head	1.260;
access;
symbols
	OPENBSD_6_1:1.247.0.4
	OPENBSD_6_1_BASE:1.247
	OPENBSD_6_0:1.234.0.4
	OPENBSD_6_0_BASE:1.234
	OPENBSD_5_9:1.229.0.2
	OPENBSD_5_9_BASE:1.229
	OPENBSD_5_8:1.213.0.2
	OPENBSD_5_8_BASE:1.213
	OPENBSD_5_7:1.208.0.2
	OPENBSD_5_7_BASE:1.208
	OPENBSD_5_6:1.198.0.4
	OPENBSD_5_6_BASE:1.198
	OPENBSD_5_5:1.192.0.4
	OPENBSD_5_5_BASE:1.192
	OPENBSD_5_4:1.188.0.2
	OPENBSD_5_4_BASE:1.188
	OPENBSD_5_3:1.181.0.2
	OPENBSD_5_3_BASE:1.181
	OPENBSD_5_2:1.176.0.4
	OPENBSD_5_2_BASE:1.176
	OPENBSD_5_1_BASE:1.176
	OPENBSD_5_1:1.176.0.2
	OPENBSD_5_0:1.173.0.2
	OPENBSD_5_0_BASE:1.173
	OPENBSD_4_9:1.172.0.2
	OPENBSD_4_9_BASE:1.172
	OPENBSD_4_8:1.168.0.2
	OPENBSD_4_8_BASE:1.168
	OPENBSD_4_7:1.166.0.2
	OPENBSD_4_7_BASE:1.166
	OPENBSD_4_6:1.166.0.4
	OPENBSD_4_6_BASE:1.166
	OPENBSD_4_5:1.160.0.2
	OPENBSD_4_5_BASE:1.160
	OPENBSD_4_4:1.157.0.2
	OPENBSD_4_4_BASE:1.157
	OPENBSD_4_3:1.151.0.2
	OPENBSD_4_3_BASE:1.151
	OPENBSD_4_2:1.148.0.2
	OPENBSD_4_2_BASE:1.148
	OPENBSD_4_1:1.145.0.2
	OPENBSD_4_1_BASE:1.145
	OPENBSD_4_0:1.144.0.2
	OPENBSD_4_0_BASE:1.144
	OPENBSD_3_9:1.121.0.2
	OPENBSD_3_9_BASE:1.121
	OPENBSD_3_8:1.119.0.2
	OPENBSD_3_8_BASE:1.119
	OPENBSD_3_7:1.116.0.2
	OPENBSD_3_7_BASE:1.116
	OPENBSD_3_6:1.115.0.2
	OPENBSD_3_6_BASE:1.115
	OPENBSD_3_5:1.112.0.2
	OPENBSD_3_5_BASE:1.112
	OPENBSD_3_4:1.109.0.2
	OPENBSD_3_4_BASE:1.109
	OPENBSD_3_3:1.102.0.2
	OPENBSD_3_3_BASE:1.102
	OPENBSD_3_2:1.97.0.2
	OPENBSD_3_2_BASE:1.97
	OPENBSD_3_1:1.93.0.2
	OPENBSD_3_1_BASE:1.93
	OPENBSD_3_0:1.70.0.2
	OPENBSD_3_0_BASE:1.70
	OPENBSD_2_9_BASE:1.61
	OPENBSD_2_9:1.61.0.2
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.32.0.2
	OPENBSD_2_7_BASE:1.32
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9;
locks; strict;
comment	@ * @;


1.260
date	2017.06.06.09.12.17;	author dtucker;	state Exp;
branches;
next	1.259;
commitid	pHx1U9iI5YIWinck;

1.259
date	2017.06.01.06.16.43;	author djm;	state Exp;
branches;
next	1.258;
commitid	MlEpXNxRfuDHk5QO;

1.258
date	2017.05.31.08.58.52;	author deraadt;	state Exp;
branches;
next	1.257;
commitid	MC62PdxBV8J69NxR;

1.257
date	2017.05.31.08.09.45;	author markus;	state Exp;
branches;
next	1.256;
commitid	U3YdddehbFcy84WY;

1.256
date	2017.05.08.06.03.39;	author djm;	state Exp;
branches;
next	1.255;
commitid	zYl6dDiIk55Mtsmt;

1.255
date	2017.05.08.00.21.36;	author djm;	state Exp;
branches;
next	1.254;
commitid	j4sluNlAt9IwEGJe;

1.254
date	2017.05.07.23.12.57;	author djm;	state Exp;
branches;
next	1.253;
commitid	rjagy2MdppXCAqQE;

1.253
date	2017.05.03.21.08.09;	author naddy;	state Exp;
branches;
next	1.252;
commitid	wlKSvaBqtNpb5VOS;

1.252
date	2017.04.30.23.28.42;	author djm;	state Exp;
branches;
next	1.251;
commitid	mCEJ1LTymp03ZrA9;

1.251
date	2017.04.30.23.26.16;	author djm;	state Exp;
branches;
next	1.250;
commitid	ur12vOD9kYPHm9ch;

1.250
date	2017.04.30.23.23.54;	author djm;	state Exp;
branches;
next	1.249;
commitid	PfkEUj5xzREsKxoN;

1.249
date	2017.04.30.23.13.25;	author djm;	state Exp;
branches;
next	1.248;
commitid	Ss7V57MvgEZubdtr;

1.248
date	2017.04.30.23.10.43;	author djm;	state Exp;
branches;
next	1.247;
commitid	I15vriCkYNtbTkea;

1.247
date	2017.03.11.13.07.35;	author markus;	state Exp;
branches;
next	1.246;
commitid	mmpC3hpgpxWS3VG4;

1.246
date	2017.02.28.06.10.08;	author djm;	state Exp;
branches;
next	1.245;
commitid	pKHc0TkS8VdyqdLm;

1.245
date	2017.02.03.23.03.33;	author djm;	state Exp;
branches;
next	1.244;
commitid	43aNO043fq67hPdQ;

1.244
date	2017.02.03.02.56.00;	author dtucker;	state Exp;
branches;
next	1.243;
commitid	FFnrndqVo2L4heRx;

1.243
date	2016.10.11.21.47.45;	author djm;	state Exp;
branches;
next	1.242;
commitid	yhU8hSEKFqFZ68zX;

1.242
date	2016.09.30.09.19.13;	author markus;	state Exp;
branches;
next	1.241;
commitid	VHQRRel9yTEUINVH;

1.241
date	2016.09.28.21.44.52;	author djm;	state Exp;
branches;
next	1.240;
commitid	dcmMFjyoLwi1xMmB;

1.240
date	2016.09.28.20.32.42;	author djm;	state Exp;
branches;
next	1.239;
commitid	TvNoQIkfkdH4jhbD;

1.239
date	2016.09.28.16.33.07;	author djm;	state Exp;
branches;
next	1.238;
commitid	e2NJzal9PUi2o22D;

1.238
date	2016.09.19.19.02.19;	author markus;	state Exp;
branches;
next	1.237;
commitid	EtE4Ip50qA5cyvN4;

1.237
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.236;
commitid	ZllbGwdb0fOmLhjK;

1.236
date	2016.09.06.09.22.56;	author markus;	state Exp;
branches;
next	1.235;
commitid	yOzUrPK8hLtAl35d;

1.235
date	2016.08.03.05.41.57;	author djm;	state Exp;
branches;
next	1.234;
commitid	otf59Ccl8VGeZugs;

1.234
date	2016.07.18.11.35.33;	author markus;	state Exp;
branches;
next	1.233;
commitid	MS3P4B74LfEvxmek;

1.233
date	2016.07.18.06.08.01;	author djm;	state Exp;
branches;
next	1.232;
commitid	e7UqbwnleMjdwHxi;

1.232
date	2016.07.15.05.01.58;	author dtucker;	state Exp;
branches;
next	1.231;
commitid	npD1qIqfl2rHEc4G;

1.231
date	2016.07.08.03.44.42;	author djm;	state Exp;
branches;
next	1.230;
commitid	oSZWAdBfrLcRSRTm;

1.230
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.229;
commitid	kr9hjdmg99uVnhW2;

1.229
date	2016.02.17.22.20.14;	author djm;	state Exp;
branches;
next	1.228;
commitid	6B4xZNrSJj0nAINd;

1.228
date	2016.02.08.10.57.07;	author djm;	state Exp;
branches;
next	1.227;
commitid	eSwtzi7BWC7eBzrp;

1.227
date	2016.02.04.23.43.48;	author djm;	state Exp;
branches;
next	1.226;
commitid	bEglGsEVtXv7SWkf;

1.226
date	2016.01.29.05.46.01;	author djm;	state Exp;
branches;
next	1.225;
commitid	r2AvyTwOqyCIWEYB;

1.225
date	2016.01.29.03.31.03;	author dtucker;	state Exp;
branches;
next	1.224;
commitid	sP7QFHGImuCgqNts;

1.224
date	2016.01.29.02.54.45;	author dtucker;	state Exp;
branches;
next	1.223;
commitid	PeK9nimTzIqJuIOX;

1.223
date	2016.01.29.02.42.46;	author dtucker;	state Exp;
branches;
next	1.222;
commitid	STT5Nj4yORviFaET;

1.222
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.221;
commitid	W9ye0gltieEl87AJ;

1.221
date	2015.12.11.04.21.12;	author mmcc;	state Exp;
branches;
next	1.220;
commitid	frWDG3VpknGQboCf;

1.220
date	2015.12.11.03.24.25;	author djm;	state Exp;
branches;
next	1.219;
commitid	ynQOJ17hX0UjbjoH;

1.219
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.218;
commitid	qST12VGCwbX5zIfM;

1.218
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.217;
commitid	K3glY441IowbrjDE;

1.217
date	2015.11.08.21.59.11;	author djm;	state Exp;
branches;
next	1.216;
commitid	261HNypXPFcIPzBb;

1.216
date	2015.10.21.11.33.03;	author gsoares;	state Exp;
branches;
next	1.215;
commitid	JgsBKOIXsDpOQs09;

1.215
date	2015.09.21.04.31.00;	author djm;	state Exp;
branches;
next	1.214;
commitid	vo8VFgzsdoOw3sUT;

1.214
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.213;
commitid	0Dp7Dy9FuNZesYo2;

1.213
date	2015.07.29.04.43.06;	author djm;	state Exp;
branches;
next	1.212;
commitid	2orWlXaVca3RWjbl;

1.212
date	2015.05.01.07.10.01;	author djm;	state Exp;
branches;
next	1.211;
commitid	OeI8NmAwBXD07SOv;

1.211
date	2015.04.27.01.52.30;	author djm;	state Exp;
branches;
next	1.210;
commitid	YUkhAUcfWvVRd3vD;

1.210
date	2015.03.24.20.10.08;	author markus;	state Exp;
branches;
next	1.209;
commitid	T7BdQJOWbu3ywMEn;

1.209
date	2015.03.11.00.48.39;	author jsg;	state Exp;
branches;
next	1.208;
commitid	8ge8SjhdLvPXxx79;

1.208
date	2015.02.13.18.57.00;	author markus;	state Exp;
branches;
next	1.207;
commitid	FXpQflsh1UdymeRb;

1.207
date	2015.02.11.01.20.38;	author djm;	state Exp;
branches;
next	1.206;
commitid	7GVop0gSk369J9GM;

1.206
date	2015.02.09.23.22.37;	author jsg;	state Exp;
branches;
next	1.205;
commitid	UavtgQ8UfYIDbCcY;

1.205
date	2015.01.30.01.13.33;	author djm;	state Exp;
branches;
next	1.204;
commitid	BuE3vBiYMFEA1E3u;

1.204
date	2015.01.28.21.15.47;	author djm;	state Exp;
branches;
next	1.203;
commitid	Iqzpomw0YO4gLwGY;

1.203
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.202;
commitid	cBx23BaCk6gYBpRj;

1.202
date	2015.01.19.20.30.23;	author markus;	state Exp;
branches;
next	1.201;
commitid	74WAJgdQCKxDqTwt;

1.201
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.200;
commitid	UHlhoIB5NMb8eAPm;

1.200
date	2015.01.13.19.31.40;	author markus;	state Exp;
branches;
next	1.199;
commitid	sCqZ9ho1RfL2Vg0U;

1.199
date	2014.10.24.02.01.20;	author lteo;	state Exp;
branches;
next	1.198;
commitid	K0sGF4uE2LYJ8DMA;

1.198
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.197;
commitid	z7plx8Gkj6l2sxem;

1.197
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.196;
commitid	1h9UxAQmwdaqUzyX;

1.196
date	2014.05.03.17.20.34;	author markus;	state Exp;
branches;
next	1.195;

1.195
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.194;

1.194
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.193;

1.193
date	2014.04.01.05.32.57;	author djm;	state Exp;
branches;
next	1.192;

1.192
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.191;

1.191
date	2013.12.06.13.34.54;	author markus;	state Exp;
branches;
next	1.190;

1.190
date	2013.11.21.00.45.44;	author djm;	state Exp;
branches;
next	1.189;

1.189
date	2013.11.08.00.39.15;	author djm;	state Exp;
branches;
next	1.188;

1.188
date	2013.07.12.00.19.58;	author djm;	state Exp;
branches
	1.188.2.1;
next	1.187;

1.187
date	2013.06.01.13.15.52;	author dtucker;	state Exp;
branches;
next	1.186;

1.186
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.185;

1.185
date	2013.05.16.04.09.13;	author dtucker;	state Exp;
branches;
next	1.184;

1.184
date	2013.05.16.02.00.34;	author dtucker;	state Exp;
branches;
next	1.183;

1.183
date	2013.04.19.01.06.50;	author djm;	state Exp;
branches;
next	1.182;

1.182
date	2013.04.11.02.27.50;	author djm;	state Exp;
branches;
next	1.181;

1.181
date	2013.02.10.23.35.24;	author djm;	state Exp;
branches
	1.181.2.1;
next	1.180;

1.180
date	2013.01.08.18.49.04;	author markus;	state Exp;
branches;
next	1.179;

1.179
date	2012.12.12.16.45.52;	author markus;	state Exp;
branches;
next	1.178;

1.178
date	2012.12.11.22.31.18;	author markus;	state Exp;
branches;
next	1.177;

1.177
date	2012.09.17.13.04.11;	author markus;	state Exp;
branches;
next	1.176;

1.176
date	2012.01.25.19.40.09;	author markus;	state Exp;
branches;
next	1.175;

1.175
date	2012.01.25.19.26.43;	author markus;	state Exp;
branches;
next	1.174;

1.174
date	2011.12.07.05.44.38;	author djm;	state Exp;
branches;
next	1.173;

1.173
date	2011.05.06.21.14.05;	author djm;	state Exp;
branches;
next	1.172;

1.172
date	2010.11.13.23.27.50;	author djm;	state Exp;
branches;
next	1.171;

1.171
date	2010.11.05.02.46.47;	author djm;	state Exp;
branches;
next	1.170;

1.170
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.169;

1.169
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.168;

1.168
date	2010.07.13.23.13.16;	author djm;	state Exp;
branches;
next	1.167;

1.167
date	2010.07.13.11.52.06;	author djm;	state Exp;
branches;
next	1.166;

1.166
date	2009.06.27.09.29.06;	author andreas;	state Exp;
branches;
next	1.165;

1.165
date	2009.06.12.20.58.32;	author andreas;	state Exp;
branches;
next	1.164;

1.164
date	2009.06.12.20.43.22;	author andreas;	state Exp;
branches;
next	1.163;

1.163
date	2009.05.28.16.50.16;	author andreas;	state Exp;
branches;
next	1.162;

1.162
date	2009.05.27.06.36.07;	author andreas;	state Exp;
branches;
next	1.161;

1.161
date	2009.05.25.06.48.01;	author andreas;	state Exp;
branches;
next	1.160;

1.160
date	2009.02.13.11.50.21;	author markus;	state Exp;
branches;
next	1.159;

1.159
date	2009.01.26.09.58.15;	author markus;	state Exp;
branches;
next	1.158;

1.158
date	2008.11.21.15.47.38;	author markus;	state Exp;
branches;
next	1.157;

1.157
date	2008.07.10.18.08.11;	author markus;	state Exp;
branches;
next	1.156;

1.156
date	2008.07.04.23.08.25;	author djm;	state Exp;
branches;
next	1.155;

1.155
date	2008.06.13.09.44.36;	author deraadt;	state Exp;
branches;
next	1.154;

1.154
date	2008.06.12.20.38.28;	author dtucker;	state Exp;
branches;
next	1.153;

1.153
date	2008.05.19.06.14.02;	author djm;	state Exp;
branches;
next	1.152;

1.152
date	2008.05.08.06.59.01;	author markus;	state Exp;
branches;
next	1.151;

1.151
date	2008.02.22.20.44.02;	author dtucker;	state Exp;
branches;
next	1.150;

1.150
date	2008.01.23.01.56.54;	author dtucker;	state Exp;
branches;
next	1.149;

1.149
date	2007.12.28.15.32.24;	author dtucker;	state Exp;
branches;
next	1.148;

1.148
date	2007.06.07.19.37.34;	author pvalchev;	state Exp;
branches;
next	1.147;

1.147
date	2007.06.05.06.52.37;	author djm;	state Exp;
branches;
next	1.146;

1.146
date	2007.05.31.23.34.29;	author djm;	state Exp;
branches;
next	1.145;

1.145
date	2006.09.19.21.14.08;	author markus;	state Exp;
branches;
next	1.144;

1.144
date	2006.09.16.19.53.37;	author djm;	state Exp;
branches
	1.144.2.1;
next	1.143;

1.143
date	2006.08.05.08.34.04;	author dtucker;	state Exp;
branches;
next	1.142;

1.142
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.141;

1.141
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.140;

1.140
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.139;

1.139
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.138;

1.138
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.137;

1.137
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.136;

1.136
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.135;

1.135
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.134;

1.134
date	2006.07.10.16.37.36;	author stevesk;	state Exp;
branches;
next	1.133;

1.133
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.132;

1.132
date	2006.07.05.02.42.09;	author stevesk;	state Exp;
branches;
next	1.131;

1.131
date	2006.03.30.09.58.16;	author djm;	state Exp;
branches;
next	1.130;

1.130
date	2006.03.25.18.56.55;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2006.03.25.18.29.35;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.127;

1.127
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.126;

1.126
date	2006.03.22.21.27.15;	author djm;	state Exp;
branches;
next	1.125;

1.125
date	2006.03.20.18.48.34;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2006.03.20.17.10.19;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2006.03.13.08.33.00;	author dtucker;	state Exp;
branches;
next	1.121;

1.121
date	2006.02.08.14.38.18;	author stevesk;	state Exp;
branches
	1.121.2.1;
next	1.120;

1.120
date	2005.10.30.08.52.17;	author djm;	state Exp;
branches;
next	1.119;

1.119
date	2005.07.28.17.36.22;	author markus;	state Exp;
branches
	1.119.2.1;
next	1.118;

1.118
date	2005.07.25.11.59.39;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.116;

1.116
date	2004.10.20.11.48.53;	author markus;	state Exp;
branches
	1.116.2.1;
next	1.115;

1.115
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches
	1.115.2.1;
next	1.114;

1.114
date	2004.06.14.01.44.39;	author djm;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches
	1.112.2.1;
next	1.111;

1.111
date	2003.09.19.11.33.09;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2003.09.19.09.02.02;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2003.07.10.14.42.28;	author markus;	state Exp;
branches
	1.109.2.1;
next	1.108;

1.108
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2003.06.10.22.20.52;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.02.09.48.07;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2003.04.01.10.22.21;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.01.10.10.23;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2002.12.10.19.47.14;	author markus;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2002.12.10.19.26.50;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2002.11.21.22.45.31;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2002.11.04.10.09.51;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2002.10.23.10.32.13;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2002.07.04.08.12.15;	author deraadt;	state Exp;
branches
	1.97.2.1;
next	1.96;

1.96
date	2002.06.23.21.10.02;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2002.06.19.18.01.00;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2002.06.04.23.02.06;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2002.03.24.16.01.13;	author markus;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2002.03.18.17.16.38;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2002.02.27.21.23.13;	author stevesk;	state Exp;
branches;
next	1.89;

1.89
date	2002.02.24.16.58.32;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2002.02.14.23.41.01;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2002.01.24.21.13.23;	author stevesk;	state Exp;
branches;
next	1.86;

1.86
date	2002.01.24.21.09.25;	author stevesk;	state Exp;
branches;
next	1.85;

1.85
date	2002.01.18.18.14.17;	author stevesk;	state Exp;
branches;
next	1.84;

1.84
date	2002.01.11.10.31.05;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2001.12.29.21.56.01;	author stevesk;	state Exp;
branches;
next	1.82;

1.82
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2001.12.28.14.13.13;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.12.28.13.57.33;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2001.12.19.17.16.13;	author stevesk;	state Exp;
branches;
next	1.75;

1.75
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2001.12.05.03.56.39;	author itojun;	state Exp;
branches;
next	1.72;

1.72
date	2001.11.10.13.37.20;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2001.11.07.16.03.17;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2001.09.27.11.59.37;	author markus;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2001.06.25.08.25.38;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.20.13.56.39;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.12.16.11.26;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.07.20.23.04;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2001.05.31.10.30.16;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.05.30.12.55.11;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.28.23.58.35;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.04.05.10.42.51;	author markus;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2001.04.05.10.39.03;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2001.04.04.23.09.18;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.04.04.09.48.34;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.04.03.23.32.12;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.03.03.21.41.07;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.01.02.45.10;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2001.02.28.21.27.47;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2001.02.28.09.57.06;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2001.02.27.10.35.27;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2001.02.12.22.56.09;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.11.12.59.25;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2001.02.04.15.32.24;	author stevesk;	state Exp;
branches;
next	1.47;

1.47
date	2001.02.04.13.30.12;	author stevesk;	state Exp;
branches;
next	1.46;

1.46
date	2001.01.21.19.05.53;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.13.18.36.45;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.13.18.32.50;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.09.21.19.50;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.02.20.41.02;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.12.19.23.17.57;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.06.22.58.15;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.12.14.21.12;	author markus;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.03.17.59.57;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.07.20.27.52;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.19.02.17.12;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.20.01.39.43;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.04.22.22.43;	author markus;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.05.01.07.40.03;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.30.09.12.07;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.14.10.30.32;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.14.10.09.15;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.04.21.37.27;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.03.20.12.55;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.03.07.07.15;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.28.20.31.27;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.05.10.13.11;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2000.01.22.20.20.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.20.15.15.18;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.04.00.07.59;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.12.15.20.03.23;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	99.12.02.20.16.34;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.11.24.19.53.48;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.11.19.19.58.18;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.11.15.21.38.54;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.11.02.19.42.36;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.10.05.01.23.54;	author dugsong;	state Exp;
branches;
next	1.8;

1.8
date	99.10.03.19.22.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.10.01.18.18.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.05.53.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.30.05.11.29;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.30.05.03.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.18.16.19;	author dugsong;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.36;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.36;	author deraadt;	state Exp;
branches;
next	;

1.32.2.1
date	2000.09.01.18.23.21;	author jason;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2000.11.08.21.31.01;	author jason;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2001.03.12.15.44.12;	author jason;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2001.03.21.18.52.55;	author jason;	state Exp;
branches;
next	;

1.38.2.1
date	2001.02.16.20.13.08;	author jason;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2001.02.19.17.19.09;	author jason;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2001.03.21.19.46.26;	author jason;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2001.05.07.21.09.31;	author jason;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.61.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.61.2.4;

1.61.2.4
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.61.2.5;

1.61.2.5
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.70.2.1
date	2001.11.14.03.24.38;	author jason;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.70.2.3;

1.70.2.3
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.70.2.4;

1.70.2.4
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.70.2.5;

1.70.2.5
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	1.70.2.6;

1.70.2.6
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.93.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.93.2.2;

1.93.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.93.2.3;

1.93.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.97.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.97.2.2;

1.97.2.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.102.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.102.2.2;

1.102.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.109.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.109.2.2;

1.109.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.112.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.112.2.2;

1.112.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.115.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.115.2.2;

1.115.2.2
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.116.2.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	1.116.2.2;

1.116.2.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.119.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.119.2.2;

1.119.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.119.2.3;

1.119.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.121.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.121.2.2;

1.121.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.144.2.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;

1.181.2.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.188.2.1
date	2013.11.08.01.33.56;	author djm;	state Exp;
branches;
next	;


desc
@@


1.260
log
@Fix compression output stats broken in rev 1.201.  Patch originally by
Russell Coker via Debian bug #797964 and Christoph Biedl.  ok djm@@
@
text
@/* $OpenBSD: packet.c,v 1.259 2017/06/01 06:16:43 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * This file contains code implementing the packet protocol and communication
 * with the other side.  This same code is used both on client and server side.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * SSH2 packet format added by Markus Friedl.
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#include <errno.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <signal.h>
#include <time.h>

#include <zlib.h>

#include "buffer.h"	/* typedefs XXX */
#include "key.h"	/* typedefs XXX */

#include "xmalloc.h"
#include "crc32.h"
#include "compat.h"
#include "ssh2.h"
#include "cipher.h"
#include "sshkey.h"
#include "kex.h"
#include "digest.h"
#include "mac.h"
#include "log.h"
#include "canohost.h"
#include "misc.h"
#include "channels.h"
#include "ssh.h"
#include "packet.h"
#include "ssherr.h"
#include "sshbuf.h"

#ifdef PACKET_DEBUG
#define DBG(x) x
#else
#define DBG(x)
#endif

#define PACKET_MAX_SIZE (256 * 1024)

struct packet_state {
	u_int32_t seqnr;
	u_int32_t packets;
	u_int64_t blocks;
	u_int64_t bytes;
};

struct packet {
	TAILQ_ENTRY(packet) next;
	u_char type;
	struct sshbuf *payload;
};

struct session_state {
	/*
	 * This variable contains the file descriptors used for
	 * communicating with the other side.  connection_in is used for
	 * reading; connection_out for writing.  These can be the same
	 * descriptor, in which case it is assumed to be a socket.
	 */
	int connection_in;
	int connection_out;

	/* Protocol flags for the remote side. */
	u_int remote_protocol_flags;

	/* Encryption context for receiving data.  Only used for decryption. */
	struct sshcipher_ctx *receive_context;

	/* Encryption context for sending data.  Only used for encryption. */
	struct sshcipher_ctx *send_context;

	/* Buffer for raw input data from the socket. */
	struct sshbuf *input;

	/* Buffer for raw output data going to the socket. */
	struct sshbuf *output;

	/* Buffer for the partial outgoing packet being constructed. */
	struct sshbuf *outgoing_packet;

	/* Buffer for the incoming packet currently being processed. */
	struct sshbuf *incoming_packet;

	/* Scratch buffer for packet compression/decompression. */
	struct sshbuf *compression_buffer;

	/* Incoming/outgoing compression dictionaries */
	z_stream compression_in_stream;
	z_stream compression_out_stream;
	int compression_in_started;
	int compression_out_started;
	int compression_in_failures;
	int compression_out_failures;

	/*
	 * Flag indicating whether packet compression/decompression is
	 * enabled.
	 */
	int packet_compression;

	/* default maximum packet size */
	u_int max_packet_size;

	/* Flag indicating whether this module has been initialized. */
	int initialized;

	/* Set to true if the connection is interactive. */
	int interactive_mode;

	/* Set to true if we are the server side. */
	int server_side;

	/* Set to true if we are authenticated. */
	int after_authentication;

	int keep_alive_timeouts;

	/* The maximum time that we will wait to send or receive a packet */
	int packet_timeout_ms;

	/* Session key information for Encryption and MAC */
	struct newkeys *newkeys[MODE_MAX];
	struct packet_state p_read, p_send;

	/* Volume-based rekeying */
	u_int64_t max_blocks_in, max_blocks_out, rekey_limit;

	/* Time-based rekeying */
	u_int32_t rekey_interval;	/* how often in seconds */
	time_t rekey_time;	/* time of last rekeying */

	/* roundup current message to extra_pad bytes */
	u_char extra_pad;

	/* XXX discard incoming data after MAC error */
	u_int packet_discard;
	size_t packet_discard_mac_already;
	struct sshmac *packet_discard_mac;

	/* Used in packet_read_poll2() */
	u_int packlen;

	/* Used in packet_send2 */
	int rekeying;

	/* Used in ssh_packet_send_mux() */
	int mux;

	/* Used in packet_set_interactive */
	int set_interactive_called;

	/* Used in packet_set_maxsize */
	int set_maxsize_called;

	/* One-off warning about weak ciphers */
	int cipher_warning_done;

	/* Hook for fuzzing inbound packets */
	ssh_packet_hook_fn *hook_in;
	void *hook_in_ctx;

	TAILQ_HEAD(, packet) outgoing;
};

struct ssh *
ssh_alloc_session_state(void)
{
	struct ssh *ssh = NULL;
	struct session_state *state = NULL;

	if ((ssh = calloc(1, sizeof(*ssh))) == NULL ||
	    (state = calloc(1, sizeof(*state))) == NULL ||
	    (state->input = sshbuf_new()) == NULL ||
	    (state->output = sshbuf_new()) == NULL ||
	    (state->outgoing_packet = sshbuf_new()) == NULL ||
	    (state->incoming_packet = sshbuf_new()) == NULL)
		goto fail;
	TAILQ_INIT(&state->outgoing);
	TAILQ_INIT(&ssh->private_keys);
	TAILQ_INIT(&ssh->public_keys);
	state->connection_in = -1;
	state->connection_out = -1;
	state->max_packet_size = 32768;
	state->packet_timeout_ms = -1;
	state->p_send.packets = state->p_read.packets = 0;
	state->initialized = 1;
	/*
	 * ssh_packet_send2() needs to queue packets until
	 * we've done the initial key exchange.
	 */
	state->rekeying = 1;
	ssh->state = state;
	return ssh;
 fail:
	if (state) {
		sshbuf_free(state->input);
		sshbuf_free(state->output);
		sshbuf_free(state->incoming_packet);
		sshbuf_free(state->outgoing_packet);
		free(state);
	}
	free(ssh);
	return NULL;
}

void
ssh_packet_set_input_hook(struct ssh *ssh, ssh_packet_hook_fn *hook, void *ctx)
{
	ssh->state->hook_in = hook;
	ssh->state->hook_in_ctx = ctx;
}

/* Returns nonzero if rekeying is in progress */
int
ssh_packet_is_rekeying(struct ssh *ssh)
{
	return ssh->state->rekeying ||
	    (ssh->kex != NULL && ssh->kex->done == 0);
}

/*
 * Sets the descriptors used for communication.
 */
struct ssh *
ssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)
{
	struct session_state *state;
	const struct sshcipher *none = cipher_by_name("none");
	int r;

	if (none == NULL) {
		error("%s: cannot load cipher 'none'", __func__);
		return NULL;
	}
	if (ssh == NULL)
		ssh = ssh_alloc_session_state();
	if (ssh == NULL) {
		error("%s: cound not allocate state", __func__);
		return NULL;
	}
	state = ssh->state;
	state->connection_in = fd_in;
	state->connection_out = fd_out;
	if ((r = cipher_init(&state->send_context, none,
	    (const u_char *)"", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||
	    (r = cipher_init(&state->receive_context, none,
	    (const u_char *)"", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {
		error("%s: cipher_init failed: %s", __func__, ssh_err(r));
		free(ssh); /* XXX need ssh_free_session_state? */
		return NULL;
	}
	state->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;
	/*
	 * Cache the IP address of the remote connection for use in error
	 * messages that might be generated after the connection has closed.
	 */
	(void)ssh_remote_ipaddr(ssh);
	return ssh;
}

void
ssh_packet_set_timeout(struct ssh *ssh, int timeout, int count)
{
	struct session_state *state = ssh->state;

	if (timeout <= 0 || count <= 0) {
		state->packet_timeout_ms = -1;
		return;
	}
	if ((INT_MAX / 1000) / count < timeout)
		state->packet_timeout_ms = INT_MAX;
	else
		state->packet_timeout_ms = timeout * count * 1000;
}

void
ssh_packet_set_mux(struct ssh *ssh)
{
	ssh->state->mux = 1;
	ssh->state->rekeying = 0;
}

int
ssh_packet_get_mux(struct ssh *ssh)
{
	return ssh->state->mux;
}

int
ssh_packet_set_log_preamble(struct ssh *ssh, const char *fmt, ...)
{
	va_list args;
	int r;

	free(ssh->log_preamble);
	if (fmt == NULL)
		ssh->log_preamble = NULL;
	else {
		va_start(args, fmt);
		r = vasprintf(&ssh->log_preamble, fmt, args);
		va_end(args);
		if (r < 0 || ssh->log_preamble == NULL)
			return SSH_ERR_ALLOC_FAIL;
	}
	return 0;
}

int
ssh_packet_stop_discard(struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	int r;

	if (state->packet_discard_mac) {
		char buf[1024];
		size_t dlen = PACKET_MAX_SIZE;

		if (dlen > state->packet_discard_mac_already)
			dlen -= state->packet_discard_mac_already;
		memset(buf, 'a', sizeof(buf));
		while (sshbuf_len(state->incoming_packet) < dlen)
			if ((r = sshbuf_put(state->incoming_packet, buf,
			    sizeof(buf))) != 0)
				return r;
		(void) mac_compute(state->packet_discard_mac,
		    state->p_read.seqnr,
		    sshbuf_ptr(state->incoming_packet), dlen,
		    NULL, 0);
	}
	logit("Finished discarding for %.200s port %d",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
	return SSH_ERR_MAC_INVALID;
}

static int
ssh_packet_start_discard(struct ssh *ssh, struct sshenc *enc,
    struct sshmac *mac, size_t mac_already, u_int discard)
{
	struct session_state *state = ssh->state;
	int r;

	if (enc == NULL || !cipher_is_cbc(enc->cipher) || (mac && mac->etm)) {
		if ((r = sshpkt_disconnect(ssh, "Packet corrupt")) != 0)
			return r;
		return SSH_ERR_MAC_INVALID;
	}
	/*
	 * Record number of bytes over which the mac has already
	 * been computed in order to minimize timing attacks.
	 */
	if (mac && mac->enabled) {
		state->packet_discard_mac = mac;
		state->packet_discard_mac_already = mac_already;
	}
	if (sshbuf_len(state->input) >= discard)
		return ssh_packet_stop_discard(ssh);
	state->packet_discard = discard - sshbuf_len(state->input);
	return 0;
}

/* Returns 1 if remote host is connected via socket, 0 if not. */

int
ssh_packet_connection_is_on_socket(struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	struct sockaddr_storage from, to;
	socklen_t fromlen, tolen;

	if (state->connection_in == -1 || state->connection_out == -1)
		return 0;

	/* filedescriptors in and out are the same, so it's a socket */
	if (state->connection_in == state->connection_out)
		return 1;
	fromlen = sizeof(from);
	memset(&from, 0, sizeof(from));
	if (getpeername(state->connection_in, (struct sockaddr *)&from,
	    &fromlen) < 0)
		return 0;
	tolen = sizeof(to);
	memset(&to, 0, sizeof(to));
	if (getpeername(state->connection_out, (struct sockaddr *)&to,
	    &tolen) < 0)
		return 0;
	if (fromlen != tolen || memcmp(&from, &to, fromlen) != 0)
		return 0;
	if (from.ss_family != AF_INET && from.ss_family != AF_INET6)
		return 0;
	return 1;
}

void
ssh_packet_get_bytes(struct ssh *ssh, u_int64_t *ibytes, u_int64_t *obytes)
{
	if (ibytes)
		*ibytes = ssh->state->p_read.bytes;
	if (obytes)
		*obytes = ssh->state->p_send.bytes;
}

int
ssh_packet_connection_af(struct ssh *ssh)
{
	struct sockaddr_storage to;
	socklen_t tolen = sizeof(to);

	memset(&to, 0, sizeof(to));
	if (getsockname(ssh->state->connection_out, (struct sockaddr *)&to,
	    &tolen) < 0)
		return 0;
	return to.ss_family;
}

/* Sets the connection into non-blocking mode. */

void
ssh_packet_set_nonblocking(struct ssh *ssh)
{
	/* Set the socket into non-blocking mode. */
	set_nonblock(ssh->state->connection_in);

	if (ssh->state->connection_out != ssh->state->connection_in)
		set_nonblock(ssh->state->connection_out);
}

/* Returns the socket used for reading. */

int
ssh_packet_get_connection_in(struct ssh *ssh)
{
	return ssh->state->connection_in;
}

/* Returns the descriptor used for writing. */

int
ssh_packet_get_connection_out(struct ssh *ssh)
{
	return ssh->state->connection_out;
}

/*
 * Returns the IP-address of the remote host as a string.  The returned
 * string must not be freed.
 */

const char *
ssh_remote_ipaddr(struct ssh *ssh)
{
	const int sock = ssh->state->connection_in;

	/* Check whether we have cached the ipaddr. */
	if (ssh->remote_ipaddr == NULL) {
		if (ssh_packet_connection_is_on_socket(ssh)) {
			ssh->remote_ipaddr = get_peer_ipaddr(sock);
			ssh->remote_port = get_peer_port(sock);
			ssh->local_ipaddr = get_local_ipaddr(sock);
			ssh->local_port = get_local_port(sock);
		} else {
			ssh->remote_ipaddr = strdup("UNKNOWN");
			ssh->remote_port = 65535;
			ssh->local_ipaddr = strdup("UNKNOWN");
			ssh->local_port = 65535;
		}
	}
	return ssh->remote_ipaddr;
}

/* Returns the port number of the remote host. */

int
ssh_remote_port(struct ssh *ssh)
{
	(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */
	return ssh->remote_port;
}

/*
 * Returns the IP-address of the local host as a string.  The returned
 * string must not be freed.
 */

const char *
ssh_local_ipaddr(struct ssh *ssh)
{
	(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */
	return ssh->local_ipaddr;
}

/* Returns the port number of the local host. */

int
ssh_local_port(struct ssh *ssh)
{
	(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */
	return ssh->local_port;
}

/* Closes the connection and clears and frees internal data structures. */

static void
ssh_packet_close_internal(struct ssh *ssh, int do_close)
{
	struct session_state *state = ssh->state;
	u_int mode;

	if (!state->initialized)
		return;
	state->initialized = 0;
	if (do_close) {
		if (state->connection_in == state->connection_out) {
			close(state->connection_out);
		} else {
			close(state->connection_in);
			close(state->connection_out);
		}
	}
	sshbuf_free(state->input);
	sshbuf_free(state->output);
	sshbuf_free(state->outgoing_packet);
	sshbuf_free(state->incoming_packet);
	for (mode = 0; mode < MODE_MAX; mode++) {
		kex_free_newkeys(state->newkeys[mode]);	/* current keys */
		state->newkeys[mode] = NULL;
		ssh_clear_newkeys(ssh, mode);		/* next keys */
	}
	/* comression state is in shared mem, so we can only release it once */
	if (do_close && state->compression_buffer) {
		sshbuf_free(state->compression_buffer);
		if (state->compression_out_started) {
			z_streamp stream = &state->compression_out_stream;
			debug("compress outgoing: "
			    "raw data %llu, compressed %llu, factor %.2f",
				(unsigned long long)stream->total_in,
				(unsigned long long)stream->total_out,
				stream->total_in == 0 ? 0.0 :
				(double) stream->total_out / stream->total_in);
			if (state->compression_out_failures == 0)
				deflateEnd(stream);
		}
		if (state->compression_in_started) {
			z_streamp stream = &state->compression_in_stream;
			debug("compress incoming: "
			    "raw data %llu, compressed %llu, factor %.2f",
			    (unsigned long long)stream->total_out,
			    (unsigned long long)stream->total_in,
			    stream->total_out == 0 ? 0.0 :
			    (double) stream->total_in / stream->total_out);
			if (state->compression_in_failures == 0)
				inflateEnd(stream);
		}
	}
	cipher_free(state->send_context);
	cipher_free(state->receive_context);
	state->send_context = state->receive_context = NULL;
	if (do_close) {
		free(ssh->remote_ipaddr);
		ssh->remote_ipaddr = NULL;
		free(ssh->state);
		ssh->state = NULL;
	}
}

void
ssh_packet_close(struct ssh *ssh)
{
	ssh_packet_close_internal(ssh, 1);
}

void
ssh_packet_clear_keys(struct ssh *ssh)
{
	ssh_packet_close_internal(ssh, 0);
}

/* Sets remote side protocol flags. */

void
ssh_packet_set_protocol_flags(struct ssh *ssh, u_int protocol_flags)
{
	ssh->state->remote_protocol_flags = protocol_flags;
}

/* Returns the remote protocol flags set earlier by the above function. */

u_int
ssh_packet_get_protocol_flags(struct ssh *ssh)
{
	return ssh->state->remote_protocol_flags;
}

/*
 * Starts packet compression from the next packet on in both directions.
 * Level is compression level 1 (fastest) - 9 (slow, best) as in gzip.
 */

static int
ssh_packet_init_compression(struct ssh *ssh)
{
	if (!ssh->state->compression_buffer &&
	   ((ssh->state->compression_buffer = sshbuf_new()) == NULL))
		return SSH_ERR_ALLOC_FAIL;
	return 0;
}

static int
start_compression_out(struct ssh *ssh, int level)
{
	if (level < 1 || level > 9)
		return SSH_ERR_INVALID_ARGUMENT;
	debug("Enabling compression at level %d.", level);
	if (ssh->state->compression_out_started == 1)
		deflateEnd(&ssh->state->compression_out_stream);
	switch (deflateInit(&ssh->state->compression_out_stream, level)) {
	case Z_OK:
		ssh->state->compression_out_started = 1;
		break;
	case Z_MEM_ERROR:
		return SSH_ERR_ALLOC_FAIL;
	default:
		return SSH_ERR_INTERNAL_ERROR;
	}
	return 0;
}

static int
start_compression_in(struct ssh *ssh)
{
	if (ssh->state->compression_in_started == 1)
		inflateEnd(&ssh->state->compression_in_stream);
	switch (inflateInit(&ssh->state->compression_in_stream)) {
	case Z_OK:
		ssh->state->compression_in_started = 1;
		break;
	case Z_MEM_ERROR:
		return SSH_ERR_ALLOC_FAIL;
	default:
		return SSH_ERR_INTERNAL_ERROR;
	}
	return 0;
}

int
ssh_packet_start_compression(struct ssh *ssh, int level)
{
	int r;

	if (ssh->state->packet_compression)
		return SSH_ERR_INTERNAL_ERROR;
	ssh->state->packet_compression = 1;
	if ((r = ssh_packet_init_compression(ssh)) != 0 ||
	    (r = start_compression_in(ssh)) != 0 ||
	    (r = start_compression_out(ssh, level)) != 0)
		return r;
	return 0;
}

/* XXX remove need for separate compression buffer */
static int
compress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)
{
	u_char buf[4096];
	int r, status;

	if (ssh->state->compression_out_started != 1)
		return SSH_ERR_INTERNAL_ERROR;

	/* This case is not handled below. */
	if (sshbuf_len(in) == 0)
		return 0;

	/* Input is the contents of the input buffer. */
	if ((ssh->state->compression_out_stream.next_in =
	    sshbuf_mutable_ptr(in)) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	ssh->state->compression_out_stream.avail_in = sshbuf_len(in);

	/* Loop compressing until deflate() returns with avail_out != 0. */
	do {
		/* Set up fixed-size output buffer. */
		ssh->state->compression_out_stream.next_out = buf;
		ssh->state->compression_out_stream.avail_out = sizeof(buf);

		/* Compress as much data into the buffer as possible. */
		status = deflate(&ssh->state->compression_out_stream,
		    Z_PARTIAL_FLUSH);
		switch (status) {
		case Z_MEM_ERROR:
			return SSH_ERR_ALLOC_FAIL;
		case Z_OK:
			/* Append compressed data to output_buffer. */
			if ((r = sshbuf_put(out, buf, sizeof(buf) -
			    ssh->state->compression_out_stream.avail_out)) != 0)
				return r;
			break;
		case Z_STREAM_ERROR:
		default:
			ssh->state->compression_out_failures++;
			return SSH_ERR_INVALID_FORMAT;
		}
	} while (ssh->state->compression_out_stream.avail_out == 0);
	return 0;
}

static int
uncompress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)
{
	u_char buf[4096];
	int r, status;

	if (ssh->state->compression_in_started != 1)
		return SSH_ERR_INTERNAL_ERROR;

	if ((ssh->state->compression_in_stream.next_in =
	    sshbuf_mutable_ptr(in)) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	ssh->state->compression_in_stream.avail_in = sshbuf_len(in);

	for (;;) {
		/* Set up fixed-size output buffer. */
		ssh->state->compression_in_stream.next_out = buf;
		ssh->state->compression_in_stream.avail_out = sizeof(buf);

		status = inflate(&ssh->state->compression_in_stream,
		    Z_PARTIAL_FLUSH);
		switch (status) {
		case Z_OK:
			if ((r = sshbuf_put(out, buf, sizeof(buf) -
			    ssh->state->compression_in_stream.avail_out)) != 0)
				return r;
			break;
		case Z_BUF_ERROR:
			/*
			 * Comments in zlib.h say that we should keep calling
			 * inflate() until we get an error.  This appears to
			 * be the error that we get.
			 */
			return 0;
		case Z_DATA_ERROR:
			return SSH_ERR_INVALID_FORMAT;
		case Z_MEM_ERROR:
			return SSH_ERR_ALLOC_FAIL;
		case Z_STREAM_ERROR:
		default:
			ssh->state->compression_in_failures++;
			return SSH_ERR_INTERNAL_ERROR;
		}
	}
	/* NOTREACHED */
}

void
ssh_clear_newkeys(struct ssh *ssh, int mode)
{
	if (ssh->kex && ssh->kex->newkeys[mode]) {
		kex_free_newkeys(ssh->kex->newkeys[mode]);
		ssh->kex->newkeys[mode] = NULL;
	}
}

int
ssh_set_newkeys(struct ssh *ssh, int mode)
{
	struct session_state *state = ssh->state;
	struct sshenc *enc;
	struct sshmac *mac;
	struct sshcomp *comp;
	struct sshcipher_ctx **ccp;
	struct packet_state *ps;
	u_int64_t *max_blocks;
	const char *wmsg;
	int r, crypt_type;

	debug2("set_newkeys: mode %d", mode);

	if (mode == MODE_OUT) {
		ccp = &state->send_context;
		crypt_type = CIPHER_ENCRYPT;
		ps = &state->p_send;
		max_blocks = &state->max_blocks_out;
	} else {
		ccp = &state->receive_context;
		crypt_type = CIPHER_DECRYPT;
		ps = &state->p_read;
		max_blocks = &state->max_blocks_in;
	}
	if (state->newkeys[mode] != NULL) {
		debug("set_newkeys: rekeying, input %llu bytes %llu blocks, "
		   "output %llu bytes %llu blocks",
		   (unsigned long long)state->p_read.bytes,
		   (unsigned long long)state->p_read.blocks,
		   (unsigned long long)state->p_send.bytes,
		   (unsigned long long)state->p_send.blocks);
		cipher_free(*ccp);
		*ccp = NULL;
		kex_free_newkeys(state->newkeys[mode]);
		state->newkeys[mode] = NULL;
	}
	/* note that both bytes and the seqnr are not reset */
	ps->packets = ps->blocks = 0;
	/* move newkeys from kex to state */
	if ((state->newkeys[mode] = ssh->kex->newkeys[mode]) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	ssh->kex->newkeys[mode] = NULL;
	enc  = &state->newkeys[mode]->enc;
	mac  = &state->newkeys[mode]->mac;
	comp = &state->newkeys[mode]->comp;
	if (cipher_authlen(enc->cipher) == 0) {
		if ((r = mac_init(mac)) != 0)
			return r;
	}
	mac->enabled = 1;
	DBG(debug("cipher_init_context: %d", mode));
	if ((r = cipher_init(ccp, enc->cipher, enc->key, enc->key_len,
	    enc->iv, enc->iv_len, crypt_type)) != 0)
		return r;
	if (!state->cipher_warning_done &&
	    (wmsg = cipher_warning_message(*ccp)) != NULL) {
		error("Warning: %s", wmsg);
		state->cipher_warning_done = 1;
	}
	/* Deleting the keys does not gain extra security */
	/* explicit_bzero(enc->iv,  enc->block_size);
	   explicit_bzero(enc->key, enc->key_len);
	   explicit_bzero(mac->key, mac->key_len); */
	if ((comp->type == COMP_ZLIB ||
	    (comp->type == COMP_DELAYED &&
	     state->after_authentication)) && comp->enabled == 0) {
		if ((r = ssh_packet_init_compression(ssh)) < 0)
			return r;
		if (mode == MODE_OUT) {
			if ((r = start_compression_out(ssh, 6)) != 0)
				return r;
		} else {
			if ((r = start_compression_in(ssh)) != 0)
				return r;
		}
		comp->enabled = 1;
	}
	/*
	 * The 2^(blocksize*2) limit is too expensive for 3DES,
	 * so enforce a 1GB limit for small blocksizes.
	 */
	if (enc->block_size >= 16)
		*max_blocks = (u_int64_t)1 << (enc->block_size*2);
	else
		*max_blocks = ((u_int64_t)1 << 30) / enc->block_size;
	if (state->rekey_limit)
		*max_blocks = MINIMUM(*max_blocks,
		    state->rekey_limit / enc->block_size);
	debug("rekey after %llu blocks", (unsigned long long)*max_blocks);
	return 0;
}

#define MAX_PACKETS	(1U<<31)
static int
ssh_packet_need_rekeying(struct ssh *ssh, u_int outbound_packet_len)
{
	struct session_state *state = ssh->state;
	u_int32_t out_blocks;

	/* XXX client can't cope with rekeying pre-auth */
	if (!state->after_authentication)
		return 0;

	/* Haven't keyed yet or KEX in progress. */
	if (ssh->kex == NULL || ssh_packet_is_rekeying(ssh))
		return 0;

	/* Peer can't rekey */
	if (ssh->compat & SSH_BUG_NOREKEY)
		return 0;

	/*
	 * Permit one packet in or out per rekey - this allows us to
	 * make progress when rekey limits are very small.
	 */
	if (state->p_send.packets == 0 && state->p_read.packets == 0)
		return 0;

	/* Time-based rekeying */
	if (state->rekey_interval != 0 &&
	    (int64_t)state->rekey_time + state->rekey_interval <= monotime())
		return 1;

	/* Always rekey when MAX_PACKETS sent in either direction */
	if (state->p_send.packets > MAX_PACKETS ||
	    state->p_read.packets > MAX_PACKETS)
		return 1;

	/* Rekey after (cipher-specific) maxiumum blocks */
	out_blocks = ROUNDUP(outbound_packet_len,
	    state->newkeys[MODE_OUT]->enc.block_size);
	return (state->max_blocks_out &&
	    (state->p_send.blocks + out_blocks > state->max_blocks_out)) ||
	    (state->max_blocks_in &&
	    (state->p_read.blocks > state->max_blocks_in));
}

/*
 * Delayed compression for SSH2 is enabled after authentication:
 * This happens on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
 * and on the client side after a SSH2_MSG_USERAUTH_SUCCESS is received.
 */
static int
ssh_packet_enable_delayed_compress(struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	struct sshcomp *comp = NULL;
	int r, mode;

	/*
	 * Remember that we are past the authentication step, so rekeying
	 * with COMP_DELAYED will turn on compression immediately.
	 */
	state->after_authentication = 1;
	for (mode = 0; mode < MODE_MAX; mode++) {
		/* protocol error: USERAUTH_SUCCESS received before NEWKEYS */
		if (state->newkeys[mode] == NULL)
			continue;
		comp = &state->newkeys[mode]->comp;
		if (comp && !comp->enabled && comp->type == COMP_DELAYED) {
			if ((r = ssh_packet_init_compression(ssh)) != 0)
				return r;
			if (mode == MODE_OUT) {
				if ((r = start_compression_out(ssh, 6)) != 0)
					return r;
			} else {
				if ((r = start_compression_in(ssh)) != 0)
					return r;
			}
			comp->enabled = 1;
		}
	}
	return 0;
}

/* Used to mute debug logging for noisy packet types */
int
ssh_packet_log_type(u_char type)
{
	switch (type) {
	case SSH2_MSG_CHANNEL_DATA:
	case SSH2_MSG_CHANNEL_EXTENDED_DATA:
	case SSH2_MSG_CHANNEL_WINDOW_ADJUST:
		return 0;
	default:
		return 1;
	}
}

/*
 * Finalize packet in SSH2 format (compress, mac, encrypt, enqueue)
 */
int
ssh_packet_send2_wrapped(struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	u_char type, *cp, macbuf[SSH_DIGEST_MAX_LENGTH];
	u_char tmp, padlen, pad = 0;
	u_int authlen = 0, aadlen = 0;
	u_int len;
	struct sshenc *enc   = NULL;
	struct sshmac *mac   = NULL;
	struct sshcomp *comp = NULL;
	int r, block_size;

	if (state->newkeys[MODE_OUT] != NULL) {
		enc  = &state->newkeys[MODE_OUT]->enc;
		mac  = &state->newkeys[MODE_OUT]->mac;
		comp = &state->newkeys[MODE_OUT]->comp;
		/* disable mac for authenticated encryption */
		if ((authlen = cipher_authlen(enc->cipher)) != 0)
			mac = NULL;
	}
	block_size = enc ? enc->block_size : 8;
	aadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;

	type = (sshbuf_ptr(state->outgoing_packet))[5];
	if (ssh_packet_log_type(type))
		debug3("send packet: type %u", type);
#ifdef PACKET_DEBUG
	fprintf(stderr, "plain:     ");
	sshbuf_dump(state->outgoing_packet, stderr);
#endif

	if (comp && comp->enabled) {
		len = sshbuf_len(state->outgoing_packet);
		/* skip header, compress only payload */
		if ((r = sshbuf_consume(state->outgoing_packet, 5)) != 0)
			goto out;
		sshbuf_reset(state->compression_buffer);
		if ((r = compress_buffer(ssh, state->outgoing_packet,
		    state->compression_buffer)) != 0)
			goto out;
		sshbuf_reset(state->outgoing_packet);
		if ((r = sshbuf_put(state->outgoing_packet,
		    "\0\0\0\0\0", 5)) != 0 ||
		    (r = sshbuf_putb(state->outgoing_packet,
		    state->compression_buffer)) != 0)
			goto out;
		DBG(debug("compression: raw %d compressed %zd", len,
		    sshbuf_len(state->outgoing_packet)));
	}

	/* sizeof (packet_len + pad_len + payload) */
	len = sshbuf_len(state->outgoing_packet);

	/*
	 * calc size of padding, alloc space, get random data,
	 * minimum padding is 4 bytes
	 */
	len -= aadlen; /* packet length is not encrypted for EtM modes */
	padlen = block_size - (len % block_size);
	if (padlen < 4)
		padlen += block_size;
	if (state->extra_pad) {
		tmp = state->extra_pad;
		state->extra_pad =
		    ROUNDUP(state->extra_pad, block_size);
		/* check if roundup overflowed */
		if (state->extra_pad < tmp)
			return SSH_ERR_INVALID_ARGUMENT;
		tmp = (len + padlen) % state->extra_pad;
		/* Check whether pad calculation below will underflow */
		if (tmp > state->extra_pad)
			return SSH_ERR_INVALID_ARGUMENT;
		pad = state->extra_pad - tmp;
		DBG(debug3("%s: adding %d (len %d padlen %d extra_pad %d)",
		    __func__, pad, len, padlen, state->extra_pad));
		tmp = padlen;
		padlen += pad;
		/* Check whether padlen calculation overflowed */
		if (padlen < tmp)
			return SSH_ERR_INVALID_ARGUMENT; /* overflow */
		state->extra_pad = 0;
	}
	if ((r = sshbuf_reserve(state->outgoing_packet, padlen, &cp)) != 0)
		goto out;
	if (enc && !cipher_ctx_is_plaintext(state->send_context)) {
		/* random padding */
		arc4random_buf(cp, padlen);
	} else {
		/* clear padding */
		explicit_bzero(cp, padlen);
	}
	/* sizeof (packet_len + pad_len + payload + padding) */
	len = sshbuf_len(state->outgoing_packet);
	cp = sshbuf_mutable_ptr(state->outgoing_packet);
	if (cp == NULL) {
		r = SSH_ERR_INTERNAL_ERROR;
		goto out;
	}
	/* packet_length includes payload, padding and padding length field */
	POKE_U32(cp, len - 4);
	cp[4] = padlen;
	DBG(debug("send: len %d (includes padlen %d, aadlen %d)",
	    len, padlen, aadlen));

	/* compute MAC over seqnr and packet(length fields, payload, padding) */
	if (mac && mac->enabled && !mac->etm) {
		if ((r = mac_compute(mac, state->p_send.seqnr,
		    sshbuf_ptr(state->outgoing_packet), len,
		    macbuf, sizeof(macbuf))) != 0)
			goto out;
		DBG(debug("done calc MAC out #%d", state->p_send.seqnr));
	}
	/* encrypt packet and append to output buffer. */
	if ((r = sshbuf_reserve(state->output,
	    sshbuf_len(state->outgoing_packet) + authlen, &cp)) != 0)
		goto out;
	if ((r = cipher_crypt(state->send_context, state->p_send.seqnr, cp,
	    sshbuf_ptr(state->outgoing_packet),
	    len - aadlen, aadlen, authlen)) != 0)
		goto out;
	/* append unencrypted MAC */
	if (mac && mac->enabled) {
		if (mac->etm) {
			/* EtM: compute mac over aadlen + cipher text */
			if ((r = mac_compute(mac, state->p_send.seqnr,
			    cp, len, macbuf, sizeof(macbuf))) != 0)
				goto out;
			DBG(debug("done calc MAC(EtM) out #%d",
			    state->p_send.seqnr));
		}
		if ((r = sshbuf_put(state->output, macbuf, mac->mac_len)) != 0)
			goto out;
	}
#ifdef PACKET_DEBUG
	fprintf(stderr, "encrypted: ");
	sshbuf_dump(state->output, stderr);
#endif
	/* increment sequence number for outgoing packets */
	if (++state->p_send.seqnr == 0)
		logit("outgoing seqnr wraps around");
	if (++state->p_send.packets == 0)
		if (!(ssh->compat & SSH_BUG_NOREKEY))
			return SSH_ERR_NEED_REKEY;
	state->p_send.blocks += len / block_size;
	state->p_send.bytes += len;
	sshbuf_reset(state->outgoing_packet);

	if (type == SSH2_MSG_NEWKEYS)
		r = ssh_set_newkeys(ssh, MODE_OUT);
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && state->server_side)
		r = ssh_packet_enable_delayed_compress(ssh);
	else
		r = 0;
 out:
	return r;
}

/* returns non-zero if the specified packet type is usec by KEX */
static int
ssh_packet_type_is_kex(u_char type)
{
	return
	    type >= SSH2_MSG_TRANSPORT_MIN &&
	    type <= SSH2_MSG_TRANSPORT_MAX &&
	    type != SSH2_MSG_SERVICE_REQUEST &&
	    type != SSH2_MSG_SERVICE_ACCEPT &&
	    type != SSH2_MSG_EXT_INFO;
}

int
ssh_packet_send2(struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	struct packet *p;
	u_char type;
	int r, need_rekey;

	if (sshbuf_len(state->outgoing_packet) < 6)
		return SSH_ERR_INTERNAL_ERROR;
	type = sshbuf_ptr(state->outgoing_packet)[5];
	need_rekey = !ssh_packet_type_is_kex(type) &&
	    ssh_packet_need_rekeying(ssh, sshbuf_len(state->outgoing_packet));

	/*
	 * During rekeying we can only send key exchange messages.
	 * Queue everything else.
	 */
	if ((need_rekey || state->rekeying) && !ssh_packet_type_is_kex(type)) {
		if (need_rekey)
			debug3("%s: rekex triggered", __func__);
		debug("enqueue packet: %u", type);
		p = calloc(1, sizeof(*p));
		if (p == NULL)
			return SSH_ERR_ALLOC_FAIL;
		p->type = type;
		p->payload = state->outgoing_packet;
		TAILQ_INSERT_TAIL(&state->outgoing, p, next);
		state->outgoing_packet = sshbuf_new();
		if (state->outgoing_packet == NULL)
			return SSH_ERR_ALLOC_FAIL;
		if (need_rekey) {
			/*
			 * This packet triggered a rekey, so send the
			 * KEXINIT now.
			 * NB. reenters this function via kex_start_rekex().
			 */
			return kex_start_rekex(ssh);
		}
		return 0;
	}

	/* rekeying starts with sending KEXINIT */
	if (type == SSH2_MSG_KEXINIT)
		state->rekeying = 1;

	if ((r = ssh_packet_send2_wrapped(ssh)) != 0)
		return r;

	/* after a NEWKEYS message we can send the complete queue */
	if (type == SSH2_MSG_NEWKEYS) {
		state->rekeying = 0;
		state->rekey_time = monotime();
		while ((p = TAILQ_FIRST(&state->outgoing))) {
			type = p->type;
			/*
			 * If this packet triggers a rekex, then skip the
			 * remaining packets in the queue for now.
			 * NB. re-enters this function via kex_start_rekex.
			 */
			if (ssh_packet_need_rekeying(ssh,
			    sshbuf_len(p->payload))) {
				debug3("%s: queued packet triggered rekex",
				    __func__);
				return kex_start_rekex(ssh);
			}
			debug("dequeue packet: %u", type);
			sshbuf_free(state->outgoing_packet);
			state->outgoing_packet = p->payload;
			TAILQ_REMOVE(&state->outgoing, p, next);
			memset(p, 0, sizeof(*p));
			free(p);
			if ((r = ssh_packet_send2_wrapped(ssh)) != 0)
				return r;
		}
	}
	return 0;
}

/*
 * Waits until a packet has been received, and returns its type.  Note that
 * no other data is processed until this returns, so this function should not
 * be used during the interactive session.
 */

int
ssh_packet_read_seqnr(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
{
	struct session_state *state = ssh->state;
	int len, r, ms_remain;
	fd_set *setp;
	char buf[8192];
	struct timeval timeout, start, *timeoutp = NULL;

	DBG(debug("packet_read()"));

	setp = calloc(howmany(state->connection_in + 1,
	    NFDBITS), sizeof(fd_mask));
	if (setp == NULL)
		return SSH_ERR_ALLOC_FAIL;

	/*
	 * Since we are blocking, ensure that all written packets have
	 * been sent.
	 */
	if ((r = ssh_packet_write_wait(ssh)) != 0)
		goto out;

	/* Stay in the loop until we have received a complete packet. */
	for (;;) {
		/* Try to read a packet from the buffer. */
		r = ssh_packet_read_poll_seqnr(ssh, typep, seqnr_p);
		if (r != 0)
			break;
		/* If we got a packet, return it. */
		if (*typep != SSH_MSG_NONE)
			break;
		/*
		 * Otherwise, wait for some data to arrive, add it to the
		 * buffer, and try again.
		 */
		memset(setp, 0, howmany(state->connection_in + 1,
		    NFDBITS) * sizeof(fd_mask));
		FD_SET(state->connection_in, setp);

		if (state->packet_timeout_ms > 0) {
			ms_remain = state->packet_timeout_ms;
			timeoutp = &timeout;
		}
		/* Wait for some data to arrive. */
		for (;;) {
			if (state->packet_timeout_ms != -1) {
				ms_to_timeval(&timeout, ms_remain);
				gettimeofday(&start, NULL);
			}
			if ((r = select(state->connection_in + 1, setp,
			    NULL, NULL, timeoutp)) >= 0)
				break;
			if (errno != EAGAIN && errno != EINTR)
				break;
			if (state->packet_timeout_ms == -1)
				continue;
			ms_subtract_diff(&start, &ms_remain);
			if (ms_remain <= 0) {
				r = 0;
				break;
			}
		}
		if (r == 0) {
			r = SSH_ERR_CONN_TIMEOUT;
			goto out;
		}
		/* Read data from the socket. */
		len = read(state->connection_in, buf, sizeof(buf));
		if (len == 0) {
			r = SSH_ERR_CONN_CLOSED;
			goto out;
		}
		if (len < 0) {
			r = SSH_ERR_SYSTEM_ERROR;
			goto out;
		}

		/* Append it to the buffer. */
		if ((r = ssh_packet_process_incoming(ssh, buf, len)) != 0)
			goto out;
	}
 out:
	free(setp);
	return r;
}

int
ssh_packet_read(struct ssh *ssh)
{
	u_char type;
	int r;

	if ((r = ssh_packet_read_seqnr(ssh, &type, NULL)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
	return type;
}

/*
 * Waits until a packet has been received, verifies that its type matches
 * that given, and gives a fatal error and exits if there is a mismatch.
 */

int
ssh_packet_read_expect(struct ssh *ssh, u_int expected_type)
{
	int r;
	u_char type;

	if ((r = ssh_packet_read_seqnr(ssh, &type, NULL)) != 0)
		return r;
	if (type != expected_type) {
		if ((r = sshpkt_disconnect(ssh,
		    "Protocol error: expected packet type %d, got %d",
		    expected_type, type)) != 0)
			return r;
		return SSH_ERR_PROTOCOL_ERROR;
	}
	return 0;
}

static int
ssh_packet_read_poll2_mux(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
{
	struct session_state *state = ssh->state;
	const u_char *cp;
	size_t need;
	int r;

	if (ssh->kex)
		return SSH_ERR_INTERNAL_ERROR;
	*typep = SSH_MSG_NONE;
	cp = sshbuf_ptr(state->input);
	if (state->packlen == 0) {
		if (sshbuf_len(state->input) < 4 + 1)
			return 0; /* packet is incomplete */
		state->packlen = PEEK_U32(cp);
		if (state->packlen < 4 + 1 ||
		    state->packlen > PACKET_MAX_SIZE)
			return SSH_ERR_MESSAGE_INCOMPLETE;
	}
	need = state->packlen + 4;
	if (sshbuf_len(state->input) < need)
		return 0; /* packet is incomplete */
	sshbuf_reset(state->incoming_packet);
	if ((r = sshbuf_put(state->incoming_packet, cp + 4,
	    state->packlen)) != 0 ||
	    (r = sshbuf_consume(state->input, need)) != 0 ||
	    (r = sshbuf_get_u8(state->incoming_packet, NULL)) != 0 ||
	    (r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
		return r;
	if (ssh_packet_log_type(*typep))
		debug3("%s: type %u", __func__, *typep);
	/* sshbuf_dump(state->incoming_packet, stderr); */
	/* reset for next packet */
	state->packlen = 0;
	return r;
}

int
ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
{
	struct session_state *state = ssh->state;
	u_int padlen, need;
	u_char *cp;
	u_int maclen, aadlen = 0, authlen = 0, block_size;
	struct sshenc *enc   = NULL;
	struct sshmac *mac   = NULL;
	struct sshcomp *comp = NULL;
	int r;

	if (state->mux)
		return ssh_packet_read_poll2_mux(ssh, typep, seqnr_p);

	*typep = SSH_MSG_NONE;

	if (state->packet_discard)
		return 0;

	if (state->newkeys[MODE_IN] != NULL) {
		enc  = &state->newkeys[MODE_IN]->enc;
		mac  = &state->newkeys[MODE_IN]->mac;
		comp = &state->newkeys[MODE_IN]->comp;
		/* disable mac for authenticated encryption */
		if ((authlen = cipher_authlen(enc->cipher)) != 0)
			mac = NULL;
	}
	maclen = mac && mac->enabled ? mac->mac_len : 0;
	block_size = enc ? enc->block_size : 8;
	aadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;

	if (aadlen && state->packlen == 0) {
		if (cipher_get_length(state->receive_context,
		    &state->packlen, state->p_read.seqnr,
		    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)
			return 0;
		if (state->packlen < 1 + 4 ||
		    state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			sshbuf_dump(state->input, stderr);
#endif
			logit("Bad packet length %u.", state->packlen);
			if ((r = sshpkt_disconnect(ssh, "Packet corrupt")) != 0)
				return r;
			return SSH_ERR_CONN_CORRUPT;
		}
		sshbuf_reset(state->incoming_packet);
	} else if (state->packlen == 0) {
		/*
		 * check if input size is less than the cipher block size,
		 * decrypt first block and extract length of incoming packet
		 */
		if (sshbuf_len(state->input) < block_size)
			return 0;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_reserve(state->incoming_packet, block_size,
		    &cp)) != 0)
			goto out;
		if ((r = cipher_crypt(state->receive_context,
		    state->p_send.seqnr, cp, sshbuf_ptr(state->input),
		    block_size, 0, 0)) != 0)
			goto out;
		state->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));
		if (state->packlen < 1 + 4 ||
		    state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			fprintf(stderr, "input: \n");
			sshbuf_dump(state->input, stderr);
			fprintf(stderr, "incoming_packet: \n");
			sshbuf_dump(state->incoming_packet, stderr);
#endif
			logit("Bad packet length %u.", state->packlen);
			return ssh_packet_start_discard(ssh, enc, mac, 0,
			    PACKET_MAX_SIZE);
		}
		if ((r = sshbuf_consume(state->input, block_size)) != 0)
			goto out;
	}
	DBG(debug("input: packet len %u", state->packlen+4));

	if (aadlen) {
		/* only the payload is encrypted */
		need = state->packlen;
	} else {
		/*
		 * the payload size and the payload are encrypted, but we
		 * have a partial packet of block_size bytes
		 */
		need = 4 + state->packlen - block_size;
	}
	DBG(debug("partial packet: block %d, need %d, maclen %d, authlen %d,"
	    " aadlen %d", block_size, need, maclen, authlen, aadlen));
	if (need % block_size != 0) {
		logit("padding error: need %d block %d mod %d",
		    need, block_size, need % block_size);
		return ssh_packet_start_discard(ssh, enc, mac, 0,
		    PACKET_MAX_SIZE - block_size);
	}
	/*
	 * check if the entire packet has been received and
	 * decrypt into incoming_packet:
	 * 'aadlen' bytes are unencrypted, but authenticated.
	 * 'need' bytes are encrypted, followed by either
	 * 'authlen' bytes of authentication tag or
	 * 'maclen' bytes of message authentication code.
	 */
	if (sshbuf_len(state->input) < aadlen + need + authlen + maclen)
		return 0; /* packet is incomplete */
#ifdef PACKET_DEBUG
	fprintf(stderr, "read_poll enc/full: ");
	sshbuf_dump(state->input, stderr);
#endif
	/* EtM: check mac over encrypted input */
	if (mac && mac->enabled && mac->etm) {
		if ((r = mac_check(mac, state->p_read.seqnr,
		    sshbuf_ptr(state->input), aadlen + need,
		    sshbuf_ptr(state->input) + aadlen + need + authlen,
		    maclen)) != 0) {
			if (r == SSH_ERR_MAC_INVALID)
				logit("Corrupted MAC on input.");
			goto out;
		}
	}
	if ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,
	    &cp)) != 0)
		goto out;
	if ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,
	    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)
		goto out;
	if ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)
		goto out;
	if (mac && mac->enabled) {
		/* Not EtM: check MAC over cleartext */
		if (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,
		    sshbuf_ptr(state->incoming_packet),
		    sshbuf_len(state->incoming_packet),
		    sshbuf_ptr(state->input), maclen)) != 0) {
			if (r != SSH_ERR_MAC_INVALID)
				goto out;
			logit("Corrupted MAC on input.");
			if (need + block_size > PACKET_MAX_SIZE)
				return SSH_ERR_INTERNAL_ERROR;
			return ssh_packet_start_discard(ssh, enc, mac,
			    sshbuf_len(state->incoming_packet),
			    PACKET_MAX_SIZE - need - block_size);
		}
		/* Remove MAC from input buffer */
		DBG(debug("MAC #%d ok", state->p_read.seqnr));
		if ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)
			goto out;
	}
	if (seqnr_p != NULL)
		*seqnr_p = state->p_read.seqnr;
	if (++state->p_read.seqnr == 0)
		logit("incoming seqnr wraps around");
	if (++state->p_read.packets == 0)
		if (!(ssh->compat & SSH_BUG_NOREKEY))
			return SSH_ERR_NEED_REKEY;
	state->p_read.blocks += (state->packlen + 4) / block_size;
	state->p_read.bytes += state->packlen + 4;

	/* get padlen */
	padlen = sshbuf_ptr(state->incoming_packet)[4];
	DBG(debug("input: padlen %d", padlen));
	if (padlen < 4)	{
		if ((r = sshpkt_disconnect(ssh,
		    "Corrupted padlen %d on input.", padlen)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			return r;
		return SSH_ERR_CONN_CORRUPT;
	}

	/* skip packet size + padlen, discard padding */
	if ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||
	    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))
		goto out;

	DBG(debug("input: len before de-compress %zd",
	    sshbuf_len(state->incoming_packet)));
	if (comp && comp->enabled) {
		sshbuf_reset(state->compression_buffer);
		if ((r = uncompress_buffer(ssh, state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_putb(state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		DBG(debug("input: len after de-compress %zd",
		    sshbuf_len(state->incoming_packet)));
	}
	/*
	 * get packet type, implies consume.
	 * return length of payload (without type field)
	 */
	if ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
		goto out;
	if (ssh_packet_log_type(*typep))
		debug3("receive packet: type %u", *typep);
	if (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {
		if ((r = sshpkt_disconnect(ssh,
		    "Invalid ssh2 packet type: %d", *typep)) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			return r;
		return SSH_ERR_PROTOCOL_ERROR;
	}
	if (state->hook_in != NULL &&
	    (r = state->hook_in(ssh, state->incoming_packet, typep,
	    state->hook_in_ctx)) != 0)
		return r;
	if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
		r = ssh_packet_enable_delayed_compress(ssh);
	else
		r = 0;
#ifdef PACKET_DEBUG
	fprintf(stderr, "read/plain[%d]:\r\n", *typep);
	sshbuf_dump(state->incoming_packet, stderr);
#endif
	/* reset for next packet */
	state->packlen = 0;

	/* do we need to rekey? */
	if (ssh_packet_need_rekeying(ssh, 0)) {
		debug3("%s: rekex triggered", __func__);
		if ((r = kex_start_rekex(ssh)) != 0)
			return r;
	}
 out:
	return r;
}

int
ssh_packet_read_poll_seqnr(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
{
	struct session_state *state = ssh->state;
	u_int reason, seqnr;
	int r;
	u_char *msg;

	for (;;) {
		msg = NULL;
		r = ssh_packet_read_poll2(ssh, typep, seqnr_p);
		if (r != 0)
			return r;
		if (*typep) {
			state->keep_alive_timeouts = 0;
			DBG(debug("received packet type %d", *typep));
		}
		switch (*typep) {
		case SSH2_MSG_IGNORE:
			debug3("Received SSH2_MSG_IGNORE");
			break;
		case SSH2_MSG_DEBUG:
			if ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||
			    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0 ||
			    (r = sshpkt_get_string(ssh, NULL, NULL)) != 0) {
				free(msg);
				return r;
			}
			debug("Remote: %.900s", msg);
			free(msg);
			break;
		case SSH2_MSG_DISCONNECT:
			if ((r = sshpkt_get_u32(ssh, &reason)) != 0 ||
			    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0)
				return r;
			/* Ignore normal client exit notifications */
			do_log2(ssh->state->server_side &&
			    reason == SSH2_DISCONNECT_BY_APPLICATION ?
			    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_ERROR,
			    "Received disconnect from %s port %d:"
			    "%u: %.400s", ssh_remote_ipaddr(ssh),
			    ssh_remote_port(ssh), reason, msg);
			free(msg);
			return SSH_ERR_DISCONNECTED;
		case SSH2_MSG_UNIMPLEMENTED:
			if ((r = sshpkt_get_u32(ssh, &seqnr)) != 0)
				return r;
			debug("Received SSH2_MSG_UNIMPLEMENTED for %u",
			    seqnr);
			break;
		default:
			return 0;
		}
	}
}

/*
 * Buffers the given amount of input characters.  This is intended to be used
 * together with packet_read_poll.
 */

int
ssh_packet_process_incoming(struct ssh *ssh, const char *buf, u_int len)
{
	struct session_state *state = ssh->state;
	int r;

	if (state->packet_discard) {
		state->keep_alive_timeouts = 0; /* ?? */
		if (len >= state->packet_discard) {
			if ((r = ssh_packet_stop_discard(ssh)) != 0)
				return r;
		}
		state->packet_discard -= len;
		return 0;
	}
	if ((r = sshbuf_put(ssh->state->input, buf, len)) != 0)
		return r;

	return 0;
}

int
ssh_packet_remaining(struct ssh *ssh)
{
	return sshbuf_len(ssh->state->incoming_packet);
}

/*
 * Sends a diagnostic message from the server to the client.  This message
 * can be sent at any time (but not while constructing another message). The
 * message is printed immediately, but only if the client is being executed
 * in verbose mode.  These messages are primarily intended to ease debugging
 * authentication problems.   The length of the formatted message must not
 * exceed 1024 bytes.  This will automatically call ssh_packet_write_wait.
 */
void
ssh_packet_send_debug(struct ssh *ssh, const char *fmt,...)
{
	char buf[1024];
	va_list args;
	int r;

	if ((ssh->compat & SSH_BUG_DEBUG))
		return;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	if ((r = sshpkt_start(ssh, SSH2_MSG_DEBUG)) != 0 ||
	    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* always display */
	    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, "")) != 0 ||
	    (r = sshpkt_send(ssh)) != 0 ||
	    (r = ssh_packet_write_wait(ssh)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
}

static void
fmt_connection_id(struct ssh *ssh, char *s, size_t l)
{
	snprintf(s, l, "%.200s%s%s port %d",
	    ssh->log_preamble ? ssh->log_preamble : "",
	    ssh->log_preamble ? " " : "",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
}

/*
 * Pretty-print connection-terminating errors and exit.
 */
void
sshpkt_fatal(struct ssh *ssh, const char *tag, int r)
{
	char remote_id[512];

	fmt_connection_id(ssh, remote_id, sizeof(remote_id));

	switch (r) {
	case SSH_ERR_CONN_CLOSED:
		ssh_packet_clear_keys(ssh);
		logdie("Connection closed by %s", remote_id);
	case SSH_ERR_CONN_TIMEOUT:
		ssh_packet_clear_keys(ssh);
		logdie("Connection %s %s timed out",
		    ssh->state->server_side ? "from" : "to", remote_id);
	case SSH_ERR_DISCONNECTED:
		ssh_packet_clear_keys(ssh);
		logdie("Disconnected from %s", remote_id);
	case SSH_ERR_SYSTEM_ERROR:
		if (errno == ECONNRESET) {
			ssh_packet_clear_keys(ssh);
			logdie("Connection reset by %s", remote_id);
		}
		/* FALLTHROUGH */
	case SSH_ERR_NO_CIPHER_ALG_MATCH:
	case SSH_ERR_NO_MAC_ALG_MATCH:
	case SSH_ERR_NO_COMPRESS_ALG_MATCH:
	case SSH_ERR_NO_KEX_ALG_MATCH:
	case SSH_ERR_NO_HOSTKEY_ALG_MATCH:
		if (ssh && ssh->kex && ssh->kex->failed_choice) {
			ssh_packet_clear_keys(ssh);
			logdie("Unable to negotiate with %s: %s. "
			    "Their offer: %s", remote_id, ssh_err(r),
			    ssh->kex->failed_choice);
		}
		/* FALLTHROUGH */
	default:
		ssh_packet_clear_keys(ssh);
		logdie("%s%sConnection %s %s: %s",
		    tag != NULL ? tag : "", tag != NULL ? ": " : "",
		    ssh->state->server_side ? "from" : "to",
		    remote_id, ssh_err(r));
	}
}

/*
 * Logs the error plus constructs and sends a disconnect packet, closes the
 * connection, and exits.  This function never returns. The error message
 * should not contain a newline.  The length of the formatted message must
 * not exceed 1024 bytes.
 */
void
ssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)
{
	char buf[1024], remote_id[512];
	va_list args;
	static int disconnecting = 0;
	int r;

	if (disconnecting)	/* Guard against recursive invocations. */
		fatal("packet_disconnect called recursively.");
	disconnecting = 1;

	/*
	 * Format the message.  Note that the caller must make sure the
	 * message is of limited size.
	 */
	fmt_connection_id(ssh, remote_id, sizeof(remote_id));
	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	/* Display the error locally */
	logit("Disconnecting %s: %.100s", remote_id, buf);

	/*
	 * Send the disconnect message to the other side, and wait
	 * for it to get sent.
	 */
	if ((r = sshpkt_disconnect(ssh, "%s", buf)) != 0)
		sshpkt_fatal(ssh, __func__, r);

	if ((r = ssh_packet_write_wait(ssh)) != 0)
		sshpkt_fatal(ssh, __func__, r);

	/* Close the connection. */
	ssh_packet_close(ssh);
	cleanup_exit(255);
}

/*
 * Checks if there is any buffered output, and tries to write some of
 * the output.
 */
int
ssh_packet_write_poll(struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	int len = sshbuf_len(state->output);
	int r;

	if (len > 0) {
		len = write(state->connection_out,
		    sshbuf_ptr(state->output), len);
		if (len == -1) {
			if (errno == EINTR || errno == EAGAIN)
				return 0;
			return SSH_ERR_SYSTEM_ERROR;
		}
		if (len == 0)
			return SSH_ERR_CONN_CLOSED;
		if ((r = sshbuf_consume(state->output, len)) != 0)
			return r;
	}
	return 0;
}

/*
 * Calls packet_write_poll repeatedly until all pending output data has been
 * written.
 */
int
ssh_packet_write_wait(struct ssh *ssh)
{
	fd_set *setp;
	int ret, r, ms_remain = 0;
	struct timeval start, timeout, *timeoutp = NULL;
	struct session_state *state = ssh->state;

	setp = calloc(howmany(state->connection_out + 1,
	    NFDBITS), sizeof(fd_mask));
	if (setp == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = ssh_packet_write_poll(ssh)) != 0) {
		free(setp);
		return r;
	}
	while (ssh_packet_have_data_to_write(ssh)) {
		memset(setp, 0, howmany(state->connection_out + 1,
		    NFDBITS) * sizeof(fd_mask));
		FD_SET(state->connection_out, setp);

		if (state->packet_timeout_ms > 0) {
			ms_remain = state->packet_timeout_ms;
			timeoutp = &timeout;
		}
		for (;;) {
			if (state->packet_timeout_ms != -1) {
				ms_to_timeval(&timeout, ms_remain);
				gettimeofday(&start, NULL);
			}
			if ((ret = select(state->connection_out + 1,
			    NULL, setp, NULL, timeoutp)) >= 0)
				break;
			if (errno != EAGAIN && errno != EINTR)
				break;
			if (state->packet_timeout_ms == -1)
				continue;
			ms_subtract_diff(&start, &ms_remain);
			if (ms_remain <= 0) {
				ret = 0;
				break;
			}
		}
		if (ret == 0) {
			free(setp);
			return SSH_ERR_CONN_TIMEOUT;
		}
		if ((r = ssh_packet_write_poll(ssh)) != 0) {
			free(setp);
			return r;
		}
	}
	free(setp);
	return 0;
}

/* Returns true if there is buffered data to write to the connection. */

int
ssh_packet_have_data_to_write(struct ssh *ssh)
{
	return sshbuf_len(ssh->state->output) != 0;
}

/* Returns true if there is not too much data to write to the connection. */

int
ssh_packet_not_very_much_data_to_write(struct ssh *ssh)
{
	if (ssh->state->interactive_mode)
		return sshbuf_len(ssh->state->output) < 16384;
	else
		return sshbuf_len(ssh->state->output) < 128 * 1024;
}

void
ssh_packet_set_tos(struct ssh *ssh, int tos)
{
	if (!ssh_packet_connection_is_on_socket(ssh))
		return;
	switch (ssh_packet_connection_af(ssh)) {
	case AF_INET:
		debug3("%s: set IP_TOS 0x%02x", __func__, tos);
		if (setsockopt(ssh->state->connection_in,
		    IPPROTO_IP, IP_TOS, &tos, sizeof(tos)) < 0)
			error("setsockopt IP_TOS %d: %.100s:",
			    tos, strerror(errno));
		break;
	case AF_INET6:
		debug3("%s: set IPV6_TCLASS 0x%02x", __func__, tos);
		if (setsockopt(ssh->state->connection_in,
		    IPPROTO_IPV6, IPV6_TCLASS, &tos, sizeof(tos)) < 0)
			error("setsockopt IPV6_TCLASS %d: %.100s:",
			    tos, strerror(errno));
		break;
	}
}

/* Informs that the current session is interactive.  Sets IP flags for that. */

void
ssh_packet_set_interactive(struct ssh *ssh, int interactive, int qos_interactive, int qos_bulk)
{
	struct session_state *state = ssh->state;

	if (state->set_interactive_called)
		return;
	state->set_interactive_called = 1;

	/* Record that we are in interactive mode. */
	state->interactive_mode = interactive;

	/* Only set socket options if using a socket.  */
	if (!ssh_packet_connection_is_on_socket(ssh))
		return;
	set_nodelay(state->connection_in);
	ssh_packet_set_tos(ssh, interactive ? qos_interactive :
	    qos_bulk);
}

/* Returns true if the current connection is interactive. */

int
ssh_packet_is_interactive(struct ssh *ssh)
{
	return ssh->state->interactive_mode;
}

int
ssh_packet_set_maxsize(struct ssh *ssh, u_int s)
{
	struct session_state *state = ssh->state;

	if (state->set_maxsize_called) {
		logit("packet_set_maxsize: called twice: old %d new %d",
		    state->max_packet_size, s);
		return -1;
	}
	if (s < 4 * 1024 || s > 1024 * 1024) {
		logit("packet_set_maxsize: bad size %d", s);
		return -1;
	}
	state->set_maxsize_called = 1;
	debug("packet_set_maxsize: setting to %d", s);
	state->max_packet_size = s;
	return s;
}

int
ssh_packet_inc_alive_timeouts(struct ssh *ssh)
{
	return ++ssh->state->keep_alive_timeouts;
}

void
ssh_packet_set_alive_timeouts(struct ssh *ssh, int ka)
{
	ssh->state->keep_alive_timeouts = ka;
}

u_int
ssh_packet_get_maxsize(struct ssh *ssh)
{
	return ssh->state->max_packet_size;
}

/*
 * 9.2.  Ignored Data Message
 *
 *   byte      SSH_MSG_IGNORE
 *   string    data
 *
 * All implementations MUST understand (and ignore) this message at any
 * time (after receiving the protocol version). No implementation is
 * required to send them. This message can be used as an additional
 * protection measure against advanced traffic analysis techniques.
 */
void
ssh_packet_send_ignore(struct ssh *ssh, int nbytes)
{
	u_int32_t rnd = 0;
	int r, i;

	if ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||
	    (r = sshpkt_put_u32(ssh, nbytes)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
	for (i = 0; i < nbytes; i++) {
		if (i % 4 == 0)
			rnd = arc4random();
		if ((r = sshpkt_put_u8(ssh, (u_char)rnd & 0xff)) != 0)
			fatal("%s: %s", __func__, ssh_err(r));
		rnd >>= 8;
	}
}

void
ssh_packet_set_rekey_limits(struct ssh *ssh, u_int64_t bytes, u_int32_t seconds)
{
	debug3("rekey after %llu bytes, %u seconds", (unsigned long long)bytes,
	    (unsigned int)seconds);
	ssh->state->rekey_limit = bytes;
	ssh->state->rekey_interval = seconds;
}

time_t
ssh_packet_get_rekey_timeout(struct ssh *ssh)
{
	time_t seconds;

	seconds = ssh->state->rekey_time + ssh->state->rekey_interval -
	    monotime();
	return (seconds <= 0 ? 1 : seconds);
}

void
ssh_packet_set_server(struct ssh *ssh)
{
	ssh->state->server_side = 1;
}

void
ssh_packet_set_authenticated(struct ssh *ssh)
{
	ssh->state->after_authentication = 1;
}

void *
ssh_packet_get_input(struct ssh *ssh)
{
	return (void *)ssh->state->input;
}

void *
ssh_packet_get_output(struct ssh *ssh)
{
	return (void *)ssh->state->output;
}

/* Reset after_authentication and reset compression in post-auth privsep */
static int
ssh_packet_set_postauth(struct ssh *ssh)
{
	int r;

	debug("%s: called", __func__);
	/* This was set in net child, but is not visible in user child */
	ssh->state->after_authentication = 1;
	ssh->state->rekeying = 0;
	if ((r = ssh_packet_enable_delayed_compress(ssh)) != 0)
		return r;
	return 0;
}

/* Packet state (de-)serialization for privsep */

/* turn kex into a blob for packet state serialization */
static int
kex_to_blob(struct sshbuf *m, struct kex *kex)
{
	int r;

	if ((r = sshbuf_put_string(m, kex->session_id,
	    kex->session_id_len)) != 0 ||
	    (r = sshbuf_put_u32(m, kex->we_need)) != 0 ||
	    (r = sshbuf_put_u32(m, kex->hostkey_type)) != 0 ||
	    (r = sshbuf_put_u32(m, kex->kex_type)) != 0 ||
	    (r = sshbuf_put_stringb(m, kex->my)) != 0 ||
	    (r = sshbuf_put_stringb(m, kex->peer)) != 0 ||
	    (r = sshbuf_put_u32(m, kex->flags)) != 0 ||
	    (r = sshbuf_put_cstring(m, kex->client_version_string)) != 0 ||
	    (r = sshbuf_put_cstring(m, kex->server_version_string)) != 0)
		return r;
	return 0;
}

/* turn key exchange results into a blob for packet state serialization */
static int
newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)
{
	struct sshbuf *b;
	struct sshcipher_ctx *cc;
	struct sshcomp *comp;
	struct sshenc *enc;
	struct sshmac *mac;
	struct newkeys *newkey;
	int r;

	if ((newkey = ssh->state->newkeys[mode]) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	enc = &newkey->enc;
	mac = &newkey->mac;
	comp = &newkey->comp;
	cc = (mode == MODE_OUT) ? ssh->state->send_context :
	    ssh->state->receive_context;
	if ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)
		return r;
	if ((b = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	/* The cipher struct is constant and shared, you export pointer */
	if ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||
	    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||
	    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||
	    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||
	    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||
	    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)
		goto out;
	if (cipher_authlen(enc->cipher) == 0) {
		if ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||
		    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||
		    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)
			goto out;
	}
	if ((r = sshbuf_put_u32(b, comp->type)) != 0 ||
	    (r = sshbuf_put_cstring(b, comp->name)) != 0)
		goto out;
	r = sshbuf_put_stringb(m, b);
 out:
	sshbuf_free(b);
	return r;
}

/* serialize packet state into a blob */
int
ssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)
{
	struct session_state *state = ssh->state;
	int r;

	if ((r = kex_to_blob(m, ssh->kex)) != 0 ||
	    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||
	    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||
	    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||
	    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||
	    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||
	    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||
	    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||
	    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||
	    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||
	    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||
	    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||
	    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0 ||
	    (r = sshbuf_put_stringb(m, state->input)) != 0 ||
	    (r = sshbuf_put_stringb(m, state->output)) != 0)
		return r;

	return 0;
}

/* restore key exchange results from blob for packet state de-serialization */
static int
newkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)
{
	struct sshbuf *b = NULL;
	struct sshcomp *comp;
	struct sshenc *enc;
	struct sshmac *mac;
	struct newkeys *newkey = NULL;
	size_t keylen, ivlen, maclen;
	int r;

	if ((newkey = calloc(1, sizeof(*newkey))) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshbuf_froms(m, &b)) != 0)
		goto out;
#ifdef DEBUG_PK
	sshbuf_dump(b, stderr);
#endif
	enc = &newkey->enc;
	mac = &newkey->mac;
	comp = &newkey->comp;

	if ((r = sshbuf_get_cstring(b, &enc->name, NULL)) != 0 ||
	    (r = sshbuf_get(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||
	    (r = sshbuf_get_u32(b, (u_int *)&enc->enabled)) != 0 ||
	    (r = sshbuf_get_u32(b, &enc->block_size)) != 0 ||
	    (r = sshbuf_get_string(b, &enc->key, &keylen)) != 0 ||
	    (r = sshbuf_get_string(b, &enc->iv, &ivlen)) != 0)
		goto out;
	if (cipher_authlen(enc->cipher) == 0) {
		if ((r = sshbuf_get_cstring(b, &mac->name, NULL)) != 0)
			goto out;
		if ((r = mac_setup(mac, mac->name)) != 0)
			goto out;
		if ((r = sshbuf_get_u32(b, (u_int *)&mac->enabled)) != 0 ||
		    (r = sshbuf_get_string(b, &mac->key, &maclen)) != 0)
			goto out;
		if (maclen > mac->key_len) {
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
		mac->key_len = maclen;
	}
	if ((r = sshbuf_get_u32(b, &comp->type)) != 0 ||
	    (r = sshbuf_get_cstring(b, &comp->name, NULL)) != 0)
		goto out;
	if (enc->name == NULL ||
	    cipher_by_name(enc->name) != enc->cipher) {
		r = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	if (sshbuf_len(b) != 0) {
		r = SSH_ERR_INVALID_FORMAT;
		goto out;
	}
	enc->key_len = keylen;
	enc->iv_len = ivlen;
	ssh->kex->newkeys[mode] = newkey;
	newkey = NULL;
	r = 0;
 out:
	free(newkey);
	sshbuf_free(b);
	return r;
}

/* restore kex from blob for packet state de-serialization */
static int
kex_from_blob(struct sshbuf *m, struct kex **kexp)
{
	struct kex *kex;
	int r;

	if ((kex = calloc(1, sizeof(struct kex))) == NULL ||
	    (kex->my = sshbuf_new()) == NULL ||
	    (kex->peer = sshbuf_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshbuf_get_string(m, &kex->session_id, &kex->session_id_len)) != 0 ||
	    (r = sshbuf_get_u32(m, &kex->we_need)) != 0 ||
	    (r = sshbuf_get_u32(m, (u_int *)&kex->hostkey_type)) != 0 ||
	    (r = sshbuf_get_u32(m, &kex->kex_type)) != 0 ||
	    (r = sshbuf_get_stringb(m, kex->my)) != 0 ||
	    (r = sshbuf_get_stringb(m, kex->peer)) != 0 ||
	    (r = sshbuf_get_u32(m, &kex->flags)) != 0 ||
	    (r = sshbuf_get_cstring(m, &kex->client_version_string, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(m, &kex->server_version_string, NULL)) != 0)
		goto out;
	kex->server = 1;
	kex->done = 1;
	r = 0;
 out:
	if (r != 0 || kexp == NULL) {
		if (kex != NULL) {
			sshbuf_free(kex->my);
			sshbuf_free(kex->peer);
			free(kex);
		}
		if (kexp != NULL)
			*kexp = NULL;
	} else {
		*kexp = kex;
	}
	return r;
}

/*
 * Restore packet state from content of blob 'm' (de-serialization).
 * Note that 'm' will be partially consumed on parsing or any other errors.
 */
int
ssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)
{
	struct session_state *state = ssh->state;
	const u_char *input, *output;
	size_t ilen, olen;
	int r;

	if ((r = kex_from_blob(m, &ssh->kex)) != 0 ||
	    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||
	    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||
	    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||
	    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||
	    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||
	    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||
	    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||
	    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||
	    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||
	    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||
	    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||
	    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)
		return r;
	/*
	 * We set the time here so that in post-auth privsep slave we
	 * count from the completion of the authentication.
	 */
	state->rekey_time = monotime();
	/* XXX ssh_set_newkeys overrides p_read.packets? XXX */
	if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||
	    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)
		return r;

	if ((r = ssh_packet_set_postauth(ssh)) != 0)
		return r;

	sshbuf_reset(state->input);
	sshbuf_reset(state->output);
	if ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||
	    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||
	    (r = sshbuf_put(state->input, input, ilen)) != 0 ||
	    (r = sshbuf_put(state->output, output, olen)) != 0)
		return r;

	if (sshbuf_len(m))
		return SSH_ERR_INVALID_FORMAT;
	debug3("%s: done", __func__);
	return 0;
}

/* NEW API */

/* put data to the outgoing packet */

int
sshpkt_put(struct ssh *ssh, const void *v, size_t len)
{
	return sshbuf_put(ssh->state->outgoing_packet, v, len);
}

int
sshpkt_putb(struct ssh *ssh, const struct sshbuf *b)
{
	return sshbuf_putb(ssh->state->outgoing_packet, b);
}

int
sshpkt_put_u8(struct ssh *ssh, u_char val)
{
	return sshbuf_put_u8(ssh->state->outgoing_packet, val);
}

int
sshpkt_put_u32(struct ssh *ssh, u_int32_t val)
{
	return sshbuf_put_u32(ssh->state->outgoing_packet, val);
}

int
sshpkt_put_u64(struct ssh *ssh, u_int64_t val)
{
	return sshbuf_put_u64(ssh->state->outgoing_packet, val);
}

int
sshpkt_put_string(struct ssh *ssh, const void *v, size_t len)
{
	return sshbuf_put_string(ssh->state->outgoing_packet, v, len);
}

int
sshpkt_put_cstring(struct ssh *ssh, const void *v)
{
	return sshbuf_put_cstring(ssh->state->outgoing_packet, v);
}

int
sshpkt_put_stringb(struct ssh *ssh, const struct sshbuf *v)
{
	return sshbuf_put_stringb(ssh->state->outgoing_packet, v);
}

#ifdef WITH_OPENSSL
int
sshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)
{
	return sshbuf_put_ec(ssh->state->outgoing_packet, v, g);
}


int
sshpkt_put_bignum2(struct ssh *ssh, const BIGNUM *v)
{
	return sshbuf_put_bignum2(ssh->state->outgoing_packet, v);
}
#endif /* WITH_OPENSSL */

/* fetch data from the incoming packet */

int
sshpkt_get(struct ssh *ssh, void *valp, size_t len)
{
	return sshbuf_get(ssh->state->incoming_packet, valp, len);
}

int
sshpkt_get_u8(struct ssh *ssh, u_char *valp)
{
	return sshbuf_get_u8(ssh->state->incoming_packet, valp);
}

int
sshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)
{
	return sshbuf_get_u32(ssh->state->incoming_packet, valp);
}

int
sshpkt_get_u64(struct ssh *ssh, u_int64_t *valp)
{
	return sshbuf_get_u64(ssh->state->incoming_packet, valp);
}

int
sshpkt_get_string(struct ssh *ssh, u_char **valp, size_t *lenp)
{
	return sshbuf_get_string(ssh->state->incoming_packet, valp, lenp);
}

int
sshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)
{
	return sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);
}

int
sshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)
{
	return sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);
}

#ifdef WITH_OPENSSL
int
sshpkt_get_ec(struct ssh *ssh, EC_POINT *v, const EC_GROUP *g)
{
	return sshbuf_get_ec(ssh->state->incoming_packet, v, g);
}


int
sshpkt_get_bignum2(struct ssh *ssh, BIGNUM *v)
{
	return sshbuf_get_bignum2(ssh->state->incoming_packet, v);
}
#endif /* WITH_OPENSSL */

int
sshpkt_get_end(struct ssh *ssh)
{
	if (sshbuf_len(ssh->state->incoming_packet) > 0)
		return SSH_ERR_UNEXPECTED_TRAILING_DATA;
	return 0;
}

const u_char *
sshpkt_ptr(struct ssh *ssh, size_t *lenp)
{
	if (lenp != NULL)
		*lenp = sshbuf_len(ssh->state->incoming_packet);
	return sshbuf_ptr(ssh->state->incoming_packet);
}

/* start a new packet */

int
sshpkt_start(struct ssh *ssh, u_char type)
{
	u_char buf[6]; /* u32 packet length, u8 pad len, u8 type */

	DBG(debug("packet_start[%d]", type));
	memset(buf, 0, sizeof(buf));
	buf[sizeof(buf) - 1] = type;
	sshbuf_reset(ssh->state->outgoing_packet);
	return sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));
}

static int
ssh_packet_send_mux(struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	u_char type, *cp;
	size_t len;
	int r;

	if (ssh->kex)
		return SSH_ERR_INTERNAL_ERROR;
	len = sshbuf_len(state->outgoing_packet);
	if (len < 6)
		return SSH_ERR_INTERNAL_ERROR;
	cp = sshbuf_mutable_ptr(state->outgoing_packet);
	type = cp[5];
	if (ssh_packet_log_type(type))
		debug3("%s: type %u", __func__, type);
	/* drop everything, but the connection protocol */
	if (type >= SSH2_MSG_CONNECTION_MIN &&
	    type <= SSH2_MSG_CONNECTION_MAX) {
		POKE_U32(cp, len - 4);
		if ((r = sshbuf_putb(state->output,
		    state->outgoing_packet)) != 0)
			return r;
		/* sshbuf_dump(state->output, stderr); */
	}
	sshbuf_reset(state->outgoing_packet);
	return 0;
}

/* send it */

int
sshpkt_send(struct ssh *ssh)
{
	if (ssh->state && ssh->state->mux)
		return ssh_packet_send_mux(ssh);
	return ssh_packet_send2(ssh);
}

int
sshpkt_disconnect(struct ssh *ssh, const char *fmt,...)
{
	char buf[1024];
	va_list args;
	int r;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	if ((r = sshpkt_start(ssh, SSH2_MSG_DISCONNECT)) != 0 ||
	    (r = sshpkt_put_u32(ssh, SSH2_DISCONNECT_PROTOCOL_ERROR)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, "")) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		return r;
	return 0;
}

/* roundup current message to pad bytes */
int
sshpkt_add_padding(struct ssh *ssh, u_char pad)
{
	ssh->state->extra_pad = pad;
	return 0;
}
@


1.259
log
@some warnings spotted by clang; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.258 2017/05/31 08:58:52 deraadt Exp $ */
d592 1
a592 1
			z_streamp stream = &state->compression_out_stream;
@


1.258
log
@These shutdown() SHUT_RDWR are not needed before close()
ok djm markus claudio
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.257 2017/05/31 08:09:45 markus Exp $ */
d805 1
a805 1
	if (ssh->kex && ssh->kex->newkeys) {
d821 1
a821 1
	const char *wmsg, *dir;
a826 1
		dir = "output";
a831 1
		dir = "input";
@


1.257
log
@clear session keys from memory; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.256 2017/05/08 06:03:39 djm Exp $ */
a561 1
			shutdown(state->connection_out, SHUT_RDWR);
@


1.256
log
@helps if I commit the correct version of the file. fix missing
return statement.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.255 2017/05/08 00:21:36 djm Exp $ */
d551 2
a552 2
void
ssh_packet_close(struct ssh *ssh)
d560 8
a567 6
	if (state->connection_in == state->connection_out) {
		shutdown(state->connection_out, SHUT_RDWR);
		close(state->connection_out);
	} else {
		close(state->connection_in);
		close(state->connection_out);
d573 7
a579 3
	for (mode = 0; mode < MODE_MAX; mode++)
		kex_free_newkeys(state->newkeys[mode]);
	if (state->compression_buffer) {
d607 18
a624 4
	free(ssh->remote_ipaddr);
	ssh->remote_ipaddr = NULL;
	free(ssh->state);
	ssh->state = NULL;
d803 9
d841 6
a846 4
		debug("%s: rekeying after %llu %s blocks"
		    " (%llu bytes total)", __func__,
		    (unsigned long long)ps->blocks, dir,
		    (unsigned long long)ps->bytes);
d849 2
a850 14
		enc  = &state->newkeys[mode]->enc;
		mac  = &state->newkeys[mode]->mac;
		comp = &state->newkeys[mode]->comp;
		mac_clear(mac);
		explicit_bzero(enc->iv,  enc->iv_len);
		explicit_bzero(enc->key, enc->key_len);
		explicit_bzero(mac->key, mac->key_len);
		free(enc->name);
		free(enc->iv);
		free(enc->key);
		free(mac->name);
		free(mac->key);
		free(comp->name);
		free(state->newkeys[mode]);
d1794 1
d1797 1
d1801 1
d1804 2
a1805 1
		if (errno == ECONNRESET)
d1807 1
d1815 1
d1822 1
@


1.255
log
@I was too aggressive with the scalpel in the last commit;
unbreak sshd, spotted quickly by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.254 2017/05/07 23:12:57 djm Exp $ */
d2223 1
@


1.254
log
@As promised in last release announcement: remove support for
Blowfish, RC4 and CAST ciphers. ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.253 2017/05/03 21:08:09 naddy Exp $ */
d2220 3
a2222 2
	    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0)
		return r;
@


1.253
log
@remove miscellaneous SSH1 leftovers; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.252 2017/04/30 23:28:42 djm Exp $ */
d876 1
a876 1
	 * blowfish, etc, so enforce a 1GB limit for small blocksizes.
a2205 2
	u_char *p;
	size_t slen, rlen;
a2222 16
	slen = cipher_get_keycontext(state->send_context, NULL);
	rlen = cipher_get_keycontext(state->receive_context, NULL);
	if ((r = sshbuf_put_u32(m, slen)) != 0 ||
	    (r = sshbuf_reserve(m, slen, &p)) != 0)
		return r;
	if (cipher_get_keycontext(state->send_context, p) != (int)slen)
		return SSH_ERR_INTERNAL_ERROR;
	if ((r = sshbuf_put_u32(m, rlen)) != 0 ||
	    (r = sshbuf_reserve(m, rlen, &p)) != 0)
		return r;
	if (cipher_get_keycontext(state->receive_context, p) != (int)rlen)
		return SSH_ERR_INTERNAL_ERROR;
	if ((r = sshbuf_put_stringb(m, state->input)) != 0 ||
	    (r = sshbuf_put_stringb(m, state->output)) != 0)
		return r;

d2344 2
a2345 2
	const u_char *keyin, *keyout, *input, *output;
	size_t rlen, slen, ilen, olen;
a2370 9

	if ((r = sshbuf_get_string_direct(m, &keyout, &slen)) != 0 ||
	    (r = sshbuf_get_string_direct(m, &keyin, &rlen)) != 0)
		return r;
	if (cipher_get_keycontext(state->send_context, NULL) != (int)slen ||
	    cipher_get_keycontext(state->receive_context, NULL) != (int)rlen)
		return SSH_ERR_INVALID_FORMAT;
	cipher_set_keycontext(state->send_context, keyout);
	cipher_set_keycontext(state->receive_context, keyin);
@


1.252
log
@obliterate ssh1.h and some dead code that used it

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.251 2017/04/30 23:26:16 djm Exp $ */
a180 4
	/* Session key for protocol v1 */
	u_char ssh1_key[SSH_SESSION_KEY_LENGTH];
	u_int ssh1_keylen;

d271 1
a271 2
 * Sets the descriptors used for communication.  Disables encryption until
 * packet_set_encryption_key is called.
a780 12
}

/*
 * Causes any further packets to be encrypted using the given key.  The same
 * key is used for both sending and reception.  However, both directions are
 * encrypted independently of each other.
 */

void
ssh_packet_set_encryption_key(struct ssh *ssh, const u_char *key, u_int keylen, int number)
{
	fatal("no SSH protocol 1 support");
@


1.251
log
@remove the (in)famous SSHv1 CRC compensation attack detector.

Despite your cameo in The Matrix movies, you will not be missed.

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.250 2017/04/30 23:23:54 djm Exp $ */
a65 1
#include "ssh1.h"
@


1.250
log
@remove SSHv1 support from packet and buffer APIs

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.249 2017/04/30 23:13:25 djm Exp $ */
a64 1
#include "deattack.h"
a211 3
	/* SSH1 CRC compensation attack detector */
	struct deattack_ctx deattack;

a307 1
	deattack_init(&state->deattack);
@


1.249
log
@remove compat20/compat13/compat15 variables

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.248 2017/04/30 23:10:43 djm Exp $ */
a1385 147
}

/* Checks if a full packet is available in the data received so far via
 * packet_process_incoming.  If so, reads the packet; otherwise returns
 * SSH_MSG_NONE.  This does not wait for data from the connection.
 *
 * SSH_MSG_DISCONNECT is handled specially here.  Also,
 * SSH_MSG_IGNORE messages are skipped by this function and are never returned
 * to higher levels.
 */

int
ssh_packet_read_poll1(struct ssh *ssh, u_char *typep)
{
	struct session_state *state = ssh->state;
	u_int len, padded_len;
	const char *emsg;
	const u_char *cp;
	u_char *p;
	u_int checksum, stored_checksum;
	int r;

	*typep = SSH_MSG_NONE;

	/* Check if input size is less than minimum packet size. */
	if (sshbuf_len(state->input) < 4 + 8)
		return 0;
	/* Get length of incoming packet. */
	len = PEEK_U32(sshbuf_ptr(state->input));
	if (len < 1 + 2 + 2 || len > 256 * 1024) {
		if ((r = sshpkt_disconnect(ssh, "Bad packet length %u",
		    len)) != 0)
			return r;
		return SSH_ERR_CONN_CORRUPT;
	}
	padded_len = (len + 8) & ~7;

	/* Check if the packet has been entirely received. */
	if (sshbuf_len(state->input) < 4 + padded_len)
		return 0;

	/* The entire packet is in buffer. */

	/* Consume packet length. */
	if ((r = sshbuf_consume(state->input, 4)) != 0)
		goto out;

	/*
	 * Cryptographic attack detector for ssh
	 * (C)1998 CORE-SDI, Buenos Aires Argentina
	 * Ariel Futoransky(futo@@core-sdi.com)
	 */
	if (!cipher_ctx_is_plaintext(state->receive_context)) {
		emsg = NULL;
		switch (detect_attack(&state->deattack,
		    sshbuf_ptr(state->input), padded_len)) {
		case DEATTACK_OK:
			break;
		case DEATTACK_DETECTED:
			emsg = "crc32 compensation attack detected";
			break;
		case DEATTACK_DOS_DETECTED:
			emsg = "deattack denial of service detected";
			break;
		default:
			emsg = "deattack error";
			break;
		}
		if (emsg != NULL) {
			error("%s", emsg);
			if ((r = sshpkt_disconnect(ssh, "%s", emsg)) != 0 ||
			    (r = ssh_packet_write_wait(ssh)) != 0)
					return r;
			return SSH_ERR_CONN_CORRUPT;
		}
	}

	/* Decrypt data to incoming_packet. */
	sshbuf_reset(state->incoming_packet);
	if ((r = sshbuf_reserve(state->incoming_packet, padded_len, &p)) != 0)
		goto out;
	if ((r = cipher_crypt(state->receive_context, 0, p,
	    sshbuf_ptr(state->input), padded_len, 0, 0)) != 0)
		goto out;

	if ((r = sshbuf_consume(state->input, padded_len)) != 0)
		goto out;

#ifdef PACKET_DEBUG
	fprintf(stderr, "read_poll plain: ");
	sshbuf_dump(state->incoming_packet, stderr);
#endif

	/* Compute packet checksum. */
	checksum = ssh_crc32(sshbuf_ptr(state->incoming_packet),
	    sshbuf_len(state->incoming_packet) - 4);

	/* Skip padding. */
	if ((r = sshbuf_consume(state->incoming_packet, 8 - len % 8)) != 0)
		goto out;

	/* Test check bytes. */
	if (len != sshbuf_len(state->incoming_packet)) {
		error("%s: len %d != sshbuf_len %zd", __func__,
		    len, sshbuf_len(state->incoming_packet));
		if ((r = sshpkt_disconnect(ssh, "invalid packet length")) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			return r;
		return SSH_ERR_CONN_CORRUPT;
	}

	cp = sshbuf_ptr(state->incoming_packet) + len - 4;
	stored_checksum = PEEK_U32(cp);
	if (checksum != stored_checksum) {
		error("Corrupted check bytes on input");
		if ((r = sshpkt_disconnect(ssh, "connection corrupted")) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			return r;
		return SSH_ERR_CONN_CORRUPT;
	}
	if ((r = sshbuf_consume_end(state->incoming_packet, 4)) < 0)
		goto out;

	if (state->packet_compression) {
		sshbuf_reset(state->compression_buffer);
		if ((r = uncompress_buffer(ssh, state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
		sshbuf_reset(state->incoming_packet);
		if ((r = sshbuf_putb(state->incoming_packet,
		    state->compression_buffer)) != 0)
			goto out;
	}
	state->p_read.packets++;
	state->p_read.bytes += padded_len + 4;
	if ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
		goto out;
	if (*typep < SSH_MSG_MIN || *typep > SSH_MSG_MAX) {
		error("Invalid ssh1 packet type: %d", *typep);
		if ((r = sshpkt_disconnect(ssh, "invalid packet type")) != 0 ||
		    (r = ssh_packet_write_wait(ssh)) != 0)
			return r;
		return SSH_ERR_PROTOCOL_ERROR;
	}
	r = 0;
 out:
	return r;
@


1.248
log
@unifdef WITH_SSH1
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.247 2017/03/11 13:07:35 markus Exp $ */
d275 2
a276 2
	return compat20 &&
	    (ssh->state->rekeying || (ssh->kex != NULL && ssh->kex->done == 0));
d690 1
a690 1
	if (ssh->state->packet_compression && !compat20)
a805 93
/*
 * Finalizes and sends the packet.  If the encryption key has been set,
 * encrypts the packet before sending.
 */

int
ssh_packet_send1(struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	u_char buf[8], *cp;
	int r, padding, len;
	u_int checksum;

	/*
	 * If using packet compression, compress the payload of the outgoing
	 * packet.
	 */
	if (state->packet_compression) {
		sshbuf_reset(state->compression_buffer);
		/* Skip padding. */
		if ((r = sshbuf_consume(state->outgoing_packet, 8)) != 0)
			goto out;
		/* padding */
		if ((r = sshbuf_put(state->compression_buffer,
		    "\0\0\0\0\0\0\0\0", 8)) != 0)
			goto out;
		if ((r = compress_buffer(ssh, state->outgoing_packet,
		    state->compression_buffer)) != 0)
			goto out;
		sshbuf_reset(state->outgoing_packet);
                if ((r = sshbuf_putb(state->outgoing_packet,
                    state->compression_buffer)) != 0)
			goto out;
	}
	/* Compute packet length without padding (add checksum, remove padding). */
	len = sshbuf_len(state->outgoing_packet) + 4 - 8;

	/* Insert padding. Initialized to zero in packet_start1() */
	padding = 8 - len % 8;
	if (!cipher_ctx_is_plaintext(state->send_context)) {
		cp = sshbuf_mutable_ptr(state->outgoing_packet);
		if (cp == NULL) {
			r = SSH_ERR_INTERNAL_ERROR;
			goto out;
		}
		arc4random_buf(cp + 8 - padding, padding);
	}
	if ((r = sshbuf_consume(state->outgoing_packet, 8 - padding)) != 0)
		goto out;

	/* Add check bytes. */
	checksum = ssh_crc32(sshbuf_ptr(state->outgoing_packet),
	    sshbuf_len(state->outgoing_packet));
	POKE_U32(buf, checksum);
	if ((r = sshbuf_put(state->outgoing_packet, buf, 4)) != 0)
		goto out;

#ifdef PACKET_DEBUG
	fprintf(stderr, "packet_send plain: ");
	sshbuf_dump(state->outgoing_packet, stderr);
#endif

	/* Append to output. */
	POKE_U32(buf, len);
	if ((r = sshbuf_put(state->output, buf, 4)) != 0)
		goto out;
	if ((r = sshbuf_reserve(state->output,
	    sshbuf_len(state->outgoing_packet), &cp)) != 0)
		goto out;
	if ((r = cipher_crypt(state->send_context, 0, cp,
	    sshbuf_ptr(state->outgoing_packet),
	    sshbuf_len(state->outgoing_packet), 0, 0)) != 0)
		goto out;

#ifdef PACKET_DEBUG
	fprintf(stderr, "encrypted: ");
	sshbuf_dump(state->output, stderr);
#endif
	state->p_send.packets++;
	state->p_send.bytes += len +
	    sshbuf_len(state->outgoing_packet);
	sshbuf_reset(state->outgoing_packet);

	/*
	 * Note that the packet is now only buffered in output.  It won't be
	 * actually sent until ssh_packet_write_wait or ssh_packet_write_poll
	 * is called.
	 */
	r = 0;
 out:
	return r;
}

a1295 7
		if (!compat20 && (
		    *typep == SSH_SMSG_SUCCESS
		    || *typep == SSH_SMSG_FAILURE
		    || *typep == SSH_CMSG_EOF
		    || *typep == SSH_CMSG_EXIT_CONFIRMATION))
			if ((r = sshpkt_get_end(ssh)) != 0)
				break;
d1815 16
a1830 3
		if (compat20) {
			r = ssh_packet_read_poll2(ssh, typep, seqnr_p);
			if (r != 0)
a1831 64
			if (*typep) {
				state->keep_alive_timeouts = 0;
				DBG(debug("received packet type %d", *typep));
			}
			switch (*typep) {
			case SSH2_MSG_IGNORE:
				debug3("Received SSH2_MSG_IGNORE");
				break;
			case SSH2_MSG_DEBUG:
				if ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||
				    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0 ||
				    (r = sshpkt_get_string(ssh, NULL, NULL)) != 0) {
					free(msg);
					return r;
				}
				debug("Remote: %.900s", msg);
				free(msg);
				break;
			case SSH2_MSG_DISCONNECT:
				if ((r = sshpkt_get_u32(ssh, &reason)) != 0 ||
				    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0)
					return r;
				/* Ignore normal client exit notifications */
				do_log2(ssh->state->server_side &&
				    reason == SSH2_DISCONNECT_BY_APPLICATION ?
				    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_ERROR,
				    "Received disconnect from %s port %d:"
				    "%u: %.400s", ssh_remote_ipaddr(ssh),
				    ssh_remote_port(ssh), reason, msg);
				free(msg);
				return SSH_ERR_DISCONNECTED;
			case SSH2_MSG_UNIMPLEMENTED:
				if ((r = sshpkt_get_u32(ssh, &seqnr)) != 0)
					return r;
				debug("Received SSH2_MSG_UNIMPLEMENTED for %u",
				    seqnr);
				break;
			default:
				return 0;
			}
		} else {
			r = ssh_packet_read_poll1(ssh, typep);
			switch (*typep) {
			case SSH_MSG_NONE:
				return SSH_MSG_NONE;
			case SSH_MSG_IGNORE:
				break;
			case SSH_MSG_DEBUG:
				if ((r = sshpkt_get_string(ssh, &msg, NULL)) != 0)
					return r;
				debug("Remote: %.900s", msg);
				free(msg);
				break;
			case SSH_MSG_DISCONNECT:
				if ((r = sshpkt_get_string(ssh, &msg, NULL)) != 0)
					return r;
				error("Received disconnect from %s port %d: "
				    "%.400s", ssh_remote_ipaddr(ssh),
				    ssh_remote_port(ssh), msg);
				free(msg);
				return SSH_ERR_DISCONNECTED;
			default:
				DBG(debug("received packet type %d", *typep));
				return 0;
d1833 24
d1908 1
a1908 1
	if (compat20 && (ssh->compat & SSH_BUG_DEBUG))
d1915 6
a1920 14
	if (compat20) {
		if ((r = sshpkt_start(ssh, SSH2_MSG_DEBUG)) != 0 ||
		    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* always display */
		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, "")) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			fatal("%s: %s", __func__, ssh_err(r));
	} else {
		if ((r = sshpkt_start(ssh, SSH_MSG_DEBUG)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			fatal("%s: %s", __func__, ssh_err(r));
	}
	if ((r = ssh_packet_write_wait(ssh)) != 0)
d2233 1
a2233 2
	if ((r = sshpkt_start(ssh, compat20 ?
	    SSH2_MSG_IGNORE : SSH_MSG_IGNORE)) != 0 ||
d2378 1
a2378 1
	int r, ssh1cipher;
d2380 14
a2393 30
	if (!compat20) {
		ssh1cipher = cipher_ctx_get_number(state->receive_context);
		slen = cipher_get_keyiv_len(state->send_context);
		rlen = cipher_get_keyiv_len(state->receive_context);
		if ((r = sshbuf_put_u32(m, state->remote_protocol_flags)) != 0 ||
		    (r = sshbuf_put_u32(m, ssh1cipher)) != 0 ||
		    (r = sshbuf_put_string(m, state->ssh1_key, state->ssh1_keylen)) != 0 ||
		    (r = sshbuf_put_u32(m, slen)) != 0 ||
		    (r = sshbuf_reserve(m, slen, &p)) != 0 ||
		    (r = cipher_get_keyiv(state->send_context, p, slen)) != 0 ||
		    (r = sshbuf_put_u32(m, rlen)) != 0 ||
		    (r = sshbuf_reserve(m, rlen, &p)) != 0 ||
		    (r = cipher_get_keyiv(state->receive_context, p, rlen)) != 0)
			return r;
	} else {
		if ((r = kex_to_blob(m, ssh->kex)) != 0 ||
		    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||
		    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||
		    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||
		    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||
		    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||
		    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||
		    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||
		    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||
		    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||
		    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||
		    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||
		    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0)
			return r;
	}
d2532 2
a2533 2
	const u_char *ssh1key, *ivin, *ivout, *keyin, *keyout, *input, *output;
	size_t ssh1keylen, rlen, slen, ilen, olen;
a2534 1
	u_int ssh1cipher = 0;
d2536 24
a2559 42
	if (!compat20) {
		if ((r = sshbuf_get_u32(m, &state->remote_protocol_flags)) != 0 ||
		    (r = sshbuf_get_u32(m, &ssh1cipher)) != 0 ||
		    (r = sshbuf_get_string_direct(m, &ssh1key, &ssh1keylen)) != 0 ||
		    (r = sshbuf_get_string_direct(m, &ivout, &slen)) != 0 ||
		    (r = sshbuf_get_string_direct(m, &ivin, &rlen)) != 0)
			return r;
		if (ssh1cipher > INT_MAX)
			return SSH_ERR_KEY_UNKNOWN_CIPHER;
		ssh_packet_set_encryption_key(ssh, ssh1key, ssh1keylen,
		    (int)ssh1cipher);
		if (cipher_get_keyiv_len(state->send_context) != (int)slen ||
		    cipher_get_keyiv_len(state->receive_context) != (int)rlen)
			return SSH_ERR_INVALID_FORMAT;
		if ((r = cipher_set_keyiv(state->send_context, ivout)) != 0 ||
		    (r = cipher_set_keyiv(state->receive_context, ivin)) != 0)
			return r;
	} else {
		if ((r = kex_from_blob(m, &ssh->kex)) != 0 ||
		    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||
		    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||
		    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||
		    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||
		    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||
		    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||
		    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||
		    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||
		    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||
		    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||
		    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||
		    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)
			return r;
		/*
		 * We set the time here so that in post-auth privsep slave we
		 * count from the completion of the authentication.
		 */
		state->rekey_time = monotime();
		/* XXX ssh_set_newkeys overrides p_read.packets? XXX */
		if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||
		    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)
			return r;
	}
d2733 1
a2733 2
	u_char buf[9];
	int len;
d2736 2
a2737 3
	len = compat20 ? 6 : 9;
	memset(buf, 0, len - 1);
	buf[len - 1] = type;
d2739 1
a2739 1
	return sshbuf_put(ssh->state->outgoing_packet, buf, len);
d2779 1
a2779 4
	if (compat20)
		return ssh_packet_send2(ssh);
	else
		return ssh_packet_send1(ssh);
d2793 6
a2798 13
	if (compat20) {
		if ((r = sshpkt_start(ssh, SSH2_MSG_DISCONNECT)) != 0 ||
		    (r = sshpkt_put_u32(ssh, SSH2_DISCONNECT_PROTOCOL_ERROR)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, "")) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			return r;
	} else {
		if ((r = sshpkt_start(ssh, SSH_MSG_DISCONNECT)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			return r;
	}
@


1.247
log
@Don't count the initial block twice when computing how many bytes
to discard for the work around for the attacks against CBC-mode.
ok djm@@; report from Jean Paul, Kenny, Martin and Torben @@ RHUL
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.246 2017/02/28 06:10:08 djm Exp $ */
a802 1
#ifndef WITH_SSH1
a803 26
#else /* WITH_SSH1 */
	struct session_state *state = ssh->state;
	const struct sshcipher *cipher = cipher_by_number(number);
	int r;
	const char *wmsg;

	if (cipher == NULL)
		fatal("%s: unknown cipher number %d", __func__, number);
	if (keylen < 20)
		fatal("%s: keylen too small: %d", __func__, keylen);
	if (keylen > SSH_SESSION_KEY_LENGTH)
		fatal("%s: keylen too big: %d", __func__, keylen);
	memcpy(state->ssh1_key, key, keylen);
	state->ssh1_keylen = keylen;
	if ((r = cipher_init(&state->send_context, cipher, key, keylen,
	    NULL, 0, CIPHER_ENCRYPT)) != 0 ||
	    (r = cipher_init(&state->receive_context, cipher, key, keylen,
	    NULL, 0, CIPHER_DECRYPT) != 0))
		fatal("%s: cipher_init failed: %s", __func__, ssh_err(r));
	if (!state->cipher_warning_done &&
	    ((wmsg = cipher_warning_message(state->send_context)) != NULL ||
	    (wmsg = cipher_warning_message(state->send_context)) != NULL)) {
		error("Warning: %s", wmsg);
		state->cipher_warning_done = 1;
	}
#endif /* WITH_SSH1 */
a2815 7
#ifdef WITH_SSH1
int
sshpkt_put_bignum1(struct ssh *ssh, const BIGNUM *v)
{
	return sshbuf_put_bignum1(ssh->state->outgoing_packet, v);
}
#endif /* WITH_SSH1 */
a2874 7
#ifdef WITH_SSH1
int
sshpkt_get_bignum1(struct ssh *ssh, BIGNUM *v)
{
	return sshbuf_get_bignum1(ssh->state->incoming_packet, v);
}
#endif /* WITH_SSH1 */
@


1.246
log
@small memleak: free fd_set on connection timeout (though we are heading to
exit anyway). From Tom Rix in bz#2683
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.245 2017/02/03 23:03:33 djm Exp $ */
d1841 1
a1841 1
			if (need > PACKET_MAX_SIZE)
d1845 1
a1845 1
			    PACKET_MAX_SIZE - need);
@


1.245
log
@add ssh_packet_set_log_preamble() to allow inclusion of a preamble
string in disconnect messages; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.244 2017/02/03 02:56:00 dtucker Exp $ */
d1457 4
a1460 2
		if (r == 0)
			return SSH_ERR_CONN_TIMEOUT;
@


1.244
log
@Make ssh_packet_set_rekey_limits take u32 for the number of seconds
until rekeying (negative values are rejected at config parse time).
This allows the removal of some casts and a signed vs unsigned
comparison warning.

rekey_time is cast to int64 for the comparison which is a no-op
on OpenBSD, but should also do the right thing in -portable on
anything still using 32bit time_t (until the system time actually
wraps, anyway).

some early guidance deraadt@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.243 2016/10/11 21:47:45 djm Exp $ */
d350 19
d2084 9
d2099 4
d2105 1
a2105 2
		logdie("Connection closed by %.200s port %d",
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
d2107 2
a2108 3
		logdie("Connection %s %.200s port %d timed out",
		    ssh->state->server_side ? "from" : "to",
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
d2110 1
a2110 2
		logdie("Disconnected from %.200s port %d",
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
d2113 1
a2113 2
			logdie("Connection reset by %.200s port %d",
			    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
d2121 2
a2122 3
			logdie("Unable to negotiate with %.200s port %d: %s. "
			    "Their offer: %s", ssh_remote_ipaddr(ssh),
			    ssh_remote_port(ssh), ssh_err(r),
d2127 1
a2127 1
		logdie("%s%sConnection %s %.200s port %d: %s",
d2130 1
a2130 1
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), ssh_err(r));
d2143 1
a2143 1
	char buf[1024];
d2156 1
d2162 1
a2162 1
	logit("Disconnecting: %.100s", buf);
@


1.243
log
@Add a per-packet input hook that is called with the decrypted packet
contents. This will be used for fuzzing; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.242 2016/09/30 09:19:13 markus Exp $ */
d1041 1
a1041 1
	    state->rekey_time + state->rekey_interval <= monotime())
d2379 1
a2379 1
ssh_packet_set_rekey_limits(struct ssh *ssh, u_int64_t bytes, time_t seconds)
d2381 2
a2382 2
	debug3("rekey after %llu bytes, %d seconds", (unsigned long long)bytes,
	    (int)seconds);
@


1.242
log
@ssh proxy mux mode (-O proxy; idea from Simon Tatham):
- mux client speaks the ssh-packet protocol directly over unix-domain socket.
- mux server acts as a proxy, translates channel IDs and relays to the server.
- no filedescriptor passing necessary.
- combined with unix-domain forwarding it's even possible to run mux client
  and server on different machines.
feedback & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.241 2016/09/28 21:44:52 djm Exp $ */
d216 4
d264 7
d1886 4
@


1.241
log
@put back some pre-auth zlib bits that I shouldn't have removed -
they are still used by the client. Spotted by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.240 2016/09/28 20:32:42 djm Exp $ */
d201 3
d325 13
d1086 1
a1086 1
static int
d1630 38
d1680 3
d2911 30
d2946 2
@


1.240
log
@restore pre-auth compression support in the client -- the previous
commit was intended to remove it from the server only.

remove a few server-side pre-auth compression bits that escaped

adjust wording of Compression directive in sshd_config(5)

pointed out by naddy@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.239 2016/09/28 16:33:07 djm Exp $ */
d957 3
a959 2
	if (comp->type == COMP_DELAYED && state->after_authentication &&
	    comp->enabled == 0) {
@


1.239
log
@Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@@ markus@@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.238 2016/09/19 19:02:19 markus Exp $ */
d957 2
a958 3
	if ((comp->type == COMP_ZLIB ||
	    (comp->type == COMP_DELAYED &&
	     state->after_authentication)) && comp->enabled == 0) {
@


1.238
log
@move inbound NEWKEYS handling to kex layer; otherwise early NEWKEYS causes
NULL deref; found by Robert Swiecki/honggfuzz; fixed with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.237 2016/09/12 01:22:38 deraadt Exp $ */
a747 80
/* Serialise compression state into a blob for privsep */
static int
ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	struct sshbuf *b;
	int r;

	if ((b = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if (state->compression_in_started) {
		if ((r = sshbuf_put_string(b, &state->compression_in_stream,
		    sizeof(state->compression_in_stream))) != 0)
			goto out;
	} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)
		goto out;
	if (state->compression_out_started) {
		if ((r = sshbuf_put_string(b, &state->compression_out_stream,
		    sizeof(state->compression_out_stream))) != 0)
			goto out;
	} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)
		goto out;
	r = sshbuf_put_stringb(m, b);
 out:
	sshbuf_free(b);
	return r;
}

/* Deserialise compression state from a blob for privsep */
static int
ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)
{
	struct session_state *state = ssh->state;
	struct sshbuf *b = NULL;
	int r;
	const u_char *inblob, *outblob;
	size_t inl, outl;

	if ((r = sshbuf_froms(m, &b)) != 0)
		goto out;
	if ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||
	    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)
		goto out;
	if (inl == 0)
		state->compression_in_started = 0;
	else if (inl != sizeof(state->compression_in_stream)) {
		r = SSH_ERR_INTERNAL_ERROR;
		goto out;
	} else {
		state->compression_in_started = 1;
		memcpy(&state->compression_in_stream, inblob, inl);
	}
	if (outl == 0)
		state->compression_out_started = 0;
	else if (outl != sizeof(state->compression_out_stream)) {
		r = SSH_ERR_INTERNAL_ERROR;
		goto out;
	} else {
		state->compression_out_started = 1;
		memcpy(&state->compression_out_stream, outblob, outl);
	}
	r = 0;
 out:
	sshbuf_free(b);
	return r;
}

void
ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,
    void *(*allocfunc)(void *, u_int, u_int),
    void (*freefunc)(void *, void *))
{
	ssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;
	ssh->state->compression_out_stream.zfree = (free_func)freefunc;
	ssh->state->compression_out_stream.opaque = ctx;
	ssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;
	ssh->state->compression_in_stream.zfree = (free_func)freefunc;
	ssh->state->compression_in_stream.opaque = ctx;
}

d2353 1
a2353 2
	struct sshcomp *comp;
	int r, mode;
d2359 2
a2360 8
	for (mode = 0; mode < MODE_MAX; mode++) {
		if (ssh->state->newkeys[mode] == NULL)
			continue;
		comp = &ssh->state->newkeys[mode]->comp;
		if (comp && comp->enabled &&
		    (r = ssh_packet_init_compression(ssh)) != 0)
			return r;
	}
a2423 1
	    (r = sshbuf_put_u32(b, comp->enabled)) != 0 ||
d2484 1
a2484 3

	if ((r = ssh_packet_get_compress_state(m, ssh)) != 0 ||
	    (r = sshbuf_put_stringb(m, state->input)) != 0 ||
a2537 1
	    (r = sshbuf_get_u32(b, (u_int *)&comp->enabled)) != 0 ||
d2665 1
a2665 2
	if ((r = ssh_packet_set_compress_state(ssh, m)) != 0 ||
	    (r = ssh_packet_set_postauth(ssh)) != 0)
@


1.237
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.236 2016/09/06 09:22:56 markus Exp $ */
d1898 1
a1898 3
	if (*typep == SSH2_MSG_NEWKEYS)
		r = ssh_set_newkeys(ssh, MODE_IN);
	else if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
@


1.236
log
@ssh_set_newkeys: print correct block counters on rekeying; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.235 2016/08/03 05:41:57 djm Exp $ */
a39 1
#include <sys/param.h>	/* MIN roundup */
d1060 1
a1060 1
		*max_blocks = MIN(*max_blocks,
d1103 1
a1103 1
	out_blocks = roundup(outbound_packet_len,
d1231 1
a1231 1
		    roundup(state->extra_pad, block_size);
@


1.235
log
@small refactor of cipher.c: make ciphercontext opaque to callers
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.234 2016/07/18 11:35:33 markus Exp $ */
d969 1
d971 1
a971 1
	const char *wmsg;
d977 1
d980 1
a980 1
		state->p_send.packets = state->p_send.blocks = 0;
d983 1
d986 1
a986 1
		state->p_read.packets = state->p_read.blocks = 0;
d990 4
a993 6
		debug("set_newkeys: rekeying, input %llu bytes %llu blocks, "
		   "output %llu bytes %llu blocks",
		   (unsigned long long)state->p_read.bytes,
		   (unsigned long long)state->p_read.blocks,
		   (unsigned long long)state->p_send.bytes,
		   (unsigned long long)state->p_send.blocks);
d1011 2
@


1.234
log
@Reduce timing attack against obsolete CBC modes by always computing
the MAC over a fixed size of data.
Reported by Jean Paul Degabriele, Kenny Paterson, Torben Hansen and
Martin Albrecht. ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.233 2016/07/18 06:08:01 djm Exp $ */
d119 1
a119 1
	struct sshcipher_ctx receive_context;
d122 1
a122 1
	struct sshcipher_ctx send_context;
a520 1
	int r;
d564 3
a566 4
	if ((r = cipher_cleanup(&state->send_context)) != 0)
		error("%s: cipher_cleanup failed: %s", __func__, ssh_err(r));
	if ((r = cipher_cleanup(&state->receive_context)) != 0)
		error("%s: cipher_cleanup failed: %s", __func__, ssh_err(r));
d860 2
a861 2
	    ((wmsg = cipher_warning_message(&state->send_context)) != NULL ||
	    (wmsg = cipher_warning_message(&state->send_context)) != NULL)) {
d907 1
a907 1
	if (!state->send_context.plaintext) {
d937 1
a937 1
	if ((r = cipher_crypt(&state->send_context, 0, cp,
d968 1
a968 1
	struct sshcipher_ctx *cc;
d976 1
a976 1
		cc = &state->send_context;
d981 1
a981 1
		cc = &state->receive_context;
d993 2
a994 2
		if ((r = cipher_cleanup(cc)) != 0)
			return r;
d1023 1
a1023 1
	if ((r = cipher_init(cc, enc->cipher, enc->key, enc->key_len,
d1027 1
a1027 1
	    (wmsg = cipher_warning_message(cc)) != NULL) {
d1249 1
a1249 1
	if (enc && !state->send_context.plaintext) {
d1281 1
a1281 1
	if ((r = cipher_crypt(&state->send_context, state->p_send.seqnr, cp,
d1595 1
a1595 1
	if (!state->receive_context.plaintext) {
d1624 1
a1624 1
	if ((r = cipher_crypt(&state->receive_context, 0, p,
d1722 1
a1722 1
		if (cipher_get_length(&state->receive_context,
d1748 1
a1748 1
		if ((r = cipher_crypt(&state->receive_context,
d1816 1
a1816 1
	if ((r = cipher_crypt(&state->receive_context, state->p_read.seqnr, cp,
d2490 2
a2491 2
	cc = (mode == MODE_OUT) ? &ssh->state->send_context :
	    &ssh->state->receive_context;
d2530 3
a2532 3
		ssh1cipher = cipher_get_number(state->receive_context.cipher);
		slen = cipher_get_keyiv_len(&state->send_context);
		rlen = cipher_get_keyiv_len(&state->receive_context);
d2538 1
a2538 1
		    (r = cipher_get_keyiv(&state->send_context, p, slen)) != 0 ||
d2541 1
a2541 1
		    (r = cipher_get_keyiv(&state->receive_context, p, rlen)) != 0)
d2560 2
a2561 2
	slen = cipher_get_keycontext(&state->send_context, NULL);
	rlen = cipher_get_keycontext(&state->receive_context, NULL);
d2565 1
a2565 1
	if (cipher_get_keycontext(&state->send_context, p) != (int)slen)
d2570 1
a2570 1
	if (cipher_get_keycontext(&state->receive_context, p) != (int)rlen)
d2716 2
a2717 2
		if (cipher_get_keyiv_len(&state->send_context) != (int)slen ||
		    cipher_get_keyiv_len(&state->receive_context) != (int)rlen)
d2719 2
a2720 2
		if ((r = cipher_set_keyiv(&state->send_context, ivout)) != 0 ||
		    (r = cipher_set_keyiv(&state->receive_context, ivin)) != 0)
d2750 2
a2751 2
	if (cipher_get_keycontext(&state->send_context, NULL) != (int)slen ||
	    cipher_get_keycontext(&state->receive_context, NULL) != (int)rlen)
d2753 2
a2754 2
	cipher_set_keycontext(&state->send_context, keyout);
	cipher_set_keycontext(&state->receive_context, keyin);
@


1.233
log
@Add some unsigned overflow checks for extra_pad. None of these
are reachable with the amount of padding that we use internally.
bz#2566, pointed out by Torben Hansen. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.232 2016/07/15 05:01:58 dtucker Exp $ */
d193 1
d331 1
d333 2
d336 1
a336 2
		while (sshbuf_len(state->incoming_packet) <
		    PACKET_MAX_SIZE)
d342 1
a342 1
		    sshbuf_ptr(state->incoming_packet), PACKET_MAX_SIZE,
d352 1
a352 1
    struct sshmac *mac, u_int packet_length, u_int discard)
d362 5
a366 1
	if (packet_length != PACKET_MAX_SIZE && mac && mac->enabled)
d368 4
a371 3
	if (sshbuf_len(state->input) >= discard &&
	   (r = ssh_packet_stop_discard(ssh)) != 0)
		return r;
d1764 2
a1765 2
			return ssh_packet_start_discard(ssh, enc, mac,
			    state->packlen, PACKET_MAX_SIZE);
d1787 2
a1788 2
		return ssh_packet_start_discard(ssh, enc, mac,
		    state->packlen, PACKET_MAX_SIZE - block_size);
d1835 2
a1836 1
			    state->packlen, PACKET_MAX_SIZE - need);
@


1.232
log
@Reduce the syslog level of some relatively common protocol events
from LOG_CRIT by replacing fatal() calls with logdie().  Part of
bz#2585, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.231 2016/07/08 03:44:42 djm Exp $ */
d1163 1
a1163 1
	u_char padlen, pad = 0;
d1221 1
a1221 1
		/* will wrap if extra_pad+padlen > 255 */
d1224 8
a1231 2
		pad = state->extra_pad -
		    ((len + padlen) % state->extra_pad);
d1234 1
d1236 3
@


1.231
log
@Improve crypto ordering for Encrypt-then-MAC (EtM) mode MAC algorithms.

Previously we were computing the MAC, decrypting the packet and then
checking the MAC. This gave rise to the possibility of creating a
side-channel oracle in the decryption step, though no such oracle has
been identified.

This adds a mac_check() function that computes and checks the MAC in
one pass, and uses it to advance MAC checking for EtM algorithms to
before payload decryption.

Reported by Jean Paul Degabriele, Kenny Paterson, Torben Hansen and
Martin Albrecht. feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.230 2016/03/07 19:02:43 djm Exp $ */
d2064 1
a2064 1
		logit("Connection closed by %.200s port %d",
a2065 1
		cleanup_exit(255);
d2067 1
a2067 1
		logit("Connection %s %.200s port %d timed out",
a2069 1
		cleanup_exit(255);
d2071 1
a2071 1
		logit("Disconnected from %.200s port %d",
a2072 1
		cleanup_exit(255);
d2074 2
a2075 2
		if (errno == ECONNRESET) {
			logit("Connection reset by %.200s port %d",
a2076 2
			cleanup_exit(255);
		}
d2084 1
a2084 1
			fatal("Unable to negotiate with %.200s port %d: %s. "
d2091 1
a2091 1
		fatal("%s%sConnection %s %.200s port %d: %s",
@


1.230
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.229 2016/02/17 22:20:14 djm Exp $ */
d1681 1
a1681 1
	u_char *cp, macbuf[SSH_DIGEST_MAX_LENGTH];
d1781 1
a1781 1
		return 0;
d1786 1
a1786 1
	/* EtM: compute mac over encrypted input */
d1788 1
a1788 1
		if ((r = mac_compute(mac, state->p_read.seqnr,
d1790 4
a1793 1
		    macbuf, sizeof(macbuf))) != 0)
d1795 1
a1804 4
	/*
	 * compute MAC over seqnr and packet,
	 * increment sequence number for incoming packet
	 */
d1806 6
a1811 5
		if (!mac->etm)
			if ((r = mac_compute(mac, state->p_read.seqnr,
			    sshbuf_ptr(state->incoming_packet),
			    sshbuf_len(state->incoming_packet),
			    macbuf, sizeof(macbuf))) != 0)
a1812 2
		if (timingsafe_bcmp(macbuf, sshbuf_ptr(state->input),
		    mac->mac_len) != 0) {
d1819 1
a1819 1

@


1.229
log
@rekey refactor broke SSH1; spotted by Tom G. Christensen
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.228 2016/02/08 10:57:07 djm Exp $ */
d49 1
d294 1
a294 1
		free(ssh);
d377 3
d464 3
a466 1
			ssh->remote_port = get_sock_port(sock, 0);
d469 3
a471 1
			ssh->remote_port = 0;
d484 21
@


1.228
log
@refactor activation of rekeying

This makes automatic rekeying internal to the packet code (previously
the server and client loops needed to assist). In doing to it makes
application of rekey limits more accurate by accounting for packets
about to be sent as well as packets queued during rekeying events
themselves.

Based on a patch from dtucker@@ which was in turn based on a patch
Aleksander Adamowski in bz#2521; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.227 2016/02/04 23:43:48 djm Exp $ */
d260 2
a261 2
	return ssh->state->rekeying ||
	    (ssh->kex != NULL && ssh->kex->done == 0);
@


1.227
log
@printf argument casts to avoid warnings on strict compilers
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.226 2016/01/29 05:46:01 djm Exp $ */
d256 8
d1029 45
d1277 12
d1295 1
a1295 1
	int r;
d1297 2
d1300 2
d1303 24
a1326 18
	/* during rekeying we can only send key exchange messages */
	if (state->rekeying) {
		if ((type < SSH2_MSG_TRANSPORT_MIN) ||
		    (type > SSH2_MSG_TRANSPORT_MAX) ||
		    (type == SSH2_MSG_SERVICE_REQUEST) ||
		    (type == SSH2_MSG_SERVICE_ACCEPT) ||
		    (type == SSH2_MSG_EXT_INFO)) {
			debug("enqueue packet: %u", type);
			p = calloc(1, sizeof(*p));
			if (p == NULL)
				return SSH_ERR_ALLOC_FAIL;
			p->type = type;
			p->payload = state->outgoing_packet;
			TAILQ_INSERT_TAIL(&state->outgoing, p, next);
			state->outgoing_packet = sshbuf_new();
			if (state->outgoing_packet == NULL)
				return SSH_ERR_ALLOC_FAIL;
			return 0;
d1328 1
d1344 11
d1359 1
d1863 7
a2343 19
}

#define MAX_PACKETS	(1U<<31)
int
ssh_packet_need_rekeying(struct ssh *ssh)
{
	struct session_state *state = ssh->state;

	if (ssh->compat & SSH_BUG_NOREKEY)
		return 0;
	return
	    (state->p_send.packets > MAX_PACKETS) ||
	    (state->p_read.packets > MAX_PACKETS) ||
	    (state->max_blocks_out &&
	        (state->p_send.blocks > state->max_blocks_out)) ||
	    (state->max_blocks_in &&
	        (state->p_read.blocks > state->max_blocks_in)) ||
	    (state->rekey_interval != 0 && state->rekey_time +
		 state->rekey_interval <= monotime());
@


1.226
log
@include packet type of non-data packets in debug3 output;
ok markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.225 2016/01/29 03:31:03 dtucker Exp $ */
d946 4
a949 2
		   state->p_read.bytes, state->p_read.blocks,
		   state->p_send.bytes, state->p_send.blocks);
d1017 1
a1017 1
	debug("rekey after %llu blocks", *max_blocks);
@


1.225
log
@Revert "account for packets buffered but not yet processed" change as it
breaks for very small RekeyLimit values due to continuous rekeying.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.222 2016/01/14 16:17:40 markus Exp $ */
d1057 14
d1099 2
a1100 1

d1752 2
@


1.224
log
@Allow RekeyLimits in excess of 4G up to 2**63 bits (limited by the return
type of scan_scaled).  Part of bz#2521, ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.223 2016/01/29 02:42:46 dtucker Exp $ */
a2236 1
	u_int32_t buf_in, buf_out;
a2239 4
	buf_in = roundup(sshbuf_len(state->input),
	    state->newkeys[MODE_IN]->enc.block_size);
	buf_out = roundup(sshbuf_len(state->output),
	    state->newkeys[MODE_OUT]->enc.block_size);
d2244 1
a2244 1
	        (state->p_send.blocks + buf_out > state->max_blocks_out)) ||
d2246 1
a2246 1
	        (state->p_read.blocks + buf_in > state->max_blocks_in)) ||
@


1.223
log
@Account for packets buffered but not yet processed when computing whether or
not it is time to perform rekeying.  bz#2521, based loosely on a patch from
olo at fb.com, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.222 2016/01/14 16:17:40 markus Exp $ */
d177 1
a177 2
	u_int64_t max_blocks_in, max_blocks_out;
	u_int32_t rekey_limit;
d944 4
a947 1
		debug("set_newkeys: rekeying");
d1015 1
d2257 1
a2257 1
ssh_packet_set_rekey_limits(struct ssh *ssh, u_int32_t bytes, time_t seconds)
d2259 1
a2259 1
	debug3("rekey after %lld bytes, %d seconds", (long long)bytes,
d2417 1
a2417 1
		    (r = sshbuf_put_u32(m, state->rekey_limit)) != 0 ||
d2596 1
a2596 1
		    (r = sshbuf_get_u32(m, &state->rekey_limit)) != 0 ||
@


1.222
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.221 2015/12/11 04:21:12 mmcc Exp $ */
d2234 1
d2238 4
d2246 1
a2246 1
	        (state->p_send.blocks > state->max_blocks_out)) ||
d2248 1
a2248 1
	        (state->p_read.blocks > state->max_blocks_in)) ||
@


1.221
log
@Remove NULL-checks before sshbuf_free().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.220 2015/12/11 03:24:25 djm Exp $ */
a79 1
#include "roaming.h"
d1270 1
a1270 1
	int len, r, ms_remain, cont;
d1339 1
a1339 5
		do {
			cont = 0;
			len = roaming_read(state->connection_in, buf,
			    sizeof(buf), &cont);
		} while (len == 0 && cont);
d2011 1
a2011 1
	int cont, r;
d2014 2
a2015 3
		cont = 0;
		len = roaming_write(state->connection_out,
		    sshbuf_ptr(state->output), len, &cont);
d2021 1
a2021 1
		if (len == 0 && !cont)
a2290 52
/* XXX TODO update roaming to new API (does not work anyway) */
/*
 * Save the state for the real connection, and use a separate state when
 * resuming a suspended connection.
 */
void
ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;

	close(ssh->state->connection_in);
	ssh->state->connection_in = -1;
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = tmp;
}

/* XXX FIXME FIXME FIXME */
/*
 * Swap in the old state when resuming a connecion.
 */
void
ssh_packet_restore_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;
	u_int len;
	int r;

	tmp = backup_state;
	backup_state = ssh;
	ssh = tmp;
	ssh->state->connection_in = backup_state->state->connection_in;
	backup_state->state->connection_in = -1;
	ssh->state->connection_out = backup_state->state->connection_out;
	backup_state->state->connection_out = -1;
	len = sshbuf_len(backup_state->state->input);
	if (len > 0) {
		if ((r = sshbuf_putb(ssh->state->input,
		    backup_state->state->input)) != 0)
			fatal("%s: %s", __func__, ssh_err(r));
		sshbuf_reset(backup_state->state->input);
		add_recv_bytes(len);
	}
}

a2439 5
	if (compat20) {
		if ((r = sshbuf_put_u64(m, get_sent_bytes())) != 0 ||
		    (r = sshbuf_put_u64(m, get_recv_bytes())) != 0)
			return r;
	}
a2565 1
	u_int64_t sent_bytes = 0, recv_bytes = 0;
a2629 6
	if (compat20) {
		if ((r = sshbuf_get_u64(m, &sent_bytes)) != 0 ||
		    (r = sshbuf_get_u64(m, &recv_bytes)) != 0)
			return r;
		roam_set_bytes(sent_bytes, recv_bytes);
	}
@


1.220
log
@include remote port number in a few more messages; makes tying log
messages together into a session a bit easier; bz#2503 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.219 2015/12/10 17:08:40 mmcc Exp $ */
d2436 1
a2436 2
	if (b != NULL)
		sshbuf_free(b);
d2572 1
a2572 2
	if (b != NULL)
		sshbuf_free(b);
d2605 2
a2606 4
			if (kex->my != NULL)
				sshbuf_free(kex->my);
			if (kex->peer != NULL)
				sshbuf_free(kex->peer);
@


1.219
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.218 2015/12/04 16:41:28 markus Exp $ */
d335 2
a336 1
	logit("Finished discarding for %.200s", ssh_remote_ipaddr(ssh));
d448 2
d451 9
a459 6
	if (ssh->remote_ipaddr == NULL)
		ssh->remote_ipaddr = ssh_packet_connection_is_on_socket(ssh) ?
		    get_peer_ipaddr(ssh->state->connection_in) :
		    strdup("UNKNOWN");
	if (ssh->remote_ipaddr == NULL)
		return "UNKNOWN";
d463 9
d1802 3
a1804 2
				    "Received disconnect from %s: %u: %.400s",
				    ssh_remote_ipaddr(ssh), reason, msg);
d1832 3
a1834 2
				error("Received disconnect from %s: %.400s",
				    ssh_remote_ipaddr(ssh), msg);
d1924 2
a1925 1
		logit("Connection closed by %.200s", ssh_remote_ipaddr(ssh));
d1928 3
a1930 1
		logit("Connection to %.200s timed out", ssh_remote_ipaddr(ssh));
d1933 2
a1934 2
		logit("Disconnected from %.200s",
		    ssh_remote_ipaddr(ssh));
d1938 2
a1939 2
			logit("Connection reset by %.200s",
			    ssh_remote_ipaddr(ssh));
d1949 1
a1949 1
			fatal("Unable to negotiate with %.200s: %s. "
d1951 2
a1952 1
			    ssh_err(r), ssh->kex->failed_choice);
d1956 1
a1956 1
		fatal("%s%sConnection to %.200s: %s",
d1958 2
a1959 1
		    ssh_remote_ipaddr(ssh), ssh_err(r));
@


1.218
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.217 2015/11/08 21:59:11 djm Exp $ */
d511 2
a512 4
	if (ssh->remote_ipaddr) {
		free(ssh->remote_ipaddr);
		ssh->remote_ipaddr = NULL;
	}
d1773 1
a1773 2
					if (msg)
						free(msg);
d2550 1
a2550 2
	if (newkey != NULL)
		free(newkey);
@


1.217
log
@fix OOB read in packet code caused by missing return statement
found by Ben Hawkes; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.216 2015/10/21 11:33:03 gsoares Exp $ */
d1207 2
a1208 1
		    (type == SSH2_MSG_SERVICE_ACCEPT)) {
@


1.216
log
@fix memory leak in error path
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.215 2015/09/21 04:31:00 djm Exp $ */
d1572 1
@


1.215
log
@fix possible hang on closed output; bz#2469 reported by Tomas Kuthan
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.214 2015/08/20 22:32:42 deraadt Exp $ */
d2030 2
a2031 1
	if ((r = ssh_packet_write_poll(ssh)) != 0)
d2033 1
@


1.214
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.213 2015/07/29 04:43:06 djm Exp $ */
d2030 2
a2031 1
	ssh_packet_write_poll(ssh);
@


1.213
log
@include the peer's offer when logging a failure to negotiate a
mutual set of algorithms (kex, pubkey, ciphers, etc.)
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.212 2015/05/01 07:10:01 djm Exp $ */
d1264 1
a1264 1
	setp = (fd_set *)calloc(howmany(state->connection_in + 1,
d2026 1
a2026 1
	setp = (fd_set *)calloc(howmany(state->connection_out + 1,
@


1.212
log
@refactor ssh_dispatch_run_fatal() to use sshpkt_fatal() to better
report error conditions. Teach sshpkt_fatal() about ECONNRESET.

Improves error messages on TCP connection resets. bz#2257

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.211 2015/04/27 01:52:30 djm Exp $ */
d1922 11
@


1.211
log
@fix compilation with OPENSSL=no; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.210 2015/03/24 20:10:08 markus Exp $ */
d1911 1
a1911 2
		logit("Connection to %.200s timed out while "
		    "waiting to write", ssh_remote_ipaddr(ssh));
d1913 11
@


1.210
log
@don't leak 'setp' on error; noted by Nicholas Lemonias; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.209 2015/03/11 00:48:39 jsg Exp $ */
a780 1
#ifdef WITH_OPENSSL
d784 3
d811 1
a812 1
#endif
d2718 1
d2725 1
d2731 1
d2738 1
d2784 1
d2791 1
d2797 1
d2804 1
@


1.209
log
@add back the changes from rev 1.206, djm reverted this by mistake in
rev 1.207
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.208 2015/02/13 18:57:00 markus Exp $ */
d1271 2
a1272 4
	if ((r = ssh_packet_write_wait(ssh)) != 0) {
		free(setp);
		return r;
	}
d1329 8
a1336 4
		if (len == 0)
			return SSH_ERR_CONN_CLOSED;
		if (len < 0)
			return SSH_ERR_SYSTEM_ERROR;
d1340 1
a1340 1
			return r;
d1342 1
@


1.208
log
@make rekey_limit for sshd w/privsep work; ok djm@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.207 2015/02/11 01:20:38 djm Exp $ */
d287 1
d1271 2
a1272 1
	if ((r = ssh_packet_write_wait(ssh)) != 0)
d1274 1
@


1.207
log
@Some packet error messages show the address of the peer, but might be
generated after the socket to the peer has suffered a TCP reset. In
these cases, getpeername() won't work so cache the address earlier.

spotted in the wild via deraadt@@ and tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.205 2015/01/30 01:13:33 djm Exp $ */
d182 1
a182 1
	time_t rekey_interval;	/* how often in seconds */
a2207 5
	/*
	 * We set the time here so that in post-auth privsep slave we count
	 * from the completion of the authentication.
	 */
	ssh->state->rekey_time = monotime();
d2415 2
d2604 2
d2615 5
@


1.206
log
@fix some leaks in error paths
ok markus@@
@
text
@a286 1
		free(ssh);
d291 5
d1270 1
a1270 2
	if ((r = ssh_packet_write_wait(ssh)) != 0) {
		free(setp);
a1271 1
	}
@


1.205
log
@avoid more fatal/exit in the packet.c paths that ssh-keyscan
uses; feedback and "looks good" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.204 2015/01/28 21:15:47 djm Exp $ */
d287 1
d1266 2
a1267 1
	if ((r = ssh_packet_write_wait(ssh)) != 0)
d1269 1
@


1.204
log
@avoid fatal() calls in packet code
makes ssh-keyscan more reliable against server failures
ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.203 2015/01/20 23:14:00 deraadt Exp $ */
d269 4
a272 2
	if (none == NULL)
		fatal("%s: cannot load cipher 'none'", __func__);
d275 4
a278 2
	if (ssh == NULL)
		fatal("%s: cound not allocate state", __func__);
d285 4
a288 2
	    (const u_char *)"", 0, NULL, 0, CIPHER_DECRYPT)) != 0)
		fatal("%s: cipher_init failed: %s", __func__, ssh_err(r));
d891 2
a892 2
	 * actually sent until packet_write_wait or packet_write_poll is
	 * called.
d1261 6
a1266 2
	/* Since we are blocking, ensure that all written packets have been sent. */
	ssh_packet_write_wait(ssh);
d1352 2
a1353 2
void
ssh_packet_read_expect(struct ssh *ssh, int expected_type)
d1355 2
a1356 1
	int type;
d1358 4
a1361 3
	type = ssh_packet_read(ssh);
	if (type != expected_type)
		ssh_packet_disconnect(ssh,
d1363 5
a1367 1
		    expected_type, type);
d1384 1
d1397 6
a1402 3
	if (len < 1 + 2 + 2 || len > 256 * 1024)
		ssh_packet_disconnect(ssh, "Bad packet length %u.",
		    len);
d1421 1
d1427 2
a1428 3
			ssh_packet_disconnect(ssh,
			    "crc32 compensation attack: network attack detected"
			);
d1430 2
a1431 2
			ssh_packet_disconnect(ssh,
			    "deattack denial of service detected");
d1433 9
a1441 1
			ssh_packet_disconnect(ssh, "deattack error");
d1470 2
a1471 3
	if (len != sshbuf_len(state->incoming_packet))
		ssh_packet_disconnect(ssh,
		    "packet_read_poll1: len %d != sshbuf_len %zd.",
d1473 5
d1481 7
a1487 3
	if (checksum != stored_checksum)
		ssh_packet_disconnect(ssh,
		    "Corrupted check bytes on input.");
d1505 7
a1511 3
	if (*typep < SSH_MSG_MIN || *typep > SSH_MSG_MAX)
		ssh_packet_disconnect(ssh,
		    "Invalid ssh1 packet type: %d", *typep);
a1664 1
	/* XXX now it's safe to use fatal/packet_disconnect */
d1678 7
a1684 3
	if (padlen < 4)
		ssh_packet_disconnect(ssh,
		    "Corrupted padlen %d on input.", padlen);
d1711 7
a1717 3
	if (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN)
		ssh_packet_disconnect(ssh,
		    "Invalid ssh2 packet type: %d", *typep);
d1854 1
a1854 1
 * exceed 1024 bytes.  This will automatically call packet_write_wait.
a1855 1

d1883 23
a1905 1
	ssh_packet_write_wait(ssh);
a1913 1

d1937 9
a1945 15
	/* Send the disconnect message to the other side, and wait for it to get sent. */
	if (compat20) {
		if ((r = sshpkt_start(ssh, SSH2_MSG_DISCONNECT)) != 0 ||
		    (r = sshpkt_put_u32(ssh, SSH2_DISCONNECT_PROTOCOL_ERROR)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, "")) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			fatal("%s: %s", __func__, ssh_err(r));
	} else {
		if ((r = sshpkt_start(ssh, SSH_MSG_DISCONNECT)) != 0 ||
		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			fatal("%s: %s", __func__, ssh_err(r));
	}
	ssh_packet_write_wait(ssh);
d1952 5
a1956 3
/* Checks if there is any buffered output, and tries to write some of the output. */

void
d1969 2
a1970 2
				return;
			fatal("Write failed: %.100s", strerror(errno));
d1973 1
a1973 1
			fatal("Write connection closed");
d1975 1
a1975 1
			fatal("%s: %s", __func__, ssh_err(r));
d1977 1
d1984 1
a1984 2

void
d1988 1
a1988 1
	int ret, ms_remain = 0;
d1995 1
a1995 1
		fatal("%s: calloc failed", __func__);
d2025 6
a2030 3
			logit("Connection to %.200s timed out while "
			    "waiting to write", ssh_remote_ipaddr(ssh));
			cleanup_exit(255);
a2031 1
		ssh_packet_write_poll(ssh);
d2034 1
@


1.203
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.202 2015/01/19 20:30:23 markus Exp $ */
d1305 2
a1306 5
		if (r == 0) {
			logit("Connection to %.200s timed out while "
			    "waiting to read", ssh_remote_ipaddr(ssh));
			cleanup_exit(255);
		}
d1313 2
a1314 5
		if (len == 0) {
			logit("Connection closed by %.200s",
			    ssh_remote_ipaddr(ssh));
			cleanup_exit(255);
		}
d1316 2
a1317 1
			fatal("Read from socket failed: %.100s", strerror(errno));
d1319 2
a1320 1
		ssh_packet_process_incoming(ssh, buf, len);
d1774 1
a1774 1
void
d1784 1
a1784 2
				fatal("%s: %s", __func__, ssh_err(r));
			cleanup_exit(255);
d1787 1
a1787 1
		return;
d1790 3
a1792 1
		fatal("%s: %s", __func__, ssh_err(r));
@


1.202
log
@add experimental api for packet layer; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.201 2015/01/19 19:52:16 markus Exp $ */
d40 1
a44 2
#include <sys/param.h>

d54 1
@


1.201
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.200 2015/01/13 19:31:40 markus Exp $ */
d231 2
@


1.200
log
@adapt mac.c to ssherr.h return codes (de-fatal) and simplify dependencies
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.199 2014/10/24 02:01:20 lteo Exp $ */
d58 5
a63 2
#include "buffer.h"
#include "packet.h"
a64 1
#include "compress.h"
d70 1
a70 1
#include "key.h"
d79 2
d82 1
a82 1
#include "roaming.h"
d102 1
a102 1
	Buffer payload;
d119 1
a119 1
	CipherContext receive_context;
d122 1
a122 1
	CipherContext send_context;
d125 1
a125 1
	Buffer input;
d128 1
a128 1
	Buffer output;
d131 1
a131 1
	Buffer outgoing_packet;
d134 1
a134 1
	Buffer incoming_packet;
d137 9
a145 2
	Buffer compression_buffer;
	int compression_buffer_ready;
d174 1
a174 1
	Newkeys *newkeys[MODE_MAX];
d194 1
a194 1
	Mac *packet_discard_mac;
d208 6
d217 2
a218 4
static struct session_state *active_state, *backup_state;

static struct session_state *
alloc_session_state(void)
d220 2
a221 1
	struct session_state *s = xcalloc(1, sizeof(*s));
d223 31
a253 5
	s->connection_in = -1;
	s->connection_out = -1;
	s->max_packet_size = 32768;
	s->packet_timeout_ms = -1;
	return s;
d260 2
a261 2
void
packet_set_connection(int fd_in, int fd_out)
d263 2
a264 1
	const Cipher *none = cipher_by_name("none");
d268 9
a276 6
		fatal("packet_set_connection: cannot load cipher 'none'");
	if (active_state == NULL)
		active_state = alloc_session_state();
	active_state->connection_in = fd_in;
	active_state->connection_out = fd_out;
	if ((r = cipher_init(&active_state->send_context, none,
d278 1
a278 1
	    (r = cipher_init(&active_state->receive_context, none,
d280 4
a283 11
		fatal("%s: cipher_init: %s", __func__, ssh_err(r));
	active_state->newkeys[MODE_IN] = active_state->newkeys[MODE_OUT] = NULL;
	if (!active_state->initialized) {
		active_state->initialized = 1;
		buffer_init(&active_state->input);
		buffer_init(&active_state->output);
		buffer_init(&active_state->outgoing_packet);
		buffer_init(&active_state->incoming_packet);
		TAILQ_INIT(&active_state->outgoing);
		active_state->p_send.packets = active_state->p_read.packets = 0;
	}
d287 1
a287 1
packet_set_timeout(int timeout, int count)
d289 2
d292 1
a292 1
		active_state->packet_timeout_ms = -1;
d296 1
a296 1
		active_state->packet_timeout_ms = INT_MAX;
d298 1
a298 1
		active_state->packet_timeout_ms = timeout * count * 1000;
d301 2
a302 2
static void
packet_stop_discard(void)
d304 4
a307 1
	if (active_state->packet_discard_mac) {
d309 1
a309 1
		
d311 1
a311 1
		while (buffer_len(&active_state->incoming_packet) <
d313 7
a319 6
			buffer_append(&active_state->incoming_packet, buf,
			    sizeof(buf));
		(void) mac_compute(active_state->packet_discard_mac,
		    active_state->p_read.seqnr,
		    buffer_ptr(&active_state->incoming_packet),
		    PACKET_MAX_SIZE, NULL, 0);
d321 2
a322 2
	logit("Finished discarding for %.200s", get_remote_ipaddr());
	cleanup_exit(255);
d325 3
a327 2
static void
packet_start_discard(Enc *enc, Mac *mac, u_int packet_length, u_int discard)
d329 8
a336 2
	if (enc == NULL || !cipher_is_cbc(enc->cipher) || (mac && mac->etm))
		packet_disconnect("Packet corrupt");
d338 6
a343 5
		active_state->packet_discard_mac = mac;
	if (buffer_len(&active_state->input) >= discard)
		packet_stop_discard();
	active_state->packet_discard = discard -
	    buffer_len(&active_state->input);
d349 1
a349 1
packet_connection_is_on_socket(void)
d351 1
d356 1
a356 1
	if (active_state->connection_in == active_state->connection_out)
d360 1
a360 1
	if (getpeername(active_state->connection_in, (struct sockaddr *)&from,
d365 1
a365 1
	if (getpeername(active_state->connection_out, (struct sockaddr *)&to,
a374 34
/*
 * Exports an IV from the CipherContext required to export the key
 * state back from the unprivileged child to the privileged parent
 * process.
 */

void
packet_get_keyiv(int mode, u_char *iv, u_int len)
{
	CipherContext *cc;
	int r;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	if ((r = cipher_get_keyiv(cc, iv, len)) != 0)
		fatal("%s: cipher_get_keyiv: %s", __func__, ssh_err(r));
}

int
packet_get_keycontext(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	return (cipher_get_keycontext(cc, dat));
}

d376 1
a376 1
packet_set_keycontext(int mode, u_char *dat)
d378 4
a381 36
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	cipher_set_keycontext(cc, dat);
}

int
packet_get_keyiv_len(int mode)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	return (cipher_get_keyiv_len(cc));
}

void
packet_set_iv(int mode, u_char *dat)
{
	CipherContext *cc;
	int r;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	if ((r = cipher_set_keyiv(cc, dat)) != 0)
		fatal("%s: cipher_set_keyiv: %s", __func__, ssh_err(r));
d385 1
a385 39
packet_get_ssh1_cipher(void)
{
	return (cipher_get_number(active_state->receive_context.cipher));
}

void
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks,
    u_int32_t *packets, u_int64_t *bytes)
{
	struct packet_state *state;

	state = (mode == MODE_IN) ?
	    &active_state->p_read : &active_state->p_send;
	if (seqnr)
		*seqnr = state->seqnr;
	if (blocks)
		*blocks = state->blocks;
	if (packets)
		*packets = state->packets;
	if (bytes)
		*bytes = state->bytes;
}

void
packet_set_state(int mode, u_int32_t seqnr, u_int64_t blocks, u_int32_t packets,
    u_int64_t bytes)
{
	struct packet_state *state;

	state = (mode == MODE_IN) ?
	    &active_state->p_read : &active_state->p_send;
	state->seqnr = seqnr;
	state->blocks = blocks;
	state->packets = packets;
	state->bytes = bytes;
}

static int
packet_connection_af(void)
d391 1
a391 1
	if (getsockname(active_state->connection_out, (struct sockaddr *)&to,
d400 1
a400 1
packet_set_nonblocking(void)
d403 1
a403 1
	set_nonblock(active_state->connection_in);
d405 2
a406 2
	if (active_state->connection_out != active_state->connection_in)
		set_nonblock(active_state->connection_out);
d412 1
a412 1
packet_get_connection_in(void)
d414 1
a414 1
	return active_state->connection_in;
d420 1
a420 1
packet_get_connection_out(void)
d422 19
a440 1
	return active_state->connection_out;
d446 1
a446 1
packet_close(void)
d448 5
a452 1
	if (!active_state->initialized)
d454 4
a457 4
	active_state->initialized = 0;
	if (active_state->connection_in == active_state->connection_out) {
		shutdown(active_state->connection_out, SHUT_RDWR);
		close(active_state->connection_out);
d459 2
a460 2
		close(active_state->connection_in);
		close(active_state->connection_out);
d462 30
a491 7
	buffer_free(&active_state->input);
	buffer_free(&active_state->output);
	buffer_free(&active_state->outgoing_packet);
	buffer_free(&active_state->incoming_packet);
	if (active_state->compression_buffer_ready) {
		buffer_free(&active_state->compression_buffer);
		buffer_compress_uninit();
d493 10
a502 2
	cipher_cleanup(&active_state->send_context);
	cipher_cleanup(&active_state->receive_context);
d508 1
a508 1
packet_set_protocol_flags(u_int protocol_flags)
d510 1
a510 1
	active_state->remote_protocol_flags = protocol_flags;
d516 1
a516 1
packet_get_protocol_flags(void)
d518 1
a518 1
	return active_state->remote_protocol_flags;
d526 2
a527 2
static void
packet_init_compression(void)
d529 4
a532 4
	if (active_state->compression_buffer_ready == 1)
		return;
	active_state->compression_buffer_ready = 1;
	buffer_init(&active_state->compression_buffer);
d535 2
a536 2
void
packet_start_compression(int level)
d538 15
a552 6
	if (active_state->packet_compression && !compat20)
		fatal("Compression already enabled.");
	active_state->packet_compression = 1;
	packet_init_compression();
	buffer_compress_init_send(level);
	buffer_compress_init_recv();
d555 16
a570 5
/*
 * Causes any further packets to be encrypted using the given key.  The same
 * key is used for both sending and reception.  However, both directions are
 * encrypted independently of each other.
 */
d572 2
a573 2
void
packet_set_encryption_key(const u_char *key, u_int keylen, int number)
a574 1
	const Cipher *cipher = cipher_by_number(number);
d577 8
a584 13
	if (cipher == NULL)
		fatal("packet_set_encryption_key: unknown cipher number %d", number);
	if (keylen < 20)
		fatal("packet_set_encryption_key: keylen too small: %d", keylen);
	if (keylen > SSH_SESSION_KEY_LENGTH)
		fatal("packet_set_encryption_key: keylen too big: %d", keylen);
	memcpy(active_state->ssh1_key, key, keylen);
	active_state->ssh1_keylen = keylen;
	if ((r = cipher_init(&active_state->send_context, cipher,
	    key, keylen, NULL, 0, CIPHER_ENCRYPT)) != 0 ||
	    (r = cipher_init(&active_state->receive_context, cipher,
	    key, keylen, NULL, 0, CIPHER_DECRYPT)) != 0)
		fatal("%s: cipher_init: %s", __func__, ssh_err(r));
d587 3
a589 2
u_int
packet_get_encryption_key(u_char *key)
d591 41
a631 4
	if (key == NULL)
		return (active_state->ssh1_keylen);
	memcpy(key, active_state->ssh1_key, active_state->ssh1_keylen);
	return (active_state->ssh1_keylen);
d634 2
a635 3
/* Start constructing a packet to send. */
void
packet_start(u_char type)
d637 2
a638 2
	u_char buf[9];
	int len;
d640 2
a641 7
	DBG(debug("packet_start[%d]", type));
	len = compat20 ? 6 : 9;
	memset(buf, 0, len - 1);
	buf[len - 1] = type;
	buffer_clear(&active_state->outgoing_packet);
	buffer_append(&active_state->outgoing_packet, buf, len);
}
d643 4
a646 5
/* Append payload. */
void
packet_put_char(int value)
{
	char ch = value;
d648 31
a678 1
	buffer_append(&active_state->outgoing_packet, &ch, 1);
d681 3
a683 2
void
packet_put_int(u_int value)
d685 22
a706 1
	buffer_put_int(&active_state->outgoing_packet, value);
d709 3
a711 2
void
packet_put_int64(u_int64_t value)
d713 5
a717 2
	buffer_put_int64(&active_state->outgoing_packet, value);
}
d719 27
a745 4
void
packet_put_string(const void *buf, u_int len)
{
	buffer_put_string(&active_state->outgoing_packet, buf, len);
d749 10
a758 3
packet_put_cstring(const char *str)
{
	buffer_put_cstring(&active_state->outgoing_packet, str);
d761 5
a765 5
void
packet_put_raw(const void *buf, u_int len)
{
	buffer_append(&active_state->outgoing_packet, buf, len);
}
d769 1
a769 1
packet_put_bignum(BIGNUM * value)
d771 4
a774 2
	buffer_put_bignum(&active_state->outgoing_packet, value);
}
d776 19
a794 10
void
packet_put_bignum2(BIGNUM * value)
{
	buffer_put_bignum2(&active_state->outgoing_packet, value);
}

void
packet_put_ecpoint(const EC_GROUP *curve, const EC_POINT *point)
{
	buffer_put_ecpoint(&active_state->outgoing_packet, curve, point);
d803 2
a804 2
static void
packet_send1(void)
d806 1
d808 1
a808 1
	int i, padding, len;
a809 1
	u_int32_t rnd = 0;
d815 2
a816 2
	if (active_state->packet_compression) {
		buffer_clear(&active_state->compression_buffer);
d818 2
a819 1
		buffer_consume(&active_state->outgoing_packet, 8);
d821 10
a830 8
		buffer_append(&active_state->compression_buffer,
		    "\0\0\0\0\0\0\0\0", 8);
		buffer_compress(&active_state->outgoing_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->outgoing_packet);
		buffer_append(&active_state->outgoing_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
d833 1
a833 1
	len = buffer_len(&active_state->outgoing_packet) + 4 - 8;
d837 5
a841 7
	if (!active_state->send_context.plaintext) {
		cp = buffer_ptr(&active_state->outgoing_packet);
		for (i = 0; i < padding; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			cp[7 - i] = rnd & 0xff;
			rnd >>= 8;
d843 1
d845 2
a846 1
	buffer_consume(&active_state->outgoing_packet, 8 - padding);
d849 5
a853 4
	checksum = ssh_crc32(buffer_ptr(&active_state->outgoing_packet),
	    buffer_len(&active_state->outgoing_packet));
	put_u32(buf, checksum);
	buffer_append(&active_state->outgoing_packet, buf, 4);
d857 1
a857 1
	buffer_dump(&active_state->outgoing_packet);
d861 10
a870 8
	put_u32(buf, len);
	buffer_append(&active_state->output, buf, 4);
	cp = buffer_append_space(&active_state->output,
	    buffer_len(&active_state->outgoing_packet));
	if (cipher_crypt(&active_state->send_context, 0, cp,
	    buffer_ptr(&active_state->outgoing_packet),
	    buffer_len(&active_state->outgoing_packet), 0, 0) != 0)
		fatal("%s: cipher_crypt failed", __func__);
d874 1
a874 1
	buffer_dump(&active_state->output);
d876 4
a879 4
	active_state->p_send.packets++;
	active_state->p_send.bytes += len +
	    buffer_len(&active_state->outgoing_packet);
	buffer_clear(&active_state->outgoing_packet);
d886 3
d891 2
a892 2
void
set_newkeys(int mode)
d894 5
a898 4
	Enc *enc;
	Mac *mac;
	Comp *comp;
	CipherContext *cc;
d900 1
d906 1
a906 1
		cc = &active_state->send_context;
d908 2
a909 2
		active_state->p_send.packets = active_state->p_send.blocks = 0;
		max_blocks = &active_state->max_blocks_out;
d911 1
a911 1
		cc = &active_state->receive_context;
d913 2
a914 2
		active_state->p_read.packets = active_state->p_read.blocks = 0;
		max_blocks = &active_state->max_blocks_in;
d916 1
a916 1
	if (active_state->newkeys[mode] != NULL) {
d918 5
a922 4
		cipher_cleanup(cc);
		enc  = &active_state->newkeys[mode]->enc;
		mac  = &active_state->newkeys[mode]->mac;
		comp = &active_state->newkeys[mode]->comp;
d933 1
a933 1
		free(active_state->newkeys[mode]);
d935 12
a946 8
	active_state->newkeys[mode] = kex_get_newkeys(mode);
	if (active_state->newkeys[mode] == NULL)
		fatal("newkeys: no keys for mode %d", mode);
	enc  = &active_state->newkeys[mode]->enc;
	mac  = &active_state->newkeys[mode]->mac;
	comp = &active_state->newkeys[mode]->comp;
	if (cipher_authlen(enc->cipher) == 0 && mac_init(mac) == 0)
		mac->enabled = 1;
d950 6
a955 1
		fatal("%s: cipher_init: %s", __func__, ssh_err(r));
d962 10
a971 6
	     active_state->after_authentication)) && comp->enabled == 0) {
		packet_init_compression();
		if (mode == MODE_OUT)
			buffer_compress_init_send(6);
		else
			buffer_compress_init_recv();
d982 1
a982 1
	if (active_state->rekey_limit)
d984 2
a985 1
		    active_state->rekey_limit / enc->block_size);
d993 2
a994 2
static void
packet_enable_delayed_compress(void)
d996 3
a998 2
	Comp *comp = NULL;
	int mode;
d1004 1
a1004 1
	active_state->after_authentication = 1;
d1007 1
a1007 1
		if (active_state->newkeys[mode] == NULL)
d1009 1
a1009 1
		comp = &active_state->newkeys[mode]->comp;
d1011 9
a1019 5
			packet_init_compression();
			if (mode == MODE_OUT)
				buffer_compress_init_send(6);
			else
				buffer_compress_init_recv();
d1023 1
d1029 2
a1030 2
static void
packet_send2_wrapped(void)
d1032 1
d1035 11
a1045 12
	u_int i, len, authlen = 0, aadlen = 0;
	u_int32_t rnd = 0;
	Enc *enc   = NULL;
	Mac *mac   = NULL;
	Comp *comp = NULL;
	int block_size;
	int r;

	if (active_state->newkeys[MODE_OUT] != NULL) {
		enc  = &active_state->newkeys[MODE_OUT]->enc;
		mac  = &active_state->newkeys[MODE_OUT]->mac;
		comp = &active_state->newkeys[MODE_OUT]->comp;
d1053 1
a1053 2
	cp = buffer_ptr(&active_state->outgoing_packet);
	type = cp[5];
d1057 1
a1057 1
	buffer_dump(&active_state->outgoing_packet);
d1061 1
a1061 1
		len = buffer_len(&active_state->outgoing_packet);
d1063 14
a1076 11
		buffer_consume(&active_state->outgoing_packet, 5);
		buffer_clear(&active_state->compression_buffer);
		buffer_compress(&active_state->outgoing_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->outgoing_packet);
		buffer_append(&active_state->outgoing_packet, "\0\0\0\0\0", 5);
		buffer_append(&active_state->outgoing_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
		DBG(debug("compression: raw %d compressed %d", len,
		    buffer_len(&active_state->outgoing_packet)));
d1080 1
a1080 1
	len = buffer_len(&active_state->outgoing_packet);
d1090 1
a1090 1
	if (active_state->extra_pad) {
d1092 4
a1095 4
		active_state->extra_pad =
		    roundup(active_state->extra_pad, block_size);
		pad = active_state->extra_pad -
		    ((len + padlen) % active_state->extra_pad);
d1097 1
a1097 1
		    __func__, pad, len, padlen, active_state->extra_pad));
d1099 1
a1099 1
		active_state->extra_pad = 0;
d1101 3
a1103 2
	cp = buffer_append_space(&active_state->outgoing_packet, padlen);
	if (enc && !active_state->send_context.plaintext) {
d1105 1
a1105 6
		for (i = 0; i < padlen; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			cp[i] = rnd & 0xff;
			rnd >>= 8;
		}
d1111 6
a1116 2
	len = buffer_len(&active_state->outgoing_packet);
	cp = buffer_ptr(&active_state->outgoing_packet);
d1118 1
a1118 1
	put_u32(cp, len - 4);
d1125 2
a1126 2
		if ((r = mac_compute(mac, active_state->p_send.seqnr,
		    buffer_ptr(&active_state->outgoing_packet), len,
d1128 2
a1129 2
			fatal("%s: mac_compute: %s", __func__, ssh_err(r));
		DBG(debug("done calc MAC out #%d", active_state->p_send.seqnr));
d1132 7
a1138 5
	cp = buffer_append_space(&active_state->output, len + authlen);
	if (cipher_crypt(&active_state->send_context, active_state->p_send.seqnr,
	    cp, buffer_ptr(&active_state->outgoing_packet),
	    len - aadlen, aadlen, authlen) != 0)
		fatal("%s: cipher_crypt failed", __func__);
d1143 3
a1145 4
			if ((r = mac_compute(mac,
			    active_state->p_send.seqnr, cp, len,
			    macbuf, sizeof(macbuf))) != 0)
				fatal("%s: mac_compute: %s", __func__, ssh_err(r));
d1147 1
a1147 1
			    active_state->p_send.seqnr));
d1149 2
a1150 1
		buffer_append(&active_state->output, macbuf, mac->mac_len);
d1154 1
a1154 1
	buffer_dump(&active_state->output);
d1157 1
a1157 1
	if (++active_state->p_send.seqnr == 0)
d1159 6
a1164 6
	if (++active_state->p_send.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	active_state->p_send.blocks += len / block_size;
	active_state->p_send.bytes += len;
	buffer_clear(&active_state->outgoing_packet);
d1167 7
a1173 3
		set_newkeys(MODE_OUT);
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && active_state->server_side)
		packet_enable_delayed_compress();
d1176 2
a1177 2
static void
packet_send2(void)
d1179 1
d1181 2
a1182 1
	u_char type, *cp;
d1184 1
a1184 2
	cp = buffer_ptr(&active_state->outgoing_packet);
	type = cp[5];
d1187 1
a1187 1
	if (active_state->rekeying) {
d1193 3
a1195 1
			p = xcalloc(1, sizeof(*p));
d1197 6
a1202 5
			memcpy(&p->payload, &active_state->outgoing_packet,
			    sizeof(Buffer));
			buffer_init(&active_state->outgoing_packet);
			TAILQ_INSERT_TAIL(&active_state->outgoing, p, next);
			return;
d1208 1
a1208 1
		active_state->rekeying = 1;
d1210 2
a1211 1
	packet_send2_wrapped();
d1215 3
a1217 3
		active_state->rekeying = 0;
		active_state->rekey_time = monotime();
		while ((p = TAILQ_FIRST(&active_state->outgoing))) {
d1220 3
a1222 4
			buffer_free(&active_state->outgoing_packet);
			memcpy(&active_state->outgoing_packet, &p->payload,
			    sizeof(Buffer));
			TAILQ_REMOVE(&active_state->outgoing, p, next);
d1224 2
a1225 1
			packet_send2_wrapped();
d1228 1
a1228 10
}

void
packet_send(void)
{
	if (compat20)
		packet_send2();
	else
		packet_send1();
	DBG(debug("packet_send done"));
d1238 1
a1238 1
packet_read_seqnr(u_int32_t *seqnr_p)
d1240 2
a1241 1
	int type, len, ret, cont, ms_remain = 0;
d1248 1
a1248 1
	setp = (fd_set *)xcalloc(howmany(active_state->connection_in + 1,
d1250 2
d1254 1
a1254 1
	packet_write_wait();
d1259 3
a1261 1
		type = packet_read_poll_seqnr(seqnr_p);
d1263 6
a1268 5
		    type == SSH_SMSG_SUCCESS
		    || type == SSH_SMSG_FAILURE
		    || type == SSH_CMSG_EOF
		    || type == SSH_CMSG_EXIT_CONFIRMATION))
			packet_check_eom();
d1270 2
a1271 4
		if (type != SSH_MSG_NONE) {
			free(setp);
			return type;
		}
d1276 1
a1276 1
		memset(setp, 0, howmany(active_state->connection_in + 1,
d1278 1
a1278 1
		FD_SET(active_state->connection_in, setp);
d1280 2
a1281 2
		if (active_state->packet_timeout_ms > 0) {
			ms_remain = active_state->packet_timeout_ms;
d1286 1
a1286 1
			if (active_state->packet_timeout_ms != -1) {
d1290 1
a1290 1
			if ((ret = select(active_state->connection_in + 1, setp,
d1295 1
a1295 1
			if (active_state->packet_timeout_ms == -1)
d1299 1
a1299 1
				ret = 0;
d1303 1
a1303 1
		if (ret == 0) {
d1305 1
a1305 1
			    "waiting to read", get_remote_ipaddr());
d1311 1
a1311 1
			len = roaming_read(active_state->connection_in, buf,
d1315 2
a1316 1
			logit("Connection closed by %.200s", get_remote_ipaddr());
d1322 1
a1322 1
		packet_process_incoming(buf, len);
d1324 2
a1325 1
	/* NOTREACHED */
d1329 1
a1329 1
packet_read(void)
d1331 6
a1336 1
	return packet_read_seqnr(NULL);
d1345 1
a1345 1
packet_read_expect(int expected_type)
d1349 1
a1349 1
	type = packet_read();
d1351 2
a1352 1
		packet_disconnect("Protocol error: expected packet type %d, got %d",
d1365 2
a1366 2
static int
packet_read_poll1(void)
d1368 1
d1370 2
a1371 1
	u_char *cp, type;
d1373 3
d1378 2
a1379 2
	if (buffer_len(&active_state->input) < 4 + 8)
		return SSH_MSG_NONE;
d1381 1
a1381 2
	cp = buffer_ptr(&active_state->input);
	len = get_u32(cp);
d1383 2
a1384 1
		packet_disconnect("Bad packet length %u.", len);
d1388 2
a1389 2
	if (buffer_len(&active_state->input) < 4 + padded_len)
		return SSH_MSG_NONE;
d1394 2
a1395 1
	buffer_consume(&active_state->input, 4);
d1402 5
a1406 3
	if (!active_state->receive_context.plaintext) {
		switch (detect_attack(buffer_ptr(&active_state->input),
		    padded_len)) {
d1408 3
a1410 2
			packet_disconnect("crc32 compensation attack: "
			    "network attack detected");
d1412 4
a1415 2
			packet_disconnect("deattack denial of "
			    "service detected");
d1420 6
a1425 5
	buffer_clear(&active_state->incoming_packet);
	cp = buffer_append_space(&active_state->incoming_packet, padded_len);
	if (cipher_crypt(&active_state->receive_context, 0, cp,
	    buffer_ptr(&active_state->input), padded_len, 0, 0) != 0)
		fatal("%s: cipher_crypt failed", __func__);
d1427 2
a1428 1
	buffer_consume(&active_state->input, padded_len);
d1432 1
a1432 1
	buffer_dump(&active_state->incoming_packet);
d1436 2
a1437 2
	checksum = ssh_crc32(buffer_ptr(&active_state->incoming_packet),
	    buffer_len(&active_state->incoming_packet) - 4);
d1440 2
a1441 1
	buffer_consume(&active_state->incoming_packet, 8 - len % 8);
d1444 4
a1447 3
	if (len != buffer_len(&active_state->incoming_packet))
		packet_disconnect("packet_read_poll1: len %d != buffer_len %d.",
		    len, buffer_len(&active_state->incoming_packet));
d1449 2
a1450 2
	cp = (u_char *)buffer_ptr(&active_state->incoming_packet) + len - 4;
	stored_checksum = get_u32(cp);
d1452 25
a1476 18
		packet_disconnect("Corrupted check bytes on input.");
	buffer_consume_end(&active_state->incoming_packet, 4);

	if (active_state->packet_compression) {
		buffer_clear(&active_state->compression_buffer);
		buffer_uncompress(&active_state->incoming_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->incoming_packet);
		buffer_append(&active_state->incoming_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
	}
	active_state->p_read.packets++;
	active_state->p_read.bytes += padded_len + 4;
	type = buffer_get_char(&active_state->incoming_packet);
	if (type < SSH_MSG_MIN || type > SSH_MSG_MAX)
		packet_disconnect("Invalid ssh1 packet type: %d", type);
	return type;
d1479 2
a1480 2
static int
packet_read_poll2(u_int32_t *seqnr_p)
d1482 1
d1484 5
a1488 2
	u_char type, *cp, macbuf[SSH_DIGEST_MAX_LENGTH];
	u_int maclen, authlen = 0, aadlen = 0, block_size;
d1490 10
a1499 11
	Enc *enc   = NULL;
	Mac *mac   = NULL;
	Comp *comp = NULL;

	if (active_state->packet_discard)
		return SSH_MSG_NONE;

	if (active_state->newkeys[MODE_IN] != NULL) {
		enc  = &active_state->newkeys[MODE_IN]->enc;
		mac  = &active_state->newkeys[MODE_IN]->mac;
		comp = &active_state->newkeys[MODE_IN]->comp;
d1508 7
a1514 9
	if (aadlen && active_state->packlen == 0) {
		if (cipher_get_length(&active_state->receive_context,
		    &active_state->packlen,
		    active_state->p_read.seqnr,
		    buffer_ptr(&active_state->input),
		    buffer_len(&active_state->input)) != 0)
			return SSH_MSG_NONE;
		if (active_state->packlen < 1 + 4 ||
		    active_state->packlen > PACKET_MAX_SIZE) {
d1516 1
a1516 1
			buffer_dump(&active_state->input);
d1518 3
a1520 2
			logit("Bad packet length %u.", active_state->packlen);
			packet_disconnect("Packet corrupt");
d1522 2
a1523 2
		buffer_clear(&active_state->incoming_packet);
	} else if (active_state->packlen == 0) {
d1528 13
a1540 13
		if (buffer_len(&active_state->input) < block_size)
			return SSH_MSG_NONE;
		buffer_clear(&active_state->incoming_packet);
		cp = buffer_append_space(&active_state->incoming_packet,
		    block_size);
		if (cipher_crypt(&active_state->receive_context,
		    active_state->p_read.seqnr, cp,
		    buffer_ptr(&active_state->input), block_size, 0, 0) != 0)
			fatal("Decryption integrity check failed");
		cp = buffer_ptr(&active_state->incoming_packet);
		active_state->packlen = get_u32(cp);
		if (active_state->packlen < 1 + 4 ||
		    active_state->packlen > PACKET_MAX_SIZE) {
d1542 4
a1545 1
			buffer_dump(&active_state->incoming_packet);
d1547 3
a1549 4
			logit("Bad packet length %u.", active_state->packlen);
			packet_start_discard(enc, mac, active_state->packlen,
			    PACKET_MAX_SIZE);
			return SSH_MSG_NONE;
d1551 2
a1552 1
		buffer_consume(&active_state->input, block_size);
d1554 2
a1555 1
	DBG(debug("input: packet len %u", active_state->packlen+4));
d1558 1
a1558 1
		need = active_state->packlen;
d1564 1
a1564 1
		need = 4 + active_state->packlen - block_size;
d1571 2
a1572 3
		packet_start_discard(enc, mac, active_state->packlen,
		    PACKET_MAX_SIZE - block_size);
		return SSH_MSG_NONE;
d1582 2
a1583 2
	if (buffer_len(&active_state->input) < aadlen + need + authlen + maclen)
		return SSH_MSG_NONE;
d1586 1
a1586 1
	buffer_dump(&active_state->input);
d1589 3
a1591 3
	if (mac && mac->enabled && mac->etm)
		if ((r = mac_compute(mac, active_state->p_read.seqnr,
		    buffer_ptr(&active_state->input), aadlen + need,
d1593 10
a1602 7
			fatal("%s: mac_compute: %s", __func__, ssh_err(r));
	cp = buffer_append_space(&active_state->incoming_packet, aadlen + need);
	if (cipher_crypt(&active_state->receive_context,
	    active_state->p_read.seqnr, cp,
	    buffer_ptr(&active_state->input), need, aadlen, authlen) != 0)
		fatal("Decryption integrity check failed");
	buffer_consume(&active_state->input, aadlen + need + authlen);
d1609 3
a1611 3
			if ((r = mac_compute(mac, active_state->p_read.seqnr,
			    buffer_ptr(&active_state->incoming_packet),
			    buffer_len(&active_state->incoming_packet),
d1613 2
a1614 2
				fatal("%s: mac_compute: %s", __func__, ssh_err(r));
		if (timingsafe_bcmp(macbuf, buffer_ptr(&active_state->input),
d1618 8
a1625 8
				fatal("internal error need %d", need);
			packet_start_discard(enc, mac, active_state->packlen,
			    PACKET_MAX_SIZE - need);
			return SSH_MSG_NONE;
		}
				
		DBG(debug("MAC #%d ok", active_state->p_read.seqnr));
		buffer_consume(&active_state->input, mac->mac_len);
d1629 2
a1630 2
		*seqnr_p = active_state->p_read.seqnr;
	if (++active_state->p_read.seqnr == 0)
d1632 5
a1636 5
	if (++active_state->p_read.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	active_state->p_read.blocks += (active_state->packlen + 4) / block_size;
	active_state->p_read.bytes += active_state->packlen + 4;
d1639 1
a1639 2
	cp = buffer_ptr(&active_state->incoming_packet);
	padlen = cp[4];
d1642 2
a1643 1
		packet_disconnect("Corrupted padlen %d on input.", padlen);
d1646 3
a1648 2
	buffer_consume(&active_state->incoming_packet, 4 + 1);
	buffer_consume_end(&active_state->incoming_packet, padlen);
d1650 2
a1651 2
	DBG(debug("input: len before de-compress %d",
	    buffer_len(&active_state->incoming_packet)));
d1653 10
a1662 9
		buffer_clear(&active_state->compression_buffer);
		buffer_uncompress(&active_state->incoming_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->incoming_packet);
		buffer_append(&active_state->incoming_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
		DBG(debug("input: len after de-compress %d",
		    buffer_len(&active_state->incoming_packet)));
d1668 11
a1678 8
	type = buffer_get_char(&active_state->incoming_packet);
	if (type < SSH2_MSG_MIN || type >= SSH2_MSG_LOCAL_MIN)
		packet_disconnect("Invalid ssh2 packet type: %d", type);
	if (type == SSH2_MSG_NEWKEYS)
		set_newkeys(MODE_IN);
	else if (type == SSH2_MSG_USERAUTH_SUCCESS &&
	    !active_state->server_side)
		packet_enable_delayed_compress();
d1680 2
a1681 2
	fprintf(stderr, "read/plain[%d]:\r\n", type);
	buffer_dump(&active_state->incoming_packet);
d1684 3
a1686 2
	active_state->packlen = 0;
	return type;
d1690 1
a1690 1
packet_read_poll_seqnr(u_int32_t *seqnr_p)
d1692 1
d1694 2
a1695 2
	u_char type;
	char *msg;
d1698 1
d1700 6
a1705 4
			type = packet_read_poll2(seqnr_p);
			if (type) {
				active_state->keep_alive_timeouts = 0;
				DBG(debug("received packet type %d", type));
d1707 1
a1707 1
			switch (type) {
d1712 7
a1718 2
				packet_get_char();
				msg = packet_get_string(NULL);
a1720 2
				msg = packet_get_string(NULL);
				free(msg);
d1723 3
a1725 2
				reason = packet_get_int();
				msg = packet_get_string(NULL);
d1727 1
a1727 1
				do_log2(active_state->server_side &&
d1731 1
a1731 1
				    get_remote_ipaddr(), reason, msg);
d1733 1
a1733 2
				cleanup_exit(255);
				break;
d1735 2
a1736 1
				seqnr = packet_get_int();
d1741 1
a1741 1
				return type;
d1744 2
a1745 2
			type = packet_read_poll1();
			switch (type) {
d1751 2
a1752 1
				msg = packet_get_string(NULL);
d1757 2
a1758 1
				msg = packet_get_string(NULL);
d1760 3
a1762 3
				    get_remote_ipaddr(), msg);
				cleanup_exit(255);
				break;
d1764 2
a1765 2
				DBG(debug("received packet type %d", type));
				return type;
d1777 1
a1777 1
packet_process_incoming(const char *buf, u_int len)
d1779 11
a1789 5
	if (active_state->packet_discard) {
		active_state->keep_alive_timeouts = 0; /* ?? */
		if (len >= active_state->packet_discard)
			packet_stop_discard();
		active_state->packet_discard -= len;
d1792 2
a1793 63
	buffer_append(&active_state->input, buf, len);
}

/* Returns a character from the packet. */

u_int
packet_get_char(void)
{
	char ch;

	buffer_get(&active_state->incoming_packet, &ch, 1);
	return (u_char) ch;
}

/* Returns an integer from the packet data. */

u_int
packet_get_int(void)
{
	return buffer_get_int(&active_state->incoming_packet);
}

/* Returns an 64 bit integer from the packet data. */

u_int64_t
packet_get_int64(void)
{
	return buffer_get_int64(&active_state->incoming_packet);
}

/*
 * Returns an arbitrary precision integer from the packet data.  The integer
 * must have been initialized before this call.
 */

#ifdef WITH_OPENSSL
void
packet_get_bignum(BIGNUM * value)
{
	buffer_get_bignum(&active_state->incoming_packet, value);
}

void
packet_get_bignum2(BIGNUM * value)
{
	buffer_get_bignum2(&active_state->incoming_packet, value);
}

void
packet_get_ecpoint(const EC_GROUP *curve, EC_POINT *point)
{
	buffer_get_ecpoint(&active_state->incoming_packet, curve, point);
}
#endif

void *
packet_get_raw(u_int *length_ptr)
{
	u_int bytes = buffer_len(&active_state->incoming_packet);

	if (length_ptr != NULL)
		*length_ptr = bytes;
	return buffer_ptr(&active_state->incoming_packet);
d1797 1
a1797 1
packet_remaining(void)
d1799 1
a1799 27
	return buffer_len(&active_state->incoming_packet);
}

/*
 * Returns a string from the packet data.  The string is allocated using
 * xmalloc; it is the responsibility of the calling program to free it when
 * no longer needed.  The length_ptr argument may be NULL, or point to an
 * integer into which the length of the string is stored.
 */

void *
packet_get_string(u_int *length_ptr)
{
	return buffer_get_string(&active_state->incoming_packet, length_ptr);
}

const void *
packet_get_string_ptr(u_int *length_ptr)
{
	return buffer_get_string_ptr(&active_state->incoming_packet, length_ptr);
}

/* Ensures the returned string has no embedded \0 characters in it. */
char *
packet_get_cstring(u_int *length_ptr)
{
	return buffer_get_cstring(&active_state->incoming_packet, length_ptr);
d1812 1
a1812 1
packet_send_debug(const char *fmt,...)
d1816 1
d1818 1
a1818 1
	if (compat20 && (datafellows & SSH_BUG_DEBUG))
d1826 6
a1831 4
		packet_start(SSH2_MSG_DEBUG);
		packet_put_char(0);	/* bool: always display */
		packet_put_cstring(buf);
		packet_put_cstring("");
d1833 4
a1836 2
		packet_start(SSH_MSG_DEBUG);
		packet_put_cstring(buf);
d1838 1
a1838 2
	packet_send();
	packet_write_wait();
d1849 1
a1849 1
packet_disconnect(const char *fmt,...)
d1854 1
d1873 6
a1878 4
		packet_start(SSH2_MSG_DISCONNECT);
		packet_put_int(SSH2_DISCONNECT_PROTOCOL_ERROR);
		packet_put_cstring(buf);
		packet_put_cstring("");
d1880 4
a1883 2
		packet_start(SSH_MSG_DISCONNECT);
		packet_put_cstring(buf);
d1885 1
a1885 5
	packet_send();
	packet_write_wait();

	/* Stop listening for connections. */
	channel_close_all();
d1888 1
a1888 1
	packet_close();
d1895 1
a1895 1
packet_write_poll(void)
d1897 3
a1899 2
	int len = buffer_len(&active_state->output);
	int cont;
d1903 2
a1904 2
		len = roaming_write(active_state->connection_out,
		    buffer_ptr(&active_state->output), len, &cont);
d1912 2
a1913 1
		buffer_consume(&active_state->output, len);
d1923 1
a1923 1
packet_write_wait(void)
d1928 1
d1930 1
a1930 1
	setp = (fd_set *)xcalloc(howmany(active_state->connection_out + 1,
d1932 5
a1936 3
	packet_write_poll();
	while (packet_have_data_to_write()) {
		memset(setp, 0, howmany(active_state->connection_out + 1,
d1938 1
a1938 1
		FD_SET(active_state->connection_out, setp);
d1940 2
a1941 2
		if (active_state->packet_timeout_ms > 0) {
			ms_remain = active_state->packet_timeout_ms;
d1945 1
a1945 1
			if (active_state->packet_timeout_ms != -1) {
d1949 1
a1949 1
			if ((ret = select(active_state->connection_out + 1,
d1954 1
a1954 1
			if (active_state->packet_timeout_ms == -1)
d1964 1
a1964 1
			    "waiting to write", get_remote_ipaddr());
d1967 1
a1967 1
		packet_write_poll();
d1975 1
a1975 1
packet_have_data_to_write(void)
d1977 1
a1977 1
	return buffer_len(&active_state->output) != 0;
d1983 1
a1983 1
packet_not_very_much_data_to_write(void)
d1985 2
a1986 2
	if (active_state->interactive_mode)
		return buffer_len(&active_state->output) < 16384;
d1988 1
a1988 1
		return buffer_len(&active_state->output) < 128 * 1024;
d1991 2
a1992 2
static void
packet_set_tos(int tos)
d1994 1
a1994 1
	if (!packet_connection_is_on_socket())
d1996 1
a1996 1
	switch (packet_connection_af()) {
d1999 1
a1999 1
		if (setsockopt(active_state->connection_in,
d2006 1
a2006 1
		if (setsockopt(active_state->connection_in,
d2017 1
a2017 1
packet_set_interactive(int interactive, int qos_interactive, int qos_bulk)
d2019 3
a2021 1
	if (active_state->set_interactive_called)
d2023 1
a2023 1
	active_state->set_interactive_called = 1;
d2026 1
a2026 1
	active_state->interactive_mode = interactive;
d2029 1
a2029 1
	if (!packet_connection_is_on_socket())
d2031 3
a2033 2
	set_nodelay(active_state->connection_in);
	packet_set_tos(interactive ? qos_interactive : qos_bulk);
d2039 1
a2039 1
packet_is_interactive(void)
d2041 1
a2041 1
	return active_state->interactive_mode;
d2045 1
a2045 1
packet_set_maxsize(u_int s)
d2047 3
a2049 1
	if (active_state->set_maxsize_called) {
d2051 1
a2051 1
		    active_state->max_packet_size, s);
d2058 1
a2058 1
	active_state->set_maxsize_called = 1;
d2060 1
a2060 1
	active_state->max_packet_size = s;
d2065 1
a2065 1
packet_inc_alive_timeouts(void)
d2067 1
a2067 1
	return ++active_state->keep_alive_timeouts;
d2071 1
a2071 1
packet_set_alive_timeouts(int ka)
d2073 1
a2073 1
	active_state->keep_alive_timeouts = ka;
d2077 1
a2077 8
packet_get_maxsize(void)
{
	return active_state->max_packet_size;
}

/* roundup current message to pad bytes */
void
packet_add_padding(u_char pad)
d2079 1
a2079 1
	active_state->extra_pad = pad;
d2094 1
a2094 1
packet_send_ignore(int nbytes)
d2097 1
a2097 1
	int i;
d2099 4
a2102 2
	packet_start(compat20 ? SSH2_MSG_IGNORE : SSH_MSG_IGNORE);
	packet_put_int(nbytes);
d2106 2
a2107 1
		packet_put_char((u_char)rnd & 0xff);
d2114 1
a2114 1
packet_need_rekeying(void)
d2116 3
a2118 1
	if (datafellows & SSH_BUG_NOREKEY)
d2121 8
a2128 8
	    (active_state->p_send.packets > MAX_PACKETS) ||
	    (active_state->p_read.packets > MAX_PACKETS) ||
	    (active_state->max_blocks_out &&
	        (active_state->p_send.blocks > active_state->max_blocks_out)) ||
	    (active_state->max_blocks_in &&
	        (active_state->p_read.blocks > active_state->max_blocks_in)) ||
	    (active_state->rekey_interval != 0 && active_state->rekey_time +
		 active_state->rekey_interval <= monotime());
d2132 1
a2132 1
packet_set_rekey_limits(u_int32_t bytes, time_t seconds)
d2136 2
a2137 2
	active_state->rekey_limit = bytes;
	active_state->rekey_interval = seconds;
d2142 1
a2142 1
	active_state->rekey_time = monotime();
d2146 1
a2146 1
packet_get_rekey_timeout(void)
d2150 1
a2150 1
	seconds = active_state->rekey_time + active_state->rekey_interval -
d2156 1
a2156 1
packet_set_server(void)
d2158 1
a2158 1
	active_state->server_side = 1;
d2162 1
a2162 1
packet_set_authenticated(void)
d2164 1
a2164 1
	active_state->after_authentication = 1;
d2168 1
a2168 1
packet_get_input(void)
d2170 1
a2170 1
	return (void *)&active_state->input;
d2174 1
a2174 1
packet_get_output(void)
d2176 1
a2176 7
	return (void *)&active_state->output;
}

void *
packet_get_newkeys(int mode)
{
	return (void *)active_state->newkeys[mode];
d2179 1
d2185 2
a2186 1
packet_backup_state(void)
d2188 1
a2188 1
	struct session_state *tmp;
d2190 4
a2193 4
	close(active_state->connection_in);
	active_state->connection_in = -1;
	close(active_state->connection_out);
	active_state->connection_out = -1;
d2197 3
a2199 3
		tmp = alloc_session_state();
	backup_state = active_state;
	active_state = tmp;
d2202 1
d2207 2
a2208 1
packet_restore_state(void)
d2210 1
a2210 2
	struct session_state *tmp;
	void *buf;
d2212 1
d2215 7
a2221 7
	backup_state = active_state;
	active_state = tmp;
	active_state->connection_in = backup_state->connection_in;
	backup_state->connection_in = -1;
	active_state->connection_out = backup_state->connection_out;
	backup_state->connection_out = -1;
	len = buffer_len(&backup_state->input);
d2223 4
a2226 3
		buf = buffer_ptr(&backup_state->input);
		buffer_append(&active_state->input, buf, len);
		buffer_clear(&backup_state->input);
d2232 2
a2233 2
void
packet_set_postauth(void)
d2235 2
a2236 2
	Comp *comp;
	int mode;
d2240 2
a2241 2
	active_state->after_authentication = 1;
	active_state->rekeying = 0;
d2243 1
a2243 1
		if (active_state->newkeys[mode] == NULL)
d2245 537
a2781 3
		comp = &active_state->newkeys[mode]->comp;
		if (comp && comp->enabled)
			packet_init_compression();
d2783 9
@


1.199
log
@Remove unnecessary include: netinet/in_systm.h is not needed by these
programs.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.198 2014/07/15 15:54:14 millert Exp $ */
d70 1
d274 1
a274 1
		    PACKET_MAX_SIZE);
d855 1
a855 1
	u_char type, *cp, *macbuf = NULL;
d863 1
d946 4
a949 2
		macbuf = mac_compute(mac, active_state->p_send.seqnr,
		    buffer_ptr(&active_state->outgoing_packet), len);
d962 4
a965 2
			macbuf = mac_compute(mac,
			    active_state->p_send.seqnr, cp, len);
d1268 1
a1268 1
	u_char *macbuf = NULL, *cp, type;
d1270 1
d1370 4
a1373 2
		macbuf = mac_compute(mac, active_state->p_read.seqnr,
		    buffer_ptr(&active_state->input), aadlen + need);
d1386 1
a1386 1
			macbuf = mac_compute(mac, active_state->p_read.seqnr,
d1388 3
a1390 1
			    buffer_len(&active_state->incoming_packet));
@


1.198
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.197 2014/06/24 01:13:21 djm Exp $ */
a45 1
#include <netinet/in_systm.h>
@


1.197
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.196 2014/05/03 17:20:34 markus Exp $ */
a64 1
#include "channels.h"
d75 1
@


1.196
log
@unbreak compression, by re-init-ing the compression code in the
post-auth child. the new buffer code is more strict, and requires
buffer_init() while the old code was happy after a bzero();
originally from djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.195 2014/04/29 18:01:49 markus Exp $ */
d77 1
d222 1
d230 5
a234 4
	cipher_init(&active_state->send_context, none, (const u_char *)"",
	    0, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&active_state->receive_context, none, (const u_char *)"",
	    0, NULL, 0, CIPHER_DECRYPT);
d331 1
d338 2
a339 1
	cipher_get_keyiv(cc, iv, len);
d385 1
d392 2
a393 1
	cipher_set_keyiv(cc, dat);
d553 1
d563 5
a567 4
	cipher_init(&active_state->send_context, cipher, key, keylen, NULL,
	    0, CIPHER_ENCRYPT);
	cipher_init(&active_state->receive_context, cipher, key, keylen, NULL,
	    0, CIPHER_DECRYPT);
d745 1
a745 1
	int crypt_type;
d787 3
a789 2
	cipher_init(cc, enc->cipher, enc->key, enc->key_len,
	    enc->iv, enc->iv_len, crypt_type);
@


1.195
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.194 2014/04/28 03:09:18 djm Exp $ */
d2038 20
@


1.194
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.193 2014/04/01 05:32:57 djm Exp $ */
d624 1
d642 1
d1562 1
d1580 1
@


1.193
log
@demote a debug3 to PACKET_DEBUG; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.192 2014/02/02 03:44:31 djm Exp $ */
d1607 1
a1607 1
void *
@


1.192
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.191 2013/12/06 13:34:54 markus Exp $ */
d904 2
a905 2
		debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)",
		    pad, len, padlen, active_state->extra_pad);
@


1.191
log
@new private key format, bcrypt as KDF by default; details in PROTOCOL.key;
feedback and lots help from djm; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.190 2013/11/21 00:45:44 djm Exp $ */
d756 3
a758 3
		memset(enc->iv,  0, enc->iv_len);
		memset(enc->key, 0, enc->key_len);
		memset(mac->key, 0, mac->key_len);
d779 3
a781 3
	/* memset(enc->iv,  0, enc->block_size);
	   memset(enc->key, 0, enc->key_len);
	   memset(mac->key, 0, mac->key_len); */
d920 1
a920 1
		memset(cp, 0, padlen);
@


1.190
log
@Add a new protocol 2 transport cipher "chacha20-poly1305@@openssh.com"
that combines Daniel Bernstein's ChaCha20 stream cipher and Poly1305 MAC
to build an authenticated encryption mode.

Inspired by and similar to Adam Langley's proposal for TLS:
http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03
but differs in layout used for the MAC calculation and the use of a
second ChaCha20 instance to separately encrypt packet lengths.
Details are in the PROTOCOL.chacha20poly1305 file.

Feedback markus@@, naddy@@; manpage bits Loganden Velvindron @@ AfriNIC
ok markus@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.189 2013/11/08 00:39:15 djm Exp $ */
d705 1
a705 1
	cipher_crypt(&active_state->send_context, 0, cp,
d707 2
a708 1
	    buffer_len(&active_state->outgoing_packet), 0, 0);
d939 1
a939 1
	cipher_crypt(&active_state->send_context, active_state->p_send.seqnr,
d941 2
a942 1
	    len - aadlen, aadlen, authlen);
d1201 3
a1203 2
	cipher_crypt(&active_state->receive_context, 0, cp,
	    buffer_ptr(&active_state->input), padded_len, 0, 0);
d1298 1
a1298 1
		cipher_crypt(&active_state->receive_context,
d1300 2
a1301 1
		    buffer_ptr(&active_state->input), block_size, 0, 0);
d1355 1
a1355 1
	cipher_crypt(&active_state->receive_context,
d1357 2
a1358 1
	    buffer_ptr(&active_state->input), need, aadlen, authlen);
@


1.189
log
@use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.188 2013/07/12 00:19:58 djm Exp $ */
d705 1
a705 1
	cipher_crypt(&active_state->send_context, cp,
d938 2
a939 2
	cipher_crypt(&active_state->send_context, cp,
	    buffer_ptr(&active_state->outgoing_packet),
d1199 1
a1199 1
	cipher_crypt(&active_state->receive_context, cp,
d1270 5
a1274 1
		if (buffer_len(&active_state->input) < 4)
a1275 2
		cp = buffer_ptr(&active_state->input);
		active_state->packlen = get_u32(cp);
d1295 2
a1296 1
		cipher_crypt(&active_state->receive_context, cp,
d1351 2
a1352 1
	cipher_crypt(&active_state->receive_context, cp,
@


1.188
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.187 2013/06/01 13:15:52 dtucker Exp $ */
d988 1
a988 1
			p = xmalloc(sizeof(*p));
@


1.188.2.1
log
@cherrypick commit:

date: 2013/11/08 00:39:15;  author: djm;  state: Exp;  lines: +2 -2;
use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.188 2013/07/12 00:19:58 djm Exp $ */
d988 1
a988 1
			p = xcalloc(1, sizeof(*p));
@


1.187
log
@Use clock_gettime(CLOCK_MONOTONIC ...) for ssh timers so that things like
keepalives and rekeying will work properly over clock steps.  Suggested by
markus@@, "looks good" djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.186 2013/05/17 00:13:13 djm Exp $ */
d1040 1
a1040 1
	int type, len, ret, ms_remain, cont;
d1478 2
d1494 1
a1494 2
				if (type)
					DBG(debug("received packet type %d", type));
d1728 1
a1728 1
	int ret, ms_remain;
@


1.186
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.185 2013/05/16 04:09:13 dtucker Exp $ */
d1007 1
a1007 1
		active_state->rekey_time = time(NULL);
d1923 1
a1923 1
		 active_state->rekey_interval <= time(NULL));
d1937 1
a1937 1
	active_state->rekey_time = time(NULL);
d1946 1
a1946 1
	    time(NULL);
@


1.185
log
@Add RekeyLimit to sshd with the same syntax as the client allowing rekeying
based on traffic volume or time.  ok djm@@, help & ok jmc@@ for the man page.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.184 2013/05/16 02:00:34 dtucker Exp $ */
d758 7
a764 7
		xfree(enc->name);
		xfree(enc->iv);
		xfree(enc->key);
		xfree(mac->name);
		xfree(mac->key);
		xfree(comp->name);
		xfree(active_state->newkeys[mode]);
d1015 1
a1015 1
			xfree(p);
d1065 1
a1065 1
			xfree(setp);
d1451 1
a1451 1
				xfree(msg);
d1453 1
a1453 1
				xfree(msg);
d1464 1
a1464 1
				xfree(msg);
d1483 1
a1483 1
				xfree(msg);
d1767 1
a1767 1
	xfree(setp);
@


1.184
log
@Add an optional second argument to RekeyLimit in the client to allow
rekeying based on elapsed time in addition to amount of traffic.
with djm@@ jmc@@, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.183 2013/04/19 01:06:50 djm Exp $ */
d1947 1
a1947 1
	return (seconds < 0 ? 0 : seconds);
@


1.183
log
@add the ability to query supported ciphers, MACs, key type and KEX
algorithms to ssh. Includes some refactoring of KEX and key type handling
to be table-driven; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.182 2013/04/11 02:27:50 djm Exp $ */
d57 1
d165 1
d169 4
d1007 1
d1921 3
a1923 1
	        (active_state->p_read.blocks > active_state->max_blocks_in));
d1927 1
a1927 1
packet_set_rekey_limit(u_int32_t bytes)
d1929 2
d1932 16
@


1.182
log
@quiet disconnect notifications on the server from error() back to logit()
if it is a normal client closure; bz#2057 ok+feedback dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.181 2013/02/10 23:35:24 djm Exp $ */
d214 1
a214 1
	Cipher *none = cipher_by_name("none");
d539 1
a539 1
	Cipher *cipher = cipher_by_number(number);
@


1.181
log
@record "Received disconnect" messages at ERROR rather than INFO priority,
since they are abnormal and result in a non-zero ssh exit status; patch
from Iain Morgan in bz#2057; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.180 2013/01/08 18:49:04 markus Exp $ */
d1451 5
a1455 1
				error("Received disconnect from %s: %u: %.400s",
@


1.181.2.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.188.2.1 2013/11/08 01:33:56 djm Exp $ */
d982 1
a982 1
			p = xcalloc(1, sizeof(*p));
@


1.180
log
@support AES-GCM as defined in RFC 5647 (but with simpler KEX handling)
ok and feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.179 2012/12/12 16:45:52 markus Exp $ */
d1451 1
a1451 1
				logit("Received disconnect from %s: %u: %.400s",
d1476 1
a1476 1
				logit("Received disconnect from %s: %.400s",
@


1.179
log
@reset incoming_packet buffer for each new packet in EtM-case, too;
this happens if packets are parsed only parially (e.g. ignore
messages sent when su/sudo turn off echo); noted by sthen/millert
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.178 2012/12/11 22:31:18 markus Exp $ */
d701 1
a701 1
	    buffer_len(&active_state->outgoing_packet), 0);
d749 1
a749 1
		memset(enc->iv,  0, enc->block_size);
d766 1
a766 1
	if (mac_init(mac) == 0)
d770 1
a770 1
	    enc->iv, enc->block_size, crypt_type);
d838 1
a838 1
	u_int i, len, aadlen = 0;
d849 3
d854 1
a854 1
	aadlen = mac && mac->enabled && mac->etm ? 4 : 0;
d931 1
a931 1
	cp = buffer_append_space(&active_state->output, len);
d934 1
a934 1
	    len - aadlen, aadlen);
d1193 1
a1193 1
	    buffer_ptr(&active_state->input), padded_len, 0);
d1242 1
a1242 1
	u_int maclen, aadlen = 0, block_size;
d1254 3
d1260 1
a1260 1
	aadlen = mac && mac->enabled && mac->etm ? 4 : 0;
d1287 1
a1287 1
		    buffer_ptr(&active_state->input), block_size, 0);
d1313 2
a1314 2
	DBG(debug("partial packet: block %d, need %d, maclen %d, aadlen %d",
	    block_size, need, maclen, aadlen));
d1326 2
a1327 1
	 * 'need' bytes are encrypted, followed by
d1330 1
a1330 1
	if (buffer_len(&active_state->input) < aadlen + need + maclen)
d1342 2
a1343 2
	    buffer_ptr(&active_state->input), need, aadlen);
	buffer_consume(&active_state->input, aadlen + need);
@


1.178
log
@add encrypt-then-mac (EtM) modes to openssh by defining new mac algorithms
that change the packet format and compute the MAC over the encrypted
message (including the packet size) instead of the plaintext data;
these EtM modes are considered more secure and used by default.
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.177 2012/09/17 13:04:11 markus Exp $ */
d1269 1
@


1.177
log
@clear old keys on rekeing; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.176 2012/01/25 19:40:09 markus Exp $ */
d274 1
a274 1
	if (enc == NULL || !cipher_is_cbc(enc->cipher))
d701 1
a701 1
	    buffer_len(&active_state->outgoing_packet));
d837 2
a838 3
	u_char padlen, pad;
	u_int packet_length = 0;
	u_int i, len;
d851 1
d884 1
d912 3
d916 1
a916 3
	packet_length = buffer_len(&active_state->outgoing_packet) - 4;
	cp = buffer_ptr(&active_state->outgoing_packet);
	put_u32(cp, packet_length);
d918 2
a919 1
	DBG(debug("send: len %d (includes padlen %d)", packet_length+4, padlen));
d922 1
a922 1
	if (mac && mac->enabled) {
d924 1
a924 2
		    buffer_ptr(&active_state->outgoing_packet),
		    buffer_len(&active_state->outgoing_packet));
d928 1
a928 2
	cp = buffer_append_space(&active_state->output,
	    buffer_len(&active_state->outgoing_packet));
d931 1
a931 1
	    buffer_len(&active_state->outgoing_packet));
d933 8
a940 1
	if (mac && mac->enabled)
d942 1
d953 2
a954 2
	active_state->p_send.blocks += (packet_length + 4) / block_size;
	active_state->p_send.bytes += packet_length + 4;
d1190 1
a1190 1
	    buffer_ptr(&active_state->input), padded_len);
d1238 2
a1239 2
	u_char *macbuf, *cp, type;
	u_int maclen, block_size;
d1254 1
d1256 14
a1269 1
	if (active_state->packlen == 0) {
d1280 1
a1280 1
		    buffer_ptr(&active_state->input), block_size);
a1292 1
		DBG(debug("input: packet len %u", active_state->packlen+4));
d1295 13
a1307 4
	/* we have a partial packet of block_size bytes */
	need = 4 + active_state->packlen - block_size;
	DBG(debug("partial packet %d, need %d, maclen %d", block_size,
	    need, maclen));
d1317 4
a1320 1
	 * decrypt into incoming_packet
d1322 1
a1322 1
	if (buffer_len(&active_state->input) < need + maclen)
d1328 5
a1332 1
	cp = buffer_append_space(&active_state->incoming_packet, need);
d1334 2
a1335 2
	    buffer_ptr(&active_state->input), need);
	buffer_consume(&active_state->input, need);
d1341 4
a1344 3
		macbuf = mac_compute(mac, active_state->p_read.seqnr,
		    buffer_ptr(&active_state->incoming_packet),
		    buffer_len(&active_state->incoming_packet));
@


1.176
log
@packet_read_poll() is not used anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.175 2012/01/25 19:26:43 markus Exp $ */
d749 3
@


1.175
log
@do not permit SSH2_MSG_SERVICE_REQUEST/ACCEPT during rekeying;
ok dtucker@@, djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.174 2011/12/07 05:44:38 djm Exp $ */
a1436 6
}

int
packet_read_poll(void)
{
	return packet_read_poll_seqnr(NULL);
@


1.174
log
@fix some harmless and/or unreachable int overflows;
reported Xi Wang, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.173 2011/05/06 21:14:05 djm Exp $ */
d962 4
a965 2
		if (!((type >= SSH2_MSG_TRANSPORT_MIN) &&
		    (type <= SSH2_MSG_TRANSPORT_MAX))) {
@


1.173
log
@set traffic class for IPv6 traffic as we do for IPv4 TOS;
patch from lionel AT mamane.lu via Colin Watson in bz#1855;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.172 2010/11/13 23:27:50 djm Exp $ */
d241 1
a241 1
	if (timeout == 0 || count == 0) {
@


1.172
log
@allow ssh and sshd to set arbitrary TOS/DSCP/QoS values instead of
hardcoding lowdelay/throughput.

bz#1733 patch from philipp AT redfish-solutions.com; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.171 2010/11/05 02:46:47 djm Exp $ */
d421 2
a422 4
/* returns 1 if connection is via ipv4 */

int
packet_connection_is_ipv4(void)
d431 1
a431 3
	if (to.ss_family != AF_INET)
		return 0;
	return 1;
d1735 1
a1735 2
	if (!packet_connection_is_on_socket() ||
	    !packet_connection_is_ipv4())
d1737 16
a1752 5
	debug3("%s: set IP_TOS 0x%02x", __func__, tos);
	if (setsockopt(active_state->connection_in, IPPROTO_IP, IP_TOS, &tos,
	    sizeof(tos)) < 0)
		error("setsockopt IP_TOS %d: %.100s:",
		    tos, strerror(errno));
@


1.171
log
@whitespace KNF
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.170 2010/08/31 11:54:45 djm Exp $ */
d1737 1
a1737 1
packet_set_tos(int interactive)
a1738 2
	int tos = interactive ? IPTOS_LOWDELAY : IPTOS_THROUGHPUT;

d1742 1
d1752 1
a1752 1
packet_set_interactive(int interactive)
d1765 1
a1765 1
	packet_set_tos(interactive);
@


1.170
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.169 2010/08/31 09:58:37 djm Exp $ */
d198 1
a198 1
    struct session_state *s = xcalloc(1, sizeof(*s));
d200 5
a204 5
    s->connection_in = -1;
    s->connection_out = -1;
    s->max_packet_size = 32768;
    s->packet_timeout_ms = -1;
    return s;
d390 2
a391 2
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks, u_int32_t *packets,
    u_int64_t *bytes)
d541 1
a541 2
packet_set_encryption_key(const u_char *key, u_int keylen,
    int number)
@


1.169
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.168 2010/07/13 23:13:16 djm Exp $ */
d635 6
d1508 6
@


1.168
log
@s/timing_safe_cmp/timingsafe_bcmp/g
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.167 2010/07/13 11:52:06 djm Exp $ */
d1537 7
@


1.167
log
@implement a timing_safe_cmp() function to compare memory without leaking
timing information by short-circuiting like memcmp() and use it for
some of the more sensitive comparisons (though nothing high-value was
readily attackable anyway); "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.166 2009/06/27 09:29:06 andreas Exp $ */
d1300 1
a1300 1
		if (timing_safe_cmp(macbuf, buffer_ptr(&active_state->input),
@


1.166
log
@packet_bacup_state() and packet_restore_state() will be used to
temporarily save the current state ren resuming a suspended connection.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.165 2009/06/12 20:58:32 andreas Exp $ */
d1300 1
a1300 1
		if (memcmp(macbuf, buffer_ptr(&active_state->input),
@


1.165
log
@Move some more statics into session_state
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.164 2009/06/12 20:43:22 andreas Exp $ */
d193 1
a193 1
static struct session_state *active_state;
d1878 47
@


1.164
log
@Fix warnings found by chl@@ and djm@@ and change roaming_atomicio's
return type to match atomicio's
Diff from djm@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.163 2009/05/28 16:50:16 andreas Exp $ */
d181 9
a952 1
	static int rekeying = 0;
d960 1
a960 1
	if (rekeying) {
d976 1
a976 1
		rekeying = 1;
d982 1
a982 1
		rekeying = 0;
d1737 1
a1737 3
	static int called = 0;

	if (called)
d1739 1
a1739 1
	called = 1;
d1762 1
a1762 3
	static int called = 0;

	if (called) {
d1771 1
a1771 1
	called = 1;
@


1.163
log
@Keep track of number of bytes read and written. Needed for upcoming
changes. Most code from Martin Forssen, maf at appgate dot com.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.162 2009/05/27 06:36:07 andreas Exp $ */
d187 1
a187 1
alloc_session_state()
@


1.162
log
@Add packet_put_int64() and packet_get_int64(), part of a larger change
from Martin Forssen.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.161 2009/05/25 06:48:01 andreas Exp $ */
d76 1
d1007 1
a1007 1
	int type, len, ret, ms_remain;
d1072 5
a1076 1
		len = read(active_state->connection_in, buf, sizeof(buf));
d1622 1
d1625 3
a1627 2
		len = write(active_state->connection_out,
		    buffer_ptr(&active_state->output), len);
d1633 1
a1633 1
		if (len == 0)
@


1.161
log
@Put the globals in packet.c into a struct and don't access it directly
from other files. No functional changes.
ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.160 2009/02/13 11:50:21 markus Exp $ */
d590 6
d1464 8
@


1.160
log
@check for enc !=NULL in packet_start_discard
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.159 2009/01/26 09:58:15 markus Exp $ */
d85 25
a109 8
/*
 * This variable contains the file descriptors used for communicating with
 * the other side.  connection_in is used for reading; connection_out for
 * writing.  These can be the same descriptor, in which case it is assumed to
 * be a socket.
 */
static int connection_in = -1;
static int connection_out = -1;
d111 2
a112 2
/* Protocol flags for the remote side. */
static u_int remote_protocol_flags = 0;
d114 2
a115 2
/* Encryption context for receiving data.  This is only used for decryption. */
static CipherContext receive_context;
d117 2
a118 2
/* Encryption context for sending data.  This is only used for encryption. */
static CipherContext send_context;
d120 2
a121 2
/* Buffer for raw input data from the socket. */
Buffer input;
d123 2
a124 2
/* Buffer for raw output data going to the socket. */
Buffer output;
d126 2
a127 2
/* Buffer for the partial outgoing packet being constructed. */
static Buffer outgoing_packet;
d129 3
a131 2
/* Buffer for the incoming packet currently being processed. */
static Buffer incoming_packet;
d133 5
a137 3
/* Scratch buffer for packet compression/decompression. */
static Buffer compression_buffer;
static int compression_buffer_ready = 0;
d139 2
a140 2
/* Flag indicating whether packet compression/decompression is enabled. */
static int packet_compression = 0;
d142 2
a143 2
/* default maximum packet size */
u_int max_packet_size = 32768;
d145 2
a146 2
/* Flag indicating whether this module has been initialized. */
static int initialized = 0;
d148 2
a149 2
/* Set to true if the connection is interactive. */
static int interactive_mode = 0;
d151 2
a152 2
/* Set to true if we are the server side. */
static int server_side = 0;
d154 1
a154 2
/* Set to true if we are authenticated. */
static int after_authentication = 0;
d156 2
a157 1
int keep_alive_timeouts = 0;
d159 3
a161 2
/* Set to the maximum time that we will wait to send or receive a packet */
static int packet_timeout_ms = -1;
d163 2
a164 8
/* Session key information for Encryption and MAC */
Newkeys *newkeys[MODE_MAX];
static struct packet_state {
	u_int32_t seqnr;
	u_int32_t packets;
	u_int64_t blocks;
	u_int64_t bytes;
} p_read, p_send;
d166 3
a168 2
static u_int64_t max_blocks_in, max_blocks_out;
static u_int32_t rekey_limit;
d170 2
a171 3
/* Session key for protocol v1 */
static u_char ssh1_key[SSH_SESSION_KEY_LENGTH];
static u_int ssh1_keylen;
d173 3
a175 2
/* roundup current message to extra_pad bytes */
static u_char extra_pad = 0;
d177 2
a178 3
/* XXX discard incoming data after MAC error */
static u_int packet_discard = 0;
static Mac *packet_discard_mac = NULL;
d180 1
a180 4
struct packet {
	TAILQ_ENTRY(packet) next;
	u_char type;
	Buffer payload;
d182 14
a195 1
TAILQ_HEAD(, packet) outgoing;
d208 5
a212 3
	connection_in = fd_in;
	connection_out = fd_out;
	cipher_init(&send_context, none, (const u_char *)"",
d214 1
a214 1
	cipher_init(&receive_context, none, (const u_char *)"",
d216 9
a224 9
	newkeys[MODE_IN] = newkeys[MODE_OUT] = NULL;
	if (!initialized) {
		initialized = 1;
		buffer_init(&input);
		buffer_init(&output);
		buffer_init(&outgoing_packet);
		buffer_init(&incoming_packet);
		TAILQ_INIT(&outgoing);
		p_send.packets = p_read.packets = 0;
d232 1
a232 1
		packet_timeout_ms = -1;
d236 1
a236 1
		packet_timeout_ms = INT_MAX;
d238 1
a238 1
		packet_timeout_ms = timeout * count * 1000;
d244 1
a244 1
	if (packet_discard_mac) {
d248 7
a254 5
		while (buffer_len(&incoming_packet) < PACKET_MAX_SIZE)
			buffer_append(&incoming_packet, buf, sizeof(buf));
		(void) mac_compute(packet_discard_mac,
		    p_read.seqnr,
		    buffer_ptr(&incoming_packet),
d267 2
a268 2
		packet_discard_mac = mac;
	if (buffer_len(&input) >= discard)
d270 2
a271 1
	packet_discard = discard - buffer_len(&input);
d283 1
a283 1
	if (connection_in == connection_out)
d287 2
a288 1
	if (getpeername(connection_in, (struct sockaddr *)&from, &fromlen) < 0)
d292 2
a293 1
	if (getpeername(connection_out, (struct sockaddr *)&to, &tolen) < 0)
d314 1
a314 1
		cc = &send_context;
d316 1
a316 1
		cc = &receive_context;
d327 1
a327 1
		cc = &send_context;
d329 1
a329 1
		cc = &receive_context;
d340 1
a340 1
		cc = &send_context;
d342 1
a342 1
		cc = &receive_context;
d353 1
a353 1
		cc = &send_context;
d355 1
a355 1
		cc = &receive_context;
d366 1
a366 1
		cc = &send_context;
d368 1
a368 1
		cc = &receive_context;
d376 1
a376 1
	return (cipher_get_number(receive_context.cipher));
d385 2
a386 1
	state = (mode == MODE_IN) ? &p_read : &p_send;
d403 2
a404 1
	state = (mode == MODE_IN) ? &p_read : &p_send;
d420 2
a421 1
	if (getsockname(connection_out, (struct sockaddr *)&to, &tolen) < 0)
d434 1
a434 1
	set_nonblock(connection_in);
d436 2
a437 2
	if (connection_out != connection_in)
		set_nonblock(connection_out);
d445 1
a445 1
	return connection_in;
d453 1
a453 1
	return connection_out;
d461 1
a461 1
	if (!initialized)
d463 4
a466 4
	initialized = 0;
	if (connection_in == connection_out) {
		shutdown(connection_out, SHUT_RDWR);
		close(connection_out);
d468 2
a469 2
		close(connection_in);
		close(connection_out);
d471 6
a476 6
	buffer_free(&input);
	buffer_free(&output);
	buffer_free(&outgoing_packet);
	buffer_free(&incoming_packet);
	if (compression_buffer_ready) {
		buffer_free(&compression_buffer);
d479 2
a480 2
	cipher_cleanup(&send_context);
	cipher_cleanup(&receive_context);
d488 1
a488 1
	remote_protocol_flags = protocol_flags;
d496 1
a496 1
	return remote_protocol_flags;
d507 1
a507 1
	if (compression_buffer_ready == 1)
d509 2
a510 2
	compression_buffer_ready = 1;
	buffer_init(&compression_buffer);
d516 1
a516 1
	if (packet_compression && !compat20)
d518 1
a518 1
	packet_compression = 1;
d542 6
a547 4
	memcpy(ssh1_key, key, keylen);
	ssh1_keylen = keylen;
	cipher_init(&send_context, cipher, key, keylen, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, cipher, key, keylen, NULL, 0, CIPHER_DECRYPT);
d554 3
a556 3
		return (ssh1_keylen);
	memcpy(key, ssh1_key, ssh1_keylen);
	return (ssh1_keylen);
d570 2
a571 2
	buffer_clear(&outgoing_packet);
	buffer_append(&outgoing_packet, buf, len);
d580 1
a580 1
	buffer_append(&outgoing_packet, &ch, 1);
d586 1
a586 1
	buffer_put_int(&outgoing_packet, value);
d592 1
a592 1
	buffer_put_string(&outgoing_packet, buf, len);
d598 1
a598 1
	buffer_put_cstring(&outgoing_packet, str);
d604 1
a604 1
	buffer_append(&outgoing_packet, buf, len);
d610 1
a610 1
	buffer_put_bignum(&outgoing_packet, value);
d616 1
a616 1
	buffer_put_bignum2(&outgoing_packet, value);
d636 2
a637 2
	if (packet_compression) {
		buffer_clear(&compression_buffer);
d639 1
a639 1
		buffer_consume(&outgoing_packet, 8);
d641 8
a648 5
		buffer_append(&compression_buffer, "\0\0\0\0\0\0\0\0", 8);
		buffer_compress(&outgoing_packet, &compression_buffer);
		buffer_clear(&outgoing_packet);
		buffer_append(&outgoing_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
d651 1
a651 1
	len = buffer_len(&outgoing_packet) + 4 - 8;
d655 2
a656 2
	if (!send_context.plaintext) {
		cp = buffer_ptr(&outgoing_packet);
d664 1
a664 1
	buffer_consume(&outgoing_packet, 8 - padding);
d667 2
a668 2
	checksum = ssh_crc32(buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
d670 1
a670 1
	buffer_append(&outgoing_packet, buf, 4);
d674 1
a674 1
	buffer_dump(&outgoing_packet);
d679 6
a684 4
	buffer_append(&output, buf, 4);
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
d688 1
a688 1
	buffer_dump(&output);
d690 4
a693 3
	p_send.packets++;
	p_send.bytes += len + buffer_len(&outgoing_packet);
	buffer_clear(&outgoing_packet);
d715 1
a715 1
		cc = &send_context;
d717 2
a718 2
		p_send.packets = p_send.blocks = 0;
		max_blocks = &max_blocks_out;
d720 1
a720 1
		cc = &receive_context;
d722 2
a723 2
		p_read.packets = p_read.blocks = 0;
		max_blocks = &max_blocks_in;
d725 1
a725 1
	if (newkeys[mode] != NULL) {
d728 3
a730 3
		enc  = &newkeys[mode]->enc;
		mac  = &newkeys[mode]->mac;
		comp = &newkeys[mode]->comp;
d738 1
a738 1
		xfree(newkeys[mode]);
d740 2
a741 2
	newkeys[mode] = kex_get_newkeys(mode);
	if (newkeys[mode] == NULL)
d743 3
a745 3
	enc  = &newkeys[mode]->enc;
	mac  = &newkeys[mode]->mac;
	comp = &newkeys[mode]->comp;
d756 2
a757 2
	    (comp->type == COMP_DELAYED && after_authentication)) &&
	    comp->enabled == 0) {
d773 3
a775 2
	if (rekey_limit)
		*max_blocks = MIN(*max_blocks, rekey_limit / enc->block_size);
d793 1
a793 1
	after_authentication = 1;
d796 1
a796 1
		if (newkeys[mode] == NULL)
d798 1
a798 1
		comp = &newkeys[mode]->comp;
d826 4
a829 4
	if (newkeys[MODE_OUT] != NULL) {
		enc  = &newkeys[MODE_OUT]->enc;
		mac  = &newkeys[MODE_OUT]->mac;
		comp = &newkeys[MODE_OUT]->comp;
d833 1
a833 1
	cp = buffer_ptr(&outgoing_packet);
d838 1
a838 1
	buffer_dump(&outgoing_packet);
d842 1
a842 1
		len = buffer_len(&outgoing_packet);
d844 9
a852 7
		buffer_consume(&outgoing_packet, 5);
		buffer_clear(&compression_buffer);
		buffer_compress(&outgoing_packet, &compression_buffer);
		buffer_clear(&outgoing_packet);
		buffer_append(&outgoing_packet, "\0\0\0\0\0", 5);
		buffer_append(&outgoing_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
d854 1
a854 1
		    buffer_len(&outgoing_packet)));
d858 1
a858 1
	len = buffer_len(&outgoing_packet);
d867 1
a867 1
	if (extra_pad) {
d869 4
a872 2
		extra_pad  = roundup(extra_pad, block_size);
		pad = extra_pad - ((len + padlen) % extra_pad);
d874 1
a874 1
		    pad, len, padlen, extra_pad);
d876 1
a876 1
		extra_pad = 0;
d878 2
a879 2
	cp = buffer_append_space(&outgoing_packet, padlen);
	if (enc && !send_context.plaintext) {
d892 2
a893 2
	packet_length = buffer_len(&outgoing_packet) - 4;
	cp = buffer_ptr(&outgoing_packet);
d900 4
a903 4
		macbuf = mac_compute(mac, p_send.seqnr,
		    buffer_ptr(&outgoing_packet),
		    buffer_len(&outgoing_packet));
		DBG(debug("done calc MAC out #%d", p_send.seqnr));
d906 5
a910 3
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
d913 1
a913 1
		buffer_append(&output, macbuf, mac->mac_len);
d916 1
a916 1
	buffer_dump(&output);
d919 1
a919 1
	if (++p_send.seqnr == 0)
d921 1
a921 1
	if (++p_send.packets == 0)
d924 3
a926 3
	p_send.blocks += (packet_length + 4) / block_size;
	p_send.bytes += packet_length + 4;
	buffer_clear(&outgoing_packet);
d930 1
a930 1
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && server_side)
d941 1
a941 1
	cp = buffer_ptr(&outgoing_packet);
d951 4
a954 3
			memcpy(&p->payload, &outgoing_packet, sizeof(Buffer));
			buffer_init(&outgoing_packet);
			TAILQ_INSERT_TAIL(&outgoing, p, next);
d968 1
a968 1
		while ((p = TAILQ_FIRST(&outgoing))) {
d971 2
a972 2
			buffer_free(&outgoing_packet);
			memcpy(&outgoing_packet, &p->payload,
d974 1
a974 1
			TAILQ_REMOVE(&outgoing, p, next);
d1007 2
a1008 2
	setp = (fd_set *)xcalloc(howmany(connection_in+1, NFDBITS),
	    sizeof(fd_mask));
d1032 3
a1034 3
		memset(setp, 0, howmany(connection_in + 1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(connection_in, setp);
d1036 2
a1037 2
		if (packet_timeout_ms > 0) {
			ms_remain = packet_timeout_ms;
d1042 1
a1042 1
			if (packet_timeout_ms != -1) {
d1046 2
a1047 2
			if ((ret = select(connection_in + 1, setp, NULL,
			    NULL, timeoutp)) >= 0)
d1049 1
a1049 1
		   	if (errno != EAGAIN && errno != EINTR)
d1051 1
a1051 1
			if (packet_timeout_ms == -1)
d1065 1
a1065 1
		len = read(connection_in, buf, sizeof(buf));
d1117 1
a1117 1
	if (buffer_len(&input) < 4 + 8)
d1120 1
a1120 1
	cp = buffer_ptr(&input);
d1127 1
a1127 1
	if (buffer_len(&input) < 4 + padded_len)
d1133 1
a1133 1
	buffer_consume(&input, 4);
d1140 3
a1142 2
	if (!receive_context.plaintext) {
		switch (detect_attack(buffer_ptr(&input), padded_len)) {
d1153 4
a1156 3
	buffer_clear(&incoming_packet);
	cp = buffer_append_space(&incoming_packet, padded_len);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), padded_len);
d1158 1
a1158 1
	buffer_consume(&input, padded_len);
d1162 1
a1162 1
	buffer_dump(&incoming_packet);
d1166 2
a1167 2
	checksum = ssh_crc32(buffer_ptr(&incoming_packet),
	    buffer_len(&incoming_packet) - 4);
d1170 1
a1170 1
	buffer_consume(&incoming_packet, 8 - len % 8);
d1173 1
a1173 1
	if (len != buffer_len(&incoming_packet))
d1175 1
a1175 1
		    len, buffer_len(&incoming_packet));
d1177 1
a1177 1
	cp = (u_char *)buffer_ptr(&incoming_packet) + len - 4;
d1181 1
a1181 1
	buffer_consume_end(&incoming_packet, 4);
d1183 12
a1194 10
	if (packet_compression) {
		buffer_clear(&compression_buffer);
		buffer_uncompress(&incoming_packet, &compression_buffer);
		buffer_clear(&incoming_packet);
		buffer_append(&incoming_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
	}
	p_read.packets++;
	p_read.bytes += padded_len + 4;
	type = buffer_get_char(&incoming_packet);
a1202 1
	static u_int packet_length = 0;
d1210 1
a1210 1
	if (packet_discard)
d1213 4
a1216 4
	if (newkeys[MODE_IN] != NULL) {
		enc  = &newkeys[MODE_IN]->enc;
		mac  = &newkeys[MODE_IN]->mac;
		comp = &newkeys[MODE_IN]->comp;
d1221 1
a1221 1
	if (packet_length == 0) {
d1226 1
a1226 1
		if (buffer_len(&input) < block_size)
d1228 2
a1229 3
		buffer_clear(&incoming_packet);
		cp = buffer_append_space(&incoming_packet, block_size);
		cipher_crypt(&receive_context, cp, buffer_ptr(&input),
d1231 6
a1236 3
		cp = buffer_ptr(&incoming_packet);
		packet_length = get_u32(cp);
		if (packet_length < 1 + 4 || packet_length > PACKET_MAX_SIZE) {
d1238 1
a1238 1
			buffer_dump(&incoming_packet);
d1240 2
a1241 2
			logit("Bad packet length %u.", packet_length);
			packet_start_discard(enc, mac, packet_length,
d1245 2
a1246 2
		DBG(debug("input: packet len %u", packet_length+4));
		buffer_consume(&input, block_size);
d1249 1
a1249 1
	need = 4 + packet_length - block_size;
d1255 1
a1255 1
		packet_start_discard(enc, mac, packet_length,
d1263 1
a1263 1
	if (buffer_len(&input) < need + maclen)
d1267 1
a1267 1
	buffer_dump(&input);
d1269 4
a1272 3
	cp = buffer_append_space(&incoming_packet, need);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), need);
	buffer_consume(&input, need);
d1278 5
a1282 4
		macbuf = mac_compute(mac, p_read.seqnr,
		    buffer_ptr(&incoming_packet),
		    buffer_len(&incoming_packet));
		if (memcmp(macbuf, buffer_ptr(&input), mac->mac_len) != 0) {
d1286 1
a1286 1
			packet_start_discard(enc, mac, packet_length,
d1291 2
a1292 2
		DBG(debug("MAC #%d ok", p_read.seqnr));
		buffer_consume(&input, mac->mac_len);
d1296 2
a1297 2
		*seqnr_p = p_read.seqnr;
	if (++p_read.seqnr == 0)
d1299 1
a1299 1
	if (++p_read.packets == 0)
d1302 2
a1303 2
	p_read.blocks += (packet_length + 4) / block_size;
	p_read.bytes += packet_length + 4;
d1306 1
a1306 1
	cp = buffer_ptr(&incoming_packet);
d1313 2
a1314 2
	buffer_consume(&incoming_packet, 4 + 1);
	buffer_consume_end(&incoming_packet, padlen);
d1316 2
a1317 1
	DBG(debug("input: len before de-compress %d", buffer_len(&incoming_packet)));
d1319 7
a1325 5
		buffer_clear(&compression_buffer);
		buffer_uncompress(&incoming_packet, &compression_buffer);
		buffer_clear(&incoming_packet);
		buffer_append(&incoming_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
d1327 1
a1327 1
		    buffer_len(&incoming_packet)));
d1333 1
a1333 1
	type = buffer_get_char(&incoming_packet);
d1338 2
a1339 1
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && !server_side)
d1343 1
a1343 1
	buffer_dump(&incoming_packet);
d1346 1
a1346 1
	packet_length = 0;
d1361 1
a1361 1
				keep_alive_timeouts = 0;
d1431 3
a1433 3
	if (packet_discard) {
		keep_alive_timeouts = 0; /* ?? */
		if (len >= packet_discard)
d1435 1
a1435 1
		packet_discard -= len;
d1438 1
a1438 1
	buffer_append(&input, buf, len);
d1448 1
a1448 1
	buffer_get(&incoming_packet, &ch, 1);
d1457 1
a1457 1
	return buffer_get_int(&incoming_packet);
d1468 1
a1468 1
	buffer_get_bignum(&incoming_packet, value);
d1474 1
a1474 1
	buffer_get_bignum2(&incoming_packet, value);
d1480 1
a1480 1
	u_int bytes = buffer_len(&incoming_packet);
d1484 1
a1484 1
	return buffer_ptr(&incoming_packet);
d1490 1
a1490 1
	return buffer_len(&incoming_packet);
d1503 1
a1503 1
	return buffer_get_string(&incoming_packet, length_ptr);
d1509 1
a1509 1
	return buffer_get_string_ptr(&incoming_packet, length_ptr);
d1602 1
a1602 1
	int len = buffer_len(&output);
d1605 2
a1606 1
		len = write(connection_out, buffer_ptr(&output), len);
d1614 1
a1614 1
		buffer_consume(&output, len);
d1630 2
a1631 2
	setp = (fd_set *)xcalloc(howmany(connection_out + 1, NFDBITS),
	    sizeof(fd_mask));
d1634 3
a1636 3
		memset(setp, 0, howmany(connection_out + 1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(connection_out, setp);
d1638 2
a1639 2
		if (packet_timeout_ms > 0) {
			ms_remain = packet_timeout_ms;
d1643 1
a1643 1
			if (packet_timeout_ms != -1) {
d1647 2
a1648 2
			if ((ret = select(connection_out + 1, NULL, setp,
			    NULL, timeoutp)) >= 0)
d1650 1
a1650 1
		   	if (errno != EAGAIN && errno != EINTR)
d1652 1
a1652 1
			if (packet_timeout_ms == -1)
d1675 1
a1675 1
	return buffer_len(&output) != 0;
d1683 2
a1684 2
	if (interactive_mode)
		return buffer_len(&output) < 16384;
d1686 1
a1686 1
		return buffer_len(&output) < 128 * 1024;
d1697 1
a1697 1
	if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, &tos,
d1715 1
a1715 1
	interactive_mode = interactive;
d1720 1
a1720 1
	set_nodelay(connection_in);
d1729 1
a1729 1
	return interactive_mode;
d1739 1
a1739 1
		    max_packet_size, s);
d1748 1
a1748 1
	max_packet_size = s;
d1752 18
d1774 1
a1774 1
	extra_pad = pad;
d1811 6
a1816 4
	    (p_send.packets > MAX_PACKETS) ||
	    (p_read.packets > MAX_PACKETS) ||
	    (max_blocks_out && (p_send.blocks > max_blocks_out)) ||
	    (max_blocks_in  && (p_read.blocks > max_blocks_in));
d1822 1
a1822 1
	rekey_limit = bytes;
d1828 1
a1828 1
	server_side = 1;
d1834 19
a1852 1
	after_authentication = 1;
@


1.159
log
@Work around the CPNI-957037 Plaintext Recovery Attack by always
reading 256K of data on packet size or HMAC errors (in CBC mode only).
Help, feedback and ok djm@@
Feedback from Martin Albrecht and Paterson Kenny
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.158 2008/11/21 15:47:38 markus Exp $ */
d235 1
a235 1
	if (!cipher_is_cbc(enc->cipher))
@


1.158
log
@packet_disconnect() on padding error, too.  should reduce the success
probability for the CPNI-957037 Plaintext Recovery Attack to 2^-18
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.157 2008/07/10 18:08:11 markus Exp $ */
d83 2
d161 4
d214 30
d1156 3
d1180 1
a1180 1
		if (packet_length < 1 + 4 || packet_length > 256 * 1024) {
d1184 4
a1187 2
			packet_disconnect("Bad packet length %-10u",
			    packet_length);
d1199 3
a1201 1
		packet_disconnect("Bad packet length %-10u", packet_length);
d1224 9
a1232 2
		if (memcmp(macbuf, buffer_ptr(&input), mac->mac_len) != 0)
			packet_disconnect("Corrupted MAC on input.");
d1236 1
d1369 7
@


1.157
log
@sync v1 and v2 traffic accounting; add it to sshd, too; ok djm@@, dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.156 2008/07/04 23:08:25 djm Exp $ */
d1145 2
a1146 1
			packet_disconnect("Bad packet length %u.", packet_length);
d1155 2
a1156 2
	if (need % block_size != 0)
		fatal("padding error: need %d block %d mod %d",
d1158 2
@


1.156
log
@handle EINTR in packet_write_poll()l ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.155 2008/06/13 09:44:36 deraadt Exp $ */
d146 1
d191 1
d312 2
a313 1
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks, u_int32_t *packets)
d318 8
a325 3
	*seqnr = state->seqnr;
	*blocks = state->blocks;
	*packets = state->packets;
d329 2
a330 1
packet_set_state(int mode, u_int32_t seqnr, u_int64_t blocks, u_int32_t packets)
d338 1
d612 2
a613 1

d839 1
d1101 2
d1191 1
@


1.155
log
@compile on older gcc; no decl after code
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.154 2008/06/12 20:38:28 dtucker Exp $ */
d1468 2
a1469 2
		if (len <= 0) {
			if (errno == EAGAIN)
d1471 1
a1471 2
			else
				fatal("Write failed: %.100s", strerror(errno));
d1473 2
@


1.154
log
@Make keepalive timeouts apply while waiting for a packet, particularly during
key renegotiation (bz #1363).  With djm and Matt Day, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.153 2008/05/19 06:14:02 djm Exp $ */
d904 2
a906 1
	struct timeval timeout, start, *timeoutp = NULL;
@


1.153
log
@unbreak protocol keepalive timeouts bz#1465; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.152 2008/05/08 06:59:01 markus Exp $ */
d137 3
d193 13
d901 1
a901 1
	int type, len;
d905 1
d936 4
d941 23
a963 4
		while (select(connection_in + 1, setp, NULL, NULL, NULL) == -1 &&
		    (errno == EAGAIN || errno == EINTR))
			;

d1486 2
d1496 28
a1523 3
		while (select(connection_out + 1, NULL, setp, NULL, NULL) == -1 &&
		    (errno == EAGAIN || errno == EINTR))
			;
@


1.152
log
@avoid extra malloc/copy/free when receiving data over the net;
~10% speedup for localhost-scp; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.151 2008/02/22 20:44:02 dtucker Exp $ */
d1188 2
a1189 2
			keep_alive_timeouts = 0;
			if (type)
d1191 1
@


1.151
log
@Allow all SSH2 packet types, including UNIMPLEMENTED to reset the
keepalive timer (bz #1307).  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.150 2008/01/23 01:56:54 dtucker Exp $ */
d1324 6
@


1.150
log
@Revert the change for bz #1307 as it causes connection aborts if an IGNORE
packet arrives while we're waiting in packet_read_expect (and possibly
elsewhere).
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.148 2007/06/07 19:37:34 pvalchev Exp $ */
d135 2
d1188 1
d1193 1
@


1.149
log
@Make SSH2_MSG_UNIMPLEMENTED and SSH2_MSG_IGNORE messages reset the
ServerAlive and ClientAlive timers.  Prevents dropping a connection
when these are enabled but the peer does not support our keepalives.
bz #1307, ok djm@@.
@
text
@d962 3
a964 4
 * SSH_MSG_DISCONNECT is handled specially here.  Also, SSH_MSG_IGNORE
 * messages are skipped by this function and are never returned
 * to higher levels, although SSH2_MSG_IGNORE are since they are needed
 * for keepalives.
d1189 2
d1211 1
a1211 1
				/* FALLTHROUGH */
@


1.148
log
@Add a new MAC algorithm for data integrity, UMAC-64 (not default yet, must
specify umac-64@@openssh.com). Provides about 20% end-to-end speedup
compared to hmac-md5. Represents a different approach to message
authentication to that of HMAC that may be beneficial if HMAC based on one
of its underlying hash algorithms is found to be vulnerable to a new attack.
http://www.ietf.org/rfc/rfc4418.txt

in conjunction with and OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.147 2007/06/05 06:52:37 djm Exp $ */
d962 4
a965 3
 * SSH_MSG_DISCONNECT is handled specially here.  Also,
 * SSH_MSG_IGNORE messages are skipped by this function and are never returned
 * to higher levels.
a1189 2
			case SSH2_MSG_IGNORE:
				break;
d1210 1
a1210 1
				break;
@


1.147
log
@Preserve MAC ctx between packets, saving 2xhash calls per-packet.
Yields around a 12-16% end-to-end speedup for arcfour256/hmac-md5

patch from markus@@ tested dtucker@@ and myself, ok markus@@ and me (I'm
committing at his request)
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.146 2007/05/31 23:34:29 djm Exp $ */
d623 1
a623 2
		if (mac->md != NULL)
			mac_clear(mac);
d638 1
a638 2
	if (mac->md != NULL) {
		mac_init(mac);
a639 1
	}
@


1.146
log
@gc unreachable code; spotted by Tavis Ormandy
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.145 2006/09/19 21:14:08 markus Exp $ */
d623 2
a624 1
		memset(mac->key, 0, mac->key_len);
d639 2
a640 1
	if (mac->md != NULL)
d642 1
d648 2
a649 1
	   memset(enc->key, 0, enc->key_len); */
@


1.145
log
@client NULL deref on protocol error; Tavis Ormandy, Google Security Team
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.144 2006/09/16 19:53:37 djm Exp $ */
a1228 1
				xfree(msg);
@


1.144
log
@limit maximum work performed by the CRC compensation attack detector,
problem reported by Tavis Ormandy, Google Security Team;
ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.143 2006/08/05 08:34:04 dtucker Exp $ */
d685 3
@


1.144.2.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.145 2006/09/19 21:14:08 markus Exp $ */
a684 3
		/* protocol error: USERAUTH_SUCCESS received before NEWKEYS */
		if (newkeys[mode] == NULL)
			continue;
@


1.143
log
@Typo in comment
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.142 2006/08/03 03:34:42 deraadt Exp $ */
d994 10
a1003 3
	if (!receive_context.plaintext &&
	    detect_attack(buffer_ptr(&input), padded_len) == DEATTACK_DETECTED)
		packet_disconnect("crc32 compensation attack: network attack detected");
@


1.142
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.141 2006/08/01 23:22:47 stevesk Exp $ */
d670 1
a670 1
 * This happans on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
@


1.141
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.140 2006/07/26 13:57:17 stevesk Exp $ */
d40 1
a40 2
#include "includes.h"

a41 1
#include <sys/types.h>
d56 1
a60 1
#include "bufaux.h"
a61 1

a64 1

a67 1

d69 1
@


1.140
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.139 2006/07/26 02:35:17 stevesk Exp $ */
d54 1
@


1.139
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.138 2006/07/25 02:59:21 stevesk Exp $ */
d54 1
@


1.138
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.137 2006/07/22 20:48:23 stevesk Exp $ */
d46 1
@


1.137
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.136 2006/07/17 01:31:09 stevesk Exp $ */
d45 1
@


1.136
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.135 2006/07/11 20:07:25 stevesk Exp $ */
d52 1
@


1.135
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.134 2006/07/10 16:37:36 stevesk Exp $ */
d52 1
@


1.134
log
@move #include <stdarg.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.133 2006/07/08 21:47:12 stevesk Exp $ */
d50 1
@


1.133
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.132 2006/07/05 02:42:09 stevesk Exp $ */
d49 2
@


1.132
log
@move #include <netinet/in.h> out of includes.h; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.131 2006/03/30 09:58:16 djm Exp $ */
d43 1
@


1.131
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.130 2006/03/25 18:56:55 deraadt Exp $ */
d43 1
d46 1
@


1.130
log
@remove (char *) casts to a function that accepts void * for the arg
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.129 2006/03/25 18:29:35 deraadt Exp $ */
a51 1
#include "getput.h"
d557 1
a557 1
	PUT_32BIT(buf, checksum);
d566 1
a566 1
	PUT_32BIT(buf, len);
d769 1
a769 1
	PUT_32BIT(cp, packet_length);
d967 1
a967 1
	len = GET_32BIT(cp);
d1015 1
a1015 1
	stored_checksum = GET_32BIT(cp);
d1064 1
a1064 1
		packet_length = GET_32BIT(cp);
@


1.129
log
@needed casts (always will be needed)
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.128 2006/03/25 13:17:02 djm Exp $ */
d787 1
a787 1
		buffer_append(&output, (char *)macbuf, mac->mac_len);
@


1.128
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1545 1
a1545 1
		packet_put_char(rnd & 0xff);
@


1.127
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.126
log
@remove IV support from the CRC attack detector, OpenSSH has never used
it - it only applied to IDEA-CFB, which we don't support.
prompted by NetBSD Coverity report via elad AT netbsd.org;
feedback markus@@ "nuke it" deraadt@@
@
text
@d876 1
a876 1
	setp = (fd_set *)xmalloc(howmany(connection_in+1, NFDBITS) *
d1418 1
a1418 1
	setp = (fd_set *)xmalloc(howmany(connection_out + 1, NFDBITS) *
@


1.125
log
@spacing
@
text
@d987 1
a987 1
	    detect_attack(buffer_ptr(&input), padded_len, NULL) == DEATTACK_DETECTED)
@


1.124
log
@in a switch (), break after return or goto is stupid
@
text
@d263 1
d276 1
d473 1
d479 1
d485 1
d491 1
d497 1
d503 1
@


1.123
log
@RCSID() can die
@
text
@a1186 1
				break;
a1208 1
				break;
@


1.122
log
@Set TCP_NODELAY for all connections not just "interactive" ones.  Fixes
poor performance and protocol stalls under some network conditions (mindrot
bugs #556 and #981). Patch originally from markus@@, ok djm@@
@
text
@a39 1
RCSID("$OpenBSD: packet.c,v 1.121 2006/02/08 14:38:18 stevesk Exp $");
@


1.121
log
@move #include <netinet/in_systm.h> and <netinet/ip.h> out of
includes.h; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.120 2005/10/30 08:52:17 djm Exp $");
d1478 1
a1478 2
	if (interactive)
		set_nodelay(connection_in);
@


1.121.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: packet.c,v 1.144 2006/09/16 19:53:37 djm Exp $ */
d39 3
a41 1
#include <sys/types.h>
a42 3
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/param.h>
a44 1
#include <netinet/in.h>
a46 8
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

d50 1
d52 2
d57 1
d61 1
a62 1
#include "key.h"
a263 1

a275 1

a471 1

a476 1

a481 1

a486 1

a491 1

a496 1

d550 1
a550 1
	put_u32(buf, checksum);
d559 1
a559 1
	put_u32(buf, len);
d655 1
a655 1
 * This happens on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
d762 1
a762 1
	put_u32(cp, packet_length);
d779 1
a779 1
		buffer_append(&output, macbuf, mac->mac_len);
d869 1
a869 1
	setp = (fd_set *)xcalloc(howmany(connection_in+1, NFDBITS),
d960 1
a960 1
	len = get_u32(cp);
d979 3
a981 10
	if (!receive_context.plaintext) {
		switch (detect_attack(buffer_ptr(&input), padded_len)) {
		case DEATTACK_DETECTED:
			packet_disconnect("crc32 compensation attack: "
			    "network attack detected");
		case DEATTACK_DOS_DETECTED:
			packet_disconnect("deattack denial of "
			    "service detected");
		}
	}
d1008 1
a1008 1
	stored_checksum = get_u32(cp);
d1057 1
a1057 1
		packet_length = get_u32(cp);
d1188 1
d1211 1
d1413 1
a1413 1
	setp = (fd_set *)xcalloc(howmany(connection_out + 1, NFDBITS),
d1478 2
a1479 1
	set_nodelay(connection_in);
d1540 1
a1540 1
		packet_put_char((u_char)rnd & 0xff);
@


1.121.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.145 2006/09/19 21:14:08 markus Exp $ */
a684 3
		/* protocol error: USERAUTH_SUCCESS received before NEWKEYS */
		if (newkeys[mode] == NULL)
			continue;
@


1.120
log
@no need to escape single quotes in comments, no binary change
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.119 2005/07/28 17:36:22 markus Exp $");
d43 3
@


1.119
log
@missing packet_init_compression(); from solar
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.118 2005/07/25 11:59:39 markus Exp $");
d570 1
a570 1
	 * Note that the packet is now only buffered in output.  It won\'t be
@


1.119.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.120 2005/10/30 08:52:17 djm Exp $");
d570 1
a570 1
	 * Note that the packet is now only buffered in output.  It won't be
@


1.119.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: packet.c,v 1.144 2006/09/16 19:53:37 djm Exp $ */
d39 3
a41 1
#include <sys/types.h>
a42 15
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/param.h>

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
d47 1
d49 2
d54 1
d58 1
a59 1
#include "key.h"
a260 1

a272 1

a468 1

a473 1

a478 1

a483 1

a488 1

a493 1

d547 1
a547 1
	put_u32(buf, checksum);
d556 1
a556 1
	put_u32(buf, len);
d652 1
a652 1
 * This happens on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
d759 1
a759 1
	put_u32(cp, packet_length);
d776 1
a776 1
		buffer_append(&output, macbuf, mac->mac_len);
d866 1
a866 1
	setp = (fd_set *)xcalloc(howmany(connection_in+1, NFDBITS),
d957 1
a957 1
	len = get_u32(cp);
d976 3
a978 10
	if (!receive_context.plaintext) {
		switch (detect_attack(buffer_ptr(&input), padded_len)) {
		case DEATTACK_DETECTED:
			packet_disconnect("crc32 compensation attack: "
			    "network attack detected");
		case DEATTACK_DOS_DETECTED:
			packet_disconnect("deattack denial of "
			    "service detected");
		}
	}
d1005 1
a1005 1
	stored_checksum = get_u32(cp);
d1054 1
a1054 1
		packet_length = get_u32(cp);
d1185 1
d1208 1
d1410 1
a1410 1
	setp = (fd_set *)xcalloc(howmany(connection_out + 1, NFDBITS),
d1475 2
a1476 1
	set_nodelay(connection_in);
d1537 1
a1537 1
		packet_put_char((u_char)rnd & 0xff);
@


1.119.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.145 2006/09/19 21:14:08 markus Exp $ */
a684 3
		/* protocol error: USERAUTH_SUCCESS received before NEWKEYS */
		if (newkeys[mode] == NULL)
			continue;
@


1.118
log
@add a new compression method that delays compression until the user
has been authenticated successfully and set compression to 'delayed'
for sshd.

this breaks older openssh clients (< 3.5) if they insist on
compression, so you have to re-enable compression in sshd_config.
ok djm@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.117 2005/06/17 02:44:32 djm Exp $");
d669 1
@


1.117
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.116 2004/10/20 11:48:53 markus Exp $");
d119 6
d628 3
a630 1
	if (comp->type != 0 && comp->enabled == 0) {
d651 28
d791 2
d1135 2
d1558 12
@


1.116
log
@disconnect for invalid (out of range) message types.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.115 2004/06/21 17:36:31 avsm Exp $");
d990 1
a990 1
	int maclen, block_size;
d1227 1
a1227 1
packet_get_raw(int *length_ptr)
d1229 1
a1229 1
	int bytes = buffer_len(&incoming_packet);
@


1.116.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.119 2005/07/28 17:36:22 markus Exp $");
a118 6
/* Set to true if we are the server side. */
static int server_side = 0;

/* Set to true if we are authenticated. */
static int after_authentication = 0;

d622 1
a622 3
	if ((comp->type == COMP_ZLIB ||
	    (comp->type == COMP_DELAYED && after_authentication)) &&
	    comp->enabled == 0) {
a642 29
 * Delayed compression for SSH2 is enabled after authentication:
 * This happans on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
 * and on the client side after a SSH2_MSG_USERAUTH_SUCCESS is received.
 */
static void
packet_enable_delayed_compress(void)
{
	Comp *comp = NULL;
	int mode;

	/*
	 * Remember that we are past the authentication step, so rekeying
	 * with COMP_DELAYED will turn on compression immediately.
	 */
	after_authentication = 1;
	for (mode = 0; mode < MODE_MAX; mode++) {
		comp = &newkeys[mode]->comp;
		if (comp && !comp->enabled && comp->type == COMP_DELAYED) {
			packet_init_compression();
			if (mode == MODE_OUT)
				buffer_compress_init_send(6);
			else
				buffer_compress_init_recv();
			comp->enabled = 1;
		}
	}
}

/*
a754 2
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && server_side)
		packet_enable_delayed_compress();
d990 1
a990 1
	u_int maclen, block_size;
a1096 2
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && !server_side)
		packet_enable_delayed_compress();
d1227 1
a1227 1
packet_get_raw(u_int *length_ptr)
d1229 1
a1229 1
	u_int bytes = buffer_len(&incoming_packet);
a1517 12
}

void
packet_set_server(void)
{
	server_side = 1;
}

void
packet_set_authenticated(void)
{
	after_authentication = 1;
@


1.116.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.120 2005/10/30 08:52:17 djm Exp $");
d570 1
a570 1
	 * Note that the packet is now only buffered in output.  It won't be
@


1.115
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.114 2004/06/14 01:44:39 djm Exp $");
d979 2
d1093 2
@


1.115.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.116 2004/10/20 11:48:53 markus Exp $");
a978 2
	if (type < SSH_MSG_MIN || type > SSH_MSG_MAX)
		packet_disconnect("Invalid ssh1 packet type: %d", type);
a1090 2
	if (type < SSH2_MSG_MIN || type >= SSH2_MSG_LOCAL_MIN)
		packet_disconnect("Invalid ssh2 packet type: %d", type);
@


1.115.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.119 2005/07/28 17:36:22 markus Exp $");
a118 6
/* Set to true if we are the server side. */
static int server_side = 0;

/* Set to true if we are authenticated. */
static int after_authentication = 0;

d622 1
a622 3
	if ((comp->type == COMP_ZLIB ||
	    (comp->type == COMP_DELAYED && after_authentication)) &&
	    comp->enabled == 0) {
a642 29
 * Delayed compression for SSH2 is enabled after authentication:
 * This happans on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
 * and on the client side after a SSH2_MSG_USERAUTH_SUCCESS is received.
 */
static void
packet_enable_delayed_compress(void)
{
	Comp *comp = NULL;
	int mode;

	/*
	 * Remember that we are past the authentication step, so rekeying
	 * with COMP_DELAYED will turn on compression immediately.
	 */
	after_authentication = 1;
	for (mode = 0; mode < MODE_MAX; mode++) {
		comp = &newkeys[mode]->comp;
		if (comp && !comp->enabled && comp->type == COMP_DELAYED) {
			packet_init_compression();
			if (mode == MODE_OUT)
				buffer_compress_init_send(6);
			else
				buffer_compress_init_recv();
			comp->enabled = 1;
		}
	}
}

/*
a754 2
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && server_side)
		packet_enable_delayed_compress();
d990 1
a990 1
	u_int maclen, block_size;
a1096 2
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && !server_side)
		packet_enable_delayed_compress();
d1227 1
a1227 1
packet_get_raw(u_int *length_ptr)
d1229 1
a1229 1
	u_int bytes = buffer_len(&incoming_packet);
a1517 12
}

void
packet_set_server(void)
{
	server_side = 1;
}

void
packet_set_authenticated(void)
{
	after_authentication = 1;
@


1.114
log
@set_nonblock() instead of fnctl(...,O_NONBLOCK); "looks sane" deraadt@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.113 2004/05/11 19:01:43 deraadt Exp $");
d505 1
a505 1
	u_int32_t rand = 0;
d531 3
a533 3
				rand = arc4random();
			cp[7 - i] = rand & 0xff;
			rand >>= 8;
d578 1
a578 1
	int encrypt;
d584 1
a584 1
		encrypt = CIPHER_ENCRYPT;
d589 1
a589 1
		encrypt = CIPHER_DECRYPT;
d618 1
a618 1
	    enc->iv, enc->block_size, encrypt);
d652 1
a652 1
	u_int32_t rand = 0;
d711 3
a713 3
				rand = arc4random();
			cp[i] = rand & 0xff;
			rand >>= 8;
d1484 1
a1484 1
	u_int32_t rand = 0;
d1491 3
a1493 3
			rand = arc4random();
		packet_put_char(rand & 0xff);
		rand >>= 8;
@


1.113
log
@improve some code lint did not like; djm millert ok
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.112 2003/09/23 20:17:11 markus Exp $");
d317 1
a317 2
	if (fcntl(connection_in, F_SETFL, O_NONBLOCK) < 0)
		error("fcntl O_NONBLOCK: %.100s", strerror(errno));
d319 2
a320 4
	if (connection_out != connection_in) {
		if (fcntl(connection_out, F_SETFL, O_NONBLOCK) < 0)
			error("fcntl O_NONBLOCK: %.100s", strerror(errno));
	}
@


1.112
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.111 2003/09/19 11:33:09 markus Exp $");
d157 4
a160 2
	cipher_init(&send_context, none, "", 0, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, none, "", 0, NULL, 0, CIPHER_DECRYPT);
d1446 1
a1446 1
u_int
d1500 1
a1500 1
#define MAX_PACKETS	(1<<31)
@


1.112.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.115 2004/06/21 17:36:31 avsm Exp $");
d157 2
a158 4
	cipher_init(&send_context, none, (const u_char *)"",
	    0, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, none, (const u_char *)"",
	    0, NULL, 0, CIPHER_DECRYPT);
d315 2
a316 1
	set_nonblock(connection_in);
d318 4
a321 2
	if (connection_out != connection_in)
		set_nonblock(connection_out);
d506 1
a506 1
	u_int32_t rnd = 0;
d532 3
a534 3
				rnd = arc4random();
			cp[7 - i] = rnd & 0xff;
			rnd >>= 8;
d579 1
a579 1
	int crypt_type;
d585 1
a585 1
		crypt_type = CIPHER_ENCRYPT;
d590 1
a590 1
		crypt_type = CIPHER_DECRYPT;
d619 1
a619 1
	    enc->iv, enc->block_size, crypt_type);
d653 1
a653 1
	u_int32_t rnd = 0;
d712 3
a714 3
				rnd = arc4random();
			cp[i] = rnd & 0xff;
			rnd >>= 8;
d1444 1
a1444 1
int
d1485 1
a1485 1
	u_int32_t rnd = 0;
d1492 3
a1494 3
			rnd = arc4random();
		packet_put_char(rnd & 0xff);
		rnd >>= 8;
d1498 1
a1498 1
#define MAX_PACKETS	(1U<<31)
@


1.112.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.116 2004/10/20 11:48:53 markus Exp $");
a978 2
	if (type < SSH_MSG_MIN || type > SSH_MSG_MAX)
		packet_disconnect("Invalid ssh1 packet type: %d", type);
a1090 2
	if (type < SSH2_MSG_MIN || type >= SSH2_MSG_LOCAL_MIN)
		packet_disconnect("Invalid ssh2 packet type: %d", type);
@


1.111
log
@do not call packet_close on fatal; ok deraadt
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.110 2003/09/19 09:02:02 markus Exp $");
d866 1
a866 1
			fatal_cleanup();
d1132 1
a1132 1
				fatal_cleanup();
d1157 1
a1157 1
				fatal_cleanup();
d1334 1
a1334 1
	fatal_cleanup();
@


1.110
log
@buffer_dump only if PACKET_DEBUG is defined; Jedi/Sector One; pr 3471
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.109 2003/07/10 14:42:28 markus Exp $");
a167 2
	/* Kludge: arrange the close function to be called from fatal(). */
	fatal_add_cleanup((void (*) (void *)) packet_close, NULL);
a1333 1

@


1.109
log
@the 2^(blocksize*2) rekeying limit is too expensive for 3DES,
blowfish, etc, so enforce a 1GB limit for small blocksizes.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.108 2003/06/24 08:23:46 markus Exp $");
d1018 1
d1020 1
@


1.109.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.112 2003/09/23 20:17:11 markus Exp $");
d168 2
d868 1
a868 1
			cleanup_exit(255);
a1017 1
#ifdef PACKET_DEBUG
a1018 1
#endif
d1132 1
a1132 1
				cleanup_exit(255);
d1157 1
a1157 1
				cleanup_exit(255);
d1334 2
a1335 1
	cleanup_exit(255);
@


1.109.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.115 2004/06/21 17:36:31 avsm Exp $");
d157 2
a158 4
	cipher_init(&send_context, none, (const u_char *)"",
	    0, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, none, (const u_char *)"",
	    0, NULL, 0, CIPHER_DECRYPT);
d315 2
a316 1
	set_nonblock(connection_in);
d318 4
a321 2
	if (connection_out != connection_in)
		set_nonblock(connection_out);
d506 1
a506 1
	u_int32_t rnd = 0;
d532 3
a534 3
				rnd = arc4random();
			cp[7 - i] = rnd & 0xff;
			rnd >>= 8;
d579 1
a579 1
	int crypt_type;
d585 1
a585 1
		crypt_type = CIPHER_ENCRYPT;
d590 1
a590 1
		crypt_type = CIPHER_DECRYPT;
d619 1
a619 1
	    enc->iv, enc->block_size, crypt_type);
d653 1
a653 1
	u_int32_t rnd = 0;
d712 3
a714 3
				rnd = arc4random();
			cp[i] = rnd & 0xff;
			rnd >>= 8;
d1444 1
a1444 1
int
d1485 1
a1485 1
	u_int32_t rnd = 0;
d1492 3
a1494 3
			rnd = arc4random();
		packet_put_char(rnd & 0xff);
		rnd >>= 8;
d1498 1
a1498 1
#define MAX_PACKETS	(1U<<31)
@


1.108
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.107 2003/06/10 22:20:52 deraadt Exp $");
d633 8
a640 1
	*max_blocks = ((u_int64_t)1 << (enc->block_size*2));
@


1.107
log
@mostly ansi cleanup; pval ok
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.106 2003/04/08 20:21:29 itojun Exp $");
d111 1
a111 1
int max_packet_size = 32768;
d1438 2
a1439 2
int
packet_set_maxsize(int s)
@


1.106
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.105 2003/04/02 09:48:07 markus Exp $");
d268 1
a268 1
packet_get_ssh1_cipher()
@


1.105
log
@reapply rekeying chage, tested by henning@@, ok djm@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.104 2003/04/01 10:22:21 markus Exp $");
d742 1
a742 1
		log("outgoing seqnr wraps around");
d860 1
a860 1
			log("Connection closed by %.200s", get_remote_ipaddr());
d1053 1
a1053 1
		log("incoming seqnr wraps around");
d1122 1
a1122 1
				log("Received disconnect from %s: %u: %.400s",
d1148 1
a1148 1
				log("Received disconnect from %s: %.400s",
d1307 1
a1307 1
	log("Disconnecting: %.100s", buf);
d1444 1
a1444 1
		log("packet_set_maxsize: called twice: old %d new %d",
d1449 1
a1449 1
		log("packet_set_maxsize: bad size %d", s);
@


1.104
log
@backout rekeying changes (for 3.6.1)
@
text
@d40 3
a42 1
RCSID("$OpenBSD: packet.c,v 1.103 2003/04/01 10:10:23 markus Exp $");
d121 8
a128 2
static u_int32_t read_seqnr = 0;
static u_int32_t send_seqnr = 0;
d137 7
d166 1
d273 4
d278 4
a281 4
u_int32_t
packet_get_seqnr(int mode)
{
	return (mode == MODE_IN ? read_seqnr : send_seqnr);
d285 1
a285 1
packet_set_seqnr(int mode, u_int32_t seqnr)
d287 6
a292 6
	if (mode == MODE_IN)
		read_seqnr = seqnr;
	else if (mode == MODE_OUT)
		send_seqnr = seqnr;
	else
		fatal("packet_set_seqnr: bad mode %d", mode);
d580 1
d588 2
d593 2
d633 3
d642 1
a642 1
packet_send2(void)
d724 1
a724 1
		macbuf = mac_compute(mac, send_seqnr,
d727 1
a727 1
		DBG(debug("done calc MAC out #%d", send_seqnr));
d741 1
a741 1
	if (++send_seqnr == 0)
d743 4
d753 46
d1042 1
a1042 1
		macbuf = mac_compute(mac, read_seqnr,
d1047 1
a1047 1
		DBG(debug("MAC #%d ok", read_seqnr));
d1051 2
a1052 2
		*seqnr_p = read_seqnr;
	if (++read_seqnr == 0)
d1054 4
d1490 19
@


1.103
log
@rekeying bugfixes and automatic rekeying:

* both client and server rekey _automatically_
      (a) after 2^31 packets, because after 2^32 packets
          the sequence number for packets wraps
      (b) after 2^(blocksize_in_bits/4) blocks
  (see: http://www.ietf.org/internet-drafts/draft-ietf-secsh-newmodes-00.txt)
  (a) and (b) are _enabled_ by default, and only disabled for known
  openssh versions, that don't support rekeying properly.
* client option 'RekeyLimit'
* do not reply to requests during rekeying
@
text
@d40 1
a40 3
RCSID("$OpenBSD: packet.c,v 1.102 2002/12/10 19:47:14 markus Exp $");

#include <sys/queue.h>
d119 2
a120 8
static struct packet_state {
	u_int32_t seqnr;
	u_int32_t packets;
	u_int64_t blocks;
} p_read, p_send;

static u_int64_t max_blocks_in, max_blocks_out;
static u_int32_t rekey_limit;
a128 7
struct packet {
	TAILQ_ENTRY(packet) next;
	u_char type;
	Buffer payload;
};
TAILQ_HEAD(, packet) outgoing;

a150 1
		TAILQ_INIT(&outgoing);
d257 3
a259 2
void
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks, u_int32_t *packets)
d261 1
a261 6
	struct packet_state *state;

	state = (mode == MODE_IN) ? &p_read : &p_send;
	*seqnr = state->seqnr;
	*blocks = state->blocks;
	*packets = state->packets;
d265 1
a265 1
packet_set_state(int mode, u_int32_t seqnr, u_int64_t blocks, u_int32_t packets)
d267 6
a272 6
	struct packet_state *state;

	state = (mode == MODE_IN) ? &p_read : &p_send;
	state->seqnr = seqnr;
	state->blocks = blocks;
	state->packets = packets;
a559 1
	u_int64_t *max_blocks;
a566 2
		p_send.packets = p_send.blocks = 0;
		max_blocks = &max_blocks_out;
a569 2
		p_read.packets = p_read.blocks = 0;
		max_blocks = &max_blocks_in;
a607 3
	*max_blocks = ((u_int64_t)1 << (enc->block_size*2));
	if (rekey_limit)
		*max_blocks = MIN(*max_blocks, rekey_limit / enc->block_size);
d614 1
a614 1
packet_send2_wrapped(void)
d696 1
a696 1
		macbuf = mac_compute(mac, p_send.seqnr,
d699 1
a699 1
		DBG(debug("done calc MAC out #%d", p_send.seqnr));
d713 1
a713 1
	if (++p_send.seqnr == 0)
a714 4
	if (++p_send.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	p_send.blocks += (packet_length + 4) / block_size;
a720 46
static void
packet_send2(void)
{
	static int rekeying = 0;
	struct packet *p;
	u_char type, *cp;

	cp = buffer_ptr(&outgoing_packet);
	type = cp[5];

	/* during rekeying we can only send key exchange messages */
	if (rekeying) {
		if (!((type >= SSH2_MSG_TRANSPORT_MIN) &&
		    (type <= SSH2_MSG_TRANSPORT_MAX))) {
			debug("enqueue packet: %u", type);
			p = xmalloc(sizeof(*p));
			p->type = type;
			memcpy(&p->payload, &outgoing_packet, sizeof(Buffer));
			buffer_init(&outgoing_packet);
			TAILQ_INSERT_TAIL(&outgoing, p, next);
			return;
		}
	}

	/* rekeying starts with sending KEXINIT */
	if (type == SSH2_MSG_KEXINIT)
		rekeying = 1;

	packet_send2_wrapped();

	/* after a NEWKEYS message we can send the complete queue */
	if (type == SSH2_MSG_NEWKEYS) {
		rekeying = 0;
		while ((p = TAILQ_FIRST(&outgoing))) {
			type = p->type;
			debug("dequeue packet: %u", type);
			buffer_free(&outgoing_packet);
			memcpy(&outgoing_packet, &p->payload,
			    sizeof(Buffer));
			TAILQ_REMOVE(&outgoing, p, next);
			xfree(p);
			packet_send2_wrapped();
		}
	}
}

d964 1
a964 1
		macbuf = mac_compute(mac, p_read.seqnr,
d969 1
a969 1
		DBG(debug("MAC #%d ok", p_read.seqnr));
d973 2
a974 2
		*seqnr_p = p_read.seqnr;
	if (++p_read.seqnr == 0)
a975 4
	if (++p_read.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	p_read.blocks += (packet_length + 4) / block_size;
a1407 19
}

#define MAX_PACKETS	(1<<31)
int
packet_need_rekeying(void)
{
	if (datafellows & SSH_BUG_NOREKEY)
		return 0;
	return
	    (p_send.packets > MAX_PACKETS) ||
	    (p_read.packets > MAX_PACKETS) ||
	    (max_blocks_out && (p_send.blocks > max_blocks_out)) ||
	    (max_blocks_in  && (p_read.blocks > max_blocks_in));
}

void
packet_set_rekey_limit(u_int32_t bytes)
{
	rekey_limit = bytes;
@


1.102
log
@static
@
text
@d40 3
a42 1
RCSID("$OpenBSD: packet.c,v 1.101 2002/12/10 19:26:50 markus Exp $");
d121 8
a128 2
static u_int32_t read_seqnr = 0;
static u_int32_t send_seqnr = 0;
d137 7
d166 1
d273 4
d278 4
a281 4
u_int32_t
packet_get_seqnr(int mode)
{
	return (mode == MODE_IN ? read_seqnr : send_seqnr);
d285 1
a285 1
packet_set_seqnr(int mode, u_int32_t seqnr)
d287 6
a292 6
	if (mode == MODE_IN)
		read_seqnr = seqnr;
	else if (mode == MODE_OUT)
		send_seqnr = seqnr;
	else
		fatal("packet_set_seqnr: bad mode %d", mode);
d580 1
d588 2
d593 2
d633 3
d642 1
a642 1
packet_send2(void)
d724 1
a724 1
		macbuf = mac_compute(mac, send_seqnr,
d727 1
a727 1
		DBG(debug("done calc MAC out #%d", send_seqnr));
d741 1
a741 1
	if (++send_seqnr == 0)
d743 4
d753 46
d1042 1
a1042 1
		macbuf = mac_compute(mac, read_seqnr,
d1047 1
a1047 1
		DBG(debug("MAC #%d ok", read_seqnr));
d1051 2
a1052 2
		*seqnr_p = read_seqnr;
	if (++read_seqnr == 0)
d1054 4
d1490 19
@


1.102.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d40 1
a40 3
RCSID("$OpenBSD: packet.c,v 1.109 2003/07/10 14:42:28 markus Exp $");

#include <sys/queue.h>
d109 1
a109 1
u_int max_packet_size = 32768;
d119 2
a120 8
static struct packet_state {
	u_int32_t seqnr;
	u_int32_t packets;
	u_int64_t blocks;
} p_read, p_send;

static u_int64_t max_blocks_in, max_blocks_out;
static u_int32_t rekey_limit;
a128 7
struct packet {
	TAILQ_ENTRY(packet) next;
	u_char type;
	Buffer payload;
};
TAILQ_HEAD(, packet) outgoing;

a150 1
		TAILQ_INIT(&outgoing);
d252 1
a252 1
packet_get_ssh1_cipher(void)
d257 3
a259 2
void
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks, u_int32_t *packets)
d261 1
a261 6
	struct packet_state *state;

	state = (mode == MODE_IN) ? &p_read : &p_send;
	*seqnr = state->seqnr;
	*blocks = state->blocks;
	*packets = state->packets;
d265 1
a265 1
packet_set_state(int mode, u_int32_t seqnr, u_int64_t blocks, u_int32_t packets)
d267 6
a272 6
	struct packet_state *state;

	state = (mode == MODE_IN) ? &p_read : &p_send;
	state->seqnr = seqnr;
	state->blocks = blocks;
	state->packets = packets;
a559 1
	u_int64_t *max_blocks;
a566 2
		p_send.packets = p_send.blocks = 0;
		max_blocks = &max_blocks_out;
a569 2
		p_read.packets = p_read.blocks = 0;
		max_blocks = &max_blocks_in;
a607 10
	/*
	 * The 2^(blocksize*2) limit is too expensive for 3DES,
	 * blowfish, etc, so enforce a 1GB limit for small blocksizes.
	 */
	if (enc->block_size >= 16)
		*max_blocks = (u_int64_t)1 << (enc->block_size*2);
	else
		*max_blocks = ((u_int64_t)1 << 30) / enc->block_size;
	if (rekey_limit)
		*max_blocks = MIN(*max_blocks, rekey_limit / enc->block_size);
d614 1
a614 1
packet_send2_wrapped(void)
d696 1
a696 1
		macbuf = mac_compute(mac, p_send.seqnr,
d699 1
a699 1
		DBG(debug("done calc MAC out #%d", p_send.seqnr));
d713 2
a714 6
	if (++p_send.seqnr == 0)
		logit("outgoing seqnr wraps around");
	if (++p_send.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	p_send.blocks += (packet_length + 4) / block_size;
a720 46
static void
packet_send2(void)
{
	static int rekeying = 0;
	struct packet *p;
	u_char type, *cp;

	cp = buffer_ptr(&outgoing_packet);
	type = cp[5];

	/* during rekeying we can only send key exchange messages */
	if (rekeying) {
		if (!((type >= SSH2_MSG_TRANSPORT_MIN) &&
		    (type <= SSH2_MSG_TRANSPORT_MAX))) {
			debug("enqueue packet: %u", type);
			p = xmalloc(sizeof(*p));
			p->type = type;
			memcpy(&p->payload, &outgoing_packet, sizeof(Buffer));
			buffer_init(&outgoing_packet);
			TAILQ_INSERT_TAIL(&outgoing, p, next);
			return;
		}
	}

	/* rekeying starts with sending KEXINIT */
	if (type == SSH2_MSG_KEXINIT)
		rekeying = 1;

	packet_send2_wrapped();

	/* after a NEWKEYS message we can send the complete queue */
	if (type == SSH2_MSG_NEWKEYS) {
		rekeying = 0;
		while ((p = TAILQ_FIRST(&outgoing))) {
			type = p->type;
			debug("dequeue packet: %u", type);
			buffer_free(&outgoing_packet);
			memcpy(&outgoing_packet, &p->payload,
			    sizeof(Buffer));
			TAILQ_REMOVE(&outgoing, p, next);
			xfree(p);
			packet_send2_wrapped();
		}
	}
}

d782 1
a782 1
			logit("Connection closed by %.200s", get_remote_ipaddr());
d964 1
a964 1
		macbuf = mac_compute(mac, p_read.seqnr,
d969 1
a969 1
		DBG(debug("MAC #%d ok", p_read.seqnr));
d973 3
a975 7
		*seqnr_p = p_read.seqnr;
	if (++p_read.seqnr == 0)
		logit("incoming seqnr wraps around");
	if (++p_read.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	p_read.blocks += (packet_length + 4) / block_size;
d1040 1
a1040 1
				logit("Received disconnect from %s: %u: %.400s",
d1066 1
a1066 1
				logit("Received disconnect from %s: %.400s",
d1225 1
a1225 1
	logit("Disconnecting: %.100s", buf);
d1356 2
a1357 2
u_int
packet_set_maxsize(u_int s)
d1362 1
a1362 1
		logit("packet_set_maxsize: called twice: old %d new %d",
d1367 1
a1367 1
		logit("packet_set_maxsize: bad size %d", s);
a1407 19
}

#define MAX_PACKETS	(1<<31)
int
packet_need_rekeying(void)
{
	if (datafellows & SSH_BUG_NOREKEY)
		return 0;
	return
	    (p_send.packets > MAX_PACKETS) ||
	    (p_read.packets > MAX_PACKETS) ||
	    (max_blocks_out && (p_send.blocks > max_blocks_out)) ||
	    (max_blocks_in  && (p_read.blocks > max_blocks_in));
}

void
packet_set_rekey_limit(u_int32_t bytes)
{
	rekey_limit = bytes;
@


1.102.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.112 2003/09/23 20:17:11 markus Exp $");
d168 2
d868 1
a868 1
			cleanup_exit(255);
a1017 1
#ifdef PACKET_DEBUG
a1018 1
#endif
d1132 1
a1132 1
				cleanup_exit(255);
d1157 1
a1157 1
				cleanup_exit(255);
d1334 2
a1335 1
	cleanup_exit(255);
@


1.101
log
@move tos handling to packet_set_tos; ok provos/henning/deraadt
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.100 2002/11/21 22:45:31 markus Exp $");
d1312 1
a1312 1
void
@


1.100
log
@debug->debug2, unify debug messages
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.99 2002/11/04 10:09:51 markus Exp $");
d1312 14
a1331 2
	int lowdelay = IPTOS_LOWDELAY;
	int throughput = IPTOS_THROUGHPUT;
d1343 1
a1343 14
	/*
	 * IPTOS_LOWDELAY and IPTOS_THROUGHPUT are IPv4 only
	 */
	if (interactive) {
		/*
		 * Set IP options for an interactive connection.  Use
		 * IPTOS_LOWDELAY and TCP_NODELAY.
		 */
		if (packet_connection_is_ipv4()) {
			if (setsockopt(connection_in, IPPROTO_IP, IP_TOS,
			    &lowdelay, sizeof(lowdelay)) < 0)
				error("setsockopt IPTOS_LOWDELAY: %.100s",
				    strerror(errno));
		}
d1345 1
a1345 9
	} else if (packet_connection_is_ipv4()) {
		/*
		 * Set IP options for a non-interactive connection.  Use
		 * IPTOS_THROUGHPUT.
		 */
		if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, &throughput,
		    sizeof(throughput)) < 0)
			error("setsockopt IPTOS_THROUGHPUT: %.100s", strerror(errno));
	}
@


1.99
log
@log before send disconnect; ok djm@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.98 2002/10/23 10:32:13 markus Exp $");
d562 1
a562 1
	debug("newkeys: mode %d", mode);
d572 1
a572 1
		debug("newkeys: rekeying");
@


1.98
log
@use %u for u_int
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.97 2002/07/04 08:12:15 deraadt Exp $");
d1224 3
a1245 2
	/* Display the error locally and exit. */
	log("Disconnecting: %.100s", buf);
@


1.97
log
@blah blah minor nothing as i read and re-read and re-read...
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.96 2002/06/23 21:10:02 deraadt Exp $");
d838 1
a838 1
		packet_disconnect("Bad packet length %d.", len);
d934 1
a934 1
			packet_disconnect("Bad packet length %d.", packet_length);
d936 1
a936 1
		DBG(debug("input: packet len %d", packet_length+4));
@


1.97.2.1
log
@Update to OpenSSH 3.6
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.102 2002/12/10 19:47:14 markus Exp $");
d562 1
a562 1
	debug2("set_newkeys: mode %d", mode);
d572 1
a572 1
		debug("set_newkeys: rekeying");
d838 1
a838 1
		packet_disconnect("Bad packet length %u.", len);
d934 1
a934 1
			packet_disconnect("Bad packet length %u.", packet_length);
d936 1
a936 1
		DBG(debug("input: packet len %u", packet_length+4));
a1223 3
	/* Display the error locally */
	log("Disconnecting: %.100s", buf);

d1243 2
a1310 14
static void
packet_set_tos(int interactive)
{
	int tos = interactive ? IPTOS_LOWDELAY : IPTOS_THROUGHPUT;

	if (!packet_connection_is_on_socket() ||
	    !packet_connection_is_ipv4())
		return;
	if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, &tos,
	    sizeof(tos)) < 0)
		error("setsockopt IP_TOS %d: %.100s:",
		    tos, strerror(errno));
}

d1317 2
d1330 14
a1343 1
	if (interactive)
d1345 9
a1353 1
	packet_set_tos(interactive);
@


1.97.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d40 1
a40 3
RCSID("$OpenBSD: packet.c,v 1.109 2003/07/10 14:42:28 markus Exp $");

#include <sys/queue.h>
d109 1
a109 1
u_int max_packet_size = 32768;
d119 2
a120 8
static struct packet_state {
	u_int32_t seqnr;
	u_int32_t packets;
	u_int64_t blocks;
} p_read, p_send;

static u_int64_t max_blocks_in, max_blocks_out;
static u_int32_t rekey_limit;
a128 7
struct packet {
	TAILQ_ENTRY(packet) next;
	u_char type;
	Buffer payload;
};
TAILQ_HEAD(, packet) outgoing;

a150 1
		TAILQ_INIT(&outgoing);
d252 1
a252 1
packet_get_ssh1_cipher(void)
d257 3
a259 2
void
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks, u_int32_t *packets)
d261 1
a261 6
	struct packet_state *state;

	state = (mode == MODE_IN) ? &p_read : &p_send;
	*seqnr = state->seqnr;
	*blocks = state->blocks;
	*packets = state->packets;
d265 1
a265 1
packet_set_state(int mode, u_int32_t seqnr, u_int64_t blocks, u_int32_t packets)
d267 6
a272 6
	struct packet_state *state;

	state = (mode == MODE_IN) ? &p_read : &p_send;
	state->seqnr = seqnr;
	state->blocks = blocks;
	state->packets = packets;
a559 1
	u_int64_t *max_blocks;
a566 2
		p_send.packets = p_send.blocks = 0;
		max_blocks = &max_blocks_out;
a569 2
		p_read.packets = p_read.blocks = 0;
		max_blocks = &max_blocks_in;
a607 10
	/*
	 * The 2^(blocksize*2) limit is too expensive for 3DES,
	 * blowfish, etc, so enforce a 1GB limit for small blocksizes.
	 */
	if (enc->block_size >= 16)
		*max_blocks = (u_int64_t)1 << (enc->block_size*2);
	else
		*max_blocks = ((u_int64_t)1 << 30) / enc->block_size;
	if (rekey_limit)
		*max_blocks = MIN(*max_blocks, rekey_limit / enc->block_size);
d614 1
a614 1
packet_send2_wrapped(void)
d696 1
a696 1
		macbuf = mac_compute(mac, p_send.seqnr,
d699 1
a699 1
		DBG(debug("done calc MAC out #%d", p_send.seqnr));
d713 2
a714 6
	if (++p_send.seqnr == 0)
		logit("outgoing seqnr wraps around");
	if (++p_send.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	p_send.blocks += (packet_length + 4) / block_size;
a720 46
static void
packet_send2(void)
{
	static int rekeying = 0;
	struct packet *p;
	u_char type, *cp;

	cp = buffer_ptr(&outgoing_packet);
	type = cp[5];

	/* during rekeying we can only send key exchange messages */
	if (rekeying) {
		if (!((type >= SSH2_MSG_TRANSPORT_MIN) &&
		    (type <= SSH2_MSG_TRANSPORT_MAX))) {
			debug("enqueue packet: %u", type);
			p = xmalloc(sizeof(*p));
			p->type = type;
			memcpy(&p->payload, &outgoing_packet, sizeof(Buffer));
			buffer_init(&outgoing_packet);
			TAILQ_INSERT_TAIL(&outgoing, p, next);
			return;
		}
	}

	/* rekeying starts with sending KEXINIT */
	if (type == SSH2_MSG_KEXINIT)
		rekeying = 1;

	packet_send2_wrapped();

	/* after a NEWKEYS message we can send the complete queue */
	if (type == SSH2_MSG_NEWKEYS) {
		rekeying = 0;
		while ((p = TAILQ_FIRST(&outgoing))) {
			type = p->type;
			debug("dequeue packet: %u", type);
			buffer_free(&outgoing_packet);
			memcpy(&outgoing_packet, &p->payload,
			    sizeof(Buffer));
			TAILQ_REMOVE(&outgoing, p, next);
			xfree(p);
			packet_send2_wrapped();
		}
	}
}

d782 1
a782 1
			logit("Connection closed by %.200s", get_remote_ipaddr());
d964 1
a964 1
		macbuf = mac_compute(mac, p_read.seqnr,
d969 1
a969 1
		DBG(debug("MAC #%d ok", p_read.seqnr));
d973 3
a975 7
		*seqnr_p = p_read.seqnr;
	if (++p_read.seqnr == 0)
		logit("incoming seqnr wraps around");
	if (++p_read.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	p_read.blocks += (packet_length + 4) / block_size;
d1040 1
a1040 1
				logit("Received disconnect from %s: %u: %.400s",
d1066 1
a1066 1
				logit("Received disconnect from %s: %.400s",
d1225 1
a1225 1
	logit("Disconnecting: %.100s", buf);
d1356 2
a1357 2
u_int
packet_set_maxsize(u_int s)
d1362 1
a1362 1
		logit("packet_set_maxsize: called twice: old %d new %d",
d1367 1
a1367 1
		logit("packet_set_maxsize: bad size %d", s);
a1407 19
}

#define MAX_PACKETS	(1<<31)
int
packet_need_rekeying(void)
{
	if (datafellows & SSH_BUG_NOREKEY)
		return 0;
	return
	    (p_send.packets > MAX_PACKETS) ||
	    (p_read.packets > MAX_PACKETS) ||
	    (max_blocks_out && (p_send.blocks > max_blocks_out)) ||
	    (max_blocks_in  && (p_read.blocks > max_blocks_in));
}

void
packet_set_rekey_limit(u_int32_t bytes)
{
	rekey_limit = bytes;
@


1.96
log
@packet_get_int() returns unsigned for reason & seqnr
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.95 2002/06/19 18:01:00 markus Exp $");
d137 1
d401 1
d443 1
d995 2
a996 1
		DBG(debug("input: len after de-compress %d", buffer_len(&incoming_packet)));
d1104 1
d1138 1
d1211 1
d1254 1
d1368 1
@


1.95
log
@make the monitor sync the transfer ssh1 session key;
transfer keycontext only for RC4 (this is still depends on EVP
implementation details and is broken).
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.94 2002/06/04 23:02:06 markus Exp $");
d1013 1
a1013 1
	int reason, seqnr;
d1036 2
a1037 2
				log("Received disconnect from %s: %d: %.400s", get_remote_ipaddr(),
					reason, msg);
d1043 2
a1044 1
				debug("Received SSH2_MSG_UNIMPLEMENTED for %d", seqnr);
d1062 2
a1063 2
				log("Received disconnect from %s: %.400s", get_remote_ipaddr(),
					msg);
@


1.94
log
@remove __FUNCTION__
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.93 2002/03/24 16:01:13 markus Exp $");
d63 1
d122 4
d394 1
d404 4
d410 9
@


1.93
log
@debug->debug3 for extra padding
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.92 2002/03/19 10:49:35 markus Exp $");
d266 1
a266 1
		fatal("%s: bad mode %d", __FUNCTION__, mode);
@


1.93.2.1
log
@Pull in OpenSSH-3.4
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.96 2002/06/23 21:10:02 deraadt Exp $");
a62 1
#include "ssh.h"
a120 4
/* Session key for protocol v1 */
static u_char ssh1_key[SSH_SESSION_KEY_LENGTH];
static u_int ssh1_keylen;

d266 1
a266 1
		fatal("packet_set_seqnr: bad mode %d", mode);
a388 1

a397 4
	if (keylen > SSH_SESSION_KEY_LENGTH)
		fatal("packet_set_encryption_key: keylen too big: %d", keylen);
	memcpy(ssh1_key, key, keylen);
	ssh1_keylen = keylen;
a401 9
u_int
packet_get_encryption_key(u_char *key)
{
	if (key == NULL)
		return (ssh1_keylen);
	memcpy(key, ssh1_key, ssh1_keylen);
	return (ssh1_keylen);
}

d994 1
a994 1
	u_int reason, seqnr;
d1017 2
a1018 2
				log("Received disconnect from %s: %u: %.400s",
				    get_remote_ipaddr(), reason, msg);
d1024 1
a1024 2
				debug("Received SSH2_MSG_UNIMPLEMENTED for %u",
				    seqnr);
d1042 2
a1043 2
				log("Received disconnect from %s: %.400s",
				    get_remote_ipaddr(), msg);
@


1.93.2.2
log
@Update to OpenSSH 3.5
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.97 2002/07/04 08:12:15 deraadt Exp $");
a136 1

a399 1

a440 1

d992 1
a992 2
		DBG(debug("input: len after de-compress %d",
		    buffer_len(&incoming_packet)));
a1099 1

a1132 1

a1204 1

a1246 1

a1359 1

@


1.93.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.104 2003/04/01 10:22:21 markus Exp $");
d562 1
a562 1
	debug2("set_newkeys: mode %d", mode);
d572 1
a572 1
		debug("set_newkeys: rekeying");
d838 1
a838 1
		packet_disconnect("Bad packet length %u.", len);
d934 1
a934 1
			packet_disconnect("Bad packet length %u.", packet_length);
d936 1
a936 1
		DBG(debug("input: packet len %u", packet_length+4));
a1223 3
	/* Display the error locally */
	log("Disconnecting: %.100s", buf);

d1243 2
a1310 14
static void
packet_set_tos(int interactive)
{
	int tos = interactive ? IPTOS_LOWDELAY : IPTOS_THROUGHPUT;

	if (!packet_connection_is_on_socket() ||
	    !packet_connection_is_ipv4())
		return;
	if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, &tos,
	    sizeof(tos)) < 0)
		error("setsockopt IP_TOS %d: %.100s:",
		    tos, strerror(errno));
}

d1317 2
d1330 14
a1343 1
	if (interactive)
d1345 9
a1353 1
	packet_set_tos(interactive);
@


1.92
log
@KNF whitespace
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.91 2002/03/18 17:16:38 markus Exp $");
d647 1
a647 1
		debug("packet_send2: adding %d (len %d padlen %d extra_pad %d)",
@


1.91
log
@export/import cipher state, iv and ssh2 seqnr; needed by ssh-privsep
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.5 2002/03/12 18:03:57 markus Exp $");
d176 1
a176 1
/* 
d199 1
a199 1
	
d212 1
a212 1
	
@


1.90
log
@remove unneeded casts in [gs]etsockopt(); ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.89 2002/02/24 16:58:32 markus Exp $");
d89 1
a89 1
static Buffer input;
d92 1
a92 1
static Buffer output;
d118 2
d176 93
d531 1
a531 1
static void
d575 3
a577 2
	memset(enc->iv,  0, enc->block_size);
	memset(enc->key, 0, enc->key_len);
a593 1
	static u_int32_t seqnr = 0;
d674 1
a674 1
		macbuf = mac_compute(mac, seqnr,
d677 1
a677 1
		DBG(debug("done calc MAC out #%d", seqnr));
d691 1
a691 1
	if (++seqnr == 0)
a880 1
	static u_int32_t seqnr = 0;
d942 1
a942 1
		macbuf = mac_compute(mac, seqnr,
d947 1
a947 1
		DBG(debug("MAC #%d ok", seqnr));
d951 2
a952 2
		*seqnr_p = seqnr;
	if (++seqnr == 0)
@


1.89
log
@make 'cp' unsigned and merge with 'ucp'; ok stevesk@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.88 2002/02/14 23:41:01 markus Exp $");
d1218 1
a1218 1
			    (void *) &lowdelay, sizeof(lowdelay)) < 0)
d1228 1
a1228 1
		if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, (void *) &throughput,
@


1.88
log
@hide some more implementation details of cipher.[ch] and prepares for move
to EVP, ok deraadt@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.87 2002/01/24 21:13:23 stevesk Exp $");
d368 1
a368 1
	char buf[8], *cp;
d499 1
a499 1
	u_char type, *ucp, *macbuf = NULL;
a500 1
	char *cp;
d516 2
a517 2
	ucp = buffer_ptr(&outgoing_packet);
	type = ucp[5];
d572 3
a574 3
	ucp = buffer_ptr(&outgoing_packet);
	PUT_32BIT(ucp, packet_length);
	ucp[4] = padlen;
d711 1
a711 2
	u_char *ucp, type;
	char *cp;
d718 2
a719 2
	ucp = buffer_ptr(&input);
	len = GET_32BIT(ucp);
d766 2
a767 2
	ucp = (u_char *)buffer_ptr(&incoming_packet) + len - 4;
	stored_checksum = GET_32BIT(ucp);
d789 1
a789 2
	u_char *macbuf, *ucp, type;
	char *cp;
d814 2
a815 2
		ucp = buffer_ptr(&incoming_packet);
		packet_length = GET_32BIT(ucp);
d863 1
a863 2
	cp += 4;
	padlen = (u_char) *cp;
@


1.87
log
@need misc.h for set_nodelay()
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.86 2002/01/24 21:09:25 stevesk Exp $");
d134 2
a135 2
	cipher_init(&send_context, none, "", 0, NULL, 0);
	cipher_init(&receive_context, none, "", 0, NULL, 0);
d244 2
d303 2
a304 2
	cipher_init(&receive_context, cipher, key, keylen, NULL, 0);
	cipher_init(&send_context, cipher, key, keylen, NULL, 0);
d393 1
a393 1
	if (send_context.cipher->number != SSH_CIPHER_NONE) {
d419 1
a419 1
	cipher_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d443 1
d447 7
a453 1
	cc = (mode == MODE_OUT) ? &send_context : &receive_context;
d456 1
a456 2
		/* todo: free old keys, reset compression/cipher-ctxt; */
		memset(cc, 0, sizeof(*cc));
d478 4
a481 4
	cipher_init(cc, enc->cipher, enc->key, enc->cipher->key_len,
	    enc->iv, enc->cipher->block_size);
	memset(enc->iv,  0, enc->cipher->block_size);
	memset(enc->key, 0, enc->cipher->key_len);
d515 1
a515 1
	block_size = enc ? enc->cipher->block_size : 8;
d559 1
a559 1
	if (enc && enc->cipher->number != SSH_CIPHER_NONE) {
d587 1
a587 1
	cipher_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d740 1
a740 1
	if (receive_context.cipher->number != SSH_CIPHER_NONE &&
d747 1
a747 1
	cipher_decrypt(&receive_context, cp, buffer_ptr(&input), padded_len);
d804 1
a804 1
	block_size = enc ? enc->cipher->block_size : 8;
d815 1
a815 1
		cipher_decrypt(&receive_context, cp, buffer_ptr(&input),
d844 1
a844 1
	cipher_decrypt(&receive_context, cp, buffer_ptr(&input), need);
@


1.86
log
@add set_nodelay() to set TCP_NODELAY on a socket (prep for nagle tuning).
no nagle changes just yet; ok djm@@ markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.85 2002/01/18 18:14:17 stevesk Exp $");
d62 1
@


1.85
log
@unneeded cast cleanup; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.84 2002/01/11 10:31:05 markus Exp $");
a1191 1
	int on = 1;
d1217 1
a1217 3
		if (setsockopt(connection_in, IPPROTO_TCP, TCP_NODELAY, (void *) &on,
		    sizeof(on)) < 0)
			error("setsockopt TCP_NODELAY: %.100s", strerror(errno));
@


1.84
log
@handle received SSH2_MSG_UNIMPLEMENTED messages; ok djm@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.83 2001/12/29 21:56:01 stevesk Exp $");
d133 2
a134 2
	cipher_init(&send_context, none, (u_char *) "", 0, NULL, 0);
	cipher_init(&receive_context, none, (u_char *) "", 0, NULL, 0);
@


1.83
log
@remove unneeded casts and some char->u_char cleanup; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.82 2001/12/28 14:50:54 markus Exp $");
d895 1
a895 1
	int reason;
d922 4
@


1.82
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.81 2001/12/28 14:13:13 markus Exp $");
d402 1
a402 1
	checksum = ssh_crc32((u_char *) buffer_ptr(&outgoing_packet),
d508 1
a508 1
	ucp = (u_char *) buffer_ptr(&outgoing_packet);
d564 1
a564 1
	ucp = (u_char *)buffer_ptr(&outgoing_packet);
d572 1
a572 1
		    (u_char *) buffer_ptr(&outgoing_packet),
d711 1
a711 1
	ucp = (u_char *) buffer_ptr(&input);
d748 1
a748 1
	checksum = ssh_crc32((u_char *) buffer_ptr(&incoming_packet),
d759 1
a759 1
	ucp = (u_char *) buffer_ptr(&incoming_packet) + len - 4;
d808 1
a808 1
		ucp = (u_char *) buffer_ptr(&incoming_packet);
d843 1
a843 1
		    (u_char *) buffer_ptr(&incoming_packet),
@


1.81
log
@buffer_get_bignum: int -> void
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.80 2001/12/28 13:57:33 markus Exp $");
d613 1
a613 1
packet_read_seqnr(int *payload_len_ptr, u_int32_t *seqnr_p)
d629 1
a629 1
		type = packet_read_poll_seqnr(payload_len_ptr, seqnr_p);
d669 1
a669 1
packet_read(int *payload_len_ptr)
d671 1
a671 1
	return packet_read_seqnr(payload_len_ptr, NULL);
d680 1
a680 1
packet_read_expect(int *payload_len_ptr, int expected_type)
d684 1
a684 1
	type = packet_read(payload_len_ptr);
a696 6
 *
 * The returned payload_len does include space consumed by:
 * 	Packet length
 * 	Padding
 * 	Packet type
 * 	Check bytes
d700 1
a700 1
packet_read_poll1(int *payload_len_ptr)
a772 1
	*payload_len_ptr = buffer_len(&incoming_packet);
d777 1
a777 1
packet_read_poll2(int *payload_len_ptr, u_int32_t *seqnr_p)
a882 1
	*payload_len_ptr = buffer_len(&incoming_packet);
d893 1
a893 1
packet_read_poll_seqnr(int *payload_len_ptr, u_int32_t *seqnr_p)
d901 1
a901 1
			type = packet_read_poll2(payload_len_ptr, seqnr_p);
d928 1
a928 1
			type = packet_read_poll1(payload_len_ptr);
d955 1
a955 1
packet_read_poll(int *payload_len_ptr)
d957 1
a957 1
	return packet_read_poll_seqnr(payload_len_ptr, NULL);
@


1.80
log
@packet_get_bignum* no longer returns a size
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.79 2001/12/28 12:14:27 markus Exp $");
d1005 1
a1005 1
	(void)buffer_get_bignum(&incoming_packet, value);
d1011 1
a1011 1
	(void)buffer_get_bignum2(&incoming_packet, value);
@


1.79
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.78 2001/12/27 20:39:58 markus Exp $");
d1003 1
a1003 1
packet_get_bignum(BIGNUM * value, int *length_ptr)
d1005 1
a1005 1
	*length_ptr = buffer_get_bignum(&incoming_packet, value);
d1009 1
a1009 1
packet_get_bignum2(BIGNUM * value, int *length_ptr)
d1011 1
a1011 1
	*length_ptr = buffer_get_bignum2(&incoming_packet, value);
@


1.78
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.77 2001/12/20 22:50:24 djm Exp $");
d635 1
a635 1
			packet_done();
@


1.77
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.76 2001/12/19 17:16:13 stevesk Exp $");
d635 1
a635 1
			packet_integrity_check(*payload_len_ptr, 0, type);
@


1.76
log
@change the buffer/packet interface to use void* vs. char*; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.75 2001/12/19 07:18:56 deraadt Exp $");
d613 1
a613 1
packet_read(int *payload_len_ptr)
d629 1
a629 1
		type = packet_read_poll(payload_len_ptr);
d668 6
d762 1
a762 1
		packet_disconnect("packet_read_poll: len %d != buffer_len %d.",
d784 1
a784 1
packet_read_poll2(int *payload_len_ptr)
d857 2
d901 1
a901 1
packet_read_poll(int *payload_len_ptr)
d909 1
a909 1
			type = packet_read_poll2(payload_len_ptr);
d960 6
@


1.75
log
@basic KNF done while i was looking for something else
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.74 2001/12/05 10:06:12 deraadt Exp $");
d332 1
a332 1
packet_put_string(const char *buf, u_int len)
d342 1
a342 1
packet_put_raw(const char *buf, u_int len)
d415 1
a415 1
	buffer_append_space(&output, &cp, buffer_len(&outgoing_packet));
d549 1
a549 1
	buffer_append_space(&outgoing_packet, &cp, padlen);
d577 1
a577 1
	buffer_append_space(&output, &cp, buffer_len(&outgoing_packet));
d737 1
a737 1
	buffer_append_space(&incoming_packet, &cp, padded_len);
d806 1
a806 1
		buffer_append_space(&incoming_packet, &cp, block_size);
d835 1
a835 1
	buffer_append_space(&incoming_packet, &cp, need);
d855 2
a856 1
	cp = buffer_ptr(&incoming_packet) + 4;
d1000 1
a1000 1
char *
d1022 1
a1022 1
char *
@


1.74
log
@minor KNF
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.73 2001/12/05 03:56:39 itojun Exp $");
d383 1
a383 1
			      buffer_len(&compression_buffer));
d417 1
a417 1
		       buffer_len(&outgoing_packet));
d1274 1
a1274 1
	for(i = 0; i < nbytes; i++) {
@


1.73
log
@make it compile with more strict prototype checking
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.72 2001/11/10 13:37:20 markus Exp $");
d903 1
a903 1
			switch(type) {
d928 1
a928 1
			switch(type) {
@


1.72
log
@remove extra debug()
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.71 2001/11/07 16:03:17 markus Exp $");
d150 1
a150 1
packet_connection_is_on_socket()
d176 1
a176 1
packet_connection_is_ipv4()
d192 1
a192 1
packet_set_nonblocking()
d207 1
a207 1
packet_get_connection_in()
d215 1
a215 1
packet_get_connection_out()
d223 1
a223 1
packet_close()
d256 1
a256 1
packet_get_protocol_flags()
d597 1
a597 1
packet_send()
d967 1
a967 1
packet_get_char()
d977 1
a977 1
packet_get_int()
d1114 1
a1114 1
packet_write_poll()
d1135 1
a1135 1
packet_write_wait()
d1157 1
a1157 1
packet_have_data_to_write()
d1165 1
a1165 1
packet_not_very_much_data_to_write()
d1224 1
a1224 1
packet_is_interactive()
@


1.71
log
@pad using the padding field from the ssh2 packet instead of sending
extra ignore messages. tested against several other ssh servers.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.70 2001/09/27 11:59:37 markus Exp $");
a1124 1
debug("packet_write_poll: sent %d bytes", len);
@


1.70
log
@missing called=1; chombier@@mac.com
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.69 2001/06/25 08:25:38 markus Exp $");
d118 3
d491 1
d494 1
a494 1
	u_int i, padlen, len;
d540 9
d1125 1
d1249 7
a1266 35
/* size of current + ignore message should be n*sumlen bytes (w/o mac) */
void
packet_inject_ignore(int sumlen)
{
	int blocksize, padlen, have, need, nb, mini, nbytes;
	Enc *enc = NULL;

	if (compat20 == 0)
		return;

	have = buffer_len(&outgoing_packet);
	debug2("packet_inject_ignore: current %d", have);
	if (newkeys[MODE_OUT] != NULL)
		enc  = &newkeys[MODE_OUT]->enc;
	blocksize = enc ? enc->cipher->block_size : 8;
	padlen = blocksize - (have % blocksize);
	if (padlen < 4)
		padlen += blocksize;
	have += padlen;
	have /= blocksize;	/* # of blocks for current message */

	nb   = roundup(sumlen,  blocksize) / blocksize;	/* blocks for both */
	mini = roundup(5+1+4+4, blocksize) / blocksize; /* minsize ignore msg */
	need = nb - (have % nb);			/* blocks for ignore */
	if (need <= mini)
		need += nb;
	nbytes = (need - mini) * blocksize;	/* size of ignore payload */
	debug2("packet_inject_ignore: block %d have %d nb %d mini %d need %d",
	    blocksize, have, nb, mini, need);

	/* enqueue current message and append a ignore message */
	packet_send();
	packet_send_ignore(nbytes);
}

@


1.70.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.72 2001/11/10 13:37:20 markus Exp $");
a117 3
/* roundup current message to extra_pad bytes */
static u_char extra_pad = 0;

a487 1
	u_char padlen, pad;
d490 1
a490 1
	u_int i, len;
a535 9
	if (extra_pad) {
		/* will wrap if extra_pad+padlen > 255 */
		extra_pad  = roundup(extra_pad, block_size);
		pad = extra_pad - ((len + padlen) % extra_pad);
		debug("packet_send2: adding %d (len %d padlen %d extra_pad %d)",
		    pad, len, padlen, extra_pad);
		padlen += pad;
		extra_pad = 0;
	}
a1234 7
/* roundup current message to pad bytes */
void
packet_add_padding(u_char pad)
{
	extra_pad = pad;
}

d1246 35
@


1.70.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.90 2002/02/27 21:23:13 stevesk Exp $");
a61 1
#include "misc.h"
d133 2
a134 2
	cipher_init(&send_context, none, "", 0, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, none, "", 0, NULL, 0, CIPHER_DECRYPT);
d150 1
a150 1
packet_connection_is_on_socket(void)
d176 1
a176 1
packet_connection_is_ipv4(void)
d192 1
a192 1
packet_set_nonblocking(void)
d207 1
a207 1
packet_get_connection_in(void)
d215 1
a215 1
packet_get_connection_out(void)
d223 1
a223 1
packet_close(void)
a242 2
	cipher_cleanup(&send_context);
	cipher_cleanup(&receive_context);
d256 1
a256 1
packet_get_protocol_flags(void)
d300 2
a301 2
	cipher_init(&send_context, cipher, key, keylen, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, cipher, key, keylen, NULL, 0, CIPHER_DECRYPT);
d332 1
a332 1
packet_put_string(const void *buf, u_int len)
d342 1
a342 1
packet_put_raw(const void *buf, u_int len)
d365 1
a365 1
	u_char buf[8], *cp;
d383 1
a383 1
		    buffer_len(&compression_buffer));
d390 1
a390 1
	if (!send_context.plaintext) {
d402 1
a402 1
	checksum = ssh_crc32(buffer_ptr(&outgoing_packet),
d415 3
a417 3
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
a439 1
	int encrypt;
d443 1
a443 7
	if (mode == MODE_OUT) {
		cc = &send_context;
		encrypt = CIPHER_ENCRYPT;
	} else {
		cc = &receive_context;
		encrypt = CIPHER_DECRYPT;
	}
d446 2
a447 1
		cipher_cleanup(cc);
d469 4
a472 4
	cipher_init(cc, enc->cipher, enc->key, enc->key_len,
	    enc->iv, enc->block_size, encrypt);
	memset(enc->iv,  0, enc->block_size);
	memset(enc->key, 0, enc->key_len);
d490 1
a490 1
	u_char type, *cp, *macbuf = NULL;
d492 1
d506 1
a506 1
	block_size = enc ? enc->block_size : 8;
d508 2
a509 2
	cp = buffer_ptr(&outgoing_packet);
	type = cp[5];
d549 2
a550 2
	cp = buffer_append_space(&outgoing_packet, padlen);
	if (enc && !send_context.plaintext) {
d564 3
a566 3
	cp = buffer_ptr(&outgoing_packet);
	PUT_32BIT(cp, packet_length);
	cp[4] = padlen;
d572 1
a572 1
		    buffer_ptr(&outgoing_packet),
d577 2
a578 2
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d597 1
a597 1
packet_send(void)
d613 1
a613 1
packet_read_seqnr(u_int32_t *seqnr_p)
d629 1
a629 1
		type = packet_read_poll_seqnr(seqnr_p);
d635 1
a635 1
			packet_check_eom();
a667 6
int
packet_read(void)
{
	return packet_read_seqnr(NULL);
}

d674 1
a674 1
packet_read_expect(int expected_type)
d678 1
a678 1
	type = packet_read();
d691 6
d700 1
a700 1
packet_read_poll1(void)
d703 2
a704 1
	u_char *cp, type;
d711 2
a712 2
	cp = buffer_ptr(&input);
	len = GET_32BIT(cp);
d731 1
a731 1
	if (!receive_context.plaintext &&
d737 2
a738 2
	cp = buffer_append_space(&incoming_packet, padded_len);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), padded_len);
d748 1
a748 1
	checksum = ssh_crc32(buffer_ptr(&incoming_packet),
d756 1
a756 1
		packet_disconnect("packet_read_poll1: len %d != buffer_len %d.",
d759 2
a760 2
	cp = (u_char *)buffer_ptr(&incoming_packet) + len - 4;
	stored_checksum = GET_32BIT(cp);
d773 1
d778 1
a778 1
packet_read_poll2(u_int32_t *seqnr_p)
d783 2
a784 1
	u_char *macbuf, *cp, type;
d796 1
a796 1
	block_size = enc ? enc->block_size : 8;
d806 2
a807 2
		cp = buffer_append_space(&incoming_packet, block_size);
		cipher_crypt(&receive_context, cp, buffer_ptr(&input),
d809 2
a810 2
		cp = buffer_ptr(&incoming_packet);
		packet_length = GET_32BIT(cp);
d835 2
a836 2
	cp = buffer_append_space(&incoming_packet, need);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), need);
d844 1
a844 1
		    buffer_ptr(&incoming_packet),
a850 2
	if (seqnr_p != NULL)
		*seqnr_p = seqnr;
d855 2
a856 2
	cp = buffer_ptr(&incoming_packet);
	padlen = cp[4];
d881 1
d892 1
a892 1
packet_read_poll_seqnr(u_int32_t *seqnr_p)
d894 1
a894 1
	int reason, seqnr;
d900 1
a900 1
			type = packet_read_poll2(seqnr_p);
d903 1
a903 1
			switch (type) {
a921 4
			case SSH2_MSG_UNIMPLEMENTED:
				seqnr = packet_get_int();
				debug("Received SSH2_MSG_UNIMPLEMENTED for %d", seqnr);
				break;
d927 2
a928 2
			type = packet_read_poll1();
			switch (type) {
a952 6
int
packet_read_poll(void)
{
	return packet_read_poll_seqnr(NULL);
}

d967 1
a967 1
packet_get_char(void)
d977 1
a977 1
packet_get_int(void)
d988 1
a988 1
packet_get_bignum(BIGNUM * value)
d990 1
a990 1
	buffer_get_bignum(&incoming_packet, value);
d994 1
a994 1
packet_get_bignum2(BIGNUM * value)
d996 1
a996 1
	buffer_get_bignum2(&incoming_packet, value);
d999 1
a999 1
void *
d1021 1
a1021 1
void *
d1114 1
a1114 1
packet_write_poll(void)
d1135 1
a1135 1
packet_write_wait(void)
d1157 1
a1157 1
packet_have_data_to_write(void)
d1165 1
a1165 1
packet_not_very_much_data_to_write(void)
d1181 1
d1203 1
a1203 1
			    &lowdelay, sizeof(lowdelay)) < 0)
d1207 3
a1209 1
		set_nodelay(connection_in);
d1215 1
a1215 1
		if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, &throughput,
d1224 1
a1224 1
packet_is_interactive(void)
d1274 1
a1274 1
	for (i = 0; i < nbytes; i++) {
@


1.70.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.93 2002/03/24 16:01:13 markus Exp $");
d89 1
a89 1
Buffer input;
d92 1
a92 1
Buffer output;
a117 2
static u_int32_t read_seqnr = 0;
static u_int32_t send_seqnr = 0;
a173 93
/*
 * Exports an IV from the CipherContext required to export the key
 * state back from the unprivileged child to the privileged parent
 * process.
 */

void
packet_get_keyiv(int mode, u_char *iv, u_int len)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	cipher_get_keyiv(cc, iv, len);
}

int
packet_get_keycontext(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	return (cipher_get_keycontext(cc, dat));
}

void
packet_set_keycontext(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	cipher_set_keycontext(cc, dat);
}

int
packet_get_keyiv_len(int mode)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	return (cipher_get_keyiv_len(cc));
}
void
packet_set_iv(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	cipher_set_keyiv(cc, dat);
}
int
packet_get_ssh1_cipher()
{
	return (cipher_get_number(receive_context.cipher));
}


u_int32_t
packet_get_seqnr(int mode)
{
	return (mode == MODE_IN ? read_seqnr : send_seqnr);
}

void
packet_set_seqnr(int mode, u_int32_t seqnr)
{
	if (mode == MODE_IN)
		read_seqnr = seqnr;
	else if (mode == MODE_OUT)
		send_seqnr = seqnr;
	else
		fatal("%s: bad mode %d", __FUNCTION__, mode);
}

d436 1
a436 1
void
d480 2
a481 3
	/* Deleting the keys does not gain extra security */
	/* memset(enc->iv,  0, enc->block_size);
	   memset(enc->key, 0, enc->key_len); */
d498 1
d552 1
a552 1
		debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)",
d579 1
a579 1
		macbuf = mac_compute(mac, send_seqnr,
d582 1
a582 1
		DBG(debug("done calc MAC out #%d", send_seqnr));
d596 1
a596 1
	if (++send_seqnr == 0)
d786 1
d848 1
a848 1
		macbuf = mac_compute(mac, read_seqnr,
d853 1
a853 1
		DBG(debug("MAC #%d ok", read_seqnr));
d857 2
a858 2
		*seqnr_p = read_seqnr;
	if (++read_seqnr == 0)
@


1.70.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.70.2.3 2002/05/17 00:03:23 miod Exp $");
a62 1
#include "ssh.h"
a120 4
/* Session key for protocol v1 */
static u_char ssh1_key[SSH_SESSION_KEY_LENGTH];
static u_int ssh1_keylen;

d266 1
a266 1
		fatal("packet_set_seqnr: bad mode %d", mode);
a388 1

a397 4
	if (keylen > SSH_SESSION_KEY_LENGTH)
		fatal("packet_set_encryption_key: keylen too big: %d", keylen);
	memcpy(ssh1_key, key, keylen);
	ssh1_keylen = keylen;
a399 9
}

u_int
packet_get_encryption_key(u_char *key)
{
	if (key == NULL)
		return (ssh1_keylen);
	memcpy(key, ssh1_key, ssh1_keylen);
	return (ssh1_keylen);
@


1.70.2.5
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.70.2.4 2002/06/22 07:23:17 miod Exp $");
d1013 1
a1013 1
	u_int reason, seqnr;
d1036 2
a1037 2
				log("Received disconnect from %s: %u: %.400s",
				    get_remote_ipaddr(), reason, msg);
d1043 1
a1043 2
				debug("Received SSH2_MSG_UNIMPLEMENTED for %u",
				    seqnr);
d1061 2
a1062 2
				log("Received disconnect from %s: %.400s",
				    get_remote_ipaddr(), msg);
@


1.70.2.6
log
@Update to OpenSSH 3.5
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.97 2002/07/04 08:12:15 deraadt Exp $");
a136 1

a399 1

a440 1

d992 1
a992 2
		DBG(debug("input: len after de-compress %d",
		    buffer_len(&incoming_packet)));
a1099 1

a1132 1

a1204 1

a1246 1

a1359 1

@


1.69
log
@update copyright for 2001
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.68 2001/06/23 15:12:19 itojun Exp $");
d1229 1
@


1.68
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d16 1
a16 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.67 2001/06/20 13:56:39 markus Exp $");
@


1.67
log
@move from channel_stop_listening to channel_free_all,
call channel_free_all before calling waitpid() in serverloop.
fixes the utmp handling; report from Lutz.Jaenicke@@aet.TU-Cottbus.DE
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.66 2001/06/12 16:11:26 markus Exp $");
d263 2
a264 2
void
packet_init_compression()
d359 1
a359 1
void
d430 1
a430 1
void
d483 1
a483 1
void
d686 1
a686 1
int
d764 1
a764 1
int
@


1.66
log
@do not log() packet_set_maxsize
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.65 2001/06/07 20:23:04 markus Exp $");
d1088 1
a1088 1
	channel_stop_listening();
@


1.65
log
@use xxx_put_cstring()
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.64 2001/05/31 10:30:16 markus Exp $");
d1229 1
a1229 1
	log("packet_set_maxsize: setting to %d", s);
@


1.64
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.63 2001/05/30 12:55:11 markus Exp $");
d336 1
a336 1
	buffer_put_string(&outgoing_packet, str, strlen(str));
d1082 1
a1082 1
		packet_put_string(buf, strlen(buf));
@


1.63
log
@channel layer cleanup: merge header files and split .c files
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.62 2001/05/28 23:58:35 markus Exp $");
d51 1
a51 1
#include "channel.h"
@


1.62
log
@remove some lines, simplify.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.61 2001/04/05 10:42:51 markus Exp $");
d51 1
a51 1
#include "channels.h"
a247 1
	channel_set_options((protocol_flags & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) != 0);
@


1.61
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.59 2001/04/04 23:09:18 markus Exp $");
a77 6
/*
 * Cipher type.  This value is only used to determine whether to pad the
 * packets with zeroes or random data.
 */
static int cipher_type = SSH_CIPHER_NONE;

a114 3
/* True if SSH2 packet format is used */
int use_ssh2_packet_format = 0;

a117 8
void
packet_set_ssh2_format(void)
{
	DBG(debug("use_ssh2_packet_format"));
	use_ssh2_packet_format = 1;
	newkeys[MODE_IN] = newkeys[MODE_OUT] = NULL;
}

a129 1
	cipher_type = SSH_CIPHER_NONE;
d132 1
d276 1
a276 1
	if (packet_compression && !use_ssh2_packet_format)
a284 32
 * Encrypts the given number of bytes, copying from src to dest. bytes is
 * known to be a multiple of 8.
 */

void
packet_encrypt(CipherContext * cc, void *dest, void *src,
    u_int bytes)
{
	cipher_encrypt(cc, dest, src, bytes);
}

/*
 * Decrypts the given number of bytes, copying from src to dest. bytes is
 * known to be a multiple of 8.
 */

void
packet_decrypt(CipherContext *context, void *dest, void *src, u_int bytes)
{
	/*
	 * Cryptographic attack detector for ssh - Modifications for packet.c
	 * (C)1998 CORE-SDI, Buenos Aires Argentina Ariel Futoransky(futo@@core-sdi.com)
	 */
	if (!compat20 &&
	    context->cipher->number != SSH_CIPHER_NONE &&
	    detect_attack(src, bytes, NULL) == DEATTACK_DETECTED)
		packet_disconnect("crc32 compensation attack: network attack detected");

	cipher_decrypt(context, dest, src, bytes);
}

/*
a288 1

d302 1
a302 2
/* Starts constructing a packet to send. */

d304 1
a304 1
packet_start1(int type)
d306 2
a307 1
	char buf[9];
d309 4
d314 1
a314 16
	memset(buf, 0, 8);
	buf[8] = type;
	buffer_append(&outgoing_packet, buf, 9);
}

void
packet_start2(int type)
{
	char buf[4+1+1];

	buffer_clear(&outgoing_packet);
	memset(buf, 0, sizeof buf);
	/* buf[0..3] = payload_len; */
	/* buf[4] =    pad_len; */
	buf[5] = type & 0xff;
	buffer_append(&outgoing_packet, buf, sizeof buf);
d317 1
a317 12
void
packet_start(int type)
{
	DBG(debug("packet_start[%d]", type));
	if (use_ssh2_packet_format)
		packet_start2(type);
	else
		packet_start1(type);
}

/* Appends a character to the packet data. */

a323 3

/* Appends an integer to the packet data. */

a328 3

/* Appends a string to packet data. */

a338 1

a343 4


/* Appends an arbitrary precision integer to packet data. */

d388 1
a388 1
	if (cipher_type != SSH_CIPHER_NONE) {
d414 1
a414 1
	packet_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d488 1
a488 1
	u_char *macbuf = NULL;
a492 1
	int type;
d505 2
a506 2
	cp = buffer_ptr(&outgoing_packet);
	type = cp[5] & 0xff;
d552 3
a554 3
	cp = buffer_ptr(&outgoing_packet);
	PUT_32BIT(cp, packet_length);
	cp[4] = padlen & 0xff;
d566 1
a566 1
	packet_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d587 1
a587 1
	if (use_ssh2_packet_format)
d618 1
a618 1
		if (!use_ssh2_packet_format && (
d691 2
a692 2
	u_char *ucp;
	char buf[8], *cp;
d714 10
a723 1
	/* Copy data to incoming_packet. */
d726 2
a727 1
	packet_decrypt(&receive_context, cp, buffer_ptr(&input), padded_len);
a742 1

a752 1
	/* If using packet compression, decompress the packet. */
d760 1
a760 4
	/* Get packet type. */
	buffer_get(&incoming_packet, &buf[0], 1);

	/* Return length of payload (without type field). */
d762 1
a762 3

	/* Return type. */
	return (u_char) buf[0];
d771 1
a771 2
	u_char buf[8], *macbuf;
	u_char *ucp;
a772 1
	int type;
d795 1
a795 1
		packet_decrypt(&receive_context, cp, buffer_ptr(&input),
d824 1
a824 1
	packet_decrypt(&receive_context, cp, buffer_ptr(&input), need);
d844 1
a844 1
	padlen = *cp & 0xff;
d866 1
a866 9
	buffer_get(&incoming_packet, (char *)&buf[0], 1);
	*payload_len_ptr = buffer_len(&incoming_packet);

	/* reset for next packet */
	packet_length = 0;

	/* extract packet type */
	type = (u_char)buf[0];

d869 1
a869 1

d874 3
a876 1
	return (u_char)type;
d882 2
d885 1
d887 3
a889 7
		int type = use_ssh2_packet_format ?
		    packet_read_poll2(payload_len_ptr):
		    packet_read_poll1(payload_len_ptr);

		if(compat20) {
			int reason;
			if (type != 0)
d915 1
d932 1
a932 1
				if (type != 0)
d1253 1
a1253 1
	if (use_ssh2_packet_format == 0)
@


1.61.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d16 1
a16 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.69 2001/06/25 08:25:38 markus Exp $");
d78 6
d121 3
d127 8
d147 1
a149 1
	newkeys[MODE_IN] = newkeys[MODE_OUT] = NULL;
d265 1
d281 2
a282 2
static void
packet_init_compression(void)
d293 1
a293 1
	if (packet_compression && !compat20)
d302 32
d338 1
d352 2
a353 1
/* Start constructing a packet to send. */
d355 1
a355 1
packet_start(u_char type)
d357 1
a357 2
	u_char buf[9];
	int len;
d359 22
d382 4
a385 5
	len = compat20 ? 6 : 9;
	memset(buf, 0, len - 1);
	buf[len - 1] = type;
	buffer_clear(&outgoing_packet);
	buffer_append(&outgoing_packet, buf, len);
d388 2
a389 1
/* Append payload. */
d396 3
d404 3
d415 1
a415 1
	buffer_put_cstring(&outgoing_packet, str);
d417 1
d423 4
d443 1
a443 1
static void
d471 1
a471 1
	if (send_context.cipher->number != SSH_CIPHER_NONE) {
d497 1
a497 1
	cipher_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d514 1
a514 1
static void
d567 1
a567 1
static void
d571 1
a571 1
	u_char type, *ucp, *macbuf = NULL;
d576 1
d589 2
a590 2
	ucp = (u_char *) buffer_ptr(&outgoing_packet);
	type = ucp[5];
d636 3
a638 3
	ucp = (u_char *)buffer_ptr(&outgoing_packet);
	PUT_32BIT(ucp, packet_length);
	ucp[4] = padlen;
d650 1
a650 1
	cipher_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d671 1
a671 1
	if (compat20)
d702 1
a702 1
		if (!compat20 && (
d771 1
a771 1
static int
d775 2
a776 2
	u_char *ucp, type;
	char *cp;
d798 1
a798 10
	/*
	 * Cryptographic attack detector for ssh
	 * (C)1998 CORE-SDI, Buenos Aires Argentina
	 * Ariel Futoransky(futo@@core-sdi.com)
	 */
	if (receive_context.cipher->number != SSH_CIPHER_NONE &&
	    detect_attack(buffer_ptr(&input), padded_len, NULL) == DEATTACK_DETECTED)
		packet_disconnect("crc32 compensation attack: network attack detected");

	/* Decrypt data to incoming_packet. */
d801 1
a801 2
	cipher_decrypt(&receive_context, cp, buffer_ptr(&input), padded_len);

d817 1
d828 1
d836 4
a839 1
	type = buffer_get_char(&incoming_packet);
d841 3
a843 1
	return type;
d846 1
a846 1
static int
d852 2
a853 1
	u_char *macbuf, *ucp, type;
d855 1
d878 1
a878 1
		cipher_decrypt(&receive_context, cp, buffer_ptr(&input),
d907 1
a907 1
	cipher_decrypt(&receive_context, cp, buffer_ptr(&input), need);
d927 1
a927 1
	padlen = (u_char) *cp;
d949 9
a957 1
	type = buffer_get_char(&incoming_packet);
d960 1
a960 1
	*payload_len_ptr = buffer_len(&incoming_packet);
d965 1
a965 3
	/* reset for next packet */
	packet_length = 0;
	return type;
a970 2
	int reason;
	u_char type;
a971 1

d973 7
a979 3
		if (compat20) {
			type = packet_read_poll2(payload_len_ptr);
			if (type)
a1004 1
			type = packet_read_poll1(payload_len_ptr);
d1021 1
a1021 1
				if (type)
d1172 1
a1172 1
		packet_put_cstring(buf);
d1178 1
a1178 1
	channel_close_all();
d1319 1
a1319 1
	debug("packet_set_maxsize: setting to %d", s);
d1342 1
a1342 1
	if (compat20 == 0)
@


1.61.2.2
log
@Merge OpenSSH 3.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.61.2.1 2001/09/27 19:03:54 jason Exp $");
a1228 1
	called = 1;
@


1.61.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.61.2.2 2001/11/15 00:15:19 miod Exp $");
a117 3
/* roundup current message to extra_pad bytes */
static u_char extra_pad = 0;

a487 1
	u_char padlen, pad;
d490 1
a490 1
	u_int i, len;
a535 9
	if (extra_pad) {
		/* will wrap if extra_pad+padlen > 255 */
		extra_pad  = roundup(extra_pad, block_size);
		pad = extra_pad - ((len + padlen) % extra_pad);
		debug("packet_send2: adding %d (len %d padlen %d extra_pad %d)",
		    pad, len, padlen, extra_pad);
		padlen += pad;
		extra_pad = 0;
	}
a1234 7
/* roundup current message to pad bytes */
void
packet_add_padding(u_char pad)
{
	extra_pad = pad;
}

d1246 35
@


1.61.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.90 2002/02/27 21:23:13 stevesk Exp $");
a61 1
#include "misc.h"
d133 2
a134 2
	cipher_init(&send_context, none, "", 0, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, none, "", 0, NULL, 0, CIPHER_DECRYPT);
d150 1
a150 1
packet_connection_is_on_socket(void)
d176 1
a176 1
packet_connection_is_ipv4(void)
d192 1
a192 1
packet_set_nonblocking(void)
d207 1
a207 1
packet_get_connection_in(void)
d215 1
a215 1
packet_get_connection_out(void)
d223 1
a223 1
packet_close(void)
a242 2
	cipher_cleanup(&send_context);
	cipher_cleanup(&receive_context);
d256 1
a256 1
packet_get_protocol_flags(void)
d300 2
a301 2
	cipher_init(&send_context, cipher, key, keylen, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, cipher, key, keylen, NULL, 0, CIPHER_DECRYPT);
d332 1
a332 1
packet_put_string(const void *buf, u_int len)
d342 1
a342 1
packet_put_raw(const void *buf, u_int len)
d365 1
a365 1
	u_char buf[8], *cp;
d383 1
a383 1
		    buffer_len(&compression_buffer));
d390 1
a390 1
	if (!send_context.plaintext) {
d402 1
a402 1
	checksum = ssh_crc32(buffer_ptr(&outgoing_packet),
d415 3
a417 3
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
a439 1
	int encrypt;
d443 1
a443 7
	if (mode == MODE_OUT) {
		cc = &send_context;
		encrypt = CIPHER_ENCRYPT;
	} else {
		cc = &receive_context;
		encrypt = CIPHER_DECRYPT;
	}
d446 2
a447 1
		cipher_cleanup(cc);
d469 4
a472 4
	cipher_init(cc, enc->cipher, enc->key, enc->key_len,
	    enc->iv, enc->block_size, encrypt);
	memset(enc->iv,  0, enc->block_size);
	memset(enc->key, 0, enc->key_len);
d490 1
a490 1
	u_char type, *cp, *macbuf = NULL;
d492 1
d506 1
a506 1
	block_size = enc ? enc->block_size : 8;
d508 2
a509 2
	cp = buffer_ptr(&outgoing_packet);
	type = cp[5];
d549 2
a550 2
	cp = buffer_append_space(&outgoing_packet, padlen);
	if (enc && !send_context.plaintext) {
d564 3
a566 3
	cp = buffer_ptr(&outgoing_packet);
	PUT_32BIT(cp, packet_length);
	cp[4] = padlen;
d572 1
a572 1
		    buffer_ptr(&outgoing_packet),
d577 2
a578 2
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d597 1
a597 1
packet_send(void)
d613 1
a613 1
packet_read_seqnr(u_int32_t *seqnr_p)
d629 1
a629 1
		type = packet_read_poll_seqnr(seqnr_p);
d635 1
a635 1
			packet_check_eom();
a667 6
int
packet_read(void)
{
	return packet_read_seqnr(NULL);
}

d674 1
a674 1
packet_read_expect(int expected_type)
d678 1
a678 1
	type = packet_read();
d691 6
d700 1
a700 1
packet_read_poll1(void)
d703 2
a704 1
	u_char *cp, type;
d711 2
a712 2
	cp = buffer_ptr(&input);
	len = GET_32BIT(cp);
d731 1
a731 1
	if (!receive_context.plaintext &&
d737 2
a738 2
	cp = buffer_append_space(&incoming_packet, padded_len);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), padded_len);
d748 1
a748 1
	checksum = ssh_crc32(buffer_ptr(&incoming_packet),
d756 1
a756 1
		packet_disconnect("packet_read_poll1: len %d != buffer_len %d.",
d759 2
a760 2
	cp = (u_char *)buffer_ptr(&incoming_packet) + len - 4;
	stored_checksum = GET_32BIT(cp);
d773 1
d778 1
a778 1
packet_read_poll2(u_int32_t *seqnr_p)
d783 2
a784 1
	u_char *macbuf, *cp, type;
d796 1
a796 1
	block_size = enc ? enc->block_size : 8;
d806 2
a807 2
		cp = buffer_append_space(&incoming_packet, block_size);
		cipher_crypt(&receive_context, cp, buffer_ptr(&input),
d809 2
a810 2
		cp = buffer_ptr(&incoming_packet);
		packet_length = GET_32BIT(cp);
d835 2
a836 2
	cp = buffer_append_space(&incoming_packet, need);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), need);
d844 1
a844 1
		    buffer_ptr(&incoming_packet),
a850 2
	if (seqnr_p != NULL)
		*seqnr_p = seqnr;
d855 2
a856 2
	cp = buffer_ptr(&incoming_packet);
	padlen = cp[4];
d881 1
d892 1
a892 1
packet_read_poll_seqnr(u_int32_t *seqnr_p)
d894 1
a894 1
	int reason, seqnr;
d900 1
a900 1
			type = packet_read_poll2(seqnr_p);
d903 1
a903 1
			switch (type) {
a921 4
			case SSH2_MSG_UNIMPLEMENTED:
				seqnr = packet_get_int();
				debug("Received SSH2_MSG_UNIMPLEMENTED for %d", seqnr);
				break;
d927 2
a928 2
			type = packet_read_poll1();
			switch (type) {
a952 6
int
packet_read_poll(void)
{
	return packet_read_poll_seqnr(NULL);
}

d967 1
a967 1
packet_get_char(void)
d977 1
a977 1
packet_get_int(void)
d988 1
a988 1
packet_get_bignum(BIGNUM * value)
d990 1
a990 1
	buffer_get_bignum(&incoming_packet, value);
d994 1
a994 1
packet_get_bignum2(BIGNUM * value)
d996 1
a996 1
	buffer_get_bignum2(&incoming_packet, value);
d999 1
a999 1
void *
d1021 1
a1021 1
void *
d1114 1
a1114 1
packet_write_poll(void)
d1135 1
a1135 1
packet_write_wait(void)
d1157 1
a1157 1
packet_have_data_to_write(void)
d1165 1
a1165 1
packet_not_very_much_data_to_write(void)
d1181 1
d1203 1
a1203 1
			    &lowdelay, sizeof(lowdelay)) < 0)
d1207 3
a1209 1
		set_nodelay(connection_in);
d1215 1
a1215 1
		if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, &throughput,
d1224 1
a1224 1
packet_is_interactive(void)
d1274 1
a1274 1
	for (i = 0; i < nbytes; i++) {
@


1.61.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.93 2002/03/24 16:01:13 markus Exp $");
d89 1
a89 1
Buffer input;
d92 1
a92 1
Buffer output;
a117 2
static u_int32_t read_seqnr = 0;
static u_int32_t send_seqnr = 0;
a173 93
/*
 * Exports an IV from the CipherContext required to export the key
 * state back from the unprivileged child to the privileged parent
 * process.
 */

void
packet_get_keyiv(int mode, u_char *iv, u_int len)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	cipher_get_keyiv(cc, iv, len);
}

int
packet_get_keycontext(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	return (cipher_get_keycontext(cc, dat));
}

void
packet_set_keycontext(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	cipher_set_keycontext(cc, dat);
}

int
packet_get_keyiv_len(int mode)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	return (cipher_get_keyiv_len(cc));
}
void
packet_set_iv(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &send_context;
	else
		cc = &receive_context;

	cipher_set_keyiv(cc, dat);
}
int
packet_get_ssh1_cipher()
{
	return (cipher_get_number(receive_context.cipher));
}


u_int32_t
packet_get_seqnr(int mode)
{
	return (mode == MODE_IN ? read_seqnr : send_seqnr);
}

void
packet_set_seqnr(int mode, u_int32_t seqnr)
{
	if (mode == MODE_IN)
		read_seqnr = seqnr;
	else if (mode == MODE_OUT)
		send_seqnr = seqnr;
	else
		fatal("%s: bad mode %d", __FUNCTION__, mode);
}

d436 1
a436 1
void
d480 2
a481 3
	/* Deleting the keys does not gain extra security */
	/* memset(enc->iv,  0, enc->block_size);
	   memset(enc->key, 0, enc->key_len); */
d498 1
d552 1
a552 1
		debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)",
d579 1
a579 1
		macbuf = mac_compute(mac, send_seqnr,
d582 1
a582 1
		DBG(debug("done calc MAC out #%d", send_seqnr));
d596 1
a596 1
	if (++send_seqnr == 0)
d786 1
d848 1
a848 1
		macbuf = mac_compute(mac, read_seqnr,
d853 1
a853 1
		DBG(debug("MAC #%d ok", read_seqnr));
d857 2
a858 2
		*seqnr_p = read_seqnr;
	if (++read_seqnr == 0)
@


1.60
log
@reset compress state per direction when rekeying.
@
text
@d532 1
a532 1
                memset(mac->key, 0, mac->key_len);
d1326 1
a1326 1
 * 
d1329 1
a1329 1
 * 
@


1.59
log
@clear+free keys,iv for rekeying.
+ fix DH mem leaks. ok niels@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.58 2001/04/04 09:48:34 markus Exp $");
d107 1
d253 1
a253 1
	if (packet_compression) {
d281 9
a289 1
/*** XXXXX todo: kex means re-init */
d293 1
a293 1
	if (packet_compression)
d296 3
a298 2
	buffer_init(&compression_buffer);
	buffer_compress_init(level);
d555 5
a560 2
		if (! packet_compression)
			packet_start_compression(6);
@


1.58
log
@don't sent multiple kexinit-requests.
send newkeys, block while waiting for newkeys.
fix comments.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.57 2001/04/03 23:32:12 markus Exp $");
a126 10
clear_enc_keys(Enc *enc, int len)
{
	memset(enc->iv,  0, len);
	memset(enc->key, 0, len);
	xfree(enc->iv);
	xfree(enc->key);
	enc->iv = NULL;
	enc->key = NULL;
}
void
d517 1
d519 10
a528 1
		/* todo: free old keys, reset compression/cipher-ctxt; */
d542 2
a543 1
	clear_enc_keys(enc, enc->cipher->key_len);
@


1.57
log
@undo parts of recent my changes: main part of keyexchange does not
need dispatch-callbacks, since application data is delayed until
the keyexchange completes (if i understand the drafts correctly).

add some infrastructure for re-keying.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.56 2001/03/03 21:41:07 millert Exp $");
d528 2
a529 1
		// free old keys, reset compression cipher-contexts;
@


1.56
log
@Dynamically allocate fd_set; deraadt@@ OK
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.55 2001/03/01 02:45:10 deraadt Exp $");
d124 1
a124 1
Kex	*kex = NULL;
a126 12
packet_set_kex(Kex *k)
{
	if( k->mac[MODE_IN ].key == NULL ||
	    k->enc[MODE_IN ].key == NULL ||
	    k->enc[MODE_IN ].iv  == NULL ||
	    k->mac[MODE_OUT].key == NULL ||
	    k->enc[MODE_OUT].key == NULL ||
	    k->enc[MODE_OUT].iv  == NULL)
		fatal("bad KEX");
	kex = k;
}
void
d141 1
d514 35
d567 4
a570 4
	if (kex != NULL) {
		enc  = &kex->enc[MODE_OUT];
		mac  = &kex->mac[MODE_OUT];
		comp = &kex->comp[MODE_OUT];
d649 2
a650 16
	if (type == SSH2_MSG_NEWKEYS) {
		if (kex==NULL || mac==NULL || enc==NULL || comp==NULL)
			fatal("packet_send2: no KEX");
		if (mac->md != NULL)
			mac->enabled = 1;
		DBG(debug("cipher_init send_context"));
		cipher_init(&send_context, enc->cipher,
		    enc->key, enc->cipher->key_len,
		    enc->iv, enc->cipher->block_size);
		clear_enc_keys(enc, kex->we_need);
		if (comp->type != 0 && comp->enabled == 0) {
			comp->enabled = 1;
			if (! packet_compression)
				packet_start_compression(6);
		}
	}
d846 4
a849 4
	if (kex != NULL) {
		enc  = &kex->enc[MODE_IN];
		mac  = &kex->mac[MODE_IN];
		comp = &kex->comp[MODE_IN];
d943 2
a944 16
	if (type == SSH2_MSG_NEWKEYS) {
		if (kex==NULL || mac==NULL || enc==NULL || comp==NULL)
			fatal("packet_read_poll2: no KEX");
		if (mac->md != NULL)
			mac->enabled = 1;
		DBG(debug("cipher_init receive_context"));
		cipher_init(&receive_context, enc->cipher,
		    enc->key, enc->cipher->key_len,
		    enc->iv, enc->cipher->block_size);
		clear_enc_keys(enc, kex->we_need);
		if (comp->type != 0 && comp->enabled == 0) {
			comp->enabled = 1;
			if (! packet_compression)
				packet_start_compression(6);
		}
	}
d1332 2
a1333 2
	if (kex != NULL)
	enc  = &kex->enc[MODE_OUT];
@


1.55
log
@KNF
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.54 2001/02/28 21:27:47 markus Exp $");
d663 1
a663 1
	fd_set set;
d667 3
d684 2
a685 1
		if (type != SSH_MSG_NONE)
d687 1
d692 3
a694 2
		FD_ZERO(&set);
		FD_SET(connection_in, &set);
d697 1
a697 1
		while (select(connection_in + 1, &set, NULL, NULL, NULL) == -1 &&
d1203 4
d1209 4
a1212 5
		fd_set set;

		FD_ZERO(&set);
		FD_SET(connection_out, &set);
		while (select(connection_out + 1, NULL, &set, NULL, NULL) == -1 &&
d1217 1
@


1.54
log
@use ignore message to simulate a SSH2_MSG_CHANNEL_DATA message
use random content in ignore messages.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.53 2001/02/28 09:57:06 markus Exp $");
d392 1
a392 1
	DBG(debug("packet_start[%d]",type));
d945 1
a945 1
	fprintf(stderr, "read/plain[%d]:\r\n",type);
@


1.53
log
@in ssh protocol v2 use ignore messages for padding (instead of trailing \0).
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.52 2001/02/27 10:35:27 markus Exp $");
d1318 1
a1318 2
	u_int32_t rand = 0;
	int i, blocksize, padlen, have, need, nb, mini, nbytes;
d1346 10
a1355 1
	packet_start(SSH2_MSG_IGNORE);
@


1.52
log
@fix random padding
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.51 2001/02/12 22:56:09 deraadt Exp $");
d1301 54
@


1.51
log
@deal with EAGAIN/EINTR selects which were skipped
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.50 2001/02/11 12:59:25 markus Exp $");
d589 1
a589 1
			rand <<= 8;
@


1.50
log
@1) clean up the MAC support for SSH-2
2) allow you to specify the MAC with 'ssh -m'
3) or the 'MACs' keyword in ssh(d)_config
4) add hmac-{md5,sha1}-96
	ok stevesk@@, provos@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.49 2001/02/08 19:30:52 itojun Exp $");
d691 3
a693 1
		select(connection_in + 1, &set, NULL, NULL, NULL);
d1200 1
d1203 3
a1205 1
		select(connection_out + 1, NULL, &set, NULL, NULL);
@


1.49
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.48 2001/02/04 15:32:24 stevesk Exp $");
a56 3
#include <openssl/bn.h>
#include <openssl/dh.h>
#include <openssl/hmac.h>
d59 1
a59 1
#include "hmac.h"
d531 1
a536 1
	static u_int seqnr = 0;
d604 1
a604 1
		macbuf = hmac( mac->md, seqnr,
d606 1
a606 3
		    buffer_len(&outgoing_packet),
		    mac->key, mac->key_len
		);
d816 2
a821 2
	static u_int packet_length = 0;
	static u_int seqnr = 0;
d881 1
a881 1
		macbuf = hmac( mac->md, seqnr,
d883 1
a883 3
		    buffer_len(&incoming_packet),
		    mac->key, mac->key_len
		);
@


1.48
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.47 2001/02/04 13:30:12 stevesk Exp $");
d458 1
a458 1
packet_send1()
d532 1
a532 1
packet_send2()
@


1.47
log
@remove duplicate #include's; ok markus@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.46 2001/01/21 19:05:53 markus Exp $");
d991 1
a991 1
			}	
d1013 1
a1013 1
			}	
@


1.46
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.45 2001/01/19 15:55:11 markus Exp $");
a59 1
#include "buffer.h"
@


1.45
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.44 2001/01/13 18:36:45 markus Exp $");
a45 1
#include "ssh.h"
d64 2
@


1.44
log
@reorder, typo
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.43 2001/01/13 18:32:50 markus Exp $");
d55 1
@


1.43
log
@split out keepalive from packet_interactive (from dale@@accentre.com)
set IPTOS_LOWDELAY TCP_NODELAY IPTOS_THROUGHPUT for ssh2, too.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.42 2001/01/09 21:19:50 markus Exp $");
d1236 4
a1258 1
			int lowdelay = IPTOS_LOWDELAY;
a1271 1
		int throughput = IPTOS_THROUGHPUT;
@


1.42
log
@allow TCP_NDELAY for ipv6; from netbsd via itojun@@
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.41 2001/01/02 20:41:02 markus Exp $");
d1233 1
a1233 1
packet_set_interactive(int interactive, int keepalives)
d1235 4
a1238 1
	int on = 1;
a1245 6
	if (keepalives) {
		/* Set keepalives if requested. */
		if (setsockopt(connection_in, SOL_SOCKET, SO_KEEPALIVE, (void *) &on,
		    sizeof(on)) < 0)
			error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));
	}
@


1.41
log
@log remote ip on disconnect; PR 1600, from jcs@@rt.fm
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.40 2000/12/19 23:17:57 markus Exp $");
d1250 1
a1250 1
	 * IPTOS_LOWDELAY, TCP_NODELAY and IPTOS_THROUGHPUT are IPv4 only
a1251 2
	if (!packet_connection_is_ipv4())
		return;
d1257 7
a1263 4
		int lowdelay = IPTOS_LOWDELAY;
		if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, (void *) &lowdelay,
		    sizeof(lowdelay)) < 0)
			error("setsockopt IPTOS_LOWDELAY: %.100s", strerror(errno));
d1267 1
a1267 1
	} else {
@


1.40
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.39 2000/12/06 22:58:15 markus Exp $");
d982 2
a983 1
				log("Received disconnect: %d: %.900s", reason, msg);
d1002 2
a1003 1
				log("Received disconnect: %.900s", msg);
@


1.39
log
@disable debug messages for ssh.com/f-secure 2.0.1x, 2.1.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.38 2000/10/12 14:21:12 markus Exp $");
d87 1
a87 1
static unsigned int remote_protocol_flags = 0;
d170 2
a171 2
	cipher_init(&send_context, none, (unsigned char *) "", 0, NULL, 0);
	cipher_init(&receive_context, none, (unsigned char *) "", 0, NULL, 0);
d284 1
a284 1
packet_set_protocol_flags(unsigned int protocol_flags)
d292 1
a292 1
unsigned int
d321 1
a321 1
    unsigned int bytes)
d332 1
a332 1
packet_decrypt(CipherContext *context, void *dest, void *src, unsigned int bytes)
d353 1
a353 1
packet_set_encryption_key(const unsigned char *key, unsigned int keylen,
d413 1
a413 1
packet_put_int(unsigned int value)
d421 1
a421 1
packet_put_string(const char *buf, unsigned int len)
d432 1
a432 1
packet_put_raw(const char *buf, unsigned int len)
d461 1
a461 1
	unsigned int checksum;
d496 1
a496 1
	checksum = ssh_crc32((unsigned char *) buffer_ptr(&outgoing_packet),
d533 1
a533 1
	unsigned char *macbuf = NULL;
d535 2
a536 2
	unsigned int packet_length = 0;
	unsigned int i, padlen, len;
d538 1
a538 1
	static unsigned int seqnr = 0;
d607 1
a607 1
		    (unsigned char *) buffer_ptr(&outgoing_packet),
d745 2
a746 2
	unsigned int len, padded_len;
	unsigned char *ucp;
d748 1
a748 1
	unsigned int checksum, stored_checksum;
d754 1
a754 1
	ucp = (unsigned char *) buffer_ptr(&input);
d781 1
a781 1
	checksum = ssh_crc32((unsigned char *) buffer_ptr(&incoming_packet),
d793 1
a793 1
	ucp = (unsigned char *) buffer_ptr(&incoming_packet) + len - 4;
d814 1
a814 1
	return (unsigned char) buf[0];
d820 3
a822 3
	unsigned int padlen, need;
	unsigned char buf[8], *macbuf;
	unsigned char *ucp;
d824 2
a825 2
	static unsigned int packet_length = 0;
	static unsigned int seqnr = 0;
d851 1
a851 1
		ucp = (unsigned char *) buffer_ptr(&incoming_packet);
d886 1
a886 1
		    (unsigned char *) buffer_ptr(&incoming_packet),
d929 1
a929 1
	type = (unsigned char)buf[0];
d952 1
a952 1
	return (unsigned char)type;
d1021 1
a1021 1
packet_process_incoming(const char *buf, unsigned int len)
d1028 1
a1028 1
unsigned int
d1033 1
a1033 1
	return (unsigned char) ch;
d1038 1
a1038 1
unsigned int
d1084 1
a1084 1
packet_get_string(unsigned int *length_ptr)
@


1.38
log
@remove unused
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.37 2000/10/11 20:27:23 markus Exp $");
d1103 3
@


1.38.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.51 2001/02/12 22:56:09 deraadt Exp $");
d46 1
a54 1
#include "ssh1.h"
d57 4
d63 1
a63 3
#include "mac.h"
#include "log.h"
#include "canohost.h"
d87 1
a87 1
static u_int remote_protocol_flags = 0;
d170 2
a171 2
	cipher_init(&send_context, none, (u_char *) "", 0, NULL, 0);
	cipher_init(&receive_context, none, (u_char *) "", 0, NULL, 0);
d284 1
a284 1
packet_set_protocol_flags(u_int protocol_flags)
d292 1
a292 1
u_int
d321 1
a321 1
    u_int bytes)
d332 1
a332 1
packet_decrypt(CipherContext *context, void *dest, void *src, u_int bytes)
d353 1
a353 1
packet_set_encryption_key(const u_char *key, u_int keylen,
d413 1
a413 1
packet_put_int(u_int value)
d421 1
a421 1
packet_put_string(const char *buf, u_int len)
d432 1
a432 1
packet_put_raw(const char *buf, u_int len)
d457 1
a457 1
packet_send1(void)
d461 1
a461 1
	u_int checksum;
d496 1
a496 1
	checksum = ssh_crc32((u_char *) buffer_ptr(&outgoing_packet),
d531 1
a531 1
packet_send2(void)
d533 1
a533 2
	static u_int32_t seqnr = 0;
	u_char *macbuf = NULL;
d535 2
a536 2
	u_int packet_length = 0;
	u_int i, padlen, len;
d538 1
d606 5
a610 3
		macbuf = mac_compute(mac, seqnr,
		    (u_char *) buffer_ptr(&outgoing_packet),
		    buffer_len(&outgoing_packet));
d695 1
a695 3
		while (select(connection_in + 1, &set, NULL, NULL, NULL) == -1 &&
		    (errno == EAGAIN || errno == EINTR))
			;
d745 2
a746 2
	u_int len, padded_len;
	u_char *ucp;
d748 1
a748 1
	u_int checksum, stored_checksum;
d754 1
a754 1
	ucp = (u_char *) buffer_ptr(&input);
d781 1
a781 1
	checksum = ssh_crc32((u_char *) buffer_ptr(&incoming_packet),
d793 1
a793 1
	ucp = (u_char *) buffer_ptr(&incoming_packet) + len - 4;
d814 1
a814 1
	return (u_char) buf[0];
d820 3
a822 5
	static u_int32_t seqnr = 0;
	static u_int packet_length = 0;
	u_int padlen, need;
	u_char buf[8], *macbuf;
	u_char *ucp;
d824 2
d851 1
a851 1
		ucp = (u_char *) buffer_ptr(&incoming_packet);
d885 5
a889 3
		macbuf = mac_compute(mac, seqnr,
		    (u_char *) buffer_ptr(&incoming_packet),
		    buffer_len(&incoming_packet));
d929 1
a929 1
	type = (u_char)buf[0];
d952 1
a952 1
	return (u_char)type;
d982 1
a982 2
				log("Received disconnect from %s: %d: %.400s", get_remote_ipaddr(),
					reason, msg);
d989 1
a989 1
			}
d1001 1
a1001 2
				log("Received disconnect from %s: %.400s", get_remote_ipaddr(),
					msg);
d1010 1
a1010 1
			}
d1021 1
a1021 1
packet_process_incoming(const char *buf, u_int len)
d1028 1
a1028 1
u_int
d1033 1
a1033 1
	return (u_char) ch;
d1038 1
a1038 1
u_int
d1084 1
a1084 1
packet_get_string(u_int *length_ptr)
a1103 3
	if (compat20 && (datafellows & SSH_BUG_DEBUG))
		return;

a1198 1

d1201 1
a1201 3
		while (select(connection_out + 1, NULL, &set, NULL, NULL) == -1 &&
		    (errno == EAGAIN || errno == EINTR))
			;
d1228 1
a1228 1
packet_set_interactive(int interactive)
a1229 3
	static int called = 0;
	int lowdelay = IPTOS_LOWDELAY;
	int throughput = IPTOS_THROUGHPUT;
a1231 4
	if (called)
		return;
	called = 1;

d1238 6
d1245 1
a1245 1
	 * IPTOS_LOWDELAY and IPTOS_THROUGHPUT are IPv4 only
d1247 2
d1254 4
a1257 6
		if (packet_connection_is_ipv4()) {
			if (setsockopt(connection_in, IPPROTO_IP, IP_TOS,
			    (void *) &lowdelay, sizeof(lowdelay)) < 0)
				error("setsockopt IPTOS_LOWDELAY: %.100s",
				    strerror(errno));
		}
d1261 1
a1261 1
	} else if (packet_connection_is_ipv4()) {
d1266 1
@


1.38.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.38.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.56 2001/03/03 21:41:07 millert Exp $");
d392 1
a392 1
	DBG(debug("packet_start[%d]", type));
d589 1
a589 1
			rand >>= 8;
d663 1
a663 1
	fd_set *setp;
a666 3
	setp = (fd_set *)xmalloc(howmany(connection_in+1, NFDBITS) *
	    sizeof(fd_mask));

d681 1
a681 2
		if (type != SSH_MSG_NONE) {
			xfree(setp);
a682 1
		}
d687 2
a688 3
		memset(setp, 0, howmany(connection_in + 1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(connection_in, setp);
d691 1
a691 1
		while (select(connection_in + 1, setp, NULL, NULL, NULL) == -1 &&
d945 1
a945 1
	fprintf(stderr, "read/plain[%d]:\r\n", type);
a1196 4
	fd_set *setp;

	setp = (fd_set *)xmalloc(howmany(connection_out + 1, NFDBITS) *
	    sizeof(fd_mask));
d1199 5
a1203 4
		memset(setp, 0, howmany(connection_out + 1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(connection_out, setp);
		while (select(connection_out + 1, NULL, setp, NULL, NULL) == -1 &&
a1207 1
	xfree(setp);
a1300 62
}

/*
 * 9.2.  Ignored Data Message
 * 
 *   byte      SSH_MSG_IGNORE
 *   string    data
 * 
 * All implementations MUST understand (and ignore) this message at any
 * time (after receiving the protocol version). No implementation is
 * required to send them. This message can be used as an additional
 * protection measure against advanced traffic analysis techniques.
 */
/* size of current + ignore message should be n*sumlen bytes (w/o mac) */
void
packet_inject_ignore(int sumlen)
{
	int blocksize, padlen, have, need, nb, mini, nbytes;
	Enc *enc = NULL;

	if (use_ssh2_packet_format == 0)
		return;

	have = buffer_len(&outgoing_packet);
	debug2("packet_inject_ignore: current %d", have);
	if (kex != NULL)
	enc  = &kex->enc[MODE_OUT];
	blocksize = enc ? enc->cipher->block_size : 8;
	padlen = blocksize - (have % blocksize);
	if (padlen < 4)
		padlen += blocksize;
	have += padlen;
	have /= blocksize;	/* # of blocks for current message */

	nb   = roundup(sumlen,  blocksize) / blocksize;	/* blocks for both */
	mini = roundup(5+1+4+4, blocksize) / blocksize; /* minsize ignore msg */
	need = nb - (have % nb);			/* blocks for ignore */
	if (need <= mini)
		need += nb;
	nbytes = (need - mini) * blocksize;	/* size of ignore payload */
	debug2("packet_inject_ignore: block %d have %d nb %d mini %d need %d",
	    blocksize, have, nb, mini, need);

	/* enqueue current message and append a ignore message */
	packet_send();
	packet_send_ignore(nbytes);
}

void
packet_send_ignore(int nbytes)
{
	u_int32_t rand = 0;
	int i;

	packet_start(compat20 ? SSH2_MSG_IGNORE : SSH_MSG_IGNORE);
	packet_put_int(nbytes);
	for(i = 0; i < nbytes; i++) {
		if (i % 4 == 0)
			rand = arc4random();
		packet_put_char(rand & 0xff);
		rand >>= 8;
	}
@


1.38.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.61 2001/04/05 10:42:51 markus Exp $");
a106 1
static int compression_buffer_ready = 0;
d124 1
a124 1
Newkeys *newkeys[MODE_MAX];
d127 22
a152 1
	newkeys[MODE_IN] = newkeys[MODE_OUT] = NULL;
d273 1
a273 1
	if (compression_buffer_ready) {
d301 1
a301 9
void
packet_init_compression()
{
	if (compression_buffer_ready == 1)
		return;
	compression_buffer_ready = 1;
	buffer_init(&compression_buffer);
}

d305 1
a305 1
	if (packet_compression && !use_ssh2_packet_format)
d308 2
a309 3
	packet_init_compression();
	buffer_compress_init_send(level);
	buffer_compress_init_recv();
a524 50
void
set_newkeys(int mode)
{
	Enc *enc;
	Mac *mac;
	Comp *comp;
	CipherContext *cc;

	debug("newkeys: mode %d", mode);

	cc = (mode == MODE_OUT) ? &send_context : &receive_context;
	if (newkeys[mode] != NULL) {
		debug("newkeys: rekeying");
		/* todo: free old keys, reset compression/cipher-ctxt; */
		memset(cc, 0, sizeof(*cc));
		enc  = &newkeys[mode]->enc;
		mac  = &newkeys[mode]->mac;
		comp = &newkeys[mode]->comp;
		memset(mac->key, 0, mac->key_len);
		xfree(enc->name);
		xfree(enc->iv);
		xfree(enc->key);
		xfree(mac->name);
		xfree(mac->key);
		xfree(comp->name);
		xfree(newkeys[mode]);
	}
	newkeys[mode] = kex_get_newkeys(mode);
	if (newkeys[mode] == NULL)
		fatal("newkeys: no keys for mode %d", mode);
	enc  = &newkeys[mode]->enc;
	mac  = &newkeys[mode]->mac;
	comp = &newkeys[mode]->comp;
	if (mac->md != NULL)
		mac->enabled = 1;
	DBG(debug("cipher_init_context: %d", mode));
	cipher_init(cc, enc->cipher, enc->key, enc->cipher->key_len,
	    enc->iv, enc->cipher->block_size);
	memset(enc->iv,  0, enc->cipher->block_size);
	memset(enc->key, 0, enc->cipher->key_len);
	if (comp->type != 0 && comp->enabled == 0) {
		packet_init_compression();
		if (mode == MODE_OUT)
			buffer_compress_init_send(6);
		else
			buffer_compress_init_recv();
		comp->enabled = 1;
	}
}

d543 4
a546 4
	if (newkeys[MODE_OUT] != NULL) {
		enc  = &newkeys[MODE_OUT]->enc;
		mac  = &newkeys[MODE_OUT]->mac;
		comp = &newkeys[MODE_OUT]->comp;
d625 16
a640 2
	if (type == SSH2_MSG_NEWKEYS)
		set_newkeys(MODE_OUT);
d836 4
a839 4
	if (newkeys[MODE_IN] != NULL) {
		enc  = &newkeys[MODE_IN]->enc;
		mac  = &newkeys[MODE_IN]->mac;
		comp = &newkeys[MODE_IN]->comp;
d933 16
a948 2
	if (type == SSH2_MSG_NEWKEYS)
		set_newkeys(MODE_IN);
d1315 1
a1315 1
 *
d1318 1
a1318 1
 *
d1336 2
a1337 2
	if (newkeys[MODE_OUT] != NULL)
		enc  = &newkeys[MODE_OUT]->enc;
@


1.38.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d16 1
a16 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.69 2001/06/25 08:25:38 markus Exp $");
d78 6
d121 3
d127 8
d147 1
a149 1
	newkeys[MODE_IN] = newkeys[MODE_OUT] = NULL;
d265 1
d281 2
a282 2
static void
packet_init_compression(void)
d293 1
a293 1
	if (packet_compression && !compat20)
d302 32
d338 1
d352 2
a353 1
/* Start constructing a packet to send. */
d355 1
a355 1
packet_start(u_char type)
d357 1
a357 2
	u_char buf[9];
	int len;
d359 22
d382 4
a385 5
	len = compat20 ? 6 : 9;
	memset(buf, 0, len - 1);
	buf[len - 1] = type;
	buffer_clear(&outgoing_packet);
	buffer_append(&outgoing_packet, buf, len);
d388 2
a389 1
/* Append payload. */
d396 3
d404 3
d415 1
a415 1
	buffer_put_cstring(&outgoing_packet, str);
d417 1
d423 4
d443 1
a443 1
static void
d471 1
a471 1
	if (send_context.cipher->number != SSH_CIPHER_NONE) {
d497 1
a497 1
	cipher_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d514 1
a514 1
static void
d567 1
a567 1
static void
d571 1
a571 1
	u_char type, *ucp, *macbuf = NULL;
d576 1
d589 2
a590 2
	ucp = (u_char *) buffer_ptr(&outgoing_packet);
	type = ucp[5];
d636 3
a638 3
	ucp = (u_char *)buffer_ptr(&outgoing_packet);
	PUT_32BIT(ucp, packet_length);
	ucp[4] = padlen;
d650 1
a650 1
	cipher_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d671 1
a671 1
	if (compat20)
d702 1
a702 1
		if (!compat20 && (
d771 1
a771 1
static int
d775 2
a776 2
	u_char *ucp, type;
	char *cp;
d798 1
a798 10
	/*
	 * Cryptographic attack detector for ssh
	 * (C)1998 CORE-SDI, Buenos Aires Argentina
	 * Ariel Futoransky(futo@@core-sdi.com)
	 */
	if (receive_context.cipher->number != SSH_CIPHER_NONE &&
	    detect_attack(buffer_ptr(&input), padded_len, NULL) == DEATTACK_DETECTED)
		packet_disconnect("crc32 compensation attack: network attack detected");

	/* Decrypt data to incoming_packet. */
d801 1
a801 2
	cipher_decrypt(&receive_context, cp, buffer_ptr(&input), padded_len);

d817 1
d828 1
d836 4
a839 1
	type = buffer_get_char(&incoming_packet);
d841 3
a843 1
	return type;
d846 1
a846 1
static int
d852 2
a853 1
	u_char *macbuf, *ucp, type;
d855 1
d878 1
a878 1
		cipher_decrypt(&receive_context, cp, buffer_ptr(&input),
d907 1
a907 1
	cipher_decrypt(&receive_context, cp, buffer_ptr(&input), need);
d927 1
a927 1
	padlen = (u_char) *cp;
d949 9
a957 1
	type = buffer_get_char(&incoming_packet);
d960 1
a960 1
	*payload_len_ptr = buffer_len(&incoming_packet);
d965 1
a965 3
	/* reset for next packet */
	packet_length = 0;
	return type;
a970 2
	int reason;
	u_char type;
a971 1

d973 7
a979 3
		if (compat20) {
			type = packet_read_poll2(payload_len_ptr);
			if (type)
a1004 1
			type = packet_read_poll1(payload_len_ptr);
d1021 1
a1021 1
				if (type)
d1172 1
a1172 1
		packet_put_cstring(buf);
d1178 1
a1178 1
	channel_close_all();
d1319 1
a1319 1
	debug("packet_set_maxsize: setting to %d", s);
d1342 1
a1342 1
	if (compat20 == 0)
@


1.38.2.6
log
@Merge OpenSSH 3.0
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.38.2.5 2001/09/27 00:15:42 miod Exp $");
a1228 1
	called = 1;
@


1.38.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.38.2.6 2001/11/15 00:14:59 miod Exp $");
a117 3
/* roundup current message to extra_pad bytes */
static u_char extra_pad = 0;

a487 1
	u_char padlen, pad;
d490 1
a490 1
	u_int i, len;
a535 9
	if (extra_pad) {
		/* will wrap if extra_pad+padlen > 255 */
		extra_pad  = roundup(extra_pad, block_size);
		pad = extra_pad - ((len + padlen) % extra_pad);
		debug("packet_send2: adding %d (len %d padlen %d extra_pad %d)",
		    pad, len, padlen, extra_pad);
		padlen += pad;
		extra_pad = 0;
	}
a1234 7
/* roundup current message to pad bytes */
void
packet_add_padding(u_char pad)
{
	extra_pad = pad;
}

d1246 35
@


1.38.2.8
log
@Merge OpenSSH 3.1.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.90 2002/02/27 21:23:13 stevesk Exp $");
a61 1
#include "misc.h"
d133 2
a134 2
	cipher_init(&send_context, none, "", 0, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, none, "", 0, NULL, 0, CIPHER_DECRYPT);
d150 1
a150 1
packet_connection_is_on_socket(void)
d176 1
a176 1
packet_connection_is_ipv4(void)
d192 1
a192 1
packet_set_nonblocking(void)
d207 1
a207 1
packet_get_connection_in(void)
d215 1
a215 1
packet_get_connection_out(void)
d223 1
a223 1
packet_close(void)
a242 2
	cipher_cleanup(&send_context);
	cipher_cleanup(&receive_context);
d256 1
a256 1
packet_get_protocol_flags(void)
d300 2
a301 2
	cipher_init(&send_context, cipher, key, keylen, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, cipher, key, keylen, NULL, 0, CIPHER_DECRYPT);
d332 1
a332 1
packet_put_string(const void *buf, u_int len)
d342 1
a342 1
packet_put_raw(const void *buf, u_int len)
d365 1
a365 1
	u_char buf[8], *cp;
d383 1
a383 1
		    buffer_len(&compression_buffer));
d390 1
a390 1
	if (!send_context.plaintext) {
d402 1
a402 1
	checksum = ssh_crc32(buffer_ptr(&outgoing_packet),
d415 3
a417 3
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
a439 1
	int encrypt;
d443 1
a443 7
	if (mode == MODE_OUT) {
		cc = &send_context;
		encrypt = CIPHER_ENCRYPT;
	} else {
		cc = &receive_context;
		encrypt = CIPHER_DECRYPT;
	}
d446 2
a447 1
		cipher_cleanup(cc);
d469 4
a472 4
	cipher_init(cc, enc->cipher, enc->key, enc->key_len,
	    enc->iv, enc->block_size, encrypt);
	memset(enc->iv,  0, enc->block_size);
	memset(enc->key, 0, enc->key_len);
d490 1
a490 1
	u_char type, *cp, *macbuf = NULL;
d492 1
d506 1
a506 1
	block_size = enc ? enc->block_size : 8;
d508 2
a509 2
	cp = buffer_ptr(&outgoing_packet);
	type = cp[5];
d549 2
a550 2
	cp = buffer_append_space(&outgoing_packet, padlen);
	if (enc && !send_context.plaintext) {
d564 3
a566 3
	cp = buffer_ptr(&outgoing_packet);
	PUT_32BIT(cp, packet_length);
	cp[4] = padlen;
d572 1
a572 1
		    buffer_ptr(&outgoing_packet),
d577 2
a578 2
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
d597 1
a597 1
packet_send(void)
d613 1
a613 1
packet_read_seqnr(u_int32_t *seqnr_p)
d629 1
a629 1
		type = packet_read_poll_seqnr(seqnr_p);
d635 1
a635 1
			packet_check_eom();
a667 6
int
packet_read(void)
{
	return packet_read_seqnr(NULL);
}

d674 1
a674 1
packet_read_expect(int expected_type)
d678 1
a678 1
	type = packet_read();
d691 6
d700 1
a700 1
packet_read_poll1(void)
d703 2
a704 1
	u_char *cp, type;
d711 2
a712 2
	cp = buffer_ptr(&input);
	len = GET_32BIT(cp);
d731 1
a731 1
	if (!receive_context.plaintext &&
d737 2
a738 2
	cp = buffer_append_space(&incoming_packet, padded_len);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), padded_len);
d748 1
a748 1
	checksum = ssh_crc32(buffer_ptr(&incoming_packet),
d756 1
a756 1
		packet_disconnect("packet_read_poll1: len %d != buffer_len %d.",
d759 2
a760 2
	cp = (u_char *)buffer_ptr(&incoming_packet) + len - 4;
	stored_checksum = GET_32BIT(cp);
d773 1
d778 1
a778 1
packet_read_poll2(u_int32_t *seqnr_p)
d783 2
a784 1
	u_char *macbuf, *cp, type;
d796 1
a796 1
	block_size = enc ? enc->block_size : 8;
d806 2
a807 2
		cp = buffer_append_space(&incoming_packet, block_size);
		cipher_crypt(&receive_context, cp, buffer_ptr(&input),
d809 2
a810 2
		cp = buffer_ptr(&incoming_packet);
		packet_length = GET_32BIT(cp);
d835 2
a836 2
	cp = buffer_append_space(&incoming_packet, need);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), need);
d844 1
a844 1
		    buffer_ptr(&incoming_packet),
a850 2
	if (seqnr_p != NULL)
		*seqnr_p = seqnr;
d855 2
a856 2
	cp = buffer_ptr(&incoming_packet);
	padlen = cp[4];
d881 1
d892 1
a892 1
packet_read_poll_seqnr(u_int32_t *seqnr_p)
d894 1
a894 1
	int reason, seqnr;
d900 1
a900 1
			type = packet_read_poll2(seqnr_p);
d903 1
a903 1
			switch (type) {
a921 4
			case SSH2_MSG_UNIMPLEMENTED:
				seqnr = packet_get_int();
				debug("Received SSH2_MSG_UNIMPLEMENTED for %d", seqnr);
				break;
d927 2
a928 2
			type = packet_read_poll1();
			switch (type) {
a952 6
int
packet_read_poll(void)
{
	return packet_read_poll_seqnr(NULL);
}

d967 1
a967 1
packet_get_char(void)
d977 1
a977 1
packet_get_int(void)
d988 1
a988 1
packet_get_bignum(BIGNUM * value)
d990 1
a990 1
	buffer_get_bignum(&incoming_packet, value);
d994 1
a994 1
packet_get_bignum2(BIGNUM * value)
d996 1
a996 1
	buffer_get_bignum2(&incoming_packet, value);
d999 1
a999 1
void *
d1021 1
a1021 1
void *
d1114 1
a1114 1
packet_write_poll(void)
d1135 1
a1135 1
packet_write_wait(void)
d1157 1
a1157 1
packet_have_data_to_write(void)
d1165 1
a1165 1
packet_not_very_much_data_to_write(void)
d1181 1
d1203 1
a1203 1
			    &lowdelay, sizeof(lowdelay)) < 0)
d1207 3
a1209 1
		set_nodelay(connection_in);
d1215 1
a1215 1
		if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, &throughput,
d1224 1
a1224 1
packet_is_interactive(void)
d1274 1
a1274 1
	for (i = 0; i < nbytes; i++) {
@


1.37
log
@new cipher framework
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.36 2000/10/03 17:59:57 markus Exp $");
d585 1
a585 1
	if (enc && enc->type != SSH_CIPHER_NONE) {
@


1.36
log
@hmac->mac
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.35 2000/09/07 20:27:52 deraadt Exp $");
a47 1
#include "cipher.h"
d61 1
d164 3
d170 2
a171 2
	cipher_set_key(&send_context, SSH_CIPHER_NONE, (unsigned char *) "", 0);
	cipher_set_key(&receive_context, SSH_CIPHER_NONE, (unsigned char *) "", 0);
d332 1
a332 2
packet_decrypt(CipherContext * cc, void *dest, void *src,
    unsigned int bytes)
a333 5
	int i;

	if ((bytes % 8) != 0)
		fatal("packet_decrypt: bad ciphertext length %d", bytes);

d338 3
a340 7

	if (cc->type == SSH_CIPHER_NONE || compat20) {
		i = DEATTACK_OK;
	} else {
		i = detect_attack(src, bytes, NULL);
	}
	if (i == DEATTACK_DETECTED)
d343 1
a343 1
	cipher_decrypt(cc, dest, src, bytes);
d354 1
a354 1
    int cipher)
d356 3
d360 3
a362 5
		fatal("keylen too small: %d", keylen);

	/* All other ciphers use the same key in both directions for now. */
	cipher_set_key(&receive_context, cipher, key, keylen);
	cipher_set_key(&send_context, cipher, key, keylen);
d550 1
a550 1
	block_size = enc ? enc->block_size : 8;
d634 4
a637 4
		DBG(debug("cipher_set_key_iv send_context"));
		cipher_set_key_iv(&send_context, enc->type,
		    enc->key, enc->key_len,
		    enc->iv, enc->iv_len);
d838 1
a838 1
	block_size = enc ? enc->block_size : 8;
d936 4
a939 4
		DBG(debug("cipher_set_key_iv receive_context"));
		cipher_set_key_iv(&receive_context, enc->type,
		    enc->key, enc->key_len,
		    enc->iv, enc->iv_len);
@


1.35
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.34 2000/08/19 02:17:12 deraadt Exp $");
d617 1
a617 1
		DBG(debug("done calc HMAC out #%d", seqnr));
d897 2
a898 2
			packet_disconnect("Corrupted HMAC on input.");
		DBG(debug("HMAC #%d ok", seqnr));
@


1.34
log
@rename crc32() to ssh_crc32() to avoid zlib name clash.  do not move to
libz crc32 function yet, because it has ugly "long"'s in it; oneill@@cs.sfu.ca
@
text
@a1 3
 *
 * packet.c
 *
a2 1
 *
d5 2
d8 5
a12 1
 * Created: Sat Mar 18 02:40:40 1995 ylo
a13 2
 * This file contains code implementing the packet protocol and communication
 * with the other side.  This same code is used both on client and server side.
d16 1
d18 19
d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.33 2000/06/20 01:39:43 markus Exp $");
@


1.33
log
@OpenBSD tag
@
text
@d20 1
a20 1
RCSID("$OpenBSD: packet.c,v 1.32 2000/05/04 22:22:43 markus Exp $");
d482 2
a483 2
	checksum = crc32((unsigned char *) buffer_ptr(&outgoing_packet),
			 buffer_len(&outgoing_packet));
d767 1
a767 1
	checksum = crc32((unsigned char *) buffer_ptr(&incoming_packet),
@


1.32
log
@clear padding in ssh2
@
text
@d20 1
a20 1
RCSID("$Id: packet.c,v 1.31 2000/05/01 07:40:03 markus Exp $");
@


1.32.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d20 1
a20 1
RCSID("$OpenBSD: packet.c,v 1.34 2000/08/19 02:17:12 deraadt Exp $");
d482 2
a483 2
	checksum = ssh_crc32((unsigned char *) buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
d767 1
a767 1
	checksum = ssh_crc32((unsigned char *) buffer_ptr(&incoming_packet),
@


1.32.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a14 7
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
a15 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
a16 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
RCSID("$OpenBSD: packet.c,v 1.38 2000/10/12 14:21:12 markus Exp $");
d28 1
a41 1
#include "cipher.h"
a143 3
	Cipher *none = cipher_by_name("none");
	if (none == NULL)
		fatal("packet_set_connection: cannot load cipher 'none'");
d147 2
a148 2
	cipher_init(&send_context, none, (unsigned char *) "", 0, NULL, 0);
	cipher_init(&receive_context, none, (unsigned char *) "", 0, NULL, 0);
d309 2
a310 1
packet_decrypt(CipherContext *context, void *dest, void *src, unsigned int bytes)
d312 5
d321 7
a327 3
	if (!compat20 &&
	    context->cipher->number != SSH_CIPHER_NONE &&
	    detect_attack(src, bytes, NULL) == DEATTACK_DETECTED)
d330 1
a330 1
	cipher_decrypt(context, dest, src, bytes);
d341 1
a341 1
    int number)
a342 3
	Cipher *cipher = cipher_by_number(number);
	if (cipher == NULL)
		fatal("packet_set_encryption_key: unknown cipher number %d", number);
d344 5
a348 3
		fatal("packet_set_encryption_key: keylen too small: %d", keylen);
	cipher_init(&receive_context, cipher, key, keylen, NULL, 0);
	cipher_init(&send_context, cipher, key, keylen, NULL, 0);
d536 1
a536 1
	block_size = enc ? enc->cipher->block_size : 8;
d571 1
a571 1
	if (enc && enc->cipher->number != SSH_CIPHER_NONE) {
d597 1
a597 1
		DBG(debug("done calc MAC out #%d", seqnr));
d620 4
a623 4
		DBG(debug("cipher_init send_context"));
		cipher_init(&send_context, enc->cipher,
		    enc->key, enc->cipher->key_len,
		    enc->iv, enc->cipher->block_size);
d824 1
a824 1
	block_size = enc ? enc->cipher->block_size : 8;
d877 2
a878 2
			packet_disconnect("Corrupted MAC on input.");
		DBG(debug("MAC #%d ok", seqnr));
d922 4
a925 4
		DBG(debug("cipher_init receive_context"));
		cipher_init(&receive_context, enc->cipher,
		    enc->key, enc->cipher->key_len,
		    enc->iv, enc->cipher->block_size);
@


1.32.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.51 2001/02/12 22:56:09 deraadt Exp $");
d46 1
a54 1
#include "ssh1.h"
d57 4
d63 1
a63 3
#include "mac.h"
#include "log.h"
#include "canohost.h"
d87 1
a87 1
static u_int remote_protocol_flags = 0;
d170 2
a171 2
	cipher_init(&send_context, none, (u_char *) "", 0, NULL, 0);
	cipher_init(&receive_context, none, (u_char *) "", 0, NULL, 0);
d284 1
a284 1
packet_set_protocol_flags(u_int protocol_flags)
d292 1
a292 1
u_int
d321 1
a321 1
    u_int bytes)
d332 1
a332 1
packet_decrypt(CipherContext *context, void *dest, void *src, u_int bytes)
d353 1
a353 1
packet_set_encryption_key(const u_char *key, u_int keylen,
d413 1
a413 1
packet_put_int(u_int value)
d421 1
a421 1
packet_put_string(const char *buf, u_int len)
d432 1
a432 1
packet_put_raw(const char *buf, u_int len)
d457 1
a457 1
packet_send1(void)
d461 1
a461 1
	u_int checksum;
d496 1
a496 1
	checksum = ssh_crc32((u_char *) buffer_ptr(&outgoing_packet),
d531 1
a531 1
packet_send2(void)
d533 1
a533 2
	static u_int32_t seqnr = 0;
	u_char *macbuf = NULL;
d535 2
a536 2
	u_int packet_length = 0;
	u_int i, padlen, len;
d538 1
d606 5
a610 3
		macbuf = mac_compute(mac, seqnr,
		    (u_char *) buffer_ptr(&outgoing_packet),
		    buffer_len(&outgoing_packet));
d695 1
a695 3
		while (select(connection_in + 1, &set, NULL, NULL, NULL) == -1 &&
		    (errno == EAGAIN || errno == EINTR))
			;
d745 2
a746 2
	u_int len, padded_len;
	u_char *ucp;
d748 1
a748 1
	u_int checksum, stored_checksum;
d754 1
a754 1
	ucp = (u_char *) buffer_ptr(&input);
d781 1
a781 1
	checksum = ssh_crc32((u_char *) buffer_ptr(&incoming_packet),
d793 1
a793 1
	ucp = (u_char *) buffer_ptr(&incoming_packet) + len - 4;
d814 1
a814 1
	return (u_char) buf[0];
d820 3
a822 5
	static u_int32_t seqnr = 0;
	static u_int packet_length = 0;
	u_int padlen, need;
	u_char buf[8], *macbuf;
	u_char *ucp;
d824 2
d851 1
a851 1
		ucp = (u_char *) buffer_ptr(&incoming_packet);
d885 5
a889 3
		macbuf = mac_compute(mac, seqnr,
		    (u_char *) buffer_ptr(&incoming_packet),
		    buffer_len(&incoming_packet));
d929 1
a929 1
	type = (u_char)buf[0];
d952 1
a952 1
	return (u_char)type;
d982 1
a982 2
				log("Received disconnect from %s: %d: %.400s", get_remote_ipaddr(),
					reason, msg);
d989 1
a989 1
			}
d1001 1
a1001 2
				log("Received disconnect from %s: %.400s", get_remote_ipaddr(),
					msg);
d1010 1
a1010 1
			}
d1021 1
a1021 1
packet_process_incoming(const char *buf, u_int len)
d1028 1
a1028 1
u_int
d1033 1
a1033 1
	return (u_char) ch;
d1038 1
a1038 1
u_int
d1084 1
a1084 1
packet_get_string(u_int *length_ptr)
a1103 3
	if (compat20 && (datafellows & SSH_BUG_DEBUG))
		return;

a1198 1

d1201 1
a1201 3
		while (select(connection_out + 1, NULL, &set, NULL, NULL) == -1 &&
		    (errno == EAGAIN || errno == EINTR))
			;
d1228 1
a1228 1
packet_set_interactive(int interactive)
a1229 3
	static int called = 0;
	int lowdelay = IPTOS_LOWDELAY;
	int throughput = IPTOS_THROUGHPUT;
a1231 4
	if (called)
		return;
	called = 1;

d1238 6
d1245 1
a1245 1
	 * IPTOS_LOWDELAY and IPTOS_THROUGHPUT are IPv4 only
d1247 2
d1254 4
a1257 6
		if (packet_connection_is_ipv4()) {
			if (setsockopt(connection_in, IPPROTO_IP, IP_TOS,
			    (void *) &lowdelay, sizeof(lowdelay)) < 0)
				error("setsockopt IPTOS_LOWDELAY: %.100s",
				    strerror(errno));
		}
d1261 1
a1261 1
	} else if (packet_connection_is_ipv4()) {
d1266 1
@


1.32.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.56 2001/03/03 21:41:07 millert Exp $");
d392 1
a392 1
	DBG(debug("packet_start[%d]", type));
d589 1
a589 1
			rand >>= 8;
d663 1
a663 1
	fd_set *setp;
a666 3
	setp = (fd_set *)xmalloc(howmany(connection_in+1, NFDBITS) *
	    sizeof(fd_mask));

d681 1
a681 2
		if (type != SSH_MSG_NONE) {
			xfree(setp);
a682 1
		}
d687 2
a688 3
		memset(setp, 0, howmany(connection_in + 1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(connection_in, setp);
d691 1
a691 1
		while (select(connection_in + 1, setp, NULL, NULL, NULL) == -1 &&
d945 1
a945 1
	fprintf(stderr, "read/plain[%d]:\r\n", type);
a1196 4
	fd_set *setp;

	setp = (fd_set *)xmalloc(howmany(connection_out + 1, NFDBITS) *
	    sizeof(fd_mask));
d1199 5
a1203 4
		memset(setp, 0, howmany(connection_out + 1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(connection_out, setp);
		while (select(connection_out + 1, NULL, setp, NULL, NULL) == -1 &&
a1207 1
	xfree(setp);
a1300 62
}

/*
 * 9.2.  Ignored Data Message
 * 
 *   byte      SSH_MSG_IGNORE
 *   string    data
 * 
 * All implementations MUST understand (and ignore) this message at any
 * time (after receiving the protocol version). No implementation is
 * required to send them. This message can be used as an additional
 * protection measure against advanced traffic analysis techniques.
 */
/* size of current + ignore message should be n*sumlen bytes (w/o mac) */
void
packet_inject_ignore(int sumlen)
{
	int blocksize, padlen, have, need, nb, mini, nbytes;
	Enc *enc = NULL;

	if (use_ssh2_packet_format == 0)
		return;

	have = buffer_len(&outgoing_packet);
	debug2("packet_inject_ignore: current %d", have);
	if (kex != NULL)
	enc  = &kex->enc[MODE_OUT];
	blocksize = enc ? enc->cipher->block_size : 8;
	padlen = blocksize - (have % blocksize);
	if (padlen < 4)
		padlen += blocksize;
	have += padlen;
	have /= blocksize;	/* # of blocks for current message */

	nb   = roundup(sumlen,  blocksize) / blocksize;	/* blocks for both */
	mini = roundup(5+1+4+4, blocksize) / blocksize; /* minsize ignore msg */
	need = nb - (have % nb);			/* blocks for ignore */
	if (need <= mini)
		need += nb;
	nbytes = (need - mini) * blocksize;	/* size of ignore payload */
	debug2("packet_inject_ignore: block %d have %d nb %d mini %d need %d",
	    blocksize, have, nb, mini, need);

	/* enqueue current message and append a ignore message */
	packet_send();
	packet_send_ignore(nbytes);
}

void
packet_send_ignore(int nbytes)
{
	u_int32_t rand = 0;
	int i;

	packet_start(compat20 ? SSH2_MSG_IGNORE : SSH_MSG_IGNORE);
	packet_put_int(nbytes);
	for(i = 0; i < nbytes; i++) {
		if (i % 4 == 0)
			rand = arc4random();
		packet_put_char(rand & 0xff);
		rand >>= 8;
	}
@


1.31
log
@less debug, rm unused
@
text
@d20 1
a20 1
RCSID("$Id: packet.c,v 1.30 2000/04/30 09:12:07 markus Exp $");
d468 1
a468 1
	/* Insert padding. */
d572 1
d579 3
d664 2
a665 1
		if (type == SSH_SMSG_SUCCESS
d668 1
a668 1
		    || type == SSH_CMSG_EXIT_CONFIRMATION)
@


1.30
log
@send debug messages in SSH2 format
@
text
@d20 1
a20 1
RCSID("$Id: packet.c,v 1.29 2000/04/14 10:30:32 markus Exp $");
d133 1
a133 1
	debug("use_ssh2_packet_format");
d616 1
a616 1
		debug("cipher_set_key_iv send_context");
a638 7
void
packet_send_and_wait()
{
	packet_send();
	packet_write_wait();
}

d917 1
a917 1
		debug("cipher_set_key_iv receive_context");
@


1.29
log
@whitespace cleanup
@
text
@d20 1
a20 1
RCSID("$Id: packet.c,v 1.28 2000/04/14 10:09:15 markus Exp $");
d1096 9
a1104 2
	packet_start(SSH_MSG_DEBUG);
	packet_put_string(buf, strlen(buf));
@


1.28
log
@check payload for (illegal) extra data
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d20 1
a20 1
RCSID("$Id: packet.c,v 1.27 2000/04/12 09:39:10 markus Exp $");
d524 1
a524 1
        static unsigned int seqnr = 0;
d606 3
a608 3
        /* increment sequence number for outgoing packets */
        if (++seqnr == 0)
                log("outgoing seqnr wraps around");
d872 1
a872 1
        if (mac && mac->enabled) {
d883 2
a884 2
        if (++seqnr == 0)
                log("incoming seqnr wraps around");
@


1.27
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d20 1
a20 1
RCSID("$Id: packet.c,v 1.26 2000/04/04 21:37:27 markus Exp $");
d1056 6
@


1.26
log
@remove unused argument, split cipher_mask()
@
text
@d20 1
a20 1
RCSID("$Id: packet.c,v 1.25 2000/04/03 20:12:55 markus Exp $");
d38 3
a40 3
#include <ssl/bn.h>
#include <ssl/dh.h>
#include <ssl/hmac.h>
@


1.25
log
@ssh2 packet format
@
text
@d20 1
a20 1
RCSID("$Id: packet.c,v 1.11 2000/03/31 09:40:42 markus Exp $");
d147 2
a148 2
	cipher_set_key(&send_context, SSH_CIPHER_NONE, (unsigned char *) "", 0, 1);
	cipher_set_key(&receive_context, SSH_CIPHER_NONE, (unsigned char *) "", 0, 0);
d347 2
a348 2
	cipher_set_key(&receive_context, cipher, key, keylen, 0);
	cipher_set_key(&send_context, cipher, key, keylen, 1);
@


1.24
log
@channel layer support for ssh2
@
text
@d14 3
a16 1
 * 
d20 1
a20 1
RCSID("$Id: packet.c,v 1.23 2000/03/28 20:31:27 markus Exp $");
d35 16
d102 35
a140 1

d280 1
d298 1
a298 1
	       unsigned int bytes)
d310 1
a310 1
	       unsigned int bytes)
d322 1
a322 2
	switch (cc->type) {
	case SSH_CIPHER_NONE:
d324 1
a324 2
		break;
	default:
a325 1
		break;
a326 1

d341 1
a341 1
			  int cipher)
d343 3
d354 1
a354 1
packet_start(int type)
d364 23
d443 1
a443 1
packet_send()
d514 133
d658 1
d712 1
a712 1
				  expected_type, type);
d731 1
a731 1
packet_read_poll(int *payload_len_ptr)
d735 1
a735 1
	char buf[8], *cp, *msg;
a737 2
restart:

d770 1
a770 1
			 buffer_len(&incoming_packet) - 4);
d779 1
a779 1
				  len, buffer_len(&incoming_packet));
d793 1
a793 1
			      buffer_len(&compression_buffer));
a800 19
	/* Handle disconnect message. */
	if ((unsigned char) buf[0] == SSH_MSG_DISCONNECT) {
		msg = packet_get_string(NULL);
		log("Received disconnect: %.900s", msg);
		xfree(msg);
		fatal_cleanup();
	}	

	/* Ignore ignore messages. */
	if ((unsigned char) buf[0] == SSH_MSG_IGNORE)
		goto restart;

	/* Send debug messages as debugging output. */
	if ((unsigned char) buf[0] == SSH_MSG_DEBUG) {
		msg = packet_get_string(NULL);
		debug("Remote: %.900s", msg);
		xfree(msg);
		goto restart;
	}
d805 198
d1122 9
a1130 2
	packet_start(SSH_MSG_DISCONNECT);
	packet_put_string(buf, strlen(buf));
d1261 2
a1262 1
		log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
@


1.23
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.22 2000/02/05 10:13:11 markus Exp $");
d336 12
d356 5
d655 15
@


1.22
log
@missing xfree()
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.21 2000/01/22 20:20:28 deraadt Exp $");
d31 1
@


1.21
log
@getsockname() requires initialized tolen; andy@@guildsoftware.com
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.20 2000/01/20 15:15:18 markus Exp $");
d508 1
a508 1
	char buf[8], *cp;
d578 3
a580 1
		log("Received disconnect: %.900s", packet_get_string(NULL));
d590 3
a592 1
		debug("Remote: %.900s", packet_get_string(NULL));
@


1.20
log
@use getpeername() in packet_connection_is_on_socket(), fixes sshd -i;
from Holger.Trapp@@Informatik.TU-Chemnitz.DE
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.19 2000/01/04 00:07:59 markus Exp $");
d139 1
a139 1
	socklen_t tolen;
@


1.19
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.18 1999/12/15 20:03:23 markus Exp $");
d120 1
a120 1
	if (getpeername(connection_in, (struct sockaddr *) & from, &fromlen) < 0)
d124 1
a124 1
	if (getsockname(connection_out, (struct sockaddr *)&to, &tolen) < 0)
@


1.18
log
@"Connection closed by x.x.x.x": fatal() -> log()
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.17 1999/12/02 20:16:34 markus Exp $");
d107 42
d780 2
a781 5
	/*
	 * Only set socket options if using a socket (as indicated by the
	 * descriptors being the same).
	 */
	if (connection_in != connection_out)
a782 1

d786 1
a786 1
			       sizeof(on)) < 0)
d789 5
d801 1
a801 1
			       sizeof(lowdelay)) < 0)
d804 1
a804 1
			       sizeof(on)) < 0)
d813 1
a813 1
			       sizeof(throughput)) < 0)
@


1.17
log
@set loglevel for SSH_MSG_DISCONNECT to log(), not fatal()
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.16 1999/11/24 19:53:48 markus Exp $");
d418 4
a421 2
		if (len == 0)
			fatal("Connection closed by %.200s", get_remote_ipaddr());
@


1.16
log
@KNF, final part 3
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.15 1999/11/24 00:26:02 deraadt Exp $");
d533 4
a536 2
	if ((unsigned char) buf[0] == SSH_MSG_DISCONNECT)
		fatal("Received disconnect: %.900s", packet_get_string(NULL));
d667 2
a668 1
	fatal("Disconnecting: %.100s", buf);
@


1.15
log
@much more KNF
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.14 1999/11/23 22:25:54 markus Exp $");
d32 6
a37 4
/* This variable contains the file descriptors used for communicating with
   the other side.  connection_in is used for reading; connection_out
   for writing.  These can be the same descriptor, in which case it is
   assumed to be a socket. */
d41 4
a44 2
/* Cipher type.  This value is only used to determine whether to pad the
   packets with zeroes or random data. */
d83 4
a86 2
/* Sets the descriptors used for communication.  Disables encryption until
   packet_set_encryption_key is called. */
d180 4
a183 2
/* Starts packet compression from the next packet on in both directions.
   Level is compression level 1 (fastest) - 9 (slow, best) as in gzip. */
d195 4
a198 2
/* Encrypts the given number of bytes, copying from src to dest.
   bytes is known to be a multiple of 8. */
d207 4
a210 2
/* Decrypts the given number of bytes, copying from src to dest.
   bytes is known to be a multiple of 8. */
d221 4
a224 2
	/* Cryptographic attack detector for ssh - Modifications for packet.c
          (C)1998 CORE-SDI, Buenos Aires Argentina Ariel Futoransky(futo@@core-sdi.com) */
d241 5
a245 3
/* Causes any further packets to be encrypted using the given key.  The same
   key is used for both sending and reception.  However, both directions
   are encrypted independently of each other. */
d302 4
a305 2
/* Finalizes and sends the packet.  If the encryption key has been set,
   encrypts the packet before sending. */
d315 4
a318 2
	/* If using packet compression, compress the payload of the
	   outgoing packet. */
d371 5
a375 3
	/* Note that the packet is now only buffered in output.  It won\'t
	   be actually sent until packet_write_wait or packet_write_poll
	   is called. */
d378 5
a382 3
/* Waits until a packet has been received, and returns its type.  Note that
   no other data is processed until this returns, so this function should
   not be used during the interactive session. */
d406 4
a409 2
		/* Otherwise, wait for some data to arrive, add it to the
		   buffer, and try again. */
d412 1
d415 1
d428 4
a431 2
/* Waits until a packet has been received, verifies that its type matches
   that given, and gives a fatal error and exits if there is a mismatch. */
d549 4
a552 2
/* Buffers the given amount of input characters.  This is intended to be
   used together with packet_read_poll. */
d578 4
a581 2
/* Returns an arbitrary precision integer from the packet data.  The integer
   must have been initialized before this call. */
d589 6
a594 4
/* Returns a string from the packet data.  The string is allocated using
   xmalloc; it is the responsibility of the calling program to free it when
   no longer needed.  The length_ptr argument may be NULL, or point to an
   integer into which the length of the string is stored. */
d596 1
a596 2
char
*
d602 8
a609 7
/* Sends a diagnostic message from the server to the client.  This message
   can be sent at any time (but not while constructing another message).
   The message is printed immediately, but only if the client is being
   executed in verbose mode.  These messages are primarily intended to
   ease debugging authentication problems.   The length of the formatted
   message must not exceed 1024 bytes.  This will automatically call
   packet_write_wait. */
d627 6
a632 4
/* Logs the error plus constructs and sends a disconnect
   packet, closes the connection, and exits.  This function never returns.
   The error message should not contain a newline.  The length of the
   formatted message must not exceed 1024 bytes. */
d644 4
a647 2
	/* Format the message.  Note that the caller must make sure the
	   message is of limited size. */
d668 1
a668 2
/* Checks if there is any buffered output, and tries to write some of the
   output. */
d686 4
a689 2
/* Calls packet_write_poll repeatedly until all pending output data has
   been written. */
d733 4
a736 2
	/* Only set socket options if using a socket (as indicated by the
	   descriptors being the same). */
d747 4
a750 2
		/* Set IP options for an interactive connection.  Use
		   IPTOS_LOWDELAY and TCP_NODELAY. */
d759 4
a762 2
		/* Set IP options for a non-interactive connection.  Use
		   IPTOS_THROUGHPUT. */
@


1.14
log
@KNF part 1
@
text
@d2 14
a15 14

packet.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Mar 18 02:40:40 1995 ylo

This file contains code implementing the packet protocol and communication
with the other side.  This same code is used both on client and server side.

*/
d18 1
a18 1
RCSID("$Id: packet.c,v 1.13 1999/11/22 21:02:38 markus Exp $");
@


1.13
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.12 1999/11/19 19:58:18 markus Exp $");
d48 2
a49 1
/* Encryption coontext for sending data.  This is only used for encryption. */
d85 14
a98 16
  connection_in = fd_in;
  connection_out = fd_out;
  cipher_type = SSH_CIPHER_NONE;
  cipher_set_key(&send_context, SSH_CIPHER_NONE, (unsigned char *)"", 0, 1);
  cipher_set_key(&receive_context, SSH_CIPHER_NONE, (unsigned char *)"", 0, 0);
  if (!initialized)
    {
      initialized = 1;
      buffer_init(&input);
      buffer_init(&output);
      buffer_init(&outgoing_packet);
      buffer_init(&incoming_packet);
    }

  /* Kludge: arrange the close function to be called from fatal(). */
  fatal_add_cleanup((void (*)(void *))packet_close, NULL);
d106 8
a113 9
  /* Set the socket into non-blocking mode. */
  if (fcntl(connection_in, F_SETFL, O_NONBLOCK) < 0)
    error("fcntl O_NONBLOCK: %.100s", strerror(errno));

  if (connection_out != connection_in)
    {
      if (fcntl(connection_out, F_SETFL, O_NONBLOCK) < 0)
	error("fcntl O_NONBLOCK: %.100s", strerror(errno));
    }
d121 1
a121 1
  return connection_in;
d129 1
a129 1
  return connection_out;
d137 18
a154 22
  if (!initialized)
    return;
  initialized = 0;
  if (connection_in == connection_out)
    {
      shutdown(connection_out, SHUT_RDWR);
      close(connection_out);
    }
  else
    {
      close(connection_in);
      close(connection_out);
    }
  buffer_free(&input);
  buffer_free(&output);
  buffer_free(&outgoing_packet);
  buffer_free(&incoming_packet);
  if (packet_compression)
    {
      buffer_free(&compression_buffer);
      buffer_compress_uninit();
    }
d162 2
a163 2
  remote_protocol_flags = protocol_flags;
  channel_set_options((protocol_flags & SSH_PROTOFLAG_HOST_IN_FWD_OPEN) != 0);
d171 1
a171 1
  return remote_protocol_flags;
d174 1
a174 1
/* Starts packet compression from the next packet on in both directions. 
d180 5
a184 5
  if (packet_compression)
    fatal("Compression already enabled.");
  packet_compression = 1;
  buffer_init(&compression_buffer);
  buffer_compress_init(level);
d191 1
a191 1
packet_encrypt(CipherContext *cc, void *dest, void *src, 
d194 1
a194 1
  cipher_encrypt(cc, dest, src, bytes);
d201 1
a201 1
packet_decrypt(CipherContext *cc, void *dest, void *src, 
d204 21
a224 24
  int i;
  
  if ((bytes % 8) != 0)
    fatal("packet_decrypt: bad ciphertext length %d", bytes);
  
  /*
    Cryptographic attack detector for ssh - Modifications for packet.c 
    (C)1998 CORE-SDI, Buenos Aires Argentina
    Ariel Futoransky(futo@@core-sdi.com)
  */
  switch (cc->type)
    {
    case SSH_CIPHER_NONE:
      i = DEATTACK_OK;
      break;
    default:
      i = detect_attack(src, bytes, NULL);
      break;
    }
  
  if (i == DEATTACK_DETECTED)
    packet_disconnect("crc32 compensation attack: network attack detected");
  
  cipher_decrypt(cc, dest, src, bytes);
d235 3
a237 3
  /* All other ciphers use the same key in both directions for now. */
  cipher_set_key(&receive_context, cipher, key, keylen, 0);
  cipher_set_key(&send_context, cipher, key, keylen, 1);
d245 1
a245 1
  char buf[9];
d247 4
a250 4
  buffer_clear(&outgoing_packet);
  memset(buf, 0, 8);
  buf[8] = type;
  buffer_append(&outgoing_packet, buf, 9);
d258 2
a259 2
  char ch = value;
  buffer_append(&outgoing_packet, &ch, 1);
d267 1
a267 1
  buffer_put_int(&outgoing_packet, value);
d275 1
a275 1
  buffer_put_string(&outgoing_packet, buf, len);
d281 1
a281 1
packet_put_bignum(BIGNUM *value)
d283 1
a283 1
  buffer_put_bignum(&outgoing_packet, value);
d288 1
a288 1
  
d292 39
a330 40
  char buf[8], *cp;
  int i, padding, len;
  unsigned int checksum;
  u_int32_t rand = 0;

  /* If using packet compression, compress the payload of the outgoing
     packet. */
  if (packet_compression)
    {
      buffer_clear(&compression_buffer);
      buffer_consume(&outgoing_packet, 8); /* Skip padding. */
      buffer_append(&compression_buffer, "\0\0\0\0\0\0\0\0", 8); /* padding */
      buffer_compress(&outgoing_packet, &compression_buffer);
      buffer_clear(&outgoing_packet);
      buffer_append(&outgoing_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
    }

  /* Compute packet length without padding (add checksum, remove padding). */
  len = buffer_len(&outgoing_packet) + 4 - 8;
  
  /* Insert padding. */
  padding = 8 - len % 8;
  if (cipher_type != SSH_CIPHER_NONE)
    {
      cp = buffer_ptr(&outgoing_packet);
      for (i = 0; i < padding; i++) {
        if (i % 4 == 0)
          rand = arc4random();
        cp[7 - i] = rand & 0xff;
        rand >>= 8;
      }
    }
  buffer_consume(&outgoing_packet, 8 - padding);
  
  /* Add check bytes. */
  checksum = crc32((unsigned char *)buffer_ptr(&outgoing_packet),
		   buffer_len(&outgoing_packet));
  PUT_32BIT(buf, checksum);
  buffer_append(&outgoing_packet, buf, 4);
d333 2
a334 2
  fprintf(stderr, "packet_send plain: ");
  buffer_dump(&outgoing_packet);
d337 7
a343 7
  /* Append to output. */
  PUT_32BIT(buf, len);
  buffer_append(&output, buf, 4);
  buffer_append_space(&output, &cp, buffer_len(&outgoing_packet));
  packet_encrypt(&send_context, cp, buffer_ptr(&outgoing_packet),
		 buffer_len(&outgoing_packet));
  
d345 2
a346 1
  fprintf(stderr, "encrypted: "); buffer_dump(&output);
d349 1
a349 1
  buffer_clear(&outgoing_packet);
d351 3
a353 2
  /* Note that the packet is now only buffered in output.  It won\'t be
     actually sent until packet_write_wait or packet_write_poll is called. */
d363 35
a397 36
  int type, len;
  fd_set set;
  char buf[8192];

  /* Since we are blocking, ensure that all written packets have been sent. */
  packet_write_wait();

  /* Stay in the loop until we have received a complete packet. */
  for (;;)
    {
      /* Try to read a packet from the buffer. */
      type = packet_read_poll(payload_len_ptr);
      if (type == SSH_SMSG_SUCCESS
	  || type == SSH_SMSG_FAILURE
	  || type == SSH_CMSG_EOF
	  || type == SSH_CMSG_EXIT_CONFIRMATION)
	packet_integrity_check(*payload_len_ptr, 0, type);
      /* If we got a packet, return it. */
      if (type != SSH_MSG_NONE)
	return type;
      /* Otherwise, wait for some data to arrive, add it to the buffer,
	 and try again. */
      FD_ZERO(&set);
      FD_SET(connection_in, &set);
      /* Wait for some data to arrive. */
      select(connection_in + 1, &set, NULL, NULL, NULL);
      /* Read data from the socket. */
      len = read(connection_in, buf, sizeof(buf));
      if (len == 0)
	fatal("Connection closed by %.200s", get_remote_ipaddr());
      if (len < 0)
	fatal("Read from socket failed: %.100s", strerror(errno));
      /* Append it to the buffer. */
      packet_process_incoming(buf, len);
    }
  /*NOTREACHED*/
d406 1
a406 1
  int type;
d408 4
a411 4
  type = packet_read(payload_len_ptr);
  if (type != expected_type)
    packet_disconnect("Protocol error: expected packet type %d, got %d",
		      expected_type, type);
d415 13
a427 15
   packet_process_incoming.  If so, reads the packet; otherwise returns
   SSH_MSG_NONE.  This does not wait for data from the connection. 
   
   SSH_MSG_DISCONNECT is handled specially here.  Also,
   SSH_MSG_IGNORE messages are skipped by this function and are never returned
   to higher levels.

   The returned payload_len does include space consumed by:
   Packet length
   Padding
   Packet type
   Check bytes

   
   */
d432 31
a462 31
  unsigned int len, padded_len;
  unsigned char *ucp;
  char buf[8], *cp;
  unsigned int checksum, stored_checksum;
  
 restart:

  /* Check if input size is less than minimum packet size. */
  if (buffer_len(&input) < 4 + 8)
    return SSH_MSG_NONE;
  /* Get length of incoming packet. */
  ucp = (unsigned char *)buffer_ptr(&input);
  len = GET_32BIT(ucp);
  if (len < 1 + 2 + 2 || len > 256*1024)
    packet_disconnect("Bad packet length %d.", len);
  padded_len = (len + 8) & ~7;

  /* Check if the packet has been entirely received. */
  if (buffer_len(&input) < 4 + padded_len)
    return SSH_MSG_NONE;

  /* The entire packet is in buffer. */

  /* Consume packet length. */
  buffer_consume(&input, 4);

  /* Copy data to incoming_packet. */
  buffer_clear(&incoming_packet);
  buffer_append_space(&incoming_packet, &cp, padded_len);
  packet_decrypt(&receive_context, cp, buffer_ptr(&input), padded_len);
  buffer_consume(&input, padded_len);
d465 2
a466 1
  fprintf(stderr, "read_poll plain: "); buffer_dump(&incoming_packet);
a467 50
  
  /* Compute packet checksum. */
  checksum = crc32((unsigned char *)buffer_ptr(&incoming_packet),
		   buffer_len(&incoming_packet) - 4);

  /* Skip padding. */
  buffer_consume(&incoming_packet, 8 - len % 8);

  /* Test check bytes. */

  if (len != buffer_len(&incoming_packet))
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.",
		      len, buffer_len(&incoming_packet));

  ucp = (unsigned char *)buffer_ptr(&incoming_packet) + len - 4;
  stored_checksum = GET_32BIT(ucp);
  if (checksum != stored_checksum)
    packet_disconnect("Corrupted check bytes on input.");
  buffer_consume_end(&incoming_packet, 4);

  /* If using packet compression, decompress the packet. */
  if (packet_compression)
    {
      buffer_clear(&compression_buffer);
      buffer_uncompress(&incoming_packet, &compression_buffer);
      buffer_clear(&incoming_packet);
      buffer_append(&incoming_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
    }

  /* Get packet type. */
  buffer_get(&incoming_packet, &buf[0], 1);

  /* Return length of payload (without type field). */
  *payload_len_ptr = buffer_len(&incoming_packet);

  /* Handle disconnect message. */
  if ((unsigned char)buf[0] == SSH_MSG_DISCONNECT)
    fatal("Received disconnect: %.900s", packet_get_string(NULL));

  /* Ignore ignore messages. */
  if ((unsigned char)buf[0] == SSH_MSG_IGNORE)
    goto restart;

  /* Send debug messages as debugging output. */
  if ((unsigned char)buf[0] == SSH_MSG_DEBUG)
    {
      debug("Remote: %.900s", packet_get_string(NULL));
      goto restart;
    }
d469 48
a516 2
  /* Return type. */
  return (unsigned char)buf[0];
d518 1
a518 1
  
d525 1
a525 1
  buffer_append(&input, buf, len);
d533 3
a535 3
  char ch;
  buffer_get(&incoming_packet, &ch, 1);
  return (unsigned char)ch;
d543 1
a543 1
  return buffer_get_int(&incoming_packet);
d550 1
a550 1
packet_get_bignum(BIGNUM *value, int *length_ptr)
d552 1
a552 1
  *length_ptr = buffer_get_bignum(&incoming_packet, value);
d561 2
a562 1
*packet_get_string(unsigned int *length_ptr)
d564 1
a564 1
  return buffer_get_string(&incoming_packet, length_ptr);
d576 1
a576 1
packet_send_debug(const char *fmt, ...)
d578 11
a588 11
  char buf[1024];
  va_list args;
  
  va_start(args, fmt);
  vsnprintf(buf, sizeof(buf), fmt, args);
  va_end(args);
  
  packet_start(SSH_MSG_DEBUG);
  packet_put_string(buf, strlen(buf));
  packet_send();
  packet_write_wait();
d597 1
a597 1
packet_disconnect(const char *fmt, ...)
d599 24
a622 25
  char buf[1024];
  va_list args;
  static int disconnecting = 0;
  if (disconnecting) /* Guard against recursive invocations. */
    fatal("packet_disconnect called recursively.");
  disconnecting = 1;

  /* Format the message.  Note that the caller must make sure the message
     is of limited size. */
  va_start(args, fmt);
  vsnprintf(buf, sizeof(buf), fmt, args);
  va_end(args);

  /* Send the disconnect message to the other side, and wait for it to get 
     sent. */
  packet_start(SSH_MSG_DISCONNECT);
  packet_put_string(buf, strlen(buf));
  packet_send();
  packet_write_wait();

  /* Stop listening for connections. */
  channel_stop_listening();
  
  /* Close the connection. */
  packet_close();
d624 2
a625 2
  /* Display the error locally and exit. */
  fatal("Disconnecting: %.100s", buf);
d634 11
a644 12
  int len = buffer_len(&output);
  if (len > 0)
    {
      len = write(connection_out, buffer_ptr(&output), len);
      if (len <= 0) {
	if (errno == EAGAIN)
	  return;
        else
	  fatal("Write failed: %.100s", strerror(errno));
      }
      buffer_consume(&output, len);
    }
d653 8
a660 9
  packet_write_poll();
  while (packet_have_data_to_write())
    {
      fd_set set;
      FD_ZERO(&set);
      FD_SET(connection_out, &set);
      select(connection_out + 1, NULL, &set, NULL, NULL);
      packet_write_poll();
    }
d668 1
a668 1
  return buffer_len(&output) != 0;
d676 4
a679 4
  if (interactive_mode)
    return buffer_len(&output) < 16384;
  else
    return buffer_len(&output) < 128*1024;
d687 1
a687 1
  int on = 1;
d689 2
a690 2
  /* Record that we are in interactive mode. */
  interactive_mode = interactive;
d692 29
a720 34
  /* Only set socket options if using a socket (as indicated by the descriptors
     being the same). */
  if (connection_in != connection_out)
    return;

  if (keepalives)
    {
      /* Set keepalives if requested. */
      if (setsockopt(connection_in, SOL_SOCKET, SO_KEEPALIVE, (void *)&on, 
		     sizeof(on)) < 0)
	error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));
    }

  if (interactive)
    {
      /* Set IP options for an interactive connection.  Use IPTOS_LOWDELAY
	 and TCP_NODELAY. */
      int lowdelay = IPTOS_LOWDELAY;
      if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, (void *)&lowdelay, 
		     sizeof(lowdelay)) < 0)
	error("setsockopt IPTOS_LOWDELAY: %.100s", strerror(errno));
      if (setsockopt(connection_in, IPPROTO_TCP, TCP_NODELAY, (void *)&on, 
		     sizeof(on)) < 0)
	error("setsockopt TCP_NODELAY: %.100s", strerror(errno));
    }
  else
    {
      /* Set IP options for a non-interactive connection.  Use 
	 IPTOS_THROUGHPUT. */
      int throughput = IPTOS_THROUGHPUT;
      if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, (void *)&throughput, 
		     sizeof(throughput)) < 0)
	error("setsockopt IPTOS_THROUGHPUT: %.100s", strerror(errno));
    }
d728 1
a728 1
  return interactive_mode;
d734 12
a745 12
  static int called = 0;
  if (called) {
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
    return -1;
  }
  if (s < 4*1024 || s > 1024*1024) {
    log("packet_set_maxsize: bad size %d", s);
    return -1;
  }
  log("packet_set_maxsize: setting to %d", s);
  max_packet_size = s;
  return s;
@


1.12
log
@SSH_CMSG_MAX_PACKET_SIZE, some clients use this, some need this, niels@@
[hope this time my ISP stays alive during commit]
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.11 1999/11/15 21:38:54 markus Exp $");
d400 1
a400 1
	fatal("Connection closed by remote host.");
d516 1
a516 1
    fatal("%.900s", packet_get_string(NULL));
d639 1
a639 1
  fatal("Local: %.100s", buf);
@


1.11
log
@remove support for cipher RC4
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.10 1999/11/02 19:42:36 markus Exp $");
d69 3
d750 17
@


1.10
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.9 1999/10/05 01:23:54 dugsong Exp $");
d239 1
a239 1
			  int cipher, int is_client)
d241 3
a243 22
  cipher_type = cipher;
  if (cipher == SSH_CIPHER_RC4)
    {
      if (is_client)
	{ /* In client: use first half for receiving, second for sending. */
	  cipher_set_key(&receive_context, cipher, key, keylen / 2, 0);
	  cipher_set_key(&send_context, cipher, key + keylen / 2, 
			 keylen / 2, 1);
	}
      else
	{ /* In server: use first half for sending, second for receiving. */
	  cipher_set_key(&receive_context, cipher, key + keylen / 2, 
			 keylen / 2, 0);
	  cipher_set_key(&send_context, cipher, key, keylen / 2, 1);
	}
    }
  else
    {
      /* All other ciphers use the same key in both directions for now. */
      cipher_set_key(&receive_context, cipher, key, keylen, 0);
      cipher_set_key(&send_context, cipher, key, keylen, 1);
    }
@


1.9
log
@crc32 compensation attack fix from CORE-SDI. "it's not crypto..." -- deraadt@@
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.8 1999/10/03 19:22:38 deraadt Exp $");
a196 1
  assert((bytes % 8) == 0);
d209 2
a210 1
  assert((bytes % 8) == 0);
d503 5
a507 1
  assert(len == buffer_len(&incoming_packet));
@


1.8
log
@use SHUT_* symbols
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.7 1999/10/01 18:18:40 deraadt Exp $");
d30 1
d208 2
d211 19
@


1.7
log
@s/long/int/
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.6 1999/09/30 05:53:04 deraadt Exp $");
d140 1
a140 1
      shutdown(connection_out, 2);
@


1.6
log
@"ssh is a very large program" -- anonymous
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.5 1999/09/30 05:11:29 deraadt Exp $");
d297 1
a297 1
  unsigned long checksum;
d440 1
a440 1
  unsigned long checksum, stored_checksum;
@


1.5
log
@do not bother with dinosaur pacification
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.4 1999/09/30 05:03:04 deraadt Exp $");
a714 1
#ifdef IPTOS_LOWDELAY
a718 1
#endif /* IPTOS_LOWDELAY */
a726 1
#ifdef IPTOS_THROUGHPUT
a730 1
#endif /* IPTOS_THROUGHPUT */
@


1.4
log
@cull more ancient garbage from pre-POSIX days
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.3 1999/09/29 18:16:19 dugsong Exp $");
a103 1
#if defined(O_NONBLOCK) && !defined(O_NONBLOCK_BROKEN)
a105 4
#else /* O_NONBLOCK && !O_NONBLOCK_BROKEN */
  if (fcntl(connection_in, F_SETFL, O_NDELAY) < 0)
    error("fcntl O_NDELAY: %.100s", strerror(errno));
#endif /* O_NONBLOCK && !O_NONBLOCK_BROKEN */
a108 1
#if defined(O_NONBLOCK) && !defined(O_NONBLOCK_BROKEN)
a110 4
#else /* O_NONBLOCK && !O_NONBLOCK_BROKEN */  
      if (fcntl(connection_out, F_SETFL, O_NDELAY) < 0)
	error("fcntl O_NDELAY: %.100s", strerror(errno));
#endif /* O_NONBLOCK && !O_NONBLOCK_BROKEN */
@


1.3
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.2 1999/09/28 04:45:36 provos Exp $");
a28 1
#ifdef WITH_ZLIB
a29 1
#endif /* WITH_ZLIB */
a64 1
#ifdef WITH_ZLIB
a66 1
#endif /* WITH_ZLIB */
a161 1
#ifdef WITH_ZLIB
a166 1
#endif /* WITH_ZLIB */
a185 1
#ifdef WITH_ZLIB
a197 1
#endif /* WITH_ZLIB */
a309 1
#ifdef WITH_ZLIB
a321 1
#endif /* WITH_ZLIB */
a497 1
#ifdef WITH_ZLIB
a506 1
#endif /* WITH_ZLIB */
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d18 1
a18 1
RCSID("$Id: packet.c,v 1.7 1999/06/14 14:41:39 bg Exp $");
d316 1
a316 1
  u_int32_t rand;
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@a20 1
#include "randoms.h"
a71 3
/* Pointer to the random number generator state. */
static RandomState *random_state;

d81 2
a82 1
void packet_set_connection(int fd_in, int fd_out, RandomState *state)
a85 1
  random_state = state;
d104 2
a105 1
void packet_set_nonblocking()
d130 2
a131 1
int packet_get_connection_in()
d138 2
a139 1
int packet_get_connection_out()
d146 2
a147 1
void packet_close()
d177 2
a178 1
void packet_set_protocol_flags(unsigned int protocol_flags)
d186 2
a187 1
unsigned int packet_get_protocol_flags()
d196 2
a197 1
void packet_start_compression(int level)
d210 3
a212 2
void packet_encrypt(CipherContext *cc, void *dest, void *src, 
		    unsigned int bytes)
d221 3
a223 2
void packet_decrypt(CipherContext *cc, void *dest, void *src, 
		    unsigned int bytes)
d233 3
a235 2
void packet_set_encryption_key(const unsigned char *key, unsigned int keylen,
			       int cipher, int is_client)
d263 2
a264 1
void packet_start(int type)
d276 2
a277 1
void packet_put_char(int value)
d285 2
a286 1
void packet_put_int(unsigned int value)
d293 2
a294 1
void packet_put_string(const char *buf, unsigned int len)
d301 2
a302 1
void packet_put_mp_int(MP_INT *value)
d304 1
a304 1
  buffer_put_mp_int(&outgoing_packet, value);
d310 2
a311 1
void packet_send()
d316 1
d341 6
a346 2
      for (i = 0; i < padding; i++)
	cp[7 - i] = random_get_byte(random_state);
d382 2
a383 1
int packet_read(int *payload_len_ptr)
d426 2
a427 1
void packet_read_expect(int *payload_len_ptr, int expected_type)
d454 2
a455 1
int packet_read_poll(int *payload_len_ptr)
d548 2
a549 1
void packet_process_incoming(const char *buf, unsigned int len)
d556 2
a557 1
unsigned int packet_get_char()
d566 2
a567 1
unsigned int packet_get_int()
d575 2
a576 1
void packet_get_mp_int(MP_INT *value, int *length_ptr)
d578 1
a578 1
  *length_ptr = buffer_get_mp_int(&incoming_packet, value);
d586 2
a587 1
char *packet_get_string(unsigned int *length_ptr)
d600 2
a601 1
void packet_send_debug(const char *fmt, ...)
d621 2
a622 1
void packet_disconnect(const char *fmt, ...)
d657 2
a658 1
void packet_write_poll()
d664 1
a664 1
      if (len <= 0)
d669 1
d677 2
a678 1
void packet_write_wait()
d693 2
a694 1
int packet_have_data_to_write()
d701 2
a702 1
int packet_not_very_much_data_to_write()
d712 2
a713 1
void packet_set_interactive(int interactive, int keepalives)
d762 2
a763 1
int packet_is_interactive()
@

