head	1.50;
access;
symbols
	OPENBSD_6_2:1.50.0.4
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.46.0.4
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.2
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.45.0.4
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.45.0.8
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.6
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.42.0.6
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.41.0.12
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.10
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.6
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.8
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.4
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.2
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.40.0.4
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.39.0.4
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.29.0.10
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.8
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.6
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.4
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.50
date	2017.05.17.01.24.17;	author djm;	state Exp;
branches;
next	1.49;
commitid	eeQm0WTdCYidaM5F;

1.49
date	2017.03.10.03.15.58;	author djm;	state Exp;
branches;
next	1.48;
commitid	MQlWKsAhUAtP91R6;

1.48
date	2016.07.15.05.01.58;	author dtucker;	state Exp;
branches;
next	1.47;
commitid	npD1qIqfl2rHEc4G;

1.47
date	2016.04.29.08.07.53;	author djm;	state Exp;
branches;
next	1.46;
commitid	RE6kD70UGwrQdBtC;

1.46
date	2015.07.08.19.04.21;	author markus;	state Exp;
branches;
next	1.45;
commitid	XBbHd4g6Xeb9uqC5;

1.45
date	2013.05.16.09.08.41;	author dtucker;	state Exp;
branches;
next	1.44;

1.44
date	2013.04.07.02.10.33;	author dtucker;	state Exp;
branches;
next	1.43;

1.43
date	2012.09.06.04.37.39;	author dtucker;	state Exp;
branches;
next	1.42;

1.42
date	2011.06.17.21.44.30;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.10.04.50.25;	author dtucker;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.17.07.50.31;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.18.09.13.25;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.35;

1.35
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.10.16.37.36;	author stevesk;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.08.23.30.06;	author stevesk;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches
	1.29.8.1
	1.29.10.1;
next	1.28;

1.28
date	2003.05.24.09.02.22;	author djm;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2003.05.18.23.22.01;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.11.18.29.43;	author markus;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.07.19.15.43.33;	author markus;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.07.06.01.00.49;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.22.12.20.34;	author markus;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2002.02.04.12.15.25;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.17.04.27.37;	author stevesk;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.26.17.27.23;	author markus;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.03.03.23.59.34;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.21.19.05.51;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.18.16.20.21;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.07.11.28.05;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.19.23.17.57;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.30.16.27.43;	author markus;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.09.12.20.53.10;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.07.21.13.37;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.07.20.27.52;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.04.00.07.59;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.11.24.19.53.47;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	99.11.24.00.26.02;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.11.19.16.04.17;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.11.10.23.36.44;	author markus;	state Exp;
branches;
next	;

1.7.2.1
date	2000.11.08.21.30.55;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.03.12.15.44.11;	author jason;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.03.21.18.52.49;	author jason;	state Exp;
branches;
next	;

1.11.2.1
date	2001.02.16.20.13.05;	author jason;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.02.19.17.19.02;	author jason;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.03.21.19.46.25;	author jason;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2001.05.07.21.09.30;	author jason;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.17.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.18.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.22.2.1
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.24.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.25.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.28.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	;

1.29.8.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.29.10.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.50
log
@allow LogLevel in sshd_config Match blocks; ok dtucker bz#2717
@
text
@/* $OpenBSD: log.c,v 1.49 2017/03/10 03:15:58 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <errno.h>
#include <vis.h>

#include "log.h"

static LogLevel log_level = SYSLOG_LEVEL_INFO;
static int log_on_stderr = 1;
static int log_stderr_fd = STDERR_FILENO;
static int log_facility = LOG_AUTH;
static char *argv0;
static log_handler_fn *log_handler;
static void *log_handler_ctx;

extern char *__progname;

/* textual representation of log-facilities/levels */

static struct {
	const char *name;
	SyslogFacility val;
} log_facilities[] = {
	{ "DAEMON",	SYSLOG_FACILITY_DAEMON },
	{ "USER",	SYSLOG_FACILITY_USER },
	{ "AUTH",	SYSLOG_FACILITY_AUTH },
	{ "LOCAL0",	SYSLOG_FACILITY_LOCAL0 },
	{ "LOCAL1",	SYSLOG_FACILITY_LOCAL1 },
	{ "LOCAL2",	SYSLOG_FACILITY_LOCAL2 },
	{ "LOCAL3",	SYSLOG_FACILITY_LOCAL3 },
	{ "LOCAL4",	SYSLOG_FACILITY_LOCAL4 },
	{ "LOCAL5",	SYSLOG_FACILITY_LOCAL5 },
	{ "LOCAL6",	SYSLOG_FACILITY_LOCAL6 },
	{ "LOCAL7",	SYSLOG_FACILITY_LOCAL7 },
	{ NULL,		SYSLOG_FACILITY_NOT_SET }
};

static struct {
	const char *name;
	LogLevel val;
} log_levels[] =
{
	{ "QUIET",	SYSLOG_LEVEL_QUIET },
	{ "FATAL",	SYSLOG_LEVEL_FATAL },
	{ "ERROR",	SYSLOG_LEVEL_ERROR },
	{ "INFO",	SYSLOG_LEVEL_INFO },
	{ "VERBOSE",	SYSLOG_LEVEL_VERBOSE },
	{ "DEBUG",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG1",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG2",	SYSLOG_LEVEL_DEBUG2 },
	{ "DEBUG3",	SYSLOG_LEVEL_DEBUG3 },
	{ NULL,		SYSLOG_LEVEL_NOT_SET }
};

SyslogFacility
log_facility_number(char *name)
{
	int i;

	if (name != NULL)
		for (i = 0; log_facilities[i].name; i++)
			if (strcasecmp(log_facilities[i].name, name) == 0)
				return log_facilities[i].val;
	return SYSLOG_FACILITY_NOT_SET;
}

const char *
log_facility_name(SyslogFacility facility)
{
	u_int i;

	for (i = 0;  log_facilities[i].name; i++)
		if (log_facilities[i].val == facility)
			return log_facilities[i].name;
	return NULL;
}

LogLevel
log_level_number(char *name)
{
	int i;

	if (name != NULL)
		for (i = 0; log_levels[i].name; i++)
			if (strcasecmp(log_levels[i].name, name) == 0)
				return log_levels[i].val;
	return SYSLOG_LEVEL_NOT_SET;
}

const char *
log_level_name(LogLevel level)
{
	u_int i;

	for (i = 0; log_levels[i].name != NULL; i++)
		if (log_levels[i].val == level)
			return log_levels[i].name;
	return NULL;
}

/* Error messages that should be logged. */

void
error(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_ERROR, fmt, args);
	va_end(args);
}

void
sigdie(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	_exit(1);
}

void
logdie(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_INFO, fmt, args);
	va_end(args);
	cleanup_exit(255);
}

/* Log this message (information that usually should go to the log). */

void
logit(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_INFO, fmt, args);
	va_end(args);
}

/* More detailed messages (information that does not need to go to the log). */

void
verbose(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_VERBOSE, fmt, args);
	va_end(args);
}

/* Debugging messages that should not be logged during normal operation. */

void
debug(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_DEBUG1, fmt, args);
	va_end(args);
}

void
debug2(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_DEBUG2, fmt, args);
	va_end(args);
}

void
debug3(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_DEBUG3, fmt, args);
	va_end(args);
}

/*
 * Initialize the log.
 */

void
log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
{
	argv0 = av0;

	if (log_change_level(level) != 0) {
		fprintf(stderr, "Unrecognized internal syslog level code %d\n",
		    (int) level);
		exit(1);
	}

	log_handler = NULL;
	log_handler_ctx = NULL;

	log_on_stderr = on_stderr;
	if (on_stderr)
		return;

	switch (facility) {
	case SYSLOG_FACILITY_DAEMON:
		log_facility = LOG_DAEMON;
		break;
	case SYSLOG_FACILITY_USER:
		log_facility = LOG_USER;
		break;
	case SYSLOG_FACILITY_AUTH:
		log_facility = LOG_AUTH;
		break;
	case SYSLOG_FACILITY_LOCAL0:
		log_facility = LOG_LOCAL0;
		break;
	case SYSLOG_FACILITY_LOCAL1:
		log_facility = LOG_LOCAL1;
		break;
	case SYSLOG_FACILITY_LOCAL2:
		log_facility = LOG_LOCAL2;
		break;
	case SYSLOG_FACILITY_LOCAL3:
		log_facility = LOG_LOCAL3;
		break;
	case SYSLOG_FACILITY_LOCAL4:
		log_facility = LOG_LOCAL4;
		break;
	case SYSLOG_FACILITY_LOCAL5:
		log_facility = LOG_LOCAL5;
		break;
	case SYSLOG_FACILITY_LOCAL6:
		log_facility = LOG_LOCAL6;
		break;
	case SYSLOG_FACILITY_LOCAL7:
		log_facility = LOG_LOCAL7;
		break;
	default:
		fprintf(stderr,
		    "Unrecognized internal syslog facility code %d\n",
		    (int) facility);
		exit(1);
	}
}

int
log_change_level(LogLevel new_log_level)
{
	/* no-op if log_init has not been called */
	if (argv0 == NULL)
		return 0;

	switch (new_log_level) {
	case SYSLOG_LEVEL_QUIET:
	case SYSLOG_LEVEL_FATAL:
	case SYSLOG_LEVEL_ERROR:
	case SYSLOG_LEVEL_INFO:
	case SYSLOG_LEVEL_VERBOSE:
	case SYSLOG_LEVEL_DEBUG1:
	case SYSLOG_LEVEL_DEBUG2:
	case SYSLOG_LEVEL_DEBUG3:
		log_level = new_log_level;
		return 0;
	default:
		return -1;
	}
}

int
log_is_on_stderr(void)
{
	return log_on_stderr && log_stderr_fd == STDERR_FILENO;
}

/* redirect what would usually get written to stderr to specified file */
void
log_redirect_stderr_to(const char *logfile)
{
	int fd;

	if ((fd = open(logfile, O_WRONLY|O_CREAT|O_APPEND, 0600)) == -1) {
		fprintf(stderr, "Couldn't open logfile %s: %s\n", logfile,
		     strerror(errno));
		exit(1);
	}
	log_stderr_fd = fd;
}

#define MSGBUFSIZ 1024

void
set_log_handler(log_handler_fn *handler, void *ctx)
{
	log_handler = handler;
	log_handler_ctx = ctx;
}

void
do_log2(LogLevel level, const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(level, fmt, args);
	va_end(args);
}

void
do_log(LogLevel level, const char *fmt, va_list args)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;
	char msgbuf[MSGBUFSIZ];
	char fmtbuf[MSGBUFSIZ];
	char *txt = NULL;
	int pri = LOG_INFO;
	int saved_errno = errno;
	log_handler_fn *tmp_handler;

	if (level > log_level)
		return;

	switch (level) {
	case SYSLOG_LEVEL_FATAL:
		if (!log_on_stderr)
			txt = "fatal";
		pri = LOG_CRIT;
		break;
	case SYSLOG_LEVEL_ERROR:
		if (!log_on_stderr)
			txt = "error";
		pri = LOG_ERR;
		break;
	case SYSLOG_LEVEL_INFO:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_VERBOSE:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_DEBUG1:
		txt = "debug1";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG2:
		txt = "debug2";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG3:
		txt = "debug3";
		pri = LOG_DEBUG;
		break;
	default:
		txt = "internal error";
		pri = LOG_ERR;
		break;
	}
	if (txt != NULL && log_handler == NULL) {
		snprintf(fmtbuf, sizeof(fmtbuf), "%s: %s", txt, fmt);
		vsnprintf(msgbuf, sizeof(msgbuf), fmtbuf, args);
	} else {
		vsnprintf(msgbuf, sizeof(msgbuf), fmt, args);
	}
	strnvis(fmtbuf, msgbuf, sizeof(fmtbuf), VIS_SAFE|VIS_OCTAL);
	if (log_handler != NULL) {
		/* Avoid recursion */
		tmp_handler = log_handler;
		log_handler = NULL;
		tmp_handler(level, fmtbuf, log_handler_ctx);
		log_handler = tmp_handler;
	} else if (log_on_stderr) {
		snprintf(msgbuf, sizeof msgbuf, "%.*s\r\n",
		    (int)sizeof msgbuf - 3, fmtbuf);
		(void)write(log_stderr_fd, msgbuf, strlen(msgbuf));
	} else {
		openlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);
		syslog_r(pri, &sdata, "%.500s", fmtbuf);
		closelog_r(&sdata);
	}
	errno = saved_errno;
}
@


1.49
log
@don't truncate off \r\n from long stderr lines; bz#2688, reported by
Brian Dyson; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.48 2016/07/15 05:01:58 dtucker Exp $ */
d243 1
a243 12
	switch (level) {
	case SYSLOG_LEVEL_QUIET:
	case SYSLOG_LEVEL_FATAL:
	case SYSLOG_LEVEL_ERROR:
	case SYSLOG_LEVEL_INFO:
	case SYSLOG_LEVEL_VERBOSE:
	case SYSLOG_LEVEL_DEBUG1:
	case SYSLOG_LEVEL_DEBUG2:
	case SYSLOG_LEVEL_DEBUG3:
		log_level = level;
		break;
	default:
d298 1
a298 1
void
d303 16
a318 2
		return;
	log_init(argv0, new_log_level, log_facility, log_on_stderr);
@


1.48
log
@Reduce the syslog level of some relatively common protocol events
from LOG_CRIT by replacing fatal() calls with logdie().  Part of
bz#2585, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.47 2016/04/29 08:07:53 djm Exp $ */
d419 2
a420 1
		snprintf(msgbuf, sizeof msgbuf, "%s\r\n", fmtbuf);
@


1.47
log
@close ControlPersist background process stderr when not in
debug mode or when logging to a file or syslog.
bz#1988 ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.46 2015/07/08 19:04:21 markus Exp $ */
d167 10
@


1.46
log
@xmalloc.h is unused
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.45 2013/05/16 09:08:41 dtucker Exp $ */
d311 1
a311 1
	return log_on_stderr;
@


1.45
log
@Fix some "unused result" warnings found via clang and -portable.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.44 2013/04/07 02:10:33 dtucker Exp $ */
a48 1
#include "xmalloc.h"
@


1.44
log
@Add -E option to ssh and sshd to append debugging logs to a specified file
instead of stderr or syslog.  ok markus@@, man page help jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.43 2012/09/06 04:37:39 dtucker Exp $ */
d411 1
a411 1
		write(log_stderr_fd, msgbuf, strlen(msgbuf));
@


1.43
log
@Add ~v and ~V escape sequences to raise and lower the logging level
respectively. Man page help from jmc, ok deraadt jmc
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.42 2011/06/17 21:44:30 djm Exp $ */
d39 1
d54 1
d315 14
d411 1
a411 1
		write(STDERR_FILENO, msgbuf, strlen(msgbuf));
@


1.42
log
@make the pre-auth privsep slave log via a socketpair shared with the
monitor rather than /var/empty/dev/log; ok dtucker@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.41 2008/06/10 04:50:25 dtucker Exp $ */
d296 15
@


1.41
log
@Add extended test mode (-T) and connection parameters for test mode (-C).
-T causes sshd to write its effective configuration to stdout and exit.
-C causes any relevant Match rules to be applied before output.  The
combination allows tesing of the parser and config files.  ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.40 2007/05/17 07:50:31 djm Exp $ */
d55 2
d249 3
d301 17
d326 1
d365 1
a365 1
	if (txt != NULL) {
d372 7
a378 1
	if (log_on_stderr) {
@


1.40
log
@save and restore errno when logging; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.39 2006/08/18 09:13:25 deraadt Exp $ */
d107 11
d128 11
@


1.39
log
@make signal handler termination path shorter; risky code pointed out by
mark dowd; ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.38 2006/08/03 03:34:42 deraadt Exp $ */
d45 1
d281 1
d335 1
@


1.38
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.37 2006/08/01 23:22:47 stevesk Exp $ */
d129 12
@


1.37
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.36 2006/07/26 13:57:17 stevesk Exp $ */
d37 1
a37 1
#include "includes.h"
d47 1
a48 1
#include "xmalloc.h"
@


1.36
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.35 2006/07/22 20:48:23 stevesk Exp $ */
d40 1
@


1.35
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.34 2006/07/17 01:31:09 stevesk Exp $ */
d40 1
@


1.34
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.33 2006/07/10 16:37:36 stevesk Exp $ */
d40 1
@


1.33
log
@move #include <stdarg.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.32 2006/07/08 23:30:06 stevesk Exp $ */
d41 1
@


1.32
log
@move user includes after /usr/include files
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.31 2006/03/25 13:17:02 djm Exp $ */
d39 1
@


1.31
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d39 3
a43 3

#include <syslog.h>
#include <vis.h>
@


1.30
log
@RCSID() can die
@
text
@d1 1
@


1.29
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@a36 1
RCSID("$OpenBSD: log.c,v 1.28 2003/05/24 09:02:22 djm Exp $");
@


1.29.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: log.c,v 1.39 2006/08/18 09:13:25 deraadt Exp $ */
d36 5
a40 1
#include <sys/types.h>
a41 4
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
a42 1
#include <unistd.h>
a44 3
#include "xmalloc.h"
#include "log.h"

a123 12

void
sigdie(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	_exit(1);
}

@


1.29.10.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: log.c,v 1.39 2006/08/18 09:13:25 deraadt Exp $ */
d36 5
a40 1
#include <sys/types.h>
a41 4
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
a42 1
#include <unistd.h>
a44 3
#include "xmalloc.h"
#include "log.h"

a123 12

void
sigdie(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	_exit(1);
}

@


1.28
log
@pass logged data through strnvis; ok markus
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.27 2003/05/18 23:22:01 deraadt Exp $");
a179 77

/* Fatal cleanup */

struct fatal_cleanup {
	struct fatal_cleanup *next;
	void (*proc) (void *);
	void *context;
};

static struct fatal_cleanup *fatal_cleanups = NULL;

/* Registers a cleanup function to be called by fatal() before exiting. */

void
fatal_add_cleanup(void (*proc) (void *), void *context)
{
	struct fatal_cleanup *cu;

	cu = xmalloc(sizeof(*cu));
	cu->proc = proc;
	cu->context = context;
	cu->next = fatal_cleanups;
	fatal_cleanups = cu;
}

/* Removes a cleanup frunction to be called at fatal(). */

void
fatal_remove_cleanup(void (*proc) (void *context), void *context)
{
	struct fatal_cleanup **cup, *cu;

	for (cup = &fatal_cleanups; *cup; cup = &cu->next) {
		cu = *cup;
		if (cu->proc == proc && cu->context == context) {
			*cup = cu->next;
			xfree(cu);
			return;
		}
	}
	fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx",
	    (u_long) proc, (u_long) context);
}

/* Remove all cleanups, to be called after fork() */
void
fatal_remove_all_cleanups(void)
{
	struct fatal_cleanup *cu, *next_cu;

	for (cu = fatal_cleanups; cu; cu = next_cu) {
		next_cu = cu->next;
		xfree(cu);
	}
	fatal_cleanups = NULL;
}

/* Cleanup and exit */
void
fatal_cleanup(void)
{
	struct fatal_cleanup *cu, *next_cu;
	static int called = 0;

	if (called)
		exit(255);
	called = 1;
	/* Call cleanup functions. */
	for (cu = fatal_cleanups; cu; cu = next_cu) {
		next_cu = cu->next;
		debug("Calling cleanup 0x%lx(0x%lx)",
		    (u_long) cu->proc, (u_long) cu->context);
		(*cu->proc) (cu->context);
	}
	exit(255);
}

@


1.28.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.29 2003/09/23 20:17:11 markus Exp $");
d180 77
@


1.27
log
@use syslog_r() in a signal handler called place; markus ok
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.26 2003/04/08 20:21:28 itojun Exp $");
d43 1
d384 1
d386 2
a387 2
		snprintf(fmtbuf, sizeof fmtbuf, "%s\r\n", msgbuf);
		write(STDERR_FILENO, fmtbuf, strlen(fmtbuf));
d390 1
a390 1
		syslog_r(pri, &sdata, "%.500s", msgbuf);
@


1.26
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.25 2003/01/11 18:29:43 markus Exp $");
d334 1
d384 2
a385 1
		fprintf(stderr, "%s\r\n", msgbuf);
d387 3
a389 3
		openlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);
		syslog(pri, "%.500s", msgbuf);
		closelog();
@


1.25
log
@set fatal_cleanups to NULL in fatal_remove_all_cleanups(); dtucker@@zip.com.au
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.24 2002/07/19 15:43:33 markus Exp $");
d127 1
a127 1
log(const char *fmt,...)
@


1.25.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.28 2003/05/24 09:02:22 djm Exp $");
a42 1
#include <vis.h>
d127 1
a127 1
logit(const char *fmt,...)
a333 1
	struct syslog_data sdata = SYSLOG_DATA_INIT;
a381 1
	strnvis(fmtbuf, msgbuf, sizeof(fmtbuf), VIS_SAFE|VIS_OCTAL);
d383 1
a383 2
		snprintf(msgbuf, sizeof msgbuf, "%s\r\n", fmtbuf);
		write(STDERR_FILENO, msgbuf, strlen(msgbuf));
d385 3
a387 3
		openlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);
		syslog_r(pri, &sdata, "%.500s", fmtbuf);
		closelog_r(&sdata);
@


1.25.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.29 2003/09/23 20:17:11 markus Exp $");
d180 77
@


1.24
log
@remove fatal cleanups after fork; based on discussions with and code
from solar.
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.23 2002/07/06 01:00:49 deraadt Exp $");
d233 1
@


1.24.2.1
log
@Update to OpenSSH 3.6
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.25 2003/01/11 18:29:43 markus Exp $");
a232 1
	fatal_cleanups = NULL;
@


1.24.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.28 2003/05/24 09:02:22 djm Exp $");
a42 1
#include <vis.h>
d127 1
a127 1
logit(const char *fmt,...)
a333 1
	struct syslog_data sdata = SYSLOG_DATA_INIT;
a381 1
	strnvis(fmtbuf, msgbuf, sizeof(fmtbuf), VIS_SAFE|VIS_OCTAL);
d383 1
a383 2
		snprintf(msgbuf, sizeof msgbuf, "%s\r\n", fmtbuf);
		write(STDERR_FILENO, msgbuf, strlen(msgbuf));
d385 3
a387 3
		openlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);
		syslog_r(pri, &sdata, "%.500s", fmtbuf);
		closelog_r(&sdata);
@


1.23
log
@KNF
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.22 2002/02/22 12:20:34 markus Exp $");
d221 12
@


1.22
log
@overwrite fatal() in ssh-keyscan.c; fixes pr 2354; ok provos@@
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.21 2002/02/04 12:15:25 markus Exp $");
d92 1
d104 1
d118 1
d130 1
d142 1
d154 1
d164 1
d174 1
@


1.22.2.1
log
@Update to OpenSSH 3.5
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.24 2002/07/19 15:43:33 markus Exp $");
a91 1

a102 1

a115 1

a126 1

a137 1

a148 1

a157 1

a166 1

a212 12
}

/* Remove all cleanups, to be called after fork() */
void
fatal_remove_all_cleanups(void)
{
	struct fatal_cleanup *cu, *next_cu;

	for (cu = fatal_cleanups; cu; cu = next_cu) {
		next_cu = cu->next;
		xfree(cu);
	}
@


1.22.2.2
log
@Merge OpenSSH 3.6.1
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.25 2003/01/11 18:29:43 markus Exp $");
a232 1
	fatal_cleanups = NULL;
@


1.21
log
@add SYSLOG_FACILITY_NOT_SET = -1, SYSLOG_LEVEL_NOT_SET = -1,
fixes arm/netbsd; based on patch from bjh21@@netbsd.org; ok djm@@
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.20 2002/01/17 04:27:37 stevesk Exp $");
a87 2
static void	 do_log(LogLevel level, const char *fmt, va_list args);

a108 11
/* Fatal messages.  This function never returns. */

void
fatal(const char *fmt,...)
{
	va_list args;
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	fatal_cleanup();
}
d310 1
a310 1
static void
@


1.20
log
@casts to silence enum type warnings for bugzilla bug 37; ok markus@@
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.19 2001/12/19 07:18:56 deraadt Exp $");
d68 1
a68 1
	{ NULL, (SyslogFacility)0 }
d85 1
a85 1
	{ NULL, (LogLevel)0 }
d98 1
a98 1
	return (SyslogFacility) - 1;
d109 1
a109 1
	return (LogLevel) - 1;
@


1.19
log
@basic KNF done while i was looking for something else
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.18 2001/06/26 17:27:23 markus Exp $");
d68 1
a68 1
	{ NULL, 0 }
d85 1
a85 1
	{ NULL, 0 }
@


1.18
log
@remove comments from .h, since they are cut&paste from the .c files
and out of sync
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.17 2001/03/04 17:42:28 millert Exp $");
d242 1
a242 1
		      (u_long) cu->proc, (u_long) cu->context);
@


1.18.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.22 2002/02/22 12:20:34 markus Exp $");
d68 1
a68 1
	{ NULL,		SYSLOG_FACILITY_NOT_SET }
d85 1
a85 1
	{ NULL,		SYSLOG_LEVEL_NOT_SET }
d88 2
d98 1
a98 1
	return SYSLOG_FACILITY_NOT_SET;
d109 12
a120 1
	return SYSLOG_LEVEL_NOT_SET;
d242 1
a242 1
		    (u_long) cu->proc, (u_long) cu->context);
d323 1
a323 1
void
@


1.18.2.2
log
@Update to OpenSSH 3.5
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.24 2002/07/19 15:43:33 markus Exp $");
a91 1

a102 1

a115 1

a126 1

a137 1

a148 1

a157 1

a166 1

a212 12
}

/* Remove all cleanups, to be called after fork() */
void
fatal_remove_all_cleanups(void)
{
	struct fatal_cleanup *cu, *next_cu;

	for (cu = fatal_cleanups; cu; cu = next_cu) {
		next_cu = cu->next;
		xfree(cu);
	}
@


1.17
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.16 2001/03/03 23:59:34 markus Exp $");
d88 2
d323 1
a323 1
void
@


1.17.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.18 2001/06/26 17:27:23 markus Exp $");
a87 2
static void	 do_log(LogLevel level, const char *fmt, va_list args);

d321 1
a321 1
static void
@


1.17.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.22 2002/02/22 12:20:34 markus Exp $");
d68 1
a68 1
	{ NULL,		SYSLOG_FACILITY_NOT_SET }
d85 1
a85 1
	{ NULL,		SYSLOG_LEVEL_NOT_SET }
d88 2
d98 1
a98 1
	return SYSLOG_FACILITY_NOT_SET;
d109 12
a120 1
	return SYSLOG_LEVEL_NOT_SET;
d242 1
a242 1
		    (u_long) cu->proc, (u_long) cu->context);
d323 1
a323 1
void
@


1.16
log
@log*.c -> log.c
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.15 2001/01/21 19:05:51 markus Exp $");
d222 1
a222 1
	fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n",
@


1.15
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@a12 2
 * Shared versions of debug(), log(), etc.
 *
d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.14 2001/01/18 16:20:21 markus Exp $");
d42 67
d223 1
a223 1
	      (u_long) proc, (u_long) context);
a245 1
/* textual representation of log-facilities/levels */
d247 3
a249 17
static struct {
	const char *name;
	SyslogFacility val;
} log_facilities[] = {
	{ "DAEMON",	SYSLOG_FACILITY_DAEMON },
	{ "USER",	SYSLOG_FACILITY_USER },
	{ "AUTH",	SYSLOG_FACILITY_AUTH },
	{ "LOCAL0",	SYSLOG_FACILITY_LOCAL0 },
	{ "LOCAL1",	SYSLOG_FACILITY_LOCAL1 },
	{ "LOCAL2",	SYSLOG_FACILITY_LOCAL2 },
	{ "LOCAL3",	SYSLOG_FACILITY_LOCAL3 },
	{ "LOCAL4",	SYSLOG_FACILITY_LOCAL4 },
	{ "LOCAL5",	SYSLOG_FACILITY_LOCAL5 },
	{ "LOCAL6",	SYSLOG_FACILITY_LOCAL6 },
	{ "LOCAL7",	SYSLOG_FACILITY_LOCAL7 },
	{ NULL, 0 }
};
d251 2
a252 4
static struct {
	const char *name;
	LogLevel val;
} log_levels[] =
d254 18
a271 11
	{ "QUIET",	SYSLOG_LEVEL_QUIET },
	{ "FATAL",	SYSLOG_LEVEL_FATAL },
	{ "ERROR",	SYSLOG_LEVEL_ERROR },
	{ "INFO",	SYSLOG_LEVEL_INFO },
	{ "VERBOSE",	SYSLOG_LEVEL_VERBOSE },
	{ "DEBUG",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG1",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG2",	SYSLOG_LEVEL_DEBUG2 },
	{ "DEBUG3",	SYSLOG_LEVEL_DEBUG3 },
	{ NULL, 0 }
};
d273 44
a316 9
SyslogFacility
log_facility_number(char *name)
{
	int i;
	if (name != NULL)
		for (i = 0; log_facilities[i].name; i++)
			if (strcasecmp(log_facilities[i].name, name) == 0)
				return log_facilities[i].val;
	return (SyslogFacility) - 1;
d319 4
a322 2
LogLevel
log_level_number(char *name)
d324 55
a378 6
	int i;
	if (name != NULL)
		for (i = 0; log_levels[i].name; i++)
			if (strcasecmp(log_levels[i].name, name) == 0)
				return log_levels[i].val;
	return (LogLevel) - 1;
@


1.14
log
@log() is at pri=LOG_INFO, since LOG_NOTICE goes to /dev/console on many systems
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.13 2001/01/07 11:28:05 markus Exp $");
d41 1
a41 1
#include "ssh.h"
@


1.13
log
@rename SYSLOG_LEVEL_INFO->SYSLOG_LEVEL_NOTICE
syslog priority changes:
	fatal() LOG_ERR  -> LOG_CRIT
	log()   LOG_INFO -> LOG_NOTICE
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.12 2000/12/19 23:17:57 markus Exp $");
d74 1
a74 1
	do_log(SYSLOG_LEVEL_NOTICE, fmt, args);
d209 1
a209 1
	{ "NOTICE",	SYSLOG_LEVEL_NOTICE },
a214 1
	{ "INFO",	SYSLOG_LEVEL_NOTICE },	/* backward compatible */
@


1.12
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.11 2000/09/30 16:27:43 markus Exp $");
d74 1
a74 1
	do_log(SYSLOG_LEVEL_INFO, fmt, args);
d209 1
a209 1
	{ "INFO",	SYSLOG_LEVEL_INFO },
d215 1
@


1.11
log
@allow loglevel debug
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.10 2000/09/12 20:53:10 markus Exp $");
d158 1
a158 1
	      (unsigned long) proc, (unsigned long) context);
d175 1
a175 1
		      (unsigned long) cu->proc, (unsigned long) cu->context);
@


1.11.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.15 2001/01/21 19:05:51 markus Exp $");
d41 1
a41 1
#include "log.h"
d158 1
a158 1
	      (u_long) proc, (u_long) context);
d175 1
a175 1
		      (u_long) cu->proc, (u_long) cu->context);
@


1.11.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.11.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d13 2
d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.17 2001/03/04 17:42:28 millert Exp $");
a43 67
#include <syslog.h>

static LogLevel log_level = SYSLOG_LEVEL_INFO;
static int log_on_stderr = 1;
static int log_facility = LOG_AUTH;
static char *argv0;

extern char *__progname;

/* textual representation of log-facilities/levels */

static struct {
	const char *name;
	SyslogFacility val;
} log_facilities[] = {
	{ "DAEMON",	SYSLOG_FACILITY_DAEMON },
	{ "USER",	SYSLOG_FACILITY_USER },
	{ "AUTH",	SYSLOG_FACILITY_AUTH },
	{ "LOCAL0",	SYSLOG_FACILITY_LOCAL0 },
	{ "LOCAL1",	SYSLOG_FACILITY_LOCAL1 },
	{ "LOCAL2",	SYSLOG_FACILITY_LOCAL2 },
	{ "LOCAL3",	SYSLOG_FACILITY_LOCAL3 },
	{ "LOCAL4",	SYSLOG_FACILITY_LOCAL4 },
	{ "LOCAL5",	SYSLOG_FACILITY_LOCAL5 },
	{ "LOCAL6",	SYSLOG_FACILITY_LOCAL6 },
	{ "LOCAL7",	SYSLOG_FACILITY_LOCAL7 },
	{ NULL, 0 }
};

static struct {
	const char *name;
	LogLevel val;
} log_levels[] =
{
	{ "QUIET",	SYSLOG_LEVEL_QUIET },
	{ "FATAL",	SYSLOG_LEVEL_FATAL },
	{ "ERROR",	SYSLOG_LEVEL_ERROR },
	{ "INFO",	SYSLOG_LEVEL_INFO },
	{ "VERBOSE",	SYSLOG_LEVEL_VERBOSE },
	{ "DEBUG",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG1",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG2",	SYSLOG_LEVEL_DEBUG2 },
	{ "DEBUG3",	SYSLOG_LEVEL_DEBUG3 },
	{ NULL, 0 }
};

SyslogFacility
log_facility_number(char *name)
{
	int i;
	if (name != NULL)
		for (i = 0; log_facilities[i].name; i++)
			if (strcasecmp(log_facilities[i].name, name) == 0)
				return log_facilities[i].val;
	return (SyslogFacility) - 1;
}

LogLevel
log_level_number(char *name)
{
	int i;
	if (name != NULL)
		for (i = 0; log_levels[i].name; i++)
			if (strcasecmp(log_levels[i].name, name) == 0)
				return log_levels[i].val;
	return (LogLevel) - 1;
}
d157 2
a158 2
	fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx",
	    (u_long) proc, (u_long) context);
d181 1
d183 17
a199 3
/*
 * Initialize the log.
 */
d201 4
a204 2
void
log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
d206 11
a216 1
	argv0 = av0;
d218 9
a226 61
	switch (level) {
	case SYSLOG_LEVEL_QUIET:
	case SYSLOG_LEVEL_FATAL:
	case SYSLOG_LEVEL_ERROR:
	case SYSLOG_LEVEL_INFO:
	case SYSLOG_LEVEL_VERBOSE:
	case SYSLOG_LEVEL_DEBUG1:
	case SYSLOG_LEVEL_DEBUG2:
	case SYSLOG_LEVEL_DEBUG3:
		log_level = level;
		break;
	default:
		fprintf(stderr, "Unrecognized internal syslog level code %d\n",
		    (int) level);
		exit(1);
	}

	log_on_stderr = on_stderr;
	if (on_stderr)
		return;

	switch (facility) {
	case SYSLOG_FACILITY_DAEMON:
		log_facility = LOG_DAEMON;
		break;
	case SYSLOG_FACILITY_USER:
		log_facility = LOG_USER;
		break;
	case SYSLOG_FACILITY_AUTH:
		log_facility = LOG_AUTH;
		break;
	case SYSLOG_FACILITY_LOCAL0:
		log_facility = LOG_LOCAL0;
		break;
	case SYSLOG_FACILITY_LOCAL1:
		log_facility = LOG_LOCAL1;
		break;
	case SYSLOG_FACILITY_LOCAL2:
		log_facility = LOG_LOCAL2;
		break;
	case SYSLOG_FACILITY_LOCAL3:
		log_facility = LOG_LOCAL3;
		break;
	case SYSLOG_FACILITY_LOCAL4:
		log_facility = LOG_LOCAL4;
		break;
	case SYSLOG_FACILITY_LOCAL5:
		log_facility = LOG_LOCAL5;
		break;
	case SYSLOG_FACILITY_LOCAL6:
		log_facility = LOG_LOCAL6;
		break;
	case SYSLOG_FACILITY_LOCAL7:
		log_facility = LOG_LOCAL7;
		break;
	default:
		fprintf(stderr,
		    "Unrecognized internal syslog facility code %d\n",
		    (int) facility);
		exit(1);
	}
d229 2
a230 4
#define MSGBUFSIZ 1024

void
do_log(LogLevel level, const char *fmt, va_list args)
d232 6
a237 55
	char msgbuf[MSGBUFSIZ];
	char fmtbuf[MSGBUFSIZ];
	char *txt = NULL;
	int pri = LOG_INFO;

	if (level > log_level)
		return;

	switch (level) {
	case SYSLOG_LEVEL_FATAL:
		if (!log_on_stderr)
			txt = "fatal";
		pri = LOG_CRIT;
		break;
	case SYSLOG_LEVEL_ERROR:
		if (!log_on_stderr)
			txt = "error";
		pri = LOG_ERR;
		break;
	case SYSLOG_LEVEL_INFO:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_VERBOSE:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_DEBUG1:
		txt = "debug1";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG2:
		txt = "debug2";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG3:
		txt = "debug3";
		pri = LOG_DEBUG;
		break;
	default:
		txt = "internal error";
		pri = LOG_ERR;
		break;
	}
	if (txt != NULL) {
		snprintf(fmtbuf, sizeof(fmtbuf), "%s: %s", txt, fmt);
		vsnprintf(msgbuf, sizeof(msgbuf), fmtbuf, args);
	} else {
		vsnprintf(msgbuf, sizeof(msgbuf), fmt, args);
	}
	if (log_on_stderr) {
		fprintf(stderr, "%s\r\n", msgbuf);
	} else {
		openlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);
		syslog(pri, "%.500s", msgbuf);
		closelog();
	}
@


1.11.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.11.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.18 2001/06/26 17:27:23 markus Exp $");
a87 2
static void	 do_log(LogLevel level, const char *fmt, va_list args);

d321 1
a321 1
static void
@


1.11.2.6
log
@Merge OpenSSH 3.1.
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.22 2002/02/22 12:20:34 markus Exp $");
d68 1
a68 1
	{ NULL,		SYSLOG_FACILITY_NOT_SET }
d85 1
a85 1
	{ NULL,		SYSLOG_LEVEL_NOT_SET }
d88 2
d98 1
a98 1
	return SYSLOG_FACILITY_NOT_SET;
d109 12
a120 1
	return SYSLOG_LEVEL_NOT_SET;
d242 1
a242 1
		    (u_long) cu->proc, (u_long) cu->context);
d323 1
a323 1
void
@


1.10
log
@multiple debug levels
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.9 2000/09/07 21:13:37 markus Exp $");
d211 1
@


1.9
log
@some more Copyright fixes
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.8 2000/09/07 20:27:52 deraadt Exp $");
d96 19
a114 1
	do_log(SYSLOG_LEVEL_DEBUG, fmt, args);
d211 3
a213 1
	{ "DEBUG",	SYSLOG_LEVEL_DEBUG },
@


1.8
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d2 11
d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.7 2000/01/04 00:07:59 markus Exp $");
@


1.7
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d3 22
d28 1
a28 1
RCSID("$OpenBSD: log.c,v 1.5 1999/11/24 00:26:02 deraadt Exp $");
@


1.7.2.1
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a1 11
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
a2 22
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d6 1
a6 1
RCSID("$OpenBSD: log.c,v 1.11 2000/09/30 16:27:43 markus Exp $");
d63 1
a63 19
	do_log(SYSLOG_LEVEL_DEBUG1, fmt, args);
	va_end(args);
}

void
debug2(const char *fmt,...)
{
	va_list args;
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_DEBUG2, fmt, args);
	va_end(args);
}

void
debug3(const char *fmt,...)
{
	va_list args;
	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_DEBUG3, fmt, args);
d160 1
a160 4
	{ "DEBUG",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG1",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG2",	SYSLOG_LEVEL_DEBUG2 },
	{ "DEBUG3",	SYSLOG_LEVEL_DEBUG3 },
@


1.7.2.2
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.15 2001/01/21 19:05:51 markus Exp $");
d41 1
a41 1
#include "log.h"
d158 1
a158 1
	      (u_long) proc, (u_long) context);
d175 1
a175 1
		      (u_long) cu->proc, (u_long) cu->context);
@


1.7.2.3
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d13 2
d39 1
a39 1
RCSID("$OpenBSD: log.c,v 1.17 2001/03/04 17:42:28 millert Exp $");
a43 67
#include <syslog.h>

static LogLevel log_level = SYSLOG_LEVEL_INFO;
static int log_on_stderr = 1;
static int log_facility = LOG_AUTH;
static char *argv0;

extern char *__progname;

/* textual representation of log-facilities/levels */

static struct {
	const char *name;
	SyslogFacility val;
} log_facilities[] = {
	{ "DAEMON",	SYSLOG_FACILITY_DAEMON },
	{ "USER",	SYSLOG_FACILITY_USER },
	{ "AUTH",	SYSLOG_FACILITY_AUTH },
	{ "LOCAL0",	SYSLOG_FACILITY_LOCAL0 },
	{ "LOCAL1",	SYSLOG_FACILITY_LOCAL1 },
	{ "LOCAL2",	SYSLOG_FACILITY_LOCAL2 },
	{ "LOCAL3",	SYSLOG_FACILITY_LOCAL3 },
	{ "LOCAL4",	SYSLOG_FACILITY_LOCAL4 },
	{ "LOCAL5",	SYSLOG_FACILITY_LOCAL5 },
	{ "LOCAL6",	SYSLOG_FACILITY_LOCAL6 },
	{ "LOCAL7",	SYSLOG_FACILITY_LOCAL7 },
	{ NULL, 0 }
};

static struct {
	const char *name;
	LogLevel val;
} log_levels[] =
{
	{ "QUIET",	SYSLOG_LEVEL_QUIET },
	{ "FATAL",	SYSLOG_LEVEL_FATAL },
	{ "ERROR",	SYSLOG_LEVEL_ERROR },
	{ "INFO",	SYSLOG_LEVEL_INFO },
	{ "VERBOSE",	SYSLOG_LEVEL_VERBOSE },
	{ "DEBUG",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG1",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG2",	SYSLOG_LEVEL_DEBUG2 },
	{ "DEBUG3",	SYSLOG_LEVEL_DEBUG3 },
	{ NULL, 0 }
};

SyslogFacility
log_facility_number(char *name)
{
	int i;
	if (name != NULL)
		for (i = 0; log_facilities[i].name; i++)
			if (strcasecmp(log_facilities[i].name, name) == 0)
				return log_facilities[i].val;
	return (SyslogFacility) - 1;
}

LogLevel
log_level_number(char *name)
{
	int i;
	if (name != NULL)
		for (i = 0; log_levels[i].name; i++)
			if (strcasecmp(log_levels[i].name, name) == 0)
				return log_levels[i].val;
	return (LogLevel) - 1;
}
d157 2
a158 2
	fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx",
	    (u_long) proc, (u_long) context);
d181 1
d183 17
a199 3
/*
 * Initialize the log.
 */
d201 4
a204 2
void
log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
d206 11
a216 1
	argv0 = av0;
d218 9
a226 61
	switch (level) {
	case SYSLOG_LEVEL_QUIET:
	case SYSLOG_LEVEL_FATAL:
	case SYSLOG_LEVEL_ERROR:
	case SYSLOG_LEVEL_INFO:
	case SYSLOG_LEVEL_VERBOSE:
	case SYSLOG_LEVEL_DEBUG1:
	case SYSLOG_LEVEL_DEBUG2:
	case SYSLOG_LEVEL_DEBUG3:
		log_level = level;
		break;
	default:
		fprintf(stderr, "Unrecognized internal syslog level code %d\n",
		    (int) level);
		exit(1);
	}

	log_on_stderr = on_stderr;
	if (on_stderr)
		return;

	switch (facility) {
	case SYSLOG_FACILITY_DAEMON:
		log_facility = LOG_DAEMON;
		break;
	case SYSLOG_FACILITY_USER:
		log_facility = LOG_USER;
		break;
	case SYSLOG_FACILITY_AUTH:
		log_facility = LOG_AUTH;
		break;
	case SYSLOG_FACILITY_LOCAL0:
		log_facility = LOG_LOCAL0;
		break;
	case SYSLOG_FACILITY_LOCAL1:
		log_facility = LOG_LOCAL1;
		break;
	case SYSLOG_FACILITY_LOCAL2:
		log_facility = LOG_LOCAL2;
		break;
	case SYSLOG_FACILITY_LOCAL3:
		log_facility = LOG_LOCAL3;
		break;
	case SYSLOG_FACILITY_LOCAL4:
		log_facility = LOG_LOCAL4;
		break;
	case SYSLOG_FACILITY_LOCAL5:
		log_facility = LOG_LOCAL5;
		break;
	case SYSLOG_FACILITY_LOCAL6:
		log_facility = LOG_LOCAL6;
		break;
	case SYSLOG_FACILITY_LOCAL7:
		log_facility = LOG_LOCAL7;
		break;
	default:
		fprintf(stderr,
		    "Unrecognized internal syslog facility code %d\n",
		    (int) facility);
		exit(1);
	}
d229 2
a230 4
#define MSGBUFSIZ 1024

void
do_log(LogLevel level, const char *fmt, va_list args)
d232 6
a237 55
	char msgbuf[MSGBUFSIZ];
	char fmtbuf[MSGBUFSIZ];
	char *txt = NULL;
	int pri = LOG_INFO;

	if (level > log_level)
		return;

	switch (level) {
	case SYSLOG_LEVEL_FATAL:
		if (!log_on_stderr)
			txt = "fatal";
		pri = LOG_CRIT;
		break;
	case SYSLOG_LEVEL_ERROR:
		if (!log_on_stderr)
			txt = "error";
		pri = LOG_ERR;
		break;
	case SYSLOG_LEVEL_INFO:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_VERBOSE:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_DEBUG1:
		txt = "debug1";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG2:
		txt = "debug2";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG3:
		txt = "debug3";
		pri = LOG_DEBUG;
		break;
	default:
		txt = "internal error";
		pri = LOG_ERR;
		break;
	}
	if (txt != NULL) {
		snprintf(fmtbuf, sizeof(fmtbuf), "%s: %s", txt, fmt);
		vsnprintf(msgbuf, sizeof(msgbuf), fmtbuf, args);
	} else {
		vsnprintf(msgbuf, sizeof(msgbuf), fmt, args);
	}
	if (log_on_stderr) {
		fprintf(stderr, "%s\r\n", msgbuf);
	} else {
		openlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);
		syslog(pri, "%.500s", msgbuf);
		closelog();
	}
@


1.6
log
@KNF, final part 3
@
text
@@


1.5
log
@much more KNF
@
text
@a1 1
 * 
d3 1
a3 2
 * 
*/
d6 1
a6 1
RCSID("$OpenBSD: log.c,v 1.4 1999/11/23 22:25:54 markus Exp $");
@


1.4
log
@KNF part 1
@
text
@d2 3
a4 3

Shared versions of debug(), log(), etc.

d8 1
a8 1
RCSID("$OpenBSD: log.c,v 1.3 1999/11/22 21:02:38 markus Exp $");
@


1.3
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d8 1
a8 1
RCSID("$OpenBSD: log.c,v 1.2 1999/11/19 16:04:17 markus Exp $");
d16 1
a16 1
fatal(const char *fmt, ...)
d18 5
a22 5
  va_list args;
  va_start(args, fmt);
  do_log(SYSLOG_LEVEL_FATAL, fmt, args);
  va_end(args);
  fatal_cleanup();
d28 1
a28 1
error(const char *fmt, ...)
d30 4
a33 4
  va_list args;
  va_start(args, fmt);
  do_log(SYSLOG_LEVEL_ERROR, fmt, args);
  va_end(args);
d39 1
a39 1
log(const char *fmt, ...)
d41 4
a44 4
  va_list args;
  va_start(args, fmt);
  do_log(SYSLOG_LEVEL_INFO, fmt, args);
  va_end(args);
d50 1
a50 1
verbose(const char *fmt, ...)
d52 4
a55 4
  va_list args;
  va_start(args, fmt);
  do_log(SYSLOG_LEVEL_VERBOSE, fmt, args);
  va_end(args);
d61 1
a61 1
debug(const char *fmt, ...)
d63 4
a66 4
  va_list args;
  va_start(args, fmt);
  do_log(SYSLOG_LEVEL_DEBUG, fmt, args);
  va_end(args);
d71 4
a74 5
struct fatal_cleanup
{
  struct fatal_cleanup *next;
  void (*proc)(void *);
  void *context;
d82 1
a82 1
fatal_add_cleanup(void (*proc)(void *), void *context)
d84 1
a84 1
  struct fatal_cleanup *cu;
d86 5
a90 5
  cu = xmalloc(sizeof(*cu));
  cu->proc = proc;
  cu->context = context;
  cu->next = fatal_cleanups;
  fatal_cleanups = cu;
d96 1
a96 1
fatal_remove_cleanup(void (*proc)(void *context), void *context)
d98 9
a106 10
  struct fatal_cleanup **cup, *cu;
  
  for (cup = &fatal_cleanups; *cup; cup = &cu->next)
    {
      cu = *cup;
      if (cu->proc == proc && cu->context == context)
	{
	  *cup = cu->next;
	  xfree(cu);
	  return;
d108 2
a109 3
    }
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n",
	(unsigned long)proc, (unsigned long)context);
d116 2
a117 14
  struct fatal_cleanup *cu, *next_cu;
  static int called = 0;
  if (called)
    exit(255);
  called = 1;

  /* Call cleanup functions. */
  for (cu = fatal_cleanups; cu; cu = next_cu)
    {
      next_cu = cu->next;
      debug("Calling cleanup 0x%lx(0x%lx)",
	    (unsigned long)cu->proc, (unsigned long)cu->context);
      (*cu->proc)(cu->context);
    }
d119 11
a129 1
  exit(255);
d134 16
a149 19

static struct 
{
  const char *name;
  SyslogFacility val;
} log_facilities[] =
{
  { "DAEMON", SYSLOG_FACILITY_DAEMON },
  { "USER", SYSLOG_FACILITY_USER },
  { "AUTH", SYSLOG_FACILITY_AUTH },
  { "LOCAL0", SYSLOG_FACILITY_LOCAL0 },
  { "LOCAL1", SYSLOG_FACILITY_LOCAL1 },
  { "LOCAL2", SYSLOG_FACILITY_LOCAL2 },
  { "LOCAL3", SYSLOG_FACILITY_LOCAL3 },
  { "LOCAL4", SYSLOG_FACILITY_LOCAL4 },
  { "LOCAL5", SYSLOG_FACILITY_LOCAL5 },
  { "LOCAL6", SYSLOG_FACILITY_LOCAL6 },
  { "LOCAL7", SYSLOG_FACILITY_LOCAL7 },
  { NULL, 0 }
d152 3
a154 4
static struct 
{
  const char *name;
  LogLevel val;
d157 7
a163 7
  { "QUIET",   SYSLOG_LEVEL_QUIET },
  { "FATAL",   SYSLOG_LEVEL_FATAL },
  { "ERROR",   SYSLOG_LEVEL_ERROR },
  { "INFO",    SYSLOG_LEVEL_INFO },
  { "VERBOSE", SYSLOG_LEVEL_VERBOSE },
  { "DEBUG",   SYSLOG_LEVEL_DEBUG },
  { NULL, 0 }
d169 6
a174 6
  int i;
  if (name != NULL)
    for (i = 0; log_facilities[i].name; i++)
      if (strcasecmp(log_facilities[i].name, name) == 0)
        return log_facilities[i].val;
  return (SyslogFacility)-1;
d180 6
a185 6
  int i;
  if (name != NULL)
    for (i = 0; log_levels[i].name; i++)
      if (strcasecmp(log_levels[i].name, name) == 0)
        return log_levels[i].val;
  return (LogLevel)-1;
@


1.2
log
@bugfix: loglevels are per host in clientconfig,
factor out common log-level parsing code.
@
text
@d8 1
a8 1
RCSID("$OpenBSD: log.c,v 1.1 1999/11/10 23:36:44 markus Exp $");
d50 1
a50 1
chat(const char *fmt, ...)
d54 1
a54 1
  do_log(SYSLOG_LEVEL_CHAT, fmt, args);
d170 1
a170 1
  { "CHAT",	SYSLOG_LEVEL_CHAT },
@


1.1
log
@add LogLevel {QUIET, FATAL, ERROR, INFO, CHAT, DEBUG} to ssh/sshd,
obsoletes QuietMode and FascistLogging in sshd.
@
text
@d8 1
a8 1
RCSID("$OpenBSD: log-server.c,v 1.5 1999/10/17 20:39:11 dugsong Exp $");
d135 60
@

