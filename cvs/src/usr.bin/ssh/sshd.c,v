head	1.492;
access;
symbols
	OPENBSD_6_2:1.492.0.2
	OPENBSD_6_2_BASE:1.492
	OPENBSD_6_1:1.485.0.4
	OPENBSD_6_1_BASE:1.485
	OPENBSD_6_0:1.470.0.4
	OPENBSD_6_0_BASE:1.470
	OPENBSD_5_9:1.465.0.2
	OPENBSD_5_9_BASE:1.465
	OPENBSD_5_8:1.457.0.2
	OPENBSD_5_8_BASE:1.457
	OPENBSD_5_7:1.444.0.2
	OPENBSD_5_7_BASE:1.444
	OPENBSD_5_6:1.428.0.4
	OPENBSD_5_6_BASE:1.428
	OPENBSD_5_5:1.420.0.4
	OPENBSD_5_5_BASE:1.420
	OPENBSD_5_4:1.404.0.2
	OPENBSD_5_4_BASE:1.404
	OPENBSD_5_3:1.397.0.2
	OPENBSD_5_3_BASE:1.397
	OPENBSD_5_2:1.393.0.2
	OPENBSD_5_2_BASE:1.393
	OPENBSD_5_1_BASE:1.388
	OPENBSD_5_1:1.388.0.2
	OPENBSD_5_0:1.385.0.2
	OPENBSD_5_0_BASE:1.385
	OPENBSD_4_9:1.381.0.2
	OPENBSD_4_9_BASE:1.381
	OPENBSD_4_8:1.375.0.2
	OPENBSD_4_8_BASE:1.375
	OPENBSD_4_7:1.374.0.2
	OPENBSD_4_7_BASE:1.374
	OPENBSD_4_6:1.367.0.4
	OPENBSD_4_6_BASE:1.367
	OPENBSD_4_5:1.366.0.2
	OPENBSD_4_5_BASE:1.366
	OPENBSD_4_4:1.364.0.2
	OPENBSD_4_4_BASE:1.364
	OPENBSD_4_3:1.355.0.2
	OPENBSD_4_3_BASE:1.355
	OPENBSD_4_2:1.351.0.2
	OPENBSD_4_2_BASE:1.351
	OPENBSD_4_1:1.350.0.2
	OPENBSD_4_1_BASE:1.350
	OPENBSD_4_0:1.347.0.4
	OPENBSD_4_0_BASE:1.347
	OPENBSD_3_9:1.323.0.2
	OPENBSD_3_9_BASE:1.323
	OPENBSD_3_8:1.312.0.2
	OPENBSD_3_8_BASE:1.312
	OPENBSD_3_7:1.308.0.2
	OPENBSD_3_7_BASE:1.308
	OPENBSD_3_6:1.302.0.2
	OPENBSD_3_6_BASE:1.302
	OPENBSD_3_5:1.290.0.2
	OPENBSD_3_5_BASE:1.290
	OPENBSD_3_4:1.276.0.2
	OPENBSD_3_4_BASE:1.276
	OPENBSD_3_3:1.263.0.2
	OPENBSD_3_3_BASE:1.263
	OPENBSD_3_2:1.260.0.2
	OPENBSD_3_2_BASE:1.260
	OPENBSD_3_1:1.239.0.2
	OPENBSD_3_1_BASE:1.239
	OPENBSD_3_0:1.206.0.2
	OPENBSD_3_0_BASE:1.206
	OPENBSD_2_9_BASE:1.195
	OPENBSD_2_9:1.195.0.2
	OPENBSD_2_8:1.132.0.2
	OPENBSD_2_8_BASE:1.132
	OPENBSD_2_7:1.115.0.2
	OPENBSD_2_7_BASE:1.115
	OPENBSD_2_6:1.40.0.2
	OPENBSD_2_6_BASE:1.40;
locks; strict;
comment	@ * @;


1.492
date	2017.09.12.06.32.07;	author djm;	state Exp;
branches;
next	1.491;
commitid	Amj5uk8F1JrQpmI5;

1.491
date	2017.07.01.13.50.45;	author djm;	state Exp;
branches;
next	1.490;
commitid	jGKycoTTk52hb7Q7;

1.490
date	2017.05.31.08.09.45;	author markus;	state Exp;
branches;
next	1.489;
commitid	U3YdddehbFcy84WY;

1.489
date	2017.05.31.07.00.13;	author markus;	state Exp;
branches;
next	1.488;
commitid	X93t1IqdA6G5YFwi;

1.488
date	2017.05.30.08.52.20;	author markus;	state Exp;
branches;
next	1.487;
commitid	AQD3o1zTZEMIcuBx;

1.487
date	2017.04.30.23.18.44;	author djm;	state Exp;
branches;
next	1.486;
commitid	NPnVhZTcf5ddO7Ys;

1.486
date	2017.04.30.23.13.25;	author djm;	state Exp;
branches;
next	1.485;
commitid	Ss7V57MvgEZubdtr;

1.485
date	2017.03.15.03.52.30;	author deraadt;	state Exp;
branches;
next	1.484;
commitid	qRmm94EhoSW3aSxU;

1.484
date	2017.03.15.02.19.09;	author djm;	state Exp;
branches;
next	1.483;
commitid	3JacyAZUmkNn0Dd2;

1.483
date	2017.02.24.03.16.34;	author djm;	state Exp;
branches;
next	1.482;
commitid	67YPuNUktTgxurVK;

1.482
date	2017.02.06.09.22.51;	author djm;	state Exp;
branches;
next	1.481;
commitid	iGAoO9QWt0h6hnRt;

1.481
date	2017.02.03.02.56.00;	author dtucker;	state Exp;
branches;
next	1.480;
commitid	FFnrndqVo2L4heRx;

1.480
date	2016.12.09.03.04.29;	author djm;	state Exp;
branches;
next	1.479;
commitid	2ko6GsQRPOhwUyMo;

1.479
date	2016.12.04.22.27.25;	author dtucker;	state Exp;
branches;
next	1.478;
commitid	ry2kmwFfM3XvEkL5;

1.478
date	2016.11.30.00.28.31;	author dtucker;	state Exp;
branches;
next	1.477;
commitid	cItLYZCoclAybZAb;

1.477
date	2016.11.29.03.54.50;	author dtucker;	state Exp;
branches;
next	1.476;
commitid	1YuZ6y9PSwz2mkJm;

1.476
date	2016.09.28.16.33.07;	author djm;	state Exp;
branches;
next	1.475;
commitid	e2NJzal9PUi2o22D;

1.475
date	2016.08.28.22.28.12;	author djm;	state Exp;
branches;
next	1.474;
commitid	z0EbTZF3z1NYZrBs;

1.474
date	2016.08.19.03.18.07;	author djm;	state Exp;
branches;
next	1.473;
commitid	o9ZQ52UJzA8fd7BT;

1.473
date	2016.08.15.12.27.56;	author naddy;	state Exp;
branches;
next	1.472;
commitid	Xx3KKNu5BoFBkpj3;

1.472
date	2016.08.13.17.47.41;	author markus;	state Exp;
branches;
next	1.471;
commitid	dl4RDERdJITM8DKC;

1.471
date	2016.08.03.04.23.55;	author dtucker;	state Exp;
branches;
next	1.470;
commitid	2khvY2KWuR3Crnmr;

1.470
date	2016.05.24.04.43.45;	author dtucker;	state Exp;
branches;
next	1.469;
commitid	9CAIn8nADq025zdf;

1.469
date	2016.05.02.14.10.58;	author djm;	state Exp;
branches;
next	1.468;
commitid	wUs3nV4uTJVOZgVg;

1.468
date	2016.05.02.10.26.04;	author djm;	state Exp;
branches;
next	1.467;
commitid	rVUG0L3JBpFl5b0k;

1.467
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.466;
commitid	RYYIr1bk0phq4fXa;

1.466
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.465;
commitid	kr9hjdmg99uVnhW2;

1.465
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.464;
commitid	ut5A0buLh4mhCTFu;

1.464
date	2016.01.29.02.54.45;	author dtucker;	state Exp;
branches;
next	1.463;
commitid	PeK9nimTzIqJuIOX;

1.463
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.462;
commitid	W9ye0gltieEl87AJ;

1.462
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.461;
commitid	qST12VGCwbX5zIfM;

1.461
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.460;
commitid	K3glY441IowbrjDE;

1.460
date	2015.11.16.22.51.05;	author djm;	state Exp;
branches;
next	1.459;
commitid	jOjSshwO4nz70HMX;

1.459
date	2015.09.04.08.21.47;	author dtucker;	state Exp;
branches;
next	1.458;
commitid	FhVyfTnh6Klt0EZk;

1.458
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.457;
commitid	0Dp7Dy9FuNZesYo2;

1.457
date	2015.07.30.00.01.34;	author djm;	state Exp;
branches;
next	1.456;
commitid	YReS3Mui4FCZvL7z;

1.456
date	2015.07.17.02.47.45;	author djm;	state Exp;
branches;
next	1.455;
commitid	cFPR7mTdPQkiVMTP;

1.455
date	2015.07.15.08.00.11;	author djm;	state Exp;
branches;
next	1.454;
commitid	QadRxGWu7FXEa1Sv;

1.454
date	2015.07.10.06.21.53;	author markus;	state Exp;
branches;
next	1.453;
commitid	iQTtbsbSVdO9zivU;

1.453
date	2015.07.03.03.49.45;	author djm;	state Exp;
branches;
next	1.452;
commitid	XxrOOTFUKuLzoQb7;

1.452
date	2015.07.03.03.47.00;	author djm;	state Exp;
branches;
next	1.451;
commitid	hGFCOk0SiG8laZE4;

1.451
date	2015.07.03.03.43.18;	author djm;	state Exp;
branches;
next	1.450;
commitid	cnvu1kGgoFFYv6D3;

1.450
date	2015.05.24.23.39.16;	author djm;	state Exp;
branches;
next	1.449;
commitid	FUmKrIkDAYFg76mj;

1.449
date	2015.05.21.06.43.31;	author djm;	state Exp;
branches;
next	1.448;
commitid	0jtBXwojTXMGT6Vz;

1.448
date	2015.04.27.00.21.21;	author djm;	state Exp;
branches;
next	1.447;
commitid	5jSGLIHjrKv9NZcX;

1.447
date	2015.04.15.23.23.25;	author dtucker;	state Exp;
branches;
next	1.446;
commitid	5uBDOgATnTv0c0sY;

1.446
date	2015.04.10.05.16.50;	author dtucker;	state Exp;
branches;
next	1.445;
commitid	ik64gItc8q2DmTsj;

1.445
date	2015.03.31.22.55.24;	author djm;	state Exp;
branches;
next	1.444;
commitid	kjU6qvVMe0faxsb6;

1.444
date	2015.02.20.22.17.21;	author djm;	state Exp;
branches;
next	1.443;
commitid	9L88tCQWzQkTa0uX;

1.443
date	2015.02.16.22.30.03;	author djm;	state Exp;
branches;
next	1.442;
commitid	ZNTQnwzOEjXFLgBn;

1.442
date	2015.02.16.22.13.32;	author djm;	state Exp;
branches;
next	1.441;
commitid	vWL0dluw4oITNbM8;

1.441
date	2015.01.31.20.30.05;	author djm;	state Exp;
branches;
next	1.440;
commitid	x8klYPZMJSrVlt3O;

1.440
date	2015.01.26.06.10.03;	author djm;	state Exp;
branches;
next	1.439;
commitid	F603CYAZ9E536XCr;

1.439
date	2015.01.26.03.04.46;	author djm;	state Exp;
branches;
next	1.438;
commitid	Xp9DfQmHQHbZ815k;

1.438
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.437;
commitid	cBx23BaCk6gYBpRj;

1.437
date	2015.01.20.20.16.21;	author markus;	state Exp;
branches;
next	1.436;
commitid	Saj27Ko6Js1nmjQ4;

1.436
date	2015.01.19.20.20.20;	author markus;	state Exp;
branches;
next	1.435;
commitid	LpkFFtLiqWKzX2Ia;

1.435
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.434;
commitid	U9l75XYAjMKaQ8Jp;

1.434
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.433;
commitid	UHlhoIB5NMb8eAPm;

1.433
date	2015.01.17.18.53.34;	author djm;	state Exp;
branches;
next	1.432;
commitid	VaXfA9ik80v46V2L;

1.432
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.431;
commitid	YqNUZu0ifI7Q95nk;

1.431
date	2015.01.07.18.15.07;	author tedu;	state Exp;
branches;
next	1.430;
commitid	anjmN1QrNKVu3COM;

1.430
date	2014.12.22.07.55.51;	author djm;	state Exp;
branches;
next	1.429;
commitid	Obssn4758PtR7Red;

1.429
date	2014.12.11.08.20.09;	author djm;	state Exp;
branches;
next	1.428;
commitid	UtK7Mx4xawqsfx0b;

1.428
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.427;
commitid	z7plx8Gkj6l2sxem;

1.427
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.426;
commitid	1h9UxAQmwdaqUzyX;

1.426
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.425;

1.425
date	2014.04.19.14.53.48;	author tedu;	state Exp;
branches;
next	1.424;

1.424
date	2014.04.18.23.52.25;	author djm;	state Exp;
branches;
next	1.423;

1.423
date	2014.04.12.04.55.53;	author djm;	state Exp;
branches;
next	1.422;

1.422
date	2014.03.27.23.01.27;	author markus;	state Exp;
branches;
next	1.421;

1.421
date	2014.03.26.19.58.37;	author tedu;	state Exp;
branches;
next	1.420;

1.420
date	2014.02.26.21.53.37;	author markus;	state Exp;
branches
	1.420.4.1;
next	1.419;

1.419
date	2014.02.26.20.28.44;	author djm;	state Exp;
branches;
next	1.418;

1.418
date	2014.02.02.03.44.32;	author djm;	state Exp;
branches;
next	1.417;

1.417
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.416;

1.416
date	2014.01.29.00.19.26;	author djm;	state Exp;
branches;
next	1.415;

1.415
date	2014.01.27.19.18.54;	author markus;	state Exp;
branches;
next	1.414;

1.414
date	2014.01.09.23.26.48;	author djm;	state Exp;
branches;
next	1.413;

1.413
date	2013.12.30.23.52.28;	author djm;	state Exp;
branches;
next	1.412;

1.412
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.411;

1.411
date	2013.11.20.02.19.01;	author djm;	state Exp;
branches;
next	1.410;

1.410
date	2013.11.02.21.59.15;	author markus;	state Exp;
branches;
next	1.409;

1.409
date	2013.10.23.23.35.32;	author djm;	state Exp;
branches;
next	1.408;

1.408
date	2013.10.17.22.08.04;	author djm;	state Exp;
branches;
next	1.407;

1.407
date	2013.10.10.01.43.03;	author djm;	state Exp;
branches;
next	1.406;

1.406
date	2013.09.02.22.00.34;	author deraadt;	state Exp;
branches;
next	1.405;

1.405
date	2013.08.22.19.02.21;	author djm;	state Exp;
branches;
next	1.404;

1.404
date	2013.07.19.07.37.48;	author markus;	state Exp;
branches;
next	1.403;

1.403
date	2013.06.05.02.27.50;	author dtucker;	state Exp;
branches;
next	1.402;

1.402
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.401;

1.401
date	2013.05.16.09.08.41;	author dtucker;	state Exp;
branches;
next	1.400;

1.400
date	2013.05.16.04.09.14;	author dtucker;	state Exp;
branches;
next	1.399;

1.399
date	2013.04.07.02.10.33;	author dtucker;	state Exp;
branches;
next	1.398;

1.398
date	2013.04.06.16.07.00;	author markus;	state Exp;
branches;
next	1.397;

1.397
date	2013.02.11.21.21.58;	author dtucker;	state Exp;
branches;
next	1.396;

1.396
date	2012.11.04.11.09.15;	author djm;	state Exp;
branches;
next	1.395;

1.395
date	2012.11.04.10.38.43;	author djm;	state Exp;
branches;
next	1.394;

1.394
date	2012.10.30.21.29.55;	author djm;	state Exp;
branches;
next	1.393;

1.393
date	2012.07.10.02.19.15;	author djm;	state Exp;
branches;
next	1.392;

1.392
date	2012.06.30.14.35.09;	author markus;	state Exp;
branches;
next	1.391;

1.391
date	2012.05.13.01.42.32;	author dtucker;	state Exp;
branches;
next	1.390;

1.390
date	2012.04.12.02.42.32;	author djm;	state Exp;
branches;
next	1.389;

1.389
date	2012.04.11.13.26.40;	author djm;	state Exp;
branches;
next	1.388;

1.388
date	2011.09.30.21.22.49;	author djm;	state Exp;
branches;
next	1.387;

1.387
date	2011.09.30.00.47.37;	author dtucker;	state Exp;
branches;
next	1.386;

1.386
date	2011.09.09.22.38.21;	author djm;	state Exp;
branches;
next	1.385;

1.385
date	2011.06.23.09.34.13;	author djm;	state Exp;
branches;
next	1.384;

1.384
date	2011.06.22.21.57.01;	author djm;	state Exp;
branches;
next	1.383;

1.383
date	2011.06.17.21.44.31;	author djm;	state Exp;
branches;
next	1.382;

1.382
date	2011.04.12.05.32.49;	author djm;	state Exp;
branches;
next	1.381;

1.381
date	2011.01.11.06.13.10;	author djm;	state Exp;
branches;
next	1.380;

1.380
date	2010.09.22.05.01.29;	author djm;	state Exp;
branches;
next	1.379;

1.379
date	2010.08.31.12.33.38;	author djm;	state Exp;
branches;
next	1.378;

1.378
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.377;

1.377
date	2010.08.16.04.06.06;	author djm;	state Exp;
branches;
next	1.376;

1.376
date	2010.08.12.23.34.39;	author tedu;	state Exp;
branches;
next	1.375;

1.375
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.374;

1.374
date	2010.03.07.11.57.13;	author dtucker;	state Exp;
branches;
next	1.373;

1.373
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.372;

1.372
date	2010.01.29.00.20.41;	author djm;	state Exp;
branches;
next	1.371;

1.371
date	2010.01.13.03.48.13;	author djm;	state Exp;
branches;
next	1.370;

1.370
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.369;

1.369
date	2010.01.09.11.17.56;	author dtucker;	state Exp;
branches;
next	1.368;

1.368
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.367;

1.367
date	2009.05.28.16.50.16;	author andreas;	state Exp;
branches;
next	1.366;

1.366
date	2009.01.22.10.02.34;	author djm;	state Exp;
branches;
next	1.365;

1.365
date	2008.10.30.19.31.16;	author stevesk;	state Exp;
branches;
next	1.364;

1.364
date	2008.07.10.18.08.11;	author markus;	state Exp;
branches;
next	1.363;

1.363
date	2008.07.01.07.24.22;	author dtucker;	state Exp;
branches;
next	1.362;

1.362
date	2008.06.14.17.07.11;	author dtucker;	state Exp;
branches;
next	1.361;

1.361
date	2008.06.14.15.49.48;	author dtucker;	state Exp;
branches;
next	1.360;

1.360
date	2008.06.12.20.38.28;	author dtucker;	state Exp;
branches;
next	1.359;

1.359
date	2008.06.10.08.17.40;	author jmc;	state Exp;
branches;
next	1.358;

1.358
date	2008.06.10.04.50.25;	author dtucker;	state Exp;
branches;
next	1.357;

1.357
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.356;

1.356
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.355;

1.355
date	2008.02.14.13.10.31;	author mbalmer;	state Exp;
branches;
next	1.354;

1.354
date	2008.02.13.22.38.17;	author djm;	state Exp;
branches;
next	1.353;

1.353
date	2007.12.31.15.27.04;	author dtucker;	state Exp;
branches;
next	1.352;

1.352
date	2007.12.27.14.22.08;	author dtucker;	state Exp;
branches;
next	1.351;

1.351
date	2007.05.22.10.18.52;	author djm;	state Exp;
branches;
next	1.350;

1.350
date	2007.03.09.05.20.06;	author dtucker;	state Exp;
branches;
next	1.349;

1.349
date	2007.02.21.11.00.05;	author dtucker;	state Exp;
branches;
next	1.348;

1.348
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.347;

1.347
date	2006.08.18.09.15.20;	author markus;	state Exp;
branches
	1.347.4.1;
next	1.346;

1.346
date	2006.08.18.09.13.26;	author deraadt;	state Exp;
branches;
next	1.345;

1.345
date	2006.08.16.11.47.15;	author djm;	state Exp;
branches;
next	1.344;

1.344
date	2006.08.05.07.52.52;	author dtucker;	state Exp;
branches;
next	1.343;

1.343
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.342;

1.342
date	2006.08.01.23.22.48;	author stevesk;	state Exp;
branches;
next	1.341;

1.341
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.340;

1.340
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.339;

1.339
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.338;

1.338
date	2006.07.12.22.28.52;	author stevesk;	state Exp;
branches;
next	1.337;

1.337
date	2006.07.12.11.34.58;	author dtucker;	state Exp;
branches;
next	1.336;

1.336
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.335;

1.335
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.334;

1.334
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.333;

1.333
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.332;

1.332
date	2006.07.03.08.54.20;	author stevesk;	state Exp;
branches;
next	1.331;

1.331
date	2006.06.01.09.21.48;	author markus;	state Exp;
branches;
next	1.330;

1.330
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.329;

1.329
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.328;

1.328
date	2006.03.20.18.17.20;	author deraadt;	state Exp;
branches;
next	1.327;

1.327
date	2006.03.19.18.56.41;	author deraadt;	state Exp;
branches;
next	1.326;

1.326
date	2006.03.19.18.51.19;	author deraadt;	state Exp;
branches;
next	1.325;

1.325
date	2006.03.13.08.16.00;	author djm;	state Exp;
branches;
next	1.324;

1.324
date	2006.03.07.09.07.40;	author djm;	state Exp;
branches;
next	1.323;

1.323
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.323.2.1;
next	1.322;

1.322
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches;
next	1.321;

1.321
date	2006.02.10.01.44.27;	author stevesk;	state Exp;
branches;
next	1.320;

1.320
date	2006.02.10.00.27.13;	author stevesk;	state Exp;
branches;
next	1.319;

1.319
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.318;

1.318
date	2005.12.24.02.27.41;	author djm;	state Exp;
branches;
next	1.317;

1.317
date	2005.10.30.08.52.18;	author djm;	state Exp;
branches;
next	1.316;

1.316
date	2005.10.30.08.29.29;	author dtucker;	state Exp;
branches;
next	1.315;

1.315
date	2005.09.21.23.37.11;	author djm;	state Exp;
branches;
next	1.314;

1.314
date	2005.09.19.11.47.09;	author djm;	state Exp;
branches;
next	1.313;

1.313
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.312;

1.312
date	2005.07.25.11.59.40;	author markus;	state Exp;
branches
	1.312.2.1;
next	1.311;

1.311
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.310;

1.310
date	2005.06.16.08.00.00;	author markus;	state Exp;
branches;
next	1.309;

1.309
date	2005.04.06.09.43.59;	author djm;	state Exp;
branches;
next	1.308;

1.308
date	2005.02.08.22.24.57;	author dtucker;	state Exp;
branches
	1.308.2.1;
next	1.307;

1.307
date	2005.01.21.08.32.02;	author otto;	state Exp;
branches;
next	1.306;

1.306
date	2005.01.17.22.48.39;	author dtucker;	state Exp;
branches;
next	1.305;

1.305
date	2004.12.23.23.11.00;	author djm;	state Exp;
branches;
next	1.304;

1.304
date	2004.09.25.03.45.14;	author djm;	state Exp;
branches;
next	1.303;

1.303
date	2004.09.15.18.42.27;	author mickey;	state Exp;
branches;
next	1.302;

1.302
date	2004.08.28.01.01.48;	author djm;	state Exp;
branches
	1.302.2.1;
next	1.301;

1.301
date	2004.08.11.11.50.09;	author dtucker;	state Exp;
branches;
next	1.300;

1.300
date	2004.07.28.08.56.22;	author markus;	state Exp;
branches;
next	1.299;

1.299
date	2004.07.17.05.31.41;	author dtucker;	state Exp;
branches;
next	1.298;

1.298
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches;
next	1.297;

1.297
date	2004.06.26.20.07.16;	author avsm;	state Exp;
branches;
next	1.296;

1.296
date	2004.06.25.18.43.36;	author djm;	state Exp;
branches;
next	1.295;

1.295
date	2004.06.25.01.16.09;	author djm;	state Exp;
branches;
next	1.294;

1.294
date	2004.06.24.19.30.54;	author djm;	state Exp;
branches;
next	1.293;

1.293
date	2004.06.14.01.44.39;	author djm;	state Exp;
branches;
next	1.292;

1.292
date	2004.06.13.12.53.24;	author djm;	state Exp;
branches;
next	1.291;

1.291
date	2004.05.09.01.19.28;	author djm;	state Exp;
branches;
next	1.290;

1.290
date	2004.03.11.10.21.17;	author markus;	state Exp;
branches
	1.290.2.1;
next	1.289;

1.289
date	2004.03.11.08.36.26;	author markus;	state Exp;
branches;
next	1.288;

1.288
date	2004.03.03.06.47.52;	author markus;	state Exp;
branches;
next	1.287;

1.287
date	2004.02.25.00.22.45;	author djm;	state Exp;
branches;
next	1.286;

1.286
date	2004.02.23.12.02.33;	author markus;	state Exp;
branches;
next	1.285;

1.285
date	2004.02.05.05.37.17;	author dtucker;	state Exp;
branches;
next	1.284;

1.284
date	2003.12.09.21.53.37;	author markus;	state Exp;
branches;
next	1.283;

1.283
date	2003.12.09.17.29.04;	author markus;	state Exp;
branches;
next	1.282;

1.282
date	2003.12.02.17.01.15;	author markus;	state Exp;
branches;
next	1.281;

1.281
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches;
next	1.280;

1.280
date	2003.10.02.10.41.59;	author markus;	state Exp;
branches;
next	1.279;

1.279
date	2003.09.26.08.19.29;	author markus;	state Exp;
branches;
next	1.278;

1.278
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.277;

1.277
date	2003.09.19.11.33.09;	author markus;	state Exp;
branches;
next	1.276;

1.276
date	2003.08.28.12.54.34;	author markus;	state Exp;
branches
	1.276.2.1;
next	1.275;

1.275
date	2003.08.13.08.46.31;	author markus;	state Exp;
branches;
next	1.274;

1.274
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.273;

1.273
date	2003.07.16.10.34.53;	author markus;	state Exp;
branches;
next	1.272;

1.272
date	2003.07.14.12.36.37;	author markus;	state Exp;
branches;
next	1.271;

1.271
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches;
next	1.270;

1.270
date	2003.06.28.07.48.10;	author djm;	state Exp;
branches;
next	1.269;

1.269
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches;
next	1.268;

1.268
date	2003.06.04.10.23.48;	author djm;	state Exp;
branches;
next	1.267;

1.267
date	2003.05.29.16.58.45;	author deraadt;	state Exp;
branches;
next	1.266;

1.266
date	2003.05.24.09.30.40;	author djm;	state Exp;
branches;
next	1.265;

1.265
date	2003.04.14.14.17.50;	author markus;	state Exp;
branches;
next	1.264;

1.264
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.263;

1.263
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches
	1.263.2.1;
next	1.262;

1.262
date	2003.01.27.17.06.31;	author markus;	state Exp;
branches;
next	1.261;

1.261
date	2002.11.07.16.28.47;	author markus;	state Exp;
branches;
next	1.260;

1.260
date	2002.09.27.10.42.09;	author mickey;	state Exp;
branches
	1.260.2.1;
next	1.259;

1.259
date	2002.09.25.15.19.02;	author markus;	state Exp;
branches;
next	1.258;

1.258
date	2002.09.13.19.23.09;	author stevesk;	state Exp;
branches;
next	1.257;

1.257
date	2002.07.23.16.03.10;	author stevesk;	state Exp;
branches;
next	1.256;

1.256
date	2002.07.19.15.43.33;	author markus;	state Exp;
branches;
next	1.255;

1.255
date	2002.06.30.21.59.45;	author deraadt;	state Exp;
branches;
next	1.254;

1.254
date	2002.06.30.21.54.16;	author deraadt;	state Exp;
branches;
next	1.253;

1.253
date	2002.06.28.23.05.06;	author deraadt;	state Exp;
branches;
next	1.252;

1.252
date	2002.06.28.10.08.25;	author deraadt;	state Exp;
branches;
next	1.251;

1.251
date	2002.06.25.18.51.04;	author markus;	state Exp;
branches;
next	1.250;

1.250
date	2002.06.23.10.29.52;	author deraadt;	state Exp;
branches;
next	1.249;

1.249
date	2002.06.23.03.30.17;	author deraadt;	state Exp;
branches;
next	1.248;

1.248
date	2002.06.22.20.05.27;	author stevesk;	state Exp;
branches;
next	1.247;

1.247
date	2002.06.22.16.40.19;	author stevesk;	state Exp;
branches;
next	1.246;

1.246
date	2002.06.20.23.05.56;	author markus;	state Exp;
branches;
next	1.245;

1.245
date	2002.06.11.05.46.20;	author mpech;	state Exp;
branches;
next	1.244;

1.244
date	2002.05.29.11.21.57;	author markus;	state Exp;
branches;
next	1.243;

1.243
date	2002.05.22.23.18.25;	author deraadt;	state Exp;
branches;
next	1.242;

1.242
date	2002.05.15.15.47.49;	author mouring;	state Exp;
branches;
next	1.241;

1.241
date	2002.05.13.15.53.19;	author millert;	state Exp;
branches;
next	1.240;

1.240
date	2002.04.23.22.16.29;	author djm;	state Exp;
branches;
next	1.239;

1.239
date	2002.03.30.18.51.15;	author markus;	state Exp;
branches
	1.239.2.1;
next	1.238;

1.238
date	2002.03.23.20.57.26;	author stevesk;	state Exp;
branches;
next	1.237;

1.237
date	2002.03.21.21.23.34;	author markus;	state Exp;
branches;
next	1.236;

1.236
date	2002.03.20.21.08.08;	author stevesk;	state Exp;
branches;
next	1.235;

1.235
date	2002.03.20.19.12.25;	author stevesk;	state Exp;
branches;
next	1.234;

1.234
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.233;

1.233
date	2002.03.19.10.35.39;	author markus;	state Exp;
branches;
next	1.232;

1.232
date	2002.03.19.03.03.43;	author stevesk;	state Exp;
branches;
next	1.231;

1.231
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.230;

1.230
date	2002.03.18.01.12.14;	author provos;	state Exp;
branches;
next	1.229;

1.229
date	2002.03.14.16.38.26;	author markus;	state Exp;
branches;
next	1.228;

1.228
date	2002.02.27.21.23.13;	author stevesk;	state Exp;
branches;
next	1.227;

1.227
date	2002.02.24.16.09.52;	author stevesk;	state Exp;
branches;
next	1.226;

1.226
date	2002.02.11.16.19.39;	author markus;	state Exp;
branches;
next	1.225;

1.225
date	2002.02.11.16.17.55;	author markus;	state Exp;
branches;
next	1.224;

1.224
date	2002.02.04.12.15.25;	author markus;	state Exp;
branches;
next	1.223;

1.223
date	2002.01.13.17.57.37;	author markus;	state Exp;
branches;
next	1.222;

1.222
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.221;

1.221
date	2001.12.28.13.57.33;	author markus;	state Exp;
branches;
next	1.220;

1.220
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.219;

1.219
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.218;

1.218
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.217;

1.217
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.216;

1.216
date	2001.12.10.16.45.04;	author stevesk;	state Exp;
branches;
next	1.215;

1.215
date	2001.12.06.13.30.06;	author markus;	state Exp;
branches;
next	1.214;

1.214
date	2001.12.05.10.06.13;	author deraadt;	state Exp;
branches;
next	1.213;

1.213
date	2001.12.05.03.50.01;	author itojun;	state Exp;
branches;
next	1.212;

1.212
date	2001.11.22.12.34.22;	author markus;	state Exp;
branches;
next	1.211;

1.211
date	2001.11.19.11.20.21;	author markus;	state Exp;
branches;
next	1.210;

1.210
date	2001.11.14.20.45.08;	author deraadt;	state Exp;
branches;
next	1.209;

1.209
date	2001.11.10.13.19.45;	author markus;	state Exp;
branches;
next	1.208;

1.208
date	2001.11.09.19.08.35;	author markus;	state Exp;
branches;
next	1.207;

1.207
date	2001.10.24.08.41.41;	author markus;	state Exp;
branches;
next	1.206;

1.206
date	2001.10.02.22.56.09;	author stevesk;	state Exp;
branches
	1.206.2.1;
next	1.205;

1.205
date	2001.10.01.21.38.53;	author markus;	state Exp;
branches;
next	1.204;

1.204
date	2001.08.23.17.59.31;	author camield;	state Exp;
branches;
next	1.203;

1.203
date	2001.07.26.17.18.22;	author stevesk;	state Exp;
branches;
next	1.202;

1.202
date	2001.06.26.16.15.25;	author dugsong;	state Exp;
branches;
next	1.201;

1.201
date	2001.06.23.19.12.43;	author markus;	state Exp;
branches;
next	1.200;

1.200
date	2001.06.23.15.12.21;	author itojun;	state Exp;
branches;
next	1.199;

1.199
date	2001.06.04.23.07.21;	author markus;	state Exp;
branches;
next	1.198;

1.198
date	2001.05.28.23.58.35;	author markus;	state Exp;
branches;
next	1.197;

1.197
date	2001.05.19.19.43.57;	author stevesk;	state Exp;
branches;
next	1.196;

1.196
date	2001.05.18.14.13.29;	author markus;	state Exp;
branches;
next	1.195;

1.195
date	2001.04.15.16.58.03;	author markus;	state Exp;
branches
	1.195.2.1;
next	1.194;

1.194
date	2001.04.15.08.43.47;	author markus;	state Exp;
branches;
next	1.193;

1.193
date	2001.04.12.20.09.38;	author stevesk;	state Exp;
branches;
next	1.192;

1.192
date	2001.04.11.16.25.30;	author lebel;	state Exp;
branches;
next	1.191;

1.191
date	2001.04.05.10.42.57;	author markus;	state Exp;
branches;
next	1.190;

1.190
date	2001.04.04.20.25.38;	author markus;	state Exp;
branches;
next	1.189;

1.189
date	2001.04.04.14.34.58;	author markus;	state Exp;
branches;
next	1.188;

1.188
date	2001.04.04.09.48.35;	author markus;	state Exp;
branches;
next	1.187;

1.187
date	2001.04.03.23.32.12;	author markus;	state Exp;
branches;
next	1.186;

1.186
date	2001.04.03.19.53.29;	author markus;	state Exp;
branches;
next	1.185;

1.185
date	2001.03.29.23.42.01;	author djm;	state Exp;
branches;
next	1.184;

1.184
date	2001.03.29.21.06.21;	author stevesk;	state Exp;
branches;
next	1.183;

1.183
date	2001.03.28.21.59.41;	author provos;	state Exp;
branches;
next	1.182;

1.182
date	2001.03.28.20.50.45;	author markus;	state Exp;
branches;
next	1.181;

1.181
date	2001.03.27.17.46.49;	author provos;	state Exp;
branches;
next	1.180;

1.180
date	2001.03.27.10.34.08;	author markus;	state Exp;
branches;
next	1.179;

1.179
date	2001.03.26.08.07.09;	author markus;	state Exp;
branches;
next	1.178;

1.178
date	2001.03.23.14.28.32;	author markus;	state Exp;
branches;
next	1.177;

1.177
date	2001.03.23.11.04.07;	author djm;	state Exp;
branches;
next	1.176;

1.176
date	2001.03.22.20.22.55;	author deraadt;	state Exp;
branches;
next	1.175;

1.175
date	2001.03.18.23.30.55;	author deraadt;	state Exp;
branches;
next	1.174;

1.174
date	2001.03.09.12.30.29;	author deraadt;	state Exp;
branches;
next	1.173;

1.173
date	2001.03.05.17.17.21;	author markus;	state Exp;
branches;
next	1.172;

1.172
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches;
next	1.171;

1.171
date	2001.03.04.01.46.30;	author djm;	state Exp;
branches;
next	1.170;

1.170
date	2001.02.28.21.21.41;	author markus;	state Exp;
branches;
next	1.169;

1.169
date	2001.02.23.18.15.13;	author markus;	state Exp;
branches;
next	1.168;

1.168
date	2001.02.19.23.09.05;	author deraadt;	state Exp;
branches;
next	1.167;

1.167
date	2001.02.12.23.26.20;	author markus;	state Exp;
branches;
next	1.166;

1.166
date	2001.02.11.12.59.25;	author markus;	state Exp;
branches;
next	1.165;

1.165
date	2001.02.08.19.30.53;	author itojun;	state Exp;
branches;
next	1.164;

1.164
date	2001.02.07.22.35.46;	author markus;	state Exp;
branches;
next	1.163;

1.163
date	2001.02.04.23.56.23;	author deraadt;	state Exp;
branches;
next	1.162;

1.162
date	2001.02.04.22.12.17;	author stevesk;	state Exp;
branches;
next	1.161;

1.161
date	2001.02.04.15.32.27;	author stevesk;	state Exp;
branches;
next	1.160;

1.160
date	2001.02.04.15.14.15;	author deraadt;	state Exp;
branches;
next	1.159;

1.159
date	2001.01.29.19.47.31;	author markus;	state Exp;
branches;
next	1.158;

1.158
date	2001.01.28.10.37.26;	author markus;	state Exp;
branches;
next	1.157;

1.157
date	2001.01.22.23.06.40;	author markus;	state Exp;
branches;
next	1.156;

1.156
date	2001.01.22.17.22.28;	author stevesk;	state Exp;
branches;
next	1.155;

1.155
date	2001.01.21.19.06.00;	author markus;	state Exp;
branches;
next	1.154;

1.154
date	2001.01.19.15.55.12;	author markus;	state Exp;
branches;
next	1.153;

1.153
date	2001.01.19.12.45.27;	author markus;	state Exp;
branches;
next	1.152;

1.152
date	2001.01.18.16.20.22;	author markus;	state Exp;
branches;
next	1.151;

1.151
date	2001.01.18.15.54.49;	author markus;	state Exp;
branches;
next	1.150;

1.150
date	2001.01.13.18.32.51;	author markus;	state Exp;
branches;
next	1.149;

1.149
date	2001.01.13.18.03.07;	author markus;	state Exp;
branches;
next	1.148;

1.148
date	2001.01.11.22.14.20;	author markus;	state Exp;
branches;
next	1.147;

1.147
date	2001.01.10.19.43.20;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2001.01.07.11.28.07;	author markus;	state Exp;
branches;
next	1.145;

1.145
date	2001.01.04.22.25.58;	author markus;	state Exp;
branches;
next	1.144;

1.144
date	2000.12.28.12.03.58;	author markus;	state Exp;
branches;
next	1.143;

1.143
date	2000.12.27.12.34.50;	author markus;	state Exp;
branches;
next	1.142;

1.142
date	2000.12.20.19.37.22;	author markus;	state Exp;
branches;
next	1.141;

1.141
date	2000.12.20.19.32.08;	author markus;	state Exp;
branches;
next	1.140;

1.140
date	2000.12.19.23.17.59;	author markus;	state Exp;
branches;
next	1.139;

1.139
date	2000.12.15.17.30.14;	author provos;	state Exp;
branches;
next	1.138;

1.138
date	2000.12.12.22.30.02;	author markus;	state Exp;
branches;
next	1.137;

1.137
date	2000.12.12.21.45.21;	author markus;	state Exp;
branches;
next	1.136;

1.136
date	2000.12.05.16.47.28;	author todd;	state Exp;
branches;
next	1.135;

1.135
date	2000.11.29.21.11.59;	author markus;	state Exp;
branches;
next	1.134;

1.134
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	1.133;

1.133
date	2000.11.06.23.13.27;	author markus;	state Exp;
branches;
next	1.132;

1.132
date	2000.10.13.18.34.46;	author markus;	state Exp;
branches
	1.132.2.1;
next	1.131;

1.131
date	2000.10.12.09.59.20;	author markus;	state Exp;
branches;
next	1.130;

1.130
date	2000.10.11.20.27.24;	author markus;	state Exp;
branches;
next	1.129;

1.129
date	2000.10.11.04.02.17;	author provos;	state Exp;
branches;
next	1.128;

1.128
date	2000.09.17.15.38.59;	author markus;	state Exp;
branches;
next	1.127;

1.127
date	2000.09.12.20.53.10;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2000.09.07.20.27.55;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2000.08.17.20.06.34;	author markus;	state Exp;
branches;
next	1.124;

1.124
date	2000.07.22.09.14.37;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2000.07.18.01.25.01;	author djm;	state Exp;
branches;
next	1.122;

1.122
date	2000.07.11.08.11.34;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2000.07.05.21.35.56;	author provos;	state Exp;
branches;
next	1.120;

1.120
date	2000.06.26.21.59.18;	author markus;	state Exp;
branches;
next	1.119;

1.119
date	2000.06.22.16.32.27;	author markus;	state Exp;
branches;
next	1.118;

1.118
date	2000.05.25.20.45.20;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2000.05.18.13.27.36;	author djm;	state Exp;
branches;
next	1.116;

1.116
date	2000.05.17.08.20.16;	author markus;	state Exp;
branches;
next	1.115;

1.115
date	2000.05.03.10.21.49;	author markus;	state Exp;
branches
	1.115.2.1;
next	1.114;

1.114
date	2000.05.02.12.44.38;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2000.05.01.20.34.51;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2000.05.01.18.50.59;	author markus;	state Exp;
branches;
next	1.111;

1.111
date	2000.04.27.08.01.28;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2000.04.26.22.36.06;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2000.04.26.22.15.59;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2000.04.26.20.56.30;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2000.04.19.07.05.50;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2000.04.17.12.31.47;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2000.04.12.08.11.36;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2000.04.12.07.45.44;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2000.04.12.07.03.06;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2000.04.12.06.37.02;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2000.04.07.09.17.39;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2000.04.06.08.55.22;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2000.04.04.21.37.27;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2000.03.28.21.15.45;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2000.03.28.20.31.29;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2000.03.23.22.15.34;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2000.03.22.09.55.10;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2000.03.16.20.56.15;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2000.03.09.19.31.47;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2000.03.06.20.29.04;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2000.02.28.19.40.23;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2000.02.15.16.52.57;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2000.02.15.09.25.45;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2000.02.06.10.18.58;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2000.02.05.10.13.12;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2000.02.01.13.52.26;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2000.01.31.23.57.01;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2000.01.27.20.20.02;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2000.01.24.20.31.19;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2000.01.20.15.19.22;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2000.01.18.13.45.05;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2000.01.18.09.42.18;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2000.01.16.23.03.10;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2000.01.04.16.54.58;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2000.01.04.00.08.01;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	99.12.12.19.20.03;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	99.12.08.23.59.12;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	99.12.08.04.36.41;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	99.12.08.00.08.09;	author provos;	state Exp;
branches;
next	1.70;

1.70
date	99.12.07.23.14.36;	author provos;	state Exp;
branches;
next	1.69;

1.69
date	99.12.07.17.52.29;	author markus;	state Exp;
branches;
next	1.68;

1.68
date	99.12.06.20.15.30;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	99.12.06.12.10.12;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	99.11.24.19.53.53;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	99.11.23.22.25.55;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	99.11.22.21.52.42;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	99.11.22.21.02.39;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	99.11.22.20.02.45;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	99.11.20.20.07.23;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	99.11.19.19.58.18;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	99.11.18.14.00.49;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	99.11.17.09.51.21;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	99.11.16.21.15.19;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	99.11.15.21.38.54;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	99.11.15.20.53.25;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	99.11.15.00.42.01;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	99.11.14.23.20.09;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	99.11.11.23.36.53;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	99.11.11.22.58.39;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	99.11.11.15.23.14;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	99.11.11.10.05.34;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	99.11.10.23.36.45;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	99.11.10.22.24.01;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	99.11.03.23.31.03;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	99.11.02.19.42.37;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	99.11.02.19.10.15;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	99.11.02.00.08.42;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	99.10.25.20.38.49;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	99.10.18.06.16.50;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	99.10.18.01.54.18;	author provos;	state Exp;
branches;
next	1.38;

1.38
date	99.10.17.23.11.24;	author dugsong;	state Exp;
branches;
next	1.37;

1.37
date	99.10.17.20.48.07;	author dugsong;	state Exp;
branches;
next	1.36;

1.36
date	99.10.17.20.43.31;	author dugsong;	state Exp;
branches;
next	1.35;

1.35
date	99.10.17.20.39.11;	author dugsong;	state Exp;
branches;
next	1.34;

1.34
date	99.10.16.23.11.29;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	99.10.16.20.47.14;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	99.10.14.18.54.45;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	99.10.14.18.17.42;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	99.10.12.18.11.55;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	99.10.12.05.45.43;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.10.11.21.48.29;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	99.10.11.21.07.37;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	99.10.11.20.00.36;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	99.10.07.22.46.33;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	99.10.07.21.45.02;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	99.10.07.04.40.03;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.10.05.22.18.52;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	99.10.05.18.34.55;	author dugsong;	state Exp;
branches;
next	1.20;

1.20
date	99.10.05.18.01.07;	author dugsong;	state Exp;
branches;
next	1.19;

1.19
date	99.10.04.20.45.02;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.10.03.21.02.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.10.03.19.22.39;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.10.03.04.21.08;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.09.30.21.45.47;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	99.09.30.08.34.25;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.09.30.06.06.31;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.09.30.05.53.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.09.30.05.03.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.09.30.04.30.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.09.30.04.10.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.09.29.22.08.13;	author dugsong;	state Exp;
branches;
next	1.7;

1.7
date	99.09.29.21.15.54;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.29.21.14.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.18.16.21;	author dugsong;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.17.42.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.15.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.37;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.38;	author deraadt;	state Exp;
branches;
next	;

1.115.2.1
date	2000.06.12.02.37.39;	author jason;	state Exp;
branches;
next	1.115.2.2;

1.115.2.2
date	2000.09.01.18.23.24;	author jason;	state Exp;
branches;
next	1.115.2.3;

1.115.2.3
date	2000.11.08.21.31.32;	author jason;	state Exp;
branches;
next	1.115.2.4;

1.115.2.4
date	2001.03.12.15.44.17;	author jason;	state Exp;
branches;
next	1.115.2.5;

1.115.2.5
date	2001.03.21.18.53.16;	author jason;	state Exp;
branches;
next	;

1.132.2.1
date	2001.02.16.20.13.23;	author jason;	state Exp;
branches;
next	1.132.2.2;

1.132.2.2
date	2001.02.19.17.19.38;	author jason;	state Exp;
branches;
next	1.132.2.3;

1.132.2.3
date	2001.03.21.19.46.31;	author jason;	state Exp;
branches;
next	1.132.2.4;

1.132.2.4
date	2001.05.07.21.09.38;	author jason;	state Exp;
branches;
next	1.132.2.5;

1.132.2.5
date	2001.09.27.00.15.43;	author miod;	state Exp;
branches;
next	1.132.2.6;

1.132.2.6
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.132.2.7;

1.132.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.132.2.8;

1.132.2.8
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.195.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.195.2.2;

1.195.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.195.2.3;

1.195.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.195.2.4;

1.195.2.4
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.195.2.5;

1.195.2.5
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.206.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.206.2.2;

1.206.2.2
date	2002.03.07.17.37.48;	author jason;	state Exp;
branches;
next	1.206.2.3;

1.206.2.3
date	2002.05.17.00.03.25;	author miod;	state Exp;
branches;
next	1.206.2.4;

1.206.2.4
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.206.2.5;

1.206.2.5
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.206.2.6;

1.206.2.6
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.239.2.1
date	2002.05.18.04.12.11;	author jason;	state Exp;
branches;
next	1.239.2.2;

1.239.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.239.2.3;

1.239.2.3
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.239.2.4;

1.239.2.4
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.239.2.5;

1.239.2.5
date	2003.04.03.22.35.18;	author miod;	state Exp;
branches;
next	;

1.260.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.260.2.2;

1.260.2.2
date	2003.09.16.21.20.29;	author brad;	state Exp;
branches;
next	;

1.263.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.263.2.2;

1.263.2.2
date	2004.03.04.18.18.17;	author brad;	state Exp;
branches;
next	;

1.276.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.276.2.2;

1.276.2.2
date	2004.08.19.22.37.33;	author brad;	state Exp;
branches;
next	;

1.290.2.1
date	2004.08.19.04.13.28;	author brad;	state Exp;
branches;
next	1.290.2.2;

1.290.2.2
date	2005.03.10.17.15.05;	author brad;	state Exp;
branches;
next	;

1.302.2.1
date	2005.03.10.16.28.28;	author brad;	state Exp;
branches;
next	1.302.2.2;

1.302.2.2
date	2005.09.02.03.45.01;	author brad;	state Exp;
branches;
next	;

1.308.2.1
date	2005.09.04.18.40.11;	author brad;	state Exp;
branches;
next	1.308.2.2;

1.308.2.2
date	2006.02.03.02.53.46;	author brad;	state Exp;
branches;
next	;

1.312.2.1
date	2006.02.03.03.01.58;	author brad;	state Exp;
branches;
next	1.312.2.2;

1.312.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.312.2.3;

1.312.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.323.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.323.2.2;

1.323.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.347.4.1
date	2006.11.08.00.42.11;	author brad;	state Exp;
branches;
next	;

1.420.4.1
date	2014.04.21.00.30.48;	author djm;	state Exp;
branches;
next	;


desc
@@


1.492
log
@refactor channels.c

Move static state to a "struct ssh_channels" that is allocated at
runtime and tracked as a member of struct ssh.

Explicitly pass "struct ssh" to all channels functions.

Replace use of the legacy packet APIs in channels.c.

Rework sshd_config PermitOpen handling: previously the configuration
parser would call directly into the channels layer. After the refactor
this is not possible, as the channels structures are allocated at
connection time and aren't available when the configuration is parsed.
The server config parser now tracks PermitOpen itself and explicitly
configures the channels code later.

ok markus@@
@
text
@/* $OpenBSD: sshd.c,v 1.491 2017/07/01 13:50:45 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * This program is the ssh daemon.  It listens for connections from clients,
 * and performs authentication, executes use commands or shell, and forwards
 * information to/from the application to the user client over an encrypted
 * connection.  This can also handle forwarding of X11, TCP/IP, and
 * authentication agent connections.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * SSH2 implementation:
 * Privilege Separation:
 *
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
 * Copyright (c) 2002 Niels Provos.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/tree.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#ifdef WITH_OPENSSL
#include <openssl/bn.h>
#endif

#include "xmalloc.h"
#include "ssh.h"
#include "ssh2.h"
#include "sshpty.h"
#include "packet.h"
#include "log.h"
#include "buffer.h"
#include "misc.h"
#include "match.h"
#include "servconf.h"
#include "uidswap.h"
#include "compat.h"
#include "cipher.h"
#include "digest.h"
#include "key.h"
#include "kex.h"
#include "myproposal.h"
#include "authfile.h"
#include "pathnames.h"
#include "atomicio.h"
#include "canohost.h"
#include "hostfile.h"
#include "auth.h"
#include "authfd.h"
#include "msg.h"
#include "dispatch.h"
#include "channels.h"
#include "session.h"
#include "monitor.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
#include "ssh-sandbox.h"
#include "version.h"
#include "ssherr.h"

/* Re-exec fds */
#define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
#define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2)
#define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3)
#define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4)

extern char *__progname;

/* Server configuration options. */
ServerOptions options;

/* Name of the server configuration file. */
char *config_file_name = _PATH_SERVER_CONFIG_FILE;

/*
 * Debug mode flag.  This can be set on the command line.  If debug
 * mode is enabled, extra debugging output will be sent to the system
 * log, the daemon will not go to background, and will exit after processing
 * the first connection.
 */
int debug_flag = 0;

/* Flag indicating that the daemon should only test the configuration and keys. */
int test_flag = 0;

/* Flag indicating that the daemon is being started from inetd. */
int inetd_flag = 0;

/* Flag indicating that sshd should not detach and become a daemon. */
int no_daemon_flag = 0;

/* debug goes to stderr unless inetd_flag is set */
int log_stderr = 0;

/* Saved arguments to main(). */
char **saved_argv;

/* re-exec */
int rexeced_flag = 0;
int rexec_flag = 1;
int rexec_argc = 0;
char **rexec_argv;

/*
 * The sockets that the server is listening; this is used in the SIGHUP
 * signal handler.
 */
#define	MAX_LISTEN_SOCKS	16
int listen_socks[MAX_LISTEN_SOCKS];
int num_listen_socks = 0;

/*
 * the client's version string, passed by sshd2 in compat mode. if != NULL,
 * sshd will skip the version-number exchange
 */
char *client_version_string = NULL;
char *server_version_string = NULL;

/* Daemon's agent connection */
int auth_sock = -1;
int have_agent = 0;

/*
 * Any really sensitive data in the application is contained in this
 * structure. The idea is that this structure could be locked into memory so
 * that the pages do not get written into swap.  However, there are some
 * problems. The private key contains BIGNUMs, and we do not (in principle)
 * have access to the internals of them, and locking just the structure is
 * not very useful.  Currently, memory locking is not implemented.
 */
struct {
	struct sshkey	**host_keys;		/* all private host keys */
	struct sshkey	**host_pubkeys;		/* all public host keys */
	struct sshkey	**host_certificates;	/* all public host certificates */
	int		have_ssh2_key;
} sensitive_data;

/* This is set to true when a signal is received. */
static volatile sig_atomic_t received_sighup = 0;
static volatile sig_atomic_t received_sigterm = 0;

/* session identifier, used by RSA-auth */
u_char session_id[16];

/* same for ssh2 */
u_char *session_id2 = NULL;
u_int session_id2_len = 0;

/* record remote hostname or ip */
u_int utmp_len = HOST_NAME_MAX+1;

/* options.max_startup sized array of fd ints */
int *startup_pipes = NULL;
int startup_pipe;		/* in child */

/* variables used for privilege separation */
int use_privsep = -1;
struct monitor *pmonitor = NULL;
int privsep_is_preauth = 1;

/* global authentication context */
Authctxt *the_authctxt = NULL;

/* sshd_config buffer */
Buffer cfg;

/* message to be displayed after login */
Buffer loginmsg;

/* Prototypes for various functions defined later in this file. */
void destroy_sensitive_data(void);
void demote_sensitive_data(void);
static void do_ssh2_kex(void);

/*
 * Close all listening sockets
 */
static void
close_listen_socks(void)
{
	int i;

	for (i = 0; i < num_listen_socks; i++)
		close(listen_socks[i]);
	num_listen_socks = -1;
}

static void
close_startup_pipes(void)
{
	int i;

	if (startup_pipes)
		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1)
				close(startup_pipes[i]);
}

/*
 * Signal handler for SIGHUP.  Sshd execs itself when it receives SIGHUP;
 * the effect is to reread the configuration file (and to regenerate
 * the server key).
 */

/*ARGSUSED*/
static void
sighup_handler(int sig)
{
	int save_errno = errno;

	received_sighup = 1;
	signal(SIGHUP, sighup_handler);
	errno = save_errno;
}

/*
 * Called from the main program after receiving SIGHUP.
 * Restarts the server.
 */
static void
sighup_restart(void)
{
	logit("Received SIGHUP; restarting.");
	if (options.pid_file != NULL)
		unlink(options.pid_file);
	close_listen_socks();
	close_startup_pipes();
	alarm(0);  /* alarm timer persists across exec */
	signal(SIGHUP, SIG_IGN); /* will be restored after exec */
	execv(saved_argv[0], saved_argv);
	logit("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0],
	    strerror(errno));
	exit(1);
}

/*
 * Generic signal handler for terminating signals in the master daemon.
 */
/*ARGSUSED*/
static void
sigterm_handler(int sig)
{
	received_sigterm = sig;
}

/*
 * SIGCHLD handler.  This is called whenever a child dies.  This will then
 * reap any zombies left by exited children.
 */
/*ARGSUSED*/
static void
main_sigchld_handler(int sig)
{
	int save_errno = errno;
	pid_t pid;
	int status;

	while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
	    (pid < 0 && errno == EINTR))
		;

	signal(SIGCHLD, main_sigchld_handler);
	errno = save_errno;
}

/*
 * Signal handler for the alarm after the login grace period has expired.
 */
/*ARGSUSED*/
static void
grace_alarm_handler(int sig)
{
	if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)
		kill(pmonitor->m_pid, SIGALRM);

	/*
	 * Try to kill any processes that we have spawned, E.g. authorized
	 * keys command helpers.
	 */
	if (getpgid(0) == getpid()) {
		signal(SIGTERM, SIG_IGN);
		kill(0, SIGTERM);
	}

	/* Log error and exit. */
	sigdie("Timeout before authentication for %s port %d",
	    ssh_remote_ipaddr(active_state), ssh_remote_port(active_state));
}

static void
sshd_exchange_identification(struct ssh *ssh, int sock_in, int sock_out)
{
	u_int i;
	int remote_major, remote_minor;
	char *s;
	char buf[256];			/* Must not be larger than remote_version. */
	char remote_version[256];	/* Must be at least as big as buf. */

	xasprintf(&server_version_string, "SSH-%d.%d-%.100s%s%s\r\n",
	    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,
	    *options.version_addendum == '\0' ? "" : " ",
	    options.version_addendum);

	/* Send our protocol version identification. */
	if (atomicio(vwrite, sock_out, server_version_string,
	    strlen(server_version_string))
	    != strlen(server_version_string)) {
		logit("Could not write ident string to %s port %d",
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
		cleanup_exit(255);
	}

	/* Read other sides version identification. */
	memset(buf, 0, sizeof(buf));
	for (i = 0; i < sizeof(buf) - 1; i++) {
		if (atomicio(read, sock_in, &buf[i], 1) != 1) {
			logit("Did not receive identification string "
			    "from %s port %d",
			    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
			cleanup_exit(255);
		}
		if (buf[i] == '\r') {
			buf[i] = 0;
			/* Kludge for F-Secure Macintosh < 1.0.2 */
			if (i == 12 &&
			    strncmp(buf, "SSH-1.5-W1.0", 12) == 0)
				break;
			continue;
		}
		if (buf[i] == '\n') {
			buf[i] = 0;
			break;
		}
	}
	buf[sizeof(buf) - 1] = 0;
	client_version_string = xstrdup(buf);

	/*
	 * Check that the versions match.  In future this might accept
	 * several versions and set appropriate flags to handle them.
	 */
	if (sscanf(client_version_string, "SSH-%d.%d-%[^\n]\n",
	    &remote_major, &remote_minor, remote_version) != 3) {
		s = "Protocol mismatch.\n";
		(void) atomicio(vwrite, sock_out, s, strlen(s));
		logit("Bad protocol version identification '%.100s' "
		    "from %s port %d", client_version_string,
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
		close(sock_in);
		close(sock_out);
		cleanup_exit(255);
	}
	debug("Client protocol version %d.%d; client software version %.100s",
	    remote_major, remote_minor, remote_version);

	ssh->compat = compat_datafellows(remote_version);

	if ((ssh->compat & SSH_BUG_PROBE) != 0) {
		logit("probed from %s port %d with %s.  Don't panic.",
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
		    client_version_string);
		cleanup_exit(255);
	}
	if ((ssh->compat & SSH_BUG_SCANNER) != 0) {
		logit("scanned from %s port %d with %s.  Don't panic.",
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
		    client_version_string);
		cleanup_exit(255);
	}
	if ((ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit("Client version \"%.100s\" uses unsafe RSA signature "
		    "scheme; disabling use of RSA keys", remote_version);
	}
	if ((ssh->compat & SSH_BUG_DERIVEKEY) != 0) {
		fatal("Client version \"%.100s\" uses unsafe key agreement; "
		    "refusing connection", remote_version);
	}

	chop(server_version_string);
	debug("Local version string %.200s", server_version_string);

	if (remote_major != 2 ||
	    (remote_major == 1 && remote_minor != 99)) {
		s = "Protocol major versions differ.\n";
		(void) atomicio(vwrite, sock_out, s, strlen(s));
		close(sock_in);
		close(sock_out);
		logit("Protocol major versions differ for %s port %d: "
		    "%.200s vs. %.200s",
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
		    server_version_string, client_version_string);
		cleanup_exit(255);
	}
}

/* Destroy the host and server keys.  They will no longer be needed. */
void
destroy_sensitive_data(void)
{
	int i;

	for (i = 0; i < options.num_host_key_files; i++) {
		if (sensitive_data.host_keys[i]) {
			key_free(sensitive_data.host_keys[i]);
			sensitive_data.host_keys[i] = NULL;
		}
		if (sensitive_data.host_certificates[i]) {
			key_free(sensitive_data.host_certificates[i]);
			sensitive_data.host_certificates[i] = NULL;
		}
	}
}

/* Demote private to public keys for network child */
void
demote_sensitive_data(void)
{
	struct sshkey *tmp;
	int i;

	for (i = 0; i < options.num_host_key_files; i++) {
		if (sensitive_data.host_keys[i]) {
			tmp = key_demote(sensitive_data.host_keys[i]);
			key_free(sensitive_data.host_keys[i]);
			sensitive_data.host_keys[i] = tmp;
		}
		/* Certs do not need demotion */
	}
}

static void
privsep_preauth_child(void)
{
	gid_t gidset[1];
	struct passwd *pw;

	/* Enable challenge-response authentication for privilege separation */
	privsep_challenge_enable();

#ifdef GSSAPI
	/* Cache supported mechanism OIDs for later use */
	if (options.gss_authentication)
		ssh_gssapi_prepare_supported_oids();
#endif

	/* Demote the private keys to public keys. */
	demote_sensitive_data();

	/* Demote the child */
	if (getuid() == 0 || geteuid() == 0) {
		if ((pw = getpwnam(SSH_PRIVSEP_USER)) == NULL)
			fatal("Privilege separation user %s does not exist",
			    SSH_PRIVSEP_USER);
		explicit_bzero(pw->pw_passwd, strlen(pw->pw_passwd));
		endpwent();

		/* Change our root directory */
		if (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)
			fatal("chroot(\"%s\"): %s", _PATH_PRIVSEP_CHROOT_DIR,
			    strerror(errno));
		if (chdir("/") == -1)
			fatal("chdir(\"/\"): %s", strerror(errno));

		/*
		 * Drop our privileges
		 * NB. Can't use setusercontext() after chroot.
		 */
		debug3("privsep user:group %u:%u", (u_int)pw->pw_uid,
		    (u_int)pw->pw_gid);
		gidset[0] = pw->pw_gid;
		if (setgroups(1, gidset) < 0)
			fatal("setgroups: %.100s", strerror(errno));
		permanently_set_uid(pw);
	}
}

static int
privsep_preauth(Authctxt *authctxt)
{
	int status, r;
	pid_t pid;
	struct ssh_sandbox *box = NULL;

	/* Set up unprivileged child process to deal with network data */
	pmonitor = monitor_init();
	/* Store a pointer to the kex for later rekeying */
	pmonitor->m_pkex = &active_state->kex;

	if (use_privsep == PRIVSEP_ON)
		box = ssh_sandbox_init();
	pid = fork();
	if (pid == -1) {
		fatal("fork of unprivileged child failed");
	} else if (pid != 0) {
		debug2("Network child is on pid %ld", (long)pid);

		pmonitor->m_pid = pid;
		if (have_agent) {
			r = ssh_get_authentication_socket(&auth_sock);
			if (r != 0) {
				error("Could not get agent socket: %s",
				    ssh_err(r));
				have_agent = 0;
			}
		}
		if (box != NULL)
			ssh_sandbox_parent_preauth(box, pid);
		monitor_child_preauth(authctxt, pmonitor);

		/* Wait for the child's exit status */
		while (waitpid(pid, &status, 0) < 0) {
			if (errno == EINTR)
				continue;
			pmonitor->m_pid = -1;
			fatal("%s: waitpid: %s", __func__, strerror(errno));
		}
		privsep_is_preauth = 0;
		pmonitor->m_pid = -1;
		if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) != 0)
				fatal("%s: preauth child exited with status %d",
				    __func__, WEXITSTATUS(status));
		} else if (WIFSIGNALED(status))
			fatal("%s: preauth child terminated by signal %d",
			    __func__, WTERMSIG(status));
		if (box != NULL)
			ssh_sandbox_parent_finish(box);
		return 1;
	} else {
		/* child */
		close(pmonitor->m_sendfd);
		close(pmonitor->m_log_recvfd);

		/* Arrange for logging to be sent to the monitor */
		set_log_handler(mm_log_handler, pmonitor);

		privsep_preauth_child();
		setproctitle("%s", "[net]");
		if (box != NULL)
			ssh_sandbox_child(box);

		return 0;
	}
}

static void
privsep_postauth(Authctxt *authctxt)
{
	if (authctxt->pw->pw_uid == 0) {
		/* File descriptor passing is broken or root login */
		use_privsep = 0;
		goto skip;
	}

	/* New socket pair */
	monitor_reinit(pmonitor);

	pmonitor->m_pid = fork();
	if (pmonitor->m_pid == -1)
		fatal("fork of unprivileged child failed");
	else if (pmonitor->m_pid != 0) {
		verbose("User child is on pid %ld", (long)pmonitor->m_pid);
		buffer_clear(&loginmsg);
		monitor_clear_keystate(pmonitor);
		monitor_child_postauth(pmonitor);

		/* NEVERREACHED */
		exit(0);
	}

	/* child */

	close(pmonitor->m_sendfd);
	pmonitor->m_sendfd = -1;

	/* Demote the private keys to public keys. */
	demote_sensitive_data();

	/* Drop privileges */
	do_setusercontext(authctxt->pw);

 skip:
	/* It is safe now to apply the key state */
	monitor_apply_keystate(pmonitor);

	/*
	 * Tell the packet layer that authentication was successful, since
	 * this information is not part of the key state.
	 */
	packet_set_authenticated();
}

static char *
list_hostkey_types(void)
{
	Buffer b;
	const char *p;
	char *ret;
	int i;
	struct sshkey *key;

	buffer_init(&b);
	for (i = 0; i < options.num_host_key_files; i++) {
		key = sensitive_data.host_keys[i];
		if (key == NULL)
			key = sensitive_data.host_pubkeys[i];
		if (key == NULL)
			continue;
		/* Check that the key is accepted in HostkeyAlgorithms */
		if (match_pattern_list(sshkey_ssh_name(key),
		    options.hostkeyalgorithms, 0) != 1) {
			debug3("%s: %s key not permitted by HostkeyAlgorithms",
			    __func__, sshkey_ssh_name(key));
			continue;
		}
		switch (key->type) {
		case KEY_RSA:
		case KEY_DSA:
		case KEY_ECDSA:
		case KEY_ED25519:
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			p = key_ssh_name(key);
			buffer_append(&b, p, strlen(p));

			/* for RSA we also support SHA2 signatures */
			if (key->type == KEY_RSA) {
				p = ",rsa-sha2-512,rsa-sha2-256";
				buffer_append(&b, p, strlen(p));
			}
			break;
		}
		/* If the private key has a cert peer, then list that too */
		key = sensitive_data.host_certificates[i];
		if (key == NULL)
			continue;
		switch (key->type) {
		case KEY_RSA_CERT:
		case KEY_DSA_CERT:
		case KEY_ECDSA_CERT:
		case KEY_ED25519_CERT:
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			p = key_ssh_name(key);
			buffer_append(&b, p, strlen(p));
			break;
		}
	}
	if ((ret = sshbuf_dup_string(&b)) == NULL)
		fatal("%s: sshbuf_dup_string failed", __func__);
	buffer_free(&b);
	debug("list_hostkey_types: %s", ret);
	return ret;
}

static struct sshkey *
get_hostkey_by_type(int type, int nid, int need_private, struct ssh *ssh)
{
	int i;
	struct sshkey *key;

	for (i = 0; i < options.num_host_key_files; i++) {
		switch (type) {
		case KEY_RSA_CERT:
		case KEY_DSA_CERT:
		case KEY_ECDSA_CERT:
		case KEY_ED25519_CERT:
			key = sensitive_data.host_certificates[i];
			break;
		default:
			key = sensitive_data.host_keys[i];
			if (key == NULL && !need_private)
				key = sensitive_data.host_pubkeys[i];
			break;
		}
		if (key != NULL && key->type == type &&
		    (key->type != KEY_ECDSA || key->ecdsa_nid == nid))
			return need_private ?
			    sensitive_data.host_keys[i] : key;
	}
	return NULL;
}

struct sshkey *
get_hostkey_public_by_type(int type, int nid, struct ssh *ssh)
{
	return get_hostkey_by_type(type, nid, 0, ssh);
}

struct sshkey *
get_hostkey_private_by_type(int type, int nid, struct ssh *ssh)
{
	return get_hostkey_by_type(type, nid, 1, ssh);
}

struct sshkey *
get_hostkey_by_index(int ind)
{
	if (ind < 0 || ind >= options.num_host_key_files)
		return (NULL);
	return (sensitive_data.host_keys[ind]);
}

struct sshkey *
get_hostkey_public_by_index(int ind, struct ssh *ssh)
{
	if (ind < 0 || ind >= options.num_host_key_files)
		return (NULL);
	return (sensitive_data.host_pubkeys[ind]);
}

int
get_hostkey_index(struct sshkey *key, int compare, struct ssh *ssh)
{
	int i;

	for (i = 0; i < options.num_host_key_files; i++) {
		if (key_is_cert(key)) {
			if (key == sensitive_data.host_certificates[i] ||
			    (compare && sensitive_data.host_certificates[i] &&
			    sshkey_equal(key,
			    sensitive_data.host_certificates[i])))
				return (i);
		} else {
			if (key == sensitive_data.host_keys[i] ||
			    (compare && sensitive_data.host_keys[i] &&
			    sshkey_equal(key, sensitive_data.host_keys[i])))
				return (i);
			if (key == sensitive_data.host_pubkeys[i] ||
			    (compare && sensitive_data.host_pubkeys[i] &&
			    sshkey_equal(key, sensitive_data.host_pubkeys[i])))
				return (i);
		}
	}
	return (-1);
}

/* Inform the client of all hostkeys */
static void
notify_hostkeys(struct ssh *ssh)
{
	struct sshbuf *buf;
	struct sshkey *key;
	int i, nkeys, r;
	char *fp;

	/* Some clients cannot cope with the hostkeys message, skip those. */
	if (datafellows & SSH_BUG_HOSTKEYS)
		return;

	if ((buf = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new", __func__);
	for (i = nkeys = 0; i < options.num_host_key_files; i++) {
		key = get_hostkey_public_by_index(i, ssh);
		if (key == NULL || key->type == KEY_UNSPEC ||
		    sshkey_is_cert(key))
			continue;
		fp = sshkey_fingerprint(key, options.fingerprint_hash,
		    SSH_FP_DEFAULT);
		debug3("%s: key %d: %s %s", __func__, i,
		    sshkey_ssh_name(key), fp);
		free(fp);
		if (nkeys == 0) {
			packet_start(SSH2_MSG_GLOBAL_REQUEST);
			packet_put_cstring("hostkeys-00@@openssh.com");
			packet_put_char(0); /* want-reply */
		}
		sshbuf_reset(buf);
		if ((r = sshkey_putb(key, buf)) != 0)
			fatal("%s: couldn't put hostkey %d: %s",
			    __func__, i, ssh_err(r));
		packet_put_string(sshbuf_ptr(buf), sshbuf_len(buf));
		nkeys++;
	}
	debug3("%s: sent %d hostkeys", __func__, nkeys);
	if (nkeys == 0)
		fatal("%s: no hostkeys", __func__);
	packet_send();
	sshbuf_free(buf);
}

/*
 * returns 1 if connection should be dropped, 0 otherwise.
 * dropping starts at connection #max_startups_begin with a probability
 * of (max_startups_rate/100). the probability increases linearly until
 * all connections are dropped for startups > max_startups
 */
static int
drop_connection(int startups)
{
	int p, r;

	if (startups < options.max_startups_begin)
		return 0;
	if (startups >= options.max_startups)
		return 1;
	if (options.max_startups_rate == 100)
		return 1;

	p  = 100 - options.max_startups_rate;
	p *= startups - options.max_startups_begin;
	p /= options.max_startups - options.max_startups_begin;
	p += options.max_startups_rate;
	r = arc4random_uniform(100);

	debug("drop_connection: p %d, r %d", p, r);
	return (r < p) ? 1 : 0;
}

static void
usage(void)
{
	fprintf(stderr, "%s, %s\n",
	    SSH_VERSION,
#ifdef WITH_OPENSSL
	    SSLeay_version(SSLEAY_VERSION)
#else
	    "without OpenSSL"
#endif
	);
	fprintf(stderr,
"usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]\n"
"            [-E log_file] [-f config_file] [-g login_grace_time]\n"
"            [-h host_key_file] [-o option] [-p port] [-u len]\n"
	);
	exit(1);
}

static void
send_rexec_state(int fd, struct sshbuf *conf)
{
	struct sshbuf *m;
	int r;

	debug3("%s: entering fd = %d config len %zu", __func__, fd,
	    sshbuf_len(conf));

	/*
	 * Protocol from reexec master to child:
	 *	string	configuration
	 */
	if ((m = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_stringb(m, conf)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (ssh_msg_send(fd, 0, m) == -1)
		fatal("%s: ssh_msg_send failed", __func__);

	sshbuf_free(m);

	debug3("%s: done", __func__);
}

static void
recv_rexec_state(int fd, Buffer *conf)
{
	Buffer m;
	char *cp;
	u_int len;

	debug3("%s: entering fd = %d", __func__, fd);

	buffer_init(&m);

	if (ssh_msg_recv(fd, &m) == -1)
		fatal("%s: ssh_msg_recv failed", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: rexec version mismatch", __func__);

	cp = buffer_get_string(&m, &len);
	if (conf != NULL)
		buffer_append(conf, cp, len);
	free(cp);

	buffer_free(&m);

	debug3("%s: done", __func__);
}

/* Accept a connection from inetd */
static void
server_accept_inetd(int *sock_in, int *sock_out)
{
	int fd;

	startup_pipe = -1;
	if (rexeced_flag) {
		close(REEXEC_CONFIG_PASS_FD);
		*sock_in = *sock_out = dup(STDIN_FILENO);
		if (!debug_flag) {
			startup_pipe = dup(REEXEC_STARTUP_PIPE_FD);
			close(REEXEC_STARTUP_PIPE_FD);
		}
	} else {
		*sock_in = dup(STDIN_FILENO);
		*sock_out = dup(STDOUT_FILENO);
	}
	/*
	 * We intentionally do not close the descriptors 0, 1, and 2
	 * as our code for setting the descriptors won't work if
	 * ttyfd happens to be one of those.
	 */
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		dup2(fd, STDIN_FILENO);
		dup2(fd, STDOUT_FILENO);
		if (!log_stderr)
			dup2(fd, STDERR_FILENO);
		if (fd > (log_stderr ? STDERR_FILENO : STDOUT_FILENO))
			close(fd);
	}
	debug("inetd sockets after dupping: %d, %d", *sock_in, *sock_out);
}

/*
 * Listen for TCP connections
 */
static void
server_listen(void)
{
	int ret, listen_sock, on = 1;
	struct addrinfo *ai;
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];

	for (ai = options.listen_addrs; ai; ai = ai->ai_next) {
		if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
			continue;
		if (num_listen_socks >= MAX_LISTEN_SOCKS)
			fatal("Too many listen sockets. "
			    "Enlarge MAX_LISTEN_SOCKS");
		if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,
		    ntop, sizeof(ntop), strport, sizeof(strport),
		    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
			error("getnameinfo failed: %.100s",
			    ssh_gai_strerror(ret));
			continue;
		}
		/* Create socket for listening. */
		listen_sock = socket(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol);
		if (listen_sock < 0) {
			/* kernel may not support ipv6 */
			verbose("socket: %.100s", strerror(errno));
			continue;
		}
		if (set_nonblock(listen_sock) == -1) {
			close(listen_sock);
			continue;
		}
		if (fcntl(listen_sock, F_SETFD, FD_CLOEXEC) == -1) {
			verbose("socket: CLOEXEC: %s", strerror(errno));
			close(listen_sock);
			continue;
		}
		/*
		 * Set socket options.
		 * Allow local port reuse in TIME_WAIT.
		 */
		if (setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR,
		    &on, sizeof(on)) == -1)
			error("setsockopt SO_REUSEADDR: %s", strerror(errno));

		debug("Bind to port %s on %s.", strport, ntop);

		/* Bind the socket to the desired port. */
		if (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {
			error("Bind to port %s on %s failed: %.200s.",
			    strport, ntop, strerror(errno));
			close(listen_sock);
			continue;
		}
		listen_socks[num_listen_socks] = listen_sock;
		num_listen_socks++;

		/* Start listening on the port. */
		if (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)
			fatal("listen on [%s]:%s: %.100s",
			    ntop, strport, strerror(errno));
		logit("Server listening on %s port %s.", ntop, strport);
	}
	freeaddrinfo(options.listen_addrs);

	if (!num_listen_socks)
		fatal("Cannot bind any address.");
}

/*
 * The main TCP accept loop. Note that, for the non-debug case, returns
 * from this function are in a forked subprocess.
 */
static void
server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
{
	fd_set *fdset;
	int i, j, ret, maxfd;
	int startups = 0;
	int startup_p[2] = { -1 , -1 };
	struct sockaddr_storage from;
	socklen_t fromlen;
	pid_t pid;

	/* setup fd set for accept */
	fdset = NULL;
	maxfd = 0;
	for (i = 0; i < num_listen_socks; i++)
		if (listen_socks[i] > maxfd)
			maxfd = listen_socks[i];
	/* pipes connected to unauthenticated childs */
	startup_pipes = xcalloc(options.max_startups, sizeof(int));
	for (i = 0; i < options.max_startups; i++)
		startup_pipes[i] = -1;

	/*
	 * Stay listening for connections until the system crashes or
	 * the daemon is killed with a signal.
	 */
	for (;;) {
		if (received_sighup)
			sighup_restart();
		free(fdset);
		fdset = xcalloc(howmany(maxfd + 1, NFDBITS),
		    sizeof(fd_mask));

		for (i = 0; i < num_listen_socks; i++)
			FD_SET(listen_socks[i], fdset);
		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1)
				FD_SET(startup_pipes[i], fdset);

		/* Wait in select until there is a connection. */
		ret = select(maxfd+1, fdset, NULL, NULL, NULL);
		if (ret < 0 && errno != EINTR)
			error("select: %.100s", strerror(errno));
		if (received_sigterm) {
			logit("Received signal %d; terminating.",
			    (int) received_sigterm);
			close_listen_socks();
			if (options.pid_file != NULL)
				unlink(options.pid_file);
			exit(received_sigterm == SIGTERM ? 0 : 255);
		}
		if (ret < 0)
			continue;

		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1 &&
			    FD_ISSET(startup_pipes[i], fdset)) {
				/*
				 * the read end of the pipe is ready
				 * if the child has closed the pipe
				 * after successful authentication
				 * or if the child has died
				 */
				close(startup_pipes[i]);
				startup_pipes[i] = -1;
				startups--;
			}
		for (i = 0; i < num_listen_socks; i++) {
			if (!FD_ISSET(listen_socks[i], fdset))
				continue;
			fromlen = sizeof(from);
			*newsock = accept(listen_socks[i],
			    (struct sockaddr *)&from, &fromlen);
			if (*newsock < 0) {
				if (errno != EINTR && errno != EWOULDBLOCK &&
				    errno != ECONNABORTED)
					error("accept: %.100s",
					    strerror(errno));
				if (errno == EMFILE || errno == ENFILE)
					usleep(100 * 1000);
				continue;
			}
			if (unset_nonblock(*newsock) == -1) {
				close(*newsock);
				continue;
			}
			if (drop_connection(startups) == 1) {
				char *laddr = get_local_ipaddr(*newsock);
				char *raddr = get_peer_ipaddr(*newsock);

				verbose("drop connection #%d from [%s]:%d "
				    "on [%s]:%d past MaxStartups", startups,
				    raddr, get_peer_port(*newsock),
				    laddr, get_local_port(*newsock));
				free(laddr);
				free(raddr);
				close(*newsock);
				continue;
			}
			if (pipe(startup_p) == -1) {
				close(*newsock);
				continue;
			}

			if (rexec_flag && socketpair(AF_UNIX,
			    SOCK_STREAM, 0, config_s) == -1) {
				error("reexec socketpair: %s",
				    strerror(errno));
				close(*newsock);
				close(startup_p[0]);
				close(startup_p[1]);
				continue;
			}

			for (j = 0; j < options.max_startups; j++)
				if (startup_pipes[j] == -1) {
					startup_pipes[j] = startup_p[0];
					if (maxfd < startup_p[0])
						maxfd = startup_p[0];
					startups++;
					break;
				}

			/*
			 * Got connection.  Fork a child to handle it, unless
			 * we are in debugging mode.
			 */
			if (debug_flag) {
				/*
				 * In debugging mode.  Close the listening
				 * socket, and start processing the
				 * connection without forking.
				 */
				debug("Server will not fork when running in debugging mode.");
				close_listen_socks();
				*sock_in = *newsock;
				*sock_out = *newsock;
				close(startup_p[0]);
				close(startup_p[1]);
				startup_pipe = -1;
				pid = getpid();
				if (rexec_flag) {
					send_rexec_state(config_s[0],
					    &cfg);
					close(config_s[0]);
				}
				break;
			}

			/*
			 * Normal production daemon.  Fork, and have
			 * the child process the connection. The
			 * parent continues listening.
			 */
			if ((pid = fork()) == 0) {
				/*
				 * Child.  Close the listening and
				 * max_startup sockets.  Start using
				 * the accepted socket. Reinitialize
				 * logging (since our pid has changed).
				 * We break out of the loop to handle
				 * the connection.
				 */
				startup_pipe = startup_p[1];
				close_startup_pipes();
				close_listen_socks();
				*sock_in = *newsock;
				*sock_out = *newsock;
				log_init(__progname,
				    options.log_level,
				    options.log_facility,
				    log_stderr);
				if (rexec_flag)
					close(config_s[0]);
				break;
			}

			/* Parent.  Stay in the loop. */
			if (pid < 0)
				error("fork: %.100s", strerror(errno));
			else
				debug("Forked child %ld.", (long)pid);

			close(startup_p[1]);

			if (rexec_flag) {
				send_rexec_state(config_s[0], &cfg);
				close(config_s[0]);
				close(config_s[1]);
			}
			close(*newsock);
		}

		/* child process check (or debug mode) */
		if (num_listen_socks < 0)
			break;
	}
}

/*
 * If IP options are supported, make sure there are none (log and
 * return an error if any are found).  Basically we are worried about
 * source routing; it can be used to pretend you are somebody
 * (ip-address) you are not. That itself may be "almost acceptable"
 * under certain circumstances, but rhosts autentication is useless
 * if source routing is accepted. Notice also that if we just dropped
 * source routing here, the other side could use IP spoofing to do
 * rest of the interaction and could still bypass security.  So we
 * exit here if we detect any IP options.
 */
static void
check_ip_options(struct ssh *ssh)
{
	int sock_in = ssh_packet_get_connection_in(ssh);
	struct sockaddr_storage from;
	u_char opts[200];
	socklen_t i, option_size = sizeof(opts), fromlen = sizeof(from);
	char text[sizeof(opts) * 3 + 1];

	memset(&from, 0, sizeof(from));
	if (getpeername(sock_in, (struct sockaddr *)&from,
	    &fromlen) < 0)
		return;
	if (from.ss_family != AF_INET)
		return;
	/* XXX IPv6 options? */

	if (getsockopt(sock_in, IPPROTO_IP, IP_OPTIONS, opts,
	    &option_size) >= 0 && option_size != 0) {
		text[0] = '\0';
		for (i = 0; i < option_size; i++)
			snprintf(text + i*3, sizeof(text) - i*3,
			    " %2.2x", opts[i]);
		fatal("Connection from %.100s port %d with IP opts: %.800s",
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), text);
	}
	return;
}

/*
 * Main program for the daemon.
 */
int
main(int ac, char **av)
{
	struct ssh *ssh = NULL;
	extern char *optarg;
	extern int optind;
	int r, opt, i, j, on = 1, already_daemon;
	int sock_in = -1, sock_out = -1, newsock = -1;
	const char *remote_ip;
	int remote_port;
	char *fp, *line, *laddr, *logfile = NULL;
	int config_s[2] = { -1 , -1 };
	u_int n;
	u_int64_t ibytes, obytes;
	mode_t new_umask;
	struct sshkey *key;
	struct sshkey *pubkey;
	int keytype;
	Authctxt *authctxt;
	struct connection_info *connection_info = get_connection_info(0, 0);

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Save argv. */
	saved_argv = av;
	rexec_argc = ac;

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/* Initialize configuration options to their default values. */
	initialize_server_options(&options);

	/* Parse command-line arguments. */
	while ((opt = getopt(ac, av,
	    "C:E:b:c:f:g:h:k:o:p:u:46DQRTdeiqrt")) != -1) {
		switch (opt) {
		case '4':
			options.address_family = AF_INET;
			break;
		case '6':
			options.address_family = AF_INET6;
			break;
		case 'f':
			config_file_name = optarg;
			break;
		case 'c':
			if (options.num_host_cert_files >= MAX_HOSTCERTS) {
				fprintf(stderr, "too many host certificates.\n");
				exit(1);
			}
			options.host_cert_files[options.num_host_cert_files++] =
			   derelativise_path(optarg);
			break;
		case 'd':
			if (debug_flag == 0) {
				debug_flag = 1;
				options.log_level = SYSLOG_LEVEL_DEBUG1;
			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3)
				options.log_level++;
			break;
		case 'D':
			no_daemon_flag = 1;
			break;
		case 'E':
			logfile = optarg;
			/* FALLTHROUGH */
		case 'e':
			log_stderr = 1;
			break;
		case 'i':
			inetd_flag = 1;
			break;
		case 'r':
			rexec_flag = 0;
			break;
		case 'R':
			rexeced_flag = 1;
			inetd_flag = 1;
			break;
		case 'Q':
			/* ignored */
			break;
		case 'q':
			options.log_level = SYSLOG_LEVEL_QUIET;
			break;
		case 'b':
			/* protocol 1, ignored */
			break;
		case 'p':
			options.ports_from_cmdline = 1;
			if (options.num_ports >= MAX_PORTS) {
				fprintf(stderr, "too many ports.\n");
				exit(1);
			}
			options.ports[options.num_ports++] = a2port(optarg);
			if (options.ports[options.num_ports-1] <= 0) {
				fprintf(stderr, "Bad port number.\n");
				exit(1);
			}
			break;
		case 'g':
			if ((options.login_grace_time = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid login grace time.\n");
				exit(1);
			}
			break;
		case 'k':
			/* protocol 1, ignored */
			break;
		case 'h':
			if (options.num_host_key_files >= MAX_HOSTKEYS) {
				fprintf(stderr, "too many host keys.\n");
				exit(1);
			}
			options.host_key_files[options.num_host_key_files++] = 
			   derelativise_path(optarg);
			break;
		case 't':
			test_flag = 1;
			break;
		case 'T':
			test_flag = 2;
			break;
		case 'C':
			if (parse_server_match_testspec(connection_info,
			    optarg) == -1)
				exit(1);
			break;
		case 'u':
			utmp_len = (u_int)strtonum(optarg, 0, HOST_NAME_MAX+1+1, NULL);
			if (utmp_len > HOST_NAME_MAX+1) {
				fprintf(stderr, "Invalid utmp length.\n");
				exit(1);
			}
			break;
		case 'o':
			line = xstrdup(optarg);
			if (process_server_config_line(&options, line,
			    "command-line", 0, NULL, NULL) != 0)
				exit(1);
			free(line);
			break;
		case '?':
		default:
			usage();
			break;
		}
	}
	if (rexeced_flag || inetd_flag)
		rexec_flag = 0;
	if (!test_flag && (rexec_flag && (av[0] == NULL || *av[0] != '/')))
		fatal("sshd re-exec requires execution with an absolute path");
	if (rexeced_flag)
		closefrom(REEXEC_MIN_FREE_FD);
	else
		closefrom(REEXEC_DEVCRYPTO_RESERVED_FD);

#ifdef WITH_OPENSSL
	OpenSSL_add_all_algorithms();
#endif

	/* If requested, redirect the logs to the specified logfile. */
	if (logfile != NULL)
		log_redirect_stderr_to(logfile);
	/*
	 * Force logging to stderr until we have loaded the private host
	 * key (unless started from inetd)
	 */
	log_init(__progname,
	    options.log_level == SYSLOG_LEVEL_NOT_SET ?
	    SYSLOG_LEVEL_INFO : options.log_level,
	    options.log_facility == SYSLOG_FACILITY_NOT_SET ?
	    SYSLOG_FACILITY_AUTH : options.log_facility,
	    log_stderr || !inetd_flag);

	sensitive_data.have_ssh2_key = 0;

	/*
	 * If we're doing an extended config test, make sure we have all of
	 * the parameters we need.  If we're not doing an extended test,
	 * do not silently ignore connection test params.
	 */
	if (test_flag >= 2 && server_match_spec_complete(connection_info) == 0)
		fatal("user, host and addr are all required when testing "
		   "Match configs");
	if (test_flag < 2 && server_match_spec_complete(connection_info) >= 0)
		fatal("Config test connection parameter (-C) provided without "
		   "test mode (-T)");

	/* Fetch our configuration */
	buffer_init(&cfg);
	if (rexeced_flag)
		recv_rexec_state(REEXEC_CONFIG_PASS_FD, &cfg);
	else if (strcasecmp(config_file_name, "none") != 0)
		load_server_config(config_file_name, &cfg);

	parse_server_config(&options, rexeced_flag ? "rexec" : config_file_name,
	    &cfg, NULL);

	/* Fill in default values for those options not explicitly set. */
	fill_default_server_options(&options);

	/* challenge-response is implemented via keyboard interactive */
	if (options.challenge_response_authentication)
		options.kbd_interactive_authentication = 1;

	/* Check that options are sensible */
	if (options.authorized_keys_command_user == NULL &&
	    (options.authorized_keys_command != NULL &&
	    strcasecmp(options.authorized_keys_command, "none") != 0))
		fatal("AuthorizedKeysCommand set without "
		    "AuthorizedKeysCommandUser");
	if (options.authorized_principals_command_user == NULL &&
	    (options.authorized_principals_command != NULL &&
	    strcasecmp(options.authorized_principals_command, "none") != 0))
		fatal("AuthorizedPrincipalsCommand set without "
		    "AuthorizedPrincipalsCommandUser");

	/*
	 * Check whether there is any path through configured auth methods.
	 * Unfortunately it is not possible to verify this generally before
	 * daemonisation in the presence of Match block, but this catches
	 * and warns for trivial misconfigurations that could break login.
	 */
	if (options.num_auth_methods != 0) {
		for (n = 0; n < options.num_auth_methods; n++) {
			if (auth2_methods_valid(options.auth_methods[n],
			    1) == 0)
				break;
		}
		if (n >= options.num_auth_methods)
			fatal("AuthenticationMethods cannot be satisfied by "
			    "enabled authentication methods");
	}

	/* Check that there are no remaining arguments. */
	if (optind < ac) {
		fprintf(stderr, "Extra argument %s.\n", av[optind]);
		exit(1);
	}

	debug("sshd version %s, %s", SSH_VERSION,
#ifdef WITH_OPENSSL
	    SSLeay_version(SSLEAY_VERSION)
#else
	    "without OpenSSL"
#endif
	);

	/* load host keys */
	sensitive_data.host_keys = xcalloc(options.num_host_key_files,
	    sizeof(struct sshkey *));
	sensitive_data.host_pubkeys = xcalloc(options.num_host_key_files,
	    sizeof(struct sshkey *));

	if (options.host_key_agent) {
		if (strcmp(options.host_key_agent, SSH_AUTHSOCKET_ENV_NAME))
			setenv(SSH_AUTHSOCKET_ENV_NAME,
			    options.host_key_agent, 1);
		if ((r = ssh_get_authentication_socket(NULL)) == 0)
			have_agent = 1;
		else
			error("Could not connect to agent \"%s\": %s",
			    options.host_key_agent, ssh_err(r));
	}

	for (i = 0; i < options.num_host_key_files; i++) {
		if (options.host_key_files[i] == NULL)
			continue;
		key = key_load_private(options.host_key_files[i], "", NULL);
		pubkey = key_load_public(options.host_key_files[i], NULL);

		if (pubkey == NULL && key != NULL)
			pubkey = key_demote(key);
		sensitive_data.host_keys[i] = key;
		sensitive_data.host_pubkeys[i] = pubkey;

		if (key == NULL && pubkey != NULL && have_agent) {
			debug("will rely on agent for hostkey %s",
			    options.host_key_files[i]);
			keytype = pubkey->type;
		} else if (key != NULL) {
			keytype = key->type;
		} else {
			error("Could not load host key: %s",
			    options.host_key_files[i]);
			sensitive_data.host_keys[i] = NULL;
			sensitive_data.host_pubkeys[i] = NULL;
			continue;
		}

		switch (keytype) {
		case KEY_RSA:
		case KEY_DSA:
		case KEY_ECDSA:
		case KEY_ED25519:
			if (have_agent || key != NULL)
				sensitive_data.have_ssh2_key = 1;
			break;
		}
		if ((fp = sshkey_fingerprint(pubkey, options.fingerprint_hash,
		    SSH_FP_DEFAULT)) == NULL)
			fatal("sshkey_fingerprint failed");
		debug("%s host key #%d: %s %s",
		    key ? "private" : "agent", i, sshkey_ssh_name(pubkey), fp);
		free(fp);
	}
	if (!sensitive_data.have_ssh2_key) {
		logit("sshd: no hostkeys available -- exiting.");
		exit(1);
	}

	/*
	 * Load certificates. They are stored in an array at identical
	 * indices to the public keys that they relate to.
	 */
	sensitive_data.host_certificates = xcalloc(options.num_host_key_files,
	    sizeof(struct sshkey *));
	for (i = 0; i < options.num_host_key_files; i++)
		sensitive_data.host_certificates[i] = NULL;

	for (i = 0; i < options.num_host_cert_files; i++) {
		if (options.host_cert_files[i] == NULL)
			continue;
		key = key_load_public(options.host_cert_files[i], NULL);
		if (key == NULL) {
			error("Could not load host certificate: %s",
			    options.host_cert_files[i]);
			continue;
		}
		if (!key_is_cert(key)) {
			error("Certificate file is not a certificate: %s",
			    options.host_cert_files[i]);
			key_free(key);
			continue;
		}
		/* Find matching private key */
		for (j = 0; j < options.num_host_key_files; j++) {
			if (key_equal_public(key,
			    sensitive_data.host_keys[j])) {
				sensitive_data.host_certificates[j] = key;
				break;
			}
		}
		if (j >= options.num_host_key_files) {
			error("No matching private key for certificate: %s",
			    options.host_cert_files[i]);
			key_free(key);
			continue;
		}
		sensitive_data.host_certificates[j] = key;
		debug("host certificate: #%d type %d %s", j, key->type,
		    key_type(key));
	}

	if (use_privsep) {
		struct stat st;

		if (getpwnam(SSH_PRIVSEP_USER) == NULL)
			fatal("Privilege separation user %s does not exist",
			    SSH_PRIVSEP_USER);
		if ((stat(_PATH_PRIVSEP_CHROOT_DIR, &st) == -1) ||
		    (S_ISDIR(st.st_mode) == 0))
			fatal("Missing privilege separation directory: %s",
			    _PATH_PRIVSEP_CHROOT_DIR);
		if (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)
			fatal("%s must be owned by root and not group or "
			    "world-writable.", _PATH_PRIVSEP_CHROOT_DIR);
	}

	if (test_flag > 1) {
		if (server_match_spec_complete(connection_info) == 1)
			parse_server_match_config(&options, connection_info);
		dump_config(&options);
	}

	/* Configuration looks good, so exit if in test mode. */
	if (test_flag)
		exit(0);

	if (rexec_flag) {
		rexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));
		for (i = 0; i < rexec_argc; i++) {
			debug("rexec_argv[%d]='%s'", i, saved_argv[i]);
			rexec_argv[i] = saved_argv[i];
		}
		rexec_argv[rexec_argc] = "-R";
		rexec_argv[rexec_argc + 1] = NULL;
	}

	/* Ensure that umask disallows at least group and world write */
	new_umask = umask(0077) | 0022;
	(void) umask(new_umask);

	/* Initialize the log (it is reinitialized below in case we forked). */
	if (debug_flag && (!inetd_flag || rexeced_flag))
		log_stderr = 1;
	log_init(__progname, options.log_level, options.log_facility, log_stderr);

	/*
	 * If not in debugging mode, not started from inetd and not already
	 * daemonized (eg re-exec via SIGHUP), disconnect from the controlling
	 * terminal, and fork.  The original process exits.
	 */
	already_daemon = daemonized();
	if (!(debug_flag || inetd_flag || no_daemon_flag || already_daemon)) {

		if (daemon(0, 0) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));

		disconnect_controlling_tty();
	}
	/* Reinitialize the log (because of the fork above). */
	log_init(__progname, options.log_level, options.log_facility, log_stderr);

	/* Chdir to the root directory so that the current disk can be
	   unmounted if desired. */
	if (chdir("/") == -1)
		error("chdir(\"/\"): %s", strerror(errno));

	/* ignore SIGPIPE */
	signal(SIGPIPE, SIG_IGN);

	/* Get a connection, either from inetd or a listening TCP socket */
	if (inetd_flag) {
		server_accept_inetd(&sock_in, &sock_out);
	} else {
		server_listen();

		signal(SIGHUP, sighup_handler);
		signal(SIGCHLD, main_sigchld_handler);
		signal(SIGTERM, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);

		/*
		 * Write out the pid file after the sigterm handler
		 * is setup and the listen sockets are bound
		 */
		if (options.pid_file != NULL && !debug_flag) {
			FILE *f = fopen(options.pid_file, "w");

			if (f == NULL) {
				error("Couldn't create pid file \"%s\": %s",
				    options.pid_file, strerror(errno));
			} else {
				fprintf(f, "%ld\n", (long) getpid());
				fclose(f);
			}
		}

		/* Accept a connection and return in a forked child */
		server_accept_loop(&sock_in, &sock_out,
		    &newsock, config_s);
	}

	/* This is the child processing a new connection. */
	setproctitle("%s", "[accepted]");

	/*
	 * Create a new session and process group since the 4.4BSD
	 * setlogin() affects the entire process group.  We don't
	 * want the child to be able to affect the parent.
	 */
	if (!debug_flag && !inetd_flag && setsid() < 0)
		error("setsid: %.100s", strerror(errno));

	if (rexec_flag) {
		int fd;

		debug("rexec start in %d out %d newsock %d pipe %d sock %d",
		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
		dup2(newsock, STDIN_FILENO);
		dup2(STDIN_FILENO, STDOUT_FILENO);
		if (startup_pipe == -1)
			close(REEXEC_STARTUP_PIPE_FD);
		else if (startup_pipe != REEXEC_STARTUP_PIPE_FD) {
			dup2(startup_pipe, REEXEC_STARTUP_PIPE_FD);
			close(startup_pipe);
			startup_pipe = REEXEC_STARTUP_PIPE_FD;
		}

		dup2(config_s[1], REEXEC_CONFIG_PASS_FD);
		close(config_s[1]);

		execv(rexec_argv[0], rexec_argv);

		/* Reexec has failed, fall back and continue */
		error("rexec of %s failed: %s", rexec_argv[0], strerror(errno));
		recv_rexec_state(REEXEC_CONFIG_PASS_FD, NULL);
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);

		/* Clean up fds */
		close(REEXEC_CONFIG_PASS_FD);
		newsock = sock_out = sock_in = dup(STDIN_FILENO);
		if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			if (fd > STDERR_FILENO)
				close(fd);
		}
		debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d",
		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
	}

	/* Executed child processes don't need these. */
	fcntl(sock_out, F_SETFD, FD_CLOEXEC);
	fcntl(sock_in, F_SETFD, FD_CLOEXEC);

	/*
	 * Disable the key regeneration alarm.  We will not regenerate the
	 * key since we are no longer in a position to give it to anyone. We
	 * will not restart on SIGHUP since it no longer makes sense.
	 */
	alarm(0);
	signal(SIGALRM, SIG_DFL);
	signal(SIGHUP, SIG_DFL);
	signal(SIGTERM, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
	signal(SIGCHLD, SIG_DFL);

	/*
	 * Register our connection.  This turns encryption off because we do
	 * not have a key.
	 */
	packet_set_connection(sock_in, sock_out);
	packet_set_server();
	ssh = active_state; /* XXX */

	check_ip_options(ssh);

	/* Prepare the channels layer */
	channel_init_channels(ssh);
	channel_set_af(ssh, options.address_family);
	process_permitopen(ssh, &options);

	/* Set SO_KEEPALIVE if requested. */
	if (options.tcp_keep_alive && packet_connection_is_on_socket() &&
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));

	if ((remote_port = ssh_remote_port(ssh)) < 0) {
		debug("ssh_remote_port failed");
		cleanup_exit(255);
	}

	/*
	 * The rest of the code depends on the fact that
	 * ssh_remote_ipaddr() caches the remote ip, even if
	 * the socket goes away.
	 */
	remote_ip = ssh_remote_ipaddr(ssh);

	/* Log the connection. */
	laddr = get_local_ipaddr(sock_in);
	verbose("Connection from %s port %d on %s port %d",
	    remote_ip, remote_port, laddr,  ssh_local_port(ssh));
	free(laddr);

	/*
	 * We don't want to listen forever unless the other side
	 * successfully authenticates itself.  So we set up an alarm which is
	 * cleared after successful authentication.  A limit of zero
	 * indicates no limit. Note that we don't set the alarm in debugging
	 * mode; it is just annoying to have the server exit just when you
	 * are about to discover the bug.
	 */
	signal(SIGALRM, grace_alarm_handler);
	if (!debug_flag)
		alarm(options.login_grace_time);

	sshd_exchange_identification(ssh, sock_in, sock_out);
	packet_set_nonblocking();

	/* allocate authentication context */
	authctxt = xcalloc(1, sizeof(*authctxt));

	/* XXX global for cleanup, access from other modules */
	the_authctxt = authctxt;

	/* prepare buffer to collect messages to display to user after login */
	buffer_init(&loginmsg);
	auth_debug_reset();

	if (use_privsep) {
		if (privsep_preauth(authctxt) == 1)
			goto authenticated;
	} else if (have_agent) {
		if ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {
			error("Unable to get agent socket: %s", ssh_err(r));
			have_agent = 0;
		}
	}

	/* perform the key exchange */
	/* authenticate user and start session */
	do_ssh2_kex();
	do_authentication2(authctxt);

	/*
	 * If we use privilege separation, the unprivileged child transfers
	 * the current keystate and exits
	 */
	if (use_privsep) {
		mm_send_keystate(pmonitor);
		packet_clear_keys();
		exit(0);
	}

 authenticated:
	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);
	signal(SIGALRM, SIG_DFL);
	authctxt->authenticated = 1;
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}

	/*
	 * In privilege separation, we fork another child and prepare
	 * file descriptor passing.
	 */
	if (use_privsep) {
		privsep_postauth(authctxt);
		/* the monitor process [priv] will not return */
	}

	packet_set_timeout(options.client_alive_interval,
	    options.client_alive_count_max);

	/* Try to send all our hostkeys to the client */
	notify_hostkeys(ssh);

	/* Start session. */
	do_authenticated(ssh, authctxt);

	/* The connection has been terminated. */
	packet_get_bytes(&ibytes, &obytes);
	verbose("Transferred: sent %llu, received %llu bytes",
	    (unsigned long long)obytes, (unsigned long long)ibytes);

	verbose("Closing connection to %.500s port %d", remote_ip, remote_port);
	packet_close();

	if (use_privsep)
		mm_terminate();

	exit(0);
}

int
sshd_hostkey_sign(struct sshkey *privkey, struct sshkey *pubkey,
    u_char **signature, size_t *slen, const u_char *data, size_t dlen,
    const char *alg, u_int flag)
{
	int r;
	u_int xxx_slen, xxx_dlen = dlen;

	if (privkey) {
		if (PRIVSEP(key_sign(privkey, signature, &xxx_slen, data, xxx_dlen,
		    alg) < 0))
			fatal("%s: key_sign failed", __func__);
		if (slen)
			*slen = xxx_slen;
	} else if (use_privsep) {
		if (mm_key_sign(pubkey, signature, &xxx_slen, data, xxx_dlen,
		    alg) < 0)
			fatal("%s: pubkey_sign failed", __func__);
		if (slen)
			*slen = xxx_slen;
	} else {
		if ((r = ssh_agent_sign(auth_sock, pubkey, signature, slen,
		    data, dlen, alg, datafellows)) != 0)
			fatal("%s: ssh_agent_sign failed: %s",
			    __func__, ssh_err(r));
	}
	return 0;
}

/* SSH2 key exchange */
static void
do_ssh2_kex(void)
{
	char *myproposal[PROPOSAL_MAX] = { KEX_SERVER };
	struct kex *kex;
	int r;

	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(
	    options.kex_algorithms);
	myproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(
	    options.ciphers);
	myproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(
	    options.ciphers);
	myproposal[PROPOSAL_MAC_ALGS_CTOS] =
	    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;

	if (options.compression == COMP_NONE) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
		    myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
	}

	if (options.rekey_limit || options.rekey_interval)
		packet_set_rekey_limits(options.rekey_limit,
		    options.rekey_interval);

	myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(
	    list_hostkey_types());

	/* start key exchange */
	if ((r = kex_setup(active_state, myproposal)) != 0)
		fatal("kex_setup: %s", ssh_err(r));
	kex = active_state->kex;
#ifdef WITH_OPENSSL
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;
	kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;
	kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;
	kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
	kex->kex[KEX_ECDH_SHA2] = kexecdh_server;
#endif
	kex->kex[KEX_C25519_SHA256] = kexc25519_server;
	kex->server = 1;
	kex->client_version_string=client_version_string;
	kex->server_version_string=server_version_string;
	kex->load_host_public_key=&get_hostkey_public_by_type;
	kex->load_host_private_key=&get_hostkey_private_by_type;
	kex->host_key_index=&get_hostkey_index;
	kex->sign = sshd_hostkey_sign;

	ssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);

	session_id2 = kex->session_id;
	session_id2_len = kex->session_id_len;

#ifdef DEBUG_KEXDH
	/* send 1st encrypted/maced/compressed message */
	packet_start(SSH2_MSG_IGNORE);
	packet_put_cstring("markus");
	packet_send();
	packet_write_wait();
#endif
	debug("KEX done");
}

/* server specific fatal cleanup */
void
cleanup_exit(int i)
{
	struct ssh *ssh = active_state; /* XXX */

	if (the_authctxt) {
		do_cleanup(ssh, the_authctxt);
		if (use_privsep && privsep_is_preauth &&
		    pmonitor != NULL && pmonitor->m_pid > 1) {
			debug("Killing privsep child %d", pmonitor->m_pid);
			if (kill(pmonitor->m_pid, SIGKILL) != 0 &&
			    errno != ESRCH)
				error("%s: kill(%d): %s", __func__,
				    pmonitor->m_pid, strerror(errno));
		}
	}
	_exit(i);
}
@


1.491
log
@remove post-SSHv1 removal dead code from rsa.c and merge the
remaining bit that it still used into ssh-rsa.c; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.490 2017/05/31 08:09:45 markus Exp $ */
a1512 3
	/* set default channel AF */
	channel_set_af(options.address_family);

d1806 1
d1809 5
d1913 1
a1913 1
	notify_hostkeys(active_state);
d1916 1
a1916 1
	do_authenticated(authctxt);
d2032 2
d2035 1
a2035 1
		do_cleanup(the_authctxt);
@


1.490
log
@clear session keys from memory; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.489 2017/05/31 07:00:13 markus Exp $ */
a72 1
#include "rsa.h"
@


1.489
log
@remove now obsolete ctx from ssh_dispatch_run; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.488 2017/05/30 08:52:20 markus Exp $ */
d611 1
d1881 1
@


1.488
log
@switch from Key typedef with struct sshkey; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.487 2017/04/30 23:18:44 djm Exp $ */
d2009 1
a2009 1
	dispatch_run(DISPATCH_BLOCK, &kex->done, active_state);
@


1.487
log
@remove KEY_RSA1

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.486 2017/04/30 23:13:25 djm Exp $ */
d179 4
a182 4
	Key	**host_keys;		/* all private host keys */
	Key	**host_pubkeys;		/* all public host keys */
	Key	**host_certificates;	/* all public host certificates */
	int	have_ssh2_key;
d465 1
a465 1
	Key *tmp;
d646 1
a646 1
	Key *key;
d702 1
a702 1
static Key *
d706 1
a706 1
	Key *key;
d730 1
a730 1
Key *
d736 1
a736 1
Key *
d742 1
a742 1
Key *
d750 1
a750 1
Key *
d759 1
a759 1
get_hostkey_index(Key *key, int compare, struct ssh *ssh)
d1293 2
a1294 2
	Key *key;
	Key *pubkey;
d1532 1
a1532 1
	    sizeof(Key *));
d1534 1
a1534 1
	    sizeof(Key *));
d1598 1
a1598 1
	    sizeof(Key *));
d1929 3
a1931 2
sshd_hostkey_sign(Key *privkey, Key *pubkey, u_char **signature, size_t *slen,
    const u_char *data, size_t dlen, const char *alg, u_int flag)
@


1.486
log
@remove compat20/compat13/compat15 variables

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.485 2017/03/15 03:52:30 deraadt Exp $ */
a1552 8
		if ((pubkey != NULL && pubkey->type == KEY_RSA1) ||
		    (key != NULL && key->type == KEY_RSA1)) {
			verbose("Ignoring RSA1 key %s",
			    options.host_key_files[i]);
			key_free(key);
			key_free(pubkey);
			continue;
		}
@


1.485
log
@accidents happen to the best of us; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.484 2017/03/15 02:19:09 djm Exp $ */
d429 2
a430 4
	if (remote_major == 2 ||
	    (remote_major == 1 && remote_minor == 99)) {
		enable_compat20();
	} else {
@


1.484
log
@Fix segfault when sshd attempts to load RSA1 keys (can only happen
when protocol v.1 support is enabled for the client). Reported by
Jakub Jelen in bz#2686; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.483 2017/02/24 03:16:34 djm Exp $ */
d1558 1
a1558 1
			    options.host_key_files[i])
@


1.483
log
@might as well set the listener socket CLOEXEC
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.482 2017/02/06 09:22:51 djm Exp $ */
d1554 9
@


1.482
log
@Restore \r\n newline sequence for server ident string. The CR got
lost in the flensing of SSHv1. Pointed out by Stef Bon
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.481 2017/02/03 02:56:00 dtucker Exp $ */
d994 5
@


1.481
log
@Make ssh_packet_set_rekey_limits take u32 for the number of seconds
until rekeying (negative values are rejected at config parse time).
This allows the removal of some casts and a signed vs unsigned
comparison warning.

rekey_time is cast to int64 for the comparison which is a no-op
on OpenBSD, but should also do the right thing in -portable on
anything still using 32bit time_t (until the system time actually
wraps, anyway).

some early guidance deraadt@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.480 2016/12/09 03:04:29 djm Exp $ */
d342 1
a342 1
	char *s, *newline = "\n";
d346 1
a346 1
	xasprintf(&server_version_string, "SSH-%d.%d-%.100s%s%s%s",
d349 1
a349 1
	    options.version_addendum, newline);
@


1.480
log
@log connections dropped in excess of MaxStartups at verbose LogLevel;
bz#2613 based on diff from Tomas Kuthan; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.479 2016/12/04 22:27:25 dtucker Exp $ */
d1976 1
a1976 1
		    (time_t)options.rekey_interval);
@


1.479
log
@Unlink PidFile on SIGHUP and always recreate it when the new sshd starts.
Regression tests (and possibly other things) depend on the pidfile being
recreated after SIGHUP, and unlinking it means it won't contain a stale
pid if sshd fails to restart.  ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.478 2016/11/30 00:28:31 dtucker Exp $ */
d1120 9
a1128 1
				debug("drop connection #%d", startups);
@


1.478
log
@On startup, check to see if sshd is already daemonized and if so,
skip the call to daemon() and do not rewrite the PidFile.  This
means that when sshd re-execs itself on SIGHUP the process ID will
no longer change.  Should address bz#2641.  ok djm@@ markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.477 2016/11/29 03:54:50 dtucker Exp $ */
d271 2
d1707 1
a1707 1
		if (options.pid_file != NULL && !debug_flag && !already_daemon) {
@


1.477
log
@Factor out code to disconnect from controlling terminal into its own
function.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.476 2016/09/28 16:33:07 djm Exp $ */
d1271 1
a1271 1
	int r, opt, i, j, on = 1;
d1667 3
a1669 3
	 * If not in debugging mode, and not started from inetd, disconnect
	 * from the controlling terminal, and fork.  The original process
	 * exits.
d1671 2
a1672 1
	if (!(debug_flag || inetd_flag || no_daemon_flag)) {
d1705 1
a1705 1
		if (options.pid_file != NULL && !debug_flag) {
@


1.476
log
@Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@@ markus@@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.475 2016/08/28 22:28:12 djm Exp $ */
a107 4
#ifndef O_NOCTTY
#define O_NOCTTY	0
#endif

a1671 1
		int fd;
d1676 1
a1676 6
		/* Disconnect from the controlling tty. */
		fd = open(_PATH_TTY, O_RDWR | O_NOCTTY);
		if (fd >= 0) {
			(void) ioctl(fd, TIOCNOTTY, NULL);
			close(fd);
		}
@


1.475
log
@fix uninitialised optlen in getsockopt() call; harmless on Unix/BSD
but potentially crashy on Cygwin. Reported by James Slepicka
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.474 2016/08/19 03:18:07 djm Exp $ */
a98 1
#include "monitor_mm.h"
a560 3
		/* Sync memory */
		monitor_sync(pmonitor);

a1970 4
	} else if (options.compression == COMP_DELAYED) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
		    myproposal[PROPOSAL_COMP_ALGS_STOC] =
		    "none,zlib@@openssh.com";
@


1.474
log
@remove UseLogin option and support for having /bin/login manage
login sessions; ok deraadt markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.473 2016/08/15 12:27:56 naddy Exp $ */
a1245 1
	socklen_t option_size, i, fromlen = sizeof(from);
d1247 1
@


1.473
log
@Remove more SSH1 server code:
* Drop sshd's -k option.
* Retire configuration keywords that only apply to protocol 1, as well as
  the "protocol" keyword.
* Remove some related vestiges of protocol 1 support.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.472 2016/08/13 17:47:41 markus Exp $ */
d604 1
a604 1
	if (authctxt->pw->pw_uid == 0 || options.use_login) {
@


1.472
log
@remove ssh1 server code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.471 2016/08/03 04:23:55 dtucker Exp $ */
a344 1
	int major, minor;
a348 13
	if ((options.protocol & SSH_PROTO_1) &&
	    (options.protocol & SSH_PROTO_2)) {
		major = PROTOCOL_MAJOR_1;
		minor = 99;
	} else if (options.protocol & SSH_PROTO_2) {
		major = PROTOCOL_MAJOR_2;
		minor = PROTOCOL_MINOR_2;
		newline = "\r\n";
	} else {
		major = PROTOCOL_MAJOR_1;
		minor = PROTOCOL_MINOR_1;
	}

d350 1
a350 1
	    major, minor, SSH_VERSION,
d876 1
a876 1
"usage: sshd [-46DdeiqTt] [-b bits] [-C connection_spec] [-c host_cert_file]\n"
d878 1
a878 2
"            [-h host_key_file] [-k key_gen_time] [-o option] [-p port]\n"
"            [-u len]\n"
d1359 1
a1359 1
			/* ignored */
d1380 1
a1380 4
			if ((options.key_regeneration_time = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid key regeneration interval.\n");
				exit(1);
			}
a1497 3
		if ((options.protocol & SSH_PROTO_1))
			fatal("AuthenticationMethods is not supported with "
			    "SSH protocol 1");
@


1.471
log
@Fix bug introduced in rev 1.467 which causes "buffer_get_bignum_ret:
incomplete message" errors when built with WITH_SSH1 and run such that no
Protocol 1 ephemeral host key is generated (eg "Protocol 2", no SSH1 host
key supplied).  Reported by rainer.laatsch at t-online.de, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.470 2016/05/24 04:43:45 dtucker Exp $ */
a71 1
#include "ssh1.h"
a183 2
	Key	*server_key;		/* ephemeral server key */
	Key	*ssh1_host_key;		/* ssh1 host key */
a186 1
	int	have_ssh1_key;
a187 1
	u_char	ssh1_cookie[SSH_SESSION_KEY_LENGTH];
a189 6
/*
 * Flag indicating whether the RSA server key needs to be regenerated.
 * Is set in the SIGALRM handler and cleared when the key is regenerated.
 */
static volatile sig_atomic_t key_do_regen = 0;

a224 4

#ifdef WITH_SSH1
static void do_ssh1_kex(void);
#endif
a339 32
/*
 * Signal handler for the key regeneration alarm.  Note that this
 * alarm only occurs in the daemon waiting for connections, and it does not
 * do anything with the private key or random state before forking.
 * Thus there should be no concurrency control/asynchronous execution
 * problems.
 */
static void
generate_ephemeral_server_key(void)
{
	verbose("Generating %s%d bit RSA key.",
	    sensitive_data.server_key ? "new " : "", options.server_key_bits);
	if (sensitive_data.server_key != NULL)
		key_free(sensitive_data.server_key);
	sensitive_data.server_key = key_generate(KEY_RSA1,
	    options.server_key_bits);
	verbose("RSA key generation complete.");

	arc4random_buf(sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
}

/*ARGSUSED*/
static void
key_regeneration_alarm(int sig)
{
	int save_errno = errno;

	signal(SIGALRM, SIG_DFL);
	errno = save_errno;
	key_do_regen = 1;
}

a343 1
	int mismatch;
a442 32
	mismatch = 0;
	switch (remote_major) {
	case 1:
		if (remote_minor == 99) {
			if (options.protocol & SSH_PROTO_2)
				enable_compat20();
			else
				mismatch = 1;
			break;
		}
		if (!(options.protocol & SSH_PROTO_1)) {
			mismatch = 1;
			break;
		}
		if (remote_minor < 3) {
			packet_disconnect("Your ssh version is too old and "
			    "is no longer supported.  Please install a newer version.");
		} else if (remote_minor == 3) {
			/* note that this disables agent-forwarding */
			enable_compat13();
		}
		break;
	case 2:
		if (options.protocol & SSH_PROTO_2) {
			enable_compat20();
			break;
		}
		/* FALLTHROUGH */
	default:
		mismatch = 1;
		break;
	}
d446 4
a449 1
	if (mismatch) {
a467 4
	if (sensitive_data.server_key) {
		key_free(sensitive_data.server_key);
		sensitive_data.server_key = NULL;
	}
a477 2
	sensitive_data.ssh1_host_key = NULL;
	explicit_bzero(sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
a486 6
	if (sensitive_data.server_key) {
		tmp = key_demote(sensitive_data.server_key);
		key_free(sensitive_data.server_key);
		sensitive_data.server_key = tmp;
	}

a491 2
			if (tmp->type == KEY_RSA1)
				sensitive_data.ssh1_host_key = tmp;
a494 2

	/* We do not clear ssh1_host key and cookie.  XXX - Okay Niels? */
d675 1
a675 1
		if (key == NULL || key->type == KEY_RSA1)
d824 1
a824 1
		    key->type == KEY_RSA1 || sshkey_is_cert(key))
a909 7
	 *	u_int	ephemeral_key_follows
	 *	bignum	e		(only if ephemeral_key_follows == 1)
	 *	bignum	n			"
	 *	bignum	d			"
	 *	bignum	iqmp			"
	 *	bignum	p			"
	 *	bignum	q			"
a914 23

#ifdef WITH_SSH1
	if (sensitive_data.server_key != NULL &&
	    sensitive_data.server_key->type == KEY_RSA1) {
		if ((r = sshbuf_put_u32(m, 1)) != 0 ||
		    (r = sshbuf_put_bignum1(m,
		    sensitive_data.server_key->rsa->e)) != 0 ||
		    (r = sshbuf_put_bignum1(m,
		    sensitive_data.server_key->rsa->n)) != 0 ||
		    (r = sshbuf_put_bignum1(m,
		    sensitive_data.server_key->rsa->d)) != 0 ||
		    (r = sshbuf_put_bignum1(m,
		    sensitive_data.server_key->rsa->iqmp)) != 0 ||
		    (r = sshbuf_put_bignum1(m,
		    sensitive_data.server_key->rsa->p)) != 0 ||
		    (r = sshbuf_put_bignum1(m,
		    sensitive_data.server_key->rsa->q)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
	} else
#endif
		if ((r = sshbuf_put_u32(m, 0)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));

a943 17
	if (buffer_get_int(&m)) {
#ifdef WITH_SSH1
		if (sensitive_data.server_key != NULL)
			key_free(sensitive_data.server_key);
		sensitive_data.server_key = key_new_private(KEY_RSA1);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->e);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->n);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->d);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->iqmp);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->p);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->q);
		if (rsa_generate_additional_parameters(
		    sensitive_data.server_key->rsa) != 0)
			fatal("%s: rsa_generate_additional_parameters "
			    "error", __func__);
#endif
	}
d1059 1
a1059 1
	int key_used = 0, startups = 0;
a1104 5
		if (key_used && key_do_regen) {
			generate_ephemeral_server_key();
			key_used = 0;
			key_do_regen = 0;
		}
a1235 13

			/*
			 * Mark that the key has been used (it
			 * was "given" to the child).
			 */
			if ((options.protocol & SSH_PROTO_1) &&
			    key_used == 0) {
				/* Schedule server key regeneration alarm. */
				signal(SIGALRM, key_regeneration_alarm);
				alarm(options.key_regeneration_time);
				key_used = 1;
			}

d1374 1
a1374 2
			options.server_key_bits = (int)strtonum(optarg, 256,
			    32768, NULL);
a1465 3
	sensitive_data.server_key = NULL;
	sensitive_data.ssh1_host_key = NULL;
	sensitive_data.have_ssh1_key = 0;
d1573 1
a1573 2
		if (key == NULL && pubkey != NULL && pubkey->type != KEY_RSA1 &&
		    have_agent) {
a1587 4
		case KEY_RSA1:
			sensitive_data.ssh1_host_key = key;
			sensitive_data.have_ssh1_key = 1;
			break;
d1600 1
a1600 2
		    key ? "private" : "agent", i, keytype == KEY_RSA1 ?
		    sshkey_type(pubkey) : sshkey_ssh_name(pubkey), fp);
d1603 1
a1603 9
	if ((options.protocol & SSH_PROTO_1) && !sensitive_data.have_ssh1_key) {
		logit("Disabling protocol version 1. Could not load host key");
		options.protocol &= ~SSH_PROTO_1;
	}
	if ((options.protocol & SSH_PROTO_2) && !sensitive_data.have_ssh2_key) {
		logit("Disabling protocol version 2. Could not load host key");
		options.protocol &= ~SSH_PROTO_2;
	}
	if (!(options.protocol & (SSH_PROTO_1|SSH_PROTO_2))) {
a1650 27
#ifdef WITH_SSH1
	/* Check certain values for sanity. */
	if (options.protocol & SSH_PROTO_1) {
		if (options.server_key_bits < SSH_RSA_MINIMUM_MODULUS_SIZE ||
		    options.server_key_bits > OPENSSL_RSA_MAX_MODULUS_BITS) {
			fprintf(stderr, "Bad server key size.\n");
			exit(1);
		}
		/*
		 * Check that server and host key lengths differ sufficiently. This
		 * is necessary to make double encryption work with rsaref. Oh, I
		 * hate software patents. I dont know if this can go? Niels
		 */
		if (options.server_key_bits >
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) -
		    SSH_KEY_BITS_RESERVED && options.server_key_bits <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
			options.server_key_bits =
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
			    SSH_KEY_BITS_RESERVED;
			debug("Forcing server key to %d bits to make it differ from host key.",
			    options.server_key_bits);
		}
	}
#endif

a1729 3
		if (options.protocol & SSH_PROTO_1)
			generate_ephemeral_server_key();

a1866 5

	/* In inetd mode, generate ephemeral key only for proto 1 connections */
	if (!compat20 && inetd_flag && sensitive_data.server_key == NULL)
		generate_ephemeral_server_key();

d1882 1
a1882 1
	} else if (compat20 && have_agent) {
d1891 3
a1893 11
	if (compat20) {
		do_ssh2_kex();
		do_authentication2(authctxt);
	} else {
#ifdef WITH_SSH1
		do_ssh1_kex();
		do_authentication(authctxt);
#else
		fatal("ssh1 not supported");
#endif
	}
a1922 2
		if (!compat20)
			destroy_sensitive_data();
d1929 1
a1929 2
	if (compat20)
		notify_hostkeys(active_state);
a1946 223

#ifdef WITH_SSH1
/*
 * Decrypt session_key_int using our private server key and private host key
 * (key with larger modulus first).
 */
int
ssh1_session_key(BIGNUM *session_key_int)
{
	struct ssh *ssh = active_state; /* XXX */
	int rsafail = 0;

	if (BN_cmp(sensitive_data.server_key->rsa->n,
	    sensitive_data.ssh1_host_key->rsa->n) > 0) {
		/* Server key has bigger modulus. */
		if (BN_num_bits(sensitive_data.server_key->rsa->n) <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s port %d: "
			    "server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
			    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) != 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) != 0)
			rsafail++;
	} else {
		/* Host key has bigger modulus (or they are equal). */
		if (BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) <
		    BN_num_bits(sensitive_data.server_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s port %d: "
			    "host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
			    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) != 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) != 0)
			rsafail++;
	}
	return (rsafail);
}

/*
 * SSH1 key exchange
 */
static void
do_ssh1_kex(void)
{
	struct ssh *ssh = active_state; /* XXX */
	int i, len;
	int rsafail = 0;
	BIGNUM *session_key_int, *fake_key_int, *real_key_int;
	u_char session_key[SSH_SESSION_KEY_LENGTH];
	u_char fake_key_bytes[4096 / 8];
	size_t fake_key_len;
	u_char cookie[8];
	u_int cipher_type, auth_mask, protocol_flags;

	/*
	 * Generate check bytes that the client must send back in the user
	 * packet in order for it to be accepted; this is used to defy ip
	 * spoofing attacks.  Note that this only works against somebody
	 * doing IP spoofing from a remote machine; any machine on the local
	 * network can still see outgoing packets and catch the random
	 * cookie.  This only affects rhosts authentication, and this is one
	 * of the reasons why it is inherently insecure.
	 */
	arc4random_buf(cookie, sizeof(cookie));

	/*
	 * Send our public key.  We include in the packet 64 bits of random
	 * data that must be matched in the reply in order to prevent IP
	 * spoofing.
	 */
	packet_start(SSH_SMSG_PUBLIC_KEY);
	for (i = 0; i < 8; i++)
		packet_put_char(cookie[i]);

	/* Store our public server RSA key. */
	packet_put_int(BN_num_bits(sensitive_data.server_key->rsa->n));
	packet_put_bignum(sensitive_data.server_key->rsa->e);
	packet_put_bignum(sensitive_data.server_key->rsa->n);

	/* Store our public host RSA key. */
	packet_put_int(BN_num_bits(sensitive_data.ssh1_host_key->rsa->n));
	packet_put_bignum(sensitive_data.ssh1_host_key->rsa->e);
	packet_put_bignum(sensitive_data.ssh1_host_key->rsa->n);

	/* Put protocol flags. */
	packet_put_int(SSH_PROTOFLAG_HOST_IN_FWD_OPEN);

	/* Declare which ciphers we support. */
	packet_put_int(cipher_mask_ssh1(0));

	/* Declare supported authentication types. */
	auth_mask = 0;
	if (options.rhosts_rsa_authentication)
		auth_mask |= 1 << SSH_AUTH_RHOSTS_RSA;
	if (options.rsa_authentication)
		auth_mask |= 1 << SSH_AUTH_RSA;
	if (options.challenge_response_authentication == 1)
		auth_mask |= 1 << SSH_AUTH_TIS;
	if (options.password_authentication)
		auth_mask |= 1 << SSH_AUTH_PASSWORD;
	packet_put_int(auth_mask);

	/* Send the packet and wait for it to be sent. */
	packet_send();
	packet_write_wait();

	debug("Sent %d bit server key and %d bit host key.",
	    BN_num_bits(sensitive_data.server_key->rsa->n),
	    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n));

	/* Read clients reply (cipher type and session key). */
	packet_read_expect(SSH_CMSG_SESSION_KEY);

	/* Get cipher type and check whether we accept this. */
	cipher_type = packet_get_char();

	if (!(cipher_mask_ssh1(0) & (1 << cipher_type)))
		packet_disconnect("Warning: client selects unsupported cipher.");

	/* Get check bytes from the packet.  These must match those we
	   sent earlier with the public key packet. */
	for (i = 0; i < 8; i++)
		if (cookie[i] != packet_get_char())
			packet_disconnect("IP Spoofing check bytes do not match.");

	debug("Encryption type: %.200s", cipher_name(cipher_type));

	/* Get the encrypted integer. */
	if ((real_key_int = BN_new()) == NULL)
		fatal("do_ssh1_kex: BN_new failed");
	packet_get_bignum(real_key_int);

	protocol_flags = packet_get_int();
	packet_set_protocol_flags(protocol_flags);
	packet_check_eom();

	/* Setup a fake key in case RSA decryption fails */
	if ((fake_key_int = BN_new()) == NULL)
		fatal("do_ssh1_kex: BN_new failed");
	fake_key_len = BN_num_bytes(real_key_int);
	if (fake_key_len > sizeof(fake_key_bytes))
		fake_key_len = sizeof(fake_key_bytes);
	arc4random_buf(fake_key_bytes, fake_key_len);
	if (BN_bin2bn(fake_key_bytes, fake_key_len, fake_key_int) == NULL)
		fatal("do_ssh1_kex: BN_bin2bn failed");

	/* Decrypt real_key_int using host/server keys */
	rsafail = PRIVSEP(ssh1_session_key(real_key_int));
	/* If decryption failed, use the fake key. Else, the real key. */
	if (rsafail)
		session_key_int = fake_key_int;
	else
		session_key_int = real_key_int;

	/*
	 * Extract session key from the decrypted integer.  The key is in the
	 * least significant 256 bits of the integer; the first byte of the
	 * key is in the highest bits.
	 */
	(void) BN_mask_bits(session_key_int, sizeof(session_key) * 8);
	len = BN_num_bytes(session_key_int);
	if (len < 0 || (u_int)len > sizeof(session_key)) {
		error("%s: bad session key len from %s port %d: "
		    "session_key_int %d > sizeof(session_key) %lu", __func__,
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
		    len, (u_long)sizeof(session_key));
		rsafail++;
	} else {
		explicit_bzero(session_key, sizeof(session_key));
		BN_bn2bin(session_key_int,
		    session_key + sizeof(session_key) - len);

		derive_ssh1_session_id(
		    sensitive_data.ssh1_host_key->rsa->n,
		    sensitive_data.server_key->rsa->n,
		    cookie, session_id);
		/*
		 * Xor the first 16 bytes of the session key with the
		 * session id.
		 */
		for (i = 0; i < 16; i++)
			session_key[i] ^= session_id[i];
	}

	/* Destroy the private and public keys. No longer. */
	destroy_sensitive_data();

	if (use_privsep)
		mm_ssh1_session_id(session_id);

	/* Destroy the decrypted integer.  It is no longer needed. */
	BN_clear_free(real_key_int);
	BN_clear_free(fake_key_int);

	/* Set the session key.  From this on all communications will be encrypted. */
	packet_set_encryption_key(session_key, SSH_SESSION_KEY_LENGTH, cipher_type);

	/* Destroy our copy of the session key.  It is no longer needed. */
	explicit_bzero(session_key, sizeof(session_key));

	debug("Received session key; encryption turned on.");

	/* Send an acknowledgment packet.  Note that this packet is sent encrypted. */
	packet_start(SSH_SMSG_SUCCESS);
	packet_send();
	packet_write_wait();
}
#endif
@


1.470
log
@KNF compression proposal and simplify the client side a little.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.469 2016/05/02 14:10:58 djm Exp $ */
d1035 1
a1035 1
		if ((r = sshbuf_put_u32(m, 1)) != 0)
@


1.469
log
@unbreak config parsing on reexec from previous commit
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.468 2016/05/02 10:26:04 djm Exp $ */
d2440 1
a2440 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
d2443 2
a2444 1
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib@@openssh.com";
@


1.468
log
@add support for additional fixed DH groups from
draft-ietf-curdle-ssh-kex-sha2-03

diffie-hellman-group14-sha256 (2K group)
diffie-hellman-group16-sha512 (4K group)
diffie-hellman-group18-sha512 (8K group)

based on patch from Mark D. Baushke and Darren Tucker
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.467 2016/05/02 08:49:03 djm Exp $ */
d1064 1
a1064 1
		buffer_append(conf, cp, len + 1);
@


1.467
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.466 2016/03/07 19:02:43 djm Exp $ */
d2460 3
@


1.466
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.465 2016/02/15 09:47:49 dtucker Exp $ */
d810 2
a811 2
	buffer_append(&b, "\0", 1);
	ret = xstrdup(buffer_ptr(&b));
d992 1
a992 1
send_rexec_state(int fd, Buffer *conf)
d994 2
a995 1
	Buffer m;
d997 2
a998 2
	debug3("%s: entering fd = %d config len %d", __func__, fd,
	    buffer_len(conf));
d1011 4
a1014 2
	buffer_init(&m);
	buffer_put_cstring(&m, buffer_ptr(conf));
d1019 14
a1032 7
		buffer_put_int(&m, 1);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->e);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->n);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->d);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->iqmp);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->p);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->q);
d1035 2
a1036 1
		buffer_put_int(&m, 0);
d1038 1
a1038 1
	if (ssh_msg_send(fd, 0, &m) == -1)
d1041 1
a1041 1
	buffer_free(&m);
@


1.465
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.464 2016/01/29 02:54:45 dtucker Exp $ */
d351 2
a352 1
	sigdie("Timeout before authentication for %s", get_remote_ipaddr());
d388 1
a388 1
sshd_exchange_identification(int sock_in, int sock_out)
d420 2
a421 1
		logit("Could not write ident string to %s", get_remote_ipaddr());
d429 3
a431 2
			logit("Did not receive identification string from %s",
			    get_remote_ipaddr());
d460 1
a460 1
		    get_remote_ipaddr(), get_remote_port());
d468 1
a468 1
	active_state->compat = compat_datafellows(remote_version);
d470 4
a473 3
	if ((datafellows & SSH_BUG_PROBE) != 0) {
		logit("probed from %s with %s.  Don't panic.",
		    get_remote_ipaddr(), client_version_string);
d476 4
a479 3
	if ((datafellows & SSH_BUG_SCANNER) != 0) {
		logit("scanned from %s with %s.  Don't panic.",
		    get_remote_ipaddr(), client_version_string);
d482 1
a482 1
	if ((datafellows & SSH_BUG_RSASIGMD5) != 0) {
d486 1
a486 1
	if ((datafellows & SSH_BUG_DERIVEKEY) != 0) {
d531 3
a533 2
		logit("Protocol major versions differ for %s: %.200s vs. %.200s",
		    get_remote_ipaddr(),
d1392 39
d1438 1
d2023 2
d2031 2
a2032 2
	if ((remote_port = get_remote_port()) < 0) {
		debug("get_remote_port failed");
a2036 5
	 * We use get_canonical_hostname with usedns = 0 instead of
	 * get_remote_ipaddr here so IP options will be checked.
	 */
	(void) get_canonical_hostname(0);
	/*
d2038 1
a2038 1
	 * get_remote_ipaddr() caches the remote ip, even if
d2041 1
a2041 1
	remote_ip = get_remote_ipaddr();
d2046 1
a2046 1
	    remote_ip, remote_port, laddr,  get_local_port());
d2061 1
a2061 1
	sshd_exchange_identification(sock_in, sock_out);
d2167 1
d2176 1
a2176 1
			fatal("do_connection: %s: "
d2178 1
a2178 1
			    get_remote_ipaddr(),
d2194 1
a2194 1
			fatal("do_connection: %s: "
d2196 1
a2196 1
			    get_remote_ipaddr(),
d2217 1
d2335 4
a2338 3
		error("do_ssh1_kex: bad session key len from %s: "
		    "session_key_int %d > sizeof(session_key) %lu",
		    get_remote_ipaddr(), len, (u_long)sizeof(session_key));
@


1.464
log
@Allow RekeyLimits in excess of 4G up to 2**63 bits (limited by the return
type of scan_scaled).  Part of bz#2521, ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.463 2016/01/14 16:17:40 markus Exp $ */
d1410 1
@


1.463
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.462 2015/12/10 17:08:40 mmcc Exp $ */
d2389 1
a2389 1
		packet_set_rekey_limits((u_int32_t)options.rekey_limit,
@


1.462
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.461 2015/12/04 16:41:28 markus Exp $ */
a105 1
#include "roaming.h"
d416 1
a416 1
	if (roaming_atomicio(vwrite, sock_out, server_version_string,
d426 1
a426 1
		if (roaming_atomicio(read, sock_in, &buf[i], 1) != 1) {
@


1.461
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.460 2015/11/16 22:51:05 djm Exp $ */
d1207 1
a1207 2
		if (fdset != NULL)
			free(fdset);
@


1.460
log
@always call privsep_preauth_child() regardless of whether sshd
was started by root; it does important priming before sandboxing
and failing to call it could result in sandbox violations later;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.459 2015/09/04 08:21:47 dtucker Exp $ */
d781 6
d2339 1
a2339 1
    const u_char *data, size_t dlen, u_int flag)
d2345 2
a2346 1
		if (PRIVSEP(key_sign(privkey, signature, &xxx_slen, data, xxx_dlen) < 0))
d2351 2
a2352 1
		if (mm_key_sign(pubkey, signature, &xxx_slen, data, xxx_dlen) < 0)
d2358 1
a2358 1
		    data, dlen, datafellows)) != 0)
@


1.459
log
@Plug minor memory leaks when options are used more than once.  bz#2182,
patch from Tiago Cunha, ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.458 2015/08/20 22:32:42 deraadt Exp $ */
d603 26
a628 25
	if ((pw = getpwnam(SSH_PRIVSEP_USER)) == NULL)
		fatal("Privilege separation user %s does not exist",
		    SSH_PRIVSEP_USER);
	explicit_bzero(pw->pw_passwd, strlen(pw->pw_passwd));
	endpwent();

	/* Change our root directory */
	if (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)
		fatal("chroot(\"%s\"): %s", _PATH_PRIVSEP_CHROOT_DIR,
		    strerror(errno));
	if (chdir("/") == -1)
		fatal("chdir(\"/\"): %s", strerror(errno));

	/* Drop our privileges */
	debug3("privsep user:group %u:%u", (u_int)pw->pw_uid,
	    (u_int)pw->pw_gid);
#if 0
	/* XXX not ready, too heavy after chroot */
	do_setusercontext(pw);
#else
	gidset[0] = pw->pw_gid;
	if (setgroups(1, gidset) < 0)
		fatal("setgroups: %.100s", strerror(errno));
	permanently_set_uid(pw);
#endif
d694 1
a694 3
		/* Demote the child */
		if (getuid() == 0 || geteuid() == 0)
			privsep_preauth_child();
@


1.458
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.457 2015/07/30 00:01:34 djm Exp $ */
d1449 1
a1449 1
			logfile = xstrdup(optarg);
d1551 1
a1551 1
	if (logfile != NULL) {
a1552 2
		free(logfile);
	}
@


1.457
log
@Allow ssh_config and sshd_config kex parameters options be prefixed
by a '+' to indicate that the specified items be appended to the
default rather than replacing it.

approach suggested by dtucker@@, feedback dlg@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.456 2015/07/17 02:47:45 djm Exp $ */
d1204 1
a1204 1
		fdset = (fd_set *)xcalloc(howmany(maxfd + 1, NFDBITS),
@


1.456
log
@fix incorrect test for SSH1 keys when compiled without SSH1 support
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.455 2015/07/15 08:00:11 djm Exp $ */
d2368 9
a2376 13
	if (options.ciphers != NULL) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
	}
	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
	myproposal[PROPOSAL_ENC_ALGS_STOC] =
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_STOC]);

	if (options.macs != NULL) {
		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
	}
a2383 5
	if (options.kex_algorithms != NULL)
		myproposal[PROPOSAL_KEX_ALGS] = options.kex_algorithms;

	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(
	    myproposal[PROPOSAL_KEX_ALGS]);
@


1.455
log
@fix NULL-deref when SSH1 reenabled
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.454 2015/07/10 06:21:53 markus Exp $ */
d764 1
a764 1
		if (key == NULL && key->type != KEY_RSA1)
@


1.454
log
@Turn off DSA by default; add HostKeyAlgorithms to the server and
PubkeyAcceptedKeyTypes to the client side, so it still can be
tested or turned back on; feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.453 2015/07/03 03:49:45 djm Exp $ */
d764 1
a764 1
		if (key == NULL)
@


1.453
log
@refuse to generate or accept RSA keys smaller than 1024 bits;
feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.452 2015/07/03 03:47:00 djm Exp $ */
d80 1
d766 7
@


1.452
log
@turn off 1024 bit diffie-hellman-group1-sha1 key exchange method
(already off in server, this turns it off in the client by default too)
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.451 2015/07/03 03:43:18 djm Exp $ */
d1763 2
a1764 2
		if (options.server_key_bits < 512 ||
		    options.server_key_bits > 32768) {
@


1.451
log
@delete support for legacy v00 certificates; "sure" markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.450 2015/05/24 23:39:16 djm Exp $ */
d2352 1
a2352 3
/*
 * SSH2 key exchange: diffie-hellman-group1-sha1
 */
@


1.450
log
@add missing 'c' option to getopt(), case statement was already
there; from Felix Bolte
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.449 2015/05/21 06:43:31 djm Exp $ */
a780 2
		case KEY_RSA_CERT_V00:
		case KEY_DSA_CERT_V00:
a806 2
		case KEY_RSA_CERT_V00:
		case KEY_DSA_CERT_V00:
@


1.449
log
@add AuthorizedPrincipalsCommand that allows getting authorized_principals
from a subprocess rather than a file, which is quite useful in
deployments with large userbases

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.448 2015/04/27 00:21:21 djm Exp $ */
d1414 2
a1415 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:C:dDeE:iqrtQRT46")) != -1) {
@


1.448
log
@allow "sshd -f none" to skip reading the config file, much like
"ssh -F none" does. ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.447 2015/04/15 23:23:25 dtucker Exp $ */
d1601 5
@


1.447
log
@Plug leak of address passed to logging.  bz#2373, patch from jjelen at redhat,
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.446 2015/04/10 05:16:50 dtucker Exp $ */
d1582 1
a1582 1
	else
@


1.446
log
@Don't send hostkey advertisments (hostkeys-00@@openssh.com) to current
versions of Tera Term as they can't handle them.  Newer versions should
be OK.  Patch from Bryan Drewery and IWAMOTO Kouichi, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.445 2015/03/31 22:55:24 djm Exp $ */
d1392 1
a1392 1
	char *fp, *line, *logfile = NULL;
d1989 1
d1991 2
a1992 2
	    remote_ip, remote_port,
	    get_local_ipaddr(sock_in), get_local_port());
@


1.445
log
@don't fatal when a !ssh1 sshd is reexeced from a w/ssh1 listener;
reported by miod@@; ok miod@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.444 2015/02/20 22:17:21 djm Exp $ */
d893 4
@


1.444
log
@UpdateHostKeys fixes:

I accidentally changed the format of the hostkeys@@openssh.com messages
last week without changing the extension name, and this has been causing
connection failures for people who are running -current. First reported
by sthen@@

s/hostkeys@@openssh.com/hostkeys-00@@openssh.com/
Change the name of the proof message too, and reorder it a little.

Also, UpdateHostKeys=ask is incompatible with ControlPersist (no TTY
available to read the response) so disable UpdateHostKeys if it is in
ask mode and ControlPersist is active (and document this)
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.443 2015/02/16 22:30:03 djm Exp $ */
a1052 2
#else
		fatal("ssh1 not supported");
@


1.443
log
@partial backout of:

revision 1.441
date: 2015/01/31 20:30:05;  author: djm;  state: Exp;  lines: +17 -10;  commitid
: x8klYPZMJSrVlt3O;
Let sshd load public host keys even when private keys are missing.
Allows sshd to advertise additional keys for future key rotation.
Also log fingerprint of hostkeys loaded; ok markus@@

hostkey updates now require access to the private key, so we can't
load public keys only. The improved log messages (fingerprints of keys
loaded) are kept.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.442 2015/02/16 22:13:32 djm Exp $ */
d908 1
a908 1
			packet_put_cstring("hostkeys@@openssh.com");
@


1.442
log
@Revise hostkeys@@openssh.com hostkey learning extension.

The client will not ask the server to prove ownership of the private
halves of any hitherto-unseen hostkeys it offers to the client.

Allow UpdateHostKeys option to take an 'ask' argument to let the
user manually review keys offered.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.441 2015/01/31 20:30:05 djm Exp $ */
d761 1
a761 1
		if (key == NULL && have_agent)
d1664 4
a1667 5
		if (key == NULL && pubkey != NULL && pubkey->type != KEY_RSA1) {
			if (have_agent) {
				debug("will rely on agent for hostkey %s",
				    options.host_key_files[i]);
			}
d1696 1
a1696 1
		    key ? "private" : "public", i, keytype == KEY_RSA1 ?
@


1.441
log
@Let sshd load public host keys even when private keys are missing.
Allows sshd to advertise additional keys for future key rotation.
Also log fingerprint of hostkeys loaded; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.440 2015/01/26 06:10:03 djm Exp $ */
d860 1
a860 1
get_hostkey_index(Key *key, struct ssh *ssh)
d866 4
a869 1
			if (key == sensitive_data.host_certificates[i])
d872 3
a874 1
			if (key == sensitive_data.host_keys[i])
d876 3
a878 1
			if (key == sensitive_data.host_pubkeys[i])
d906 7
a912 1
		if ((r = sshkey_puts(key, buf)) != 0)
d915 1
d918 1
a920 5
	debug3("%s: send %d hostkeys", __func__, nkeys);
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("hostkeys@@openssh.com");
	packet_put_char(0); /* want-reply */
	packet_put_string(sshbuf_ptr(buf), sshbuf_len(buf));
d922 1
d2324 1
a2324 1
    u_char *data, size_t dlen, u_int flag)
@


1.440
log
@correctly match ECDSA subtype (== curve) for offered/recevied
host keys. Fixes connection-killing host key mismatches when
a server offers multiple ECDSA keys with different curve type
(an extremely unlikely configuration).

ok markus, "looks mechanical" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.439 2015/01/26 03:04:46 djm Exp $ */
d761 1
a761 1
		if (key == NULL)
d1379 1
a1379 1
	char *line, *logfile = NULL;
d1653 5
a1657 4
		if (key == NULL && pubkey != NULL && pubkey->type != KEY_RSA1 &&
		    have_agent) {
			debug("will rely on agent for hostkey %s",
			    options.host_key_files[i]);
d1678 2
a1679 1
			sensitive_data.have_ssh2_key = 1;
d1682 7
a1688 2
		debug("private host key: #%d type %d %s", i, keytype,
		    key_type(key ? key : pubkey));
@


1.439
log
@Host key rotation support.

Add a hostkeys@@openssh.com protocol extension (global request) for
a server to inform a client of all its available host key after
authentication has completed. The client may record the keys in
known_hosts, allowing it to upgrade to better host key algorithms
and a server to gracefully rotate its keys.

The client side of this is controlled by a UpdateHostkeys config
option (default on).

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.438 2015/01/20 23:14:00 deraadt Exp $ */
d802 1
a802 1
get_hostkey_by_type(int type, int need_private, struct ssh *ssh)
d823 2
a824 1
		if (key != NULL && key->type == type)
d832 1
a832 1
get_hostkey_public_by_type(int type, struct ssh *ssh)
d834 1
a834 1
	return get_hostkey_by_type(type, 0, ssh);
d838 1
a838 1
get_hostkey_private_by_type(int type, struct ssh *ssh)
d840 1
a840 1
	return get_hostkey_by_type(type, 1, ssh);
@


1.438
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.437 2015/01/20 20:16:21 markus Exp $ */
d877 36
d1647 2
d2061 4
@


1.437
log
@kex_setup errors are fatal()
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.436 2015/01/19 20:20:20 markus Exp $ */
a45 1
#include <sys/param.h>
d64 1
d213 1
a213 1
u_int utmp_len = MAXHOSTNAMELEN;
d1463 2
a1464 2
			utmp_len = (u_int)strtonum(optarg, 0, MAXHOSTNAMELEN+1, NULL);
			if (utmp_len > MAXHOSTNAMELEN) {
@


1.436
log
@store compat flags in struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.435 2015/01/19 20:16:15 markus Exp $ */
d2295 1
d2331 2
a2332 1
	kex_setup(active_state, myproposal);
@


1.435
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.434 2015/01/19 19:52:16 markus Exp $ */
d465 1
a465 1
	compat_datafellows(remote_version);
@


1.434
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.433 2015/01/17 18:53:34 djm Exp $ */
d802 1
a802 1
get_hostkey_by_type(int type, int need_private)
d831 1
a831 1
get_hostkey_public_by_type(int type)
d833 1
a833 1
	return get_hostkey_by_type(type, 0);
d837 1
a837 1
get_hostkey_private_by_type(int type)
d839 1
a839 1
	return get_hostkey_by_type(type, 1);
d851 1
a851 1
get_hostkey_public_by_index(int ind)
d859 1
a859 1
get_hostkey_index(Key *key)
d2261 3
a2263 3
void
sshd_hostkey_sign(Key *privkey, Key *pubkey, u_char **signature, u_int *slen,
    u_char *data, u_int dlen)
d2266 1
d2269 1
a2269 1
		if (PRIVSEP(key_sign(privkey, signature, slen, data, dlen) < 0))
d2271 2
d2274 1
a2274 1
		if (mm_key_sign(pubkey, signature, slen, data, dlen) < 0)
d2276 2
d2279 1
a2279 3
		size_t xxx_slen;

		if ((r = ssh_agent_sign(auth_sock, pubkey, signature, &xxx_slen,
a2282 3
		/* XXX: Old API is u_int; new size_t */
		if (slen != NULL)
			*slen = xxx_slen;
d2284 1
d2294 1
a2294 1
	Kex *kex;
d2330 2
a2331 2
	kex = kex_setup(myproposal);
	active_state->kex = kex;
d2348 1
a2348 1
	dispatch_run(DISPATCH_BLOCK, &kex->done, kex);
@


1.433
log
@fix hostkeys on ssh agent; found by unit test I'm about to commit
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.432 2015/01/14 20:05:27 djm Exp $ */
a171 3
/* for rekeying XXX fixme */
Kex *xxx_kex;

d639 1
a639 1
	pmonitor->m_pkex = &xxx_kex;
d2028 1
a2028 2
	packet_get_state(MODE_IN, NULL, NULL, NULL, &ibytes);
	packet_get_state(MODE_OUT, NULL, NULL, NULL, &obytes);
d2330 1
a2345 2

	xxx_kex = kex;
@


1.432
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.431 2015/01/07 18:15:07 tedu Exp $ */
d1602 5
a1606 1
		have_agent = ssh_get_authentication_socket(NULL);
d1974 1
a1974 1
			have_agent = -1;
@


1.431
log
@workaround for the Meyer, et al, Bleichenbacher Side Channel Attack.
fake up a bignum key before RSA decryption.
discussed/ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.430 2014/12/22 07:55:51 djm Exp $ */
d108 1
d176 1
a176 1
AuthenticationConnection *auth_conn = NULL;
d635 1
a635 1
	int status;
d653 8
a660 2
		if (have_agent)
			auth_conn = ssh_get_authentication_connection();
d1341 1
a1341 1
	int opt, i, j, on = 1;
d1602 1
a1602 1
		have_agent = ssh_agent_present();
d1967 6
a1972 2
	} else if (compat20 && have_agent)
		auth_conn = ssh_get_authentication_connection();
d2265 2
d2274 9
a2282 3
		if (ssh_agent_sign(auth_conn, pubkey, signature, slen, data,
		    dlen))
			fatal("%s: ssh_agent_sign failed", __func__);
@


1.430
log
@make internal handling of filename arguments of "none" more consistent
with ssh. "none" arguments are now replaced with NULL when the
configuration is finalised.

Simplifies checking later on (just need to test not-NULL rather than
that + strcmp) and cleans up some inconsistencies. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.429 2014/12/11 08:20:09 djm Exp $ */
d2089 1
a2089 1
	BIGNUM *session_key_int;
d2091 2
d2170 1
a2170 1
	if ((session_key_int = BN_new()) == NULL)
d2172 1
a2172 1
	packet_get_bignum(session_key_int);
d2178 17
a2194 2
	/* Decrypt session_key_int using host/server keys */
	rsafail = PRIVSEP(ssh1_session_key(session_key_int));
d2201 20
a2220 49
	if (!rsafail) {
		(void) BN_mask_bits(session_key_int, sizeof(session_key) * 8);
		len = BN_num_bytes(session_key_int);
		if (len < 0 || (u_int)len > sizeof(session_key)) {
			error("do_ssh1_kex: bad session key len from %s: "
			    "session_key_int %d > sizeof(session_key) %lu",
			    get_remote_ipaddr(), len, (u_long)sizeof(session_key));
			rsafail++;
		} else {
			explicit_bzero(session_key, sizeof(session_key));
			BN_bn2bin(session_key_int,
			    session_key + sizeof(session_key) - len);

			derive_ssh1_session_id(
			    sensitive_data.ssh1_host_key->rsa->n,
			    sensitive_data.server_key->rsa->n,
			    cookie, session_id);
			/*
			 * Xor the first 16 bytes of the session key with the
			 * session id.
			 */
			for (i = 0; i < 16; i++)
				session_key[i] ^= session_id[i];
		}
	}
	if (rsafail) {
		int bytes = BN_num_bytes(session_key_int);
		u_char *buf = xmalloc(bytes);
		struct ssh_digest_ctx *md;

		logit("do_connection: generating a fake encryption key");
		BN_bn2bin(session_key_int, buf);
		if ((md = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||
		    ssh_digest_update(md, buf, bytes) < 0 ||
		    ssh_digest_update(md, sensitive_data.ssh1_cookie,
		    SSH_SESSION_KEY_LENGTH) < 0 ||
		    ssh_digest_final(md, session_key, sizeof(session_key)) < 0)
			fatal("%s: md5 failed", __func__);
		ssh_digest_free(md);
		if ((md = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||
		    ssh_digest_update(md, session_key, 16) < 0 ||
		    ssh_digest_update(md, sensitive_data.ssh1_cookie,
		    SSH_SESSION_KEY_LENGTH) < 0 ||
		    ssh_digest_final(md, session_key + 16,
		    sizeof(session_key) - 16) < 0)
			fatal("%s: md5 failed", __func__);
		ssh_digest_free(md);
		explicit_bzero(buf, bytes);
		free(buf);
d2222 1
a2222 1
			session_id[i] = session_key[i] ^ session_key[i + 16];
d2224 1
d2232 2
a2233 1
	BN_clear_free(session_key_int);
@


1.429
log
@explicitly include sys/param.h in files that use the howmany() macro;
from portable
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.428 2014/07/15 15:54:14 millert Exp $ */
d1163 2
a1164 1
			unlink(options.pid_file);
a1589 4
	for (i = 0; i < options.num_host_key_files; i++) {
		sensitive_data.host_keys[i] = NULL;
		sensitive_data.host_pubkeys[i] = NULL;
	}
d1599 2
d1659 2
d1810 1
a1810 1
		if (!debug_flag) {
@


1.428
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.427 2014/06/24 01:13:21 djm Exp $ */
d46 1
@


1.427
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.426 2014/04/29 18:01:49 markus Exp $ */
d78 1
a93 1
#include "misc.h"
@


1.426
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.425 2014/04/19 14:53:48 tedu Exp $ */
d996 4
a999 2
		rsa_generate_additional_parameters(
		    sensitive_data.server_key->rsa);
d2052 1
a2052 1
		    sensitive_data.server_key->rsa) <= 0)
d2055 1
a2055 1
		    sensitive_data.ssh1_host_key->rsa) <= 0)
d2070 1
a2070 1
		    sensitive_data.ssh1_host_key->rsa) < 0)
d2073 1
a2073 1
		    sensitive_data.server_key->rsa) < 0)
@


1.425
log
@Delete futile calls to RAND_seed. ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.424 2014/04/18 23:52:25 djm Exp $ */
d65 1
a65 1
#include <openssl/dh.h>
d67 1
a84 1
#include "dh.h"
d238 1
d240 1
a700 1

d904 7
a910 1
	    SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
d942 1
d953 1
d986 1
d998 3
d1483 1
d1485 1
d1574 6
a1579 1
	    SSLeay_version(SSLEAY_VERSION));
d1687 2
d1713 1
d1965 1
d1968 3
d2026 1
d2076 1
d2254 1
d2317 1
d2323 1
@


1.424
log
@OpenSSH 6.5 and 6.6 have a bug that causes ~0.2% of connections
using the curve25519-sha256@@libssh.org KEX exchange method to fail
when connecting with something that implements the spec properly.

Disable this KEX method when speaking to one of the affected
versions.

reported by Aris Adamantiadis; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.423 2014/04/12 04:55:53 djm Exp $ */
a66 1
#include <openssl/rand.h>
a585 1
	u_int32_t rnd[256];
a597 4
	arc4random_buf(rnd, sizeof(rnd));
	RAND_seed(rnd, sizeof(rnd));
	explicit_bzero(rnd, sizeof(rnd));

a698 1
	u_int32_t rnd[256];
a728 4
	arc4random_buf(rnd, sizeof(rnd));
	RAND_seed(rnd, sizeof(rnd));
	explicit_bzero(rnd, sizeof(rnd));

a1108 1
	u_char rnd[256];
a1299 8

			/*
			 * Ensure that our random state differs
			 * from that of the child
			 */
			arc4random_buf(rnd, sizeof(rnd));
			RAND_seed(rnd, sizeof(rnd));
			explicit_bzero(rnd, sizeof(rnd));
@


1.423
log
@avoid crash at exit: check that pmonitor!=NULL before dereferencing;
bz#2225, patch from kavi AT juniper.net
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.422 2014/03/27 23:01:27 markus Exp $ */
d2294 3
@


1.422
log
@disable weak proposals in sshd, but keep them in ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.421 2014/03/26 19:58:37 tedu Exp $ */
d2341 2
a2342 1
		if (use_privsep && privsep_is_preauth && pmonitor->m_pid > 1) {
@


1.421
log
@remove libwrap support. ok deraadt djm mfriedl
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.420 2014/02/26 21:53:37 markus Exp $ */
d2269 1
@


1.420
log
@ssh_gssapi_prepare_supported_oids needs GSSAPI
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.419 2014/02/26 20:28:44 djm Exp $ */
a108 7
#ifdef LIBWRAP
#include <tcpd.h>
#include <syslog.h>
int allow_severity = LOG_INFO;
int deny_severity = LOG_WARNING;
#endif /* LIBWRAP */

a1913 17

#ifdef LIBWRAP
	/* Check whether logins are denied from this host. */
	if (packet_connection_is_on_socket()) {
		struct request_info req;

		request_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, 0);
		fromhost(&req);

		if (!hosts_access(&req)) {
			debug("Connection refused by tcp wrapper");
			refuse(&req);
			/* NOTREACHED */
			fatal("libwrap refuse returns");
		}
	}
#endif /* LIBWRAP */
@


1.420.4.1
log
@MFC:

reliability fix for OpenSSH using curve25519-sha256@@libssh.org key
exchange method.

revision 1.71
date: 2014/04/18 23:52:25;  author: djm;  state: Exp;  lines: +2 -2;
OpenSSH 6.5 and 6.6 have a bug that causes ~0.2% of connections
using the curve25519-sha256@@libssh.org KEX exchange method to fail
when connecting with something that implements the spec properly.

Disable this KEX method when speaking to one of the affected
versions.

revision 1.57
date: 2014/04/16 23:22:45;  author: djm;  state: Exp;  lines: +4 -1;
skip leading zero bytes in buffer_put_bignum2_from_string();
reported by jan AT mojzis.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.420 2014/02/26 21:53:37 markus Exp $ */
a2316 3

	myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(
	    myproposal[PROPOSAL_KEX_ALGS]);
@


1.419
log
@bz#2107 - cache OIDs of supported GSSAPI mechanisms before privsep
sandboxing, as running this code in the sandbox can cause violations;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.418 2014/02/02 03:44:32 djm Exp $ */
d601 1
d605 1
@


1.418
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.417 2014/01/31 16:39:19 tedu Exp $ */
d600 4
@


1.417
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.416 2014/01/29 00:19:26 djm Exp $ */
d561 1
a561 1
	memset(sensitive_data.ssh1_cookie, 0, SSH_SESSION_KEY_LENGTH);
d611 1
a611 1
	memset(pw->pw_passwd, 0, strlen(pw->pw_passwd));
d2198 1
a2198 1
			memset(session_key, 0, sizeof(session_key));
d2236 1
a2236 1
		memset(buf, 0, bytes);
d2254 1
a2254 1
	memset(session_key, 0, sizeof(session_key));
@


1.416
log
@use kill(0, ...) instead of killpg(0, ...); on most operating systems
they are equivalent, but SUSv2 describes the latter as having undefined
behaviour; from portable; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.415 2014/01/27 19:18:54 markus Exp $ */
d603 1
a603 1
	bzero(rnd, sizeof(rnd));
d739 1
a739 1
	bzero(rnd, sizeof(rnd));
d1320 1
a1320 1
			bzero(rnd, sizeof(rnd));
@


1.415
log
@replace openssl MD5 with our ssh_digest_*; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.414 2014/01/09 23:26:48 djm Exp $ */
d354 1
a354 1
		killpg(0, SIGTERM);
@


1.414
log
@ban clients/servers that suffer from SSH_BUG_DERIVEKEY, they are ancient,
deranged and might make some attacks on KEX easier; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.413 2013/12/30 23:52:28 djm Exp $ */
a66 1
#include <openssl/md5.h>
d82 1
d2217 1
a2217 1
		MD5_CTX md;
d2221 15
a2235 9
		MD5_Init(&md);
		MD5_Update(&md, buf, bytes);
		MD5_Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
		MD5_Final(session_key, &md);
		MD5_Init(&md);
		MD5_Update(&md, session_key, 16);
		MD5_Update(&md, buf, bytes);
		MD5_Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
		MD5_Final(session_key + 16, &md);
@


1.413
log
@refuse RSA keys from old proprietary clients/servers that use the
obsolete RSA+MD5 signature scheme. it will still be possible to connect
with these clients/servers but only DSA keys will be accepted, and we'll
deprecate them entirely in a future release. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.412 2013/12/06 13:39:49 markus Exp $ */
d484 1
a484 1
	if ((datafellows & SSH_BUG_RSASIGMD5) != 0)
d487 5
@


1.412
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.411 2013/11/20 02:19:01 djm Exp $ */
d474 1
a474 1
	if (datafellows & SSH_BUG_PROBE) {
d479 1
a479 2

	if (datafellows & SSH_BUG_SCANNER) {
d484 3
d2305 2
a2306 1
	myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = list_hostkey_types();
@


1.411
log
@delay closure of in/out fds until after "Bad protocol version
identification..." message, as get_remote_ipaddr/get_remote_port
require them open.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.410 2013/11/02 21:59:15 markus Exp $ */
d768 1
d785 1
d813 1
d1621 1
@


1.410
log
@use curve25519 for default key exchange (curve25519-sha256@@libssh.org);
initial patch from Aris Adamantiadis; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.409 2013/10/23 23:35:32 djm Exp $ */
a461 2
		close(sock_in);
		close(sock_out);
d465 2
@


1.409
log
@include local address and port in "Connection from ..." message (only
shown at loglevel>=verbose)
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.408 2013/10/17 22:08:04 djm Exp $ */
d2308 1
@


1.408
log
@include remote port in bad banner message; bz#2162
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.407 2013/10/10 01:43:03 djm Exp $ */
d1923 3
a1925 1
	verbose("Connection from %.500s port %d", remote_ip, remote_port);
@


1.407
log
@bz#2139: fix re-exec fallback by ensuring that startup_pipe is correctly
updated; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.406 2013/09/02 22:00:34 deraadt Exp $ */
d464 3
a466 2
		logit("Bad protocol version identification '%.100s' from %s",
		    client_version_string, get_remote_ipaddr());
@


1.406
log
@All the instances of arc4random_stir() are bogus, since arc4random()
does this itself, inside itself, and has for a very long time..  Actually,
this was probably reducing the entropy available.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.405 2013/08/22 19:02:21 djm Exp $ */
d1829 1
a1829 1
		else
d1831 3
a1836 2
		if (startup_pipe != -1)
			close(startup_pipe);
a1846 2
		startup_pipe = REEXEC_STARTUP_PIPE_FD;
		close(config_s[1]);
@


1.405
log
@Stir PRNG after post-accept fork. The child gets a different PRNG state
anyway via rexec and explicit privsep reseeds, but it's good to be sure.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.404 2013/07/19 07:37:48 markus Exp $ */
a379 1
	arc4random_stir();
a592 1
	arc4random_stir();
a728 1
	arc4random_stir();
a1306 1
			arc4random_stir();
a1764 3

	/* Initialize the random number generator. */
	arc4random_stir();
@


1.404
log
@add ssh-agent(1) support to sshd(8); allows encrypted hostkeys,
or hostkeys on smartcards; most of the work by Zev Weiss; bz #1974
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.403 2013/06/05 02:27:50 dtucker Exp $ */
d597 1
d734 1
d1113 1
d1311 3
@


1.403
log
@When running sshd -D, close stderr unless we have explicitly requesting
logging to stderr. From james.hunt at ubuntu.com via bz#1976, djm's patch
so, err, ok dtucker.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.402 2013/05/17 00:13:14 djm Exp $ */
d93 1
d181 4
d197 1
d649 2
d761 2
d815 2
d846 8
d866 2
d1335 2
d1569 1
a1569 1
	/* load private host keys */
d1572 3
a1574 1
	for (i = 0; i < options.num_host_key_files; i++)
d1576 9
d1588 1
d1590 10
a1599 1
		if (key == NULL) {
d1603 1
d1606 2
a1607 1
		switch (key->type) {
d1618 2
a1619 2
		debug("private host key: #%d type %d %s", i, key->type,
		    key_type(key));
d1956 1
a1956 1
	if (use_privsep)
d1959 2
d2246 17
d2313 1
@


1.402
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.401 2013/05/16 09:08:41 dtucker Exp $ */
d1000 3
a1002 1
		if (fd > STDOUT_FILENO)
@


1.401
log
@Fix some "unused result" warnings found via clang and -portable.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.400 2013/05/16 04:09:14 dtucker Exp $ */
d954 1
a954 1
	xfree(cp);
d1107 1
a1107 1
			xfree(fdset);
d1435 1
a1435 1
			xfree(line);
d1457 1
a1457 1
		xfree(logfile);
d2168 1
a2168 1
		xfree(buf);
@


1.400
log
@Add RekeyLimit to sshd with the same syntax as the client allowing rekeying
based on traffic volume or time.  ok djm@@, help & ok jmc@@ for the man page.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.399 2013/04/07 02:10:33 dtucker Exp $ */
d1720 2
a1721 1
	chdir("/");
@


1.399
log
@Add -E option to ssh and sshd to append debugging logs to a specified file
instead of stderr or syslog.  ok markus@@, man page help jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.398 2013/04/06 16:07:00 markus Exp $ */
d2224 4
@


1.398
log
@handle ECONNABORTED for accept(); ok deraadt some time ago...
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.397 2013/02/11 21:21:58 dtucker Exp $ */
d886 3
a888 2
"            [-f config_file] [-g login_grace_time] [-h host_key_file]\n"
"            [-k key_gen_time] [-o option] [-p port] [-u len]\n"
d1305 1
a1305 1
	char *line;
d1325 1
a1325 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:C:dDeiqrtQRT46")) != -1) {
d1354 3
d1454 5
@


1.397
log
@Add openssl version to debug output similar to the client.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.396 2012/11/04 11:09:15 djm Exp $ */
d1155 2
a1156 1
				if (errno != EINTR && errno != EWOULDBLOCK)
@


1.396
log
@Support multiple required authentication via an AuthenticationMethods
option. This option lists one or more comma-separated lists of
authentication method names. Successful completion of all the methods in
any list is required for authentication to complete;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.395 2012/11/04 10:38:43 djm Exp $ */
d1530 2
a1531 1
	debug("sshd version %.100s", SSH_VERSION);
@


1.395
log
@Remove default of AuthorizedCommandUser. Administrators are now expected
to explicitly specify a user. feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.394 2012/10/30 21:29:55 djm Exp $ */
d1305 1
d1500 20
@


1.394
log
@new sshd_config option AuthorizedKeysCommand to support fetching
authorized_keys from a command in addition to (or instead of) from
the filesystem. The command is run as the target server user unless
another specified via a new AuthorizedKeysCommandUser option.

patch originally by jchadima AT redhat.com, reworked by me; feedback
and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.393 2012/07/10 02:19:15 djm Exp $ */
d1492 7
@


1.393
log
@Turn on systrace sandboxing of pre-auth sshd by default for new installs
by shipping a config that overrides the current UsePrivilegeSeparation=yes
default. Make it easier to flip the default in the future by adding too.
prodded markus@@ feedback dtucker@@ "get it in" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.392 2012/06/30 14:35:09 markus Exp $ */
d341 9
@


1.392
log
@fix a during the load of the sandbox policies (child can still make
the read-syscall and wait forever for systrace-answers) by replacing
the read/write synchronisation with SIGSTOP/SIGCONT;
report and help hshoexer@@; ok djm@@, dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.391 2012/05/13 01:42:32 dtucker Exp $ */
d625 1
a625 1
	if (use_privsep == PRIVSEP_SANDBOX)
@


1.391
log
@Add "Match LocalAddress" and "Match LocalPort" to sshd and adjust tests
to match.  Feedback and ok djm@@ markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.390 2012/04/12 02:42:32 djm Exp $ */
d633 1
a635 1
		pmonitor->m_pid = pid;
@


1.390
log
@VersionAddendum option to allow server operators to append some arbitrary
text to the SSH-... banner; ok deraadt@@ "don't care" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.389 2012/04/11 13:26:40 djm Exp $ */
a1292 1
	char *test_user = NULL, *test_host = NULL, *test_addr = NULL;
d1294 1
a1294 1
	char *line, *p, *cp;
d1300 1
d1404 3
a1406 14
			cp = optarg;
			while ((p = strsep(&cp, ",")) && *p != '\0') {
				if (strncmp(p, "addr=", 5) == 0)
					test_addr = xstrdup(p + 5);
				else if (strncmp(p, "host=", 5) == 0)
					test_host = xstrdup(p + 5);
				else if (strncmp(p, "user=", 5) == 0)
					test_user = xstrdup(p + 5);
				else {
					fprintf(stderr, "Invalid test "
					    "mode specification %s\n", p);
					exit(1);
				}
			}
d1418 1
a1418 1
			    "command-line", 0, NULL, NULL, NULL, NULL) != 0)
d1460 1
a1460 3
	if (test_flag >= 2 &&
	   (test_user != NULL || test_host != NULL || test_addr != NULL)
	    && (test_user == NULL || test_host == NULL || test_addr == NULL))
d1463 1
a1463 2
	if (test_flag < 2 && (test_user != NULL || test_host != NULL ||
	    test_addr != NULL))
d1475 1
a1475 1
	    &cfg, NULL, NULL, NULL);
d1618 2
a1619 3
		if (test_user != NULL && test_addr != NULL && test_host != NULL)
			parse_server_match_config(&options, test_user,
			    test_host, test_addr);
@


1.389
log
@don't spin in accept() when out of fds (ENFILE/ENFILE) - back off for a
while; ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.388 2011/09/30 21:22:49 djm Exp $ */
d402 5
a406 3
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s", major, minor,
	    SSH_VERSION, newline);
	server_version_string = xstrdup(buf);
@


1.388
log
@fix inverted test that caused logspam; spotted by henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.387 2011/09/30 00:47:37 dtucker Exp $ */
d1145 4
a1148 1
					error("accept: %.100s", strerror(errno));
@


1.387
log
@don't attempt privsep cleanup when not using privsep; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.386 2011/09/09 22:38:21 djm Exp $ */
d2229 1
a2229 1
			    errno == ESRCH)
@


1.386
log
@kill the preauth privsep child on fatal errors in the monitor;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.385 2011/06/23 09:34:13 djm Exp $ */
d2226 1
a2226 1
		if (privsep_is_preauth && pmonitor->m_pid > 1) {
@


1.385
log
@rename sandbox.h => ssh-sandbox.h to make things easier for portable
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.384 2011/06/22 21:57:01 djm Exp $ */
d225 1
d641 4
a644 3
			if (errno != EINTR)
				fatal("%s: waitpid: %s", __func__,
				    strerror(errno));
d646 2
d2224 1
a2224 1
	if (the_authctxt)
d2226 8
@


1.384
log
@introduce sandboxing of the pre-auth privsep child using systrace(4).

This introduces a new "UsePrivilegeSeparation=sandbox" option for
sshd_config that applies mandatory restrictions on the syscalls the
privsep child can perform. This prevents a compromised privsep child
from being used to attack other hosts (by opening sockets and proxying)
or probing local kernel attack surface.

The sandbox is implemented using systrace(4) in unsupervised "fast-path"
mode, where a list of permitted syscalls is supplied. Any syscall not
on the list results in SIGKILL being sent to the privsep child. Note
that this requires a kernel with the new SYSTR_POLICY_KILL option.

UsePrivilegeSeparation=sandbox will become the default in the future
so please start testing it now.

feedback dtucker@@; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.383 2011/06/17 21:44:31 djm Exp $ */
d105 1
a105 1
#include "sandbox.h"
@


1.383
log
@make the pre-auth privsep slave log via a socketpair shared with the
monitor rather than /var/empty/dev/log; ok dtucker@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.382 2011/04/12 05:32:49 djm Exp $ */
d105 1
d615 1
d622 2
d630 2
d639 1
a639 1
		while (waitpid(pid, &status, 0) < 0)
d641 13
a653 2
				break;
		return (1);
d666 4
a670 1
	return (0);
@


1.382
log
@exit with 0 status on SIGTERM; bz#1879
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.381 2011/01/11 06:13:10 djm Exp $ */
a625 1
		close(pmonitor->m_recvfd);
a627 1
		close(pmonitor->m_sendfd);
d639 2
d642 2
a643 1
		close(pmonitor->m_sendfd);
a671 1
		close(pmonitor->m_recvfd);
d679 2
d682 1
@


1.381
log
@some unsigned long long casts that make things a bit easier for
portable without resorting to dropping PRIu64 formats everywhere
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.380 2010/09/22 05:01:29 djm Exp $ */
d1087 1
a1087 1
			exit(255);
@


1.380
log
@add a KexAlgorithms knob to the client and server configuration to allow
selection of which key exchange methods are used by ssh(1) and sshd(8)
and their order of preference.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.379 2010/08/31 12:33:38 djm Exp $ */
d1896 2
a1897 1
	verbose("Transferred: sent %llu, received %llu bytes", obytes, ibytes);
@


1.379
log
@reintroduce commit from tedu@@, which I pulled out for release engineering:

  OpenSSL_add_all_algorithms is the name of the function we have a man page
  for, so use that.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.376 2010/08/12 23:34:39 tedu Exp $ */
d2156 2
@


1.378
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.377 2010/08/16 04:06:06 djm Exp $ */
d1416 1
a1416 1
	SSLeay_add_all_algorithms();
@


1.377
log
@backout previous temporarily; discussed with deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.375 2010/04/16 01:47:26 djm Exp $ */
d719 1
d735 1
d762 1
d1499 1
d2165 1
@


1.376
log
@OpenSSL_add_all_algorithms is the name of the function we have a man page
for, so use that.  ok djm
@
text
@d1413 1
a1413 1
	OpenSSL_add_all_algorithms();
@


1.375
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.374 2010/03/07 11:57:13 dtucker Exp $ */
d1413 1
a1413 1
	SSLeay_add_all_algorithms();
@


1.374
log
@Hold authentication debug messages until after successful authentication.
Fixes an info leak of environment variables specified in authorized_keys,
reported by Jacob Appelbaum.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.373 2010/02/26 20:29:54 djm Exp $ */
d730 2
d755 5
a759 1
		if (type == KEY_RSA_CERT || type == KEY_DSA_CERT)
d761 2
a762 1
		else
d764 2
@


1.373
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.372 2010/01/29 00:20:41 djm Exp $ */
d1826 1
@


1.372
log
@set FD_CLOEXEC on sock_in/sock_out; bz#1706 from jchadima AT redhat.com
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.371 2010/01/13 03:48:13 djm Exp $ */
d191 1
d529 4
d559 1
d709 1
d713 1
a713 1
		Key *key = sensitive_data.host_keys[i];
d725 13
d746 2
a747 2
Key *
get_hostkey_by_type(int type)
d750 1
d753 4
a756 1
		Key *key = sensitive_data.host_keys[i];
d758 2
a759 1
			return key;
d765 12
d790 7
a796 2
		if (key == sensitive_data.host_keys[i])
			return (i);
d835 3
a837 3
"usage: sshd [-46DdeiqTt] [-b bits] [-C connection_spec] [-f config_file]\n"
"            [-g login_grace_time] [-h host_key_file] [-k key_gen_time]\n"
"            [-o option] [-p port] [-u len]\n"
d1246 1
a1246 1
	int opt, i, on = 1;
d1280 8
d1506 40
d2154 2
a2155 1
	kex->load_host_key=&get_hostkey_by_type;
@


1.371
log
@avoid run-time failures when specifying hostkeys via a relative
path by prepending the cwd in these cases; bz#1290; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.370 2010/01/09 23:04:13 dtucker Exp $ */
d1642 4
@


1.370
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.367 2009/05/28 16:50:16 andreas Exp $ */
d1300 2
a1301 1
			options.host_key_files[options.num_host_key_files++] = optarg;
@


1.369
log
@Afer sshd receives a SIGHUP, ignore subsequent HUPs while sshd re-execs
itself.  Prevents two HUPs in quick succession from resulting in sshd
dying.  bz#1692, patch from Colin Watson via Ubuntu.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.368 2009/10/28 16:38:18 reyk Exp $ */
d937 2
a938 2
		listen_sock = socket_rdomain(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol, options.rdomain);
d1403 1
a1403 1
	/* set default channel AF and routing domain */
a1404 1
	channel_set_rdomain(options.rdomain);
@


1.368
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.367 2009/05/28 16:50:16 andreas Exp $ */
d292 1
@


1.367
log
@Keep track of number of bytes read and written. Needed for upcoming
changes. Most code from Martin Forssen, maf at appgate dot com.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.366 2009/01/22 10:02:34 djm Exp $ */
d936 2
a937 2
		listen_sock = socket(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol);
d1402 1
a1402 1
	/* set default channel AF */
d1404 1
@


1.366
log
@make a2port() return -1 when it encounters an invalid port number
rather than 0, which it will now treat as valid (needed for future work)

adjust current consumers of a2port() to check its return value is <= 0,
which in turn required some things to be converted from u_short => int

make use of int vs. u_short consistent in some other places too

feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.365 2008/10/30 19:31:16 stevesk Exp $ */
d104 1
d403 1
a403 1
	if (atomicio(vwrite, sock_out, server_version_string,
d413 1
a413 1
		if (atomicio(read, sock_in, &buf[i], 1) != 1) {
@


1.365
log
@don't need to #include "monitor_fdpass.h"
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.364 2008/07/10 18:08:11 markus Exp $ */
d1276 1
a1276 1
			if (options.ports[options.num_ports-1] == 0) {
@


1.364
log
@sync v1 and v2 traffic accounting; add it to sshd, too; ok djm@@, dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.363 2008/07/01 07:24:22 dtucker Exp $ */
a103 1
#include "monitor_fdpass.h"
@


1.363
log
@Send CR LF during protocol banner exchanges, but only for Protocol 2 only,
in order to comply with RFC 4253.  bz #1443, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.362 2008/06/14 17:07:11 dtucker Exp $ */
d663 1
a663 1
		debug2("User child is on pid %ld", (long)pmonitor->m_pid);
d1210 1
d1784 5
a1788 1
	verbose("Closing connection to %.100s", remote_ip);
@


1.362
log
@ensure default umask disallows at least group and world write; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.361 2008/06/14 15:49:48 dtucker Exp $ */
d382 1
a382 1
	char *s;
d393 1
d398 2
a399 1
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s\n", major, minor, SSH_VERSION);
@


1.361
log
@wrap long line at 80 chars
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.360 2008/06/12 20:38:28 dtucker Exp $ */
d1208 1
d1511 4
@


1.360
log
@Make keepalive timeouts apply while waiting for a packet, particularly during
key renegotiation (bz #1363).  With djm and Matt Day, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.359 2008/06/10 08:17:40 jmc Exp $ */
d1371 2
a1372 1
	if (test_flag >= 2 && (test_user != NULL || test_host != NULL || test_addr != NULL)
@


1.359
log
@- update usage()
- fix SYNOPSIS, and sort options
- some minor additional fixes
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.358 2008/06/10 04:50:25 dtucker Exp $ */
d1767 3
@


1.358
log
@Add extended test mode (-T) and connection parameters for test mode (-C).
-T causes sshd to write its effective configuration to stdout and exit.
-C causes any relevant Match rules to be applied before output.  The
combination allows tesing of the parser and config files.  ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.357 2008/05/08 12:02:23 djm Exp $ */
d790 3
a792 2
"usage: sshd [-46Ddeiqt] [-b bits] [-f config_file] [-g login_grace_time]\n"
"            [-h host_key_file] [-k key_gen_time] [-o option] [-p port] [-u len]\n"
@


1.357
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.356 2008/04/13 00:22:17 djm Exp $ */
d1203 1
d1205 1
a1205 1
	char *line;
d1221 1
a1221 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:dDeiqrtQR46")) != -1) {
d1299 19
d1365 14
d1486 7
@


1.356
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.355 2008/02/14 13:10:31 mbalmer Exp $ */
d52 1
@


1.355
log
@When started in configuration test mode (-t) do not check that sshd is
being started with an absolute path.

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.354 2008/02/13 22:38:17 djm Exp $ */
a350 3
	u_int32_t rnd = 0;
	int i;

d359 1
a359 6
	for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++) {
		if (i % 4 == 0)
			rnd = arc4random();
		sensitive_data.ssh1_cookie[i] = rnd & 0xff;
		rnd >>= 8;
	}
a560 1
	u_int i;
d566 1
a566 2
	for (i = 0; i < 256; i++)
		rnd[i] = arc4random();
a645 1
	u_int i;
d675 1
a675 2
	for (i = 0; i < 256; i++)
		rnd[i] = arc4random();
d777 1
a777 1
	r = arc4random() % 100;
a1798 1
	u_int32_t rnd = 0;
d1809 1
a1809 6
	for (i = 0; i < 8; i++) {
		if (i % 4 == 0)
			rnd = arc4random();
		cookie[i] = rnd & 0xff;
		rnd >>= 8;
	}
@


1.354
log
@rekey arc4random and OpenSSL RNG in postauth child
closefrom fds > 2 before shell/command execution
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.353 2007/12/31 15:27:04 dtucker Exp $ */
d1331 1
a1331 1
	if (rexec_flag && (av[0] == NULL || *av[0] != '/'))
@


1.353
log
@When in inetd mode, have sshd generate a Protocol 1 ephemeral server
key only for connections where the client chooses Protocol 1 as opposed
to when it's enabled in the server's config.  Speeds up Protocol 2
connections to inetd-mode servers that also allow Protocol 1.  bz #440,
based on a patch from bruno at wolff.to, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.352 2007/12/27 14:22:08 dtucker Exp $ */
d569 1
a569 1
	int i;
d574 1
d655 3
d684 5
@


1.352
log
@Add a small helper function to consistently handle the EAI_SYSTEM error
code of getaddrinfo.  Prompted by vgiffin at apple com via bz #1417.
ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.351 2007/05/22 10:18:52 djm Exp $ */
a1508 4

		if ((options.protocol & SSH_PROTO_1) &&
		    sensitive_data.server_key == NULL)
			generate_ephemeral_server_key();
d1666 4
@


1.351
log
@zap double include; from p_nowaczyk AT o2.pl
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.350 2007/03/09 05:20:06 dtucker Exp $ */
d931 1
a931 2
			    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
			    strerror(errno));
@


1.350
log
@Move C/R -> kbdint special case to after the defaults have been
loaded, which makes ChallengeResponse default to yes again.  This
was broken by the Match changes and not fixed properly subsequently.
Found by okan at demirmen.com, ok djm@@ "please do it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.349 2007/02/21 11:00:05 dtucker Exp $ */
a53 1
#include <signal.h>
@


1.349
log
@Clear alarm() before restarting sshd on SIGHUP.  Without this, if there's
a SIGALRM pending (for SSH1 key regeneration) when sshd is SIGHUP'ed, the
newly exec'ed sshd will get the SIGALRM and not have a handler for it,
and the default action will terminate the listening sshd.  Analysis and
patch from andrew at gaul.org.
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.348 2006/11/06 21:25:28 markus Exp $ */
d1361 4
@


1.348
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.347 2006/08/18 09:15:20 markus Exp $ */
d291 1
@


1.347
log
@delay authentication related cleanups until we're authenticated and
all alarms have been cancelled; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.346 2006/08/18 09:13:26 deraadt Exp $ */
d1897 1
a1897 1
		BN_mask_bits(session_key_int, sizeof(session_key) * 8);
d1900 1
a1900 1
			error("do_connection: bad session key len from %s: "
@


1.347.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.348 2006/11/06 21:25:28 markus Exp $ */
d1897 1
a1897 1
		(void) BN_mask_bits(session_key_int, sizeof(session_key) * 8);
d1900 1
a1900 1
			error("do_ssh1_kex: bad session key len from %s: "
@


1.346
log
@make signal handler termination path shorter; risky code pointed out by
mark dowd; ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.345 2006/08/16 11:47:15 djm Exp $ */
d1708 1
@


1.345
log
@factor inetd connection, TCP listen and main TCP accept loop out of main()
into separate functions to improve readability; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.344 2006/08/05 07:52:52 dtucker Exp $ */
a333 2
	/* XXX no idea how fix this signal handler */

d338 1
a338 1
	fatal("Timeout before authentication for %s", get_remote_ipaddr());
@


1.344
log
@Add headers required to build with KERBEROS5=no.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.343 2006/08/03 03:34:42 deraadt Exp $ */
d881 316
d1205 1
a1205 1
	int opt, j, i, on = 1;
a1206 4
	pid_t pid;
	socklen_t fromlen;
	fd_set *fdset;
	struct sockaddr_storage from;
a1208 3
	FILE *f;
	struct addrinfo *ai;
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
d1210 1
a1210 3
	int listen_sock, maxfd;
	int startup_p[2] = { -1 , -1 }, config_s[2] = { -1 , -1 };
	int startups = 0;
a1212 1
	int ret, key_used = 0;
a1479 1
#ifdef TIOCNOTTY
d1481 1
a1481 1
#endif /* TIOCNOTTY */
a1485 1
#ifdef TIOCNOTTY
a1490 1
#endif /* TIOCNOTTY */
d1505 1
a1505 1
	/* Start listening for a socket, unless started from inetd. */
d1507 1
a1507 1
		int fd;
a1508 24
		startup_pipe = -1;
		if (rexeced_flag) {
			close(REEXEC_CONFIG_PASS_FD);
			sock_in = sock_out = dup(STDIN_FILENO);
			if (!debug_flag) {
				startup_pipe = dup(REEXEC_STARTUP_PIPE_FD);
				close(REEXEC_STARTUP_PIPE_FD);
			}
		} else {
			sock_in = dup(STDIN_FILENO);
			sock_out = dup(STDOUT_FILENO);
		}
		/*
		 * We intentionally do not close the descriptors 0, 1, and 2
		 * as our code for setting the descriptors won't work if
		 * ttyfd happens to be one of those.
		 */
		if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			if (fd > STDOUT_FILENO)
				close(fd);
		}
		debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
d1513 1
a1513 56
		for (ai = options.listen_addrs; ai; ai = ai->ai_next) {
			if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
				continue;
			if (num_listen_socks >= MAX_LISTEN_SOCKS)
				fatal("Too many listen sockets. "
				    "Enlarge MAX_LISTEN_SOCKS");
			if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,
			    ntop, sizeof(ntop), strport, sizeof(strport),
			    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
				error("getnameinfo failed: %.100s",
				    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
				    strerror(errno));
				continue;
			}
			/* Create socket for listening. */
			listen_sock = socket(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol);
			if (listen_sock < 0) {
				/* kernel may not support ipv6 */
				verbose("socket: %.100s", strerror(errno));
				continue;
			}
			if (set_nonblock(listen_sock) == -1) {
				close(listen_sock);
				continue;
			}
			/*
			 * Set socket options.
			 * Allow local port reuse in TIME_WAIT.
			 */
			if (setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR,
			    &on, sizeof(on)) == -1)
				error("setsockopt SO_REUSEADDR: %s", strerror(errno));

			debug("Bind to port %s on %s.", strport, ntop);

			/* Bind the socket to the desired port. */
			if (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {
				error("Bind to port %s on %s failed: %.200s.",
				    strport, ntop, strerror(errno));
				close(listen_sock);
				continue;
			}
			listen_socks[num_listen_socks] = listen_sock;
			num_listen_socks++;

			/* Start listening on the port. */
			if (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)
				fatal("listen on [%s]:%s: %.100s",
				    ntop, strport, strerror(errno));
			logit("Server listening on %s port %s.", ntop, strport);
		}
		freeaddrinfo(options.listen_addrs);

		if (!num_listen_socks)
			fatal("Cannot bind any address.");
a1517 4
		/*
		 * Arrange to restart on SIGHUP.  The handler needs
		 * listen_sock.
		 */
d1519 1
a1519 1

d1523 6
a1528 2
		/* Arrange SIGCHLD to be caught. */
		signal(SIGCHLD, main_sigchld_handler);
a1529 10
		/* Write out the pid file after the sigterm handler is setup */
		if (!debug_flag) {
			/*
			 * Record our pid in /var/run/sshd.pid to make it
			 * easier to kill the correct sshd.  We don't want to
			 * do this before the bind above because the bind will
			 * fail if there already is a daemon, and this will
			 * overwrite any old pid in the file.
			 */
			f = fopen(options.pid_file, "w");
d1539 3
a1541 192
		/* setup fd set for listen */
		fdset = NULL;
		maxfd = 0;
		for (i = 0; i < num_listen_socks; i++)
			if (listen_socks[i] > maxfd)
				maxfd = listen_socks[i];
		/* pipes connected to unauthenticated childs */
		startup_pipes = xcalloc(options.max_startups, sizeof(int));
		for (i = 0; i < options.max_startups; i++)
			startup_pipes[i] = -1;

		/*
		 * Stay listening for connections until the system crashes or
		 * the daemon is killed with a signal.
		 */
		for (;;) {
			if (received_sighup)
				sighup_restart();
			if (fdset != NULL)
				xfree(fdset);
			fdset = (fd_set *)xcalloc(howmany(maxfd + 1, NFDBITS),
			    sizeof(fd_mask));

			for (i = 0; i < num_listen_socks; i++)
				FD_SET(listen_socks[i], fdset);
			for (i = 0; i < options.max_startups; i++)
				if (startup_pipes[i] != -1)
					FD_SET(startup_pipes[i], fdset);

			/* Wait in select until there is a connection. */
			ret = select(maxfd+1, fdset, NULL, NULL, NULL);
			if (ret < 0 && errno != EINTR)
				error("select: %.100s", strerror(errno));
			if (received_sigterm) {
				logit("Received signal %d; terminating.",
				    (int) received_sigterm);
				close_listen_socks();
				unlink(options.pid_file);
				exit(255);
			}
			if (key_used && key_do_regen) {
				generate_ephemeral_server_key();
				key_used = 0;
				key_do_regen = 0;
			}
			if (ret < 0)
				continue;

			for (i = 0; i < options.max_startups; i++)
				if (startup_pipes[i] != -1 &&
				    FD_ISSET(startup_pipes[i], fdset)) {
					/*
					 * the read end of the pipe is ready
					 * if the child has closed the pipe
					 * after successful authentication
					 * or if the child has died
					 */
					close(startup_pipes[i]);
					startup_pipes[i] = -1;
					startups--;
				}
			for (i = 0; i < num_listen_socks; i++) {
				if (!FD_ISSET(listen_socks[i], fdset))
					continue;
				fromlen = sizeof(from);
				newsock = accept(listen_socks[i],
				    (struct sockaddr *)&from, &fromlen);
				if (newsock < 0) {
					if (errno != EINTR && errno != EWOULDBLOCK)
						error("accept: %.100s", strerror(errno));
					continue;
				}
				if (unset_nonblock(newsock) == -1) {
					close(newsock);
					continue;
				}
				if (drop_connection(startups) == 1) {
					debug("drop connection #%d", startups);
					close(newsock);
					continue;
				}
				if (pipe(startup_p) == -1) {
					close(newsock);
					continue;
				}

				if (rexec_flag && socketpair(AF_UNIX,
				    SOCK_STREAM, 0, config_s) == -1) {
					error("reexec socketpair: %s",
					    strerror(errno));
					close(newsock);
					close(startup_p[0]);
					close(startup_p[1]);
					continue;
				}

				for (j = 0; j < options.max_startups; j++)
					if (startup_pipes[j] == -1) {
						startup_pipes[j] = startup_p[0];
						if (maxfd < startup_p[0])
							maxfd = startup_p[0];
						startups++;
						break;
					}

				/*
				 * Got connection.  Fork a child to handle it, unless
				 * we are in debugging mode.
				 */
				if (debug_flag) {
					/*
					 * In debugging mode.  Close the listening
					 * socket, and start processing the
					 * connection without forking.
					 */
					debug("Server will not fork when running in debugging mode.");
					close_listen_socks();
					sock_in = newsock;
					sock_out = newsock;
					close(startup_p[0]);
					close(startup_p[1]);
					startup_pipe = -1;
					pid = getpid();
					if (rexec_flag) {
						send_rexec_state(config_s[0],
						    &cfg);
						close(config_s[0]);
					}
					break;
				} else {
					/*
					 * Normal production daemon.  Fork, and have
					 * the child process the connection. The
					 * parent continues listening.
					 */
					if ((pid = fork()) == 0) {
						/*
						 * Child.  Close the listening and
						 * max_startup sockets.  Start using
						 * the accepted socket. Reinitialize
						 * logging (since our pid has changed).
						 * We break out of the loop to handle
						 * the connection.
						 */
						startup_pipe = startup_p[1];
						close_startup_pipes();
						close_listen_socks();
						sock_in = newsock;
						sock_out = newsock;
						log_init(__progname,
						    options.log_level,
						    options.log_facility,
						    log_stderr);
						if (rexec_flag)
							close(config_s[0]);
						break;
					}
				}

				/* Parent.  Stay in the loop. */
				if (pid < 0)
					error("fork: %.100s", strerror(errno));
				else
					debug("Forked child %ld.", (long)pid);

				close(startup_p[1]);

				if (rexec_flag) {
					send_rexec_state(config_s[0], &cfg);
					close(config_s[0]);
					close(config_s[1]);
				}

				/*
				 * Mark that the key has been used (it
				 * was "given" to the child).
				 */
				if ((options.protocol & SSH_PROTO_1) &&
				    key_used == 0) {
					/* Schedule server key regeneration alarm. */
					signal(SIGALRM, key_regeneration_alarm);
					alarm(options.key_regeneration_time);
					key_used = 1;
				}

				arc4random_stir();
				close(newsock);
			}
			/* child process check (or debug mode) */
			if (num_listen_socks < 0)
				break;
		}
@


1.343
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.342 2006/08/01 23:22:48 stevesk Exp $ */
d63 1
@


1.342
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.341 2006/07/26 13:57:17 stevesk Exp $ */
d45 1
a45 2
#include "includes.h"

a46 1
#include <sys/types.h>
d48 1
d54 1
d69 1
a72 1
#include "xmalloc.h"
d77 1
a80 2
#include "buffer.h"
#include "bufaux.h"
d82 1
a83 1
#include "key.h"
d90 1
d99 3
@


1.341
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.340 2006/07/25 02:59:21 stevesk Exp $ */
d60 1
@


1.340
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.339 2006/07/22 20:48:23 stevesk Exp $ */
d60 1
@


1.339
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.338 2006/07/12 22:28:52 stevesk Exp $ */
d52 1
@


1.338
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.337 2006/07/12 11:34:58 dtucker Exp $ */
d59 1
@


1.337
log
@Add support for conditional directives to sshd_config via a "Match" keyword,
which works similarly to the "Host" directive in ssh_config.

Lines after a Match line override the default set in the main section
if the condition on the Match line is true, eg

AllowTcpForwarding yes
Match User anoncvs
        AllowTcpForwarding no

will allow port forwarding by all users except "anoncvs".

Currently only a very small subset of directives are supported.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.336 2006/07/11 20:07:25 stevesk Exp $ */
d55 1
@


1.336
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.335 2006/07/09 15:15:11 stevesk Exp $ */
d212 1
a212 1
int use_privsep;
d218 3
a897 1
	Buffer cfg;
d998 1
a998 1
			    "command-line", 0) != 0)
d1042 2
a1043 5
	parse_server_config(&options,
	    rexeced_flag ? "rexec" : config_file_name, &cfg);

	if (!rexec_flag)
		buffer_free(&cfg);
@


1.335
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.334 2006/07/08 21:47:12 stevesk Exp $ */
d53 1
@


1.334
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.333 2006/07/06 16:03:53 stevesk Exp $ */
d53 1
@


1.333
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.332 2006/07/03 08:54:20 stevesk Exp $ */
d51 1
@


1.332
log
@move #include "version.h" out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.331 2006/06/01 09:21:48 markus Exp $ */
d53 1
@


1.331
log
@call get_remote_ipaddr() early; fixes logging after client disconnects;
report mpf@@; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.330 2006/03/25 13:17:02 djm Exp $ */
d92 1
@


1.330
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1590 7
a1596 1
	remote_ip = get_canonical_hostname(0);
@


1.329
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.328
log
@sprinkle some ARGSUSED for table driven functions (which sometimes must ignore their args)
@
text
@d871 1
a871 1
	int opt, j, i, fdsetsz, on = 1;
d1055 1
a1055 1
	sensitive_data.host_keys = xmalloc(options.num_host_key_files *
d1140 1
a1140 1
		rexec_argv = xmalloc(sizeof(char *) * (rexec_argc + 2));
d1318 1
a1318 1
		startup_pipes = xmalloc(options.max_startups * sizeof(int));
d1331 2
a1332 3
			fdsetsz = howmany(maxfd+1, NFDBITS) * sizeof(fd_mask);
			fdset = (fd_set *)xmalloc(fdsetsz);
			memset(fdset, 0, fdsetsz);
d1628 1
a1628 2
	authctxt = xmalloc(sizeof(*authctxt));
	memset(authctxt, 0, sizeof(*authctxt));
@


1.327
log
@ARGSUSED for signal handlers
@
text
@a266 1
/*ARGSUSED*/
@


1.326
log
@RCSID() can die
@
text
@d251 2
d267 1
d283 1
d294 1
d313 1
d356 1
d944 2
a945 1
			options.server_key_bits = atoi(optarg);
d982 1
a982 1
			utmp_len = atoi(optarg);
a1121 1
		struct passwd *pw;
d1124 1
a1124 1
		if ((pw = getpwnam(SSH_PRIVSEP_USER)) == NULL)
d1378 2
a1379 2
				newsock = accept(listen_socks[i], (struct sockaddr *)&from,
				    &fromlen);
d1450 5
a1454 4
						 * Child.  Close the listening and max_startup
						 * sockets.  Start using the accepted socket.
						 * Reinitialize logging (since our pid has
						 * changed).  We break out of the loop to handle
d1462 4
a1465 1
						log_init(__progname, options.log_level, options.log_facility, log_stderr);
d1486 4
a1489 1
				/* Mark that the key has been used (it was "given" to the child). */
a1498 2

				/* Close the new socket (the child is now taking care of it). */
d1706 2
a1707 1
	if (BN_cmp(sensitive_data.server_key->rsa->n, sensitive_data.ssh1_host_key->rsa->n) > 0) {
d1710 4
a1713 2
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
d1728 4
a1731 2
		    BN_num_bits(sensitive_data.server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
d1952 1
a1952 1
	
@


1.325
log
@don't log that we are listening on a socket before the listen() call
actually succeeds, bz #1162 reported by Senthil Kumar; ok dtucker@@
@
text
@a44 1
RCSID("$OpenBSD: sshd.c,v 1.324 2006/03/07 09:07:40 djm Exp $");
@


1.324
log
@Implement the diffie-hellman-group-exchange-sha256 key exchange method
using the SHA256 code in libc (and wrapper to make it into an OpenSSL
EVP), interop tested against CVS PuTTY
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.323 2006/02/20 17:19:54 stevesk Exp $");
d1262 3
a1265 3
			if (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)
				fatal("listen: %.100s", strerror(errno));

@


1.323
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.322 2006/02/20 17:02:44 stevesk Exp $");
d1944 1
@


1.323.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sshd.c,v 1.347 2006/08/18 09:15:20 markus Exp $ */
d44 4
a48 1
#include <sys/ioctl.h>
a49 1
#include <sys/tree.h>
a50 2
#include <sys/socket.h>
#include <sys/time.h>
a51 4
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <netdb.h>
a52 1
#include <pwd.h>
a53 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a59 1
#include "xmalloc.h"
d63 1
a67 1
#include "buffer.h"
d71 2
d74 1
a75 1
#include "kex.h"
a81 1
#include "hostfile.h"
a89 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
a91 1
#include "version.h"
d207 1
a207 1
int use_privsep = -1;
a212 3
/* sshd_config buffer */
Buffer cfg;

a251 2

/*ARGSUSED*/
a280 1
/*ARGSUSED*/
a290 1
/*ARGSUSED*/
a308 1
/*ARGSUSED*/
d312 2
d318 1
a318 1
	sigdie("Timeout before authentication for %s", get_remote_ipaddr());
a350 1
/*ARGSUSED*/
a857 316
/* Accept a connection from inetd */
static void
server_accept_inetd(int *sock_in, int *sock_out)
{
	int fd;

	startup_pipe = -1;
	if (rexeced_flag) {
		close(REEXEC_CONFIG_PASS_FD);
		*sock_in = *sock_out = dup(STDIN_FILENO);
		if (!debug_flag) {
			startup_pipe = dup(REEXEC_STARTUP_PIPE_FD);
			close(REEXEC_STARTUP_PIPE_FD);
		}
	} else {
		*sock_in = dup(STDIN_FILENO);
		*sock_out = dup(STDOUT_FILENO);
	}
	/*
	 * We intentionally do not close the descriptors 0, 1, and 2
	 * as our code for setting the descriptors won't work if
	 * ttyfd happens to be one of those.
	 */
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		dup2(fd, STDIN_FILENO);
		dup2(fd, STDOUT_FILENO);
		if (fd > STDOUT_FILENO)
			close(fd);
	}
	debug("inetd sockets after dupping: %d, %d", *sock_in, *sock_out);
}

/*
 * Listen for TCP connections
 */
static void
server_listen(void)
{
	int ret, listen_sock, on = 1;
	struct addrinfo *ai;
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];

	for (ai = options.listen_addrs; ai; ai = ai->ai_next) {
		if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
			continue;
		if (num_listen_socks >= MAX_LISTEN_SOCKS)
			fatal("Too many listen sockets. "
			    "Enlarge MAX_LISTEN_SOCKS");
		if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,
		    ntop, sizeof(ntop), strport, sizeof(strport),
		    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
			error("getnameinfo failed: %.100s",
			    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
			    strerror(errno));
			continue;
		}
		/* Create socket for listening. */
		listen_sock = socket(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol);
		if (listen_sock < 0) {
			/* kernel may not support ipv6 */
			verbose("socket: %.100s", strerror(errno));
			continue;
		}
		if (set_nonblock(listen_sock) == -1) {
			close(listen_sock);
			continue;
		}
		/*
		 * Set socket options.
		 * Allow local port reuse in TIME_WAIT.
		 */
		if (setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR,
		    &on, sizeof(on)) == -1)
			error("setsockopt SO_REUSEADDR: %s", strerror(errno));

		debug("Bind to port %s on %s.", strport, ntop);

		/* Bind the socket to the desired port. */
		if (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {
			error("Bind to port %s on %s failed: %.200s.",
			    strport, ntop, strerror(errno));
			close(listen_sock);
			continue;
		}
		listen_socks[num_listen_socks] = listen_sock;
		num_listen_socks++;

		/* Start listening on the port. */
		if (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)
			fatal("listen on [%s]:%s: %.100s",
			    ntop, strport, strerror(errno));
		logit("Server listening on %s port %s.", ntop, strport);
	}
	freeaddrinfo(options.listen_addrs);

	if (!num_listen_socks)
		fatal("Cannot bind any address.");
}

/*
 * The main TCP accept loop. Note that, for the non-debug case, returns
 * from this function are in a forked subprocess.
 */
static void
server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
{
	fd_set *fdset;
	int i, j, ret, maxfd;
	int key_used = 0, startups = 0;
	int startup_p[2] = { -1 , -1 };
	struct sockaddr_storage from;
	socklen_t fromlen;
	pid_t pid;

	/* setup fd set for accept */
	fdset = NULL;
	maxfd = 0;
	for (i = 0; i < num_listen_socks; i++)
		if (listen_socks[i] > maxfd)
			maxfd = listen_socks[i];
	/* pipes connected to unauthenticated childs */
	startup_pipes = xcalloc(options.max_startups, sizeof(int));
	for (i = 0; i < options.max_startups; i++)
		startup_pipes[i] = -1;

	/*
	 * Stay listening for connections until the system crashes or
	 * the daemon is killed with a signal.
	 */
	for (;;) {
		if (received_sighup)
			sighup_restart();
		if (fdset != NULL)
			xfree(fdset);
		fdset = (fd_set *)xcalloc(howmany(maxfd + 1, NFDBITS),
		    sizeof(fd_mask));

		for (i = 0; i < num_listen_socks; i++)
			FD_SET(listen_socks[i], fdset);
		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1)
				FD_SET(startup_pipes[i], fdset);

		/* Wait in select until there is a connection. */
		ret = select(maxfd+1, fdset, NULL, NULL, NULL);
		if (ret < 0 && errno != EINTR)
			error("select: %.100s", strerror(errno));
		if (received_sigterm) {
			logit("Received signal %d; terminating.",
			    (int) received_sigterm);
			close_listen_socks();
			unlink(options.pid_file);
			exit(255);
		}
		if (key_used && key_do_regen) {
			generate_ephemeral_server_key();
			key_used = 0;
			key_do_regen = 0;
		}
		if (ret < 0)
			continue;

		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1 &&
			    FD_ISSET(startup_pipes[i], fdset)) {
				/*
				 * the read end of the pipe is ready
				 * if the child has closed the pipe
				 * after successful authentication
				 * or if the child has died
				 */
				close(startup_pipes[i]);
				startup_pipes[i] = -1;
				startups--;
			}
		for (i = 0; i < num_listen_socks; i++) {
			if (!FD_ISSET(listen_socks[i], fdset))
				continue;
			fromlen = sizeof(from);
			*newsock = accept(listen_socks[i],
			    (struct sockaddr *)&from, &fromlen);
			if (*newsock < 0) {
				if (errno != EINTR && errno != EWOULDBLOCK)
					error("accept: %.100s", strerror(errno));
				continue;
			}
			if (unset_nonblock(*newsock) == -1) {
				close(*newsock);
				continue;
			}
			if (drop_connection(startups) == 1) {
				debug("drop connection #%d", startups);
				close(*newsock);
				continue;
			}
			if (pipe(startup_p) == -1) {
				close(*newsock);
				continue;
			}

			if (rexec_flag && socketpair(AF_UNIX,
			    SOCK_STREAM, 0, config_s) == -1) {
				error("reexec socketpair: %s",
				    strerror(errno));
				close(*newsock);
				close(startup_p[0]);
				close(startup_p[1]);
				continue;
			}

			for (j = 0; j < options.max_startups; j++)
				if (startup_pipes[j] == -1) {
					startup_pipes[j] = startup_p[0];
					if (maxfd < startup_p[0])
						maxfd = startup_p[0];
					startups++;
					break;
				}

			/*
			 * Got connection.  Fork a child to handle it, unless
			 * we are in debugging mode.
			 */
			if (debug_flag) {
				/*
				 * In debugging mode.  Close the listening
				 * socket, and start processing the
				 * connection without forking.
				 */
				debug("Server will not fork when running in debugging mode.");
				close_listen_socks();
				*sock_in = *newsock;
				*sock_out = *newsock;
				close(startup_p[0]);
				close(startup_p[1]);
				startup_pipe = -1;
				pid = getpid();
				if (rexec_flag) {
					send_rexec_state(config_s[0],
					    &cfg);
					close(config_s[0]);
				}
				break;
			}

			/*
			 * Normal production daemon.  Fork, and have
			 * the child process the connection. The
			 * parent continues listening.
			 */
			if ((pid = fork()) == 0) {
				/*
				 * Child.  Close the listening and
				 * max_startup sockets.  Start using
				 * the accepted socket. Reinitialize
				 * logging (since our pid has changed).
				 * We break out of the loop to handle
				 * the connection.
				 */
				startup_pipe = startup_p[1];
				close_startup_pipes();
				close_listen_socks();
				*sock_in = *newsock;
				*sock_out = *newsock;
				log_init(__progname,
				    options.log_level,
				    options.log_facility,
				    log_stderr);
				if (rexec_flag)
					close(config_s[0]);
				break;
			}

			/* Parent.  Stay in the loop. */
			if (pid < 0)
				error("fork: %.100s", strerror(errno));
			else
				debug("Forked child %ld.", (long)pid);

			close(startup_p[1]);

			if (rexec_flag) {
				send_rexec_state(config_s[0], &cfg);
				close(config_s[0]);
				close(config_s[1]);
			}

			/*
			 * Mark that the key has been used (it
			 * was "given" to the child).
			 */
			if ((options.protocol & SSH_PROTO_1) &&
			    key_used == 0) {
				/* Schedule server key regeneration alarm. */
				signal(SIGALRM, key_regeneration_alarm);
				alarm(options.key_regeneration_time);
				key_used = 1;
			}

			close(*newsock);

			/*
			 * Ensure that our random state differs
			 * from that of the child
			 */
			arc4random_stir();
		}

		/* child process check (or debug mode) */
		if (num_listen_socks < 0)
			break;
	}
}


d866 1
a866 1
	int opt, i, on = 1;
d868 4
d874 3
d878 3
a880 1
	int config_s[2] = { -1 , -1 };
d883 2
d938 1
a938 2
			options.server_key_bits = (int)strtonum(optarg, 256,
			    32768, NULL);
d975 1
a975 1
			utmp_len = (u_int)strtonum(optarg, 0, MAXHOSTNAMELEN+1, NULL);
d984 1
a984 1
			    "command-line", 0, NULL, NULL, NULL, NULL) != 0)
d1028 5
a1032 2
	parse_server_config(&options, rexeced_flag ? "rexec" : config_file_name,
	    &cfg, NULL, NULL, NULL);
d1049 1
a1049 1
	sensitive_data.host_keys = xcalloc(options.num_host_key_files,
d1115 1
d1118 1
a1118 1
		if (getpwnam(SSH_PRIVSEP_USER) == NULL)
d1135 1
a1135 1
		rexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));
d1155 1
d1157 1
a1157 1

d1162 1
d1168 1
d1183 1
a1183 1
	/* Get a connection, either from inetd or a listening TCP socket */
d1185 1
a1185 1
		server_accept_inetd(&sock_in, &sock_out);
d1187 24
d1215 56
a1270 1
		server_listen();
d1275 4
d1280 1
a1280 1
		signal(SIGCHLD, main_sigchld_handler);
d1284 4
a1287 4
		/*
		 * Write out the pid file after the sigterm handler
		 * is setup and the listen sockets are bound
		 */
d1289 8
a1296 2
			FILE *f = fopen(options.pid_file, "w");

d1306 188
a1493 3
		/* Accept a connection and return in a forked child */
		server_accept_loop(&sock_in, &sock_out,
		    &newsock, config_s);
d1580 1
a1580 7
	(void) get_canonical_hostname(0);
	/*
	 * The rest of the code depends on the fact that
	 * get_remote_ipaddr() caches the remote ip, even if
	 * the socket goes away.
	 */
	remote_ip = get_remote_ipaddr();
d1619 2
a1620 1
	authctxt = xcalloc(1, sizeof(*authctxt));
a1656 1
	authctxt->authenticated = 1;
d1695 1
a1695 2
	if (BN_cmp(sensitive_data.server_key->rsa->n,
	    sensitive_data.ssh1_host_key->rsa->n) > 0) {
d1698 2
a1699 4
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: "
			    "server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
d1714 2
a1715 4
		    BN_num_bits(sensitive_data.server_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: "
			    "host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
d1936 1
a1936 1

a1943 1
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
@


1.323.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.348 2006/11/06 21:25:28 markus Exp $ */
d1897 1
a1897 1
		(void) BN_mask_bits(session_key_int, sizeof(session_key) * 8);
d1900 1
a1900 1
			error("do_ssh1_kex: bad session key len from %s: "
@


1.322
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.321 2006/02/10 01:44:27 stevesk Exp $");
d50 1
@


1.321
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.320 2006/02/10 00:27:13 stevesk Exp $");
d52 1
@


1.320
log
@move #include <sys/ioctl.h> out of includes.h; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.319 2006/02/08 12:15:27 stevesk Exp $");
d48 2
@


1.319
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d45 3
a47 1
RCSID("$OpenBSD: sshd.c,v 1.318 2005/12/24 02:27:41 djm Exp $");
@


1.318
log
@eliminate some code duplicated in privsep and non-privsep paths, and
explicitly clear SIGALRM handler; "groovy" deraadt@@
@
text
@d45 3
a47 1
RCSID("$OpenBSD: sshd.c,v 1.317 2005/10/30 08:52:18 djm Exp $");
@


1.317
log
@no need to escape single quotes in comments, no binary change
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.316 2005/10/30 08:29:29 dtucker Exp $");
a630 7
	/* Authentication complete */
	alarm(0);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}

d1643 11
@


1.316
log
@Check for connections with IP options earlier and drop silently.  ok djm@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.315 2005/09/21 23:37:11 djm Exp $");
d1602 1
a1602 1
	 * We don\'t want to listen forever unless the other side
d1605 1
a1605 1
	 * indicates no limit. Note that we don\'t set the alarm in debugging
@


1.315
log
@change label at markus@@'s request
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.314 2005/09/19 11:47:09 djm Exp $");
d1574 6
a1579 1
	remote_ip = get_remote_ipaddr();
@


1.314
log
@stop connection abort on rekey with delayed compression enabled when
post-auth privsep is disabled (e.g. when root is logged in); ok dtucker@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.313 2005/09/13 23:40:07 djm Exp $");
d628 1
a628 1
		goto out;
d662 1
a662 1
 out:
@


1.313
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.312 2005/07/25 11:59:40 markus Exp $");
a626 1
		monitor_apply_keystate(pmonitor);
d628 1
a628 1
		return;
d662 1
@


1.312
log
@add a new compression method that delays compression until the user
has been authenticated successfully and set compression to 'delayed'
for sshd.

this breaks older openssh clients (< 3.5) if they insist on
compression, so you have to re-enable compression in sshd_config.
ok djm@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.311 2005/06/17 02:44:33 djm Exp $");
d888 3
@


1.312.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.318 2005/12/24 02:27:41 djm Exp $");
d627 1
d629 8
a636 1
		goto skip;
a662 1
 skip:
a888 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d1571 1
a1571 6

	/*
	 * We use get_canonical_hostname with usedns = 0 instead of
	 * get_remote_ipaddr here so IP options will be checked.
	 */
	remote_ip = get_canonical_hostname(0);
d1594 1
a1594 1
	 * We don't want to listen forever unless the other side
d1597 1
a1597 1
	 * indicates no limit. Note that we don't set the alarm in debugging
a1641 11
	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);
	signal(SIGALRM, SIG_DFL);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}

@


1.312.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sshd.c,v 1.347 2006/08/18 09:15:20 markus Exp $ */
d44 2
a45 19
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/tree.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a51 1
#include "xmalloc.h"
d55 1
a59 1
#include "buffer.h"
d63 2
d66 1
a67 1
#include "kex.h"
a73 1
#include "hostfile.h"
a81 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
a83 1
#include "version.h"
d199 1
a199 1
int use_privsep = -1;
a204 3
/* sshd_config buffer */
Buffer cfg;

a243 2

/*ARGSUSED*/
a272 1
/*ARGSUSED*/
a282 1
/*ARGSUSED*/
a300 1
/*ARGSUSED*/
d304 2
d310 1
a310 1
	sigdie("Timeout before authentication for %s", get_remote_ipaddr());
a342 1
/*ARGSUSED*/
a849 316
/* Accept a connection from inetd */
static void
server_accept_inetd(int *sock_in, int *sock_out)
{
	int fd;

	startup_pipe = -1;
	if (rexeced_flag) {
		close(REEXEC_CONFIG_PASS_FD);
		*sock_in = *sock_out = dup(STDIN_FILENO);
		if (!debug_flag) {
			startup_pipe = dup(REEXEC_STARTUP_PIPE_FD);
			close(REEXEC_STARTUP_PIPE_FD);
		}
	} else {
		*sock_in = dup(STDIN_FILENO);
		*sock_out = dup(STDOUT_FILENO);
	}
	/*
	 * We intentionally do not close the descriptors 0, 1, and 2
	 * as our code for setting the descriptors won't work if
	 * ttyfd happens to be one of those.
	 */
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		dup2(fd, STDIN_FILENO);
		dup2(fd, STDOUT_FILENO);
		if (fd > STDOUT_FILENO)
			close(fd);
	}
	debug("inetd sockets after dupping: %d, %d", *sock_in, *sock_out);
}

/*
 * Listen for TCP connections
 */
static void
server_listen(void)
{
	int ret, listen_sock, on = 1;
	struct addrinfo *ai;
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];

	for (ai = options.listen_addrs; ai; ai = ai->ai_next) {
		if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
			continue;
		if (num_listen_socks >= MAX_LISTEN_SOCKS)
			fatal("Too many listen sockets. "
			    "Enlarge MAX_LISTEN_SOCKS");
		if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,
		    ntop, sizeof(ntop), strport, sizeof(strport),
		    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
			error("getnameinfo failed: %.100s",
			    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
			    strerror(errno));
			continue;
		}
		/* Create socket for listening. */
		listen_sock = socket(ai->ai_family, ai->ai_socktype,
		    ai->ai_protocol);
		if (listen_sock < 0) {
			/* kernel may not support ipv6 */
			verbose("socket: %.100s", strerror(errno));
			continue;
		}
		if (set_nonblock(listen_sock) == -1) {
			close(listen_sock);
			continue;
		}
		/*
		 * Set socket options.
		 * Allow local port reuse in TIME_WAIT.
		 */
		if (setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR,
		    &on, sizeof(on)) == -1)
			error("setsockopt SO_REUSEADDR: %s", strerror(errno));

		debug("Bind to port %s on %s.", strport, ntop);

		/* Bind the socket to the desired port. */
		if (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) < 0) {
			error("Bind to port %s on %s failed: %.200s.",
			    strport, ntop, strerror(errno));
			close(listen_sock);
			continue;
		}
		listen_socks[num_listen_socks] = listen_sock;
		num_listen_socks++;

		/* Start listening on the port. */
		if (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)
			fatal("listen on [%s]:%s: %.100s",
			    ntop, strport, strerror(errno));
		logit("Server listening on %s port %s.", ntop, strport);
	}
	freeaddrinfo(options.listen_addrs);

	if (!num_listen_socks)
		fatal("Cannot bind any address.");
}

/*
 * The main TCP accept loop. Note that, for the non-debug case, returns
 * from this function are in a forked subprocess.
 */
static void
server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
{
	fd_set *fdset;
	int i, j, ret, maxfd;
	int key_used = 0, startups = 0;
	int startup_p[2] = { -1 , -1 };
	struct sockaddr_storage from;
	socklen_t fromlen;
	pid_t pid;

	/* setup fd set for accept */
	fdset = NULL;
	maxfd = 0;
	for (i = 0; i < num_listen_socks; i++)
		if (listen_socks[i] > maxfd)
			maxfd = listen_socks[i];
	/* pipes connected to unauthenticated childs */
	startup_pipes = xcalloc(options.max_startups, sizeof(int));
	for (i = 0; i < options.max_startups; i++)
		startup_pipes[i] = -1;

	/*
	 * Stay listening for connections until the system crashes or
	 * the daemon is killed with a signal.
	 */
	for (;;) {
		if (received_sighup)
			sighup_restart();
		if (fdset != NULL)
			xfree(fdset);
		fdset = (fd_set *)xcalloc(howmany(maxfd + 1, NFDBITS),
		    sizeof(fd_mask));

		for (i = 0; i < num_listen_socks; i++)
			FD_SET(listen_socks[i], fdset);
		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1)
				FD_SET(startup_pipes[i], fdset);

		/* Wait in select until there is a connection. */
		ret = select(maxfd+1, fdset, NULL, NULL, NULL);
		if (ret < 0 && errno != EINTR)
			error("select: %.100s", strerror(errno));
		if (received_sigterm) {
			logit("Received signal %d; terminating.",
			    (int) received_sigterm);
			close_listen_socks();
			unlink(options.pid_file);
			exit(255);
		}
		if (key_used && key_do_regen) {
			generate_ephemeral_server_key();
			key_used = 0;
			key_do_regen = 0;
		}
		if (ret < 0)
			continue;

		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1 &&
			    FD_ISSET(startup_pipes[i], fdset)) {
				/*
				 * the read end of the pipe is ready
				 * if the child has closed the pipe
				 * after successful authentication
				 * or if the child has died
				 */
				close(startup_pipes[i]);
				startup_pipes[i] = -1;
				startups--;
			}
		for (i = 0; i < num_listen_socks; i++) {
			if (!FD_ISSET(listen_socks[i], fdset))
				continue;
			fromlen = sizeof(from);
			*newsock = accept(listen_socks[i],
			    (struct sockaddr *)&from, &fromlen);
			if (*newsock < 0) {
				if (errno != EINTR && errno != EWOULDBLOCK)
					error("accept: %.100s", strerror(errno));
				continue;
			}
			if (unset_nonblock(*newsock) == -1) {
				close(*newsock);
				continue;
			}
			if (drop_connection(startups) == 1) {
				debug("drop connection #%d", startups);
				close(*newsock);
				continue;
			}
			if (pipe(startup_p) == -1) {
				close(*newsock);
				continue;
			}

			if (rexec_flag && socketpair(AF_UNIX,
			    SOCK_STREAM, 0, config_s) == -1) {
				error("reexec socketpair: %s",
				    strerror(errno));
				close(*newsock);
				close(startup_p[0]);
				close(startup_p[1]);
				continue;
			}

			for (j = 0; j < options.max_startups; j++)
				if (startup_pipes[j] == -1) {
					startup_pipes[j] = startup_p[0];
					if (maxfd < startup_p[0])
						maxfd = startup_p[0];
					startups++;
					break;
				}

			/*
			 * Got connection.  Fork a child to handle it, unless
			 * we are in debugging mode.
			 */
			if (debug_flag) {
				/*
				 * In debugging mode.  Close the listening
				 * socket, and start processing the
				 * connection without forking.
				 */
				debug("Server will not fork when running in debugging mode.");
				close_listen_socks();
				*sock_in = *newsock;
				*sock_out = *newsock;
				close(startup_p[0]);
				close(startup_p[1]);
				startup_pipe = -1;
				pid = getpid();
				if (rexec_flag) {
					send_rexec_state(config_s[0],
					    &cfg);
					close(config_s[0]);
				}
				break;
			}

			/*
			 * Normal production daemon.  Fork, and have
			 * the child process the connection. The
			 * parent continues listening.
			 */
			if ((pid = fork()) == 0) {
				/*
				 * Child.  Close the listening and
				 * max_startup sockets.  Start using
				 * the accepted socket. Reinitialize
				 * logging (since our pid has changed).
				 * We break out of the loop to handle
				 * the connection.
				 */
				startup_pipe = startup_p[1];
				close_startup_pipes();
				close_listen_socks();
				*sock_in = *newsock;
				*sock_out = *newsock;
				log_init(__progname,
				    options.log_level,
				    options.log_facility,
				    log_stderr);
				if (rexec_flag)
					close(config_s[0]);
				break;
			}

			/* Parent.  Stay in the loop. */
			if (pid < 0)
				error("fork: %.100s", strerror(errno));
			else
				debug("Forked child %ld.", (long)pid);

			close(startup_p[1]);

			if (rexec_flag) {
				send_rexec_state(config_s[0], &cfg);
				close(config_s[0]);
				close(config_s[1]);
			}

			/*
			 * Mark that the key has been used (it
			 * was "given" to the child).
			 */
			if ((options.protocol & SSH_PROTO_1) &&
			    key_used == 0) {
				/* Schedule server key regeneration alarm. */
				signal(SIGALRM, key_regeneration_alarm);
				alarm(options.key_regeneration_time);
				key_used = 1;
			}

			close(*newsock);

			/*
			 * Ensure that our random state differs
			 * from that of the child
			 */
			arc4random_stir();
		}

		/* child process check (or debug mode) */
		if (num_listen_socks < 0)
			break;
	}
}


d858 1
a858 1
	int opt, i, on = 1;
d860 4
d866 3
d870 3
a872 1
	int config_s[2] = { -1 , -1 };
d875 2
d930 1
a930 2
			options.server_key_bits = (int)strtonum(optarg, 256,
			    32768, NULL);
d967 1
a967 1
			utmp_len = (u_int)strtonum(optarg, 0, MAXHOSTNAMELEN+1, NULL);
d976 1
a976 1
			    "command-line", 0, NULL, NULL, NULL, NULL) != 0)
d1020 5
a1024 2
	parse_server_config(&options, rexeced_flag ? "rexec" : config_file_name,
	    &cfg, NULL, NULL, NULL);
d1041 1
a1041 1
	sensitive_data.host_keys = xcalloc(options.num_host_key_files,
d1107 1
d1110 1
a1110 1
		if (getpwnam(SSH_PRIVSEP_USER) == NULL)
d1127 1
a1127 1
		rexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));
d1147 1
d1149 1
a1149 1

d1154 1
d1160 1
d1175 1
a1175 1
	/* Get a connection, either from inetd or a listening TCP socket */
d1177 1
a1177 1
		server_accept_inetd(&sock_in, &sock_out);
d1179 24
d1207 56
a1262 1
		server_listen();
d1267 4
d1272 1
a1272 1
		signal(SIGCHLD, main_sigchld_handler);
d1276 4
a1279 4
		/*
		 * Write out the pid file after the sigterm handler
		 * is setup and the listen sockets are bound
		 */
d1281 8
a1288 2
			FILE *f = fopen(options.pid_file, "w");

d1298 188
a1485 3
		/* Accept a connection and return in a forked child */
		server_accept_loop(&sock_in, &sock_out,
		    &newsock, config_s);
d1572 1
a1572 7
	(void) get_canonical_hostname(0);
	/*
	 * The rest of the code depends on the fact that
	 * get_remote_ipaddr() caches the remote ip, even if
	 * the socket goes away.
	 */
	remote_ip = get_remote_ipaddr();
d1611 2
a1612 1
	authctxt = xcalloc(1, sizeof(*authctxt));
a1648 1
	authctxt->authenticated = 1;
d1687 1
a1687 2
	if (BN_cmp(sensitive_data.server_key->rsa->n,
	    sensitive_data.ssh1_host_key->rsa->n) > 0) {
d1690 2
a1691 4
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: "
			    "server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
d1706 2
a1707 4
		    BN_num_bits(sensitive_data.server_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: "
			    "host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
d1928 1
a1928 1

a1935 1
	kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
@


1.312.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshd.c,v 1.348 2006/11/06 21:25:28 markus Exp $ */
d1897 1
a1897 1
		(void) BN_mask_bits(session_key_int, sizeof(session_key) * 8);
d1900 1
a1900 1
			error("do_ssh1_kex: bad session key len from %s: "
@


1.311
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.310 2005/06/16 08:00:00 markus Exp $");
d665 6
d1560 1
d1909 1
a1909 1
	if (!options.compression) {
d1912 3
d1916 1
@


1.310
log
@don't exit if getpeername fails for forwarded ports; bugzilla #1054; ok djm
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.309 2005/04/06 09:43:59 djm Exp $");
d356 2
a357 1
	int i, mismatch;
d1815 1
a1815 1
		if (len < 0 || len > sizeof(session_key)) {
@


1.309
log
@avoid harmless logspam by not performing setsockopt() on non-socket; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.308 2005/02/08 22:24:57 dtucker Exp $");
d1559 4
a1562 1
	remote_port = get_remote_port();
@


1.308
log
@Provide reason in error message if getnameinfo fails; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.307 2005/01/21 08:32:02 otto Exp $");
a1547 6
	/* Set SO_KEEPALIVE if requested. */
	if (options.tcp_keep_alive &&
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on,
	    sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));

d1553 5
@


1.308.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.312 2005/07/25 11:59:40 markus Exp $");
d356 1
a356 2
	u_int i;
	int mismatch;
a663 6

	/*
	 * Tell the packet layer that authentication was successful, since
	 * this information is not part of the key state.
	 */
	packet_set_authenticated();
d1548 6
a1558 1
	packet_set_server();
d1560 1
a1560 9
	/* Set SO_KEEPALIVE if requested. */
	if (options.tcp_keep_alive && packet_connection_is_on_socket() &&
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));

	if ((remote_port = get_remote_port()) < 0) {
		debug("get_remote_port failed");
		cleanup_exit(255);
	}
d1812 1
a1812 1
		if (len < 0 || (u_int)len > sizeof(session_key)) {
d1899 1
a1899 1
	if (options.compression == COMP_NONE) {
a1901 3
	} else if (options.compression == COMP_DELAYED) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib@@openssh.com";
a1902 1
	
@


1.308.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.318 2005/12/24 02:27:41 djm Exp $");
d627 1
d629 8
a636 1
		goto skip;
a662 1
 skip:
a888 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d1571 1
a1571 6

	/*
	 * We use get_canonical_hostname with usedns = 0 instead of
	 * get_remote_ipaddr here so IP options will be checked.
	 */
	remote_ip = get_canonical_hostname(0);
d1594 1
a1594 1
	 * We don't want to listen forever unless the other side
d1597 1
a1597 1
	 * indicates no limit. Note that we don't set the alarm in debugging
a1641 11
	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);
	signal(SIGALRM, SIG_DFL);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}

@


1.307
log
@Warn in advance for password and account expiry; initialize loginmsg
buffer earlier and clear it after privsep fork. ok and help dtucker@@ markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.306 2005/01/17 22:48:39 dtucker Exp $");
d1210 1
a1210 1
			if (getnameinfo(ai->ai_addr, ai->ai_addrlen,
d1212 4
a1215 2
			    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
				error("getnameinfo failed");
@


1.306
log
@Make debugging output continue after reexec; ok djm@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.305 2004/12/23 23:11:00 djm Exp $");
d647 1
d1604 3
a1609 3

	/* prepare buffer to collect messages to display to user after login */
	buffer_init(&loginmsg);
@


1.305
log
@bz #898: support AddressFamily in sshd_config. from peak@@argo.troja.mff.cuni.cz
ok deraadt@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.304 2004/09/25 03:45:14 djm Exp $");
d1133 1
a1133 1
	if (debug_flag && !inetd_flag)
@


1.304
log
@these printf args are no longer double; ok deraadt@@ markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.303 2004/09/15 18:42:27 mickey Exp $");
a110 6
 * Flag indicating whether IPv4 or IPv6.  This can be set on the command line.
 * Default value is AF_UNSPEC means both IPv4 and IPv6.
 */
int IPv4or6 = AF_UNSPEC;

/*
d888 1
a888 1
			IPv4or6 = AF_INET;
d891 1
a891 1
			IPv4or6 = AF_INET6;
a991 1
	channel_set_af(IPv4or6);
d1024 3
@


1.303
log
@use less doubles in daemons; markus@@ ok
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.302 2004/08/28 01:01:48 djm Exp $");
d758 1
a758 1
	debug("drop_connection: p %g, r %g", p, r);
@


1.302
log
@don't erroneously close stdin for !reexec case, from Dave Johnson; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.301 2004/08/11 11:50:09 dtucker Exp $");
d743 1
a743 1
	double p, r;
d754 1
a754 1
	p /= (double) (options.max_startups - options.max_startups_begin);
d756 1
a756 2
	p /= 100.0;
	r = arc4random() / (double) UINT_MAX;
@


1.302.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.308 2005/02/08 22:24:57 dtucker Exp $");
d111 6
a652 1
		buffer_clear(&loginmsg);
d743 1
a743 1
	int p, r;
d754 1
a754 1
	p /= options.max_startups - options.max_startups_begin;
d756 2
a757 1
	r = arc4random() % 100;
d759 1
a759 1
	debug("drop_connection: p %d, r %d", p, r);
d895 1
a895 1
			options.address_family = AF_INET;
d898 1
a898 1
			options.address_family = AF_INET6;
d999 1
a1032 3
	/* set default channel AF */
	channel_set_af(options.address_family);

d1138 1
a1138 1
	if (debug_flag && (!inetd_flag || rexeced_flag))
d1214 1
a1214 1
			if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,
d1216 2
a1217 4
			    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
				error("getnameinfo failed: %.100s",
				    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
				    strerror(errno));
a1607 3
	/* prepare buffer to collect messages to display to user after login */
	buffer_init(&loginmsg);

d1611 3
@


1.302.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.312 2005/07/25 11:59:40 markus Exp $");
d356 1
a356 2
	u_int i;
	int mismatch;
a663 6

	/*
	 * Tell the packet layer that authentication was successful, since
	 * this information is not part of the key state.
	 */
	packet_set_authenticated();
d1548 6
a1558 1
	packet_set_server();
d1560 1
a1560 9
	/* Set SO_KEEPALIVE if requested. */
	if (options.tcp_keep_alive && packet_connection_is_on_socket() &&
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));

	if ((remote_port = get_remote_port()) < 0) {
		debug("get_remote_port failed");
		cleanup_exit(255);
	}
d1812 1
a1812 1
		if (len < 0 || (u_int)len > sizeof(session_key)) {
d1899 1
a1899 1
	if (options.compression == COMP_NONE) {
a1901 3
	} else if (options.compression == COMP_DELAYED) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none,zlib@@openssh.com";
a1902 1
	
@


1.301
log
@Don't try to close startup_pipe if it's not open; ok djm@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.300 2004/07/28 08:56:22 markus Exp $");
d877 1
a877 1
	int startup_p[2], config_s[2];
d1447 2
a1448 1
						close(config_s[0]);
@


1.300
log
@call setsid() _before_ re-exec
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.299 2004/07/17 05:31:41 dtucker Exp $");
d1511 2
a1512 1
		close(startup_pipe);
@


1.299
log
@Move "Last logged in at.." message generation to the monitor, right
before recording the new login.  Fixes missing lastlog message when
/var/log/lastlog is not world-readable and incorrect datestamp when
multiple sessions are used (bz #463);  much assistance & ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.298 2004/07/11 17:48:47 deraadt Exp $");
d1489 8
a1534 8

	/*
	 * Create a new session and process group since the 4.4BSD
	 * setlogin() affects the entire process group.  We don't
	 * want the child to be able to affect the parent.
	 */
	if (!debug_flag && !inetd_flag && setsid() < 0)
		error("setsid: %.100s", strerror(errno));
@


1.298
log
@spaces
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.297 2004/06/26 20:07:16 avsm Exp $");
d211 3
d1609 3
@


1.297
log
@initialise some fd variables to -1, djm@@ ok
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.296 2004/06/25 18:43:36 djm Exp $");
d794 1
a794 1
	if (sensitive_data.server_key != NULL && 
d1817 1
a1817 1
			    sensitive_data.ssh1_host_key->rsa->n, 
@


1.296
log
@fix broken fd handling in the re-exec fallback path, particularly when
/dev/crypto is in use; ok deraadt@@ markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.295 2004/06/25 01:16:09 djm Exp $");
d861 2
a862 1
	int opt, sock_in = 0, sock_out = 0, newsock, j, i, fdsetsz, on = 1;
@


1.295
log
@only perform tcp wrappers checks when the incoming connection is on a socket.
silences useless warnings from regress tests that use proxycommand="sshd -i"
prompted by david@@ ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.294 2004/06/24 19:30:54 djm Exp $");
d96 6
d990 3
a992 1
		closefrom(STDERR_FILENO + 3);
d1016 1
a1016 1
		recv_rexec_state(STDERR_FILENO + 2, &cfg);
d1178 1
a1178 1
			close(STDERR_FILENO + 2);
d1181 2
a1182 2
				startup_pipe = dup(STDERR_FILENO + 1);
				close(STDERR_FILENO + 1);
d1443 1
d1488 2
a1489 2
		debug("rexec newsock %d pipe %d sock %d", newsock, 
		    startup_pipe, config_s[0]);
d1493 1
a1493 1
			close(STDERR_FILENO + 1);
d1495 1
a1495 1
			dup2(startup_pipe, STDERR_FILENO + 1);
d1497 1
a1497 1
		dup2(config_s[1], STDERR_FILENO + 2);
d1499 2
d1505 1
a1505 1
		recv_rexec_state(STDERR_FILENO + 2, NULL);
d1510 1
d1512 2
a1513 2
		close(STDERR_FILENO + 1);
		close(STDERR_FILENO + 2);
d1520 2
@


1.294
log
@re-exec sshd on accept(); initial work, final debugging and ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.293 2004/06/14 01:44:39 djm Exp $");
d1547 1
a1547 1
	{
@


1.293
log
@set_nonblock() instead of fnctl(...,O_NONBLOCK); "looks sane" deraadt@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.292 2004/06/13 12:53:24 djm Exp $");
d64 1
d76 1
d133 6
d766 81
d867 1
a867 1
	int startup_p[2];
d872 1
d876 1
d882 1
a882 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:dDeiqtQ46")) != -1) {
d909 7
d979 7
d1000 17
a1016 2
	/* Read server configuration options from the configuration file. */
	read_server_config(&options, config_file_name);
a1033 4
	sensitive_data.server_key = NULL;
	sensitive_data.ssh1_host_key = NULL;
	sensitive_data.have_ssh1_key = 0;
	sensitive_data.have_ssh2_key = 0;
d1115 10
d1166 2
a1167 5
		int s1;
		s1 = dup(0);	/* Make sure descriptors 0, 1, and 2 are in use. */
		dup(s1);
		sock_in = dup(0);
		sock_out = dup(1);
d1169 11
d1182 1
a1182 1
		 * as our code for setting the descriptors won\'t work if
d1185 6
d1192 2
a1193 1
		if (options.protocol & SSH_PROTO_1)
d1372 10
d1405 2
d1409 5
d1447 6
d1475 34
@


1.292
log
@implement diffie-hellman-group14-sha1 kex method (trivial extension to
existing diffie-hellman-group1-sha1); ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.291 2004/05/09 01:19:28 djm Exp $");
d1075 1
a1075 2
			if (fcntl(listen_sock, F_SETFL, O_NONBLOCK) < 0) {
				error("listen_sock O_NONBLOCK: %s", strerror(errno));
d1217 1
a1217 2
				if (fcntl(newsock, F_SETFL, 0) < 0) {
					error("newsock del O_NONBLOCK: %s", strerror(errno));
@


1.291
log
@kill some more tiny files; ok deraadt@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.290 2004/03/11 10:21:17 markus Exp $");
d1691 1
@


1.290
log
@ssh, sshd: sync version output, ok djm
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.289 2004/03/11 08:36:26 markus Exp $");
a58 1
#include "mpaux.h"
d1605 4
a1608 3
			compute_session_id(session_id, cookie,
			    sensitive_data.ssh1_host_key->rsa->n,
			    sensitive_data.server_key->rsa->n);
@


1.290.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.301 2004/08/11 11:50:09 dtucker Exp $");
d59 1
a64 1
#include "bufaux.h"
a75 1
#include "msg.h"
a94 6
/* Re-exec fds */
#define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
#define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2)
#define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3)
#define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4)

a131 6
/* re-exec */
int rexeced_flag = 0;
int rexec_flag = 1;
int rexec_argc = 0;
char **rexec_argv;

a197 3
/* message to be displayed after login */
Buffer loginmsg;

a758 81
static void
send_rexec_state(int fd, Buffer *conf)
{
	Buffer m;

	debug3("%s: entering fd = %d config len %d", __func__, fd,
	    buffer_len(conf));

	/*
	 * Protocol from reexec master to child:
	 *	string	configuration
	 *	u_int	ephemeral_key_follows
	 *	bignum	e		(only if ephemeral_key_follows == 1)
	 *	bignum	n			"
	 *	bignum	d			"
	 *	bignum	iqmp			"
	 *	bignum	p			"
	 *	bignum	q			"
	 */
	buffer_init(&m);
	buffer_put_cstring(&m, buffer_ptr(conf));

	if (sensitive_data.server_key != NULL &&
	    sensitive_data.server_key->type == KEY_RSA1) {
		buffer_put_int(&m, 1);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->e);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->n);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->d);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->iqmp);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->p);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->q);
	} else
		buffer_put_int(&m, 0);

	if (ssh_msg_send(fd, 0, &m) == -1)
		fatal("%s: ssh_msg_send failed", __func__);

	buffer_free(&m);

	debug3("%s: done", __func__);
}

static void
recv_rexec_state(int fd, Buffer *conf)
{
	Buffer m;
	char *cp;
	u_int len;

	debug3("%s: entering fd = %d", __func__, fd);

	buffer_init(&m);

	if (ssh_msg_recv(fd, &m) == -1)
		fatal("%s: ssh_msg_recv failed", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: rexec version mismatch", __func__);

	cp = buffer_get_string(&m, &len);
	if (conf != NULL)
		buffer_append(conf, cp, len + 1);
	xfree(cp);

	if (buffer_get_int(&m)) {
		if (sensitive_data.server_key != NULL)
			key_free(sensitive_data.server_key);
		sensitive_data.server_key = key_new_private(KEY_RSA1);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->e);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->n);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->d);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->iqmp);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->p);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->q);
		rsa_generate_additional_parameters(
		    sensitive_data.server_key->rsa);
	}
	buffer_free(&m);

	debug3("%s: done", __func__);
}

d767 1
a767 2
	int opt, j, i, fdsetsz, on = 1;
	int sock_in = -1, sock_out = -1, newsock = -1;
d779 1
a779 1
	int startup_p[2], config_s[2];
a783 1
	Buffer cfg;
a786 1
	rexec_argc = ac;
d792 1
a792 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:dDeiqrtQR46")) != -1) {
a818 7
		case 'r':
			rexec_flag = 0;
			break;
		case 'R':
			rexeced_flag = 1;
			inetd_flag = 1;
			break;
a881 9
	if (rexeced_flag || inetd_flag)
		rexec_flag = 0;
	if (rexec_flag && (av[0] == NULL || *av[0] != '/'))
		fatal("sshd re-exec requires execution with an absolute path");
	if (rexeced_flag)
		closefrom(REEXEC_MIN_FREE_FD);
	else
		closefrom(REEXEC_DEVCRYPTO_RESERVED_FD);

d896 2
a897 17
	sensitive_data.server_key = NULL;
	sensitive_data.ssh1_host_key = NULL;
	sensitive_data.have_ssh1_key = 0;
	sensitive_data.have_ssh2_key = 0;

	/* Fetch our configuration */
	buffer_init(&cfg);
	if (rexeced_flag)
		recv_rexec_state(REEXEC_CONFIG_PASS_FD, &cfg);
	else
		load_server_config(config_file_name, &cfg);

	parse_server_config(&options,
	    rexeced_flag ? "rexec" : config_file_name, &cfg);

	if (!rexec_flag)
		buffer_free(&cfg);
d915 4
a999 10
	if (rexec_flag) {
		rexec_argv = xmalloc(sizeof(char *) * (rexec_argc + 2));
		for (i = 0; i < rexec_argc; i++) {
			debug("rexec_argv[%d]='%s'", i, saved_argv[i]);
			rexec_argv[i] = saved_argv[i];
		}
		rexec_argv[rexec_argc] = "-R";
		rexec_argv[rexec_argc + 1] = NULL;
	}

d1041 5
a1045 2
		int fd;

a1046 11
		if (rexeced_flag) {
			close(REEXEC_CONFIG_PASS_FD);
			sock_in = sock_out = dup(STDIN_FILENO);
			if (!debug_flag) {
				startup_pipe = dup(REEXEC_STARTUP_PIPE_FD);
				close(REEXEC_STARTUP_PIPE_FD);
			}
		} else {
			sock_in = dup(STDIN_FILENO);
			sock_out = dup(STDOUT_FILENO);
		}
d1049 1
a1049 1
		 * as our code for setting the descriptors won't work if
a1051 6
		if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			if (fd > STDOUT_FILENO)
				close(fd);
		}
d1053 1
a1053 2
		if ((options.protocol & SSH_PROTO_1) &&
		    sensitive_data.server_key == NULL)
d1076 2
a1077 1
			if (set_nonblock(listen_sock) == -1) {
d1219 2
a1220 1
				if (unset_nonblock(newsock) == -1) {
a1233 10
				if (rexec_flag && socketpair(AF_UNIX,
				    SOCK_STREAM, 0, config_s) == -1) {
					error("reexec socketpair: %s",
					    strerror(errno));
					close(newsock);
					close(startup_p[0]);
					close(startup_p[1]);
					continue;
				}

a1256 2
					close(startup_p[0]);
					close(startup_p[1]);
a1258 5
					if (rexec_flag) {
						send_rexec_state(config_s[0],
						    &cfg);
						close(config_s[0]);
					}
a1279 1
						close(config_s[0]);
a1291 6
				if (rexec_flag) {
					send_rexec_state(config_s[0], &cfg);
					close(config_s[0]);
					close(config_s[1]);
				}

a1322 40
	if (rexec_flag) {
		int fd;

		debug("rexec start in %d out %d newsock %d pipe %d sock %d",
		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
		dup2(newsock, STDIN_FILENO);
		dup2(STDIN_FILENO, STDOUT_FILENO);
		if (startup_pipe == -1)
			close(REEXEC_STARTUP_PIPE_FD);
		else
			dup2(startup_pipe, REEXEC_STARTUP_PIPE_FD);

		dup2(config_s[1], REEXEC_CONFIG_PASS_FD);
		close(config_s[1]);
		if (startup_pipe != -1)
			close(startup_pipe);

		execv(rexec_argv[0], rexec_argv);

		/* Reexec has failed, fall back and continue */
		error("rexec of %s failed: %s", rexec_argv[0], strerror(errno));
		recv_rexec_state(REEXEC_CONFIG_PASS_FD, NULL);
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);

		/* Clean up fds */
		startup_pipe = REEXEC_STARTUP_PIPE_FD;
		close(config_s[1]);
		close(REEXEC_CONFIG_PASS_FD);
		newsock = sock_out = sock_in = dup(STDIN_FILENO);
		if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			if (fd > STDERR_FILENO)
				close(fd);
		}
		debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d",
		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
	}

d1352 1
a1352 1
	if (packet_connection_is_on_socket()) {
a1396 3
	/* prepare buffer to collect messages to display to user after login */
	buffer_init(&loginmsg);

d1606 1
a1606 1
			derive_ssh1_session_id(
d1608 1
a1608 2
			    sensitive_data.server_key->rsa->n,
			    cookie, session_id);
a1690 1
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;
@


1.290.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.308 2005/02/08 22:24:57 dtucker Exp $");
d111 6
a652 1
		buffer_clear(&loginmsg);
d743 1
a743 1
	int p, r;
d754 1
a754 1
	p /= options.max_startups - options.max_startups_begin;
d756 2
a757 1
	r = arc4random() % 100;
d759 1
a759 1
	debug("drop_connection: p %d, r %d", p, r);
d877 1
a877 1
	int startup_p[2] = { -1 , -1 }, config_s[2] = { -1 , -1 };
d895 1
a895 1
			options.address_family = AF_INET;
d898 1
a898 1
			options.address_family = AF_INET6;
d999 1
a1032 3
	/* set default channel AF */
	channel_set_af(options.address_family);

d1138 1
a1138 1
	if (debug_flag && (!inetd_flag || rexeced_flag))
d1214 1
a1214 1
			if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,
d1216 2
a1217 4
			    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
				error("getnameinfo failed: %.100s",
				    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
				    strerror(errno));
d1447 1
a1447 2
						if (rexec_flag)
							close(config_s[0]);
a1606 3
	/* prepare buffer to collect messages to display to user after login */
	buffer_init(&loginmsg);

d1610 3
@


1.289
log
@trim usage; ok deraadt
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.288 2004/03/03 06:47:52 markus Exp $");
d750 1
a750 1
	fprintf(stderr, "sshd version %s, %s\n",
@


1.288
log
@change proctiltle after accept(2); ok henning, deraadt, djm
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.287 2004/02/25 00:22:45 djm Exp $");
d752 4
a755 18
	fprintf(stderr, "Usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -f file    Configuration file (default %s)\n", _PATH_SERVER_CONFIG_FILE);
	fprintf(stderr, "  -d         Debugging mode (multiple -d means more debugging)\n");
	fprintf(stderr, "  -i         Started from inetd\n");
	fprintf(stderr, "  -D         Do not fork into daemon mode\n");
	fprintf(stderr, "  -t         Only test configuration file and keys\n");
	fprintf(stderr, "  -q         Quiet (no logging)\n");
	fprintf(stderr, "  -p port    Listen on the specified port (default: 22)\n");
	fprintf(stderr, "  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
	fprintf(stderr, "  -g seconds Grace period for authentication (default: 600)\n");
	fprintf(stderr, "  -b bits    Size of server RSA key (default: 768 bits)\n");
	fprintf(stderr, "  -h file    File from which to read host key (default: %s)\n",
	    _PATH_HOST_KEY_FILE);
	fprintf(stderr, "  -u len     Maximum hostname length for utmp recording\n");
	fprintf(stderr, "  -4         Use IPv4 only\n");
	fprintf(stderr, "  -6         Use IPv6 only\n");
	fprintf(stderr, "  -o option  Process the option as if it was read from a configuration file.\n");
@


1.287
log
@typo in comment
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.286 2004/02/23 12:02:33 markus Exp $");
d1327 1
@


1.286
log
@backout revision 1.279; set listen socket to non-block; ok henning.
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.285 2004/02/05 05:37:17 dtucker Exp $");
d558 1
a558 1
	/* XXX not ready, to heavy after chroot */
@


1.285
log
@Pass SIGALRM through to privsep child if LoginGraceTime expires.  ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.284 2003/12/09 21:53:37 markus Exp $");
d1090 5
d1231 5
@


1.284
log
@rename keepalive to tcpkeepalive; the old name causes too much
confusion; ok djm, dtucker; with help from jmc@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.283 2003/12/09 17:29:04 markus Exp $");
d193 1
a193 1
struct monitor *pmonitor;
d296 3
d586 1
@


1.283
log
@fix -o and HUP; ok henning@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.282 2003/12/02 17:01:15 markus Exp $");
d1334 2
a1335 2
	/* Set keepalives if requested. */
	if (options.keepalives &&
@


1.282
log
@use SSH_LISTEN_BACKLOG (=128) in listen(2).
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.281 2003/11/10 16:23:41 jakob Exp $");
d787 1
d880 2
a881 1
			if (process_server_config_line(&options, optarg,
d884 1
@


1.281
log
@constify. ok markus@@ & djm@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.280 2003/10/02 10:41:59 markus Exp $");
d1105 1
a1105 1
			if (listen(listen_sock, 5) < 0)
@


1.280
log
@print openssl version, too, several requests; ok henning/djm.
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.279 2003/09/26 08:19:29 markus Exp $");
d655 2
a656 1
	char *p;
d675 1
a675 1
	p = xstrdup(buffer_ptr(&b));
d677 2
a678 2
	debug("list_hostkey_types: %s", p);
	return p;
@


1.279
log
@no need to set the listen sockets to non-block; ok deraadt@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.278 2003/09/23 20:17:11 markus Exp $");
d745 2
a746 1
	fprintf(stderr, "sshd version %s\n", SSH_VERSION);
@


1.278
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.277 2003/09/19 11:33:09 markus Exp $");
a1080 5
			if (fcntl(listen_sock, F_SETFL, O_NONBLOCK) < 0) {
				error("listen_sock O_NONBLOCK: %s", strerror(errno));
				close(listen_sock);
				continue;
			}
a1216 5
					continue;
				}
				if (fcntl(newsock, F_SETFL, 0) < 0) {
					error("newsock del O_NONBLOCK: %s", strerror(errno));
					close(newsock);
@


1.277
log
@do not call packet_close on fatal; ok deraadt
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.276 2003/08/28 12:54:34 markus Exp $");
d195 3
d369 1
a369 1
		fatal_cleanup();
d378 1
a378 1
			fatal_cleanup();
d408 1
a408 1
		fatal_cleanup();
d418 1
a418 1
		fatal_cleanup();
d424 1
a424 1
		fatal_cleanup();
d470 1
a470 1
		fatal_cleanup();
d565 2
a566 2
static Authctxt *
privsep_preauth(void)
a567 1
	Authctxt *authctxt = NULL;
d583 1
a583 1
		authctxt = monitor_child_preauth(pmonitor);
d593 1
a593 1
		return (authctxt);
d604 1
a604 1
	return (NULL);
a609 5
	extern Authctxt *x_authctxt;

	/* XXX - Remote port forwarding */
	x_authctxt = authctxt;

d788 1
a789 1
	Key *key;
d1390 7
d1398 1
a1398 1
		if ((authctxt = privsep_preauth()) != NULL)
d1405 1
a1405 1
		authctxt = do_authentication2();
d1408 1
a1408 1
		authctxt = do_authentication();
d1431 1
a1431 1
	/* Perform session preparation. */
d1717 9
@


1.276
log
@remove kerberos support from ssh1, since it has been replaced with GSSAPI;
but keep kerberos passwd auth for ssh1 and 2; ok djm, hin, henning, ...
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.275 2003/08/13 08:46:31 markus Exp $");
a577 2
		fatal_remove_cleanup((void (*) (void *)) packet_close, NULL);

a590 4

		/* Reinstall, since the child has finished */
		fatal_add_cleanup((void (*) (void *)) packet_close, NULL);

a633 2
		fatal_remove_cleanup((void (*) (void *)) packet_close, NULL);

@


1.276.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.286 2004/02/23 12:02:33 markus Exp $");
d193 1
a193 4
struct monitor *pmonitor = NULL;

/* global authentication context */
Authctxt *the_authctxt = NULL;
a292 3
	if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)
		kill(pmonitor->m_pid, SIGALRM);

d366 1
a366 1
		cleanup_exit(255);
d375 1
a375 1
			cleanup_exit(255);
d405 1
a405 1
		cleanup_exit(255);
d415 1
a415 1
		cleanup_exit(255);
d421 1
a421 1
		cleanup_exit(255);
d467 1
a467 1
		cleanup_exit(255);
d562 2
a563 2
static int
privsep_preauth(Authctxt *authctxt)
d565 1
d578 2
d583 1
a583 2
		pmonitor->m_pid = pid;
		monitor_child_preauth(authctxt, pmonitor);
d593 5
a597 1
		return (1);
d608 1
a608 1
	return (0);
d614 5
d640 2
d666 1
a666 2
	const char *p;
	char *ret;
d685 1
a685 1
	ret = xstrdup(buffer_ptr(&b));
d687 2
a688 2
	debug("list_hostkey_types: %s", ret);
	return ret;
d756 1
a756 2
	fprintf(stderr, "sshd version %s, %s\n",
	    SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
a795 1
	char *line;
d799 1
a800 1
	Authctxt *authctxt;
d888 1
a888 2
			line = xstrdup(optarg);
			if (process_server_config_line(&options, line,
a890 1
			xfree(line);
d1119 1
a1119 1
			if (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)
d1350 2
a1351 2
	/* Set SO_KEEPALIVE if requested. */
	if (options.tcp_keep_alive &&
a1400 7
	/* allocate authentication context */
	authctxt = xmalloc(sizeof(*authctxt));
	memset(authctxt, 0, sizeof(*authctxt));

	/* XXX global for cleanup, access from other modules */
	the_authctxt = authctxt;

d1402 1
a1402 1
		if (privsep_preauth(authctxt) == 1)
d1409 1
a1409 1
		do_authentication2(authctxt);
d1412 1
a1412 1
		do_authentication(authctxt);
d1435 1
a1435 1
	/* Start session. */
a1720 9
}

/* server specific fatal cleanup */
void
cleanup_exit(int i)
{
	if (the_authctxt)
		do_cleanup(the_authctxt);
	_exit(i);
@


1.276.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.301 2004/08/11 11:50:09 dtucker Exp $");
d59 1
a64 1
#include "bufaux.h"
a75 1
#include "msg.h"
a94 6
/* Re-exec fds */
#define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
#define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2)
#define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3)
#define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4)

a131 6
/* re-exec */
int rexeced_flag = 0;
int rexec_flag = 1;
int rexec_argc = 0;
char **rexec_argv;

a197 3
/* message to be displayed after login */
Buffer loginmsg;

d558 1
a558 1
	/* XXX not ready, too heavy after chroot */
d750 1
a750 1
	fprintf(stderr, "%s, %s\n",
d752 18
a769 4
	fprintf(stderr,
"usage: sshd [-46Ddeiqt] [-b bits] [-f config_file] [-g login_grace_time]\n"
"            [-h host_key_file] [-k key_gen_time] [-o option] [-p port] [-u len]\n"
	);
a772 81
static void
send_rexec_state(int fd, Buffer *conf)
{
	Buffer m;

	debug3("%s: entering fd = %d config len %d", __func__, fd,
	    buffer_len(conf));

	/*
	 * Protocol from reexec master to child:
	 *	string	configuration
	 *	u_int	ephemeral_key_follows
	 *	bignum	e		(only if ephemeral_key_follows == 1)
	 *	bignum	n			"
	 *	bignum	d			"
	 *	bignum	iqmp			"
	 *	bignum	p			"
	 *	bignum	q			"
	 */
	buffer_init(&m);
	buffer_put_cstring(&m, buffer_ptr(conf));

	if (sensitive_data.server_key != NULL &&
	    sensitive_data.server_key->type == KEY_RSA1) {
		buffer_put_int(&m, 1);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->e);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->n);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->d);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->iqmp);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->p);
		buffer_put_bignum(&m, sensitive_data.server_key->rsa->q);
	} else
		buffer_put_int(&m, 0);

	if (ssh_msg_send(fd, 0, &m) == -1)
		fatal("%s: ssh_msg_send failed", __func__);

	buffer_free(&m);

	debug3("%s: done", __func__);
}

static void
recv_rexec_state(int fd, Buffer *conf)
{
	Buffer m;
	char *cp;
	u_int len;

	debug3("%s: entering fd = %d", __func__, fd);

	buffer_init(&m);

	if (ssh_msg_recv(fd, &m) == -1)
		fatal("%s: ssh_msg_recv failed", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: rexec version mismatch", __func__);

	cp = buffer_get_string(&m, &len);
	if (conf != NULL)
		buffer_append(conf, cp, len + 1);
	xfree(cp);

	if (buffer_get_int(&m)) {
		if (sensitive_data.server_key != NULL)
			key_free(sensitive_data.server_key);
		sensitive_data.server_key = key_new_private(KEY_RSA1);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->e);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->n);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->d);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->iqmp);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->p);
		buffer_get_bignum(&m, sensitive_data.server_key->rsa->q);
		rsa_generate_additional_parameters(
		    sensitive_data.server_key->rsa);
	}
	buffer_free(&m);

	debug3("%s: done", __func__);
}

d781 1
a781 2
	int opt, j, i, fdsetsz, on = 1;
	int sock_in = -1, sock_out = -1, newsock = -1;
d793 1
a793 1
	int startup_p[2], config_s[2];
a797 1
	Buffer cfg;
a800 1
	rexec_argc = ac;
d806 1
a806 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:dDeiqrtQR46")) != -1) {
a832 7
		case 'r':
			rexec_flag = 0;
			break;
		case 'R':
			rexeced_flag = 1;
			inetd_flag = 1;
			break;
a895 9
	if (rexeced_flag || inetd_flag)
		rexec_flag = 0;
	if (rexec_flag && (av[0] == NULL || *av[0] != '/'))
		fatal("sshd re-exec requires execution with an absolute path");
	if (rexeced_flag)
		closefrom(REEXEC_MIN_FREE_FD);
	else
		closefrom(REEXEC_DEVCRYPTO_RESERVED_FD);

d910 2
a911 17
	sensitive_data.server_key = NULL;
	sensitive_data.ssh1_host_key = NULL;
	sensitive_data.have_ssh1_key = 0;
	sensitive_data.have_ssh2_key = 0;

	/* Fetch our configuration */
	buffer_init(&cfg);
	if (rexeced_flag)
		recv_rexec_state(REEXEC_CONFIG_PASS_FD, &cfg);
	else
		load_server_config(config_file_name, &cfg);

	parse_server_config(&options,
	    rexeced_flag ? "rexec" : config_file_name, &cfg);

	if (!rexec_flag)
		buffer_free(&cfg);
d929 4
a1013 10
	if (rexec_flag) {
		rexec_argv = xmalloc(sizeof(char *) * (rexec_argc + 2));
		for (i = 0; i < rexec_argc; i++) {
			debug("rexec_argv[%d]='%s'", i, saved_argv[i]);
			rexec_argv[i] = saved_argv[i];
		}
		rexec_argv[rexec_argc] = "-R";
		rexec_argv[rexec_argc + 1] = NULL;
	}

d1055 5
a1059 2
		int fd;

a1060 11
		if (rexeced_flag) {
			close(REEXEC_CONFIG_PASS_FD);
			sock_in = sock_out = dup(STDIN_FILENO);
			if (!debug_flag) {
				startup_pipe = dup(REEXEC_STARTUP_PIPE_FD);
				close(REEXEC_STARTUP_PIPE_FD);
			}
		} else {
			sock_in = dup(STDIN_FILENO);
			sock_out = dup(STDOUT_FILENO);
		}
d1063 1
a1063 1
		 * as our code for setting the descriptors won't work if
a1065 6
		if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			if (fd > STDOUT_FILENO)
				close(fd);
		}
d1067 1
a1067 2
		if ((options.protocol & SSH_PROTO_1) &&
		    sensitive_data.server_key == NULL)
d1090 2
a1091 1
			if (set_nonblock(listen_sock) == -1) {
d1233 2
a1234 1
				if (unset_nonblock(newsock) == -1) {
a1247 10
				if (rexec_flag && socketpair(AF_UNIX,
				    SOCK_STREAM, 0, config_s) == -1) {
					error("reexec socketpair: %s",
					    strerror(errno));
					close(newsock);
					close(startup_p[0]);
					close(startup_p[1]);
					continue;
				}

a1270 2
					close(startup_p[0]);
					close(startup_p[1]);
a1272 5
					if (rexec_flag) {
						send_rexec_state(config_s[0],
						    &cfg);
						close(config_s[0]);
					}
a1293 1
						close(config_s[0]);
a1305 6
				if (rexec_flag) {
					send_rexec_state(config_s[0], &cfg);
					close(config_s[0]);
					close(config_s[1]);
				}

a1326 1
	setproctitle("%s", "[accepted]");
a1335 40
	if (rexec_flag) {
		int fd;

		debug("rexec start in %d out %d newsock %d pipe %d sock %d",
		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
		dup2(newsock, STDIN_FILENO);
		dup2(STDIN_FILENO, STDOUT_FILENO);
		if (startup_pipe == -1)
			close(REEXEC_STARTUP_PIPE_FD);
		else
			dup2(startup_pipe, REEXEC_STARTUP_PIPE_FD);

		dup2(config_s[1], REEXEC_CONFIG_PASS_FD);
		close(config_s[1]);
		if (startup_pipe != -1)
			close(startup_pipe);

		execv(rexec_argv[0], rexec_argv);

		/* Reexec has failed, fall back and continue */
		error("rexec of %s failed: %s", rexec_argv[0], strerror(errno));
		recv_rexec_state(REEXEC_CONFIG_PASS_FD, NULL);
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);

		/* Clean up fds */
		startup_pipe = REEXEC_STARTUP_PIPE_FD;
		close(config_s[1]);
		close(REEXEC_CONFIG_PASS_FD);
		newsock = sock_out = sock_in = dup(STDIN_FILENO);
		if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			if (fd > STDERR_FILENO)
				close(fd);
		}
		debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d",
		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
	}

d1365 1
a1365 1
	if (packet_connection_is_on_socket()) {
a1409 3
	/* prepare buffer to collect messages to display to user after login */
	buffer_init(&loginmsg);

d1619 1
a1619 1
			derive_ssh1_session_id(
d1621 1
a1621 2
			    sensitive_data.server_key->rsa->n,
			    cookie, session_id);
a1703 1
	kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;
@


1.275
log
@remove RhostsAuthentication; suggested by djm@@ before; ok djm@@, deraadt@@,
fgsch@@, miod@@, henning@@, jakob@@ and others
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.274 2003/07/22 13:35:22 markus Exp $");
a1398 8
#ifdef KRB5
	if (!packet_connection_is_ipv4() &&
	    options.kerberos_authentication) {
		debug("Kerberos Authentication disabled, only available for IPv4.");
		options.kerberos_authentication = 0;
	}
#endif

a1552 6
#ifdef KRB5
	if (options.kerberos_authentication)
		auth_mask |= 1 << SSH_AUTH_KERBEROS;
	if (options.kerberos_tgt_passing)
		auth_mask |= 1 << SSH_PASS_KERBEROS_TGT;
#endif
@


1.274
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.273 2003/07/16 10:34:53 markus Exp $");
d1398 1
a1398 14
	/*
	 * Check that the connection comes from a privileged port.
	 * Rhosts-Authentication only makes sense from privileged
	 * programs.  Of course, if the intruder has root access on his local
	 * machine, he can connect from any port.  So do not use these
	 * authentication methods from machines that you do not trust.
	 */
	if (options.rhosts_authentication &&
	    (remote_port >= IPPORT_RESERVED ||
	    remote_port < IPPORT_RESERVED / 2)) {
		debug("Rhosts Authentication disabled, "
		    "originating port %d not trusted.", remote_port);
		options.rhosts_authentication = 0;
	}
a1556 2
	if (options.rhosts_authentication)
		auth_mask |= 1 << SSH_AUTH_RHOSTS;
@


1.273
log
@don't exit on multiple -v or -d; ok deraadt@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.272 2003/07/14 12:36:37 markus Exp $");
d1412 1
a1412 1
#if defined(KRB4) && !defined(KRB5)
d1418 1
a1418 8
#endif /* KRB4 && !KRB5 */
#ifdef AFS
	/* If machine has AFS, set process authentication group. */
	if (k_hasafs()) {
		k_setpag();
		k_unlog();
	}
#endif /* AFS */
d1576 1
a1576 1
#if defined(KRB4) || defined(KRB5)
a1578 2
#endif
#if defined(AFS) || defined(KRB5)
a1580 4
#endif
#ifdef AFS
	if (options.afs_token_passing)
		auth_mask |= 1 << SSH_PASS_AFS_TOKEN;
@


1.272
log
@remove undocumented -V option. would be only useful if openssh is used
as ssh v1 server for ssh.com's ssh v2.
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.271 2003/06/28 16:23:06 deraadt Exp $");
d822 1
a822 1
			if (0 == debug_flag) {
d825 1
a825 1
			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3) {
a826 4
			} else {
				fprintf(stderr, "Too high debugging level.\n");
				exit(1);
			}
@


1.271
log
@deal with typing of write vs read in atomicio
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.270 2003/06/28 07:48:10 djm Exp $");
d361 14
a374 6
	if (client_version_string == NULL) {
		/* Send our protocol version identification. */
		if (atomicio(vwrite, sock_out, server_version_string,
		    strlen(server_version_string))
		    != strlen(server_version_string)) {
			logit("Could not write ident string to %s", get_remote_ipaddr());
d377 5
a381 19

		/* Read other sides version identification. */
		memset(buf, 0, sizeof(buf));
		for (i = 0; i < sizeof(buf) - 1; i++) {
			if (atomicio(read, sock_in, &buf[i], 1) != 1) {
				logit("Did not receive identification string from %s",
				    get_remote_ipaddr());
				fatal_cleanup();
			}
			if (buf[i] == '\r') {
				buf[i] = 0;
				/* Kludge for F-Secure Macintosh < 1.0.2 */
				if (i == 12 &&
				    strncmp(buf, "SSH-1.5-W1.0", 12) == 0)
					break;
				continue;
			}
			if (buf[i] == '\n') {
				buf[i] = 0;
d383 5
a387 1
			}
a388 2
		buf[sizeof(buf) - 1] = 0;
		client_version_string = xstrdup(buf);
d390 2
d810 1
a810 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:o:dDeiqtQ46")) != -1) {
a879 5
			break;
		case 'V':
			client_version_string = optarg;
			/* only makes sense with inetd_flag, i.e. no listen() */
			inetd_flag = 1;
@


1.270
log
@report pidfile creation errors, based on patch from Roumen Petrov; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.269 2003/06/24 08:23:46 markus Exp $");
d363 1
a363 1
		if (atomicio(write, sock_out, server_version_string,
d402 1
a402 1
		(void) atomicio(write, sock_out, s, strlen(s));
d463 1
a463 1
		(void) atomicio(write, sock_out, s, strlen(s));
@


1.269
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.268 2003/06/04 10:23:48 djm Exp $");
d1164 4
a1167 1
			if (f) {
@


1.268
log
@remove duplicated group-dropping code; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.267 2003/05/29 16:58:45 deraadt Exp $");
d182 1
a182 1
int session_id2_len = 0;
@


1.267
log
@seteuid and setegid; markus ok
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.266 2003/05/24 09:30:40 djm Exp $");
a557 4
	if (setegid(pw->pw_gid) < 0)
		fatal("setegid failed for %u", (u_int)pw->pw_gid);
	if (setgid(pw->pw_gid) < 0)
		fatal("setgid failed for %u", (u_int)pw->pw_gid);
@


1.266
log
@cast some types for printing; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.265 2003/04/14 14:17:50 markus Exp $");
d558 2
d561 1
a561 1
		fatal("setgid failed for %u", (u_int)pw->pw_gid );
@


1.265
log
@avoid hardcoded SOCK_xx; with itojun@@; should allow ssh over SCTP
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.264 2003/04/08 20:21:29 itojun Exp $");
d559 1
a559 1
		fatal("setgid failed for %u", pw->pw_gid );
@


1.264
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.263 2003/02/16 17:09:57 markus Exp $");
d1098 2
a1099 1
			listen_sock = socket(ai->ai_family, SOCK_STREAM, 0);
@


1.263
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.262 2003/01/27 17:06:31 markus Exp $");
d248 1
a248 1
	log("Received SIGHUP; restarting.");
d252 1
a252 1
	log("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0],
d366 1
a366 1
			log("Could not write ident string to %s", get_remote_ipaddr());
d374 1
a374 1
				log("Did not receive identification string from %s",
d405 1
a405 1
		log("Bad protocol version identification '%.100s' from %s",
d415 1
a415 1
		log("probed from %s with %s.  Don't panic.",
d421 1
a421 1
		log("scanned from %s with %s.  Don't panic.",
d466 1
a466 1
		log("Protocol major versions differ for %s: %.200s vs. %.200s",
d972 1
a972 1
		log("Disabling protocol version 1. Could not load host key");
d976 1
a976 1
		log("Disabling protocol version 2. Could not load host key");
d980 1
a980 1
		log("sshd: no hostkeys available -- exiting.");
d1130 1
a1130 1
			log("Server listening on %s port %s.", ntop, strport);
d1206 1
a1206 1
				log("Received signal %d; terminating.",
d1681 1
a1681 1
		log("do_connection: generating a fake encryption key");
@


1.263.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.276 2003/08/28 12:54:34 markus Exp $");
d182 1
a182 1
u_int session_id2_len = 0;
d248 1
a248 1
	logit("Received SIGHUP; restarting.");
d252 1
a252 1
	logit("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0],
d361 6
a366 14
	/* Send our protocol version identification. */
	if (atomicio(vwrite, sock_out, server_version_string,
	    strlen(server_version_string))
	    != strlen(server_version_string)) {
		logit("Could not write ident string to %s", get_remote_ipaddr());
		fatal_cleanup();
	}

	/* Read other sides version identification. */
	memset(buf, 0, sizeof(buf));
	for (i = 0; i < sizeof(buf) - 1; i++) {
		if (atomicio(read, sock_in, &buf[i], 1) != 1) {
			logit("Did not receive identification string from %s",
			    get_remote_ipaddr());
d369 19
a387 5
		if (buf[i] == '\r') {
			buf[i] = 0;
			/* Kludge for F-Secure Macintosh < 1.0.2 */
			if (i == 12 &&
			    strncmp(buf, "SSH-1.5-W1.0", 12) == 0)
d389 1
a389 5
			continue;
		}
		if (buf[i] == '\n') {
			buf[i] = 0;
			break;
d391 2
a393 2
	buf[sizeof(buf) - 1] = 0;
	client_version_string = xstrdup(buf);
d402 1
a402 1
		(void) atomicio(vwrite, sock_out, s, strlen(s));
d405 1
a405 1
		logit("Bad protocol version identification '%.100s' from %s",
d415 1
a415 1
		logit("probed from %s with %s.  Don't panic.",
d421 1
a421 1
		logit("scanned from %s with %s.  Don't panic.",
d463 1
a463 1
		(void) atomicio(vwrite, sock_out, s, strlen(s));
d466 1
a466 1
		logit("Protocol major versions differ for %s: %.200s vs. %.200s",
d558 2
d814 1
a814 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:dDeiqtQ46")) != -1) {
d826 1
a826 1
			if (debug_flag == 0) {
d829 1
a829 1
			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3)
d831 4
d885 5
d972 1
a972 1
		logit("Disabling protocol version 1. Could not load host key");
d976 1
a976 1
		logit("Disabling protocol version 2. Could not load host key");
d980 1
a980 1
		logit("sshd: no hostkeys available -- exiting.");
d1098 1
a1098 2
			listen_sock = socket(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol);
d1130 1
a1130 1
			logit("Server listening on %s port %s.", ntop, strport);
d1165 1
a1165 4
			if (f == NULL) {
				error("Couldn't create pid file \"%s\": %s",
				    options.pid_file, strerror(errno));
			} else {
d1206 1
a1206 1
				logit("Received signal %d; terminating.",
d1407 28
d1586 2
d1592 12
d1681 1
a1681 1
		logit("do_connection: generating a fake encryption key");
@


1.263.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.286 2004/02/23 12:02:33 markus Exp $");
d193 1
a193 4
struct monitor *pmonitor = NULL;

/* global authentication context */
Authctxt *the_authctxt = NULL;
a292 3
	if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)
		kill(pmonitor->m_pid, SIGALRM);

d366 1
a366 1
		cleanup_exit(255);
d375 1
a375 1
			cleanup_exit(255);
d405 1
a405 1
		cleanup_exit(255);
d415 1
a415 1
		cleanup_exit(255);
d421 1
a421 1
		cleanup_exit(255);
d467 1
a467 1
		cleanup_exit(255);
d562 2
a563 2
static int
privsep_preauth(Authctxt *authctxt)
d565 1
d578 2
d583 1
a583 2
		pmonitor->m_pid = pid;
		monitor_child_preauth(authctxt, pmonitor);
d593 5
a597 1
		return (1);
d608 1
a608 1
	return (0);
d614 5
d640 2
d666 1
a666 2
	const char *p;
	char *ret;
d685 1
a685 1
	ret = xstrdup(buffer_ptr(&b));
d687 2
a688 2
	debug("list_hostkey_types: %s", ret);
	return ret;
d756 1
a756 2
	fprintf(stderr, "sshd version %s, %s\n",
	    SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
a795 1
	char *line;
d799 1
a800 1
	Authctxt *authctxt;
d888 1
a888 2
			line = xstrdup(optarg);
			if (process_server_config_line(&options, line,
a890 1
			xfree(line);
d1119 1
a1119 1
			if (listen(listen_sock, SSH_LISTEN_BACKLOG) < 0)
d1350 2
a1351 2
	/* Set SO_KEEPALIVE if requested. */
	if (options.tcp_keep_alive &&
a1400 7
	/* allocate authentication context */
	authctxt = xmalloc(sizeof(*authctxt));
	memset(authctxt, 0, sizeof(*authctxt));

	/* XXX global for cleanup, access from other modules */
	the_authctxt = authctxt;

d1402 1
a1402 1
		if (privsep_preauth(authctxt) == 1)
d1409 1
a1409 1
		do_authentication2(authctxt);
d1412 1
a1412 1
		do_authentication(authctxt);
d1435 1
a1435 1
	/* Start session. */
a1720 9
}

/* server specific fatal cleanup */
void
cleanup_exit(int i)
{
	if (the_authctxt)
		do_cleanup(the_authctxt);
	_exit(i);
@


1.262
log
@more specific error message when /var/empty has wrong permissions;
bug #46, map@@appgate.com; ok henning@@, provos@@, stevesk@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.261 2002/11/07 16:28:47 markus Exp $");
d192 2
a193 2
extern struct monitor *pmonitor;
extern int use_privsep;
d1749 2
@


1.261
log
@log to stderr if -ie is given, bug #414, prj@@po.cwru.edu
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.260 2002/09/27 10:42:09 mickey Exp $");
d1021 2
a1022 2
			fatal("Bad owner or mode for %s",
			    _PATH_PRIVSEP_CHROOT_DIR);
@


1.260
log
@add a generic match for a prober, such as sie big brother; idea from stevesk@@; markus@@ ok
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.259 2002/09/25 15:19:02 markus Exp $");
d923 1
a923 1
	    !inetd_flag);
@


1.260.2.1
log
@Update to OpenSSH 3.6
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.263 2003/02/16 17:09:57 markus Exp $");
d192 2
a193 2
int use_privsep;
struct monitor *pmonitor;
d923 1
a923 1
	    log_stderr || !inetd_flag);
d1021 2
a1022 2
			fatal("%s must be owned by root and not group or "
			    "world-writable.", _PATH_PRIVSEP_CHROOT_DIR);
a1748 2
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;
@


1.260.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.276 2003/08/28 12:54:34 markus Exp $");
d182 1
a182 1
u_int session_id2_len = 0;
d248 1
a248 1
	logit("Received SIGHUP; restarting.");
d252 1
a252 1
	logit("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0],
d361 6
a366 14
	/* Send our protocol version identification. */
	if (atomicio(vwrite, sock_out, server_version_string,
	    strlen(server_version_string))
	    != strlen(server_version_string)) {
		logit("Could not write ident string to %s", get_remote_ipaddr());
		fatal_cleanup();
	}

	/* Read other sides version identification. */
	memset(buf, 0, sizeof(buf));
	for (i = 0; i < sizeof(buf) - 1; i++) {
		if (atomicio(read, sock_in, &buf[i], 1) != 1) {
			logit("Did not receive identification string from %s",
			    get_remote_ipaddr());
d369 19
a387 5
		if (buf[i] == '\r') {
			buf[i] = 0;
			/* Kludge for F-Secure Macintosh < 1.0.2 */
			if (i == 12 &&
			    strncmp(buf, "SSH-1.5-W1.0", 12) == 0)
d389 1
a389 5
			continue;
		}
		if (buf[i] == '\n') {
			buf[i] = 0;
			break;
d391 2
a393 2
	buf[sizeof(buf) - 1] = 0;
	client_version_string = xstrdup(buf);
d402 1
a402 1
		(void) atomicio(vwrite, sock_out, s, strlen(s));
d405 1
a405 1
		logit("Bad protocol version identification '%.100s' from %s",
d415 1
a415 1
		logit("probed from %s with %s.  Don't panic.",
d421 1
a421 1
		logit("scanned from %s with %s.  Don't panic.",
d463 1
a463 1
		(void) atomicio(vwrite, sock_out, s, strlen(s));
d466 1
a466 1
		logit("Protocol major versions differ for %s: %.200s vs. %.200s",
d558 2
d814 1
a814 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:u:o:dDeiqtQ46")) != -1) {
d826 1
a826 1
			if (debug_flag == 0) {
d829 1
a829 1
			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3)
d831 4
d885 5
d972 1
a972 1
		logit("Disabling protocol version 1. Could not load host key");
d976 1
a976 1
		logit("Disabling protocol version 2. Could not load host key");
d980 1
a980 1
		logit("sshd: no hostkeys available -- exiting.");
d1098 1
a1098 2
			listen_sock = socket(ai->ai_family, ai->ai_socktype,
			    ai->ai_protocol);
d1130 1
a1130 1
			logit("Server listening on %s port %s.", ntop, strport);
d1165 1
a1165 4
			if (f == NULL) {
				error("Couldn't create pid file \"%s\": %s",
				    options.pid_file, strerror(errno));
			} else {
d1206 1
a1206 1
				logit("Received signal %d; terminating.",
d1407 28
d1586 2
d1592 12
d1681 1
a1681 1
		logit("do_connection: generating a fake encryption key");
@


1.259
log
@typo; pilot@@monkey.org
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.258 2002/09/13 19:23:09 stevesk Exp $");
d413 6
@


1.258
log
@remove use of SO_LINGER, it should not be needed. error check
SO_REUSEADDR. fixup comments. ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.257 2002/07/23 16:03:10 stevesk Exp $");
d294 1
a294 1
	fatal("Timeout before authentication for %s.", get_remote_ipaddr());
@


1.257
log
@utmp_len is unsigned; display error consistent with other options.
ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.256 2002/07/19 15:43:33 markus Exp $");
a791 1
	struct linger linger;
d1104 2
a1105 4
			 * Set socket options.  We try to make the port
			 * reusable and have it close as fast as possible
			 * without waiting in unnecessary wait states on
			 * close.
d1107 3
a1109 6
			setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR,
			    &on, sizeof(on));
			linger.l_onoff = 1;
			linger.l_linger = 5;
			setsockopt(listen_sock, SOL_SOCKET, SO_LINGER,
			    &linger, sizeof(linger));
a1351 10

	/*
	 * Set socket options for the connection.  We want the socket to
	 * close as fast as possible without waiting for anything.  If the
	 * connection is not a socket, these will do nothing.
	 */
	/* setsockopt(sock_in, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on)); */
	linger.l_onoff = 1;
	linger.l_linger = 5;
	setsockopt(sock_in, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
@


1.256
log
@remove fatal cleanups after fork; based on discussions with and code
from solar.
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.255 2002/06/30 21:59:45 deraadt Exp $");
d890 4
a893 2
			if (utmp_len < 0 || utmp_len > MAXHOSTNAMELEN)
				usage();
@


1.255
log
@minor KNF
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.254 2002/06/30 21:54:16 deraadt Exp $");
a292 3
	/* Close the connection. */
	packet_close();

d576 2
d591 4
d638 2
@


1.254
log
@lint asks that we use names that do not overlap
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.253 2002/06/28 23:05:06 deraadt Exp $");
d540 1
a540 1
	/* Change our root directory*/
d563 1
a563 1
static Authctxt*
d928 2
a929 1
	sensitive_data.host_keys = xmalloc(options.num_host_key_files*sizeof(Key*));
@


1.253
log
@gidset[2] -> gidset[1]; markus ok
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.252 2002/06/28 10:08:25 deraadt Exp $");
d310 1
a310 1
	u_int32_t rand = 0;
d323 3
a325 3
			rand = arc4random();
		sensitive_data.ssh1_cookie[i] = rand & 0xff;
		rand >>= 8;
d519 1
a519 1
	u_int32_t rand[256];
d528 2
a529 2
		rand[i] = arc4random();
	RAND_seed(rand, sizeof(rand));
d1543 1
a1543 1
	u_int32_t rand = 0;
d1556 3
a1558 3
			rand = arc4random();
		cookie[i] = rand & 0xff;
		rand >>= 8;
@


1.252
log
@range check -u option at invocation
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.251 2002/06/25 18:51:04 markus Exp $");
d520 1
a520 1
	gid_t gidset[2];
@


1.251
log
@lightweight do_setusercontext after chroot()
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.250 2002/06/23 10:29:52 deraadt Exp $");
d885 2
@


1.250
log
@some minor KNF and %u
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.249 2002/06/23 03:30:17 deraadt Exp $");
d520 1
d550 2
d553 8
@


1.249
log
@various KNF and %d for unsigned
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.248 2002/06/22 20:05:27 stevesk Exp $");
d209 1
d219 1
d252 2
a253 1
	log("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0], strerror(errno));
d273 1
a274 1
	int save_errno = errno;
d334 1
d520 1
a521 1
	struct passwd *pw;
d677 1
d698 1
d971 4
a974 3
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) - SSH_KEY_BITS_RESERVED &&
		    options.server_key_bits <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
d976 2
a977 1
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED;
@


1.248
log
@don't call setsid() if debugging or run from inetd; no "Operation not
permitted" errors now; ok millert@@ markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.247 2002/06/22 16:40:19 stevesk Exp $");
d362 2
a363 1
		if (atomicio(write, sock_out, server_version_string, strlen(server_version_string))
a464 1

@


1.247
log
@check /var/empty owner mode; ok provos@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.246 2002/06/20 23:05:56 markus Exp $");
d1315 1
a1315 1
	if (setsid() < 0)
@


1.246
log
@allow Compression=yes/no in sshd_config
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.245 2002/06/11 05:46:20 mpech Exp $");
d985 3
@


1.245
log
@pid_t cleanup. Markus need this now to keep hacking.
markus@@, millert@@ ok

Note: big usr.bin/ cleanup is comming. Now I'm waiting Ok from espie@@ for
make/.
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.244 2002/05/29 11:21:57 markus Exp $");
d1718 4
@


1.244
log
@don't start if privsep is enabled and SSH_PRIVSEP_USER or
_PATH_PRIVSEP_CHROOT_DIR are missing; ok deraadt@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.243 2002/05/22 23:18:25 deraadt Exp $");
d564 1
a564 1
		debug2("Network child is on pid %d", pid);
d620 1
a620 1
		debug2("User child is on pid %d", pmonitor->m_pid);
d1134 1
a1134 1
				fprintf(f, "%u\n", (u_int) getpid());
d1281 1
a1281 1
					debug("Forked child %d.", pid);
@


1.243
log
@spelling; abishoff@@arc.nasa.gov
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.242 2002/05/15 15:47:49 mouring Exp $");
d973 13
@


1.242
log
@'monitor' variable clashes with at least one lame platform (NeXT).  Renamed
to 'pmonitor'.  provos@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.241 2002/05/13 15:53:19 millert Exp $");
d368 1
a368 1
		/* Read other side's version identification. */
d1374 1
a1374 1
	 * Rhosts-Authentication only makes sense from priviledged
d1679 1
a1679 1
	/* Send an acknowledgement packet.  Note that this packet is sent encrypted. */
@


1.241
log
@Call setsid() in the child after sshd accepts the connection and forks.
This is needed for privsep which calls setlogin() when it changes uids.
Without this, there is a race where the login name of an existing connection,
as returned by getlogin(), may be changed to the privsep user (sshd).
markus@@ OK
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.240 2002/04/23 22:16:29 djm Exp $");
d192 1
a192 1
extern struct monitor *monitor;
d556 1
a556 1
	monitor = monitor_init();
d558 1
a558 1
	monitor->m_pkex = &xxx_kex;
d566 3
a568 3
		close(monitor->m_recvfd);
		authctxt = monitor_child_preauth(monitor);
		close(monitor->m_sendfd);
d571 1
a571 1
		monitor_sync(monitor);
d581 1
a581 1
		close(monitor->m_sendfd);
d601 1
a601 1
		monitor_apply_keystate(monitor);
d614 1
a614 1
	monitor_reinit(monitor);
d616 2
a617 2
	monitor->m_pid = fork();
	if (monitor->m_pid == -1)
d619 4
a622 4
	else if (monitor->m_pid != 0) {
		debug2("User child is on pid %d", monitor->m_pid);
		close(monitor->m_recvfd);
		monitor_child_postauth(monitor);
d628 1
a628 1
	close(monitor->m_sendfd);
d637 1
a637 1
	monitor_apply_keystate(monitor);
d1421 1
a1421 1
		mm_send_keystate(monitor);
@


1.240
log
@Improve error message; ok markus@@ stevesk@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.239 2002/03/30 18:51:15 markus Exp $");
d1293 8
@


1.239
log
@check waitpid for EINTR; based on patch from peter@@ifm.liu.se
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.238 2002/03/23 20:57:26 stevesk Exp $");
d530 2
a531 1
		fatal("%s: no user", SSH_PRIVSEP_USER);
@


1.239.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.242 2002/05/15 15:47:49 mouring Exp $");
d192 1
a192 1
extern struct monitor *pmonitor;
d530 1
a530 2
		fatal("Privilege separation user %s does not exist",
		    SSH_PRIVSEP_USER);
d555 1
a555 1
	pmonitor = monitor_init();
d557 1
a557 1
	pmonitor->m_pkex = &xxx_kex;
d565 3
a567 3
		close(pmonitor->m_recvfd);
		authctxt = monitor_child_preauth(pmonitor);
		close(pmonitor->m_sendfd);
d570 1
a570 1
		monitor_sync(pmonitor);
d580 1
a580 1
		close(pmonitor->m_sendfd);
d600 1
a600 1
		monitor_apply_keystate(pmonitor);
d613 1
a613 1
	monitor_reinit(pmonitor);
d615 2
a616 2
	pmonitor->m_pid = fork();
	if (pmonitor->m_pid == -1)
d618 4
a621 4
	else if (pmonitor->m_pid != 0) {
		debug2("User child is on pid %d", pmonitor->m_pid);
		close(pmonitor->m_recvfd);
		monitor_child_postauth(pmonitor);
d627 1
a627 1
	close(pmonitor->m_sendfd);
d636 1
a636 1
	monitor_apply_keystate(pmonitor);
a1293 8
	 * Create a new session and process group since the 4.4BSD
	 * setlogin() affects the entire process group.  We don't
	 * want the child to be able to affect the parent.
	 */
	if (setsid() < 0)
		error("setsid: %.100s", strerror(errno));

	/*
d1412 1
a1412 1
		mm_send_keystate(pmonitor);
@


1.239.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.239.2.3
log
@Pull in OpenSSH-3.4
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.251 2002/06/25 18:51:04 markus Exp $");
a208 1

a217 1

d250 1
a250 2
	log("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0],
	    strerror(errno));
d270 1
a271 1
	pid_t pid;
a330 1

d362 1
a362 2
		if (atomicio(write, sock_out, server_version_string,
		    strlen(server_version_string))
d368 1
a368 1
		/* Read other sides version identification. */
d465 1
d516 1
a516 1
	gid_t gidset[2];
a517 1
	int i;
a544 2
#if 0
	/* XXX not ready, to heavy after chroot */
a545 8
#else
	gidset[0] = pw->pw_gid;
	if (setgid(pw->pw_gid) < 0)
		fatal("setgid failed for %u", pw->pw_gid );
	if (setgroups(1, gidset) < 0)
		fatal("setgroups: %.100s", strerror(errno));
	permanently_set_uid(pw);
#endif
d564 1
a564 1
		debug2("Network child is on pid %ld", (long)pid);
d620 1
a620 1
		debug2("User child is on pid %ld", (long)pmonitor->m_pid);
a672 1

a692 1

d965 3
a967 4
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) -
		    SSH_KEY_BITS_RESERVED && options.server_key_bits <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
d969 1
a969 2
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
			    SSH_KEY_BITS_RESERVED;
a974 16
	if (use_privsep) {
		struct passwd *pw;
		struct stat st;

		if ((pw = getpwnam(SSH_PRIVSEP_USER)) == NULL)
			fatal("Privilege separation user %s does not exist",
			    SSH_PRIVSEP_USER);
		if ((stat(_PATH_PRIVSEP_CHROOT_DIR, &st) == -1) ||
		    (S_ISDIR(st.st_mode) == 0))
			fatal("Missing privilege separation directory: %s",
			    _PATH_PRIVSEP_CHROOT_DIR);
		if (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)
			fatal("Bad owner or mode for %s",
			    _PATH_PRIVSEP_CHROOT_DIR);
	}

d1121 1
a1121 1
				fprintf(f, "%ld\n", (long) getpid());
d1268 1
a1268 1
					debug("Forked child %ld.", (long)pid);
d1299 1
a1299 1
	if (!debug_flag && !inetd_flag && setsid() < 0)
d1374 1
a1374 1
	 * Rhosts-Authentication only makes sense from privileged
d1679 1
a1679 1
	/* Send an acknowledgment packet.  Note that this packet is sent encrypted. */
a1704 4
	}
	if (!options.compression) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
@


1.239.2.4
log
@Update to OpenSSH 3.5
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.260 2002/09/27 10:42:09 mickey Exp $");
d293 3
d297 1
a297 1
	fatal("Timeout before authentication for %s", get_remote_ipaddr());
d310 1
a310 1
	u_int32_t rnd = 0;
d323 3
a325 3
			rnd = arc4random();
		sensitive_data.ssh1_cookie[i] = rnd & 0xff;
		rnd >>= 8;
a416 6
	if (datafellows & SSH_BUG_PROBE) {
		log("probed from %s with %s.  Don't panic.",
		    get_remote_ipaddr(), client_version_string);
		fatal_cleanup();
	}

d519 2
a520 2
	u_int32_t rnd[256];
	gid_t gidset[1];
d528 2
a529 2
		rnd[i] = arc4random();
	RAND_seed(rnd, sizeof(rnd));
d540 1
a540 1
	/* Change our root directory */
d563 1
a563 1
static Authctxt *
a578 2
		fatal_remove_cleanup((void (*) (void *)) packet_close, NULL);

a591 4

		/* Reinstall, since the child has finished */
		fatal_add_cleanup((void (*) (void *)) packet_close, NULL);

a634 2
		fatal_remove_cleanup((void (*) (void *)) packet_close, NULL);

d787 1
a884 4
			if (utmp_len > MAXHOSTNAMELEN) {
				fprintf(stderr, "Invalid utmp length.\n");
				exit(1);
			}
d926 1
a926 2
	sensitive_data.host_keys = xmalloc(options.num_host_key_files *
	    sizeof(Key *));
d1095 4
a1098 2
			 * Set socket options.
			 * Allow local port reuse in TIME_WAIT.
d1100 6
a1105 3
			if (setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR,
			    &on, sizeof(on)) == -1)
				error("setsockopt SO_REUSEADDR: %s", strerror(errno));
d1349 10
d1541 1
a1541 1
	u_int32_t rnd = 0;
d1554 3
a1556 3
			rnd = arc4random();
		cookie[i] = rnd & 0xff;
		rnd >>= 8;
@


1.239.2.5
log
@Merge OpenSSH 3.6.1
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.263 2003/02/16 17:09:57 markus Exp $");
d192 2
a193 2
int use_privsep;
struct monitor *pmonitor;
d923 1
a923 1
	    log_stderr || !inetd_flag);
d1021 2
a1022 2
			fatal("%s must be owned by root and not group or "
			    "world-writable.", _PATH_PRIVSEP_CHROOT_DIR);
a1748 2
	kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;
	kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;
@


1.238
log
@setproctitle() after preauth child; ok markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.237 2002/03/21 21:23:34 markus Exp $");
d270 1
d274 2
a275 1
	while (waitpid(-1, &status, WNOHANG) > 0)
d573 3
a575 2
		waitpid(pid, &status, 0);

@


1.237
log
@add privsep_preauth() and remove 1 goto; ok provos@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.236 2002/03/20 21:08:08 stevesk Exp $");
d582 1
@


1.236
log
@strerror() on chdir() fail; ok provos@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.235 2002/03/20 19:12:25 stevesk Exp $");
d545 41
d587 1
a587 1
privsep_postauth(Authctxt *authctxt, pid_t pid)
a589 4
	int status;

	/* Wait for the child's exit status */
	waitpid(pid, &status, 0);
d615 1
a615 1
		debug2("User child is on pid %d", pid);
a634 1

d1390 3
a1392 30
	if (!use_privsep)
		goto skip_privilegeseparation;

	/* Set up unprivileged child process to deal with network data */
	monitor = monitor_init();
	/* Store a pointer to the kex for later rekeying */
	monitor->m_pkex = &xxx_kex;

	pid = fork();
	if (pid == -1)
		fatal("fork of unprivileged child failed");
	else if (pid != 0) {
		debug2("Network child is on pid %d", pid);

		close(monitor->m_recvfd);
		authctxt = monitor_child_preauth(monitor);
		close(monitor->m_sendfd);

		/* Sync memory */
		monitor_sync(monitor);
		goto authenticated;
	} else {
		close(monitor->m_sendfd);

		/* Demote the child */
		if (getuid() == 0 || geteuid() == 0)
			privsep_preauth_child();
	}

 skip_privilegeseparation:
d1403 5
a1407 1
	if (use_privsep)
a1408 3

	/* If we use privilege separation, the unprivileged child exits */
	if (use_privsep)
d1410 1
d1418 2
a1419 1
		privsep_postauth(authctxt, pid);
@


1.235
log
@for unprivileged user, group do:
pw=getpwnam(SSH_PRIVSEP_USER); do_setusercontext(pw).  ok provos@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.234 2002/03/19 10:49:35 markus Exp $");
d537 1
a537 1
		fatal("chdir(/)");
@


1.234
log
@KNF whitespace
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.233 2002/03/19 10:35:39 markus Exp $");
d515 1
d527 5
d540 3
a542 4
	setegid(options.unprivileged_group);
	setgid(options.unprivileged_group);
	seteuid(options.unprivileged_user);
	setuid(options.unprivileged_user);
@


1.233
log
@clean up prototypes
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.232 2002/03/19 03:03:43 stevesk Exp $");
d532 1
a532 1
		
d558 1
a558 1
	
d1351 1
a1351 1
		
d1397 1
a1397 1
	/* 
@


1.232
log
@_PATH_PRIVSEP_CHROOT_DIR; ok provos@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.231 2002/03/18 17:50:31 provos Exp $");
d510 1
a510 1
void
d540 1
a540 1
void
@


1.231
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.228 2002/02/27 21:23:13 stevesk Exp $");
d527 3
a529 2
	if (chroot(options.unprivileged_dir) == -1)
		fatal("chroot(/var/empty)");
@


1.230
log
@have the authentication functions return the authentication context
and then do_authenticated; okay millert@@
@
text
@d18 1
d20 2
a21 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.229 2002/03/14 16:38:26 markus Exp $");
d50 1
d79 4
d191 4
d197 1
d484 109
d622 1
a622 1
static Key *
d634 19
d1348 31
d1388 17
d1412 4
d1423 1
a1423 1
static int
d1579 2
a1580 1
	rsafail = ssh1_session_key(session_key_int);
d1631 1
a1631 1
	/* Destroy the private and public keys.  They will no longer be needed. */
d1634 3
d1683 1
@


1.229
log
@split out ssh1 session key decryption; ok provos@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.228 2002/02/27 21:23:13 stevesk Exp $");
d75 1
d589 1
d1212 1
a1212 1
		do_authentication2();
d1215 1
a1215 1
		do_authentication();
d1217 4
@


1.228
log
@remove unneeded casts in [gs]etsockopt(); ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.227 2002/02/24 16:09:52 stevesk Exp $");
d1222 44
d1380 2
a1381 37
	/*
	 * Decrypt it using our private server key and private host key (key
	 * with larger modulus first).
	 */
	if (BN_cmp(sensitive_data.server_key->rsa->n, sensitive_data.ssh1_host_key->rsa->n) > 0) {
		/* Server key has bigger modulus. */
		if (BN_num_bits(sensitive_data.server_key->rsa->n) <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) <= 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) <= 0)
			rsafail++;
	} else {
		/* Host key has bigger modulus (or they are equal). */
		if (BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) <
		    BN_num_bits(sensitive_data.server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) < 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) < 0)
			rsafail++;
	}
@


1.227
log
@use u_char* here; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.226 2002/02/11 16:19:39 markus Exp $");
d877 1
a877 1
			    (void *) &on, sizeof(on));
d881 1
a881 1
			    (void *) &linger, sizeof(linger));
d1125 1
a1125 1
	setsockopt(sock_in, SOL_SOCKET, SO_LINGER, (void *) &linger, sizeof(linger));
d1129 1
a1129 1
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
@


1.226
log
@include md5.h not hmac.h
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.225 2002/02/11 16:17:55 markus Exp $");
d1404 1
a1404 1
		char *buf = xmalloc(bytes);
@


1.225
log
@do not complain about port > 1024 if rhosts-auth is disabled
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.224 2002/02/04 12:15:25 markus Exp $");
d47 1
a47 1
#include <openssl/hmac.h>
@


1.224
log
@add SYSLOG_FACILITY_NOT_SET = -1, SYSLOG_LEVEL_NOT_SET = -1,
fixes arm/netbsd; based on patch from bjh21@@netbsd.org; ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.223 2002/01/13 17:57:37 markus Exp $");
d1182 3
a1184 2
	if (remote_port >= IPPORT_RESERVED ||
	    remote_port < IPPORT_RESERVED / 2) {
@


1.223
log
@use buffer API and avoid static strings of fixed size; ok provos@@/mouring@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.222 2001/12/28 14:50:54 markus Exp $");
d699 4
a702 2
	    options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
	    options.log_facility == -1 ? SYSLOG_FACILITY_AUTH : options.log_facility,
@


1.222
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.221 2001/12/28 13:57:33 markus Exp $");
d474 2
a475 1
	static char buf[1024];
d477 2
a478 1
	buf[0] = '\0';
d486 4
a489 2
			strlcat(buf, key_ssh_name(key), sizeof buf);
			strlcat(buf, ",", sizeof buf);
d493 5
a497 5
	i = strlen(buf);
	if (i > 0 && buf[i-1] == ',')
		buf[i-1] = '\0';
	debug("list_hostkey_types: %s", buf);
	return buf;
@


1.221
log
@packet_get_bignum* no longer returns a size
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.220 2001/12/28 12:14:27 markus Exp $");
a1220 1
	int plen;
d1304 1
a1304 1
	packet_read_expect(&plen, SSH_CMSG_SESSION_KEY);
@


1.220
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.219 2001/12/27 20:39:58 markus Exp $");
d1221 1
a1221 1
	int plen, slen;
d1324 1
a1324 1
	packet_get_bignum(session_key_int, &slen);
@


1.219
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.218 2001/12/27 18:22:16 markus Exp $");
d1328 1
a1328 1
	packet_done();
@


1.218
log
@call fatal() for openssl allocation failures
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.217 2001/12/19 07:18:56 deraadt Exp $");
d1328 1
a1328 2

	packet_integrity_check(plen, 1 + 8 + slen + 4, SSH_CMSG_SESSION_KEY);
@


1.217
log
@basic KNF done while i was looking for something else
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.216 2001/12/10 16:45:04 stevesk Exp $");
d1322 2
a1323 1
	session_key_int = BN_new();
@


1.216
log
@possible fd leak on error; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.215 2001/12/06 13:30:06 markus Exp $");
d393 1
a393 1
	      remote_major, remote_minor, remote_version);
d461 1
a461 1
	for(i = 0; i < options.num_host_key_files; i++) {
d477 1
a477 1
	for(i = 0; i < options.num_host_key_files; i++) {
d500 1
a500 1
	for(i = 0; i < options.num_host_key_files; i++) {
d677 1
a677 1
                        if (process_server_config_line(&options, optarg,
d679 1
a679 1
                                exit(1);
d715 1
a715 1
	for(i = 0; i < options.num_host_key_files; i++)
d722 1
a722 1
	for(i = 0; i < options.num_host_key_files; i++) {
d819 1
a819 1
	
@


1.215
log
@add -o to sshd, too. ok deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.214 2001/12/05 10:06:13 deraadt Exp $");
d1006 1
@


1.214
log
@minor KNF
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.213 2001/12/05 03:50:01 itojun Exp $");
d537 25
d594 1
a594 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDeiqtQ46")) != -1) {
d676 5
d683 2
a684 19
			fprintf(stderr, "sshd version %s\n", SSH_VERSION);
			fprintf(stderr, "Usage: %s [options]\n", __progname);
			fprintf(stderr, "Options:\n");
			fprintf(stderr, "  -f file    Configuration file (default %s)\n", _PATH_SERVER_CONFIG_FILE);
			fprintf(stderr, "  -d         Debugging mode (multiple -d means more debugging)\n");
			fprintf(stderr, "  -i         Started from inetd\n");
			fprintf(stderr, "  -D         Do not fork into daemon mode\n");
			fprintf(stderr, "  -t         Only test configuration file and keys\n");
			fprintf(stderr, "  -q         Quiet (no logging)\n");
			fprintf(stderr, "  -p port    Listen on the specified port (default: 22)\n");
			fprintf(stderr, "  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
			fprintf(stderr, "  -g seconds Grace period for authentication (default: 600)\n");
			fprintf(stderr, "  -b bits    Size of server RSA key (default: 768 bits)\n");
			fprintf(stderr, "  -h file    File from which to read host key (default: %s)\n",
			    _PATH_HOST_KEY_FILE);
			fprintf(stderr, "  -u len     Maximum hostname length for utmp recording\n");
			fprintf(stderr, "  -4         Use IPv4 only\n");
			fprintf(stderr, "  -6         Use IPv6 only\n");
			exit(1);
@


1.213
log
@deal with LP64 printf issue with sig_atomic_t.  from thorpej
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.212 2001/11/22 12:34:22 markus Exp $");
d404 1
a404 1
	switch(remote_major) {
d481 1
a481 1
		switch(key->type) {
d718 1
a718 1
		switch(key->type){
@


1.212
log
@volatile sig_atomic_t
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.211 2001/11/19 11:20:21 markus Exp $");
d954 1
a954 1
				    received_sigterm);
@


1.211
log
@fd leak on HUP; ok stevesk@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.210 2001/11/14 20:45:08 deraadt Exp $");
d163 1
a163 1
int key_do_regen = 0;
d166 2
a167 2
int received_sighup = 0;
int received_sigterm = 0;
@


1.210
log
@errno saving wrapping in a signal handler
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.209 2001/11/10 13:19:45 markus Exp $");
d179 4
d201 10
d235 1
a536 3
int *startup_pipes = NULL;	/* options.max_startup sized array of fd ints */
int startup_pipe;		/* in child */

d1046 1
a1046 3
						for (j = 0; j < options.max_startups; j++)
							if (startup_pipes[j] != -1)
								close(startup_pipes[j]);
@


1.209
log
@cleanup libwrap support (remove bogus comment, bogus close(), add debug, etc).
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.208 2001/11/09 19:08:35 markus Exp $");
d205 2
d209 1
@


1.208
log
@remove extra trailing dot from log message; pilot@@naughty.monkey.org
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.207 2001/10/24 08:41:41 markus Exp $");
d1109 1
a1110 2
#ifdef LIBWRAP
	/* XXX LIBWRAP noes not know about IPv6 */
d1118 1
d1120 2
a1121 2
			close(sock_in);
			close(sock_out);
a1122 1
/*XXX IPv6 verbose("Connection from %.500s port %d", eval_client(&req), remote_port); */
d1125 1
@


1.207
log
@mention remote port in debug message
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.206 2001/10/02 22:56:09 stevesk Exp $");
d331 1
a331 1
			log("Could not write ident string to %s.", get_remote_ipaddr());
d339 1
a339 1
				log("Did not receive identification string from %s.",
@


1.206
log
@#include "channels.h" for channel_set_af()
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.205 2001/10/01 21:38:53 markus Exp $");
d1152 1
a1152 1
		    "originating port not trusted.");
@


1.206.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.209 2001/11/10 13:19:45 markus Exp $");
d331 1
a331 1
			log("Could not write ident string to %s", get_remote_ipaddr());
d339 1
a339 1
				log("Did not receive identification string from %s",
d1109 1
d1111 1
a1111 1
	/* Check whether logins are denied from this host. */
a1118 1
			debug("Connection refused by tcp wrapper");
d1120 2
a1121 2
			/* NOTREACHED */
			fatal("libwrap refuse returns");
d1123 1
a1125 1

d1152 1
a1152 1
		    "originating port %d not trusted.", remote_port);
@


1.206.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.228 2002/02/27 21:23:13 stevesk Exp $");
d47 1
a47 1
#include <openssl/md5.h>
d163 1
a163 1
static volatile sig_atomic_t key_do_regen = 0;
d166 2
a167 2
static volatile sig_atomic_t received_sighup = 0;
static volatile sig_atomic_t received_sigterm = 0;
a178 4
/* options.max_startup sized array of fd ints */
int *startup_pipes = NULL;
int startup_pipe;		/* in child */

a196 10
static void
close_startup_pipes(void)
{
	int i;
	if (startup_pipes)
		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1)
				close(startup_pipes[i]);
}

a204 2
	int save_errno = errno;

a206 1
	errno = save_errno;
a217 1
	close_startup_pipes();
d375 1
a375 1
	    remote_major, remote_minor, remote_version);
d386 1
a386 1
	switch (remote_major) {
d443 1
a443 1
	for (i = 0; i < options.num_host_key_files; i++) {
d456 1
a456 2
	Buffer b;
	char *p;
d458 2
a459 3

	buffer_init(&b);
	for (i = 0; i < options.num_host_key_files; i++) {
d463 1
a463 1
		switch (key->type) {
d466 2
a467 4
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			p = key_ssh_name(key);
			buffer_append(&b, p, strlen(p));
d471 5
a475 5
	buffer_append(&b, "\0", 1);
	p = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
	debug("list_hostkey_types: %s", p);
	return p;
d482 1
a482 1
	for (i = 0; i < options.num_host_key_files; i++) {
d519 2
a520 24
static void
usage(void)
{
	fprintf(stderr, "sshd version %s\n", SSH_VERSION);
	fprintf(stderr, "Usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -f file    Configuration file (default %s)\n", _PATH_SERVER_CONFIG_FILE);
	fprintf(stderr, "  -d         Debugging mode (multiple -d means more debugging)\n");
	fprintf(stderr, "  -i         Started from inetd\n");
	fprintf(stderr, "  -D         Do not fork into daemon mode\n");
	fprintf(stderr, "  -t         Only test configuration file and keys\n");
	fprintf(stderr, "  -q         Quiet (no logging)\n");
	fprintf(stderr, "  -p port    Listen on the specified port (default: 22)\n");
	fprintf(stderr, "  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
	fprintf(stderr, "  -g seconds Grace period for authentication (default: 600)\n");
	fprintf(stderr, "  -b bits    Size of server RSA key (default: 768 bits)\n");
	fprintf(stderr, "  -h file    File from which to read host key (default: %s)\n",
	    _PATH_HOST_KEY_FILE);
	fprintf(stderr, "  -u len     Maximum hostname length for utmp recording\n");
	fprintf(stderr, "  -4         Use IPv4 only\n");
	fprintf(stderr, "  -6         Use IPv6 only\n");
	fprintf(stderr, "  -o option  Process the option as if it was read from a configuration file.\n");
	exit(1);
}
d554 1
a554 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:o:dDeiqtQ46")) != -1) {
a635 5
		case 'o':
			if (process_server_config_line(&options, optarg,
			    "command-line", 0) != 0)
				exit(1);
			break;
d638 19
a656 2
			usage();
			break;
d667 2
a668 4
	    options.log_level == SYSLOG_LEVEL_NOT_SET ?
	    SYSLOG_LEVEL_INFO : options.log_level,
	    options.log_facility == SYSLOG_FACILITY_NOT_SET ?
	    SYSLOG_FACILITY_AUTH : options.log_facility,
d687 1
a687 1
	for (i = 0; i < options.num_host_key_files; i++)
d694 1
a694 1
	for (i = 0; i < options.num_host_key_files; i++) {
d703 1
a703 1
		switch (key->type) {
d791 1
a791 1

d843 1
a843 1
			    &on, sizeof(on));
d847 1
a847 1
			    &linger, sizeof(linger));
d939 1
a939 1
				    (int) received_sigterm);
a977 1
					close(newsock);
d1031 3
a1033 1
						close_startup_pipes();
d1092 1
a1092 1
	setsockopt(sock_in, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
d1096 1
a1096 1
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on,
d1149 2
a1150 3
	if (options.rhosts_authentication &&
	    (remote_port >= IPPORT_RESERVED ||
	    remote_port < IPPORT_RESERVED / 2)) {
d1194 1
d1278 1
a1278 1
	packet_read_expect(SSH_CMSG_SESSION_KEY);
d1295 2
a1296 3
	if ((session_key_int = BN_new()) == NULL)
		fatal("do_ssh1_kex: BN_new failed");
	packet_get_bignum(session_key_int);
d1300 2
a1301 1
	packet_check_eom();
d1371 1
a1371 1
		u_char *buf = xmalloc(bytes);
@


1.206.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@a17 1
 * Privilege Separation:
d19 1
a19 2
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
 * Copyright (c) 2002 Niels Provos.  All rights reserved.
d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.242 2002/05/15 15:47:49 mouring Exp $");
a47 1
#include <openssl/rand.h>
a74 5
#include "session.h"
#include "monitor_mm.h"
#include "monitor.h"
#include "monitor_wrap.h"
#include "monitor_fdpass.h"
a182 4
/* variables used for privilege separation */
extern struct monitor *pmonitor;
extern int use_privsep;

a184 1
void demote_sensitive_data(void);
a256 1
	pid_t pid;
d260 1
a260 2
	while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
	    (pid < 0 && errno == EINTR))
a470 154
/* Demote private to public keys for network child */
void
demote_sensitive_data(void)
{
	Key *tmp;
	int i;

	if (sensitive_data.server_key) {
		tmp = key_demote(sensitive_data.server_key);
		key_free(sensitive_data.server_key);
		sensitive_data.server_key = tmp;
	}

	for (i = 0; i < options.num_host_key_files; i++) {
		if (sensitive_data.host_keys[i]) {
			tmp = key_demote(sensitive_data.host_keys[i]);
			key_free(sensitive_data.host_keys[i]);
			sensitive_data.host_keys[i] = tmp;
			if (tmp->type == KEY_RSA1)
				sensitive_data.ssh1_host_key = tmp;
		}
	}

	/* We do not clear ssh1_host key and cookie.  XXX - Okay Niels? */
}

static void
privsep_preauth_child(void)
{
	u_int32_t rand[256];
	int i;
	struct passwd *pw;

	/* Enable challenge-response authentication for privilege separation */
	privsep_challenge_enable();

	for (i = 0; i < 256; i++)
		rand[i] = arc4random();
	RAND_seed(rand, sizeof(rand));

	/* Demote the private keys to public keys. */
	demote_sensitive_data();

	if ((pw = getpwnam(SSH_PRIVSEP_USER)) == NULL)
		fatal("Privilege separation user %s does not exist",
		    SSH_PRIVSEP_USER);
	memset(pw->pw_passwd, 0, strlen(pw->pw_passwd));
	endpwent();

	/* Change our root directory*/
	if (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)
		fatal("chroot(\"%s\"): %s", _PATH_PRIVSEP_CHROOT_DIR,
		    strerror(errno));
	if (chdir("/") == -1)
		fatal("chdir(\"/\"): %s", strerror(errno));

	/* Drop our privileges */
	debug3("privsep user:group %u:%u", (u_int)pw->pw_uid,
	    (u_int)pw->pw_gid);
	do_setusercontext(pw);
}

static Authctxt*
privsep_preauth(void)
{
	Authctxt *authctxt = NULL;
	int status;
	pid_t pid;

	/* Set up unprivileged child process to deal with network data */
	pmonitor = monitor_init();
	/* Store a pointer to the kex for later rekeying */
	pmonitor->m_pkex = &xxx_kex;

	pid = fork();
	if (pid == -1) {
		fatal("fork of unprivileged child failed");
	} else if (pid != 0) {
		debug2("Network child is on pid %d", pid);

		close(pmonitor->m_recvfd);
		authctxt = monitor_child_preauth(pmonitor);
		close(pmonitor->m_sendfd);

		/* Sync memory */
		monitor_sync(pmonitor);

		/* Wait for the child's exit status */
		while (waitpid(pid, &status, 0) < 0)
			if (errno != EINTR)
				break;
		return (authctxt);
	} else {
		/* child */

		close(pmonitor->m_sendfd);

		/* Demote the child */
		if (getuid() == 0 || geteuid() == 0)
			privsep_preauth_child();
		setproctitle("%s", "[net]");
	}
	return (NULL);
}

static void
privsep_postauth(Authctxt *authctxt)
{
	extern Authctxt *x_authctxt;

	/* XXX - Remote port forwarding */
	x_authctxt = authctxt;

	if (authctxt->pw->pw_uid == 0 || options.use_login) {
		/* File descriptor passing is broken or root login */
		monitor_apply_keystate(pmonitor);
		use_privsep = 0;
		return;
	}

	/* Authentication complete */
	alarm(0);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}

	/* New socket pair */
	monitor_reinit(pmonitor);

	pmonitor->m_pid = fork();
	if (pmonitor->m_pid == -1)
		fatal("fork of unprivileged child failed");
	else if (pmonitor->m_pid != 0) {
		debug2("User child is on pid %d", pmonitor->m_pid);
		close(pmonitor->m_recvfd);
		monitor_child_postauth(pmonitor);

		/* NEVERREACHED */
		exit(0);
	}

	close(pmonitor->m_sendfd);

	/* Demote the private keys to public keys. */
	demote_sensitive_data();

	/* Drop privileges */
	do_setusercontext(authctxt->pw);

	/* It is safe now to apply the key state */
	monitor_apply_keystate(pmonitor);
}

d500 1
a500 1
Key *
a511 19
Key *
get_hostkey_by_index(int ind)
{
	if (ind < 0 || ind >= options.num_host_key_files)
		return (NULL);
	return (sensitive_data.host_keys[ind]);
}

int
get_hostkey_index(Key *key)
{
	int i;
	for (i = 0; i < options.num_host_key_files; i++) {
		if (key == sensitive_data.host_keys[i])
			return (i);
	}
	return (-1);
}

a587 1
	Authctxt *authctxt;
a1105 8
	 * Create a new session and process group since the 4.4BSD
	 * setlogin() affects the entire process group.  We don't
	 * want the child to be able to affect the parent.
	 */
	if (setsid() < 0)
		error("setsid: %.100s", strerror(errno));

	/*
a1205 4
	if (use_privsep)
		if ((authctxt = privsep_preauth()) != NULL)
			goto authenticated;

d1210 1
a1210 1
		authctxt = do_authentication2();
d1213 1
a1213 1
		authctxt = do_authentication();
a1214 24
	/*
	 * If we use privilege separation, the unprivileged child transfers
	 * the current keystate and exits
	 */
	if (use_privsep) {
		mm_send_keystate(pmonitor);
		exit(0);
	}

 authenticated:
	/*
	 * In privilege separation, we fork another child and prepare
	 * file descriptor passing.
	 */
	if (use_privsep) {
		privsep_postauth(authctxt);
		/* the monitor process [priv] will not return */
		if (!compat20)
			destroy_sensitive_data();
	}

	/* Perform session preparation. */
	do_authenticated(authctxt);

a1217 4

	if (use_privsep)
		mm_terminate();

a1221 44
 * Decrypt session_key_int using our private server key and private host key
 * (key with larger modulus first).
 */
int
ssh1_session_key(BIGNUM *session_key_int)
{
	int rsafail = 0;

	if (BN_cmp(sensitive_data.server_key->rsa->n, sensitive_data.ssh1_host_key->rsa->n) > 0) {
		/* Server key has bigger modulus. */
		if (BN_num_bits(sensitive_data.server_key->rsa->n) <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) <= 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) <= 0)
			rsafail++;
	} else {
		/* Host key has bigger modulus (or they are equal). */
		if (BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) <
		    BN_num_bits(sensitive_data.server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) < 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) < 0)
			rsafail++;
	}
	return (rsafail);
}
/*
d1336 37
a1372 3
	/* Decrypt session_key_int using host/server keys */
	rsafail = PRIVSEP(ssh1_session_key(session_key_int));

d1423 1
a1423 1
	/* Destroy the private and public keys. No longer. */
a1425 3
	if (use_privsep)
		mm_ssh1_session_id(session_id);

a1471 1
	kex->host_key_index=&get_hostkey_index;
@


1.206.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.206.2.3 2002/05/17 00:03:25 miod Exp $");
d368 1
a368 1
		/* Read other sides version identification. */
d564 1
a564 1
		debug2("Network child is on pid %ld", (long)pid);
a598 3
#ifdef __sparc__
	if (1) {
#else
a599 1
#endif
d620 1
a620 1
		debug2("User child is on pid %ld", (long)pmonitor->m_pid);
a974 13
	if (use_privsep) {
		struct passwd *pw;
		struct stat st;

		if ((pw = getpwnam(SSH_PRIVSEP_USER)) == NULL)
			fatal("Privilege separation user %s does not exist",
			    SSH_PRIVSEP_USER);
		if ((stat(_PATH_PRIVSEP_CHROOT_DIR, &st) == -1) ||
		    (S_ISDIR(st.st_mode) == 0))
			fatal("Missing privilege separation directory: %s",
			    _PATH_PRIVSEP_CHROOT_DIR);
	}

d1121 1
a1121 1
				fprintf(f, "%ld\n", (long) getpid());
d1268 1
a1268 1
					debug("Forked child %ld.", (long)pid);
d1374 1
a1374 1
	 * Rhosts-Authentication only makes sense from privileged
d1679 1
a1679 1
	/* Send an acknowledgment packet.  Note that this packet is sent encrypted. */
a1704 4
	}
	if (!options.compression) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
@


1.206.2.5
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.206.2.4 2002/06/22 07:23:18 miod Exp $");
a208 1

a217 1

d250 1
a250 2
	log("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0],
	    strerror(errno));
d270 1
a271 1
	pid_t pid;
a330 1

d362 1
a362 2
		if (atomicio(write, sock_out, server_version_string,
		    strlen(server_version_string))
d465 1
d516 1
a516 1
	gid_t gidset[2];
a517 1
	int i;
a544 2
#if 0
	/* XXX not ready, to heavy after chroot */
a545 8
#else
	gidset[0] = pw->pw_gid;
	if (setgid(pw->pw_gid) < 0)
		fatal("setgid failed for %u", pw->pw_gid );
	if (setgroups(1, gidset) < 0)
		fatal("setgroups: %.100s", strerror(errno));
	permanently_set_uid(pw);
#endif
d599 1
a599 1
#if BYTE_ORDER != LITTLE_ENDIAN
a676 1

a696 1

d969 3
a971 4
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) -
		    SSH_KEY_BITS_RESERVED && options.server_key_bits <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
		    SSH_KEY_BITS_RESERVED) {
d973 1
a973 2
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) +
			    SSH_KEY_BITS_RESERVED;
a989 3
		if (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)
			fatal("Bad owner or mode for %s",
			    _PATH_PRIVSEP_CHROOT_DIR);
d1316 1
a1316 1
	if (!debug_flag && !inetd_flag && setsid() < 0)
@


1.206.2.6
log
@Update to OpenSSH 3.5
@
text
@d45 1
a45 1
RCSID("$OpenBSD: sshd.c,v 1.260 2002/09/27 10:42:09 mickey Exp $");
d293 3
d297 1
a297 1
	fatal("Timeout before authentication for %s", get_remote_ipaddr());
d310 1
a310 1
	u_int32_t rnd = 0;
d323 3
a325 3
			rnd = arc4random();
		sensitive_data.ssh1_cookie[i] = rnd & 0xff;
		rnd >>= 8;
a416 6
	if (datafellows & SSH_BUG_PROBE) {
		log("probed from %s with %s.  Don't panic.",
		    get_remote_ipaddr(), client_version_string);
		fatal_cleanup();
	}

d519 2
a520 2
	u_int32_t rnd[256];
	gid_t gidset[1];
d528 2
a529 2
		rnd[i] = arc4random();
	RAND_seed(rnd, sizeof(rnd));
d540 1
a540 1
	/* Change our root directory */
d563 1
a563 1
static Authctxt *
a578 2
		fatal_remove_cleanup((void (*) (void *)) packet_close, NULL);

a591 4

		/* Reinstall, since the child has finished */
		fatal_add_cleanup((void (*) (void *)) packet_close, NULL);

a638 2
		fatal_remove_cleanup((void (*) (void *)) packet_close, NULL);

d791 1
a888 4
			if (utmp_len > MAXHOSTNAMELEN) {
				fprintf(stderr, "Invalid utmp length.\n");
				exit(1);
			}
d930 1
a930 2
	sensitive_data.host_keys = xmalloc(options.num_host_key_files *
	    sizeof(Key *));
d1099 4
a1102 2
			 * Set socket options.
			 * Allow local port reuse in TIME_WAIT.
d1104 6
a1109 3
			if (setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR,
			    &on, sizeof(on)) == -1)
				error("setsockopt SO_REUSEADDR: %s", strerror(errno));
d1353 10
d1545 1
a1545 1
	u_int32_t rnd = 0;
d1558 3
a1560 3
			rnd = arc4random();
		cookie[i] = rnd & 0xff;
		rnd >>= 8;
@


1.205
log
@remove ugliness; vp@@drexel.edu via angelos
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.204 2001/08/23 17:59:31 camield Exp $");
d74 1
@


1.204
log
@end request with 0, not NULL

ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.203 2001/07/26 17:18:22 stevesk Exp $");
d659 1
@


1.203
log
@add -t option to test configuration file and keys; pekkas@@netcore.fi
ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.202 2001/06/26 16:15:25 dugsong Exp $");
d1113 1
a1113 1
		request_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, NULL);
@


1.202
log
@Kerberos v5 support for SSH1, mostly from Assar Westerlund <assar@@freebsd.org> and Bjorn Gronvall <bg@@sics.se>. markus@@ ok
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.201 2001/06/23 19:12:43 markus Exp $");
d108 3
d553 1
a553 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDeiqQ46")) != -1) {
d629 3
d644 1
d749 4
@


1.201
log
@pidfile/sigterm race; bbraun@@synack.net
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.200 2001/06/23 15:12:21 itojun Exp $");
d1142 1
a1142 1
#ifdef KRB4
d1148 1
a1148 1
#endif /* KRB4 */
a1167 7

#ifdef KRB4
	/* Cleanup user's ticket cache file. */
	if (options.kerberos_ticket_cleanup)
		(void) dest_tkt();
#endif /* KRB4 */

d1238 1
a1238 1
#ifdef KRB4
d1242 1
a1242 1
#ifdef AFS
d1245 2
@


1.200
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.199 2001/06/04 23:07:21 markus Exp $");
d859 16
a888 11
		if (options.protocol & SSH_PROTO_1)
			generate_ephemeral_server_key();

		/* Arrange to restart on SIGHUP.  The handler needs listen_sock. */
		signal(SIGHUP, sighup_handler);

		signal(SIGTERM, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);

		/* Arrange SIGCHLD to be caught. */
		signal(SIGCHLD, main_sigchld_handler);
@


1.199
log
@set flags in the signal handlers, do real work in the main loop, ok provos@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.198 2001/05/28 23:58:35 markus Exp $");
d176 1
a176 2
void do_ssh1_kex(void);
void do_ssh2_kex(void);
d178 2
a179 2
void ssh_dh1_server(Kex *, Buffer *_kexinit, Buffer *);
void ssh_dhgex_server(Kex *, Buffer *_kexinit, Buffer *);
d184 1
a184 1
void
d198 1
a198 1
void
d209 1
a209 1
void
d222 1
a222 1
void
d232 1
a232 1
void
d248 1
a248 1
void
d267 1
a267 1
void
d290 1
a290 1
void
d299 1
a299 1
void
d449 1
a449 1
char *
d474 1
a474 1
Key *
d492 1
a492 1
int
d1179 1
a1179 1
void
d1400 1
a1400 1
void
@


1.198
log
@remove some lines, simplify.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.197 2001/05/19 19:43:57 stevesk Exp $");
d161 1
a161 1
/* This is set to true when SIGHUP is received. */
d163 1
a221 2
 * These close the listen socket; not closing it seems to cause "Address
 * already in use" problems on some machines, which is inconvenient.
d226 1
a226 4
	log("Received signal %d; terminating.", sig);
	close_listen_socks();
	unlink(options.pid_file);
	exit(255);
d231 1
a231 1
 * reap any zombies left by exited c.
d252 2
d920 7
@


1.197
log
@sshd command-line arguments and configuration file options that
specify time may be expressed using a sequence of the form:
time[qualifier], where time is a positive integer value and qualifier
is one of the following:
    <none>,s,m,h,d,w
Examples:
    600     600 seconds (10 minutes)
    10m     10 minutes
    1h30m   1 hour 30 minutes (90 minutes)
ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.196 2001/05/18 14:13:29 markus Exp $");
a428 2
	if (compat20)
		packet_set_ssh2_format();
@


1.196
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.195 2001/04/15 16:58:03 markus Exp $");
d608 4
a611 1
			options.login_grace_time = atoi(optarg);
d614 4
a617 1
			options.key_regeneration_time = atoi(optarg);
@


1.195
log
@don't use errno for key_{load,save}_private; discussion w/ solar@@openwall
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.194 2001/04/15 08:43:47 markus Exp $");
d1242 1
a1242 1
	if (options.challenge_reponse_authentication == 1)
@


1.195.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.204 2001/08/23 17:59:31 camield Exp $");
a107 3
/* Flag indicating that the daemon should only test the configuration and keys. */
int test_flag = 0;

d161 1
a161 1
/* This is set to true when a signal is received. */
a162 1
int received_sigterm = 0;
d175 2
a176 1
void destroy_sensitive_data(void);
d178 2
a179 2
static void do_ssh1_kex(void);
static void do_ssh2_kex(void);
d184 1
a184 1
static void
d198 1
a198 1
static void
d209 1
a209 1
static void
d221 2
d224 1
a224 1
static void
d227 4
a230 1
	received_sigterm = sig;
d235 1
a235 1
 * reap any zombies left by exited children.
d237 1
a237 1
static void
d253 1
a253 1
static void
a255 2
	/* XXX no idea how fix this signal handler */

d270 1
a270 1
static void
d293 1
a293 1
static void
d302 1
a302 1
static void
d429 2
d454 1
a454 1
static char *
d479 1
a479 1
static Key *
d497 1
a497 1
static int
d555 1
a555 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDeiqtQ46")) != -1) {
d608 1
a608 4
			if ((options.login_grace_time = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid login grace time.\n");
				exit(1);
			}
d611 1
a611 4
			if ((options.key_regeneration_time = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid key regeneration interval.\n");
				exit(1);
			}
a624 3
		case 't':
			test_flag = 1;
			break;
a636 1
			fprintf(stderr, "  -t         Only test configuration file and keys\n");
a741 4
	/* Configuration looks good, so exit if in test mode. */
	if (test_flag)
		exit(0);

a857 16
		if (options.protocol & SSH_PROTO_1)
			generate_ephemeral_server_key();

		/*
		 * Arrange to restart on SIGHUP.  The handler needs
		 * listen_sock.
		 */
		signal(SIGHUP, sighup_handler);

		signal(SIGTERM, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);

		/* Arrange SIGCHLD to be caught. */
		signal(SIGCHLD, main_sigchld_handler);

		/* Write out the pid file after the sigterm handler is setup */
d872 11
a917 7
			if (received_sigterm) {
				log("Received signal %d; terminating.",
				    received_sigterm);
				close_listen_socks();
				unlink(options.pid_file);
				exit(255);
			}
d1089 1
a1089 1
		request_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, 0);
d1129 1
a1129 1
#if defined(KRB4) && !defined(KRB5)
d1135 1
a1135 1
#endif /* KRB4 && !KRB5 */
d1155 7
d1171 1
a1171 1
static void
d1232 1
a1232 1
#if defined(KRB4) || defined(KRB5)
d1236 1
a1236 1
#if defined(AFS) || defined(KRB5)
a1238 2
#endif
#ifdef AFS
d1242 1
a1242 1
	if (options.challenge_response_authentication == 1)
d1392 1
a1392 1
static void
@


1.195.2.2
log
@Merge OpenSSH 3.0
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.195.2.1 2001/09/27 19:03:55 jason Exp $");
a73 1
#include "channels.h"
a658 1
	channel_set_af(IPv4or6);
@


1.195.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.195.2.2 2001/11/15 00:15:19 miod Exp $");
d331 1
a331 1
			log("Could not write ident string to %s", get_remote_ipaddr());
d339 1
a339 1
				log("Did not receive identification string from %s",
d1109 1
d1111 1
a1111 1
	/* Check whether logins are denied from this host. */
a1118 1
			debug("Connection refused by tcp wrapper");
d1120 2
a1121 2
			/* NOTREACHED */
			fatal("libwrap refuse returns");
d1123 1
a1125 1

d1152 1
a1152 1
		    "originating port %d not trusted.", remote_port);
@


1.195.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.228 2002/02/27 21:23:13 stevesk Exp $");
d47 1
a47 1
#include <openssl/md5.h>
d163 1
a163 1
static volatile sig_atomic_t key_do_regen = 0;
d166 2
a167 2
static volatile sig_atomic_t received_sighup = 0;
static volatile sig_atomic_t received_sigterm = 0;
a178 4
/* options.max_startup sized array of fd ints */
int *startup_pipes = NULL;
int startup_pipe;		/* in child */

a196 10
static void
close_startup_pipes(void)
{
	int i;
	if (startup_pipes)
		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1)
				close(startup_pipes[i]);
}

a204 2
	int save_errno = errno;

a206 1
	errno = save_errno;
a217 1
	close_startup_pipes();
d375 1
a375 1
	    remote_major, remote_minor, remote_version);
d386 1
a386 1
	switch (remote_major) {
d443 1
a443 1
	for (i = 0; i < options.num_host_key_files; i++) {
d456 1
a456 2
	Buffer b;
	char *p;
d458 2
a459 3

	buffer_init(&b);
	for (i = 0; i < options.num_host_key_files; i++) {
d463 1
a463 1
		switch (key->type) {
d466 2
a467 4
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			p = key_ssh_name(key);
			buffer_append(&b, p, strlen(p));
d471 5
a475 5
	buffer_append(&b, "\0", 1);
	p = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
	debug("list_hostkey_types: %s", p);
	return p;
d482 1
a482 1
	for (i = 0; i < options.num_host_key_files; i++) {
d519 2
a520 24
static void
usage(void)
{
	fprintf(stderr, "sshd version %s\n", SSH_VERSION);
	fprintf(stderr, "Usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -f file    Configuration file (default %s)\n", _PATH_SERVER_CONFIG_FILE);
	fprintf(stderr, "  -d         Debugging mode (multiple -d means more debugging)\n");
	fprintf(stderr, "  -i         Started from inetd\n");
	fprintf(stderr, "  -D         Do not fork into daemon mode\n");
	fprintf(stderr, "  -t         Only test configuration file and keys\n");
	fprintf(stderr, "  -q         Quiet (no logging)\n");
	fprintf(stderr, "  -p port    Listen on the specified port (default: 22)\n");
	fprintf(stderr, "  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
	fprintf(stderr, "  -g seconds Grace period for authentication (default: 600)\n");
	fprintf(stderr, "  -b bits    Size of server RSA key (default: 768 bits)\n");
	fprintf(stderr, "  -h file    File from which to read host key (default: %s)\n",
	    _PATH_HOST_KEY_FILE);
	fprintf(stderr, "  -u len     Maximum hostname length for utmp recording\n");
	fprintf(stderr, "  -4         Use IPv4 only\n");
	fprintf(stderr, "  -6         Use IPv6 only\n");
	fprintf(stderr, "  -o option  Process the option as if it was read from a configuration file.\n");
	exit(1);
}
d554 1
a554 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:o:dDeiqtQ46")) != -1) {
a635 5
		case 'o':
			if (process_server_config_line(&options, optarg,
			    "command-line", 0) != 0)
				exit(1);
			break;
d638 19
a656 2
			usage();
			break;
d667 2
a668 4
	    options.log_level == SYSLOG_LEVEL_NOT_SET ?
	    SYSLOG_LEVEL_INFO : options.log_level,
	    options.log_facility == SYSLOG_FACILITY_NOT_SET ?
	    SYSLOG_FACILITY_AUTH : options.log_facility,
d687 1
a687 1
	for (i = 0; i < options.num_host_key_files; i++)
d694 1
a694 1
	for (i = 0; i < options.num_host_key_files; i++) {
d703 1
a703 1
		switch (key->type) {
d791 1
a791 1

d843 1
a843 1
			    &on, sizeof(on));
d847 1
a847 1
			    &linger, sizeof(linger));
d939 1
a939 1
				    (int) received_sigterm);
a977 1
					close(newsock);
d1031 3
a1033 1
						close_startup_pipes();
d1092 1
a1092 1
	setsockopt(sock_in, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
d1096 1
a1096 1
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on,
d1149 2
a1150 3
	if (options.rhosts_authentication &&
	    (remote_port >= IPPORT_RESERVED ||
	    remote_port < IPPORT_RESERVED / 2)) {
d1194 1
d1278 1
a1278 1
	packet_read_expect(SSH_CMSG_SESSION_KEY);
d1295 2
a1296 3
	if ((session_key_int = BN_new()) == NULL)
		fatal("do_ssh1_kex: BN_new failed");
	packet_get_bignum(session_key_int);
d1300 2
a1301 1
	packet_check_eom();
d1371 1
a1371 1
		u_char *buf = xmalloc(bytes);
@


1.195.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@a17 1
 * Privilege Separation:
d19 1
a19 2
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
 * Copyright (c) 2002 Niels Provos.  All rights reserved.
d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.242 2002/05/15 15:47:49 mouring Exp $");
a47 1
#include <openssl/rand.h>
a74 5
#include "session.h"
#include "monitor_mm.h"
#include "monitor.h"
#include "monitor_wrap.h"
#include "monitor_fdpass.h"
a182 4
/* variables used for privilege separation */
extern struct monitor *pmonitor;
extern int use_privsep;

a184 1
void demote_sensitive_data(void);
a256 1
	pid_t pid;
d260 1
a260 2
	while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
	    (pid < 0 && errno == EINTR))
a470 154
/* Demote private to public keys for network child */
void
demote_sensitive_data(void)
{
	Key *tmp;
	int i;

	if (sensitive_data.server_key) {
		tmp = key_demote(sensitive_data.server_key);
		key_free(sensitive_data.server_key);
		sensitive_data.server_key = tmp;
	}

	for (i = 0; i < options.num_host_key_files; i++) {
		if (sensitive_data.host_keys[i]) {
			tmp = key_demote(sensitive_data.host_keys[i]);
			key_free(sensitive_data.host_keys[i]);
			sensitive_data.host_keys[i] = tmp;
			if (tmp->type == KEY_RSA1)
				sensitive_data.ssh1_host_key = tmp;
		}
	}

	/* We do not clear ssh1_host key and cookie.  XXX - Okay Niels? */
}

static void
privsep_preauth_child(void)
{
	u_int32_t rand[256];
	int i;
	struct passwd *pw;

	/* Enable challenge-response authentication for privilege separation */
	privsep_challenge_enable();

	for (i = 0; i < 256; i++)
		rand[i] = arc4random();
	RAND_seed(rand, sizeof(rand));

	/* Demote the private keys to public keys. */
	demote_sensitive_data();

	if ((pw = getpwnam(SSH_PRIVSEP_USER)) == NULL)
		fatal("Privilege separation user %s does not exist",
		    SSH_PRIVSEP_USER);
	memset(pw->pw_passwd, 0, strlen(pw->pw_passwd));
	endpwent();

	/* Change our root directory*/
	if (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)
		fatal("chroot(\"%s\"): %s", _PATH_PRIVSEP_CHROOT_DIR,
		    strerror(errno));
	if (chdir("/") == -1)
		fatal("chdir(\"/\"): %s", strerror(errno));

	/* Drop our privileges */
	debug3("privsep user:group %u:%u", (u_int)pw->pw_uid,
	    (u_int)pw->pw_gid);
	do_setusercontext(pw);
}

static Authctxt*
privsep_preauth(void)
{
	Authctxt *authctxt = NULL;
	int status;
	pid_t pid;

	/* Set up unprivileged child process to deal with network data */
	pmonitor = monitor_init();
	/* Store a pointer to the kex for later rekeying */
	pmonitor->m_pkex = &xxx_kex;

	pid = fork();
	if (pid == -1) {
		fatal("fork of unprivileged child failed");
	} else if (pid != 0) {
		debug2("Network child is on pid %d", pid);

		close(pmonitor->m_recvfd);
		authctxt = monitor_child_preauth(pmonitor);
		close(pmonitor->m_sendfd);

		/* Sync memory */
		monitor_sync(pmonitor);

		/* Wait for the child's exit status */
		while (waitpid(pid, &status, 0) < 0)
			if (errno != EINTR)
				break;
		return (authctxt);
	} else {
		/* child */

		close(pmonitor->m_sendfd);

		/* Demote the child */
		if (getuid() == 0 || geteuid() == 0)
			privsep_preauth_child();
		setproctitle("%s", "[net]");
	}
	return (NULL);
}

static void
privsep_postauth(Authctxt *authctxt)
{
	extern Authctxt *x_authctxt;

	/* XXX - Remote port forwarding */
	x_authctxt = authctxt;

	if (authctxt->pw->pw_uid == 0 || options.use_login) {
		/* File descriptor passing is broken or root login */
		monitor_apply_keystate(pmonitor);
		use_privsep = 0;
		return;
	}

	/* Authentication complete */
	alarm(0);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}

	/* New socket pair */
	monitor_reinit(pmonitor);

	pmonitor->m_pid = fork();
	if (pmonitor->m_pid == -1)
		fatal("fork of unprivileged child failed");
	else if (pmonitor->m_pid != 0) {
		debug2("User child is on pid %d", pmonitor->m_pid);
		close(pmonitor->m_recvfd);
		monitor_child_postauth(pmonitor);

		/* NEVERREACHED */
		exit(0);
	}

	close(pmonitor->m_sendfd);

	/* Demote the private keys to public keys. */
	demote_sensitive_data();

	/* Drop privileges */
	do_setusercontext(authctxt->pw);

	/* It is safe now to apply the key state */
	monitor_apply_keystate(pmonitor);
}

d500 1
a500 1
Key *
a511 19
Key *
get_hostkey_by_index(int ind)
{
	if (ind < 0 || ind >= options.num_host_key_files)
		return (NULL);
	return (sensitive_data.host_keys[ind]);
}

int
get_hostkey_index(Key *key)
{
	int i;
	for (i = 0; i < options.num_host_key_files; i++) {
		if (key == sensitive_data.host_keys[i])
			return (i);
	}
	return (-1);
}

a587 1
	Authctxt *authctxt;
a1105 8
	 * Create a new session and process group since the 4.4BSD
	 * setlogin() affects the entire process group.  We don't
	 * want the child to be able to affect the parent.
	 */
	if (setsid() < 0)
		error("setsid: %.100s", strerror(errno));

	/*
a1205 4
	if (use_privsep)
		if ((authctxt = privsep_preauth()) != NULL)
			goto authenticated;

d1210 1
a1210 1
		authctxt = do_authentication2();
d1213 1
a1213 1
		authctxt = do_authentication();
a1214 24
	/*
	 * If we use privilege separation, the unprivileged child transfers
	 * the current keystate and exits
	 */
	if (use_privsep) {
		mm_send_keystate(pmonitor);
		exit(0);
	}

 authenticated:
	/*
	 * In privilege separation, we fork another child and prepare
	 * file descriptor passing.
	 */
	if (use_privsep) {
		privsep_postauth(authctxt);
		/* the monitor process [priv] will not return */
		if (!compat20)
			destroy_sensitive_data();
	}

	/* Perform session preparation. */
	do_authenticated(authctxt);

a1217 4

	if (use_privsep)
		mm_terminate();

a1221 44
 * Decrypt session_key_int using our private server key and private host key
 * (key with larger modulus first).
 */
int
ssh1_session_key(BIGNUM *session_key_int)
{
	int rsafail = 0;

	if (BN_cmp(sensitive_data.server_key->rsa->n, sensitive_data.ssh1_host_key->rsa->n) > 0) {
		/* Server key has bigger modulus. */
		if (BN_num_bits(sensitive_data.server_key->rsa->n) <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) <= 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) <= 0)
			rsafail++;
	} else {
		/* Host key has bigger modulus (or they are equal). */
		if (BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) <
		    BN_num_bits(sensitive_data.server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) < 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) < 0)
			rsafail++;
	}
	return (rsafail);
}
/*
d1336 37
a1372 3
	/* Decrypt session_key_int using host/server keys */
	rsafail = PRIVSEP(ssh1_session_key(session_key_int));

d1423 1
a1423 1
	/* Destroy the private and public keys. No longer. */
a1425 3
	if (use_privsep)
		mm_ssh1_session_id(session_id);

a1471 1
	kex->host_key_index=&get_hostkey_index;
@


1.194
log
@some unused variable and typos; from tomh@@po.crl.go.jp
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.193 2001/04/12 20:09:38 stevesk Exp $");
d688 2
a689 2
			error("Could not load host key: %.200s: %.100s",
			    options.host_key_files[i], strerror(errno));
@


1.193
log
@robust port validation; ok markus@@ jakob@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.192 2001/04/11 16:25:30 lebel Exp $");
d783 1
a783 1
		int s1, s2;
d785 1
a785 1
		s2 = dup(s1);
@


1.192
log
@implement the -e option into sshd:

 -e      When this option is specified, sshd will send the output to the
         standard error instead of the system log.

markus@@ OK.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.191 2001/04/05 10:42:57 markus Exp $");
d601 5
a605 1
			options.ports[options.num_ports++] = atoi(optarg);
@


1.191
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.190 2001/04/04 20:25:38 markus Exp $");
d555 1
a555 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDiqQ46")) != -1) {
d579 3
@


1.190
log
@more robust rekeying
don't send channel data after rekeying is started.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.189 2001/04/04 14:34:58 markus Exp $");
d276 1
a276 1
	verbose("Generating %s%d bit RSA key.", 
d280 1
a280 1
	sensitive_data.server_key = key_generate(KEY_RSA1, 
d335 1
a335 1
		memset(buf, 0, sizeof(buf)); 
@


1.189
log
@enable server side rekeying + some rekey related clientup.
todo: we should not send any non-KEX messages after we send KEXINIT
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.188 2001/04/04 09:48:35 markus Exp $");
d1414 1
a1414 1
	dispatch_run(DISPATCH_BLOCK, &kex->newkeys, kex);
@


1.188
log
@don't sent multiple kexinit-requests.
send newkeys, block while waiting for newkeys.
fix comments.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.187 2001/04/03 23:32:12 markus Exp $");
d135 3
d1405 1
d1412 2
a1413 1
	/* start key exchange */
@


1.187
log
@undo parts of recent my changes: main part of keyexchange does not
need dispatch-callbacks, since application data is delayed until
the keyexchange completes (if i understand the drafts correctly).

add some infrastructure for re-keying.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.186 2001/04/03 19:53:29 markus Exp $");
d1402 1
a1402 1
	kex = kex_start(myproposal);
@


1.186
log
@move kex to kex*.c, used dispatch_set() callbacks for kex. should
make rekeying easier.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.185 2001/03/29 23:42:01 djm Exp $");
d1410 3
@


1.185
log
@Protocol 1 key regeneration log => verbose, some KNF; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.184 2001/03/29 21:06:21 stevesk Exp $");
d73 1
a1384 4
	Buffer *server_kexinit;
	Buffer *client_kexinit;
	int payload_len;
	int i;
a1385 3
	char *cprop[PROPOSAL_MAX];

/* KEXINIT */
d1402 5
a1406 26
	server_kexinit = kex_init(myproposal);
	client_kexinit = xmalloc(sizeof(*client_kexinit));
	buffer_init(client_kexinit);

	/* algorithm negotiation */
	kex_exchange_kexinit(server_kexinit, client_kexinit, cprop);
	kex = kex_choose_conf(cprop, myproposal, 1);
	for (i = 0; i < PROPOSAL_MAX; i++)
		xfree(cprop[i]);

	switch (kex->kex_type) {
	case DH_GRP1_SHA1:
		ssh_dh1_server(kex, client_kexinit, server_kexinit);
		break;
	case DH_GEX_SHA1:
		ssh_dhgex_server(kex, client_kexinit, server_kexinit);
		break;
	default:
		fatal("Unsupported key exchange %d", kex->kex_type);
	}

	debug("send SSH2_MSG_NEWKEYS.");
	packet_start(SSH2_MSG_NEWKEYS);
	packet_send();
	packet_write_wait();
	debug("done: send SSH2_MSG_NEWKEYS.");
d1408 2
a1409 3
	debug("Wait SSH2_MSG_NEWKEYS.");
	packet_read_expect(&payload_len, SSH2_MSG_NEWKEYS);
	debug("GOT SSH2_MSG_NEWKEYS.");
d1418 1
a1418 312

	debug("done: KEX2.");
}

/*
 * SSH2 key exchange
 */

/* diffie-hellman-group1-sha1 */

void
ssh_dh1_server(Kex *kex, Buffer *client_kexinit, Buffer *server_kexinit)
{
#ifdef DEBUG_KEXDH
	int i;
#endif
	int payload_len, dlen;
	int slen;
	u_char *signature = NULL;
	u_char *server_host_key_blob = NULL;
	u_int sbloblen;
	u_int klen, kout;
	u_char *kbuf;
	u_char *hash;
	BIGNUM *shared_secret = 0;
	DH *dh;
	BIGNUM *dh_client_pub = 0;
	Key *hostkey;

	hostkey = get_hostkey_by_type(kex->hostkey_type);
	if (hostkey == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);

/* KEXDH */
	/* generate DH key */
	dh = dh_new_group1();			/* XXX depends on 'kex' */
	dh_gen_key(dh, kex->we_need * 8);

	debug("Wait SSH2_MSG_KEXDH_INIT.");
	packet_read_expect(&payload_len, SSH2_MSG_KEXDH_INIT);

	/* key, cert */
	dh_client_pub = BN_new();
	if (dh_client_pub == NULL)
		fatal("dh_client_pub == NULL");
	packet_get_bignum2(dh_client_pub, &dlen);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\ndh_client_pub= ");
	BN_print_fp(stderr, dh_client_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_client_pub));
#endif

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\np= ");
	BN_print_fp(stderr, dh->p);
	fprintf(stderr, "\ng= ");
	bn_print(dh->g);
	fprintf(stderr, "\npub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
	DHparams_print_fp(stderr, dh);
#endif
	if (!dh_pub_is_valid(dh, dh_client_pub))
		packet_disconnect("bad client public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_client_pub, dh);

#ifdef DEBUG_KEXDH
	debug("shared secret: len %d/%d", klen, kout);
	fprintf(stderr, "shared secret == ");
	for (i = 0; i< kout; i++)
		fprintf(stderr, "%02x", (kbuf[i])&0xff);
	fprintf(stderr, "\n");
#endif
	shared_secret = BN_new();

	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	/* XXX precompute? */
	key_to_blob(hostkey, &server_host_key_blob, &sbloblen);

	/* calc H */			/* XXX depends on 'kex' */
	hash = kex_hash(
	    client_version_string,
	    server_version_string,
	    buffer_ptr(client_kexinit), buffer_len(client_kexinit),
	    buffer_ptr(server_kexinit), buffer_len(server_kexinit),
	    (char *)server_host_key_blob, sbloblen,
	    dh_client_pub,
	    dh->pub_key,
	    shared_secret
	);
	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);
	BN_free(dh_client_pub);
#ifdef DEBUG_KEXDH
	fprintf(stderr, "hash == ");
	for (i = 0; i< 20; i++)
		fprintf(stderr, "%02x", (hash[i])&0xff);
	fprintf(stderr, "\n");
#endif
	/* save session id := H */
	/* XXX hashlen depends on KEX */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);

	/* sign H */
	/* XXX hashlen depends on KEX */
	key_sign(hostkey, &signature, &slen, hash, 20);

	destroy_sensitive_data();

	/* send server hostkey, DH pubkey 'f' and singed H */
	packet_start(SSH2_MSG_KEXDH_REPLY);
	packet_put_string((char *)server_host_key_blob, sbloblen);
	packet_put_bignum2(dh->pub_key);	/* f */
	packet_put_string((char *)signature, slen);
	packet_send();
	xfree(signature);
	xfree(server_host_key_blob);
	packet_write_wait();

	kex_derive_keys(kex, hash, shared_secret);
	BN_clear_free(shared_secret);
	packet_set_kex(kex);

	/* have keys, free DH */
	DH_free(dh);
}

/* diffie-hellman-group-exchange-sha1 */

void
ssh_dhgex_server(Kex *kex, Buffer *client_kexinit, Buffer *server_kexinit)
{
#ifdef DEBUG_KEXDH
	int i;
#endif
	int payload_len, dlen;
	int slen, nbits, type, min, max;
	u_char *signature = NULL;
	u_char *server_host_key_blob = NULL;
	u_int sbloblen;
	u_int klen, kout;
	u_char *kbuf;
	u_char *hash;
	BIGNUM *shared_secret = 0;
	DH *dh;
	BIGNUM *dh_client_pub = 0;
	Key *hostkey;

	hostkey = get_hostkey_by_type(kex->hostkey_type);
	if (hostkey == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);

/* KEXDHGEX */
	debug("Wait SSH2_MSG_KEX_DH_GEX_REQUEST.");
	type = packet_read(&payload_len);
	if (type != SSH2_MSG_KEX_DH_GEX_REQUEST_OLD &&
	    type != SSH2_MSG_KEX_DH_GEX_REQUEST)
		packet_disconnect("Protocol error: expected type %d or %d, got %d",
		    SSH2_MSG_KEX_DH_GEX_REQUEST_OLD,
		    SSH2_MSG_KEX_DH_GEX_REQUEST,
		    type);
	if (type == SSH2_MSG_KEX_DH_GEX_REQUEST_OLD) {
		nbits = packet_get_int();
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;
	} else {
		min = packet_get_int();
		nbits = packet_get_int();
		max = packet_get_int();

		min = MAX(DH_GRP_MIN, min);
		max = MIN(DH_GRP_MAX, max);
	}

	if (max < min || nbits < min || max < nbits)
		fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d",
		    min, nbits, max);

	dh = choose_dh(min, nbits, max);
	if (dh == NULL)
		packet_disconnect("Protocol error: no matching DH grp found");

	debug("Sending SSH2_MSG_KEX_DH_GEX_GROUP.");
	packet_start(SSH2_MSG_KEX_DH_GEX_GROUP);
	packet_put_bignum2(dh->p);
	packet_put_bignum2(dh->g);
	packet_send();
	packet_write_wait();

	/* Compute our exchange value in parallel with the client */

	dh_gen_key(dh, kex->we_need * 8);

	debug("Wait SSH2_MSG_KEX_DH_GEX_INIT.");
	packet_read_expect(&payload_len, SSH2_MSG_KEX_DH_GEX_INIT);

	/* key, cert */
	dh_client_pub = BN_new();
	if (dh_client_pub == NULL)
		fatal("dh_client_pub == NULL");
	packet_get_bignum2(dh_client_pub, &dlen);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\ndh_client_pub= ");
	BN_print_fp(stderr, dh_client_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_client_pub));
#endif

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\np= ");
	BN_print_fp(stderr, dh->p);
	fprintf(stderr, "\ng= ");
	bn_print(dh->g);
	fprintf(stderr, "\npub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
	DHparams_print_fp(stderr, dh);
#endif
	if (!dh_pub_is_valid(dh, dh_client_pub))
		packet_disconnect("bad client public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_client_pub, dh);

#ifdef DEBUG_KEXDH
	debug("shared secret: len %d/%d", klen, kout);
	fprintf(stderr, "shared secret == ");
	for (i = 0; i< kout; i++)
		fprintf(stderr, "%02x", (kbuf[i])&0xff);
	fprintf(stderr, "\n");
#endif
	shared_secret = BN_new();

	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	/* XXX precompute? */
	key_to_blob(hostkey, &server_host_key_blob, &sbloblen);

	if (type == SSH2_MSG_KEX_DH_GEX_REQUEST_OLD) {
		/* These values are not included in the hash */
		min = -1;
		max = -1;
	}

	/* calc H */			/* XXX depends on 'kex' */
	hash = kex_hash_gex(
	    client_version_string,
	    server_version_string,
	    buffer_ptr(client_kexinit), buffer_len(client_kexinit),
	    buffer_ptr(server_kexinit), buffer_len(server_kexinit),
	    (char *)server_host_key_blob, sbloblen,
	    min, nbits, max,
	    dh->p, dh->g,
	    dh_client_pub,
	    dh->pub_key,
	    shared_secret
	);
	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);
	BN_free(dh_client_pub);
#ifdef DEBUG_KEXDH
	fprintf(stderr, "hash == ");
	for (i = 0; i< 20; i++)
		fprintf(stderr, "%02x", (hash[i])&0xff);
	fprintf(stderr, "\n");
#endif
	/* save session id := H */
	/* XXX hashlen depends on KEX */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);

	/* sign H */
	/* XXX hashlen depends on KEX */
	key_sign(hostkey, &signature, &slen, hash, 20);

	destroy_sensitive_data();

	/* send server hostkey, DH pubkey 'f' and singed H */
	packet_start(SSH2_MSG_KEX_DH_GEX_REPLY);
	packet_put_string((char *)server_host_key_blob, sbloblen);
	packet_put_bignum2(dh->pub_key);	/* f */
	packet_put_string((char *)signature, slen);
	packet_send();
	xfree(signature);
	xfree(server_host_key_blob);
	packet_write_wait();

	kex_derive_keys(kex, hash, shared_secret);
	BN_clear_free(shared_secret);
	packet_set_kex(kex);

	/* have keys, free DH */
	DH_free(dh);
@


1.184
log
@need to set both STOC and CTOS for SSH_BUG_BIGENDIANAES; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.183 2001/03/28 21:59:41 provos Exp $");
d272 2
a273 2
	log("Generating %s%d bit RSA key.", sensitive_data.server_key ? "new " : "",
	    options.server_key_bits);
d276 3
a278 2
	sensitive_data.server_key = key_generate(KEY_RSA1, options.server_key_bits);
	log("RSA key generation complete.");
@


1.183
log
@forgot to include min and max params in hash, okay markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.182 2001/03/28 20:50:45 markus Exp $");
d1396 5
a1405 3

	myproposal[PROPOSAL_ENC_ALGS_STOC] =
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_STOC]);
@


1.182
log
@call refuse() before close(); from olemx@@ans.pl
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.181 2001/03/27 17:46:49 provos Exp $");
d1697 6
d1710 2
a1711 1
	    nbits, dh->p, dh->g,
@


1.181
log
@make dh group exchange more flexible, allow min and max group size,
okay markus@@, deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.180 2001/03/27 10:34:08 markus Exp $");
d1081 1
a1083 1
			refuse(&req);
@


1.180
log
@use EVP_get_digestbynid, reorder some calls and fix missing free.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.179 2001/03/26 08:07:09 markus Exp $");
d1591 1
a1591 1
	int slen, nbits;
d1609 27
a1635 3
	packet_read_expect(&payload_len, SSH2_MSG_KEX_DH_GEX_REQUEST);
	nbits = packet_get_int();
	dh = choose_dh(nbits);
@


1.179
log
@simpler key load/save interface, see authfile.h
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.178 2001/03/23 14:28:32 markus Exp $");
d638 1
@


1.178
log
@ignore SIGPIPE, restore in child, fixes x11-fwd crashes; with djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.177 2001/03/23 11:04:07 djm Exp $");
a447 33
Key *
load_private_key_autodetect(const char *filename)
{
	struct stat st;
	int type;
	Key *public, *private;

	if (stat(filename, &st) < 0) {
		perror(filename);
		return NULL;
	}
	/*
	 * try to load the public key. right now this only works for RSA1,
	 * since SSH2 keys are fully encrypted
	 */
	type = KEY_RSA1;
	public = key_new(type);
	if (!load_public_key(filename, public, NULL)) {
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
	}
	key_free(public);

	/* Ok, try key with empty passphrase */
	private = key_new(type);
	if (load_private_key(filename, "", private, NULL)) {
		debug("load_private_key_autodetect: type %d %s",
		    private->type, key_type(private));
		return private;
	}
	key_free(private);
	return NULL;
}
d540 1
d672 2
a673 1
		Key *key = load_private_key_autodetect(options.host_key_files[i]);
d677 1
d690 2
a691 1
		sensitive_data.host_keys[i] = key;
@


1.177
log
@Compat for OpenSSH with broken Rijndael/AES. ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.176 2001/03/22 20:22:55 deraadt Exp $");
d793 3
@


1.176
log
@do not place linefeeds in buffer
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.175 2001/03/18 23:30:55 deraadt Exp $");
d1426 3
@


1.175
log
@specifically version match on ssh scanners.  do not log scan information
to the console, because clueless users freak out when people do completely
legal probes.  instead, generate a detailed log file entry and use british
humour to relax their sphincters a little bit.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.174 2001/03/09 12:30:29 deraadt Exp $");
d338 1
a338 2
				buf[i] = '\n';
				buf[i + 1] = 0;
d346 1
a346 2
				/* buf[i] == '\n' */
				buf[i + 1] = 0;
a411 1
	chop(client_version_string);
@


1.174
log
@typo; slade@@shore.net
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.173 2001/03/05 17:17:21 markus Exp $");
d374 6
@


1.173
log
@generate a 2*need size (~300 instead of 1024/2048) random private
exponent during the DH key agreement. according to Niels (the great
german advisor) this is safe since /etc/primes contains strong
primes only.

References:
        P. C. van Oorschot and M. J. Wiener, On Diffie-Hellman key
        agreement with short exponents, In Advances in Cryptology
        - EUROCRYPT'96, LNCS 1070, Springer-Verlag, 1996, pp.332-343.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.172 2001/03/04 17:42:28 millert Exp $");
d143 1
a143 1
	Key	*server_key;		/* empheral server key */
d267 1
a267 1
generate_empheral_server_key(void)
d806 1
a806 1
			generate_empheral_server_key();
d883 1
a883 1
			generate_empheral_server_key();
d929 1
a929 1
				generate_empheral_server_key();
@


1.172
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.171 2001/03/04 01:46:30 djm Exp $");
d1498 1
a1498 1
	dh_gen_key(dh);
d1641 1
a1641 1
	dh_gen_key(dh);
@


1.171
log
@Rename pty.[ch] -> sshpty.[ch] and login.[ch] to sshlogin.[ch] to avoid
header conflicts in portable; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.170 2001/02/28 21:21:41 markus Exp $");
d728 1
a728 1
		log("sshd: no hostkeys available -- exiting.\n");
@


1.170
log
@generate a fake session id, too
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.169 2001/02/23 18:15:13 markus Exp $");
d54 1
a54 1
#include "pty.h"
@


1.169
log
@the random session key depends now on the session_key_int
sent by the 'attacker'
        dig1 = md5(cookie|session_key_int);
        dig2 = md5(dig1|cookie|session_key_int);
        fake_session_key = dig1|dig2;
this change is caused by a mail from anakin@@pobox.com
patch based on discussions with my german advisor niels@@openbsd.org
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.168 2001/02/19 23:09:05 deraadt Exp $");
d1376 2
@


1.168
log
@clarify message to make it not mention "ident"
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.167 2001/02/12 23:26:20 markus Exp $");
d148 1
d269 3
d277 8
a285 1
	log("RSA key generation complete.");
d443 1
a1328 8

	compute_session_id(session_id, cookie,
	    sensitive_data.ssh1_host_key->rsa->n,
	    sensitive_data.server_key->rsa->n);

	/* Destroy the private and public keys.  They will no longer be needed. */
	destroy_sensitive_data();

d1346 10
d1359 4
d1364 12
a1375 6
		for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++) {
			if (i % 4 == 0)
				rand = arc4random();
			session_key[i] = rand & 0xff;
			rand >>= 8;
		}
d1377 3
a1381 4

	/* Xor the first 16 bytes of the session key with the session id. */
	for (i = 0; i < 16; i++)
		session_key[i] ^= session_id[i];
@


1.167
log
@missing memset; from solar@@openwall.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.166 2001/02/11 12:59:25 markus Exp $");
d322 2
a323 1
				log("Did not receive ident string from %s.", get_remote_ipaddr());
@


1.166
log
@1) clean up the MAC support for SSH-2
2) allow you to specify the MAC with 'ssh -m'
3) or the 'MACs' keyword in ssh(d)_config
4) add hmac-{md5,sha1}-96
	ok stevesk@@, provos@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.165 2001/02/08 19:30:53 itojun Exp $");
d318 2
a319 1
		/* Read other side\'s version identification. */
@


1.165
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.164 2001/02/07 22:35:46 markus Exp $");
d1390 4
@


1.164
log
@move k_setpag() to a central place; ok dugsong@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.163 2001/02/04 23:56:23 deraadt Exp $");
d205 1
a205 1
sighup_restart()
d760 1
a760 1
		fd = open("/dev/tty", O_RDWR | O_NOCTTY);
d1333 2
a1334 2
			    "session_key_int %d > sizeof(session_key) %d",
			    get_remote_ipaddr(), len, (int)sizeof(session_key));
@


1.163
log
@alpha happiness
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.162 2001/02/04 22:12:17 stevesk Exp $");
d1132 7
@


1.162
log
@precedence; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.161 2001/02/04 15:32:27 stevesk Exp $");
d1326 2
a1327 2
			    "session_key_int %d > sizeof(session_key) %ld",
			    get_remote_ipaddr(), len, sizeof(session_key));
@


1.161
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.160 2001/02/04 15:14:15 deraadt Exp $");
d713 1
a713 1
	if (! options.protocol & (SSH_PROTO_1|SSH_PROTO_2)) {
@


1.160
log
@make the alpha happy
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.159 2001/01/29 19:47:31 markus Exp $");
d423 1
a423 1
        for(i = 0; i < options.num_host_key_files; i++) {
d968 1
a968 1
				
d1486 1
a1486 1
        DHparams_print_fp(stderr, dh);
d1629 1
a1629 1
        DHparams_print_fp(stderr, dh);
@


1.159
log
@handle rsa_private_decrypt failures; helps against the Bleichenbacher pkcs#1 attack
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.158 2001/01/28 10:37:26 markus Exp $");
d1326 1
a1326 1
			    "session_key_int %d > sizeof(session_key) %d",
@


1.158
log
@remove -Q, no longer needed
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.157 2001/01/22 23:06:40 markus Exp $");
d1165 1
d1276 1
a1276 1
		/* Private key has bigger modulus. */
d1285 6
a1290 4
		rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa);
		rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa);
d1301 6
a1306 4
		rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa);
		rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa);
d1321 23
a1343 9
	BN_mask_bits(session_key_int, sizeof(session_key) * 8);
	len = BN_num_bytes(session_key_int);
	if (len < 0 || len > sizeof(session_key))
		fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
		    get_remote_ipaddr(),
		    len, sizeof(session_key));
	memset(session_key, 0, sizeof(session_key));
	BN_bn2bin(session_key_int, session_key + sizeof(session_key) - len);

@


1.157
log
@rename skey -> challenge response.
auto-enable kbd-interactive for ssh2 if challenge-reponse is enabled.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.156 2001/01/22 17:22:28 stevesk Exp $");
a544 1
	int silent = 0;
d594 1
a594 1
			silent = 1;
d661 1
a661 1
	    !silent && !inetd_flag);
a713 2
		if (silent == 0)
			fprintf(stderr, "sshd: no hostkeys available -- exiting.\n");
@


1.156
log
@fix memory leaks in SSH2 key exchange; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.155 2001/01/21 19:06:00 markus Exp $");
d1233 1
a1233 1
	if (options.skey_authentication == 1)
@


1.155
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.154 2001/01/19 15:55:12 markus Exp $");
d1510 1
d1540 1
d1654 1
d1684 1
@


1.154
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.153 2001/01/19 12:45:27 markus Exp $");
d45 7
a53 1
#include "ssh.h"
d57 1
d62 1
a62 6

#include "ssh1.h"
#include "ssh2.h"
#include <openssl/dh.h>
#include <openssl/bn.h>
#include <openssl/hmac.h>
a63 2
#include <openssl/dsa.h>
#include <openssl/rsa.h>
a65 2

#include "auth.h"
d69 4
@


1.153
log
@only auth-chall.c needs #ifdef SKEY
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.152 2001/01/18 16:20:22 markus Exp $");
d56 1
d70 1
d89 1
a89 1
char *config_file_name = SERVER_CONFIG_FILE;
d635 1
a635 1
			fprintf(stderr, "  -f file    Configuration file (default %s)\n", SERVER_CONFIG_FILE);
d645 1
a645 1
			    HOST_KEY_FILE);
@


1.152
log
@log() is at pri=LOG_INFO, since LOG_NOTICE goes to /dev/console on many systems
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.151 2001/01/18 15:54:49 markus Exp $");
a1228 1
#ifdef SKEY
a1230 1
#endif
@


1.151
log
@don't call rsa-keygen from signalhandler.
re-schedule keygen at the time the key is actually used.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.150 2001/01/13 18:32:51 markus Exp $");
d656 1
a656 1
	    options.log_level == -1 ? SYSLOG_LEVEL_NOTICE : options.log_level,
@


1.150
log
@split out keepalive from packet_interactive (from dale@@accentre.com)
set IPTOS_LOWDELAY TCP_NODELAY IPTOS_THROUGHPUT for ssh2, too.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.149 2001/01/13 18:03:07 markus Exp $");
d147 2
a148 2
 * Flag indicating whether the current session key has been used.  This flag
 * is set whenever the key is used, and cleared when the key is regenerated.
d150 1
a150 1
int key_used = 0;
a259 1
 * XXX calling log() is not safe from races.
d277 1
a277 10

	/* Check if we should generate a new key. */
	if (key_used) {
		/* This should really be done in the background. */
		generate_empheral_server_key();
		key_used = 0;
	}
	/* Reschedule the alarm. */
	signal(SIGALRM, key_regeneration_alarm);
	alarm(options.key_regeneration_time);
d279 1
d553 1
d867 1
a867 1
		if (options.protocol & SSH_PROTO_1) {
a869 5
			/* Schedule server key regeneration alarm. */
			signal(SIGALRM, key_regeneration_alarm);
			alarm(options.key_regeneration_time);
		}

d910 9
a918 3
			if (select(maxfd+1, fdset, NULL, NULL, NULL) < 0) {
				if (errno != EINTR)
					error("select: %.100s", strerror(errno));
d920 1
a920 1
			}
d1020 7
a1026 1
				key_used = 1;
@


1.149
log
@getopt() returns -1 not EOF; stevesk@@pobox.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.148 2001/01/11 22:14:20 markus Exp $");
d1063 6
@


1.148
log
@maxfd+1
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.147 2001/01/10 19:43:20 deraadt Exp $");
d570 1
a570 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDiqQ46")) != EOF) {
@


1.147
log
@XXX -- generate_empheral_server_key() is not safe against races, because it calls log()
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.147 2001/01/10 19:25:57 deraadt Exp $");
d912 1
a912 1
			fdsetsz = howmany(maxfd, NFDBITS) * sizeof(fd_mask);
d923 1
a923 1
			if (select(maxfd + 1, fdset, NULL, NULL, NULL) < 0) {
@


1.146
log
@rename SYSLOG_LEVEL_INFO->SYSLOG_LEVEL_NOTICE
syslog priority changes:
	fatal() LOG_ERR  -> LOG_CRIT
	log()   LOG_INFO -> LOG_NOTICE
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.145 2001/01/04 22:25:58 markus Exp $");
d260 1
a261 1
/* XXX do we really want this work to be done in a signal handler ? -m */
d273 1
@


1.145
log
@sync usage()/man with defaults; from stevesk@@pobox.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.144 2000/12/28 12:03:58 markus Exp $");
d663 1
a663 1
	    options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
@


1.144
log
@document -D
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.143 2000/12/27 12:34:50 markus Exp $");
d647 1
a647 1
			fprintf(stderr, "  -g seconds Grace period for authentication (default: 300)\n");
@


1.143
log
@typo
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.142 2000/12/20 19:37:22 markus Exp $");
d643 1
@


1.142
log
@fix prototypes; from  stevesk@@pobox.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.141 2000/12/20 19:32:08 markus Exp $");
d932 1
a932 1
					 * after successfull authentication
@


1.141
log
@init pointer to NULL; report from Jan.Iven@@cern.ch
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.140 2000/12/19 23:17:59 markus Exp $");
d166 2
a167 2
void do_ssh1_kex();
void do_ssh2_kex();
d1153 1
a1153 1
do_ssh1_kex()
d1344 1
a1344 1
do_ssh2_kex()
@


1.140
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.139 2000/12/15 17:30:14 provos Exp $");
d682 2
@


1.139
log
@compute diffie-hellman in parallel between server and client. okay markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.138 2000/12/12 22:30:02 markus Exp $");
d156 1
a156 1
unsigned char session_id[16];
d159 1
a159 1
unsigned char *session_id2 = NULL;
d163 1
a163 1
unsigned int utmp_len = MAXHOSTNAMELEN;
d867 1
a867 1
				fprintf(f, "%u\n", (unsigned int) getpid());
d1156 3
a1158 3
	unsigned char session_key[SSH_SESSION_KEY_LENGTH];
	unsigned char cookie[8];
	unsigned int cipher_type, auth_mask, protocol_flags;
d1415 6
a1420 6
	unsigned char *signature = NULL;
	unsigned char *server_host_key_blob = NULL;
	unsigned int sbloblen;
	unsigned int klen, kout;
	unsigned char *kbuf;
	unsigned char *hash;
d1544 6
a1549 6
	unsigned char *signature = NULL;
	unsigned char *server_host_key_blob = NULL;
	unsigned int sbloblen;
	unsigned int klen, kout;
	unsigned char *kbuf;
	unsigned char *hash;
@


1.138
log
@consistently use __progname; from stevesk@@pobox.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.137 2000/12/12 21:45:21 markus Exp $");
d1431 4
a1450 3
	/* generate DH key */
	dh = dh_new_group1();			/* XXX depends on 'kex' */

d1571 4
@


1.137
log
@source port < 1024 is no longer required for rhosts-rsa since it
adds no additional security.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.136 2000/12/05 16:47:28 todd Exp $");
d81 2
a111 3
/* argv[0] without path. */
char *av0;

d206 1
a206 1
	log("RESTART FAILED: av0='%s', error: %s.", av0, strerror(errno));
d562 1
a562 1
	/* Save argv[0]. */
a563 4
	if (strchr(av[0], '/'))
		av0 = strrchr(av[0], '/') + 1;
	else
		av0 = av[0];
d638 1
a638 1
			fprintf(stderr, "Usage: %s [options]\n", av0);
d661 1
a661 1
	log_init(av0,
d747 1
a747 1
	log_init(av0, options.log_level, options.log_facility, log_stderr);
d771 1
a771 1
	log_init(av0, options.log_level, options.log_facility, log_stderr);
d1009 1
a1009 1
						log_init(av0, options.log_level, options.log_facility, log_stderr);
d1075 1
a1075 1
		request_init(&req, RQ_DAEMON, av0, RQ_FILE, sock_in, NULL);
@


1.136
log
@tweak comment to reflect real location of pid file; ok provos@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.135 2000/11/29 21:11:59 markus Exp $");
d1108 2
a1109 2
	 * Check that the connection comes from a privileged port.  Rhosts-
	 * and Rhosts-RSA-Authentication only make sense from priviledged
d1116 1
a1116 1
		debug("Rhosts Authentication methods disabled, "
a1118 1
		options.rhosts_rsa_authentication = 0;
@


1.135
log
@sshd -D, startup w/o daemon(), for monitoring scripts or initab;
from handler@@sub-rosa.com and eric@@urbanrage.com; ok niels@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.134 2000/11/12 19:50:38 markus Exp $");
d864 3
a866 3
			 * Record our pid in /etc/sshd_pid to make it easier
			 * to kill the correct sshd.  We don\'t want to do
			 * this before the bind above because the bind will
@


1.134
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.133 2000/11/06 23:13:27 markus Exp $");
d104 3
d574 1
a574 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:diqQ46")) != EOF) {
d596 3
d759 1
a759 1
	if (!debug_flag && !inetd_flag) {
@


1.133
log
@do not disabled rhosts(rsa) if server port > 1024; from pekkas@@netcore.fi
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.132 2000/10/13 18:34:46 markus Exp $");
a63 1
#include "dsa.h"
d137 5
a141 3
	RSA *private_key;	 /* Private part of empheral server key. */
	RSA *host_key;		 /* Private part of host key. */
	Key *dsa_host_key;       /* Private DSA host key. */
a152 4
/* Public side of the server key.  This value is regenerated regularly with
   the private key. */
RSA *public_key;

d261 11
d279 1
a279 13
		log("Generating new %d bit RSA key.", options.server_key_bits);

		if (sensitive_data.private_key != NULL)
			RSA_free(sensitive_data.private_key);
		sensitive_data.private_key = RSA_new();

		if (public_key != NULL)
			RSA_free(public_key);
		public_key = RSA_new();

		rsa_generate_key(sensitive_data.private_key, public_key,
				 options.server_key_bits);
		arc4random_stir();
a280 1
		log("RSA key generation complete.");
d415 1
d419 83
a501 9
	/* Destroy the private and public keys.  They will no longer be needed. */
	if (public_key)
		RSA_free(public_key);
	if (sensitive_data.private_key)
		RSA_free(sensitive_data.private_key);
	if (sensitive_data.host_key)
		RSA_free(sensitive_data.host_key);
	if (sensitive_data.dsa_host_key != NULL)
		key_free(sensitive_data.dsa_host_key);
d620 5
a624 1
			options.host_key_file = optarg;
d679 28
a706 8
	sensitive_data.dsa_host_key = NULL;
	sensitive_data.host_key = NULL;

	/* check if RSA support exists */
	if ((options.protocol & SSH_PROTO_1) &&
	    rsa_alive() == 0) {
		log("no RSA support in libssl and libcrypto.  See ssl(8)");
		log("Disabling protocol version 1");
d709 3
a711 23
	/* Load the RSA/DSA host key.  It must have empty passphrase. */
	if (options.protocol & SSH_PROTO_1) {
		Key k;
		sensitive_data.host_key = RSA_new();
		k.type = KEY_RSA;
		k.rsa = sensitive_data.host_key;
		errno = 0;
		if (!load_private_key(options.host_key_file, "", &k, NULL)) {
			error("Could not load host key: %.200s: %.100s",
			    options.host_key_file, strerror(errno));
			log("Disabling protocol version 1");
			options.protocol &= ~SSH_PROTO_1;
		}
		k.rsa = NULL;
	}
	if (options.protocol & SSH_PROTO_2) {
		sensitive_data.dsa_host_key = key_new(KEY_DSA);
		if (!load_private_key(options.host_dsa_key_file, "", sensitive_data.dsa_host_key, NULL)) {

			error("Could not load DSA host key: %.200s", options.host_dsa_key_file);
			log("Disabling protocol version 2");
			options.protocol &= ~SSH_PROTO_2;
		}
d733 1
a733 1
		    BN_num_bits(sensitive_data.host_key->n) - SSH_KEY_BITS_RESERVED &&
d735 1
a735 1
		    BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED) {
d737 1
a737 1
			    BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED;
a771 3
	/* Do not display messages to stdout in RSA code. */
	rsa_set_verbose(0);

d793 2
a794 10

		if (options.protocol & SSH_PROTO_1) {
			public_key = RSA_new();
			sensitive_data.private_key = RSA_new();
			log("Generating %d bit RSA key.", options.server_key_bits);
			rsa_generate_key(sensitive_data.private_key, public_key,
			    options.server_key_bits);
			arc4random_stir();
			log("RSA key generation complete.");
		}
d871 1
a871 8
			public_key = RSA_new();
			sensitive_data.private_key = RSA_new();

			log("Generating %d bit RSA key.", options.server_key_bits);
			rsa_generate_key(sensitive_data.private_key, public_key,
			    options.server_key_bits);
			arc4random_stir();
			log("RSA key generation complete.");
d1187 3
a1189 3
	packet_put_int(BN_num_bits(public_key->n));
	packet_put_bignum(public_key->e);
	packet_put_bignum(public_key->n);
d1192 3
a1194 3
	packet_put_int(BN_num_bits(sensitive_data.host_key->n));
	packet_put_bignum(sensitive_data.host_key->e);
	packet_put_bignum(sensitive_data.host_key->n);
d1232 3
a1234 2
	debug("Sent %d bit public key and %d bit host key.",
	      BN_num_bits(public_key->n), BN_num_bits(sensitive_data.host_key->n));
d1266 1
a1266 1
	if (BN_cmp(sensitive_data.private_key->n, sensitive_data.host_key->n) > 0) {
d1268 7
a1274 7
		if (BN_num_bits(sensitive_data.private_key->n) <
		    BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
			      get_remote_ipaddr(),
			      BN_num_bits(sensitive_data.private_key->n),
			      BN_num_bits(sensitive_data.host_key->n),
			      SSH_KEY_BITS_RESERVED);
d1277 1
a1277 1
				    sensitive_data.private_key);
d1279 1
a1279 1
				    sensitive_data.host_key);
d1282 7
a1288 7
		if (BN_num_bits(sensitive_data.host_key->n) <
		    BN_num_bits(sensitive_data.private_key->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
			      get_remote_ipaddr(),
			      BN_num_bits(sensitive_data.host_key->n),
			      BN_num_bits(sensitive_data.private_key->n),
			      SSH_KEY_BITS_RESERVED);
d1291 1
a1291 1
				    sensitive_data.host_key);
d1293 1
a1293 1
				    sensitive_data.private_key);
d1297 2
a1298 2
			   sensitive_data.host_key->n,
			   sensitive_data.private_key->n);
d1312 2
a1313 2
		      get_remote_ipaddr(),
		      len, sizeof(session_key));
d1357 2
d1424 5
d1481 1
a1481 2
	dsa_make_key_blob(sensitive_data.dsa_host_key,
			  &server_host_key_blob, &sbloblen);
d1512 1
a1512 1
	dsa_sign(sensitive_data.dsa_host_key, &signature, &slen, hash, 20);
d1552 5
d1618 1
a1618 2
	dsa_make_key_blob(sensitive_data.dsa_host_key,
			  &server_host_key_blob, &sbloblen);
d1650 1
a1650 1
	dsa_sign(sensitive_data.dsa_host_key, &signature, &slen, hash, 20);
a1669 1

@


1.132
log
@Kludge for F-Secure Macintosh < 1.0.2; appro@@fy.chalmers.se
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.131 2000/10/12 09:59:20 markus Exp $");
d1054 2
@


1.132.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.167 2001/02/12 23:26:20 markus Exp $");
a44 7
#include <openssl/dh.h>
#include <openssl/bn.h>
#include <openssl/hmac.h>

#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
d47 1
a50 1
#include "log.h"
d55 5
a59 1
#include "cipher.h"
d61 2
d64 1
d66 2
a69 5
#include "pathnames.h"
#include "atomicio.h"
#include "canohost.h"
#include "auth.h"
#include "misc.h"
a81 2
extern char *__progname;

d86 1
a86 1
char *config_file_name = _PATH_SERVER_CONFIG_FILE;
a104 3
/* Flag indicating that sshd should not detach and become a daemon. */
int no_daemon_flag = 0;

d108 3
d138 3
a140 5
	Key	*server_key;		/* empheral server key */
	Key	*ssh1_host_key;		/* ssh1 host key */
	Key	**host_keys;		/* all private host keys */
	int	have_ssh1_key;
	int	have_ssh2_key;
d144 2
a145 2
 * Flag indicating whether the RSA server key needs to be regenerated.
 * Is set in the SIGALRM handler and cleared when the key is regenerated.
d147 1
a147 1
int key_do_regen = 0;
d152 4
d157 1
a157 1
u_char session_id[16];
d160 1
a160 1
u_char *session_id2 = NULL;
d164 1
a164 1
u_int utmp_len = MAXHOSTNAMELEN;
d167 2
a168 2
void do_ssh1_kex(void);
void do_ssh2_kex(void);
d202 1
a202 1
sighup_restart(void)
d207 1
a207 1
	log("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0], strerror(errno));
d262 1
a262 12
void
generate_empheral_server_key(void)
{
	log("Generating %s%d bit RSA key.", sensitive_data.server_key ? "new " : "",
	    options.server_key_bits);
	if (sensitive_data.server_key != NULL)
		key_free(sensitive_data.server_key);
	sensitive_data.server_key = key_generate(KEY_RSA1, options.server_key_bits);
	arc4random_stir();
	log("RSA key generation complete.");
}

d267 23
a289 1
	signal(SIGALRM, SIG_DFL);
a290 1
	key_do_regen = 1;
d325 1
a325 2
		/* Read other side's version identification. */
		memset(buf, 0, sizeof(buf)); 
a419 1
/* Destroy the host and server keys.  They will no longer be needed. */
d423 9
a431 83
	int i;

	if (sensitive_data.server_key) {
		key_free(sensitive_data.server_key);
		sensitive_data.server_key = NULL;
	}
	for(i = 0; i < options.num_host_key_files; i++) {
		if (sensitive_data.host_keys[i]) {
			key_free(sensitive_data.host_keys[i]);
			sensitive_data.host_keys[i] = NULL;
		}
	}
	sensitive_data.ssh1_host_key = NULL;
}
Key *
load_private_key_autodetect(const char *filename)
{
	struct stat st;
	int type;
	Key *public, *private;

	if (stat(filename, &st) < 0) {
		perror(filename);
		return NULL;
	}
	/*
	 * try to load the public key. right now this only works for RSA1,
	 * since SSH2 keys are fully encrypted
	 */
	type = KEY_RSA1;
	public = key_new(type);
	if (!load_public_key(filename, public, NULL)) {
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
	}
	key_free(public);

	/* Ok, try key with empty passphrase */
	private = key_new(type);
	if (load_private_key(filename, "", private, NULL)) {
		debug("load_private_key_autodetect: type %d %s",
		    private->type, key_type(private));
		return private;
	}
	key_free(private);
	return NULL;
}

char *
list_hostkey_types(void)
{
	static char buf[1024];
	int i;
	buf[0] = '\0';
	for(i = 0; i < options.num_host_key_files; i++) {
		Key *key = sensitive_data.host_keys[i];
		if (key == NULL)
			continue;
		switch(key->type) {
		case KEY_RSA:
		case KEY_DSA:
			strlcat(buf, key_ssh_name(key), sizeof buf);
			strlcat(buf, ",", sizeof buf);
			break;
		}
	}
	i = strlen(buf);
	if (i > 0 && buf[i-1] == ',')
		buf[i-1] = '\0';
	debug("list_hostkey_types: %s", buf);
	return buf;
}

Key *
get_hostkey_by_type(int type)
{
	int i;
	for(i = 0; i < options.num_host_key_files; i++) {
		Key *key = sensitive_data.host_keys[i];
		if (key != NULL && key->type == type)
			return key;
	}
	return NULL;
d477 1
a488 1
	int ret, key_used = 0;
d490 1
a490 1
	/* Save argv. */
d492 4
d501 1
a501 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDiqQ46")) != -1) {
a522 3
		case 'D':
			no_daemon_flag = 1;
			break;
d527 1
a527 1
			/* ignored */
d550 1
a550 5
			if (options.num_host_key_files >= MAX_HOSTKEYS) {
				fprintf(stderr, "too many host keys.\n");
				exit(1);
			}
			options.host_key_files[options.num_host_key_files++] = optarg;
d563 1
a563 1
			fprintf(stderr, "Usage: %s [options]\n", __progname);
d565 1
a565 1
			fprintf(stderr, "  -f file    Configuration file (default %s)\n", _PATH_SERVER_CONFIG_FILE);
a567 1
			fprintf(stderr, "  -D         Do not fork into daemon mode\n");
d571 1
a571 1
			fprintf(stderr, "  -g seconds Grace period for authentication (default: 600)\n");
d574 1
a574 1
			    _PATH_HOST_KEY_FILE);
d586 1
a586 1
	log_init(__progname,
d589 1
a589 1
	    !inetd_flag);
d605 18
a622 12
	/* load private host keys */
	sensitive_data.host_keys = xmalloc(options.num_host_key_files*sizeof(Key*));
	for(i = 0; i < options.num_host_key_files; i++)
		sensitive_data.host_keys[i] = NULL;
	sensitive_data.server_key = NULL;
	sensitive_data.ssh1_host_key = NULL;
	sensitive_data.have_ssh1_key = 0;
	sensitive_data.have_ssh2_key = 0;

	for(i = 0; i < options.num_host_key_files; i++) {
		Key *key = load_private_key_autodetect(options.host_key_files[i]);
		if (key == NULL) {
d624 3
a626 2
			    options.host_key_files[i], strerror(errno));
			continue;
d628 9
a636 9
		switch(key->type){
		case KEY_RSA1:
			sensitive_data.ssh1_host_key = key;
			sensitive_data.have_ssh1_key = 1;
			break;
		case KEY_RSA:
		case KEY_DSA:
			sensitive_data.have_ssh2_key = 1;
			break;
a637 9
		sensitive_data.host_keys[i] = key;
	}
	if ((options.protocol & SSH_PROTO_1) && !sensitive_data.have_ssh1_key) {
		log("Disabling protocol version 1. Could not load host key");
		options.protocol &= ~SSH_PROTO_1;
	}
	if ((options.protocol & SSH_PROTO_2) && !sensitive_data.have_ssh2_key) {
		log("Disabling protocol version 2. Could not load host key");
		options.protocol &= ~SSH_PROTO_2;
d639 3
a641 1
	if (!(options.protocol & (SSH_PROTO_1|SSH_PROTO_2))) {
d659 1
a659 1
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) - SSH_KEY_BITS_RESERVED &&
d661 1
a661 1
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
d663 1
a663 1
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED;
d672 1
a672 1
	log_init(__progname, options.log_level, options.log_facility, log_stderr);
d679 1
a679 1
	if (!(debug_flag || inetd_flag || no_daemon_flag)) {
d688 1
a688 1
		fd = open(_PATH_TTY, O_RDWR | O_NOCTTY);
d696 4
a699 1
	log_init(__progname, options.log_level, options.log_facility, log_stderr);
d722 10
a731 2
		if (options.protocol & SSH_PROTO_1)
			generate_empheral_server_key();
d795 3
a797 3
			 * Record our pid in /var/run/sshd.pid to make it
			 * easier to kill the correct sshd.  We don't want to
			 * do this before the bind above because the bind will
d803 1
a803 1
				fprintf(f, "%u\n", (u_int) getpid());
d807 14
a820 2
		if (options.protocol & SSH_PROTO_1)
			generate_empheral_server_key();
d851 1
a851 1
			fdsetsz = howmany(maxfd+1, NFDBITS) * sizeof(fd_mask);
d862 4
a865 7
			ret = select(maxfd+1, fdset, NULL, NULL, NULL);
			if (ret < 0 && errno != EINTR)
				error("select: %.100s", strerror(errno));
			if (key_used && key_do_regen) {
				generate_empheral_server_key();
				key_used = 0;
				key_do_regen = 0;
a866 3
			if (ret < 0)
				continue;

d873 1
a873 1
					 * after successful authentication
d913 1
a913 1

d952 1
a952 1
						log_init(__progname, options.log_level, options.log_facility, log_stderr);
d966 1
a966 7
				if ((options.protocol & SSH_PROTO_1) &&
				    key_used == 0) {
					/* Schedule server key regeneration alarm. */
					signal(SIGALRM, key_regeneration_alarm);
					alarm(options.key_regeneration_time);
					key_used = 1;
				}
a1002 6
	/* Set keepalives if requested. */
	if (options.keepalives &&
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
	    sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));

d1018 1
a1018 1
		request_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, NULL);
d1046 2
a1047 2
	 * Check that the connection comes from a privileged port.
	 * Rhosts-Authentication only makes sense from priviledged
a1053 2
		debug("Rhosts Authentication disabled, "
		    "originating port not trusted.");
d1055 1
a1063 7
#ifdef AFS
	/* If machine has AFS, set process authentication group. */
	if (k_hasafs()) {
		k_setpag();
		k_unlog();
	}
#endif /* AFS */
d1093 1
a1093 1
do_ssh1_kex(void)
a1096 1
	int rsafail = 0;
d1098 3
a1100 3
	u_char session_key[SSH_SESSION_KEY_LENGTH];
	u_char cookie[8];
	u_int cipher_type, auth_mask, protocol_flags;
d1129 3
a1131 3
	packet_put_int(BN_num_bits(sensitive_data.server_key->rsa->n));
	packet_put_bignum(sensitive_data.server_key->rsa->e);
	packet_put_bignum(sensitive_data.server_key->rsa->n);
d1134 3
a1136 3
	packet_put_int(BN_num_bits(sensitive_data.ssh1_host_key->rsa->n));
	packet_put_bignum(sensitive_data.ssh1_host_key->rsa->e);
	packet_put_bignum(sensitive_data.ssh1_host_key->rsa->n);
d1162 2
a1163 1
	if (options.challenge_reponse_authentication == 1)
d1165 1
d1174 2
a1175 3
	debug("Sent %d bit server key and %d bit host key.",
	    BN_num_bits(sensitive_data.server_key->rsa->n),
	    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n));
d1207 14
a1220 16
	if (BN_cmp(sensitive_data.server_key->rsa->n, sensitive_data.ssh1_host_key->rsa->n) > 0) {
		/* Server key has bigger modulus. */
		if (BN_num_bits(sensitive_data.server_key->rsa->n) <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) <= 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) <= 0)
			rsafail++;
d1223 12
a1234 14
		if (BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) <
		    BN_num_bits(sensitive_data.server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) < 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) < 0)
			rsafail++;
d1238 2
a1239 2
	    sensitive_data.ssh1_host_key->rsa->n,
	    sensitive_data.server_key->rsa->n);
d1249 9
a1257 23
	if (!rsafail) {
		BN_mask_bits(session_key_int, sizeof(session_key) * 8);
		len = BN_num_bytes(session_key_int);
		if (len < 0 || len > sizeof(session_key)) {
			error("do_connection: bad session key len from %s: "
			    "session_key_int %d > sizeof(session_key) %lu",
			    get_remote_ipaddr(), len, (u_long)sizeof(session_key));
			rsafail++;
		} else {
			memset(session_key, 0, sizeof(session_key));
			BN_bn2bin(session_key_int,
			    session_key + sizeof(session_key) - len);
		}
	}
	if (rsafail) {
		log("do_connection: generating a fake encryption key");
		for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++) {
			if (i % 4 == 0)
				rand = arc4random();
			session_key[i] = rand & 0xff;
			rand >>= 8;
		}
	}
d1283 1
a1283 1
do_ssh2_kex(void)
a1297 6
	if (options.macs != NULL) {
		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
	}
	myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = list_hostkey_types();

d1354 6
a1359 6
	u_char *signature = NULL;
	u_char *server_host_key_blob = NULL;
	u_int sbloblen;
	u_int klen, kout;
	u_char *kbuf;
	u_char *hash;
a1362 5
	Key *hostkey;

	hostkey = get_hostkey_by_type(kex->hostkey_type);
	if (hostkey == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);
a1364 4
	/* generate DH key */
	dh = dh_new_group1();			/* XXX depends on 'kex' */
	dh_gen_key(dh);

d1381 3
d1392 1
a1392 1
	DHparams_print_fp(stderr, dh);
d1415 2
a1416 1
	key_to_blob(hostkey, &server_host_key_blob, &sbloblen);
a1432 1
	BN_free(dh_client_pub);
d1447 1
a1447 1
	key_sign(hostkey, &signature, &slen, hash, 20);
a1461 1
	BN_clear_free(shared_secret);
d1478 6
a1483 6
	u_char *signature = NULL;
	u_char *server_host_key_blob = NULL;
	u_int sbloblen;
	u_int klen, kout;
	u_char *kbuf;
	u_char *hash;
a1486 5
	Key *hostkey;

	hostkey = get_hostkey_by_type(kex->hostkey_type);
	if (hostkey == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);
a1500 4
	/* Compute our exchange value in parallel with the client */

	dh_gen_key(dh);

d1525 1
a1525 1
	DHparams_print_fp(stderr, dh);
d1548 2
a1549 1
	key_to_blob(hostkey, &server_host_key_blob, &sbloblen);
a1566 1
	BN_free(dh_client_pub);
d1581 1
a1581 1
	key_sign(hostkey, &signature, &slen, hash, 20);
a1595 1
	BN_clear_free(shared_secret);
d1601 1
@


1.132.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.132.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.175 2001/03/18 23:30:55 deraadt Exp $");
d54 1
a54 1
#include "sshpty.h"
d143 1
a143 1
	Key	*server_key;		/* ephemeral server key */
a147 1
	u_char	ssh1_cookie[SSH_SESSION_KEY_LENGTH];
d266 1
a266 1
generate_ephemeral_server_key(void)
a267 3
	u_int32_t rand = 0;
	int i;

d273 1
a274 8

	for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++) {
		if (i % 4 == 0)
			rand = arc4random();
		sensitive_data.ssh1_cookie[i] = rand & 0xff;
		rand >>= 8;
	}
	arc4random_stir();
d322 1
a322 2
				log("Did not receive identification string from %s.",
				    get_remote_ipaddr());
a362 6
	if (datafellows & SSH_BUG_SCANNER) {
		log("scanned from %s with %s.  Don't panic.",
		    get_remote_ipaddr(), client_version_string);
		fatal_cleanup();
	}

a430 1
	memset(sensitive_data.ssh1_cookie, 0, SSH_SESSION_KEY_LENGTH);
d715 1
a715 1
		log("sshd: no hostkeys available -- exiting.");
d793 1
a793 1
			generate_ephemeral_server_key();
d870 1
a870 1
			generate_ephemeral_server_key();
d916 1
a916 1
				generate_ephemeral_server_key();
d1316 8
a1340 10

			compute_session_id(session_id, cookie,
			    sensitive_data.ssh1_host_key->rsa->n,
			    sensitive_data.server_key->rsa->n);
			/*
			 * Xor the first 16 bytes of the session key with the
			 * session id.
			 */
			for (i = 0; i < 16; i++)
				session_key[i] ^= session_id[i];
a1343 4
		int bytes = BN_num_bytes(session_key_int);
		char *buf = xmalloc(bytes);
		MD5_CTX md;

d1345 6
a1350 14
		BN_bn2bin(session_key_int, buf);
		MD5_Init(&md);
		MD5_Update(&md, buf, bytes);
		MD5_Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
		MD5_Final(session_key, &md);
		MD5_Init(&md);
		MD5_Update(&md, session_key, 16);
		MD5_Update(&md, buf, bytes);
		MD5_Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
		MD5_Final(session_key + 16, &md);
		memset(buf, 0, bytes);
		xfree(buf);
		for (i = 0; i < 16; i++)
			session_id[i] = session_key[i] ^ session_key[i + 16];
a1351 3
	/* Destroy the private and public keys.  They will no longer be needed. */
	destroy_sensitive_data();

d1355 4
d1472 1
a1472 1
	dh_gen_key(dh, kex->we_need * 8);
d1615 1
a1615 1
	dh_gen_key(dh, kex->we_need * 8);
@


1.132.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.195 2001/04/15 16:58:03 markus Exp $");
a72 1
#include "dispatch.h"
a133 3
/* for rekeying XXX fixme */
Kex *xxx_kex;

d272 2
a273 2
	verbose("Generating %s%d bit RSA key.",
	    sensitive_data.server_key ? "new " : "", options.server_key_bits);
d276 2
a277 3
	sensitive_data.server_key = key_generate(KEY_RSA1,
	    options.server_key_bits);
	verbose("RSA key generation complete.");
d330 1
a330 1
		memset(buf, 0, sizeof(buf));
d338 2
a339 1
				buf[i] = 0;
d347 2
a348 1
				buf[i] = 0;
d414 1
d451 33
a575 1
	Key *key;
d585 1
a585 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDeiqQ46")) != -1) {
a609 3
		case 'e':
			log_stderr = 1;
			break;
d628 1
a628 5
			options.ports[options.num_ports++] = a2port(optarg);
			if (options.ports[options.num_ports-1] == 0) {
				fprintf(stderr, "Bad port number.\n");
				exit(1);
			}
a672 1
	SSLeay_add_all_algorithms();
d707 1
a707 2
		key = key_load_private(options.host_key_files[i], "", NULL);
		sensitive_data.host_keys[i] = key;
d709 2
a710 3
			error("Could not load host key: %s",
			    options.host_key_files[i]);
			sensitive_data.host_keys[i] = NULL;
d723 1
a723 2
		debug("private host key: #%d type %d %s", i, key->type,
		    key_type(key));
a795 3
	
	/* ignore SIGPIPE */
	signal(SIGPIPE, SIG_IGN);
d799 1
a799 1
		int s1;
d801 1
a801 1
		dup(s1);
a1108 1
			refuse(&req);
d1111 1
d1411 4
d1416 3
a1423 5
	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
	myproposal[PROPOSAL_ENC_ALGS_STOC] =
	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_STOC]);

d1430 20
a1449 6
	/* start key exchange */
	kex = kex_setup(myproposal);
	kex->server = 1;
	kex->client_version_string=client_version_string;
	kex->server_version_string=server_version_string;
	kex->load_host_key=&get_hostkey_by_type;
d1451 5
a1455 3
	xxx_kex = kex;

	dispatch_run(DISPATCH_BLOCK, &kex->done, kex);
d1457 3
a1459 2
	session_id2 = kex->session_id;
	session_id2_len = kex->session_id_len;
d1468 281
a1748 1
	debug("KEX done");
@


1.132.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.204 2001/08/23 17:59:31 camield Exp $");
a107 3
/* Flag indicating that the daemon should only test the configuration and keys. */
int test_flag = 0;

d161 1
a161 1
/* This is set to true when a signal is received. */
a162 1
int received_sigterm = 0;
d175 2
a176 1
void destroy_sensitive_data(void);
d178 2
a179 2
static void do_ssh1_kex(void);
static void do_ssh2_kex(void);
d184 1
a184 1
static void
d198 1
a198 1
static void
d209 1
a209 1
static void
d221 2
d224 1
a224 1
static void
d227 4
a230 1
	received_sigterm = sig;
d235 1
a235 1
 * reap any zombies left by exited children.
d237 1
a237 1
static void
d253 1
a253 1
static void
a255 2
	/* XXX no idea how fix this signal handler */

d270 1
a270 1
static void
d293 1
a293 1
static void
d302 1
a302 1
static void
d429 2
d454 1
a454 1
static char *
d479 1
a479 1
static Key *
d497 1
a497 1
static int
d555 1
a555 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDeiqtQ46")) != -1) {
d608 1
a608 4
			if ((options.login_grace_time = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid login grace time.\n");
				exit(1);
			}
d611 1
a611 4
			if ((options.key_regeneration_time = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid key regeneration interval.\n");
				exit(1);
			}
a624 3
		case 't':
			test_flag = 1;
			break;
a636 1
			fprintf(stderr, "  -t         Only test configuration file and keys\n");
a741 4
	/* Configuration looks good, so exit if in test mode. */
	if (test_flag)
		exit(0);

a857 16
		if (options.protocol & SSH_PROTO_1)
			generate_ephemeral_server_key();

		/*
		 * Arrange to restart on SIGHUP.  The handler needs
		 * listen_sock.
		 */
		signal(SIGHUP, sighup_handler);

		signal(SIGTERM, sigterm_handler);
		signal(SIGQUIT, sigterm_handler);

		/* Arrange SIGCHLD to be caught. */
		signal(SIGCHLD, main_sigchld_handler);

		/* Write out the pid file after the sigterm handler is setup */
d872 11
a917 7
			if (received_sigterm) {
				log("Received signal %d; terminating.",
				    received_sigterm);
				close_listen_socks();
				unlink(options.pid_file);
				exit(255);
			}
d1089 1
a1089 1
		request_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, 0);
d1129 1
a1129 1
#if defined(KRB4) && !defined(KRB5)
d1135 1
a1135 1
#endif /* KRB4 && !KRB5 */
d1155 7
d1171 1
a1171 1
static void
d1232 1
a1232 1
#if defined(KRB4) || defined(KRB5)
d1236 1
a1236 1
#if defined(AFS) || defined(KRB5)
a1238 2
#endif
#ifdef AFS
d1242 1
a1242 1
	if (options.challenge_response_authentication == 1)
d1392 1
a1392 1
static void
@


1.132.2.6
log
@Merge OpenSSH 3.0
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.132.2.5 2001/09/27 00:15:43 miod Exp $");
a73 1
#include "channels.h"
a658 1
	channel_set_af(IPv4or6);
@


1.132.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.132.2.6 2001/11/15 00:15:00 miod Exp $");
d331 1
a331 1
			log("Could not write ident string to %s", get_remote_ipaddr());
d339 1
a339 1
				log("Did not receive identification string from %s",
d1109 1
d1111 1
a1111 1
	/* Check whether logins are denied from this host. */
a1118 1
			debug("Connection refused by tcp wrapper");
d1120 2
a1121 2
			/* NOTREACHED */
			fatal("libwrap refuse returns");
d1123 1
a1125 1

d1152 1
a1152 1
		    "originating port %d not trusted.", remote_port);
@


1.132.2.8
log
@Merge OpenSSH 3.1.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.228 2002/02/27 21:23:13 stevesk Exp $");
d47 1
a47 1
#include <openssl/md5.h>
d163 1
a163 1
static volatile sig_atomic_t key_do_regen = 0;
d166 2
a167 2
static volatile sig_atomic_t received_sighup = 0;
static volatile sig_atomic_t received_sigterm = 0;
a178 4
/* options.max_startup sized array of fd ints */
int *startup_pipes = NULL;
int startup_pipe;		/* in child */

a196 10
static void
close_startup_pipes(void)
{
	int i;
	if (startup_pipes)
		for (i = 0; i < options.max_startups; i++)
			if (startup_pipes[i] != -1)
				close(startup_pipes[i]);
}

a204 2
	int save_errno = errno;

a206 1
	errno = save_errno;
a217 1
	close_startup_pipes();
d375 1
a375 1
	    remote_major, remote_minor, remote_version);
d386 1
a386 1
	switch (remote_major) {
d443 1
a443 1
	for (i = 0; i < options.num_host_key_files; i++) {
d456 1
a456 2
	Buffer b;
	char *p;
d458 2
a459 3

	buffer_init(&b);
	for (i = 0; i < options.num_host_key_files; i++) {
d463 1
a463 1
		switch (key->type) {
d466 2
a467 4
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			p = key_ssh_name(key);
			buffer_append(&b, p, strlen(p));
d471 5
a475 5
	buffer_append(&b, "\0", 1);
	p = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
	debug("list_hostkey_types: %s", p);
	return p;
d482 1
a482 1
	for (i = 0; i < options.num_host_key_files; i++) {
d519 2
a520 24
static void
usage(void)
{
	fprintf(stderr, "sshd version %s\n", SSH_VERSION);
	fprintf(stderr, "Usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -f file    Configuration file (default %s)\n", _PATH_SERVER_CONFIG_FILE);
	fprintf(stderr, "  -d         Debugging mode (multiple -d means more debugging)\n");
	fprintf(stderr, "  -i         Started from inetd\n");
	fprintf(stderr, "  -D         Do not fork into daemon mode\n");
	fprintf(stderr, "  -t         Only test configuration file and keys\n");
	fprintf(stderr, "  -q         Quiet (no logging)\n");
	fprintf(stderr, "  -p port    Listen on the specified port (default: 22)\n");
	fprintf(stderr, "  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
	fprintf(stderr, "  -g seconds Grace period for authentication (default: 600)\n");
	fprintf(stderr, "  -b bits    Size of server RSA key (default: 768 bits)\n");
	fprintf(stderr, "  -h file    File from which to read host key (default: %s)\n",
	    _PATH_HOST_KEY_FILE);
	fprintf(stderr, "  -u len     Maximum hostname length for utmp recording\n");
	fprintf(stderr, "  -4         Use IPv4 only\n");
	fprintf(stderr, "  -6         Use IPv6 only\n");
	fprintf(stderr, "  -o option  Process the option as if it was read from a configuration file.\n");
	exit(1);
}
d554 1
a554 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:o:dDeiqtQ46")) != -1) {
a635 5
		case 'o':
			if (process_server_config_line(&options, optarg,
			    "command-line", 0) != 0)
				exit(1);
			break;
d638 19
a656 2
			usage();
			break;
d667 2
a668 4
	    options.log_level == SYSLOG_LEVEL_NOT_SET ?
	    SYSLOG_LEVEL_INFO : options.log_level,
	    options.log_facility == SYSLOG_FACILITY_NOT_SET ?
	    SYSLOG_FACILITY_AUTH : options.log_facility,
d687 1
a687 1
	for (i = 0; i < options.num_host_key_files; i++)
d694 1
a694 1
	for (i = 0; i < options.num_host_key_files; i++) {
d703 1
a703 1
		switch (key->type) {
d791 1
a791 1

d843 1
a843 1
			    &on, sizeof(on));
d847 1
a847 1
			    &linger, sizeof(linger));
d939 1
a939 1
				    (int) received_sigterm);
a977 1
					close(newsock);
d1031 3
a1033 1
						close_startup_pipes();
d1092 1
a1092 1
	setsockopt(sock_in, SOL_SOCKET, SO_LINGER, &linger, sizeof(linger));
d1096 1
a1096 1
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on,
d1149 2
a1150 3
	if (options.rhosts_authentication &&
	    (remote_port >= IPPORT_RESERVED ||
	    remote_port < IPPORT_RESERVED / 2)) {
d1194 1
d1278 1
a1278 1
	packet_read_expect(SSH_CMSG_SESSION_KEY);
d1295 2
a1296 3
	if ((session_key_int = BN_new()) == NULL)
		fatal("do_ssh1_kex: BN_new failed");
	packet_get_bignum(session_key_int);
d1300 2
a1301 1
	packet_check_eom();
d1371 1
a1371 1
		u_char *buf = xmalloc(bytes);
@


1.131
log
@enable DES in SSH-1 clients only
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.130 2000/10/11 20:27:24 markus Exp $");
d334 4
@


1.130
log
@new cipher framework
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.129 2000/10/11 04:02:17 provos Exp $");
d1138 1
a1138 1
	packet_put_int(cipher_mask1());
d1179 1
a1179 1
	if (!(cipher_mask1() & (1 << cipher_type)))
@


1.129
log
@First rough implementation of the diffie-hellman group exchange.  The
client can ask the server for bigger groups to perform the diffie-hellman
in, thus increasing the attack complexity when using ciphers with longer
keys.  University of Windsor provided network, T the company.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.128 2000/09/17 15:38:59 markus Exp $");
a49 1
#include "cipher.h"
d1179 1
a1179 1
	if (!(cipher_mask() & (1 << cipher_type)))
d1345 3
d1469 3
@


1.128
log
@fix DEBUG_KEXDH
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.127 2000/09/12 20:53:10 markus Exp $");
d66 1
d171 3
d1284 1
a1284 9
	int payload_len, dlen;
	int slen;
	unsigned int klen, kout;
	unsigned char *signature = NULL;
	unsigned char *server_host_key_blob = NULL;
	unsigned int sbloblen;
	DH *dh;
	BIGNUM *dh_client_pub = 0;
	BIGNUM *shared_secret = 0;
a1285 2
	unsigned char *kbuf;
	unsigned char *hash;
d1305 53
a1358 1

d1409 2
a1410 1
	dsa_make_key_blob(sensitive_data.dsa_host_key, &server_host_key_blob, &sbloblen);
d1460 3
d1464 25
a1488 2
	debug("send SSH2_MSG_NEWKEYS.");
	packet_start(SSH2_MSG_NEWKEYS);
a1490 1
	debug("done: send SSH2_MSG_NEWKEYS.");
d1492 49
a1540 3
	debug("Wait SSH2_MSG_NEWKEYS.");
	packet_read_expect(&payload_len, SSH2_MSG_NEWKEYS);
	debug("GOT SSH2_MSG_NEWKEYS.");
d1542 16
d1559 22
a1580 3
	/* send 1st encrypted/maced/compressed message */
	packet_start(SSH2_MSG_IGNORE);
	packet_put_cstring("markus");
d1582 2
d1585 6
a1590 2
#endif
	debug("done: KEX2.");
d1592 1
@


1.127
log
@multiple debug levels
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.126 2000/09/07 20:27:55 deraadt Exp $");
d1324 1
a1324 1
	bignum_print(dh_client_pub);
d1334 1
a1334 1
	bignum_print(dh->p);
d1336 1
a1336 1
	bignum_print(dh->g);
d1338 1
a1338 1
	bignum_print(dh->pub_key);
d1340 1
@


1.126
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.125 2000/08/17 20:06:34 markus Exp $");
d506 9
a514 2
			debug_flag = 1;
			options.log_level = SYSLOG_LEVEL_DEBUG;
d530 4
a533 2
			if (options.num_ports >= MAX_PORTS)
				fatal("too many ports.\n");
d559 1
a559 1
			fprintf(stderr, "  -d         Debugging mode\n");
@


1.125
log
@sshd -u len, similar to telnetd
@
text
@d5 2
a6 3
 * Created: Fri Mar 17 17:09:28 1995 ylo
 * This program is the ssh daemon.  It listens for connections from clients, and
 * performs authentication, executes use commands or shell, and forwards
d8 2
a9 2
 * connection.  This can also handle forwarding of X11, TCP/IP, and authentication
 * agent connections.
d11 29
a39 2
 * SSH2 implementation,
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.124 2000/07/22 09:14:37 markus Exp $");
@


1.124
log
@random early drop; ok theo, niels
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.123 2000/07/18 01:25:01 djm Exp $");
d137 3
d468 1
a468 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:diqQ46")) != EOF) {
d515 3
d533 1
@


1.123
log
@Another closing of stdin; ok deraadt
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.122 2000/07/11 08:11:34 deraadt Exp $");
d398 29
d846 2
a847 1
				if (startups >= options.max_startups) {
@


1.122
log
@make MaxStartups code still work with -d; djm
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.121 2000/07/05 21:35:56 provos Exp $");
d637 1
@


1.121
log
@typo
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.120 2000/06/26 21:59:18 markus Exp $");
d848 1
@


1.120
log
@MaxStartups: limit number of unauthenticated connections, work by theo and me
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.119 2000/06/22 16:32:27 markus Exp $");
d348 1
a348 1
			packet_disconnect("Your ssh version is too old and"
@


1.119
log
@missing atomicio; report from Steve.Marquess@@DET.AMEDD.ARMY.MIL
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.118 2000/05/25 20:45:20 markus Exp $");
d398 3
d409 1
a409 1
	int opt, sock_in = 0, sock_out = 0, newsock, i, fdsetsz, on = 1;
d422 2
d745 1
d753 1
d758 4
a761 2
		fdsetsz = howmany(maxfd, NFDBITS) * sizeof(fd_mask);
		fdset = (fd_set *)xmalloc(fdsetsz);
d770 4
a773 1
			/* Wait in select until there is a connection. */
d775 1
d778 5
d788 13
d804 30
a833 17
			fromlen = sizeof(from);
			newsock = accept(listen_socks[i], (struct sockaddr *)&from,
			    &fromlen);
			if (newsock < 0) {
				if (errno != EINTR && errno != EWOULDBLOCK)
					error("accept: %.100s", strerror(errno));
				continue;
			}
			if (fcntl(newsock, F_SETFL, 0) < 0) {
				error("newsock del O_NONBLOCK: %s", strerror(errno));
				continue;
			}
			/*
			 * Got connection.  Fork a child to handle it, unless
			 * we are in debugging mode.
			 */
			if (debug_flag) {
d835 2
a836 3
				 * In debugging mode.  Close the listening
				 * socket, and start processing the
				 * connection without forking.
d838 1
a838 13
				debug("Server will not fork when running in debugging mode.");
				close_listen_socks();
				sock_in = newsock;
				sock_out = newsock;
				pid = getpid();
				break;
			} else {
				/*
				 * Normal production daemon.  Fork, and have
				 * the child process the connection. The
				 * parent continues listening.
				 */
				if ((pid = fork()) == 0) {
d840 3
a842 3
					 * Child.  Close the listening socket, and start using the
					 * accepted socket.  Reinitialize logging (since our pid has
					 * changed).  We break out of the loop to handle the connection.
d844 1
d848 1
a848 1
					log_init(av0, options.log_level, options.log_facility, log_stderr);
d850 24
a874 1
			}
d876 7
a882 5
			/* Parent.  Stay in the loop. */
			if (pid < 0)
				error("fork: %.100s", strerror(errno));
			else
				debug("Forked child %d.", pid);
d884 2
a885 2
			/* Mark that the key has been used (it was "given" to the child). */
			key_used = 1;
d887 1
a887 1
			arc4random_stir();
d889 3
a891 3
			/* Close the new socket (the child is now taking care of it). */
			close(newsock);
			} /* for (i = 0; i < num_listen_socks; i++) */
@


1.118
log
@split kexinit/kexdh, factor out common code
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.117 2000/05/18 13:27:36 djm Exp $");
d295 1
a295 1
			if (read(sock_in, &buf[i], 1) != 1) {
@


1.117
log
@Check for RSA key presence before freeing them. From
kevin_oconnor@@standardandpoors.com. ok Markus.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.116 2000/05/17 08:20:16 markus Exp $");
a1151 1
	char *ptr;
a1162 1
	char *sprop[PROPOSAL_MAX];
d1170 1
a1170 19

	debug("Sending KEX init.");

	for (i = 0; i < PROPOSAL_MAX; i++)
		sprop[i] = xstrdup(myproposal[i]);
	server_kexinit = kex_init(sprop);
	packet_start(SSH2_MSG_KEXINIT);
	packet_put_raw(buffer_ptr(server_kexinit), buffer_len(server_kexinit));	
	packet_send();
	packet_write_wait();

	debug("done");

	packet_read_expect(&payload_len, SSH2_MSG_KEXINIT);

	/*
	 * save raw KEXINIT payload in buffer. this is used during
	 * computation of the session_id and the session keys.
	 */
a1172 2
	ptr = packet_get_raw(&payload_len);
	buffer_append(client_kexinit, ptr, payload_len);
d1174 5
a1178 16
	/* skip cookie */
	for (i = 0; i < 16; i++)
		(void) packet_get_char();
	/* save kex init proposal strings */
	for (i = 0; i < PROPOSAL_MAX; i++) {
		cprop[i] = packet_get_string(NULL);
		debug("got kexinit string: %s", cprop[i]);
	}

	i = (int) packet_get_char();
	debug("first kex follow == %d", i);
	i = packet_get_int();
	debug("reserved == %d", i);

	debug("done read kexinit");
	kex = kex_choose_conf(cprop, sprop, 1);
@


1.116
log
@enable nonblocking IO for sshd w/ proto 1, too; split out common code
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.115 2000/05/03 10:21:49 markus Exp $");
d388 6
a393 3
	RSA_free(public_key);
	RSA_free(sensitive_data.private_key);
	RSA_free(sensitive_data.host_key);
@


1.115
log
@s/DsaKey/HostDSAKey/, document option
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.114 2000/05/02 12:44:38 markus Exp $");
a258 15
}

char *
chop(char *s)
{
	char *t = s;
	while (*t) {
		if(*t == '\n' || *t == '\r') {
			*t = '\0';
			return s;
		}
		t++;
	}
	return s;

@


1.115.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.118 2000/05/25 20:45:20 markus Exp $");
d261 15
d403 3
a405 6
	if (public_key)
		RSA_free(public_key);
	if (sensitive_data.private_key)
		RSA_free(sensitive_data.private_key);
	if (sensitive_data.host_key)
		RSA_free(sensitive_data.host_key);
d1164 1
d1176 1
d1184 19
a1202 1
	server_kexinit = kex_init(myproposal);
d1205 2
d1208 16
a1223 5
	/* algorithm negotiation */
	kex_exchange_kexinit(server_kexinit, client_kexinit, cprop);
	kex = kex_choose_conf(cprop, myproposal, 1);
	for (i = 0; i < PROPOSAL_MAX; i++)
		xfree(cprop[i]);
@


1.115.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.125 2000/08/17 20:06:34 markus Exp $");
a136 3
/* record remote hostname or ip */
unsigned int utmp_len = MAXHOSTNAMELEN;

d295 1
a295 1
			if (atomicio(read, sock_in, &buf[i], 1) != 1) {
d348 1
a348 1
			packet_disconnect("Your ssh version is too old and "
a398 32
 * returns 1 if connection should be dropped, 0 otherwise.
 * dropping starts at connection #max_startups_begin with a probability
 * of (max_startups_rate/100). the probability increases linearly until
 * all connections are dropped for startups > max_startups
 */
int
drop_connection(int startups)
{
	double p, r;

	if (startups < options.max_startups_begin)
		return 0;
	if (startups >= options.max_startups)
		return 1;
	if (options.max_startups_rate == 100)
		return 1;

	p  = 100 - options.max_startups_rate;
	p *= startups - options.max_startups_begin;
	p /= (double) (options.max_startups - options.max_startups_begin);
	p += options.max_startups_rate;
	p /= 100.0;
	r = arc4random() / (double) UINT_MAX;

	debug("drop_connection: p %g, r %g", p, r);
	return (r < p) ? 1 : 0;
}

int *startup_pipes = NULL;	/* options.max_startup sized array of fd ints */
int startup_pipe;		/* in child */

/*
d406 1
a406 1
	int opt, sock_in = 0, sock_out = 0, newsock, j, i, fdsetsz, on = 1;
a418 2
	int startup_p[2];
	int startups = 0;
d431 1
a431 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:diqQ46")) != EOF) {
a477 3
		case 'u':
			utmp_len = atoi(optarg);
			break;
a492 1
			fprintf(stderr, "  -u len     Maximum hostname length for utmp recording\n");
a631 1
		startup_pipe = -1;
a739 1

a746 1
		fdset = NULL;
d751 2
a752 4
		/* pipes connected to unauthenticated childs */
		startup_pipes = xmalloc(options.max_startups * sizeof(int));
		for (i = 0; i < options.max_startups; i++)
			startup_pipes[i] = -1;
d761 1
a761 4
			if (fdset != NULL)
				xfree(fdset);
			fdsetsz = howmany(maxfd, NFDBITS) * sizeof(fd_mask);
			fdset = (fd_set *)xmalloc(fdsetsz);
a762 1

a764 5
			for (i = 0; i < options.max_startups; i++)
				if (startup_pipes[i] != -1)
					FD_SET(startup_pipes[i], fdset);

			/* Wait in select until there is a connection. */
a769 13
			for (i = 0; i < options.max_startups; i++)
				if (startup_pipes[i] != -1 &&
				    FD_ISSET(startup_pipes[i], fdset)) {
					/*
					 * the read end of the pipe is ready
					 * if the child has closed the pipe
					 * after successfull authentication
					 * or if the child has died
					 */
					close(startup_pipes[i]);
					startup_pipes[i] = -1;
					startups--;
				}
d773 29
a801 31
				fromlen = sizeof(from);
				newsock = accept(listen_socks[i], (struct sockaddr *)&from,
				    &fromlen);
				if (newsock < 0) {
					if (errno != EINTR && errno != EWOULDBLOCK)
						error("accept: %.100s", strerror(errno));
					continue;
				}
				if (fcntl(newsock, F_SETFL, 0) < 0) {
					error("newsock del O_NONBLOCK: %s", strerror(errno));
					continue;
				}
				if (drop_connection(startups) == 1) {
					debug("drop connection #%d", startups);
					close(newsock);
					continue;
				}
				if (pipe(startup_p) == -1) {
					close(newsock);
					continue;
				}

				for (j = 0; j < options.max_startups; j++)
					if (startup_pipes[j] == -1) {
						startup_pipes[j] = startup_p[0];
						if (maxfd < startup_p[0])
							maxfd = startup_p[0];
						startups++;
						break;
					}
				
d803 3
a805 2
				 * Got connection.  Fork a child to handle it, unless
				 * we are in debugging mode.
d807 1
a807 1
				if (debug_flag) {
d809 3
a811 3
					 * In debugging mode.  Close the listening
					 * socket, and start processing the
					 * connection without forking.
a812 1
					debug("Server will not fork when running in debugging mode.");
d816 1
a816 2
					startup_pipe = -1;
					pid = getpid();
a817 24
				} else {
					/*
					 * Normal production daemon.  Fork, and have
					 * the child process the connection. The
					 * parent continues listening.
					 */
					if ((pid = fork()) == 0) {
						/*
						 * Child.  Close the listening and max_startup
						 * sockets.  Start using the accepted socket.
						 * Reinitialize logging (since our pid has
						 * changed).  We break out of the loop to handle
						 * the connection.
						 */
						startup_pipe = startup_p[1];
						for (j = 0; j < options.max_startups; j++)
							if (startup_pipes[j] != -1)
								close(startup_pipes[j]);
						close_listen_socks();
						sock_in = newsock;
						sock_out = newsock;
						log_init(av0, options.log_level, options.log_facility, log_stderr);
						break;
					}
d819 1
d821 5
a825 5
				/* Parent.  Stay in the loop. */
				if (pid < 0)
					error("fork: %.100s", strerror(errno));
				else
					debug("Forked child %d.", pid);
d827 2
a828 1
				close(startup_p[1]);
d830 1
a830 2
				/* Mark that the key has been used (it was "given" to the child). */
				key_used = 1;
d832 3
a834 5
				arc4random_stir();

				/* Close the new socket (the child is now taking care of it). */
				close(newsock);
			}
@


1.115.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 3
a7 2
 * This program is the ssh daemon.  It listens for connections from clients,
 * and performs authentication, executes use commands or shell, and forwards
d9 2
a10 2
 * connection.  This can also handle forwarding of X11, TCP/IP, and
 * authentication agent connections.
d12 2
a13 29
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * SSH2 implementation:
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.132 2000/10/13 18:34:46 markus Exp $");
d24 1
a39 1
#include "dh.h"
a143 3
void ssh_dh1_server(Kex *, Buffer *_kexinit, Buffer *);
void ssh_dhgex_server(Kex *, Buffer *_kexinit, Buffer *);

a304 4
				/* Kludge for F-Secure Macintosh < 1.0.2 */
				if (i == 12 &&
				    strncmp(buf, "SSH-1.5-W1.0", 12) == 0)
					break;
d480 2
a481 9
			if (0 == debug_flag) {
				debug_flag = 1;
				options.log_level = SYSLOG_LEVEL_DEBUG1;
			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3) {
				options.log_level++;
			} else {
				fprintf(stderr, "Too high debugging level.\n");
				exit(1);
			}
d497 2
a498 4
			if (options.num_ports >= MAX_PORTS) {
				fprintf(stderr, "too many ports.\n");
				exit(1);
			}
d524 1
a524 1
			fprintf(stderr, "  -d         Debugging mode (multiple -d means more debugging)\n");
d1100 1
a1100 1
	packet_put_int(cipher_mask_ssh1(0));
d1141 1
a1141 1
	if (!(cipher_mask_ssh1(0) & (1 << cipher_type)))
d1245 9
a1253 1
	int payload_len;
d1255 2
d1276 1
a1276 31
	switch (kex->kex_type) {
	case DH_GRP1_SHA1:
		ssh_dh1_server(kex, client_kexinit, server_kexinit);
		break;
	case DH_GEX_SHA1:
		ssh_dhgex_server(kex, client_kexinit, server_kexinit);
		break;
	default:
		fatal("Unsupported key exchange %d", kex->kex_type);
	}

	debug("send SSH2_MSG_NEWKEYS.");
	packet_start(SSH2_MSG_NEWKEYS);
	packet_send();
	packet_write_wait();
	debug("done: send SSH2_MSG_NEWKEYS.");

	debug("Wait SSH2_MSG_NEWKEYS.");
	packet_read_expect(&payload_len, SSH2_MSG_NEWKEYS);
	debug("GOT SSH2_MSG_NEWKEYS.");

#ifdef DEBUG_KEXDH
	/* send 1st encrypted/maced/compressed message */
	packet_start(SSH2_MSG_IGNORE);
	packet_put_cstring("markus");
	packet_send();
	packet_write_wait();
#endif

	debug("done: KEX2.");
}
a1277 25
/*
 * SSH2 key exchange
 */

/* diffie-hellman-group1-sha1 */

void
ssh_dh1_server(Kex *kex, Buffer *client_kexinit, Buffer *server_kexinit)
{
#ifdef DEBUG_KEXDH
	int i;
#endif
	int payload_len, dlen;
	int slen;
	unsigned char *signature = NULL;
	unsigned char *server_host_key_blob = NULL;
	unsigned int sbloblen;
	unsigned int klen, kout;
	unsigned char *kbuf;
	unsigned char *hash;
	BIGNUM *shared_secret = 0;
	DH *dh;
	BIGNUM *dh_client_pub = 0;

/* KEXDH */
d1289 1
a1289 1
	BN_print_fp(stderr, dh_client_pub);
d1299 1
a1299 1
	BN_print_fp(stderr, dh->p);
d1301 1
a1301 1
	bn_print(dh->g);
d1303 1
a1303 1
	BN_print_fp(stderr, dh->pub_key);
a1304 1
        DHparams_print_fp(stderr, dh);
d1327 1
a1327 2
	dsa_make_key_blob(sensitive_data.dsa_host_key,
			  &server_host_key_blob, &sbloblen);
a1376 1
}
d1378 2
a1379 30
/* diffie-hellman-group-exchange-sha1 */

void
ssh_dhgex_server(Kex *kex, Buffer *client_kexinit, Buffer *server_kexinit)
{
#ifdef DEBUG_KEXDH
	int i;
#endif
	int payload_len, dlen;
	int slen, nbits;
	unsigned char *signature = NULL;
	unsigned char *server_host_key_blob = NULL;
	unsigned int sbloblen;
	unsigned int klen, kout;
	unsigned char *kbuf;
	unsigned char *hash;
	BIGNUM *shared_secret = 0;
	DH *dh;
	BIGNUM *dh_client_pub = 0;

/* KEXDHGEX */
	debug("Wait SSH2_MSG_KEX_DH_GEX_REQUEST.");
	packet_read_expect(&payload_len, SSH2_MSG_KEX_DH_GEX_REQUEST);
	nbits = packet_get_int();
	dh = choose_dh(nbits);

	debug("Sending SSH2_MSG_KEX_DH_GEX_GROUP.");
	packet_start(SSH2_MSG_KEX_DH_GEX_GROUP);
	packet_put_bignum2(dh->p);
	packet_put_bignum2(dh->g);
d1382 1
d1384 3
a1386 8
	debug("Wait SSH2_MSG_KEX_DH_GEX_INIT.");
	packet_read_expect(&payload_len, SSH2_MSG_KEX_DH_GEX_INIT);

	/* key, cert */
	dh_client_pub = BN_new();
	if (dh_client_pub == NULL)
		fatal("dh_client_pub == NULL");
	packet_get_bignum2(dh_client_pub, &dlen);
d1389 3
a1391 79
	fprintf(stderr, "\ndh_client_pub= ");
	BN_print_fp(stderr, dh_client_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_client_pub));
#endif

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\np= ");
	BN_print_fp(stderr, dh->p);
	fprintf(stderr, "\ng= ");
	bn_print(dh->g);
	fprintf(stderr, "\npub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
        DHparams_print_fp(stderr, dh);
#endif
	if (!dh_pub_is_valid(dh, dh_client_pub))
		packet_disconnect("bad client public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_client_pub, dh);

#ifdef DEBUG_KEXDH
	debug("shared secret: len %d/%d", klen, kout);
	fprintf(stderr, "shared secret == ");
	for (i = 0; i< kout; i++)
		fprintf(stderr, "%02x", (kbuf[i])&0xff);
	fprintf(stderr, "\n");
#endif
	shared_secret = BN_new();

	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	/* XXX precompute? */
	dsa_make_key_blob(sensitive_data.dsa_host_key,
			  &server_host_key_blob, &sbloblen);

	/* calc H */			/* XXX depends on 'kex' */
	hash = kex_hash_gex(
	    client_version_string,
	    server_version_string,
	    buffer_ptr(client_kexinit), buffer_len(client_kexinit),
	    buffer_ptr(server_kexinit), buffer_len(server_kexinit),
	    (char *)server_host_key_blob, sbloblen,
	    nbits, dh->p, dh->g,
	    dh_client_pub,
	    dh->pub_key,
	    shared_secret
	);
	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);
#ifdef DEBUG_KEXDH
	fprintf(stderr, "hash == ");
	for (i = 0; i< 20; i++)
		fprintf(stderr, "%02x", (hash[i])&0xff);
	fprintf(stderr, "\n");
#endif
	/* save session id := H */
	/* XXX hashlen depends on KEX */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);

	/* sign H */
	/* XXX hashlen depends on KEX */
	dsa_sign(sensitive_data.dsa_host_key, &signature, &slen, hash, 20);

	destroy_sensitive_data();

	/* send server hostkey, DH pubkey 'f' and singed H */
	packet_start(SSH2_MSG_KEX_DH_GEX_REPLY);
	packet_put_string((char *)server_host_key_blob, sbloblen);
	packet_put_bignum2(dh->pub_key);	/* f */
	packet_put_string((char *)signature, slen);
a1392 2
	xfree(signature);
	xfree(server_host_key_blob);
d1394 2
a1395 6

	kex_derive_keys(kex, hash, shared_secret);
	packet_set_kex(kex);

	/* have keys, free DH */
	DH_free(dh);
a1396 1

@


1.115.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.167 2001/02/12 23:26:20 markus Exp $");
a44 7
#include <openssl/dh.h>
#include <openssl/bn.h>
#include <openssl/hmac.h>

#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
d47 1
a50 1
#include "log.h"
d55 5
a59 1
#include "cipher.h"
d61 2
d64 1
d66 2
a69 5
#include "pathnames.h"
#include "atomicio.h"
#include "canohost.h"
#include "auth.h"
#include "misc.h"
a81 2
extern char *__progname;

d86 1
a86 1
char *config_file_name = _PATH_SERVER_CONFIG_FILE;
a104 3
/* Flag indicating that sshd should not detach and become a daemon. */
int no_daemon_flag = 0;

d108 3
d138 3
a140 5
	Key	*server_key;		/* empheral server key */
	Key	*ssh1_host_key;		/* ssh1 host key */
	Key	**host_keys;		/* all private host keys */
	int	have_ssh1_key;
	int	have_ssh2_key;
d144 2
a145 2
 * Flag indicating whether the RSA server key needs to be regenerated.
 * Is set in the SIGALRM handler and cleared when the key is regenerated.
d147 1
a147 1
int key_do_regen = 0;
d152 4
d157 1
a157 1
u_char session_id[16];
d160 1
a160 1
u_char *session_id2 = NULL;
d164 1
a164 1
u_int utmp_len = MAXHOSTNAMELEN;
d167 2
a168 2
void do_ssh1_kex(void);
void do_ssh2_kex(void);
d202 1
a202 1
sighup_restart(void)
d207 1
a207 1
	log("RESTART FAILED: av[0]='%.100s', error: %.100s.", saved_argv[0], strerror(errno));
d262 1
a262 12
void
generate_empheral_server_key(void)
{
	log("Generating %s%d bit RSA key.", sensitive_data.server_key ? "new " : "",
	    options.server_key_bits);
	if (sensitive_data.server_key != NULL)
		key_free(sensitive_data.server_key);
	sensitive_data.server_key = key_generate(KEY_RSA1, options.server_key_bits);
	arc4random_stir();
	log("RSA key generation complete.");
}

d267 23
a289 1
	signal(SIGALRM, SIG_DFL);
a290 1
	key_do_regen = 1;
d325 1
a325 2
		/* Read other side's version identification. */
		memset(buf, 0, sizeof(buf)); 
a419 1
/* Destroy the host and server keys.  They will no longer be needed. */
d423 9
a431 83
	int i;

	if (sensitive_data.server_key) {
		key_free(sensitive_data.server_key);
		sensitive_data.server_key = NULL;
	}
	for(i = 0; i < options.num_host_key_files; i++) {
		if (sensitive_data.host_keys[i]) {
			key_free(sensitive_data.host_keys[i]);
			sensitive_data.host_keys[i] = NULL;
		}
	}
	sensitive_data.ssh1_host_key = NULL;
}
Key *
load_private_key_autodetect(const char *filename)
{
	struct stat st;
	int type;
	Key *public, *private;

	if (stat(filename, &st) < 0) {
		perror(filename);
		return NULL;
	}
	/*
	 * try to load the public key. right now this only works for RSA1,
	 * since SSH2 keys are fully encrypted
	 */
	type = KEY_RSA1;
	public = key_new(type);
	if (!load_public_key(filename, public, NULL)) {
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
	}
	key_free(public);

	/* Ok, try key with empty passphrase */
	private = key_new(type);
	if (load_private_key(filename, "", private, NULL)) {
		debug("load_private_key_autodetect: type %d %s",
		    private->type, key_type(private));
		return private;
	}
	key_free(private);
	return NULL;
}

char *
list_hostkey_types(void)
{
	static char buf[1024];
	int i;
	buf[0] = '\0';
	for(i = 0; i < options.num_host_key_files; i++) {
		Key *key = sensitive_data.host_keys[i];
		if (key == NULL)
			continue;
		switch(key->type) {
		case KEY_RSA:
		case KEY_DSA:
			strlcat(buf, key_ssh_name(key), sizeof buf);
			strlcat(buf, ",", sizeof buf);
			break;
		}
	}
	i = strlen(buf);
	if (i > 0 && buf[i-1] == ',')
		buf[i-1] = '\0';
	debug("list_hostkey_types: %s", buf);
	return buf;
}

Key *
get_hostkey_by_type(int type)
{
	int i;
	for(i = 0; i < options.num_host_key_files; i++) {
		Key *key = sensitive_data.host_keys[i];
		if (key != NULL && key->type == type)
			return key;
	}
	return NULL;
d477 1
a488 1
	int ret, key_used = 0;
d490 1
a490 1
	/* Save argv. */
d492 4
d501 1
a501 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:u:dDiqQ46")) != -1) {
a522 3
		case 'D':
			no_daemon_flag = 1;
			break;
d527 1
a527 1
			/* ignored */
d550 1
a550 5
			if (options.num_host_key_files >= MAX_HOSTKEYS) {
				fprintf(stderr, "too many host keys.\n");
				exit(1);
			}
			options.host_key_files[options.num_host_key_files++] = optarg;
d563 1
a563 1
			fprintf(stderr, "Usage: %s [options]\n", __progname);
d565 1
a565 1
			fprintf(stderr, "  -f file    Configuration file (default %s)\n", _PATH_SERVER_CONFIG_FILE);
a567 1
			fprintf(stderr, "  -D         Do not fork into daemon mode\n");
d571 1
a571 1
			fprintf(stderr, "  -g seconds Grace period for authentication (default: 600)\n");
d574 1
a574 1
			    _PATH_HOST_KEY_FILE);
d586 1
a586 1
	log_init(__progname,
d589 1
a589 1
	    !inetd_flag);
d605 18
a622 12
	/* load private host keys */
	sensitive_data.host_keys = xmalloc(options.num_host_key_files*sizeof(Key*));
	for(i = 0; i < options.num_host_key_files; i++)
		sensitive_data.host_keys[i] = NULL;
	sensitive_data.server_key = NULL;
	sensitive_data.ssh1_host_key = NULL;
	sensitive_data.have_ssh1_key = 0;
	sensitive_data.have_ssh2_key = 0;

	for(i = 0; i < options.num_host_key_files; i++) {
		Key *key = load_private_key_autodetect(options.host_key_files[i]);
		if (key == NULL) {
d624 3
a626 2
			    options.host_key_files[i], strerror(errno));
			continue;
d628 9
a636 9
		switch(key->type){
		case KEY_RSA1:
			sensitive_data.ssh1_host_key = key;
			sensitive_data.have_ssh1_key = 1;
			break;
		case KEY_RSA:
		case KEY_DSA:
			sensitive_data.have_ssh2_key = 1;
			break;
a637 9
		sensitive_data.host_keys[i] = key;
	}
	if ((options.protocol & SSH_PROTO_1) && !sensitive_data.have_ssh1_key) {
		log("Disabling protocol version 1. Could not load host key");
		options.protocol &= ~SSH_PROTO_1;
	}
	if ((options.protocol & SSH_PROTO_2) && !sensitive_data.have_ssh2_key) {
		log("Disabling protocol version 2. Could not load host key");
		options.protocol &= ~SSH_PROTO_2;
d639 3
a641 1
	if (!(options.protocol & (SSH_PROTO_1|SSH_PROTO_2))) {
d659 1
a659 1
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) - SSH_KEY_BITS_RESERVED &&
d661 1
a661 1
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
d663 1
a663 1
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED;
d672 1
a672 1
	log_init(__progname, options.log_level, options.log_facility, log_stderr);
d679 1
a679 1
	if (!(debug_flag || inetd_flag || no_daemon_flag)) {
d688 1
a688 1
		fd = open(_PATH_TTY, O_RDWR | O_NOCTTY);
d696 4
a699 1
	log_init(__progname, options.log_level, options.log_facility, log_stderr);
d722 10
a731 2
		if (options.protocol & SSH_PROTO_1)
			generate_empheral_server_key();
d795 3
a797 3
			 * Record our pid in /var/run/sshd.pid to make it
			 * easier to kill the correct sshd.  We don't want to
			 * do this before the bind above because the bind will
d803 1
a803 1
				fprintf(f, "%u\n", (u_int) getpid());
d807 14
a820 2
		if (options.protocol & SSH_PROTO_1)
			generate_empheral_server_key();
d851 1
a851 1
			fdsetsz = howmany(maxfd+1, NFDBITS) * sizeof(fd_mask);
d862 4
a865 7
			ret = select(maxfd+1, fdset, NULL, NULL, NULL);
			if (ret < 0 && errno != EINTR)
				error("select: %.100s", strerror(errno));
			if (key_used && key_do_regen) {
				generate_empheral_server_key();
				key_used = 0;
				key_do_regen = 0;
a866 3
			if (ret < 0)
				continue;

d873 1
a873 1
					 * after successful authentication
d913 1
a913 1

d952 1
a952 1
						log_init(__progname, options.log_level, options.log_facility, log_stderr);
d966 1
a966 7
				if ((options.protocol & SSH_PROTO_1) &&
				    key_used == 0) {
					/* Schedule server key regeneration alarm. */
					signal(SIGALRM, key_regeneration_alarm);
					alarm(options.key_regeneration_time);
					key_used = 1;
				}
a1002 6
	/* Set keepalives if requested. */
	if (options.keepalives &&
	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
	    sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));

d1018 1
a1018 1
		request_init(&req, RQ_DAEMON, __progname, RQ_FILE, sock_in, NULL);
d1046 2
a1047 2
	 * Check that the connection comes from a privileged port.
	 * Rhosts-Authentication only makes sense from priviledged
a1053 2
		debug("Rhosts Authentication disabled, "
		    "originating port not trusted.");
d1055 1
a1063 7
#ifdef AFS
	/* If machine has AFS, set process authentication group. */
	if (k_hasafs()) {
		k_setpag();
		k_unlog();
	}
#endif /* AFS */
d1093 1
a1093 1
do_ssh1_kex(void)
a1096 1
	int rsafail = 0;
d1098 3
a1100 3
	u_char session_key[SSH_SESSION_KEY_LENGTH];
	u_char cookie[8];
	u_int cipher_type, auth_mask, protocol_flags;
d1129 3
a1131 3
	packet_put_int(BN_num_bits(sensitive_data.server_key->rsa->n));
	packet_put_bignum(sensitive_data.server_key->rsa->e);
	packet_put_bignum(sensitive_data.server_key->rsa->n);
d1134 3
a1136 3
	packet_put_int(BN_num_bits(sensitive_data.ssh1_host_key->rsa->n));
	packet_put_bignum(sensitive_data.ssh1_host_key->rsa->e);
	packet_put_bignum(sensitive_data.ssh1_host_key->rsa->n);
d1162 2
a1163 1
	if (options.challenge_reponse_authentication == 1)
d1165 1
d1174 2
a1175 3
	debug("Sent %d bit server key and %d bit host key.",
	    BN_num_bits(sensitive_data.server_key->rsa->n),
	    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n));
d1207 14
a1220 16
	if (BN_cmp(sensitive_data.server_key->rsa->n, sensitive_data.ssh1_host_key->rsa->n) > 0) {
		/* Server key has bigger modulus. */
		if (BN_num_bits(sensitive_data.server_key->rsa->n) <
		    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) <= 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) <= 0)
			rsafail++;
d1223 12
a1234 14
		if (BN_num_bits(sensitive_data.ssh1_host_key->rsa->n) <
		    BN_num_bits(sensitive_data.server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
			fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
			    get_remote_ipaddr(),
			    BN_num_bits(sensitive_data.ssh1_host_key->rsa->n),
			    BN_num_bits(sensitive_data.server_key->rsa->n),
			    SSH_KEY_BITS_RESERVED);
		}
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.ssh1_host_key->rsa) < 0)
			rsafail++;
		if (rsa_private_decrypt(session_key_int, session_key_int,
		    sensitive_data.server_key->rsa) < 0)
			rsafail++;
d1238 2
a1239 2
	    sensitive_data.ssh1_host_key->rsa->n,
	    sensitive_data.server_key->rsa->n);
d1249 9
a1257 23
	if (!rsafail) {
		BN_mask_bits(session_key_int, sizeof(session_key) * 8);
		len = BN_num_bytes(session_key_int);
		if (len < 0 || len > sizeof(session_key)) {
			error("do_connection: bad session key len from %s: "
			    "session_key_int %d > sizeof(session_key) %lu",
			    get_remote_ipaddr(), len, (u_long)sizeof(session_key));
			rsafail++;
		} else {
			memset(session_key, 0, sizeof(session_key));
			BN_bn2bin(session_key_int,
			    session_key + sizeof(session_key) - len);
		}
	}
	if (rsafail) {
		log("do_connection: generating a fake encryption key");
		for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++) {
			if (i % 4 == 0)
				rand = arc4random();
			session_key[i] = rand & 0xff;
			rand >>= 8;
		}
	}
d1283 1
a1283 1
do_ssh2_kex(void)
a1297 6
	if (options.macs != NULL) {
		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
	}
	myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = list_hostkey_types();

d1354 6
a1359 6
	u_char *signature = NULL;
	u_char *server_host_key_blob = NULL;
	u_int sbloblen;
	u_int klen, kout;
	u_char *kbuf;
	u_char *hash;
a1362 5
	Key *hostkey;

	hostkey = get_hostkey_by_type(kex->hostkey_type);
	if (hostkey == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);
a1364 4
	/* generate DH key */
	dh = dh_new_group1();			/* XXX depends on 'kex' */
	dh_gen_key(dh);

d1381 3
d1392 1
a1392 1
	DHparams_print_fp(stderr, dh);
d1415 2
a1416 1
	key_to_blob(hostkey, &server_host_key_blob, &sbloblen);
a1432 1
	BN_free(dh_client_pub);
d1447 1
a1447 1
	key_sign(hostkey, &signature, &slen, hash, 20);
a1461 1
	BN_clear_free(shared_secret);
d1478 6
a1483 6
	u_char *signature = NULL;
	u_char *server_host_key_blob = NULL;
	u_int sbloblen;
	u_int klen, kout;
	u_char *kbuf;
	u_char *hash;
a1486 5
	Key *hostkey;

	hostkey = get_hostkey_by_type(kex->hostkey_type);
	if (hostkey == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);
a1500 4
	/* Compute our exchange value in parallel with the client */

	dh_gen_key(dh);

d1525 1
a1525 1
	DHparams_print_fp(stderr, dh);
d1548 2
a1549 1
	key_to_blob(hostkey, &server_host_key_blob, &sbloblen);
a1566 1
	BN_free(dh_client_pub);
d1581 1
a1581 1
	key_sign(hostkey, &signature, &slen, hash, 20);
a1595 1
	BN_clear_free(shared_secret);
d1601 1
@


1.115.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: sshd.c,v 1.175 2001/03/18 23:30:55 deraadt Exp $");
d54 1
a54 1
#include "sshpty.h"
d143 1
a143 1
	Key	*server_key;		/* ephemeral server key */
a147 1
	u_char	ssh1_cookie[SSH_SESSION_KEY_LENGTH];
d266 1
a266 1
generate_ephemeral_server_key(void)
a267 3
	u_int32_t rand = 0;
	int i;

d273 1
a274 8

	for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++) {
		if (i % 4 == 0)
			rand = arc4random();
		sensitive_data.ssh1_cookie[i] = rand & 0xff;
		rand >>= 8;
	}
	arc4random_stir();
d322 1
a322 2
				log("Did not receive identification string from %s.",
				    get_remote_ipaddr());
a362 6
	if (datafellows & SSH_BUG_SCANNER) {
		log("scanned from %s with %s.  Don't panic.",
		    get_remote_ipaddr(), client_version_string);
		fatal_cleanup();
	}

a430 1
	memset(sensitive_data.ssh1_cookie, 0, SSH_SESSION_KEY_LENGTH);
d715 1
a715 1
		log("sshd: no hostkeys available -- exiting.");
d793 1
a793 1
			generate_ephemeral_server_key();
d870 1
a870 1
			generate_ephemeral_server_key();
d916 1
a916 1
				generate_ephemeral_server_key();
d1316 8
a1340 10

			compute_session_id(session_id, cookie,
			    sensitive_data.ssh1_host_key->rsa->n,
			    sensitive_data.server_key->rsa->n);
			/*
			 * Xor the first 16 bytes of the session key with the
			 * session id.
			 */
			for (i = 0; i < 16; i++)
				session_key[i] ^= session_id[i];
a1343 4
		int bytes = BN_num_bytes(session_key_int);
		char *buf = xmalloc(bytes);
		MD5_CTX md;

d1345 6
a1350 14
		BN_bn2bin(session_key_int, buf);
		MD5_Init(&md);
		MD5_Update(&md, buf, bytes);
		MD5_Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
		MD5_Final(session_key, &md);
		MD5_Init(&md);
		MD5_Update(&md, session_key, 16);
		MD5_Update(&md, buf, bytes);
		MD5_Update(&md, sensitive_data.ssh1_cookie, SSH_SESSION_KEY_LENGTH);
		MD5_Final(session_key + 16, &md);
		memset(buf, 0, bytes);
		xfree(buf);
		for (i = 0; i < 16; i++)
			session_id[i] = session_key[i] ^ session_key[i + 16];
a1351 3
	/* Destroy the private and public keys.  They will no longer be needed. */
	destroy_sensitive_data();

d1355 4
d1472 1
a1472 1
	dh_gen_key(dh, kex->we_need * 8);
d1615 1
a1615 1
	dh_gen_key(dh, kex->we_need * 8);
@


1.114
log
@use c-style comments
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.113 2000/05/01 20:34:51 markus Exp $");
d561 3
a563 2
		if (!load_private_key(options.dsa_key_file, "", sensitive_data.dsa_host_key, NULL)) {
			error("Could not load DSA host key: %.200s", options.dsa_key_file);
@


1.113
log
@unlink pid file, ok niels@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.112 2000/05/01 18:50:59 markus Exp $");
d1313 1
a1313 1
	packet_put_bignum2(dh->pub_key);	// f
@


1.112
log
@PidFile, pr 1210
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.111 2000/04/27 08:01:28 markus Exp $");
d189 1
@


1.111
log
@xfree DSA blobs
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.110 2000/04/26 22:36:06 markus Exp $");
d727 1
a727 1
			f = fopen(SSH_DAEMON_PID_FILE, "w");
@


1.110
log
@silent if -Q is specified
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.109 2000/04/26 22:15:59 markus Exp $");
d1273 1
d1316 1
@


1.109
log
@remove unused
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.108 2000/04/26 20:56:30 markus Exp $");
d420 1
a420 1
	int silentrsa = 0;
d461 1
a461 1
			silentrsa = 1;
d517 1
a517 1
	    !inetd_flag);
a538 2
		if (silentrsa == 0)
			fprintf(stderr, "sshd: no RSA support in libssl and libcrypto.  See ssl(8)\n");
d567 2
a568 1
		fprintf(stderr, "sshd: no hostkeys available -- exiting.\n");
@


1.108
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.107 2000/04/19 07:05:50 deraadt Exp $");
a424 1
	char *comment;
d552 1
a552 1
		if (!load_private_key(options.host_key_file, "", &k, &comment)) {
a558 1
		xfree(comment);
@


1.107
log
@pid_t
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.106 2000/04/17 12:31:47 markus Exp $");
d43 1
d112 1
a112 1
	RSA *private_key;	 /* Private part of server key. */
d114 1
d133 4
d229 1
d350 7
a367 6
		if (remote_minor == 99) {
			if (options.protocol & SSH_PROTO_2)
				enable_compat20();
			else
				mismatch = 1;
		}
d393 14
a519 7
	/* check if RSA support exists */
	if (rsa_alive() == 0) {
		if (silentrsa == 0)
			printf("sshd: no RSA support in libssl and libcrypto -- exiting.  See ssl(8)\n");
		log("no RSA support in libssl and libcrypto -- exiting.  See ssl(8)");
		exit(1);
	}
a525 6
	/* Check certain values for sanity. */
	if (options.server_key_bits < 512 ||
	    options.server_key_bits > 32768) {
		fprintf(stderr, "Bad server key size.\n");
		exit(1);
	}
d534 39
a572 7
	sensitive_data.host_key = RSA_new();
	errno = 0;
	/* Load the host key.  It must have empty passphrase. */
	if (!load_private_key(options.host_key_file, "",
			      sensitive_data.host_key, &comment)) {
		error("Could not load host key: %.200s: %.100s",
		      options.host_key_file, strerror(errno));
a574 1
	xfree(comment);
d576 24
a599 2
	/* Initialize the log (it is reinitialized below in case we
	   forked). */
d604 5
a608 3
	/* If not in debugging mode, and not started from inetd,
	   disconnect from the controlling terminal, and fork.  The
	   original process exits. */
a627 12
	/* Check that server and host key lengths differ sufficiently.
	   This is necessary to make double encryption work with rsaref.
	   Oh, I hate software patents. I dont know if this can go? Niels */
	if (options.server_key_bits >
	BN_num_bits(sensitive_data.host_key->n) - SSH_KEY_BITS_RESERVED &&
	    options.server_key_bits <
	BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED) {
		options.server_key_bits =
			BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED;
		debug("Forcing server key to %d bits to make it differ from host key.",
		      options.server_key_bits);
	}
d645 5
a649 3
		/* We intentionally do not close the descriptors 0, 1, and 2
		   as our code for setting the descriptors won\'t work
		   if ttyfd happens to be one of those. */
d652 9
a660 9
		public_key = RSA_new();
		sensitive_data.private_key = RSA_new();

		/* XXX check options.protocol */
		log("Generating %d bit RSA key.", options.server_key_bits);
		rsa_generate_key(sensitive_data.private_key, public_key,
				 options.server_key_bits);
		arc4random_stir();
		log("RSA key generation complete.");
d736 9
d746 4
a749 12
		public_key = RSA_new();
		sensitive_data.private_key = RSA_new();

		log("Generating %d bit RSA key.", options.server_key_bits);
		rsa_generate_key(sensitive_data.private_key, public_key,
				 options.server_key_bits);
		arc4random_stir();
		log("RSA key generation complete.");

		/* Schedule server key regeneration alarm. */
		signal(SIGALRM, key_regeneration_alarm);
		alarm(options.key_regeneration_time);
d1117 1
a1117 3
	RSA_free(public_key);
	RSA_free(sensitive_data.private_key);
	RSA_free(sensitive_data.host_key);
a1175 1
	Key *server_host_key;
d1276 1
a1276 2
	server_host_key = dsa_get_serverkey(options.dsa_key_file);
	dsa_make_serverkey_blob(server_host_key, &server_host_key_blob, &sbloblen);
d1299 6
d1306 4
a1309 3
	dsa_sign(server_host_key, &signature, &slen, hash, 20);
		/* hashlen depends on KEX */
	key_free(server_host_key);
@


1.106
log
@missing xfree()
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.105 2000/04/14 10:30:33 markus Exp $");
d395 2
a396 1
	int opt, sock_in = 0, sock_out = 0, newsock, i, fdsetsz, pid, on = 1;
@


1.105
log
@whitespace cleanup
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.104 2000/04/12 09:39:10 markus Exp $");
d1258 1
@


1.104
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.103 2000/04/12 08:11:36 markus Exp $");
d61 1
a61 1
/* 
d152 1
a152 1
void 
d163 1
a163 1
void 
d178 1
a178 1
void 
d190 1
a190 1
void 
d206 1
a206 1
void 
d223 1
a223 1
void 
d256 9
a264 9
        char *t = s;
        while (*t) {
                if(*t == '\n' || *t == '\r') {
                        *t = '\0';
                        return s;
                }
                t++;
        }
        return s;
d327 1
a327 1
 		s = "Protocol mismatch.\n";
d367 1
a367 1
	default: 
d708 2
a709 2
		fdsetsz = howmany(maxfd, NFDBITS) * sizeof(fd_mask);         
		fdset = (fd_set *)xmalloc(fdsetsz);                                  
d1002 1
a1002 1
        if (!(cipher_mask() & (1 << cipher_type)))
d1129 1
a1129 1
		myproposal[PROPOSAL_ENC_ALGS_CTOS] = 
d1242 4
a1245 4
        fprintf(stderr, "hash == ");
        for (i = 0; i< 20; i++)
                fprintf(stderr, "%02x", (hash[i])&0xff);
        fprintf(stderr, "\n");
@


1.103
log
@print 1.99 only if server supports both
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.102 2000/04/12 07:45:44 markus Exp $");
d32 3
a34 3
#include <ssl/dh.h>
#include <ssl/bn.h>
#include <ssl/hmac.h>
d36 2
a37 2
#include <ssl/dsa.h>
#include <ssl/rsa.h>
@


1.102
log
@add Cipher and Protocol options to ssh/sshd, e.g.:
ssh -o 'Protocol 1,2' if you prefer proto 1, ssh -o 'Ciphers arcfour,3des-cbc'
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.101 2000/04/12 07:03:06 markus Exp $");
d278 2
a279 1
	if (options.protocol & (SSH_PROTO_1|SSH_PROTO_2)) {
@


1.101
log
@check for reasonable public DH values
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.100 2000/04/12 06:37:02 markus Exp $");
a66 3
/* Flag indicating whether SSH2 is enabled */
int allow_ssh2 = 0;

d271 1
a271 1
	int i;
d273 1
d278 11
a288 4
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s\n",
		 allow_ssh2 ? 1	 : PROTOCOL_MAJOR,
		 allow_ssh2 ? 99 : PROTOCOL_MINOR,
		 SSH_VERSION);
a308 1
				//break;
d339 1
d342 4
d353 7
a359 3
		if (remote_minor != 99)
		       break;
		/* FALLTHROUGH */
d361 1
a361 1
		if (allow_ssh2) {
d367 8
d379 3
a381 2
		log("Protocol major versions differ for %s: %d vs. %d",
		    get_remote_ipaddr(), PROTOCOL_MAJOR, remote_major);
a382 1
		break;
a383 2
	chop(server_version_string);
	chop(client_version_string);
d419 1
a419 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:diqQ246")) != EOF) {
a420 3
		case '2':
			allow_ssh2 = 1;
			break;
d599 1
d1126 5
@


1.100
log
@less debugging output
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.99 2000/04/07 09:17:39 markus Exp $");
d1169 1
a1169 1
	dh = new_dh_group1();			/* XXX depends on 'kex' */
d1180 2
@


1.99
log
@interop w/ latest ssh.com windows client.
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.98 2000/04/06 08:55:22 markus Exp $");
d1251 1
d1257 1
a1257 1

@


1.98
log
@ssh2 server side, see README.openssh2; enable with 'sshd -2'
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.97 2000/04/04 21:37:27 markus Exp $");
d344 3
a346 1
		break;
d352 1
@


1.97
log
@remove unused argument, split cipher_mask()
@
text
@d11 3
d17 1
a17 1
RCSID("$OpenBSD: sshd.c,v 1.96 2000/03/28 21:15:45 markus Exp $");
d31 1
d35 1
d39 1
d42 1
d67 3
d136 1
d256 15
d281 3
a283 1
	    PROTOCOL_MAJOR, PROTOCOL_MINOR, SSH_VERSION);
d304 1
a304 1
				/*break; XXX eat \r */
d333 2
d345 5
d360 2
d397 1
a397 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:diqQ46")) != EOF) {
d399 3
a865 1
	do_ssh1_kex();
d867 7
a873 1
	do_authentication();
d1077 178
@


1.96
log
@split sshd.c -> auth.c session.c sshd.c plus cleanup and goto-removal
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.18 2000/03/22 09:56:25 markus Exp $");
d895 1
a895 1
	packet_put_int(cipher_mask());
@


1.95
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.94 2000/03/23 22:15:34 markus Exp $");
a20 1
#include "buffer.h"
a24 2
#include "match.h"
#include "channels.h"
d26 10
a47 3
/* Local Xauthority file. */
static char *xauthfile = NULL;

d93 1
a93 15

/* Flags set in auth-rsa from authorized_keys flags.  These are set in auth-rsa.c. */
int no_port_forwarding_flag = 0;
int no_agent_forwarding_flag = 0;
int no_x11_forwarding_flag = 0;
int no_pty_flag = 0;

/* RSA authentication "command=" option. */
char *forced_command = NULL;

/* RSA authentication "environment=" options. */
struct envstring *custom_environment = NULL;

/* Session id for the current session. */
unsigned char session_id[16];
d121 3
d125 1
a125 36
void do_ssh_kex();
void do_authentication();
void do_authloop(struct passwd * pw);
void do_fake_authloop(char *user);
void do_authenticated(struct passwd * pw);
void do_exec_pty(const char *command, int ptyfd, int ttyfd,
	         const char *ttyname, struct passwd * pw, const char *term,
	         const char *display, const char *auth_proto,
	         const char *auth_data);
void do_exec_no_pty(const char *command, struct passwd * pw,
	            const char *display, const char *auth_proto,
	            const char *auth_data);
void do_child(const char *command, struct passwd * pw, const char *term,
	      const char *display, const char *auth_proto,
	      const char *auth_data, const char *ttyname);

/*
 * Remove local Xauthority file.
 */
void
xauthfile_cleanup_proc(void *ignore)
{
	debug("xauthfile_cleanup_proc called");

	if (xauthfile != NULL) {
		char *p;
		unlink(xauthfile);
		p = strrchr(xauthfile, '/');
		if (p != NULL) {
			*p = '\0';
			rmdir(xauthfile);
		}
		xfree(xauthfile);
		xauthfile = NULL;
	}
}
a208 29
 * convert ssh auth msg type into description
 */
char *
get_authname(int type)
{
	static char buf[1024];
	switch (type) {
	case SSH_CMSG_AUTH_PASSWORD:
		return "password";
	case SSH_CMSG_AUTH_RSA:
		return "rsa";
	case SSH_CMSG_AUTH_RHOSTS_RSA:
		return "rhosts-rsa";
	case SSH_CMSG_AUTH_RHOSTS:
		return "rhosts";
#ifdef KRB4
	case SSH_CMSG_AUTH_KERBEROS:
		return "kerberos";
#endif
#ifdef SKEY
	case SSH_CMSG_AUTH_TIS_RESPONSE:
		return "s/key";
#endif
	}
	snprintf(buf, sizeof buf, "bad-auth-msg-%d", type);
	return buf;
}

/*
d245 82
a336 1
	int remote_major, remote_minor;
a339 2
	char buf[100];			/* Must not be larger than remote_version. */
	char remote_version[100];	/* Must be at least as big as buf. */
d802 1
a802 67
	if (client_version_string != NULL) {
		/* we are exec'ed by sshd2, so skip exchange of protocol version */
		strlcpy(buf, client_version_string, sizeof(buf));
	} else {
		/* Send our protocol version identification. */
		snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s\n",
			 PROTOCOL_MAJOR, PROTOCOL_MINOR, SSH_VERSION);
		if (atomicio(write, sock_out, buf, strlen(buf)) != strlen(buf)) {
			log("Could not write ident string to %s.", remote_ip);
			fatal_cleanup();
		}

		/* Read other side\'s version identification. */
		for (i = 0; i < sizeof(buf) - 1; i++) {
			if (read(sock_in, &buf[i], 1) != 1) {
				log("Did not receive ident string from %s.", remote_ip);
				fatal_cleanup();
			}
			if (buf[i] == '\r') {
				buf[i] = '\n';
				buf[i + 1] = 0;
				break;
			}
			if (buf[i] == '\n') {
				/* buf[i] == '\n' */
				buf[i + 1] = 0;
				break;
			}
		}
		buf[sizeof(buf) - 1] = 0;
	}

	/*
	 * Check that the versions match.  In future this might accept
	 * several versions and set appropriate flags to handle them.
	 */
	if (sscanf(buf, "SSH-%d.%d-%[^\n]\n", &remote_major, &remote_minor,
	    remote_version) != 3) {
		char *s = "Protocol mismatch.\n";

		(void) atomicio(write, sock_out, s, strlen(s));
		close(sock_in);
		close(sock_out);
		log("Bad protocol version identification '%.100s' from %s",
		    buf, remote_ip);
		fatal_cleanup();
	}
	debug("Client protocol version %d.%d; client software version %.100s",
	      remote_major, remote_minor, remote_version);
	if (remote_major != PROTOCOL_MAJOR) {
		char *s = "Protocol major versions differ.\n";

		(void) atomicio(write, sock_out, s, strlen(s));
		close(sock_in);
		close(sock_out);
		log("Protocol major versions differ for %s: %d vs. %d",
		    remote_ip, PROTOCOL_MAJOR, remote_major);
		fatal_cleanup();
	}
	/* Check that the client has sufficiently high software version. */
	if (remote_major == 1 && remote_minor < 3)
		packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");

	if (remote_major == 1 && remote_minor == 3) {
		/* note that this disables agent-forwarding */
		enable_compat13();
	}
d826 1
a826 2
	do_ssh_kex();

a835 4
	/* Cleanup user's local Xauthority file. */
	if (xauthfile)
		xauthfile_cleanup_proc(NULL);

d846 1
a846 1
do_ssh_kex()
a1031 1460
}


/*
 * Check if the user is allowed to log in via ssh. If user is listed in
 * DenyUsers or user's primary group is listed in DenyGroups, false will
 * be returned. If AllowUsers isn't empty and user isn't listed there, or
 * if AllowGroups isn't empty and user isn't listed there, false will be
 * returned. 
 * If the user's shell is not executable, false will be returned.
 * Otherwise true is returned. 
 */
static int
allowed_user(struct passwd * pw)
{
	struct stat st;
	struct group *grp;
	int i;

	/* Shouldn't be called if pw is NULL, but better safe than sorry... */
	if (!pw)
		return 0;

	/* deny if shell does not exists or is not executable */
	if (stat(pw->pw_shell, &st) != 0)
		return 0;
	if (!((st.st_mode & S_IFREG) && (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP))))
		return 0;

	/* Return false if user is listed in DenyUsers */
	if (options.num_deny_users > 0) {
		if (!pw->pw_name)
			return 0;
		for (i = 0; i < options.num_deny_users; i++)
			if (match_pattern(pw->pw_name, options.deny_users[i]))
				return 0;
	}
	/* Return false if AllowUsers isn't empty and user isn't listed there */
	if (options.num_allow_users > 0) {
		if (!pw->pw_name)
			return 0;
		for (i = 0; i < options.num_allow_users; i++)
			if (match_pattern(pw->pw_name, options.allow_users[i]))
				break;
		/* i < options.num_allow_users iff we break for loop */
		if (i >= options.num_allow_users)
			return 0;
	}
	/* Get the primary group name if we need it. Return false if it fails */
	if (options.num_deny_groups > 0 || options.num_allow_groups > 0) {
		grp = getgrgid(pw->pw_gid);
		if (!grp)
			return 0;

		/* Return false if user's group is listed in DenyGroups */
		if (options.num_deny_groups > 0) {
			if (!grp->gr_name)
				return 0;
			for (i = 0; i < options.num_deny_groups; i++)
				if (match_pattern(grp->gr_name, options.deny_groups[i]))
					return 0;
		}
		/*
		 * Return false if AllowGroups isn't empty and user's group
		 * isn't listed there
		 */
		if (options.num_allow_groups > 0) {
			if (!grp->gr_name)
				return 0;
			for (i = 0; i < options.num_allow_groups; i++)
				if (match_pattern(grp->gr_name, options.allow_groups[i]))
					break;
			/* i < options.num_allow_groups iff we break for
			   loop */
			if (i >= options.num_allow_groups)
				return 0;
		}
	}
	/* We found no reason not to let this user try to log on... */
	return 1;
}

/*
 * Performs authentication of an incoming connection.  Session key has already
 * been exchanged and encryption is enabled.
 */
void
do_authentication()
{
	struct passwd *pw, pwcopy;
	int plen;
	unsigned int ulen;
	char *user;

	/* Get the name of the user that we wish to log in as. */
	packet_read_expect(&plen, SSH_CMSG_USER);

	/* Get the user name. */
	user = packet_get_string(&ulen);
	packet_integrity_check(plen, (4 + ulen), SSH_CMSG_USER);

	setproctitle("%s", user);

#ifdef AFS
	/* If machine has AFS, set process authentication group. */
	if (k_hasafs()) {
		k_setpag();
		k_unlog();
	}
#endif /* AFS */

	/* Verify that the user is a valid user. */
	pw = getpwnam(user);
	if (!pw || !allowed_user(pw))
		do_fake_authloop(user);
	xfree(user);

	/* Take a copy of the returned structure. */
	memset(&pwcopy, 0, sizeof(pwcopy));
	pwcopy.pw_name = xstrdup(pw->pw_name);
	pwcopy.pw_passwd = xstrdup(pw->pw_passwd);
	pwcopy.pw_uid = pw->pw_uid;
	pwcopy.pw_gid = pw->pw_gid;
	pwcopy.pw_dir = xstrdup(pw->pw_dir);
	pwcopy.pw_shell = xstrdup(pw->pw_shell);
	pw = &pwcopy;

	/*
	 * If we are not running as root, the user must have the same uid as
	 * the server.
	 */
	if (getuid() != 0 && pw->pw_uid != getuid())
		packet_disconnect("Cannot change user when server not running as root.");

	debug("Attempting authentication for %.100s.", pw->pw_name);

	/* If the user has no password, accept authentication immediately. */
	if (options.password_authentication &&
#ifdef KRB4
	    (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
#endif /* KRB4 */
	    auth_password(pw, "")) {
		/* Authentication with empty password succeeded. */
		log("Login for user %s from %.100s, accepted without authentication.",
		    pw->pw_name, get_remote_ipaddr());
	} else {
		/* Loop until the user has been authenticated or the
		   connection is closed, do_authloop() returns only if
		   authentication is successfull */
		do_authloop(pw);
	}

	/* The user has been authenticated and accepted. */
	packet_start(SSH_SMSG_SUCCESS);
	packet_send();
	packet_write_wait();

	/* Perform session preparation. */
	do_authenticated(pw);
}

#define AUTH_FAIL_MAX 6
#define AUTH_FAIL_LOG (AUTH_FAIL_MAX/2)
#define AUTH_FAIL_MSG "Too many authentication failures for %.100s"

/*
 * read packets and try to authenticate local user *pw.
 * return if authentication is successfull
 */
void
do_authloop(struct passwd * pw)
{
	int attempt = 0;
	unsigned int bits;
	RSA *client_host_key;
	BIGNUM *n;
	char *client_user, *password;
	char user[1024];
	unsigned int dlen;
	int plen, nlen, elen;
	unsigned int ulen;
	int type = 0;
	void (*authlog) (const char *fmt,...) = verbose;

	/* Indicate that authentication is needed. */
	packet_start(SSH_SMSG_FAILURE);
	packet_send();
	packet_write_wait();

	for (attempt = 1;; attempt++) {
		int authenticated = 0;
		strlcpy(user, "", sizeof user);

		/* Get a packet from the client. */
		type = packet_read(&plen);

		/* Process the packet. */
		switch (type) {
#ifdef AFS
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			if (!options.kerberos_tgt_passing) {
				/* packet_get_all(); */
				verbose("Kerberos tgt passing disabled.");
				break;
			} else {
				/* Accept Kerberos tgt. */
				char *tgt = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				if (!auth_kerberos_tgt(pw, tgt))
					verbose("Kerberos tgt REFUSED for %s", pw->pw_name);
				xfree(tgt);
			}
			continue;

		case SSH_CMSG_HAVE_AFS_TOKEN:
			if (!options.afs_token_passing || !k_hasafs()) {
				/* packet_get_all(); */
				verbose("AFS token passing disabled.");
				break;
			} else {
				/* Accept AFS token. */
				char *token_string = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				if (!auth_afs_token(pw, token_string))
					verbose("AFS token REFUSED for %s", pw->pw_name);
				xfree(token_string);
			}
			continue;
#endif /* AFS */
#ifdef KRB4
		case SSH_CMSG_AUTH_KERBEROS:
			if (!options.kerberos_authentication) {
				/* packet_get_all(); */
				verbose("Kerberos authentication disabled.");
				break;
			} else {
				/* Try Kerberos v4 authentication. */
				KTEXT_ST auth;
				char *tkt_user = NULL;
				char *kdata = packet_get_string((unsigned int *) &auth.length);
				packet_integrity_check(plen, 4 + auth.length, type);

				if (auth.length < MAX_KTXT_LEN)
					memcpy(auth.dat, kdata, auth.length);
				xfree(kdata);

				authenticated = auth_krb4(pw->pw_name, &auth, &tkt_user);

				if (authenticated) {
					snprintf(user, sizeof user, " tktuser %s", tkt_user);
					xfree(tkt_user);
				}
			}
			break;
#endif /* KRB4 */

		case SSH_CMSG_AUTH_RHOSTS:
			if (!options.rhosts_authentication) {
				verbose("Rhosts authentication disabled.");
				break;
			}
			/*
			 * Get client user name.  Note that we just have to
			 * trust the client; this is one reason why rhosts
			 * authentication is insecure. (Another is
			 * IP-spoofing on a local network.)
			 */
			client_user = packet_get_string(&ulen);
			packet_integrity_check(plen, 4 + ulen, type);

			/* Try to authenticate using /etc/hosts.equiv and
			   .rhosts. */
			authenticated = auth_rhosts(pw, client_user);

			snprintf(user, sizeof user, " ruser %s", client_user);
			xfree(client_user);
			break;

		case SSH_CMSG_AUTH_RHOSTS_RSA:
			if (!options.rhosts_rsa_authentication) {
				verbose("Rhosts with RSA authentication disabled.");
				break;
			}
			/*
			 * Get client user name.  Note that we just have to
			 * trust the client; root on the client machine can
			 * claim to be any user.
			 */
			client_user = packet_get_string(&ulen);

			/* Get the client host key. */
			client_host_key = RSA_new();
			if (client_host_key == NULL)
				fatal("RSA_new failed");
			client_host_key->e = BN_new();
			client_host_key->n = BN_new();
			if (client_host_key->e == NULL || client_host_key->n == NULL)
				fatal("BN_new failed");
			bits = packet_get_int();
			packet_get_bignum(client_host_key->e, &elen);
			packet_get_bignum(client_host_key->n, &nlen);

			if (bits != BN_num_bits(client_host_key->n))
				error("Warning: keysize mismatch for client_host_key: "
				      "actual %d, announced %d", BN_num_bits(client_host_key->n), bits);
			packet_integrity_check(plen, (4 + ulen) + 4 + elen + nlen, type);

			authenticated = auth_rhosts_rsa(pw, client_user, client_host_key);
			RSA_free(client_host_key);

			snprintf(user, sizeof user, " ruser %s", client_user);
			xfree(client_user);
			break;

		case SSH_CMSG_AUTH_RSA:
			if (!options.rsa_authentication) {
				verbose("RSA authentication disabled.");
				break;
			}
			/* RSA authentication requested. */
			n = BN_new();
			packet_get_bignum(n, &nlen);
			packet_integrity_check(plen, nlen, type);
			authenticated = auth_rsa(pw, n);
			BN_clear_free(n);
			break;

		case SSH_CMSG_AUTH_PASSWORD:
			if (!options.password_authentication) {
				verbose("Password authentication disabled.");
				break;
			}
			/*
			 * Read user password.  It is in plain text, but was
			 * transmitted over the encrypted channel so it is
			 * not visible to an outside observer.
			 */
			password = packet_get_string(&dlen);
			packet_integrity_check(plen, 4 + dlen, type);

			/* Try authentication with the password. */
			authenticated = auth_password(pw, password);

			memset(password, 0, strlen(password));
			xfree(password);
			break;

#ifdef SKEY
		case SSH_CMSG_AUTH_TIS:
			debug("rcvd SSH_CMSG_AUTH_TIS");
			if (options.skey_authentication == 1) {
				char *skeyinfo = skey_keyinfo(pw->pw_name);
				if (skeyinfo == NULL) {
					debug("generating fake skeyinfo for %.100s.", pw->pw_name);
					skeyinfo = skey_fake_keyinfo(pw->pw_name);
				}
				if (skeyinfo != NULL) {
					/* we send our s/key- in tis-challenge messages */
					debug("sending challenge '%s'", skeyinfo);
					packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
					packet_put_string(skeyinfo, strlen(skeyinfo));
					packet_send();
					packet_write_wait();
					continue;
				}
			}
			break;
		case SSH_CMSG_AUTH_TIS_RESPONSE:
			debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
			if (options.skey_authentication == 1) {
				char *response = packet_get_string(&dlen);
				debug("skey response == '%s'", response);
				packet_integrity_check(plen, 4 + dlen, type);
				authenticated = (skey_haskey(pw->pw_name) == 0 &&
						 skey_passcheck(pw->pw_name, response) != -1);
				xfree(response);
			}
			break;
#else
		case SSH_CMSG_AUTH_TIS:
			/* TIS Authentication is unsupported */
			log("TIS authentication unsupported.");
			break;
#endif

		default:
			/*
			 * Any unknown messages will be ignored (and failure
			 * returned) during authentication.
			 */
			log("Unknown message during authentication: type %d", type);
			break;
		}

		/*
		 * Check if the user is logging in as root and root logins
		 * are disallowed.
		 * Note that root login is allowed for forced commands.
		 */
		if (authenticated && pw->pw_uid == 0 && !options.permit_root_login) {
			if (forced_command) {
				log("Root login accepted for forced command.");
			} else {
				authenticated = 0;
				log("ROOT LOGIN REFUSED FROM %.200s",
				    get_canonical_hostname());
			}
		}

		/* Raise logging level */
		if (authenticated ||
		    attempt == AUTH_FAIL_LOG ||
		    type == SSH_CMSG_AUTH_PASSWORD)
			authlog = log;

		authlog("%s %s for %.200s from %.200s port %d%s",
			authenticated ? "Accepted" : "Failed",
			get_authname(type),
			pw->pw_uid == 0 ? "ROOT" : pw->pw_name,
			get_remote_ipaddr(),
			get_remote_port(),
			user);

		if (authenticated)
			return;

		if (attempt > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, pw->pw_name);

		/* Send a message indicating that the authentication attempt failed. */
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
	}
}

/*
 * The user does not exist or access is denied,
 * but fake indication that authentication is needed.
 */
void
do_fake_authloop(char *user)
{
	int attempt = 0;

	log("Faking authloop for illegal user %.200s from %.200s port %d",
	    user,
	    get_remote_ipaddr(),
	    get_remote_port());

	/* Indicate that authentication is needed. */
	packet_start(SSH_SMSG_FAILURE);
	packet_send();
	packet_write_wait();

	/*
	 * Keep reading packets, and always respond with a failure.  This is
	 * to avoid disclosing whether such a user really exists.
	 */
	for (attempt = 1;; attempt++) {
		/* Read a packet.  This will not return if the client disconnects. */
		int plen;
		int type = packet_read(&plen);
#ifdef SKEY
		unsigned int dlen;
		char *password, *skeyinfo;
		/* Try to send a fake s/key challenge. */
		if (options.skey_authentication == 1 &&
		    (skeyinfo = skey_fake_keyinfo(user)) != NULL) {
			password = NULL;
			if (type == SSH_CMSG_AUTH_TIS) {
				packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
				packet_put_string(skeyinfo, strlen(skeyinfo));
				packet_send();
				packet_write_wait();
				continue;
			} else if (type == SSH_CMSG_AUTH_PASSWORD &&
			           options.password_authentication &&
			           (password = packet_get_string(&dlen)) != NULL &&
			           dlen == 5 &&
			           strncasecmp(password, "s/key", 5) == 0 ) {
				packet_send_debug(skeyinfo);
			}
			if (password != NULL)
				xfree(password);
		}
#endif
		if (attempt > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, user);

		/*
		 * Send failure.  This should be indistinguishable from a
		 * failed authentication.
		 */
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
	}
	/* NOTREACHED */
	abort();
}

struct pty_cleanup_context {
	const char *ttyname;
	int pid;
};

/*
 * Function to perform cleanup if we get aborted abnormally (e.g., due to a
 * dropped connection).
 */
void 
pty_cleanup_proc(void *context)
{
	struct pty_cleanup_context *cu = context;

	debug("pty_cleanup_proc called");

	/* Record that the user has logged out. */
	record_logout(cu->pid, cu->ttyname);

	/* Release the pseudo-tty. */
	pty_release(cu->ttyname);
}

/* simple cleanup: chown tty slave back to root */
static void
pty_release_proc(void *tty)
{
	char *ttyname = tty;
	pty_release(ttyname);
}

/*
 * Prepares for an interactive session.  This is called after the user has
 * been successfully authenticated.  During this message exchange, pseudo
 * terminals are allocated, X11, TCP/IP, and authentication agent forwardings
 * are requested, etc.
 */
void 
do_authenticated(struct passwd * pw)
{
	int type;
	int compression_level = 0, enable_compression_after_reply = 0;
	int have_pty = 0, ptyfd = -1, ttyfd = -1;
	int row, col, xpixel, ypixel, screen;
	char ttyname[64];
	char *command, *term = NULL, *display = NULL, *proto = NULL, *data = NULL;
	int plen;
	unsigned int dlen;
	int n_bytes;

	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);

	/*
	 * Inform the channel mechanism that we are the server side and that
	 * the client may request to connect to any port at all. (The user
	 * could do it anyway, and we wouldn\'t know what is permitted except
	 * by the client telling us, so we can equally well trust the client
	 * not to request anything bogus.)
	 */
	if (!no_port_forwarding_flag)
		channel_permit_all_opens();

	/*
	 * We stay in this loop until the client requests to execute a shell
	 * or a command.
	 */
	while (1) {

		/* Get a packet from the client. */
		type = packet_read(&plen);

		/* Process the packet. */
		switch (type) {
		case SSH_CMSG_REQUEST_COMPRESSION:
			packet_integrity_check(plen, 4, type);
			compression_level = packet_get_int();
			if (compression_level < 1 || compression_level > 9) {
				packet_send_debug("Received illegal compression level %d.",
						  compression_level);
				goto fail;
			}
			/* Enable compression after we have responded with SUCCESS. */
			enable_compression_after_reply = 1;
			break;

		case SSH_CMSG_REQUEST_PTY:
			if (no_pty_flag) {
				debug("Allocating a pty not permitted for this authentication.");
				goto fail;
			}
			if (have_pty)
				packet_disconnect("Protocol error: you already have a pty.");

			debug("Allocating pty.");

			/* Allocate a pty and open it. */
			if (!pty_allocate(&ptyfd, &ttyfd, ttyname,
			    sizeof(ttyname))) {
				error("Failed to allocate pty.");
				goto fail;
			}
			fatal_add_cleanup(pty_release_proc, (void *)ttyname);
			pty_setowner(pw, ttyname);

			/* Get TERM from the packet.  Note that the value may be of arbitrary length. */
			term = packet_get_string(&dlen);
			packet_integrity_check(dlen, strlen(term), type);

			/* Remaining bytes */
			n_bytes = plen - (4 + dlen + 4 * 4);

			if (strcmp(term, "") == 0) {
				xfree(term);
				term = NULL;
			}

			/* Get window size from the packet. */
			row = packet_get_int();
			col = packet_get_int();
			xpixel = packet_get_int();
			ypixel = packet_get_int();
			pty_change_window_size(ptyfd, row, col, xpixel, ypixel);

			/* Get tty modes from the packet. */
			tty_parse_modes(ttyfd, &n_bytes);
			packet_integrity_check(plen, 4 + dlen + 4 * 4 + n_bytes, type);

			/* Indicate that we now have a pty. */
			have_pty = 1;
			break;

		case SSH_CMSG_X11_REQUEST_FORWARDING:
			if (!options.x11_forwarding) {
				packet_send_debug("X11 forwarding disabled in server configuration file.");
				goto fail;
			}
#ifdef XAUTH_PATH
			if (no_x11_forwarding_flag) {
				packet_send_debug("X11 forwarding not permitted for this authentication.");
				goto fail;
			}
			debug("Received request for X11 forwarding with auth spoofing.");
			if (display)
				packet_disconnect("Protocol error: X11 display already set.");
			{
				unsigned int proto_len, data_len;
				proto = packet_get_string(&proto_len);
				data = packet_get_string(&data_len);
				packet_integrity_check(plen, 4 + proto_len + 4 + data_len + 4, type);
			}
			if (packet_get_protocol_flags() & SSH_PROTOFLAG_SCREEN_NUMBER)
				screen = packet_get_int();
			else
				screen = 0;
			display = x11_create_display_inet(screen, options.x11_display_offset);
			if (!display)
				goto fail;

			/* Setup to always have a local .Xauthority. */
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", MAXPATHLEN);
			temporarily_use_uid(pw->pw_uid);
			if (mkdtemp(xauthfile) == NULL) {
				restore_uid();
				error("private X11 dir: mkdtemp %s failed: %s",
				    xauthfile, strerror(errno));
				xfree(xauthfile);
				xauthfile = NULL;
				goto fail;
			}
			strlcat(xauthfile, "/cookies", MAXPATHLEN);
			open(xauthfile, O_RDWR|O_CREAT|O_EXCL, 0600);
			restore_uid();
			fatal_add_cleanup(xauthfile_cleanup_proc, NULL);
			break;
#else /* XAUTH_PATH */
			packet_send_debug("No xauth program; cannot forward with spoofing.");
			goto fail;
#endif /* XAUTH_PATH */

		case SSH_CMSG_AGENT_REQUEST_FORWARDING:
			if (no_agent_forwarding_flag || compat13) {
				debug("Authentication agent forwarding not permitted for this authentication.");
				goto fail;
			}
			debug("Received authentication agent forwarding request.");
			auth_input_request_forwarding(pw);
			break;

		case SSH_CMSG_PORT_FORWARD_REQUEST:
			if (no_port_forwarding_flag) {
				debug("Port forwarding not permitted for this authentication.");
				goto fail;
			}
			debug("Received TCP/IP port forwarding request.");
			channel_input_port_forward_request(pw->pw_uid == 0);
			break;

		case SSH_CMSG_MAX_PACKET_SIZE:
			if (packet_set_maxsize(packet_get_int()) < 0)
				goto fail;
			break;

		case SSH_CMSG_EXEC_SHELL:
			/* Set interactive/non-interactive mode. */
			packet_set_interactive(have_pty || display != NULL,
					       options.keepalives);

			if (forced_command != NULL)
				goto do_forced_command;
			debug("Forking shell.");
			packet_integrity_check(plen, 0, type);
			if (have_pty)
				do_exec_pty(NULL, ptyfd, ttyfd, ttyname, pw, term, display, proto, data);
			else
				do_exec_no_pty(NULL, pw, display, proto, data);
			return;

		case SSH_CMSG_EXEC_CMD:
			/* Set interactive/non-interactive mode. */
			packet_set_interactive(have_pty || display != NULL,
					       options.keepalives);

			if (forced_command != NULL)
				goto do_forced_command;
			/* Get command from the packet. */
			{
				unsigned int dlen;
				command = packet_get_string(&dlen);
				debug("Executing command '%.500s'", command);
				packet_integrity_check(plen, 4 + dlen, type);
			}
			if (have_pty)
				do_exec_pty(command, ptyfd, ttyfd, ttyname, pw, term, display, proto, data);
			else
				do_exec_no_pty(command, pw, display, proto, data);
			xfree(command);
			return;

		default:
			/*
			 * Any unknown messages in this phase are ignored,
			 * and a failure message is returned.
			 */
			log("Unknown packet type received after authentication: %d", type);
			goto fail;
		}

		/* The request was successfully processed. */
		packet_start(SSH_SMSG_SUCCESS);
		packet_send();
		packet_write_wait();

		/* Enable compression now that we have replied if appropriate. */
		if (enable_compression_after_reply) {
			enable_compression_after_reply = 0;
			packet_start_compression(compression_level);
		}
		continue;

fail:
		/* The request failed. */
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
		continue;

do_forced_command:
		/*
		 * There is a forced command specified for this login.
		 * Execute it.
		 */
		debug("Executing forced command: %.900s", forced_command);
		if (have_pty)
			do_exec_pty(forced_command, ptyfd, ttyfd, ttyname, pw, term, display, proto, data);
		else
			do_exec_no_pty(forced_command, pw, display, proto, data);
		return;
	}
}

/*
 * This is called to fork and execute a command when we have no tty.  This
 * will call do_child from the child, and server_loop from the parent after
 * setting up file descriptors and such.
 */
void 
do_exec_no_pty(const char *command, struct passwd * pw,
	       const char *display, const char *auth_proto,
	       const char *auth_data)
{
	int pid;

#ifdef USE_PIPES
	int pin[2], pout[2], perr[2];
	/* Allocate pipes for communicating with the program. */
	if (pipe(pin) < 0 || pipe(pout) < 0 || pipe(perr) < 0)
		packet_disconnect("Could not create pipes: %.100s",
				  strerror(errno));
#else /* USE_PIPES */
	int inout[2], err[2];
	/* Uses socket pairs to communicate with the program. */
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0 ||
	    socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0)
		packet_disconnect("Could not create socket pairs: %.100s",
				  strerror(errno));
#endif /* USE_PIPES */

	setproctitle("%s@@notty", pw->pw_name);

	/* Fork the child. */
	if ((pid = fork()) == 0) {
		/* Child.  Reinitialize the log since the pid has changed. */
		log_init(av0, options.log_level, options.log_facility, log_stderr);

		/*
		 * Create a new session and process group since the 4.4BSD
		 * setlogin() affects the entire process group.
		 */
		if (setsid() < 0)
			error("setsid failed: %.100s", strerror(errno));

#ifdef USE_PIPES
		/*
		 * Redirect stdin.  We close the parent side of the socket
		 * pair, and make the child side the standard input.
		 */
		close(pin[1]);
		if (dup2(pin[0], 0) < 0)
			perror("dup2 stdin");
		close(pin[0]);

		/* Redirect stdout. */
		close(pout[0]);
		if (dup2(pout[1], 1) < 0)
			perror("dup2 stdout");
		close(pout[1]);

		/* Redirect stderr. */
		close(perr[0]);
		if (dup2(perr[1], 2) < 0)
			perror("dup2 stderr");
		close(perr[1]);
#else /* USE_PIPES */
		/*
		 * Redirect stdin, stdout, and stderr.  Stdin and stdout will
		 * use the same socket, as some programs (particularly rdist)
		 * seem to depend on it.
		 */
		close(inout[1]);
		close(err[1]);
		if (dup2(inout[0], 0) < 0)	/* stdin */
			perror("dup2 stdin");
		if (dup2(inout[0], 1) < 0)	/* stdout.  Note: same socket as stdin. */
			perror("dup2 stdout");
		if (dup2(err[0], 2) < 0)	/* stderr */
			perror("dup2 stderr");
#endif /* USE_PIPES */

		/* Do processing for the child (exec command etc). */
		do_child(command, pw, NULL, display, auth_proto, auth_data, NULL);
		/* NOTREACHED */
	}
	if (pid < 0)
		packet_disconnect("fork failed: %.100s", strerror(errno));
#ifdef USE_PIPES
	/* We are the parent.  Close the child sides of the pipes. */
	close(pin[0]);
	close(pout[1]);
	close(perr[1]);

	/* Enter the interactive session. */
	server_loop(pid, pin[1], pout[0], perr[0]);
	/* server_loop has closed pin[1], pout[1], and perr[1]. */
#else /* USE_PIPES */
	/* We are the parent.  Close the child sides of the socket pairs. */
	close(inout[0]);
	close(err[0]);

	/*
	 * Enter the interactive session.  Note: server_loop must be able to
	 * handle the case that fdin and fdout are the same.
	 */
	server_loop(pid, inout[1], inout[1], err[1]);
	/* server_loop has closed inout[1] and err[1]. */
#endif /* USE_PIPES */
}

/*
 * This is called to fork and execute a command when we have a tty.  This
 * will call do_child from the child, and server_loop from the parent after
 * setting up file descriptors, controlling tty, updating wtmp, utmp,
 * lastlog, and other such operations.
 */
void 
do_exec_pty(const char *command, int ptyfd, int ttyfd,
	    const char *ttyname, struct passwd * pw, const char *term,
	    const char *display, const char *auth_proto,
	    const char *auth_data)
{
	int pid, fdout;
	int ptymaster;
	const char *hostname;
	time_t last_login_time;
	char buf[100], *time_string;
	FILE *f;
	char line[256];
	struct stat st;
	int quiet_login;
	struct sockaddr_storage from;
	socklen_t fromlen;
	struct pty_cleanup_context cleanup_context;

	/* Get remote host name. */
	hostname = get_canonical_hostname();

	/*
	 * Get the time when the user last logged in.  Buf will be set to
	 * contain the hostname the last login was from.
	 */
	if (!options.use_login) {
		last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
						      buf, sizeof(buf));
	}
	setproctitle("%s@@%s", pw->pw_name, strrchr(ttyname, '/') + 1);

	/* Fork the child. */
	if ((pid = fork()) == 0) {
		pid = getpid();

		/* Child.  Reinitialize the log because the pid has
		   changed. */
		log_init(av0, options.log_level, options.log_facility, log_stderr);

		/* Close the master side of the pseudo tty. */
		close(ptyfd);

		/* Make the pseudo tty our controlling tty. */
		pty_make_controlling_tty(&ttyfd, ttyname);

		/* Redirect stdin from the pseudo tty. */
		if (dup2(ttyfd, fileno(stdin)) < 0)
			error("dup2 stdin failed: %.100s", strerror(errno));

		/* Redirect stdout to the pseudo tty. */
		if (dup2(ttyfd, fileno(stdout)) < 0)
			error("dup2 stdin failed: %.100s", strerror(errno));

		/* Redirect stderr to the pseudo tty. */
		if (dup2(ttyfd, fileno(stderr)) < 0)
			error("dup2 stdin failed: %.100s", strerror(errno));

		/* Close the extra descriptor for the pseudo tty. */
		close(ttyfd);

		/*
		 * Get IP address of client.  This is needed because we want
		 * to record where the user logged in from.  If the
		 * connection is not a socket, let the ip address be 0.0.0.0.
		 */
		memset(&from, 0, sizeof(from));
		if (packet_get_connection_in() == packet_get_connection_out()) {
			fromlen = sizeof(from);
			if (getpeername(packet_get_connection_in(),
			     (struct sockaddr *) & from, &fromlen) < 0) {
				debug("getpeername: %.100s", strerror(errno));
				fatal_cleanup();
			}
		}
		/* Record that there was a login on that terminal. */
		record_login(pid, ttyname, pw->pw_name, pw->pw_uid, hostname,
			     (struct sockaddr *)&from);

		/* Check if .hushlogin exists. */
		snprintf(line, sizeof line, "%.200s/.hushlogin", pw->pw_dir);
		quiet_login = stat(line, &st) >= 0;

		/*
		 * If the user has logged in before, display the time of last
		 * login. However, don't display anything extra if a command
		 * has been specified (so that ssh can be used to execute
		 * commands on a remote machine without users knowing they
		 * are going to another machine). Login(1) will do this for
		 * us as well, so check if login(1) is used
		 */
		if (command == NULL && last_login_time != 0 && !quiet_login &&
		    !options.use_login) {
			/* Convert the date to a string. */
			time_string = ctime(&last_login_time);
			/* Remove the trailing newline. */
			if (strchr(time_string, '\n'))
				*strchr(time_string, '\n') = 0;
			/* Display the last login time.  Host if displayed
			   if known. */
			if (strcmp(buf, "") == 0)
				printf("Last login: %s\r\n", time_string);
			else
				printf("Last login: %s from %s\r\n", time_string, buf);
		}
		/*
		 * Print /etc/motd unless a command was specified or printing
		 * it was disabled in server options or login(1) will be
		 * used.  Note that some machines appear to print it in
		 * /etc/profile or similar.
		 */
		if (command == NULL && options.print_motd && !quiet_login &&
		    !options.use_login) {
			/* Print /etc/motd if it exists. */
			f = fopen("/etc/motd", "r");
			if (f) {
				while (fgets(line, sizeof(line), f))
					fputs(line, stdout);
				fclose(f);
			}
		}
		/* Do common processing for the child, such as execing the command. */
		do_child(command, pw, term, display, auth_proto, auth_data, ttyname);
		/* NOTREACHED */
	}
	if (pid < 0)
		packet_disconnect("fork failed: %.100s", strerror(errno));
	/* Parent.  Close the slave side of the pseudo tty. */
	close(ttyfd);

	/*
	 * Add a cleanup function to clear the utmp entry and record logout
	 * time in case we call fatal() (e.g., the connection gets closed).
	 */
	cleanup_context.pid = pid;
	cleanup_context.ttyname = ttyname;
	fatal_add_cleanup(pty_cleanup_proc, (void *) &cleanup_context);
	fatal_remove_cleanup(pty_release_proc, (void *) ttyname);

	/*
	 * Create another descriptor of the pty master side for use as the
	 * standard input.  We could use the original descriptor, but this
	 * simplifies code in server_loop.  The descriptor is bidirectional.
	 */
	fdout = dup(ptyfd);
	if (fdout < 0)
		packet_disconnect("dup #1 failed: %.100s", strerror(errno));

	/* we keep a reference to the pty master */
	ptymaster = dup(ptyfd);
	if (ptymaster < 0)
		packet_disconnect("dup #2 failed: %.100s", strerror(errno));

	/* Enter interactive session. */
	server_loop(pid, ptyfd, fdout, -1);
	/* server_loop _has_ closed ptyfd and fdout. */

	/* Cancel the cleanup function. */
	fatal_remove_cleanup(pty_cleanup_proc, (void *) &cleanup_context);

	/* Record that the user has logged out. */
	record_logout(pid, ttyname);

	/* Release the pseudo-tty. */
	pty_release(ttyname);

	/*
	 * Close the server side of the socket pairs.  We must do this after
	 * the pty cleanup, so that another process doesn't get this pty
	 * while we're still cleaning up.
	 */
	if (close(ptymaster) < 0)
		error("close(ptymaster): %s", strerror(errno));
}

/*
 * Sets the value of the given variable in the environment.  If the variable
 * already exists, its value is overriden.
 */
void 
child_set_env(char ***envp, unsigned int *envsizep, const char *name,
	      const char *value)
{
	unsigned int i, namelen;
	char **env;

	/*
	 * Find the slot where the value should be stored.  If the variable
	 * already exists, we reuse the slot; otherwise we append a new slot
	 * at the end of the array, expanding if necessary.
	 */
	env = *envp;
	namelen = strlen(name);
	for (i = 0; env[i]; i++)
		if (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')
			break;
	if (env[i]) {
		/* Reuse the slot. */
		xfree(env[i]);
	} else {
		/* New variable.  Expand if necessary. */
		if (i >= (*envsizep) - 1) {
			(*envsizep) += 50;
			env = (*envp) = xrealloc(env, (*envsizep) * sizeof(char *));
		}
		/* Need to set the NULL pointer at end of array beyond the new slot. */
		env[i + 1] = NULL;
	}

	/* Allocate space and format the variable in the appropriate slot. */
	env[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);
	snprintf(env[i], strlen(name) + 1 + strlen(value) + 1, "%s=%s", name, value);
}

/*
 * Reads environment variables from the given file and adds/overrides them
 * into the environment.  If the file does not exist, this does nothing.
 * Otherwise, it must consist of empty lines, comments (line starts with '#')
 * and assignments of the form name=value.  No other forms are allowed.
 */
void 
read_environment_file(char ***env, unsigned int *envsize,
		      const char *filename)
{
	FILE *f;
	char buf[4096];
	char *cp, *value;

	f = fopen(filename, "r");
	if (!f)
		return;

	while (fgets(buf, sizeof(buf), f)) {
		for (cp = buf; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '#' || *cp == '\n')
			continue;
		if (strchr(cp, '\n'))
			*strchr(cp, '\n') = '\0';
		value = strchr(cp, '=');
		if (value == NULL) {
			fprintf(stderr, "Bad line in %.100s: %.200s\n", filename, buf);
			continue;
		}
		/* Replace the equals sign by nul, and advance value to the value string. */
		*value = '\0';
		value++;
		child_set_env(env, envsize, cp, value);
	}
	fclose(f);
}

/*
 * Performs common processing for the child, such as setting up the
 * environment, closing extra file descriptors, setting the user and group
 * ids, and executing the command or shell.
 */
void 
do_child(const char *command, struct passwd * pw, const char *term,
	 const char *display, const char *auth_proto,
	 const char *auth_data, const char *ttyname)
{
	const char *shell, *cp = NULL;
	char buf[256];
	FILE *f;
	unsigned int envsize, i;
	char **env;
	extern char **environ;
	struct stat st;
	char *argv[10];

	f = fopen("/etc/nologin", "r");
	if (f) {
		/* /etc/nologin exists.  Print its contents and exit. */
		while (fgets(buf, sizeof(buf), f))
			fputs(buf, stderr);
		fclose(f);
		if (pw->pw_uid != 0)
			exit(254);
	}
	/* Set login name in the kernel. */
	if (setlogin(pw->pw_name) < 0)
		error("setlogin failed: %s", strerror(errno));

	/* Set uid, gid, and groups. */
	/* Login(1) does this as well, and it needs uid 0 for the "-h"
	   switch, so we let login(1) to this for us. */
	if (!options.use_login) {
		if (getuid() == 0 || geteuid() == 0) {
			if (setgid(pw->pw_gid) < 0) {
				perror("setgid");
				exit(1);
			}
			/* Initialize the group list. */
			if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
				perror("initgroups");
				exit(1);
			}
			endgrent();

			/* Permanently switch to the desired uid. */
			permanently_set_uid(pw->pw_uid);
		}
		if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
			fatal("Failed to set uids to %d.", (int) pw->pw_uid);
	}
	/*
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
	 */
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;

#ifdef AFS
	/* Try to get AFS tokens for the local cell. */
	if (k_hasafs()) {
		char cell[64];

		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb_afslog(cell, 0);

		krb_afslog(0, 0);
	}
#endif /* AFS */

	/* Initialize the environment. */
	envsize = 100;
	env = xmalloc(envsize * sizeof(char *));
	env[0] = NULL;

	if (!options.use_login) {
		/* Set basic environment. */
		child_set_env(&env, &envsize, "USER", pw->pw_name);
		child_set_env(&env, &envsize, "LOGNAME", pw->pw_name);
		child_set_env(&env, &envsize, "HOME", pw->pw_dir);
		child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);

		snprintf(buf, sizeof buf, "%.200s/%.50s",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, "MAIL", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, "SHELL", shell);
	}
	if (getenv("TZ"))
		child_set_env(&env, &envsize, "TZ", getenv("TZ"));

	/* Set custom environment options from RSA authentication. */
	while (custom_environment) {
		struct envstring *ce = custom_environment;
		char *s = ce->s;
		int i;
		for (i = 0; s[i] != '=' && s[i]; i++);
		if (s[i] == '=') {
			s[i] = 0;
			child_set_env(&env, &envsize, s, s + i + 1);
		}
		custom_environment = ce->next;
		xfree(ce->s);
		xfree(ce);
	}

	snprintf(buf, sizeof buf, "%.50s %d %d",
		 get_remote_ipaddr(), get_remote_port(), get_local_port());
	child_set_env(&env, &envsize, "SSH_CLIENT", buf);

	if (ttyname)
		child_set_env(&env, &envsize, "SSH_TTY", ttyname);
	if (term)
		child_set_env(&env, &envsize, "TERM", term);
	if (display)
		child_set_env(&env, &envsize, "DISPLAY", display);

#ifdef KRB4
	{
		extern char *ticket;

		if (ticket)
			child_set_env(&env, &envsize, "KRBTKFILE", ticket);
	}
#endif /* KRB4 */

	if (xauthfile)
		child_set_env(&env, &envsize, "XAUTHORITY", xauthfile);
	if (auth_get_socket_name() != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
			      auth_get_socket_name());

	/* read $HOME/.ssh/environment. */
	if (!options.use_login) {
		snprintf(buf, sizeof buf, "%.200s/.ssh/environment", pw->pw_dir);
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, "Environment:\n");
		for (i = 0; env[i]; i++)
			fprintf(stderr, "  %.200s\n", env[i]);
	}
	/*
	 * Close the connection descriptors; note that this is the child, and
	 * the server will still have the socket open, and it is important
	 * that we do not shutdown it.  Note that the descriptors cannot be
	 * closed before building the environment, as we call
	 * get_remote_ipaddr there.
	 */
	if (packet_get_connection_in() == packet_get_connection_out())
		close(packet_get_connection_in());
	else {
		close(packet_get_connection_in());
		close(packet_get_connection_out());
	}
	/*
	 * Close all descriptors related to channels.  They will still remain
	 * open in the parent.
	 */
	/* XXX better use close-on-exec? -markus */
	channel_close_all();

	/*
	 * Close any extra file descriptors.  Note that there may still be
	 * descriptors left by system functions.  They will be closed later.
	 */
	endpwent();

	/*
	 * Close any extra open file descriptors so that we don\'t have them
	 * hanging around in clients.  Note that we want to do this after
	 * initgroups, because at least on Solaris 2.3 it leaves file
	 * descriptors open.
	 */
	for (i = 3; i < 64; i++)
		close(i);

	/* Change current directory to the user\'s home directory. */
	if (chdir(pw->pw_dir) < 0)
		fprintf(stderr, "Could not chdir to home directory %s: %s\n",
			pw->pw_dir, strerror(errno));

	/*
	 * Must take new environment into use so that .ssh/rc, /etc/sshrc and
	 * xauth are run in the proper environment.
	 */
	environ = env;

	/*
	 * Run $HOME/.ssh/rc, /etc/sshrc, or xauth (whichever is found first
	 * in this order).
	 */
	if (!options.use_login) {
		if (stat(SSH_USER_RC, &st) >= 0) {
			if (debug_flag)
				fprintf(stderr, "Running /bin/sh %s\n", SSH_USER_RC);

			f = popen("/bin/sh " SSH_USER_RC, "w");
			if (f) {
				if (auth_proto != NULL && auth_data != NULL)
					fprintf(f, "%s %s\n", auth_proto, auth_data);
				pclose(f);
			} else
				fprintf(stderr, "Could not run %s\n", SSH_USER_RC);
		} else if (stat(SSH_SYSTEM_RC, &st) >= 0) {
			if (debug_flag)
				fprintf(stderr, "Running /bin/sh %s\n", SSH_SYSTEM_RC);

			f = popen("/bin/sh " SSH_SYSTEM_RC, "w");
			if (f) {
				if (auth_proto != NULL && auth_data != NULL)
					fprintf(f, "%s %s\n", auth_proto, auth_data);
				pclose(f);
			} else
				fprintf(stderr, "Could not run %s\n", SSH_SYSTEM_RC);
		}
#ifdef XAUTH_PATH
		else {
			/* Add authority data to .Xauthority if appropriate. */
			if (auth_proto != NULL && auth_data != NULL) {
				if (debug_flag)
					fprintf(stderr, "Running %.100s add %.100s %.100s %.100s\n",
						XAUTH_PATH, display, auth_proto, auth_data);

				f = popen(XAUTH_PATH " -q -", "w");
				if (f) {
					fprintf(f, "add %s %s %s\n", display, auth_proto, auth_data);
					pclose(f);
				} else
					fprintf(stderr, "Could not run %s -q -\n", XAUTH_PATH);
			}
		}
#endif /* XAUTH_PATH */

		/* Get the last component of the shell name. */
		cp = strrchr(shell, '/');
		if (cp)
			cp++;
		else
			cp = shell;
	}
	/*
	 * If we have no command, execute the shell.  In this case, the shell
	 * name to be passed in argv[0] is preceded by '-' to indicate that
	 * this is a login shell.
	 */
	if (!command) {
		if (!options.use_login) {
			char buf[256];

			/*
			 * Check for mail if we have a tty and it was enabled
			 * in server options.
			 */
			if (ttyname && options.check_mail) {
				char *mailbox;
				struct stat mailstat;
				mailbox = getenv("MAIL");
				if (mailbox != NULL) {
					if (stat(mailbox, &mailstat) != 0 || mailstat.st_size == 0)
						printf("No mail.\n");
					else if (mailstat.st_mtime < mailstat.st_atime)
						printf("You have mail.\n");
					else
						printf("You have new mail.\n");
				}
			}
			/* Start the shell.  Set initial character to '-'. */
			buf[0] = '-';
			strncpy(buf + 1, cp, sizeof(buf) - 1);
			buf[sizeof(buf) - 1] = 0;

			/* Execute the shell. */
			argv[0] = buf;
			argv[1] = NULL;
			execve(shell, argv, env);

			/* Executing the shell failed. */
			perror(shell);
			exit(1);

		} else {
			/* Launch login(1). */

			execl("/usr/bin/login", "login", "-h", get_remote_ipaddr(),
			      "-p", "-f", "--", pw->pw_name, NULL);

			/* Login couldn't be executed, die. */

			perror("login");
			exit(1);
		}
	}
	/*
	 * Execute the command using the user's shell.  This uses the -c
	 * option to execute the command.
	 */
	argv[0] = (char *) cp;
	argv[1] = "-c";
	argv[2] = (char *) command;
	argv[3] = NULL;
	execve(shell, argv, env);
	perror(shell);
	exit(1);
@


1.94
log
@initial support for DSA keys. ok deraadt@@, niels@@
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.93 2000/03/22 09:55:10 markus Exp $");
d26 2
@


1.93
log
@remove unused cipher_attack_detected code
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.92 2000/03/16 20:56:15 markus Exp $");
d1267 1
a1267 1
	BIGNUM *client_host_key_e, *client_host_key_n;
d1384 7
a1390 2
			client_host_key_e = BN_new();
			client_host_key_n = BN_new();
d1392 2
a1393 2
			packet_get_bignum(client_host_key_e, &elen);
			packet_get_bignum(client_host_key_n, &nlen);
d1395 1
a1395 1
			if (bits != BN_num_bits(client_host_key_n))
d1397 1
a1397 1
				      "actual %d, announced %d", BN_num_bits(client_host_key_n), bits);
d1400 2
a1401 4
			authenticated = auth_rhosts_rsa(pw, client_user,
				   client_host_key_e, client_host_key_n);
			BN_clear_free(client_host_key_e);
			BN_clear_free(client_host_key_n);
@


1.92
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.91 2000/03/09 19:31:47 markus Exp $");
a513 3

	/* Close connection cleanly after attack. */
	cipher_attack_detected = packet_disconnect;
@


1.91
log
@disallow guessing of root password
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.90 2000/03/06 20:29:04 markus Exp $");
d1186 2
a1187 1
	int plen, ulen;
d1274 3
a1276 1
	int plen, dlen, nlen, ulen, elen;
d1557 1
a1557 1
		int dlen;
d1641 2
a1665 1
		int plen, dlen;
d1744 1
a1744 1
				int proto_len, data_len;
d1826 1
a1826 1
				int dlen;
@


1.90
log
@fix pr 1113, fclose() -> pclose(), todo: remote popen()
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.89 2000/02/28 19:40:23 markus Exp $");
a1246 8
	/* Check if the user is logging in as root and root logins are disallowed. */
	if (pw->pw_uid == 0 && !options.permit_root_login) {
		if (forced_command)
			log("Root login accepted for forced command.");
		else
			packet_disconnect("ROOT LOGIN REFUSED FROM %.200s",
					  get_canonical_hostname());
	}
d1482 15
@


1.89
log
@create x11 cookie file
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.88 2000/02/15 16:52:57 markus Exp $");
d2465 1
a2465 1
					fclose(f);
@


1.88
log
@register cleanup for pty earlier. move code for pty-owner handling to pty.c
ok provos@@, dugsong@@
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.87 2000/02/15 09:25:45 markus Exp $");
d1758 2
a1760 1
			strlcat(xauthfile, "/cookies", MAXPATHLEN);
@


1.87
log
@move XAUTHORITY to subdir. ok dugsong@@. fixes debian bug #57907, too.
(http://cgi.debian.org/cgi-bin/bugreport.cgi?archive=no&bug=57907)
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.86 2000/02/06 10:18:58 markus Exp $");
d1585 31
d1630 1
a1630 5
	char *command, *term = NULL, *display = NULL, *proto = NULL,
	*data = NULL;
	struct group *grp;
	gid_t tty_gid;
	mode_t tty_mode;
d1689 2
a1690 17
			/* Determine the group to make the owner of the tty. */
			grp = getgrnam("tty");
			if (grp) {
				tty_gid = grp->gr_gid;
				tty_mode = S_IRUSR | S_IWUSR | S_IWGRP;
			} else {
				tty_gid = pw->pw_gid;
				tty_mode = S_IRUSR | S_IWUSR | S_IWGRP | S_IWOTH;
			}

			/* Change ownership of the tty. */
			if (chown(ttyname, pw->pw_uid, tty_gid) < 0)
				fatal("chown(%.100s, %d, %d) failed: %.100s",
				      ttyname, pw->pw_uid, tty_gid, strerror(errno));
			if (chmod(ttyname, tty_mode) < 0)
				fatal("chmod(%.100s, 0%o) failed: %.100s",
				      ttyname, tty_mode, strerror(errno));
d1695 1
a1695 1
			/* packet_integrity_check(plen, 4 + dlen + 4*4 + n_bytes, type); */
d1699 2
a1700 1
			if (strcmp(term, "") == 0)
d1702 1
a1974 23
struct pty_cleanup_context {
	const char *ttyname;
	int pid;
};

/*
 * Function to perform cleanup if we get aborted abnormally (e.g., due to a
 * dropped connection).
 */
void 
pty_cleanup_proc(void *context)
{
	struct pty_cleanup_context *cu = context;

	debug("pty_cleanup_proc called");

	/* Record that the user has logged out. */
	record_logout(cu->pid, cu->ttyname);

	/* Release the pseudo-tty. */
	pty_release(cu->ttyname);
}

d2112 9
a2132 8

	/*
	 * Add a cleanup function to clear the utmp entry and record logout
	 * time in case we call fatal() (e.g., the connection gets closed).
	 */
	cleanup_context.pid = pid;
	cleanup_context.ttyname = ttyname;
	fatal_add_cleanup(pty_cleanup_proc, (void *) &cleanup_context);
@


1.86
log
@typo
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.85 2000/02/05 10:13:12 markus Exp $");
d147 21
d898 1
a898 1
		unlink(xauthfile);
a1584 16

/*
 * Remove local Xauthority file.
 */
static void
xauthfile_cleanup_proc(void *ignore)
{
	debug("xauthfile_cleanup_proc called");

	if (xauthfile != NULL) {
		unlink(xauthfile);
		xfree(xauthfile);
		xauthfile = NULL;
	}
}

d1596 1
a1596 1
	int have_pty = 0, ptyfd = -1, ttyfd = -1, xauthfd = -1;
d1734 6
a1739 7
			snprintf(xauthfile, MAXPATHLEN, "/tmp/XauthXXXXXX");

			if ((xauthfd = mkstemp(xauthfile)) != -1) {
				fchown(xauthfd, pw->pw_uid, pw->pw_gid);
				close(xauthfd);
				fatal_add_cleanup(xauthfile_cleanup_proc, NULL);
			} else {
d1742 1
d1744 3
@


1.85
log
@missing xfree()
@
text
@d1 1
a1 1

d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.84 2000/02/01 13:52:26 markus Exp $");
@


1.84
log
@oops, fix comment, too.
@
text
@d1 1
a1 1
/*
d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.83 2000/01/31 23:57:01 markus Exp $");
d1189 1
d1208 1
a1208 1
	debug("Attempting authentication for %.100s.", user);
d1531 1
d1545 2
@


1.83
log
@delay close() of pty until the pty has been chowned back to root
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.82 2000/01/27 20:20:02 markus Exp $");
d2132 1
a2132 1
	/* server_loop has not closed ptyfd and fdout. */
@


1.82
log
@deny login if shell does not exist or is not executable at all
make no-port-forwarding for RSA keys deny both -L and -R style fwding
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.81 2000/01/24 20:31:19 markus Exp $");
d1985 1
d2115 6
a2120 1
		packet_disconnect("dup failed: %.100s", strerror(errno));
d2148 2
a2149 2
	close(ptyfd);
	close(fdout);
@


1.81
log
@don't panic if client behaves strange. ok deraadt@@
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.80 2000/01/20 15:19:22 markus Exp $");
d1083 3
a1085 2
 * returned. Otherwise true is returned.
 * XXX This function should also check if user has a valid shell
d1090 1
d1098 5
a1102 1
	/* XXX Should check for valid login shell */
d1610 2
a1611 1
	channel_permit_all_opens();
@


1.80
log
@log with level log() not fatal() if peer behaves badly.
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.79 2000/01/18 13:45:05 markus Exp $");
d233 1
d252 2
a253 2
	fatal("get_authname: unknown auth %d: internal error", type);
	return NULL;
@


1.79
log
@no need for poll.h; from bright@@wintelcom.net
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.78 2000/01/18 09:42:18 markus Exp $");
d780 4
a783 2
		if (atomicio(write, sock_out, buf, strlen(buf)) != strlen(buf))
			fatal("Could not write ident string to %s.", remote_ip);
d787 4
a790 2
			if (read(sock_in, &buf[i], 1) != 1)
				fatal("Did not receive ident string from %s.", remote_ip);
d816 3
a818 2
		fatal("Bad protocol version identification '%.100s' from %s",
		      buf, remote_ip);
d828 3
a830 2
		fatal("Protocol major versions differ for %s: %d vs. %d",
		      remote_ip, PROTOCOL_MAJOR, remote_major);
@


1.78
log
@disable agent fwding for proto 1.3, remove abuse of auth-rsa flags.
@
text
@d14 1
a14 3
RCSID("$OpenBSD: sshd.c,v 1.77 2000/01/16 23:03:10 markus Exp $");

#include <poll.h>
@


1.77
log
@split key exchange (kex) and user authentication (user-auth), ok: provos@@
@
text
@d14 1
a14 1
RCSID("$OpenBSD: sshd.c,v 1.76 2000/01/04 16:54:58 markus Exp $");
d833 1
a834 4
		if (strcmp(remote_version, "OpenSSH-1.1") != 0) {
			debug("Agent forwarding disabled, remote version is not compatible.");
			no_agent_forwarding_flag = 1;
		}
d1730 1
a1730 1
			if (no_agent_forwarding_flag) {
@


1.76
log
@allow auth-kerberos for IPv4 only
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.75 2000/01/04 00:08:01 markus Exp $");
d132 2
a133 2
void do_connection();
void do_authentication(char *user);
d861 5
a865 2
	/* Handle the connection. */
	do_connection();
d884 1
a884 3
 * Process an incoming connection.  Protocol version identifiers have already
 * been exchanged.  This sends server key and performs the key exchange.
 * Server and host keys will no longer be needed after this functions.
d887 1
a887 1
do_connection()
d890 1
d893 1
a893 2
	unsigned char check_bytes[8];
	char *user;
a894 1
	int plen, slen, ulen;
d909 1
a909 1
		check_bytes[i] = rand & 0xff;
d920 1
a920 1
		packet_put_char(check_bytes[i]);
d983 1
a983 1
		if (check_bytes[i] != packet_get_char())
d1031 1
a1031 1
	compute_session_id(session_id, check_bytes,
d1035 5
d1054 3
a1060 3
	/* Destroy the decrypted integer.  It is no longer needed. */
	BN_clear_free(session_key_int);

d1073 1
a1074 16
	/* Get the name of the user that we wish to log in as. */
	packet_read_expect(&plen, SSH_CMSG_USER);

	/* Get the user name. */
	user = packet_get_string(&ulen);
	packet_integrity_check(plen, (4 + ulen), SSH_CMSG_USER);

	/* Destroy the private and public keys.  They will no longer be needed. */
	RSA_free(public_key);
	RSA_free(sensitive_data.private_key);
	RSA_free(sensitive_data.host_key);

	setproctitle("%s", user);
	/* Do the authentication. */
	do_authentication(user);
}
d1151 1
a1151 2
 * been exchanged and encryption is enabled.  User is the user name to log
 * in as (received from the client).
d1154 1
a1154 1
do_authentication(char *user)
d1157 11
@


1.75
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.74 1999/12/12 19:20:03 markus Exp $");
d851 8
@


1.74
log
@type conflict for 'extern Type *options' in channels.c; dot@@dotat.at
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.73 1999/12/08 23:59:12 markus Exp $");
d50 6
d77 2
a78 2
 * This is set to the socket that the server is listening; this is used in
 * the SIGHUP signal handler.
d80 3
a82 1
int listen_sock;
d149 12
d180 1
a180 1
	close(listen_sock);
d195 1
a195 1
	close(listen_sock);
d302 2
a303 1
	int opt, aux, sock_in, sock_out, newsock, i, pid, on = 1;
d306 2
a307 2
	struct pollfd fds;
	struct sockaddr_in sin;
d315 3
d330 1
a330 1
	while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:diqQ")) != EOF) {
d332 6
d358 4
a361 1
			options.port = atoi(optarg);
d391 3
a393 1
				HOST_KEY_FILE);
d398 9
a425 4
	if (options.port < 1 || options.port > 65535) {
		fprintf(stderr, "Bad port number.\n");
		exit(1);
	}
a430 3
	/* Force logging to stderr while loading the private host key
	   unless started from inetd */
	log_init(av0, options.log_level, options.log_facility, !inetd_flag);
d519 54
a572 25
		/* Create socket for listening. */
		listen_sock = socket(AF_INET, SOCK_STREAM, 0);
		if (listen_sock < 0)
			fatal("socket: %.100s", strerror(errno));

		/* Set socket options.  We try to make the port reusable
		   and have it close as fast as possible without waiting
		   in unnecessary wait states on close. */
		setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, (void *) &on,
			   sizeof(on));
		linger.l_onoff = 1;
		linger.l_linger = 5;
		setsockopt(listen_sock, SOL_SOCKET, SO_LINGER, (void *) &linger,
			   sizeof(linger));

		memset(&sin, 0, sizeof(sin));
		sin.sin_family = AF_INET;
		sin.sin_addr = options.listen_addr;
		sin.sin_port = htons(options.port);

		if (bind(listen_sock, (struct sockaddr *) & sin, sizeof(sin)) < 0) {
			error("bind: %.100s", strerror(errno));
			shutdown(listen_sock, SHUT_RDWR);
			close(listen_sock);
			fatal("Bind to port %d failed.", options.port);
d574 5
a593 4
		log("Server listening on port %d.", options.port);
		if (listen(listen_sock, 5) < 0)
			fatal("listen: %.100s", strerror(errno));

d615 8
d630 11
a640 6
			/* Wait in poll until there is a connection. */
			memset(&fds, 0, sizeof(fds));
			fds.fd = listen_sock;
			fds.events = POLLIN;
			if (poll(&fds, 1, -1) == -1) {
				if (errno == EINTR)
d642 7
a648 2
				fatal("poll: %.100s", strerror(errno));
				/*NOTREACHED*/
d650 2
a651 10
			if (fds.revents == 0)
				continue;
			aux = sizeof(sin);
			newsock = accept(listen_sock, (struct sockaddr *) & sin, &aux);
			if (received_sighup)
				sighup_restart();
			if (newsock < 0) {
				if (errno == EINTR)
					continue;
				error("accept: %.100s", strerror(errno));
d665 1
a665 1
				close(listen_sock);
d682 1
a682 1
					close(listen_sock);
d703 4
d745 1
d757 1
a757 1
		verbose("Connection from %.500s port %d", eval_client(&req), remote_port);
d759 1
a759 1
#else
a761 1
#endif /* LIBWRAP */
d783 1
a783 1
			fatal("Could not write ident string to %s.", get_remote_ipaddr());
d788 1
a788 1
				fatal("Did not receive ident string from %s.", get_remote_ipaddr());
d815 1
a815 1
		      buf, get_remote_ipaddr());
d826 1
a826 2
		      get_remote_ipaddr(),
		      PROTOCOL_MAJOR, remote_major);
d1975 2
a1976 2
	struct sockaddr_in from;
	int fromlen;
d2037 1
a2037 1
			     &from);
d2316 1
a2316 1
		 get_remote_ipaddr(), get_remote_port(), options.port);
a2376 1
	endhostent();
@


1.73
log
@repair fake-skey for AUTH_TIS
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.72 1999/12/08 04:36:41 deraadt Exp $");
d1622 1
a1622 1
			display = x11_create_display_inet(screen);
@


1.72
log
@careless niels
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.71 1999/12/08 00:08:09 provos Exp $");
d806 1
a806 1
	int plen, slen;
d985 2
a986 5
	{
		int ulen;
		user = packet_get_string(&ulen);
		packet_integrity_check(plen, (4 + ulen), SSH_CMSG_USER);
	}
d1431 2
a1432 6
		if (options.password_authentication &&
		    options.skey_authentication == 1 &&
		    type == SSH_CMSG_AUTH_PASSWORD &&
		    (password = packet_get_string(&dlen)) != NULL &&
		    dlen == 5 &&
		    strncasecmp(password, "s/key", 5) == 0 &&
d1434 13
a1446 2
			/* Send a fake s/key challenge. */
			packet_send_debug(skeyinfo);
@


1.71
log
@make that a fatal
@
text
@d14 3
a16 1
RCSID("$Id: sshd.c,v 1.70 1999/12/07 23:14:36 provos Exp $");
@


1.70
log
@fix sighup handling.  accept would just restart and daemon handled sighup
only after the next connection was accepted. use poll on listen sock now.
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.69 1999/12/07 17:52:29 markus Exp $");
d560 1
a560 1
				error("poll: %.100s", strerror(errno));
@


1.69
log
@make sure the client selects a supported cipher
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.68 1999/12/06 20:15:30 deraadt Exp $");
d283 1
d553 12
a564 1
			/* Wait in accept until there is a connection. */
@


1.68
log
@move atomicio into it's own file.  wrap all socket write()s which were doing
write(sock, buf, len) != len, with atomicio() calls.
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.67 1999/12/06 12:10:12 deraadt Exp $");
d872 1
a872 1
	/* Get cipher type. */
d874 3
@


1.67
log
@use openpty() if it exists (it does on BSD4_4)
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.66 1999/11/24 19:53:53 markus Exp $");
d687 1
a687 1
		if (write(sock_out, buf, strlen(buf)) != strlen(buf))
d713 4
a716 3
		   remote_version) != 3) {
		const char *s = "Protocol mismatch.\n";
		(void) write(sock_out, s, strlen(s));
d725 3
a727 2
		const char *s = "Protocol major versions differ.\n";
		(void) write(sock_out, s, strlen(s));
@


1.66
log
@KNF, final part 3
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.65 1999/11/24 00:26:03 deraadt Exp $");
d1528 2
a1529 1
			if (!pty_allocate(&ptyfd, &ttyfd, ttyname)) {
@


1.65
log
@much more KNF
@
text
@d14 1
a14 1
RCSID("$Id: sshd.c,v 1.64 1999/11/23 22:25:55 markus Exp $");
d68 4
a71 2
/* This is set to the socket that the server is listening; this is used in
   the SIGHUP signal handler. */
d74 4
a77 2
/* the client's version string, passed by sshd2 in compat mode.
   if != NULL, sshd will skip the version-number exchange */
d95 8
a102 6
/* Any really sensitive data in the application is contained in this structure.
   The idea is that this structure could be locked into memory so that the
   pages do not get written into swap.  However, there are some problems.
   The private key contains BIGNUMs, and we do not (in principle) have
   access to the internals of them, and locking just the structure is not
   very useful.  Currently, memory locking is not implemented. */
d108 4
a111 2
/* Flag indicating whether the current session key has been used.  This flag
   is set whenever the key is used, and cleared when the key is regenerated. */
d346 1
a346 1
			fprintf(stderr, "  -f file    Configuration file (default %s/sshd_config)\n", ETCDIR);
a493 1
		/* Initialize the socket address. */
a498 1
		/* Bind the socket to the desired port. */
d506 7
a512 6
			/* Record our pid in /etc/sshd_pid to make it
			   easier to kill the correct sshd.  We don\'t
			   want to do this before the bind above because
			   the bind will fail if there already is a
			   daemon, and this will overwrite any old pid in
			   the file. */
d545 4
a548 2
		/* Stay listening for connections until the system crashes
		   or the daemon is killed with a signal. */
d563 4
a566 2
			/* Got connection.  Fork a child to handle it,
			   unless we are in debugging mode. */
d568 5
a572 3
				/* In debugging mode.  Close the listening
				   socket, and start processing the
				   connection without forking. */
d580 5
a584 3
				/* Normal production daemon.  Fork, and
				   have the child process the connection.
				   The parent continues listening. */
d586 5
a590 6
					/* Child.  Close the listening
					   socket, and start using the
					   accepted socket.  Reinitialize
					   logging (since our pid has
					   changed).  We break out of the
					   loop to handle the connection. */
d617 5
a621 3
	/* Disable the key regeneration alarm.  We will not regenerate the
	   key since we are no longer in a position to give it to anyone.
	   We will not restart on SIGHUP since it no longer makes sense. */
d629 6
a634 5
	/* Set socket options for the connection.  We want the socket to
	   close as fast as possible without waiting for anything.  If the
	   connection is not a socket, these will do nothing. */
	/* setsockopt(sock_in, SOL_SOCKET, SO_REUSEADDR, (void *)&on,
	   sizeof(on)); */
d639 4
a642 2
	/* Register our connection.  This turns encryption off because we
	   do not have a key. */
d668 8
a675 6
	/* We don\'t want to listen forever unless the other side
	   successfully authenticates itself.  So we set up an alarm which
	   is cleared after successful authentication.  A limit of zero
	   indicates no limit. Note that we don\'t set the alarm in
	   debugging mode; it is just annoying to have the server exit
	   just when you are about to discover the bug. */
d708 4
a711 2
	/* Check that the versions match.  In future this might accept
	   several versions and set appropriate flags to handle them. */
d743 7
a749 5
	/* Check that the connection comes from a privileged port.  Rhosts-
	   and Rhosts-RSA-Authentication only make sense from priviledged
	   programs.  Of course, if the intruder has root access on his
	   local machine, he can connect from any port.  So do not use
	   these authentication methods from machines that you do not trust. */
d793 9
a801 7
	/* Generate check bytes that the client must send back in the user
	   packet in order for it to be accepted; this is used to defy ip
	   spoofing attacks.  Note that this only works against somebody
	   doing IP spoofing from a remote machine; any machine on the
	   local network can still see outgoing packets and catch the
	   random cookie.  This only affects rhosts authentication, and
	   this is one of the reasons why it is inherently insecure. */
d809 5
a813 3
	/* Send our public key.  We include in the packet 64 bits of
	   random data that must be matched in the reply in order to
	   prevent IP spoofing. */
a884 1
	/* Get protocol flags. */
d890 4
a893 2
	/* Decrypt it using our private server key and private host key
	   (key with larger modulus first). */
a923 1
	/* Compute session id for this session. */
d928 5
a932 3
	/* Extract session key from the decrypted integer.  The key is in
	   the least significant 256 bits of the integer; the first byte
	   of the key is in the highest bits. */
d1010 1
a1010 2
	/* Return false if AllowUsers isn't empty and user isn't listed
	   there */
d1035 4
a1038 2
		/* Return false if AllowGroups isn't empty and user's
		   group isn't listed there */
d1088 4
a1091 2
	/* If we are not running as root, the user must have the same uid
	   as the server. */
d1228 6
a1233 4
			/* Get client user name.  Note that we just have
			   to trust the client; this is one reason why
			   rhosts authentication is insecure. (Another is
			   IP-spoofing on a local network.) */
d1250 5
a1254 3
			/* Get client user name.  Note that we just have
			   to trust the client; root on the client machine
			   can claim to be any user. */
d1296 5
a1300 3
			/* Read user password.  It is in plain text, but
			   was transmitted over the encrypted channel so
			   it is not visible to an outside observer. */
d1321 1
a1321 2
					/* we send our s/key- in
					   tis-challenge messages */
d1350 4
a1353 2
			/* Any unknown messages will be ignored (and
			   failure returned) during authentication. */
d1404 4
a1407 2
	/* Keep reading packets, and always respond with a failure.  This
	   is to avoid disclosing whether such a user really exists. */
d1409 1
a1409 2
		/* Read a packet.  This will not return if the client
		   disconnects. */
d1429 4
a1432 2
		/* Send failure.  This should be indistinguishable from a
		   failed authentication. */
d1478 4
a1481 2
	/* Cancel the alarm we set to limit the time taken for
	   authentication. */
d1484 7
a1490 5
	/* Inform the channel mechanism that we are the server side and
	   that the client may request to connect to any port at all.
	   (The user could do it anyway, and we wouldn\'t know what is
	   permitted except by the client telling us, so we can equally
	   well trust the client not to request anything bogus.) */
d1493 4
a1496 2
	/* We stay in this loop until the client requests to execute a
	   shell or a command. */
d1680 4
a1683 2
			/* Any unknown messages in this phase are ignored,
			   and a failure message is returned. */
d1708 4
a1711 2
		/* There is a forced command specified for this login.
		   Execute it. */
d1755 4
a1758 2
		/* Create a new session and process group since the 4.4BSD
		   setlogin() affects the entire process group. */
d1763 4
a1766 2
		/* Redirect stdin.  We close the parent side of the socket
		   pair, and make the child side the standard input. */
d1784 5
a1788 3
		/* Redirect stdin, stdout, and stderr.  Stdin and stdout
		   will use the same socket, as some programs
		   (particularly rdist) seem to depend on it. */
d1819 4
a1822 2
	/* Enter the interactive session.  Note: server_loop must be able
	   to handle the case that fdin and fdout are the same. */
d1878 4
a1881 2
	/* Get the time when the user last logged in.  Buf will be set to
	   contain the hostname the last login was from. */
d1917 5
a1921 3
		/* Get IP address of client.  This is needed because we
		   want to record where the user logged in from.  If the
		   connection is not a socket, let the ip address be 0.0.0.0. */
d1939 8
a1946 6
		/* If the user has logged in before, display the time of
		   last login. However, don't display anything extra if a
		   command has been specified (so that ssh can be used to
		   execute commands on a remote machine without users
		   knowing they are going to another machine). Login(1)
		   will do this for us as well, so check if login(1) is used */
d1961 6
a1966 4
		/* Print /etc/motd unless a command was specified or
		   printing it was disabled in server options or login(1)
		   will be used.  Note that some machines appear to print
		   it in /etc/profile or similar. */
d1986 5
a1990 3
	/* Create another descriptor of the pty master side for use as the
	   standard input.  We could use the original descriptor, but this
	   simplifies code in server_loop.  The descriptor is bidirectional. */
d1995 4
a1998 2
	/* Add a cleanup function to clear the utmp entry and record logout
	   time in case we call fatal() (e.g., the connection gets closed). */
d2016 5
a2020 3
	/* Close the server side of the socket pairs.  We must do this
	   after the pty cleanup, so that another process doesn't get this
	   pty while we're still cleaning up. */
d2036 5
a2040 3
	/* Find the slot where the value should be stored.  If the
	   variable already exists, we reuse the slot; otherwise we append
	   a new slot at the end of the array, expanding if necessary. */
d2047 1
a2047 1
		/* Name already exists.  Reuse the slot. */
d2050 1
a2050 1
		/* New variable.  Expand the array if necessary. */
a2077 1
	/* Open the environment file. */
a2081 1
	/* Process each line. */
d2083 2
a2084 4
		/* Skip leading whitespace. */
		for (cp = buf; *cp == ' ' || *cp == '\t'; cp++);

		/* Ignore empty and comment lines. */
a2086 2

		/* Remove newline. */
a2088 3

		/* Find the equals sign.  Its lack indicates badly
		   formatted line. */
d2094 1
a2094 2
		/* Replace the equals sign by nul, and advance value to
		   the value string. */
a2096 2

		/* Set the value in environment. */
a2098 1

a2120 1
	/* Check /etc/nologin. */
d2156 4
a2159 2
	/* Get the shell from the password data.  An empty shell field is
	   legal, and means /bin/sh. */
d2174 1
a2174 2
	/* Initialize the environment.  In the first part we allocate
	   space for all environment variables. */
a2192 1
	/* Let it inherit timezone if we have one. */
a2210 1
	/* Set SSH_CLIENT. */
a2214 1
	/* Set SSH_TTY if we have a pty. */
a2216 2

	/* Set TERM if we have a pty. */
a2218 2

	/* Set DISPLAY if we have one. */
a2230 1
	/* Set XAUTHORITY to always be a local file. */
a2232 3

	/* Set variable for forwarded authentication connection, if we
	   have one. */
d2237 1
a2237 1
	/* Read $HOME/.ssh/environment. */
a2241 1
	/* If debugging, dump the environment to stderr. */
d2243 1
d2248 7
a2254 5
	/* Close the connection descriptors; note that this is the child,
	   and the server will still have the socket open, and it is
	   important that we do not shutdown it.  Note that the
	   descriptors cannot be closed before building the environment,
	   as we call get_remote_ipaddr there. */
d2261 5
a2265 2
	/* Close all descriptors related to channels.  They will still
	   remain open in the parent. */
d2268 4
a2271 3
	/* Close any extra file descriptors.  Note that there may still be
	   descriptors left by system functions.  They will be closed
	   later. */
d2275 6
a2280 4
	/* Close any extra open file descriptors so that we don\'t have
	   them hanging around in clients.  Note that we want to do this
	   after initgroups, because at least on Solaris 2.3 it leaves
	   file descriptors open. */
d2289 4
a2292 2
	/* Must take new environment into use so that .ssh/rc, /etc/sshrc
	   and xauth are run in the proper environment. */
d2295 4
a2298 2
	/* Run $HOME/.ssh/rc, /etc/sshrc, or xauth (whichever is found
	   first in this order). */
d2325 1
a2325 2
			/* Add authority data to .Xauthority if
			   appropriate. */
d2348 5
a2352 3
	/* If we have no command, execute the shell.  In this case, the
	   shell name to be passed in argv[0] is preceded by '-' to
	   indicate that this is a login shell. */
d2357 4
a2360 2
			/* Check for mail if we have a tty and it was
			   enabled in server options. */
d2400 4
a2403 2
	/* Execute the command using the user's shell.  This uses the -c
	   option to execute the command. */
@


1.64
log
@KNF part 1
@
text
@d2 10
a11 17

sshd.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Fri Mar 17 17:09:28 1995 ylo

This program is the ssh daemon.  It listens for connections from clients, and
performs authentication, executes use commands or shell, and forwards
information to/from the application to the user client over an encrypted
connection.  This can also handle forwarding of X11, TCP/IP, and authentication
agent connections.

*/
d14 1
a14 1
RCSID("$Id: sshd.c,v 1.63 1999/11/22 21:52:42 markus Exp $");
d48 6
a53 4
/* Debug mode flag.  This can be set on the command line.  If debug
   mode is enabled, extra debugging output will be sent to the system
   log, the daemon will not go to background, and will exit after processing
   the first connection. */
d130 5
a134 4
/* Signal handler for SIGHUP.  Sshd execs itself when it receives SIGHUP;
   the effect is to reread the configuration file (and to regenerate
   the server key). */

d142 4
a145 2
/* Called from the main program after receiving SIGHUP.  Restarts the server. */

d156 5
a160 4
/* Generic signal handler for terminating signals in the master daemon.
   These close the listen socket; not closing it seems to cause "Address
   already in use" problems on some machines, which is inconvenient. */

d169 4
a172 3
/* SIGCHLD handler.  This is called whenever a child dies.  This will then
   reap any zombies left by exited c. */

d186 3
a188 2
/* Signal handler for the alarm after the login grace period has expired. */

d199 3
a201 1
/* convert ssh auth msg type into description */
d227 7
a233 5
/* Signal handler for the key regeneration alarm.  Note that this
   alarm only occurs in the daemon waiting for connections, and it does not
   do anything with the private key or random state before forking.  Thus there
   should be no concurrency control/asynchronous execution problems. */

d264 3
a266 2
/* Main program for the daemon. */

d751 5
a755 4
/* Process an incoming connection.  Protocol version identifiers have already
   been exchanged.  This sends server key and performs the key exchange.
   Server and host keys will no longer be needed after this functions. */

d951 8
a958 7
/* Check if the user is allowed to log in via ssh. If user is listed in
   DenyUsers or user's primary group is listed in DenyGroups, false will
   be returned. If AllowUsers isn't empty and user isn't listed there, or
   if AllowGroups isn't empty and user isn't listed there, false will be
   returned. Otherwise true is returned.
   XXX This function should also check if user has a valid shell */

d1023 5
a1027 4
/* Performs authentication of an incoming connection.  Session key has already
   been exchanged and encryption is enabled.  User is the user name to log
   in as (received from the client). */

d1100 4
a1103 2
/* read packets and try to authenticate local user *pw.
   return if authentication is successfull */
d1344 4
a1347 2
/* The user does not exist or access is denied,
   but fake indication that authentication is needed. */
d1398 3
a1400 1
/* Remove local Xauthority file. */
d1413 6
a1418 5
/* Prepares for an interactive session.  This is called after the user has
   been successfully authenticated.  During this message exchange, pseudo
   terminals are allocated, X11, TCP/IP, and authentication agent forwardings
   are requested, etc. */

d1667 5
a1671 4
/* This is called to fork and execute a command when we have no tty.  This
   will call do_child from the child, and server_loop from the parent after
   setting up file descriptors and such. */

d1771 4
a1774 3
/* Function to perform cleanup if we get aborted abnormally (e.g., due to a
   dropped connection). */

d1789 6
a1794 5
/* This is called to fork and execute a command when we have a tty.  This
   will call do_child from the child, and server_loop from the parent after
   setting up file descriptors, controlling tty, updating wtmp, utmp,
   lastlog, and other such operations. */

d1949 4
a1952 3
/* Sets the value of the given variable in the environment.  If the variable
   already exists, its value is overriden. */

d1986 6
a1991 5
/* Reads environment variables from the given file and adds/overrides them
   into the environment.  If the file does not exist, this does nothing.
   Otherwise, it must consist of empty lines, comments (line starts with '#')
   and assignments of the form name=value.  No other forms are allowed. */

d2037 5
a2041 4
/* Performs common processing for the child, such as setting up the
   environment, closing extra file descriptors, setting the user and group
   ids, and executing the command or shell. */

@


1.63
log
@tranfer s/key challenge/response data in SSH_SMSG_AUTH_TIS_CHALLENGE
messages. allows use of s/key in windows (ttssh, securecrt) and
ssh-1.2.27 clients without 'ssh -v', ok: niels@@
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.62 1999/11/22 21:02:39 markus Exp $");
d81 1
a81 2
/* Flags set in auth-rsa from authorized_keys flags.  These are set in
  auth-rsa.c. */
d86 6
a91 3
char *forced_command = NULL;  /* RSA authentication "command=" option. */
struct envstring *custom_environment = NULL; 
			  /* RSA authentication "environment=" options. */
d102 3
a104 7
struct
{
  /* Private part of server key. */
  RSA *private_key;

  /* Private part of host key. */
  RSA *host_key;
d121 1
a121 1
void do_authloop(struct passwd *pw);
d123 9
a131 9
void do_authenticated(struct passwd *pw);
void do_exec_pty(const char *command, int ptyfd, int ttyfd, 
		 const char *ttyname, struct passwd *pw, const char *term,
		 const char *display, const char *auth_proto,
		 const char *auth_data);
void do_exec_no_pty(const char *command, struct passwd *pw,
		    const char *display, const char *auth_proto,
		    const char *auth_data);
void do_child(const char *command, struct passwd *pw, const char *term,
d139 2
a140 1
void sighup_handler(int sig)
d142 2
a143 2
  received_sighup = 1;
  signal(SIGHUP, sighup_handler);
d146 1
a146 2
/* Called from the main program after receiving SIGHUP.  Restarts the 
   server. */
d148 2
a149 1
void sighup_restart()
d151 5
a155 5
  log("Received SIGHUP; restarting.");
  close(listen_sock);
  execv(saved_argv[0], saved_argv);
  log("RESTART FAILED: av0='%s', error: %s.", av0, strerror(errno));
  exit(1);
d158 1
a158 1
/* Generic signal handler for terminating signals in the master daemon. 
d162 2
a163 1
void sigterm_handler(int sig)
d165 3
a167 3
  log("Received signal %d; terminating.", sig);
  close(listen_sock);
  exit(255);
d170 1
a170 1
/* SIGCHLD handler.  This is called whenever a child dies.  This will then 
d173 2
a174 1
void main_sigchld_handler(int sig)
d176 2
a177 2
  int save_errno = errno;
  int status;
d179 2
a180 2
  while (waitpid(-1, &status, WNOHANG) > 0)
	;
d182 2
a183 2
  signal(SIGCHLD, main_sigchld_handler);
  errno = save_errno;
d188 2
a189 1
void grace_alarm_handler(int sig)
d191 5
a195 5
  /* Close the connection. */
  packet_close();
  
  /* Log error and exit. */
  fatal("Timeout before authentication for %s.", get_remote_ipaddr());
d202 9
a210 9
  switch (type) {
  case SSH_CMSG_AUTH_PASSWORD:
    return "password";
  case SSH_CMSG_AUTH_RSA:
    return "rsa";
  case SSH_CMSG_AUTH_RHOSTS_RSA:
    return "rhosts-rsa";
  case SSH_CMSG_AUTH_RHOSTS:
    return "rhosts";
d212 2
a213 2
  case SSH_CMSG_AUTH_KERBEROS:
    return "kerberos";
d216 2
a217 2
  case SSH_CMSG_AUTH_TIS_RESPONSE:
    return "s/key";
d219 3
a221 3
  }
  fatal("get_authname: unknown auth %d: internal error", type);
  return NULL;
d229 2
a230 1
void key_regeneration_alarm(int sig)
d232 1
a232 1
  int save_errno = errno;
d234 23
a256 25
  /* Check if we should generate a new key. */
  if (key_used)
    {
      /* This should really be done in the background. */
      log("Generating new %d bit RSA key.", options.server_key_bits);

      if (sensitive_data.private_key != NULL)
	RSA_free(sensitive_data.private_key);
      sensitive_data.private_key = RSA_new();

      if (public_key != NULL) 
	RSA_free(public_key);
      public_key = RSA_new();

      rsa_generate_key(sensitive_data.private_key, public_key, 
		       options.server_key_bits);
      arc4random_stir();
      key_used = 0;
      log("RSA key generation complete.");
    }

  /* Reschedule the alarm. */
  signal(SIGALRM, key_regeneration_alarm);
  alarm(options.key_regeneration_time);
  errno = save_errno;
d264 137
a400 145
  extern char *optarg;
  extern int optind;
  int opt, aux, sock_in, sock_out, newsock, i, pid, on = 1;
  int remote_major, remote_minor;
  int silentrsa = 0;
  struct sockaddr_in sin;
  char buf[100]; /* Must not be larger than remote_version. */
  char remote_version[100]; /* Must be at least as big as buf. */
  const char *remote_ip;
  int remote_port;
  char *comment;
  FILE *f;
  struct linger linger;

  /* Save argv[0]. */
  saved_argv = av;
  if (strchr(av[0], '/'))
    av0 = strrchr(av[0], '/') + 1;
  else
    av0 = av[0];

  /* Initialize configuration options to their default values. */
  initialize_server_options(&options);

  /* Parse command-line arguments. */
  while ((opt = getopt(ac, av, "f:p:b:k:h:g:V:diqQ")) != EOF)
    {
      switch (opt)
	{
	case 'f':
	  config_file_name = optarg;
	  break;
	case 'd':
	  debug_flag = 1;
	  options.log_level = SYSLOG_LEVEL_DEBUG;
	  break;
	case 'i':
	  inetd_flag = 1;
	  break;
	case 'Q':
          silentrsa = 1;
	  break;
	case 'q':
	  options.log_level = SYSLOG_LEVEL_QUIET;
	  break;
	case 'b':
	  options.server_key_bits = atoi(optarg);
	  break;
	case 'p':
	  options.port = atoi(optarg);
	  break;
	case 'g':
	  options.login_grace_time = atoi(optarg);
	  break;
	case 'k':
	  options.key_regeneration_time = atoi(optarg);
	  break;
	case 'h':
	  options.host_key_file = optarg;
	  break;
	case 'V':
	  client_version_string = optarg;
	  /* only makes sense with inetd_flag, i.e. no listen() */
	  inetd_flag = 1;
	  break;
	case '?':
	default:
	  fprintf(stderr, "sshd version %s\n", SSH_VERSION);
	  fprintf(stderr, "Usage: %s [options]\n", av0);
	  fprintf(stderr, "Options:\n");
	  fprintf(stderr, "  -f file    Configuration file (default %s/sshd_config)\n", ETCDIR);
	  fprintf(stderr, "  -d         Debugging mode\n");
	  fprintf(stderr, "  -i         Started from inetd\n");
	  fprintf(stderr, "  -q         Quiet (no logging)\n");
	  fprintf(stderr, "  -p port    Listen on the specified port (default: 22)\n");
	  fprintf(stderr, "  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
	  fprintf(stderr, "  -g seconds Grace period for authentication (default: 300)\n");
	  fprintf(stderr, "  -b bits    Size of server RSA key (default: 768 bits)\n");
	  fprintf(stderr, "  -h file    File from which to read host key (default: %s)\n",
		  HOST_KEY_FILE);
	  exit(1);
	}
    }

  /* check if RSA support exists */
  if (rsa_alive() == 0) {
    if (silentrsa == 0)
      printf("sshd: no RSA support in libssl and libcrypto -- exiting.  See ssl(8)\n");
    log("no RSA support in libssl and libcrypto -- exiting.  See ssl(8)");
    exit(1);
  }

  /* Read server configuration options from the configuration file. */
  read_server_config(&options, config_file_name);

  /* Fill in default values for those options not explicitly set. */
  fill_default_server_options(&options);

  /* Check certain values for sanity. */
  if (options.server_key_bits < 512 || 
      options.server_key_bits > 32768)
    {
      fprintf(stderr, "Bad server key size.\n");
      exit(1);
    }
  if (options.port < 1 || options.port > 65535)
    {
      fprintf(stderr, "Bad port number.\n");
      exit(1);
    }

  /* Check that there are no remaining arguments. */
  if (optind < ac)
    {
      fprintf(stderr, "Extra argument %s.\n", av[optind]);
      exit(1);
    }

  /* Force logging to stderr while loading the private host key
     unless started from inetd */
  log_init(av0, options.log_level, options.log_facility, !inetd_flag);

  debug("sshd version %.100s", SSH_VERSION);

  sensitive_data.host_key = RSA_new();
  errno = 0;
  /* Load the host key.  It must have empty passphrase. */
  if (!load_private_key(options.host_key_file, "", 
			sensitive_data.host_key, &comment))
    {
      error("Could not load host key: %.200s: %.100s", 
	    options.host_key_file, strerror(errno));
      exit(1);
    }
  xfree(comment);

  /* Initialize the log (it is reinitialized below in case we forked). */
  if (debug_flag && !inetd_flag)
    log_stderr = 1;
  log_init(av0, options.log_level, options.log_facility, log_stderr);

  /* If not in debugging mode, and not started from inetd, disconnect from
     the controlling terminal, and fork.  The original process exits. */
  if (!debug_flag && !inetd_flag)
    { 
d402 1
a402 1
      int fd;
d404 4
a407 4
      if (daemon(0, 0) < 0)
	  fatal("daemon() failed: %.200s", strerror(errno));
     
      /* Disconnect from the controlling tty. */
d409 21
a429 5
      fd = open("/dev/tty", O_RDWR|O_NOCTTY);
      if (fd >= 0)
	{
	  (void)ioctl(fd, TIOCNOTTY, NULL);
	  close(fd);
d431 153
a583 2
#endif /* TIOCNOTTY */
    }
d585 2
a586 2
  /* Reinitialize the log (because of the fork above). */
  log_init(av0, options.log_level, options.log_facility, log_stderr);
d588 1
a588 71
  /* Check that server and host key lengths differ sufficiently.  This is
     necessary to make double encryption work with rsaref.  Oh, I hate
     software patents. I dont know if this can go? Niels */
  if (options.server_key_bits > 
      BN_num_bits(sensitive_data.host_key->n) - SSH_KEY_BITS_RESERVED &&
      options.server_key_bits < 
      BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED)
    {
      options.server_key_bits = 
	BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED;
      debug("Forcing server key to %d bits to make it differ from host key.", 
	    options.server_key_bits);
    }

  /* Do not display messages to stdout in RSA code. */
  rsa_set_verbose(0);

  /* Initialize the random number generator. */
  arc4random_stir();
  
  /* Chdir to the root directory so that the current disk can be unmounted
     if desired. */
  chdir("/");
  
  /* Close connection cleanly after attack. */
  cipher_attack_detected = packet_disconnect;

  /* Start listening for a socket, unless started from inetd. */
  if (inetd_flag)
    {
      int s1, s2;
      s1 = dup(0);  /* Make sure descriptors 0, 1, and 2 are in use. */
      s2 = dup(s1);
      sock_in = dup(0);
      sock_out = dup(1);
      /* We intentionally do not close the descriptors 0, 1, and 2 as our
	 code for setting the descriptors won\'t work if ttyfd happens to
	 be one of those. */
      debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);

      public_key = RSA_new();
      sensitive_data.private_key = RSA_new();
      /* Generate an rsa key. */
      log("Generating %d bit RSA key.", options.server_key_bits);
      rsa_generate_key(sensitive_data.private_key, public_key,
		       options.server_key_bits);
      arc4random_stir();
      log("RSA key generation complete.");
    }
  else
    {
      /* Create socket for listening. */
      listen_sock = socket(AF_INET, SOCK_STREAM, 0);
      if (listen_sock < 0)
	fatal("socket: %.100s", strerror(errno));

      /* Set socket options.  We try to make the port reusable and have it
	 close as fast as possible without waiting in unnecessary wait states
	 on close. */
      setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, (void *)&on, 
		 sizeof(on));
      linger.l_onoff = 1;
      linger.l_linger = 5;
      setsockopt(listen_sock, SOL_SOCKET, SO_LINGER, (void *)&linger, 
		 sizeof(linger));

      /* Initialize the socket address. */
      memset(&sin, 0, sizeof(sin));
      sin.sin_family = AF_INET;
      sin.sin_addr = options.listen_addr;
      sin.sin_port = htons(options.port);
d590 3
a592 7
      /* Bind the socket to the desired port. */
      if (bind(listen_sock, (struct sockaddr *)&sin, sizeof(sin)) < 0)
	{
	  error("bind: %.100s", strerror(errno));
	  shutdown(listen_sock, SHUT_RDWR);
	  close(listen_sock);
	  fatal("Bind to port %d failed.", options.port);
d595 24
a618 129
      if (!debug_flag)
	{
	  /* Record our pid in /etc/sshd_pid to make it easier to kill the
	     correct sshd.  We don\'t want to do this before the bind above
	     because the bind will fail if there already is a daemon, and this
	     will overwrite any old pid in the file. */
	  f = fopen(SSH_DAEMON_PID_FILE, "w");
	  if (f)
	    {
	      fprintf(f, "%u\n", (unsigned int)getpid());
	      fclose(f);
	    }
	}

      /* Start listening on the port. */
      log("Server listening on port %d.", options.port);
      if (listen(listen_sock, 5) < 0)
	fatal("listen: %.100s", strerror(errno));

      public_key = RSA_new();
      sensitive_data.private_key = RSA_new();
      /* Generate an rsa key. */
      log("Generating %d bit RSA key.", options.server_key_bits);
      rsa_generate_key(sensitive_data.private_key, public_key,
		       options.server_key_bits);
      arc4random_stir();
      log("RSA key generation complete.");

      /* Schedule server key regeneration alarm. */
      signal(SIGALRM, key_regeneration_alarm);
      alarm(options.key_regeneration_time);

      /* Arrange to restart on SIGHUP.  The handler needs listen_sock. */
      signal(SIGHUP, sighup_handler);
      signal(SIGTERM, sigterm_handler);
      signal(SIGQUIT, sigterm_handler);
      
      /* Arrange SIGCHLD to be caught. */
      signal(SIGCHLD, main_sigchld_handler);

      /* Stay listening for connections until the system crashes or the
	 daemon is killed with a signal. */
      for (;;)
	{
	  if (received_sighup)
	    sighup_restart();
	  /* Wait in accept until there is a connection. */
	  aux = sizeof(sin);
	  newsock = accept(listen_sock, (struct sockaddr *)&sin, &aux);
	  if (received_sighup)
	    sighup_restart();
	  if (newsock < 0)
	    {
	      if (errno == EINTR)
		continue;
	      error("accept: %.100s", strerror(errno));
	      continue;
	    }

	  /* Got connection.  Fork a child to handle it, unless we are in
	     debugging mode. */
	  if (debug_flag)
	    {
	      /* In debugging mode.  Close the listening socket, and start
		 processing the connection without forking. */
	      debug("Server will not fork when running in debugging mode.");
	      close(listen_sock);
	      sock_in = newsock;
	      sock_out = newsock;
	      pid = getpid();
	      break;
	    }
	  else
	    {
	      /* Normal production daemon.  Fork, and have the child process
		 the connection.  The parent continues listening. */
	      if ((pid = fork()) == 0)
		{ 
		  /* Child.  Close the listening socket, and start using
		     the accepted socket.  Reinitialize logging (since our
		     pid has changed).  We break out of the loop to handle
		     the connection. */
		  close(listen_sock);
		  sock_in = newsock;
		  sock_out = newsock;
                  log_init(av0, options.log_level, options.log_facility, log_stderr);
		  break;
		}
	    }

	  /* Parent.  Stay in the loop. */
	  if (pid < 0)
	    error("fork: %.100s", strerror(errno));
	  else
	    debug("Forked child %d.", pid);

	  /* Mark that the key has been used (it was "given" to the child). */
	  key_used = 1;

	  arc4random_stir();

	  /* Close the new socket (the child is now taking care of it). */
	  close(newsock);
	}
    }
  
  /* This is the child processing a new connection. */

  /* Disable the key regeneration alarm.  We will not regenerate the key
     since we are no longer in a position to give it to anyone.  We will
     not restart on SIGHUP since it no longer makes sense. */
  alarm(0);
  signal(SIGALRM, SIG_DFL);
  signal(SIGHUP, SIG_DFL);
  signal(SIGTERM, SIG_DFL);
  signal(SIGQUIT, SIG_DFL);
  signal(SIGCHLD, SIG_DFL);

  /* Set socket options for the connection.  We want the socket to close
     as fast as possible without waiting for anything.  If the connection
     is not a socket, these will do nothing. */
  /* setsockopt(sock_in, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on)); */
  linger.l_onoff = 1;
  linger.l_linger = 5;
  setsockopt(sock_in, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof(linger));

  /* Register our connection.  This turns encryption off because we do not
     have a key. */
  packet_set_connection(sock_in, sock_out);
d620 2
a621 2
  remote_port = get_remote_port();
  remote_ip = get_remote_ipaddr();
d623 1
a623 1
  /* Check whether logins are denied from this host. */
d625 2
a626 2
  {
    struct request_info req;
d628 2
a629 2
    request_init(&req, RQ_DAEMON, av0, RQ_FILE, sock_in, NULL);
    fromhost(&req);
d631 7
a637 7
    if (!hosts_access(&req)) {
      close(sock_in);
      close(sock_out);
      refuse(&req);
    }
    verbose("Connection from %.500s port %d", eval_client(&req), remote_port);
  }
d639 2
a640 2
  /* Log the connection. */
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
d643 82
a724 64
  /* We don\'t want to listen forever unless the other side successfully
     authenticates itself.  So we set up an alarm which is cleared after
     successful authentication.  A limit of zero indicates no limit.
     Note that we don\'t set the alarm in debugging mode; it is just annoying
     to have the server exit just when you are about to discover the bug. */
  signal(SIGALRM, grace_alarm_handler);
  if (!debug_flag)
    alarm(options.login_grace_time);

  if (client_version_string != NULL) {
     /* we are exec'ed by sshd2, so skip exchange of protocol version */
     strlcpy(buf, client_version_string, sizeof(buf));
  } else {
    /* Send our protocol version identification. */
    snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s\n", 
      	  PROTOCOL_MAJOR, PROTOCOL_MINOR, SSH_VERSION);
    if (write(sock_out, buf, strlen(buf)) != strlen(buf))
      fatal("Could not write ident string to %s.", get_remote_ipaddr());
 
    /* Read other side\'s version identification. */
    for (i = 0; i < sizeof(buf) - 1; i++)
      {
        if (read(sock_in, &buf[i], 1) != 1)
      	fatal("Did not receive ident string from %s.", get_remote_ipaddr());
        if (buf[i] == '\r')
      	{
      	  buf[i] = '\n';
      	  buf[i + 1] = 0;
      	  break;
      	}
        if (buf[i] == '\n')
      	{
      	  /* buf[i] == '\n' */
      	  buf[i + 1] = 0;
      	  break;
      	}
      }
    buf[sizeof(buf) - 1] = 0;
  }
  
  /* Check that the versions match.  In future this might accept several
     versions and set appropriate flags to handle them. */
  if (sscanf(buf, "SSH-%d.%d-%[^\n]\n", &remote_major, &remote_minor, 
	     remote_version) != 3)
    {
      const char *s = "Protocol mismatch.\n";
      (void) write(sock_out, s, strlen(s));
      close(sock_in);
      close(sock_out);
      fatal("Bad protocol version identification '%.100s' from %s",
	     buf, get_remote_ipaddr());
    }
  debug("Client protocol version %d.%d; client software version %.100s",
	remote_major, remote_minor, remote_version);
  if (remote_major != PROTOCOL_MAJOR)
    {
      const char *s = "Protocol major versions differ.\n";
      (void) write(sock_out, s, strlen(s));
      close(sock_in);
      close(sock_out);
      fatal("Protocol major versions differ for %s: %d vs. %d", 
	    get_remote_ipaddr(),
	    PROTOCOL_MAJOR, remote_major);
    }
d726 2
a727 29
  /* Check that the client has sufficiently high software version. */
  if (remote_major == 1 && remote_minor < 3)
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");

  if (remote_major == 1 && remote_minor == 3) {
    enable_compat13();
    if (strcmp(remote_version, "OpenSSH-1.1") != 0) {
        debug("Agent forwarding disabled, remote version is not compatible.");
        no_agent_forwarding_flag = 1;
    }
  }

  /* Check that the connection comes from a privileged port.
     Rhosts- and Rhosts-RSA-Authentication only make sense
     from priviledged programs.
     Of course, if the intruder has root access on his local machine,
     he can connect from any port.  So do not use these authentication
     methods from machines that you do not trust. */
  if (remote_port >= IPPORT_RESERVED ||
      remote_port <  IPPORT_RESERVED / 2)
    {
      options.rhosts_authentication = 0;
      options.rhosts_rsa_authentication = 0;
    }

  packet_set_nonblocking();
  
  /* Handle the connection. */
  do_connection();
d730 3
a732 3
  /* Cleanup user's ticket cache file. */
  if (options.kerberos_ticket_cleanup)
    (void) dest_tkt();
d735 8
a742 7
  /* Cleanup user's local Xauthority file. */
  if (xauthfile) unlink(xauthfile);

  /* The connection has been terminated. */
  verbose("Closing connection to %.100s", remote_ip);
  packet_close();
  exit(0);
d752 54
a805 53
  int i, len;
  BIGNUM *session_key_int;
  unsigned char session_key[SSH_SESSION_KEY_LENGTH];
  unsigned char check_bytes[8];
  char *user;
  unsigned int cipher_type, auth_mask, protocol_flags;
  int plen, slen;
  u_int32_t rand = 0;

  /* Generate check bytes that the client must send back in the user packet
     in order for it to be accepted; this is used to defy ip spoofing 
     attacks.  Note that this only works against somebody doing IP spoofing 
     from a remote machine; any machine on the local network can still see 
     outgoing packets and catch the random cookie.  This only affects
     rhosts authentication, and this is one of the reasons why it is
     inherently insecure. */
  for (i = 0; i < 8; i++) {
    if (i % 4 == 0)
      rand = arc4random();
    check_bytes[i] = rand & 0xff;
    rand >>= 8;
  }
  
  /* Send our public key.  We include in the packet 64 bits of random
     data that must be matched in the reply in order to prevent IP spoofing. */
  packet_start(SSH_SMSG_PUBLIC_KEY);
  for (i = 0; i < 8; i++)
    packet_put_char(check_bytes[i]);

  /* Store our public server RSA key. */
  packet_put_int(BN_num_bits(public_key->n));
  packet_put_bignum(public_key->e);
  packet_put_bignum(public_key->n);

  /* Store our public host RSA key. */
  packet_put_int(BN_num_bits(sensitive_data.host_key->n));
  packet_put_bignum(sensitive_data.host_key->e);
  packet_put_bignum(sensitive_data.host_key->n);

  /* Put protocol flags. */
  packet_put_int(SSH_PROTOFLAG_HOST_IN_FWD_OPEN);

  /* Declare which ciphers we support. */
  packet_put_int(cipher_mask());

  /* Declare supported authentication types. */
  auth_mask = 0;
  if (options.rhosts_authentication)
    auth_mask |= 1 << SSH_AUTH_RHOSTS;
  if (options.rhosts_rsa_authentication)
    auth_mask |= 1 << SSH_AUTH_RHOSTS_RSA;
  if (options.rsa_authentication)
    auth_mask |= 1 << SSH_AUTH_RSA;
d807 2
a808 2
  if (options.kerberos_authentication)
    auth_mask |= 1 << SSH_AUTH_KERBEROS;
d811 4
a814 4
  if (options.kerberos_tgt_passing)
    auth_mask |= 1 << SSH_PASS_KERBEROS_TGT;
  if (options.afs_token_passing)
    auth_mask |= 1 << SSH_PASS_AFS_TOKEN;
d817 2
a818 2
  if (options.skey_authentication == 1)
    auth_mask |= 1 << SSH_AUTH_TIS;
d820 122
a941 128
  if (options.password_authentication)
    auth_mask |= 1 << SSH_AUTH_PASSWORD;
  packet_put_int(auth_mask);

  /* Send the packet and wait for it to be sent. */
  packet_send();
  packet_write_wait();

  debug("Sent %d bit public key and %d bit host key.", 
	BN_num_bits(public_key->n), BN_num_bits(sensitive_data.host_key->n));

  /* Read clients reply (cipher type and session key). */
  packet_read_expect(&plen, SSH_CMSG_SESSION_KEY);

  /* Get cipher type. */
  cipher_type = packet_get_char();

  /* Get check bytes from the packet.  These must match those we sent earlier
     with the public key packet. */
  for (i = 0; i < 8; i++)
    if (check_bytes[i] != packet_get_char())
      packet_disconnect("IP Spoofing check bytes do not match.");

  debug("Encryption type: %.200s", cipher_name(cipher_type));

  /* Get the encrypted integer. */
  session_key_int = BN_new();
  packet_get_bignum(session_key_int, &slen);

  /* Get protocol flags. */
  protocol_flags = packet_get_int();
  packet_set_protocol_flags(protocol_flags);

  packet_integrity_check(plen, 1 + 8 + slen + 4, SSH_CMSG_SESSION_KEY);

  /* Decrypt it using our private server key and private host key (key with 
     larger modulus first). */
  if (BN_cmp(sensitive_data.private_key->n, sensitive_data.host_key->n) > 0)
    {
      /* Private key has bigger modulus. */
      if (BN_num_bits(sensitive_data.private_key->n) < 
	  BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED) {
        fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
	      get_remote_ipaddr(),
	      BN_num_bits(sensitive_data.private_key->n),
              BN_num_bits(sensitive_data.host_key->n),
	      SSH_KEY_BITS_RESERVED);
      }

      rsa_private_decrypt(session_key_int, session_key_int,
			  sensitive_data.private_key);
      rsa_private_decrypt(session_key_int, session_key_int,
			  sensitive_data.host_key);
    }
  else
    {
      /* Host key has bigger modulus (or they are equal). */
      if (BN_num_bits(sensitive_data.host_key->n) < 
	  BN_num_bits(sensitive_data.private_key->n) + SSH_KEY_BITS_RESERVED) {
        fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
	      get_remote_ipaddr(),
	      BN_num_bits(sensitive_data.host_key->n),
              BN_num_bits(sensitive_data.private_key->n),
	      SSH_KEY_BITS_RESERVED);
      }
      rsa_private_decrypt(session_key_int, session_key_int,
			  sensitive_data.host_key);
      rsa_private_decrypt(session_key_int, session_key_int,
			  sensitive_data.private_key);
    }

  /* Compute session id for this session. */
  compute_session_id(session_id, check_bytes,
		     sensitive_data.host_key->n, 
		     sensitive_data.private_key->n);

  /* Extract session key from the decrypted integer.  The key is in the 
     least significant 256 bits of the integer; the first byte of the 
     key is in the highest bits. */
  BN_mask_bits(session_key_int, sizeof(session_key) * 8);
  len = BN_num_bytes(session_key_int);
  if (len < 0 || len > sizeof(session_key))
    fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
	  get_remote_ipaddr(), 
	  len, sizeof(session_key));
  memset(session_key, 0, sizeof(session_key));
  BN_bn2bin(session_key_int, session_key + sizeof(session_key) - len);
  
  /* Xor the first 16 bytes of the session key with the session id. */
  for (i = 0; i < 16; i++)
    session_key[i] ^= session_id[i];

  /* Destroy the decrypted integer.  It is no longer needed. */
  BN_clear_free(session_key_int);
  
  /* Set the session key.  From this on all communications will be
     encrypted. */
  packet_set_encryption_key(session_key, SSH_SESSION_KEY_LENGTH, cipher_type);
  
  /* Destroy our copy of the session key.  It is no longer needed. */
  memset(session_key, 0, sizeof(session_key));

  debug("Received session key; encryption turned on.");

  /* Send an acknowledgement packet.  Note that this packet is sent
     encrypted. */
  packet_start(SSH_SMSG_SUCCESS);
  packet_send();
  packet_write_wait();

  /* Get the name of the user that we wish to log in as. */
  packet_read_expect(&plen, SSH_CMSG_USER);

  /* Get the user name. */
  {
    int ulen;
    user = packet_get_string(&ulen);
    packet_integrity_check(plen, (4 + ulen), SSH_CMSG_USER);
  }

  /* Destroy the private and public keys.  They will no longer be needed. */
  RSA_free(public_key);
  RSA_free(sensitive_data.private_key);
  RSA_free(sensitive_data.host_key);

  setproctitle("%s", user);
  /* Do the authentication. */
  do_authentication(user);
d952 1
a952 1
allowed_user(struct passwd *pw)
d954 2
a955 2
  struct group *grp;
  int i;
d957 56
a1012 63
  /* Shouldn't be called if pw is NULL, but better safe than sorry... */
  if (!pw)
    return 0;

  /* XXX Should check for valid login shell */

  /* Return false if user is listed in DenyUsers */
  if (options.num_deny_users > 0)
    {
      if (!pw->pw_name)
	return 0;
      for (i = 0; i < options.num_deny_users; i++)
	if (match_pattern(pw->pw_name, options.deny_users[i]))
	  return 0;
    }

  /* Return false if AllowUsers isn't empty and user isn't listed there */
  if (options.num_allow_users > 0)
    {
      if (!pw->pw_name)
	return 0;
      for (i = 0; i < options.num_allow_users; i++)
	if (match_pattern(pw->pw_name, options.allow_users[i]))
	  break;
      /* i < options.num_allow_users iff we break for loop */
      if (i >= options.num_allow_users)
	return 0;
    }

  /* Get the primary group name if we need it. Return false if it fails */
  if (options.num_deny_groups > 0 || options.num_allow_groups > 0 )
    {
      grp = getgrgid(pw->pw_gid);
      if (!grp)
	return 0;

      /* Return false if user's group is listed in DenyGroups */
      if (options.num_deny_groups > 0)
        {
          if (!grp->gr_name)
	    return 0;
          for (i = 0; i < options.num_deny_groups; i++)
	    if (match_pattern(grp->gr_name, options.deny_groups[i]))
	      return 0;
        }

      /* Return false if AllowGroups isn't empty and user's group isn't
	 listed there */
      if (options.num_allow_groups > 0)
        {
          if (!grp->gr_name)
	    return 0;
          for (i = 0; i < options.num_allow_groups; i++)
	    if (match_pattern(grp->gr_name, options.allow_groups[i]))
	      break;
          /* i < options.num_allow_groups iff we break for loop */
          if (i >= options.num_allow_groups)
	    return 0;
        }
    }

  /* We found no reason not to let this user try to log on... */
  return 1;
d1022 1
a1022 1
  struct passwd *pw, pwcopy;
d1025 5
a1029 5
  /* If machine has AFS, set process authentication group. */
  if (k_hasafs()) {
    k_setpag();
    k_unlog();
  }
a1030 20
       
  /* Verify that the user is a valid user. */
  pw = getpwnam(user);
  if (!pw || !allowed_user(pw))
    do_fake_authloop(user);
  
  /* Take a copy of the returned structure. */
  memset(&pwcopy, 0, sizeof(pwcopy));
  pwcopy.pw_name = xstrdup(pw->pw_name);
  pwcopy.pw_passwd = xstrdup(pw->pw_passwd);
  pwcopy.pw_uid = pw->pw_uid;
  pwcopy.pw_gid = pw->pw_gid;
  pwcopy.pw_dir = xstrdup(pw->pw_dir);
  pwcopy.pw_shell = xstrdup(pw->pw_shell);
  pw = &pwcopy;

  /* If we are not running as root, the user must have the same uid as the
     server. */
  if (getuid() != 0 && pw->pw_uid != getuid())
    packet_disconnect("Cannot change user when server not running as root.");
d1032 21
a1052 1
  debug("Attempting authentication for %.100s.", user);
d1054 2
a1055 2
  /* If the user has no password, accept authentication immediately. */
  if (options.password_authentication &&
d1057 1
a1057 1
      (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
d1059 10
a1068 25
      auth_password(pw, ""))
    {
      /* Authentication with empty password succeeded. */
      log("Login for user %s from %.100s, accepted without authentication.",
	  pw->pw_name, get_remote_ipaddr());
    } else {
      /* Loop until the user has been authenticated or the connection is closed,
         do_authloop() returns only if authentication is successfull */
      do_authloop(pw);
    }

  /* Check if the user is logging in as root and root logins are disallowed. */
  if (pw->pw_uid == 0 && !options.permit_root_login)
    {
      if (forced_command)
	log("Root login accepted for forced command.");
      else
	packet_disconnect("ROOT LOGIN REFUSED FROM %.200s", 
			  get_canonical_hostname());
    }

  /* The user has been authenticated and accepted. */
  packet_start(SSH_SMSG_SUCCESS);
  packet_send();
  packet_write_wait();
d1070 15
a1084 2
  /* Perform session preparation. */
  do_authenticated(pw);
d1094 1
a1094 1
do_authloop(struct passwd *pw)
d1096 24
a1119 25
  int attempt = 0;
  unsigned int bits;
  BIGNUM *client_host_key_e, *client_host_key_n;
  BIGNUM *n;
  char *client_user, *password;
  char user[1024];
  int plen, dlen, nlen, ulen, elen;
  int type = 0;
  void (*authlog)(const char *fmt, ...) = verbose;

  /* Indicate that authentication is needed. */
  packet_start(SSH_SMSG_FAILURE);
  packet_send();
  packet_write_wait();

  for (attempt = 1; ; attempt++) {
    int authenticated = 0;
    strlcpy(user, "", sizeof user);

    /* Get a packet from the client. */
    type = packet_read(&plen);
  
    /* Process the packet. */
    switch (type)
      {
d1121 29
a1149 32
      case SSH_CMSG_HAVE_KERBEROS_TGT:
	if (!options.kerberos_tgt_passing)
	  {
	    /* packet_get_all(); */
	    verbose("Kerberos tgt passing disabled.");
	    break;
	  }
	else {
	  /* Accept Kerberos tgt. */
	  char *tgt = packet_get_string(&dlen);
	  packet_integrity_check(plen, 4 + dlen, type);
	  if (!auth_kerberos_tgt(pw, tgt))
	    verbose("Kerberos tgt REFUSED for %s", pw->pw_name);
	  xfree(tgt);
	}
	continue;
  
      case SSH_CMSG_HAVE_AFS_TOKEN:
	if (!options.afs_token_passing || !k_hasafs()) {
	  /* packet_get_all(); */
	  verbose("AFS token passing disabled.");
	  break;
	}
	else {
	  /* Accept AFS token. */
	  char *token_string = packet_get_string(&dlen);
	  packet_integrity_check(plen, 4 + dlen, type);
	  if (!auth_afs_token(pw, token_string))
	    verbose("AFS token REFUSED for %s", pw->pw_name);
	  xfree(token_string);
	}
	continue;
a1150 1
	    
d1152 24
a1175 26
      case SSH_CMSG_AUTH_KERBEROS:
	if (!options.kerberos_authentication)
	  {
	    /* packet_get_all(); */
	    verbose("Kerberos authentication disabled.");
	    break;
	  }
	else {
	  /* Try Kerberos v4 authentication. */
	  KTEXT_ST auth;
	  char *tkt_user = NULL;
	  char *kdata = packet_get_string((unsigned int *)&auth.length);
	  packet_integrity_check(plen, 4 + auth.length, type);
  
	  if (auth.length < MAX_KTXT_LEN)
	    memcpy(auth.dat, kdata, auth.length);
	  xfree(kdata);
	  
	  authenticated = auth_krb4(pw->pw_name, &auth, &tkt_user);

	  if (authenticated) {
	    snprintf(user, sizeof user, " tktuser %s", tkt_user);
	    xfree(tkt_user);
	  }
	}
	break;
d1177 83
a1259 89
	   
      case SSH_CMSG_AUTH_RHOSTS:
	if (!options.rhosts_authentication)
	  {
	    verbose("Rhosts authentication disabled.");
	    break;
	  }
  
	/* Get client user name.  Note that we just have to trust the client;
	   this is one reason why rhosts authentication is insecure. 
	   (Another is IP-spoofing on a local network.) */
	client_user = packet_get_string(&ulen);
	packet_integrity_check(plen, 4 + ulen, type);
  
	/* Try to authenticate using /etc/hosts.equiv and .rhosts. */
	authenticated = auth_rhosts(pw, client_user);

	snprintf(user, sizeof user, " ruser %s", client_user);
	xfree(client_user);
	break;
  
      case SSH_CMSG_AUTH_RHOSTS_RSA:
	if (!options.rhosts_rsa_authentication)
	  {
	    verbose("Rhosts with RSA authentication disabled.");
	    break;
	  }
  
	/* Get client user name.  Note that we just have to trust
	   the client; root on the client machine can claim to be
	   any user. */
	client_user = packet_get_string(&ulen);
  
	/* Get the client host key. */
	client_host_key_e = BN_new();
	client_host_key_n = BN_new();
	bits = packet_get_int();
	packet_get_bignum(client_host_key_e, &elen);
	packet_get_bignum(client_host_key_n, &nlen);

        if (bits != BN_num_bits(client_host_key_n))
          error("Warning: keysize mismatch for client_host_key: "
	        "actual %d, announced %d", BN_num_bits(client_host_key_n), bits);
	packet_integrity_check(plen, (4 + ulen) + 4 + elen + nlen, type);
  
	authenticated = auth_rhosts_rsa(pw, client_user,
					client_host_key_e, client_host_key_n);
	BN_clear_free(client_host_key_e);
	BN_clear_free(client_host_key_n);

	snprintf(user, sizeof user, " ruser %s", client_user);
	xfree(client_user);
	break;
	
      case SSH_CMSG_AUTH_RSA:
	if (!options.rsa_authentication)
	  {
	    verbose("RSA authentication disabled.");
	    break;
	  }
  
	/* RSA authentication requested. */
	n = BN_new();
	packet_get_bignum(n, &nlen);
	packet_integrity_check(plen, nlen, type);
	authenticated = auth_rsa(pw, n);
	BN_clear_free(n);
	break;
  
      case SSH_CMSG_AUTH_PASSWORD:
	if (!options.password_authentication)
	  {
	    verbose("Password authentication disabled.");
	    break;
	  }
  
	/* Read user password.  It is in plain text, but was transmitted
	   over the encrypted channel so it is not visible to an outside
	   observer. */
	password = packet_get_string(&dlen);
	packet_integrity_check(plen, 4 + dlen, type);
  
	/* Try authentication with the password. */
	authenticated = auth_password(pw, password);

	memset(password, 0, strlen(password));
	xfree(password);
	break;
  
d1261 31
a1291 30
      case SSH_CMSG_AUTH_TIS:
	debug("rcvd SSH_CMSG_AUTH_TIS");
	if (options.skey_authentication == 1) {
	    char *skeyinfo = skey_keyinfo(pw->pw_name);
	    if (skeyinfo == NULL) {
	      debug("generating fake skeyinfo for %.100s.", pw->pw_name);
	      skeyinfo = skey_fake_keyinfo(pw->pw_name);
	    }
	    if (skeyinfo != NULL) {
	      /* we send our s/key- in tis-challenge messages */
	      debug("sending challenge '%s'", skeyinfo);
	      packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
	      packet_put_string(skeyinfo, strlen(skeyinfo));
	      packet_send();
	      packet_write_wait();
	      continue;
	    }
	}
	break;
      case SSH_CMSG_AUTH_TIS_RESPONSE:
	debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
	if (options.skey_authentication == 1) {
	  char *response = packet_get_string(&dlen);
	  debug("skey response == '%s'", response);
	  packet_integrity_check(plen, 4 + dlen, type);
	  authenticated = (skey_haskey(pw->pw_name) == 0 &&
			   skey_passcheck(pw->pw_name, response) != -1);
	  xfree(response);
	}
	break;
d1293 4
a1296 4
      case SSH_CMSG_AUTH_TIS:
	/* TIS Authentication is unsupported */
	log("TIS authentication unsupported.");
	break;
d1298 33
a1330 33
  
      default:
	/* Any unknown messages will be ignored (and failure returned)
	   during authentication. */
	log("Unknown message during authentication: type %d", type);
	break;
      }

    /* Raise logging level */
    if (authenticated ||
	attempt == AUTH_FAIL_LOG ||
	type == SSH_CMSG_AUTH_PASSWORD)
      authlog = log;

    authlog("%s %s for %.200s from %.200s port %d%s",
       authenticated ? "Accepted" : "Failed",
       get_authname(type),
       pw->pw_uid == 0 ? "ROOT" : pw->pw_name,
       get_remote_ipaddr(),
       get_remote_port(),
       user);

    if (authenticated)
      return;

    if (attempt > AUTH_FAIL_MAX)
      packet_disconnect(AUTH_FAIL_MSG, pw->pw_name);

    /* Send a message indicating that the authentication attempt failed. */
    packet_start(SSH_SMSG_FAILURE);
    packet_send();
    packet_write_wait();
  }
d1338 6
a1343 1
  int attempt = 0;
d1345 12
a1356 17
  log("Faking authloop for illegal user %.200s from %.200s port %d", 
       user,
       get_remote_ipaddr(),
       get_remote_port());

  /* Indicate that authentication is needed. */
  packet_start(SSH_SMSG_FAILURE);
  packet_send();
  packet_write_wait();

  /* Keep reading packets, and always respond with a failure.  This is to
     avoid disclosing whether such a user really exists. */
  for (attempt = 1; ; attempt++)
    {
      /* Read a packet.  This will not return if the client disconnects. */
      int plen;
      int type = packet_read(&plen);
d1358 12
a1369 12
      int dlen;
      char *password, *skeyinfo;
      if (options.password_authentication &&
         options.skey_authentication == 1 &&
         type == SSH_CMSG_AUTH_PASSWORD &&
         (password = packet_get_string(&dlen)) != NULL &&
         dlen == 5 &&
         strncasecmp(password, "s/key", 5) == 0 &&
         (skeyinfo = skey_fake_keyinfo(user)) != NULL ){
        /* Send a fake s/key challenge. */
        packet_send_debug(skeyinfo);
      }
d1371 2
a1372 2
      if (attempt > AUTH_FAIL_MAX)
        packet_disconnect(AUTH_FAIL_MSG, user);
d1374 8
a1381 8
      /* Send failure.  This should be indistinguishable from a failed
         authentication. */
      packet_start(SSH_SMSG_FAILURE);
      packet_send();
      packet_write_wait();
    }
  /*NOTREACHED*/
  abort();
d1389 1
a1389 1
  debug("xauthfile_cleanup_proc called");
d1391 5
a1395 5
  if (xauthfile != NULL) {
    unlink(xauthfile);
    xfree(xauthfile);
    xauthfile = NULL;
  }
d1403 2
a1404 1
void do_authenticated(struct passwd *pw)
d1406 108
a1513 118
  int type;
  int compression_level = 0, enable_compression_after_reply = 0;
  int have_pty = 0, ptyfd = -1, ttyfd = -1, xauthfd = -1;
  int row, col, xpixel, ypixel, screen;
  char ttyname[64];
  char *command, *term = NULL, *display = NULL, *proto = NULL, *data = NULL;
  struct group *grp;
  gid_t tty_gid;
  mode_t tty_mode;
  int n_bytes;
  
  /* Cancel the alarm we set to limit the time taken for authentication. */
  alarm(0);

  /* Inform the channel mechanism that we are the server side and that
     the client may request to connect to any port at all.  (The user could
     do it anyway, and we wouldn\'t know what is permitted except by the
     client telling us, so we can equally well trust the client not to request
     anything bogus.) */
  channel_permit_all_opens();

  /* We stay in this loop until the client requests to execute a shell or a
     command. */
  while (1)
    {
      int plen, dlen;

      /* Get a packet from the client. */
      type = packet_read(&plen);
      
      /* Process the packet. */
      switch (type)
	{
	case SSH_CMSG_REQUEST_COMPRESSION:
	  packet_integrity_check(plen, 4, type);
	  compression_level = packet_get_int();
	  if (compression_level < 1 || compression_level > 9)
	    {
	      packet_send_debug("Received illegal compression level %d.",
				compression_level);
	      goto fail;
	    }
	  /* Enable compression after we have responded with SUCCESS. */
	  enable_compression_after_reply = 1;
	  break;

	case SSH_CMSG_REQUEST_PTY:
	  if (no_pty_flag)
	    {
	      debug("Allocating a pty not permitted for this authentication.");
	      goto fail;
	    }
	  if (have_pty)
	    packet_disconnect("Protocol error: you already have a pty.");

	  debug("Allocating pty.");

	  /* Allocate a pty and open it. */
	  if (!pty_allocate(&ptyfd, &ttyfd, ttyname))
	    {
	      error("Failed to allocate pty.");
	      goto fail;
	    }

	  /* Determine the group to make the owner of the tty. */
	  grp = getgrnam("tty");
	  if (grp)
	    {
	      tty_gid = grp->gr_gid;
	      tty_mode = S_IRUSR|S_IWUSR|S_IWGRP;
	    }
	  else
	    {
	      tty_gid = pw->pw_gid;
	      tty_mode = S_IRUSR|S_IWUSR|S_IWGRP|S_IWOTH;
	    }

	  /* Change ownership of the tty. */
	  if (chown(ttyname, pw->pw_uid, tty_gid) < 0)
	    fatal("chown(%.100s, %d, %d) failed: %.100s",
		  ttyname, pw->pw_uid, tty_gid, strerror(errno));
	  if (chmod(ttyname, tty_mode) < 0)
	    fatal("chmod(%.100s, 0%o) failed: %.100s",
		  ttyname, tty_mode, strerror(errno));

	  /* Get TERM from the packet.  Note that the value may be of arbitrary
	     length. */

	  term = packet_get_string(&dlen);
	  packet_integrity_check(dlen, strlen(term), type);
	  /* packet_integrity_check(plen, 4 + dlen + 4*4 + n_bytes, type); */
	  /* Remaining bytes */
	  n_bytes = plen - (4 + dlen + 4*4);
	  
	  if (strcmp(term, "") == 0)
	    term = NULL;

	  /* Get window size from the packet. */
	  row = packet_get_int();
	  col = packet_get_int();
	  xpixel = packet_get_int();
	  ypixel = packet_get_int();
	  pty_change_window_size(ptyfd, row, col, xpixel, ypixel);

	  /* Get tty modes from the packet. */
	  tty_parse_modes(ttyfd, &n_bytes);
	  packet_integrity_check(plen, 4 + dlen + 4*4 + n_bytes, type);

	  /* Indicate that we now have a pty. */
	  have_pty = 1;
	  break;

	case SSH_CMSG_X11_REQUEST_FORWARDING:
	  if (!options.x11_forwarding)
	    {
	      packet_send_debug("X11 forwarding disabled in server configuration file.");
	      goto fail;
	    }
d1515 34
a1548 36
	  if (no_x11_forwarding_flag)
	    {
	      packet_send_debug("X11 forwarding not permitted for this authentication.");
	      goto fail;
	    }
	  debug("Received request for X11 forwarding with auth spoofing.");
	  if (display)
	    packet_disconnect("Protocol error: X11 display already set.");
	  {
	    int proto_len, data_len;
	    proto = packet_get_string(&proto_len);
	    data = packet_get_string(&data_len);
	    packet_integrity_check(plen, 4+proto_len + 4+data_len + 4, type);
	  }
	  if (packet_get_protocol_flags() & SSH_PROTOFLAG_SCREEN_NUMBER)
	    screen = packet_get_int();
	  else
	    screen = 0;
	  display = x11_create_display_inet(screen);
	  if (!display)
	    goto fail;

	  /* Setup to always have a local .Xauthority. */
	  xauthfile = xmalloc(MAXPATHLEN);
	  snprintf(xauthfile, MAXPATHLEN, "/tmp/XauthXXXXXX");
	  
	  if ((xauthfd = mkstemp(xauthfile)) != -1) {
	    fchown(xauthfd, pw->pw_uid, pw->pw_gid);
	    close(xauthfd);
            fatal_add_cleanup(xauthfile_cleanup_proc, NULL);
	  }
	  else {
	    xfree(xauthfile);
	    xauthfile = NULL;
	  }
	  break;
d1550 2
a1551 3
	  /* No xauth program; we won't accept forwarding with spoofing. */
	  packet_send_debug("No xauth program; cannot forward with spoofing.");
	  goto fail;
d1554 65
a1618 74
	case SSH_CMSG_AGENT_REQUEST_FORWARDING:
	  if (no_agent_forwarding_flag)
	    {
	      debug("Authentication agent forwarding not permitted for this authentication.");
	      goto fail;
	    }
	  debug("Received authentication agent forwarding request.");
	  auth_input_request_forwarding(pw);
	  break;

	case SSH_CMSG_PORT_FORWARD_REQUEST:
	  if (no_port_forwarding_flag)
	    {
	      debug("Port forwarding not permitted for this authentication.");
	      goto fail;
	    }
	  debug("Received TCP/IP port forwarding request.");
	  channel_input_port_forward_request(pw->pw_uid == 0);
	  break;

	case SSH_CMSG_MAX_PACKET_SIZE:
          if (packet_set_maxsize(packet_get_int()) < 0)
	    goto fail;
	  break;

	case SSH_CMSG_EXEC_SHELL:
	  /* Set interactive/non-interactive mode. */
	  packet_set_interactive(have_pty || display != NULL, 
				 options.keepalives);
	    
	  if (forced_command != NULL)
	    goto do_forced_command;
	  debug("Forking shell.");
	  packet_integrity_check(plen, 0, type);
	  if (have_pty)
	    do_exec_pty(NULL, ptyfd, ttyfd, ttyname, pw, term, display, proto,
			data);
	  else
	    do_exec_no_pty(NULL, pw, display, proto, data);
	  return;

	case SSH_CMSG_EXEC_CMD:
	  /* Set interactive/non-interactive mode. */
	  packet_set_interactive(have_pty || display != NULL,
				 options.keepalives);

	  if (forced_command != NULL)
	    goto do_forced_command;
	  /* Get command from the packet. */
	  {
	    int dlen;
	    command = packet_get_string(&dlen);
	    debug("Executing command '%.500s'", command);
	    packet_integrity_check(plen, 4 + dlen, type);
	  }
	  if (have_pty)
	    do_exec_pty(command, ptyfd, ttyfd, ttyname, pw, term, display,
			proto, data);
	  else
	    do_exec_no_pty(command, pw, display, proto, data);
	  xfree(command);
	  return;

	default:
	  /* Any unknown messages in this phase are ignored, and a failure
	     message is returned. */
	  log("Unknown packet type received after authentication: %d", type);
	  goto fail;
	}

      /* The request was successfully processed. */
      packet_start(SSH_SMSG_SUCCESS);
      packet_send();
      packet_write_wait();
d1620 11
a1630 6
      /* Enable compression now that we have replied if appropriate. */
      if (enable_compression_after_reply)
	{
	  enable_compression_after_reply = 0;
	  packet_start_compression(compression_level);
	}
d1632 6
a1637 1
      continue;
d1639 10
a1648 17
    fail:
      /* The request failed. */
      packet_start(SSH_SMSG_FAILURE);
      packet_send();
      packet_write_wait();
      continue;
      
    do_forced_command:
      /* There is a forced command specified for this login.  Execute it. */
      debug("Executing forced command: %.900s", forced_command);
      if (have_pty)
	do_exec_pty(forced_command, ptyfd, ttyfd, ttyname, pw, term, display,
		    proto, data);
      else
	do_exec_no_pty(forced_command, pw, display, proto, data);
      return;
    }
d1655 6
a1660 5
void do_exec_no_pty(const char *command, struct passwd *pw,
		    const char *display, const char *auth_proto,
		    const char *auth_data)
{  
  int pid;
d1663 5
a1667 5
  int pin[2], pout[2], perr[2];
  /* Allocate pipes for communicating with the program. */
  if (pipe(pin) < 0 || pipe(pout) < 0 || pipe(perr) < 0)
    packet_disconnect("Could not create pipes: %.100s",
		      strerror(errno));
d1669 6
a1674 6
  int inout[2], err[2];
  /* Uses socket pairs to communicate with the program. */
  if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0 ||
      socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0)
    packet_disconnect("Could not create socket pairs: %.100s",
		      strerror(errno));
a1675 2
  
  setproctitle("%s@@notty", pw->pw_name);
d1677 11
a1687 10
  /* Fork the child. */
  if ((pid = fork()) == 0)
    {
      /* Child.  Reinitialize the log since the pid has changed. */
      log_init(av0, options.log_level, options.log_facility, log_stderr);

      /* Create a new session and process group since the 4.4BSD setlogin()
	 affects the entire process group. */
      if (setsid() < 0)
	error("setsid failed: %.100s", strerror(errno));
d1690 18
a1707 18
      /* Redirect stdin.  We close the parent side of the socket pair,
         and make the child side the standard input. */
      close(pin[1]);
      if (dup2(pin[0], 0) < 0)
	perror("dup2 stdin");
      close(pin[0]);
      
      /* Redirect stdout. */
      close(pout[0]);
      if (dup2(pout[1], 1) < 0)
	perror("dup2 stdout");
      close(pout[1]);

      /* Redirect stderr. */
      close(perr[0]);
      if (dup2(perr[1], 2) < 0)
	perror("dup2 stderr");
      close(perr[1]);
d1709 11
a1719 11
      /* Redirect stdin, stdout, and stderr.  Stdin and stdout will use the
	 same socket, as some programs (particularly rdist) seem to depend
	 on it. */
      close(inout[1]);
      close(err[1]);
      if (dup2(inout[0], 0) < 0) /* stdin */
	perror("dup2 stdin");
      if (dup2(inout[0], 1) < 0) /* stdout.  Note: same socket as stdin. */
	perror("dup2 stdout");
      if (dup2(err[0], 2) < 0) /* stderr */
	perror("dup2 stderr");
d1722 6
a1727 6
      /* Do processing for the child (exec command etc). */
      do_child(command, pw, NULL, display, auth_proto, auth_data, NULL);
      /*NOTREACHED*/
    }
  if (pid < 0)
    packet_disconnect("fork failed: %.100s", strerror(errno));
d1729 8
a1736 8
  /* We are the parent.  Close the child sides of the pipes. */
  close(pin[0]);
  close(pout[1]);
  close(perr[1]);

  /* Enter the interactive session. */
  server_loop(pid, pin[1], pout[0], perr[0]);
  /* server_loop has closed pin[1], pout[1], and perr[1]. */
d1738 8
a1745 8
  /* We are the parent.  Close the child sides of the socket pairs. */
  close(inout[0]);
  close(err[0]);
  
  /* Enter the interactive session.  Note: server_loop must be able to handle
     the case that fdin and fdout are the same. */
  server_loop(pid, inout[1], inout[1], err[1]);
  /* server_loop has closed inout[1] and err[1]. */
d1749 3
a1751 4
struct pty_cleanup_context
{
  const char *ttyname;
  int pid;
d1757 2
a1758 1
void pty_cleanup_proc(void *context)
d1760 1
a1760 1
  struct pty_cleanup_context *cu = context;
d1762 1
a1762 1
  debug("pty_cleanup_proc called");
d1764 2
a1765 2
  /* Record that the user has logged out. */
  record_logout(cu->pid, cu->ttyname);
d1767 2
a1768 2
  /* Release the pseudo-tty. */
  pty_release(cu->ttyname);
d1776 152
a1927 156
void do_exec_pty(const char *command, int ptyfd, int ttyfd, 
		 const char *ttyname, struct passwd *pw, const char *term,
		 const char *display, const char *auth_proto, 
		 const char *auth_data)
{
  int pid, fdout;
  const char *hostname;
  time_t last_login_time;
  char buf[100], *time_string;
  FILE *f;
  char line[256];
  struct stat st;
  int quiet_login;
  struct sockaddr_in from;
  int fromlen;
  struct pty_cleanup_context cleanup_context;

  /* Get remote host name. */
  hostname = get_canonical_hostname();

  /* Get the time when the user last logged in.  Buf will be set to contain
     the hostname the last login was from. */
  if(!options.use_login) {
    last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
					  buf, sizeof(buf));
  }

  setproctitle("%s@@%s", pw->pw_name, strrchr(ttyname, '/') + 1);

  /* Fork the child. */
  if ((pid = fork()) == 0)
    { 
      pid = getpid();

      /* Child.  Reinitialize the log because the pid has changed. */
      log_init(av0, options.log_level, options.log_facility, log_stderr);

      /* Close the master side of the pseudo tty. */
      close(ptyfd);

      /* Make the pseudo tty our controlling tty. */
      pty_make_controlling_tty(&ttyfd, ttyname);

      /* Redirect stdin from the pseudo tty. */
      if (dup2(ttyfd, fileno(stdin)) < 0)
	error("dup2 stdin failed: %.100s", strerror(errno));

      /* Redirect stdout to the pseudo tty. */
      if (dup2(ttyfd, fileno(stdout)) < 0)
	error("dup2 stdin failed: %.100s", strerror(errno));

      /* Redirect stderr to the pseudo tty. */
      if (dup2(ttyfd, fileno(stderr)) < 0)
	error("dup2 stdin failed: %.100s", strerror(errno));

      /* Close the extra descriptor for the pseudo tty. */
      close(ttyfd);

      /* Get IP address of client.  This is needed because we want to record 
	 where the user logged in from.  If the connection is not a socket,
	 let the ip address be 0.0.0.0. */
      memset(&from, 0, sizeof(from));
      if (packet_get_connection_in() == packet_get_connection_out())
	{
	  fromlen = sizeof(from);
	  if (getpeername(packet_get_connection_in(),
			  (struct sockaddr *)&from, &fromlen) < 0) {
	    debug("getpeername: %.100s", strerror(errno));
            fatal_cleanup();
          }
	}

      /* Record that there was a login on that terminal. */
      record_login(pid, ttyname, pw->pw_name, pw->pw_uid, hostname, 
		   &from);

      /* Check if .hushlogin exists. */
      snprintf(line, sizeof line, "%.200s/.hushlogin", pw->pw_dir);
      quiet_login = stat(line, &st) >= 0;
      
      /* If the user has logged in before, display the time of last login. 
         However, don't display anything extra if a command has been 
	 specified (so that ssh can be used to execute commands on a remote
         machine without users knowing they are going to another machine). 
         Login(1) will do this for us as well, so check if login(1) is used */
      if (command == NULL && last_login_time != 0 && !quiet_login && 
          !options.use_login)
	{
	  /* Convert the date to a string. */
	  time_string = ctime(&last_login_time);
	  /* Remove the trailing newline. */
	  if (strchr(time_string, '\n'))
	    *strchr(time_string, '\n') = 0;
	  /* Display the last login time.  Host if displayed if known. */
	  if (strcmp(buf, "") == 0)
	    printf("Last login: %s\r\n", time_string);
	  else
	    printf("Last login: %s from %s\r\n", time_string, buf);
	}

      /* Print /etc/motd unless a command was specified or printing it was
         disabled in server options or login(1) will be used.  Note that 
         some machines appear to print it in /etc/profile or similar. */
      if (command == NULL && options.print_motd && !quiet_login && 
          !options.use_login)
	{
	  /* Print /etc/motd if it exists. */
	  f = fopen("/etc/motd", "r");
	  if (f)
	    {
	      while (fgets(line, sizeof(line), f))
		fputs(line, stdout);
	      fclose(f);
	    }
	}

      /* Do common processing for the child, such as execing the command. */
      do_child(command, pw, term, display, auth_proto, auth_data, ttyname);
      /*NOTREACHED*/
    }
  if (pid < 0)
    packet_disconnect("fork failed: %.100s", strerror(errno));
  /* Parent.  Close the slave side of the pseudo tty. */
  close(ttyfd);
  
  /* Create another descriptor of the pty master side for use as the standard
     input.  We could use the original descriptor, but this simplifies code
     in server_loop.  The descriptor is bidirectional. */
  fdout = dup(ptyfd);
  if (fdout < 0)
    packet_disconnect("dup failed: %.100s", strerror(errno));

  /* Add a cleanup function to clear the utmp entry and record logout time
     in case we call fatal() (e.g., the connection gets closed). */
  cleanup_context.pid = pid;
  cleanup_context.ttyname = ttyname;
  fatal_add_cleanup(pty_cleanup_proc, (void *)&cleanup_context);

  /* Enter interactive session. */
  server_loop(pid, ptyfd, fdout, -1);
  /* server_loop has not closed ptyfd and fdout. */

  /* Cancel the cleanup function. */
  fatal_remove_cleanup(pty_cleanup_proc, (void *)&cleanup_context);

  /* Record that the user has logged out. */
  record_logout(pid, ttyname);

  /* Release the pseudo-tty. */
  pty_release(ttyname);

  /* Close the server side of the socket pairs.  We must do this after the
     pty cleanup, so that another process doesn't get this pty while we're
     still cleaning up. */
  close(ptyfd);
  close(fdout);
d1933 26
a1958 26
void child_set_env(char ***envp, unsigned int *envsizep, const char *name,
		   const char *value)
{
  unsigned int i, namelen;
  char **env;

  /* Find the slot where the value should be stored.  If the variable already
     exists, we reuse the slot; otherwise we append a new slot at the end
     of the array, expanding if necessary. */
  env = *envp;
  namelen = strlen(name);
  for (i = 0; env[i]; i++)
    if (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')
      break;
  if (env[i])
    {
      /* Name already exists.  Reuse the slot. */
      xfree(env[i]);
    }
  else
    {
      /* New variable.  Expand the array if necessary. */
      if (i >= (*envsizep) - 1)
	{
	  (*envsizep) += 50;
	  env = (*envp) = xrealloc(env, (*envsizep) * sizeof(char *));
d1961 3
a1963 8
      /* Need to set the NULL pointer at end of array beyond the new 
	 slot. */
      env[i + 1] = NULL;
    }

  /* Allocate space and format the variable in the appropriate slot. */
  env[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);
  snprintf(env[i], strlen(name) + 1 + strlen(value) + 1, "%s=%s", name, value);
d1971 40
a2010 33
void read_environment_file(char ***env, unsigned int *envsize,
			   const char *filename)
{
  FILE *f;
  char buf[4096];
  char *cp, *value;
  
  /* Open the environment file. */
  f = fopen(filename, "r");
  if (!f)
    return;  /* Not found. */
  
  /* Process each line. */
  while (fgets(buf, sizeof(buf), f))
    {
      /* Skip leading whitespace. */
      for (cp = buf; *cp == ' ' || *cp == '\t'; cp++)
	;

      /* Ignore empty and comment lines. */
      if (!*cp || *cp == '#' || *cp == '\n')
	continue;

      /* Remove newline. */
      if (strchr(cp, '\n'))
	*strchr(cp, '\n') = '\0';

      /* Find the equals sign.  Its lack indicates badly formatted line. */
      value = strchr(cp, '=');
      if (value == NULL)
	{
	  fprintf(stderr, "Bad line in %.100s: %.200s\n", filename, buf);
	  continue;
d2013 1
a2013 10
      /* Replace the equals sign by nul, and advance value to the value 
	 string. */
      *value = '\0';
      value++;

      /* Set the value in environment. */
      child_set_env(env, envsize, cp, value);
    }
  
  fclose(f);
d2016 2
a2017 2
/* Performs common processing for the child, such as setting up the 
   environment, closing extra file descriptors, setting the user and group 
d2020 53
a2072 58
void do_child(const char *command, struct passwd *pw, const char *term,
	      const char *display, const char *auth_proto, 
	      const char *auth_data, const char *ttyname)
{
  const char *shell, *cp = NULL;
  char buf[256];
  FILE *f;
  unsigned int envsize, i;
  char **env;
  extern char **environ;
  struct stat st;
  char *argv[10];

  /* Check /etc/nologin. */
  f = fopen("/etc/nologin", "r");
  if (f)
    { /* /etc/nologin exists.  Print its contents and exit. */
      while (fgets(buf, sizeof(buf), f))
	fputs(buf, stderr);
      fclose(f);
      if (pw->pw_uid != 0)
	exit(254);
    }

  /* Set login name in the kernel. */
  if (setlogin(pw->pw_name) < 0)
    error("setlogin failed: %s", strerror(errno));

  /* Set uid, gid, and groups. */
  /* Login(1) does this as well, and it needs uid 0 for the "-h" switch,
     so we let login(1) to this for us. */
  if(!options.use_login) {
    if (getuid() == 0 || geteuid() == 0)
      { 
        if (setgid(pw->pw_gid) < 0)
          {
            perror("setgid");
            exit(1);
          }
        /* Initialize the group list. */
        if (initgroups(pw->pw_name, pw->pw_gid) < 0)
          {
            perror("initgroups");
            exit(1);
          }
        endgrent();
   
        /* Permanently switch to the desired uid. */
        permanently_set_uid(pw->pw_uid);
      }
   
    if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
      fatal("Failed to set uids to %d.", (int)pw->pw_uid);
  }

  /* Get the shell from the password data.  An empty shell field is legal,
     and means /bin/sh. */
  shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;
d2075 3
a2077 6
  /* Try to get AFS tokens for the local cell. */
  if (k_hasafs()) {
    char cell[64];
    
    if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
      krb_afslog(cell, 0);
d2079 5
a2083 2
    krb_afslog(0, 0);
  }
d2085 38
a2122 38
  
  /* Initialize the environment.  In the first part we allocate space for
     all environment variables. */
  envsize = 100;
  env = xmalloc(envsize * sizeof(char *));
  env[0] = NULL;

  if(!options.use_login) {
    /* Set basic environment. */
    child_set_env(&env, &envsize, "USER", pw->pw_name);
    child_set_env(&env, &envsize, "LOGNAME", pw->pw_name);
    child_set_env(&env, &envsize, "HOME", pw->pw_dir);
    child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
   
    snprintf(buf, sizeof buf, "%.200s/%.50s",
      _PATH_MAILDIR, pw->pw_name);
    child_set_env(&env, &envsize, "MAIL", buf);
   
    /* Normal systems set SHELL by default. */
    child_set_env(&env, &envsize, "SHELL", shell);
  }

  /* Let it inherit timezone if we have one. */
  if (getenv("TZ"))
    child_set_env(&env, &envsize, "TZ", getenv("TZ"));

  /* Set custom environment options from RSA authentication. */
  while (custom_environment) 
    {
      struct envstring *ce = custom_environment;
      char *s = ce->s;
      int i;
      for (i = 0; s[i] != '=' && s[i]; i++)
	;
      if (s[i] == '=') 
	{
	  s[i] = 0;
	  child_set_env(&env, &envsize, s, s + i + 1);
d2124 17
a2140 21
      custom_environment = ce->next;
      xfree(ce->s);
      xfree(ce);
    }

  /* Set SSH_CLIENT. */
  snprintf(buf, sizeof buf, "%.50s %d %d", 
	  get_remote_ipaddr(), get_remote_port(), options.port);
  child_set_env(&env, &envsize, "SSH_CLIENT", buf);

  /* Set SSH_TTY if we have a pty. */
  if (ttyname)
    child_set_env(&env, &envsize, "SSH_TTY", ttyname);

  /* Set TERM if we have a pty. */
  if (term)
    child_set_env(&env, &envsize, "TERM", term);

  /* Set DISPLAY if we have one. */
  if (display)
    child_set_env(&env, &envsize, "DISPLAY", display);
d2143 6
a2148 6
  {
    extern char *ticket;
    
    if (ticket)
      child_set_env(&env, &envsize, "KRBTKFILE", ticket);
  }
d2150 85
a2234 94
  
  /* Set XAUTHORITY to always be a local file. */
  if (xauthfile)
      child_set_env(&env, &envsize, "XAUTHORITY", xauthfile);

  /* Set variable for forwarded authentication connection, if we have one. */
  if (auth_get_socket_name() != NULL)
      child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME, 
		    auth_get_socket_name());

  /* Read $HOME/.ssh/environment. */
  if(!options.use_login) {
    snprintf(buf, sizeof buf, "%.200s/.ssh/environment", pw->pw_dir);
    read_environment_file(&env, &envsize, buf);
  }

  /* If debugging, dump the environment to stderr. */
  if (debug_flag)
    {
      fprintf(stderr, "Environment:\n");
      for (i = 0; env[i]; i++)
	fprintf(stderr, "  %.200s\n", env[i]);
    }

  /* Close the connection descriptors; note that this is the child, and the 
     server will still have the socket open, and it is important that we
     do not shutdown it.  Note that the descriptors cannot be closed before
     building the environment, as we call get_remote_ipaddr there. */
  if (packet_get_connection_in() == packet_get_connection_out())
    close(packet_get_connection_in());
  else
    {
      close(packet_get_connection_in());
      close(packet_get_connection_out());
    }
  /* Close all descriptors related to channels.  They will still remain
     open in the parent. */
  channel_close_all();

  /* Close any extra file descriptors.  Note that there may still be
     descriptors left by system functions.  They will be closed later. */
  endpwent();
  endhostent();

  /* Close any extra open file descriptors so that we don\'t have them
     hanging around in clients.  Note that we want to do this after
     initgroups, because at least on Solaris 2.3 it leaves file descriptors
     open. */
  for (i = 3; i < 64; i++)
    close(i);

  /* Change current directory to the user\'s home directory. */
  if (chdir(pw->pw_dir) < 0)
    fprintf(stderr, "Could not chdir to home directory %s: %s\n",
	    pw->pw_dir, strerror(errno));

  /* Must take new environment into use so that .ssh/rc, /etc/sshrc and
     xauth are run in the proper environment. */
  environ = env;

  /* Run $HOME/.ssh/rc, /etc/sshrc, or xauth (whichever is found first
     in this order). */
  if(!options.use_login) {
    if (stat(SSH_USER_RC, &st) >= 0)
      {
        if (debug_flag)
      	fprintf(stderr, "Running /bin/sh %s\n", SSH_USER_RC);
 
        f = popen("/bin/sh " SSH_USER_RC, "w");
        if (f)
      	{
      	  if (auth_proto != NULL && auth_data != NULL)
      	    fprintf(f, "%s %s\n", auth_proto, auth_data);
      	  pclose(f);
      	}
        else
      	fprintf(stderr, "Could not run %s\n", SSH_USER_RC);
      }
    else
      if (stat(SSH_SYSTEM_RC, &st) >= 0)
        {
      	if (debug_flag)
      	  fprintf(stderr, "Running /bin/sh %s\n", SSH_SYSTEM_RC);
 
      	f = popen("/bin/sh " SSH_SYSTEM_RC, "w");
      	if (f)
      	  {
      	    if (auth_proto != NULL && auth_data != NULL)
      	      fprintf(f, "%s %s\n", auth_proto, auth_data);
      	    pclose(f);
      	  }
      	else
      	  fprintf(stderr, "Could not run %s\n", SSH_SYSTEM_RC);
        }
d2236 16
a2251 19
      else
        {
      	/* Add authority data to .Xauthority if appropriate. */
      	if (auth_proto != NULL && auth_data != NULL)
      	  {
      	    if (debug_flag)
      	      fprintf(stderr, "Running %.100s add %.100s %.100s %.100s\n",
      		      XAUTH_PATH, display, auth_proto, auth_data);
      	    
      	    f = popen(XAUTH_PATH " -q -", "w");
      	    if (f)
      	      {
      		fprintf(f, "add %s %s %s\n", display, auth_proto, auth_data);
      		fclose(f);
      	      }
      	    else
      	      fprintf(stderr, "Could not run %s -q -\n", XAUTH_PATH);
      	  }
        }
d2254 64
a2317 64
    /* Get the last component of the shell name. */
    cp = strrchr(shell, '/');
    if (cp)
      cp++;
    else
      cp = shell;
  }

  /* If we have no command, execute the shell.  In this case, the shell name
     to be passed in argv[0] is preceded by '-' to indicate that this is
     a login shell. */
  if (!command)
    {
      if(!options.use_login) {
        char buf[256];

        /* Check for mail if we have a tty and it was enabled in server options. */
        if (ttyname && options.check_mail) {
          char *mailbox;
          struct stat mailstat;
          mailbox = getenv("MAIL");
          if(mailbox != NULL) {
            if(stat(mailbox, &mailstat) != 0 || mailstat.st_size == 0) {
              printf("No mail.\n");
            } else if(mailstat.st_mtime < mailstat.st_atime) {
              printf("You have mail.\n");
            } else {
              printf("You have new mail.\n");
            }
          }
        }
        /* Start the shell.  Set initial character to '-'. */
        buf[0] = '-';
        strncpy(buf + 1, cp, sizeof(buf) - 1);
        buf[sizeof(buf) - 1] = 0;
        /* Execute the shell. */
        argv[0] = buf;
        argv[1] = NULL;
        execve(shell, argv, env);
        /* Executing the shell failed. */
        perror(shell);
        exit(1);

      } else {
        /* Launch login(1). */

        execl("/usr/bin/login", "login", "-h", get_remote_ipaddr(), "-p", "-f", "--", pw->pw_name, NULL);

        /* Login couldn't be executed, die. */

        perror("login");
        exit(1);
      }
    }

  /* Execute the command using the user's shell.  This uses the -c option
     to execute the command. */
  argv[0] = (char *)cp;
  argv[1] = "-c";
  argv[2] = (char *)command;
  argv[3] = NULL;
  execve(shell, argv, env);
  perror(shell);
  exit(1);
@


1.62
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.61 1999/11/22 20:02:45 markus Exp $");
d213 4
d842 4
d1314 32
d1348 1
a1348 1
	log("TIS authentication disabled.");
d1350 1
@


1.61
log
@-V, for fallback to openssh in SSH2 compatibility mode
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.60 1999/11/20 20:07:23 deraadt Exp $");
d193 23
a215 1
  fatal("Timeout before authentication.");
d267 1
d636 1
d651 1
a651 1
    log("Connection from %.500s port %d", eval_client(&req), remote_port);
d655 1
a655 1
  log("Connection from %.100s port %d", get_remote_ipaddr(), remote_port);
d675 1
a675 1
      fatal("Could not write ident string.");
d681 1
a681 1
      	fatal("Did not receive ident string.");
d707 2
a708 1
      fatal("Bad protocol version identification: %.100s", buf);
d718 2
a719 1
      fatal("Protocol major versions differ: %d vs. %d", 
d763 1
a763 1
  log("Closing connection to %.100s", inet_ntoa(sin.sin_addr));
d880 2
a881 1
        fatal("do_connection: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
d897 2
a898 1
        fatal("do_connection: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
d920 2
a921 1
    fatal("do_connection: bad len: session_key_int %d > sizeof(session_key) %d",
d1093 2
a1094 1
      debug("Login for user %.100s accepted without authentication.", user);
a1100 2
  /* XXX log unified auth message */

d1120 3
a1122 1
#define MAX_AUTH_FAILURES 5
d1129 1
a1129 1
  int authentication_failures = 0;
d1134 1
d1136 2
d1144 1
a1144 1
  for (;;) {
d1146 1
d1149 1
a1149 1
    int type = packet_read(&plen);
d1159 1
a1159 1
	    log("Kerberos tgt passing disabled.");
d1167 1
a1167 1
	    debug("Kerberos tgt REFUSED for %s", pw->pw_name);
d1175 1
a1175 1
	  log("AFS token passing disabled.");
d1183 1
a1183 1
	    debug("AFS token REFUSED for %s", pw->pw_name);
d1194 1
a1194 1
	    log("Kerberos authentication disabled.");
d1210 2
a1211 5
	  log("Kerberos authentication %s%s for account %s from %s", 
	      authenticated ? "accepted " : "failed",
	      tkt_user != NULL ? tkt_user : "",
	      pw->pw_name, get_canonical_hostname());
          if (authenticated)
d1213 1
d1221 1
a1221 1
	    log("Rhosts authentication disabled.");
d1228 2
a1229 2
	client_user = packet_get_string(&dlen);
	packet_integrity_check(plen, 4 + dlen, type);
d1234 1
a1234 3
	log("Rhosts authentication %s for %.100s, remote %.100s on %.700s.",
	     authenticated ? "accepted" : "failed",
	     pw->pw_name, client_user, get_canonical_hostname());
d1241 1
a1241 1
	    log("Rhosts with RSA authentication disabled.");
a1263 4
	log("Rhosts authentication %s for %.100s, remote %.100s.",
	     authenticated ? "accepted" : "failed",
	     pw->pw_name, client_user);
	xfree(client_user);
d1266 3
d1274 1
a1274 1
	    log("RSA authentication disabled.");
a1281 1

a1282 3
	log("RSA authentication %s for %.100s.",
	    authenticated ? "accepted" : "failed",
	    pw->pw_name);
d1289 1
a1289 1
	    log("Password authentication disabled.");
a1300 3
	log("Password authentication %s for %.100s.",
	    authenticated ? "accepted" : "failed",
	    pw->pw_name);
d1315 1
a1315 1
	break; /* Respond with a failure message. */
d1318 14
d1333 5
a1337 4
      break;
    if (++authentication_failures >= MAX_AUTH_FAILURES)
      packet_disconnect("Too many authentication failures for %.100s from %.200s", 
			 pw->pw_name, get_canonical_hostname());
d1350 6
a1355 1
  int authentication_failures = 0;
d1364 1
a1364 1
  for (;;)
d1370 1
a1370 1
      int passw_len;
d1375 2
a1376 2
         (password = packet_get_string(&passw_len)) != NULL &&
         passw_len == 5 &&
d1383 3
a1385 3
      if (++authentication_failures >= MAX_AUTH_FAILURES)
        packet_disconnect("Too many authentication failures for %.100s from %.200s", 
                          user, get_canonical_hostname());
@


1.60
log
@fix sigchld race; cjc5@@po.cwru.edu
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.59 1999/11/19 19:58:18 markus Exp $");
d77 4
d261 1
a261 1
  while ((opt = getopt(ac, av, "f:p:b:k:h:g:diqQ")) != EOF)
d296 5
d643 30
a672 25
  /* Send our protocol version identification. */
  snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s\n", 
	  PROTOCOL_MAJOR, PROTOCOL_MINOR, SSH_VERSION);
  if (write(sock_out, buf, strlen(buf)) != strlen(buf))
    fatal("Could not write ident string.");

  /* Read other side\'s version identification. */
  for (i = 0; i < sizeof(buf) - 1; i++)
    {
      if (read(sock_in, &buf[i], 1) != 1)
	fatal("Did not receive ident string.");
      if (buf[i] == '\r')
	{
	  buf[i] = '\n';
	  buf[i + 1] = 0;
	  break;
	}
      if (buf[i] == '\n')
	{
	  /* buf[i] == '\n' */
	  buf[i + 1] = 0;
	  break;
	}
    }
  buf[sizeof(buf) - 1] = 0;
@


1.59
log
@SSH_CMSG_MAX_PACKET_SIZE, some clients use this, some need this, niels@@
[hope this time my ISP stays alive during commit]
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.58 1999/11/18 14:00:49 markus Exp $");
d173 4
a176 1
  wait(&status);
@


1.58
log
@more %d vs. %s in fmt-strings
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.57 1999/11/17 09:51:21 markus Exp $");
d1539 5
a1580 4

	case SSH_CMSG_MAX_PACKET_SIZE:
      	  debug("The server does not support limiting packet size.");
	  goto fail;
@


1.57
log
@bugfix: the log() for passwd-auth escaped during logging changes.
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.56 1999/11/16 21:15:19 markus Exp $");
d1212 1
a1212 1
	        "actual %d, announced %s", BN_num_bits(client_host_key_n), bits);
@


1.56
log
@force logging to stderr while loading private key file
(lost while converting to new log-levels)
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.55 1999/11/15 21:38:54 markus Exp $");
d1236 1
a1237 1
	BN_clear_free(n);
d1241 1
d1259 3
@


1.55
log
@remove support for cipher RC4
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.54 1999/11/15 20:53:25 markus Exp $");
d342 3
a344 6
  /* Initialize the log (it is reinitialized below in case we forked). */

  if (debug_flag && !inetd_flag)
    log_stderr = 1;

  log_init(av0, options.log_level, options.log_facility, log_stderr);
d349 1
d354 2
a355 11
      if (debug_flag)
	fprintf(stderr, "Could not load host key: %s: %s\n",
		options.host_key_file, strerror(errno));
      else
	{
	  int err = errno;
 	  /* force logging */
          log_init(av0, SYSLOG_LEVEL_DEBUG, options.log_facility, log_stderr);
	  error("Could not load host key: %.200s: %.100s", 
		options.host_key_file, strerror(err));
	}
d359 5
@


1.54
log
@the keysize of rsa-parameter 'n' is passed implizit,
a few more checks and warnings about 'pretended' keysizes.
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.53 1999/11/15 00:42:01 markus Exp $");
d895 1
a895 2
  packet_set_encryption_key(session_key, SSH_SESSION_KEY_LENGTH, 
			    cipher_type, 0);
@


1.53
log
@disconnect if getpeername() fails
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.52 1999/11/14 23:20:09 markus Exp $");
a871 1
		     BN_num_bits(sensitive_data.host_key->n),
a872 1
		     BN_num_bits(sensitive_data.private_key->n),
d1090 1
a1090 1
  unsigned int client_host_key_bits;
d1213 1
a1213 1
	client_host_key_bits = packet_get_int();
d1216 4
a1219 1
  
d1222 1
a1222 1
	authenticated = auth_rhosts_rsa(pw, client_user, client_host_key_bits,
@


1.52
log
@split do_authentication() in subroutines
move checking of remote port to central place
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.51 1999/11/11 23:36:53 markus Exp $");
d1244 1
a1244 1
	log("RSA authentication %s for %.100s failed.",
d1814 4
a1817 2
			  (struct sockaddr *)&from, &fromlen) < 0)
	    fatal("getpeername: %.100s", strerror(errno));
@


1.51
log
@make all access to options via 'extern Options options'
and 'extern ServerOptions options' respectively;
options are no longer passed as arguments:
 * make options handling more consistent
 * remove #include "readconf.h" from ssh.h
 * readconf.h is only included if necessary
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.50 1999/11/11 22:58:39 markus Exp $");
d117 4
a120 2
void do_connection(int privileged_port);
void do_authentication(char *user, int privileged_port);
d238 1
d606 2
d621 1
a621 2
    log("Connection from %.500s port %d",
	eval_client(&req), get_remote_port());
d625 1
a625 2
  log("Connection from %.100s port %d", 
      get_remote_ipaddr(), get_remote_port());
d698 13
d713 2
a714 3
  /* Handle the connection.   We pass as argument whether the connection
     came from a privileged port. */
  do_connection(get_remote_port() < IPPORT_RESERVED);
d735 2
a736 1
void do_connection(int privileged_port)
d928 1
a928 1
  do_authentication(user, privileged_port);
d1011 1
a1011 4
   in as (received from the clinet).  Privileged_port is true if the
   connection comes from a privileged port (used for .rhosts authentication).*/

#define MAX_AUTH_FAILURES 5
d1014 1
a1014 1
do_authentication(char *user, int privileged_port)
a1015 4
  int type;
  int authenticated = 0;
  int authentication_failures = 0;
  char *password;
d1017 1
a1017 4
  char *client_user;
  unsigned int client_host_key_bits;
  BIGNUM *client_host_key_e, *client_host_key_n;
			 
d1029 1
a1029 41
    {
      /* The user does not exist or access is denied,
         but fake indication that authentication is needed. */
      packet_start(SSH_SMSG_FAILURE);
      packet_send();
      packet_write_wait();

      /* Keep reading packets, and always respond with a failure.  This is to
	 avoid disclosing whether such a user really exists. */
      for (;;)
	{
	  /* Read a packet.  This will not return if the client disconnects. */
	  int plen;
	  int type = packet_read(&plen);
#ifdef SKEY
	  int passw_len;
	  char *password, *skeyinfo;
	  if (options.password_authentication &&
	     options.skey_authentication == 1 &&
	     type == SSH_CMSG_AUTH_PASSWORD &&
	     (password = packet_get_string(&passw_len)) != NULL &&
	     passw_len == 5 &&
	     strncasecmp(password, "s/key", 5) == 0 &&
	     (skeyinfo = skey_fake_keyinfo(user)) != NULL ){
	    /* Send a fake s/key challenge. */
	    packet_send_debug(skeyinfo);
          }
#endif
          if (++authentication_failures >= MAX_AUTH_FAILURES) {
	    packet_disconnect("Too many authentication failures for %.100s from %.200s", 
            		       user, get_canonical_hostname());
          }
	  /* Send failure.  This should be indistinguishable from a failed
	     authentication. */
	  packet_start(SSH_SMSG_FAILURE);
	  packet_send();
	  packet_write_wait();
	}
      /*NOTREACHED*/
      abort();
    }
d1057 4
a1060 3
      /* authentication_type = SSH_AUTH_PASSWORD; */
      authenticated = 1;
      /* Success packet will be sent after loop below. */
d1062 5
a1066 1
  else
d1068 5
a1072 4
      /* Indicate that authentication is needed. */
      packet_start(SSH_SMSG_FAILURE);
      packet_send();
      packet_write_wait();
d1075 30
a1104 10
  /* Loop until the user has been authenticated or the connection is closed. */
  while (!authenticated)
    {
      int plen;
      /* Get a packet from the client. */
      type = packet_read(&plen);
      
      /* Process the packet. */
      switch (type)
	{
d1106 6
d1113 3
a1115 20
	case SSH_CMSG_HAVE_KERBEROS_TGT:
	  if (!options.kerberos_tgt_passing)
	    {
	      /* packet_get_all(); */
	      log("Kerberos tgt passing disabled.");
	      break;
	    }
	  else {
	    /* Accept Kerberos tgt. */
	    int dlen;
	    char *tgt = packet_get_string(&dlen);
	    packet_integrity_check(plen, 4 + dlen, type);
	    if (!auth_kerberos_tgt(pw, tgt))
	      debug("Kerberos tgt REFUSED for %s", user);
	    xfree(tgt);
	  }
	  continue;

	case SSH_CMSG_HAVE_AFS_TOKEN:
	  if (!options.afs_token_passing || !k_hasafs()) {
d1117 1
a1117 1
	    log("AFS token passing disabled.");
d1120 25
a1144 10
	  else {
	    /* Accept AFS token. */
	    int dlen;
	    char *token_string = packet_get_string(&dlen);
	    packet_integrity_check(plen, 4 + dlen, type);
	    if (!auth_afs_token(pw, token_string))
	      debug("AFS token REFUSED for %s", user);
	    xfree(token_string);
	    continue;
	  }
d1146 1
a1146 1
	  
d1148 6
a1153 30
	case SSH_CMSG_AUTH_KERBEROS:
	  if (!options.kerberos_authentication)
	    {
	      /* packet_get_all(); */
	      log("Kerberos authentication disabled.");
	      break;
	    }
	  else {
	    /* Try Kerberos v4 authentication. */
	    KTEXT_ST auth;
	    char *tkt_user = NULL;
	    char *kdata = packet_get_string((unsigned int *)&auth.length);
	    packet_integrity_check(plen, 4 + auth.length, type);

	    if (auth.length < MAX_KTXT_LEN)
	      memcpy(auth.dat, kdata, auth.length);
	    xfree(kdata);
	    
	    if (auth_krb4(user, &auth, &tkt_user)) {
	      /* Client has successfully authenticated to us. */
	      log("Kerberos authentication accepted %s for account "
		  "%s from %s", tkt_user, user, get_canonical_hostname());
	      /* authentication_type = SSH_AUTH_KERBEROS; */
	      authenticated = 1;
	      xfree(tkt_user);
	    }
	    else {
	      log("Kerberos authentication failed for account "
		  "%s from %s", user, get_canonical_hostname());
	    }
d1155 10
a1164 2
	  break;
#endif /* KRB4 */
d1166 1
a1166 6
	case SSH_CMSG_AUTH_RHOSTS:
	  if (!options.rhosts_authentication)
	    {
	      log("Rhosts authentication disabled.");
	      break;
	    }
d1168 12
a1179 10
	  /* Rhosts authentication (also uses /etc/hosts.equiv). */
	  if (!privileged_port)
	    {
	      log("Rhosts authentication not available for connections from unprivileged port.");
	      break;
	    }

	  /* Get client user name.  Note that we just have to trust the client;
	     this is one reason why rhosts authentication is insecure. 
	     (Another is IP-spoofing on a local network.) */
d1181 2
a1182 3
	    int dlen;
	    client_user = packet_get_string(&dlen);
	    packet_integrity_check(plen, 4 + dlen, type);
d1184 9
d1194 8
a1201 30
	  /* Try to authenticate using /etc/hosts.equiv and .rhosts. */
	  if (auth_rhosts(pw, client_user))
	    {
	      /* Authentication accepted. */
	      log("Rhosts authentication accepted for %.100s, remote %.100s on %.700s.",
		  user, client_user, get_canonical_hostname());
	      authenticated = 1;
	      xfree(client_user);
	      break;
	    }
	  log("Rhosts authentication failed for %.100s, remote %.100s.",
		user, client_user);
	  xfree(client_user);
	  break;

	case SSH_CMSG_AUTH_RHOSTS_RSA:
	  if (!options.rhosts_rsa_authentication)
	    {
	      log("Rhosts with RSA authentication disabled.");
	      break;
	    }

	  /* Rhosts authentication (also uses /etc/hosts.equiv) with RSA
	     host authentication. */
	  if (!privileged_port)
	    {
	      log("Rhosts authentication not available for connections from unprivileged port.");
	      break;
	    }

d1203 2
a1204 14
	    int ulen, elen, nlen;
	    /* Get client user name.  Note that we just have to trust
	       the client; root on the client machine can claim to be
	       any user. */
	    client_user = packet_get_string(&ulen);

	    /* Get the client host key. */
	    client_host_key_e = BN_new();
	    client_host_key_n = BN_new();
	    client_host_key_bits = packet_get_int();
	    packet_get_bignum(client_host_key_e, &elen);
	    packet_get_bignum(client_host_key_n, &nlen);

	    packet_integrity_check(plen, (4 + ulen) + 4 + elen + nlen, type);
d1206 27
a1232 26

	  if (auth_rhosts_rsa(pw, client_user,
			      client_host_key_bits, client_host_key_e, client_host_key_n))
	    {
	      /* Authentication accepted. */
	      authenticated = 1;
	      xfree(client_user);
	      BN_clear_free(client_host_key_e);
	      BN_clear_free(client_host_key_n);
	      break;
	    }
	  log("Rhosts authentication failed for %.100s, remote %.100s.",
		user, client_user);
	  xfree(client_user);
	  BN_clear_free(client_host_key_e);
	  BN_clear_free(client_host_key_n);
	  break;
	  
	case SSH_CMSG_AUTH_RSA:
	  if (!options.rsa_authentication)
	    {
	      log("RSA authentication disabled.");
	      break;
	    }

	  /* RSA authentication requested. */
d1234 2
a1235 17
	    int nlen;
	    BIGNUM *n;
	    n = BN_new();
	    packet_get_bignum(n, &nlen);

	    packet_integrity_check(plen, nlen, type);
	    
	    if (auth_rsa(pw, n))
	      { 
		/* Successful authentication. */
		BN_clear_free(n);
		log("RSA authentication for %.100s accepted.", user);
		authenticated = 1;
		break;
	      }
	    BN_clear_free(n);
	    log("RSA authentication for %.100s failed.", user);
d1237 14
a1250 13
	  break;

	case SSH_CMSG_AUTH_PASSWORD:
	  if (!options.password_authentication)
	    {
	      log("Password authentication disabled.");
	      break;
	    }

	  /* Password authentication requested. */
	  /* Read user password.  It is in plain text, but was transmitted
	     over the encrypted channel so it is not visible to an outside
	     observer. */
d1252 2
a1253 3
	    int passw_len;
	    password = packet_get_string(&passw_len);
	    packet_integrity_check(plen, 4 + passw_len, type);
d1255 25
d1281 11
a1291 15
	  /* Try authentication with the password. */
	  if (auth_password(pw, password))
	    {
	      /* Successful authentication. */
	      /* Clear the password from memory. */
	      memset(password, 0, strlen(password));
	      xfree(password);
	      log("Password authentication for %.100s accepted.", user);
	      authenticated = 1;
	      break;
	    }
	  log("Password authentication for %.100s failed.", user);
	  memset(password, 0, strlen(password));
	  xfree(password);
	  break;
d1293 6
a1298 4
	case SSH_CMSG_AUTH_TIS:
	  /* TIS Authentication is unsupported */
	  log("TIS authentication disabled.");
	  break;
d1300 4
a1303 9
	default:
	  /* Any unknown messages will be ignored (and failure returned)
	     during authentication. */
	  log("Unknown message during authentication: type %d", type);
	  break; /* Respond with a failure message. */
	}
      /* If successfully authenticated, break out of loop. */
      if (authenticated)
	break;
d1305 19
a1323 3
      if (++authentication_failures >= MAX_AUTH_FAILURES) {
	packet_disconnect("Too many authentication failures for %.100s from %.200s", 
          pw->pw_name, get_canonical_hostname());
d1325 6
a1330 1
      /* Send a message indicating that the authentication attempt failed. */
a1333 1

d1335 3
a1338 18
  /* Check if the user is logging in as root and root logins are disallowed. */
  if (pw->pw_uid == 0 && !options.permit_root_login)
    {
      if (forced_command)
	log("Root login accepted for forced command.");
      else
	packet_disconnect("ROOT LOGIN REFUSED FROM %.200s", 
			  get_canonical_hostname());
    }

  /* The user has been authenticated and accepted. */
  packet_start(SSH_SMSG_SUCCESS);
  packet_send();
  packet_write_wait();

  /* Perform session preparation. */
  do_authenticated(pw);
}
@


1.50
log
@IgnoreUserKnownHosts(default=no), used for RhostRSAAuth, ok deraadt,millert
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.49 1999/11/11 15:23:14 markus Exp $");
d1210 1
a1210 2
	  if (auth_rhosts(pw, client_user, options.ignore_rhosts,
			  options.strict_modes))
d1289 1
a1289 1
	    if (auth_rsa(pw, n, options.strict_modes))
@


1.49
log
@session_key_int may be zero
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.48 1999/11/11 10:05:34 markus Exp $");
a1256 1
	  /* Try to authenticate using /etc/hosts.equiv and .rhosts. */
d1258 1
a1258 3
			      client_host_key_bits, client_host_key_e,
			      client_host_key_n, options.ignore_rhosts,
			      options.strict_modes))
@


1.48
log
@fix fatal/assert() bug reported by damien@@ibs.com.au:
allow session_key_int != sizeof(session_key)
[this should fix the pre-assert-removal-core-files]
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.47 1999/11/10 23:36:45 markus Exp $");
d866 1
a866 1
  if (len <= 0 || len > sizeof(session_key))
@


1.47
log
@add LogLevel {QUIET, FATAL, ERROR, INFO, CHAT, DEBUG} to ssh/sshd,
obsoletes QuietMode and FascistLogging in sshd.
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.46 1999/11/10 22:24:01 markus Exp $");
d722 1
a722 1
  int i;
d865 6
a870 5
  if (BN_num_bytes(session_key_int) != sizeof(session_key)){
    fatal("do_connection: session_key_int %d != sizeof(session_key) %d",
	  BN_num_bytes(session_key_int), sizeof(session_key));
  }
  BN_bn2bin(session_key_int, session_key);
@


1.46
log
@remove x11- and krb-cleanup from fatal() + krb-cleanup cleanup
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.45 1999/11/03 23:31:03 markus Exp $");
d64 3
d260 1
d269 1
a269 1
	  options.quiet_mode = 1;
d340 5
a344 3
  log_init(av0, debug_flag && !inetd_flag, 
	   debug_flag || options.fascist_logging, 
	   options.quiet_mode, options.log_facility);
d359 2
a360 1
	  log_init(av0, !inetd_flag, 1, 0, options.log_facility);
d390 1
a390 3
  log_init(av0, debug_flag && !inetd_flag, 
	   debug_flag || options.fascist_logging, 
	   options.quiet_mode, options.log_facility);
d558 1
a558 3
		  log_init(av0, debug_flag && !inetd_flag, 
			   options.fascist_logging || debug_flag, 
			   options.quiet_mode, options.log_facility);
d1697 1
a1697 2
      log_init(av0, debug_flag && !inetd_flag, debug_flag, 
	       options.quiet_mode, options.log_facility);
d1826 1
a1826 2
      log_init(av0, debug_flag && !inetd_flag, debug_flag, options.quiet_mode, 
	       options.log_facility);
@


1.45
log
@don't send fail-msg but disconnect if too many authentication failures
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.44 1999/11/02 19:42:37 markus Exp $");
a45 4
#ifdef KRB4
char *ticket = NULL;
#endif /* KRB4 */

d47 1
a47 1
char *xauthfile = NULL;
d1380 13
d1548 1
a1776 5
#if defined(KRB4)
  /* Destroy user's ticket cache file. */
  (void) dest_tkt();
#endif /* KRB4 */
  
d2175 6
a2180 2
  if (ticket)
    child_set_env(&env, &envsize, "KRBTKFILE", ticket);
d2182 1
a2182 1

@


1.44
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.43 1999/11/02 19:10:15 markus Exp $");
d1051 4
a1059 4
          if (++authentication_failures >= MAX_AUTH_FAILURES) {
	    packet_disconnect("Too many authentication failures for %.100s from %.200s", 
            		       user, get_canonical_hostname());
          }
d1354 4
a1362 4
      if (++authentication_failures >= MAX_AUTH_FAILURES) {
	packet_disconnect("Too many authentication failures for %.100s from %.200s", 
          pw->pw_name, get_canonical_hostname());
      }
@


1.43
log
@remove unused argument. ok dugsong
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.42 1999/11/02 00:08:42 markus Exp $");
d826 8
a833 2
      assert(BN_num_bits(sensitive_data.private_key->n) >= 
	     BN_num_bits(sensitive_data.host_key->n) + SSH_KEY_BITS_RESERVED);
d842 7
a848 3
      assert(BN_num_bits(sensitive_data.host_key->n) >= 
	     BN_num_bits(sensitive_data.private_key->n) +
	     SSH_KEY_BITS_RESERVED);
d866 4
a869 1
  assert(BN_num_bytes(session_key_int) == sizeof(session_key));
@


1.42
log
@typo
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.41 1999/10/25 20:38:49 markus Exp $");
d1131 1
a1131 1
	    if (!auth_afs_token(user, pw->pw_uid, token_string))
@


1.41
log
@typo, s/to many/too many/, from zzlevo@@dd.chalmers.se
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.40 1999/10/18 06:16:50 markus Exp $");
d1356 1
a1356 1
	log("Root login accepted for forced command.", forced_command);
@


1.40
log
@OpenSSH-1.2, read my lips: no more patches
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.39 1999/10/18 01:54:18 provos Exp $");
d1044 1
a1044 1
	    packet_disconnect("To many authentication failures for %.100s from %.200s", 
d1347 1
a1347 1
	packet_disconnect("To many authentication failures for %.100s from %.200s", 
@


1.39
log
@the session key is only the least significant 256-bits, mask the rest away
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.38 1999/10/17 23:11:24 dugsong Exp $");
d690 2
a691 3
    if (strcmp(remote_version, SSH_VERSION) != 0) {
        debug("Agent forwarding disabled, remote version '%s' is not compatible.",
    	  SSH_VERSION);
@


1.38
log
@don't use KerberosOrLocalPassword unless KerberosAuthentication is set - from millert@@
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.37 1999/10/17 20:48:07 dugsong Exp $");
d856 1
@


1.37
log
@remove AllowHosts, DenyHosts, SilentDeny server access control cruft - replace with LIBWRAP moved to child. ok markus@@ deraat@@
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.36 1999/10/17 20:43:31 dugsong Exp $");
d1072 1
a1072 1
      options.kerberos_or_local_passwd &&
@


1.36
log
@use daemon()
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.35 1999/10/17 20:39:11 dugsong Exp $");
a530 18
#ifdef LIBWRAP
	  {
	    struct request_info req;
	    request_init(&req, RQ_DAEMON, av0, RQ_FILE, newsock, NULL);
	    fromhost(&req);
	    if (!hosts_access(&req)) 
	      {
		error("Connection from %.500s refused by tcp_wrappers.",
		      eval_client(&req));
		shutdown(newsock, SHUT_RDWR);
		close(newsock);
		continue;
	      }
	    /* if from inet: refuse(&req); */
	    log("connect from %.500s", eval_client(&req));
	  }
#endif /* LIBWRAP */

d604 17
d624 1
a624 21

  /* Check whether logins are denied from this host. */
  if (options.num_deny_hosts > 0)
    {
      const char *hostname = get_canonical_hostname();
      const char *ipaddr = get_remote_ipaddr();
      int i;
      for (i = 0; i < options.num_deny_hosts; i++)
	if (match_pattern(hostname, options.deny_hosts[i]) ||
	    match_pattern(ipaddr, options.deny_hosts[i]))
	  {
	    if(!options.silent_deny){
	      log("Connection from %.200s denied.\n", hostname);
	      hostname = "You are not allowed to connect.  Go away!\r\n";
	      write(sock_out, hostname, strlen(hostname));
	    }
	    close(sock_in);
	    close(sock_out);
	    exit(0);
	  }
    }
a696 24
  /* Check whether logins are permitted from this host. */
  if (options.num_allow_hosts > 0)
    {
      const char *hostname = get_canonical_hostname();
      const char *ipaddr = get_remote_ipaddr();
      int i;
      for (i = 0; i < options.num_allow_hosts; i++)
	if (match_pattern(hostname, options.allow_hosts[i]) ||
	    match_pattern(ipaddr, options.allow_hosts[i]))
	  break;
      if (i >= options.num_allow_hosts)
	{
	  if(!options.silent_deny){
	    log("Connection from %.200s not allowed.\n", hostname);
	    packet_disconnect("Sorry, you are not allowed to connect.");
	  }else{
            close(sock_in);
            close(sock_out);
	    exit(0);
	  }
	  /*NOTREACHED*/
	}
    }

d2029 1
a2029 1
  const char *shell, *cp;
@


1.35
log
@-Wall, get rid of unused headers/vars
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.34 1999/10/16 23:11:29 markus Exp $");
d372 3
a374 10

      /* Fork, and have the parent exit.  The child becomes the server. */
      if (fork())
	exit(0);

      /* Redirect stdin, stdout, and stderr to /dev/null. */
      freopen("/dev/null", "r", stdin);
      freopen("/dev/null", "w", stdout);
      freopen("/dev/null", "w", stderr);

a383 1
      (void)setsid();
@


1.34
log
@refuse to talk to protocol < 1.3
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.33 1999/10/16 20:47:14 markus Exp $");
a37 2
#include <sys/syslog.h>
#include <sys/stat.h>
@


1.33
log
@support for SSH protocol 1.5 which is poorly documented, the RFC.troff lies.
interops (x11,agent,etc) with 1.2.27 and protocol 1.3
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.32 1999/10/14 18:54:45 markus Exp $");
d716 1
a716 1
  if (remote_major == 1 && remote_minor == 0)
d725 1
a725 1
      }
@


1.32
log
@"the french issue", stir RC4 after key usage, ok niels
from planchon@@math.polytechnique.fr
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.31 1999/10/14 18:17:42 markus Exp $");
d33 1
d719 8
a726 6
  if (strcmp(remote_version, SSH_VERSION) != 0)
    {
      debug("Agent forwarding disabled, remote version is not '%s'.",
	    SSH_VERSION);
      no_agent_forwarding_flag = 1;
    }
d1381 5
d1650 4
@


1.31
log
@fix old connect() race security-bug for ssh-agent and agent-forwarding
by removing the connect() junk, with the following restrictions:
1) change the version to "OpenSSH-1.1":
   agent-forwarding will work only between OpenSSH-1.1 client and
   OpenSSH-1.1 server
2) renamed the environment variable of OpenSSH-1.1 to
   "SSH_AUTH_SOCKET", since useing OpenSSH-1.0 ssh-add against the new
   ssh-agent does not work
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.30 1999/10/12 18:11:55 markus Exp $");
d599 2
@


1.30
log
@SilentDeny, don't log/answer refused connections, deraadt@@
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.29 1999/10/12 05:45:43 deraadt Exp $");
d715 7
@


1.29
log
@setsid() for all connections; millert/markus
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.28 1999/10/11 21:48:29 markus Exp $");
d643 5
a647 3
	    log("Connection from %.200s denied.\n", hostname);
	    hostname = "You are not allowed to connect.  Go away!\r\n";
	    write(sock_out, hostname, strlen(hostname));
d728 8
a735 2
	  log("Connection from %.200s not allowed.\n", hostname);
	  packet_disconnect("Sorry, you are not allowed to connect.");
@


1.28
log
@Allow/Deny Users/Groups, from zzlevo@@dd.chalmers.se, ok deraadt@@
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.27 1999/10/11 21:07:37 markus Exp $");
d1700 5
d2076 2
a2077 1
  setlogin(pw->pw_name);
@


1.27
log
@UseLogin, default=no, from kpa@@gmx.net, ok deraadt@@
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.26 1999/10/11 20:00:36 markus Exp $");
d937 78
d1044 1
a1044 1
  if (!pw)
d1046 2
a1047 1
      /* The user does not exist. */
@


1.26
log
@make sure ~/.ssh/authorized_keys is not writable for group/world (sshd)
don't load private keys if they are group/world-{rwx} (ssh,sshd and ssh-add)
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.25 1999/10/07 22:46:33 markus Exp $");
d1735 4
a1738 2
  last_login_time = get_last_login_time(pw->pw_uid, pw->pw_name,
					buf, sizeof(buf));
d1795 4
a1798 2
	 machine without users knowing they are going to another machine). */
      if (command == NULL && last_login_time != 0 && !quiet_login)
d1813 4
a1816 3
	 disabled in server options.  Note that some machines appear to
	 print it in /etc/profile or similar. */
      if (command == NULL && options.print_motd && !quiet_login)
d1995 25
a2019 21
  if (getuid() == 0 || geteuid() == 0)
    { 
      if (setgid(pw->pw_gid) < 0)
	{
	  perror("setgid");
	  exit(1);
	}
      /* Initialize the group list. */
      if (initgroups(pw->pw_name, pw->pw_gid) < 0)
	{
	  perror("initgroups");
	  exit(1);
	}
      endgrent();

      /* Permanently switch to the desired uid. */
      permanently_set_uid(pw->pw_uid);
    }

  if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
    fatal("Failed to set uids to %d.", (int)pw->pw_uid);
d2043 14
a2056 5
  /* Set basic environment. */
  child_set_env(&env, &envsize, "USER", pw->pw_name);
  child_set_env(&env, &envsize, "LOGNAME", pw->pw_name);
  child_set_env(&env, &envsize, "HOME", pw->pw_dir);
  child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
a2061 7
  snprintf(buf, sizeof buf, "%.200s/%.50s",
    _PATH_MAILDIR, pw->pw_name);
  child_set_env(&env, &envsize, "MAIL", buf);

  /* Normal systems set SHELL by default. */
  child_set_env(&env, &envsize, "SHELL", shell);

d2112 4
a2115 2
  snprintf(buf, sizeof buf, "%.200s/.ssh/environment", pw->pw_dir);
  read_environment_file(&env, &envsize, buf);
d2163 2
a2164 17
  if (stat(SSH_USER_RC, &st) >= 0)
    {
      if (debug_flag)
	fprintf(stderr, "Running /bin/sh %s\n", SSH_USER_RC);

      f = popen("/bin/sh " SSH_USER_RC, "w");
      if (f)
	{
	  if (auth_proto != NULL && auth_data != NULL)
	    fprintf(f, "%s %s\n", auth_proto, auth_data);
	  pclose(f);
	}
      else
	fprintf(stderr, "Could not run %s\n", SSH_USER_RC);
    }
  else
    if (stat(SSH_SYSTEM_RC, &st) >= 0)
d2166 12
a2177 12
	if (debug_flag)
	  fprintf(stderr, "Running /bin/sh %s\n", SSH_SYSTEM_RC);

	f = popen("/bin/sh " SSH_SYSTEM_RC, "w");
	if (f)
	  {
	    if (auth_proto != NULL && auth_data != NULL)
	      fprintf(f, "%s %s\n", auth_proto, auth_data);
	    pclose(f);
	  }
	else
	  fprintf(stderr, "Could not run %s\n", SSH_SYSTEM_RC);
d2179 16
d2196 19
a2214 19
    else
      {
	/* Add authority data to .Xauthority if appropriate. */
	if (auth_proto != NULL && auth_data != NULL)
	  {
	    if (debug_flag)
	      fprintf(stderr, "Running %.100s add %.100s %.100s %.100s\n",
		      XAUTH_PATH, display, auth_proto, auth_data);
	    
	    f = popen(XAUTH_PATH " -q -", "w");
	    if (f)
	      {
		fprintf(f, "add %s %s %s\n", display, auth_proto, auth_data);
		fclose(f);
	      }
	    else
	      fprintf(stderr, "Could not run %s -q -\n", XAUTH_PATH);
	  }
      }
d2217 7
a2223 6
  /* Get the last component of the shell name. */
  cp = strrchr(shell, '/');
  if (cp)
    cp++;
  else
    cp = shell;
d2230 2
a2231 1
      char buf[256];
d2233 13
a2245 12
      /* Check for mail if we have a tty and it was enabled in server options. */
      if (ttyname && options.check_mail) {
        char *mailbox;
        struct stat mailstat;
        mailbox = getenv("MAIL");
        if(mailbox != NULL) {
          if(stat(mailbox, &mailstat) != 0 || mailstat.st_size == 0) {
            printf("No mail.\n");
          } else if(mailstat.st_mtime < mailstat.st_atime) {
            printf("You have mail.\n");
          } else {
            printf("You have new mail.\n");
d2248 21
a2269 11
      /* Start the shell.  Set initial character to '-'. */
      buf[0] = '-';
      strncpy(buf + 1, cp, sizeof(buf) - 1);
      buf[sizeof(buf) - 1] = 0;
      /* Execute the shell. */
      argv[0] = buf;
      argv[1] = NULL;
      execve(shell, argv, env);
      /* Executing the shell failed. */
      perror(shell);
      exit(1);
@


1.25
log
@You have Mail. Email fuer Dich. Karsten Patzwaldt <kpa@@gmx.net> default=no
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.24 1999/10/07 21:45:02 markus Exp $");
d1236 1
a1236 1
	    if (auth_rsa(pw, n))
@


1.24
log
@add skey to sshd:

1) pass *pw to auth_password() not user_name, do_authentication already
   keeps private copy of struct passwd for current user.
2) limit authentication attemps to 5, otherwise
        ssh -o 'NumberOfPasswordPrompts 100000' host
   lets you enter 100000 passwds
3) make s/key a run-time option in /etc/sshd_config
4) generate fake skeys,
   for s/key for nonexisting users, too
   limit auth-tries for nonexisting users, too.
Note that
% ssh -l nonexisting-user -o 'NumberOfPasswordPrompts 100000' host
has NO limits in ssh-1.2.27
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.23 1999/10/07 04:40:03 deraadt Exp $");
d38 1
d2217 15
@


1.23
log
@add -Q flag: says whether ssh RSA check should whine on stdout
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.22 1999/10/05 22:18:52 markus Exp $");
d941 2
d948 1
d978 15
a992 2
	  (void) packet_read(&plen);

d998 4
d1029 1
a1029 1
      auth_password(user, ""))
d1266 1
a1266 1
	  if (auth_password(user, password))
d1295 5
@


1.22
log
@move auth-sockets to private dir
delete minfd residua
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.21 1999/10/05 18:34:55 dugsong Exp $");
d233 1
a247 6
  /* check if RSA support exists */
  if (rsa_alive() == 0) {
    log("no RSA support in libssl and libcrypto -- exiting.  See ssl(8)");
    exit(1);
  }

d252 1
a252 1
  while ((opt = getopt(ac, av, "f:p:b:k:h:g:diq")) != EOF)
d265 3
d304 8
@


1.21
log
@clear xauthfile on mkstemp failure. adam@@xpert.com
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.20 1999/10/05 18:01:07 dugsong Exp $");
d2105 1
a2105 5
    {
      if (i == auth_get_fd())
	continue;
      close(i);
    }
@


1.20
log
@fix potential xauth race
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.19 1999/10/04 20:45:02 markus Exp $");
d1448 1
@


1.19
log
@nuke genminfd/AUTH_FD
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.18 1999/10/03 21:02:12 deraadt Exp $");
d1299 1
a1299 1
  int have_pty = 0, ptyfd = -1, ttyfd = -1;
d1440 9
a1448 3
	  snprintf(xauthfile, MAXPATHLEN, "/tmp/Xauth%d_%d",
	    pw->pw_uid, getpid());

@


1.18
log
@errno trashing in signal handlers
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.17 1999/10/03 19:22:39 deraadt Exp $");
d2057 3
a2059 12
  if (get_permanent_fd(pw->pw_shell) < 0)
    {
      if (auth_get_socket_name() != NULL)
	child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME, 
		      auth_get_socket_name());
    }
  else
    if (auth_get_fd() >= 0)
      {
	snprintf(buf, sizeof buf, "%d", auth_get_fd());
	child_set_env(&env, &envsize, SSH_AUTHFD_ENV_NAME, buf);
      }
@


1.17
log
@use SHUT_* symbols
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.16 1999/10/03 04:21:08 deraadt Exp $");
d170 1
d174 1
d195 2
d221 1
@


1.16
log
@a few setproctitle() calls...
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.15 1999/09/30 21:45:47 aaron Exp $");
d464 1
a464 1
	  shutdown(listen_sock, 2);
d537 1
a537 1
		shutdown(newsock, 2);
@


1.15
log
@We don't have an /etc/environment.
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.14 1999/09/30 08:34:25 deraadt Exp $");
d920 1
d1568 2
d1693 2
@


1.14
log
@even smaller
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.13 1999/09/30 06:06:31 deraadt Exp $");
a2058 4

  /* Read environment variable settings from /etc/environment.  (This exists
     at least on AIX, but could be useful also elsewhere.) */
  read_environment_file(&env, &envsize, "/etc/environment");
@


1.13
log
@use IPPORT_RESERVED instead of 1024
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.12 1999/09/30 05:53:04 deraadt Exp $");
d136 1
a136 1
RETSIGTYPE sighup_handler(int sig)
d158 1
a158 1
RETSIGTYPE sigterm_handler(int sig)
d168 1
a168 1
RETSIGTYPE main_sigchld_handler(int sig)
d177 1
a177 1
RETSIGTYPE grace_alarm_handler(int sig)
d191 1
a191 1
RETSIGTYPE key_regeneration_alarm(int sig)
a1355 3
#ifdef TTY_GROUP
	  grp = getgrnam(TTY_GROUP);
#else /* TTY_GROUP */
a1356 1
#endif /* TTY_GROUP */
a1936 1
#ifdef HAVE_SETLOGIN
a1938 1
#endif /* HAVE_SETLOGIN */
d1996 1
a1996 1
    MAIL_SPOOL_DIRECTORY, pw->pw_name);
@


1.12
log
@"ssh is a very large program" -- anonymous
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.11 1999/09/30 05:03:05 deraadt Exp $");
d724 1
a724 1
  do_connection(get_remote_port() < 1024);
@


1.11
log
@cull more ancient garbage from pre-POSIX days
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.10 1999/09/30 04:30:03 deraadt Exp $");
a232 1
#ifdef SO_LINGER
a233 1
#endif /* SO_LINGER */
a448 1
#ifdef SO_LINGER
a452 1
#endif /* SO_LINGER */
a608 1
#ifdef SO_LINGER
a611 1
#endif /* SO_LINGER */
@


1.10
log
@more culling
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.9 1999/09/30 04:10:29 deraadt Exp $");
a1297 1
#ifdef WITH_ZLIB
a1298 1
#endif /* WITH_ZLIB */
a1329 1
#ifdef WITH_ZLIB
a1341 1
#endif /* WITH_ZLIB */
a1523 1
#ifdef WITH_ZLIB
a1529 1
#endif /* WITH_ZLIB */
@


1.9
log
@rely on paths.h more
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.8 1999/09/29 22:08:13 dugsong Exp $");
a32 6
#ifdef HAVE_USERSEC_H
#include <usersec.h>
#endif /* HAVE_USERSEC_H */
#ifdef HAVE_ULIMIT_H
#include <ulimit.h>
#endif /* HAVE_ULIMIT_H */
a36 1
#ifdef NEED_SYS_SYSLOG_H
a37 1
#endif /* NEED_SYS_SYSLOG_H */
a355 8
#ifdef SCO
  (void) set_auth_parameters(ac, av);
#endif

#ifdef HAVE_OSF1_C2_SECURITY
  initialize_osf_security(ac, av);
#endif /* HAVE_OSF1_C2_SECURITY */

a1924 94

#ifdef HAVE_ETC_DEFAULT_LOGIN

/* Gets the value of the given variable in the environment.  If the
   variable does not exist, returns NULL. */

char *child_get_env(char **env, const char *name)
{
  unsigned int i, namelen;

  namelen = strlen(name);

  for (i = 0; env[i]; i++)
    if (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')
      break;
  if (env[i])
    return &env[i][namelen + 1];
  else
    return NULL;
}

/* Processes /etc/default/login; this involves things like environment
   settings, ulimit, etc.  This file exists at least on Solaris 2.x. */

void read_etc_default_login(char ***env, unsigned int *envsize,
			    struct passwd *pw)
{
  unsigned int defenvsize;
  char **defenv, *def;
  int i;

  /* Read /etc/default/login into a separate temporary environment. */
  defenvsize = 10;
  defenv = xmalloc(defenvsize * sizeof(char *));
  defenv[0] = NULL;
  read_environment_file(&defenv, &defenvsize, "/etc/default/login");

  /* Set SHELL if ALTSHELL is YES. */
  def = child_get_env(defenv, "ALTSHELL");
  if (def != NULL && strcmp(def, "YES") == 0)
    child_set_env(env, envsize, "SHELL", pw->pw_shell);

  /* Set PATH from SUPATH if we are logging in as root, and PATH
     otherwise.  If neither of these exists, we use the default ssh
     path. */
  if (pw->pw_uid == 0)
    def = child_get_env(defenv, "SUPATH");
  else
    def = child_get_env(defenv, "PATH");
  if (def != NULL)
    child_set_env(env, envsize, "PATH", def);
  else
    child_set_env(env, envsize, "PATH", _PATH_STDPATH);

  /* Set TZ if TIMEZONE is defined and we haven't inherited a value
     for TZ. */
  def = getenv("TZ");
  if (def == NULL)
    def = child_get_env(defenv, "TIMEZONE");
  if (def != NULL)
    child_set_env(env, envsize, "TZ", def);

  /* Set HZ if defined. */
  def = child_get_env(defenv, "HZ");
  if (def != NULL)
    child_set_env(env, envsize, "HZ", def);

  /* Set up the default umask if UMASK is defined. */
  def = child_get_env(defenv, "UMASK");
  if (def != NULL)
    {
      int i, value;

      for (value = i = 0; 
	   def[i] && isdigit(def[i]) && def[i] != '8' && def[i] != '9'; 
	   i++)
	value = value * 8 + def[i] - '0';

      umask(value);
    }

  /* Set up the file size ulimit if ULIMIT is set. */
  def = child_get_env(defenv, "ULIMIT");
  if (def != NULL && atoi(def) > 0)
    ulimit(UL_SETFSIZE, atoi(def));

  /* Free the temporary environment. */
  for (i = 0; defenv[i]; i++)
    xfree(defenv[i]);
  xfree(defenv);
}

#endif /* HAVE_ETC_DEFAULT_LOGIN */

a1957 8
#ifdef HAVE_USERSEC_H
  /* On AIX, this "sets process credentials".  I am not sure what this
     includes, but it seems to be important.  This also does setuid
     (but we do it below as well just in case). */
  if (setpcred((char *)pw->pw_name, NULL))
    log("setpcred %.100s: %.100s", strerror(errno));
#endif /* HAVE_USERSEC_H */

a1965 1
#ifdef HAVE_INITGROUPS
a1971 1
#endif /* HAVE_INITGROUPS */
a1973 9
#ifdef HAVE_SETLUID
      /* Initialize login UID. */
      if (setluid(user_uid) < 0)
	{
	  perror("setluid");
	  exit(1);
	}
#endif /* HAVE_SETLUID */

a2012 1
#ifdef MAIL_SPOOL_DIRECTORY
a2015 6
#else /* MAIL_SPOOL_DIRECTORY */
#ifdef HAVE_TILDE_NEWMAIL
  snprintf(buf, sizeof buf, "%.200s/newmail", pw->pw_dir);
  child_set_env(&env, &envsize, "MAIL", buf);
#endif /* HAVE_TILDE_NEWMAIL */
#endif /* MAIL_SPOOL_DIRECTORY */
a2016 4
#ifdef HAVE_ETC_DEFAULT_LOGIN
  /* Read /etc/default/login; this exists at least on Solaris 2.x. */
  read_etc_default_login(&env, &envsize, pw);
#else /* HAVE_ETC_DEFAULT_LOGIN */
a2018 1
#endif /* HAVE_ETC_DEFAULT_LOGIN */
@


1.8
log
@fix server krb4 option initialization
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.7 1999/09/29 21:15:54 deraadt Exp $");
a49 14
#ifdef _PATH_BSHELL
#define DEFAULT_SHELL		_PATH_BSHELL
#else
#define DEFAULT_SHELL		"/bin/sh"
#endif

#ifndef DEFAULT_PATH
#ifdef _PATH_USERPATH
#define DEFAULT_PATH		_PATH_USERPATH
#else
#define DEFAULT_PATH	"/bin:/usr/bin:/usr/ucb:/usr/bin/X11:/usr/local/bin"
#endif
#endif /* DEFAULT_PATH */

d1993 1
a1993 1
    child_set_env(env, envsize, "PATH", DEFAULT_PATH);
d2112 1
a2112 1
  shell = (pw->pw_shell[0] == '\0') ? DEFAULT_SHELL : pw->pw_shell;
d2136 1
a2136 1
  child_set_env(&env, &envsize, "PATH", DEFAULT_PATH);
@


1.7
log
@we have setsid
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.6 1999/09/29 21:14:16 deraadt Exp $");
d837 1
a837 1
  if (options.kerberos_authentication && (access(KEYFILE, R_OK) == 0))
d843 1
a843 1
  if (options.afs_token_passing && k_hasafs())
@


1.6
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.5 1999/09/29 18:16:21 dugsong Exp $");
a411 1
#ifdef HAVE_SETSID
a412 1
#endif /* HAVE_SETSID */
@


1.5
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.4 1999/09/29 17:42:10 deraadt Exp $");
d688 1
a688 1
  sprintf(buf, "SSH-%d.%d-%.100s\n", 
d1480 2
a1481 1
	  sprintf(xauthfile, "/tmp/Xauth%d_%d", pw->pw_uid, getpid());
d1786 1
a1786 1
      sprintf(line, "%.200s/.hushlogin", pw->pw_dir);
d1902 1
a1902 1
  sprintf(env[i], "%s=%s", name, value);
d2159 2
a2160 1
  sprintf(buf, "%.200s/%.50s", MAIL_SPOOL_DIRECTORY, pw->pw_name);
d2164 1
a2164 1
  sprintf(buf, "%.200s/newmail", pw->pw_dir);
d2196 1
a2196 1
  sprintf(buf, "%.50s %d %d", 
d2231 1
a2231 1
	sprintf(buf, "%d", auth_get_fd());
d2240 1
a2240 1
  sprintf(buf, "%.200s/.ssh/environment", pw->pw_dir);
@


1.4
log
@log all auth failures; Markus.Friedl@@informatik.uni-erlangen.de
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.3 1999/09/29 06:15:00 deraadt Exp $");
a68 2
#include <sys/param.h>
#include <krb.h>
a69 3
#ifdef AFS
#include <kafs.h>
#endif /* AFS */
d792 1
a792 1
  u_int32_t rand;
d842 1
a842 1
#ifdef KERBEROS_TGT_PASSING
a844 2
#endif
#ifdef AFS
d1062 1
a1062 1
#ifdef KERBEROS_TGT_PASSING
d1066 1
d1070 2
a1071 2
	  /* Accept Kerberos tgt. */
	  {
d1073 1
a1073 1
	    char *data = packet_get_string(&dlen);
d1075 3
a1077 2
	    if (!auth_kerberos_tgt(pw, data))
	      debug("Kerberos tgt REFUSED for %.100s", user);
d1080 1
a1080 3
#endif /* KERBEROS_TGT_PASSING */
	  
#ifdef AFS
d1093 1
a1093 1
	      debug("AFS token REFUSED for %.100s", user);
d1103 1
d1107 1
a1107 1
	  {
d1114 2
a1115 1
	    memcpy(auth.dat, kdata, auth.length);
d1117 1
a1117 1

d1120 2
a1121 3
	      log("Kerberos authentication accepted %.100s for account "
		  "%.100s from %.200s", tkt_user, user,
		  get_canonical_hostname());
a1124 1
	      break;
d1126 4
a1129 2
	    log("Kerberos authentication failed for account "
		"%.100s from %.200s", user, get_canonical_hostname());
d1696 1
a1696 1
#if defined(KRB4) || defined(AFS)
d1699 1
a1699 1
#endif /* KRB4 || AFS */
d2210 1
a2210 1
#ifdef KRB4 /* XXX - how to make these coexist? */
@


1.3
log
@test for RSA in the ssl library, real early on
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.2 1999/09/28 04:45:37 provos Exp $");
d1173 1
a1173 1
	  debug("Rhosts authentication failed for %.100s, remote %.100s.",
d1223 1
a1223 1
	  debug("Rhosts authentication failed for %.100s, remote %.100s.",
d1255 1
a1255 1
	    debug("RSA authentication for %.100s failed.", user);
d1287 1
a1287 1
	  debug("Password authentication for %.100s failed.", user);
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d21 1
a21 1
RCSID("$Id: sshd.c,v 1.20 1999/08/18 15:33:10 bg Exp $");
d270 6
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@a22 1
#include <gmp.h>
d121 1
a121 1
   The private key contains MP_INTs, and we do not (in principle) have
a125 3
  /* Random number generator. */
  RandomState random_state;
  
d127 1
a127 1
  RSAPrivateKey private_key;
d130 1
a130 1
  RSAPrivateKey host_key;
d142 1
a142 1
RSAPublicKey public_key;
d225 12
a236 5
      random_acquire_light_environmental_noise(&sensitive_data.random_state);
      rsa_generate_key(&sensitive_data.private_key, &public_key, 
		       &sensitive_data.random_state, options.server_key_bits);
      random_stir(&sensitive_data.random_state);
      random_save(&sensitive_data.random_state, options.random_seed_file);
d248 2
a249 1
int main(int ac, char **av)
d358 1
d361 1
a361 1
			&sensitive_data.host_key, &comment))
d423 1
a423 1
     software patents. */
d425 1
a425 1
      sensitive_data.host_key.bits - SSH_KEY_BITS_RESERVED &&
d427 1
a427 1
      sensitive_data.host_key.bits + SSH_KEY_BITS_RESERVED)
d430 1
a430 1
	sensitive_data.host_key.bits + SSH_KEY_BITS_RESERVED;
a434 4
  /* Initialize memory allocation so that any freed MP_INT data will be
     zeroed. */
  rsa_set_mp_memory_allocation();

d439 1
a439 3
  debug("Initializing random number generator; seed file %.200s", 
	options.random_seed_file);
  random_initialize(&sensitive_data.random_state, options.random_seed_file);
d461 2
d465 3
a467 5
      rsa_generate_key(&sensitive_data.private_key, &public_key,
		       &sensitive_data.random_state,
		   options.server_key_bits);
      random_stir(&sensitive_data.random_state);
      random_save(&sensitive_data.random_state, options.random_seed_file);
d523 2
d527 1
a527 2
      rsa_generate_key(&sensitive_data.private_key, &public_key,
		       &sensitive_data.random_state,
d529 1
a529 2
      random_stir(&sensitive_data.random_state);
      random_save(&sensitive_data.random_state, options.random_seed_file);
d652 1
a652 1
  packet_set_connection(sock_in, sock_out, &sensitive_data.random_state);
d785 1
a785 1
  MP_INT session_key_int;
d791 1
d800 6
a805 2
  for (i = 0; i < 8; i++)
    check_bytes[i] = random_get_byte(&sensitive_data.random_state);
d814 3
a816 3
  packet_put_int(public_key.bits);
  packet_put_mp_int(&public_key.e);
  packet_put_mp_int(&public_key.n);
d819 3
a821 3
  packet_put_int(sensitive_data.host_key.bits);
  packet_put_mp_int(&sensitive_data.host_key.e);
  packet_put_mp_int(&sensitive_data.host_key.n);
d858 1
a858 1
	public_key.bits, sensitive_data.host_key.bits);
d875 2
a876 2
  mpz_init(&session_key_int);
  packet_get_mp_int(&session_key_int, &slen);
d886 1
a886 1
  if (mpz_cmp(&sensitive_data.private_key.n, &sensitive_data.host_key.n) > 0)
d889 6
a894 6
      assert(sensitive_data.private_key.bits >= 
	     sensitive_data.host_key.bits + SSH_KEY_BITS_RESERVED);
      rsa_private_decrypt(&session_key_int, &session_key_int,
			  &sensitive_data.private_key);
      rsa_private_decrypt(&session_key_int, &session_key_int,
			  &sensitive_data.host_key);
d899 7
a905 6
      assert(sensitive_data.host_key.bits >= 
	     sensitive_data.private_key.bits + SSH_KEY_BITS_RESERVED);
      rsa_private_decrypt(&session_key_int, &session_key_int,
			  &sensitive_data.host_key);
      rsa_private_decrypt(&session_key_int, &session_key_int,
			  &sensitive_data.private_key);
d909 5
a913 4
  compute_session_id(session_id, check_bytes, sensitive_data.host_key.bits,
		     &sensitive_data.host_key.n, 
		     sensitive_data.private_key.bits,
		     &sensitive_data.private_key.n);
d918 2
a919 2
  mp_linearize_msb_first(session_key, sizeof(session_key), 
			 &session_key_int);
d926 1
a926 1
  mpz_clear(&session_key_int);
d955 3
a957 3
  rsa_clear_public_key(&public_key);
  rsa_clear_private_key(&sensitive_data.private_key);
  rsa_clear_private_key(&sensitive_data.host_key);
d968 2
a969 1
void do_authentication(char *user, int privileged_port)
d977 1
a977 1
  MP_INT client_host_key_e, client_host_key_n;
d1195 2
a1196 2
	    mpz_init(&client_host_key_e);
	    mpz_init(&client_host_key_n);
d1198 2
a1199 2
	    packet_get_mp_int(&client_host_key_e, &elen);
	    packet_get_mp_int(&client_host_key_n, &nlen);
d1205 3
a1207 4
	  if (auth_rhosts_rsa(&sensitive_data.random_state,
			      pw, client_user,
			      client_host_key_bits, &client_host_key_e,
			      &client_host_key_n, options.ignore_rhosts,
d1213 2
a1214 2
	      mpz_clear(&client_host_key_e);
	      mpz_clear(&client_host_key_n);
d1220 2
a1221 2
	  mpz_clear(&client_host_key_e);
	  mpz_clear(&client_host_key_n);
d1234 3
a1236 3
	    MP_INT n;
	    mpz_init(&n);
	    packet_get_mp_int(&n, &nlen);
d1240 1
a1240 1
	    if (auth_rsa(pw, &n, &sensitive_data.random_state))
d1243 1
a1243 1
		mpz_clear(&n);
d1248 1
a1248 1
	    mpz_clear(&n);
@

