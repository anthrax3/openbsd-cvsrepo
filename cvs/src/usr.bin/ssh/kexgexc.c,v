head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.22.0.8
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.4
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.2
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.16
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.12
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.14
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.10
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.8
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.8
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.0.8
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_2:1.1.0.4
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	ZllbGwdb0fOmLhjK;

1.22
date	2015.05.26.23.23.40;	author dtucker;	state Exp;
branches;
next	1.21;
commitid	tyWYnKYZbJa3qfav;

1.21
date	2015.04.13.02.04.08;	author djm;	state Exp;
branches;
next	1.20;
commitid	UnQkGQmy0WhvW7t3;

1.20
date	2015.01.26.06.10.03;	author djm;	state Exp;
branches;
next	1.19;
commitid	F603CYAZ9E536XCr;

1.19
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.18;
commitid	U9l75XYAjMKaQ8Jp;

1.18
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.17;
commitid	UHlhoIB5NMb8eAPm;

1.17
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.25.10.12.50;	author dtucker;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.12.08.13.13;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.11.10.01.33.07;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.31.16.33.12;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.18.21.27.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.04.05.15.59;	author djm;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.12.08.11.00.47;	author markus;	state Exp;
branches
	1.2.6.1
	1.2.8.1;
next	1.1;

1.1
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1
	1.1.8.1;
next	;

1.1.2.1
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.1.4.1
date	2003.04.01.10.38.57;	author margarida;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.1.6.1
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.1.8.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	;

1.2.6.1
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.2.8.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.2.8.3;

1.2.8.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.3.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.9.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@/* $OpenBSD: kexgexc.c,v 1.22 2015/05/26 23:23:40 dtucker Exp $ */
/*
 * Copyright (c) 2000 Niels Provos.  All rights reserved.
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <openssl/dh.h>

#include <stdio.h>
#include <string.h>
#include <signal.h>

#include "sshkey.h"
#include "cipher.h"
#include "digest.h"
#include "kex.h"
#include "log.h"
#include "packet.h"
#include "dh.h"
#include "ssh2.h"
#include "compat.h"
#include "dispatch.h"
#include "ssherr.h"
#include "sshbuf.h"
#include "misc.h"

static int input_kex_dh_gex_group(int, u_int32_t, void *);
static int input_kex_dh_gex_reply(int, u_int32_t, void *);

int
kexgex_client(struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	int r;
	u_int nbits;

	nbits = dh_estimate(kex->dh_need * 8);

	kex->min = DH_GRP_MIN;
	kex->max = DH_GRP_MAX;
	kex->nbits = nbits;
	if (datafellows & SSH_BUG_DHGEX_LARGE)
		kex->nbits = MINIMUM(kex->nbits, 4096);
	/* New GEX request */
	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_REQUEST)) != 0 ||
	    (r = sshpkt_put_u32(ssh, kex->min)) != 0 ||
	    (r = sshpkt_put_u32(ssh, kex->nbits)) != 0 ||
	    (r = sshpkt_put_u32(ssh, kex->max)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		goto out;
	debug("SSH2_MSG_KEX_DH_GEX_REQUEST(%u<%u<%u) sent",
	    kex->min, kex->nbits, kex->max);
#ifdef DEBUG_KEXDH
	fprintf(stderr, "\nmin = %d, nbits = %d, max = %d\n",
	    kex->min, kex->nbits, kex->max);
#endif
	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_GROUP,
	    &input_kex_dh_gex_group);
	r = 0;
 out:
	return r;
}

static int
input_kex_dh_gex_group(int type, u_int32_t seq, void *ctxt)
{
	struct ssh *ssh = ctxt;
	struct kex *kex = ssh->kex;
	BIGNUM *p = NULL, *g = NULL;
	int r, bits;

	debug("got SSH2_MSG_KEX_DH_GEX_GROUP");

	if ((p = BN_new()) == NULL ||
	    (g = BN_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshpkt_get_bignum2(ssh, p)) != 0 ||
	    (r = sshpkt_get_bignum2(ssh, g)) != 0 ||
	    (r = sshpkt_get_end(ssh)) != 0)
		goto out;
	if ((bits = BN_num_bits(p)) < 0 ||
	    (u_int)bits < kex->min || (u_int)bits > kex->max) {
		r = SSH_ERR_DH_GEX_OUT_OF_RANGE;
		goto out;
	}
	if ((kex->dh = dh_new_group(g, p)) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	p = g = NULL; /* belong to kex->dh now */

	/* generate and send 'e', client DH public key */
	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0 ||
	    (r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_INIT)) != 0 ||
	    (r = sshpkt_put_bignum2(ssh, kex->dh->pub_key)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		goto out;
	debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
#ifdef DEBUG_KEXDH
	DHparams_print_fp(stderr, kex->dh);
	fprintf(stderr, "pub= ");
	BN_print_fp(stderr, kex->dh->pub_key);
	fprintf(stderr, "\n");
#endif
	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_GROUP, NULL);
	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_REPLY, &input_kex_dh_gex_reply);
	r = 0;
out:
	if (p)
		BN_clear_free(p);
	if (g)
		BN_clear_free(g);
	return r;
}

static int
input_kex_dh_gex_reply(int type, u_int32_t seq, void *ctxt)
{
	struct ssh *ssh = ctxt;
	struct kex *kex = ssh->kex;
	BIGNUM *dh_server_pub = NULL, *shared_secret = NULL;
	struct sshkey *server_host_key = NULL;
	u_char *kbuf = NULL, *signature = NULL, *server_host_key_blob = NULL;
	u_char hash[SSH_DIGEST_MAX_LENGTH];
	size_t klen = 0, slen, sbloblen, hashlen;
	int kout, r;

	debug("got SSH2_MSG_KEX_DH_GEX_REPLY");
	if (kex->verify_host_key == NULL) {
		r = SSH_ERR_INVALID_ARGUMENT;
		goto out;
	}
	/* key, cert */
	if ((r = sshpkt_get_string(ssh, &server_host_key_blob,
	    &sbloblen)) != 0 ||
	    (r = sshkey_from_blob(server_host_key_blob, sbloblen,
	    &server_host_key)) != 0)
		goto out;
	if (server_host_key->type != kex->hostkey_type) {
		r = SSH_ERR_KEY_TYPE_MISMATCH;
		goto out;
	}
	if (server_host_key->type != kex->hostkey_type ||
	    (kex->hostkey_type == KEY_ECDSA &&
	    server_host_key->ecdsa_nid != kex->hostkey_nid)) {
		r = SSH_ERR_KEY_TYPE_MISMATCH;
		goto out;
	}
	if (kex->verify_host_key(server_host_key, ssh) == -1) {
		r = SSH_ERR_SIGNATURE_INVALID;
		goto out;
	}
	/* DH parameter f, server public DH key */
	if ((dh_server_pub = BN_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	/* signed H */
	if ((r = sshpkt_get_bignum2(ssh, dh_server_pub)) != 0 ||
	    (r = sshpkt_get_string(ssh, &signature, &slen)) != 0 ||
	    (r = sshpkt_get_end(ssh)) != 0)
		goto out;
#ifdef DEBUG_KEXDH
	fprintf(stderr, "dh_server_pub= ");
	BN_print_fp(stderr, dh_server_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_server_pub));
#endif
	if (!dh_pub_is_valid(kex->dh, dh_server_pub)) {
		sshpkt_disconnect(ssh, "bad server public DH value");
		r = SSH_ERR_MESSAGE_INCOMPLETE;
		goto out;
	}

	klen = DH_size(kex->dh);
	if ((kbuf = malloc(klen)) == NULL ||
	    (shared_secret = BN_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((kout = DH_compute_key(kbuf, dh_server_pub, kex->dh)) < 0 ||
	    BN_bin2bn(kbuf, kout, shared_secret) == NULL) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
#ifdef DEBUG_KEXDH
	dump_digest("shared secret", kbuf, kout);
#endif
	if (ssh->compat & SSH_OLD_DHGEX)
		kex->min = kex->max = -1;

	/* calc and verify H */
	hashlen = sizeof(hash);
	if ((r = kexgex_hash(
	    kex->hash_alg,
	    kex->client_version_string,
	    kex->server_version_string,
	    sshbuf_ptr(kex->my), sshbuf_len(kex->my),
	    sshbuf_ptr(kex->peer), sshbuf_len(kex->peer),
	    server_host_key_blob, sbloblen,
	    kex->min, kex->nbits, kex->max,
	    kex->dh->p, kex->dh->g,
	    kex->dh->pub_key,
	    dh_server_pub,
	    shared_secret,
	    hash, &hashlen)) != 0)
		goto out;

	if ((r = sshkey_verify(server_host_key, signature, slen, hash,
	    hashlen, ssh->compat)) != 0)
		goto out;

	/* save session id */
	if (kex->session_id == NULL) {
		kex->session_id_len = hashlen;
		kex->session_id = malloc(kex->session_id_len);
		if (kex->session_id == NULL) {
			r = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		memcpy(kex->session_id, hash, kex->session_id_len);
	}

	if ((r = kex_derive_keys_bn(ssh, hash, hashlen, shared_secret)) == 0)
		r = kex_send_newkeys(ssh);
 out:
	explicit_bzero(hash, sizeof(hash));
	DH_free(kex->dh);
	kex->dh = NULL;
	if (dh_server_pub)
		BN_clear_free(dh_server_pub);
	if (kbuf) {
		explicit_bzero(kbuf, klen);
		free(kbuf);
	}
	if (shared_secret)
		BN_clear_free(shared_secret);
	sshkey_free(server_host_key);
	free(server_host_key_blob);
	free(signature);
	return r;
}
@


1.22
log
@Cap DH-GEX group size at 4kbits for Cisco implementations.  Some of them
will choke when asked for preferred sizes >4k instead of returning the 4k
group that they do have.  bz#2209, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.21 2015/04/13 02:04:08 djm Exp $ */
a26 1
#include <sys/param.h>
d47 1
d65 1
a65 1
		kex->nbits = MIN(kex->nbits, 4096);
@


1.21
log
@deprecate ancient, pre-RFC4419 and undocumented
SSH2_MSG_KEX_DH_GEX_REQUEST_OLD message;
ok markus@@ deraadt@@ "seems reasonable" dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.20 2015/01/26 06:10:03 djm Exp $ */
d27 1
d64 2
@


1.20
log
@correctly match ECDSA subtype (== curve) for offered/recevied
host keys. Fixes connection-killing host key mismatches when
a server offers multiple ECDSA keys with different curve type
(an extremely unlikely configuration).

ok markus, "looks mechanical" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.19 2015/01/19 20:16:15 markus Exp $ */
d63 9
a71 19
	if (ssh->compat & SSH_OLD_DHGEX) {
		/* Old GEX request */
		if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_REQUEST_OLD))
		    != 0 ||
		    (r = sshpkt_put_u32(ssh, kex->nbits)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			goto out;
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD(%u) sent", kex->nbits);
	} else {
		/* New GEX request */
		if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_REQUEST)) != 0 ||
		    (r = sshpkt_put_u32(ssh, kex->min)) != 0 ||
		    (r = sshpkt_put_u32(ssh, kex->nbits)) != 0 ||
		    (r = sshpkt_put_u32(ssh, kex->max)) != 0 ||
		    (r = sshpkt_send(ssh)) != 0)
			goto out;
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST(%u<%u<%u) sent",
		    kex->min, kex->nbits, kex->max);
	}
@


1.19
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.18 2015/01/19 19:52:16 markus Exp $ */
d171 6
@


1.18
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.17 2014/02/02 03:44:31 djm Exp $ */
d35 1
a35 3
#include "xmalloc.h"
#include "buffer.h"
#include "key.h"
d37 1
d44 3
d48 5
a52 2
void
kexgex_client(Kex *kex)
d54 3
a56 8
	BIGNUM *dh_server_pub = NULL, *shared_secret = NULL;
	BIGNUM *p = NULL, *g = NULL;
	Key *server_host_key;
	u_char *kbuf, *hash, *signature = NULL, *server_host_key_blob = NULL;
	u_int klen, slen, sbloblen, hashlen;
	int kout;
	int min, max, nbits;
	DH *dh;
d60 4
a63 1
	if (datafellows & SSH_OLD_DHGEX) {
d65 6
a70 6
		packet_start(SSH2_MSG_KEX_DH_GEX_REQUEST_OLD);
		packet_put_int(nbits);
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;

		debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD(%u) sent", nbits);
d73 6
a78 7
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;
		packet_start(SSH2_MSG_KEX_DH_GEX_REQUEST);
		packet_put_int(min);
		packet_put_int(nbits);
		packet_put_int(max);

d80 1
a80 1
		    min, nbits, max);
d84 1
a84 1
	    min, nbits, max);
d86 6
a91 1
	packet_send();
d93 7
a99 2
	debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_GROUP);
d101 1
a101 11
	if ((p = BN_new()) == NULL)
		fatal("BN_new");
	packet_get_bignum2(p);
	if ((g = BN_new()) == NULL)
		fatal("BN_new");
	packet_get_bignum2(g);
	packet_check_eom();

	if (BN_num_bits(p) < min || BN_num_bits(p) > max)
		fatal("DH_GEX group out of range: %d !< %d !< %d",
		    min, BN_num_bits(p), max);
d103 19
a121 2
	dh = dh_new_group(g, p);
	dh_gen_key(dh, kex->we_need * 8);
d123 7
d131 1
a131 1
	DHparams_print_fp(stderr, dh);
d133 1
a133 1
	BN_print_fp(stderr, dh->pub_key);
d136 10
d147 17
a163 9
	debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
	/* generate and send 'e', client DH public key */
	packet_start(SSH2_MSG_KEX_DH_GEX_INIT);
	packet_put_bignum2(dh->pub_key);
	packet_send();

	debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_REPLY);

d165 13
a177 11
	server_host_key_blob = packet_get_string(&sbloblen);
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
	if (server_host_key == NULL)
		fatal("cannot decode server_host_key_blob");
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
	if (kex->verify_host_key == NULL)
		fatal("cannot verify server_host_key");
	if (kex->verify_host_key(server_host_key) == -1)
		fatal("server_host_key verification failed");

d179 9
a187 4
	if ((dh_server_pub = BN_new()) == NULL)
		fatal("dh_server_pub == NULL");
	packet_get_bignum2(dh_server_pub);

d194 5
d200 11
a210 11
	/* signed H */
	signature = packet_get_string(&slen);
	packet_check_eom();

	if (!dh_pub_is_valid(dh, dh_server_pub))
		packet_disconnect("bad server public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	if ((kout = DH_compute_key(kbuf, dh_server_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d214 2
a215 9
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_client: BN_new failed");
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexgex_client: BN_bin2bn failed");
	explicit_bzero(kbuf, klen);
	free(kbuf);

	if (datafellows & SSH_OLD_DHGEX)
		min = max = -1;
d218 2
a219 1
	kexgex_hash(
d223 2
a224 2
	    buffer_ptr(kex->my), buffer_len(kex->my),
	    buffer_ptr(kex->peer), buffer_len(kex->peer),
d226 3
a228 3
	    min, nbits, max,
	    dh->p, dh->g,
	    dh->pub_key,
d231 2
a232 2
	    &hash, &hashlen
	);
d234 3
a236 9
	/* have keys, free DH */
	DH_free(dh);
	free(server_host_key_blob);
	BN_clear_free(dh_server_pub);

	if (key_verify(server_host_key, signature, slen, hash, hashlen) != 1)
		fatal("key_verify failed for server_host_key");
	key_free(server_host_key);
	free(signature);
d241 5
a245 1
		kex->session_id = xmalloc(kex->session_id_len);
a247 2
	kex_derive_keys_bn(kex, hash, hashlen, shared_secret);
	BN_clear_free(shared_secret);
d249 18
a266 1
	kex_finish(kex);
@


1.17
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.16 2014/01/25 10:12:50 dtucker Exp $ */
d173 2
a174 2
	    buffer_ptr(&kex->my), buffer_len(&kex->my),
	    buffer_ptr(&kex->peer), buffer_len(&kex->peer),
@


1.16
log
@Add a special case for the DH group size for 3des-cbc, which has an
effective strength much lower than the key size.  This causes problems
with some cryptlib implementations, which don't support group sizes larger
than 4k but also don't use the largest group size it does support as
specified in the RFC.  Based on a patch from Petr Lautrbach at Redhat,
reduced by me with input from Markus.  ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.15 2014/01/12 08:13:13 djm Exp $ */
d162 1
a162 1
	memset(kbuf, 0, klen);
@


1.15
log
@avoid use of OpenSSL BIGNUM type and functions for KEX with
Curve25519 by adding a buffer_put_bignum2_from_string() that stores
a string using the bignum encoding rules. Will make it easier to
build a reduced-feature OpenSSH without OpenSSL in the future;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.14 2014/01/09 23:20:00 djm Exp $ */
d58 1
a58 1
	nbits = dh_estimate(kex->we_need * 8);
@


1.14
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.13 2013/05/17 00:13:13 djm Exp $ */
d200 1
a200 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.13
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.12 2010/11/10 01:33:07 djm Exp $ */
d170 1
a170 1
	    kex->evp_md,
@


1.12
log
@use only libcrypto APIs that are retained with OPENSSL_NO_DEPRECATED.
these have been around for years by this time. ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.11 2006/11/06 21:25:28 markus Exp $ */
d163 1
a163 1
	xfree(kbuf);
d186 1
a186 1
	xfree(server_host_key_blob);
d192 1
a192 1
	xfree(signature);
@


1.11
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.10 2006/10/31 16:33:12 markus Exp $ */
d28 2
@


1.10
log
@check DH_compute_key() for -1 even if it should not happen because of
earlier calls to dh_pub_is_valid(); report krahmer at suse.de; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.9 2006/08/03 03:34:42 deraadt Exp $ */
d158 2
a159 1
	BN_bin2bn(kbuf, kout, shared_secret);
@


1.9
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.8 2006/08/01 23:22:47 stevesk Exp $ */
d51 2
a52 1
	u_int klen, kout, slen, sbloblen, hashlen;
d151 2
a152 1
	kout = DH_compute_key(kbuf, dh_server_pub, dh);
@


1.9.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.11 2006/11/06 21:25:28 markus Exp $ */
d51 1
a51 2
	u_int klen, slen, sbloblen, hashlen;
	int kout;
d150 1
a150 2
	if ((kout = DH_compute_key(kbuf, dh_server_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d156 1
a156 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexgex_client: BN_bin2bn failed");
@


1.8
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.7 2006/07/22 20:48:23 stevesk Exp $ */
d27 1
a27 1
#include "includes.h"
d31 1
d34 1
d36 1
@


1.7
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.6 2006/05/18 21:27:25 miod Exp $ */
d29 1
@


1.6
log
@paramter -> parameter
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.5 2006/03/25 13:17:02 djm Exp $ */
d28 2
@


1.5
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d123 1
a123 1
	/* DH paramter f, server public DH key */
@


1.4
log
@RCSID() can die
@
text
@d1 1
@


1.3
log
@remove hardcoded hash lengths in key exchange code, allowing
implementation of KEX methods with different hashes (e.g. SHA-256);
ok markus@@ dtucker@@ stevesk@@
@
text
@a26 1
RCSID("$OpenBSD: kexgexc.c,v 1.2 2003/12/08 11:00:47 markus Exp $");
@


1.3.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexgexc.c,v 1.9 2006/08/03 03:34:42 deraadt Exp $ */
d26 2
a27 5
#include <sys/types.h>

#include <stdio.h>
#include <string.h>
#include <signal.h>
a29 1
#include "buffer.h"
a30 1
#include "cipher.h"
d123 1
a123 1
	/* DH parameter f, server public DH key */
@


1.3.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.11 2006/11/06 21:25:28 markus Exp $ */
d51 1
a51 2
	u_int klen, slen, sbloblen, hashlen;
	int kout;
d150 1
a150 2
	if ((kout = DH_compute_key(kbuf, dh_server_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d156 1
a156 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexgex_client: BN_bin2bn failed");
@


1.2
log
@print requested group size in debug; ok djm
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexc.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
d45 1
a45 1
	u_int klen, kout, slen, sbloblen;
d158 2
a159 1
	hash = kexgex_hash(
d169 2
a170 1
	    shared_secret
d172 1
d178 1
a178 1
	if (key_verify(server_host_key, signature, slen, hash, 20) != 1)
d185 1
a185 1
		kex->session_id_len = 20;
d189 1
a189 1
	kex_derive_keys(kex, hash, shared_secret);
@


1.2.8.1
log
@upgrade to OpenSSH 4.3
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexc.c,v 1.3 2005/11/04 05:15:59 djm Exp $");
d45 1
a45 1
	u_int klen, kout, slen, sbloblen, hashlen;
d158 1
a158 2
	kexgex_hash(
	    kex->evp_md,
d168 1
a168 2
	    shared_secret,
	    &hash, &hashlen
a169 1

d175 1
a175 1
	if (key_verify(server_host_key, signature, slen, hash, hashlen) != 1)
d182 1
a182 1
		kex->session_id_len = hashlen;
d186 1
a186 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.2.8.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexgexc.c,v 1.9 2006/08/03 03:34:42 deraadt Exp $ */
d26 2
a27 5
#include <sys/types.h>

#include <stdio.h>
#include <string.h>
#include <signal.h>
a29 1
#include "buffer.h"
a30 1
#include "cipher.h"
d123 1
a123 1
	/* DH parameter f, server public DH key */
@


1.2.8.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexgexc.c,v 1.11 2006/11/06 21:25:28 markus Exp $ */
d51 1
a51 2
	u_int klen, slen, sbloblen, hashlen;
	int kout;
d150 1
a150 2
	if ((kout = DH_compute_key(kbuf, dh_server_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d156 1
a156 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexgex_client: BN_bin2bn failed");
@


1.2.6.1
log
@upgrade to OpenSSH 4.3
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexc.c,v 1.3 2005/11/04 05:15:59 djm Exp $");
d45 1
a45 1
	u_int klen, kout, slen, sbloblen, hashlen;
d158 1
a158 2
	kexgex_hash(
	    kex->evp_md,
d168 1
a168 2
	    shared_secret,
	    &hash, &hashlen
a169 1

d175 1
a175 1
	if (key_verify(server_host_key, signature, slen, hash, hashlen) != 1)
d182 1
a182 1
		kex->session_id_len = hashlen;
d186 1
a186 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.1
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.22 2002/03/24 17:27:03 stevesk Exp $");
a51 2
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD sent");

d57 2
a59 2
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST sent");

d67 3
@


1.1.2.1
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexc.c,v 1.2 2003/12/08 11:00:47 markus Exp $");
d52 2
d59 2
a61 2
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD(%u) sent", nbits);
	} else {
a68 3

		debug("SSH2_MSG_KEX_DH_GEX_REQUEST(%u<%u<%u) sent",
		    min, nbits, max);
@


1.1.8.1
log
@upgrade to OpenSSH 3.8
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexc.c,v 1.2 2003/12/08 11:00:47 markus Exp $");
d52 2
d59 2
a61 2
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD(%u) sent", nbits);
	} else {
a68 3

		debug("SSH2_MSG_KEX_DH_GEX_REQUEST(%u<%u<%u) sent",
		    min, nbits, max);
@


1.1.6.1
log
@Merge OpenSSH 3.6.1
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexc.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
@


1.1.4.1
log
@These were missed on the update to the last openssh.

Thanks to all who pointed it out.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgexc.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
@


1.1.4.2
log
@upgrade to OpenSSH 3.7
@
text
@@


