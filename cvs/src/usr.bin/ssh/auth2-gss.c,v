head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.10
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.6
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.14
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.12
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.8
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.22
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.21;
commitid	GrtSC5ve2VERgUln;

1.21
date	2014.02.26.20.28.44;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.05.00.14.00;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2012.12.02.20.34.09;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.10.02.52.57;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.29.00.52.45;	author dtucker;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.25.22.22.42;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.20.04.07.22;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.13.22.24.31;	author stevesk;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2005.10.13.14.03.01;	author stevesk;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.17.07.17.54;	author djm;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches
	1.8.2.1
	1.8.4.1;
next	1.7;

1.7
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2003.11.17.11.06.07;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.02.11.01.03;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.21.09.50.06;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.01.20.44.54;	author markus;	state Exp;
branches
	1.3.2.1
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2003.08.24.17.36.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.22.10.56.08;	author markus;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.3.4.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.3.6.1
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.7.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.8.2.1
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.8.4.1
date	2005.09.04.18.39.58;	author brad;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.10.2.1
date	2006.02.03.03.01.55;	author brad;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.12.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.22
log
@move dispatch to struct ssh; ok djm@@
@
text
@/* $OpenBSD: auth2-gss.c,v 1.21 2014/02/26 20:28:44 djm Exp $ */

/*
 * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef GSSAPI

#include <sys/types.h>

#include "xmalloc.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "ssh2.h"
#include "log.h"
#include "dispatch.h"
#include "buffer.h"
#include "servconf.h"
#include "packet.h"
#include "ssh-gss.h"
#include "monitor_wrap.h"

extern ServerOptions options;

static int input_gssapi_token(int type, u_int32_t plen, void *ctxt);
static int input_gssapi_mic(int type, u_int32_t plen, void *ctxt);
static int input_gssapi_exchange_complete(int type, u_int32_t plen, void *ctxt);
static int input_gssapi_errtok(int, u_int32_t, void *);

/*
 * We only support those mechanisms that we know about (ie ones that we know
 * how to check local user kuserok and the like)
 */
static int
userauth_gssapi(Authctxt *authctxt)
{
	gss_OID_desc goid = {0, NULL};
	Gssctxt *ctxt = NULL;
	int mechs;
	int present;
	OM_uint32 ms;
	u_int len;
	u_char *doid = NULL;

	if (!authctxt->valid || authctxt->user == NULL)
		return (0);

	mechs = packet_get_int();
	if (mechs == 0) {
		debug("Mechanism negotiation is not supported");
		return (0);
	}

	do {
		mechs--;

		free(doid);

		present = 0;
		doid = packet_get_string(&len);

		if (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&
		    doid[1] == len - 2) {
			goid.elements = doid + 2;
			goid.length   = len - 2;
			ssh_gssapi_test_oid_supported(&ms, &goid, &present);
		} else {
			logit("Badly formed OID received");
		}
	} while (mechs > 0 && !present);

	if (!present) {
		free(doid);
		authctxt->server_caused_failure = 1;
		return (0);
	}

	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
		if (ctxt != NULL)
			ssh_gssapi_delete_ctx(&ctxt);
		free(doid);
		authctxt->server_caused_failure = 1;
		return (0);
	}

	authctxt->methoddata = (void *)ctxt;

	packet_start(SSH2_MSG_USERAUTH_GSSAPI_RESPONSE);

	/* Return the OID that we received */
	packet_put_string(doid, len);

	packet_send();
	free(doid);

	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);
	authctxt->postponed = 1;

	return (0);
}

static int
input_gssapi_token(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc recv_tok;
	OM_uint32 maj_status, min_status, flags;
	u_int len;

	if (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))
		fatal("No authentication or GSSAPI context");

	gssctxt = authctxt->methoddata;
	recv_tok.value = packet_get_string(&len);
	recv_tok.length = len; /* u_int vs. size_t */

	packet_check_eom();

	maj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,
	    &send_tok, &flags));

	free(recv_tok.value);

	if (GSS_ERROR(maj_status)) {
		if (send_tok.length != 0) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK);
			packet_put_string(send_tok.value, send_tok.length);
			packet_send();
		}
		authctxt->postponed = 0;
		dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
		userauth_finish(authctxt, 0, "gssapi-with-mic", NULL);
	} else {
		if (send_tok.length != 0) {
			packet_start(SSH2_MSG_USERAUTH_GSSAPI_TOKEN);
			packet_put_string(send_tok.value, send_tok.length);
			packet_send();
		}
		if (maj_status == GSS_S_COMPLETE) {
			dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
			if (flags & GSS_C_INTEG_FLAG)
				dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC,
				    &input_gssapi_mic);
			else
				dispatch_set(
				    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,
				    &input_gssapi_exchange_complete);
		}
	}

	gss_release_buffer(&min_status, &send_tok);
	return 0;
}

static int
input_gssapi_errtok(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
	gss_buffer_desc recv_tok;
	OM_uint32 maj_status;
	u_int len;

	if (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))
		fatal("No authentication or GSSAPI context");

	gssctxt = authctxt->methoddata;
	recv_tok.value = packet_get_string(&len);
	recv_tok.length = len;

	packet_check_eom();

	/* Push the error token into GSSAPI to see what it says */
	maj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,
	    &send_tok, NULL));

	free(recv_tok.value);

	/* We can't return anything to the client, even if we wanted to */
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);

	/* The client will have already moved on to the next auth */

	gss_release_buffer(&maj_status, &send_tok);
	return 0;
}

/*
 * This is called when the client thinks we've completed authentication.
 * It should only be enabled in the dispatch handler by the function above,
 * which only enables it once the GSSAPI exchange is complete.
 */

static int
input_gssapi_exchange_complete(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	int authenticated;

	if (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))
		fatal("No authentication or GSSAPI context");

	/*
	 * We don't need to check the status, because we're only enabled in
	 * the dispatcher once the exchange is complete
	 */

	packet_check_eom();

	authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));

	authctxt->postponed = 0;
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
	userauth_finish(authctxt, authenticated, "gssapi-with-mic", NULL);
	return 0;
}

static int
input_gssapi_mic(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	int authenticated = 0;
	Buffer b;
	gss_buffer_desc mic, gssbuf;
	u_int len;

	if (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))
		fatal("No authentication or GSSAPI context");

	gssctxt = authctxt->methoddata;

	mic.value = packet_get_string(&len);
	mic.length = len;

	ssh_gssapi_buildmic(&b, authctxt->user, authctxt->service,
	    "gssapi-with-mic");

	gssbuf.value = buffer_ptr(&b);
	gssbuf.length = buffer_len(&b);

	if (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))))
		authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));
	else
		logit("GSSAPI MIC check failed");

	buffer_free(&b);
	free(mic.value);

	authctxt->postponed = 0;
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
	userauth_finish(authctxt, authenticated, "gssapi-with-mic", NULL);
	return 0;
}

Authmethod method_gssapi = {
	"gssapi-with-mic",
	userauth_gssapi,
	&options.gss_authentication
};
#endif
@


1.21
log
@bz#2107 - cache OIDs of supported GSSAPI mechanisms before privsep
sandboxing, as running this code in the sandbox can cause violations;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.20 2013/05/17 00:13:13 djm Exp $ */
d46 4
a49 4
static void input_gssapi_token(int type, u_int32_t plen, void *ctxt);
static void input_gssapi_mic(int type, u_int32_t plen, void *ctxt);
static void input_gssapi_exchange_complete(int type, u_int32_t plen, void *ctxt);
static void input_gssapi_errtok(int, u_int32_t, void *);
d124 1
a124 1
static void
d176 1
d179 1
a179 1
static void
d211 1
d220 1
a220 1
static void
d244 1
d247 1
a247 1
static void
d285 1
@


1.20
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.19 2013/04/05 00:14:00 djm Exp $ */
a60 1
	gss_OID_set supported;
a74 1
	ssh_gssapi_supported_oids(&supported);
d87 1
a87 2
			gss_test_oid_set_member(&ms, &goid, supported,
			    &present);
a91 2

	gss_release_oid_set(&ms, &supported);
@


1.19
log
@hush some {unused, printf type} warnings
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.18 2012/12/02 20:34:09 djm Exp $ */
d80 1
a80 2
		if (doid)
			xfree(doid);
d99 1
a99 1
		xfree(doid);
d107 1
a107 1
		xfree(doid);
d120 1
a120 1
	xfree(doid);
d151 1
a151 1
	xfree(recv_tok.value);
d206 1
a206 1
	xfree(recv_tok.value);
d279 1
a279 1
	xfree(mic.value);
@


1.18
log
@Fixes logging of partial authentication when privsep is enabled
Previously, we recorded "Failed xxx" since we reset authenticated before
calling auth_log() in auth2.c. This adds an explcit "Partial" state.

Add a "submethod" to auth_log() to report which submethod is used
for keyboard-interactive.

Fix multiple authentication when one of the methods is
keyboard-interactive.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.17 2011/03/10 02:52:57 djm Exp $ */
a227 1
	Gssctxt *gssctxt;
a231 2

	gssctxt = authctxt->methoddata;
@


1.17
log
@allow GSSAPI authentication to detect when a server-side failure causes
authentication failure and don't count such failures against MaxAuthTries;
bz#1244 from simon AT sxw.org.uk; ok markus@@ before lock
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.16 2007/10/29 00:52:45 dtucker Exp $ */
d162 1
a162 1
		userauth_finish(authctxt, 0, "gssapi-with-mic");
d250 1
a250 1
	userauth_finish(authctxt, authenticated, "gssapi-with-mic");
d290 1
a290 1
	userauth_finish(authctxt, authenticated, "gssapi-with-mic");
@


1.16
log
@Allow build without -DGSSAPI; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.15 2006/08/03 03:34:41 deraadt Exp $ */
d101 1
d109 1
@


1.15
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.14 2006/03/25 22:22:42 djm Exp $ */
d27 2
d296 1
@


1.14
log
@standardise spacing in $OpenBSD$ tags; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.13 2006/03/20 04:07:22 djm Exp $ */
d27 1
a27 3
#include "includes.h"

#ifdef GSSAPI
d29 3
a33 1
#include "xmalloc.h"
d36 1
d39 1
a41 2
#include "ssh-gss.h"

a293 2

#endif /* GSSAPI */
@


1.13
log
@GSSAPI related leaks detected by Coverity via elad AT netbsd.org;
reviewed by simon AT sxw.org.uk; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.12 2005/10/13 22:24:31 stevesk Exp $	*/
@


1.12
log
@KNF; ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.11 2005/10/13 14:03:01 stevesk Exp $	*/
d103 2
@


1.12.2.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.15 2006/08/03 03:34:41 deraadt Exp $ */
d27 3
a29 1
#include <sys/types.h>
a30 3
#include "xmalloc.h"
#include "key.h"
#include "hostfile.h"
d33 1
a35 1
#include "buffer.h"
d38 2
a40 1
#include "monitor_wrap.h"
a102 2
		if (ctxt != NULL)
			ssh_gssapi_delete_ctx(&ctxt);
d292 2
@


1.11
log
@remove unneeded #includes; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.10 2005/07/17 07:17:54 djm Exp $	*/
d51 1
a51 1
 * how to check local user kuserok and the like
d107 1
a107 1
	authctxt->methoddata=(void *)ctxt;
@


1.10
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.9 2005/06/17 02:44:32 djm Exp $	*/
a36 1
#include "compat.h"
@


1.10.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.12 2005/10/13 22:24:31 stevesk Exp $	*/
d37 1
d52 1
a52 1
 * how to check local user kuserok and the like)
d108 1
a108 1
	authctxt->methoddata = (void *)ctxt;
@


1.10.2.2
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-gss.c,v 1.15 2006/08/03 03:34:41 deraadt Exp $ */
d27 3
a29 1
#include <sys/types.h>
a30 3
#include "xmalloc.h"
#include "key.h"
#include "hostfile.h"
d33 1
a35 1
#include "buffer.h"
d38 2
a40 1
#include "monitor_wrap.h"
a102 2
		if (ctxt != NULL)
			ssh_gssapi_delete_ctx(&ctxt);
d292 2
@


1.9
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.8 2004/06/21 17:36:31 avsm Exp $	*/
d85 2
a86 3
		if (len > 2 &&
		   doid[0] == SSH_GSS_OIDTYPE &&
		   doid[1] == len - 2) {
@


1.8
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.7 2003/11/21 11:57:03 djm Exp $	*/
d64 1
a64 1
	char *doid = NULL;
@


1.8.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.10 2005/07/17 07:17:54 djm Exp $	*/
d64 1
a64 1
	u_char *doid = NULL;
d85 3
a87 2
		if (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&
		    doid[1] == len - 2) {
@


1.8.4.2
log
@upgrade to OpenSSH 4.3
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.12 2005/10/13 22:24:31 stevesk Exp $	*/
d37 1
d52 1
a52 1
 * how to check local user kuserok and the like)
d108 1
a108 1
	authctxt->methoddata = (void *)ctxt;
@


1.8.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.10 2005/07/17 07:17:54 djm Exp $	*/
d64 1
a64 1
	u_char *doid = NULL;
d85 3
a87 2
		if (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&
		    doid[1] == len - 2) {
@


1.7
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.6 2003/11/17 11:06:07 markus Exp $	*/
d57 1
a57 1
	gss_OID_desc oid = {0, NULL};
d88 3
a90 3
			oid.elements = doid + 2;
			oid.length   = len - 2;
			gss_test_oid_set_member(&ms, &oid, supported,
d104 1
a104 1
	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &oid)))) {
@


1.7.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.8 2004/06/21 17:36:31 avsm Exp $	*/
d57 1
a57 1
	gss_OID_desc goid = {0, NULL};
d88 3
a90 3
			goid.elements = doid + 2;
			goid.length   = len - 2;
			gss_test_oid_set_member(&ms, &goid, supported,
d104 1
a104 1
	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
@


1.6
log
@replace "gssapi" with "gssapi-with-mic"; from Simon Wilkinson; test + ok jakob.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.5 2003/11/02 11:01:03 markus Exp $	*/
d85 1
a85 1
		if (len > 2 && 
d88 2
a89 2
                        oid.elements = doid + 2;
                        oid.length   = len - 2;
d258 1
a258 1
	
d261 1
a261 1
	
d263 1
a263 1
	
d266 1
a266 1
	
d269 1
a269 1
	
d272 1
a272 1
	
d280 1
a280 1
	
@


1.5
log
@remove support for SSH_BUG_GSSAPI_BER; simon@@sxw.org.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.4 2003/10/21 09:50:06 markus Exp $	*/
d46 1
d133 1
a133 1
	OM_uint32 maj_status, min_status;
d146 1
a146 1
	    &send_tok, NULL));
d158 1
a158 1
		userauth_finish(authctxt, 0, "gssapi");
d167 7
a173 2
			dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,
				     &input_gssapi_exchange_complete);
d233 2
a234 3
	 * We don't need to check the status, because the stored credentials
	 * which userok uses are only populated once the context init step
	 * has returned complete.
d244 41
d286 1
a286 1
	userauth_finish(authctxt, authenticated, "gssapi");
d290 1
a290 1
	"gssapi",
@


1.4
log
@make sure the doid is larger than 2
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.3 2003/09/01 20:44:54 markus Exp $	*/
d81 1
a82 2
		if (len <= 2)
			packet_disconnect("Short OID received");
d84 7
a90 4
		if (doid[0] != SSH_GSS_OIDTYPE || doid[1] != len-2) {
			logit("Mechanism OID received using the old encoding form");
			oid.elements = doid;
			oid.length = len;
d92 1
a92 2
			oid.elements = doid + 2;
			oid.length   = len - 2;
a93 1
		gss_test_oid_set_member(&ms, &oid, supported, &present);
d112 1
a112 1
	/* Return OID in same format as we received it*/
@


1.3
log
@fix leak
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.2 2003/08/24 17:36:51 deraadt Exp $	*/
d82 2
@


1.3.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.7 2003/11/21 11:57:03 djm Exp $	*/
a45 1
static void input_gssapi_mic(int type, u_int32_t plen, void *ctxt);
a80 1
		present = 0;
d83 5
a87 3
		if (len > 2 &&
		   doid[0] == SSH_GSS_OIDTYPE &&
		   doid[1] == len - 2) {
a89 4
			gss_test_oid_set_member(&ms, &oid, supported,
			    &present);
		} else {
			logit("Badly formed OID received");
d91 1
d110 1
a110 1
	/* Return the OID that we received */
d130 1
a130 1
	OM_uint32 maj_status, min_status, flags;
d143 1
a143 1
	    &send_tok, &flags));
d155 1
a155 1
		userauth_finish(authctxt, 0, "gssapi-with-mic");
d164 2
a165 7
			if (flags & GSS_C_INTEG_FLAG)
				dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC,
				    &input_gssapi_mic);
			else
				dispatch_set(
				    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,
				    &input_gssapi_exchange_complete);
d225 3
a227 2
	 * We don't need to check the status, because we're only enabled in
	 * the dispatcher once the exchange is complete
a236 41
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
	userauth_finish(authctxt, authenticated, "gssapi-with-mic");
}

static void
input_gssapi_mic(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	int authenticated = 0;
	Buffer b;
	gss_buffer_desc mic, gssbuf;
	u_int len;

	if (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))
		fatal("No authentication or GSSAPI context");

	gssctxt = authctxt->methoddata;

	mic.value = packet_get_string(&len);
	mic.length = len;

	ssh_gssapi_buildmic(&b, authctxt->user, authctxt->service,
	    "gssapi-with-mic");

	gssbuf.value = buffer_ptr(&b);
	gssbuf.length = buffer_len(&b);

	if (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))))
		authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));
	else
		logit("GSSAPI MIC check failed");

	buffer_free(&b);
	xfree(mic.value);

	authctxt->postponed = 0;
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);
d238 1
a238 1
	userauth_finish(authctxt, authenticated, "gssapi-with-mic");
d242 1
a242 1
	"gssapi-with-mic",
@


1.3.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.8 2004/06/21 17:36:31 avsm Exp $	*/
d57 1
a57 1
	gss_OID_desc goid = {0, NULL};
d88 3
a90 3
			goid.elements = doid + 2;
			goid.length   = len - 2;
			gss_test_oid_set_member(&ms, &goid, supported,
d104 1
a104 1
	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
@


1.3.6.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.3 2003/09/01 20:44:54 markus Exp $	*/
@


1.3.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.3 2003/09/01 20:44:54 markus Exp $	*/
@


1.3.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.7 2003/11/21 11:57:03 djm Exp $	*/
a45 1
static void input_gssapi_mic(int type, u_int32_t plen, void *ctxt);
a80 1
		present = 0;
d83 5
a87 3
		if (len > 2 &&
		   doid[0] == SSH_GSS_OIDTYPE &&
		   doid[1] == len - 2) {
a89 4
			gss_test_oid_set_member(&ms, &oid, supported,
			    &present);
		} else {
			logit("Badly formed OID received");
d91 1
d110 1
a110 1
	/* Return the OID that we received */
d130 1
a130 1
	OM_uint32 maj_status, min_status, flags;
d143 1
a143 1
	    &send_tok, &flags));
d155 1
a155 1
		userauth_finish(authctxt, 0, "gssapi-with-mic");
d164 2
a165 7
			if (flags & GSS_C_INTEG_FLAG)
				dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC,
				    &input_gssapi_mic);
			else
				dispatch_set(
				    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,
				    &input_gssapi_exchange_complete);
d225 3
a227 2
	 * We don't need to check the status, because we're only enabled in
	 * the dispatcher once the exchange is complete
a236 41
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
	userauth_finish(authctxt, authenticated, "gssapi-with-mic");
}

static void
input_gssapi_mic(int type, u_int32_t plen, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Gssctxt *gssctxt;
	int authenticated = 0;
	Buffer b;
	gss_buffer_desc mic, gssbuf;
	u_int len;

	if (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))
		fatal("No authentication or GSSAPI context");

	gssctxt = authctxt->methoddata;

	mic.value = packet_get_string(&len);
	mic.length = len;

	ssh_gssapi_buildmic(&b, authctxt->user, authctxt->service,
	    "gssapi-with-mic");

	gssbuf.value = buffer_ptr(&b);
	gssbuf.length = buffer_len(&b);

	if (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))))
		authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));
	else
		logit("GSSAPI MIC check failed");

	buffer_free(&b);
	xfree(mic.value);

	authctxt->postponed = 0;
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);
d238 1
a238 1
	userauth_finish(authctxt, authenticated, "gssapi-with-mic");
d242 1
a242 1
	"gssapi-with-mic",
@


1.2
log
@64 bit cleanups; markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: auth2-gss.c,v 1.1 2003/08/22 10:56:08 markus Exp $	*/
d101 2
a102 1
	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &oid))))
d104 1
@


1.1
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d178 1
d184 2
a185 1
	recv_tok.value = packet_get_string(&recv_tok.length);
@

