head	1.86;
access;
symbols
	OPENBSD_6_1:1.83.0.8
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.83.0.6
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.81.0.2
	OPENBSD_5_8_BASE:1.81
	OPENBSD_5_7:1.79.0.16
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.79.0.20
	OPENBSD_5_6_BASE:1.79
	OPENBSD_5_5:1.79.0.18
	OPENBSD_5_5_BASE:1.79
	OPENBSD_5_4:1.79.0.14
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.79.0.12
	OPENBSD_5_3_BASE:1.79
	OPENBSD_5_2:1.79.0.10
	OPENBSD_5_2_BASE:1.79
	OPENBSD_5_1_BASE:1.79
	OPENBSD_5_1:1.79.0.8
	OPENBSD_5_0:1.79.0.6
	OPENBSD_5_0_BASE:1.79
	OPENBSD_4_9:1.79.0.4
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.79.0.2
	OPENBSD_4_8_BASE:1.79
	OPENBSD_4_7:1.78.0.14
	OPENBSD_4_7_BASE:1.78
	OPENBSD_4_6:1.78.0.16
	OPENBSD_4_6_BASE:1.78
	OPENBSD_4_5:1.78.0.12
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.78.0.10
	OPENBSD_4_4_BASE:1.78
	OPENBSD_4_3:1.78.0.8
	OPENBSD_4_3_BASE:1.78
	OPENBSD_4_2:1.78.0.6
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.78.0.2
	OPENBSD_4_1_BASE:1.78
	OPENBSD_4_0:1.78.0.4
	OPENBSD_4_0_BASE:1.78
	OPENBSD_3_9:1.76.0.6
	OPENBSD_3_9_BASE:1.76
	OPENBSD_3_8:1.76.0.4
	OPENBSD_3_8_BASE:1.76
	OPENBSD_3_7:1.76.0.2
	OPENBSD_3_7_BASE:1.76
	OPENBSD_3_6:1.75.0.4
	OPENBSD_3_6_BASE:1.75
	OPENBSD_3_5:1.75.0.2
	OPENBSD_3_5_BASE:1.75
	OPENBSD_3_4:1.74.0.2
	OPENBSD_3_4_BASE:1.74
	OPENBSD_3_3:1.71.0.4
	OPENBSD_3_3_BASE:1.71
	OPENBSD_3_2:1.71.0.2
	OPENBSD_3_2_BASE:1.71
	OPENBSD_3_1:1.66.0.2
	OPENBSD_3_1_BASE:1.66
	OPENBSD_3_0:1.63.0.2
	OPENBSD_3_0_BASE:1.63
	OPENBSD_2_9_BASE:1.62
	OPENBSD_2_9:1.62.0.2
	OPENBSD_2_8:1.54.0.2
	OPENBSD_2_8_BASE:1.54
	OPENBSD_2_7:1.45.0.2
	OPENBSD_2_7_BASE:1.45
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13;
locks; strict;
comment	@ * @;


1.86
date	2017.05.03.21.08.09;	author naddy;	state Exp;
branches;
next	1.85;
commitid	wlKSvaBqtNpb5VOS;

1.85
date	2017.04.30.23.28.12;	author djm;	state Exp;
branches;
next	1.84;
commitid	j8T9GfcAdHo0Finy;

1.84
date	2017.04.30.23.18.44;	author djm;	state Exp;
branches;
next	1.83;
commitid	NPnVhZTcf5ddO7Ys;

1.83
date	2015.12.11.03.19.09;	author djm;	state Exp;
branches;
next	1.82;
commitid	2E8Vrkc7F6a99V57;

1.82
date	2015.09.24.06.15.11;	author djm;	state Exp;
branches;
next	1.81;
commitid	nGLvQjqT3Z8tECCC;

1.81
date	2015.08.04.05.23.06;	author djm;	state Exp;
branches;
next	1.80;
commitid	J7ksbUfI55hZsQJA;

1.80
date	2015.07.03.03.49.45;	author djm;	state Exp;
branches;
next	1.79;
commitid	XxrOOTFUKuLzoQb7;

1.79
date	2010.06.25.07.14.46;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.25.22.22.43;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2004.12.06.11.41.03;	author dtucker;	state Exp;
branches
	1.76.4.1
	1.76.6.1;
next	1.75;

1.75
date	2003.12.02.17.01.15;	author markus;	state Exp;
branches
	1.75.2.1
	1.75.4.1;
next	1.74;

1.74
date	2003.09.01.13.52.18;	author markus;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.22.02.00.29;	author stevesk;	state Exp;
branches
	1.71.2.1
	1.71.4.1;
next	1.70;

1.70
date	2002.06.03.12.04.07;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.11.20.24.48;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2002.05.08.21.06.34;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.07.19.54.36;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.29.19.18.33;	author stevesk;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2002.03.20.19.12.25;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches;
next	1.63;

1.63
date	2001.05.24.18.57.53;	author stevesk;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2001.01.23.10.45.10;	author markus;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2001.01.21.19.05.59;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2001.01.19.12.45.27;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.01.18.16.20.22;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.01.07.11.28.06;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2000.11.25.17.19.33;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2000.10.11.20.27.24;	author markus;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2000.10.11.20.14.39;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2000.10.11.04.02.17;	author provos;	state Exp;
branches;
next	1.51;

1.51
date	2000.09.12.20.53.10;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2000.09.07.20.27.54;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2000.08.19.18.48.11;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2000.07.13.22.53.21;	author provos;	state Exp;
branches;
next	1.47;

1.47
date	2000.06.20.01.39.45;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2000.05.17.08.20.15;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2000.05.08.17.12.16;	author markus;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2000.05.04.22.38.00;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2000.05.03.10.21.48;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2000.05.02.22.18.04;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2000.04.26.22.38.16;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.26.20.56.30;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.19.07.05.49;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.12.07.45.44;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.06.08.55.22;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.28.20.31.29;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.03.23.22.15.33;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.01.22.32.53;	author d;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.04.00.08.00;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	99.12.12.19.20.03;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	99.12.06.20.15.29;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	99.12.02.20.05.40;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	99.12.01.16.54.35;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	99.12.01.13.59.15;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	99.11.24.19.53.52;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	99.11.22.21.52.42;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	99.11.22.21.02.38;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	99.11.19.16.04.17;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	99.11.15.20.53.25;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	99.11.11.23.36.53;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	99.11.11.22.58.38;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.11.10.23.36.44;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	99.11.10.22.24.01;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.11.02.19.10.15;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	99.10.28.08.43.10;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.10.25.20.41.55;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.10.16.20.47.14;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	99.10.16.19.23.35;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	99.10.14.18.17.42;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.10.11.20.00.36;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.10.07.21.45.02;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.10.05.22.18.52;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.10.04.20.45.02;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.10.03.21.50.04;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	99.10.01.02.38.10;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.18.16.21;	author dugsong;	state Exp;
branches;
next	1.3;

1.3
date	99.09.28.04.45.37;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	99.09.26.21.47.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.38;	author deraadt;	state Exp;
branches;
next	;

1.45.2.1
date	2000.06.12.02.37.37;	author jason;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2000.09.01.18.23.24;	author jason;	state Exp;
branches;
next	1.45.2.3;

1.45.2.3
date	2000.11.08.21.31.25;	author jason;	state Exp;
branches;
next	1.45.2.4;

1.45.2.4
date	2001.03.12.15.44.17;	author jason;	state Exp;
branches;
next	1.45.2.5;

1.45.2.5
date	2001.03.21.18.53.13;	author jason;	state Exp;
branches;
next	;

1.54.2.1
date	2001.02.16.20.13.20;	author jason;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2001.02.19.17.19.33;	author jason;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2001.03.21.19.46.30;	author jason;	state Exp;
branches;
next	1.54.2.4;

1.54.2.4
date	2001.05.07.21.09.36;	author jason;	state Exp;
branches;
next	1.54.2.5;

1.54.2.5
date	2001.09.27.00.15.43;	author miod;	state Exp;
branches;
next	1.54.2.6;

1.54.2.6
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.62.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.63.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.63.2.2;

1.63.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.63.2.3;

1.63.2.3
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.63.2.4;

1.63.2.4
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	;

1.66.2.1
date	2002.05.18.04.12.11;	author jason;	state Exp;
branches;
next	1.66.2.2;

1.66.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.66.2.3;

1.66.2.3
date	2002.05.19.15.12.46;	author jason;	state Exp;
branches;
next	1.66.2.4;

1.66.2.4
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	;

1.71.2.1
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.71.4.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.71.4.2;

1.71.4.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.74.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	;

1.75.2.1
date	2005.03.10.17.15.05;	author brad;	state Exp;
branches;
next	;

1.75.4.1
date	2005.03.10.16.28.28;	author brad;	state Exp;
branches;
next	;

1.76.4.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.76.6.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.86
log
@remove miscellaneous SSH1 leftovers; ok markus@@
@
text
@/* $OpenBSD: ssh.h,v 1.85 2017/04/30 23:28:12 djm Exp $ */

/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

/* Cipher used for encrypting authentication files. */
#define SSH_AUTHFILE_CIPHER	SSH_CIPHER_3DES

/* Default port number. */
#define SSH_DEFAULT_PORT	22

/*
 * Maximum number of certificate files that can be specified
 * in configuration files or on the command line.
 */
#define SSH_MAX_CERTIFICATE_FILES	100

/*
 * Maximum number of RSA authentication identity files that can be specified
 * in configuration files or on the command line.
 */
#define SSH_MAX_IDENTITY_FILES		100

/*
 * Maximum length of lines in authorized_keys file.
 * Current value permits 16kbit RSA keys and 8kbit DSA keys, with
 * some room for options and comments.
 */
#define SSH_MAX_PUBKEY_BYTES		16384

/*
 * Major protocol version.  Different version indicates major incompatibility
 * that prevents communication.
 *
 * Minor protocol version.  Different version indicates minor incompatibility
 * that does not prevent interoperation.
 */
#define PROTOCOL_MAJOR_1	1
#define PROTOCOL_MINOR_1	5

/* We support only SSH2 */
#define PROTOCOL_MAJOR_2	2
#define PROTOCOL_MINOR_2	0

/*
 * Name for the service.  The port named by this service overrides the
 * default port if present.
 */
#define SSH_SERVICE_NAME	"ssh"

/*
 * Name of the environment variable containing the process ID of the
 * authentication agent.
 */
#define SSH_AGENTPID_ENV_NAME	"SSH_AGENT_PID"

/*
 * Name of the environment variable containing the pathname of the
 * authentication socket.
 */
#define SSH_AUTHSOCKET_ENV_NAME "SSH_AUTH_SOCK"

/*
 * Environment variable for overwriting the default location of askpass
 */
#define SSH_ASKPASS_ENV		"SSH_ASKPASS"

/*
 * Force host key length and server key length to differ by at least this
 * many bits.  This is to make double encryption with rsaref work.
 */
#define SSH_KEY_BITS_RESERVED		128

/*
 * Length of the session key in bytes.  (Specified as 256 bits in the
 * protocol.)
 */
#define SSH_SESSION_KEY_LENGTH		32

/* Used to identify ``EscapeChar none'' */
#define SSH_ESCAPECHAR_NONE		-2

/*
 * unprivileged user when UsePrivilegeSeparation=yes;
 * sshd will change its privileges to this user and its
 * primary group.
 */
#define SSH_PRIVSEP_USER		"sshd"

/* Minimum modulus size (n) for RSA keys. */
#define SSH_RSA_MINIMUM_MODULUS_SIZE	768

/* Listen backlog for sshd, ssh-agent and forwarding sockets */
#define SSH_LISTEN_BACKLOG		128
@


1.85
log
@exterminate the -1 flag from scp

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.84 2017/04/30 23:18:44 djm Exp $ */
d50 1
a50 1
/* We support both SSH2 */
@


1.84
log
@remove KEY_RSA1

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.83 2015/12/11 03:19:09 djm Exp $ */
d50 1
a50 1
/* We support both SSH1 and SSH2 */
@


1.83
log
@use SSH_MAX_PUBKEY_BYTES consistently as buffer size when reading key
files. Increase it to match the size of the buffers already being used.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.82 2015/09/24 06:15:11 djm Exp $ */
d35 1
a35 1
 * Current value permits 16kbit RSA and RSA1 keys and 8kbit DSA keys, with
@


1.82
log
@add ssh_config CertificateFile option to explicitly list
a certificate; patch from Meghana Bhat on bz#2436; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.81 2015/08/04 05:23:06 djm Exp $ */
d38 1
a38 1
#define SSH_MAX_PUBKEY_BYTES		8192
@


1.81
log
@backout SSH_RSA_MINIMUM_MODULUS_SIZE increase for this release;
problems spotted by sthen@@ ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.80 2015/07/03 03:49:45 djm Exp $ */
d20 6
@


1.80
log
@refuse to generate or accept RSA keys smaller than 1024 bits;
feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.79 2010/06/25 07:14:46 djm Exp $ */
d94 1
a94 1
#define SSH_RSA_MINIMUM_MODULUS_SIZE	1024
@


1.79
log
@bz#1327: remove hardcoded limit of 100 permitopen clauses and port
forwards per direction; ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.78 2006/08/03 03:34:42 deraadt Exp $ */
d94 1
a94 1
#define SSH_RSA_MINIMUM_MODULUS_SIZE	768
@


1.78
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.77 2006/03/25 22:22:43 djm Exp $ */
a19 3

/* Maximum number of TCP/IP ports forwarded per direction. */
#define SSH_MAX_FORWARDS_PER_DIRECTION	100
@


1.77
log
@standardise spacing in $OpenBSD$ tags; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.76 2004/12/06 11:41:03 dtucker Exp $ */
a14 3
#ifndef SSH_H
#define SSH_H

a100 2

#endif				/* SSH_H */
@


1.76
log
@Discard over-length authorized_keys entries rather than complaining when
they don't decode.  bz #884, with & ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.75 2003/12/02 17:01:15 markus Exp $	*/
@


1.76.4.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.78 2006/08/03 03:34:42 deraadt Exp $ */
d15 3
d104 2
@


1.76.6.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.h,v 1.78 2006/08/03 03:34:42 deraadt Exp $ */
d15 3
d104 2
@


1.75
log
@use SSH_LISTEN_BACKLOG (=128) in listen(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.74 2003/09/01 13:52:18 markus Exp $	*/
d32 7
@


1.75.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.76 2004/12/06 11:41:03 dtucker Exp $	*/
a31 7

/*
 * Maximum length of lines in authorized_keys file.
 * Current value permits 16kbit RSA and RSA1 keys and 8kbit DSA keys, with
 * some room for options and comments.
 */
#define SSH_MAX_PUBKEY_BYTES		8192
@


1.75.4.1
log
@upgrade to OpenSSH 4.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.76 2004/12/06 11:41:03 dtucker Exp $	*/
a31 7

/*
 * Maximum length of lines in authorized_keys file.
 * Current value permits 16kbit RSA and RSA1 keys and 8kbit DSA keys, with
 * some room for options and comments.
 */
#define SSH_MAX_PUBKEY_BYTES		8192
@


1.74
log
@rm whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.73 2003/07/22 13:35:22 markus Exp $	*/
d94 3
@


1.74.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.75 2003/12/02 17:01:15 markus Exp $	*/
a93 3

/* Listen backlog for sshd, ssh-agent and forwarding sockets */
#define SSH_LISTEN_BACKLOG		128
@


1.73
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.72 2003/06/28 16:23:06 deraadt Exp $	*/
a95 1

@


1.72
log
@deal with typing of write vs read in atomicio
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.71 2002/06/22 02:00:29 stevesk Exp $	*/
a80 3

/* Name of Kerberos service for SSH to use. */
#define KRB4_SERVICE_NAME		"rcmd"
@


1.71
log
@correct comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.70 2002/06/03 12:04:07 deraadt Exp $	*/
d99 1
@


1.71.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.74 2003/09/01 13:52:18 markus Exp $	*/
d81 3
@


1.71.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.74 2003/09/01 13:52:18 markus Exp $	*/
d81 3
@


1.71.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.75 2003/12/02 17:01:15 markus Exp $	*/
a93 3

/* Listen backlog for sshd, ssh-agent and forwarding sockets */
#define SSH_LISTEN_BACKLOG		128
@


1.70
log
@compatiblity -> compatibility
decriptor -> descriptor
authentciated -> authenticated
transmition -> transmission
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.69 2002/05/11 20:24:48 stevesk Exp $	*/
d54 2
a55 2
 * Name of the environment variable containing the pathname of the
 * authentication socket.
@


1.69
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.68 2002/05/08 21:06:34 deraadt Exp $	*/
d34 1
a34 1
 * Major protocol version.  Different version indicates major incompatiblity
@


1.68
log
@move to sshd.sshd instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.67 2002/05/07 19:54:36 deraadt Exp $	*/
d90 1
a90 1
 * sshd will change its pivileges to this user and its
@


1.67
log
@use ssh uid
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.66 2002/03/29 19:18:33 stevesk Exp $	*/
d93 1
a93 1
#define SSH_PRIVSEP_USER		"ssh"
@


1.66
log
@make RSA modulus minimum #define; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.65 2002/03/20 19:12:25 stevesk Exp $	*/
d93 1
a93 1
#define SSH_PRIVSEP_USER		"nobody"
@


1.66.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.69 2002/05/11 20:24:48 stevesk Exp $	*/
d90 1
a90 1
 * sshd will change its privileges to this user and its
d93 1
a93 1
#define SSH_PRIVSEP_USER		"sshd"
@


1.66.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.66.2.3
log
@Set privsep user to 'nobody', missed in merge of openssh-3.2.[23];
pointed out by Oleg Safiullin <form@@openbsd.ru>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.66.2.2 2002/05/18 04:50:38 jason Exp $	*/
d93 1
a93 1
#define SSH_PRIVSEP_USER		"nobody"
@


1.66.2.4
log
@Pull in OpenSSH-3.4
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.71 2002/06/22 02:00:29 stevesk Exp $	*/
d34 1
a34 1
 * Major protocol version.  Different version indicates major incompatibility
d54 2
a55 2
 * Name of the environment variable containing the process ID of the
 * authentication agent.
@


1.65
log
@for unprivileged user, group do:
pw=getpwnam(SSH_PRIVSEP_USER); do_setusercontext(pw).  ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.64 2002/03/04 17:27:39 stevesk Exp $	*/
d94 3
@


1.64
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.63 2001/05/24 18:57:53 stevesk Exp $	*/
d87 7
@


1.63
log
@don't perform escape processing when ``EscapeChar none''; ok markus@@
@
text
@d1 2
a13 2

/* RCSID("$OpenBSD: ssh.h,v 1.62 2001/01/23 10:45:10 markus Exp $"); */
@


1.63.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@a0 2
/*	$OpenBSD: ssh.h,v 1.64 2002/03/04 17:27:39 stevesk Exp $	*/

d12 2
@


1.63.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.69 2002/05/11 20:24:48 stevesk Exp $	*/
a86 10

/*
 * unprivileged user when UsePrivilegeSeparation=yes;
 * sshd will change its privileges to this user and its
 * primary group.
 */
#define SSH_PRIVSEP_USER		"sshd"

/* Minimum modulus size (n) for RSA keys. */
#define SSH_RSA_MINIMUM_MODULUS_SIZE	768
@


1.63.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.63.2.2 2002/05/17 00:03:24 miod Exp $	*/
d34 1
a34 1
 * Major protocol version.  Different version indicates major incompatibility
d93 1
a93 1
#define SSH_PRIVSEP_USER		"nobody"
@


1.63.2.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.63.2.3 2002/06/22 07:23:18 miod Exp $	*/
d54 2
a55 2
 * Name of the environment variable containing the process ID of the
 * authentication agent.
@


1.62
log
@nuke comment
@
text
@d13 1
a13 1
/* RCSID("$OpenBSD: ssh.h,v 1.61 2001/01/21 19:05:59 markus Exp $"); */
d84 3
@


1.62.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d13 1
a13 1
/* RCSID("$OpenBSD: ssh.h,v 1.63 2001/05/24 18:57:53 stevesk Exp $"); */
a83 3

/* Used to identify ``EscapeChar none'' */
#define SSH_ESCAPECHAR_NONE		-2
@


1.62.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@a0 2
/*	$OpenBSD: ssh.h,v 1.64 2002/03/04 17:27:39 stevesk Exp $	*/

d12 2
@


1.62.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssh.h,v 1.69 2002/05/11 20:24:48 stevesk Exp $	*/
a86 10

/*
 * unprivileged user when UsePrivilegeSeparation=yes;
 * sshd will change its privileges to this user and its
 * primary group.
 */
#define SSH_PRIVSEP_USER		"sshd"

/* Minimum modulus size (n) for RSA keys. */
#define SSH_RSA_MINIMUM_MODULUS_SIZE	768
@


1.61
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d13 1
a13 1
/* RCSID("$OpenBSD: ssh.h,v 1.60 2001/01/19 15:55:11 markus Exp $"); */
a16 3

//#include "rsa.h"
//#include "cipher.h"
@


1.60
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@a5 2
 * Generic header file for ssh.
 *
d13 1
a13 1
/* RCSID("$OpenBSD: ssh.h,v 1.59 2001/01/19 12:45:27 markus Exp $"); */
d18 2
a19 2
#include "rsa.h"
#include "cipher.h"
a86 261


/*------------ definitions for login.c -------------*/

/*
 * Returns the time when the user last logged in.  Returns 0 if the
 * information is not available.  This must be called before record_login.
 * The host from which the user logged in is stored in buf.
 */
u_long
get_last_login_time(uid_t uid, const char *logname,
    char *buf, u_int bufsize);

/*
 * Records that the user has logged in.  This does many things normally done
 * by login(1).
 */
void
record_login(pid_t pid, const char *ttyname, const char *user, uid_t uid,
    const char *host, struct sockaddr *addr);

/*
 * Records that the user has logged out.  This does many thigs normally done
 * by login(1) or init.
 */
void    record_logout(pid_t pid, const char *ttyname);

/*------------ definitions for sshconnect.c ----------*/

/*
 * Opens a TCP/IP connection to the remote server on the given host.  If port
 * is 0, the default port will be used.  If anonymous is zero, a privileged
 * port will be allocated to make the connection. This requires super-user
 * privileges if anonymous is false. Connection_attempts specifies the
 * maximum number of tries, one per second.  This returns true on success,
 * and zero on failure.  If the connection is successful, this calls
 * packet_set_connection for the connection.
 */
int
ssh_connect(const char *host, struct sockaddr_storage * hostaddr,
    u_short port, int connection_attempts,
    int anonymous, uid_t original_real_uid,
    const char *proxy_command);

/*
 * Starts a dialog with the server, and authenticates the current user on the
 * server.  This does not need any extra privileges.  The basic connection to
 * the server must already have been established before this is called. If
 * login fails, this function prints an error and never returns. This
 * initializes the random state, and leaves it initialized (it will also have
 * references from the packet module).
 */

void
ssh_login(int host_key_valid, RSA * host_key, const char *host,
    struct sockaddr * hostaddr, uid_t original_real_uid);

/*------------ Definitions for various authentication methods. -------*/

/*
 * Tries to authenticate the user using the .rhosts file.  Returns true if
 * authentication succeeds.  If ignore_rhosts is non-zero, this will not
 * consider .rhosts and .shosts (/etc/hosts.equiv will still be used).
 */
int     auth_rhosts(struct passwd * pw, const char *client_user);

/*
 * Tries to authenticate the user using the .rhosts file and the host using
 * its host key.  Returns true if authentication succeeds.
 */
int
auth_rhosts_rsa(struct passwd * pw, const char *client_user, RSA* client_host_key);

/*
 * Tries to authenticate the user using password.  Returns true if
 * authentication succeeds.
 */
int     auth_password(struct passwd * pw, const char *password);

/*
 * Performs the RSA authentication dialog with the client.  This returns 0 if
 * the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int     auth_rsa(struct passwd * pw, BIGNUM * client_n);

/*
 * Parses an RSA key (number of bits, e, n) from a string.  Moves the pointer
 * over the key.  Skips any whitespace at the beginning and at end.
 */
int     auth_rsa_read_key(char **cpp, u_int *bitsp, BIGNUM * e, BIGNUM * n);

/*
 * Returns the name of the machine at the other end of the socket.  The
 * returned string should be freed by the caller.
 */
char   *get_remote_hostname(int socket);

/*
 * Return the canonical name of the host in the other side of the current
 * connection (as returned by packet_get_connection).  The host name is
 * cached, so it is efficient to call this several times.
 */
const char *get_canonical_hostname(void);

/*
 * Returns the remote IP address as an ascii string.  The value need not be
 * freed by the caller.
 */
const char *get_remote_ipaddr(void);

/* Returns the port number of the peer of the socket. */
int     get_peer_port(int sock);

/* Returns the port number of the remote/local host. */
int     get_remote_port(void);
int	get_local_port(void);


/*
 * Performs the RSA authentication challenge-response dialog with the client,
 * and returns true (non-zero) if the client gave the correct answer to our
 * challenge; returns zero if the client gives a wrong answer.
 */
int     auth_rsa_challenge_dialog(RSA *pk);

/*
 * Reads a passphrase from /dev/tty with echo turned off.  Returns the
 * passphrase (allocated with xmalloc).  Exits if EOF is encountered. If
 * from_stdin is true, the passphrase will be read from stdin instead.
 */
char   *read_passphrase(char *prompt, int from_stdin);


/*------------ Definitions for logging. -----------------------*/

/* Supported syslog facilities and levels. */
typedef enum {
	SYSLOG_FACILITY_DAEMON,
	SYSLOG_FACILITY_USER,
	SYSLOG_FACILITY_AUTH,
	SYSLOG_FACILITY_LOCAL0,
	SYSLOG_FACILITY_LOCAL1,
	SYSLOG_FACILITY_LOCAL2,
	SYSLOG_FACILITY_LOCAL3,
	SYSLOG_FACILITY_LOCAL4,
	SYSLOG_FACILITY_LOCAL5,
	SYSLOG_FACILITY_LOCAL6,
	SYSLOG_FACILITY_LOCAL7
}       SyslogFacility;

typedef enum {
	SYSLOG_LEVEL_QUIET,
	SYSLOG_LEVEL_FATAL,
	SYSLOG_LEVEL_ERROR,
	SYSLOG_LEVEL_INFO,
	SYSLOG_LEVEL_VERBOSE,
	SYSLOG_LEVEL_DEBUG1,
	SYSLOG_LEVEL_DEBUG2,
	SYSLOG_LEVEL_DEBUG3
}       LogLevel;
/* Initializes logging. */
void    log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr);

/* Logging implementation, depending on server or client */
void    do_log(LogLevel level, const char *fmt, va_list args);

/* name to facility/level */
SyslogFacility log_facility_number(char *name);
LogLevel log_level_number(char *name);

/* Output a message to syslog or stderr */
void    fatal(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void    error(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void    log(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void    verbose(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void    debug(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void    debug2(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void    debug3(const char *fmt,...) __attribute__((format(printf, 1, 2)));

/* same as fatal() but w/o logging */
void    fatal_cleanup(void);

/*
 * Registers a cleanup function to be called by fatal()/fatal_cleanup()
 * before exiting. It is permissible to call fatal_remove_cleanup for the
 * function itself from the function.
 */
void    fatal_add_cleanup(void (*proc) (void *context), void *context);

/* Removes a cleanup function to be called at fatal(). */
void    fatal_remove_cleanup(void (*proc) (void *context), void *context);

/* ---- misc */

/*
 * Expands tildes in the file name.  Returns data allocated by xmalloc.
 * Warning: this calls getpw*.
 */
char   *tilde_expand_filename(const char *filename, uid_t my_uid);

/* remove newline at end of string */
char	*chop(char *s);

/* return next token in configuration line */
char	*strdelim(char **s);

/* set filedescriptor to non-blocking */
void	set_nonblock(int fd);

/*
 * Performs the interactive session.  This handles data transmission between
 * the client and the program.  Note that the notion of stdin, stdout, and
 * stderr in this function is sort of reversed: this function writes to stdin
 * (of the child program), and reads from stdout and stderr (of the child
 * program).
 */
void    server_loop(pid_t pid, int fdin, int fdout, int fderr);
void    server_loop2(void);

/* Client side main loop for the interactive session. */
int     client_loop(int have_pty, int escape_char, int id);

/* Linked list of custom environment strings (see auth-rsa.c). */
struct envstring {
	struct envstring *next;
	char   *s;
};

/*
 * Ensure all of data on socket comes through. f==read || f==write
 */
ssize_t	atomicio(ssize_t (*f)(), int fd, void *s, size_t n);

#ifdef KRB4
#include <krb.h>
/*
 * Performs Kerberos v4 mutual authentication with the client. This returns 0
 * if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int     auth_krb4(const char *server_user, KTEXT auth, char **client);
int     krb4_init(uid_t uid);
void    krb4_cleanup_proc(void *ignore);
int	auth_krb4_password(struct passwd * pw, const char *password);

#ifdef AFS
#include <kafs.h>

/* Accept passed Kerberos v4 ticket-granting ticket and AFS tokens. */
int     auth_kerberos_tgt(struct passwd * pw, const char *string);
int     auth_afs_token(struct passwd * pw, const char *token_string);

int     creds_to_radix(CREDENTIALS * creds, u_char *buf, size_t buflen);
int     radix_to_creds(const char *buf, CREDENTIALS * creds);
#endif				/* AFS */

#endif				/* KRB4 */

/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;
@


1.59
log
@only auth-chall.c needs #ifdef SKEY
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.58 2001/01/18 16:20:22 markus Exp $"); */
a57 84
#define ETCDIR			"/etc"
#define PIDDIR			"/var/run"

/*
 * System-wide file containing host keys of known hosts.  This file should be
 * world-readable.
 */
#define SSH_SYSTEM_HOSTFILE	ETCDIR "/ssh_known_hosts"
#define SSH_SYSTEM_HOSTFILE2	ETCDIR "/ssh_known_hosts2"

/*
 * Of these, ssh_host_key must be readable only by root, whereas ssh_config
 * should be world-readable.
 */
#define HOST_KEY_FILE		ETCDIR "/ssh_host_key"
#define SERVER_CONFIG_FILE	ETCDIR "/sshd_config"
#define HOST_CONFIG_FILE	ETCDIR "/ssh_config"
#define HOST_DSA_KEY_FILE	ETCDIR "/ssh_host_dsa_key"
#define DH_PRIMES		ETCDIR "/primes"

#define SSH_PROGRAM		"/usr/bin/ssh"

/*
 * The process id of the daemon listening for connections is saved here to
 * make it easier to kill the correct daemon when necessary.
 */
#define SSH_DAEMON_PID_FILE	PIDDIR "/sshd.pid"

/*
 * The directory in user\'s home directory in which the files reside. The
 * directory should be world-readable (though not all files are).
 */
#define SSH_USER_DIR		".ssh"

/*
 * Per-user file containing host keys of known hosts.  This file need not be
 * readable by anyone except the user him/herself, though this does not
 * contain anything particularly secret.
 */
#define SSH_USER_HOSTFILE	"~/.ssh/known_hosts"
#define SSH_USER_HOSTFILE2	"~/.ssh/known_hosts2"

/*
 * Name of the default file containing client-side authentication key. This
 * file should only be readable by the user him/herself.
 */
#define SSH_CLIENT_IDENTITY	".ssh/identity"
#define SSH_CLIENT_ID_DSA	".ssh/id_dsa"
#define SSH_CLIENT_ID_RSA	".ssh/id_rsa"

/*
 * Configuration file in user\'s home directory.  This file need not be
 * readable by anyone but the user him/herself, but does not contain anything
 * particularly secret.  If the user\'s home directory resides on an NFS
 * volume where root is mapped to nobody, this may need to be world-readable.
 */
#define SSH_USER_CONFFILE	".ssh/config"

/*
 * File containing a list of those rsa keys that permit logging in as this
 * user.  This file need not be readable by anyone but the user him/herself,
 * but does not contain anything particularly secret.  If the user\'s home
 * directory resides on an NFS volume where root is mapped to nobody, this
 * may need to be world-readable.  (This file is read by the daemon which is
 * running as root.)
 */
#define SSH_USER_PERMITTED_KEYS	".ssh/authorized_keys"
#define SSH_USER_PERMITTED_KEYS2	".ssh/authorized_keys2"

/*
 * Per-user and system-wide ssh "rc" files.  These files are executed with
 * /bin/sh before starting the shell or command if they exist.  They will be
 * passed "proto cookie" as arguments if X11 forwarding with spoofing is in
 * use.  xauth will be run if neither of these exists.
 */
#define SSH_USER_RC		".ssh/rc"
#define SSH_SYSTEM_RC		ETCDIR "/sshrc"

/*
 * Ssh-only version of /etc/hosts.equiv.  Additionally, the daemon may use
 * ~/.rhosts and /etc/hosts.equiv if rhosts authentication is enabled.
 */
#define SSH_HOSTS_EQUIV		ETCDIR "/shosts.equiv"

d62 1
a62 1
#define SSH_AUTHSOCKET_ENV_NAME	"SSH_AUTH_SOCK"
d68 1
a68 1
#define SSH_AGENTPID_ENV_NAME	"SSH_AGENT_PID"
d71 1
a71 2
 * Default path to ssh-askpass used by ssh-add,
 * environment variable for overwriting the default location
a72 1
#define SSH_ASKPASS_DEFAULT	"/usr/X11R6/bin/ssh-askpass"
a89 71
/*
 * Authentication methods.  New types can be added, but old types should not
 * be removed for compatibility.  The maximum allowed value is 31.
 */
#define SSH_AUTH_RHOSTS		1
#define SSH_AUTH_RSA		2
#define SSH_AUTH_PASSWORD	3
#define SSH_AUTH_RHOSTS_RSA	4
#define SSH_AUTH_TIS		5
#define SSH_AUTH_KERBEROS	6
#define SSH_PASS_KERBEROS_TGT	7
				/* 8 to 15 are reserved */
#define SSH_PASS_AFS_TOKEN	21

/* Protocol flags.  These are bit masks. */
#define SSH_PROTOFLAG_SCREEN_NUMBER	1	/* X11 forwarding includes screen */
#define SSH_PROTOFLAG_HOST_IN_FWD_OPEN	2	/* forwarding opens contain host */

/*
 * Definition of message types.  New values can be added, but old values
 * should not be removed or without careful consideration of the consequences
 * for compatibility.  The maximum value is 254; value 255 is reserved for
 * future extension.
 */
/* Message name */			/* msg code */	/* arguments */
#define SSH_MSG_NONE				0	/* no message */
#define SSH_MSG_DISCONNECT			1	/* cause (string) */
#define SSH_SMSG_PUBLIC_KEY			2	/* ck,msk,srvk,hostk */
#define SSH_CMSG_SESSION_KEY			3	/* key (BIGNUM) */
#define SSH_CMSG_USER				4	/* user (string) */
#define SSH_CMSG_AUTH_RHOSTS			5	/* user (string) */
#define SSH_CMSG_AUTH_RSA			6	/* modulus (BIGNUM) */
#define SSH_SMSG_AUTH_RSA_CHALLENGE		7	/* int (BIGNUM) */
#define SSH_CMSG_AUTH_RSA_RESPONSE		8	/* int (BIGNUM) */
#define SSH_CMSG_AUTH_PASSWORD			9	/* pass (string) */
#define SSH_CMSG_REQUEST_PTY		        10	/* TERM, tty modes */
#define SSH_CMSG_WINDOW_SIZE		        11	/* row,col,xpix,ypix */
#define SSH_CMSG_EXEC_SHELL			12	/* */
#define SSH_CMSG_EXEC_CMD			13	/* cmd (string) */
#define SSH_SMSG_SUCCESS			14	/* */
#define SSH_SMSG_FAILURE			15	/* */
#define SSH_CMSG_STDIN_DATA			16	/* data (string) */
#define SSH_SMSG_STDOUT_DATA			17	/* data (string) */
#define SSH_SMSG_STDERR_DATA			18	/* data (string) */
#define SSH_CMSG_EOF				19	/* */
#define SSH_SMSG_EXITSTATUS			20	/* status (int) */
#define SSH_MSG_CHANNEL_OPEN_CONFIRMATION	21	/* channel (int) */
#define SSH_MSG_CHANNEL_OPEN_FAILURE		22	/* channel (int) */
#define SSH_MSG_CHANNEL_DATA			23	/* ch,data (int,str) */
#define SSH_MSG_CHANNEL_CLOSE			24	/* channel (int) */
#define SSH_MSG_CHANNEL_CLOSE_CONFIRMATION	25	/* channel (int) */
/*      SSH_CMSG_X11_REQUEST_FORWARDING         26         OBSOLETE */
#define SSH_SMSG_X11_OPEN			27	/* channel (int) */
#define SSH_CMSG_PORT_FORWARD_REQUEST		28	/* p,host,hp (i,s,i) */
#define SSH_MSG_PORT_OPEN			29	/* ch,h,p (i,s,i) */
#define SSH_CMSG_AGENT_REQUEST_FORWARDING	30	/* */
#define SSH_SMSG_AGENT_OPEN			31	/* port (int) */
#define SSH_MSG_IGNORE				32	/* string */
#define SSH_CMSG_EXIT_CONFIRMATION		33	/* */
#define SSH_CMSG_X11_REQUEST_FORWARDING		34	/* proto,data (s,s) */
#define SSH_CMSG_AUTH_RHOSTS_RSA		35	/* user,mod (s,mpi) */
#define SSH_MSG_DEBUG				36	/* string */
#define SSH_CMSG_REQUEST_COMPRESSION		37	/* level 1-9 (int) */
#define SSH_CMSG_MAX_PACKET_SIZE		38	/* size 4k-1024k (int) */
#define SSH_CMSG_AUTH_TIS			39	/* we use this for s/key */
#define SSH_SMSG_AUTH_TIS_CHALLENGE		40	/* challenge (string) */
#define SSH_CMSG_AUTH_TIS_RESPONSE		41	/* response (string) */
#define SSH_CMSG_AUTH_KERBEROS			42	/* (KTEXT) */
#define SSH_SMSG_AUTH_KERBEROS_RESPONSE		43	/* (KTEXT) */
#define SSH_CMSG_HAVE_KERBEROS_TGT		44	/* credentials (s) */
#define SSH_CMSG_HAVE_AFS_TOKEN			65	/* token (s) */
@


1.58
log
@log() is at pri=LOG_INFO, since LOG_NOTICE goes to /dev/console on many systems
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.57 2001/01/07 11:28:06 markus Exp $"); */
a503 6

#ifdef SKEY
#include <skey.h>
char   *skey_fake_keyinfo(char *username);
int	auth_skey_password(struct passwd * pw, const char *password);
#endif				/* SKEY */
@


1.57
log
@rename SYSLOG_LEVEL_INFO->SYSLOG_LEVEL_NOTICE
syslog priority changes:
	fatal() LOG_ERR  -> LOG_CRIT
	log()   LOG_INFO -> LOG_NOTICE
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.56 2000/12/19 23:17:58 markus Exp $"); */
d401 1
a401 1
	SYSLOG_LEVEL_NOTICE,
@


1.56
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.55 2000/11/25 17:19:33 markus Exp $"); */
d401 1
a401 1
	SYSLOG_LEVEL_INFO,
@


1.55
log
@print keytype when generating a key.
reasonable defaults for RSA1/RSA/DSA keys.
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.54 2000/10/11 20:27:24 markus Exp $"); */
d255 1
a255 1
unsigned long
d257 1
a257 1
    char *buf, unsigned int bufsize);
d336 1
a336 1
int     auth_rsa_read_key(char **cpp, unsigned int *bitsp, BIGNUM * e, BIGNUM * n);
d499 1
a499 1
int     creds_to_radix(CREDENTIALS * creds, unsigned char *buf, size_t buflen);
@


1.54
log
@new cipher framework
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.53 2000/10/11 20:14:39 markus Exp $"); */
d106 1
@


1.54.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d6 2
d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.62 2001/01/23 10:45:10 markus Exp $"); */
d20 3
d58 83
d145 1
a145 1
#define SSH_AGENTPID_ENV_NAME	"SSH_AGENT_PID"
d151 1
a151 1
#define SSH_AUTHSOCKET_ENV_NAME "SSH_AUTH_SOCK"
d154 2
a155 1
 * Environment variable for overwriting the default location of askpass
d157 1
d174 338
@


1.54.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.54.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.54.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.54.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d13 1
a13 1
/* RCSID("$OpenBSD: ssh.h,v 1.63 2001/05/24 18:57:53 stevesk Exp $"); */
a83 3

/* Used to identify ``EscapeChar none'' */
#define SSH_ESCAPECHAR_NONE		-2
@


1.54.2.6
log
@Merge OpenSSH 3.1.
@
text
@a0 2
/*	$OpenBSD: ssh.h,v 1.64 2002/03/04 17:27:39 stevesk Exp $	*/

d12 2
@


1.53
log
@add support for s/key (kbd-interactive) to ssh2, based on work by mkiernan@@avantgo.com and me
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.52 2000/10/11 04:02:17 provos Exp $"); */
a21 8

/*
 * XXX
 * The default cipher used if IDEA is not supported by the remote host. It is
 * recommended that this be one of the mandatory ciphers (DES, 3DES), though
 * that is not required.
 */
#define SSH_FALLBACK_CIPHER	SSH_CIPHER_3DES
@


1.52
log
@First rough implementation of the diffie-hellman group exchange.  The
client can ask the server for bigger groups to perform the diffie-hellman
in, thus increasing the attack complexity when using ciphers with longer
keys.  University of Windsor provided network, T the company.
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.51 2000/09/12 20:53:10 markus Exp $"); */
d384 1
a384 1
char   *read_passphrase(const char *prompt, int from_stdin);
@


1.51
log
@multiple debug levels
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.50 2000/09/07 20:27:54 deraadt Exp $"); */
d84 1
@


1.50
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.49 2000/08/19 18:48:11 markus Exp $"); */
d409 3
a411 1
	SYSLOG_LEVEL_DEBUG
d429 2
@


1.49
log
@support for ~. in ssh2
@
text
@a1 3
 *
 * ssh.h
 *
a2 1
 *
a5 2
 * Created: Fri Mar 17 17:09:37 1995 ylo
 *
d8 5
d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.48 2000/07/13 22:53:21 provos Exp $"); */
@


1.48
log
@allow multiple whitespace but only one '=' between tokens, bug report from
Ralf S. Engelschall <rse@@engelschall.com> but different fix. okay deraadt@@
@
text
@d16 1
a16 1
/* RCSID("$OpenBSD: ssh.h,v 1.47 2000/06/20 01:39:45 markus Exp $"); */
d470 1
a470 1
int     client_loop(int have_pty, int escape_char);
@


1.47
log
@OpenBSD tag
@
text
@d16 1
a16 1
/* RCSID("$OpenBSD: ssh.h,v 1.46 2000/05/17 08:20:15 markus Exp $"); */
d452 3
@


1.46
log
@enable nonblocking IO for sshd w/ proto 1, too; split out common code
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.45 2000/05/08 17:12:16 markus Exp $"); */
@


1.45
log
@complain about invalid ciphers in SSH1 (e.g. arcfour is SSH2 only)
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.44 2000/05/04 22:38:00 markus Exp $"); */
d449 6
@


1.45.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.46 2000/05/17 08:20:15 markus Exp $"); */
a448 6

/* remove newline at end of string */
char	*chop(char *s);

/* set filedescriptor to non-blocking */
void	set_nonblock(int fd);
@


1.45.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d16 1
a16 1
/* RCSID("$OpenBSD: ssh.h,v 1.49 2000/08/19 18:48:11 markus Exp $"); */
a452 3
/* return next token in configuration line */
char	*strdelim(char **s);

d467 1
a467 1
int     client_loop(int have_pty, int escape_char, int id);
@


1.45.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d10 2
a13 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d16 1
a16 1
/* RCSID("$OpenBSD: ssh.h,v 1.54 2000/10/11 20:27:24 markus Exp $"); */
d24 8
a84 1
#define DH_PRIMES		ETCDIR "/primes"
d384 1
a384 1
char   *read_passphrase(char *prompt, int from_stdin);
d410 1
a410 3
	SYSLOG_LEVEL_DEBUG1,
	SYSLOG_LEVEL_DEBUG2,
	SYSLOG_LEVEL_DEBUG3
a427 2
void    debug2(const char *fmt,...) __attribute__((format(printf, 1, 2)));
void    debug3(const char *fmt,...) __attribute__((format(printf, 1, 2)));
@


1.45.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d6 2
d15 1
a15 1
/* RCSID("$OpenBSD: ssh.h,v 1.62 2001/01/23 10:45:10 markus Exp $"); */
d20 3
d58 83
d145 1
a145 1
#define SSH_AGENTPID_ENV_NAME	"SSH_AGENT_PID"
d151 1
a151 1
#define SSH_AUTHSOCKET_ENV_NAME "SSH_AUTH_SOCK"
d154 2
a155 1
 * Environment variable for overwriting the default location of askpass
d157 1
d174 338
@


1.45.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.44
log
@replace broken uuencode w/ libc b64_ntop
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.43 2000/05/03 10:21:48 markus Exp $"); */
d25 1
@


1.43
log
@s/DsaKey/HostDSAKey/, document option
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.42 2000/05/02 22:18:04 markus Exp $"); */
d492 1
a492 1
int     creds_to_radix(CREDENTIALS * creds, unsigned char *buf);
@


1.42
log
@default DSA key file ~/.ssh/id_dsa
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.41 2000/04/26 22:38:16 deraadt Exp $"); */
d83 1
a83 1
#define DSA_KEY_FILE		ETCDIR "/ssh_host_dsa_key"
@


1.41
log
@host key becomes /etc/ssh_host_dsa_key
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.40 2000/04/26 20:56:30 markus Exp $"); */
d112 1
@


1.40
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.39 2000/04/19 07:05:49 deraadt Exp $"); */
d83 1
a83 1
#define DSA_KEY_FILE		ETCDIR "/ssh_dsa_key"
@


1.39
log
@pid_t
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.38 2000/04/14 10:30:33 markus Exp $"); */
d74 1
d105 1
d130 1
a383 30
/*
 * Saves the authentication (private) key in a file, encrypting it with
 * passphrase.  The identification of the file (lowest 64 bits of n) will
 * precede the key to provide identification of the key without needing a
 * passphrase.
 */
int
save_private_key(const char *filename, const char *passphrase,
    RSA * private_key, const char *comment);

/*
 * Loads the public part of the key file (public key and comment). Returns 0
 * if an error occurred; zero if the public key was successfully read.  The
 * comment of the key is returned in comment_return if it is non-NULL; the
 * caller must free the value with xfree.
 */
int
load_public_key(const char *filename, RSA * pub,
    char **comment_return);

/*
 * Loads the private key from the file.  Returns 0 if an error is encountered
 * (file does not exist or is not readable, or passphrase is bad). This
 * initializes the private key.  The comment of the key is returned in
 * comment_return if it is non-NULL; the caller must free the value with
 * xfree.
 */
int
load_private_key(const char *filename, const char *passphrase,
    RSA * private_key, char **comment_return);
@


1.38
log
@whitespace cleanup
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.37 2000/04/12 07:45:44 markus Exp $"); */
d266 1
a266 1
record_login(int pid, const char *ttyname, const char *user, uid_t uid,
d273 1
a273 1
void    record_logout(int pid, const char *ttyname);
d482 1
a482 1
void    server_loop(int pid, int fdin, int fdout, int fderr);
@


1.37
log
@add Cipher and Protocol options to ssh/sshd, e.g.:
ssh -o 'Protocol 1,2' if you prefer proto 1, ssh -o 'Ciphers arcfour,3des-cbc'
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.36 2000/04/06 08:55:22 markus Exp $"); */
d257 1
a257 1
unsigned long 
d265 1
a265 1
void 
d286 1
a286 1
int 
d301 1
a301 1
void 
d318 1
a318 1
int 
d387 1
a387 1
int 
d397 1
a397 1
int 
d408 1
a408 1
int 
@


1.36
log
@ssh2 server side, see README.openssh2; enable with 'sshd -2'
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.35 2000/03/28 20:31:29 markus Exp $"); */
d49 1
a49 4
 */
#define PROTOCOL_MAJOR		1

/*
d53 6
a58 1
#define PROTOCOL_MINOR		5
@


1.35
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.34 2000/03/23 22:15:33 markus Exp $"); */
d80 1
d465 2
d481 1
@


1.34
log
@initial support for DSA keys. ok deraadt@@, niels@@
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.33 2000/02/01 22:32:53 d Exp $"); */
a462 169

/*---------------- definitions for channels ------------------*/

/* Sets specific protocol options. */
void    channel_set_options(int hostname_in_open);

/*
 * Allocate a new channel object and set its type and socket.  Remote_name
 * must have been allocated with xmalloc; this will free it when the channel
 * is freed.
 */
int     channel_allocate(int type, int sock, char *remote_name);

/* Free the channel and close its socket. */
void    channel_free(int channel);

/* Add any bits relevant to channels in select bitmasks. */
void    channel_prepare_select(fd_set * readset, fd_set * writeset);

/*
 * After select, perform any appropriate operations for channels which have
 * events pending.
 */
void    channel_after_select(fd_set * readset, fd_set * writeset);

/* If there is data to send to the connection, send some of it now. */
void    channel_output_poll(void);

/*
 * This is called when a packet of type CHANNEL_DATA has just been received.
 * The message type has already been consumed, but channel number and data is
 * still there.
 */
void    channel_input_data(int payload_len);

/* Returns true if no channel has too much buffered data. */
int     channel_not_very_much_buffered_data(void);

/* This is called after receiving CHANNEL_CLOSE. */
void    channel_input_close(void);

/* This is called after receiving CHANNEL_CLOSE_CONFIRMATION. */
void    channel_input_close_confirmation(void);

/* This is called after receiving CHANNEL_OPEN_CONFIRMATION. */
void    channel_input_open_confirmation(void);

/* This is called after receiving CHANNEL_OPEN_FAILURE from the other side. */
void    channel_input_open_failure(void);

/* This closes any sockets that are listening for connections; this removes
   any unix domain sockets. */
void    channel_stop_listening(void);

/*
 * Closes the sockets of all channels.  This is used to close extra file
 * descriptors after a fork.
 */
void    channel_close_all(void);

/* Returns the maximum file descriptor number used by the channels. */
int     channel_max_fd(void);

/* Returns true if there is still an open channel over the connection. */
int     channel_still_open(void);

/*
 * Returns a string containing a list of all open channels.  The list is
 * suitable for displaying to the user.  It uses crlf instead of newlines.
 * The caller should free the string with xfree.
 */
char   *channel_open_message(void);

/*
 * Initiate forwarding of connections to local port "port" through the secure
 * channel to host:port from remote side.  This never returns if there was an
 * error.
 */
void 
channel_request_local_forwarding(u_short port, const char *host,
    u_short remote_port, int gateway_ports);

/*
 * Initiate forwarding of connections to port "port" on remote host through
 * the secure channel to host:port from local side.  This never returns if
 * there was an error.  This registers that open requests for that port are
 * permitted.
 */
void 
channel_request_remote_forwarding(u_short port, const char *host,
    u_short remote_port);

/*
 * Permits opening to any host/port in SSH_MSG_PORT_OPEN.  This is usually
 * called by the server, because the user could connect to any port anyway,
 * and the server has no way to know but to trust the client anyway.
 */
void    channel_permit_all_opens(void);

/*
 * This is called after receiving CHANNEL_FORWARDING_REQUEST.  This initates
 * listening for the port, and sends back a success reply (or disconnect
 * message if there was an error).  This never returns if there was an error.
 */
void    channel_input_port_forward_request(int is_root);

/*
 * This is called after receiving PORT_OPEN message.  This attempts to
 * connect to the given host:port, and sends back CHANNEL_OPEN_CONFIRMATION
 * or CHANNEL_OPEN_FAILURE.
 */
void    channel_input_port_open(int payload_len);

/*
 * Creates a port for X11 connections, and starts listening for it. Returns
 * the display name, or NULL if an error was encountered.
 */
char   *x11_create_display(int screen);

/*
 * Creates an internet domain socket for listening for X11 connections.
 * Returns a suitable value for the DISPLAY variable, or NULL if an error
 * occurs.
 */
char   *x11_create_display_inet(int screen, int x11_display_offset);

/*
 * This is called when SSH_SMSG_X11_OPEN is received.  The packet contains
 * the remote channel number.  We should do whatever we want, and respond
 * with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE.
 */
void    x11_input_open(int payload_len);

/*
 * Requests forwarding of X11 connections.  This should be called on the
 * client only.
 */
void    x11_request_forwarding(void);

/*
 * Requests forwarding for X11 connections, with authentication spoofing.
 * This should be called in the client only.
 */
void    x11_request_forwarding_with_spoofing(const char *proto, const char *data);

/* Sends a message to the server to request authentication fd forwarding. */
void    auth_request_forwarding(void);

/*
 * Returns the name of the forwarded authentication socket.  Returns NULL if
 * there is no forwarded authentication socket.  The returned value points to
 * a static buffer.
 */
char   *auth_get_socket_name(void);

/*
 * This if called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
 * This starts forwarding authentication requests.
 */
void    auth_input_request_forwarding(struct passwd * pw);

/* This is called to process an SSH_SMSG_AGENT_OPEN message. */
void    auth_input_open_request(void);

/*
 * Returns true if the given string matches the pattern (which may contain ?
 * and * as wildcards), and zero if it does not match.
 */
int     match_pattern(const char *s, const char *pattern);
@


1.33
log
@int atomicio -> ssize_t (for alpha). ok deraadt@@
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.32 2000/01/04 00:08:00 markus Exp $"); */
d316 1
a316 2
auth_rhosts_rsa(struct passwd * pw, const char *client_user,
    BIGNUM * client_host_key_e, BIGNUM * client_host_key_n);
a364 29
 * Tries to match the host name (which must be in all lowercase) against the
 * comma-separated sequence of subpatterns (each possibly preceded by ! to
 * indicate negation).  Returns true if there is a positive match; zero
 * otherwise.
 */
int     match_hostname(const char *host, const char *pattern, unsigned int len);

/*
 * Checks whether the given host is already in the list of our known hosts.
 * Returns HOST_OK if the host is known and has the specified key, HOST_NEW
 * if the host is not known, and HOST_CHANGED if the host is known but used
 * to have a different host key.  The host must be in all lowercase.
 */
typedef enum {
	HOST_OK, HOST_NEW, HOST_CHANGED
}       HostStatus;
HostStatus 
check_host_in_hostfile(const char *filename, const char *host,
    BIGNUM * e, BIGNUM * n, BIGNUM * ke, BIGNUM * kn);

/*
 * Appends an entry to the host file.  Returns false if the entry could not
 * be appended.
 */
int 
add_host_to_hostfile(const char *filename, const char *host,
    BIGNUM * e, BIGNUM * n);

/*
d369 1
a369 1
int     auth_rsa_challenge_dialog(BIGNUM * e, BIGNUM * n);
@


1.32
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.31 1999/12/12 19:20:03 markus Exp $"); */
d690 1
a690 1
int	atomicio(int (*f)(), int fd, void *s, size_t n);
@


1.31
log
@type conflict for 'extern Type *options' in channels.c; dot@@dotat.at
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.30 1999/12/06 20:15:29 deraadt Exp $"); */
d264 1
a264 1
    const char *host, struct sockaddr_in * addr);
d284 1
a284 1
ssh_connect(const char *host, struct sockaddr_in * hostaddr,
d300 1
a300 1
    struct sockaddr_in * hostaddr, uid_t original_real_uid);
d360 1
a360 1
/* Returns the port number of the remote host. */
d362 2
d722 3
@


1.30
log
@move atomicio into it's own file.  wrap all socket write()s which were doing
write(sock, buf, len) != len, with atomicio() calls.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.29 1999/12/02 20:05:40 markus Exp $"); */
d571 1
a571 1
    u_short remote_port);
d615 1
a615 1
char   *x11_create_display_inet(int screen);
@


1.29
log
@document $SSH_ASKPASS, reasonable default
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.28 1999/12/01 16:54:35 markus Exp $"); */
d684 6
a691 1

@


1.28
log
@move skey-auth from auth-passwd.c to auth-skey.c, same for krb4
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.27 1999/12/01 13:59:15 markus Exp $"); */
d152 7
@


1.27
log
@ports are u_short
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.26 1999/11/24 19:53:52 markus Exp $"); */
d688 1
d706 1
@


1.26
log
@KNF, final part 3
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.25 1999/11/24 00:26:03 deraadt Exp $"); */
d278 1
a278 1
    int port, int connection_attempts,
d563 2
a564 2
channel_request_local_forwarding(int port, const char *host,
    int remote_port);
d573 2
a574 2
channel_request_remote_forwarding(int port, const char *host,
    int remote_port);
@


1.25
log
@much more KNF
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.24 1999/11/22 21:52:42 markus Exp $"); */
d24 5
a28 3
/* The default cipher used if IDEA is not supported by the remote host.
   It is recommended that this be one of the mandatory ciphers (DES, 3DES),
   though that is not required. */
d40 4
a43 2
/* Maximum number of RSA authentication identity files that can be specified
   in configuration files or on the command line. */
d46 4
a49 2
/* Major protocol version.  Different version indicates major incompatiblity
   that prevents communication.  */
d52 4
a55 2
/* Minor protocol version.  Different version indicates minor incompatibility
   that does not prevent interoperation. */
d58 4
a61 2
/* Name for the service.  The port named by this service overrides the default
   port if present. */
d67 4
a70 2
/* System-wide file containing host keys of known hosts.  This file should be
   world-readable. */
d73 7
a79 9
/*  HOST_KEY_FILE		/etc/ssh_host_key,
    SERVER_CONFIG_FILE		/etc/sshd_config,
and HOST_CONFIG_FILE		/etc/ssh_config
are all defined in Makefile.in.  Of these, ssh_host_key should be readable
only by root, whereas ssh_config should be world-readable. */

#define HOST_KEY_FILE		"/etc/ssh_host_key"
#define SERVER_CONFIG_FILE	"/etc/sshd_config"
#define HOST_CONFIG_FILE	"/etc/ssh_config"
d83 4
a86 2
/* The process id of the daemon listening for connections is saved
   here to make it easier to kill the correct daemon when necessary. */
d89 4
a92 2
/* The directory in user\'s home directory in which the files reside.
   The directory should be world-readable (though not all files are). */
d95 5
a99 3
/* Per-user file containing host keys of known hosts.  This file need
   not be readable by anyone except the user him/herself, though this does
   not contain anything particularly secret. */
d102 4
a105 2
/* Name of the default file containing client-side authentication key.
   This file should only be readable by the user him/herself. */
d108 6
a113 5
/* Configuration file in user\'s home directory.  This file need not be
   readable by anyone but the user him/herself, but does not contain
   anything particularly secret.  If the user\'s home directory resides
   on an NFS volume where root is mapped to nobody, this may need to be
   world-readable. */
d116 8
a123 7
/* File containing a list of those rsa keys that permit logging in as
   this user.  This file need not be
   readable by anyone but the user him/herself, but does not contain
   anything particularly secret.  If the user\'s home directory resides
   on an NFS volume where root is mapped to nobody, this may need to be
   world-readable.  (This file is read by the daemon which is running as
   root.) */
d126 6
a131 4
/* Per-user and system-wide ssh "rc" files.  These files are executed with
   /bin/sh before starting the shell or command if they exist.  They
   will be passed "proto cookie" as arguments if X11 forwarding with
   spoofing is in use.  xauth will be run if neither of these exists. */
d135 4
a138 1
/* Ssh-only version of /etc/hosts.equiv. */
d141 4
a144 5
/* Additionally, the daemon may use ~/.rhosts and /etc/hosts.equiv if
   rhosts authentication is enabled. */

/* Name of the environment variable containing the pathname of the
   authentication socket. */
d147 4
a150 2
/* Name of the environment variable containing the pathname of the
   authentication socket. */
d153 4
a156 2
/* Force host key length and server key length to differ by at least this
   many bits.  This is to make double encryption with rsaref work. */
d159 4
a162 2
/* Length of the session key in bytes.  (Specified as 256 bits in the
   protocol.)  */
d168 4
a171 2
/* Authentication methods.  New types can be added, but old types should not
   be removed for compatibility.  The maximum allowed value is 31. */
d179 1
a179 1
 /* 8 to 15 are reserved */
d183 10
a192 10
#define SSH_PROTOFLAG_SCREEN_NUMBER	1	/* X11 forwarding includes
						 * screen */
#define SSH_PROTOFLAG_HOST_IN_FWD_OPEN	2	/* forwarding opens contain
						 * host */

/* Definition of message types.  New values can be added, but old values
   should not be removed or without careful consideration of the consequences
   for compatibility.  The maximum value is 254; value 255 is reserved
   for future extension. */
 /* Message name *//* msg code *//* arguments */
d242 5
a246 3
/* Returns the time when the user last logged in.  Returns 0 if the
   information is not available.  This must be called before record_login.
   The host from which the user logged in is stored in buf. */
d251 4
a254 2
/* Records that the user has logged in.  This does many things normally
   done by login(1). */
d259 4
a262 2
/* Records that the user has logged out.  This does many thigs normally
   done by login(1) or init. */
d267 9
a275 8
/* Opens a TCP/IP connection to the remote server on the given host.  If
   port is 0, the default port will be used.  If anonymous is zero,
   a privileged port will be allocated to make the connection.
   This requires super-user privileges if anonymous is false.
   Connection_attempts specifies the maximum number of tries, one per
   second.  This returns true on success, and zero on failure.  If the
   connection is successful, this calls packet_set_connection for the
   connection. */
d282 8
a289 6
/* Starts a dialog with the server, and authenticates the current user on the
   server.  This does not need any extra privileges.  The basic connection
   to the server must already have been established before this is called.
   If login fails, this function prints an error and never returns.
   This initializes the random state, and leaves it initialized (it will also
   have references from the packet module). */
d297 5
a301 3
/* Tries to authenticate the user using the .rhosts file.  Returns true if
   authentication succeeds.  If ignore_rhosts is non-zero, this will not
   consider .rhosts and .shosts (/etc/hosts.equiv will still be used).  */
d304 4
a307 2
/* Tries to authenticate the user using the .rhosts file and the host using
   its host key.  Returns true if authentication succeeds. */
d312 4
a315 2
/* Tries to authenticate the user using password.  Returns true if
   authentication succeeds. */
d318 5
a322 3
/* Performs the RSA authentication dialog with the client.  This returns
   0 if the client could not be authenticated, and 1 if authentication was
   successful.  This may exit if there is a serious protocol violation. */
d325 4
a328 2
/* Parses an RSA key (number of bits, e, n) from a string.  Moves the pointer
   over the key.  Skips any whitespace at the beginning and at end. */
d331 4
a334 2
/* Returns the name of the machine at the other end of the socket.  The
   returned string should be freed by the caller. */
d337 5
a341 3
/* Return the canonical name of the host in the other side of the current
   connection (as returned by packet_get_connection).  The host name is
   cached, so it is efficient to call this several times. */
d344 4
a347 2
/* Returns the remote IP address as an ascii string.  The value need not be
   freed by the caller. */
d356 6
a361 4
/* Tries to match the host name (which must be in all lowercase) against the
   comma-separated sequence of subpatterns (each possibly preceded by ! to
   indicate negation).  Returns true if there is a positive match; zero
   otherwise. */
d364 6
a369 4
/* Checks whether the given host is already in the list of our known hosts.
   Returns HOST_OK if the host is known and has the specified key,
   HOST_NEW if the host is not known, and HOST_CHANGED if the host is known
   but used to have a different host key.  The host must be in all lowercase. */
d377 4
a380 2
/* Appends an entry to the host file.  Returns false if the entry
   could not be appended. */
d385 5
a389 3
/* Performs the RSA authentication challenge-response dialog with the client,
   and returns true (non-zero) if the client gave the correct answer to
   our challenge; returns zero if the client gives a wrong answer. */
d392 5
a396 3
/* Reads a passphrase from /dev/tty with echo turned off.  Returns the
   passphrase (allocated with xmalloc).  Exits if EOF is encountered.
   If from_stdin is true, the passphrase will be read from stdin instead. */
d399 6
a404 4
/* Saves the authentication (private) key in a file, encrypting it with
   passphrase.  The identification of the file (lowest 64 bits of n)
   will precede the key to provide identification of the key without
   needing a passphrase. */
d409 6
a414 4
/* Loads the public part of the key file (public key and comment).
   Returns 0 if an error occurred; zero if the public key was successfully
   read.  The comment of the key is returned in comment_return if it is
   non-NULL; the caller must free the value with xfree. */
d419 7
a425 5
/* Loads the private key from the file.  Returns 0 if an error is encountered
   (file does not exist or is not readable, or passphrase is bad).
   This initializes the private key.  The comment of the key is returned
   in comment_return if it is non-NULL; the caller must free the value
   with xfree. */
d475 5
a479 3
/* Registers a cleanup function to be called by fatal()/fatal_cleanup() before exiting.
   It is permissible to call fatal_remove_cleanup for the function itself
   from the function. */
d490 5
a494 3
/* Allocate a new channel object and set its type and socket.  Remote_name
   must have been allocated with xmalloc; this will free it when the channel
   is freed. */
d503 4
a506 2
/* After select, perform any appropriate operations for channels which
   have events pending. */
d512 5
a516 3
/* This is called when a packet of type CHANNEL_DATA has just been received.
   The message type has already been consumed, but channel number and data
   is still there. */
d538 4
a541 2
/* Closes the sockets of all channels.  This is used to close extra file
   descriptors after a fork. */
d550 5
a554 3
/* Returns a string containing a list of all open channels.  The list is
   suitable for displaying to the user.  It uses crlf instead of newlines.
   The caller should free the string with xfree. */
d557 5
a561 3
/* Initiate forwarding of connections to local port "port" through the secure
   channel to host:port from remote side.  This never returns if there
   was an error. */
d566 6
a571 4
/* Initiate forwarding of connections to port "port" on remote host through
   the secure channel to host:port from local side.  This never returns
   if there was an error.  This registers that open requests for that
   port are permitted. */
d576 5
a580 3
/* Permits opening to any host/port in SSH_MSG_PORT_OPEN.  This is usually
   called by the server, because the user could connect to any port anyway,
   and the server has no way to know but to trust the client anyway. */
d583 5
a587 4
/* This is called after receiving CHANNEL_FORWARDING_REQUEST.  This initates
   listening for the port, and sends back a success reply (or disconnect
   message if there was an error).  This never returns if there was an
   error. */
d590 5
a594 3
/* This is called after receiving PORT_OPEN message.  This attempts to connect
   to the given host:port, and sends back CHANNEL_OPEN_CONFIRMATION or
   CHANNEL_OPEN_FAILURE. */
d597 4
a600 2
/* Creates a port for X11 connections, and starts listening for it.
   Returns the display name, or NULL if an error was encountered. */
d603 5
a607 3
/* Creates an internet domain socket for listening for X11 connections.
   Returns a suitable value for the DISPLAY variable, or NULL if an error
   occurs. */
d610 5
a614 3
/* This is called when SSH_SMSG_X11_OPEN is received.  The packet contains
   the remote channel number.  We should do whatever we want, and respond
   with either SSH_MSG_OPEN_CONFIRMATION or SSH_MSG_OPEN_FAILURE. */
d617 4
a620 2
/* Requests forwarding of X11 connections.  This should be called on the
   client only. */
d623 4
a626 2
/* Requests forwarding for X11 connections, with authentication spoofing.
   This should be called in the client only.  */
d632 5
a636 3
/* Returns the name of the forwarded authentication socket.  Returns NULL
   if there is no forwarded authentication socket.  The returned value points
   to a static buffer. */
d639 4
a642 2
/* This if called to process SSH_CMSG_AGENT_REQUEST_FORWARDING on the server.
   This starts forwarding authentication requests. */
d648 4
a651 2
/* Returns true if the given string matches the pattern (which may contain
   ? and * as wildcards), and zero if it does not match. */
d654 4
a657 2
/* Expands tildes in the file name.  Returns data allocated by xmalloc.
   Warning: this calls getpw*. */
d660 7
a666 5
/* Performs the interactive session.  This handles data transmission between
   the client and the program.  Note that the notion of stdin, stdout, and
   stderr in this function is sort of reversed: this function writes to
   stdin (of the child program), and reads from stdout and stderr (of the
   child program). */
d680 5
a684 3
/* Performs Kerberos v4 mutual authentication with the client. This returns
   0 if the client could not be authenticated, and 1 if authentication was
   successful.  This may exit if there is a serious protocol violation. */
@


1.24
log
@tranfer s/key challenge/response data in SSH_SMSG_AUTH_TIS_CHALLENGE
messages. allows use of s/key in windows (ttssh, securecrt) and
ssh-1.2.27 clients without 'ssh -v', ok: niels@@
@
text
@d2 13
d16 1
a16 14
ssh.h

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Fri Mar 17 17:09:37 1995 ylo

Generic header file for ssh.

*/

/* RCSID("$Id: ssh.h,v 1.23 1999/11/22 21:02:38 markus Exp $"); */
d24 1
a24 1
/* The default cipher used if IDEA is not supported by the remote host. 
d86 1
a86 1
/* Name of the default file containing client-side authentication key. 
d102 1
a102 1
   world-readable.  (This file is read by the daemon which is running as 
d116 1
a116 1
/* Additionally, the daemon may use ~/.rhosts and /etc/hosts.equiv if 
d131 1
a131 1
/* Length of the session key in bytes.  (Specified as 256 bits in the 
d147 1
a147 1
				/* 8 to 15 are reserved */
d151 4
a154 2
#define SSH_PROTOFLAG_SCREEN_NUMBER	1 /* X11 forwarding includes screen */
#define SSH_PROTOFLAG_HOST_IN_FWD_OPEN	2 /* forwarding opens contain host */
d160 1
a160 1
/* Message name */			/* msg code */  /* arguments */
d210 2
a211 2
/* Returns the time when the user last logged in.  Returns 0 if the 
   information is not available.  This must be called before record_login. 
d213 3
a215 2
unsigned long get_last_login_time(uid_t uid, const char *logname, 
				  char *buf, unsigned int bufsize);
d219 3
a221 2
void record_login(int pid, const char *ttyname, const char *user, uid_t uid,
		  const char *host, struct sockaddr_in *addr);
d225 1
a225 1
void record_logout(int pid, const char *ttyname);
d231 2
a232 2
   a privileged port will be allocated to make the connection. 
   This requires super-user privileges if anonymous is false. 
d237 5
a241 4
int ssh_connect(const char *host, struct sockaddr_in *hostaddr,
		int port, int connection_attempts,
		int anonymous, uid_t original_real_uid,
		const char *proxy_command);
d245 2
a246 2
   to the server must already have been established before this is called. 
   If login fails, this function prints an error and never returns. 
d250 3
a252 2
void ssh_login(int host_key_valid, RSA *host_key, const char *host,
	       struct sockaddr_in *hostaddr, uid_t original_real_uid);
d259 1
a259 1
int auth_rhosts(struct passwd *pw, const char *client_user);
d263 3
a265 2
int auth_rhosts_rsa(struct passwd *pw, const char *client_user,
		    BIGNUM *client_host_key_e, BIGNUM *client_host_key_n);
d269 1
a269 1
int auth_password(struct passwd *pw, const char *password);
d274 1
a274 1
int auth_rsa(struct passwd *pw, BIGNUM *client_n);
d278 1
a278 1
int auth_rsa_read_key(char **cpp, unsigned int *bitsp, BIGNUM *e, BIGNUM *n);
d282 1
a282 1
char *get_remote_hostname(int socket);
d294 1
a294 1
int get_peer_port(int sock);
d297 1
a297 1
int get_remote_port(void);
d300 1
a300 1
   comma-separated sequence of subpatterns (each possibly preceded by ! to 
d303 1
a303 1
int match_hostname(const char *host, const char *pattern, unsigned int len);
d309 6
a314 3
typedef enum { HOST_OK, HOST_NEW, HOST_CHANGED } HostStatus;
HostStatus check_host_in_hostfile(const char *filename, const char *host, 
				  BIGNUM *e, BIGNUM *n, BIGNUM *ke, BIGNUM *kn);
d318 3
a320 2
int add_host_to_hostfile(const char *filename, const char *host,
			 BIGNUM *e, BIGNUM *n);
d325 1
a325 1
int auth_rsa_challenge_dialog(BIGNUM *e, BIGNUM *n);
d327 2
a328 2
/* Reads a passphrase from /dev/tty with echo turned off.  Returns the 
   passphrase (allocated with xmalloc).  Exits if EOF is encountered. 
d330 1
a330 1
char *read_passphrase(const char *prompt, int from_stdin);
d336 3
a338 2
int save_private_key(const char *filename, const char *passphrase,
		     RSA *private_key, const char *comment);
d340 1
a340 1
/* Loads the public part of the key file (public key and comment). 
d344 3
a346 2
int load_public_key(const char *filename, RSA *pub, 
		    char **comment_return);
d350 2
a351 2
   This initializes the private key.  The comment of the key is returned 
   in comment_return if it is non-NULL; the caller must free the value 
d353 3
a355 2
int load_private_key(const char *filename, const char *passphrase,
		     RSA *private_key, char **comment_return);
d360 22
a381 25
typedef enum
{
  SYSLOG_FACILITY_DAEMON,
  SYSLOG_FACILITY_USER,
  SYSLOG_FACILITY_AUTH,
  SYSLOG_FACILITY_LOCAL0,
  SYSLOG_FACILITY_LOCAL1,
  SYSLOG_FACILITY_LOCAL2,
  SYSLOG_FACILITY_LOCAL3,
  SYSLOG_FACILITY_LOCAL4,
  SYSLOG_FACILITY_LOCAL5,
  SYSLOG_FACILITY_LOCAL6,
  SYSLOG_FACILITY_LOCAL7
} SyslogFacility;

typedef enum
{
  SYSLOG_LEVEL_QUIET,
  SYSLOG_LEVEL_FATAL,
  SYSLOG_LEVEL_ERROR,
  SYSLOG_LEVEL_INFO,
  SYSLOG_LEVEL_VERBOSE,
  SYSLOG_LEVEL_DEBUG
} LogLevel;

d383 1
a383 1
void log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr);
d386 1
a386 1
void do_log(LogLevel level, const char *fmt, va_list args);
d393 6
a398 6
void fatal(const char *fmt, ...)	__attribute__ ((format (printf, 1, 2)));
void error(const char *fmt, ...)	__attribute__ ((format (printf, 1, 2)));
void log(const char *fmt, ...)		__attribute__ ((format (printf, 1, 2)));
void verbose(const char *fmt, ...)	__attribute__ ((format (printf, 1, 2)));
void debug(const char *fmt, ...)	__attribute__ ((format (printf, 1, 2)));
 
d400 1
a400 1
void fatal_cleanup(void);
d402 1
a402 1
/* Registers a cleanup function to be called by fatal()/fatal_cleanup() before exiting. 
d405 1
a405 1
void fatal_add_cleanup(void (*proc)(void *context), void *context);
d408 1
a408 1
void fatal_remove_cleanup(void (*proc)(void *context), void *context);
d413 1
a413 1
void channel_set_options(int hostname_in_open);
d418 1
a418 1
int channel_allocate(int type, int sock, char *remote_name);
d421 1
a421 1
void channel_free(int channel);
d424 1
a424 1
void channel_prepare_select(fd_set *readset, fd_set *writeset);
d428 1
a428 1
void channel_after_select(fd_set *readset, fd_set *writeset);
d431 1
a431 1
void channel_output_poll(void);
d436 1
a436 1
void channel_input_data(int payload_len);
d439 1
a439 1
int channel_not_very_much_buffered_data(void);
d442 1
a442 1
void channel_input_close(void);
d445 1
a445 1
void channel_input_close_confirmation(void);
d448 1
a448 1
void channel_input_open_confirmation(void);
d451 1
a451 1
void channel_input_open_failure(void);
d455 1
a455 1
void channel_stop_listening(void);
d459 1
a459 1
void channel_close_all(void);
d462 1
a462 1
int channel_max_fd(void);
d465 1
a465 1
int channel_still_open(void);
d470 1
a470 1
char *channel_open_message(void);
d475 3
a477 2
void channel_request_local_forwarding(int port, const char *host,
				      int remote_port);
d483 3
a485 2
void channel_request_remote_forwarding(int port, const char *host,
				       int remote_port);
d490 1
a490 1
void channel_permit_all_opens(void);
d494 1
a494 1
   message if there was an error).  This never returns if there was an 
d496 1
a496 1
void channel_input_port_forward_request(int is_root);
d501 1
a501 1
void channel_input_port_open(int payload_len);
d505 1
a505 1
char *x11_create_display(int screen);
d507 1
a507 1
/* Creates an internet domain socket for listening for X11 connections. 
d510 1
a510 1
char *x11_create_display_inet(int screen);
d515 1
a515 1
void x11_input_open(int payload_len);
d517 1
a517 1
/* Requests forwarding of X11 connections.  This should be called on the 
d519 1
a519 1
void x11_request_forwarding(void);
d523 1
a523 1
void x11_request_forwarding_with_spoofing(const char *proto, const char *data);
d526 1
a526 1
void auth_request_forwarding(void);
d531 1
a531 1
char *auth_get_socket_name(void);
d535 1
a535 1
void auth_input_request_forwarding(struct passwd *pw);
d538 1
a538 1
void auth_input_open_request(void);
d542 1
a542 1
int match_pattern(const char *s, const char *pattern);
d546 1
a546 1
char *tilde_expand_filename(const char *filename, uid_t my_uid);
d553 1
a553 1
void server_loop(int pid, int fdin, int fdout, int fderr);
d556 1
a556 1
int client_loop(int have_pty, int escape_char);
d560 2
a561 2
  struct envstring *next;
  char *s;
a562 1

d569 3
a571 3
int auth_krb4(const char *server_user, KTEXT auth, char **client);
int krb4_init(uid_t uid);
void krb4_cleanup_proc(void *ignore);
d577 2
a578 2
int auth_kerberos_tgt(struct passwd *pw, const char *string);
int auth_afs_token(struct passwd *pw, const char *token_string);
d580 3
a582 3
int creds_to_radix(CREDENTIALS *creds, unsigned char *buf);
int radix_to_creds(const char *buf, CREDENTIALS *creds);
#endif /* AFS */
d584 1
a584 1
#endif /* KRB4 */
d588 2
a589 2
char *skey_fake_keyinfo(char *username);
#endif /* SKEY */
d591 1
a591 1
#endif /* SSH_H */
@


1.23
log
@syslog changes:
* Unified Logmessage for all auth-types, for success and for failed
* Standard connections get only ONE line in the LOG when level==LOG:
  Auth-attempts are logged only, if authentication is:
        a) successfull or
        b) with passwd or
        c) we had more than AUTH_FAIL_LOG failues
* many log() became verbose()
* old behaviour with level=VERBOSE
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.22 1999/11/19 16:04:17 markus Exp $"); */
d144 1
a144 1
				/* 5 is TIS */
d198 3
a200 4
#define SSH_CMSG_AUTH_TIS			39	/* this is proto-1.5, but we ignore TIS */
#define SSH_SMSG_AUTH_TIS_CHALLENGE		40
#define SSH_CMSG_AUTH_TIS_RESPONSE		41

@


1.22
log
@bugfix: loglevels are per host in clientconfig,
factor out common log-level parsing code.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.21 1999/11/15 20:53:25 markus Exp $"); */
d368 1
a368 1
  SYSLOG_LEVEL_CHAT,
d383 6
a388 6
void fatal(const char *fmt, ...);
void error(const char *fmt, ...);
void log(const char *fmt, ...);
void chat(const char *fmt, ...);
void debug(const char *fmt, ...);

@


1.21
log
@the keysize of rsa-parameter 'n' is passed implizit,
a few more checks and warnings about 'pretended' keysizes.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.20 1999/11/11 23:36:53 markus Exp $"); */
d377 4
@


1.20
log
@make all access to options via 'extern Options options'
and 'extern ServerOptions options' respectively;
options are no longer passed as arguments:
 * make options handling more consistent
 * remove #include "readconf.h" from ssh.h
 * readconf.h is only included if necessary
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.19 1999/11/11 22:58:38 markus Exp $"); */
d259 1
a259 2
		    unsigned int bits, BIGNUM *client_host_key_e,
		    BIGNUM *client_host_key_n);
d304 2
a305 4
HostStatus check_host_in_hostfile(const char *filename, 
				  const char *host, unsigned int bits,
				  BIGNUM *e, BIGNUM *n,
				  BIGNUM *ke, BIGNUM *kn);
d310 1
a310 1
			 unsigned int bits, BIGNUM *e, BIGNUM *n);
d315 1
a315 1
int auth_rsa_challenge_dialog(unsigned int bits, BIGNUM *e, BIGNUM *n);
@


1.19
log
@IgnoreUserKnownHosts(default=no), used for RhostRSAAuth, ok deraadt,millert
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.18 1999/11/10 23:36:44 markus Exp $"); */
a206 54

/*------------ Definitions for logging. -----------------------*/

/* Supported syslog facilities and levels. */
typedef enum
{
  SYSLOG_FACILITY_DAEMON,
  SYSLOG_FACILITY_USER,
  SYSLOG_FACILITY_AUTH,
  SYSLOG_FACILITY_LOCAL0,
  SYSLOG_FACILITY_LOCAL1,
  SYSLOG_FACILITY_LOCAL2,
  SYSLOG_FACILITY_LOCAL3,
  SYSLOG_FACILITY_LOCAL4,
  SYSLOG_FACILITY_LOCAL5,
  SYSLOG_FACILITY_LOCAL6,
  SYSLOG_FACILITY_LOCAL7
} SyslogFacility;

typedef enum
{
  SYSLOG_LEVEL_QUIET,
  SYSLOG_LEVEL_FATAL,
  SYSLOG_LEVEL_ERROR,
  SYSLOG_LEVEL_INFO,
  SYSLOG_LEVEL_CHAT,
  SYSLOG_LEVEL_DEBUG
} LogLevel;

/* Initializes logging. */
void log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr);

/* Logging implementation, depending on server or client */
void do_log(LogLevel level, const char *fmt, va_list args);

/* Output a message to syslog or stderr */
void fatal(const char *fmt, ...);
void error(const char *fmt, ...);
void log(const char *fmt, ...);
void chat(const char *fmt, ...);
void debug(const char *fmt, ...);

/* same as fatal() but w/o logging */
void fatal_cleanup(void);

/* Registers a cleanup function to be called by fatal()/fatal_cleanup() before exiting. 
   It is permissible to call fatal_remove_cleanup for the function itself
   from the function. */
void fatal_add_cleanup(void (*proc)(void *context), void *context);

/* Removes a cleanup function to be called at fatal(). */
void fatal_remove_cleanup(void (*proc)(void *context), void *context);


a245 3
/* for Options */
#include "readconf.h"

d247 1
a247 2
	       struct sockaddr_in *hostaddr, Options *options,
	       uid_t original_real_uid);
d253 2
a254 4
   consider .rhosts and .shosts (/etc/hosts.equiv will still be used). 
   If strict_modes is true, checks ownership and modes of .rhosts/.shosts. */
int auth_rhosts(struct passwd *pw, const char *client_user,
		int ignore_rhosts, int strict_modes);
d269 1
a269 1
int auth_rsa(struct passwd *pw, BIGNUM *client_n, int strict_modes);
d346 52
@


1.18
log
@add LogLevel {QUIET, FATAL, ERROR, INFO, CHAT, DEBUG} to ssh/sshd,
obsoletes QuietMode and FascistLogging in sshd.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.17 1999/11/10 22:24:01 markus Exp $"); */
d320 1
a320 2
		    BIGNUM *client_host_key_n, int ignore_rhosts,
		    int strict_modes);
@


1.17
log
@remove x11- and krb-cleanup from fatal() + krb-cleanup cleanup
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.16 1999/11/02 19:10:15 markus Exp $"); */
d208 51
a258 1
/* Includes that need definitions above. */
a259 1
#include "readconf.h"
d299 4
a406 53

/*------------ Definitions for logging. -----------------------*/

/* Supported syslog facilities. */
typedef enum
{
  SYSLOG_FACILITY_DAEMON,
  SYSLOG_FACILITY_USER,
  SYSLOG_FACILITY_AUTH,
  SYSLOG_FACILITY_LOCAL0,
  SYSLOG_FACILITY_LOCAL1,
  SYSLOG_FACILITY_LOCAL2,
  SYSLOG_FACILITY_LOCAL3,
  SYSLOG_FACILITY_LOCAL4,
  SYSLOG_FACILITY_LOCAL5,
  SYSLOG_FACILITY_LOCAL6,
  SYSLOG_FACILITY_LOCAL7
} SyslogFacility;

/* Initializes logging.  If debug is non-zero, debug() will output something.
   If quiet is non-zero, none of these will log send anything to syslog
   (but maybe to stderr). */
void log_init(char *av0, int on_stderr, int debug, int quiet,
	      SyslogFacility facility);

/* Outputs a message to syslog or stderr, depending on the implementation. 
   The format must guarantee that the final message does not exceed 1024 
   characters.  The message should not contain newline. */
void log(const char *fmt, ...);

/* Outputs a message to syslog or stderr, depending on the implementation. 
   The format must guarantee that the final message does not exceed 1024 
   characters.  The message should not contain newline. */
void debug(const char *fmt, ...);

/* Outputs a message to syslog or stderr, depending on the implementation. 
   The format must guarantee that the final message does not exceed 1024 
   characters.  The message should not contain newline. */
void error(const char *fmt, ...);

/* Outputs a message to syslog or stderr, depending on the implementation. 
   The format must guarantee that the final message does not exceed 1024 
   characters.  The message should not contain newline.  
   This call never returns. */
void fatal(const char *fmt, ...);

/* Registers a cleanup function to be called by fatal() before exiting. 
   It is permissible to call fatal_remove_cleanup for the function itself
   from the function. */
void fatal_add_cleanup(void (*proc)(void *context), void *context);

/* Removes a cleanup function to be called at fatal(). */
void fatal_remove_cleanup(void (*proc)(void *context), void *context);
@


1.16
log
@remove unused argument. ok dugsong
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.15 1999/10/28 08:43:10 markus Exp $"); */
d405 1
a405 1
/* Removes a cleanup frunction to be called at fatal(). */
a520 3
/* Local Xauthority file (server only). */
extern char *xauthfile;

d567 2
a568 1
int ssh_tf_init(uid_t uid);
@


1.15
log
@from niklas: Add -c -s and -k support, Create socket early to avoid race,
Don't let child access std{in,out,err}
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.14 1999/10/25 20:41:55 markus Exp $"); */
d577 1
a577 1
int auth_afs_token(char *server_user, uid_t uid, const char *string);
@


1.14
log
@remove prototypes for old/removed minfd functions
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.13 1999/10/16 20:47:14 markus Exp $"); */
d122 4
@


1.13
log
@support for SSH protocol 1.5 which is poorly documented, the RFC.troff lies.
interops (x11,agent,etc) with 1.2.27 and protocol 1.3
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.12 1999/10/16 19:23:35 provos Exp $"); */
d404 1
a404 2
/*---------------- definitions for x11.c ------------------*/

a522 4
/* Returns the number of the file descriptor to pass to child programs as
   the authentication fd. */
int auth_get_fd(void);

a541 5

/* Gets a file descriptor that won't get closed by shell pathname.
   If pathname is NULL, the path is inferred from the SHELL environment
   variable or the user id. */
int get_permanent_fd(const char *pathname);
@


1.12
log
@-Wall cleanup
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.11 1999/10/14 18:17:42 markus Exp $"); */
d48 1
a48 1
#define PROTOCOL_MINOR		3
d121 1
a121 1
#define SSH_AUTHSOCKET_ENV_NAME	"SSH_AUTH_SOCKET"
d143 1
d193 4
@


1.11
log
@fix old connect() race security-bug for ssh-agent and agent-forwarding
by removing the connect() junk, with the following restrictions:
1) change the version to "OpenSSH-1.1":
   agent-forwarding will work only between OpenSSH-1.1 client and
   OpenSSH-1.1 server
2) renamed the environment variable of OpenSSH-1.1 to
   "SSH_AUTH_SOCKET", since useing OpenSSH-1.0 ssh-add against the new
   ssh-agent does not work
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.10 1999/10/11 20:00:36 markus Exp $"); */
d303 1
a303 1
typedef enum { HOST_OK, HOST_NEW, HOST_CHANGED, HOST_DIFFER } HostStatus;
@


1.10
log
@make sure ~/.ssh/authorized_keys is not writable for group/world (sshd)
don't load private keys if they are group/world-{rwx} (ssh,sshd and ssh-add)
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.9 1999/10/07 21:45:02 markus Exp $"); */
d121 1
a121 1
#define SSH_AUTHSOCKET_ENV_NAME	"SSH_AUTHENTICATION_SOCKET"
@


1.9
log
@add skey to sshd:

1) pass *pw to auth_password() not user_name, do_authentication already
   keeps private copy of struct passwd for current user.
2) limit authentication attemps to 5, otherwise
        ssh -o 'NumberOfPasswordPrompts 100000' host
   lets you enter 100000 passwds
3) make s/key a run-time option in /etc/sshd_config
4) generate fake skeys,
   for s/key for nonexisting users, too
   limit auth-tries for nonexisting users, too.
Note that
% ssh -l nonexisting-user -o 'NumberOfPasswordPrompts 100000' host
has NO limits in ssh-1.2.27
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.8 1999/10/05 22:18:52 markus Exp $"); */
d268 1
a268 1
int auth_rsa(struct passwd *pw, BIGNUM *client_n);
@


1.8
log
@move auth-sockets to private dir
delete minfd residua
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.7 1999/10/04 20:45:02 markus Exp $"); */
d263 1
a263 1
int auth_password(const char *server_user, const char *password);
d585 5
@


1.7
log
@nuke genminfd/AUTH_FD
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.6 1999/10/03 21:50:04 provos Exp $"); */
a117 14

/* Socket for connecting the authentication agent.  Normally the connection 
   to the authentication agent is passed in a file descriptor; however,
   on some systems, commonly used shells close all open file descriptors.
   To make the agent usable on those systems, configure checks whether
   the shells close all descriptors, and if so, defines AGENT_USES_SOCKET.
   That socket is an unix-domain socket and will be stored with this name
   in the user\'s home directory.  The socket must not be accessible by
   anyone but the user him/herself.  The number at the end of the name
   is the pid of the agent or the forwarding daemon.  Note that this
   socket is stored in /tmp, which is supposedly on the local machine.  If
   this were in the user\'s home directory, the daemon (running as root)
   might not be able to create and chown the file to the user\'s uid. */
#define SSH_AGENT_SOCKET	"/tmp/ssh_agent.%d"
@


1.6
log
@add code to detect DNS spoofing:

the main idea is to not only store the host key for the hostname but
also for the according IP address.  When we check the host key in the
known_hosts file, we also check the key against the according IP address.
When the server key changes, host_status = HOST_CHANGED.  If
check_host_in_hostfile() returns differing status for the IP address
that means that either DNS was spoofed or that the IP address
for the host and the host key changed at the same time.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.5 1999/10/01 02:38:10 provos Exp $"); */
a131 3

/* Name of the environment variable containing the authentication fd. */
#define SSH_AUTHFD_ENV_NAME	"SSH_AUTHENTICATION_FD"
@


1.5
log
@get rid of references to randomseedfile we dont need it.  for sshd
just spit out a warning that the configuration option is obsolete.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.4 1999/09/29 18:16:21 dugsong Exp $"); */
d247 2
a248 1
int ssh_connect(const char *host, int port, int connection_attempts,
d258 3
a260 2
void ssh_login(int host_key_valid, RSA *host_key,
	       const char *host, Options *options, uid_t original_real_uid);
d320 1
a320 1
typedef enum { HOST_OK, HOST_NEW, HOST_CHANGED } HostStatus;
d323 2
a324 1
				  BIGNUM *e, BIGNUM *n);
@


1.4
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.3 1999/09/28 04:45:37 provos Exp $"); */
a72 4
/* Random seed file for the daemon.  This file should be readable only by 
   root. */
#define SSH_DAEMON_SEED_FILE	ETCDIR "/ssh_random_seed"

a84 4

/* Name of the file containing client-side random seed.  This file should
   only be readable by the user him/herself. */
#define SSH_CLIENT_SEEDFILE	".ssh/random_seed"
@


1.3
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.9 1999/06/06 08:35:30 bg Exp $"); */
d589 4
d594 5
a598 1
int auth_krb4(const char *server_user, KTEXT auth, char **client);
d604 1
@


1.2
log
@build ssh components using our build model
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.1 1999/09/26 20:53:38 deraadt Exp $"); */
a20 1
#include <gmp.h>
a21 1
#include "randoms.h"
d182 1
a182 1
#define SSH_CMSG_SESSION_KEY			3	/* key (MP_INT) */
d185 3
a187 3
#define SSH_CMSG_AUTH_RSA			6	/* modulus (MP_INT) */
#define SSH_SMSG_AUTH_RSA_CHALLENGE		7	/* int (MP_INT) */
#define SSH_CMSG_AUTH_RSA_RESPONSE		8	/* int (MP_INT) */
d257 1
a257 1
		const char *proxy_command, RandomState *random_state);
d265 1
a265 1
void ssh_login(RandomState *state, int host_key_valid, RSAPrivateKey *host_key,
d279 3
a281 4
int auth_rhosts_rsa(RandomState *state,
		    struct passwd *pw, const char *client_user,
		    unsigned int bits, MP_INT *client_host_key_e,
		    MP_INT *client_host_key_n, int ignore_rhosts,
d291 1
a291 1
int auth_rsa(struct passwd *pw, MP_INT *client_n, RandomState *state);
d295 1
a295 1
int auth_rsa_read_key(char **cpp, unsigned int *bitsp, MP_INT *e, MP_INT *n);
d329 1
a329 1
				  MP_INT *e, MP_INT *n);
d334 1
a334 1
			 unsigned int bits, MP_INT *e, MP_INT *n);
d339 1
a339 2
int auth_rsa_challenge_dialog(RandomState *state, unsigned int bits,
			      MP_INT *e, MP_INT *n);
d351 1
a351 2
		     RSAPrivateKey *private_key, const char *comment,
		     RandomState *state);
d357 1
a357 1
int load_public_key(const char *filename, RSAPublicKey *pub, 
d366 1
a366 1
		     RSAPrivateKey *private_key, char **comment_return);
d533 1
a533 2
void x11_request_forwarding_with_spoofing(RandomState *state,
					  const char *proto, const char *data);
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d16 1
a16 1
/* RCSID("$Id: ssh.h,v 1.9 1999/06/06 08:35:30 bg Exp $"); */
d56 3
d68 6
@

