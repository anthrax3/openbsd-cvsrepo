head	1.128;
access;
symbols
	OPENBSD_6_0:1.128.0.6
	OPENBSD_6_0_BASE:1.128
	OPENBSD_5_9:1.128.0.2
	OPENBSD_5_9_BASE:1.128
	OPENBSD_5_8:1.123.0.2
	OPENBSD_5_8_BASE:1.123
	OPENBSD_5_7:1.120.0.2
	OPENBSD_5_7_BASE:1.120
	OPENBSD_5_6:1.113.0.4
	OPENBSD_5_6_BASE:1.113
	OPENBSD_5_5:1.109.0.4
	OPENBSD_5_5_BASE:1.109
	OPENBSD_5_4:1.106.0.2
	OPENBSD_5_4_BASE:1.106
	OPENBSD_5_3:1.105.0.2
	OPENBSD_5_3_BASE:1.105
	OPENBSD_5_2:1.103.0.4
	OPENBSD_5_2_BASE:1.103
	OPENBSD_5_1_BASE:1.103
	OPENBSD_5_1:1.103.0.2
	OPENBSD_5_0:1.101.0.2
	OPENBSD_5_0_BASE:1.101
	OPENBSD_4_9:1.100.0.2
	OPENBSD_4_9_BASE:1.100
	OPENBSD_4_8:1.96.0.2
	OPENBSD_4_8_BASE:1.96
	OPENBSD_4_7:1.94.0.2
	OPENBSD_4_7_BASE:1.94
	OPENBSD_4_6:1.90.0.10
	OPENBSD_4_6_BASE:1.90
	OPENBSD_4_5:1.90.0.6
	OPENBSD_4_5_BASE:1.90
	OPENBSD_4_4:1.90.0.4
	OPENBSD_4_4_BASE:1.90
	OPENBSD_4_3:1.90.0.2
	OPENBSD_4_3_BASE:1.90
	OPENBSD_4_2:1.89.0.6
	OPENBSD_4_2_BASE:1.89
	OPENBSD_4_1:1.89.0.2
	OPENBSD_4_1_BASE:1.89
	OPENBSD_4_0:1.89.0.4
	OPENBSD_4_0_BASE:1.89
	OPENBSD_3_9:1.75.0.2
	OPENBSD_3_9_BASE:1.75
	OPENBSD_3_8:1.72.0.2
	OPENBSD_3_8_BASE:1.72
	OPENBSD_3_7:1.71.0.2
	OPENBSD_3_7_BASE:1.71
	OPENBSD_3_6:1.70.0.2
	OPENBSD_3_6_BASE:1.70
	OPENBSD_3_5:1.69.0.2
	OPENBSD_3_5_BASE:1.69
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	OPENBSD_3_3:1.66.0.2
	OPENBSD_3_3_BASE:1.66
	OPENBSD_3_2:1.63.0.2
	OPENBSD_3_2_BASE:1.63
	OPENBSD_3_1:1.53.0.2
	OPENBSD_3_1_BASE:1.53
	OPENBSD_3_0:1.46.0.2
	OPENBSD_3_0_BASE:1.46
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.128
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.127;
commitid	ut5A0buLh4mhCTFu;

1.127
date	2015.12.11.02.31.47;	author mmcc;	state Exp;
branches;
next	1.126;
commitid	f7EpsYIFQYQNXTtF;

1.126
date	2015.10.15.23.51.40;	author djm;	state Exp;
branches;
next	1.125;
commitid	Zt9fWcnXm9hrhBex;

1.125
date	2015.09.13.14.39.16;	author tim;	state Exp;
branches;
next	1.124;
commitid	o7lHtj0fKIytZvfO;

1.124
date	2015.09.13.13.48.19;	author tim;	state Exp;
branches;
next	1.123;
commitid	NW90gE6hQljbGHOS;

1.123
date	2015.07.03.03.43.18;	author djm;	state Exp;
branches;
next	1.122;
commitid	cnvu1kGgoFFYv6D3;

1.122
date	2015.03.26.12.32.38;	author naddy;	state Exp;
branches;
next	1.121;
commitid	JGJuZfGPlEPARMlR;

1.121
date	2015.03.25.19.29.58;	author markus;	state Exp;
branches;
next	1.120;
commitid	xqm2X2yKw04uLAqN;

1.120
date	2015.02.21.21.46.57;	author halex;	state Exp;
branches;
next	1.119;
commitid	QWjVVHZcMggC30Yj;

1.119
date	2015.02.03.00.34.14;	author halex;	state Exp;
branches;
next	1.118;
commitid	gEFzhgC4zeG5GoHx;

1.118
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.117;
commitid	P7KG9D8zB61mMUPV;

1.117
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	Uu5nFG3wCl0LACBb;

1.116
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.115;
commitid	YqNUZu0ifI7Q95nk;

1.115
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.114;
commitid	EbtriidyZdsmXksl;

1.114
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.113;
commitid	9QOFSShUOtA0kQLF;

1.113
date	2014.07.09.14.15.56;	author benno;	state Exp;
branches;
next	1.112;
commitid	n0qCY601cUpDfT6v;

1.112
date	2014.07.03.03.15.01;	author djm;	state Exp;
branches;
next	1.111;
commitid	VJ0X3iAW2wI3TDCk;

1.111
date	2014.06.27.18.50.39;	author markus;	state Exp;
branches;
next	1.110;
commitid	9HzmkMLFofU34iy0;

1.110
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.109;
commitid	1h9UxAQmwdaqUzyX;

1.109
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.108;

1.108
date	2013.12.19.00.10.30;	author djm;	state Exp;
branches;
next	1.107;

1.107
date	2013.12.15.18.17.26;	author pascal;	state Exp;
branches;
next	1.106;

1.106
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.105;

1.105
date	2012.12.05.15.42.52;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2012.12.02.20.42.15;	author djm;	state Exp;
branches;
next	1.103;

1.103
date	2011.10.18.23.37.42;	author djm;	state Exp;
branches;
next	1.102;

1.102
date	2011.10.18.05.00.48;	author djm;	state Exp;
branches;
next	1.101;

1.101
date	2011.05.04.21.15.29;	author djm;	state Exp;
branches;
next	1.100;

1.100
date	2010.08.31.12.33.38;	author djm;	state Exp;
branches;
next	1.99;

1.99
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.16.04.06.06;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2010.08.12.23.34.38;	author tedu;	state Exp;
branches;
next	1.96;

1.96
date	2010.05.14.00.47.22;	author djm;	state Exp;
branches;
next	1.95;

1.95
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.94;

1.94
date	2010.03.01.11.07.06;	author otto;	state Exp;
branches;
next	1.93;

1.93
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2010.02.08.10.50.20;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2009.08.27.17.44.52;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.09.11.38.01;	author sobrado;	state Exp;
branches;
next	1.89;

1.89
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.87;

1.87
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.86;

1.86
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.85;

1.85
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.84;

1.84
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.83;

1.83
date	2006.07.09.15.27.59;	author stevesk;	state Exp;
branches;
next	1.82;

1.82
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.81;

1.81
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.80;

1.80
date	2006.05.30.11.46.38;	author mk;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.20.17.10.19;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2006.03.13.10.26.52;	author dtucker;	state Exp;
branches;
next	1.75;

1.75
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2005.11.12.18.37.59;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.72;

1.72
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2005.03.10.22.01.06;	author deraadt;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2003.06.16.10.22.45;	author markus;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2003.06.11.11.18.38;	author djm;	state Exp;
branches;
next	1.66;

1.66
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2003.01.23.13.50.27;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2002.11.21.23.03.51;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2002.09.19.15.51.23;	author markus;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2002.06.26.14.51.33;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.15.01.27.48;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.15.00.07.38;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.15.00.01.36;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2002.06.10.17.36.23;	author stevesk;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.05.21.55.44;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.05.20.56.39;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.05.19.57.12;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.21.22.44.05;	author rees;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2002.03.21.10.21.20;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.29.14.27.57;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.24.07.29.43;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.21.10.06.43;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.02.08.38.50;	author djm;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2001.08.03.10.31.30;	author jakob;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.01.22.03.33;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.27.06.26.36;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.26.04.59.59;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.25.08.25.40;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.24.05.35.33;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.06.23.19.35;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.02.16.41.20;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.18.21.57.42;	author markus;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.04.14.16.27.57;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.14.04.31.01;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.09.15.12.23;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.08.13.03.00;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.26.08.07.08;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.12.22.02.02;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.02.18.54.31;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.04.15.32.25;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.21.19.05.56;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.20.21.33.42;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.13.18.14.13;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.07.20.27.54;	author deraadt;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.09.05.19.18.48;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.28.03.50.54;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.19.21.34.43;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.16.08.27.21;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.20.01.39.44;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.26.20.56.29;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	99.12.02.20.05.40;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.11.24.16.13.45;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.11.23.22.25.55;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.11.16.22.49.28;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.11.15.20.53.24;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.14.17.53.48;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.02.19.42.36;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.10.27.23.35.32;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.10.17.20.39.11;	author dugsong;	state Exp;
branches;
next	1.5;

1.5
date	99.10.11.20.24.54;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.21.14.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.15.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.37;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.37;	author deraadt;	state Exp;
branches;
next	;

1.16.2.1
date	2000.09.01.18.23.23;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2000.11.08.21.31.19;	author jason;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.03.12.15.44.15;	author jason;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.03.21.18.53.08;	author jason;	state Exp;
branches;
next	;

1.22.2.1
date	2001.02.16.20.13.16;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.02.19.17.19.26;	author jason;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.03.21.19.46.29;	author jason;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.05.07.21.09.35;	author jason;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.36.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.36.2.4;

1.36.2.4
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.46.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.46.2.4;

1.46.2.4
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.53.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.53.2.3;

1.53.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.63.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.63.2.2;

1.63.2.2
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.66.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.66.2.2;

1.66.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.68.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.69.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	;

1.70.2.1
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.71.2.1
date	2005.09.04.18.40.08;	author brad;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.72.2.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.75.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.128
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@/* $OpenBSD: ssh-add.c,v 1.127 2015/12/11 02:31:47 mmcc Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Adds an identity to the authentication server, or removes an identity.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * SSH2 implementation,
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <openssl/evp.h>

#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "xmalloc.h"
#include "ssh.h"
#include "rsa.h"
#include "log.h"
#include "sshkey.h"
#include "sshbuf.h"
#include "authfd.h"
#include "authfile.h"
#include "pathnames.h"
#include "misc.h"
#include "ssherr.h"
#include "digest.h"

/* argv0 */
extern char *__progname;

/* Default files to add */
static char *default_files[] = {
	_PATH_SSH_CLIENT_ID_RSA,
	_PATH_SSH_CLIENT_ID_DSA,
	_PATH_SSH_CLIENT_ID_ECDSA,
	_PATH_SSH_CLIENT_ID_ED25519,
#ifdef WITH_SSH1
	_PATH_SSH_CLIENT_IDENTITY,
#endif
	NULL
};

static int fingerprint_hash = SSH_FP_HASH_DEFAULT;

/* Default lifetime (0 == forever) */
static int lifetime = 0;

/* User has to confirm key use */
static int confirm = 0;

/* we keep a cache of one passphrase */
static char *pass = NULL;
static void
clear_pass(void)
{
	if (pass) {
		explicit_bzero(pass, strlen(pass));
		free(pass);
		pass = NULL;
	}
}

static int
delete_file(int agent_fd, const char *filename, int key_only)
{
	struct sshkey *public, *cert = NULL;
	char *certpath = NULL, *comment = NULL;
	int r, ret = -1;

	if ((r = sshkey_load_public(filename, &public,  &comment)) != 0) {
		printf("Bad key file %s: %s\n", filename, ssh_err(r));
		return -1;
	}
	if ((r = ssh_remove_identity(agent_fd, public)) == 0) {
		fprintf(stderr, "Identity removed: %s (%s)\n", filename, comment);
		ret = 0;
	} else
		fprintf(stderr, "Could not remove identity \"%s\": %s\n",
		    filename, ssh_err(r));

	if (key_only)
		goto out;

	/* Now try to delete the corresponding certificate too */
	free(comment);
	comment = NULL;
	xasprintf(&certpath, "%s-cert.pub", filename);
	if ((r = sshkey_load_public(certpath, &cert, &comment)) != 0) {
		if (r != SSH_ERR_SYSTEM_ERROR || errno != ENOENT)
			error("Failed to load certificate \"%s\": %s",
			    certpath, ssh_err(r));
		goto out;
	}

	if (!sshkey_equal_public(cert, public))
		fatal("Certificate %s does not match private key %s",
		    certpath, filename);

	if ((r = ssh_remove_identity(agent_fd, cert)) == 0) {
		fprintf(stderr, "Identity removed: %s (%s)\n", certpath,
		    comment);
		ret = 0;
	} else
		fprintf(stderr, "Could not remove identity \"%s\": %s\n",
		    certpath, ssh_err(r));

 out:
	sshkey_free(cert);
	sshkey_free(public);
	free(certpath);
	free(comment);

	return ret;
}

/* Send a request to remove all identities. */
static int
delete_all(int agent_fd)
{
	int ret = -1;

	if (ssh_remove_all_identities(agent_fd, 2) == 0)
		ret = 0;
	/* ignore error-code for ssh1 */
	ssh_remove_all_identities(agent_fd, 1);

	if (ret == 0)
		fprintf(stderr, "All identities removed.\n");
	else
		fprintf(stderr, "Failed to remove all identities.\n");

	return ret;
}

static int
add_file(int agent_fd, const char *filename, int key_only)
{
	struct sshkey *private, *cert;
	char *comment = NULL;
	char msg[1024], *certpath = NULL;
	int r, fd, ret = -1;
	struct sshbuf *keyblob;

	if (strcmp(filename, "-") == 0) {
		fd = STDIN_FILENO;
		filename = "(stdin)";
	} else if ((fd = open(filename, O_RDONLY)) < 0) {
		perror(filename);
		return -1;
	}

	/*
	 * Since we'll try to load a keyfile multiple times, permission errors
	 * will occur multiple times, so check perms first and bail if wrong.
	 */
	if (fd != STDIN_FILENO) {
		if (sshkey_perm_ok(fd, filename) != 0) {
			close(fd);
			return -1;
		}
	}
	if ((keyblob = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshkey_load_file(fd, keyblob)) != 0) {
		fprintf(stderr, "Error loading key \"%s\": %s\n",
		    filename, ssh_err(r));
		sshbuf_free(keyblob);
		close(fd);
		return -1;
	}
	close(fd);

	/* At first, try empty passphrase */
	if ((r = sshkey_parse_private_fileblob(keyblob, "", &private,
	    &comment)) != 0 && r != SSH_ERR_KEY_WRONG_PASSPHRASE) {
		fprintf(stderr, "Error loading key \"%s\": %s\n",
		    filename, ssh_err(r));
		goto fail_load;
	}
	/* try last */
	if (private == NULL && pass != NULL) {
		if ((r = sshkey_parse_private_fileblob(keyblob, pass, &private,
		    &comment)) != 0 && r != SSH_ERR_KEY_WRONG_PASSPHRASE) {
			fprintf(stderr, "Error loading key \"%s\": %s\n",
			    filename, ssh_err(r));
			goto fail_load;
		}
	}
	if (private == NULL) {
		/* clear passphrase since it did not work */
		clear_pass();
		snprintf(msg, sizeof msg, "Enter passphrase for %s%s: ",
		    filename, confirm ? " (will confirm each use)" : "");
		for (;;) {
			pass = read_passphrase(msg, RP_ALLOW_STDIN);
			if (strcmp(pass, "") == 0)
				goto fail_load;
			if ((r = sshkey_parse_private_fileblob(keyblob, pass,
			    &private, &comment)) == 0)
				break;
			else if (r != SSH_ERR_KEY_WRONG_PASSPHRASE) {
				fprintf(stderr,
				    "Error loading key \"%s\": %s\n",
				    filename, ssh_err(r));
 fail_load:
				clear_pass();
				sshbuf_free(keyblob);
				return -1;
			}
			clear_pass();
			snprintf(msg, sizeof msg,
			    "Bad passphrase, try again for %s%s: ", filename,
			    confirm ? " (will confirm each use)" : "");
		}
	}
	if (comment == NULL || *comment == '\0')
		comment = xstrdup(filename);
	sshbuf_free(keyblob);

	if ((r = ssh_add_identity_constrained(agent_fd, private, comment,
	    lifetime, confirm)) == 0) {
		fprintf(stderr, "Identity added: %s (%s)\n", filename, comment);
		ret = 0;
		if (lifetime != 0)
			fprintf(stderr,
			    "Lifetime set to %d seconds\n", lifetime);
		if (confirm != 0)
			fprintf(stderr,
			    "The user must confirm each use of the key\n");
	} else {
		fprintf(stderr, "Could not add identity \"%s\": %s\n",
		    filename, ssh_err(r));
	}

	/* Skip trying to load the cert if requested */
	if (key_only)
		goto out;

	/* Now try to add the certificate flavour too */
	xasprintf(&certpath, "%s-cert.pub", filename);
	if ((r = sshkey_load_public(certpath, &cert, NULL)) != 0) {
		if (r != SSH_ERR_SYSTEM_ERROR || errno != ENOENT)
			error("Failed to load certificate \"%s\": %s",
			    certpath, ssh_err(r));
		goto out;
	}

	if (!sshkey_equal_public(cert, private)) {
		error("Certificate %s does not match private key %s",
		    certpath, filename);
		sshkey_free(cert);
		goto out;
	} 

	/* Graft with private bits */
	if ((r = sshkey_to_certified(private)) != 0) {
		error("%s: sshkey_to_certified: %s", __func__, ssh_err(r));
		sshkey_free(cert);
		goto out;
	}
	if ((r = sshkey_cert_copy(cert, private)) != 0) {
		error("%s: key_cert_copy: %s", __func__, ssh_err(r));
		sshkey_free(cert);
		goto out;
	}
	sshkey_free(cert);

	if ((r = ssh_add_identity_constrained(agent_fd, private, comment,
	    lifetime, confirm)) != 0) {
		error("Certificate %s (%s) add failed: %s", certpath,
		    private->cert->key_id, ssh_err(r));
		goto out;
	}
	fprintf(stderr, "Certificate added: %s (%s)\n", certpath,
	    private->cert->key_id);
	if (lifetime != 0)
		fprintf(stderr, "Lifetime set to %d seconds\n", lifetime);
	if (confirm != 0)
		fprintf(stderr, "The user must confirm each use of the key\n");
 out:
	free(certpath);
	free(comment);
	sshkey_free(private);

	return ret;
}

static int
update_card(int agent_fd, int add, const char *id)
{
	char *pin = NULL;
	int r, ret = -1;

	if (add) {
		if ((pin = read_passphrase("Enter passphrase for PKCS#11: ",
		    RP_ALLOW_STDIN)) == NULL)
			return -1;
	}

	if ((r = ssh_update_card(agent_fd, add, id, pin == NULL ? "" : pin,
	    lifetime, confirm)) == 0) {
		fprintf(stderr, "Card %s: %s\n",
		    add ? "added" : "removed", id);
		ret = 0;
	} else {
		fprintf(stderr, "Could not %s card \"%s\": %s\n",
		    add ? "add" : "remove", id, ssh_err(r));
		ret = -1;
	}
	free(pin);
	return ret;
}

static int
list_identities(int agent_fd, int do_fp)
{
	char *fp;
	int r, had_identities = 0;
	struct ssh_identitylist *idlist;
	size_t i;
#ifdef WITH_SSH1
	int version = 1;
#else
	int version = 2;
#endif

	for (; version <= 2; version++) {
		if ((r = ssh_fetch_identitylist(agent_fd, version,
		    &idlist)) != 0) {
			if (r != SSH_ERR_AGENT_NO_IDENTITIES)
				fprintf(stderr, "error fetching identities for "
				    "protocol %d: %s\n", version, ssh_err(r));
			continue;
		}
		for (i = 0; i < idlist->nkeys; i++) {
			had_identities = 1;
			if (do_fp) {
				fp = sshkey_fingerprint(idlist->keys[i],
				    fingerprint_hash, SSH_FP_DEFAULT);
				printf("%u %s %s (%s)\n",
				    sshkey_size(idlist->keys[i]),
				    fp == NULL ? "(null)" : fp,
				    idlist->comments[i],
				    sshkey_type(idlist->keys[i]));
				free(fp);
			} else {
				if ((r = sshkey_write(idlist->keys[i],
				    stdout)) != 0) {
					fprintf(stderr, "sshkey_write: %s\n",
					    ssh_err(r));
					continue;
				}
				fprintf(stdout, " %s\n", idlist->comments[i]);
			}
		}
		ssh_free_identitylist(idlist);
	}
	if (!had_identities) {
		printf("The agent has no identities.\n");
		return -1;
	}
	return 0;
}

static int
lock_agent(int agent_fd, int lock)
{
	char prompt[100], *p1, *p2;
	int r, passok = 1, ret = -1;

	strlcpy(prompt, "Enter lock password: ", sizeof(prompt));
	p1 = read_passphrase(prompt, RP_ALLOW_STDIN);
	if (lock) {
		strlcpy(prompt, "Again: ", sizeof prompt);
		p2 = read_passphrase(prompt, RP_ALLOW_STDIN);
		if (strcmp(p1, p2) != 0) {
			fprintf(stderr, "Passwords do not match.\n");
			passok = 0;
		}
		explicit_bzero(p2, strlen(p2));
		free(p2);
	}
	if (passok) {
		if ((r = ssh_lock_agent(agent_fd, lock, p1)) == 0) {
			fprintf(stderr, "Agent %slocked.\n", lock ? "" : "un");
			ret = 0;
		} else {
			fprintf(stderr, "Failed to %slock agent: %s\n",
			    lock ? "" : "un", ssh_err(r));
		}
	}
	explicit_bzero(p1, strlen(p1));
	free(p1);
	return (ret);
}

static int
do_file(int agent_fd, int deleting, int key_only, char *file)
{
	if (deleting) {
		if (delete_file(agent_fd, file, key_only) == -1)
			return -1;
	} else {
		if (add_file(agent_fd, file, key_only) == -1)
			return -1;
	}
	return 0;
}

static void
usage(void)
{
	fprintf(stderr, "usage: %s [options] [file ...]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -l          List fingerprints of all identities.\n");
	fprintf(stderr, "  -E hash     Specify hash algorithm used for fingerprints.\n");
	fprintf(stderr, "  -L          List public key parameters of all identities.\n");
	fprintf(stderr, "  -k          Load only keys and not certificates.\n");
	fprintf(stderr, "  -c          Require confirmation to sign using identities\n");
	fprintf(stderr, "  -t life     Set lifetime (in seconds) when adding identities.\n");
	fprintf(stderr, "  -d          Delete identity.\n");
	fprintf(stderr, "  -D          Delete all identities.\n");
	fprintf(stderr, "  -x          Lock agent.\n");
	fprintf(stderr, "  -X          Unlock agent.\n");
	fprintf(stderr, "  -s pkcs11   Add keys from PKCS#11 provider.\n");
	fprintf(stderr, "  -e pkcs11   Remove keys provided by PKCS#11 provider.\n");
}

int
main(int argc, char **argv)
{
	extern char *optarg;
	extern int optind;
	int agent_fd;
	char *pkcs11provider = NULL;
	int r, i, ch, deleting = 0, ret = 0, key_only = 0;
	int xflag = 0, lflag = 0, Dflag = 0;

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	OpenSSL_add_all_algorithms();

	setvbuf(stdout, NULL, _IOLBF, 0);

	/* First, get a connection to the authentication agent. */
	switch (r = ssh_get_authentication_socket(&agent_fd)) {
	case 0:
		break;
	case SSH_ERR_AGENT_NOT_PRESENT:
		fprintf(stderr, "Could not open a connection to your "
		    "authentication agent.\n");
		exit(2);
	default:
		fprintf(stderr, "Error connecting to agent: %s\n", ssh_err(r));
		exit(2);
	}

	while ((ch = getopt(argc, argv, "klLcdDxXE:e:s:t:")) != -1) {
		switch (ch) {
		case 'E':
			fingerprint_hash = ssh_digest_alg_by_name(optarg);
			if (fingerprint_hash == -1)
				fatal("Invalid hash algorithm \"%s\"", optarg);
			break;
		case 'k':
			key_only = 1;
			break;
		case 'l':
		case 'L':
			if (lflag != 0)
				fatal("-%c flag already specified", lflag);
			lflag = ch;
			break;
		case 'x':
		case 'X':
			if (xflag != 0)
				fatal("-%c flag already specified", xflag);
			xflag = ch;
			break;
		case 'c':
			confirm = 1;
			break;
		case 'd':
			deleting = 1;
			break;
		case 'D':
			Dflag = 1;
			break;
		case 's':
			pkcs11provider = optarg;
			break;
		case 'e':
			deleting = 1;
			pkcs11provider = optarg;
			break;
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid lifetime\n");
				ret = 1;
				goto done;
			}
			break;
		default:
			usage();
			ret = 1;
			goto done;
		}
	}

	if ((xflag != 0) + (lflag != 0) + (Dflag != 0) > 1)
		fatal("Invalid combination of actions");
	else if (xflag) {
		if (lock_agent(agent_fd, xflag == 'x' ? 1 : 0) == -1)
			ret = 1;
		goto done;
	} else if (lflag) {
		if (list_identities(agent_fd, lflag == 'l' ? 1 : 0) == -1)
			ret = 1;
		goto done;
	} else if (Dflag) {
		if (delete_all(agent_fd) == -1)
			ret = 1;
		goto done;
	}

	argc -= optind;
	argv += optind;
	if (pkcs11provider != NULL) {
		if (update_card(agent_fd, !deleting, pkcs11provider) == -1)
			ret = 1;
		goto done;
	}
	if (argc == 0) {
		char buf[PATH_MAX];
		struct passwd *pw;
		struct stat st;
		int count = 0;

		if ((pw = getpwuid(getuid())) == NULL) {
			fprintf(stderr, "No user found with uid %u\n",
			    (u_int)getuid());
			ret = 1;
			goto done;
		}

		for (i = 0; default_files[i]; i++) {
			snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir,
			    default_files[i]);
			if (stat(buf, &st) < 0)
				continue;
			if (do_file(agent_fd, deleting, key_only, buf) == -1)
				ret = 1;
			else
				count++;
		}
		if (count == 0)
			ret = 1;
	} else {
		for (i = 0; i < argc; i++) {
			if (do_file(agent_fd, deleting, key_only,
			    argv[i]) == -1)
				ret = 1;
		}
	}
	clear_pass();

done:
	ssh_close_authentication_socket(agent_fd);
	return ret;
}
@


1.127
log
@Remove NULL-checks before sshkey_free().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.126 2015/10/15 23:51:40 djm Exp $ */
d476 1
@


1.126
log
@fix some signed/unsigned integer type mismatches in format
strings; reported by Nicholas Lemonias
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.125 2015/09/13 14:39:16 tim Exp $ */
d145 2
a146 4
	if (cert != NULL)
		sshkey_free(cert);
	if (public != NULL)
		sshkey_free(public);
@


1.125
log
@- Fix error message: passphrase needs to be at least 5 characters, not 4.
- Remove unused function argument.
- Remove two unnecessary variables.

OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.124 2015/09/13 13:48:19 tim Exp $ */
d379 1
a379 1
				printf("%d %s %s (%s)\n",
@


1.124
log
@When adding keys to the agent, don't ignore the comment of keys for which the
user is prompted for a passphrase.

Tweak and OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.123 2015/07/03 03:43:18 djm Exp $ */
d213 2
a214 2
	if ((r = sshkey_parse_private_fileblob(keyblob, "", filename,
	    &private, &comment)) != 0 && r != SSH_ERR_KEY_WRONG_PASSPHRASE) {
d221 2
a222 3
		if ((r = sshkey_parse_private_fileblob(keyblob, pass, filename,
		    &private, &comment)) != 0 &&
		    r != SSH_ERR_KEY_WRONG_PASSPHRASE) {
d238 1
a238 1
			    filename, &private, &comment)) == 0)
@


1.123
log
@delete support for legacy v00 certificates; "sure" markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.122 2015/03/26 12:32:38 naddy Exp $ */
d88 1
a88 1
/* we keep a cache of one passphrases */
a228 2
	if (comment == NULL)
		comment = xstrdup(filename);
d232 2
a233 2
		snprintf(msg, sizeof msg, "Enter passphrase for %.200s%s: ",
		    comment, confirm ? " (will confirm each use)" : "");
d239 1
a239 1
			    filename, &private, NULL)) == 0)
a246 1
				free(comment);
d252 1
a252 1
			    "Bad passphrase, try again for %.200s%s: ", comment,
d256 2
@


1.122
log
@don't try to load .ssh/identity by default if SSH1 is disabled; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.121 2015/03/25 19:29:58 markus Exp $ */
d297 1
a297 2
	if ((r = sshkey_to_certified(private,
	    sshkey_cert_is_legacy(cert))) != 0) {
@


1.121
log
@ignore v1 errors on ssh-add -D; only try v2 keys on -l/-L (unless WITH_SSH1)
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.120 2015/02/21 21:46:57 halex Exp $ */
d74 1
d76 1
@


1.120
log
@make "ssh-add -d" properly remove a corresponding certificate, and also
not whine and fail if there is none

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.119 2015/02/03 00:34:14 halex Exp $ */
d159 1
a159 1
	if (ssh_remove_all_identities(agent_fd, 1) == 0)
d161 2
a162 3
	/* ignore error-code for ssh2 */
	/* XXX revisit */
	ssh_remove_all_identities(agent_fd, 2);
d358 1
a358 1
	int version, r, had_identities = 0;
d361 5
d367 1
a367 1
	for (version = 1; version <= 2; version++) {
@


1.119
log
@slightly extend the passphrase prompt if running with -c in order to
give the user a chance to notice if unintentionally running without it

wording tweak and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.118 2015/01/28 22:36:00 djm Exp $ */
d123 4
a126 1
	if ((r = sshkey_load_public(certpath, &cert, &comment)) == 0)
d128 2
d134 1
a134 1
	if (ssh_remove_identity(agent_fd, cert)) {
d139 2
a140 1
		fprintf(stderr, "Could not remove identity: %s\n", certpath);
@


1.118
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.117 2015/01/16 06:40:12 deraadt Exp $ */
d227 2
a228 2
		snprintf(msg, sizeof msg, "Enter passphrase for %.200s: ",
		    comment);
d248 2
a249 1
			    "Bad passphrase, try again for %.200s: ", comment);
@


1.117
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.116 2015/01/14 20:05:27 djm Exp $ */
d370 2
a371 1
				    sshkey_size(idlist->keys[i]), fp,
@


1.116
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.115 2014/12/21 22:27:56 djm Exp $ */
a39 1
#include <sys/param.h>
d50 1
d563 1
a563 1
		char buf[MAXPATHLEN];
@


1.115
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.114 2014/11/26 18:34:51 millert Exp $ */
d44 1
d56 2
a57 2
#include "key.h"
#include "buffer.h"
d99 1
a99 1
delete_file(AuthenticationConnection *ac, const char *filename, int key_only)
d101 1
a101 1
	Key *public = NULL, *cert = NULL;
d103 1
a103 1
	int ret = -1;
d105 2
a106 3
	public = key_load_public(filename, &comment);
	if (public == NULL) {
		printf("Bad key file %s\n", filename);
d109 1
a109 1
	if (ssh_remove_identity(ac, public)) {
d113 2
a114 1
		fprintf(stderr, "Could not remove identity: %s\n", filename);
d123 1
a123 1
	if ((cert = key_load_public(certpath, &comment)) == NULL)
d125 1
a125 1
	if (!key_equal_public(cert, public))
d129 1
a129 1
	if (ssh_remove_identity(ac, cert)) {
d138 1
a138 1
		key_free(cert);
d140 1
a140 1
		key_free(public);
d149 1
a149 1
delete_all(AuthenticationConnection *ac)
d153 1
a153 1
	if (ssh_remove_all_identities(ac, 1))
d156 2
a157 1
	ssh_remove_all_identities(ac, 2);
d168 1
a168 1
add_file(AuthenticationConnection *ac, const char *filename, int key_only)
d170 1
a170 1
	Key *private, *cert;
d173 2
a174 2
	int r, fd, perms_ok, ret = -1;
	Buffer keyblob;
d189 1
a189 2
		perms_ok = key_perm_ok(fd, filename);
		if (!perms_ok) {
d194 6
a199 3
	buffer_init(&keyblob);
	if (!key_load_file(fd, filename, &keyblob)) {
		buffer_free(&keyblob);
d206 6
a211 3
	if ((r = sshkey_parse_private_fileblob(&keyblob, "", filename,
	    &private, &comment)) != 0 && r != SSH_ERR_KEY_WRONG_PASSPHRASE)
		fatal("Cannot parse %s: %s", filename, ssh_err(r));
d214 1
a214 1
		if ((r = sshkey_parse_private_fileblob(&keyblob, pass, filename,
d216 5
a220 2
		    r != SSH_ERR_KEY_WRONG_PASSPHRASE)
			fatal("Cannot parse %s: %s", filename, ssh_err(r));
d231 10
a240 1
			if (strcmp(pass, "") == 0) {
d243 1
a243 1
				buffer_free(&keyblob);
a245 7
			if ((r = sshkey_parse_private_fileblob(&keyblob,
			     pass, filename, &private, NULL)) != 0 &&
			    r != SSH_ERR_KEY_WRONG_PASSPHRASE)
				fatal("Cannot parse %s: %s",
					    filename, ssh_err(r));
			if (private != NULL)
				break;
d251 1
a251 1
	buffer_free(&keyblob);
d253 2
a254 2
	if (ssh_add_identity_constrained(ac, private, comment, lifetime,
	    confirm)) {
d264 2
a265 1
		fprintf(stderr, "Could not add identity: %s\n", filename);
d274 4
a277 1
	if ((cert = key_load_public(certpath, NULL)) == NULL)
d279 1
d281 1
a281 1
	if (!key_equal_public(cert, private)) {
d284 1
a284 1
		key_free(cert);
d289 9
a297 3
	if (key_to_certified(private, key_cert_is_legacy(cert)) != 0) {
		error("%s: key_to_certified failed", __func__);
		key_free(cert);
d300 1
a300 2
	key_cert_copy(cert, private);
	key_free(cert);
d302 5
a306 4
	if (!ssh_add_identity_constrained(ac, private, comment,
	    lifetime, confirm)) {
		error("Certificate %s (%s) add failed", certpath,
		    private->cert->key_id);
d315 1
a315 2
	if (certpath != NULL)
		free(certpath);
d317 1
a317 1
	key_free(private);
d323 1
a323 1
update_card(AuthenticationConnection *ac, int add, const char *id)
d326 1
a326 1
	int ret = -1;
d334 2
a335 2
	if (ssh_update_card(ac, add, id, pin == NULL ? "" : pin,
	    lifetime, confirm)) {
d340 2
a341 2
		fprintf(stderr, "Could not %s card: %s\n",
		    add ? "add" : "remove", id);
d349 1
a349 1
list_identities(AuthenticationConnection *ac, int do_fp)
d351 4
a354 4
	Key *key;
	char *comment, *fp;
	int had_identities = 0;
	int version;
d357 8
a364 3
		for (key = ssh_get_first_identity(ac, &comment, version);
		    key != NULL;
		    key = ssh_get_next_identity(ac, &comment, version)) {
d367 2
a368 2
				fp = key_fingerprint(key, fingerprint_hash,
				    SSH_FP_DEFAULT);
d370 3
a372 1
				    key_size(key), fp, comment, key_type(key));
d375 7
a381 3
				if (!key_write(key, stdout))
					fprintf(stderr, "key_write failed");
				fprintf(stdout, " %s\n", comment);
a382 2
			key_free(key);
			free(comment);
d384 1
d394 1
a394 1
lock_agent(AuthenticationConnection *ac, int lock)
d397 1
a397 1
	int passok = 1, ret = -1;
d411 9
a419 5
	if (passok && ssh_lock_agent(ac, lock, p1)) {
		fprintf(stderr, "Agent %slocked.\n", lock ? "" : "un");
		ret = 0;
	} else
		fprintf(stderr, "Failed to %slock agent.\n", lock ? "" : "un");
d426 1
a426 1
do_file(AuthenticationConnection *ac, int deleting, int key_only, char *file)
d429 1
a429 1
		if (delete_file(ac, file, key_only) == -1)
d432 1
a432 1
		if (add_file(ac, file, key_only) == -1)
d462 1
a462 1
	AuthenticationConnection *ac = NULL;
d464 1
a464 1
	int i, ch, deleting = 0, ret = 0, key_only = 0;
d474 10
a483 5
	/* At first, get a connection to the authentication agent. */
	ac = ssh_get_authentication_connection();
	if (ac == NULL) {
		fprintf(stderr,
		    "Could not open a connection to your authentication agent.\n");
d486 1
d542 1
a542 1
		if (lock_agent(ac, xflag == 'x' ? 1 : 0) == -1)
d546 1
a546 1
		if (list_identities(ac, lflag == 'l' ? 1 : 0) == -1)
d550 1
a550 1
		if (delete_all(ac) == -1)
d558 1
a558 1
		if (update_card(ac, !deleting, pkcs11provider) == -1)
d580 1
a580 1
			if (do_file(ac, deleting, key_only, buf) == -1)
d589 2
a590 1
			if (do_file(ac, deleting, key_only, argv[i]) == -1)
d597 1
a597 1
	ssh_close_authentication_connection(ac);
@


1.114
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.113 2014/07/09 14:15:56 benno Exp $ */
d62 1
d77 2
d340 2
a341 2
				fp = key_fingerprint(key, SSH_FP_MD5,
				    SSH_FP_HEX);
d408 1
d429 1
d445 1
a445 1
	while ((ch = getopt(argc, argv, "klLcdDxXe:s:t:")) != -1) {
d447 5
d457 4
a460 3
			if (list_identities(ac, ch == 'l' ? 1 : 0) == -1)
				ret = 1;
			goto done;
d463 4
a466 3
			if (lock_agent(ac, ch == 'x' ? 1 : 0) == -1)
				ret = 1;
			goto done;
d474 2
a475 3
			if (delete_all(ac) == -1)
				ret = 1;
			goto done;
d496 17
@


1.113
log
@fix ssh-add crash while loading more than one key
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.112 2014/07/03 03:15:01 djm Exp $ */
d431 1
a431 1
	setlinebuf(stdout);
@


1.112
log
@make stdout line-buffered; saves partial output getting lost when
ssh-add fatal()s part-way through (e.g. when listing keys from an
agent that supports key types that ssh-add doesn't);
bz#2234, reported by Phil Pennock
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.111 2014/06/27 18:50:39 markus Exp $ */
a201 2
	if (comment == NULL)
		comment = xstrdup(filename);
d209 2
@


1.111
log
@fix loading of private keys
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.110 2014/06/24 01:13:21 djm Exp $ */
d430 2
@


1.110
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.109 2014/02/02 03:44:31 djm Exp $ */
d199 1
a199 1
	if ((r = sshkey_parse_private_fileblob(&keyblob, filename, "",
d201 1
a201 1
			fatal("Cannot parse %s: %s", filename, ssh_err(r));
d206 1
a206 1
		if ((r = sshkey_parse_private_fileblob(&keyblob, filename, pass,
d225 1
a225 1
			     filename, pass, &private, &comment)) != 0 &&
@


1.109
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.108 2013/12/19 00:10:30 djm Exp $ */
d61 1
d168 1
a168 1
	int fd, perms_ok, ret = -1;
d199 3
a201 1
	private = key_parse_private(&keyblob, filename, "", &comment);
d205 6
a210 2
	if (private == NULL && pass != NULL)
		private = key_parse_private(&keyblob, filename, pass, NULL);
d224 5
a228 2
			private = key_parse_private(&keyblob, filename, pass,
			    &comment);
@


1.108
log
@skip requesting smartcard PIN when removing keys from agent; bz#2187
patch from jay AT slushpupie.com; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.107 2013/12/15 18:17:26 pascal Exp $ */
d87 1
a87 1
		memset(pass, 0, strlen(pass));
d363 1
a363 1
		memset(p2, 0, strlen(p2));
d371 1
a371 1
	memset(p1, 0, strlen(p1));
@


1.107
log
@Make ssh-add also add .ssh/id_ed25519; fixes lie in manual page.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.106 2013/05/17 00:13:14 djm Exp $ */
d290 1
a290 1
	char *pin;
d293 5
a297 3
	pin = read_passphrase("Enter passphrase for PKCS#11: ", RP_ALLOW_STDIN);
	if (pin == NULL)
		return -1;
d299 2
a300 1
	if (ssh_update_card(ac, add, id, pin, lifetime, confirm)) {
@


1.106
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.105 2012/12/05 15:42:52 markus Exp $ */
d70 1
@


1.105
log
@prevent double-free of comment; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.104 2012/12/02 20:42:15 djm Exp $ */
d87 1
a87 1
		xfree(pass);
d212 1
a212 1
				xfree(comment);
d279 2
a280 2
		xfree(certpath);
	xfree(comment);
d305 1
a305 1
	xfree(pin);
d327 1
a327 1
				xfree(fp);
d334 1
a334 1
			xfree(comment);
d360 1
a360 1
		xfree(p2);
d368 1
a368 1
	xfree(p1);
@


1.104
log
@make deleting explicit keys "ssh-add -d" symmetric with adding keys -
try to delete the corresponding certificate too and respect the -k option
to allow deleting of the key only; feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.103 2011/10/18 23:37:42 djm Exp $ */
d115 1
@


1.103
log
@add -k to usage(); reminded by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.102 2011/10/18 05:00:48 djm Exp $ */
d93 1
a93 1
delete_file(AuthenticationConnection *ac, const char *filename)
d95 2
a96 2
	Key *public;
	char *comment = NULL;
d110 26
a135 2
	key_free(public);
	xfree(comment);
d375 1
a375 1
		if (delete_file(ac, file) == -1)
@


1.102
log
@new "ssh-add -k" option to load plain keys (skipping certificates);
"looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.101 2011/05/04 21:15:29 djm Exp $ */
d367 3
a373 2
	fprintf(stderr, "  -t life     Set lifetime (in seconds) when adding identities.\n");
	fprintf(stderr, "  -c          Require confirmation to sign using identities\n");
@


1.101
log
@allow "ssh-add - < key"; feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.100 2010/08/31 12:33:38 djm Exp $ */
d136 1
a136 1
add_file(AuthenticationConnection *ac, const char *filename)
d140 1
a140 1
	char msg[1024], *certpath;
d216 3
d253 2
a254 1
	xfree(certpath);
d348 1
a348 1
do_file(AuthenticationConnection *ac, int deleting, char *file)
d354 1
a354 1
		if (add_file(ac, file) == -1)
d384 1
a384 1
	int i, ch, deleting = 0, ret = 0;
d398 1
a398 1
	while ((ch = getopt(argc, argv, "lLcdDxXe:s:t:")) != -1) {
d400 3
d468 1
a468 1
			if (do_file(ac, deleting, buf) == -1)
d477 1
a477 1
			if (do_file(ac, deleting, argv[i]) == -1)
@


1.100
log
@reintroduce commit from tedu@@, which I pulled out for release engineering:

  OpenSSL_add_all_algorithms is the name of the function we have a man page
  for, so use that.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.97 2010/08/12 23:34:38 tedu Exp $ */
d142 1
d144 4
a147 1
	if ((fd = open(filename, O_RDONLY)) < 0) {
d156 13
a168 1
	perms_ok = key_perm_ok(fd, filename);
a169 2
	if (!perms_ok)
		return -1;
d172 1
a172 1
	private = key_load_private(filename, "", &comment);
d177 1
a177 1
		private = key_load_private(filename, pass, NULL);
d188 1
d191 2
a192 1
			private = key_load_private(filename, pass, &comment);
d200 1
@


1.99
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.98 2010/08/16 04:06:06 djm Exp $ */
d368 1
a368 1
	SSLeay_add_all_algorithms();
@


1.98
log
@backout previous temporarily; discussed with deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.96 2010/05/14 00:47:22 djm Exp $ */
d69 1
@


1.97
log
@OpenSSL_add_all_algorithms is the name of the function we have a man page
for, so use that.  ok djm
@
text
@d367 1
a367 1
	OpenSSL_add_all_algorithms();
@


1.96
log
@check that the certificate matches the corresponding private key before
grafting it on
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.95 2010/04/16 01:47:26 djm Exp $ */
d367 1
a367 1
	SSLeay_add_all_algorithms();
@


1.95
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.94 2010/03/01 11:07:06 otto Exp $ */
d193 1
a193 1
			    "The user has to confirm each use of the key\n");
d201 6
a206 5
	if ((cert = key_load_public(certpath, NULL)) != NULL) {
		/* Graft with private bits */
		if (key_to_certified(private, key_cert_is_legacy(cert)) != 0)
			fatal("%s: key_to_certified failed", __func__);
		key_cert_copy(cert, private);
d208 2
d211 5
a215 14
		if (ssh_add_identity_constrained(ac, private, comment,
		    lifetime, confirm)) {
			fprintf(stderr, "Certificate added: %s (%s)\n",
			    certpath, private->cert->key_id);
			if (lifetime != 0)
				fprintf(stderr, "Lifetime set to %d seconds\n",
				    lifetime);
			if (confirm != 0)
				fprintf(stderr, "The user has to confirm each "
				    "use of the key\n");
		} else {
			error("Certificate %s (%s) add failed", certpath,
			    private->cert->key_id);
		}
d217 2
d220 12
@


1.94
log
@zap what seems to be a left-over debug message; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.93 2010/02/26 20:29:54 djm Exp $ */
d203 1
a203 1
		if (key_to_certified(private) != 0)
@


1.93
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.92 2010/02/08 10:50:20 markus Exp $ */
d222 1
a222 2
	} else
		fprintf(stderr, "Unable to load certificate %s", certpath);
@


1.92
log
@replace our obsolete smartcard code with PKCS#11.
	ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v2-20/pkcs-11v2-20.pdf
ssh(1) and ssh-keygen(1) use dlopen(3) directly to talk to a PKCS#11
provider (shared library) while ssh-agent(1) delegates PKCS#11 to
a forked a ssh-pkcs11-helper process.
PKCS#11 is currently a compile time option.
feedback and ok djm@@; inspired by patches from Alon Bar-Lev
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.91 2009/08/27 17:44:52 djm Exp $ */
d137 1
a137 1
	Key *private;
d139 1
a139 1
	char msg[1024];
d198 28
@


1.91
log
@Do not fall back to adding keys without contraints (ssh-add -c / -t ...)
when the agent refuses the constrained add request. This was a useful
migration measure back in 2002 when constraints were new, but just
adds risk now.

bz #1612, report and patch from dkg AT fifthhorseman.net; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.90 2007/09/09 11:38:01 sobrado Exp $ */
d210 1
a210 1
	pin = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
d316 2
a317 4
#ifdef SMARTCARD
	fprintf(stderr, "  -s reader   Add key in smartcard reader.\n");
	fprintf(stderr, "  -e reader   Remove key in smartcard reader.\n");
#endif
d326 1
a326 1
	char *sc_reader_id = NULL;
d364 1
a364 1
			sc_reader_id = optarg;
d368 1
a368 1
			sc_reader_id = optarg;
d385 2
a386 2
	if (sc_reader_id != NULL) {
		if (update_card(ac, !deleting, sc_reader_id) == -1)
@


1.90
log
@sort synopsis and options in ssh-agent(1); usage is lowercase

ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.89 2006/08/03 03:34:42 deraadt Exp $ */
a193 3
	} else if (ssh_add_identity(ac, private, comment)) {
		fprintf(stderr, "Identity added: %s (%s)\n", filename, comment);
		ret = 0;
@


1.89
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.88 2006/08/01 23:22:47 stevesk Exp $ */
d309 1
a309 1
	fprintf(stderr, "Usage: %s [options] [file ...]\n", __progname);
@


1.88
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.87 2006/07/26 13:57:17 stevesk Exp $ */
a37 2
#include "includes.h"

d51 1
a54 1
#include "xmalloc.h"
d56 1
@


1.87
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.86 2006/07/26 02:35:17 stevesk Exp $ */
d48 1
@


1.86
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.85 2006/07/22 20:48:23 stevesk Exp $ */
d48 1
@


1.85
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.84 2006/07/17 01:31:09 stevesk Exp $ */
d42 1
@


1.84
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.83 2006/07/09 15:27:59 stevesk Exp $ */
d47 1
@


1.83
log
@use O_RDONLY vs. 0 in open(); no binary change
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.82 2006/07/09 15:15:11 stevesk Exp $ */
d47 1
@


1.82
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.81 2006/07/06 16:03:53 stevesk Exp $ */
d138 1
a138 1
	if ((fd = open(filename, 0)) < 0) {
@


1.81
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.80 2006/05/30 11:46:38 mk Exp $ */
d45 1
@


1.80
log
@Sync usage() with man page and reality.

ok deraadt dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-add.c,v 1.79 2006/03/25 13:17:02 djm Exp $ */
d44 2
@


1.79
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d302 1
a302 1
	fprintf(stderr, "Usage: %s [options]\n", __progname);
@


1.78
log
@in a switch (), break after return or goto is stupid
@
text
@d1 1
@


1.77
log
@RCSID() can die
@
text
@a344 1
			break;
a349 1
			break;
a359 1
			break;
@


1.76
log
@Make ssh-add check file permissions before attempting to load private
key files multiple times; it will fail anyway and this prevents confusing
multiple prompts and warnings.  mindrot #1138, ok djm@@
@
text
@a37 1
RCSID("$OpenBSD: ssh-add.c,v 1.75 2006/02/20 17:19:54 stevesk Exp $");
@


1.75
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.74 2005/11/12 18:37:59 deraadt Exp $");
a129 1
	struct stat st;
d133 1
a133 1
	int ret = -1;
d135 1
a135 1
	if (stat(filename, &st) < 0) {
d139 10
@


1.75.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-add.c,v 1.89 2006/08/03 03:34:42 deraadt Exp $ */
d37 3
a41 1
#include <sys/param.h>
a44 8
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
d48 1
a49 1
#include "buffer.h"
d130 1
d134 1
a134 1
	int fd, perms_ok, ret = -1;
d136 1
a136 1
	if ((fd = open(filename, O_RDONLY)) < 0) {
a139 10

	/*
	 * Since we'll try to load a keyfile multiple times, permission errors
	 * will occur multiple times, so check perms first and bail if wrong.
	 */
	perms_ok = key_perm_ok(fd, filename);
	close(fd);
	if (!perms_ok)
		return -1;

d293 1
a293 1
	fprintf(stderr, "Usage: %s [options] [file ...]\n", __progname);
d337 1
d343 1
d354 1
@


1.74
log
@space
@
text
@d38 4
a41 1
RCSID("$OpenBSD: ssh-add.c,v 1.73 2005/09/13 23:40:07 djm Exp $");
@


1.73
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.72 2005/07/17 07:17:55 djm Exp $");
d323 2
a324 1
		fprintf(stderr, "Could not open a connection to your authentication agent.\n");
@


1.72
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.71 2005/03/10 22:01:06 deraadt Exp $");
d314 3
@


1.72.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.74 2005/11/12 18:37:59 deraadt Exp $");
a314 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d320 1
a320 2
		fprintf(stderr,
		    "Could not open a connection to your authentication agent.\n");
@


1.72.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-add.c,v 1.89 2006/08/03 03:34:42 deraadt Exp $ */
d37 2
a38 3
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
a41 8
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
d45 1
a46 1
#include "buffer.h"
d127 1
d131 1
a131 1
	int fd, perms_ok, ret = -1;
d133 1
a133 1
	if ((fd = open(filename, O_RDONLY)) < 0) {
a136 10

	/*
	 * Since we'll try to load a keyfile multiple times, permission errors
	 * will occur multiple times, so check perms first and bail if wrong.
	 */
	perms_ok = key_perm_ok(fd, filename);
	close(fd);
	if (!perms_ok)
		return -1;

d290 1
a290 1
	fprintf(stderr, "Usage: %s [options] [file ...]\n", __progname);
d334 1
d340 1
d351 1
@


1.71
log
@spacing
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.70 2004/05/08 00:21:31 djm Exp $");
d148 1
a148 1
		   comment);
@


1.71.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.72 2005/07/17 07:17:55 djm Exp $");
d148 1
a148 1
		    comment);
@


1.71.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.74 2005/11/12 18:37:59 deraadt Exp $");
a314 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d320 1
a320 2
		fprintf(stderr,
		    "Could not open a connection to your authentication agent.\n");
@


1.70
log
@kill a tiny header; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.69 2003/11/21 11:57:03 djm Exp $");
d388 1
a388 1
		for(i = 0; default_files[i]; i++) {
d401 1
a401 1
		for(i = 0; i < argc; i++) {
@


1.70.2.1
log
@upgrade to OpenSSH 4.1
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.71 2005/03/10 22:01:06 deraadt Exp $");
d388 1
a388 1
		for (i = 0; default_files[i]; i++) {
d401 1
a401 1
		for (i = 0; i < argc; i++) {
@


1.70.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.72 2005/07/17 07:17:55 djm Exp $");
d148 1
a148 1
		    comment);
@


1.69
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.68 2003/06/16 10:22:45 markus Exp $");
a49 1
#include "readpass.h"
@


1.69.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.70 2004/05/08 00:21:31 djm Exp $");
d50 1
@


1.68
log
@print out key comment on each prompt; make ssh-askpass more useable; ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.67 2003/06/11 11:18:38 djm Exp $");
d166 2
a167 2
 	if (ssh_add_identity_constrained(ac, private, comment, lifetime,
 	    confirm)) {
d173 1
a173 1
 		if (confirm != 0)
@


1.68.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.69 2003/11/21 11:57:03 djm Exp $");
d166 2
a167 2
	if (ssh_add_identity_constrained(ac, private, comment, lifetime,
	    confirm)) {
d173 1
a173 1
		if (confirm != 0)
@


1.68.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.70 2004/05/08 00:21:31 djm Exp $");
d50 1
@


1.67
log
@make agent constraints (lifetime, confirm) work with smartcard keys; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.66 2003/03/05 22:33:43 markus Exp $");
d161 2
a162 1
			strlcpy(msg, "Bad passphrase, try again: ", sizeof msg);
@


1.66
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.65 2003/01/23 13:50:27 markus Exp $");
d198 1
a198 1
	if (ssh_update_card(ac, add, id, pin)) {
@


1.66.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.68 2003/06/16 10:22:45 markus Exp $");
d161 1
a161 2
			snprintf(msg, sizeof msg,
			    "Bad passphrase, try again for %.200s: ", comment);
d198 1
a198 1
	if (ssh_update_card(ac, add, id, pin, lifetime, confirm)) {
@


1.66.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.69 2003/11/21 11:57:03 djm Exp $");
d166 2
a167 2
	if (ssh_add_identity_constrained(ac, private, comment, lifetime,
	    confirm)) {
d173 1
a173 1
		if (confirm != 0)
@


1.65
log
@ssh-add -c, prompt user for confirmation (using ssh-askpass) when
private agent key is used; with djm@@; test by dugsong@@, djm@@; ok deraadt@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.64 2002/11/21 23:03:51 deraadt Exp $");
d192 1
d201 1
a201 1
		return 0;
d205 1
a205 1
		return -1;
d207 2
@


1.64
log
@KNF
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.63 2002/09/19 15:51:23 markus Exp $");
d67 3
d165 2
a166 1
	if (ssh_add_identity_constrained(ac, private, comment, lifetime)) {
d172 3
d296 1
d320 1
a320 1
	while ((ch = getopt(argc, argv, "lLdDxXe:s:t:")) != -1) {
d333 3
@


1.63
log
@typo; cd@@kalkatraz.de
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.62 2002/06/26 14:51:33 markus Exp $");
d166 1
a166 1
                        fprintf(stderr,
@


1.63.2.1
log
@Update to OpenSSH 3.6
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.66 2003/03/05 22:33:43 markus Exp $");
a66 3
/* User has to confirm key use */
static int confirm = 0;

d162 1
a162 2
 	if (ssh_add_identity_constrained(ac, private, comment, lifetime,
 	    confirm)) {
d166 1
a166 1
			fprintf(stderr,
a167 3
 		if (confirm != 0)
			fprintf(stderr,
			    "The user has to confirm each use of the key\n");
a184 1
	int ret = -1;
d193 1
a193 1
		ret = 0;
d197 1
a197 1
		ret = -1;
a198 2
	xfree(pin);
	return ret;
a288 1
	fprintf(stderr, "  -c          Require confirmation to sign using identities\n");
d312 1
a312 1
	while ((ch = getopt(argc, argv, "lLcdDxXe:s:t:")) != -1) {
a324 3
			break;
		case 'c':
			confirm = 1;
@


1.63.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.68 2003/06/16 10:22:45 markus Exp $");
d161 1
a161 2
			snprintf(msg, sizeof msg,
			    "Bad passphrase, try again for %.200s: ", comment);
d198 1
a198 1
	if (ssh_update_card(ac, add, id, pin, lifetime, confirm)) {
@


1.62
log
@fix exit code for -X/-x
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.61 2002/06/19 00:27:55 deraadt Exp $");
d287 1
a287 1
	fprintf(stderr, "  -x          Unlock agent.\n");
@


1.61
log
@KNF done automatically while reading....
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.60 2002/06/15 01:27:48 markus Exp $");
d261 1
a261 1
	return -1;
@


1.60
log
@remove the CONSTRAIN_IDENTITY messages and introduce a new
ADD_ID message with contraints instead. contraints can be
only added together with the private key.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.59 2002/06/15 00:07:38 markus Exp $");
d241 1
a241 1
 
@


1.59
log
@fix stupid typo
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.58 2002/06/15 00:01:36 markus Exp $");
d161 8
a168 1
	if (ssh_add_identity(ac, private, comment)) {
d171 1
a171 1
	} else
a172 11

	if (ret == 0 && lifetime != 0) {
		if (ssh_constrain_identity(ac, private, lifetime)) {
			fprintf(stderr,
			    "Lifetime set to %d seconds for: %s (%s)\n",
			    lifetime, filename, comment);
		} else {
			fprintf(stderr,
			    "Could not set lifetime for identity: %s\n",
			    filename);
		}
@


1.58
log
@break agent key lifetime protocol and allow other contraints for key usage.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.57 2002/06/10 17:36:23 stevesk Exp $");
d168 1
a168 1
		if (ssh_contrain_identity(ac, private, lifetime)) {
@


1.57
log
@use convtime() to parse and validate key lifetime.  can now
use '-t 2h' etc.  ok markus@@ provos@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.56 2002/06/05 21:55:44 markus Exp $");
d168 1
a168 1
		if (ssh_lifetime_identity(ac, private, lifetime)) {
@


1.56
log
@ssh-add -t life,  Set lifetime (in seconds) when adding identities; ok provos@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.55 2002/06/05 20:56:39 markus Exp $");
d51 1
d65 1
a65 1
static u_int lifetime = 0;
d346 5
a350 1
			lifetime = atoi(optarg);
@


1.55
log
@add -x/-X to usage
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.54 2002/06/05 19:57:12 markus Exp $");
d63 2
d166 12
d291 1
d315 1
a315 1
	while ((ch = getopt(argc, argv, "lLdDxXe:s:")) != -1) {
d343 3
@


1.54
log
@ssh-add -x for lock and -X for unlocking the agent.
todo: encrypt private keys with locked...
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.53 2002/03/21 22:44:05 rees Exp $");
d275 2
@


1.53
log
@Add PIN-protection for secret key.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.52 2002/03/21 10:21:20 markus Exp $");
d226 28
d298 1
a298 1
	while ((ch = getopt(argc, argv, "lLdDe:s:")) != -1) {
d303 6
@


1.53.2.1
log
@Pull in OpenSSH-3.4
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.61 2002/06/19 00:27:55 deraadt Exp $");
a50 1
#include "misc.h"
a62 2
/* Default lifetime (0 == forever) */
static int lifetime = 0;
d158 1
a158 2

	if (ssh_add_identity_constrained(ac, private, comment, lifetime)) {
d161 1
a161 7
		if (lifetime != 0)
                        fprintf(stderr,
			    "Lifetime set to %d seconds\n", lifetime);
	} else if (ssh_add_identity(ac, private, comment)) {
		fprintf(stderr, "Identity added: %s (%s)\n", filename, comment);
		ret = 0;
	} else {
a162 1
	}
a225 28
lock_agent(AuthenticationConnection *ac, int lock)
{
	char prompt[100], *p1, *p2;
	int passok = 1, ret = -1;

	strlcpy(prompt, "Enter lock password: ", sizeof(prompt));
	p1 = read_passphrase(prompt, RP_ALLOW_STDIN);
	if (lock) {
		strlcpy(prompt, "Again: ", sizeof prompt);
		p2 = read_passphrase(prompt, RP_ALLOW_STDIN);
		if (strcmp(p1, p2) != 0) {
			fprintf(stderr, "Passwords do not match.\n");
			passok = 0;
		}
		memset(p2, 0, strlen(p2));
		xfree(p2);
	}
	if (passok && ssh_lock_agent(ac, lock, p1)) {
		fprintf(stderr, "Agent %slocked.\n", lock ? "" : "un");
		ret = 0;
	} else
		fprintf(stderr, "Failed to %slock agent.\n", lock ? "" : "un");
	memset(p1, 0, strlen(p1));
	xfree(p1);
	return -1;
}

static int
a246 3
	fprintf(stderr, "  -x          Lock agent.\n");
	fprintf(stderr, "  -x          Unlock agent.\n");
	fprintf(stderr, "  -t life     Set lifetime (in seconds) when adding identities.\n");
d270 1
a270 1
	while ((ch = getopt(argc, argv, "lLdDxXe:s:t:")) != -1) {
a277 6
		case 'x':
		case 'X':
			if (lock_agent(ac, ch == 'x' ? 1 : 0) == -1)
				ret = 1;
			goto done;
			break;
a291 7
			break;
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid lifetime\n");
				ret = 1;
				goto done;
			}
@


1.53.2.2
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.63 2002/09/19 15:51:23 markus Exp $");
d261 1
a261 1
	return (ret);
d287 1
a287 1
	fprintf(stderr, "  -X          Unlock agent.\n");
@


1.53.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.66 2003/03/05 22:33:43 markus Exp $");
a66 3
/* User has to confirm key use */
static int confirm = 0;

d162 1
a162 2
 	if (ssh_add_identity_constrained(ac, private, comment, lifetime,
 	    confirm)) {
d166 1
a166 1
			fprintf(stderr,
a167 3
 		if (confirm != 0)
			fprintf(stderr,
			    "The user has to confirm each use of the key\n");
a184 1
	int ret = -1;
d193 1
a193 1
		ret = 0;
d197 1
a197 1
		ret = -1;
a198 2
	xfree(pin);
	return ret;
a288 1
	fprintf(stderr, "  -c          Require confirmation to sign using identities\n");
d312 1
a312 1
	while ((ch = getopt(argc, argv, "lLcdDxXe:s:t:")) != -1) {
a324 3
			break;
		case 'c':
			confirm = 1;
@


1.52
log
@ignore errors for nonexisting default keys in ssh-add,
fixes http://bugzilla.mindrot.org/show_bug.cgi?id=158
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.51 2002/03/19 10:49:35 markus Exp $");
d173 7
a179 1
	if (ssh_update_card(ac, add, id)) {
@


1.51
log
@KNF whitespace
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.50 2002/01/29 14:27:57 markus Exp $");
d303 2
d316 2
d320 2
d323 2
@


1.50
log
@exit 2 if no agent, exit 1 if list fails; debian#61078; ok djm@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.49 2001/12/24 07:29:43 deraadt Exp $");
d59 1
a59 1
	_PATH_SSH_CLIENT_IDENTITY, 
d312 1
a312 1
			snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir, 
@


1.49
log
@try all listed keys.. how did this get broken?
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.48 2001/12/21 10:06:43 djm Exp $");
d184 1
a184 1
static void
d212 1
a212 1
	if (!had_identities)
d214 3
d262 1
a262 1
		exit(1);
d268 2
a269 1
			list_identities(ac, ch == 'l' ? 1 : 0);
@


1.48
log
@Try all standard key files (id_rsa, id_dsa, identity) when invoked with
no arguments; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.47 2001/12/19 07:18:56 deraadt Exp $");
d315 1
a315 1
			if (do_file(ac, deleting, argv[1]) == -1)
@


1.47
log
@basic KNF done while i was looking for something else
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.46 2001/10/02 08:38:50 djm Exp $");
d55 9
d216 13
a249 2
	struct passwd *pw;
	char buf[1024];
d297 4
a300 2
		pw = getpwuid(getuid());
		if (!pw) {
d306 5
a310 6
		snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, _PATH_SSH_CLIENT_IDENTITY);
		if (deleting) {
			if (delete_file(ac, buf) == -1)
				ret = 1;
		} else {
			if (add_file(ac, buf) == -1)
d314 3
a316 8
		for (i = 0; i < argc; i++) {
			if (deleting) {
				if (delete_file(ac, argv[i]) == -1)
					ret = 1;
			} else {
				if (add_file(ac, argv[i]) == -1)
					ret = 1;
			}
@


1.46
log
@return non-zero exit code on error; ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.45 2001/08/03 10:31:30 jakob Exp $");
d87 1
a87 1
	
d157 1
a157 1
	
d166 1
a166 1
		     add ? "added" : "removed", id);
d170 1
a170 1
		     add ? "add" : "remove", id);
d185 2
a186 2
		     key != NULL;
		     key = ssh_get_next_identity(ac, &comment, version)) {
d241 1
a241 1
        while ((ch = getopt(argc, argv, "lLdDe:s:")) != -1) {
d260 1
a260 1
			deleting = 1; 
@


1.46.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.50 2002/01/29 14:27:57 markus Exp $");
a54 9
/* Default files to add */
static char *default_files[] = {
	_PATH_SSH_CLIENT_ID_RSA,
	_PATH_SSH_CLIENT_ID_DSA,
	_PATH_SSH_CLIENT_IDENTITY, 
	NULL
};


d87 1
a87 1

d157 1
a157 1

d166 1
a166 1
		    add ? "added" : "removed", id);
d170 1
a170 1
		    add ? "add" : "remove", id);
d175 1
a175 1
static int
d185 2
a186 2
		    key != NULL;
		    key = ssh_get_next_identity(ac, &comment, version)) {
d203 1
a203 1
	if (!had_identities) {
a204 16
		return -1;
	}
	return 0;
}

static int
do_file(AuthenticationConnection *ac, int deleting, char *file)
{
	if (deleting) {
		if (delete_file(ac, file) == -1)
			return -1;
	} else {
		if (add_file(ac, file) == -1)
			return -1;
	}
	return 0;
d228 2
d239 1
a239 1
		exit(2);
d241 1
a241 1
	while ((ch = getopt(argc, argv, "lLdDe:s:")) != -1) {
d245 1
a245 2
			if (list_identities(ac, ch == 'l' ? 1 : 0) == -1)
				ret = 1;
d260 1
a260 1
			deleting = 1;
d277 2
a278 4
		char buf[MAXPATHLEN];
		struct passwd *pw;

		if ((pw = getpwuid(getuid())) == NULL) {
d284 6
a289 5

		for(i = 0; default_files[i]; i++) {
			snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir, 
			    default_files[i]);
			if (do_file(ac, deleting, buf) == -1)
d293 8
a300 3
		for(i = 0; i < argc; i++) {
			if (do_file(ac, deleting, argv[i]) == -1)
				ret = 1;
@


1.46.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.53 2002/03/21 22:44:05 rees Exp $");
d59 1
a59 1
	_PATH_SSH_CLIENT_IDENTITY,
d173 1
a173 7
	char *pin;

	pin = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
	if (pin == NULL)
		return -1;

	if (ssh_update_card(ac, add, id, pin)) {
a302 2
		struct stat st;
		int count = 0;
d312 1
a312 1
			snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir,
a313 2
			if (stat(buf, &st) < 0)
				continue;
a315 2
			else
				count++;
a316 2
		if (count == 0)
			ret = 1;
@


1.46.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.46.2.2 2002/05/17 00:03:24 miod Exp $");
a50 1
#include "misc.h"
a62 2
/* Default lifetime (0 == forever) */
static int lifetime = 0;
d158 1
a158 2

	if (ssh_add_identity_constrained(ac, private, comment, lifetime)) {
d161 1
a161 7
		if (lifetime != 0)
                        fprintf(stderr,
			    "Lifetime set to %d seconds\n", lifetime);
	} else if (ssh_add_identity(ac, private, comment)) {
		fprintf(stderr, "Identity added: %s (%s)\n", filename, comment);
		ret = 0;
	} else {
a162 1
	}
a225 28
lock_agent(AuthenticationConnection *ac, int lock)
{
	char prompt[100], *p1, *p2;
	int passok = 1, ret = -1;

	strlcpy(prompt, "Enter lock password: ", sizeof(prompt));
	p1 = read_passphrase(prompt, RP_ALLOW_STDIN);
	if (lock) {
		strlcpy(prompt, "Again: ", sizeof prompt);
		p2 = read_passphrase(prompt, RP_ALLOW_STDIN);
		if (strcmp(p1, p2) != 0) {
			fprintf(stderr, "Passwords do not match.\n");
			passok = 0;
		}
		memset(p2, 0, strlen(p2));
		xfree(p2);
	}
	if (passok && ssh_lock_agent(ac, lock, p1)) {
		fprintf(stderr, "Agent %slocked.\n", lock ? "" : "un");
		ret = 0;
	} else
		fprintf(stderr, "Failed to %slock agent.\n", lock ? "" : "un");
	memset(p1, 0, strlen(p1));
	xfree(p1);
	return -1;
}

static int
a246 3
	fprintf(stderr, "  -x          Lock agent.\n");
	fprintf(stderr, "  -x          Unlock agent.\n");
	fprintf(stderr, "  -t life     Set lifetime (in seconds) when adding identities.\n");
d270 1
a270 1
	while ((ch = getopt(argc, argv, "lLdDxXe:s:t:")) != -1) {
a277 6
		case 'x':
		case 'X':
			if (lock_agent(ac, ch == 'x' ? 1 : 0) == -1)
				ret = 1;
			goto done;
			break;
a291 7
			break;
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid lifetime\n");
				ret = 1;
				goto done;
			}
@


1.46.2.4
log
@Update to OpenSSH 3.5
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.63 2002/09/19 15:51:23 markus Exp $");
d261 1
a261 1
	return (ret);
d287 1
a287 1
	fprintf(stderr, "  -X          Unlock agent.\n");
@


1.45
log
@improve usage(). ok markus@@
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.44 2001/08/01 22:03:33 markus Exp $");
d67 1
a67 1
static void
d72 1
d77 1
a77 1
		return;
d79 1
a79 1
	if (ssh_remove_identity(ac, public))
d81 2
a82 1
	else
d84 1
d87 2
d92 1
a92 1
static void
d95 1
a95 1
	int success = 1;
d97 2
a98 2
	if (!ssh_remove_all_identities(ac, 1))
		success = 0;
d102 1
a102 1
	if (success)
d106 2
d110 1
a110 1
static void
d117 1
d121 1
a121 1
		exit(1);
d140 1
a140 1
				return;
d149 1
a149 1
	if (ssh_add_identity(ac, private, comment))
d151 2
a152 1
	else
d154 1
d157 2
d161 1
a161 1
static void
d164 1
a164 1
	if (ssh_update_card(ac, add, id))
d167 2
a168 1
	else
d171 2
d231 1
a231 1
	int i, ch, deleting = 0;
d252 2
a253 1
			delete_all(ac);
d265 2
a266 2
			exit(1);
			break;
d272 2
a273 1
		update_card(ac, !deleting, sc_reader_id);
d281 2
a282 2
			ssh_close_authentication_connection(ac);
			exit(1);
d285 7
a291 4
		if (deleting)
			delete_file(ac, buf);
		else
			add_file(ac, buf);
d294 7
a300 4
			if (deleting)
				delete_file(ac, argv[i]);
			else
				add_file(ac, argv[i]);
d307 1
a307 1
	exit(0);
@


1.44
log
@use strings instead of ints for smartcard reader ids
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.43 2001/06/27 06:26:36 markus Exp $");
d52 3
d195 10
a204 6
	printf("Usage: ssh-add [options]\n");
	printf("    -l, -L        : list identities\n");
	printf("    -d            : delete identity\n");
	printf("    -D            : delete all identities\n");
	printf("    -s reader_num : add key in the smartcard in reader_num.\n");
	printf("    -e reader_num : remove key in the smartcard in reader_num.\n");
@


1.43
log
@convert to getopt(3)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.42 2001/06/26 04:59:59 markus Exp $");
d147 1
a147 1
update_card(AuthenticationConnection *ac, int add, int id)
d150 1
a150 1
		fprintf(stderr, "Card %s: %d\n",
d153 1
a153 1
		fprintf(stderr, "Could not %s card: %d\n",
d208 2
a209 1
	int i, ch, deleting = 0, sc_reader_num = -1;
d234 1
a234 1
			sc_reader_num = atoi(optarg);
d238 1
a238 1
			sc_reader_num = atoi(optarg);
d248 2
a249 2
	if (sc_reader_num != -1) {
		update_card(ac, !deleting, sc_reader_num);
@


1.42
log
@initial support for smartcards in the agent
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.41 2001/06/25 08:25:40 markus Exp $");
a197 1
	exit (1);
d203 2
d208 1
a208 5
	int no_files = 1;
	int i;
	int deleting = 0;
	int sc_mode = 0;
	int sc_reader_num = 0;
d218 8
a225 9
	for (i = 1; i < argc; i++) {
		if ((strcmp(argv[i], "-l") == 0) ||
		    (strcmp(argv[i], "-L") == 0)) {
			list_identities(ac, argv[i][1] == 'l' ? 1 : 0);
			/* Don't default-add/delete if -l. */
			no_files = 0;
			continue;
		}
		if (strcmp(argv[i], "-d") == 0) {
d227 2
a228 3
			continue;
		}
		if (strcmp(argv[i], "-D") == 0) {
d230 6
a235 14
			no_files = 0;
			continue;
		}
		if (strcmp(argv[i], "-s") == 0) {
			sc_mode = 1;
			deleting = 0; 
			i++;
			if (i >= argc)
				usage();
			sc_reader_num = atoi(argv[i]);
			continue; 
		}
		if (strcmp(argv[i], "-e") == 0) {
			sc_mode = 1;
d237 6
a242 5
			i++;
			if (i >= argc)
				usage();
			sc_reader_num = atoi(argv[i]);
			continue; 
a243 7
		if (sc_mode == 1)
			update_card(ac, !deleting, sc_reader_num);
		no_files = 0;
		if (deleting)
			delete_file(ac, argv[i]);
		else
			add_file(ac, argv[i]);
d245 3
a247 1
	if (sc_mode == 1) {
d249 1
a249 2
		ssh_close_authentication_connection(ac);
		exit(0);
d251 1
a251 1
	if (no_files) {
d264 7
d273 2
@


1.41
log
@update copyright for 2001
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.40 2001/06/24 05:35:33 markus Exp $");
d147 11
d189 12
d210 2
d238 20
d263 5
@


1.40
log
@switch to readpassphrase(3)
2.7/8-stable needs readpassphrase.[ch] from libc
@
text
@d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.39 2001/06/23 15:12:20 itojun Exp $");
@


1.39
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.38 2001/06/06 23:19:35 markus Exp $");
d125 1
a125 1
			pass = read_passphrase(msg, 1);
@


1.38
log
@remove debug message; Darren.Moffat@@eng.sun.com
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.37 2001/05/02 16:41:20 markus Exp $");
d54 1
a54 1
void
d64 1
a64 1
void
d84 1
a84 1
void
d100 1
a100 1
void
d146 1
a146 1
void
@


1.37
log
@fix prompt for ssh-add.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.36 2001/04/18 21:57:42 markus Exp $");
a121 1
		printf("Need passphrase for %.200s\n", filename);
@


1.36
log
@call askpass from ssh, too, based on work by roth@@feep.net, ok deraadt
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.35 2001/04/14 16:27:57 markus Exp $");
d123 1
a123 1
		snprintf(msg, sizeof msg, "Enter passphrase for %.200s ",
d136 1
a136 1
			strlcpy(msg, "Bad passphrase, try again ", sizeof msg);
@


1.36.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d14 1
a14 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.45 2001/08/03 10:31:30 jakob Exp $");
a51 3
/* argv0 */
extern char *__progname;

d54 1
a54 1
static void
d64 1
a64 1
static void
d84 1
a84 1
static void
d100 1
a100 1
static void
d122 2
a123 1
		snprintf(msg, sizeof msg, "Enter passphrase for %.200s: ",
d126 1
a126 1
			pass = read_passphrase(msg, RP_ALLOW_STDIN);
d136 1
a136 1
			strlcpy(msg, "Bad passphrase, try again: ", sizeof msg);
d147 1
a147 12
static void
update_card(AuthenticationConnection *ac, int add, const char *id)
{
	if (ssh_update_card(ac, add, id))
		fprintf(stderr, "Card %s: %s\n",
		     add ? "added" : "removed", id);
	else
		fprintf(stderr, "Could not %s card: %s\n",
		     add ? "add" : "remove", id);
}

static void
a178 15
static void
usage(void)
{
	fprintf(stderr, "Usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -l          List fingerprints of all identities.\n");
	fprintf(stderr, "  -L          List public key parameters of all identities.\n");
	fprintf(stderr, "  -d          Delete identity.\n");
	fprintf(stderr, "  -D          Delete all identities.\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -s reader   Add key in smartcard reader.\n");
	fprintf(stderr, "  -e reader   Remove key in smartcard reader.\n");
#endif
}

a181 2
	extern char *optarg;
	extern int optind;
d185 3
a187 2
	char *sc_reader_id = NULL;
	int i, ch, deleting = 0;
d197 9
a205 8
        while ((ch = getopt(argc, argv, "lLdDe:s:")) != -1) {
		switch (ch) {
		case 'l':
		case 'L':
			list_identities(ac, ch == 'l' ? 1 : 0);
			goto done;
			break;
		case 'd':
d207 3
a209 2
			break;
		case 'D':
d211 2
a212 13
			goto done;
			break;
		case 's':
			sc_reader_id = optarg;
			break;
		case 'e':
			deleting = 1; 
			sc_reader_id = optarg;
			break;
		default:
			usage();
			exit(1);
			break;
d214 5
d220 1
a220 7
	argc -= optind;
	argv += optind;
	if (sc_reader_id != NULL) {
		update_card(ac, !deleting, sc_reader_id);
		goto done;
	}
	if (argc == 0) {
a232 7
	} else {
		for (i = 0; i < argc; i++) {
			if (deleting)
				delete_file(ac, argv[i]);
			else
				add_file(ac, argv[i]);
		}
a234 2

done:
@


1.36.2.2
log
@Merge OpenSSH 3.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.36.2.1 2001/09/27 19:03:55 jason Exp $");
d67 1
a67 1
static int
a71 1
	int ret = -1;
d76 1
a76 1
		return -1;
d78 1
a78 1
	if (ssh_remove_identity(ac, public)) {
d80 1
a80 2
		ret = 0;
	} else
a81 1

a83 2
	
	return ret;
d87 1
a87 1
static int
d90 1
a90 1
	int ret = -1;
d92 2
a93 2
	if (ssh_remove_all_identities(ac, 1))
		ret = 0;
d97 1
a97 1
	if (ret == 0)
a100 2

	return ret;
d103 1
a103 1
static int
a109 1
	int ret = -1;
d113 1
a113 1
		return -1;
d132 1
a132 1
				return -1;
d141 1
a141 1
	if (ssh_add_identity(ac, private, comment)) {
d143 1
a143 2
		ret = 0;
	} else
a144 1

a146 2
	
	return ret;
d149 1
a149 1
static int
d152 1
a152 1
	if (ssh_update_card(ac, add, id)) {
d155 1
a155 2
		return 0;
	} else {
a157 2
		return -1;
	}
d216 1
a216 1
	int i, ch, deleting = 0, ret = 0;
d237 1
a237 2
			if (delete_all(ac) == -1)
				ret = 1;
d249 2
a250 2
			ret = 1;
			goto done;
d256 1
a256 2
		if (update_card(ac, !deleting, sc_reader_id) == -1)
			ret = 1;
d264 2
a265 2
			ret = 1;
			goto done;
d268 4
a271 7
		if (deleting) {
			if (delete_file(ac, buf) == -1)
				ret = 1;
		} else {
			if (add_file(ac, buf) == -1)
				ret = 1;
		}
d274 4
a277 7
			if (deleting) {
				if (delete_file(ac, argv[i]) == -1)
					ret = 1;
			} else {
				if (add_file(ac, argv[i]) == -1)
					ret = 1;
			}
d284 1
a284 1
	return ret;
@


1.36.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.50 2002/01/29 14:27:57 markus Exp $");
a54 9
/* Default files to add */
static char *default_files[] = {
	_PATH_SSH_CLIENT_ID_RSA,
	_PATH_SSH_CLIENT_ID_DSA,
	_PATH_SSH_CLIENT_IDENTITY, 
	NULL
};


d87 1
a87 1

d157 1
a157 1

d166 1
a166 1
		    add ? "added" : "removed", id);
d170 1
a170 1
		    add ? "add" : "remove", id);
d175 1
a175 1
static int
d185 2
a186 2
		    key != NULL;
		    key = ssh_get_next_identity(ac, &comment, version)) {
d203 1
a203 1
	if (!had_identities) {
a204 16
		return -1;
	}
	return 0;
}

static int
do_file(AuthenticationConnection *ac, int deleting, char *file)
{
	if (deleting) {
		if (delete_file(ac, file) == -1)
			return -1;
	} else {
		if (add_file(ac, file) == -1)
			return -1;
	}
	return 0;
d228 2
d239 1
a239 1
		exit(2);
d241 1
a241 1
	while ((ch = getopt(argc, argv, "lLdDe:s:")) != -1) {
d245 1
a245 2
			if (list_identities(ac, ch == 'l' ? 1 : 0) == -1)
				ret = 1;
d260 1
a260 1
			deleting = 1;
d277 2
a278 4
		char buf[MAXPATHLEN];
		struct passwd *pw;

		if ((pw = getpwuid(getuid())) == NULL) {
d284 6
a289 5

		for(i = 0; default_files[i]; i++) {
			snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir, 
			    default_files[i]);
			if (do_file(ac, deleting, buf) == -1)
d293 8
a300 3
		for(i = 0; i < argc; i++) {
			if (do_file(ac, deleting, argv[i]) == -1)
				ret = 1;
@


1.36.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.53 2002/03/21 22:44:05 rees Exp $");
d59 1
a59 1
	_PATH_SSH_CLIENT_IDENTITY,
d173 1
a173 7
	char *pin;

	pin = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
	if (pin == NULL)
		return -1;

	if (ssh_update_card(ac, add, id, pin)) {
a302 2
		struct stat st;
		int count = 0;
d312 1
a312 1
			snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir,
a313 2
			if (stat(buf, &st) < 0)
				continue;
a315 2
			else
				count++;
a316 2
		if (count == 0)
			ret = 1;
@


1.35
log
@use clear_pass instead of xfree()
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.34 2001/04/14 04:31:01 deraadt Exp $");
a99 40
char *
ssh_askpass(char *askpass, char *msg)
{
	pid_t pid;
	size_t len;
	char *nl, *pass;
	int p[2], status;
	char buf[1024];

	if (fflush(stdout) != 0)
		error("ssh_askpass: fflush: %s", strerror(errno));
	if (askpass == NULL)
		fatal("internal error: askpass undefined");
	if (pipe(p) < 0)
		fatal("ssh_askpass: pipe: %s", strerror(errno));
	if ((pid = fork()) < 0)
		fatal("ssh_askpass: fork: %s", strerror(errno));
	if (pid == 0) {
		close(p[0]);
		if (dup2(p[1], STDOUT_FILENO) < 0)
			fatal("ssh_askpass: dup2: %s", strerror(errno));
		execlp(askpass, askpass, msg, (char *) 0);
		fatal("ssh_askpass: exec(%s): %s", askpass, strerror(errno));
	}
	close(p[1]);
	len = read(p[0], buf, sizeof buf);
	close(p[0]);
	while (waitpid(pid, &status, 0) < 0)
		if (errno != EINTR)
			break;
	if (len <= 1)
		return xstrdup("");
	nl = strchr(buf, '\n');
	if (nl)
		*nl = '\0';
	pass = xstrdup(buf);
	memset(buf, 0, sizeof(buf));
	return pass;
}

d105 2
a106 3
	char *comment = NULL, *askpass = NULL;
	char buf[1024], msg[1024];
	int interactive = isatty(STDIN_FILENO);
a111 7
	if (!interactive && getenv("DISPLAY")) {
		if (getenv(SSH_ASKPASS_ENV))
			askpass = getenv(SSH_ASKPASS_ENV);
		else
			askpass = _PATH_SSH_ASKPASS_DEFAULT;
	}

d123 2
a124 5
		if (!interactive && askpass == NULL) {
			xfree(comment);
			return;
		}
		snprintf(msg, sizeof msg, "Enter passphrase for %.200s", comment);
d126 1
a126 6
			if (interactive) {
				snprintf(buf, sizeof buf, "%s: ", msg);
				pass = read_passphrase(buf, 1);
			} else {
				pass = ssh_askpass(askpass, msg);
			}
d136 1
a136 1
			strlcpy(msg, "Bad passphrase, try again", sizeof msg);
@


1.34
log
@do not double free
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.33 2001/04/09 15:12:23 markus Exp $");
d184 1
a184 2
				xfree(pass);
				pass = NULL;
@


1.33
log
@passphrase caching: ssh-add tries last passphrase, clears passphrase if
not successful and after last try.
based on discussions with espie@@, jakob@@, ... and code from jakob@@ and
wolfgang@@wsrcc.com
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.32 2001/04/08 13:03:00 markus Exp $");
d185 1
@


1.32
log
@init pointers with NULL, thanks to danimal@@danimal.org
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.31 2001/03/26 08:07:08 markus Exp $");
d52 12
d145 1
a145 1
	char *comment = NULL, *askpass = NULL, *pass;
d164 3
d168 2
a188 2
			memset(pass, 0, strlen(pass));
			xfree(pass);
d191 1
d290 1
@


1.31
log
@simpler key load/save interface, see authfile.h
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.30 2001/03/12 22:02:02 markus Exp $");
d56 1
a56 1
	char *comment;
d133 1
a133 1
	char *comment, *askpass = NULL, *pass;
@


1.30
log
@remove old key_fingerprint interface, s/_ex//
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.29 2001/03/02 18:54:31 deraadt Exp $");
d58 4
a61 8
	public = key_new(KEY_RSA1);
	if (!load_public_key(filename, public, &comment)) {
		key_free(public);
		public = key_new(KEY_UNSPEC);
		if (!try_load_public_key(filename, public, &comment)) {
			printf("Bad key file %s\n", filename);
			return;
		}
a131 1
	Key *public;
d133 1
a133 1
	char *saved_comment, *comment, *askpass = NULL;
a134 1
	int success;
a135 1
	int type = KEY_RSA1;
a140 12
	/*
	 * try to load the public key. right now this only works for RSA,
	 * since DSA keys are fully encrypted
	 */
	public = key_new(KEY_RSA1);
	if (!load_public_key(filename, public, &saved_comment)) {
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
		saved_comment = xstrdup(filename);
	}
	key_free(public);

d149 4
a152 3
	private = key_new(type);
	success = load_private_key(filename, "", private, &comment);
	if (!success) {
d155 1
a155 1
			xfree(saved_comment);
d158 1
a158 1
		snprintf(msg, sizeof msg, "Enter passphrase for %.200s", saved_comment);
a159 1
			char *pass;
d168 1
a168 1
				xfree(saved_comment);
d171 1
a171 1
			success = load_private_key(filename, pass, private, &comment);
d174 1
a174 1
			if (success)
d179 2
a180 3
	xfree(comment);
	if (ssh_add_identity(ac, private, saved_comment))
		fprintf(stderr, "Identity added: %s (%s)\n", filename, saved_comment);
d183 1
a184 1
	xfree(saved_comment);
@


1.29
log
@make copyright lines the same format
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.28 2001/02/04 15:32:25 stevesk Exp $");
d208 1
a208 1
list_identities(AuthenticationConnection *ac, int fp)
d211 1
a211 1
	char *comment;
d220 3
a222 1
			if (fp) {
d224 2
a225 2
				    key_size(key), key_fingerprint(key),
				    comment, key_type(key));
@


1.28
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.27 2001/01/21 19:05:56 markus Exp $");
@


1.27
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.26 2001/01/20 21:33:42 markus Exp $");
d247 1
a247 1
        SSLeay_add_all_algorithms();
@


1.26
log
@do not loop forever if askpass does not exist; from andrew@@pimlott.ne.mediaone.net
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.25 2001/01/19 15:55:11 markus Exp $");
a40 2
#include <openssl/rsa.h>
#include <openssl/dsa.h>
d42 1
d44 1
a44 1
#include "ssh.h"
d50 1
@


1.25
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.24 2001/01/13 18:14:13 markus Exp $");
d101 2
@


1.24
log
@typo, from stevesk@@sweden.hp.com
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.23 2000/11/12 19:50:38 markus Exp $");
d50 1
d162 1
a162 1
			askpass = SSH_ASKPASS_DEFAULT;
d284 1
a284 1
		snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
@


1.23
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.22 2000/09/07 20:27:54 deraadt Exp $");
d88 1
a88 1
		fprintf(stderr, "Failed to remove all identitities.\n");
@


1.22
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.21 2000/09/05 19:18:48 markus Exp $");
d57 1
a57 1
	public = key_new(KEY_RSA);
d60 1
a60 1
		public = key_new(KEY_DSA);
d139 1
a139 1
	int type = KEY_RSA;
d149 1
a149 1
	public = key_new(KEY_RSA);
d151 2
a152 2
		/* ok, so we will asume this is a DSA key */
		type = KEY_DSA;
d218 3
a220 2
				printf("%d %s %s\n",
				    key_size(key), key_fingerprint(key), comment);
a243 9
	/* check if RSA support exists */
	if (rsa_alive() == 0) {
		extern char *__progname;

		fprintf(stderr,
			"%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
			__progname);
		exit(1);
	}
@


1.22.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.28 2001/02/04 15:32:25 stevesk Exp $");
d41 2
d44 1
a45 2
#include "rsa.h"
#include "log.h"
a49 2
#include "pathnames.h"
#include "readpass.h"
d57 1
a57 1
	public = key_new(KEY_RSA1);
d60 1
a60 1
		public = key_new(KEY_UNSPEC);
d88 1
a88 1
		fprintf(stderr, "Failed to remove all identities.\n");
a99 2
	if (fflush(stdout) != 0)
		error("ssh_askpass: fflush: %s", strerror(errno));
d139 1
a139 1
	int type = KEY_RSA1;
d149 1
a149 1
	public = key_new(KEY_RSA1);
d151 2
a152 2
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
d161 1
a161 1
			askpass = _PATH_SSH_ASKPASS_DEFAULT;
d218 2
a219 3
				printf("%d %s %s (%s)\n",
				    key_size(key), key_fingerprint(key),
				    comment, key_type(key));
d243 10
a252 1
	SSLeay_add_all_algorithms();
d291 1
a291 1
		snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, _PATH_SSH_CLIENT_IDENTITY);
@


1.22.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.22.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.30 2001/03/12 22:02:02 markus Exp $");
d208 1
a208 1
list_identities(AuthenticationConnection *ac, int do_fp)
d211 1
a211 1
	char *comment, *fp;
d220 1
a220 3
			if (do_fp) {
				fp = key_fingerprint(key, SSH_FP_MD5,
				    SSH_FP_HEX);
d222 2
a223 2
				    key_size(key), fp, comment, key_type(key));
				xfree(fp);
@


1.22.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.36 2001/04/18 21:57:42 markus Exp $");
a51 12
/* we keep a cache of one passphrases */
static char *pass = NULL;
void
clear_pass(void)
{
	if (pass) {
		memset(pass, 0, strlen(pass));
		xfree(pass);
		pass = NULL;
	}
}

d56 1
a56 1
	char *comment = NULL;
d58 8
a65 4
	public = key_load_public(filename, &comment);
	if (public == NULL) {
		printf("Bad key file %s\n", filename);
		return;
d92 40
d136 1
d138 5
a142 2
	char *comment = NULL;
	char msg[1024];
d148 19
d168 3
a170 9
	private = key_load_private(filename, "", &comment);
	if (comment == NULL)
		comment = xstrdup(filename);
	/* try last */
	if (private == NULL && pass != NULL)
		private = key_load_private(filename, pass, NULL);
	if (private == NULL) {
		/* clear passphrase since it did not work */
		clear_pass();
d172 5
a176 2
		snprintf(msg, sizeof msg, "Enter passphrase for %.200s ",
		   comment);
d178 7
a184 1
			pass = read_passphrase(msg, 1);
d186 2
a187 2
				clear_pass();
				xfree(comment);
d190 4
a193 2
			private = key_load_private(filename, pass, &comment);
			if (private != NULL)
d195 1
a195 2
			clear_pass();
			strlcpy(msg, "Bad passphrase, try again ", sizeof msg);
d198 3
a200 2
	if (ssh_add_identity(ac, private, comment))
		fprintf(stderr, "Identity added: %s (%s)\n", filename, comment);
a202 1
	xfree(comment);
d204 1
a293 1
	clear_pass();
@


1.22.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d14 1
a14 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.45 2001/08/03 10:31:30 jakob Exp $");
a51 3
/* argv0 */
extern char *__progname;

d54 1
a54 1
static void
d64 1
a64 1
static void
d84 1
a84 1
static void
d100 1
a100 1
static void
d122 2
a123 1
		snprintf(msg, sizeof msg, "Enter passphrase for %.200s: ",
d126 1
a126 1
			pass = read_passphrase(msg, RP_ALLOW_STDIN);
d136 1
a136 1
			strlcpy(msg, "Bad passphrase, try again: ", sizeof msg);
d147 1
a147 12
static void
update_card(AuthenticationConnection *ac, int add, const char *id)
{
	if (ssh_update_card(ac, add, id))
		fprintf(stderr, "Card %s: %s\n",
		     add ? "added" : "removed", id);
	else
		fprintf(stderr, "Could not %s card: %s\n",
		     add ? "add" : "remove", id);
}

static void
a178 15
static void
usage(void)
{
	fprintf(stderr, "Usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -l          List fingerprints of all identities.\n");
	fprintf(stderr, "  -L          List public key parameters of all identities.\n");
	fprintf(stderr, "  -d          Delete identity.\n");
	fprintf(stderr, "  -D          Delete all identities.\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -s reader   Add key in smartcard reader.\n");
	fprintf(stderr, "  -e reader   Remove key in smartcard reader.\n");
#endif
}

a181 2
	extern char *optarg;
	extern int optind;
d185 3
a187 2
	char *sc_reader_id = NULL;
	int i, ch, deleting = 0;
d197 9
a205 8
        while ((ch = getopt(argc, argv, "lLdDe:s:")) != -1) {
		switch (ch) {
		case 'l':
		case 'L':
			list_identities(ac, ch == 'l' ? 1 : 0);
			goto done;
			break;
		case 'd':
d207 3
a209 2
			break;
		case 'D':
d211 2
a212 13
			goto done;
			break;
		case 's':
			sc_reader_id = optarg;
			break;
		case 'e':
			deleting = 1; 
			sc_reader_id = optarg;
			break;
		default:
			usage();
			exit(1);
			break;
d214 5
d220 1
a220 7
	argc -= optind;
	argv += optind;
	if (sc_reader_id != NULL) {
		update_card(ac, !deleting, sc_reader_id);
		goto done;
	}
	if (argc == 0) {
a232 7
	} else {
		for (i = 0; i < argc; i++) {
			if (deleting)
				delete_file(ac, argv[i]);
			else
				add_file(ac, argv[i]);
		}
a234 2

done:
@


1.22.2.6
log
@Merge OpenSSH 3.0
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.22.2.5 2001/09/27 00:15:42 miod Exp $");
d67 1
a67 1
static int
a71 1
	int ret = -1;
d76 1
a76 1
		return -1;
d78 1
a78 1
	if (ssh_remove_identity(ac, public)) {
d80 1
a80 2
		ret = 0;
	} else
a81 1

a83 2
	
	return ret;
d87 1
a87 1
static int
d90 1
a90 1
	int ret = -1;
d92 2
a93 2
	if (ssh_remove_all_identities(ac, 1))
		ret = 0;
d97 1
a97 1
	if (ret == 0)
a100 2

	return ret;
d103 1
a103 1
static int
a109 1
	int ret = -1;
d113 1
a113 1
		return -1;
d132 1
a132 1
				return -1;
d141 1
a141 1
	if (ssh_add_identity(ac, private, comment)) {
d143 1
a143 2
		ret = 0;
	} else
a144 1

a146 2
	
	return ret;
d149 1
a149 1
static int
d152 1
a152 1
	if (ssh_update_card(ac, add, id)) {
d155 1
a155 2
		return 0;
	} else {
a157 2
		return -1;
	}
d216 1
a216 1
	int i, ch, deleting = 0, ret = 0;
d237 1
a237 2
			if (delete_all(ac) == -1)
				ret = 1;
d249 2
a250 2
			ret = 1;
			goto done;
d256 1
a256 2
		if (update_card(ac, !deleting, sc_reader_id) == -1)
			ret = 1;
d264 2
a265 2
			ret = 1;
			goto done;
d268 4
a271 7
		if (deleting) {
			if (delete_file(ac, buf) == -1)
				ret = 1;
		} else {
			if (add_file(ac, buf) == -1)
				ret = 1;
		}
d274 4
a277 7
			if (deleting) {
				if (delete_file(ac, argv[i]) == -1)
					ret = 1;
			} else {
				if (add_file(ac, argv[i]) == -1)
					ret = 1;
			}
d284 1
a284 1
	return ret;
@


1.22.2.7
log
@Merge OpenSSH 3.1.
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.50 2002/01/29 14:27:57 markus Exp $");
a54 9
/* Default files to add */
static char *default_files[] = {
	_PATH_SSH_CLIENT_ID_RSA,
	_PATH_SSH_CLIENT_ID_DSA,
	_PATH_SSH_CLIENT_IDENTITY, 
	NULL
};


d87 1
a87 1

d157 1
a157 1

d166 1
a166 1
		    add ? "added" : "removed", id);
d170 1
a170 1
		    add ? "add" : "remove", id);
d175 1
a175 1
static int
d185 2
a186 2
		    key != NULL;
		    key = ssh_get_next_identity(ac, &comment, version)) {
d203 1
a203 1
	if (!had_identities) {
a204 16
		return -1;
	}
	return 0;
}

static int
do_file(AuthenticationConnection *ac, int deleting, char *file)
{
	if (deleting) {
		if (delete_file(ac, file) == -1)
			return -1;
	} else {
		if (add_file(ac, file) == -1)
			return -1;
	}
	return 0;
d228 2
d239 1
a239 1
		exit(2);
d241 1
a241 1
	while ((ch = getopt(argc, argv, "lLdDe:s:")) != -1) {
d245 1
a245 2
			if (list_identities(ac, ch == 'l' ? 1 : 0) == -1)
				ret = 1;
d260 1
a260 1
			deleting = 1;
d277 2
a278 4
		char buf[MAXPATHLEN];
		struct passwd *pw;

		if ((pw = getpwuid(getuid())) == NULL) {
d284 6
a289 5

		for(i = 0; default_files[i]; i++) {
			snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir, 
			    default_files[i]);
			if (do_file(ac, deleting, buf) == -1)
d293 8
a300 3
		for(i = 0; i < argc; i++) {
			if (do_file(ac, deleting, argv[i]) == -1)
				ret = 1;
@


1.21
log
@enable ssh-add -d for DSA keys
@
text
@a4 1
 * Created: Thu Apr  6 00:52:24 1995 ylo
d7 6
d15 20
d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.20 2000/08/28 03:50:54 deraadt Exp $");
@


1.20
log
@print uid/gid as unsigned
@
text
@d13 1
a13 1
RCSID("$OpenBSD: ssh-add.c,v 1.19 2000/08/19 21:34:43 markus Exp $");
d34 6
a39 2
		printf("Bad key file %s: %s\n", filename, strerror(errno));
		return;
@


1.19
log
@add SSH2/DSA support to the agent and some other DSA related cleanups.
(note that we cannot talk to ssh.com's ssh2 agents)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: ssh-add.c,v 1.18 2000/07/16 08:27:21 markus Exp $");
d257 2
a258 1
			fprintf(stderr, "No user found with uid %d\n", (int) getuid());
@


1.18
log
@make ssh-add accept dsa keys (the agent does not)
@
text
@d7 3
d13 1
a13 1
RCSID("$OpenBSD: ssh-add.c,v 1.17 2000/06/20 01:39:44 markus Exp $");
d15 1
a21 1
#include "fingerprint.h"
d37 1
a37 1
	if (ssh_remove_identity(ac, public->rsa))
d45 1
d49 8
a56 2
	/* Send a request to remove all identities. */
	if (ssh_remove_all_identities(ac))
d103 1
d112 4
d166 3
a168 4
	xfree(saved_comment);

	if (ssh_add_identity(ac, private, comment))
		fprintf(stderr, "Identity added: %s (%s)\n", filename, comment);
d172 1
a172 1
	xfree(comment);
d178 1
a178 2
	BIGNUM *e, *n;
	int status;
d180 2
a181 1
	int had_identities;
d183 8
a190 15
	e = BN_new();
	n = BN_new();
	had_identities = 0;
	for (status = ssh_get_first_identity(ac, e, n, &comment);
	     status;
	     status = ssh_get_next_identity(ac, e, n, &comment)) {
		unsigned int bits = BN_num_bits(n);
		had_identities = 1;
		if (fp) {
			printf("%d %s %s\n", bits, fingerprint(e, n), comment);
		} else {
			char *ebuf, *nbuf;
			ebuf = BN_bn2dec(e);
			if (ebuf == NULL) {
				error("list_identities: BN_bn2dec(e) failed.");
d192 3
a194 8
				nbuf = BN_bn2dec(n);
				if (nbuf == NULL) {
					error("list_identities: BN_bn2dec(n) failed.");
				} else {
					printf("%d %s %s %s\n", bits, ebuf, nbuf, comment);
					free(nbuf);
				}
				free(ebuf);
d196 2
a198 1
		xfree(comment);
a199 2
	BN_clear_free(e);
	BN_clear_free(n);
d223 2
@


1.17
log
@OpenBSD tag
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-add.c,v 1.16 2000/04/26 20:56:29 markus Exp $");
a17 1
#include "authfd.h"
d20 1
d99 1
d101 4
d107 3
a109 2
		printf("Bad key file %s: %s\n", filename, strerror(errno));
		return;
d121 1
a121 1
	private = key_new(KEY_RSA);
d153 1
a153 1
	if (ssh_add_identity(ac, private->rsa, comment))
@


1.16
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d10 1
a10 1
RCSID("$Id: ssh-add.c,v 1.1.1.1 2000/01/28 15:35:34 markus Exp $");
@


1.16.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@a6 3
 *
 * SSH2 implementation,
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d10 1
a10 1
RCSID("$OpenBSD: ssh-add.c,v 1.20 2000/08/28 03:50:54 deraadt Exp $");
a11 1
#include <openssl/evp.h>
d18 2
a20 1
#include "authfd.h"
d34 1
a34 1
	if (ssh_remove_identity(ac, public))
a41 1
/* Send a request to remove all identities. */
d45 2
a46 8
	int success = 1;

	if (!ssh_remove_all_identities(ac, 1))
		success = 0;
	/* ignore error-code for ssh2 */
	ssh_remove_all_identities(ac, 2);

	if (success)
a92 1
	struct stat st;
a98 1
	int type = KEY_RSA;
a99 8
	if (stat(filename, &st) < 0) {
		perror(filename);
		exit(1);
	}
	/*
	 * try to load the public key. right now this only works for RSA,
	 * since DSA keys are fully encrypted
	 */
d102 2
a103 3
		/* ok, so we will asume this is a DSA key */
		type = KEY_DSA;
		saved_comment = xstrdup(filename);
d115 1
a115 1
	private = key_new(type);
d145 4
a148 3
	xfree(comment);
	if (ssh_add_identity(ac, private, saved_comment))
		fprintf(stderr, "Identity added: %s (%s)\n", filename, saved_comment);
d152 1
a152 1
	xfree(saved_comment);
d158 2
a159 1
	Key *key;
d161 1
a161 2
	int had_identities = 0;
	int version;
d163 15
a177 8
	for (version = 1; version <= 2; version++) {
		for (key = ssh_get_first_identity(ac, &comment, version);
		     key != NULL;
		     key = ssh_get_next_identity(ac, &comment, version)) {
			had_identities = 1;
			if (fp) {
				printf("%d %s %s\n",
				    key_size(key), key_fingerprint(key), comment);
d179 8
a186 3
				if (!key_write(key, stdout))
					fprintf(stderr, "key_write failed");
				fprintf(stdout, " %s\n", comment);
a187 2
			key_free(key);
			xfree(comment);
d189 1
d191 2
a215 2
        SSLeay_add_all_algorithms();

d248 1
a248 2
			fprintf(stderr, "No user found with uid %u\n",
			    (u_int)getuid());
@


1.16.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
a7 6
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
a9 20
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d13 1
a13 1
RCSID("$OpenBSD: ssh-add.c,v 1.22 2000/09/07 20:27:54 deraadt Exp $");
d34 2
a35 6
		key_free(public);
		public = key_new(KEY_DSA);
		if (!try_load_public_key(filename, public, &comment)) {
			printf("Bad key file %s\n", filename);
			return;
		}
@


1.16.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.28 2001/02/04 15:32:25 stevesk Exp $");
d41 2
d44 1
a45 2
#include "rsa.h"
#include "log.h"
a49 2
#include "pathnames.h"
#include "readpass.h"
d57 1
a57 1
	public = key_new(KEY_RSA1);
d60 1
a60 1
		public = key_new(KEY_UNSPEC);
d88 1
a88 1
		fprintf(stderr, "Failed to remove all identities.\n");
a99 2
	if (fflush(stdout) != 0)
		error("ssh_askpass: fflush: %s", strerror(errno));
d139 1
a139 1
	int type = KEY_RSA1;
d149 1
a149 1
	public = key_new(KEY_RSA1);
d151 2
a152 2
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
d161 1
a161 1
			askpass = _PATH_SSH_ASKPASS_DEFAULT;
d218 2
a219 3
				printf("%d %s %s (%s)\n",
				    key_size(key), key_fingerprint(key),
				    comment, key_type(key));
d243 10
a252 1
	SSLeay_add_all_algorithms();
d291 1
a291 1
		snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, _PATH_SSH_CLIENT_IDENTITY);
@


1.16.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d14 1
a14 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d38 1
a38 1
RCSID("$OpenBSD: ssh-add.c,v 1.30 2001/03/12 22:02:02 markus Exp $");
d208 1
a208 1
list_identities(AuthenticationConnection *ac, int do_fp)
d211 1
a211 1
	char *comment, *fp;
d220 1
a220 3
			if (do_fp) {
				fp = key_fingerprint(key, SSH_FP_MD5,
				    SSH_FP_HEX);
d222 2
a223 2
				    key_size(key), fp, comment, key_type(key));
				xfree(fp);
@


1.15
log
@document $SSH_ASKPASS, reasonable default
@
text
@d10 4
a13 1
RCSID("$Id: ssh-add.c,v 1.14 1999/11/24 16:13:45 markus Exp $");
d20 2
d26 1
a26 1
	RSA *key;
d29 2
a30 2
	key = RSA_new();
	if (!load_public_key(filename, key, &comment)) {
d34 1
a34 1
	if (ssh_remove_identity(ac, key))
d38 1
a38 1
	RSA_free(key);
d93 2
a94 2
	RSA *key;
	RSA *public_key;
d100 2
a101 3
	key = RSA_new();
	public_key = RSA_new();
	if (!load_public_key(filename, public_key, &saved_comment)) {
d105 1
a105 1
	RSA_free(public_key);
d115 2
a116 1
	success = load_private_key(filename, "", key, &comment);
d137 1
a137 1
			success = load_private_key(filename, pass, key, &comment);
d147 1
a147 1
	if (ssh_add_identity(ac, key, comment))
d151 1
a151 1
	RSA_free(key);
@


1.14
log
@SSH_ASKPASS support
@
text
@d10 1
a10 1
RCSID("$Id: ssh-add.c,v 1.13 1999/11/24 00:26:03 deraadt Exp $");
d103 6
a108 2
	if (!interactive && getenv("DISPLAY"))
		askpass = getenv("SSH_ASKPASS");
@


1.13
log
@much more KNF
@
text
@d10 1
a10 1
RCSID("$Id: ssh-add.c,v 1.12 1999/11/23 22:25:55 markus Exp $");
d47 38
d90 2
a91 1
	char *saved_comment, *comment;
d93 1
d103 3
d109 2
a110 2
		printf("Need passphrase for %s (%s).\n", filename, saved_comment);
		if (!isatty(STDIN_FILENO)) {
d114 1
d116 7
a122 1
			char *pass = read_passphrase("Enter passphrase: ", 1);
d133 1
a133 1
			printf("Bad passphrase.\n");
@


1.12
log
@KNF part 1
@
text
@d2 6
a7 13

ssh-add.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Thu Apr  6 00:52:24 1995 ylo

Adds an identity to the authentication server, or removes an identity.

*/
d10 1
a10 1
RCSID("$Id: ssh-add.c,v 1.11 1999/11/16 22:49:28 markus Exp $");
@


1.11
log
@rsa key fingerprints, idea from Bjoern Groenvall <bg@@sics.se>
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.10 1999/11/15 20:53:24 markus Exp $");
d28 2
a29 2
  RSA *key;
  char *comment;
d31 11
a41 13
  key = RSA_new();
  if (!load_public_key(filename, key, &comment))
    {
      printf("Bad key file %s: %s\n", filename, strerror(errno));
      return;
    }

  if (ssh_remove_identity(ac, key))
    fprintf(stderr, "Identity removed: %s (%s)\n", filename, comment);
  else
    fprintf(stderr, "Could not remove identity: %s\n", filename);
  RSA_free(key);
  xfree(comment);
d47 5
a51 5
  /* Send a request to remove all identities. */
  if (ssh_remove_all_identities(ac))
    fprintf(stderr, "All identities removed.\n");
  else
    fprintf(stderr, "Failed to remove all identitities.\n");
d57 44
a100 45
  RSA *key;
  RSA *public_key;
  char *saved_comment, *comment;
  int success;
  
  key = RSA_new();
  public_key = RSA_new();
  if (!load_public_key(filename, public_key, &saved_comment))
    {
      printf("Bad key file %s: %s\n", filename, strerror(errno));
      return;
    }
  RSA_free(public_key);

  /* At first, try empty passphrase */
  success = load_private_key(filename, "", key, &comment);
  if (!success) {
    printf("Need passphrase for %s (%s).\n", filename, saved_comment);
    if (!isatty(STDIN_FILENO)){
      xfree(saved_comment);
      return;
    }
    for (;;) {
      char *pass = read_passphrase("Enter passphrase: ", 1);
      if (strcmp(pass, "") == 0){
        xfree(pass);
        xfree(saved_comment);
        return;
      }
      success = load_private_key(filename, pass, key, &comment);
      memset(pass, 0, strlen(pass));
      xfree(pass);
      if (success)
	break;
      printf("Bad passphrase.\n");
    } 
  }
  xfree(saved_comment);

  if (ssh_add_identity(ac, key, comment))
    fprintf(stderr, "Identity added: %s (%s)\n", filename, comment);
  else
    fprintf(stderr, "Could not add identity: %s\n", filename);
  RSA_free(key);
  xfree(comment);
d106 37
a142 38
  BIGNUM *e, *n;
  int status;
  char *comment;
  int had_identities;

  e = BN_new();
  n = BN_new();
  had_identities = 0;
  for (status = ssh_get_first_identity(ac, e, n, &comment);
       status;
       status = ssh_get_next_identity(ac, e, n, &comment))
    {
      unsigned int bits = BN_num_bits(n);
      had_identities = 1;
      if (fp) {
	printf("%d %s %s\n", bits, fingerprint(e, n), comment);
      } else {
	char *ebuf, *nbuf;
	ebuf = BN_bn2dec(e);
	if (ebuf == NULL) {
	  error("list_identities: BN_bn2dec(e) failed.");
	}else{
	  nbuf = BN_bn2dec(n);
	  if (nbuf == NULL) {
	    error("list_identities: BN_bn2dec(n) failed.");
	  }else{
	    printf("%d %s %s %s\n", bits, ebuf, nbuf, comment);
	    free(nbuf);
	  }
	  free(ebuf);
	}
      }
      xfree(comment);
    }
  BN_clear_free(e);
  BN_clear_free(n);
  if (!had_identities)
    printf("The agent has no identities.\n");
d148 60
a207 67
  AuthenticationConnection *ac = NULL;
  struct passwd *pw;
  char buf[1024];
  int no_files = 1;
  int i;
  int deleting = 0;

  /* check if RSA support exists */
  if (rsa_alive() == 0) {
    extern char *__progname;

    fprintf(stderr,
      "%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
      __progname);
    exit(1);
  }

  /* At first, get a connection to the authentication agent. */
  ac = ssh_get_authentication_connection();
  if (ac == NULL) {
    fprintf(stderr, "Could not open a connection to your authentication agent.\n");
    exit(1);
  }

  for (i = 1; i < argc; i++)
    {
      if ((strcmp(argv[i], "-l") == 0) ||
          (strcmp(argv[i], "-L") == 0))
	{
	  list_identities(ac, argv[i][1] == 'l' ? 1 : 0);
	  no_files = 0; /* Don't default-add/delete if -l. */
	  continue;
	}
      if (strcmp(argv[i], "-d") == 0)
	{
	  deleting = 1;
	  continue;
	}
      if (strcmp(argv[i], "-D") == 0)
	{
	  delete_all(ac);
	  no_files = 0;
	  continue;
	}
      no_files = 0;
      if (deleting)
	delete_file(ac, argv[i]);
      else
	add_file(ac, argv[i]);
    }
  if (no_files)
    {
      pw = getpwuid(getuid());
      if (!pw)
	{
	  fprintf(stderr, "No user found with uid %d\n", (int)getuid());
	  ssh_close_authentication_connection(ac);
	  exit(1);
	}
      snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
      if (deleting)
	delete_file(ac, buf);
      else
	add_file(ac, buf);
    }
  ssh_close_authentication_connection(ac);
  exit(0);
@


1.10
log
@the keysize of rsa-parameter 'n' is passed implizit,
a few more checks and warnings about 'pretended' keysizes.
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.9 1999/11/14 17:53:48 markus Exp $");
d23 1
d107 1
a107 1
list_identities(AuthenticationConnection *ac)
d121 1
a121 1
      char *ebuf, *nbuf;
d123 17
a139 13
      ebuf = BN_bn2dec(e);
      if (ebuf == NULL) {
	error("list_identities: BN_bn2dec(e) failed.");
      }else{
        nbuf = BN_bn2dec(n);
        if (nbuf == NULL) {
	  error("list_identities: BN_bn2dec(n) failed.");
        }else{
          unsigned int bits = BN_num_bits(n);
          printf("%d %s %s %s\n", bits, ebuf, nbuf, comment);
          free(nbuf);
        }
        free(ebuf);
d178 2
a179 1
      if (strcmp(argv[i], "-l") == 0)
d181 1
a181 1
	  list_identities(ac);
@


1.9
log
@change passphrase loop logic and remove ref to $DISPLAY, ok niels
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.8 1999/11/02 19:42:36 markus Exp $");
d109 1
a109 1
  int bits, status;
d116 1
a116 1
  for (status = ssh_get_first_identity(ac, &bits, e, n, &comment);
d118 1
a118 1
       status = ssh_get_next_identity(ac, &bits, e, n, &comment))
d120 1
a120 1
      char *buf;
d122 13
a134 14
      printf("%d ", bits);
      buf = BN_bn2dec(e);
      if (buf != NULL) {
        printf("%s ", buf);
        free (buf);
      } else {
	error("list_identities: BN_bn2dec #1 failed.");
      }
      buf = BN_bn2dec(n);
      if (buf != NULL) {
        printf("%s %s\n", buf, comment);
        free (buf);
      } else {
	error("list_identities: BN_bn2dec #2 failed.");
@


1.8
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.7 1999/10/27 23:35:32 markus Exp $");
d60 2
a61 2
  char *saved_comment, *comment, *pass;
  int first;
d71 17
a87 6
  
  pass = xstrdup("");
  first = 1;
  while (!load_private_key(filename, pass, key, &comment))
    {
      /* Free the old passphrase. */
d90 5
a94 26

      /* Ask for a passphrase. */
      if (getenv("DISPLAY") && !isatty(fileno(stdin)))
	{
	      xfree(saved_comment);
	      return;
	}
      else
	{
	  if (first)
	    printf("Need passphrase for %s (%s).\n", filename, saved_comment);
	  else
	    printf("Bad passphrase.\n");
	  pass = read_passphrase("Enter passphrase: ", 1);
	  if (strcmp(pass, "") == 0)
	    {
	      xfree(saved_comment);
	      xfree(pass);
	      return;
	    }
	}
      first = 0;
    }
  memset(pass, 0, strlen(pass));
  xfree(pass);

@


1.7
log
@connect to agent before accepting input. ok niklas@@
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.6 1999/10/17 20:39:11 dugsong Exp $");
d134 6
a139 3
      assert(buf != NULL);
      printf("%s ", buf);
      free (buf);
d141 6
a146 3
      assert(buf != NULL);
      printf("%s %s\n", buf, comment);
      free (buf);
@


1.6
log
@-Wall, get rid of unused headers/vars
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.5 1999/10/11 20:24:54 markus Exp $");
d25 1
a25 1
delete_file(const char *filename)
a28 1
  AuthenticationConnection *ac;
a36 10
  /* Send the request to the authentication agent. */
  ac = ssh_get_authentication_connection();
  if (!ac)
    {
      fprintf(stderr,
	      "Could not open a connection to your authentication agent.\n");
      RSA_free(key);
      xfree(comment);
      return;
    }
a42 1
  ssh_close_authentication_connection(ac);
d46 1
a46 1
delete_all()
a47 11
  AuthenticationConnection *ac;
  
  /* Get a connection to the agent. */
  ac = ssh_get_authentication_connection();
  if (!ac)
    {
      fprintf(stderr,
	      "Could not open a connection to your authentication agent.\n");
      return;
    }

a52 3
  
  /* Close the connection to the agent. */
  ssh_close_authentication_connection(ac);
d56 1
a56 1
add_file(const char *filename)
a59 1
  AuthenticationConnection *ac;
a106 10
  /* Send the key to the authentication agent. */
  ac = ssh_get_authentication_connection();
  if (!ac)
    {
      fprintf(stderr,
	      "Could not open a connection to your authentication agent.\n");
      RSA_free(key);
      xfree(comment);
      return;
    }
a112 1
  ssh_close_authentication_connection(ac);
d116 1
a116 1
list_identities()
a117 1
  AuthenticationConnection *ac;
a122 6
  ac = ssh_get_authentication_connection();
  if (!ac)
    {
      fprintf(stderr, "Could not connect to authentication server.\n");
      return;
    }
a146 1
  ssh_close_authentication_connection(ac);
d150 1
a150 1
main(int ac, char **av)
d152 1
d169 8
a176 1
  for (i = 1; i < ac; i++)
d178 1
a178 1
      if (strcmp(av[i], "-l") == 0)
d180 1
a180 1
	  list_identities();
d184 1
a184 1
      if (strcmp(av[i], "-d") == 0)
d189 1
a189 1
      if (strcmp(av[i], "-D") == 0)
d191 1
a191 1
	  delete_all();
d197 1
a197 1
	delete_file(av[i]);
d199 1
a199 1
	add_file(av[i]);
d207 1
d212 1
a212 1
	delete_file(buf);
d214 1
a214 1
	add_file(buf);
d216 1
@


1.5
log
@we do not ship ssh-askpass
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.4 1999/09/29 21:14:16 deraadt Exp $");
a102 3
      char buf[1024];
      FILE *f;
      
@


1.4
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.3 1999/09/29 06:15:00 deraadt Exp $");
a112 8
	  snprintf(buf, sizeof buf,
	    "ssh-askpass '%sEnter passphrase for %.100s'", 
		  first ? "" : "You entered wrong passphrase.  ", 
		  saved_comment);
	  f = popen(buf, "r");
	  if (!fgets(buf, sizeof(buf), f))
	    {
	      pclose(f);
a114 5
	    }
	  pclose(f);
	  if (strchr(buf, '\n'))
	    *strchr(buf, '\n') = 0;
	  pass = xstrdup(buf);
@


1.3
log
@test for RSA in the ssl library, real early on
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.2 1999/09/28 04:45:37 provos Exp $");
d113 2
a114 1
	  sprintf(buf, "ssh-askpass '%sEnter passphrase for %.100s'", 
d263 1
a263 1
      sprintf(buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d17 1
a17 1
RCSID("$Id: ssh-add.c,v 1.2 1999/05/04 11:59:12 bg Exp $");
d218 10
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@a18 1
#include "randoms.h"
d24 2
a25 1
void delete_file(const char *filename)
d27 1
a27 1
  RSAPublicKey key;
d31 2
a32 1
  if (!load_public_key(filename, &key, &comment))
d44 1
a44 1
      rsa_clear_public_key(&key);
d48 1
a48 1
  if (ssh_remove_identity(ac, &key))
d52 1
a52 1
  rsa_clear_public_key(&key);
d57 2
a58 1
void delete_all()
d81 2
a82 1
void add_file(const char *filename)
d84 2
a85 2
  RSAPrivateKey key;
  RSAPublicKey public_key;
d90 3
a92 1
  if (!load_public_key(filename, &public_key, &saved_comment))
d97 1
a97 1
  rsa_clear_public_key(&public_key);
d101 1
a101 1
  while (!load_private_key(filename, pass, &key, &comment))
d155 1
a155 1
      rsa_clear_private_key(&key);
d159 1
a159 1
  if (ssh_add_identity(ac, &key, comment))
d163 1
a163 1
  rsa_clear_private_key(&key);
d168 2
a169 1
void list_identities()
d172 1
a172 1
  MP_INT e, n;
d183 2
a184 2
  mpz_init(&e);
  mpz_init(&n);
d186 1
a186 1
  for (status = ssh_get_first_identity(ac, &bits, &e, &n, &comment);
d188 1
a188 1
       status = ssh_get_next_identity(ac, &bits, &e, &n, &comment))
d190 1
d193 8
a200 4
      mpz_out_str(stdout, 10, &e);
      printf(" ");
      mpz_out_str(stdout, 10, &n);
      printf(" %s\n", comment);
d203 2
a204 2
  mpz_clear(&e);
  mpz_clear(&n);
d210 2
a211 1
int main(int ac, char **av)
@

