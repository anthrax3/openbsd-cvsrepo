head	1.30;
access;
symbols
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.30
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.28
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.22
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.26
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.24
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.20
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.18
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.16
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.14
	OPENBSD_5_0:1.29.0.12
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.10
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.8
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.4
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.26.0.8
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.10
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.30
date	2016.05.04.14.22.33;	author markus;	state Exp;
branches;
next	1.29;
commitid	hyxgmNlwF7h4Eao2;

1.29
date	2008.11.02.00.16.16;	author stevesk;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.07.00.31.41;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.19.15.45.07;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.25.13.17.03;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.20.21.11.53;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.19.18.51.19;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.07.01.42.00;	author stevesk;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches
	1.19.10.1;
next	1.18;

1.18
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches
	1.18.2.1
	1.18.4.1;
next	1.17;

1.17
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.24.17.18.31;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.04.15.01.35.22;	author stevesk;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.04.14.16.33.20;	author stevesk;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.10.15.02.05;	author stevesk;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.21.19.06.01;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.19.15.55.12;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.07.20.27.55;	author deraadt;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.06.20.01.39.45;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.14.10.30.34;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.11.24.19.53.54;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.24.00.26.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.11.23.22.25.56;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.09.30.05.03.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.38;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2000.09.01.18.23.25;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.11.08.21.31.35;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.03.12.15.44.18;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.21.18.53.19;	author jason;	state Exp;
branches;
next	;

1.8.2.1
date	2001.02.16.20.13.24;	author jason;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.02.19.17.19.41;	author jason;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.03.21.19.46.32;	author jason;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.05.07.21.09.38;	author jason;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2001.09.27.00.15.43;	author miod;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.13.2.1
date	2001.09.27.19.03.56;	author jason;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.14.2.1
date	2002.03.07.17.37.48;	author jason;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.05.17.00.03.25;	author miod;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	;

1.18.2.1
date	2003.09.16.21.20.29;	author brad;	state Exp;
branches;
next	;

1.18.4.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2004.03.04.18.18.17;	author brad;	state Exp;
branches;
next	;

1.19.10.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.20.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.30
log
@move SSH_MSG_NONE, so we don't have to include ssh1.h; ok deraadt@@
@
text
@/* $OpenBSD: ttymodes.c,v 1.29 2008/11/02 00:16:16 stevesk Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

/*
 * SSH2 tty modes support by Kevin Steves.
 * Copyright (c) 2001 Kevin Steves.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Encoding and decoding of terminal modes in a portable way.
 * Much of the format is defined in ttymodes.h; it is included multiple times
 * into this file with the appropriate macro definitions to generate the
 * suitable code.
 */

#include <sys/types.h>

#include <errno.h>
#include <string.h>
#include <termios.h>
#include <stdarg.h>

#include "packet.h"
#include "log.h"
#include "compat.h"
#include "buffer.h"

#define TTY_OP_END		0
/*
 * uint32 (u_int) follows speed in SSH1 and SSH2
 */
#define TTY_OP_ISPEED_PROTO1	192
#define TTY_OP_OSPEED_PROTO1	193
#define TTY_OP_ISPEED_PROTO2	128
#define TTY_OP_OSPEED_PROTO2	129

/*
 * Converts POSIX speed_t to a baud rate.  The values of the
 * constants for speed_t are not themselves portable.
 */
static int
speed_to_baud(speed_t speed)
{
	switch (speed) {
	case B0:
		return 0;
	case B50:
		return 50;
	case B75:
		return 75;
	case B110:
		return 110;
	case B134:
		return 134;
	case B150:
		return 150;
	case B200:
		return 200;
	case B300:
		return 300;
	case B600:
		return 600;
	case B1200:
		return 1200;
	case B1800:
		return 1800;
	case B2400:
		return 2400;
	case B4800:
		return 4800;
	case B9600:
		return 9600;

#ifdef B19200
	case B19200:
		return 19200;
#else /* B19200 */
#ifdef EXTA
	case EXTA:
		return 19200;
#endif /* EXTA */
#endif /* B19200 */

#ifdef B38400
	case B38400:
		return 38400;
#else /* B38400 */
#ifdef EXTB
	case EXTB:
		return 38400;
#endif /* EXTB */
#endif /* B38400 */

#ifdef B7200
	case B7200:
		return 7200;
#endif /* B7200 */
#ifdef B14400
	case B14400:
		return 14400;
#endif /* B14400 */
#ifdef B28800
	case B28800:
		return 28800;
#endif /* B28800 */
#ifdef B57600
	case B57600:
		return 57600;
#endif /* B57600 */
#ifdef B76800
	case B76800:
		return 76800;
#endif /* B76800 */
#ifdef B115200
	case B115200:
		return 115200;
#endif /* B115200 */
#ifdef B230400
	case B230400:
		return 230400;
#endif /* B230400 */
	default:
		return 9600;
	}
}

/*
 * Converts a numeric baud rate to a POSIX speed_t.
 */
static speed_t
baud_to_speed(int baud)
{
	switch (baud) {
	case 0:
		return B0;
	case 50:
		return B50;
	case 75:
		return B75;
	case 110:
		return B110;
	case 134:
		return B134;
	case 150:
		return B150;
	case 200:
		return B200;
	case 300:
		return B300;
	case 600:
		return B600;
	case 1200:
		return B1200;
	case 1800:
		return B1800;
	case 2400:
		return B2400;
	case 4800:
		return B4800;
	case 9600:
		return B9600;

#ifdef B19200
	case 19200:
		return B19200;
#else /* B19200 */
#ifdef EXTA
	case 19200:
		return EXTA;
#endif /* EXTA */
#endif /* B19200 */

#ifdef B38400
	case 38400:
		return B38400;
#else /* B38400 */
#ifdef EXTB
	case 38400:
		return EXTB;
#endif /* EXTB */
#endif /* B38400 */

#ifdef B7200
	case 7200:
		return B7200;
#endif /* B7200 */
#ifdef B14400
	case 14400:
		return B14400;
#endif /* B14400 */
#ifdef B28800
	case 28800:
		return B28800;
#endif /* B28800 */
#ifdef B57600
	case 57600:
		return B57600;
#endif /* B57600 */
#ifdef B76800
	case 76800:
		return B76800;
#endif /* B76800 */
#ifdef B115200
	case 115200:
		return B115200;
#endif /* B115200 */
#ifdef B230400
	case 230400:
		return B230400;
#endif /* B230400 */
	default:
		return B9600;
	}
}

/*
 * Encodes terminal modes for the terminal referenced by fd
 * or tiop in a portable manner, and appends the modes to a packet
 * being constructed.
 */
void
tty_make_modes(int fd, struct termios *tiop)
{
	struct termios tio;
	int baud;
	Buffer buf;
	int tty_op_ospeed, tty_op_ispeed;
	void (*put_arg)(Buffer *, u_int);

	buffer_init(&buf);
	if (compat20) {
		tty_op_ospeed = TTY_OP_OSPEED_PROTO2;
		tty_op_ispeed = TTY_OP_ISPEED_PROTO2;
		put_arg = buffer_put_int;
	} else {
		tty_op_ospeed = TTY_OP_OSPEED_PROTO1;
		tty_op_ispeed = TTY_OP_ISPEED_PROTO1;
		put_arg = (void (*)(Buffer *, u_int)) buffer_put_char;
	}

	if (tiop == NULL) {
		if (fd == -1) {
			debug("tty_make_modes: no fd or tio");
			goto end;
		}
		if (tcgetattr(fd, &tio) == -1) {
			logit("tcgetattr: %.100s", strerror(errno));
			goto end;
		}
	} else
		tio = *tiop;

	/* Store input and output baud rates. */
	baud = speed_to_baud(cfgetospeed(&tio));
	buffer_put_char(&buf, tty_op_ospeed);
	buffer_put_int(&buf, baud);
	baud = speed_to_baud(cfgetispeed(&tio));
	buffer_put_char(&buf, tty_op_ispeed);
	buffer_put_int(&buf, baud);

	/* Store values of mode flags. */
#define TTYCHAR(NAME, OP) \
	buffer_put_char(&buf, OP); \
	put_arg(&buf, tio.c_cc[NAME]);

#define TTYMODE(NAME, FIELD, OP) \
	buffer_put_char(&buf, OP); \
	put_arg(&buf, ((tio.FIELD & NAME) != 0));

#include "ttymodes.h"

#undef TTYCHAR
#undef TTYMODE

end:
	/* Mark end of mode data. */
	buffer_put_char(&buf, TTY_OP_END);
	if (compat20)
		packet_put_string(buffer_ptr(&buf), buffer_len(&buf));
	else
		packet_put_raw(buffer_ptr(&buf), buffer_len(&buf));
	buffer_free(&buf);
}

/*
 * Decodes terminal modes for the terminal referenced by fd in a portable
 * manner from a packet being read.
 */
void
tty_parse_modes(int fd, int *n_bytes_ptr)
{
	struct termios tio;
	int opcode, baud;
	int n_bytes = 0;
	int failure = 0;
	u_int (*get_arg)(void);
	int arg_size;

	if (compat20) {
		*n_bytes_ptr = packet_get_int();
		if (*n_bytes_ptr == 0)
			return;
		get_arg = packet_get_int;
		arg_size = 4;
	} else {
		get_arg = packet_get_char;
		arg_size = 1;
	}

	/*
	 * Get old attributes for the terminal.  We will modify these
	 * flags. I am hoping that if there are any machine-specific
	 * modes, they will initially have reasonable values.
	 */
	if (tcgetattr(fd, &tio) == -1) {
		logit("tcgetattr: %.100s", strerror(errno));
		failure = -1;
	}

	for (;;) {
		n_bytes += 1;
		opcode = packet_get_char();
		switch (opcode) {
		case TTY_OP_END:
			goto set;

		/* XXX: future conflict possible */
		case TTY_OP_ISPEED_PROTO1:
		case TTY_OP_ISPEED_PROTO2:
			n_bytes += 4;
			baud = packet_get_int();
			if (failure != -1 &&
			    cfsetispeed(&tio, baud_to_speed(baud)) == -1)
				error("cfsetispeed failed for %d", baud);
			break;

		/* XXX: future conflict possible */
		case TTY_OP_OSPEED_PROTO1:
		case TTY_OP_OSPEED_PROTO2:
			n_bytes += 4;
			baud = packet_get_int();
			if (failure != -1 &&
			    cfsetospeed(&tio, baud_to_speed(baud)) == -1)
				error("cfsetospeed failed for %d", baud);
			break;

#define TTYCHAR(NAME, OP) \
	case OP: \
	  n_bytes += arg_size; \
	  tio.c_cc[NAME] = get_arg(); \
	  break;
#define TTYMODE(NAME, FIELD, OP) \
	case OP: \
	  n_bytes += arg_size; \
	  if (get_arg()) \
	    tio.FIELD |= NAME; \
	  else \
	    tio.FIELD &= ~NAME;	\
	  break;

#include "ttymodes.h"

#undef TTYCHAR
#undef TTYMODE

		default:
			debug("Ignoring unsupported tty mode opcode %d (0x%x)",
			    opcode, opcode);
			if (!compat20) {
				/*
				 * SSH1:
				 * Opcodes 1 to 127 are defined to have
				 * a one-byte argument.
				 * Opcodes 128 to 159 are defined to have
				 * an integer argument.
				 */
				if (opcode > 0 && opcode < 128) {
					n_bytes += 1;
					(void) packet_get_char();
					break;
				} else if (opcode >= 128 && opcode < 160) {
					n_bytes += 4;
					(void) packet_get_int();
					break;
				} else {
					/*
					 * It is a truly undefined opcode (160 to 255).
					 * We have no idea about its arguments.  So we
					 * must stop parsing.  Note that some data
					 * may be left in the packet; hopefully there
					 * is nothing more coming after the mode data.
					 */
					logit("parse_tty_modes: unknown opcode %d",
					    opcode);
					goto set;
				}
			} else {
				/*
				 * SSH2:
				 * Opcodes 1 to 159 are defined to have
				 * a uint32 argument.
				 * Opcodes 160 to 255 are undefined and
				 * cause parsing to stop.
				 */
				if (opcode > 0 && opcode < 160) {
					n_bytes += 4;
					(void) packet_get_int();
					break;
				} else {
					logit("parse_tty_modes: unknown opcode %d",
					    opcode);
					goto set;
				}
			}
		}
	}

set:
	if (*n_bytes_ptr != n_bytes) {
		*n_bytes_ptr = n_bytes;
		logit("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d",
		    *n_bytes_ptr, n_bytes);
		return;		/* Don't process bytes passed */
	}
	if (failure == -1)
		return;		/* Packet parsed ok but tcgetattr() failed */

	/* Set the new modes for the terminal. */
	if (tcsetattr(fd, TCSANOW, &tio) == -1)
		logit("Setting tty modes failed: %.100s", strerror(errno));
}
@


1.29
log
@protocol 2 tty modes support is now 7.5 years old so remove these
debug3()s; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ttymodes.c,v 1.28 2008/07/07 00:31:41 stevesk Exp $ */
a54 1
#include "ssh1.h"
@


1.28
log
@we don't need arg after the debug3() was removed.  from lint.
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ttymodes.c,v 1.27 2008/05/19 15:45:07 djm Exp $ */
a285 1
	debug3("tty_make_modes: ospeed %d", baud);
a288 1
	debug3("tty_make_modes: ispeed %d", baud);
a331 1
		debug3("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
a362 1
			debug3("tty_parse_modes: ispeed %d", baud);
a372 1
			debug3("tty_parse_modes: ospeed %d", baud);
@


1.27
log
@Fix sending tty modes when stdin is not a tty (bz#1199). Previously
we would send the modes corresponding to a zeroed struct termios,
whereas we should have been sending an empty list of modes.
Based on patch from daniel.ritz AT alcatel.ch; ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ttymodes.c,v 1.26 2006/08/03 03:34:42 deraadt Exp $ */
d330 1
a330 1
	int arg, arg_size;
d391 1
a391 1
	  if ((arg = get_arg())) \
@


1.26
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ttymodes.c,v 1.25 2006/07/22 20:48:23 stevesk Exp $ */
d273 4
a295 1
	debug3("tty_make_modes: %d %d", OP, tio.c_cc[NAME]); \
a299 1
	debug3("tty_make_modes: %d %d", OP, ((tio.FIELD & NAME) != 0)); \
a386 1
	  debug3("tty_parse_modes: %d %d", OP, tio.c_cc[NAME]); \
a394 1
	  debug3("tty_parse_modes: %d %d", OP, arg); \
@


1.25
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ttymodes.c,v 1.24 2006/07/11 20:07:25 stevesk Exp $ */
d46 1
a46 1
#include "includes.h"
d51 1
a57 1
#include "bufaux.h"
@


1.24
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ttymodes.c,v 1.23 2006/03/25 13:17:03 djm Exp $ */
d49 1
@


1.23
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d48 1
@


1.22
log
@spacing
@
text
@d1 1
@


1.21
log
@RCSID() can die
@
text
@d362 2
a363 1
			if (failure != -1 && cfsetispeed(&tio, baud_to_speed(baud)) == -1)
d373 2
a374 1
			if (failure != -1 && cfsetospeed(&tio, baud_to_speed(baud)) == -1)
d422 3
a424 3
					 * must stop parsing.  Note that some data may be
					 * left in the packet; hopefully there is nothing
					 * more coming after the mode data.
d426 2
a427 1
					logit("parse_tty_modes: unknown opcode %d", opcode);
d443 2
a444 1
					logit("parse_tty_modes: unknown opcode %d", opcode);
@


1.20
log
@move #include <termios.h> out of includes.h; ok markus@@
@
text
@a45 1
RCSID("$OpenBSD: ttymodes.c,v 1.19 2003/04/08 20:21:29 itojun Exp $");
@


1.20.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ttymodes.c,v 1.26 2006/08/03 03:34:42 deraadt Exp $ */
d45 2
a46 1
#include <sys/types.h>
a47 2
#include <errno.h>
#include <string.h>
a48 1
#include <stdarg.h>
d55 1
d363 1
a363 2
			if (failure != -1 &&
			    cfsetispeed(&tio, baud_to_speed(baud)) == -1)
d373 1
a373 2
			if (failure != -1 &&
			    cfsetospeed(&tio, baud_to_speed(baud)) == -1)
d421 3
a423 3
					 * must stop parsing.  Note that some data
					 * may be left in the packet; hopefully there
					 * is nothing more coming after the mode data.
d425 1
a425 2
					logit("parse_tty_modes: unknown opcode %d",
					    opcode);
d441 1
a441 2
					logit("parse_tty_modes: unknown opcode %d",
					    opcode);
@


1.19
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d46 3
a48 1
RCSID("$OpenBSD: ttymodes.c,v 1.18 2002/06/19 00:27:55 deraadt Exp $");
@


1.19.10.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ttymodes.c,v 1.26 2006/08/03 03:34:42 deraadt Exp $ */
d45 2
a46 6
#include <sys/types.h>

#include <errno.h>
#include <string.h>
#include <termios.h>
#include <stdarg.h>
d53 1
d361 1
a361 2
			if (failure != -1 &&
			    cfsetispeed(&tio, baud_to_speed(baud)) == -1)
d371 1
a371 2
			if (failure != -1 &&
			    cfsetospeed(&tio, baud_to_speed(baud)) == -1)
d419 3
a421 3
					 * must stop parsing.  Note that some data
					 * may be left in the packet; hopefully there
					 * is nothing more coming after the mode data.
d423 1
a423 2
					logit("parse_tty_modes: unknown opcode %d",
					    opcode);
d439 1
a439 2
					logit("parse_tty_modes: unknown opcode %d",
					    opcode);
@


1.18
log
@KNF done automatically while reading....
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.17 2002/03/19 10:49:35 markus Exp $");
d270 1
a270 1
			log("tcgetattr: %.100s", strerror(errno));
d344 1
a344 1
		log("tcgetattr: %.100s", strerror(errno));
d423 1
a423 1
					log("parse_tty_modes: unknown opcode %d", opcode);
d439 1
a439 1
					log("parse_tty_modes: unknown opcode %d", opcode);
d449 1
a449 1
		log("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d",
d458 1
a458 1
		log("Setting tty modes failed: %.100s", strerror(errno));
@


1.18.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.19 2003/04/08 20:21:29 itojun Exp $");
d270 1
a270 1
			logit("tcgetattr: %.100s", strerror(errno));
d344 1
a344 1
		logit("tcgetattr: %.100s", strerror(errno));
d423 1
a423 1
					logit("parse_tty_modes: unknown opcode %d", opcode);
d439 1
a439 1
					logit("parse_tty_modes: unknown opcode %d", opcode);
d449 1
a449 1
		logit("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d",
d458 1
a458 1
		logit("Setting tty modes failed: %.100s", strerror(errno));
@


1.18.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.19 2003/04/08 20:21:29 itojun Exp $");
d270 1
a270 1
			logit("tcgetattr: %.100s", strerror(errno));
d344 1
a344 1
		logit("tcgetattr: %.100s", strerror(errno));
d423 1
a423 1
					logit("parse_tty_modes: unknown opcode %d", opcode);
d439 1
a439 1
					logit("parse_tty_modes: unknown opcode %d", opcode);
d449 1
a449 1
		logit("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d",
d458 1
a458 1
		logit("Setting tty modes failed: %.100s", strerror(errno));
@


1.18.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@@


1.17
log
@KNF whitespace
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.16 2001/12/27 20:39:58 markus Exp $");
a309 1
	return;
a458 1
	return;
@


1.17.2.1
log
@Pull in OpenSSH-3.4
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.18 2002/06/19 00:27:55 deraadt Exp $");
d310 1
d460 1
@


1.16
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.15 2001/12/19 07:18:56 deraadt Exp $");
d405 3
a407 3
  				 * Opcodes 128 to 159 are defined to have
  				 * an integer argument.
  				 */
d413 3
a415 3
  					n_bytes += 4;
  					(void) packet_get_int();
  					break;
d426 1
a426 1
  				}
d443 1
a443 1
  			}
@


1.15
log
@basic KNF done while i was looking for something else
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.14 2001/06/24 17:18:31 markus Exp $");
a424 1
					packet_integrity_check(0, 1, SSH_CMSG_REQUEST_PTY);
@


1.14
log
@passing modes works fine: debug2->3
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.13 2001/04/15 01:35:22 stevesk Exp $");
d399 1
a399 1
			      opcode, opcode);
@


1.14.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.16 2001/12/27 20:39:58 markus Exp $");
d399 1
a399 1
			    opcode, opcode);
d425 1
@


1.14.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.17 2002/03/19 10:49:35 markus Exp $");
d405 3
a407 3
				 * Opcodes 128 to 159 are defined to have
				 * an integer argument.
				 */
d413 3
a415 3
					n_bytes += 4;
					(void) packet_get_int();
					break;
d426 1
a426 1
				}
d443 1
a443 1
			}
@


1.14.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.14.2.2 2002/05/17 00:03:25 miod Exp $");
d310 1
d460 1
@


1.13
log
@fix comments
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.12 2001/04/14 16:33:20 stevesk Exp $");
d278 1
a278 1
	debug2("tty_make_modes: ospeed %d", baud);
d282 1
a282 1
	debug2("tty_make_modes: ispeed %d", baud);
d288 1
a288 1
	debug2("tty_make_modes: %d %d", OP, tio.c_cc[NAME]); \
d293 1
a293 1
	debug2("tty_make_modes: %d %d", OP, ((tio.FIELD & NAME) != 0)); \
d329 1
a329 1
		debug2("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
d361 1
a361 1
			debug2("tty_parse_modes: ispeed %d", baud);
d371 1
a371 1
			debug2("tty_parse_modes: ospeed %d", baud);
d380 1
a380 1
	  debug2("tty_parse_modes: %d %d", OP, tio.c_cc[NAME]); \
d389 1
a389 1
	  debug2("tty_parse_modes: %d %d", OP, arg); \
@


1.13.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.14 2001/06/24 17:18:31 markus Exp $");
d278 1
a278 1
	debug3("tty_make_modes: ospeed %d", baud);
d282 1
a282 1
	debug3("tty_make_modes: ispeed %d", baud);
d288 1
a288 1
	debug3("tty_make_modes: %d %d", OP, tio.c_cc[NAME]); \
d293 1
a293 1
	debug3("tty_make_modes: %d %d", OP, ((tio.FIELD & NAME) != 0)); \
d329 1
a329 1
		debug3("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
d361 1
a361 1
			debug3("tty_parse_modes: ispeed %d", baud);
d371 1
a371 1
			debug3("tty_parse_modes: ospeed %d", baud);
d380 1
a380 1
	  debug3("tty_parse_modes: %d %d", OP, tio.c_cc[NAME]); \
d389 1
a389 1
	  debug3("tty_parse_modes: %d %d", OP, arg); \
@


1.13.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.16 2001/12/27 20:39:58 markus Exp $");
d399 1
a399 1
			    opcode, opcode);
d425 1
@


1.13.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.17 2002/03/19 10:49:35 markus Exp $");
d405 3
a407 3
				 * Opcodes 128 to 159 are defined to have
				 * an integer argument.
				 */
d413 3
a415 3
					n_bytes += 4;
					(void) packet_get_int();
					break;
d426 1
a426 1
				}
d443 1
a443 1
			}
@


1.12
log
@protocol 2 tty modes support; ok markus@@
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.11 2001/03/10 15:02:05 stevesk Exp $");
d431 1
a431 1
				 * Opcodes 0 to 159 are defined to have
d456 1
a456 1
		return;		/* Packet parsed ok but tty stuff failed */
@


1.11
log
@remove unused sgtty macros; ok markus@@
@
text
@a4 4
 * Encoding and decoding of terminal modes in a portable way.
 * Much of the format is defined in ttymodes.h; it is included multiple times
 * into this file with the appropriate macro definitions to generate the
 * suitable code.
d13 32
d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.10 2001/01/21 19:06:01 markus Exp $");
d51 3
d55 8
a62 3
#define TTY_OP_END	0
#define TTY_OP_ISPEED	192	/* int follows */
#define TTY_OP_OSPEED	193	/* int follows */
d161 1
a161 1
		case 0:
d245 1
a245 1
 * in a portable manner, and appends the modes to a packet
d249 1
a249 1
tty_make_modes(int fd)
d253 22
a275 5
	if (tcgetattr(fd, &tio) < 0) {
		packet_put_char(TTY_OP_END);
		log("tcgetattr: %.100s", strerror(errno));
		return;
	}
d278 3
a280 2
	packet_put_char(TTY_OP_OSPEED);
	packet_put_int(baud);
d282 3
a284 2
	packet_put_char(TTY_OP_ISPEED);
	packet_put_int(baud);
d288 4
a291 1
  packet_put_char(OP); packet_put_char(tio.c_cc[NAME]);
d293 3
a295 1
  packet_put_char(OP); packet_put_char((tio.FIELD & NAME) != 0);
d302 1
d304 7
a310 1
	packet_put_char(TTY_OP_END);
d324 14
d344 2
a345 1
	if (tcgetattr(fd, &tio) < 0)
d347 1
d356 3
a358 1
		case TTY_OP_ISPEED:
d361 2
a362 1
			if (failure != -1 && cfsetispeed(&tio, baud_to_speed(baud)) < 0)
d366 3
a368 1
		case TTY_OP_OSPEED:
d371 2
a372 1
			if (failure != -1 && cfsetospeed(&tio, baud_to_speed(baud)) < 0)
d376 5
a380 4
#define TTYCHAR(NAME, OP) 				\
	case OP:					\
	  n_bytes += 1;					\
	  tio.c_cc[NAME] = packet_get_char();		\
d382 8
a389 7
#define TTYMODE(NAME, FIELD, OP)		       	\
	case OP:					\
	  n_bytes += 1;					\
	  if (packet_get_char())			\
	    tio.FIELD |= NAME;				\
	  else						\
	    tio.FIELD &= ~NAME;				\
d400 28
a427 8
			/*
			 * Opcodes 0 to 127 are defined to have
			 * a one-byte argument.
			 */
			if (opcode >= 0 && opcode < 128) {
				n_bytes += 1;
				(void) packet_get_char();
				break;
d430 5
a434 2
				 * Opcodes 128 to 159 are defined to have
				 * an integer argument.
d436 1
a436 1
				if (opcode >= 128 && opcode < 160) {
d440 3
d444 1
a444 11
			}
			/*
			 * It is a truly undefined opcode (160 to 255).
			 * We have no idea about its arguments.  So we
			 * must stop parsing.  Note that some data may be
			 * left in the packet; hopefully there is nothing
			 * more coming after the mode data.
			 */
			log("parse_tty_modes: unknown opcode %d", opcode);
			packet_integrity_check(0, 1, SSH_CMSG_REQUEST_PTY);
			goto set;
d451 2
d459 1
a459 1
	if (tcsetattr(fd, TCSANOW, &tio) < 0)
@


1.10
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.9 2001/01/19 15:55:12 markus Exp $");
a235 3
#define SGTTYCHAR(NAME, OP)
#define SGTTYMODE(NAME, FIELD, OP)
#define SGTTYMODEN(NAME, FIELD, OP)
a240 3
#undef SGTTYCHAR
#undef SGTTYMODE
#undef SGTTYMODEN
a299 3
#define SGTTYCHAR(NAME, OP)
#define SGTTYMODE(NAME, FIELD, OP)
#define SGTTYMODEN(NAME, FIELD, OP)
a304 3
#undef SGTTYCHAR
#undef SGTTYMODE
#undef SGTTYMODEN
@


1.9
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.8 2000/09/07 20:27:55 deraadt Exp $");
d21 1
a21 1
#include "ssh.h"
@


1.8
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.7 2000/06/20 01:39:45 markus Exp $");
d22 1
@


1.8.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.10 2001/01/21 19:06:01 markus Exp $");
d21 1
a21 2
#include "log.h"
#include "ssh1.h"
@


1.8.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.8.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.11 2001/03/10 15:02:05 stevesk Exp $");
d236 3
d244 3
d306 3
d314 3
@


1.8.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d5 4
a16 32
/*
 * SSH2 tty modes support by Kevin Steves.
 * Copyright (c) 2001 Kevin Steves.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Encoding and decoding of terminal modes in a portable way.
 * Much of the format is defined in ttymodes.h; it is included multiple times
 * into this file with the appropriate macro definitions to generate the
 * suitable code.
 */

d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.13 2001/04/15 01:35:22 stevesk Exp $");
a22 3
#include "compat.h"
#include "buffer.h"
#include "bufaux.h"
d24 3
a26 8
#define TTY_OP_END		0
/*
 * uint32 (u_int) follows speed in SSH1 and SSH2
 */
#define TTY_OP_ISPEED_PROTO1	192
#define TTY_OP_OSPEED_PROTO1	193
#define TTY_OP_ISPEED_PROTO2	128
#define TTY_OP_OSPEED_PROTO2	129
d125 1
a125 1
	case 0:
d209 1
a209 1
 * or tiop in a portable manner, and appends the modes to a packet
d213 1
a213 1
tty_make_modes(int fd, struct termios *tiop)
d217 5
a221 13
	Buffer buf;
	int tty_op_ospeed, tty_op_ispeed;
	void (*put_arg)(Buffer *, u_int);

	buffer_init(&buf);
	if (compat20) {
		tty_op_ospeed = TTY_OP_OSPEED_PROTO2;
		tty_op_ispeed = TTY_OP_ISPEED_PROTO2;
		put_arg = buffer_put_int;
	} else {
		tty_op_ospeed = TTY_OP_OSPEED_PROTO1;
		tty_op_ispeed = TTY_OP_ISPEED_PROTO1;
		put_arg = (void (*)(Buffer *, u_int)) buffer_put_char;
a222 9

	if (tiop == NULL) {
		if (tcgetattr(fd, &tio) == -1) {
			log("tcgetattr: %.100s", strerror(errno));
			goto end;
		}
	} else
		tio = *tiop;

d225 2
a226 3
	debug2("tty_make_modes: ospeed %d", baud);
	buffer_put_char(&buf, tty_op_ospeed);
	buffer_put_int(&buf, baud);
d228 2
a229 3
	debug2("tty_make_modes: ispeed %d", baud);
	buffer_put_char(&buf, tty_op_ispeed);
	buffer_put_int(&buf, baud);
d233 1
a233 4
	debug2("tty_make_modes: %d %d", OP, tio.c_cc[NAME]); \
	buffer_put_char(&buf, OP); \
	put_arg(&buf, tio.c_cc[NAME]);

d235 1
a235 3
	debug2("tty_make_modes: %d %d", OP, ((tio.FIELD & NAME) != 0)); \
	buffer_put_char(&buf, OP); \
	put_arg(&buf, ((tio.FIELD & NAME) != 0));
a241 1
end:
d243 1
a243 7
	buffer_put_char(&buf, TTY_OP_END);
	if (compat20)
		packet_put_string(buffer_ptr(&buf), buffer_len(&buf));
	else
		packet_put_raw(buffer_ptr(&buf), buffer_len(&buf));
	buffer_free(&buf);
	return;
a256 14
	u_int (*get_arg)(void);
	int arg, arg_size;

	if (compat20) {
		*n_bytes_ptr = packet_get_int();
		debug2("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
		if (*n_bytes_ptr == 0)
			return;
		get_arg = packet_get_int;
		arg_size = 4;
	} else {
		get_arg = packet_get_char;
		arg_size = 1;
	}
d263 1
a263 2
	if (tcgetattr(fd, &tio) == -1) {
		log("tcgetattr: %.100s", strerror(errno));
a264 1
	}
d273 1
a273 3
		/* XXX: future conflict possible */
		case TTY_OP_ISPEED_PROTO1:
		case TTY_OP_ISPEED_PROTO2:
d276 1
a276 2
			debug2("tty_parse_modes: ispeed %d", baud);
			if (failure != -1 && cfsetispeed(&tio, baud_to_speed(baud)) == -1)
d280 1
a280 3
		/* XXX: future conflict possible */
		case TTY_OP_OSPEED_PROTO1:
		case TTY_OP_OSPEED_PROTO2:
d283 1
a283 2
			debug2("tty_parse_modes: ospeed %d", baud);
			if (failure != -1 && cfsetospeed(&tio, baud_to_speed(baud)) == -1)
d287 4
a290 5
#define TTYCHAR(NAME, OP) \
	case OP: \
	  n_bytes += arg_size; \
	  tio.c_cc[NAME] = get_arg(); \
	  debug2("tty_parse_modes: %d %d", OP, tio.c_cc[NAME]); \
d292 7
a298 8
#define TTYMODE(NAME, FIELD, OP) \
	case OP: \
	  n_bytes += arg_size; \
	  if ((arg = get_arg())) \
	    tio.FIELD |= NAME; \
	  else \
	    tio.FIELD &= ~NAME;	\
	  debug2("tty_parse_modes: %d %d", OP, arg); \
d309 8
a316 28
			if (!compat20) {
				/*
				 * SSH1:
				 * Opcodes 1 to 127 are defined to have
				 * a one-byte argument.
  				 * Opcodes 128 to 159 are defined to have
  				 * an integer argument.
  				 */
				if (opcode > 0 && opcode < 128) {
					n_bytes += 1;
					(void) packet_get_char();
					break;
				} else if (opcode >= 128 && opcode < 160) {
  					n_bytes += 4;
  					(void) packet_get_int();
  					break;
				} else {
					/*
					 * It is a truly undefined opcode (160 to 255).
					 * We have no idea about its arguments.  So we
					 * must stop parsing.  Note that some data may be
					 * left in the packet; hopefully there is nothing
					 * more coming after the mode data.
					 */
					log("parse_tty_modes: unknown opcode %d", opcode);
					packet_integrity_check(0, 1, SSH_CMSG_REQUEST_PTY);
					goto set;
  				}
d319 2
a320 5
				 * SSH2:
				 * Opcodes 1 to 159 are defined to have
				 * a uint32 argument.
				 * Opcodes 160 to 255 are undefined and
				 * cause parsing to stop.
d322 1
a322 1
				if (opcode > 0 && opcode < 160) {
a325 3
				} else {
					log("parse_tty_modes: unknown opcode %d", opcode);
					goto set;
d327 11
a337 1
  			}
a343 2
		log("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d",
		    *n_bytes_ptr, n_bytes);
d347 1
a347 1
		return;		/* Packet parsed ok but tcgetattr() failed */
d350 1
a350 1
	if (tcsetattr(fd, TCSANOW, &tio) == -1)
@


1.8.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.14 2001/06/24 17:18:31 markus Exp $");
d278 1
a278 1
	debug3("tty_make_modes: ospeed %d", baud);
d282 1
a282 1
	debug3("tty_make_modes: ispeed %d", baud);
d288 1
a288 1
	debug3("tty_make_modes: %d %d", OP, tio.c_cc[NAME]); \
d293 1
a293 1
	debug3("tty_make_modes: %d %d", OP, ((tio.FIELD & NAME) != 0)); \
d329 1
a329 1
		debug3("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
d361 1
a361 1
			debug3("tty_parse_modes: ispeed %d", baud);
d371 1
a371 1
			debug3("tty_parse_modes: ospeed %d", baud);
d380 1
a380 1
	  debug3("tty_parse_modes: %d %d", OP, tio.c_cc[NAME]); \
d389 1
a389 1
	  debug3("tty_parse_modes: %d %d", OP, arg); \
@


1.8.2.6
log
@Merge OpenSSH 3.1.
@
text
@d46 1
a46 1
RCSID("$OpenBSD: ttymodes.c,v 1.16 2001/12/27 20:39:58 markus Exp $");
d399 1
a399 1
			    opcode, opcode);
d425 1
@


1.7
log
@OpenBSD tag
@
text
@a4 1
 * Created: Tue Mar 21 15:59:15 1995 ylo
d9 6
d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.6 2000/04/14 10:30:34 markus Exp $");
@


1.6
log
@whitespace cleanup
@
text
@d13 1
a13 1
RCSID("$Id: ttymodes.c,v 1.5 1999/11/24 19:53:54 markus Exp $");
@


1.6.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d13 1
a13 1
RCSID("$OpenBSD: ttymodes.c,v 1.7 2000/06/20 01:39:45 markus Exp $");
@


1.6.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
a9 6
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d13 1
a13 1
RCSID("$OpenBSD: ttymodes.c,v 1.8 2000/09/07 20:27:55 deraadt Exp $");
@


1.6.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.10 2001/01/21 19:06:01 markus Exp $");
d21 1
a21 2
#include "log.h"
#include "ssh1.h"
@


1.6.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d18 1
a18 1
RCSID("$OpenBSD: ttymodes.c,v 1.11 2001/03/10 15:02:05 stevesk Exp $");
d236 3
d244 3
d306 3
d314 3
@


1.5
log
@KNF, final part 3
@
text
@d13 1
a13 1
RCSID("$Id: ttymodes.c,v 1.4 1999/11/24 00:26:04 deraadt Exp $");
d26 1
a26 1
static int 
d115 1
a115 1
static speed_t 
d206 1
a206 1
void 
d250 1
a250 1
void 
@


1.4
log
@much more KNF
@
text
@d13 1
a13 1
RCSID("$Id: ttymodes.c,v 1.3 1999/11/23 22:25:56 markus Exp $");
a211 1
	/* Get the modes. */
@


1.3
log
@KNF part 1
@
text
@d2 9
a10 16

ttymodes.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Tue Mar 21 15:59:15 1995 ylo

Encoding and decoding of terminal modes in a portable way.
Much of the format is defined in ttymodes.h; it is included multiple times
into this file with the appropriate macro definitions to generate the
suitable code.

*/
d13 1
a13 1
RCSID("$Id: ttymodes.c,v 1.2 1999/09/30 05:03:05 deraadt Exp $");
d22 4
a25 3
/* Converts POSIX speed_t to a baud rate.  The values of the constants
   for speed_t are not themselves portable. */

d112 3
a114 2
/* Converts a numeric baud rate to a POSIX speed_t. */

d201 5
a205 3
/* Encodes terminal modes for the terminal referenced by fd in a portable
   manner, and appends the modes to a packet being constructed. */

d247 4
a250 3
/* Decodes terminal modes for the terminal referenced by fd in a portable
   manner from a packet being read. */

d259 5
a263 3
	/* Get old attributes for the terminal.  We will modify these
	   flags. I am hoping that if there are any machine-specific
	   modes, they will initially have reasonable values. */
d316 4
a319 1
			/* Opcodes 0 to 127 are defined to have a one-byte argument. */
d325 4
a328 1
				/* Opcodes 128 to 159 are defined to have an integer argument. */
d335 7
a341 5
			/* It is a truly undefined opcode (160 to 255).
			   We have no idea about its arguments.  So we
			   must stop parsing.  Note that some data may be
			   left in the packet; hopefully there is nothing
			   more coming after the mode data. */
@


1.2
log
@cull more ancient garbage from pre-POSIX days
@
text
@d20 1
a20 1
RCSID("$Id: ttymodes.c,v 1.1 1999/09/26 20:53:38 deraadt Exp $");
d26 2
a27 2
#define TTY_OP_ISPEED	192 /* int follows */
#define TTY_OP_OSPEED	193 /* int follows */
d32 2
a33 1
static int speed_to_baud(speed_t speed)
d35 29
a63 30
  switch (speed)
    {
    case B0:
      return 0;
    case B50:
      return 50;
    case B75:
      return 75;
    case B110:
      return 110;
    case B134:
      return 134;
    case B150:
      return 150;
    case B200:
      return 200;
    case B300:
      return 300;
    case B600:
      return 600;
    case B1200:
      return 1200;
    case B1800:
      return 1800;
    case B2400:
      return 2400;
    case B4800:
      return 4800;
    case B9600:
      return 9600;
d66 2
a67 2
    case B19200:
      return 19200;
d70 2
a71 2
    case EXTA:
      return 19200;
d76 2
a77 2
    case B38400:
      return 38400;
d80 2
a81 2
    case EXTB:
      return 38400;
d86 2
a87 2
    case B7200:
      return 7200;
d90 2
a91 2
    case B14400:
      return 14400;
d94 2
a95 2
    case B28800:
      return 28800;
d98 2
a99 2
    case B57600:
      return 57600;
d102 2
a103 2
    case B76800:
      return 76800;
d106 2
a107 2
    case B115200:
      return 115200;
d110 2
a111 2
    case B230400:
      return 230400;
d113 3
a115 3
    default:
      return 9600;
    }
d120 2
a121 1
static speed_t baud_to_speed(int baud)
d123 29
a151 30
  switch (baud)
    {
    case 0:
      return B0;
    case 50:
      return B50;
    case 75:
      return B75;
    case 110:
      return B110;
    case 134:
      return B134;
    case 150:
      return B150;
    case 200:
      return B200;
    case 300:
      return B300;
    case 600:
      return B600;
    case 1200:
      return B1200;
    case 1800:
      return B1800;
    case 2400:
      return B2400;
    case 4800:
      return B4800;
    case 9600:
      return B9600;
d154 2
a155 2
    case 19200:
      return B19200;
d158 2
a159 2
    case 19200:
      return EXTA;
d164 2
a165 2
    case 38400:
      return B38400;
d168 2
a169 2
    case 38400:
      return EXTB;
d174 2
a175 2
    case 7200:
      return B7200;
d178 2
a179 2
    case 14400:
      return B14400;
d182 2
a183 2
    case 28800:
      return B28800;
d186 2
a187 2
    case 57600:
      return B57600;
d190 2
a191 2
    case 76800:
      return B76800;
d194 2
a195 2
    case 115200:
      return B115200;
d198 2
a199 2
    case 230400:
      return B230400;
d201 3
a203 3
    default:
      return B9600;
    }
d209 2
a210 1
void tty_make_modes(int fd)
d212 2
a213 2
  struct termios tio;
  int baud;
d215 13
a227 15
  /* Get the modes. */
  if (tcgetattr(fd, &tio) < 0)
    {
      packet_put_char(TTY_OP_END);
      log("tcgetattr: %.100s", strerror(errno));
      return;
    }

  /* Store input and output baud rates. */
  baud = speed_to_baud(cfgetospeed(&tio));
  packet_put_char(TTY_OP_OSPEED);
  packet_put_int(baud);
  baud = speed_to_baud(cfgetispeed(&tio));
  packet_put_char(TTY_OP_ISPEED);
  packet_put_int(baud);
d229 1
a229 1
  /* Store values of mode flags. */
d246 2
a247 2
  /* Mark end of mode data. */
  packet_put_char(TTY_OP_END);
d253 2
a254 1
void tty_parse_modes(int fd, int *n_bytes_ptr)
d256 31
a286 33
  struct termios tio;
  int opcode, baud;
  int n_bytes = 0;
  int failure = 0;

  /* Get old attributes for the terminal.  We will modify these flags. 
     I am hoping that if there are any machine-specific modes, they will
     initially have reasonable values. */
  if (tcgetattr(fd, &tio) < 0)
    failure = -1;

  for (;;)
    {
      n_bytes += 1;
      opcode = packet_get_char();
      switch (opcode)
	{
	case TTY_OP_END:
	  goto set;

	case TTY_OP_ISPEED:
	  n_bytes += 4;
	  baud = packet_get_int();
	  if (failure != -1 && cfsetispeed(&tio, baud_to_speed(baud)) < 0)
	    error("cfsetispeed failed for %d", baud);
	  break;

	case TTY_OP_OSPEED:
	  n_bytes += 4;
	  baud = packet_get_int();
	  if (failure != -1 && cfsetospeed(&tio, baud_to_speed(baud)) < 0)
	    error("cfsetospeed failed for %d", baud);
	  break;
d313 24
a336 18
	default:
	  debug("Ignoring unsupported tty mode opcode %d (0x%x)",
		opcode, opcode);
	  /* Opcodes 0 to 127 are defined to have a one-byte argument. */
	  if (opcode >= 0 && opcode < 128)
	    {
	      n_bytes += 1;
	      (void)packet_get_char();
	      break;
	    }
	  else
	    {
	      /* Opcodes 128 to 159 are defined to have an integer argument. */
	      if (opcode >= 128 && opcode < 160)
		{
		  n_bytes += 4;
		  (void)packet_get_int();
		  break;
a337 8
	    }
	  /* It is a truly undefined opcode (160 to 255).  We have no idea
	     about its arguments.  So we must stop parsing.  Note that some
	     data may be left in the packet; hopefully there is nothing more
	     coming after the mode data. */
	  log("parse_tty_modes: unknown opcode %d", opcode);
	  packet_integrity_check(0, 1, SSH_CMSG_REQUEST_PTY);
	  goto set;
a338 1
    }
d340 12
a351 14
 set:
  if (*n_bytes_ptr != n_bytes)
    {
      *n_bytes_ptr = n_bytes;
      return;			/* Don't process bytes passed */
    }

  if (failure == -1)
    return;			/* Packet parsed ok but tty stuff failed */
  
  /* Set the new modes for the terminal. */
  if (tcsetattr(fd, TCSANOW, &tio) < 0)
    log("Setting tty modes failed: %.100s", strerror(errno));
  return;
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d20 1
a20 1
RCSID("$Id: ttymodes.c,v 1.3 1999/05/04 11:59:25 bg Exp $");
a28 12
/* Speed extraction & setting macros for sgtty. */

#ifdef USING_SGTTY
#define cfgetospeed(tio)	((tio)->sg_ospeed)
#define cfgetispeed(tio)	((tio)->sg_ispeed)
#define cfsetospeed(tio, spd)	((tio)->sg_ospeed = (spd), 0)
#define cfsetispeed(tio, spd)	((tio)->sg_ispeed = (spd), 0)
#ifndef SPEED_T_IN_STDTYPES_H
typedef char speed_t;
#endif
#endif

a210 1
#ifdef USING_TERMIOS
a211 10
#endif
#ifdef USING_SGTTY
  struct sgttyb tio;
  struct tchars tiotc;
  struct ltchars tioltc;
  int tiolm;
#ifdef TIOCGSTAT
  struct tstatus tiots;
#endif /* TIOCGSTAT */
#endif /* USING_SGTTY */
a214 1
#ifdef USING_TERMIOS
a220 35
#endif /* USING_TERMIOS */
#ifdef USING_SGTTY
  if (ioctl(fd, TIOCGETP, &tio) < 0)
    {
      packet_put_char(TTY_OP_END);
      log("ioctl(fd, TIOCGETP, ...): %.100s", strerror(errno));
      return;
    }
  if (ioctl(fd, TIOCGETC, &tiotc) < 0)
    {
      packet_put_char(TTY_OP_END);
      log("ioctl(fd, TIOCGETC, ...): %.100s", strerror(errno));
      return;
    }
  if (ioctl(fd, TIOCLGET, &tiolm) < 0)
    {
      packet_put_char(TTY_OP_END);
      log("ioctl(fd, TIOCLGET, ...): %.100s", strerror(errno));
      return;
    }
  if (ioctl(fd, TIOCGLTC, &tioltc) < 0)
    {
      packet_put_char(TTY_OP_END);
      log("ioctl(fd, TIOCGLTC, ...): %.100s", strerror(errno));
      return;
    }
#ifdef TIOCGSTAT
  if (ioctl(fd, TIOCGSTAT, &tiots) < 0) 
    {
      packet_put_char(TTY_OP_END);
      log("ioctl(fd, TIOCGSTAT, ...): %.100s", strerror(errno));
      return;
    }
#endif /* TIOCGSTAT */
#endif /* USING_SGTTY */
a230 1
#ifdef USING_TERMIOS
a237 12
#endif /* USING_TERMIOS */

#ifdef USING_SGTTY
#define TTYCHAR(NAME, OP)
#define TTYMODE(NAME, FIELD, OP)
#define SGTTYCHAR(NAME, OP) \
  packet_put_char(OP); packet_put_char(NAME);
#define SGTTYMODE(NAME, FIELD, OP) \
  packet_put_char(OP); packet_put_char((FIELD & NAME) != 0);
#define SGTTYMODEN(NAME, FIELD, OP) \
  packet_put_char(OP); packet_put_char((FIELD & NAME) == 0);
#endif /* USING_SGTTY */
a255 1
#ifdef USING_TERMIOS
a256 10
#endif /* USING_TERMIOS */
#ifdef USING_SGTTY
  struct sgttyb tio;
  struct tchars tiotc;
  struct ltchars tioltc;
  int tiolm;
#ifdef TIOCGSTAT
  struct tstatus tiots;
#endif /* TIOCGSTAT */
#endif
a263 1
#ifdef USING_TERMIOS
a265 15
#endif /* USING_TERMIOS */
#ifdef USING_SGTTY
  if (ioctl(fd, TIOCGETP, &tio) < 0)
    failure = -1;
  if (ioctl(fd, TIOCGETC, &tiotc) < 0)
    failure = -1;
  if (ioctl(fd, TIOCLGET, &tiolm) < 0)
    failure = -1;
  if (ioctl(fd, TIOCGLTC, &tioltc) < 0)
    failure = -1;
#ifdef TIOCGSTAT
  if (ioctl(fd, TIOCGSTAT, &tiots) < 0)
    failure = -1;
#endif /* TIOCGSTAT */
#endif /* USING_SGTTY */
a289 1
#ifdef USING_TERMIOS
a305 27
#endif /* USING_TERMIOS */

#ifdef USING_SGTTY
#define TTYCHAR(NAME, OP)
#define TTYMODE(NAME, FIELD, OP)
#define SGTTYCHAR(NAME, OP) 				\
	case OP:					\
	  n_bytes += 1;					\
	  NAME = packet_get_char();			\
	  break;
#define SGTTYMODE(NAME, FIELD, OP)		       	\
	case OP:					\
	  n_bytes += 1;					\
	  if (packet_get_char())			\
	    FIELD |= NAME;				\
	  else						\
	    FIELD &= ~NAME;				\
	  break;
#define SGTTYMODEN(NAME, FIELD, OP)		       	\
	case OP:					\
	  n_bytes += 1;					\
	  if (packet_get_char())			\
	    FIELD &= ~NAME;				\
	  else						\
	    FIELD |= NAME;				\
	  break;
#endif /* USING_SGTTY */
a355 1
#ifdef USING_TERMIOS
a357 12
#endif /* USING_TERMIOS */
#ifdef USING_SGTTY
  if (ioctl(fd, TIOCSETP, &tio) < 0
      || ioctl(fd, TIOCSETC, &tiotc) < 0
      || ioctl(fd, TIOCLSET, &tiolm) < 0
      || ioctl(fd, TIOCSLTC, &tioltc) < 0
#ifdef TIOCSSTAT
      || ioctl(fd, TIOCSSTAT, &tiots) < 0
#endif /* TIOCSSTAT */
     ) 
    log("Setting tty modes failed: %.100s", strerror(errno));
#endif /* USING_SGTTY */
@

