head	1.127;
access;
symbols
	OPENBSD_6_2_BASE:1.127
	OPENBSD_6_1:1.126.0.4
	OPENBSD_6_1_BASE:1.126
	OPENBSD_6_0:1.124.0.4
	OPENBSD_6_0_BASE:1.124
	OPENBSD_5_9:1.121.0.2
	OPENBSD_5_9_BASE:1.121
	OPENBSD_5_8:1.120.0.2
	OPENBSD_5_8_BASE:1.120
	OPENBSD_5_7:1.117.0.2
	OPENBSD_5_7_BASE:1.117
	OPENBSD_5_6:1.115.0.4
	OPENBSD_5_6_BASE:1.115
	OPENBSD_5_5:1.114.0.4
	OPENBSD_5_5_BASE:1.114
	OPENBSD_5_4:1.101.0.2
	OPENBSD_5_4_BASE:1.101
	OPENBSD_5_3:1.97.0.4
	OPENBSD_5_3_BASE:1.97
	OPENBSD_5_2:1.97.0.2
	OPENBSD_5_2_BASE:1.97
	OPENBSD_5_1_BASE:1.96
	OPENBSD_5_1:1.96.0.2
	OPENBSD_5_0:1.94.0.4
	OPENBSD_5_0_BASE:1.94
	OPENBSD_4_9:1.94.0.2
	OPENBSD_4_9_BASE:1.94
	OPENBSD_4_8:1.92.0.2
	OPENBSD_4_8_BASE:1.92
	OPENBSD_4_7:1.90.0.2
	OPENBSD_4_7_BASE:1.90
	OPENBSD_4_6:1.87.0.4
	OPENBSD_4_6_BASE:1.87
	OPENBSD_4_5:1.86.0.4
	OPENBSD_4_5_BASE:1.86
	OPENBSD_4_4:1.86.0.2
	OPENBSD_4_4_BASE:1.86
	OPENBSD_4_3:1.80.0.2
	OPENBSD_4_3_BASE:1.80
	OPENBSD_4_2:1.76.0.4
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.76.0.2
	OPENBSD_4_1_BASE:1.76
	OPENBSD_4_0:1.74.0.4
	OPENBSD_4_0_BASE:1.74
	OPENBSD_3_9:1.60.0.2
	OPENBSD_3_9_BASE:1.60
	OPENBSD_3_8:1.57.0.2
	OPENBSD_3_8_BASE:1.57
	OPENBSD_3_7:1.53.0.2
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.51.0.2
	OPENBSD_3_6_BASE:1.51
	OPENBSD_3_5:1.47.0.2
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.44.0.2
	OPENBSD_3_4_BASE:1.44
	OPENBSD_3_3:1.42.0.2
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_8:1.10.0.2;
locks; strict;
comment	@ * @;


1.127
date	2017.08.11.04.41.08;	author djm;	state Exp;
branches;
next	1.126;
commitid	M1xYxEiQvZmhlYQe;

1.126
date	2017.01.03.05.46.51;	author djm;	state Exp;
branches;
next	1.125;
commitid	suDniqofduEsGUp4;

1.125
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.124;
commitid	ZllbGwdb0fOmLhjK;

1.124
date	2016.05.25.23.48.45;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	NPBJoBfuBDOIqIQi;

1.123
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.122;
commitid	RYYIr1bk0phq4fXa;

1.122
date	2016.04.08.08.19.17;	author djm;	state Exp;
branches;
next	1.121;
commitid	muNH4U8SNAOORI3Q;

1.121
date	2016.02.11.02.21.34;	author djm;	state Exp;
branches;
next	1.120;
commitid	sB75bajqSjylBVDG;

1.120
date	2015.05.28.04.50.53;	author djm;	state Exp;
branches;
next	1.119;
commitid	szMwGQxvTtyEhPsm;

1.119
date	2015.05.23.14.28.37;	author jsg;	state Exp;
branches;
next	1.118;
commitid	BuBF0uNP3zhaIjDd;

1.118
date	2015.04.24.01.36.00;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	LHkUmZjv49ojnnuH;

1.117
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	cBx23BaCk6gYBpRj;

1.116
date	2015.01.14.13.54.13;	author djm;	state Exp;
branches;
next	1.115;
commitid	5mVYZPiIJUHzgjMn;

1.115
date	2014.04.21.14.36.16;	author logan;	state Exp;
branches;
next	1.114;

1.114
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.113;

1.113
date	2014.01.17.00.21.06;	author djm;	state Exp;
branches;
next	1.112;

1.112
date	2014.01.16.07.31.09;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2013.12.05.22.59.45;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2013.12.04.04.20.01;	author djm;	state Exp;
branches;
next	1.109;

1.109
date	2013.11.08.11.15.19;	author dtucker;	state Exp;
branches;
next	1.108;

1.108
date	2013.11.08.00.39.15;	author djm;	state Exp;
branches;
next	1.107;

1.107
date	2013.10.17.00.30.13;	author djm;	state Exp;
branches;
next	1.106;

1.106
date	2013.10.11.02.52.23;	author djm;	state Exp;
branches;
next	1.105;

1.105
date	2013.10.11.02.45.36;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2013.09.19.00.49.12;	author djm;	state Exp;
branches;
next	1.103;

1.103
date	2013.08.09.03.39.13;	author djm;	state Exp;
branches;
next	1.102;

1.102
date	2013.08.08.05.04.03;	author djm;	state Exp;
branches;
next	1.101;

1.101
date	2013.07.25.00.56.51;	author djm;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2013.06.01.22.34.50;	author dtucker;	state Exp;
branches;
next	1.99;

1.99
date	2013.06.01.20.59.25;	author dtucker;	state Exp;
branches;
next	1.98;

1.98
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2012.07.02.12.13.26;	author dtucker;	state Exp;
branches
	1.97.4.1;
next	1.96;

1.96
date	2011.09.12.08.46.15;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2011.09.11.16.07.26;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2010.12.04.00.18.01;	author djm;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.22.22.58.51;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2010.07.19.03.16.33;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.18.04.43.08;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2009.10.11.10.41.26;	author dtucker;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.18.18.36.20;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2009.08.14.18.17.49;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2009.06.22.05.39.28;	author dtucker;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.26.06.10.09;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2008.06.12.20.47.04;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.08.20.15.29;	author dtucker;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.07.21.52.46;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2008.04.18.12.32.11;	author djm;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.23.12.54.01;	author djm;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.21.19.20.17;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.19.22.04.57;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.11.07.22.27;	author chl;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.16.00.55.52;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2007.01.22.11.32.50;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2006.10.22.02.25.50;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.74.4.1;
next	1.73;

1.73
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.23.01.11.05;	author stevesk;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.16.00.54.10;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.30.09.58.16;	author djm;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2006.02.15.05.08.24;	author david;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.02.01.20.31;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2005.07.27.10.39.03;	author dtucker;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.24.17.32.44;	author avsm;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2004.11.25.22.22.14;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2004.06.03.12.22.20;	author pedro;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.19.12.17.33;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.30.12.41.56;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.03.09.30.42;	author djm;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2004.02.17.05.39.51;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2003.01.14.10.58.00;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.10.08.48.15;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.10.08.19.07;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.06.23.51.22;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.21.23.03.51;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.05.20.10.37;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.11.22.41.49;	author djm;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2002.06.27.10.35.47;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.23.09.30.14;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.09.13.32.01;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.06.00.30.08;	author djm;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2002.04.01.22.07.17;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.01.22.02.16;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.11.03.19.53;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.11.03.18.49;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.08.06.10.16;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.24.16.57.19;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.13.00.59.23;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.12.12.44.46;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.12.12.32.27;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.05.00.00.46;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.14.15.10.16;	author stevesk;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.05.10.42.52;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.03.19.10.52.51;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.16.08.16.17;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.14.08.57.14;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.13.22.42.54;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.07.10.11.22;	author djm;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.02.14.09.46.03;	author djm;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.02.10.00.41.46;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.17.11.23;	author stevesk;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.07.21.58.34;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.07.18.01.18;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.07.10.55.12;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.06.23.30.28;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.04.15.32.25;	author stevesk;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.04.15.23.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.04.11.11.54;	author djm;	state Exp;
branches;
next	;

1.10.2.1
date	2001.02.16.20.13.14;	author jason;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.02.19.17.19.21;	author jason;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.03.21.19.46.28;	author jason;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.05.07.21.09.34;	author jason;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.11.2.1
date	2001.03.12.15.44.14;	author jason;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.03.21.18.53.04;	author jason;	state Exp;
branches;
next	;

1.16.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.18.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.31.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.35.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.42.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.44.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.47.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.51.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.53.2.1
date	2005.09.04.18.40.03;	author brad;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.57.2.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.57.2.3;

1.57.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.60.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.74.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;

1.97.4.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.101.2.1
date	2013.11.08.01.33.56;	author djm;	state Exp;
branches;
next	;


desc
@@


1.127
log
@don't print verbose error message when ssh disconnects under sftp;
bz#2750; ok dtucker@@
@
text
@/* $OpenBSD: sftp-client.c,v 1.126 2017/01/03 05:46:51 djm Exp $ */
/*
 * Copyright (c) 2001-2004 Damien Miller <djm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* XXX: memleaks */
/* XXX: signed vs unsigned */
/* XXX: remove all logging, only return status codes */
/* XXX: copy between two remote sites */

#include <sys/types.h>
#include <sys/poll.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/statvfs.h>
#include <sys/uio.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssherr.h"
#include "sshbuf.h"
#include "log.h"
#include "atomicio.h"
#include "progressmeter.h"
#include "misc.h"
#include "utf8.h"

#include "sftp.h"
#include "sftp-common.h"
#include "sftp-client.h"

extern volatile sig_atomic_t interrupted;
extern int showprogress;

/* Minimum amount of data to read at a time */
#define MIN_READ_SIZE	512

/* Maximum depth to descend in directory trees */
#define MAX_DIR_DEPTH 64

struct sftp_conn {
	int fd_in;
	int fd_out;
	u_int transfer_buflen;
	u_int num_requests;
	u_int version;
	u_int msg_id;
#define SFTP_EXT_POSIX_RENAME	0x00000001
#define SFTP_EXT_STATVFS	0x00000002
#define SFTP_EXT_FSTATVFS	0x00000004
#define SFTP_EXT_HARDLINK	0x00000008
#define SFTP_EXT_FSYNC		0x00000010
	u_int exts;
	u_int64_t limit_kbps;
	struct bwlimit bwlimit_in, bwlimit_out;
};

static u_char *
get_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,
    const char *errfmt, ...) __attribute__((format(printf, 4, 5)));

/* ARGSUSED */
static int
sftpio(void *_bwlimit, size_t amount)
{
	struct bwlimit *bwlimit = (struct bwlimit *)_bwlimit;

	bandwidth_limit(bwlimit, amount);
	return 0;
}

static void
send_msg(struct sftp_conn *conn, struct sshbuf *m)
{
	u_char mlen[4];
	struct iovec iov[2];

	if (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)
		fatal("Outbound message too long %zu", sshbuf_len(m));

	/* Send length first */
	put_u32(mlen, sshbuf_len(m));
	iov[0].iov_base = mlen;
	iov[0].iov_len = sizeof(mlen);
	iov[1].iov_base = (u_char *)sshbuf_ptr(m);
	iov[1].iov_len = sshbuf_len(m);

	if (atomiciov6(writev, conn->fd_out, iov, 2,
	    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=
	    sshbuf_len(m) + sizeof(mlen))
		fatal("Couldn't send packet: %s", strerror(errno));

	sshbuf_reset(m);
}

static void
get_msg(struct sftp_conn *conn, struct sshbuf *m)
{
	u_int msg_len;
	u_char *p;
	int r;

	if ((r = sshbuf_reserve(m, 4, &p)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (atomicio6(read, conn->fd_in, p, 4,
	    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in) != 4) {
		if (errno == EPIPE || errno == ECONNRESET)
			fatal("Connection closed");
		else
			fatal("Couldn't read packet: %s", strerror(errno));
	}

	if ((r = sshbuf_get_u32(m, &msg_len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (msg_len > SFTP_MAX_MSG_LENGTH)
		fatal("Received message too long %u", msg_len);

	if ((r = sshbuf_reserve(m, msg_len, &p)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (atomicio6(read, conn->fd_in, p, msg_len,
	    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in)
	    != msg_len) {
		if (errno == EPIPE)
			fatal("Connection closed");
		else
			fatal("Read packet: %s", strerror(errno));
	}
}

static void
send_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,
    u_int len)
{
	struct sshbuf *msg;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, code)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_string(msg, s, len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message fd %d T:%u I:%u", conn->fd_out, code, id);
	sshbuf_free(msg);
}

static void
send_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,
    const void *s, u_int len, Attrib *a)
{
	struct sshbuf *msg;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, code)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_string(msg, s, len)) != 0 ||
	    (r = encode_attrib(msg, a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message fd %d T:%u I:%u", conn->fd_out, code, id);
	sshbuf_free(msg);
}

static u_int
get_status(struct sftp_conn *conn, u_int expected_id)
{
	struct sshbuf *msg;
	u_char type;
	u_int id, status;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	get_msg(conn, msg);
	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
	    (r = sshbuf_get_u32(msg, &id)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if (id != expected_id)
		fatal("ID mismatch (%u != %u)", id, expected_id);
	if (type != SSH2_FXP_STATUS)
		fatal("Expected SSH2_FXP_STATUS(%u) packet, got %u",
		    SSH2_FXP_STATUS, type);

	if ((r = sshbuf_get_u32(msg, &status)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	sshbuf_free(msg);

	debug3("SSH2_FXP_STATUS %u", status);

	return status;
}

static u_char *
get_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,
    const char *errfmt, ...)
{
	struct sshbuf *msg;
	u_int id, status;
	u_char type;
	u_char *handle;
	char errmsg[256];
	va_list args;
	int r;

	va_start(args, errfmt);
	if (errfmt != NULL)
		vsnprintf(errmsg, sizeof(errmsg), errfmt, args);
	va_end(args);

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	get_msg(conn, msg);
	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
	    (r = sshbuf_get_u32(msg, &id)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if (id != expected_id)
		fatal("%s: ID mismatch (%u != %u)",
		    errfmt == NULL ? __func__ : errmsg, id, expected_id);
	if (type == SSH2_FXP_STATUS) {
		if ((r = sshbuf_get_u32(msg, &status)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		if (errfmt != NULL)
			error("%s: %s", errmsg, fx2txt(status));
		sshbuf_free(msg);
		return(NULL);
	} else if (type != SSH2_FXP_HANDLE)
		fatal("%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u",
		    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);

	if ((r = sshbuf_get_string(msg, &handle, len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	sshbuf_free(msg);

	return handle;
}

static Attrib *
get_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)
{
	struct sshbuf *msg;
	u_int id;
	u_char type;
	int r;
	static Attrib a;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	get_msg(conn, msg);

	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
	    (r = sshbuf_get_u32(msg, &id)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("Received stat reply T:%u I:%u", type, id);
	if (id != expected_id)
		fatal("ID mismatch (%u != %u)", id, expected_id);
	if (type == SSH2_FXP_STATUS) {
		u_int status;

		if ((r = sshbuf_get_u32(msg, &status)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		if (quiet)
			debug("Couldn't stat remote file: %s", fx2txt(status));
		else
			error("Couldn't stat remote file: %s", fx2txt(status));
		sshbuf_free(msg);
		return(NULL);
	} else if (type != SSH2_FXP_ATTRS) {
		fatal("Expected SSH2_FXP_ATTRS(%u) packet, got %u",
		    SSH2_FXP_ATTRS, type);
	}
	if ((r = decode_attrib(msg, &a)) != 0) {
		error("%s: couldn't decode attrib: %s", __func__, ssh_err(r));
		sshbuf_free(msg);
		return NULL;
	}
	sshbuf_free(msg);

	return &a;
}

static int
get_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,
    u_int expected_id, int quiet)
{
	struct sshbuf *msg;
	u_char type;
	u_int id;
	u_int64_t flag;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	get_msg(conn, msg);

	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
	    (r = sshbuf_get_u32(msg, &id)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("Received statvfs reply T:%u I:%u", type, id);
	if (id != expected_id)
		fatal("ID mismatch (%u != %u)", id, expected_id);
	if (type == SSH2_FXP_STATUS) {
		u_int status;

		if ((r = sshbuf_get_u32(msg, &status)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		if (quiet)
			debug("Couldn't statvfs: %s", fx2txt(status));
		else
			error("Couldn't statvfs: %s", fx2txt(status));
		sshbuf_free(msg);
		return -1;
	} else if (type != SSH2_FXP_EXTENDED_REPLY) {
		fatal("Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u",
		    SSH2_FXP_EXTENDED_REPLY, type);
	}

	memset(st, 0, sizeof(*st));
	if ((r = sshbuf_get_u64(msg, &st->f_bsize)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_frsize)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_blocks)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_bfree)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_bavail)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_files)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_ffree)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_favail)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_fsid)) != 0 ||
	    (r = sshbuf_get_u64(msg, &flag)) != 0 ||
	    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	st->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;
	st->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;

	sshbuf_free(msg);

	return 0;
}

struct sftp_conn *
do_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,
    u_int64_t limit_kbps)
{
	u_char type;
	struct sshbuf *msg;
	struct sftp_conn *ret;
	int r;

	ret = xcalloc(1, sizeof(*ret));
	ret->msg_id = 1;
	ret->fd_in = fd_in;
	ret->fd_out = fd_out;
	ret->transfer_buflen = transfer_buflen;
	ret->num_requests = num_requests;
	ret->exts = 0;
	ret->limit_kbps = 0;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_INIT)) != 0 ||
	    (r = sshbuf_put_u32(msg, SSH2_FILEXFER_VERSION)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(ret, msg);

	sshbuf_reset(msg);

	get_msg(ret, msg);

	/* Expecting a VERSION reply */
	if ((r = sshbuf_get_u8(msg, &type)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (type != SSH2_FXP_VERSION) {
		error("Invalid packet back from SSH2_FXP_INIT (type %u)",
		    type);
		sshbuf_free(msg);
		free(ret);
		return(NULL);
	}
	if ((r = sshbuf_get_u32(msg, &ret->version)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug2("Remote version: %u", ret->version);

	/* Check for extensions */
	while (sshbuf_len(msg) > 0) {
		char *name;
		u_char *value;
		size_t vlen;
		int known = 0;

		if ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||
		    (r = sshbuf_get_string(msg, &value, &vlen)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		if (strcmp(name, "posix-rename@@openssh.com") == 0 &&
		    strcmp((char *)value, "1") == 0) {
			ret->exts |= SFTP_EXT_POSIX_RENAME;
			known = 1;
		} else if (strcmp(name, "statvfs@@openssh.com") == 0 &&
		    strcmp((char *)value, "2") == 0) {
			ret->exts |= SFTP_EXT_STATVFS;
			known = 1;
		} else if (strcmp(name, "fstatvfs@@openssh.com") == 0 &&
		    strcmp((char *)value, "2") == 0) {
			ret->exts |= SFTP_EXT_FSTATVFS;
			known = 1;
		} else if (strcmp(name, "hardlink@@openssh.com") == 0 &&
		    strcmp((char *)value, "1") == 0) {
			ret->exts |= SFTP_EXT_HARDLINK;
			known = 1;
		} else if (strcmp(name, "fsync@@openssh.com") == 0 &&
		    strcmp((char *)value, "1") == 0) {
			ret->exts |= SFTP_EXT_FSYNC;
			known = 1;
		}
		if (known) {
			debug2("Server supports extension \"%s\" revision %s",
			    name, value);
		} else {
			debug2("Unrecognised server extension \"%s\"", name);
		}
		free(name);
		free(value);
	}

	sshbuf_free(msg);

	/* Some filexfer v.0 servers don't support large packets */
	if (ret->version == 0)
		ret->transfer_buflen = MINIMUM(ret->transfer_buflen, 20480);

	ret->limit_kbps = limit_kbps;
	if (ret->limit_kbps > 0) {
		bandwidth_limit_init(&ret->bwlimit_in, ret->limit_kbps,
		    ret->transfer_buflen);
		bandwidth_limit_init(&ret->bwlimit_out, ret->limit_kbps,
		    ret->transfer_buflen);
	}

	return ret;
}

u_int
sftp_proto_version(struct sftp_conn *conn)
{
	return conn->version;
}

int
do_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)
{
	u_int id, status;
	struct sshbuf *msg;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	id = conn->msg_id++;
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message SSH2_FXP_CLOSE I:%u", id);

	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't close file: %s", fx2txt(status));

	sshbuf_free(msg);

	return status == SSH2_FX_OK ? 0 : -1;
}


static int
do_lsreaddir(struct sftp_conn *conn, const char *path, int print_flag,
    SFTP_DIRENT ***dir)
{
	struct sshbuf *msg;
	u_int count, id, i, expected_id, ents = 0;
	size_t handle_len;
	u_char type, *handle;
	int status = SSH2_FX_FAILURE;
	int r;

	if (dir)
		*dir = NULL;

	id = conn->msg_id++;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, path)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);

	handle = get_handle(conn, id, &handle_len,
	    "remote readdir(\"%s\")", path);
	if (handle == NULL) {
		sshbuf_free(msg);
		return -1;
	}

	if (dir) {
		ents = 0;
		*dir = xcalloc(1, sizeof(**dir));
		(*dir)[0] = NULL;
	}

	for (; !interrupted;) {
		id = expected_id = conn->msg_id++;

		debug3("Sending SSH2_FXP_READDIR I:%u", id);

		sshbuf_reset(msg);
		if ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||
		    (r = sshbuf_put_u32(msg, id)) != 0 ||
		    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		send_msg(conn, msg);

		sshbuf_reset(msg);

		get_msg(conn, msg);

		if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
		    (r = sshbuf_get_u32(msg, &id)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));

		debug3("Received reply T:%u I:%u", type, id);

		if (id != expected_id)
			fatal("ID mismatch (%u != %u)", id, expected_id);

		if (type == SSH2_FXP_STATUS) {
			u_int rstatus;

			if ((r = sshbuf_get_u32(msg, &rstatus)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			debug3("Received SSH2_FXP_STATUS %d", rstatus);
			if (rstatus == SSH2_FX_EOF)
				break;
			error("Couldn't read directory: %s", fx2txt(rstatus));
			goto out;
		} else if (type != SSH2_FXP_NAME)
			fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
			    SSH2_FXP_NAME, type);

		if ((r = sshbuf_get_u32(msg, &count)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		if (count > SSHBUF_SIZE_MAX)
			fatal("%s: nonsensical number of entries", __func__);
		if (count == 0)
			break;
		debug3("Received %d SSH2_FXP_NAME responses", count);
		for (i = 0; i < count; i++) {
			char *filename, *longname;
			Attrib a;

			if ((r = sshbuf_get_cstring(msg, &filename,
			    NULL)) != 0 ||
			    (r = sshbuf_get_cstring(msg, &longname,
			    NULL)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			if ((r = decode_attrib(msg, &a)) != 0) {
				error("%s: couldn't decode attrib: %s",
				    __func__, ssh_err(r));
				free(filename);
				free(longname);
				sshbuf_free(msg);
				return -1;
			}

			if (print_flag)
				mprintf("%s\n", longname);

			/*
			 * Directory entries should never contain '/'
			 * These can be used to attack recursive ops
			 * (e.g. send '../../../../etc/passwd')
			 */
			if (strchr(filename, '/') != NULL) {
				error("Server sent suspect path \"%s\" "
				    "during readdir of \"%s\"", filename, path);
			} else if (dir) {
				*dir = xreallocarray(*dir, ents + 2, sizeof(**dir));
				(*dir)[ents] = xcalloc(1, sizeof(***dir));
				(*dir)[ents]->filename = xstrdup(filename);
				(*dir)[ents]->longname = xstrdup(longname);
				memcpy(&(*dir)[ents]->a, &a, sizeof(a));
				(*dir)[++ents] = NULL;
			}
			free(filename);
			free(longname);
		}
	}
	status = 0;

 out:
	sshbuf_free(msg);
	do_close(conn, handle, handle_len);
	free(handle);

	if (status != 0 && dir != NULL) {
		/* Don't return results on error */
		free_sftp_dirents(*dir);
		*dir = NULL;
	} else if (interrupted && dir != NULL && *dir != NULL) {
		/* Don't return partial matches on interrupt */
		free_sftp_dirents(*dir);
		*dir = xcalloc(1, sizeof(**dir));
		**dir = NULL;
	}

	return status;
}

int
do_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)
{
	return(do_lsreaddir(conn, path, 0, dir));
}

void free_sftp_dirents(SFTP_DIRENT **s)
{
	int i;

	if (s == NULL)
		return;
	for (i = 0; s[i]; i++) {
		free(s[i]->filename);
		free(s[i]->longname);
		free(s[i]);
	}
	free(s);
}

int
do_rm(struct sftp_conn *conn, const char *path)
{
	u_int status, id;

	debug2("Sending SSH2_FXP_REMOVE \"%s\"", path);

	id = conn->msg_id++;
	send_string_request(conn, id, SSH2_FXP_REMOVE, path, strlen(path));
	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't delete file: %s", fx2txt(status));
	return status == SSH2_FX_OK ? 0 : -1;
}

int
do_mkdir(struct sftp_conn *conn, const char *path, Attrib *a, int print_flag)
{
	u_int status, id;

	id = conn->msg_id++;
	send_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path,
	    strlen(path), a);

	status = get_status(conn, id);
	if (status != SSH2_FX_OK && print_flag)
		error("Couldn't create directory: %s", fx2txt(status));

	return status == SSH2_FX_OK ? 0 : -1;
}

int
do_rmdir(struct sftp_conn *conn, const char *path)
{
	u_int status, id;

	id = conn->msg_id++;
	send_string_request(conn, id, SSH2_FXP_RMDIR, path,
	    strlen(path));

	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't remove directory: %s", fx2txt(status));

	return status == SSH2_FX_OK ? 0 : -1;
}

Attrib *
do_stat(struct sftp_conn *conn, const char *path, int quiet)
{
	u_int id;

	id = conn->msg_id++;

	send_string_request(conn, id,
	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,
	    path, strlen(path));

	return(get_decode_stat(conn, id, quiet));
}

Attrib *
do_lstat(struct sftp_conn *conn, const char *path, int quiet)
{
	u_int id;

	if (conn->version == 0) {
		if (quiet)
			debug("Server version does not support lstat operation");
		else
			logit("Server version does not support lstat operation");
		return(do_stat(conn, path, quiet));
	}

	id = conn->msg_id++;
	send_string_request(conn, id, SSH2_FXP_LSTAT, path,
	    strlen(path));

	return(get_decode_stat(conn, id, quiet));
}

#ifdef notyet
Attrib *
do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,
    int quiet)
{
	u_int id;

	id = conn->msg_id++;
	send_string_request(conn, id, SSH2_FXP_FSTAT, handle,
	    handle_len);

	return(get_decode_stat(conn, id, quiet));
}
#endif

int
do_setstat(struct sftp_conn *conn, const char *path, Attrib *a)
{
	u_int status, id;

	id = conn->msg_id++;
	send_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path,
	    strlen(path), a);

	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't setstat on \"%s\": %s", path,
		    fx2txt(status));

	return status == SSH2_FX_OK ? 0 : -1;
}

int
do_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,
    Attrib *a)
{
	u_int status, id;

	id = conn->msg_id++;
	send_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle,
	    handle_len, a);

	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't fsetstat: %s", fx2txt(status));

	return status == SSH2_FX_OK ? 0 : -1;
}

char *
do_realpath(struct sftp_conn *conn, const char *path)
{
	struct sshbuf *msg;
	u_int expected_id, count, id;
	char *filename, *longname;
	Attrib a;
	u_char type;
	int r;

	expected_id = id = conn->msg_id++;
	send_string_request(conn, id, SSH2_FXP_REALPATH, path,
	    strlen(path));

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	get_msg(conn, msg);
	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
	    (r = sshbuf_get_u32(msg, &id)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if (id != expected_id)
		fatal("ID mismatch (%u != %u)", id, expected_id);

	if (type == SSH2_FXP_STATUS) {
		u_int status;

		if ((r = sshbuf_get_u32(msg, &status)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		error("Couldn't canonicalize: %s", fx2txt(status));
		sshbuf_free(msg);
		return NULL;
	} else if (type != SSH2_FXP_NAME)
		fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
		    SSH2_FXP_NAME, type);

	if ((r = sshbuf_get_u32(msg, &count)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (count != 1)
		fatal("Got multiple names (%d) from SSH_FXP_REALPATH", count);

	if ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||
	    (r = decode_attrib(msg, &a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("SSH_FXP_REALPATH %s -> %s size %lu", path, filename,
	    (unsigned long)a.size);

	free(longname);

	sshbuf_free(msg);

	return(filename);
}

int
do_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath,
    int force_legacy)
{
	struct sshbuf *msg;
	u_int status, id;
	int r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	/* Send rename request */
	id = conn->msg_id++;
	if (use_ext) {
		if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
		    (r = sshbuf_put_u32(msg, id)) != 0 ||
		    (r = sshbuf_put_cstring(msg,
		    "posix-rename@@openssh.com")) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
	} else {
		if ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||
		    (r = sshbuf_put_u32(msg, id)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
	}
	if ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message %s \"%s\" -> \"%s\"",
	    use_ext ? "posix-rename@@openssh.com" :
	    "SSH2_FXP_RENAME", oldpath, newpath);
	sshbuf_free(msg);

	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));

	return status == SSH2_FX_OK ? 0 : -1;
}

int
do_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)
{
	struct sshbuf *msg;
	u_int status, id;
	int r;

	if ((conn->exts & SFTP_EXT_HARDLINK) == 0) {
		error("Server does not support hardlink@@openssh.com extension");
		return -1;
	}

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	/* Send link request */
	id = conn->msg_id++;
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, "hardlink@@openssh.com")) != 0 ||
	    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message hardlink@@openssh.com \"%s\" -> \"%s\"",
	       oldpath, newpath);
	sshbuf_free(msg);

	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't link file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));

	return status == SSH2_FX_OK ? 0 : -1;
}

int
do_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)
{
	struct sshbuf *msg;
	u_int status, id;
	int r;

	if (conn->version < 3) {
		error("This server does not support the symlink operation");
		return(SSH2_FX_OP_UNSUPPORTED);
	}

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	/* Send symlink request */
	id = conn->msg_id++;
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_SYMLINK)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||
	    (r = sshbuf_put_cstring(msg, newpath)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message SSH2_FXP_SYMLINK \"%s\" -> \"%s\"", oldpath,
	    newpath);
	sshbuf_free(msg);

	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't symlink file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));

	return status == SSH2_FX_OK ? 0 : -1;
}

int
do_fsync(struct sftp_conn *conn, u_char *handle, u_int handle_len)
{
	struct sshbuf *msg;
	u_int status, id;
	int r;

	/* Silently return if the extension is not supported */
	if ((conn->exts & SFTP_EXT_FSYNC) == 0)
		return -1;

	/* Send fsync request */
	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	id = conn->msg_id++;
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, "fsync@@openssh.com")) != 0 ||
	    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message fsync@@openssh.com I:%u", id);
	sshbuf_free(msg);

	status = get_status(conn, id);
	if (status != SSH2_FX_OK)
		error("Couldn't sync file: %s", fx2txt(status));

	return status;
}

#ifdef notyet
char *
do_readlink(struct sftp_conn *conn, const char *path)
{
	struct sshbuf *msg;
	u_int expected_id, count, id;
	char *filename, *longname;
	Attrib a;
	u_char type;
	int r;

	expected_id = id = conn->msg_id++;
	send_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	get_msg(conn, msg);
	if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
	    (r = sshbuf_get_u32(msg, &id)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if (id != expected_id)
		fatal("ID mismatch (%u != %u)", id, expected_id);

	if (type == SSH2_FXP_STATUS) {
		u_int status;

		if ((r = sshbuf_get_u32(msg, &status)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		error("Couldn't readlink: %s", fx2txt(status));
		sshbuf_free(msg);
		return(NULL);
	} else if (type != SSH2_FXP_NAME)
		fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
		    SSH2_FXP_NAME, type);

	if ((r = sshbuf_get_u32(msg, &count)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (count != 1)
		fatal("Got multiple names (%d) from SSH_FXP_READLINK", count);

	if ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||
	    (r = decode_attrib(msg, &a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("SSH_FXP_READLINK %s -> %s", path, filename);

	free(longname);

	sshbuf_free(msg);

	return filename;
}
#endif

int
do_statvfs(struct sftp_conn *conn, const char *path, struct sftp_statvfs *st,
    int quiet)
{
	struct sshbuf *msg;
	u_int id;
	int r;

	if ((conn->exts & SFTP_EXT_STATVFS) == 0) {
		error("Server does not support statvfs@@openssh.com extension");
		return -1;
	}

	id = conn->msg_id++;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	sshbuf_reset(msg);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, "statvfs@@openssh.com")) != 0 ||
	    (r = sshbuf_put_cstring(msg, path)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	sshbuf_free(msg);

	return get_decode_statvfs(conn, st, id, quiet);
}

#ifdef notyet
int
do_fstatvfs(struct sftp_conn *conn, const u_char *handle, u_int handle_len,
    struct sftp_statvfs *st, int quiet)
{
	struct sshbuf *msg;
	u_int id;

	if ((conn->exts & SFTP_EXT_FSTATVFS) == 0) {
		error("Server does not support fstatvfs@@openssh.com extension");
		return -1;
	}

	id = conn->msg_id++;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	sshbuf_reset(msg);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, "fstatvfs@@openssh.com")) != 0 ||
	    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	sshbuf_free(msg);

	return get_decode_statvfs(conn, st, id, quiet);
}
#endif

static void
send_read_request(struct sftp_conn *conn, u_int id, u_int64_t offset,
    u_int len, const u_char *handle, u_int handle_len)
{
	struct sshbuf *msg;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	sshbuf_reset(msg);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_READ)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||
	    (r = sshbuf_put_u64(msg, offset)) != 0 ||
	    (r = sshbuf_put_u32(msg, len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	sshbuf_free(msg);
}

int
do_download(struct sftp_conn *conn, const char *remote_path,
    const char *local_path, Attrib *a, int preserve_flag, int resume_flag,
    int fsync_flag)
{
	Attrib junk;
	struct sshbuf *msg;
	u_char *handle;
	int local_fd = -1, write_error;
	int read_error, write_errno, reordered = 0, r;
	u_int64_t offset = 0, size, highwater;
	u_int mode, id, buflen, num_req, max_req, status = SSH2_FX_OK;
	off_t progress_counter;
	size_t handle_len;
	struct stat st;
	struct request {
		u_int id;
		size_t len;
		u_int64_t offset;
		TAILQ_ENTRY(request) tq;
	};
	TAILQ_HEAD(reqhead, request) requests;
	struct request *req;
	u_char type;

	TAILQ_INIT(&requests);

	if (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)
		return -1;

	/* Do not preserve set[ug]id here, as we do not preserve ownership */
	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)
		mode = a->perm & 0777;
	else
		mode = 0666;

	if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
	    (!S_ISREG(a->perm))) {
		error("Cannot download non-regular file: %s", remote_path);
		return(-1);
	}

	if (a->flags & SSH2_FILEXFER_ATTR_SIZE)
		size = a->size;
	else
		size = 0;

	buflen = conn->transfer_buflen;
	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	attrib_clear(&junk); /* Send empty attributes */

	/* Send open request */
	id = conn->msg_id++;
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||
	    (r = sshbuf_put_u32(msg, SSH2_FXF_READ)) != 0 ||
	    (r = encode_attrib(msg, &junk)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);

	handle = get_handle(conn, id, &handle_len,
	    "remote open(\"%s\")", remote_path);
	if (handle == NULL) {
		sshbuf_free(msg);
		return(-1);
	}

	local_fd = open(local_path,
	    O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);
	if (local_fd == -1) {
		error("Couldn't open local file \"%s\" for writing: %s",
		    local_path, strerror(errno));
		goto fail;
	}
	offset = highwater = 0;
	if (resume_flag) {
		if (fstat(local_fd, &st) == -1) {
			error("Unable to stat local file \"%s\": %s",
			    local_path, strerror(errno));
			goto fail;
		}
		if (st.st_size < 0) {
			error("\"%s\" has negative size", local_path);
			goto fail;
		}
		if ((u_int64_t)st.st_size > size) {
			error("Unable to resume download of \"%s\": "
			    "local file is larger than remote", local_path);
 fail:
			do_close(conn, handle, handle_len);
			sshbuf_free(msg);
			free(handle);
			if (local_fd != -1)
				close(local_fd);
			return -1;
		}
		offset = highwater = st.st_size;
	}

	/* Read from remote and write to local */
	write_error = read_error = write_errno = num_req = 0;
	max_req = 1;
	progress_counter = offset;

	if (showprogress && size != 0)
		start_progress_meter(remote_path, size, &progress_counter);

	while (num_req > 0 || max_req > 0) {
		u_char *data;
		size_t len;

		/*
		 * Simulate EOF on interrupt: stop sending new requests and
		 * allow outstanding requests to drain gracefully
		 */
		if (interrupted) {
			if (num_req == 0) /* If we haven't started yet... */
				break;
			max_req = 0;
		}

		/* Send some more requests */
		while (num_req < max_req) {
			debug3("Request range %llu -> %llu (%d/%d)",
			    (unsigned long long)offset,
			    (unsigned long long)offset + buflen - 1,
			    num_req, max_req);
			req = xcalloc(1, sizeof(*req));
			req->id = conn->msg_id++;
			req->len = buflen;
			req->offset = offset;
			offset += buflen;
			num_req++;
			TAILQ_INSERT_TAIL(&requests, req, tq);
			send_read_request(conn, req->id, req->offset,
			    req->len, handle, handle_len);
		}

		sshbuf_reset(msg);
		get_msg(conn, msg);
		if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
		    (r = sshbuf_get_u32(msg, &id)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		debug3("Received reply T:%u I:%u R:%d", type, id, max_req);

		/* Find the request in our queue */
		for (req = TAILQ_FIRST(&requests);
		    req != NULL && req->id != id;
		    req = TAILQ_NEXT(req, tq))
			;
		if (req == NULL)
			fatal("Unexpected reply %u", id);

		switch (type) {
		case SSH2_FXP_STATUS:
			if ((r = sshbuf_get_u32(msg, &status)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			if (status != SSH2_FX_EOF)
				read_error = 1;
			max_req = 0;
			TAILQ_REMOVE(&requests, req, tq);
			free(req);
			num_req--;
			break;
		case SSH2_FXP_DATA:
			if ((r = sshbuf_get_string(msg, &data, &len)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			debug3("Received data %llu -> %llu",
			    (unsigned long long)req->offset,
			    (unsigned long long)req->offset + len - 1);
			if (len > req->len)
				fatal("Received more data than asked for "
				    "%zu > %zu", len, req->len);
			if ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||
			    atomicio(vwrite, local_fd, data, len) != len) &&
			    !write_error) {
				write_errno = errno;
				write_error = 1;
				max_req = 0;
			}
			else if (!reordered && req->offset <= highwater)
				highwater = req->offset + len;
			else if (!reordered && req->offset > highwater)
				reordered = 1;
			progress_counter += len;
			free(data);

			if (len == req->len) {
				TAILQ_REMOVE(&requests, req, tq);
				free(req);
				num_req--;
			} else {
				/* Resend the request for the missing data */
				debug3("Short data block, re-requesting "
				    "%llu -> %llu (%2d)",
				    (unsigned long long)req->offset + len,
				    (unsigned long long)req->offset +
				    req->len - 1, num_req);
				req->id = conn->msg_id++;
				req->len -= len;
				req->offset += len;
				send_read_request(conn, req->id,
				    req->offset, req->len, handle, handle_len);
				/* Reduce the request size */
				if (len < buflen)
					buflen = MAXIMUM(MIN_READ_SIZE, len);
			}
			if (max_req > 0) { /* max_req = 0 iff EOF received */
				if (size > 0 && offset > size) {
					/* Only one request at a time
					 * after the expected EOF */
					debug3("Finish at %llu (%2d)",
					    (unsigned long long)offset,
					    num_req);
					max_req = 1;
				} else if (max_req <= conn->num_requests) {
					++max_req;
				}
			}
			break;
		default:
			fatal("Expected SSH2_FXP_DATA(%u) packet, got %u",
			    SSH2_FXP_DATA, type);
		}
	}

	if (showprogress && size)
		stop_progress_meter();

	/* Sanity check */
	if (TAILQ_FIRST(&requests) != NULL)
		fatal("Transfer complete, but requests still in queue");
	/* Truncate at highest contiguous point to avoid holes on interrupt */
	if (read_error || write_error || interrupted) {
		if (reordered && resume_flag) {
			error("Unable to resume download of \"%s\": "
			    "server reordered requests", local_path);
		}
		debug("truncating at %llu", (unsigned long long)highwater);
		if (ftruncate(local_fd, highwater) == -1)
			error("ftruncate \"%s\": %s", local_path,
			    strerror(errno));
	}
	if (read_error) {
		error("Couldn't read from remote file \"%s\" : %s",
		    remote_path, fx2txt(status));
		status = -1;
		do_close(conn, handle, handle_len);
	} else if (write_error) {
		error("Couldn't write to \"%s\": %s", local_path,
		    strerror(write_errno));
		status = SSH2_FX_FAILURE;
		do_close(conn, handle, handle_len);
	} else {
		if (do_close(conn, handle, handle_len) != 0 || interrupted)
			status = SSH2_FX_FAILURE;
		else
			status = SSH2_FX_OK;
		/* Override umask and utimes if asked */
		if (preserve_flag && fchmod(local_fd, mode) == -1)
			error("Couldn't set mode on \"%s\": %s", local_path,
			    strerror(errno));
		if (preserve_flag &&
		    (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {
			struct timeval tv[2];
			tv[0].tv_sec = a->atime;
			tv[1].tv_sec = a->mtime;
			tv[0].tv_usec = tv[1].tv_usec = 0;
			if (utimes(local_path, tv) == -1)
				error("Can't set times on \"%s\": %s",
				    local_path, strerror(errno));
		}
		if (fsync_flag) {
			debug("syncing \"%s\"", local_path);
			if (fsync(local_fd) == -1)
				error("Couldn't sync file \"%s\": %s",
				    local_path, strerror(errno));
		}
	}
	close(local_fd);
	sshbuf_free(msg);
	free(handle);

	return(status);
}

static int
download_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,
    int depth, Attrib *dirattrib, int preserve_flag, int print_flag,
    int resume_flag, int fsync_flag)
{
	int i, ret = 0;
	SFTP_DIRENT **dir_entries;
	char *filename, *new_src, *new_dst;
	mode_t mode = 0777;

	if (depth >= MAX_DIR_DEPTH) {
		error("Maximum directory depth exceeded: %d levels", depth);
		return -1;
	}

	if (dirattrib == NULL &&
	    (dirattrib = do_stat(conn, src, 1)) == NULL) {
		error("Unable to stat remote directory \"%s\"", src);
		return -1;
	}
	if (!S_ISDIR(dirattrib->perm)) {
		error("\"%s\" is not a directory", src);
		return -1;
	}
	if (print_flag)
		mprintf("Retrieving %s\n", src);

	if (dirattrib->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)
		mode = dirattrib->perm & 01777;
	else {
		debug("Server did not send permissions for "
		    "directory \"%s\"", dst);
	}

	if (mkdir(dst, mode) == -1 && errno != EEXIST) {
		error("mkdir %s: %s", dst, strerror(errno));
		return -1;
	}

	if (do_readdir(conn, src, &dir_entries) == -1) {
		error("%s: Failed to get directory contents", src);
		return -1;
	}

	for (i = 0; dir_entries[i] != NULL && !interrupted; i++) {
		filename = dir_entries[i]->filename;

		new_dst = path_append(dst, filename);
		new_src = path_append(src, filename);

		if (S_ISDIR(dir_entries[i]->a.perm)) {
			if (strcmp(filename, ".") == 0 ||
			    strcmp(filename, "..") == 0)
				continue;
			if (download_dir_internal(conn, new_src, new_dst,
			    depth + 1, &(dir_entries[i]->a), preserve_flag,
			    print_flag, resume_flag, fsync_flag) == -1)
				ret = -1;
		} else if (S_ISREG(dir_entries[i]->a.perm) ) {
			if (do_download(conn, new_src, new_dst,
			    &(dir_entries[i]->a), preserve_flag,
			    resume_flag, fsync_flag) == -1) {
				error("Download of file %s to %s failed",
				    new_src, new_dst);
				ret = -1;
			}
		} else
			logit("%s: not a regular file\n", new_src);

		free(new_dst);
		free(new_src);
	}

	if (preserve_flag) {
		if (dirattrib->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
			struct timeval tv[2];
			tv[0].tv_sec = dirattrib->atime;
			tv[1].tv_sec = dirattrib->mtime;
			tv[0].tv_usec = tv[1].tv_usec = 0;
			if (utimes(dst, tv) == -1)
				error("Can't set times on \"%s\": %s",
				    dst, strerror(errno));
		} else
			debug("Server did not send times for directory "
			    "\"%s\"", dst);
	}

	free_sftp_dirents(dir_entries);

	return ret;
}

int
download_dir(struct sftp_conn *conn, const char *src, const char *dst,
    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag,
    int fsync_flag)
{
	char *src_canon;
	int ret;

	if ((src_canon = do_realpath(conn, src)) == NULL) {
		error("Unable to canonicalize path \"%s\"", src);
		return -1;
	}

	ret = download_dir_internal(conn, src_canon, dst, 0,
	    dirattrib, preserve_flag, print_flag, resume_flag, fsync_flag);
	free(src_canon);
	return ret;
}

int
do_upload(struct sftp_conn *conn, const char *local_path,
    const char *remote_path, int preserve_flag, int resume, int fsync_flag)
{
	int r, local_fd;
	u_int status = SSH2_FX_OK;
	u_int id;
	u_char type;
	off_t offset, progress_counter;
	u_char *handle, *data;
	struct sshbuf *msg;
	struct stat sb;
	Attrib a, *c = NULL;
	u_int32_t startid;
	u_int32_t ackid;
	struct outstanding_ack {
		u_int id;
		u_int len;
		off_t offset;
		TAILQ_ENTRY(outstanding_ack) tq;
	};
	TAILQ_HEAD(ackhead, outstanding_ack) acks;
	struct outstanding_ack *ack = NULL;
	size_t handle_len;

	TAILQ_INIT(&acks);

	if ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {
		error("Couldn't open local file \"%s\" for reading: %s",
		    local_path, strerror(errno));
		return(-1);
	}
	if (fstat(local_fd, &sb) == -1) {
		error("Couldn't fstat local file \"%s\": %s",
		    local_path, strerror(errno));
		close(local_fd);
		return(-1);
	}
	if (!S_ISREG(sb.st_mode)) {
		error("%s is not a regular file", local_path);
		close(local_fd);
		return(-1);
	}
	stat_to_attrib(&sb, &a);

	a.flags &= ~SSH2_FILEXFER_ATTR_SIZE;
	a.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;
	a.perm &= 0777;
	if (!preserve_flag)
		a.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;

	if (resume) {
		/* Get remote file size if it exists */
		if ((c = do_stat(conn, remote_path, 0)) == NULL) {
			close(local_fd);
			return -1;
		}

		if ((off_t)c->size >= sb.st_size) {
			error("destination file bigger or same size as "
			      "source file");
			close(local_fd);
			return -1;
		}

		if (lseek(local_fd, (off_t)c->size, SEEK_SET) == -1) {
			close(local_fd);
			return -1;
		}
	}

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	/* Send open request */
	id = conn->msg_id++;
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||
	    (r = sshbuf_put_u32(msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|
	    (resume ? SSH2_FXF_APPEND : SSH2_FXF_TRUNC))) != 0 ||
	    (r = encode_attrib(msg, &a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(conn, msg);
	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);

	sshbuf_reset(msg);

	handle = get_handle(conn, id, &handle_len,
	    "remote open(\"%s\")", remote_path);
	if (handle == NULL) {
		close(local_fd);
		sshbuf_free(msg);
		return -1;
	}

	startid = ackid = id + 1;
	data = xmalloc(conn->transfer_buflen);

	/* Read from local and write to remote */
	offset = progress_counter = (resume ? c->size : 0);
	if (showprogress)
		start_progress_meter(local_path, sb.st_size,
		    &progress_counter);

	for (;;) {
		int len;

		/*
		 * Can't use atomicio here because it returns 0 on EOF,
		 * thus losing the last block of the file.
		 * Simulate an EOF on interrupt, allowing ACKs from the
		 * server to drain.
		 */
		if (interrupted || status != SSH2_FX_OK)
			len = 0;
		else do
			len = read(local_fd, data, conn->transfer_buflen);
		while ((len == -1) && (errno == EINTR || errno == EAGAIN));

		if (len == -1)
			fatal("Couldn't read from \"%s\": %s", local_path,
			    strerror(errno));

		if (len != 0) {
			ack = xcalloc(1, sizeof(*ack));
			ack->id = ++id;
			ack->offset = offset;
			ack->len = len;
			TAILQ_INSERT_TAIL(&acks, ack, tq);

			sshbuf_reset(msg);
			if ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||
			    (r = sshbuf_put_u32(msg, ack->id)) != 0 ||
			    (r = sshbuf_put_string(msg, handle,
			    handle_len)) != 0 ||
			    (r = sshbuf_put_u64(msg, offset)) != 0 ||
			    (r = sshbuf_put_string(msg, data, len)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			send_msg(conn, msg);
			debug3("Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u",
			    id, (unsigned long long)offset, len);
		} else if (TAILQ_FIRST(&acks) == NULL)
			break;

		if (ack == NULL)
			fatal("Unexpected ACK %u", id);

		if (id == startid || len == 0 ||
		    id - ackid >= conn->num_requests) {
			u_int rid;

			sshbuf_reset(msg);
			get_msg(conn, msg);
			if ((r = sshbuf_get_u8(msg, &type)) != 0 ||
			    (r = sshbuf_get_u32(msg, &rid)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));

			if (type != SSH2_FXP_STATUS)
				fatal("Expected SSH2_FXP_STATUS(%d) packet, "
				    "got %d", SSH2_FXP_STATUS, type);

			if ((r = sshbuf_get_u32(msg, &status)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			debug3("SSH2_FXP_STATUS %u", status);

			/* Find the request in our queue */
			for (ack = TAILQ_FIRST(&acks);
			    ack != NULL && ack->id != rid;
			    ack = TAILQ_NEXT(ack, tq))
				;
			if (ack == NULL)
				fatal("Can't find request for ID %u", rid);
			TAILQ_REMOVE(&acks, ack, tq);
			debug3("In write loop, ack for %u %u bytes at %lld",
			    ack->id, ack->len, (long long)ack->offset);
			++ackid;
			progress_counter += ack->len;
			free(ack);
		}
		offset += len;
		if (offset < 0)
			fatal("%s: offset < 0", __func__);
	}
	sshbuf_free(msg);

	if (showprogress)
		stop_progress_meter();
	free(data);

	if (status != SSH2_FX_OK) {
		error("Couldn't write to remote file \"%s\": %s",
		    remote_path, fx2txt(status));
		status = SSH2_FX_FAILURE;
	}

	if (close(local_fd) == -1) {
		error("Couldn't close local file \"%s\": %s", local_path,
		    strerror(errno));
		status = SSH2_FX_FAILURE;
	}

	/* Override umask and utimes if asked */
	if (preserve_flag)
		do_fsetstat(conn, handle, handle_len, &a);

	if (fsync_flag)
		(void)do_fsync(conn, handle, handle_len);

	if (do_close(conn, handle, handle_len) != 0)
		status = SSH2_FX_FAILURE;

	free(handle);

	return status == SSH2_FX_OK ? 0 : -1;
}

static int
upload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,
    int depth, int preserve_flag, int print_flag, int resume, int fsync_flag)
{
	int ret = 0;
	DIR *dirp;
	struct dirent *dp;
	char *filename, *new_src, *new_dst;
	struct stat sb;
	Attrib a, *dirattrib;

	if (depth >= MAX_DIR_DEPTH) {
		error("Maximum directory depth exceeded: %d levels", depth);
		return -1;
	}

	if (stat(src, &sb) == -1) {
		error("Couldn't stat directory \"%s\": %s",
		    src, strerror(errno));
		return -1;
	}
	if (!S_ISDIR(sb.st_mode)) {
		error("\"%s\" is not a directory", src);
		return -1;
	}
	if (print_flag)
		mprintf("Entering %s\n", src);

	attrib_clear(&a);
	stat_to_attrib(&sb, &a);
	a.flags &= ~SSH2_FILEXFER_ATTR_SIZE;
	a.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;
	a.perm &= 01777;
	if (!preserve_flag)
		a.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;

	/*
	 * sftp lacks a portable status value to match errno EEXIST,
	 * so if we get a failure back then we must check whether
	 * the path already existed and is a directory.
	 */
	if (do_mkdir(conn, dst, &a, 0) != 0) {
		if ((dirattrib = do_stat(conn, dst, 0)) == NULL)
			return -1;
		if (!S_ISDIR(dirattrib->perm)) {
			error("\"%s\" exists but is not a directory", dst);
			return -1;
		}
	}

	if ((dirp = opendir(src)) == NULL) {
		error("Failed to open dir \"%s\": %s", src, strerror(errno));
		return -1;
	}

	while (((dp = readdir(dirp)) != NULL) && !interrupted) {
		if (dp->d_ino == 0)
			continue;
		filename = dp->d_name;
		new_dst = path_append(dst, filename);
		new_src = path_append(src, filename);

		if (lstat(new_src, &sb) == -1) {
			logit("%s: lstat failed: %s", filename,
			    strerror(errno));
			ret = -1;
		} else if (S_ISDIR(sb.st_mode)) {
			if (strcmp(filename, ".") == 0 ||
			    strcmp(filename, "..") == 0)
				continue;

			if (upload_dir_internal(conn, new_src, new_dst,
			    depth + 1, preserve_flag, print_flag, resume,
			    fsync_flag) == -1)
				ret = -1;
		} else if (S_ISREG(sb.st_mode)) {
			if (do_upload(conn, new_src, new_dst,
			    preserve_flag, resume, fsync_flag) == -1) {
				error("Uploading of file %s to %s failed!",
				    new_src, new_dst);
				ret = -1;
			}
		} else
			logit("%s: not a regular file\n", filename);
		free(new_dst);
		free(new_src);
	}

	do_setstat(conn, dst, &a);

	(void) closedir(dirp);
	return ret;
}

int
upload_dir(struct sftp_conn *conn, const char *src, const char *dst,
    int preserve_flag, int print_flag, int resume, int fsync_flag)
{
	char *dst_canon;
	int ret;

	if ((dst_canon = do_realpath(conn, dst)) == NULL) {
		error("Unable to canonicalize path \"%s\"", dst);
		return -1;
	}

	ret = upload_dir_internal(conn, src, dst_canon, 0, preserve_flag,
	    print_flag, resume, fsync_flag);

	free(dst_canon);
	return ret;
}

char *
path_append(const char *p1, const char *p2)
{
	char *ret;
	size_t len = strlen(p1) + strlen(p2) + 2;

	ret = xmalloc(len);
	strlcpy(ret, p1, len);
	if (p1[0] != '\0' && p1[strlen(p1) - 1] != '/')
		strlcat(ret, "/", len);
	strlcat(ret, p2, len);

	return(ret);
}

@


1.126
log
@check number of entries in SSH2_FXP_NAME response; avoids
unreachable overflow later. Reported by Jann Horn
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.125 2016/09/12 01:22:38 deraadt Exp $ */
d129 1
a129 1
		if (errno == EPIPE)
@


1.125
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.124 2016/05/25 23:48:45 schwarze Exp $ */
d583 2
@


1.124
log
@To prevent screwing up terminal settings when printing to the
terminal, for ASCII and UTF-8, escape bytes not forming characters
and bytes forming non-printable characters with vis(3) VIS_OCTAL.
For other character sets, abort printing of the current string in
these cases.  In particular,
* let scp(1) respect the local user's LC_CTYPE locale(1);
* sanitize data received from the remote host;
* sanitize filenames, usernames, and similar data even locally;
* take character display widths into account for the progressmeter.

This is believed to be sufficient to keep the local terminal safe
on OpenBSD, but bad things can still happen on other systems with
state-dependent locales because many places in the code print
unencoded ASCII characters into the output stream.

Using feedback from djm@@ and martijn@@,
various aspects discussed with many others.

deraadt@@ says it should go in now, i probably already hesitated too long
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.123 2016/05/02 08:49:03 djm Exp $ */
a22 1
#include <sys/param.h>	/* MIN MAX */
d457 1
a457 1
		ret->transfer_buflen = MIN(ret->transfer_buflen, 20480);
d1346 1
a1346 1
					buflen = MAX(MIN_READ_SIZE, len);
@


1.123
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.122 2016/04/08 08:19:17 djm Exp $ */
d49 1
d607 1
a607 1
				printf("%s\n", longname);
d1453 1
a1453 1
		printf("Retrieving %s\n", src);
d1785 1
a1785 1
		printf("Entering %s\n", src);
@


1.122
log
@whitespace at EOL
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.121 2016/02/11 02:21:34 djm Exp $ */
d511 1
a511 2
	u_char type;
	char *handle;
@


1.121
log
@fix regression in openssh-6.8 sftp client: existing destination
directories would incorrectly terminate recursive uploads;
bz#2528
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.120 2015/05/28 04:50:53 djm Exp $ */
d1593 1
a1593 1
			close(local_fd);                
@


1.120
log
@add error message on ftruncate failure; bz#2176
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.119 2015/05/23 14:28:37 jsg Exp $ */
d1751 1
a1751 1
	if (do_close(conn, handle, handle_len) != SSH2_FX_OK)
a1763 1
	u_int status;
d1768 1
a1768 1
	Attrib a;
a1794 1
	status = do_mkdir(conn, dst, &a, 0);
d1796 3
a1798 3
	 * we lack a portable status for errno EEXIST,
	 * so if we get a SSH2_FX_FAILURE back we must check
	 * if it was created successfully.
d1800 2
a1801 2
	if (status != SSH2_FX_OK) {
		if (status != SSH2_FX_FAILURE)
d1803 2
a1804 1
		if (do_stat(conn, dst, 0) == NULL)
d1806 1
@


1.119
log
@fix a memory leak in an error path
ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.118 2015/04/24 01:36:00 deraadt Exp $ */
d1381 3
a1383 1
		ftruncate(local_fd, highwater);
@


1.118
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.117 2015/01/20 23:14:00 deraadt Exp $ */
d404 1
@


1.117
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.116 2015/01/14 13:54:13 djm Exp $ */
d617 1
a617 1
				*dir = xrealloc(*dir, ents + 2, sizeof(**dir));
@


1.116
log
@update sftp client and server to new buffer API.
pretty much just mechanical changes; with & ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.115 2014/04/21 14:36:16 logan Exp $ */
d23 1
a28 1
#include <sys/param.h>
@


1.115
log
@Implement sftp upload resume support.

OK from djm@@, with input from guenther@@, mlarkin@@ and
okan@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.114 2014/01/31 16:39:19 tedu Exp $ */
d43 2
a44 1
#include "buffer.h"
d80 2
a81 2
static char *
get_handle(struct sftp_conn *conn, u_int expected_id, u_int *len,
d95 1
a95 1
send_msg(struct sftp_conn *conn, Buffer *m)
d100 2
a101 2
	if (buffer_len(m) > SFTP_MAX_MSG_LENGTH)
		fatal("Outbound message too long %u", buffer_len(m));
d104 1
a104 1
	put_u32(mlen, buffer_len(m));
d107 2
a108 2
	iov[1].iov_base = buffer_ptr(m);
	iov[1].iov_len = buffer_len(m);
d112 1
a112 1
	    buffer_len(m) + sizeof(mlen))
d115 1
a115 1
	buffer_clear(m);
d119 1
a119 1
get_msg(struct sftp_conn *conn, Buffer *m)
d122 2
d125 3
a127 2
	buffer_append_space(m, 4);
	if (atomicio6(read, conn->fd_in, buffer_ptr(m), 4,
d135 2
a136 1
	msg_len = buffer_get_int(m);
d140 3
a142 2
	buffer_append_space(m, msg_len);
	if (atomicio6(read, conn->fd_in, buffer_ptr(m), msg_len,
d153 1
a153 1
send_string_request(struct sftp_conn *conn, u_int id, u_int code, char *s,
d156 2
a157 1
	Buffer msg;
d159 7
a165 5
	buffer_init(&msg);
	buffer_put_char(&msg, code);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, s, len);
	send_msg(conn, &msg);
d167 1
a167 1
	buffer_free(&msg);
d172 1
a172 1
    char *s, u_int len, Attrib *a)
d174 2
a175 1
	Buffer msg;
d177 8
a184 6
	buffer_init(&msg);
	buffer_put_char(&msg, code);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, s, len);
	encode_attrib(&msg, a);
	send_msg(conn, &msg);
d186 1
a186 1
	buffer_free(&msg);
d192 4
a195 2
	Buffer msg;
	u_int type, id, status;
d197 6
a202 4
	buffer_init(&msg);
	get_msg(conn, &msg);
	type = buffer_get_char(&msg);
	id = buffer_get_int(&msg);
d210 3
a212 2
	status = buffer_get_int(&msg);
	buffer_free(&msg);
d219 2
a220 2
static char *
get_handle(struct sftp_conn *conn, u_int expected_id, u_int *len,
d223 5
a227 3
	Buffer msg;
	u_int type, id;
	char *handle, errmsg[256];
d229 1
a229 1
	int status;
d236 6
a241 4
	buffer_init(&msg);
	get_msg(conn, &msg);
	type = buffer_get_char(&msg);
	id = buffer_get_int(&msg);
d247 2
a248 1
		status = buffer_get_int(&msg);
d251 1
a251 1
		buffer_free(&msg);
d257 3
a259 2
	handle = buffer_get_string(&msg, len);
	buffer_free(&msg);
d261 1
a261 1
	return(handle);
d267 13
a279 9
	Buffer msg;
	u_int type, id;
	Attrib *a;

	buffer_init(&msg);
	get_msg(conn, &msg);

	type = buffer_get_char(&msg);
	id = buffer_get_int(&msg);
d285 1
a285 1
		int status = buffer_get_int(&msg);
d287 2
d293 1
a293 1
		buffer_free(&msg);
d299 6
a304 2
	a = decode_attrib(&msg);
	buffer_free(&msg);
d306 1
a306 1
	return(a);
d313 5
a317 5
	Buffer msg;
	u_int type, id, flag;

	buffer_init(&msg);
	get_msg(conn, &msg);
d319 7
a325 2
	type = buffer_get_char(&msg);
	id = buffer_get_int(&msg);
d331 1
a331 1
		int status = buffer_get_int(&msg);
d333 2
d339 1
a339 1
		buffer_free(&msg);
d347 12
a358 11
	st->f_bsize = buffer_get_int64(&msg);
	st->f_frsize = buffer_get_int64(&msg);
	st->f_blocks = buffer_get_int64(&msg);
	st->f_bfree = buffer_get_int64(&msg);
	st->f_bavail = buffer_get_int64(&msg);
	st->f_files = buffer_get_int64(&msg);
	st->f_ffree = buffer_get_int64(&msg);
	st->f_favail = buffer_get_int64(&msg);
	st->f_fsid = buffer_get_int64(&msg);
	flag = buffer_get_int64(&msg);
	st->f_namemax = buffer_get_int64(&msg);
d363 1
a363 1
	buffer_free(&msg);
d372 2
a373 2
	u_int type;
	Buffer msg;
d375 1
d386 6
a391 4
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_INIT);
	buffer_put_int(&msg, SSH2_FILEXFER_VERSION);
	send_msg(ret, &msg);
d393 1
a393 1
	buffer_clear(&msg);
d395 1
a395 1
	get_msg(ret, &msg);
d398 3
a400 1
	if ((type = buffer_get_char(&msg)) != SSH2_FXP_VERSION) {
d403 1
a403 1
		buffer_free(&msg);
d406 2
a407 1
	ret->version = buffer_get_int(&msg);
d412 4
a415 3
	while (buffer_len(&msg) > 0) {
		char *name = buffer_get_string(&msg, NULL);
		char *value = buffer_get_string(&msg, NULL);
d418 3
d422 1
a422 1
		    strcmp(value, "1") == 0) {
d426 1
a426 1
		    strcmp(value, "2") == 0) {
d430 1
a430 1
		    strcmp(value, "2") == 0) {
d434 1
a434 1
		    strcmp(value, "1") == 0) {
d437 4
a440 4
 		} else if (strcmp(name, "fsync@@openssh.com") == 0 &&
 		    strcmp(value, "1") == 0) {
 			ret->exts |= SFTP_EXT_FSYNC;
 			known = 1;
d452 1
a452 1
	buffer_free(&msg);
d476 1
a476 1
do_close(struct sftp_conn *conn, char *handle, u_int handle_len)
d479 2
a480 1
	Buffer msg;
d482 2
a483 1
	buffer_init(&msg);
d486 5
a490 4
	buffer_put_char(&msg, SSH2_FXP_CLOSE);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, handle, handle_len);
	send_msg(conn, &msg);
d497 1
a497 1
	buffer_free(&msg);
d499 1
a499 1
	return status;
d504 1
a504 1
do_lsreaddir(struct sftp_conn *conn, char *path, int print_flag,
d507 4
a510 2
	Buffer msg;
	u_int count, type, id, handle_len, i, expected_id, ents = 0;
d513 1
d520 7
a526 5
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_OPENDIR);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, path);
	send_msg(conn, &msg);
d531 1
a531 1
		buffer_free(&msg);
d546 14
a559 12
		buffer_clear(&msg);
		buffer_put_char(&msg, SSH2_FXP_READDIR);
		buffer_put_int(&msg, id);
		buffer_put_string(&msg, handle, handle_len);
		send_msg(conn, &msg);

		buffer_clear(&msg);

		get_msg(conn, &msg);

		type = buffer_get_char(&msg);
		id = buffer_get_int(&msg);
d567 7
a573 3
			status = buffer_get_int(&msg);
			debug3("Received SSH2_FXP_STATUS %d", status);
			if (status == SSH2_FX_EOF)
d575 1
a575 1
			error("Couldn't read directory: %s", fx2txt(status));
d581 2
a582 1
		count = buffer_get_int(&msg);
d588 1
a588 1
			Attrib *a;
d590 14
a603 3
			filename = buffer_get_string(&msg, NULL);
			longname = buffer_get_string(&msg, NULL);
			a = decode_attrib(&msg);
d621 1
a621 1
				memcpy(&(*dir)[ents]->a, a, sizeof(*a));
d631 1
a631 1
	buffer_free(&msg);
d650 1
a650 1
do_readdir(struct sftp_conn *conn, char *path, SFTP_DIRENT ***dir)
d670 1
a670 1
do_rm(struct sftp_conn *conn, char *path)
d681 1
a681 1
	return(status);
d685 1
a685 1
do_mkdir(struct sftp_conn *conn, char *path, Attrib *a, int print_flag)
d697 1
a697 1
	return(status);
d701 1
a701 1
do_rmdir(struct sftp_conn *conn, char *path)
d713 1
a713 1
	return(status);
d717 1
a717 1
do_stat(struct sftp_conn *conn, char *path, int quiet)
d731 1
a731 1
do_lstat(struct sftp_conn *conn, char *path, int quiet)
d752 2
a753 1
do_fstat(struct sftp_conn *conn, char *handle, u_int handle_len, int quiet)
d766 1
a766 1
do_setstat(struct sftp_conn *conn, char *path, Attrib *a)
d779 1
a779 1
	return(status);
d783 1
a783 1
do_fsetstat(struct sftp_conn *conn, char *handle, u_int handle_len,
d796 1
a796 1
	return(status);
d800 1
a800 1
do_realpath(struct sftp_conn *conn, char *path)
d802 2
a803 2
	Buffer msg;
	u_int type, expected_id, count, id;
d805 3
a807 1
	Attrib *a;
d813 2
a814 1
	buffer_init(&msg);
d816 4
a819 3
	get_msg(conn, &msg);
	type = buffer_get_char(&msg);
	id = buffer_get_int(&msg);
d825 1
a825 1
		u_int status = buffer_get_int(&msg);
d827 2
d830 1
a830 1
		buffer_free(&msg);
d836 2
a837 1
	count = buffer_get_int(&msg);
d841 4
a844 3
	filename = buffer_get_string(&msg, NULL);
	longname = buffer_get_string(&msg, NULL);
	a = decode_attrib(&msg);
d847 1
a847 1
	    (unsigned long)a->size);
d851 1
a851 1
	buffer_free(&msg);
d857 1
a857 1
do_rename(struct sftp_conn *conn, char *oldpath, char *newpath,
d860 1
a860 1
	Buffer msg;
d862 1
a862 1
	int use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;
d864 2
a865 1
	buffer_init(&msg);
d870 5
a874 3
		buffer_put_char(&msg, SSH2_FXP_EXTENDED);
		buffer_put_int(&msg, id);
		buffer_put_cstring(&msg, "posix-rename@@openssh.com");
d876 8
a883 6
		buffer_put_char(&msg, SSH2_FXP_RENAME);
		buffer_put_int(&msg, id);
	}
	buffer_put_cstring(&msg, oldpath);
	buffer_put_cstring(&msg, newpath);
	send_msg(conn, &msg);
d885 3
a887 3
	    use_ext ? "posix-rename@@openssh.com" : "SSH2_FXP_RENAME",
	    oldpath, newpath);
	buffer_free(&msg);
d894 1
a894 1
	return(status);
d898 1
a898 1
do_hardlink(struct sftp_conn *conn, char *oldpath, char *newpath)
d900 1
a900 1
	Buffer msg;
d902 1
d909 2
a910 1
	buffer_init(&msg);
d914 7
a920 6
	buffer_put_char(&msg, SSH2_FXP_EXTENDED);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, "hardlink@@openssh.com");
	buffer_put_cstring(&msg, oldpath);
	buffer_put_cstring(&msg, newpath);
	send_msg(conn, &msg);
d923 1
a923 1
	buffer_free(&msg);
d930 1
a930 1
	return(status);
d934 1
a934 1
do_symlink(struct sftp_conn *conn, char *oldpath, char *newpath)
d936 1
a936 1
	Buffer msg;
d938 1
d945 2
a946 1
	buffer_init(&msg);
d950 6
a955 5
	buffer_put_char(&msg, SSH2_FXP_SYMLINK);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, oldpath);
	buffer_put_cstring(&msg, newpath);
	send_msg(conn, &msg);
d958 1
a958 1
	buffer_free(&msg);
d965 1
a965 1
	return(status);
d969 1
a969 1
do_fsync(struct sftp_conn *conn, char *handle, u_int handle_len)
d971 1
a971 1
	Buffer msg;
d973 1
a978 2
	buffer_init(&msg);

d980 2
d983 6
a988 6

	buffer_put_char(&msg, SSH2_FXP_EXTENDED);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, "fsync@@openssh.com");
	buffer_put_string(&msg, handle, handle_len);
	send_msg(conn, &msg);
d990 1
a990 1
	buffer_free(&msg);
d1001 1
a1001 1
do_readlink(struct sftp_conn *conn, char *path)
d1003 2
a1004 2
	Buffer msg;
	u_int type, expected_id, count, id;
d1006 3
a1008 1
	Attrib *a;
d1013 2
a1014 1
	buffer_init(&msg);
d1016 4
a1019 3
	get_msg(conn, &msg);
	type = buffer_get_char(&msg);
	id = buffer_get_int(&msg);
d1025 1
a1025 1
		u_int status = buffer_get_int(&msg);
d1027 2
d1030 1
a1030 1
		buffer_free(&msg);
d1036 2
a1037 1
	count = buffer_get_int(&msg);
d1041 4
a1044 3
	filename = buffer_get_string(&msg, NULL);
	longname = buffer_get_string(&msg, NULL);
	a = decode_attrib(&msg);
d1050 1
a1050 1
	buffer_free(&msg);
d1052 1
a1052 1
	return(filename);
d1060 1
a1060 1
	Buffer msg;
d1062 1
d1071 10
a1080 8
	buffer_init(&msg);
	buffer_clear(&msg);
	buffer_put_char(&msg, SSH2_FXP_EXTENDED);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, "statvfs@@openssh.com");
	buffer_put_cstring(&msg, path);
	send_msg(conn, &msg);
	buffer_free(&msg);
d1087 1
a1087 1
do_fstatvfs(struct sftp_conn *conn, const char *handle, u_int handle_len,
d1090 1
a1090 1
	Buffer msg;
d1100 10
a1109 8
	buffer_init(&msg);
	buffer_clear(&msg);
	buffer_put_char(&msg, SSH2_FXP_EXTENDED);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, "fstatvfs@@openssh.com");
	buffer_put_string(&msg, handle, handle_len);
	send_msg(conn, &msg);
	buffer_free(&msg);
d1117 1
a1117 1
    u_int len, char *handle, u_int handle_len)
d1119 2
a1120 1
	Buffer msg;
d1122 11
a1132 9
	buffer_init(&msg);
	buffer_clear(&msg);
	buffer_put_char(&msg, SSH2_FXP_READ);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, handle, handle_len);
	buffer_put_int64(&msg, offset);
	buffer_put_int(&msg, len);
	send_msg(conn, &msg);
	buffer_free(&msg);
d1136 3
a1138 2
do_download(struct sftp_conn *conn, char *remote_path, char *local_path,
    Attrib *a, int preserve_flag, int resume_flag, int fsync_flag)
d1141 4
a1144 4
	Buffer msg;
	char *handle;
	int local_fd = -1, status = 0, write_error;
	int read_error, write_errno, reordered = 0;
d1146 1
a1146 1
	u_int handle_len, mode, type, id, buflen, num_req, max_req;
d1148 1
d1152 1
a1152 1
		u_int len;
d1158 1
d1183 4
a1186 1
	buffer_init(&msg);
d1190 7
a1196 7
	buffer_put_char(&msg, SSH2_FXP_OPEN);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, remote_path);
	buffer_put_int(&msg, SSH2_FXF_READ);
	attrib_clear(&junk); /* Send empty attributes */
	encode_attrib(&msg, &junk);
	send_msg(conn, &msg);
d1202 1
a1202 1
		buffer_free(&msg);
d1229 1
a1229 1
			buffer_free(&msg);
d1247 2
a1248 2
		char *data;
		u_int len;
d1277 5
a1281 4
		buffer_clear(&msg);
		get_msg(conn, &msg);
		type = buffer_get_char(&msg);
		id = buffer_get_int(&msg);
d1294 3
a1296 1
			status = buffer_get_int(&msg);
d1305 3
a1307 1
			data = buffer_get_string(&msg, &len);
d1313 1
a1313 1
				    "%u > %u", len, req->len);
d1390 1
a1390 1
		status = -1;
d1393 4
a1396 3
		status = do_close(conn, handle, handle_len);
		if (interrupted || status != SSH2_FX_OK)
			status = -1;
d1419 1
a1419 1
	buffer_free(&msg);
d1426 3
a1428 3
download_dir_internal(struct sftp_conn *conn, char *src, char *dst, int depth,
    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag,
    int fsync_flag)
d1518 3
a1520 3
download_dir(struct sftp_conn *conn, char *src, char *dst,
    Attrib *dirattrib, int preserve_flag, int print_flag,
    int resume_flag, int fsync_flag)
d1537 2
a1538 2
do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
    int preserve_flag, int resume, int fsync_flag)
d1540 4
a1543 3
	int local_fd;
	int status = SSH2_FX_OK;
	u_int handle_len, id, type;
d1545 2
a1546 2
	char *handle, *data;
	Buffer msg;
d1559 1
d1607 2
a1608 1
	buffer_init(&msg);
d1612 8
a1619 7
	buffer_put_char(&msg, SSH2_FXP_OPEN);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, remote_path);
	buffer_put_int(&msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|
		      (resume ? SSH2_FXF_APPEND : SSH2_FXF_TRUNC));
	encode_attrib(&msg, &a);
	send_msg(conn, &msg);
d1622 1
a1622 1
	buffer_clear(&msg);
d1628 1
a1628 1
		buffer_free(&msg);
d1667 10
a1676 7
			buffer_clear(&msg);
			buffer_put_char(&msg, SSH2_FXP_WRITE);
			buffer_put_int(&msg, ack->id);
			buffer_put_string(&msg, handle, handle_len);
			buffer_put_int64(&msg, offset);
			buffer_put_string(&msg, data, len);
			send_msg(conn, &msg);
d1687 1
a1687 1
			u_int r_id;
d1689 6
a1694 4
			buffer_clear(&msg);
			get_msg(conn, &msg);
			type = buffer_get_char(&msg);
			r_id = buffer_get_int(&msg);
d1700 4
a1703 2
			status = buffer_get_int(&msg);
			debug3("SSH2_FXP_STATUS %d", status);
d1707 1
a1707 1
			    ack != NULL && ack->id != r_id;
d1711 1
a1711 1
				fatal("Can't find request for ID %u", r_id);
d1723 1
a1723 1
	buffer_free(&msg);
d1732 1
a1732 1
		status = -1;
d1738 1
a1738 1
		status = -1;
d1749 2
a1750 1
		status = -1;
d1753 1
a1753 1
	return status;
d1757 2
a1758 2
upload_dir_internal(struct sftp_conn *conn, char *src, char *dst, int depth,
    int preserve_flag, int print_flag, int resume, int fsync_flag)
d1760 2
a1761 1
	int ret = 0, status;
d1851 2
a1852 2
upload_dir(struct sftp_conn *conn, char *src, char *dst, int preserve_flag,
    int print_flag, int resume, int fsync_flag)
d1870 1
a1870 1
path_append(char *p1, char *p2)
@


1.114
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.113 2014/01/17 00:21:06 djm Exp $ */
d1412 1
a1412 1
    int preserve_flag, int fsync_flag)
d1421 1
a1421 1
	Attrib a;
d1459 20
d1486 2
a1487 1
	buffer_put_int(&msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|SSH2_FXF_TRUNC);
d1506 1
a1506 1
	offset = progress_counter = 0;
d1620 1
a1620 1
    int preserve_flag, int print_flag, int fsync_flag)
d1689 1
a1689 1
			    depth + 1, preserve_flag, print_flag,
d1694 1
a1694 1
			    preserve_flag, fsync_flag) == -1) {
d1713 1
a1713 1
    int print_flag, int fsync_flag)
d1724 1
a1724 1
	    print_flag, fsync_flag);
@


1.113
log
@signed/unsigned comparison warning fix; from portable
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.112 2014/01/16 07:31:09 djm Exp $ */
d306 1
a306 1
	bzero(st, sizeof(*st));
@


1.112
log
@needless and incorrect cast to size_t can break resumption of
large download; patch from tobias@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.111 2013/12/05 22:59:45 djm Exp $ */
d1100 5
a1104 1
		if (st.st_size > size) {
@


1.111
log
@fix memory leak in error path in do_readdir(); pointed out by
Loganaden Velvindron @@ AfriNIC in bz#2163
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.110 2013/12/04 04:20:01 djm Exp $ */
d1100 1
a1100 1
		if ((size_t)st.st_size > size) {
@


1.110
log
@bz#2171: don't leak local_fd on error; from Loganaden Velvindron @@
AfriNIC
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.109 2013/11/08 11:15:19 dtucker Exp $ */
d456 4
d506 1
a506 2
			int status = buffer_get_int(&msg);

d508 1
a508 2

			if (status == SSH2_FX_EOF) {
d510 2
a511 8
			} else {
				error("Couldn't read directory: %s",
				    fx2txt(status));
				do_close(conn, handle, handle_len);
				free(handle);
				buffer_free(&msg);
				return(status);
			}
d539 1
a539 4
				goto next;
			}

			if (dir) {
a546 1
 next:
d551 1
d553 1
d558 6
a563 2
	/* Don't return partial matches on interrupt */
	if (interrupted && dir != NULL && *dir != NULL) {
d569 1
a569 1
	return 0;
d582 2
@


1.109
log
@Include stdlib.h for free() as per the man page.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.108 2013/11/08 00:39:15 djm Exp $ */
d1107 2
@


1.108
log
@use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.107 2013/10/17 00:30:13 djm Exp $ */
d38 1
@


1.107
log
@fsync@@openssh.com protocol extension for sftp-server
client support to allow calling fsync() faster successful transfer
patch mostly by imorgan AT nas.nasa.gov; bz#1798
"fine" markus@@ "grumble OK" deraadt@@ "doesn't sound bad to me" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.106 2013/10/11 02:52:23 djm Exp $ */
d473 1
a473 1
		*dir = xmalloc(sizeof(**dir));
d547 1
a547 1
				(*dir)[ents] = xmalloc(sizeof(***dir));
d566 1
a566 1
		*dir = xmalloc(sizeof(**dir));
d1139 1
a1139 1
			req = xmalloc(sizeof(*req));
d1503 1
a1503 1
			ack = xmalloc(sizeof(*ack));
@


1.106
log
@missed one arg reorder
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.105 2013/10/11 02:45:36 djm Exp $ */
d72 1
d385 4
d744 1
a744 1
		error("Couldn't canonicalise: %s", fx2txt(status));
d870 30
d1022 1
a1022 1
    Attrib *a, int preserve_flag, int resume_flag)
d1278 6
d1294 2
a1295 1
    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag)
d1348 1
a1348 1
			    print_flag, resume_flag) == -1)
d1352 2
a1353 1
			    &(dir_entries[i]->a), preserve_flag, resume_flag) == -1) {
d1386 2
a1387 1
    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag)
d1393 1
a1393 1
		error("Unable to canonicalise path \"%s\"", src);
d1398 1
a1398 1
	    dirattrib, preserve_flag, print_flag, resume_flag);
d1405 1
a1405 1
    int preserve_flag)
d1580 3
d1592 1
a1592 1
    int preserve_flag, int print_flag)
d1661 2
a1662 1
			    depth + 1, preserve_flag, print_flag) == -1)
d1666 1
a1666 1
			    preserve_flag) == -1) {
d1685 1
a1685 1
    int print_flag)
d1691 1
a1691 1
		error("Unable to canonicalise path \"%s\"", dst);
d1696 2
a1697 1
	    print_flag);
@


1.105
log
@rename flag arguments to be more clear and consistent.
reorder some internal function arguments to make adding additional flags
easier.

no functional change
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.104 2013/09/19 00:49:12 djm Exp $ */
d1647 2
a1648 2
	ret = upload_dir_internal(conn, src, dst_canon, preserve_flag,
	    print_flag, 0);
@


1.104
log
@fix swapped pflag and printflag in sftp upload_dir; from Iain Morgan
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.103 2013/08/09 03:39:13 djm Exp $ */
d444 1
a444 1
do_lsreaddir(struct sftp_conn *conn, char *path, int printflag,
d526 1
a526 1
			if (printflag)
d602 1
a602 1
do_mkdir(struct sftp_conn *conn, char *path, Attrib *a, int printflag)
d611 1
a611 1
	if (status != SSH2_FX_OK && printflag)
d987 1
a987 1
    Attrib *a, int pflag, int resume)
d1050 2
a1051 2
	local_fd = open(local_path, O_WRONLY | O_CREAT | (resume ? : O_TRUNC),
	    mode | S_IWUSR);
d1058 1
a1058 1
	if (resume) {
d1208 1
a1208 1
		if (reordered && resume) {
d1230 1
a1230 1
		if (pflag && fchmod(local_fd, mode) == -1)
d1233 2
a1234 1
		if (pflag && (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {
d1252 2
a1253 2
download_dir_internal(struct sftp_conn *conn, char *src, char *dst,
    Attrib *dirattrib, int pflag, int printflag, int depth, int resume)
d1274 1
a1274 1
	if (printflag)
d1305 2
a1306 2
			    &(dir_entries[i]->a), pflag, printflag,
			    depth + 1, resume) == -1)
d1310 1
a1310 1
			    &(dir_entries[i]->a), pflag, resume) == -1) {
d1322 1
a1322 1
	if (pflag) {
d1343 1
a1343 1
    Attrib *dirattrib, int pflag, int printflag, int resume)
d1353 2
a1354 2
	ret = download_dir_internal(conn, src_canon, dst,
	    dirattrib, pflag, printflag, 0, resume);
d1361 1
a1361 1
    int pflag)
d1405 1
a1405 1
	if (!pflag)
d1533 1
a1533 1
	if (pflag)
d1544 2
a1545 2
upload_dir_internal(struct sftp_conn *conn, char *src, char *dst,
    int pflag, int printflag, int depth)
d1568 1
a1568 1
	if (printflag)
d1576 1
a1576 1
	if (!pflag)
d1614 1
a1614 1
			    pflag, printflag, depth + 1) == -1)
d1617 2
a1618 1
			if (do_upload(conn, new_src, new_dst, pflag) == -1) {
d1636 2
a1637 2
upload_dir(struct sftp_conn *conn, char *src, char *dst, int pflag,
    int printflag)
d1647 2
a1648 1
	ret = upload_dir_internal(conn, src, dst_canon, pflag, printflag, 0);
@


1.103
log
@two problems found by a to-be-committed regress test: 1) msg_id was not
being initialised so was starting at a random value from the heap
(harmless, but confusing). 2) some error conditions were not being
propagated back to the caller
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.102 2013/08/08 05:04:03 djm Exp $ */
d1634 2
a1635 2
upload_dir(struct sftp_conn *conn, char *src, char *dst, int printflag,
    int pflag)
@


1.102
log
@add a "-l" flag for the rename command to force it to use the silly
standard SSH_FXP_RENAME command instead of the POSIX-rename- like
posix-rename@@openssh.com extension.

intended for use in regress tests, so no documentation.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.101 2013/07/25 00:56:51 djm Exp $ */
d333 2
a334 1
	ret = xmalloc(sizeof(*ret));
d1218 1
d1227 1
a1227 1
		if (interrupted)
@


1.101
log
@sftp support for resuming partial downloads; patch mostly by Loganaden
Velvindron/AfriNIC with some tweaks by me; feedback and ok dtucker@@
"Just be careful" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.100 2013/06/01 22:34:50 dtucker Exp $ */
d764 2
a765 1
do_rename(struct sftp_conn *conn, char *oldpath, char *newpath)
d769 1
d775 1
a775 1
	if ((conn->exts & SFTP_EXT_POSIX_RENAME)) {
d787 2
a788 2
	    (conn->exts & SFTP_EXT_POSIX_RENAME) ? "posix-rename@@openssh.com" :
	    "SSH2_FXP_RENAME", oldpath, newpath);
@


1.101.2.1
log
@cherrypick commit:

date: 2013/11/08 00:39:15;  author: djm;  state: Exp;  lines: +2 -2;
use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.101 2013/07/25 00:56:51 djm Exp $ */
d467 1
a467 1
		*dir = xcalloc(1, sizeof(**dir));
d541 1
a541 1
				(*dir)[ents] = xcalloc(1, sizeof(***dir));
d560 1
a560 1
		*dir = xcalloc(1, sizeof(**dir));
d1101 1
a1101 1
			req = xcalloc(1, sizeof(*req));
d1454 1
a1454 1
			ack = xcalloc(1, sizeof(*ack));
@


1.100
log
@Update progressmeter when data is acked, not when it's sent.  bz#2108, from
Debian via Colin Watson, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.99 2013/06/01 20:59:25 dtucker Exp $ */
d108 1
a108 1
	    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) != 
d984 1
a984 1
    Attrib *a, int pflag)
d989 3
a991 3
	int local_fd, status = 0, write_error;
	int read_error, write_errno;
	u_int64_t offset, size;
d994 1
d1047 1
a1047 1
	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC,
d1052 19
a1070 4
		do_close(conn, handle, handle_len);
		buffer_free(&msg);
		free(handle);
		return(-1);
d1074 1
a1074 1
	write_error = read_error = write_errno = num_req = offset = 0;
d1076 1
a1076 1
	progress_counter = 0;
d1151 4
d1203 9
a1211 1

d1223 2
a1224 1

d1248 1
a1248 1
    Attrib *dirattrib, int pflag, int printflag, int depth)
d1301 1
a1301 1
			    depth + 1) == -1)
d1305 1
a1305 1
			    &(dir_entries[i]->a), pflag) == -1) {
d1338 1
a1338 1
    Attrib *dirattrib, int pflag, int printflag)
d1349 1
a1349 1
	    dirattrib, pflag, printflag, 0);
d1573 1
a1573 1
	
d1583 1
a1583 1
		if (do_stat(conn, dst, 0) == NULL) 
d1591 1
a1591 1
	
@


1.99
log
@Replace S_IWRITE, which isn't standardized, with S_IWUSR, which is.  Patch
from Nathan Osman via bz#2085.  ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.98 2013/05/17 00:13:14 djm Exp $ */
d1332 1
a1332 1
	off_t offset;
d1400 1
a1400 1
	offset = 0;
d1402 2
a1403 1
		start_progress_meter(local_path, sb.st_size, &offset);
d1473 1
@


1.98
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.97 2012/07/02 12:13:26 dtucker Exp $ */
d1047 1
a1047 1
	    mode | S_IWRITE);
@


1.97
log
@fix a couple of "assigned but not used" warnings.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.96 2011/09/12 08:46:15 markus Exp $ */
d390 2
a391 2
		xfree(name);
		xfree(value);
d505 1
a505 1
				xfree(handle);
d548 2
a549 2
			xfree(filename);
			xfree(longname);
d555 1
a555 1
	xfree(handle);
d578 3
a580 3
		xfree(s[i]->filename);
		xfree(s[i]->longname);
		xfree(s[i]);
d582 1
a582 1
	xfree(s);
d756 1
a756 1
	xfree(longname);
d903 1
a903 1
	xfree(longname);
d1053 1
a1053 1
		xfree(handle);
d1117 1
a1117 1
			xfree(req);
d1136 1
a1136 1
			xfree(data);
d1140 1
a1140 1
				xfree(req);
d1212 1
a1212 1
	xfree(handle);
d1284 2
a1285 2
		xfree(new_dst);
		xfree(new_src);
d1321 1
a1321 1
	xfree(src_canon);
d1472 1
a1472 1
			xfree(ack);
d1482 1
a1482 1
	xfree(data);
d1502 1
a1502 1
	xfree(handle);
d1588 2
a1589 2
		xfree(new_dst);
		xfree(new_src);
d1611 1
a1611 1
	xfree(dst_canon);
@


1.97.4.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.101.2.1 2013/11/08 01:33:56 djm Exp $ */
d467 1
a467 1
		*dir = xcalloc(1, sizeof(**dir));
d541 1
a541 1
				(*dir)[ents] = xcalloc(1, sizeof(***dir));
d560 1
a560 1
		*dir = xcalloc(1, sizeof(**dir));
d1085 1
a1085 1
			req = xcalloc(1, sizeof(*req));
d1424 1
a1424 1
			ack = xcalloc(1, sizeof(*ack));
@


1.96
log
@fix leak in do_lsreaddir(); ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.95 2011/09/11 16:07:26 markus Exp $ */
d753 2
a754 1
	debug3("SSH_FXP_REALPATH %s -> %s", path, filename);
@


1.95
log
@fix leaks in do_hardlink() and do_readlink(); bz#1921
from Loganaden Velvindron
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.94 2010/12/04 00:18:01 djm Exp $ */
a457 2
	buffer_clear(&msg);

d460 2
a461 1
	if (handle == NULL)
d463 1
d506 1
@


1.94
log
@add a protocol extension to support a hard link operation. It is
available through the "ln" command in the client. The old "ln"
behaviour of creating a symlink is available using its "-s" option
or through the preexisting "symlink" command; based on a patch from
miklos AT szeredi.hu in bz#1555; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.93 2010/09/22 22:58:51 djm Exp $ */
a800 4
	buffer_init(&msg);

	/* Send link request */
	id = conn->msg_id++;
d806 4
d885 1
@


1.93
log
@add an option per-read/write callback to atomicio

factor out bandwidth limiting code from scp(1) into a generic bandwidth
limiter that can be attached using the atomicio callback mechanism

add a bandwidth limit option to sftp(1) using the above

"very nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.92 2010/07/19 03:16:33 djm Exp $ */
d71 1
d375 1
a375 1
		} if (strcmp(name, "fstatvfs@@openssh.com") == 0 &&
d379 4
d790 33
@


1.92
log
@bz#1797: fix swapped args in upload_dir_internal(), breaking recursive
upload depth checks and causing verbose printing of transfers to always
be turned on; patch from imorgan AT nas.nasa.gov
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.91 2010/06/18 04:43:08 djm Exp $ */
d24 1
d72 2
d77 12
a88 2
get_handle(int fd, u_int expected_id, u_int *len, const char *errfmt, ...)
    __attribute__((format(printf, 4, 5)));
d91 1
a91 1
send_msg(int fd, Buffer *m)
d106 3
a108 1
	if (atomiciov(writev, fd, iov, 2) != buffer_len(m) + sizeof(mlen))
d115 1
a115 1
get_msg(int fd, Buffer *m)
d120 2
a121 1
	if (atomicio(read, fd, buffer_ptr(m), 4) != 4) {
d133 3
a135 1
	if (atomicio(read, fd, buffer_ptr(m), msg_len) != msg_len) {
d144 1
a144 1
send_string_request(int fd, u_int id, u_int code, char *s,
d153 2
a154 2
	send_msg(fd, &msg);
	debug3("Sent message fd %d T:%u I:%u", fd, code, id);
d159 2
a160 2
send_string_attrs_request(int fd, u_int id, u_int code, char *s,
    u_int len, Attrib *a)
d169 2
a170 2
	send_msg(fd, &msg);
	debug3("Sent message fd %d T:%u I:%u", fd, code, id);
d175 1
a175 1
get_status(int fd, u_int expected_id)
d181 1
a181 1
	get_msg(fd, &msg);
d196 1
a196 1
	return(status);
d200 2
a201 1
get_handle(int fd, u_int expected_id, u_int *len, const char *errfmt, ...)
d215 1
a215 1
	get_msg(fd, &msg);
d239 1
a239 1
get_decode_stat(int fd, u_int expected_id, int quiet)
d246 1
a246 1
	get_msg(fd, &msg);
d274 2
a275 2
get_decode_statvfs(int fd, struct sftp_statvfs *st, u_int expected_id,
    int quiet)
d281 1
a281 1
	get_msg(fd, &msg);
d325 2
a326 1
do_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests)
d328 1
a328 2
	u_int type, exts = 0;
	int version;
d332 8
d343 1
a343 1
	send_msg(fd_out, &msg);
d347 1
a347 1
	get_msg(fd_in, &msg);
d356 1
a356 1
	version = buffer_get_int(&msg);
d358 1
a358 1
	debug2("Remote version: %d", version);
d368 1
a368 1
			exts |= SFTP_EXT_POSIX_RENAME;
d372 1
a372 1
			exts |= SFTP_EXT_STATVFS;
d376 1
a376 1
			exts |= SFTP_EXT_FSTATVFS;
a390 9
	ret = xmalloc(sizeof(*ret));
	ret->fd_in = fd_in;
	ret->fd_out = fd_out;
	ret->transfer_buflen = transfer_buflen;
	ret->num_requests = num_requests;
	ret->version = version;
	ret->msg_id = 1;
	ret->exts = exts;

d392 1
a392 1
	if (version == 0)
d395 9
a403 1
	return(ret);
d409 1
a409 1
	return(conn->version);
d424 1
a424 1
	send_msg(conn->fd_out, &msg);
d427 1
a427 1
	status = get_status(conn->fd_in, id);
d433 1
a433 1
	return(status);
d451 1
a451 1
	send_msg(conn->fd_out, &msg);
d455 1
a455 1
	handle = get_handle(conn->fd_in, id, &handle_len,
d458 1
a458 1
		return(-1);
d475 1
a475 1
		send_msg(conn->fd_out, &msg);
d479 1
a479 1
		get_msg(conn->fd_in, &msg);
d558 1
a558 1
	return(0);
d587 2
a588 3
	send_string_request(conn->fd_out, id, SSH2_FXP_REMOVE, path,
	    strlen(path));
	status = get_status(conn->fd_in, id);
d600 1
a600 1
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_MKDIR, path,
d603 1
a603 1
	status = get_status(conn->fd_in, id);
d616 1
a616 1
	send_string_request(conn->fd_out, id, SSH2_FXP_RMDIR, path,
d619 1
a619 1
	status = get_status(conn->fd_in, id);
d633 1
a633 1
	send_string_request(conn->fd_out, id,
d637 1
a637 1
	return(get_decode_stat(conn->fd_in, id, quiet));
d654 1
a654 1
	send_string_request(conn->fd_out, id, SSH2_FXP_LSTAT, path,
d657 1
a657 1
	return(get_decode_stat(conn->fd_in, id, quiet));
d667 1
a667 1
	send_string_request(conn->fd_out, id, SSH2_FXP_FSTAT, handle,
d670 1
a670 1
	return(get_decode_stat(conn->fd_in, id, quiet));
d680 1
a680 1
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_SETSTAT, path,
d683 1
a683 1
	status = get_status(conn->fd_in, id);
d698 1
a698 1
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_FSETSTAT, handle,
d701 1
a701 1
	status = get_status(conn->fd_in, id);
d717 1
a717 1
	send_string_request(conn->fd_out, id, SSH2_FXP_REALPATH, path,
d722 1
a722 1
	get_msg(conn->fd_in, &msg);
d776 1
a776 1
	send_msg(conn->fd_out, &msg);
d782 1
a782 1
	status = get_status(conn->fd_in, id);
d809 1
a809 1
	send_msg(conn->fd_out, &msg);
d814 1
a814 1
	status = get_status(conn->fd_in, id);
d832 1
a832 2
	send_string_request(conn->fd_out, id, SSH2_FXP_READLINK, path,
	    strlen(path));
d836 1
a836 1
	get_msg(conn->fd_in, &msg);
d890 1
a890 1
	send_msg(conn->fd_out, &msg);
d893 1
a893 1
	return get_decode_statvfs(conn->fd_in, st, id, quiet);
d917 1
a917 1
	send_msg(conn->fd_out, &msg);
d920 1
a920 1
	return get_decode_statvfs(conn->fd_in, st, id, quiet);
d925 2
a926 2
send_read_request(int fd_out, u_int id, u_int64_t offset, u_int len,
    char *handle, u_int handle_len)
d937 1
a937 1
	send_msg(fd_out, &msg);
d995 1
a995 1
	send_msg(conn->fd_out, &msg);
d998 1
a998 1
	handle = get_handle(conn->fd_in, id, &handle_len,
d1051 1
a1051 1
			send_read_request(conn->fd_out, req->id, req->offset,
d1056 1
a1056 1
		get_msg(conn->fd_in, &msg);
d1111 1
a1111 1
				send_read_request(conn->fd_out, req->id,
d1342 1
a1342 1
	send_msg(conn->fd_out, &msg);
d1347 1
a1347 1
	handle = get_handle(conn->fd_in, id, &handle_len,
d1395 1
a1395 1
			send_msg(conn->fd_out, &msg);
d1409 1
a1409 1
			get_msg(conn->fd_in, &msg);
@


1.91
log
@fix memory leak in do_realpath() error path; bz#1771, patch from
anicka AT suse.cz
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.90 2009/10/11 10:41:26 dtucker Exp $ */
d1513 1
a1513 1
			    pflag, depth + 1, printflag) == -1)
@


1.90
log
@d_type isn't portable so use lstat to get dirent modes.  Suggested by and
"looks sane" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.89 2009/08/18 18:36:20 djm Exp $ */
d708 2
a709 1
		return(NULL);
@


1.89
log
@recursive transfer support for get/put and on the commandline
work mostly by carlosvsilvapt@@gmail.com for the Google Summer of Code
with some tweaks by me; "go for it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.88 2009/08/14 18:17:49 djm Exp $ */
d1502 5
a1506 1
		if (S_ISDIR(DTTOIF(dp->d_type))) {
d1514 1
a1514 1
		} else if (S_ISREG(DTTOIF(dp->d_type)) ) {
@


1.88
log
@make the "get_handle: ..." error messages vaguely useful by allowing
callers to specify their own error message strings.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.87 2009/06/22 05:39:28 dtucker Exp $ */
d31 1
d57 3
d496 11
d515 1
a515 1

d570 1
a570 1
do_mkdir(struct sftp_conn *conn, char *path, Attrib *a)
d579 1
a579 1
	if (status != SSH2_FX_OK)
d918 1
a918 1
    int pflag)
d920 1
a920 1
	Attrib junk, *a;
d939 2
a940 3
	a = do_stat(conn, remote_path, 0);
	if (a == NULL)
		return(-1);
d1151 108
d1440 120
@


1.87
log
@alphabetize includes; reduces diff vs portable and style(9).  ok stevesk djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.86 2008/06/26 06:10:09 djm Exp $ */
d69 4
d178 1
a178 1
get_handle(int fd, u_int expected_id, u_int *len)
d182 8
a189 1
	char *handle;
d197 2
a198 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d200 3
a202 3
		int status = buffer_get_int(&msg);

		error("Couldn't get handle: %s", fx2txt(status));
d206 2
a207 2
		fatal("Expected SSH2_FXP_HANDLE(%u) packet, got %u",
		    SSH2_FXP_HANDLE, type);
d425 2
a426 1
	handle = get_handle(conn->fd_in, id, &handle_len);
d959 2
a960 1
	handle = get_handle(conn->fd_in, id, &handle_len);
d1200 2
a1201 1
	handle = get_handle(conn->fd_in, id, &handle_len);
@


1.86
log
@allow the sftp chmod(2)-equivalent operation to set set[ug]id/sticky
bits. Note that this only affects explicit setting of modes (e.g. via
sftp(1)'s chmod command) and not file transfers. (bz#1310)
ok deraadt@@ at c2k8
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.85 2008/06/12 20:47:04 djm Exp $ */
d34 1
a37 1
#include <stdarg.h>
@


1.85
log
@print extension revisions for extensions that we understand
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.84 2008/06/08 20:15:29 dtucker Exp $ */
d915 1
a915 1
	/* XXX: should we preserve set[ug]id? */
@


1.84
log
@Have the sftp client store the statvfs replies in wire format,
which prevents problems when the server's native sizes exceed the
client's.

Also extends the sizes of the remaining 32bit wire format to 64bit,
they're specified as unsigned long in the standard.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.83 2008/06/07 21:52:46 djm Exp $ */
d321 1
a322 1
		debug2("Init extension: \"%s\"", name);
d324 1
a324 1
		    strcmp(value, "1") == 0)
d326 3
a328 2
		if (strcmp(name, "statvfs@@openssh.com") == 0 &&
		    strcmp(value, "2") == 0)
d330 3
a332 2
		if (strcmp(name, "fstatvfs@@openssh.com") == 0 &&
		    strcmp(value, "2") == 0)
d334 8
@


1.83
log
@statvfs member fsid needs to be wider, increase it to 64 bits and
crank extension revision number to 2; prodded and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.82 2008/04/18 12:32:11 djm Exp $ */
d239 2
a240 1
get_decode_statvfs(int fd, struct statvfs *st, u_int expected_id, int quiet)
d269 2
a270 2
	st->f_bsize = buffer_get_int(&msg);
	st->f_frsize = buffer_get_int(&msg);
d278 2
a279 2
	flag = buffer_get_int(&msg);
	st->f_namemax = buffer_get_int(&msg);
d808 1
a808 1
do_statvfs(struct sftp_conn *conn, const char *path, struct statvfs *st,
d836 1
a836 1
    struct statvfs *st, int quiet)
@


1.82
log
@introduce sftp extension methods statvfs@@openssh.com and
fstatvfs@@openssh.com that implement statvfs(2)-like operations,
based on a patch from miklos AT szeredi.hu (bz#1399)

also add a "df" command to the sftp client that uses the
statvfs@@openssh.com to produce a df(1)-like display of filesystem
space and inode utilisation

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.81 2008/03/23 12:54:01 djm Exp $ */
d276 1
a276 1
	st->f_fsid = buffer_get_int(&msg);
d326 1
a326 1
		    strcmp(value, "1") == 0)
d329 1
a329 1
		    strcmp(value, "1") == 0)
@


1.81
log
@prefer POSIX-style file renaming over filexfer rename behaviour if the server
supports the posix-rename@@openssh.com extension.

Note that the old (filexfer) behaviour would refuse to clobber an existing
file. Users who depended on this should adjust their sftp(1) usage.

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.80 2008/01/21 19:20:17 djm Exp $ */
d28 1
d63 3
a65 1
#define SFTP_EXT_POSIX_RENAME	1
d238 50
d322 2
a323 1
		if (strcmp(name, "posix-rename@@openssh.com") == 0)
d325 6
d803 54
@


1.80
log
@when a remote write error occurs during an upload, ensure that ACKs for all
issued requests are properly drained. patch from t8m AT centrum.cz
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.79 2008/01/19 22:04:57 djm Exp $ */
d62 2
d238 1
a238 1
	u_int type;
d269 2
d284 1
d641 8
a648 2
	buffer_put_char(&msg, SSH2_FXP_RENAME);
	buffer_put_int(&msg, id);
d652 3
a654 2
	debug3("Sent message SSH2_FXP_RENAME \"%s\" -> \"%s\"", oldpath,
	    newpath);
@


1.79
log
@fix remote handle leak in do_download() local file open error path;
report and fix from sworley AT chkno.net
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.78 2008/01/11 07:22:27 chl Exp $ */
d990 2
a991 1
	int local_fd, status;
d1053 1
a1053 1
		return(-1);
d1073 1
a1073 1
		if (interrupted)
a1128 13

			if (status != SSH2_FX_OK) {
				error("Couldn't write to remote file \"%s\": %s",
				    remote_path, fx2txt(status));
				if (showprogress)
					stop_progress_meter();
				do_close(conn, handle, handle_len);
				close(local_fd);
				xfree(data);
				xfree(ack);
				status = -1;
				goto done;
			}
d1138 2
d1144 6
a1152 1
		do_close(conn, handle, handle_len);
a1153 1
		goto done;
d1160 3
a1162 1
	status = do_close(conn, handle, handle_len);
d1164 1
a1164 4
done:
	xfree(handle);
	buffer_free(&msg);
	return(status);
@


1.78
log
@disable unused functions

initially from tobias@@, but disabled them by placing them in "#ifdef notyet" which was asked by djm@@

ok djm@@ tobias@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.77 2007/09/16 00:55:52 djm Exp $ */
d820 1
@


1.77
log
@use off_t instead of u_int64_t for file offsets, matching what the
progressmeter code expects; bz #842
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.76 2007/01/22 11:32:50 djm Exp $ */
d531 1
d543 1
d685 1
d732 1
@


1.76
log
@return error from do_upload() when a write fails. fixes bz#1252: zero
exit status from sftp when uploading to a full device. report from
jirkat AT atlas.cz; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.75 2006/10/22 02:25:50 djm Exp $ */
d987 1
a987 1
	u_int64_t offset;
d997 1
a997 1
		u_int64_t offset;
d1136 2
a1137 2
			debug3("In write loop, ack for %u %u bytes at %llu",
			    ack->id, ack->len, (unsigned long long)ack->offset);
d1142 2
@


1.75
log
@cancel progress meter when upload write fails; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.74 2006/08/03 03:34:42 deraadt Exp $ */
d1133 1
@


1.74
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.73 2006/08/01 23:22:47 stevesk Exp $ */
d1127 2
@


1.74.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.75 2006/10/22 02:25:50 djm Exp $ */
a1126 2
				if (showprogress)
					stop_progress_meter();
@


1.73
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.72 2006/07/26 02:35:17 stevesk Exp $ */
d23 1
a23 2
#include "includes.h"

a24 1
#include <sys/types.h>
d28 1
d36 1
d38 1
a39 2
#include "bufaux.h"
#include "xmalloc.h"
d79 1
a79 1
	
@


1.72
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.71 2006/07/25 02:59:21 stevesk Exp $ */
d34 1
@


1.71
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.70 2006/07/23 01:11:05 stevesk Exp $ */
d29 1
@


1.70
log
@#include <signal.h> for sig_atomic_t; need this prior to <sys/param.h>
move
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.69 2006/07/22 20:48:23 stevesk Exp $ */
d28 1
@


1.69
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.68 2006/07/17 01:31:09 stevesk Exp $ */
d31 1
@


1.68
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.67 2006/07/11 20:07:25 stevesk Exp $ */
d31 1
@


1.67
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.66 2006/07/09 15:15:11 stevesk Exp $ */
d31 1
@


1.66
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.65 2006/04/16 00:54:10 djm Exp $ */
d29 1
@


1.65
log
@avoid making a tiny 4-byte write to send the packet length of sftp
commands, which would result in a separate tiny packet on the wire by
using atomiciov(writev, ...) to write the length and the command in one
pass; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.64 2006/03/30 09:58:16 djm Exp $ */
d28 2
@


1.64
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.63 2006/03/25 13:17:02 djm Exp $ */
d60 1
d67 6
a72 4
	if (atomicio(vwrite, fd, mlen, sizeof(mlen)) != sizeof(mlen))
		fatal("Couldn't send packet: %s", strerror(errno));

	if (atomicio(vwrite, fd, buffer_ptr(m), buffer_len(m)) != buffer_len(m))
@


1.63
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a30 1
#include "getput.h"
d35 1
d65 1
a65 1
	PUT_32BIT(mlen, buffer_len(m));
@


1.62
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.61
log
@RCSID() can die
@
text
@d392 1
a392 2
				*dir = xrealloc(*dir, sizeof(**dir) *
				    (ents + 2));
@


1.60
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@a22 1
RCSID("$OpenBSD: sftp-client.c,v 1.59 2006/02/15 05:08:24 david Exp $");
@


1.60.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sftp-client.c,v 1.74 2006/08/03 03:34:42 deraadt Exp $ */
d22 4
a26 1
#include <sys/queue.h>
a27 11
#include <sys/time.h>
#include <sys/param.h>
#include <sys/uio.h>

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
d29 3
a32 1
#include "buffer.h"
a35 1
#include "misc.h"
a59 1
	struct iovec iov[2];
d65 3
a67 5
	put_u32(mlen, buffer_len(m));
	iov[0].iov_base = mlen;
	iov[0].iov_len = sizeof(mlen);
	iov[1].iov_base = buffer_ptr(m);
	iov[1].iov_len = buffer_len(m);
d69 1
a69 1
	if (atomiciov(writev, fd, iov, 2) != buffer_len(m) + sizeof(mlen))
d393 2
a394 1
				*dir = xrealloc(*dir, ents + 2, sizeof(**dir));
@


1.60.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.75 2006/10/22 02:25:50 djm Exp $ */
a1126 2
				if (showprogress)
					stop_progress_meter();
@


1.59
log
@typo in comment; ok djm@@
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.58 2006/01/02 01:20:31 djm Exp $");
d26 2
@


1.58
log
@use a common max. packet length, no binary change
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.57 2005/07/27 10:39:03 dtucker Exp $");
d42 1
a42 1
/* Minimum amount of data to read at at time */
@


1.57
log
@Silence bogus -Wuninitialized warnings; ok djm@@
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.56 2005/07/17 07:17:55 djm Exp $");
a44 3
/* Maximum packet size */
#define MAX_MSG_LENGTH	(256 * 1024)

d59 1
a59 1
	if (buffer_len(m) > MAX_MSG_LENGTH)
d87 1
a87 1
	if (msg_len > MAX_MSG_LENGTH)
@


1.57.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.58 2006/01/02 01:20:31 djm Exp $");
d45 3
d62 1
a62 1
	if (buffer_len(m) > SFTP_MAX_MSG_LENGTH)
d90 1
a90 1
	if (msg_len > SFTP_MAX_MSG_LENGTH)
@


1.57.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sftp-client.c,v 1.74 2006/08/03 03:34:42 deraadt Exp $ */
d22 3
a24 1
#include <sys/types.h>
a25 12
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/param.h>
#include <sys/uio.h>

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
d27 3
a30 1
#include "buffer.h"
a33 1
#include "misc.h"
d42 1
a42 1
/* Minimum amount of data to read at a time */
a57 1
	struct iovec iov[2];
d63 3
a65 5
	put_u32(mlen, buffer_len(m));
	iov[0].iov_base = mlen;
	iov[0].iov_len = sizeof(mlen);
	iov[1].iov_base = buffer_ptr(m);
	iov[1].iov_len = buffer_len(m);
d67 1
a67 1
	if (atomiciov(writev, fd, iov, 2) != buffer_len(m) + sizeof(mlen))
d391 2
a392 1
				*dir = xrealloc(*dir, ents + 2, sizeof(**dir));
@


1.57.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-client.c,v 1.75 2006/10/22 02:25:50 djm Exp $ */
a1126 2
				if (showprogress)
					stop_progress_meter();
@


1.56
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.55 2005/06/17 02:44:33 djm Exp $");
d745 1
a745 1
	int local_fd, status, write_error;
@


1.55
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.54 2005/05/24 17:32:44 avsm Exp $");
d1125 1
a1125 1
			   ack->id, ack->len, (unsigned long long)ack->offset);
@


1.54
log
@Switch atomicio to use a simpler interface; it now returns a size_t
(containing number of bytes read/written), and indicates error by
returning 0.  EOF is signalled by errno==EPIPE.
Typical use now becomes:

if (atomicio(read, ..., len) != len)
        err(1,"read");

ok deraadt@@, cloder@@, djm@@
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.53 2005/03/10 22:01:05 deraadt Exp $");
d314 1
a314 1
	u_int type, id, handle_len, i, expected_id, ents = 0;
a337 2
		int count;

d745 1
a745 1
	int local_fd, status, num_req, max_req, write_error;
d748 1
a748 1
	u_int handle_len, mode, type, id, buflen;
@


1.53
log
@spacing
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.52 2004/11/25 22:22:14 markus Exp $");
d67 1
a67 1
	if (atomicio(vwrite, fd, mlen, sizeof(mlen)) <= 0)
d70 1
a70 1
	if (atomicio(vwrite, fd, buffer_ptr(m), buffer_len(m)) <= 0)
a78 1
	ssize_t len;
d82 6
a87 5
	len = atomicio(read, fd, buffer_ptr(m), 4);
	if (len == 0)
		fatal("Connection closed");
	else if (len == -1)
		fatal("Couldn't read packet: %s", strerror(errno));
d94 6
a99 5
	len = atomicio(read, fd, buffer_ptr(m), msg_len);
	if (len == 0)
		fatal("Connection closed");
	else if (len == -1)
		fatal("Read packet: %s", strerror(errno));
@


1.53.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.57 2005/07/27 10:39:03 dtucker Exp $");
d67 1
a67 1
	if (atomicio(vwrite, fd, mlen, sizeof(mlen)) != sizeof(mlen))
d70 1
a70 1
	if (atomicio(vwrite, fd, buffer_ptr(m), buffer_len(m)) != buffer_len(m))
d79 1
d83 5
a87 6
	if (atomicio(read, fd, buffer_ptr(m), 4) != 4) {
		if (errno == EPIPE)
			fatal("Connection closed");
		else
			fatal("Couldn't read packet: %s", strerror(errno));
	}
d94 5
a98 6
	if (atomicio(read, fd, buffer_ptr(m), msg_len) != msg_len) {
		if (errno == EPIPE)
			fatal("Connection closed");
		else
			fatal("Read packet: %s", strerror(errno));
	}
d313 1
a313 1
	u_int count, type, id, handle_len, i, expected_id, ents = 0;
d337 2
d746 1
a746 1
	int local_fd, status = 0, write_error;
d749 1
a749 1
	u_int handle_len, mode, type, id, buflen, num_req, max_req;
d1126 1
a1126 1
			    ack->id, ack->len, (unsigned long long)ack->offset);
@


1.53.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.58 2006/01/02 01:20:31 djm Exp $");
d45 3
d62 1
a62 1
	if (buffer_len(m) > SFTP_MAX_MSG_LENGTH)
d90 1
a90 1
	if (msg_len > SFTP_MAX_MSG_LENGTH)
@


1.52
log
@leak; from mpech
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.51 2004/07/11 17:48:47 deraadt Exp $");
d859 1
a859 1
		for(req = TAILQ_FIRST(&requests);
d1108 1
a1108 1
			for(ack = TAILQ_FIRST(&acks);
@


1.51
log
@spaces
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.50 2004/06/03 12:22:20 pedro Exp $");
d175 1
d210 1
@


1.51.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.52 2004/11/25 22:22:14 markus Exp $");
a174 1
		buffer_free(&msg);
a208 1
		buffer_free(&msg);
@


1.51.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.53 2005/03/10 22:01:05 deraadt Exp $");
d859 1
a859 1
		for (req = TAILQ_FIRST(&requests);
d1108 1
a1108 1
			for (ack = TAILQ_FIRST(&acks);
@


1.51.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.57 2005/07/27 10:39:03 dtucker Exp $");
d67 1
a67 1
	if (atomicio(vwrite, fd, mlen, sizeof(mlen)) != sizeof(mlen))
d70 1
a70 1
	if (atomicio(vwrite, fd, buffer_ptr(m), buffer_len(m)) != buffer_len(m))
d79 1
d83 5
a87 6
	if (atomicio(read, fd, buffer_ptr(m), 4) != 4) {
		if (errno == EPIPE)
			fatal("Connection closed");
		else
			fatal("Couldn't read packet: %s", strerror(errno));
	}
d94 5
a98 6
	if (atomicio(read, fd, buffer_ptr(m), msg_len) != msg_len) {
		if (errno == EPIPE)
			fatal("Connection closed");
		else
			fatal("Read packet: %s", strerror(errno));
	}
d313 1
a313 1
	u_int count, type, id, handle_len, i, expected_id, ents = 0;
d337 2
d746 1
a746 1
	int local_fd, status = 0, write_error;
d749 1
a749 1
	u_int handle_len, mode, type, id, buflen, num_req, max_req;
d1126 1
a1126 1
			    ack->id, ack->len, (unsigned long long)ack->offset);
@


1.50
log
@initialize pointers, ok markus@@
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.49 2004/05/19 12:17:33 djm Exp $");
d824 1
a824 1
		 * Simulate EOF on interrupt: stop sending new requests and 
d1052 1
a1052 1
		 * Can't use atomicio here because it returns 0 on EOF, 
d1054 1
a1054 1
		 * Simulate an EOF on interrupt, allowing ACKs from the 
@


1.49
log
@gracefully abort transfers on receipt of SIGINT, also ignore SIGINT while
waiting for a command; ok markus@@
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.48 2004/03/30 12:41:56 djm Exp $");
d991 1
a991 1
	struct outstanding_ack *ack;
@


1.48
log
@sync comment with reality
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.47 2004/03/03 09:30:42 djm Exp $");
d39 1
d334 1
a334 1
	for (;;) {
d411 7
d823 10
d920 1
a920 2
				}
				else if (max_req < conn->num_requests + 1) {
d1052 4
a1055 2
		 * Can't use atomicio here because it returns 0 on EOF, thus losing
		 * the last block of the file
d1057 3
a1059 1
		do
@


1.47
log
@Don't print duplicate messages when progressmeter is off
Spotted by job317 AT mailvault.com; ok markus@@
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.46 2004/02/17 05:39:51 djm Exp $");
d646 1
a646 1
	/* Send rename request */
@


1.47.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.51 2004/07/11 17:48:47 deraadt Exp $");
a38 1
extern volatile sig_atomic_t interrupted;
d333 1
a333 1
	for (; !interrupted;) {
a409 7
	/* Don't return partial matches on interrupt */
	if (interrupted && dir != NULL && *dir != NULL) {
		free_sftp_dirents(*dir);
		*dir = xmalloc(sizeof(**dir));
		**dir = NULL;
	}

d646 1
a646 1
	/* Send symlink request */
a814 10
		/*
		 * Simulate EOF on interrupt: stop sending new requests and
		 * allow outstanding requests to drain gracefully
		 */
		if (interrupted) {
			if (num_req == 0) /* If we haven't started yet... */
				break;
			max_req = 0;
		}

d902 2
a903 1
				} else if (max_req <= conn->num_requests) {
d974 1
a974 1
	struct outstanding_ack *ack = NULL;
d1035 2
a1036 4
		 * Can't use atomicio here because it returns 0 on EOF,
		 * thus losing the last block of the file.
		 * Simulate an EOF on interrupt, allowing ACKs from the
		 * server to drain.
d1038 1
a1038 3
		if (interrupted)
			len = 0;
		else do
@


1.47.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.52 2004/11/25 22:22:14 markus Exp $");
a174 1
		buffer_free(&msg);
a208 1
		buffer_free(&msg);
@


1.46
log
@switch to license.template for code written by me (belated, I know...)
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.45 2003/11/21 11:57:03 djm Exp $");
d808 2
a809 7
	if (showprogress) {
		if (size)
			start_progress_meter(remote_path, size,
			    &progress_counter);
		else
			printf("Fetching %s to %s\n", remote_path, local_path);
	}
a1029 2
	else
		printf("Uploading %s to %s\n", local_path, remote_path);
@


1.45
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2003 Damien Miller.  All rights reserved.
d4 3
a6 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d8 7
a14 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.44 2003/06/28 16:23:06 deraadt Exp $");
@


1.44
log
@deal with typing of write vs read in atomicio
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.43 2003/04/08 20:21:29 itojun Exp $");
d801 1
a801 1
	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC, 
@


1.44.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2004 Damien Miller <djm@@openbsd.org>
d4 8
a11 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d13 10
a22 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.46 2004/02/17 05:39:51 djm Exp $");
d801 1
a801 1
	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC,
@


1.44.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d23 1
a23 1
RCSID("$OpenBSD: sftp-client.c,v 1.51 2004/07/11 17:48:47 deraadt Exp $");
a38 1
extern volatile sig_atomic_t interrupted;
d333 1
a333 1
	for (; !interrupted;) {
a409 7
	/* Don't return partial matches on interrupt */
	if (interrupted && dir != NULL && *dir != NULL) {
		free_sftp_dirents(*dir);
		*dir = xmalloc(sizeof(**dir));
		**dir = NULL;
	}

d646 1
a646 1
	/* Send symlink request */
d808 7
a814 2
	if (showprogress && size != 0)
		start_progress_meter(remote_path, size, &progress_counter);
a819 10
		/*
		 * Simulate EOF on interrupt: stop sending new requests and
		 * allow outstanding requests to drain gracefully
		 */
		if (interrupted) {
			if (num_req == 0) /* If we haven't started yet... */
				break;
			max_req = 0;
		}

d907 2
a908 1
				} else if (max_req <= conn->num_requests) {
d979 1
a979 1
	struct outstanding_ack *ack = NULL;
d1035 2
d1042 2
a1043 4
		 * Can't use atomicio here because it returns 0 on EOF,
		 * thus losing the last block of the file.
		 * Simulate an EOF on interrupt, allowing ACKs from the
		 * server to drain.
d1045 1
a1045 3
		if (interrupted)
			len = 0;
		else do
@


1.43
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.42 2003/03/05 22:33:43 markus Exp $");
d74 1
a74 1
	if (atomicio(write, fd, mlen, sizeof(mlen)) <= 0)
d77 1
a77 1
	if (atomicio(write, fd, buffer_ptr(m), buffer_len(m)) <= 0)
d878 1
a878 1
			    atomicio(write, local_fd, data, len) != len) &&
@


1.42
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.41 2003/01/14 10:58:00 djm Exp $");
d510 1
a510 1
			log("Server version does not support lstat operation");
@


1.42.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.44 2003/06/28 16:23:06 deraadt Exp $");
d74 1
a74 1
	if (atomicio(vwrite, fd, mlen, sizeof(mlen)) <= 0)
d77 1
a77 1
	if (atomicio(vwrite, fd, buffer_ptr(m), buffer_len(m)) <= 0)
d510 1
a510 1
			logit("Server version does not support lstat operation");
d878 1
a878 1
			    atomicio(vwrite, local_fd, data, len) != len) &&
@


1.42.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2004 Damien Miller <djm@@openbsd.org>
d4 8
a11 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d13 10
a22 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.46 2004/02/17 05:39:51 djm Exp $");
d801 1
a801 1
	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC,
@


1.41
log
@Don't try to upload or download non-regular files. Report from
apoloval@@pantuflo.escet.urjc.es; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.40 2003/01/10 08:48:15 djm Exp $");
d377 1
d1113 2
@


1.40
log
@Simplify and avoid redundancy in packet send and receive function; ok fgs@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.39 2003/01/10 08:19:07 fgsch Exp $");
d770 2
a771 2
	    (a->perm & S_IFDIR)) {
		error("Cannot download a directory: %s", remote_path);
d998 5
@


1.39
log
@sftp progress meter support.
original diffs by Nils Nordman <nino at nforced dot com> via markus@@, merged
to -current by me, djm@@ ok.
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.37 2002/11/21 23:03:51 deraadt Exp $");
d52 3
d67 9
a75 8
	int mlen = buffer_len(m);
	int len;
	Buffer oqueue;

	buffer_init(&oqueue);
	buffer_put_int(&oqueue, mlen);
	buffer_append(&oqueue, buffer_ptr(m), mlen);
	buffer_consume(m, mlen);
d77 1
a77 2
	len = atomicio(write, fd, buffer_ptr(&oqueue), buffer_len(&oqueue));
	if (len <= 0)
d80 1
a80 1
	buffer_free(&oqueue);
d86 2
a87 2
	u_int len, msg_len;
	unsigned char buf[4096];
d89 2
a90 1
	len = atomicio(read, fd, buf, 4);
d96 2
a97 2
	msg_len = GET_32BIT(buf);
	if (msg_len > 256 * 1024)
d100 6
a105 10
	while (msg_len) {
		len = atomicio(read, fd, buf, MIN(msg_len, sizeof(buf)));
		if (len == 0)
			fatal("Connection closed");
		else if (len == -1)
			fatal("Couldn't read packet: %s", strerror(errno));

		msg_len -= len;
		buffer_append(m, buf, len);
	}
@


1.38
log
@Fix "get -p" download to not add user-write perm. mindrot bug #426 reported
by gfernandez@@livevault.com; ok markus@@
@
text
@d41 1
d47 2
d747 1
d813 10
d883 1
d926 3
d1035 5
d1116 2
@


1.37
log
@KNF
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.36 2002/11/05 20:10:37 markus Exp $");
d761 1
a761 1
		mode = S_IWRITE | (a->perm & 0777);
d796 2
a797 1
	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC, mode);
@


1.36
log
@typo; GaryF@@livevault.com
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.35 2002/09/11 22:41:49 djm Exp $");
d860 1
a860 1
				      "%u > %u", len, req->len);
d862 1
a862 1
			     atomicio(write, local_fd, data, len) != len) &&
d929 1
a929 1
			      strerror(errno));
d937 1
a937 1
				      local_path, strerror(errno));
d1046 1
a1046 1
			       id, (unsigned long long)offset, len);
d1080 1
a1080 1
				      remote_path, fx2txt(status));
@


1.35
log
@support for short/long listings and globbing in "ls"; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.34 2002/06/27 10:35:47 deraadt Exp $");
d663 1
a663 1
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath,
@


1.35.2.1
log
@Update to OpenSSH 3.6
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2003 Damien Miller.  All rights reserved.
d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.42 2003/03/05 22:33:43 markus Exp $");
a40 1
#include "progressmeter.h"
a45 2
extern int showprogress;

a48 3
/* Maximum packet size */
#define MAX_MSG_LENGTH	(256 * 1024)

d61 8
a68 4
	u_char mlen[4];

	if (buffer_len(m) > MAX_MSG_LENGTH)
		fatal("Outbound message too long %u", buffer_len(m));
d70 2
a71 3
	/* Send length first */
	PUT_32BIT(mlen, buffer_len(m));
	if (atomicio(write, fd, mlen, sizeof(mlen)) <= 0)
d74 1
a74 4
	if (atomicio(write, fd, buffer_ptr(m), buffer_len(m)) <= 0)
		fatal("Couldn't send packet: %s", strerror(errno));

	buffer_clear(m);
d80 2
a81 2
	ssize_t len;
	u_int msg_len;
d83 1
a83 2
	buffer_append_space(m, 4);
	len = atomicio(read, fd, buffer_ptr(m), 4);
d89 2
a90 2
	msg_len = buffer_get_int(m);
	if (msg_len > MAX_MSG_LENGTH)
d93 10
a102 6
	buffer_append_space(m, msg_len);
	len = atomicio(read, fd, buffer_ptr(m), msg_len);
	if (len == 0)
		fatal("Connection closed");
	else if (len == -1)
		fatal("Read packet: %s", strerror(errno));
a373 1
				xfree(handle);
d663 1
a663 1
		error("Couldn't symlink file \"%s\" to \"%s\": %s", oldpath,
a743 1
	off_t progress_counter;
d761 1
a761 1
		mode = a->perm & 0777;
d766 2
a767 2
	    (!S_ISREG(a->perm))) {
		error("Cannot download non-regular file: %s", remote_path);
d796 1
a796 2
	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC, 
	    mode | S_IWRITE);
a807 10
	progress_counter = 0;

	if (showprogress) {
		if (size)
			start_progress_meter(remote_path, size,
			    &progress_counter);
		else
			printf("Fetching %s to %s\n", remote_path, local_path);
	}

d860 1
a860 1
				    "%u > %u", len, req->len);
d862 1
a862 1
			    atomicio(write, local_fd, data, len) != len) &&
a867 1
			progress_counter += len;
a909 3
	if (showprogress && size)
		stop_progress_meter();

d929 1
a929 1
			    strerror(errno));
d937 1
a937 1
				    local_path, strerror(errno));
a981 5
	if (!S_ISREG(sb.st_mode)) {
		error("%s is not a regular file", local_path);
		close(local_fd);
		return(-1);
	}
a1015 5
	if (showprogress)
		start_progress_meter(local_path, sb.st_size, &offset);
	else
		printf("Uploading %s to %s\n", local_path, remote_path);

d1046 1
a1046 1
			    id, (unsigned long long)offset, len);
d1080 1
a1080 1
				    remote_path, fx2txt(status));
a1082 2
				xfree(data);
				xfree(ack);
a1091 2
	if (showprogress)
		stop_progress_meter();
@


1.35.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.44 2003/06/28 16:23:06 deraadt Exp $");
d74 1
a74 1
	if (atomicio(vwrite, fd, mlen, sizeof(mlen)) <= 0)
d77 1
a77 1
	if (atomicio(vwrite, fd, buffer_ptr(m), buffer_len(m)) <= 0)
d510 1
a510 1
			logit("Server version does not support lstat operation");
d878 1
a878 1
			    atomicio(vwrite, local_fd, data, len) != len) &&
@


1.34
log
@use xfree()
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.33 2002/06/23 09:30:14 deraadt Exp $");
a414 6
}

int
do_ls(struct sftp_conn *conn, char *path)
{
	return(do_lsreaddir(conn, path, 1, NULL));
@


1.33
log
@bunch of u_int vs int stuff
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.32 2002/06/09 13:32:01 markus Exp $");
d1094 1
a1094 1
			free(ack);
@


1.32
log
@use tab not spaces (|unexpand)
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.31 2002/04/06 00:30:08 djm Exp $");
d91 1
a91 1
		fatal("Received message too long %d", msg_len);
d116 1
a116 1
	debug3("Sent message fd %d T:%d I:%d", fd, code, id);
d132 1
a132 1
	debug3("Sent message fd %d T:%d I:%d", fd, code, id);
d137 1
a137 1
get_status(int fd, int expected_id)
d148 1
a148 1
		fatal("ID mismatch (%d != %d)", id, expected_id);
d150 1
a150 1
		fatal("Expected SSH2_FXP_STATUS(%d) packet, got %d",
d156 1
a156 1
	debug3("SSH2_FXP_STATUS %d", status);
d174 1
a174 1
		fatal("ID mismatch (%d != %d)", id, expected_id);
d181 1
a181 1
		fatal("Expected SSH2_FXP_HANDLE(%d) packet, got %d",
d203 1
a203 1
	debug3("Received stat reply T:%d I:%d", type, id);
d205 1
a205 1
		fatal("ID mismatch (%d != %d)", id, expected_id);
d215 1
a215 1
		fatal("Expected SSH2_FXP_ATTRS(%d) packet, got %d",
d227 2
a228 1
	int type, version;
d243 1
a243 1
		error("Invalid packet back from SSH2_FXP_INIT (type %d)",
d298 1
a298 1
	debug3("Sent message SSH2_FXP_CLOSE I:%d", id);
d343 1
a343 1
		debug3("Sending SSH2_FXP_READDIR I:%d", id);
d358 1
a358 1
		debug3("Received reply T:%d I:%d", type, id);
d361 1
a361 1
			fatal("ID mismatch (%d != %d)", id, expected_id);
d377 1
a377 1
			fatal("Expected SSH2_FXP_NAME(%d) packet, got %d",
d588 1
a588 1
		fatal("ID mismatch (%d != %d)", id, expected_id);
d596 1
a596 1
		fatal("Expected SSH2_FXP_NAME(%d) packet, got %d",
d694 1
a694 1
		fatal("ID mismatch (%d != %d)", id, expected_id);
d702 1
a702 1
		fatal("Expected SSH2_FXP_NAME(%d) packet, got %d",
d794 1
a794 1
	debug3("Sent message SSH2_FXP_OPEN I:%d P:%s", id, remote_path);
d839 1
a839 1
		debug3("Received reply T:%d I:%d R:%d", type, id, max_req);
d866 1
a866 1
				      "%d > %d", len, req->len);
d911 1
a911 1
			fatal("Expected SSH2_FXP_DATA(%d) packet, got %d",
d1006 1
a1006 1
	debug3("Sent message SSH2_FXP_OPEN I:%d P:%s", id, remote_path);
d1051 1
a1051 1
			debug3("Sent message SSH2_FXP_WRITE I:%d O:%llu S:%u",
d1081 1
a1081 1
				fatal("Can't find request for ID %d", r_id);
d1091 1
a1091 1
			debug3("In write loop, ack for %u %d bytes at %llu",
@


1.31
log
@Fix occasional corruption on upload due to bad reuse of request id, spotted
by chombier@@mac.com; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.30 2002/04/01 22:07:17 markus Exp $");
d1060 1
a1060 1
		    	u_int r_id;
@


1.31.2.1
log
@Pull in OpenSSH-3.4
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.33 2002/06/23 09:30:14 deraadt Exp $");
d91 1
a91 1
		fatal("Received message too long %u", msg_len);
d116 1
a116 1
	debug3("Sent message fd %d T:%u I:%u", fd, code, id);
d132 1
a132 1
	debug3("Sent message fd %d T:%u I:%u", fd, code, id);
d137 1
a137 1
get_status(int fd, u_int expected_id)
d148 1
a148 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d150 1
a150 1
		fatal("Expected SSH2_FXP_STATUS(%u) packet, got %u",
d156 1
a156 1
	debug3("SSH2_FXP_STATUS %u", status);
d174 1
a174 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d181 1
a181 1
		fatal("Expected SSH2_FXP_HANDLE(%u) packet, got %u",
d203 1
a203 1
	debug3("Received stat reply T:%u I:%u", type, id);
d205 1
a205 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d215 1
a215 1
		fatal("Expected SSH2_FXP_ATTRS(%u) packet, got %u",
d227 1
a227 2
	u_int type;
	int version;
d242 1
a242 1
		error("Invalid packet back from SSH2_FXP_INIT (type %u)",
d297 1
a297 1
	debug3("Sent message SSH2_FXP_CLOSE I:%u", id);
d342 1
a342 1
		debug3("Sending SSH2_FXP_READDIR I:%u", id);
d357 1
a357 1
		debug3("Received reply T:%u I:%u", type, id);
d360 1
a360 1
			fatal("ID mismatch (%u != %u)", id, expected_id);
d376 1
a376 1
			fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
d587 1
a587 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d595 1
a595 1
		fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
d693 1
a693 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d701 1
a701 1
		fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
d793 1
a793 1
	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);
d838 1
a838 1
		debug3("Received reply T:%u I:%u R:%d", type, id, max_req);
d865 1
a865 1
				      "%u > %u", len, req->len);
d910 1
a910 1
			fatal("Expected SSH2_FXP_DATA(%u) packet, got %u",
d1005 1
a1005 1
	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);
d1050 1
a1050 1
			debug3("Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u",
d1060 1
a1060 1
			u_int r_id;
d1080 1
a1080 1
				fatal("Can't find request for ID %u", r_id);
d1090 1
a1090 1
			debug3("In write loop, ack for %u %u bytes at %llu",
@


1.31.2.2
log
@Update to OpenSSH 3.5
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.35 2002/09/11 22:41:49 djm Exp $");
d418 6
d1094 1
a1094 1
			xfree(ack);
@


1.31.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2003 Damien Miller.  All rights reserved.
d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.42 2003/03/05 22:33:43 markus Exp $");
a40 1
#include "progressmeter.h"
a45 2
extern int showprogress;

a48 3
/* Maximum packet size */
#define MAX_MSG_LENGTH	(256 * 1024)

d61 8
a68 4
	u_char mlen[4];

	if (buffer_len(m) > MAX_MSG_LENGTH)
		fatal("Outbound message too long %u", buffer_len(m));
d70 2
a71 3
	/* Send length first */
	PUT_32BIT(mlen, buffer_len(m));
	if (atomicio(write, fd, mlen, sizeof(mlen)) <= 0)
d74 1
a74 4
	if (atomicio(write, fd, buffer_ptr(m), buffer_len(m)) <= 0)
		fatal("Couldn't send packet: %s", strerror(errno));

	buffer_clear(m);
d80 2
a81 2
	ssize_t len;
	u_int msg_len;
d83 1
a83 2
	buffer_append_space(m, 4);
	len = atomicio(read, fd, buffer_ptr(m), 4);
d89 2
a90 2
	msg_len = buffer_get_int(m);
	if (msg_len > MAX_MSG_LENGTH)
d93 10
a102 6
	buffer_append_space(m, msg_len);
	len = atomicio(read, fd, buffer_ptr(m), msg_len);
	if (len == 0)
		fatal("Connection closed");
	else if (len == -1)
		fatal("Read packet: %s", strerror(errno));
a373 1
				xfree(handle);
d663 1
a663 1
		error("Couldn't symlink file \"%s\" to \"%s\": %s", oldpath,
a743 1
	off_t progress_counter;
d761 1
a761 1
		mode = a->perm & 0777;
d766 2
a767 2
	    (!S_ISREG(a->perm))) {
		error("Cannot download non-regular file: %s", remote_path);
d796 1
a796 2
	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC, 
	    mode | S_IWRITE);
a807 10
	progress_counter = 0;

	if (showprogress) {
		if (size)
			start_progress_meter(remote_path, size,
			    &progress_counter);
		else
			printf("Fetching %s to %s\n", remote_path, local_path);
	}

d860 1
a860 1
				    "%u > %u", len, req->len);
d862 1
a862 1
			    atomicio(write, local_fd, data, len) != len) &&
a867 1
			progress_counter += len;
a909 3
	if (showprogress && size)
		stop_progress_meter();

d929 1
a929 1
			    strerror(errno));
d937 1
a937 1
				    local_path, strerror(errno));
a981 5
	if (!S_ISREG(sb.st_mode)) {
		error("%s is not a regular file", local_path);
		close(local_fd);
		return(-1);
	}
a1015 5
	if (showprogress)
		start_progress_meter(local_path, sb.st_size, &offset);
	else
		printf("Uploading %s to %s\n", local_path, remote_path);

d1046 1
a1046 1
			    id, (unsigned long long)offset, len);
d1080 1
a1080 1
				    remote_path, fx2txt(status));
a1082 2
				xfree(data);
				xfree(ack);
a1091 2
	if (showprogress)
		stop_progress_meter();
@


1.30
log
@fallback to stat if server does not support lstat
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.29 2002/04/01 22:02:16 markus Exp $");
d1060 2
d1065 1
a1065 1
			id = buffer_get_int(&msg);
d1076 1
a1076 1
			    ack != NULL && ack->id != id;
d1080 1
a1080 1
				fatal("Can't find request for ID %d", id);
@


1.29
log
@20480 is an upper limit for older server
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.28 2002/03/19 10:49:35 markus Exp $");
d511 2
a512 2
			error("Server version does not support lstat operation");
		return(NULL);
@


1.28
log
@KNF whitespace
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.27 2002/03/11 03:19:53 itojun Exp $");
d273 1
a273 1
		ret->transfer_buflen = MAX(ret->transfer_buflen, 20480);
@


1.27
log
@indent
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.26 2002/03/11 03:18:49 itojun Exp $");
d448 1
a448 1
	send_string_request(conn->fd_out, id, SSH2_FXP_REMOVE, path, 
d495 2
a496 2
	send_string_request(conn->fd_out, id, 
	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT, 
d726 1
a726 1
	
d736 1
a736 1
}	
d753 1
a753 1
		TAILQ_ENTRY(request) tq; 
d819 1
a819 1
			debug3("Request range %llu -> %llu (%d/%d)", 
d830 1
a830 1
			send_read_request(conn->fd_out, req->id, req->offset, 
d861 1
a861 1
			    (unsigned long long)req->offset, 
d883 1
a883 1
				    (unsigned long long)req->offset + len, 
d889 1
a889 1
				send_read_request(conn->fd_out, req->id, 
d920 1
a920 1
		error("Couldn't read from remote file \"%s\" : %s", 
d969 1
a969 1
		TAILQ_ENTRY(outstanding_ack) tq; 
d1058 1
a1058 1
		if (id == startid || len == 0 || 
d1088 1
a1088 1
			debug3("In write loop, ack for %u %d bytes at %llu", 
@


1.26
log
@correct type mismatches (u_int64_t != unsigned long long)
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.25 2002/03/08 06:10:16 itojun Exp $");
d883 3
a885 3
				        (unsigned long long)req->offset + len, 
					(unsigned long long)req->offset + req->len - 1,
					num_req);
@


1.25
log
@printf type mismatch
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.24 2002/02/24 16:57:19 markus Exp $");
d860 3
a862 2
			debug3("Received data %llu -> %llu", req->offset, 
			    req->offset + len - 1);
d882 4
a885 2
				    "%llu -> %llu (%2d)", req->offset + len, 
					req->offset + req->len - 1, num_req);
d900 2
a901 1
					    offset, num_req);
d1051 1
a1051 1
			       id, (u_int64_t)offset, len);
d1089 1
a1089 1
			   ack->id, ack->len, ack->offset);
@


1.24
log
@early close(), missing free; ok stevesk@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.23 2002/02/13 00:59:23 djm Exp $");
d820 3
a822 1
			    offset, offset + buflen - 1, num_req, max_req);
@


1.23
log
@API cleanup and backwards compat for filexfer v.0 servers; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.22 2002/02/12 12:44:46 djm Exp $");
a797 1
		close(local_fd);
d805 2
@


1.22
log
@Let overlapped upload path handle servers which reorder ACKs. This may be
permitted by the protocol spec; ok markus@@
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2002 Damien Miller.  All rights reserved.
d27 1
a27 1
/* XXX: we use fatal too much, error may be more appropriate in places */
d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.21 2002/02/12 12:32:27 djm Exp $");
d49 8
a56 2
/* Message ID */
static u_int msg_id = 1;
d224 2
a225 2
int
do_init(int fd_in, int fd_out)
d229 1
d245 1
a245 1
		return(-1);
d263 19
a281 1
	return(version);
d285 1
a285 1
do_close(int fd_in, int fd_out, char *handle, u_int handle_len)
d292 1
a292 1
	id = msg_id++;
d296 1
a296 1
	send_msg(fd_out, &msg);
d299 1
a299 1
	status = get_status(fd_in, id);
d310 1
a310 1
do_lsreaddir(int fd_in, int fd_out, char *path, int printflag,
d317 1
a317 1
	id = msg_id++;
d323 1
a323 1
	send_msg(fd_out, &msg);
d327 1
a327 1
	handle = get_handle(fd_in, id, &handle_len);
d340 1
a340 1
		id = expected_id = msg_id++;
d348 1
a348 1
		send_msg(fd_out, &msg);
d352 1
a352 1
		get_msg(fd_in, &msg);
d372 1
a372 1
				do_close(fd_in, fd_out, handle, handle_len);
d410 1
a410 1
	do_close(fd_in, fd_out, handle, handle_len);
d417 1
a417 1
do_ls(int fd_in, int fd_out, char *path)
d419 1
a419 1
	return(do_lsreaddir(fd_in, fd_out, path, 1, NULL));
d423 1
a423 1
do_readdir(int fd_in, int fd_out, char *path, SFTP_DIRENT ***dir)
d425 1
a425 1
	return(do_lsreaddir(fd_in, fd_out, path, 0, dir));
d441 1
a441 1
do_rm(int fd_in, int fd_out, char *path)
d447 4
a450 3
	id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_REMOVE, path, strlen(path));
	status = get_status(fd_in, id);
d457 1
a457 1
do_mkdir(int fd_in, int fd_out, char *path, Attrib *a)
d461 2
a462 2
	id = msg_id++;
	send_string_attrs_request(fd_out, id, SSH2_FXP_MKDIR, path,
d465 1
a465 1
	status = get_status(fd_in, id);
d473 1
a473 1
do_rmdir(int fd_in, int fd_out, char *path)
d477 3
a479 2
	id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_RMDIR, path, strlen(path));
d481 1
a481 1
	status = get_status(fd_in, id);
d489 1
a489 1
do_stat(int fd_in, int fd_out, char *path, int quiet)
d493 7
a499 3
	id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_STAT, path, strlen(path));
	return(get_decode_stat(fd_in, id, quiet));
d503 1
a503 1
do_lstat(int fd_in, int fd_out, char *path, int quiet)
d507 13
a519 3
	id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_LSTAT, path, strlen(path));
	return(get_decode_stat(fd_in, id, quiet));
d523 1
a523 1
do_fstat(int fd_in, int fd_out, char *handle, u_int handle_len, int quiet)
d527 5
a531 3
	id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_FSTAT, handle, handle_len);
	return(get_decode_stat(fd_in, id, quiet));
d535 1
a535 1
do_setstat(int fd_in, int fd_out, char *path, Attrib *a)
d539 2
a540 2
	id = msg_id++;
	send_string_attrs_request(fd_out, id, SSH2_FXP_SETSTAT, path,
d543 1
a543 1
	status = get_status(fd_in, id);
d552 1
a552 1
do_fsetstat(int fd_in, int fd_out, char *handle, u_int handle_len,
d557 2
a558 2
	id = msg_id++;
	send_string_attrs_request(fd_out, id, SSH2_FXP_FSETSTAT, handle,
d561 1
a561 1
	status = get_status(fd_in, id);
d569 1
a569 1
do_realpath(int fd_in, int fd_out, char *path)
d576 3
a578 2
	expected_id = id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_REALPATH, path, strlen(path));
d582 1
a582 1
	get_msg(fd_in, &msg);
d616 1
a616 1
do_rename(int fd_in, int fd_out, char *oldpath, char *newpath)
d624 1
a624 1
	id = msg_id++;
d629 1
a629 1
	send_msg(fd_out, &msg);
d634 1
a634 1
	status = get_status(fd_in, id);
d636 2
a637 2
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath, newpath,
		    fx2txt(status));
d643 1
a643 1
do_symlink(int fd_in, int fd_out, char *oldpath, char *newpath)
d648 5
d656 1
a656 1
	id = msg_id++;
d661 1
a661 1
	send_msg(fd_out, &msg);
d666 1
a666 1
	status = get_status(fd_in, id);
d668 2
a669 2
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath, newpath,
		    fx2txt(status));
d675 1
a675 1
do_readlink(int fd_in, int fd_out, char *path)
d682 3
a684 2
	expected_id = id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_READLINK, path, strlen(path));
d688 1
a688 1
	get_msg(fd_in, &msg);
d739 2
a740 2
do_download(int fd_in, int fd_out, char *remote_path, char *local_path,
    int pflag, size_t buflen, int num_requests)
d748 1
a748 1
	u_int handle_len, mode, type, id;
d760 1
a760 1
	a = do_stat(fd_in, fd_out, remote_path, 0);
d781 1
a781 7
	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC, mode);
	if (local_fd == -1) {
		error("Couldn't open local file \"%s\" for writing: %s",
		    local_path, strerror(errno));
		return(-1);
	}

d785 1
a785 1
	id = msg_id++;
d792 1
a792 1
	send_msg(fd_out, &msg);
d795 1
a795 1
	handle = get_handle(fd_in, id, &handle_len);
d802 7
d821 1
a821 1
			req->id = msg_id++;
d827 1
a827 1
			send_read_request(fd_out, req->id, req->offset, 
d832 1
a832 1
		get_msg(fd_in, &msg);
d880 1
a880 1
				req->id = msg_id++;
d883 2
a884 3
				send_read_request(fd_out, req->id, 
				    req->offset, req->len, handle, 
				    handle_len);
d897 1
a897 1
				else if (max_req < num_requests + 1) {
d915 1
a915 1
		do_close(fd_in, fd_out, handle, handle_len);
d920 1
a920 1
		do_close(fd_in, fd_out, handle, handle_len);
d922 1
a922 1
		status = do_close(fd_in, fd_out, handle, handle_len);
d941 2
a942 1
	return status;
d946 2
a947 2
do_upload(int fd_in, int fd_out, char *local_path, char *remote_path,
    int pflag, size_t buflen, int num_requests)
d991 1
a991 1
	id = msg_id++;
d997 1
a997 1
	send_msg(fd_out, &msg);
d1002 1
a1002 1
	handle = get_handle(fd_in, id, &handle_len);
d1010 1
a1010 1
	data = xmalloc(buflen);
d1022 1
a1022 1
			len = read(local_fd, data, buflen);
d1042 1
a1042 1
			send_msg(fd_out, &msg);
d1051 2
a1052 1
		if (id == startid || len == 0 || id - ackid >= num_requests) {
d1054 1
a1054 1
			get_msg(fd_in, &msg);
d1077 1
a1077 1
				do_close(fd_in, fd_out, handle, handle_len);
a1085 1

d1093 1
a1093 1
		do_close(fd_in, fd_out, handle, handle_len);
d1100 1
a1100 1
		do_fsetstat(fd_in, fd_out, handle, handle_len, &a);
d1102 1
a1102 1
	status = do_close(fd_in, fd_out, handle, handle_len);
d1107 1
a1107 1
	return status;
@


1.21
log
@Perform multiple overlapping read/write requests in file transfer. Mostly
done by Tobias Ringstrom <tori@@ringstrom.mine.nu>; ok markus@@
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.20 2002/02/05 00:00:46 djm Exp $");
d899 1
a899 1
	u_int handle_len, id;
d907 10
d979 6
d987 1
a987 1
			buffer_put_int(&msg, ++id);
d994 1
a994 1
		} else if ( id < ackid )
d997 25
a1021 3
		if (id == startid || len == 0 ||
		    id - ackid >= num_requests) {
			status = get_status(fd_in, ackid);
d1029 2
a1030 2
			debug3("In write loop, got %d offset %llu", len,
			       (u_int64_t)offset);
d1032 1
@


1.20
log
@Add "-B" option to specify copy buffer length (default 32k); ok markus@@
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Damien Miller.  All rights reserved.
a26 1
/* XXX: redesign to allow concurrent overlapped operations */
d31 3
a33 1
RCSID("$OpenBSD: sftp-client.c,v 1.19 2001/12/19 07:18:56 deraadt Exp $");
d46 3
d671 17
d690 1
a690 1
    int pflag, size_t buflen)
d692 2
a693 3
	int local_fd, status;
	u_int expected_id, handle_len, mode, type, id;
	u_int64_t offset;
d695 14
a708 2
	Buffer msg;
	Attrib junk, *a;
d726 5
d759 4
a762 2
	offset = 0;
	for (;;) {
a763 1
		char *data;
d765 14
a778 1
		id = expected_id = msg_id++;
a780 11
		buffer_put_char(&msg, SSH2_FXP_READ);
		buffer_put_int(&msg, id);
		buffer_put_string(&msg, handle, handle_len);
		buffer_put_int64(&msg, offset);
		buffer_put_int(&msg, buflen);
		send_msg(fd_out, &msg);
		debug3("Sent message SSH2_FXP_READ I:%d O:%llu S:%u",
		    id, (unsigned long long)offset, buflen);

		buffer_clear(&msg);

d784 12
a795 4
		debug3("Received reply T:%d I:%d", type, id);
		if (id != expected_id)
			fatal("ID mismatch (%d != %d)", id, expected_id);
		if (type == SSH2_FXP_STATUS) {
d797 22
d820 30
a849 8
			if (status == SSH2_FX_EOF)
				break;
			else {
				error("Couldn't read from remote "
				    "file \"%s\" : %s", remote_path,
				    fx2txt(status));
				do_close(fd_in, fd_out, handle, handle_len);
				goto done;
d851 2
a852 1
		} else if (type != SSH2_FXP_DATA) {
d856 1
d858 28
a885 14
		data = buffer_get_string(&msg, &len);
		if (len > buflen)
			fatal("Received more data than asked for %d > %d",
			    len, buflen);

		debug3("In read loop, got %d offset %llu", len,
		    (unsigned long long)offset);
		if (atomicio(write, local_fd, data, len) != len) {
			error("Couldn't write to \"%s\": %s", local_path,
			    strerror(errno));
			do_close(fd_in, fd_out, handle, handle_len);
			status = -1;
			xfree(data);
			goto done;
a886 18

		offset += len;
		xfree(data);
	}
	status = do_close(fd_in, fd_out, handle, handle_len);

	/* Override umask and utimes if asked */
	if (pflag && fchmod(local_fd, mode) == -1)
		error("Couldn't set mode on \"%s\": %s", local_path,
		    strerror(errno));
	if (pflag && (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {
		struct timeval tv[2];
		tv[0].tv_sec = a->atime;
		tv[1].tv_sec = a->mtime;
		tv[0].tv_usec = tv[1].tv_usec = 0;
		if (utimes(local_path, tv) == -1)
			error("Can't set times on \"%s\": %s", local_path,
			    strerror(errno));
a887 2

done:
d896 1
a896 1
    int pflag, size_t buflen)
d905 2
d948 1
d967 12
a978 1
		if (len == 0)
d981 13
a993 17
		buffer_clear(&msg);
		buffer_put_char(&msg, SSH2_FXP_WRITE);
		buffer_put_int(&msg, ++id);
		buffer_put_string(&msg, handle, handle_len);
		buffer_put_int64(&msg, offset);
		buffer_put_string(&msg, data, len);
		send_msg(fd_out, &msg);
		debug3("Sent message SSH2_FXP_WRITE I:%d O:%llu S:%u",
		    id, (unsigned long long)offset, len);

		status = get_status(fd_in, id);
		if (status != SSH2_FX_OK) {
			error("Couldn't write to remote file \"%s\": %s",
			    remote_path, fx2txt(status));
			do_close(fd_in, fd_out, handle, handle_len);
			close(local_fd);
			goto done;
a994 2
		debug3("In write loop, got %d offset %llu", len,
		    (unsigned long long)offset);
a1018 1

@


1.19
log
@basic KNF done while i was looking for something else
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.18 2001/07/14 15:10:16 stevesk Exp $");
a44 4
/* How much data to read/write at at time during copies */
/* XXX: what should this be? */
#define COPY_SIZE	8192

d669 1
a669 1
    int pflag)
d671 1
a671 1
	int local_fd;
a676 1
	int status;
d734 1
a734 1
		buffer_put_int(&msg, COPY_SIZE);
d737 1
a737 1
		    id, (unsigned long long)offset, COPY_SIZE);
d765 1
a765 1
		if (len > COPY_SIZE)
d767 1
a767 1
			    len, COPY_SIZE);
d808 1
a808 1
    int pflag)
d810 1
a810 1
	int local_fd;
d813 1
a813 1
	char *handle;
a816 1
	int status;
d858 2
a863 1
		char data[COPY_SIZE];
d870 1
a870 1
			len = read(local_fd, data, COPY_SIZE);
d902 1
@


1.18
log
@delete spurious #includes; ok deraadt@@ markus@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.17 2001/06/23 15:12:20 itojun Exp $");
a310 1
	
d312 1
a312 1
	for(;;) {
d358 1
a358 1
		for(i = 0; i < count; i++) {
d406 2
a407 2
	
	for(i = 0; s[i]; i++) {
d728 1
a728 1
	for(;;) {
d760 1
a760 1
				     fx2txt(status));
d866 1
a866 1
	for(;;) {
@


1.18.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d27 2
a28 1
/* XXX: remove all logging, only return status codes */
d32 1
a32 3
RCSID("$OpenBSD: sftp-client.c,v 1.24 2002/02/24 16:57:19 markus Exp $");

#include <sys/queue.h>
d45 3
a47 2
/* Minimum amount of data to read at at time */
#define MIN_READ_SIZE	512
d49 2
a50 8
struct sftp_conn {
	int fd_in;
	int fd_out;
	u_int transfer_buflen;
	u_int num_requests;
	u_int version;
	u_int msg_id;
};
d218 2
a219 2
struct sftp_conn *
do_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests)
a222 1
	struct sftp_conn *ret;
d238 1
a238 1
		return(NULL);
d256 1
a256 19
	ret = xmalloc(sizeof(*ret));
	ret->fd_in = fd_in;
	ret->fd_out = fd_out;
	ret->transfer_buflen = transfer_buflen;
	ret->num_requests = num_requests;
	ret->version = version;
	ret->msg_id = 1;

	/* Some filexfer v.0 servers don't support large packets */
	if (version == 0)
		ret->transfer_buflen = MAX(ret->transfer_buflen, 20480);

	return(ret);
}

u_int
sftp_proto_version(struct sftp_conn *conn)
{
	return(conn->version);
d260 1
a260 1
do_close(struct sftp_conn *conn, char *handle, u_int handle_len)
d267 1
a267 1
	id = conn->msg_id++;
d271 1
a271 1
	send_msg(conn->fd_out, &msg);
d274 1
a274 1
	status = get_status(conn->fd_in, id);
d285 1
a285 1
do_lsreaddir(struct sftp_conn *conn, char *path, int printflag,
d292 1
a292 1
	id = conn->msg_id++;
d298 1
a298 1
	send_msg(conn->fd_out, &msg);
d302 1
a302 1
	handle = get_handle(conn->fd_in, id, &handle_len);
d311 1
d313 1
a313 1
	for (;;) {
d316 1
a316 1
		id = expected_id = conn->msg_id++;
d324 1
a324 1
		send_msg(conn->fd_out, &msg);
d328 1
a328 1
		get_msg(conn->fd_in, &msg);
d348 1
a348 1
				do_close(conn, handle, handle_len);
d359 1
a359 1
		for (i = 0; i < count; i++) {
d386 1
a386 1
	do_close(conn, handle, handle_len);
d393 1
a393 1
do_ls(struct sftp_conn *conn, char *path)
d395 1
a395 1
	return(do_lsreaddir(conn, path, 1, NULL));
d399 1
a399 1
do_readdir(struct sftp_conn *conn, char *path, SFTP_DIRENT ***dir)
d401 1
a401 1
	return(do_lsreaddir(conn, path, 0, dir));
d407 2
a408 2

	for (i = 0; s[i]; i++) {
d417 1
a417 1
do_rm(struct sftp_conn *conn, char *path)
d423 3
a425 4
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_REMOVE, path, 
	    strlen(path));
	status = get_status(conn->fd_in, id);
d432 1
a432 1
do_mkdir(struct sftp_conn *conn, char *path, Attrib *a)
d436 2
a437 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_MKDIR, path,
d440 1
a440 1
	status = get_status(conn->fd_in, id);
d448 1
a448 1
do_rmdir(struct sftp_conn *conn, char *path)
d452 2
a453 3
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_RMDIR, path,
	    strlen(path));
d455 1
a455 1
	status = get_status(conn->fd_in, id);
d463 1
a463 1
do_stat(struct sftp_conn *conn, char *path, int quiet)
d467 3
a469 7
	id = conn->msg_id++;

	send_string_request(conn->fd_out, id, 
	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT, 
	    path, strlen(path));

	return(get_decode_stat(conn->fd_in, id, quiet));
d473 1
a473 1
do_lstat(struct sftp_conn *conn, char *path, int quiet)
d477 3
a479 13
	if (conn->version == 0) {
		if (quiet)
			debug("Server version does not support lstat operation");
		else
			error("Server version does not support lstat operation");
		return(NULL);
	}

	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_LSTAT, path,
	    strlen(path));

	return(get_decode_stat(conn->fd_in, id, quiet));
d483 1
a483 1
do_fstat(struct sftp_conn *conn, char *handle, u_int handle_len, int quiet)
d487 3
a489 5
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_FSTAT, handle,
	    handle_len);

	return(get_decode_stat(conn->fd_in, id, quiet));
d493 1
a493 1
do_setstat(struct sftp_conn *conn, char *path, Attrib *a)
d497 2
a498 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_SETSTAT, path,
d501 1
a501 1
	status = get_status(conn->fd_in, id);
d510 1
a510 1
do_fsetstat(struct sftp_conn *conn, char *handle, u_int handle_len,
d515 2
a516 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_FSETSTAT, handle,
d519 1
a519 1
	status = get_status(conn->fd_in, id);
d527 1
a527 1
do_realpath(struct sftp_conn *conn, char *path)
d534 2
a535 3
	expected_id = id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_REALPATH, path,
	    strlen(path));
d539 1
a539 1
	get_msg(conn->fd_in, &msg);
d573 1
a573 1
do_rename(struct sftp_conn *conn, char *oldpath, char *newpath)
d581 1
a581 1
	id = conn->msg_id++;
d586 1
a586 1
	send_msg(conn->fd_out, &msg);
d591 1
a591 1
	status = get_status(conn->fd_in, id);
d593 2
a594 2
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));
d600 1
a600 1
do_symlink(struct sftp_conn *conn, char *oldpath, char *newpath)
a604 5
	if (conn->version < 3) {
		error("This server does not support the symlink operation");
		return(SSH2_FX_OP_UNSUPPORTED);
	}

d608 1
a608 1
	id = conn->msg_id++;
d613 1
a613 1
	send_msg(conn->fd_out, &msg);
d618 1
a618 1
	status = get_status(conn->fd_in, id);
d620 2
a621 2
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));
d627 1
a627 1
do_readlink(struct sftp_conn *conn, char *path)
d634 2
a635 3
	expected_id = id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_READLINK, path,
	    strlen(path));
d639 1
a639 1
	get_msg(conn->fd_in, &msg);
a671 17
static void
send_read_request(int fd_out, u_int id, u_int64_t offset, u_int len,
    char *handle, u_int handle_len)
{
	Buffer msg;
	
	buffer_init(&msg);
	buffer_clear(&msg);
	buffer_put_char(&msg, SSH2_FXP_READ);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, handle, handle_len);
	buffer_put_int64(&msg, offset);
	buffer_put_int(&msg, len);
	send_msg(fd_out, &msg);
	buffer_free(&msg);
}	

d673 1
a673 1
do_download(struct sftp_conn *conn, char *remote_path, char *local_path,
d676 5
d682 1
a682 14
	Buffer msg;
	char *handle;
	int local_fd, status, num_req, max_req, write_error;
	int read_error, write_errno;
	u_int64_t offset, size;
	u_int handle_len, mode, type, id, buflen;
	struct request {
		u_int id;
		u_int len;
		u_int64_t offset;
		TAILQ_ENTRY(request) tq; 
	};
	TAILQ_HEAD(reqhead, request) requests;
	struct request *req;
d684 1
a684 3
	TAILQ_INIT(&requests);

	a = do_stat(conn, remote_path, 0);
d700 6
a705 4
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE)
		size = a->size;
	else
		size = 0;
a706 1
	buflen = conn->transfer_buflen;
d710 1
a710 1
	id = conn->msg_id++;
d717 1
a717 1
	send_msg(conn->fd_out, &msg);
d720 1
a720 1
	handle = get_handle(conn->fd_in, id, &handle_len);
d723 1
a723 9
		return(-1);
	}

	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC, mode);
	if (local_fd == -1) {
		error("Couldn't open local file \"%s\" for writing: %s",
		    local_path, strerror(errno));
		buffer_free(&msg);
		xfree(handle);
d728 3
a730 3
	write_error = read_error = write_errno = num_req = offset = 0;
	max_req = 1;
	while (num_req > 0 || max_req > 0) {
a731 1
		u_int len;
d733 11
a743 14
		/* Send some more requests */
		while (num_req < max_req) {
			debug3("Request range %llu -> %llu (%d/%d)", 
			    offset, offset + buflen - 1, num_req, max_req);
			req = xmalloc(sizeof(*req));
			req->id = conn->msg_id++;
			req->len = buflen;
			req->offset = offset;
			offset += buflen;
			num_req++;
			TAILQ_INSERT_TAIL(&requests, req, tq);
			send_read_request(conn->fd_out, req->id, req->offset, 
			    req->len, handle, handle_len);
		}
d746 2
a747 1
		get_msg(conn->fd_in, &msg);
d750 4
a753 12
		debug3("Received reply T:%d I:%d R:%d", type, id, max_req);

		/* Find the request in our queue */
		for(req = TAILQ_FIRST(&requests);
		    req != NULL && req->id != id;
		    req = TAILQ_NEXT(req, tq))
			;
		if (req == NULL)
			fatal("Unexpected reply %u", id);

		switch (type) {
		case SSH2_FXP_STATUS:
a754 22
			if (status != SSH2_FX_EOF)
				read_error = 1;
			max_req = 0;
			TAILQ_REMOVE(&requests, req, tq);
			xfree(req);
			num_req--;
			break;
		case SSH2_FXP_DATA:
			data = buffer_get_string(&msg, &len);
			debug3("Received data %llu -> %llu", req->offset, 
			    req->offset + len - 1);
			if (len > req->len)
				fatal("Received more data than asked for "
				      "%d > %d", len, req->len);
			if ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||
			     atomicio(write, local_fd, data, len) != len) &&
			    !write_error) {
				write_errno = errno;
				write_error = 1;
				max_req = 0;
			}
			xfree(data);
d756 8
a763 17
			if (len == req->len) {
				TAILQ_REMOVE(&requests, req, tq);
				xfree(req);
				num_req--;
			} else {
				/* Resend the request for the missing data */
				debug3("Short data block, re-requesting "
				    "%llu -> %llu (%2d)", req->offset + len, 
					req->offset + req->len - 1, num_req);
				req->id = conn->msg_id++;
				req->len -= len;
				req->offset += len;
				send_read_request(conn->fd_out, req->id, 
				    req->offset, req->len, handle, handle_len);
				/* Reduce the request size */
				if (len < buflen)
					buflen = MAX(MIN_READ_SIZE, len);
d765 1
a765 14
			if (max_req > 0) { /* max_req = 0 iff EOF received */
				if (size > 0 && offset > size) {
					/* Only one request at a time
					 * after the expected EOF */
					debug3("Finish at %llu (%2d)",
					    offset, num_req);
					max_req = 1;
				}
				else if (max_req < conn->num_requests + 1) {
					++max_req;
				}
			}
			break;
		default:
d769 19
d789 1
d791 12
a802 29
	/* Sanity check */
	if (TAILQ_FIRST(&requests) != NULL)
		fatal("Transfer complete, but requests still in queue");

	if (read_error) {
		error("Couldn't read from remote file \"%s\" : %s", 
		    remote_path, fx2txt(status));
		do_close(conn, handle, handle_len);
	} else if (write_error) {
		error("Couldn't write to \"%s\": %s", local_path,
		    strerror(write_errno));
		status = -1;
		do_close(conn, handle, handle_len);
	} else {
		status = do_close(conn, handle, handle_len);

		/* Override umask and utimes if asked */
		if (pflag && fchmod(local_fd, mode) == -1)
			error("Couldn't set mode on \"%s\": %s", local_path,
			      strerror(errno));
		if (pflag && (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {
			struct timeval tv[2];
			tv[0].tv_sec = a->atime;
			tv[1].tv_sec = a->mtime;
			tv[0].tv_usec = tv[1].tv_usec = 0;
			if (utimes(local_path, tv) == -1)
				error("Can't set times on \"%s\": %s",
				      local_path, strerror(errno));
		}
d804 2
d809 1
a809 2

	return(status);
d813 1
a813 1
do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
d816 2
a817 2
	int local_fd, status;
	u_int handle_len, id, type;
d819 1
a819 1
	char *handle, *data;
d823 1
a823 12
	u_int32_t startid;
	u_int32_t ackid;
	struct outstanding_ack {
		u_int id;
		u_int len;
		u_int64_t offset;
		TAILQ_ENTRY(outstanding_ack) tq; 
	};
	TAILQ_HEAD(ackhead, outstanding_ack) acks;
	struct outstanding_ack *ack;

	TAILQ_INIT(&acks);
d847 1
a847 1
	id = conn->msg_id++;
d853 1
a853 1
	send_msg(conn->fd_out, &msg);
d858 1
a858 1
	handle = get_handle(conn->fd_in, id, &handle_len);
a864 3
	startid = ackid = id + 1;
	data = xmalloc(conn->transfer_buflen);

d867 1
a867 1
	for (;;) {
d869 1
d876 1
a876 1
			len = read(local_fd, data, conn->transfer_buflen);
d882 1
a882 18

		if (len != 0) {
			ack = xmalloc(sizeof(*ack));
			ack->id = ++id;
			ack->offset = offset;
			ack->len = len;
			TAILQ_INSERT_TAIL(&acks, ack, tq);

			buffer_clear(&msg);
			buffer_put_char(&msg, SSH2_FXP_WRITE);
			buffer_put_int(&msg, ack->id);
			buffer_put_string(&msg, handle, handle_len);
			buffer_put_int64(&msg, offset);
			buffer_put_string(&msg, data, len);
			send_msg(conn->fd_out, &msg);
			debug3("Sent message SSH2_FXP_WRITE I:%d O:%llu S:%u",
			       id, (u_int64_t)offset, len);
		} else if (TAILQ_FIRST(&acks) == NULL)
d885 20
a904 13
		if (ack == NULL)
			fatal("Unexpected ACK %u", id);

		if (id == startid || len == 0 || 
		    id - ackid >= conn->num_requests) {
			buffer_clear(&msg);
			get_msg(conn->fd_in, &msg);
			type = buffer_get_char(&msg);
			id = buffer_get_int(&msg);

			if (type != SSH2_FXP_STATUS)
				fatal("Expected SSH2_FXP_STATUS(%d) packet, "
				    "got %d", SSH2_FXP_STATUS, type);
a905 24
			status = buffer_get_int(&msg);
			debug3("SSH2_FXP_STATUS %d", status);

			/* Find the request in our queue */
			for(ack = TAILQ_FIRST(&acks);
			    ack != NULL && ack->id != id;
			    ack = TAILQ_NEXT(ack, tq))
				;
			if (ack == NULL)
				fatal("Can't find request for ID %d", id);
			TAILQ_REMOVE(&acks, ack, tq);

			if (status != SSH2_FX_OK) {
				error("Couldn't write to remote file \"%s\": %s",
				      remote_path, fx2txt(status));
				do_close(conn, handle, handle_len);
				close(local_fd);
				goto done;
			}
			debug3("In write loop, ack for %u %d bytes at %llu", 
			   ack->id, ack->len, ack->offset);
			++ackid;
			free(ack);
		}
a907 1
	xfree(data);
d912 1
a912 1
		do_close(conn, handle, handle_len);
d919 1
a919 1
		do_fsetstat(conn, handle, handle_len, &a);
d921 1
a921 1
	status = do_close(conn, handle, handle_len);
d926 1
a926 1
	return(status);
d928 1
@


1.18.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.31 2002/04/06 00:30:08 djm Exp $");
d273 1
a273 1
		ret->transfer_buflen = MIN(ret->transfer_buflen, 20480);
d448 1
a448 1
	send_string_request(conn->fd_out, id, SSH2_FXP_REMOVE, path,
d495 2
a496 2
	send_string_request(conn->fd_out, id,
	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,
d511 2
a512 2
			log("Server version does not support lstat operation");
		return(do_stat(conn, path, quiet));
d726 1
a726 1

d736 1
a736 1
}
d753 1
a753 1
		TAILQ_ENTRY(request) tq;
d819 2
a820 4
			debug3("Request range %llu -> %llu (%d/%d)",
			    (unsigned long long)offset,
			    (unsigned long long)offset + buflen - 1,
			    num_req, max_req);
d828 1
a828 1
			send_read_request(conn->fd_out, req->id, req->offset,
d858 2
a859 3
			debug3("Received data %llu -> %llu",
			    (unsigned long long)req->offset,
			    (unsigned long long)req->offset + len - 1);
d879 2
a880 4
				    "%llu -> %llu (%2d)",
				    (unsigned long long)req->offset + len,
				    (unsigned long long)req->offset +
				    req->len - 1, num_req);
d884 1
a884 1
				send_read_request(conn->fd_out, req->id,
d895 1
a895 2
					    (unsigned long long)offset,
					    num_req);
d914 1
a914 1
		error("Couldn't read from remote file \"%s\" : %s",
d963 1
a963 1
		TAILQ_ENTRY(outstanding_ack) tq;
d1045 1
a1045 1
			       id, (unsigned long long)offset, len);
d1052 1
a1052 1
		if (id == startid || len == 0 ||
a1053 2
		    	u_int r_id;

d1057 1
a1057 1
			r_id = buffer_get_int(&msg);
d1068 1
a1068 1
			    ack != NULL && ack->id != r_id;
d1072 1
a1072 1
				fatal("Can't find request for ID %d", r_id);
d1082 2
a1083 2
			debug3("In write loop, ack for %u %d bytes at %llu",
			   ack->id, ack->len, (unsigned long long)ack->offset);
@


1.18.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.18.2.2 2002/05/17 00:03:24 miod Exp $");
d1060 1
a1060 1
			u_int r_id;
@


1.18.2.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.18.2.3 2002/06/22 07:23:17 miod Exp $");
d91 1
a91 1
		fatal("Received message too long %u", msg_len);
d116 1
a116 1
	debug3("Sent message fd %d T:%u I:%u", fd, code, id);
d132 1
a132 1
	debug3("Sent message fd %d T:%u I:%u", fd, code, id);
d137 1
a137 1
get_status(int fd, u_int expected_id)
d148 1
a148 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d150 1
a150 1
		fatal("Expected SSH2_FXP_STATUS(%u) packet, got %u",
d156 1
a156 1
	debug3("SSH2_FXP_STATUS %u", status);
d174 1
a174 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d181 1
a181 1
		fatal("Expected SSH2_FXP_HANDLE(%u) packet, got %u",
d203 1
a203 1
	debug3("Received stat reply T:%u I:%u", type, id);
d205 1
a205 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d215 1
a215 1
		fatal("Expected SSH2_FXP_ATTRS(%u) packet, got %u",
d227 1
a227 2
	u_int type;
	int version;
d242 1
a242 1
		error("Invalid packet back from SSH2_FXP_INIT (type %u)",
d297 1
a297 1
	debug3("Sent message SSH2_FXP_CLOSE I:%u", id);
d342 1
a342 1
		debug3("Sending SSH2_FXP_READDIR I:%u", id);
d357 1
a357 1
		debug3("Received reply T:%u I:%u", type, id);
d360 1
a360 1
			fatal("ID mismatch (%u != %u)", id, expected_id);
d376 1
a376 1
			fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
d587 1
a587 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d595 1
a595 1
		fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
d693 1
a693 1
		fatal("ID mismatch (%u != %u)", id, expected_id);
d701 1
a701 1
		fatal("Expected SSH2_FXP_NAME(%u) packet, got %u",
d793 1
a793 1
	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);
d838 1
a838 1
		debug3("Received reply T:%u I:%u R:%d", type, id, max_req);
d865 1
a865 1
				      "%u > %u", len, req->len);
d910 1
a910 1
			fatal("Expected SSH2_FXP_DATA(%u) packet, got %u",
d1005 1
a1005 1
	debug3("Sent message SSH2_FXP_OPEN I:%u P:%s", id, remote_path);
d1050 1
a1050 1
			debug3("Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u",
d1080 1
a1080 1
				fatal("Can't find request for ID %u", r_id);
d1090 1
a1090 1
			debug3("In write loop, ack for %u %u bytes at %llu",
@


1.18.2.5
log
@Update to OpenSSH 3.5
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.35 2002/09/11 22:41:49 djm Exp $");
d418 6
d1094 1
a1094 1
			xfree(ack);
@


1.17
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.16 2001/04/05 10:42:52 markus Exp $");
a33 1
#include "ssh.h"
a39 1
#include "pathnames.h"
@


1.16
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.15 2001/03/19 10:52:51 djm Exp $");
d54 1
a54 1
void
d73 1
a73 1
void
d101 1
a101 1
void
d116 1
a116 1
void
d132 1
a132 1
u_int
d157 1
a157 1
char *
d186 1
a186 1
Attrib *
d286 1
a286 1
int
@


1.16.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.18 2001/07/14 15:10:16 stevesk Exp $");
d34 1
d41 1
d54 1
a54 1
static void
d73 1
a73 1
static void
d101 1
a101 1
static void
d116 1
a116 1
static void
d132 1
a132 1
static u_int
d157 1
a157 1
static char *
d186 1
a186 1
static Attrib *
d286 1
a286 1
static int
@


1.16.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d27 2
a28 1
/* XXX: remove all logging, only return status codes */
d32 1
a32 3
RCSID("$OpenBSD: sftp-client.c,v 1.24 2002/02/24 16:57:19 markus Exp $");

#include <sys/queue.h>
d45 3
a47 2
/* Minimum amount of data to read at at time */
#define MIN_READ_SIZE	512
d49 2
a50 8
struct sftp_conn {
	int fd_in;
	int fd_out;
	u_int transfer_buflen;
	u_int num_requests;
	u_int version;
	u_int msg_id;
};
d218 2
a219 2
struct sftp_conn *
do_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests)
a222 1
	struct sftp_conn *ret;
d238 1
a238 1
		return(NULL);
d256 1
a256 19
	ret = xmalloc(sizeof(*ret));
	ret->fd_in = fd_in;
	ret->fd_out = fd_out;
	ret->transfer_buflen = transfer_buflen;
	ret->num_requests = num_requests;
	ret->version = version;
	ret->msg_id = 1;

	/* Some filexfer v.0 servers don't support large packets */
	if (version == 0)
		ret->transfer_buflen = MAX(ret->transfer_buflen, 20480);

	return(ret);
}

u_int
sftp_proto_version(struct sftp_conn *conn)
{
	return(conn->version);
d260 1
a260 1
do_close(struct sftp_conn *conn, char *handle, u_int handle_len)
d267 1
a267 1
	id = conn->msg_id++;
d271 1
a271 1
	send_msg(conn->fd_out, &msg);
d274 1
a274 1
	status = get_status(conn->fd_in, id);
d285 1
a285 1
do_lsreaddir(struct sftp_conn *conn, char *path, int printflag,
d292 1
a292 1
	id = conn->msg_id++;
d298 1
a298 1
	send_msg(conn->fd_out, &msg);
d302 1
a302 1
	handle = get_handle(conn->fd_in, id, &handle_len);
d311 1
d313 1
a313 1
	for (;;) {
d316 1
a316 1
		id = expected_id = conn->msg_id++;
d324 1
a324 1
		send_msg(conn->fd_out, &msg);
d328 1
a328 1
		get_msg(conn->fd_in, &msg);
d348 1
a348 1
				do_close(conn, handle, handle_len);
d359 1
a359 1
		for (i = 0; i < count; i++) {
d386 1
a386 1
	do_close(conn, handle, handle_len);
d393 1
a393 1
do_ls(struct sftp_conn *conn, char *path)
d395 1
a395 1
	return(do_lsreaddir(conn, path, 1, NULL));
d399 1
a399 1
do_readdir(struct sftp_conn *conn, char *path, SFTP_DIRENT ***dir)
d401 1
a401 1
	return(do_lsreaddir(conn, path, 0, dir));
d407 2
a408 2

	for (i = 0; s[i]; i++) {
d417 1
a417 1
do_rm(struct sftp_conn *conn, char *path)
d423 3
a425 4
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_REMOVE, path, 
	    strlen(path));
	status = get_status(conn->fd_in, id);
d432 1
a432 1
do_mkdir(struct sftp_conn *conn, char *path, Attrib *a)
d436 2
a437 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_MKDIR, path,
d440 1
a440 1
	status = get_status(conn->fd_in, id);
d448 1
a448 1
do_rmdir(struct sftp_conn *conn, char *path)
d452 2
a453 3
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_RMDIR, path,
	    strlen(path));
d455 1
a455 1
	status = get_status(conn->fd_in, id);
d463 1
a463 1
do_stat(struct sftp_conn *conn, char *path, int quiet)
d467 3
a469 7
	id = conn->msg_id++;

	send_string_request(conn->fd_out, id, 
	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT, 
	    path, strlen(path));

	return(get_decode_stat(conn->fd_in, id, quiet));
d473 1
a473 1
do_lstat(struct sftp_conn *conn, char *path, int quiet)
d477 3
a479 13
	if (conn->version == 0) {
		if (quiet)
			debug("Server version does not support lstat operation");
		else
			error("Server version does not support lstat operation");
		return(NULL);
	}

	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_LSTAT, path,
	    strlen(path));

	return(get_decode_stat(conn->fd_in, id, quiet));
d483 1
a483 1
do_fstat(struct sftp_conn *conn, char *handle, u_int handle_len, int quiet)
d487 3
a489 5
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_FSTAT, handle,
	    handle_len);

	return(get_decode_stat(conn->fd_in, id, quiet));
d493 1
a493 1
do_setstat(struct sftp_conn *conn, char *path, Attrib *a)
d497 2
a498 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_SETSTAT, path,
d501 1
a501 1
	status = get_status(conn->fd_in, id);
d510 1
a510 1
do_fsetstat(struct sftp_conn *conn, char *handle, u_int handle_len,
d515 2
a516 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_FSETSTAT, handle,
d519 1
a519 1
	status = get_status(conn->fd_in, id);
d527 1
a527 1
do_realpath(struct sftp_conn *conn, char *path)
d534 2
a535 3
	expected_id = id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_REALPATH, path,
	    strlen(path));
d539 1
a539 1
	get_msg(conn->fd_in, &msg);
d573 1
a573 1
do_rename(struct sftp_conn *conn, char *oldpath, char *newpath)
d581 1
a581 1
	id = conn->msg_id++;
d586 1
a586 1
	send_msg(conn->fd_out, &msg);
d591 1
a591 1
	status = get_status(conn->fd_in, id);
d593 2
a594 2
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));
d600 1
a600 1
do_symlink(struct sftp_conn *conn, char *oldpath, char *newpath)
a604 5
	if (conn->version < 3) {
		error("This server does not support the symlink operation");
		return(SSH2_FX_OP_UNSUPPORTED);
	}

d608 1
a608 1
	id = conn->msg_id++;
d613 1
a613 1
	send_msg(conn->fd_out, &msg);
d618 1
a618 1
	status = get_status(conn->fd_in, id);
d620 2
a621 2
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));
d627 1
a627 1
do_readlink(struct sftp_conn *conn, char *path)
d634 2
a635 3
	expected_id = id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_READLINK, path,
	    strlen(path));
d639 1
a639 1
	get_msg(conn->fd_in, &msg);
a671 17
static void
send_read_request(int fd_out, u_int id, u_int64_t offset, u_int len,
    char *handle, u_int handle_len)
{
	Buffer msg;
	
	buffer_init(&msg);
	buffer_clear(&msg);
	buffer_put_char(&msg, SSH2_FXP_READ);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, handle, handle_len);
	buffer_put_int64(&msg, offset);
	buffer_put_int(&msg, len);
	send_msg(fd_out, &msg);
	buffer_free(&msg);
}	

d673 1
a673 1
do_download(struct sftp_conn *conn, char *remote_path, char *local_path,
d676 5
d682 1
a682 14
	Buffer msg;
	char *handle;
	int local_fd, status, num_req, max_req, write_error;
	int read_error, write_errno;
	u_int64_t offset, size;
	u_int handle_len, mode, type, id, buflen;
	struct request {
		u_int id;
		u_int len;
		u_int64_t offset;
		TAILQ_ENTRY(request) tq; 
	};
	TAILQ_HEAD(reqhead, request) requests;
	struct request *req;
d684 1
a684 3
	TAILQ_INIT(&requests);

	a = do_stat(conn, remote_path, 0);
d700 6
a705 4
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE)
		size = a->size;
	else
		size = 0;
a706 1
	buflen = conn->transfer_buflen;
d710 1
a710 1
	id = conn->msg_id++;
d717 1
a717 1
	send_msg(conn->fd_out, &msg);
d720 1
a720 1
	handle = get_handle(conn->fd_in, id, &handle_len);
d723 1
a723 9
		return(-1);
	}

	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC, mode);
	if (local_fd == -1) {
		error("Couldn't open local file \"%s\" for writing: %s",
		    local_path, strerror(errno));
		buffer_free(&msg);
		xfree(handle);
d728 3
a730 3
	write_error = read_error = write_errno = num_req = offset = 0;
	max_req = 1;
	while (num_req > 0 || max_req > 0) {
a731 1
		u_int len;
d733 11
a743 14
		/* Send some more requests */
		while (num_req < max_req) {
			debug3("Request range %llu -> %llu (%d/%d)", 
			    offset, offset + buflen - 1, num_req, max_req);
			req = xmalloc(sizeof(*req));
			req->id = conn->msg_id++;
			req->len = buflen;
			req->offset = offset;
			offset += buflen;
			num_req++;
			TAILQ_INSERT_TAIL(&requests, req, tq);
			send_read_request(conn->fd_out, req->id, req->offset, 
			    req->len, handle, handle_len);
		}
d746 2
a747 1
		get_msg(conn->fd_in, &msg);
d750 4
a753 12
		debug3("Received reply T:%d I:%d R:%d", type, id, max_req);

		/* Find the request in our queue */
		for(req = TAILQ_FIRST(&requests);
		    req != NULL && req->id != id;
		    req = TAILQ_NEXT(req, tq))
			;
		if (req == NULL)
			fatal("Unexpected reply %u", id);

		switch (type) {
		case SSH2_FXP_STATUS:
a754 22
			if (status != SSH2_FX_EOF)
				read_error = 1;
			max_req = 0;
			TAILQ_REMOVE(&requests, req, tq);
			xfree(req);
			num_req--;
			break;
		case SSH2_FXP_DATA:
			data = buffer_get_string(&msg, &len);
			debug3("Received data %llu -> %llu", req->offset, 
			    req->offset + len - 1);
			if (len > req->len)
				fatal("Received more data than asked for "
				      "%d > %d", len, req->len);
			if ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||
			     atomicio(write, local_fd, data, len) != len) &&
			    !write_error) {
				write_errno = errno;
				write_error = 1;
				max_req = 0;
			}
			xfree(data);
d756 8
a763 17
			if (len == req->len) {
				TAILQ_REMOVE(&requests, req, tq);
				xfree(req);
				num_req--;
			} else {
				/* Resend the request for the missing data */
				debug3("Short data block, re-requesting "
				    "%llu -> %llu (%2d)", req->offset + len, 
					req->offset + req->len - 1, num_req);
				req->id = conn->msg_id++;
				req->len -= len;
				req->offset += len;
				send_read_request(conn->fd_out, req->id, 
				    req->offset, req->len, handle, handle_len);
				/* Reduce the request size */
				if (len < buflen)
					buflen = MAX(MIN_READ_SIZE, len);
d765 1
a765 14
			if (max_req > 0) { /* max_req = 0 iff EOF received */
				if (size > 0 && offset > size) {
					/* Only one request at a time
					 * after the expected EOF */
					debug3("Finish at %llu (%2d)",
					    offset, num_req);
					max_req = 1;
				}
				else if (max_req < conn->num_requests + 1) {
					++max_req;
				}
			}
			break;
		default:
d769 19
d789 1
d791 12
a802 29
	/* Sanity check */
	if (TAILQ_FIRST(&requests) != NULL)
		fatal("Transfer complete, but requests still in queue");

	if (read_error) {
		error("Couldn't read from remote file \"%s\" : %s", 
		    remote_path, fx2txt(status));
		do_close(conn, handle, handle_len);
	} else if (write_error) {
		error("Couldn't write to \"%s\": %s", local_path,
		    strerror(write_errno));
		status = -1;
		do_close(conn, handle, handle_len);
	} else {
		status = do_close(conn, handle, handle_len);

		/* Override umask and utimes if asked */
		if (pflag && fchmod(local_fd, mode) == -1)
			error("Couldn't set mode on \"%s\": %s", local_path,
			      strerror(errno));
		if (pflag && (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {
			struct timeval tv[2];
			tv[0].tv_sec = a->atime;
			tv[1].tv_sec = a->mtime;
			tv[0].tv_usec = tv[1].tv_usec = 0;
			if (utimes(local_path, tv) == -1)
				error("Can't set times on \"%s\": %s",
				      local_path, strerror(errno));
		}
d804 2
d809 1
a809 2

	return(status);
d813 1
a813 1
do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
d816 2
a817 2
	int local_fd, status;
	u_int handle_len, id, type;
d819 1
a819 1
	char *handle, *data;
d823 1
a823 12
	u_int32_t startid;
	u_int32_t ackid;
	struct outstanding_ack {
		u_int id;
		u_int len;
		u_int64_t offset;
		TAILQ_ENTRY(outstanding_ack) tq; 
	};
	TAILQ_HEAD(ackhead, outstanding_ack) acks;
	struct outstanding_ack *ack;

	TAILQ_INIT(&acks);
d847 1
a847 1
	id = conn->msg_id++;
d853 1
a853 1
	send_msg(conn->fd_out, &msg);
d858 1
a858 1
	handle = get_handle(conn->fd_in, id, &handle_len);
a864 3
	startid = ackid = id + 1;
	data = xmalloc(conn->transfer_buflen);

d867 1
a867 1
	for (;;) {
d869 1
d876 1
a876 1
			len = read(local_fd, data, conn->transfer_buflen);
d882 1
a882 18

		if (len != 0) {
			ack = xmalloc(sizeof(*ack));
			ack->id = ++id;
			ack->offset = offset;
			ack->len = len;
			TAILQ_INSERT_TAIL(&acks, ack, tq);

			buffer_clear(&msg);
			buffer_put_char(&msg, SSH2_FXP_WRITE);
			buffer_put_int(&msg, ack->id);
			buffer_put_string(&msg, handle, handle_len);
			buffer_put_int64(&msg, offset);
			buffer_put_string(&msg, data, len);
			send_msg(conn->fd_out, &msg);
			debug3("Sent message SSH2_FXP_WRITE I:%d O:%llu S:%u",
			       id, (u_int64_t)offset, len);
		} else if (TAILQ_FIRST(&acks) == NULL)
d885 20
a904 13
		if (ack == NULL)
			fatal("Unexpected ACK %u", id);

		if (id == startid || len == 0 || 
		    id - ackid >= conn->num_requests) {
			buffer_clear(&msg);
			get_msg(conn->fd_in, &msg);
			type = buffer_get_char(&msg);
			id = buffer_get_int(&msg);

			if (type != SSH2_FXP_STATUS)
				fatal("Expected SSH2_FXP_STATUS(%d) packet, "
				    "got %d", SSH2_FXP_STATUS, type);
a905 24
			status = buffer_get_int(&msg);
			debug3("SSH2_FXP_STATUS %d", status);

			/* Find the request in our queue */
			for(ack = TAILQ_FIRST(&acks);
			    ack != NULL && ack->id != id;
			    ack = TAILQ_NEXT(ack, tq))
				;
			if (ack == NULL)
				fatal("Can't find request for ID %d", id);
			TAILQ_REMOVE(&acks, ack, tq);

			if (status != SSH2_FX_OK) {
				error("Couldn't write to remote file \"%s\": %s",
				      remote_path, fx2txt(status));
				do_close(conn, handle, handle_len);
				close(local_fd);
				goto done;
			}
			debug3("In write loop, ack for %u %d bytes at %llu", 
			   ack->id, ack->len, ack->offset);
			++ackid;
			free(ack);
		}
a907 1
	xfree(data);
d912 1
a912 1
		do_close(conn, handle, handle_len);
d919 1
a919 1
		do_fsetstat(conn, handle, handle_len, &a);
d921 1
a921 1
	status = do_close(conn, handle, handle_len);
d926 1
a926 1
	return(status);
d928 1
@


1.16.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d31 1
a31 1
RCSID("$OpenBSD: sftp-client.c,v 1.31 2002/04/06 00:30:08 djm Exp $");
d273 1
a273 1
		ret->transfer_buflen = MIN(ret->transfer_buflen, 20480);
d448 1
a448 1
	send_string_request(conn->fd_out, id, SSH2_FXP_REMOVE, path,
d495 2
a496 2
	send_string_request(conn->fd_out, id,
	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,
d511 2
a512 2
			log("Server version does not support lstat operation");
		return(do_stat(conn, path, quiet));
d726 1
a726 1

d736 1
a736 1
}
d753 1
a753 1
		TAILQ_ENTRY(request) tq;
d819 2
a820 4
			debug3("Request range %llu -> %llu (%d/%d)",
			    (unsigned long long)offset,
			    (unsigned long long)offset + buflen - 1,
			    num_req, max_req);
d828 1
a828 1
			send_read_request(conn->fd_out, req->id, req->offset,
d858 2
a859 3
			debug3("Received data %llu -> %llu",
			    (unsigned long long)req->offset,
			    (unsigned long long)req->offset + len - 1);
d879 2
a880 4
				    "%llu -> %llu (%2d)",
				    (unsigned long long)req->offset + len,
				    (unsigned long long)req->offset +
				    req->len - 1, num_req);
d884 1
a884 1
				send_read_request(conn->fd_out, req->id,
d895 1
a895 2
					    (unsigned long long)offset,
					    num_req);
d914 1
a914 1
		error("Couldn't read from remote file \"%s\" : %s",
d963 1
a963 1
		TAILQ_ENTRY(outstanding_ack) tq;
d1045 1
a1045 1
			       id, (unsigned long long)offset, len);
d1052 1
a1052 1
		if (id == startid || len == 0 ||
a1053 2
		    	u_int r_id;

d1057 1
a1057 1
			r_id = buffer_get_int(&msg);
d1068 1
a1068 1
			    ack != NULL && ack->id != r_id;
d1072 1
a1072 1
				fatal("Can't find request for ID %d", r_id);
d1082 2
a1083 2
			debug3("In write loop, ack for %u %d bytes at %llu",
			   ack->id, ack->len, (unsigned long long)ack->offset);
@


1.15
log
@Report ssh connection closing correctly; ok deraadt@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.14 2001/03/16 08:16:17 djm Exp $");
d287 1
a287 1
do_lsreaddir(int fd_in, int fd_out, char *path, int printflag, 
d373 1
a373 1
				*dir = xrealloc(*dir, sizeof(**dir) * 
@


1.14
log
@Revise globbing for get/put to be more shell-like. In particular,
"get/put file* directory/" now works. ok markus@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.13 2001/03/14 08:57:14 markus Exp $");
d80 3
a82 1
	if (len != 4)
d91 3
a93 1
		if (len <= 0)
@


1.13
log
@Wall
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.12 2001/03/13 22:42:54 djm Exp $");
d183 1
a183 1
get_decode_stat(int fd, u_int expected_id)
d201 4
a204 1
		error("Couldn't stat remote file: %s", fx2txt(status));
d461 1
a461 1
do_stat(int fd_in, int fd_out, char *path)
d467 1
a467 1
	return(get_decode_stat(fd_in, id));
d471 1
a471 1
do_lstat(int fd_in, int fd_out, char *path)
d477 1
a477 1
	return(get_decode_stat(fd_in, id));
d481 1
a481 2
do_fstat(int fd_in, int fd_out, char *handle,
    u_int handle_len)
d487 1
a487 1
	return(get_decode_stat(fd_in, id));
d682 1
a682 1
	a = do_stat(fd_in, fd_out, remote_path);
d692 6
d702 1
a702 1
		return(errno);
@


1.12
log
@sftp client filename globbing for get, put, ch{mod,grp,own}. ok markus@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.11 2001/03/07 10:11:22 djm Exp $");
d284 1
a284 1
	u_int type, id, handle_len, i, expected_id, ents;
@


1.11
log
@Support for new draft (draft-ietf-secsh-filexfer-01). New symlink handling
functions and small protocol change.
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.10 2001/02/14 09:46:03 djm Exp $");
d278 1
d280 2
a281 1
do_ls(int fd_in, int fd_out, char *path)
d284 1
a284 1
	u_int type, id, handle_len, i, expected_id;
d301 7
d362 12
a373 1
			printf("%s\n", longname);
d388 24
d918 1
@


1.11.2.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d250 2
a251 1
	return(0);
d487 1
a487 2
	send_string_request(fd_out, id, SSH2_FXP_REALPATH, path,
	    strlen(path));
d549 73
@


1.11.2.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.15 2001/03/19 10:52:51 djm Exp $");
d80 1
a80 3
	if (len == 0)
		fatal("Connection closed");
	else if (len == -1)
d89 1
a89 3
		if (len == 0)
			fatal("Connection closed");
		else if (len == -1)
d183 1
a183 1
get_decode_stat(int fd, u_int expected_id, int quiet)
d201 1
a201 4
		if (quiet)
			debug("Couldn't stat remote file: %s", fx2txt(status));
		else
			error("Couldn't stat remote file: %s", fx2txt(status));
d250 1
a250 2

	return(version);
a276 1

d278 1
a278 2
do_lsreaddir(int fd_in, int fd_out, char *path, int printflag, 
    SFTP_DIRENT ***dir)
d281 1
a281 1
	u_int type, id, handle_len, i, expected_id, ents = 0;
a297 7
	if (dir) {
		ents = 0;
		*dir = xmalloc(sizeof(**dir));
		(*dir)[0] = NULL;
	}
	

d352 1
a352 12
			if (printflag)
				printf("%s\n", longname);

			if (dir) {
				*dir = xrealloc(*dir, sizeof(**dir) * 
				    (ents + 2));
				(*dir)[ents] = xmalloc(sizeof(***dir));
				(*dir)[ents]->filename = xstrdup(filename);
				(*dir)[ents]->longname = xstrdup(longname);
				memcpy(&(*dir)[ents]->a, a, sizeof(*a));
				(*dir)[++ents] = NULL;
			}
a366 24
do_ls(int fd_in, int fd_out, char *path)
{
	return(do_lsreaddir(fd_in, fd_out, path, 1, NULL));
}

int
do_readdir(int fd_in, int fd_out, char *path, SFTP_DIRENT ***dir)
{
	return(do_lsreaddir(fd_in, fd_out, path, 0, dir));
}

void free_sftp_dirents(SFTP_DIRENT **s)
{
	int i;
	
	for(i = 0; s[i]; i++) {
		xfree(s[i]->filename);
		xfree(s[i]->longname);
		xfree(s[i]);
	}
	xfree(s);
}

int
d413 1
a413 1
do_stat(int fd_in, int fd_out, char *path, int quiet)
d419 1
a419 1
	return(get_decode_stat(fd_in, id, quiet));
d423 1
a423 1
do_lstat(int fd_in, int fd_out, char *path, int quiet)
d429 1
a429 1
	return(get_decode_stat(fd_in, id, quiet));
d433 2
a434 1
do_fstat(int fd_in, int fd_out, char *handle, u_int handle_len, int quiet)
d440 1
a440 1
	return(get_decode_stat(fd_in, id, quiet));
d486 2
a487 1
	send_string_request(fd_out, id, SSH2_FXP_REALPATH, path, strlen(path));
a551 73
do_symlink(int fd_in, int fd_out, char *oldpath, char *newpath)
{
	Buffer msg;
	u_int status, id;

	buffer_init(&msg);

	/* Send rename request */
	id = msg_id++;
	buffer_put_char(&msg, SSH2_FXP_SYMLINK);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, oldpath);
	buffer_put_cstring(&msg, newpath);
	send_msg(fd_out, &msg);
	debug3("Sent message SSH2_FXP_SYMLINK \"%s\" -> \"%s\"", oldpath,
	    newpath);
	buffer_free(&msg);

	status = get_status(fd_in, id);
	if (status != SSH2_FX_OK)
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath, newpath,
		    fx2txt(status));

	return(status);
}

char *
do_readlink(int fd_in, int fd_out, char *path)
{
	Buffer msg;
	u_int type, expected_id, count, id;
	char *filename, *longname;
	Attrib *a;

	expected_id = id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_READLINK, path, strlen(path));

	buffer_init(&msg);

	get_msg(fd_in, &msg);
	type = buffer_get_char(&msg);
	id = buffer_get_int(&msg);

	if (id != expected_id)
		fatal("ID mismatch (%d != %d)", id, expected_id);

	if (type == SSH2_FXP_STATUS) {
		u_int status = buffer_get_int(&msg);

		error("Couldn't readlink: %s", fx2txt(status));
		return(NULL);
	} else if (type != SSH2_FXP_NAME)
		fatal("Expected SSH2_FXP_NAME(%d) packet, got %d",
		    SSH2_FXP_NAME, type);

	count = buffer_get_int(&msg);
	if (count != 1)
		fatal("Got multiple names (%d) from SSH_FXP_READLINK", count);

	filename = buffer_get_string(&msg, NULL);
	longname = buffer_get_string(&msg, NULL);
	a = decode_attrib(&msg);

	debug3("SSH_FXP_READLINK %s -> %s", path, filename);

	xfree(longname);

	buffer_free(&msg);

	return(filename);
}

int
d563 1
a563 1
	a = do_stat(fd_in, fd_out, remote_path, 0);
a572 6
	if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
	    (a->perm & S_IFDIR)) {
		error("Cannot download a directory: %s", remote_path);
		return(-1);
	}

d577 1
a577 1
		return(-1);
a800 1

@


1.10
log
@Fix and document 'preserve modes & times' option ('-p' flag in sftp);
ok markus@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.9 2001/02/10 00:41:46 djm Exp $");
d250 2
a251 1
	return(0);
d487 1
a487 2
	send_string_request(fd_out, id, SSH2_FXP_REALPATH, path,
	    strlen(path));
d549 73
@


1.10.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.10 2001/02/14 09:46:03 djm Exp $");
@


1.10.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.10.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.15 2001/03/19 10:52:51 djm Exp $");
d80 1
a80 3
	if (len == 0)
		fatal("Connection closed");
	else if (len == -1)
d89 1
a89 3
		if (len == 0)
			fatal("Connection closed");
		else if (len == -1)
d183 1
a183 1
get_decode_stat(int fd, u_int expected_id, int quiet)
d201 1
a201 4
		if (quiet)
			debug("Couldn't stat remote file: %s", fx2txt(status));
		else
			error("Couldn't stat remote file: %s", fx2txt(status));
d250 1
a250 2

	return(version);
a276 1

d278 1
a278 2
do_lsreaddir(int fd_in, int fd_out, char *path, int printflag, 
    SFTP_DIRENT ***dir)
d281 1
a281 1
	u_int type, id, handle_len, i, expected_id, ents = 0;
a297 7
	if (dir) {
		ents = 0;
		*dir = xmalloc(sizeof(**dir));
		(*dir)[0] = NULL;
	}
	

d352 1
a352 12
			if (printflag)
				printf("%s\n", longname);

			if (dir) {
				*dir = xrealloc(*dir, sizeof(**dir) * 
				    (ents + 2));
				(*dir)[ents] = xmalloc(sizeof(***dir));
				(*dir)[ents]->filename = xstrdup(filename);
				(*dir)[ents]->longname = xstrdup(longname);
				memcpy(&(*dir)[ents]->a, a, sizeof(*a));
				(*dir)[++ents] = NULL;
			}
a366 24
do_ls(int fd_in, int fd_out, char *path)
{
	return(do_lsreaddir(fd_in, fd_out, path, 1, NULL));
}

int
do_readdir(int fd_in, int fd_out, char *path, SFTP_DIRENT ***dir)
{
	return(do_lsreaddir(fd_in, fd_out, path, 0, dir));
}

void free_sftp_dirents(SFTP_DIRENT **s)
{
	int i;
	
	for(i = 0; s[i]; i++) {
		xfree(s[i]->filename);
		xfree(s[i]->longname);
		xfree(s[i]);
	}
	xfree(s);
}

int
d413 1
a413 1
do_stat(int fd_in, int fd_out, char *path, int quiet)
d419 1
a419 1
	return(get_decode_stat(fd_in, id, quiet));
d423 1
a423 1
do_lstat(int fd_in, int fd_out, char *path, int quiet)
d429 1
a429 1
	return(get_decode_stat(fd_in, id, quiet));
d433 2
a434 1
do_fstat(int fd_in, int fd_out, char *handle, u_int handle_len, int quiet)
d440 1
a440 1
	return(get_decode_stat(fd_in, id, quiet));
d486 2
a487 1
	send_string_request(fd_out, id, SSH2_FXP_REALPATH, path, strlen(path));
a551 73
do_symlink(int fd_in, int fd_out, char *oldpath, char *newpath)
{
	Buffer msg;
	u_int status, id;

	buffer_init(&msg);

	/* Send rename request */
	id = msg_id++;
	buffer_put_char(&msg, SSH2_FXP_SYMLINK);
	buffer_put_int(&msg, id);
	buffer_put_cstring(&msg, oldpath);
	buffer_put_cstring(&msg, newpath);
	send_msg(fd_out, &msg);
	debug3("Sent message SSH2_FXP_SYMLINK \"%s\" -> \"%s\"", oldpath,
	    newpath);
	buffer_free(&msg);

	status = get_status(fd_in, id);
	if (status != SSH2_FX_OK)
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath, newpath,
		    fx2txt(status));

	return(status);
}

char *
do_readlink(int fd_in, int fd_out, char *path)
{
	Buffer msg;
	u_int type, expected_id, count, id;
	char *filename, *longname;
	Attrib *a;

	expected_id = id = msg_id++;
	send_string_request(fd_out, id, SSH2_FXP_READLINK, path, strlen(path));

	buffer_init(&msg);

	get_msg(fd_in, &msg);
	type = buffer_get_char(&msg);
	id = buffer_get_int(&msg);

	if (id != expected_id)
		fatal("ID mismatch (%d != %d)", id, expected_id);

	if (type == SSH2_FXP_STATUS) {
		u_int status = buffer_get_int(&msg);

		error("Couldn't readlink: %s", fx2txt(status));
		return(NULL);
	} else if (type != SSH2_FXP_NAME)
		fatal("Expected SSH2_FXP_NAME(%d) packet, got %d",
		    SSH2_FXP_NAME, type);

	count = buffer_get_int(&msg);
	if (count != 1)
		fatal("Got multiple names (%d) from SSH_FXP_READLINK", count);

	filename = buffer_get_string(&msg, NULL);
	longname = buffer_get_string(&msg, NULL);
	a = decode_attrib(&msg);

	debug3("SSH_FXP_READLINK %s -> %s", path, filename);

	xfree(longname);

	buffer_free(&msg);

	return(filename);
}

int
d563 1
a563 1
	a = do_stat(fd_in, fd_out, remote_path, 0);
a572 6
	if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
	    (a->perm & S_IFDIR)) {
		error("Cannot download a directory: %s", remote_path);
		return(-1);
	}

d577 1
a577 1
		return(-1);
a800 1

@


1.10.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.16 2001/04/05 10:42:52 markus Exp $");
d287 1
a287 1
do_lsreaddir(int fd_in, int fd_out, char *path, int printflag,
d373 1
a373 1
				*dir = xrealloc(*dir, sizeof(**dir) *
@


1.10.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.18 2001/07/14 15:10:16 stevesk Exp $");
d34 1
d41 1
d54 1
a54 1
static void
d73 1
a73 1
static void
d101 1
a101 1
static void
d116 1
a116 1
static void
d132 1
a132 1
static u_int
d157 1
a157 1
static char *
d186 1
a186 1
static Attrib *
d286 1
a286 1
static int
@


1.10.2.6
log
@Merge OpenSSH 3.1.
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d27 2
a28 1
/* XXX: remove all logging, only return status codes */
d32 1
a32 3
RCSID("$OpenBSD: sftp-client.c,v 1.24 2002/02/24 16:57:19 markus Exp $");

#include <sys/queue.h>
d45 3
a47 2
/* Minimum amount of data to read at at time */
#define MIN_READ_SIZE	512
d49 2
a50 8
struct sftp_conn {
	int fd_in;
	int fd_out;
	u_int transfer_buflen;
	u_int num_requests;
	u_int version;
	u_int msg_id;
};
d218 2
a219 2
struct sftp_conn *
do_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests)
a222 1
	struct sftp_conn *ret;
d238 1
a238 1
		return(NULL);
d256 1
a256 19
	ret = xmalloc(sizeof(*ret));
	ret->fd_in = fd_in;
	ret->fd_out = fd_out;
	ret->transfer_buflen = transfer_buflen;
	ret->num_requests = num_requests;
	ret->version = version;
	ret->msg_id = 1;

	/* Some filexfer v.0 servers don't support large packets */
	if (version == 0)
		ret->transfer_buflen = MAX(ret->transfer_buflen, 20480);

	return(ret);
}

u_int
sftp_proto_version(struct sftp_conn *conn)
{
	return(conn->version);
d260 1
a260 1
do_close(struct sftp_conn *conn, char *handle, u_int handle_len)
d267 1
a267 1
	id = conn->msg_id++;
d271 1
a271 1
	send_msg(conn->fd_out, &msg);
d274 1
a274 1
	status = get_status(conn->fd_in, id);
d285 1
a285 1
do_lsreaddir(struct sftp_conn *conn, char *path, int printflag,
d292 1
a292 1
	id = conn->msg_id++;
d298 1
a298 1
	send_msg(conn->fd_out, &msg);
d302 1
a302 1
	handle = get_handle(conn->fd_in, id, &handle_len);
d311 1
d313 1
a313 1
	for (;;) {
d316 1
a316 1
		id = expected_id = conn->msg_id++;
d324 1
a324 1
		send_msg(conn->fd_out, &msg);
d328 1
a328 1
		get_msg(conn->fd_in, &msg);
d348 1
a348 1
				do_close(conn, handle, handle_len);
d359 1
a359 1
		for (i = 0; i < count; i++) {
d386 1
a386 1
	do_close(conn, handle, handle_len);
d393 1
a393 1
do_ls(struct sftp_conn *conn, char *path)
d395 1
a395 1
	return(do_lsreaddir(conn, path, 1, NULL));
d399 1
a399 1
do_readdir(struct sftp_conn *conn, char *path, SFTP_DIRENT ***dir)
d401 1
a401 1
	return(do_lsreaddir(conn, path, 0, dir));
d407 2
a408 2

	for (i = 0; s[i]; i++) {
d417 1
a417 1
do_rm(struct sftp_conn *conn, char *path)
d423 3
a425 4
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_REMOVE, path, 
	    strlen(path));
	status = get_status(conn->fd_in, id);
d432 1
a432 1
do_mkdir(struct sftp_conn *conn, char *path, Attrib *a)
d436 2
a437 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_MKDIR, path,
d440 1
a440 1
	status = get_status(conn->fd_in, id);
d448 1
a448 1
do_rmdir(struct sftp_conn *conn, char *path)
d452 2
a453 3
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_RMDIR, path,
	    strlen(path));
d455 1
a455 1
	status = get_status(conn->fd_in, id);
d463 1
a463 1
do_stat(struct sftp_conn *conn, char *path, int quiet)
d467 3
a469 7
	id = conn->msg_id++;

	send_string_request(conn->fd_out, id, 
	    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT, 
	    path, strlen(path));

	return(get_decode_stat(conn->fd_in, id, quiet));
d473 1
a473 1
do_lstat(struct sftp_conn *conn, char *path, int quiet)
d477 3
a479 13
	if (conn->version == 0) {
		if (quiet)
			debug("Server version does not support lstat operation");
		else
			error("Server version does not support lstat operation");
		return(NULL);
	}

	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_LSTAT, path,
	    strlen(path));

	return(get_decode_stat(conn->fd_in, id, quiet));
d483 1
a483 1
do_fstat(struct sftp_conn *conn, char *handle, u_int handle_len, int quiet)
d487 3
a489 5
	id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_FSTAT, handle,
	    handle_len);

	return(get_decode_stat(conn->fd_in, id, quiet));
d493 1
a493 1
do_setstat(struct sftp_conn *conn, char *path, Attrib *a)
d497 2
a498 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_SETSTAT, path,
d501 1
a501 1
	status = get_status(conn->fd_in, id);
d510 1
a510 1
do_fsetstat(struct sftp_conn *conn, char *handle, u_int handle_len,
d515 2
a516 2
	id = conn->msg_id++;
	send_string_attrs_request(conn->fd_out, id, SSH2_FXP_FSETSTAT, handle,
d519 1
a519 1
	status = get_status(conn->fd_in, id);
d527 1
a527 1
do_realpath(struct sftp_conn *conn, char *path)
d534 2
a535 3
	expected_id = id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_REALPATH, path,
	    strlen(path));
d539 1
a539 1
	get_msg(conn->fd_in, &msg);
d573 1
a573 1
do_rename(struct sftp_conn *conn, char *oldpath, char *newpath)
d581 1
a581 1
	id = conn->msg_id++;
d586 1
a586 1
	send_msg(conn->fd_out, &msg);
d591 1
a591 1
	status = get_status(conn->fd_in, id);
d593 2
a594 2
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));
d600 1
a600 1
do_symlink(struct sftp_conn *conn, char *oldpath, char *newpath)
a604 5
	if (conn->version < 3) {
		error("This server does not support the symlink operation");
		return(SSH2_FX_OP_UNSUPPORTED);
	}

d608 1
a608 1
	id = conn->msg_id++;
d613 1
a613 1
	send_msg(conn->fd_out, &msg);
d618 1
a618 1
	status = get_status(conn->fd_in, id);
d620 2
a621 2
		error("Couldn't rename file \"%s\" to \"%s\": %s", oldpath,
		    newpath, fx2txt(status));
d627 1
a627 1
do_readlink(struct sftp_conn *conn, char *path)
d634 2
a635 3
	expected_id = id = conn->msg_id++;
	send_string_request(conn->fd_out, id, SSH2_FXP_READLINK, path,
	    strlen(path));
d639 1
a639 1
	get_msg(conn->fd_in, &msg);
a671 17
static void
send_read_request(int fd_out, u_int id, u_int64_t offset, u_int len,
    char *handle, u_int handle_len)
{
	Buffer msg;
	
	buffer_init(&msg);
	buffer_clear(&msg);
	buffer_put_char(&msg, SSH2_FXP_READ);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, handle, handle_len);
	buffer_put_int64(&msg, offset);
	buffer_put_int(&msg, len);
	send_msg(fd_out, &msg);
	buffer_free(&msg);
}	

d673 1
a673 1
do_download(struct sftp_conn *conn, char *remote_path, char *local_path,
d676 5
d682 1
a682 14
	Buffer msg;
	char *handle;
	int local_fd, status, num_req, max_req, write_error;
	int read_error, write_errno;
	u_int64_t offset, size;
	u_int handle_len, mode, type, id, buflen;
	struct request {
		u_int id;
		u_int len;
		u_int64_t offset;
		TAILQ_ENTRY(request) tq; 
	};
	TAILQ_HEAD(reqhead, request) requests;
	struct request *req;
d684 1
a684 3
	TAILQ_INIT(&requests);

	a = do_stat(conn, remote_path, 0);
d700 6
a705 4
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE)
		size = a->size;
	else
		size = 0;
a706 1
	buflen = conn->transfer_buflen;
d710 1
a710 1
	id = conn->msg_id++;
d717 1
a717 1
	send_msg(conn->fd_out, &msg);
d720 1
a720 1
	handle = get_handle(conn->fd_in, id, &handle_len);
d723 1
a723 9
		return(-1);
	}

	local_fd = open(local_path, O_WRONLY | O_CREAT | O_TRUNC, mode);
	if (local_fd == -1) {
		error("Couldn't open local file \"%s\" for writing: %s",
		    local_path, strerror(errno));
		buffer_free(&msg);
		xfree(handle);
d728 3
a730 3
	write_error = read_error = write_errno = num_req = offset = 0;
	max_req = 1;
	while (num_req > 0 || max_req > 0) {
a731 1
		u_int len;
d733 11
a743 14
		/* Send some more requests */
		while (num_req < max_req) {
			debug3("Request range %llu -> %llu (%d/%d)", 
			    offset, offset + buflen - 1, num_req, max_req);
			req = xmalloc(sizeof(*req));
			req->id = conn->msg_id++;
			req->len = buflen;
			req->offset = offset;
			offset += buflen;
			num_req++;
			TAILQ_INSERT_TAIL(&requests, req, tq);
			send_read_request(conn->fd_out, req->id, req->offset, 
			    req->len, handle, handle_len);
		}
d746 2
a747 1
		get_msg(conn->fd_in, &msg);
d750 4
a753 12
		debug3("Received reply T:%d I:%d R:%d", type, id, max_req);

		/* Find the request in our queue */
		for(req = TAILQ_FIRST(&requests);
		    req != NULL && req->id != id;
		    req = TAILQ_NEXT(req, tq))
			;
		if (req == NULL)
			fatal("Unexpected reply %u", id);

		switch (type) {
		case SSH2_FXP_STATUS:
a754 22
			if (status != SSH2_FX_EOF)
				read_error = 1;
			max_req = 0;
			TAILQ_REMOVE(&requests, req, tq);
			xfree(req);
			num_req--;
			break;
		case SSH2_FXP_DATA:
			data = buffer_get_string(&msg, &len);
			debug3("Received data %llu -> %llu", req->offset, 
			    req->offset + len - 1);
			if (len > req->len)
				fatal("Received more data than asked for "
				      "%d > %d", len, req->len);
			if ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||
			     atomicio(write, local_fd, data, len) != len) &&
			    !write_error) {
				write_errno = errno;
				write_error = 1;
				max_req = 0;
			}
			xfree(data);
d756 8
a763 17
			if (len == req->len) {
				TAILQ_REMOVE(&requests, req, tq);
				xfree(req);
				num_req--;
			} else {
				/* Resend the request for the missing data */
				debug3("Short data block, re-requesting "
				    "%llu -> %llu (%2d)", req->offset + len, 
					req->offset + req->len - 1, num_req);
				req->id = conn->msg_id++;
				req->len -= len;
				req->offset += len;
				send_read_request(conn->fd_out, req->id, 
				    req->offset, req->len, handle, handle_len);
				/* Reduce the request size */
				if (len < buflen)
					buflen = MAX(MIN_READ_SIZE, len);
d765 1
a765 14
			if (max_req > 0) { /* max_req = 0 iff EOF received */
				if (size > 0 && offset > size) {
					/* Only one request at a time
					 * after the expected EOF */
					debug3("Finish at %llu (%2d)",
					    offset, num_req);
					max_req = 1;
				}
				else if (max_req < conn->num_requests + 1) {
					++max_req;
				}
			}
			break;
		default:
d769 19
d789 1
d791 12
a802 29
	/* Sanity check */
	if (TAILQ_FIRST(&requests) != NULL)
		fatal("Transfer complete, but requests still in queue");

	if (read_error) {
		error("Couldn't read from remote file \"%s\" : %s", 
		    remote_path, fx2txt(status));
		do_close(conn, handle, handle_len);
	} else if (write_error) {
		error("Couldn't write to \"%s\": %s", local_path,
		    strerror(write_errno));
		status = -1;
		do_close(conn, handle, handle_len);
	} else {
		status = do_close(conn, handle, handle_len);

		/* Override umask and utimes if asked */
		if (pflag && fchmod(local_fd, mode) == -1)
			error("Couldn't set mode on \"%s\": %s", local_path,
			      strerror(errno));
		if (pflag && (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {
			struct timeval tv[2];
			tv[0].tv_sec = a->atime;
			tv[1].tv_sec = a->mtime;
			tv[0].tv_usec = tv[1].tv_usec = 0;
			if (utimes(local_path, tv) == -1)
				error("Can't set times on \"%s\": %s",
				      local_path, strerror(errno));
		}
d804 2
d809 1
a809 2

	return(status);
d813 1
a813 1
do_upload(struct sftp_conn *conn, char *local_path, char *remote_path,
d816 2
a817 2
	int local_fd, status;
	u_int handle_len, id, type;
d819 1
a819 1
	char *handle, *data;
d823 1
a823 12
	u_int32_t startid;
	u_int32_t ackid;
	struct outstanding_ack {
		u_int id;
		u_int len;
		u_int64_t offset;
		TAILQ_ENTRY(outstanding_ack) tq; 
	};
	TAILQ_HEAD(ackhead, outstanding_ack) acks;
	struct outstanding_ack *ack;

	TAILQ_INIT(&acks);
d847 1
a847 1
	id = conn->msg_id++;
d853 1
a853 1
	send_msg(conn->fd_out, &msg);
d858 1
a858 1
	handle = get_handle(conn->fd_in, id, &handle_len);
a864 3
	startid = ackid = id + 1;
	data = xmalloc(conn->transfer_buflen);

d867 1
a867 1
	for (;;) {
d869 1
d876 1
a876 1
			len = read(local_fd, data, conn->transfer_buflen);
d882 1
a882 18

		if (len != 0) {
			ack = xmalloc(sizeof(*ack));
			ack->id = ++id;
			ack->offset = offset;
			ack->len = len;
			TAILQ_INSERT_TAIL(&acks, ack, tq);

			buffer_clear(&msg);
			buffer_put_char(&msg, SSH2_FXP_WRITE);
			buffer_put_int(&msg, ack->id);
			buffer_put_string(&msg, handle, handle_len);
			buffer_put_int64(&msg, offset);
			buffer_put_string(&msg, data, len);
			send_msg(conn->fd_out, &msg);
			debug3("Sent message SSH2_FXP_WRITE I:%d O:%llu S:%u",
			       id, (u_int64_t)offset, len);
		} else if (TAILQ_FIRST(&acks) == NULL)
d885 20
a904 13
		if (ack == NULL)
			fatal("Unexpected ACK %u", id);

		if (id == startid || len == 0 || 
		    id - ackid >= conn->num_requests) {
			buffer_clear(&msg);
			get_msg(conn->fd_in, &msg);
			type = buffer_get_char(&msg);
			id = buffer_get_int(&msg);

			if (type != SSH2_FXP_STATUS)
				fatal("Expected SSH2_FXP_STATUS(%d) packet, "
				    "got %d", SSH2_FXP_STATUS, type);
a905 24
			status = buffer_get_int(&msg);
			debug3("SSH2_FXP_STATUS %d", status);

			/* Find the request in our queue */
			for(ack = TAILQ_FIRST(&acks);
			    ack != NULL && ack->id != id;
			    ack = TAILQ_NEXT(ack, tq))
				;
			if (ack == NULL)
				fatal("Can't find request for ID %d", id);
			TAILQ_REMOVE(&acks, ack, tq);

			if (status != SSH2_FX_OK) {
				error("Couldn't write to remote file \"%s\": %s",
				      remote_path, fx2txt(status));
				do_close(conn, handle, handle_len);
				close(local_fd);
				goto done;
			}
			debug3("In write loop, ack for %u %d bytes at %llu", 
			   ack->id, ack->len, ack->offset);
			++ackid;
			free(ack);
		}
a907 1
	xfree(data);
d912 1
a912 1
		do_close(conn, handle, handle_len);
d919 1
a919 1
		do_fsetstat(conn, handle, handle_len, &a);
d921 1
a921 1
	status = do_close(conn, handle, handle_len);
d926 1
a926 1
	return(status);
d928 1
@


1.9
log
@typo; ok Niels
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.8 2001/02/08 17:11:23 stevesk Exp $");
a579 14
	/* Override umask and utimes if asked */
	if (pflag && fchmod(local_fd, mode) == -1)
		error("Couldn't set mode on \"%s\": %s", local_path,
		    strerror(errno));
	if (pflag && (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {
		struct timeval tv;

		tv.tv_sec = a->atime;
		tv.tv_usec = a->mtime;
		if (utimes(local_path, &tv) == -1)
			error("Can't set times on \"%s\": %s", local_path,
			    strerror(errno));
	}

d664 14
a737 4
	/* Override umask and utimes if asked */
	if (pflag)
		do_fsetstat(fd_in, fd_out, handle, handle_len, &a);

d790 4
a800 2


@


1.8
log
@%i -> %d
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.7 2001/02/07 21:58:34 markus Exp $");
d334 1
a334 1
				return(NULL);
@


1.7
log
@older servers reply with SSH2_FXP_NAME + count==0 instead of EOF
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.6 2001/02/07 18:01:18 itojun Exp $");
d343 1
a343 1
		debug3("Received %i SSH2_FXP_NAME responses", count);
@


1.6
log
@unsigned long long -> %llu, not %qu.  markus ok
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.5 2001/02/07 10:55:12 djm Exp $");
d341 2
@


1.5
log
@Don't free handles before we are done with them. Based on work from
Corinna Vinschen <vinschen@@redhat.com>. ok markus@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.4 2001/02/06 23:30:28 djm Exp $");
d660 1
a660 1
		debug3("In read loop, got %d offset %lld", len,
@


1.4
log
@replace arc4random with counter for request ids; ok markus@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.3 2001/02/04 15:32:25 stevesk Exp $");
d559 1
d639 1
a639 1
			int status = buffer_get_int(&msg);
d648 1
a648 4
				xfree(handle);
				close(local_fd);
				buffer_free(&msg);
				return(status);
d666 1
a666 2
			xfree(handle);
			close(local_fd);
d668 1
a668 2
			buffer_free(&msg);
			return(-1);
d674 5
d680 1
a680 4
	buffer_free(&msg);
	close(local_fd);

	return(do_close(fd_in, fd_out, handle, handle_len));
d694 1
a744 1
		u_int status;
a774 1
			xfree(handle);
d776 1
a776 1
			return(-1);
a782 2
	xfree(handle);
	buffer_free(&msg);
d788 2
a789 1
		return(-1);
d792 6
a797 1
	return(do_close(fd_in, fd_out, handle, handle_len));
d799 2
@


1.3
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.2 2001/02/04 15:23:08 deraadt Exp $");
d51 3
d261 1
a261 1
	id = arc4random();
d284 1
a284 1
	id = arc4random();
d301 1
a301 1
		expected_id = ++id;
d371 1
a371 1
	id = arc4random();
d384 1
a384 1
	id = arc4random();
d400 1
a400 1
	id = arc4random();
d415 1
a415 1
	id = arc4random();
d425 1
a425 1
	id = arc4random();
d436 1
a436 1
	id = arc4random();
d446 1
a446 1
	id = arc4random();
d464 1
a464 1
	id = arc4random();
d483 1
a483 1
	expected_id = id = arc4random();
d531 1
a531 1
	id = arc4random();
d594 1
a594 1
	id = arc4random();
d617 1
a617 1
		expected_id = ++id;
d719 1
a719 1
	id = arc4random();
@


1.2
log
@make gcc on the alpha even happier
@
text
@d32 1
a32 1
RCSID("$OpenBSD: sftp-client.c,v 1.1 2001/02/04 11:11:54 djm Exp $");
d225 1
a225 1
 	/* Expecting a VERSION reply */
@


1.1
log
@Basic interactive sftp client; ok theo@@
@
text
@d32 1
a32 1
RCSID("$OpenBSD$");
d624 1
a624 1
		    id, offset, COPY_SIZE);
d659 2
a660 1
		debug3("In read loop, got %d offset %lld", len, offset);
d767 1
a767 1
		    id, offset, len);
d778 2
a779 1
		debug3("In write loop, got %d offset %lld", len, offset);
@

