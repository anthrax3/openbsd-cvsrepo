head	1.25;
access;
symbols
	OPENBSD_6_0:1.25.0.12
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.8
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.10
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.8
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.11.0.12
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.10
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2014.04.30.05.29.56;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.12.08.13.13;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2013.07.12.00.19.58;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.09.03.56.28;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.12.01.36.08;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.08.06.59.01;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.16.00.48.52;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.25.22.22.42;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.14.11.46.56;	author markus;	state Exp;
branches
	1.13.4.1
	1.13.6.1;
next	1.12;

1.12
date	2004.10.29.23.56.17;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.04.17.27.39;	author stevesk;	state Exp;
branches
	1.11.10.1
	1.11.12.1;
next	1.10;

1.10
date	2001.12.19.17.16.13;	author stevesk;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.26.17.27.23;	author markus;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.06.26.06.32.48;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.06.20.01.39.39;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.11.24.19.53.44;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.34;	author deraadt;	state Exp;
branches;
next	;

1.4.2.1
date	2000.09.01.18.23.18;	author jason;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2000.11.08.21.30.31;	author jason;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.03.12.15.44.08;	author jason;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.03.21.18.52.37;	author jason;	state Exp;
branches;
next	;

1.6.2.1
date	2001.02.16.20.12.56;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.02.19.17.18.43;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.03.21.19.46.23;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.05.07.21.09.27;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.7.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.9.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	;

1.11.10.1
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.11.12.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.11.12.2;

1.11.12.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	;

1.13.4.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.13.6.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.25
log
@New buffer API; the first installment of the conversion/replacement
of OpenSSH's internals to make them usable as a standalone library.

This includes a set of wrappers to make it compatible with the
existing buffer API so replacement can occur incrementally.

With and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review.
@
text
@/* $OpenBSD: buffer.h,v 1.24 2014/04/28 03:09:18 djm Exp $ */

/*
 * Copyright (c) 2012 Damien Miller <djm@@mindrot.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Emulation wrappers for legacy OpenSSH buffer API atop sshbuf */

#ifndef BUFFER_H
#define BUFFER_H

#include "sshbuf.h"

typedef struct sshbuf Buffer;

#define buffer_init(b)		sshbuf_init(b)
#define buffer_clear(b)		sshbuf_reset(b)
#define buffer_free(b)		sshbuf_free(b)
#define buffer_dump(b)		sshbuf_dump(b, stderr)

/* XXX cast is safe: sshbuf never stores more than len 2^31 */
#define buffer_len(b)		((u_int) sshbuf_len(b))
#define	buffer_ptr(b)		sshbuf_mutable_ptr(b)

void	 buffer_append(Buffer *, const void *, u_int);
void	*buffer_append_space(Buffer *, u_int);
int	 buffer_check_alloc(Buffer *, u_int);
void	 buffer_get(Buffer *, void *, u_int);

void	 buffer_consume(Buffer *, u_int);
void	 buffer_consume_end(Buffer *, u_int);


int	 buffer_get_ret(Buffer *, void *, u_int);
int	 buffer_consume_ret(Buffer *, u_int);
int	 buffer_consume_end_ret(Buffer *, u_int);

void    buffer_put_bignum(Buffer *, const BIGNUM *);
void    buffer_put_bignum2(Buffer *, const BIGNUM *);
void	buffer_get_bignum(Buffer *, BIGNUM *);
void	buffer_get_bignum2(Buffer *, BIGNUM *);
void	buffer_put_bignum2_from_string(Buffer *, const u_char *, u_int);

u_short	buffer_get_short(Buffer *);
void	buffer_put_short(Buffer *, u_short);

u_int	buffer_get_int(Buffer *);
void    buffer_put_int(Buffer *, u_int);

u_int64_t buffer_get_int64(Buffer *);
void	buffer_put_int64(Buffer *, u_int64_t);

int     buffer_get_char(Buffer *);
void    buffer_put_char(Buffer *, int);

void   *buffer_get_string(Buffer *, u_int *);
const void *buffer_get_string_ptr(Buffer *, u_int *);
void    buffer_put_string(Buffer *, const void *, u_int);
char   *buffer_get_cstring(Buffer *, u_int *);
void	buffer_put_cstring(Buffer *, const char *);

#define buffer_skip_string(b) (void)buffer_get_string_ptr(b, NULL);

int	buffer_put_bignum_ret(Buffer *, const BIGNUM *);
int	buffer_get_bignum_ret(Buffer *, BIGNUM *);
int	buffer_put_bignum2_ret(Buffer *, const BIGNUM *);
int	buffer_get_bignum2_ret(Buffer *, BIGNUM *);
int	buffer_get_short_ret(u_short *, Buffer *);
int	buffer_get_int_ret(u_int *, Buffer *);
int	buffer_get_int64_ret(u_int64_t *, Buffer *);
void	*buffer_get_string_ret(Buffer *, u_int *);
char	*buffer_get_cstring_ret(Buffer *, u_int *);
const void *buffer_get_string_ptr_ret(Buffer *, u_int *);
int	buffer_get_char_ret(char *, Buffer *);

int	buffer_put_ecpoint_ret(Buffer *, const EC_GROUP *, const EC_POINT *);
void	buffer_put_ecpoint(Buffer *, const EC_GROUP *, const EC_POINT *);
int	buffer_get_ecpoint_ret(Buffer *, const EC_GROUP *, EC_POINT *);
void	buffer_get_ecpoint(Buffer *, const EC_GROUP *, EC_POINT *);

#endif	/* BUFFER_H */

@


1.24
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.23 2014/01/12 08:13:13 djm Exp $ */
d4 1
a4 4
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Code for manipulating FIFO buffers.
d6 11
a16 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d19 2
d24 3
a26 10
typedef struct {
	u_char	*buf;		/* Buffer for data. */
	u_int	 alloc;		/* Number of bytes allocated for data. */
	u_int	 offset;	/* Offset of first byte containing data. */
	u_int	 end;		/* Offset of last byte containing data. */
}       Buffer;

void	 buffer_init(Buffer *);
void	 buffer_clear(Buffer *);
void	 buffer_free(Buffer *);
d28 8
a35 2
u_int	 buffer_len(const Buffer *);
void	*buffer_ptr(const Buffer *);
a38 1

a39 1

a44 1
void     buffer_dump(const Buffer *);
a49 2
#include <openssl/bn.h>

d54 1
d74 1
a74 2
#define buffer_skip_string(b) \
    do { u_int l = buffer_get_int(b); buffer_consume(b, l); } while (0)
d86 1
a86 7
int	buffer_get_char_ret(u_char *, Buffer *);

void *buffer_get_bignum2_as_string_ret(Buffer *, u_int *);
void *buffer_get_bignum2_as_string(Buffer *, u_int *);
void  buffer_put_bignum2_from_string(Buffer *, const u_char *, u_int);

#include <openssl/ec.h>
d93 2
a94 1
#endif				/* BUFFER_H */
@


1.23
log
@avoid use of OpenSSL BIGNUM type and functions for KEX with
Curve25519 by adding a buffer_put_bignum2_from_string() that stores
a string using the bignum encoding rules. Will make it easier to
build a reduced-feature OpenSSH without OpenSSL in the future;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.22 2013/07/12 00:19:58 djm Exp $ */
d69 1
a69 1
void   *buffer_get_string_ptr(Buffer *, u_int *);
d86 1
a86 1
void	*buffer_get_string_ptr_ret(Buffer *, u_int *);
@


1.22
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.21 2010/08/31 11:54:45 djm Exp $ */
d88 4
@


1.21
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.20 2010/08/31 09:58:37 djm Exp $ */
d87 1
a87 1
int	buffer_get_char_ret(char *, Buffer *);
@


1.20
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.19 2010/02/09 03:56:28 djm Exp $ */
d88 7
@


1.19
log
@constify the arguments to buffer_len, buffer_ptr and buffer_dump
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.18 2010/01/12 01:36:08 djm Exp $ */
d71 1
d85 1
@


1.18
log
@add a buffer_get_string_ptr_ret() that does the same as
buffer_get_string_ptr() but does not fatal() on error; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.17 2008/05/08 06:59:01 markus Exp $ */
d30 2
a31 2
u_int	 buffer_len(Buffer *);
void	*buffer_ptr(Buffer *);
d43 1
a43 1
void     buffer_dump(Buffer *);
@


1.17
log
@avoid extra malloc/copy/free when receiving data over the net;
~10% speedup for localhost-scp; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.16 2006/08/03 03:34:41 deraadt Exp $ */
d84 1
@


1.16
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.15 2006/04/16 00:48:52 djm Exp $ */
d69 1
@


1.15
log
@Fix condition where we could exit with a fatal error when an input
buffer became too large and the remote end had advertised a big window.
The problem was a mismatch in the backoff math between the channels code
and the buffer code, so make a buffer_check_alloc() function that the
channels code can use to propsectivly check whether an incremental
allocation will succeed.  bz #1131, debugged with the assistance of
cove AT wildpackets.com; ok dtucker@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.14 2006/03/25 22:22:42 djm Exp $ */
d48 36
@


1.14
log
@standardise spacing in $OpenBSD$ tags; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.13 2005/03/14 11:46:56 markus Exp $ */
a25 3
#define	BUFFER_MAX_CHUNK	0x100000
#define	BUFFER_MAX_LEN		0xa00000

d35 2
@


1.13
log
@limit input buffer size for channels; bugzilla #896; with and ok dtucker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.h,v 1.12 2004/10/29 23:56:17 djm Exp $	*/
@


1.13.4.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.16 2006/08/03 03:34:41 deraadt Exp $ */
d26 3
a38 2
int	 buffer_check_alloc(Buffer *, u_int);

a48 36

#include <openssl/bn.h>

void    buffer_put_bignum(Buffer *, const BIGNUM *);
void    buffer_put_bignum2(Buffer *, const BIGNUM *);
void	buffer_get_bignum(Buffer *, BIGNUM *);
void	buffer_get_bignum2(Buffer *, BIGNUM *);

u_short	buffer_get_short(Buffer *);
void	buffer_put_short(Buffer *, u_short);

u_int	buffer_get_int(Buffer *);
void    buffer_put_int(Buffer *, u_int);

u_int64_t buffer_get_int64(Buffer *);
void	buffer_put_int64(Buffer *, u_int64_t);

int     buffer_get_char(Buffer *);
void    buffer_put_char(Buffer *, int);

void   *buffer_get_string(Buffer *, u_int *);
void    buffer_put_string(Buffer *, const void *, u_int);
void	buffer_put_cstring(Buffer *, const char *);

#define buffer_skip_string(b) \
    do { u_int l = buffer_get_int(b); buffer_consume(b, l); } while (0)

int	buffer_put_bignum_ret(Buffer *, const BIGNUM *);
int	buffer_get_bignum_ret(Buffer *, BIGNUM *);
int	buffer_put_bignum2_ret(Buffer *, const BIGNUM *);
int	buffer_get_bignum2_ret(Buffer *, BIGNUM *);
int	buffer_get_short_ret(u_short *, Buffer *);
int	buffer_get_int_ret(u_int *, Buffer *);
int	buffer_get_int64_ret(u_int64_t *, Buffer *);
void	*buffer_get_string_ret(Buffer *, u_int *);
int	buffer_get_char_ret(char *, Buffer *);
@


1.13.6.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.h,v 1.16 2006/08/03 03:34:41 deraadt Exp $ */
d26 3
a38 2
int	 buffer_check_alloc(Buffer *, u_int);

a48 36

#include <openssl/bn.h>

void    buffer_put_bignum(Buffer *, const BIGNUM *);
void    buffer_put_bignum2(Buffer *, const BIGNUM *);
void	buffer_get_bignum(Buffer *, BIGNUM *);
void	buffer_get_bignum2(Buffer *, BIGNUM *);

u_short	buffer_get_short(Buffer *);
void	buffer_put_short(Buffer *, u_short);

u_int	buffer_get_int(Buffer *);
void    buffer_put_int(Buffer *, u_int);

u_int64_t buffer_get_int64(Buffer *);
void	buffer_put_int64(Buffer *, u_int64_t);

int     buffer_get_char(Buffer *);
void    buffer_put_char(Buffer *, int);

void   *buffer_get_string(Buffer *, u_int *);
void    buffer_put_string(Buffer *, const void *, u_int);
void	buffer_put_cstring(Buffer *, const char *);

#define buffer_skip_string(b) \
    do { u_int l = buffer_get_int(b); buffer_consume(b, l); } while (0)

int	buffer_put_bignum_ret(Buffer *, const BIGNUM *);
int	buffer_get_bignum_ret(Buffer *, BIGNUM *);
int	buffer_put_bignum2_ret(Buffer *, const BIGNUM *);
int	buffer_get_bignum2_ret(Buffer *, BIGNUM *);
int	buffer_get_short_ret(u_short *, Buffer *);
int	buffer_get_int_ret(u_int *, Buffer *);
int	buffer_get_int64_ret(u_int64_t *, Buffer *);
void	*buffer_get_string_ret(Buffer *, u_int *);
int	buffer_get_char_ret(char *, Buffer *);
@


1.12
log
@introduce a new buffer API that returns an error rather than fatal()ing when
presented with bad data; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.h,v 1.11 2002/03/04 17:27:39 stevesk Exp $	*/
d25 3
@


1.11
log
@$OpenBSD$ and RCSID() cleanup: don't use RCSID() in .h files; add
missing RCSID() to .c files and remove dup /*$OpenBSD$*/ from .c
files.  ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.h,v 1.10 2001/12/19 17:16:13 stevesk Exp $	*/
d42 4
@


1.11.10.1
log
@upgrade to OpenSSH 4.0
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.h,v 1.12 2004/10/29 23:56:17 djm Exp $	*/
a41 4

int	 buffer_get_ret(Buffer *, void *, u_int);
int	 buffer_consume_ret(Buffer *, u_int);
int	 buffer_consume_end_ret(Buffer *, u_int);
@


1.11.12.1
log
@upgrade to OpenSSH 4.0
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.h,v 1.12 2004/10/29 23:56:17 djm Exp $	*/
a41 4

int	 buffer_get_ret(Buffer *, void *, u_int);
int	 buffer_consume_ret(Buffer *, u_int);
int	 buffer_consume_end_ret(Buffer *, u_int);
@


1.11.12.2
log
@upgrade to OpenSSH 4.1
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.h,v 1.13 2005/03/14 11:46:56 markus Exp $	*/
a24 3

#define	BUFFER_MAX_CHUNK	0x100000
#define	BUFFER_MAX_LEN		0xa00000
@


1.10
log
@change the buffer/packet interface to use void* vs. char*; ok markus@@
@
text
@d1 2
a14 2

/* RCSID("$OpenBSD: buffer.h,v 1.9 2001/06/26 17:27:23 markus Exp $"); */
@


1.9
log
@remove comments from .h, since they are cut&paste from the .c files
and out of sync
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.8 2001/06/26 06:32:48 itojun Exp $"); */
d20 1
a20 1
	char	*buf;		/* Buffer for data. */
d31 1
a31 1
char	*buffer_ptr(Buffer *);
d33 2
a34 2
void	 buffer_append(Buffer *, const char *, u_int);
void	 buffer_append_space(Buffer *, char **, u_int);
d36 1
a36 1
void	 buffer_get(Buffer *, char *, u_int);
@


1.9.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@a0 2
/*	$OpenBSD: buffer.h,v 1.11 2002/03/04 17:27:39 stevesk Exp $	*/

d14 2
d20 1
a20 1
	u_char	*buf;		/* Buffer for data. */
d31 1
a31 1
void	*buffer_ptr(Buffer *);
d33 2
a34 2
void	 buffer_append(Buffer *, const void *, u_int);
void	*buffer_append_space(Buffer *, u_int);
d36 1
a36 1
void	 buffer_get(Buffer *, void *, u_int);
@


1.8
log
@prototype pedant.  not very creative...
- () -> (void)
- no variable names
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.7 2000/12/19 23:17:55 markus Exp $"); */
d20 4
a23 4
	char   *buf;		/* Buffer for data. */
	u_int alloc;	/* Number of bytes allocated for data. */
	u_int offset;	/* Offset of first byte containing data. */
	u_int end;	/* Offset of last byte containing data. */
a24 2
/* Initializes the buffer structure. */
void    buffer_init(Buffer *);
d26 3
a28 2
/* Frees any memory used for the buffer. */
void    buffer_free(Buffer *);
d30 12
a41 34
/* Clears any data from the buffer, making it empty.  This does not actually
   zero the memory. */
void    buffer_clear(Buffer *);

/* Appends data to the buffer, expanding it if necessary. */
void    buffer_append(Buffer *, const char *, u_int);

/*
 * Appends space to the buffer, expanding the buffer if necessary. This does
 * not actually copy the data into the buffer, but instead returns a pointer
 * to the allocated region.
 */
void    buffer_append_space(Buffer *, char **, u_int);

/* Returns the number of bytes of data in the buffer. */
u_int buffer_len(Buffer *);

/* Gets data from the beginning of the buffer. */
void    buffer_get(Buffer *, char *, u_int);

/* Consumes the given number of bytes from the beginning of the buffer. */
void    buffer_consume(Buffer *, u_int);

/* Consumes the given number of bytes from the end of the buffer. */
void    buffer_consume_end(Buffer *, u_int);

/* Returns a pointer to the first used byte in the buffer. */
char   *buffer_ptr(Buffer *);

/*
 * Dumps the contents of the buffer to stderr in hex.  This intended for
 * debugging purposes only.
 */
void    buffer_dump(Buffer *);
@


1.7
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.6 2000/09/07 20:27:50 deraadt Exp $"); */
d26 1
a26 1
void    buffer_init(Buffer * buffer);
d29 1
a29 1
void    buffer_free(Buffer * buffer);
d33 1
a33 1
void    buffer_clear(Buffer * buffer);
d36 1
a36 1
void    buffer_append(Buffer * buffer, const char *data, u_int len);
d43 1
a43 1
void    buffer_append_space(Buffer * buffer, char **datap, u_int len);
d46 1
a46 1
u_int buffer_len(Buffer * buffer);
d49 1
a49 1
void    buffer_get(Buffer * buffer, char *buf, u_int len);
d52 1
a52 1
void    buffer_consume(Buffer * buffer, u_int bytes);
d55 1
a55 1
void    buffer_consume_end(Buffer * buffer, u_int bytes);
d58 1
a58 1
char   *buffer_ptr(Buffer * buffer);
d64 1
a64 1
void    buffer_dump(Buffer * buffer);
@


1.7.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.9 2001/06/26 17:27:23 markus Exp $"); */
d20 4
a23 4
	char	*buf;		/* Buffer for data. */
	u_int	 alloc;		/* Number of bytes allocated for data. */
	u_int	 offset;	/* Offset of first byte containing data. */
	u_int	 end;		/* Offset of last byte containing data. */
d25 2
d28 2
a29 3
void	 buffer_init(Buffer *);
void	 buffer_clear(Buffer *);
void	 buffer_free(Buffer *);
d31 34
a64 12
u_int	 buffer_len(Buffer *);
char	*buffer_ptr(Buffer *);

void	 buffer_append(Buffer *, const char *, u_int);
void	 buffer_append_space(Buffer *, char **, u_int);

void	 buffer_get(Buffer *, char *, u_int);

void	 buffer_consume(Buffer *, u_int);
void	 buffer_consume_end(Buffer *, u_int);

void     buffer_dump(Buffer *);
@


1.7.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@a0 2
/*	$OpenBSD: buffer.h,v 1.11 2002/03/04 17:27:39 stevesk Exp $	*/

d14 2
d20 1
a20 1
	u_char	*buf;		/* Buffer for data. */
d31 1
a31 1
void	*buffer_ptr(Buffer *);
d33 2
a34 2
void	 buffer_append(Buffer *, const void *, u_int);
void	*buffer_append_space(Buffer *, u_int);
d36 1
a36 1
void	 buffer_get(Buffer *, void *, u_int);
@


1.6
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.5 2000/06/20 01:39:39 markus Exp $"); */
d21 3
a23 3
	unsigned int alloc;	/* Number of bytes allocated for data. */
	unsigned int offset;	/* Offset of first byte containing data. */
	unsigned int end;	/* Offset of last byte containing data. */
d36 1
a36 1
void    buffer_append(Buffer * buffer, const char *data, unsigned int len);
d43 1
a43 1
void    buffer_append_space(Buffer * buffer, char **datap, unsigned int len);
d46 1
a46 1
unsigned int buffer_len(Buffer * buffer);
d49 1
a49 1
void    buffer_get(Buffer * buffer, char *buf, unsigned int len);
d52 1
a52 1
void    buffer_consume(Buffer * buffer, unsigned int bytes);
d55 1
a55 1
void    buffer_consume_end(Buffer * buffer, unsigned int bytes);
@


1.6.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.7 2000/12/19 23:17:55 markus Exp $"); */
d21 3
a23 3
	u_int alloc;	/* Number of bytes allocated for data. */
	u_int offset;	/* Offset of first byte containing data. */
	u_int end;	/* Offset of last byte containing data. */
d36 1
a36 1
void    buffer_append(Buffer * buffer, const char *data, u_int len);
d43 1
a43 1
void    buffer_append_space(Buffer * buffer, char **datap, u_int len);
d46 1
a46 1
u_int buffer_len(Buffer * buffer);
d49 1
a49 1
void    buffer_get(Buffer * buffer, char *buf, u_int len);
d52 1
a52 1
void    buffer_consume(Buffer * buffer, u_int bytes);
d55 1
a55 1
void    buffer_consume_end(Buffer * buffer, u_int bytes);
@


1.6.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.6.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.6.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.6.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.9 2001/06/26 17:27:23 markus Exp $"); */
d20 4
a23 4
	char	*buf;		/* Buffer for data. */
	u_int	 alloc;		/* Number of bytes allocated for data. */
	u_int	 offset;	/* Offset of first byte containing data. */
	u_int	 end;		/* Offset of last byte containing data. */
d25 2
d28 2
a29 3
void	 buffer_init(Buffer *);
void	 buffer_clear(Buffer *);
void	 buffer_free(Buffer *);
d31 34
a64 12
u_int	 buffer_len(Buffer *);
char	*buffer_ptr(Buffer *);

void	 buffer_append(Buffer *, const char *, u_int);
void	 buffer_append_space(Buffer *, char **, u_int);

void	 buffer_get(Buffer *, char *, u_int);

void	 buffer_consume(Buffer *, u_int);
void	 buffer_consume_end(Buffer *, u_int);

void     buffer_dump(Buffer *);
@


1.6.2.6
log
@Merge OpenSSH 3.1.
@
text
@a0 2
/*	$OpenBSD: buffer.h,v 1.11 2002/03/04 17:27:39 stevesk Exp $	*/

d14 2
d20 1
a20 1
	u_char	*buf;		/* Buffer for data. */
d31 1
a31 1
void	*buffer_ptr(Buffer *);
d33 2
a34 2
void	 buffer_append(Buffer *, const void *, u_int);
void	*buffer_append_space(Buffer *, u_int);
d36 1
a36 1
void	 buffer_get(Buffer *, void *, u_int);
@


1.5
log
@OpenBSD tag
@
text
@a1 3
 *
 * buffer.h
 *
a2 1
 *
a4 3
 *
 * Created: Sat Mar 18 04:12:25 1995 ylo
 *
d7 5
d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.4 2000/04/14 10:30:30 markus Exp $"); */
@


1.4
log
@whitespace cleanup
@
text
@d16 1
a16 1
/* RCSID("$Id: buffer.h,v 1.3 1999/11/24 19:53:44 markus Exp $"); */
@


1.4.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d16 1
a16 1
/* RCSID("$OpenBSD: buffer.h,v 1.5 2000/06/20 01:39:39 markus Exp $"); */
@


1.4.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d16 1
a16 1
/* RCSID("$OpenBSD: buffer.h,v 1.6 2000/09/07 20:27:50 deraadt Exp $"); */
@


1.4.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d14 1
a14 1
/* RCSID("$OpenBSD: buffer.h,v 1.7 2000/12/19 23:17:55 markus Exp $"); */
d21 3
a23 3
	u_int alloc;	/* Number of bytes allocated for data. */
	u_int offset;	/* Offset of first byte containing data. */
	u_int end;	/* Offset of last byte containing data. */
d36 1
a36 1
void    buffer_append(Buffer * buffer, const char *data, u_int len);
d43 1
a43 1
void    buffer_append_space(Buffer * buffer, char **datap, u_int len);
d46 1
a46 1
u_int buffer_len(Buffer * buffer);
d49 1
a49 1
void    buffer_get(Buffer * buffer, char *buf, u_int len);
d52 1
a52 1
void    buffer_consume(Buffer * buffer, u_int bytes);
d55 1
a55 1
void    buffer_consume_end(Buffer * buffer, u_int bytes);
@


1.4.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.3
log
@KNF, final part 3
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d16 1
a16 1
/* RCSID("$Id: buffer.h,v 1.2 1999/11/24 00:26:01 deraadt Exp $"); */
@


1.2
log
@much more KNF
@
text
@d16 1
a16 1
/* RCSID("$Id: buffer.h,v 1.1 1999/09/26 20:53:34 deraadt Exp $"); */
d40 5
a44 3
/* Appends space to the buffer, expanding the buffer if necessary.
   This does not actually copy the data into the buffer, but instead
   returns a pointer to the allocated region. */
d62 4
a65 2
/* Dumps the contents of the buffer to stderr in hex.  This intended for
   debugging purposes only. */
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d2 13
d16 1
a16 14
buffer.h

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Mar 18 04:12:25 1995 ylo

Code for manipulating FIFO buffers.

*/

/* RCSID("$Id: buffer.h,v 1.2 1999/05/04 11:58:31 bg Exp $"); */
d21 6
a26 8
typedef struct
{
  char *buf;			/* Buffer for data. */
  unsigned int alloc;		/* Number of bytes allocated for data. */
  unsigned int offset;		/* Offset of first byte containing data. */
  unsigned int end;		/* Offset of last byte containing data. */
} Buffer;

d28 1
a28 1
void buffer_init(Buffer *buffer);
d31 1
a31 1
void buffer_free(Buffer *buffer);
d35 1
a35 1
void buffer_clear(Buffer *buffer);
d38 1
a38 1
void buffer_append(Buffer *buffer, const char *data, unsigned int len);
d43 1
a43 1
void buffer_append_space(Buffer *buffer, char **datap, unsigned int len);
d46 1
a46 1
unsigned int buffer_len(Buffer *buffer);
d49 1
a49 1
void buffer_get(Buffer *buffer, char *buf, unsigned int len);
d52 1
a52 1
void buffer_consume(Buffer *buffer, unsigned int bytes);
d55 1
a55 1
void buffer_consume_end(Buffer *buffer, unsigned int bytes);
d58 1
a58 1
char *buffer_ptr(Buffer *buffer);
d62 1
a62 1
void buffer_dump(Buffer *buffer);
d64 1
a64 1
#endif /* BUFFER_H */
@

