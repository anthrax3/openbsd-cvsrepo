head	1.37;
access;
symbols
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.35.0.8
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.6
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.4
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.6
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6;
locks; strict;
comment	@ * @;


1.37
date	2017.09.14.04.32.21;	author djm;	state Exp;
branches;
next	1.36;
commitid	GlY9YkqqBc7uixGk;

1.36
date	2017.09.01.05.53.56;	author djm;	state Exp;
branches;
next	1.35;
commitid	gJtIN6rRTS3CHy9b;

1.35
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	0Dp7Dy9FuNZesYo2;

1.34
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.33;
commitid	P7KG9D8zB61mMUPV;

1.33
date	2015.01.15.09.40.00;	author djm;	state Exp;
branches;
next	1.32;
commitid	akRUKeZEbb3ylbKG;

1.32
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.31;
commitid	EbtriidyZdsmXksl;

1.31
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.30;
commitid	1h9UxAQmwdaqUzyX;

1.30
date	2014.04.20.09.24.26;	author logan;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2012.05.23.03.28.28;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.12.00.03.49;	author dtucker;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.03.03.01.40;	author stevesk;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.25.22.22.43;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.20.18.41.43;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.17.14.13.35;	author stevesk;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2005.10.17.14.01.28;	author stevesk;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.17.13.45.05;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.13.19.13.41;	author stevesk;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2005.04.20.10.05.45;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2003.11.12.16.39.58;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.14.19.42.10;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.11.10.18.47;	author jakob;	state Exp;
branches
	1.6.2.1
	1.6.4.1
	1.6.6.1;
next	1.5;

1.5
date	2003.05.15.02.27.15;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.14.23.29.22;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.14.22.56.51;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.14.22.51.56;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.14.18.16.20;	author jakob;	state Exp;
branches;
next	;

1.6.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.6.4.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.6.6.1
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	;

1.9.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.10.2.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.10.4.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.12.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.16.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Revert commitid: gJtIN6rRTS3CHy9b.

-------------
identify the case where SSHFP records are missing but other DNS RR
types are present and display a more useful error message for this
case; patch by Thordur Bjornsson; bz#2501; ok dtucker@@
-------------

This caused unexpected failures when VerifyHostKeyDNS=yes, SSHFP results
are missing but the user already has the key in known_hosts

Spotted by dtucker@@
@
text
@/* $OpenBSD: dns.c,v 1.35 2015/08/20 22:32:42 deraadt Exp $ */

/*
 * Copyright (c) 2003 Wesley Griffin. All rights reserved.
 * Copyright (c) 2003 Jakob Schlyter. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>

#include "xmalloc.h"
#include "sshkey.h"
#include "ssherr.h"
#include "dns.h"
#include "log.h"
#include "digest.h"

static const char *errset_text[] = {
	"success",		/* 0 ERRSET_SUCCESS */
	"out of memory",	/* 1 ERRSET_NOMEMORY */
	"general failure",	/* 2 ERRSET_FAIL */
	"invalid parameter",	/* 3 ERRSET_INVAL */
	"name does not exist",	/* 4 ERRSET_NONAME */
	"data does not exist",	/* 5 ERRSET_NODATA */
};

static const char *
dns_result_totext(unsigned int res)
{
	switch (res) {
	case ERRSET_SUCCESS:
		return errset_text[ERRSET_SUCCESS];
	case ERRSET_NOMEMORY:
		return errset_text[ERRSET_NOMEMORY];
	case ERRSET_FAIL:
		return errset_text[ERRSET_FAIL];
	case ERRSET_INVAL:
		return errset_text[ERRSET_INVAL];
	case ERRSET_NONAME:
		return errset_text[ERRSET_NONAME];
	case ERRSET_NODATA:
		return errset_text[ERRSET_NODATA];
	default:
		return "unknown error";
	}
}

/*
 * Read SSHFP parameters from key buffer.
 */
static int
dns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,
    u_char **digest, size_t *digest_len, struct sshkey *key)
{
	int r, success = 0;
	int fp_alg = -1;

	switch (key->type) {
	case KEY_RSA:
		*algorithm = SSHFP_KEY_RSA;
		if (!*digest_type)
			*digest_type = SSHFP_HASH_SHA1;
		break;
	case KEY_DSA:
		*algorithm = SSHFP_KEY_DSA;
		if (!*digest_type)
			*digest_type = SSHFP_HASH_SHA1;
		break;
	case KEY_ECDSA:
		*algorithm = SSHFP_KEY_ECDSA;
		if (!*digest_type)
			*digest_type = SSHFP_HASH_SHA256;
		break;
	case KEY_ED25519:
		*algorithm = SSHFP_KEY_ED25519;
		if (!*digest_type)
			*digest_type = SSHFP_HASH_SHA256;
		break;
	default:
		*algorithm = SSHFP_KEY_RESERVED; /* 0 */
		*digest_type = SSHFP_HASH_RESERVED; /* 0 */
	}

	switch (*digest_type) {
	case SSHFP_HASH_SHA1:
		fp_alg = SSH_DIGEST_SHA1;
		break;
	case SSHFP_HASH_SHA256:
		fp_alg = SSH_DIGEST_SHA256;
		break;
	default:
		*digest_type = SSHFP_HASH_RESERVED; /* 0 */
	}

	if (*algorithm && *digest_type) {
		if ((r = sshkey_fingerprint_raw(key, fp_alg, digest,
		    digest_len)) != 0)
			fatal("%s: sshkey_fingerprint_raw: %s", __func__,
			   ssh_err(r));
		success = 1;
	} else {
		*digest = NULL;
		*digest_len = 0;
		success = 0;
	}

	return success;
}

/*
 * Read SSHFP parameters from rdata buffer.
 */
static int
dns_read_rdata(u_int8_t *algorithm, u_int8_t *digest_type,
    u_char **digest, size_t *digest_len, u_char *rdata, int rdata_len)
{
	int success = 0;

	*algorithm = SSHFP_KEY_RESERVED;
	*digest_type = SSHFP_HASH_RESERVED;

	if (rdata_len >= 2) {
		*algorithm = rdata[0];
		*digest_type = rdata[1];
		*digest_len = rdata_len - 2;

		if (*digest_len > 0) {
			*digest = xmalloc(*digest_len);
			memcpy(*digest, rdata + 2, *digest_len);
		} else {
			*digest = (u_char *)xstrdup("");
		}

		success = 1;
	}

	return success;
}

/*
 * Check if hostname is numerical.
 * Returns -1 if hostname is numeric, 0 otherwise
 */
static int
is_numeric_hostname(const char *hostname)
{
	struct addrinfo hints, *ai;

	/*
	 * We shouldn't ever get a null host but if we do then log an error
	 * and return -1 which stops DNS key fingerprint processing.
	 */
	if (hostname == NULL) {
		error("is_numeric_hostname called with NULL hostname");
		return -1;
	}

	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {
		freeaddrinfo(ai);
		return -1;
	}

	return 0;
}

/*
 * Verify the given hostname, address and host key using DNS.
 * Returns 0 if lookup succeeds, -1 otherwise
 */
int
verify_host_key_dns(const char *hostname, struct sockaddr *address,
    struct sshkey *hostkey, int *flags)
{
	u_int counter;
	int result;
	struct rrsetinfo *fingerprints = NULL;

	u_int8_t hostkey_algorithm;
	u_int8_t hostkey_digest_type = SSHFP_HASH_RESERVED;
	u_char *hostkey_digest;
	size_t hostkey_digest_len;

	u_int8_t dnskey_algorithm;
	u_int8_t dnskey_digest_type;
	u_char *dnskey_digest;
	size_t dnskey_digest_len;

	*flags = 0;

	debug3("verify_host_key_dns");
	if (hostkey == NULL)
		fatal("No key to look up!");

	if (is_numeric_hostname(hostname)) {
		debug("skipped DNS lookup for numerical hostname");
		return -1;
	}

	result = getrrsetbyname(hostname, DNS_RDATACLASS_IN,
	    DNS_RDATATYPE_SSHFP, 0, &fingerprints);
	if (result) {
		verbose("DNS lookup error: %s", dns_result_totext(result));
		return -1;
	}

	if (fingerprints->rri_flags & RRSET_VALIDATED) {
		*flags |= DNS_VERIFY_SECURE;
		debug("found %d secure fingerprints in DNS",
		    fingerprints->rri_nrdatas);
	} else {
		debug("found %d insecure fingerprints in DNS",
		    fingerprints->rri_nrdatas);
	}

	/* Initialize default host key parameters */
	if (!dns_read_key(&hostkey_algorithm, &hostkey_digest_type,
	    &hostkey_digest, &hostkey_digest_len, hostkey)) {
		error("Error calculating host key fingerprint.");
		freerrset(fingerprints);
		return -1;
	}

	if (fingerprints->rri_nrdatas)
		*flags |= DNS_VERIFY_FOUND;

	for (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {
		/*
		 * Extract the key from the answer. Ignore any badly
		 * formatted fingerprints.
		 */
		if (!dns_read_rdata(&dnskey_algorithm, &dnskey_digest_type,
		    &dnskey_digest, &dnskey_digest_len,
		    fingerprints->rri_rdatas[counter].rdi_data,
		    fingerprints->rri_rdatas[counter].rdi_length)) {
			verbose("Error parsing fingerprint from DNS.");
			continue;
		}

		if (hostkey_digest_type != dnskey_digest_type) {
			hostkey_digest_type = dnskey_digest_type;
			free(hostkey_digest);

			/* Initialize host key parameters */
			if (!dns_read_key(&hostkey_algorithm,
			    &hostkey_digest_type, &hostkey_digest,
			    &hostkey_digest_len, hostkey)) {
				error("Error calculating key fingerprint.");
				freerrset(fingerprints);
				return -1;
			}
		}

		/* Check if the current key is the same as the given key */
		if (hostkey_algorithm == dnskey_algorithm &&
		    hostkey_digest_type == dnskey_digest_type) {
			if (hostkey_digest_len == dnskey_digest_len &&
			    timingsafe_bcmp(hostkey_digest, dnskey_digest,
			    hostkey_digest_len) == 0)
				*flags |= DNS_VERIFY_MATCH;
		}
		free(dnskey_digest);
	}

	free(hostkey_digest); /* from sshkey_fingerprint_raw() */
	freerrset(fingerprints);

	if (*flags & DNS_VERIFY_FOUND)
		if (*flags & DNS_VERIFY_MATCH)
			debug("matching host key fingerprint found in DNS");
		else
			debug("mismatching host key fingerprint found in DNS");
	else
		debug("no host key fingerprint found in DNS");

	return 0;
}

/*
 * Export the fingerprint of a key as a DNS resource record
 */
int
export_dns_rr(const char *hostname, struct sshkey *key, FILE *f, int generic)
{
	u_int8_t rdata_pubkey_algorithm = 0;
	u_int8_t rdata_digest_type = SSHFP_HASH_RESERVED;
	u_int8_t dtype;
	u_char *rdata_digest;
	size_t i, rdata_digest_len;
	int success = 0;

	for (dtype = SSHFP_HASH_SHA1; dtype < SSHFP_HASH_MAX; dtype++) {
		rdata_digest_type = dtype;
		if (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,
		    &rdata_digest, &rdata_digest_len, key)) {
			if (generic) {
				fprintf(f, "%s IN TYPE%d \\# %zu %02x %02x ",
				    hostname, DNS_RDATATYPE_SSHFP,
				    2 + rdata_digest_len,
				    rdata_pubkey_algorithm, rdata_digest_type);
			} else {
				fprintf(f, "%s IN SSHFP %d %d ", hostname,
				    rdata_pubkey_algorithm, rdata_digest_type);
			}
			for (i = 0; i < rdata_digest_len; i++)
				fprintf(f, "%02x", rdata_digest[i]);
			fprintf(f, "\n");
			free(rdata_digest); /* from sshkey_fingerprint_raw() */
			success = 1;
		}
	}

	/* No SSHFP record was generated at all */
	if (success == 0) {
		error("%s: unsupported algorithm and/or digest_type", __func__);
	}

	return success;
}
@


1.36
log
@identify the case where SSHFP records are missing but other DNS RR
types are present and display a more useful error message for this
case; patch by Thordur Bjornsson; bz#2501; ok dtucker@@
@
text
@d294 4
a297 1
	if (*flags & DNS_VERIFY_FOUND) {
a299 2
		else if (counter == fingerprints->rri_nrdatas)
			*flags |= DNS_VERIFY_MISSING;
d302 1
a302 1
	} else
a303 3

	free(hostkey_digest); /* from sshkey_fingerprint_raw() */
	freerrset(fingerprints);
@


1.35
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.34 2015/01/28 22:36:00 djm Exp $ */
d294 1
a294 4
	free(hostkey_digest); /* from sshkey_fingerprint_raw() */
	freerrset(fingerprints);

	if (*flags & DNS_VERIFY_FOUND)
d297 2
d301 1
a301 1
	else
d303 3
@


1.34
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.33 2015/01/15 09:40:00 djm Exp $ */
d154 1
a154 1
			*digest = (u_char *) xmalloc(*digest_len);
@


1.33
log
@sync ssh-keysign, ssh-keygen and some dependencies to the new
buffer/key API; mostly mechanical, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.32 2014/12/21 22:27:56 djm Exp $ */
d294 1
a294 1
	free(hostkey_digest); /* from key_fingerprint_raw() */
d337 1
a337 1
			free(rdata_digest); /* from key_fingerprint_raw() */
@


1.32
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.31 2014/06/24 01:13:21 djm Exp $ */
d38 2
a39 1
#include "key.h"
d79 1
a79 1
    u_char **digest, u_int *digest_len, Key *key)
d81 1
a81 1
	int success = 0;
d122 4
a125 3
		*digest = key_fingerprint_raw(key, fp_alg, digest_len);
		if (*digest == NULL)
			fatal("dns_read_key: null from key_fingerprint_raw()");
d141 1
a141 1
    u_char **digest, u_int *digest_len, u_char *rdata, int rdata_len)
d202 1
a202 1
    Key *hostkey, int *flags)
d211 1
a211 1
	u_int hostkey_digest_len;
d216 1
a216 1
	u_int dnskey_digest_len;
d312 1
a312 1
export_dns_rr(const char *hostname, Key *key, FILE *f, int generic)
d318 1
a318 1
	u_int i, rdata_digest_len;
d326 1
a326 1
				fprintf(f, "%s IN TYPE%d \\# %d %02x %02x ",
@


1.31
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.30 2014/04/20 09:24:26 logan Exp $ */
d41 1
d81 1
a81 1
	enum fp_type fp_type = 0;
d111 1
a111 1
		fp_type = SSH_FP_SHA1;
d114 1
a114 1
		fp_type = SSH_FP_SHA256;
d121 1
a121 1
		*digest = key_fingerprint_raw(key, fp_type, digest_len);
@


1.30
log
@Add support for SSHFP DNS records for ED25519 key types.

OK from djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.29 2013/05/17 00:13:13 djm Exp $ */
d34 2
@


1.29
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.28 2012/05/23 03:28:28 djm Exp $ */
d93 5
@


1.28
log
@add support for RFC6594 SSHFP DNS records for ECDSA key types.
patch from bugzilla-m67 AT nulld.me in bz#1978; ok + tweak markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.27 2010/08/31 11:54:45 djm Exp $ */
d261 1
a261 1
			xfree(hostkey_digest);
d281 1
a281 1
		xfree(dnskey_digest);
d284 1
a284 1
	xfree(hostkey_digest); /* from key_fingerprint_raw() */
d327 1
a327 1
			xfree(rdata_digest); /* from key_fingerprint_raw() */
@


1.27
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.26 2010/02/26 20:29:54 djm Exp $ */
d78 1
d83 2
d88 7
a95 1
	/* XXX KEY_ECDSA */
d98 12
d112 2
a113 3
	if (*algorithm) {
		*digest_type = SSHFP_HASH_SHA1;
		*digest = key_fingerprint_raw(key, SSH_FP_SHA1, digest_len);
a117 1
		*digest_type = SSHFP_HASH_RESERVED;
d199 1
a199 1
	u_int8_t hostkey_digest_type;
d235 1
a235 1
	/* Initialize host key parameters */
d259 14
a275 1

d277 2
a278 3
			    memcmp(hostkey_digest, dnskey_digest,
			    hostkey_digest_len) == 0) {

a279 1
			}
d305 2
a306 1
	u_int8_t rdata_digest_type = SSHFP_HASH_SHA1;
d308 1
a308 3
	u_int rdata_digest_len;

	u_int i;
d311 20
a330 10
	if (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,
	    &rdata_digest, &rdata_digest_len, key)) {

		if (generic)
			fprintf(f, "%s IN TYPE%d \\# %d %02x %02x ", hostname,
			    DNS_RDATATYPE_SSHFP, 2 + rdata_digest_len,
			    rdata_pubkey_algorithm, rdata_digest_type);
		else
			fprintf(f, "%s IN SSHFP %d %d ", hostname,
			    rdata_pubkey_algorithm, rdata_digest_type);
d332 3
a334 7
		for (i = 0; i < rdata_digest_len; i++)
			fprintf(f, "%02x", rdata_digest[i]);
		fprintf(f, "\n");
		xfree(rdata_digest); /* from key_fingerprint_raw() */
		success = 1;
	} else {
		error("export_dns_rr: unsupported algorithm");
@


1.26
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.25 2008/06/12 00:03:49 dtucker Exp $ */
d86 1
@


1.25
log
@Do not pass "0" strings as ports to getaddrinfo because the lookups
can slow things down and we never use the service info anyway. bz
#859, patch from YOSHIFUJI Hideaki and John Devitofranceschi.  ok
deraadt@@ djm@@

djm belives that the reason for the "0" strings is to ensure that
it's not possible to call getaddrinfo with both host and port being
NULL.  In the case of canohost.c host is a local array.  In the
case of sshconnect.c, it's checked for null immediately before use.

In dns.c it ultimately comes from ssh.c:main() and is guaranteed to
be non-null but it's not obvious, so I added a warning message in
case it is ever passed a null.
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.24 2007/01/03 03:01:40 stevesk Exp $ */
d75 1
a75 1
    u_char **digest, u_int *digest_len, const Key *key)
d172 1
a172 1
    const Key *hostkey, int *flags)
d271 1
a271 1
export_dns_rr(const char *hostname, const Key *key, FILE *f, int generic)
@


1.24
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d145 9
d158 1
a158 1
	if (getaddrinfo(hostname, "0", &hints, &ai) == 0) {
@


1.23
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.22 2006/08/01 23:22:47 stevesk Exp $ */
d217 1
a217 1
	for (counter = 0; counter < fingerprints->rri_nrdatas; counter++)  {
@


1.22
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.21 2006/07/22 20:48:23 stevesk Exp $ */
a26 2

#include "includes.h"
@


1.21
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.20 2006/07/08 21:47:12 stevesk Exp $ */
d34 1
@


1.20
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.19 2006/03/25 22:22:43 djm Exp $ */
d34 1
@


1.19
log
@standardise spacing in $OpenBSD$ tags; requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.18 2006/03/20 18:41:43 deraadt Exp $ */
d29 3
@


1.18
log
@cast xstrdup to propert u_char *
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.17 2006/03/19 18:51:18 deraadt Exp $	*/
@


1.17
log
@RCSID() can die
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $	*/
d124 1
a124 1
			*digest = xstrdup("");
@


1.16
log
@more cleanups; ok jakob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.15 2005/10/17 14:01:28 stevesk Exp $	*/
a28 1
RCSID("$OpenBSD: dns.c,v 1.15 2005/10/17 14:01:28 stevesk Exp $");
@


1.16.2.1
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d28 2
a29 2
#include <sys/types.h>
#include <sys/socket.h>
a31 2
#include <stdio.h>
#include <string.h>
d125 1
a125 1
			*digest = (u_char *)xstrdup("");
@


1.15
log
@remove #ifdef LWRES; ok jakob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.14 2005/10/17 13:45:05 stevesk Exp $	*/
a27 1

d29 1
a30 1
#include <openssl/bn.h>
a37 2
RCSID("$OpenBSD: dns.c,v 1.14 2005/10/17 13:45:05 stevesk Exp $");

d179 1
a179 1
	debug3("verify_hostkey_dns");
a255 1

d271 1
a271 1
			 &rdata_digest, &rdata_digest_len, key)) {
d287 1
a287 1
		error("dns_export_rr: unsupported algorithm");
@


1.14
log
@fix memory leaks from 2 sources:
    1) key_fingerprint_raw()
    2) malloc in dns_read_rdata()
ok jakob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.13 2005/10/13 19:13:41 stevesk Exp $	*/
a31 4
#ifdef LWRES
#include <lwres/netdb.h>
#include <dns/result.h>
#else /* LWRES */
a32 1
#endif /* LWRES */
d39 1
a39 1
RCSID("$OpenBSD: dns.c,v 1.13 2005/10/13 19:13:41 stevesk Exp $");
a40 1
#ifndef LWRES
a69 2
#endif /* LWRES */

@


1.13
log
@unneeded #include, unused declaration, little knf; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.12 2005/06/17 02:44:32 djm Exp $	*/
d44 1
a44 1
RCSID("$OpenBSD: dns.c,v 1.12 2005/06/17 02:44:32 djm Exp $");
d96 1
a96 1
		*algorithm = SSHFP_KEY_RESERVED;
d102 2
d136 1
a136 1
			*digest = NULL;
d250 1
d253 1
d296 1
@


1.12
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.11 2005/04/20 10:05:45 jakob Exp $	*/
a42 1
#include "uuencode.h"
d44 1
a44 2
extern char *__progname;
RCSID("$OpenBSD: dns.c,v 1.11 2005/04/20 10:05:45 jakob Exp $");
d224 1
a224 1
	for (counter = 0 ; counter < fingerprints->rri_nrdatas ; counter++)  {
@


1.12.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $	*/
d28 1
a29 1
RCSID("$OpenBSD: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $");
d31 5
d37 1
d43 4
d48 1
d78 2
d98 1
a98 1
		*algorithm = SSHFP_KEY_RESERVED; /* 0 */
a103 2
		if (*digest == NULL)
			fatal("dns_read_key: null from key_fingerprint_raw()");
d136 1
a136 1
			*digest = xstrdup("");
d190 1
a190 1
	debug3("verify_host_key_dns");
d226 1
a226 1
	for (counter = 0; counter < fingerprints->rri_nrdatas; counter++)  {
a249 1
		xfree(dnskey_digest);
a251 1
	xfree(hostkey_digest); /* from key_fingerprint_raw() */
d265 1
d281 1
a281 1
	    &rdata_digest, &rdata_digest_len, key)) {
a293 1
		xfree(rdata_digest); /* from key_fingerprint_raw() */
d296 1
a296 1
		error("export_dns_rr: unsupported algorithm");
@


1.12.2.2
log
@upgrade to OpenSSH 4.4
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d28 2
a29 2
#include <sys/types.h>
#include <sys/socket.h>
a31 2
#include <stdio.h>
#include <string.h>
d125 1
a125 1
			*digest = (u_char *)xstrdup("");
@


1.11
log
@do not try to look up SSHFP for numerical hostname. ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.10 2004/06/21 17:36:31 avsm Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.10 2004/06/21 17:36:31 avsm Exp $");
d174 1
a174 1
	int counter;
d277 1
a277 1
	int i;
@


1.10
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.9 2003/11/21 11:57:03 djm Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.9 2003/11/21 11:57:03 djm Exp $");
d145 20
d193 5
@


1.10.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.12 2005/06/17 02:44:32 djm Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.12 2005/06/17 02:44:32 djm Exp $");
a144 20
/*
 * Check if hostname is numerical.
 * Returns -1 if hostname is numeric, 0 otherwise
 */
static int
is_numeric_hostname(const char *hostname)
{
	struct addrinfo hints, *ai;

	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(hostname, "0", &hints, &ai) == 0) {
		freeaddrinfo(ai);
		return -1;
	}

	return 0;
}
d154 1
a154 1
	u_int counter;
a173 5
	if (is_numeric_hostname(hostname)) {
		debug("skipped DNS lookup for numerical hostname");
		return -1;
	}

d252 1
a252 1
	u_int i;
@


1.10.4.2
log
@upgrade to OpenSSH 4.3
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $	*/
d28 1
a29 1
RCSID("$OpenBSD: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $");
d31 5
d37 1
d43 4
d48 1
d78 2
d98 1
a98 1
		*algorithm = SSHFP_KEY_RESERVED; /* 0 */
a103 2
		if (*digest == NULL)
			fatal("dns_read_key: null from key_fingerprint_raw()");
d136 1
a136 1
			*digest = xstrdup("");
d190 1
a190 1
	debug3("verify_host_key_dns");
d226 1
a226 1
	for (counter = 0; counter < fingerprints->rri_nrdatas; counter++)  {
a249 1
		xfree(dnskey_digest);
a251 1
	xfree(hostkey_digest); /* from key_fingerprint_raw() */
d265 1
d281 1
a281 1
	    &rdata_digest, &rdata_digest_len, key)) {
a293 1
		xfree(rdata_digest); /* from key_fingerprint_raw() */
d296 1
a296 1
		error("export_dns_rr: unsupported algorithm");
@


1.10.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.12 2005/06/17 02:44:32 djm Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.12 2005/06/17 02:44:32 djm Exp $");
a144 20
/*
 * Check if hostname is numerical.
 * Returns -1 if hostname is numeric, 0 otherwise
 */
static int
is_numeric_hostname(const char *hostname)
{
	struct addrinfo hints, *ai;

	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(hostname, "0", &hints, &ai) == 0) {
		freeaddrinfo(ai);
		return -1;
	}

	return 0;
}
d154 1
a154 1
	u_int counter;
a173 5
	if (is_numeric_hostname(hostname)) {
		debug("skipped DNS lookup for numerical hostname");
		return -1;
	}

d252 1
a252 1
	u_int i;
@


1.9
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.8 2003/11/12 16:39:58 jakob Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.8 2003/11/12 16:39:58 jakob Exp $");
d59 1
a59 1
dns_result_totext(unsigned int error)
d61 1
a61 1
	switch (error) {
@


1.9.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.10 2004/06/21 17:36:31 avsm Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.10 2004/06/21 17:36:31 avsm Exp $");
d59 1
a59 1
dns_result_totext(unsigned int res)
d61 1
a61 1
	switch (res) {
@


1.8
log
@update SSHFP validation. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.7 2003/10/14 19:42:10 jakob Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.7 2003/10/14 19:42:10 jakob Exp $");
d148 1
a148 1
 * Returns 0 if lookup succeeds, -1 otherwise 
@


1.7
log
@include SSHFP lookup code (not enabled by default). ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.6 2003/06/11 10:18:47 jakob Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.6 2003/06/11 10:18:47 jakob Exp $");
d86 1
a86 1
    u_char **digest, u_int *digest_len, Key *key)
d148 1
a148 1
 * Returns 0 if key verifies or -1 if key does NOT verify
d152 1
a152 1
    Key *hostkey)
a156 1
	int failures = 0;
d168 1
d178 1
a178 1
		return DNS_VERIFY_ERROR;
d181 7
a187 6
#ifdef DNSSEC
	/* Only accept validated answers */
	if (!fingerprints->rri_flags & RRSET_VALIDATED) {
		error("Ignored unvalidated fingerprint from DNS.");
		freerrset(fingerprints);
		return DNS_VERIFY_ERROR;
a188 3
#endif

	debug("found %d fingerprints in DNS", fingerprints->rri_nrdatas);
d195 1
a195 1
		return DNS_VERIFY_ERROR;
d198 3
d222 1
a222 8
				/* Matching algoritm and digest. */
				freerrset(fingerprints);
				debug("matching host key fingerprint found in DNS");
				return DNS_VERIFY_OK;
			} else {
				/* Correct algorithm but bad digest */
				debug("verify_hostkey_dns: failed");
				failures++;
d229 7
a235 13
	if (failures) {
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@");
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
		error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
		error("It is also possible that the %s host key has just been changed.",
		    key_type(hostkey));
		error("Please contact your system administrator.");
		return DNS_VERIFY_FAILED;
	}

	debug("fingerprints found in DNS, but none of them matched");
d237 1
a237 1
	return DNS_VERIFY_ERROR;
d245 1
a245 1
export_dns_rr(const char *hostname, Key *key, FILE *f, int generic)
@


1.6
log
@sync with check_host_key() change
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.5 2003/05/15 02:27:15 jakob Exp $	*/
a30 1
#ifdef DNS
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.5 2003/05/15 02:27:15 jakob Exp $");
a287 2

#endif /* DNS */
@


1.6.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.9 2003/11/21 11:57:03 djm Exp $	*/
d31 1
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.9 2003/11/21 11:57:03 djm Exp $");
d87 1
a87 1
    u_char **digest, u_int *digest_len, const Key *key)
d149 1
a149 1
 * Returns 0 if lookup succeeds, -1 otherwise
d153 1
a153 1
    const Key *hostkey, int *flags)
d158 1
a169 1
	*flags = 0;
d179 1
a179 1
		return -1;
d182 6
a187 7
	if (fingerprints->rri_flags & RRSET_VALIDATED) {
		*flags |= DNS_VERIFY_SECURE;
		debug("found %d secure fingerprints in DNS",
		    fingerprints->rri_nrdatas);
	} else {
		debug("found %d insecure fingerprints in DNS",
		    fingerprints->rri_nrdatas);
d189 3
d198 1
a198 1
		return -1;
a200 3
	if (fingerprints->rri_nrdatas)
		*flags |= DNS_VERIFY_FOUND;

d222 8
a229 1
				*flags |= DNS_VERIFY_MATCH;
d236 13
a248 7
	if (*flags & DNS_VERIFY_FOUND)
		if (*flags & DNS_VERIFY_MATCH)
			debug("matching host key fingerprint found in DNS");
		else
			debug("mismatching host key fingerprint found in DNS");
	else
		debug("no host key fingerprint found in DNS");
d250 1
a250 1
	return 0;
d258 1
a258 1
export_dns_rr(const char *hostname, const Key *key, FILE *f, int generic)
d289 2
@


1.6.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.10 2004/06/21 17:36:31 avsm Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.10 2004/06/21 17:36:31 avsm Exp $");
d59 1
a59 1
dns_result_totext(unsigned int res)
d61 1
a61 1
	switch (res) {
@


1.6.6.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.6 2003/06/11 10:18:47 jakob Exp $	*/
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.6 2003/06/11 10:18:47 jakob Exp $");
@


1.6.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.6 2003/06/11 10:18:47 jakob Exp $	*/
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.6 2003/06/11 10:18:47 jakob Exp $");
@


1.6.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.9 2003/11/21 11:57:03 djm Exp $	*/
d31 1
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.9 2003/11/21 11:57:03 djm Exp $");
d87 1
a87 1
    u_char **digest, u_int *digest_len, const Key *key)
d149 1
a149 1
 * Returns 0 if lookup succeeds, -1 otherwise
d153 1
a153 1
    const Key *hostkey, int *flags)
d158 1
a169 1
	*flags = 0;
d179 1
a179 1
		return -1;
d182 6
a187 7
	if (fingerprints->rri_flags & RRSET_VALIDATED) {
		*flags |= DNS_VERIFY_SECURE;
		debug("found %d secure fingerprints in DNS",
		    fingerprints->rri_nrdatas);
	} else {
		debug("found %d insecure fingerprints in DNS",
		    fingerprints->rri_nrdatas);
d189 3
d198 1
a198 1
		return -1;
a200 3
	if (fingerprints->rri_nrdatas)
		*flags |= DNS_VERIFY_FOUND;

d222 8
a229 1
				*flags |= DNS_VERIFY_MATCH;
d236 13
a248 7
	if (*flags & DNS_VERIFY_FOUND)
		if (*flags & DNS_VERIFY_MATCH)
			debug("matching host key fingerprint found in DNS");
		else
			debug("mismatching host key fingerprint found in DNS");
	else
		debug("no host key fingerprint found in DNS");
d250 1
a250 1
	return 0;
d258 1
a258 1
export_dns_rr(const char *hostname, const Key *key, FILE *f, int generic)
d289 2
@


1.5
log
@add missing freerrset
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.4 2003/05/14 23:29:22 jakob Exp $	*/
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.4 2003/05/14 23:29:22 jakob Exp $");
a223 1
#ifdef DNSSEC
a225 4
#else
				logit("Matching host key fingerprint found in DNS.");
				return DNS_VERIFY_ERROR;
#endif
@


1.4
log
@sshfp contains fingerprints, not keys
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.3 2003/05/14 22:56:51 jakob Exp $	*/
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.3 2003/05/14 22:56:51 jakob Exp $");
d186 1
d197 1
@


1.3
log
@rename enum
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.2 2003/05/14 22:51:56 jakob Exp $	*/
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.2 2003/05/14 22:51:56 jakob Exp $");
d157 1
a157 1
	struct rrsetinfo *keys = NULL;
d176 1
a176 1
	    DNS_RDATATYPE_SSHFP, 0, &keys);
d184 1
a184 1
	if (!keys->rri_flags & RRSET_VALIDATED) {
d190 1
a190 1
	debug("found %d fingerprints in DNS", keys->rri_nrdatas);
d199 1
a199 1
	for (counter = 0 ; counter < keys->rri_nrdatas ; counter++)  {
d202 1
a202 1
		 * formatted keys.
d206 2
a207 2
		    keys->rri_rdatas[counter].rdi_data,
		    keys->rri_rdatas[counter].rdi_length)) {
d221 1
a221 1
				freerrset(keys);
d237 1
a237 1
	freerrset(keys);
@


1.2
log
@update license, remove 3rd clause. ok author (me)
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.1 2003/05/14 18:16:20 jakob Exp $	*/
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.1 2003/05/14 18:16:20 jakob Exp $");
d93 1
a93 1
		*algorithm = DNS_KEY_RSA;
d96 1
a96 1
		*algorithm = DNS_KEY_DSA;
d99 1
a99 1
		*algorithm = DNS_KEY_RESERVED;
d103 1
a103 1
		*digest_type = DNS_HASH_SHA1;
d107 1
a107 1
		*digest_type = DNS_HASH_RESERVED;
d125 2
a126 2
	*algorithm = DNS_KEY_RESERVED;
	*digest_type = DNS_HASH_RESERVED;
d264 1
a264 1
	u_int8_t rdata_digest_type = DNS_HASH_SHA1;
@


1.1
log
@add experimental support for verifying hos keys using DNS as described
in draft-ietf-secsh-dns-xx.txt. more information in README.dns.
ok markus@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.1 2003/05/12 16:40:33 jakob Exp $	*/
a14 2
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d47 1
a47 1
RCSID("$OpenBSD: dns.c,v 1.1 2003/05/12 16:40:33 jakob Exp $");
@

