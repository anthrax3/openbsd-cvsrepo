head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.16
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.14
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.12
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.8
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.14
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.12
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.10
	OPENBSD_5_0:1.32.0.8
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.16
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.12
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.10
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.8
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.6
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.23.0.6
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.36
date	2014.04.30.05.29.56;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.08.11.15.19;	author dtucker;	state Exp;
branches;
next	1.33;

1.33
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2010.02.09.03.56.28;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.16.00.48.52;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.14.11.46.56;	author markus;	state Exp;
branches
	1.23.4.1
	1.23.6.1;
next	1.22;

1.22
date	2004.10.29.23.56.17;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches
	1.21.2.1
	1.21.4.1;
next	1.20;

1.20
date	2003.09.19.09.03.00;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.18.07.54.48;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.16.21.02.39;	author markus;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2003.09.16.03.03.47;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.26.08.54.18;	author markus;	state Exp;
branches
	1.16.2.1
	1.16.4.1;
next	1.15;

1.15
date	2002.01.18.18.14.17;	author stevesk;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.19.17.16.13;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.12.19.15.24;	author markus;	state Exp;
branches
	1.13.2.1
	1.13.4.1;
next	1.12;

1.12
date	2001.04.07.08.55.15;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.05.21.02.46;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.21.19.05.45;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.07.20.27.50;	author deraadt;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.06.20.01.39.39;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.04.12.10.22.38;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.24.19.53.44;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.11.24.00.26.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.11.23.22.25.53;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.34;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2000.09.01.18.23.18;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.11.08.21.30.29;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.03.12.15.44.08;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.21.18.52.37;	author jason;	state Exp;
branches;
next	;

1.8.2.1
date	2001.02.16.20.12.55;	author jason;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.02.19.17.18.42;	author jason;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.03.21.19.46.23;	author jason;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.05.07.21.09.27;	author jason;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.13.2.1
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.13.4.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	;

1.16.2.1
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2003.09.16.21.25.56;	author brad;	state Exp;
branches;
next	;

1.16.4.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2003.09.16.21.30.49;	author brad;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.18.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	;

1.21.2.1
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.21.4.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	;

1.23.4.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.23.6.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.36
log
@New buffer API; the first installment of the conversion/replacement
of OpenSSH's internals to make them usable as a standalone library.

This includes a set of wrappers to make it compatible with the
existing buffer API so replacement can occur incrementally.

With and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review.
@
text
@/* $OpenBSD$ */

/*
 * Copyright (c) 2012 Damien Miller <djm@@mindrot.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Emulation wrappers for legacy OpenSSH buffer API atop sshbuf */

#include <sys/types.h>

#include "buffer.h"
#include "log.h"
#include "ssherr.h"

void
buffer_append(Buffer *buffer, const void *data, u_int len)
{
	int ret;

	if ((ret = sshbuf_put(buffer, data, len)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
}

void *
buffer_append_space(Buffer *buffer, u_int len)
{
	int ret;
	u_char *p;

	if ((ret = sshbuf_reserve(buffer, len, &p)) != 0)
		fatal("%s: %s", __func__, ssh_err(ret));
	return p;
}

int
buffer_check_alloc(Buffer *buffer, u_int len)
{
	int ret = sshbuf_check_reserve(buffer, len);

	if (ret == 0)
		return 1;
	if (ret == SSH_ERR_NO_BUFFER_SPACE)
		return 0;
	fatal("%s: %s", __func__, ssh_err(ret));
}

int
buffer_get_ret(Buffer *buffer, void *buf, u_int len)
{
	int ret;

	if ((ret = sshbuf_get(buffer, buf, len)) != 0) {
		error("%s: %s", __func__, ssh_err(ret));
		return -1;
	}
	return 0;
}

void
buffer_get(Buffer *buffer, void *buf, u_int len)
{
	if (buffer_get_ret(buffer, buf, len) == -1)
		fatal("%s: buffer error", __func__);
}

int
buffer_consume_ret(Buffer *buffer, u_int bytes)
{
	int ret = sshbuf_consume(buffer, bytes);

	if (ret == 0)
		return 0;
	if (ret == SSH_ERR_MESSAGE_INCOMPLETE)
		return -1;
	fatal("%s: %s", __func__, ssh_err(ret));
}

void
buffer_consume(Buffer *buffer, u_int bytes)
{
	if (buffer_consume_ret(buffer, bytes) == -1)
		fatal("%s: buffer error", __func__);
}

int
buffer_consume_end_ret(Buffer *buffer, u_int bytes)
{
	int ret = sshbuf_consume_end(buffer, bytes);

	if (ret == 0)
		return 0;
	if (ret == SSH_ERR_MESSAGE_INCOMPLETE)
		return -1;
	fatal("%s: %s", __func__, ssh_err(ret));
}

void
buffer_consume_end(Buffer *buffer, u_int bytes)
{
	if (buffer_consume_end_ret(buffer, bytes) == -1)
		fatal("%s: buffer error", __func__);
}


@


1.35
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 2
a2 1
/* $OpenBSD: buffer.c,v 1.34 2013/11/08 11:15:19 dtucker Exp $ */
d4 5
a8 4
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Functions for manipulating fifo buffers (that can grow if needed).
d10 7
a16 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d19 1
a19 1
#include <sys/param.h>
d21 1
a21 4
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
a22 1
#include "xmalloc.h"
d25 1
a25 6

#define	BUFFER_MAX_CHUNK	0x100000
#define	BUFFER_MAX_LEN		0xa00000
#define	BUFFER_ALLOCSZ		0x008000

/* Initializes the buffer structure. */
d28 1
a28 30
buffer_init(Buffer *buffer)
{
	const u_int len = 4096;

	buffer->alloc = 0;
	buffer->buf = xmalloc(len);
	buffer->alloc = len;
	buffer->offset = 0;
	buffer->end = 0;
}

/* Frees any memory used for the buffer. */

void
buffer_free(Buffer *buffer)
{
	if (buffer->alloc > 0) {
		explicit_bzero(buffer->buf, buffer->alloc);
		buffer->alloc = 0;
		free(buffer->buf);
	}
}

/*
 * Clears any data from the buffer, making it empty.  This does not actually
 * zero the memory.
 */

void
buffer_clear(Buffer *buffer)
d30 1
a30 5
	buffer->offset = 0;
	buffer->end = 0;
}

/* Appends data to the buffer, expanding it if necessary. */
d32 2
a33 23
void
buffer_append(Buffer *buffer, const void *data, u_int len)
{
	void *p;
	p = buffer_append_space(buffer, len);
	memcpy(p, data, len);
}

static int
buffer_compact(Buffer *buffer)
{
	/*
	 * If the buffer is quite empty, but all data is at the end, move the
	 * data to the beginning.
	 */
	if (buffer->offset > MIN(buffer->alloc, BUFFER_MAX_CHUNK)) {
		memmove(buffer->buf, buffer->buf + buffer->offset,
			buffer->end - buffer->offset);
		buffer->end -= buffer->offset;
		buffer->offset = 0;
		return (1);
	}
	return (0);
a35 6
/*
 * Appends space to the buffer, expanding the buffer if necessary. This does
 * not actually copy the data into the buffer, but instead returns a pointer
 * to the allocated region.
 */

d39 2
a40 2
	u_int newlen;
	void *p;
d42 3
a44 29
	if (len > BUFFER_MAX_CHUNK)
		fatal("buffer_append_space: len %u not supported", len);

	/* If the buffer is empty, start using it from the beginning. */
	if (buffer->offset == buffer->end) {
		buffer->offset = 0;
		buffer->end = 0;
	}
restart:
	/* If there is enough space to store all data, store it now. */
	if (buffer->end + len < buffer->alloc) {
		p = buffer->buf + buffer->end;
		buffer->end += len;
		return p;
	}

	/* Compact data back to the start of the buffer if necessary */
	if (buffer_compact(buffer))
		goto restart;

	/* Increase the size of the buffer and retry. */
	newlen = roundup(buffer->alloc + len, BUFFER_ALLOCSZ);
	if (newlen > BUFFER_MAX_LEN)
		fatal("buffer_append_space: alloc %u not supported",
		    newlen);
	buffer->buf = xrealloc(buffer->buf, 1, newlen);
	buffer->alloc = newlen;
	goto restart;
	/* NOTREACHED */
a46 4
/*
 * Check whether an allocation of 'len' will fit in the buffer
 * This must follow the same math as buffer_append_space
 */
d50 1
a50 15
	if (buffer->offset == buffer->end) {
		buffer->offset = 0;
		buffer->end = 0;
	}
 restart:
	if (buffer->end + len < buffer->alloc)
		return (1);
	if (buffer_compact(buffer))
		goto restart;
	if (roundup(buffer->alloc + len, BUFFER_ALLOCSZ) <= BUFFER_MAX_LEN)
		return (1);
	return (0);
}

/* Returns the number of bytes of data in the buffer. */
d52 5
a56 4
u_int
buffer_len(const Buffer *buffer)
{
	return buffer->end - buffer->offset;
a58 2
/* Gets data from the beginning of the buffer. */

d62 5
a66 4
	if (len > buffer->end - buffer->offset) {
		error("buffer_get_ret: trying to get more bytes %d than in buffer %d",
		    len, buffer->end - buffer->offset);
		return (-1);
d68 1
a68 3
	memcpy(buf, buffer->buf + buffer->offset, len);
	buffer->offset += len;
	return (0);
d75 1
a75 1
		fatal("buffer_get: buffer error");
a77 2
/* Consumes the given number of bytes from the beginning of the buffer. */

d81 7
a87 6
	if (bytes > buffer->end - buffer->offset) {
		error("buffer_consume_ret: trying to get more bytes than in buffer");
		return (-1);
	}
	buffer->offset += bytes;
	return (0);
d94 1
a94 1
		fatal("buffer_consume: buffer error");
a96 2
/* Consumes the given number of bytes from the end of the buffer. */

d100 7
a106 4
	if (bytes > buffer->end - buffer->offset)
		return (-1);
	buffer->end -= bytes;
	return (0);
d113 1
a113 1
		fatal("buffer_consume_end: trying to get more bytes than in buffer");
a115 7
/* Returns a pointer to the first used byte in the buffer. */

void *
buffer_ptr(const Buffer *buffer)
{
	return buffer->buf + buffer->offset;
}
a116 17
/* Dumps the contents of the buffer to stderr. */

void
buffer_dump(const Buffer *buffer)
{
	u_int i;
	u_char *ucp = buffer->buf;

	for (i = buffer->offset; i < buffer->end; i++) {
		fprintf(stderr, "%02x", ucp[i]);
		if ((i-buffer->offset)%16==15)
			fprintf(stderr, "\r\n");
		else if ((i-buffer->offset)%2==1)
			fprintf(stderr, " ");
	}
	fprintf(stderr, "\r\n");
}
@


1.34
log
@Include stdlib.h for free() as per the man page.
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.c,v 1.33 2013/05/17 00:13:13 djm Exp $ */
d50 1
a50 1
		memset(buffer->buf, 0, buffer->alloc);
@


1.33
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.c,v 1.32 2010/02/09 03:56:28 djm Exp $ */
d20 1
@


1.32
log
@constify the arguments to buffer_len, buffer_ptr and buffer_dump
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.c,v 1.31 2006/08/03 03:34:41 deraadt Exp $ */
d51 1
a51 1
		xfree(buffer->buf);
@


1.31
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.c,v 1.30 2006/08/01 23:22:47 stevesk Exp $ */
d161 1
a161 1
buffer_len(Buffer *buffer)
d229 1
a229 1
buffer_ptr(Buffer *buffer)
d237 1
a237 1
buffer_dump(Buffer *buffer)
@


1.30
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.c,v 1.29 2006/07/26 02:35:17 stevesk Exp $ */
a14 2
#include "includes.h"

d19 1
@


1.29
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.c,v 1.28 2006/07/22 20:48:22 stevesk Exp $ */
d19 1
@


1.28
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.c,v 1.27 2006/04/16 00:48:52 djm Exp $ */
d16 2
@


1.27
log
@Fix condition where we could exit with a fatal error when an input
buffer became too large and the remote end had advertised a big window.
The problem was a mismatch in the backoff math between the channels code
and the buffer code, so make a buffer_check_alloc() function that the
channels code can use to propsectivly check whether an incremental
allocation will succeed.  bz #1131, debugged with the assistance of
cove AT wildpackets.com; ok dtucker@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: buffer.c,v 1.26 2006/03/25 13:17:01 djm Exp $ */
d16 2
@


1.26
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d21 4
d73 17
d117 3
a119 9
	/*
	 * If the buffer is quite empty, but all data is at the end, move the
	 * data to the beginning and retry.
	 */
	if (buffer->offset > MIN(buffer->alloc, BUFFER_MAX_CHUNK)) {
		memmove(buffer->buf, buffer->buf + buffer->offset,
			buffer->end - buffer->offset);
		buffer->end -= buffer->offset;
		buffer->offset = 0;
d121 1
a121 1
	}
d123 1
a123 2

	newlen = buffer->alloc + len + 32768;
d131 21
@


1.25
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.24
log
@RCSID() can die
@
text
@d112 1
a112 1
	buffer->buf = xrealloc(buffer->buf, newlen);
@


1.23
log
@limit input buffer size for channels; bugzilla #896; with and ok dtucker@@
@
text
@a14 1
RCSID("$OpenBSD: buffer.c,v 1.22 2004/10/29 23:56:17 djm Exp $");
@


1.23.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: buffer.c,v 1.31 2006/08/03 03:34:41 deraadt Exp $ */
d14 2
a15 5
#include <sys/param.h>

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
a20 4
#define	BUFFER_MAX_CHUNK	0x100000
#define	BUFFER_MAX_LEN		0xa00000
#define	BUFFER_ALLOCSZ		0x008000

a68 17
static int
buffer_compact(Buffer *buffer)
{
	/*
	 * If the buffer is quite empty, but all data is at the end, move the
	 * data to the beginning.
	 */
	if (buffer->offset > MIN(buffer->alloc, BUFFER_MAX_CHUNK)) {
		memmove(buffer->buf, buffer->buf + buffer->offset,
			buffer->end - buffer->offset);
		buffer->end -= buffer->offset;
		buffer->offset = 0;
		return (1);
	}
	return (0);
}

d96 9
a104 3

	/* Compact data back to the start of the buffer if necessary */
	if (buffer_compact(buffer))
d106 2
d109 1
a109 2
	/* Increase the size of the buffer and retry. */
	newlen = roundup(buffer->alloc + len, BUFFER_ALLOCSZ);
d113 1
a113 1
	buffer->buf = xrealloc(buffer->buf, 1, newlen);
a116 21
}

/*
 * Check whether an allocation of 'len' will fit in the buffer
 * This must follow the same math as buffer_append_space
 */
int
buffer_check_alloc(Buffer *buffer, u_int len)
{
	if (buffer->offset == buffer->end) {
		buffer->offset = 0;
		buffer->end = 0;
	}
 restart:
	if (buffer->end + len < buffer->alloc)
		return (1);
	if (buffer_compact(buffer))
		goto restart;
	if (roundup(buffer->alloc + len, BUFFER_ALLOCSZ) <= BUFFER_MAX_LEN)
		return (1);
	return (0);
@


1.23.6.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: buffer.c,v 1.31 2006/08/03 03:34:41 deraadt Exp $ */
d14 2
a15 5
#include <sys/param.h>

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
a20 4
#define	BUFFER_MAX_CHUNK	0x100000
#define	BUFFER_MAX_LEN		0xa00000
#define	BUFFER_ALLOCSZ		0x008000

a68 17
static int
buffer_compact(Buffer *buffer)
{
	/*
	 * If the buffer is quite empty, but all data is at the end, move the
	 * data to the beginning.
	 */
	if (buffer->offset > MIN(buffer->alloc, BUFFER_MAX_CHUNK)) {
		memmove(buffer->buf, buffer->buf + buffer->offset,
			buffer->end - buffer->offset);
		buffer->end -= buffer->offset;
		buffer->offset = 0;
		return (1);
	}
	return (0);
}

d96 9
a104 3

	/* Compact data back to the start of the buffer if necessary */
	if (buffer_compact(buffer))
d106 2
d109 1
a109 2
	/* Increase the size of the buffer and retry. */
	newlen = roundup(buffer->alloc + len, BUFFER_ALLOCSZ);
d113 1
a113 1
	buffer->buf = xrealloc(buffer->buf, 1, newlen);
a116 21
}

/*
 * Check whether an allocation of 'len' will fit in the buffer
 * This must follow the same math as buffer_append_space
 */
int
buffer_check_alloc(Buffer *buffer, u_int len)
{
	if (buffer->offset == buffer->end) {
		buffer->offset = 0;
		buffer->end = 0;
	}
 restart:
	if (buffer->end + len < buffer->alloc)
		return (1);
	if (buffer_compact(buffer))
		goto restart;
	if (roundup(buffer->alloc + len, BUFFER_ALLOCSZ) <= BUFFER_MAX_LEN)
		return (1);
	return (0);
@


1.22
log
@introduce a new buffer API that returns an error rather than fatal()ing when
presented with bad data; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.21 2003/11/21 11:57:03 djm Exp $");
d81 1
a81 1
	if (len > 0x100000)
d100 1
a100 1
	if (buffer->offset > buffer->alloc / 2) {
d110 1
a110 1
	if (newlen > 0xa00000)
@


1.21
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.20 2003/09/19 09:03:00 markus Exp $");
d129 2
a130 2
void
buffer_get(Buffer *buffer, void *buf, u_int len)
d132 2
a133 2
	if (len > buffer->end - buffer->offset)
		fatal("buffer_get: trying to get more bytes %d than in buffer %d",
d135 2
d139 8
d151 11
d165 2
a166 3
	if (bytes > buffer->end - buffer->offset)
		fatal("buffer_consume: trying to get more bytes than in buffer");
	buffer->offset += bytes;
d171 9
d183 1
a183 1
	if (bytes > buffer->end - buffer->offset)
a184 1
	buffer->end -= bytes;
@


1.21.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.22 2004/10/29 23:56:17 djm Exp $");
d129 2
a130 2
int
buffer_get_ret(Buffer *buffer, void *buf, u_int len)
d132 2
a133 2
	if (len > buffer->end - buffer->offset) {
		error("buffer_get_ret: trying to get more bytes %d than in buffer %d",
a134 2
		return (-1);
	}
a136 8
	return (0);
}

void
buffer_get(Buffer *buffer, void *buf, u_int len)
{
	if (buffer_get_ret(buffer, buf, len) == -1)
		fatal("buffer_get: buffer error");
a140 11
int
buffer_consume_ret(Buffer *buffer, u_int bytes)
{
	if (bytes > buffer->end - buffer->offset) {
		error("buffer_consume_ret: trying to get more bytes than in buffer");
		return (-1);
	}
	buffer->offset += bytes;
	return (0);
}

d144 3
a146 2
	if (buffer_consume_ret(buffer, bytes) == -1)
		fatal("buffer_consume: buffer error");
a150 9
int
buffer_consume_end_ret(Buffer *buffer, u_int bytes)
{
	if (bytes > buffer->end - buffer->offset)
		return (-1);
	buffer->end -= bytes;
	return (0);
}

d154 1
a154 1
	if (buffer_consume_end_ret(buffer, bytes) == -1)
d156 1
@


1.21.4.1
log
@upgrade to OpenSSH 4.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.22 2004/10/29 23:56:17 djm Exp $");
d129 2
a130 2
int
buffer_get_ret(Buffer *buffer, void *buf, u_int len)
d132 2
a133 2
	if (len > buffer->end - buffer->offset) {
		error("buffer_get_ret: trying to get more bytes %d than in buffer %d",
a134 2
		return (-1);
	}
a136 8
	return (0);
}

void
buffer_get(Buffer *buffer, void *buf, u_int len)
{
	if (buffer_get_ret(buffer, buf, len) == -1)
		fatal("buffer_get: buffer error");
a140 11
int
buffer_consume_ret(Buffer *buffer, u_int bytes)
{
	if (bytes > buffer->end - buffer->offset) {
		error("buffer_consume_ret: trying to get more bytes than in buffer");
		return (-1);
	}
	buffer->offset += bytes;
	return (0);
}

d144 3
a146 2
	if (buffer_consume_ret(buffer, bytes) == -1)
		fatal("buffer_consume: buffer error");
a150 9
int
buffer_consume_end_ret(Buffer *buffer, u_int bytes)
{
	if (bytes > buffer->end - buffer->offset)
		return (-1);
	buffer->end -= bytes;
	return (0);
}

d154 1
a154 1
	if (buffer_consume_end_ret(buffer, bytes) == -1)
d156 1
@


1.21.4.2
log
@upgrade to OpenSSH 4.1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.23 2005/03/14 11:46:56 markus Exp $");
d81 1
a81 1
	if (len > BUFFER_MAX_CHUNK)
d100 1
a100 1
	if (buffer->offset > MIN(buffer->alloc, BUFFER_MAX_CHUNK)) {
d110 1
a110 1
	if (newlen > BUFFER_MAX_LEN)
@


1.20
log
@sign fix in buffer_dump; Jedi/Sector One; pr 3473
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.19 2003/09/18 07:54:48 markus Exp $");
d108 1
a108 1
	
@


1.19
log
@protect against double free; #660;  zardoz at users.sf.net
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.18 2003/09/16 21:02:39 markus Exp $");
d172 1
a172 1
	int i;
@


1.18
log
@more malloc/fatal fixes; ok millert/deraadt; ghudson at MIT.EDU
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.17 2003/09/16 03:03:47 deraadt Exp $");
d42 1
@


1.18.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.21 2003/11/21 11:57:03 djm Exp $");
a41 1
		buffer->alloc = 0;
d107 1
a107 1

d171 1
a171 1
	u_int i;
@


1.17
log
@do not expand buffer before attempting to reallocate it; markus ok
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.16 2002/06/26 08:54:18 markus Exp $");
d26 5
a30 2
	buffer->alloc = 4096;
	buffer->buf = xmalloc(buffer->alloc);
d40 4
a43 2
	memset(buffer->buf, 0, buffer->alloc);
	xfree(buffer->buf);
@


1.16
log
@limit append to 1MB and buffers to 10MB
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.15 2002/01/18 18:14:17 stevesk Exp $");
d72 1
d102 3
a104 2
	buffer->alloc += len + 32768;
	if (buffer->alloc > 0xa00000)
d106 3
a108 2
		    buffer->alloc);
	buffer->buf = xrealloc(buffer->buf, buffer->alloc);
@


1.16.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.17 2003/09/16 03:03:47 deraadt Exp $");
a71 1
	u_int newlen;
d101 2
a102 3
	
	newlen = buffer->alloc + len + 32768;
	if (newlen > 0xa00000)
d104 2
a105 3
		    newlen);
	buffer->buf = xrealloc(buffer->buf, newlen);
	buffer->alloc = newlen;
@


1.16.2.2
log
@upgrade to OpenSSH 3.7.1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.18 2003/09/16 21:02:39 markus Exp $");
d26 2
a27 5
	const u_int len = 4096;

	buffer->alloc = 0;
	buffer->buf = xmalloc(len);
	buffer->alloc = len;
d37 2
a38 4
	if (buffer->alloc > 0) {
		memset(buffer->buf, 0, buffer->alloc);
		xfree(buffer->buf);
	}
@


1.16.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.17 2003/09/16 03:03:47 deraadt Exp $");
a71 1
	u_int newlen;
d101 2
a102 3
	
	newlen = buffer->alloc + len + 32768;
	if (newlen > 0xa00000)
d104 2
a105 3
		    newlen);
	buffer->buf = xrealloc(buffer->buf, newlen);
	buffer->alloc = newlen;
@


1.16.4.2
log
@upgrade to OpenSSH 3.7.1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.18 2003/09/16 21:02:39 markus Exp $");
d26 2
a27 5
	const u_int len = 4096;

	buffer->alloc = 0;
	buffer->buf = xmalloc(len);
	buffer->alloc = len;
d37 2
a38 4
	if (buffer->alloc > 0) {
		memset(buffer->buf, 0, buffer->alloc);
		xfree(buffer->buf);
	}
@


1.16.4.3
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.21 2003/11/21 11:57:03 djm Exp $");
a41 1
		buffer->alloc = 0;
d107 1
a107 1

d171 1
a171 1
	u_int i;
@


1.15
log
@unneeded cast cleanup; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.14 2001/12/19 17:16:13 stevesk Exp $");
d74 3
d102 3
@


1.15.2.1
log
@Pull in OpenSSH-3.4
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.16 2002/06/26 08:54:18 markus Exp $");
a73 3
	if (len > 0x100000)
		fatal("buffer_append_space: len %u not supported", len);

a98 3
	if (buffer->alloc > 0xa00000)
		fatal("buffer_append_space: alloc %u not supported",
		    buffer->alloc);
@


1.14
log
@change the buffer/packet interface to use void* vs. char*; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.13 2001/04/12 19:15:24 markus Exp $");
d158 1
a158 1
	u_char *ucp = (u_char *) buffer->buf;
@


1.13
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.12 2001/04/07 08:55:15 markus Exp $");
d56 1
a56 1
buffer_append(Buffer *buffer, const char *data, u_int len)
d58 3
a60 3
	char *cp;
	buffer_append_space(buffer, &cp, len);
	memcpy(cp, data, len);
d69 2
a70 2
void
buffer_append_space(Buffer *buffer, char **datap, u_int len)
d72 2
d82 1
a82 1
		*datap = buffer->buf + buffer->end;
d84 1
a84 1
		return;
d101 1
d115 1
a115 1
buffer_get(Buffer *buffer, char *buf, u_int len)
d146 1
a146 1
char *
@


1.13.2.1
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.15 2002/01/18 18:14:17 stevesk Exp $");
d56 1
a56 1
buffer_append(Buffer *buffer, const void *data, u_int len)
d58 3
a60 3
	void *p;
	p = buffer_append_space(buffer, len);
	memcpy(p, data, len);
d69 2
a70 2
void *
buffer_append_space(Buffer *buffer, u_int len)
a71 2
	void *p;

d80 1
a80 1
		p = buffer->buf + buffer->end;
d82 1
a82 1
		return p;
a98 1
	/* NOTREACHED */
d112 1
a112 1
buffer_get(Buffer *buffer, void *buf, u_int len)
d143 1
a143 1
void *
d155 1
a155 1
	u_char *ucp = buffer->buf;
@


1.13.4.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.15 2002/01/18 18:14:17 stevesk Exp $");
d56 1
a56 1
buffer_append(Buffer *buffer, const void *data, u_int len)
d58 3
a60 3
	void *p;
	p = buffer_append_space(buffer, len);
	memcpy(p, data, len);
d69 2
a70 2
void *
buffer_append_space(Buffer *buffer, u_int len)
a71 2
	void *p;

d80 1
a80 1
		p = buffer->buf + buffer->end;
d82 1
a82 1
		return p;
a98 1
	/* NOTREACHED */
d112 1
a112 1
buffer_get(Buffer *buffer, void *buf, u_int len)
d143 1
a143 1
void *
d155 1
a155 1
	u_char *ucp = buffer->buf;
@


1.13.4.2
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.13.4.1 2002/03/07 17:37:46 jason Exp $");
a73 3
	if (len > 0x100000)
		fatal("buffer_append_space: len %u not supported", len);

a98 3
	if (buffer->alloc > 0xa00000)
		fatal("buffer_append_space: alloc %u not supported",
		    buffer->alloc);
@


1.12
log
@allow the ssh client act as a SOCKS4 proxy (dynamic local portforwarding).
work by Dan Kaminsky <dankamin@@cisco.com> and me. thanks to Dan for this
great patch: use 'ssh -D 1080 host' and make netscape use localhost:1080 as
a socks proxy.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.11 2001/04/05 21:02:46 markus Exp $");
d157 7
a163 2
	for (i = buffer->offset; i < buffer->end; i++)
		fprintf(stderr, " %02x", ucp[i]);
@


1.11
log
@better error message
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.10 2001/01/21 19:05:45 markus Exp $");
d159 1
a159 1
	fprintf(stderr, "\n");
@


1.10
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.9 2000/12/19 23:17:55 markus Exp $");
d115 2
a116 1
		fatal("buffer_get: trying to get more bytes than in buffer");
@


1.9
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.8 2000/09/07 20:27:50 deraadt Exp $");
d19 1
a19 1
#include "ssh.h"
@


1.8
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.7 2000/06/20 01:39:39 markus Exp $");
d56 1
a56 1
buffer_append(Buffer *buffer, const char *data, unsigned int len)
d70 1
a70 1
buffer_append_space(Buffer *buffer, char **datap, unsigned int len)
d103 1
a103 1
unsigned int
d112 1
a112 1
buffer_get(Buffer *buffer, char *buf, unsigned int len)
d123 1
a123 1
buffer_consume(Buffer *buffer, unsigned int bytes)
d133 1
a133 1
buffer_consume_end(Buffer *buffer, unsigned int bytes)
d154 1
a154 1
	unsigned char *ucp = (unsigned char *) buffer->buf;
@


1.8.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.10 2001/01/21 19:05:45 markus Exp $");
d19 1
a19 1
#include "log.h"
d56 1
a56 1
buffer_append(Buffer *buffer, const char *data, u_int len)
d70 1
a70 1
buffer_append_space(Buffer *buffer, char **datap, u_int len)
d103 1
a103 1
u_int
d112 1
a112 1
buffer_get(Buffer *buffer, char *buf, u_int len)
d123 1
a123 1
buffer_consume(Buffer *buffer, u_int bytes)
d133 1
a133 1
buffer_consume_end(Buffer *buffer, u_int bytes)
d154 1
a154 1
	u_char *ucp = (u_char *) buffer->buf;
@


1.8.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.8.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.8.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.13 2001/04/12 19:15:24 markus Exp $");
d115 1
a115 2
		fatal("buffer_get: trying to get more bytes %d than in buffer %d",
		    len, buffer->end - buffer->offset);
d156 3
a158 8
	for (i = buffer->offset; i < buffer->end; i++) {
		fprintf(stderr, "%02x", ucp[i]);
		if ((i-buffer->offset)%16==15)
			fprintf(stderr, "\r\n");
		else if ((i-buffer->offset)%2==1)
			fprintf(stderr, " ");
	}
	fprintf(stderr, "\r\n");
@


1.8.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@@


1.8.2.6
log
@Merge OpenSSH 3.1.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.15 2002/01/18 18:14:17 stevesk Exp $");
d56 1
a56 1
buffer_append(Buffer *buffer, const void *data, u_int len)
d58 3
a60 3
	void *p;
	p = buffer_append_space(buffer, len);
	memcpy(p, data, len);
d69 2
a70 2
void *
buffer_append_space(Buffer *buffer, u_int len)
a71 2
	void *p;

d80 1
a80 1
		p = buffer->buf + buffer->end;
d82 1
a82 1
		return p;
a98 1
	/* NOTREACHED */
d112 1
a112 1
buffer_get(Buffer *buffer, void *buf, u_int len)
d143 1
a143 1
void *
d155 1
a155 1
	u_char *ucp = buffer->buf;
@


1.7
log
@OpenBSD tag
@
text
@a1 3
 *
 * buffer.c
 *
a2 1
 *
a4 3
 *
 * Created: Sat Mar 18 04:15:33 1995 ylo
 *
d7 5
d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.6 2000/04/14 10:30:30 markus Exp $");
@


1.6
log
@whitespace cleanup
@
text
@d17 1
a17 1
RCSID("$Id: buffer.c,v 1.5 2000/04/12 10:22:38 markus Exp $");
@


1.6.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d17 1
a17 1
RCSID("$OpenBSD: buffer.c,v 1.7 2000/06/20 01:39:39 markus Exp $");
@


1.6.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a13 5
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d17 1
a17 1
RCSID("$OpenBSD: buffer.c,v 1.8 2000/09/07 20:27:50 deraadt Exp $");
@


1.6.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: buffer.c,v 1.10 2001/01/21 19:05:45 markus Exp $");
d19 1
a19 1
#include "log.h"
d56 1
a56 1
buffer_append(Buffer *buffer, const char *data, u_int len)
d70 1
a70 1
buffer_append_space(Buffer *buffer, char **datap, u_int len)
d103 1
a103 1
u_int
d112 1
a112 1
buffer_get(Buffer *buffer, char *buf, u_int len)
d123 1
a123 1
buffer_consume(Buffer *buffer, u_int bytes)
d133 1
a133 1
buffer_consume_end(Buffer *buffer, u_int bytes)
d154 1
a154 1
	u_char *ucp = (u_char *) buffer->buf;
@


1.6.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.5
log
@typos
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
RCSID("$Id: buffer.c,v 1.4 1999/11/24 19:53:44 markus Exp $");
d25 1
a25 1
void 
d36 1
a36 1
void 
d48 1
a48 1
void 
d57 1
a57 1
void 
d71 1
a71 1
void 
d105 1
a105 1
unsigned int 
d113 1
a113 1
void 
d124 1
a124 1
void 
d134 1
a134 1
void 
d152 1
a152 1
void 
@


1.4
log
@KNF, final part 3
@
text
@d17 1
a17 1
RCSID("$Id: buffer.c,v 1.3 1999/11/24 00:26:01 deraadt Exp $");
d117 1
a117 1
		fatal("buffer_get trying to get more bytes than in buffer");
d128 1
a128 1
		fatal("buffer_get trying to get more bytes than in buffer");
d138 1
a138 1
		fatal("buffer_get trying to get more bytes than in buffer");
@


1.3
log
@much more KNF
@
text
@d17 1
a17 1
RCSID("$Id: buffer.c,v 1.2 1999/11/23 22:25:53 markus Exp $");
d43 4
a46 2
/* Clears any data from the buffer, making it empty.  This does not actually
   zero the memory. */
d65 5
a69 3
/* Appends space to the buffer, expanding the buffer if necessary.
   This does not actually copy the data into the buffer, but instead
   returns a pointer to the allocated region. */
d86 4
a89 2
	/* If the buffer is quite empty, but all data is at the end, move
	   the data to the beginning and retry. */
@


1.2
log
@KNF part 1
@
text
@d2 13
a14 13

buffer.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Mar 18 04:15:33 1995 ylo

Functions for manipulating fifo buffers (that can grow if needed).

*/
d17 1
a17 1
RCSID("$Id: buffer.c,v 1.1 1999/09/26 20:53:34 deraadt Exp $");
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d17 1
a17 1
RCSID("$Id: buffer.c,v 1.2 1999/05/04 11:58:31 bg Exp $");
d25 2
a26 1
void buffer_init(Buffer *buffer)
d28 4
a31 4
  buffer->alloc = 4096;
  buffer->buf = xmalloc(buffer->alloc);
  buffer->offset = 0;
  buffer->end = 0;
d36 2
a37 1
void buffer_free(Buffer *buffer)
d39 2
a40 2
  memset(buffer->buf, 0, buffer->alloc);
  xfree(buffer->buf);
d46 2
a47 1
void buffer_clear(Buffer *buffer)
d49 2
a50 2
  buffer->offset = 0;
  buffer->end = 0;
d55 2
a56 1
void buffer_append(Buffer *buffer, const char *data, unsigned int len)
d58 3
a60 3
  char *cp;
  buffer_append_space(buffer, &cp, len);
  memcpy(cp, data, len);
d67 2
a68 1
void buffer_append_space(Buffer *buffer, char **datap, unsigned int len)
d70 25
a94 31
  /* If the buffer is empty, start using it from the beginning. */
  if (buffer->offset == buffer->end)
    {
      buffer->offset = 0;
      buffer->end = 0;
    }

 restart:
  /* If there is enough space to store all data, store it now. */
  if (buffer->end + len < buffer->alloc)
    {
      *datap = buffer->buf + buffer->end;
      buffer->end += len;
      return;
    }

  /* If the buffer is quite empty, but all data is at the end, move the
     data to the beginning and retry. */
  if (buffer->offset > buffer->alloc / 2)
    {
      memmove(buffer->buf, buffer->buf + buffer->offset,
	      buffer->end - buffer->offset);
      buffer->end -= buffer->offset;
      buffer->offset = 0;
      goto restart;
    }

  /* Increase the size of the buffer and retry. */
  buffer->alloc += len + 32768;
  buffer->buf = xrealloc(buffer->buf, buffer->alloc);
  goto restart;
d99 2
a100 1
unsigned int buffer_len(Buffer *buffer)
d102 1
a102 1
  return buffer->end - buffer->offset;
d107 2
a108 1
void buffer_get(Buffer *buffer, char *buf, unsigned int len)
d110 4
a113 4
  if (len > buffer->end - buffer->offset)
    fatal("buffer_get trying to get more bytes than in buffer");
  memcpy(buf, buffer->buf + buffer->offset, len);
  buffer->offset += len;
d118 2
a119 1
void buffer_consume(Buffer *buffer, unsigned int bytes)
d121 4
a124 4
  if (bytes > buffer->end - buffer->offset)
    fatal("buffer_get trying to get more bytes than in buffer");
  buffer->offset += bytes;
}  
d128 2
a129 1
void buffer_consume_end(Buffer *buffer, unsigned int bytes)
d131 4
a134 4
  if (bytes > buffer->end - buffer->offset)
    fatal("buffer_get trying to get more bytes than in buffer");
  buffer->end -= bytes;
}  
d138 2
a139 1
char *buffer_ptr(Buffer *buffer)
d141 1
a141 1
  return buffer->buf + buffer->offset;
d146 2
a147 1
void buffer_dump(Buffer *buffer)
d149 6
a154 6
  int i;
  unsigned char *ucp = (unsigned char *)buffer->buf;
  
  for (i = buffer->offset; i < buffer->end; i++)
    fprintf(stderr, " %02x", ucp[i]);
  fprintf(stderr, "\n");
@

