head	1.122;
access;
symbols
	OPENBSD_6_0:1.121.0.4
	OPENBSD_6_0_BASE:1.121
	OPENBSD_5_9:1.120.0.2
	OPENBSD_5_9_BASE:1.120
	OPENBSD_5_8:1.116.0.2
	OPENBSD_5_8_BASE:1.116
	OPENBSD_5_7:1.111.0.2
	OPENBSD_5_7_BASE:1.111
	OPENBSD_5_6:1.107.0.4
	OPENBSD_5_6_BASE:1.107
	OPENBSD_5_5:1.103.0.4
	OPENBSD_5_5_BASE:1.103
	OPENBSD_5_4:1.97.0.2
	OPENBSD_5_4_BASE:1.97
	OPENBSD_5_3:1.95.0.2
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.93.0.4
	OPENBSD_5_2_BASE:1.93
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.2
	OPENBSD_5_0:1.92.0.2
	OPENBSD_5_0_BASE:1.92
	OPENBSD_4_9:1.87.0.2
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.82.0.2
	OPENBSD_4_8_BASE:1.82
	OPENBSD_4_7:1.80.0.2
	OPENBSD_4_7_BASE:1.80
	OPENBSD_4_6:1.76.0.16
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.76.0.12
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.76.0.10
	OPENBSD_4_4_BASE:1.76
	OPENBSD_4_3:1.76.0.8
	OPENBSD_4_3_BASE:1.76
	OPENBSD_4_2:1.76.0.6
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.76.0.2
	OPENBSD_4_1_BASE:1.76
	OPENBSD_4_0:1.76.0.4
	OPENBSD_4_0_BASE:1.76
	OPENBSD_3_9:1.62.0.2
	OPENBSD_3_9_BASE:1.62
	OPENBSD_3_8:1.61.0.2
	OPENBSD_3_8_BASE:1.61
	OPENBSD_3_7:1.60.0.2
	OPENBSD_3_7_BASE:1.60
	OPENBSD_3_6:1.58.0.2
	OPENBSD_3_6_BASE:1.58
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.54.0.2
	OPENBSD_3_4_BASE:1.54
	OPENBSD_3_3:1.52.0.2
	OPENBSD_3_3_BASE:1.52
	OPENBSD_3_2:1.50.0.2
	OPENBSD_3_2_BASE:1.50
	OPENBSD_3_1:1.48.0.2
	OPENBSD_3_1_BASE:1.48
	OPENBSD_3_0:1.39.0.2
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9_BASE:1.32
	OPENBSD_2_9:1.32.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7;
locks; strict;
comment	@ * @;


1.122
date	2016.11.25.23.24.45;	author djm;	state Exp;
branches;
next	1.121;
commitid	FzgmoB6h0WmGeoxd;

1.121
date	2016.04.09.12.39.30;	author djm;	state Exp;
branches;
next	1.120;
commitid	7ymBtAKlgDHKj5P1;

1.120
date	2015.12.11.04.21.11;	author mmcc;	state Exp;
branches;
next	1.119;
commitid	frWDG3VpknGQboCf;

1.119
date	2015.12.11.02.31.47;	author mmcc;	state Exp;
branches;
next	1.118;
commitid	f7EpsYIFQYQNXTtF;

1.118
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.117;
commitid	qST12VGCwbX5zIfM;

1.117
date	2015.09.13.14.39.16;	author tim;	state Exp;
branches;
next	1.116;
commitid	o7lHtj0fKIytZvfO;

1.116
date	2015.07.09.09.49.46;	author markus;	state Exp;
branches;
next	1.115;
commitid	fdzTyLRhaYK4offX;

1.115
date	2015.07.03.03.43.18;	author djm;	state Exp;
branches;
next	1.114;
commitid	cnvu1kGgoFFYv6D3;

1.114
date	2015.04.17.13.32.09;	author djm;	state Exp;
branches;
next	1.113;
commitid	hkXye5X489yRx8WB;

1.113
date	2015.03.31.22.55.50;	author djm;	state Exp;
branches;
next	1.112;
commitid	1Q0K4vbdUZSx9RYX;

1.112
date	2015.03.18.01.44.21;	author djm;	state Exp;
branches;
next	1.111;
commitid	kOUyzaNxRH1hKWEI;

1.111
date	2015.02.23.16.55.51;	author djm;	state Exp;
branches;
next	1.110;
commitid	QDXG2zGeVVjNXP3D;

1.110
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	cBx23BaCk6gYBpRj;

1.109
date	2015.01.08.10.14.08;	author djm;	state Exp;
branches;
next	1.108;
commitid	397Wklb10N5bP6VW;

1.108
date	2014.12.04.02.24.32;	author djm;	state Exp;
branches;
next	1.107;
commitid	0YGyOuIh3H3xTolw;

1.107
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.106;
commitid	1h9UxAQmwdaqUzyX;

1.106
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2014.03.12.04.51.12;	author djm;	state Exp;
branches;
next	1.103;

1.103
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.102;

1.102
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.101;

1.101
date	2013.12.29.04.35.50;	author djm;	state Exp;
branches;
next	1.100;

1.100
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2013.12.06.13.34.54;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2013.11.21.00.45.43;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.96;

1.96
date	2013.04.19.01.06.50;	author djm;	state Exp;
branches;
next	1.95;

1.95
date	2013.01.08.18.49.04;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2012.12.11.22.31.18;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2012.01.25.19.36.31;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2011.06.14.22.49.18;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2011.05.23.07.24.57;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2011.05.13.00.05.36;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2011.05.10.05.46.46;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2011.05.04.21.15.29;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2010.11.29.18.57.04;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2010.11.21.10.57.07;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2010.10.28.11.22.09;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2010.09.08.03.54.36;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2010.08.04.05.49.22;	author djm;	state Exp;
branches;
next	1.81;

1.81
date	2010.08.04.05.42.47;	author djm;	state Exp;
branches;
next	1.80;

1.80
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2010.01.12.00.16.47;	author dtucker;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.11.04.46.45;	author dtucker;	state Exp;
branches;
next	1.77;

1.77
date	2009.10.22.22.26.13;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2006.08.01.23.36.11;	author stevesk;	state Exp;
branches;
next	1.74;

1.74
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.73;

1.73
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.11.20.27.56;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.09.15.15.10;	author stevesk;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.25.08.02.27;	author dtucker;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.19.18.59.09;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.13.10.26.52;	author dtucker;	state Exp;
branches;
next	1.62;

1.62
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2004.12.11.01.48.56;	author dtucker;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2004.12.06.11.41.03;	author dtucker;	state Exp;
branches;
next	1.58;

1.58
date	2004.08.23.11.48.09;	author djm;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2003.09.18.07.56.05;	author markus;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2003.05.24.09.30.39;	author djm;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2003.05.11.16.56.48;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2003.03.13.11.42.18;	author markus;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.11.15.10.03.09;	author fgsch;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.24.14.55.38;	author markus;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2002.05.23.19.24.30;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.28.15.46.33;	author markus;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.14.23.41.01;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.29.21.56.01;	author stevesk;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.27.18.26.13;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.19.17.16.13;	author stevesk;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.07.10.29.52;	author markus;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2001.09.23.11.09.13;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.23.15.12.17;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.07.20.23.03;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.29.12.31.27;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.28.10.08.55;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.16.20.51.57;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.18.23.44.51;	author markus;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2001.04.15.16.58.03;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.26.23.12.42;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.26.08.07.07;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.21.09.05.54;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.08.19.30.51;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.28.22.27.05;	author stevesk;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.21.19.05.44;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.20.19.26.56;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.19.22.43.44;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.12.19.50.37;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.05.19.18.47;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.20.01.39.38;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.26.21.28.32;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2000.04.26.20.56.29;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.14.10.30.30;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.04.21.37.27;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.12.06.19.11.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.11.24.19.53.44;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.24.00.26.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.11.23.22.25.52;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.10.11.20.00.35;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.09.30.18.28.35;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	99.09.30.16.55.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.30.16.34.21;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	99.09.28.04.45.35;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	99.09.26.21.02.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.33;	author deraadt;	state Exp;
branches;
next	;

1.16.2.1
date	2000.09.01.18.23.17;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2000.11.08.21.30.27;	author jason;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.03.12.15.44.08;	author jason;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.03.21.18.52.36;	author jason;	state Exp;
branches;
next	;

1.20.2.1
date	2001.02.16.20.12.54;	author jason;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.02.19.17.18.40;	author jason;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.03.21.19.46.23;	author jason;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2001.05.07.21.09.26;	author jason;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.32.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.39.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	;

1.48.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2003.04.03.22.35.16;	author miod;	state Exp;
branches;
next	;

1.50.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.52.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.54.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.55.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.58.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.60.2.1
date	2005.09.04.18.40.00;	author brad;	state Exp;
branches;
next	;

1.61.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.62.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.122
log
@use sshbuf_allocate() to pre-allocate the buffer used for loading
keys. This avoids implicit realloc inside the buffer code, which
might theoretically leave fragments of the key on the heap. This
doesn't appear to happen in practice for normal sized keys, but
was observed for novelty oversize ones.

Pointed out by Jann Horn of Project Zero; ok markus@@
@
text
@/* $OpenBSD: authfile.c,v 1.121 2016/04/09 12:39:30 djm Exp $ */
/*
 * Copyright (c) 2000, 2013 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "cipher.h"
#include "ssh.h"
#include "log.h"
#include "authfile.h"
#include "rsa.h"
#include "misc.h"
#include "atomicio.h"
#include "sshkey.h"
#include "sshbuf.h"
#include "ssherr.h"
#include "krl.h"

#define MAX_KEY_FILE_SIZE	(1024 * 1024)

/* Save a key blob to a file */
static int
sshkey_save_private_blob(struct sshbuf *keybuf, const char *filename)
{
	int fd, oerrno;

	if ((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600)) < 0)
		return SSH_ERR_SYSTEM_ERROR;
	if (atomicio(vwrite, fd, (u_char *)sshbuf_ptr(keybuf),
	    sshbuf_len(keybuf)) != sshbuf_len(keybuf)) {
		oerrno = errno;
		close(fd);
		unlink(filename);
		errno = oerrno;
		return SSH_ERR_SYSTEM_ERROR;
	}
	close(fd);
	return 0;
}

int
sshkey_save_private(struct sshkey *key, const char *filename,
    const char *passphrase, const char *comment,
    int force_new_format, const char *new_format_cipher, int new_format_rounds)
{
	struct sshbuf *keyblob = NULL;
	int r;

	if ((keyblob = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,
	    force_new_format, new_format_cipher, new_format_rounds)) != 0)
		goto out;
	if ((r = sshkey_save_private_blob(keyblob, filename)) != 0)
		goto out;
	r = 0;
 out:
	sshbuf_free(keyblob);
	return r;
}

/* Load a key from a fd into a buffer */
int
sshkey_load_file(int fd, struct sshbuf *blob)
{
	u_char buf[1024];
	size_t len;
	struct stat st;
	int r, dontmax = 0;

	if (fstat(fd, &st) < 0)
		return SSH_ERR_SYSTEM_ERROR;
	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
	    st.st_size > MAX_KEY_FILE_SIZE)
		return SSH_ERR_INVALID_FORMAT;
	/*
	 * Pre-allocate the buffer used for the key contents and clamp its
	 * maximum size. This ensures that key contents are never leaked via
	 * implicit realloc() in the sshbuf code.
	 */
	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
		st.st_size = 64*1024; /* 64k should be enough for anyone :) */
		dontmax = 1;
	}
	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
		return r;
	for (;;) {
		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
			if (errno == EPIPE)
				break;
			r = SSH_ERR_SYSTEM_ERROR;
			goto out;
		}
		if ((r = sshbuf_put(blob, buf, len)) != 0)
			goto out;
		if (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
	}
	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
	    st.st_size != (off_t)sshbuf_len(blob)) {
		r = SSH_ERR_FILE_CHANGED;
		goto out;
	}
	r = 0;

 out:
	explicit_bzero(buf, sizeof(buf));
	if (r != 0)
		sshbuf_reset(blob);
	return r;
}

#ifdef WITH_SSH1
/*
 * Loads the public part of the ssh v1 key file.  Returns NULL if an error was
 * encountered (the file does not exist or is not readable), and the key
 * otherwise.
 */
static int
sshkey_load_public_rsa1(int fd, struct sshkey **keyp, char **commentp)
{
	struct sshbuf *b = NULL;
	int r;

	if (keyp != NULL)
		*keyp = NULL;
	if (commentp != NULL)
		*commentp = NULL;

	if ((b = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshkey_load_file(fd, b)) != 0)
		goto out;
	if ((r = sshkey_parse_public_rsa1_fileblob(b, keyp, commentp)) != 0)
		goto out;
	r = 0;
 out:
	sshbuf_free(b);
	return r;
}
#endif /* WITH_SSH1 */

/* XXX remove error() calls from here? */
int
sshkey_perm_ok(int fd, const char *filename)
{
	struct stat st;

	if (fstat(fd, &st) < 0)
		return SSH_ERR_SYSTEM_ERROR;
	/*
	 * if a key owned by the user is accessed, then we check the
	 * permissions of the file. if the key owned by a different user,
	 * then we don't care.
	 */
	if ((st.st_uid == getuid()) && (st.st_mode & 077) != 0) {
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@");
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("Permissions 0%3.3o for '%s' are too open.",
		    (u_int)st.st_mode & 0777, filename);
		error("It is required that your private key files are NOT accessible by others.");
		error("This private key will be ignored.");
		return SSH_ERR_KEY_BAD_PERMISSIONS;
	}
	return 0;
}

/* XXX kill perm_ok now that we have SSH_ERR_KEY_BAD_PERMISSIONS? */
int
sshkey_load_private_type(int type, const char *filename, const char *passphrase,
    struct sshkey **keyp, char **commentp, int *perm_ok)
{
	int fd, r;

	if (keyp != NULL)
		*keyp = NULL;
	if (commentp != NULL)
		*commentp = NULL;

	if ((fd = open(filename, O_RDONLY)) < 0) {
		if (perm_ok != NULL)
			*perm_ok = 0;
		return SSH_ERR_SYSTEM_ERROR;
	}
	if (sshkey_perm_ok(fd, filename) != 0) {
		if (perm_ok != NULL)
			*perm_ok = 0;
		r = SSH_ERR_KEY_BAD_PERMISSIONS;
		goto out;
	}
	if (perm_ok != NULL)
		*perm_ok = 1;

	r = sshkey_load_private_type_fd(fd, type, passphrase, keyp, commentp);
 out:
	close(fd);
	return r;
}

int
sshkey_load_private_type_fd(int fd, int type, const char *passphrase,
    struct sshkey **keyp, char **commentp)
{
	struct sshbuf *buffer = NULL;
	int r;

	if (keyp != NULL)
		*keyp = NULL;
	if ((buffer = sshbuf_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshkey_load_file(fd, buffer)) != 0 ||
	    (r = sshkey_parse_private_fileblob_type(buffer, type,
	    passphrase, keyp, commentp)) != 0)
		goto out;

	/* success */
	r = 0;
 out:
	sshbuf_free(buffer);
	return r;
}

/* XXX this is almost identical to sshkey_load_private_type() */
int
sshkey_load_private(const char *filename, const char *passphrase,
    struct sshkey **keyp, char **commentp)
{
	struct sshbuf *buffer = NULL;
	int r, fd;

	if (keyp != NULL)
		*keyp = NULL;
	if (commentp != NULL)
		*commentp = NULL;

	if ((fd = open(filename, O_RDONLY)) < 0)
		return SSH_ERR_SYSTEM_ERROR;
	if (sshkey_perm_ok(fd, filename) != 0) {
		r = SSH_ERR_KEY_BAD_PERMISSIONS;
		goto out;
	}

	if ((buffer = sshbuf_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshkey_load_file(fd, buffer)) != 0 ||
	    (r = sshkey_parse_private_fileblob(buffer, passphrase, keyp,
	    commentp)) != 0)
		goto out;
	r = 0;
 out:
	close(fd);
	sshbuf_free(buffer);
	return r;
}

static int
sshkey_try_load_public(struct sshkey *k, const char *filename, char **commentp)
{
	FILE *f;
	char line[SSH_MAX_PUBKEY_BYTES];
	char *cp;
	u_long linenum = 0;
	int r;

	if (commentp != NULL)
		*commentp = NULL;
	if ((f = fopen(filename, "r")) == NULL)
		return SSH_ERR_SYSTEM_ERROR;
	while (read_keyfile_line(f, filename, line, sizeof(line),
		    &linenum) != -1) {
		cp = line;
		switch (*cp) {
		case '#':
		case '\n':
		case '\0':
			continue;
		}
		/* Abort loading if this looks like a private key */
		if (strncmp(cp, "-----BEGIN", 10) == 0 ||
		    strcmp(cp, "SSH PRIVATE KEY FILE") == 0)
			break;
		/* Skip leading whitespace. */
		for (; *cp && (*cp == ' ' || *cp == '\t'); cp++)
			;
		if (*cp) {
			if ((r = sshkey_read(k, &cp)) == 0) {
				cp[strcspn(cp, "\r\n")] = '\0';
				if (commentp) {
					*commentp = strdup(*cp ?
					    cp : filename);
					if (*commentp == NULL)
						r = SSH_ERR_ALLOC_FAIL;
				}
				fclose(f);
				return r;
			}
		}
	}
	fclose(f);
	return SSH_ERR_INVALID_FORMAT;
}

/* load public key from ssh v1 private or any pubkey file */
int
sshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)
{
	struct sshkey *pub = NULL;
	char file[PATH_MAX];
	int r, fd;

	if (keyp != NULL)
		*keyp = NULL;
	if (commentp != NULL)
		*commentp = NULL;

	/* XXX should load file once and attempt to parse each format */

	if ((fd = open(filename, O_RDONLY)) < 0)
		goto skip;
#ifdef WITH_SSH1
	/* try rsa1 private key */
	r = sshkey_load_public_rsa1(fd, keyp, commentp);
	close(fd);
	switch (r) {
	case SSH_ERR_INTERNAL_ERROR:
	case SSH_ERR_ALLOC_FAIL:
	case SSH_ERR_INVALID_ARGUMENT:
	case SSH_ERR_SYSTEM_ERROR:
	case 0:
		return r;
	}
#else /* WITH_SSH1 */
	close(fd);
#endif /* WITH_SSH1 */

	/* try ssh2 public key */
	if ((pub = sshkey_new(KEY_UNSPEC)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {
		if (keyp != NULL)
			*keyp = pub;
		return 0;
	}
	sshkey_free(pub);

#ifdef WITH_SSH1
	/* try rsa1 public key */
	if ((pub = sshkey_new(KEY_RSA1)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {
		if (keyp != NULL)
			*keyp = pub;
		return 0;
	}
	sshkey_free(pub);
#endif /* WITH_SSH1 */

 skip:
	/* try .pub suffix */
	if ((pub = sshkey_new(KEY_UNSPEC)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	r = SSH_ERR_ALLOC_FAIL;	/* in case strlcpy or strlcat fail */
	if ((strlcpy(file, filename, sizeof file) < sizeof(file)) &&
	    (strlcat(file, ".pub", sizeof file) < sizeof(file)) &&
	    (r = sshkey_try_load_public(pub, file, commentp)) == 0) {
		if (keyp != NULL)
			*keyp = pub;
		return 0;
	}
	sshkey_free(pub);

	return r;
}

/* Load the certificate associated with the named private key */
int
sshkey_load_cert(const char *filename, struct sshkey **keyp)
{
	struct sshkey *pub = NULL;
	char *file = NULL;
	int r = SSH_ERR_INTERNAL_ERROR;

	if (keyp != NULL)
		*keyp = NULL;

	if (asprintf(&file, "%s-cert.pub", filename) == -1)
		return SSH_ERR_ALLOC_FAIL;

	if ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {
		goto out;
	}
	if ((r = sshkey_try_load_public(pub, file, NULL)) != 0)
		goto out;
	/* success */
	if (keyp != NULL) {
		*keyp = pub;
		pub = NULL;
	}
	r = 0;
 out:
	free(file);
	sshkey_free(pub);
	return r;
}

/* Load private key and certificate */
int
sshkey_load_private_cert(int type, const char *filename, const char *passphrase,
    struct sshkey **keyp, int *perm_ok)
{
	struct sshkey *key = NULL, *cert = NULL;
	int r;

	if (keyp != NULL)
		*keyp = NULL;

	switch (type) {
#ifdef WITH_OPENSSL
	case KEY_RSA:
	case KEY_DSA:
	case KEY_ECDSA:
#endif /* WITH_OPENSSL */
	case KEY_ED25519:
	case KEY_UNSPEC:
		break;
	default:
		return SSH_ERR_KEY_TYPE_UNKNOWN;
	}

	if ((r = sshkey_load_private_type(type, filename,
	    passphrase, &key, NULL, perm_ok)) != 0 ||
	    (r = sshkey_load_cert(filename, &cert)) != 0)
		goto out;

	/* Make sure the private key matches the certificate */
	if (sshkey_equal_public(key, cert) == 0) {
		r = SSH_ERR_KEY_CERT_MISMATCH;
		goto out;
	}

	if ((r = sshkey_to_certified(key)) != 0 ||
	    (r = sshkey_cert_copy(cert, key)) != 0)
		goto out;
	r = 0;
	if (keyp != NULL) {
		*keyp = key;
		key = NULL;
	}
 out:
	sshkey_free(key);
	sshkey_free(cert);
	return r;
}

/*
 * Returns success if the specified "key" is listed in the file "filename",
 * SSH_ERR_KEY_NOT_FOUND: if the key is not listed or another error.
 * If "strict_type" is set then the key type must match exactly,
 * otherwise a comparison that ignores certficiate data is performed.
 * If "check_ca" is set and "key" is a certificate, then its CA key is
 * also checked and sshkey_in_file() will return success if either is found.
 */
int
sshkey_in_file(struct sshkey *key, const char *filename, int strict_type,
    int check_ca)
{
	FILE *f;
	char line[SSH_MAX_PUBKEY_BYTES];
	char *cp;
	u_long linenum = 0;
	int r = 0;
	struct sshkey *pub = NULL;
	int (*sshkey_compare)(const struct sshkey *, const struct sshkey *) =
	    strict_type ?  sshkey_equal : sshkey_equal_public;

	if ((f = fopen(filename, "r")) == NULL)
		return SSH_ERR_SYSTEM_ERROR;

	while (read_keyfile_line(f, filename, line, sizeof(line),
	    &linenum) != -1) {
		cp = line;

		/* Skip leading whitespace. */
		for (; *cp && (*cp == ' ' || *cp == '\t'); cp++)
			;

		/* Skip comments and empty lines */
		switch (*cp) {
		case '#':
		case '\n':
		case '\0':
			continue;
		}

		if ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {
			r = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		if ((r = sshkey_read(pub, &cp)) != 0)
			goto out;
		if (sshkey_compare(key, pub) ||
		    (check_ca && sshkey_is_cert(key) &&
		    sshkey_compare(key->cert->signature_key, pub))) {
			r = 0;
			goto out;
		}
		sshkey_free(pub);
		pub = NULL;
	}
	r = SSH_ERR_KEY_NOT_FOUND;
 out:
	sshkey_free(pub);
	fclose(f);
	return r;
}

/*
 * Checks whether the specified key is revoked, returning 0 if not,
 * SSH_ERR_KEY_REVOKED if it is or another error code if something
 * unexpected happened.
 * This will check both the key and, if it is a certificate, its CA key too.
 * "revoked_keys_file" may be a KRL or a one-per-line list of public keys.
 */
int
sshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file)
{
	int r;

	r = ssh_krl_file_contains_key(revoked_keys_file, key);
	/* If this was not a KRL to begin with then continue below */
	if (r != SSH_ERR_KRL_BAD_MAGIC)
		return r;

	/*
	 * If the file is not a KRL or we can't handle KRLs then attempt to
	 * parse the file as a flat list of keys.
	 */
	switch ((r = sshkey_in_file(key, revoked_keys_file, 0, 1))) {
	case 0:
		/* Key found => revoked */
		return SSH_ERR_KEY_REVOKED;
	case SSH_ERR_KEY_NOT_FOUND:
		/* Key not found => not revoked */
		return 0;
	default:
		/* Some other error occurred */
		return r;
	}
}

@


1.121
log
@make private key loading functions consistently handle NULL
key pointer arguments; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.120 2015/12/11 04:21:11 mmcc Exp $ */
d101 1
a101 1
	int r;
d108 12
@


1.120
log
@Remove NULL-checks before sshbuf_free().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.119 2015/12/11 02:31:47 mmcc Exp $ */
d148 2
a149 1
	*keyp = NULL;
d199 2
a200 1
	*keyp = NULL;
d231 2
d257 2
a258 1
	*keyp = NULL;
d411 2
a412 1
	*keyp = NULL;
d422 5
a426 3

	*keyp = pub;
	pub = NULL;
a427 1

d442 2
a443 1
	*keyp = NULL;
d473 4
a476 2
	*keyp = key;
	key = NULL;
@


1.119
log
@Remove NULL-checks before sshkey_free().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.118 2015/12/10 17:08:40 mmcc Exp $ */
d241 1
a241 2
	if (buffer != NULL)
		sshbuf_free(buffer);
d275 1
a275 2
	if (buffer != NULL)
		sshbuf_free(buffer);
@


1.118
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.117 2015/09/13 14:39:16 tim Exp $ */
d425 1
a425 2
	if (pub != NULL)
		sshkey_free(pub);
d470 2
a471 4
	if (key != NULL)
		sshkey_free(key);
	if (cert != NULL)
		sshkey_free(cert);
d532 1
a532 2
	if (pub != NULL)
		sshkey_free(pub);
@


1.117
log
@- Fix error message: passphrase needs to be at least 5 characters, not 4.
- Remove unused function argument.
- Remove two unnecessary variables.

OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.116 2015/07/09 09:49:46 markus Exp $ */
d424 1
a424 2
	if (file != NULL)
		free(file);
@


1.116
log
@re-enable ed25519-certs if compiled w/o openssl; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.115 2015/07/03 03:43:18 djm Exp $ */
d270 2
a271 2
	    (r = sshkey_parse_private_fileblob(buffer, passphrase, filename,
	    keyp, commentp)) != 0)
@


1.115
log
@delete support for legacy v00 certificates; "sure" markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.114 2015/04/17 13:32:09 djm Exp $ */
a39 1
#include "key.h"
d46 1
d446 1
a447 1
#endif /* WITH_OPENSSL */
@


1.114
log
@s/recommended/required/ that private keys be og-r
this wording change was made a while ago but got accidentally reverted
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.113 2015/03/31 22:55:50 djm Exp $ */
d465 1
a465 1
	if ((r = sshkey_to_certified(key, sshkey_cert_is_legacy(cert))) != 0 ||
@


1.113
log
@fd leak for !ssh1 case; found by unittests; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.112 2015/03/18 01:44:21 djm Exp $ */
d184 1
a184 1
		error("It is recommended that your private key files are NOT accessible by others.");
@


1.112
log
@KRL support doesn't need OpenSSL anymore, remove #ifdefs
from around call
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.111 2015/02/23 16:55:51 djm Exp $ */
d357 2
@


1.111
log
@add an XXX to remind me to improve sshkey_load_public
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.110 2015/01/20 23:14:00 deraadt Exp $ */
a551 1
#ifdef WITH_OPENSSL
a555 1
#endif
@


1.110
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.109 2015/01/08 10:14:08 djm Exp $ */
d341 2
d394 1
@


1.109
log
@deprecate key_load_private_pem() and sshkey_load_private_pem()
interfaces. Refactor the generic key loading API to not require
pathnames to be specified (they weren't really used).

Fixes a few other things en passant:

Makes ed25519 keys work for hostbased authentication (ssh-keysign
previously used the PEM-only routines).

Fixes key comment regression bz#2306: key pathnames were being lost as
comment fields.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.108 2014/12/04 02:24:32 djm Exp $ */
a28 1
#include <sys/param.h>
d37 1
d333 1
a333 1
	char file[MAXPATHLEN];
@


1.108
log
@add RevokedHostKeys option for the client

Allow textfile or KRL-based revocation of hostkeys.
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.107 2014/06/24 01:13:21 djm Exp $ */
d96 1
a96 1
sshkey_load_file(int fd, const char *filename, struct sshbuf *blob)
d143 1
a143 2
sshkey_load_public_rsa1(int fd, const char *filename,
    struct sshkey **keyp, char **commentp)
d154 1
a154 1
	if ((r = sshkey_load_file(fd, filename, b)) != 0)
a164 27
#ifdef WITH_OPENSSL
/* XXX Deprecate? */
int
sshkey_load_private_pem(int fd, int type, const char *passphrase,
    struct sshkey **keyp, char **commentp)
{
	struct sshbuf *buffer = NULL;
	int r;

	*keyp = NULL;
	if (commentp != NULL)
		*commentp = NULL;

	if ((buffer = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshkey_load_file(fd, NULL, buffer)) != 0)
		goto out;
	if ((r = sshkey_parse_private_pem_fileblob(buffer, type, passphrase,
	    keyp, commentp)) != 0)
		goto out;
	r = 0;
 out:
	sshbuf_free(buffer);
	return r;
}
#endif /* WITH_OPENSSL */

a196 1
	struct sshbuf *buffer = NULL;
d216 13
d233 3
a235 4
	if ((r = sshkey_load_file(fd, filename, buffer)) != 0)
		goto out;
	if ((r = sshkey_parse_private_fileblob_type(buffer, type, passphrase,
	    keyp, commentp)) != 0)
d237 2
a240 1
	close(fd);
d269 1
a269 1
	if ((r = sshkey_load_file(fd, filename, buffer)) != 0 ||
d345 1
a345 1
	r = sshkey_load_public_rsa1(fd, filename, keyp, commentp);
@


1.107
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.106 2014/04/29 18:01:49 markus Exp $ */
d49 1
d493 1
a493 1
 * If strict_type is set then the key type must match exactly,
d495 2
d499 2
a500 1
sshkey_in_file(struct sshkey *key, const char *filename, int strict_type)
d511 2
a512 6
	if ((f = fopen(filename, "r")) == NULL) {
		if (errno == ENOENT)
			return SSH_ERR_KEY_NOT_FOUND;
		else
			return SSH_ERR_SYSTEM_ERROR;
	}
d536 3
a538 1
		if (sshkey_compare(key, pub)) {
d551 36
@


1.106
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.105 2014/04/28 03:09:18 djm Exp $ */
a2 13
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * This file contains functions for reading and writing identity files, and
 * for reading the passphrase from the user.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
a31 8
#ifdef WITH_OPENSSL
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#endif

#include "crypto_api.h"

a38 3
#include <util.h>

#include "xmalloc.h"
a39 1
#include "buffer.h"
d47 2
a48 10
#include "uuencode.h"

/* openssh private key file format */
#define MARK_BEGIN		"-----BEGIN OPENSSH PRIVATE KEY-----\n"
#define MARK_END		"-----END OPENSSH PRIVATE KEY-----\n"
#define KDFNAME			"bcrypt"
#define AUTH_MAGIC		"openssh-key-v1"
#define SALT_LEN		16
#define DEFAULT_CIPHERNAME	"aes256-cbc"
#define	DEFAULT_ROUNDS		16
a51 470
/* Version identification string for SSH v1 identity files. */
static const char authfile_id_string[] =
    "SSH PRIVATE KEY FILE FORMAT 1.1\n";

static int
key_private_to_blob2(Key *prv, Buffer *blob, const char *passphrase,
    const char *comment, const char *ciphername, int rounds)
{
	u_char *key, *cp, salt[SALT_LEN];
	size_t keylen, ivlen, blocksize, authlen;
	u_int len, check;
	int i, n;
	const Cipher *c;
	Buffer encoded, b, kdf;
	CipherContext ctx;
	const char *kdfname = KDFNAME;

	if (rounds <= 0)
		rounds = DEFAULT_ROUNDS;
	if (passphrase == NULL || !strlen(passphrase)) {
		ciphername = "none";
		kdfname = "none";
	} else if (ciphername == NULL)
		ciphername = DEFAULT_CIPHERNAME;
	else if (cipher_number(ciphername) != SSH_CIPHER_SSH2)
		fatal("invalid cipher");

	if ((c = cipher_by_name(ciphername)) == NULL)
		fatal("unknown cipher name");
	buffer_init(&kdf);
	blocksize = cipher_blocksize(c);
	keylen = cipher_keylen(c);
	ivlen = cipher_ivlen(c);
	authlen = cipher_authlen(c);
	key = xcalloc(1, keylen + ivlen);
	if (strcmp(kdfname, "none") != 0) {
		arc4random_buf(salt, SALT_LEN);
		if (bcrypt_pbkdf(passphrase, strlen(passphrase),
		    salt, SALT_LEN, key, keylen + ivlen, rounds) < 0)
			fatal("bcrypt_pbkdf failed");
		buffer_put_string(&kdf, salt, SALT_LEN);
		buffer_put_int(&kdf, rounds);
	}
	cipher_init(&ctx, c, key, keylen, key + keylen , ivlen, 1);
	explicit_bzero(key, keylen + ivlen);
	free(key);

	buffer_init(&encoded);
	buffer_append(&encoded, AUTH_MAGIC, sizeof(AUTH_MAGIC));
	buffer_put_cstring(&encoded, ciphername);
	buffer_put_cstring(&encoded, kdfname);
	buffer_put_string(&encoded, buffer_ptr(&kdf), buffer_len(&kdf));
	buffer_put_int(&encoded, 1);			/* number of keys */
	key_to_blob(prv, &cp, &len);			/* public key */
	buffer_put_string(&encoded, cp, len);

	explicit_bzero(cp, len);
	free(cp);

	buffer_free(&kdf);

	/* set up the buffer that will be encrypted */
	buffer_init(&b);

	/* Random check bytes */
	check = arc4random();
	buffer_put_int(&b, check);
	buffer_put_int(&b, check);

	/* append private key and comment*/
	key_private_serialize(prv, &b);
	buffer_put_cstring(&b, comment);

	/* padding */
	i = 0;
	while (buffer_len(&b) % blocksize)
		buffer_put_char(&b, ++i & 0xff);

	/* length */
	buffer_put_int(&encoded, buffer_len(&b));

	/* encrypt */
	cp = buffer_append_space(&encoded, buffer_len(&b) + authlen);
	if (cipher_crypt(&ctx, 0, cp, buffer_ptr(&b), buffer_len(&b), 0,
	    authlen) != 0)
		fatal("%s: cipher_crypt failed", __func__);
	buffer_free(&b);
	cipher_cleanup(&ctx);

	/* uuencode */
	len = 2 * buffer_len(&encoded);
	cp = xmalloc(len);
	n = uuencode(buffer_ptr(&encoded), buffer_len(&encoded),
	    (char *)cp, len);
	if (n < 0)
		fatal("%s: uuencode", __func__);

	buffer_clear(blob);
	buffer_append(blob, MARK_BEGIN, sizeof(MARK_BEGIN) - 1);
	for (i = 0; i < n; i++) {
		buffer_put_char(blob, cp[i]);
		if (i % 70 == 69)
			buffer_put_char(blob, '\n');
	}
	if (i % 70 != 69)
		buffer_put_char(blob, '\n');
	buffer_append(blob, MARK_END, sizeof(MARK_END) - 1);
	free(cp);

	return buffer_len(blob);
}

static Key *
key_parse_private2(Buffer *blob, int type, const char *passphrase,
    char **commentp)
{
	u_char *key = NULL, *cp, *salt = NULL, pad, last;
	char *comment = NULL, *ciphername = NULL, *kdfname = NULL;
	const u_char *kdfp;
	u_int keylen = 0, ivlen, blocksize, slen, klen, len, rounds, nkeys;
	u_int check1, check2, m1len, m2len;
	size_t authlen;
	const Cipher *c;
	Buffer b, encoded, copy, kdf;
	CipherContext ctx;
	Key *k = NULL;
	int dlen, ret, i;

	buffer_init(&b);
	buffer_init(&kdf);
	buffer_init(&encoded);
	buffer_init(&copy);

	/* uudecode */
	m1len = sizeof(MARK_BEGIN) - 1;
	m2len = sizeof(MARK_END) - 1;
	cp = buffer_ptr(blob);
	len = buffer_len(blob);
	if (len < m1len || memcmp(cp, MARK_BEGIN, m1len)) {
		debug("%s: missing begin marker", __func__);
		goto out;
	}
	cp += m1len;
	len -= m1len;
	while (len) {
		if (*cp != '\n' && *cp != '\r')
			buffer_put_char(&encoded, *cp);
		last = *cp;
		len--;
		cp++;
		if (last == '\n') {
			if (len >= m2len && !memcmp(cp, MARK_END, m2len)) {
				buffer_put_char(&encoded, '\0');
				break;
			}
		}
	}
	if (!len) {
		debug("%s: no end marker", __func__);
		goto out;
	}
	len = buffer_len(&encoded);
	if ((cp = buffer_append_space(&copy, len)) == NULL) {
		error("%s: buffer_append_space", __func__);
		goto out;
	}
	if ((dlen = uudecode(buffer_ptr(&encoded), cp, len)) < 0) {
		error("%s: uudecode failed", __func__);
		goto out;
	}
	if ((u_int)dlen > len) {
		error("%s: crazy uudecode length %d > %u", __func__, dlen, len);
		goto out;
	}
	buffer_consume_end(&copy, len - dlen);
	if (buffer_len(&copy) < sizeof(AUTH_MAGIC) ||
	    memcmp(buffer_ptr(&copy), AUTH_MAGIC, sizeof(AUTH_MAGIC))) {
		error("%s: bad magic", __func__);
		goto out;
	}
	buffer_consume(&copy, sizeof(AUTH_MAGIC));

	ciphername = buffer_get_cstring_ret(&copy, NULL);
	if (ciphername == NULL ||
	    (c = cipher_by_name(ciphername)) == NULL) {
		error("%s: unknown cipher name", __func__);
		goto out;
	}
	if ((passphrase == NULL || !strlen(passphrase)) &&
	    strcmp(ciphername, "none") != 0) {
		/* passphrase required */
		goto out;
	}
	kdfname = buffer_get_cstring_ret(&copy, NULL);
	if (kdfname == NULL ||
	    (strcmp(kdfname, "none") != 0 && strcmp(kdfname, "bcrypt") != 0)) {
		error("%s: unknown kdf name", __func__);
		goto out;
	}
	if (!strcmp(kdfname, "none") && strcmp(ciphername, "none") != 0) {
		error("%s: cipher %s requires kdf", __func__, ciphername);
		goto out;
	}
	/* kdf options */
	kdfp = buffer_get_string_ptr_ret(&copy, &klen);
	if (kdfp == NULL) {
		error("%s: kdf options not set", __func__);
		goto out;
	}
	if (klen > 0) {
		if ((cp = buffer_append_space(&kdf, klen)) == NULL) {
			error("%s: kdf alloc failed", __func__);
			goto out;
		}
		memcpy(cp, kdfp, klen);
	}
	/* number of keys */
	if (buffer_get_int_ret(&nkeys, &copy) < 0) {
		error("%s: key counter missing", __func__);
		goto out;
	}
	if (nkeys != 1) {
		error("%s: only one key supported", __func__);
		goto out;
	}
	/* pubkey */
	if ((cp = buffer_get_string_ret(&copy, &len)) == NULL) {
		error("%s: pubkey not found", __func__);
		goto out;
	}
	free(cp); /* XXX check pubkey against decrypted private key */

	/* size of encrypted key blob */
	len = buffer_get_int(&copy);
	blocksize = cipher_blocksize(c);
	authlen = cipher_authlen(c);
	if (len < blocksize) {
		error("%s: encrypted data too small", __func__);
		goto out;
	}
	if (len % blocksize) {
		error("%s: length not multiple of blocksize", __func__);
		goto out;
	}

	/* setup key */
	keylen = cipher_keylen(c);
	ivlen = cipher_ivlen(c);
	key = xcalloc(1, keylen + ivlen);
	if (!strcmp(kdfname, "bcrypt")) {
		if ((salt = buffer_get_string_ret(&kdf, &slen)) == NULL) {
			error("%s: salt not set", __func__);
			goto out;
		}
		if (buffer_get_int_ret(&rounds, &kdf) < 0) {
			error("%s: rounds not set", __func__);
			goto out;
		}
		if (bcrypt_pbkdf(passphrase, strlen(passphrase), salt, slen,
		    key, keylen + ivlen, rounds) < 0) {
			error("%s: bcrypt_pbkdf failed", __func__);
			goto out;
		}
	}

	cp = buffer_append_space(&b, len);
	cipher_init(&ctx, c, key, keylen, key + keylen, ivlen, 0);
	ret = cipher_crypt(&ctx, 0, cp, buffer_ptr(&copy), len, 0, authlen);
	cipher_cleanup(&ctx);
	buffer_consume(&copy, len);

	/* fail silently on decryption errors */
	if (ret != 0) {
		debug("%s: decrypt failed", __func__);
		goto out;
	}

	if (buffer_len(&copy) != 0) {
		error("%s: key blob has trailing data (len = %u)", __func__,
		    buffer_len(&copy));
		goto out;
	}

	/* check bytes */
	if (buffer_get_int_ret(&check1, &b) < 0 ||
	    buffer_get_int_ret(&check2, &b) < 0) {
		error("check bytes missing");
		goto out;
	}
	if (check1 != check2) {
		debug("%s: decrypt failed: 0x%08x != 0x%08x", __func__,
		    check1, check2);
		goto out;
	}

	k = key_private_deserialize(&b);

	/* comment */
	comment = buffer_get_cstring_ret(&b, NULL);

	i = 0;
	while (buffer_len(&b)) {
		if (buffer_get_char_ret(&pad, &b) == -1 ||
		    pad != (++i & 0xff)) {
			error("%s: bad padding", __func__);
			key_free(k);
			k = NULL;
			goto out;
		}
	}

	if (k && commentp) {
		*commentp = comment;
		comment = NULL;
	}

	/* XXX decode pubkey and check against private */
 out:
	free(ciphername);
	free(kdfname);
	free(salt);
	free(comment);
	if (key)
		explicit_bzero(key, keylen + ivlen);
	free(key);
	buffer_free(&encoded);
	buffer_free(&copy);
	buffer_free(&kdf);
	buffer_free(&b);
	return k;
}

#ifdef WITH_SSH1
/*
 * Serialises the authentication (private) key to a blob, encrypting it with
 * passphrase.  The identification of the blob (lowest 64 bits of n) will
 * precede the key to provide identification of the key without needing a
 * passphrase.
 */
static int
key_private_rsa1_to_blob(Key *key, Buffer *blob, const char *passphrase,
    const char *comment)
{
	Buffer buffer, encrypted;
	u_char buf[100], *cp;
	int i, cipher_num;
	CipherContext ciphercontext;
	const Cipher *cipher;
	u_int32_t rnd;

	/*
	 * If the passphrase is empty, use SSH_CIPHER_NONE to ease converting
	 * to another cipher; otherwise use SSH_AUTHFILE_CIPHER.
	 */
	cipher_num = (strcmp(passphrase, "") == 0) ?
	    SSH_CIPHER_NONE : SSH_AUTHFILE_CIPHER;
	if ((cipher = cipher_by_number(cipher_num)) == NULL)
		fatal("save_private_key_rsa: bad cipher");

	/* This buffer is used to built the secret part of the private key. */
	buffer_init(&buffer);

	/* Put checkbytes for checking passphrase validity. */
	rnd = arc4random();
	buf[0] = rnd & 0xff;
	buf[1] = (rnd >> 8) & 0xff;
	buf[2] = buf[0];
	buf[3] = buf[1];
	buffer_append(&buffer, buf, 4);

	/*
	 * Store the private key (n and e will not be stored because they
	 * will be stored in plain text, and storing them also in encrypted
	 * format would just give known plaintext).
	 */
	buffer_put_bignum(&buffer, key->rsa->d);
	buffer_put_bignum(&buffer, key->rsa->iqmp);
	buffer_put_bignum(&buffer, key->rsa->q);	/* reverse from SSL p */
	buffer_put_bignum(&buffer, key->rsa->p);	/* reverse from SSL q */

	/* Pad the part to be encrypted until its size is a multiple of 8. */
	while (buffer_len(&buffer) % 8 != 0)
		buffer_put_char(&buffer, 0);

	/* This buffer will be used to contain the data in the file. */
	buffer_init(&encrypted);

	/* First store keyfile id string. */
	for (i = 0; authfile_id_string[i]; i++)
		buffer_put_char(&encrypted, authfile_id_string[i]);
	buffer_put_char(&encrypted, 0);

	/* Store cipher type. */
	buffer_put_char(&encrypted, cipher_num);
	buffer_put_int(&encrypted, 0);	/* For future extension */

	/* Store public key.  This will be in plain text. */
	buffer_put_int(&encrypted, BN_num_bits(key->rsa->n));
	buffer_put_bignum(&encrypted, key->rsa->n);
	buffer_put_bignum(&encrypted, key->rsa->e);
	buffer_put_cstring(&encrypted, comment);

	/* Allocate space for the private part of the key in the buffer. */
	cp = buffer_append_space(&encrypted, buffer_len(&buffer));

	cipher_set_key_string(&ciphercontext, cipher, passphrase,
	    CIPHER_ENCRYPT);
	if (cipher_crypt(&ciphercontext, 0, cp,
	    buffer_ptr(&buffer), buffer_len(&buffer), 0, 0) != 0)
		fatal("%s: cipher_crypt failed", __func__);
	cipher_cleanup(&ciphercontext);
	explicit_bzero(&ciphercontext, sizeof(ciphercontext));

	/* Destroy temporary data. */
	explicit_bzero(buf, sizeof(buf));
	buffer_free(&buffer);

	buffer_append(blob, buffer_ptr(&encrypted), buffer_len(&encrypted));
	buffer_free(&encrypted);

	return 1;
}
#endif

#ifdef WITH_OPENSSL
/* convert SSH v2 key in OpenSSL PEM format */
static int
key_private_pem_to_blob(Key *key, Buffer *blob, const char *_passphrase,
    const char *comment)
{
	int success = 0;
	int blen, len = strlen(_passphrase);
	u_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;
	const EVP_CIPHER *cipher = (len > 0) ? EVP_aes_128_cbc() : NULL;
	const u_char *bptr;
	BIO *bio;

	if (len > 0 && len <= 4) {
		error("passphrase too short: have %d bytes, need > 4", len);
		return 0;
	}
	if ((bio = BIO_new(BIO_s_mem())) == NULL) {
		error("%s: BIO_new failed", __func__);
		return 0;
	}
	switch (key->type) {
	case KEY_DSA:
		success = PEM_write_bio_DSAPrivateKey(bio, key->dsa,
		    cipher, passphrase, len, NULL, NULL);
		break;
	case KEY_ECDSA:
		success = PEM_write_bio_ECPrivateKey(bio, key->ecdsa,
		    cipher, passphrase, len, NULL, NULL);
		break;
	case KEY_RSA:
		success = PEM_write_bio_RSAPrivateKey(bio, key->rsa,
		    cipher, passphrase, len, NULL, NULL);
		break;
	}
	if (success) {
		if ((blen = BIO_get_mem_data(bio, &bptr)) <= 0)
			success = 0;
		else
			buffer_append(blob, bptr, blen);
	}
	BIO_free(bio);
	return success;
}
#endif

d54 1
a54 1
key_save_private_blob(Buffer *keybuf, const char *filename)
d56 1
a56 1
	int fd;
d58 5
a62 8
	if ((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600)) < 0) {
		error("open %s failed: %s.", filename, strerror(errno));
		return 0;
	}
	if (atomicio(vwrite, fd, buffer_ptr(keybuf),
	    buffer_len(keybuf)) != buffer_len(keybuf)) {
		error("write to key file %s failed: %s", filename,
		    strerror(errno));
d65 2
a66 1
		return 0;
d69 1
a69 31
	return 1;
}

/* Serialise "key" to buffer "blob" */
static int
key_private_to_blob(Key *key, Buffer *blob, const char *passphrase,
    const char *comment, int force_new_format, const char *new_format_cipher,
    int new_format_rounds)
{
	switch (key->type) {
#ifdef WITH_SSH1
	case KEY_RSA1:
		return key_private_rsa1_to_blob(key, blob, passphrase, comment);
#endif
#ifdef WITH_OPENSSL
	case KEY_DSA:
	case KEY_ECDSA:
	case KEY_RSA:
		if (force_new_format) {
			return key_private_to_blob2(key, blob, passphrase,
			    comment, new_format_cipher, new_format_rounds);
		}
		return key_private_pem_to_blob(key, blob, passphrase, comment);
#endif
	case KEY_ED25519:
		return key_private_to_blob2(key, blob, passphrase,
		    comment, new_format_cipher, new_format_rounds);
	default:
		error("%s: cannot save key type %d", __func__, key->type);
		return 0;
	}
d73 3
a75 3
key_save_private(Key *key, const char *filename, const char *passphrase,
    const char *comment, int force_new_format, const char *new_format_cipher,
    int new_format_rounds)
d77 2
a78 2
	Buffer keyblob;
	int success = 0;
d80 4
a83 3
	buffer_init(&keyblob);
	if (!key_private_to_blob(key, &keyblob, passphrase, comment,
	    force_new_format, new_format_cipher, new_format_rounds))
d85 1
a85 1
	if (!key_save_private_blob(&keyblob, filename))
d87 1
a87 1
	success = 1;
d89 2
a90 48
	buffer_free(&keyblob);
	return success;
}

#ifdef WITH_SSH1
/*
 * Parse the public, unencrypted portion of a RSA1 key.
 */
static Key *
key_parse_public_rsa1(Buffer *blob, char **commentp)
{
	Key *pub;
	Buffer copy;

	/* Check that it is at least big enough to contain the ID string. */
	if (buffer_len(blob) < sizeof(authfile_id_string)) {
		debug3("Truncated RSA1 identifier");
		return NULL;
	}

	/*
	 * Make sure it begins with the id string.  Consume the id string
	 * from the buffer.
	 */
	if (memcmp(buffer_ptr(blob), authfile_id_string,
	    sizeof(authfile_id_string)) != 0) {
		debug3("Incorrect RSA1 identifier");
		return NULL;
	}
	buffer_init(&copy);
	buffer_append(&copy, buffer_ptr(blob), buffer_len(blob));
	buffer_consume(&copy, sizeof(authfile_id_string));

	/* Skip cipher type and reserved data. */
	(void) buffer_get_char(&copy);		/* cipher type */
	(void) buffer_get_int(&copy);		/* reserved */

	/* Read the public key from the buffer. */
	(void) buffer_get_int(&copy);
	pub = key_new(KEY_RSA1);
	buffer_get_bignum(&copy, pub->rsa->n);
	buffer_get_bignum(&copy, pub->rsa->e);
	if (commentp)
		*commentp = buffer_get_string(&copy, NULL);
	/* The encrypted private part is not parsed by this function. */
	buffer_free(&copy);

	return pub;
a91 1
#endif
d95 1
a95 1
key_load_file(int fd, const char *filename, Buffer *blob)
d100 1
d102 2
a103 7
	if (fstat(fd, &st) < 0) {
		error("%s: fstat of key file %.200s%sfailed: %.100s", __func__,
		    filename == NULL ? "" : filename,
		    filename == NULL ? "" : " ",
		    strerror(errno));
		return 0;
	}
d105 2
a106 8
	    st.st_size > MAX_KEY_FILE_SIZE) {
 toobig:
		error("%s: key file %.200s%stoo large", __func__,
		    filename == NULL ? "" : filename,
		    filename == NULL ? "" : " ");
		return 0;
	}
	buffer_clear(blob);
d111 2
a112 6
			debug("%s: read from key file %.200s%sfailed: %.100s",
			    __func__, filename == NULL ? "" : filename,
			    filename == NULL ? "" : " ", strerror(errno));
			buffer_clear(blob);
			explicit_bzero(buf, sizeof(buf));
			return 0;
d114 5
a118 5
		buffer_append(blob, buf, len);
		if (buffer_len(blob) > MAX_KEY_FILE_SIZE) {
			buffer_clear(blob);
			explicit_bzero(buf, sizeof(buf));
			goto toobig;
a120 1
	explicit_bzero(buf, sizeof(buf));
d122 3
a124 6
	    st.st_size != buffer_len(blob)) {
		debug("%s: key file %.200s%schanged size while reading",
		    __func__, filename == NULL ? "" : filename,
		    filename == NULL ? "" : " ");
		buffer_clear(blob);
		return 0;
d126 1
d128 5
a132 1
	return 1;
d141 3
a143 2
static Key *
key_load_public_rsa1(int fd, const char *filename, char **commentp)
d145 2
a146 2
	Buffer buffer;
	Key *pub;
d148 3
a150 5
	buffer_init(&buffer);
	if (!key_load_file(fd, filename, &buffer)) {
		buffer_free(&buffer);
		return NULL;
	}
d152 10
a161 5
	pub = key_parse_public_rsa1(&buffer, commentp);
	if (pub == NULL)
		debug3("Could not load \"%s\" as a RSA1 public key", filename);
	buffer_free(&buffer);
	return pub;
d163 1
d165 5
a169 20
/* load public key from private-key file, works only for SSH v1 */
Key *
key_load_public_type(int type, const char *filename, char **commentp)
{
	Key *pub;
	int fd;

	if (type == KEY_RSA1) {
		fd = open(filename, O_RDONLY);
		if (fd < 0)
			return NULL;
		pub = key_load_public_rsa1(fd, filename, commentp);
		close(fd);
		return pub;
	}
	return NULL;
}

static Key *
key_parse_private_rsa1(Buffer *blob, const char *passphrase, char **commentp)
d171 2
a172 13
	int check1, check2, cipher_type;
	Buffer decrypted;
	u_char *cp;
	CipherContext ciphercontext;
	const Cipher *cipher;
	Key *prv = NULL;
	Buffer copy;

	/* Check that it is at least big enough to contain the ID string. */
	if (buffer_len(blob) < sizeof(authfile_id_string)) {
		debug3("Truncated RSA1 identifier");
		return NULL;
	}
d174 1
a174 79
	/*
	 * Make sure it begins with the id string.  Consume the id string
	 * from the buffer.
	 */
	if (memcmp(buffer_ptr(blob), authfile_id_string,
	    sizeof(authfile_id_string)) != 0) {
		debug3("Incorrect RSA1 identifier");
		return NULL;
	}
	buffer_init(&copy);
	buffer_append(&copy, buffer_ptr(blob), buffer_len(blob));
	buffer_consume(&copy, sizeof(authfile_id_string));

	/* Read cipher type. */
	cipher_type = buffer_get_char(&copy);
	(void) buffer_get_int(&copy);	/* Reserved data. */

	/* Read the public key from the buffer. */
	(void) buffer_get_int(&copy);
	prv = key_new_private(KEY_RSA1);

	buffer_get_bignum(&copy, prv->rsa->n);
	buffer_get_bignum(&copy, prv->rsa->e);
	if (commentp)
		*commentp = buffer_get_string(&copy, NULL);
	else
		(void)buffer_get_string_ptr(&copy, NULL);

	/* Check that it is a supported cipher. */
	cipher = cipher_by_number(cipher_type);
	if (cipher == NULL) {
		debug("Unsupported RSA1 cipher %d", cipher_type);
		buffer_free(&copy);
		goto fail;
	}
	/* Initialize space for decrypted data. */
	buffer_init(&decrypted);
	cp = buffer_append_space(&decrypted, buffer_len(&copy));

	/* Rest of the buffer is encrypted.  Decrypt it using the passphrase. */
	cipher_set_key_string(&ciphercontext, cipher, passphrase,
	    CIPHER_DECRYPT);
	if (cipher_crypt(&ciphercontext, 0, cp,
	    buffer_ptr(&copy), buffer_len(&copy), 0, 0) != 0)
		fatal("%s: cipher_crypt failed", __func__);
	cipher_cleanup(&ciphercontext);
	explicit_bzero(&ciphercontext, sizeof(ciphercontext));
	buffer_free(&copy);

	check1 = buffer_get_char(&decrypted);
	check2 = buffer_get_char(&decrypted);
	if (check1 != buffer_get_char(&decrypted) ||
	    check2 != buffer_get_char(&decrypted)) {
		if (strcmp(passphrase, "") != 0)
			debug("Bad passphrase supplied for RSA1 key");
		/* Bad passphrase. */
		buffer_free(&decrypted);
		goto fail;
	}
	/* Read the rest of the private key. */
	buffer_get_bignum(&decrypted, prv->rsa->d);
	buffer_get_bignum(&decrypted, prv->rsa->iqmp);		/* u */
	/* in SSL and SSH v1 p and q are exchanged */
	buffer_get_bignum(&decrypted, prv->rsa->q);		/* p */
	buffer_get_bignum(&decrypted, prv->rsa->p);		/* q */

	/* calculate p-1 and q-1 */
	rsa_generate_additional_parameters(prv->rsa);

	buffer_free(&decrypted);

	/* enable blinding */
	if (RSA_blinding_on(prv->rsa, NULL) != 1) {
		error("%s: RSA_blinding_on failed", __func__);
		goto fail;
	}
	return prv;

fail:
d176 1
a176 5
		free(*commentp);
	key_free(prv);
	return NULL;
}
#endif
d178 11
a188 91
#ifdef WITH_OPENSSL
static Key *
key_parse_private_pem(Buffer *blob, int type, const char *passphrase,
    char **commentp)
{
	EVP_PKEY *pk = NULL;
	Key *prv = NULL;
	char *name = "<no key>";
	BIO *bio;

	if ((bio = BIO_new_mem_buf(buffer_ptr(blob),
	    buffer_len(blob))) == NULL) {
		error("%s: BIO_new_mem_buf failed", __func__);
		return NULL;
	}
	
	pk = PEM_read_bio_PrivateKey(bio, NULL, NULL, (char *)passphrase);
	BIO_free(bio);
	if (pk == NULL) {
		debug("%s: PEM_read_PrivateKey failed", __func__);
		(void)ERR_get_error();
	} else if (pk->type == EVP_PKEY_RSA &&
	    (type == KEY_UNSPEC||type==KEY_RSA)) {
		prv = key_new(KEY_UNSPEC);
		prv->rsa = EVP_PKEY_get1_RSA(pk);
		prv->type = KEY_RSA;
		name = "rsa w/o comment";
#ifdef DEBUG_PK
		RSA_print_fp(stderr, prv->rsa, 8);
#endif
		if (RSA_blinding_on(prv->rsa, NULL) != 1) {
			error("%s: RSA_blinding_on failed", __func__);
			key_free(prv);
			prv = NULL;
		}
	} else if (pk->type == EVP_PKEY_DSA &&
	    (type == KEY_UNSPEC||type==KEY_DSA)) {
		prv = key_new(KEY_UNSPEC);
		prv->dsa = EVP_PKEY_get1_DSA(pk);
		prv->type = KEY_DSA;
		name = "dsa w/o comment";
#ifdef DEBUG_PK
		DSA_print_fp(stderr, prv->dsa, 8);
#endif
	} else if (pk->type == EVP_PKEY_EC &&
	    (type == KEY_UNSPEC||type==KEY_ECDSA)) {
		prv = key_new(KEY_UNSPEC);
		prv->ecdsa = EVP_PKEY_get1_EC_KEY(pk);
		prv->type = KEY_ECDSA;
		if ((prv->ecdsa_nid = key_ecdsa_key_to_nid(prv->ecdsa)) == -1 ||
		    key_curve_nid_to_name(prv->ecdsa_nid) == NULL ||
		    key_ec_validate_public(EC_KEY_get0_group(prv->ecdsa),
		    EC_KEY_get0_public_key(prv->ecdsa)) != 0 ||
		    key_ec_validate_private(prv->ecdsa) != 0) {
			error("%s: bad ECDSA key", __func__);
			key_free(prv);
			prv = NULL;
		}
		name = "ecdsa w/o comment";
#ifdef DEBUG_PK
		if (prv != NULL && prv->ecdsa != NULL)
			key_dump_ec_key(prv->ecdsa);
#endif
	} else {
		error("%s: PEM_read_PrivateKey: mismatch or "
		    "unknown EVP_PKEY save_type %d", __func__, pk->save_type);
	}
	if (pk != NULL)
		EVP_PKEY_free(pk);
	if (prv != NULL && commentp)
		*commentp = xstrdup(name);
	debug("read PEM private key done: type %s",
	    prv ? key_type(prv) : "<unknown>");
	return prv;
}

Key *
key_load_private_pem(int fd, int type, const char *passphrase,
    char **commentp)
{
	Buffer buffer;
	Key *prv;

	buffer_init(&buffer);
	if (!key_load_file(fd, NULL, &buffer)) {
		buffer_free(&buffer);
		return NULL;
	}
	prv = key_parse_private_pem(&buffer, type, passphrase, commentp);
	buffer_free(&buffer);
	return prv;
d190 1
a190 1
#endif
d192 1
d194 1
a194 1
key_perm_ok(int fd, const char *filename)
d199 1
a199 1
		return 0;
d213 1
a213 1
		return 0;
d215 1
a215 1
	return 1;
d218 4
a221 3
static Key *
key_parse_private_type(Buffer *blob, int type, const char *passphrase,
    char **commentp)
d223 2
a224 1
	Key *k;
d226 3
a228 25
	switch (type) {
#ifdef WITH_SSH1
	case KEY_RSA1:
		return key_parse_private_rsa1(blob, passphrase, commentp);
#endif
#ifdef WITH_OPENSSL
	case KEY_DSA:
	case KEY_ECDSA:
	case KEY_RSA:
		return key_parse_private_pem(blob, type, passphrase, commentp);
#endif
	case KEY_ED25519:
		return key_parse_private2(blob, type, passphrase, commentp);
	case KEY_UNSPEC:
		if ((k = key_parse_private2(blob, type, passphrase, commentp)))
			return k;
#ifdef WITH_OPENSSL
		return key_parse_private_pem(blob, type, passphrase, commentp);
#endif
	default:
		error("%s: cannot parse key type %d", __func__, type);
		break;
	}
	return NULL;
}
d230 1
a230 12
Key *
key_load_private_type(int type, const char *filename, const char *passphrase,
    char **commentp, int *perm_ok)
{
	int fd;
	Key *ret;
	Buffer buffer;

	fd = open(filename, O_RDONLY);
	if (fd < 0) {
		debug("could not open key file '%s': %s", filename,
		    strerror(errno));
d233 1
a233 1
		return NULL;
d235 1
a235 1
	if (!key_perm_ok(fd, filename)) {
d238 2
a239 3
		error("bad permissions: ignore key: %s", filename);
		close(fd);
		return NULL;
d244 3
a246 5
	buffer_init(&buffer);
	if (!key_load_file(fd, filename, &buffer)) {
		buffer_free(&buffer);
		close(fd);
		return NULL;
d248 7
d256 3
a258 3
	ret = key_parse_private_type(&buffer, type, passphrase, commentp);
	buffer_free(&buffer);
	return ret;
d261 4
a264 3
Key *
key_parse_private(Buffer *buffer, const char *filename,
    const char *passphrase, char **commentp)
d266 2
a267 2
#ifdef WITH_SSH1
	Key *pub, *prv;
d269 3
a271 20
	/* it's a SSH v1 key if the public key part is readable */
	pub = key_parse_public_rsa1(buffer, commentp);
	if (pub == NULL) {
		prv = key_parse_private_type(buffer, KEY_UNSPEC,
		    passphrase, NULL);
		/* use the filename as a comment for PEM */
		if (commentp && prv)
			*commentp = xstrdup(filename);
	} else {
		key_free(pub);
		/* key_parse_public_rsa1() has already loaded the comment */
		prv = key_parse_private_type(buffer, KEY_RSA1, passphrase,
		    NULL);
	}
	return prv;
#else
	return key_parse_private_type(buffer, KEY_UNSPEC,
	    passphrase, commentp);
#endif
}
d273 5
a277 18
Key *
key_load_private(const char *filename, const char *passphrase,
    char **commentp)
{
	Key *prv;
	Buffer buffer;
	int fd;

	fd = open(filename, O_RDONLY);
	if (fd < 0) {
		debug("could not open key file '%s': %s", filename,
		    strerror(errno));
		return NULL;
	}
	if (!key_perm_ok(fd, filename)) {
		error("bad permissions: ignore key: %s", filename);
		close(fd);
		return NULL;
d280 3
a282 5
	buffer_init(&buffer);
	if (!key_load_file(fd, filename, &buffer)) {
		buffer_free(&buffer);
		close(fd);
		return NULL;
d284 6
d291 3
a293 4

	prv = key_parse_private(&buffer, filename, passphrase, commentp);
	buffer_free(&buffer);
	return prv;
d297 1
a297 1
key_try_load_public(Key *k, const char *filename, char **commentp)
d303 1
d305 28
a332 26
	f = fopen(filename, "r");
	if (f != NULL) {
		while (read_keyfile_line(f, filename, line, sizeof(line),
			    &linenum) != -1) {
			cp = line;
			switch (*cp) {
			case '#':
			case '\n':
			case '\0':
				continue;
			}
			/* Abort loading if this looks like a private key */
			if (strncmp(cp, "-----BEGIN", 10) == 0)
				break;
			/* Skip leading whitespace. */
			for (; *cp && (*cp == ' ' || *cp == '\t'); cp++)
				;
			if (*cp) {
				if (key_read(k, &cp) == 1) {
					cp[strcspn(cp, "\r\n")] = '\0';
					if (commentp) {
						*commentp = xstrdup(*cp ?
						    cp : filename);
					}
					fclose(f);
					return 1;
d334 2
a337 1
		fclose(f);
d339 2
a340 1
	return 0;
d344 2
a345 2
Key *
key_load_public(const char *filename, char **commentp)
d347 1
a347 1
	Key *pub;
d349 1
d351 7
d360 21
a380 3
	pub = key_load_public_type(KEY_RSA1, filename, commentp);
	if (pub != NULL)
		return pub;
d382 1
d384 9
a392 5
	pub = key_new(KEY_RSA1);
	if (key_try_load_public(pub, filename, commentp) == 1)
		return pub;
	key_free(pub);
#endif
d394 5
a398 4
	/* try ssh2 public key */
	pub = key_new(KEY_UNSPEC);
	if (key_try_load_public(pub, filename, commentp) == 1)
		return pub;
d401 7
a407 4
	    (key_try_load_public(pub, file, commentp) == 1))
		return pub;
	key_free(pub);
	return NULL;
d411 2
a412 2
Key *
key_load_cert(const char *filename)
d414 5
a418 2
	Key *pub;
	char *file;
d420 15
a434 3
	pub = key_new(KEY_UNSPEC);
	xasprintf(&file, "%s-cert.pub", filename);
	if (key_try_load_public(pub, file, NULL) == 1) {
d436 3
a438 5
		return pub;
	}
	free(file);
	key_free(pub);
	return NULL;
d442 3
a444 3
Key *
key_load_private_cert(int type, const char *filename, const char *passphrase,
    int *perm_ok)
d446 4
a449 1
	Key *key, *pub;
a455 1
#endif
d457 2
d461 1
a461 2
		error("%s: unsupported key type", __func__);
		return NULL;
d464 4
a467 8
	if ((key = key_load_private_type(type, filename, 
	    passphrase, NULL, perm_ok)) == NULL)
		return NULL;

	if ((pub = key_load_cert(filename)) == NULL) {
		key_free(key);
		return NULL;
	}
d470 3
a472 9
	if (key_equal_public(key, pub) == 0) {
		error("%s: certificate does not match private key %s",
		    __func__, filename);
	} else if (key_to_certified(key, key_cert_is_legacy(pub)) != 0) {
		error("%s: key_to_certified failed", __func__);
	} else {
		key_cert_copy(pub, key);
		key_free(pub);
		return key;
d475 12
a486 3
	key_free(key);
	key_free(pub);
	return NULL;
d490 2
a491 2
 * Returns 1 if the specified "key" is listed in the file "filename",
 * 0 if the key is not listed or -1 on error.
d496 1
a496 1
key_in_file(Key *key, const char *filename, int strict_type)
d502 4
a505 4
	int ret = 0;
	Key *pub;
	int (*key_compare)(const Key *, const Key *) = strict_type ?
	    key_equal : key_equal_public;
d508 4
a511 8
		if (errno == ENOENT) {
			debug("%s: keyfile \"%s\" missing", __func__, filename);
			return 0;
		} else {
			error("%s: could not open keyfile \"%s\": %s", __func__,
			    filename, strerror(errno));
			return -1;
		}
d515 1
a515 1
		    &linenum) != -1) {
d530 3
a532 4
		pub = key_new(KEY_UNSPEC);
		if (key_read(pub, &cp) != 1) {
			key_free(pub);
			continue;
d534 5
a538 4
		if (key_compare(key, pub)) {
			ret = 1;
			key_free(pub);
			break;
d540 2
a541 1
		key_free(pub);
d543 4
d548 1
a548 1
	return ret;
d550 1
@


1.105
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.104 2014/03/12 04:51:12 djm Exp $ */
d45 1
d49 1
d417 1
d507 1
d509 1
d553 1
d584 1
d587 2
d597 1
d627 1
d672 1
d729 1
d873 1
d875 1
d967 1
d1001 1
d1004 2
d1010 1
d1016 1
d1018 1
d1068 1
d1086 4
d1174 1
d1185 1
d1225 1
d1229 1
@


1.104
log
@correct test that kdf name is not "none" or "bcrypt"
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.103 2014/02/02 03:44:31 djm Exp $ */
d200 2
a201 1
	char *comment = NULL, *ciphername = NULL, *kdfname = NULL, *kdfp;
@


1.103
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.102 2014/01/31 16:39:19 tedu Exp $ */
d277 1
a277 1
	    (!strcmp(kdfname, "none") && !strcmp(kdfname, "bcrypt"))) {
@


1.102
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.101 2013/12/29 04:35:50 djm Exp $ */
d127 1
a127 1
	memset(key, 0, keylen + ivlen);
d139 1
a139 1
	memset(cp, 0, len);
d405 1
a405 1
		memset(key, 0, keylen + ivlen);
d492 1
a492 1
	memset(&ciphercontext, 0, sizeof(ciphercontext));
d495 1
a495 1
	memset(buf, 0, sizeof(buf));
d821 1
a821 1
	memset(&ciphercontext, 0, sizeof(ciphercontext));
@


1.101
log
@don't refuse to load Ed25519 certificates
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.100 2013/12/06 13:39:49 markus Exp $ */
d693 1
a693 1
			bzero(buf, sizeof(buf));
d699 1
a699 1
			bzero(buf, sizeof(buf));
d703 1
a703 1
	bzero(buf, sizeof(buf));
@


1.100
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.99 2013/12/06 13:34:54 markus Exp $ */
d1198 1
@


1.99
log
@new private key format, bcrypt as KDF by default; details in PROTOCOL.key;
feedback and lots help from djm; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.98 2013/11/21 00:45:43 djm Exp $ */
d49 2
d587 3
d989 3
@


1.98
log
@Add a new protocol 2 transport cipher "chacha20-poly1305@@openssh.com"
that combines Daniel Bernstein's ChaCha20 stream cipher and Poly1305 MAC
to build an authenticated encryption mode.

Inspired by and similar to Adam Langley's proposal for TLS:
http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03
but differs in layout used for the MAC calculation and the use of a
second ChaCha20 instance to separately encrypt packet lengths.
Details are in the PROTOCOL.chacha20poly1305 file.

Feedback markus@@, naddy@@; manpage bits Loganden Velvindron @@ AfriNIC
ok markus@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.97 2013/05/17 00:13:13 djm Exp $ */
d16 1
a16 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d56 2
d68 10
d85 327
d486 3
a488 2
	cipher_crypt(&ciphercontext, 0, cp,
	    buffer_ptr(&buffer), buffer_len(&buffer), 0, 0);
d571 2
a572 1
    const char *comment)
d580 4
d593 2
a594 1
    const char *comment)
d600 2
a601 1
	if (!key_private_to_blob(key, &keyblob, passphrase, comment))
d812 3
a814 2
	cipher_crypt(&ciphercontext, 0, cp,
	    buffer_ptr(&copy), buffer_len(&copy), 0, 0);
d976 2
d985 2
a1281 1

@


1.97
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.96 2013/04/19 01:06:50 djm Exp $ */
d147 1
a147 1
	cipher_crypt(&ciphercontext, cp,
d465 1
a465 1
	cipher_crypt(&ciphercontext, cp,
@


1.96
log
@add the ability to query supported ciphers, MACs, key type and KEX
algorithms to ssh. Includes some refactoring of KEX and key type handling
to be table-driven; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.95 2013/01/08 18:49:04 markus Exp $ */
d501 2
a502 2
	if (commentp)
		xfree(*commentp);
d819 1
a819 1
		xfree(file);
d822 1
a822 1
	xfree(file);
@


1.95
log
@support AES-GCM as defined in RFC 5647 (but with simpler KEX handling)
ok and feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.94 2012/12/11 22:31:18 markus Exp $ */
d87 1
a87 1
	Cipher *cipher;
d413 1
a413 1
	Cipher *cipher;
@


1.94
log
@add encrypt-then-mac (EtM) modes to openssh by defining new mac algorithms
that change the packet format and compute the MAC over the encrypted
message (including the packet size) instead of the plaintext data;
these EtM modes are considered more secure and used by default.
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.93 2012/01/25 19:36:31 markus Exp $ */
d148 1
a148 1
	    buffer_ptr(&buffer), buffer_len(&buffer), 0);
d466 1
a466 1
	    buffer_ptr(&copy), buffer_len(&copy), 0);
@


1.93
log
@memleak in key_load_file(); from Jan Klemkow
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.92 2011/06/14 22:49:18 markus Exp $ */
d148 1
a148 1
	    buffer_ptr(&buffer), buffer_len(&buffer));
d466 1
a466 1
	    buffer_ptr(&copy), buffer_len(&copy));
@


1.92
log
@make sure key_parse_public/private_rsa1() no longer consumes its input buffer.
fixes ssh-add for passphrase-protected ssh1-keys; noted by naddy@@; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.91 2011/05/23 07:24:57 djm Exp $ */
d332 1
a332 1
	buffer_init(blob);
@


1.91
log
@read in key comments for v.2 keys (though note that these are not
passed over the agent protocol); bz#439, based on patch from binder
AT arago.de; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.90 2011/05/13 00:05:36 djm Exp $ */
d271 1
d288 3
a290 1
	buffer_consume(blob, sizeof(authfile_id_string));
d293 2
a294 2
	(void) buffer_get_char(blob);	/* cipher type */
	(void) buffer_get_int(blob);		/* reserved */
d297 1
a297 1
	(void) buffer_get_int(blob);
d299 2
a300 2
	buffer_get_bignum(blob, pub->rsa->n);
	buffer_get_bignum(blob, pub->rsa->e);
d302 1
a302 1
		*commentp = buffer_get_string(blob, NULL);
d304 1
a304 1
	buffer_clear(blob);
d415 1
d432 3
a434 1
	buffer_consume(blob, sizeof(authfile_id_string));
d437 2
a438 2
	cipher_type = buffer_get_char(blob);
	(void) buffer_get_int(blob);	/* Reserved data. */
d441 1
a441 1
	(void) buffer_get_int(blob);
d444 2
a445 2
	buffer_get_bignum(blob, prv->rsa->n);
	buffer_get_bignum(blob, prv->rsa->e);
d447 1
a447 1
		*commentp = buffer_get_string(blob, NULL);
d449 1
a449 1
		(void)buffer_get_string_ptr(blob, NULL);
d455 1
d460 1
a460 1
	cp = buffer_append_space(&decrypted, buffer_len(blob));
d466 1
a466 1
	    buffer_ptr(blob), buffer_len(blob));
d469 1
a469 1
	buffer_clear(blob);
a685 1
	Buffer pubcopy;
a686 2
	buffer_init(&pubcopy);
	buffer_append(&pubcopy, buffer_ptr(buffer), buffer_len(buffer));
d688 1
a688 2
	pub = key_parse_public_rsa1(&pubcopy, commentp);
	buffer_free(&pubcopy);
@


1.90
log
@warn on unexpected key type in key_parse_private_type()
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.89 2011/05/10 05:46:46 djm Exp $ */
d761 5
a765 2
					if (commentp)
						*commentp=xstrdup(filename);
@


1.89
log
@despam debug() logs by detecting that we are trying to load a private key
in key_try_load_public() and returning early; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.88 2011/05/04 21:15:29 djm Exp $ */
d630 1
@


1.88
log
@allow "ssh-add - < key"; feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.87 2010/11/29 18:57:04 markus Exp $ */
d752 3
@


1.87
log
@correctly load comment for encrypted rsa1 keys;
report/fix Joachim Schipper; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.86 2010/11/21 10:57:07 djm Exp $ */
d67 2
d306 2
a307 2
/* Load the contents of a key file into a buffer */
static int
d310 1
a311 1
	u_char *cp;
a318 1
		close(fd);
d321 3
a323 1
	if (st.st_size > 1*1024*1024) {
a326 1
		close(fd);
a328 2
	len = (size_t)st.st_size;		/* truncated */

d330 24
a353 7
	cp = buffer_append_space(blob, len);

	if (atomicio(read, fd, cp, len) != len) {
		debug("%s: read from key file %.200s%sfailed: %.100s", __func__,
		    filename == NULL ? "" : filename,
		    filename == NULL ? "" : " ",
		    strerror(errno));
a354 1
		close(fd);
d357 1
d674 27
d704 2
a705 2
	Key *pub, *prv;
	Buffer buffer, pubcopy;
d728 1
a728 17
	buffer_init(&pubcopy);
	buffer_append(&pubcopy, buffer_ptr(&buffer), buffer_len(&buffer));
	/* it's a SSH v1 key if the public key part is readable */
	pub = key_parse_public_rsa1(&pubcopy, commentp);
	buffer_free(&pubcopy);
	if (pub == NULL) {
		prv = key_parse_private_type(&buffer, KEY_UNSPEC,
		    passphrase, NULL);
		/* use the filename as a comment for PEM */
		if (commentp && prv)
			*commentp = xstrdup(filename);
	} else {
		key_free(pub);
		/* key_parse_public_rsa1() has already loaded the comment */
		prv = key_parse_private_type(&buffer, KEY_RSA1, passphrase,
		    NULL);
	}
@


1.86
log
@Refactor internals of private key loading and saving to work on memory
buffers rather than directly on files. This will make a few things
easier to do in the future; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.85 2010/10/28 11:22:09 djm Exp $ */
d697 1
d699 1
a699 1
		    commentp);
@


1.85
log
@fix a possible NULL deref on loading a corrupt ECDH key

store ECDH group information in private keys files as "named groups"
rather than as a set of explicit group parameters (by setting
the OPENSSL_EC_NAMED_CURVE flag). This makes for shorter key files and
retrieves the group's OpenSSL NID that we need for various things.
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.84 2010/09/08 03:54:36 djm Exp $ */
d72 2
a73 2
 * Saves the authentication (private) key in a file, encrypting it with
 * passphrase.  The identification of the file (lowest 64 bits of n) will
a76 1

d78 1
a78 1
key_save_private_rsa1(Key *key, const char *filename, const char *passphrase,
d83 1
a83 1
	int fd, i, cipher_num;
d154 1
a154 16
	fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (fd < 0) {
		error("open %s failed: %s.", filename, strerror(errno));
		buffer_free(&encrypted);
		return 0;
	}
	if (atomicio(vwrite, fd, buffer_ptr(&encrypted),
	    buffer_len(&encrypted)) != buffer_len(&encrypted)) {
		error("write to key file %s failed: %s", filename,
		    strerror(errno));
		buffer_free(&encrypted);
		close(fd);
		unlink(filename);
		return 0;
	}
	close(fd);
d156 1
d160 1
a160 1
/* save SSH v2 key in OpenSSL PEM format */
d162 1
a162 1
key_save_private_pem(Key *key, const char *filename, const char *_passphrase,
a164 2
	FILE *fp;
	int fd;
d166 1
a166 1
	int len = strlen(_passphrase);
d169 2
d176 2
a177 9
	fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (fd < 0) {
		error("open %s failed: %s.", filename, strerror(errno));
		return 0;
	}
	fp = fdopen(fd, "w");
	if (fp == NULL) {
		error("fdopen %s failed: %s.", filename, strerror(errno));
		close(fd);
d182 1
a182 1
		success = PEM_write_DSAPrivateKey(fp, key->dsa,
d186 1
a186 1
		success = PEM_write_ECPrivateKey(fp, key->ecdsa,
d190 1
a190 1
		success = PEM_write_RSAPrivateKey(fp, key->rsa,
d194 7
a200 1
	fclose(fp);
d204 25
a228 2
int
key_save_private(Key *key, const char *filename, const char *passphrase,
d233 1
a233 2
		return key_save_private_rsa1(key, filename, passphrase,
		    comment);
d237 1
a237 2
		return key_save_private_pem(key, filename, passphrase,
		    comment);
d239 2
a240 1
		break;
d242 18
a259 2
	error("key_save_private: cannot save key type %d", key->type);
	return 0;
d263 1
a263 3
 * Loads the public part of the ssh v1 key file.  Returns NULL if an error was
 * encountered (the file does not exist or is not readable), and the key
 * otherwise.
a264 1

d266 1
a266 1
key_load_public_rsa1(int fd, const char *filename, char **commentp)
a267 1
	Buffer buffer;
d269 41
a310 3
	char *cp;
	u_int i;
	size_t len;
d313 6
a318 3
		error("fstat for key file %.200s failed: %.100s",
		    filename, strerror(errno));
		return NULL;
d321 5
a325 2
		error("key file %.200s too large", filename);
		return NULL;
d329 2
a330 2
	buffer_init(&buffer);
	cp = buffer_append_space(&buffer, len);
d333 3
a335 1
		debug("Read from key file %.200s failed: %.100s", filename,
d337 3
a339 2
		buffer_free(&buffer);
		return NULL;
d341 2
d344 13
a356 3
	/* Check that it is at least big enough to contain the ID string. */
	if (len < sizeof(authfile_id_string)) {
		debug3("Not a RSA1 key file %.200s.", filename);
a359 22
	/*
	 * Make sure it begins with the id string.  Consume the id string
	 * from the buffer.
	 */
	for (i = 0; i < sizeof(authfile_id_string); i++)
		if (buffer_get_char(&buffer) != authfile_id_string[i]) {
			debug3("Not a RSA1 key file %.200s.", filename);
			buffer_free(&buffer);
			return NULL;
		}
	/* Skip cipher type and reserved data. */
	(void) buffer_get_char(&buffer);	/* cipher type */
	(void) buffer_get_int(&buffer);		/* reserved */

	/* Read the public key from the buffer. */
	(void) buffer_get_int(&buffer);
	pub = key_new(KEY_RSA1);
	buffer_get_bignum(&buffer, pub->rsa->n);
	buffer_get_bignum(&buffer, pub->rsa->e);
	if (commentp)
		*commentp = buffer_get_string(&buffer, NULL);
	/* The encrypted private part is not parsed by this function. */
d361 3
a385 7
/*
 * Loads the private key from the file.  Returns 0 if an error is encountered
 * (file does not exist or is not readable, or passphrase is bad). This
 * initializes the private key.
 * Assumes we are called under uid of the owner of the file.
 */

d387 1
a387 2
key_load_private_rsa1(int fd, const char *filename, const char *passphrase,
    char **commentp)
a388 1
	u_int i;
d390 1
a390 2
	size_t len;
	Buffer buffer, decrypted;
a394 1
	struct stat st;
d396 3
a398 4
	if (fstat(fd, &st) < 0) {
		error("fstat for key file %.200s failed: %.100s",
		    filename, strerror(errno));
		close(fd);
a400 9
	if (st.st_size > 1*1024*1024) {
		error("key file %.200s too large", filename);
		close(fd);
		return (NULL);
	}
	len = (size_t)st.st_size;		/* truncated */

	buffer_init(&buffer);
	cp = buffer_append_space(&buffer, len);
a401 15
	if (atomicio(read, fd, cp, len) != len) {
		debug("Read from key file %.200s failed: %.100s", filename,
		    strerror(errno));
		buffer_free(&buffer);
		close(fd);
		return NULL;
	}

	/* Check that it is at least big enough to contain the ID string. */
	if (len < sizeof(authfile_id_string)) {
		debug3("Not a RSA1 key file %.200s.", filename);
		buffer_free(&buffer);
		close(fd);
		return NULL;
	}
d406 6
a411 7
	for (i = 0; i < sizeof(authfile_id_string); i++)
		if (buffer_get_char(&buffer) != authfile_id_string[i]) {
			debug3("Not a RSA1 key file %.200s.", filename);
			buffer_free(&buffer);
			close(fd);
			return NULL;
		}
d414 2
a415 2
	cipher_type = buffer_get_char(&buffer);
	(void) buffer_get_int(&buffer);	/* Reserved data. */
d418 1
a418 1
	(void) buffer_get_int(&buffer);
d421 2
a422 2
	buffer_get_bignum(&buffer, prv->rsa->n);
	buffer_get_bignum(&buffer, prv->rsa->e);
d424 1
a424 1
		*commentp = buffer_get_string(&buffer, NULL);
d426 1
a426 1
		xfree(buffer_get_string(&buffer, NULL));
d431 1
a431 3
		debug("Unsupported cipher %d used in key file %.200s.",
		    cipher_type, filename);
		buffer_free(&buffer);
d436 1
a436 1
	cp = buffer_append_space(&decrypted, buffer_len(&buffer));
d442 1
a442 1
	    buffer_ptr(&buffer), buffer_len(&buffer));
d445 1
a445 1
	buffer_free(&buffer);
d452 1
a452 2
			debug("Bad passphrase supplied for key file %.200s.",
			    filename);
d471 1
a471 1
		error("key_load_private_rsa1: RSA_blinding_on failed");
a473 1
	close(fd);
a478 1
	close(fd);
d483 2
a484 2
Key *
key_load_private_pem(int fd, int type, const char *passphrase,
a486 1
	FILE *fp;
d490 1
d492 3
a494 4
	fp = fdopen(fd, "r");
	if (fp == NULL) {
		error("fdopen failed: %s", strerror(errno));
		close(fd);
d497 3
a499 1
	pk = PEM_read_PrivateKey(fp, NULL, NULL, (char *)passphrase);
d501 1
a501 1
		debug("PEM_read_PrivateKey failed");
d513 1
a513 1
			error("key_load_private_pem: RSA_blinding_on failed");
d546 2
a547 2
		error("PEM_read_PrivateKey: mismatch or "
		    "unknown EVP_PKEY save_type %d", pk->save_type);
a548 1
	fclose(fp);
d558 17
d600 18
d623 2
d643 4
a646 12
	switch (type) {
	case KEY_RSA1:
		return key_load_private_rsa1(fd, filename, passphrase,
		    commentp);
		/* closes fd */
	case KEY_DSA:
	case KEY_ECDSA:
	case KEY_RSA:
	case KEY_UNSPEC:
		return key_load_private_pem(fd, type, passphrase, commentp);
		/* closes fd */
	default:
d648 1
a648 1
		break;
d650 4
a653 1
	return NULL;
d661 1
d675 14
a688 2
	pub = key_load_public_rsa1(fd, filename, commentp);
	lseek(fd, (off_t) 0, SEEK_SET);		/* rewind */
d690 2
a691 2
		/* closes fd */
		prv = key_load_private_pem(fd, KEY_UNSPEC, passphrase, NULL);
a695 1
		/* it's a SSH v1 key if the public key part is readable */
d697 2
a698 2
		/* closes fd */
		prv = key_load_private_rsa1(fd, filename, passphrase, NULL);
d700 1
@


1.84
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.83 2010/08/31 11:54:45 djm Exp $ */
d514 3
a516 7
		prv->ecdsa_nid = key_ecdsa_group_to_nid(
		    EC_KEY_get0_group(prv->ecdsa));
		if (key_curve_nid_to_name(prv->ecdsa_nid) == NULL) {
			key_free(prv);
			prv = NULL;
		}
		if (key_ec_validate_public(EC_KEY_get0_group(prv->ecdsa),
d525 1
a525 1
		if (prv->ecdsa != NULL)
@


1.83
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.82 2010/08/04 05:49:22 djm Exp $ */
d527 1
a527 1
		name = "dsa w/o comment";
@


1.82
log
@commited the wrong version of the hostbased certificate diff; this
version replaces some strlc{py,at} verbosity with xasprintf() at
the request of markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.81 2010/08/04 05:42:47 djm Exp $ */
d207 4
d229 1
d509 23
d600 1
d741 1
@


1.81
log
@enable certificates for hostbased authentication, from Iain Morgan;
"looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.80 2010/03/04 10:36:03 djm Exp $ */
d689 1
a689 1
	char file[MAXPATHLEN];
d692 3
a694 3
	if ((strlcpy(file, filename, sizeof file) < sizeof(file)) &&
	    (strlcat(file, "-cert.pub", sizeof file) < sizeof(file)) &&
	    (key_try_load_public(pub, file, NULL) == 1))
d696 2
@


1.80
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.79 2010/01/12 00:16:47 dtucker Exp $ */
d680 58
@


1.79
log
@Fix bug introduced in r1.78 (incorrect brace location) that broke key auth.
Patch from joachim joachimschipper nl.
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.78 2010/01/11 04:46:45 dtucker Exp $ */
d683 62
@


1.78
log
@Do not prompt for a passphrase if we fail to open a keyfile, and log the
reason the open failed to debug.
bz #1693, found by tj AT castaglia org, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.77 2009/10/22 22:26:13 djm Exp $ */
d555 1
a556 1
		return NULL;
@


1.77
log
@switch from 3DES to AES-128 for encryption of passphrase-protected
SSH protocol 2 private keys; ok several
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.76 2006/08/03 03:34:41 deraadt Exp $ */
d550 6
a555 1
	if (fd < 0)
d591 3
a593 1
	if (fd < 0)
d595 1
@


1.76
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.75 2006/08/01 23:36:11 stevesk Exp $ */
d185 1
a185 1
	const EVP_CIPHER *cipher = (len > 0) ? EVP_des_ede3_cbc() : NULL;
@


1.75
log
@clean extra spaces
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.74 2006/08/01 23:22:47 stevesk Exp $ */
a38 1
#include "includes.h"
d43 1
d56 1
a57 1
#include "xmalloc.h"
a58 1
#include "bufaux.h"
@


1.74
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.73 2006/07/26 13:57:17 stevesk Exp $ */
d198 1
a198 1
	if (fp == NULL ) {
@


1.73
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.72 2006/07/26 02:35:17 stevesk Exp $ */
d51 1
@


1.72
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.71 2006/07/22 20:48:22 stevesk Exp $ */
d51 1
@


1.71
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.70 2006/07/17 01:31:09 stevesk Exp $ */
d43 1
@


1.70
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.69 2006/07/11 20:27:56 stevesk Exp $ */
d50 1
@


1.69
log
@need <errno.h> here also (it's also included in <openssl/err.h>)
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.68 2006/07/09 15:15:10 stevesk Exp $ */
d50 1
@


1.68
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.67 2006/04/25 08:02:27 dtucker Exp $ */
d48 1
@


1.67
log
@Prevent ssh from trying to open private keys with bad permissions more than
once or prompting for their passphrases (which it subsequently ignores
anyway), similar to a previous change in ssh-add.  bz #1186, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: authfile.c,v 1.66 2006/03/25 13:17:01 djm Exp $ */
d47 2
@


1.66
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d538 1
a538 1
    char **commentp)
d546 2
d552 2
@


1.65
log
@whoever thought that break after return was a good idea needs to get their head examimed
@
text
@d1 1
@


1.64
log
@RCSID() can die
@
text
@a215 1
		break;
a219 1
		break;
a553 1
		break;
a558 1
		break;
@


1.63
log
@Make ssh-add check file permissions before attempting to load private
key files multiple times; it will fail anyway and this prevents confusing
multiple prompts and warnings.  mindrot #1138, ok djm@@
@
text
@a38 1
RCSID("$OpenBSD: authfile.c,v 1.62 2006/02/20 17:19:54 stevesk Exp $");
@


1.62
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.61 2005/06/17 02:44:32 djm Exp $");
d513 1
a513 1
static int
@


1.62.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: authfile.c,v 1.76 2006/08/03 03:34:41 deraadt Exp $ */
d38 2
a42 2
#include <sys/param.h>
#include <sys/uio.h>
d48 1
a48 7
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

a49 1
#include "cipher.h"
d51 1
d190 1
a190 1
	if (fp == NULL) {
d217 1
d222 1
d513 1
a513 1
int
d540 1
a540 1
    char **commentp, int *perm_ok)
a547 2
		if (perm_ok != NULL)
			*perm_ok = 0;
a551 2
	if (perm_ok != NULL)
		*perm_ok = 1;
d557 1
d563 1
@


1.61
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d39 4
a42 1
RCSID("$OpenBSD: authfile.c,v 1.60 2004/12/11 01:48:56 dtucker Exp $");
@


1.61.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: authfile.c,v 1.76 2006/08/03 03:34:41 deraadt Exp $ */
d38 2
a39 5

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/uio.h>
d45 1
a45 7
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

a46 1
#include "cipher.h"
d48 1
d187 1
a187 1
	if (fp == NULL) {
d214 1
d219 1
d510 1
a510 1
int
d537 1
a537 1
    char **commentp, int *perm_ok)
a544 2
		if (perm_ok != NULL)
			*perm_ok = 0;
a548 2
	if (perm_ok != NULL)
		*perm_ok = 1;
d554 1
d560 1
@


1.60
log
@Fix debug call in error path of authorized_keys processing and fix related
warnings; ok djm@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.59 2004/12/06 11:41:03 dtucker Exp $");
d55 1
d151 2
a152 2
	if (write(fd, buffer_ptr(&encrypted), buffer_len(&encrypted)) !=
	    buffer_len(&encrypted)) {
d240 1
a240 1
	int i;
d257 1
a257 1
	if (read(fd, cp, (size_t) len) != (size_t) len) {
d326 2
a327 1
	int i, check1, check2, cipher_type;
d352 1
a352 1
	if (read(fd, cp, (size_t) len) != (size_t) len) {
@


1.60.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.61 2005/06/17 02:44:32 djm Exp $");
a54 1
#include "atomicio.h"
d150 2
a151 2
	if (atomicio(vwrite, fd, buffer_ptr(&encrypted),
	    buffer_len(&encrypted)) != buffer_len(&encrypted)) {
d239 1
a239 1
	u_int i;
d256 1
a256 1
	if (atomicio(read, fd, cp, len) != len) {
d325 1
a325 2
	u_int i;
	int check1, check2, cipher_type;
d350 1
a350 1
	if (atomicio(read, fd, cp, len) != len) {
@


1.59
log
@Discard over-length authorized_keys entries rather than complaining when
they don't decode.  bz #884, with & ok djm@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.58 2004/08/23 11:48:09 djm Exp $");
d54 1
d604 1
a604 1
	int linenum = 0;
@


1.58
log
@fix error path, spotted by Martin.Kraemer AT Fujitsu-Siemens.com; ok markus
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.57 2004/06/21 17:36:31 avsm Exp $");
d601 1
a601 1
	char line[4096];
d603 1
d607 2
a608 2
		while (fgets(line, sizeof(line), f)) {
			line[sizeof(line)-1] = '\0';
@


1.58.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.60 2004/12/11 01:48:56 dtucker Exp $");
a53 1
#include "misc.h"
d601 1
a601 1
	char line[SSH_MAX_PUBKEY_BYTES];
a602 1
	u_long linenum = 0;
d606 2
a607 2
		while (read_keyfile_line(f, filename, line, sizeof(line),
			    &linenum) != -1) {
@


1.58.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.61 2005/06/17 02:44:32 djm Exp $");
a54 1
#include "atomicio.h"
d150 2
a151 2
	if (atomicio(vwrite, fd, buffer_ptr(&encrypted),
	    buffer_len(&encrypted)) != buffer_len(&encrypted)) {
d239 1
a239 1
	u_int i;
d256 1
a256 1
	if (atomicio(read, fd, cp, len) != len) {
d325 1
a325 2
	u_int i;
	int check1, check2, cipher_type;
d350 1
a350 1
	if (atomicio(read, fd, cp, len) != len) {
@


1.57
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.56 2004/05/11 19:01:43 deraadt Exp $");
d246 4
a249 2
	if (st.st_size > 1*1024*1024)
		close(fd);
d340 1
@


1.56
log
@improve some code lint did not like; djm millert ok
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.55 2003/09/18 07:56:05 markus Exp $");
d75 1
a75 1
	u_int32_t rand;
d90 3
a92 3
	rand = arc4random();
	buf[0] = rand & 0xff;
	buf[1] = (rand >> 8) & 0xff;
@


1.55
log
@missing  buffer_free(&encrypted); #662; zardoz at users.sf.net
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.54 2003/05/24 09:30:39 djm Exp $");
d239 1
a239 1
	off_t len;
d246 3
a248 1
	len = st.st_size;
d323 1
a323 1
	off_t len;
d337 5
a341 1
	len = st.st_size;
@


1.55.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.57 2004/06/21 17:36:31 avsm Exp $");
d75 1
a75 1
	u_int32_t rnd;
d90 3
a92 3
	rnd = arc4random();
	buf[0] = rnd & 0xff;
	buf[1] = (rnd >> 8) & 0xff;
d239 1
a239 1
	size_t len;
d246 1
a246 3
	if (st.st_size > 1*1024*1024)
		close(fd);
	len = (size_t)st.st_size;		/* truncated */
d321 1
a321 1
	size_t len;
d335 1
a335 5
	if (st.st_size > 1*1024*1024) {
		close(fd);
		return (NULL);
	}
	len = (size_t)st.st_size;		/* truncated */
@


1.55.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.60 2004/12/11 01:48:56 dtucker Exp $");
a53 1
#include "misc.h"
d246 2
a247 4
	if (st.st_size > 1*1024*1024) {
		error("key file %.200s too large", filename);
		return NULL;
	}
a337 1
		error("key file %.200s too large", filename);
d598 1
a598 1
	char line[SSH_MAX_PUBKEY_BYTES];
a599 1
	u_long linenum = 0;
d603 2
a604 2
		while (read_keyfile_line(f, filename, line, sizeof(line),
			    &linenum) != -1) {
@


1.54
log
@cast some types for printing; ok markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.53 2003/05/11 16:56:48 markus Exp $");
d146 1
@


1.54.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.55 2003/09/18 07:56:05 markus Exp $");
a145 1
		buffer_free(&encrypted);
@


1.54.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.57 2004/06/21 17:36:31 avsm Exp $");
d75 1
a75 1
	u_int32_t rnd;
d90 3
a92 3
	rnd = arc4random();
	buf[0] = rnd & 0xff;
	buf[1] = (rnd >> 8) & 0xff;
d239 1
a239 1
	size_t len;
d246 1
a246 3
	if (st.st_size > 1*1024*1024)
		close(fd);
	len = (size_t)st.st_size;		/* truncated */
d321 1
a321 1
	size_t len;
d335 1
a335 5
	if (st.st_size > 1*1024*1024) {
		close(fd);
		return (NULL);
	}
	len = (size_t)st.st_size;		/* truncated */
@


1.53
log
@change key_load_public to try to read a public from:
rsa1 private or rsa1 public and ssh2 keys.
this makes ssh-keygen -e fail for ssh1 keys more gracefully
for example; report from itojun (netbsd pr 20550).
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.52 2003/03/13 11:42:18 markus Exp $");
d514 1
a514 1
		    st.st_mode & 0777, filename);
@


1.52
log
@move RSA_blinding_on to generic key load method
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.51 2002/11/15 10:03:09 fgsch Exp $");
d629 1
d633 8
@


1.52.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.54 2003/05/24 09:30:39 djm Exp $");
d514 1
a514 1
		    (u_int)st.st_mode & 0777, filename);
a628 1
	/* try rsa1 private key */
a631 8

	/* try rsa1 public key */
	pub = key_new(KEY_RSA1);
	if (key_try_load_public(pub, filename, commentp) == 1)
		return pub;
	key_free(pub);

	/* try ssh2 public key */
@


1.52.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.55 2003/09/18 07:56:05 markus Exp $");
a145 1
		buffer_free(&encrypted);
@


1.51
log
@lseek(2) may return -1 when getting the public/private key lenght.
Simplify the code and check for errors using fstat(2).

Problem reported by Mauricio Sanchez, markus@@ ok.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.49 2002/05/23 19:24:30 markus Exp $");
d424 6
d469 5
@


1.50
log
@cat to (void) when output from buffer_get_X is ignored
@
text
@d235 1
d240 6
a245 2
	len = lseek(fd, (off_t) 0, SEEK_END);
	lseek(fd, (off_t) 0, SEEK_SET);
d326 1
d328 7
a334 2
	len = lseek(fd, (off_t) 0, SEEK_END);
	lseek(fd, (off_t) 0, SEEK_SET);
@


1.50.2.1
log
@Update to OpenSSH 3.6
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.52 2003/03/13 11:42:18 markus Exp $");
a234 1
	struct stat st;
d239 2
a240 6
	if (fstat(fd, &st) < 0) {
		error("fstat for key file %.200s failed: %.100s",
		    filename, strerror(errno));
		return NULL;
	}
	len = st.st_size;
a320 1
	struct stat st;
d322 2
a323 7
	if (fstat(fd, &st) < 0) {
		error("fstat for key file %.200s failed: %.100s",
		    filename, strerror(errno));
		close(fd);
		return NULL;
	}
	len = st.st_size;
a412 6

	/* enable blinding */
	if (RSA_blinding_on(prv->rsa, NULL) != 1) {
		error("key_load_private_rsa1: RSA_blinding_on failed");
		goto fail;
	}
a451 5
		if (RSA_blinding_on(prv->rsa, NULL) != 1) {
			error("key_load_private_pem: RSA_blinding_on failed");
			key_free(prv);
			prv = NULL;
		}
@


1.50.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.54 2003/05/24 09:30:39 djm Exp $");
d514 1
a514 1
		    (u_int)st.st_mode & 0777, filename);
a628 1
	/* try rsa1 private key */
a631 8

	/* try rsa1 public key */
	pub = key_new(KEY_RSA1);
	if (key_try_load_public(pub, filename, commentp) == 1)
		return pub;
	key_free(pub);

	/* try ssh2 public key */
@


1.49
log
@add /usr/libexec/ssh-keysign: a setuid helper program for hostbased authentication
in protocol v2 (needs to access the hostkeys).
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.48 2002/02/28 15:46:33 markus Exp $");
d273 1
a273 1
	buffer_get_int(&buffer);
d360 1
a360 1
	buffer_get_int(&buffer);
@


1.48
log
@add some const EVP_MD for openssl-0.9.7
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.47 2002/02/24 19:14:59 markus Exp $");
d424 1
a424 1
static Key *
@


1.48.2.1
log
@Pull in OpenSSH-3.4
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.50 2002/06/24 14:55:38 markus Exp $");
d273 1
a273 1
	(void) buffer_get_int(&buffer);
d360 1
a360 1
	(void) buffer_get_int(&buffer);
d424 1
a424 1
Key *
@


1.48.2.2
log
@Merge OpenSSH 3.6.1
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.52 2003/03/13 11:42:18 markus Exp $");
a234 1
	struct stat st;
d239 2
a240 6
	if (fstat(fd, &st) < 0) {
		error("fstat for key file %.200s failed: %.100s",
		    filename, strerror(errno));
		return NULL;
	}
	len = st.st_size;
a320 1
	struct stat st;
d322 2
a323 7
	if (fstat(fd, &st) < 0) {
		error("fstat for key file %.200s failed: %.100s",
		    filename, strerror(errno));
		close(fd);
		return NULL;
	}
	len = st.st_size;
a412 6

	/* enable blinding */
	if (RSA_blinding_on(prv->rsa, NULL) != 1) {
		error("key_load_private_rsa1: RSA_blinding_on failed");
		goto fail;
	}
a451 5
		if (RSA_blinding_on(prv->rsa, NULL) != 1) {
			error("key_load_private_pem: RSA_blinding_on failed");
			key_free(prv);
			prv = NULL;
		}
@


1.47
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.46 2002/02/14 23:41:01 markus Exp $");
d172 1
a172 1
	EVP_CIPHER *cipher = (len > 0) ? EVP_des_ede3_cbc() : NULL;
@


1.46
log
@hide some more implementation details of cipher.[ch] and prepares for move
to EVP, ok deraadt@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.45 2001/12/29 21:56:01 stevesk Exp $");
d171 1
a171 1
	char *passphrase = (len > 0) ? (char *)_passphrase : NULL;
@


1.45
log
@remove unneeded casts and some char->u_char cleanup; ok markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.44 2001/12/27 18:26:13 markus Exp $");
d72 1
a72 1
	int fd, i;
d81 3
a83 5
	if (strcmp(passphrase, "") == 0)
		cipher = cipher_by_number(SSH_CIPHER_NONE);
	else
		cipher = cipher_by_number(SSH_AUTHFILE_CIPHER);
	if (cipher == NULL)
d120 1
a120 1
	buffer_put_char(&encrypted, cipher->number);
d132 3
a134 2
	cipher_set_key_string(&ciphercontext, cipher, passphrase);
	cipher_encrypt(&ciphercontext, cp,
d136 1
d383 3
a385 2
	cipher_set_key_string(&ciphercontext, cipher, passphrase);
	cipher_decrypt(&ciphercontext, cp,
d387 1
@


1.44
log
@missing include
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.43 2001/12/27 18:22:16 markus Exp $");
d71 1
a71 1
	char buf[100], *cp;
d135 2
a136 2
	cipher_encrypt(&ciphercontext, (u_char *) cp,
	    (u_char *) buffer_ptr(&buffer), buffer_len(&buffer));
d317 1
a317 1
	char *cp;
d384 2
a385 2
	cipher_decrypt(&ciphercontext, (u_char *) cp,
	    (u_char *) buffer_ptr(&buffer), buffer_len(&buffer));
@


1.43
log
@call fatal() for openssl allocation failures
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.42 2001/12/19 17:16:13 stevesk Exp $");
d53 1
@


1.42
log
@change the buffer/packet interface to use void* vs. char*; ok markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.41 2001/12/19 07:18:56 deraadt Exp $");
a318 2
	BN_CTX *ctx;
	BIGNUM *aux;
d407 1
a407 11
	ctx = BN_CTX_new();
	aux = BN_new();

	BN_sub(aux, prv->rsa->q, BN_value_one());
	BN_mod(prv->rsa->dmq1, prv->rsa->d, aux, ctx);

	BN_sub(aux, prv->rsa->p, BN_value_one());
	BN_mod(prv->rsa->dmp1, prv->rsa->d, aux, ctx);

	BN_clear_free(aux);
	BN_CTX_free(ctx);
@


1.41
log
@basic KNF done while i was looking for something else
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.40 2001/12/05 10:06:12 deraadt Exp $");
d131 1
a131 1
	buffer_append_space(&encrypted, &cp, buffer_len(&buffer));
d242 1
a242 1
	buffer_append_space(&buffer, &cp, len);
d327 1
a327 1
	buffer_append_space(&buffer, &cp, len);
d381 1
a381 1
	buffer_append_space(&decrypted, &cp, buffer_len(&buffer));
@


1.40
log
@minor KNF
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.39 2001/10/07 10:29:52 markus Exp $");
d150 1
a150 1
		      strerror(errno));
d453 1
a453 1
	     (type == KEY_UNSPEC||type==KEY_RSA)) {
d462 1
a462 1
	     (type == KEY_UNSPEC||type==KEY_DSA)) {
@


1.39
log
@grammer; Matthew_Clarke@@mindlink.bc.ca
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.38 2001/09/23 11:09:13 markus Exp $");
d586 1
a586 1
			switch(*cp){
@


1.39.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.48 2002/02/28 15:46:33 markus Exp $");
a52 1
#include "rsa.h"
d70 2
a71 2
	u_char buf[100], *cp;
	int fd, i, cipher_num;
d80 5
a84 3
	cipher_num = (strcmp(passphrase, "") == 0) ?
	    SSH_CIPHER_NONE : SSH_AUTHFILE_CIPHER;
	if ((cipher = cipher_by_number(cipher_num)) == NULL)
d121 1
a121 1
	buffer_put_char(&encrypted, cipher_num);
d131 1
a131 1
	cp = buffer_append_space(&encrypted, buffer_len(&buffer));
d133 3
a135 5
	cipher_set_key_string(&ciphercontext, cipher, passphrase,
	    CIPHER_ENCRYPT);
	cipher_crypt(&ciphercontext, cp,
	    buffer_ptr(&buffer), buffer_len(&buffer));
	cipher_cleanup(&ciphercontext);
d150 1
a150 1
		    strerror(errno));
d170 2
a171 2
	u_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;
	const EVP_CIPHER *cipher = (len > 0) ? EVP_des_ede3_cbc() : NULL;
d242 1
a242 1
	cp = buffer_append_space(&buffer, len);
d316 1
a316 1
	u_char *cp;
d319 2
d327 1
a327 1
	cp = buffer_append_space(&buffer, len);
d381 1
a381 1
	cp = buffer_append_space(&decrypted, buffer_len(&buffer));
d384 3
a386 5
	cipher_set_key_string(&ciphercontext, cipher, passphrase,
	    CIPHER_DECRYPT);
	cipher_crypt(&ciphercontext, cp,
	    buffer_ptr(&buffer), buffer_len(&buffer));
	cipher_cleanup(&ciphercontext);
d409 11
a419 1
	rsa_generate_additional_parameters(prv->rsa);
d453 1
a453 1
	    (type == KEY_UNSPEC||type==KEY_RSA)) {
d462 1
a462 1
	    (type == KEY_UNSPEC||type==KEY_DSA)) {
d586 1
a586 1
			switch (*cp) {
@


1.39.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.39.2.1 2002/03/07 17:37:46 jason Exp $");
d424 1
a424 1
Key *
@


1.39.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.39.2.2 2002/06/22 07:23:17 miod Exp $");
d273 1
a273 1
	(void) buffer_get_int(&buffer);
d360 1
a360 1
	(void) buffer_get_int(&buffer);
@


1.38
log
@relax permission check for private key files.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.37 2001/06/23 15:12:17 itojun Exp $");
d253 1
a253 1
		debug3("No RSA1 key file %.200s.", filename);
d263 1
a263 1
			debug3("No RSA1 key file %.200s.", filename);
d339 1
a339 1
		debug3("No RSA1 key file %.200s.", filename);
d350 1
a350 1
			debug3("No RSA1 key file %.200s.", filename);
@


1.37
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.36 2001/06/07 20:23:03 markus Exp $");
d489 8
a496 5
	/* check owner and modes */
	if (fstat(fd, &st) < 0 ||
	    (st.st_uid != 0 && getuid() != 0 && st.st_uid != getuid()) ||
	    (st.st_mode & 077) != 0) {
		close(fd);
d500 1
a500 1
		error("Bad ownership or mode(0%3.3o) for '%s'.",
@


1.36
log
@use xxx_put_cstring()
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.35 2001/05/29 12:31:27 markus Exp $");
d65 1
a65 1
int
d162 1
a162 1
int
d229 1
a229 1
Key *
d309 1
a309 1
Key *
d433 1
a433 1
Key *
d484 1
a484 1
int
d571 1
a571 1
int
@


1.35
log
@typo
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.34 2001/05/28 10:08:55 markus Exp $");
d128 1
a128 1
	buffer_put_string(&encrypted, comment, strlen(comment));
@


1.34
log
@key_load_private: set comment to filename for PEM keys
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.33 2001/05/16 20:51:57 markus Exp $");
d561 1
a561 1
			commentp = xstrdup(filename);
@


1.33
log
@return comments for private pem files, too; report from nolan@@naic.edu
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.32 2001/04/18 23:44:51 markus Exp $");
d543 1
a543 1
	Key *pub;
d558 4
a561 2
		return key_load_private_pem(fd, KEY_UNSPEC, passphrase,
		    commentp);
d566 1
a566 1
		return key_load_private_rsa1(fd, filename, passphrase, NULL);
d568 1
@


1.32
log
@error->debug; noted by fries@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.31 2001/04/15 16:58:03 markus Exp $");
d558 2
a559 1
		return key_load_private_pem(fd, KEY_UNSPEC, passphrase, NULL);
@


1.32.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.38 2001/09/23 11:09:13 markus Exp $");
d65 1
a65 1
static int
d128 1
a128 1
	buffer_put_cstring(&encrypted, comment);
d162 1
a162 1
static int
d229 1
a229 1
static Key *
d309 1
a309 1
static Key *
d433 1
a433 1
static Key *
d484 1
a484 1
static int
d489 5
a493 8
	if (fstat(fd, &st) < 0)
		return 0;
	/*
	 * if a key owned by the user is accessed, then we check the
	 * permissions of the file. if the key owned by a different user,
	 * then we don't care.
	 */
	if ((st.st_uid == getuid()) && (st.st_mode & 077) != 0) {
d497 1
a497 1
		error("Permissions 0%3.3o for '%s' are too open.",
d543 1
a543 1
	Key *pub, *prv;
d558 1
a558 4
		prv = key_load_private_pem(fd, KEY_UNSPEC, passphrase, NULL);
		/* use the filename as a comment for PEM */
		if (commentp && prv)
			*commentp = xstrdup(filename);
d563 1
a563 1
		prv = key_load_private_rsa1(fd, filename, passphrase, NULL);
a564 1
	return prv;
d567 1
a567 1
static int
@


1.32.2.2
log
@Merge OpenSSH 3.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.32.2.1 2001/09/27 19:03:54 jason Exp $");
d253 1
a253 1
		debug3("Not a RSA1 key file %.200s.", filename);
d263 1
a263 1
			debug3("Not a RSA1 key file %.200s.", filename);
d339 1
a339 1
		debug3("Not a RSA1 key file %.200s.", filename);
d350 1
a350 1
			debug3("Not a RSA1 key file %.200s.", filename);
@


1.32.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.48 2002/02/28 15:46:33 markus Exp $");
a52 1
#include "rsa.h"
d70 2
a71 2
	u_char buf[100], *cp;
	int fd, i, cipher_num;
d80 5
a84 3
	cipher_num = (strcmp(passphrase, "") == 0) ?
	    SSH_CIPHER_NONE : SSH_AUTHFILE_CIPHER;
	if ((cipher = cipher_by_number(cipher_num)) == NULL)
d121 1
a121 1
	buffer_put_char(&encrypted, cipher_num);
d131 1
a131 1
	cp = buffer_append_space(&encrypted, buffer_len(&buffer));
d133 3
a135 5
	cipher_set_key_string(&ciphercontext, cipher, passphrase,
	    CIPHER_ENCRYPT);
	cipher_crypt(&ciphercontext, cp,
	    buffer_ptr(&buffer), buffer_len(&buffer));
	cipher_cleanup(&ciphercontext);
d150 1
a150 1
		    strerror(errno));
d170 2
a171 2
	u_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;
	const EVP_CIPHER *cipher = (len > 0) ? EVP_des_ede3_cbc() : NULL;
d242 1
a242 1
	cp = buffer_append_space(&buffer, len);
d316 1
a316 1
	u_char *cp;
d319 2
d327 1
a327 1
	cp = buffer_append_space(&buffer, len);
d381 1
a381 1
	cp = buffer_append_space(&decrypted, buffer_len(&buffer));
d384 3
a386 5
	cipher_set_key_string(&ciphercontext, cipher, passphrase,
	    CIPHER_DECRYPT);
	cipher_crypt(&ciphercontext, cp,
	    buffer_ptr(&buffer), buffer_len(&buffer));
	cipher_cleanup(&ciphercontext);
d409 11
a419 1
	rsa_generate_additional_parameters(prv->rsa);
d453 1
a453 1
	    (type == KEY_UNSPEC||type==KEY_RSA)) {
d462 1
a462 1
	    (type == KEY_UNSPEC||type==KEY_DSA)) {
d586 1
a586 1
			switch (*cp) {
@


1.31
log
@don't use errno for key_{load,save}_private; discussion w/ solar@@openwall
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.30 2001/03/26 23:12:42 markus Exp $");
d450 1
a450 1
		error("PEM_read_PrivateKey failed");
@


1.30
log
@KNF
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.29 2001/03/26 08:07:07 markus Exp $");
d143 2
a144 1
	if (fd < 0)
d146 1
d149 1
a149 1
		debug("Write to key file %.200s failed: %.100s", filename,
d174 1
a174 2
		error("passphrase too short: %d bytes", len);
		errno = 0;
d179 1
a179 1
		debug("open %s failed", filename);
d184 1
a184 1
		debug("fdopen %s failed", filename);
d219 1
d253 1
a253 1
		debug3("Bad RSA1 key file %.200s.", filename);
d263 1
a263 1
			debug3("Bad RSA1 key file %.200s.", filename);
d339 1
a339 1
		debug3("Bad RSA1 key file %.200s.", filename);
d350 1
a350 1
			debug3("Bad RSA1 key file %.200s.", filename);
d444 1
a444 1
		error("fdopen failed");
d450 1
a450 1
		debug("PEM_read_PrivateKey failed");
d516 1
a516 1
		debug("bad permissions: ignore key: %s", filename);
d550 1
a550 1
		debug("bad permissions: ignore key: %s", filename);
@


1.29
log
@simpler key load/save interface, see authfile.h
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.28 2001/02/21 09:05:54 deraadt Exp $");
d188 8
a195 8
		case KEY_DSA:
			success = PEM_write_DSAPrivateKey(fp, key->dsa,
			    cipher, passphrase, len, NULL, NULL);
			break;
		case KEY_RSA:
			success = PEM_write_RSAPrivateKey(fp, key->rsa,
			    cipher, passphrase, len, NULL, NULL);
			break;
@


1.28
log
@improve fd handling
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.27 2001/02/08 19:30:51 itojun Exp $");
d54 1
a54 1
/* Version identification string for identity files. */
d66 2
a67 2
save_private_key_rsa1(const char *filename, const char *passphrase,
    RSA *key, const char *comment)
d103 4
a106 4
	buffer_put_bignum(&buffer, key->d);
	buffer_put_bignum(&buffer, key->iqmp);
	buffer_put_bignum(&buffer, key->q);	/* reverse from SSL p */
	buffer_put_bignum(&buffer, key->p);	/* reverse from SSL q */
d125 3
a127 3
	buffer_put_int(&encrypted, BN_num_bits(key->n));
	buffer_put_bignum(&encrypted, key->n);
	buffer_put_bignum(&encrypted, key->e);
d159 1
a159 1
/* save SSH2 key in OpenSSL PEM format */
d161 2
a162 2
save_private_key_ssh2(const char *filename, const char *_passphrase,
    Key *key, const char *comment)
d202 1
a202 1
save_private_key(const char *filename, const char *passphrase, Key *key,
d207 2
a208 1
		return save_private_key_rsa1(filename, passphrase, key->rsa, comment);
d212 2
a213 1
		return save_private_key_ssh2(filename, passphrase, key, comment);
d222 2
a223 2
 * Loads the public part of the key file.  Returns 0 if an error was
 * encountered (the file does not exist or is not readable), and non-zero
d227 2
a228 2
int
load_public_key_rsa(const char *filename, RSA * pub, char **comment_return)
a229 2
	int fd, i;
	off_t len;
d231 1
d233 2
a235 3
	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return 0;
d246 1
a246 2
		close(fd);
		return 0;
a247 1
	close(fd);
d253 1
a253 1
		return 0;
d263 1
a263 1
			return 0;
d271 5
a275 10
	/* XXX alloc */
	if (pub->n == NULL)
		pub->n = BN_new();
	buffer_get_bignum(&buffer, pub->n);
	/* XXX alloc */
	if (pub->e == NULL)
		pub->e = BN_new();
	buffer_get_bignum(&buffer, pub->e);
	if (comment_return)
		*comment_return = buffer_get_string(&buffer, NULL);
d279 1
a279 2

	return 1;
d282 3
a284 3
/* load public key from private-key file */
int
load_public_key(const char *filename, Key * key, char **comment_return)
d286 10
a295 8
	switch (key->type) {
	case KEY_RSA1:
		return load_public_key_rsa(filename, key->rsa, comment_return);
		break;
	case KEY_DSA:
	case KEY_RSA:
	default:
		break;
d297 1
a297 1
	return 0;
d307 3
a309 3
int
load_private_key_rsa1(int fd, const char *filename,
    const char *passphrase, RSA * prv, char **comment_return)
d319 1
d332 1
a332 1
		return 0;
d340 1
a340 1
		return 0;
d351 1
a351 1
			return 0;
d360 6
a365 6
	prv->n = BN_new();
	buffer_get_bignum(&buffer, prv->n);
	prv->e = BN_new();
	buffer_get_bignum(&buffer, prv->e);
	if (comment_return)
		*comment_return = buffer_get_string(&buffer, NULL);
d393 2
a394 1
			debug("Bad passphrase supplied for key file %.200s.", filename);
d397 1
a397 9
fail:
		BN_clear_free(prv->n);
		prv->n = NULL;
		BN_clear_free(prv->e);
		prv->e = NULL;
		if (comment_return)
			xfree(*comment_return);
		close(fd);
		return 0;
d400 5
a404 9
	prv->d = BN_new();
	buffer_get_bignum(&decrypted, prv->d);
	prv->iqmp = BN_new();
	buffer_get_bignum(&decrypted, prv->iqmp);	/* u */
	/* in SSL and SSH p and q are exchanged */
	prv->q = BN_new();
	buffer_get_bignum(&decrypted, prv->q);		/* p */
	prv->p = BN_new();
	buffer_get_bignum(&decrypted, prv->p);		/* q */
d406 1
d410 5
a414 7
	BN_sub(aux, prv->q, BN_value_one());
	prv->dmq1 = BN_new();
	BN_mod(prv->dmq1, prv->d, aux, ctx);

	BN_sub(aux, prv->p, BN_value_one());
	prv->dmp1 = BN_new();
	BN_mod(prv->dmp1, prv->d, aux, ctx);
d421 8
a428 1
	return 1;
d431 3
a433 2
int
load_private_key_ssh2(int fd, const char *passphrase, Key *k, char **comment_return)
a435 1
	int success = 0;
d437 1
d444 1
a444 1
		return 0;
d450 6
a455 9
	} else if (pk->type == EVP_PKEY_RSA) {
		/* replace k->rsa with loaded key */
		if (k->type == KEY_RSA || k->type == KEY_UNSPEC) {
			if (k->rsa != NULL)
				RSA_free(k->rsa);
			k->rsa = EVP_PKEY_get1_RSA(pk);
			k->type = KEY_RSA;
			name = "rsa w/o comment";
			success = 1;
d457 1
a457 1
			RSA_print_fp(stderr, k->rsa, 8);
d459 6
a464 9
		}
	} else if (pk->type == EVP_PKEY_DSA) {
		/* replace k->dsa with loaded key */
		if (k->type == KEY_DSA || k->type == KEY_UNSPEC) {
			if (k->dsa != NULL)
				DSA_free(k->dsa);
			k->dsa = EVP_PKEY_get1_DSA(pk);
			k->type = KEY_DSA;
			name = "dsa w/o comment";
d466 1
a466 1
			DSA_print_fp(stderr, k->dsa, 8);
a467 2
			success = 1;
		}
d475 5
a479 4
	if (success && comment_return)
		*comment_return = xstrdup(name);
	debug("read SSH2 private key done: name %s success %d", name, success);
	return success;
d483 1
a483 2
load_private_key(const char *filename, const char *passphrase, Key *key,
    char **comment_return)
a484 2
	int fd;
	int ret = 0;
a486 4
	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return 0;

d498 1
d501 18
a518 1
	switch (key->type) {
d520 3
a522 11
		if (key->rsa->e != NULL) {
			BN_clear_free(key->rsa->e);
			key->rsa->e = NULL;
		}
		if (key->rsa->n != NULL) {
			BN_clear_free(key->rsa->n);
			key->rsa->n = NULL;
		}
		ret = load_private_key_rsa1(fd, filename, passphrase,
		    key->rsa, comment_return);		/* closes fd */

d527 2
a528 2
		ret = load_private_key_ssh2(fd, passphrase, key,
		    comment_return);			/* closes fd */
d534 29
a562 1
	return ret;
d566 1
a566 1
do_load_public_key(const char *filename, Key *k, char **commentp)
d569 1
a569 1
	char line[1024];
d600 3
a602 3
/* load public key from pubkey file */
int
try_load_public_key(const char *filename, Key *k, char **commentp)
d604 2
a605 1
	char pub[MAXPATHLEN];
d607 12
a618 9
	if (do_load_public_key(filename, k, commentp) == 1)
		return 1;
	if (strlcpy(pub, filename, sizeof pub) >= MAXPATHLEN)
		return 0;
	if (strlcat(pub, ".pub", sizeof pub) >= MAXPATHLEN)
		return 0;
	if (do_load_public_key(pub, k, commentp) == 1)
		return 1;
	return 0;
@


1.27
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.26 2001/01/28 22:27:05 stevesk Exp $");
a338 1
	close(fd);
d344 1
d355 1
d358 1
d408 1
d437 1
a437 1

d452 1
d519 1
a519 1
		      st.st_mode & 0777, filename);
d534 2
a535 1
		     key->rsa, comment_return);
d540 3
a542 1
		ret = load_private_key_ssh2(fd, passphrase, key, comment_return);
d544 1
a546 1
	close(fd);
@


1.26
log
@spelling.  use sizeof vs. strlen().  ok markus@@
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.25 2001/01/21 19:05:44 markus Exp $");
d52 1
@


1.25
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.24 2000/12/20 19:26:56 markus Exp $");
d54 2
a55 1
#define AUTHFILE_ID_STRING "SSH PRIVATE KEY FILE FORMAT 1.1\n"
d115 2
a116 3
	cp = AUTHFILE_ID_STRING;
	for (i = 0; cp[i]; i++)
		buffer_put_char(&encrypted, cp[i]);
d250 2
a251 2
	/* Check that it is at least big enought to contain the ID string. */
	if (len < strlen(AUTHFILE_ID_STRING) + 1) {
d260 2
a261 2
	for (i = 0; i < (u_int) strlen(AUTHFILE_ID_STRING) + 1; i++)
		if (buffer_get_char(&buffer) != (u_char) AUTHFILE_ID_STRING[i]) {
d340 2
a341 2
	/* Check that it is at least big enought to contain the ID string. */
	if (len < strlen(AUTHFILE_ID_STRING) + 1) {
d350 2
a351 2
	for (i = 0; i < (u_int) strlen(AUTHFILE_ID_STRING) + 1; i++)
		if (buffer_get_char(&buffer) != (u_char) AUTHFILE_ID_STRING[i]) {
@


1.24
log
@allow ssh -i userkey for root
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.23 2000/12/19 23:17:55 markus Exp $");
a40 3
#include <openssl/bn.h>
#include <openssl/dsa.h>
#include <openssl/rsa.h>
d42 1
a43 1
#include <openssl/evp.h>
d45 1
d49 1
d51 1
a51 1
#include "key.h"
@


1.23
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.22 2000/12/19 22:43:44 markus Exp $");
d508 1
a508 1
	    (st.st_uid != 0 && st.st_uid != getuid()) ||
@


1.22
log
@remove() -> unlink() for consistency
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.21 2000/11/12 19:50:37 markus Exp $");
d134 2
a135 2
	cipher_encrypt(&ciphercontext, (unsigned char *) cp,
	    (unsigned char *) buffer_ptr(&buffer), buffer_len(&buffer));
d261 1
a261 1
	for (i = 0; i < (unsigned int) strlen(AUTHFILE_ID_STRING) + 1; i++)
d351 1
a351 1
	for (i = 0; i < (unsigned int) strlen(AUTHFILE_ID_STRING) + 1; i++)
d386 2
a387 2
	cipher_decrypt(&ciphercontext, (unsigned char *) cp,
	    (unsigned char *) buffer_ptr(&buffer), buffer_len(&buffer));
@


1.21
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.20 2000/10/11 20:27:23 markus Exp $");
d151 1
a151 1
		remove(filename);
@


1.20
log
@new cipher framework
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.19 2000/09/07 20:27:49 deraadt Exp $");
d44 1
d65 1
a65 1
save_private_key_rsa(const char *filename, const char *passphrase,
d159 1
a159 2
/* save DSA key in OpenSSL PEM format */

d161 2
a162 2
save_private_key_dsa(const char *filename, const char *passphrase,
    DSA *dsa, const char *comment)
d166 4
a169 2
	int success = 1;
	int len = strlen(passphrase);
d187 9
a195 8
	if (len > 0) {
		if (!PEM_write_DSAPrivateKey(fp, dsa, EVP_des_ede3_cbc(),
		    (char *)passphrase, strlen(passphrase), NULL, NULL))
			success = 0;
	} else {
		if (!PEM_write_DSAPrivateKey(fp, dsa, NULL,
		    NULL, 0, NULL, NULL))
			success = 0;
d206 2
a207 2
	case KEY_RSA:
		return save_private_key_rsa(filename, passphrase, key->rsa, comment);
d210 2
a211 1
		return save_private_key_dsa(filename, passphrase, key->dsa, comment);
d253 1
a253 1
		debug("Bad key file %.200s.", filename);
d263 1
a263 1
			debug("Bad key file %.200s.", filename);
d295 1
a295 1
	case KEY_RSA:
d299 1
d314 1
a314 1
load_private_key_rsa(int fd, const char *filename,
d334 1
a334 1
		      strerror(errno));
d343 1
a343 1
		debug("Bad key file %.200s.", filename);
d352 2
a353 2
		if (buffer_get_char(&buffer) != (unsigned char) AUTHFILE_ID_STRING[i]) {
			debug("Bad key file %.200s.", filename);
d439 1
a439 1
load_private_key_dsa(int fd, const char *passphrase, Key *k, char **comment_return)
a440 2
	DSA *dsa;
	BIO *in;
d442 3
a445 5
	in = BIO_new(BIO_s_file());
	if (in == NULL) {
		error("BIO_new failed");
		return 0;
	}
d451 30
a480 4
	BIO_set_fp(in, fp, BIO_NOCLOSE);
	dsa = PEM_read_bio_DSAPrivateKey(in, NULL, NULL, (char *)passphrase);
	if (dsa == NULL) {
		debug("PEM_read_bio_DSAPrivateKey failed");
d482 2
a483 3
		/* replace k->dsa with loaded key */
		DSA_free(k->dsa);
		k->dsa = dsa;
a484 1
	BIO_free(in);
d486 6
a491 7
	if (comment_return)
		*comment_return = xstrdup("dsa w/o comment");
	debug("read DSA private key done");
#ifdef DEBUG_DSS
	DSA_print_fp(stderr, dsa, 8);
#endif
	return dsa != NULL ? 1 : 0;
d520 1
a520 1
	case KEY_RSA:
d529 1
a529 1
		ret = load_private_key_rsa(fd, filename, passphrase,
d533 3
a535 1
		ret = load_private_key_dsa(fd, passphrase, key, comment_return);
a546 1
	unsigned int bits;
d565 1
a565 2
				bits = key_read(k, &cp);
				if (bits != 0) {
@


1.20.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.27 2001/02/08 19:30:51 itojun Exp $");
d41 4
a44 1
#include <openssl/err.h>
a45 1
#include <openssl/pem.h>
a46 1
#include "cipher.h"
d50 1
a51 3
#include "ssh.h"
#include "log.h"
#include "authfile.h"
d54 1
a54 2
static const char authfile_id_string[] =
    "SSH PRIVATE KEY FILE FORMAT 1.1\n";
d64 1
a64 1
save_private_key_rsa1(const char *filename, const char *passphrase,
d114 3
a116 2
	for (i = 0; authfile_id_string[i]; i++)
		buffer_put_char(&encrypted, authfile_id_string[i]);
d133 2
a134 2
	cipher_encrypt(&ciphercontext, (u_char *) cp,
	    (u_char *) buffer_ptr(&buffer), buffer_len(&buffer));
d150 1
a150 1
		unlink(filename);
d158 2
a159 1
/* save SSH2 key in OpenSSL PEM format */
d161 2
a162 2
save_private_key_ssh2(const char *filename, const char *_passphrase,
    Key *key, const char *comment)
d166 2
a167 4
	int success = 0;
	int len = strlen(_passphrase);
	char *passphrase = (len > 0) ? (char *)_passphrase : NULL;
	EVP_CIPHER *cipher = (len > 0) ? EVP_des_ede3_cbc() : NULL;
d185 8
a192 9
	switch (key->type) {
		case KEY_DSA:
			success = PEM_write_DSAPrivateKey(fp, key->dsa,
			    cipher, passphrase, len, NULL, NULL);
			break;
		case KEY_RSA:
			success = PEM_write_RSAPrivateKey(fp, key->rsa,
			    cipher, passphrase, len, NULL, NULL);
			break;
d203 2
a204 2
	case KEY_RSA1:
		return save_private_key_rsa1(filename, passphrase, key->rsa, comment);
d207 1
a207 2
	case KEY_RSA:
		return save_private_key_ssh2(filename, passphrase, key, comment);
d247 3
a249 3
	/* Check that it is at least big enough to contain the ID string. */
	if (len < sizeof(authfile_id_string)) {
		debug3("Bad RSA1 key file %.200s.", filename);
d257 3
a259 3
	for (i = 0; i < sizeof(authfile_id_string); i++)
		if (buffer_get_char(&buffer) != authfile_id_string[i]) {
			debug3("Bad RSA1 key file %.200s.", filename);
d291 1
a291 1
	case KEY_RSA1:
a294 1
	case KEY_RSA:
d309 1
a309 1
load_private_key_rsa1(int fd, const char *filename,
d329 1
a329 1
		    strerror(errno));
d336 3
a338 3
	/* Check that it is at least big enough to contain the ID string. */
	if (len < sizeof(authfile_id_string)) {
		debug3("Bad RSA1 key file %.200s.", filename);
d346 3
a348 3
	for (i = 0; i < sizeof(authfile_id_string); i++)
		if (buffer_get_char(&buffer) != authfile_id_string[i]) {
			debug3("Bad RSA1 key file %.200s.", filename);
d381 2
a382 2
	cipher_decrypt(&ciphercontext, (u_char *) cp,
	    (u_char *) buffer_ptr(&buffer), buffer_len(&buffer));
d434 1
a434 1
load_private_key_ssh2(int fd, const char *passphrase, Key *k, char **comment_return)
d436 2
a438 3
	int success = 0;
	EVP_PKEY *pk = NULL;
	char *name = "<no key>";
d440 5
d450 5
a454 18
	pk = PEM_read_PrivateKey(fp, NULL, NULL, (char *)passphrase);
	if (pk == NULL) {
		debug("PEM_read_PrivateKey failed");
		(void)ERR_get_error();
	} else if (pk->type == EVP_PKEY_RSA) {
		/* replace k->rsa with loaded key */
		if (k->type == KEY_RSA || k->type == KEY_UNSPEC) {
			if (k->rsa != NULL)
				RSA_free(k->rsa);
			k->rsa = EVP_PKEY_get1_RSA(pk);
			k->type = KEY_RSA;
			name = "rsa w/o comment";
			success = 1;
#ifdef DEBUG_PK
			RSA_print_fp(stderr, k->rsa, 8);
#endif
		}
	} else if (pk->type == EVP_PKEY_DSA) {
d456 2
a457 14
		if (k->type == KEY_DSA || k->type == KEY_UNSPEC) {
			if (k->dsa != NULL)
				DSA_free(k->dsa);
			k->dsa = EVP_PKEY_get1_DSA(pk);
			k->type = KEY_DSA;
			name = "dsa w/o comment";
#ifdef DEBUG_PK
			DSA_print_fp(stderr, k->dsa, 8);
#endif
			success = 1;
		}
	} else {
		error("PEM_read_PrivateKey: mismatch or "
		    "unknown EVP_PKEY save_type %d", pk->save_type);
d459 1
d461 7
a467 6
	if (pk != NULL)
		EVP_PKEY_free(pk);
	if (success && comment_return)
		*comment_return = xstrdup(name);
	debug("read SSH2 private key done: name %s success %d", name, success);
	return success;
d484 1
a484 1
	    (st.st_uid != 0 && getuid() != 0 && st.st_uid != getuid()) ||
d496 1
a496 1
	case KEY_RSA1:
d505 1
a505 1
		ret = load_private_key_rsa1(fd, filename, passphrase,
d509 1
a509 3
	case KEY_RSA:
	case KEY_UNSPEC:
		ret = load_private_key_ssh2(fd, passphrase, key, comment_return);
d521 1
d540 2
a541 1
				if (key_read(k, &cp) == 1) {
@


1.20.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.20.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.28 2001/02/21 09:05:54 deraadt Exp $");
d339 1
a344 1
		close(fd);
a354 1
			close(fd);
a356 1

a405 1
		close(fd);
d434 1
a434 1
	close(fd);
a448 1
		close(fd);
d515 1
a515 1
		    st.st_mode & 0777, filename);
d530 1
a530 2
		    key->rsa, comment_return);		/* closes fd */

d535 1
a535 3
		ret = load_private_key_ssh2(fd, passphrase, key,
		    comment_return);			/* closes fd */
		break;
a536 1
		close(fd);
d539 1
@


1.20.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.32 2001/04/18 23:44:51 markus Exp $");
d54 1
a54 1
/* Version identification string for SSH v1 identity files. */
d66 2
a67 2
key_save_private_rsa1(Key *key, const char *filename, const char *passphrase,
    const char *comment)
d103 4
a106 4
	buffer_put_bignum(&buffer, key->rsa->d);
	buffer_put_bignum(&buffer, key->rsa->iqmp);
	buffer_put_bignum(&buffer, key->rsa->q);	/* reverse from SSL p */
	buffer_put_bignum(&buffer, key->rsa->p);	/* reverse from SSL q */
d125 3
a127 3
	buffer_put_int(&encrypted, BN_num_bits(key->rsa->n));
	buffer_put_bignum(&encrypted, key->rsa->n);
	buffer_put_bignum(&encrypted, key->rsa->e);
d143 1
a143 2
	if (fd < 0) {
		error("open %s failed: %s.", filename, strerror(errno));
a144 1
	}
d147 1
a147 1
		error("write to key file %s failed: %s", filename,
d159 1
a159 1
/* save SSH v2 key in OpenSSL PEM format */
d161 2
a162 2
key_save_private_pem(Key *key, const char *filename, const char *_passphrase,
    const char *comment)
d172 2
a173 1
		error("passphrase too short: have %d bytes, need > 4", len);
d178 1
a178 1
		error("open %s failed: %s.", filename, strerror(errno));
d183 1
a183 1
		error("fdopen %s failed: %s.", filename, strerror(errno));
d188 8
a195 8
	case KEY_DSA:
		success = PEM_write_DSAPrivateKey(fp, key->dsa,
		    cipher, passphrase, len, NULL, NULL);
		break;
	case KEY_RSA:
		success = PEM_write_RSAPrivateKey(fp, key->rsa,
		    cipher, passphrase, len, NULL, NULL);
		break;
d202 1
a202 1
key_save_private(Key *key, const char *filename, const char *passphrase,
d207 1
a207 2
		return key_save_private_rsa1(key, filename, passphrase,
		    comment);
d211 1
a211 2
		return key_save_private_pem(key, filename, passphrase,
		    comment);
a215 1
	error("key_save_private: cannot save key type %d", key->type);
d220 2
a221 2
 * Loads the public part of the ssh v1 key file.  Returns NULL if an error was
 * encountered (the file does not exist or is not readable), and the key
d225 2
a226 2
Key *
key_load_public_rsa1(int fd, const char *filename, char **commentp)
d228 2
a230 1
	Key *pub;
a231 2
	int i;
	off_t len;
d233 3
d246 2
a247 1
		return NULL;
d249 1
d253 1
a253 1
		debug3("No RSA1 key file %.200s.", filename);
d255 1
a255 1
		return NULL;
d263 1
a263 1
			debug3("No RSA1 key file %.200s.", filename);
d265 1
a265 1
			return NULL;
d273 10
a282 5
	pub = key_new(KEY_RSA1);
	buffer_get_bignum(&buffer, pub->rsa->n);
	buffer_get_bignum(&buffer, pub->rsa->e);
	if (commentp)
		*commentp = buffer_get_string(&buffer, NULL);
d286 2
a287 1
	return pub;
d290 3
a292 3
/* load public key from private-key file, works only for SSH v1 */
Key *
key_load_public_type(int type, const char *filename, char **commentp)
d294 8
a301 10
	Key *pub;
	int fd;

	if (type == KEY_RSA1) {
		fd = open(filename, O_RDONLY);
		if (fd < 0)
			return NULL;
		pub = key_load_public_rsa1(fd, filename, commentp);
		close(fd);
		return pub;
d303 1
a303 1
	return NULL;
d313 3
a315 3
Key *
key_load_private_rsa1(int fd, const char *filename, const char *passphrase,
    char **commentp)
a324 1
	Key *prv = NULL;
d337 1
a337 1
		return NULL;
d342 1
a342 1
		debug3("No RSA1 key file %.200s.", filename);
d345 1
a345 1
		return NULL;
d353 1
a353 1
			debug3("No RSA1 key file %.200s.", filename);
d356 1
a356 1
			return NULL;
d365 6
a370 6
	prv = key_new_private(KEY_RSA1);

	buffer_get_bignum(&buffer, prv->rsa->n);
	buffer_get_bignum(&buffer, prv->rsa->e);
	if (commentp)
		*commentp = buffer_get_string(&buffer, NULL);
d398 1
a398 2
			debug("Bad passphrase supplied for key file %.200s.",
			    filename);
d401 9
a409 1
		goto fail;
d412 9
a420 5
	buffer_get_bignum(&decrypted, prv->rsa->d);
	buffer_get_bignum(&decrypted, prv->rsa->iqmp);		/* u */
	/* in SSL and SSH v1 p and q are exchanged */
	buffer_get_bignum(&decrypted, prv->rsa->q);		/* p */
	buffer_get_bignum(&decrypted, prv->rsa->p);		/* q */
a421 1
	/* calculate p-1 and q-1 */
d425 7
a431 5
	BN_sub(aux, prv->rsa->q, BN_value_one());
	BN_mod(prv->rsa->dmq1, prv->rsa->d, aux, ctx);

	BN_sub(aux, prv->rsa->p, BN_value_one());
	BN_mod(prv->rsa->dmp1, prv->rsa->d, aux, ctx);
d438 1
a438 8
	return prv;

fail:
	if (commentp)
		xfree(*commentp);
	close(fd);
	key_free(prv);
	return NULL;
d441 2
a442 3
Key *
key_load_private_pem(int fd, int type, const char *passphrase,
    char **commentp)
d445 1
a446 1
	Key *prv = NULL;
d451 1
a451 1
		error("fdopen failed: %s", strerror(errno));
d453 1
a453 1
		return NULL;
d459 9
a467 6
	} else if (pk->type == EVP_PKEY_RSA &&
	     (type == KEY_UNSPEC||type==KEY_RSA)) {
		prv = key_new(KEY_UNSPEC);
		prv->rsa = EVP_PKEY_get1_RSA(pk);
		prv->type = KEY_RSA;
		name = "rsa w/o comment";
d469 1
a469 1
		RSA_print_fp(stderr, prv->rsa, 8);
d471 9
a479 6
	} else if (pk->type == EVP_PKEY_DSA &&
	     (type == KEY_UNSPEC||type==KEY_DSA)) {
		prv = key_new(KEY_UNSPEC);
		prv->dsa = EVP_PKEY_get1_DSA(pk);
		prv->type = KEY_DSA;
		name = "dsa w/o comment";
d481 1
a481 1
		DSA_print_fp(stderr, prv->dsa, 8);
d483 2
d492 4
a495 5
	if (prv != NULL && commentp)
		*commentp = xstrdup(name);
	debug("read PEM private key done: type %s",
	    prv ? key_type(prv) : "<unknown>");
	return prv;
d499 2
a500 1
key_perm_ok(int fd, const char *filename)
d502 2
d506 4
a520 1
		error("This private key will be ignored.");
d523 12
a534 2
	return 1;
}
a535 19
Key *
key_load_private_type(int type, const char *filename, const char *passphrase,
    char **commentp)
{
	int fd;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return NULL;
	if (!key_perm_ok(fd, filename)) {
		error("bad permissions: ignore key: %s", filename);
		close(fd);
		return NULL;
	}
	switch (type) {
	case KEY_RSA1:
		return key_load_private_rsa1(fd, filename, passphrase,
		    commentp);
		/* closes fd */
d540 2
a541 2
		return key_load_private_pem(fd, type, passphrase, commentp);
		/* closes fd */
d547 1
a547 29
	return NULL;
}

Key *
key_load_private(const char *filename, const char *passphrase,
    char **commentp)
{
	Key *pub;
	int fd;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return NULL;
	if (!key_perm_ok(fd, filename)) {
		error("bad permissions: ignore key: %s", filename);
		close(fd);
		return NULL;
	}
	pub = key_load_public_rsa1(fd, filename, commentp);
	lseek(fd, (off_t) 0, SEEK_SET);		/* rewind */
	if (pub == NULL) {
		/* closes fd */
		return key_load_private_pem(fd, KEY_UNSPEC, passphrase, NULL);
	} else {
		/* it's a SSH v1 key if the public key part is readable */
		key_free(pub);
		/* closes fd */
		return key_load_private_rsa1(fd, filename, passphrase, NULL);
	}
d551 1
a551 1
key_try_load_public(Key *k, const char *filename, char **commentp)
d554 1
a554 1
	char line[4096];
d585 3
a587 3
/* load public key from ssh v1 private or any pubkey file */
Key *
key_load_public(const char *filename, char **commentp)
d589 1
a589 2
	Key *pub;
	char file[MAXPATHLEN];
d591 9
a599 12
	pub = key_load_public_type(KEY_RSA1, filename, commentp);
	if (pub != NULL)
		return pub;
	pub = key_new(KEY_UNSPEC);
	if (key_try_load_public(pub, filename, commentp) == 1)
		return pub;
	if ((strlcpy(file, filename, sizeof file) < sizeof(file)) &&
	    (strlcat(file, ".pub", sizeof file) < sizeof(file)) &&
	    (key_try_load_public(pub, file, commentp) == 1))
		return pub;
	key_free(pub);
	return NULL;
@


1.20.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.38 2001/09/23 11:09:13 markus Exp $");
d65 1
a65 1
static int
d128 1
a128 1
	buffer_put_cstring(&encrypted, comment);
d162 1
a162 1
static int
d229 1
a229 1
static Key *
d309 1
a309 1
static Key *
d433 1
a433 1
static Key *
d484 1
a484 1
static int
d489 5
a493 8
	if (fstat(fd, &st) < 0)
		return 0;
	/*
	 * if a key owned by the user is accessed, then we check the
	 * permissions of the file. if the key owned by a different user,
	 * then we don't care.
	 */
	if ((st.st_uid == getuid()) && (st.st_mode & 077) != 0) {
d497 1
a497 1
		error("Permissions 0%3.3o for '%s' are too open.",
d543 1
a543 1
	Key *pub, *prv;
d558 1
a558 4
		prv = key_load_private_pem(fd, KEY_UNSPEC, passphrase, NULL);
		/* use the filename as a comment for PEM */
		if (commentp && prv)
			*commentp = xstrdup(filename);
d563 1
a563 1
		prv = key_load_private_rsa1(fd, filename, passphrase, NULL);
a564 1
	return prv;
d567 1
a567 1
static int
@


1.20.2.6
log
@Merge OpenSSH 3.0
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.20.2.5 2001/09/27 00:15:41 miod Exp $");
d253 1
a253 1
		debug3("Not a RSA1 key file %.200s.", filename);
d263 1
a263 1
			debug3("Not a RSA1 key file %.200s.", filename);
d339 1
a339 1
		debug3("Not a RSA1 key file %.200s.", filename);
d350 1
a350 1
			debug3("Not a RSA1 key file %.200s.", filename);
@


1.20.2.7
log
@Merge OpenSSH 3.1.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.48 2002/02/28 15:46:33 markus Exp $");
a52 1
#include "rsa.h"
d70 2
a71 2
	u_char buf[100], *cp;
	int fd, i, cipher_num;
d80 5
a84 3
	cipher_num = (strcmp(passphrase, "") == 0) ?
	    SSH_CIPHER_NONE : SSH_AUTHFILE_CIPHER;
	if ((cipher = cipher_by_number(cipher_num)) == NULL)
d121 1
a121 1
	buffer_put_char(&encrypted, cipher_num);
d131 1
a131 1
	cp = buffer_append_space(&encrypted, buffer_len(&buffer));
d133 3
a135 5
	cipher_set_key_string(&ciphercontext, cipher, passphrase,
	    CIPHER_ENCRYPT);
	cipher_crypt(&ciphercontext, cp,
	    buffer_ptr(&buffer), buffer_len(&buffer));
	cipher_cleanup(&ciphercontext);
d150 1
a150 1
		    strerror(errno));
d170 2
a171 2
	u_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;
	const EVP_CIPHER *cipher = (len > 0) ? EVP_des_ede3_cbc() : NULL;
d242 1
a242 1
	cp = buffer_append_space(&buffer, len);
d316 1
a316 1
	u_char *cp;
d319 2
d327 1
a327 1
	cp = buffer_append_space(&buffer, len);
d381 1
a381 1
	cp = buffer_append_space(&decrypted, buffer_len(&buffer));
d384 3
a386 5
	cipher_set_key_string(&ciphercontext, cipher, passphrase,
	    CIPHER_DECRYPT);
	cipher_crypt(&ciphercontext, cp,
	    buffer_ptr(&buffer), buffer_len(&buffer));
	cipher_cleanup(&ciphercontext);
d409 11
a419 1
	rsa_generate_additional_parameters(prv->rsa);
d453 1
a453 1
	    (type == KEY_UNSPEC||type==KEY_RSA)) {
d462 1
a462 1
	    (type == KEY_UNSPEC||type==KEY_DSA)) {
d586 1
a586 1
			switch (*cp) {
@


1.19
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.18 2000/09/05 19:18:47 markus Exp $");
a49 1
#include "cipher.h"
d70 2
a71 2
	CipherContext cipher;
	int cipher_type;
d79 1
a79 1
		cipher_type = SSH_CIPHER_NONE;
d81 3
a83 1
		cipher_type = SSH_AUTHFILE_CIPHER;
d120 1
a120 1
	buffer_put_char(&encrypted, cipher_type);
d132 4
a135 5
	cipher_set_key_string(&cipher, cipher_type, passphrase);
	cipher_encrypt(&cipher, (unsigned char *) cp,
		       (unsigned char *) buffer_ptr(&buffer),
		       buffer_len(&buffer));
	memset(&cipher, 0, sizeof(cipher));
d316 2
a317 1
	CipherContext cipher;
d368 4
a371 4
	if (((cipher_mask1() | SSH_CIPHER_NONE | SSH_AUTHFILE_CIPHER) &
	     (1 << cipher_type)) == 0) {
		debug("Unsupported cipher %.100s used in key file %.200s.",
		      cipher_name(cipher_type), filename);
d380 4
a383 5
	cipher_set_key_string(&cipher, cipher_type, passphrase);
	cipher_decrypt(&cipher, (unsigned char *) cp,
		       (unsigned char *) buffer_ptr(&buffer),
		       buffer_len(&buffer));

@


1.18
log
@enable ssh-add -d for DSA keys
@
text
@a1 3
 *
 * authfile.c
 *
a2 1
 *
a4 3
 *
 * Created: Mon Mar 27 03:52:05 1995 ylo
 *
d8 28
d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.17 2000/06/20 01:39:38 markus Exp $");
@


1.17
log
@OpenBSD tag
@
text
@d18 1
a18 1
RCSID("$OpenBSD: authfile.c,v 1.16 2000/04/26 21:28:32 markus Exp $");
d265 1
d494 54
@


1.16
log
@split auth/sshconnect in one file per protocol version
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.3 2000/04/17 09:13:21 markus Exp $");
@


1.16.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d18 1
a18 1
RCSID("$OpenBSD: authfile.c,v 1.17 2000/06/20 01:39:38 markus Exp $");
@


1.16.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d2 3
d6 1
d9 3
a14 28
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d18 1
a18 1
RCSID("$OpenBSD: authfile.c,v 1.20 2000/10/11 20:27:23 markus Exp $");
d29 1
d50 2
a51 2
	CipherContext ciphercontext;
	Cipher *cipher;
d59 1
a59 1
		cipher = cipher_by_number(SSH_CIPHER_NONE);
d61 1
a61 3
		cipher = cipher_by_number(SSH_AUTHFILE_CIPHER);
	if (cipher == NULL)
		fatal("save_private_key_rsa: bad cipher");
d98 1
a98 1
	buffer_put_char(&encrypted, cipher->number);
d110 5
a114 4
	cipher_set_key_string(&ciphercontext, cipher, passphrase);
	cipher_encrypt(&ciphercontext, (unsigned char *) cp,
	    (unsigned char *) buffer_ptr(&buffer), buffer_len(&buffer));
	memset(&ciphercontext, 0, sizeof(ciphercontext));
a264 1
/* load public key from private-key file */
d294 1
a294 2
	CipherContext ciphercontext;
	Cipher *cipher;
d345 4
a348 4
	cipher = cipher_by_number(cipher_type);
	if (cipher == NULL) {
		debug("Unsupported cipher %d used in key file %.200s.",
		    cipher_type, filename);
d357 5
a361 4
	cipher_set_key_string(&ciphercontext, cipher, passphrase);
	cipher_decrypt(&ciphercontext, (unsigned char *) cp,
	    (unsigned char *) buffer_ptr(&buffer), buffer_len(&buffer));
	memset(&ciphercontext, 0, sizeof(ciphercontext));
a492 54
}

int
do_load_public_key(const char *filename, Key *k, char **commentp)
{
	FILE *f;
	unsigned int bits;
	char line[1024];
	char *cp;

	f = fopen(filename, "r");
	if (f != NULL) {
		while (fgets(line, sizeof(line), f)) {
			line[sizeof(line)-1] = '\0';
			cp = line;
			switch(*cp){
			case '#':
			case '\n':
			case '\0':
				continue;
			}
			/* Skip leading whitespace. */
			for (; *cp && (*cp == ' ' || *cp == '\t'); cp++)
				;
			if (*cp) {
				bits = key_read(k, &cp);
				if (bits != 0) {
					if (commentp)
						*commentp=xstrdup(filename);
					fclose(f);
					return 1;
				}
			}
		}
		fclose(f);
	}
	return 0;
}

/* load public key from pubkey file */
int
try_load_public_key(const char *filename, Key *k, char **commentp)
{
	char pub[MAXPATHLEN];

	if (do_load_public_key(filename, k, commentp) == 1)
		return 1;
	if (strlcpy(pub, filename, sizeof pub) >= MAXPATHLEN)
		return 0;
	if (strlcat(pub, ".pub", sizeof pub) >= MAXPATHLEN)
		return 0;
	if (do_load_public_key(pub, k, commentp) == 1)
		return 1;
	return 0;
@


1.16.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.27 2001/02/08 19:30:51 itojun Exp $");
d41 4
a44 1
#include <openssl/err.h>
a45 1
#include <openssl/pem.h>
a46 1
#include "cipher.h"
d50 1
a51 3
#include "ssh.h"
#include "log.h"
#include "authfile.h"
d54 1
a54 2
static const char authfile_id_string[] =
    "SSH PRIVATE KEY FILE FORMAT 1.1\n";
d64 1
a64 1
save_private_key_rsa1(const char *filename, const char *passphrase,
d114 3
a116 2
	for (i = 0; authfile_id_string[i]; i++)
		buffer_put_char(&encrypted, authfile_id_string[i]);
d133 2
a134 2
	cipher_encrypt(&ciphercontext, (u_char *) cp,
	    (u_char *) buffer_ptr(&buffer), buffer_len(&buffer));
d150 1
a150 1
		unlink(filename);
d158 2
a159 1
/* save SSH2 key in OpenSSL PEM format */
d161 2
a162 2
save_private_key_ssh2(const char *filename, const char *_passphrase,
    Key *key, const char *comment)
d166 2
a167 4
	int success = 0;
	int len = strlen(_passphrase);
	char *passphrase = (len > 0) ? (char *)_passphrase : NULL;
	EVP_CIPHER *cipher = (len > 0) ? EVP_des_ede3_cbc() : NULL;
d185 8
a192 9
	switch (key->type) {
		case KEY_DSA:
			success = PEM_write_DSAPrivateKey(fp, key->dsa,
			    cipher, passphrase, len, NULL, NULL);
			break;
		case KEY_RSA:
			success = PEM_write_RSAPrivateKey(fp, key->rsa,
			    cipher, passphrase, len, NULL, NULL);
			break;
d203 2
a204 2
	case KEY_RSA1:
		return save_private_key_rsa1(filename, passphrase, key->rsa, comment);
d207 1
a207 2
	case KEY_RSA:
		return save_private_key_ssh2(filename, passphrase, key, comment);
d247 3
a249 3
	/* Check that it is at least big enough to contain the ID string. */
	if (len < sizeof(authfile_id_string)) {
		debug3("Bad RSA1 key file %.200s.", filename);
d257 3
a259 3
	for (i = 0; i < sizeof(authfile_id_string); i++)
		if (buffer_get_char(&buffer) != authfile_id_string[i]) {
			debug3("Bad RSA1 key file %.200s.", filename);
d291 1
a291 1
	case KEY_RSA1:
a294 1
	case KEY_RSA:
d309 1
a309 1
load_private_key_rsa1(int fd, const char *filename,
d329 1
a329 1
		    strerror(errno));
d336 3
a338 3
	/* Check that it is at least big enough to contain the ID string. */
	if (len < sizeof(authfile_id_string)) {
		debug3("Bad RSA1 key file %.200s.", filename);
d346 3
a348 3
	for (i = 0; i < sizeof(authfile_id_string); i++)
		if (buffer_get_char(&buffer) != authfile_id_string[i]) {
			debug3("Bad RSA1 key file %.200s.", filename);
d381 2
a382 2
	cipher_decrypt(&ciphercontext, (u_char *) cp,
	    (u_char *) buffer_ptr(&buffer), buffer_len(&buffer));
d434 1
a434 1
load_private_key_ssh2(int fd, const char *passphrase, Key *k, char **comment_return)
d436 2
a438 3
	int success = 0;
	EVP_PKEY *pk = NULL;
	char *name = "<no key>";
d440 5
d450 5
a454 18
	pk = PEM_read_PrivateKey(fp, NULL, NULL, (char *)passphrase);
	if (pk == NULL) {
		debug("PEM_read_PrivateKey failed");
		(void)ERR_get_error();
	} else if (pk->type == EVP_PKEY_RSA) {
		/* replace k->rsa with loaded key */
		if (k->type == KEY_RSA || k->type == KEY_UNSPEC) {
			if (k->rsa != NULL)
				RSA_free(k->rsa);
			k->rsa = EVP_PKEY_get1_RSA(pk);
			k->type = KEY_RSA;
			name = "rsa w/o comment";
			success = 1;
#ifdef DEBUG_PK
			RSA_print_fp(stderr, k->rsa, 8);
#endif
		}
	} else if (pk->type == EVP_PKEY_DSA) {
d456 2
a457 14
		if (k->type == KEY_DSA || k->type == KEY_UNSPEC) {
			if (k->dsa != NULL)
				DSA_free(k->dsa);
			k->dsa = EVP_PKEY_get1_DSA(pk);
			k->type = KEY_DSA;
			name = "dsa w/o comment";
#ifdef DEBUG_PK
			DSA_print_fp(stderr, k->dsa, 8);
#endif
			success = 1;
		}
	} else {
		error("PEM_read_PrivateKey: mismatch or "
		    "unknown EVP_PKEY save_type %d", pk->save_type);
d459 1
d461 7
a467 6
	if (pk != NULL)
		EVP_PKEY_free(pk);
	if (success && comment_return)
		*comment_return = xstrdup(name);
	debug("read SSH2 private key done: name %s success %d", name, success);
	return success;
d484 1
a484 1
	    (st.st_uid != 0 && getuid() != 0 && st.st_uid != getuid()) ||
d496 1
a496 1
	case KEY_RSA1:
d505 1
a505 1
		ret = load_private_key_rsa1(fd, filename, passphrase,
d509 1
a509 3
	case KEY_RSA:
	case KEY_UNSPEC:
		ret = load_private_key_ssh2(fd, passphrase, key, comment_return);
d521 1
d540 2
a541 1
				if (key_read(k, &cp) == 1) {
@


1.16.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d39 1
a39 1
RCSID("$OpenBSD: authfile.c,v 1.28 2001/02/21 09:05:54 deraadt Exp $");
d339 1
a344 1
		close(fd);
a354 1
			close(fd);
a356 1

a405 1
		close(fd);
d434 1
a434 1
	close(fd);
a448 1
		close(fd);
d515 1
a515 1
		    st.st_mode & 0777, filename);
d530 1
a530 2
		    key->rsa, comment_return);		/* closes fd */

d535 1
a535 3
		ret = load_private_key_ssh2(fd, passphrase, key,
		    comment_return);			/* closes fd */
		break;
a536 1
		close(fd);
d539 1
@


1.15
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@@


1.14
log
@whitespace cleanup
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.13 2000/04/12 09:39:10 markus Exp $");
d21 5
d31 1
d44 2
a45 2
save_private_key(const char *filename, const char *passphrase,
		 RSA *key, const char *comment)
d137 57
d201 1
a201 2
load_public_key(const char *filename, RSA * pub,
		char **comment_return)
d219 1
a219 1
		      strerror(errno));
d248 3
a250 1
	pub->n = BN_new();
d252 3
a254 1
	pub->e = BN_new();
d265 14
d287 2
a288 2
load_private_key(const char *filename, const char *passphrase,
		 RSA * prv, char **comment_return)
d290 1
a290 1
	int fd, i, check1, check2, cipher_type;
a296 5
	struct stat st;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return 0;
a297 13
	/* check owner and modes */
	if (fstat(fd, &st) < 0 ||
	    (st.st_uid != 0 && st.st_uid != getuid()) ||
	    (st.st_mode & 077) != 0) {
		close(fd);
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@");
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("Bad ownership or mode(0%3.3o) for '%s'.",
		      st.st_mode & 0777, filename);
		error("It is recommended that your private key files are NOT accessible by others.");
		return 0;
	}
d374 1
d376 1
d409 84
@


1.13
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d2 1
a2 1
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * 
d9 1
a9 1
 * 
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
RCSID("$Id: authfile.c,v 1.12 2000/04/04 21:37:27 markus Exp $");
@


1.12
log
@remove unused argument, split cipher_mask()
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.11 1999/12/06 19:11:15 deraadt Exp $");
d20 1
a20 1
#include <ssl/bn.h>
@


1.11
log
@properly name fd variable
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.10 1999/11/24 19:53:44 markus Exp $");
d104 1
a104 1
	cipher_set_key_string(&cipher, cipher_type, passphrase, 1);
d283 1
a283 1
	if (((cipher_mask() | SSH_CIPHER_NONE | SSH_AUTHFILE_CIPHER) &
d295 1
a295 1
	cipher_set_key_string(&cipher, cipher_type, passphrase, 0);
@


1.10
log
@KNF, final part 3
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.9 1999/11/24 00:26:00 deraadt Exp $");
d43 1
a43 1
	int f, i;
d114 2
a115 2
	f = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (f < 0)
d117 1
a117 1
	if (write(f, buffer_ptr(&encrypted), buffer_len(&encrypted)) !=
d122 1
a122 1
		close(f);
d126 1
a126 1
	close(f);
d141 1
a141 1
	int f, i;
d146 2
a147 2
	f = open(filename, O_RDONLY);
	if (f < 0)
d149 2
a150 2
	len = lseek(f, (off_t) 0, SEEK_END);
	lseek(f, (off_t) 0, SEEK_SET);
d155 1
a155 1
	if (read(f, cp, (size_t) len) != (size_t) len) {
d159 1
a159 1
		close(f);
d162 1
a162 1
	close(f);
d175 1
a175 1
		if (buffer_get_char(&buffer) != (unsigned char) AUTHFILE_ID_STRING[i]) {
d210 1
a210 1
	int f, i, check1, check2, cipher_type;
d219 2
a220 2
	f = open(filename, O_RDONLY);
	if (f < 0)
d224 1
a224 1
	if (fstat(f, &st) < 0 ||
d227 1
d236 2
a237 2
	len = lseek(f, (off_t) 0, SEEK_END);
	lseek(f, (off_t) 0, SEEK_SET);
d242 1
a242 1
	if (read(f, cp, (size_t) len) != (size_t) len) {
d246 1
a246 1
		close(f);
d249 1
a249 1
	close(f);
@


1.9
log
@much more KNF
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.8 1999/11/23 22:25:52 markus Exp $");
d30 6
a35 4
/* Saves the authentication (private) key in a file, encrypting it with
   passphrase.  The identification of the file (lowest 64 bits of n)
   will precede the key to provide identification of the key without
   needing a passphrase. */
d48 4
a51 3
	/* If the passphrase is empty, use SSH_CIPHER_NONE to ease
	   converting to another cipher; otherwise use
	   SSH_AUTHFILE_CIPHER. */
d68 5
a72 3
	/* Store the private key (n and e will not be stored because they
	   will be stored in plain text, and storing them also in
	   encrypted format would just give known plaintext). */
a113 1
	/* Write to a file. */
a116 1

d131 5
a135 3
/* Loads the public part of the key file.  Returns 0 if an error
   was encountered (the file does not exist or is not readable), and
   non-zero otherwise. */
a145 1
	/* Read data from the file into the buffer. */
a148 1

d170 4
a173 2
	/* Make sure it begins with the id string.  Consume the id string
	   from the buffer. */
d199 6
a204 3
/* Loads the private key from the file.  Returns 0 if an error is encountered
   (file does not exist or is not readable, or passphrase is bad).
   This initializes the private key. */
a218 1
	/* Read the file into the buffer. */
d223 1
a223 1
	/* We assume we are called under uid of the owner of the file */
d256 4
a259 2
	/* Make sure it begins with the id string.  Consume the id string
	   from the buffer. */
@


1.8
log
@KNF part 1
@
text
@d2 14
a15 14

authfile.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Mon Mar 27 03:52:05 1995 ylo

This file contains functions for reading and writing identity files, and
for reading the passphrase from the user.

*/
d18 1
a18 1
RCSID("$Id: authfile.c,v 1.7 1999/10/11 20:00:35 markus Exp $");
@


1.7
log
@make sure ~/.ssh/authorized_keys is not writable for group/world (sshd)
don't load private keys if they are group/world-{rwx} (ssh,sshd and ssh-add)
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.6 1999/09/30 18:28:35 provos Exp $");
d39 87
a125 87
  Buffer buffer, encrypted;
  char buf[100], *cp;
  int f, i;
  CipherContext cipher;
  int cipher_type;
  u_int32_t rand;

  /* If the passphrase is empty, use SSH_CIPHER_NONE to ease converting to
     another cipher; otherwise use SSH_AUTHFILE_CIPHER. */
  if (strcmp(passphrase, "") == 0)
    cipher_type = SSH_CIPHER_NONE;
  else
    cipher_type = SSH_AUTHFILE_CIPHER;

  /* This buffer is used to built the secret part of the private key. */
  buffer_init(&buffer);
  
  /* Put checkbytes for checking passphrase validity. */
  rand = arc4random();
  buf[0] = rand & 0xff;
  buf[1] = (rand >> 8) & 0xff;
  buf[2] = buf[0];
  buf[3] = buf[1];
  buffer_append(&buffer, buf, 4);

  /* Store the private key (n and e will not be stored because they will
     be stored in plain text, and storing them also in encrypted format
     would just give known plaintext). */
  buffer_put_bignum(&buffer, key->d);
  buffer_put_bignum(&buffer, key->iqmp);
  buffer_put_bignum(&buffer, key->q); /* reverse from SSL p */
  buffer_put_bignum(&buffer, key->p); /* reverse from SSL q */

  /* Pad the part to be encrypted until its size is a multiple of 8. */
  while (buffer_len(&buffer) % 8 != 0)
    buffer_put_char(&buffer, 0);

  /* This buffer will be used to contain the data in the file. */
  buffer_init(&encrypted);

  /* First store keyfile id string. */
  cp = AUTHFILE_ID_STRING;
  for (i = 0; cp[i]; i++)
    buffer_put_char(&encrypted, cp[i]);
  buffer_put_char(&encrypted, 0);

  /* Store cipher type. */
  buffer_put_char(&encrypted, cipher_type);
  buffer_put_int(&encrypted, 0);  /* For future extension */

  /* Store public key.  This will be in plain text. */
  buffer_put_int(&encrypted, BN_num_bits(key->n));
  buffer_put_bignum(&encrypted, key->n);
  buffer_put_bignum(&encrypted, key->e);
  buffer_put_string(&encrypted, comment, strlen(comment));

  /* Allocate space for the private part of the key in the buffer. */
  buffer_append_space(&encrypted, &cp, buffer_len(&buffer));

  cipher_set_key_string(&cipher, cipher_type, passphrase, 1);
  cipher_encrypt(&cipher, (unsigned char *)cp, 
		 (unsigned char *)buffer_ptr(&buffer),
		 buffer_len(&buffer));
  memset(&cipher, 0, sizeof(cipher));

  /* Destroy temporary data. */
  memset(buf, 0, sizeof(buf));
  buffer_free(&buffer);

  /* Write to a file. */
  f = open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0600);
  if (f < 0)
    return 0;

  if (write(f, buffer_ptr(&encrypted), buffer_len(&encrypted)) != 
      buffer_len(&encrypted))
    {
      debug("Write to key file %.200s failed: %.100s", filename,
	    strerror(errno));
      buffer_free(&encrypted);
      close(f);
      remove(filename);
      return 0;
    }
  close(f);
  buffer_free(&encrypted);
  return 1;
d133 1
a133 1
load_public_key(const char *filename, RSA *pub, 
d136 53
a188 40
  int f, i;
  off_t len;
  Buffer buffer;
  char *cp;

  /* Read data from the file into the buffer. */
  f = open(filename, O_RDONLY);
  if (f < 0)
    return 0;

  len = lseek(f, (off_t)0, SEEK_END);
  lseek(f, (off_t)0, SEEK_SET);
  
  buffer_init(&buffer);
  buffer_append_space(&buffer, &cp, len);

  if (read(f, cp, (size_t)len) != (size_t)len)
    {
      debug("Read from key file %.200s failed: %.100s", filename, 
	    strerror(errno));
      buffer_free(&buffer);
      close(f);
      return 0;
    }
  close(f);

  /* Check that it is at least big enought to contain the ID string. */
  if (len < strlen(AUTHFILE_ID_STRING) + 1)
    {
      debug("Bad key file %.200s.", filename);
      buffer_free(&buffer);
      return 0;
    }

  /* Make sure it begins with the id string.  Consume the id string from
     the buffer. */
  for (i = 0; i < (unsigned int)strlen(AUTHFILE_ID_STRING) + 1; i++)
    if (buffer_get_char(&buffer) != (unsigned char)AUTHFILE_ID_STRING[i])
      {
	debug("Bad key file %.200s.", filename);
a189 2
	return 0;
      }
d191 1
a191 17
  /* Skip cipher type and reserved data. */
  (void)buffer_get_char(&buffer); /* cipher type */
  (void)buffer_get_int(&buffer); /* reserved */

  /* Read the public key from the buffer. */
  buffer_get_int(&buffer);
  pub->n = BN_new();
  buffer_get_bignum(&buffer, pub->n);
  pub->e = BN_new();
  buffer_get_bignum(&buffer, pub->e);
  if (comment_return)
    *comment_return = buffer_get_string(&buffer, NULL);
  /* The encrypted private part is not parsed by this function. */

  buffer_free(&buffer);
  
  return 1;
d200 1
a200 1
		 RSA *prv, char **comment_return)
d202 88
a289 57
  int f, i, check1, check2, cipher_type;
  off_t len;
  Buffer buffer, decrypted;
  char *cp;
  CipherContext cipher;
  BN_CTX *ctx;
  BIGNUM *aux;
  struct stat st;

  /* Read the file into the buffer. */
  f = open(filename, O_RDONLY);
  if (f < 0)
    return 0;

  /* We assume we are called under uid of the owner of the file */
  if (fstat(f, &st) < 0 ||
      (st.st_uid != 0 && st.st_uid != getuid()) ||
      (st.st_mode & 077) != 0) {
    error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
    error("@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@");
    error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
    error("Bad ownership or mode(0%3.3o) for '%s'.",
	   st.st_mode & 0777, filename);
    error("It is recommended that your private key files are NOT accessible by others.");
    return 0;
  }

  len = lseek(f, (off_t)0, SEEK_END);
  lseek(f, (off_t)0, SEEK_SET);
  
  buffer_init(&buffer);
  buffer_append_space(&buffer, &cp, len);

  if (read(f, cp, (size_t)len) != (size_t)len)
    {
      debug("Read from key file %.200s failed: %.100s", filename,
	    strerror(errno));
      buffer_free(&buffer);
      close(f);
      return 0;
    }
  close(f);

  /* Check that it is at least big enought to contain the ID string. */
  if (len < strlen(AUTHFILE_ID_STRING) + 1)
    {
      debug("Bad key file %.200s.", filename);
      buffer_free(&buffer);
      return 0;
    }

  /* Make sure it begins with the id string.  Consume the id string from
     the buffer. */
  for (i = 0; i < (unsigned int)strlen(AUTHFILE_ID_STRING) + 1; i++)
    if (buffer_get_char(&buffer) != (unsigned char)AUTHFILE_ID_STRING[i])
      {
	debug("Bad key file %.200s.", filename);
a290 2
	return 0;
      }
d292 41
a332 80
  /* Read cipher type. */
  cipher_type = buffer_get_char(&buffer);
  (void)buffer_get_int(&buffer);  /* Reserved data. */

  /* Read the public key from the buffer. */
  buffer_get_int(&buffer);
  prv->n = BN_new();
  buffer_get_bignum(&buffer, prv->n);
  prv->e = BN_new();
  buffer_get_bignum(&buffer, prv->e);
  if (comment_return)
    *comment_return = buffer_get_string(&buffer, NULL);
  else
    xfree(buffer_get_string(&buffer, NULL));

  /* Check that it is a supported cipher. */
  if (((cipher_mask() | SSH_CIPHER_NONE | SSH_AUTHFILE_CIPHER) &
	(1 << cipher_type)) == 0)
    {
      debug("Unsupported cipher %.100s used in key file %.200s.",
	    cipher_name(cipher_type), filename);
      buffer_free(&buffer);
      goto fail;
    }

  /* Initialize space for decrypted data. */
  buffer_init(&decrypted);
  buffer_append_space(&decrypted, &cp, buffer_len(&buffer));
      
  /* Rest of the buffer is encrypted.  Decrypt it using the passphrase. */
  cipher_set_key_string(&cipher, cipher_type, passphrase, 0);
  cipher_decrypt(&cipher, (unsigned char *)cp,
		 (unsigned char *)buffer_ptr(&buffer),
		 buffer_len(&buffer));

  buffer_free(&buffer);

  check1 = buffer_get_char(&decrypted);
  check2 = buffer_get_char(&decrypted);
  if (check1 != buffer_get_char(&decrypted) ||
      check2 != buffer_get_char(&decrypted))
    {
      if (strcmp(passphrase, "") != 0)
	debug("Bad passphrase supplied for key file %.200s.", filename);
      /* Bad passphrase. */
      buffer_free(&decrypted);
    fail:
      BN_clear_free(prv->n);
      BN_clear_free(prv->e);
      if (comment_return)
	xfree(*comment_return);
      return 0;
    }

  /* Read the rest of the private key. */
  prv->d = BN_new();
  buffer_get_bignum(&decrypted, prv->d);
  prv->iqmp = BN_new();
  buffer_get_bignum(&decrypted, prv->iqmp); /* u */
  /* in SSL and SSH p and q are exchanged */
  prv->q = BN_new();
  buffer_get_bignum(&decrypted, prv->q); /* p */
  prv->p = BN_new();
  buffer_get_bignum(&decrypted, prv->p); /* q */

  ctx = BN_CTX_new();
  aux = BN_new();

  BN_sub(aux, prv->q, BN_value_one());
  prv->dmq1 = BN_new();
  BN_mod(prv->dmq1, prv->d, aux, ctx);

  BN_sub(aux, prv->p, BN_value_one());
  prv->dmp1 = BN_new();
  BN_mod(prv->dmp1, prv->d, aux, ctx);

  BN_clear_free(aux);
  BN_CTX_free(ctx);
  
  buffer_free(&decrypted);
d334 1
a334 1
  return 1;
@


1.6
log
@better way to deal with authfile cipher; dugsong@@
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.5 1999/09/30 16:55:06 deraadt Exp $");
d214 1
d220 13
@


1.5
log
@off_t, but needs more looking at later
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.4 1999/09/30 16:34:21 provos Exp $");
d270 2
a271 2
  if (cipher_type != SSH_CIPHER_NONE && 
     (cipher_mask() & (1 << cipher_type)) == 0)
@


1.4
log
@we have to enable SSH_CIPHER_NONE for unprotected host keys, etc...
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.3 1999/09/28 04:45:35 provos Exp $");
d137 1
a137 1
  unsigned long len;
d146 2
a147 2
  len = lseek(f, (off_t)0L, 2);
  lseek(f, (off_t)0L, 0);
d152 1
a152 1
  if (read(f, cp, len) != len)
d208 1
a208 1
  unsigned long len;
d220 2
a221 2
  len = lseek(f, (off_t)0L, 2);
  lseek(f, (off_t)0L, 0);
d226 1
a226 1
  if (read(f, cp, len) != len)
@


1.3
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.2 1999/05/04 11:58:28 bg Exp $");
d270 2
a271 1
  if ((cipher_mask() & (1 << cipher_type)) == 0)
@


1.2
log
@all the idea code goes away
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.1 1999/09/26 20:53:33 deraadt Exp $");
d20 1
a20 1
#include <gmp.h>
d35 3
a37 3
int save_private_key(const char *filename, const char *passphrase,
		     RSAPrivateKey *key, const char *comment, 
		     RandomState *state)
d44 1
d57 3
a59 2
  buf[0] = random_get_byte(state);
  buf[1] = random_get_byte(state);
d67 4
a70 4
  buffer_put_mp_int(&buffer, &key->d);
  buffer_put_mp_int(&buffer, &key->u);
  buffer_put_mp_int(&buffer, &key->p);
  buffer_put_mp_int(&buffer, &key->q);
d90 3
a92 3
  buffer_put_int(&encrypted, key->bits);
  buffer_put_mp_int(&encrypted, &key->n);
  buffer_put_mp_int(&encrypted, &key->e);
d132 3
a134 2
int load_public_key(const char *filename, RSAPublicKey *pub, 
		    char **comment_return)
d185 5
a189 5
  pub->bits = buffer_get_int(&buffer);
  mpz_init(&pub->n);
  buffer_get_mp_int(&buffer, &pub->n);
  mpz_init(&pub->e);
  buffer_get_mp_int(&buffer, &pub->e);
d203 3
a205 2
int load_private_key(const char *filename, const char *passphrase,
		     RSAPrivateKey *prv, char **comment_return)
d212 2
d259 5
a263 5
  prv->bits = buffer_get_int(&buffer);
  mpz_init(&prv->n);
  buffer_get_mp_int(&buffer, &prv->n);
  mpz_init(&prv->e);
  buffer_get_mp_int(&buffer, &prv->e);
d300 2
a301 2
      mpz_clear(&prv->n);
      mpz_clear(&prv->e);
d308 23
a330 8
  mpz_init(&prv->d);
  buffer_get_mp_int(&decrypted, &prv->d);
  mpz_init(&prv->u);
  buffer_get_mp_int(&decrypted, &prv->u);
  mpz_init(&prv->p);
  buffer_get_mp_int(&decrypted, &prv->p);
  mpz_init(&prv->q);
  buffer_get_mp_int(&decrypted, &prv->q);
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d18 1
a18 1
RCSID("$Id: authfile.c,v 1.2 1999/05/04 11:58:28 bg Exp $");
a21 1
#include "idea.h"
@

