head	1.131;
access;
symbols
	OPENBSD_6_2_BASE:1.131
	OPENBSD_6_1:1.130.0.6
	OPENBSD_6_1_BASE:1.130
	OPENBSD_6_0:1.130.0.4
	OPENBSD_6_0_BASE:1.130
	OPENBSD_5_9:1.129.0.2
	OPENBSD_5_9_BASE:1.129
	OPENBSD_5_8:1.128.0.2
	OPENBSD_5_8_BASE:1.128
	OPENBSD_5_7:1.127.0.2
	OPENBSD_5_7_BASE:1.127
	OPENBSD_5_6:1.122.0.4
	OPENBSD_5_6_BASE:1.122
	OPENBSD_5_5:1.116.0.4
	OPENBSD_5_5_BASE:1.116
	OPENBSD_5_4:1.104.0.2
	OPENBSD_5_4_BASE:1.104
	OPENBSD_5_3:1.100.0.2
	OPENBSD_5_3_BASE:1.100
	OPENBSD_5_2:1.99.0.2
	OPENBSD_5_2_BASE:1.99
	OPENBSD_5_1_BASE:1.98
	OPENBSD_5_1:1.98.0.2
	OPENBSD_5_0:1.97.0.2
	OPENBSD_5_0_BASE:1.97
	OPENBSD_4_9:1.96.0.2
	OPENBSD_4_9_BASE:1.96
	OPENBSD_4_8:1.90.0.2
	OPENBSD_4_8_BASE:1.90
	OPENBSD_4_7:1.86.0.2
	OPENBSD_4_7_BASE:1.86
	OPENBSD_4_6:1.80.0.6
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.80.0.2
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.79.0.2
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.69.0.4
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.69.0.2
	OPENBSD_4_2_BASE:1.69
	OPENBSD_4_1:1.68.0.2
	OPENBSD_4_1_BASE:1.68
	OPENBSD_4_0:1.67.0.4
	OPENBSD_4_0_BASE:1.67
	OPENBSD_3_9:1.58.0.4
	OPENBSD_3_9_BASE:1.58
	OPENBSD_3_8:1.58.0.2
	OPENBSD_3_8_BASE:1.58
	OPENBSD_3_7:1.57.0.2
	OPENBSD_3_7_BASE:1.57
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.54.0.2
	OPENBSD_3_4_BASE:1.54
	OPENBSD_3_3:1.51.0.2
	OPENBSD_3_3_BASE:1.51
	OPENBSD_3_2:1.49.0.2
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.43.0.2
	OPENBSD_3_1_BASE:1.43
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.131
date	2017.05.30.14.16.41;	author markus;	state Exp;
branches;
next	1.130;
commitid	qvTM0EqWXxMps7F0;

1.130
date	2016.05.02.09.36.42;	author djm;	state Exp;
branches;
next	1.129;
commitid	g1pzvVA0Azqu3umf;

1.129
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.128;
commitid	K3glY441IowbrjDE;

1.128
date	2015.07.03.03.43.18;	author djm;	state Exp;
branches;
next	1.127;
commitid	cnvu1kGgoFFYv6D3;

1.127
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.126;
commitid	P7KG9D8zB61mMUPV;

1.126
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.125;
commitid	cBx23BaCk6gYBpRj;

1.125
date	2015.01.08.10.14.08;	author djm;	state Exp;
branches;
next	1.124;
commitid	397Wklb10N5bP6VW;

1.124
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.123;
commitid	EbtriidyZdsmXksl;

1.123
date	2014.12.04.20.47.36;	author djm;	state Exp;
branches;
next	1.122;
commitid	IKArE6kTGiisPPIV;

1.122
date	2014.07.22.01.18.50;	author dtucker;	state Exp;
branches;
next	1.121;
commitid	eYucfHrXS1D39Agt;

1.121
date	2014.07.17.00.12.03;	author djm;	state Exp;
branches;
next	1.120;
commitid	S8gigLkjibDDDunX;

1.120
date	2014.07.09.03.02.15;	author djm;	state Exp;
branches;
next	1.119;
commitid	N2bxHrluxoXQ8NHn;

1.119
date	2014.06.30.12.54.39;	author djm;	state Exp;
branches;
next	1.118;
commitid	iQMDEWkghE5BfuOA;

1.118
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.117;
commitid	1h9UxAQmwdaqUzyX;

1.117
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.115;

1.115
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.114;

1.114
date	2013.12.29.04.20.04;	author djm;	state Exp;
branches;
next	1.113;

1.113
date	2013.12.29.02.49.52;	author djm;	state Exp;
branches;
next	1.112;

1.112
date	2013.12.29.02.37.04;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2013.12.29.02.28.10;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2013.12.07.00.19.15;	author djm;	state Exp;
branches;
next	1.109;

1.109
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2013.12.06.13.34.54;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2013.12.06.13.30.08;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2013.12.02.03.09.22;	author djm;	state Exp;
branches;
next	1.105;

1.105
date	2013.10.29.09.42.11;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2013.05.19.02.42.42;	author djm;	state Exp;
branches;
next	1.103;

1.103
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.102;

1.102
date	2013.05.10.04.08.01;	author djm;	state Exp;
branches;
next	1.101;

1.101
date	2013.04.19.01.06.50;	author djm;	state Exp;
branches;
next	1.100;

1.100
date	2013.01.17.23.00.01;	author djm;	state Exp;
branches;
next	1.99;

1.99
date	2012.05.23.03.28.28;	author djm;	state Exp;
branches;
next	1.98;

1.98
date	2011.10.18.04.58.26;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2011.05.17.07.13.31;	author djm;	state Exp;
branches;
next	1.96;

1.96
date	2011.02.04.00.44.21;	author djm;	state Exp;
branches;
next	1.95;

1.95
date	2010.11.10.01.33.07;	author djm;	state Exp;
branches;
next	1.94;

1.94
date	2010.10.28.11.22.09;	author djm;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.09.10.45.45;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.13.23.13.16;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2010.07.13.11.52.06;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.07.11.30.29;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2010.03.15.19.40.02;	author stevesk;	state Exp;
branches;
next	1.85;

1.85
date	2010.03.04.01.44.57;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2010.03.03.01.44.36;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.13.01.10.56;	author dtucker;	state Exp;
branches;
next	1.81;

1.81
date	2009.12.11.18.16.33;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2008.10.10.05.00.12;	author stevesk;	state Exp;
branches;
next	1.79;

1.79
date	2008.07.25.07.05.16;	author grunk;	state Exp;
branches;
next	1.78;

1.78
date	2008.07.07.23.32.51;	author stevesk;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.25.11.13.43;	author otto;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.12.22.03.36;	author grunk;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.12.06.32.59;	author grunk;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.12.05.42.46;	author grunk;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.12.00.13.13;	author otto;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.11.23.51.57;	author grunk;	state Exp;
branches;
next	1.71;

1.71
date	2008.06.11.23.02.22;	author otto;	state Exp;
branches;
next	1.70;

1.70
date	2008.06.11.21.01.35;	author grunk;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.12.05.48.05;	author ray;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.67.4.1;
next	1.66;

1.66
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.20.17.13.16;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.20.17.10.19;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.20.11.38.46;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.58.2.1
	1.58.4.1;
next	1.57;

1.57
date	2004.10.29.23.57.05;	author djm;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2004.07.28.09.40.29;	author markus;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2003.07.09.13.58.19;	author avsm;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.14.18.16.20;	author jakob;	state Exp;
branches;
next	1.51;

1.51
date	2003.02.12.09.33.04;	author markus;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2003.02.04.09.32.08;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.09.14.54.14;	author markus;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2002.07.04.10.41.47;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.04.04.15.33;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.30.21.59.45;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.23.03.26.19;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.31.13.16.48;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2002.03.18.17.23.31;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.28.15.46.33;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2002.01.25.22.07.40;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.25.18.49.56;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.21.15.51.24;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.04.14.34.16;	author markus;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2001.09.19.13.23.29;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.17.20.50.22;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.17.19.27.15;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.26.20.14.10;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.25.08.25.37;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.23.05.26.02;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.17.10.53.24;	author markus;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.04.16.08.26.04;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.05.10.42.50;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.12.22.02.01;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.11.18.29.51;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.11.15.13.09;	author jakob;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.11.15.03.15;	author jakob;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.11.13.25.36;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.04.15.32.24;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.22.16.55.21;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.21.19.05.50;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.16.19.20.06;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.19.23.17.56;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.12.19.50.37;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.07.20.27.51;	author deraadt;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.08.19.21.34.43;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.22.23.55.00;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.19.03.29.49;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.24.18.26.47;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.05.18.53.42;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.05.04.22.38.00;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.04.09.50.22;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.20.56.29;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.23.22.15.33;	author markus;	state Exp;
branches;
next	;

1.6.2.1
date	2000.06.12.02.37.34;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.09.01.18.23.20;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2000.11.08.21.30.51;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.12.15.44.11;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.03.21.18.52.47;	author jason;	state Exp;
branches;
next	;

1.11.2.1
date	2001.02.16.20.13.04;	author jason;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.02.19.17.19.00;	author jason;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.03.21.19.46.25;	author jason;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2001.05.07.21.09.30;	author jason;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.25.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.33.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.33.2.4;

1.33.2.4
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	1.33.2.5;

1.33.2.5
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.43.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.49.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.51.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.54.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.55.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.56.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.57.2.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	;

1.58.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.58.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.58.4.2;

1.58.4.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.67.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.131
log
@remove unused wrapper functions from key.[ch]; ok djm@@
@
text
@/* $OpenBSD: key.c,v 1.130 2016/05/02 09:36:42 djm Exp $ */
/*
 * placed in the public domain
 */

#include <sys/types.h>
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <limits.h>

#define SSH_KEY_NO_DEFINE
#include "key.h"

#include "compat.h"
#include "sshkey.h"
#include "ssherr.h"
#include "log.h"
#include "authfile.h"

static void
fatal_on_fatal_errors(int r, const char *func, int extra_fatal)
{
	if (r == SSH_ERR_INTERNAL_ERROR ||
	    r == SSH_ERR_ALLOC_FAIL ||
	    (extra_fatal != 0 && r == extra_fatal))
		fatal("%s: %s", func, ssh_err(r));
}

Key *
key_from_blob(const u_char *blob, u_int blen)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_from_blob(blob, blen, &ret)) != 0) {
		fatal_on_fatal_errors(r, __func__, 0);
		error("%s: %s", __func__, ssh_err(r));
		return NULL;
	}
	return ret;
}

int
key_to_blob(const Key *key, u_char **blobp, u_int *lenp)
{
	u_char *blob;
	size_t blen;
	int r;

	if (blobp != NULL)
		*blobp = NULL;
	if (lenp != NULL)
		*lenp = 0;
	if ((r = sshkey_to_blob(key, &blob, &blen)) != 0) {
		fatal_on_fatal_errors(r, __func__, 0);
		error("%s: %s", __func__, ssh_err(r));
		return 0;
	}
	if (blen > INT_MAX)
		fatal("%s: giant len %zu", __func__, blen);
	if (blobp != NULL)
		*blobp = blob;
	if (lenp != NULL)
		*lenp = blen;
	return blen;
}

int
key_sign(const Key *key, u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen, const char *alg)
{
	int r;
	u_char *sig;
	size_t siglen;

	if (sigp != NULL)
		*sigp = NULL;
	if (lenp != NULL)
		*lenp = 0;
	if ((r = sshkey_sign(key, &sig, &siglen,
	    data, datalen, alg, datafellows)) != 0) {
		fatal_on_fatal_errors(r, __func__, 0);
		error("%s: %s", __func__, ssh_err(r));
		return -1;
	}
	if (siglen > INT_MAX)
		fatal("%s: giant len %zu", __func__, siglen);
	if (sigp != NULL)
		*sigp = sig;
	if (lenp != NULL)
		*lenp = siglen;
	return 0;
}

int
key_verify(const Key *key, const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
{
	int r;

	if ((r = sshkey_verify(key, signature, signaturelen,
	    data, datalen, datafellows)) != 0) {
		fatal_on_fatal_errors(r, __func__, 0);
		error("%s: %s", __func__, ssh_err(r));
		return r == SSH_ERR_SIGNATURE_INVALID ? 0 : -1;
	}
	return 1;
}

Key *
key_demote(const Key *k)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_demote(k, &ret)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
	return ret;
}

int
key_drop_cert(Key *k)
{
	int r;

	if ((r = sshkey_drop_cert(k)) != 0) {
		fatal_on_fatal_errors(r, __func__, 0);
		error("%s: %s", __func__, ssh_err(r));
		return -1;
	}
	return 0;
}

int
key_cert_check_authority(const Key *k, int want_host, int require_principal,
    const char *name, const char **reason)
{
	int r;

	if ((r = sshkey_cert_check_authority(k, want_host, require_principal,
	    name, reason)) != 0) {
		fatal_on_fatal_errors(r, __func__, 0);
		error("%s: %s", __func__, ssh_err(r));
		return -1;
	}
	return 0;
}

/* authfile.c */

Key *
key_load_cert(const char *filename)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_load_cert(filename, &ret)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		/* Old authfile.c ignored all file errors. */
		if (r == SSH_ERR_SYSTEM_ERROR)
			debug("%s: %s", __func__, ssh_err(r));
		else
			error("%s: %s", __func__, ssh_err(r));
		return NULL;
	}
	return ret;

}

Key *
key_load_public(const char *filename, char **commentp)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_load_public(filename, &ret, commentp)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		/* Old authfile.c ignored all file errors. */
		if (r == SSH_ERR_SYSTEM_ERROR)
			debug("%s: %s", __func__, ssh_err(r));
		else
			error("%s: %s", __func__, ssh_err(r));
		return NULL;
	}
	return ret;
}

Key *
key_load_private(const char *path, const char *passphrase,
    char **commentp)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_load_private(path, passphrase, &ret, commentp)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		/* Old authfile.c ignored all file errors. */
		if (r == SSH_ERR_SYSTEM_ERROR ||
		    r == SSH_ERR_KEY_WRONG_PASSPHRASE)
			debug("%s: %s", __func__, ssh_err(r));
		else
			error("%s: %s", __func__, ssh_err(r));
		return NULL;
	}
	return ret;
}

Key *
key_load_private_cert(int type, const char *filename, const char *passphrase,
    int *perm_ok)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_load_private_cert(type, filename, passphrase,
	    &ret, perm_ok)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		/* Old authfile.c ignored all file errors. */
		if (r == SSH_ERR_SYSTEM_ERROR ||
		    r == SSH_ERR_KEY_WRONG_PASSPHRASE)
			debug("%s: %s", __func__, ssh_err(r));
		else
			error("%s: %s", __func__, ssh_err(r));
		return NULL;
	}
	return ret;
}

Key *
key_load_private_type(int type, const char *filename, const char *passphrase,
    char **commentp, int *perm_ok)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_load_private_type(type, filename, passphrase,
	    &ret, commentp, perm_ok)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		/* Old authfile.c ignored all file errors. */
		if (r == SSH_ERR_SYSTEM_ERROR ||
		    (r == SSH_ERR_KEY_WRONG_PASSPHRASE))
			debug("%s: %s", __func__, ssh_err(r));
		else
			error("%s: %s", __func__, ssh_err(r));
		return NULL;
	}
	return ret;
}
@


1.130
log
@support SHA256 and SHA512 RSA signatures in certificates;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.129 2015/12/04 16:41:28 markus Exp $ */
a20 62
void
key_add_private(Key *k)
{
	int r;

	if ((r = sshkey_add_private(k)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
}

Key *
key_new_private(int type)
{
	Key *ret = NULL;

	if ((ret = sshkey_new_private(type)) == NULL)
		fatal("%s: failed", __func__);
	return ret;
}

int
key_read(Key *ret, char **cpp)
{
	return sshkey_read(ret, cpp) == 0 ? 1 : -1;
}

int
key_write(const Key *key, FILE *f)
{
	return sshkey_write(key, f) == 0 ? 1 : 0;
}

Key *
key_generate(int type, u_int bits)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_generate(type, bits, &ret)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
	return ret;
}

void
key_cert_copy(const Key *from_key, Key *to_key)
{
	int r;

	if ((r = sshkey_cert_copy(from_key, to_key)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
}

Key *
key_from_private(const Key *k)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_from_private(k, &ret)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
	return ret;
}

a122 13
key_to_certified(Key *k)
{
	int r;

	if ((r = sshkey_to_certified(k)) != 0) {
		fatal_on_fatal_errors(r, __func__, 0);
		error("%s: %s", __func__, ssh_err(r));
		return -1;
	}
	return 0;
}

int
a135 13
key_certify(Key *k, Key *ca)
{
	int r;

	if ((r = sshkey_certify(k, ca, NULL)) != 0) {
		fatal_on_fatal_errors(r, __func__, 0);
		error("%s: %s", __func__, ssh_err(r));
		return -1;
	}
	return 0;
}

int
a149 51
#ifdef WITH_OPENSSL
int
key_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)
{
	int r;

	if ((r = sshkey_ec_validate_public(group, public)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		error("%s: %s", __func__, ssh_err(r));
		return -1;
	}
	return 0;
}

int
key_ec_validate_private(const EC_KEY *key)
{
	int r;

	if ((r = sshkey_ec_validate_private(key)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		error("%s: %s", __func__, ssh_err(r));
		return -1;
	}
	return 0;
}
#endif /* WITH_OPENSSL */

void
key_private_serialize(const Key *key, struct sshbuf *b)
{
	int r;

	if ((r = sshkey_private_serialize(key, b)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
}

Key *
key_private_deserialize(struct sshbuf *blob)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_private_deserialize(blob, &ret)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		error("%s: %s", __func__, ssh_err(r));
		return NULL;
	}
	return ret;
}

a151 29
int
key_save_private(Key *key, const char *filename, const char *passphrase,
    const char *comment, int force_new_format, const char *new_format_cipher,
    int new_format_rounds)
{
	int r;

	if ((r = sshkey_save_private(key, filename, passphrase, comment,
	    force_new_format, new_format_cipher, new_format_rounds)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		error("%s: %s", __func__, ssh_err(r));
		return 0;
	}
	return 1;
}

int
key_load_file(int fd, const char *filename, struct sshbuf *blob)
{
	int r;

	if ((r = sshkey_load_file(fd, blob)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		error("%s: %s", __func__, ssh_err(r));
		return 0;
	}
	return 1;
}

a249 7

int
key_perm_ok(int fd, const char *filename)
{
	return sshkey_perm_ok(fd, filename) == 0 ? 1 : 0;
}

@


1.129
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.128 2015/07/03 03:43:18 djm Exp $ */
d215 1
a215 1
	if ((r = sshkey_certify(k, ca)) != 0) {
@


1.128
log
@delete support for legacy v00 certificates; "sure" markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.127 2015/01/28 22:36:00 djm Exp $ */
d133 1
a133 1
    const u_char *data, u_int datalen)
d144 1
a144 1
	    data, datalen, datafellows)) != 0) {
@


1.127
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.126 2015/01/20 23:14:00 deraadt Exp $ */
d185 1
a185 1
key_to_certified(Key *k, int legacy)
d189 1
a189 1
	if ((r = sshkey_to_certified(k, legacy)) != 0) {
@


1.126
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.125 2015/01/08 10:14:08 djm Exp $ */
a36 17
	return ret;
}

u_char*
key_fingerprint_raw(const Key *k, int dgst_alg, u_int *dgst_raw_length)
{
	u_char *ret = NULL;
	size_t dlen;
	int r;

	if (dgst_raw_length != NULL)
		*dgst_raw_length = 0;
	if ((r = sshkey_fingerprint_raw(k, dgst_alg, &ret, &dlen)) != 0)
		fatal("%s: %s", __func__, ssh_err(r));
	if (dlen > INT_MAX)
		fatal("%s: giant len %zu", __func__, dlen);
	*dgst_raw_length = dlen;
@


1.125
log
@deprecate key_load_private_pem() and sshkey_load_private_pem()
interfaces. Refactor the generic key loading API to not require
pathnames to be specified (they weren't really used).

Fixes a few other things en passant:

Makes ed25519 keys work for hostbased authentication (ssh-keysign
previously used the PEM-only routines).

Fixes key comment regression bz#2306: key pathnames were being lost as
comment fields.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.124 2014/12/21 22:27:56 djm Exp $ */
a5 1
#include <sys/param.h>
d10 1
@


1.124
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.123 2014/12/04 20:47:36 djm Exp $ */
d329 1
a329 1
	if ((r = sshkey_load_file(fd, filename, blob)) != 0) {
a434 21

#ifdef WITH_OPENSSL
Key *
key_load_private_pem(int fd, int type, const char *passphrase,
    char **commentp)
{
	int r;
	Key *ret = NULL;

	if ((r = sshkey_load_private_pem(fd, type, passphrase,
	     &ret, commentp)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		if (r == SSH_ERR_KEY_WRONG_PASSPHRASE)
			debug("%s: %s", __func__, ssh_err(r));
		else
			error("%s: %s", __func__, ssh_err(r));
		return NULL;
	}
	return ret;
}
#endif /* WITH_OPENSSL */
@


1.123
log
@key_in_file() wrapper is no longer used
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.122 2014/07/22 01:18:50 dtucker Exp $ */
d41 1
a41 2
key_fingerprint_raw(const Key *k, enum fp_type dgst_type,
    u_int *dgst_raw_length)
d49 1
a49 1
	if ((r = sshkey_fingerprint_raw(k, dgst_type, &ret, &dlen)) != 0)
@


1.122
log
@Prevent spam from key_load_private_pem during hostbased auth.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.121 2014/07/17 00:12:03 djm Exp $ */
a463 14
int
key_in_file(Key *key, const char *filename, int strict_type)
{
	int r;

	if ((r = sshkey_in_file(key, filename, strict_type)) != 0) {
		fatal_on_fatal_errors(r, __func__, SSH_ERR_LIBCRYPTO_ERROR);
		if (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT)
			return 0;
		error("%s: %s", __func__, ssh_err(r));
		return r == SSH_ERR_KEY_NOT_FOUND ? 0 : -1;
	}
	return 1;
}
@


1.121
log
@silence "incorrect passphrase" error spam; reported and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.120 2014/07/09 03:02:15 djm Exp $ */
d448 4
a451 1
		error("%s: %s", __func__, ssh_err(r));
@


1.120
log
@downgrade more error() to debug() to better match what old authfile.c
did; suppresses spurious errors with hostbased authentication enabled
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.119 2014/06/30 12:54:39 djm Exp $ */
d385 2
a386 1
		if (r == SSH_ERR_SYSTEM_ERROR)
d406 2
a407 1
		if (r == SSH_ERR_SYSTEM_ERROR)
@


1.119
log
@suppress spurious error message when loading key with a passphrase;
reported by kettenis@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.118 2014/06/24 01:13:21 djm Exp $ */
d346 2
a347 1
		if (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT)
d365 2
a366 1
		if (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT)
d384 2
a385 1
		if (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT)
d404 2
a405 1
		if (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT)
d424 2
a425 1
		if ((r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT) ||
@


1.118
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.117 2014/04/29 18:01:49 markus Exp $ */
d420 2
a421 1
		if (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT)
@


1.117
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.116 2014/02/02 03:44:31 djm Exp $ */
d3 1
a3 32
 * read_bignum():
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2008 Alexander von Gernler.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d8 2
a9 4

#include <openssl/evp.h>
#include "crypto_api.h"

a10 1
#include <string.h>
d12 1
a12 1
#include "xmalloc.h"
d14 4
a17 3
#include "rsa.h"
#include "uuencode.h"
#include "buffer.h"
d19 1
a19 90
#include "misc.h"
#include "ssh2.h"
#include "digest.h"

static int to_blob(const Key *, u_char **, u_int *, int);
static Key *key_from_blob2(const u_char *, u_int, int);

static struct KeyCert *
cert_new(void)
{
	struct KeyCert *cert;

	cert = xcalloc(1, sizeof(*cert));
	buffer_init(&cert->certblob);
	buffer_init(&cert->critical);
	buffer_init(&cert->extensions);
	cert->key_id = NULL;
	cert->principals = NULL;
	cert->signature_key = NULL;
	return cert;
}

Key *
key_new(int type)
{
	Key *k;
#ifdef WITH_OPENSSL
	RSA *rsa;
	DSA *dsa;
#endif

	k = xcalloc(1, sizeof(*k));
	k->type = type;
	k->ecdsa = NULL;
	k->ecdsa_nid = -1;
	k->dsa = NULL;
	k->rsa = NULL;
	k->cert = NULL;
	k->ed25519_sk = NULL;
	k->ed25519_pk = NULL;
	switch (k->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA1:
	case KEY_RSA:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		if ((rsa = RSA_new()) == NULL)
			fatal("key_new: RSA_new failed");
		if ((rsa->n = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((rsa->e = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		k->rsa = rsa;
		break;
	case KEY_DSA:
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		if ((dsa = DSA_new()) == NULL)
			fatal("key_new: DSA_new failed");
		if ((dsa->p = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->q = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->g = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->pub_key = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		k->dsa = dsa;
		break;
	case KEY_ECDSA:
	case KEY_ECDSA_CERT:
		/* Cannot do anything until we know the group */
		break;
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		/* no need to prealloc */
		break;
	case KEY_UNSPEC:
		break;
	default:
		fatal("key_new: bad key type %d", k->type);
		break;
	}

	if (key_is_cert(k))
		k->cert = cert_new();

	return k;
}
d24 4
a27 39
	switch (k->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA1:
	case KEY_RSA:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		if ((k->rsa->d = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->iqmp = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->q = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->p = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->dmq1 = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->dmp1 = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		break;
	case KEY_DSA:
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		if ((k->dsa->priv_key = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		break;
	case KEY_ECDSA:
	case KEY_ECDSA_CERT:
		/* Cannot do anything until we know the group */
		break;
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		/* no need to prealloc */
		break;
	case KEY_UNSPEC:
		break;
	default:
		break;
	}
d33 1
a33 1
	Key *k = key_new(type);
d35 3
a37 164
	key_add_private(k);
	return k;
}

static void
cert_free(struct KeyCert *cert)
{
	u_int i;

	buffer_free(&cert->certblob);
	buffer_free(&cert->critical);
	buffer_free(&cert->extensions);
	free(cert->key_id);
	for (i = 0; i < cert->nprincipals; i++)
		free(cert->principals[i]);
	free(cert->principals);
	if (cert->signature_key != NULL)
		key_free(cert->signature_key);
	free(cert);
}

void
key_free(Key *k)
{
	if (k == NULL)
		fatal("key_free: key is NULL");
	switch (k->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA1:
	case KEY_RSA:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		if (k->rsa != NULL)
			RSA_free(k->rsa);
		k->rsa = NULL;
		break;
	case KEY_DSA:
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		if (k->dsa != NULL)
			DSA_free(k->dsa);
		k->dsa = NULL;
		break;
	case KEY_ECDSA:
	case KEY_ECDSA_CERT:
		if (k->ecdsa != NULL)
			EC_KEY_free(k->ecdsa);
		k->ecdsa = NULL;
		break;
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		if (k->ed25519_pk) {
			explicit_bzero(k->ed25519_pk, ED25519_PK_SZ);
			free(k->ed25519_pk);
			k->ed25519_pk = NULL;
		}
		if (k->ed25519_sk) {
			explicit_bzero(k->ed25519_sk, ED25519_SK_SZ);
			free(k->ed25519_sk);
			k->ed25519_sk = NULL;
		}
		break;
	case KEY_UNSPEC:
		break;
	default:
		fatal("key_free: bad key type %d", k->type);
		break;
	}
	if (key_is_cert(k)) {
		if (k->cert != NULL)
			cert_free(k->cert);
		k->cert = NULL;
	}

	free(k);
}

static int
cert_compare(struct KeyCert *a, struct KeyCert *b)
{
	if (a == NULL && b == NULL)
		return 1;
	if (a == NULL || b == NULL)
		return 0;
	if (buffer_len(&a->certblob) != buffer_len(&b->certblob))
		return 0;
	if (timingsafe_bcmp(buffer_ptr(&a->certblob), buffer_ptr(&b->certblob),
	    buffer_len(&a->certblob)) != 0)
		return 0;
	return 1;
}

/*
 * Compare public portions of key only, allowing comparisons between
 * certificates and plain keys too.
 */
int
key_equal_public(const Key *a, const Key *b)
{
#ifdef WITH_OPENSSL
	BN_CTX *bnctx;
#endif

	if (a == NULL || b == NULL ||
	    key_type_plain(a->type) != key_type_plain(b->type))
		return 0;

	switch (a->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA1:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
	case KEY_RSA:
		return a->rsa != NULL && b->rsa != NULL &&
		    BN_cmp(a->rsa->e, b->rsa->e) == 0 &&
		    BN_cmp(a->rsa->n, b->rsa->n) == 0;
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
	case KEY_DSA:
		return a->dsa != NULL && b->dsa != NULL &&
		    BN_cmp(a->dsa->p, b->dsa->p) == 0 &&
		    BN_cmp(a->dsa->q, b->dsa->q) == 0 &&
		    BN_cmp(a->dsa->g, b->dsa->g) == 0 &&
		    BN_cmp(a->dsa->pub_key, b->dsa->pub_key) == 0;
	case KEY_ECDSA_CERT:
	case KEY_ECDSA:
		if (a->ecdsa == NULL || b->ecdsa == NULL ||
		    EC_KEY_get0_public_key(a->ecdsa) == NULL ||
		    EC_KEY_get0_public_key(b->ecdsa) == NULL)
			return 0;
		if ((bnctx = BN_CTX_new()) == NULL)
			fatal("%s: BN_CTX_new failed", __func__);
		if (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),
		    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||
		    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),
		    EC_KEY_get0_public_key(a->ecdsa),
		    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {
			BN_CTX_free(bnctx);
			return 0;
		}
		BN_CTX_free(bnctx);
		return 1;
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		return a->ed25519_pk != NULL && b->ed25519_pk != NULL &&
		    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;
	default:
		fatal("key_equal: bad key type %d", a->type);
	}
	/* NOTREACHED */
}

int
key_equal(const Key *a, const Key *b)
{
	if (a == NULL || b == NULL || a->type != b->type)
		return 0;
	if (key_is_cert(a)) {
		if (!cert_compare(a->cert, b->cert))
			return 0;
	}
	return key_equal_public(a, b);
d44 12
a55 319
	u_char *blob = NULL;
	u_char *retval = NULL;
	u_int len = 0;
	int hash_alg = -1;
#ifdef WITH_OPENSSL
	int nlen, elen;
#endif

	*dgst_raw_length = 0;

	/* XXX switch to DIGEST_* directly? */
	switch (dgst_type) {
	case SSH_FP_MD5:
		hash_alg = SSH_DIGEST_MD5;
		break;
	case SSH_FP_SHA1:
		hash_alg = SSH_DIGEST_SHA1;
		break;
	case SSH_FP_SHA256:
		hash_alg = SSH_DIGEST_SHA256;
		break;
	default:
		fatal("%s: bad digest type %d", __func__, dgst_type);
	}
	switch (k->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA1:
		nlen = BN_num_bytes(k->rsa->n);
		elen = BN_num_bytes(k->rsa->e);
		len = nlen + elen;
		blob = xmalloc(len);
		BN_bn2bin(k->rsa->n, blob);
		BN_bn2bin(k->rsa->e, blob + nlen);
		break;
	case KEY_DSA:
	case KEY_ECDSA:
	case KEY_RSA:
#endif
	case KEY_ED25519:
		key_to_blob(k, &blob, &len);
		break;
#ifdef WITH_OPENSSL
	case KEY_DSA_CERT_V00:
	case KEY_RSA_CERT_V00:
	case KEY_DSA_CERT:
	case KEY_ECDSA_CERT:
	case KEY_RSA_CERT:
#endif
	case KEY_ED25519_CERT:
		/* We want a fingerprint of the _key_ not of the cert */
		to_blob(k, &blob, &len, 1);
		break;
	case KEY_UNSPEC:
		return retval;
	default:
		fatal("%s: bad key type %d", __func__, k->type);
		break;
	}
	if (blob != NULL) {
		retval = xmalloc(SSH_DIGEST_MAX_LENGTH);
		if ((ssh_digest_memory(hash_alg, blob, len,
		    retval, SSH_DIGEST_MAX_LENGTH)) != 0)
			fatal("%s: digest_memory failed", __func__);
		explicit_bzero(blob, len);
		free(blob);
		*dgst_raw_length = ssh_digest_bytes(hash_alg);
	} else {
		fatal("%s: blob is null", __func__);
	}
	return retval;
}

static char *
key_fingerprint_hex(u_char *dgst_raw, u_int dgst_raw_len)
{
	char *retval;
	u_int i;

	retval = xcalloc(1, dgst_raw_len * 3 + 1);
	for (i = 0; i < dgst_raw_len; i++) {
		char hex[4];
		snprintf(hex, sizeof(hex), "%02x:", dgst_raw[i]);
		strlcat(retval, hex, dgst_raw_len * 3 + 1);
	}

	/* Remove the trailing ':' character */
	retval[(dgst_raw_len * 3) - 1] = '\0';
	return retval;
}

static char *
key_fingerprint_bubblebabble(u_char *dgst_raw, u_int dgst_raw_len)
{
	char vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };
	char consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm',
	    'n', 'p', 'r', 's', 't', 'v', 'z', 'x' };
	u_int i, j = 0, rounds, seed = 1;
	char *retval;

	rounds = (dgst_raw_len / 2) + 1;
	retval = xcalloc((rounds * 6), sizeof(char));
	retval[j++] = 'x';
	for (i = 0; i < rounds; i++) {
		u_int idx0, idx1, idx2, idx3, idx4;
		if ((i + 1 < rounds) || (dgst_raw_len % 2 != 0)) {
			idx0 = (((((u_int)(dgst_raw[2 * i])) >> 6) & 3) +
			    seed) % 6;
			idx1 = (((u_int)(dgst_raw[2 * i])) >> 2) & 15;
			idx2 = ((((u_int)(dgst_raw[2 * i])) & 3) +
			    (seed / 6)) % 6;
			retval[j++] = vowels[idx0];
			retval[j++] = consonants[idx1];
			retval[j++] = vowels[idx2];
			if ((i + 1) < rounds) {
				idx3 = (((u_int)(dgst_raw[(2 * i) + 1])) >> 4) & 15;
				idx4 = (((u_int)(dgst_raw[(2 * i) + 1]))) & 15;
				retval[j++] = consonants[idx3];
				retval[j++] = '-';
				retval[j++] = consonants[idx4];
				seed = ((seed * 5) +
				    ((((u_int)(dgst_raw[2 * i])) * 7) +
				    ((u_int)(dgst_raw[(2 * i) + 1])))) % 36;
			}
		} else {
			idx0 = seed % 6;
			idx1 = 16;
			idx2 = seed / 6;
			retval[j++] = vowels[idx0];
			retval[j++] = consonants[idx1];
			retval[j++] = vowels[idx2];
		}
	}
	retval[j++] = 'x';
	retval[j++] = '\0';
	return retval;
}

/*
 * Draw an ASCII-Art representing the fingerprint so human brain can
 * profit from its built-in pattern recognition ability.
 * This technique is called "random art" and can be found in some
 * scientific publications like this original paper:
 *
 * "Hash Visualization: a New Technique to improve Real-World Security",
 * Perrig A. and Song D., 1999, International Workshop on Cryptographic
 * Techniques and E-Commerce (CrypTEC '99)
 * sparrow.ece.cmu.edu/~adrian/projects/validation/validation.pdf
 *
 * The subject came up in a talk by Dan Kaminsky, too.
 *
 * If you see the picture is different, the key is different.
 * If the picture looks the same, you still know nothing.
 *
 * The algorithm used here is a worm crawling over a discrete plane,
 * leaving a trace (augmenting the field) everywhere it goes.
 * Movement is taken from dgst_raw 2bit-wise.  Bumping into walls
 * makes the respective movement vector be ignored for this turn.
 * Graphs are not unambiguous, because circles in graphs can be
 * walked in either direction.
 */

/*
 * Field sizes for the random art.  Have to be odd, so the starting point
 * can be in the exact middle of the picture, and FLDBASE should be >=8 .
 * Else pictures would be too dense, and drawing the frame would
 * fail, too, because the key type would not fit in anymore.
 */
#define	FLDBASE		8
#define	FLDSIZE_Y	(FLDBASE + 1)
#define	FLDSIZE_X	(FLDBASE * 2 + 1)
static char *
key_fingerprint_randomart(u_char *dgst_raw, u_int dgst_raw_len, const Key *k)
{
	/*
	 * Chars to be used after each other every time the worm
	 * intersects with itself.  Matter of taste.
	 */
	char	*augmentation_string = " .o+=*BOX@@%&#/^SE";
	char	*retval, *p;
	u_char	 field[FLDSIZE_X][FLDSIZE_Y];
	u_int	 i, b;
	int	 x, y;
	size_t	 len = strlen(augmentation_string) - 1;

	retval = xcalloc(1, (FLDSIZE_X + 3) * (FLDSIZE_Y + 2));

	/* initialize field */
	memset(field, 0, FLDSIZE_X * FLDSIZE_Y * sizeof(char));
	x = FLDSIZE_X / 2;
	y = FLDSIZE_Y / 2;

	/* process raw key */
	for (i = 0; i < dgst_raw_len; i++) {
		int input;
		/* each byte conveys four 2-bit move commands */
		input = dgst_raw[i];
		for (b = 0; b < 4; b++) {
			/* evaluate 2 bit, rest is shifted later */
			x += (input & 0x1) ? 1 : -1;
			y += (input & 0x2) ? 1 : -1;

			/* assure we are still in bounds */
			x = MAX(x, 0);
			y = MAX(y, 0);
			x = MIN(x, FLDSIZE_X - 1);
			y = MIN(y, FLDSIZE_Y - 1);

			/* augment the field */
			if (field[x][y] < len - 2)
				field[x][y]++;
			input = input >> 2;
		}
	}

	/* mark starting point and end point*/
	field[FLDSIZE_X / 2][FLDSIZE_Y / 2] = len - 1;
	field[x][y] = len;

	/* fill in retval */
	snprintf(retval, FLDSIZE_X, "+--[%4s %4u]", key_type(k), key_size(k));
	p = strchr(retval, '\0');

	/* output upper border */
	for (i = p - retval - 1; i < FLDSIZE_X; i++)
		*p++ = '-';
	*p++ = '+';
	*p++ = '\n';

	/* output content */
	for (y = 0; y < FLDSIZE_Y; y++) {
		*p++ = '|';
		for (x = 0; x < FLDSIZE_X; x++)
			*p++ = augmentation_string[MIN(field[x][y], len)];
		*p++ = '|';
		*p++ = '\n';
	}

	/* output lower border */
	*p++ = '+';
	for (i = 0; i < FLDSIZE_X; i++)
		*p++ = '-';
	*p++ = '+';

	return retval;
}

char *
key_fingerprint(const Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
{
	char *retval = NULL;
	u_char *dgst_raw;
	u_int dgst_raw_len;

	dgst_raw = key_fingerprint_raw(k, dgst_type, &dgst_raw_len);
	if (!dgst_raw)
		fatal("key_fingerprint: null from key_fingerprint_raw()");
	switch (dgst_rep) {
	case SSH_FP_HEX:
		retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
		break;
	case SSH_FP_BUBBLEBABBLE:
		retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
		break;
	case SSH_FP_RANDOMART:
		retval = key_fingerprint_randomart(dgst_raw, dgst_raw_len, k);
		break;
	default:
		fatal("key_fingerprint: bad digest representation %d",
		    dgst_rep);
		break;
	}
	explicit_bzero(dgst_raw, dgst_raw_len);
	free(dgst_raw);
	return retval;
}

#ifdef WITH_SSH1
/*
 * Reads a multiple-precision integer in decimal from the buffer, and advances
 * the pointer.  The integer must already be initialized.  This function is
 * permitted to modify the buffer.  This leaves *cpp to point just beyond the
 * last processed (and maybe modified) character.  Note that this may modify
 * the buffer containing the number.
 */
static int
read_bignum(char **cpp, BIGNUM * value)
{
	char *cp = *cpp;
	int old;

	/* Skip any leading whitespace. */
	for (; *cp == ' ' || *cp == '\t'; cp++)
		;

	/* Check that it begins with a decimal digit. */
	if (*cp < '0' || *cp > '9')
		return 0;

	/* Save starting position. */
	*cpp = cp;

	/* Move forward until all decimal digits skipped. */
	for (; *cp >= '0' && *cp <= '9'; cp++)
		;

	/* Save the old terminating character, and replace it by \0. */
	old = *cp;
	*cp = 0;

	/* Parse the number. */
	if (BN_dec2bn(&value, *cpp) == 0)
		return 0;

	/* Restore old terminating character. */
	*cp = old;

	/* Move beyond the number and return success. */
	*cpp = cp;
	return 1;
a57 15
static int
write_bignum(FILE *f, BIGNUM *num)
{
	char *buf = BN_bn2dec(num);
	if (buf == NULL) {
		error("write_bignum: BN_bn2dec() failed");
		return 0;
	}
	fprintf(f, " %s", buf);
	OPENSSL_free(buf);
	return 1;
}
#endif

/* returns 1 ok, -1 error */
d61 1
a61 169
	Key *k;
	int success = -1;
	char *cp, *space;
	int len, n, type, curve_nid = -1;
#ifdef WITH_SSH1
	u_int bits;
#endif
	u_char *blob;

	cp = *cpp;

	switch (ret->type) {
	case KEY_RSA1:
#ifdef WITH_SSH1
		/* Get number of bits. */
		if (*cp < '0' || *cp > '9')
			return -1;	/* Bad bit count... */
		for (bits = 0; *cp >= '0' && *cp <= '9'; cp++)
			bits = 10 * bits + *cp - '0';
		if (bits == 0)
			return -1;
		*cpp = cp;
		/* Get public exponent, public modulus. */
		if (!read_bignum(cpp, ret->rsa->e))
			return -1;
		if (!read_bignum(cpp, ret->rsa->n))
			return -1;
		/* validate the claimed number of bits */
		if ((u_int)BN_num_bits(ret->rsa->n) != bits) {
			verbose("key_read: claimed key size %d does not match "
			   "actual %d", bits, BN_num_bits(ret->rsa->n));
			return -1;
		}
		success = 1;
#endif
		break;
	case KEY_UNSPEC:
	case KEY_RSA:
	case KEY_DSA:
	case KEY_ECDSA:
	case KEY_ED25519:
	case KEY_DSA_CERT_V00:
	case KEY_RSA_CERT_V00:
	case KEY_DSA_CERT:
	case KEY_ECDSA_CERT:
	case KEY_RSA_CERT:
	case KEY_ED25519_CERT:
		space = strchr(cp, ' ');
		if (space == NULL) {
			debug3("key_read: missing whitespace");
			return -1;
		}
		*space = '\0';
		type = key_type_from_name(cp);
		if (key_type_plain(type) == KEY_ECDSA &&
		    (curve_nid = key_ecdsa_nid_from_name(cp)) == -1) {
			debug("key_read: invalid curve");
			return -1;
		}
		*space = ' ';
		if (type == KEY_UNSPEC) {
			debug3("key_read: missing keytype");
			return -1;
		}
		cp = space+1;
		if (*cp == '\0') {
			debug3("key_read: short string");
			return -1;
		}
		if (ret->type == KEY_UNSPEC) {
			ret->type = type;
		} else if (ret->type != type) {
			/* is a key, but different type */
			debug3("key_read: type mismatch");
			return -1;
		}
		len = 2*strlen(cp);
		blob = xmalloc(len);
		n = uudecode(cp, blob, len);
		if (n < 0) {
			error("key_read: uudecode %s failed", cp);
			free(blob);
			return -1;
		}
		k = key_from_blob(blob, (u_int)n);
		free(blob);
		if (k == NULL) {
			error("key_read: key_from_blob %s failed", cp);
			return -1;
		}
		if (k->type != type) {
			error("key_read: type mismatch: encoding error");
			key_free(k);
			return -1;
		}
		if (key_type_plain(type) == KEY_ECDSA &&
		    curve_nid != k->ecdsa_nid) {
			error("key_read: type mismatch: EC curve mismatch");
			key_free(k);
			return -1;
		}
/*XXXX*/
		if (key_is_cert(ret)) {
			if (!key_is_cert(k)) {
				error("key_read: loaded key is not a cert");
				key_free(k);
				return -1;
			}
			if (ret->cert != NULL)
				cert_free(ret->cert);
			ret->cert = k->cert;
			k->cert = NULL;
		}
#ifdef WITH_OPENSSL
		if (key_type_plain(ret->type) == KEY_RSA) {
			if (ret->rsa != NULL)
				RSA_free(ret->rsa);
			ret->rsa = k->rsa;
			k->rsa = NULL;
#ifdef DEBUG_PK
			RSA_print_fp(stderr, ret->rsa, 8);
#endif
		}
		if (key_type_plain(ret->type) == KEY_DSA) {
			if (ret->dsa != NULL)
				DSA_free(ret->dsa);
			ret->dsa = k->dsa;
			k->dsa = NULL;
#ifdef DEBUG_PK
			DSA_print_fp(stderr, ret->dsa, 8);
#endif
		}
		if (key_type_plain(ret->type) == KEY_ECDSA) {
			if (ret->ecdsa != NULL)
				EC_KEY_free(ret->ecdsa);
			ret->ecdsa = k->ecdsa;
			ret->ecdsa_nid = k->ecdsa_nid;
			k->ecdsa = NULL;
			k->ecdsa_nid = -1;
#ifdef DEBUG_PK
			key_dump_ec_key(ret->ecdsa);
#endif
		}
#endif
		if (key_type_plain(ret->type) == KEY_ED25519) {
			free(ret->ed25519_pk);
			ret->ed25519_pk = k->ed25519_pk;
			k->ed25519_pk = NULL;
#ifdef DEBUG_PK
			/* XXX */
#endif
		}
		success = 1;
/*XXXX*/
		key_free(k);
		if (success != 1)
			break;
		/* advance cp: skip whitespace and data */
		while (*cp == ' ' || *cp == '\t')
			cp++;
		while (*cp != '\0' && *cp != ' ' && *cp != '\t')
			cp++;
		*cpp = cp;
		break;
	default:
		fatal("key_read: bad key type: %d", ret->type);
		break;
	}
	return success;
d67 1
a67 72
	int n, success = 0;
#ifdef WITH_SSH1
	u_int bits = 0;
#endif
	u_int len;
	u_char *blob;
	char *uu;

	if (key_is_cert(key)) {
		if (key->cert == NULL) {
			error("%s: no cert data", __func__);
			return 0;
		}
		if (buffer_len(&key->cert->certblob) == 0) {
			error("%s: no signed certificate blob", __func__);
			return 0;
		}
	}

	switch (key->type) {
#ifdef WITH_SSH1
	case KEY_RSA1:
		if (key->rsa == NULL)
			return 0;
		/* size of modulus 'n' */
		bits = BN_num_bits(key->rsa->n);
		fprintf(f, "%u", bits);
		if (write_bignum(f, key->rsa->e) &&
		    write_bignum(f, key->rsa->n))
			return 1;
		error("key_write: failed for RSA key");
		return 0;
#endif
#ifdef WITH_OPENSSL
	case KEY_DSA:
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		if (key->dsa == NULL)
			return 0;
		break;
	case KEY_ECDSA:
	case KEY_ECDSA_CERT:
		if (key->ecdsa == NULL)
			return 0;
		break;
	case KEY_RSA:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		if (key->rsa == NULL)
			return 0;
		break;
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		if (key->ed25519_pk == NULL)
			return 0;
		break;
	default:
		return 0;
	}

	key_to_blob(key, &blob, &len);
	uu = xmalloc(2*len);
	n = uuencode(blob, len, uu, 2*len);
	if (n > 0) {
		fprintf(f, "%s %s", key_ssh_name(key), uu);
		success = 1;
	}
	free(blob);
	free(uu);

	return success;
d70 2
a71 88
const char *
key_cert_type(const Key *k)
{
	switch (k->cert->type) {
	case SSH2_CERT_TYPE_USER:
		return "user";
	case SSH2_CERT_TYPE_HOST:
		return "host";
	default:
		return "unknown";
	}
}

struct keytype {
	char *name;
	char *shortname;
	int type;
	int nid;
	int cert;
};
static const struct keytype keytypes[] = {
#ifdef WITH_OPENSSL
#ifdef WITH_SSH1
	{ NULL, "RSA1", KEY_RSA1, 0, 0 },
#endif
	{ "ssh-rsa", "RSA", KEY_RSA, 0, 0 },
	{ "ssh-dss", "DSA", KEY_DSA, 0, 0 },
	{ "ecdsa-sha2-nistp256", "ECDSA", KEY_ECDSA, NID_X9_62_prime256v1, 0 },
	{ "ecdsa-sha2-nistp384", "ECDSA", KEY_ECDSA, NID_secp384r1, 0 },
	{ "ecdsa-sha2-nistp521", "ECDSA", KEY_ECDSA, NID_secp521r1, 0 },
	{ "ssh-rsa-cert-v01@@openssh.com", "RSA-CERT", KEY_RSA_CERT, 0, 1 },
	{ "ssh-dss-cert-v01@@openssh.com", "DSA-CERT", KEY_DSA_CERT, 0, 1 },
	{ "ecdsa-sha2-nistp256-cert-v01@@openssh.com", "ECDSA-CERT",
	    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1 },
	{ "ecdsa-sha2-nistp384-cert-v01@@openssh.com", "ECDSA-CERT",
	    KEY_ECDSA_CERT, NID_secp384r1, 1 },
	{ "ecdsa-sha2-nistp521-cert-v01@@openssh.com", "ECDSA-CERT",
	    KEY_ECDSA_CERT, NID_secp521r1, 1 },
	{ "ssh-rsa-cert-v00@@openssh.com", "RSA-CERT-V00",
	    KEY_RSA_CERT_V00, 0, 1 },
	{ "ssh-dss-cert-v00@@openssh.com", "DSA-CERT-V00",
	    KEY_DSA_CERT_V00, 0, 1 },
#endif
	{ "ssh-ed25519", "ED25519", KEY_ED25519, 0, 0 },
	{ "ssh-ed25519-cert-v01@@openssh.com", "ED25519-CERT",
	    KEY_ED25519_CERT, 0, 1 },
	{ NULL, NULL, -1, -1, 0 }
};

const char *
key_type(const Key *k)
{
	const struct keytype *kt;

	for (kt = keytypes; kt->type != -1; kt++) {
		if (kt->type == k->type)
			return kt->shortname;
	}
	return "unknown";
}

static const char *
key_ssh_name_from_type_nid(int type, int nid)
{
	const struct keytype *kt;

	for (kt = keytypes; kt->type != -1; kt++) {
		if (kt->type == type && (kt->nid == 0 || kt->nid == nid))
			return kt->name;
	}
	return "ssh-unknown";
}

const char *
key_ssh_name(const Key *k)
{
	return key_ssh_name_from_type_nid(k->type, k->ecdsa_nid);
}

const char *
key_ssh_name_plain(const Key *k)
{
	return key_ssh_name_from_type_nid(key_type_plain(k->type),
	    k->ecdsa_nid);
}

int
key_type_from_name(char *name)
d73 2
a74 1
	const struct keytype *kt;
d76 2
a77 44
	for (kt = keytypes; kt->type != -1; kt++) {
		/* Only allow shortname matches for plain key types */
		if ((kt->name != NULL && strcmp(name, kt->name) == 0) ||
		    (!kt->cert && strcasecmp(kt->shortname, name) == 0))
			return kt->type;
	}
	debug2("key_type_from_name: unknown key type '%s'", name);
	return KEY_UNSPEC;
}

int
key_ecdsa_nid_from_name(const char *name)
{
	const struct keytype *kt;

	for (kt = keytypes; kt->type != -1; kt++) {
		if (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)
			continue;
		if (kt->name != NULL && strcmp(name, kt->name) == 0)
			return kt->nid;
	}
	debug2("%s: unknown/non-ECDSA key type '%s'", __func__, name);
	return -1;
}

char *
key_alg_list(int certs_only, int plain_only)
{
	char *ret = NULL;
	size_t nlen, rlen = 0;
	const struct keytype *kt;

	for (kt = keytypes; kt->type != -1; kt++) {
		if (kt->name == NULL)
			continue;
		if ((certs_only && !kt->cert) || (plain_only && kt->cert))
			continue;
		if (ret != NULL)
			ret[rlen++] = '\n';
		nlen = strlen(kt->name);
		ret = xrealloc(ret, 1, rlen + nlen + 2);
		memcpy(ret + rlen, kt->name, nlen + 1);
		rlen += nlen;
	}
a80 195
int
key_type_is_cert(int type)
{
	const struct keytype *kt;

	for (kt = keytypes; kt->type != -1; kt++) {
		if (kt->type == type)
			return kt->cert;
	}
	return 0;
}

static int
key_type_is_valid_ca(int type)
{
	switch (type) {
	case KEY_RSA:
	case KEY_DSA:
	case KEY_ECDSA:
	case KEY_ED25519:
		return 1;
	default:
		return 0;
	}
}

u_int
key_size(const Key *k)
{
	switch (k->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA1:
	case KEY_RSA:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		return BN_num_bits(k->rsa->n);
	case KEY_DSA:
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		return BN_num_bits(k->dsa->p);
	case KEY_ECDSA:
	case KEY_ECDSA_CERT:
		return key_curve_nid_to_bits(k->ecdsa_nid);
#endif
	case KEY_ED25519:
		return 256;	/* XXX */
	}
	return 0;
}

#ifdef WITH_OPENSSL
static RSA *
rsa_generate_private_key(u_int bits)
{
	RSA *private = RSA_new();
	BIGNUM *f4 = BN_new();

	if (private == NULL)
		fatal("%s: RSA_new failed", __func__);
	if (f4 == NULL)
		fatal("%s: BN_new failed", __func__);
	if (!BN_set_word(f4, RSA_F4))
		fatal("%s: BN_new failed", __func__);
	if (!RSA_generate_key_ex(private, bits, f4, NULL))
		fatal("%s: key generation failed.", __func__);
	BN_free(f4);
	return private;
}

static DSA*
dsa_generate_private_key(u_int bits)
{
	DSA *private = DSA_new();

	if (private == NULL)
		fatal("%s: DSA_new failed", __func__);
	if (!DSA_generate_parameters_ex(private, bits, NULL, 0, NULL,
	    NULL, NULL))
		fatal("%s: DSA_generate_parameters failed", __func__);
	if (!DSA_generate_key(private))
		fatal("%s: DSA_generate_key failed.", __func__);
	return private;
}

int
key_ecdsa_bits_to_nid(int bits)
{
	switch (bits) {
	case 256:
		return NID_X9_62_prime256v1;
	case 384:
		return NID_secp384r1;
	case 521:
		return NID_secp521r1;
	default:
		return -1;
	}
}

int
key_ecdsa_key_to_nid(EC_KEY *k)
{
	EC_GROUP *eg;
	int nids[] = {
		NID_X9_62_prime256v1,
		NID_secp384r1,
		NID_secp521r1,
		-1
	};
	int nid;
	u_int i;
	BN_CTX *bnctx;
	const EC_GROUP *g = EC_KEY_get0_group(k);

	/*
	 * The group may be stored in a ASN.1 encoded private key in one of two
	 * ways: as a "named group", which is reconstituted by ASN.1 object ID
	 * or explicit group parameters encoded into the key blob. Only the
	 * "named group" case sets the group NID for us, but we can figure
	 * it out for the other case by comparing against all the groups that
	 * are supported.
	 */
	if ((nid = EC_GROUP_get_curve_name(g)) > 0)
		return nid;
	if ((bnctx = BN_CTX_new()) == NULL)
		fatal("%s: BN_CTX_new() failed", __func__);
	for (i = 0; nids[i] != -1; i++) {
		if ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL)
			fatal("%s: EC_GROUP_new_by_curve_name failed",
			    __func__);
		if (EC_GROUP_cmp(g, eg, bnctx) == 0)
			break;
		EC_GROUP_free(eg);
	}
	BN_CTX_free(bnctx);
	debug3("%s: nid = %d", __func__, nids[i]);
	if (nids[i] != -1) {
		/* Use the group with the NID attached */
		EC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);
		if (EC_KEY_set_group(k, eg) != 1)
			fatal("%s: EC_KEY_set_group", __func__);
	}
	return nids[i];
}

static EC_KEY*
ecdsa_generate_private_key(u_int bits, int *nid)
{
	EC_KEY *private;

	if ((*nid = key_ecdsa_bits_to_nid(bits)) == -1)
		fatal("%s: invalid key length", __func__);
	if ((private = EC_KEY_new_by_curve_name(*nid)) == NULL)
		fatal("%s: EC_KEY_new_by_curve_name failed", __func__);
	if (EC_KEY_generate_key(private) != 1)
		fatal("%s: EC_KEY_generate_key failed", __func__);
	EC_KEY_set_asn1_flag(private, OPENSSL_EC_NAMED_CURVE);
	return private;
}
#endif

Key *
key_generate(int type, u_int bits)
{
	Key *k = key_new(KEY_UNSPEC);
	switch (type) {
#ifdef WITH_OPENSSL
	case KEY_DSA:
		k->dsa = dsa_generate_private_key(bits);
		break;
	case KEY_ECDSA:
		k->ecdsa = ecdsa_generate_private_key(bits, &k->ecdsa_nid);
		break;
	case KEY_RSA:
	case KEY_RSA1:
		k->rsa = rsa_generate_private_key(bits);
		break;
	case KEY_RSA_CERT_V00:
	case KEY_DSA_CERT_V00:
	case KEY_RSA_CERT:
	case KEY_DSA_CERT:
		fatal("key_generate: cert keys cannot be generated directly");
#endif
	case KEY_ED25519:
		k->ed25519_pk = xmalloc(ED25519_PK_SZ);
		k->ed25519_sk = xmalloc(ED25519_SK_SZ);
		crypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);
		break;
	default:
		fatal("key_generate: unknown type %d", type);
	}
	k->type = type;
	return k;
}

d82 1
a82 1
key_cert_copy(const Key *from_key, struct Key *to_key)
d84 1
a84 13
	u_int i;
	const struct KeyCert *from;
	struct KeyCert *to;

	if (to_key->cert != NULL) {
		cert_free(to_key->cert);
		to_key->cert = NULL;
	}

	if ((from = from_key->cert) == NULL)
		return;

	to = to_key->cert = cert_new();
d86 2
a87 26
	buffer_append(&to->certblob, buffer_ptr(&from->certblob),
	    buffer_len(&from->certblob));

	buffer_append(&to->critical,
	    buffer_ptr(&from->critical), buffer_len(&from->critical));
	buffer_append(&to->extensions,
	    buffer_ptr(&from->extensions), buffer_len(&from->extensions));

	to->serial = from->serial;
	to->type = from->type;
	to->key_id = from->key_id == NULL ? NULL : xstrdup(from->key_id);
	to->valid_after = from->valid_after;
	to->valid_before = from->valid_before;
	to->signature_key = from->signature_key == NULL ?
	    NULL : key_from_private(from->signature_key);

	to->nprincipals = from->nprincipals;
	if (to->nprincipals > CERT_MAX_PRINCIPALS)
		fatal("%s: nprincipals (%u) > CERT_MAX_PRINCIPALS (%u)",
		    __func__, to->nprincipals, CERT_MAX_PRINCIPALS);
	if (to->nprincipals > 0) {
		to->principals = xcalloc(from->nprincipals,
		    sizeof(*to->principals));
		for (i = 0; i < to->nprincipals; i++)
			to->principals[i] = xstrdup(from->principals[i]);
	}
d93 2
a94 54
	Key *n = NULL;
	switch (k->type) {
#ifdef WITH_OPENSSL
	case KEY_DSA:
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		n = key_new(k->type);
		if ((BN_copy(n->dsa->p, k->dsa->p) == NULL) ||
		    (BN_copy(n->dsa->q, k->dsa->q) == NULL) ||
		    (BN_copy(n->dsa->g, k->dsa->g) == NULL) ||
		    (BN_copy(n->dsa->pub_key, k->dsa->pub_key) == NULL))
			fatal("key_from_private: BN_copy failed");
		break;
	case KEY_ECDSA:
	case KEY_ECDSA_CERT:
		n = key_new(k->type);
		n->ecdsa_nid = k->ecdsa_nid;
		if ((n->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid)) == NULL)
			fatal("%s: EC_KEY_new_by_curve_name failed", __func__);
		if (EC_KEY_set_public_key(n->ecdsa,
		    EC_KEY_get0_public_key(k->ecdsa)) != 1)
			fatal("%s: EC_KEY_set_public_key failed", __func__);
		break;
	case KEY_RSA:
	case KEY_RSA1:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		n = key_new(k->type);
		if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
		    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
			fatal("key_from_private: BN_copy failed");
		break;
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		n = key_new(k->type);
		if (k->ed25519_pk != NULL) {
			n->ed25519_pk = xmalloc(ED25519_PK_SZ);
			memcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);
		}
		break;
	default:
		fatal("key_from_private: unknown type %d", k->type);
		break;
	}
	if (key_is_cert(k))
		key_cert_copy(k, n);
	return n;
}

int
key_names_valid2(const char *names)
{
	char *s, *cp, *p;
d96 2
a97 138
	if (names == NULL || strcmp(names, "") == 0)
		return 0;
	s = cp = xstrdup(names);
	for ((p = strsep(&cp, ",")); p && *p != '\0';
	    (p = strsep(&cp, ","))) {
		switch (key_type_from_name(p)) {
		case KEY_RSA1:
		case KEY_UNSPEC:
			free(s);
			return 0;
		}
	}
	debug3("key names ok: [%s]", names);
	free(s);
	return 1;
}

static int
cert_parse(Buffer *b, Key *key, const u_char *blob, u_int blen)
{
	u_char *principals, *critical, *exts, *sig_key, *sig;
	u_int signed_len, plen, clen, sklen, slen, kidlen, elen;
	Buffer tmp;
	char *principal;
	int ret = -1;
	int v00 = key->type == KEY_DSA_CERT_V00 ||
	    key->type == KEY_RSA_CERT_V00;

	buffer_init(&tmp);

	/* Copy the entire key blob for verification and later serialisation */
	buffer_append(&key->cert->certblob, blob, blen);

	elen = 0; /* Not touched for v00 certs */
	principals = exts = critical = sig_key = sig = NULL;
	if ((!v00 && buffer_get_int64_ret(&key->cert->serial, b) != 0) ||
	    buffer_get_int_ret(&key->cert->type, b) != 0 ||
	    (key->cert->key_id = buffer_get_cstring_ret(b, &kidlen)) == NULL ||
	    (principals = buffer_get_string_ret(b, &plen)) == NULL ||
	    buffer_get_int64_ret(&key->cert->valid_after, b) != 0 ||
	    buffer_get_int64_ret(&key->cert->valid_before, b) != 0 ||
	    (critical = buffer_get_string_ret(b, &clen)) == NULL ||
	    (!v00 && (exts = buffer_get_string_ret(b, &elen)) == NULL) ||
	    (v00 && buffer_get_string_ptr_ret(b, NULL) == NULL) || /* nonce */
	    buffer_get_string_ptr_ret(b, NULL) == NULL || /* reserved */
	    (sig_key = buffer_get_string_ret(b, &sklen)) == NULL) {
		error("%s: parse error", __func__);
		goto out;
	}

	/* Signature is left in the buffer so we can calculate this length */
	signed_len = buffer_len(&key->cert->certblob) - buffer_len(b);

	if ((sig = buffer_get_string_ret(b, &slen)) == NULL) {
		error("%s: parse error", __func__);
		goto out;
	}

	if (key->cert->type != SSH2_CERT_TYPE_USER &&
	    key->cert->type != SSH2_CERT_TYPE_HOST) {
		error("Unknown certificate type %u", key->cert->type);
		goto out;
	}

	buffer_append(&tmp, principals, plen);
	while (buffer_len(&tmp) > 0) {
		if (key->cert->nprincipals >= CERT_MAX_PRINCIPALS) {
			error("%s: Too many principals", __func__);
			goto out;
		}
		if ((principal = buffer_get_cstring_ret(&tmp, &plen)) == NULL) {
			error("%s: Principals data invalid", __func__);
			goto out;
		}
		key->cert->principals = xrealloc(key->cert->principals,
		    key->cert->nprincipals + 1, sizeof(*key->cert->principals));
		key->cert->principals[key->cert->nprincipals++] = principal;
	}

	buffer_clear(&tmp);

	buffer_append(&key->cert->critical, critical, clen);
	buffer_append(&tmp, critical, clen);
	/* validate structure */
	while (buffer_len(&tmp) != 0) {
		if (buffer_get_string_ptr_ret(&tmp, NULL) == NULL ||
		    buffer_get_string_ptr_ret(&tmp, NULL) == NULL) {
			error("%s: critical option data invalid", __func__);
			goto out;
		}
	}
	buffer_clear(&tmp);

	buffer_append(&key->cert->extensions, exts, elen);
	buffer_append(&tmp, exts, elen);
	/* validate structure */
	while (buffer_len(&tmp) != 0) {
		if (buffer_get_string_ptr_ret(&tmp, NULL) == NULL ||
		    buffer_get_string_ptr_ret(&tmp, NULL) == NULL) {
			error("%s: extension data invalid", __func__);
			goto out;
		}
	}
	buffer_clear(&tmp);

	if ((key->cert->signature_key = key_from_blob2(sig_key, sklen, 0))
	    == NULL) {
		error("%s: Signature key invalid", __func__);
		goto out;
	}
	if (!key_type_is_valid_ca(key->cert->signature_key->type)) {
		error("%s: Invalid signature key type %s (%d)", __func__,
		    key_type(key->cert->signature_key),
		    key->cert->signature_key->type);
		goto out;
	}

	switch (key_verify(key->cert->signature_key, sig, slen, 
	    buffer_ptr(&key->cert->certblob), signed_len)) {
	case 1:
		ret = 0;
		break; /* Good signature */
	case 0:
		error("%s: Invalid signature on certificate", __func__);
		goto out;
	case -1:
		error("%s: Certificate signature verification failed",
		    __func__);
		goto out;
	}

 out:
	buffer_free(&tmp);
	free(principals);
	free(critical);
	free(exts);
	free(sig_key);
	free(sig);
d101 2
a102 2
static Key *
key_from_blob2(const u_char *blob, u_int blen, int allow_cert)
d104 4
a107 139
	Buffer b;
	int rlen, type, nid = -1;
	u_int len;
	char *ktype = NULL, *curve = NULL;
	u_char *pk = NULL;
	Key *key = NULL;
	EC_POINT *q = NULL;

#ifdef DEBUG_PK
	dump_base64(stderr, blob, blen);
#endif
	buffer_init(&b);
	buffer_append(&b, blob, blen);
	if ((ktype = buffer_get_cstring_ret(&b, NULL)) == NULL) {
		error("key_from_blob: can't read key type");
		goto out;
	}

	type = key_type_from_name(ktype);
	if (key_type_plain(type) == KEY_ECDSA)
		nid = key_ecdsa_nid_from_name(ktype);
	if (!allow_cert && key_type_is_cert(type)) {
		error("key_from_blob: certificate not allowed in this context");
		goto out;
	}
	switch (type) {
#ifdef WITH_OPENSSL
	case KEY_RSA_CERT:
		(void)buffer_get_string_ptr_ret(&b, NULL); /* Skip nonce */
		/* FALLTHROUGH */
	case KEY_RSA:
	case KEY_RSA_CERT_V00:
		key = key_new(type);
		if (buffer_get_bignum2_ret(&b, key->rsa->e) == -1 ||
		    buffer_get_bignum2_ret(&b, key->rsa->n) == -1) {
			error("key_from_blob: can't read rsa key");
			goto badkey;
		}
#ifdef DEBUG_PK
		RSA_print_fp(stderr, key->rsa, 8);
#endif
		break;
	case KEY_DSA_CERT:
		(void)buffer_get_string_ptr_ret(&b, NULL); /* Skip nonce */
		/* FALLTHROUGH */
	case KEY_DSA:
	case KEY_DSA_CERT_V00:
		key = key_new(type);
		if (buffer_get_bignum2_ret(&b, key->dsa->p) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->q) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->g) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->pub_key) == -1) {
			error("key_from_blob: can't read dsa key");
			goto badkey;
		}
#ifdef DEBUG_PK
		DSA_print_fp(stderr, key->dsa, 8);
#endif
		break;
	case KEY_ECDSA_CERT:
		(void)buffer_get_string_ptr_ret(&b, NULL); /* Skip nonce */
		/* FALLTHROUGH */
	case KEY_ECDSA:
		key = key_new(type);
		key->ecdsa_nid = nid;
		if ((curve = buffer_get_string_ret(&b, NULL)) == NULL) {
			error("key_from_blob: can't read ecdsa curve");
			goto badkey;
		}
		if (key->ecdsa_nid != key_curve_name_to_nid(curve)) {
			error("key_from_blob: ecdsa curve doesn't match type");
			goto badkey;
		}
		if (key->ecdsa != NULL)
			EC_KEY_free(key->ecdsa);
		if ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))
		    == NULL)
			fatal("key_from_blob: EC_KEY_new_by_curve_name failed");
		if ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL)
			fatal("key_from_blob: EC_POINT_new failed");
		if (buffer_get_ecpoint_ret(&b, EC_KEY_get0_group(key->ecdsa),
		    q) == -1) {
			error("key_from_blob: can't read ecdsa key point");
			goto badkey;
		}
		if (key_ec_validate_public(EC_KEY_get0_group(key->ecdsa),
		    q) != 0)
			goto badkey;
		if (EC_KEY_set_public_key(key->ecdsa, q) != 1)
			fatal("key_from_blob: EC_KEY_set_public_key failed");
#ifdef DEBUG_PK
		key_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);
#endif
		break;
#endif
	case KEY_ED25519_CERT:
		(void)buffer_get_string_ptr_ret(&b, NULL); /* Skip nonce */
		/* FALLTHROUGH */
	case KEY_ED25519:
		if ((pk = buffer_get_string_ret(&b, &len)) == NULL) {
			error("key_from_blob: can't read ed25519 key");
			goto badkey;
		}
		if (len != ED25519_PK_SZ) {
			error("key_from_blob: ed25519 len %d != %d",
			    len, ED25519_PK_SZ);
			goto badkey;
		}
		key = key_new(type);
		key->ed25519_pk = pk;
		pk = NULL;
		break;
	case KEY_UNSPEC:
		key = key_new(type);
		break;
	default:
		error("key_from_blob: cannot handle type %s", ktype);
		goto out;
	}
	if (key_is_cert(key) && cert_parse(&b, key, blob, blen) == -1) {
		error("key_from_blob: can't parse cert data");
		goto badkey;
	}
	rlen = buffer_len(&b);
	if (key != NULL && rlen != 0)
		error("key_from_blob: remaining bytes in key blob %d", rlen);
 out:
	free(ktype);
	free(curve);
	free(pk);
	if (q != NULL)
		EC_POINT_free(q);
	buffer_free(&b);
	return key;

 badkey:
	key_free(key);
	key = NULL;
	goto out;
d113 9
a121 1
	return key_from_blob2(blob, blen, 1);
d124 2
a125 2
static int
to_blob(const Key *key, u_char **blobp, u_int *lenp, int force_plain)
d127 3
a129 2
	Buffer b;
	int len, type;
d135 3
a137 2
	if (key == NULL) {
		error("key_to_blob: key == NULL");
d140 4
a143 49
	buffer_init(&b);
	type = force_plain ? key_type_plain(key->type) : key->type;
	switch (type) {
#ifdef WITH_OPENSSL
	case KEY_DSA_CERT_V00:
	case KEY_RSA_CERT_V00:
	case KEY_DSA_CERT:
	case KEY_ECDSA_CERT:
	case KEY_RSA_CERT:
#endif
	case KEY_ED25519_CERT:
		/* Use the existing blob */
		buffer_append(&b, buffer_ptr(&key->cert->certblob),
		    buffer_len(&key->cert->certblob));
		break;
#ifdef WITH_OPENSSL
	case KEY_DSA:
		buffer_put_cstring(&b,
		    key_ssh_name_from_type_nid(type, key->ecdsa_nid));
		buffer_put_bignum2(&b, key->dsa->p);
		buffer_put_bignum2(&b, key->dsa->q);
		buffer_put_bignum2(&b, key->dsa->g);
		buffer_put_bignum2(&b, key->dsa->pub_key);
		break;
	case KEY_ECDSA:
		buffer_put_cstring(&b,
		    key_ssh_name_from_type_nid(type, key->ecdsa_nid));
		buffer_put_cstring(&b, key_curve_nid_to_name(key->ecdsa_nid));
		buffer_put_ecpoint(&b, EC_KEY_get0_group(key->ecdsa),
		    EC_KEY_get0_public_key(key->ecdsa));
		break;
	case KEY_RSA:
		buffer_put_cstring(&b,
		    key_ssh_name_from_type_nid(type, key->ecdsa_nid));
		buffer_put_bignum2(&b, key->rsa->e);
		buffer_put_bignum2(&b, key->rsa->n);
		break;
#endif
	case KEY_ED25519:
		buffer_put_cstring(&b,
		    key_ssh_name_from_type_nid(type, key->ecdsa_nid));
		buffer_put_string(&b, key->ed25519_pk, ED25519_PK_SZ);
		break;
	default:
		error("key_to_blob: unsupported key type %d", key->type);
		buffer_free(&b);
		return 0;
	}
	len = buffer_len(&b);
d145 2
a146 8
		*lenp = len;
	if (blobp != NULL) {
		*blobp = xmalloc(len);
		memcpy(*blobp, buffer_ptr(&b), len);
	}
	explicit_bzero(buffer_ptr(&b), len);
	buffer_free(&b);
	return len;
d150 2
a151 1
key_to_blob(const Key *key, u_char **blobp, u_int *lenp)
d153 3
a155 2
	return to_blob(key, blobp, lenp, 0);
}
d157 8
a164 25
int
key_sign(
    const Key *key,
    u_char **sigp, u_int *lenp,
    const u_char *data, u_int datalen)
{
	switch (key->type) {
#ifdef WITH_OPENSSL
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
	case KEY_DSA:
		return ssh_dss_sign(key, sigp, lenp, data, datalen);
	case KEY_ECDSA_CERT:
	case KEY_ECDSA:
		return ssh_ecdsa_sign(key, sigp, lenp, data, datalen);
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
	case KEY_RSA:
		return ssh_rsa_sign(key, sigp, lenp, data, datalen);
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		return ssh_ed25519_sign(key, sigp, lenp, data, datalen);
	default:
		error("key_sign: invalid key type %d", key->type);
d167 7
a175 4
/*
 * key_verify returns 1 for a correct signature, 0 for an incorrect signature
 * and -1 on error.
 */
d177 1
a177 3
key_verify(
    const Key *key,
    const u_char *signature, u_int signaturelen,
d180 1
a180 2
	if (signaturelen == 0)
		return -1;
d182 5
a186 20
	switch (key->type) {
#ifdef WITH_OPENSSL
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
	case KEY_DSA:
		return ssh_dss_verify(key, signature, signaturelen, data, datalen);
	case KEY_ECDSA_CERT:
	case KEY_ECDSA:
		return ssh_ecdsa_verify(key, signature, signaturelen, data, datalen);
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
	case KEY_RSA:
		return ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#endif
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		return ssh_ed25519_verify(key, signature, signaturelen, data, datalen);
	default:
		error("key_verify: invalid key type %d", key->type);
		return -1;
d188 1
a190 1
/* Converts a private to a public key */
d194 2
a195 1
	Key *pk;
d197 3
a199 67
	pk = xcalloc(1, sizeof(*pk));
	pk->type = k->type;
	pk->flags = k->flags;
	pk->ecdsa_nid = k->ecdsa_nid;
	pk->dsa = NULL;
	pk->ecdsa = NULL;
	pk->rsa = NULL;
	pk->ed25519_pk = NULL;
	pk->ed25519_sk = NULL;

	switch (k->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		key_cert_copy(k, pk);
		/* FALLTHROUGH */
	case KEY_RSA1:
	case KEY_RSA:
		if ((pk->rsa = RSA_new()) == NULL)
			fatal("key_demote: RSA_new failed");
		if ((pk->rsa->e = BN_dup(k->rsa->e)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->rsa->n = BN_dup(k->rsa->n)) == NULL)
			fatal("key_demote: BN_dup failed");
		break;
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		key_cert_copy(k, pk);
		/* FALLTHROUGH */
	case KEY_DSA:
		if ((pk->dsa = DSA_new()) == NULL)
			fatal("key_demote: DSA_new failed");
		if ((pk->dsa->p = BN_dup(k->dsa->p)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->q = BN_dup(k->dsa->q)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->g = BN_dup(k->dsa->g)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->pub_key = BN_dup(k->dsa->pub_key)) == NULL)
			fatal("key_demote: BN_dup failed");
		break;
	case KEY_ECDSA_CERT:
		key_cert_copy(k, pk);
		/* FALLTHROUGH */
	case KEY_ECDSA:
		if ((pk->ecdsa = EC_KEY_new_by_curve_name(pk->ecdsa_nid)) == NULL)
			fatal("key_demote: EC_KEY_new_by_curve_name failed");
		if (EC_KEY_set_public_key(pk->ecdsa,
		    EC_KEY_get0_public_key(k->ecdsa)) != 1)
			fatal("key_demote: EC_KEY_set_public_key failed");
		break;
#endif
	case KEY_ED25519_CERT:
		key_cert_copy(k, pk);
		/* FALLTHROUGH */
	case KEY_ED25519:
		if (k->ed25519_pk != NULL) {
			pk->ed25519_pk = xmalloc(ED25519_PK_SZ);
			memcpy(pk->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);
		}
		break;
	default:
		fatal("key_demote: bad key type %d", k->type);
		break;
	}

	return (pk);
d203 1
a203 1
key_is_cert(const Key *k)
d205 1
a205 4
	if (k == NULL)
		return 0;
	return key_type_is_cert(k->type);
}
d207 3
a209 49
/* Return the cert-less equivalent to a certified key type */
int
key_type_plain(int type)
{
	switch (type) {
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		return KEY_RSA;
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		return KEY_DSA;
	case KEY_ECDSA_CERT:
		return KEY_ECDSA;
	case KEY_ED25519_CERT:
		return KEY_ED25519;
	default:
		return type;
	}
}

/* Convert a plain key to their _CERT equivalent */
int
key_to_certified(Key *k, int legacy)
{
	switch (k->type) {
	case KEY_RSA:
		k->cert = cert_new();
		k->type = legacy ? KEY_RSA_CERT_V00 : KEY_RSA_CERT;
		return 0;
	case KEY_DSA:
		k->cert = cert_new();
		k->type = legacy ? KEY_DSA_CERT_V00 : KEY_DSA_CERT;
		return 0;
	case KEY_ECDSA:
		if (legacy)
			fatal("%s: legacy ECDSA certificates are not supported",
			    __func__);
		k->cert = cert_new();
		k->type = KEY_ECDSA_CERT;
		return 0;
	case KEY_ED25519:
		if (legacy)
			fatal("%s: legacy ED25519 certificates are not "
			    "supported", __func__);
		k->cert = cert_new();
		k->type = KEY_ED25519_CERT;
		return 0;
	default:
		error("%s: key has incorrect type %s", __func__, key_type(k));
d212 1
a214 1
/* Convert a certificate to its raw key equivalent */
d218 5
a222 2
	if (!key_type_is_cert(k->type)) {
		error("%s: key has incorrect type %s", __func__, key_type(k));
a224 3
	cert_free(k->cert);
	k->cert = NULL;
	k->type = key_type_plain(k->type);
a227 1
/* Sign a certified key, (re-)generating the signed certblob. */
d231 1
a231 3
	Buffer principals;
	u_char *ca_blob, *sig_blob, nonce[32];
	u_int i, ca_len, sig_len;
d233 3
a235 2
	if (k->cert == NULL) {
		error("%s: key lacks cert info", __func__);
d238 2
d241 5
a245 5
	if (!key_is_cert(k)) {
		error("%s: certificate has unknown type %d", __func__,
		    k->cert->type);
		return -1;
	}
d247 4
a250 3
	if (!key_type_is_valid_ca(ca->type)) {
		error("%s: CA key has unsupported type %s", __func__,
		    key_type(ca));
d253 2
a255 12
	key_to_blob(ca, &ca_blob, &ca_len);

	buffer_clear(&k->cert->certblob);
	buffer_put_cstring(&k->cert->certblob, key_ssh_name(k));

	/* -v01 certs put nonce first */
	arc4random_buf(&nonce, sizeof(nonce));
	if (!key_cert_is_legacy(k))
		buffer_put_string(&k->cert->certblob, nonce, sizeof(nonce));

	/* XXX this substantially duplicates to_blob(); refactor */
	switch (k->type) {
d257 4
a260 56
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		buffer_put_bignum2(&k->cert->certblob, k->dsa->p);
		buffer_put_bignum2(&k->cert->certblob, k->dsa->q);
		buffer_put_bignum2(&k->cert->certblob, k->dsa->g);
		buffer_put_bignum2(&k->cert->certblob, k->dsa->pub_key);
		break;
	case KEY_ECDSA_CERT:
		buffer_put_cstring(&k->cert->certblob,
		    key_curve_nid_to_name(k->ecdsa_nid));
		buffer_put_ecpoint(&k->cert->certblob,
		    EC_KEY_get0_group(k->ecdsa),
		    EC_KEY_get0_public_key(k->ecdsa));
		break;
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		buffer_put_bignum2(&k->cert->certblob, k->rsa->e);
		buffer_put_bignum2(&k->cert->certblob, k->rsa->n);
		break;
#endif
	case KEY_ED25519_CERT:
		buffer_put_string(&k->cert->certblob,
		    k->ed25519_pk, ED25519_PK_SZ);
		break;
	default:
		error("%s: key has incorrect type %s", __func__, key_type(k));
		buffer_clear(&k->cert->certblob);
		free(ca_blob);
		return -1;
	}

	/* -v01 certs have a serial number next */
	if (!key_cert_is_legacy(k))
		buffer_put_int64(&k->cert->certblob, k->cert->serial);

	buffer_put_int(&k->cert->certblob, k->cert->type);
	buffer_put_cstring(&k->cert->certblob, k->cert->key_id);

	buffer_init(&principals);
	for (i = 0; i < k->cert->nprincipals; i++)
		buffer_put_cstring(&principals, k->cert->principals[i]);
	buffer_put_string(&k->cert->certblob, buffer_ptr(&principals),
	    buffer_len(&principals));
	buffer_free(&principals);

	buffer_put_int64(&k->cert->certblob, k->cert->valid_after);
	buffer_put_int64(&k->cert->certblob, k->cert->valid_before);
	buffer_put_string(&k->cert->certblob,
	    buffer_ptr(&k->cert->critical), buffer_len(&k->cert->critical));

	/* -v01 certs have non-critical options here */
	if (!key_cert_is_legacy(k)) {
		buffer_put_string(&k->cert->certblob,
		    buffer_ptr(&k->cert->extensions),
		    buffer_len(&k->cert->extensions));
	}
d262 3
a264 13
	/* -v00 certs put the nonce at the end */
	if (key_cert_is_legacy(k))
		buffer_put_string(&k->cert->certblob, nonce, sizeof(nonce));

	buffer_put_string(&k->cert->certblob, NULL, 0); /* reserved */
	buffer_put_string(&k->cert->certblob, ca_blob, ca_len);
	free(ca_blob);

	/* Sign the whole mess */
	if (key_sign(ca, &sig_blob, &sig_len, buffer_ptr(&k->cert->certblob),
	    buffer_len(&k->cert->certblob)) != 0) {
		error("%s: signature operation failed", __func__);
		buffer_clear(&k->cert->certblob);
a266 4
	/* Append signature and we are done */
	buffer_put_string(&k->cert->certblob, sig_blob, sig_len);
	free(sig_blob);

d271 1
a271 2
key_cert_check_authority(const Key *k, int want_host, int require_principal,
    const char *name, const char **reason)
d273 1
a273 2
	u_int i, principal_matches;
	time_t now = time(NULL);
d275 3
a277 18
	if (want_host) {
		if (k->cert->type != SSH2_CERT_TYPE_HOST) {
			*reason = "Certificate invalid: not a host certificate";
			return -1;
		}
	} else {
		if (k->cert->type != SSH2_CERT_TYPE_USER) {
			*reason = "Certificate invalid: not a user certificate";
			return -1;
		}
	}
	if (now < 0) {
		error("%s: system clock lies before epoch", __func__);
		*reason = "Certificate invalid: not yet valid";
		return -1;
	}
	if ((u_int64_t)now < k->cert->valid_after) {
		*reason = "Certificate invalid: not yet valid";
a279 23
	if ((u_int64_t)now >= k->cert->valid_before) {
		*reason = "Certificate invalid: expired";
		return -1;
	}
	if (k->cert->nprincipals == 0) {
		if (require_principal) {
			*reason = "Certificate lacks principal list";
			return -1;
		}
	} else if (name != NULL) {
		principal_matches = 0;
		for (i = 0; i < k->cert->nprincipals; i++) {
			if (strcmp(name, k->cert->principals[i]) == 0) {
				principal_matches = 1;
				break;
			}
		}
		if (!principal_matches) {
			*reason = "Certificate invalid: name is not a listed "
			    "principal";
			return -1;
		}
	}
d282 1
d284 11
a294 2
int
key_cert_is_legacy(const Key *k)
d296 7
a302 6
	switch (k->type) {
	case KEY_DSA_CERT_V00:
	case KEY_RSA_CERT_V00:
		return 1;
	default:
		return 0;
d304 1
d307 2
a308 2
#ifdef WITH_OPENSSL
/* XXX: these are really begging for a table-driven approach */
d310 3
a312 1
key_curve_name_to_nid(const char *name)
d314 6
a319 23
	if (strcmp(name, "nistp256") == 0)
		return NID_X9_62_prime256v1;
	else if (strcmp(name, "nistp384") == 0)
		return NID_secp384r1;
	else if (strcmp(name, "nistp521") == 0)
		return NID_secp521r1;

	debug("%s: unsupported EC curve name \"%.100s\"", __func__, name);
	return -1;
}

u_int
key_curve_nid_to_bits(int nid)
{
	switch (nid) {
	case NID_X9_62_prime256v1:
		return 256;
	case NID_secp384r1:
		return 384;
	case NID_secp521r1:
		return 521;
	default:
		error("%s: unsupported EC curve nid %d", __func__, nid);
d322 1
d325 2
a326 2
const char *
key_curve_nid_to_name(int nid)
d328 1
a328 6
	if (nid == NID_X9_62_prime256v1)
		return "nistp256";
	else if (nid == NID_secp384r1)
		return "nistp384";
	else if (nid == NID_secp521r1)
		return "nistp521";
d330 6
a335 2
	error("%s: unsupported EC curve nid %d", __func__, nid);
	return NULL;
d338 2
a339 2
int
key_ec_nid_to_hash_alg(int nid)
d341 12
a352 1
	int kbits = key_curve_nid_to_bits(nid);
a353 9
	if (kbits == 0)
		fatal("%s: invalid nid %d", __func__, nid);
	/* RFC5656 section 6.2.1 */
	if (kbits <= 256)
		return SSH_DIGEST_SHA256;
	else if (kbits <= 384)
		return SSH_DIGEST_SHA384;
	else
		return SSH_DIGEST_SHA512;
d356 2
a357 2
int
key_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)
d359 2
a360 18
	BN_CTX *bnctx;
	EC_POINT *nq = NULL;
	BIGNUM *order, *x, *y, *tmp;
	int ret = -1;

	if ((bnctx = BN_CTX_new()) == NULL)
		fatal("%s: BN_CTX_new failed", __func__);
	BN_CTX_start(bnctx);

	/*
	 * We shouldn't ever hit this case because bignum_get_ecpoint()
	 * refuses to load GF2m points.
	 */
	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
	    NID_X9_62_prime_field) {
		error("%s: group is not a prime field", __func__);
		goto out;
	}
d362 7
a368 5
	/* Q != infinity */
	if (EC_POINT_is_at_infinity(group, public)) {
		error("%s: received degenerate public key (infinity)",
		    __func__);
		goto out;
d370 2
d373 6
a378 24
	if ((x = BN_CTX_get(bnctx)) == NULL ||
	    (y = BN_CTX_get(bnctx)) == NULL ||
	    (order = BN_CTX_get(bnctx)) == NULL ||
	    (tmp = BN_CTX_get(bnctx)) == NULL)
		fatal("%s: BN_CTX_get failed", __func__);

	/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */
	if (EC_GROUP_get_order(group, order, bnctx) != 1)
		fatal("%s: EC_GROUP_get_order failed", __func__);
	if (EC_POINT_get_affine_coordinates_GFp(group, public,
	    x, y, bnctx) != 1)
		fatal("%s: EC_POINT_get_affine_coordinates_GFp", __func__);
	if (BN_num_bits(x) <= BN_num_bits(order) / 2) {
		error("%s: public key x coordinate too small: "
		    "bits(x) = %d, bits(order)/2 = %d", __func__,
		    BN_num_bits(x), BN_num_bits(order) / 2);
		goto out;
	}
	if (BN_num_bits(y) <= BN_num_bits(order) / 2) {
		error("%s: public key y coordinate too small: "
		    "bits(y) = %d, bits(order)/2 = %d", __func__,
		    BN_num_bits(x), BN_num_bits(order) / 2);
		goto out;
	}
d380 7
a386 9
	/* nQ == infinity (n == order of subgroup) */
	if ((nq = EC_POINT_new(group)) == NULL)
		fatal("%s: BN_CTX_tmp failed", __func__);
	if (EC_POINT_mul(group, nq, NULL, public, order, bnctx) != 1)
		fatal("%s: EC_GROUP_mul failed", __func__);
	if (EC_POINT_is_at_infinity(group, nq) != 1) {
		error("%s: received degenerate public key (nQ != infinity)",
		    __func__);
		goto out;
a387 18

	/* x < order - 1, y < order - 1 */
	if (!BN_sub(tmp, order, BN_value_one()))
		fatal("%s: BN_sub failed", __func__);
	if (BN_cmp(x, tmp) >= 0) {
		error("%s: public key x coordinate >= group order - 1",
		    __func__);
		goto out;
	}
	if (BN_cmp(y, tmp) >= 0) {
		error("%s: public key y coordinate >= group order - 1",
		    __func__);
		goto out;
	}
	ret = 0;
 out:
	BN_CTX_free(bnctx);
	EC_POINT_free(nq);
d391 3
a393 2
int
key_ec_validate_private(const EC_KEY *key)
d395 2
a396 23
	BN_CTX *bnctx;
	BIGNUM *order, *tmp;
	int ret = -1;

	if ((bnctx = BN_CTX_new()) == NULL)
		fatal("%s: BN_CTX_new failed", __func__);
	BN_CTX_start(bnctx);

	if ((order = BN_CTX_get(bnctx)) == NULL ||
	    (tmp = BN_CTX_get(bnctx)) == NULL)
		fatal("%s: BN_CTX_get failed", __func__);

	/* log2(private) > log2(order)/2 */
	if (EC_GROUP_get_order(EC_KEY_get0_group(key), order, bnctx) != 1)
		fatal("%s: EC_GROUP_get_order failed", __func__);
	if (BN_num_bits(EC_KEY_get0_private_key(key)) <=
	    BN_num_bits(order) / 2) {
		error("%s: private key too small: "
		    "bits(y) = %d, bits(order)/2 = %d", __func__,
		    BN_num_bits(EC_KEY_get0_private_key(key)),
		    BN_num_bits(order) / 2);
		goto out;
	}
d398 8
a405 6
	/* private < order - 1 */
	if (!BN_sub(tmp, order, BN_value_one()))
		fatal("%s: BN_sub failed", __func__);
	if (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0) {
		error("%s: private key >= group order - 1", __func__);
		goto out;
a406 3
	ret = 0;
 out:
	BN_CTX_free(bnctx);
a408 1
#endif
d410 3
a412 3
#if defined(DEBUG_KEXECDH) || defined(DEBUG_PK)
void
key_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)
d414 2
a415 2
	BIGNUM *x, *y;
	BN_CTX *bnctx;
d417 8
a424 3
	if (point == NULL) {
		fputs("point=(NULL)\n", stderr);
		return;
d426 1
a426 16
	if ((bnctx = BN_CTX_new()) == NULL)
		fatal("%s: BN_CTX_new failed", __func__);
	BN_CTX_start(bnctx);
	if ((x = BN_CTX_get(bnctx)) == NULL || (y = BN_CTX_get(bnctx)) == NULL)
		fatal("%s: BN_CTX_get failed", __func__);
	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
	    NID_X9_62_prime_field)
		fatal("%s: group is not a prime field", __func__);
	if (EC_POINT_get_affine_coordinates_GFp(group, point, x, y, bnctx) != 1)
		fatal("%s: EC_POINT_get_affine_coordinates_GFp", __func__);
	fputs("x=", stderr);
	BN_print_fp(stderr, x);
	fputs("\ny=", stderr);
	BN_print_fp(stderr, y);
	fputs("\n", stderr);
	BN_CTX_free(bnctx);
d429 4
a432 2
void
key_dump_ec_key(const EC_KEY *key)
d434 2
a435 1
	const BIGNUM *exponent;
d437 7
a443 7
	key_dump_ec_point(EC_KEY_get0_group(key), EC_KEY_get0_public_key(key));
	fputs("exponent=", stderr);
	if ((exponent = EC_KEY_get0_private_key(key)) == NULL)
		fputs("(NULL)", stderr);
	else
		BN_print_fp(stderr, EC_KEY_get0_private_key(key));
	fputs("\n", stderr);
d445 1
a445 1
#endif /* defined(DEBUG_KEXECDH) || defined(DEBUG_PK) */
d447 2
a448 2
void
key_private_serialize(const Key *key, Buffer *b)
d450 1
a450 64
	buffer_put_cstring(b, key_ssh_name(key));
	switch (key->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA:
		buffer_put_bignum2(b, key->rsa->n);
		buffer_put_bignum2(b, key->rsa->e);
		buffer_put_bignum2(b, key->rsa->d);
		buffer_put_bignum2(b, key->rsa->iqmp);
		buffer_put_bignum2(b, key->rsa->p);
		buffer_put_bignum2(b, key->rsa->q);
		break;
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		if (key->cert == NULL || buffer_len(&key->cert->certblob) == 0)
			fatal("%s: no cert/certblob", __func__);
		buffer_put_string(b, buffer_ptr(&key->cert->certblob),
		    buffer_len(&key->cert->certblob));
		buffer_put_bignum2(b, key->rsa->d);
		buffer_put_bignum2(b, key->rsa->iqmp);
		buffer_put_bignum2(b, key->rsa->p);
		buffer_put_bignum2(b, key->rsa->q);
		break;
	case KEY_DSA:
		buffer_put_bignum2(b, key->dsa->p);
		buffer_put_bignum2(b, key->dsa->q);
		buffer_put_bignum2(b, key->dsa->g);
		buffer_put_bignum2(b, key->dsa->pub_key);
		buffer_put_bignum2(b, key->dsa->priv_key);
		break;
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		if (key->cert == NULL || buffer_len(&key->cert->certblob) == 0)
			fatal("%s: no cert/certblob", __func__);
		buffer_put_string(b, buffer_ptr(&key->cert->certblob),
		    buffer_len(&key->cert->certblob));
		buffer_put_bignum2(b, key->dsa->priv_key);
		break;
	case KEY_ECDSA:
		buffer_put_cstring(b, key_curve_nid_to_name(key->ecdsa_nid));
		buffer_put_ecpoint(b, EC_KEY_get0_group(key->ecdsa),
		    EC_KEY_get0_public_key(key->ecdsa));
		buffer_put_bignum2(b, EC_KEY_get0_private_key(key->ecdsa));
		break;
	case KEY_ECDSA_CERT:
		if (key->cert == NULL || buffer_len(&key->cert->certblob) == 0)
			fatal("%s: no cert/certblob", __func__);
		buffer_put_string(b, buffer_ptr(&key->cert->certblob),
		    buffer_len(&key->cert->certblob));
		buffer_put_bignum2(b, EC_KEY_get0_private_key(key->ecdsa));
		break;
#endif
	case KEY_ED25519:
		buffer_put_string(b, key->ed25519_pk, ED25519_PK_SZ);
		buffer_put_string(b, key->ed25519_sk, ED25519_SK_SZ);
		break;
	case KEY_ED25519_CERT:
		if (key->cert == NULL || buffer_len(&key->cert->certblob) == 0)
			fatal("%s: no cert/certblob", __func__);
		buffer_put_string(b, buffer_ptr(&key->cert->certblob),
		    buffer_len(&key->cert->certblob));
		buffer_put_string(b, key->ed25519_pk, ED25519_PK_SZ);
		buffer_put_string(b, key->ed25519_sk, ED25519_SK_SZ);
		break;
	}
d453 2
a454 2
Key *
key_private_deserialize(Buffer *blob)
d456 1
a456 140
	char *type_name;
	Key *k = NULL;
	u_char *cert;
	u_int len, pklen, sklen;
	int type;
#ifdef WITH_OPENSSL
	char *curve;
	BIGNUM *exponent;
	EC_POINT *q;
#endif

	type_name = buffer_get_string(blob, NULL);
	type = key_type_from_name(type_name);
	switch (type) {
#ifdef WITH_OPENSSL
	case KEY_DSA:
		k = key_new_private(type);
		buffer_get_bignum2(blob, k->dsa->p);
		buffer_get_bignum2(blob, k->dsa->q);
		buffer_get_bignum2(blob, k->dsa->g);
		buffer_get_bignum2(blob, k->dsa->pub_key);
		buffer_get_bignum2(blob, k->dsa->priv_key);
		break;
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		cert = buffer_get_string(blob, &len);
		if ((k = key_from_blob(cert, len)) == NULL)
			fatal("Certificate parse failed");
		free(cert);
		key_add_private(k);
		buffer_get_bignum2(blob, k->dsa->priv_key);
		break;
	case KEY_ECDSA:
		k = key_new_private(type);
		k->ecdsa_nid = key_ecdsa_nid_from_name(type_name);
		curve = buffer_get_string(blob, NULL);
		if (k->ecdsa_nid != key_curve_name_to_nid(curve))
			fatal("%s: curve names mismatch", __func__);
		free(curve);
		k->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);
		if (k->ecdsa == NULL)
			fatal("%s: EC_KEY_new_by_curve_name failed",
			    __func__);
		q = EC_POINT_new(EC_KEY_get0_group(k->ecdsa));
		if (q == NULL)
			fatal("%s: BN_new failed", __func__);
		if ((exponent = BN_new()) == NULL)
			fatal("%s: BN_new failed", __func__);
		buffer_get_ecpoint(blob,
			EC_KEY_get0_group(k->ecdsa), q);
		buffer_get_bignum2(blob, exponent);
		if (EC_KEY_set_public_key(k->ecdsa, q) != 1)
			fatal("%s: EC_KEY_set_public_key failed",
			    __func__);
		if (EC_KEY_set_private_key(k->ecdsa, exponent) != 1)
			fatal("%s: EC_KEY_set_private_key failed",
			    __func__);
		if (key_ec_validate_public(EC_KEY_get0_group(k->ecdsa),
		    EC_KEY_get0_public_key(k->ecdsa)) != 0)
			fatal("%s: bad ECDSA public key", __func__);
		if (key_ec_validate_private(k->ecdsa) != 0)
			fatal("%s: bad ECDSA private key", __func__);
		BN_clear_free(exponent);
		EC_POINT_free(q);
		break;
	case KEY_ECDSA_CERT:
		cert = buffer_get_string(blob, &len);
		if ((k = key_from_blob(cert, len)) == NULL)
			fatal("Certificate parse failed");
		free(cert);
		key_add_private(k);
		if ((exponent = BN_new()) == NULL)
			fatal("%s: BN_new failed", __func__);
		buffer_get_bignum2(blob, exponent);
		if (EC_KEY_set_private_key(k->ecdsa, exponent) != 1)
			fatal("%s: EC_KEY_set_private_key failed",
			    __func__);
		if (key_ec_validate_public(EC_KEY_get0_group(k->ecdsa),
		    EC_KEY_get0_public_key(k->ecdsa)) != 0 ||
		    key_ec_validate_private(k->ecdsa) != 0)
			fatal("%s: bad ECDSA key", __func__);
		BN_clear_free(exponent);
		break;
	case KEY_RSA:
		k = key_new_private(type);
		buffer_get_bignum2(blob, k->rsa->n);
		buffer_get_bignum2(blob, k->rsa->e);
		buffer_get_bignum2(blob, k->rsa->d);
		buffer_get_bignum2(blob, k->rsa->iqmp);
		buffer_get_bignum2(blob, k->rsa->p);
		buffer_get_bignum2(blob, k->rsa->q);

		/* Generate additional parameters */
		rsa_generate_additional_parameters(k->rsa);
		break;
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		cert = buffer_get_string(blob, &len);
		if ((k = key_from_blob(cert, len)) == NULL)
			fatal("Certificate parse failed");
		free(cert);
		key_add_private(k);
		buffer_get_bignum2(blob, k->rsa->d);
		buffer_get_bignum2(blob, k->rsa->iqmp);
		buffer_get_bignum2(blob, k->rsa->p);
		buffer_get_bignum2(blob, k->rsa->q);
		break;
#endif
	case KEY_ED25519:
		k = key_new_private(type);
		k->ed25519_pk = buffer_get_string(blob, &pklen);
		k->ed25519_sk = buffer_get_string(blob, &sklen);
		if (pklen != ED25519_PK_SZ)
			fatal("%s: ed25519 pklen %d != %d",
			    __func__, pklen, ED25519_PK_SZ);
		if (sklen != ED25519_SK_SZ)
			fatal("%s: ed25519 sklen %d != %d",
			    __func__, sklen, ED25519_SK_SZ);
		break;
	case KEY_ED25519_CERT:
		cert = buffer_get_string(blob, &len);
		if ((k = key_from_blob(cert, len)) == NULL)
			fatal("Certificate parse failed");
		free(cert);
		key_add_private(k);
		k->ed25519_pk = buffer_get_string(blob, &pklen);
		k->ed25519_sk = buffer_get_string(blob, &sklen);
		if (pklen != ED25519_PK_SZ)
			fatal("%s: ed25519 pklen %d != %d",
			    __func__, pklen, ED25519_PK_SZ);
		if (sklen != ED25519_SK_SZ)
			fatal("%s: ed25519 sklen %d != %d",
			    __func__, sklen, ED25519_SK_SZ);
		break;
	default:
		free(type_name);
		buffer_clear(blob);
		return NULL;
	}
	free(type_name);
d458 6
a463 14
	/* enable blinding */
	switch (k->type) {
#ifdef WITH_OPENSSL
	case KEY_RSA:
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
	case KEY_RSA1:
		if (RSA_blinding_on(k->rsa, NULL) != 1) {
			error("%s: RSA_blinding_on failed", __func__);
			key_free(k);
			return NULL;
		}
		break;
#endif
d465 1
a465 1
	return k;
@


1.116
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.115 2014/01/09 23:20:00 djm Exp $ */
d78 1
d81 2
d93 1
d125 1
d147 1
d175 1
d219 1
d241 1
d292 1
d294 1
d301 1
d335 1
d365 4
a368 1
	int nlen, elen, hash_alg = -1;
d387 1
d399 1
d403 1
d409 1
d638 1
d695 1
d705 1
d707 1
d714 1
d735 1
d814 1
d844 1
d876 4
a879 1
	u_int len, bits = 0;
d895 1
d907 2
a919 5
	case KEY_ED25519:
	case KEY_ED25519_CERT:
		if (key->ed25519_pk == NULL)
			return 0;
		break;
d926 6
d970 2
d973 1
a975 1
	{ "ssh-ed25519", "ED25519", KEY_ED25519, 0, 0 },
d991 2
d1117 1
a1126 2
	case KEY_ED25519:
		return 256;	/* XXX */
d1130 3
d1137 1
d1246 1
d1253 1
d1264 6
a1274 5
	case KEY_RSA_CERT_V00:
	case KEY_DSA_CERT_V00:
	case KEY_RSA_CERT:
	case KEY_DSA_CERT:
		fatal("key_generate: cert keys cannot be generated directly");
d1332 1
d1362 1
d1555 1
d1565 1
a1565 4
 badkey:
			key_free(key);
			key = NULL;
			goto out;
d1623 1
d1663 5
d1693 1
d1699 1
d1705 1
d1727 1
d1763 1
d1775 1
d1799 1
d1811 1
d1838 1
d1878 1
d2008 1
d2028 1
d2153 1
d2339 1
d2390 1
d2438 1
d2457 1
a2457 1
	char *type_name, *curve;
a2458 2
	BIGNUM *exponent;
	EC_POINT *q;
d2462 5
d2471 1
d2564 1
d2600 1
d2611 1
@


1.115
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.114 2013/12/29 04:20:04 djm Exp $ */
d236 1
a236 1
			memset(k->ed25519_pk, 0, ED25519_PK_SZ);
d241 1
a241 1
			memset(k->ed25519_sk, 0, ED25519_SK_SZ);
d405 1
a405 1
		memset(blob, 0, len);
d613 1
a613 1
	memset(dgst_raw, 0, dgst_raw_len);
d1690 1
a1690 1
	memset(buffer_ptr(&b), 0, len);
@


1.114
log
@to make sure we don't omit any key types as valid CA keys again,
factor the valid key type check into a key_type_is_valid_ca()
function
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.113 2013/12/29 02:49:52 djm Exp $ */
d54 1
a348 2
	const EVP_MD *md = NULL;
	EVP_MD_CTX ctx;
d352 1
a352 1
	int nlen, elen;
d356 1
d359 1
a359 1
		md = EVP_md5();
d362 1
a362 1
		md = EVP_sha1();
d365 1
a365 1
		md = EVP_sha256();
d368 1
a368 2
		fatal("key_fingerprint_raw: bad digest type %d",
		    dgst_type);
d397 1
a397 1
		fatal("key_fingerprint_raw: bad key type %d", k->type);
d401 4
a404 4
		retval = xmalloc(EVP_MAX_MD_SIZE);
		EVP_DigestInit(&ctx, md);
		EVP_DigestUpdate(&ctx, blob, len);
		EVP_DigestFinal(&ctx, retval, dgst_raw_length);
d407 1
d409 1
a409 1
		fatal("key_fingerprint_raw: blob is null");
d2135 2
a2136 2
const EVP_MD *
key_ec_nid_to_evpmd(int nid)
d2144 1
a2144 1
		return EVP_sha256();
d2146 1
a2146 1
		return EVP_sha384();
d2148 1
a2148 1
		return EVP_sha512();
@


1.113
log
@correct comment for key_drop_cert()
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.112 2013/12/29 02:37:04 djm Exp $ */
d1060 14
d1448 1
a1448 4
	if (key->cert->signature_key->type != KEY_RSA &&
	    key->cert->signature_key->type != KEY_DSA &&
	    key->cert->signature_key->type != KEY_ECDSA &&
	    key->cert->signature_key->type != KEY_ED25519) {
d1929 1
a1929 2
	if (ca->type != KEY_RSA && ca->type != KEY_DSA &&
	    ca->type != KEY_ECDSA && ca->type != KEY_ED25519) {
@


1.112
log
@correct comment for key_to_certified()
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.111 2013/12/29 02:28:10 djm Exp $ */
d1885 1
a1885 1
/* Convert a KEY_RSA_CERT or KEY_DSA_CERT to their raw key equivalent */
@


1.111
log
@allow ed25519 keys to appear as certificate authorities
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.110 2013/12/07 00:19:15 djm Exp $ */
d1852 1
a1852 1
/* Convert a KEY_RSA or KEY_DSA to their _CERT equivalent */
@


1.110
log
@set k->cert = NULL after freeing it
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.109 2013/12/06 13:39:49 markus Exp $ */
d1436 2
a1437 1
	    key->cert->signature_key->type != KEY_ECDSA) {
@


1.109
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.108 2013/12/06 13:34:54 markus Exp $ */
d1893 1
@


1.108
log
@new private key format, bcrypt as KDF by default; details in PROTOCOL.key;
feedback and lots help from djm; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.107 2013/12/06 13:30:08 markus Exp $ */
d41 1
d86 2
d120 4
d168 4
d232 13
d322 4
d383 1
d391 1
d715 1
d721 1
d817 8
d886 5
d938 1
d954 2
d1027 1
a1027 1
key_alg_list(void)
d1036 2
d1073 2
d1206 5
d1302 8
d1472 1
d1474 1
d1566 17
d1600 1
d1635 1
d1661 5
d1707 3
d1741 3
d1763 2
d1806 9
d1816 1
a1816 1
		fatal("key_free: bad key type %d", k->type);
d1844 2
d1871 7
d1888 1
a1888 16
	switch (k->type) {
	case KEY_RSA_CERT_V00:
	case KEY_RSA_CERT:
		cert_free(k->cert);
		k->type = KEY_RSA;
		return 0;
	case KEY_DSA_CERT_V00:
	case KEY_DSA_CERT:
		cert_free(k->cert);
		k->type = KEY_DSA;
		return 0;
	case KEY_ECDSA_CERT:
		cert_free(k->cert);
		k->type = KEY_ECDSA;
		return 0;
	default:
d1892 3
d1897 1
a1897 4
/*
 * Sign a KEY_RSA_CERT, KEY_DSA_CERT or KEY_ECDSA_CERT, (re-)generating
 * the signed certblob
 */
d1917 1
a1917 1
	    ca->type != KEY_ECDSA) {
d1954 4
d2360 12
d2383 1
a2383 1
	u_int len;
d2480 26
@


1.107
log
@move private key (de)serialization to key.c; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.106 2013/12/02 03:09:22 djm Exp $ */
d1831 1
@


1.106
log
@make key_to_blob() return a NULL blob on failure; part of
bz#2175 from Loganaden Velvindron @@ AfriNIC
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.105 2013/10/29 09:42:11 djm Exp $ */
d2201 183
@


1.105
log
@fix potential stack exhaustion caused by nested certificates;
report by Mateusz Kocielski; ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.104 2013/05/19 02:42:42 djm Exp $ */
d1534 4
@


1.104
log
@Standardise logging of supplemental information during userauth. Keys
and ruser is now logged in the auth success/failure message alongside
the local username, remote host/port and protocol in use. Certificates
contents and CA are logged too.

Pushing all logging onto a single line simplifies log analysis as it is
no longer necessary to relate information scattered across multiple log
entries. "I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.103 2013/05/17 00:13:13 djm Exp $ */
d55 1
d998 12
d1364 2
a1365 2
	if ((key->cert->signature_key = key_from_blob(sig_key,
	    sklen)) == NULL) {
d1402 2
a1403 2
Key *
key_from_blob(const u_char *blob, u_int blen)
d1424 4
a1427 1

d1522 6
d1716 1
a1716 10
	switch (k->type) {
	case KEY_RSA_CERT_V00:
	case KEY_DSA_CERT_V00:
	case KEY_RSA_CERT:
	case KEY_DSA_CERT:
	case KEY_ECDSA_CERT:
		return 1;
	default:
		return 0;
	}
@


1.103
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.102 2013/05/10 04:08:01 djm Exp $ */
d558 1
a558 1
key_fingerprint(Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
@


1.102
log
@memleak in cert_free(), wasn't actually freeing the struct;
bz#2096 from shm AT digitalsun.pl
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.101 2013/04/19 01:06:50 djm Exp $ */
d184 1
a184 2
	if (cert->key_id != NULL)
		xfree(cert->key_id);
d186 2
a187 3
		xfree(cert->principals[i]);
	if (cert->principals != NULL)
		xfree(cert->principals);
d190 1
a190 1
	xfree(cert);
d232 1
a232 1
	xfree(k);
d376 1
a376 1
		xfree(blob);
d583 1
a583 1
	xfree(dgst_raw);
d723 1
a723 1
			xfree(blob);
d727 1
a727 1
		xfree(blob);
d862 2
a863 2
	xfree(blob);
	xfree(uu);
d1254 1
a1254 1
			xfree(s);
d1259 1
a1259 1
	xfree(s);
d1381 5
a1385 10
	if (principals != NULL)
		xfree(principals);
	if (critical != NULL)
		xfree(critical);
	if (exts != NULL)
		xfree(exts);
	if (sig_key != NULL)
		xfree(sig_key);
	if (sig != NULL)
		xfree(sig);
d1498 2
a1499 4
	if (ktype != NULL)
		xfree(ktype);
	if (curve != NULL)
		xfree(curve);
d1837 1
a1837 1
		xfree(ca_blob);
d1873 1
a1873 1
	xfree(ca_blob);
d1884 1
a1884 1
	xfree(sig_blob);
@


1.101
log
@add the ability to query supported ciphers, MACs, key type and KEX
algorithms to ssh. Includes some refactoring of KEX and key type handling
to be table-driven; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.100 2013/01/17 23:00:01 djm Exp $ */
d192 1
@


1.100
log
@add support for Key Revocation Lists (KRLs). These are a compact way to
represent lists of revoked keys and certificates, taking as little as
a single bit of incremental cost to revoke a certificate by serial number.
KRLs are loaded via the existing RevokedKeys sshd_config option.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.99 2012/05/23 03:28:28 djm Exp $ */
a869 26
key_type(const Key *k)
{
	switch (k->type) {
	case KEY_RSA1:
		return "RSA1";
	case KEY_RSA:
		return "RSA";
	case KEY_DSA:
		return "DSA";
	case KEY_ECDSA:
		return "ECDSA";
	case KEY_RSA_CERT_V00:
		return "RSA-CERT-V00";
	case KEY_DSA_CERT_V00:
		return "DSA-CERT-V00";
	case KEY_RSA_CERT:
		return "RSA-CERT";
	case KEY_DSA_CERT:
		return "DSA-CERT";
	case KEY_ECDSA_CERT:
		return "ECDSA-CERT";
	}
	return "unknown";
}

const char *
d882 41
d926 5
a930 37
	switch (type) {
	case KEY_RSA:
		return "ssh-rsa";
	case KEY_DSA:
		return "ssh-dss";
	case KEY_RSA_CERT_V00:
		return "ssh-rsa-cert-v00@@openssh.com";
	case KEY_DSA_CERT_V00:
		return "ssh-dss-cert-v00@@openssh.com";
	case KEY_RSA_CERT:
		return "ssh-rsa-cert-v01@@openssh.com";
	case KEY_DSA_CERT:
		return "ssh-dss-cert-v01@@openssh.com";
	case KEY_ECDSA:
		switch (nid) {
		case NID_X9_62_prime256v1:
			return "ecdsa-sha2-nistp256";
		case NID_secp384r1:
			return "ecdsa-sha2-nistp384";
		case NID_secp521r1:
			return "ecdsa-sha2-nistp521";
		default:
			break;
		}
		break;
	case KEY_ECDSA_CERT:
		switch (nid) {
		case NID_X9_62_prime256v1:
			return "ecdsa-sha2-nistp256-cert-v01@@openssh.com";
		case NID_secp384r1:
			return "ecdsa-sha2-nistp384-cert-v01@@openssh.com";
		case NID_secp521r1:
			return "ecdsa-sha2-nistp521-cert-v01@@openssh.com";
		default:
			break;
		}
		break;
d948 50
a1239 52
}

int
key_type_from_name(char *name)
{
	if (strcmp(name, "rsa1") == 0) {
		return KEY_RSA1;
	} else if (strcmp(name, "rsa") == 0) {
		return KEY_RSA;
	} else if (strcmp(name, "dsa") == 0) {
		return KEY_DSA;
	} else if (strcmp(name, "ssh-rsa") == 0) {
		return KEY_RSA;
	} else if (strcmp(name, "ssh-dss") == 0) {
		return KEY_DSA;
	} else if (strcmp(name, "ecdsa") == 0 ||
	    strcmp(name, "ecdsa-sha2-nistp256") == 0 ||
	    strcmp(name, "ecdsa-sha2-nistp384") == 0 ||
	    strcmp(name, "ecdsa-sha2-nistp521") == 0) {
		return KEY_ECDSA;
	} else if (strcmp(name, "ssh-rsa-cert-v00@@openssh.com") == 0) {
		return KEY_RSA_CERT_V00;
	} else if (strcmp(name, "ssh-dss-cert-v00@@openssh.com") == 0) {
		return KEY_DSA_CERT_V00;
	} else if (strcmp(name, "ssh-rsa-cert-v01@@openssh.com") == 0) {
		return KEY_RSA_CERT;
	} else if (strcmp(name, "ssh-dss-cert-v01@@openssh.com") == 0) {
		return KEY_DSA_CERT;
	} else if (strcmp(name, "ecdsa-sha2-nistp256-cert-v01@@openssh.com") == 0 ||
	    strcmp(name, "ecdsa-sha2-nistp384-cert-v01@@openssh.com") == 0 ||
	    strcmp(name, "ecdsa-sha2-nistp521-cert-v01@@openssh.com") == 0)
		return KEY_ECDSA_CERT;

	debug2("key_type_from_name: unknown key type '%s'", name);
	return KEY_UNSPEC;
}

int
key_ecdsa_nid_from_name(const char *name)
{
	if (strcmp(name, "ecdsa-sha2-nistp256") == 0 ||
	    strcmp(name, "ecdsa-sha2-nistp256-cert-v01@@openssh.com") == 0)
		return NID_X9_62_prime256v1;
	if (strcmp(name, "ecdsa-sha2-nistp384") == 0 ||
	    strcmp(name, "ecdsa-sha2-nistp384-cert-v01@@openssh.com") == 0)
		return NID_secp384r1;
	if (strcmp(name, "ecdsa-sha2-nistp521") == 0 ||
	    strcmp(name, "ecdsa-sha2-nistp521-cert-v01@@openssh.com") == 0)
		return NID_secp521r1;

	debug2("%s: unknown/non-ECDSA key type '%s'", __func__, name);
	return -1;
@


1.99
log
@add support for RFC6594 SSHFP DNS records for ECDSA key types.
patch from bugzilla-m67 AT nulld.me in bz#1978; ok + tweak markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.98 2011/10/18 04:58:26 djm Exp $ */
d54 2
d317 2
a318 1
key_fingerprint_raw(Key *k, enum fp_type dgst_type, u_int *dgst_raw_length)
d325 1
a325 1
	int nlen, elen, otype;
d363 1
a363 4
		otype = k->type;
		k->type = key_type_plain(k->type);
		key_to_blob(k, &blob, &len);
		k->type = otype;
d1533 2
a1534 2
int
key_to_blob(const Key *key, u_char **blobp, u_int *lenp)
d1537 1
a1537 1
	int len;
d1544 2
a1545 1
	switch (key->type) {
d1556 2
a1557 1
		buffer_put_cstring(&b, key_ssh_name(key));
d1564 2
a1565 1
		buffer_put_cstring(&b, key_ssh_name(key));
d1571 2
a1572 1
		buffer_put_cstring(&b, key_ssh_name(key));
d1594 6
d1970 1
a1970 1
key_cert_is_legacy(Key *k)
@


1.98
log
@remove explict search for \0 in packet strings, this job is now done
implicitly by buffer_get_cstring; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.97 2011/05/17 07:13:31 djm Exp $ */
d332 3
@


1.97
log
@fatal() if asked to generate a legacy ECDSA cert (these don't exist)
and fix the regress test that was trying to generate them :)
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.96 2011/02/04 00:44:21 djm Exp $ */
a1309 5
		goto out;
	}

	if (kidlen != strlen(key->cert->key_id)) {
		error("%s: key ID contains \\0 character", __func__);
@


1.96
log
@fix uninitialised nonce variable; reported by Mateusz Kocielski
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.95 2010/11/10 01:33:07 djm Exp $ */
d1757 3
@


1.95
log
@use only libcrypto APIs that are retained with OPENSSL_NO_DEPRECATED.
these have been around for years by this time. ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.94 2010/10/28 11:22:09 djm Exp $ */
d1826 2
a1827 2
	if (!key_cert_is_legacy(k)) {
		arc4random_buf(&nonce, sizeof(nonce));
a1828 1
	}
@


1.94
log
@fix a possible NULL deref on loading a corrupt ECDH key

store ECDH group information in private keys files as "named groups"
rather than as a set of explicit group parameters (by setting
the OPENSSL_EC_NAMED_CURVE flag). This makes for shorter key files and
retrieves the group's OpenSSL NID that we need for various things.
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.93 2010/09/09 10:45:45 djm Exp $ */
d985 2
a986 1
	RSA *private;
a987 1
	private = RSA_generate_key(bits, RSA_F4, NULL, NULL);
d989 8
a996 1
		fatal("rsa_generate_private_key: key generation failed.");
d1003 1
a1003 1
	DSA *private = DSA_generate_parameters(bits, NULL, 0, NULL, NULL, NULL, NULL);
d1006 4
a1009 1
		fatal("dsa_generate_private_key: DSA_generate_parameters failed");
d1011 1
a1011 3
		fatal("dsa_generate_private_key: DSA_generate_key failed.");
	if (private == NULL)
		fatal("dsa_generate_private_key: NULL.");
@


1.93
log
@ECDH/ECDSA compliance fix: these methods vary the hash function they use
(SHA256/384/512) depending on the length of the curve in use. The previous
code incorrectly used SHA256 in all cases.

This fix will cause authentication failure when using 384 or 521-bit curve
keys if one peer hasn't been upgraded and the other has. (256-bit curve
keys work ok). In particular you may need to specify HostkeyAlgorithms
when connecting to a server that has not been upgraded from an upgraded
client.

ok naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.92 2010/08/31 11:54:45 djm Exp $ */
a1021 4
/*
 * This is horrid, but OpenSSL's PEM_read_PrivateKey seems not to restore
 * the EC_GROUP nid when loading a key...
 */
d1023 1
a1023 1
key_ecdsa_group_to_nid(const EC_GROUP *g)
d1032 1
d1035 1
d1037 10
d1053 1
a1053 2
		if (EC_GROUP_cmp(g, eg, bnctx) == 0) {
			EC_GROUP_free(eg);
a1054 1
		}
d1059 6
d1079 1
@


1.92
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.91 2010/08/31 09:58:37 djm Exp $ */
d977 1
a977 11
		switch (k->ecdsa_nid) {
		case NID_X9_62_prime256v1:
			return 256;
		case NID_secp384r1:
			return 384;
		case NID_secp521r1:
			return 521;
		default:
			break;
		}
		break;
d1950 1
d1965 16
d1993 16
@


1.91
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.90 2010/07/13 23:13:16 djm Exp $ */
d77 2
d110 4
d154 4
d213 6
d256 2
d278 18
d347 1
d354 1
d649 1
a649 1
	int len, n, type;
d681 1
d685 1
d694 5
d735 6
d771 11
d838 5
d876 2
d886 2
d905 2
a906 2
const char *
key_ssh_name(const Key *k)
d908 1
a908 1
	switch (k->type) {
d921 24
d949 13
d975 13
d1017 63
d1088 3
d1167 10
d1208 5
d1221 5
a1225 1
	}
d1231 17
d1368 2
a1369 1
	    key->cert->signature_key->type != KEY_DSA) {
d1409 2
a1410 2
	int rlen, type;
	char *ktype = NULL;
d1412 1
d1425 2
d1464 35
d1516 4
d1539 1
d1552 6
d1591 3
d1622 3
d1644 1
d1646 1
d1679 10
d1707 1
d1725 2
d1745 4
d1770 4
d1780 4
a1783 1
/* Sign a KEY_RSA_CERT or KEY_DSA_CERT, (re-)generating the signed certblob */
d1802 2
a1803 1
	if (ca->type != KEY_RSA && ca->type != KEY_DSA) {
d1815 1
a1815 1
	if (k->type == KEY_DSA_CERT || k->type == KEY_RSA_CERT) {
d1828 7
d1848 1
a1848 1
	if (k->type == KEY_DSA_CERT || k->type == KEY_RSA_CERT)
d1867 1
a1867 1
	if (k->type == KEY_DSA_CERT || k->type == KEY_RSA_CERT) {
d1874 1
a1874 1
	if (k->type == KEY_DSA_CERT_V00 || k->type == KEY_RSA_CERT_V00)
d1959 198
@


1.90
log
@s/timing_safe_cmp/timingsafe_bcmp/g
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.89 2010/07/13 11:52:06 djm Exp $ */
d1066 1
a1066 1
	    (key->cert->key_id = buffer_get_string_ret(b, &kidlen)) == NULL ||
d1104 1
a1104 1
		if ((principal = buffer_get_string_ret(&tmp, &plen)) == NULL) {
a1107 5
		if (strlen(principal) != plen) {
			error("%s: Principal contains \\0 character",
			    __func__);
			goto out;
		}
d1194 1
a1194 1
	if ((ktype = buffer_get_string_ret(&b, NULL)) == NULL) {
@


1.89
log
@implement a timing_safe_cmp() function to compare memory without leaking
timing information by short-circuiting like memcmp() and use it for
some of the more sensitive comparisons (though nothing high-value was
readily attackable anyway); "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.88 2010/05/07 11:30:29 djm Exp $ */
d227 1
a227 1
	if (timing_safe_cmp(buffer_ptr(&a->certblob), buffer_ptr(&b->certblob),
@


1.88
log
@add some optional indirection to matching of principal names listed
in certificates. Currently, a certificate must include the a user's name
to be accepted for authentication. This change adds the ability to
specify a list of certificate principal names that are acceptable.

When authenticating using a CA trusted through ~/.ssh/authorized_keys,
this adds a new principals="name1[,name2,...]" key option.

For CAs listed through sshd_config's TrustedCAKeys option, a new config
option "AuthorizedPrincipalsFile" specifies a per-user file containing
the list of acceptable names.

If either option is absent, the current behaviour of requiring the
username to appear in principals continues to apply.

These options are useful for role accounts, disjoint account namespaces
and "user@@realm"-style naming policies in certificates.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.87 2010/04/16 01:47:26 djm Exp $ */
d51 1
d227 1
a227 1
	if (memcmp(buffer_ptr(&a->certblob), buffer_ptr(&b->certblob),
@


1.87
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.86 2010/03/15 19:40:02 stevesk Exp $ */
d1622 1
a1622 1
	} else {
@


1.86
log
@also print certificate type (user or host) for ssh-keygen -L
ok djm kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.85 2010/03/04 01:44:57 djm Exp $ */
d60 2
a61 1
	buffer_init(&cert->constraints);
d82 1
d93 1
d126 1
d142 1
d169 2
a170 1
	buffer_free(&cert->constraints);
d189 1
d196 1
d245 1
d251 1
d313 2
d642 2
d770 1
d776 1
d808 4
d841 4
d846 1
a846 1
		return "ssh-rsa-cert-v00@@openssh.com";
d848 1
a848 1
		return "ssh-dss-cert-v00@@openssh.com";
d859 1
d863 1
d907 2
d939 4
a942 2
	buffer_append(&to->constraints, buffer_ptr(&from->constraints),
	    buffer_len(&from->constraints));
d944 1
d970 1
d981 1
d1011 4
d1016 1
a1016 1
	} else if (strcmp(name, "ssh-dss-cert-v00@@openssh.com") == 0) {
d1048 2
a1049 2
	u_char *principals, *constraints, *sig_key, *sig;
	u_int signed_len, plen, clen, sklen, slen, kidlen;
d1053 2
d1061 4
a1064 2
	principals = constraints = sig_key = sig = NULL;
	if (buffer_get_int_ret(&key->cert->type, b) != 0 ||
d1069 4
a1072 3
	    (constraints = buffer_get_string_ret(b, &clen)) == NULL ||
	    /* skip nonce */ buffer_get_string_ptr_ret(b, NULL) == NULL ||
	    /* skip reserved */ buffer_get_string_ptr_ret(b, NULL) == NULL ||
d1119 2
a1120 2
	buffer_append(&key->cert->constraints, constraints, clen);
	buffer_append(&tmp, constraints, clen);
d1125 13
a1137 1
			error("%s: Constraints data invalid", __func__);
d1174 4
a1177 2
	if (constraints != NULL)
		xfree(constraints);
d1206 3
d1210 1
a1210 1
	case KEY_RSA_CERT:
d1224 3
d1228 1
a1228 1
	case KEY_DSA_CERT:
d1274 2
d1318 1
d1322 1
d1346 1
d1350 1
d1373 1
d1386 1
d1413 11
a1423 2
	return k != NULL &&
	    (k->type == KEY_RSA_CERT || k->type == KEY_DSA_CERT);
d1431 1
d1434 1
d1444 1
a1444 1
key_to_certified(Key *k)
d1449 1
a1449 1
		k->type = KEY_RSA_CERT;
d1453 1
a1453 1
		k->type = KEY_DSA_CERT;
d1466 1
d1471 1
d1512 6
d1519 1
d1526 1
d1538 4
d1555 12
a1566 2
	    buffer_ptr(&k->cert->constraints),
	    buffer_len(&k->cert->constraints));
a1567 2
	arc4random_buf(&nonce, sizeof(nonce));
	buffer_put_string(&k->cert->certblob, nonce, sizeof(nonce));
d1637 12
@


1.85
log
@use buffer_get_string_ptr_ret() where we are checking the return
value explicitly instead of the fatal()-causing buffer_get_string_ptr()
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.84 2010/03/03 01:44:36 djm Exp $ */
d798 13
@


1.84
log
@reject strings with embedded ASCII nul chars in certificate key IDs,
principal names and constraints
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.83 2010/02/26 20:29:54 djm Exp $ */
d1068 2
a1069 2
		if (buffer_get_string_ptr(&tmp, NULL) == NULL ||
		    buffer_get_string_ptr(&tmp, NULL) == NULL) {
@


1.83
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.82 2010/01/13 01:10:56 dtucker Exp $ */
d999 1
a999 1
	u_int signed_len, plen, clen, sklen, slen;
d1011 1
a1011 1
	    (key->cert->key_id = buffer_get_string_ret(b, NULL)) == NULL ||
d1023 5
d1045 1
a1045 1
			error("Too many principals");
d1048 7
a1054 2
		if ((principal = buffer_get_string_ret(&tmp, NULL)) == NULL) {
			error("Principals data invalid");
d1070 1
a1070 1
			error("Constraints data invalid");
d1078 1
a1078 1
		error("Signature key invalid");
d1083 1
a1083 1
		error("Invalid signature key type %s (%d)",
d1092 1
d1095 1
a1095 1
		error("Invalid signature on certificate");
d1098 2
a1099 1
		error("Certificate signature verification failed");
a1101 2

	ret = 0;
@


1.82
log
@Ignore and log any Protocol 1 keys where the claimed size is not equal to
the actual size.  Noted by Derek Martin, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.81 2009/12/11 18:16:33 markus Exp $ */
d51 15
d77 1
d81 1
d91 1
d110 4
d117 2
a118 2
Key *
key_new_private(int type)
a119 1
	Key *k = key_new(type);
d123 1
d138 1
d147 8
d158 17
d183 1
d189 1
d200 6
d209 19
d229 1
a229 1
key_equal(const Key *a, const Key *b)
d231 2
a232 1
	if (a == NULL || b == NULL || a->type != b->type)
d234 1
d237 1
d242 1
d255 12
d268 1
a268 2
key_fingerprint_raw(const Key *k, enum fp_type dgst_type,
    u_int *dgst_raw_length)
d275 1
a275 1
	int nlen, elen;
d303 8
d505 1
a505 1
key_fingerprint(const Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
d630 2
d676 12
a687 1
		if (ret->type == KEY_RSA) {
a691 1
			success = 1;
d695 2
a696 1
		} else {
a700 1
			success = 1;
d705 1
d732 15
a746 1
	if (key->type == KEY_RSA1 && key->rsa != NULL) {
d751 24
a774 16
		    write_bignum(f, key->rsa->n)) {
			success = 1;
		} else {
			error("key_write: failed for RSA key");
		}
	} else if ((key->type == KEY_DSA && key->dsa != NULL) ||
	    (key->type == KEY_RSA && key->rsa != NULL)) {
		key_to_blob(key, &blob, &len);
		uu = xmalloc(2*len);
		n = uuencode(blob, len, uu, 2*len);
		if (n > 0) {
			fprintf(f, "%s %s", key_ssh_name(key), uu);
			success = 1;
		}
		xfree(blob);
		xfree(uu);
d776 3
d792 4
d808 4
d822 1
d825 1
d868 3
d878 42
d926 1
d936 1
d946 2
d964 4
d995 111
d1128 1
d1133 1
d1143 1
d1150 1
a1150 3
			key_free(key);
			key = NULL;
			goto out;
d1163 4
d1189 6
d1231 1
d1234 1
d1257 1
d1260 1
d1282 3
d1294 3
d1315 196
@


1.81
log
@switch from 35 to the more common value of RSA_F4 == (2**16)+1 == 65537
for the RSA public exponent; discussed with provos; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.80 2008/10/10 05:00:12 stevesk Exp $ */
d521 6
@


1.80
log
@typo in error message; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.79 2008/07/25 07:05:16 grunk Exp $ */
d684 1
a684 1
	private = RSA_generate_key(bits, 35, NULL, NULL);
@


1.79
log
@In random art visualization, make sure to use the end marker only at the
end.  Initial diff by Dirk Loss, tweaks and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.78 2008/07/07 23:32:51 stevesk Exp $ */
d427 1
a427 1
		fatal("key_fingerprint_ex: bad digest representation %d",
@


1.78
log
@/*NOTREACHED*/ for lint warning:
  warning: function key_equal falls off bottom without returning value
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.77 2008/06/25 11:13:43 otto Exp $ */
d368 2
a369 1
			field[x][y]++;
@


1.77
log
@add key length to visual fingerprint; zap magical constants;
ok grunk@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.76 2008/06/12 22:03:36 grunk Exp $ */
d173 1
@


1.76
log
@add my copyright, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.75 2008/06/12 06:32:59 grunk Exp $ */
d377 1
a377 1
	snprintf(retval, 10, "+--[%4s]", key_type(k));
d381 1
a381 1
	for (i = 0; i < FLDSIZE_X - 8; i++)
@


1.75
log
@We already mark the start of the worm, now also mark the end of the worm
in our random art drawings.
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.74 2008/06/12 05:42:46 grunk Exp $ */
d14 1
@


1.74
log
@supply the key type (rsa1, rsa, dsa) as a caption in the frame of the
random art.  while there, stress the fact that the field base should at
least be 8 characters for the pictures to make sense.

comment and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.73 2008/06/12 00:13:13 otto Exp $ */
d335 1
a335 1
	char	*augmentation_string = " .o+=*BOX@@%&#/^S";
d370 4
a373 1
	field[FLDSIZE_X / 2][FLDSIZE_Y / 2] = len;
@


1.73
log
@use an odd number of rows and columns and a separate start marker, looks
better; ok grunk@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.72 2008/06/11 23:51:57 grunk Exp $ */
d318 10
a327 2
#define	FLDSIZE_Y	(8 + 1)
#define	FLDSIZE_X	(8 * 2 + 1)
d329 1
a329 1
key_fingerprint_randomart(u_char *dgst_raw, u_int dgst_raw_len)
d373 2
a374 1
	p = retval;
d377 1
a377 2
	*p++ = '+';
	for (i = 0; i < FLDSIZE_X; i++)
d418 1
a418 1
		retval = key_fingerprint_randomart(dgst_raw, dgst_raw_len);
@


1.72
log
@#define statements that are not atoms need braces around them, else they
will cause trouble in some cases.
Also do a computation of -1 once, and not in a loop several times.

spotted by otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.71 2008/06/11 23:02:22 otto Exp $ */
d318 2
a319 2
#define	FLDSIZE_Y	8
#define	FLDSIZE_X	(FLDSIZE_Y * 2)
d327 1
a327 1
	char	*augmentation_string = " .o+=*BOX@@%&#/^";
a339 1
	field[x][y] = 1;
d362 1
@


1.71
log
@simpler way of computing the augmentations; ok grunk@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.70 2008/06/11 21:01:35 grunk Exp $ */
d318 2
a319 2
#define	FLDSIZE_Y	 8
#define	FLDSIZE_X	FLDSIZE_Y * 2
d332 1
a332 1
	size_t	 len = strlen(augmentation_string);
d378 1
a378 1
			*p++ = augmentation_string[MIN(field[x][y], len - 1)];
@


1.70
log
@Introduce SSH Fingerprint ASCII Visualization, a technique inspired by the
graphical hash visualization schemes known as "random art", and by
Dan Kaminsky's musings on the subject during a BlackOp talk at the
23C3 in Berlin.

Scientific publication (original paper):
"Hash Visualization: a New Technique to improve Real-World Security",
Perrig A. and Song D., 1999, International Workshop on Cryptographic
Techniques and E-Commerce (CrypTEC '99)
http://sparrow.ece.cmu.edu/~adrian/projects/validation/validation.pdf

The algorithm used here is a worm crawling over a discrete plane,
leaving a trace (augmenting the field) everywhere it goes.
Movement is taken from dgst_raw 2bit-wise.  Bumping into walls
makes the respective movement vector be ignored for this turn,
thus switching to the other color of the chessboard.
Graphs are not unambiguous for now, because circles in graphs can be
walked in either direction.

discussions with several people,
help, corrections and ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.69 2007/07/12 05:48:05 ray Exp $ */
d329 1
a329 1
	char	 field[FLDSIZE_X][FLDSIZE_Y];
d332 1
d337 1
a337 1
	memset(field, ' ', FLDSIZE_X * FLDSIZE_Y * sizeof(char));
d340 1
a340 1
	field[x][y] = '.';
d359 1
a359 4
			p = strchr(augmentation_string, field[x][y]);
			if (*++p != '\0')
				field[x][y] = *p;

d378 1
a378 1
			*p++ = field[x][y];
@


1.69
log
@Delint: remove some unreachable statements, from Bret Lambert.

OK markus@@ and dtucker@@.
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.68 2006/11/06 21:25:28 markus Exp $ */
d36 1
d295 99
d410 3
@


1.68
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.67 2006/08/03 03:34:42 deraadt Exp $ */
a169 1
		break;
a170 1
	return 0;
@


1.67
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.66 2006/08/01 23:22:47 stevesk Exp $ */
d617 5
a621 4
		BN_copy(n->dsa->p, k->dsa->p);
		BN_copy(n->dsa->q, k->dsa->q);
		BN_copy(n->dsa->g, k->dsa->g);
		BN_copy(n->dsa->pub_key, k->dsa->pub_key);
d626 3
a628 2
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
@


1.67.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.68 2006/11/06 21:25:28 markus Exp $ */
d617 4
a620 5
		if ((BN_copy(n->dsa->p, k->dsa->p) == NULL) ||
		    (BN_copy(n->dsa->q, k->dsa->q) == NULL) ||
		    (BN_copy(n->dsa->g, k->dsa->g) == NULL) ||
		    (BN_copy(n->dsa->pub_key, k->dsa->pub_key) == NULL))
			fatal("key_from_private: BN_copy failed");
d625 2
a626 3
		if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
		    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
			fatal("key_from_private: BN_copy failed");
@


1.66
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.65 2006/07/22 20:48:23 stevesk Exp $ */
d35 2
a36 1
#include "includes.h"
a47 1
#include "bufaux.h"
@


1.65
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.64 2006/03/25 13:17:02 djm Exp $ */
d39 1
@


1.64
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d38 2
@


1.63
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.62
log
@djm did a typo
@
text
@d52 1
a52 1
	k = xmalloc(sizeof(*k));
a53 1
	k->flags = 0;
d233 1
a233 2
	retval = xmalloc(dgst_raw_len * 3 + 1);
	retval[0] = '\0';
d255 1
a255 1
	retval = xmalloc(sizeof(char) * (rounds*6));
d825 1
a825 1
	pk = xmalloc(sizeof(*pk));
@


1.61
log
@in a switch (), break after return or goto is stupid
@
text
@d126 1
a126 1
		fatal("key_free: key is NULL);
@


1.60
log
@(really) last of the Coverity diffs: avoid possible NULL deref in
key_free. via elad AT netbsd.org; markus@@ ok
@
text
@a158 1
		break;
a164 1
		break;
a210 1
		break;
a530 1
		break;
a532 1
		break;
a534 1
		break;
a544 1
		break;
a546 1
		break;
a557 1
		break;
a559 1
		break;
d568 1
d579 1
a788 1
		break;
a790 1
		break;
a793 1
		break;
a812 1
		break;
a814 1
		break;
a817 1
		break;
@


1.59
log
@RCSID() can die
@
text
@d125 2
@


1.58
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@a34 1
RCSID("$OpenBSD: key.c,v 1.57 2004/10/29 23:57:05 djm Exp $");
@


1.58.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: key.c,v 1.67 2006/08/03 03:34:42 deraadt Exp $ */
d34 2
a35 2

#include <sys/types.h>
a38 3
#include <stdio.h>
#include <string.h>

d44 1
d53 1
a53 1
	k = xcalloc(1, sizeof(*k));
d55 1
a125 2
	if (k == NULL)
		fatal("key_free: key is NULL");
d158 1
d165 1
d212 1
d236 2
a237 1
	retval = xcalloc(1, dgst_raw_len * 3 + 1);
d259 1
a259 1
	retval = xcalloc((rounds * 6), sizeof(char));
d533 1
d536 1
d539 1
d550 1
d553 1
d565 1
d568 1
a576 1

a586 1

d796 1
d799 1
d803 1
d823 1
d826 1
d830 1
d840 1
a840 1
	pk = xcalloc(1, sizeof(*pk));
@


1.58.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.68 2006/11/06 21:25:28 markus Exp $ */
d617 4
a620 5
		if ((BN_copy(n->dsa->p, k->dsa->p) == NULL) ||
		    (BN_copy(n->dsa->q, k->dsa->q) == NULL) ||
		    (BN_copy(n->dsa->g, k->dsa->g) == NULL) ||
		    (BN_copy(n->dsa->pub_key, k->dsa->pub_key) == NULL))
			fatal("key_from_private: BN_copy failed");
d625 2
a626 3
		if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
		    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
			fatal("key_from_private: BN_copy failed");
@


1.58.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: key.c,v 1.67 2006/08/03 03:34:42 deraadt Exp $ */
d34 2
a35 2

#include <sys/types.h>
a38 3
#include <stdio.h>
#include <string.h>

d44 1
d53 1
a53 1
	k = xcalloc(1, sizeof(*k));
d55 1
a125 2
	if (k == NULL)
		fatal("key_free: key is NULL");
d158 1
d165 1
d212 1
d236 2
a237 1
	retval = xcalloc(1, dgst_raw_len * 3 + 1);
d259 1
a259 1
	retval = xcalloc((rounds * 6), sizeof(char));
d533 1
d536 1
d539 1
d550 1
d553 1
d565 1
d568 1
a576 1

a586 1

d796 1
d799 1
d803 1
d823 1
d826 1
d830 1
d840 1
a840 1
	pk = xcalloc(1, sizeof(*pk));
@


1.58.4.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.68 2006/11/06 21:25:28 markus Exp $ */
d617 4
a620 5
		if ((BN_copy(n->dsa->p, k->dsa->p) == NULL) ||
		    (BN_copy(n->dsa->q, k->dsa->q) == NULL) ||
		    (BN_copy(n->dsa->g, k->dsa->g) == NULL) ||
		    (BN_copy(n->dsa->pub_key, k->dsa->pub_key) == NULL))
			fatal("key_from_private: BN_copy failed");
d625 2
a626 3
		if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
		    (BN_copy(n->rsa->e, k->rsa->e) == NULL))
			fatal("key_from_private: BN_copy failed");
@


1.57
log
@use new buffer API to avoid fatal errors on corrupt keys in authorized_keys
files; ok markus@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.56 2004/07/28 09:40:29 markus Exp $");
d234 1
a234 1
	int i;
@


1.57.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.58 2005/06/17 02:44:32 djm Exp $");
d234 1
a234 1
	u_int i;
@


1.56
log
@more s/illegal/invalid/
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.55 2003/11/10 16:23:41 jakob Exp $");
a683 1
	char *ktype;
d685 1
d693 5
a697 1
	ktype = buffer_get_string(&b, NULL);
d703 7
a709 2
		buffer_get_bignum2(&b, key->rsa->e);
		buffer_get_bignum2(&b, key->rsa->n);
d716 9
a724 4
		buffer_get_bignum2(&b, key->dsa->p);
		buffer_get_bignum2(&b, key->dsa->q);
		buffer_get_bignum2(&b, key->dsa->g);
		buffer_get_bignum2(&b, key->dsa->pub_key);
d734 1
a734 1
		break;
d739 3
a741 1
	xfree(ktype);
@


1.56.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.57 2004/10/29 23:57:05 djm Exp $");
d684 1
a685 1
	char *ktype = NULL;
d693 1
a693 5
	if ((ktype = buffer_get_string_ret(&b, NULL)) == NULL) {
		error("key_from_blob: can't read key type");
		goto out;
	}

d699 2
a700 7
		if (buffer_get_bignum2_ret(&b, key->rsa->e) == -1 ||
		    buffer_get_bignum2_ret(&b, key->rsa->n) == -1) {
			error("key_from_blob: can't read rsa key");
			key_free(key);
			key = NULL;
			goto out;
		}
d707 4
a710 9
		if (buffer_get_bignum2_ret(&b, key->dsa->p) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->q) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->g) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->pub_key) == -1) {
			error("key_from_blob: can't read dsa key");
			key_free(key);
			key = NULL;
			goto out;
		}
d720 1
a720 1
		goto out;
d725 1
a725 3
 out:
	if (ktype != NULL)
		xfree(ktype);
@


1.56.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.58 2005/06/17 02:44:32 djm Exp $");
d234 1
a234 1
	u_int i;
@


1.55
log
@constify. ok markus@@ & djm@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.54 2003/07/09 13:58:19 avsm Exp $");
d785 1
a785 1
		error("key_sign: illegal key type %d", key->type);
d812 1
a812 1
		error("key_verify: illegal key type %d", key->type);
@


1.55.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.56 2004/07/28 09:40:29 markus Exp $");
d785 1
a785 1
		error("key_sign: invalid key type %d", key->type);
d812 1
a812 1
		error("key_verify: invalid key type %d", key->type);
@


1.55.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.57 2004/10/29 23:57:05 djm Exp $");
d684 1
a685 1
	char *ktype = NULL;
d693 1
a693 5
	if ((ktype = buffer_get_string_ret(&b, NULL)) == NULL) {
		error("key_from_blob: can't read key type");
		goto out;
	}

d699 2
a700 7
		if (buffer_get_bignum2_ret(&b, key->rsa->e) == -1 ||
		    buffer_get_bignum2_ret(&b, key->rsa->n) == -1) {
			error("key_from_blob: can't read rsa key");
			key_free(key);
			key = NULL;
			goto out;
		}
d707 4
a710 9
		if (buffer_get_bignum2_ret(&b, key->dsa->p) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->q) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->g) == -1 ||
		    buffer_get_bignum2_ret(&b, key->dsa->pub_key) == -1) {
			error("key_from_blob: can't read dsa key");
			key_free(key);
			key = NULL;
			goto out;
		}
d720 1
a720 1
		goto out;
d725 1
a725 3
 out:
	if (ktype != NULL)
		xfree(ktype);
@


1.54
log
@minor tweak: when generating the hex fingerprint, give strlcat the full bound to the buffer, and add a comment below explaining why the zero-termination is one less than the bound.
markus@@ ok
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.53 2003/06/24 08:23:46 markus Exp $");
d146 1
d148 1
a148 1
key_equal(Key *a, Key *b)
d174 2
a175 1
key_fingerprint_raw(Key *k, enum fp_type dgst_type, u_int *dgst_raw_length)
d297 1
a297 1
key_fingerprint(Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
d495 1
a495 1
key_write(Key *key, FILE *f)
d527 2
a528 2
char *
key_type(Key *k)
d544 2
a545 2
char *
key_ssh_name(Key *k)
d559 1
a559 1
key_size(Key *k)
d616 1
a616 1
key_from_private(Key *k)
d681 1
a681 1
key_from_blob(u_char *blob, u_int blen)
d731 1
a731 1
key_to_blob(Key *key, u_char **blobp, u_int *lenp)
d773 1
a773 1
    Key *key,
d775 1
a775 1
    u_char *data, u_int datalen)
d797 3
a799 3
    Key *key,
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d820 1
a820 1
key_demote(Key *k)
@


1.54.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.55 2003/11/10 16:23:41 jakob Exp $");
a145 1

d147 1
a147 1
key_equal(const Key *a, const Key *b)
d173 1
a173 2
key_fingerprint_raw(const Key *k, enum fp_type dgst_type,
    u_int *dgst_raw_length)
d295 1
a295 1
key_fingerprint(const Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
d493 1
a493 1
key_write(const Key *key, FILE *f)
d525 2
a526 2
const char *
key_type(const Key *k)
d542 2
a543 2
const char *
key_ssh_name(const Key *k)
d557 1
a557 1
key_size(const Key *k)
d614 1
a614 1
key_from_private(const Key *k)
d679 1
a679 1
key_from_blob(const u_char *blob, u_int blen)
d729 1
a729 1
key_to_blob(const Key *key, u_char **blobp, u_int *lenp)
d771 1
a771 1
    const Key *key,
d773 1
a773 1
    const u_char *data, u_int datalen)
d795 3
a797 3
    const Key *key,
    const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
d818 1
a818 1
key_demote(const Key *k)
@


1.54.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.56 2004/07/28 09:40:29 markus Exp $");
d785 1
a785 1
		error("key_sign: invalid key type %d", key->type);
d812 1
a812 1
		error("key_verify: invalid key type %d", key->type);
@


1.53
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.52 2003/05/14 18:16:20 jakob Exp $");
d239 1
a239 1
		strlcat(retval, hex, dgst_raw_len * 3);
d241 2
@


1.52
log
@add experimental support for verifying hos keys using DNS as described
in draft-ietf-secsh-dns-xx.txt. more information in README.dns.
ok markus@@ and henning@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.51 2003/02/12 09:33:04 markus Exp $");
d441 1
a441 1
		k = key_from_blob(blob, n);
d677 1
a677 1
key_from_blob(u_char *blob, int blen)
@


1.51
log
@merge ssh-dss.h ssh-rsa.h into key.h; ok deraadt@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.50 2003/02/04 09:32:08 markus Exp $");
d172 1
a172 1
static u_char *
@


1.51.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.54 2003/07/09 13:58:19 avsm Exp $");
d172 1
a172 1
u_char*
d239 1
a239 1
		strlcat(retval, hex, dgst_raw_len * 3 + 1);
a240 2

	/* Remove the trailing ':' character */
d441 1
a441 1
		k = key_from_blob(blob, (u_int)n);
d677 1
a677 1
key_from_blob(u_char *blob, u_int blen)
@


1.51.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.55 2003/11/10 16:23:41 jakob Exp $");
a145 1

d147 1
a147 1
key_equal(const Key *a, const Key *b)
d173 1
a173 2
key_fingerprint_raw(const Key *k, enum fp_type dgst_type,
    u_int *dgst_raw_length)
d295 1
a295 1
key_fingerprint(const Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
d493 1
a493 1
key_write(const Key *key, FILE *f)
d525 2
a526 2
const char *
key_type(const Key *k)
d542 2
a543 2
const char *
key_ssh_name(const Key *k)
d557 1
a557 1
key_size(const Key *k)
d614 1
a614 1
key_from_private(const Key *k)
d679 1
a679 1
key_from_blob(const u_char *blob, u_int blen)
d729 1
a729 1
key_to_blob(const Key *key, u_char **blobp, u_int *lenp)
d771 1
a771 1
    const Key *key,
d773 1
a773 1
    const u_char *data, u_int datalen)
d795 3
a797 3
    const Key *key,
    const u_char *signature, u_int signaturelen,
    const u_char *data, u_int datalen)
d818 1
a818 1
key_demote(const Key *k)
@


1.50
log
@better debug3 message
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.49 2002/09/09 14:54:14 markus Exp $");
a41 2
#include "ssh-dss.h"
#include "ssh-rsa.h"
@


1.49
log
@signed vs unsigned from -pedantic; ok henning@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.48 2002/07/04 10:41:47 markus Exp $");
d413 1
a413 1
			debug3("key_read: no space");
d420 1
a420 1
			debug3("key_read: no key found");
@


1.49.2.1
log
@Update to OpenSSH 3.6
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.51 2003/02/12 09:33:04 markus Exp $");
d42 2
d413 1
a413 1
			debug3("key_read: missing whitespace");
d420 1
a420 1
			debug3("key_read: missing keytype");
@


1.49.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.54 2003/07/09 13:58:19 avsm Exp $");
d172 1
a172 1
u_char*
d239 1
a239 1
		strlcat(retval, hex, dgst_raw_len * 3 + 1);
a240 2

	/* Remove the trailing ':' character */
d441 1
a441 1
		k = key_from_blob(blob, (u_int)n);
d677 1
a677 1
key_from_blob(u_char *blob, u_int blen)
@


1.48
log
@don't allocate, copy, and discard if there is not interested in the data; ok deraadt@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.47 2002/07/04 04:15:33 deraadt Exp $");
d497 2
a498 1
	u_char *blob, *uu;
@


1.47
log
@patch memory leaks; grendel@@zeitbombe.org
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.46 2002/06/30 21:59:45 deraadt Exp $");
a731 1
	u_char *buf;
d757 6
a762 2
	buf = xmalloc(len);
	memcpy(buf, buffer_ptr(&b), len);
a764 6
	if (lenp != NULL)
		*lenp = len;
	if (blobp != NULL)
		*blobp = buf;
	else
		xfree(buf);
@


1.46
log
@minor KNF
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.45 2002/06/23 03:26:19 deraadt Exp $");
d766 2
@


1.45
log
@KNF
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.44 2002/05/31 13:16:48 markus Exp $");
d174 1
a174 1
static u_char*
d230 2
a231 2
static char*
key_fingerprint_hex(u_char* dgst_raw, u_int dgst_raw_len)
d247 2
a248 2
static char*
key_fingerprint_bubblebabble(u_char* dgst_raw, u_int dgst_raw_len)
d294 1
a294 1
char*
@


1.44
log
@add comment:
key_verify returns 1 for a correct signature, 0 for an incorrect signature
and -1 on error.
CVS ----------------------------------------------------------------------
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.43 2002/03/19 10:49:35 markus Exp $");
d92 1
d124 1
d364 1
d491 1
d523 1
d540 1
d554 1
a816 1

@


1.43
log
@KNF whitespace
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.42 2002/03/18 17:23:31 markus Exp $");
d782 4
@


1.43.2.1
log
@Pull in OpenSSH-3.4
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.45 2002/06/23 03:26:19 deraadt Exp $");
a91 1

a122 1

a361 1

a487 1

a518 1

a534 1

a547 1

a781 4
/*
 * key_verify returns 1 for a correct signature, 0 for an incorrect signature
 * and -1 on error.
 */
d806 1
@


1.43.2.2
log
@Update to OpenSSH 3.5
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.49 2002/09/09 14:54:14 markus Exp $");
d174 1
a174 1
static u_char *
d230 2
a231 2
static char *
key_fingerprint_hex(u_char *dgst_raw, u_int dgst_raw_len)
d247 2
a248 2
static char *
key_fingerprint_bubblebabble(u_char *dgst_raw, u_int dgst_raw_len)
d294 1
a294 1
char *
d497 1
a497 2
	u_char *blob;
	char *uu;
d732 1
d758 4
d764 2
a765 6
	if (blobp != NULL) {
		*blobp = xmalloc(len);
		memcpy(*blobp, buffer_ptr(&b), len);
	}
	memset(buffer_ptr(&b), 0, len);
	buffer_free(&b);
@


1.43.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.51 2003/02/12 09:33:04 markus Exp $");
d42 2
d413 1
a413 1
			debug3("key_read: missing whitespace");
d420 1
a420 1
			debug3("key_read: missing keytype");
@


1.42
log
@add key_demote() for ssh-privsep
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.41 2002/02/28 15:46:33 markus Exp $");
d811 1
a811 1
	
@


1.41
log
@add some const EVP_MD for openssl-0.9.7
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.40 2002/02/24 19:14:59 markus Exp $");
d803 43
@


1.40
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.39 2002/01/25 22:07:40 markus Exp $");
d175 1
a175 1
	EVP_MD *md = NULL;
@


1.39
log
@use EVP_MD_size(evp_md) and not evp_md->md_size; ok steveks@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.38 2001/12/27 18:22:16 markus Exp $");
d179 1
a179 1
	int len = 0;
d491 3
a493 2
	int success = 0;
	u_int bits = 0;
a506 2
		int len, n;
		u_char *blob, *uu;
d765 2
a766 2
    u_char **sigp, int *lenp,
    u_char *data, int datalen)
d785 2
a786 2
    u_char *signature, int signaturelen,
    u_char *data, int datalen)
@


1.38
log
@call fatal() for openssl allocation failures
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.37 2001/12/25 18:49:56 markus Exp $");
d173 1
a173 1
key_fingerprint_raw(Key *k, enum fp_type dgst_type, size_t *dgst_raw_length)
d219 1
a219 2
		EVP_DigestFinal(&ctx, retval, NULL);
		*dgst_raw_length = md->md_size;
d229 1
a229 1
key_fingerprint_hex(u_char* dgst_raw, size_t dgst_raw_len)
d246 1
a246 1
key_fingerprint_bubblebabble(u_char* dgst_raw, size_t dgst_raw_len)
d297 1
a297 1
	size_t dgst_raw_len;
@


1.37
log
@be more careful on allocation
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.36 2001/12/19 07:18:56 deraadt Exp $");
d63 6
a68 5
		rsa = RSA_new();
		rsa->n = BN_new();
		rsa->e = BN_new();
		if (rsa == NULL || rsa->n == NULL || rsa->e == NULL)
			fatal("key_new: malloc failure");
d72 10
a81 8
		dsa = DSA_new();
		dsa->p = BN_new();
		dsa->q = BN_new();
		dsa->g = BN_new();
		dsa->pub_key = BN_new();
		if (dsa == NULL || dsa->p == NULL || dsa->q == NULL ||
		    dsa->g == NULL || dsa->pub_key == NULL)
			fatal("key_new: malloc failure");
d99 12
a110 6
		k->rsa->d = BN_new();
		k->rsa->iqmp = BN_new();
		k->rsa->q = BN_new();
		k->rsa->p = BN_new();
		k->rsa->dmq1 = BN_new();
		k->rsa->dmp1 = BN_new();
d113 2
a114 1
		k->dsa->priv_key = BN_new();
@


1.36
log
@basic KNF done while i was looking for something else
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.35 2001/12/05 10:06:12 deraadt Exp $");
d66 2
d76 3
@


1.35
log
@minor KNF
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.34 2001/11/21 15:51:24 markus Exp $");
d222 1
a222 1
	for(i = 0; i < dgst_raw_len; i++) {
d284 1
a284 1
	
d644 1
a644 1
	     (p = strsep(&cp, ","))) {
@


1.34
log
@mem leak
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.33 2001/10/04 14:34:16 markus Exp $");
d288 1
a288 1
	switch(dgst_rep) {
d374 1
a374 1
	switch(ret->type) {
d536 2
a537 1
key_size(Key *k){
d620 1
a620 1
	if (strcmp(name, "rsa1") == 0){
d622 1
a622 1
	} else if (strcmp(name, "rsa") == 0){
d624 1
a624 1
	} else if (strcmp(name, "dsa") == 0){
d626 1
a626 1
	} else if (strcmp(name, "ssh-rsa") == 0){
d628 1
a628 1
	} else if (strcmp(name, "ssh-dss") == 0){
d673 1
a673 1
	switch(type){
d719 1
a719 1
	switch(key->type){
d755 1
a755 1
	switch(key->type){
d778 1
a778 1
	switch(key->type){
@


1.33
log
@call OPENSSL_free() for memory allocated by openssl; from chombier@@mac.com
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.32 2001/09/19 13:23:29 markus Exp $");
d423 1
d427 1
a431 1
		xfree(blob);
d458 1
a460 1
		key_free(k);
@


1.33.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.41 2002/02/28 15:46:33 markus Exp $");
d63 3
a65 6
		if ((rsa = RSA_new()) == NULL)
			fatal("key_new: RSA_new failed");
		if ((rsa->n = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((rsa->e = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
d69 5
a73 10
		if ((dsa = DSA_new()) == NULL)
			fatal("key_new: DSA_new failed");
		if ((dsa->p = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->q = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->g = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->pub_key = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
d91 6
a96 12
		if ((k->rsa->d = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->iqmp = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->q = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->p = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->dmq1 = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->dmp1 = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
d99 1
a99 2
		if ((k->dsa->priv_key = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
d158 1
a158 1
key_fingerprint_raw(Key *k, enum fp_type dgst_type, u_int *dgst_raw_length)
d160 1
a160 1
	const EVP_MD *md = NULL;
d164 1
a164 1
	u_int len = 0;
d204 2
a205 1
		EVP_DigestFinal(&ctx, retval, dgst_raw_length);
d215 1
a215 1
key_fingerprint_hex(u_char* dgst_raw, u_int dgst_raw_len)
d222 1
a222 1
	for (i = 0; i < dgst_raw_len; i++) {
d232 1
a232 1
key_fingerprint_bubblebabble(u_char* dgst_raw, u_int dgst_raw_len)
d283 2
a284 2
	u_int dgst_raw_len;

d288 1
a288 1
	switch (dgst_rep) {
d374 1
a374 1
	switch (ret->type) {
a422 1
			xfree(blob);
a425 1
		xfree(blob);
d430 1
a456 1
		key_free(k);
d459 1
d476 2
a477 3
	int n, success = 0;
	u_int len, bits = 0;
	u_char *blob, *uu;
d491 2
d535 1
a535 2
key_size(Key *k)
{
d618 1
a618 1
	if (strcmp(name, "rsa1") == 0) {
d620 1
a620 1
	} else if (strcmp(name, "rsa") == 0) {
d622 1
a622 1
	} else if (strcmp(name, "dsa") == 0) {
d624 1
a624 1
	} else if (strcmp(name, "ssh-rsa") == 0) {
d626 1
a626 1
	} else if (strcmp(name, "ssh-dss") == 0) {
d642 1
a642 1
	    (p = strsep(&cp, ","))) {
d671 1
a671 1
	switch (type) {
d717 1
a717 1
	switch (key->type) {
d750 2
a751 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d753 1
a753 1
	switch (key->type) {
d770 2
a771 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d776 1
a776 1
	switch (key->type) {
@


1.33.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.43 2002/03/19 10:49:35 markus Exp $");
a802 43
}

/* Converts a private to a public key */

Key *
key_demote(Key *k)
{
	Key *pk;

	pk = xmalloc(sizeof(*pk));
	pk->type = k->type;
	pk->flags = k->flags;
	pk->dsa = NULL;
	pk->rsa = NULL;

	switch (k->type) {
	case KEY_RSA1:
	case KEY_RSA:
		if ((pk->rsa = RSA_new()) == NULL)
			fatal("key_demote: RSA_new failed");
		if ((pk->rsa->e = BN_dup(k->rsa->e)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->rsa->n = BN_dup(k->rsa->n)) == NULL)
			fatal("key_demote: BN_dup failed");
		break;
	case KEY_DSA:
		if ((pk->dsa = DSA_new()) == NULL)
			fatal("key_demote: DSA_new failed");
		if ((pk->dsa->p = BN_dup(k->dsa->p)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->q = BN_dup(k->dsa->q)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->g = BN_dup(k->dsa->g)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->pub_key = BN_dup(k->dsa->pub_key)) == NULL)
			fatal("key_demote: BN_dup failed");
		break;
	default:
		fatal("key_free: bad key type %d", k->type);
		break;
	}

	return (pk);
@


1.33.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.33.2.2 2002/05/17 00:03:23 miod Exp $");
a781 4
/*
 * key_verify returns 1 for a correct signature, 0 for an incorrect signature
 * and -1 on error.
 */
@


1.33.2.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.33.2.3 2002/06/22 07:23:17 miod Exp $");
a91 1

a122 1

a361 1

a487 1

a518 1

a534 1

a547 1

d810 1
@


1.33.2.5
log
@Update to OpenSSH 3.5
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.49 2002/09/09 14:54:14 markus Exp $");
d174 1
a174 1
static u_char *
d230 2
a231 2
static char *
key_fingerprint_hex(u_char *dgst_raw, u_int dgst_raw_len)
d247 2
a248 2
static char *
key_fingerprint_bubblebabble(u_char *dgst_raw, u_int dgst_raw_len)
d294 1
a294 1
char *
d497 1
a497 2
	u_char *blob;
	char *uu;
d732 1
d758 4
d764 2
a765 6
	if (blobp != NULL) {
		*blobp = xmalloc(len);
		memcpy(*blobp, buffer_ptr(&b), len);
	}
	memset(buffer_ptr(&b), 0, len);
	buffer_free(&b);
@


1.32
log
@key_read() now returns -1 on type mismatch, too
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.31 2001/09/17 20:50:22 markus Exp $");
d357 1
a357 1
	xfree(buf);
@


1.31
log
@better error handling if you try to export a bad key to ssh.com
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.30 2001/09/17 19:27:15 stevesk Exp $");
d361 1
a361 1
/* returns 1 ok, -1 error, 0 type mismatch */
d416 1
a416 1
			return 0;
@


1.30
log
@u_char*/char* cleanup; ok markus@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.29 2001/06/26 20:14:10 markus Exp $");
d731 3
a733 2
		error("key_to_blob: illegal key type %d", key->type);
		break;
@


1.29
log
@add smartcard support to the client, too (now you can use both
the agent and the client).
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.28 2001/06/25 08:25:37 markus Exp $");
d656 1
a656 1
key_from_blob(char *blob, int blen)
@


1.28
log
@update copyright for 2001
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.27 2001/06/23 15:12:19 itojun Exp $");
d57 1
@


1.27
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d12 1
a12 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.26 2001/06/23 05:26:02 markus Exp $");
@


1.26
log
@handle sigature of size 0 (some broken clients send this).
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.25 2001/04/17 10:53:24 markus Exp $");
d156 1
a156 1
u_char*
d213 1
a213 1
char*
d230 1
a230 1
char*
d311 1
a311 1
int
d347 1
a347 1
int
d547 1
a547 1
RSA *
d557 1
a557 1
DSA*
@


1.25
log
@add HostKeyAlgorithms; based on patch from res@@shore.net; ok provos@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.24 2001/04/16 08:26:04 deraadt Exp $");
d771 3
@


1.25.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d12 1
a12 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.32 2001/09/19 13:23:29 markus Exp $");
a56 1
	k->flags = 0;
d156 1
a156 1
static u_char*
d213 1
a213 1
static char*
d230 1
a230 1
static char*
d311 1
a311 1
static int
d347 1
a347 1
static int
d360 1
a360 1
/* returns 1 ok, -1 error */
d415 1
a415 1
			return -1;
d547 1
a547 1
static RSA *
d557 1
a557 1
static DSA*
d655 1
a655 1
key_from_blob(u_char *blob, int blen)
d730 2
a731 3
		error("key_to_blob: unsupported key type %d", key->type);
		buffer_free(&b);
		return 0;
a770 3
	if (signaturelen == 0)
		return -1;

@


1.25.2.2
log
@Merge OpenSSH 3.0
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.25.2.1 2001/09/27 19:03:54 jason Exp $");
d357 1
a357 1
	OPENSSL_free(buf);
@


1.25.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.41 2002/02/28 15:46:33 markus Exp $");
d63 3
a65 6
		if ((rsa = RSA_new()) == NULL)
			fatal("key_new: RSA_new failed");
		if ((rsa->n = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((rsa->e = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
d69 5
a73 10
		if ((dsa = DSA_new()) == NULL)
			fatal("key_new: DSA_new failed");
		if ((dsa->p = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->q = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->g = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->pub_key = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
d91 6
a96 12
		if ((k->rsa->d = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->iqmp = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->q = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->p = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->dmq1 = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->dmp1 = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
d99 1
a99 2
		if ((k->dsa->priv_key = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
d158 1
a158 1
key_fingerprint_raw(Key *k, enum fp_type dgst_type, u_int *dgst_raw_length)
d160 1
a160 1
	const EVP_MD *md = NULL;
d164 1
a164 1
	u_int len = 0;
d204 2
a205 1
		EVP_DigestFinal(&ctx, retval, dgst_raw_length);
d215 1
a215 1
key_fingerprint_hex(u_char* dgst_raw, u_int dgst_raw_len)
d222 1
a222 1
	for (i = 0; i < dgst_raw_len; i++) {
d232 1
a232 1
key_fingerprint_bubblebabble(u_char* dgst_raw, u_int dgst_raw_len)
d283 2
a284 2
	u_int dgst_raw_len;

d288 1
a288 1
	switch (dgst_rep) {
d374 1
a374 1
	switch (ret->type) {
a422 1
			xfree(blob);
a425 1
		xfree(blob);
d430 1
a456 1
		key_free(k);
d459 1
d476 2
a477 3
	int n, success = 0;
	u_int len, bits = 0;
	u_char *blob, *uu;
d491 2
d535 1
a535 2
key_size(Key *k)
{
d618 1
a618 1
	if (strcmp(name, "rsa1") == 0) {
d620 1
a620 1
	} else if (strcmp(name, "rsa") == 0) {
d622 1
a622 1
	} else if (strcmp(name, "dsa") == 0) {
d624 1
a624 1
	} else if (strcmp(name, "ssh-rsa") == 0) {
d626 1
a626 1
	} else if (strcmp(name, "ssh-dss") == 0) {
d642 1
a642 1
	    (p = strsep(&cp, ","))) {
d671 1
a671 1
	switch (type) {
d717 1
a717 1
	switch (key->type) {
d750 2
a751 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d753 1
a753 1
	switch (key->type) {
d770 2
a771 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d776 1
a776 1
	switch (key->type) {
@


1.25.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.43 2002/03/19 10:49:35 markus Exp $");
a802 43
}

/* Converts a private to a public key */

Key *
key_demote(Key *k)
{
	Key *pk;

	pk = xmalloc(sizeof(*pk));
	pk->type = k->type;
	pk->flags = k->flags;
	pk->dsa = NULL;
	pk->rsa = NULL;

	switch (k->type) {
	case KEY_RSA1:
	case KEY_RSA:
		if ((pk->rsa = RSA_new()) == NULL)
			fatal("key_demote: RSA_new failed");
		if ((pk->rsa->e = BN_dup(k->rsa->e)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->rsa->n = BN_dup(k->rsa->n)) == NULL)
			fatal("key_demote: BN_dup failed");
		break;
	case KEY_DSA:
		if ((pk->dsa = DSA_new()) == NULL)
			fatal("key_demote: DSA_new failed");
		if ((pk->dsa->p = BN_dup(k->dsa->p)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->q = BN_dup(k->dsa->q)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->g = BN_dup(k->dsa->g)) == NULL)
			fatal("key_demote: BN_dup failed");
		if ((pk->dsa->pub_key = BN_dup(k->dsa->pub_key)) == NULL)
			fatal("key_demote: BN_dup failed");
		break;
	default:
		fatal("key_free: bad key type %d", k->type);
		break;
	}

	return (pk);
@


1.24
log
@better safe than sorry in later mods; yongari@@kt-is.co.kr
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.23 2001/04/05 10:42:50 markus Exp $");
d630 22
@


1.23
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.22 2001/03/12 22:02:01 markus Exp $");
d219 1
a219 1
	retval = xmalloc(dgst_raw_len * 3);
@


1.22
log
@remove old key_fingerprint interface, s/_ex//
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.21 2001/03/11 18:29:51 markus Exp $");
d214 1
a214 1
key_fingerprint_hex(u_char* dgst_raw, size_t dgst_raw_len) 
d231 1
a231 1
key_fingerprint_bubblebabble(u_char* dgst_raw, size_t dgst_raw_len) 
d280 1
a280 1
	char *retval = NULL; 
d282 1
a282 1
	size_t dgst_raw_len; 
@


1.21
log
@style+cleanup
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.20 2001/03/11 15:13:09 jakob Exp $");
d278 1
a278 1
key_fingerprint_ex(Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
d286 1
a286 1
		fatal("key_fingerprint_ex: null value returned from key_fingerprint_raw()");
a300 12
	return retval;
}

char *
key_fingerprint(Key *k)
{
	static char retval[(EVP_MAX_MD_SIZE + 1) * 3];
	char *digest;

	digest = key_fingerprint_ex(k, SSH_FP_MD5, SSH_FP_HEX);
	strlcpy(retval, digest, sizeof(retval));
	xfree(digest);
@


1.20
log
@cleanup & shorten some var names key_fingerprint_bubblebabble.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.19 2001/03/11 15:03:15 jakob Exp $");
d159 2
d168 11
a199 3
		EVP_MD *md = NULL;
		EVP_MD_CTX ctx;

a200 13

		switch (dgst_type) {
		case SSH_FP_MD5:
			md = EVP_md5();
			break;
		case SSH_FP_SHA1:
			md = EVP_sha1();
			break;
		default:
			fatal("key_fingerprint_raw: bad digest type %d",
			    dgst_type);
		}

@


1.19
log
@add improved fingerprint functions. based on work by Carsten
Raskgaard <cara@@int.tele.dk> and modified by me. ok markus@@.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.18 2001/03/11 13:25:36 markus Exp $");
d239 1
a239 1
	u_int rounds, idx, retval_idx, seed;
d244 2
a245 4
	seed = 1;
	retval_idx = 0;
	retval[retval_idx++] = 'x';
	for (idx=0;idx<rounds;idx++) {
d247 2
a248 2
		if ((idx + 1 < rounds) || (dgst_raw_len % 2 != 0)) {
			idx0 = (((((u_int)(dgst_raw[2 * idx])) >> 6) & 3) +
d250 2
a251 2
			idx1 = (((u_int)(dgst_raw[2 * idx])) >> 2) & 15;
			idx2 = ((((u_int)(dgst_raw[2 * idx])) & 3) +
d253 9
a261 9
			retval[retval_idx++] = vowels[idx0];
			retval[retval_idx++] = consonants[idx1];
			retval[retval_idx++] = vowels[idx2];
			if ((idx + 1) < rounds) {
				idx3 = (((u_int)(dgst_raw[(2 * idx) + 1])) >> 4) & 15;
				idx4 = (((u_int)(dgst_raw[(2 * idx) + 1]))) & 15;
				retval[retval_idx++] = consonants[idx3];
				retval[retval_idx++] = '-';
				retval[retval_idx++] = consonants[idx4];
d263 2
a264 2
				    ((((u_int)(dgst_raw[2 * idx])) * 7) +
				    ((u_int)(dgst_raw[(2 * idx) + 1])))) % 36;
d270 3
a272 3
			retval[retval_idx++] = vowels[idx0];
			retval[retval_idx++] = consonants[idx1];
			retval[retval_idx++] = vowels[idx2];
d275 2
a276 2
	retval[retval_idx++] = 'x';
	retval[retval_idx++] = '\0';
@


1.18
log
@debug
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.17 2001/02/04 15:32:24 stevesk Exp $");
d156 2
a157 6
/*
 * Generate key fingerprint in ascii format.
 * Based on ideas and code from Bjoern Groenvall <bg@@sics.se>
 */
char *
key_fingerprint(Key *k)
a158 1
	static char retval[(EVP_MAX_MD_SIZE+1)*3];
d160 1
d164 2
a165 1
	retval[0] = '\0';
d183 1
a183 1
		fatal("key_fingerprint: bad key type %d", k->type);
d187 1
a187 3
		int i;
		u_char digest[EVP_MAX_MD_SIZE];
		EVP_MD *md = EVP_md5();
d189 15
d206 2
a207 7
		EVP_DigestFinal(&ctx, digest, NULL);
		for(i = 0; i < md->md_size; i++) {
			char hex[4];
			snprintf(hex, sizeof(hex), "%02x:", digest[i]);
			strlcat(retval, hex, sizeof(retval));
		}
		retval[strlen(retval) - 1] = '\0';
d210 2
d213 105
@


1.17
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.16 2001/01/22 16:55:21 stevesk Exp $");
d533 1
a533 1
	debug("key_type_from_name: unknown key type '%s'", name);
@


1.16
log
@free() -> xfree(); ok markus@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.15 2001/01/21 19:05:50 markus Exp $");
d455 5
a459 5
        RSA *private;
        private = RSA_generate_key(bits, 35, NULL, NULL);
        if (private == NULL)
                fatal("rsa_generate_private_key: key generation failed.");
        return private;
d469 3
a471 3
                fatal("dsa_generate_private_key: DSA_generate_key failed.");
        if (private == NULL)
                fatal("dsa_generate_private_key: NULL.");
d480 1
a480 1
        case KEY_DSA:
d488 1
a488 1
                fatal("key_generate: unknown type %d", type);
d490 1
a490 1
        k->type = type;
d499 1
a499 1
        case KEY_DSA:
d513 1
a513 1
                fatal("key_from_private: unknown type %d", k->type);
@


1.15
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.14 2001/01/16 19:20:06 markus Exp $");
d261 1
a261 1
	free(buf);
@


1.14
log
@make "ssh-rsa" key format for ssh2 confirm to the ietf-drafts; from galb@@vandyke.com.
note that you have to delete older ssh2-rsa keys, since they are in the
wrong format, too. they must be removed from .ssh/authorized_keys2
and .ssh/known_hosts2, etc.
(cd; grep -v ssh-rsa .ssh/authorized_keys2 > TMP && mv TMP .ssh/authorized_keys2)
additionally, we now check that BN_num_bits(rsa->n) >= 768.
@
text
@d34 2
a36 4
#include "includes.h"
#include "ssh.h"
#include <openssl/rsa.h>
#include <openssl/dsa.h>
d38 1
d47 1
a47 2

RCSID("$OpenBSD: key.c,v 1.13 2000/12/19 23:17:56 markus Exp $");
@


1.13
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d49 1
a49 1
RCSID("$OpenBSD: key.c,v 1.12 2000/11/12 19:50:37 markus Exp $");
d558 1
a559 1
		buffer_get_bignum2(&b, key->rsa->e);
d611 1
a612 1
		buffer_put_bignum2(&b, key->rsa->e);
@


1.12
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d49 1
a49 1
RCSID("$OpenBSD: key.c,v 1.11 2000/09/07 20:27:51 deraadt Exp $");
d166 1
a166 1
	unsigned char *blob = NULL;
d193 1
a193 1
		unsigned char digest[EVP_MAX_MD_SIZE];
d276 1
a276 1
	unsigned char *blob;
d383 1
a383 1
	unsigned int bits = 0;
d398 1
a398 1
		unsigned char *blob, *uu;
d455 1
a455 1
rsa_generate_private_key(unsigned int bits)
d465 1
a465 1
dsa_generate_private_key(unsigned int bits)
d478 1
a478 1
key_generate(int type, unsigned int bits)
d590 1
a590 1
key_to_blob(Key *key, unsigned char **blobp, unsigned int *lenp)
d594 1
a594 1
	unsigned char *buf;
d633 2
a634 2
    unsigned char **sigp, int *lenp,
    unsigned char *data, int datalen)
d653 2
a654 2
    unsigned char *signature, int signaturelen,
    unsigned char *data, int datalen)
@


1.11
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d42 3
a44 1
#include "dsa.h"
d46 2
d49 1
a49 3
RCSID("$OpenBSD: key.c,v 1.10 2000/08/19 21:34:43 markus Exp $");

#define SSH_DSS "ssh-dss"
d62 1
d77 1
a77 1
	case KEY_EMPTY:
d85 24
d113 1
d124 2
d138 1
d170 1
d172 1
a172 1
	case KEY_RSA:
d181 5
a185 1
		dsa_make_key_blob(k, &blob, &len);
a190 2
	retval[0] = '\0';

d266 3
a268 1
unsigned int
d272 4
a275 3
	unsigned int bits = 0;
	char *cp;
	int len, n;
d281 1
a281 1
	case KEY_RSA:
d284 1
a284 1
			return 0;	/* Bad bit count... */
d288 1
a288 1
			return 0;
d292 1
a292 1
			return 0;
d294 2
a295 1
			return 0;
d297 2
d300 22
a321 1
		if (strncmp(cp, SSH_DSS " ", 7) != 0)
d323 1
a323 1
		cp += 7;
d329 1
a329 1
			return 0;
d331 1
a331 1
		k = dsa_key_from_blob(blob, n);
d333 2
a334 2
			error("key_read: dsa_key_from_blob %s failed", cp);
			return 0;
d337 28
a364 4
		if (ret->dsa != NULL)
			DSA_free(ret->dsa);
		ret->dsa = k->dsa;
		k->dsa = NULL;
a365 1
		bits = BN_num_bits(ret->dsa->p);
d377 1
a377 1
	return bits;
d385 1
a385 1
	if (key->type == KEY_RSA && key->rsa != NULL) {
d395 2
a396 1
	} else if (key->type == KEY_DSA && key->dsa != NULL) {
d399 1
a399 1
		dsa_make_key_blob(key, &blob, &len);
d403 1
a403 1
			fprintf(f, "%s %s", SSH_DSS, uu);
d415 3
d427 14
a440 1
unsigned int
d443 1
d452 216
@


1.11.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d34 1
d36 3
a38 2
RCSID("$OpenBSD: key.c,v 1.17 2001/02/04 15:32:24 stevesk Exp $");

a39 1

d42 1
a42 3
#include "rsa.h"
#include "ssh-dss.h"
#include "ssh-rsa.h"
d44 4
a47 3
#include "buffer.h"
#include "bufaux.h"
#include "log.h"
a59 1
	case KEY_RSA1:
d74 1
a74 1
	case KEY_UNSPEC:
a81 24
Key *
key_new_private(int type)
{
	Key *k = key_new(type);
	switch (k->type) {
	case KEY_RSA1:
	case KEY_RSA:
		k->rsa->d = BN_new();
		k->rsa->iqmp = BN_new();
		k->rsa->q = BN_new();
		k->rsa->p = BN_new();
		k->rsa->dmq1 = BN_new();
		k->rsa->dmp1 = BN_new();
		break;
	case KEY_DSA:
		k->dsa->priv_key = BN_new();
		break;
	case KEY_UNSPEC:
		break;
	default:
		break;
	}
	return k;
}
a85 1
	case KEY_RSA1:
a95 2
	case KEY_UNSPEC:
		break;
a107 1
	case KEY_RSA1:
d135 1
a135 1
	u_char *blob = NULL;
a138 1
	retval[0] = '\0';
d140 1
a140 1
	case KEY_RSA1:
d149 1
a149 5
	case KEY_RSA:
		key_to_blob(k, &blob, &len);
		break;
	case KEY_UNSPEC:
		return retval;
d155 2
d159 1
a159 1
		u_char digest[EVP_MAX_MD_SIZE];
d229 1
a229 1
	xfree(buf);
d232 1
a232 3

/* returns 1 ok, -1 error, 0 type mismatch */
int
d236 4
a239 5
	int success = -1;
	char *cp, *space;
	int len, n, type;
	u_int bits;
	u_char *blob;
d244 1
a244 1
	case KEY_RSA1:
d247 1
a247 1
			return -1;	/* Bad bit count... */
d251 1
a251 1
			return -1;
d255 1
a255 1
			return -1;
d257 1
a257 2
			return -1;
		success = 1;
a258 2
	case KEY_UNSPEC:
	case KEY_RSA:
d260 1
a260 22
		space = strchr(cp, ' ');
		if (space == NULL) {
			debug3("key_read: no space");
			return -1;
		}
		*space = '\0';
		type = key_type_from_name(cp);
		*space = ' ';
		if (type == KEY_UNSPEC) {
			debug3("key_read: no key found");
			return -1;
		}
		cp = space+1;
		if (*cp == '\0') {
			debug3("key_read: short string");
			return -1;
		}
		if (ret->type == KEY_UNSPEC) {
			ret->type = type;
		} else if (ret->type != type) {
			/* is a key, but different type */
			debug3("key_read: type mismatch");
d262 1
a262 1
		}
d268 1
a268 1
			return -1;
d270 1
a270 1
		k = key_from_blob(blob, n);
d272 2
a273 2
			error("key_read: key_from_blob %s failed", cp);
			return -1;
d276 4
a279 28
		if (k->type != type) {
			error("key_read: type mismatch: encoding error");
			key_free(k);
			return -1;
		}
/*XXXX*/
		if (ret->type == KEY_RSA) {
			if (ret->rsa != NULL)
				RSA_free(ret->rsa);
			ret->rsa = k->rsa;
			k->rsa = NULL;
			success = 1;
#ifdef DEBUG_PK
			RSA_print_fp(stderr, ret->rsa, 8);
#endif
		} else {
			if (ret->dsa != NULL)
				DSA_free(ret->dsa);
			ret->dsa = k->dsa;
			k->dsa = NULL;
			success = 1;
#ifdef DEBUG_PK
			DSA_print_fp(stderr, ret->dsa, 8);
#endif
		}
/*XXXX*/
		if (success != 1)
			break;
d281 1
d293 1
a293 1
	return success;
d299 1
a299 1
	u_int bits = 0;
d301 1
a301 1
	if (key->type == KEY_RSA1 && key->rsa != NULL) {
d311 1
a311 2
	} else if ((key->type == KEY_DSA && key->dsa != NULL) ||
	    (key->type == KEY_RSA && key->rsa != NULL)) {
d313 2
a314 2
		u_char *blob, *uu;
		key_to_blob(key, &blob, &len);
d318 1
a318 1
			fprintf(f, "%s %s", key_ssh_name(key), uu);
a329 3
	case KEY_RSA1:
		return "RSA1";
		break;
d339 1
a339 14
char *
key_ssh_name(Key *k)
{
	switch (k->type) {
	case KEY_RSA:
		return "ssh-rsa";
		break;
	case KEY_DSA:
		return "ssh-dss";
		break;
	}
	return "ssh-unknown";
}
u_int
a341 1
	case KEY_RSA1:
a349 216
}

RSA *
rsa_generate_private_key(u_int bits)
{
	RSA *private;
	private = RSA_generate_key(bits, 35, NULL, NULL);
	if (private == NULL)
		fatal("rsa_generate_private_key: key generation failed.");
	return private;
}

DSA*
dsa_generate_private_key(u_int bits)
{
	DSA *private = DSA_generate_parameters(bits, NULL, 0, NULL, NULL, NULL, NULL);
	if (private == NULL)
		fatal("dsa_generate_private_key: DSA_generate_parameters failed");
	if (!DSA_generate_key(private))
		fatal("dsa_generate_private_key: DSA_generate_key failed.");
	if (private == NULL)
		fatal("dsa_generate_private_key: NULL.");
	return private;
}

Key *
key_generate(int type, u_int bits)
{
	Key *k = key_new(KEY_UNSPEC);
	switch (type) {
	case KEY_DSA:
		k->dsa = dsa_generate_private_key(bits);
		break;
	case KEY_RSA:
	case KEY_RSA1:
		k->rsa = rsa_generate_private_key(bits);
		break;
	default:
		fatal("key_generate: unknown type %d", type);
	}
	k->type = type;
	return k;
}

Key *
key_from_private(Key *k)
{
	Key *n = NULL;
	switch (k->type) {
	case KEY_DSA:
		n = key_new(k->type);
		BN_copy(n->dsa->p, k->dsa->p);
		BN_copy(n->dsa->q, k->dsa->q);
		BN_copy(n->dsa->g, k->dsa->g);
		BN_copy(n->dsa->pub_key, k->dsa->pub_key);
		break;
	case KEY_RSA:
	case KEY_RSA1:
		n = key_new(k->type);
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
		break;
	default:
		fatal("key_from_private: unknown type %d", k->type);
		break;
	}
	return n;
}

int
key_type_from_name(char *name)
{
	if (strcmp(name, "rsa1") == 0){
		return KEY_RSA1;
	} else if (strcmp(name, "rsa") == 0){
		return KEY_RSA;
	} else if (strcmp(name, "dsa") == 0){
		return KEY_DSA;
	} else if (strcmp(name, "ssh-rsa") == 0){
		return KEY_RSA;
	} else if (strcmp(name, "ssh-dss") == 0){
		return KEY_DSA;
	}
	debug("key_type_from_name: unknown key type '%s'", name);
	return KEY_UNSPEC;
}

Key *
key_from_blob(char *blob, int blen)
{
	Buffer b;
	char *ktype;
	int rlen, type;
	Key *key = NULL;

#ifdef DEBUG_PK
	dump_base64(stderr, blob, blen);
#endif
	buffer_init(&b);
	buffer_append(&b, blob, blen);
	ktype = buffer_get_string(&b, NULL);
	type = key_type_from_name(ktype);

	switch(type){
	case KEY_RSA:
		key = key_new(type);
		buffer_get_bignum2(&b, key->rsa->e);
		buffer_get_bignum2(&b, key->rsa->n);
#ifdef DEBUG_PK
		RSA_print_fp(stderr, key->rsa, 8);
#endif
		break;
	case KEY_DSA:
		key = key_new(type);
		buffer_get_bignum2(&b, key->dsa->p);
		buffer_get_bignum2(&b, key->dsa->q);
		buffer_get_bignum2(&b, key->dsa->g);
		buffer_get_bignum2(&b, key->dsa->pub_key);
#ifdef DEBUG_PK
		DSA_print_fp(stderr, key->dsa, 8);
#endif
		break;
	case KEY_UNSPEC:
		key = key_new(type);
		break;
	default:
		error("key_from_blob: cannot handle type %s", ktype);
		break;
	}
	rlen = buffer_len(&b);
	if (key != NULL && rlen != 0)
		error("key_from_blob: remaining bytes in key blob %d", rlen);
	xfree(ktype);
	buffer_free(&b);
	return key;
}

int
key_to_blob(Key *key, u_char **blobp, u_int *lenp)
{
	Buffer b;
	int len;
	u_char *buf;

	if (key == NULL) {
		error("key_to_blob: key == NULL");
		return 0;
	}
	buffer_init(&b);
	switch(key->type){
	case KEY_DSA:
		buffer_put_cstring(&b, key_ssh_name(key));
		buffer_put_bignum2(&b, key->dsa->p);
		buffer_put_bignum2(&b, key->dsa->q);
		buffer_put_bignum2(&b, key->dsa->g);
		buffer_put_bignum2(&b, key->dsa->pub_key);
		break;
	case KEY_RSA:
		buffer_put_cstring(&b, key_ssh_name(key));
		buffer_put_bignum2(&b, key->rsa->e);
		buffer_put_bignum2(&b, key->rsa->n);
		break;
	default:
		error("key_to_blob: illegal key type %d", key->type);
		break;
	}
	len = buffer_len(&b);
	buf = xmalloc(len);
	memcpy(buf, buffer_ptr(&b), len);
	memset(buffer_ptr(&b), 0, len);
	buffer_free(&b);
	if (lenp != NULL)
		*lenp = len;
	if (blobp != NULL)
		*blobp = buf;
	return len;
}

int
key_sign(
    Key *key,
    u_char **sigp, int *lenp,
    u_char *data, int datalen)
{
	switch(key->type){
	case KEY_DSA:
		return ssh_dss_sign(key, sigp, lenp, data, datalen);
		break;
	case KEY_RSA:
		return ssh_rsa_sign(key, sigp, lenp, data, datalen);
		break;
	default:
		error("key_sign: illegal key type %d", key->type);
		return -1;
		break;
	}
}

int
key_verify(
    Key *key,
    u_char *signature, int signaturelen,
    u_char *data, int datalen)
{
	switch(key->type){
	case KEY_DSA:
		return ssh_dss_verify(key, signature, signaturelen, data, datalen);
		break;
	case KEY_RSA:
		return ssh_rsa_verify(key, signature, signaturelen, data, datalen);
		break;
	default:
		error("key_verify: illegal key type %d", key->type);
		return -1;
		break;
	}
@


1.11.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.11.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.22 2001/03/12 22:02:01 markus Exp $");
d156 6
a161 2
u_char*
key_fingerprint_raw(Key *k, enum fp_type dgst_type, size_t *dgst_raw_length)
d163 1
a163 2
	EVP_MD *md = NULL;
	EVP_MD_CTX ctx;
a164 1
	u_char *retval = NULL;
d168 1
a168 13
	*dgst_raw_length = 0;

	switch (dgst_type) {
	case SSH_FP_MD5:
		md = EVP_md5();
		break;
	case SSH_FP_SHA1:
		md = EVP_sha1();
		break;
	default:
		fatal("key_fingerprint_raw: bad digest type %d",
		    dgst_type);
	}
d186 1
a186 1
		fatal("key_fingerprint_raw: bad key type %d", k->type);
d190 4
a193 1
		retval = xmalloc(EVP_MAX_MD_SIZE);
d196 7
a202 2
		EVP_DigestFinal(&ctx, retval, NULL);
		*dgst_raw_length = md->md_size;
a204 91
	} else {
		fatal("key_fingerprint_raw: blob is null");
	}
	return retval;
}

char*
key_fingerprint_hex(u_char* dgst_raw, size_t dgst_raw_len) 
{
	char *retval;
	int i;

	retval = xmalloc(dgst_raw_len * 3);
	retval[0] = '\0';
	for(i = 0; i < dgst_raw_len; i++) {
		char hex[4];
		snprintf(hex, sizeof(hex), "%02x:", dgst_raw[i]);
		strlcat(retval, hex, dgst_raw_len * 3);
	}
	retval[(dgst_raw_len * 3) - 1] = '\0';
	return retval;
}

char*
key_fingerprint_bubblebabble(u_char* dgst_raw, size_t dgst_raw_len) 
{
	char vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };
	char consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm',
	    'n', 'p', 'r', 's', 't', 'v', 'z', 'x' };
	u_int i, j = 0, rounds, seed = 1;
	char *retval;

	rounds = (dgst_raw_len / 2) + 1;
	retval = xmalloc(sizeof(char) * (rounds*6));
	retval[j++] = 'x';
	for (i = 0; i < rounds; i++) {
		u_int idx0, idx1, idx2, idx3, idx4;
		if ((i + 1 < rounds) || (dgst_raw_len % 2 != 0)) {
			idx0 = (((((u_int)(dgst_raw[2 * i])) >> 6) & 3) +
			    seed) % 6;
			idx1 = (((u_int)(dgst_raw[2 * i])) >> 2) & 15;
			idx2 = ((((u_int)(dgst_raw[2 * i])) & 3) +
			    (seed / 6)) % 6;
			retval[j++] = vowels[idx0];
			retval[j++] = consonants[idx1];
			retval[j++] = vowels[idx2];
			if ((i + 1) < rounds) {
				idx3 = (((u_int)(dgst_raw[(2 * i) + 1])) >> 4) & 15;
				idx4 = (((u_int)(dgst_raw[(2 * i) + 1]))) & 15;
				retval[j++] = consonants[idx3];
				retval[j++] = '-';
				retval[j++] = consonants[idx4];
				seed = ((seed * 5) +
				    ((((u_int)(dgst_raw[2 * i])) * 7) +
				    ((u_int)(dgst_raw[(2 * i) + 1])))) % 36;
			}
		} else {
			idx0 = seed % 6;
			idx1 = 16;
			idx2 = seed / 6;
			retval[j++] = vowels[idx0];
			retval[j++] = consonants[idx1];
			retval[j++] = vowels[idx2];
		}
	}
	retval[j++] = 'x';
	retval[j++] = '\0';
	return retval;
}

char*
key_fingerprint(Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
{
	char *retval = NULL; 
	u_char *dgst_raw;
	size_t dgst_raw_len; 
	
	dgst_raw = key_fingerprint_raw(k, dgst_type, &dgst_raw_len);
	if (!dgst_raw)
		fatal("key_fingerprint: null from key_fingerprint_raw()");
	switch(dgst_rep) {
	case SSH_FP_HEX:
		retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
		break;
	case SSH_FP_BUBBLEBABBLE:
		retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
		break;
	default:
		fatal("key_fingerprint_ex: bad digest representation %d",
		    dgst_rep);
		break;
a205 2
	memset(dgst_raw, 0, dgst_raw_len);
	xfree(dgst_raw);
d533 1
a533 1
	debug2("key_type_from_name: unknown key type '%s'", name);
@


1.11.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.25 2001/04/17 10:53:24 markus Exp $");
d214 1
a214 1
key_fingerprint_hex(u_char* dgst_raw, size_t dgst_raw_len)
d219 1
a219 1
	retval = xmalloc(dgst_raw_len * 3 + 1);
d231 1
a231 1
key_fingerprint_bubblebabble(u_char* dgst_raw, size_t dgst_raw_len)
d280 1
a280 1
	char *retval = NULL;
d282 1
a282 1
	size_t dgst_raw_len;
a629 22
}

int
key_names_valid2(const char *names)
{
	char *s, *cp, *p;

	if (names == NULL || strcmp(names, "") == 0)
		return 0;
	s = cp = xstrdup(names);
	for ((p = strsep(&cp, ",")); p && *p != '\0';
	     (p = strsep(&cp, ","))) {
		switch (key_type_from_name(p)) {
		case KEY_RSA1:
		case KEY_UNSPEC:
			xfree(s);
			return 0;
		}
	}
	debug3("key names ok: [%s]", names);
	xfree(s);
	return 1;
@


1.11.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d12 1
a12 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.32 2001/09/19 13:23:29 markus Exp $");
a56 1
	k->flags = 0;
d156 1
a156 1
static u_char*
d213 1
a213 1
static char*
d230 1
a230 1
static char*
d311 1
a311 1
static int
d347 1
a347 1
static int
d360 1
a360 1
/* returns 1 ok, -1 error */
d415 1
a415 1
			return -1;
d547 1
a547 1
static RSA *
d557 1
a557 1
static DSA*
d655 1
a655 1
key_from_blob(u_char *blob, int blen)
d730 2
a731 3
		error("key_to_blob: unsupported key type %d", key->type);
		buffer_free(&b);
		return 0;
a770 3
	if (signaturelen == 0)
		return -1;

@


1.11.2.6
log
@Merge OpenSSH 3.0
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.11.2.5 2001/09/27 00:15:42 miod Exp $");
d357 1
a357 1
	CRYPTO_free(buf);
@


1.11.2.7
log
@Merge OpenSSH 3.1.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.41 2002/02/28 15:46:33 markus Exp $");
d63 3
a65 6
		if ((rsa = RSA_new()) == NULL)
			fatal("key_new: RSA_new failed");
		if ((rsa->n = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((rsa->e = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
d69 5
a73 10
		if ((dsa = DSA_new()) == NULL)
			fatal("key_new: DSA_new failed");
		if ((dsa->p = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->q = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->g = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
		if ((dsa->pub_key = BN_new()) == NULL)
			fatal("key_new: BN_new failed");
d91 6
a96 12
		if ((k->rsa->d = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->iqmp = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->q = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->p = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->dmq1 = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
		if ((k->rsa->dmp1 = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
d99 1
a99 2
		if ((k->dsa->priv_key = BN_new()) == NULL)
			fatal("key_new_private: BN_new failed");
d158 1
a158 1
key_fingerprint_raw(Key *k, enum fp_type dgst_type, u_int *dgst_raw_length)
d160 1
a160 1
	const EVP_MD *md = NULL;
d164 1
a164 1
	u_int len = 0;
d204 2
a205 1
		EVP_DigestFinal(&ctx, retval, dgst_raw_length);
d215 1
a215 1
key_fingerprint_hex(u_char* dgst_raw, u_int dgst_raw_len)
d222 1
a222 1
	for (i = 0; i < dgst_raw_len; i++) {
d232 1
a232 1
key_fingerprint_bubblebabble(u_char* dgst_raw, u_int dgst_raw_len)
d283 2
a284 2
	u_int dgst_raw_len;

d288 1
a288 1
	switch (dgst_rep) {
d357 1
a357 1
	free(buf);
d374 1
a374 1
	switch (ret->type) {
a422 1
			xfree(blob);
a425 1
		xfree(blob);
d430 1
a456 1
		key_free(k);
d459 1
d476 2
a477 3
	int n, success = 0;
	u_int len, bits = 0;
	u_char *blob, *uu;
d491 2
d535 1
a535 2
key_size(Key *k)
{
d618 1
a618 1
	if (strcmp(name, "rsa1") == 0) {
d620 1
a620 1
	} else if (strcmp(name, "rsa") == 0) {
d622 1
a622 1
	} else if (strcmp(name, "dsa") == 0) {
d624 1
a624 1
	} else if (strcmp(name, "ssh-rsa") == 0) {
d626 1
a626 1
	} else if (strcmp(name, "ssh-dss") == 0) {
d642 1
a642 1
	    (p = strsep(&cp, ","))) {
d671 1
a671 1
	switch (type) {
d717 1
a717 1
	switch (key->type) {
d750 2
a751 2
    u_char **sigp, u_int *lenp,
    u_char *data, u_int datalen)
d753 1
a753 1
	switch (key->type) {
d770 2
a771 2
    u_char *signature, u_int signaturelen,
    u_char *data, u_int datalen)
d776 1
a776 1
	switch (key->type) {
@


1.10
log
@add SSH2/DSA support to the agent and some other DSA related cleanups.
(note that we cannot talk to ssh.com's ssh2 agents)
@
text
@d2 10
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Markus Friedl.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
a33 4
/*
 * read_bignum():
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 */
d45 1
a45 1
RCSID("$OpenBSD: key.c,v 1.9 2000/06/22 23:55:00 djm Exp $");
@


1.9
log
@Missing CVS idents; ok markus
@
text
@d44 1
a44 1
RCSID("$OpenBSD$");
d337 12
@


1.8
log
@cleanup fingerprinting, less hardcoded sizes
@
text
@d44 2
@


1.7
log
@fix key_read() for uuencoded keys w/o '='
@
text
@a123 2
#define FPRINT "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x"

d131 1
a131 1
	static char retval[80];
d152 2
d155 13
a167 8
		unsigned char d[16];
		EVP_MD_CTX md;
		EVP_DigestInit(&md, EVP_md5());
		EVP_DigestUpdate(&md, blob, len);
		EVP_DigestFinal(&md, d, NULL);
		snprintf(retval, sizeof(retval), FPRINT,
		    d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7],
		    d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15]);
@


1.6
log
@remote trailing comments before calling __b64_pton
@
text
@d259 1
a259 1
			error("uudecode %s failed", cp);
d263 4
a266 2
		if (k == NULL)
			 return 0;
d274 6
a279 4
		cp = strchr(cp, '=');
		if (cp == NULL)
			return 0;
		*cpp = cp + 1;
@


1.6.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d259 1
a259 1
			error("key_read: uudecode %s failed", cp);
d263 2
a264 4
		if (k == NULL) {
			error("key_read: dsa_key_from_blob %s failed", cp);
			return 0;
		}
d272 4
a275 6
		/* advance cp: skip whitespace and data */
		while (*cp == ' ' || *cp == '\t')
			cp++;
		while (*cp != '\0' && *cp != ' ' && *cp != '\t')
			cp++;
		*cpp = cp;
@


1.6.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@a43 2
RCSID("$OpenBSD: key.c,v 1.10 2000/08/19 21:34:43 markus Exp $");

d124 2
d133 1
a133 1
	static char retval[(EVP_MAX_MD_SIZE+1)*3];
a153 2
	retval[0] = '\0';

d155 8
a162 13
		int i;
		unsigned char digest[EVP_MAX_MD_SIZE];
		EVP_MD *md = EVP_md5();
		EVP_MD_CTX ctx;
		EVP_DigestInit(&ctx, md);
		EVP_DigestUpdate(&ctx, blob, len);
		EVP_DigestFinal(&ctx, digest, NULL);
		for(i = 0; i < md->md_size; i++) {
			char hex[4];
			snprintf(hex, sizeof(hex), "%02x:", digest[i]);
			strlcat(retval, hex, sizeof(retval));
		}
		retval[strlen(retval) - 1] = '\0';
a329 12
}
unsigned int
key_size(Key *k){
	switch (k->type) {
	case KEY_RSA:
		return BN_num_bits(k->rsa->n);
		break;
	case KEY_DSA:
		return BN_num_bits(k->dsa->p);
		break;
	}
	return 0;
@


1.6.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a1 10
 * read_bignum():
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
d12 5
d29 4
d44 1
a44 1
RCSID("$OpenBSD: key.c,v 1.11 2000/09/07 20:27:51 deraadt Exp $");
@


1.6.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d34 1
d36 3
a38 2
RCSID("$OpenBSD: key.c,v 1.17 2001/02/04 15:32:24 stevesk Exp $");

a39 1

d42 1
a42 3
#include "rsa.h"
#include "ssh-dss.h"
#include "ssh-rsa.h"
d44 4
a47 3
#include "buffer.h"
#include "bufaux.h"
#include "log.h"
a59 1
	case KEY_RSA1:
d74 1
a74 1
	case KEY_UNSPEC:
a81 24
Key *
key_new_private(int type)
{
	Key *k = key_new(type);
	switch (k->type) {
	case KEY_RSA1:
	case KEY_RSA:
		k->rsa->d = BN_new();
		k->rsa->iqmp = BN_new();
		k->rsa->q = BN_new();
		k->rsa->p = BN_new();
		k->rsa->dmq1 = BN_new();
		k->rsa->dmp1 = BN_new();
		break;
	case KEY_DSA:
		k->dsa->priv_key = BN_new();
		break;
	case KEY_UNSPEC:
		break;
	default:
		break;
	}
	return k;
}
a85 1
	case KEY_RSA1:
a95 2
	case KEY_UNSPEC:
		break;
a107 1
	case KEY_RSA1:
d135 1
a135 1
	u_char *blob = NULL;
a138 1
	retval[0] = '\0';
d140 1
a140 1
	case KEY_RSA1:
d149 1
a149 5
	case KEY_RSA:
		key_to_blob(k, &blob, &len);
		break;
	case KEY_UNSPEC:
		return retval;
d155 2
d159 1
a159 1
		u_char digest[EVP_MAX_MD_SIZE];
d229 1
a229 1
	xfree(buf);
d232 1
a232 3

/* returns 1 ok, -1 error, 0 type mismatch */
int
d236 4
a239 5
	int success = -1;
	char *cp, *space;
	int len, n, type;
	u_int bits;
	u_char *blob;
d244 1
a244 1
	case KEY_RSA1:
d247 1
a247 1
			return -1;	/* Bad bit count... */
d251 1
a251 1
			return -1;
d255 1
a255 1
			return -1;
d257 1
a257 2
			return -1;
		success = 1;
a258 2
	case KEY_UNSPEC:
	case KEY_RSA:
d260 1
a260 22
		space = strchr(cp, ' ');
		if (space == NULL) {
			debug3("key_read: no space");
			return -1;
		}
		*space = '\0';
		type = key_type_from_name(cp);
		*space = ' ';
		if (type == KEY_UNSPEC) {
			debug3("key_read: no key found");
			return -1;
		}
		cp = space+1;
		if (*cp == '\0') {
			debug3("key_read: short string");
			return -1;
		}
		if (ret->type == KEY_UNSPEC) {
			ret->type = type;
		} else if (ret->type != type) {
			/* is a key, but different type */
			debug3("key_read: type mismatch");
d262 1
a262 1
		}
d268 1
a268 1
			return -1;
d270 1
a270 1
		k = key_from_blob(blob, n);
d272 2
a273 2
			error("key_read: key_from_blob %s failed", cp);
			return -1;
d276 4
a279 28
		if (k->type != type) {
			error("key_read: type mismatch: encoding error");
			key_free(k);
			return -1;
		}
/*XXXX*/
		if (ret->type == KEY_RSA) {
			if (ret->rsa != NULL)
				RSA_free(ret->rsa);
			ret->rsa = k->rsa;
			k->rsa = NULL;
			success = 1;
#ifdef DEBUG_PK
			RSA_print_fp(stderr, ret->rsa, 8);
#endif
		} else {
			if (ret->dsa != NULL)
				DSA_free(ret->dsa);
			ret->dsa = k->dsa;
			k->dsa = NULL;
			success = 1;
#ifdef DEBUG_PK
			DSA_print_fp(stderr, ret->dsa, 8);
#endif
		}
/*XXXX*/
		if (success != 1)
			break;
d281 1
d293 1
a293 1
	return success;
d299 1
a299 1
	u_int bits = 0;
d301 1
a301 1
	if (key->type == KEY_RSA1 && key->rsa != NULL) {
d311 1
a311 2
	} else if ((key->type == KEY_DSA && key->dsa != NULL) ||
	    (key->type == KEY_RSA && key->rsa != NULL)) {
d313 2
a314 2
		u_char *blob, *uu;
		key_to_blob(key, &blob, &len);
d318 1
a318 1
			fprintf(f, "%s %s", key_ssh_name(key), uu);
a329 3
	case KEY_RSA1:
		return "RSA1";
		break;
d339 1
a339 14
char *
key_ssh_name(Key *k)
{
	switch (k->type) {
	case KEY_RSA:
		return "ssh-rsa";
		break;
	case KEY_DSA:
		return "ssh-dss";
		break;
	}
	return "ssh-unknown";
}
u_int
a341 1
	case KEY_RSA1:
a349 216
}

RSA *
rsa_generate_private_key(u_int bits)
{
	RSA *private;
	private = RSA_generate_key(bits, 35, NULL, NULL);
	if (private == NULL)
		fatal("rsa_generate_private_key: key generation failed.");
	return private;
}

DSA*
dsa_generate_private_key(u_int bits)
{
	DSA *private = DSA_generate_parameters(bits, NULL, 0, NULL, NULL, NULL, NULL);
	if (private == NULL)
		fatal("dsa_generate_private_key: DSA_generate_parameters failed");
	if (!DSA_generate_key(private))
		fatal("dsa_generate_private_key: DSA_generate_key failed.");
	if (private == NULL)
		fatal("dsa_generate_private_key: NULL.");
	return private;
}

Key *
key_generate(int type, u_int bits)
{
	Key *k = key_new(KEY_UNSPEC);
	switch (type) {
	case KEY_DSA:
		k->dsa = dsa_generate_private_key(bits);
		break;
	case KEY_RSA:
	case KEY_RSA1:
		k->rsa = rsa_generate_private_key(bits);
		break;
	default:
		fatal("key_generate: unknown type %d", type);
	}
	k->type = type;
	return k;
}

Key *
key_from_private(Key *k)
{
	Key *n = NULL;
	switch (k->type) {
	case KEY_DSA:
		n = key_new(k->type);
		BN_copy(n->dsa->p, k->dsa->p);
		BN_copy(n->dsa->q, k->dsa->q);
		BN_copy(n->dsa->g, k->dsa->g);
		BN_copy(n->dsa->pub_key, k->dsa->pub_key);
		break;
	case KEY_RSA:
	case KEY_RSA1:
		n = key_new(k->type);
		BN_copy(n->rsa->n, k->rsa->n);
		BN_copy(n->rsa->e, k->rsa->e);
		break;
	default:
		fatal("key_from_private: unknown type %d", k->type);
		break;
	}
	return n;
}

int
key_type_from_name(char *name)
{
	if (strcmp(name, "rsa1") == 0){
		return KEY_RSA1;
	} else if (strcmp(name, "rsa") == 0){
		return KEY_RSA;
	} else if (strcmp(name, "dsa") == 0){
		return KEY_DSA;
	} else if (strcmp(name, "ssh-rsa") == 0){
		return KEY_RSA;
	} else if (strcmp(name, "ssh-dss") == 0){
		return KEY_DSA;
	}
	debug("key_type_from_name: unknown key type '%s'", name);
	return KEY_UNSPEC;
}

Key *
key_from_blob(char *blob, int blen)
{
	Buffer b;
	char *ktype;
	int rlen, type;
	Key *key = NULL;

#ifdef DEBUG_PK
	dump_base64(stderr, blob, blen);
#endif
	buffer_init(&b);
	buffer_append(&b, blob, blen);
	ktype = buffer_get_string(&b, NULL);
	type = key_type_from_name(ktype);

	switch(type){
	case KEY_RSA:
		key = key_new(type);
		buffer_get_bignum2(&b, key->rsa->e);
		buffer_get_bignum2(&b, key->rsa->n);
#ifdef DEBUG_PK
		RSA_print_fp(stderr, key->rsa, 8);
#endif
		break;
	case KEY_DSA:
		key = key_new(type);
		buffer_get_bignum2(&b, key->dsa->p);
		buffer_get_bignum2(&b, key->dsa->q);
		buffer_get_bignum2(&b, key->dsa->g);
		buffer_get_bignum2(&b, key->dsa->pub_key);
#ifdef DEBUG_PK
		DSA_print_fp(stderr, key->dsa, 8);
#endif
		break;
	case KEY_UNSPEC:
		key = key_new(type);
		break;
	default:
		error("key_from_blob: cannot handle type %s", ktype);
		break;
	}
	rlen = buffer_len(&b);
	if (key != NULL && rlen != 0)
		error("key_from_blob: remaining bytes in key blob %d", rlen);
	xfree(ktype);
	buffer_free(&b);
	return key;
}

int
key_to_blob(Key *key, u_char **blobp, u_int *lenp)
{
	Buffer b;
	int len;
	u_char *buf;

	if (key == NULL) {
		error("key_to_blob: key == NULL");
		return 0;
	}
	buffer_init(&b);
	switch(key->type){
	case KEY_DSA:
		buffer_put_cstring(&b, key_ssh_name(key));
		buffer_put_bignum2(&b, key->dsa->p);
		buffer_put_bignum2(&b, key->dsa->q);
		buffer_put_bignum2(&b, key->dsa->g);
		buffer_put_bignum2(&b, key->dsa->pub_key);
		break;
	case KEY_RSA:
		buffer_put_cstring(&b, key_ssh_name(key));
		buffer_put_bignum2(&b, key->rsa->e);
		buffer_put_bignum2(&b, key->rsa->n);
		break;
	default:
		error("key_to_blob: illegal key type %d", key->type);
		break;
	}
	len = buffer_len(&b);
	buf = xmalloc(len);
	memcpy(buf, buffer_ptr(&b), len);
	memset(buffer_ptr(&b), 0, len);
	buffer_free(&b);
	if (lenp != NULL)
		*lenp = len;
	if (blobp != NULL)
		*blobp = buf;
	return len;
}

int
key_sign(
    Key *key,
    u_char **sigp, int *lenp,
    u_char *data, int datalen)
{
	switch(key->type){
	case KEY_DSA:
		return ssh_dss_sign(key, sigp, lenp, data, datalen);
		break;
	case KEY_RSA:
		return ssh_rsa_sign(key, sigp, lenp, data, datalen);
		break;
	default:
		error("key_sign: illegal key type %d", key->type);
		return -1;
		break;
	}
}

int
key_verify(
    Key *key,
    u_char *signature, int signaturelen,
    u_char *data, int datalen)
{
	switch(key->type){
	case KEY_DSA:
		return ssh_dss_verify(key, signature, signaturelen, data, datalen);
		break;
	case KEY_RSA:
		return ssh_rsa_verify(key, signature, signaturelen, data, datalen);
		break;
	default:
		error("key_verify: illegal key type %d", key->type);
		return -1;
		break;
	}
@


1.6.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: key.c,v 1.22 2001/03/12 22:02:01 markus Exp $");
d156 6
a161 2
u_char*
key_fingerprint_raw(Key *k, enum fp_type dgst_type, size_t *dgst_raw_length)
d163 1
a163 2
	EVP_MD *md = NULL;
	EVP_MD_CTX ctx;
a164 1
	u_char *retval = NULL;
d168 1
a168 13
	*dgst_raw_length = 0;

	switch (dgst_type) {
	case SSH_FP_MD5:
		md = EVP_md5();
		break;
	case SSH_FP_SHA1:
		md = EVP_sha1();
		break;
	default:
		fatal("key_fingerprint_raw: bad digest type %d",
		    dgst_type);
	}
d186 1
a186 1
		fatal("key_fingerprint_raw: bad key type %d", k->type);
d190 4
a193 1
		retval = xmalloc(EVP_MAX_MD_SIZE);
d196 7
a202 2
		EVP_DigestFinal(&ctx, retval, NULL);
		*dgst_raw_length = md->md_size;
a204 91
	} else {
		fatal("key_fingerprint_raw: blob is null");
	}
	return retval;
}

char*
key_fingerprint_hex(u_char* dgst_raw, size_t dgst_raw_len) 
{
	char *retval;
	int i;

	retval = xmalloc(dgst_raw_len * 3);
	retval[0] = '\0';
	for(i = 0; i < dgst_raw_len; i++) {
		char hex[4];
		snprintf(hex, sizeof(hex), "%02x:", dgst_raw[i]);
		strlcat(retval, hex, dgst_raw_len * 3);
	}
	retval[(dgst_raw_len * 3) - 1] = '\0';
	return retval;
}

char*
key_fingerprint_bubblebabble(u_char* dgst_raw, size_t dgst_raw_len) 
{
	char vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };
	char consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm',
	    'n', 'p', 'r', 's', 't', 'v', 'z', 'x' };
	u_int i, j = 0, rounds, seed = 1;
	char *retval;

	rounds = (dgst_raw_len / 2) + 1;
	retval = xmalloc(sizeof(char) * (rounds*6));
	retval[j++] = 'x';
	for (i = 0; i < rounds; i++) {
		u_int idx0, idx1, idx2, idx3, idx4;
		if ((i + 1 < rounds) || (dgst_raw_len % 2 != 0)) {
			idx0 = (((((u_int)(dgst_raw[2 * i])) >> 6) & 3) +
			    seed) % 6;
			idx1 = (((u_int)(dgst_raw[2 * i])) >> 2) & 15;
			idx2 = ((((u_int)(dgst_raw[2 * i])) & 3) +
			    (seed / 6)) % 6;
			retval[j++] = vowels[idx0];
			retval[j++] = consonants[idx1];
			retval[j++] = vowels[idx2];
			if ((i + 1) < rounds) {
				idx3 = (((u_int)(dgst_raw[(2 * i) + 1])) >> 4) & 15;
				idx4 = (((u_int)(dgst_raw[(2 * i) + 1]))) & 15;
				retval[j++] = consonants[idx3];
				retval[j++] = '-';
				retval[j++] = consonants[idx4];
				seed = ((seed * 5) +
				    ((((u_int)(dgst_raw[2 * i])) * 7) +
				    ((u_int)(dgst_raw[(2 * i) + 1])))) % 36;
			}
		} else {
			idx0 = seed % 6;
			idx1 = 16;
			idx2 = seed / 6;
			retval[j++] = vowels[idx0];
			retval[j++] = consonants[idx1];
			retval[j++] = vowels[idx2];
		}
	}
	retval[j++] = 'x';
	retval[j++] = '\0';
	return retval;
}

char*
key_fingerprint(Key *k, enum fp_type dgst_type, enum fp_rep dgst_rep)
{
	char *retval = NULL; 
	u_char *dgst_raw;
	size_t dgst_raw_len; 
	
	dgst_raw = key_fingerprint_raw(k, dgst_type, &dgst_raw_len);
	if (!dgst_raw)
		fatal("key_fingerprint: null from key_fingerprint_raw()");
	switch(dgst_rep) {
	case SSH_FP_HEX:
		retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
		break;
	case SSH_FP_BUBBLEBABBLE:
		retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
		break;
	default:
		fatal("key_fingerprint_ex: bad digest representation %d",
		    dgst_rep);
		break;
a205 2
	memset(dgst_raw, 0, dgst_raw_len);
	xfree(dgst_raw);
d533 1
a533 1
	debug2("key_type_from_name: unknown key type '%s'", name);
@


1.5
log
@replace broken uuencode w/ libc b64_ntop
@
text
@d258 4
@


1.4
log
@print key type when talking about host keys
@
text
@d300 5
a304 2
		n = uuencode(blob, len, uu);
		fprintf(f, "%s %s", SSH_DSS, uu);
a306 1
		success = 1;
@


1.3
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d308 13
@


1.2
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d41 4
d54 2
a71 2
		k->dsa = NULL;
		k->rsa = NULL;
d118 1
a118 1
		fatal("key_free: bad key type %d", a->type);
d134 1
a134 1
	unsigned char *buf = NULL;
d136 1
a136 1
	int nlen, elen, plen, qlen, glen, publen;
d143 3
a145 3
		buf = xmalloc(len);
		BN_bn2bin(k->rsa->n, buf);
		BN_bn2bin(k->rsa->e, buf + nlen);
d148 1
a148 10
		plen = BN_num_bytes(k->dsa->p);
		qlen = BN_num_bytes(k->dsa->q);
		glen = BN_num_bytes(k->dsa->g);
		publen = BN_num_bytes(k->dsa->pub_key);
		len = qlen + qlen + glen + publen;
		buf = xmalloc(len);
		BN_bn2bin(k->dsa->p, buf);
		BN_bn2bin(k->dsa->q, buf + plen);
		BN_bn2bin(k->dsa->g, buf + plen + qlen);
		BN_bn2bin(k->dsa->pub_key , buf + plen + qlen + glen);
d154 1
a154 1
	if (buf != NULL) {
d158 1
a158 1
		EVP_DigestUpdate(&md, buf, len);
d163 2
a164 2
		memset(buf, 0, len);
		xfree(buf);
d224 2
a225 2
int
key_read(Key *ret, unsigned int bits, char **cpp)
d227 8
d237 5
d244 1
d252 1
a252 1
		if (bits != 0)
d254 16
a269 7
		if (!read_bignum(cpp, ret->dsa->p))
			return 0;
		if (!read_bignum(cpp, ret->dsa->q))
			return 0;
		if (!read_bignum(cpp, ret->dsa->g))
			return 0;
		if (!read_bignum(cpp, ret->dsa->pub_key))
d271 1
d274 1
a274 1
		fatal("bad key type: %d", ret->type);
d277 1
a277 1
	return 1;
d296 9
a304 11
		/* bits == 0 means DSA key */
		bits = 0;
		fprintf(f, "%u", bits);
		if (write_bignum(f, key->dsa->p) &&
		    write_bignum(f, key->dsa->q) &&
		    write_bignum(f, key->dsa->g) &&
		    write_bignum(f, key->dsa->pub_key)) {
			success = 1;
		} else {
			error("key_write: failed for DSA key");
		}
@


1.1
log
@initial support for DSA keys. ok deraadt@@, niels@@
@
text
@d36 3
a38 3
#include <ssl/rsa.h>
#include <ssl/dsa.h>
#include <ssl/evp.h>
@

