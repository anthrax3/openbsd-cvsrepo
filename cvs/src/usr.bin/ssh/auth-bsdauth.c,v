head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.11.0.28
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.24
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.22
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.20
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.18
	OPENBSD_5_0:1.11.0.16
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.14
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.12
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.8
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.10
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2;
locks; strict;
comment	@ * @;


1.14
date	2015.10.20.23.24.25;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	KVrcISpunUJIXb7B;

1.13
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.12;
commitid	1h9UxAQmwdaqUzyX;

1.12
date	2014.03.12.04.50.32;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.21.08.15.29;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.25.00.05.40;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.19.13.11.47;	author dtucker;	state Exp;
branches
	1.6.4.1
	1.6.6.1;
next	1.5;

1.5
date	2002.06.30.21.59.45;	author deraadt;	state Exp;
branches
	1.5.8.1
	1.5.10.1;
next	1.4;

1.4
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.18.14.13.28;	author markus;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.1.2.1
date	2001.09.27.18.27.43;	author miod;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.1.4.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.1.6.1
date	2002.03.07.17.37.45;	author jason;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.10.11.14.51.51;	author miod;	state Exp;
branches;
next	;

1.5.8.1
date	2005.03.10.17.15.03;	author brad;	state Exp;
branches;
next	;

1.5.10.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	;

1.6.4.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.6.6.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Compare pointers to NULL rather than 0.

ok djm@@
@
text
@/* $OpenBSD: auth-bsdauth.c,v 1.13 2014/06/24 01:13:21 djm Exp $ */
/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdarg.h>
#include <stdio.h>

#include "xmalloc.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "log.h"
#include "buffer.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"

static void *
bsdauth_init_ctx(Authctxt *authctxt)
{
	return authctxt;
}

int
bsdauth_query(void *ctx, char **name, char **infotxt,
   u_int *numprompts, char ***prompts, u_int **echo_on)
{
	Authctxt *authctxt = ctx;
	char *challenge = NULL;

	*infotxt = NULL;
	*numprompts = 0;
	*prompts = NULL;
	*echo_on = NULL;

	if (authctxt->as != NULL) {
		debug2("bsdauth_query: try reuse session");
		challenge = auth_getitem(authctxt->as, AUTHV_CHALLENGE);
		if (challenge == NULL) {
			auth_close(authctxt->as);
			authctxt->as = NULL;
		}
	}

	if (challenge == NULL) {
		debug2("bsdauth_query: new bsd auth session");
		debug3("bsdauth_query: style %s",
		    authctxt->style ? authctxt->style : "<default>");
		authctxt->as = auth_userchallenge(authctxt->user,
		    authctxt->style, "auth-ssh", &challenge);
		if (authctxt->as == NULL)
			challenge = NULL;
		debug2("bsdauth_query: <%s>", challenge ? challenge : "empty");
	}

	if (challenge == NULL)
		return -1;

	*name = xstrdup("");
	*infotxt = xstrdup("");
	*numprompts = 1;
	*prompts = xcalloc(*numprompts, sizeof(char *));
	*echo_on = xcalloc(*numprompts, sizeof(u_int));
	(*prompts)[0] = xstrdup(challenge);

	return 0;
}

int
bsdauth_respond(void *ctx, u_int numresponses, char **responses)
{
	Authctxt *authctxt = ctx;
	int authok;

	if (!authctxt->valid)
		return -1;

	if (authctxt->as == NULL)
		error("bsdauth_respond: no bsd auth session");

	if (numresponses != 1)
		return -1;

	authok = auth_userresponse(authctxt->as, responses[0], 0);
	authctxt->as = NULL;
	debug3("bsdauth_respond: <%s> = <%d>", responses[0], authok);

	return (authok == 0) ? -1 : 0;
}

static void
bsdauth_free_ctx(void *ctx)
{
	Authctxt *authctxt = ctx;

	if (authctxt && authctxt->as) {
		auth_close(authctxt->as);
		authctxt->as = NULL;
	}
}

KbdintDevice bsdauth_device = {
	"bsdauth",
	bsdauth_init_ctx,
	bsdauth_query,
	bsdauth_respond,
	bsdauth_free_ctx
};

KbdintDevice mm_bsdauth_device = {
	"bsdauth",
	bsdauth_init_ctx,
	mm_bsdauth_query,
	mm_bsdauth_respond,
	bsdauth_free_ctx
};
@


1.13
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: auth-bsdauth.c,v 1.12 2014/03/12 04:50:32 djm Exp $ */
d101 1
a101 1
	if (authctxt->as == 0)
@


1.12
log
@don't count on things that accept arguments by reference to clear
things for us on error; most things do, but it's unsafe form.
@
text
@d1 1
a1 1
/* $OpenBSD: auth-bsdauth.c,v 1.11 2007/09/21 08:15:29 djm Exp $ */
d27 2
@


1.11
log
@unifdef -DBSD_AUTH
unifdef -USKEY

These options have been in use for some years;
ok markus@@ "no objection" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth-bsdauth.c,v 1.10 2006/08/03 03:34:41 deraadt Exp $ */
d51 5
@


1.10
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth-bsdauth.c,v 1.9 2006/03/25 13:17:01 djm Exp $ */
a27 1
#ifdef BSD_AUTH
a132 1
#endif
@


1.9
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d25 2
a26 1
#include "includes.h"
d30 2
d34 4
@


1.8
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.7
log
@RCSID() can die
@
text
@d71 2
a72 3
	*prompts = xmalloc(*numprompts * sizeof(char *));
	*echo_on = xmalloc(*numprompts * sizeof(u_int));
	(*echo_on)[0] = 0;
@


1.6
log
@Have keyboard-interactive code call the drivers even for responses for
invalid logins.  This allows the drivers themselves to decide how to handle
them and prevent leaking information where possible.  Existing behaviour for
bsdauth is maintained by checking authctxt->valid in the bsdauth driver.
Note that any third-party kbdint drivers will now need to be able to handle
responses for invalid logins.  ok markus@@
@
text
@a24 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.5 2002/06/30 21:59:45 deraadt Exp $");
@


1.6.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-bsdauth.c,v 1.10 2006/08/03 03:34:41 deraadt Exp $ */
d24 2
a25 2

#include <sys/types.h>
a28 2
#include "key.h"
#include "hostfile.h"
a30 4
#include "buffer.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d72 3
a74 2
	*prompts = xcalloc(*numprompts, sizeof(char *));
	*echo_on = xcalloc(*numprompts, sizeof(u_int));
@


1.6.6.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth-bsdauth.c,v 1.10 2006/08/03 03:34:41 deraadt Exp $ */
d24 2
a25 2

#include <sys/types.h>
a28 2
#include "key.h"
#include "hostfile.h"
a30 4
#include "buffer.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d72 3
a74 2
	*prompts = xcalloc(*numprompts, sizeof(char *));
	*echo_on = xcalloc(*numprompts, sizeof(u_int));
@


1.5
log
@minor KNF
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.4 2002/06/19 00:27:55 deraadt Exp $");
d85 3
@


1.5.8.1
log
@upgrade to OpenSSH 4.0
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.6 2005/01/19 13:11:47 dtucker Exp $");
a84 3

	if (!authctxt->valid)
		return -1;
@


1.5.10.1
log
@upgrade to OpenSSH 4.0
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.6 2005/01/19 13:11:47 dtucker Exp $");
a84 3

	if (!authctxt->valid)
		return -1;
@


1.4
log
@KNF done automatically while reading....
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.3 2002/03/18 17:50:31 provos Exp $");
d72 1
a72 1
	*prompts = xmalloc(*numprompts * sizeof(char*));
@


1.3
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.2 2001/12/19 07:18:56 deraadt Exp $");
d60 1
a60 1
		     authctxt->style, "auth-ssh", &challenge);
d69 2
a70 2
	*name       = xstrdup("");
	*infotxt    = xstrdup("");
@


1.3.2.1
log
@Pull in OpenSSH-3.4
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.4 2002/06/19 00:27:55 deraadt Exp $");
d60 1
a60 1
		    authctxt->style, "auth-ssh", &challenge);
d69 2
a70 2
	*name = xstrdup("");
	*infotxt = xstrdup("");
@


1.3.2.2
log
@Update to OpenSSH 3.5
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.5 2002/06/30 21:59:45 deraadt Exp $");
d72 1
a72 1
	*prompts = xmalloc(*numprompts * sizeof(char *));
@


1.2
log
@basic KNF done while i was looking for something else
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.1 2001/05/18 14:13:28 markus Exp $");
d31 1
d39 1
a39 1
static int
d80 1
a80 1
static int
d115 8
@


1.1
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.4 2001/03/28 22:43:31 markus Exp $");
d39 1
a39 1
bsdauth_query(void *ctx, char **name, char **infotxt, 
d42 2
a43 2
        Authctxt *authctxt = ctx;
        char *challenge = NULL;
d45 12
a56 12
        if (authctxt->as != NULL) {
                debug2("bsdauth_query: try reuse session");
                challenge = auth_getitem(authctxt->as, AUTHV_CHALLENGE);
                if (challenge == NULL) {
                        auth_close(authctxt->as);
                        authctxt->as = NULL;
                }
        }

        if (challenge == NULL) {
                debug2("bsdauth_query: new bsd auth session");
                debug3("bsdauth_query: style %s",
d58 1
a58 1
                authctxt->as = auth_userchallenge(authctxt->user,
d60 15
a74 15
                if (authctxt->as == NULL)
                        challenge = NULL;
                debug2("bsdauth_query: <%s>", challenge ? challenge : "empty");
        }
        
        if (challenge == NULL)
                return -1;

        *name       = xstrdup("");
        *infotxt    = xstrdup("");
        *numprompts = 1;
        *prompts = xmalloc(*numprompts * sizeof(char*));
        *echo_on = xmalloc(*numprompts * sizeof(u_int));
        (*echo_on)[0] = 0;
        (*prompts)[0] = xstrdup(challenge);
d76 1
a76 1
        return 0;
d82 2
a83 12
        Authctxt *authctxt = ctx;
        int authok;
        
        if (authctxt->as == 0)
                error("bsdauth_respond: no bsd auth session");

        if (numresponses != 1)
                return -1;

        authok = auth_userresponse(authctxt->as, responses[0], 0);
        authctxt->as = NULL;
        debug3("bsdauth_respond: <%s> = <%d>", responses[0], authok);
d85 11
a95 1
        return (authok == 0) ? -1 : 0;
d101 1
a101 1
        Authctxt *authctxt = ctx;
d103 4
a106 4
        if (authctxt && authctxt->as) {
                auth_close(authctxt->as);
                authctxt->as = NULL;
        }
@


1.1.6.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.2 2001/12/19 07:18:56 deraadt Exp $");
d39 1
a39 1
bsdauth_query(void *ctx, char **name, char **infotxt,
d42 2
a43 2
	Authctxt *authctxt = ctx;
	char *challenge = NULL;
d45 12
a56 12
	if (authctxt->as != NULL) {
		debug2("bsdauth_query: try reuse session");
		challenge = auth_getitem(authctxt->as, AUTHV_CHALLENGE);
		if (challenge == NULL) {
			auth_close(authctxt->as);
			authctxt->as = NULL;
		}
	}

	if (challenge == NULL) {
		debug2("bsdauth_query: new bsd auth session");
		debug3("bsdauth_query: style %s",
d58 1
a58 1
		authctxt->as = auth_userchallenge(authctxt->user,
d60 15
a74 15
		if (authctxt->as == NULL)
			challenge = NULL;
		debug2("bsdauth_query: <%s>", challenge ? challenge : "empty");
	}

	if (challenge == NULL)
		return -1;

	*name       = xstrdup("");
	*infotxt    = xstrdup("");
	*numprompts = 1;
	*prompts = xmalloc(*numprompts * sizeof(char*));
	*echo_on = xmalloc(*numprompts * sizeof(u_int));
	(*echo_on)[0] = 0;
	(*prompts)[0] = xstrdup(challenge);
d76 1
a76 1
	return 0;
d82 12
a93 2
	Authctxt *authctxt = ctx;
	int authok;
d95 1
a95 11
	if (authctxt->as == 0)
		error("bsdauth_respond: no bsd auth session");

	if (numresponses != 1)
		return -1;

	authok = auth_userresponse(authctxt->as, responses[0], 0);
	authctxt->as = NULL;
	debug3("bsdauth_respond: <%s> = <%d>", responses[0], authok);

	return (authok == 0) ? -1 : 0;
d101 1
a101 1
	Authctxt *authctxt = ctx;
d103 4
a106 4
	if (authctxt && authctxt->as) {
		auth_close(authctxt->as);
		authctxt->as = NULL;
	}
@


1.1.6.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.3 2002/03/18 17:50:31 provos Exp $");
a30 1
#include "monitor_wrap.h"
d38 1
a38 1
int
d79 1
a79 1
int
a113 8
	bsdauth_free_ctx
};

KbdintDevice mm_bsdauth_device = {
	"bsdauth",
	bsdauth_init_ctx,
	mm_bsdauth_query,
	mm_bsdauth_respond,
@


1.1.6.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.1.6.2 2002/05/17 00:03:23 miod Exp $");
d60 1
a60 1
		    authctxt->style, "auth-ssh", &challenge);
d69 2
a70 2
	*name = xstrdup("");
	*infotxt = xstrdup("");
@


1.1.6.4
log
@Update to OpenSSH 3.5
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.5 2002/06/30 21:59:45 deraadt Exp $");
d72 1
a72 1
	*prompts = xmalloc(*numprompts * sizeof(char *));
@


1.1.4.1
log
@Pull in OpenSSH-2.9.9
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.1 2001/05/18 14:13:28 markus Exp $");
@


1.1.4.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.2 2001/12/19 07:18:56 deraadt Exp $");
d39 1
a39 1
bsdauth_query(void *ctx, char **name, char **infotxt,
d42 2
a43 2
	Authctxt *authctxt = ctx;
	char *challenge = NULL;
d45 12
a56 12
	if (authctxt->as != NULL) {
		debug2("bsdauth_query: try reuse session");
		challenge = auth_getitem(authctxt->as, AUTHV_CHALLENGE);
		if (challenge == NULL) {
			auth_close(authctxt->as);
			authctxt->as = NULL;
		}
	}

	if (challenge == NULL) {
		debug2("bsdauth_query: new bsd auth session");
		debug3("bsdauth_query: style %s",
d58 1
a58 1
		authctxt->as = auth_userchallenge(authctxt->user,
d60 15
a74 15
		if (authctxt->as == NULL)
			challenge = NULL;
		debug2("bsdauth_query: <%s>", challenge ? challenge : "empty");
	}

	if (challenge == NULL)
		return -1;

	*name       = xstrdup("");
	*infotxt    = xstrdup("");
	*numprompts = 1;
	*prompts = xmalloc(*numprompts * sizeof(char*));
	*echo_on = xmalloc(*numprompts * sizeof(u_int));
	(*echo_on)[0] = 0;
	(*prompts)[0] = xstrdup(challenge);
d76 1
a76 1
	return 0;
d82 12
a93 2
	Authctxt *authctxt = ctx;
	int authok;
d95 1
a95 11
	if (authctxt->as == 0)
		error("bsdauth_respond: no bsd auth session");

	if (numresponses != 1)
		return -1;

	authok = auth_userresponse(authctxt->as, responses[0], 0);
	authctxt->as = NULL;
	debug3("bsdauth_respond: <%s> = <%d>", responses[0], authok);

	return (authok == 0) ? -1 : 0;
d101 1
a101 1
	Authctxt *authctxt = ctx;
d103 4
a106 4
	if (authctxt && authctxt->as) {
		auth_close(authctxt->as);
		authctxt->as = NULL;
	}
@


1.1.4.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.3 2002/03/18 17:50:31 provos Exp $");
a30 1
#include "monitor_wrap.h"
d38 1
a38 1
int
d79 1
a79 1
int
a113 8
	bsdauth_free_ctx
};

KbdintDevice mm_bsdauth_device = {
	"bsdauth",
	bsdauth_init_ctx,
	mm_bsdauth_query,
	mm_bsdauth_respond,
@


1.1.2.1
log
@A few files forgotten during last OpenSSH update. Spotted by naddy@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.1 2001/05/18 14:13:28 markus Exp $");
@


1.1.2.2
log
@Merge OpenSSH 3.1.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth-bsdauth.c,v 1.2 2001/12/19 07:18:56 deraadt Exp $");
d39 1
a39 1
bsdauth_query(void *ctx, char **name, char **infotxt,
d42 2
a43 2
	Authctxt *authctxt = ctx;
	char *challenge = NULL;
d45 12
a56 12
	if (authctxt->as != NULL) {
		debug2("bsdauth_query: try reuse session");
		challenge = auth_getitem(authctxt->as, AUTHV_CHALLENGE);
		if (challenge == NULL) {
			auth_close(authctxt->as);
			authctxt->as = NULL;
		}
	}

	if (challenge == NULL) {
		debug2("bsdauth_query: new bsd auth session");
		debug3("bsdauth_query: style %s",
d58 1
a58 1
		authctxt->as = auth_userchallenge(authctxt->user,
d60 15
a74 15
		if (authctxt->as == NULL)
			challenge = NULL;
		debug2("bsdauth_query: <%s>", challenge ? challenge : "empty");
	}

	if (challenge == NULL)
		return -1;

	*name       = xstrdup("");
	*infotxt    = xstrdup("");
	*numprompts = 1;
	*prompts = xmalloc(*numprompts * sizeof(char*));
	*echo_on = xmalloc(*numprompts * sizeof(u_int));
	(*echo_on)[0] = 0;
	(*prompts)[0] = xstrdup(challenge);
d76 1
a76 1
	return 0;
d82 12
a93 2
	Authctxt *authctxt = ctx;
	int authok;
d95 1
a95 11
	if (authctxt->as == 0)
		error("bsdauth_respond: no bsd auth session");

	if (numresponses != 1)
		return -1;

	authok = auth_userresponse(authctxt->as, responses[0], 0);
	authctxt->as = NULL;
	debug3("bsdauth_respond: <%s> = <%d>", responses[0], authok);

	return (authok == 0) ? -1 : 0;
d101 1
a101 1
	Authctxt *authctxt = ctx;
d103 4
a106 4
	if (authctxt && authctxt->as) {
		auth_close(authctxt->as);
		authctxt->as = NULL;
	}
@


