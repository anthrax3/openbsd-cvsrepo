head	1.180;
access;
symbols
	OPENBSD_6_2:1.180.0.2
	OPENBSD_6_2_BASE:1.180
	OPENBSD_6_1:1.178.0.4
	OPENBSD_6_1_BASE:1.178
	OPENBSD_6_0:1.175.0.4
	OPENBSD_6_0_BASE:1.175
	OPENBSD_5_9:1.172.0.2
	OPENBSD_5_9_BASE:1.172
	OPENBSD_5_8:1.170.0.4
	OPENBSD_5_8_BASE:1.170
	OPENBSD_5_7:1.170.0.2
	OPENBSD_5_7_BASE:1.170
	OPENBSD_5_6:1.164.0.4
	OPENBSD_5_6_BASE:1.164
	OPENBSD_5_5:1.158.0.4
	OPENBSD_5_5_BASE:1.158
	OPENBSD_5_4:1.148.0.2
	OPENBSD_5_4_BASE:1.148
	OPENBSD_5_3:1.142.0.2
	OPENBSD_5_3_BASE:1.142
	OPENBSD_5_2:1.136.0.2
	OPENBSD_5_2_BASE:1.136
	OPENBSD_5_1_BASE:1.134
	OPENBSD_5_1:1.134.0.2
	OPENBSD_5_0:1.132.0.4
	OPENBSD_5_0_BASE:1.132
	OPENBSD_4_9:1.132.0.2
	OPENBSD_4_9_BASE:1.132
	OPENBSD_4_8:1.125.0.2
	OPENBSD_4_8_BASE:1.125
	OPENBSD_4_7:1.123.0.2
	OPENBSD_4_7_BASE:1.123
	OPENBSD_4_6:1.107.0.6
	OPENBSD_4_6_BASE:1.107
	OPENBSD_4_5:1.107.0.2
	OPENBSD_4_5_BASE:1.107
	OPENBSD_4_4:1.103.0.2
	OPENBSD_4_4_BASE:1.103
	OPENBSD_4_3:1.99.0.2
	OPENBSD_4_3_BASE:1.99
	OPENBSD_4_2:1.96.0.4
	OPENBSD_4_2_BASE:1.96
	OPENBSD_4_1:1.96.0.2
	OPENBSD_4_1_BASE:1.96
	OPENBSD_4_0:1.91.0.4
	OPENBSD_4_0_BASE:1.91
	OPENBSD_3_9:1.75.0.2
	OPENBSD_3_9_BASE:1.75
	OPENBSD_3_8:1.66.0.2
	OPENBSD_3_8_BASE:1.66
	OPENBSD_3_7:1.63.0.2
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.34.0.2
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_8:1.7.0.2;
locks; strict;
comment	@ * @;


1.180
date	2017.06.10.06.33.34;	author djm;	state Exp;
branches;
next	1.179;
commitid	nrrUKMG7vxt7Omw7;

1.179
date	2017.05.02.08.54.19;	author djm;	state Exp;
branches;
next	1.178;
commitid	aw1gyRpicXRAmZ0Z;

1.178
date	2017.02.15.01.46.47;	author djm;	state Exp;
branches;
next	1.177;
commitid	Bc6CuGuBIHvOGgMC;

1.177
date	2016.10.18.12.41.22;	author millert;	state Exp;
branches;
next	1.176;
commitid	yVmu0vcBR0neq1Rf;

1.176
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.175;
commitid	ZllbGwdb0fOmLhjK;

1.175
date	2016.07.22.03.47.36;	author djm;	state Exp;
branches;
next	1.174;
commitid	AcNnFjrGYofLly3y;

1.174
date	2016.05.25.23.48.45;	author schwarze;	state Exp;
branches;
next	1.173;
commitid	NPBJoBfuBDOIqIQi;

1.173
date	2016.04.08.08.19.17;	author djm;	state Exp;
branches;
next	1.172;
commitid	muNH4U8SNAOORI3Q;

1.172
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.171;
commitid	ut5A0buLh4mhCTFu;

1.171
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.170;
commitid	0Dp7Dy9FuNZesYo2;

1.170
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.169;
commitid	cBx23BaCk6gYBpRj;

1.169
date	2015.01.14.13.54.13;	author djm;	state Exp;
branches;
next	1.168;
commitid	5mVYZPiIJUHzgjMn;

1.168
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.167;
commitid	9QOFSShUOtA0kQLF;

1.167
date	2014.10.06.00.47.15;	author djm;	state Exp;
branches;
next	1.166;
commitid	uKG4GNsD0gMRSiax;

1.166
date	2014.08.20.01.28.55;	author deraadt;	state Exp;
branches;
next	1.165;
commitid	1WABOtiD9HAoN3ba;

1.165
date	2014.08.19.23.57.18;	author djm;	state Exp;
branches;
next	1.164;
commitid	Z4xmkgDwZWyzW7Bh;

1.164
date	2014.07.09.01.45.10;	author djm;	state Exp;
branches;
next	1.163;
commitid	y44aVKlQWPpRFhqt;

1.163
date	2014.05.05.07.02.30;	author logan;	state Exp;
branches;
next	1.162;

1.162
date	2014.04.29.20.36.51;	author dtucker;	state Exp;
branches;
next	1.161;

1.161
date	2014.04.29.19.58.50;	author dtucker;	state Exp;
branches;
next	1.160;

1.160
date	2014.04.22.10.07.12;	author logan;	state Exp;
branches;
next	1.159;

1.159
date	2014.04.21.14.36.16;	author logan;	state Exp;
branches;
next	1.158;

1.158
date	2013.11.20.20.54.10;	author deraadt;	state Exp;
branches;
next	1.157;

1.157
date	2013.10.17.07.35.48;	author jmc;	state Exp;
branches;
next	1.156;

1.156
date	2013.10.17.00.30.13;	author djm;	state Exp;
branches;
next	1.155;

1.155
date	2013.08.31.00.13.54;	author djm;	state Exp;
branches;
next	1.154;

1.154
date	2013.08.09.03.56.42;	author djm;	state Exp;
branches;
next	1.153;

1.153
date	2013.08.09.03.37.25;	author djm;	state Exp;
branches;
next	1.152;

1.152
date	2013.08.08.05.04.03;	author djm;	state Exp;
branches;
next	1.151;

1.151
date	2013.08.08.04.52.04;	author djm;	state Exp;
branches;
next	1.150;

1.150
date	2013.08.07.06.24.51;	author jmc;	state Exp;
branches;
next	1.149;

1.149
date	2013.08.06.23.03.49;	author djm;	state Exp;
branches;
next	1.148;

1.148
date	2013.07.25.00.56.52;	author djm;	state Exp;
branches;
next	1.147;

1.147
date	2013.07.12.00.20.00;	author djm;	state Exp;
branches;
next	1.146;

1.146
date	2013.06.04.20.42.36;	author dtucker;	state Exp;
branches;
next	1.145;

1.145
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.144;

1.144
date	2013.05.16.09.08.41;	author dtucker;	state Exp;
branches;
next	1.143;

1.143
date	2013.04.18.02.16.07;	author djm;	state Exp;
branches;
next	1.142;

1.142
date	2013.02.08.00.41.12;	author djm;	state Exp;
branches;
next	1.141;

1.141
date	2012.10.05.12.34.39;	author markus;	state Exp;
branches;
next	1.140;

1.140
date	2012.09.21.10.55.04;	author dtucker;	state Exp;
branches;
next	1.139;

1.139
date	2012.09.21.10.53.07;	author dtucker;	state Exp;
branches;
next	1.138;

1.138
date	2012.09.18.10.36.12;	author dtucker;	state Exp;
branches;
next	1.137;

1.137
date	2012.09.17.09.54.44;	author djm;	state Exp;
branches;
next	1.136;

1.136
date	2012.06.22.14.36.33;	author dtucker;	state Exp;
branches;
next	1.135;

1.135
date	2012.04.20.03.24.23;	author djm;	state Exp;
branches;
next	1.134;

1.134
date	2011.11.16.12.24.28;	author oga;	state Exp;
branches;
next	1.133;

1.133
date	2011.09.22.06.29.03;	author djm;	state Exp;
branches;
next	1.132;

1.132
date	2010.12.04.00.18.01;	author djm;	state Exp;
branches;
next	1.131;

1.131
date	2010.10.23.22.06.12;	author sthen;	state Exp;
branches;
next	1.130;

1.130
date	2010.10.05.05.13.18;	author djm;	state Exp;
branches;
next	1.129;

1.129
date	2010.09.26.22.26.33;	author djm;	state Exp;
branches;
next	1.128;

1.128
date	2010.09.25.09.30.16;	author djm;	state Exp;
branches;
next	1.127;

1.127
date	2010.09.23.13.34.43;	author jmc;	state Exp;
branches;
next	1.126;

1.126
date	2010.09.22.22.58.51;	author djm;	state Exp;
branches;
next	1.125;

1.125
date	2010.06.18.00.58.39;	author djm;	state Exp;
branches;
next	1.124;

1.124
date	2010.05.05.04.22.09;	author dtucker;	state Exp;
branches;
next	1.123;

1.123
date	2010.01.27.19.21.39;	author djm;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.15.00.05.22;	author guenther;	state Exp;
branches;
next	1.121;

1.121
date	2010.01.13.12.48.34;	author jmc;	state Exp;
branches;
next	1.120;

1.120
date	2010.01.13.04.10.50;	author djm;	state Exp;
branches;
next	1.119;

1.119
date	2010.01.13.01.40.16;	author djm;	state Exp;
branches;
next	1.118;

1.118
date	2010.01.09.11.13.02;	author dtucker;	state Exp;
branches;
next	1.117;

1.117
date	2010.01.08.21.50.49;	author dtucker;	state Exp;
branches;
next	1.116;

1.116
date	2010.01.04.02.03.57;	author djm;	state Exp;
branches;
next	1.115;

1.115
date	2009.12.20.07.28.36;	author guenther;	state Exp;
branches;
next	1.114;

1.114
date	2009.12.06.23.53.54;	author dtucker;	state Exp;
branches;
next	1.113;

1.113
date	2009.11.22.13.18.00;	author halex;	state Exp;
branches;
next	1.112;

1.112
date	2009.11.20.00.54.01;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2009.08.18.18.36.21;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2009.08.13.13.39.54;	author jmc;	state Exp;
branches;
next	1.109;

1.109
date	2009.08.13.01.11.19;	author djm;	state Exp;
branches;
next	1.108;

1.108
date	2009.08.12.00.13.00;	author djm;	state Exp;
branches;
next	1.107;

1.107
date	2009.02.02.11.15.14;	author dtucker;	state Exp;
branches;
next	1.106;

1.106
date	2008.12.09.15.35.00;	author sobrado;	state Exp;
branches;
next	1.105;

1.105
date	2008.12.09.03.04.39;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2008.12.09.02.39.59;	author djm;	state Exp;
branches;
next	1.103;

1.103
date	2008.07.13.22.16.03;	author djm;	state Exp;
branches;
next	1.102;

1.102
date	2008.06.21.07.46.46;	author martynas;	state Exp;
branches;
next	1.101;

1.101
date	2008.06.08.20.15.29;	author dtucker;	state Exp;
branches;
next	1.100;

1.100
date	2008.04.18.12.32.11;	author djm;	state Exp;
branches;
next	1.99;

1.99
date	2008.01.20.00.38.30;	author djm;	state Exp;
branches;
next	1.98;

1.98
date	2007.12.12.05.04.03;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2007.10.24.03.30.02;	author djm;	state Exp;
branches;
next	1.96;

1.96
date	2007.01.03.04.09.15;	author stevesk;	state Exp;
branches;
next	1.95;

1.95
date	2007.01.03.03.01.40;	author stevesk;	state Exp;
branches;
next	1.94;

1.94
date	2006.11.23.01.35.11;	author ray;	state Exp;
branches;
next	1.93;

1.93
date	2006.09.30.17.48.22;	author ray;	state Exp;
branches;
next	1.92;

1.92
date	2006.09.19.05.52.23;	author otto;	state Exp;
branches;
next	1.91;

1.91
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.91.4.1;
next	1.90;

1.90
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.89;

1.89
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.88;

1.88
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.87;

1.87
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.86;

1.86
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.85;

1.85
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.84;

1.84
date	2006.07.10.16.01.57;	author stevesk;	state Exp;
branches;
next	1.83;

1.83
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.82;

1.82
date	2006.05.17.12.43.34;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2006.04.20.21.53.44;	author djm;	state Exp;
branches;
next	1.80;

1.80
date	2006.03.27.23.15.46;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.25.01.30.23;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2006.03.19.02.22.56;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches;
next	1.73;

1.73
date	2006.02.10.01.44.27;	author stevesk;	state Exp;
branches;
next	1.72;

1.72
date	2006.02.10.00.27.13;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.70;

1.70
date	2006.01.31.10.19.02;	author djm;	state Exp;
branches;
next	1.69;

1.69
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.68;

1.68
date	2005.10.31.06.15.04;	author dtucker;	state Exp;
branches;
next	1.67;

1.67
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.66;

1.66
date	2005.08.08.13.22.48;	author jaredy;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.10.22.01.05;	author deraadt;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2005.02.20.22.59.06;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2005.01.24.10.22.06;	author dtucker;	state Exp;
branches;
next	1.60;

1.60
date	2004.12.10.03.10.42;	author fgsch;	state Exp;
branches;
next	1.59;

1.59
date	2004.11.29.07.41.24;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2004.11.25.22.22.14;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2004.11.05.12.19.56;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2004.06.25.23.21.38;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.22.01.16.39;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.21.22.30.45;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2004.06.21.22.04.50;	author djm;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.20.18.53.39;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.18.06.13.25;	author dtucker;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.03.12.22.20;	author pedro;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.26.08.59.57;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.19.12.17.33;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.03.09.31.20;	author djm;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2004.02.17.11.03.08;	author djm;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.17.07.17.29;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.17.05.39.51;	author djm;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.27.10.08.10;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.21.03.07.59;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.13.09.25.05;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.08.08.27.36;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.10.20.05.55;	author markus;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2003.06.04.12.41.22;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.15.03.44.00;	author mouring;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.10.08.19.07;	author fgsch;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2003.01.08.23.53.26;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.27.17.53.35;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.25.01.16.59;	author mouring;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2002.06.23.09.30.14;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.02.17.37.48;	author markus;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.03.30.18.51.15;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.12.12.32.27;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.06.14.27.23;	author mpech;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.05.00.00.46;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.04.21.53.12;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.19.19.24.19;	author stevesk;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.09.17.20.38.09;	author stevesk;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.17.17.57.57;	author stevesk;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.08.19.45.25;	author mouring;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.03.23.09.53;	author mouring;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.16.02.31.44;	author mouring;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.04.12.23.17.54;	author mouring;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.08.20.52.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.05.10.42.54;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.07.10.11.23;	author djm;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.03.06.06.11.44;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.03.23.52.22;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.28.05.36.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.08.00.04.52;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.02.07.22.27.18;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.06.23.53.54;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.06.22.06.21;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.06.22.05.25;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.04.15.32.25;	author stevesk;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.04.11.11.54;	author djm;	state Exp;
branches;
next	;

1.7.2.1
date	2001.02.16.20.13.16;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.02.19.17.19.25;	author jason;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.03.21.19.46.29;	author jason;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.05.07.21.09.35;	author jason;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.11.2.1
date	2001.03.12.15.44.15;	author jason;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.03.21.18.53.07;	author jason;	state Exp;
branches;
next	;

1.15.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.21.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.29.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.31.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.34.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.37.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.45.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.56.2.1
date	2005.03.10.16.28.28;	author brad;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.56.2.3;

1.56.2.3
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.63.2.1
date	2005.09.04.18.40.06;	author brad;	state Exp;
branches;
next	1.63.2.2;

1.63.2.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.66.2.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.66.2.2;

1.66.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.66.2.3;

1.66.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.75.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.91.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.180
log
@implement sorting for globbed ls; bz#2649 ok dtucker@@
@
text
@/* $OpenBSD: sftp.c,v 1.179 2017/05/02 08:54:19 djm Exp $ */
/*
 * Copyright (c) 2001-2004 Damien Miller <djm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/statvfs.h>

#include <ctype.h>
#include <errno.h>
#include <glob.h>
#include <histedit.h>
#include <paths.h>
#include <libgen.h>
#include <locale.h>
#include <signal.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>
#include <stdarg.h>

#include "xmalloc.h"
#include "log.h"
#include "pathnames.h"
#include "misc.h"
#include "utf8.h"

#include "sftp.h"
#include "ssherr.h"
#include "sshbuf.h"
#include "sftp-common.h"
#include "sftp-client.h"

#define DEFAULT_COPY_BUFLEN	32768	/* Size of buffer for up/download */
#define DEFAULT_NUM_REQUESTS	64	/* # concurrent outstanding requests */

/* File to read commands from */
FILE* infile;

/* Are we in batchfile mode? */
int batchmode = 0;

/* PID of ssh transport process */
static pid_t sshpid = -1;

/* Suppress diagnositic messages */
int quiet = 0;

/* This is set to 0 if the progressmeter is not desired. */
int showprogress = 1;

/* When this option is set, we always recursively download/upload directories */
int global_rflag = 0;

/* When this option is set, we resume download or upload if possible */
int global_aflag = 0;

/* When this option is set, the file transfers will always preserve times */
int global_pflag = 0;

/* When this option is set, transfers will have fsync() called on each file */
int global_fflag = 0;

/* SIGINT received during command processing */
volatile sig_atomic_t interrupted = 0;

/* I wish qsort() took a separate ctx for the comparison function...*/
int sort_flag;
glob_t *sort_glob;

/* Context used for commandline completion */
struct complete_ctx {
	struct sftp_conn *conn;
	char **remote_pathp;
};

int remote_glob(struct sftp_conn *, const char *, int,
    int (*)(const char *, int), glob_t *); /* proto for sftp-glob.c */

/* Separators for interactive commands */
#define WHITESPACE " \t\r\n"

/* ls flags */
#define LS_LONG_VIEW	0x0001	/* Full view ala ls -l */
#define LS_SHORT_VIEW	0x0002	/* Single row view ala ls -1 */
#define LS_NUMERIC_VIEW	0x0004	/* Long view with numeric uid/gid */
#define LS_NAME_SORT	0x0008	/* Sort by name (default) */
#define LS_TIME_SORT	0x0010	/* Sort by mtime */
#define LS_SIZE_SORT	0x0020	/* Sort by file size */
#define LS_REVERSE_SORT	0x0040	/* Reverse sort order */
#define LS_SHOW_ALL	0x0080	/* Don't skip filenames starting with '.' */
#define LS_SI_UNITS	0x0100	/* Display sizes as K, M, G, etc. */

#define VIEW_FLAGS	(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW|LS_SI_UNITS)
#define SORT_FLAGS	(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)

/* Commands for interactive mode */
enum sftp_command {
	I_CHDIR = 1,
	I_CHGRP,
	I_CHMOD,
	I_CHOWN,
	I_DF,
	I_GET,
	I_HELP,
	I_LCHDIR,
	I_LINK,
	I_LLS,
	I_LMKDIR,
	I_LPWD,
	I_LS,
	I_LUMASK,
	I_MKDIR,
	I_PUT,
	I_PWD,
	I_QUIT,
	I_REGET,
	I_RENAME,
	I_REPUT,
	I_RM,
	I_RMDIR,
	I_SHELL,
	I_SYMLINK,
	I_VERSION,
	I_PROGRESS,
};

struct CMD {
	const char *c;
	const int n;
	const int t;
};

/* Type of completion */
#define NOARGS	0
#define REMOTE	1
#define LOCAL	2

static const struct CMD cmds[] = {
	{ "bye",	I_QUIT,		NOARGS	},
	{ "cd",		I_CHDIR,	REMOTE	},
	{ "chdir",	I_CHDIR,	REMOTE	},
	{ "chgrp",	I_CHGRP,	REMOTE	},
	{ "chmod",	I_CHMOD,	REMOTE	},
	{ "chown",	I_CHOWN,	REMOTE	},
	{ "df",		I_DF,		REMOTE	},
	{ "dir",	I_LS,		REMOTE	},
	{ "exit",	I_QUIT,		NOARGS	},
	{ "get",	I_GET,		REMOTE	},
	{ "help",	I_HELP,		NOARGS	},
	{ "lcd",	I_LCHDIR,	LOCAL	},
	{ "lchdir",	I_LCHDIR,	LOCAL	},
	{ "lls",	I_LLS,		LOCAL	},
	{ "lmkdir",	I_LMKDIR,	LOCAL	},
	{ "ln",		I_LINK,		REMOTE	},
	{ "lpwd",	I_LPWD,		LOCAL	},
	{ "ls",		I_LS,		REMOTE	},
	{ "lumask",	I_LUMASK,	NOARGS	},
	{ "mkdir",	I_MKDIR,	REMOTE	},
	{ "mget",	I_GET,		REMOTE	},
	{ "mput",	I_PUT,		LOCAL	},
	{ "progress",	I_PROGRESS,	NOARGS	},
	{ "put",	I_PUT,		LOCAL	},
	{ "pwd",	I_PWD,		REMOTE	},
	{ "quit",	I_QUIT,		NOARGS	},
	{ "reget",	I_REGET,	REMOTE	},
	{ "rename",	I_RENAME,	REMOTE	},
	{ "reput",	I_REPUT,	LOCAL	},
	{ "rm",		I_RM,		REMOTE	},
	{ "rmdir",	I_RMDIR,	REMOTE	},
	{ "symlink",	I_SYMLINK,	REMOTE	},
	{ "version",	I_VERSION,	NOARGS	},
	{ "!",		I_SHELL,	NOARGS	},
	{ "?",		I_HELP,		NOARGS	},
	{ NULL,		-1,		-1	}
};

int interactive_loop(struct sftp_conn *, char *file1, char *file2);

/* ARGSUSED */
static void
killchild(int signo)
{
	if (sshpid > 1) {
		kill(sshpid, SIGTERM);
		waitpid(sshpid, NULL, 0);
	}

	_exit(1);
}

/* ARGSUSED */
static void
suspchild(int signo)
{
	if (sshpid > 1) {
		kill(sshpid, signo);
		while (waitpid(sshpid, NULL, WUNTRACED) == -1 && errno == EINTR)
			continue;
	}
	kill(getpid(), SIGSTOP);
}

/* ARGSUSED */
static void
cmd_interrupt(int signo)
{
	const char msg[] = "\rInterrupt  \n";
	int olderrno = errno;

	(void)write(STDERR_FILENO, msg, sizeof(msg) - 1);
	interrupted = 1;
	errno = olderrno;
}

static void
help(void)
{
	printf("Available commands:\n"
	    "bye                                Quit sftp\n"
	    "cd path                            Change remote directory to 'path'\n"
	    "chgrp grp path                     Change group of file 'path' to 'grp'\n"
	    "chmod mode path                    Change permissions of file 'path' to 'mode'\n"
	    "chown own path                     Change owner of file 'path' to 'own'\n"
	    "df [-hi] [path]                    Display statistics for current directory or\n"
	    "                                   filesystem containing 'path'\n"
	    "exit                               Quit sftp\n"
	    "get [-afPpRr] remote [local]       Download file\n"
	    "reget [-fPpRr] remote [local]      Resume download file\n"
	    "reput [-fPpRr] [local] remote      Resume upload file\n"
	    "help                               Display this help text\n"
	    "lcd path                           Change local directory to 'path'\n"
	    "lls [ls-options [path]]            Display local directory listing\n"
	    "lmkdir path                        Create local directory\n"
	    "ln [-s] oldpath newpath            Link remote file (-s for symlink)\n"
	    "lpwd                               Print local working directory\n"
	    "ls [-1afhlnrSt] [path]             Display remote directory listing\n"
	    "lumask umask                       Set local umask to 'umask'\n"
	    "mkdir path                         Create remote directory\n"
	    "progress                           Toggle display of progress meter\n"
	    "put [-afPpRr] local [remote]       Upload file\n"
	    "pwd                                Display remote working directory\n"
	    "quit                               Quit sftp\n"
	    "rename oldpath newpath             Rename remote file\n"
	    "rm path                            Delete remote file\n"
	    "rmdir path                         Remove remote directory\n"
	    "symlink oldpath newpath            Symlink remote file\n"
	    "version                            Show SFTP version\n"
	    "!command                           Execute 'command' in local shell\n"
	    "!                                  Escape to local shell\n"
	    "?                                  Synonym for help\n");
}

static void
local_do_shell(const char *args)
{
	int status;
	char *shell;
	pid_t pid;

	if (!*args)
		args = NULL;

	if ((shell = getenv("SHELL")) == NULL || *shell == '\0')
		shell = _PATH_BSHELL;

	if ((pid = fork()) == -1)
		fatal("Couldn't fork: %s", strerror(errno));

	if (pid == 0) {
		/* XXX: child has pipe fds to ssh subproc open - issue? */
		if (args) {
			debug3("Executing %s -c \"%s\"", shell, args);
			execl(shell, shell, "-c", args, (char *)NULL);
		} else {
			debug3("Executing %s", shell);
			execl(shell, shell, (char *)NULL);
		}
		fprintf(stderr, "Couldn't execute \"%s\": %s\n", shell,
		    strerror(errno));
		_exit(1);
	}
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));
	if (!WIFEXITED(status))
		error("Shell exited abnormally");
	else if (WEXITSTATUS(status))
		error("Shell exited with status %d", WEXITSTATUS(status));
}

static void
local_do_ls(const char *args)
{
	if (!args || !*args)
		local_do_shell(_PATH_LS);
	else {
		int len = strlen(_PATH_LS " ") + strlen(args) + 1;
		char *buf = xmalloc(len);

		/* XXX: quoting - rip quoting code from ftp? */
		snprintf(buf, len, _PATH_LS " %s", args);
		local_do_shell(buf);
		free(buf);
	}
}

/* Strip one path (usually the pwd) from the start of another */
static char *
path_strip(const char *path, const char *strip)
{
	size_t len;

	if (strip == NULL)
		return (xstrdup(path));

	len = strlen(strip);
	if (strncmp(path, strip, len) == 0) {
		if (strip[len - 1] != '/' && path[len] == '/')
			len++;
		return (xstrdup(path + len));
	}

	return (xstrdup(path));
}

static char *
make_absolute(char *p, const char *pwd)
{
	char *abs_str;

	/* Derelativise */
	if (p && p[0] != '/') {
		abs_str = path_append(pwd, p);
		free(p);
		return(abs_str);
	} else
		return(p);
}

static int
parse_getput_flags(const char *cmd, char **argv, int argc,
    int *aflag, int *fflag, int *pflag, int *rflag)
{
	extern int opterr, optind, optopt, optreset;
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*aflag = *fflag = *rflag = *pflag = 0;
	while ((ch = getopt(argc, argv, "afPpRr")) != -1) {
		switch (ch) {
		case 'a':
			*aflag = 1;
			break;
		case 'f':
			*fflag = 1;
			break;
		case 'p':
		case 'P':
			*pflag = 1;
			break;
		case 'r':
		case 'R':
			*rflag = 1;
			break;
		default:
			error("%s: Invalid flag -%c", cmd, optopt);
			return -1;
		}
	}

	return optind;
}

static int
parse_link_flags(const char *cmd, char **argv, int argc, int *sflag)
{
	extern int opterr, optind, optopt, optreset;
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*sflag = 0;
	while ((ch = getopt(argc, argv, "s")) != -1) {
		switch (ch) {
		case 's':
			*sflag = 1;
			break;
		default:
			error("%s: Invalid flag -%c", cmd, optopt);
			return -1;
		}
	}

	return optind;
}

static int
parse_rename_flags(const char *cmd, char **argv, int argc, int *lflag)
{
	extern int opterr, optind, optopt, optreset;
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*lflag = 0;
	while ((ch = getopt(argc, argv, "l")) != -1) {
		switch (ch) {
		case 'l':
			*lflag = 1;
			break;
		default:
			error("%s: Invalid flag -%c", cmd, optopt);
			return -1;
		}
	}

	return optind;
}

static int
parse_ls_flags(char **argv, int argc, int *lflag)
{
	extern int opterr, optind, optopt, optreset;
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*lflag = LS_NAME_SORT;
	while ((ch = getopt(argc, argv, "1Safhlnrt")) != -1) {
		switch (ch) {
		case '1':
			*lflag &= ~VIEW_FLAGS;
			*lflag |= LS_SHORT_VIEW;
			break;
		case 'S':
			*lflag &= ~SORT_FLAGS;
			*lflag |= LS_SIZE_SORT;
			break;
		case 'a':
			*lflag |= LS_SHOW_ALL;
			break;
		case 'f':
			*lflag &= ~SORT_FLAGS;
			break;
		case 'h':
			*lflag |= LS_SI_UNITS;
			break;
		case 'l':
			*lflag &= ~LS_SHORT_VIEW;
			*lflag |= LS_LONG_VIEW;
			break;
		case 'n':
			*lflag &= ~LS_SHORT_VIEW;
			*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;
			break;
		case 'r':
			*lflag |= LS_REVERSE_SORT;
			break;
		case 't':
			*lflag &= ~SORT_FLAGS;
			*lflag |= LS_TIME_SORT;
			break;
		default:
			error("ls: Invalid flag -%c", optopt);
			return -1;
		}
	}

	return optind;
}

static int
parse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)
{
	extern int opterr, optind, optopt, optreset;
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*hflag = *iflag = 0;
	while ((ch = getopt(argc, argv, "hi")) != -1) {
		switch (ch) {
		case 'h':
			*hflag = 1;
			break;
		case 'i':
			*iflag = 1;
			break;
		default:
			error("%s: Invalid flag -%c", cmd, optopt);
			return -1;
		}
	}

	return optind;
}

static int
parse_no_flags(const char *cmd, char **argv, int argc)
{
	extern int opterr, optind, optopt, optreset;
	int ch;

	optind = optreset = 1;
	opterr = 0;

	while ((ch = getopt(argc, argv, "")) != -1) {
		switch (ch) {
		default:
			error("%s: Invalid flag -%c", cmd, optopt);
			return -1;
		}
	}

	return optind;
}

static int
is_dir(const char *path)
{
	struct stat sb;

	/* XXX: report errors? */
	if (stat(path, &sb) == -1)
		return(0);

	return(S_ISDIR(sb.st_mode));
}

static int
remote_is_dir(struct sftp_conn *conn, const char *path)
{
	Attrib *a;

	/* XXX: report errors? */
	if ((a = do_stat(conn, path, 1)) == NULL)
		return(0);
	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
		return(0);
	return(S_ISDIR(a->perm));
}

/* Check whether path returned from glob(..., GLOB_MARK, ...) is a directory */
static int
pathname_is_dir(const char *pathname)
{
	size_t l = strlen(pathname);

	return l > 0 && pathname[l - 1] == '/';
}

static int
process_get(struct sftp_conn *conn, const char *src, const char *dst,
    const char *pwd, int pflag, int rflag, int resume, int fflag)
{
	char *abs_src = NULL;
	char *abs_dst = NULL;
	glob_t g;
	char *filename, *tmp=NULL;
	int i, r, err = 0;

	abs_src = xstrdup(src);
	abs_src = make_absolute(abs_src, pwd);
	memset(&g, 0, sizeof(g));

	debug3("Looking up %s", abs_src);
	if ((r = remote_glob(conn, abs_src, GLOB_MARK, NULL, &g)) != 0) {
		if (r == GLOB_NOSPACE) {
			error("Too many matches for \"%s\".", abs_src);
		} else {
			error("File \"%s\" not found.", abs_src);
		}
		err = -1;
		goto out;
	}

	/*
	 * If multiple matches then dst must be a directory or
	 * unspecified.
	 */
	if (g.gl_matchc > 1 && dst != NULL && !is_dir(dst)) {
		error("Multiple source paths, but destination "
		    "\"%s\" is not a directory", dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
		tmp = xstrdup(g.gl_pathv[i]);
		if ((filename = basename(tmp)) == NULL) {
			error("basename %s: %s", tmp, strerror(errno));
			free(tmp);
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && dst) {
			if (is_dir(dst)) {
				abs_dst = path_append(dst, filename);
			} else {
				abs_dst = xstrdup(dst);
			}
		} else if (dst) {
			abs_dst = path_append(dst, filename);
		} else {
			abs_dst = xstrdup(filename);
		}
		free(tmp);

		resume |= global_aflag;
		if (!quiet && resume)
			mprintf("Resuming %s to %s\n",
			    g.gl_pathv[i], abs_dst);
		else if (!quiet && !resume)
			mprintf("Fetching %s to %s\n",
			    g.gl_pathv[i], abs_dst);
		if (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {
			if (download_dir(conn, g.gl_pathv[i], abs_dst, NULL,
			    pflag || global_pflag, 1, resume,
			    fflag || global_fflag) == -1)
				err = -1;
		} else {
			if (do_download(conn, g.gl_pathv[i], abs_dst, NULL,
			    pflag || global_pflag, resume,
			    fflag || global_fflag) == -1)
				err = -1;
		}
		free(abs_dst);
		abs_dst = NULL;
	}

out:
	free(abs_src);
	globfree(&g);
	return(err);
}

static int
process_put(struct sftp_conn *conn, const char *src, const char *dst,
    const char *pwd, int pflag, int rflag, int resume, int fflag)
{
	char *tmp_dst = NULL;
	char *abs_dst = NULL;
	char *tmp = NULL, *filename = NULL;
	glob_t g;
	int err = 0;
	int i, dst_is_dir = 1;
	struct stat sb;

	if (dst) {
		tmp_dst = xstrdup(dst);
		tmp_dst = make_absolute(tmp_dst, pwd);
	}

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", src);
	if (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {
		error("File \"%s\" not found.", src);
		err = -1;
		goto out;
	}

	/* If we aren't fetching to pwd then stash this status for later */
	if (tmp_dst != NULL)
		dst_is_dir = remote_is_dir(conn, tmp_dst);

	/* If multiple matches, dst may be directory or unspecified */
	if (g.gl_matchc > 1 && tmp_dst && !dst_is_dir) {
		error("Multiple paths match, but destination "
		    "\"%s\" is not a directory", tmp_dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
		if (stat(g.gl_pathv[i], &sb) == -1) {
			err = -1;
			error("stat %s: %s", g.gl_pathv[i], strerror(errno));
			continue;
		}

		tmp = xstrdup(g.gl_pathv[i]);
		if ((filename = basename(tmp)) == NULL) {
			error("basename %s: %s", tmp, strerror(errno));
			free(tmp);
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && tmp_dst) {
			/* If directory specified, append filename */
			if (dst_is_dir)
				abs_dst = path_append(tmp_dst, filename);
			else
				abs_dst = xstrdup(tmp_dst);
		} else if (tmp_dst) {
			abs_dst = path_append(tmp_dst, filename);
		} else {
			abs_dst = make_absolute(xstrdup(filename), pwd);
		}
		free(tmp);

                resume |= global_aflag;
		if (!quiet && resume)
			mprintf("Resuming upload of %s to %s\n",
			    g.gl_pathv[i], abs_dst);
		else if (!quiet && !resume)
			mprintf("Uploading %s to %s\n",
			    g.gl_pathv[i], abs_dst);
		if (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {
			if (upload_dir(conn, g.gl_pathv[i], abs_dst,
			    pflag || global_pflag, 1, resume,
			    fflag || global_fflag) == -1)
				err = -1;
		} else {
			if (do_upload(conn, g.gl_pathv[i], abs_dst,
			    pflag || global_pflag, resume,
			    fflag || global_fflag) == -1)
				err = -1;
		}
	}

out:
	free(abs_dst);
	free(tmp_dst);
	globfree(&g);
	return(err);
}

static int
sdirent_comp(const void *aa, const void *bb)
{
	SFTP_DIRENT *a = *(SFTP_DIRENT **)aa;
	SFTP_DIRENT *b = *(SFTP_DIRENT **)bb;
	int rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;

#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))
	if (sort_flag & LS_NAME_SORT)
		return (rmul * strcmp(a->filename, b->filename));
	else if (sort_flag & LS_TIME_SORT)
		return (rmul * NCMP(a->a.mtime, b->a.mtime));
	else if (sort_flag & LS_SIZE_SORT)
		return (rmul * NCMP(a->a.size, b->a.size));

	fatal("Unknown ls sort type");
}

/* sftp ls.1 replacement for directories */
static int
do_ls_dir(struct sftp_conn *conn, const char *path,
    const char *strip_path, int lflag)
{
	int n;
	u_int c = 1, colspace = 0, columns = 1;
	SFTP_DIRENT **d;

	if ((n = do_readdir(conn, path, &d)) != 0)
		return (n);

	if (!(lflag & LS_SHORT_VIEW)) {
		u_int m = 0, width = 80;
		struct winsize ws;
		char *tmp;

		/* Count entries for sort and find longest filename */
		for (n = 0; d[n] != NULL; n++) {
			if (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))
				m = MAXIMUM(m, strlen(d[n]->filename));
		}

		/* Add any subpath that also needs to be counted */
		tmp = path_strip(path, strip_path);
		m += strlen(tmp);
		free(tmp);

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAXIMUM(columns, 1);
		colspace = width / columns;
		colspace = MINIMUM(colspace, width);
	}

	if (lflag & SORT_FLAGS) {
		for (n = 0; d[n] != NULL; n++)
			;	/* count entries */
		sort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);
		qsort(d, n, sizeof(*d), sdirent_comp);
	}

	for (n = 0; d[n] != NULL && !interrupted; n++) {
		char *tmp, *fname;

		if (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))
			continue;

		tmp = path_append(path, d[n]->filename);
		fname = path_strip(tmp, strip_path);
		free(tmp);

		if (lflag & LS_LONG_VIEW) {
			if (lflag & (LS_NUMERIC_VIEW|LS_SI_UNITS)) {
				char *lname;
				struct stat sb;

				memset(&sb, 0, sizeof(sb));
				attrib_to_stat(&d[n]->a, &sb);
				lname = ls_file(fname, &sb, 1,
				    (lflag & LS_SI_UNITS));
				mprintf("%s\n", lname);
				free(lname);
			} else
				mprintf("%s\n", d[n]->longname);
		} else {
			mprintf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}

		free(fname);
	}

	if (!(lflag & LS_LONG_VIEW) && (c != 1))
		printf("\n");

	free_sftp_dirents(d);
	return (0);
}

static int
sglob_comp(const void *aa, const void *bb)
{
	u_int a = *(const u_int *)aa;
	u_int b = *(const u_int *)bb;
	const char *ap = sort_glob->gl_pathv[a];
	const char *bp = sort_glob->gl_pathv[b];
	const struct stat *as = sort_glob->gl_statv[a];
	const struct stat *bs = sort_glob->gl_statv[b];
	int rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;

#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))
	if (sort_flag & LS_NAME_SORT)
		return (rmul * strcmp(ap, bp));
	else if (sort_flag & LS_TIME_SORT)
		return (rmul * timespeccmp(&as->st_mtim, &bs->st_mtim, <));
	else if (sort_flag & LS_SIZE_SORT)
		return (rmul * NCMP(as->st_size, bs->st_size));

	fatal("Unknown ls sort type");
}

/* sftp ls.1 replacement which handles path globs */
static int
do_globbed_ls(struct sftp_conn *conn, const char *path,
    const char *strip_path, int lflag)
{
	char *fname, *lname;
	glob_t g;
	int err, r;
	struct winsize ws;
	u_int i, j, nentries, *indices = NULL, c = 1;
	u_int colspace = 0, columns = 1, m = 0, width = 80;

	memset(&g, 0, sizeof(g));

	if ((r = remote_glob(conn, path,
	    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,
	    NULL, &g)) != 0 ||
	    (g.gl_pathc && !g.gl_matchc)) {
		if (g.gl_pathc)
			globfree(&g);
		if (r == GLOB_NOSPACE) {
			error("Can't ls: Too many matches for \"%s\"", path);
		} else {
			error("Can't ls: \"%s\" not found", path);
		}
		return -1;
	}

	if (interrupted)
		goto out;

	/*
	 * If the glob returns a single match and it is a directory,
	 * then just list its contents.
	 */
	if (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&
	    S_ISDIR(g.gl_statv[0]->st_mode)) {
		err = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);
		globfree(&g);
		return err;
	}

	if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
		width = ws.ws_col;

	if (!(lflag & LS_SHORT_VIEW)) {
		/* Count entries for sort and find longest filename */
		for (i = 0; g.gl_pathv[i]; i++)
			m = MAXIMUM(m, strlen(g.gl_pathv[i]));

		columns = width / (m + 2);
		columns = MAXIMUM(columns, 1);
		colspace = width / columns;
	}

	/*
	 * Sorting: rather than mess with the contents of glob_t, prepare
	 * an array of indices into it and sort that. For the usual
	 * unsorted case, the indices are just the identity 1=1, 2=2, etc.
	 */
	for (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)
		;	/* count entries */
	indices = calloc(nentries, sizeof(*indices));
	for (i = 0; i < nentries; i++)
		indices[i] = i;

	if (lflag & SORT_FLAGS) {
		sort_glob = &g;
		sort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);
		qsort(indices, nentries, sizeof(*indices), sglob_comp);
		sort_glob = NULL;
	}

	for (j = 0; j < nentries && !interrupted; j++) {
		i = indices[j];
		fname = path_strip(g.gl_pathv[i], strip_path);
		if (lflag & LS_LONG_VIEW) {
			if (g.gl_statv[i] == NULL) {
				error("no stat information for %s", fname);
				continue;
			}
			lname = ls_file(fname, g.gl_statv[i], 1,
			    (lflag & LS_SI_UNITS));
			mprintf("%s\n", lname);
			free(lname);
		} else {
			mprintf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}
		free(fname);
	}

	if (!(lflag & LS_LONG_VIEW) && (c != 1))
		printf("\n");

 out:
	if (g.gl_pathc)
		globfree(&g);
	free(indices);

	return 0;
}

static int
do_df(struct sftp_conn *conn, const char *path, int hflag, int iflag)
{
	struct sftp_statvfs st;
	char s_used[FMT_SCALED_STRSIZE], s_avail[FMT_SCALED_STRSIZE];
	char s_root[FMT_SCALED_STRSIZE], s_total[FMT_SCALED_STRSIZE];
	char s_icapacity[16], s_dcapacity[16];

	if (do_statvfs(conn, path, &st, 1) == -1)
		return -1;
	if (st.f_files == 0)
		strlcpy(s_icapacity, "ERR", sizeof(s_icapacity));
	else {
		snprintf(s_icapacity, sizeof(s_icapacity), "%3llu%%",
		    (unsigned long long)(100 * (st.f_files - st.f_ffree) /
		    st.f_files));
	}
	if (st.f_blocks == 0)
		strlcpy(s_dcapacity, "ERR", sizeof(s_dcapacity));
	else {
		snprintf(s_dcapacity, sizeof(s_dcapacity), "%3llu%%",
		    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /
		    st.f_blocks));
	}
	if (iflag) {
		printf("     Inodes        Used       Avail      "
		    "(root)    %%Capacity\n");
		printf("%11llu %11llu %11llu %11llu         %s\n",
		    (unsigned long long)st.f_files,
		    (unsigned long long)(st.f_files - st.f_ffree),
		    (unsigned long long)st.f_favail,
		    (unsigned long long)st.f_ffree, s_icapacity);
	} else if (hflag) {
		strlcpy(s_used, "error", sizeof(s_used));
		strlcpy(s_avail, "error", sizeof(s_avail));
		strlcpy(s_root, "error", sizeof(s_root));
		strlcpy(s_total, "error", sizeof(s_total));
		fmt_scaled((st.f_blocks - st.f_bfree) * st.f_frsize, s_used);
		fmt_scaled(st.f_bavail * st.f_frsize, s_avail);
		fmt_scaled(st.f_bfree * st.f_frsize, s_root);
		fmt_scaled(st.f_blocks * st.f_frsize, s_total);
		printf("    Size     Used    Avail   (root)    %%Capacity\n");
		printf("%7sB %7sB %7sB %7sB         %s\n",
		    s_total, s_used, s_avail, s_root, s_dcapacity);
	} else {
		printf("        Size         Used        Avail       "
		    "(root)    %%Capacity\n");
		printf("%12llu %12llu %12llu %12llu         %s\n",
		    (unsigned long long)(st.f_frsize * st.f_blocks / 1024),
		    (unsigned long long)(st.f_frsize *
		    (st.f_blocks - st.f_bfree) / 1024),
		    (unsigned long long)(st.f_frsize * st.f_bavail / 1024),
		    (unsigned long long)(st.f_frsize * st.f_bfree / 1024),
		    s_dcapacity);
	}
	return 0;
}

/*
 * Undo escaping of glob sequences in place. Used to undo extra escaping
 * applied in makeargv() when the string is destined for a function that
 * does not glob it.
 */
static void
undo_glob_escape(char *s)
{
	size_t i, j;

	for (i = j = 0;;) {
		if (s[i] == '\0') {
			s[j] = '\0';
			return;
		}
		if (s[i] != '\\') {
			s[j++] = s[i++];
			continue;
		}
		/* s[i] == '\\' */
		++i;
		switch (s[i]) {
		case '?':
		case '[':
		case '*':
		case '\\':
			s[j++] = s[i++];
			break;
		case '\0':
			s[j++] = '\\';
			s[j] = '\0';
			return;
		default:
			s[j++] = '\\';
			s[j++] = s[i++];
			break;
		}
	}
}

/*
 * Split a string into an argument vector using sh(1)-style quoting,
 * comment and escaping rules, but with some tweaks to handle glob(3)
 * wildcards.
 * The "sloppy" flag allows for recovery from missing terminating quote, for
 * use in parsing incomplete commandlines during tab autocompletion.
 *
 * Returns NULL on error or a NULL-terminated array of arguments.
 *
 * If "lastquote" is not NULL, the quoting character used for the last
 * argument is placed in *lastquote ("\0", "'" or "\"").
 *
 * If "terminated" is not NULL, *terminated will be set to 1 when the
 * last argument's quote has been properly terminated or 0 otherwise.
 * This parameter is only of use if "sloppy" is set.
 */
#define MAXARGS 	128
#define MAXARGLEN	8192
static char **
makeargv(const char *arg, int *argcp, int sloppy, char *lastquote,
    u_int *terminated)
{
	int argc, quot;
	size_t i, j;
	static char argvs[MAXARGLEN];
	static char *argv[MAXARGS + 1];
	enum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;

	*argcp = argc = 0;
	if (strlen(arg) > sizeof(argvs) - 1) {
 args_too_longs:
		error("string too long");
		return NULL;
	}
	if (terminated != NULL)
		*terminated = 1;
	if (lastquote != NULL)
		*lastquote = '\0';
	state = MA_START;
	i = j = 0;
	for (;;) {
		if ((size_t)argc >= sizeof(argv) / sizeof(*argv)){
			error("Too many arguments.");
			return NULL;
		}
		if (isspace((unsigned char)arg[i])) {
			if (state == MA_UNQUOTED) {
				/* Terminate current argument */
				argvs[j++] = '\0';
				argc++;
				state = MA_START;
			} else if (state != MA_START)
				argvs[j++] = arg[i];
		} else if (arg[i] == '"' || arg[i] == '\'') {
			q = arg[i] == '"' ? MA_DQUOTE : MA_SQUOTE;
			if (state == MA_START) {
				argv[argc] = argvs + j;
				state = q;
				if (lastquote != NULL)
					*lastquote = arg[i];
			} else if (state == MA_UNQUOTED)
				state = q;
			else if (state == q)
				state = MA_UNQUOTED;
			else
				argvs[j++] = arg[i];
		} else if (arg[i] == '\\') {
			if (state == MA_SQUOTE || state == MA_DQUOTE) {
				quot = state == MA_SQUOTE ? '\'' : '"';
				/* Unescape quote we are in */
				/* XXX support \n and friends? */
				if (arg[i + 1] == quot) {
					i++;
					argvs[j++] = arg[i];
				} else if (arg[i + 1] == '?' ||
				    arg[i + 1] == '[' || arg[i + 1] == '*') {
					/*
					 * Special case for sftp: append
					 * double-escaped glob sequence -
					 * glob will undo one level of
					 * escaping. NB. string can grow here.
					 */
					if (j >= sizeof(argvs) - 5)
						goto args_too_longs;
					argvs[j++] = '\\';
					argvs[j++] = arg[i++];
					argvs[j++] = '\\';
					argvs[j++] = arg[i];
				} else {
					argvs[j++] = arg[i++];
					argvs[j++] = arg[i];
				}
			} else {
				if (state == MA_START) {
					argv[argc] = argvs + j;
					state = MA_UNQUOTED;
					if (lastquote != NULL)
						*lastquote = '\0';
				}
				if (arg[i + 1] == '?' || arg[i + 1] == '[' ||
				    arg[i + 1] == '*' || arg[i + 1] == '\\') {
					/*
					 * Special case for sftp: append
					 * escaped glob sequence -
					 * glob will undo one level of
					 * escaping.
					 */
					argvs[j++] = arg[i++];
					argvs[j++] = arg[i];
				} else {
					/* Unescape everything */
					/* XXX support \n and friends? */
					i++;
					argvs[j++] = arg[i];
				}
			}
		} else if (arg[i] == '#') {
			if (state == MA_SQUOTE || state == MA_DQUOTE)
				argvs[j++] = arg[i];
			else
				goto string_done;
		} else if (arg[i] == '\0') {
			if (state == MA_SQUOTE || state == MA_DQUOTE) {
				if (sloppy) {
					state = MA_UNQUOTED;
					if (terminated != NULL)
						*terminated = 0;
					goto string_done;
				}
				error("Unterminated quoted argument");
				return NULL;
			}
 string_done:
			if (state == MA_UNQUOTED) {
				argvs[j++] = '\0';
				argc++;
			}
			break;
		} else {
			if (state == MA_START) {
				argv[argc] = argvs + j;
				state = MA_UNQUOTED;
				if (lastquote != NULL)
					*lastquote = '\0';
			}
			if ((state == MA_SQUOTE || state == MA_DQUOTE) &&
			    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {
				/*
				 * Special case for sftp: escape quoted
				 * glob(3) wildcards. NB. string can grow
				 * here.
				 */
				if (j >= sizeof(argvs) - 3)
					goto args_too_longs;
				argvs[j++] = '\\';
				argvs[j++] = arg[i];
			} else
				argvs[j++] = arg[i];
		}
		i++;
	}
	*argcp = argc;
	return argv;
}

static int
parse_args(const char **cpp, int *ignore_errors, int *aflag,
	  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag,
	  int *rflag, int *sflag,
    unsigned long *n_arg, char **path1, char **path2)
{
	const char *cmd, *cp = *cpp;
	char *cp2, **argv;
	int base = 0;
	long l;
	int i, cmdnum, optidx, argc;

	/* Skip leading whitespace */
	cp = cp + strspn(cp, WHITESPACE);

	/* Check for leading '-' (disable error processing) */
	*ignore_errors = 0;
	if (*cp == '-') {
		*ignore_errors = 1;
		cp++;
		cp = cp + strspn(cp, WHITESPACE);
	}

	/* Ignore blank lines and lines which begin with comment '#' char */
	if (*cp == '\0' || *cp == '#')
		return (0);

	if ((argv = makeargv(cp, &argc, 0, NULL, NULL)) == NULL)
		return -1;

	/* Figure out which command we have */
	for (i = 0; cmds[i].c != NULL; i++) {
		if (argv[0] != NULL && strcasecmp(cmds[i].c, argv[0]) == 0)
			break;
	}
	cmdnum = cmds[i].n;
	cmd = cmds[i].c;

	/* Special case */
	if (*cp == '!') {
		cp++;
		cmdnum = I_SHELL;
	} else if (cmdnum == -1) {
		error("Invalid command.");
		return -1;
	}

	/* Get arguments and parse flags */
	*aflag = *fflag = *hflag = *iflag = *lflag = *pflag = 0;
	*rflag = *sflag = 0;
	*path1 = *path2 = NULL;
	optidx = 1;
	switch (cmdnum) {
	case I_GET:
	case I_REGET:
	case I_REPUT:
	case I_PUT:
		if ((optidx = parse_getput_flags(cmd, argv, argc,
		    aflag, fflag, pflag, rflag)) == -1)
			return -1;
		/* Get first pathname (mandatory) */
		if (argc - optidx < 1) {
			error("You must specify at least one path after a "
			    "%s command.", cmd);
			return -1;
		}
		*path1 = xstrdup(argv[optidx]);
		/* Get second pathname (optional) */
		if (argc - optidx > 1) {
			*path2 = xstrdup(argv[optidx + 1]);
			/* Destination is not globbed */
			undo_glob_escape(*path2);
		}
		break;
	case I_LINK:
		if ((optidx = parse_link_flags(cmd, argv, argc, sflag)) == -1)
			return -1;
		goto parse_two_paths;
	case I_RENAME:
		if ((optidx = parse_rename_flags(cmd, argv, argc, lflag)) == -1)
			return -1;
		goto parse_two_paths;
	case I_SYMLINK:
		if ((optidx = parse_no_flags(cmd, argv, argc)) == -1)
			return -1;
 parse_two_paths:
		if (argc - optidx < 2) {
			error("You must specify two paths after a %s "
			    "command.", cmd);
			return -1;
		}
		*path1 = xstrdup(argv[optidx]);
		*path2 = xstrdup(argv[optidx + 1]);
		/* Paths are not globbed */
		undo_glob_escape(*path1);
		undo_glob_escape(*path2);
		break;
	case I_RM:
	case I_MKDIR:
	case I_RMDIR:
	case I_CHDIR:
	case I_LCHDIR:
	case I_LMKDIR:
		if ((optidx = parse_no_flags(cmd, argv, argc)) == -1)
			return -1;
		/* Get pathname (mandatory) */
		if (argc - optidx < 1) {
			error("You must specify a path after a %s command.",
			    cmd);
			return -1;
		}
		*path1 = xstrdup(argv[optidx]);
		/* Only "rm" globs */
		if (cmdnum != I_RM)
			undo_glob_escape(*path1);
		break;
	case I_DF:
		if ((optidx = parse_df_flags(cmd, argv, argc, hflag,
		    iflag)) == -1)
			return -1;
		/* Default to current directory if no path specified */
		if (argc - optidx < 1)
			*path1 = NULL;
		else {
			*path1 = xstrdup(argv[optidx]);
			undo_glob_escape(*path1);
		}
		break;
	case I_LS:
		if ((optidx = parse_ls_flags(argv, argc, lflag)) == -1)
			return(-1);
		/* Path is optional */
		if (argc - optidx > 0)
			*path1 = xstrdup(argv[optidx]);
		break;
	case I_LLS:
		/* Skip ls command and following whitespace */
		cp = cp + strlen(cmd) + strspn(cp, WHITESPACE);
	case I_SHELL:
		/* Uses the rest of the line */
		break;
	case I_LUMASK:
	case I_CHMOD:
		base = 8;
	case I_CHOWN:
	case I_CHGRP:
		if ((optidx = parse_no_flags(cmd, argv, argc)) == -1)
			return -1;
		/* Get numeric arg (mandatory) */
		if (argc - optidx < 1)
			goto need_num_arg;
		errno = 0;
		l = strtol(argv[optidx], &cp2, base);
		if (cp2 == argv[optidx] || *cp2 != '\0' ||
		    ((l == LONG_MIN || l == LONG_MAX) && errno == ERANGE) ||
		    l < 0) {
 need_num_arg:
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return -1;
		}
		*n_arg = l;
		if (cmdnum == I_LUMASK)
			break;
		/* Get pathname (mandatory) */
		if (argc - optidx < 2) {
			error("You must specify a path after a %s command.",
			    cmd);
			return -1;
		}
		*path1 = xstrdup(argv[optidx + 1]);
		break;
	case I_QUIT:
	case I_PWD:
	case I_LPWD:
	case I_HELP:
	case I_VERSION:
	case I_PROGRESS:
		if ((optidx = parse_no_flags(cmd, argv, argc)) == -1)
			return -1;
		break;
	default:
		fatal("Command not implemented");
	}

	*cpp = cp;
	return(cmdnum);
}

static int
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
    int err_abort)
{
	char *path1, *path2, *tmp;
	int ignore_errors = 0, aflag = 0, fflag = 0, hflag = 0,
	iflag = 0;
	int lflag = 0, pflag = 0, rflag = 0, sflag = 0;
	int cmdnum, i;
	unsigned long n_arg = 0;
	Attrib a, *aa;
	char path_buf[PATH_MAX];
	int err = 0;
	glob_t g;

	path1 = path2 = NULL;
	cmdnum = parse_args(&cmd, &ignore_errors, &aflag, &fflag, &hflag,
	    &iflag, &lflag, &pflag, &rflag, &sflag, &n_arg, &path1, &path2);
	if (ignore_errors != 0)
		err_abort = 0;

	memset(&g, 0, sizeof(g));

	/* Perform command */
	switch (cmdnum) {
	case 0:
		/* Blank line */
		break;
	case -1:
		/* Unrecognized command */
		err = -1;
		break;
	case I_REGET:
		aflag = 1;
		/* FALLTHROUGH */
	case I_GET:
		err = process_get(conn, path1, path2, *pwd, pflag,
		    rflag, aflag, fflag);
		break;
	case I_REPUT:
		aflag = 1;
		/* FALLTHROUGH */
	case I_PUT:
		err = process_put(conn, path1, path2, *pwd, pflag,
		    rflag, aflag, fflag);
		break;
	case I_RENAME:
		path1 = make_absolute(path1, *pwd);
		path2 = make_absolute(path2, *pwd);
		err = do_rename(conn, path1, path2, lflag);
		break;
	case I_SYMLINK:
		sflag = 1;
	case I_LINK:
		if (!sflag)
			path1 = make_absolute(path1, *pwd);
		path2 = make_absolute(path2, *pwd);
		err = (sflag ? do_symlink : do_hardlink)(conn, path1, path2);
		break;
	case I_RM:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
			if (!quiet)
				mprintf("Removing %s\n", g.gl_pathv[i]);
			err = do_rm(conn, g.gl_pathv[i]);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_MKDIR:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = 0777;
		err = do_mkdir(conn, path1, &a, 1);
		break;
	case I_RMDIR:
		path1 = make_absolute(path1, *pwd);
		err = do_rmdir(conn, path1);
		break;
	case I_CHDIR:
		path1 = make_absolute(path1, *pwd);
		if ((tmp = do_realpath(conn, path1)) == NULL) {
			err = 1;
			break;
		}
		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
			free(tmp);
			err = 1;
			break;
		}
		if (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {
			error("Can't change directory: Can't check target");
			free(tmp);
			err = 1;
			break;
		}
		if (!S_ISDIR(aa->perm)) {
			error("Can't change directory: \"%s\" is not "
			    "a directory", tmp);
			free(tmp);
			err = 1;
			break;
		}
		free(*pwd);
		*pwd = tmp;
		break;
	case I_LS:
		if (!path1) {
			do_ls_dir(conn, *pwd, *pwd, lflag);
			break;
		}

		/* Strip pwd off beginning of non-absolute paths */
		tmp = NULL;
		if (*path1 != '/')
			tmp = *pwd;

		path1 = make_absolute(path1, *pwd);
		err = do_globbed_ls(conn, path1, tmp, lflag);
		break;
	case I_DF:
		/* Default to current directory if no path specified */
		if (path1 == NULL)
			path1 = xstrdup(*pwd);
		path1 = make_absolute(path1, *pwd);
		err = do_df(conn, path1, hflag, iflag);
		break;
	case I_LCHDIR:
		tmp = tilde_expand_filename(path1, getuid());
		free(path1);
		path1 = tmp;
		if (chdir(path1) == -1) {
			error("Couldn't change local directory to "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LMKDIR:
		if (mkdir(path1, 0777) == -1) {
			error("Couldn't create local directory "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LLS:
		local_do_ls(cmd);
		break;
	case I_SHELL:
		local_do_shell(cmd);
		break;
	case I_LUMASK:
		umask(n_arg);
		printf("Local umask: %03lo\n", n_arg);
		break;
	case I_CHMOD:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = n_arg;
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
			if (!quiet)
				mprintf("Changing mode on %s\n",
				    g.gl_pathv[i]);
			err = do_setstat(conn, g.gl_pathv[i], &a);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_CHOWN:
	case I_CHGRP:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
				if (err_abort) {
					err = -1;
					break;
				} else
					continue;
			}
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				if (err_abort) {
					err = -1;
					break;
				} else
					continue;
			}
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			if (cmdnum == I_CHOWN) {
				if (!quiet)
					mprintf("Changing owner on %s\n",
					    g.gl_pathv[i]);
				aa->uid = n_arg;
			} else {
				if (!quiet)
					mprintf("Changing group on %s\n",
					    g.gl_pathv[i]);
				aa->gid = n_arg;
			}
			err = do_setstat(conn, g.gl_pathv[i], aa);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_PWD:
		mprintf("Remote working directory: %s\n", *pwd);
		break;
	case I_LPWD:
		if (!getcwd(path_buf, sizeof(path_buf))) {
			error("Couldn't get local cwd: %s", strerror(errno));
			err = -1;
			break;
		}
		mprintf("Local working directory: %s\n", path_buf);
		break;
	case I_QUIT:
		/* Processed below */
		break;
	case I_HELP:
		help();
		break;
	case I_VERSION:
		printf("SFTP protocol version %u\n", sftp_proto_version(conn));
		break;
	case I_PROGRESS:
		showprogress = !showprogress;
		if (showprogress)
			printf("Progress meter enabled\n");
		else
			printf("Progress meter disabled\n");
		break;
	default:
		fatal("%d is not implemented", cmdnum);
	}

	if (g.gl_pathc)
		globfree(&g);
	free(path1);
	free(path2);

	/* If an unignored error occurs in batch mode we should abort. */
	if (err_abort && err != 0)
		return (-1);
	else if (cmdnum == I_QUIT)
		return (1);

	return (0);
}

static char *
prompt(EditLine *el)
{
	return ("sftp> ");
}

/* Display entries in 'list' after skipping the first 'len' chars */
static void
complete_display(char **list, u_int len)
{
	u_int y, m = 0, width = 80, columns = 1, colspace = 0, llen;
	struct winsize ws;
	char *tmp;

	/* Count entries for sort and find longest */
	for (y = 0; list[y]; y++)
		m = MAXIMUM(m, strlen(list[y]));

	if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
		width = ws.ws_col;

	m = m > len ? m - len : 0;
	columns = width / (m + 2);
	columns = MAXIMUM(columns, 1);
	colspace = width / columns;
	colspace = MINIMUM(colspace, width);

	printf("\n");
	m = 1;
	for (y = 0; list[y]; y++) {
		llen = strlen(list[y]);
		tmp = llen > len ? list[y] + len : "";
		mprintf("%-*s", colspace, tmp);
		if (m >= columns) {
			printf("\n");
			m = 1;
		} else
			m++;
	}
	printf("\n");
}

/*
 * Given a "list" of words that begin with a common prefix of "word",
 * attempt to find an autocompletion to extends "word" by the next
 * characters common to all entries in "list".
 */
static char *
complete_ambiguous(const char *word, char **list, size_t count)
{
	if (word == NULL)
		return NULL;

	if (count > 0) {
		u_int y, matchlen = strlen(list[0]);

		/* Find length of common stem */
		for (y = 1; list[y]; y++) {
			u_int x;

			for (x = 0; x < matchlen; x++)
				if (list[0][x] != list[y][x])
					break;

			matchlen = x;
		}

		if (matchlen > strlen(word)) {
			char *tmp = xstrdup(list[0]);

			tmp[matchlen] = '\0';
			return tmp;
		}
	}

	return xstrdup(word);
}

/* Autocomplete a sftp command */
static int
complete_cmd_parse(EditLine *el, char *cmd, int lastarg, char quote,
    int terminated)
{
	u_int y, count = 0, cmdlen, tmplen;
	char *tmp, **list, argterm[3];
	const LineInfo *lf;

	list = xcalloc((sizeof(cmds) / sizeof(*cmds)) + 1, sizeof(char *));

	/* No command specified: display all available commands */
	if (cmd == NULL) {
		for (y = 0; cmds[y].c; y++)
			list[count++] = xstrdup(cmds[y].c);

		list[count] = NULL;
		complete_display(list, 0);

		for (y = 0; list[y] != NULL; y++)
			free(list[y]);
		free(list);
		return count;
	}

	/* Prepare subset of commands that start with "cmd" */
	cmdlen = strlen(cmd);
	for (y = 0; cmds[y].c; y++)  {
		if (!strncasecmp(cmd, cmds[y].c, cmdlen))
			list[count++] = xstrdup(cmds[y].c);
	}
	list[count] = NULL;

	if (count == 0) {
		free(list);
		return 0;
	}

	/* Complete ambigious command */
	tmp = complete_ambiguous(cmd, list, count);
	if (count > 1)
		complete_display(list, 0);

	for (y = 0; list[y]; y++)
		free(list[y]);
	free(list);

	if (tmp != NULL) {
		tmplen = strlen(tmp);
		cmdlen = strlen(cmd);
		/* If cmd may be extended then do so */
		if (tmplen > cmdlen)
			if (el_insertstr(el, tmp + cmdlen) == -1)
				fatal("el_insertstr failed.");
		lf = el_line(el);
		/* Terminate argument cleanly */
		if (count == 1) {
			y = 0;
			if (!terminated)
				argterm[y++] = quote;
			if (lastarg || *(lf->cursor) != ' ')
				argterm[y++] = ' ';
			argterm[y] = '\0';
			if (y > 0 && el_insertstr(el, argterm) == -1)
				fatal("el_insertstr failed.");
		}
		free(tmp);
	}

	return count;
}

/*
 * Determine whether a particular sftp command's arguments (if any)
 * represent local or remote files.
 */
static int
complete_is_remote(char *cmd) {
	int i;

	if (cmd == NULL)
		return -1;

	for (i = 0; cmds[i].c; i++) {
		if (!strncasecmp(cmd, cmds[i].c, strlen(cmds[i].c)))
			return cmds[i].t;
	}

	return -1;
}

/* Autocomplete a filename "file" */
static int
complete_match(EditLine *el, struct sftp_conn *conn, char *remote_path,
    char *file, int remote, int lastarg, char quote, int terminated)
{
	glob_t g;
	char *tmp, *tmp2, ins[8];
	u_int i, hadglob, pwdlen, len, tmplen, filelen, cesc, isesc, isabs;
	int clen;
	const LineInfo *lf;

	/* Glob from "file" location */
	if (file == NULL)
		tmp = xstrdup("*");
	else
		xasprintf(&tmp, "%s*", file);

	/* Check if the path is absolute. */
	isabs = tmp[0] == '/';

	memset(&g, 0, sizeof(g));
	if (remote != LOCAL) {
		tmp = make_absolute(tmp, remote_path);
		remote_glob(conn, tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);
	} else
		glob(tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);

	/* Determine length of pwd so we can trim completion display */
	for (hadglob = tmplen = pwdlen = 0; tmp[tmplen] != 0; tmplen++) {
		/* Terminate counting on first unescaped glob metacharacter */
		if (tmp[tmplen] == '*' || tmp[tmplen] == '?') {
			if (tmp[tmplen] != '*' || tmp[tmplen + 1] != '\0')
				hadglob = 1;
			break;
		}
		if (tmp[tmplen] == '\\' && tmp[tmplen + 1] != '\0')
			tmplen++;
		if (tmp[tmplen] == '/')
			pwdlen = tmplen + 1;	/* track last seen '/' */
	}
	free(tmp);
	tmp = NULL;

	if (g.gl_matchc == 0)
		goto out;

	if (g.gl_matchc > 1)
		complete_display(g.gl_pathv, pwdlen);

	/* Don't try to extend globs */
	if (file == NULL || hadglob)
		goto out;

	tmp2 = complete_ambiguous(file, g.gl_pathv, g.gl_matchc);
	tmp = path_strip(tmp2, isabs ? NULL : remote_path);
	free(tmp2);

	if (tmp == NULL)
		goto out;

	tmplen = strlen(tmp);
	filelen = strlen(file);

	/* Count the number of escaped characters in the input string. */
	cesc = isesc = 0;
	for (i = 0; i < filelen; i++) {
		if (!isesc && file[i] == '\\' && i + 1 < filelen){
			isesc = 1;
			cesc++;
		} else
			isesc = 0;
	}

	if (tmplen > (filelen - cesc)) {
		tmp2 = tmp + filelen - cesc;
		len = strlen(tmp2);
		/* quote argument on way out */
		for (i = 0; i < len; i += clen) {
			if ((clen = mblen(tmp2 + i, len - i)) < 0 ||
			    (size_t)clen > sizeof(ins) - 2)
				fatal("invalid multibyte character");
			ins[0] = '\\';
			memcpy(ins + 1, tmp2 + i, clen);
			ins[clen + 1] = '\0';
			switch (tmp2[i]) {
			case '\'':
			case '"':
			case '\\':
			case '\t':
			case '[':
			case ' ':
			case '#':
			case '*':
				if (quote == '\0' || tmp2[i] == quote) {
					if (el_insertstr(el, ins) == -1)
						fatal("el_insertstr "
						    "failed.");
					break;
				}
				/* FALLTHROUGH */
			default:
				if (el_insertstr(el, ins + 1) == -1)
					fatal("el_insertstr failed.");
				break;
			}
		}
	}

	lf = el_line(el);
	if (g.gl_matchc == 1) {
		i = 0;
		if (!terminated && quote != '\0')
			ins[i++] = quote;
		if (*(lf->cursor - 1) != '/' &&
		    (lastarg || *(lf->cursor) != ' '))
			ins[i++] = ' ';
		ins[i] = '\0';
		if (i > 0 && el_insertstr(el, ins) == -1)
			fatal("el_insertstr failed.");
	}
	free(tmp);

 out:
	globfree(&g);
	return g.gl_matchc;
}

/* tab-completion hook function, called via libedit */
static unsigned char
complete(EditLine *el, int ch)
{
	char **argv, *line, quote;
	int argc, carg;
	u_int cursor, len, terminated, ret = CC_ERROR;
	const LineInfo *lf;
	struct complete_ctx *complete_ctx;

	lf = el_line(el);
	if (el_get(el, EL_CLIENTDATA, (void**)&complete_ctx) != 0)
		fatal("%s: el_get failed", __func__);

	/* Figure out which argument the cursor points to */
	cursor = lf->cursor - lf->buffer;
	line = xmalloc(cursor + 1);
	memcpy(line, lf->buffer, cursor);
	line[cursor] = '\0';
	argv = makeargv(line, &carg, 1, &quote, &terminated);
	free(line);

	/* Get all the arguments on the line */
	len = lf->lastchar - lf->buffer;
	line = xmalloc(len + 1);
	memcpy(line, lf->buffer, len);
	line[len] = '\0';
	argv = makeargv(line, &argc, 1, NULL, NULL);

	/* Ensure cursor is at EOL or a argument boundary */
	if (line[cursor] != ' ' && line[cursor] != '\0' &&
	    line[cursor] != '\n') {
		free(line);
		return ret;
	}

	if (carg == 0) {
		/* Show all available commands */
		complete_cmd_parse(el, NULL, argc == carg, '\0', 1);
		ret = CC_REDISPLAY;
	} else if (carg == 1 && cursor > 0 && line[cursor - 1] != ' ')  {
		/* Handle the command parsing */
		if (complete_cmd_parse(el, argv[0], argc == carg,
		    quote, terminated) != 0)
			ret = CC_REDISPLAY;
	} else if (carg >= 1) {
		/* Handle file parsing */
		int remote = complete_is_remote(argv[0]);
		char *filematch = NULL;

		if (carg > 1 && line[cursor-1] != ' ')
			filematch = argv[carg - 1];

		if (remote != 0 &&
		    complete_match(el, complete_ctx->conn,
		    *complete_ctx->remote_pathp, filematch,
		    remote, carg == argc, quote, terminated) != 0)
			ret = CC_REDISPLAY;
	}

	free(line);
	return ret;
}

int
interactive_loop(struct sftp_conn *conn, char *file1, char *file2)
{
	char *remote_path;
	char *dir = NULL;
	char cmd[2048];
	int err, interactive;
	EditLine *el = NULL;
	History *hl = NULL;
	HistEvent hev;
	extern char *__progname;
	struct complete_ctx complete_ctx;

	if (!batchmode && isatty(STDIN_FILENO)) {
		if ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)
			fatal("Couldn't initialise editline");
		if ((hl = history_init()) == NULL)
			fatal("Couldn't initialise editline history");
		history(hl, &hev, H_SETSIZE, 100);
		el_set(el, EL_HIST, history, hl);

		el_set(el, EL_PROMPT, prompt);
		el_set(el, EL_EDITOR, "emacs");
		el_set(el, EL_TERMINAL, NULL);
		el_set(el, EL_SIGNAL, 1);
		el_source(el, NULL);

		/* Tab Completion */
		el_set(el, EL_ADDFN, "ftp-complete",
		    "Context sensitive argument completion", complete);
		complete_ctx.conn = conn;
		complete_ctx.remote_pathp = &remote_path;
		el_set(el, EL_CLIENTDATA, (void*)&complete_ctx);
		el_set(el, EL_BIND, "^I", "ftp-complete", NULL);
		/* enable ctrl-left-arrow and ctrl-right-arrow */
		el_set(el, EL_BIND, "\\e[1;5C", "em-next-word", NULL);
		el_set(el, EL_BIND, "\\e[5C", "em-next-word", NULL);
		el_set(el, EL_BIND, "\\e[1;5D", "ed-prev-word", NULL);
		el_set(el, EL_BIND, "\\e\\e[D", "ed-prev-word", NULL);
		/* make ^w match ksh behaviour */
		el_set(el, EL_BIND, "^w", "ed-delete-prev-word", NULL);
	}

	remote_path = do_realpath(conn, ".");
	if (remote_path == NULL)
		fatal("Need cwd");

	if (file1 != NULL) {
		dir = xstrdup(file1);
		dir = make_absolute(dir, remote_path);

		if (remote_is_dir(conn, dir) && file2 == NULL) {
			if (!quiet)
				mprintf("Changing to: %s\n", dir);
			snprintf(cmd, sizeof cmd, "cd \"%s\"", dir);
			if (parse_dispatch_command(conn, cmd,
			    &remote_path, 1) != 0) {
				free(dir);
				free(remote_path);
				free(conn);
				return (-1);
			}
		} else {
			/* XXX this is wrong wrt quoting */
			snprintf(cmd, sizeof cmd, "get%s %s%s%s",
			    global_aflag ? " -a" : "", dir,
			    file2 == NULL ? "" : " ",
			    file2 == NULL ? "" : file2);
			err = parse_dispatch_command(conn, cmd,
			    &remote_path, 1);
			free(dir);
			free(remote_path);
			free(conn);
			return (err);
		}
		free(dir);
	}

	setvbuf(stdout, NULL, _IOLBF, 0);
	setvbuf(infile, NULL, _IOLBF, 0);

	interactive = !batchmode && isatty(STDIN_FILENO);
	err = 0;
	for (;;) {
		char *cp;
		const char *line;
		int count = 0;

		signal(SIGINT, SIG_IGN);

		if (el == NULL) {
			if (interactive)
				printf("sftp> ");
			if (fgets(cmd, sizeof(cmd), infile) == NULL) {
				if (interactive)
					printf("\n");
				break;
			}
			if (!interactive) { /* Echo command */
				mprintf("sftp> %s", cmd);
				if (strlen(cmd) > 0 &&
				    cmd[strlen(cmd) - 1] != '\n')
					printf("\n");
			}
		} else {
			if ((line = el_gets(el, &count)) == NULL ||
			    count <= 0) {
				printf("\n");
				break;
			}
			history(hl, &hev, H_ENTER, line);
			if (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {
				fprintf(stderr, "Error: input line too long\n");
				continue;
			}
		}

		cp = strrchr(cmd, '\n');
		if (cp)
			*cp = '\0';

		/* Handle user interrupts gracefully during commands */
		interrupted = 0;
		signal(SIGINT, cmd_interrupt);

		err = parse_dispatch_command(conn, cmd, &remote_path,
		    batchmode);
		if (err != 0)
			break;
	}
	free(remote_path);
	free(conn);

	if (el != NULL)
		el_end(el);

	/* err == 1 signifies normal "quit" exit */
	return (err >= 0 ? 0 : -1);
}

static void
connect_to_server(char *path, char **args, int *in, int *out)
{
	int c_in, c_out;

	int inout[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)
		fatal("socketpair: %s", strerror(errno));
	*in = *out = inout[0];
	c_in = c_out = inout[1];

	if ((sshpid = fork()) == -1)
		fatal("fork: %s", strerror(errno));
	else if (sshpid == 0) {
		if ((dup2(c_in, STDIN_FILENO) == -1) ||
		    (dup2(c_out, STDOUT_FILENO) == -1)) {
			fprintf(stderr, "dup2: %s\n", strerror(errno));
			_exit(1);
		}
		close(*in);
		close(*out);
		close(c_in);
		close(c_out);

		/*
		 * The underlying ssh is in the same process group, so we must
		 * ignore SIGINT if we want to gracefully abort commands,
		 * otherwise the signal will make it to the ssh process and
		 * kill it too.  Contrawise, since sftp sends SIGTERMs to the
		 * underlying ssh, it must *not* ignore that signal.
		 */
		signal(SIGINT, SIG_IGN);
		signal(SIGTERM, SIG_DFL);
		execvp(path, args);
		fprintf(stderr, "exec: %s: %s\n", path, strerror(errno));
		_exit(1);
	}

	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
	signal(SIGTSTP, suspchild);
	signal(SIGTTIN, suspchild);
	signal(SIGTTOU, suspchild);
	close(c_in);
	close(c_out);
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-46aCfpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
	    "          [-D sftp_server_path] [-F ssh_config] "
	    "[-i identity_file] [-l limit]\n"
	    "          [-o ssh_option] [-P port] [-R num_requests] "
	    "[-S program]\n"
	    "          [-s subsystem | sftp_server] host\n"
	    "       %s [user@@]host[:file ...]\n"
	    "       %s [user@@]host[:dir[/]]\n"
	    "       %s -b batchfile [user@@]host\n",
	    __progname, __progname, __progname, __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	int in, out, ch, err;
	char *host = NULL, *userhost, *cp, *file2 = NULL;
	int debug_level = 0, sshver = 2;
	char *file1 = NULL, *sftp_server = NULL;
	char *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;
	const char *errstr;
	LogLevel ll = SYSLOG_LEVEL_INFO;
	arglist args;
	extern int optind;
	extern char *optarg;
	struct sftp_conn *conn;
	size_t copy_buffer_len = DEFAULT_COPY_BUFLEN;
	size_t num_requests = DEFAULT_NUM_REQUESTS;
	long long limit_kbps = 0;

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();
	setlocale(LC_CTYPE, "");

	memset(&args, '\0', sizeof(args));
	args.list = NULL;
	addargs(&args, "%s", ssh_program);
	addargs(&args, "-oForwardX11 no");
	addargs(&args, "-oForwardAgent no");
	addargs(&args, "-oPermitLocalCommand no");
	addargs(&args, "-oClearAllForwardings yes");

	ll = SYSLOG_LEVEL_INFO;
	infile = stdin;

	while ((ch = getopt(argc, argv,
	    "1246afhpqrvCc:D:i:l:o:s:S:b:B:F:P:R:")) != -1) {
		switch (ch) {
		/* Passed through to ssh(1) */
		case '4':
		case '6':
		case 'C':
			addargs(&args, "-%c", ch);
			break;
		/* Passed through to ssh(1) with argument */
		case 'F':
		case 'c':
		case 'i':
		case 'o':
			addargs(&args, "-%c", ch);
			addargs(&args, "%s", optarg);
			break;
		case 'q':
			ll = SYSLOG_LEVEL_ERROR;
			quiet = 1;
			showprogress = 0;
			addargs(&args, "-%c", ch);
			break;
		case 'P':
			addargs(&args, "-oPort %s", optarg);
			break;
		case 'v':
			if (debug_level < 3) {
				addargs(&args, "-v");
				ll = SYSLOG_LEVEL_DEBUG1 + debug_level;
			}
			debug_level++;
			break;
		case '1':
			sshver = 1;
			if (sftp_server == NULL)
				sftp_server = _PATH_SFTP_SERVER;
			break;
		case '2':
			sshver = 2;
			break;
		case 'a':
			global_aflag = 1;
			break;
		case 'B':
			copy_buffer_len = strtol(optarg, &cp, 10);
			if (copy_buffer_len == 0 || *cp != '\0')
				fatal("Invalid buffer size \"%s\"", optarg);
			break;
		case 'b':
			if (batchmode)
				fatal("Batch file already specified.");

			/* Allow "-" as stdin */
			if (strcmp(optarg, "-") != 0 &&
			    (infile = fopen(optarg, "r")) == NULL)
				fatal("%s (%s).", strerror(errno), optarg);
			showprogress = 0;
			quiet = batchmode = 1;
			addargs(&args, "-obatchmode yes");
			break;
		case 'f':
			global_fflag = 1;
			break;
		case 'p':
			global_pflag = 1;
			break;
		case 'D':
			sftp_direct = optarg;
			break;
		case 'l':
			limit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,
			    &errstr);
			if (errstr != NULL)
				usage();
			limit_kbps *= 1024; /* kbps */
			break;
		case 'r':
			global_rflag = 1;
			break;
		case 'R':
			num_requests = strtol(optarg, &cp, 10);
			if (num_requests == 0 || *cp != '\0')
				fatal("Invalid number of requests \"%s\"",
				    optarg);
			break;
		case 's':
			sftp_server = optarg;
			break;
		case 'S':
			ssh_program = optarg;
			replacearg(&args, 0, "%s", ssh_program);
			break;
		case 'h':
		default:
			usage();
		}
	}

	if (!isatty(STDERR_FILENO))
		showprogress = 0;

	log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);

	if (sftp_direct == NULL) {
		if (optind == argc || argc > (optind + 2))
			usage();

		userhost = xstrdup(argv[optind]);
		file2 = argv[optind+1];

		if ((host = strrchr(userhost, '@@')) == NULL)
			host = userhost;
		else {
			*host++ = '\0';
			if (!userhost[0]) {
				fprintf(stderr, "Missing username\n");
				usage();
			}
			addargs(&args, "-l");
			addargs(&args, "%s", userhost);
		}

		if ((cp = colon(host)) != NULL) {
			*cp++ = '\0';
			file1 = cp;
		}

		host = cleanhostname(host);
		if (!*host) {
			fprintf(stderr, "Missing hostname\n");
			usage();
		}

		addargs(&args, "-oProtocol %d", sshver);

		/* no subsystem if the server-spec contains a '/' */
		if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
			addargs(&args, "-s");

		addargs(&args, "--");
		addargs(&args, "%s", host);
		addargs(&args, "%s", (sftp_server != NULL ?
		    sftp_server : "sftp"));

		connect_to_server(ssh_program, args.list, &in, &out);
	} else {
		args.list = NULL;
		addargs(&args, "sftp-server");

		connect_to_server(sftp_direct, args.list, &in, &out);
	}
	freeargs(&args);

	conn = do_init(in, out, copy_buffer_len, num_requests, limit_kbps);
	if (conn == NULL)
		fatal("Couldn't initialise connection to server");

	if (!quiet) {
		if (sftp_direct == NULL)
			fprintf(stderr, "Connected to %s.\n", host);
		else
			fprintf(stderr, "Attached to %s.\n", sftp_direct);
	}

	err = interactive_loop(conn, file1, file2);

	close(in);
	close(out);
	if (batchmode)
		fclose(infile);

	while (waitpid(sshpid, NULL, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for ssh process: %s",
			    strerror(errno));

	exit(err == 0 ? 0 : 1);
}
@


1.179
log
@remove -1 / -2 options; pointed out by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.178 2017/02/15 01:46:47 djm Exp $ */
d89 1
d861 22
d892 2
a893 1
	u_int i, c = 1, colspace = 0, columns = 1, m = 0, width = 80;
d938 20
a957 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d985 1
@


1.178
log
@fix division by zero crash in "df" output when server returns zero
total filesystem blocks/inodes. Spotted by Guido Vranken; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.177 2016/10/18 12:41:22 millert Exp $ */
d2207 1
a2207 1
	    "usage: %s [-1246aCfpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
@


1.177
log
@Install a signal handler for tty-generated signals and wait for the
ssh child to suspend before suspending sftp.  This lets ssh restore
the terminal mode as needed when it is suspended at the password
prompt.  OK dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.176 2016/09/12 01:22:38 deraadt Exp $ */
d950 3
a952 5
	char s_used[FMT_SCALED_STRSIZE];
	char s_avail[FMT_SCALED_STRSIZE];
	char s_root[FMT_SCALED_STRSIZE];
	char s_total[FMT_SCALED_STRSIZE];
	unsigned long long ffree;
d956 14
a970 1
		ffree = st.f_files ? (100 * (st.f_files - st.f_ffree) / st.f_files) : 0;
d973 1
a973 1
		printf("%11llu %11llu %11llu %11llu         %3llu%%\n",
d977 1
a977 1
		    (unsigned long long)st.f_ffree, ffree);
d988 2
a989 4
		printf("%7sB %7sB %7sB %7sB         %3llu%%\n",
		    s_total, s_used, s_avail, s_root,
		    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /
		    st.f_blocks));
d993 1
a993 1
		printf("%12llu %12llu %12llu %12llu         %3llu%%\n",
d999 1
a999 2
		    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /
		    st.f_blocks));
@


1.176
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.175 2016/07/22 03:47:36 djm Exp $ */
d213 12
d2186 3
@


1.175
log
@constify a few functions' arguments; patch from Jakub Jelen bz#2581
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.174 2016/05/25 23:48:45 schwarze Exp $ */
a17 1
#include <sys/param.h>	/* MIN MAX */
d782 1
a782 1
				m = MAX(m, strlen(d[n]->filename));
d794 1
a794 1
		columns = MAX(columns, 1);
d796 1
a796 1
		colspace = MIN(colspace, width);
d895 1
a895 1
			m = MAX(m, strlen(g.gl_pathv[i]));
d898 1
a898 1
		columns = MAX(columns, 1);
d1648 1
a1648 1
		m = MAX(m, strlen(list[y]));
d1655 1
a1655 1
	columns = MAX(columns, 1);
d1657 1
a1657 1
	colspace = MIN(colspace, width);
@


1.174
log
@To prevent screwing up terminal settings when printing to the
terminal, for ASCII and UTF-8, escape bytes not forming characters
and bytes forming non-printable characters with vis(3) VIS_OCTAL.
For other character sets, abort printing of the current string in
these cases.  In particular,
* let scp(1) respect the local user's LC_CTYPE locale(1);
* sanitize data received from the remote host;
* sanitize filenames, usernames, and similar data even locally;
* take character display widths into account for the progressmeter.

This is believed to be sufficient to keep the local terminal safe
on OpenBSD, but bad things can still happen on other systems with
state-dependent locales because many places in the code print
unencoded ASCII characters into the output stream.

Using feedback from djm@@ and martijn@@,
various aspects discussed with many others.

deraadt@@ says it should go in now, i probably already hesitated too long
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.173 2016/04/08 08:19:17 djm Exp $ */
d318 1
a318 1
path_strip(char *path, char *strip)
d336 1
a336 1
make_absolute(char *p, char *pwd)
d534 1
a534 1
is_dir(char *path)
d546 1
a546 1
remote_is_dir(struct sftp_conn *conn, char *path)
d560 1
a560 1
pathname_is_dir(char *pathname)
d568 2
a569 2
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd,
    int pflag, int rflag, int resume, int fflag)
d654 2
a655 2
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd,
    int pflag, int rflag, int resume, int fflag)
d765 2
a766 1
do_ls_dir(struct sftp_conn *conn, char *path, char *strip_path, int lflag)
d851 2
a852 2
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path,
    int lflag)
d936 1
a936 1
do_df(struct sftp_conn *conn, char *path, int hflag, int iflag)
@


1.173
log
@whitespace at EOL
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.172 2016/02/15 09:47:49 dtucker Exp $ */
d34 1
d47 1
d627 2
a628 1
			printf("Resuming %s to %s\n", g.gl_pathv[i], abs_dst);
d630 2
a631 1
			printf("Fetching %s to %s\n", g.gl_pathv[i], abs_dst);
d720 2
a721 2
			printf("Resuming upload of %s to %s\n", g.gl_pathv[i],
				abs_dst);
d723 2
a724 1
			printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
d825 1
a825 1
				printf("%s\n", lname);
d828 1
a828 1
				printf("%s\n", d[n]->longname);
d830 1
a830 1
			printf("%-*s", colspace, fname);
d911 1
a911 1
			printf("%s\n", lname);
d914 1
a914 1
			printf("%-*s", colspace, fname);
d1442 1
a1442 1
				printf("Removing %s\n", g.gl_pathv[i]);
d1542 2
a1543 1
				printf("Changing mode on %s\n", g.gl_pathv[i]);
d1573 1
a1573 1
					printf("Changing owner on %s\n",
d1578 1
a1578 1
					printf("Changing group on %s\n",
d1588 1
a1588 1
		printf("Remote working directory: %s\n", *pwd);
d1596 1
a1596 1
		printf("Local working directory: %s\n", path_buf);
d1664 1
a1664 1
		printf("%-*s", colspace, tmp);
d2045 1
a2045 1
				printf("Changing to: %s\n", dir);
d2091 1
a2091 1
				printf("sftp> %s", cmd);
@


1.172
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.171 2015/08/20 22:32:42 deraadt Exp $ */
d716 1
a716 1
			printf("Resuming upload of %s to %s\n", g.gl_pathv[i], 
d1186 1
a1186 1
	  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag, 
d1378 1
a1378 1
	int ignore_errors = 0, aflag = 0, fflag = 0, hflag = 0, 
@


1.171
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.170 2015/01/20 23:14:00 deraadt Exp $ */
d2209 1
@


1.170
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.169 2015/01/14 13:54:13 djm Exp $ */
d1938 1
a1938 1
	line = (char *)xmalloc(cursor + 1);
d1946 1
a1946 1
	line = (char *)xmalloc(len + 1);
@


1.169
log
@update sftp client and server to new buffer API.
pretty much just mechanical changes; with & ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.168 2014/11/26 18:34:51 millert Exp $ */
d18 1
a23 1
#include <sys/param.h>
d38 1
d1384 1
a1384 1
	char path_buf[MAXPATHLEN];
@


1.168
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.167 2014/10/06 00:47:15 djm Exp $ */
d47 2
a48 1
#include "buffer.h"
@


1.167
log
@correct options in usage(); from mancha1 AT zoho.com
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.166 2014/08/20 01:28:55 deraadt Exp $ */
d2062 2
a2063 2
	setlinebuf(stdout);
	setlinebuf(infile);
@


1.166
log
@djm how did you make a typo like that...
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.165 2014/08/19 23:57:18 djm Exp $ */
d184 1
a184 1
	{ "reput",      I_REPUT,        LOCAL   },
d232 3
a234 3
	    "get [-Ppr] remote [local]          Download file\n"
	    "reget remote [local]		Resume download file\n"
	    "reput [local] remote               Resume upload file\n"
d245 1
a245 1
	    "put [-Ppr] local [remote]          Upload file\n"
@


1.165
log
@~-expand lcd paths
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.164 2014/07/09 01:45:10 djm Exp $ */
d1501 1
a1501 1
		tmp = tilde_expand_filename(path1, getuid())
@


1.164
log
@more useful error message when GLOB_NOSPACE occurs;
bz#2254, patch from Orion Poplawski
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.163 2014/05/05 07:02:30 logan Exp $ */
d1501 3
@


1.163
log
@Zap extra whitespace.

OK from djm@@ and dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.162 2014/04/29 20:36:51 dtucker Exp $ */
d571 1
a571 1
	int i, err = 0;
d578 6
a583 2
	if (remote_glob(conn, abs_src, GLOB_MARK, NULL, &g)) {
		error("File \"%s\" not found.", abs_src);
d848 1
a848 1
	int err;
d854 1
a854 1
	if (remote_glob(conn, path,
d856 1
a856 1
	    NULL, &g) ||
d860 5
a864 1
		error("Can't ls: \"%s\" not found", path);
@


1.162
log
@Don't attempt to append a nul quote char to the filename.  Should prevent
fatal'ing with "el_insertstr failed" when there's a single quote char
somewhere in the string.  bz#2238, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.161 2014/04/29 19:58:50 dtucker Exp $ */
d710 1
a710 1
			printf("Resuming upload of  %s to %s\n", g.gl_pathv[i], 
@


1.161
log
@Move nulling of variable next to where it's freed.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.160 2014/04/22 10:07:12 logan Exp $ */
d1893 1
a1893 1
		if (!terminated)
@


1.160
log
@Sort the sftp command list.

OK from djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.159 2014/04/21 14:36:16 logan Exp $ */
d1823 1
a1830 1
	tmp = NULL;
@


1.159
log
@Implement sftp upload resume support.

OK from djm@@, with input from guenther@@, mlarkin@@ and
okan@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.158 2013/11/20 20:54:10 deraadt Exp $ */
d133 1
d135 1
a141 2
	I_REGET,
	I_REPUT
@


1.158
log
@unsigned casts for ctype macros where neccessary
ok guenther millert markus
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.157 2013/10/17 07:35:48 jmc Exp $ */
d72 1
a72 1
/* When this option is set, we resume download if possible */
d141 1
d184 1
d234 1
d645 1
a645 1
    int pflag, int rflag, int fflag)
d708 5
a712 1
		if (!quiet)
d716 1
a716 1
			    pflag || global_pflag, 1,
d721 1
a721 1
			    pflag || global_pflag,
d1175 3
a1177 2
parse_args(const char **cpp, int *ignore_errors, int *aflag, int *fflag,
    int *hflag, int *iflag, int *lflag, int *pflag, int *rflag, int *sflag,
d1229 1
a1246 5
		if (*aflag && cmdnum == I_PUT) {
			/* XXX implement resume for uploads */
			error("Resume is not supported for uploads");
			return -1;
		}
d1368 2
a1369 1
	int ignore_errors = 0, aflag = 0, fflag = 0, hflag = 0, iflag = 0;
d1402 3
d1407 1
a1407 1
		    rflag, fflag);
@


1.157
log
@tweak previous;
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.156 2013/10/17 00:30:13 djm Exp $ */
d1047 1
a1047 1
		if (isspace(arg[i])) {
@


1.156
log
@fsync@@openssh.com protocol extension for sftp-server
client support to allow calling fsync() faster successful transfer
patch mostly by imorgan AT nas.nasa.gov; bz#1798
"fine" markus@@ "grumble OK" deraadt@@ "doesn't sound bad to me" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.155 2013/08/31 00:13:54 djm Exp $ */
d2157 1
a2157 1
	    "usage: %s [-1246aCpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
@


1.155
log
@make ^w match ksh behaviour (delete previous word instead of entire line)
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.154 2013/08/09 03:56:42 djm Exp $ */
d78 3
d344 1
a344 1
    int *aflag, int *pflag, int *rflag)
d352 2
a353 2
	*aflag = *rflag = *pflag = 0;
	while ((ch = getopt(argc, argv, "aPpRr")) != -1) {
d358 3
d562 1
a562 1
    int pflag, int rflag, int resume)
d621 2
a622 1
			    pflag || global_pflag, 1, resume) == -1)
d626 2
a627 1
			    pflag || global_pflag, resume) == -1)
d642 1
a642 1
    int pflag, int rflag)
d709 2
a710 1
			    pflag || global_pflag, 1) == -1)
d714 2
a715 1
			    pflag || global_pflag) == -1)
d1168 3
a1170 3
parse_args(const char **cpp, int *aflag, int *hflag, int *iflag, int *lflag,
    int *pflag, int *rflag, int *sflag, unsigned long *n_arg,
    char **path1, char **path2)
d1182 1
a1182 1
	*iflag = 0;
d1184 1
a1184 1
		*iflag = 1;
d1214 2
a1215 1
	*aflag = *lflag = *pflag = *rflag = *hflag = *n_arg = 0;
d1223 1
a1223 1
		    aflag, pflag, rflag)) == -1)
d1364 2
a1365 2
	int aflag = 0, hflag = 0, iflag = 0, lflag = 0, pflag = 0;
	int rflag = 0, sflag = 0;
d1374 3
a1376 3
	cmdnum = parse_args(&cmd, &aflag, &hflag, &iflag, &lflag, &pflag,
	    &rflag, &sflag, &n_arg, &path1, &path2);
	if (iflag != 0)
d1395 1
a1395 1
		    rflag, aflag);
d1398 2
a1399 1
		err = process_put(conn, path1, path2, *pwd, pflag, rflag);
d2204 1
a2204 1
	    "1246ahpqrvCc:D:i:l:o:s:S:b:B:F:P:R:")) != -1) {
d2263 3
@


1.154
log
@enable ctrl-left-arrow and ctrl-right-arrow to move forward/back a word;
matching ksh's relatively recent change.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.153 2013/08/09 03:37:25 djm Exp $ */
d1992 2
@


1.153
log
@do getopt parsing for all sftp commands (with an empty optstring for
commands without arguments) to ensure consistent behaviour
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.152 2013/08/08 05:04:03 djm Exp $ */
d1987 5
@


1.152
log
@add a "-l" flag for the rename command to force it to use the silly
standard SSH_FXP_RENAME command instead of the POSIX-rename- like
posix-rename@@openssh.com extension.

intended for use in regress tests, so no documentation.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.151 2013/08/08 04:52:04 djm Exp $ */
d501 20
d1242 2
d1262 2
d1305 2
d1337 2
@


1.151
log
@fix two year old regression: symlinking a file would incorrectly
canonicalise the target path. bz#2129 report from delphij AT freebsd.org
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.150 2013/08/07 06:24:51 jmc Exp $ */
d397 24
d1216 5
d1222 1
a1222 1
	case I_RENAME:
d1364 1
a1364 1
		err = do_rename(conn, path1, path2);
@


1.150
log
@sort -a;
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.149 2013/08/06 23:03:49 djm Exp $ */
d1340 2
a1341 1
		path1 = make_absolute(path1, *pwd);
@


1.149
log
@fix some whitespace at EOL

make list of commands an enum rather than a long list of defines

add -a to usage()
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.148 2013/07/25 00:56:52 djm Exp $ */
d2080 1
a2080 1
	    "usage: %s [-1246Capqrv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
@


1.148
log
@sftp support for resuming partial downloads; patch mostly by Loganaden
Velvindron/AfriNIC with some tweaks by me; feedback and ok dtucker@@
"Just be careful" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.147 2013/07/12 00:20:00 djm Exp $ */
d111 28
a138 26
#define I_CHDIR		1
#define I_CHGRP		2
#define I_CHMOD		3
#define I_CHOWN		4
#define I_DF		24
#define I_GET		5
#define I_HELP		6
#define I_LCHDIR	7
#define I_LINK		25
#define I_LLS		8
#define I_LMKDIR	9
#define I_LPWD		10
#define I_LS		11
#define I_LUMASK	12
#define I_MKDIR		13
#define I_PUT		14
#define I_PWD		15
#define I_QUIT		16
#define I_RENAME	17
#define I_RM		18
#define I_RMDIR		19
#define I_SHELL		20
#define I_SYMLINK	21
#define I_VERSION	22
#define I_PROGRESS	23
#define I_REGET		26
d631 1
a631 1
		
d959 1
a959 1
 * 
d1008 1
a1008 1
			} else if (state == MA_UNQUOTED) 
d1550 1
a1550 1
	for (y = 0; list[y]; y++) 
d1595 2
a1596 2
			for (x = 0; x < matchlen; x++) 
				if (list[0][x] != list[y][x]) 
d1608 1
a1608 1
	} 
d1628 1
a1628 1
		
d1632 2
a1633 2
		for (y = 0; list[y] != NULL; y++)  
			free(list[y]);	
d1641 1
a1641 1
		if (!strncasecmp(cmd, cmds[y].c, cmdlen)) 
d1656 2
a1657 2
	for (y = 0; list[y]; y++)  
		free(list[y]);	
d1697 1
a1697 1
		if (!strncasecmp(cmd, cmds[i].c, strlen(cmds[i].c))) 
d1714 1
a1714 1
	
d1728 1
a1728 1
	} else 
d1730 1
a1730 1
	
d1746 1
a1746 1
	if (g.gl_matchc == 0) 
d1779 1
a1779 1
		len = strlen(tmp2); 
d1835 1
a1835 1
	char **argv, *line, quote; 
d1874 1
a1874 1
		    quote, terminated) != 0) 
d1887 1
a1887 1
		    remote, carg == argc, quote, terminated) != 0) 
d1891 1
a1891 1
	free(line);	
d1923 1
a1923 1
		el_set(el, EL_ADDFN, "ftp-complete", 
d2080 1
a2080 1
	    "usage: %s [-1246Cpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
@


1.147
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.146 2013/06/04 20:42:36 dtucker Exp $ */
d72 3
d136 1
d176 1
d226 1
d338 2
a339 2
parse_getput_flags(const char *cmd, char **argv, int argc, int *pflag,
    int *rflag)
d347 2
a348 2
	*rflag = *pflag = 0;
	while ((ch = getopt(argc, argv, "PpRr")) != -1) {
d350 3
d510 1
a510 1
    int pflag, int rflag)
d562 4
a565 1
		if (!quiet)
d568 2
a569 2
			if (download_dir(conn, g.gl_pathv[i], abs_dst, NULL, 
			    pflag || global_pflag, 1) == -1)
d573 1
a573 1
			    pflag || global_pflag) == -1)
d1112 3
a1114 2
parse_args(const char **cpp, int *pflag, int *rflag, int *lflag, int *iflag,
    int *hflag, int *sflag, unsigned long *n_arg, char **path1, char **path2)
d1158 1
a1158 1
	*lflag = *pflag = *rflag = *hflag = *n_arg = 0;
d1163 1
d1166 1
a1166 1
		    pflag, rflag)) == -1)
d1181 5
d1294 2
a1295 1
	int pflag = 0, rflag = 0, lflag = 0, iflag = 0, hflag = 0, sflag = 0;
d1304 2
a1305 3
	cmdnum = parse_args(&cmd, &pflag, &rflag, &lflag, &iflag, &hflag,
	    &sflag, &n_arg, &path1, &path2);

d1320 3
d1324 2
a1325 1
		err = process_get(conn, path1, path2, *pwd, pflag, rflag);
d1950 4
a1953 6
			if (file2 == NULL)
				snprintf(cmd, sizeof cmd, "get %s", dir);
			else
				snprintf(cmd, sizeof cmd, "get %s %s", dir,
				    file2);

d2125 1
a2125 1
	    "1246hpqrvCc:D:i:l:o:s:S:b:B:F:P:R:")) != -1) {
d2164 3
@


1.146
log
@Make sftp's libedit interface marginally multibyte aware by building up the
quoted string by character instead of by byte.  Prevents failures when linked
against a libedit built with wide character support (bz#1990).  "looks ok" djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.145 2013/05/17 00:13:14 djm Exp $ */
d1811 2
a1812 1
	u_int argc, carg, cursor, len, terminated, ret = CC_ERROR;
@


1.145
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.144 2013/05/16 09:08:41 dtucker Exp $ */
d32 1
d1685 1
a1685 1
	char *tmp, *tmp2, ins[3];
d1687 1
d1756 4
a1759 1
		for (i = 0; i < len; i++) {
d1761 2
a1762 2
			ins[1] = tmp2[i];
			ins[2] = '\0';
d2089 1
@


1.144
log
@Fix some "unused result" warnings found via clang and -portable.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.143 2013/04/18 02:16:07 djm Exp $ */
d293 1
a293 1
		xfree(buf);
d324 1
a324 1
		xfree(p);
d534 1
a534 1
			xfree(tmp);
d550 1
a550 1
		xfree(tmp);
d563 1
a563 1
		xfree(abs_dst);
d568 1
a568 1
	xfree(abs_src);
d620 1
a620 1
			xfree(tmp);
d636 1
a636 1
		xfree(tmp);
d652 2
a653 4
	if (abs_dst)
		xfree(abs_dst);
	if (tmp_dst)
		xfree(tmp_dst);
d701 1
a701 1
		xfree(tmp);
d727 1
a727 1
		xfree(tmp);
d739 1
a739 1
				xfree(lname);
d751 1
a751 1
		xfree(fname);
d821 1
a821 1
			xfree(lname);
d830 1
a830 1
		xfree(fname);
d1347 1
a1347 1
			xfree(tmp);
d1353 1
a1353 1
			xfree(tmp);
d1360 1
a1360 1
			xfree(tmp);
d1364 1
a1364 1
		xfree(*pwd);
d1497 2
a1498 4
	if (path1)
		xfree(path1);
	if (path2)
		xfree(path2);
d1607 2
a1608 2
			xfree(list[y]);	
		xfree(list);
d1621 1
a1621 1
		xfree(list);
d1631 2
a1632 2
		xfree(list[y]);	
	xfree(list);
d1653 1
a1653 1
		xfree(tmp);
d1717 1
a1717 1
	xfree(tmp);
d1732 1
a1732 1
	xfree(tmp2);
d1794 1
a1794 1
	xfree(tmp);
d1820 1
a1820 1
	xfree(line);
d1832 1
a1832 1
		xfree(line);
d1860 1
a1860 1
	xfree(line);	
d1914 3
a1916 3
				xfree(dir);
				xfree(remote_path);
				xfree(conn);
d1929 3
a1931 3
			xfree(dir);
			xfree(remote_path);
			xfree(conn);
d1934 1
a1934 1
		xfree(dir);
d1989 2
a1990 2
	xfree(remote_path);
	xfree(conn);
@


1.143
log
@make "sftp -q" do what it says on the sticker: hush everything but errors;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.142 2013/02/08 00:41:12 djm Exp $ */
d202 1
a202 1
	write(STDERR_FILENO, msg, sizeof(msg) - 1);
@


1.142
log
@fix NULL deref when built without libedit and control characters
entered as command; debugging and patch from Iain Morgan an
Loganaden Velvindron in bz#1956
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.141 2012/10/05 12:34:39 markus Exp $ */
d62 3
d552 2
a553 1
		printf("Fetching %s to %s\n", g.gl_pathv[i], abs_dst);
d638 2
a639 1
		printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
d1324 2
a1325 1
			printf("Removing %s\n", g.gl_pathv[i]);
d1421 2
a1422 1
			printf("Changing mode on %s\n", g.gl_pathv[i]);
d1451 3
a1453 1
				printf("Changing owner on %s\n", g.gl_pathv[i]);
d1456 3
a1458 1
				printf("Changing group on %s\n", g.gl_pathv[i]);
d1913 2
a1914 1
			printf("Changing to: %s\n", dir);
d2118 2
d2155 1
a2155 1
			batchmode = 1;
d2252 1
a2252 1
	if (!batchmode) {
@


1.141
log
@fix signed vs unsigned warning; feedback & ok: djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.140 2012/09/21 10:55:04 dtucker Exp $ */
d1125 1
a1125 1
		if (strcasecmp(cmds[i].c, argv[0]) == 0)
@


1.140
log
@Fix handling of filenames containing escaped globbing characters and escape
"#" and "*".  Patch from Jean-Marc Robert via tech@@, ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.138 2012/09/18 10:36:12 dtucker Exp $ */
d971 1
a971 1
		if (argc >= sizeof(argv) / sizeof(*argv)){
@


1.139
log
@Fix improper handling of absolute paths when PWD is part of the completed
path.  Patch from Jean-Marc Robert via tech@@, ok djm.
@
text
@d1678 1
a1678 1
	u_int i, hadglob, pwdlen, len, tmplen, filelen, isabs;
d1733 12
a1744 2
	if (tmplen > filelen)  {
		tmp2 = tmp + filelen;
d1758 2
@


1.138
log
@Add bounds check on sftp tab-completion.  Part of a patch from from Jean-Marc
Robert via tech@@, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.137 2012/09/17 09:54:44 djm Exp $ */
d1678 1
a1678 1
	u_int i, hadglob, pwdlen, len, tmplen, filelen;
d1687 3
d1724 1
a1724 1
	tmp = path_strip(tmp2, remote_path);
@


1.137
log
@an XXX for later
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.136 2012/06/22 14:36:33 dtucker Exp $ */
d971 4
@


1.136
log
@Remove unused variable leftover from tab-completion changes.
From Steve.McClellan at radisys com, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.135 2012/04/20 03:24:23 djm Exp $ */
d1893 1
@


1.135
log
@setlinebuf(3) is more readable than setvbuf(.., _IOLBF, ...)
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.134 2011/11/16 12:24:28 oga Exp $ */
a762 1
	Attrib *a = NULL;
d808 1
a808 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++, a = NULL) {
@


1.134
log
@Don't leak list in complete_cmd_parse if there are no commands found.

Discovered when I was ``borrowing'' this code for something else.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.133 2011/09/22 06:29:03 djm Exp $ */
d1910 2
a1911 2
	setvbuf(stdout, NULL, _IOLBF, 0);
	setvbuf(infile, NULL, _IOLBF, 0);
@


1.133
log
@don't let remote_glob() implicitly sort its results in do_globbed_ls() -
in all likelihood, they will be resorted anyway
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.132 2010/12/04 00:18:01 djm Exp $ */
d1610 2
a1611 1
	if (count == 0)
d1613 1
@


1.132
log
@add a protocol extension to support a hard link operation. It is
available through the "ln" command in the client. The old "ln"
behaviour of creating a symlink is available using its "-s" option
or through the preexisting "symlink" command; based on a patch from
miklos AT szeredi.hu in bz#1555; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.131 2010/10/23 22:06:12 sthen Exp $ */
d773 2
a774 1
	    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT, NULL, &g) ||
@


1.131
log
@escape '[' in filename tab-completion; fix a type while there.
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.130 2010/10/05 05:13:18 djm Exp $ */
d112 1
d157 1
a157 1
	{ "ln",		I_SYMLINK,	REMOTE	},
d221 1
a221 1
	    "ln oldpath newpath                 Symlink remote file\n"
d358 24
d1093 1
a1093 1
    int *hflag, unsigned long *n_arg, char **path1, char **path2)
d1143 2
a1144 1
		if ((optidx = parse_getput_flags(cmd, argv, argc, pflag, rflag)) == -1)
d1160 4
a1164 1
	case I_SYMLINK:
d1267 2
a1268 1
	int pflag = 0, rflag = 0, lflag = 0, iflag = 0, hflag = 0, cmdnum, i;
d1276 2
a1277 2
	cmdnum = parse_args(&cmd, &pflag, &rflag, &lflag, &iflag, &hflag, &n_arg,
	    &path1, &path2);
d1305 3
d1309 1
a1309 1
		err = do_symlink(conn, path1, path2);
@


1.130
log
@use default shell /bin/sh if $SHELL is ""; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.129 2010/09/26 22:26:33 djm Exp $ */
d1704 1
d1832 1
a1832 1
		    "Context senstive argument completion", complete);
@


1.129
log
@when performing an "ls" in columnated (short) mode, only call
ioctl(TIOCGWINSZ) once to get the window width instead of per-
filename
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.128 2010/09/25 09:30:16 djm Exp $ */
d249 1
a249 1
	if ((shell = getenv("SHELL")) == NULL)
@


1.128
log
@make use of new glob(3) GLOB_KEEPSTAT extension to save extra server
rountrips to fetch per-file stat(2) information.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.127 2010/09/23 13:34:43 jmc Exp $ */
d738 2
a740 2
	u_int i, c = 1, colspace = 0, columns = 1;
	Attrib *a = NULL;
d742 2
a743 1
	char *fname, *lname;
d770 3
a773 3
		u_int m = 0, width = 80;
		struct winsize ws;

a776 3

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;
@


1.127
log
@add [-l limit] to usage();
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.126 2010/09/22 22:58:51 djm Exp $ */
d741 2
d746 3
a748 2
	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE,
	    NULL, &g) || (g.gl_pathc && !g.gl_matchc)) {
d752 1
a752 1
		return (-1);
d762 5
a766 13
	if (g.gl_matchc == 1) {
		if ((a = do_lstat(conn, g.gl_pathv[0], 1)) == NULL) {
			globfree(&g);
			return (-1);
		}
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
		    S_ISDIR(a->perm)) {
			int err;

			err = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);
			globfree(&g);
			return (err);
		}
a785 2
		char *fname;

a786 1

d788 6
a793 16
			char *lname;
			struct stat sb;

			/*
			 * XXX: this is slow - 1 roundtrip per path
			 * A solution to this is to fork glob() and
			 * build a sftp specific version which keeps the
			 * attribs (which currently get thrown away)
			 * that the server returns as well as the filenames.
			 */
			memset(&sb, 0, sizeof(sb));
			if (a == NULL)
				a = do_lstat(conn, g.gl_pathv[i], 1);
			if (a != NULL)
				attrib_to_stat(a, &sb);
			lname = ls_file(fname, &sb, 1, (lflag & LS_SI_UNITS));
d814 1
a814 1
	return (0);
@


1.126
log
@add an option per-read/write callback to atomicio

factor out bandwidth limiting code from scp(1) into a generic bandwidth
limiter that can be attached using the atomicio callback mechanism

add a bandwidth limit option to sftp(1) using the above

"very nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.125 2010/06/18 00:58:39 djm Exp $ */
d2009 1
a2009 1
	    "[-i identity_file]\n"
@


1.125
log
@unbreak ls in working directories that contains globbing characters in
their pathnames. bz#1655 reported by vgiffin AT apple.com
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.124 2010/05/05 04:22:09 dtucker Exp $ */
d2028 1
d2036 1
d2053 1
a2053 1
	    "1246hpqrvCc:D:i:o:s:S:b:B:F:P:R:")) != -1) {
d2114 7
d2198 1
a2198 1
	conn = do_init(in, out, copy_buffer_len, num_requests);
@


1.124
log
@restore mput and mget which got lost in the tab-completion changes.
found by Kenneth Whitaker, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.123 2010/01/27 19:21:39 djm Exp $ */
d1348 1
a1348 1
			do_globbed_ls(conn, *pwd, *pwd, lflag);
@


1.123
log
@add missing "p" flag to getopt optstring;
bz#1704 from imorgan AT nas.nasa.gov
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.122 2010/01/15 00:05:22 guenther Exp $ */
d161 2
@


1.122
log
@Reset SIGTERM to SIG_DFL before executing ssh, so that even if sftp
inherited SIGTERM as ignored it will still be able to kill the ssh it
starts.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.121 2010/01/13 12:48:34 jmc Exp $ */
d2049 1
a2049 1
	    "1246hqrvCc:D:i:o:s:S:b:B:F:P:R:")) != -1) {
@


1.121
log
@sftp.1: put ls -h in the right place
sftp.c: as above, plus add -p to get/put, and shorten their arg names
to keep the help usage nicely aligned

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.120 2010/01/13 04:10:50 djm Exp $ */
d1982 2
a1983 1
		 * kill it too
d1986 1
@


1.120
log
@don't append a space after inserting a completion of a directory (i.e.
a path ending in '/') for a slightly better user experience; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.119 2010/01/13 01:40:16 djm Exp $ */
d213 1
a213 1
	    "get [-Pr] remote-path [local-path] Download file\n"
d220 1
a220 1
	    "ls [-1aflnrSt] [path]              Display remote directory listing\n"
d224 1
a224 1
	    "put [-Pr] local-path [remote-path] Upload file\n"
@


1.119
log
@support '-h' (human-readable units) for sftp's ls command, just like
ls(1); ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.118 2010/01/09 11:13:02 dtucker Exp $ */
a1738 4
	/*
	 * XXX should we really extend here? the user may not be done if
	 * the filename is a directory.
	 */
d1743 2
a1744 1
		if (lastarg || *(lf->cursor) != ' ')
@


1.118
log
@Prevent sftp from derefing a null pointer when given a "-" without a command.
Also, allow whitespace to follow a "-".  bz#1691, path from Colin Watson via
Debian.  ok djm@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.117 2010/01/08 21:50:49 dtucker Exp $ */
d90 9
a98 8
#define LS_LONG_VIEW	0x01	/* Full view ala ls -l */
#define LS_SHORT_VIEW	0x02	/* Single row view ala ls -1 */
#define LS_NUMERIC_VIEW	0x04	/* Long view with numeric uid/gid */
#define LS_NAME_SORT	0x08	/* Sort by name (default) */
#define LS_TIME_SORT	0x10	/* Sort by mtime */
#define LS_SIZE_SORT	0x20	/* Sort by file size */
#define LS_REVERSE_SORT	0x40	/* Reverse sort order */
#define LS_SHOW_ALL	0x80	/* Don't skip filenames starting with '.' */
d100 1
a100 1
#define VIEW_FLAGS	(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW)
d364 1
a364 1
	while ((ch = getopt(argc, argv, "1Saflnrt")) != -1) {
d380 3
d384 1
a384 1
			*lflag &= ~VIEW_FLAGS;
d388 1
a388 1
			*lflag &= ~VIEW_FLAGS;
d700 1
a700 1
			if (lflag & LS_NUMERIC_VIEW) {
d706 2
a707 1
				lname = ls_file(fname, &sb, 1);
d809 1
a809 1
			lname = ls_file(fname, &sb, 1);
@


1.117
log
@Fix two warnings: possibly used unitialized and use a nul byte instead of
NULL pointer.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.116 2010/01/04 02:03:57 djm Exp $ */
a1091 4
	/* Ignore blank lines and lines which begin with comment '#' char */
	if (*cp == '\0' || *cp == '#')
		return (0);

d1097 1
d1099 4
@


1.116
log
@Implement tab-completion of commands, local and remote filenames for sftp.
Hacked on and off for some time by myself, mouring, Carlos Silva (via 2009
Google Summer of Code) and polished to a fine sheen by myself again.
It should deal more-or-less correctly with the ikky corner-cases presented
by quoted filenames, but the UI could still be slightly improved.
In particular, it is quite slow for remote completion on large directories.
bz#200; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.115 2009/12/20 07:28:36 guenther Exp $ */
d1547 1
a1547 1
			tmp[matchlen] = NULL;
d2017 1
a2017 1
	char *host, *userhost, *cp, *file2 = NULL;
@


1.115
log
@When passing user-controlled options with arguments to other programs,
pass the option and option argument as separate argv entries and
not smashed into one (e.g., as -l foo and not -lfoo).  Also, always
pass a "--" argument to stop option parsing, so that a positional
argument that starts with a '-' isn't treated as an option.  This
fixes some error cases as well as the handling of hostnames and
filenames that start with a '-'.

Based on a diff by halex@@
ok halex@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.114 2009/12/06 23:53:54 dtucker Exp $ */
d77 6
d131 1
d134 5
d140 32
a171 34
	{ "bye",	I_QUIT },
	{ "cd",		I_CHDIR },
	{ "chdir",	I_CHDIR },
	{ "chgrp",	I_CHGRP },
	{ "chmod",	I_CHMOD },
	{ "chown",	I_CHOWN },
	{ "df",		I_DF },
	{ "dir",	I_LS },
	{ "exit",	I_QUIT },
	{ "get",	I_GET },
	{ "mget",	I_GET },
	{ "help",	I_HELP },
	{ "lcd",	I_LCHDIR },
	{ "lchdir",	I_LCHDIR },
	{ "lls",	I_LLS },
	{ "lmkdir",	I_LMKDIR },
	{ "ln",		I_SYMLINK },
	{ "lpwd",	I_LPWD },
	{ "ls",		I_LS },
	{ "lumask",	I_LUMASK },
	{ "mkdir",	I_MKDIR },
	{ "progress",	I_PROGRESS },
	{ "put",	I_PUT },
	{ "mput",	I_PUT },
	{ "pwd",	I_PWD },
	{ "quit",	I_QUIT },
	{ "rename",	I_RENAME },
	{ "rm",		I_RM },
	{ "rmdir",	I_RMDIR },
	{ "symlink",	I_SYMLINK },
	{ "version",	I_VERSION },
	{ "!",		I_SHELL },
	{ "?",		I_HELP },
	{ NULL,			-1}
d922 3
d926 7
d937 2
a938 1
makeargv(const char *arg, int *argcp)
d952 4
d972 2
d1010 2
d1037 6
d1056 2
d1080 2
a1081 2
parse_args(const char **cpp, int *pflag, int *rflag, int *lflag, int *iflag, int *hflag,
    unsigned long *n_arg, char **path1, char **path2)
d1103 1
a1103 1
	if ((argv = makeargv(cp, &argc)) == NULL)
d1483 334
d1820 1
a1820 1
	char *pwd;
d1828 1
d1843 8
d1853 2
a1854 2
	pwd = do_realpath(conn, ".");
	if (pwd == NULL)
d1859 1
a1859 1
		dir = make_absolute(dir, pwd);
d1864 2
a1865 1
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0) {
d1867 1
a1867 1
				xfree(pwd);
d1878 2
a1879 1
			err = parse_dispatch_command(conn, cmd, &pwd, 1);
d1881 1
a1881 1
			xfree(pwd);
d1915 2
a1916 1
			if ((line = el_gets(el, &count)) == NULL || count <= 0) {
d1935 2
a1936 1
		err = parse_dispatch_command(conn, cmd, &pwd, batchmode);
d1940 1
a1940 1
	xfree(pwd);
@


1.114
log
@fix potential divide-by-zero in sftp's "df" output when talking to a server
that reports zero files on the filesystem (Unix filesystems always have at
least the root inode).  From Steve McClellan at radisys, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.113 2009/11/22 13:18:00 halex Exp $ */
d1763 2
a1764 1
			addargs(&args, "-l%s", userhost);
d1784 1
@


1.113
log
@make passing of zero-length arguments to ssh safe by
passing "-<switch>" "<value>" rather than "-<switch><value>"

ok dtucker@@, guenther@@, djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.112 2009/11/20 00:54:01 djm Exp $ */
d826 1
d831 1
d838 1
a838 3
		    (unsigned long long)st.f_ffree,
		    (unsigned long long)(100 * (st.f_files - st.f_ffree) /
		    st.f_files));
@


1.112
log
@bz#1588 change "Connecting to host..." message to "Connected to host."
and delay it until after the sftp protocol connection has been established.
Avoids confusing sequence of messages when the underlying ssh connection
experiences problems. ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.111 2009/08/18 18:36:21 djm Exp $ */
d1673 2
a1674 1
			addargs(&args, "-%c%s", ch, optarg);
@


1.111
log
@recursive transfer support for get/put and on the commandline
work mostly by carlosvsilvapt@@gmail.com for the Google Summer of Code
with some tweaks by me; "go for it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.110 2009/08/13 13:39:54 jmc Exp $ */
d50 3
a58 6
/* Size of buffer used when copying files */
size_t copy_buffer_len = 32768;

/* Number of concurrent outstanding requests */
size_t num_requests = 64;

d164 1
a164 1
int interactive_loop(int fd_in, int fd_out, char *file1, char *file2);
d1447 1
a1447 1
interactive_loop(int fd_in, int fd_out, char *file1, char *file2)
a1451 1
	struct sftp_conn *conn;
a1472 4
	conn = do_init(fd_in, fd_out, copy_buffer_len, num_requests);
	if (conn == NULL)
		fatal("Couldn't initialise connection to server");

d1641 3
a1785 2
		if (!batchmode)
			fprintf(stderr, "Connecting to %s...\n", host);
a1790 2
		if (!batchmode)
			fprintf(stderr, "Attaching to %s...\n", sftp_direct);
d1795 12
a1806 1
	err = interactive_loop(in, out, file1, file2);
@


1.110
log
@sync synopsis and usage();
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.109 2009/08/13 01:11:19 djm Exp $ */
d31 1
d68 6
d205 1
a205 1
	    "get [-P] remote-path [local-path]  Download file\n"
d216 1
a216 1
	    "put [-P] local-path [remote-path]  Upload file\n"
a302 15
path_append(char *p1, char *p2)
{
	char *ret;
	size_t len = strlen(p1) + strlen(p2) + 2;

	ret = xmalloc(len);
	strlcpy(ret, p1, len);
	if (p1[0] != '\0' && p1[strlen(p1) - 1] != '/')
		strlcat(ret, "/", len);
	strlcat(ret, p2, len);

	return(ret);
}

static char *
d317 2
a318 21
infer_path(const char *p, char **ifp)
{
	char *cp;

	cp = strrchr(p, '/');
	if (cp == NULL) {
		*ifp = xstrdup(p);
		return(0);
	}

	if (!cp[1]) {
		error("Invalid path");
		return(-1);
	}

	*ifp = xstrdup(cp + 1);
	return(0);
}

static int
parse_getput_flags(const char *cmd, char **argv, int argc, int *pflag)
d326 2
a327 2
	*pflag = 0;
	while ((ch = getopt(argc, argv, "Pp")) != -1) {
d333 4
d448 9
d458 2
a459 1
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
a462 1
	char *tmp;
d464 2
a465 2
	int err = 0;
	int i;
d469 1
a470 1
	memset(&g, 0, sizeof(g));
d472 1
a472 1
	if (remote_glob(conn, abs_src, 0, NULL, &g)) {
d478 7
a484 4
	/* If multiple matches, dst must be a directory or unspecified */
	if (g.gl_matchc > 1 && dst && !is_dir(dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    dst);
d490 4
a493 1
		if (infer_path(g.gl_pathv[i], &tmp)) {
a498 2
			/* If directory specified, append filename */
			xfree(tmp);
d500 2
a501 7
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
d503 1
d505 5
a509 4
			abs_dst = path_append(dst, tmp);
			xfree(tmp);
		} else
			abs_dst = tmp;
d512 9
a520 2
		if (do_download(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
d532 2
a533 1
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
d537 1
a537 1
	char *tmp;
d540 1
a540 1
	int i;
d550 1
a550 1
	if (glob(src, GLOB_NOCHECK, NULL, &g)) {
d556 4
d561 3
a563 3
	if (g.gl_matchc > 1 && tmp_dst && !remote_is_dir(conn, tmp_dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    tmp_dst);
d574 5
a578 7

		if (!S_ISREG(sb.st_mode)) {
			error("skipping non-regular file %s",
			    g.gl_pathv[i]);
			continue;
		}
		if (infer_path(g.gl_pathv[i], &tmp)) {
d585 3
a587 8
			if (remote_is_dir(conn, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
a588 1

d590 5
a594 4
			abs_dst = path_append(tmp_dst, tmp);
			xfree(tmp);
		} else
			abs_dst = make_absolute(tmp, pwd);
d597 9
a605 2
		if (do_upload(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
d1046 1
a1046 1
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag, int *hflag,
d1090 1
a1090 1
	*lflag = *pflag = *hflag = *n_arg = 0;
d1096 1
a1096 1
		if ((optidx = parse_getput_flags(cmd, argv, argc, pflag)) == -1)
d1216 1
a1216 1
	int pflag = 0, lflag = 0, iflag = 0, hflag = 0, cmdnum, i;
d1224 1
a1224 1
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &hflag, &n_arg,
d1242 1
a1242 1
		err = process_get(conn, path1, path2, *pwd, pflag);
d1245 1
a1245 1
		err = process_put(conn, path1, path2, *pwd, pflag);
d1271 1
a1271 1
		err = do_mkdir(conn, path1, &a);
d1624 1
a1624 1
	    "usage: %s [-1246Cqv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
d1665 1
a1665 1
	    "1246hqvCc:D:i:o:s:S:b:B:F:P:R:")) != -1) {
d1719 3
d1724 3
@


1.109
log
@Swizzle options: "-P sftp_server_path" moves to "-D sftp_server_path",
add "-P port" to match scp(1). Fortunately, the -P option is only really
used by our regression scripts.

part of larger patch from carlosvsilvapt@@gmail.com for his Google Summer
of Code work; ok deraadt markus
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.108 2009/08/12 00:13:00 djm Exp $ */
d1626 4
a1629 2
	    "          [-F ssh_config] [-i identify_file] [-o ssh_option]\n"
	    "          [-P sftp_server_path] [-R num_requests] [-S program]\n"
@


1.108
log
@support most of scp(1)'s commandline arguments in sftp(1), as a first
step towards making sftp(1) a drop-in replacement for scp(1).
One conflicting option (-P) has not been changed, pending further
discussion.

Patch from carlosvsilvapt@@gmail.com as part of his work in the
Google Summer of Code
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.107 2009/02/02 11:15:14 dtucker Exp $ */
d1663 2
a1664 1
	while ((ch = getopt(argc, argv, "1246hqvCc:i:o:s:S:b:B:F:P:R:")) != -1) {
d1683 3
d1718 1
a1718 1
		case 'P':
@


1.107
log
@Initialize a few variables to prevent spurious "may be used uninitialized"
warnings from newer gcc's.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.106 2008/12/09 15:35:00 sobrado Exp $ */
d1625 4
a1628 3
	    "usage: %s [-1Cv] [-B buffer_size] [-b batchfile] [-F ssh_config]\n"
	    "            [-o ssh_option] [-P sftp_server_path] [-R num_requests]\n"
	    "            [-S program] [-s subsystem | sftp_server] host\n"
d1631 2
a1632 1
	    "       %s -b batchfile [user@@]host\n", __progname, __progname, __progname, __progname);
d1663 1
a1663 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:B:F:P:R:")) != -1) {
d1665 3
d1669 12
a1680 1
			addargs(&args, "-C");
a1688 4
		case 'F':
		case 'o':
			addargs(&args, "-%c%s", ch, optarg);
			break;
d1694 2
a1695 2
		case 's':
			sftp_server = optarg;
d1697 4
a1700 3
		case 'S':
			ssh_program = optarg;
			replacearg(&args, 0, "%s", ssh_program);
a1716 5
		case 'B':
			copy_buffer_len = strtol(optarg, &cp, 10);
			if (copy_buffer_len == 0 || *cp != '\0')
				fatal("Invalid buffer size \"%s\"", optarg);
			break;
d1722 7
@


1.106
log
@update for the synopses displayed by the 'help' command, there are a
few missing flags; add 'bye' to the output of 'help'; sorting and spacing.

jmc@@ suggested replacing .Oo/.Oc with a single .Op macro.

ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.105 2008/12/09 03:04:39 djm Exp $ */
d1217 2
a1218 2
	int pflag, lflag, iflag, hflag, cmdnum, i;
	unsigned long n_arg;
@


1.105
log
@correct sftp(1) and corresponding usage syntax;
bz#1518 patch from imorgan AT nas.nasa.gov; ok deraadt@@ improved diff jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.104 2008/12/09 02:39:59 djm Exp $ */
d189 31
a219 30
	printf("Available commands:\n");
	printf("cd path                       Change remote directory to 'path'\n");
	printf("lcd path                      Change local directory to 'path'\n");
	printf("chgrp grp path                Change group of file 'path' to 'grp'\n");
	printf("chmod mode path               Change permissions of file 'path' to 'mode'\n");
	printf("chown own path                Change owner of file 'path' to 'own'\n");
	printf("df [path]                     Display statistics for current directory or\n");
	printf("                              filesystem containing 'path'\n");
	printf("help                          Display this help text\n");
	printf("get remote-path [local-path]  Download file\n");
	printf("lls [ls-options [path]]       Display local directory listing\n");
	printf("ln oldpath newpath            Symlink remote file\n");
	printf("lmkdir path                   Create local directory\n");
	printf("lpwd                          Print local working directory\n");
	printf("ls [path]                     Display remote directory listing\n");
	printf("lumask umask                  Set local umask to 'umask'\n");
	printf("mkdir path                    Create remote directory\n");
	printf("progress                      Toggle display of progress meter\n");
	printf("put local-path [remote-path]  Upload file\n");
	printf("pwd                           Display remote working directory\n");
	printf("exit                          Quit sftp\n");
	printf("quit                          Quit sftp\n");
	printf("rename oldpath newpath        Rename remote file\n");
	printf("rmdir path                    Remove remote directory\n");
	printf("rm path                       Delete remote file\n");
	printf("symlink oldpath newpath       Symlink remote file\n");
	printf("version                       Show SFTP version\n");
	printf("!command                      Execute 'command' in local shell\n");
	printf("!                             Escape to local shell\n");
	printf("?                             Synonym for help\n");
@


1.104
log
@Deal correctly with failures in remote stat() operation in sftp,
correcting fail-on-error behaviour in batchmode. bz#1541 report and
fix from anedvedicky AT gmail.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.103 2008/07/13 22:16:03 djm Exp $ */
d1627 2
a1628 2
	    "       %s [[user@@]host[:file [file]]]\n"
	    "       %s [[user@@]host[:dir[/]]]\n"
@


1.103
log
@increase number of piplelined requests so they properly fill the
(recently increased) channel window. prompted by rapier AT psc.edu;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.102 2008/06/21 07:46:46 martynas Exp $ */
d1368 2
a1369 1
				if (err != 0 && err_abort)
d1371 1
a1371 1
				else
d1377 2
a1378 1
				if (err != 0 && err_abort)
d1380 1
a1380 1
				else
@


1.102
log
@use optopt to get invalid flag, instead of return value of getopt,
which is always '?';  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.101 2008/06/08 20:15:29 dtucker Exp $ */
d59 1
a59 1
size_t num_requests = 16;
@


1.101
log
@Have the sftp client store the statvfs replies in wire format,
which prevents problems when the server's native sizes exceed the
client's.

Also extends the sizes of the remaining 32bit wire format to 64bit,
they're specified as unsigned long in the standard.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.100 2008/04/18 12:32:11 djm Exp $ */
d346 1
a346 1
	extern int optind, optreset, opterr;
d360 1
a360 1
			error("%s: Invalid flag -%c", cmd, ch);
d371 1
a371 1
	extern int optind, optreset, opterr;
d410 1
a410 1
			error("ls: Invalid flag -%c", ch);
d421 1
a421 1
	extern int optind, optreset, opterr;
d437 1
a437 1
			error("%s: Invalid flag -%c", cmd, ch);
@


1.100
log
@introduce sftp extension methods statvfs@@openssh.com and
fstatvfs@@openssh.com that implement statvfs(2)-like operations,
based on a patch from miklos AT szeredi.hu (bz#1399)

also add a "df" command to the sftp client that uses the
statvfs@@openssh.com to produce a df(1)-like display of filesystem
space and inode utilisation

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.99 2008/01/20 00:38:30 djm Exp $ */
d824 1
a824 1
	struct statvfs st;
@


1.99
log
@When uploading, correctly handle the case of an unquoted filename with
glob metacharacters that match a file exactly but not as a glob, e.g. a
file called "[abcd]". report and test cases from duncan2nd AT gmx.de
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.98 2007/12/12 05:04:03 djm Exp $ */
d24 1
d36 1
d97 1
d130 1
d195 2
d419 27
d821 50
d1046 1
a1046 1
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag,
d1090 1
a1090 1
	*lflag = *pflag = *n_arg = 0;
d1142 12
d1216 1
a1216 1
	int pflag, lflag, iflag, cmdnum, i;
d1224 1
a1224 1
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &n_arg,
d1317 7
@


1.98
log
@unbreak lls command and add a regress test that would have caught the
breakage; spotted by mouring@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.97 2007/10/24 03:30:02 djm Exp $ */
a424 11
is_reg(char *path)
{
	struct stat sb;

	if (stat(path, &sb) == -1)
		fatal("stat %s: %s", path, strerror(errno));

	return(S_ISREG(sb.st_mode));
}

static int
d512 1
d521 1
a521 1
	if (glob(src, 0, NULL, &g)) {
d536 7
a542 1
		if (!is_reg(g.gl_pathv[i])) {
@


1.97
log
@rework argument splitting and parsing to cope correctly with common shell
escapes and make handling of escaped characters consistent with sh(1) and
between sftp commands (especially between ones that glob their arguments
and ones that don't).
parse command flags using getopt(3) rather than hand-rolled parsers.
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.96 2007/01/03 04:09:15 stevesk Exp $ */
d1071 2
@


1.96
log
@ARGSUSED for lint
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.95 2007/01/03 03:01:40 stevesk Exp $ */
d25 1
d338 1
a338 1
parse_getput_flags(const char **cpp, int *pflag)
d340 2
a341 1
	const char *cp = *cpp;
d343 6
a348 3
	/* Check for flags */
	if (cp[0] == '-' && cp[1] && strchr(WHITESPACE, cp[2])) {
		switch (cp[1]) {
d354 2
a355 2
			error("Invalid flag -%c", cp[1]);
			return(-1);
a356 2
		cp += 2;
		*cpp = cp + strspn(cp, WHITESPACE);
d359 1
a359 1
	return(0);
d363 1
a363 1
parse_ls_flags(const char **cpp, int *lflag)
d365 5
a369 1
	const char *cp = *cpp;
a370 1
	/* Defaults */
d372 34
a405 38

	/* Check for flags */
	if (cp++[0] == '-') {
		for (; strchr(WHITESPACE, *cp) == NULL; cp++) {
			switch (*cp) {
			case 'l':
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_LONG_VIEW;
				break;
			case '1':
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_SHORT_VIEW;
				break;
			case 'n':
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;
				break;
			case 'S':
				*lflag &= ~SORT_FLAGS;
				*lflag |= LS_SIZE_SORT;
				break;
			case 't':
				*lflag &= ~SORT_FLAGS;
				*lflag |= LS_TIME_SORT;
				break;
			case 'r':
				*lflag |= LS_REVERSE_SORT;
				break;
			case 'f':
				*lflag &= ~SORT_FLAGS;
				break;
			case 'a':
				*lflag |= LS_SHOW_ALL;
				break;
			default:
				error("Invalid flag -%c", *cp);
				return(-1);
			}
a406 1
		*cpp = cp + strspn(cp, WHITESPACE);
d409 1
a409 67
	return(0);
}

static int
get_pathname(const char **cpp, char **path)
{
	const char *cp = *cpp, *end;
	char quot;
	u_int i, j;

	cp += strspn(cp, WHITESPACE);
	if (!*cp) {
		*cpp = cp;
		*path = NULL;
		return (0);
	}

	*path = xmalloc(strlen(cp) + 1);

	/* Check for quoted filenames */
	if (*cp == '\"' || *cp == '\'') {
		quot = *cp++;

		/* Search for terminating quote, unescape some chars */
		for (i = j = 0; i <= strlen(cp); i++) {
			if (cp[i] == quot) {	/* Found quote */
				i++;
				(*path)[j] = '\0';
				break;
			}
			if (cp[i] == '\0') {	/* End of string */
				error("Unterminated quote");
				goto fail;
			}
			if (cp[i] == '\\') {	/* Escaped characters */
				i++;
				if (cp[i] != '\'' && cp[i] != '\"' &&
				    cp[i] != '\\') {
					error("Bad escaped character '\\%c'",
					    cp[i]);
					goto fail;
				}
			}
			(*path)[j++] = cp[i];
		}

		if (j == 0) {
			error("Empty quotes");
			goto fail;
		}
		*cpp = cp + i + strspn(cp + i, WHITESPACE);
	} else {
		/* Read to end of filename */
		end = strpbrk(cp, WHITESPACE);
		if (end == NULL)
			end = strchr(cp, '\0');
		*cpp = end + strspn(end, WHITESPACE);

		memcpy(*path, cp, end - cp);
		(*path)[end - cp] = '\0';
	}
	return (0);

 fail:
	xfree(*path);
	*path = NULL;
	return (-1);
d792 174
d971 1
a971 1
	char *cp2;
d974 1
a974 1
	int i, cmdnum;
d990 3
d994 2
a995 8
	for (i = 0; cmds[i].c; i++) {
		int cmdlen = strlen(cmds[i].c);

		/* Check for command followed by whitespace */
		if (!strncasecmp(cp, cmds[i].c, cmdlen) &&
		    strchr(WHITESPACE, cp[cmdlen])) {
			cp += cmdlen;
			cp = cp + strspn(cp, WHITESPACE);
a996 1
		}
d1007 1
a1007 1
		return (-1);
d1013 1
d1017 2
a1018 2
		if (parse_getput_flags(&cp, pflag))
			return(-1);
d1020 1
a1020 3
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
d1023 8
a1030 1
			return(-1);
a1031 3
		/* Try to get second pathname (optional) */
		if (get_pathname(&cp, path2))
			return(-1);
d1035 1
a1035 5
		if (get_pathname(&cp, path1))
			return(-1);
		if (get_pathname(&cp, path2))
			return(-1);
		if (!*path1 || !*path2) {
d1038 1
a1038 1
			return(-1);
d1040 5
d1053 1
a1053 3
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
d1056 1
a1056 1
			return(-1);
d1058 4
d1064 1
a1064 1
		if (parse_ls_flags(&cp, lflag))
d1067 2
a1068 2
		if (get_pathname(&cp, path1))
			return(-1);
a1074 1
		base = 8;
d1080 2
d1083 5
a1087 3
		l = strtol(cp, &cp2, base);
		if (cp2 == cp || ((l == LONG_MIN || l == LONG_MAX) &&
		    errno == ERANGE) || l < 0) {
d1090 1
a1090 1
			return(-1);
a1091 1
		cp = cp2;
d1093 1
a1093 1
		if (cmdnum == I_LUMASK && strchr(WHITESPACE, *cp))
a1094 7
		if (cmdnum == I_LUMASK || !strchr(WHITESPACE, *cp)) {
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return(-1);
		}
		cp += strspn(cp, WHITESPACE);

d1096 1
a1096 3
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
d1099 1
a1099 1
			return(-1);
d1101 1
@


1.95
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.94 2006/11/23 01:35:11 ray Exp $ */
d157 1
d169 1
@


1.94
log
@Don't access buf[strlen(buf) - 1] for zero-length strings.

``ok by me'' djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.93 2006/09/30 17:48:22 ray Exp $ */
d1531 1
a1531 1
			addargs(&args, "-l%s",userhost);
@


1.93
log
@Clear errno before calling the strtol functions.

From Paul Stoeber <x0001 at x dot de1 dot cc>.

OK deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.92 2006/09/19 05:52:23 otto Exp $ */
d289 1
a289 1
	int len = strlen(p1) + strlen(p2) + 2;
d293 1
a293 1
	if (p1[strlen(p1) - 1] != '/')
@


1.92
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
Paul Stoeber, more to come. ok millert@@ pedro@@ jaredy@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.91 2006/08/03 03:34:42 deraadt Exp $ */
d968 1
@


1.91
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.90 2006/08/01 23:22:47 stevesk Exp $ */
d484 1
a484 1
	return(sb.st_mode & S_IFDIR);
d508 1
a508 1
	return(a->perm & S_IFDIR);
@


1.91.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.93 2006/09/30 17:48:22 ray Exp $ */
d484 1
a484 1
	return(S_ISDIR(sb.st_mode));
d508 1
a508 1
	return(S_ISDIR(a->perm));
a967 1
		errno = 0;
@


1.90
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.89 2006/07/26 13:57:17 stevesk Exp $ */
d18 1
a18 2
#include "includes.h"

a19 1
#include <sys/types.h>
d34 1
d42 1
@


1.89
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.88 2006/07/26 02:35:17 stevesk Exp $ */
d33 1
@


1.88
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.87 2006/07/22 20:48:23 stevesk Exp $ */
d32 1
@


1.87
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.86 2006/07/17 01:31:09 stevesk Exp $ */
d25 1
@


1.86
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.85 2006/07/11 20:07:25 stevesk Exp $ */
d31 1
@


1.85
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.84 2006/07/10 16:01:57 stevesk Exp $ */
d31 1
@


1.84
log
@buffer.h only needed in sftp-common.h and remove some unneeded
user includes; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.83 2006/07/08 21:47:12 stevesk Exp $ */
d26 1
@


1.83
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.82 2006/05/17 12:43:34 markus Exp $ */
a30 1
#include "buffer.h"
@


1.82
log
@fix leak; coverity via Kylene Jo Hall
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.81 2006/04/20 21:53:44 djm Exp $ */
d24 1
@


1.81
log
@Switch from using pipes to socketpairs for communication between
sftp/scp and ssh, and between sshd and its subprocesses. This saves
a file descriptor per session and apparently makes userland ppp over
ssh work; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.80 2006/03/27 23:15:46 djm Exp $ */
d542 1
a566 2
	if (abs_dst)
		xfree(abs_dst);
@


1.80
log
@always use a format string for addargs; spotted by mouring@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.79 2006/03/25 13:17:02 djm Exp $ */
a1363 10
#ifdef USE_PIPES
	int pin[2], pout[2];

	if ((pipe(pin) == -1) || (pipe(pout) == -1))
		fatal("pipe: %s", strerror(errno));
	*in = pin[0];
	*out = pout[1];
	c_in = pout[0];
	c_out = pin[1];
#else /* USE_PIPES */
a1369 1
#endif /* USE_PIPES */
@


1.79
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1447 1
a1447 1
	addargs(&args, ssh_program);
@


1.78
log
@"abormally" is a perfectly cromulent word, but "abnormally" is better
@
text
@d1 1
@


1.77
log
@RCSID() can die
@
text
@d238 1
a238 1
		error("Shell exited abormally");
@


1.76
log
@more memory leaks detected by Coverity via elad AT netbsd.org;
deraadt@@ ok
@
text
@a17 1
RCSID("$OpenBSD: sftp.c,v 1.75 2006/02/20 17:19:54 stevesk Exp $");
@


1.75
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d18 1
a18 1
RCSID("$OpenBSD: sftp.c,v 1.74 2006/02/20 17:02:44 stevesk Exp $");
d1280 1
d1293 1
d1350 1
@


1.75.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sftp.c,v 1.91 2006/08/03 03:34:42 deraadt Exp $ */
d17 4
a21 1
#include <sys/ioctl.h>
a23 2
#include <sys/socket.h>
#include <sys/param.h>
a24 1
#include <errno.h>
a28 5
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
d30 1
a36 1
#include "buffer.h"
d239 1
a239 1
		error("Shell exited abnormally");
a541 1
			xfree(tmp);
d566 2
a1279 1
				xfree(conn);
a1291 1
			xfree(conn);
a1347 1
	xfree(conn);
d1361 10
d1377 1
d1444 1
a1444 1
	addargs(&args, "%s", ssh_program);
@


1.75.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.93 2006/09/30 17:48:22 ray Exp $ */
d484 1
a484 1
	return(S_ISDIR(sb.st_mode));
d508 1
a508 1
	return(S_ISDIR(a->perm));
a967 1
		errno = 0;
@


1.74
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@d18 1
a18 1
RCSID("$OpenBSD: sftp.c,v 1.73 2006/02/10 01:44:27 stevesk Exp $");
d23 1
@


1.73
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@d18 1
a18 1
RCSID("$OpenBSD: sftp.c,v 1.72 2006/02/10 00:27:13 stevesk Exp $");
d27 1
@


1.72
log
@move #include <sys/ioctl.h> out of includes.h; ok markus@@
@
text
@d18 1
a18 1
RCSID("$OpenBSD: sftp.c,v 1.71 2006/02/08 12:15:27 stevesk Exp $");
d21 2
@


1.71
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d18 1
d20 1
a20 1
RCSID("$OpenBSD: sftp.c,v 1.70 2006/01/31 10:19:02 djm Exp $");
@


1.70
log
@fix local arbitrary command execution vulnerability on local/local and
remote/remote copies (CVE-2006-0225, bz #1094), patch by
t8m AT centrum.cz, polished by dtucker@@ and myself; ok markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.69 2005/12/06 22:38:27 reyk Exp $");
d23 1
@


1.69
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.68 2005/10/31 06:15:04 dtucker Exp $");
d1436 1
d1438 1
a1438 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
d1473 1
a1549 1
		args.list[0] = ssh_program;
d1562 1
@


1.68
log
@Fix sorting with "ls -1" command. From Robert Tsai, "looks right" deraadt@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.67 2005/09/13 23:40:07 djm Exp $");
d1440 1
@


1.67
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.66 2005/08/08 13:22:48 jaredy Exp $");
d695 2
@


1.66
log
@sftp prompt enhancements:
- in non-interactive mode, do not print an empty prompt at the end
  before finishing
- print newline after EOF in editline mode
- call el_end() in editline mode

ok dtucker djm
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.65 2005/07/17 07:17:55 djm Exp $");
d1430 3
@


1.66.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.70 2006/01/31 10:19:02 djm Exp $");
a694 2
		for (n = 0; d[n] != NULL; n++)
			;	/* count entries */
a1430 4
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	memset(&args, '\0', sizeof(args));
d1432 1
a1432 1
	addargs(&args, ssh_program);
a1434 1
	addargs(&args, "-oPermitLocalCommand no");
a1465 1
			replacearg(&args, 0, "%s", ssh_program);
d1542 1
a1554 1
	freeargs(&args);
@


1.66.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sftp.c,v 1.91 2006/08/03 03:34:42 deraadt Exp $ */
d17 3
a19 6
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/param.h>
a20 1
#include <errno.h>
a22 7
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
d24 1
a30 1
#include "buffer.h"
d233 1
a233 1
		error("Shell exited abnormally");
a535 1
			xfree(tmp);
d560 2
a1273 1
				xfree(conn);
a1285 1
			xfree(conn);
a1341 1
	xfree(conn);
d1355 10
d1371 1
d1438 1
a1438 1
	addargs(&args, "%s", ssh_program);
@


1.66.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.93 2006/09/30 17:48:22 ray Exp $ */
d484 1
a484 1
	return(S_ISDIR(sb.st_mode));
d508 1
a508 1
	return(S_ISDIR(a->perm));
a967 1
		errno = 0;
@


1.65
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.64 2005/06/17 02:44:33 djm Exp $");
d1233 1
a1233 1
	int err;
d1292 1
d1302 2
a1303 1
			printf("sftp> ");
d1305 2
a1306 1
				printf("\n");
d1309 6
a1314 2
			if (batchmode) /* Echo command */
				printf("%s", cmd);
d1316 2
a1317 1
			if ((line = el_gets(el, &count)) == NULL || count <= 0)
d1319 1
d1340 3
@


1.64
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.63 2005/03/10 22:01:05 deraadt Exp $");
d1461 1
a1461 1
			   (infile = fopen(optarg, "r")) == NULL)
@


1.63
log
@spacing
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.62 2005/02/20 22:59:06 djm Exp $");
d402 1
a402 1
	int i, j;
d662 2
a663 1
	int n, c = 1, colspace = 0, columns = 1;
d670 1
a670 1
		int m = 0, width = 80;
d746 1
a746 1
	int i, c = 1, colspace = 0, columns = 1;
d782 1
a782 1
		int m = 0, width = 80;
@


1.63.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.66 2005/08/08 13:22:48 jaredy Exp $");
d402 1
a402 1
	u_int i, j;
d662 1
a662 2
	int n;
	u_int c = 1, colspace = 0, columns = 1;
d669 1
a669 1
		u_int m = 0, width = 80;
d745 1
a745 1
	u_int i, c = 1, colspace = 0, columns = 1;
d781 1
a781 1
		u_int m = 0, width = 80;
d1232 1
a1232 1
	int err, interactive;
a1290 1
	interactive = !batchmode && isatty(STDIN_FILENO);
d1300 1
a1300 2
			if (interactive)
				printf("sftp> ");
d1302 1
a1302 2
				if (interactive)
					printf("\n");
d1305 2
a1306 6
			if (!interactive) { /* Echo command */
				printf("sftp> %s", cmd);
				if (strlen(cmd) > 0 &&
				    cmd[strlen(cmd) - 1] != '\n')
					printf("\n");
			}
d1308 1
a1308 2
			if ((line = el_gets(el, &count)) == NULL || count <= 0) {
				printf("\n");
a1309 1
			}
a1330 3
	if (el != NULL)
		el_end(el);

d1460 1
a1460 1
			    (infile = fopen(optarg, "r")) == NULL)
@


1.63.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.70 2006/01/31 10:19:02 djm Exp $");
a694 2
		for (n = 0; d[n] != NULL; n++)
			;	/* count entries */
a1430 4
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	memset(&args, '\0', sizeof(args));
d1432 1
a1432 1
	addargs(&args, ssh_program);
a1434 1
	addargs(&args, "-oPermitLocalCommand no");
a1465 1
			replacearg(&args, 0, "%s", ssh_program);
d1542 1
a1554 1
	freeargs(&args);
@


1.62
log
@turn on ssh batch mode when in sftp batch mode, patch from jdmossh AT nand.net;
ok markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.61 2005/01/24 10:22:06 dtucker Exp $");
d355 1
a355 1
		for(; strchr(WHITESPACE, *cp) == NULL; cp++) {
@


1.61
log
@Have scp and sftp wait for the spawned ssh to exit before they exit
themselves.  This prevents ssh from being unable to restore terminal
modes (not normally a problem on OpenBSD but common with -Portable
on POSIX platforms).  From peak at argo.troja.mff.cuni.cz (bz#950);
ok djm@@ markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.60 2004/12/10 03:10:42 fgsch Exp $");
d1464 1
@


1.60
log
@- fix globbed ls for paths the same lenght as the globbed path when
  we have a unique matching.
- fix globbed ls in case of a directory when we have a unique matching.
- as a side effect, if the path does not exist error (used to silently ignore).
- don't do extra do_lstat() if we only have one matching file.

djm@@ ok
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.59 2004/11/29 07:41:24 djm Exp $");
d148 1
a148 1
	if (sshpid > 1)
d150 2
@


1.59
log
@Some small fixes from moritz@@jodeit.org. ok deraadt@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.58 2004/11/25 22:22:14 markus Exp $");
d744 1
a744 1
	Attrib *a;
d749 3
a751 1
	    NULL, &g)) {
d760 2
a761 2
	 * If the glob returns a single match, which is the same as the
	 * input glob, and it is a directory, then just list its contents
d763 2
a764 3
	if (g.gl_pathc == 1 &&
	    strncmp(path, g.gl_pathv[0], strlen(g.gl_pathv[0]) - 1) == 0) {
		if ((a = do_lstat(conn, path, 1)) == NULL) {
d770 3
d774 1
a774 1
			return (do_ls_dir(conn, path, strip_path, lflag));
d794 1
a794 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d811 2
a812 1
			a = do_lstat(conn, g.gl_pathv[i], 1);
@


1.58
log
@leak; from mpech
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.57 2004/11/05 12:19:56 djm Exp $");
d158 1
d162 1
d262 1
a262 1
	if (strip != NULL && strncmp(path, strip, len) == 0) {
@


1.57
log
@command editing and history support via libedit; ok markus@@
thanks to hshoexer@@ and many testers on tech@@ too
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.56 2004/07/11 17:48:47 deraadt Exp $");
d1259 3
a1261 1
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0)
d1263 1
@


1.56
log
@spaces
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.55 2004/06/25 23:21:38 djm Exp $");
d22 1
d1210 6
d1224 19
d1282 2
d1287 16
a1302 6
		printf("sftp> ");

		/* XXX: use libedit */
		if (fgets(cmd, sizeof(cmd), infile) == NULL) {
			printf("\n");
			break;
a1303 3

		if (batchmode) /* Echo command */
			printf("%s", cmd);
@


1.56.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.62 2005/02/20 22:59:06 djm Exp $");
a21 1
#include <histedit.h>
d147 1
a147 1
	if (sshpid > 1) {
a148 2
		waitpid(sshpid, NULL, 0);
	}
a156 1
	int olderrno = errno;
a159 1
	errno = olderrno;
d259 1
a259 1
	if (strncmp(path, strip, len) == 0) {
d741 1
a741 1
	Attrib *a = NULL;
d746 1
a746 3
	    NULL, &g) || (g.gl_pathc && !g.gl_matchc)) {
		if (g.gl_pathc)
			globfree(&g);
d755 2
a756 2
	 * If the glob returns a single match and it is a directory,
	 * then just list its contents.
d758 3
a760 2
	if (g.gl_matchc == 1) {
		if ((a = do_lstat(conn, g.gl_pathv[0], 1)) == NULL) {
a765 3
			int err;

			err = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);
d767 1
a767 1
			return (err);
d787 1
a787 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++, a = NULL) {
d804 1
a804 2
			if (a == NULL)
				a = do_lstat(conn, g.gl_pathv[i], 1);
a1208 6
static char *
prompt(EditLine *el)
{
	return ("sftp> ");
}

a1216 19
	EditLine *el = NULL;
	History *hl = NULL;
	HistEvent hev;
	extern char *__progname;

	if (!batchmode && isatty(STDIN_FILENO)) {
		if ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)
			fatal("Couldn't initialise editline");
		if ((hl = history_init()) == NULL)
			fatal("Couldn't initialise editline history");
		history(hl, &hev, H_SETSIZE, 100);
		el_set(el, EL_HIST, history, hl);

		el_set(el, EL_PROMPT, prompt);
		el_set(el, EL_EDITOR, "emacs");
		el_set(el, EL_TERMINAL, NULL);
		el_set(el, EL_SIGNAL, 1);
		el_source(el, NULL);
	}
d1233 1
a1233 3
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0) {
				xfree(dir);
				xfree(pwd);
a1234 1
			}
a1255 2
		const char *line;
		int count = 0;
d1259 6
a1264 16
		if (el == NULL) {
			printf("sftp> ");
			if (fgets(cmd, sizeof(cmd), infile) == NULL) {
				printf("\n");
				break;
			}
			if (batchmode) /* Echo command */
				printf("%s", cmd);
		} else {
			if ((line = el_gets(el, &count)) == NULL || count <= 0)
				break;
			history(hl, &hev, H_ENTER, line);
			if (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {
				fprintf(stderr, "Error: input line too long\n");
				continue;
			}
d1267 3
a1416 1
			addargs(&args, "-obatchmode yes");
@


1.56.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.63 2005/03/10 22:01:05 deraadt Exp $");
d355 1
a355 1
		for (; strchr(WHITESPACE, *cp) == NULL; cp++) {
@


1.56.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.66 2005/08/08 13:22:48 jaredy Exp $");
d402 1
a402 1
	u_int i, j;
d662 1
a662 2
	int n;
	u_int c = 1, colspace = 0, columns = 1;
d669 1
a669 1
		u_int m = 0, width = 80;
d745 1
a745 1
	u_int i, c = 1, colspace = 0, columns = 1;
d781 1
a781 1
		u_int m = 0, width = 80;
d1232 1
a1232 1
	int err, interactive;
a1290 1
	interactive = !batchmode && isatty(STDIN_FILENO);
d1300 1
a1300 2
			if (interactive)
				printf("sftp> ");
d1302 1
a1302 2
				if (interactive)
					printf("\n");
d1305 2
a1306 6
			if (!interactive) { /* Echo command */
				printf("sftp> %s", cmd);
				if (strlen(cmd) > 0 &&
				    cmd[strlen(cmd) - 1] != '\n')
					printf("\n");
			}
d1308 1
a1308 2
			if ((line = el_gets(el, &count)) == NULL || count <= 0) {
				printf("\n");
a1309 1
			}
a1330 3
	if (el != NULL)
		el_end(el);

d1460 1
a1460 1
			    (infile = fopen(optarg, "r")) == NULL)
@


1.55
log
@bz #875: fix bad escape char error message; reported by f_mohr AT yahoo.de
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.54 2004/06/22 01:16:39 djm Exp $");
d1326 2
a1327 2
		 * ignore SIGINT if we want to gracefully abort commands, 
		 * otherwise the signal will make it to the ssh process and 
d1412 1
a1412 1
			if (strcmp(optarg, "-") != 0 && 
@


1.54
log
@don't show .files by default in ls, add -a option to turn them back on;
ok markus
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.53 2004/06/21 22:30:45 djm Exp $");
d427 1
a427 1
					error("Bad escaped character '\%c'",
@


1.53
log
@prefix ls option flags with LS_
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.52 2004/06/21 22:04:50 djm Exp $");
d71 1
d378 3
d669 4
a672 2
		for (n = 0; d[n] != NULL; n++)
			m = MAX(m, strlen(d[n]->filename));
d695 3
@


1.52
log
@introduce sorting for ls, same options as /bin/ls; ok markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.51 2004/06/21 17:36:31 avsm Exp $");
d64 7
a70 7
#define LONG_VIEW	0x01	/* Full view ala ls -l */
#define SHORT_VIEW	0x02	/* Single row view ala ls -1 */
#define NUMERIC_VIEW	0x04	/* Long view with numeric uid/gid */
#define NAME_SORT	0x08	/* Sort by name (default) */
#define TIME_SORT	0x10	/* Sort by mtime */
#define SIZE_SORT	0x20	/* Sort by file size */
#define REVERSE_SORT	0x40	/* Reverse sort order */
d72 2
a73 2
#define VIEW_FLAGS	(LONG_VIEW|SHORT_VIEW|NUMERIC_VIEW)
#define SORT_FLAGS	(NAME_SORT|TIME_SORT|SIZE_SORT)
d345 1
a345 1
	*lflag = NAME_SORT;
d353 1
a353 1
				*lflag |= LONG_VIEW;
d357 1
a357 1
				*lflag |= SHORT_VIEW;
d361 1
a361 1
				*lflag |= NUMERIC_VIEW|LONG_VIEW;
d365 1
a365 1
				*lflag |= SIZE_SORT;
d369 1
a369 1
				*lflag |= TIME_SORT;
d372 1
a372 1
				*lflag |= REVERSE_SORT;
d636 1
a636 1
	int rmul = sort_flag & REVERSE_SORT ? -1 : 1;
d639 1
a639 1
	if (sort_flag & NAME_SORT)
d641 1
a641 1
	else if (sort_flag & TIME_SORT)
d643 1
a643 1
	else if (sort_flag & SIZE_SORT)
d659 1
a659 1
	if (!(lflag & SHORT_VIEW)) {
d683 1
a683 1
		sort_flag = lflag & (SORT_FLAGS|REVERSE_SORT);
d694 2
a695 2
		if (lflag & LONG_VIEW) {
			if (lflag & NUMERIC_VIEW) {
d718 1
a718 1
	if (!(lflag & LONG_VIEW) && (c != 1))
d762 1
a762 1
	if (!(lflag & SHORT_VIEW)) {
d783 1
a783 1
		if (lflag & LONG_VIEW) {
d812 1
a812 1
	if (!(lflag & LONG_VIEW) && (c != 1))
@


1.51
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.50 2004/06/20 18:53:39 djm Exp $");
d54 3
d63 9
a71 4
/* Define what type of ls view */
#define LONG_VIEW	1	/* Full view ala ls -l */
#define SHORT_VIEW	2	/* Single row view ala ls -1 */
#define NUMERIC_VIEW	4	/* Long view with numeric uid/gid */
d73 1
d344 3
d363 14
d636 1
d638 9
a646 1
	return (strcmp(a->filename, b->filename));
d682 4
a685 1
	qsort(d, n, sizeof(*d), sdirent_comp);
@


1.50
log
@make "ls -l" listings print user/group names, add "ls -n" to show uid/gid
(like /bin/ls); idea & ok markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.49 2004/06/18 06:13:25 dtucker Exp $");
d276 1
a276 1
	char *abs;
d280 1
a280 1
		abs = path_append(pwd, p);
d282 1
a282 1
		return(abs);
@


1.49
log
@Use execvp instead of execv so sftp -S ssh works.  "makes sense" markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.48 2004/06/03 12:22:20 pedro Exp $");
d60 5
a64 3
/* Define what type of ls view (0 - multi-column) */
#define LONG_VIEW 1		/* Full view ala ls -l */
#define SHORT_VIEW 2		/* Single row view ala ls -1 */
d340 2
a341 1
				*lflag = LONG_VIEW;
d344 6
a349 1
				*lflag = SHORT_VIEW;
d657 11
a667 8
			char *lname;
			struct stat sb;

			memset(&sb, 0, sizeof(sb));
			attrib_to_stat(&d[n]->a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
@


1.48
log
@initialize pointers, ok markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.47 2004/05/26 08:59:57 djm Exp $");
d1273 1
a1273 1
		execv(path, args);
@


1.47
log
@exit -> _exit in forked child on error; from andrushock AT korovino.net
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.46 2004/05/19 12:17:33 djm Exp $");
d1304 1
a1304 1
	char *host, *userhost, *cp, *file2;
@


1.46
log
@gracefully abort transfers on receipt of SIGINT, also ignore SIGINT while
waiting for a command; ok markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.45 2004/03/03 09:31:20 djm Exp $");
d1259 1
a1259 1
			exit(1);
d1275 1
a1275 1
		exit(1);
@


1.45
log
@Fix initialisation of progress meter; ok markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.44 2004/02/17 11:03:08 djm Exp $");
d51 3
d133 18
d485 1
a485 1
	for (i = 0; g.gl_pathv[i]; i++) {
d554 1
a554 1
	for (i = 0; g.gl_pathv[i]; i++) {
d641 1
a641 1
	for (n = 0; d[n] != NULL; n++) {
d693 3
d729 1
a729 1
	for (i = 0; g.gl_pathv[i]; i++) {
d766 1
d976 1
a976 1
		for (i = 0; g.gl_pathv[i]; i++) {
d1065 1
a1065 1
		for (i = 0; g.gl_pathv[i]; i++) {
d1076 1
a1076 1
		for (i = 0; g.gl_pathv[i]; i++) {
d1199 2
d1216 4
a1230 9
killchild(int signo)
{
	if (sshpid > 1)
		kill(sshpid, signo);

	_exit(1);
}

static void
d1265 8
@


1.45.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.56 2004/07/11 17:48:47 deraadt Exp $");
a50 6
/* SIGINT received during command processing */
volatile sig_atomic_t interrupted = 0;

/* I wish qsort() took a separate ctx for the comparison function...*/
int sort_flag;

d57 3
a59 12
/* ls flags */
#define LS_LONG_VIEW	0x01	/* Full view ala ls -l */
#define LS_SHORT_VIEW	0x02	/* Single row view ala ls -1 */
#define LS_NUMERIC_VIEW	0x04	/* Long view with numeric uid/gid */
#define LS_NAME_SORT	0x08	/* Sort by name (default) */
#define LS_TIME_SORT	0x10	/* Sort by mtime */
#define LS_SIZE_SORT	0x20	/* Sort by file size */
#define LS_REVERSE_SORT	0x40	/* Reverse sort order */
#define LS_SHOW_ALL	0x80	/* Don't skip filenames starting with '.' */

#define VIEW_FLAGS	(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW)
#define SORT_FLAGS	(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)
a129 18
killchild(int signo)
{
	if (sshpid > 1)
		kill(sshpid, SIGTERM);

	_exit(1);
}

static void
cmd_interrupt(int signo)
{
	const char msg[] = "\rInterrupt  \n";

	write(STDERR_FILENO, msg, sizeof(msg) - 1);
	interrupted = 1;
}

static void
d253 1
a253 1
	char *abs_str;
d257 1
a257 1
		abs_str = path_append(pwd, p);
d259 1
a259 1
		return(abs_str);
a311 3
	/* Defaults */
	*lflag = LS_NAME_SORT;

d317 1
a317 2
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_LONG_VIEW;
d320 1
a320 23
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_SHORT_VIEW;
				break;
			case 'n':
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;
				break;
			case 'S':
				*lflag &= ~SORT_FLAGS;
				*lflag |= LS_SIZE_SORT;
				break;
			case 't':
				*lflag &= ~SORT_FLAGS;
				*lflag |= LS_TIME_SORT;
				break;
			case 'r':
				*lflag |= LS_REVERSE_SORT;
				break;
			case 'f':
				*lflag &= ~SORT_FLAGS;
				break;
			case 'a':
				*lflag |= LS_SHOW_ALL;
d368 1
a368 1
					error("Bad escaped character '\\%c'",
d464 1
a464 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d533 1
a533 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
a580 9
	int rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;

#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))
	if (sort_flag & LS_NAME_SORT)
		return (rmul * strcmp(a->filename, b->filename));
	else if (sort_flag & LS_TIME_SORT)
		return (rmul * NCMP(a->a.mtime, b->a.mtime));
	else if (sort_flag & LS_SIZE_SORT)
		return (rmul * NCMP(a->a.size, b->a.size));
d582 1
a582 1
	fatal("Unknown ls sort type");
d595 1
a595 1
	if (!(lflag & LS_SHORT_VIEW)) {
d601 2
a602 4
		for (n = 0; d[n] != NULL; n++) {
			if (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))
				m = MAX(m, strlen(d[n]->filename));
		}
d618 1
a618 4
	if (lflag & SORT_FLAGS) {
		sort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);
		qsort(d, n, sizeof(*d), sdirent_comp);
	}
d620 1
a620 1
	for (n = 0; d[n] != NULL && !interrupted; n++) {
a622 3
		if (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))
			continue;

d627 9
a635 12
		if (lflag & LS_LONG_VIEW) {
			if (lflag & LS_NUMERIC_VIEW) {
				char *lname;
				struct stat sb;

				memset(&sb, 0, sizeof(sb));
				attrib_to_stat(&d[n]->a, &sb);
				lname = ls_file(fname, &sb, 1);
				printf("%s\n", lname);
				xfree(lname);
			} else
				printf("%s\n", d[n]->longname);
d648 1
a648 1
	if (!(lflag & LS_LONG_VIEW) && (c != 1))
a671 3
	if (interrupted)
		goto out;

d689 1
a689 1
	if (!(lflag & LS_SHORT_VIEW)) {
d705 1
a705 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d710 1
a710 1
		if (lflag & LS_LONG_VIEW) {
d739 1
a739 1
	if (!(lflag & LS_LONG_VIEW) && (c != 1))
a741 1
 out:
d951 1
a951 1
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d1040 1
a1040 1
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d1051 1
a1051 1
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
a1173 2
		signal(SIGINT, SIG_IGN);

a1188 4
		/* Handle user interrupts gracefully during commands */
		interrupted = 0;
		signal(SIGINT, cmd_interrupt);

d1200 9
d1237 1
a1237 1
			_exit(1);
d1243 1
a1243 9

		/*
		 * The underlying ssh is in the same process group, so we must
		 * ignore SIGINT if we want to gracefully abort commands,
		 * otherwise the signal will make it to the ssh process and
		 * kill it too
		 */
		signal(SIGINT, SIG_IGN);
		execvp(path, args);
d1245 1
a1245 1
		_exit(1);
d1274 1
a1274 1
	char *host, *userhost, *cp, *file2 = NULL;
d1324 1
a1324 1
			if (strcmp(optarg, "-") != 0 &&
@


1.45.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.62 2005/02/20 22:59:06 djm Exp $");
a21 1
#include <histedit.h>
d147 1
a147 1
	if (sshpid > 1) {
a148 2
		waitpid(sshpid, NULL, 0);
	}
a156 1
	int olderrno = errno;
a159 1
	errno = olderrno;
d259 1
a259 1
	if (strncmp(path, strip, len) == 0) {
d741 1
a741 1
	Attrib *a = NULL;
d746 1
a746 3
	    NULL, &g) || (g.gl_pathc && !g.gl_matchc)) {
		if (g.gl_pathc)
			globfree(&g);
d755 2
a756 2
	 * If the glob returns a single match and it is a directory,
	 * then just list its contents.
d758 3
a760 2
	if (g.gl_matchc == 1) {
		if ((a = do_lstat(conn, g.gl_pathv[0], 1)) == NULL) {
a765 3
			int err;

			err = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);
d767 1
a767 1
			return (err);
d787 1
a787 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++, a = NULL) {
d804 1
a804 2
			if (a == NULL)
				a = do_lstat(conn, g.gl_pathv[i], 1);
a1208 6
static char *
prompt(EditLine *el)
{
	return ("sftp> ");
}

a1216 19
	EditLine *el = NULL;
	History *hl = NULL;
	HistEvent hev;
	extern char *__progname;

	if (!batchmode && isatty(STDIN_FILENO)) {
		if ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)
			fatal("Couldn't initialise editline");
		if ((hl = history_init()) == NULL)
			fatal("Couldn't initialise editline history");
		history(hl, &hev, H_SETSIZE, 100);
		el_set(el, EL_HIST, history, hl);

		el_set(el, EL_PROMPT, prompt);
		el_set(el, EL_EDITOR, "emacs");
		el_set(el, EL_TERMINAL, NULL);
		el_set(el, EL_SIGNAL, 1);
		el_source(el, NULL);
	}
d1233 1
a1233 3
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0) {
				xfree(dir);
				xfree(pwd);
a1234 1
			}
a1255 2
		const char *line;
		int count = 0;
d1259 6
a1264 16
		if (el == NULL) {
			printf("sftp> ");
			if (fgets(cmd, sizeof(cmd), infile) == NULL) {
				printf("\n");
				break;
			}
			if (batchmode) /* Echo command */
				printf("%s", cmd);
		} else {
			if ((line = el_gets(el, &count)) == NULL || count <= 0)
				break;
			history(hl, &hev, H_ENTER, line);
			if (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {
				fprintf(stderr, "Error: input line too long\n");
				continue;
			}
d1267 3
a1416 1
			addargs(&args, "-obatchmode yes");
@


1.44
log
@sftp.c and sftp-int.c, together at last; ok markus@@
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.43 2004/02/17 07:17:29 djm Exp $");
d49 1
a49 1
int showprogress;
d1349 3
@


1.43
log
@Remove useless headers; ok deraadt@@
@
text
@d19 3
a21 1
RCSID("$OpenBSD: sftp.c,v 1.42 2004/02/17 05:39:51 djm Exp $");
d33 2
a34 1
int interactive_loop(int, int, char *, char *); /* sftp-int.c */
d36 1
a36 1
FILE* infile;
d38 2
d41 2
d44 2
d48 1150
a1197 1
extern int showprogress;
@


1.42
log
@switch to license.template for code written by me (belated, I know...)
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.41 2004/01/27 10:08:10 djm Exp $");
d30 2
a31 1
#include "sftp-int.h"
@


1.41
log
@reorder parsing so user:skey@@host:file works (bugzilla #777)
patch from admorten AT umich.edu; ok markus@@
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d4 3
a6 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d8 7
a14 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.40 2004/01/21 03:07:59 djm Exp $");
@


1.40
log
@initialise infile in main, rather than statically - from portable
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.39 2004/01/13 09:25:05 djm Exp $");
a207 5
		if ((cp = colon(userhost)) != NULL) {
			*cp++ = '\0';
			file1 = cp;
		}

d217 5
@


1.39
log
@Tidy sftp batchmode handling, eliminate junk to stderr (bugzilla #754) and
enable use of "-b -" to accept batchfile from stdin; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.38 2003/10/08 08:27:36 jmc Exp $");
d40 1
a40 1
FILE* infile = stdin;
d137 1
d139 1
@


1.38
log
@scp and sftp: add options list and sort options. options list requested
by deraadt@@
sshd: use same format as ssh
ssh: remove wrong option from list
sftp-server: Subsystem is documented in ssh_config(5), not sshd(8)

ok deraadt@@ markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.37 2003/07/10 20:05:55 markus Exp $");
d40 2
a41 1
FILE* infile;
a137 1
	infile = stdin;		/* Read from STDIN unless changed by -b */
d167 7
a173 6
			if (infile == stdin) {
				infile = fopen(optarg, "r");
				if (infile == NULL)
					fatal("%s (%s).", strerror(errno), optarg);
			} else
				fatal("Filename already specified.");
d175 1
d239 2
a240 1
		fprintf(stderr, "Connecting to %s...\n", host);
d246 2
a247 1
		fprintf(stderr, "Attaching to %s...\n", sftp_direct);
d255 1
a255 1
	if (infile != stdin)
@


1.37
log
@sync usage with manpage, add missing -R
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.36 2003/06/04 12:41:22 djm Exp $");
d109 6
a114 4
	    "usage: %s [-vC1] [-b batchfile] [-o ssh_option] [-s subsystem | sftp_server]\n"
	    "            [-B buffer_size] [-F ssh_config] [-P sftp_server path]\n"
	    "            [-R num_requests] [-S program]\n"
	    "            [user@@]host[:file [file]]\n", __progname);
@


1.37.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2004 Damien Miller <djm@@openbsd.org>
d4 8
a11 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d13 10
a22 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d27 1
a27 3
RCSID("$OpenBSD: sftp.c,v 1.44 2004/02/17 11:03:08 djm Exp $");

#include <glob.h>
d38 1
a39 1
/* File to read commands from */
a40 5

/* Are we in batchfile mode? */
int batchmode = 0;

/* Size of buffer used when copying files */
a41 2

/* Number of concurrent outstanding requests */
a42 2

/* PID of ssh transport process */
d45 1
a45 1150
/* This is set to 0 if the progressmeter is not desired. */
int showprogress;

int remote_glob(struct sftp_conn *, const char *, int,
    int (*)(const char *, int), glob_t *); /* proto for sftp-glob.c */

/* Separators for interactive commands */
#define WHITESPACE " \t\r\n"

/* Define what type of ls view (0 - multi-column) */
#define LONG_VIEW 1		/* Full view ala ls -l */
#define SHORT_VIEW 2		/* Single row view ala ls -1 */

/* Commands for interactive mode */
#define I_CHDIR		1
#define I_CHGRP		2
#define I_CHMOD		3
#define I_CHOWN		4
#define I_GET		5
#define I_HELP		6
#define I_LCHDIR	7
#define I_LLS		8
#define I_LMKDIR	9
#define I_LPWD		10
#define I_LS		11
#define I_LUMASK	12
#define I_MKDIR		13
#define I_PUT		14
#define I_PWD		15
#define I_QUIT		16
#define I_RENAME	17
#define I_RM		18
#define I_RMDIR		19
#define I_SHELL		20
#define I_SYMLINK	21
#define I_VERSION	22
#define I_PROGRESS	23

struct CMD {
	const char *c;
	const int n;
};

static const struct CMD cmds[] = {
	{ "bye",	I_QUIT },
	{ "cd",		I_CHDIR },
	{ "chdir",	I_CHDIR },
	{ "chgrp",	I_CHGRP },
	{ "chmod",	I_CHMOD },
	{ "chown",	I_CHOWN },
	{ "dir",	I_LS },
	{ "exit",	I_QUIT },
	{ "get",	I_GET },
	{ "mget",	I_GET },
	{ "help",	I_HELP },
	{ "lcd",	I_LCHDIR },
	{ "lchdir",	I_LCHDIR },
	{ "lls",	I_LLS },
	{ "lmkdir",	I_LMKDIR },
	{ "ln",		I_SYMLINK },
	{ "lpwd",	I_LPWD },
	{ "ls",		I_LS },
	{ "lumask",	I_LUMASK },
	{ "mkdir",	I_MKDIR },
	{ "progress",	I_PROGRESS },
	{ "put",	I_PUT },
	{ "mput",	I_PUT },
	{ "pwd",	I_PWD },
	{ "quit",	I_QUIT },
	{ "rename",	I_RENAME },
	{ "rm",		I_RM },
	{ "rmdir",	I_RMDIR },
	{ "symlink",	I_SYMLINK },
	{ "version",	I_VERSION },
	{ "!",		I_SHELL },
	{ "?",		I_HELP },
	{ NULL,			-1}
};

int interactive_loop(int fd_in, int fd_out, char *file1, char *file2);

static void
help(void)
{
	printf("Available commands:\n");
	printf("cd path                       Change remote directory to 'path'\n");
	printf("lcd path                      Change local directory to 'path'\n");
	printf("chgrp grp path                Change group of file 'path' to 'grp'\n");
	printf("chmod mode path               Change permissions of file 'path' to 'mode'\n");
	printf("chown own path                Change owner of file 'path' to 'own'\n");
	printf("help                          Display this help text\n");
	printf("get remote-path [local-path]  Download file\n");
	printf("lls [ls-options [path]]       Display local directory listing\n");
	printf("ln oldpath newpath            Symlink remote file\n");
	printf("lmkdir path                   Create local directory\n");
	printf("lpwd                          Print local working directory\n");
	printf("ls [path]                     Display remote directory listing\n");
	printf("lumask umask                  Set local umask to 'umask'\n");
	printf("mkdir path                    Create remote directory\n");
	printf("progress                      Toggle display of progress meter\n");
	printf("put local-path [remote-path]  Upload file\n");
	printf("pwd                           Display remote working directory\n");
	printf("exit                          Quit sftp\n");
	printf("quit                          Quit sftp\n");
	printf("rename oldpath newpath        Rename remote file\n");
	printf("rmdir path                    Remove remote directory\n");
	printf("rm path                       Delete remote file\n");
	printf("symlink oldpath newpath       Symlink remote file\n");
	printf("version                       Show SFTP version\n");
	printf("!command                      Execute 'command' in local shell\n");
	printf("!                             Escape to local shell\n");
	printf("?                             Synonym for help\n");
}

static void
local_do_shell(const char *args)
{
	int status;
	char *shell;
	pid_t pid;

	if (!*args)
		args = NULL;

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	if ((pid = fork()) == -1)
		fatal("Couldn't fork: %s", strerror(errno));

	if (pid == 0) {
		/* XXX: child has pipe fds to ssh subproc open - issue? */
		if (args) {
			debug3("Executing %s -c \"%s\"", shell, args);
			execl(shell, shell, "-c", args, (char *)NULL);
		} else {
			debug3("Executing %s", shell);
			execl(shell, shell, (char *)NULL);
		}
		fprintf(stderr, "Couldn't execute \"%s\": %s\n", shell,
		    strerror(errno));
		_exit(1);
	}
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));
	if (!WIFEXITED(status))
		error("Shell exited abormally");
	else if (WEXITSTATUS(status))
		error("Shell exited with status %d", WEXITSTATUS(status));
}

static void
local_do_ls(const char *args)
{
	if (!args || !*args)
		local_do_shell(_PATH_LS);
	else {
		int len = strlen(_PATH_LS " ") + strlen(args) + 1;
		char *buf = xmalloc(len);

		/* XXX: quoting - rip quoting code from ftp? */
		snprintf(buf, len, _PATH_LS " %s", args);
		local_do_shell(buf);
		xfree(buf);
	}
}

/* Strip one path (usually the pwd) from the start of another */
static char *
path_strip(char *path, char *strip)
{
	size_t len;

	if (strip == NULL)
		return (xstrdup(path));

	len = strlen(strip);
	if (strip != NULL && strncmp(path, strip, len) == 0) {
		if (strip[len - 1] != '/' && path[len] == '/')
			len++;
		return (xstrdup(path + len));
	}

	return (xstrdup(path));
}

static char *
path_append(char *p1, char *p2)
{
	char *ret;
	int len = strlen(p1) + strlen(p2) + 2;

	ret = xmalloc(len);
	strlcpy(ret, p1, len);
	if (p1[strlen(p1) - 1] != '/')
		strlcat(ret, "/", len);
	strlcat(ret, p2, len);

	return(ret);
}

static char *
make_absolute(char *p, char *pwd)
{
	char *abs;

	/* Derelativise */
	if (p && p[0] != '/') {
		abs = path_append(pwd, p);
		xfree(p);
		return(abs);
	} else
		return(p);
}

static int
infer_path(const char *p, char **ifp)
{
	char *cp;

	cp = strrchr(p, '/');
	if (cp == NULL) {
		*ifp = xstrdup(p);
		return(0);
	}

	if (!cp[1]) {
		error("Invalid path");
		return(-1);
	}

	*ifp = xstrdup(cp + 1);
	return(0);
}

static int
parse_getput_flags(const char **cpp, int *pflag)
{
	const char *cp = *cpp;

	/* Check for flags */
	if (cp[0] == '-' && cp[1] && strchr(WHITESPACE, cp[2])) {
		switch (cp[1]) {
		case 'p':
		case 'P':
			*pflag = 1;
			break;
		default:
			error("Invalid flag -%c", cp[1]);
			return(-1);
		}
		cp += 2;
		*cpp = cp + strspn(cp, WHITESPACE);
	}

	return(0);
}

static int
parse_ls_flags(const char **cpp, int *lflag)
{
	const char *cp = *cpp;

	/* Check for flags */
	if (cp++[0] == '-') {
		for(; strchr(WHITESPACE, *cp) == NULL; cp++) {
			switch (*cp) {
			case 'l':
				*lflag = LONG_VIEW;
				break;
			case '1':
				*lflag = SHORT_VIEW;
				break;
			default:
				error("Invalid flag -%c", *cp);
				return(-1);
			}
		}
		*cpp = cp + strspn(cp, WHITESPACE);
	}

	return(0);
}

static int
get_pathname(const char **cpp, char **path)
{
	const char *cp = *cpp, *end;
	char quot;
	int i, j;

	cp += strspn(cp, WHITESPACE);
	if (!*cp) {
		*cpp = cp;
		*path = NULL;
		return (0);
	}

	*path = xmalloc(strlen(cp) + 1);

	/* Check for quoted filenames */
	if (*cp == '\"' || *cp == '\'') {
		quot = *cp++;

		/* Search for terminating quote, unescape some chars */
		for (i = j = 0; i <= strlen(cp); i++) {
			if (cp[i] == quot) {	/* Found quote */
				i++;
				(*path)[j] = '\0';
				break;
			}
			if (cp[i] == '\0') {	/* End of string */
				error("Unterminated quote");
				goto fail;
			}
			if (cp[i] == '\\') {	/* Escaped characters */
				i++;
				if (cp[i] != '\'' && cp[i] != '\"' &&
				    cp[i] != '\\') {
					error("Bad escaped character '\%c'",
					    cp[i]);
					goto fail;
				}
			}
			(*path)[j++] = cp[i];
		}

		if (j == 0) {
			error("Empty quotes");
			goto fail;
		}
		*cpp = cp + i + strspn(cp + i, WHITESPACE);
	} else {
		/* Read to end of filename */
		end = strpbrk(cp, WHITESPACE);
		if (end == NULL)
			end = strchr(cp, '\0');
		*cpp = end + strspn(end, WHITESPACE);

		memcpy(*path, cp, end - cp);
		(*path)[end - cp] = '\0';
	}
	return (0);

 fail:
	xfree(*path);
	*path = NULL;
	return (-1);
}

static int
is_dir(char *path)
{
	struct stat sb;

	/* XXX: report errors? */
	if (stat(path, &sb) == -1)
		return(0);

	return(sb.st_mode & S_IFDIR);
}

static int
is_reg(char *path)
{
	struct stat sb;

	if (stat(path, &sb) == -1)
		fatal("stat %s: %s", path, strerror(errno));

	return(S_ISREG(sb.st_mode));
}

static int
remote_is_dir(struct sftp_conn *conn, char *path)
{
	Attrib *a;

	/* XXX: report errors? */
	if ((a = do_stat(conn, path, 1)) == NULL)
		return(0);
	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
		return(0);
	return(a->perm & S_IFDIR);
}

static int
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
{
	char *abs_src = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	abs_src = xstrdup(src);
	abs_src = make_absolute(abs_src, pwd);

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", abs_src);
	if (remote_glob(conn, abs_src, 0, NULL, &g)) {
		error("File \"%s\" not found.", abs_src);
		err = -1;
		goto out;
	}

	/* If multiple matches, dst must be a directory or unspecified */
	if (g.gl_matchc > 1 && dst && !is_dir(dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && dst) {
			/* If directory specified, append filename */
			if (is_dir(dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(dst);
		} else if (dst) {
			abs_dst = path_append(dst, tmp);
			xfree(tmp);
		} else
			abs_dst = tmp;

		printf("Fetching %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_download(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
		xfree(abs_dst);
		abs_dst = NULL;
	}

out:
	xfree(abs_src);
	if (abs_dst)
		xfree(abs_dst);
	globfree(&g);
	return(err);
}

static int
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
{
	char *tmp_dst = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	if (dst) {
		tmp_dst = xstrdup(dst);
		tmp_dst = make_absolute(tmp_dst, pwd);
	}

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", src);
	if (glob(src, 0, NULL, &g)) {
		error("File \"%s\" not found.", src);
		err = -1;
		goto out;
	}

	/* If multiple matches, dst may be directory or unspecified */
	if (g.gl_matchc > 1 && tmp_dst && !remote_is_dir(conn, tmp_dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    tmp_dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		if (!is_reg(g.gl_pathv[i])) {
			error("skipping non-regular file %s",
			    g.gl_pathv[i]);
			continue;
		}
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && tmp_dst) {
			/* If directory specified, append filename */
			if (remote_is_dir(conn, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(tmp_dst);

		} else if (tmp_dst) {
			abs_dst = path_append(tmp_dst, tmp);
			xfree(tmp);
		} else
			abs_dst = make_absolute(tmp, pwd);

		printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_upload(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
	}

out:
	if (abs_dst)
		xfree(abs_dst);
	if (tmp_dst)
		xfree(tmp_dst);
	globfree(&g);
	return(err);
}

static int
sdirent_comp(const void *aa, const void *bb)
{
	SFTP_DIRENT *a = *(SFTP_DIRENT **)aa;
	SFTP_DIRENT *b = *(SFTP_DIRENT **)bb;

	return (strcmp(a->filename, b->filename));
}

/* sftp ls.1 replacement for directories */
static int
do_ls_dir(struct sftp_conn *conn, char *path, char *strip_path, int lflag)
{
	int n, c = 1, colspace = 0, columns = 1;
	SFTP_DIRENT **d;

	if ((n = do_readdir(conn, path, &d)) != 0)
		return (n);

	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;
		char *tmp;

		/* Count entries for sort and find longest filename */
		for (n = 0; d[n] != NULL; n++)
			m = MAX(m, strlen(d[n]->filename));

		/* Add any subpath that also needs to be counted */
		tmp = path_strip(path, strip_path);
		m += strlen(tmp);
		xfree(tmp);

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
		colspace = MIN(colspace, width);
	}

	qsort(d, n, sizeof(*d), sdirent_comp);

	for (n = 0; d[n] != NULL; n++) {
		char *tmp, *fname;

		tmp = path_append(path, d[n]->filename);
		fname = path_strip(tmp, strip_path);
		xfree(tmp);

		if (lflag & LONG_VIEW) {
			char *lname;
			struct stat sb;

			memset(&sb, 0, sizeof(sb));
			attrib_to_stat(&d[n]->a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}

		xfree(fname);
	}

	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");

	free_sftp_dirents(d);
	return (0);
}

/* sftp ls.1 replacement which handles path globs */
static int
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path,
    int lflag)
{
	glob_t g;
	int i, c = 1, colspace = 0, columns = 1;
	Attrib *a;

	memset(&g, 0, sizeof(g));

	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE,
	    NULL, &g)) {
		error("Can't ls: \"%s\" not found", path);
		return (-1);
	}

	/*
	 * If the glob returns a single match, which is the same as the
	 * input glob, and it is a directory, then just list its contents
	 */
	if (g.gl_pathc == 1 &&
	    strncmp(path, g.gl_pathv[0], strlen(g.gl_pathv[0]) - 1) == 0) {
		if ((a = do_lstat(conn, path, 1)) == NULL) {
			globfree(&g);
			return (-1);
		}
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
		    S_ISDIR(a->perm)) {
			globfree(&g);
			return (do_ls_dir(conn, path, strip_path, lflag));
		}
	}

	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;

		/* Count entries for sort and find longest filename */
		for (i = 0; g.gl_pathv[i]; i++)
			m = MAX(m, strlen(g.gl_pathv[i]));

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		char *fname;

		fname = path_strip(g.gl_pathv[i], strip_path);

		if (lflag & LONG_VIEW) {
			char *lname;
			struct stat sb;

			/*
			 * XXX: this is slow - 1 roundtrip per path
			 * A solution to this is to fork glob() and
			 * build a sftp specific version which keeps the
			 * attribs (which currently get thrown away)
			 * that the server returns as well as the filenames.
			 */
			memset(&sb, 0, sizeof(sb));
			a = do_lstat(conn, g.gl_pathv[i], 1);
			if (a != NULL)
				attrib_to_stat(a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}
		xfree(fname);
	}

	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");

	if (g.gl_pathc)
		globfree(&g);

	return (0);
}

static int
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag,
    unsigned long *n_arg, char **path1, char **path2)
{
	const char *cmd, *cp = *cpp;
	char *cp2;
	int base = 0;
	long l;
	int i, cmdnum;

	/* Skip leading whitespace */
	cp = cp + strspn(cp, WHITESPACE);

	/* Ignore blank lines and lines which begin with comment '#' char */
	if (*cp == '\0' || *cp == '#')
		return (0);

	/* Check for leading '-' (disable error processing) */
	*iflag = 0;
	if (*cp == '-') {
		*iflag = 1;
		cp++;
	}

	/* Figure out which command we have */
	for (i = 0; cmds[i].c; i++) {
		int cmdlen = strlen(cmds[i].c);

		/* Check for command followed by whitespace */
		if (!strncasecmp(cp, cmds[i].c, cmdlen) &&
		    strchr(WHITESPACE, cp[cmdlen])) {
			cp += cmdlen;
			cp = cp + strspn(cp, WHITESPACE);
			break;
		}
	}
	cmdnum = cmds[i].n;
	cmd = cmds[i].c;

	/* Special case */
	if (*cp == '!') {
		cp++;
		cmdnum = I_SHELL;
	} else if (cmdnum == -1) {
		error("Invalid command.");
		return (-1);
	}

	/* Get arguments and parse flags */
	*lflag = *pflag = *n_arg = 0;
	*path1 = *path2 = NULL;
	switch (cmdnum) {
	case I_GET:
	case I_PUT:
		if (parse_getput_flags(&cp, pflag))
			return(-1);
		/* Get first pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify at least one path after a "
			    "%s command.", cmd);
			return(-1);
		}
		/* Try to get second pathname (optional) */
		if (get_pathname(&cp, path2))
			return(-1);
		break;
	case I_RENAME:
	case I_SYMLINK:
		if (get_pathname(&cp, path1))
			return(-1);
		if (get_pathname(&cp, path2))
			return(-1);
		if (!*path1 || !*path2) {
			error("You must specify two paths after a %s "
			    "command.", cmd);
			return(-1);
		}
		break;
	case I_RM:
	case I_MKDIR:
	case I_RMDIR:
	case I_CHDIR:
	case I_LCHDIR:
	case I_LMKDIR:
		/* Get pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify a path after a %s command.",
			    cmd);
			return(-1);
		}
		break;
	case I_LS:
		if (parse_ls_flags(&cp, lflag))
			return(-1);
		/* Path is optional */
		if (get_pathname(&cp, path1))
			return(-1);
		break;
	case I_LLS:
	case I_SHELL:
		/* Uses the rest of the line */
		break;
	case I_LUMASK:
		base = 8;
	case I_CHMOD:
		base = 8;
	case I_CHOWN:
	case I_CHGRP:
		/* Get numeric arg (mandatory) */
		l = strtol(cp, &cp2, base);
		if (cp2 == cp || ((l == LONG_MIN || l == LONG_MAX) &&
		    errno == ERANGE) || l < 0) {
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return(-1);
		}
		cp = cp2;
		*n_arg = l;
		if (cmdnum == I_LUMASK && strchr(WHITESPACE, *cp))
			break;
		if (cmdnum == I_LUMASK || !strchr(WHITESPACE, *cp)) {
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return(-1);
		}
		cp += strspn(cp, WHITESPACE);

		/* Get pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify a path after a %s command.",
			    cmd);
			return(-1);
		}
		break;
	case I_QUIT:
	case I_PWD:
	case I_LPWD:
	case I_HELP:
	case I_VERSION:
	case I_PROGRESS:
		break;
	default:
		fatal("Command not implemented");
	}

	*cpp = cp;
	return(cmdnum);
}

static int
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
    int err_abort)
{
	char *path1, *path2, *tmp;
	int pflag, lflag, iflag, cmdnum, i;
	unsigned long n_arg;
	Attrib a, *aa;
	char path_buf[MAXPATHLEN];
	int err = 0;
	glob_t g;

	path1 = path2 = NULL;
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &n_arg,
	    &path1, &path2);

	if (iflag != 0)
		err_abort = 0;

	memset(&g, 0, sizeof(g));

	/* Perform command */
	switch (cmdnum) {
	case 0:
		/* Blank line */
		break;
	case -1:
		/* Unrecognized command */
		err = -1;
		break;
	case I_GET:
		err = process_get(conn, path1, path2, *pwd, pflag);
		break;
	case I_PUT:
		err = process_put(conn, path1, path2, *pwd, pflag);
		break;
	case I_RENAME:
		path1 = make_absolute(path1, *pwd);
		path2 = make_absolute(path2, *pwd);
		err = do_rename(conn, path1, path2);
		break;
	case I_SYMLINK:
		path2 = make_absolute(path2, *pwd);
		err = do_symlink(conn, path1, path2);
		break;
	case I_RM:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			printf("Removing %s\n", g.gl_pathv[i]);
			err = do_rm(conn, g.gl_pathv[i]);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_MKDIR:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = 0777;
		err = do_mkdir(conn, path1, &a);
		break;
	case I_RMDIR:
		path1 = make_absolute(path1, *pwd);
		err = do_rmdir(conn, path1);
		break;
	case I_CHDIR:
		path1 = make_absolute(path1, *pwd);
		if ((tmp = do_realpath(conn, path1)) == NULL) {
			err = 1;
			break;
		}
		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
			xfree(tmp);
			err = 1;
			break;
		}
		if (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {
			error("Can't change directory: Can't check target");
			xfree(tmp);
			err = 1;
			break;
		}
		if (!S_ISDIR(aa->perm)) {
			error("Can't change directory: \"%s\" is not "
			    "a directory", tmp);
			xfree(tmp);
			err = 1;
			break;
		}
		xfree(*pwd);
		*pwd = tmp;
		break;
	case I_LS:
		if (!path1) {
			do_globbed_ls(conn, *pwd, *pwd, lflag);
			break;
		}

		/* Strip pwd off beginning of non-absolute paths */
		tmp = NULL;
		if (*path1 != '/')
			tmp = *pwd;

		path1 = make_absolute(path1, *pwd);
		err = do_globbed_ls(conn, path1, tmp, lflag);
		break;
	case I_LCHDIR:
		if (chdir(path1) == -1) {
			error("Couldn't change local directory to "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LMKDIR:
		if (mkdir(path1, 0777) == -1) {
			error("Couldn't create local directory "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LLS:
		local_do_ls(cmd);
		break;
	case I_SHELL:
		local_do_shell(cmd);
		break;
	case I_LUMASK:
		umask(n_arg);
		printf("Local umask: %03lo\n", n_arg);
		break;
	case I_CHMOD:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = n_arg;
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			printf("Changing mode on %s\n", g.gl_pathv[i]);
			err = do_setstat(conn, g.gl_pathv[i], &a);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_CHOWN:
	case I_CHGRP:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
				if (err != 0 && err_abort)
					break;
				else
					continue;
			}
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				if (err != 0 && err_abort)
					break;
				else
					continue;
			}
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			if (cmdnum == I_CHOWN) {
				printf("Changing owner on %s\n", g.gl_pathv[i]);
				aa->uid = n_arg;
			} else {
				printf("Changing group on %s\n", g.gl_pathv[i]);
				aa->gid = n_arg;
			}
			err = do_setstat(conn, g.gl_pathv[i], aa);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_PWD:
		printf("Remote working directory: %s\n", *pwd);
		break;
	case I_LPWD:
		if (!getcwd(path_buf, sizeof(path_buf))) {
			error("Couldn't get local cwd: %s", strerror(errno));
			err = -1;
			break;
		}
		printf("Local working directory: %s\n", path_buf);
		break;
	case I_QUIT:
		/* Processed below */
		break;
	case I_HELP:
		help();
		break;
	case I_VERSION:
		printf("SFTP protocol version %u\n", sftp_proto_version(conn));
		break;
	case I_PROGRESS:
		showprogress = !showprogress;
		if (showprogress)
			printf("Progress meter enabled\n");
		else
			printf("Progress meter disabled\n");
		break;
	default:
		fatal("%d is not implemented", cmdnum);
	}

	if (g.gl_pathc)
		globfree(&g);
	if (path1)
		xfree(path1);
	if (path2)
		xfree(path2);

	/* If an unignored error occurs in batch mode we should abort. */
	if (err_abort && err != 0)
		return (-1);
	else if (cmdnum == I_QUIT)
		return (1);

	return (0);
}

int
interactive_loop(int fd_in, int fd_out, char *file1, char *file2)
{
	char *pwd;
	char *dir = NULL;
	char cmd[2048];
	struct sftp_conn *conn;
	int err;

	conn = do_init(fd_in, fd_out, copy_buffer_len, num_requests);
	if (conn == NULL)
		fatal("Couldn't initialise connection to server");

	pwd = do_realpath(conn, ".");
	if (pwd == NULL)
		fatal("Need cwd");

	if (file1 != NULL) {
		dir = xstrdup(file1);
		dir = make_absolute(dir, pwd);

		if (remote_is_dir(conn, dir) && file2 == NULL) {
			printf("Changing to: %s\n", dir);
			snprintf(cmd, sizeof cmd, "cd \"%s\"", dir);
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0)
				return (-1);
		} else {
			if (file2 == NULL)
				snprintf(cmd, sizeof cmd, "get %s", dir);
			else
				snprintf(cmd, sizeof cmd, "get %s %s", dir,
				    file2);

			err = parse_dispatch_command(conn, cmd, &pwd, 1);
			xfree(dir);
			xfree(pwd);
			return (err);
		}
		xfree(dir);
	}

	setvbuf(stdout, NULL, _IOLBF, 0);
	setvbuf(infile, NULL, _IOLBF, 0);

	err = 0;
	for (;;) {
		char *cp;

		printf("sftp> ");

		/* XXX: use libedit */
		if (fgets(cmd, sizeof(cmd), infile) == NULL) {
			printf("\n");
			break;
		}

		if (batchmode) /* Echo command */
			printf("%s", cmd);

		cp = strrchr(cmd, '\n');
		if (cp)
			*cp = '\0';

		err = parse_dispatch_command(conn, cmd, &pwd, batchmode);
		if (err != 0)
			break;
	}
	xfree(pwd);

	/* err == 1 signifies normal "quit" exit */
	return (err >= 0 ? 0 : -1);
}
d109 4
a112 6
	    "usage: %s [-1Cv] [-B buffer_size] [-b batchfile] [-F ssh_config]\n"
	    "            [-o ssh_option] [-P sftp_server_path] [-R num_requests]\n"
	    "            [-S program] [-s subsystem | sftp_server] host\n"
	    "       %s [[user@@]host[:file [file]]]\n"
	    "       %s [[user@@]host[:dir[/]]]\n"
	    "       %s -b batchfile [user@@]host\n", __progname, __progname, __progname, __progname);
a133 1

d135 1
a135 1
	infile = stdin;
d165 6
a170 7
			if (batchmode)
				fatal("Batch file already specified.");

			/* Allow "-" as stdin */
			if (strcmp(optarg, "-") != 0 && 
			   (infile = fopen(optarg, "r")) == NULL)
				fatal("%s (%s).", strerror(errno), optarg);
a171 1
			batchmode = 1;
d202 5
a217 5
		if ((cp = colon(host)) != NULL) {
			*cp++ = '\0';
			file1 = cp;
		}

d235 1
a235 2
		if (!batchmode)
			fprintf(stderr, "Connecting to %s...\n", host);
d241 1
a241 2
		if (!batchmode)
			fprintf(stderr, "Attaching to %s...\n", sftp_direct);
d249 1
a249 1
	if (batchmode)
@


1.37.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.56 2004/07/11 17:48:47 deraadt Exp $");
d49 1
a49 7
int showprogress = 1;

/* SIGINT received during command processing */
volatile sig_atomic_t interrupted = 0;

/* I wish qsort() took a separate ctx for the comparison function...*/
int sort_flag;
d57 3
a59 12
/* ls flags */
#define LS_LONG_VIEW	0x01	/* Full view ala ls -l */
#define LS_SHORT_VIEW	0x02	/* Single row view ala ls -1 */
#define LS_NUMERIC_VIEW	0x04	/* Long view with numeric uid/gid */
#define LS_NAME_SORT	0x08	/* Sort by name (default) */
#define LS_TIME_SORT	0x10	/* Sort by mtime */
#define LS_SIZE_SORT	0x20	/* Sort by file size */
#define LS_REVERSE_SORT	0x40	/* Reverse sort order */
#define LS_SHOW_ALL	0x80	/* Don't skip filenames starting with '.' */

#define VIEW_FLAGS	(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW)
#define SORT_FLAGS	(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)
a129 18
killchild(int signo)
{
	if (sshpid > 1)
		kill(sshpid, SIGTERM);

	_exit(1);
}

static void
cmd_interrupt(int signo)
{
	const char msg[] = "\rInterrupt  \n";

	write(STDERR_FILENO, msg, sizeof(msg) - 1);
	interrupted = 1;
}

static void
d253 1
a253 1
	char *abs_str;
d257 1
a257 1
		abs_str = path_append(pwd, p);
d259 1
a259 1
		return(abs_str);
a311 3
	/* Defaults */
	*lflag = LS_NAME_SORT;

d317 1
a317 2
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_LONG_VIEW;
d320 1
a320 23
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_SHORT_VIEW;
				break;
			case 'n':
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;
				break;
			case 'S':
				*lflag &= ~SORT_FLAGS;
				*lflag |= LS_SIZE_SORT;
				break;
			case 't':
				*lflag &= ~SORT_FLAGS;
				*lflag |= LS_TIME_SORT;
				break;
			case 'r':
				*lflag |= LS_REVERSE_SORT;
				break;
			case 'f':
				*lflag &= ~SORT_FLAGS;
				break;
			case 'a':
				*lflag |= LS_SHOW_ALL;
d368 1
a368 1
					error("Bad escaped character '\\%c'",
d464 1
a464 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d533 1
a533 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
a580 1
	int rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;
d582 1
a582 9
#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))
	if (sort_flag & LS_NAME_SORT)
		return (rmul * strcmp(a->filename, b->filename));
	else if (sort_flag & LS_TIME_SORT)
		return (rmul * NCMP(a->a.mtime, b->a.mtime));
	else if (sort_flag & LS_SIZE_SORT)
		return (rmul * NCMP(a->a.size, b->a.size));

	fatal("Unknown ls sort type");
d595 1
a595 1
	if (!(lflag & LS_SHORT_VIEW)) {
d601 2
a602 4
		for (n = 0; d[n] != NULL; n++) {
			if (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))
				m = MAX(m, strlen(d[n]->filename));
		}
d618 1
a618 4
	if (lflag & SORT_FLAGS) {
		sort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);
		qsort(d, n, sizeof(*d), sdirent_comp);
	}
d620 1
a620 1
	for (n = 0; d[n] != NULL && !interrupted; n++) {
a622 3
		if (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))
			continue;

d627 9
a635 12
		if (lflag & LS_LONG_VIEW) {
			if (lflag & LS_NUMERIC_VIEW) {
				char *lname;
				struct stat sb;

				memset(&sb, 0, sizeof(sb));
				attrib_to_stat(&d[n]->a, &sb);
				lname = ls_file(fname, &sb, 1);
				printf("%s\n", lname);
				xfree(lname);
			} else
				printf("%s\n", d[n]->longname);
d648 1
a648 1
	if (!(lflag & LS_LONG_VIEW) && (c != 1))
a671 3
	if (interrupted)
		goto out;

d689 1
a689 1
	if (!(lflag & LS_SHORT_VIEW)) {
d705 1
a705 1
	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d710 1
a710 1
		if (lflag & LS_LONG_VIEW) {
d739 1
a739 1
	if (!(lflag & LS_LONG_VIEW) && (c != 1))
a741 1
 out:
d951 1
a951 1
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d1040 1
a1040 1
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
d1051 1
a1051 1
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
a1173 2
		signal(SIGINT, SIG_IGN);

a1188 4
		/* Handle user interrupts gracefully during commands */
		interrupted = 0;
		signal(SIGINT, cmd_interrupt);

d1200 9
d1237 1
a1237 1
			_exit(1);
d1243 1
a1243 9

		/*
		 * The underlying ssh is in the same process group, so we must
		 * ignore SIGINT if we want to gracefully abort commands,
		 * otherwise the signal will make it to the ssh process and
		 * kill it too
		 */
		signal(SIGINT, SIG_IGN);
		execvp(path, args);
d1245 1
a1245 1
		_exit(1);
d1274 1
a1274 1
	char *host, *userhost, *cp, *file2 = NULL;
d1324 1
a1324 1
			if (strcmp(optarg, "-") != 0 &&
a1348 3

	if (!isatty(STDERR_FILENO))
		showprogress = 0;
@


1.36
log
@kill ssh process on receipt of signal; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.35 2003/05/15 03:44:00 mouring Exp $");
d109 3
a111 2
	    "usage: %s [-vC1] [-b batchfile] [-o option] [-s subsystem|path] [-B buffer_size]\n"
	    "            [-F config] [-P direct server path] [-S program]\n"
@


1.35
log
@Teach ls how to display multiple column display and allow users to return
to single column format via 'ls -1'.  OK @@djm
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.34 2003/01/10 08:19:07 fgsch Exp $");
d43 1
d48 10
a57 1
connect_to_server(char *path, char **args, int *in, int *out, pid_t *sshpid)
d79 1
a79 1
	if ((*sshpid = fork()) == -1)
d81 1
a81 1
	else if (*sshpid == 0) {
d96 3
a118 1
	pid_t sshpid;
d235 1
a235 2
		connect_to_server(ssh_program, args.list, &in, &out,
		    &sshpid);
d241 1
a241 2
		connect_to_server(sftp_direct, args.list, &in, &out,
		    &sshpid);
@


1.34
log
@sftp progress meter support.
original diffs by Nils Nordman <nino at nforced dot com> via markus@@, merged
to -current by me, djm@@ ok.
@
text
@d27 1
a27 3
RCSID("$OpenBSD: sftp.c,v 1.32 2002/11/27 17:53:35 markus Exp $");

/* XXX: short-form remote directory listings (like 'ls -C') */
@


1.34.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d27 3
a29 1
RCSID("$OpenBSD: sftp.c,v 1.37 2003/07/10 20:05:55 markus Exp $");
a44 1
static pid_t sshpid = -1;
d49 1
a49 10
killchild(int signo)
{
	if (sshpid > 1)
		kill(sshpid, signo);

	_exit(1);
}

static void
connect_to_server(char *path, char **args, int *in, int *out)
d71 1
a71 1
	if ((sshpid = fork()) == -1)
d73 1
a73 1
	else if (sshpid == 0) {
a87 3
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
d98 2
a99 3
	    "usage: %s [-vC1] [-b batchfile] [-o ssh_option] [-s subsystem | sftp_server]\n"
	    "            [-B buffer_size] [-F ssh_config] [-P sftp_server path]\n"
	    "            [-R num_requests] [-S program]\n"
d108 1
d225 2
a226 1
		connect_to_server(ssh_program, args.list, &in, &out);
d232 2
a233 1
		connect_to_server(sftp_direct, args.list, &in, &out);
@


1.34.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2004 Damien Miller <djm@@openbsd.org>
d4 8
a11 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d13 10
a22 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d27 1
a27 3
RCSID("$OpenBSD: sftp.c,v 1.44 2004/02/17 11:03:08 djm Exp $");

#include <glob.h>
d38 1
a39 1
/* File to read commands from */
a40 5

/* Are we in batchfile mode? */
int batchmode = 0;

/* Size of buffer used when copying files */
a41 2

/* Number of concurrent outstanding requests */
a42 2

/* PID of ssh transport process */
d45 1
a45 1150
/* This is set to 0 if the progressmeter is not desired. */
int showprogress;

int remote_glob(struct sftp_conn *, const char *, int,
    int (*)(const char *, int), glob_t *); /* proto for sftp-glob.c */

/* Separators for interactive commands */
#define WHITESPACE " \t\r\n"

/* Define what type of ls view (0 - multi-column) */
#define LONG_VIEW 1		/* Full view ala ls -l */
#define SHORT_VIEW 2		/* Single row view ala ls -1 */

/* Commands for interactive mode */
#define I_CHDIR		1
#define I_CHGRP		2
#define I_CHMOD		3
#define I_CHOWN		4
#define I_GET		5
#define I_HELP		6
#define I_LCHDIR	7
#define I_LLS		8
#define I_LMKDIR	9
#define I_LPWD		10
#define I_LS		11
#define I_LUMASK	12
#define I_MKDIR		13
#define I_PUT		14
#define I_PWD		15
#define I_QUIT		16
#define I_RENAME	17
#define I_RM		18
#define I_RMDIR		19
#define I_SHELL		20
#define I_SYMLINK	21
#define I_VERSION	22
#define I_PROGRESS	23

struct CMD {
	const char *c;
	const int n;
};

static const struct CMD cmds[] = {
	{ "bye",	I_QUIT },
	{ "cd",		I_CHDIR },
	{ "chdir",	I_CHDIR },
	{ "chgrp",	I_CHGRP },
	{ "chmod",	I_CHMOD },
	{ "chown",	I_CHOWN },
	{ "dir",	I_LS },
	{ "exit",	I_QUIT },
	{ "get",	I_GET },
	{ "mget",	I_GET },
	{ "help",	I_HELP },
	{ "lcd",	I_LCHDIR },
	{ "lchdir",	I_LCHDIR },
	{ "lls",	I_LLS },
	{ "lmkdir",	I_LMKDIR },
	{ "ln",		I_SYMLINK },
	{ "lpwd",	I_LPWD },
	{ "ls",		I_LS },
	{ "lumask",	I_LUMASK },
	{ "mkdir",	I_MKDIR },
	{ "progress",	I_PROGRESS },
	{ "put",	I_PUT },
	{ "mput",	I_PUT },
	{ "pwd",	I_PWD },
	{ "quit",	I_QUIT },
	{ "rename",	I_RENAME },
	{ "rm",		I_RM },
	{ "rmdir",	I_RMDIR },
	{ "symlink",	I_SYMLINK },
	{ "version",	I_VERSION },
	{ "!",		I_SHELL },
	{ "?",		I_HELP },
	{ NULL,			-1}
};

int interactive_loop(int fd_in, int fd_out, char *file1, char *file2);

static void
help(void)
{
	printf("Available commands:\n");
	printf("cd path                       Change remote directory to 'path'\n");
	printf("lcd path                      Change local directory to 'path'\n");
	printf("chgrp grp path                Change group of file 'path' to 'grp'\n");
	printf("chmod mode path               Change permissions of file 'path' to 'mode'\n");
	printf("chown own path                Change owner of file 'path' to 'own'\n");
	printf("help                          Display this help text\n");
	printf("get remote-path [local-path]  Download file\n");
	printf("lls [ls-options [path]]       Display local directory listing\n");
	printf("ln oldpath newpath            Symlink remote file\n");
	printf("lmkdir path                   Create local directory\n");
	printf("lpwd                          Print local working directory\n");
	printf("ls [path]                     Display remote directory listing\n");
	printf("lumask umask                  Set local umask to 'umask'\n");
	printf("mkdir path                    Create remote directory\n");
	printf("progress                      Toggle display of progress meter\n");
	printf("put local-path [remote-path]  Upload file\n");
	printf("pwd                           Display remote working directory\n");
	printf("exit                          Quit sftp\n");
	printf("quit                          Quit sftp\n");
	printf("rename oldpath newpath        Rename remote file\n");
	printf("rmdir path                    Remove remote directory\n");
	printf("rm path                       Delete remote file\n");
	printf("symlink oldpath newpath       Symlink remote file\n");
	printf("version                       Show SFTP version\n");
	printf("!command                      Execute 'command' in local shell\n");
	printf("!                             Escape to local shell\n");
	printf("?                             Synonym for help\n");
}

static void
local_do_shell(const char *args)
{
	int status;
	char *shell;
	pid_t pid;

	if (!*args)
		args = NULL;

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	if ((pid = fork()) == -1)
		fatal("Couldn't fork: %s", strerror(errno));

	if (pid == 0) {
		/* XXX: child has pipe fds to ssh subproc open - issue? */
		if (args) {
			debug3("Executing %s -c \"%s\"", shell, args);
			execl(shell, shell, "-c", args, (char *)NULL);
		} else {
			debug3("Executing %s", shell);
			execl(shell, shell, (char *)NULL);
		}
		fprintf(stderr, "Couldn't execute \"%s\": %s\n", shell,
		    strerror(errno));
		_exit(1);
	}
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));
	if (!WIFEXITED(status))
		error("Shell exited abormally");
	else if (WEXITSTATUS(status))
		error("Shell exited with status %d", WEXITSTATUS(status));
}

static void
local_do_ls(const char *args)
{
	if (!args || !*args)
		local_do_shell(_PATH_LS);
	else {
		int len = strlen(_PATH_LS " ") + strlen(args) + 1;
		char *buf = xmalloc(len);

		/* XXX: quoting - rip quoting code from ftp? */
		snprintf(buf, len, _PATH_LS " %s", args);
		local_do_shell(buf);
		xfree(buf);
	}
}

/* Strip one path (usually the pwd) from the start of another */
static char *
path_strip(char *path, char *strip)
{
	size_t len;

	if (strip == NULL)
		return (xstrdup(path));

	len = strlen(strip);
	if (strip != NULL && strncmp(path, strip, len) == 0) {
		if (strip[len - 1] != '/' && path[len] == '/')
			len++;
		return (xstrdup(path + len));
	}

	return (xstrdup(path));
}

static char *
path_append(char *p1, char *p2)
{
	char *ret;
	int len = strlen(p1) + strlen(p2) + 2;

	ret = xmalloc(len);
	strlcpy(ret, p1, len);
	if (p1[strlen(p1) - 1] != '/')
		strlcat(ret, "/", len);
	strlcat(ret, p2, len);

	return(ret);
}

static char *
make_absolute(char *p, char *pwd)
{
	char *abs;

	/* Derelativise */
	if (p && p[0] != '/') {
		abs = path_append(pwd, p);
		xfree(p);
		return(abs);
	} else
		return(p);
}

static int
infer_path(const char *p, char **ifp)
{
	char *cp;

	cp = strrchr(p, '/');
	if (cp == NULL) {
		*ifp = xstrdup(p);
		return(0);
	}

	if (!cp[1]) {
		error("Invalid path");
		return(-1);
	}

	*ifp = xstrdup(cp + 1);
	return(0);
}

static int
parse_getput_flags(const char **cpp, int *pflag)
{
	const char *cp = *cpp;

	/* Check for flags */
	if (cp[0] == '-' && cp[1] && strchr(WHITESPACE, cp[2])) {
		switch (cp[1]) {
		case 'p':
		case 'P':
			*pflag = 1;
			break;
		default:
			error("Invalid flag -%c", cp[1]);
			return(-1);
		}
		cp += 2;
		*cpp = cp + strspn(cp, WHITESPACE);
	}

	return(0);
}

static int
parse_ls_flags(const char **cpp, int *lflag)
{
	const char *cp = *cpp;

	/* Check for flags */
	if (cp++[0] == '-') {
		for(; strchr(WHITESPACE, *cp) == NULL; cp++) {
			switch (*cp) {
			case 'l':
				*lflag = LONG_VIEW;
				break;
			case '1':
				*lflag = SHORT_VIEW;
				break;
			default:
				error("Invalid flag -%c", *cp);
				return(-1);
			}
		}
		*cpp = cp + strspn(cp, WHITESPACE);
	}

	return(0);
}

static int
get_pathname(const char **cpp, char **path)
{
	const char *cp = *cpp, *end;
	char quot;
	int i, j;

	cp += strspn(cp, WHITESPACE);
	if (!*cp) {
		*cpp = cp;
		*path = NULL;
		return (0);
	}

	*path = xmalloc(strlen(cp) + 1);

	/* Check for quoted filenames */
	if (*cp == '\"' || *cp == '\'') {
		quot = *cp++;

		/* Search for terminating quote, unescape some chars */
		for (i = j = 0; i <= strlen(cp); i++) {
			if (cp[i] == quot) {	/* Found quote */
				i++;
				(*path)[j] = '\0';
				break;
			}
			if (cp[i] == '\0') {	/* End of string */
				error("Unterminated quote");
				goto fail;
			}
			if (cp[i] == '\\') {	/* Escaped characters */
				i++;
				if (cp[i] != '\'' && cp[i] != '\"' &&
				    cp[i] != '\\') {
					error("Bad escaped character '\%c'",
					    cp[i]);
					goto fail;
				}
			}
			(*path)[j++] = cp[i];
		}

		if (j == 0) {
			error("Empty quotes");
			goto fail;
		}
		*cpp = cp + i + strspn(cp + i, WHITESPACE);
	} else {
		/* Read to end of filename */
		end = strpbrk(cp, WHITESPACE);
		if (end == NULL)
			end = strchr(cp, '\0');
		*cpp = end + strspn(end, WHITESPACE);

		memcpy(*path, cp, end - cp);
		(*path)[end - cp] = '\0';
	}
	return (0);

 fail:
	xfree(*path);
	*path = NULL;
	return (-1);
}

static int
is_dir(char *path)
{
	struct stat sb;

	/* XXX: report errors? */
	if (stat(path, &sb) == -1)
		return(0);

	return(sb.st_mode & S_IFDIR);
}

static int
is_reg(char *path)
{
	struct stat sb;

	if (stat(path, &sb) == -1)
		fatal("stat %s: %s", path, strerror(errno));

	return(S_ISREG(sb.st_mode));
}

static int
remote_is_dir(struct sftp_conn *conn, char *path)
{
	Attrib *a;

	/* XXX: report errors? */
	if ((a = do_stat(conn, path, 1)) == NULL)
		return(0);
	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
		return(0);
	return(a->perm & S_IFDIR);
}

static int
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
{
	char *abs_src = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	abs_src = xstrdup(src);
	abs_src = make_absolute(abs_src, pwd);

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", abs_src);
	if (remote_glob(conn, abs_src, 0, NULL, &g)) {
		error("File \"%s\" not found.", abs_src);
		err = -1;
		goto out;
	}

	/* If multiple matches, dst must be a directory or unspecified */
	if (g.gl_matchc > 1 && dst && !is_dir(dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && dst) {
			/* If directory specified, append filename */
			if (is_dir(dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(dst);
		} else if (dst) {
			abs_dst = path_append(dst, tmp);
			xfree(tmp);
		} else
			abs_dst = tmp;

		printf("Fetching %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_download(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
		xfree(abs_dst);
		abs_dst = NULL;
	}

out:
	xfree(abs_src);
	if (abs_dst)
		xfree(abs_dst);
	globfree(&g);
	return(err);
}

static int
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
{
	char *tmp_dst = NULL;
	char *abs_dst = NULL;
	char *tmp;
	glob_t g;
	int err = 0;
	int i;

	if (dst) {
		tmp_dst = xstrdup(dst);
		tmp_dst = make_absolute(tmp_dst, pwd);
	}

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", src);
	if (glob(src, 0, NULL, &g)) {
		error("File \"%s\" not found.", src);
		err = -1;
		goto out;
	}

	/* If multiple matches, dst may be directory or unspecified */
	if (g.gl_matchc > 1 && tmp_dst && !remote_is_dir(conn, tmp_dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    tmp_dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		if (!is_reg(g.gl_pathv[i])) {
			error("skipping non-regular file %s",
			    g.gl_pathv[i]);
			continue;
		}
		if (infer_path(g.gl_pathv[i], &tmp)) {
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && tmp_dst) {
			/* If directory specified, append filename */
			if (remote_is_dir(conn, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
				abs_dst = xstrdup(tmp_dst);

		} else if (tmp_dst) {
			abs_dst = path_append(tmp_dst, tmp);
			xfree(tmp);
		} else
			abs_dst = make_absolute(tmp, pwd);

		printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
		if (do_upload(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
	}

out:
	if (abs_dst)
		xfree(abs_dst);
	if (tmp_dst)
		xfree(tmp_dst);
	globfree(&g);
	return(err);
}

static int
sdirent_comp(const void *aa, const void *bb)
{
	SFTP_DIRENT *a = *(SFTP_DIRENT **)aa;
	SFTP_DIRENT *b = *(SFTP_DIRENT **)bb;

	return (strcmp(a->filename, b->filename));
}

/* sftp ls.1 replacement for directories */
static int
do_ls_dir(struct sftp_conn *conn, char *path, char *strip_path, int lflag)
{
	int n, c = 1, colspace = 0, columns = 1;
	SFTP_DIRENT **d;

	if ((n = do_readdir(conn, path, &d)) != 0)
		return (n);

	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;
		char *tmp;

		/* Count entries for sort and find longest filename */
		for (n = 0; d[n] != NULL; n++)
			m = MAX(m, strlen(d[n]->filename));

		/* Add any subpath that also needs to be counted */
		tmp = path_strip(path, strip_path);
		m += strlen(tmp);
		xfree(tmp);

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
		colspace = MIN(colspace, width);
	}

	qsort(d, n, sizeof(*d), sdirent_comp);

	for (n = 0; d[n] != NULL; n++) {
		char *tmp, *fname;

		tmp = path_append(path, d[n]->filename);
		fname = path_strip(tmp, strip_path);
		xfree(tmp);

		if (lflag & LONG_VIEW) {
			char *lname;
			struct stat sb;

			memset(&sb, 0, sizeof(sb));
			attrib_to_stat(&d[n]->a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}

		xfree(fname);
	}

	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");

	free_sftp_dirents(d);
	return (0);
}

/* sftp ls.1 replacement which handles path globs */
static int
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path,
    int lflag)
{
	glob_t g;
	int i, c = 1, colspace = 0, columns = 1;
	Attrib *a;

	memset(&g, 0, sizeof(g));

	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE,
	    NULL, &g)) {
		error("Can't ls: \"%s\" not found", path);
		return (-1);
	}

	/*
	 * If the glob returns a single match, which is the same as the
	 * input glob, and it is a directory, then just list its contents
	 */
	if (g.gl_pathc == 1 &&
	    strncmp(path, g.gl_pathv[0], strlen(g.gl_pathv[0]) - 1) == 0) {
		if ((a = do_lstat(conn, path, 1)) == NULL) {
			globfree(&g);
			return (-1);
		}
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
		    S_ISDIR(a->perm)) {
			globfree(&g);
			return (do_ls_dir(conn, path, strip_path, lflag));
		}
	}

	if (!(lflag & SHORT_VIEW)) {
		int m = 0, width = 80;
		struct winsize ws;

		/* Count entries for sort and find longest filename */
		for (i = 0; g.gl_pathv[i]; i++)
			m = MAX(m, strlen(g.gl_pathv[i]));

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
	}

	for (i = 0; g.gl_pathv[i]; i++) {
		char *fname;

		fname = path_strip(g.gl_pathv[i], strip_path);

		if (lflag & LONG_VIEW) {
			char *lname;
			struct stat sb;

			/*
			 * XXX: this is slow - 1 roundtrip per path
			 * A solution to this is to fork glob() and
			 * build a sftp specific version which keeps the
			 * attribs (which currently get thrown away)
			 * that the server returns as well as the filenames.
			 */
			memset(&sb, 0, sizeof(sb));
			a = do_lstat(conn, g.gl_pathv[i], 1);
			if (a != NULL)
				attrib_to_stat(a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}
		xfree(fname);
	}

	if (!(lflag & LONG_VIEW) && (c != 1))
		printf("\n");

	if (g.gl_pathc)
		globfree(&g);

	return (0);
}

static int
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag,
    unsigned long *n_arg, char **path1, char **path2)
{
	const char *cmd, *cp = *cpp;
	char *cp2;
	int base = 0;
	long l;
	int i, cmdnum;

	/* Skip leading whitespace */
	cp = cp + strspn(cp, WHITESPACE);

	/* Ignore blank lines and lines which begin with comment '#' char */
	if (*cp == '\0' || *cp == '#')
		return (0);

	/* Check for leading '-' (disable error processing) */
	*iflag = 0;
	if (*cp == '-') {
		*iflag = 1;
		cp++;
	}

	/* Figure out which command we have */
	for (i = 0; cmds[i].c; i++) {
		int cmdlen = strlen(cmds[i].c);

		/* Check for command followed by whitespace */
		if (!strncasecmp(cp, cmds[i].c, cmdlen) &&
		    strchr(WHITESPACE, cp[cmdlen])) {
			cp += cmdlen;
			cp = cp + strspn(cp, WHITESPACE);
			break;
		}
	}
	cmdnum = cmds[i].n;
	cmd = cmds[i].c;

	/* Special case */
	if (*cp == '!') {
		cp++;
		cmdnum = I_SHELL;
	} else if (cmdnum == -1) {
		error("Invalid command.");
		return (-1);
	}

	/* Get arguments and parse flags */
	*lflag = *pflag = *n_arg = 0;
	*path1 = *path2 = NULL;
	switch (cmdnum) {
	case I_GET:
	case I_PUT:
		if (parse_getput_flags(&cp, pflag))
			return(-1);
		/* Get first pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify at least one path after a "
			    "%s command.", cmd);
			return(-1);
		}
		/* Try to get second pathname (optional) */
		if (get_pathname(&cp, path2))
			return(-1);
		break;
	case I_RENAME:
	case I_SYMLINK:
		if (get_pathname(&cp, path1))
			return(-1);
		if (get_pathname(&cp, path2))
			return(-1);
		if (!*path1 || !*path2) {
			error("You must specify two paths after a %s "
			    "command.", cmd);
			return(-1);
		}
		break;
	case I_RM:
	case I_MKDIR:
	case I_RMDIR:
	case I_CHDIR:
	case I_LCHDIR:
	case I_LMKDIR:
		/* Get pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify a path after a %s command.",
			    cmd);
			return(-1);
		}
		break;
	case I_LS:
		if (parse_ls_flags(&cp, lflag))
			return(-1);
		/* Path is optional */
		if (get_pathname(&cp, path1))
			return(-1);
		break;
	case I_LLS:
	case I_SHELL:
		/* Uses the rest of the line */
		break;
	case I_LUMASK:
		base = 8;
	case I_CHMOD:
		base = 8;
	case I_CHOWN:
	case I_CHGRP:
		/* Get numeric arg (mandatory) */
		l = strtol(cp, &cp2, base);
		if (cp2 == cp || ((l == LONG_MIN || l == LONG_MAX) &&
		    errno == ERANGE) || l < 0) {
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return(-1);
		}
		cp = cp2;
		*n_arg = l;
		if (cmdnum == I_LUMASK && strchr(WHITESPACE, *cp))
			break;
		if (cmdnum == I_LUMASK || !strchr(WHITESPACE, *cp)) {
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return(-1);
		}
		cp += strspn(cp, WHITESPACE);

		/* Get pathname (mandatory) */
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
			error("You must specify a path after a %s command.",
			    cmd);
			return(-1);
		}
		break;
	case I_QUIT:
	case I_PWD:
	case I_LPWD:
	case I_HELP:
	case I_VERSION:
	case I_PROGRESS:
		break;
	default:
		fatal("Command not implemented");
	}

	*cpp = cp;
	return(cmdnum);
}

static int
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
    int err_abort)
{
	char *path1, *path2, *tmp;
	int pflag, lflag, iflag, cmdnum, i;
	unsigned long n_arg;
	Attrib a, *aa;
	char path_buf[MAXPATHLEN];
	int err = 0;
	glob_t g;

	path1 = path2 = NULL;
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &n_arg,
	    &path1, &path2);

	if (iflag != 0)
		err_abort = 0;

	memset(&g, 0, sizeof(g));

	/* Perform command */
	switch (cmdnum) {
	case 0:
		/* Blank line */
		break;
	case -1:
		/* Unrecognized command */
		err = -1;
		break;
	case I_GET:
		err = process_get(conn, path1, path2, *pwd, pflag);
		break;
	case I_PUT:
		err = process_put(conn, path1, path2, *pwd, pflag);
		break;
	case I_RENAME:
		path1 = make_absolute(path1, *pwd);
		path2 = make_absolute(path2, *pwd);
		err = do_rename(conn, path1, path2);
		break;
	case I_SYMLINK:
		path2 = make_absolute(path2, *pwd);
		err = do_symlink(conn, path1, path2);
		break;
	case I_RM:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			printf("Removing %s\n", g.gl_pathv[i]);
			err = do_rm(conn, g.gl_pathv[i]);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_MKDIR:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = 0777;
		err = do_mkdir(conn, path1, &a);
		break;
	case I_RMDIR:
		path1 = make_absolute(path1, *pwd);
		err = do_rmdir(conn, path1);
		break;
	case I_CHDIR:
		path1 = make_absolute(path1, *pwd);
		if ((tmp = do_realpath(conn, path1)) == NULL) {
			err = 1;
			break;
		}
		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
			xfree(tmp);
			err = 1;
			break;
		}
		if (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {
			error("Can't change directory: Can't check target");
			xfree(tmp);
			err = 1;
			break;
		}
		if (!S_ISDIR(aa->perm)) {
			error("Can't change directory: \"%s\" is not "
			    "a directory", tmp);
			xfree(tmp);
			err = 1;
			break;
		}
		xfree(*pwd);
		*pwd = tmp;
		break;
	case I_LS:
		if (!path1) {
			do_globbed_ls(conn, *pwd, *pwd, lflag);
			break;
		}

		/* Strip pwd off beginning of non-absolute paths */
		tmp = NULL;
		if (*path1 != '/')
			tmp = *pwd;

		path1 = make_absolute(path1, *pwd);
		err = do_globbed_ls(conn, path1, tmp, lflag);
		break;
	case I_LCHDIR:
		if (chdir(path1) == -1) {
			error("Couldn't change local directory to "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LMKDIR:
		if (mkdir(path1, 0777) == -1) {
			error("Couldn't create local directory "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LLS:
		local_do_ls(cmd);
		break;
	case I_SHELL:
		local_do_shell(cmd);
		break;
	case I_LUMASK:
		umask(n_arg);
		printf("Local umask: %03lo\n", n_arg);
		break;
	case I_CHMOD:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = n_arg;
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			printf("Changing mode on %s\n", g.gl_pathv[i]);
			err = do_setstat(conn, g.gl_pathv[i], &a);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_CHOWN:
	case I_CHGRP:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i]; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
				if (err != 0 && err_abort)
					break;
				else
					continue;
			}
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				if (err != 0 && err_abort)
					break;
				else
					continue;
			}
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			if (cmdnum == I_CHOWN) {
				printf("Changing owner on %s\n", g.gl_pathv[i]);
				aa->uid = n_arg;
			} else {
				printf("Changing group on %s\n", g.gl_pathv[i]);
				aa->gid = n_arg;
			}
			err = do_setstat(conn, g.gl_pathv[i], aa);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_PWD:
		printf("Remote working directory: %s\n", *pwd);
		break;
	case I_LPWD:
		if (!getcwd(path_buf, sizeof(path_buf))) {
			error("Couldn't get local cwd: %s", strerror(errno));
			err = -1;
			break;
		}
		printf("Local working directory: %s\n", path_buf);
		break;
	case I_QUIT:
		/* Processed below */
		break;
	case I_HELP:
		help();
		break;
	case I_VERSION:
		printf("SFTP protocol version %u\n", sftp_proto_version(conn));
		break;
	case I_PROGRESS:
		showprogress = !showprogress;
		if (showprogress)
			printf("Progress meter enabled\n");
		else
			printf("Progress meter disabled\n");
		break;
	default:
		fatal("%d is not implemented", cmdnum);
	}

	if (g.gl_pathc)
		globfree(&g);
	if (path1)
		xfree(path1);
	if (path2)
		xfree(path2);

	/* If an unignored error occurs in batch mode we should abort. */
	if (err_abort && err != 0)
		return (-1);
	else if (cmdnum == I_QUIT)
		return (1);

	return (0);
}

int
interactive_loop(int fd_in, int fd_out, char *file1, char *file2)
{
	char *pwd;
	char *dir = NULL;
	char cmd[2048];
	struct sftp_conn *conn;
	int err;

	conn = do_init(fd_in, fd_out, copy_buffer_len, num_requests);
	if (conn == NULL)
		fatal("Couldn't initialise connection to server");

	pwd = do_realpath(conn, ".");
	if (pwd == NULL)
		fatal("Need cwd");

	if (file1 != NULL) {
		dir = xstrdup(file1);
		dir = make_absolute(dir, pwd);

		if (remote_is_dir(conn, dir) && file2 == NULL) {
			printf("Changing to: %s\n", dir);
			snprintf(cmd, sizeof cmd, "cd \"%s\"", dir);
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0)
				return (-1);
		} else {
			if (file2 == NULL)
				snprintf(cmd, sizeof cmd, "get %s", dir);
			else
				snprintf(cmd, sizeof cmd, "get %s %s", dir,
				    file2);

			err = parse_dispatch_command(conn, cmd, &pwd, 1);
			xfree(dir);
			xfree(pwd);
			return (err);
		}
		xfree(dir);
	}

	setvbuf(stdout, NULL, _IOLBF, 0);
	setvbuf(infile, NULL, _IOLBF, 0);

	err = 0;
	for (;;) {
		char *cp;

		printf("sftp> ");

		/* XXX: use libedit */
		if (fgets(cmd, sizeof(cmd), infile) == NULL) {
			printf("\n");
			break;
		}

		if (batchmode) /* Echo command */
			printf("%s", cmd);

		cp = strrchr(cmd, '\n');
		if (cp)
			*cp = '\0';

		err = parse_dispatch_command(conn, cmd, &pwd, batchmode);
		if (err != 0)
			break;
	}
	xfree(pwd);

	/* err == 1 signifies normal "quit" exit */
	return (err >= 0 ? 0 : -1);
}
d109 4
a112 6
	    "usage: %s [-1Cv] [-B buffer_size] [-b batchfile] [-F ssh_config]\n"
	    "            [-o ssh_option] [-P sftp_server_path] [-R num_requests]\n"
	    "            [-S program] [-s subsystem | sftp_server] host\n"
	    "       %s [[user@@]host[:file [file]]]\n"
	    "       %s [[user@@]host[:dir[/]]]\n"
	    "       %s -b batchfile [user@@]host\n", __progname, __progname, __progname, __progname);
a133 1

d135 1
a135 1
	infile = stdin;
d165 6
a170 7
			if (batchmode)
				fatal("Batch file already specified.");

			/* Allow "-" as stdin */
			if (strcmp(optarg, "-") != 0 && 
			   (infile = fopen(optarg, "r")) == NULL)
				fatal("%s (%s).", strerror(errno), optarg);
a171 1
			batchmode = 1;
d202 5
a217 5
		if ((cp = colon(host)) != NULL) {
			*cp++ = '\0';
			file1 = cp;
		}

d235 1
a235 2
		if (!batchmode)
			fprintf(stderr, "Connecting to %s...\n", host);
d241 1
a241 2
		if (!batchmode)
			fprintf(stderr, "Attaching to %s...\n", sftp_direct);
d249 1
a249 1
	if (batchmode)
@


1.33
log
@Cleanup error handling for batchmode
Allow blank lines and comments in input
Ability to suppress abort on error in batchmode ("-put blah")

Fixes mindrot bug #452; markus@@ ok
@
text
@d46 2
d160 1
@


1.32
log
@allow usernames with embedded '@@', e.g. scp user@@vhost@@realhost:file /tmp;
http://bugzilla.mindrot.org/show_bug.cgi?id=447; ok mouring@@, millert@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.31 2002/07/25 01:16:59 mouring Exp $");
d105 1
a105 1
	int in, out, ch;
d233 1
a233 1
	interactive_loop(in, out, file1, file2);
d245 1
a245 1
	exit(0);
@


1.31
log
@FallBackToRsh does not exist anywhere else.  Remove it from here.  OK deraadt.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.30 2002/06/23 09:30:14 deraadt Exp $");
d193 1
a193 1
		if ((host = strchr(userhost, '@@')) == NULL)
@


1.31.2.1
log
@Update to OpenSSH 3.6
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.34 2003/01/10 08:19:07 fgsch Exp $");
a45 2
extern int showprogress;

d105 1
a105 1
	int in, out, ch, err;
a157 1
			showprogress = 0;
d193 1
a193 1
		if ((host = strrchr(userhost, '@@')) == NULL)
d233 1
a233 1
	err = interactive_loop(in, out, file1, file2);
d245 1
a245 1
	exit(err == 0 ? 0 : 1);
@


1.31.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d27 3
a29 1
RCSID("$OpenBSD: sftp.c,v 1.37 2003/07/10 20:05:55 markus Exp $");
a44 1
static pid_t sshpid = -1;
d49 1
a49 10
killchild(int signo)
{
	if (sshpid > 1)
		kill(sshpid, signo);

	_exit(1);
}

static void
connect_to_server(char *path, char **args, int *in, int *out)
d71 1
a71 1
	if ((sshpid = fork()) == -1)
d73 1
a73 1
	else if (sshpid == 0) {
a87 3
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
d98 2
a99 3
	    "usage: %s [-vC1] [-b batchfile] [-o ssh_option] [-s subsystem | sftp_server]\n"
	    "            [-B buffer_size] [-F ssh_config] [-P sftp_server path]\n"
	    "            [-R num_requests] [-S program]\n"
d108 1
d225 2
a226 1
		connect_to_server(ssh_program, args.list, &in, &out);
d232 2
a233 1
		connect_to_server(sftp_direct, args.list, &in, &out);
@


1.30
log
@bunch of u_int vs int stuff
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.29 2002/04/02 17:37:48 markus Exp $");
a117 1
	addargs(&args, "-oFallBackToRsh no");
@


1.29
log
@always call log_init()
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.28 2002/03/30 18:51:15 markus Exp $");
d50 1
d53 1
d62 1
@


1.29.2.1
log
@Pull in OpenSSH-3.4
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.30 2002/06/23 09:30:14 deraadt Exp $");
a49 1

a51 1

a59 1

@


1.29.2.2
log
@Update to OpenSSH 3.5
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.31 2002/07/25 01:16:59 mouring Exp $");
d118 1
@


1.29.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.34 2003/01/10 08:19:07 fgsch Exp $");
a45 2
extern int showprogress;

d105 1
a105 1
	int in, out, ch, err;
a157 1
			showprogress = 0;
d193 1
a193 1
		if ((host = strrchr(userhost, '@@')) == NULL)
d233 1
a233 1
	err = interactive_loop(in, out, file1, file2);
d245 1
a245 1
	exit(err == 0 ? 0 : 1);
@


1.28
log
@check waitpid for EINTR; based on patch from peter@@ifm.liu.se
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.27 2002/03/19 10:49:35 markus Exp $");
d177 2
a207 1
		log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);
@


1.27
log
@KNF whitespace
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.26 2002/02/12 12:32:27 djm Exp $");
d237 4
a240 2
	if (waitpid(sshpid, NULL, 0) == -1)
		fatal("Couldn't wait for ssh process: %s", strerror(errno));
@


1.26
log
@Perform multiple overlapping read/write requests in file transfer. Mostly
done by Tobias Ringstrom <tori@@ringstrom.mine.nu>; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.25 2002/02/06 14:27:23 mpech Exp $");
d91 1
a91 1
	
d168 1
a168 1
				fatal("Invalid number of requests \"%s\"", 
d214 1
a214 1
		addargs(&args, "%s", (sftp_server != NULL ? 
d219 1
a219 1
		connect_to_server(ssh_program, args.list, &in, &out, 
d226 1
a226 1
		connect_to_server(sftp_direct, args.list, &in, &out, 
@


1.25
log
@sync usage() with manual.

markus@@ ok
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.24 2002/02/05 00:00:46 djm Exp $");
d44 1
d122 1
a122 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:B:F:P:")) != -1) {
d164 6
@


1.24
log
@Add "-B" option to specify copy buffer length (default 32k); ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.23 2002/02/04 21:53:12 djm Exp $");
d89 2
d92 3
a94 3
	    "usage: sftp [-1Cv] [-b batchfile] [-F config] [-o option] [-s subsystem|path]\n"
	    "            [-P direct server path] [-S program] \n"
	    "            [-B buffer_size] [user@@]host[:file [file]]\n");
@


1.23
log
@Add "-P" option to directly connect to a local sftp-server. Should be useful
for regression testing; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.22 2001/12/19 07:18:56 deraadt Exp $");
d43 1
d91 2
a92 1
	    "            [-S program] [user@@]host[:file [file]]\n");
d119 1
a119 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:F:P:")) != -1) {
d156 5
@


1.22
log
@basic KNF done while i was looking for something else
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Damien Miller.  All rights reserved.
d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.21 2001/09/19 19:24:19 stevesk Exp $");
a28 1
/* XXX: commandline mode */
a41 1
char *ssh_program = _PATH_SSH_PROGRAM;
d45 1
a45 1
connect_to_server(char **args, int *in, int *out, pid_t *sshpid)
d76 2
a77 2
		execv(ssh_program, args);
		fprintf(stderr, "exec: %s: %s\n", ssh_program, strerror(errno));
d102 1
d117 1
a117 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:F:")) != -1) {
d152 3
d161 6
a166 2
	if (optind == argc || argc > (optind + 2))
		usage();
d168 4
a171 2
	userhost = xstrdup(argv[optind]);
	file2 = argv[optind+1];
d173 10
a182 4
	if ((cp = colon(userhost)) != NULL) {
		*cp++ = '\0';
		file1 = cp;
	}
d184 3
a186 6
	if ((host = strchr(userhost, '@@')) == NULL)
		host = userhost;
	else {
		*host++ = '\0';
		if (!userhost[0]) {
			fprintf(stderr, "Missing username\n");
a188 2
		addargs(&args, "-l%s",userhost);
	}
d190 22
a211 4
	host = cleanhostname(host);
	if (!*host) {
		fprintf(stderr, "Missing hostname\n");
		usage();
a212 15

	log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);
	addargs(&args, "-oProtocol %d", sshver);

	/* no subsystem if the server-spec contains a '/' */
	if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
		addargs(&args, "-s");

	addargs(&args, "%s", host);
	addargs(&args, "%s", (sftp_server != NULL ? sftp_server : "sftp"));
	args.list[0] = ssh_program;

	fprintf(stderr, "Connecting to %s...\n", host);

	connect_to_server(args.list, &in, &out, &sshpid);
@


1.21
log
@add ClearAllForwardings ssh option and set it in scp and sftp; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.20 2001/09/17 20:38:09 stevesk Exp $");
d110 1
a110 1
	addargs(&args, "ssh");         /* overwritten with ssh_program */
d191 1
a191 1
	if (sftp_server == NULL || strchr(sftp_server, '/') == NULL) 
@


1.21.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.26 2002/02/12 12:32:27 djm Exp $");
d29 1
d43 1
a44 2
size_t copy_buffer_len = 32768;
size_t num_requests = 16;
d47 1
a47 1
connect_to_server(char *path, char **args, int *in, int *out, pid_t *sshpid)
d78 2
a79 2
		execv(path, args);
		fprintf(stderr, "exec: %s: %s\n", path, strerror(errno));
a89 2
	extern char *__progname;
	
d91 2
a92 3
	    "usage: %s [-vC1] [-b batchfile] [-o option] [-s subsystem|path] [-B buffer_size]\n"
	    "            [-F config] [-P direct server path] [-S program]\n"
	    "            [user@@]host[:file [file]]\n", __progname);
a103 1
	char *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;
d110 1
a110 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
d118 1
a118 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:B:F:P:R:")) != -1) {
a152 14
		case 'P':
			sftp_direct = optarg;
			break;
		case 'B':
			copy_buffer_len = strtol(optarg, &cp, 10);
			if (copy_buffer_len == 0 || *cp != '\0')
				fatal("Invalid buffer size \"%s\"", optarg);
			break;
		case 'R':
			num_requests = strtol(optarg, &cp, 10);
			if (num_requests == 0 || *cp != '\0')
				fatal("Invalid number of requests \"%s\"", 
				    optarg);
			break;
d159 17
a175 2
	if (sftp_direct == NULL) {
		if (optind == argc || argc > (optind + 2))
d177 3
d181 5
a185 2
		userhost = xstrdup(argv[optind]);
		file2 = argv[optind+1];
d187 2
a188 4
		if ((cp = colon(userhost)) != NULL) {
			*cp++ = '\0';
			file1 = cp;
		}
d190 3
a192 10
		if ((host = strchr(userhost, '@@')) == NULL)
			host = userhost;
		else {
			*host++ = '\0';
			if (!userhost[0]) {
				fprintf(stderr, "Missing username\n");
				usage();
			}
			addargs(&args, "-l%s",userhost);
		}
d194 3
a196 5
		host = cleanhostname(host);
		if (!*host) {
			fprintf(stderr, "Missing hostname\n");
			usage();
		}
d198 1
a198 2
		log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);
		addargs(&args, "-oProtocol %d", sshver);
d200 1
a200 20
		/* no subsystem if the server-spec contains a '/' */
		if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
			addargs(&args, "-s");

		addargs(&args, "%s", host);
		addargs(&args, "%s", (sftp_server != NULL ? 
		    sftp_server : "sftp"));
		args.list[0] = ssh_program;

		fprintf(stderr, "Connecting to %s...\n", host);
		connect_to_server(ssh_program, args.list, &in, &out, 
		    &sshpid);
	} else {
		args.list = NULL;
		addargs(&args, "sftp-server");

		fprintf(stderr, "Attaching to %s...\n", sftp_direct);
		connect_to_server(sftp_direct, args.list, &in, &out, 
		    &sshpid);
	}
@


1.21.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.29 2002/04/02 17:37:48 markus Exp $");
d91 1
a91 1

d168 1
a168 1
				fatal("Invalid number of requests \"%s\"",
a176 2
	log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);

d206 1
d214 1
a214 1
		addargs(&args, "%s", (sftp_server != NULL ?
d219 1
a219 1
		connect_to_server(ssh_program, args.list, &in, &out,
d226 1
a226 1
		connect_to_server(sftp_direct, args.list, &in, &out,
d237 2
a238 4
	while (waitpid(sshpid, NULL, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for ssh process: %s",
			    strerror(errno));
@


1.21.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.21.2.2 2002/05/17 00:03:24 miod Exp $");
a49 1

a51 1

a59 1

@


1.21.2.4
log
@Update to OpenSSH 3.5
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.31 2002/07/25 01:16:59 mouring Exp $");
d118 1
@


1.20
log
@cleanup and document -1, -s and -S; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.19 2001/09/17 17:57:57 stevesk Exp $");
d114 1
@


1.19
log
@add -Fssh_config option; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.18 2001/06/23 15:12:20 itojun Exp $");
d91 2
a92 2
	    "usage: sftp [-1vC] [-b batchfile] [-F config] [-o option]\n"
	    "            [user@@]host[:file [file]]\n");
@


1.18
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.17 2001/05/08 19:45:25 mouring Exp $");
d90 3
a92 1
	fprintf(stderr, "usage: sftp [-1vC] [-b batchfile] [-osshopt=value] [user@@]host[:file [file]]\n");
d117 1
a117 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:")) != -1) {
d129 1
d131 1
a131 1
			addargs(&args, "-o%s", optarg);
@


1.17
log
@Use addargs() in sftp plus some clean up of addargs().  OK Markus
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.16 2001/05/03 23:09:53 mouring Exp $");
d46 1
a46 1
void
d87 1
a87 1
void
@


1.16
log
@Move colon() and cleanhost() to misc.c where I should I have put it in
the first place
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.15 2001/04/16 02:31:44 mouring Exp $");
a42 1
int use_ssh1 = 0;
a43 1
char *sftp_server = NULL;
a86 52
char **
make_ssh_args(char *add_arg)
{
	static char **args = NULL;
	static int nargs = 0;
	char debug_buf[4096];
	int i;

	/* Init args array */
	if (args == NULL) {
		nargs = 2;
		i = 0;
		args = xmalloc(sizeof(*args) * nargs);
		args[i++] = "ssh";
		args[i++] = NULL;
	}

	/* If asked to add args, then do so and return */
	if (add_arg) {
		i = nargs++ - 1;
		args = xrealloc(args, sizeof(*args) * nargs);
		args[i++] = add_arg;
		args[i++] = NULL;
		return(NULL);
	}

	/* no subsystem if the server-spec contains a '/' */
	if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
		make_ssh_args("-s");
	make_ssh_args("-oForwardX11=no");
	make_ssh_args("-oForwardAgent=no");
	make_ssh_args(use_ssh1 ? "-oProtocol=1" : "-oProtocol=2");

	/* Otherwise finish up and return the arg array */
	if (sftp_server != NULL)
		make_ssh_args(sftp_server);
	else
		make_ssh_args("sftp");

	/* XXX: overflow - doesn't grow debug_buf */
	debug_buf[0] = '\0';
	for(i = 0; args[i]; i++) {
		if (i)
			strlcat(debug_buf, " ", sizeof(debug_buf));

		strlcat(debug_buf, args[i], sizeof(debug_buf));
	}
	debug("SSH args \"%s\"", debug_buf);

	return(args);
}

d97 1
a97 1
	int in, out, ch, debug_level, compress_flag;
a98 1
	char *file1 = NULL;
d100 4
a103 1
	LogLevel ll;
d107 6
a113 1
	debug_level = compress_flag = 0;
d118 1
a118 1
			compress_flag = 1;
d121 5
a125 1
			debug_level = MIN(3, debug_level + 1);
d128 1
a128 2
			make_ssh_args("-o");
			make_ssh_args(optarg);
d131 1
a131 1
			use_ssh1 = 1;
d174 1
a174 2
		make_ssh_args("-l");
		make_ssh_args(userhost);
d183 2
a184 19
	/* Set up logging and debug '-d' arguments to ssh */
	ll = SYSLOG_LEVEL_INFO;
	switch (debug_level) {
	case 1:
		ll = SYSLOG_LEVEL_DEBUG1;
		make_ssh_args("-v");
		break;
	case 2:
		ll = SYSLOG_LEVEL_DEBUG2;
		make_ssh_args("-v");
		make_ssh_args("-v");
		break;
	case 3:
		ll = SYSLOG_LEVEL_DEBUG3;
		make_ssh_args("-v");
		make_ssh_args("-v");
		make_ssh_args("-v");
		break;
	}
d186 3
a188 4
	if (compress_flag)
		make_ssh_args("-C");

	log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);
d190 3
a192 1
	make_ssh_args(host);
d196 1
a196 1
	connect_to_server(make_ssh_args(NULL), &in, &out, &sshpid);
@


1.15
log
@IPv6 support for sftp (which I bungled in my last patch) which is
borrowed from scp.c.  Thanks to Markus@@ for pointing it out.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.14 2001/04/12 23:17:54 mouring Exp $");
d36 1
a41 2

#include "scp-common.h"
@


1.15.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.21 2001/09/19 19:24:19 stevesk Exp $");
a35 1
#include "misc.h"
d42 3
d46 1
d49 1
a49 1
static void
d90 53
a142 1
static void
d145 1
a145 3
	fprintf(stderr,
	    "usage: sftp [-1Cv] [-b batchfile] [-F config] [-o option] [-s subsystem|path]\n"
	    "            [-S program] [user@@]host[:file [file]]\n");
d152 1
a152 1
	int in, out, ch;
d154 1
d156 1
a156 4
	int debug_level = 0, sshver = 2;
	char *file1 = NULL, *sftp_server = NULL;
	LogLevel ll = SYSLOG_LEVEL_INFO;
	arglist args;
a159 7
	args.list = NULL;
	addargs(&args, "ssh");         /* overwritten with ssh_program */
	addargs(&args, "-oFallBackToRsh no");
	addargs(&args, "-oForwardX11 no");
	addargs(&args, "-oForwardAgent no");
	addargs(&args, "-oClearAllForwardings yes");
	ll = SYSLOG_LEVEL_INFO;
d161 1
d163 1
a163 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:F:")) != -1) {
d166 1
a166 1
			addargs(&args, "-C");
d169 1
a169 5
			if (debug_level < 3) {
				addargs(&args, "-v");
				ll = SYSLOG_LEVEL_DEBUG1 + debug_level;
			}
			debug_level++;
a170 1
		case 'F':
d172 2
a173 1
			addargs(&args, "-%c%s", ch, optarg);
d176 1
a176 1
			sshver = 1;
d219 2
a220 1
		addargs(&args, "-l%s",userhost);
d229 23
a252 5
	addargs(&args, "-oProtocol %d", sshver);

	/* no subsystem if the server-spec contains a '/' */
	if (sftp_server == NULL || strchr(sftp_server, '/') == NULL) 
		addargs(&args, "-s");
d254 1
a254 3
	addargs(&args, "%s", host);
	addargs(&args, "%s", (sftp_server != NULL ? sftp_server : "sftp"));
	args.list[0] = ssh_program;
d258 1
a258 1
	connect_to_server(args.list, &in, &out, &sshpid);
@


1.15.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.26 2002/02/12 12:32:27 djm Exp $");
d29 1
d43 1
a44 2
size_t copy_buffer_len = 32768;
size_t num_requests = 16;
d47 1
a47 1
connect_to_server(char *path, char **args, int *in, int *out, pid_t *sshpid)
d78 2
a79 2
		execv(path, args);
		fprintf(stderr, "exec: %s: %s\n", path, strerror(errno));
a89 2
	extern char *__progname;
	
d91 2
a92 3
	    "usage: %s [-vC1] [-b batchfile] [-o option] [-s subsystem|path] [-B buffer_size]\n"
	    "            [-F config] [-P direct server path] [-S program]\n"
	    "            [user@@]host[:file [file]]\n", __progname);
a103 1
	char *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;
d110 1
a110 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
d118 1
a118 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:B:F:P:R:")) != -1) {
a152 14
		case 'P':
			sftp_direct = optarg;
			break;
		case 'B':
			copy_buffer_len = strtol(optarg, &cp, 10);
			if (copy_buffer_len == 0 || *cp != '\0')
				fatal("Invalid buffer size \"%s\"", optarg);
			break;
		case 'R':
			num_requests = strtol(optarg, &cp, 10);
			if (num_requests == 0 || *cp != '\0')
				fatal("Invalid number of requests \"%s\"", 
				    optarg);
			break;
d159 17
a175 2
	if (sftp_direct == NULL) {
		if (optind == argc || argc > (optind + 2))
d177 3
d181 5
a185 2
		userhost = xstrdup(argv[optind]);
		file2 = argv[optind+1];
d187 2
a188 4
		if ((cp = colon(userhost)) != NULL) {
			*cp++ = '\0';
			file1 = cp;
		}
d190 3
a192 10
		if ((host = strchr(userhost, '@@')) == NULL)
			host = userhost;
		else {
			*host++ = '\0';
			if (!userhost[0]) {
				fprintf(stderr, "Missing username\n");
				usage();
			}
			addargs(&args, "-l%s",userhost);
		}
d194 3
a196 5
		host = cleanhostname(host);
		if (!*host) {
			fprintf(stderr, "Missing hostname\n");
			usage();
		}
d198 1
a198 2
		log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);
		addargs(&args, "-oProtocol %d", sshver);
d200 1
a200 20
		/* no subsystem if the server-spec contains a '/' */
		if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
			addargs(&args, "-s");

		addargs(&args, "%s", host);
		addargs(&args, "%s", (sftp_server != NULL ? 
		    sftp_server : "sftp"));
		args.list[0] = ssh_program;

		fprintf(stderr, "Connecting to %s...\n", host);
		connect_to_server(ssh_program, args.list, &in, &out, 
		    &sshpid);
	} else {
		args.list = NULL;
		addargs(&args, "sftp-server");

		fprintf(stderr, "Attaching to %s...\n", sftp_direct);
		connect_to_server(sftp_direct, args.list, &in, &out, 
		    &sshpid);
	}
@


1.15.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.29 2002/04/02 17:37:48 markus Exp $");
d91 1
a91 1

d168 1
a168 1
				fatal("Invalid number of requests \"%s\"",
a176 2
	log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);

d206 1
d214 1
a214 1
		addargs(&args, "%s", (sftp_server != NULL ?
d219 1
a219 1
		connect_to_server(ssh_program, args.list, &in, &out,
d226 1
a226 1
		connect_to_server(sftp_direct, args.list, &in, &out,
d237 2
a238 4
	while (waitpid(sshpid, NULL, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for ssh process: %s",
			    strerror(errno));
@


1.14
log
@Add support for:
	sftp [user@@]host[:file [file]]	- Fetch remote file(s)
	sftp [user@@]host[:dir[/]]	- Start in remote dir/
OK deraadt@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.13 2001/04/08 20:52:55 deraadt Exp $");
a29 1
/* XXX: copy between two remote hosts (commandline) */
d42 2
d206 1
a206 1
	if ((cp = strchr(userhost, ':')) != NULL) {
d223 1
@


1.13
log
@do not modify an actual argv[] entry
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.12 2001/04/05 10:42:54 markus Exp $");
d144 1
a144 1
	fprintf(stderr, "usage: sftp [-1vC] [-b batchfile] [-osshopt=value] [user@@]host\n");
d153 2
a154 1
	char *host, *userhost;
d199 1
a199 1
	if (optind == argc || argc > (optind + 1))
d203 6
d213 1
a213 1
		*host = '\0';
a219 1
		host++;
d258 1
a258 1
	interactive_loop(in, out);
@


1.12
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.11 2001/03/07 10:11:23 djm Exp $");
d201 1
a201 1
	userhost = argv[optind];
@


1.11
log
@Support for new draft (draft-ietf-secsh-filexfer-01). New symlink handling
functions and small protocol change.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.10 2001/03/06 06:11:44 deraadt Exp $");
d187 1
a187 1
				if (infile == NULL) 
d189 1
a189 1
			} else 
@


1.11.2.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.7 2001/02/08 00:04:52 markus Exp $");
d46 1
d95 1
a95 6
	int i, use_subsystem = 1;

	/* no subsystem if protocol 1 or the server-spec contains a '/' */
	if (use_ssh1 ||
	    (sftp_server != NULL && strchr(sftp_server, '/') != NULL))
		use_subsystem = 0;
d99 1
a99 1
		nargs = use_subsystem ? 6 : 5;
a102 5
		args[i++] = use_ssh1 ? "-oProtocol=1" : "-oProtocol=2";
		if (use_subsystem)
			args[i++] = "-s";
		args[i++] = "-oForwardAgent=no";
		args[i++] = "-oForwardX11=no";
d115 7
d144 1
a144 1
	fprintf(stderr, "usage: sftp [-1vC] [-osshopt=value] [user@@]host\n");
d158 1
d161 1
a161 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:")) != -1) {
d184 8
a251 2
	do_init(in, out);

d256 2
a257 3

	if (kill(sshpid, SIGHUP) == -1)
		fatal("Couldn't terminate ssh process: %s", strerror(errno));
@


1.11.2.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.11 2001/03/07 10:11:23 djm Exp $");
a45 1
FILE* infile;
d94 6
a99 1
	int i;
d103 1
a103 1
		nargs = 2;
d107 5
a123 7
	/* no subsystem if the server-spec contains a '/' */
	if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
		make_ssh_args("-s");
	make_ssh_args("-oForwardX11=no");
	make_ssh_args("-oForwardAgent=no");
	make_ssh_args(use_ssh1 ? "-oProtocol=1" : "-oProtocol=2");

d146 1
a146 1
	fprintf(stderr, "usage: sftp [-1vC] [-b batchfile] [-osshopt=value] [user@@]host\n");
a159 1
	infile = stdin;		/* Read from STDIN unless changed by -b */
d162 1
a162 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:")) != -1) {
a184 8
		case 'b':
			if (infile == stdin) {
				infile = fopen(optarg, "r");
				if (infile == NULL) 
					fatal("%s (%s).", strerror(errno), optarg);
			} else 
				fatal("Filename already specified.");
			break;
d245 2
d251 3
a253 2
	if (infile != stdin)
		fclose(infile);
@


1.10
log
@sftp -b batchfile; mouring@@etoh.eviladmin.org
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.9 2001/03/03 23:52:22 markus Exp $");
a250 2

	do_init(in, out);
@


1.9
log
@clean up arg processing. based on work by Christophe_Moret@@hp.com
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.8 2001/02/28 05:36:28 deraadt Exp $");
d46 1
d144 1
a144 1
	fprintf(stderr, "usage: sftp [-1vC] [-osshopt=value] [user@@]host\n");
d158 1
d161 1
a161 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:")) != -1) {
d184 8
d258 2
@


1.8
log
@do not kill the subprocess on termination (we will see if this helps things
or hurts things)
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.7 2001/02/08 00:04:52 markus Exp $");
d94 1
a94 6
	int i, use_subsystem = 1;

	/* no subsystem if protocol 1 or the server-spec contains a '/' */
	if (use_ssh1 ||
	    (sftp_server != NULL && strchr(sftp_server, '/') != NULL))
		use_subsystem = 0;
d98 1
a98 1
		nargs = use_subsystem ? 6 : 5;
a101 5
		args[i++] = use_ssh1 ? "-oProtocol=1" : "-oProtocol=2";
		if (use_subsystem)
			args[i++] = "-s";
		args[i++] = "-oForwardAgent=no";
		args[i++] = "-oForwardX11=no";
d113 7
@


1.7
log
@allow sftp over ssh protocol 1; ok djm@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.6 2001/02/07 22:27:18 djm Exp $");
a250 3

	if (kill(sshpid, SIGHUP) == -1)
		fatal("Couldn't terminate ssh process: %s", strerror(errno));
@


1.7.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.7 2001/02/08 00:04:52 markus Exp $");
@


1.7.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.7.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.11 2001/03/07 10:11:23 djm Exp $");
a45 1
FILE* infile;
d94 6
a99 1
	int i;
d103 1
a103 1
		nargs = 2;
d107 5
a123 7
	/* no subsystem if the server-spec contains a '/' */
	if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
		make_ssh_args("-s");
	make_ssh_args("-oForwardX11=no");
	make_ssh_args("-oForwardAgent=no");
	make_ssh_args(use_ssh1 ? "-oProtocol=1" : "-oProtocol=2");

d146 1
a146 1
	fprintf(stderr, "usage: sftp [-1vC] [-b batchfile] [-osshopt=value] [user@@]host\n");
a159 1
	infile = stdin;		/* Read from STDIN unless changed by -b */
d162 1
a162 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:")) != -1) {
a184 8
		case 'b':
			if (infile == stdin) {
				infile = fopen(optarg, "r");
				if (infile == NULL) 
					fatal("%s (%s).", strerror(errno), optarg);
			} else 
				fatal("Filename already specified.");
			break;
d245 2
d251 3
a253 2
	if (infile != stdin)
		fclose(infile);
@


1.7.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.15 2001/04/16 02:31:44 mouring Exp $");
d30 1
a42 2
#include "scp-common.h"

d144 1
a144 1
	fprintf(stderr, "usage: sftp [-1vC] [-b batchfile] [-osshopt=value] [user@@]host[:file [file]]\n");
d153 1
a153 2
	char *file1 = NULL;
	char *host, *userhost, *cp, *file2;
d187 1
a187 1
				if (infile == NULL)
d189 1
a189 1
			} else
d198 1
a198 1
	if (optind == argc || argc > (optind + 2))
d201 1
a201 7
	userhost = xstrdup(argv[optind]);
	file2 = argv[optind+1];

	if ((cp = colon(userhost)) != NULL) {
		*cp++ = '\0';
		file1 = cp;
	}
d206 1
a206 1
		*host++ = '\0';
d213 1
a215 1
	host = cleanhostname(host);
d252 1
a252 1
	interactive_loop(in, out, file1, file2);
@


1.7.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.21 2001/09/19 19:24:19 stevesk Exp $");
a35 1
#include "misc.h"
d42 3
d46 1
d49 1
a49 1
static void
d90 53
a142 1
static void
d145 1
a145 3
	fprintf(stderr,
	    "usage: sftp [-1Cv] [-b batchfile] [-F config] [-o option] [-s subsystem|path]\n"
	    "            [-S program] [user@@]host[:file [file]]\n");
d152 1
a152 1
	int in, out, ch;
d154 1
d156 1
a156 4
	int debug_level = 0, sshver = 2;
	char *file1 = NULL, *sftp_server = NULL;
	LogLevel ll = SYSLOG_LEVEL_INFO;
	arglist args;
a159 7
	args.list = NULL;
	addargs(&args, "ssh");         /* overwritten with ssh_program */
	addargs(&args, "-oFallBackToRsh no");
	addargs(&args, "-oForwardX11 no");
	addargs(&args, "-oForwardAgent no");
	addargs(&args, "-oClearAllForwardings yes");
	ll = SYSLOG_LEVEL_INFO;
d161 1
d163 1
a163 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:F:")) != -1) {
d166 1
a166 1
			addargs(&args, "-C");
d169 1
a169 5
			if (debug_level < 3) {
				addargs(&args, "-v");
				ll = SYSLOG_LEVEL_DEBUG1 + debug_level;
			}
			debug_level++;
a170 1
		case 'F':
d172 2
a173 1
			addargs(&args, "-%c%s", ch, optarg);
d176 1
a176 1
			sshver = 1;
d219 2
a220 1
		addargs(&args, "-l%s",userhost);
d229 23
a252 5
	addargs(&args, "-oProtocol %d", sshver);

	/* no subsystem if the server-spec contains a '/' */
	if (sftp_server == NULL || strchr(sftp_server, '/') == NULL) 
		addargs(&args, "-s");
d254 1
a254 3
	addargs(&args, "%s", host);
	addargs(&args, "%s", (sftp_server != NULL ? sftp_server : "sftp"));
	args.list[0] = ssh_program;
d258 1
a258 1
	connect_to_server(args.list, &in, &out, &sshpid);
@


1.7.2.6
log
@Merge OpenSSH 3.1.
@
text
@d2 1
a2 1
 * Copyright (c) 2001,2002 Damien Miller.  All rights reserved.
d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.26 2002/02/12 12:32:27 djm Exp $");
d29 1
d43 1
a44 2
size_t copy_buffer_len = 32768;
size_t num_requests = 16;
d47 1
a47 1
connect_to_server(char *path, char **args, int *in, int *out, pid_t *sshpid)
d78 2
a79 2
		execv(path, args);
		fprintf(stderr, "exec: %s: %s\n", path, strerror(errno));
a89 2
	extern char *__progname;
	
d91 2
a92 3
	    "usage: %s [-vC1] [-b batchfile] [-o option] [-s subsystem|path] [-B buffer_size]\n"
	    "            [-F config] [-P direct server path] [-S program]\n"
	    "            [user@@]host[:file [file]]\n", __progname);
a103 1
	char *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;
d110 1
a110 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
d118 1
a118 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:B:F:P:R:")) != -1) {
a152 14
		case 'P':
			sftp_direct = optarg;
			break;
		case 'B':
			copy_buffer_len = strtol(optarg, &cp, 10);
			if (copy_buffer_len == 0 || *cp != '\0')
				fatal("Invalid buffer size \"%s\"", optarg);
			break;
		case 'R':
			num_requests = strtol(optarg, &cp, 10);
			if (num_requests == 0 || *cp != '\0')
				fatal("Invalid number of requests \"%s\"", 
				    optarg);
			break;
d159 17
a175 2
	if (sftp_direct == NULL) {
		if (optind == argc || argc > (optind + 2))
d177 3
d181 5
a185 2
		userhost = xstrdup(argv[optind]);
		file2 = argv[optind+1];
d187 2
a188 4
		if ((cp = colon(userhost)) != NULL) {
			*cp++ = '\0';
			file1 = cp;
		}
d190 3
a192 10
		if ((host = strchr(userhost, '@@')) == NULL)
			host = userhost;
		else {
			*host++ = '\0';
			if (!userhost[0]) {
				fprintf(stderr, "Missing username\n");
				usage();
			}
			addargs(&args, "-l%s",userhost);
		}
d194 3
a196 5
		host = cleanhostname(host);
		if (!*host) {
			fprintf(stderr, "Missing hostname\n");
			usage();
		}
d198 1
a198 2
		log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);
		addargs(&args, "-oProtocol %d", sshver);
d200 1
a200 20
		/* no subsystem if the server-spec contains a '/' */
		if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
			addargs(&args, "-s");

		addargs(&args, "%s", host);
		addargs(&args, "%s", (sftp_server != NULL ? 
		    sftp_server : "sftp"));
		args.list[0] = ssh_program;

		fprintf(stderr, "Connecting to %s...\n", host);
		connect_to_server(ssh_program, args.list, &in, &out, 
		    &sshpid);
	} else {
		args.list = NULL;
		addargs(&args, "sftp-server");

		fprintf(stderr, "Attaching to %s...\n", sftp_direct);
		connect_to_server(sftp_direct, args.list, &in, &out, 
		    &sshpid);
	}
@


1.6
log
@Don't forward agent and X11 in sftp. Suggestion from Roumen Petrov
<roumen.petrov@@skalasoft.com>
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.5 2001/02/06 23:53:54 djm Exp $");
d43 4
d79 2
a80 2
		execv(_PATH_SSH_PROGRAM, args);
		fprintf(stderr, "exec: %s", strerror(errno));
d94 6
a99 1
	int i;
d103 1
a103 1
		nargs = 6;
d107 3
a109 1
		args[i++] = "-oProtocol=2";
a111 1
		args[i++] = "-s";
d125 4
a128 1
	make_ssh_args("sftp");
d146 1
a146 1
	fprintf(stderr, "usage: sftp [-vC] [-osshopt=value] [user@@]host\n");
d162 1
a162 1
	while ((ch = getopt(argc, argv, "hCvo:")) != -1) {
d173 11
@


1.5
log
@Fix -o option under getopt; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.4 2001/02/06 22:06:21 djm Exp $");
d94 1
a94 1
		nargs = 4;
d99 2
@


1.4
log
@Wait for ssh subprocess at exit
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.3 2001/02/06 22:05:25 djm Exp $");
d156 1
@


1.3
log
@Use getopt to process commandline arguments
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.2 2001/02/04 15:32:25 stevesk Exp $");
d228 2
a229 1
	/* XXX: wait? */
@


1.2
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: sftp.c,v 1.1 2001/02/04 11:11:54 djm Exp $");
d138 1
a138 1
	int in, out, i, debug_level, compress_flag;
d140 1
a140 1
	char *cp;
d142 2
d146 7
a152 2
	for(i = 1; i < argc && argv[i][0] == '-'; i++) {
		if (!strcmp(argv[i], "-v"))
d154 6
a159 6
		else if (!strcmp(argv[i], "-C"))
			compress_flag = 1;
		else if (!strncmp(argv[i], "-o", 2)) {
			make_ssh_args(argv[i]);
		} else {
			fprintf(stderr, "Unknown option \"%s\"\n", argv[i]);
d164 1
a164 1
	if (i == argc || argc > (i + 1))
d167 4
a170 2
	if ((cp = strchr(argv[i], '@@')) == NULL)
		cp = argv[i];
d172 2
a173 2
		*cp = '\0';
		if (!argv[i][0]) {
d178 2
a179 2
		make_ssh_args(argv[i]);
		cp++;
d182 1
a182 1
	if (!*cp) {
d212 1
a212 1
	make_ssh_args(cp);
d214 1
a214 1
	fprintf(stderr, "Connecting to %s...\n", cp);
@


1.1
log
@Basic interactive sftp client; ok theo@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD$");
d128 1
a128 1
void 
d135 1
a135 1
int 
@

