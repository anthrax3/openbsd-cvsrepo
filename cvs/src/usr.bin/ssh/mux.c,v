head	1.64;
access;
symbols
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.60.0.4
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.53.0.2
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.44.0.6
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7;
locks; strict;
comment	@ * @;


1.64
date	2017.01.21.11.32.04;	author guenther;	state Exp;
branches;
next	1.63;
commitid	DpBZlpar7mq0CJFq;

1.63
date	2016.10.19.23.21.56;	author dtucker;	state Exp;
branches;
next	1.62;
commitid	yUZ0PF9LzwPwr2cb;

1.62
date	2016.09.30.09.19.13;	author markus;	state Exp;
branches;
next	1.61;
commitid	VHQRRel9yTEUINVH;

1.61
date	2016.08.08.22.40.57;	author dtucker;	state Exp;
branches;
next	1.60;
commitid	T2FDSClB6AMWSkCh;

1.60
date	2016.06.03.03.14.41;	author dtucker;	state Exp;
branches;
next	1.59;
commitid	ovpSdW3xBjKJO7iw;

1.59
date	2016.04.01.02.34.10;	author djm;	state Exp;
branches;
next	1.58;
commitid	sECjUqssZeusxK4n;

1.58
date	2016.01.13.23.04.47;	author djm;	state Exp;
branches;
next	1.57;
commitid	ALMWb9LK721aNRnl;

1.57
date	2015.12.26.07.46.03;	author semarie;	state Exp;
branches;
next	1.56;
commitid	9bx9feiyf0CCkRyA;

1.56
date	2015.12.03.17.00.18;	author semarie;	state Exp;
branches;
next	1.55;
commitid	m8AGU3kOgtFV5kYk;

1.55
date	2015.10.15.23.51.40;	author djm;	state Exp;
branches;
next	1.54;
commitid	Zt9fWcnXm9hrhBex;

1.54
date	2015.08.19.23.18.26;	author djm;	state Exp;
branches;
next	1.53;
commitid	cHNZJRUq4KtLwQS7;

1.53
date	2015.05.01.04.03.20;	author djm;	state Exp;
branches
	1.53.2.1;
next	1.52;
commitid	UeeUTvpn5ZlNFdWM;

1.52
date	2015.05.01.04.01.58;	author djm;	state Exp;
branches;
next	1.51;
commitid	nGFo94GGRPmS71Mg;

1.51
date	2015.04.24.01.36.00;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	LHkUmZjv49ojnnuH;

1.50
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches
	1.50.2.1;
next	1.49;
commitid	cBx23BaCk6gYBpRj;

1.49
date	2014.12.22.07.24.11;	author djm;	state Exp;
branches;
next	1.48;
commitid	3v40v27xS4eA4ds0;

1.48
date	2014.07.17.07.22.19;	author djm;	state Exp;
branches;
next	1.47;
commitid	TDWPfvKEryjfRthw;

1.47
date	2014.07.17.00.10.18;	author djm;	state Exp;
branches;
next	1.46;
commitid	2X6JVow9Ov4mzkAz;

1.46
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.45;
commitid	z7plx8Gkj6l2sxem;

1.45
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2013.07.12.00.19.58;	author djm;	state Exp;
branches;
next	1.43;

1.43
date	2013.06.05.02.07.29;	author dtucker;	state Exp;
branches;
next	1.42;

1.42
date	2013.06.02.23.36.29;	author dtucker;	state Exp;
branches;
next	1.41;

1.41
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2013.04.22.01.17.18;	author dtucker;	state Exp;
branches;
next	1.39;

1.39
date	2013.04.05.00.58.51;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2013.01.02.00.32.07;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2012.08.17.00.45.45;	author dtucker;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.06.01.37.21;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2012.06.01.01.01.22;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.07.21.11.36;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.04.23.16.12;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.02.00.41.56;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2011.09.23.07.45.05;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2011.09.09.22.46.44;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.22.22.08.42;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.08.12.52.01;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.06.21.34.32;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.05.05.12.08;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.17.22.42.41;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.13.21.54.53;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.12.02.22.24;	author dtucker;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.20.07.19.27;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.25.23.15.36;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.25.07.14.46;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.17.07.07.30;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.16.12.55.51;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.14.23.29.23;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.23.22.27.38;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.10.05.48.16;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.30.02.54.53;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.29.20.16.17;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.27.13.26.17;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.26.02.15.20;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.26.01.28.35;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.09.05.04.24;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.20.23.54.28;	author dtucker;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.13.17.21.20;	author dtucker;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.13.00.47.53;	author dtucker;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.13.00.16.49;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.12.15.19.17;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.12.05.32.30;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.12.03.40.52;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.09.14.18.44;	author djm;	state Exp;
branches;
next	;

1.50.2.1
date	2016.01.14.11.53.20;	author sthen;	state Exp;
branches;
next	;
commitid	T6tcqH9MXVck1Xkf;

1.53.2.1
date	2016.01.14.11.50.37;	author sthen;	state Exp;
branches;
next	;
commitid	kuomKbPjnfGwrKrZ;


desc
@@


1.64
log
@The POSIX APIs that that sockaddrs all ignore the s*_len field in the
incoming socket, so userspace doesn't need to set it unless it has its
own reasons for tracking the size along with the sockaddr.

ok phessler@@ deraadt@@ florian@@
@
text
@/* $OpenBSD: mux.c,v 1.63 2016/10/19 23:21:56 dtucker Exp $ */
/*
 * Copyright (c) 2002-2008 Damien Miller <djm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* ssh session multiplexing support */

/*
 * TODO:
 *   - Better signalling from master to slave, especially passing of
 *      error messages
 *   - Better fall-back from mux slave error to new connection.
 *   - ExitOnForwardingFailure
 *   - Maybe extension mechanisms for multi-X11/multi-agent forwarding
 *   - Support ~^Z in mux slaves.
 *   - Inspect or control sessions in master.
 *   - If we ever support the "signal" channel request, send signals on
 *     sessions in master.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>
#include <paths.h>

#include "atomicio.h"
#include "xmalloc.h"
#include "log.h"
#include "ssh.h"
#include "ssh2.h"
#include "pathnames.h"
#include "misc.h"
#include "match.h"
#include "buffer.h"
#include "channels.h"
#include "msg.h"
#include "packet.h"
#include "monitor_fdpass.h"
#include "sshpty.h"
#include "key.h"
#include "readconf.h"
#include "clientloop.h"
#include "ssherr.h"

/* from ssh.c */
extern int tty_flag;
extern Options options;
extern int stdin_null_flag;
extern char *host;
extern int subsystem_flag;
extern Buffer command;
extern volatile sig_atomic_t quit_pending;

/* Context for session open confirmation callback */
struct mux_session_confirm_ctx {
	u_int want_tty;
	u_int want_subsys;
	u_int want_x_fwd;
	u_int want_agent_fwd;
	Buffer cmd;
	char *term;
	struct termios tio;
	char **env;
	u_int rid;
};

/* Context for stdio fwd open confirmation callback */
struct mux_stdio_confirm_ctx {
	u_int rid;
};

/* Context for global channel callback */
struct mux_channel_confirm_ctx {
	u_int cid;	/* channel id */
	u_int rid;	/* request id */
	int fid;	/* forward id */
};

/* fd to control socket */
int muxserver_sock = -1;

/* client request id */
u_int muxclient_request_id = 0;

/* Multiplexing control command */
u_int muxclient_command = 0;

/* Set when signalled. */
static volatile sig_atomic_t muxclient_terminate = 0;

/* PID of multiplex server */
static u_int muxserver_pid = 0;

static Channel *mux_listener_channel = NULL;

struct mux_master_state {
	int hello_rcvd;
};

/* mux protocol messages */
#define MUX_MSG_HELLO		0x00000001
#define MUX_C_NEW_SESSION	0x10000002
#define MUX_C_ALIVE_CHECK	0x10000004
#define MUX_C_TERMINATE		0x10000005
#define MUX_C_OPEN_FWD		0x10000006
#define MUX_C_CLOSE_FWD		0x10000007
#define MUX_C_NEW_STDIO_FWD	0x10000008
#define MUX_C_STOP_LISTENING	0x10000009
#define MUX_C_PROXY		0x1000000f
#define MUX_S_OK		0x80000001
#define MUX_S_PERMISSION_DENIED	0x80000002
#define MUX_S_FAILURE		0x80000003
#define MUX_S_EXIT_MESSAGE	0x80000004
#define MUX_S_ALIVE		0x80000005
#define MUX_S_SESSION_OPENED	0x80000006
#define MUX_S_REMOTE_PORT	0x80000007
#define MUX_S_TTY_ALLOC_FAIL	0x80000008
#define MUX_S_PROXY		0x8000000f

/* type codes for MUX_C_OPEN_FWD and MUX_C_CLOSE_FWD */
#define MUX_FWD_LOCAL   1
#define MUX_FWD_REMOTE  2
#define MUX_FWD_DYNAMIC 3

static void mux_session_confirm(int, int, void *);
static void mux_stdio_confirm(int, int, void *);

static int process_mux_master_hello(u_int, Channel *, Buffer *, Buffer *);
static int process_mux_new_session(u_int, Channel *, Buffer *, Buffer *);
static int process_mux_alive_check(u_int, Channel *, Buffer *, Buffer *);
static int process_mux_terminate(u_int, Channel *, Buffer *, Buffer *);
static int process_mux_open_fwd(u_int, Channel *, Buffer *, Buffer *);
static int process_mux_close_fwd(u_int, Channel *, Buffer *, Buffer *);
static int process_mux_stdio_fwd(u_int, Channel *, Buffer *, Buffer *);
static int process_mux_stop_listening(u_int, Channel *, Buffer *, Buffer *);
static int process_mux_proxy(u_int, Channel *, Buffer *, Buffer *);

static const struct {
	u_int type;
	int (*handler)(u_int, Channel *, Buffer *, Buffer *);
} mux_master_handlers[] = {
	{ MUX_MSG_HELLO, process_mux_master_hello },
	{ MUX_C_NEW_SESSION, process_mux_new_session },
	{ MUX_C_ALIVE_CHECK, process_mux_alive_check },
	{ MUX_C_TERMINATE, process_mux_terminate },
	{ MUX_C_OPEN_FWD, process_mux_open_fwd },
	{ MUX_C_CLOSE_FWD, process_mux_close_fwd },
	{ MUX_C_NEW_STDIO_FWD, process_mux_stdio_fwd },
	{ MUX_C_STOP_LISTENING, process_mux_stop_listening },
	{ MUX_C_PROXY, process_mux_proxy },
	{ 0, NULL }
};

/* Cleanup callback fired on closure of mux slave _session_ channel */
/* ARGSUSED */
static void
mux_master_session_cleanup_cb(int cid, void *unused)
{
	Channel *cc, *c = channel_by_id(cid);

	debug3("%s: entering for channel %d", __func__, cid);
	if (c == NULL)
		fatal("%s: channel_by_id(%i) == NULL", __func__, cid);
	if (c->ctl_chan != -1) {
		if ((cc = channel_by_id(c->ctl_chan)) == NULL)
			fatal("%s: channel %d missing control channel %d",
			    __func__, c->self, c->ctl_chan);
		c->ctl_chan = -1;
		cc->remote_id = -1;
		chan_rcvd_oclose(cc);
	}
	channel_cancel_cleanup(c->self);
}

/* Cleanup callback fired on closure of mux slave _control_ channel */
/* ARGSUSED */
static void
mux_master_control_cleanup_cb(int cid, void *unused)
{
	Channel *sc, *c = channel_by_id(cid);

	debug3("%s: entering for channel %d", __func__, cid);
	if (c == NULL)
		fatal("%s: channel_by_id(%i) == NULL", __func__, cid);
	if (c->remote_id != -1) {
		if ((sc = channel_by_id(c->remote_id)) == NULL)
			fatal("%s: channel %d missing session channel %d",
			    __func__, c->self, c->remote_id);
		c->remote_id = -1;
		sc->ctl_chan = -1;
		if (sc->type != SSH_CHANNEL_OPEN &&
		    sc->type != SSH_CHANNEL_OPENING) {
			debug2("%s: channel %d: not open", __func__, sc->self);
			chan_mark_dead(sc);
		} else {
			if (sc->istate == CHAN_INPUT_OPEN)
				chan_read_failed(sc);
			if (sc->ostate == CHAN_OUTPUT_OPEN)
				chan_write_failed(sc);
		}
	}
	channel_cancel_cleanup(c->self);
}

/* Check mux client environment variables before passing them to mux master. */
static int
env_permitted(char *env)
{
	int i, ret;
	char name[1024], *cp;

	if ((cp = strchr(env, '=')) == NULL || cp == env)
		return 0;
	ret = snprintf(name, sizeof(name), "%.*s", (int)(cp - env), env);
	if (ret <= 0 || (size_t)ret >= sizeof(name)) {
		error("env_permitted: name '%.100s...' too long", env);
		return 0;
	}

	for (i = 0; i < options.num_send_env; i++)
		if (match_pattern(name, options.send_env[i]))
			return 1;

	return 0;
}

/* Mux master protocol message handlers */

static int
process_mux_master_hello(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	u_int ver;
	struct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;

	if (state == NULL)
		fatal("%s: channel %d: c->mux_ctx == NULL", __func__, c->self);
	if (state->hello_rcvd) {
		error("%s: HELLO received twice", __func__);
		return -1;
	}
	if (buffer_get_int_ret(&ver, m) != 0) {
 malf:
		error("%s: malformed message", __func__);
		return -1;
	}
	if (ver != SSHMUX_VER) {
		error("Unsupported multiplexing protocol version %d "
		    "(expected %d)", ver, SSHMUX_VER);
		return -1;
	}
	debug2("%s: channel %d slave version %u", __func__, c->self, ver);

	/* No extensions are presently defined */
	while (buffer_len(m) > 0) {
		char *name = buffer_get_string_ret(m, NULL);
		char *value = buffer_get_string_ret(m, NULL);

		if (name == NULL || value == NULL) {
			free(name);
			free(value);
			goto malf;
		}
		debug2("Unrecognised slave extension \"%s\"", name);
		free(name);
		free(value);
	}
	state->hello_rcvd = 1;
	return 0;
}

static int
process_mux_new_session(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	Channel *nc;
	struct mux_session_confirm_ctx *cctx;
	char *reserved, *cmd, *cp;
	u_int i, j, len, env_len, escape_char, window, packetmax;
	int new_fd[3];

	/* Reply for SSHMUX_COMMAND_OPEN */
	cctx = xcalloc(1, sizeof(*cctx));
	cctx->term = NULL;
	cctx->rid = rid;
	cmd = reserved = NULL;
	cctx->env = NULL;
	env_len = 0;
	if ((reserved = buffer_get_string_ret(m, NULL)) == NULL ||
	    buffer_get_int_ret(&cctx->want_tty, m) != 0 ||
	    buffer_get_int_ret(&cctx->want_x_fwd, m) != 0 ||
	    buffer_get_int_ret(&cctx->want_agent_fwd, m) != 0 ||
	    buffer_get_int_ret(&cctx->want_subsys, m) != 0 ||
	    buffer_get_int_ret(&escape_char, m) != 0 ||
	    (cctx->term = buffer_get_string_ret(m, &len)) == NULL ||
	    (cmd = buffer_get_string_ret(m, &len)) == NULL) {
 malf:
		free(cmd);
		free(reserved);
		for (j = 0; j < env_len; j++)
			free(cctx->env[j]);
		free(cctx->env);
		free(cctx->term);
		free(cctx);
		error("%s: malformed message", __func__);
		return -1;
	}
	free(reserved);
	reserved = NULL;

	while (buffer_len(m) > 0) {
#define MUX_MAX_ENV_VARS	4096
		if ((cp = buffer_get_string_ret(m, &len)) == NULL)
			goto malf;
		if (!env_permitted(cp)) {
			free(cp);
			continue;
		}
		cctx->env = xreallocarray(cctx->env, env_len + 2,
		    sizeof(*cctx->env));
		cctx->env[env_len++] = cp;
		cctx->env[env_len] = NULL;
		if (env_len > MUX_MAX_ENV_VARS) {
			error(">%d environment variables received, ignoring "
			    "additional", MUX_MAX_ENV_VARS);
			break;
		}
	}

	debug2("%s: channel %d: request tty %d, X %d, agent %d, subsys %d, "
	    "term \"%s\", cmd \"%s\", env %u", __func__, c->self,
	    cctx->want_tty, cctx->want_x_fwd, cctx->want_agent_fwd,
	    cctx->want_subsys, cctx->term, cmd, env_len);

	buffer_init(&cctx->cmd);
	buffer_append(&cctx->cmd, cmd, strlen(cmd));
	free(cmd);
	cmd = NULL;

	/* Gather fds from client */
	for(i = 0; i < 3; i++) {
		if ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {
			error("%s: failed to receive fd %d from slave",
			    __func__, i);
			for (j = 0; j < i; j++)
				close(new_fd[j]);
			for (j = 0; j < env_len; j++)
				free(cctx->env[j]);
			free(cctx->env);
			free(cctx->term);
			buffer_free(&cctx->cmd);
			free(cctx);

			/* prepare reply */
			buffer_put_int(r, MUX_S_FAILURE);
			buffer_put_int(r, rid);
			buffer_put_cstring(r,
			    "did not receive file descriptors");
			return -1;
		}
	}

	debug3("%s: got fds stdin %d, stdout %d, stderr %d", __func__,
	    new_fd[0], new_fd[1], new_fd[2]);

	/* XXX support multiple child sessions in future */
	if (c->remote_id != -1) {
		debug2("%s: session already open", __func__);
		/* prepare reply */
		buffer_put_int(r, MUX_S_FAILURE);
		buffer_put_int(r, rid);
		buffer_put_cstring(r, "Multiple sessions not supported");
 cleanup:
		close(new_fd[0]);
		close(new_fd[1]);
		close(new_fd[2]);
		free(cctx->term);
		if (env_len != 0) {
			for (i = 0; i < env_len; i++)
				free(cctx->env[i]);
			free(cctx->env);
		}
		buffer_free(&cctx->cmd);
		free(cctx);
		return 0;
	}

	if (options.control_master == SSHCTL_MASTER_ASK ||
	    options.control_master == SSHCTL_MASTER_AUTO_ASK) {
		if (!ask_permission("Allow shared connection to %s? ", host)) {
			debug2("%s: session refused by user", __func__);
			/* prepare reply */
			buffer_put_int(r, MUX_S_PERMISSION_DENIED);
			buffer_put_int(r, rid);
			buffer_put_cstring(r, "Permission denied");
			goto cleanup;
		}
	}

	/* Try to pick up ttymodes from client before it goes raw */
	if (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)
		error("%s: tcgetattr: %s", __func__, strerror(errno));

	/* enable nonblocking unless tty */
	if (!isatty(new_fd[0]))
		set_nonblock(new_fd[0]);
	if (!isatty(new_fd[1]))
		set_nonblock(new_fd[1]);
	if (!isatty(new_fd[2]))
		set_nonblock(new_fd[2]);

	window = CHAN_SES_WINDOW_DEFAULT;
	packetmax = CHAN_SES_PACKET_DEFAULT;
	if (cctx->want_tty) {
		window >>= 1;
		packetmax >>= 1;
	}

	nc = channel_new("session", SSH_CHANNEL_OPENING,
	    new_fd[0], new_fd[1], new_fd[2], window, packetmax,
	    CHAN_EXTENDED_WRITE, "client-session", /*nonblock*/0);

	nc->ctl_chan = c->self;		/* link session -> control channel */
	c->remote_id = nc->self; 	/* link control -> session channel */

	if (cctx->want_tty && escape_char != 0xffffffff) {
		channel_register_filter(nc->self,
		    client_simple_escape_filter, NULL,
		    client_filter_cleanup,
		    client_new_escape_filter_ctx((int)escape_char));
	}

	debug2("%s: channel_new: %d linked to control channel %d",
	    __func__, nc->self, nc->ctl_chan);

	channel_send_open(nc->self);
	channel_register_open_confirm(nc->self, mux_session_confirm, cctx);
	c->mux_pause = 1; /* stop handling messages until open_confirm done */
	channel_register_cleanup(nc->self, mux_master_session_cleanup_cb, 1);

	/* reply is deferred, sent by mux_session_confirm */
	return 0;
}

static int
process_mux_alive_check(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	debug2("%s: channel %d: alive check", __func__, c->self);

	/* prepare reply */
	buffer_put_int(r, MUX_S_ALIVE);
	buffer_put_int(r, rid);
	buffer_put_int(r, (u_int)getpid());

	return 0;
}

static int
process_mux_terminate(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	debug2("%s: channel %d: terminate request", __func__, c->self);

	if (options.control_master == SSHCTL_MASTER_ASK ||
	    options.control_master == SSHCTL_MASTER_AUTO_ASK) {
		if (!ask_permission("Terminate shared connection to %s? ",
		    host)) {
			debug2("%s: termination refused by user", __func__);
			buffer_put_int(r, MUX_S_PERMISSION_DENIED);
			buffer_put_int(r, rid);
			buffer_put_cstring(r, "Permission denied");
			return 0;
		}
	}

	quit_pending = 1;
	buffer_put_int(r, MUX_S_OK);
	buffer_put_int(r, rid);
	/* XXX exit happens too soon - message never makes it to client */
	return 0;
}

static char *
format_forward(u_int ftype, struct Forward *fwd)
{
	char *ret;

	switch (ftype) {
	case MUX_FWD_LOCAL:
		xasprintf(&ret, "local forward %.200s:%d -> %.200s:%d",
		    (fwd->listen_path != NULL) ? fwd->listen_path :
		    (fwd->listen_host == NULL) ?
		    (options.fwd_opts.gateway_ports ? "*" : "LOCALHOST") :
		    fwd->listen_host, fwd->listen_port,
		    (fwd->connect_path != NULL) ? fwd->connect_path :
		    fwd->connect_host, fwd->connect_port);
		break;
	case MUX_FWD_DYNAMIC:
		xasprintf(&ret, "dynamic forward %.200s:%d -> *",
		    (fwd->listen_host == NULL) ?
		    (options.fwd_opts.gateway_ports ? "*" : "LOCALHOST") :
		     fwd->listen_host, fwd->listen_port);
		break;
	case MUX_FWD_REMOTE:
		xasprintf(&ret, "remote forward %.200s:%d -> %.200s:%d",
		    (fwd->listen_path != NULL) ? fwd->listen_path :
		    (fwd->listen_host == NULL) ?
		    "LOCALHOST" : fwd->listen_host,
		    fwd->listen_port,
		    (fwd->connect_path != NULL) ? fwd->connect_path :
		    fwd->connect_host, fwd->connect_port);
		break;
	default:
		fatal("%s: unknown forward type %u", __func__, ftype);
	}
	return ret;
}

static int
compare_host(const char *a, const char *b)
{
	if (a == NULL && b == NULL)
		return 1;
	if (a == NULL || b == NULL)
		return 0;
	return strcmp(a, b) == 0;
}

static int
compare_forward(struct Forward *a, struct Forward *b)
{
	if (!compare_host(a->listen_host, b->listen_host))
		return 0;
	if (!compare_host(a->listen_path, b->listen_path))
		return 0;
	if (a->listen_port != b->listen_port)
		return 0;
	if (!compare_host(a->connect_host, b->connect_host))
		return 0;
	if (!compare_host(a->connect_path, b->connect_path))
		return 0;
	if (a->connect_port != b->connect_port)
		return 0;

	return 1;
}

static void
mux_confirm_remote_forward(int type, u_int32_t seq, void *ctxt)
{
	struct mux_channel_confirm_ctx *fctx = ctxt;
	char *failmsg = NULL;
	struct Forward *rfwd;
	Channel *c;
	Buffer out;

	if ((c = channel_by_id(fctx->cid)) == NULL) {
		/* no channel for reply */
		error("%s: unknown channel", __func__);
		return;
	}
	buffer_init(&out);
	if (fctx->fid >= options.num_remote_forwards ||
	    (options.remote_forwards[fctx->fid].connect_path == NULL &&
	    options.remote_forwards[fctx->fid].connect_host == NULL)) {
		xasprintf(&failmsg, "unknown forwarding id %d", fctx->fid);
		goto fail;
	}
	rfwd = &options.remote_forwards[fctx->fid];
	debug("%s: %s for: listen %d, connect %s:%d", __func__,
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :
	    rfwd->connect_host, rfwd->connect_port);
	if (type == SSH2_MSG_REQUEST_SUCCESS) {
		if (rfwd->listen_port == 0) {
			rfwd->allocated_port = packet_get_int();
			debug("Allocated port %u for mux remote forward"
			    " to %s:%d", rfwd->allocated_port,
			    rfwd->connect_host, rfwd->connect_port);
			buffer_put_int(&out, MUX_S_REMOTE_PORT);
			buffer_put_int(&out, fctx->rid);
			buffer_put_int(&out, rfwd->allocated_port);
			channel_update_permitted_opens(rfwd->handle,
			   rfwd->allocated_port);
		} else {
			buffer_put_int(&out, MUX_S_OK);
			buffer_put_int(&out, fctx->rid);
		}
		goto out;
	} else {
		if (rfwd->listen_port == 0)
			channel_update_permitted_opens(rfwd->handle, -1);
		if (rfwd->listen_path != NULL)
			xasprintf(&failmsg, "remote port forwarding failed for "
			    "listen path %s", rfwd->listen_path);
		else
			xasprintf(&failmsg, "remote port forwarding failed for "
			    "listen port %d", rfwd->listen_port);

                debug2("%s: clearing registered forwarding for listen %d, "
		    "connect %s:%d", __func__, rfwd->listen_port,
		    rfwd->connect_path ? rfwd->connect_path :
		    rfwd->connect_host, rfwd->connect_port);

		free(rfwd->listen_host);
		free(rfwd->listen_path);
		free(rfwd->connect_host);
		free(rfwd->connect_path);
		memset(rfwd, 0, sizeof(*rfwd));
	}
 fail:
	error("%s: %s", __func__, failmsg);
	buffer_put_int(&out, MUX_S_FAILURE);
	buffer_put_int(&out, fctx->rid);
	buffer_put_cstring(&out, failmsg);
	free(failmsg);
 out:
	buffer_put_string(&c->output, buffer_ptr(&out), buffer_len(&out));
	buffer_free(&out);
	if (c->mux_pause <= 0)
		fatal("%s: mux_pause %d", __func__, c->mux_pause);
	c->mux_pause = 0; /* start processing messages again */
}

static int
process_mux_open_fwd(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	struct Forward fwd;
	char *fwd_desc = NULL;
	char *listen_addr, *connect_addr;
	u_int ftype;
	u_int lport, cport;
	int i, ret = 0, freefwd = 1;

	memset(&fwd, 0, sizeof(fwd));

	/* XXX - lport/cport check redundant */
	if (buffer_get_int_ret(&ftype, m) != 0 ||
	    (listen_addr = buffer_get_string_ret(m, NULL)) == NULL ||
	    buffer_get_int_ret(&lport, m) != 0 ||
	    (connect_addr = buffer_get_string_ret(m, NULL)) == NULL ||
	    buffer_get_int_ret(&cport, m) != 0 ||
	    (lport != (u_int)PORT_STREAMLOCAL && lport > 65535) ||
	    (cport != (u_int)PORT_STREAMLOCAL && cport > 65535)) {
		error("%s: malformed message", __func__);
		ret = -1;
		goto out;
	}
	if (*listen_addr == '\0') {
		free(listen_addr);
		listen_addr = NULL;
	}
	if (*connect_addr == '\0') {
		free(connect_addr);
		connect_addr = NULL;
	}

	memset(&fwd, 0, sizeof(fwd));
	fwd.listen_port = lport;
	if (fwd.listen_port == PORT_STREAMLOCAL)
		fwd.listen_path = listen_addr;
	else
		fwd.listen_host = listen_addr;
	fwd.connect_port = cport;
	if (fwd.connect_port == PORT_STREAMLOCAL)
		fwd.connect_path = connect_addr;
	else
		fwd.connect_host = connect_addr;

	debug2("%s: channel %d: request %s", __func__, c->self,
	    (fwd_desc = format_forward(ftype, &fwd)));

	if (ftype != MUX_FWD_LOCAL && ftype != MUX_FWD_REMOTE &&
	    ftype != MUX_FWD_DYNAMIC) {
		logit("%s: invalid forwarding type %u", __func__, ftype);
 invalid:
		free(listen_addr);
		free(connect_addr);
		buffer_put_int(r, MUX_S_FAILURE);
		buffer_put_int(r, rid);
		buffer_put_cstring(r, "Invalid forwarding request");
		return 0;
	}
	if (ftype == MUX_FWD_DYNAMIC && fwd.listen_path) {
		logit("%s: streamlocal and dynamic forwards "
		    "are mutually exclusive", __func__);
		goto invalid;
	}
	if (fwd.listen_port != PORT_STREAMLOCAL && fwd.listen_port >= 65536) {
		logit("%s: invalid listen port %u", __func__,
		    fwd.listen_port);
		goto invalid;
	}
	if ((fwd.connect_port != PORT_STREAMLOCAL && fwd.connect_port >= 65536)
	    || (ftype != MUX_FWD_DYNAMIC && ftype != MUX_FWD_REMOTE && fwd.connect_port == 0)) {
		logit("%s: invalid connect port %u", __func__,
		    fwd.connect_port);
		goto invalid;
	}
	if (ftype != MUX_FWD_DYNAMIC && fwd.connect_host == NULL && fwd.connect_path == NULL) {
		logit("%s: missing connect host", __func__);
		goto invalid;
	}

	/* Skip forwards that have already been requested */
	switch (ftype) {
	case MUX_FWD_LOCAL:
	case MUX_FWD_DYNAMIC:
		for (i = 0; i < options.num_local_forwards; i++) {
			if (compare_forward(&fwd,
			    options.local_forwards + i)) {
 exists:
				debug2("%s: found existing forwarding",
				    __func__);
				buffer_put_int(r, MUX_S_OK);
				buffer_put_int(r, rid);
				goto out;
			}
		}
		break;
	case MUX_FWD_REMOTE:
		for (i = 0; i < options.num_remote_forwards; i++) {
			if (compare_forward(&fwd,
			    options.remote_forwards + i)) {
				if (fwd.listen_port != 0)
					goto exists;
				debug2("%s: found allocated port",
				    __func__);
				buffer_put_int(r, MUX_S_REMOTE_PORT);
				buffer_put_int(r, rid);
				buffer_put_int(r,
				    options.remote_forwards[i].allocated_port);
				goto out;
			}
		}
		break;
	}

	if (options.control_master == SSHCTL_MASTER_ASK ||
	    options.control_master == SSHCTL_MASTER_AUTO_ASK) {
		if (!ask_permission("Open %s on %s?", fwd_desc, host)) {
			debug2("%s: forwarding refused by user", __func__);
			buffer_put_int(r, MUX_S_PERMISSION_DENIED);
			buffer_put_int(r, rid);
			buffer_put_cstring(r, "Permission denied");
			goto out;
		}
	}

	if (ftype == MUX_FWD_LOCAL || ftype == MUX_FWD_DYNAMIC) {
		if (!channel_setup_local_fwd_listener(&fwd,
		    &options.fwd_opts)) {
 fail:
			logit("slave-requested %s failed", fwd_desc);
			buffer_put_int(r, MUX_S_FAILURE);
			buffer_put_int(r, rid);
			buffer_put_cstring(r, "Port forwarding failed");
			goto out;
		}
		add_local_forward(&options, &fwd);
		freefwd = 0;
	} else {
		struct mux_channel_confirm_ctx *fctx;

		fwd.handle = channel_request_remote_forwarding(&fwd);
		if (fwd.handle < 0)
			goto fail;
		add_remote_forward(&options, &fwd);
		fctx = xcalloc(1, sizeof(*fctx));
		fctx->cid = c->self;
		fctx->rid = rid;
		fctx->fid = options.num_remote_forwards - 1;
		client_register_global_confirm(mux_confirm_remote_forward,
		    fctx);
		freefwd = 0;
		c->mux_pause = 1; /* wait for mux_confirm_remote_forward */
		/* delayed reply in mux_confirm_remote_forward */
		goto out;
	}
	buffer_put_int(r, MUX_S_OK);
	buffer_put_int(r, rid);
 out:
	free(fwd_desc);
	if (freefwd) {
		free(fwd.listen_host);
		free(fwd.listen_path);
		free(fwd.connect_host);
		free(fwd.connect_path);
	}
	return ret;
}

static int
process_mux_close_fwd(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	struct Forward fwd, *found_fwd;
	char *fwd_desc = NULL;
	const char *error_reason = NULL;
	char *listen_addr = NULL, *connect_addr = NULL;
	u_int ftype;
	int i, ret = 0;
	u_int lport, cport;

	memset(&fwd, 0, sizeof(fwd));

	if (buffer_get_int_ret(&ftype, m) != 0 ||
	    (listen_addr = buffer_get_string_ret(m, NULL)) == NULL ||
	    buffer_get_int_ret(&lport, m) != 0 ||
	    (connect_addr = buffer_get_string_ret(m, NULL)) == NULL ||
	    buffer_get_int_ret(&cport, m) != 0 ||
	    (lport != (u_int)PORT_STREAMLOCAL && lport > 65535) ||
	    (cport != (u_int)PORT_STREAMLOCAL && cport > 65535)) {
		error("%s: malformed message", __func__);
		ret = -1;
		goto out;
	}

	if (*listen_addr == '\0') {
		free(listen_addr);
		listen_addr = NULL;
	}
	if (*connect_addr == '\0') {
		free(connect_addr);
		connect_addr = NULL;
	}

	memset(&fwd, 0, sizeof(fwd));
	fwd.listen_port = lport;
	if (fwd.listen_port == PORT_STREAMLOCAL)
		fwd.listen_path = listen_addr;
	else
		fwd.listen_host = listen_addr;
	fwd.connect_port = cport;
	if (fwd.connect_port == PORT_STREAMLOCAL)
		fwd.connect_path = connect_addr;
	else
		fwd.connect_host = connect_addr;

	debug2("%s: channel %d: request cancel %s", __func__, c->self,
	    (fwd_desc = format_forward(ftype, &fwd)));

	/* make sure this has been requested */
	found_fwd = NULL;
	switch (ftype) {
	case MUX_FWD_LOCAL:
	case MUX_FWD_DYNAMIC:
		for (i = 0; i < options.num_local_forwards; i++) {
			if (compare_forward(&fwd,
			    options.local_forwards + i)) {
				found_fwd = options.local_forwards + i;
				break;
			}
		}
		break;
	case MUX_FWD_REMOTE:
		for (i = 0; i < options.num_remote_forwards; i++) {
			if (compare_forward(&fwd,
			    options.remote_forwards + i)) {
				found_fwd = options.remote_forwards + i;
				break;
			}
		}
		break;
	}

	if (found_fwd == NULL)
		error_reason = "port not forwarded";
	else if (ftype == MUX_FWD_REMOTE) {
		/*
		 * This shouldn't fail unless we confused the host/port
		 * between options.remote_forwards and permitted_opens.
		 * However, for dynamic allocated listen ports we need
		 * to use the actual listen port.
		 */
		if (channel_request_rforward_cancel(found_fwd) == -1)
			error_reason = "port not in permitted opens";
	} else {	/* local and dynamic forwards */
		/* Ditto */
		if (channel_cancel_lport_listener(&fwd, fwd.connect_port,
		    &options.fwd_opts) == -1)
			error_reason = "port not found";
	}

	if (error_reason == NULL) {
		buffer_put_int(r, MUX_S_OK);
		buffer_put_int(r, rid);

		free(found_fwd->listen_host);
		free(found_fwd->listen_path);
		free(found_fwd->connect_host);
		free(found_fwd->connect_path);
		found_fwd->listen_host = found_fwd->connect_host = NULL;
		found_fwd->listen_path = found_fwd->connect_path = NULL;
		found_fwd->listen_port = found_fwd->connect_port = 0;
	} else {
		buffer_put_int(r, MUX_S_FAILURE);
		buffer_put_int(r, rid);
		buffer_put_cstring(r, error_reason);
	}
 out:
	free(fwd_desc);
	free(listen_addr);
	free(connect_addr);

	return ret;
}

static int
process_mux_stdio_fwd(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	Channel *nc;
	char *reserved, *chost;
	u_int cport, i, j;
	int new_fd[2];
	struct mux_stdio_confirm_ctx *cctx;

	chost = reserved = NULL;
	if ((reserved = buffer_get_string_ret(m, NULL)) == NULL ||
	   (chost = buffer_get_string_ret(m, NULL)) == NULL ||
	    buffer_get_int_ret(&cport, m) != 0) {
		free(reserved);
		free(chost);
		error("%s: malformed message", __func__);
		return -1;
	}
	free(reserved);

	debug2("%s: channel %d: request stdio fwd to %s:%u",
	    __func__, c->self, chost, cport);

	/* Gather fds from client */
	for(i = 0; i < 2; i++) {
		if ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {
			error("%s: failed to receive fd %d from slave",
			    __func__, i);
			for (j = 0; j < i; j++)
				close(new_fd[j]);
			free(chost);

			/* prepare reply */
			buffer_put_int(r, MUX_S_FAILURE);
			buffer_put_int(r, rid);
			buffer_put_cstring(r,
			    "did not receive file descriptors");
			return -1;
		}
	}

	debug3("%s: got fds stdin %d, stdout %d", __func__,
	    new_fd[0], new_fd[1]);

	/* XXX support multiple child sessions in future */
	if (c->remote_id != -1) {
		debug2("%s: session already open", __func__);
		/* prepare reply */
		buffer_put_int(r, MUX_S_FAILURE);
		buffer_put_int(r, rid);
		buffer_put_cstring(r, "Multiple sessions not supported");
 cleanup:
		close(new_fd[0]);
		close(new_fd[1]);
		free(chost);
		return 0;
	}

	if (options.control_master == SSHCTL_MASTER_ASK ||
	    options.control_master == SSHCTL_MASTER_AUTO_ASK) {
		if (!ask_permission("Allow forward to %s:%u? ",
		    chost, cport)) {
			debug2("%s: stdio fwd refused by user", __func__);
			/* prepare reply */
			buffer_put_int(r, MUX_S_PERMISSION_DENIED);
			buffer_put_int(r, rid);
			buffer_put_cstring(r, "Permission denied");
			goto cleanup;
		}
	}

	/* enable nonblocking unless tty */
	if (!isatty(new_fd[0]))
		set_nonblock(new_fd[0]);
	if (!isatty(new_fd[1]))
		set_nonblock(new_fd[1]);

	nc = channel_connect_stdio_fwd(chost, cport, new_fd[0], new_fd[1]);

	nc->ctl_chan = c->self;		/* link session -> control channel */
	c->remote_id = nc->self; 	/* link control -> session channel */

	debug2("%s: channel_new: %d linked to control channel %d",
	    __func__, nc->self, nc->ctl_chan);

	channel_register_cleanup(nc->self, mux_master_session_cleanup_cb, 1);

	cctx = xcalloc(1, sizeof(*cctx));
	cctx->rid = rid;
	channel_register_open_confirm(nc->self, mux_stdio_confirm, cctx);
	c->mux_pause = 1; /* stop handling messages until open_confirm done */

	/* reply is deferred, sent by mux_session_confirm */
	return 0;
}

/* Callback on open confirmation in mux master for a mux stdio fwd session. */
static void
mux_stdio_confirm(int id, int success, void *arg)
{
	struct mux_stdio_confirm_ctx *cctx = arg;
	Channel *c, *cc;
	Buffer reply;

	if (cctx == NULL)
		fatal("%s: cctx == NULL", __func__);
	if ((c = channel_by_id(id)) == NULL)
		fatal("%s: no channel for id %d", __func__, id);
	if ((cc = channel_by_id(c->ctl_chan)) == NULL)
		fatal("%s: channel %d lacks control channel %d", __func__,
		    id, c->ctl_chan);

	if (!success) {
		debug3("%s: sending failure reply", __func__);
		/* prepare reply */
		buffer_init(&reply);
		buffer_put_int(&reply, MUX_S_FAILURE);
		buffer_put_int(&reply, cctx->rid);
		buffer_put_cstring(&reply, "Session open refused by peer");
		goto done;
	}

	debug3("%s: sending success reply", __func__);
	/* prepare reply */
	buffer_init(&reply);
	buffer_put_int(&reply, MUX_S_SESSION_OPENED);
	buffer_put_int(&reply, cctx->rid);
	buffer_put_int(&reply, c->self);

 done:
	/* Send reply */
	buffer_put_string(&cc->output, buffer_ptr(&reply), buffer_len(&reply));
	buffer_free(&reply);

	if (cc->mux_pause <= 0)
		fatal("%s: mux_pause %d", __func__, cc->mux_pause);
	cc->mux_pause = 0; /* start processing messages again */
	c->open_confirm_ctx = NULL;
	free(cctx);
}

static int
process_mux_stop_listening(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	debug("%s: channel %d: stop listening", __func__, c->self);

	if (options.control_master == SSHCTL_MASTER_ASK ||
	    options.control_master == SSHCTL_MASTER_AUTO_ASK) {
		if (!ask_permission("Disable further multiplexing on shared "
		    "connection to %s? ", host)) {
			debug2("%s: stop listen refused by user", __func__);
			buffer_put_int(r, MUX_S_PERMISSION_DENIED);
			buffer_put_int(r, rid);
			buffer_put_cstring(r, "Permission denied");
			return 0;
		}
	}

	if (mux_listener_channel != NULL) {
		channel_free(mux_listener_channel);
		client_stop_mux();
		free(options.control_path);
		options.control_path = NULL;
		mux_listener_channel = NULL;
		muxserver_sock = -1;
	}

	/* prepare reply */
	buffer_put_int(r, MUX_S_OK);
	buffer_put_int(r, rid);

	return 0;
}

static int
process_mux_proxy(u_int rid, Channel *c, Buffer *m, Buffer *r)
{
	debug("%s: channel %d: proxy request", __func__, c->self);

	c->mux_rcb = channel_proxy_downstream;
	buffer_put_int(r, MUX_S_PROXY);
	buffer_put_int(r, rid);

	return 0;
}

/* Channel callbacks fired on read/write from mux slave fd */
static int
mux_master_read_cb(Channel *c)
{
	struct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;
	Buffer in, out;
	const u_char *ptr;
	u_int type, rid, have, i;
	int ret = -1;

	/* Setup ctx and  */
	if (c->mux_ctx == NULL) {
		state = xcalloc(1, sizeof(*state));
		c->mux_ctx = state;
		channel_register_cleanup(c->self,
		    mux_master_control_cleanup_cb, 0);

		/* Send hello */
		buffer_init(&out);
		buffer_put_int(&out, MUX_MSG_HELLO);
		buffer_put_int(&out, SSHMUX_VER);
		/* no extensions */
		buffer_put_string(&c->output, buffer_ptr(&out),
		    buffer_len(&out));
		buffer_free(&out);
		debug3("%s: channel %d: hello sent", __func__, c->self);
		return 0;
	}

	buffer_init(&in);
	buffer_init(&out);

	/* Channel code ensures that we receive whole packets */
	if ((ptr = buffer_get_string_ptr_ret(&c->input, &have)) == NULL) {
 malf:
		error("%s: malformed message", __func__);
		goto out;
	}
	buffer_append(&in, ptr, have);

	if (buffer_get_int_ret(&type, &in) != 0)
		goto malf;
	debug3("%s: channel %d packet type 0x%08x len %u",
	    __func__, c->self, type, buffer_len(&in));

	if (type == MUX_MSG_HELLO)
		rid = 0;
	else {
		if (!state->hello_rcvd) {
			error("%s: expected MUX_MSG_HELLO(0x%08x), "
			    "received 0x%08x", __func__, MUX_MSG_HELLO, type);
			goto out;
		}
		if (buffer_get_int_ret(&rid, &in) != 0)
			goto malf;
	}

	for (i = 0; mux_master_handlers[i].handler != NULL; i++) {
		if (type == mux_master_handlers[i].type) {
			ret = mux_master_handlers[i].handler(rid, c, &in, &out);
			break;
		}
	}
	if (mux_master_handlers[i].handler == NULL) {
		error("%s: unsupported mux message 0x%08x", __func__, type);
		buffer_put_int(&out, MUX_S_FAILURE);
		buffer_put_int(&out, rid);
		buffer_put_cstring(&out, "unsupported request");
		ret = 0;
	}
	/* Enqueue reply packet */
	if (buffer_len(&out) != 0) {
		buffer_put_string(&c->output, buffer_ptr(&out),
		    buffer_len(&out));
	}
 out:
	buffer_free(&in);
	buffer_free(&out);
	return ret;
}

void
mux_exit_message(Channel *c, int exitval)
{
	Buffer m;
	Channel *mux_chan;

	debug3("%s: channel %d: exit message, exitval %d", __func__, c->self,
	    exitval);

	if ((mux_chan = channel_by_id(c->ctl_chan)) == NULL)
		fatal("%s: channel %d missing mux channel %d",
		    __func__, c->self, c->ctl_chan);

	/* Append exit message packet to control socket output queue */
	buffer_init(&m);
	buffer_put_int(&m, MUX_S_EXIT_MESSAGE);
	buffer_put_int(&m, c->self);
	buffer_put_int(&m, exitval);

	buffer_put_string(&mux_chan->output, buffer_ptr(&m), buffer_len(&m));
	buffer_free(&m);
}

void
mux_tty_alloc_failed(Channel *c)
{
	Buffer m;
	Channel *mux_chan;

	debug3("%s: channel %d: TTY alloc failed", __func__, c->self);

	if ((mux_chan = channel_by_id(c->ctl_chan)) == NULL)
		fatal("%s: channel %d missing mux channel %d",
		    __func__, c->self, c->ctl_chan);

	/* Append exit message packet to control socket output queue */
	buffer_init(&m);
	buffer_put_int(&m, MUX_S_TTY_ALLOC_FAIL);
	buffer_put_int(&m, c->self);

	buffer_put_string(&mux_chan->output, buffer_ptr(&m), buffer_len(&m));
	buffer_free(&m);
}

/* Prepare a mux master to listen on a Unix domain socket. */
void
muxserver_listen(void)
{
	mode_t old_umask;
	char *orig_control_path = options.control_path;
	char rbuf[16+1];
	u_int i, r;
	int oerrno;

	if (options.control_path == NULL ||
	    options.control_master == SSHCTL_MASTER_NO)
		return;

	debug("setting up multiplex master socket");

	/*
	 * Use a temporary path before listen so we can pseudo-atomically
	 * establish the listening socket in its final location to avoid
	 * other processes racing in between bind() and listen() and hitting
	 * an unready socket.
	 */
	for (i = 0; i < sizeof(rbuf) - 1; i++) {
		r = arc4random_uniform(26+26+10);
		rbuf[i] = (r < 26) ? 'a' + r :
		    (r < 26*2) ? 'A' + r - 26 :
		    '0' + r - 26 - 26;
	}
	rbuf[sizeof(rbuf) - 1] = '\0';
	options.control_path = NULL;
	xasprintf(&options.control_path, "%s.%s", orig_control_path, rbuf);
	debug3("%s: temporary control path %s", __func__, options.control_path);

	old_umask = umask(0177);
	muxserver_sock = unix_listener(options.control_path, 64, 0);
	oerrno = errno;
	umask(old_umask);
	if (muxserver_sock < 0) {
		if (oerrno == EINVAL || oerrno == EADDRINUSE) {
			error("ControlSocket %s already exists, "
			    "disabling multiplexing", options.control_path);
 disable_mux_master:
			if (muxserver_sock != -1) {
				close(muxserver_sock);
				muxserver_sock = -1;
			}
			free(orig_control_path);
			free(options.control_path);
			options.control_path = NULL;
			options.control_master = SSHCTL_MASTER_NO;
			return;
		} else {
			/* unix_listener() logs the error */
			cleanup_exit(255);
		}
	}

	/* Now atomically "move" the mux socket into position */
	if (link(options.control_path, orig_control_path) != 0) {
		if (errno != EEXIST) {
			fatal("%s: link mux listener %s => %s: %s", __func__,
			    options.control_path, orig_control_path,
			    strerror(errno));
		}
		error("ControlSocket %s already exists, disabling multiplexing",
		    orig_control_path);
		unlink(options.control_path);
		goto disable_mux_master;
	}
	unlink(options.control_path);
	free(options.control_path);
	options.control_path = orig_control_path;

	set_nonblock(muxserver_sock);

	mux_listener_channel = channel_new("mux listener",
	    SSH_CHANNEL_MUX_LISTENER, muxserver_sock, muxserver_sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
	    0, options.control_path, 1);
	mux_listener_channel->mux_rcb = mux_master_read_cb;
	debug3("%s: mux listener channel %d fd %d", __func__,
	    mux_listener_channel->self, mux_listener_channel->sock);
}

/* Callback on open confirmation in mux master for a mux client session. */
static void
mux_session_confirm(int id, int success, void *arg)
{
	struct mux_session_confirm_ctx *cctx = arg;
	const char *display;
	Channel *c, *cc;
	int i;
	Buffer reply;

	if (cctx == NULL)
		fatal("%s: cctx == NULL", __func__);
	if ((c = channel_by_id(id)) == NULL)
		fatal("%s: no channel for id %d", __func__, id);
	if ((cc = channel_by_id(c->ctl_chan)) == NULL)
		fatal("%s: channel %d lacks control channel %d", __func__,
		    id, c->ctl_chan);

	if (!success) {
		debug3("%s: sending failure reply", __func__);
		/* prepare reply */
		buffer_init(&reply);
		buffer_put_int(&reply, MUX_S_FAILURE);
		buffer_put_int(&reply, cctx->rid);
		buffer_put_cstring(&reply, "Session open refused by peer");
		goto done;
	}

	display = getenv("DISPLAY");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
		char *proto, *data;

		/* Get reasonable local authentication information. */
		if (client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, options.forward_x11_timeout,
		    &proto, &data) == 0) {
			/* Request forwarding with authentication spoofing. */
			debug("Requesting X11 forwarding with authentication "
			    "spoofing.");
			x11_request_forwarding_with_spoofing(id, display, proto,
			    data, 1);
			/* XXX exit_on_forward_failure */
			client_expect_confirm(id, "X11 forwarding",
			    CONFIRM_WARN);
		}
	}

	if (cctx->want_agent_fwd && options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env);

	debug3("%s: sending success reply", __func__);
	/* prepare reply */
	buffer_init(&reply);
	buffer_put_int(&reply, MUX_S_SESSION_OPENED);
	buffer_put_int(&reply, cctx->rid);
	buffer_put_int(&reply, c->self);

 done:
	/* Send reply */
	buffer_put_string(&cc->output, buffer_ptr(&reply), buffer_len(&reply));
	buffer_free(&reply);

	if (cc->mux_pause <= 0)
		fatal("%s: mux_pause %d", __func__, cc->mux_pause);
	cc->mux_pause = 0; /* start processing messages again */
	c->open_confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	free(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			free(cctx->env[i]);
		free(cctx->env);
	}
	free(cctx);
}

/* ** Multiplexing client support */

/* Exit signal handler */
static void
control_client_sighandler(int signo)
{
	muxclient_terminate = signo;
}

/*
 * Relay signal handler - used to pass some signals from mux client to
 * mux master.
 */
static void
control_client_sigrelay(int signo)
{
	int save_errno = errno;

	if (muxserver_pid > 1)
		kill(muxserver_pid, signo);

	errno = save_errno;
}

static int
mux_client_read(int fd, Buffer *b, u_int need)
{
	u_int have;
	ssize_t len;
	u_char *p;
	struct pollfd pfd;

	pfd.fd = fd;
	pfd.events = POLLIN;
	p = buffer_append_space(b, need);
	for (have = 0; have < need; ) {
		if (muxclient_terminate) {
			errno = EINTR;
			return -1;
		}
		len = read(fd, p + have, need - have);
		if (len < 0) {
			switch (errno) {
			case EAGAIN:
				(void)poll(&pfd, 1, -1);
				/* FALLTHROUGH */
			case EINTR:
				continue;
			default:
				return -1;
			}
		}
		if (len == 0) {
			errno = EPIPE;
			return -1;
		}
		have += (u_int)len;
	}
	return 0;
}

static int
mux_client_write_packet(int fd, Buffer *m)
{
	Buffer queue;
	u_int have, need;
	int oerrno, len;
	u_char *ptr;
	struct pollfd pfd;

	pfd.fd = fd;
	pfd.events = POLLOUT;
	buffer_init(&queue);
	buffer_put_string(&queue, buffer_ptr(m), buffer_len(m));

	need = buffer_len(&queue);
	ptr = buffer_ptr(&queue);

	for (have = 0; have < need; ) {
		if (muxclient_terminate) {
			buffer_free(&queue);
			errno = EINTR;
			return -1;
		}
		len = write(fd, ptr + have, need - have);
		if (len < 0) {
			switch (errno) {
			case EAGAIN:
				(void)poll(&pfd, 1, -1);
				/* FALLTHROUGH */
			case EINTR:
				continue;
			default:
				oerrno = errno;
				buffer_free(&queue);
				errno = oerrno;
				return -1;
			}
		}
		if (len == 0) {
			buffer_free(&queue);
			errno = EPIPE;
			return -1;
		}
		have += (u_int)len;
	}
	buffer_free(&queue);
	return 0;
}

static int
mux_client_read_packet(int fd, Buffer *m)
{
	Buffer queue;
	u_int need, have;
	const u_char *ptr;
	int oerrno;

	buffer_init(&queue);
	if (mux_client_read(fd, &queue, 4) != 0) {
		if ((oerrno = errno) == EPIPE)
			debug3("%s: read header failed: %s", __func__,
			    strerror(errno));
		buffer_free(&queue);
		errno = oerrno;
		return -1;
	}
	need = get_u32(buffer_ptr(&queue));
	if (mux_client_read(fd, &queue, need) != 0) {
		oerrno = errno;
		debug3("%s: read body failed: %s", __func__, strerror(errno));
		buffer_free(&queue);
		errno = oerrno;
		return -1;
	}
	ptr = buffer_get_string_ptr(&queue, &have);
	buffer_append(m, ptr, have);
	buffer_free(&queue);
	return 0;
}

static int
mux_client_hello_exchange(int fd)
{
	Buffer m;
	u_int type, ver;

	buffer_init(&m);
	buffer_put_int(&m, MUX_MSG_HELLO);
	buffer_put_int(&m, SSHMUX_VER);
	/* no extensions */

	if (mux_client_write_packet(fd, &m) != 0)
		fatal("%s: write packet: %s", __func__, strerror(errno));

	buffer_clear(&m);

	/* Read their HELLO */
	if (mux_client_read_packet(fd, &m) != 0) {
		buffer_free(&m);
		return -1;
	}

	type = buffer_get_int(&m);
	if (type != MUX_MSG_HELLO)
		fatal("%s: expected HELLO (%u) received %u",
		    __func__, MUX_MSG_HELLO, type);
	ver = buffer_get_int(&m);
	if (ver != SSHMUX_VER)
		fatal("Unsupported multiplexing protocol version %d "
		    "(expected %d)", ver, SSHMUX_VER);
	debug2("%s: master version %u", __func__, ver);
	/* No extensions are presently defined */
	while (buffer_len(&m) > 0) {
		char *name = buffer_get_string(&m, NULL);
		char *value = buffer_get_string(&m, NULL);

		debug2("Unrecognised master extension \"%s\"", name);
		free(name);
		free(value);
	}
	buffer_free(&m);
	return 0;
}

static u_int
mux_client_request_alive(int fd)
{
	Buffer m;
	char *e;
	u_int pid, type, rid;

	debug3("%s: entering", __func__);

	buffer_init(&m);
	buffer_put_int(&m, MUX_C_ALIVE_CHECK);
	buffer_put_int(&m, muxclient_request_id);

	if (mux_client_write_packet(fd, &m) != 0)
		fatal("%s: write packet: %s", __func__, strerror(errno));

	buffer_clear(&m);

	/* Read their reply */
	if (mux_client_read_packet(fd, &m) != 0) {
		buffer_free(&m);
		return 0;
	}

	type = buffer_get_int(&m);
	if (type != MUX_S_ALIVE) {
		e = buffer_get_string(&m, NULL);
		fatal("%s: master returned error: %s", __func__, e);
	}

	if ((rid = buffer_get_int(&m)) != muxclient_request_id)
		fatal("%s: out of sequence reply: my id %u theirs %u",
		    __func__, muxclient_request_id, rid);
	pid = buffer_get_int(&m);
	buffer_free(&m);

	debug3("%s: done pid = %u", __func__, pid);

	muxclient_request_id++;

	return pid;
}

static void
mux_client_request_terminate(int fd)
{
	Buffer m;
	char *e;
	u_int type, rid;

	debug3("%s: entering", __func__);

	buffer_init(&m);
	buffer_put_int(&m, MUX_C_TERMINATE);
	buffer_put_int(&m, muxclient_request_id);

	if (mux_client_write_packet(fd, &m) != 0)
		fatal("%s: write packet: %s", __func__, strerror(errno));

	buffer_clear(&m);

	/* Read their reply */
	if (mux_client_read_packet(fd, &m) != 0) {
		/* Remote end exited already */
		if (errno == EPIPE) {
			buffer_free(&m);
			return;
		}
		fatal("%s: read from master failed: %s",
		    __func__, strerror(errno));
	}

	type = buffer_get_int(&m);
	if ((rid = buffer_get_int(&m)) != muxclient_request_id)
		fatal("%s: out of sequence reply: my id %u theirs %u",
		    __func__, muxclient_request_id, rid);
	switch (type) {
	case MUX_S_OK:
		break;
	case MUX_S_PERMISSION_DENIED:
		e = buffer_get_string(&m, NULL);
		fatal("Master refused termination request: %s", e);
	case MUX_S_FAILURE:
		e = buffer_get_string(&m, NULL);
		fatal("%s: termination request failed: %s", __func__, e);
	default:
		fatal("%s: unexpected response from master 0x%08x",
		    __func__, type);
	}
	buffer_free(&m);
	muxclient_request_id++;
}

static int
mux_client_forward(int fd, int cancel_flag, u_int ftype, struct Forward *fwd)
{
	Buffer m;
	char *e, *fwd_desc;
	u_int type, rid;

	fwd_desc = format_forward(ftype, fwd);
	debug("Requesting %s %s",
	    cancel_flag ? "cancellation of" : "forwarding of", fwd_desc);
	free(fwd_desc);

	buffer_init(&m);
	buffer_put_int(&m, cancel_flag ? MUX_C_CLOSE_FWD : MUX_C_OPEN_FWD);
	buffer_put_int(&m, muxclient_request_id);
	buffer_put_int(&m, ftype);
	if (fwd->listen_path != NULL) {
		buffer_put_cstring(&m, fwd->listen_path);
	} else {
		buffer_put_cstring(&m,
		    fwd->listen_host == NULL ? "" :
		    (*fwd->listen_host == '\0' ? "*" : fwd->listen_host));
	}
	buffer_put_int(&m, fwd->listen_port);
	if (fwd->connect_path != NULL) {
		buffer_put_cstring(&m, fwd->connect_path);
	} else {
		buffer_put_cstring(&m,
		    fwd->connect_host == NULL ? "" : fwd->connect_host);
	}
	buffer_put_int(&m, fwd->connect_port);

	if (mux_client_write_packet(fd, &m) != 0)
		fatal("%s: write packet: %s", __func__, strerror(errno));

	buffer_clear(&m);

	/* Read their reply */
	if (mux_client_read_packet(fd, &m) != 0) {
		buffer_free(&m);
		return -1;
	}

	type = buffer_get_int(&m);
	if ((rid = buffer_get_int(&m)) != muxclient_request_id)
		fatal("%s: out of sequence reply: my id %u theirs %u",
		    __func__, muxclient_request_id, rid);
	switch (type) {
	case MUX_S_OK:
		break;
	case MUX_S_REMOTE_PORT:
		if (cancel_flag)
			fatal("%s: got MUX_S_REMOTE_PORT for cancel", __func__);
		fwd->allocated_port = buffer_get_int(&m);
		verbose("Allocated port %u for remote forward to %s:%d",
		    fwd->allocated_port,
		    fwd->connect_host ? fwd->connect_host : "",
		    fwd->connect_port);
		if (muxclient_command == SSHMUX_COMMAND_FORWARD)
			fprintf(stdout, "%i\n", fwd->allocated_port);
		break;
	case MUX_S_PERMISSION_DENIED:
		e = buffer_get_string(&m, NULL);
		buffer_free(&m);
		error("Master refused forwarding request: %s", e);
		return -1;
	case MUX_S_FAILURE:
		e = buffer_get_string(&m, NULL);
		buffer_free(&m);
		error("%s: forwarding request failed: %s", __func__, e);
		return -1;
	default:
		fatal("%s: unexpected response from master 0x%08x",
		    __func__, type);
	}
	buffer_free(&m);

	muxclient_request_id++;
	return 0;
}

static int
mux_client_forwards(int fd, int cancel_flag)
{
	int i, ret = 0;

	debug3("%s: %s forwardings: %d local, %d remote", __func__,
	    cancel_flag ? "cancel" : "request",
	    options.num_local_forwards, options.num_remote_forwards);

	/* XXX ExitOnForwardingFailure */
	for (i = 0; i < options.num_local_forwards; i++) {
		if (mux_client_forward(fd, cancel_flag,
		    options.local_forwards[i].connect_port == 0 ?
		    MUX_FWD_DYNAMIC : MUX_FWD_LOCAL,
		    options.local_forwards + i) != 0)
			ret = -1;
	}
	for (i = 0; i < options.num_remote_forwards; i++) {
		if (mux_client_forward(fd, cancel_flag, MUX_FWD_REMOTE,
		    options.remote_forwards + i) != 0)
			ret = -1;
	}
	return ret;
}

static int
mux_client_request_session(int fd)
{
	Buffer m;
	char *e, *term;
	u_int i, rid, sid, esid, exitval, type, exitval_seen;
	extern char **environ;
	int devnull, rawmode;

	debug3("%s: entering", __func__);

	if ((muxserver_pid = mux_client_request_alive(fd)) == 0) {
		error("%s: master alive request failed", __func__);
		return -1;
	}

	signal(SIGPIPE, SIG_IGN);

	if (stdin_null_flag) {
		if ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(devnull, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (devnull > STDERR_FILENO)
			close(devnull);
	}

	term = getenv("TERM");

	buffer_init(&m);
	buffer_put_int(&m, MUX_C_NEW_SESSION);
	buffer_put_int(&m, muxclient_request_id);
	buffer_put_cstring(&m, ""); /* reserved */
	buffer_put_int(&m, tty_flag);
	buffer_put_int(&m, options.forward_x11);
	buffer_put_int(&m, options.forward_agent);
	buffer_put_int(&m, subsystem_flag);
	buffer_put_int(&m, options.escape_char == SSH_ESCAPECHAR_NONE ?
	    0xffffffff : (u_int)options.escape_char);
	buffer_put_cstring(&m, term == NULL ? "" : term);
	buffer_put_string(&m, buffer_ptr(&command), buffer_len(&command));

	if (options.num_send_env > 0 && environ != NULL) {
		/* Pass environment */
		for (i = 0; environ[i] != NULL; i++) {
			if (env_permitted(environ[i])) {
				buffer_put_cstring(&m, environ[i]);
			}
		}
	}

	if (mux_client_write_packet(fd, &m) != 0)
		fatal("%s: write packet: %s", __func__, strerror(errno));

	/* Send the stdio file descriptors */
	if (mm_send_fd(fd, STDIN_FILENO) == -1 ||
	    mm_send_fd(fd, STDOUT_FILENO) == -1 ||
	    mm_send_fd(fd, STDERR_FILENO) == -1)
		fatal("%s: send fds failed", __func__);

	debug3("%s: session request sent", __func__);

	/* Read their reply */
	buffer_clear(&m);
	if (mux_client_read_packet(fd, &m) != 0) {
		error("%s: read from master failed: %s",
		    __func__, strerror(errno));
		buffer_free(&m);
		return -1;
	}

	type = buffer_get_int(&m);
	if ((rid = buffer_get_int(&m)) != muxclient_request_id)
		fatal("%s: out of sequence reply: my id %u theirs %u",
		    __func__, muxclient_request_id, rid);
	switch (type) {
	case MUX_S_SESSION_OPENED:
		sid = buffer_get_int(&m);
		debug("%s: master session id: %u", __func__, sid);
		break;
	case MUX_S_PERMISSION_DENIED:
		e = buffer_get_string(&m, NULL);
		buffer_free(&m);
		error("Master refused session request: %s", e);
		return -1;
	case MUX_S_FAILURE:
		e = buffer_get_string(&m, NULL);
		buffer_free(&m);
		error("%s: session request failed: %s", __func__, e);
		return -1;
	default:
		buffer_free(&m);
		error("%s: unexpected response from master 0x%08x",
		    __func__, type);
		return -1;
	}
	muxclient_request_id++;

	if (pledge("stdio proc tty", NULL) == -1)
		fatal("%s pledge(): %s", __func__, strerror(errno));

	signal(SIGHUP, control_client_sighandler);
	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

	rawmode = tty_flag;
	if (tty_flag)
		enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);

	/*
	 * Stick around until the controlee closes the client_fd.
	 * Before it does, it is expected to write an exit message.
	 * This process must read the value and wait for the closure of
	 * the client_fd; if this one closes early, the multiplex master will
	 * terminate early too (possibly losing data).
	 */
	for (exitval = 255, exitval_seen = 0;;) {
		buffer_clear(&m);
		if (mux_client_read_packet(fd, &m) != 0)
			break;
		type = buffer_get_int(&m);
		switch (type) {
		case MUX_S_TTY_ALLOC_FAIL:
			if ((esid = buffer_get_int(&m)) != sid)
				fatal("%s: tty alloc fail on unknown session: "
				    "my id %u theirs %u",
				    __func__, sid, esid);
			leave_raw_mode(options.request_tty ==
			    REQUEST_TTY_FORCE);
			rawmode = 0;
			continue;
		case MUX_S_EXIT_MESSAGE:
			if ((esid = buffer_get_int(&m)) != sid)
				fatal("%s: exit on unknown session: "
				    "my id %u theirs %u",
				    __func__, sid, esid);
			if (exitval_seen)
				fatal("%s: exitval sent twice", __func__);
			exitval = buffer_get_int(&m);
			exitval_seen = 1;
			continue;
		default:
			e = buffer_get_string(&m, NULL);
			fatal("%s: master returned error: %s", __func__, e);
		}
	}

	close(fd);
	if (rawmode)
		leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);

	if (muxclient_terminate) {
		debug2("Exiting on signal %d", muxclient_terminate);
		exitval = 255;
	} else if (!exitval_seen) {
		debug2("Control master terminated unexpectedly");
		exitval = 255;
	} else
		debug2("Received exit status from master %d", exitval);

	if (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "Shared connection to %s closed.\r\n", host);

	exit(exitval);
}

static int
mux_client_proxy(int fd)
{
	Buffer m;
	char *e;
	u_int type, rid;

	buffer_init(&m);
	buffer_put_int(&m, MUX_C_PROXY);
	buffer_put_int(&m, muxclient_request_id);
	if (mux_client_write_packet(fd, &m) != 0)
		fatal("%s: write packet: %s", __func__, strerror(errno));

	buffer_clear(&m);

	/* Read their reply */
	if (mux_client_read_packet(fd, &m) != 0) {
		buffer_free(&m);
		return 0;
	}
	type = buffer_get_int(&m);
	if (type != MUX_S_PROXY) {
		e = buffer_get_string(&m, NULL);
		fatal("%s: master returned error: %s", __func__, e);
	}
	if ((rid = buffer_get_int(&m)) != muxclient_request_id)
		fatal("%s: out of sequence reply: my id %u theirs %u",
		    __func__, muxclient_request_id, rid);
	buffer_free(&m);

	debug3("%s: done", __func__);
	muxclient_request_id++;
	return 0;
}

static int
mux_client_request_stdio_fwd(int fd)
{
	Buffer m;
	char *e;
	u_int type, rid, sid;
	int devnull;

	debug3("%s: entering", __func__);

	if ((muxserver_pid = mux_client_request_alive(fd)) == 0) {
		error("%s: master alive request failed", __func__);
		return -1;
	}

	signal(SIGPIPE, SIG_IGN);

	if (stdin_null_flag) {
		if ((devnull = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(devnull, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (devnull > STDERR_FILENO)
			close(devnull);
	}

	buffer_init(&m);
	buffer_put_int(&m, MUX_C_NEW_STDIO_FWD);
	buffer_put_int(&m, muxclient_request_id);
	buffer_put_cstring(&m, ""); /* reserved */
	buffer_put_cstring(&m, options.stdio_forward_host);
	buffer_put_int(&m, options.stdio_forward_port);

	if (mux_client_write_packet(fd, &m) != 0)
		fatal("%s: write packet: %s", __func__, strerror(errno));

	/* Send the stdio file descriptors */
	if (mm_send_fd(fd, STDIN_FILENO) == -1 ||
	    mm_send_fd(fd, STDOUT_FILENO) == -1)
		fatal("%s: send fds failed", __func__);

	if (pledge("stdio proc tty", NULL) == -1)
		fatal("%s pledge(): %s", __func__, strerror(errno));

	debug3("%s: stdio forward request sent", __func__);

	/* Read their reply */
	buffer_clear(&m);

	if (mux_client_read_packet(fd, &m) != 0) {
		error("%s: read from master failed: %s",
		    __func__, strerror(errno));
		buffer_free(&m);
		return -1;
	}

	type = buffer_get_int(&m);
	if ((rid = buffer_get_int(&m)) != muxclient_request_id)
		fatal("%s: out of sequence reply: my id %u theirs %u",
		    __func__, muxclient_request_id, rid);
	switch (type) {
	case MUX_S_SESSION_OPENED:
		sid = buffer_get_int(&m);
		debug("%s: master session id: %u", __func__, sid);
		break;
	case MUX_S_PERMISSION_DENIED:
		e = buffer_get_string(&m, NULL);
		buffer_free(&m);
		fatal("Master refused stdio forwarding request: %s", e);
	case MUX_S_FAILURE:
		e = buffer_get_string(&m, NULL);
		buffer_free(&m);
		fatal("Stdio forwarding request failed: %s", e);
	default:
		buffer_free(&m);
		error("%s: unexpected response from master 0x%08x",
		    __func__, type);
		return -1;
	}
	muxclient_request_id++;

	signal(SIGHUP, control_client_sighandler);
	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

	/*
	 * Stick around until the controlee closes the client_fd.
	 */
	buffer_clear(&m);
	if (mux_client_read_packet(fd, &m) != 0) {
		if (errno == EPIPE ||
		    (errno == EINTR && muxclient_terminate != 0))
			return 0;
		fatal("%s: mux_client_read_packet: %s",
		    __func__, strerror(errno));
	}
	fatal("%s: master returned unexpected message %u", __func__, type);
}

static void
mux_client_request_stop_listening(int fd)
{
	Buffer m;
	char *e;
	u_int type, rid;

	debug3("%s: entering", __func__);

	buffer_init(&m);
	buffer_put_int(&m, MUX_C_STOP_LISTENING);
	buffer_put_int(&m, muxclient_request_id);

	if (mux_client_write_packet(fd, &m) != 0)
		fatal("%s: write packet: %s", __func__, strerror(errno));

	buffer_clear(&m);

	/* Read their reply */
	if (mux_client_read_packet(fd, &m) != 0)
		fatal("%s: read from master failed: %s",
		    __func__, strerror(errno));

	type = buffer_get_int(&m);
	if ((rid = buffer_get_int(&m)) != muxclient_request_id)
		fatal("%s: out of sequence reply: my id %u theirs %u",
		    __func__, muxclient_request_id, rid);
	switch (type) {
	case MUX_S_OK:
		break;
	case MUX_S_PERMISSION_DENIED:
		e = buffer_get_string(&m, NULL);
		fatal("Master refused stop listening request: %s", e);
	case MUX_S_FAILURE:
		e = buffer_get_string(&m, NULL);
		fatal("%s: stop listening request failed: %s", __func__, e);
	default:
		fatal("%s: unexpected response from master 0x%08x",
		    __func__, type);
	}
	buffer_free(&m);
	muxclient_request_id++;
}

/* Multiplex client main loop. */
int
muxclient(const char *path)
{
	struct sockaddr_un addr;
	int sock;
	u_int pid;

	if (muxclient_command == 0) {
		if (options.stdio_forward_host != NULL)
			muxclient_command = SSHMUX_COMMAND_STDIO_FWD;
		else
			muxclient_command = SSHMUX_COMMAND_OPEN;
	}

	switch (options.control_master) {
	case SSHCTL_MASTER_AUTO:
	case SSHCTL_MASTER_AUTO_ASK:
		debug("auto-mux: Trying existing master");
		/* FALLTHROUGH */
	case SSHCTL_MASTER_NO:
		break;
	default:
		return -1;
	}

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;

	if (strlcpy(addr.sun_path, path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long ('%s' >= %u bytes)", path,
		     (unsigned int)sizeof(addr.sun_path));

	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
		switch (muxclient_command) {
		case SSHMUX_COMMAND_OPEN:
		case SSHMUX_COMMAND_STDIO_FWD:
			break;
		default:
			fatal("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		if (errno == ECONNREFUSED &&
		    options.control_master != SSHCTL_MASTER_NO) {
			debug("Stale control socket %.100s, unlinking", path);
			unlink(path);
		} else if (errno == ENOENT) {
			debug("Control socket \"%.100s\" does not exist", path);
		} else {
			error("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		close(sock);
		return -1;
	}
	set_nonblock(sock);

	if (mux_client_hello_exchange(sock) != 0) {
		error("%s: master hello exchange failed", __func__);
		close(sock);
		return -1;
	}

	switch (muxclient_command) {
	case SSHMUX_COMMAND_ALIVE_CHECK:
		if ((pid = mux_client_request_alive(sock)) == 0)
			fatal("%s: master alive check failed", __func__);
		fprintf(stderr, "Master running (pid=%u)\r\n", pid);
		exit(0);
	case SSHMUX_COMMAND_TERMINATE:
		mux_client_request_terminate(sock);
		if (options.log_level != SYSLOG_LEVEL_QUIET)
			fprintf(stderr, "Exit request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_FORWARD:
		if (mux_client_forwards(sock, 0) != 0)
			fatal("%s: master forward request failed", __func__);
		exit(0);
	case SSHMUX_COMMAND_OPEN:
		if (mux_client_forwards(sock, 0) != 0) {
			error("%s: master forward request failed", __func__);
			return -1;
		}
		mux_client_request_session(sock);
		return -1;
	case SSHMUX_COMMAND_STDIO_FWD:
		mux_client_request_stdio_fwd(sock);
		exit(0);
	case SSHMUX_COMMAND_STOP:
		mux_client_request_stop_listening(sock);
		if (options.log_level != SYSLOG_LEVEL_QUIET)
			fprintf(stderr, "Stop listening request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_CANCEL_FWD:
		if (mux_client_forwards(sock, 1) != 0)
			error("%s: master cancel forward request failed",
			    __func__);
		exit(0);
	case SSHMUX_COMMAND_PROXY:
		mux_client_proxy(sock);
		return (sock);
	default:
		fatal("unrecognised muxclient_command %d", muxclient_command);
	}
}
@


1.63
log
@When tearing down ControlMaster connecctions, don't pollute stderr when
LogLevel=quiet.  Patch from Tim Kuijsten via tech@@.
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.62 2016/09/30 09:19:13 markus Exp $ */
a2165 2
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(path) + 1;
d2175 1
a2175 1
	if (connect(sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
@


1.62
log
@ssh proxy mux mode (-O proxy; idea from Simon Tatham):
- mux client speaks the ssh-packet protocol directly over unix-domain socket.
- mux server acts as a proxy, translates channel IDs and relays to the server.
- no filedescriptor passing necessary.
- combined with unix-domain forwarding it's even possible to run mux client
  and server on different machines.
feedback & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.61 2016/08/08 22:40:57 dtucker Exp $ */
d2215 2
a2216 1
		fprintf(stderr, "Exit request sent.\r\n");
d2234 2
a2235 1
		fprintf(stderr, "Stop listening request sent.\r\n");
@


1.61
log
@Improve error message for overlong ControlPath.  ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.60 2016/06/03 03:14:41 dtucker Exp $ */
d69 1
d135 1
d144 1
d162 1
d176 1
d1105 12
d1960 35
d2139 1
a2139 1
void
d2161 1
a2161 1
		return;
d2197 1
a2197 1
		return;
d2204 1
a2204 1
		return;
d2224 1
a2224 1
			return;
d2227 1
a2227 1
		return;
d2240 3
@


1.60
log
@Move the host and port used by ssh -W into the Options struct.
This will make future changes a bit easier.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.59 2016/04/01 02:34:10 djm Exp $ */
d2119 2
a2120 1
		fatal("ControlPath too long");
@


1.59
log
@whitespace at EOL
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.58 2016/01/13 23:04:47 djm Exp $ */
a77 2
extern char *stdio_forward_host;
extern int stdio_forward_port;
d1972 2
a1973 2
	buffer_put_cstring(&m, stdio_forward_host);
	buffer_put_int(&m, stdio_forward_port);
d2095 1
a2095 1
		if (stdio_forward_host != NULL)
@


1.58
log
@eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.57 2015/12/26 07:46:03 semarie Exp $ */
d1287 1
a1287 1
			fatal("%s: link mux listener %s => %s: %s", __func__, 
@


1.57
log
@adjust pledge promises for ControlMaster: when using "ask" or "autoask", the process will use ssh-askpass for asking confirmation.

problem found by halex@@

ok halex@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.56 2015/12/03 17:00:18 semarie Exp $ */
d1344 1
a1344 1
		client_x11_get_proto(display, options.xauth_location,
d1346 10
a1355 8
		    &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication "
		    "spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto,
		    data, 1);
		client_expect_confirm(id, "X11 forwarding", CONFIRM_WARN);
		/* XXX exit_on_forward_failure */
@


1.56
log
@pledges ssh client:
  - mux client: which is used when ControlMaster is in use.
    will end with "stdio proc tty" (proc is to permit sending SIGWINCH to mux master on window resize)

  - client loop: several levels of pledging depending of your used options

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.55 2015/10/15 23:51:40 djm Exp $ */
a1834 3
	if (pledge("stdio proc tty", NULL) == -1)
		fatal("%s pledge(): %s", __func__, strerror(errno));

d1873 3
a2146 3

	if (pledge("stdio sendfd proc tty", NULL) == -1)
		fatal("%s pledge(): %s", __func__, strerror(errno));
@


1.55
log
@fix some signed/unsigned integer type mismatches in format
strings; reported by Nicholas Lemonias
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.54 2015/08/19 23:18:26 djm Exp $ */
d1835 3
d1983 3
d2147 3
@


1.54
log
@fix free() of uninitialised pointer reported by Mateusz Kocielski;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.53 2015/05/01 04:03:20 djm Exp $ */
d1728 1
a1728 1
			fprintf(stdout, "%u\n", fwd->allocated_port);
d2152 1
a2152 1
		fprintf(stderr, "Master running (pid=%d)\r\n", pid);
@


1.53
log
@remove failed remote forwards established by muliplexing from the
list of active forwards; bz#2363, patch mostly by Yoann Ricordel;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.52 2015/05/01 04:01:58 djm Exp $ */
d655 2
d823 2
@


1.53.2.1
log
@MFC changes by djm@@cvs.openbsd.org, 2016/01/13 16:04:47

"eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@"
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.53 2015/05/01 04:03:20 djm Exp $ */
d1340 1
a1340 1
		if (client_x11_get_proto(display, options.xauth_location,
d1342 8
a1349 10
		    &proto, &data) == 0) {
			/* Request forwarding with authentication spoofing. */
			debug("Requesting X11 forwarding with authentication "
			    "spoofing.");
			x11_request_forwarding_with_spoofing(id, display, proto,
			    data, 1);
			/* XXX exit_on_forward_failure */
			client_expect_confirm(id, "X11 forwarding",
			    CONFIRM_WARN);
		}
@


1.52
log
@reduce stderr spam when using ssh -S /path/mux -O forward -R 0:...
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.51 2015/04/24 01:36:00 deraadt Exp $ */
d583 3
a585 1
	if (fctx->fid >= options.num_remote_forwards) {
d619 11
@


1.51
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.50 2015/01/20 23:14:00 deraadt Exp $ */
d595 1
a595 1
			logit("Allocated port %u for mux remote forward"
d1706 1
a1706 1
		logit("Allocated port %u for remote forward to %s:%d",
@


1.50
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.49 2014/12/22 07:24:11 djm Exp $ */
d340 1
a340 1
		cctx->env = xrealloc(cctx->env, env_len + 2,
@


1.50.2.1
log
@MFC changes by djm@@cvs.openbsd.org, 2016/01/13 16:04:47

"eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@"
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.50 2015/01/20 23:14:00 deraadt Exp $ */
d1327 1
a1327 1
		if (client_x11_get_proto(display, options.xauth_location,
d1329 8
a1336 10
		    &proto, &data) == 0) {
			/* Request forwarding with authentication spoofing. */
			debug("Requesting X11 forwarding with authentication "
			    "spoofing.");
			x11_request_forwarding_with_spoofing(id, display, proto,
			    data, 1);
			/* XXX exit_on_forward_failure */
			client_expect_confirm(id, "X11 forwarding",
			    CONFIRM_WARN);
		}
@


1.49
log
@fix passing of wildcard forward bind addresses when connection
multiplexing is in use; patch from Sami Hartikainen via bz#2324;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.48 2014/07/17 07:22:19 djm Exp $ */
a33 1
#include <sys/param.h>
@


1.48
log
@reflect stdio-forward ("ssh -W host:port ...") failures in exit status.
previously we were always returning 0. bz#2255 reported by Brendan
Germain; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.47 2014/07/17 00:10:18 djm Exp $ */
d1673 2
a1674 1
		    fwd->listen_host == NULL ? "" : fwd->listen_host);
@


1.47
log
@preserve errno across syscall
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.46 2014/07/15 15:54:14 millert Exp $ */
d95 5
d152 1
d919 1
d999 36
d1036 9
a1044 4
	/* XXX defer until channel confirmed */
	buffer_put_int(r, MUX_S_SESSION_OPENED);
	buffer_put_int(r, rid);
	buffer_put_int(r, nc->self);
d1046 5
a1050 1
	return 0;
d1991 1
a1991 1
		fatal("%s: stdio forwarding request failed: %s", __func__, e);
@


1.46
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.45 2014/04/28 03:09:18 djm Exp $ */
d1167 1
d1194 1
d1197 1
a1197 1
		if (errno == EINVAL || errno == EADDRINUSE) {
@


1.45
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.44 2013/07/12 00:19:58 djm Exp $ */
d499 1
a499 1
format_forward(u_int ftype, Forward *fwd)
d506 1
d508 1
a508 1
		    (options.gateway_ports ? "*" : "LOCALHOST") :
d510 1
d516 1
a516 1
		    (options.gateway_ports ? "*" : "LOCALHOST") :
d521 1
d525 1
d545 1
a545 1
compare_forward(Forward *a, Forward *b)
d549 2
d555 2
d568 1
a568 1
	Forward *rfwd;
d585 2
a586 1
	    rfwd->listen_port, rfwd->connect_host, rfwd->connect_port);
d606 6
a611 2
		xasprintf(&failmsg, "remote port forwarding failed for "
		    "listen port %d", rfwd->listen_port);
d630 1
a630 1
	Forward fwd;
d632 1
d637 1
a637 1
	fwd.listen_host = fwd.connect_host = NULL;
d639 1
a639 1
	    (fwd.listen_host = buffer_get_string_ret(m, NULL)) == NULL ||
d641 1
a641 1
	    (fwd.connect_host = buffer_get_string_ret(m, NULL)) == NULL ||
d643 2
a644 1
	    lport > 65535 || cport > 65535) {
d649 10
d660 4
d665 4
a668 8
	if (*fwd.listen_host == '\0') {
		free(fwd.listen_host);
		fwd.listen_host = NULL;
	}
	if (*fwd.connect_host == '\0') {
		free(fwd.connect_host);
		fwd.connect_host = NULL;
	}
d677 2
a678 2
		free(fwd.listen_host);
		free(fwd.connect_host);
d684 6
a689 1
	if (fwd.listen_port >= 65536) {
d694 2
a695 2
	if (fwd.connect_port >= 65536 || (ftype != MUX_FWD_DYNAMIC &&
	    ftype != MUX_FWD_REMOTE && fwd.connect_port == 0)) {
d700 1
a700 1
	if (ftype != MUX_FWD_DYNAMIC && fwd.connect_host == NULL) {
d751 2
a752 3
		if (!channel_setup_local_fwd_listener(fwd.listen_host,
		    fwd.listen_port, fwd.connect_host, fwd.connect_port,
		    options.gateway_ports)) {
d765 1
a765 2
		fwd.handle = channel_request_remote_forwarding(fwd.listen_host,
		    fwd.listen_port, fwd.connect_host, fwd.connect_port);
d786 1
d788 1
d796 1
a796 1
	Forward fwd, *found_fwd;
d799 1
d801 1
a801 1
	int i, listen_port, ret = 0;
a803 1
	fwd.listen_host = fwd.connect_host = NULL;
d805 1
a805 1
	    (fwd.listen_host = buffer_get_string_ret(m, NULL)) == NULL ||
d807 1
a807 1
	    (fwd.connect_host = buffer_get_string_ret(m, NULL)) == NULL ||
d809 2
a810 1
	    lport > 65535 || cport > 65535) {
a814 2
	fwd.listen_port = lport;
	fwd.connect_port = cport;
d816 3
a818 3
	if (*fwd.listen_host == '\0') {
		free(fwd.listen_host);
		fwd.listen_host = NULL;
d820 3
a822 3
	if (*fwd.connect_host == '\0') {
		free(fwd.connect_host);
		fwd.connect_host = NULL;
d825 12
d871 1
a871 1
		 * to lookup the actual listen port.
d873 1
a873 4
	        listen_port = (fwd.listen_port == 0) ?
		    found_fwd->allocated_port : fwd.listen_port;
		if (channel_request_rforward_cancel(fwd.listen_host,
		    listen_port) == -1)
d877 2
a878 3
		if (channel_cancel_lport_listener(fwd.listen_host,
		    fwd.listen_port, fwd.connect_port,
		    options.gateway_ports) == -1)
d887 1
d889 1
d891 1
d900 2
a901 2
	free(fwd.listen_host);
	free(fwd.connect_host);
a1162 1
	struct sockaddr_un addr;
a1190 15
	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(options.control_path) + 1;

	if (strlcpy(addr.sun_path, options.control_path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path)) {
		error("ControlPath \"%s\" too long for Unix domain socket",
		    options.control_path);
		goto disable_mux_master;
	}

	if ((muxserver_sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

d1192 3
a1194 1
	if (bind(muxserver_sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
d1208 4
a1211 2
		} else
			fatal("%s bind(): %s", __func__, strerror(errno));
a1212 4
	umask(old_umask);

	if (listen(muxserver_sock, 64) == -1)
		fatal("%s listen(): %s", __func__, strerror(errno));
d1600 1
a1600 1
mux_client_forward(int fd, int cancel_flag, u_int ftype, Forward *fwd)
d1615 6
a1620 2
	buffer_put_cstring(&m,
	    fwd->listen_host == NULL ? "" : fwd->listen_host);
d1622 6
a1627 2
	buffer_put_cstring(&m,
	    fwd->connect_host == NULL ? "" : fwd->connect_host);
@


1.44
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.43 2013/06/05 02:07:29 dtucker Exp $ */
d1000 1
a1000 1
	void *ptr;
d1412 1
a1412 1
	void *ptr;
@


1.43
log
@fix leaks in mux error paths, from Zhenbo Xu, found by Melton. bz#1967, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.42 2013/06/02 23:36:29 dtucker Exp $ */
d620 1
d626 1
a626 1
	    buffer_get_int_ret(&fwd.listen_port, m) != 0 ||
d628 2
a629 1
	    buffer_get_int_ret(&fwd.connect_port, m) != 0) {
d634 2
a635 1

d771 1
d776 1
a776 1
	    buffer_get_int_ret(&fwd.listen_port, m) != 0 ||
d778 2
a779 1
	    buffer_get_int_ret(&fwd.connect_port, m) != 0) {
d784 2
@


1.42
log
@No need for the mux cleanup callback to be visible so restore it to static
and call it through the detach_user function pointer.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.41 2013/05/17 00:13:13 djm Exp $ */
d278 1
d1411 3
a1413 1
		debug3("%s: read header failed: %s", __func__, strerror(errno));
d1421 1
@


1.41
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.40 2013/04/22 01:17:18 dtucker Exp $ */
d174 1
a174 1
void
@


1.40
log
@typo in debug output: evitval->exitval
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.39 2013/04/05 00:58:51 djm Exp $ */
d277 1
a277 2
			if (name != NULL)
				xfree(name);
d281 2
a282 2
		xfree(name);
		xfree(value);
d313 2
a314 4
		if (cmd != NULL)
			xfree(cmd);
		if (reserved != NULL)
			xfree(reserved);
d316 4
a319 6
			xfree(cctx->env[j]);
		if (env_len > 0)
			xfree(cctx->env);
		if (cctx->term != NULL)
			xfree(cctx->term);
		xfree(cctx);
d323 1
a323 1
	xfree(reserved);
d331 1
a331 1
			xfree(cp);
d352 1
a352 1
	xfree(cmd);
d363 3
a365 4
				xfree(cctx->env[j]);
			if (env_len > 0)
				xfree(cctx->env);
			xfree(cctx->term);
d367 1
a367 1
			xfree(cctx);
d392 1
a392 1
		xfree(cctx->term);
d395 2
a396 2
				xfree(cctx->env[i]);
			xfree(cctx->env);
d399 1
a399 1
		xfree(cctx);
d604 1
a604 1
	xfree(failmsg);
d633 1
a633 1
		xfree(fwd.listen_host);
d637 1
a637 1
		xfree(fwd.connect_host);
d648 2
a649 4
		if (fwd.listen_host)
			xfree(fwd.listen_host);
		if (fwd.connect_host)
			xfree(fwd.connect_host);
d751 1
a751 2
	if (fwd_desc != NULL)
		xfree(fwd_desc);
d753 2
a754 4
		if (fwd.listen_host != NULL)
			xfree(fwd.listen_host);
		if (fwd.connect_host != NULL)
			xfree(fwd.connect_host);
d780 1
a780 1
		xfree(fwd.listen_host);
d784 1
a784 1
		xfree(fwd.connect_host);
d841 2
a842 4
		if (found_fwd->listen_host != NULL)
			xfree(found_fwd->listen_host);
		if (found_fwd->connect_host != NULL)
			xfree(found_fwd->connect_host);
d851 3
a853 6
	if (fwd_desc != NULL)
		xfree(fwd_desc);
	if (fwd.listen_host != NULL)
		xfree(fwd.listen_host);
	if (fwd.connect_host != NULL)
		xfree(fwd.connect_host);
d870 2
a871 4
		if (reserved != NULL)
			xfree(reserved);
		if (chost != NULL)
			xfree(chost);
d875 1
a875 1
	xfree(reserved);
d887 1
a887 1
			xfree(chost);
d911 1
a911 1
		xfree(chost);
d973 1
a973 1
		xfree(options.control_path);
d1169 2
a1170 2
			xfree(orig_control_path);
			xfree(options.control_path);
d1195 1
a1195 1
	xfree(options.control_path);
d1280 1
a1280 1
	xfree(cctx->term);
d1283 2
a1284 2
			xfree(cctx->env[i]);
		xfree(cctx->env);
d1286 1
a1286 1
	xfree(cctx);
d1464 2
a1465 2
		xfree(name);
		xfree(value);
d1574 1
a1574 1
	xfree(fwd_desc);
@


1.39
log
@cleanup mux-created channels that are in SSH_CHANNEL_OPENING state too
(in addition to ones already in OPEN); bz#2079, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.38 2013/01/02 00:32:07 djm Exp $ */
d1091 1
a1091 1
	debug3("%s: channel %d: exit message, evitval %d", __func__, c->self,
@


1.38
log
@channel_setup_local_fwd_listener() returns 0 on failure, not -ve
bz#2055 reported by mathieu.lacage AT gmail.com
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.37 2012/08/17 00:45:45 dtucker Exp $ */
d209 2
a210 1
		if (sc->type != SSH_CHANNEL_OPEN) {
@


1.37
log
@Force a clean shutdown of ControlMaster client sessions when the ~. escape
sequence is used.  This means that ~. should now work in mux clients even
if the server is no longer responding.  Found by tedu, ok djm.
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.36 2012/07/06 01:37:21 djm Exp $ */
d724 1
a724 1
		if (channel_setup_local_fwd_listener(fwd.listen_host,
d726 1
a726 1
		    options.gateway_ports) < 0) {
@


1.36
log
@fix memory leak of passed-in environment variables and connection
context when new session message is malformed; bz#2003 from Bert.Wesarg
AT googlemail.com
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.35 2012/06/01 01:01:22 djm Exp $ */
d174 1
a174 1
static void
@


1.35
log
@fix memory leak when mux socket creation fails; bz#2002 from bert.wesarg
AT googlemail.com
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.34 2012/01/07 21:11:36 djm Exp $ */
d302 2
d317 4
d323 1
a329 2
	cctx->env = NULL;
	env_len = 0;
d404 1
@


1.34
log
@fix double-free in new session handler
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.33 2011/12/04 23:16:12 djm Exp $ */
d1180 1
a1201 1
		xfree(orig_control_path);
@


1.33
log
@revert:

> revision 1.32
> date: 2011/12/02 00:41:56;  author: djm;  state: Exp;  lines: +4 -1
> fix bz#1948: ssh -f doesn't fork for multiplexed connection.
> ok dtucker@@

it interacts badly with ControlPersist
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.31 2011/09/23 07:45:05 markus Exp $ */
d327 1
a327 2
		if ((cp = buffer_get_string_ret(m, &len)) == NULL) {
			xfree(cmd);
a328 1
		}
@


1.32
log
@fix bz#1948: ssh -f doesn't fork for multiplexed connection.
ok dtucker@@
@
text
@a80 1
extern int fork_after_authentication_flag;
a1780 2
	if (fork_after_authentication_flag)
		daemon(1, 1);
@


1.31
log
@unbreak remote portforwarding with dynamic allocated listen ports:
1) send the actual listen port in the open message (instead of 0).
   this allows multiple forwardings with a dynamic listen port
2) update the matching permit-open entry, so we can identify where
   to connect to
report: den at skbkontur.ru and P. Szczygielski
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.30 2011/09/09 22:46:44 djm Exp $ */
d81 1
d1782 2
@


1.30
log
@support for cancelling local and remote port forwards via the multiplex
socket. Use ssh -O cancel -L xx:xx:xx -R yy:yy:yy user@@host" to request
the cancellation of the specified forwardings; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.29 2011/06/22 22:08:42 djm Exp $ */
d587 2
d595 2
d735 3
a737 2
		if (channel_request_remote_forwarding(fwd.listen_host,
		    fwd.listen_port, fwd.connect_host, fwd.connect_port) < 0)
d772 1
a772 1
	int i, ret = 0;
d827 2
d830 2
d833 1
a833 1
		    fwd.listen_port) == -1)
@


1.29
log
@hook up a channel confirm callback to warn the user then requested X11
forwarding was refused by the server; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.28 2011/05/08 12:52:01 djm Exp $ */
d763 1
a763 1
	Forward fwd;
d765 1
d767 1
a767 1
	int ret = 0;
d789 1
a789 1
	debug2("%s: channel %d: request %s", __func__, c->self,
d792 45
a836 4
	/* XXX implement this */
	buffer_put_int(r, MUX_S_FAILURE);
	buffer_put_int(r, rid);
	buffer_put_cstring(r, "unimplemented");
d838 11
d1569 1
a1569 1
mux_client_request_forward(int fd, u_int ftype, Forward *fwd)
d1576 2
a1577 1
	debug("Requesting %s", fwd_desc);
d1581 1
a1581 1
	buffer_put_int(&m, MUX_C_OPEN_FWD);
d1610 2
d1641 1
a1641 1
mux_client_request_forwards(int fd)
d1643 1
a1643 1
	int i;
d1645 2
a1646 1
	debug3("%s: requesting forwardings: %d local, %d remote", __func__,
d1651 1
a1651 1
		if (mux_client_request_forward(fd,
d1655 1
a1655 1
			return -1;
d1658 1
a1658 1
		if (mux_client_request_forward(fd, MUX_FWD_REMOTE,
d1660 1
a1660 1
			return -1;
d1662 1
a1662 1
	return 0;
d2049 1
a2049 1
		if (mux_client_request_forwards(sock) != 0)
d2053 1
a2053 1
		if (mux_client_request_forwards(sock) != 0) {
d2065 5
@


1.28
log
@improve our behaviour when TTY allocation fails: if we are in
RequestTTY=auto mode (the default), then do not treat at TTY
allocation error as fatal but rather just restore the local TTY
to cooked mode and continue. This is more graceful on devices that
never allocate TTYs.

If RequestTTY is set to "yes" or "force", then failure to allocate
a TTY is fatal.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.27 2011/05/06 21:34:32 djm Exp $ */
d1199 4
a1202 2
		x11_request_forwarding_with_spoofing(id, display, proto, data);
		/* XXX wait for reply */
@


1.27
log
@Add a RequestTTY ssh_config option to allow configuration-based
control over tty allocation (like -t/-T); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.26 2011/05/05 05:12:08 djm Exp $ */
d139 1
d1041 21
d1613 1
a1613 1
	int devnull;
d1709 1
d1725 21
a1745 1
		if (type != MUX_S_EXIT_MESSAGE) {
a1748 8
		if ((esid = buffer_get_int(&m)) != sid)
			fatal("%s: exit on unknown session: my id %u theirs %u",
			    __func__, sid, esid);
		debug("%s: master session id: %u", __func__, sid);
		if (exitval_seen)
			fatal("%s: exitval sent twice", __func__);
		exitval = buffer_get_int(&m);
		exitval_seen = 1;
d1752 2
a1753 1
	leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
@


1.26
log
@gracefully fall back when ControlPath is too large for a
sockaddr_un. ok markus@@ as part of a larger diff
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.25 2011/04/17 22:42:41 djm Exp $ */
a72 1
extern int force_tty_flag;
d1688 1
a1688 1
		enter_raw_mode(force_tty_flag);
d1717 1
a1717 1
	leave_raw_mode(force_tty_flag);
@


1.25
log
@allow graceful shutdown of multiplexing: request that a mux server removes
its listener socket and refuse future multiplexing requests; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.24 2011/01/13 21:54:53 djm Exp $ */
d1080 5
a1084 2
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");
a1090 1
		muxserver_sock = -1;
d1095 4
a1098 2
			close(muxserver_sock);
			muxserver_sock = -1;
@


1.24
log
@correct error messages; patch from bert.wesarg AT googlemail.com
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.23 2010/10/12 02:22:24 dtucker Exp $ */
d132 1
d155 1
d168 1
d904 33
d1828 44
d1963 4
@


1.23
log
@Typo in confirmation message.  bz#1827, patch from imorgan at nas nasa gov
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.22 2010/09/20 07:19:27 djm Exp $ */
d1509 1
a1509 1
		error("%s: session request failed: %s", __func__, e);
d1628 1
a1628 1
		error("Master refused forwarding request: %s", e);
d1633 1
a1633 1
		error("%s: forwarding request failed: %s", __func__, e);
d1760 1
a1760 1
		fatal("Master refused forwarding request: %s", e);
@


1.22
log
@"atomically" create the listening mux socket by binding it on a temorary
name and then linking it into position after listen() has succeeded.

this allows the mux clients to determine that the server socket is
either ready or stale without races. stale server sockets are now
automatically removed

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.21 2010/06/25 23:15:36 djm Exp $ */
d865 1
a865 1
		if (!ask_permission("Allow forward to to %s:%u? ",
@


1.21
log
@Add X11ForwardTimeout option to specify timeout for untrusted X11
authentication cookies to avoid fallback in X11 code to fully-trusted
implicit authentication using SO_PEERCRED described at:
http://lists.x.org/archives/xorg-devel/2010-May/008636.html

After the X11ForwardTimeout has expired the client will now refuse
incoming X11 channel opens.

based on patch from Tavis Ormandy; "nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.20 2010/06/25 07:14:46 djm Exp $ */
d1011 3
d1021 17
d1056 1
d1071 17
d1093 1
a1093 1
	    0, addr.sun_path, 1);
d1839 5
a1843 1
		if (errno == ENOENT)
d1845 1
a1845 1
		else {
@


1.20
log
@bz#1327: remove hardcoded limit of 100 permitopen clauses and port
forwards per direction; ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.19 2010/06/17 07:07:30 djm Exp $ */
d1092 1
d1095 2
a1096 1
		    options.forward_x11_trusted, &proto, &data);
d1098 2
a1099 1
		debug("Requesting X11 forwarding with authentication spoofing.");
@


1.19
log
@Correct sizing of object to be allocated by calloc(), replacing
sizeof(state) with sizeof(*state). This worked by accident since
the struct contained a single int at present, but could have broken
in the future. patch from hyc AT symas.com
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.18 2010/05/16 12:55:51 markus Exp $ */
d713 1
a713 3
		if (options.num_local_forwards + 1 >=
		    SSH_MAX_FORWARDS_PER_DIRECTION ||
		    channel_setup_local_fwd_listener(fwd.listen_host,
d728 1
a728 3
		if (options.num_remote_forwards + 1 >=
		    SSH_MAX_FORWARDS_PER_DIRECTION ||
		    channel_request_remote_forwarding(fwd.listen_host,
d735 1
a735 1
		fctx->fid = options.num_remote_forwards-1;
@


1.18
log
@mux support for remote forwarding with dynamic port allocation,
use with
	LPORT=`ssh -S muxsocket -R0:localhost:25 -O forward somehost`
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.17 2010/05/14 23:29:23 djm Exp $ */
d917 1
a917 1
		state = xcalloc(1, sizeof(state));
@


1.17
log
@Pause the mux channel while waiting for reply from aynch callbacks.
Prevents misordering of replies if new requests arrive while waiting.

Extend channel open confirm callback to allow signalling failure
conditions as well as success. Use this to 1) fix a memory leak, 2)
start using the above pause mechanism and 3) delay sending a success/
failure message on mux slave session open until we receive a reply from
the server.

motivated by and with feedback from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.16 2010/04/23 22:27:38 djm Exp $ */
d57 1
d96 7
d138 1
d552 55
d642 4
a645 2
		xfree(fwd.listen_host);
		xfree(fwd.connect_host);
d651 1
a651 2
	/* XXX support rport0 forwarding with reply of port assigned */
	if (fwd.listen_port == 0 || fwd.listen_port >= 65536) {
d686 11
a696 2
			    options.remote_forwards + i))
				goto exists;
d728 2
a729 1
		/* XXX wait for remote to confirm */
d736 6
d743 3
d1455 9
d1828 4
@


1.16
log
@set "detach_close" flag when registering channel cleanup callbacks.
This causes the channel to close normally when its fds close and
hangs when terminating a mux slave using ~. bz#1758; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.15 2010/04/10 05:48:16 djm Exp $ */
d92 1
d136 1
a136 1
static void mux_session_confirm(int, void *);
d288 1
d442 1
d445 1
a445 6
	/* prepare reply */
	/* XXX defer until mux_session_confirm() fires */
	buffer_put_int(r, MUX_S_SESSION_OPENED);
	buffer_put_int(r, rid);
	buffer_put_int(r, nc->self);

d983 1
a983 1
mux_session_confirm(int id, void *arg)
d987 1
a987 1
	Channel *c;
d989 1
d995 13
d1030 15
@


1.15
log
@fix NULL dereference; from matthew.haub AT alumni.adelaide.edu.au
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.14 2010/01/30 02:54:53 djm Exp $ */
d440 1
a440 1
	channel_register_cleanup(nc->self, mux_master_session_cleanup_cb, 0);
d812 1
a812 1
	channel_register_cleanup(nc->self, mux_master_session_cleanup_cb, 0);
@


1.14
log
@don't mark channel as read failed if it is already closing; suppresses
harmless error messages when connecting to SSH.COM Tectia server
report by imorgan AT nas.nasa.gov
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.13 2010/01/29 20:16:17 djm Exp $ */
d192 1
a192 1
			debug2("%s: channel %d n session channel %d",
@


1.13
log
@kill correct channel (was killing already-dead mux channel, not
its session channel)
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.12 2010/01/27 13:26:17 djm Exp $ */
d200 4
a203 2
			chan_read_failed(sc);
			chan_write_failed(sc);
@


1.12
log
@fix bug introduced in mux rewrite:

In a mux master, when a socket to a mux slave closes before its server
session (as may occur when the slave has been signalled), gracefully
close the server session rather than deleting its channel immediately.
A server may have more messages on that channel to send (e.g. an exit
message) that will fatal() the client if they are sent to a channel that
has been prematurely deleted.

spotted by imorgan AT nas.nasa.gov
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.11 2010/01/26 02:15:20 djm Exp $ */
d198 1
a198 1
			chan_mark_dead(c);
@


1.11
log
@-Wuninitialized and remove a // comment; from portable
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.10 2010/01/26 01:28:35 djm Exp $ */
d196 7
a202 1
		chan_mark_dead(sc);
@


1.10
log
@rewrite ssh(1) multiplexing code to a more sensible protocol.

The new multiplexing code uses channels for the listener and
accepted control sockets to make the mux master non-blocking, so
no stalls when processing messages from a slave.

avoid use of fatal() in mux master protocol parsing so an errant slave
process cannot take down a running master.

implement requesting of port-forwards over multiplexed sessions. Any
port forwards requested by the slave are added to those the master has
established.

add support for stdio forwarding ("ssh -W host:port ...") in mux slaves.

document master/slave mux protocol so that other tools can use it to
control a running ssh(1). Note: there are no guarantees that this
protocol won't be incompatibly changed (though it is versioned).

feedback Salvador Fandino, dtucker@@
channel changes ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.9 2010/01/09 05:04:24 djm Exp $ */
a19 2
// XXX signal of slave passed to master

d279 1
a279 1
	cmd = NULL;
d289 4
d299 1
d332 1
d726 1
d730 2
@


1.9
log
@quell tc[gs]etattr warnings when forcing a tty (ssh -tt), since we
usually don't actually have a tty to read/set; bz#1686 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.8 2009/08/20 23:54:28 dtucker Exp $ */
d20 2
d24 1
a24 3
 *   1. partial reads in muxserver_accept_control (maybe make channels
 *      from accepted connections)
 *   2. Better signalling from master to slave, especially passing of
d26 7
a32 9
 *   3. Better fall-back from mux slave error to new connection.
 *   3. Add/delete forwardings via slave
 *   4. ExitOnForwardingFailure (after #3 obviously)
 *   5. Maybe extension mechanisms for multi-X11/multi-agent forwarding
 *   6. Document the mux mini-protocol somewhere.
 *   7. Support ~^Z in mux slaves.
 *   8. Inspect or control sessions in master.
 *   9. If we ever support the "signal" channel request, send signals on
 *      sessions in master.
d44 1
d55 1
d80 3
d86 4
a89 4
	int want_tty;
	int want_subsys;
	int want_x_fwd;
	int want_agent_fwd;
d99 3
d111 5
d117 43
a159 1
/* ** Multiplexing master support */
d161 4
a164 3
/* Prepare a mux master to listen on a Unix domain socket. */
void
muxserver_listen(void)
d166 1
a166 20
	struct sockaddr_un addr;
	mode_t old_umask;

	if (options.control_path == NULL ||
	    options.control_master == SSHCTL_MASTER_NO)
		return;

	debug("setting up multiplex master socket");

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(options.control_path) + 1;

	if (strlcpy(addr.sun_path, options.control_path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((muxserver_sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));
d168 10
a177 14
	old_umask = umask(0177);
	if (bind(muxserver_sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
		muxserver_sock = -1;
		if (errno == EINVAL || errno == EADDRINUSE) {
			error("ControlSocket %s already exists, "
			    "disabling multiplexing", options.control_path);
			close(muxserver_sock);
			muxserver_sock = -1;
			xfree(options.control_path);
			options.control_path = NULL;
			options.control_master = SSHCTL_MASTER_NO;
			return;
		} else
			fatal("%s bind(): %s", __func__, strerror(errno));
d179 1
a179 6
	umask(old_umask);

	if (listen(muxserver_sock, 64) == -1)
		fatal("%s listen(): %s", __func__, strerror(errno));

	set_nonblock(muxserver_sock);
d182 2
a183 1
/* Callback on open confirmation in mux master for a mux client session. */
d185 1
a185 1
mux_session_confirm(int id, void *arg)
d187 1
a187 30
	struct mux_session_confirm_ctx *cctx = arg;
	const char *display;
	Channel *c;
	int i;

	if (cctx == NULL)
		fatal("%s: cctx == NULL", __func__);
	if ((c = channel_lookup(id)) == NULL)
		fatal("%s: no channel for id %d", __func__, id);

	display = getenv("DISPLAY");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto, data);
		/* XXX wait for reply */
	}

	if (cctx->want_agent_fwd && options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env);
d189 10
a198 7
	c->open_confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	xfree(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			xfree(cctx->env[i]);
		xfree(cctx->env);
d200 1
a200 1
	xfree(cctx);
d203 3
a205 7
/*
 * Accept a connection on the mux master socket and process the
 * client's request. Returns flag indicating whether mux master should
 * begin graceful close.
 */
int
muxserver_accept_control(void)
d207 2
a208 11
	Buffer m;
	Channel *c;
	int client_fd, new_fd[3], ver, allowed, window, packetmax;
	socklen_t addrlen;
	struct sockaddr_storage addr;
	struct mux_session_confirm_ctx *cctx;
	char *cmd;
	u_int i, j, len, env_len, mux_command, flags, escape_char;
	uid_t euid;
	gid_t egid;
	int start_close = 0;
d210 1
a210 8
	/*
	 * Accept connection on control socket
	 */
	memset(&addr, 0, sizeof(addr));
	addrlen = sizeof(addr);
	if ((client_fd = accept(muxserver_sock,
	    (struct sockaddr*)&addr, &addrlen)) == -1) {
		error("%s accept: %s", __func__, strerror(errno));
d212 3
a214 11
	}

	if (getpeereid(client_fd, &euid, &egid) < 0) {
		error("%s getpeereid failed: %s", __func__, strerror(errno));
		close(client_fd);
		return 0;
	}
	if ((euid != 0) && (getuid() != euid)) {
		error("control mode uid mismatch: peer euid %u != uid %u",
		    (u_int) euid, (u_int) getuid());
		close(client_fd);
d218 3
a220 2
	/* XXX handle asynchronously */
	unset_nonblock(client_fd);
d222 2
a223 14
	/* Read command */
	buffer_init(&m);
	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return 0;
	}
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return 0;
	}
d225 1
a225 3
	allowed = 1;
	mux_command = buffer_get_int(&m);
	flags = buffer_get_int(&m);
d227 5
a231 1
	buffer_clear(&m);
d233 27
a259 26
	switch (mux_command) {
	case SSHMUX_COMMAND_OPEN:
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
			allowed = ask_permission("Allow shared connection "
			    "to %s? ", host);
		/* continue below */
		break;
	case SSHMUX_COMMAND_TERMINATE:
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
			allowed = ask_permission("Terminate shared connection "
			    "to %s? ", host);
		if (allowed)
			start_close = 1;
		/* FALLTHROUGH */
	case SSHMUX_COMMAND_ALIVE_CHECK:
		/* Reply for SSHMUX_COMMAND_TERMINATE and ALIVE_CHECK */
		buffer_clear(&m);
		buffer_put_int(&m, allowed);
		buffer_put_int(&m, getpid());
		if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
			error("%s: client msg_send failed", __func__);
			close(client_fd);
			buffer_free(&m);
			return start_close;
d261 3
a263 8
		buffer_free(&m);
		close(client_fd);
		return start_close;
	default:
		error("Unsupported command %d", mux_command);
		buffer_free(&m);
		close(client_fd);
		return 0;
d265 12
d279 16
a294 8
	buffer_clear(&m);
	buffer_put_int(&m, allowed);
	buffer_put_int(&m, getpid());
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return 0;
d296 1
d298 21
a318 19
	if (!allowed) {
		error("Refused control connection");
		close(client_fd);
		buffer_free(&m);
		return 0;
	}

	buffer_clear(&m);
	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return 0;
	}
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return 0;
d321 4
a324 7
	cctx = xcalloc(1, sizeof(*cctx));
	cctx->want_tty = (flags & SSHMUX_FLAG_TTY) != 0;
	cctx->want_subsys = (flags & SSHMUX_FLAG_SUBSYS) != 0;
	cctx->want_x_fwd = (flags & SSHMUX_FLAG_X11_FWD) != 0;
	cctx->want_agent_fwd = (flags & SSHMUX_FLAG_AGENT_FWD) != 0;
	cctx->term = buffer_get_string(&m, &len);
	escape_char = buffer_get_int(&m);
a325 1
	cmd = buffer_get_string(&m, &len);
a327 13

	env_len = buffer_get_int(&m);
	env_len = MIN(env_len, 4096);
	debug3("%s: receiving %d env vars", __func__, env_len);
	if (env_len != 0) {
		cctx->env = xcalloc(env_len + 1, sizeof(*cctx->env));
		for (i = 0; i < env_len; i++)
			cctx->env[i] = buffer_get_string(&m, &len);
		cctx->env[i] = NULL;
	}

	debug2("%s: accepted tty %d, subsys %d, cmd %s", __func__,
	    cctx->want_tty, cctx->want_subsys, cmd);
d332 1
a332 1
		if ((new_fd[i] = mm_receive_fd(client_fd)) == -1) {
a342 1
			close(client_fd);
d344 7
a350 1
			return 0;
d354 1
a354 1
	debug2("%s: got fds stdin %d, stdout %d, stderr %d", __func__,
d357 8
a364 9
	/* Try to pick up ttymodes from client before it goes raw */
	if (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)
		error("%s: tcgetattr: %s", __func__, strerror(errno));

	/* This roundtrip is just for synchronisation of ttymodes */
	buffer_clear(&m);
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
a367 1
		buffer_free(&m);
d374 1
d377 16
a392 1
	buffer_free(&m);
a401 2
	set_nonblock(client_fd);

d408 2
a409 2
	
	c = channel_new("session", SSH_CHANNEL_OPENING,
d413 3
a415 1
	c->ctl_fd = client_fd;
d417 1
a417 1
		channel_register_filter(c->self,
d423 12
a434 1
	debug3("%s: channel_new: %d", __func__, c->self);
a435 2
	channel_send_open(c->self);
	channel_register_open_confirm(c->self, mux_session_confirm, cctx);
d439 2
a440 15
/* ** Multiplexing client support */

/* Exit signal handler */
static void
control_client_sighandler(int signo)
{
	muxclient_terminate = signo;
}

/*
 * Relay signal handler - used to pass some signals from mux client to
 * mux master.
 */
static void
control_client_sigrelay(int signo)
d442 1
a442 1
	int save_errno = errno;
d444 4
a447 2
	if (muxserver_pid > 1)
		kill(muxserver_pid, signo);
d449 1
a449 1
	errno = save_errno;
a451 1
/* Check mux client environment variables before passing them to mux master. */
d453 1
a453 1
env_permitted(char *env)
d455 1
a455 2
	int i, ret;
	char name[1024], *cp;
d457 11
a467 5
	if ((cp = strchr(env, '=')) == NULL || cp == env)
		return (0);
	ret = snprintf(name, sizeof(name), "%.*s", (int)(cp - env), env);
	if (ret <= 0 || (size_t)ret >= sizeof(name))
		fatal("env_permitted: name '%.100s...' too long", env);
d469 5
a473 5
	for (i = 0; i < options.num_send_env; i++)
		if (match_pattern(name, options.send_env[i]))
			return (1);

	return (0);
d476 2
a477 3
/* Multiplex client main loop. */
void
muxclient(const char *path)
d479 1
a479 6
	struct sockaddr_un addr;
	int i, r, fd, sock, exitval[2], num_env;
	Buffer m;
	char *term;
	extern char **environ;
	u_int allowed, flags;
d481 20
a500 9
	if (muxclient_command == 0)
		muxclient_command = SSHMUX_COMMAND_OPEN;

	switch (options.control_master) {
	case SSHCTL_MASTER_AUTO:
	case SSHCTL_MASTER_AUTO_ASK:
		debug("auto-mux: Trying existing master");
		/* FALLTHROUGH */
	case SSHCTL_MASTER_NO:
d503 1
a503 1
		return;
d505 2
d508 9
a516 4
	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(path) + 1;
d518 11
a528 3
	if (strlcpy(addr.sun_path, path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");
d530 2
a531 2
	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));
d533 327
a859 4
	if (connect(sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
		if (muxclient_command != SSHMUX_COMMAND_OPEN) {
			fatal("Control socket connect(%.100s): %s", path,
			    strerror(errno));
d861 8
a868 5
		if (errno == ENOENT)
			debug("Control socket \"%.100s\" does not exist", path);
		else {
			error("Control socket connect(%.100s): %s", path,
			    strerror(errno));
d870 51
a920 1
		close(sock);
d922 88
d1011 26
d1038 33
a1070 7
	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
d1072 2
d1075 48
a1122 1
	term = getenv("TERM");
d1124 27
a1150 9
	flags = 0;
	if (tty_flag)
		flags |= SSHMUX_FLAG_TTY;
	if (subsystem_flag)
		flags |= SSHMUX_FLAG_SUBSYS;
	if (options.forward_x11)
		flags |= SSHMUX_FLAG_X11_FWD;
	if (options.forward_agent)
		flags |= SSHMUX_FLAG_AGENT_FWD;
d1152 5
a1156 1
	signal(SIGPIPE, SIG_IGN);
d1159 6
d1166 4
a1169 7
	/* Send our command to server */
	buffer_put_int(&m, muxclient_command);
	buffer_put_int(&m, flags);
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1) {
		error("%s: msg_send", __func__);
 muxerr:
		close(sock);
d1171 20
a1190 7
		if (muxclient_command != SSHMUX_COMMAND_OPEN)
			cleanup_exit(255);
		logit("Falling back to non-multiplexed connection");
		xfree(options.control_path);
		options.control_path = NULL;
		options.control_master = SSHCTL_MASTER_NO;
		return;
d1192 20
d1214 10
a1223 16
	/* Get authorisation status and PID of controlee */
	if (ssh_msg_recv(sock, &m) == -1) {
		error("%s: Did not receive reply from master", __func__);
		goto muxerr;
	}
	if (buffer_get_char(&m) != SSHMUX_VER) {
		error("%s: Master replied with wrong version", __func__);
		goto muxerr;
	}
	if (buffer_get_int_ret(&allowed, &m) != 0) {
		error("%s: bad server reply", __func__);
		goto muxerr;
	}
	if (allowed != 1) {
		error("Connection to master denied");
		goto muxerr;
d1225 29
a1253 1
	muxserver_pid = buffer_get_int(&m);
d1257 6
a1262 33
	switch (muxclient_command) {
	case SSHMUX_COMMAND_ALIVE_CHECK:
		fprintf(stderr, "Master running (pid=%d)\r\n",
		    muxserver_pid);
		exit(0);
	case SSHMUX_COMMAND_TERMINATE:
		fprintf(stderr, "Exit request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_OPEN:
		buffer_put_cstring(&m, term ? term : "");
		if (options.escape_char == SSH_ESCAPECHAR_NONE)
			buffer_put_int(&m, 0xffffffff);
		else
			buffer_put_int(&m, options.escape_char);
		buffer_append(&command, "\0", 1);
		buffer_put_cstring(&m, buffer_ptr(&command));

		if (options.num_send_env == 0 || environ == NULL) {
			buffer_put_int(&m, 0);
		} else {
			/* Pass environment */
			num_env = 0;
			for (i = 0; environ[i] != NULL; i++) {
				if (env_permitted(environ[i]))
					num_env++; /* Count */
			}
			buffer_put_int(&m, num_env);
		for (i = 0; environ[i] != NULL && num_env >= 0; i++) {
				if (env_permitted(environ[i])) {
					num_env--;
					buffer_put_cstring(&m, environ[i]);
				}
			}
d1264 64
d1329 10
d1340 47
a1386 1
		fatal("unrecognised muxclient_command %d", muxclient_command);
d1389 9
a1397 3
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1) {
		error("%s: msg_send", __func__);
		goto muxerr;
d1400 22
a1421 5
	if (mm_send_fd(sock, STDIN_FILENO) == -1 ||
	    mm_send_fd(sock, STDOUT_FILENO) == -1 ||
	    mm_send_fd(sock, STDERR_FILENO) == -1) {
		error("%s: send fds failed", __func__);
		goto muxerr;
d1424 10
a1433 4
	/*
	 * Mux errors are non-recoverable from this point as the master
	 * has ownership of the session now.
	 */
d1435 1
a1435 1
	/* Wait for reply, so master has a chance to gather ttymodes */
d1437 33
a1469 5
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != SSHMUX_VER)
		fatal("%s: wrong version", __func__);
	buffer_free(&m);
d1481 4
a1484 4
	 * Before it does, it is expected to write this process' exit
	 * value (one int). This process must read the value and wait for
	 * the closure of the client_fd; if this one closes early, the 
	 * multiplex master will terminate early too (possibly losing data).
d1486 3
a1488 5
	exitval[0] = 0;
	for (i = 0; !muxclient_terminate && i < (int)sizeof(exitval);) {
		r = read(sock, (char *)exitval + i, sizeof(exitval) - i);
		if (r == 0) {
			debug2("Received EOF from master");
d1490 4
d1495 8
a1502 6
		if (r == -1) {
			if (errno == EINTR)
				continue;
			fatal("%s: read %s", __func__, strerror(errno));
		}
		i += r;
d1505 1
a1505 1
	close(sock);
d1507 1
a1507 3
	if (i > (int)sizeof(int))
		fatal("%s: master returned too much data (%d > %lu)",
		    __func__, i, (u_long)sizeof(int));
d1510 2
a1511 2
		exitval[0] = 255;
	} else if (i < (int)sizeof(int)) {
d1513 1
a1513 1
		exitval[0] = 255;
d1515 1
a1515 1
		debug2("Received exit status from master %d", exitval[0]);
d1520 187
a1706 1
	exit(exitval[0]);
@


1.8
log
@subsystem_flag is defined in ssh.c so it's extern; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.7 2008/06/13 17:21:20 dtucker Exp $ */
d74 1
d675 1
a675 1
		enter_raw_mode();
d700 1
a700 1
	leave_raw_mode();
@


1.7
log
@Friendlier error messages for mux fallback.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.6 2008/06/13 00:47:53 dtucker Exp $ */
d77 1
a77 1
int subsystem_flag;
@


1.6
log
@upcast size_t to u_long to match format arg; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.5 2008/06/13 00:16:49 djm Exp $ */
d585 1
a585 1
		error("%s: msg_recv", __func__);
d589 1
a589 1
		error("%s: wrong version", __func__);
@


1.5
log
@fall back to creating a new TCP connection on most multiplexing errors
(socket connect fail, invalid version, refused permittion, corrupted
messages, etc.); bz #1329 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.4 2008/06/12 15:19:17 djm Exp $ */
d702 1
a702 1
		    __func__, i, sizeof(int));
@


1.4
log
@The multiplexing escape char handler commit last night introduced a
small memory leak per session; plug it.
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.3 2008/06/12 05:32:30 djm Exp $ */
d135 10
a144 4
		if (errno == EINVAL || errno == EADDRINUSE)
			fatal("ControlSocket %s already exists",
			    options.control_path);
		else
d497 1
a497 1
	u_int  flags;
d568 13
a580 2
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
		fatal("%s: msg_send", __func__);
d584 16
a599 6
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != SSHMUX_VER)
		fatal("%s: wrong version", __func__);
	if (buffer_get_int(&m) != 1)
		fatal("Connection to master denied");
d643 4
a646 2
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
		fatal("%s: msg_send", __func__);
d650 9
a658 2
	    mm_send_fd(sock, STDERR_FILENO) == -1)
		fatal("%s: send fds failed", __func__);
@


1.3
log
@some more TODO for me
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.2 2008/06/12 03:40:52 djm Exp $ */
d427 1
@


1.2
log
@Enable ~ escapes for multiplex slave sessions; give each channel
its own escape state and hook the escape filters up to muxed
channels. bz #1331

Mux slaves do not currently support the ~^Z and ~& escapes.

NB. this change cranks the mux protocol version, so a new ssh
mux client will not be able to connect to a running old ssh
mux master.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: mux.c,v 1.1 2008/05/09 14:18:44 djm Exp $ */
d31 4
a34 1
 *   6. Support ~^Z in mux slaves.
@


1.1
log
@tidy up session multiplexing code, moving it into its own file and
making the function names more consistent - making ssh.c and
clientloop.c a fair bit more readable.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d20 14
d77 12
d148 1
a148 1
client_extra_session2_setup(int id, void *arg)
d207 1
a207 1
	u_int i, j, len, env_len, mux_command, flags;
d334 1
a419 1
	/* XXX */
d421 5
d430 1
a430 2
	channel_register_open_confirm(c->self,
	    client_extra_session2_setup, cctx);
d582 25
a606 1
		/* continue below */
d609 1
a609 24
		fatal("silly muxclient_command %d", muxclient_command);
	}

	/* SSHMUX_COMMAND_OPEN */
	buffer_put_cstring(&m, term ? term : "");
	buffer_append(&command, "\0", 1);
	buffer_put_cstring(&m, buffer_ptr(&command));

	if (options.num_send_env == 0 || environ == NULL) {
		buffer_put_int(&m, 0);
	} else {
		/* Pass environment */
		num_env = 0;
		for (i = 0; environ[i] != NULL; i++)
			if (env_permitted(environ[i]))
				num_env++; /* Count */

		buffer_put_int(&m, num_env);

		for (i = 0; environ[i] != NULL && num_env >= 0; i++)
			if (env_permitted(environ[i])) {
				num_env--;
				buffer_put_cstring(&m, environ[i]);
			}
@

