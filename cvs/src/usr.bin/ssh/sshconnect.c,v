head	1.273;
access;
symbols
	OPENBSD_6_1:1.273.0.4
	OPENBSD_6_1_BASE:1.273
	OPENBSD_6_0:1.271.0.6
	OPENBSD_6_0_BASE:1.271
	OPENBSD_5_9:1.271.0.2
	OPENBSD_5_9_BASE:1.271
	OPENBSD_5_8:1.262.0.2
	OPENBSD_5_8_BASE:1.262
	OPENBSD_5_7:1.259.0.2
	OPENBSD_5_7_BASE:1.259
	OPENBSD_5_6:1.251.0.4
	OPENBSD_5_6_BASE:1.251
	OPENBSD_5_5:1.246.0.4
	OPENBSD_5_5_BASE:1.246
	OPENBSD_5_4:1.238.0.2
	OPENBSD_5_4_BASE:1.238
	OPENBSD_5_3:1.237.0.2
	OPENBSD_5_3_BASE:1.237
	OPENBSD_5_2:1.234.0.6
	OPENBSD_5_2_BASE:1.234
	OPENBSD_5_1_BASE:1.234
	OPENBSD_5_1:1.234.0.4
	OPENBSD_5_0:1.234.0.2
	OPENBSD_5_0_BASE:1.234
	OPENBSD_4_9:1.232.0.2
	OPENBSD_4_9_BASE:1.232
	OPENBSD_4_8:1.224.0.2
	OPENBSD_4_8_BASE:1.224
	OPENBSD_4_7:1.220.0.2
	OPENBSD_4_7_BASE:1.220
	OPENBSD_4_6:1.214.0.4
	OPENBSD_4_6_BASE:1.214
	OPENBSD_4_5:1.212.0.2
	OPENBSD_4_5_BASE:1.212
	OPENBSD_4_4:1.211.0.2
	OPENBSD_4_4_BASE:1.211
	OPENBSD_4_3:1.203.0.2
	OPENBSD_4_3_BASE:1.203
	OPENBSD_4_2:1.200.0.4
	OPENBSD_4_2_BASE:1.200
	OPENBSD_4_1:1.200.0.2
	OPENBSD_4_1_BASE:1.200
	OPENBSD_4_0:1.199.0.4
	OPENBSD_4_0_BASE:1.199
	OPENBSD_3_9:1.176.0.2
	OPENBSD_3_9_BASE:1.176
	OPENBSD_3_8:1.168.0.2
	OPENBSD_3_8_BASE:1.168
	OPENBSD_3_7:1.162.0.2
	OPENBSD_3_7_BASE:1.162
	OPENBSD_3_6:1.158.0.2
	OPENBSD_3_6_BASE:1.158
	OPENBSD_3_5:1.156.0.2
	OPENBSD_3_5_BASE:1.156
	OPENBSD_3_4:1.147.0.2
	OPENBSD_3_4_BASE:1.147
	OPENBSD_3_3:1.137.0.2
	OPENBSD_3_3_BASE:1.137
	OPENBSD_3_2:1.135.0.2
	OPENBSD_3_2_BASE:1.135
	OPENBSD_3_1:1.119.0.2
	OPENBSD_3_1_BASE:1.119
	OPENBSD_3_0:1.115.0.2
	OPENBSD_3_0_BASE:1.115
	OPENBSD_2_9_BASE:1.104
	OPENBSD_2_9:1.104.0.2
	OPENBSD_2_8:1.79.0.2
	OPENBSD_2_8_BASE:1.79
	OPENBSD_2_7:1.72.0.2
	OPENBSD_2_7_BASE:1.72
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22;
locks; strict;
comment	@ * @;


1.273
date	2017.03.10.03.22.40;	author dtucker;	state Exp;
branches;
next	1.272;
commitid	S043b3aTRR4XGbtX;

1.272
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.271;
commitid	ZllbGwdb0fOmLhjK;

1.271
date	2016.01.14.22.56.56;	author markus;	state Exp;
branches;
next	1.270;
commitid	wjm52VmSUdBkFKQk;

1.270
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.269;
commitid	W9ye0gltieEl87AJ;

1.269
date	2015.11.20.01.45.29;	author djm;	state Exp;
branches;
next	1.268;
commitid	WTUXWpCaUzMxDkxA;

1.268
date	2015.11.19.08.23.27;	author djm;	state Exp;
branches;
next	1.267;
commitid	vjLZDEV1SOcsI3XO;

1.267
date	2015.11.19.01.09.38;	author djm;	state Exp;
branches;
next	1.266;
commitid	Ppne2VWEYN6wiIMH;

1.266
date	2015.11.15.22.26.49;	author jcs;	state Exp;
branches;
next	1.265;
commitid	mjNGB5AAtJeHDag2;

1.265
date	2015.09.04.04.55.24;	author djm;	state Exp;
branches;
next	1.264;
commitid	K31jzorUeSiysQU5;

1.264
date	2015.09.04.03.57.38;	author djm;	state Exp;
branches;
next	1.263;
commitid	3AJ1L9XIBgMKvyZu;

1.263
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.262;
commitid	0Dp7Dy9FuNZesYo2;

1.262
date	2015.05.28.05.41.29;	author dtucker;	state Exp;
branches;
next	1.261;
commitid	BVGu4ZWxTe12chWp;

1.261
date	2015.04.14.04.17.03;	author dtucker;	state Exp;
branches;
next	1.260;
commitid	IWxTFn4JvUCQhP2B;

1.260
date	2015.03.24.01.11.12;	author djm;	state Exp;
branches;
next	1.259;
commitid	WcYFRCZUbqJDQ1vL;

1.259
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.258;
commitid	P7KG9D8zB61mMUPV;

1.258
date	2015.01.26.06.10.03;	author djm;	state Exp;
branches;
next	1.257;
commitid	F603CYAZ9E536XCr;

1.257
date	2015.01.26.03.04.46;	author djm;	state Exp;
branches;
next	1.256;
commitid	Xp9DfQmHQHbZ815k;

1.256
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.255;
commitid	cBx23BaCk6gYBpRj;

1.255
date	2015.01.19.20.20.20;	author markus;	state Exp;
branches;
next	1.254;
commitid	LpkFFtLiqWKzX2Ia;

1.254
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.253;
commitid	EbtriidyZdsmXksl;

1.253
date	2014.12.11.08.20.09;	author djm;	state Exp;
branches;
next	1.252;
commitid	UtK7Mx4xawqsfx0b;

1.252
date	2014.12.04.02.24.32;	author djm;	state Exp;
branches;
next	1.251;
commitid	0YGyOuIh3H3xTolw;

1.251
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.250;
commitid	z7plx8Gkj6l2sxem;

1.250
date	2014.07.03.22.23.46;	author djm;	state Exp;
branches;
next	1.249;
commitid	Ma1796XTdoLkQaup;

1.249
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.248;
commitid	1h9UxAQmwdaqUzyX;

1.248
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.247;

1.247
date	2014.04.01.03.34.10;	author djm;	state Exp;
branches;
next	1.246;

1.246
date	2014.02.06.22.21.01;	author djm;	state Exp;
branches;
next	1.245;

1.245
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.244;

1.244
date	2014.01.09.23.26.48;	author djm;	state Exp;
branches;
next	1.243;

1.243
date	2013.12.30.23.52.27;	author djm;	state Exp;
branches;
next	1.242;

1.242
date	2013.12.29.05.57.02;	author djm;	state Exp;
branches;
next	1.241;

1.241
date	2013.10.16.02.31.46;	author djm;	state Exp;
branches;
next	1.240;

1.240
date	2013.09.19.01.26.29;	author djm;	state Exp;
branches;
next	1.239;

1.239
date	2013.08.20.00.11.38;	author djm;	state Exp;
branches;
next	1.238;

1.238
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.237;

1.237
date	2013.02.22.19.13.56;	author markus;	state Exp;
branches;
next	1.236;

1.236
date	2012.09.14.16.51.34;	author markus;	state Exp;
branches;
next	1.235;

1.235
date	2012.08.17.01.30.00;	author djm;	state Exp;
branches;
next	1.234;

1.234
date	2011.05.24.07.15.47;	author djm;	state Exp;
branches;
next	1.233;

1.233
date	2011.05.23.03.52.55;	author djm;	state Exp;
branches;
next	1.232;

1.232
date	2011.01.16.11.50.36;	author djm;	state Exp;
branches;
next	1.231;

1.231
date	2011.01.06.23.01.35;	author djm;	state Exp;
branches;
next	1.230;

1.230
date	2010.12.14.11.59.06;	author markus;	state Exp;
branches;
next	1.229;

1.229
date	2010.11.29.23.45.51;	author djm;	state Exp;
branches;
next	1.228;

1.228
date	2010.10.06.21.10.21;	author djm;	state Exp;
branches;
next	1.227;

1.227
date	2010.10.06.06.39.28;	author djm;	state Exp;
branches;
next	1.226;

1.226
date	2010.10.05.05.13.18;	author djm;	state Exp;
branches;
next	1.225;

1.225
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.224;

1.224
date	2010.04.16.21.14.27;	author djm;	state Exp;
branches;
next	1.223;

1.223
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.222;

1.222
date	2010.04.14.22.27.42;	author djm;	state Exp;
branches;
next	1.221;

1.221
date	2010.04.10.00.04.30;	author djm;	state Exp;
branches;
next	1.220;

1.220
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.219;

1.219
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.218;

1.218
date	2010.01.13.00.19.04;	author dtucker;	state Exp;
branches;
next	1.217;

1.217
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.216;

1.216
date	2009.11.10.04.30.45;	author dtucker;	state Exp;
branches;
next	1.215;

1.215
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.214;

1.214
date	2009.05.28.16.50.16;	author andreas;	state Exp;
branches;
next	1.213;

1.213
date	2009.05.27.06.38.16;	author andreas;	state Exp;
branches;
next	1.212;

1.212
date	2008.10.14.18.11.33;	author stevesk;	state Exp;
branches;
next	1.211;

1.211
date	2008.07.01.07.24.22;	author dtucker;	state Exp;
branches;
next	1.210;

1.210
date	2008.07.01.07.20.52;	author dtucker;	state Exp;
branches;
next	1.209;

1.209
date	2008.06.26.11.46.31;	author grunk;	state Exp;
branches;
next	1.208;

1.208
date	2008.06.12.23.24.58;	author ian;	state Exp;
branches;
next	1.207;

1.207
date	2008.06.12.20.38.28;	author dtucker;	state Exp;
branches;
next	1.206;

1.206
date	2008.06.12.00.13.55;	author grunk;	state Exp;
branches;
next	1.205;

1.205
date	2008.06.12.00.03.49;	author dtucker;	state Exp;
branches;
next	1.204;

1.204
date	2008.06.11.21.01.35;	author grunk;	state Exp;
branches;
next	1.203;

1.203
date	2007.12.27.14.22.08;	author dtucker;	state Exp;
branches;
next	1.202;

1.202
date	2007.09.04.11.15.55;	author djm;	state Exp;
branches;
next	1.201;

1.201
date	2007.08.23.03.23.26;	author djm;	state Exp;
branches;
next	1.200;

1.200
date	2006.10.10.10.12.45;	author markus;	state Exp;
branches;
next	1.199;

1.199
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.199.4.1;
next	1.198;

1.198
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.197;

1.197
date	2006.08.01.11.34.36;	author dtucker;	state Exp;
branches;
next	1.196;

1.196
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.195;

1.195
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.194;

1.194
date	2006.07.24.13.58.22;	author stevesk;	state Exp;
branches;
next	1.193;

1.193
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.192;

1.192
date	2006.07.17.01.31.10;	author stevesk;	state Exp;
branches;
next	1.191;

1.191
date	2006.07.12.22.28.52;	author stevesk;	state Exp;
branches;
next	1.190;

1.190
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.189;

1.189
date	2006.07.10.12.46.51;	author dtucker;	state Exp;
branches;
next	1.188;

1.188
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.187;

1.187
date	2006.07.05.02.42.09;	author stevesk;	state Exp;
branches;
next	1.186;

1.186
date	2006.07.03.08.54.20;	author stevesk;	state Exp;
branches;
next	1.185;

1.185
date	2006.06.14.10.50.42;	author djm;	state Exp;
branches;
next	1.184;

1.184
date	2006.06.08.14.45.49;	author markus;	state Exp;
branches;
next	1.183;

1.183
date	2006.06.06.10.20.20;	author markus;	state Exp;
branches;
next	1.182;

1.182
date	2006.05.17.12.43.34;	author markus;	state Exp;
branches;
next	1.181;

1.181
date	2006.04.20.09.47.59;	author markus;	state Exp;
branches;
next	1.180;

1.180
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.179;

1.179
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.178;

1.178
date	2006.03.20.18.42.27;	author deraadt;	state Exp;
branches;
next	1.177;

1.177
date	2006.03.19.18.51.19;	author deraadt;	state Exp;
branches;
next	1.176;

1.176
date	2006.02.22.00.04.45;	author stevesk;	state Exp;
branches
	1.176.2.1;
next	1.175;

1.175
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches;
next	1.174;

1.174
date	2006.02.10.01.44.27;	author stevesk;	state Exp;
branches;
next	1.173;

1.173
date	2006.02.08.14.16.59;	author stevesk;	state Exp;
branches;
next	1.172;

1.172
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.171;

1.171
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.170;

1.170
date	2005.10.30.08.52.18;	author djm;	state Exp;
branches;
next	1.169;

1.169
date	2005.10.15.15.28.12;	author stevesk;	state Exp;
branches;
next	1.168;

1.168
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches
	1.168.2.1;
next	1.167;

1.167
date	2005.07.16.01.35.24;	author djm;	state Exp;
branches;
next	1.166;

1.166
date	2005.06.17.22.53.47;	author djm;	state Exp;
branches;
next	1.165;

1.165
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches;
next	1.164;

1.164
date	2005.06.06.11.20.36;	author djm;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.24.17.32.44;	author avsm;	state Exp;
branches;
next	1.162;

1.162
date	2005.03.10.22.01.06;	author deraadt;	state Exp;
branches
	1.162.2.1;
next	1.161;

1.161
date	2005.03.02.01.00.06;	author djm;	state Exp;
branches;
next	1.160;

1.160
date	2005.03.01.10.40.27;	author djm;	state Exp;
branches;
next	1.159;

1.159
date	2005.01.05.08.51.32;	author markus;	state Exp;
branches;
next	1.158;

1.158
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches
	1.158.2.1;
next	1.157;

1.157
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches;
next	1.156;

1.156
date	2004.01.25.03.49.09;	author djm;	state Exp;
branches
	1.156.2.1;
next	1.155;

1.155
date	2003.12.09.21.53.37;	author markus;	state Exp;
branches;
next	1.154;

1.154
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.153;

1.153
date	2003.11.12.16.39.58;	author jakob;	state Exp;
branches;
next	1.152;

1.152
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches;
next	1.151;

1.151
date	2003.11.03.09.37.32;	author jakob;	state Exp;
branches;
next	1.150;

1.150
date	2003.11.03.09.09.41;	author jakob;	state Exp;
branches;
next	1.149;

1.149
date	2003.10.14.19.42.10;	author jakob;	state Exp;
branches;
next	1.148;

1.148
date	2003.09.18.07.52.54;	author markus;	state Exp;
branches;
next	1.147;

1.147
date	2003.06.29.12.44.38;	author markus;	state Exp;
branches
	1.147.2.1;
next	1.146;

1.146
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2003.06.11.10.16.16;	author jakob;	state Exp;
branches;
next	1.144;

1.144
date	2003.06.04.08.25.18;	author djm;	state Exp;
branches;
next	1.143;

1.143
date	2003.05.26.12.54.40;	author djm;	state Exp;
branches;
next	1.142;

1.142
date	2003.05.23.08.29.30;	author djm;	state Exp;
branches;
next	1.141;

1.141
date	2003.05.15.14.55.25;	author djm;	state Exp;
branches;
next	1.140;

1.140
date	2003.05.14.18.16.21;	author jakob;	state Exp;
branches;
next	1.139;

1.139
date	2003.04.14.14.17.50;	author markus;	state Exp;
branches;
next	1.138;

1.138
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.137;

1.137
date	2002.11.21.23.03.51;	author deraadt;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2002.11.21.22.45.31;	author markus;	state Exp;
branches;
next	1.135;

1.135
date	2002.09.19.01.58.18;	author djm;	state Exp;
branches
	1.135.2.1;
next	1.134;

1.134
date	2002.09.13.19.23.09;	author stevesk;	state Exp;
branches;
next	1.133;

1.133
date	2002.07.29.18.57.30;	author markus;	state Exp;
branches;
next	1.132;

1.132
date	2002.07.24.16.11.18;	author markus;	state Exp;
branches;
next	1.131;

1.131
date	2002.07.12.13.29.09;	author itojun;	state Exp;
branches;
next	1.130;

1.130
date	2002.07.10.10.28.15;	author itojun;	state Exp;
branches;
next	1.129;

1.129
date	2002.07.09.12.04.02;	author itojun;	state Exp;
branches;
next	1.128;

1.128
date	2002.07.09.11.56.50;	author itojun;	state Exp;
branches;
next	1.127;

1.127
date	2002.06.27.08.49.44;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2002.06.23.03.30.17;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2002.06.11.04.14.26;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2002.06.09.22.17.21;	author itojun;	state Exp;
branches;
next	1.122;

1.122
date	2002.06.09.04.33.27;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2002.06.08.21.15.27;	author itojun;	state Exp;
branches;
next	1.120;

1.120
date	2002.05.23.19.24.30;	author markus;	state Exp;
branches;
next	1.119;

1.119
date	2002.01.21.15.13.51;	author markus;	state Exp;
branches
	1.119.2.1;
next	1.118;

1.118
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2001.12.06.18.02.32;	author stevesk;	state Exp;
branches;
next	1.116;

1.116
date	2001.12.05.10.06.13;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2001.10.08.19.05.05;	author markus;	state Exp;
branches
	1.115.2.1;
next	1.114;

1.114
date	2001.10.08.16.15.47;	author markus;	state Exp;
branches;
next	1.113;

1.113
date	2001.10.06.11.18.19;	author markus;	state Exp;
branches;
next	1.112;

1.112
date	2001.10.06.00.14.50;	author markus;	state Exp;
branches;
next	1.111;

1.111
date	2001.10.01.21.51.16;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2001.07.25.14.35.18;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2001.06.23.15.12.21;	author itojun;	state Exp;
branches;
next	1.108;

1.108
date	2001.06.23.02.34.31;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2001.06.07.20.23.05;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2001.05.28.23.58.35;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2001.04.30.11.18.52;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2001.04.12.19.15.25;	author markus;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2001.04.06.21.00.14;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2001.04.05.10.42.55;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2001.03.26.08.07.09;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2001.03.12.22.02.02;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2001.03.10.15.31.00;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches;
next	1.97;

1.97
date	2001.02.15.23.19.59;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2001.02.08.22.35.30;	author markus;	state Exp;
branches;
next	1.95;

1.95
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.94;

1.94
date	2001.02.08.10.47.04;	author itojun;	state Exp;
branches;
next	1.93;

1.93
date	2001.02.04.15.32.26;	author stevesk;	state Exp;
branches;
next	1.92;

1.92
date	2001.01.30.22.48.52;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2001.01.21.19.05.59;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2001.01.13.18.32.50;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2001.01.04.22.41.03;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2001.01.02.20.50.56;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2000.12.28.14.25.03;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2000.12.27.12.30.20;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2000.12.21.15.10.17;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2000.12.20.19.27.55;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2000.11.30.22.53.35;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2000.11.29.13.51.27;	author provos;	state Exp;
branches;
next	1.81;

1.81
date	2000.11.06.23.16.35;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2000.11.06.23.13.26;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2000.09.17.15.52.51;	author markus;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2000.09.07.20.27.54;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2000.08.28.03.50.54;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2000.06.17.20.30.10;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2000.06.17.19.24.34;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2000.05.17.16.57.02;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2000.05.17.08.20.15;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2000.05.04.09.50.22;	author markus;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2000.04.26.21.28.33;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2000.04.26.20.56.30;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2000.04.19.07.05.50;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2000.04.14.10.09.16;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2000.04.12.07.56.16;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2000.04.12.07.45.44;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2000.04.12.07.03.06;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2000.04.12.06.36.48;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2000.04.04.21.37.27;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2000.04.04.15.30.51;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2000.04.04.15.19.43;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2000.03.23.22.15.33;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2000.02.18.08.50.33;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2000.02.15.13.08.01;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2000.02.05.10.13.11;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2000.01.18.09.42.17;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2000.01.16.23.53.02;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2000.01.16.23.03.10;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2000.01.05.08.32.42;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2000.01.04.00.08.00;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2000.01.02.14.25.51;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	99.12.20.08.35.36;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	99.12.08.22.39.21;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	99.12.06.20.15.30;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	99.12.01.16.51.19;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	99.12.01.14.24.38;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	99.12.01.14.07.22;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	99.12.01.13.59.15;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	99.11.24.19.53.53;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	99.11.23.22.25.55;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	99.11.22.21.52.42;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	99.11.19.19.58.18;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	99.11.18.14.00.49;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	99.11.17.09.51.57;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	99.11.16.22.49.28;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	99.11.16.20.44.42;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	99.11.15.23.58.54;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	99.11.15.21.38.54;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	99.11.15.20.53.25;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	99.11.15.00.42.01;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	99.11.11.23.36.53;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	99.11.07.22.38.39;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	99.11.02.19.42.36;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	99.10.27.16.37.46;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.10.25.20.34.30;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	99.10.16.23.11.29;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	99.10.16.20.47.14;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	99.10.16.19.23.35;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	99.10.15.20.51.01;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	99.10.14.20.03.44;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	99.10.14.18.17.42;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	99.10.06.20.07.42;	author dugsong;	state Exp;
branches;
next	1.15;

1.15
date	99.10.06.04.22.20;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	99.10.04.19.46.30;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	99.10.03.22.01.39;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	99.10.03.21.50.04;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	99.10.03.19.22.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.09.30.17.08.52;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.09.30.06.06.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.09.30.05.53.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.09.30.04.30.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.09.29.21.14.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.18.16.21;	author dugsong;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.15.52.55;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	99.09.28.04.45.37;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	99.09.26.22.01.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.38;	author deraadt;	state Exp;
branches;
next	;

1.72.2.1
date	2000.06.12.02.37.37;	author jason;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2000.09.01.18.23.24;	author jason;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2000.11.08.21.31.27;	author jason;	state Exp;
branches;
next	1.72.2.4;

1.72.2.4
date	2001.03.12.15.44.17;	author jason;	state Exp;
branches;
next	1.72.2.5;

1.72.2.5
date	2001.03.21.18.53.14;	author jason;	state Exp;
branches;
next	;

1.79.2.1
date	2001.02.16.20.13.21;	author jason;	state Exp;
branches;
next	1.79.2.2;

1.79.2.2
date	2001.02.19.17.19.35;	author jason;	state Exp;
branches;
next	1.79.2.3;

1.79.2.3
date	2001.03.21.19.46.30;	author jason;	state Exp;
branches;
next	1.79.2.4;

1.79.2.4
date	2001.05.07.21.09.37;	author jason;	state Exp;
branches;
next	1.79.2.5;

1.79.2.5
date	2001.09.27.00.15.43;	author miod;	state Exp;
branches;
next	1.79.2.6;

1.79.2.6
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.79.2.7;

1.79.2.7
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.104.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.104.2.2;

1.104.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.104.2.3;

1.104.2.3
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	;

1.115.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.115.2.2;

1.115.2.2
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.115.2.3;

1.115.2.3
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.115.2.4;

1.115.2.4
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.119.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.119.2.2;

1.119.2.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.119.2.3;

1.119.2.3
date	2003.04.03.22.35.18;	author miod;	state Exp;
branches;
next	;

1.135.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.135.2.2;

1.135.2.2
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.137.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	2004.03.04.18.18.17;	author brad;	state Exp;
branches;
next	;

1.147.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.147.2.2;

1.147.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.156.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.156.2.2;

1.156.2.2
date	2005.03.10.17.15.05;	author brad;	state Exp;
branches;
next	;

1.158.2.1
date	2005.03.10.16.28.28;	author brad;	state Exp;
branches;
next	1.158.2.2;

1.158.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.158.2.3;

1.158.2.3
date	2005.09.02.03.45.01;	author brad;	state Exp;
branches;
next	;

1.162.2.1
date	2005.09.04.18.40.10;	author brad;	state Exp;
branches;
next	1.162.2.2;

1.162.2.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.168.2.1
date	2006.02.03.03.01.58;	author brad;	state Exp;
branches;
next	1.168.2.2;

1.168.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.168.2.3;

1.168.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.176.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.176.2.2;

1.176.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.199.4.1
date	2006.11.08.00.42.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.273
log
@Plug descriptor leaks of auth_sock.  From jjelen at redhat.com via
bz#2687, ok djm@@
@
text
@/* $OpenBSD: sshconnect.c,v 1.272 2016/09/12 01:22:38 deraadt Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Code to connect to a remote host, and to perform the client side of the
 * login (authentication) dialog.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <signal.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "rsa.h"
#include "buffer.h"
#include "packet.h"
#include "uidswap.h"
#include "compat.h"
#include "key.h"
#include "sshconnect.h"
#include "hostfile.h"
#include "log.h"
#include "misc.h"
#include "readconf.h"
#include "atomicio.h"
#include "dns.h"
#include "monitor_fdpass.h"
#include "ssh2.h"
#include "version.h"
#include "authfile.h"
#include "ssherr.h"
#include "authfd.h"

char *client_version_string = NULL;
char *server_version_string = NULL;
Key *previous_host_key = NULL;

static int matching_host_key_dns = 0;

static pid_t proxy_command_pid = 0;

/* import */
extern Options options;
extern char *__progname;
extern uid_t original_real_uid;
extern uid_t original_effective_uid;

static int show_other_keys(struct hostkeys *, Key *);
static void warn_changed_key(Key *);

/* Expand a proxy command */
static char *
expand_proxy_command(const char *proxy_command, const char *user,
    const char *host, int port)
{
	char *tmp, *ret, strport[NI_MAXSERV];

	snprintf(strport, sizeof strport, "%d", port);
	xasprintf(&tmp, "exec %s", proxy_command);
	ret = percent_expand(tmp, "h", host, "p", strport,
	    "r", options.user, (char *)NULL);
	free(tmp);
	return ret;
}

/*
 * Connect to the given ssh server using a proxy command that passes a
 * a connected fd back to us.
 */
static int
ssh_proxy_fdpass_connect(const char *host, u_short port,
    const char *proxy_command)
{
	char *command_string;
	int sp[2], sock;
	pid_t pid;
	char *shell;

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) < 0)
		fatal("Could not create socketpair to communicate with "
		    "proxy dialer: %.100s", strerror(errno));

	command_string = expand_proxy_command(proxy_command, options.user,
	    host, port);
	debug("Executing proxy dialer command: %.500s", command_string);

	/* Fork and execute the proxy command. */
	if ((pid = fork()) == 0) {
		char *argv[10];

		/* Child.  Permanently give up superuser privileges. */
		permanently_drop_suid(original_real_uid);

		close(sp[1]);
		/* Redirect stdin and stdout. */
		if (sp[0] != 0) {
			if (dup2(sp[0], 0) < 0)
				perror("dup2 stdin");
		}
		if (sp[0] != 1) {
			if (dup2(sp[0], 1) < 0)
				perror("dup2 stdout");
		}
		if (sp[0] >= 2)
			close(sp[0]);

		/*
		 * Stderr is left as it is so that error messages get
		 * printed on the user's terminal.
		 */
		argv[0] = shell;
		argv[1] = "-c";
		argv[2] = command_string;
		argv[3] = NULL;

		/*
		 * Execute the proxy command.
		 * Note that we gave up any extra privileges above.
		 */
		execv(argv[0], argv);
		perror(argv[0]);
		exit(1);
	}
	/* Parent. */
	if (pid < 0)
		fatal("fork failed: %.100s", strerror(errno));
	close(sp[0]);
	free(command_string);

	if ((sock = mm_receive_fd(sp[1])) == -1)
		fatal("proxy dialer did not pass back a connection");
	close(sp[1]);

	while (waitpid(pid, NULL, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));

	/* Set the connection file descriptors. */
	packet_set_connection(sock, sock);

	return 0;
}

/*
 * Connect to the given ssh server using a proxy command.
 */
static int
ssh_proxy_connect(const char *host, u_short port, const char *proxy_command)
{
	char *command_string;
	int pin[2], pout[2];
	pid_t pid;
	char *shell;

	if ((shell = getenv("SHELL")) == NULL || *shell == '\0')
		shell = _PATH_BSHELL;

	/* Create pipes for communicating with the proxy. */
	if (pipe(pin) < 0 || pipe(pout) < 0)
		fatal("Could not create pipes to communicate with the proxy: %.100s",
		    strerror(errno));

	command_string = expand_proxy_command(proxy_command, options.user,
	    host, port);
	debug("Executing proxy command: %.500s", command_string);

	/* Fork and execute the proxy command. */
	if ((pid = fork()) == 0) {
		char *argv[10];

		/* Child.  Permanently give up superuser privileges. */
		permanently_drop_suid(original_real_uid);

		/* Redirect stdin and stdout. */
		close(pin[1]);
		if (pin[0] != 0) {
			if (dup2(pin[0], 0) < 0)
				perror("dup2 stdin");
			close(pin[0]);
		}
		close(pout[0]);
		if (dup2(pout[1], 1) < 0)
			perror("dup2 stdout");
		/* Cannot be 1 because pin allocated two descriptors. */
		close(pout[1]);

		/* Stderr is left as it is so that error messages get
		   printed on the user's terminal. */
		argv[0] = shell;
		argv[1] = "-c";
		argv[2] = command_string;
		argv[3] = NULL;

		/* Execute the proxy command.  Note that we gave up any
		   extra privileges above. */
		signal(SIGPIPE, SIG_DFL);
		execv(argv[0], argv);
		perror(argv[0]);
		exit(1);
	}
	/* Parent. */
	if (pid < 0)
		fatal("fork failed: %.100s", strerror(errno));
	else
		proxy_command_pid = pid; /* save pid to clean up later */

	/* Close child side of the descriptors. */
	close(pin[0]);
	close(pout[1]);

	/* Free the command name. */
	free(command_string);

	/* Set the connection file descriptors. */
	packet_set_connection(pout[0], pin[1]);

	/* Indicate OK return */
	return 0;
}

void
ssh_kill_proxy_command(void)
{
	/*
	 * Send SIGHUP to proxy command if used. We don't wait() in
	 * case it hangs and instead rely on init to reap the child
	 */
	if (proxy_command_pid > 1)
		kill(proxy_command_pid, SIGHUP);
}

/*
 * Creates a (possibly privileged) socket for use as the ssh connection.
 */
static int
ssh_create_socket(int privileged, struct addrinfo *ai)
{
	int sock, r, gaierr;
	struct addrinfo hints, *res = NULL;

	sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
	if (sock < 0) {
		error("socket: %s", strerror(errno));
		return -1;
	}
	fcntl(sock, F_SETFD, FD_CLOEXEC);

	/* Bind the socket to an alternative local IP address */
	if (options.bind_address == NULL && !privileged)
		return sock;

	if (options.bind_address) {
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = ai->ai_family;
		hints.ai_socktype = ai->ai_socktype;
		hints.ai_protocol = ai->ai_protocol;
		hints.ai_flags = AI_PASSIVE;
		gaierr = getaddrinfo(options.bind_address, NULL, &hints, &res);
		if (gaierr) {
			error("getaddrinfo: %s: %s", options.bind_address,
			    ssh_gai_strerror(gaierr));
			close(sock);
			return -1;
		}
	}
	/*
	 * If we are running as root and want to connect to a privileged
	 * port, bind our own socket to a privileged port.
	 */
	if (privileged) {
		PRIV_START;
		r = bindresvport_sa(sock, res ? res->ai_addr : NULL);
		PRIV_END;
		if (r < 0) {
			error("bindresvport_sa: af=%d %s", ai->ai_family,
			    strerror(errno));
			goto fail;
		}
	} else {
		if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
			error("bind: %s: %s", options.bind_address,
			    strerror(errno));
 fail:
			close(sock);
			freeaddrinfo(res);
			return -1;
		}
	}
	if (res != NULL)
		freeaddrinfo(res);
	return sock;
}

static int
timeout_connect(int sockfd, const struct sockaddr *serv_addr,
    socklen_t addrlen, int *timeoutp)
{
	fd_set *fdset;
	struct timeval tv, t_start;
	socklen_t optlen;
	int optval, rc, result = -1;

	gettimeofday(&t_start, NULL);

	if (*timeoutp <= 0) {
		result = connect(sockfd, serv_addr, addrlen);
		goto done;
	}

	set_nonblock(sockfd);
	rc = connect(sockfd, serv_addr, addrlen);
	if (rc == 0) {
		unset_nonblock(sockfd);
		result = 0;
		goto done;
	}
	if (errno != EINPROGRESS) {
		result = -1;
		goto done;
	}

	fdset = xcalloc(howmany(sockfd + 1, NFDBITS),
	    sizeof(fd_mask));
	FD_SET(sockfd, fdset);
	ms_to_timeval(&tv, *timeoutp);

	for (;;) {
		rc = select(sockfd + 1, NULL, fdset, NULL, &tv);
		if (rc != -1 || errno != EINTR)
			break;
	}

	switch (rc) {
	case 0:
		/* Timed out */
		errno = ETIMEDOUT;
		break;
	case -1:
		/* Select error */
		debug("select: %s", strerror(errno));
		break;
	case 1:
		/* Completed or failed */
		optval = 0;
		optlen = sizeof(optval);
		if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval,
		    &optlen) == -1) {
			debug("getsockopt: %s", strerror(errno));
			break;
		}
		if (optval != 0) {
			errno = optval;
			break;
		}
		result = 0;
		unset_nonblock(sockfd);
		break;
	default:
		/* Should not occur */
		fatal("Bogus return (%d) from select()", rc);
	}

	free(fdset);

 done:
 	if (result == 0 && *timeoutp > 0) {
		ms_subtract_diff(&t_start, timeoutp);
		if (*timeoutp <= 0) {
			errno = ETIMEDOUT;
			result = -1;
		}
	}

	return (result);
}

/*
 * Opens a TCP/IP connection to the remote server on the given host.
 * The address of the remote host will be returned in hostaddr.
 * If port is 0, the default port will be used.  If needpriv is true,
 * a privileged port will be allocated to make the connection.
 * This requires super-user privileges if needpriv is true.
 * Connection_attempts specifies the maximum number of tries (one per
 * second).  If proxy_command is non-NULL, it specifies the command (with %h
 * and %p substituted for host and port, respectively) to use to contact
 * the daemon.
 */
static int
ssh_connect_direct(const char *host, struct addrinfo *aitop,
    struct sockaddr_storage *hostaddr, u_short port, int family,
    int connection_attempts, int *timeout_ms, int want_keepalive, int needpriv)
{
	int on = 1;
	int sock = -1, attempt;
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
	struct addrinfo *ai;

	debug2("%s: needpriv %d", __func__, needpriv);
	memset(ntop, 0, sizeof(ntop));
	memset(strport, 0, sizeof(strport));

	for (attempt = 0; attempt < connection_attempts; attempt++) {
		if (attempt > 0) {
			/* Sleep a moment before retrying. */
			sleep(1);
			debug("Trying again...");
		}
		/*
		 * Loop through addresses for this host, and try each one in
		 * sequence until the connection succeeds.
		 */
		for (ai = aitop; ai; ai = ai->ai_next) {
			if (ai->ai_family != AF_INET &&
			    ai->ai_family != AF_INET6)
				continue;
			if (getnameinfo(ai->ai_addr, ai->ai_addrlen,
			    ntop, sizeof(ntop), strport, sizeof(strport),
			    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
				error("%s: getnameinfo failed", __func__);
				continue;
			}
			debug("Connecting to %.200s [%.100s] port %s.",
				host, ntop, strport);

			/* Create a socket for connecting. */
			sock = ssh_create_socket(needpriv, ai);
			if (sock < 0)
				/* Any error is already output */
				continue;

			if (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,
			    timeout_ms) >= 0) {
				/* Successful connection. */
				memcpy(hostaddr, ai->ai_addr, ai->ai_addrlen);
				break;
			} else {
				debug("connect to address %s port %s: %s",
				    ntop, strport, strerror(errno));
				close(sock);
				sock = -1;
			}
		}
		if (sock != -1)
			break;	/* Successful connection. */
	}

	/* Return failure if we didn't get a successful connection. */
	if (sock == -1) {
		error("ssh: connect to host %s port %s: %s",
		    host, strport, strerror(errno));
		return (-1);
	}

	debug("Connection established.");

	/* Set SO_KEEPALIVE if requested. */
	if (want_keepalive &&
	    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
	    sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));

	/* Set the connection. */
	packet_set_connection(sock, sock);

	return 0;
}

int
ssh_connect(const char *host, struct addrinfo *addrs,
    struct sockaddr_storage *hostaddr, u_short port, int family,
    int connection_attempts, int *timeout_ms, int want_keepalive, int needpriv)
{
	if (options.proxy_command == NULL) {
		return ssh_connect_direct(host, addrs, hostaddr, port, family,
		    connection_attempts, timeout_ms, want_keepalive, needpriv);
	} else if (strcmp(options.proxy_command, "-") == 0) {
		packet_set_connection(STDIN_FILENO, STDOUT_FILENO);
		return 0; /* Always succeeds */
	} else if (options.proxy_use_fdpass) {
		return ssh_proxy_fdpass_connect(host, port,
		    options.proxy_command);
	}
	return ssh_proxy_connect(host, port, options.proxy_command);
}

static void
send_client_banner(int connection_out, int minor1)
{
	/* Send our own protocol version identification. */
	if (compat20) {
		xasprintf(&client_version_string, "SSH-%d.%d-%.100s\r\n",
		    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION);
	} else {
		xasprintf(&client_version_string, "SSH-%d.%d-%.100s\n",
		    PROTOCOL_MAJOR_1, minor1, SSH_VERSION);
	}
	if (atomicio(vwrite, connection_out, client_version_string,
	    strlen(client_version_string)) != strlen(client_version_string))
		fatal("write: %.100s", strerror(errno));
	chop(client_version_string);
	debug("Local version string %.100s", client_version_string);
}

/*
 * Waits for the server identification string, and sends our own
 * identification string.
 */
void
ssh_exchange_identification(int timeout_ms)
{
	char buf[256], remote_version[256];	/* must be same size! */
	int remote_major, remote_minor, mismatch;
	int connection_in = packet_get_connection_in();
	int connection_out = packet_get_connection_out();
	int minor1 = PROTOCOL_MINOR_1, client_banner_sent = 0;
	u_int i, n;
	size_t len;
	int fdsetsz, remaining, rc;
	struct timeval t_start, t_remaining;
	fd_set *fdset;

	fdsetsz = howmany(connection_in + 1, NFDBITS) * sizeof(fd_mask);
	fdset = xcalloc(1, fdsetsz);

	/*
	 * If we are SSH2-only then we can send the banner immediately and
	 * save a round-trip.
	 */
	if (options.protocol == SSH_PROTO_2) {
		enable_compat20();
		send_client_banner(connection_out, 0);
		client_banner_sent = 1;
	}

	/* Read other side's version identification. */
	remaining = timeout_ms;
	for (n = 0;;) {
		for (i = 0; i < sizeof(buf) - 1; i++) {
			if (timeout_ms > 0) {
				gettimeofday(&t_start, NULL);
				ms_to_timeval(&t_remaining, remaining);
				FD_SET(connection_in, fdset);
				rc = select(connection_in + 1, fdset, NULL,
				    fdset, &t_remaining);
				ms_subtract_diff(&t_start, &remaining);
				if (rc == 0 || remaining <= 0)
					fatal("Connection timed out during "
					    "banner exchange");
				if (rc == -1) {
					if (errno == EINTR)
						continue;
					fatal("ssh_exchange_identification: "
					    "select: %s", strerror(errno));
				}
			}

			len = atomicio(read, connection_in, &buf[i], 1);

			if (len != 1 && errno == EPIPE)
				fatal("ssh_exchange_identification: "
				    "Connection closed by remote host");
			else if (len != 1)
				fatal("ssh_exchange_identification: "
				    "read: %.100s", strerror(errno));
			if (buf[i] == '\r') {
				buf[i] = '\n';
				buf[i + 1] = 0;
				continue;		/**XXX wait for \n */
			}
			if (buf[i] == '\n') {
				buf[i + 1] = 0;
				break;
			}
			if (++n > 65536)
				fatal("ssh_exchange_identification: "
				    "No banner received");
		}
		buf[sizeof(buf) - 1] = 0;
		if (strncmp(buf, "SSH-", 4) == 0)
			break;
		debug("ssh_exchange_identification: %s", buf);
	}
	server_version_string = xstrdup(buf);
	free(fdset);

	/*
	 * Check that the versions match.  In future this might accept
	 * several versions and set appropriate flags to handle them.
	 */
	if (sscanf(server_version_string, "SSH-%d.%d-%[^\n]\n",
	    &remote_major, &remote_minor, remote_version) != 3)
		fatal("Bad remote protocol version identification: '%.100s'", buf);
	debug("Remote protocol version %d.%d, remote software version %.100s",
	    remote_major, remote_minor, remote_version);

	active_state->compat = compat_datafellows(remote_version);
	mismatch = 0;

	switch (remote_major) {
	case 1:
		if (remote_minor == 99 &&
		    (options.protocol & SSH_PROTO_2) &&
		    !(options.protocol & SSH_PROTO_1_PREFERRED)) {
			enable_compat20();
			break;
		}
		if (!(options.protocol & SSH_PROTO_1)) {
			mismatch = 1;
			break;
		}
		if (remote_minor < 3) {
			fatal("Remote machine has too old SSH software version.");
		} else if (remote_minor == 3 || remote_minor == 4) {
			/* We speak 1.3, too. */
			enable_compat13();
			minor1 = 3;
			if (options.forward_agent) {
				logit("Agent forwarding disabled for protocol 1.3");
				options.forward_agent = 0;
			}
		}
		break;
	case 2:
		if (options.protocol & SSH_PROTO_2) {
			enable_compat20();
			break;
		}
		/* FALLTHROUGH */
	default:
		mismatch = 1;
		break;
	}
	if (mismatch)
		fatal("Protocol major versions differ: %d vs. %d",
		    (options.protocol & SSH_PROTO_2) ? PROTOCOL_MAJOR_2 : PROTOCOL_MAJOR_1,
		    remote_major);
	if ((datafellows & SSH_BUG_DERIVEKEY) != 0)
		fatal("Server version \"%.100s\" uses unsafe key agreement; "
		    "refusing connection", remote_version);
	if ((datafellows & SSH_BUG_RSASIGMD5) != 0)
		logit("Server version \"%.100s\" uses unsafe RSA signature "
		    "scheme; disabling use of RSA keys", remote_version);
	if (!client_banner_sent)
		send_client_banner(connection_out, minor1);
	chop(server_version_string);
}

/* defaults to 'no' */
static int
confirm(const char *prompt)
{
	const char *msg, *again = "Please type 'yes' or 'no': ";
	char *p;
	int ret = -1;

	if (options.batch_mode)
		return 0;
	for (msg = prompt;;msg = again) {
		p = read_passphrase(msg, RP_ECHO);
		if (p == NULL ||
		    (p[0] == '\0') || (p[0] == '\n') ||
		    strncasecmp(p, "no", 2) == 0)
			ret = 0;
		if (p && strncasecmp(p, "yes", 3) == 0)
			ret = 1;
		free(p);
		if (ret != -1)
			return ret;
	}
}

static int
check_host_cert(const char *host, const Key *host_key)
{
	const char *reason;

	if (key_cert_check_authority(host_key, 1, 0, host, &reason) != 0) {
		error("%s", reason);
		return 0;
	}
	if (buffer_len(host_key->cert->critical) != 0) {
		error("Certificate for %s contains unsupported "
		    "critical options(s)", host);
		return 0;
	}
	return 1;
}

static int
sockaddr_is_local(struct sockaddr *hostaddr)
{
	switch (hostaddr->sa_family) {
	case AF_INET:
		return (ntohl(((struct sockaddr_in *)hostaddr)->
		    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
	case AF_INET6:
		return IN6_IS_ADDR_LOOPBACK(
		    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));
	default:
		return 0;
	}
}

/*
 * Prepare the hostname and ip address strings that are used to lookup
 * host keys in known_hosts files. These may have a port number appended.
 */
void
get_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,
    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)
{
	char ntop[NI_MAXHOST];

	/*
	 * We don't have the remote ip-address for connections
	 * using a proxy command
	 */
	if (hostfile_ipaddr != NULL) {
		if (options.proxy_command == NULL) {
			if (getnameinfo(hostaddr, hostaddr->sa_len,
			    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)
			fatal("%s: getnameinfo failed", __func__);
			*hostfile_ipaddr = put_host_port(ntop, port);
		} else {
			*hostfile_ipaddr = xstrdup("<no hostip for proxy "
			    "command>");
		}
	}

	/*
	 * Allow the user to record the key under a different name or
	 * differentiate a non-standard port.  This is useful for ssh
	 * tunneling over forwarded connections or if you run multiple
	 * sshd's on different ports on the same machine.
	 */
	if (hostfile_hostname != NULL) {
		if (options.host_key_alias != NULL) {
			*hostfile_hostname = xstrdup(options.host_key_alias);
			debug("using hostkeyalias: %s", *hostfile_hostname);
		} else {
			*hostfile_hostname = put_host_port(hostname, port);
		}
	}
}

/*
 * check whether the supplied host key is valid, return -1 if the key
 * is not valid. user_hostfile[0] will not be updated if 'readonly' is true.
 */
#define RDRW	0
#define RDONLY	1
#define ROQUIET	2
static int
check_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,
    Key *host_key, int readonly,
    char **user_hostfiles, u_int num_user_hostfiles,
    char **system_hostfiles, u_int num_system_hostfiles)
{
	HostStatus host_status;
	HostStatus ip_status;
	Key *raw_key = NULL;
	char *ip = NULL, *host = NULL;
	char hostline[1000], *hostp, *fp, *ra;
	char msg[1024];
	const char *type;
	const struct hostkey_entry *host_found, *ip_found;
	int len, cancelled_forwarding = 0;
	int local = sockaddr_is_local(hostaddr);
	int r, want_cert = key_is_cert(host_key), host_ip_differ = 0;
	int hostkey_trusted = 0; /* Known or explicitly accepted by user */
	struct hostkeys *host_hostkeys, *ip_hostkeys;
	u_int i;

	/*
	 * Force accepting of the host key for loopback/localhost. The
	 * problem is that if the home directory is NFS-mounted to multiple
	 * machines, localhost will refer to a different machine in each of
	 * them, and the user will get bogus HOST_CHANGED warnings.  This
	 * essentially disables host authentication for localhost; however,
	 * this is probably not a real problem.
	 */
	if (options.no_host_authentication_for_localhost == 1 && local &&
	    options.host_key_alias == NULL) {
		debug("Forcing accepting of host key for "
		    "loopback/localhost.");
		return 0;
	}

	/*
	 * Prepare the hostname and address strings used for hostkey lookup.
	 * In some cases, these will have a port number appended.
	 */
	get_hostfile_hostname_ipaddr(hostname, hostaddr, port, &host, &ip);

	/*
	 * Turn off check_host_ip if the connection is to localhost, via proxy
	 * command or if we don't have a hostname to compare with
	 */
	if (options.check_host_ip && (local ||
	    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))
		options.check_host_ip = 0;

	host_hostkeys = init_hostkeys();
	for (i = 0; i < num_user_hostfiles; i++)
		load_hostkeys(host_hostkeys, host, user_hostfiles[i]);
	for (i = 0; i < num_system_hostfiles; i++)
		load_hostkeys(host_hostkeys, host, system_hostfiles[i]);

	ip_hostkeys = NULL;
	if (!want_cert && options.check_host_ip) {
		ip_hostkeys = init_hostkeys();
		for (i = 0; i < num_user_hostfiles; i++)
			load_hostkeys(ip_hostkeys, ip, user_hostfiles[i]);
		for (i = 0; i < num_system_hostfiles; i++)
			load_hostkeys(ip_hostkeys, ip, system_hostfiles[i]);
	}

 retry:
	/* Reload these as they may have changed on cert->key downgrade */
	want_cert = key_is_cert(host_key);
	type = key_type(host_key);

	/*
	 * Check if the host key is present in the user's list of known
	 * hosts or in the systemwide list.
	 */
	host_status = check_key_in_hostkeys(host_hostkeys, host_key,
	    &host_found);

	/*
	 * Also perform check for the ip address, skip the check if we are
	 * localhost, looking for a certificate, or the hostname was an ip
	 * address to begin with.
	 */
	if (!want_cert && ip_hostkeys != NULL) {
		ip_status = check_key_in_hostkeys(ip_hostkeys, host_key,
		    &ip_found);
		if (host_status == HOST_CHANGED &&
		    (ip_status != HOST_CHANGED || 
		    (ip_found != NULL &&
		    !key_equal(ip_found->key, host_found->key))))
			host_ip_differ = 1;
	} else
		ip_status = host_status;

	switch (host_status) {
	case HOST_OK:
		/* The host is known and the key matches. */
		debug("Host '%.200s' is known and matches the %s host %s.",
		    host, type, want_cert ? "certificate" : "key");
		debug("Found %s in %s:%lu", want_cert ? "CA key" : "key",
		    host_found->file, host_found->line);
		if (want_cert && !check_host_cert(hostname, host_key))
			goto fail;
		if (options.check_host_ip && ip_status == HOST_NEW) {
			if (readonly || want_cert)
				logit("%s host key for IP address "
				    "'%.128s' not in list of known hosts.",
				    type, ip);
			else if (!add_host_to_hostfile(user_hostfiles[0], ip,
			    host_key, options.hash_known_hosts))
				logit("Failed to add the %s host key for IP "
				    "address '%.128s' to the list of known "
				    "hosts (%.500s).", type, ip,
				    user_hostfiles[0]);
			else
				logit("Warning: Permanently added the %s host "
				    "key for IP address '%.128s' to the list "
				    "of known hosts.", type, ip);
		} else if (options.visual_host_key) {
			fp = sshkey_fingerprint(host_key,
			    options.fingerprint_hash, SSH_FP_DEFAULT);
			ra = sshkey_fingerprint(host_key,
			    options.fingerprint_hash, SSH_FP_RANDOMART);
			if (fp == NULL || ra == NULL)
				fatal("%s: sshkey_fingerprint fail", __func__);
			logit("Host key fingerprint is %s\n%s", fp, ra);
			free(ra);
			free(fp);
		}
		hostkey_trusted = 1;
		break;
	case HOST_NEW:
		if (options.host_key_alias == NULL && port != 0 &&
		    port != SSH_DEFAULT_PORT) {
			debug("checking without port identifier");
			if (check_host_key(hostname, hostaddr, 0, host_key,
			    ROQUIET, user_hostfiles, num_user_hostfiles,
			    system_hostfiles, num_system_hostfiles) == 0) {
				debug("found matching key w/out port");
				break;
			}
		}
		if (readonly || want_cert)
			goto fail;
		/* The host is new. */
		if (options.strict_host_key_checking == 1) {
			/*
			 * User has requested strict host key checking.  We
			 * will not add the host key automatically.  The only
			 * alternative left is to abort.
			 */
			error("No %s host key is known for %.200s and you "
			    "have requested strict checking.", type, host);
			goto fail;
		} else if (options.strict_host_key_checking == 2) {
			char msg1[1024], msg2[1024];

			if (show_other_keys(host_hostkeys, host_key))
				snprintf(msg1, sizeof(msg1),
				    "\nbut keys of different type are already"
				    " known for this host.");
			else
				snprintf(msg1, sizeof(msg1), ".");
			/* The default */
			fp = sshkey_fingerprint(host_key,
			    options.fingerprint_hash, SSH_FP_DEFAULT);
			ra = sshkey_fingerprint(host_key,
			    options.fingerprint_hash, SSH_FP_RANDOMART);
			if (fp == NULL || ra == NULL)
				fatal("%s: sshkey_fingerprint fail", __func__);
			msg2[0] = '\0';
			if (options.verify_host_key_dns) {
				if (matching_host_key_dns)
					snprintf(msg2, sizeof(msg2),
					    "Matching host key fingerprint"
					    " found in DNS.\n");
				else
					snprintf(msg2, sizeof(msg2),
					    "No matching host key fingerprint"
					    " found in DNS.\n");
			}
			snprintf(msg, sizeof(msg),
			    "The authenticity of host '%.200s (%s)' can't be "
			    "established%s\n"
			    "%s key fingerprint is %s.%s%s\n%s"
			    "Are you sure you want to continue connecting "
			    "(yes/no)? ",
			    host, ip, msg1, type, fp,
			    options.visual_host_key ? "\n" : "",
			    options.visual_host_key ? ra : "",
			    msg2);
			free(ra);
			free(fp);
			if (!confirm(msg))
				goto fail;
			hostkey_trusted = 1; /* user explicitly confirmed */
		}
		/*
		 * If not in strict mode, add the key automatically to the
		 * local known_hosts file.
		 */
		if (options.check_host_ip && ip_status == HOST_NEW) {
			snprintf(hostline, sizeof(hostline), "%s,%s", host, ip);
			hostp = hostline;
			if (options.hash_known_hosts) {
				/* Add hash of host and IP separately */
				r = add_host_to_hostfile(user_hostfiles[0],
				    host, host_key, options.hash_known_hosts) &&
				    add_host_to_hostfile(user_hostfiles[0], ip,
				    host_key, options.hash_known_hosts);
			} else {
				/* Add unhashed "host,ip" */
				r = add_host_to_hostfile(user_hostfiles[0],
				    hostline, host_key,
				    options.hash_known_hosts);
			}
		} else {
			r = add_host_to_hostfile(user_hostfiles[0], host,
			    host_key, options.hash_known_hosts);
			hostp = host;
		}

		if (!r)
			logit("Failed to add the host to the list of known "
			    "hosts (%.500s).", user_hostfiles[0]);
		else
			logit("Warning: Permanently added '%.200s' (%s) to the "
			    "list of known hosts.", hostp, type);
		break;
	case HOST_REVOKED:
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("@@       WARNING: REVOKED HOST KEY DETECTED!               @@");
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("The %s host key for %s is marked as revoked.", type, host);
		error("This could mean that a stolen key is being used to");
		error("impersonate this host.");

		/*
		 * If strict host key checking is in use, the user will have
		 * to edit the key manually and we can only abort.
		 */
		if (options.strict_host_key_checking) {
			error("%s host key for %.200s was revoked and you have "
			    "requested strict checking.", type, host);
			goto fail;
		}
		goto continue_unsafe;

	case HOST_CHANGED:
		if (want_cert) {
			/*
			 * This is only a debug() since it is valid to have
			 * CAs with wildcard DNS matches that don't match
			 * all hosts that one might visit.
			 */
			debug("Host certificate authority does not "
			    "match %s in %s:%lu", CA_MARKER,
			    host_found->file, host_found->line);
			goto fail;
		}
		if (readonly == ROQUIET)
			goto fail;
		if (options.check_host_ip && host_ip_differ) {
			char *key_msg;
			if (ip_status == HOST_NEW)
				key_msg = "is unknown";
			else if (ip_status == HOST_OK)
				key_msg = "is unchanged";
			else
				key_msg = "has a different value";
			error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
			error("@@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @@");
			error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
			error("The %s host key for %s has changed,", type, host);
			error("and the key for the corresponding IP address %s", ip);
			error("%s. This could either mean that", key_msg);
			error("DNS SPOOFING is happening or the IP address for the host");
			error("and its host key have changed at the same time.");
			if (ip_status != HOST_NEW)
				error("Offending key for IP in %s:%lu",
				    ip_found->file, ip_found->line);
		}
		/* The host key has changed. */
		warn_changed_key(host_key);
		error("Add correct host key in %.100s to get rid of this message.",
		    user_hostfiles[0]);
		error("Offending %s key in %s:%lu", key_type(host_found->key),
		    host_found->file, host_found->line);

		/*
		 * If strict host key checking is in use, the user will have
		 * to edit the key manually and we can only abort.
		 */
		if (options.strict_host_key_checking) {
			error("%s host key for %.200s has changed and you have "
			    "requested strict checking.", type, host);
			goto fail;
		}

 continue_unsafe:
		/*
		 * If strict host key checking has not been requested, allow
		 * the connection but without MITM-able authentication or
		 * forwarding.
		 */
		if (options.password_authentication) {
			error("Password authentication is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.password_authentication = 0;
			cancelled_forwarding = 1;
		}
		if (options.kbd_interactive_authentication) {
			error("Keyboard-interactive authentication is disabled"
			    " to avoid man-in-the-middle attacks.");
			options.kbd_interactive_authentication = 0;
			options.challenge_response_authentication = 0;
			cancelled_forwarding = 1;
		}
		if (options.challenge_response_authentication) {
			error("Challenge/response authentication is disabled"
			    " to avoid man-in-the-middle attacks.");
			options.challenge_response_authentication = 0;
			cancelled_forwarding = 1;
		}
		if (options.forward_agent) {
			error("Agent forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.forward_agent = 0;
			cancelled_forwarding = 1;
		}
		if (options.forward_x11) {
			error("X11 forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.forward_x11 = 0;
			cancelled_forwarding = 1;
		}
		if (options.num_local_forwards > 0 ||
		    options.num_remote_forwards > 0) {
			error("Port forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.num_local_forwards =
			    options.num_remote_forwards = 0;
			cancelled_forwarding = 1;
		}
		if (options.tun_open != SSH_TUNMODE_NO) {
			error("Tunnel forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.tun_open = SSH_TUNMODE_NO;
			cancelled_forwarding = 1;
		}
		if (options.exit_on_forward_failure && cancelled_forwarding)
			fatal("Error: forwarding disabled due to host key "
			    "check failure");
		
		/*
		 * XXX Should permit the user to change to use the new id.
		 * This could be done by converting the host key to an
		 * identifying sentence, tell that the host identifies itself
		 * by that sentence, and ask the user if he/she wishes to
		 * accept the authentication.
		 */
		break;
	case HOST_FOUND:
		fatal("internal error");
		break;
	}

	if (options.check_host_ip && host_status != HOST_CHANGED &&
	    ip_status == HOST_CHANGED) {
		snprintf(msg, sizeof(msg),
		    "Warning: the %s host key for '%.200s' "
		    "differs from the key for the IP address '%.128s'"
		    "\nOffending key for IP in %s:%lu",
		    type, host, ip, ip_found->file, ip_found->line);
		if (host_status == HOST_OK) {
			len = strlen(msg);
			snprintf(msg + len, sizeof(msg) - len,
			    "\nMatching host key in %s:%lu",
			    host_found->file, host_found->line);
		}
		if (options.strict_host_key_checking == 1) {
			logit("%s", msg);
			error("Exiting, you have requested strict checking.");
			goto fail;
		} else if (options.strict_host_key_checking == 2) {
			strlcat(msg, "\nAre you sure you want "
			    "to continue connecting (yes/no)? ", sizeof(msg));
			if (!confirm(msg))
				goto fail;
		} else {
			logit("%s", msg);
		}
	}

	if (!hostkey_trusted && options.update_hostkeys) {
		debug("%s: hostkey not known or explicitly trusted: "
		    "disabling UpdateHostkeys", __func__);
		options.update_hostkeys = 0;
	}

	free(ip);
	free(host);
	if (host_hostkeys != NULL)
		free_hostkeys(host_hostkeys);
	if (ip_hostkeys != NULL)
		free_hostkeys(ip_hostkeys);
	return 0;

fail:
	if (want_cert && host_status != HOST_REVOKED) {
		/*
		 * No matching certificate. Downgrade cert to raw key and
		 * search normally.
		 */
		debug("No matching CA found. Retry with plain key");
		raw_key = key_from_private(host_key);
		if (key_drop_cert(raw_key) != 0)
			fatal("Couldn't drop certificate");
		host_key = raw_key;
		goto retry;
	}
	if (raw_key != NULL)
		key_free(raw_key);
	free(ip);
	free(host);
	if (host_hostkeys != NULL)
		free_hostkeys(host_hostkeys);
	if (ip_hostkeys != NULL)
		free_hostkeys(ip_hostkeys);
	return -1;
}

/* returns 0 if key verifies or -1 if key does NOT verify */
int
verify_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)
{
	u_int i;
	int r = -1, flags = 0;
	char valid[64], *fp = NULL, *cafp = NULL;
	struct sshkey *plain = NULL;

	if ((fp = sshkey_fingerprint(host_key,
	    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {
		error("%s: fingerprint host key: %s", __func__, ssh_err(r));
		r = -1;
		goto out;
	}

	if (sshkey_is_cert(host_key)) {
		if ((cafp = sshkey_fingerprint(host_key->cert->signature_key,
		    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {
			error("%s: fingerprint CA key: %s",
			    __func__, ssh_err(r));
			r = -1;
			goto out;
		}
		sshkey_format_cert_validity(host_key->cert,
		    valid, sizeof(valid));
		debug("Server host certificate: %s %s, serial %llu "
		    "ID \"%s\" CA %s %s valid %s",
		    sshkey_ssh_name(host_key), fp,
		    (unsigned long long)host_key->cert->serial,
		    host_key->cert->key_id,
		    sshkey_ssh_name(host_key->cert->signature_key), cafp,
		    valid);
		for (i = 0; i < host_key->cert->nprincipals; i++) {
			debug2("Server host certificate hostname: %s",
			    host_key->cert->principals[i]);
		}
	} else {
		debug("Server host key: %s %s", compat20 ?
		    sshkey_ssh_name(host_key) : sshkey_type(host_key), fp);
	}

	if (sshkey_equal(previous_host_key, host_key)) {
		debug2("%s: server host key %s %s matches cached key",
		    __func__, sshkey_type(host_key), fp);
		r = 0;
		goto out;
	}

	/* Check in RevokedHostKeys file if specified */
	if (options.revoked_host_keys != NULL) {
		r = sshkey_check_revoked(host_key, options.revoked_host_keys);
		switch (r) {
		case 0:
			break; /* not revoked */
		case SSH_ERR_KEY_REVOKED:
			error("Host key %s %s revoked by file %s",
			    sshkey_type(host_key), fp,
			    options.revoked_host_keys);
			r = -1;
			goto out;
		default:
			error("Error checking host key %s %s in "
			    "revoked keys file %s: %s", sshkey_type(host_key),
			    fp, options.revoked_host_keys, ssh_err(r));
			r = -1;
			goto out;
		}
	}

	if (options.verify_host_key_dns) {
		/*
		 * XXX certs are not yet supported for DNS, so downgrade
		 * them and try the plain key.
		 */
		if ((r = sshkey_from_private(host_key, &plain)) != 0)
			goto out;
		if (sshkey_is_cert(plain))
			sshkey_drop_cert(plain);
		if (verify_host_key_dns(host, hostaddr, plain, &flags) == 0) {
			if (flags & DNS_VERIFY_FOUND) {
				if (options.verify_host_key_dns == 1 &&
				    flags & DNS_VERIFY_MATCH &&
				    flags & DNS_VERIFY_SECURE) {
					r = 0;
					goto out;
				}
				if (flags & DNS_VERIFY_MATCH) {
					matching_host_key_dns = 1;
				} else {
					warn_changed_key(plain);
					error("Update the SSHFP RR in DNS "
					    "with the new host key to get rid "
					    "of this message.");
				}
			}
		}
	}
	r = check_host_key(host, hostaddr, options.port, host_key, RDRW,
	    options.user_hostfiles, options.num_user_hostfiles,
	    options.system_hostfiles, options.num_system_hostfiles);

out:
	sshkey_free(plain);
	free(fp);
	free(cafp);
	if (r == 0 && host_key != NULL) {
		key_free(previous_host_key);
		previous_host_key = key_from_private(host_key);
	}

	return r;
}

/*
 * Starts a dialog with the server, and authenticates the current user on the
 * server.  This does not need any extra privileges.  The basic connection
 * to the server must already have been established before this is called.
 * If login fails, this function prints an error and never returns.
 * This function does not require super-user privileges.
 */
void
ssh_login(Sensitive *sensitive, const char *orighost,
    struct sockaddr *hostaddr, u_short port, struct passwd *pw, int timeout_ms)
{
	char *host;
	char *server_user, *local_user;

	local_user = xstrdup(pw->pw_name);
	server_user = options.user ? options.user : local_user;

	/* Convert the user-supplied hostname into all lowercase. */
	host = xstrdup(orighost);
	lowercase(host);

	/* Exchange protocol version identification strings with the server. */
	ssh_exchange_identification(timeout_ms);

	/* Put the connection into non-blocking mode. */
	packet_set_nonblocking();

	/* key exchange */
	/* authenticate user */
	debug("Authenticating to %s:%d as '%s'", host, port, server_user);
	if (compat20) {
		ssh_kex2(host, hostaddr, port);
		ssh_userauth2(local_user, server_user, host, sensitive);
	} else {
#ifdef WITH_SSH1
		ssh_kex(host, hostaddr);
		ssh_userauth1(local_user, server_user, host, sensitive);
#else
		fatal("ssh1 is not supported");
#endif
	}
	free(local_user);
}

void
ssh_put_password(char *password)
{
	int size;
	char *padded;

	if (datafellows & SSH_BUG_PASSWORDPAD) {
		packet_put_cstring(password);
		return;
	}
	size = ROUNDUP(strlen(password) + 1, 32);
	padded = xcalloc(1, size);
	strlcpy(padded, password, size);
	packet_put_string(padded, size);
	explicit_bzero(padded, size);
	free(padded);
}

/* print all known host keys for a given host, but skip keys of given type */
static int
show_other_keys(struct hostkeys *hostkeys, Key *key)
{
	int type[] = {
		KEY_RSA1,
		KEY_RSA,
		KEY_DSA,
		KEY_ECDSA,
		KEY_ED25519,
		-1
	};
	int i, ret = 0;
	char *fp, *ra;
	const struct hostkey_entry *found;

	for (i = 0; type[i] != -1; i++) {
		if (type[i] == key->type)
			continue;
		if (!lookup_key_in_hostkeys_by_type(hostkeys, type[i], &found))
			continue;
		fp = sshkey_fingerprint(found->key,
		    options.fingerprint_hash, SSH_FP_DEFAULT);
		ra = sshkey_fingerprint(found->key,
		    options.fingerprint_hash, SSH_FP_RANDOMART);
		if (fp == NULL || ra == NULL)
			fatal("%s: sshkey_fingerprint fail", __func__);
		logit("WARNING: %s key found for host %s\n"
		    "in %s:%lu\n"
		    "%s key fingerprint %s.",
		    key_type(found->key),
		    found->host, found->file, found->line,
		    key_type(found->key), fp);
		if (options.visual_host_key)
			logit("%s", ra);
		free(ra);
		free(fp);
		ret = 1;
	}
	return ret;
}

static void
warn_changed_key(Key *host_key)
{
	char *fp;

	fp = sshkey_fingerprint(host_key, options.fingerprint_hash,
	    SSH_FP_DEFAULT);
	if (fp == NULL)
		fatal("%s: sshkey_fingerprint fail", __func__);

	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@");
	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
	error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
	error("It is also possible that a host key has just been changed.");
	error("The fingerprint for the %s key sent by the remote host is\n%s.",
	    key_type(host_key), fp);
	error("Please contact your system administrator.");

	free(fp);
}

/*
 * Execute a local command
 */
int
ssh_local_cmd(const char *args)
{
	char *shell;
	pid_t pid;
	int status;
	void (*osighand)(int);

	if (!options.permit_local_command ||
	    args == NULL || !*args)
		return (1);

	if ((shell = getenv("SHELL")) == NULL || *shell == '\0')
		shell = _PATH_BSHELL;

	osighand = signal(SIGCHLD, SIG_DFL);
	pid = fork();
	if (pid == 0) {
		signal(SIGPIPE, SIG_DFL);
		debug3("Executing %s -c \"%s\"", shell, args);
		execl(shell, shell, "-c", args, (char *)NULL);
		error("Couldn't execute %s -c \"%s\": %s",
		    shell, args, strerror(errno));
		_exit(1);
	} else if (pid == -1)
		fatal("fork failed: %.100s", strerror(errno));
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));
	signal(SIGCHLD, osighand);

	if (!WIFEXITED(status))
		return (1);

	return (WEXITSTATUS(status));
}

void
maybe_add_key_to_agent(char *authfile, Key *private, char *comment,
    char *passphrase)
{
	int auth_sock = -1, r;

	if (options.add_keys_to_agent == 0)
		return;

	if ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {
		debug3("no authentication agent, not adding key");
		return;
	}

	if (options.add_keys_to_agent == 2 &&
	    !ask_permission("Add key %s (%s) to agent?", authfile, comment)) {
		debug3("user denied adding this key");
		close(auth_sock);
		return;
	}

	if ((r = ssh_add_identity_constrained(auth_sock, private, comment, 0,
	    (options.add_keys_to_agent == 3))) == 0)
		debug("identity added to agent: %s", authfile);
	else
		debug("could not add identity to agent: %s (%d)", authfile, r);
	close(auth_sock);
}
@


1.272
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.271 2016/01/14 22:56:56 markus Exp $ */
d1509 1
d1518 1
@


1.271
log
@fd leaks; report Qualys Security Advisory team; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.270 2016/01/14 16:17:40 markus Exp $ */
a15 1
#include <sys/param.h>	/* roundup */
d1379 1
a1379 1
	size = roundup(strlen(password) + 1, 32);
@


1.270
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.269 2015/11/20 01:45:29 djm Exp $ */
d160 1
@


1.269
log
@add cast to make -Werror clean
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.268 2015/11/19 08:23:27 djm Exp $ */
a51 1
#include "roaming.h"
d524 1
a524 1
	if (roaming_atomicio(vwrite, connection_out, client_version_string,
d584 1
a584 1
			len = roaming_atomicio(read, connection_in, &buf[i], 1);
@


1.268
log
@ban ConnectionAttempts=0, it makes no sense and would cause
ssh_connect_direct() to print an uninitialised stack variable;
bz#2500 reported by dvw AT phas.ubc.ca
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.267 2015/11/19 01:09:38 djm Exp $ */
d1241 2
a1242 1
		    host_key->cert->serial, host_key->cert->key_id,
@


1.267
log
@print host certificate contents at debug level
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.266 2015/11/15 22:26:49 jcs Exp $ */
d427 2
@


1.266
log
@Add an AddKeysToAgent client option which can be set to 'yes', 'no',
'ask', or 'confirm', and defaults to 'no'.  When enabled, a private
key that is used during authentication will be added to ssh-agent if
it is running (with confirmation enabled if set to 'confirm').

Initial version from Joachim Schipper many years ago.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.265 2015/09/04 04:55:24 djm Exp $ */
d1214 1
d1216 1
a1216 1
	char *fp = NULL;
d1226 24
a1249 2
	debug("Server host key: %s %s",
	    compat20 ? sshkey_ssh_name(host_key) : sshkey_type(host_key), fp);
d1314 1
@


1.265
log
@correct function name in error messages
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.264 2015/09/04 03:57:38 djm Exp $ */
d58 1
d1464 27
@


1.264
log
@remove extra newline in nethack-mode hostkey;
from Christian Hesse bz#2686
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.263 2015/08/20 22:32:42 deraadt Exp $ */
d425 1
a425 1
	debug2("ssh_connect: needpriv %d", needpriv);
d444 1
a444 1
				error("ssh_connect: getnameinfo failed");
@


1.263
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.262 2015/05/28 05:41:29 dtucker Exp $ */
d902 1
a902 1
			logit("Host key fingerprint is %s\n%s\n", fp, ra);
@


1.262
log
@Increase the allowed length of the known host file name in the log
message to be consistent with other cases.  Part of bz#1993, ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.261 2015/04/14 04:17:03 dtucker Exp $ */
d349 1
a349 1
	fdset = (fd_set *)xcalloc(howmany(sockfd + 1, NFDBITS),
@


1.261
log
@Output remote username in debug output since with Host and Match it's not
always obvious what it will be.  bz#2368, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.260 2015/03/24 01:11:12 djm Exp $ */
d889 1
a889 1
				    "hosts (%.30s).", type, ip,
@


1.260
log
@fix double-negative error message "ssh1 is not unsupported"
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.259 2015/01/28 22:36:00 djm Exp $ */
d1327 1
@


1.259
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.258 2015/01/26 06:10:03 djm Exp $ */
d1335 1
a1335 1
		fatal("ssh1 is not unsupported");
@


1.258
log
@correctly match ECDSA subtype (== curve) for offered/recevied
host keys. Fixes connection-killing host key mismatches when
a server offers multiple ECDSA keys with different curve type
(an extremely unlikely configuration).

ok markus, "looks mechanical" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.257 2015/01/26 03:04:46 djm Exp $ */
d747 1
a747 1
			fatal("check_host_key: getnameinfo failed");
d896 1
a896 1
			fp = key_fingerprint(host_key,
d898 1
a898 1
			ra = key_fingerprint(host_key,
d900 2
d941 1
a941 1
			fp = key_fingerprint(host_key,
d943 1
a943 1
			ra = key_fingerprint(host_key,
d945 2
d1380 1
a1380 1
		fp = key_fingerprint(found->key,
d1382 1
a1382 1
		ra = key_fingerprint(found->key,
d1384 2
d1406 1
a1406 1
	fp = key_fingerprint(host_key, options.fingerprint_hash,
d1408 2
@


1.257
log
@Host key rotation support.

Add a hostkeys@@openssh.com protocol extension (global request) for
a server to inform a client of all its available host key after
authentication has completed. The client may record the keys in
known_hosts, allowing it to upgrade to better host key algorithms
and a server to gracefully rotate its keys.

The client side of this is controlled by a UpdateHostkeys config
option (default on).

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.256 2015/01/20 23:14:00 deraadt Exp $ */
d1220 2
a1221 1
	debug("Server host key: %s %s", sshkey_type(host_key), fp);
@


1.256
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.255 2015/01/19 20:20:20 markus Exp $ */
d795 1
d904 1
d968 1
d1165 6
@


1.255
log
@store compat flags in struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.254 2014/12/21 22:27:56 djm Exp $ */
d16 1
a17 1
#include <sys/param.h>
@


1.254
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.253 2014/12/11 08:20:09 djm Exp $ */
d621 1
a621 1
	compat_datafellows(remote_version);
@


1.253
log
@explicitly include sys/param.h in files that use the howmany() macro;
from portable
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.252 2014/12/04 02:24:32 djm Exp $ */
d895 4
a898 3
			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
			ra = key_fingerprint(host_key, SSH_FP_MD5,
			    SSH_FP_RANDOMART);
d937 4
a940 3
			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
			ra = key_fingerprint(host_key, SSH_FP_MD5,
			    SSH_FP_RANDOMART);
d1205 1
a1205 1
	    SSH_FP_MD5, SSH_FP_HEX)) == NULL) {
d1366 4
a1369 2
		fp = key_fingerprint(found->key, SSH_FP_MD5, SSH_FP_HEX);
		ra = key_fingerprint(found->key, SSH_FP_MD5, SSH_FP_RANDOMART);
d1390 2
a1391 1
	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
@


1.252
log
@add RevokedHostKeys option for the client

Allow textfile or KRL-based revocation of hostkeys.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.251 2014/07/15 15:54:14 millert Exp $ */
d17 1
@


1.251
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.250 2014/07/03 22:23:46 djm Exp $ */
d55 2
d1198 2
a1199 2
	char *fp;
	Key *plain = NULL;
d1201 35
a1235 7
	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
	debug("Server host key: %s %s", key_type(host_key), fp);
	free(fp);

	if (key_equal(previous_host_key, host_key)) {
		debug("%s: server host key matches cached key", __func__);
		return 0;
d1243 4
a1246 3
		plain = key_from_private(host_key);
		if (key_is_cert(plain))
			key_drop_cert(plain);
a1251 1
					key_free(plain);
d1253 1
a1253 1
					goto done;
a1264 1
		key_free(plain);
a1265 1

d1270 3
a1272 1
done:
@


1.250
log
@when rekeying, skip file/DNS lookup if it is the same as the key sent
during initial key exchange. bz#2154 patch from Iain Morgan; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.249 2014/06/24 01:13:21 djm Exp $ */
d47 1
a49 1
#include "misc.h"
@


1.249
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.248 2014/04/29 18:01:49 markus Exp $ */
d58 1
d1195 1
a1195 1
	int flags = 0;
d1203 5
d1222 2
a1223 1
					return 0;
d1238 1
a1238 1
	return check_host_key(host, hostaddr, options.port, host_key, RDRW,
d1241 8
@


1.248
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.247 2014/04/01 03:34:10 djm Exp $ */
d702 1
a702 1
	if (buffer_len(&host_key->cert->critical) != 0) {
@


1.247
log
@When using VerifyHostKeyDNS with a DNSSEC resolver, down-convert any
certificate keys to plain keys and attempt SSHFP resolution.

Prevents a server from skipping SSHFP lookup and forcing a new-hostkey
dialog by offering only certificate keys.

Reported by mcv21 AT cam.ac.uk
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.246 2014/02/06 22:21:01 djm Exp $ */
d1269 1
d1272 3
@


1.246
log
@in ssh_create_socket(), only do the getaddrinfo for BindAddress when
BindAddress is actually specified. Fixes regression in 6.5 for
UsePrivilegedPort=yes; patch from Corinna Vinschen
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.245 2014/02/02 03:44:31 djm Exp $ */
d1196 1
d1202 24
a1225 16
	/* XXX certs are not yet supported for DNS */
	if (!key_is_cert(host_key) && options.verify_host_key_dns &&
	    verify_host_key_dns(host, hostaddr, host_key, &flags) == 0) {
		if (flags & DNS_VERIFY_FOUND) {

			if (options.verify_host_key_dns == 1 &&
			    flags & DNS_VERIFY_MATCH &&
			    flags & DNS_VERIFY_SECURE)
				return 0;

			if (flags & DNS_VERIFY_MATCH) {
				matching_host_key_dns = 1;
			} else {
				warn_changed_key(host_key);
				error("Update the SSHFP RR in DNS with the new "
				    "host key to get rid of this message.");
d1228 1
@


1.245
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.244 2014/01/09 23:26:48 djm Exp $ */
d262 1
a262 1
	struct addrinfo hints, *res;
d275 13
a287 11
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = ai->ai_family;
	hints.ai_socktype = ai->ai_socktype;
	hints.ai_protocol = ai->ai_protocol;
	hints.ai_flags = AI_PASSIVE;
	gaierr = getaddrinfo(options.bind_address, NULL, &hints, &res);
	if (gaierr) {
		error("getaddrinfo: %s: %s", options.bind_address,
		    ssh_gai_strerror(gaierr));
		close(sock);
		return -1;
d295 1
a295 1
		r = bindresvport_sa(sock, res->ai_addr);
d312 2
a313 1
	freeaddrinfo(res);
@


1.244
log
@ban clients/servers that suffer from SSH_BUG_DERIVEKEY, they are ancient,
deranged and might make some attacks on KEX easier; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.243 2013/12/30 23:52:27 djm Exp $ */
d1276 1
a1276 1
	memset(padded, 0, size);
@


1.243
log
@refuse RSA keys from old proprietary clients/servers that use the
obsolete RSA+MD5 signature scheme. it will still be possible to connect
with these clients/servers but only DSA keys will be accepted, and we'll
deprecate them entirely in a future release. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.242 2013/12/29 05:57:02 djm Exp $ */
d655 3
@


1.242
log
@when showing other hostkeys, don't forget Ed25519 keys
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.241 2013/10/16 02:31:46 djm Exp $ */
d655 3
@


1.241
log
@Implement client-side hostname canonicalisation to allow an explicit
search path of domain suffixes to use to convert unqualified host names
to fully-qualified ones for host key matching.
This is particularly useful for host certificates, which would otherwise
need to list unqualified names alongside fully-qualified ones (and this
causes a number of problems).

"looks fine" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.240 2013/09/19 01:26:29 djm Exp $ */
d1278 8
a1285 1
	int type[] = { KEY_RSA1, KEY_RSA, KEY_DSA, KEY_ECDSA, -1};
@


1.240
log
@bz#1211: make BindAddress work with UsePrivilegedPort=yes; patch from
swp AT swp.pp.ru; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.239 2013/08/20 00:11:38 djm Exp $ */
d79 1
a79 1
	snprintf(strport, sizeof strport, "%hu", port);
a162 2
	packet_set_timeout(options.server_alive_interval,
	    options.server_alive_count_max);
a177 10
	if (!strcmp(proxy_command, "-")) {
		packet_set_connection(STDIN_FILENO, STDOUT_FILENO);
		packet_set_timeout(options.server_alive_interval,
		    options.server_alive_count_max);
		return 0;
	}

	if (options.proxy_use_fdpass)
		return ssh_proxy_fdpass_connect(host, port, proxy_command);

a238 2
	packet_set_timeout(options.server_alive_interval,
	    options.server_alive_count_max);
d408 4
a411 4
int
ssh_connect(const char *host, struct sockaddr_storage * hostaddr,
    u_short port, int family, int connection_attempts, int *timeout_ms,
    int want_keepalive, int needpriv, const char *proxy_command)
a412 1
	int gaierr;
d416 1
a416 1
	struct addrinfo hints, *ai, *aitop;
a419 14
	/* If a proxy command is given, connect using it. */
	if (proxy_command != NULL)
		return ssh_proxy_connect(host, port, proxy_command);

	/* No proxy command. */

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
	snprintf(strport, sizeof strport, "%u", port);
	if ((gaierr = getaddrinfo(host, strport, &hints, &aitop)) != 0)
		fatal("%s: Could not resolve hostname %.100s: %s", __progname,
		    host, ssh_gai_strerror(gaierr));

d431 2
a432 1
			if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
a464 2
	freeaddrinfo(aitop);

a481 2
	packet_set_timeout(options.server_alive_interval,
	    options.server_alive_count_max);
d486 18
d1228 1
a1228 1
	char *host, *cp;
d1236 1
a1236 3
	for (cp = host; *cp; cp++)
		if (isupper(*cp))
			*cp = (char)tolower(*cp);
@


1.239
log
@Add a ssh_config ProxyUseFDPass option that supports the use of
ProxyCommands that establish a connection and then pass a connected
file descriptor back to ssh(1). This allows the ProxyCommand to exit
rather than have to shuffle data back and forth and enables ssh to use
getpeername, etc. to obtain address information just like it does with
regular directly-connected sockets. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.238 2013/05/17 00:13:14 djm Exp $ */
d275 1
a275 1
	int sock, gaierr;
a277 16
	/*
	 * If we are running as root and want to connect to a privileged
	 * port, bind our own socket to a privileged port.
	 */
	if (privileged) {
		int p = IPPORT_RESERVED - 1;
		PRIV_START;
		sock = rresvport_af(&p, ai->ai_family);
		PRIV_END;
		if (sock < 0)
			error("rresvport: af=%d %.100s", ai->ai_family,
			    strerror(errno));
		else
			debug("Allocated local port %d.", p);
		return sock;
	}
d280 1
a280 1
		error("socket: %.100s", strerror(errno));
d286 1
a286 1
	if (options.bind_address == NULL)
d301 22
a322 5
	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
		error("bind: %s: %s", options.bind_address, strerror(errno));
		close(sock);
		freeaddrinfo(res);
		return -1;
@


1.238
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.237 2013/02/22 19:13:56 markus Exp $ */
d52 1
d72 97
d175 1
a175 1
	char *command_string, *tmp;
d178 1
a178 1
	char *shell, strport[NI_MAXSERV];
d187 3
a192 15
	/* Convert the port number into a string. */
	snprintf(strport, sizeof strport, "%hu", port);

	/*
	 * Build the final command string in the buffer by making the
	 * appropriate substitutions to the given proxy command.
	 *
	 * Use "exec" to avoid "sh -c" processes on some platforms
	 * (e.g. Solaris)
	 */
	xasprintf(&tmp, "exec %s", proxy_command);
	command_string = percent_expand(tmp, "h", host, "p", strport,
	    "r", options.user, (char *)NULL);
	free(tmp);

d198 2
@


1.237
log
@support ProxyCommand=- (stdin/out already point to the proxy); ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.236 2012/09/14 16:51:34 markus Exp $ */
d105 1
a105 1
	xfree(tmp);
d159 1
a159 1
	xfree(command_string);
d308 1
a308 1
	xfree(fdset);
d527 1
a527 1
	xfree(fdset);
d603 1
a603 2
		if (p)
			xfree(p);
d811 2
a812 2
			xfree(ra);
			xfree(fp);
d872 2
a873 2
			xfree(ra);
			xfree(fp);
d1074 2
a1075 2
	xfree(ip);
	xfree(host);
d1097 2
a1098 2
	xfree(ip);
	xfree(host);
d1115 1
a1115 1
	xfree(fp);
d1180 1
a1180 1
	xfree(local_user);
d1198 1
a1198 1
	xfree(padded);
d1225 2
a1226 2
		xfree(ra);
		xfree(fp);
d1249 1
a1249 1
	xfree(fp);
@


1.236
log
@remove unused variable
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.235 2012/08/17 01:30:00 djm Exp $ */
d81 7
@


1.235
log
@Send client banner immediately, rather than waiting for the server to
move first for SSH protocol 2 connections (the default). Patch based on
one in bz#1999 by tls AT panix.com, feedback dtucker@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.234 2011/05/24 07:15:47 djm Exp $ */
a424 2
	char buf[256];

@


1.234
log
@Remove undocumented legacy options UserKnownHostsFile2 and
GlobalKnownHostsFile2 by making UserKnownHostsFile/GlobalKnownHostsFile
accept multiple paths per line and making their defaults include
known_hosts2; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.233 2011/05/23 03:52:55 djm Exp $ */
d422 20
d453 1
a453 1
	int minor1 = PROTOCOL_MINOR_1;
d463 10
d575 2
a576 10
	/* Send our own protocol version identification. */
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s",
	    compat20 ? PROTOCOL_MAJOR_2 : PROTOCOL_MAJOR_1,
	    compat20 ? PROTOCOL_MINOR_2 : minor1,
	    SSH_VERSION, compat20 ? "\r\n" : "\n");
	if (roaming_atomicio(vwrite, connection_out, buf, strlen(buf))
	    != strlen(buf))
		fatal("write: %.100s", strerror(errno));
	client_version_string = xstrdup(buf);
	chop(client_version_string);
a577 1
	debug("Local version string %.100s", client_version_string);
@


1.233
log
@remove extra newline
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.232 2011/01/16 11:50:36 djm Exp $ */
d660 1
a660 1
 * is not valid. the user_hostfile will not be updated if 'readonly' is true.
d667 3
a669 2
    Key *host_key, int readonly, char *user_hostfile,
    char *system_hostfile)
d671 2
a673 1
	const char *type;
a675 4
	HostStatus host_status;
	HostStatus ip_status;
	int r, want_cert = key_is_cert(host_key), host_ip_differ = 0;
	int local = sockaddr_is_local(hostaddr);
d677 2
d680 2
d683 1
a683 1
	const struct hostkey_entry *host_found, *ip_found;
d715 4
a718 2
	load_hostkeys(host_hostkeys, host, user_hostfile);
	load_hostkeys(host_hostkeys, host, system_hostfile);
d723 4
a726 2
		load_hostkeys(ip_hostkeys, ip, user_hostfile);
		load_hostkeys(ip_hostkeys, ip, system_hostfile);
d771 1
a771 1
			else if (!add_host_to_hostfile(user_hostfile, ip,
d775 2
a776 1
				    "hosts (%.30s).", type, ip, user_hostfile);
d795 2
a796 1
			    ROQUIET, user_hostfile, system_hostfile) == 0) {
d861 3
a863 3
				r = add_host_to_hostfile(user_hostfile, host,
				    host_key, options.hash_known_hosts) &&
				    add_host_to_hostfile(user_hostfile, ip,
d867 1
a867 1
				r = add_host_to_hostfile(user_hostfile,
d872 2
a873 2
			r = add_host_to_hostfile(user_hostfile, host, host_key,
			    options.hash_known_hosts);
d879 1
a879 1
			    "hosts (%.500s).", user_hostfile);
d940 1
a940 1
		    user_hostfile);
a1084 1
	struct stat st;
d1112 3
a1114 10
	/* return ok if the key can be found in an old keyfile */
	if (stat(options.system_hostfile2, &st) == 0 ||
	    stat(options.user_hostfile2, &st) == 0) {
		if (check_host_key(host, hostaddr, options.port, host_key,
		    RDONLY, options.user_hostfile2,
		    options.system_hostfile2) == 0)
			return 0;
	}
	return check_host_key(host, hostaddr, options.port, host_key,
	    RDRW, options.user_hostfile, options.system_hostfile);
@


1.232
log
@reset the SIGPIPE handler when forking to execute child processes;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.231 2011/01/06 23:01:35 djm Exp $ */
a1087 1

@


1.231
log
@reset SIGCHLD handler to SIG_DFL when execuring LocalCommand;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.230 2010/12/14 11:59:06 markus Exp $ */
d136 1
d1249 1
@


1.230
log
@don't mention key type in key-changed-warning, since we also print
this warning if a new key type appears. ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.229 2010/11/29 23:45:51 djm Exp $ */
d1236 1
d1245 1
d1258 1
@


1.229
log
@automatically order the hostkeys requested by the client based on
which hostkeys are already recorded in known_hosts. This avoids
hostkey warnings when connecting to servers with new ECDSA keys
that are preferred by default; with markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.228 2010/10/06 21:10:21 djm Exp $ */
a1210 1
	const char *type = key_type(host_key);
d1219 1
a1219 1
	error("It is also possible that the %s host key has just been changed.", type);
d1221 1
a1221 1
	    type, fp);
@


1.228
log
@swapped args to kill(2)
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.227 2010/10/06 06:39:28 djm Exp $ */
d68 1
a68 1
static int show_other_keys(const char *, Key *);
d600 57
d666 2
a667 2
    Key *host_key, int readonly, const char *user_hostfile,
    const char *system_hostfile)
d669 1
a669 1
	Key *file_key, *raw_key = NULL;
d675 2
a676 2
	int r, want_cert, local = 0, host_ip_differ = 0;
	char ntop[NI_MAXHOST];
d678 3
a680 2
	int len, host_line, ip_line, cancelled_forwarding = 0;
	const char *host_file = NULL, *ip_file = NULL;
a689 14
	/**  hostaddr == 0! */
	switch (hostaddr->sa_family) {
	case AF_INET:
		local = (ntohl(((struct sockaddr_in *)hostaddr)->
		    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
		break;
	case AF_INET6:
		local = IN6_IS_ADDR_LOOPBACK(
		    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));
		break;
	default:
		local = 0;
		break;
	}
d698 2
a699 2
	 * We don't have the remote ip-address for connections
	 * using a proxy command
d701 1
a701 8
	if (options.proxy_command == NULL) {
		if (getnameinfo(hostaddr, hostaddr->sa_len, ntop, sizeof(ntop),
		    NULL, 0, NI_NUMERICHOST) != 0)
			fatal("check_host_key: getnameinfo failed");
		ip = put_host_port(ntop, port);
	} else {
		ip = xstrdup("<no hostip for proxy command>");
	}
d711 9
a719 11
	/*
	 * Allow the user to record the key under a different name or
	 * differentiate a non-standard port.  This is useful for ssh
	 * tunneling over forwarded connections or if you run multiple
	 * sshd's on different ports on the same machine.
	 */
	if (options.host_key_alias != NULL) {
		host = xstrdup(options.host_key_alias);
		debug("using hostkeyalias: %s", host);
	} else {
		host = put_host_port(hostname, port);
d723 1
a727 6
	 * Store the host key from the known host file in here so that we can
	 * compare it with the key for the IP address.
	 */
	file_key = key_new(key_is_cert(host_key) ? KEY_UNSPEC : host_key->type);

	/*
d731 3
a733 8
	host_file = user_hostfile;
	host_status = check_host_in_hostfile(host_file, host, host_key,
	    file_key, &host_line);
	if (host_status == HOST_NEW) {
		host_file = system_hostfile;
		host_status = check_host_in_hostfile(host_file, host, host_key,
		    file_key, &host_line);
	}
d739 3
a741 11
	if (!want_cert && options.check_host_ip) {
		Key *ip_key = key_new(host_key->type);

		ip_file = user_hostfile;
		ip_status = check_host_in_hostfile(ip_file, ip, host_key,
		    ip_key, &ip_line);
		if (ip_status == HOST_NEW) {
			ip_file = system_hostfile;
			ip_status = check_host_in_hostfile(ip_file, ip,
			    host_key, ip_key, &ip_line);
		}
d743 3
a745 1
		    (ip_status != HOST_CHANGED || !key_equal(ip_key, file_key)))
a746 2

		key_free(ip_key);
a749 2
	key_free(file_key);

d755 2
a756 2
		debug("Found %s in %s:%d",
		    want_cert ? "CA key" : "key", host_file, host_line);
d807 1
a807 1
			if (show_other_keys(host, host_key))
d848 1
a848 2
			snprintf(hostline, sizeof(hostline), "%s,%s",
			    host, ip);
d902 2
a903 2
			    "match %s in %s:%d", CA_MARKER,
			    host_file, host_line);
d925 2
a926 1
				error("Offending key for IP in %s:%d", ip_file, ip_line);
d932 2
a933 1
		error("Offending key in %s:%d", host_file, host_line);
d1018 2
a1019 2
		    "\nOffending key for IP in %s:%d",
		    type, host, ip, ip_file, ip_line);
d1023 2
a1024 2
			    "\nMatching host key in %s:%d",
			    host_file, host_line);
d1042 4
d1065 4
d1078 5
d1126 1
a1126 1
    struct sockaddr *hostaddr, struct passwd *pw, int timeout_ms)
d1149 1
a1149 1
		ssh_kex2(host, hostaddr);
a1175 24
static int
show_key_from_file(const char *file, const char *host, int keytype)
{
	Key *found;
	char *fp, *ra;
	int line, ret;

	found = key_new(keytype);
	if ((ret = lookup_key_in_hostfile_by_type(file, host,
	    keytype, found, &line))) {
		fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
		ra = key_fingerprint(found, SSH_FP_MD5, SSH_FP_RANDOMART);
		logit("WARNING: %s key found for host %s\n"
		    "in %s:%d\n"
		    "%s key fingerprint %s.\n%s\n",
		    key_type(found), host, file, line,
		    key_type(found), fp, ra);
		xfree(ra);
		xfree(fp);
	}
	key_free(found);
	return (ret);
}

d1178 1
a1178 1
show_other_keys(const char *host, Key *key)
d1181 3
a1183 1
	int i, found = 0;
d1188 1
a1188 3
		if (type[i] != KEY_RSA1 &&
		    show_key_from_file(options.user_hostfile2, host, type[i])) {
			found = 1;
d1190 13
a1202 15
		}
		if (type[i] != KEY_RSA1 &&
		    show_key_from_file(options.system_hostfile2, host, type[i])) {
			found = 1;
			continue;
		}
		if (show_key_from_file(options.user_hostfile, host, type[i])) {
			found = 1;
			continue;
		}
		if (show_key_from_file(options.system_hostfile, host, type[i])) {
			found = 1;
			continue;
		}
		debug2("no key of type %d for host %s", type[i], host);
d1204 1
a1204 1
	return (found);
@


1.227
log
@kill proxy command on fatal() (we already kill it on clean exit);
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.226 2010/10/05 05:13:18 djm Exp $ */
d170 1
a170 1
		kill(SIGHUP, proxy_command_pid);
@


1.226
log
@use default shell /bin/sh if $SHELL is ""; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.225 2010/08/31 11:54:45 djm Exp $ */
d60 2
a66 1
extern pid_t proxy_command_pid;
d160 11
@


1.225
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.224 2010/04/16 21:14:27 djm Exp $ */
d81 1
a81 1
	if ((shell = getenv("SHELL")) == NULL)
d1227 1
a1227 1
	if ((shell = getenv("SHELL")) == NULL)
@


1.224
log
@oops, %r => remote username, not %u
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.223 2010/04/16 01:47:26 djm Exp $ */
d1163 1
a1163 1
	int type[] = { KEY_RSA1, KEY_RSA, KEY_DSA, -1};
@


1.223
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.222 2010/04/14 22:27:42 djm Exp $ */
d96 1
a96 1
	    "u", options.user, (char *)NULL);
@


1.222
log
@expand %r => remote username in ssh_config:ProxyCommand;
ok deraadt markus
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.221 2010/04/10 00:04:30 djm Exp $ */
d580 3
a582 3
	if (buffer_len(&host_key->cert->constraints) != 0) {
		error("Certificate for %s contains unsupported constraint(s)",
		    host);
@


1.221
log
@fix terminology: we didn't find a certificate in known_hosts, we found
a CA key
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.220 2010/03/04 10:36:03 djm Exp $ */
d95 2
a96 2
	command_string = percent_expand(tmp, "h", host,
	    "p", strport, (char *)NULL);
@


1.220
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.219 2010/02/26 20:29:54 djm Exp $ */
d729 1
a729 1
		    want_cert ? "certificate" : "key", host_file, host_line);
@


1.219
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.218 2010/01/13 00:19:04 dtucker Exp $ */
d849 19
d917 1
d1017 1
a1017 1
	if (want_cert) {
@


1.218
log
@Fix a couple of typos/mispellings in comments
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.217 2010/01/09 23:04:13 dtucker Exp $ */
d52 1
d571 17
d600 2
a601 2
	Key *file_key;
	const char *type = key_type(host_key);
d606 1
a606 1
	int r, local = 0, host_ip_differ = 0;
d675 4
d683 1
a683 1
	file_key = key_new(host_key->type);
d699 2
a700 1
	 * localhost or the hostname was an ip address to begin with
d702 1
a702 1
	if (options.check_host_ip) {
d726 6
a731 3
		debug("Host '%.200s' is known and matches the %s host key.",
		    host, type);
		debug("Found key in %s:%d", host_file, host_line);
d733 1
a733 1
			if (readonly)
d765 1
a765 1
		if (readonly)
d850 11
d997 14
d1023 2
a1024 1
	if (options.verify_host_key_dns &&
@


1.217
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.214 2009/05/28 16:50:16 andreas Exp $ */
d919 1
a919 1
		 * by that sentence, and ask the user if he/she whishes to
@


1.216
log
@Set close-on-exec on various descriptors so they don't get leaked to
child processes.  bz #1643, patch from jchadima at redhat, ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.215 2009/10/28 16:38:18 reyk Exp $ */
d185 1
a185 2
	sock = socket_rdomain(ai->ai_family, ai->ai_socktype, ai->ai_protocol,
	    options.rdomain);
@


1.215
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.214 2009/05/28 16:50:16 andreas Exp $ */
d26 1
d187 1
a187 1
	if (sock < 0)
d189 3
@


1.214
log
@Keep track of number of bytes read and written. Needed for upcoming
changes. Most code from Martin Forssen, maf at appgate dot com.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.213 2009/05/27 06:38:16 andreas Exp $ */
d184 2
a185 1
	sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
@


1.213
log
@Un-static ssh_exchange_identification(), part of a larger change from
Martin Forssen and needed for upcoming changes.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.212 2008/10/14 18:11:33 stevesk Exp $ */
d50 1
d447 1
a447 1
			len = atomicio(read, connection_in, &buf[i], 1);
d532 2
a533 1
	if (atomicio(vwrite, connection_out, buf, strlen(buf)) != strlen(buf))
@


1.212
log
@use #define ROQUIET here; no binary change. ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.211 2008/07/01 07:24:22 dtucker Exp $ */
d407 1
a407 1
static void
@


1.211
log
@Send CR LF during protocol banner exchanges, but only for Protocol 2 only,
in order to comply with RFC 4253.  bz #1443, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.210 2008/07/01 07:20:52 dtucker Exp $ */
d727 2
a728 2
			if (check_host_key(hostname, hostaddr, 0, host_key, 2,
			    user_hostfile, system_hostfile) == 0) {
@


1.210
log
@Check ExitOnForwardFailure if forwardings are disabled due to a failed
host key check.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.209 2008/06/26 11:46:31 grunk Exp $ */
d527 1
a527 1
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s\n",
d530 1
a530 1
	    SSH_VERSION);
@


1.209
log
@Move SSH Fingerprint Visualization away from sharing the config option
CheckHostIP to an own config option named VisualHostKey.
While there, fix the behaviour that ssh would draw a random art picture
on every newly seen host even when the option was not enabled.

prodded by deraadt@@, discussions,
help and ok markus@@ djm@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.208 2008/06/12 23:24:58 ian Exp $ */
d585 1
a585 1
	int len, host_line, ip_line;
d864 1
d871 1
d877 1
d883 1
d889 1
d897 1
d903 1
d905 4
@


1.208
log
@tweak wording in message, ok deraadt@@ jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.207 2008/06/12 20:38:28 dtucker Exp $ */
a586 1
	int display_randomart;
a630 6
	 * check_host_ip may be set to zero in the next step, so if it
	 * conveys a request to display the random art, save it away.
	 */
	display_randomart = (options.check_host_ip == SSHCTL_CHECKHOSTIP_FPR);

	/*
d714 1
a714 1
		} else if (display_randomart) {
d772 1
a772 1
			    "%s key fingerprint is %s.\n%s\n%s"
d775 4
a778 1
			    host, ip, msg1, type, fp, ra, msg2);
@


1.207
log
@Make keepalive timeouts apply while waiting for a packet, particularly during
key renegotiation (bz #1363).  With djm and Matt Day, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.206 2008/06/12 00:13:55 grunk Exp $ */
d836 1
a836 1
			error("and the key for the according IP address %s", ip);
@


1.206
log
@Make ssh print the random art also when ssh'ing to a host using IP only.
spotted by naddy@@, ok and help djm@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.205 2008/06/12 00:03:49 dtucker Exp $ */
a66 17
static void
ms_subtract_diff(struct timeval *start, int *ms)
{
	struct timeval diff, finish;

	gettimeofday(&finish, NULL);
	timersub(&finish, start, &diff);	
	*ms -= (diff.tv_sec * 1000) + (diff.tv_usec / 1000);
}

static void
ms_to_timeval(struct timeval *tv, int ms)
{
	tv->tv_sec = ms / 1000;
	tv->tv_usec = (ms % 1000) * 1000;
}

d151 2
d397 2
@


1.205
log
@Do not pass "0" strings as ports to getaddrinfo because the lookups
can slow things down and we never use the service info anyway. bz
#859, patch from YOSHIFUJI Hideaki and John Devitofranceschi.  ok
deraadt@@ djm@@

djm belives that the reason for the "0" strings is to ensure that
it's not possible to call getaddrinfo with both host and port being
NULL.  In the case of canohost.c host is a local array.  In the
case of sshconnect.c, it's checked for null immediately before use.

In dns.c it ultimately comes from ssh.c:main() and is guaranteed to
be non-null but it's not obvious, so I added a warning message in
case it is ever passed a null.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.204 2008/06/11 21:01:35 grunk Exp $ */
d600 1
d643 7
d734 1
a734 1
		} else if (options.check_host_ip == SSHCTL_CHECKHOSTIP_FPR) {
@


1.204
log
@Introduce SSH Fingerprint ASCII Visualization, a technique inspired by the
graphical hash visualization schemes known as "random art", and by
Dan Kaminsky's musings on the subject during a BlackOp talk at the
23C3 in Berlin.

Scientific publication (original paper):
"Hash Visualization: a New Technique to improve Real-World Security",
Perrig A. and Song D., 1999, International Workshop on Cryptographic
Techniques and E-Commerce (CrypTEC '99)
http://sparrow.ece.cmu.edu/~adrian/projects/validation/validation.pdf

The algorithm used here is a worm crawling over a discrete plane,
leaving a trace (augmenting the field) everywhere it goes.
Movement is taken from dgst_raw 2bit-wise.  Bumping into walls
makes the respective movement vector be ignored for this turn,
thus switching to the other color of the chessboard.
Graphs are not unambiguous for now, because circles in graphs can be
walked in either direction.

discussions with several people,
help, corrections and ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.203 2007/12/27 14:22:08 dtucker Exp $ */
d211 1
a211 1
	gaierr = getaddrinfo(options.bind_address, "0", &hints, &res);
@


1.203
log
@Add a small helper function to consistently handle the EAI_SYSTEM error
code of getaddrinfo.  Prompted by vgiffin at apple com via bz #1417.
ok markus@@ stevesk@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.202 2007/09/04 11:15:55 djm Exp $ */
d592 1
a592 1
	char hostline[1000], *hostp, *fp;
d726 7
d768 2
d784 1
a784 1
			    "%s key fingerprint is %s.\n%s"
d787 2
a788 1
			    host, ip, msg1, type, fp, msg2);
d1059 1
a1059 1
	char *fp;
d1066 1
d1069 1
a1069 1
		    "%s key fingerprint %s.",
d1071 2
a1072 1
		    key_type(found), fp);
@


1.202
log
@make ssh(1)'s ConnectTimeout option apply to both the TCP connection and
SSH banner exchange (previously it just covered the TCP connection).
This allows callers of ssh(1) to better detect and deal with stuck servers
that accept a TCP connection but don't progress the protocol, and also makes
ConnectTimeout useful for connections via a ProxyCommand;
feedback and "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.201 2007/08/23 03:23:26 djm Exp $ */
d214 1
a214 1
		    gai_strerror(gaierr));
d346 2
a347 2
		fatal("%s: %.100s: %s", __progname, host,
		    gai_strerror(gaierr));
@


1.201
log
@Execute ProxyCommands with $SHELL rather than /bin/sh unconditionally
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.200 2006/10/10 10:12:45 markus Exp $ */
d67 17
d230 1
a230 1
    socklen_t addrlen, int timeout)
d233 1
a233 1
	struct timeval tv;
d237 6
a242 2
	if (timeout <= 0)
		return (connect(sockfd, serv_addr, addrlen));
d248 6
a253 1
		return (0);
a254 2
	if (errno != EINPROGRESS)
		return (-1);
d259 1
a259 2
	tv.tv_sec = timeout;
	tv.tv_usec = 0;
d298 10
d324 2
a325 2
    u_short port, int family, int connection_attempts,
    int needpriv, const char *proxy_command)
d378 1
a378 1
			    options.connection_timeout) >= 0) {
d405 1
a405 1
	if (options.tcp_keep_alive &&
d421 1
a421 1
ssh_exchange_identification(void)
d429 7
d438 1
d441 19
a459 1
			size_t len = atomicio(read, connection_in, &buf[i], 1);
d462 2
a463 1
				fatal("ssh_exchange_identification: Connection closed by remote host");
d465 2
a466 1
				fatal("ssh_exchange_identification: read: %.100s", strerror(errno));
d477 2
a478 1
				fatal("ssh_exchange_identification: No banner received");
d486 1
d995 1
a995 1
    struct sockaddr *hostaddr, struct passwd *pw)
d1010 1
a1010 1
	ssh_exchange_identification();
@


1.200
log
@sleep before retrying (not after) since sleep changes errno; fixes
pr 5250; rad@@twig.com; ok dtucker djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.199 2006/08/03 03:34:42 deraadt Exp $ */
d76 4
a79 1
	char strport[NI_MAXSERV];
d125 1
a125 1
		argv[0] = _PATH_BSHELL;
@


1.199
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.198 2006/08/01 23:22:47 stevesk Exp $ */
d314 3
a316 1
		if (attempt > 0)
d318 1
a318 1

a354 3

		/* Sleep a moment before retrying. */
		sleep(1);
@


1.199.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.200 2006/10/10 10:12:45 markus Exp $ */
d314 1
a314 3
		if (attempt > 0) {
			/* Sleep a moment before retrying. */
			sleep(1);
d316 1
a316 1
		}
d353 3
@


1.198
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.197 2006/08/01 11:34:36 dtucker Exp $ */
a15 2
#include "includes.h"

d28 1
d35 1
a36 1
#include "xmalloc.h"
@


1.197
log
@Allow fallback to known_hosts entries without port qualifiers for
non-standard ports too, so that all existing known_hosts entries will be
recognised.  Requested by, feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.196 2006/07/26 13:57:17 stevesk Exp $ */
d31 1
@


1.196
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.195 2006/07/25 02:59:21 stevesk Exp $ */
d516 3
d520 3
a522 2
check_host_key(char *hostname, struct sockaddr *hostaddr, Key *host_key,
    int readonly, const char *user_hostfile, const char *system_hostfile)
d573 1
a573 1
		ip = put_host_port(ntop, options.port);
d595 1
a595 1
		host = put_host_port(hostname, options.port);
d664 9
d752 2
d912 3
a914 2
		if (check_host_key(host, hostaddr, host_key, /*readonly*/ 1,
		    options.user_hostfile2, options.system_hostfile2) == 0)
d917 2
a918 2
	return check_host_key(host, hostaddr, host_key, /*readonly*/ 0,
	    options.user_hostfile, options.system_hostfile);
@


1.195
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.194 2006/07/24 13:58:22 stevesk Exp $ */
d31 1
@


1.194
log
@disable tunnel forwarding when no strict host key checking
and key changed; ok djm@@ markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.193 2006/07/22 20:48:23 stevesk Exp $ */
d22 1
@


1.193
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.192 2006/07/17 01:31:10 stevesk Exp $ */
d775 1
a775 1
		 * agent forwarding.
d809 5
@


1.192
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.191 2006/07/12 22:28:52 stevesk Exp $ */
d30 1
@


1.191
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.190 2006/07/11 20:07:25 stevesk Exp $ */
d30 1
@


1.190
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.189 2006/07/10 12:46:51 dtucker Exp $ */
d27 1
@


1.189
log
@Add port identifier to known_hosts for non-default ports, based originally
on a patch from Devin Nate in bz#910.

For any connection using the default port or using a HostKeyAlias the
format is unchanged, otherwise the host name or address is enclosed
within square brackets in the same format as sshd's ListenAddress.

Tested by many, ok markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.188 2006/07/06 16:03:53 stevesk Exp $ */
d26 1
@


1.188
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.187 2006/07/05 02:42:09 stevesk Exp $ */
d511 1
a511 1
check_host_key(char *host, struct sockaddr *hostaddr, Key *host_key,
d516 1
a516 1
	char *ip = NULL;
d563 1
a563 1
		ip = xstrdup(ntop);
d571 2
a572 2
	if (options.check_host_ip &&
	    (local || strcmp(host, ip) == 0 || options.proxy_command != NULL))
d576 4
a579 3
	 * Allow the user to record the key under a different name. This is
	 * useful for ssh tunneling over forwarded connections or if you run
	 * multiple sshd's on different ports on the same machine.
d582 1
a582 1
		host = options.host_key_alias;
d584 2
d847 1
d852 1
@


1.187
log
@move #include <netinet/in.h> out of includes.h; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.186 2006/07/03 08:54:20 stevesk Exp $ */
d27 1
@


1.186
log
@move #include "version.h" out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.185 2006/06/14 10:50:42 djm Exp $ */
d21 3
@


1.185
log
@limit the number of pre-banner characters we will accept; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.184 2006/06/08 14:45:49 markus Exp $ */
d40 1
@


1.184
log
@do not set the gid, noted by solar; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.183 2006/06/06 10:20:20 markus Exp $ */
d382 1
a382 1
	u_int i;
d385 1
a385 1
	for (;;) {
d402 2
@


1.183
log
@replace remaining setuid() calls with permanently_set_uid() and
check seteuid() return values; report Marcus Meissner; ok dtucker djm
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.182 2006/05/17 12:43:34 markus Exp $ */
d94 1
a94 1
		permanently_set_uid(getpwuid(original_real_uid));
@


1.182
log
@fix leak; coverity via Kylene Jo Hall
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.181 2006/04/20 09:47:59 markus Exp $ */
d94 1
a94 2
		seteuid(original_real_uid);
		setuid(original_real_uid);
@


1.181
log
@simplify; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.180 2006/03/25 13:17:02 djm Exp $ */
d921 1
@


1.180
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d303 1
a303 6
	/*
	 * Try to connect several times.  On some machines, the first time
	 * will sometimes fail.  In general socket code appears to behave
	 * quite magically on many machines.
		 */
	for (attempt = 0; ;) {
d307 4
a310 2
		/* Loop through addresses for this host, and try each one in
		   sequence until the connection succeeds. */
a336 6
				/*
				 * Close the failed socket; there appear to
				 * be some problems when reusing a socket for
				 * which connect() has already returned an
				 * error.
				 */
d338 1
d341 1
a341 1
		if (ai)
a343 3
		attempt++;
		if (attempt >= connection_attempts)
			break;
d351 1
a351 1
	if (attempt >= connection_attempts) {
@


1.179
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.178
log
@be strict with tolower() casting
@
text
@a64 1
	size_t len;
d76 1
a76 4
	len = strlen(proxy_command) + 6;
	tmp = xmalloc(len);
	strlcpy(tmp, "exec ", len);
	strlcat(tmp, proxy_command, len);
d204 1
a204 1
	int fdsetsz, optval, rc, result = -1;
d218 2
a219 4
	fdsetsz = howmany(sockfd + 1, NFDBITS) * sizeof(fd_mask);
	fdset = (fd_set *)xmalloc(fdsetsz);

	memset(fdset, 0, fdsetsz);
d944 1
a944 2
	padded = xmalloc(size);
	memset(padded, 0, size);
@


1.177
log
@RCSID() can die
@
text
@d920 1
a920 1
			*cp = tolower(*cp);
@


1.176
log
@move #include <ctype.h> out of includes.h; ok djm@@
@
text
@a15 1
RCSID("$OpenBSD: sshconnect.c,v 1.175 2006/02/20 17:19:54 stevesk Exp $");
@


1.176.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sshconnect.c,v 1.199 2006/08/03 03:34:42 deraadt Exp $ */
d15 3
a20 4
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>
a22 2
#include <errno.h>
#include <netdb.h>
a23 6
#include <signal.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d25 1
a26 1
#include "ssh.h"
a39 1
#include "version.h"
d66 1
d78 4
a81 1
	xasprintf(&tmp, "exec %s", proxy_command);
d98 2
a99 1
		permanently_drop_suid(original_real_uid);
d209 1
a209 1
	int optval, rc, result = -1;
d223 4
a226 2
	fdset = (fd_set *)xcalloc(howmany(sockfd + 1, NFDBITS),
	    sizeof(fd_mask));
d309 6
a314 1
	for (attempt = 0; attempt < connection_attempts; attempt++) {
d318 2
a319 4
		/*
		 * Loop through addresses for this host, and try each one in
		 * sequence until the connection succeeds.
		 */
d346 6
a352 1
				sock = -1;
d355 1
a355 1
		if (sock != -1)
d358 3
d368 1
a368 1
	if (sock == -1) {
d400 1
a400 1
	u_int i, n;
d403 1
a403 1
	for (n = 0;;) {
a419 2
			if (++n > 65536)
				fatal("ssh_exchange_identification: No banner received");
a520 3
#define RDRW	0
#define RDONLY	1
#define ROQUIET	2
d522 2
a523 3
check_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,
    Key *host_key, int readonly, const char *user_hostfile,
    const char *system_hostfile)
d527 1
a527 1
	char *ip = NULL, *host = NULL;
d574 1
a574 1
		ip = put_host_port(ntop, port);
d582 2
a583 2
	if (options.check_host_ip && (local ||
	    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))
d587 3
a589 4
	 * Allow the user to record the key under a different name or
	 * differentiate a non-standard port.  This is useful for ssh
	 * tunneling over forwarded connections or if you run multiple
	 * sshd's on different ports on the same machine.
d592 1
a592 1
		host = xstrdup(options.host_key_alias);
a593 2
	} else {
		host = put_host_port(hostname, port);
a661 9
		if (options.host_key_alias == NULL && port != 0 &&
		    port != SSH_DEFAULT_PORT) {
			debug("checking without port identifier");
			if (check_host_key(hostname, hostaddr, 0, host_key, 2,
			    user_hostfile, system_hostfile) == 0) {
				debug("found matching key w/out port");
				break;
			}
		}
a740 2
		if (readonly == ROQUIET)
			goto fail;
d779 1
a779 1
		 * forwarding.
a813 5
		if (options.tun_open != SSH_TUNMODE_NO) {
			error("Tunnel forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.tun_open = SSH_TUNMODE_NO;
		}
a854 1
	xfree(host);
a858 1
	xfree(host);
d892 2
a893 3
		if (check_host_key(host, hostaddr, options.port, host_key,
		    RDONLY, options.user_hostfile2,
		    options.system_hostfile2) == 0)
d896 2
a897 2
	return check_host_key(host, hostaddr, options.port, host_key,
	    RDRW, options.user_hostfile, options.system_hostfile);
d921 1
a921 1
			*cp = (char)tolower(*cp);
a937 1
	xfree(local_user);
d951 2
a952 1
	padded = xcalloc(1, size);
@


1.176.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.200 2006/10/10 10:12:45 markus Exp $ */
d314 1
a314 3
		if (attempt > 0) {
			/* Sleep a moment before retrying. */
			sleep(1);
d316 1
a316 1
		}
d353 3
@


1.175
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.174 2006/02/10 01:44:27 stevesk Exp $");
d22 1
@


1.174
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.173 2006/02/08 14:16:59 stevesk Exp $");
d20 1
@


1.173
log
@<openssl/bn.h> not needed
@
text
@d16 4
a19 1
RCSID("$OpenBSD: sshconnect.c,v 1.172 2006/02/08 12:15:27 stevesk Exp $");
@


1.172
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.171 2005/12/06 22:38:27 reyk Exp $");
a18 2

#include <openssl/bn.h>
@


1.171
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d16 3
a18 1
RCSID("$OpenBSD: sshconnect.c,v 1.170 2005/10/30 08:52:18 djm Exp $");
@


1.170
log
@no need to escape single quotes in comments, no binary change
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.169 2005/10/15 15:28:12 stevesk Exp $");
d1028 36
@


1.169
log
@make external definition static; ok deraadt@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.168 2005/07/17 07:17:55 djm Exp $");
d598 1
a598 1
	 * Check if the host key is present in the user\'s list of known
@


1.168
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.167 2005/07/16 01:35:24 djm Exp $");
a33 1

d39 1
a39 1
int matching_host_key_dns = 0;
@


1.168.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.171 2005/12/06 22:38:27 reyk Exp $");
d34 1
d40 1
a40 1
static int matching_host_key_dns = 0;
d599 1
a599 1
	 * Check if the host key is present in the user's list of known
a1028 36
}

/*
 * Execute a local command
 */
int
ssh_local_cmd(const char *args)
{
	char *shell;
	pid_t pid;
	int status;

	if (!options.permit_local_command ||
	    args == NULL || !*args)
		return (1);

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	pid = fork();
	if (pid == 0) {
		debug3("Executing %s -c \"%s\"", shell, args);
		execl(shell, shell, "-c", args, (char *)NULL);
		error("Couldn't execute %s -c \"%s\": %s",
		    shell, args, strerror(errno));
		_exit(1);
	} else if (pid == -1)
		fatal("fork failed: %.100s", strerror(errno));
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));

	if (!WIFEXITED(status))
		return (1);

	return (WEXITSTATUS(status));
@


1.168.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sshconnect.c,v 1.199 2006/08/03 03:34:42 deraadt Exp $ */
d15 2
a16 18
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <paths.h>
#include <signal.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d18 3
a21 1
#include "ssh.h"
a34 1
#include "version.h"
d61 1
d73 4
a76 1
	xasprintf(&tmp, "exec %s", proxy_command);
d93 2
a94 1
		permanently_drop_suid(original_real_uid);
d204 1
a204 1
	int optval, rc, result = -1;
d218 4
a221 2
	fdset = (fd_set *)xcalloc(howmany(sockfd + 1, NFDBITS),
	    sizeof(fd_mask));
d304 6
a309 1
	for (attempt = 0; attempt < connection_attempts; attempt++) {
d313 2
a314 4
		/*
		 * Loop through addresses for this host, and try each one in
		 * sequence until the connection succeeds.
		 */
d341 6
a347 1
				sock = -1;
d350 1
a350 1
		if (sock != -1)
d353 3
d363 1
a363 1
	if (sock == -1) {
d395 1
a395 1
	u_int i, n;
d398 1
a398 1
	for (n = 0;;) {
a414 2
			if (++n > 65536)
				fatal("ssh_exchange_identification: No banner received");
a515 3
#define RDRW	0
#define RDONLY	1
#define ROQUIET	2
d517 2
a518 3
check_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,
    Key *host_key, int readonly, const char *user_hostfile,
    const char *system_hostfile)
d522 1
a522 1
	char *ip = NULL, *host = NULL;
d569 1
a569 1
		ip = put_host_port(ntop, port);
d577 2
a578 2
	if (options.check_host_ip && (local ||
	    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))
d582 3
a584 4
	 * Allow the user to record the key under a different name or
	 * differentiate a non-standard port.  This is useful for ssh
	 * tunneling over forwarded connections or if you run multiple
	 * sshd's on different ports on the same machine.
d587 1
a587 1
		host = xstrdup(options.host_key_alias);
a588 2
	} else {
		host = put_host_port(hostname, port);
a656 9
		if (options.host_key_alias == NULL && port != 0 &&
		    port != SSH_DEFAULT_PORT) {
			debug("checking without port identifier");
			if (check_host_key(hostname, hostaddr, 0, host_key, 2,
			    user_hostfile, system_hostfile) == 0) {
				debug("found matching key w/out port");
				break;
			}
		}
a735 2
		if (readonly == ROQUIET)
			goto fail;
d774 1
a774 1
		 * forwarding.
a808 5
		if (options.tun_open != SSH_TUNMODE_NO) {
			error("Tunnel forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.tun_open = SSH_TUNMODE_NO;
		}
a849 1
	xfree(host);
a853 1
	xfree(host);
d887 2
a888 3
		if (check_host_key(host, hostaddr, options.port, host_key,
		    RDONLY, options.user_hostfile2,
		    options.system_hostfile2) == 0)
d891 2
a892 2
	return check_host_key(host, hostaddr, options.port, host_key,
	    RDRW, options.user_hostfile, options.system_hostfile);
d916 1
a916 1
			*cp = (char)tolower(*cp);
a932 1
	xfree(local_user);
d946 2
a947 1
	padded = xcalloc(1, size);
@


1.168.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.200 2006/10/10 10:12:45 markus Exp $ */
d314 1
a314 3
		if (attempt > 0) {
			/* Sleep a moment before retrying. */
			sleep(1);
d316 1
a316 1
		}
d353 3
@


1.167
log
@spacing
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.166 2005/06/17 22:53:47 djm Exp $");
d545 1
a545 1
		   sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d675 2
a676 2
				   "\nbut keys of different type are already"
				   " known for this host.");
@


1.166
log
@Fix ControlPath's %p expanding to "0" for a default port,
spotted dwmw2 AT infradead.org; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.165 2005/06/17 02:44:33 djm Exp $");
d403 1
a403 1
			if (len != 1 && errno == EPIPE) 
@


1.165
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.164 2005/06/06 11:20:36 djm Exp $");
a287 1
	struct servent *sp;
a290 8
	/* Get default port if port has not been set. */
	if (port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		if (sp)
			port = ntohs(sp->s_port);
		else
			port = SSH_DEFAULT_PORT;
	}
@


1.164
log
@introduce a generic %foo expansion function. replace existing % expansion and
add expansion to ControlPath; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.163 2005/05/24 17:32:44 avsm Exp $");
d401 1
a401 1
	int remote_major, remote_minor, i, mismatch;
d405 1
@


1.163
log
@Switch atomicio to use a simpler interface; it now returns a size_t
(containing number of bytes read/written), and indicates error by
returning 0.  EOF is signalled by errno==EPIPE.
Typical use now becomes:

if (atomicio(read, ..., len) != len)
        err(1,"read");

ok deraadt@@, cloder@@, djm@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.162 2005/03/10 22:01:06 deraadt Exp $");
d58 1
a58 3
	Buffer command;
	const char *cp;
	char *command_string;
d62 1
d74 7
a80 25
	buffer_init(&command);
	buffer_append(&command, "exec ", 5);

	for (cp = proxy_command; *cp; cp++) {
		if (cp[0] == '%' && cp[1] == '%') {
			buffer_append(&command, "%", 1);
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'h') {
			buffer_append(&command, host, strlen(host));
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'p') {
			buffer_append(&command, strport, strlen(strport));
			cp++;
			continue;
		}
		buffer_append(&command, cp, 1);
	}
	buffer_append(&command, "\0", 1);

	/* Get the final command string. */
	command_string = buffer_ptr(&command);
d134 1
a134 1
	buffer_free(&command);
@


1.162
log
@spacing
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.161 2005/03/02 01:00:06 djm Exp $");
d425 1
a425 1
	/* Read other side\'s version identification. */
d428 5
a432 2
			int len = atomicio(read, connection_in, &buf[i], 1);
			if (len < 0)
a433 2
			if (len != 1)
				fatal("ssh_exchange_identification: Connection closed by remote host");
@


1.162.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.168 2005/07/17 07:17:55 djm Exp $");
d58 3
a60 1
	char *command_string, *tmp;
a63 1
	size_t len;
d75 25
a99 7
	len = strlen(proxy_command) + 6;
	tmp = xmalloc(len);
	strlcpy(tmp, "exec ", len);
	strlcat(tmp, proxy_command, len);
	command_string = percent_expand(tmp, "h", host,
	    "p", strport, (char *)NULL);
	xfree(tmp);
d153 1
a153 1
	xfree(command_string);
d307 1
d311 8
d420 1
a420 1
	int remote_major, remote_minor, mismatch;
a423 1
	u_int i;
d425 1
a425 1
	/* Read other side's version identification. */
d428 4
a431 3
			size_t len = atomicio(read, connection_in, &buf[i], 1);

			if (len != 1 && errno == EPIPE)
a432 2
			else if (len != 1)
				fatal("ssh_exchange_identification: read: %.100s", strerror(errno));
d571 1
a571 1
		    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d701 2
a702 2
				    "\nbut keys of different type are already"
				    " known for this host.");
@


1.162.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.171 2005/12/06 22:38:27 reyk Exp $");
d34 1
d40 1
a40 1
static int matching_host_key_dns = 0;
d599 1
a599 1
	 * Check if the host key is present in the user's list of known
a1028 36
}

/*
 * Execute a local command
 */
int
ssh_local_cmd(const char *args)
{
	char *shell;
	pid_t pid;
	int status;

	if (!options.permit_local_command ||
	    args == NULL || !*args)
		return (1);

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	pid = fork();
	if (pid == 0) {
		debug3("Executing %s -c \"%s\"", shell, args);
		execl(shell, shell, "-c", args, (char *)NULL);
		error("Couldn't execute %s -c \"%s\": %s",
		    shell, args, strerror(errno));
		_exit(1);
	} else if (pid == -1)
		fatal("fork failed: %.100s", strerror(errno));
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));

	if (!WIFEXITED(status))
		return (1);

	return (WEXITSTATUS(status));
@


1.161
log
@fix addition of new hashed hostnames when CheckHostIP=yes;
found and ok dtucker@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.160 2005/03/01 10:40:27 djm Exp $");
d246 1
a246 1
	for(;;) {
d252 1
a252 1
	switch(rc) {
@


1.160
log
@add support for hashing host names and addresses added to known_hosts files,
to improve privacy of which hosts user have been visiting; ok markus@@ deraadt@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.159 2005/01/05 08:51:32 markus Exp $");
d553 1
a553 1
	int local = 0, host_ip_differ = 0;
d729 4
d734 2
a735 1
			snprintf(hostline, sizeof(hostline), "%s,%s", host, ip);
d737 15
a751 1
		} else
d753 1
d755 1
a755 6
		/*
		 * If not in strict mode, add the key automatically to the
		 * local known_hosts file.
		 */
		if (!add_host_to_hostfile(user_hostfile, hostp, host_key,
		    options.hash_known_hosts))
@


1.159
log
@remove dead code, log connect() failures with level error, ok djm@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.158 2004/06/21 17:36:31 avsm Exp $");
d673 1
a673 1
			    host_key))
d739 2
a740 1
		if (!add_host_to_hostfile(user_hostfile, hostp, host_key))
@


1.158
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.157 2004/05/08 00:21:31 djm Exp $");
a295 6
 * Return values:
 *    0 for OK
 *    ECONNREFUSED if we got a "Connection Refused" by the peer on any address
 *    ECONNABORTED if we failed without a "Connection refused"
 * Suitable error messages for the connection failure will already have been
 * printed.
a307 6
	/*
	 * Did we get only other errors than "Connection refused" (which
	 * should block fallback to rsh and similar), or did we get at least
	 * one "Connection refused"?
	 */
	int full_failure = 1;
a367 2
				if (errno == ECONNREFUSED)
					full_failure = 0;
d393 1
a393 1
		logit("ssh: connect to host %s port %s: %s",
d395 1
a395 1
		return full_failure ? ECONNABORTED : ECONNREFUSED;
@


1.158.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.161 2005/03/02 01:00:06 djm Exp $");
d296 6
d314 6
d380 2
d407 1
a407 1
		error("ssh: connect to host %s port %s: %s",
d409 1
a409 1
		return (-1);
d567 1
a567 1
	int r, local = 0, host_ip_differ = 0;
d687 1
a687 1
			    host_key, options.hash_known_hosts))
d743 6
d753 1
a753 23
		if (options.check_host_ip && ip_status == HOST_NEW) {
			snprintf(hostline, sizeof(hostline), "%s,%s",
			    host, ip);
			hostp = hostline;
			if (options.hash_known_hosts) {
				/* Add hash of host and IP separately */
				r = add_host_to_hostfile(user_hostfile, host,
				    host_key, options.hash_known_hosts) &&
				    add_host_to_hostfile(user_hostfile, ip,
				    host_key, options.hash_known_hosts);
			} else {
				/* Add unhashed "host,ip" */
				r = add_host_to_hostfile(user_hostfile,
				    hostline, host_key,
				    options.hash_known_hosts);
			}
		} else {
			r = add_host_to_hostfile(user_hostfile, host, host_key,
			    options.hash_known_hosts);
			hostp = host;
		}

		if (!r)
@


1.158.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.162 2005/03/10 22:01:06 deraadt Exp $");
d246 1
a246 1
	for (;;) {
d252 1
a252 1
	switch (rc) {
@


1.158.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.168 2005/07/17 07:17:55 djm Exp $");
d58 3
a60 1
	char *command_string, *tmp;
a63 1
	size_t len;
d75 25
a99 7
	len = strlen(proxy_command) + 6;
	tmp = xmalloc(len);
	strlcpy(tmp, "exec ", len);
	strlcat(tmp, proxy_command, len);
	command_string = percent_expand(tmp, "h", host,
	    "p", strport, (char *)NULL);
	xfree(tmp);
d153 1
a153 1
	xfree(command_string);
d307 1
d311 8
d420 1
a420 1
	int remote_major, remote_minor, mismatch;
a423 1
	u_int i;
d425 1
a425 1
	/* Read other side's version identification. */
d428 4
a431 3
			size_t len = atomicio(read, connection_in, &buf[i], 1);

			if (len != 1 && errno == EPIPE)
a432 2
			else if (len != 1)
				fatal("ssh_exchange_identification: read: %.100s", strerror(errno));
d571 1
a571 1
		    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d701 2
a702 2
				    "\nbut keys of different type are already"
				    " known for this host.");
@


1.157
log
@kill a tiny header; ok deraadt@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.156 2004/01/25 03:49:09 djm Exp $");
d762 1
a762 1
			char *msg;
d764 1
a764 1
				msg = "is unknown";
d766 1
a766 1
				msg = "is unchanged";
d768 1
a768 1
				msg = "has a different value";
d774 1
a774 1
			error("%s. This could either mean that", msg);
@


1.156
log
@reset nonblocking flag after ConnectTimeout > 0 connect; (bugzilla #785)
from jclonguet AT free.fr; ok millert@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.155 2003/12/09 21:53:37 markus Exp $");
a33 1
#include "readpass.h"
@


1.156.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.158 2004/06/21 17:36:31 avsm Exp $");
d34 1
d763 1
a763 1
			char *key_msg;
d765 1
a765 1
				key_msg = "is unknown";
d767 1
a767 1
				key_msg = "is unchanged";
d769 1
a769 1
				key_msg = "has a different value";
d775 1
a775 1
			error("%s. This could either mean that", key_msg);
@


1.156.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.161 2005/03/02 01:00:06 djm Exp $");
d296 6
d314 6
d380 2
d407 1
a407 1
		error("ssh: connect to host %s port %s: %s",
d409 1
a409 1
		return (-1);
d567 1
a567 1
	int r, local = 0, host_ip_differ = 0;
d687 1
a687 1
			    host_key, options.hash_known_hosts))
d743 6
d753 1
a753 23
		if (options.check_host_ip && ip_status == HOST_NEW) {
			snprintf(hostline, sizeof(hostline), "%s,%s",
			    host, ip);
			hostp = hostline;
			if (options.hash_known_hosts) {
				/* Add hash of host and IP separately */
				r = add_host_to_hostfile(user_hostfile, host,
				    host_key, options.hash_known_hosts) &&
				    add_host_to_hostfile(user_hostfile, ip,
				    host_key, options.hash_known_hosts);
			} else {
				/* Add unhashed "host,ip" */
				r = add_host_to_hostfile(user_hostfile,
				    hostline, host_key,
				    options.hash_known_hosts);
			}
		} else {
			r = add_host_to_hostfile(user_hostfile, host, host_key,
			    options.hash_known_hosts);
			hostp = host;
		}

		if (!r)
@


1.155
log
@rename keepalive to tcpkeepalive; the old name causes too much
confusion; ok djm, dtucker; with help from jmc@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.154 2003/11/21 11:57:03 djm Exp $");
d230 1
a230 3
	if (fcntl(sockfd, F_SETFL, O_NONBLOCK) < 0)
		return (-1);

d232 2
a233 1
	if (rc == 0)
d235 1
d276 1
@


1.154
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.153 2003/11/12 16:39:58 jakob Exp $");
d414 2
a415 2
	/* Set keepalives if requested. */
	if (options.keepalives &&
@


1.153
log
@update SSHFP validation. ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.152 2003/11/10 16:23:41 jakob Exp $");
d73 1
a73 1
	 * Use "exec" to avoid "sh -c" processes on some platforms 
d260 1
a260 1
	    	debug("select: %s", strerror(errno));
d266 1
a266 1
		if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval, 
d268 1
a268 1
		    	debug("getsockopt: %s", strerror(errno));
@


1.152
log
@constify. ok markus@@ & djm@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.151 2003/11/03 09:37:32 jakob Exp $");
d41 1
a41 1
int verified_host_key_dns = 0;
d723 1
a723 1
				if (verified_host_key_dns)
d887 1
d889 17
a905 16
	if (options.verify_host_key_dns) {
		switch(verify_host_key_dns(host, hostaddr, host_key)) {
		case DNS_VERIFY_OK:
#ifdef DNSSEC
			return 0;
#else
			verified_host_key_dns = 1;
			break;
#endif
		case DNS_VERIFY_FAILED:
			return -1;
		case DNS_VERIFY_ERROR:
			break;
		default:
			debug3("bad return value from verify_host_key_dns");
			break;
@


1.151
log
@do not free static type pointer in warn_changed_key()
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.150 2003/11/03 09:09:41 jakob Exp $");
d562 1
a562 1
	char *type = key_type(host_key);
@


1.150
log
@move changed key warning into warn_changed_key(). ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.149 2003/10/14 19:42:10 jakob Exp $");
d1036 1
a1036 1
	char *type = key_type(host_key);
a1050 1
	xfree(type);
@


1.149
log
@include SSHFP lookup code (not enabled by default). ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.148 2003/09/18 07:52:54 markus Exp $");
d51 1
d781 1
a781 10
		fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@");
		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
		error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
		error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
		error("It is also possible that the %s host key has just been changed.", type);
		error("The fingerprint for the %s key sent by the remote host is\n%s.",
		    type, fp);
		error("Please contact your system administrator.");
a784 1
		xfree(fp);
d1030 22
@


1.148
log
@missing {}; bug #656; jclonguet at free.fr
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.147 2003/06/29 12:44:38 markus Exp $");
a35 1
#ifdef DNS
a36 1
#endif
a40 1
#ifdef DNS
a41 1
#endif
a720 1
#ifdef DNS
a730 1
#endif
a896 1
#ifdef DNS
a914 1
#endif /* DNS */
@


1.147
log
@memset 0, not \0; andrushock@@korovino.net
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.146 2003/06/28 16:23:06 deraadt Exp $");
d270 1
a270 1
		    &optlen) == -1)
d273 1
@


1.147.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.156 2004/01/25 03:49:09 djm Exp $");
d36 1
d38 1
d43 3
a45 1
int matching_host_key_dns = 0;
a54 1
static void warn_changed_key(Key *);
d76 1
a76 1
	 * Use "exec" to avoid "sh -c" processes on some platforms
d233 3
a235 1
	set_nonblock(sockfd);
d237 1
a237 2
	if (rc == 0) {
		unset_nonblock(sockfd);
a238 1
	}
d263 1
a263 1
		debug("select: %s", strerror(errno));
d269 3
a271 3
		if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval,
		    &optlen) == -1) {
			debug("getsockopt: %s", strerror(errno));
a272 1
		}
a277 1
		unset_nonblock(sockfd);
d416 2
a417 2
	/* Set SO_KEEPALIVE if requested. */
	if (options.tcp_keep_alive &&
d564 1
a564 1
	const char *type = key_type(host_key);
d724 1
d726 1
a726 1
				if (matching_host_key_dns)
d735 1
d785 10
a794 1
		warn_changed_key(host_key);
d798 1
a900 1
	int flags = 0;
d902 17
a918 17
	if (options.verify_host_key_dns &&
	    verify_host_key_dns(host, hostaddr, host_key, &flags) == 0) {

		if (flags & DNS_VERIFY_FOUND) {

			if (options.verify_host_key_dns == 1 &&
			    flags & DNS_VERIFY_MATCH &&
			    flags & DNS_VERIFY_SECURE)
				return 0;

			if (flags & DNS_VERIFY_MATCH) {
				matching_host_key_dns = 1;
			} else {
				warn_changed_key(host_key);
				error("Update the SSHFP RR in DNS with the new "
				    "host key to get rid of this message.");
			}
d921 1
a1045 21
}

static void
warn_changed_key(Key *host_key)
{
	char *fp;
	const char *type = key_type(host_key);

	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);

	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@");
	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
	error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
	error("It is also possible that the %s host key has just been changed.", type);
	error("The fingerprint for the %s key sent by the remote host is\n%s.",
	    type, fp);
	error("Please contact your system administrator.");

	xfree(fp);
@


1.147.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.158 2004/06/21 17:36:31 avsm Exp $");
d34 1
d763 1
a763 1
			char *key_msg;
d765 1
a765 1
				key_msg = "is unknown";
d767 1
a767 1
				key_msg = "is unchanged";
d769 1
a769 1
				key_msg = "has a different value";
d775 1
a775 1
			error("%s. This could either mean that", key_msg);
@


1.146
log
@deal with typing of write vs read in atomicio
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.145 2003/06/11 10:16:16 jakob Exp $");
d245 1
a245 1
	memset(fdset, '\0', fdsetsz);
@


1.145
log
@clean up check_host_key() and improve SSHFP feedback. ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.144 2003/06/04 08:25:18 djm Exp $");
d522 1
a522 1
	if (atomicio(write, connection_out, buf, strlen(buf)) != strlen(buf))
@


1.144
log
@disable challenge/response and keyboard-interactive auth methods upon hostkey
mismatch. based on patch from fcusack AT fcusack.com. bz #580; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.143 2003/05/26 12:54:40 djm Exp $");
d43 4
d572 1
a572 1
	int len, host_line, ip_line, has_keys;
d713 8
a720 1
			has_keys = show_other_keys(host, host_key);
d723 13
d739 1
a739 1
			    "%s key fingerprint is %s.\n"
d742 1
a742 4
			    host, ip,
			    has_keys ? ",\nbut keys of different type are already "
			    "known for this host." : ".",
			    type, fp);
d906 1
d908 4
@


1.143
log
@fix format strings; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.142 2003/05/23 08:29:30 djm Exp $");
d791 1
a791 1
		 * the connection but without password authentication or
d798 11
@


1.142
log
@fix leak; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.141 2003/05/15 14:55:25 djm Exp $");
d843 1
a843 1
			logit(msg);
d852 1
a852 1
			logit(msg);
@


1.141
log
@add a ConnectTimeout option to ssh, based on patch from
Jean-Charles Longuet (jclonguet at free.fr); portable #207 ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.140 2003/05/14 18:16:21 jakob Exp $");
d224 1
a224 1
	int fdsetsz, optval, rc;
d256 1
a256 1
		return (-1);
d260 1
a260 1
		return (-1);
d268 1
a268 1
			return (-1);
d271 1
a271 1
			return (-1);
d273 1
d280 2
a281 1
	return (0);
@


1.140
log
@add experimental support for verifying hos keys using DNS as described
in draft-ietf-secsh-dns-xx.txt. more information in README.dns.
ok markus@@ and henning@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.139 2003/04/14 14:17:50 markus Exp $");
d217 65
d370 2
a371 1
			if (connect(sock, ai->ai_addr, ai->ai_addrlen) >= 0) {
@


1.139
log
@avoid hardcoded SOCK_xx; with itojun@@; should allow ssh over SCTP
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.138 2003/04/08 20:21:29 itojun Exp $");
d36 4
d796 1
d801 16
@


1.138
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.137 2002/11/21 23:03:51 deraadt Exp $");
d162 1
a162 1
ssh_create_socket(int privileged, int family)
d174 1
a174 1
		sock = rresvport_af(&p, family);
d177 2
a178 1
			error("rresvport: af=%d %.100s", family, strerror(errno));
d183 1
a183 1
	sock = socket(family, SOCK_STREAM, 0);
d192 3
a194 2
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
d296 1
a296 1
			sock = ssh_create_socket(needpriv, ai->ai_family);
@


1.137
log
@KNF
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.136 2002/11/21 22:45:31 markus Exp $");
d331 1
a331 1
		log("ssh: connect to host %s port %s: %s",
d420 1
a420 1
				log("Agent forwarding disabled for protocol 1.3");
d607 1
a607 1
				log("%s host key for IP address "
d612 1
a612 1
				log("Failed to add the %s host key for IP "
d616 1
a616 1
				log("Warning: Permanently added the %s host "
d663 1
a663 1
			log("Failed to add the host to the list of known "
d666 1
a666 1
			log("Warning: Permanently added '%.200s' (%s) to the "
d769 1
a769 1
			log(msg);
d778 1
a778 1
			log(msg);
d876 1
a876 1
		log("WARNING: %s key found for host %s\n"
@


1.137.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.147 2003/06/29 12:44:38 markus Exp $");
a35 4
#ifdef DNS
#include "dns.h"
#endif

a38 4
#ifdef DNS
int verified_host_key_dns = 0;
#endif

d162 1
a162 1
ssh_create_socket(int privileged, struct addrinfo *ai)
d174 1
a174 1
		sock = rresvport_af(&p, ai->ai_family);
d177 1
a177 2
			error("rresvport: af=%d %.100s", ai->ai_family,
			    strerror(errno));
d182 1
a182 1
	sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d191 2
a192 3
	hints.ai_family = ai->ai_family;
	hints.ai_socktype = ai->ai_socktype;
	hints.ai_protocol = ai->ai_protocol;
a210 67
static int
timeout_connect(int sockfd, const struct sockaddr *serv_addr,
    socklen_t addrlen, int timeout)
{
	fd_set *fdset;
	struct timeval tv;
	socklen_t optlen;
	int fdsetsz, optval, rc, result = -1;

	if (timeout <= 0)
		return (connect(sockfd, serv_addr, addrlen));

	if (fcntl(sockfd, F_SETFL, O_NONBLOCK) < 0)
		return (-1);

	rc = connect(sockfd, serv_addr, addrlen);
	if (rc == 0)
		return (0);
	if (errno != EINPROGRESS)
		return (-1);

	fdsetsz = howmany(sockfd + 1, NFDBITS) * sizeof(fd_mask);
	fdset = (fd_set *)xmalloc(fdsetsz);

	memset(fdset, 0, fdsetsz);
	FD_SET(sockfd, fdset);
	tv.tv_sec = timeout;
	tv.tv_usec = 0;

	for(;;) {
		rc = select(sockfd + 1, NULL, fdset, NULL, &tv);
		if (rc != -1 || errno != EINTR)
			break;
	}

	switch(rc) {
	case 0:
		/* Timed out */
		errno = ETIMEDOUT;
		break;
	case -1:
		/* Select error */
	    	debug("select: %s", strerror(errno));
		break;
	case 1:
		/* Completed or failed */
		optval = 0;
		optlen = sizeof(optval);
		if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval, 
		    &optlen) == -1)
		    	debug("getsockopt: %s", strerror(errno));
			break;
		if (optval != 0) {
			errno = optval;
			break;
		}
		result = 0;
		break;
	default:
		/* Should not occur */
		fatal("Bogus return (%d) from select()", rc);
	}

	xfree(fdset);
	return (result);
}

d294 1
a294 1
			sock = ssh_create_socket(needpriv, ai);
d299 1
a299 2
			if (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,
			    options.connection_timeout) >= 0) {
d331 1
a331 1
		logit("ssh: connect to host %s port %s: %s",
d420 1
a420 1
				logit("Agent forwarding disabled for protocol 1.3");
d444 1
a444 1
	if (atomicio(vwrite, connection_out, buf, strlen(buf)) != strlen(buf))
d494 1
a494 1
	int len, host_line, ip_line;
d607 1
a607 1
				logit("%s host key for IP address "
d612 1
a612 1
				logit("Failed to add the %s host key for IP "
d616 1
a616 1
				logit("Warning: Permanently added the %s host "
d635 1
a635 8
			char msg1[1024], msg2[1024];

			if (show_other_keys(host, host_key))
				snprintf(msg1, sizeof(msg1),
				   "\nbut keys of different type are already"
				   " known for this host.");
			else
				snprintf(msg1, sizeof(msg1), ".");
a637 13
			msg2[0] = '\0';
#ifdef DNS
			if (options.verify_host_key_dns) {
				if (verified_host_key_dns)
					snprintf(msg2, sizeof(msg2),
					    "Matching host key fingerprint"
					    " found in DNS.\n");
				else
					snprintf(msg2, sizeof(msg2),
					    "No matching host key fingerprint"
					    " found in DNS.\n");
			}
#endif
d641 1
a641 1
			    "%s key fingerprint is %s.\n%s"
d644 4
a647 1
			    host, ip, msg1, type, fp, msg2);
d663 1
a663 1
			logit("Failed to add the host to the list of known "
d666 1
a666 1
			logit("Warning: Permanently added '%.200s' (%s) to the "
d717 1
a717 1
		 * the connection but without MITM-able authentication or
a724 11
		if (options.kbd_interactive_authentication) {
			error("Keyboard-interactive authentication is disabled"
			    " to avoid man-in-the-middle attacks.");
			options.kbd_interactive_authentication = 0;
			options.challenge_response_authentication = 0;
		}
		if (options.challenge_response_authentication) {
			error("Challenge/response authentication is disabled"
			    " to avoid man-in-the-middle attacks.");
			options.challenge_response_authentication = 0;
		}
d769 1
a769 1
			logit("%s", msg);
d778 1
a778 1
			logit("%s", msg);
a789 1
/* returns 0 if key verifies or -1 if key does NOT verify */
a794 21
#ifdef DNS
	if (options.verify_host_key_dns) {
		switch(verify_host_key_dns(host, hostaddr, host_key)) {
		case DNS_VERIFY_OK:
#ifdef DNSSEC
			return 0;
#else
			verified_host_key_dns = 1;
			break;
#endif
		case DNS_VERIFY_FAILED:
			return -1;
		case DNS_VERIFY_ERROR:
			break;
		default:
			debug3("bad return value from verify_host_key_dns");
			break;
		}
	}
#endif /* DNS */

d876 1
a876 1
		logit("WARNING: %s key found for host %s\n"
@


1.137.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.156 2004/01/25 03:49:09 djm Exp $");
d36 1
d38 1
d43 3
a45 1
int matching_host_key_dns = 0;
a54 1
static void warn_changed_key(Key *);
d76 1
a76 1
	 * Use "exec" to avoid "sh -c" processes on some platforms
d233 3
a235 1
	set_nonblock(sockfd);
d237 1
a237 2
	if (rc == 0) {
		unset_nonblock(sockfd);
a238 1
	}
d263 1
a263 1
		debug("select: %s", strerror(errno));
d269 3
a271 3
		if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval,
		    &optlen) == -1) {
			debug("getsockopt: %s", strerror(errno));
a272 1
		}
a277 1
		unset_nonblock(sockfd);
d416 2
a417 2
	/* Set SO_KEEPALIVE if requested. */
	if (options.tcp_keep_alive &&
d564 1
a564 1
	const char *type = key_type(host_key);
d724 1
d726 1
a726 1
				if (matching_host_key_dns)
d735 1
d785 10
a794 1
		warn_changed_key(host_key);
d798 1
a900 1
	int flags = 0;
d902 17
a918 17
	if (options.verify_host_key_dns &&
	    verify_host_key_dns(host, hostaddr, host_key, &flags) == 0) {

		if (flags & DNS_VERIFY_FOUND) {

			if (options.verify_host_key_dns == 1 &&
			    flags & DNS_VERIFY_MATCH &&
			    flags & DNS_VERIFY_SECURE)
				return 0;

			if (flags & DNS_VERIFY_MATCH) {
				matching_host_key_dns = 1;
			} else {
				warn_changed_key(host_key);
				error("Update the SSHFP RR in DNS with the new "
				    "host key to get rid of this message.");
			}
d921 1
a1045 21
}

static void
warn_changed_key(Key *host_key)
{
	char *fp;
	const char *type = key_type(host_key);

	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);

	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@");
	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
	error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
	error("It is also possible that the %s host key has just been changed.", type);
	error("The fingerprint for the %s key sent by the remote host is\n%s.",
	    type, fp);
	error("Please contact your system administrator.");

	xfree(fp);
@


1.136
log
@debug->debug2, unify debug messages
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.135 2002/09/19 01:58:18 djm Exp $");
d644 4
a647 4
			     host, ip,
			     has_keys ? ",\nbut keys of different type are already "
			     "known for this host." : ".",
			     type, fp);
@


1.135
log
@bugzilla.mindrot.org #223 - ProxyCommands don't exit.
Patch from dtucker@@zip.com.au; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.134 2002/09/13 19:23:09 stevesk Exp $");
d246 1
a246 1
	debug("ssh_connect: needpriv %d", needpriv);
@


1.135.2.1
log
@Update to OpenSSH 3.6
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.137 2002/11/21 23:03:51 deraadt Exp $");
d246 1
a246 1
	debug2("ssh_connect: needpriv %d", needpriv);
d644 4
a647 4
			    host, ip,
			    has_keys ? ",\nbut keys of different type are already "
			    "known for this host." : ".",
			    type, fp);
@


1.135.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.147 2003/06/29 12:44:38 markus Exp $");
a35 4
#ifdef DNS
#include "dns.h"
#endif

a38 4
#ifdef DNS
int verified_host_key_dns = 0;
#endif

d162 1
a162 1
ssh_create_socket(int privileged, struct addrinfo *ai)
d174 1
a174 1
		sock = rresvport_af(&p, ai->ai_family);
d177 1
a177 2
			error("rresvport: af=%d %.100s", ai->ai_family,
			    strerror(errno));
d182 1
a182 1
	sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d191 2
a192 3
	hints.ai_family = ai->ai_family;
	hints.ai_socktype = ai->ai_socktype;
	hints.ai_protocol = ai->ai_protocol;
a210 67
static int
timeout_connect(int sockfd, const struct sockaddr *serv_addr,
    socklen_t addrlen, int timeout)
{
	fd_set *fdset;
	struct timeval tv;
	socklen_t optlen;
	int fdsetsz, optval, rc, result = -1;

	if (timeout <= 0)
		return (connect(sockfd, serv_addr, addrlen));

	if (fcntl(sockfd, F_SETFL, O_NONBLOCK) < 0)
		return (-1);

	rc = connect(sockfd, serv_addr, addrlen);
	if (rc == 0)
		return (0);
	if (errno != EINPROGRESS)
		return (-1);

	fdsetsz = howmany(sockfd + 1, NFDBITS) * sizeof(fd_mask);
	fdset = (fd_set *)xmalloc(fdsetsz);

	memset(fdset, 0, fdsetsz);
	FD_SET(sockfd, fdset);
	tv.tv_sec = timeout;
	tv.tv_usec = 0;

	for(;;) {
		rc = select(sockfd + 1, NULL, fdset, NULL, &tv);
		if (rc != -1 || errno != EINTR)
			break;
	}

	switch(rc) {
	case 0:
		/* Timed out */
		errno = ETIMEDOUT;
		break;
	case -1:
		/* Select error */
	    	debug("select: %s", strerror(errno));
		break;
	case 1:
		/* Completed or failed */
		optval = 0;
		optlen = sizeof(optval);
		if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval, 
		    &optlen) == -1)
		    	debug("getsockopt: %s", strerror(errno));
			break;
		if (optval != 0) {
			errno = optval;
			break;
		}
		result = 0;
		break;
	default:
		/* Should not occur */
		fatal("Bogus return (%d) from select()", rc);
	}

	xfree(fdset);
	return (result);
}

d294 1
a294 1
			sock = ssh_create_socket(needpriv, ai);
d299 1
a299 2
			if (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,
			    options.connection_timeout) >= 0) {
d331 1
a331 1
		logit("ssh: connect to host %s port %s: %s",
d420 1
a420 1
				logit("Agent forwarding disabled for protocol 1.3");
d444 1
a444 1
	if (atomicio(vwrite, connection_out, buf, strlen(buf)) != strlen(buf))
d494 1
a494 1
	int len, host_line, ip_line;
d607 1
a607 1
				logit("%s host key for IP address "
d612 1
a612 1
				logit("Failed to add the %s host key for IP "
d616 1
a616 1
				logit("Warning: Permanently added the %s host "
d635 1
a635 8
			char msg1[1024], msg2[1024];

			if (show_other_keys(host, host_key))
				snprintf(msg1, sizeof(msg1),
				   "\nbut keys of different type are already"
				   " known for this host.");
			else
				snprintf(msg1, sizeof(msg1), ".");
a637 13
			msg2[0] = '\0';
#ifdef DNS
			if (options.verify_host_key_dns) {
				if (verified_host_key_dns)
					snprintf(msg2, sizeof(msg2),
					    "Matching host key fingerprint"
					    " found in DNS.\n");
				else
					snprintf(msg2, sizeof(msg2),
					    "No matching host key fingerprint"
					    " found in DNS.\n");
			}
#endif
d641 1
a641 1
			    "%s key fingerprint is %s.\n%s"
d644 4
a647 1
			    host, ip, msg1, type, fp, msg2);
d663 1
a663 1
			logit("Failed to add the host to the list of known "
d666 1
a666 1
			logit("Warning: Permanently added '%.200s' (%s) to the "
d717 1
a717 1
		 * the connection but without MITM-able authentication or
a724 11
		if (options.kbd_interactive_authentication) {
			error("Keyboard-interactive authentication is disabled"
			    " to avoid man-in-the-middle attacks.");
			options.kbd_interactive_authentication = 0;
			options.challenge_response_authentication = 0;
		}
		if (options.challenge_response_authentication) {
			error("Challenge/response authentication is disabled"
			    " to avoid man-in-the-middle attacks.");
			options.challenge_response_authentication = 0;
		}
d769 1
a769 1
			logit("%s", msg);
d778 1
a778 1
			logit("%s", msg);
a789 1
/* returns 0 if key verifies or -1 if key does NOT verify */
a794 21
#ifdef DNS
	if (options.verify_host_key_dns) {
		switch(verify_host_key_dns(host, hostaddr, host_key)) {
		case DNS_VERIFY_OK:
#ifdef DNSSEC
			return 0;
#else
			verified_host_key_dns = 1;
			break;
#endif
		case DNS_VERIFY_FAILED:
			return -1;
		case DNS_VERIFY_ERROR:
			break;
		default:
			debug3("bad return value from verify_host_key_dns");
			break;
		}
	}
#endif /* DNS */

d876 1
a876 1
		logit("WARNING: %s key found for host %s\n"
@


1.134
log
@remove use of SO_LINGER, it should not be needed. error check
SO_REUSEADDR. fixup comments. ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.133 2002/07/29 18:57:30 markus Exp $");
d44 1
d64 7
a70 2
	/* Build the final command string in the buffer by making the
	   appropriate substitutions to the given proxy command. */
d72 2
d141 2
@


1.133
log
@print file:line
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.132 2002/07/24 16:11:18 markus Exp $");
a227 1
	struct linger linger;
a326 9

	/*
	 * Set socket options.  We would like the socket to disappear as soon
	 * as it has been closed for whatever reason.
	 */
	/* setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on)); */
	linger.l_onoff = 1;
	linger.l_linger = 5;
	setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof(linger));
@


1.132
log
@print out all known keys for a host if we get a unknown host key,
see discussion at http://marc.theaimsgroup.com/?t=101069210100016&r=1&w=4

the ssharp mitm tool attacks users in a similar way, so i'd like to
pointed out again:
	A MITM attack is always possible if the ssh client prints:
	The authenticity of host 'bla' can't be established.
(protocol version 2 with pubkey authentication allows you to detect
MITM attacks)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.131 2002/07/12 13:29:09 itojun Exp $");
d877 1
a877 1
		    "in file %s line %d with\n"
@


1.131
log
@print connect failure during debugging mode.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.130 2002/07/10 10:28:15 itojun Exp $");
d45 2
d494 1
a494 1
	int len, host_line, ip_line;
d635 1
d640 1
a640 1
			    "established.\n"
d643 5
a647 1
			    "(yes/no)? ", host, ip, type, fp);
d750 3
d863 55
@


1.130
log
@bark if all connection attempt fails.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.129 2002/07/09 12:04:02 itojun Exp $");
a44 13
#if 0
static const char *
sockaddr_ntop(struct sockaddr *sa, socklen_t salen)
{
	static char addrbuf[NI_MAXHOST];

	if (getnameinfo(sa, salen, addrbuf, sizeof(addrbuf), NULL, 0,
	    NI_NUMERICHOST) != 0)
		fatal("sockaddr_ntop: getnameinfo NI_NUMERICHOST failed");
	return addrbuf;
}
#endif

d295 2
@


1.129
log
@ed static function (less warnings)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.128 2002/07/09 11:56:50 itojun Exp $");
a307 5
#if 0
				log("ssh: connect to address %s port %s: %s",
				    sockaddr_ntop(ai->ai_addr, ai->ai_addrlen),
				    strport, strerror(errno));
#endif
d330 3
a332 1
	if (attempt >= connection_attempts)
d334 1
@


1.128
log
@silently try next address on connect(2).  markus ok
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.127 2002/06/27 08:49:44 markus Exp $");
d45 1
d56 1
@


1.127
log
@more checks for NULL pointers; from grendel@@zeitbombe.org; ok deraadt@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.126 2002/06/23 03:30:17 deraadt Exp $");
d306 1
d310 1
@


1.126
log
@various KNF and %d for unsigned
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.125 2002/06/19 00:27:55 deraadt Exp $");
d475 1
a475 1
		if (strncasecmp(p, "yes", 3) == 0)
@


1.125
log
@KNF done automatically while reading....
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.124 2002/06/11 04:14:26 markus Exp $");
d265 1
a265 1
	snprintf(strport, sizeof strport, "%d", port);
a487 1

@


1.124
log
@no longer use uidswap.[ch] from the ssh client
run less code with euid==0 if ssh is installed setuid root
just switch the euid, don't switch the complete set of groups
(this is only needed by sshd). ok provos@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.123 2002/06/09 22:17:21 itojun Exp $");
d766 1
a766 1
			     host_file, host_line);
@


1.123
log
@pass salen to sockaddr_ntop so that we are happy on linux/solaris
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.122 2002/06/09 04:33:27 markus Exp $");
d39 1
d42 2
d60 1
a60 2
ssh_proxy_connect(const char *host, u_short port, struct passwd *pw,
		  const char *proxy_command)
d110 2
a111 1
		permanently_set_uid(pw);
d161 1
a161 1
ssh_create_socket(struct passwd *pw, int privileged, int family)
d172 1
d174 1
a180 5
	/*
	 * Just create an ordinary socket on arbitrary port.  We use
	 * the user's uid to create the socket.
	 */
	temporarily_use_uid(pw);
a183 1
	restore_uid();
d213 1
a213 1
 * If port is 0, the default port will be used.  If anonymous is zero,
d215 1
a215 1
 * This requires super-user privileges if anonymous is false.
d230 1
a230 1
    int anonymous, struct passwd *pw, const char *proxy_command)
d246 1
a246 2
	debug("ssh_connect: getuid %u geteuid %u anon %d",
	    (u_int) getuid(), (u_int) geteuid(), anonymous);
d258 1
a258 1
		return ssh_proxy_connect(host, port, pw, proxy_command);
d294 1
a294 3
			sock = ssh_create_socket(pw,
			    !anonymous && geteuid() == 0,
			    ai->ai_family);
a298 5
			/* Connect to the host.  We use the user's uid in the
			 * hope that it will help with tcp_wrappers showing
			 * the remote uid as root.
			 */
			temporarily_use_uid(pw);
a301 1
				restore_uid();
a308 1
				restore_uid();
@


1.122
log
@abort() - > fatal()
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.121 2002/06/08 21:15:27 itojun Exp $");
d43 1
a43 1
sockaddr_ntop(struct sockaddr *sa)
d47 1
a47 1
	if (getnameinfo(sa, sa->sa_len, addrbuf, sizeof(addrbuf), NULL, 0,
d317 2
a318 2
				    sockaddr_ntop(ai->ai_addr), strport,
				    strerror(errno));
@


1.121
log
@always use getnameinfo.  (diag message only)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.120 2002/05/23 19:24:30 markus Exp $");
d49 1
a49 1
		abort();	/* XXX abort is bad -- do something else */
@


1.120
log
@add /usr/libexec/ssh-keysign: a setuid helper program for hostbased authentication
in protocol v2 (needs to access the hostkeys).
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.119 2002/01/21 15:13:51 markus Exp $");
d45 1
a45 2
	void *addr;
	static char addrbuf[INET6_ADDRSTRLEN];
d47 2
a48 9
	switch (sa->sa_family) {
	case AF_INET:
		addr = &((struct sockaddr_in *)sa)->sin_addr;
		break;
	case AF_INET6:
		addr = &((struct sockaddr_in6 *)sa)->sin6_addr;
		break;
	default:
		/* This case should be protected against elsewhere */
a49 2
	}
	inet_ntop(sa->sa_family, addr, addrbuf, sizeof(addrbuf));
@


1.119
log
@use read_passphrase+ECHO in confirm(), allows use of ssh-askpass
for hostkey confirm.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.118 2001/12/19 07:18:56 deraadt Exp $");
d835 1
a835 1
ssh_login(Key **keys, int nkeys, const char *orighost,
d860 1
a860 1
		ssh_userauth2(local_user, server_user, host, keys, nkeys);
d863 1
a863 1
		ssh_userauth1(local_user, server_user, host, keys, nkeys);
@


1.119.2.1
log
@Pull in OpenSSH-3.4
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.126 2002/06/23 03:30:17 deraadt Exp $");
a38 1
/* import */
a40 2
extern uid_t original_real_uid;
extern uid_t original_effective_uid;
d43 1
a43 1
sockaddr_ntop(struct sockaddr *sa, socklen_t salen)
d45 2
a46 1
	static char addrbuf[NI_MAXHOST];
d48 12
a59 3
	if (getnameinfo(sa, salen, addrbuf, sizeof(addrbuf), NULL, 0,
	    NI_NUMERICHOST) != 0)
		fatal("sockaddr_ntop: getnameinfo NI_NUMERICHOST failed");
d67 2
a68 1
ssh_proxy_connect(const char *host, u_short port, const char *proxy_command)
d118 1
a118 2
		seteuid(original_real_uid);
		setuid(original_real_uid);
d168 1
a168 1
ssh_create_socket(int privileged, int family)
a178 1
		PRIV_START;
a179 1
		PRIV_END;
d186 5
d194 1
d224 1
a224 1
 * If port is 0, the default port will be used.  If needpriv is true,
d226 1
a226 1
 * This requires super-user privileges if needpriv is true.
d241 1
a241 1
    int needpriv, const char *proxy_command)
d257 2
a258 1
	debug("ssh_connect: needpriv %d", needpriv);
d270 1
a270 1
		return ssh_proxy_connect(host, port, proxy_command);
d277 1
a277 1
	snprintf(strport, sizeof strport, "%u", port);
d306 3
a308 1
			sock = ssh_create_socket(needpriv, ai->ai_family);
d313 5
d321 1
d327 3
a329 2
				    sockaddr_ntop(ai->ai_addr, ai->ai_addrlen),
				    strport, strerror(errno));
d509 1
d787 1
a787 1
			    host_file, host_line);
d835 1
a835 1
ssh_login(Sensitive *sensitive, const char *orighost,
d860 1
a860 1
		ssh_userauth2(local_user, server_user, host, sensitive);
d863 1
a863 1
		ssh_userauth1(local_user, server_user, host, sensitive);
@


1.119.2.2
log
@Update to OpenSSH 3.5
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.135 2002/09/19 01:58:18 djm Exp $");
a43 1
extern pid_t proxy_command_pid;
d45 10
a54 1
static int show_other_keys(const char *, Key *);
d72 2
a73 7
	/*
	 * Build the final command string in the buffer by making the
	 * appropriate substitutions to the given proxy command.
	 *
	 * Use "exec" to avoid "sh -c" processes on some platforms 
	 * (e.g. Solaris)
	 */
a74 2
	buffer_append(&command, "exec ", 5);

a141 2
	else
		proxy_command_pid = pid; /* save pid to clean up later */
d237 1
d306 3
a308 2
				debug("connect to address %s port %s: %s",
				    ntop, strport, strerror(errno));
d331 1
a331 3
	if (attempt >= connection_attempts) {
		log("ssh: connect to host %s port %s: %s",
		    host, strport, strerror(errno));
a332 1
	}
d336 9
d475 1
a475 1
		if (p && strncasecmp(p, "yes", 3) == 0)
d501 1
a501 1
	int len, host_line, ip_line, has_keys;
a641 1
			has_keys = show_other_keys(host, host_key);
d646 1
a646 1
			    "established%s\n"
d649 1
a649 5
			    "(yes/no)? ",
			     host, ip,
			     has_keys ? ",\nbut keys of different type are already "
			     "known for this host." : ".",
			     type, fp);
a751 3
	case HOST_FOUND:
		fatal("internal error");
		break;
a861 55
}

static int
show_key_from_file(const char *file, const char *host, int keytype)
{
	Key *found;
	char *fp;
	int line, ret;

	found = key_new(keytype);
	if ((ret = lookup_key_in_hostfile_by_type(file, host,
	    keytype, found, &line))) {
		fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
		log("WARNING: %s key found for host %s\n"
		    "in %s:%d\n"
		    "%s key fingerprint %s.",
		    key_type(found), host, file, line,
		    key_type(found), fp);
		xfree(fp);
	}
	key_free(found);
	return (ret);
}

/* print all known host keys for a given host, but skip keys of given type */
static int
show_other_keys(const char *host, Key *key)
{
	int type[] = { KEY_RSA1, KEY_RSA, KEY_DSA, -1};
	int i, found = 0;

	for (i = 0; type[i] != -1; i++) {
		if (type[i] == key->type)
			continue;
		if (type[i] != KEY_RSA1 &&
		    show_key_from_file(options.user_hostfile2, host, type[i])) {
			found = 1;
			continue;
		}
		if (type[i] != KEY_RSA1 &&
		    show_key_from_file(options.system_hostfile2, host, type[i])) {
			found = 1;
			continue;
		}
		if (show_key_from_file(options.user_hostfile, host, type[i])) {
			found = 1;
			continue;
		}
		if (show_key_from_file(options.system_hostfile, host, type[i])) {
			found = 1;
			continue;
		}
		debug2("no key of type %d for host %s", type[i], host);
	}
	return (found);
@


1.119.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.137 2002/11/21 23:03:51 deraadt Exp $");
d246 1
a246 1
	debug2("ssh_connect: needpriv %d", needpriv);
d644 4
a647 4
			    host, ip,
			    has_keys ? ",\nbut keys of different type are already "
			    "known for this host." : ".",
			    type, fp);
@


1.118
log
@basic KNF done while i was looking for something else
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.117 2001/12/06 18:02:32 stevesk Exp $");
d34 1
d484 3
a486 3
	char buf[1024];
	FILE *f;
	int retval = -1;
d490 12
a501 28
	if (isatty(STDIN_FILENO))
		f = stdin;
	else
		f = fopen(_PATH_TTY, "rw");
	if (f == NULL)
		return 0;
	fflush(stdout);
	fprintf(stderr, "%s", prompt);
	while (1) {
		if (fgets(buf, sizeof(buf), f) == NULL) {
			fprintf(stderr, "\n");
			strlcpy(buf, "no", sizeof buf);
		}
		/* Remove newline from response. */
		if (strchr(buf, '\n'))
			*strchr(buf, '\n') = 0;
		if (strcmp(buf, "yes") == 0)
			retval = 1;
		else if (strcmp(buf, "no") == 0)
			retval = 0;
		else
			fprintf(stderr, "Please type 'yes' or 'no': ");

		if (retval != -1) {
			if (f != stdin)
				fclose(f);
			return retval;
		}
d522 2
a523 1
	int host_line, ip_line;
a664 1
			char prompt[1024];
d666 1
a666 1
			snprintf(prompt, sizeof(prompt),
d673 1
a673 1
			if (!confirm(prompt)) {
a674 1
			}
d778 11
a788 6
		log("Warning: the %s host key for '%.200s' "
		    "differs from the key for the IP address '%.128s'",
		    type, host, ip);
		if (host_status == HOST_OK)
			log("Matching host key in %s:%d", host_file, host_line);
		log("Offending key for IP in %s:%d", ip_file, ip_line);
d790 1
d794 3
a796 2
			if (!confirm("Are you sure you want "
			    "to continue connecting (yes/no)? ")) {
d798 2
a799 1
			}
@


1.117
log
@shutdown(sock, SHUT_RDWR) not needed here; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.116 2001/12/05 10:06:13 deraadt Exp $");
d108 1
a108 1
		      strerror(errno));
d257 1
a257 1
	      (u_int) getuid(), (u_int) geteuid(), anonymous);
d423 1
a423 1
	      remote_major, remote_minor, remote_version);
d611 1
a611 1
	     file_key, &host_line);
d654 1
a654 1
			     host_key))
d780 1
a780 1
			     options.num_remote_forwards = 0;
d804 1
a804 1
			if (!confirm("Are you sure you want " 
@


1.116
log
@minor KNF
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.115 2001/10/08 19:05:05 markus Exp $");
a334 1
				shutdown(sock, SHUT_RDWR);
@


1.115
log
@some more IPv4or6 cleanup
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.114 2001/10/08 16:15:47 markus Exp $");
d48 9
a56 9
		case AF_INET:
			addr = &((struct sockaddr_in *)sa)->sin_addr;
			break;
		case AF_INET6:
			addr = &((struct sockaddr_in6 *)sa)->sin6_addr;
			break;
		default:
			/* This case should be protected against elsewhere */
			abort();
d429 1
a429 1
	switch(remote_major) {
@


1.115.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.119 2002/01/21 15:13:51 markus Exp $");
a33 1
#include "readpass.h"
d48 9
a56 9
	case AF_INET:
		addr = &((struct sockaddr_in *)sa)->sin_addr;
		break;
	case AF_INET6:
		addr = &((struct sockaddr_in6 *)sa)->sin6_addr;
		break;
	default:
		/* This case should be protected against elsewhere */
		abort();	/* XXX abort is bad -- do something else */
d108 1
a108 1
		    strerror(errno));
d257 1
a257 1
	    (u_int) getuid(), (u_int) geteuid(), anonymous);
d335 1
d424 1
a424 1
	    remote_major, remote_minor, remote_version);
d429 1
a429 1
	switch (remote_major) {
d484 3
a486 3
	const char *msg, *again = "Please type 'yes' or 'no': ";
	char *p;
	int ret = -1;
d490 28
a517 12
	for (msg = prompt;;msg = again) {
		p = read_passphrase(msg, RP_ECHO);
		if (p == NULL ||
		    (p[0] == '\0') || (p[0] == '\n') ||
		    strncasecmp(p, "no", 2) == 0)
			ret = 0;
		if (strncasecmp(p, "yes", 3) == 0)
			ret = 1;
		if (p)
			xfree(p);
		if (ret != -1)
			return ret;
d538 1
a538 2
	char msg[1024];
	int len, host_line, ip_line;
d612 1
a612 1
	    file_key, &host_line);
d655 1
a655 1
			    host_key))
d680 1
d682 1
a682 1
			snprintf(msg, sizeof(msg),
d689 1
a689 1
			if (!confirm(msg))
d691 1
d781 1
a781 1
			    options.num_remote_forwards = 0;
d795 6
a800 11
		snprintf(msg, sizeof(msg),
		    "Warning: the %s host key for '%.200s' "
		    "differs from the key for the IP address '%.128s'"
		    "\nOffending key for IP in %s:%d",
		    type, host, ip, ip_file, ip_line);
		if (host_status == HOST_OK) {
			len = strlen(msg);
			snprintf(msg + len, sizeof(msg) - len,
			    "\nMatching host key in %s:%d",
			     host_file, host_line);
		}
a801 1
			log(msg);
d805 2
a806 3
			strlcat(msg, "\nAre you sure you want "
			    "to continue connecting (yes/no)? ", sizeof(msg));
			if (!confirm(msg))
d808 1
a808 2
		} else {
			log(msg);
@


1.115.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.115.2.1 2002/03/07 17:37:47 jason Exp $");
a38 1
/* import */
a40 2
extern uid_t original_real_uid;
extern uid_t original_effective_uid;
d43 1
a43 1
sockaddr_ntop(struct sockaddr *sa, socklen_t salen)
d45 2
a46 1
	static char addrbuf[NI_MAXHOST];
d48 12
a59 3
	if (getnameinfo(sa, salen, addrbuf, sizeof(addrbuf), NULL, 0,
	    NI_NUMERICHOST) != 0)
		fatal("sockaddr_ntop: getnameinfo NI_NUMERICHOST failed");
d67 2
a68 1
ssh_proxy_connect(const char *host, u_short port, const char *proxy_command)
d118 1
a118 2
		seteuid(original_real_uid);
		setuid(original_real_uid);
d168 1
a168 1
ssh_create_socket(int privileged, int family)
a178 1
		PRIV_START;
a179 1
		PRIV_END;
d186 5
d194 1
d224 1
a224 1
 * If port is 0, the default port will be used.  If needpriv is true,
d226 1
a226 1
 * This requires super-user privileges if needpriv is true.
d241 1
a241 1
    int needpriv, const char *proxy_command)
d257 2
a258 1
	debug("ssh_connect: needpriv %d", needpriv);
d270 1
a270 1
		return ssh_proxy_connect(host, port, proxy_command);
d306 3
a308 1
			sock = ssh_create_socket(needpriv, ai->ai_family);
d313 5
d321 1
d327 3
a329 2
				    sockaddr_ntop(ai->ai_addr, ai->ai_addrlen),
				    strport, strerror(errno));
d787 1
a787 1
			    host_file, host_line);
d835 1
a835 1
ssh_login(Sensitive *sensitive, const char *orighost,
d860 1
a860 1
		ssh_userauth2(local_user, server_user, host, sensitive);
d863 1
a863 1
		ssh_userauth1(local_user, server_user, host, sensitive);
@


1.115.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.115.2.2 2002/06/22 07:23:18 miod Exp $");
d265 1
a265 1
	snprintf(strport, sizeof strport, "%u", port);
d488 1
@


1.115.2.4
log
@Update to OpenSSH 3.5
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.135 2002/09/19 01:58:18 djm Exp $");
a43 1
extern pid_t proxy_command_pid;
d45 10
a54 1
static int show_other_keys(const char *, Key *);
d72 2
a73 7
	/*
	 * Build the final command string in the buffer by making the
	 * appropriate substitutions to the given proxy command.
	 *
	 * Use "exec" to avoid "sh -c" processes on some platforms 
	 * (e.g. Solaris)
	 */
a74 2
	buffer_append(&command, "exec ", 5);

a141 2
	else
		proxy_command_pid = pid; /* save pid to clean up later */
d237 1
d306 3
a308 2
				debug("connect to address %s port %s: %s",
				    ntop, strport, strerror(errno));
d331 1
a331 3
	if (attempt >= connection_attempts) {
		log("ssh: connect to host %s port %s: %s",
		    host, strport, strerror(errno));
a332 1
	}
d336 9
d475 1
a475 1
		if (p && strncasecmp(p, "yes", 3) == 0)
d501 1
a501 1
	int len, host_line, ip_line, has_keys;
a641 1
			has_keys = show_other_keys(host, host_key);
d646 1
a646 1
			    "established%s\n"
d649 1
a649 5
			    "(yes/no)? ",
			     host, ip,
			     has_keys ? ",\nbut keys of different type are already "
			     "known for this host." : ".",
			     type, fp);
a751 3
	case HOST_FOUND:
		fatal("internal error");
		break;
a861 55
}

static int
show_key_from_file(const char *file, const char *host, int keytype)
{
	Key *found;
	char *fp;
	int line, ret;

	found = key_new(keytype);
	if ((ret = lookup_key_in_hostfile_by_type(file, host,
	    keytype, found, &line))) {
		fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
		log("WARNING: %s key found for host %s\n"
		    "in %s:%d\n"
		    "%s key fingerprint %s.",
		    key_type(found), host, file, line,
		    key_type(found), fp);
		xfree(fp);
	}
	key_free(found);
	return (ret);
}

/* print all known host keys for a given host, but skip keys of given type */
static int
show_other_keys(const char *host, Key *key)
{
	int type[] = { KEY_RSA1, KEY_RSA, KEY_DSA, -1};
	int i, found = 0;

	for (i = 0; type[i] != -1; i++) {
		if (type[i] == key->type)
			continue;
		if (type[i] != KEY_RSA1 &&
		    show_key_from_file(options.user_hostfile2, host, type[i])) {
			found = 1;
			continue;
		}
		if (type[i] != KEY_RSA1 &&
		    show_key_from_file(options.system_hostfile2, host, type[i])) {
			found = 1;
			continue;
		}
		if (show_key_from_file(options.user_hostfile, host, type[i])) {
			found = 1;
			continue;
		}
		if (show_key_from_file(options.system_hostfile, host, type[i])) {
			found = 1;
			continue;
		}
		debug2("no key of type %d for host %s", type[i], host);
	}
	return (found);
@


1.114
log
@use correct family for -b option
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.113 2001/10/06 11:18:19 markus Exp $");
a40 3
/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

d239 2
a240 3
	    u_short port, int connection_attempts,
	    int anonymous, struct passwd *pw,
	    const char *proxy_command)
d274 1
a274 1
	hints.ai_family = IPv4or6;
@


1.113
log
@unify hostkey check error messages, simplify prompt.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.112 2001/10/06 00:14:50 markus Exp $");
d203 1
a203 1
	hints.ai_family = IPv4or6;
@


1.112
log
@remove unused argument
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.111 2001/10/01 21:51:16 markus Exp $");
d501 1
a502 1
		fprintf(stderr, "%s", prompt);
d515 1
a515 1
			fprintf(stderr, "Please type 'yes' or 'no'.\n");
a693 1
				log("Aborted by user!");
a810 1
				log("Aborted by user!");
@


1.111
log
@add NoHostAuthenticationForLocalhost; note that the hostkey is
now check for localhost, too.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.110 2001/07/25 14:35:18 markus Exp $");
d486 1
a486 1
read_yes_or_no(const char *prompt, int defval)
a493 1

a497 1

a499 1

a500 1

a503 4
			/*
			 * Print a newline (the prompt probably didn\'t have
			 * one).
			 */
a509 3

		if (buf[0] == 0)
			retval = defval;
d693 1
a693 1
			if (!read_yes_or_no(prompt, -1)) {
d810 2
a811 2
			if (!read_yes_or_no("Are you sure you want " 
			    "to continue connecting (yes/no)? ", -1)) {
@


1.110
log
@cleanup connect(); connection_attempts 4 -> 1; from eivind@@freebsd.org
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.109 2001/06/23 15:12:21 itojun Exp $");
d578 2
a579 1
	if (local && options.host_key_alias == NULL) {
@


1.109
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.108 2001/06/23 02:34:31 markus Exp $");
d44 21
d162 2
a163 1
	return 1;
d233 6
d253 6
d289 2
a290 2
	 */
	for (attempt = 0; attempt < connection_attempts; attempt++) {
d313 1
d327 5
a331 1
				debug("connect: %.100s", strerror(errno));
d346 3
d357 1
a357 1
		return 0;
d379 1
a379 1
	return 1;
@


1.108
log
@get rid of known_hosts2, use it for hostkey lookup, but do not modify.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.107 2001/06/07 20:23:05 markus Exp $");
d47 1
a47 1
int
d147 1
a147 1
int
d344 1
a344 1
void
d443 1
a443 1
int
d499 1
a499 1
int
@


1.107
log
@use xxx_put_cstring()
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.106 2001/05/28 23:58:35 markus Exp $");
d466 4
a469 1
			/* Print a newline (the prompt probably didn\'t have one). */
d495 2
a496 1
 * check whether the supplied host key is valid, return only if ok.
d499 1
a499 1
void
d501 1
a501 1
	const char *user_hostfile, const char *system_hostfile)
d525 2
a526 1
		local = (ntohl(((struct sockaddr_in *)hostaddr)->sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d529 2
a530 1
		local = IN6_IS_ADDR_LOOPBACK(&(((struct sockaddr_in6 *)hostaddr)->sin6_addr));
d539 1
a539 1
		return;
d583 2
a584 1
	host_status = check_host_in_hostfile(host_file, host, host_key, file_key, &host_line);
d587 2
a588 1
		host_status = check_host_in_hostfile(host_file, host, host_key, file_key, &host_line);
d598 2
a599 1
		ip_status = check_host_in_hostfile(ip_file, ip, host_key, ip_key, &ip_line);
d602 2
a603 1
			ip_status = check_host_in_hostfile(ip_file, ip, host_key, ip_key, &ip_line);
d622 9
a630 3
			if (!add_host_to_hostfile(user_hostfile, ip, host_key))
				log("Failed to add the %s host key for IP address '%.128s' to the list of known hosts (%.30s).",
				    type, ip, user_hostfile);
d632 3
a634 2
				log("Warning: Permanently added the %s host key for IP address '%.128s' to the list of known hosts.",
				    type, ip);
d638 2
d642 8
a649 3
			/* User has requested strict host key checking.  We will not add the host key
			   automatically.  The only alternative left is to abort. */
			fatal("No %s host key is known for %.200s and you have requested strict checking.", type, host);
d655 2
a656 1
			    "The authenticity of host '%.200s (%s)' can't be established.\n"
d658 2
a659 2
			    "Are you sure you want to continue connecting (yes/no)? ",
			    host, ip, type, fp);
d661 4
a664 2
			if (!read_yes_or_no(prompt, -1))
				fatal("Aborted by user!");
d672 4
a675 1
		/* If not in strict mode, add the key automatically to the local known_hosts file. */
d677 2
a678 2
			log("Failed to add the host to the list of known hosts (%.500s).",
			    user_hostfile);
d680 2
a681 2
			log("Warning: Permanently added '%.200s' (%s) to the list of known hosts.",
			    hostp, type);
d723 5
a727 2
		if (options.strict_host_key_checking)
			fatal("%s host key for %.200s has changed and you have requested strict checking.", type, host);
d735 2
a736 1
			error("Password authentication is disabled to avoid trojan horses.");
d740 2
a741 1
			error("Agent forwarding is disabled to avoid trojan horses.");
d745 2
a746 1
			error("X11 forwarding is disabled to avoid trojan horses.");
d749 6
a754 3
		if (options.num_local_forwards > 0 || options.num_remote_forwards > 0) {
			error("Port forwarding is disabled to avoid trojan horses.");
			options.num_local_forwards = options.num_remote_forwards = 0;
d775 2
a776 1
			fatal("Exiting, you have requested strict checking.");
d778 5
a782 3
			if (!read_yes_or_no("Are you sure you want " \
			    "to continue connecting (yes/no)? ", -1))
				fatal("Aborted by user!");
d787 21
@


1.106
log
@remove some lines, simplify.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.105 2001/04/30 11:18:52 markus Exp $");
d794 1
a794 1
		packet_put_string(password, strlen(password));
@


1.105
log
@implement 'ssh -b bind_address' like 'telnet -b'
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.104 2001/04/12 19:15:25 markus Exp $");
a428 2
	if (compat20)
		packet_set_ssh2_format();
@


1.104
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.103 2001/04/06 21:00:14 markus Exp $");
d150 2
a151 1
	int sock;
d164 32
a195 10
	} else {
		/*
		 * Just create an ordinary socket on arbitrary port.  We use
		 * the user's uid to create the socket.
		 */
		temporarily_use_uid(pw);
		sock = socket(family, SOCK_STREAM, 0);
		if (sock < 0)
			error("socket: %.100s", strerror(errno));
		restore_uid();
d197 1
@


1.104.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.110 2001/07/25 14:35:18 markus Exp $");
a43 21
static const char *
sockaddr_ntop(struct sockaddr *sa)
{
	void *addr;
	static char addrbuf[INET6_ADDRSTRLEN];

	switch (sa->sa_family) {
		case AF_INET:
			addr = &((struct sockaddr_in *)sa)->sin_addr;
			break;
		case AF_INET6:
			addr = &((struct sockaddr_in6 *)sa)->sin6_addr;
			break;
		default:
			/* This case should be protected against elsewhere */
			abort();
	}
	inet_ntop(sa->sa_family, addr, addrbuf, sizeof(addrbuf));
	return addrbuf;
}

d47 1
a47 1
static int
d141 1
a141 2
	/* Indicate OK return */
	return 0;
d147 1
a147 1
static int
d150 1
a150 2
	int sock, gaierr;
	struct addrinfo hints, *res;
d163 10
a172 1
		return sock;
a173 32
	/*
	 * Just create an ordinary socket on arbitrary port.  We use
	 * the user's uid to create the socket.
	 */
	temporarily_use_uid(pw);
	sock = socket(family, SOCK_STREAM, 0);
	if (sock < 0)
		error("socket: %.100s", strerror(errno));
	restore_uid();

	/* Bind the socket to an alternative local IP address */
	if (options.bind_address == NULL)
		return sock;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = IPv4or6;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_PASSIVE;
	gaierr = getaddrinfo(options.bind_address, "0", &hints, &res);
	if (gaierr) {
		error("getaddrinfo: %s: %s", options.bind_address,
		    gai_strerror(gaierr));
		close(sock);
		return -1;
	}
	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
		error("bind: %s: %s", options.bind_address, strerror(errno));
		close(sock);
		freeaddrinfo(res);
		return -1;
	}
	freeaddrinfo(res);
a186 6
 * Return values:
 *    0 for OK
 *    ECONNREFUSED if we got a "Connection Refused" by the peer on any address
 *    ECONNABORTED if we failed without a "Connection refused"
 * Suitable error messages for the connection failure will already have been
 * printed.
a200 6
	/*
	 * Did we get only other errors than "Connection refused" (which
	 * should block fallback to rsh and similar), or did we get at least
	 * one "Connection refused"?
	 */
	int full_failure = 1;
d231 2
a232 2
		 */
	for (attempt = 0; ;) {
a254 1
				/* Any error is already output */
d268 1
a268 5
				if (errno == ECONNREFUSED)
					full_failure = 0;
				log("ssh: connect to address %s port %s: %s",
				    sockaddr_ntop(ai->ai_addr), strport,
				    strerror(errno));
a282 3
		attempt++;
		if (attempt >= connection_attempts)
			break;
d291 1
a291 1
		return full_failure ? ECONNABORTED : ECONNREFUSED;
d313 1
a313 1
	return 0;
d320 1
a320 1
static void
d405 2
d421 1
a421 1
static int
d444 1
a444 4
			/*
			 * Print a newline (the prompt probably didn\'t have
			 * one).
			 */
d470 1
a470 2
 * check whether the supplied host key is valid, return -1 if the key
 * is not valid. the user_hostfile will not be updated if 'readonly' is true.
d473 1
a473 1
static int
d475 1
a475 1
    int readonly, const char *user_hostfile, const char *system_hostfile)
d499 1
a499 2
		local = (ntohl(((struct sockaddr_in *)hostaddr)->
		   sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d502 1
a502 2
		local = IN6_IS_ADDR_LOOPBACK(
		    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));
d511 1
a511 1
		return 0;
d555 1
a555 2
	host_status = check_host_in_hostfile(host_file, host, host_key,
	     file_key, &host_line);
d558 1
a558 2
		host_status = check_host_in_hostfile(host_file, host, host_key,
		    file_key, &host_line);
d568 1
a568 2
		ip_status = check_host_in_hostfile(ip_file, ip, host_key,
		    ip_key, &ip_line);
d571 1
a571 2
			ip_status = check_host_in_hostfile(ip_file, ip,
			    host_key, ip_key, &ip_line);
d590 5
a594 3
			if (readonly)
				log("%s host key for IP address "
				    "'%.128s' not in list of known hosts.",
a595 9
			else if (!add_host_to_hostfile(user_hostfile, ip,
			     host_key))
				log("Failed to add the %s host key for IP "
				    "address '%.128s' to the list of known "
				    "hosts (%.30s).", type, ip, user_hostfile);
			else
				log("Warning: Permanently added the %s host "
				    "key for IP address '%.128s' to the list "
				    "of known hosts.", type, ip);
a598 2
		if (readonly)
			goto fail;
d601 3
a603 8
			/*
			 * User has requested strict host key checking.  We
			 * will not add the host key automatically.  The only
			 * alternative left is to abort.
			 */
			error("No %s host key is known for %.200s and you "
			    "have requested strict checking.", type, host);
			goto fail;
d609 1
a609 2
			    "The authenticity of host '%.200s (%s)' can't be "
			    "established.\n"
d611 2
a612 2
			    "Are you sure you want to continue connecting "
			    "(yes/no)? ", host, ip, type, fp);
d614 2
a615 4
			if (!read_yes_or_no(prompt, -1)) {
				log("Aborted by user!");
				goto fail;
			}
d623 1
a623 4
		/*
		 * If not in strict mode, add the key automatically to the
		 * local known_hosts file.
		 */
d625 2
a626 2
			log("Failed to add the host to the list of known "
			    "hosts (%.500s).", user_hostfile);
d628 2
a629 2
			log("Warning: Permanently added '%.200s' (%s) to the "
			    "list of known hosts.", hostp, type);
d671 2
a672 5
		if (options.strict_host_key_checking) {
			error("%s host key for %.200s has changed and you have "
			    "requested strict checking.", type, host);
			goto fail;
		}
d680 1
a680 2
			error("Password authentication is disabled to avoid "
			    "man-in-the-middle attacks.");
d684 1
a684 2
			error("Agent forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
d688 1
a688 2
			error("X11 forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
d691 3
a693 6
		if (options.num_local_forwards > 0 ||
		    options.num_remote_forwards > 0) {
			error("Port forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.num_local_forwards =
			     options.num_remote_forwards = 0;
d714 1
a714 2
			error("Exiting, you have requested strict checking.");
			goto fail;
d716 3
a718 5
			if (!read_yes_or_no("Are you sure you want " 
			    "to continue connecting (yes/no)? ", -1)) {
				log("Aborted by user!");
				goto fail;
			}
a722 21
	return 0;

fail:
	xfree(ip);
	return -1;
}

int
verify_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)
{
	struct stat st;

	/* return ok if the key can be found in an old keyfile */
	if (stat(options.system_hostfile2, &st) == 0 ||
	    stat(options.user_hostfile2, &st) == 0) {
		if (check_host_key(host, hostaddr, host_key, /*readonly*/ 1,
		    options.user_hostfile2, options.system_hostfile2) == 0)
			return 0;
	}
	return check_host_key(host, hostaddr, host_key, /*readonly*/ 0,
	    options.user_hostfile, options.system_hostfile);
d772 1
a772 1
		packet_put_cstring(password);
@


1.104.2.2
log
@Merge OpenSSH 3.0
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.104.2.1 2001/09/27 19:03:55 jason Exp $");
d41 3
d203 1
a203 1
	hints.ai_family = family;
d242 3
a244 2
    u_short port, int family, int connection_attempts,
    int anonymous, struct passwd *pw, const char *proxy_command)
d278 1
a278 1
	hints.ai_family = family;
d486 1
a486 1
confirm(const char *prompt)
d494 1
d499 1
d502 1
d504 1
a504 1
	fprintf(stderr, "%s", prompt);
d506 1
d508 4
d518 3
d526 1
a526 1
			fprintf(stderr, "Please type 'yes' or 'no': ");
d578 1
a578 2
	if (options.no_host_authentication_for_localhost == 1 && local &&
	    options.host_key_alias == NULL) {
d703 2
a704 1
			if (!confirm(prompt)) {
d820 3
a822 2
			if (!confirm("Are you sure you want " 
			    "to continue connecting (yes/no)? ")) {
@


1.104.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.119 2002/01/21 15:13:51 markus Exp $");
a33 1
#include "readpass.h"
d48 9
a56 9
	case AF_INET:
		addr = &((struct sockaddr_in *)sa)->sin_addr;
		break;
	case AF_INET6:
		addr = &((struct sockaddr_in6 *)sa)->sin6_addr;
		break;
	default:
		/* This case should be protected against elsewhere */
		abort();	/* XXX abort is bad -- do something else */
d108 1
a108 1
		    strerror(errno));
d257 1
a257 1
	    (u_int) getuid(), (u_int) geteuid(), anonymous);
d335 1
d424 1
a424 1
	    remote_major, remote_minor, remote_version);
d429 1
a429 1
	switch (remote_major) {
d484 3
a486 3
	const char *msg, *again = "Please type 'yes' or 'no': ";
	char *p;
	int ret = -1;
d490 28
a517 12
	for (msg = prompt;;msg = again) {
		p = read_passphrase(msg, RP_ECHO);
		if (p == NULL ||
		    (p[0] == '\0') || (p[0] == '\n') ||
		    strncasecmp(p, "no", 2) == 0)
			ret = 0;
		if (strncasecmp(p, "yes", 3) == 0)
			ret = 1;
		if (p)
			xfree(p);
		if (ret != -1)
			return ret;
d538 1
a538 2
	char msg[1024];
	int len, host_line, ip_line;
d612 1
a612 1
	    file_key, &host_line);
d655 1
a655 1
			    host_key))
d680 1
d682 1
a682 1
			snprintf(msg, sizeof(msg),
d689 1
a689 1
			if (!confirm(msg))
d691 1
d781 1
a781 1
			    options.num_remote_forwards = 0;
d795 6
a800 11
		snprintf(msg, sizeof(msg),
		    "Warning: the %s host key for '%.200s' "
		    "differs from the key for the IP address '%.128s'"
		    "\nOffending key for IP in %s:%d",
		    type, host, ip, ip_file, ip_line);
		if (host_status == HOST_OK) {
			len = strlen(msg);
			snprintf(msg + len, sizeof(msg) - len,
			    "\nMatching host key in %s:%d",
			     host_file, host_line);
		}
a801 1
			log(msg);
d805 2
a806 3
			strlcat(msg, "\nAre you sure you want "
			    "to continue connecting (yes/no)? ", sizeof(msg));
			if (!confirm(msg))
d808 1
a808 2
		} else {
			log(msg);
@


1.103
log
@do gid/groups-swap in addition to uid-swap, should help if /home/group
is chmod 750 + chgrp grp /home/group/, work be deraadt and me, thanks
to olar@@openwall.com is comments.  we had many requests for this.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.102 2001/04/05 10:42:55 markus Exp $");
d733 1
a733 1
ssh_login(Key *own_host_key, const char *orighost,
d758 1
a758 1
		ssh_userauth2(server_user, host);
d761 1
a761 1
		ssh_userauth(local_user, server_user, host, own_host_key);
@


1.102
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.101 2001/03/26 08:07:09 markus Exp $");
d48 1
a48 1
ssh_proxy_connect(const char *host, u_short port, uid_t original_real_uid,
d99 1
a99 1
		permanently_set_uid(original_real_uid);
d148 1
a148 1
ssh_create_socket(uid_t original_real_uid, int privileged, int family)
d168 1
a168 1
		temporarily_use_uid(original_real_uid);
d191 1
a191 1
	    int anonymous, uid_t original_real_uid,
d215 1
a215 1
		return ssh_proxy_connect(host, port, original_real_uid, proxy_command);
d251 1
a251 1
			sock = ssh_create_socket(original_real_uid,
d261 1
a261 1
			temporarily_use_uid(original_real_uid);
d734 1
a734 1
    struct sockaddr *hostaddr, uid_t original_real_uid)
a735 1
	struct passwd *pw;
a738 4
	/* Get local user name.  Use it as server user if no user name was given. */
	pw = getpwuid(original_real_uid);
	if (!pw)
		fatal("User id %u not found from user database.", original_real_uid);
@


1.101
log
@simpler key load/save interface, see authfile.h
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.100 2001/03/12 22:02:02 markus Exp $");
d264 1
a264 1
				memcpy(hostaddr, ai->ai_addr, ai->ai_addrlen); 
@


1.100
log
@remove old key_fingerprint interface, s/_ex//
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.99 2001/03/10 15:31:00 deraadt Exp $");
d733 1
a733 1
ssh_login(int host_key_valid, RSA *own_host_key, const char *orighost,
d766 1
a766 1
		ssh_userauth(local_user, server_user, host, host_key_valid, own_host_key);
@


1.99
log
@all known netscreen ssh versions, and older versions of OSU ssh cannot
handle password padding (newer OSU is fixed)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.98 2001/03/04 17:42:28 millert Exp $");
d480 1
a480 1
	char hostline[1000], *hostp;
d607 1
d612 2
a613 1
			    host, ip, type, key_fingerprint(host_key));
d652 1
d660 1
a660 1
		    type, key_fingerprint(host_key));
d665 1
@


1.98
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.97 2001/02/15 23:19:59 markus Exp $");
d772 4
@


1.97
log
@genericize password padding function for SSH1 and SSH2.
add stylized echo to 2, too.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.96 2001/02/08 22:35:30 markus Exp $");
d613 1
a613 1
				fatal("Aborted by user!\n");
d714 1
a714 1
				fatal("Aborted by user!\n");
@


1.96
log
@don't connect if batch_mode is true and stricthostkeychecking set to 'ask'
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.95 2001/02/08 19:30:52 itojun Exp $");
d764 15
@


1.95
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.94 2001/02/08 10:47:04 itojun Exp $");
d420 1
d427 3
@


1.94
log
@%.30s is too short for IPv6 numeric address.  use %.128s for now.  markus ok
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.93 2001/02/04 15:32:26 stevesk Exp $");
d321 1
a321 1
ssh_exchange_identification()
d430 1
a430 1
		f = fopen("/dev/tty", "rw");
@


1.93
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.92 2001/01/30 22:48:52 djm Exp $");
d587 1
a587 1
				log("Failed to add the %s host key for IP address '%.30s' to the list of known hosts (%.30s).",
d590 1
a590 1
				log("Warning: Permanently added the %s host key for IP address '%.30s' to the list of known hosts.",
d700 1
a700 1
		    "differs from the key for the IP address '%.30s'",
@


1.92
log
@Make warning message a little more consistent. ok markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.91 2001/01/21 19:05:59 markus Exp $");
d327 1
a327 1
	int minor1 = PROTOCOL_MINOR_1; 
d683 1
a683 1
	        if (options.num_local_forwards > 0 || options.num_remote_forwards > 0) {
@


1.91
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.90 2001/01/13 18:32:50 markus Exp $");
d708 2
a709 1
			if (!read_yes_or_no("Continue?", -1))
@


1.90
log
@split out keepalive from packet_interactive (from dale@@accentre.com)
set IPTOS_LOWDELAY TCP_NODELAY IPTOS_THROUGHPUT for ssh2, too.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.89 2001/01/04 22:41:03 markus Exp $");
a18 2
#include <openssl/dsa.h>
#include <openssl/rsa.h>
d20 1
a22 1
#include "ssh.h"
a26 1
#include "readconf.h"
d30 4
d40 3
@


1.89
log
@consistent use of _PATH_BSHELL; from stevesk@@pobox.com
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.88 2001/01/02 20:50:56 markus Exp $");
d190 2
d193 1
a193 1
	struct servent *sp;
a194 2
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
	int gaierr;
d196 1
d298 7
a304 1
	setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *) &linger, sizeof(linger));
@


1.88
log
@strict_host_key_checking for host_status != HOST_CHANGED && ip_status == HOST_CHANGED
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.87 2000/12/28 14:25:03 markus Exp $");
d112 1
a112 1
		argv[0] = "/bin/sh";
d119 2
a120 2
		execv("/bin/sh", argv);
		perror("/bin/sh");
@


1.87
log
@fingerprint for MITM attacks, too
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.86 2000/12/27 12:30:20 markus Exp $");
d416 1
a416 1
	if (isatty(0))
d470 1
a470 1
	int host_line = -1, ip_line = -1;
d493 4
a496 8
	if (local) {
		if (options.host_key_alias == NULL) {
			debug("Forcing accepting of host key for "
			    "loopback/localhost.");
			return;
		}
		if (options.check_host_ip)
			options.check_host_ip = 0;
d500 2
a501 2
	 * Turn off check_host_ip for proxy connects, since
	 * we don't have the remote ip-address
a502 3
	if (options.proxy_command != NULL && options.check_host_ip)
		options.check_host_ip = 0;

d511 7
d549 1
a549 1
	if (options.check_host_ip && !local && strcmp(host, ip)) {
d574 7
a580 15
		if (options.check_host_ip) {
			if (ip_status == HOST_NEW) {
				if (!add_host_to_hostfile(user_hostfile, ip, host_key))
					log("Failed to add the %s host key for IP address '%.30s' to the list of known hosts (%.30s).",
					    type, ip, user_hostfile);
				else
					log("Warning: Permanently added the %s host key for IP address '%.30s' to the list of known hosts.",
					    type, ip);
			} else if (ip_status != HOST_OK) {
				log("Warning: the %s host key for '%.200s' differs from the key for the IP address '%.30s'",
				    type, host, ip);
				log("Found key in %s:%d", host_file, host_line);
				if (ip_line != -1)
					log("Offending key for IP in %s:%d", ip_file, ip_line);
			}
d600 1
a600 1
		if (options.check_host_ip && ip_status == HOST_NEW && strcmp(host, ip)) {
d631 1
a631 1
			if (ip_line != -1)
d684 16
@


1.86
log
@new option: HostKeyAlias: allows the user to record the host key
under a different name. This is useful for ssh tunneling over
forwarded connections or if you run multiple sshd's on different
ports on the same machine.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.85 2000/12/21 15:10:17 markus Exp $");
a599 1
			char *fp = key_fingerprint(host_key);
d604 1
a604 1
			    host, ip, type, fp);
d649 2
d653 1
a653 1
		      user_hostfile);
@


1.85
log
@print keyfile:line for changed hostkeys, for deraadt@@; ok deraadt@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.84 2000/12/20 19:27:55 markus Exp $");
d494 7
a500 2
		debug("Forcing accepting of host key for loopback/localhost.");
		return;
d512 1
a512 1
				NULL, 0, NI_NUMERICHOST) != 0)
d517 10
@


1.84
log
@cannot get ip for remote host if proxy_command is used
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.83 2000/11/30 22:53:35 markus Exp $");
d470 2
d524 6
a529 3
	host_status = check_host_in_hostfile(user_hostfile, host, host_key, file_key);
	if (host_status == HOST_NEW)
		host_status = check_host_in_hostfile(system_hostfile, host, host_key, file_key);
a535 1
		ip_status = check_host_in_hostfile(user_hostfile, ip, host_key, ip_key);
d537 6
a542 2
		if (ip_status == HOST_NEW)
			ip_status = check_host_in_hostfile(system_hostfile, ip, host_key, ip_key);
d558 1
d567 1
a567 1
			} else if (ip_status != HOST_OK)
d570 4
d624 3
a626 1
			error("and its host key have changed at the same time");
d638 1
@


1.83
log
@disable agent/x11/port fwding if hostkey has changed; ok niels@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.82 2000/11/29 13:51:27 provos Exp $");
d503 8
a510 4
	if (getnameinfo(hostaddr, hostaddr->sa_len, ntop, sizeof(ntop),
			NULL, 0, NI_NUMERICHOST) != 0)
		fatal("check_host_key: getnameinfo failed");
	ip = xstrdup(ntop);
@


1.82
log
@show IP address and hostname when new key is encountered. okay markus@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.81 2000/11/06 23:16:35 markus Exp $");
d639 8
@


1.81
log
@downgrade client to 1.3 if server is 1.4; help from mdb@@juniper.net
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.80 2000/11/06 23:13:26 markus Exp $");
d503 4
a506 6
	if (options.check_host_ip) {
		if (getnameinfo(hostaddr, hostaddr->sa_len, ntop, sizeof(ntop),
		    NULL, 0, NI_NUMERICHOST) != 0)
			fatal("check_host_key: getnameinfo failed");
		ip = xstrdup(ntop);
	}
d570 1
a570 1
			    "The authenticity of host '%.200s' can't be established.\n"
d573 1
a573 1
			    host, type, fp);
d649 2
a650 2
	if (options.check_host_ip)
		xfree(ip);
@


1.80
log
@do not disabled rhosts(rsa) if server port > 1024; from pekkas@@netcore.fi
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.79 2000/09/17 15:52:51 markus Exp $");
d316 1
d370 1
a370 1
		} else if (remote_minor == 3) {
d373 1
d399 1
a399 1
	    compat20 ? PROTOCOL_MINOR_2 : PROTOCOL_MINOR_1,
@


1.79
log
@yes no; ok niels@@
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.78 2000/09/07 20:27:54 deraadt Exp $");
d247 1
a247 1
			    !anonymous && geteuid() == 0 && port < IPPORT_RESERVED,
@


1.79.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.97 2001/02/15 23:19:59 markus Exp $");
d19 2
a21 1
#include "ssh.h"
d24 1
d29 1
a32 4
#include "log.h"
#include "readconf.h"
#include "atomicio.h"
#include "misc.h"
a39 3
/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

d112 1
a112 1
		argv[0] = _PATH_BSHELL;
d119 2
a120 2
		execv(argv[0], argv);
		perror(argv[0]);
a189 2
	int gaierr;
	int on = 1;
d191 2
d194 1
a194 1
	struct addrinfo hints, *ai, *aitop;
a195 1
	struct servent *sp;
d247 1
a247 1
			    !anonymous && geteuid() == 0,
d297 1
a297 7
	setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof(linger));

	/* Set keepalives if requested. */
	if (options.keepalives &&
	    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
	    sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));
d310 1
a310 1
ssh_exchange_identification(void)
a315 1
	int minor1 = PROTOCOL_MINOR_1;
d369 1
a369 1
		} else if (remote_minor == 3 || remote_minor == 4) {
a371 1
			minor1 = 3;
d397 1
a397 1
	    compat20 ? PROTOCOL_MINOR_2 : minor1,
a406 1
/* defaults to 'no' */
d414 1
a414 4
	if (options.batch_mode)
		return 0;

	if (isatty(STDIN_FILENO))
d417 1
a417 1
		f = fopen(_PATH_TTY, "rw");
a467 2
	int host_line, ip_line;
	const char *host_file = NULL, *ip_file = NULL;
d489 2
a490 3
	if (local && options.host_key_alias == NULL) {
		debug("Forcing accepting of host key for "
		    "loopback/localhost.");
d495 2
a496 2
	 * We don't have the remote ip-address for connections
	 * using a proxy command
d498 4
a501 1
	if (options.proxy_command == NULL) {
a505 19
	} else {
		ip = xstrdup("<no hostip for proxy command>");
	}
	/*
	 * Turn off check_host_ip if the connection is to localhost, via proxy
	 * command or if we don't have a hostname to compare with
	 */
	if (options.check_host_ip &&
	    (local || strcmp(host, ip) == 0 || options.proxy_command != NULL))
		options.check_host_ip = 0;

	/*
	 * Allow the user to record the key under a different name. This is
	 * useful for ssh tunneling over forwarded connections or if you run
	 * multiple sshd's on different ports on the same machine.
	 */
	if (options.host_key_alias != NULL) {
		host = options.host_key_alias;
		debug("using hostkeyalias: %s", host);
d518 3
a520 6
	host_file = user_hostfile;
	host_status = check_host_in_hostfile(host_file, host, host_key, file_key, &host_line);
	if (host_status == HOST_NEW) {
		host_file = system_hostfile;
		host_status = check_host_in_hostfile(host_file, host, host_key, file_key, &host_line);
	}
d525 1
a525 1
	if (options.check_host_ip) {
d527 1
d529 2
a530 6
		ip_file = user_hostfile;
		ip_status = check_host_in_hostfile(ip_file, ip, host_key, ip_key, &ip_line);
		if (ip_status == HOST_NEW) {
			ip_file = system_hostfile;
			ip_status = check_host_in_hostfile(ip_file, ip, host_key, ip_key, &ip_line);
		}
d546 11
a556 8
		debug("Found key in %s:%d", host_file, host_line);
		if (options.check_host_ip && ip_status == HOST_NEW) {
			if (!add_host_to_hostfile(user_hostfile, ip, host_key))
				log("Failed to add the %s host key for IP address '%.128s' to the list of known hosts (%.30s).",
				    type, ip, user_hostfile);
			else
				log("Warning: Permanently added the %s host key for IP address '%.128s' to the list of known hosts.",
				    type, ip);
d568 1
d570 1
a570 1
			    "The authenticity of host '%.200s (%s)' can't be established.\n"
d573 1
a573 1
			    host, ip, type, key_fingerprint(host_key));
d577 1
a577 1
		if (options.check_host_ip && ip_status == HOST_NEW) {
d607 1
a607 3
			error("and its host key have changed at the same time.");
			if (ip_status != HOST_NEW)
				error("Offending key for IP in %s:%d", ip_file, ip_line);
a615 2
		error("The fingerprint for the %s key sent by the remote host is\n%s.",
		    type, key_fingerprint(host_key));
d618 1
a618 2
		    user_hostfile);
		error("Offending key in %s:%d", host_file, host_line);
a639 8
		if (options.forward_x11) {
			error("X11 forwarding is disabled to avoid trojan horses.");
			options.forward_x11 = 0;
		}
		if (options.num_local_forwards > 0 || options.num_remote_forwards > 0) {
			error("Port forwarding is disabled to avoid trojan horses.");
			options.num_local_forwards = options.num_remote_forwards = 0;
		}
d649 2
a650 19

	if (options.check_host_ip && host_status != HOST_CHANGED &&
	    ip_status == HOST_CHANGED) {
		log("Warning: the %s host key for '%.200s' "
		    "differs from the key for the IP address '%.128s'",
		    type, host, ip);
		if (host_status == HOST_OK)
			log("Matching host key in %s:%d", host_file, host_line);
		log("Offending key for IP in %s:%d", ip_file, ip_line);
		if (options.strict_host_key_checking == 1) {
			fatal("Exiting, you have requested strict checking.");
		} else if (options.strict_host_key_checking == 2) {
			if (!read_yes_or_no("Are you sure you want " \
			    "to continue connecting (yes/no)? ", -1))
				fatal("Aborted by user!\n");
		}
	}

	xfree(ip);
a695 15
}

void
ssh_put_password(char *password)
{
	int size;
	char *padded;

	size = roundup(strlen(password) + 1, 32);
	padded = xmalloc(size);
	memset(padded, 0, size);
	strlcpy(padded, password, size);
	packet_put_string(padded, size);
	memset(padded, 0, size);
	xfree(padded);
@


1.79.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.79.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.100 2001/03/12 22:02:02 markus Exp $");
d480 1
a480 1
	char hostline[1000], *hostp, *fp;
a606 1
			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
d611 1
a611 2
			    host, ip, type, fp);
			xfree(fp);
d613 1
a613 1
				fatal("Aborted by user!");
a649 1
		fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
d657 1
a657 1
		    type, fp);
a661 1
		xfree(fp);
d714 1
a714 1
				fatal("Aborted by user!");
a771 4
	if (datafellows & SSH_BUG_PASSWORDPAD) {
		packet_put_string(password, strlen(password));
		return;
	}
@


1.79.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.104 2001/04/12 19:15:25 markus Exp $");
d48 1
a48 1
ssh_proxy_connect(const char *host, u_short port, struct passwd *pw,
d99 1
a99 1
		permanently_set_uid(pw);
d148 1
a148 1
ssh_create_socket(struct passwd *pw, int privileged, int family)
d168 1
a168 1
		temporarily_use_uid(pw);
d191 1
a191 1
	    int anonymous, struct passwd *pw,
d215 1
a215 1
		return ssh_proxy_connect(host, port, pw, proxy_command);
d251 1
a251 1
			sock = ssh_create_socket(pw,
d261 1
a261 1
			temporarily_use_uid(pw);
d264 1
a264 1
				memcpy(hostaddr, ai->ai_addr, ai->ai_addrlen);
d733 2
a734 2
ssh_login(Key **keys, int nkeys, const char *orighost,
    struct sockaddr *hostaddr, struct passwd *pw)
d736 1
d740 4
d763 1
a763 1
		ssh_userauth2(local_user, server_user, host, keys, nkeys);
d766 1
a766 1
		ssh_userauth1(local_user, server_user, host, keys, nkeys);
@


1.79.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.110 2001/07/25 14:35:18 markus Exp $");
a43 21
static const char *
sockaddr_ntop(struct sockaddr *sa)
{
	void *addr;
	static char addrbuf[INET6_ADDRSTRLEN];

	switch (sa->sa_family) {
		case AF_INET:
			addr = &((struct sockaddr_in *)sa)->sin_addr;
			break;
		case AF_INET6:
			addr = &((struct sockaddr_in6 *)sa)->sin6_addr;
			break;
		default:
			/* This case should be protected against elsewhere */
			abort();
	}
	inet_ntop(sa->sa_family, addr, addrbuf, sizeof(addrbuf));
	return addrbuf;
}

d47 1
a47 1
static int
d141 1
a141 2
	/* Indicate OK return */
	return 0;
d147 1
a147 1
static int
d150 1
a150 2
	int sock, gaierr;
	struct addrinfo hints, *res;
d163 10
a172 1
		return sock;
a173 32
	/*
	 * Just create an ordinary socket on arbitrary port.  We use
	 * the user's uid to create the socket.
	 */
	temporarily_use_uid(pw);
	sock = socket(family, SOCK_STREAM, 0);
	if (sock < 0)
		error("socket: %.100s", strerror(errno));
	restore_uid();

	/* Bind the socket to an alternative local IP address */
	if (options.bind_address == NULL)
		return sock;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = IPv4or6;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_PASSIVE;
	gaierr = getaddrinfo(options.bind_address, "0", &hints, &res);
	if (gaierr) {
		error("getaddrinfo: %s: %s", options.bind_address,
		    gai_strerror(gaierr));
		close(sock);
		return -1;
	}
	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
		error("bind: %s: %s", options.bind_address, strerror(errno));
		close(sock);
		freeaddrinfo(res);
		return -1;
	}
	freeaddrinfo(res);
a186 6
 * Return values:
 *    0 for OK
 *    ECONNREFUSED if we got a "Connection Refused" by the peer on any address
 *    ECONNABORTED if we failed without a "Connection refused"
 * Suitable error messages for the connection failure will already have been
 * printed.
a200 6
	/*
	 * Did we get only other errors than "Connection refused" (which
	 * should block fallback to rsh and similar), or did we get at least
	 * one "Connection refused"?
	 */
	int full_failure = 1;
d231 2
a232 2
		 */
	for (attempt = 0; ;) {
a254 1
				/* Any error is already output */
d268 1
a268 5
				if (errno == ECONNREFUSED)
					full_failure = 0;
				log("ssh: connect to address %s port %s: %s",
				    sockaddr_ntop(ai->ai_addr), strport,
				    strerror(errno));
a282 3
		attempt++;
		if (attempt >= connection_attempts)
			break;
d291 1
a291 1
		return full_failure ? ECONNABORTED : ECONNREFUSED;
d313 1
a313 1
	return 0;
d320 1
a320 1
static void
d405 2
d421 1
a421 1
static int
d444 1
a444 4
			/*
			 * Print a newline (the prompt probably didn\'t have
			 * one).
			 */
d470 1
a470 2
 * check whether the supplied host key is valid, return -1 if the key
 * is not valid. the user_hostfile will not be updated if 'readonly' is true.
d473 1
a473 1
static int
d475 1
a475 1
    int readonly, const char *user_hostfile, const char *system_hostfile)
d499 1
a499 2
		local = (ntohl(((struct sockaddr_in *)hostaddr)->
		   sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d502 1
a502 2
		local = IN6_IS_ADDR_LOOPBACK(
		    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));
d511 1
a511 1
		return 0;
d555 1
a555 2
	host_status = check_host_in_hostfile(host_file, host, host_key,
	     file_key, &host_line);
d558 1
a558 2
		host_status = check_host_in_hostfile(host_file, host, host_key,
		    file_key, &host_line);
d568 1
a568 2
		ip_status = check_host_in_hostfile(ip_file, ip, host_key,
		    ip_key, &ip_line);
d571 1
a571 2
			ip_status = check_host_in_hostfile(ip_file, ip,
			    host_key, ip_key, &ip_line);
d590 5
a594 3
			if (readonly)
				log("%s host key for IP address "
				    "'%.128s' not in list of known hosts.",
a595 9
			else if (!add_host_to_hostfile(user_hostfile, ip,
			     host_key))
				log("Failed to add the %s host key for IP "
				    "address '%.128s' to the list of known "
				    "hosts (%.30s).", type, ip, user_hostfile);
			else
				log("Warning: Permanently added the %s host "
				    "key for IP address '%.128s' to the list "
				    "of known hosts.", type, ip);
a598 2
		if (readonly)
			goto fail;
d601 3
a603 8
			/*
			 * User has requested strict host key checking.  We
			 * will not add the host key automatically.  The only
			 * alternative left is to abort.
			 */
			error("No %s host key is known for %.200s and you "
			    "have requested strict checking.", type, host);
			goto fail;
d609 1
a609 2
			    "The authenticity of host '%.200s (%s)' can't be "
			    "established.\n"
d611 2
a612 2
			    "Are you sure you want to continue connecting "
			    "(yes/no)? ", host, ip, type, fp);
d614 2
a615 4
			if (!read_yes_or_no(prompt, -1)) {
				log("Aborted by user!");
				goto fail;
			}
d623 1
a623 4
		/*
		 * If not in strict mode, add the key automatically to the
		 * local known_hosts file.
		 */
d625 2
a626 2
			log("Failed to add the host to the list of known "
			    "hosts (%.500s).", user_hostfile);
d628 2
a629 2
			log("Warning: Permanently added '%.200s' (%s) to the "
			    "list of known hosts.", hostp, type);
d671 2
a672 5
		if (options.strict_host_key_checking) {
			error("%s host key for %.200s has changed and you have "
			    "requested strict checking.", type, host);
			goto fail;
		}
d680 1
a680 2
			error("Password authentication is disabled to avoid "
			    "man-in-the-middle attacks.");
d684 1
a684 2
			error("Agent forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
d688 1
a688 2
			error("X11 forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
d691 3
a693 6
		if (options.num_local_forwards > 0 ||
		    options.num_remote_forwards > 0) {
			error("Port forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.num_local_forwards =
			     options.num_remote_forwards = 0;
d714 1
a714 2
			error("Exiting, you have requested strict checking.");
			goto fail;
d716 3
a718 5
			if (!read_yes_or_no("Are you sure you want " 
			    "to continue connecting (yes/no)? ", -1)) {
				log("Aborted by user!");
				goto fail;
			}
a722 21
	return 0;

fail:
	xfree(ip);
	return -1;
}

int
verify_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)
{
	struct stat st;

	/* return ok if the key can be found in an old keyfile */
	if (stat(options.system_hostfile2, &st) == 0 ||
	    stat(options.user_hostfile2, &st) == 0) {
		if (check_host_key(host, hostaddr, host_key, /*readonly*/ 1,
		    options.user_hostfile2, options.system_hostfile2) == 0)
			return 0;
	}
	return check_host_key(host, hostaddr, host_key, /*readonly*/ 0,
	    options.user_hostfile, options.system_hostfile);
d772 1
a772 1
		packet_put_cstring(password);
@


1.79.2.6
log
@Merge OpenSSH 3.0
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.79.2.5 2001/09/27 00:15:43 miod Exp $");
d41 3
d203 1
a203 1
	hints.ai_family = family;
d242 3
a244 2
    u_short port, int family, int connection_attempts,
    int anonymous, struct passwd *pw, const char *proxy_command)
d278 1
a278 1
	hints.ai_family = family;
d486 1
a486 1
confirm(const char *prompt)
d494 1
d499 1
d502 1
d504 1
a504 1
	fprintf(stderr, "%s", prompt);
d506 1
d508 4
d518 3
d526 1
a526 1
			fprintf(stderr, "Please type 'yes' or 'no': ");
d578 1
a578 2
	if (options.no_host_authentication_for_localhost == 1 && local &&
	    options.host_key_alias == NULL) {
d703 2
a704 1
			if (!confirm(prompt)) {
d820 3
a822 2
			if (!confirm("Are you sure you want " 
			    "to continue connecting (yes/no)? ")) {
@


1.79.2.7
log
@Merge OpenSSH 3.1.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.119 2002/01/21 15:13:51 markus Exp $");
a33 1
#include "readpass.h"
d48 9
a56 9
	case AF_INET:
		addr = &((struct sockaddr_in *)sa)->sin_addr;
		break;
	case AF_INET6:
		addr = &((struct sockaddr_in6 *)sa)->sin6_addr;
		break;
	default:
		/* This case should be protected against elsewhere */
		abort();	/* XXX abort is bad -- do something else */
d108 1
a108 1
		    strerror(errno));
d257 1
a257 1
	    (u_int) getuid(), (u_int) geteuid(), anonymous);
d335 1
d424 1
a424 1
	    remote_major, remote_minor, remote_version);
d429 1
a429 1
	switch (remote_major) {
d484 3
a486 3
	const char *msg, *again = "Please type 'yes' or 'no': ";
	char *p;
	int ret = -1;
d490 28
a517 12
	for (msg = prompt;;msg = again) {
		p = read_passphrase(msg, RP_ECHO);
		if (p == NULL ||
		    (p[0] == '\0') || (p[0] == '\n') ||
		    strncasecmp(p, "no", 2) == 0)
			ret = 0;
		if (strncasecmp(p, "yes", 3) == 0)
			ret = 1;
		if (p)
			xfree(p);
		if (ret != -1)
			return ret;
d538 1
a538 2
	char msg[1024];
	int len, host_line, ip_line;
d612 1
a612 1
	    file_key, &host_line);
d655 1
a655 1
			    host_key))
d680 1
d682 1
a682 1
			snprintf(msg, sizeof(msg),
d689 1
a689 1
			if (!confirm(msg))
d691 1
d781 1
a781 1
			    options.num_remote_forwards = 0;
d795 6
a800 11
		snprintf(msg, sizeof(msg),
		    "Warning: the %s host key for '%.200s' "
		    "differs from the key for the IP address '%.128s'"
		    "\nOffending key for IP in %s:%d",
		    type, host, ip, ip_file, ip_line);
		if (host_status == HOST_OK) {
			len = strlen(msg);
			snprintf(msg + len, sizeof(msg) - len,
			    "\nMatching host key in %s:%d",
			     host_file, host_line);
		}
a801 1
			log(msg);
d805 2
a806 3
			strlcat(msg, "\nAre you sure you want "
			    "to continue connecting (yes/no)? ", sizeof(msg));
			if (!confirm(msg))
d808 1
a808 2
		} else {
			log(msg);
@


1.78
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.77 2000/08/28 03:50:54 deraadt Exp $");
d439 1
a439 1
		if (strcmp(buf, "no") == 0)
d441 2
@


1.77
log
@print uid/gid as unsigned
@
text
@a4 1
 * Created: Sat Mar 18 22:15:47 1995 ylo
d7 6
d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.76 2000/06/17 20:30:10 markus Exp $");
@


1.76
log
@missing atomicio, typo
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.75 2000/06/17 19:24:34 markus Exp $");
d192 2
a193 2
	debug("ssh_connect: getuid %d geteuid %d anon %d",
	      (int) getuid(), (int) geteuid(), anonymous);
d664 1
a664 1
		fatal("User id %d not found from user database.", original_real_uid);
@


1.75
log
@allow extended server banners
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.74 2000/05/17 16:57:02 markus Exp $");
d315 1
a315 1
			int len = read(connection_in, &buf[i], 1);
d331 1
a331 1
		if (strncmp(buf, "SSH-", 4))
@


1.74
log
@copy only ai_addrlen bytes; misiek@@pld.org.pl
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.73 2000/05/17 08:20:15 markus Exp $");
d313 16
a328 10
	for (i = 0; i < sizeof(buf) - 1; i++) {
		int len = read(connection_in, &buf[i], 1);
		if (len < 0)
			fatal("ssh_exchange_identification: read: %.100s", strerror(errno));
		if (len != 1)
			fatal("ssh_exchange_identification: Connection closed by remote host");
		if (buf[i] == '\r') {
			buf[i] = '\n';
			buf[i + 1] = 0;
			continue;		/**XXX wait for \n */
d330 2
a331 2
		if (buf[i] == '\n') {
			buf[i + 1] = 0;
d333 1
a333 1
		}
a334 1
	buf[sizeof(buf) - 1] = 0;
@


1.73
log
@enable nonblocking IO for sshd w/ proto 1, too; split out common code
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.72 2000/05/04 09:50:22 markus Exp $");
d254 1
a254 1
				memcpy(hostaddr, ai->ai_addr, sizeof(*hostaddr));
@


1.72
log
@print key type when talking about host keys
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.71 2000/04/26 21:28:33 markus Exp $");
a297 15
}

char *
chop(char *s)
{
	char *t = s;
	while (*t) {
		if(*t == '\n' || *t == '\r') {
			*t = '\0';
			return s;
		}
		t++;
	}
	return s;

@


1.72.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.74 2000/05/17 16:57:02 markus Exp $");
d254 1
a254 1
				memcpy(hostaddr, ai->ai_addr, ai->ai_addrlen); 
d298 15
@


1.72.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.77 2000/08/28 03:50:54 deraadt Exp $");
d192 2
a193 2
	debug("ssh_connect: getuid %u geteuid %u anon %d",
	      (u_int) getuid(), (u_int) geteuid(), anonymous);
d313 10
a322 16
	for (;;) {
		for (i = 0; i < sizeof(buf) - 1; i++) {
			int len = atomicio(read, connection_in, &buf[i], 1);
			if (len < 0)
				fatal("ssh_exchange_identification: read: %.100s", strerror(errno));
			if (len != 1)
				fatal("ssh_exchange_identification: Connection closed by remote host");
			if (buf[i] == '\r') {
				buf[i] = '\n';
				buf[i + 1] = 0;
				continue;		/**XXX wait for \n */
			}
			if (buf[i] == '\n') {
				buf[i + 1] = 0;
				break;
			}
d324 2
a325 2
		buf[sizeof(buf) - 1] = 0;
		if (strncmp(buf, "SSH-", 4) == 0)
d327 1
a327 1
		debug("ssh_exchange_identification: %s", buf);
d329 1
d659 1
a659 1
		fatal("User id %u not found from user database.", original_real_uid);
@


1.72.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
a7 6
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.79 2000/09/17 15:52:51 markus Exp $");
d434 1
a434 1
		else if (strcmp(buf, "no") == 0)
a435 2
		else
			fprintf(stderr, "Please type 'yes' or 'no'.\n");
@


1.72.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.97 2001/02/15 23:19:59 markus Exp $");
d19 2
a21 1
#include "ssh.h"
d24 1
d29 1
a32 4
#include "log.h"
#include "readconf.h"
#include "atomicio.h"
#include "misc.h"
a39 3
/* AF_UNSPEC or AF_INET or AF_INET6 */
extern int IPv4or6;

d112 1
a112 1
		argv[0] = _PATH_BSHELL;
d119 2
a120 2
		execv(argv[0], argv);
		perror(argv[0]);
a189 2
	int gaierr;
	int on = 1;
d191 2
d194 1
a194 1
	struct addrinfo hints, *ai, *aitop;
a195 1
	struct servent *sp;
d247 1
a247 1
			    !anonymous && geteuid() == 0,
d297 1
a297 7
	setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof(linger));

	/* Set keepalives if requested. */
	if (options.keepalives &&
	    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
	    sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));
d310 1
a310 1
ssh_exchange_identification(void)
a315 1
	int minor1 = PROTOCOL_MINOR_1;
d369 1
a369 1
		} else if (remote_minor == 3 || remote_minor == 4) {
a371 1
			minor1 = 3;
d397 1
a397 1
	    compat20 ? PROTOCOL_MINOR_2 : minor1,
a406 1
/* defaults to 'no' */
d414 1
a414 4
	if (options.batch_mode)
		return 0;

	if (isatty(STDIN_FILENO))
d417 1
a417 1
		f = fopen(_PATH_TTY, "rw");
a467 2
	int host_line, ip_line;
	const char *host_file = NULL, *ip_file = NULL;
d489 2
a490 3
	if (local && options.host_key_alias == NULL) {
		debug("Forcing accepting of host key for "
		    "loopback/localhost.");
d495 2
a496 2
	 * We don't have the remote ip-address for connections
	 * using a proxy command
d498 4
a501 1
	if (options.proxy_command == NULL) {
a505 19
	} else {
		ip = xstrdup("<no hostip for proxy command>");
	}
	/*
	 * Turn off check_host_ip if the connection is to localhost, via proxy
	 * command or if we don't have a hostname to compare with
	 */
	if (options.check_host_ip &&
	    (local || strcmp(host, ip) == 0 || options.proxy_command != NULL))
		options.check_host_ip = 0;

	/*
	 * Allow the user to record the key under a different name. This is
	 * useful for ssh tunneling over forwarded connections or if you run
	 * multiple sshd's on different ports on the same machine.
	 */
	if (options.host_key_alias != NULL) {
		host = options.host_key_alias;
		debug("using hostkeyalias: %s", host);
d518 3
a520 6
	host_file = user_hostfile;
	host_status = check_host_in_hostfile(host_file, host, host_key, file_key, &host_line);
	if (host_status == HOST_NEW) {
		host_file = system_hostfile;
		host_status = check_host_in_hostfile(host_file, host, host_key, file_key, &host_line);
	}
d525 1
a525 1
	if (options.check_host_ip) {
d527 1
d529 2
a530 6
		ip_file = user_hostfile;
		ip_status = check_host_in_hostfile(ip_file, ip, host_key, ip_key, &ip_line);
		if (ip_status == HOST_NEW) {
			ip_file = system_hostfile;
			ip_status = check_host_in_hostfile(ip_file, ip, host_key, ip_key, &ip_line);
		}
d546 11
a556 8
		debug("Found key in %s:%d", host_file, host_line);
		if (options.check_host_ip && ip_status == HOST_NEW) {
			if (!add_host_to_hostfile(user_hostfile, ip, host_key))
				log("Failed to add the %s host key for IP address '%.128s' to the list of known hosts (%.30s).",
				    type, ip, user_hostfile);
			else
				log("Warning: Permanently added the %s host key for IP address '%.128s' to the list of known hosts.",
				    type, ip);
d568 1
d570 1
a570 1
			    "The authenticity of host '%.200s (%s)' can't be established.\n"
d573 1
a573 1
			    host, ip, type, key_fingerprint(host_key));
d577 1
a577 1
		if (options.check_host_ip && ip_status == HOST_NEW) {
d607 1
a607 3
			error("and its host key have changed at the same time.");
			if (ip_status != HOST_NEW)
				error("Offending key for IP in %s:%d", ip_file, ip_line);
a615 2
		error("The fingerprint for the %s key sent by the remote host is\n%s.",
		    type, key_fingerprint(host_key));
d618 1
a618 2
		    user_hostfile);
		error("Offending key in %s:%d", host_file, host_line);
a639 8
		if (options.forward_x11) {
			error("X11 forwarding is disabled to avoid trojan horses.");
			options.forward_x11 = 0;
		}
		if (options.num_local_forwards > 0 || options.num_remote_forwards > 0) {
			error("Port forwarding is disabled to avoid trojan horses.");
			options.num_local_forwards = options.num_remote_forwards = 0;
		}
d649 2
a650 19

	if (options.check_host_ip && host_status != HOST_CHANGED &&
	    ip_status == HOST_CHANGED) {
		log("Warning: the %s host key for '%.200s' "
		    "differs from the key for the IP address '%.128s'",
		    type, host, ip);
		if (host_status == HOST_OK)
			log("Matching host key in %s:%d", host_file, host_line);
		log("Offending key for IP in %s:%d", ip_file, ip_line);
		if (options.strict_host_key_checking == 1) {
			fatal("Exiting, you have requested strict checking.");
		} else if (options.strict_host_key_checking == 2) {
			if (!read_yes_or_no("Are you sure you want " \
			    "to continue connecting (yes/no)? ", -1))
				fatal("Aborted by user!\n");
		}
	}

	xfree(ip);
a695 15
}

void
ssh_put_password(char *password)
{
	int size;
	char *padded;

	size = roundup(strlen(password) + 1, 32);
	padded = xmalloc(size);
	memset(padded, 0, size);
	strlcpy(padded, password, size);
	packet_put_string(padded, size);
	memset(padded, 0, size);
	xfree(padded);
@


1.72.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.100 2001/03/12 22:02:02 markus Exp $");
d480 1
a480 1
	char hostline[1000], *hostp, *fp;
a606 1
			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
d611 1
a611 2
			    host, ip, type, fp);
			xfree(fp);
d613 1
a613 1
				fatal("Aborted by user!");
a649 1
		fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
d657 1
a657 1
		    type, fp);
a661 1
		xfree(fp);
d714 1
a714 1
				fatal("Aborted by user!");
a771 4
	if (datafellows & SSH_BUG_PASSWORDPAD) {
		packet_put_string(password, strlen(password));
		return;
	}
@


1.71
log
@split auth/sshconnect in one file per protocol version
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.28 2000/04/18 15:01:33 markus Exp $");
d464 1
d547 2
a548 1
		debug("Host '%.200s' is known and matches the host key.", host);
d552 2
a553 2
					log("Failed to add the host key for IP address '%.30s' to the list of known hosts (%.30s).",
					    ip, user_hostfile);
d555 2
a556 2
					log("Warning: Permanently added host key for IP address '%.30s' to the list of known hosts.",
					    ip);
d558 2
a559 2
				log("Warning: the host key for '%.200s' differs from the key for the IP address '%.30s'",
				    host, ip);
d567 1
a567 1
			fatal("No host key is known for %.200s and you have requested strict checking.", host);
d574 1
a574 1
			    "Key fingerprint is %s.\n"
d576 1
a576 1
			    host, fp);
d591 2
a592 2
			log("Warning: Permanently added '%.200s' to the list of known hosts.",
			    hostp);
d606 1
a606 1
			error("The host key for %s has changed,", host);
d618 1
a618 1
		error("It is also possible that the host key has just been changed.");
d628 1
a628 1
			fatal("Host key for %.200s has changed and you have requested strict checking.", host);
@


1.70
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d14 3
a21 3
#include "authfd.h"
#include "cipher.h"
#include "mpaux.h"
a24 11

#include "bufaux.h"
#include <openssl/rsa.h>
#include <openssl/dsa.h>

#include "ssh2.h"
#include <openssl/md5.h>
#include <openssl/dh.h>
#include <openssl/hmac.h>
#include "kex.h"
#include "myproposal.h"
d26 1
a26 1
#include "dsa.h"
a27 8
#include "authfile.h"

/* Session id for the current session. */
unsigned char session_id[16];
unsigned int supported_authentications = 0;

unsigned char *session_id2 = NULL;
int session_id2_len = 0;
a299 649

/*
 * Checks if the user has an authentication agent, and if so, tries to
 * authenticate using the agent.
 */
int
try_agent_authentication()
{
	int status, type;
	char *comment;
	AuthenticationConnection *auth;
	unsigned char response[16];
	unsigned int i;
	BIGNUM *e, *n, *challenge;

	/* Get connection to the agent. */
	auth = ssh_get_authentication_connection();
	if (!auth)
		return 0;

	e = BN_new();
	n = BN_new();
	challenge = BN_new();

	/* Loop through identities served by the agent. */
	for (status = ssh_get_first_identity(auth, e, n, &comment);
	     status;
	     status = ssh_get_next_identity(auth, e, n, &comment)) {
		int plen, clen;

		/* Try this identity. */
		debug("Trying RSA authentication via agent with '%.100s'", comment);
		xfree(comment);

		/* Tell the server that we are willing to authenticate using this key. */
		packet_start(SSH_CMSG_AUTH_RSA);
		packet_put_bignum(n);
		packet_send();
		packet_write_wait();

		/* Wait for server's response. */
		type = packet_read(&plen);

		/* The server sends failure if it doesn\'t like our key or
		   does not support RSA authentication. */
		if (type == SSH_SMSG_FAILURE) {
			debug("Server refused our key.");
			continue;
		}
		/* Otherwise it should have sent a challenge. */
		if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
			packet_disconnect("Protocol error during RSA authentication: %d",
					  type);

		packet_get_bignum(challenge, &clen);

		packet_integrity_check(plen, clen, type);

		debug("Received RSA challenge from server.");

		/* Ask the agent to decrypt the challenge. */
		if (!ssh_decrypt_challenge(auth, e, n, challenge,
					   session_id, 1, response)) {
			/* The agent failed to authenticate this identifier although it
			   advertised it supports this.  Just return a wrong value. */
			log("Authentication agent failed to decrypt challenge.");
			memset(response, 0, sizeof(response));
		}
		debug("Sending response to RSA challenge.");

		/* Send the decrypted challenge back to the server. */
		packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
		for (i = 0; i < 16; i++)
			packet_put_char(response[i]);
		packet_send();
		packet_write_wait();

		/* Wait for response from the server. */
		type = packet_read(&plen);

		/* The server returns success if it accepted the authentication. */
		if (type == SSH_SMSG_SUCCESS) {
			debug("RSA authentication accepted by server.");
			BN_clear_free(e);
			BN_clear_free(n);
			BN_clear_free(challenge);
			return 1;
		}
		/* Otherwise it should return failure. */
		if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error waiting RSA auth response: %d",
					  type);
	}

	BN_clear_free(e);
	BN_clear_free(n);
	BN_clear_free(challenge);

	debug("RSA authentication using agent refused.");
	return 0;
}

/*
 * Computes the proper response to a RSA challenge, and sends the response to
 * the server.
 */
void
respond_to_rsa_challenge(BIGNUM * challenge, RSA * prv)
{
	unsigned char buf[32], response[16];
	MD5_CTX md;
	int i, len;

	/* Decrypt the challenge using the private key. */
	rsa_private_decrypt(challenge, challenge, prv);

	/* Compute the response. */
	/* The response is MD5 of decrypted challenge plus session id. */
	len = BN_num_bytes(challenge);
	if (len <= 0 || len > sizeof(buf))
		packet_disconnect("respond_to_rsa_challenge: bad challenge length %d",
				  len);

	memset(buf, 0, sizeof(buf));
	BN_bn2bin(challenge, buf + sizeof(buf) - len);
	MD5_Init(&md);
	MD5_Update(&md, buf, 32);
	MD5_Update(&md, session_id, 16);
	MD5_Final(response, &md);

	debug("Sending response to host key RSA challenge.");

	/* Send the response back to the server. */
	packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
	for (i = 0; i < 16; i++)
		packet_put_char(response[i]);
	packet_send();
	packet_write_wait();

	memset(buf, 0, sizeof(buf));
	memset(response, 0, sizeof(response));
	memset(&md, 0, sizeof(md));
}

/*
 * Checks if the user has authentication file, and if so, tries to authenticate
 * the user using it.
 */
int
try_rsa_authentication(const char *authfile)
{
	BIGNUM *challenge;
	Key *public;
	Key *private;
	char *passphrase, *comment;
	int type, i;
	int plen, clen;

	/* Try to load identification for the authentication key. */
	public = key_new(KEY_RSA);
	if (!load_public_key(authfile, public, &comment)) {
		key_free(public);
		/* Could not load it.  Fail. */
		return 0;
	}
	debug("Trying RSA authentication with key '%.100s'", comment);

	/* Tell the server that we are willing to authenticate using this key. */
	packet_start(SSH_CMSG_AUTH_RSA);
	packet_put_bignum(public->rsa->n);
	packet_send();
	packet_write_wait();

	/* We no longer need the public key. */
	key_free(public);

	/* Wait for server's response. */
	type = packet_read(&plen);

	/*
	 * The server responds with failure if it doesn\'t like our key or
	 * doesn\'t support RSA authentication.
	 */
	if (type == SSH_SMSG_FAILURE) {
		debug("Server refused our key.");
		xfree(comment);
		return 0;
	}
	/* Otherwise, the server should respond with a challenge. */
	if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
		packet_disconnect("Protocol error during RSA authentication: %d", type);

	/* Get the challenge from the packet. */
	challenge = BN_new();
	packet_get_bignum(challenge, &clen);

	packet_integrity_check(plen, clen, type);

	debug("Received RSA challenge from server.");

	private = key_new(KEY_RSA);
	/*
	 * Load the private key.  Try first with empty passphrase; if it
	 * fails, ask for a passphrase.
	 */
	if (!load_private_key(authfile, "", private, NULL)) {
		char buf[300];
		snprintf(buf, sizeof buf, "Enter passphrase for RSA key '%.100s': ",
		    comment);
		if (!options.batch_mode)
			passphrase = read_passphrase(buf, 0);
		else {
			debug("Will not query passphrase for %.100s in batch mode.",
			      comment);
			passphrase = xstrdup("");
		}

		/* Load the authentication file using the pasphrase. */
		if (!load_private_key(authfile, passphrase, private, NULL)) {
			memset(passphrase, 0, strlen(passphrase));
			xfree(passphrase);
			error("Bad passphrase.");

			/* Send a dummy response packet to avoid protocol error. */
			packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
			for (i = 0; i < 16; i++)
				packet_put_char(0);
			packet_send();
			packet_write_wait();

			/* Expect the server to reject it... */
			packet_read_expect(&plen, SSH_SMSG_FAILURE);
			xfree(comment);
			return 0;
		}
		/* Destroy the passphrase. */
		memset(passphrase, 0, strlen(passphrase));
		xfree(passphrase);
	}
	/* We no longer need the comment. */
	xfree(comment);

	/* Compute and send a response to the challenge. */
	respond_to_rsa_challenge(challenge, private->rsa);

	/* Destroy the private key. */
	key_free(private);

	/* We no longer need the challenge. */
	BN_clear_free(challenge);

	/* Wait for response from the server. */
	type = packet_read(&plen);
	if (type == SSH_SMSG_SUCCESS) {
		debug("RSA authentication accepted by server.");
		return 1;
	}
	if (type != SSH_SMSG_FAILURE)
		packet_disconnect("Protocol error waiting RSA auth response: %d", type);
	debug("RSA authentication refused.");
	return 0;
}

/*
 * Tries to authenticate the user using combined rhosts or /etc/hosts.equiv
 * authentication and RSA host authentication.
 */
int
try_rhosts_rsa_authentication(const char *local_user, RSA * host_key)
{
	int type;
	BIGNUM *challenge;
	int plen, clen;

	debug("Trying rhosts or /etc/hosts.equiv with RSA host authentication.");

	/* Tell the server that we are willing to authenticate using this key. */
	packet_start(SSH_CMSG_AUTH_RHOSTS_RSA);
	packet_put_string(local_user, strlen(local_user));
	packet_put_int(BN_num_bits(host_key->n));
	packet_put_bignum(host_key->e);
	packet_put_bignum(host_key->n);
	packet_send();
	packet_write_wait();

	/* Wait for server's response. */
	type = packet_read(&plen);

	/* The server responds with failure if it doesn't admit our
	   .rhosts authentication or doesn't know our host key. */
	if (type == SSH_SMSG_FAILURE) {
		debug("Server refused our rhosts authentication or host key.");
		return 0;
	}
	/* Otherwise, the server should respond with a challenge. */
	if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
		packet_disconnect("Protocol error during RSA authentication: %d", type);

	/* Get the challenge from the packet. */
	challenge = BN_new();
	packet_get_bignum(challenge, &clen);

	packet_integrity_check(plen, clen, type);

	debug("Received RSA challenge for host key from server.");

	/* Compute a response to the challenge. */
	respond_to_rsa_challenge(challenge, host_key);

	/* We no longer need the challenge. */
	BN_clear_free(challenge);

	/* Wait for response from the server. */
	type = packet_read(&plen);
	if (type == SSH_SMSG_SUCCESS) {
		debug("Rhosts or /etc/hosts.equiv with RSA host authentication accepted by server.");
		return 1;
	}
	if (type != SSH_SMSG_FAILURE)
		packet_disconnect("Protocol error waiting RSA auth response: %d", type);
	debug("Rhosts or /etc/hosts.equiv with RSA host authentication refused.");
	return 0;
}

#ifdef KRB4
int
try_kerberos_authentication()
{
	KTEXT_ST auth;		/* Kerberos data */
	char *reply;
	char inst[INST_SZ];
	char *realm;
	CREDENTIALS cred;
	int r, type, plen;
	socklen_t slen;
	Key_schedule schedule;
	u_long checksum, cksum;
	MSG_DAT msg_data;
	struct sockaddr_in local, foreign;
	struct stat st;

	/* Don't do anything if we don't have any tickets. */
	if (stat(tkt_string(), &st) < 0)
		return 0;

	strncpy(inst, (char *) krb_get_phost(get_canonical_hostname()), INST_SZ);

	realm = (char *) krb_realmofhost(get_canonical_hostname());
	if (!realm) {
		debug("Kerberos V4: no realm for %s", get_canonical_hostname());
		return 0;
	}
	/* This can really be anything. */
	checksum = (u_long) getpid();

	r = krb_mk_req(&auth, KRB4_SERVICE_NAME, inst, realm, checksum);
	if (r != KSUCCESS) {
		debug("Kerberos V4 krb_mk_req failed: %s", krb_err_txt[r]);
		return 0;
	}
	/* Get session key to decrypt the server's reply with. */
	r = krb_get_cred(KRB4_SERVICE_NAME, inst, realm, &cred);
	if (r != KSUCCESS) {
		debug("get_cred failed: %s", krb_err_txt[r]);
		return 0;
	}
	des_key_sched((des_cblock *) cred.session, schedule);

	/* Send authentication info to server. */
	packet_start(SSH_CMSG_AUTH_KERBEROS);
	packet_put_string((char *) auth.dat, auth.length);
	packet_send();
	packet_write_wait();

	/* Zero the buffer. */
	(void) memset(auth.dat, 0, MAX_KTXT_LEN);

	slen = sizeof(local);
	memset(&local, 0, sizeof(local));
	if (getsockname(packet_get_connection_in(),
			(struct sockaddr *) & local, &slen) < 0)
		debug("getsockname failed: %s", strerror(errno));

	slen = sizeof(foreign);
	memset(&foreign, 0, sizeof(foreign));
	if (getpeername(packet_get_connection_in(),
			(struct sockaddr *) & foreign, &slen) < 0) {
		debug("getpeername failed: %s", strerror(errno));
		fatal_cleanup();
	}
	/* Get server reply. */
	type = packet_read(&plen);
	switch (type) {
	case SSH_SMSG_FAILURE:
		/* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
		debug("Kerberos V4 authentication failed.");
		return 0;
		break;

	case SSH_SMSG_AUTH_KERBEROS_RESPONSE:
		/* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
		debug("Kerberos V4 authentication accepted.");

		/* Get server's response. */
		reply = packet_get_string((unsigned int *) &auth.length);
		memcpy(auth.dat, reply, auth.length);
		xfree(reply);

		packet_integrity_check(plen, 4 + auth.length, type);

		/*
		 * If his response isn't properly encrypted with the session
		 * key, and the decrypted checksum fails to match, he's
		 * bogus. Bail out.
		 */
		r = krb_rd_priv(auth.dat, auth.length, schedule, &cred.session,
				&foreign, &local, &msg_data);
		if (r != KSUCCESS) {
			debug("Kerberos V4 krb_rd_priv failed: %s", krb_err_txt[r]);
			packet_disconnect("Kerberos V4 challenge failed!");
		}
		/* Fetch the (incremented) checksum that we supplied in the request. */
		(void) memcpy((char *) &cksum, (char *) msg_data.app_data, sizeof(cksum));
		cksum = ntohl(cksum);

		/* If it matches, we're golden. */
		if (cksum == checksum + 1) {
			debug("Kerberos V4 challenge successful.");
			return 1;
		} else
			packet_disconnect("Kerberos V4 challenge failed!");
		break;

	default:
		packet_disconnect("Protocol error on Kerberos V4 response: %d", type);
	}
	return 0;
}

#endif /* KRB4 */

#ifdef AFS
int
send_kerberos_tgt()
{
	CREDENTIALS *creds;
	char pname[ANAME_SZ], pinst[INST_SZ], prealm[REALM_SZ];
	int r, type, plen;
	char buffer[8192];
	struct stat st;

	/* Don't do anything if we don't have any tickets. */
	if (stat(tkt_string(), &st) < 0)
		return 0;

	creds = xmalloc(sizeof(*creds));

	if ((r = krb_get_tf_fullname(TKT_FILE, pname, pinst, prealm)) != KSUCCESS) {
		debug("Kerberos V4 tf_fullname failed: %s", krb_err_txt[r]);
		return 0;
	}
	if ((r = krb_get_cred("krbtgt", prealm, prealm, creds)) != GC_OK) {
		debug("Kerberos V4 get_cred failed: %s", krb_err_txt[r]);
		return 0;
	}
	if (time(0) > krb_life_to_time(creds->issue_date, creds->lifetime)) {
		debug("Kerberos V4 ticket expired: %s", TKT_FILE);
		return 0;
	}
	creds_to_radix(creds, (unsigned char *)buffer);
	xfree(creds);

	packet_start(SSH_CMSG_HAVE_KERBEROS_TGT);
	packet_put_string(buffer, strlen(buffer));
	packet_send();
	packet_write_wait();

	type = packet_read(&plen);

	if (type == SSH_SMSG_FAILURE)
		debug("Kerberos TGT for realm %s rejected.", prealm);
	else if (type != SSH_SMSG_SUCCESS)
		packet_disconnect("Protocol error on Kerberos TGT response: %d", type);

	return 1;
}

void
send_afs_tokens(void)
{
	CREDENTIALS creds;
	struct ViceIoctl parms;
	struct ClearToken ct;
	int i, type, len, plen;
	char buf[2048], *p, *server_cell;
	char buffer[8192];

	/* Move over ktc_GetToken, here's something leaner. */
	for (i = 0; i < 100; i++) {	/* just in case */
		parms.in = (char *) &i;
		parms.in_size = sizeof(i);
		parms.out = buf;
		parms.out_size = sizeof(buf);
		if (k_pioctl(0, VIOCGETTOK, &parms, 0) != 0)
			break;
		p = buf;

		/* Get secret token. */
		memcpy(&creds.ticket_st.length, p, sizeof(unsigned int));
		if (creds.ticket_st.length > MAX_KTXT_LEN)
			break;
		p += sizeof(unsigned int);
		memcpy(creds.ticket_st.dat, p, creds.ticket_st.length);
		p += creds.ticket_st.length;

		/* Get clear token. */
		memcpy(&len, p, sizeof(len));
		if (len != sizeof(struct ClearToken))
			break;
		p += sizeof(len);
		memcpy(&ct, p, len);
		p += len;
		p += sizeof(len);	/* primary flag */
		server_cell = p;

		/* Flesh out our credentials. */
		strlcpy(creds.service, "afs", sizeof creds.service);
		creds.instance[0] = '\0';
		strlcpy(creds.realm, server_cell, REALM_SZ);
		memcpy(creds.session, ct.HandShakeKey, DES_KEY_SZ);
		creds.issue_date = ct.BeginTimestamp;
		creds.lifetime = krb_time_to_life(creds.issue_date, ct.EndTimestamp);
		creds.kvno = ct.AuthHandle;
		snprintf(creds.pname, sizeof(creds.pname), "AFS ID %d", ct.ViceId);
		creds.pinst[0] = '\0';

		/* Encode token, ship it off. */
		if (!creds_to_radix(&creds, (unsigned char*) buffer))
			break;
		packet_start(SSH_CMSG_HAVE_AFS_TOKEN);
		packet_put_string(buffer, strlen(buffer));
		packet_send();
		packet_write_wait();

		/* Roger, Roger. Clearance, Clarence. What's your vector,
		   Victor? */
		type = packet_read(&plen);

		if (type == SSH_SMSG_FAILURE)
			debug("AFS token for cell %s rejected.", server_cell);
		else if (type != SSH_SMSG_SUCCESS)
			packet_disconnect("Protocol error on AFS token response: %d", type);
	}
}

#endif /* AFS */

/*
 * Tries to authenticate with any string-based challenge/response system.
 * Note that the client code is not tied to s/key or TIS.
 */
int
try_skey_authentication()
{
	int type, i;
	int payload_len;
	unsigned int clen;
	char *challenge, *response;

	debug("Doing skey authentication.");

	/* request a challenge */
	packet_start(SSH_CMSG_AUTH_TIS);
	packet_send();
	packet_write_wait();

	type = packet_read(&payload_len);
	if (type != SSH_SMSG_FAILURE &&
	    type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
		packet_disconnect("Protocol error: got %d in response "
				  "to skey-auth", type);
	}
	if (type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
		debug("No challenge for skey authentication.");
		return 0;
	}
	challenge = packet_get_string(&clen);
	packet_integrity_check(payload_len, (4 + clen), type);
	if (options.cipher == SSH_CIPHER_NONE)
		log("WARNING: Encryption is disabled! "
		    "Reponse will be transmitted in clear text.");
	fprintf(stderr, "%s\n", challenge);
	xfree(challenge);
	fflush(stderr);
	for (i = 0; i < options.number_of_password_prompts; i++) {
		if (i != 0)
			error("Permission denied, please try again.");
		response = read_passphrase("Response: ", 0);
		packet_start(SSH_CMSG_AUTH_TIS_RESPONSE);
		packet_put_string(response, strlen(response));
		memset(response, 0, strlen(response));
		xfree(response);
		packet_send();
		packet_write_wait();
		type = packet_read(&payload_len);
		if (type == SSH_SMSG_SUCCESS)
			return 1;
		if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error: got %d in response "
					  "to skey-auth-reponse", type);
	}
	/* failure */
	return 0;
}

/*
 * Tries to authenticate with plain passwd authentication.
 */
int
try_password_authentication(char *prompt)
{
	int type, i, payload_len;
	char *password;

	debug("Doing password authentication.");
	if (options.cipher == SSH_CIPHER_NONE)
		log("WARNING: Encryption is disabled! Password will be transmitted in clear text.");
	for (i = 0; i < options.number_of_password_prompts; i++) {
		if (i != 0)
			error("Permission denied, please try again.");
		password = read_passphrase(prompt, 0);
		packet_start(SSH_CMSG_AUTH_PASSWORD);
		packet_put_string(password, strlen(password));
		memset(password, 0, strlen(password));
		xfree(password);
		packet_send();
		packet_write_wait();

		type = packet_read(&payload_len);
		if (type == SSH_SMSG_SUCCESS)
			return 1;
		if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error: got %d in response to passwd auth", type);
	}
	/* failure */
	return 0;
}


a651 717
}

/*
 * SSH2 key exchange
 */

void
ssh_kex2(char *host, struct sockaddr *hostaddr)
{
	Kex *kex;
	char *cprop[PROPOSAL_MAX];
	char *sprop[PROPOSAL_MAX];
	Buffer *client_kexinit;
	Buffer *server_kexinit;
	int payload_len, dlen;
	unsigned int klen, kout;
	char *ptr;
	char *signature = NULL;
	unsigned int slen;
	char *server_host_key_blob = NULL;
	Key *server_host_key;
	unsigned int sbloblen;
	DH *dh;
	BIGNUM *dh_server_pub = 0;
	BIGNUM *shared_secret = 0;
	int i;
	unsigned char *kbuf;
	unsigned char *hash;

/* KEXINIT */

	debug("Sending KEX init.");
	if (options.ciphers != NULL) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
	} else if (
	    options.cipher == SSH_CIPHER_ARCFOUR ||
	    options.cipher == SSH_CIPHER_3DES_CBC ||
	    options.cipher == SSH_CIPHER_CAST128_CBC ||
	    options.cipher == SSH_CIPHER_BLOWFISH_CBC) {
		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
		myproposal[PROPOSAL_ENC_ALGS_STOC] = cipher_name(options.cipher);
	}
	if (options.compression) {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "zlib";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "zlib";
	} else {
		myproposal[PROPOSAL_COMP_ALGS_CTOS] = "none";
		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
	}
	for (i = 0; i < PROPOSAL_MAX; i++)
		cprop[i] = xstrdup(myproposal[i]);

	client_kexinit = kex_init(cprop);
	packet_start(SSH2_MSG_KEXINIT);
	packet_put_raw(buffer_ptr(client_kexinit), buffer_len(client_kexinit));	
	packet_send();
	packet_write_wait();

	debug("done");

	packet_read_expect(&payload_len, SSH2_MSG_KEXINIT);

	/* save payload for session_id */
	server_kexinit = xmalloc(sizeof(*server_kexinit));
	buffer_init(server_kexinit);
	ptr = packet_get_raw(&payload_len);
	buffer_append(server_kexinit, ptr, payload_len);

	/* skip cookie */
	for (i = 0; i < 16; i++)
		(void) packet_get_char();
	/* kex init proposal strings */
	for (i = 0; i < PROPOSAL_MAX; i++) {
		sprop[i] = packet_get_string(NULL);
		debug("got kexinit string: %s", sprop[i]);
	}
	i = (int) packet_get_char();
	debug("first kex follow == %d", i);
	i = packet_get_int();
	debug("reserved == %d", i);
	packet_done();

	debug("done read kexinit");
	kex = kex_choose_conf(cprop, sprop, 0);

/* KEXDH */

	debug("Sending SSH2_MSG_KEXDH_INIT.");

	/* generate and send 'e', client DH public key */
	dh = dh_new_group1();
	packet_start(SSH2_MSG_KEXDH_INIT);
	packet_put_bignum2(dh->pub_key);
	packet_send();
	packet_write_wait();

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\np= ");
	bignum_print(dh->p);
	fprintf(stderr, "\ng= ");
	bignum_print(dh->g);
	fprintf(stderr, "\npub= ");
	bignum_print(dh->pub_key);
	fprintf(stderr, "\n");
	DHparams_print_fp(stderr, dh);
#endif

	debug("Wait SSH2_MSG_KEXDH_REPLY.");

	packet_read_expect(&payload_len, SSH2_MSG_KEXDH_REPLY);

	debug("Got SSH2_MSG_KEXDH_REPLY.");

	/* key, cert */
	server_host_key_blob = packet_get_string(&sbloblen);
	server_host_key = dsa_key_from_blob(server_host_key_blob, sbloblen);
	if (server_host_key == NULL)
		fatal("cannot decode server_host_key_blob");

	check_host_key(host, hostaddr, server_host_key,
	    options.user_hostfile2, options.system_hostfile2);

	/* DH paramter f, server public DH key */
	dh_server_pub = BN_new();
	if (dh_server_pub == NULL)
		fatal("dh_server_pub == NULL");
	packet_get_bignum2(dh_server_pub, &dlen);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "\ndh_server_pub= ");
	bignum_print(dh_server_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_server_pub));
#endif

	/* signed H */
	signature = packet_get_string(&slen);
	packet_done();

	if (!dh_pub_is_valid(dh, dh_server_pub))
		packet_disconnect("bad server public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_server_pub, dh);
#ifdef DEBUG_KEXDH
	debug("shared secret: len %d/%d", klen, kout);
	fprintf(stderr, "shared secret == ");
	for (i = 0; i< kout; i++)
		fprintf(stderr, "%02x", (kbuf[i])&0xff);
	fprintf(stderr, "\n");
#endif
	shared_secret = BN_new();

	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	/* calc and verify H */
	hash = kex_hash(
	    client_version_string,
	    server_version_string,
	    buffer_ptr(client_kexinit), buffer_len(client_kexinit),
	    buffer_ptr(server_kexinit), buffer_len(server_kexinit),
	    server_host_key_blob, sbloblen,
	    dh->pub_key,
	    dh_server_pub,
	    shared_secret
	);
	buffer_free(client_kexinit);
	buffer_free(server_kexinit);
	xfree(client_kexinit);
	xfree(server_kexinit);
#ifdef DEBUG_KEXDH
	fprintf(stderr, "hash == ");
	for (i = 0; i< 20; i++)
		fprintf(stderr, "%02x", (hash[i])&0xff);
	fprintf(stderr, "\n");
#endif
	if (dsa_verify(server_host_key, (unsigned char *)signature, slen, hash, 20) != 1)
		fatal("dsa_verify failed for server_host_key");
	key_free(server_host_key);

	kex_derive_keys(kex, hash, shared_secret);
	packet_set_kex(kex);

	/* have keys, free DH */
	DH_free(dh);

	/* save session id */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);

	debug("Wait SSH2_MSG_NEWKEYS.");
	packet_read_expect(&payload_len, SSH2_MSG_NEWKEYS);
	packet_done();
	debug("GOT SSH2_MSG_NEWKEYS.");

	debug("send SSH2_MSG_NEWKEYS.");
	packet_start(SSH2_MSG_NEWKEYS);
	packet_send();
	packet_write_wait();
	debug("done: send SSH2_MSG_NEWKEYS.");

#ifdef DEBUG_KEXDH
	/* send 1st encrypted/maced/compressed message */
	packet_start(SSH2_MSG_IGNORE);
	packet_put_cstring("markus");
	packet_send();
	packet_write_wait();
#endif
	debug("done: KEX2.");
}
/*
 * Authenticate user
 */
int
ssh2_try_passwd(const char *server_user, const char *host, const char *service)
{
	char prompt[80];
	char *password;

	snprintf(prompt, sizeof(prompt), "%.30s@@%.40s's password: ",
	    server_user, host);
	password = read_passphrase(prompt, 0);
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(server_user);
	packet_put_cstring(service);
	packet_put_cstring("password");
	packet_put_char(0);
	packet_put_cstring(password);
	memset(password, 0, strlen(password));
	xfree(password);
	packet_send();
	packet_write_wait();
	return 1;
}

int
ssh2_try_pubkey(char *filename,
    const char *server_user, const char *host, const char *service)
{
	Buffer b;
	Key *k;
	unsigned char *blob, *signature;
	int bloblen, slen;

	debug("try pubkey: %s", filename);

	k = key_new(KEY_DSA);
	if (!load_private_key(filename, "", k, NULL)) {
		int success = 0;
		char *passphrase;
		char prompt[300];
                snprintf(prompt, sizeof prompt,
		     "Enter passphrase for DSA key '%.100s': ",
                     filename);
		passphrase = read_passphrase(prompt, 0);
		success = load_private_key(filename, passphrase, k, NULL);
		memset(passphrase, 0, strlen(passphrase));
		xfree(passphrase);
		if (!success)
			return 0;
	}
	dsa_make_key_blob(k, &blob, &bloblen);

	/* data to be signed */
	buffer_init(&b);
	buffer_append(&b, session_id2, session_id2_len);
	buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
	buffer_put_cstring(&b, server_user);
	buffer_put_cstring(&b, service);
	buffer_put_cstring(&b, "publickey");
	buffer_put_char(&b, 1);
	buffer_put_cstring(&b, KEX_DSS); 
	buffer_put_string(&b, blob, bloblen);

	/* generate signature */
	dsa_sign(k, &signature, &slen, buffer_ptr(&b), buffer_len(&b));
	key_free(k);
#ifdef DEBUG_DSS
	buffer_dump(&b);
#endif
	/* append signature */
	buffer_put_string(&b, signature, slen);
	xfree(signature);

	/* skip session id and packet type */
	if (buffer_len(&b) < session_id2_len + 1)
		fatal("ssh2_try_pubkey: internal error");
	buffer_consume(&b, session_id2_len + 1);

	/* put remaining data from buffer into packet */
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_raw(buffer_ptr(&b), buffer_len(&b));
	buffer_free(&b);

	/* send */
	packet_send();
	packet_write_wait();
	return 1;
}

void
ssh_userauth2(const char *server_user, char *host)
{
	int type;
	int plen;
	int sent;
	unsigned int dlen;
	int partial;
	int i = 0;
	char *auths;
	char *service = "ssh-connection";		/* service name */

	debug("send SSH2_MSG_SERVICE_REQUEST");
	packet_start(SSH2_MSG_SERVICE_REQUEST);
	packet_put_cstring("ssh-userauth");
	packet_send();
	packet_write_wait();

	type = packet_read(&plen);
	if (type != SSH2_MSG_SERVICE_ACCEPT) {
		fatal("denied SSH2_MSG_SERVICE_ACCEPT: %d", type);
	}
	if (packet_remaining() > 0) {
		char *reply = packet_get_string(&plen);
		debug("service_accept: %s", reply);
		xfree(reply);
	} else {
		/* payload empty for ssh-2.0.13 ?? */
		log("buggy server: service_accept w/o service");
	}
	packet_done();
	debug("got SSH2_MSG_SERVICE_ACCEPT");

	/* INITIAL request for auth */
	packet_start(SSH2_MSG_USERAUTH_REQUEST);
	packet_put_cstring(server_user);
	packet_put_cstring(service);
	packet_put_cstring("none");
	packet_send();
	packet_write_wait();

	for (;;) {
		sent = 0;
		type = packet_read(&plen);
		if (type == SSH2_MSG_USERAUTH_SUCCESS)
			break;
		if (type != SSH2_MSG_USERAUTH_FAILURE)
			fatal("access denied: %d", type);
		/* SSH2_MSG_USERAUTH_FAILURE means: try again */
		auths = packet_get_string(&dlen);
		debug("authentications that can continue: %s", auths);
		partial = packet_get_char();
		packet_done();
		if (partial)
			debug("partial success");
		if (strstr(auths, "publickey") != NULL) {
			while (i < options.num_identity_files2) {
				sent = ssh2_try_pubkey(
				    options.identity_files2[i++],
				    server_user, host, service);
				if (sent)
					break;
			}
		}
		if (!sent) {
			if (strstr(auths, "password") != NULL) {
				sent = ssh2_try_passwd(server_user, host, service);
			} else {
				fatal("passwd auth not supported: %s", auths);
			}
			if (!sent)
				fatal("no more auths: %s", auths);
		}
		xfree(auths);
	}
	packet_done();
	debug("ssh-userauth2 successfull");
}

/*
 * SSH1 key exchange
 */
void
ssh_kex(char *host, struct sockaddr *hostaddr)
{
	int i;
	BIGNUM *key;
	RSA *host_key;
	RSA *public_key;
	Key k;
	int bits, rbits;
	int ssh_cipher_default = SSH_CIPHER_3DES;
	unsigned char session_key[SSH_SESSION_KEY_LENGTH];
	unsigned char cookie[8];
	unsigned int supported_ciphers;
	unsigned int server_flags, client_flags;
	int payload_len, clen, sum_len = 0;
	u_int32_t rand = 0;

	debug("Waiting for server public key.");

	/* Wait for a public key packet from the server. */
	packet_read_expect(&payload_len, SSH_SMSG_PUBLIC_KEY);

	/* Get cookie from the packet. */
	for (i = 0; i < 8; i++)
		cookie[i] = packet_get_char();

	/* Get the public key. */
	public_key = RSA_new();
	bits = packet_get_int();/* bits */
	public_key->e = BN_new();
	packet_get_bignum(public_key->e, &clen);
	sum_len += clen;
	public_key->n = BN_new();
	packet_get_bignum(public_key->n, &clen);
	sum_len += clen;

	rbits = BN_num_bits(public_key->n);
	if (bits != rbits) {
		log("Warning: Server lies about size of server public key: "
		    "actual size is %d bits vs. announced %d.", rbits, bits);
		log("Warning: This may be due to an old implementation of ssh.");
	}
	/* Get the host key. */
	host_key = RSA_new();
	bits = packet_get_int();/* bits */
	host_key->e = BN_new();
	packet_get_bignum(host_key->e, &clen);
	sum_len += clen;
	host_key->n = BN_new();
	packet_get_bignum(host_key->n, &clen);
	sum_len += clen;

	rbits = BN_num_bits(host_key->n);
	if (bits != rbits) {
		log("Warning: Server lies about size of server host key: "
		    "actual size is %d bits vs. announced %d.", rbits, bits);
		log("Warning: This may be due to an old implementation of ssh.");
	}

	/* Get protocol flags. */
	server_flags = packet_get_int();
	packet_set_protocol_flags(server_flags);

	supported_ciphers = packet_get_int();
	supported_authentications = packet_get_int();

	debug("Received server public key (%d bits) and host key (%d bits).",
	      BN_num_bits(public_key->n), BN_num_bits(host_key->n));

	packet_integrity_check(payload_len,
			       8 + 4 + sum_len + 0 + 4 + 0 + 0 + 4 + 4 + 4,
			       SSH_SMSG_PUBLIC_KEY);
	k.type = KEY_RSA;
	k.rsa = host_key;
	check_host_key(host, hostaddr, &k,
	    options.user_hostfile, options.system_hostfile);

	client_flags = SSH_PROTOFLAG_SCREEN_NUMBER | SSH_PROTOFLAG_HOST_IN_FWD_OPEN;

	compute_session_id(session_id, cookie, host_key->n, public_key->n);

	/* Generate a session key. */
	arc4random_stir();

	/*
	 * Generate an encryption key for the session.   The key is a 256 bit
	 * random number, interpreted as a 32-byte key, with the least
	 * significant 8 bits being the first byte of the key.
	 */
	for (i = 0; i < 32; i++) {
		if (i % 4 == 0)
			rand = arc4random();
		session_key[i] = rand & 0xff;
		rand >>= 8;
	}

	/*
	 * According to the protocol spec, the first byte of the session key
	 * is the highest byte of the integer.  The session key is xored with
	 * the first 16 bytes of the session id.
	 */
	key = BN_new();
	BN_set_word(key, 0);
	for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++) {
		BN_lshift(key, key, 8);
		if (i < 16)
			BN_add_word(key, session_key[i] ^ session_id[i]);
		else
			BN_add_word(key, session_key[i]);
	}

	/*
	 * Encrypt the integer using the public key and host key of the
	 * server (key with smaller modulus first).
	 */
	if (BN_cmp(public_key->n, host_key->n) < 0) {
		/* Public key has smaller modulus. */
		if (BN_num_bits(host_key->n) <
		    BN_num_bits(public_key->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: host_key %d < public_key %d + "
			      "SSH_KEY_BITS_RESERVED %d",
			      BN_num_bits(host_key->n),
			      BN_num_bits(public_key->n),
			      SSH_KEY_BITS_RESERVED);
		}
		rsa_public_encrypt(key, key, public_key);
		rsa_public_encrypt(key, key, host_key);
	} else {
		/* Host key has smaller modulus (or they are equal). */
		if (BN_num_bits(public_key->n) <
		    BN_num_bits(host_key->n) + SSH_KEY_BITS_RESERVED) {
			fatal("respond_to_rsa_challenge: public_key %d < host_key %d + "
			      "SSH_KEY_BITS_RESERVED %d",
			      BN_num_bits(public_key->n),
			      BN_num_bits(host_key->n),
			      SSH_KEY_BITS_RESERVED);
		}
		rsa_public_encrypt(key, key, host_key);
		rsa_public_encrypt(key, key, public_key);
	}

	/* Destroy the public keys since we no longer need them. */
	RSA_free(public_key);
	RSA_free(host_key);

	if (options.cipher == SSH_CIPHER_NOT_SET) {
		if (cipher_mask1() & supported_ciphers & (1 << ssh_cipher_default))
			options.cipher = ssh_cipher_default;
		else {
			debug("Cipher %s not supported, using %.100s instead.",
			      cipher_name(ssh_cipher_default),
			      cipher_name(SSH_FALLBACK_CIPHER));
			options.cipher = SSH_FALLBACK_CIPHER;
		}
	}
	/* Check that the selected cipher is supported. */
	if (!(supported_ciphers & (1 << options.cipher)))
		fatal("Selected cipher type %.100s not supported by server.",
		      cipher_name(options.cipher));

	debug("Encryption type: %.100s", cipher_name(options.cipher));

	/* Send the encrypted session key to the server. */
	packet_start(SSH_CMSG_SESSION_KEY);
	packet_put_char(options.cipher);

	/* Send the cookie back to the server. */
	for (i = 0; i < 8; i++)
		packet_put_char(cookie[i]);

	/* Send and destroy the encrypted encryption key integer. */
	packet_put_bignum(key);
	BN_clear_free(key);

	/* Send protocol flags. */
	packet_put_int(client_flags);

	/* Send the packet now. */
	packet_send();
	packet_write_wait();

	debug("Sent encrypted session key.");

	/* Set the encryption key. */
	packet_set_encryption_key(session_key, SSH_SESSION_KEY_LENGTH, options.cipher);

	/* We will no longer need the session key here.  Destroy any extra copies. */
	memset(session_key, 0, sizeof(session_key));

	/*
	 * Expect a success message from the server.  Note that this message
	 * will be received in encrypted form.
	 */
	packet_read_expect(&payload_len, SSH_SMSG_SUCCESS);

	debug("Received encrypted confirmation.");
}

/*
 * Authenticate user
 */
void
ssh_userauth(
    const char* local_user,
    const char* server_user,
    char *host,
    int host_key_valid, RSA *own_host_key)
{
	int i, type;
	int payload_len;

	if (supported_authentications == 0)
		fatal("ssh_userauth: server supports no auth methods");

	/* Send the name of the user to log in as on the server. */
	packet_start(SSH_CMSG_USER);
	packet_put_string(server_user, strlen(server_user));
	packet_send();
	packet_write_wait();

	/*
	 * The server should respond with success if no authentication is
	 * needed (the user has no password).  Otherwise the server responds
	 * with failure.
	 */
	type = packet_read(&payload_len);

	/* check whether the connection was accepted without authentication. */
	if (type == SSH_SMSG_SUCCESS)
		return;
	if (type != SSH_SMSG_FAILURE)
		packet_disconnect("Protocol error: got %d in response to SSH_CMSG_USER",
				  type);

#ifdef AFS
	/* Try Kerberos tgt passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
	    options.kerberos_tgt_passing) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
		(void) send_kerberos_tgt();
	}
	/* Try AFS token passing if the server supports it. */
	if ((supported_authentications & (1 << SSH_PASS_AFS_TOKEN)) &&
	    options.afs_token_passing && k_hasafs()) {
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Token will be transmitted in the clear!");
		send_afs_tokens();
	}
#endif /* AFS */

#ifdef KRB4
	if ((supported_authentications & (1 << SSH_AUTH_KERBEROS)) &&
	    options.kerberos_authentication) {
		debug("Trying Kerberos authentication.");
		if (try_kerberos_authentication()) {
			/* The server should respond with success or failure. */
			type = packet_read(&payload_len);
			if (type == SSH_SMSG_SUCCESS)
				return;
			if (type != SSH_SMSG_FAILURE)
				packet_disconnect("Protocol error: got %d in response to Kerberos auth", type);
		}
	}
#endif /* KRB4 */

	/*
	 * Use rhosts authentication if running in privileged socket and we
	 * do not wish to remain anonymous.
	 */
	if ((supported_authentications & (1 << SSH_AUTH_RHOSTS)) &&
	    options.rhosts_authentication) {
		debug("Trying rhosts authentication.");
		packet_start(SSH_CMSG_AUTH_RHOSTS);
		packet_put_string(local_user, strlen(local_user));
		packet_send();
		packet_write_wait();

		/* The server should respond with success or failure. */
		type = packet_read(&payload_len);
		if (type == SSH_SMSG_SUCCESS)
			return;
		if (type != SSH_SMSG_FAILURE)
			packet_disconnect("Protocol error: got %d in response to rhosts auth",
					  type);
	}
	/*
	 * Try .rhosts or /etc/hosts.equiv authentication with RSA host
	 * authentication.
	 */
	if ((supported_authentications & (1 << SSH_AUTH_RHOSTS_RSA)) &&
	    options.rhosts_rsa_authentication && host_key_valid) {
		if (try_rhosts_rsa_authentication(local_user, own_host_key))
			return;
	}
	/* Try RSA authentication if the server supports it. */
	if ((supported_authentications & (1 << SSH_AUTH_RSA)) &&
	    options.rsa_authentication) {
		/*
		 * Try RSA authentication using the authentication agent. The
		 * agent is tried first because no passphrase is needed for
		 * it, whereas identity files may require passphrases.
		 */
		if (try_agent_authentication())
			return;

		/* Try RSA authentication for each identity. */
		for (i = 0; i < options.num_identity_files; i++)
			if (try_rsa_authentication(options.identity_files[i]))
				return;
	}
	/* Try skey authentication if the server supports it. */
	if ((supported_authentications & (1 << SSH_AUTH_TIS)) &&
	    options.skey_authentication && !options.batch_mode) {
		if (try_skey_authentication())
			return;
	}
	/* Try password authentication if the server supports it. */
	if ((supported_authentications & (1 << SSH_AUTH_PASSWORD)) &&
	    options.password_authentication && !options.batch_mode) {
		char prompt[80];

		snprintf(prompt, sizeof(prompt), "%.30s@@%.40s's password: ",
		    server_user, host);
		if (try_password_authentication(prompt))
			return;
	}
	/* All authentication methods have failed.  Exit with an error message. */
	fatal("Permission denied.");
	/* NOTREACHED */
@


1.69
log
@pid_t
@
text
@a7 2
 *
 * SSH2 support added by Markus Friedl.
d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.68 2000/04/14 10:30:33 markus Exp $");
d39 1
d43 1
d45 2
a46 2
/* authentications supported by server */
unsigned int supported_authentications;
d48 2
a49 2
static char *client_version_string = NULL;
static char *server_version_string = NULL;
d319 1
d471 2
a472 2
	RSA *private_key;
	RSA *public_key;
d478 3
a480 3
	public_key = RSA_new();
	if (!load_public_key(authfile, public_key, &comment)) {
		RSA_free(public_key);
d488 1
a488 1
	packet_put_bignum(public_key->n);
d493 1
a493 1
	RSA_free(public_key);
d519 1
a519 1
	private_key = RSA_new();
d524 1
a524 1
	if (!load_private_key(authfile, "", private_key, NULL)) {
d537 1
a537 1
		if (!load_private_key(authfile, passphrase, private_key, NULL)) {
d562 1
a562 1
	respond_to_rsa_challenge(challenge, private_key);
d565 1
a565 1
	RSA_free(private_key);
d967 1
d1065 2
a1066 1

d1128 2
a1129 1
check_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)
d1147 1
d1188 1
a1188 1
	host_status = check_host_in_hostfile(options.user_hostfile, host, host_key, file_key);
d1190 1
a1190 1
		host_status = check_host_in_hostfile(options.system_hostfile, host, host_key, file_key);
d1197 1
a1197 1
		ip_status = check_host_in_hostfile(options.user_hostfile, ip, host_key, ip_key);
d1200 1
a1200 1
			ip_status = check_host_in_hostfile(options.system_hostfile, ip, host_key, ip_key);
d1217 1
a1217 1
				if (!add_host_to_hostfile(options.user_hostfile, ip, host_key))
d1219 1
a1219 1
					    ip, options.user_hostfile);
d1253 1
a1253 1
		if (!add_host_to_hostfile(options.user_hostfile, hostp, host_key))
d1255 1
a1255 1
			    options.user_hostfile);
d1287 1
a1287 1
		      options.user_hostfile);
a1320 8
void
check_rsa_host_key(char *host, struct sockaddr *hostaddr, RSA *host_key)
{
	Key k;
	k.type = KEY_RSA;
	k.rsa = host_key;
	check_host_key(host, hostaddr, &k);
}
d1325 1
d1436 1
a1436 1
	server_host_key = dsa_serverkey_from_blob(server_host_key_blob, sbloblen);
d1440 2
a1441 1
	check_host_key(host, hostaddr, server_host_key);
d1500 2
a1501 1
	dsa_verify(server_host_key, (unsigned char *)signature, slen, hash, 20);
d1510 5
d1538 87
d1626 1
a1626 2
ssh_userauth2(int host_key_valid, RSA *own_host_key,
    uid_t original_real_uid, char *host)
d1630 1
d1633 1
a1633 3
	struct passwd *pw;
	char prompt[80];
	char *server_user, *local_user;
a1634 1
	char *password;
a1657 8
	/*XX COMMONCODE: */
	/* Get local user name.  Use it as server user if no user name was given. */
	pw = getpwuid(original_real_uid);
	if (!pw)
		fatal("User id %d not found from user database.", original_real_uid);
	local_user = xstrdup(pw->pw_name);
	server_user = options.user ? options.user : local_user;

d1667 1
d1680 18
a1697 2
		if (strstr(auths, "password") == NULL)
			fatal("passwd auth not supported: %s", auths);
a1698 14
		/* try passwd */
		snprintf(prompt, sizeof(prompt), "%.30s@@%.40s's password: ",
		    server_user, host);
		password = read_passphrase(prompt, 0);
		packet_start(SSH2_MSG_USERAUTH_REQUEST);
		packet_put_cstring(server_user);
		packet_put_cstring(service);
		packet_put_cstring("password");
		packet_put_char(0);
		packet_put_cstring(password);
		memset(password, 0, strlen(password));
		xfree(password);
		packet_send();
		packet_write_wait();
d1714 1
d1779 4
a1782 2

	check_rsa_host_key(host, hostaddr, host_key);
d1909 5
a1913 2
ssh_userauth(int host_key_valid, RSA *own_host_key,
    uid_t original_real_uid, char *host)
a1916 2
	struct passwd *pw;
	const char *server_user, *local_user;
d1918 2
a1919 6
	/* Get local user name.  Use it as server user if no user name was given. */
	pw = getpwuid(original_real_uid);
	if (!pw)
		fatal("User id %d not found from user database.", original_real_uid);
	local_user = xstrdup(pw->pw_name);
	server_user = options.user ? options.user : local_user;
d2038 1
d2050 1
d2052 8
d2077 1
a2077 1
		ssh_userauth2(host_key_valid, own_host_key, original_real_uid, host);
a2078 1
		supported_authentications = 0;
d2080 1
a2080 3
		if (supported_authentications == 0)
			fatal("supported_authentications == 0.");
		ssh_userauth(host_key_valid, own_host_key, original_real_uid, host);
@


1.68
log
@whitespace cleanup
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.67 2000/04/14 10:09:16 markus Exp $");
d65 1
a65 1
	int pid;
@


1.67
log
@check payload for (illegal) extra data
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.66 2000/04/12 09:39:10 markus Exp $");
d246 1
a246 1
 		   sequence until the connection succeeds. */
d260 1
a260 1
			sock = ssh_create_socket(original_real_uid, 
d1055 1
a1055 1
	default: 
d1355 1
a1355 1
		myproposal[PROPOSAL_ENC_ALGS_CTOS] = 
d1359 3
a1361 3
            options.cipher == SSH_CIPHER_3DES_CBC ||
            options.cipher == SSH_CIPHER_CAST128_CBC ||
            options.cipher == SSH_CIPHER_BLOWFISH_CBC) {
d1427 1
a1427 1
        DHparams_print_fp(stderr, dh);
d1469 4
a1472 4
        fprintf(stderr, "shared secret == ");
        for (i = 0; i< kout; i++)
                fprintf(stderr, "%02x", (kbuf[i])&0xff);
        fprintf(stderr, "\n");
d1474 1
a1474 1
        shared_secret = BN_new();
d1476 1
a1476 1
        BN_bin2bn(kbuf, kout, shared_secret);
d1496 4
a1499 4
        fprintf(stderr, "hash == ");
        for (i = 0; i< 20; i++)
                fprintf(stderr, "%02x", (hash[i])&0xff);
        fprintf(stderr, "\n");
@


1.66
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.65 2000/04/12 07:56:16 markus Exp $");
d1403 1
d1459 1
d1512 1
d1546 1
a1546 1
	char *service = "ssh-connection";		// service name
d1558 9
a1566 2
	/* payload empty for ssh-2.0.13 ?? */
	/* reply = packet_get_string(&payload_len); */
d1595 1
d1616 1
@


1.65
log
@typo
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.64 2000/04/12 07:45:44 markus Exp $");
d15 1
a15 1
#include <ssl/bn.h>
d29 2
a30 2
#include <ssl/rsa.h>
#include <ssl/dsa.h>
d33 3
a35 3
#include <ssl/md5.h>
#include <ssl/dh.h>
#include <ssl/hmac.h>
@


1.64
log
@add Cipher and Protocol options to ssh/sshd, e.g.:
ssh -o 'Protocol 1,2' if you prefer proto 1, ssh -o 'Ciphers arcfour,3des-cbc'
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.63 2000/04/12 07:03:06 markus Exp $");
d1067 1
a1067 1
	    compat20 ? PROTOCOL_MINOR_1 : PROTOCOL_MINOR_1,
@


1.63
log
@check for reasonable public DH values
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.62 2000/04/12 06:36:48 markus Exp $");
d989 1
a989 1
	int remote_major, remote_minor, i;
a1022 1
/*** XXX option for disabling 2.0 or 1.5 */
d1024 1
d1026 27
a1052 10
	/* Check if the remote protocol version is too old. */
	if (remote_major == 1 && remote_minor < 3)
		fatal("Remote machine has too old SSH software version.");

	/* We speak 1.3, too. */
	if (remote_major == 1 && remote_minor == 3) {
		enable_compat13();
		if (options.forward_agent) {
			log("Agent forwarding disabled for protocol 1.3");
			options.forward_agent = 0;
d1054 4
d1059 1
a1059 11
	if ((remote_major == 2 && remote_minor == 0) ||
	    (remote_major == 1 && remote_minor == 99)) {
		enable_compat20();
	}
#if 0
	/*
	 * Removed for now, to permit compatibility with latter versions. The
	 * server will reject our version and disconnect if it doesn't
	 * support it.
	 */
	if (remote_major != PROTOCOL_MAJOR)
d1061 3
a1063 2
		      PROTOCOL_MAJOR, remote_major);
#endif
d1066 2
a1067 2
	    compat20 ? 2 : PROTOCOL_MAJOR,
	    compat20 ? 0 : PROTOCOL_MINOR,
d1354 5
a1358 1
        if (options.cipher == SSH_CIPHER_ARCFOUR ||
d1362 1
a1362 1
		myproposal[PROPOSAL_ENC_ALGS_CTOS] = cipher_name(options.cipher);
@


1.62
log
@fix passwd prompt for ssh2, less debugging output.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.61 2000/04/04 21:37:27 markus Exp $");
d1396 1
a1396 1
	dh = new_dh_group1();
d1442 3
@


1.61
log
@remove unused argument, split cipher_mask()
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.60 2000/04/04 15:30:51 markus Exp $");
d1499 1
d1505 1
a1505 1

d1520 1
d1572 3
a1574 1
		password = read_passphrase("password: ", 0);
@


1.60
log
@missing free.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.59 2000/04/04 15:19:43 markus Exp $");
d1731 1
a1731 1
		if (cipher_mask() & supported_ciphers & (1 << ssh_cipher_default))
@


1.59
log
@ssh2 client implementation, interops w/ ssh.com and lsh servers.
@
text
@d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.58 2000/03/23 22:15:33 markus Exp $");
d1470 2
a1471 2
	buffer_clear(client_kexinit);
	buffer_clear(server_kexinit);
@


1.58
log
@initial support for DSA keys. ok deraadt@@, niels@@
@
text
@d8 2
d13 1
a13 1
RCSID("$OpenBSD: sshconnect.c,v 1.57 2000/03/16 20:56:14 markus Exp $");
d19 1
d28 1
d31 2
d34 4
d39 1
d48 3
d966 15
d1003 1
a1003 1
			break;
d1011 1
d1017 2
a1018 2
	if (sscanf(buf, "SSH-%d.%d-%[^\n]\n", &remote_major, &remote_minor,
		   remote_version) != 3)
d1023 3
d1038 4
a1051 1

d1054 3
a1056 1
	    PROTOCOL_MAJOR, PROTOCOL_MINOR, SSH_VERSION);
d1059 4
a1064 2
int ssh_cipher_default = SSH_CIPHER_3DES;

d1314 272
d1596 1
a1943 1
	supported_authentications = 0;
a1944 4
	ssh_kex(host, hostaddr);
	if (supported_authentications == 0)
		fatal("supported_authentications == 0.");

d1946 10
a1955 1
	ssh_userauth(host_key_valid, own_host_key, original_real_uid, host);
@


1.57
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.56 2000/02/18 08:50:33 markus Exp $");
a23 1
#include "fingerprint.h"
d25 2
d28 2
d1073 1
a1073 1
check_host_key(char *host, struct sockaddr *hostaddr, RSA *host_key)
d1075 1
a1075 1
	RSA *file_key;
d1125 1
a1125 3
	file_key = RSA_new();
	file_key->n = BN_new();
	file_key->e = BN_new();
d1131 1
a1131 3
	host_status = check_host_in_hostfile(options.user_hostfile, host,
					     host_key->e, host_key->n,
					     file_key->e, file_key->n);
d1133 1
a1133 3
		host_status = check_host_in_hostfile(options.system_hostfile, host,
						host_key->e, host_key->n,
					       file_key->e, file_key->n);
d1139 2
a1140 6
		RSA *ip_key = RSA_new();
		ip_key->n = BN_new();
		ip_key->e = BN_new();
		ip_status = check_host_in_hostfile(options.user_hostfile, ip,
						host_key->e, host_key->n,
						   ip_key->e, ip_key->n);
d1143 1
a1143 3
			ip_status = check_host_in_hostfile(options.system_hostfile, ip,
						host_key->e, host_key->n,
						   ip_key->e, ip_key->n);
d1145 1
a1145 2
		    (ip_status != HOST_CHANGED ||
		     (BN_cmp(ip_key->e, file_key->e) || BN_cmp(ip_key->n, file_key->n))))
d1148 1
a1148 1
		RSA_free(ip_key);
d1152 1
a1152 1
	RSA_free(file_key);
d1160 1
a1160 2
				if (!add_host_to_hostfile(options.user_hostfile, ip,
					       host_key->e, host_key->n))
d1180 1
a1180 1
			char *fp = fingerprint(host_key->e, host_key->n);
d1183 1
a1183 1
			    "Key fingerprint is %d %s.\n"
d1185 1
a1185 1
			    host, BN_num_bits(host_key->n), fp);
d1196 1
a1196 2
		if (!add_host_to_hostfile(options.user_hostfile, hostp,
					  host_key->e, host_key->n))
d1264 8
d1347 1
a1347 1
	check_host_key(host, hostaddr, host_key);
a1605 1

d1636 1
@


1.56
log
@read error vs. "Connection closed by remote host"
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.55 2000/02/15 13:08:01 markus Exp $");
d635 1
d678 1
a678 1
	r = sizeof(local);
d681 1
a681 1
			(struct sockaddr *) & local, &r) < 0)
d684 1
a684 1
	r = sizeof(foreign);
d687 1
a687 1
			(struct sockaddr *) & foreign, &r) < 0) {
d749 1
a749 1
	unsigned char buffer[8192];
d770 1
a770 1
	creds_to_radix(creds, buffer);
d774 1
a774 1
	packet_put_string((char *) buffer, strlen(buffer));
d796 1
a796 1
	unsigned char buffer[8192];
d838 1
a838 1
		if (!creds_to_radix(&creds, buffer))
d841 1
a841 1
		packet_put_string((char *) buffer, strlen(buffer));
d865 3
a867 1
	int type, i, payload_len;
d887 2
a888 1
	challenge = packet_get_string(&payload_len);
@


1.55
log
@retry rresvport_af(), too. from sumikawa@@ebina.hitachi.co.jp.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.54 2000/02/05 10:13:11 markus Exp $");
d959 2
a960 1
		if (read(connection_in, &buf[i], 1) != 1)
d962 2
@


1.54
log
@missing xfree()
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.53 2000/01/18 09:42:17 markus Exp $");
d153 3
a155 2
			fatal("rresvport: af=%d %.100s", family, strerror(errno));
		debug("Allocated local port %d.", p);
@


1.53
log
@disable agent fwding for proto 1.3, remove abuse of auth-rsa flags.
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.52 2000/01/16 23:53:02 markus Exp $");
d888 1
@


1.52
log
@destroy keys earlier
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.51 2000/01/16 23:03:10 markus Exp $");
d988 2
a989 3
		if (options.forward_agent && strcmp(remote_version, "OpenSSH-1.1") != 0) {
			log("Agent forwarding disabled, remote version '%s' is not compatible.",
			    remote_version);
@


1.51
log
@split key exchange (kex) and user authentication (user-auth), ok: provos@@
@
text
@d11 1
a11 1
RCSID("$OpenBSD: sshconnect.c,v 1.50 2000/01/05 08:32:42 markus Exp $");
d1409 4
d1438 1
a1438 1
	/* Send the encrypted encryption key. */
d1440 1
a1447 5

	/* Destroy the session key integer and the public keys since we no longer need them. */
	BN_clear_free(key);
	RSA_free(public_key);
	RSA_free(host_key);
@


1.50
log
@better error message
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.49 2000/01/04 00:08:00 markus Exp $");
d31 3
d1270 1
a1270 7
 * Starts a dialog with the server, and authenticates the current user on the
 * server.  This does not need any extra privileges.  The basic connection
 * to the server must already have been established before this is called.
 * User is the remote user; if it is NULL, the current local user name will
 * be used.  Anonymous indicates that no rhosts authentication will be used.
 * If login fails, this function prints an error and never returns.
 * This function does not require super-user privileges.
d1273 1
a1273 5
ssh_login(int host_key_valid,
	  RSA *own_host_key,
	  const char *orighost,
	  struct sockaddr *hostaddr,
	  uid_t original_real_uid)
d1275 1
a1275 2
	int i, type;
	struct passwd *pw;
d1281 2
a1282 4
	const char *server_user, *local_user;
	char *host, *cp;
	unsigned char check_bytes[8];
	unsigned int supported_ciphers, supported_authentications;
a1286 19
	/* Convert the user-supplied hostname into all lowercase. */
	host = xstrdup(orighost);
	for (cp = host; *cp; cp++)
		if (isupper(*cp))
			*cp = tolower(*cp);

	/* Exchange protocol version identification strings with the server. */
	ssh_exchange_identification();

	/* Put the connection into non-blocking mode. */
	packet_set_nonblocking();

	/* Get local user name.  Use it as server user if no user name was given. */
	pw = getpwuid(original_real_uid);
	if (!pw)
		fatal("User id %d not found from user database.", original_real_uid);
	local_user = xstrdup(pw->pw_name);
	server_user = options.user ? options.user : local_user;

d1292 1
a1292 1
	/* Get check bytes from the packet. */
d1294 1
a1294 1
		check_bytes[i] = packet_get_char();
d1347 1
a1347 1
	compute_session_id(session_id, check_bytes, host_key->n, public_key->n);
d1430 1
a1430 1
	/* Send the check bytes back to the server. */
d1432 1
a1432 1
		packet_put_char(check_bytes[i]);
d1464 20
d1601 34
@


1.49
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.48 2000/01/02 14:25:51 markus Exp $");
d32 1
d212 2
a213 1
		fatal("Bad host name: %.100s (%s)", host, gai_strerror(gaierr));
@


1.48
log
@compare correct version for 1.3 compat mode
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.47 1999/12/20 08:35:36 markus Exp $");
d45 1
a45 1
	char portstring[100];
d48 1
a48 1
	snprintf(portstring, sizeof portstring, "%hu", port);
d65 1
a65 1
			buffer_append(&command, portstring, strlen(portstring));
d137 1
a137 1
ssh_create_socket(uid_t original_real_uid, int privileged)
d147 1
a147 2

		sock = rresvport(&p);
d149 1
a149 1
			fatal("rresvport: %.100s", strerror(errno));
d157 1
a157 1
		sock = socket(AF_INET, SOCK_STREAM, 0);
d159 1
a159 1
			fatal("socket: %.100s", strerror(errno));
d166 3
a168 2
 * Opens a TCP/IP connection to the remote server on the given host.  If
 * port is 0, the default port will be used.  If anonymous is zero,
d177 1
a177 1
ssh_connect(const char *host, struct sockaddr_in * hostaddr,
d182 1
a182 2
	int sock = -1, attempt, i;
	int on = 1;
d184 3
a186 1
	struct hostent *hp;
d206 6
a211 2
	/* No host lookup made yet. */
	hp = NULL;
d222 24
a245 19
		/* Try to parse the host name as a numeric inet address. */
		memset(hostaddr, 0, sizeof(hostaddr));
		hostaddr->sin_family = AF_INET;
		hostaddr->sin_port = htons(port);
		hostaddr->sin_addr.s_addr = inet_addr(host);
		if ((hostaddr->sin_addr.s_addr & 0xffffffff) != 0xffffffff) {
			/* Valid numeric IP address */
			debug("Connecting to %.100s port %d.",
			      inet_ntoa(hostaddr->sin_addr), port);

			/* Create a socket. */
			sock = ssh_create_socket(original_real_uid,
					  !anonymous && geteuid() == 0 &&
						 port < IPPORT_RESERVED);

			/*
			 * Connect to the host.  We use the user's uid in the
			 * hope that it will help with the problems of
			 * tcp_wrappers showing the remote uid as root.
d248 3
a250 3
			if (connect(sock, (struct sockaddr *) hostaddr, sizeof(*hostaddr))
			    >= 0) {
				/* Successful connect. */
d253 1
a253 47
			}
			debug("connect: %.100s", strerror(errno));
			restore_uid();

			/* Destroy the failed socket. */
			shutdown(sock, SHUT_RDWR);
			close(sock);
		} else {
			/* Not a valid numeric inet address. */
			/* Map host name to an address. */
			if (!hp)
				hp = gethostbyname(host);
			if (!hp)
				fatal("Bad host name: %.100s", host);
			if (!hp->h_addr_list[0])
				fatal("Host does not have an IP address: %.100s", host);

			/* Loop through addresses for this host, and try
			   each one in sequence until the connection
			   succeeds. */
			for (i = 0; hp->h_addr_list[i]; i++) {
				/* Set the address to connect to. */
				hostaddr->sin_family = hp->h_addrtype;
				memcpy(&hostaddr->sin_addr, hp->h_addr_list[i],
				       sizeof(hostaddr->sin_addr));

				debug("Connecting to %.200s [%.100s] port %d.",
				      host, inet_ntoa(hostaddr->sin_addr), port);

				/* Create a socket for connecting. */
				sock = ssh_create_socket(original_real_uid,
					  !anonymous && geteuid() == 0 &&
						 port < IPPORT_RESERVED);

				/*
				 * Connect to the host.  We use the user's
				 * uid in the hope that it will help with
				 * tcp_wrappers showing the remote uid as
				 * root.
				 */
				temporarily_use_uid(original_real_uid);
				if (connect(sock, (struct sockaddr *) hostaddr,
					    sizeof(*hostaddr)) >= 0) {
					/* Successful connection. */
					restore_uid();
					break;
				}
a255 1

a264 2
			if (hp->h_addr_list[i])
				break;	/* Successful connection. */
d266 2
d272 3
a285 1
	setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void *) &on, sizeof(on));
d1057 1
a1057 3
check_host_key(char *host,
    struct sockaddr_in *hostaddr,
    RSA *host_key)
d1064 26
a1089 2
	int host_ip_differ = 0;
	int local = (ntohl(hostaddr->sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d1098 6
a1103 2
	if (options.check_host_ip)
		ip = xstrdup(inet_ntoa(hostaddr->sin_addr));
a1124 12
	 * Force accepting of the host key for localhost and 127.0.0.1. The
	 * problem is that if the home directory is NFS-mounted to multiple
	 * machines, localhost will refer to a different machine in each of
	 * them, and the user will get bogus HOST_CHANGED warnings.  This
	 * essentially disables host authentication for localhost; however,
	 * this is probably not a real problem.
	 */
	if (local) {
		debug("Forcing accepting of host key for localhost.");
		host_status = HOST_OK;
	}
	/*
d1277 1
a1277 1
	  struct sockaddr_in *hostaddr,
@


1.47
log
@say "REMOTE HOST IDENTIFICATION HAS CHANGED"
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.46 1999/12/08 22:39:21 markus Exp $");
d1018 1
a1018 1
		if (options.forward_agent && strcmp(remote_version, SSH_VERSION) != 0) {
@


1.46
log
@move checking of hostkey into own function.
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.45 1999/12/06 20:15:30 deraadt Exp $");
d1243 1
a1243 1
		error("@@       WARNING: HOST IDENTIFICATION HAS CHANGED!         @@");
@


1.45
log
@move atomicio into it's own file.  wrap all socket write()s which were doing
write(sock, buf, len) != len, with atomicio() calls.
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.44 1999/12/01 16:51:19 markus Exp $");
d153 4
a156 2
		/* Just create an ordinary socket on arbitrary port.  We
		   use the user's uid to create the socket. */
d208 5
a212 3
	/* Try to connect several times.  On some machines, the first time
	   will sometimes fail.  In general socket code appears to behave
	   quite magically on many machines. */
d1088 1
a1088 7
 * Starts a dialog with the server, and authenticates the current user on the
 * server.  This does not need any extra privileges.  The basic connection
 * to the server must already have been established before this is called.
 * User is the remote user; if it is NULL, the current local user name will
 * be used.  Anonymous indicates that no rhosts authentication will be used.
 * If login fails, this function prints an error and never returns.
 * This function does not require super-user privileges.
d1090 1
d1092 3
a1094 5
ssh_login(int host_key_valid,
	  RSA *own_host_key,
	  const char *orighost,
	  struct sockaddr_in *hostaddr,
	  uid_t original_real_uid)
d1096 2
a1097 9
	int i, type;
	struct passwd *pw;
	BIGNUM *key;
	RSA *host_key, *file_key;
	RSA *public_key;
	int bits, rbits;
	unsigned char session_key[SSH_SESSION_KEY_LENGTH];
	const char *server_user, *local_user;
	char *cp, *host, *ip = NULL;
a1098 2
	unsigned char check_bytes[8];
	unsigned int supported_ciphers, supported_authentications, protocol_flags;
a1102 2
	int payload_len, clen, sum_len = 0;
	u_int32_t rand = 0;
d1114 4
a1117 62
	/* Convert the user-supplied hostname into all lowercase. */
	host = xstrdup(orighost);
	for (cp = host; *cp; cp++)
		if (isupper(*cp))
			*cp = tolower(*cp);

	/* Exchange protocol version identification strings with the server. */
	ssh_exchange_identification();

	/* Put the connection into non-blocking mode. */
	packet_set_nonblocking();

	/* Get local user name.  Use it as server user if no user name was given. */
	pw = getpwuid(original_real_uid);
	if (!pw)
		fatal("User id %d not found from user database.", original_real_uid);
	local_user = xstrdup(pw->pw_name);
	server_user = options.user ? options.user : local_user;

	debug("Waiting for server public key.");

	/* Wait for a public key packet from the server. */
	packet_read_expect(&payload_len, SSH_SMSG_PUBLIC_KEY);

	/* Get check bytes from the packet. */
	for (i = 0; i < 8; i++)
		check_bytes[i] = packet_get_char();

	/* Get the public key. */
	public_key = RSA_new();
	bits = packet_get_int();/* bits */
	public_key->e = BN_new();
	packet_get_bignum(public_key->e, &clen);
	sum_len += clen;
	public_key->n = BN_new();
	packet_get_bignum(public_key->n, &clen);
	sum_len += clen;

	rbits = BN_num_bits(public_key->n);
	if (bits != rbits) {
		log("Warning: Server lies about size of server public key: "
		    "actual size is %d bits vs. announced %d.", rbits, bits);
		log("Warning: This may be due to an old implementation of ssh.");
	}
	/* Get the host key. */
	host_key = RSA_new();
	bits = packet_get_int();/* bits */
	host_key->e = BN_new();
	packet_get_bignum(host_key->e, &clen);
	sum_len += clen;
	host_key->n = BN_new();
	packet_get_bignum(host_key->n, &clen);
	sum_len += clen;

	rbits = BN_num_bits(host_key->n);
	if (bits != rbits) {
		log("Warning: Server lies about size of server host key: "
		    "actual size is %d bits vs. announced %d.", rbits, bits);
		log("Warning: This may be due to an old implementation of ssh.");
	}
	/* Store the host key from the known host file in here so that we
	   can compare it with the key for the IP address. */
a1121 16
	/* Get protocol flags. */
	protocol_flags = packet_get_int();
	packet_set_protocol_flags(protocol_flags);

	supported_ciphers = packet_get_int();
	supported_authentications = packet_get_int();

	debug("Received server public key (%d bits) and host key (%d bits).",
	      BN_num_bits(public_key->n), BN_num_bits(host_key->n));

	packet_integrity_check(payload_len,
			       8 + 4 + sum_len + 0 + 4 + 0 + 0 + 4 + 4 + 4,
			       SSH_SMSG_PUBLIC_KEY);

	compute_session_id(session_id, check_bytes, host_key->n, public_key->n);

a1280 1

d1283 113
d1486 1
a1486 1
	packet_put_int(SSH_PROTOFLAG_SCREEN_NUMBER | SSH_PROTOFLAG_HOST_IN_FWD_OPEN);
@


1.44
log
@typo
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.43 1999/12/01 14:24:38 markus Exp $");
d534 1
a534 1
			 comment);
d1033 2
a1034 2
		 PROTOCOL_MAJOR, PROTOCOL_MINOR, SSH_VERSION);
	if (write(connection_out, buf, strlen(buf)) != strlen(buf))
d1289 4
a1292 4
				 "The authenticity of host '%.200s' can't be established.\n"
				 "Key fingerprint is %d %s.\n"
				 "Are you sure you want to continue connecting (yes/no)? ",
			         host, BN_num_bits(host_key->n), fp);
d1596 1
d1598 1
a1598 1
			 server_user, host);
@


1.43
log
@easier to read client code for passwd and skey auth
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.42 1999/12/01 14:07:22 markus Exp $");
d1119 1
a1119 1
	 * Turn of check_host_ip for proxy connects, since
@


1.42
log
@turn of checkhostip for proxy connects, since we don't know the remote ip
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.41 1999/12/01 13:59:15 markus Exp $");
d31 2
d475 1
a475 1
try_rsa_authentication(struct passwd * pw, const char *authfile)
a476 1
	extern Options options;
d488 2
a489 1
		return 0;	/* Could not load it.  Fail. */
d512 1
a512 2
		return 0;	/* Server refuses to authenticate with
				   this key. */
d883 87
a979 1
	extern Options options;
a1098 1
	extern Options options;
a1099 1
	char *password;
d1583 1
a1583 1
			if (try_rsa_authentication(pw, options.identity_files[i]))
d1589 2
a1590 41
		debug("Doing skey authentication.");

		/* request a challenge */
		packet_start(SSH_CMSG_AUTH_TIS);
		packet_send();
		packet_write_wait();

		type = packet_read(&payload_len);
		if (type != SSH_SMSG_FAILURE &&
		    type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
			packet_disconnect("Protocol error: got %d in response "
					  "to skey auth", type);
		}
		if (type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
			debug("No challenge for skey authentication.");
		} else {
			char *challenge, *response;
			challenge = packet_get_string(&payload_len);
			if (options.cipher == SSH_CIPHER_NONE)
				log("WARNING: Encryption is disabled! "
				    "Reponse will be transmitted in clear text.");
			fprintf(stderr, "%s\n", challenge);
			fflush(stderr);
			for (i = 0; i < options.number_of_password_prompts; i++) {
				if (i != 0)
					error("Permission denied, please try again.");
				response = read_passphrase("Response: ", 0);
				packet_start(SSH_CMSG_AUTH_TIS_RESPONSE);
				packet_put_string(response, strlen(response));
				memset(response, 0, strlen(response));
				xfree(response);
				packet_send();
				packet_write_wait();
				type = packet_read(&payload_len);
				if (type == SSH_SMSG_SUCCESS)
					return;
				if (type != SSH_SMSG_FAILURE)
					packet_disconnect("Protocol error: got %d in response "
						   	  "to skey auth", type);
			}
		}
d1596 1
a1596 1
		snprintf(prompt, sizeof(prompt), "%.30s@@%.30s's password: ",
d1598 2
a1599 20
		debug("Doing password authentication.");
		if (options.cipher == SSH_CIPHER_NONE)
			log("WARNING: Encryption is disabled! Password will be transmitted in clear text.");
		for (i = 0; i < options.number_of_password_prompts; i++) {
			if (i != 0)
				error("Permission denied, please try again.");
			password = read_passphrase(prompt, 0);
			packet_start(SSH_CMSG_AUTH_PASSWORD);
			packet_put_string(password, strlen(password));
			memset(password, 0, strlen(password));
			xfree(password);
			packet_send();
			packet_write_wait();

			type = packet_read(&payload_len);
			if (type == SSH_SMSG_SUCCESS)
				return;
			if (type != SSH_SMSG_FAILURE)
				packet_disconnect("Protocol error: got %d in response to passwd auth", type);
		}
@


1.41
log
@ports are u_short
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.40 1999/11/24 19:53:53 markus Exp $");
d1032 7
@


1.40
log
@KNF, final part 3
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.39 1999/11/24 00:26:03 deraadt Exp $");
d35 1
a35 1
ssh_proxy_connect(const char *host, int port, uid_t original_real_uid,
d46 1
a46 1
	snprintf(portstring, sizeof portstring, "%d", port);
d174 1
a174 1
	    int port, int connection_attempts,
@


1.39
log
@much more KNF
@
text
@d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.38 1999/11/23 22:25:55 markus Exp $");
d139 4
a142 2
	/* If we are running as root and want to connect to a privileged
	   port, bind our own socket to a privileged port. */
d226 5
a230 3
			/* Connect to the host.  We use the user's uid in
			   the hope that it will help with the problems of
			   tcp_wrappers showing the remote uid as root. */
d271 6
a276 2
				/* Connect to the host.  We use the user's uid in the hope that
				   it will help with tcp_wrappers showing the remote uid as root. */
d287 6
a292 2
				/* Close the failed socket; there appear to be some problems when
				   reusing a socket for which connect() has already returned an error. */
d309 5
a313 4
	/* Set socket options.  We would like the socket to disappear as
	   soon as it has been closed for whatever reason. */
	/* setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&on,
	   sizeof(on)); */
d503 4
a506 2
	/* The server responds with failure if it doesn\'t like our key or
	   doesn\'t support RSA authentication. */
d526 4
a529 2
	/* Load the private key.  Try first with empty passphrase; if it
	   fails, ask for a passphrase. */
d734 5
a738 3
		/* If his response isn't properly encrypted with the
		   session key, and the decrypted checksum fails to match,
		   he's bogus. Bail out. */
d910 4
a913 2
	/* Check that the versions match.  In future this might accept
	   several versions and set appropriate flags to handle them. */
d934 5
a938 3
	/* Removed for now, to permit compatibility with latter versions.
	   The server will reject our version and disconnect if it doesn't
	   support it. */
a1105 1
	/* Get supported cipher types. */
a1106 2

	/* Get supported authentication types. */
a1115 1
	/* Compute the session id. */
d1118 4
a1121 2
	/* Check if the host key is present in the user\'s list of known
	   hosts or in the systemwide list. */
d1129 8
a1136 6
	/* Force accepting of the host key for localhost and 127.0.0.1.
	   The problem is that if the home directory is NFS-mounted to
	   multiple machines, localhost will refer to a different machine
	   in each of them, and the user will get bogus HOST_CHANGED
	   warnings.  This essentially disables host authentication for
	   localhost; however, this is probably not a real problem. */
d1141 4
a1144 2
	/* Also perform check for the ip address, skip the check if we are
	   localhost or the hostname was an ip address to begin with */
d1248 4
a1251 2
		/* If strict host key checking is in use, the user will
		   have to edit the key manually and we can only abort. */
d1255 5
a1259 2
		/* If strict host key checking has not been requested, allow the connection
		   but without password authentication or agent forwarding. */
d1268 7
a1274 5
		/* XXX Should permit the user to change to use the new id.
		   This could be done by converting the host key to an
		   identifying sentence, tell that the host identifies
		   itself by that sentence, and ask the user if he/she
		   whishes to accept the authentication. */
d1284 5
a1288 3
	/* Generate an encryption key for the session.   The key is a 256
	   bit random number, interpreted as a 32-byte key, with the least
	   significant 8 bits being the first byte of the key. */
d1296 5
a1300 3
	/* According to the protocol spec, the first byte of the session
	   key is the highest byte of the integer.  The session key is
	   xored with the first 16 bytes of the session id. */
d1311 4
a1314 2
	/* Encrypt the integer using the public key and host key of the
	   server (key with smaller modulus first). */
d1389 4
a1392 2
	/* Expect a success message from the server.  Note that this
	   message will be received in encrypted form. */
d1403 5
a1407 3
	/* The server should respond with success if no authentication is
	   needed (the user has no password).  Otherwise the server
	   responds with failure. */
d1449 4
a1452 2
	/* Use rhosts authentication if running in privileged socket and
	   we do not wish to remain anonymous. */
d1469 4
a1472 2
	/* Try .rhosts or /etc/hosts.equiv authentication with RSA host
	   authentication. */
d1481 5
a1485 4
		/* Try RSA authentication using the authentication agent.
		   The agent is tried first because no passphrase is
		   needed for it, whereas identity files may require
		   passphrases. */
@


1.38
log
@KNF part 1
@
text
@d2 7
a8 14

sshconnect.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Mar 18 22:15:47 1995 ylo

Code to connect to a remote host, and to perform the client side of the
login (authentication) dialog.

*/
d11 1
a11 1
RCSID("$Id: sshconnect.c,v 1.37 1999/11/22 21:52:42 markus Exp $");
d31 3
a33 2
/* Connect to the given ssh server using a proxy command. */

d131 3
a133 2
/* Creates a (possibly privileged) socket for use as the ssh connection. */

d160 10
a169 9
/* Opens a TCP/IP connection to the remote server on the given host.  If
   port is 0, the default port will be used.  If anonymous is zero,
   a privileged port will be allocated to make the connection.
   This requires super-user privileges if anonymous is false.
   Connection_attempts specifies the maximum number of tries (one per
   second).  If proxy_command is non-NULL, it specifies the command (with %h
   and %p substituted for host and port, respectively) to use to contact
   the daemon. */

d312 4
a315 3
/* Checks if the user has an authentication agent, and if so, tries to
   authenticate using the agent. */

d413 4
a416 3
/* Computes the proper response to a RSA challenge, and sends the response to
   the server. */

d455 4
a458 3
/* Checks if the user has authentication file, and if so, tries to authenticate
   the user using it. */

d571 4
a574 3
/* Tries to authenticate the user using combined rhosts or /etc/hosts.equiv
   authentication and RSA host authentication. */

d862 4
a865 3
/* Waits for the server identification string, and sends our own
   identification string. */

d973 9
a981 8
/* Starts a dialog with the server, and authenticates the current user on the
   server.  This does not need any extra privileges.  The basic connection
   to the server must already have been established before this is called.
   User is the remote user; if it is NULL, the current local user name will
   be used.  Anonymous indicates that no rhosts authentication will be used.
   If login fails, this function prints an error and never returns.
   This function does not require super-user privileges. */

@


1.37
log
@tranfer s/key challenge/response data in SSH_SMSG_AUTH_TIS_CHALLENGE
messages. allows use of s/key in windows (ttssh, securecrt) and
ssh-1.2.27 clients without 'ssh -v', ok: niels@@
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.36 1999/11/19 19:58:18 markus Exp $");
d44 89
a132 94
  Buffer command;
  const char *cp;
  char *command_string;
  int pin[2], pout[2];
  int pid;
  char portstring[100];

  /* Convert the port number into a string. */
  snprintf(portstring, sizeof portstring, "%d", port);

  /* Build the final command string in the buffer by making the appropriate
     substitutions to the given proxy command. */
  buffer_init(&command);
  for (cp = proxy_command; *cp; cp++)
    {
      if (cp[0] == '%' && cp[1] == '%')
	{
	  buffer_append(&command, "%", 1);
	  cp++;
	  continue;
	}
      if (cp[0] == '%' && cp[1] == 'h')
	{
	  buffer_append(&command, host, strlen(host));
	  cp++;
	  continue;
	}
      if (cp[0] == '%' && cp[1] == 'p')
	{
	  buffer_append(&command, portstring, strlen(portstring));
	  cp++;
	  continue;
	}
      buffer_append(&command, cp, 1);
    }
  buffer_append(&command, "\0", 1);

  /* Get the final command string. */
  command_string = buffer_ptr(&command);

  /* Create pipes for communicating with the proxy. */
  if (pipe(pin) < 0 || pipe(pout) < 0)
    fatal("Could not create pipes to communicate with the proxy: %.100s",
	  strerror(errno));

  debug("Executing proxy command: %.500s", command_string);

  /* Fork and execute the proxy command. */
  if ((pid = fork()) == 0)
    {
      char *argv[10];

      /* Child.  Permanently give up superuser privileges. */
      permanently_set_uid(original_real_uid);

      /* Redirect stdin and stdout. */
      close(pin[1]);
      if (pin[0] != 0)
	{
	  if (dup2(pin[0], 0) < 0)
	    perror("dup2 stdin");
	  close(pin[0]);
	}
      close(pout[0]);
      if (dup2(pout[1], 1) < 0)
	perror("dup2 stdout");
      close(pout[1]); /* Cannot be 1 because pin allocated two descriptors. */

      /* Stderr is left as it is so that error messages get printed on
	 the user's terminal. */
      argv[0] = "/bin/sh";
      argv[1] = "-c";
      argv[2] = command_string;
      argv[3] = NULL;
      
      /* Execute the proxy command.  Note that we gave up any extra 
	 privileges above. */
      execv("/bin/sh", argv);
      perror("/bin/sh");
      exit(1);
    }
  /* Parent. */
  if (pid < 0)
    fatal("fork failed: %.100s", strerror(errno));
  
  /* Close child side of the descriptors. */
  close(pin[0]);
  close(pout[1]);

  /* Free the command name. */
  buffer_free(&command);
  
  /* Set the connection file descriptors. */
  packet_set_connection(pout[0], pin[1]);
d134 1
a134 1
  return 1;
d139 2
a140 1
int ssh_create_socket(uid_t original_real_uid, int privileged)
d142 1
a142 1
  int sock;
d144 19
a162 22
  /* If we are running as root and want to connect to a privileged port,
     bind our own socket to a privileged port. */
  if (privileged)
    {
      int p = IPPORT_RESERVED - 1;

      sock = rresvport(&p);
      if (sock < 0)
        fatal("rresvport: %.100s", strerror(errno));
      debug("Allocated local port %d.", p);
    }
  else
    { 
      /* Just create an ordinary socket on arbitrary port.  We use the
	 user's uid to create the socket. */
      temporarily_use_uid(original_real_uid);
      sock = socket(AF_INET, SOCK_STREAM, 0);
      if (sock < 0)
	fatal("socket: %.100s", strerror(errno));
      restore_uid();
    }
  return sock;
d167 2
a168 2
   a privileged port will be allocated to make the connection. 
   This requires super-user privileges if anonymous is false. 
d170 1
a170 1
   second).  If proxy_command is non-NULL, it specifies the command (with %h 
d174 5
a178 4
int ssh_connect(const char *host, struct sockaddr_in *hostaddr,
		int port, int connection_attempts,
		int anonymous, uid_t original_real_uid, 
		const char *proxy_command)
d180 111
a290 138
  int sock = -1, attempt, i;
  int on = 1;
  struct servent *sp;
  struct hostent *hp;
  struct linger linger;

  debug("ssh_connect: getuid %d geteuid %d anon %d", 
	(int)getuid(), (int)geteuid(), anonymous);

  /* Get default port if port has not been set. */
  if (port == 0)
    {
      sp = getservbyname(SSH_SERVICE_NAME, "tcp");
      if (sp)
	port = ntohs(sp->s_port);
      else
	port = SSH_DEFAULT_PORT;
    }

  /* If a proxy command is given, connect using it. */
  if (proxy_command != NULL)
    return ssh_proxy_connect(host, port, original_real_uid, proxy_command);

  /* No proxy command. */

  /* No host lookup made yet. */
  hp = NULL;
  
  /* Try to connect several times.  On some machines, the first time will
     sometimes fail.  In general socket code appears to behave quite
     magically on many machines. */
  for (attempt = 0; attempt < connection_attempts; attempt++)
    {
      if (attempt > 0)
	debug("Trying again...");

      /* Try to parse the host name as a numeric inet address. */
      memset(hostaddr, 0, sizeof(hostaddr));
      hostaddr->sin_family = AF_INET;
      hostaddr->sin_port = htons(port);
      hostaddr->sin_addr.s_addr = inet_addr(host);
      if ((hostaddr->sin_addr.s_addr & 0xffffffff) != 0xffffffff)
	{ 
	  /* Valid numeric IP address */
	  debug("Connecting to %.100s port %d.", 
		inet_ntoa(hostaddr->sin_addr), port);
      
	  /* Create a socket. */
	  sock = ssh_create_socket(original_real_uid, 
				   !anonymous && geteuid() == 0 && 
				     port < IPPORT_RESERVED);
      
	  /* Connect to the host.  We use the user's uid in the hope that
	     it will help with the problems of tcp_wrappers showing the
	     remote uid as root. */
	  temporarily_use_uid(original_real_uid);
	  if (connect(sock, (struct sockaddr *)hostaddr, sizeof(*hostaddr))
	      >= 0)
	    {
	      /* Successful connect. */
	      restore_uid();
	      break;
	    }
	  debug("connect: %.100s", strerror(errno));
	  restore_uid();

	  /* Destroy the failed socket. */
	  shutdown(sock, SHUT_RDWR);
	  close(sock);
	}
      else
	{ 
	  /* Not a valid numeric inet address. */
	  /* Map host name to an address. */
	  if (!hp)
	    hp = gethostbyname(host);
	  if (!hp)
	    fatal("Bad host name: %.100s", host);
	  if (!hp->h_addr_list[0])
	    fatal("Host does not have an IP address: %.100s", host);

	  /* Loop through addresses for this host, and try each one in
	     sequence until the connection succeeds. */
	  for (i = 0; hp->h_addr_list[i]; i++)
	    {
	      /* Set the address to connect to. */
	      hostaddr->sin_family = hp->h_addrtype;
	      memcpy(&hostaddr->sin_addr, hp->h_addr_list[i],
		     sizeof(hostaddr->sin_addr));

	      debug("Connecting to %.200s [%.100s] port %d.",
		    host, inet_ntoa(hostaddr->sin_addr), port);

	      /* Create a socket for connecting. */
	      sock = ssh_create_socket(original_real_uid, 
				       !anonymous && geteuid() == 0 && 
				         port < IPPORT_RESERVED);

	      /* Connect to the host.  We use the user's uid in the hope that
	         it will help with tcp_wrappers showing the remote uid as
		 root. */
	      temporarily_use_uid(original_real_uid);
	      if (connect(sock, (struct sockaddr *)hostaddr, 
			  sizeof(*hostaddr)) >= 0)
		{
		  /* Successful connection. */
		  restore_uid();
		  break;
		}
	      debug("connect: %.100s", strerror(errno));
	      restore_uid();

	      /* Close the failed socket; there appear to be some problems 
		 when reusing a socket for which connect() has already 
		 returned an error. */
	      shutdown(sock, SHUT_RDWR);
	      close(sock);
	    }
	  if (hp->h_addr_list[i])
	    break; /* Successful connection. */
	}

      /* Sleep a moment before retrying. */
      sleep(1);
    }
  /* Return failure if we didn't get a successful connection. */
  if (attempt >= connection_attempts)
    return 0;

  debug("Connection established.");

  /* Set socket options.  We would like the socket to disappear as soon as
     it has been closed for whatever reason. */
  /* setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on)); */
  setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void *)&on, sizeof(on));
  linger.l_onoff = 1;
  linger.l_linger = 5;
  setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof(linger));
d292 20
a311 2
  /* Set the connection. */
  packet_set_connection(sock, sock);
d313 1
a313 1
  return 1;
d322 61
a382 96
  int status, type;
  char *comment;
  AuthenticationConnection *auth;
  unsigned char response[16];
  unsigned int i;
  BIGNUM *e, *n, *challenge;
  
  /* Get connection to the agent. */
  auth = ssh_get_authentication_connection();
  if (!auth)
    return 0;
  
  e = BN_new();
  n = BN_new();
  challenge = BN_new();
  
  /* Loop through identities served by the agent. */
  for (status = ssh_get_first_identity(auth, e, n, &comment);
       status;
       status = ssh_get_next_identity(auth, e, n, &comment))
    {
      int plen, clen;

      /* Try this identity. */
      debug("Trying RSA authentication via agent with '%.100s'", comment);
      xfree(comment);
      
      /* Tell the server that we are willing to authenticate using this key. */
      packet_start(SSH_CMSG_AUTH_RSA);
      packet_put_bignum(n);
      packet_send();
      packet_write_wait();
      
      /* Wait for server's response. */
      type = packet_read(&plen);
      
      /* The server sends failure if it doesn\'t like our key or does not
	 support RSA authentication. */
      if (type == SSH_SMSG_FAILURE)
	{
	  debug("Server refused our key.");
	  continue;
	}
      
      /* Otherwise it should have sent a challenge. */
      if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
	packet_disconnect("Protocol error during RSA authentication: %d", 
			  type);
      
      packet_get_bignum(challenge, &clen);
      
      packet_integrity_check(plen, clen, type);

      debug("Received RSA challenge from server.");
      
      /* Ask the agent to decrypt the challenge. */
      if (!ssh_decrypt_challenge(auth, e, n, challenge, 
				 session_id, 1, response))
	{
	  /* The agent failed to authenticate this identifier although it
	     advertised it supports this.  Just return a wrong value. */
	  log("Authentication agent failed to decrypt challenge.");
	  memset(response, 0, sizeof(response));
	}
      
      debug("Sending response to RSA challenge.");
      
      /* Send the decrypted challenge back to the server. */
      packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
      for (i = 0; i < 16; i++)
	packet_put_char(response[i]);
      packet_send();
      packet_write_wait();
      
      /* Wait for response from the server. */
      type = packet_read(&plen);

      /* The server returns success if it accepted the authentication. */
      if (type == SSH_SMSG_SUCCESS)
	{
	  debug("RSA authentication accepted by server.");
	  BN_clear_free(e);
	  BN_clear_free(n);
	  BN_clear_free(challenge);
	  return 1;
	}

      /* Otherwise it should return failure. */
      if (type != SSH_SMSG_FAILURE)
	packet_disconnect("Protocol error waiting RSA auth response: %d", 
			  type);
    }

  BN_clear_free(e);
  BN_clear_free(n);
  BN_clear_free(challenge);
d384 30
a413 2
  debug("RSA authentication using agent refused.");
  return 0;
d420 1
a420 1
respond_to_rsa_challenge(BIGNUM *challenge, RSA *prv)
d422 33
a454 33
  unsigned char buf[32], response[16];
  MD5_CTX md;
  int i, len;

  /* Decrypt the challenge using the private key. */
  rsa_private_decrypt(challenge, challenge, prv);

  /* Compute the response. */
  /* The response is MD5 of decrypted challenge plus session id. */
  len = BN_num_bytes(challenge);
  if (len <= 0 || len > sizeof(buf))
    packet_disconnect("respond_to_rsa_challenge: bad challenge length %d",
		      len);

  memset(buf, 0, sizeof(buf));
  BN_bn2bin(challenge, buf + sizeof(buf) - len);
  MD5_Init(&md);
  MD5_Update(&md, buf, 32);
  MD5_Update(&md, session_id, 16);
  MD5_Final(response, &md);
  
  debug("Sending response to host key RSA challenge.");

  /* Send the response back to the server. */
  packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
  for (i = 0; i < 16; i++)
    packet_put_char(response[i]);
  packet_send();
  packet_write_wait();
  
  memset(buf, 0, sizeof(buf));
  memset(response, 0, sizeof(response));
  memset(&md, 0, sizeof(md));
d461 1
a461 1
try_rsa_authentication(struct passwd *pw, const char *authfile)
d463 107
a569 119
  extern Options options;
  BIGNUM *challenge;
  RSA *private_key;
  RSA *public_key;
  char *passphrase, *comment;
  int type, i;
  int plen, clen;

  /* Try to load identification for the authentication key. */
  public_key = RSA_new();
  if (!load_public_key(authfile, public_key, &comment)) {
    RSA_free(public_key);
    return 0; /* Could not load it.  Fail. */
  }

  debug("Trying RSA authentication with key '%.100s'", comment);

  /* Tell the server that we are willing to authenticate using this key. */
  packet_start(SSH_CMSG_AUTH_RSA);
  packet_put_bignum(public_key->n);
  packet_send();
  packet_write_wait();

  /* We no longer need the public key. */
  RSA_free(public_key);
  
  /* Wait for server's response. */
  type = packet_read(&plen);

  /* The server responds with failure if it doesn\'t like our key or doesn\'t
     support RSA authentication. */
  if (type == SSH_SMSG_FAILURE)
    {
      debug("Server refused our key.");
      xfree(comment);
      return 0; /* Server refuses to authenticate with this key. */
    }

  /* Otherwise, the server should respond with a challenge. */
  if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
    packet_disconnect("Protocol error during RSA authentication: %d", type);

  /* Get the challenge from the packet. */
  challenge = BN_new();
  packet_get_bignum(challenge, &clen);

  packet_integrity_check(plen, clen, type);

  debug("Received RSA challenge from server.");

  private_key = RSA_new();
  /* Load the private key.  Try first with empty passphrase; if it fails, 
     ask for a passphrase. */
  if (!load_private_key(authfile, "", private_key, NULL))
    {
      char buf[300];
      /* Request passphrase from the user.  We read from /dev/tty to make
         this work even if stdin has been redirected.  If running in
	 batch mode, we just use the empty passphrase, which will fail and
	 return. */
      snprintf(buf, sizeof buf,
	"Enter passphrase for RSA key '%.100s': ", comment);
      if (!options.batch_mode)
	passphrase = read_passphrase(buf, 0);
      else
	{
	  debug("Will not query passphrase for %.100s in batch mode.", 
		comment);
	  passphrase = xstrdup("");
	}
      
      /* Load the authentication file using the pasphrase. */
      if (!load_private_key(authfile, passphrase, private_key, NULL))
	{
	  memset(passphrase, 0, strlen(passphrase));
	  xfree(passphrase);
	  error("Bad passphrase.");

	  /* Send a dummy response packet to avoid protocol error. */
	  packet_start(SSH_CMSG_AUTH_RSA_RESPONSE);
	  for (i = 0; i < 16; i++)
	    packet_put_char(0);
	  packet_send();
	  packet_write_wait();

	  /* Expect the server to reject it... */
	  packet_read_expect(&plen, SSH_SMSG_FAILURE);
	  xfree(comment);
	  return 0;
	}

      /* Destroy the passphrase. */
      memset(passphrase, 0, strlen(passphrase));
      xfree(passphrase);
    }
  
  /* We no longer need the comment. */
  xfree(comment);

  /* Compute and send a response to the challenge. */
  respond_to_rsa_challenge(challenge, private_key);
  
  /* Destroy the private key. */
  RSA_free(private_key);

  /* We no longer need the challenge. */
  BN_clear_free(challenge);
  
  /* Wait for response from the server. */
  type = packet_read(&plen);
  if (type == SSH_SMSG_SUCCESS)
    {
      debug("RSA authentication accepted by server.");
      return 1;
    }
  if (type != SSH_SMSG_FAILURE)
    packet_disconnect("Protocol error waiting RSA auth response: %d", type);
  debug("RSA authentication refused.");
  return 0;
d576 1
a576 1
try_rhosts_rsa_authentication(const char *local_user, RSA *host_key)
d578 52
a629 55
  int type;
  BIGNUM *challenge;
  int plen, clen;

  debug("Trying rhosts or /etc/hosts.equiv with RSA host authentication.");

  /* Tell the server that we are willing to authenticate using this key. */
  packet_start(SSH_CMSG_AUTH_RHOSTS_RSA);
  packet_put_string(local_user, strlen(local_user));
  packet_put_int(BN_num_bits(host_key->n));
  packet_put_bignum(host_key->e);
  packet_put_bignum(host_key->n);
  packet_send();
  packet_write_wait();

  /* Wait for server's response. */
  type = packet_read(&plen);

  /* The server responds with failure if it doesn't admit our .rhosts
     authentication or doesn't know our host key. */
  if (type == SSH_SMSG_FAILURE)
    {
      debug("Server refused our rhosts authentication or host key.");
      return 0; /* Server refuses to authenticate us with this method. */
    }

  /* Otherwise, the server should respond with a challenge. */
  if (type != SSH_SMSG_AUTH_RSA_CHALLENGE)
    packet_disconnect("Protocol error during RSA authentication: %d", type);

  /* Get the challenge from the packet. */
  challenge = BN_new();
  packet_get_bignum(challenge, &clen);

  packet_integrity_check(plen, clen, type);

  debug("Received RSA challenge for host key from server.");

  /* Compute a response to the challenge. */
  respond_to_rsa_challenge(challenge, host_key);

  /* We no longer need the challenge. */
  BN_clear_free(challenge);
  
  /* Wait for response from the server. */
  type = packet_read(&plen);
  if (type == SSH_SMSG_SUCCESS)
    {
      debug("Rhosts or /etc/hosts.equiv with RSA host authentication accepted by server.");
      return 1;
    }
  if (type != SSH_SMSG_FAILURE)
    packet_disconnect("Protocol error waiting RSA auth response: %d", type);
  debug("Rhosts or /etc/hosts.equiv with RSA host authentication refused.");
  return 0;
d633 2
a634 1
int try_kerberos_authentication()
d636 106
a741 105
  KTEXT_ST auth;                     /* Kerberos data */
  char *reply;
  char inst[INST_SZ];
  char *realm;
  CREDENTIALS cred;
  int r, type, plen;
  Key_schedule schedule;
  u_long checksum, cksum;
  MSG_DAT msg_data;
  struct sockaddr_in local, foreign;
  struct stat st;

  /* Don't do anything if we don't have any tickets. */
  if (stat(tkt_string(), &st) < 0) return 0;
  
  strncpy(inst, (char *) krb_get_phost(get_canonical_hostname()), INST_SZ);
  
  realm = (char *)krb_realmofhost(get_canonical_hostname());
  if (!realm) {
    debug("Kerberos V4: no realm for %s", get_canonical_hostname());
    return 0;
  }
  /* This can really be anything. */
  checksum = (u_long) getpid();
  
  r = krb_mk_req(&auth, KRB4_SERVICE_NAME, inst, realm, checksum);
  if (r != KSUCCESS) {
    debug("Kerberos V4 krb_mk_req failed: %s", krb_err_txt[r]);
    return 0;
  }
  /* Get session key to decrypt the server's reply with. */
  r = krb_get_cred(KRB4_SERVICE_NAME, inst, realm, &cred);
  if (r != KSUCCESS) {
     debug("get_cred failed: %s", krb_err_txt[r]);
     return 0;
  }
  des_key_sched((des_cblock *)cred.session, schedule);
  
  /* Send authentication info to server. */
  packet_start(SSH_CMSG_AUTH_KERBEROS);
  packet_put_string((char *)auth.dat, auth.length);
  packet_send();
  packet_write_wait();
  
  /* Zero the buffer. */
  (void) memset(auth.dat, 0, MAX_KTXT_LEN);
  
  r = sizeof(local);
  memset(&local, 0, sizeof(local));
  if (getsockname(packet_get_connection_in(),
 		  (struct sockaddr *) &local, &r) < 0)
    debug("getsockname failed: %s", strerror(errno));
  
  r = sizeof(foreign);
  memset(&foreign, 0, sizeof(foreign));
   if (getpeername(packet_get_connection_in(),
		   (struct sockaddr *)&foreign, &r) < 0) {
     debug("getpeername failed: %s", strerror(errno));
     fatal_cleanup();
   }
   
   /* Get server reply. */
   type = packet_read(&plen);
   switch(type) {
     
   case SSH_SMSG_FAILURE: /* Should really be SSH_SMSG_AUTH_KERBEROS_FAILURE */
     debug("Kerberos V4 authentication failed.");
     return 0;
     break;
     
   case SSH_SMSG_AUTH_KERBEROS_RESPONSE: /* SSH_SMSG_AUTH_KERBEROS_SUCCESS */
     debug("Kerberos V4 authentication accepted.");
     
     /* Get server's response. */
     reply = packet_get_string((unsigned int *)&auth.length);
     memcpy(auth.dat, reply, auth.length);
     xfree(reply);
     
     packet_integrity_check(plen, 4 + auth.length, type);

     /* If his response isn't properly encrypted with the session key,
        and the decrypted checksum fails to match, he's bogus. Bail out. */
     r = krb_rd_priv(auth.dat, auth.length, schedule, &cred.session,
		     &foreign, &local, &msg_data);
     if (r != KSUCCESS) {
       debug("Kerberos V4 krb_rd_priv failed: %s", krb_err_txt[r]);
       packet_disconnect("Kerberos V4 challenge failed!");
     }
     /* Fetch the (incremented) checksum that we supplied in the request. */
     (void)memcpy((char *)&cksum, (char *)msg_data.app_data, sizeof(cksum));
     cksum = ntohl(cksum);
     
     /* If it matches, we're golden. */
     if (cksum == checksum + 1) {
       debug("Kerberos V4 challenge successful.");
       return 1;
     }
     else
       packet_disconnect("Kerberos V4 challenge failed!");
     break;
     
   default:
     packet_disconnect("Protocol error on Kerberos V4 response: %d", type);
   }
   return 0;
d743 1
d747 2
a748 1
int send_kerberos_tgt()
d750 33
a782 38
  CREDENTIALS *creds;
  char pname[ANAME_SZ], pinst[INST_SZ], prealm[REALM_SZ];
  int r, type, plen;
  unsigned char buffer[8192];
  struct stat st;

  /* Don't do anything if we don't have any tickets. */
  if (stat(tkt_string(), &st) < 0) return 0;
    
  creds = xmalloc(sizeof(*creds));
  
  if ((r = krb_get_tf_fullname(TKT_FILE, pname, pinst, prealm)) != KSUCCESS) {
    debug("Kerberos V4 tf_fullname failed: %s",krb_err_txt[r]);
    return 0;
  }
  if ((r = krb_get_cred("krbtgt", prealm, prealm, creds)) != GC_OK) {
    debug("Kerberos V4 get_cred failed: %s", krb_err_txt[r]);
    return 0;
  }
  if (time(0) > krb_life_to_time(creds->issue_date, creds->lifetime)) {
    debug("Kerberos V4 ticket expired: %s", TKT_FILE);
    return 0;
  }

  creds_to_radix(creds, buffer);
  xfree(creds);
    
  packet_start(SSH_CMSG_HAVE_KERBEROS_TGT);
  packet_put_string((char *)buffer, strlen(buffer));
  packet_send();
  packet_write_wait();

  type = packet_read(&plen);
  
  if (type == SSH_SMSG_FAILURE)
    debug("Kerberos TGT for realm %s rejected.", prealm);
  else if (type != SSH_SMSG_SUCCESS)
    packet_disconnect("Protocol error on Kerberos TGT response: %d", type);
d784 6
a789 1
  return 1;
d792 2
a793 1
void send_afs_tokens(void)
d795 63
a857 58
  CREDENTIALS creds;
  struct ViceIoctl parms;
  struct ClearToken ct;
  int i, type, len, plen;
  char buf[2048], *p, *server_cell;
  unsigned char buffer[8192];

  /* Move over ktc_GetToken, here's something leaner. */
  for (i = 0; i < 100; i++) { /* just in case */
    parms.in = (char *)&i;
    parms.in_size = sizeof(i);
    parms.out = buf;
    parms.out_size = sizeof(buf);
    if (k_pioctl(0, VIOCGETTOK, &parms, 0) != 0) break;
    p = buf;
    
    /* Get secret token. */
    memcpy(&creds.ticket_st.length, p, sizeof(unsigned int));
    if (creds.ticket_st.length > MAX_KTXT_LEN) break;
    p += sizeof(unsigned int);
    memcpy(creds.ticket_st.dat, p, creds.ticket_st.length);
    p += creds.ticket_st.length;
        
    /* Get clear token. */
    memcpy(&len, p, sizeof(len));
    if (len != sizeof(struct ClearToken)) break;
    p += sizeof(len);
    memcpy(&ct, p, len);
    p += len;
    p += sizeof(len); /* primary flag */
    server_cell = p;

    /* Flesh out our credentials. */
    strlcpy(creds.service, "afs", sizeof creds.service);
    creds.instance[0] = '\0';
    strlcpy(creds.realm, server_cell, REALM_SZ);
    memcpy(creds.session, ct.HandShakeKey, DES_KEY_SZ);
    creds.issue_date = ct.BeginTimestamp;
    creds.lifetime = krb_time_to_life(creds.issue_date, ct.EndTimestamp);
    creds.kvno = ct.AuthHandle;
    snprintf(creds.pname, sizeof(creds.pname), "AFS ID %d", ct.ViceId);
    creds.pinst[0] = '\0';

    /* Encode token, ship it off. */
    if (!creds_to_radix(&creds, buffer)) break;
    packet_start(SSH_CMSG_HAVE_AFS_TOKEN);
    packet_put_string((char *)buffer, strlen(buffer));
    packet_send();
    packet_write_wait();

    /* Roger, Roger. Clearance, Clarence. What's your vector, Victor? */
    type = packet_read(&plen);

    if (type == SSH_SMSG_FAILURE)
      debug("AFS token for cell %s rejected.", server_cell);
    else if (type != SSH_SMSG_SUCCESS)
      packet_disconnect("Protocol error on AFS token response: %d", type);
  }  
d859 1
d862 2
a863 2
/* Waits for the server identification string, and sends our own identification
   string. */
d865 2
a866 1
void ssh_exchange_identification()
d868 43
a910 46
  char buf[256], remote_version[256]; /* must be same size! */
  int remote_major, remote_minor, i;
  int connection_in = packet_get_connection_in();
  int connection_out = packet_get_connection_out();
  extern Options options;

  /* Read other side\'s version identification. */
  for (i = 0; i < sizeof(buf) - 1; i++)
    {
      if (read(connection_in, &buf[i], 1) != 1)
	fatal("ssh_exchange_identification: read: %.100s", strerror(errno));
      if (buf[i] == '\r')
	{
	  buf[i] = '\n';
	  buf[i + 1] = 0;
	  break;
	}
      if (buf[i] == '\n')
	{
	  buf[i + 1] = 0;
	  break;
	}
    }
  buf[sizeof(buf) - 1] = 0;
  
  /* Check that the versions match.  In future this might accept several
     versions and set appropriate flags to handle them. */
  if (sscanf(buf, "SSH-%d.%d-%[^\n]\n", &remote_major, &remote_minor, 
	     remote_version) != 3)
    fatal("Bad remote protocol version identification: '%.100s'", buf);
  debug("Remote protocol version %d.%d, remote software version %.100s",
	remote_major, remote_minor, remote_version);

  /* Check if the remote protocol version is too old. */
  if (remote_major == 1 && remote_minor < 3)
    fatal("Remote machine has too old SSH software version.");

  /* We speak 1.3, too. */
  if (remote_major == 1 && remote_minor == 3) {
    enable_compat13();
    if (options.forward_agent && strcmp(remote_version, SSH_VERSION) != 0) {
      log("Agent forwarding disabled, remote version '%s' is not compatible.",
	    remote_version);
      options.forward_agent = 0;
    }
  }
d912 6
a917 5
  /* Removed for now, to permit compatibility with latter versions.  The server
     will reject our version and disconnect if it doesn't support it. */
  if (remote_major != PROTOCOL_MAJOR)
    fatal("Protocol major versions differ: %d vs. %d",
	  PROTOCOL_MAJOR, remote_major);
d920 5
a924 5
  /* Send our own protocol version identification. */
  snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s\n", 
	  PROTOCOL_MAJOR, PROTOCOL_MINOR, SSH_VERSION);
  if (write(connection_out, buf, strlen(buf)) != strlen(buf))
    fatal("write: %.100s", strerror(errno));
d929 2
a930 1
int read_yes_or_no(const char *prompt, int defval)
d932 37
a968 39
  char buf[1024];
  FILE *f;
  int retval = -1;
      
  if (isatty(0))
    f = stdin;
  else
    f = fopen("/dev/tty", "rw");

  if (f == NULL)
    return 0;

  fflush(stdout);

  while (1)
    {
      fprintf(stderr, "%s", prompt);
      if (fgets(buf, sizeof(buf), f) == NULL)
	{
	  /* Print a newline (the prompt probably didn\'t have one). */
	  fprintf(stderr, "\n");
	  strlcpy(buf, "no", sizeof buf);
	}
      /* Remove newline from response. */
      if (strchr(buf, '\n'))
	*strchr(buf, '\n') = 0;

      if (buf[0] == 0)
	retval = defval;
      if (strcmp(buf, "yes") == 0)
	retval = 1;
      if (strcmp(buf, "no") == 0)
	retval = 0;

      if (retval != -1)
	{
	  if (f != stdin)
	    fclose(f);
	  return retval;
a969 1
    }
d974 1
a974 1
   to the server must already have been established before this is called. 
d977 1
a977 1
   If login fails, this function prints an error and never returns. 
d980 6
a985 5
void ssh_login(int host_key_valid, 
	       RSA *own_host_key,
	       const char *orighost, 
	       struct sockaddr_in *hostaddr,
	       uid_t original_real_uid)
d987 371
a1357 549
  extern Options options;
  int i, type;
  char *password;
  struct passwd *pw;
  BIGNUM *key;
  RSA *host_key, *file_key;
  RSA *public_key;
  int bits, rbits;
  unsigned char session_key[SSH_SESSION_KEY_LENGTH];
  const char *server_user, *local_user;
  char *cp, *host, *ip = NULL;
  unsigned char check_bytes[8];
  unsigned int supported_ciphers, supported_authentications, protocol_flags;
  HostStatus host_status;
  HostStatus ip_status;
  int host_ip_differ = 0;
  int local = (ntohl(hostaddr->sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
  int payload_len, clen, sum_len = 0;
  u_int32_t rand = 0;

  if (options.check_host_ip)
    ip = xstrdup(inet_ntoa(hostaddr->sin_addr));

  /* Convert the user-supplied hostname into all lowercase. */
  host = xstrdup(orighost);
  for (cp = host; *cp; cp++)
    if (isupper(*cp))
      *cp = tolower(*cp);

  /* Exchange protocol version identification strings with the server. */
  ssh_exchange_identification();

  /* Put the connection into non-blocking mode. */
  packet_set_nonblocking();

  /* Get local user name.  Use it as server user if no user name
     was given. */
  pw = getpwuid(original_real_uid);
  if (!pw)
    fatal("User id %d not found from user database.", original_real_uid);
  local_user = xstrdup(pw->pw_name);
  server_user = options.user ? options.user : local_user;

  debug("Waiting for server public key.");

  /* Wait for a public key packet from the server. */
  packet_read_expect(&payload_len, SSH_SMSG_PUBLIC_KEY);

  /* Get check bytes from the packet. */
  for (i = 0; i < 8; i++)
    check_bytes[i] = packet_get_char();

  /* Get the public key. */
  public_key = RSA_new();
  bits = packet_get_int();	/* bits */
  public_key->e = BN_new();
  packet_get_bignum(public_key->e, &clen);
  sum_len += clen;
  public_key->n = BN_new();
  packet_get_bignum(public_key->n, &clen);
  sum_len += clen;

  rbits = BN_num_bits(public_key->n);
  if (bits != rbits) {
    log("Warning: Server lies about size of server public key: "
        "actual size is %d bits vs. announced %d.", rbits, bits);
    log("Warning: This may be due to an old implementation of ssh.");
  }

  /* Get the host key. */
  host_key = RSA_new();
  bits = packet_get_int();	/* bits */
  host_key->e = BN_new();
  packet_get_bignum(host_key->e, &clen);
  sum_len += clen;
  host_key->n = BN_new();
  packet_get_bignum(host_key->n, &clen);
  sum_len += clen;

  rbits = BN_num_bits(host_key->n);
  if (bits != rbits) {
    log("Warning: Server lies about size of server host key: "
        "actual size is %d bits vs. announced %d.", rbits, bits);
    log("Warning: This may be due to an old implementation of ssh.");
  }

  /* Store the host key from the known host file in here
   * so that we can compare it with the key for the IP
   * address. */
  file_key = RSA_new();
  file_key->n = BN_new();
  file_key->e = BN_new();

  /* Get protocol flags. */
  protocol_flags = packet_get_int();
  packet_set_protocol_flags(protocol_flags);

  /* Get supported cipher types. */
  supported_ciphers = packet_get_int();

  /* Get supported authentication types. */
  supported_authentications = packet_get_int();

  debug("Received server public key (%d bits) and host key (%d bits).", 
	BN_num_bits(public_key->n), BN_num_bits(host_key->n));

  packet_integrity_check(payload_len,
			 8 + 4 + sum_len + 0 + 4 + 0 + 0 + 4 + 4 + 4,
			 SSH_SMSG_PUBLIC_KEY);

  /* Compute the session id. */
  compute_session_id(session_id, check_bytes, host_key->n, public_key->n);

  /* Check if the host key is present in the user\'s list of known hosts
     or in the systemwide list. */
  host_status = check_host_in_hostfile(options.user_hostfile, host,
				       host_key->e, host_key->n,
				       file_key->e, file_key->n);
  if (host_status == HOST_NEW)
    host_status = check_host_in_hostfile(options.system_hostfile, host, 
					 host_key->e, host_key->n,
					 file_key->e, file_key->n);
  /* Force accepting of the host key for localhost and 127.0.0.1.
     The problem is that if the home directory is NFS-mounted to multiple
     machines, localhost will refer to a different machine in each of them,
     and the user will get bogus HOST_CHANGED warnings.  This essentially
     disables host authentication for localhost; however, this is probably
     not a real problem. */
  if (local) {
    debug("Forcing accepting of host key for localhost.");
    host_status = HOST_OK;
  }

  /* Also perform check for the ip address, skip the check if we are
     localhost or the hostname was an ip address to begin with */
  if (options.check_host_ip && !local && strcmp(host, ip)) {
    RSA *ip_key = RSA_new();
    ip_key->n = BN_new();
    ip_key->e = BN_new();
    ip_status = check_host_in_hostfile(options.user_hostfile, ip,
				       host_key->e, host_key->n,
				       ip_key->e, ip_key->n);

    if (ip_status == HOST_NEW)
      ip_status = check_host_in_hostfile(options.system_hostfile, ip,
					 host_key->e, host_key->n,
					 ip_key->e, ip_key->n);
    if (host_status == HOST_CHANGED &&
	(ip_status != HOST_CHANGED || 
	 (BN_cmp(ip_key->e, file_key->e) || BN_cmp(ip_key->n, file_key->n))))
      host_ip_differ = 1;

    RSA_free(ip_key);
  } else
    ip_status = host_status;

  RSA_free(file_key);

  switch (host_status) {
  case HOST_OK:
    /* The host is known and the key matches. */
    debug("Host '%.200s' is known and matches the host key.", host);
    if (options.check_host_ip) {
      if (ip_status == HOST_NEW) {
	if (!add_host_to_hostfile(options.user_hostfile, ip,
				  host_key->e, host_key->n))
 	  log("Failed to add the host key for IP address '%.30s' to the list of known hosts (%.30s).", 
 	      ip, options.user_hostfile);
	else
 	  log("Warning: Permanently added host key for IP address '%.30s' to the list of known hosts.",
               ip);
      } else if (ip_status != HOST_OK)
 	log("Warning: the host key for '%.200s' differs from the key for the IP address '%.30s'",
 	    host, ip);
    }
    
    break;
  case HOST_NEW:
    {
      char hostline[1000], *hostp = hostline;
      /* The host is new. */
      if (options.strict_host_key_checking == 1) {
	/* User has requested strict host key checking.  We will not
	   add the host key automatically.  The only alternative left
	   is to abort. */
	fatal("No host key is known for %.200s and you have requested strict checking.", host);
      } else if (options.strict_host_key_checking == 2) { /* The default */
	char prompt[1024];
        char *fp = fingerprint(host_key->e, host_key->n);
	snprintf(prompt, sizeof(prompt),
		 "The authenticity of host '%.200s' can't be established.\n"
                 "Key fingerprint is %d %s.\n"
 		 "Are you sure you want to continue connecting (yes/no)? ",
		 host, BN_num_bits(host_key->n), fp);
	if (!read_yes_or_no(prompt, -1))
	  fatal("Aborted by user!\n");
      }
      
      if (options.check_host_ip && ip_status == HOST_NEW && strcmp(host, ip))
	snprintf(hostline, sizeof(hostline), "%s,%s", host, ip);
      else
	hostp = host;
      
      /* If not in strict mode, add the key automatically to the local
	 known_hosts file. */
      if (!add_host_to_hostfile(options.user_hostfile, hostp,
				host_key->e, host_key->n))
	log("Failed to add the host to the list of known hosts (%.500s).", 
	    options.user_hostfile);
      else
	log("Warning: Permanently added '%.200s' to the list of known hosts.",
	    hostp);
      break;
    }
  case HOST_CHANGED:
    if (options.check_host_ip) {
      if (host_ip_differ) {
        char *msg;
	if (ip_status == HOST_NEW)
	  msg = "is unknown";
	else if (ip_status == HOST_OK)
	  msg = "is unchanged";
	else 
	  msg = "has a different value";
	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("@@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @@");
	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("The host key for %s has changed,", host);
	error("and the key for the according IP address %s", ip);
	error("%s. This could either mean that", msg);
	error("DNS SPOOFING is happening or the IP address for the host");
	error("and its host key have changed at the same time");
      }
    }
    
    /* The host key has changed. */
    error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
    error("@@       WARNING: HOST IDENTIFICATION HAS CHANGED!         @@");
    error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
    error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
    error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
    error("It is also possible that the host key has just been changed.");
    error("Please contact your system administrator.");
    error("Add correct host key in %.100s to get rid of this message.", 
	  options.user_hostfile);
    
    /* If strict host key checking is in use, the user will have to edit
       the key manually and we can only abort. */
    if (options.strict_host_key_checking)
      fatal("Host key for %.200s has changed and you have requested strict checking.", host);
    
    /* If strict host key checking has not been requested, allow the
       connection but without password authentication or
       agent forwarding. */
    if (options.password_authentication) {
      error("Password authentication is disabled to avoid trojan horses.");
      options.password_authentication = 0;
    }
    if (options.forward_agent) {
      error("Agent forwarding is disabled to avoid trojan horses.");
      options.forward_agent = 0;
    }
    /* XXX Should permit the user to change to use the new id.  This could
       be done by converting the host key to an identifying sentence, tell
       that the host identifies itself by that sentence, and ask the user
       if he/she whishes to accept the authentication. */
    break;
  }

  if (options.check_host_ip)
    xfree(ip);
  
  /* Generate a session key. */
  arc4random_stir();
  
  /* Generate an encryption key for the session.   The key is a 256 bit
     random number, interpreted as a 32-byte key, with the least significant
     8 bits being the first byte of the key. */
  for (i = 0; i < 32; i++) {
    if (i % 4 == 0)
      rand = arc4random();
    session_key[i] = rand & 0xff;
    rand >>= 8;
  }

  /* According to the protocol spec, the first byte of the session key is
     the highest byte of the integer.  The session key is xored with the
     first 16 bytes of the session id. */
  key = BN_new();
  BN_set_word(key, 0);
  for (i = 0; i < SSH_SESSION_KEY_LENGTH; i++)
    {
      BN_lshift(key, key, 8);
      if (i < 16)
	BN_add_word(key, session_key[i] ^ session_id[i]);
      else
	BN_add_word(key, session_key[i]);
    }

  /* Encrypt the integer using the public key and host key of the server
     (key with smaller modulus first). */
  if (BN_cmp(public_key->n, host_key->n) < 0)
    {
      /* Public key has smaller modulus. */
      if (BN_num_bits(host_key->n) < 
	  BN_num_bits(public_key->n) + SSH_KEY_BITS_RESERVED) {
        fatal("respond_to_rsa_challenge: host_key %d < public_key %d + "
	      "SSH_KEY_BITS_RESERVED %d",
	      BN_num_bits(host_key->n),
              BN_num_bits(public_key->n),
	      SSH_KEY_BITS_RESERVED);
      }

      rsa_public_encrypt(key, key, public_key);
      rsa_public_encrypt(key, key, host_key);
    }
  else
    {
      /* Host key has smaller modulus (or they are equal). */
      if (BN_num_bits(public_key->n) < 
	  BN_num_bits(host_key->n) + SSH_KEY_BITS_RESERVED) {
        fatal("respond_to_rsa_challenge: public_key %d < host_key %d + "
	      "SSH_KEY_BITS_RESERVED %d",
	      BN_num_bits(public_key->n),
              BN_num_bits(host_key->n),
	      SSH_KEY_BITS_RESERVED);
      }

      rsa_public_encrypt(key, key, host_key);
      rsa_public_encrypt(key, key, public_key);
    }

  if (options.cipher == SSH_CIPHER_NOT_SET) {
    if (cipher_mask() & supported_ciphers & (1 << ssh_cipher_default))
      options.cipher = ssh_cipher_default;
    else {
      debug("Cipher %s not supported, using %.100s instead.",
	    cipher_name(ssh_cipher_default),
	    cipher_name(SSH_FALLBACK_CIPHER));
      options.cipher = SSH_FALLBACK_CIPHER;
    }
  }

  /* Check that the selected cipher is supported. */
  if (!(supported_ciphers & (1 << options.cipher)))
    fatal("Selected cipher type %.100s not supported by server.", 
	  cipher_name(options.cipher));

  debug("Encryption type: %.100s", cipher_name(options.cipher));

  /* Send the encrypted session key to the server. */
  packet_start(SSH_CMSG_SESSION_KEY);
  packet_put_char(options.cipher);

  /* Send the check bytes back to the server. */
  for (i = 0; i < 8; i++)
    packet_put_char(check_bytes[i]);

  /* Send the encrypted encryption key. */
  packet_put_bignum(key);

  /* Send protocol flags. */
  packet_put_int(SSH_PROTOFLAG_SCREEN_NUMBER | SSH_PROTOFLAG_HOST_IN_FWD_OPEN);

  /* Send the packet now. */
  packet_send();
  packet_write_wait();

  /* Destroy the session key integer and the public keys since we no longer
     need them. */
  BN_clear_free(key);
  RSA_free(public_key);
  RSA_free(host_key);

  debug("Sent encrypted session key.");
  
  /* Set the encryption key. */
  packet_set_encryption_key(session_key, SSH_SESSION_KEY_LENGTH, options.cipher);

  /* We will no longer need the session key here.  Destroy any extra copies. */
  memset(session_key, 0, sizeof(session_key));

  /* Expect a success message from the server.  Note that this message will
     be received in encrypted form. */
  packet_read_expect(&payload_len, SSH_SMSG_SUCCESS);

  debug("Received encrypted confirmation.");

  /* Send the name of the user to log in as on the server. */
  packet_start(SSH_CMSG_USER);
  packet_put_string(server_user, strlen(server_user));
  packet_send();
  packet_write_wait();

  /* The server should respond with success if no authentication is needed
     (the user has no password).  Otherwise the server responds with 
     failure. */
  type = packet_read(&payload_len);
  if (type == SSH_SMSG_SUCCESS)
    return;  /* Connection was accepted without authentication. */
  if (type != SSH_SMSG_FAILURE)
    packet_disconnect("Protocol error: got %d in response to SSH_CMSG_USER",
		      type);
  
#ifdef AFS
  /* Try Kerberos tgt passing if the server supports it. */
  if ((supported_authentications & (1 << SSH_PASS_KERBEROS_TGT)) &&
      options.kerberos_tgt_passing)
    {
      if (options.cipher == SSH_CIPHER_NONE)
	log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
      (void)send_kerberos_tgt();
    }

  /* Try AFS token passing if the server supports it. */
  if ((supported_authentications & (1 << SSH_PASS_AFS_TOKEN)) &&
      options.afs_token_passing && k_hasafs())  {
    if (options.cipher == SSH_CIPHER_NONE)
      log("WARNING: Encryption is disabled! Token will be transmitted in the clear!");
    send_afs_tokens();
  }
#endif /* AFS */
  
#ifdef KRB4
  if ((supported_authentications & (1 << SSH_AUTH_KERBEROS)) &&
      options.kerberos_authentication)
    {
      debug("Trying Kerberos authentication.");
      if (try_kerberos_authentication()) {
        /* The server should respond with success or failure. */
        type = packet_read(&payload_len);
        if (type == SSH_SMSG_SUCCESS)
          return; /* Successful connection. */
        if (type != SSH_SMSG_FAILURE)
          packet_disconnect("Protocol error: got %d in response to Kerberos auth", type);
      }
    }
#endif /* KRB4 */
  
  /* Use rhosts authentication if running in privileged socket and we do not
     wish to remain anonymous. */
  if ((supported_authentications & (1 << SSH_AUTH_RHOSTS)) && 
      options.rhosts_authentication)
    {
      debug("Trying rhosts authentication.");
      packet_start(SSH_CMSG_AUTH_RHOSTS);
      packet_put_string(local_user, strlen(local_user));
      packet_send();
      packet_write_wait();

      /* The server should respond with success or failure. */
      type = packet_read(&payload_len);
      if (type == SSH_SMSG_SUCCESS)
	return; /* Successful connection. */
      if (type != SSH_SMSG_FAILURE)
	packet_disconnect("Protocol error: got %d in response to rhosts auth",
			  type);
    }

  /* Try .rhosts or /etc/hosts.equiv authentication with RSA host 
     authentication. */
  if ((supported_authentications & (1 << SSH_AUTH_RHOSTS_RSA)) &&
      options.rhosts_rsa_authentication && host_key_valid)
    {
      if (try_rhosts_rsa_authentication(local_user, own_host_key))
	return; /* Successful authentication. */
    }

  /* Try RSA authentication if the server supports it. */
  if ((supported_authentications & (1 << SSH_AUTH_RSA)) &&
      options.rsa_authentication)
    {
      /* Try RSA authentication using the authentication agent.  The agent
         is tried first because no passphrase is needed for it, whereas
	 identity files may require passphrases. */
      if (try_agent_authentication())
	return; /* Successful connection. */

      /* Try RSA authentication for each identity. */
      for (i = 0; i < options.num_identity_files; i++)
	if (try_rsa_authentication(pw, options.identity_files[i]))
	  return; /* Successful connection. */
    }

  /* Try skey authentication if the server supports it. */
  if ((supported_authentications & (1 << SSH_AUTH_TIS)) &&
      options.skey_authentication && !options.batch_mode)
    {
      debug("Doing skey authentication.");

      /* request a challenge */
      packet_start(SSH_CMSG_AUTH_TIS);
      packet_send();
      packet_write_wait();

      type = packet_read(&payload_len);
      if (type != SSH_SMSG_FAILURE && 
	  type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
	packet_disconnect("Protocol error: got %d in response "
			  "to skey auth", type);
      }
      if (type != SSH_SMSG_AUTH_TIS_CHALLENGE) {
	debug("No challenge for skey authentication.");
      } else {
	char *challenge, *response;
	challenge = packet_get_string(&payload_len);                            
	if (options.cipher == SSH_CIPHER_NONE)
	  log("WARNING: Encryption is disabled! "
	      "Reponse will be transmitted in clear text.");
	fprintf(stderr, "%s\n", challenge);
	fflush(stderr);
	for (i = 0; i < options.number_of_password_prompts; i++) {
	  if (i != 0)
	    error("Permission denied, please try again.");
	  response = read_passphrase("Response: ", 0);
	  packet_start(SSH_CMSG_AUTH_TIS_RESPONSE);
	  packet_put_string(response, strlen(response));
	  memset(response, 0, strlen(response));
	  xfree(response);
	  packet_send();
	  packet_write_wait();
	  type = packet_read(&payload_len);
	  if (type == SSH_SMSG_SUCCESS)
	    return;
	  if (type != SSH_SMSG_FAILURE)
	    packet_disconnect("Protocol error: got %d in response "
			      "to skey auth", type);
	}
      }
    }
  
  /* Try password authentication if the server supports it. */
  if ((supported_authentications & (1 << SSH_AUTH_PASSWORD)) &&
      options.password_authentication && !options.batch_mode)
    {
      char prompt[80];
      snprintf(prompt, sizeof(prompt), "%.30s@@%.30s's password: ",
	server_user, host);
      debug("Doing password authentication.");
      if (options.cipher == SSH_CIPHER_NONE)
	log("WARNING: Encryption is disabled! Password will be transmitted in clear text.");
      for (i = 0; i < options.number_of_password_prompts; i++) {
        if (i != 0)
	  error("Permission denied, please try again.");
	password = read_passphrase(prompt, 0);
	packet_start(SSH_CMSG_AUTH_PASSWORD);
	packet_put_string(password, strlen(password));
	memset(password, 0, strlen(password));
	xfree(password);
d1360 4
a1363 1
	
d1365 2
d1368 1
a1368 1
	  return; /* Successful connection. */
d1370 150
a1519 7
	  packet_disconnect("Protocol error: got %d in response to passwd auth", type);
      }
    }

  /* All authentication methods have failed.  Exit with an error message. */
  fatal("Permission denied.");
  /*NOTREACHED*/
@


1.36
log
@SSH_CMSG_MAX_PACKET_SIZE, some clients use this, some need this, niels@@
[hope this time my ISP stays alive during commit]
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.35 1999/11/18 14:00:49 markus Exp $");
d1497 47
@


1.35
log
@more %d vs. %s in fmt-strings
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.34 1999/11/17 09:51:57 markus Exp $");
d903 1
a903 1
	fatal("read: %.100s", strerror(errno));
@


1.34
log
@include fingerprint.h
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.33 1999/11/16 22:49:28 markus Exp $");
d1351 1
a1351 1
      debug("Cipher %d not supported, using %.100s instead.",
@


1.33
log
@rsa key fingerprints, idea from Bjoern Groenvall <bg@@sics.se>
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.32 1999/11/16 20:44:42 markus Exp $");
d31 1
@


1.32
log
@prettyprint dreaded keysize warnings
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.31 1999/11/15 23:58:54 markus Exp $");
d1202 1
d1205 3
a1207 2
		 "Are you sure you want to continue connecting (yes/no)? ",
		 host);
@


1.31
log
@more detailed messages about adding and checking hostkeys
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.30 1999/11/15 21:38:54 markus Exp $");
d1078 3
a1080 3
    log("Warning: Server lies about size of server public key,");
    log("Warning: this may be due to an old implementation of ssh.");
    log("Warning: (actual size %d bits, announced size %d bits)", rbits, bits);
d1095 3
a1097 3
    log("Warning: Server lies about size of server host key,");
    log("Warning: this may be due to an old implementation of ssh.");
    log("Warning: (actual size %d bits, announced size %d bits)", rbits, bits);
@


1.30
log
@remove support for cipher RC4
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.29 1999/11/15 20:53:25 markus Exp $");
d1180 2
a1181 2
	  log("Failed to add the host ip to the list of known hosts (%.30s).", 
	      options.user_hostfile);
d1183 2
a1184 1
	  log("Warning: Permanently added host ip '%.30s' to the list of known hosts.", ip);
d1186 2
a1187 1
	log("Warning: the host key differ from the key of the ip address '%.30s' differs", ip);
d1229 7
d1240 3
a1242 3
	error("but the key for the according IP address %s has", ip);
	error("a different status.  This could either mean that DNS");
	error("SPOOFING is happening or the IP address for the host");
@


1.29
log
@the keysize of rsa-parameter 'n' is passed implizit,
a few more checks and warnings about 'pretended' keysizes.
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.28 1999/11/15 00:42:01 markus Exp $");
d1380 1
a1380 2
  packet_set_encryption_key(session_key, SSH_SESSION_KEY_LENGTH, 
			    options.cipher, 1);
@


1.28
log
@disconnect if getpeername() fails
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.27 1999/11/11 23:36:53 markus Exp $");
d336 1
a336 1
  int status, type, bits;
d353 1
a353 1
  for (status = ssh_get_first_identity(auth, &bits, e, n, &comment);
d355 1
a355 1
       status = ssh_get_next_identity(auth, &bits, e, n, &comment))
d392 1
a392 1
      if (!ssh_decrypt_challenge(auth, bits, e, n, challenge, 
d1125 1
a1125 3
  compute_session_id(session_id, check_bytes, 
		     BN_num_bits(host_key->n), host_key->n, 
		     BN_num_bits(public_key->n), public_key->n);
d1129 1
a1129 2
  host_status = check_host_in_hostfile(options.user_hostfile, 
				       host, BN_num_bits(host_key->n), 
a1133 1
					 BN_num_bits(host_key->n),
a1153 1
				       BN_num_bits(host_key->n),
a1158 1
					 BN_num_bits(host_key->n),
a1178 1
				  BN_num_bits(host_key->n), 
a1215 1
				BN_num_bits(host_key->n), 
@


1.27
log
@make all access to options via 'extern Options options'
and 'extern ServerOptions options' respectively;
options are no longer passed as arguments:
 * make options handling more consistent
 * remove #include "readconf.h" from ssh.h
 * readconf.h is only included if necessary
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.26 1999/11/07 22:38:39 markus Exp $");
d727 1
a727 1
		   (struct sockaddr *)&foreign, &r) < 0)
d729 2
@


1.26
log
@warn if announced size of modulus 'n' != real size
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.25 1999/11/02 19:42:36 markus Exp $");
d30 1
d482 1
a482 2
try_rsa_authentication(struct passwd *pw, const char *authfile,
		       int may_ask_passphrase)
d484 1
d546 1
a546 1
      if (may_ask_passphrase)
d1010 1
a1010 1
	       Options *options, uid_t original_real_uid)
d1012 1
d1032 1
a1032 1
  if (options->check_host_ip)
d1053 1
a1053 1
  server_user = options->user ? options->user : local_user;
d1129 1
a1129 1
  host_status = check_host_in_hostfile(options->user_hostfile, 
d1134 1
a1134 1
    host_status = check_host_in_hostfile(options->system_hostfile, host, 
d1151 1
a1151 1
  if (options->check_host_ip && !local && strcmp(host, ip)) {
d1155 1
a1155 1
    ip_status = check_host_in_hostfile(options->user_hostfile, ip,
d1161 1
a1161 1
      ip_status = check_host_in_hostfile(options->system_hostfile, ip,
d1180 1
a1180 1
    if (options->check_host_ip) {
d1182 1
a1182 1
	if (!add_host_to_hostfile(options->user_hostfile, ip,
d1186 1
a1186 1
	      options->user_hostfile);
d1198 1
a1198 1
      if (options->strict_host_key_checking == 1) {
d1203 1
a1203 1
      } else if (options->strict_host_key_checking == 2) { /* The default */
d1213 1
a1213 1
      if (options->check_host_ip && ip_status == HOST_NEW && strcmp(host, ip))
d1220 1
a1220 1
      if (!add_host_to_hostfile(options->user_hostfile, hostp,
d1224 1
a1224 1
	    options->user_hostfile);
d1231 1
a1231 1
    if (options->check_host_ip) {
d1253 1
a1253 1
	  options->user_hostfile);
d1257 1
a1257 1
    if (options->strict_host_key_checking)
d1263 1
a1263 1
    if (options->password_authentication) {
d1265 1
a1265 1
      options->password_authentication = 0;
d1267 1
a1267 1
    if (options->forward_agent) {
d1269 1
a1269 1
      options->forward_agent = 0;
d1278 1
a1278 1
  if (options->check_host_ip)
d1341 1
a1341 1
  if (options->cipher == SSH_CIPHER_NOT_SET) {
d1343 1
a1343 1
      options->cipher = ssh_cipher_default;
d1348 1
a1348 1
      options->cipher = SSH_FALLBACK_CIPHER;
d1353 1
a1353 1
  if (!(supported_ciphers & (1 << options->cipher)))
d1355 1
a1355 1
	  cipher_name(options->cipher));
d1357 1
a1357 1
  debug("Encryption type: %.100s", cipher_name(options->cipher));
d1361 1
a1361 1
  packet_put_char(options->cipher);
d1387 1
a1387 1
			    options->cipher, 1);
d1417 1
a1417 1
      options->kerberos_tgt_passing)
d1419 1
a1419 1
      if (options->cipher == SSH_CIPHER_NONE)
d1426 2
a1427 2
      options->afs_token_passing && k_hasafs())  {
    if (options->cipher == SSH_CIPHER_NONE)
d1435 1
a1435 1
      options->kerberos_authentication)
d1452 1
a1452 1
      options->rhosts_authentication)
d1472 1
a1472 1
      options->rhosts_rsa_authentication && host_key_valid)
d1480 1
a1480 1
      options->rsa_authentication)
d1489 2
a1490 3
      for (i = 0; i < options->num_identity_files; i++)
	if (try_rsa_authentication(pw, options->identity_files[i],
				   !options->batch_mode))
d1496 1
a1496 1
      options->password_authentication && !options->batch_mode)
d1502 1
a1502 1
      if (options->cipher == SSH_CIPHER_NONE)
d1504 1
a1504 1
      for (i = 0; i < options->number_of_password_prompts; i++) {
@


1.25
log
@replace assert() with error, fatal or packet_disconnect
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.24 1999/10/27 16:37:46 deraadt Exp $");
d1017 1
d1064 1
a1064 1
  packet_get_int();	/* bits */
d1072 7
d1081 1
a1081 1
  packet_get_int();	/* bits */
d1088 7
@


1.24
log
@use libssl md5 routines
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.23 1999/10/25 20:34:30 markus Exp $");
d452 4
a455 1
  assert(len <= sizeof(buf) && len);
d1296 8
a1303 2
      assert(BN_num_bits(host_key->n) >= 
	     BN_num_bits(public_key->n) + SSH_KEY_BITS_RESERVED);
d1311 8
a1318 2
      assert(BN_num_bits(public_key->n) >=
	     BN_num_bits(host_key->n) + SSH_KEY_BITS_RESERVED);
@


1.23
log
@bugfix: print remote version, from chris@@dqc.org
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.22 1999/10/16 23:11:29 markus Exp $");
d31 1
a31 1
#include <md5.h>
d455 4
a458 4
  MD5Init(&md);
  MD5Update(&md, buf, 32);
  MD5Update(&md, session_id, 16);
  MD5Final(response, &md);
@


1.22
log
@refuse to talk to protocol < 1.3
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.21 1999/10/16 20:47:14 markus Exp $");
d928 1
a928 1
	    SSH_VERSION);
@


1.21
log
@support for SSH protocol 1.5 which is poorly documented, the RFC.troff lies.
interops (x11,agent,etc) with 1.2.27 and protocol 1.3
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.20 1999/10/16 19:23:35 provos Exp $");
d919 3
d923 1
a938 4

  /* Check if the remote protocol version is too old. */
  if (remote_major == 1 && remote_minor == 0)
    fatal("Remote machine has too old SSH software version.");
@


1.20
log
@-Wall cleanup
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.19 1999/10/15 20:51:01 markus Exp $");
d29 1
d919 5
a923 3
  if (options.forward_agent && strcmp(remote_version, SSH_VERSION) != 0)
    {
      log("Agent forwarding disabled, remote version is not '%s'.",
d927 1
@


1.19
log
@turn of agent-fwding if hostkey changed, ok: theo.
and don't forget: "1.5 won't die!"
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.18 1999/10/14 20:03:44 markus Exp $");
d1017 1
d1141 4
a1144 3
    if (ip_status == HOST_CHANGED && host_status == HOST_CHANGED &&
	(BN_cmp(ip_key->e, file_key->e) || BN_cmp(ip_key->n, file_key->n)))
      ip_status = HOST_DIFFER;
d1208 1
a1208 1
      if (ip_status != HOST_CHANGED) {
@


1.18
log
@say "Permission denied" if passwd is wrong. from wvdputte, ok niels
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.17 1999/10/14 18:17:42 markus Exp $");
d1208 1
a1208 1
	error("@@       WARNING: POSSIBLE DNS SPOOFNG DETECTED!           @@");
d1235 10
a1244 3
       connection but without password authentication. */
    error("Password authentication is disabled to avoid trojan horses.");
    options->password_authentication = 0;
@


1.17
log
@fix old connect() race security-bug for ssh-agent and agent-forwarding
by removing the connect() junk, with the following restrictions:
1) change the version to "OpenSSH-1.1":
   agent-forwarding will work only between OpenSSH-1.1 client and
   OpenSSH-1.1 server
2) renamed the environment variable of OpenSSH-1.1 to
   "SSH_AUTH_SOCKET", since useing OpenSSH-1.0 ssh-add against the new
   ssh-agent does not work
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.16 1999/10/06 20:07:42 dugsong Exp $");
d1461 2
@


1.16
log
@implement client NumberOfPasswordPrompts option
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.15 1999/10/06 04:22:20 provos Exp $");
d889 1
d917 7
@


1.15
log
@force HOST_OK not only for localhost but for localnet, suggested tholo@@
some cleanup.
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.14 1999/10/04 19:46:30 provos Exp $");
d1452 15
a1466 14
      password = read_passphrase(prompt, 0);
      packet_start(SSH_CMSG_AUTH_PASSWORD);
      packet_put_string(password, strlen(password));
      memset(password, 0, strlen(password));
      xfree(password);
      packet_send();
      packet_write_wait();
  
      type = packet_read(&payload_len);
      if (type == SSH_SMSG_SUCCESS)
	return; /* Successful connection. */
      if (type != SSH_SMSG_FAILURE)
	packet_disconnect("Protocol error: got %d in response to passwd auth",
			  type);
@


1.14
log
@fix handling of the localhost case.  used to be a check against 'localhost',
but we use canonical names, so check against ip address.
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.13 1999/10/03 22:01:39 provos Exp $");
d1004 1
a1004 1
  char *cp, *host;
d1009 1
d1013 3
d1111 4
a1114 5
  if (strcmp(inet_ntoa(hostaddr->sin_addr), "127.0.0.1") == 0)
    {
      debug("Forcing accepting of host key for localhost.");
      host_status = HOST_OK;
    }
d1118 1
a1118 3
  if (options->check_host_ip &&
      strcmp(inet_ntoa(hostaddr->sin_addr), "127.0.0.1") && 
      strcmp(host, inet_ntoa(hostaddr->sin_addr))) {
d1122 1
a1122 2
    ip_status = check_host_in_hostfile(options->user_hostfile,
				       inet_ntoa(hostaddr->sin_addr), 
d1128 1
a1128 2
      ip_status = check_host_in_hostfile(options->system_hostfile,
					 inet_ntoa(hostaddr->sin_addr), 
d1148 1
a1148 2
	if (!add_host_to_hostfile(options->user_hostfile,
				  inet_ntoa(hostaddr->sin_addr),
d1154 1
a1154 1
	  log("Warning: Permanently added host ip '%.30s' to the list of known hosts.", inet_ntoa(hostaddr->sin_addr));
d1156 1
a1156 1
	log("Warning: the host key differ from the key of the ip address '%.30s' differs", inet_ntoa(hostaddr->sin_addr));
d1179 2
a1180 4
      if (options->check_host_ip && ip_status == HOST_NEW &&
	  strcmp(host, inet_ntoa(hostaddr->sin_addr)))
	snprintf(hostline, sizeof(hostline), "%s,%s",
		 host, inet_ntoa(hostaddr->sin_addr));
d1203 1
a1203 2
	error("but the key for the according IP address %s has",
	      inet_ntoa(hostaddr->sin_addr));
d1236 3
@


1.13
log
@fix last commit.
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.12 1999/10/03 21:50:04 provos Exp $");
d1107 1
a1107 2
  if (strcmp(host, "localhost") == 0 ||
      strcmp(host, "127.0.0.1") == 0)
d1113 5
a1117 2
  /* Also perform check for the ip address */
  if (options->check_host_ip && strcmp(host, inet_ntoa(hostaddr->sin_addr))) {
@


1.12
log
@add code to detect DNS spoofing:

the main idea is to not only store the host key for the hostname but
also for the according IP address.  When we check the host key in the
known_hosts file, we also check the key against the according IP address.
When the server key changes, host_status = HOST_CHANGED.  If
check_host_in_hostfile() returns differing status for the IP address
that means that either DNS was spoofed or that the IP address
for the host and the host key changed at the same time.
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.11 1999/10/03 19:22:39 deraadt Exp $");
d1061 6
a1066 8
  if (options->check_host_ip && strcmp(host, inet_ntoa(hostaddr->sin_addr))) {
    /* Store the host key from the known host file in here
     * so that we can compare it with the key for the IP
     * address. */
    file_key = RSA_new();
    file_key->n = BN_new();
    file_key->e = BN_new();
  }
a1135 1
    RSA_free(file_key);
d1138 2
@


1.11
log
@use SHUT_* symbols
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.10 1999/09/30 17:08:52 deraadt Exp $");
d178 2
a179 1
int ssh_connect(const char *host, int port, int connection_attempts,
a186 1
  struct sockaddr_in hostaddr;
d220 5
a224 5
      memset(&hostaddr, 0, sizeof(hostaddr));
      hostaddr.sin_family = AF_INET;
      hostaddr.sin_port = htons(port);
      hostaddr.sin_addr.s_addr = inet_addr(host);
      if ((hostaddr.sin_addr.s_addr & 0xffffffff) != 0xffffffff)
d228 1
a228 1
		inet_ntoa(hostaddr.sin_addr), port);
d239 1
a239 1
	  if (connect(sock, (struct sockaddr *)&hostaddr, sizeof(hostaddr))
d269 3
a271 3
	      hostaddr.sin_family = hp->h_addrtype;
	      memcpy(&hostaddr.sin_addr, hp->h_addr_list[i],
		     sizeof(hostaddr.sin_addr));
d274 1
a274 1
		    host, inet_ntoa(hostaddr.sin_addr), port);
d285 2
a286 2
	      if (connect(sock, (struct sockaddr *)&hostaddr, 
			  sizeof(hostaddr)) >= 0)
d993 1
d1000 1
a1000 1
  RSA *host_key;
d1008 1
d1061 9
d1096 2
a1097 1
				       host_key->e, host_key->n);
d1101 2
a1102 2
					 host_key->e, host_key->n);

d1116 46
a1161 1
  switch (host_status)
d1163 1
a1163 5
    case HOST_OK:
      /* The host is known and the key matches. */
      debug("Host '%.200s' is known and matches the host key.", host);
      break;
    case HOST_NEW:
d1165 22
a1186 16
      if (options->strict_host_key_checking == 1)
	{ /* User has requested strict host key checking.  We will not
	     add the host key automatically.  The only alternative left
	     is to abort. */
	  fatal("No host key is known for %.200s and you have requested strict checking.", host);
	}
      else if (options->strict_host_key_checking == 2) /* The default */
	{
	  char prompt[1024];
	  sprintf(prompt,
		  "The authenticity of host '%.200s' can't be established.\n"
		  "Are you sure you want to continue connecting (yes/no)? ",
		  host);
	  if (!read_yes_or_no(prompt, -1))
	    fatal("Aborted by user!\n");
	}
d1189 1
a1189 1
      if (!add_host_to_hostfile(options->user_hostfile, host,
d1195 2
a1196 27
	log("Warning: Permanently added host '%.200s' to the list of known hosts.", host);
      break;
    case HOST_CHANGED:
      /* The host key has changed. */
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
      error("@@       WARNING: HOST IDENTIFICATION HAS CHANGED!         @@");
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
      error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
      error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
      error("It is also possible that the host key has just been changed.");
      error("Please contact your system administrator.");
      error("Add correct host key in %.100s to get rid of this message.", 
	    options->user_hostfile);

      /* If strict host key checking is in use, the user will have to edit
	 the key manually and we can only abort. */
      if (options->strict_host_key_checking)
	fatal("Host key for %.200s has changed and you have requested strict checking.", host);

      /* If strict host key checking has not been requested, allow the
	 connection but without password authentication. */
      error("Password authentication is disabled to avoid trojan horses.");
      options->password_authentication = 0;
      /* XXX Should permit the user to change to use the new id.  This could
         be done by converting the host key to an identifying sentence, tell
	 that the host identifies itself by that sentence, and ask the user
	 if he/she whishes to accept the authentication. */
d1199 42
a1240 1

@


1.10
log
@use libc md5
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.9 1999/09/30 06:06:31 deraadt Exp $");
d250 1
a250 1
	  shutdown(sock, 2);
d298 1
a298 1
	      shutdown(sock, 2);
@


1.9
log
@use IPPORT_RESERVED instead of 1024
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.8 1999/09/30 05:53:04 deraadt Exp $");
a26 1
#include "ssh_md5.h"
d30 2
d442 1
a442 1
  struct MD5Context md;
@


1.8
log
@"ssh is a very large program" -- anonymous
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.7 1999/09/30 04:30:03 deraadt Exp $");
d232 1
a232 1
				     port < 1024);
d278 1
a278 1
				         port < 1024);
@


1.7
log
@more culling
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.6 1999/09/29 21:14:16 deraadt Exp $");
a185 1
#ifdef SO_LINGER
a186 1
#endif /* SO_LINGER */
a315 1
#ifdef TCP_NODELAY
a316 2
#endif /* TCP_NODELAY */
#ifdef SO_LINGER
a319 1
#endif /* SO_LINGER */
@


1.6
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.5 1999/09/29 18:16:21 dugsong Exp $");
a223 3
#ifdef BROKEN_INET_ADDR
      hostaddr.sin_addr.s_addr = inet_network(host);
#else /* BROKEN_INET_ADDR */
a224 1
#endif /* BROKEN_INET_ADDR */
@


1.5
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.4 1999/09/29 15:52:55 provos Exp $");
d48 1
a48 1
  sprintf(portstring, "%d", port);
d548 2
a549 1
      sprintf(buf, "Enter passphrase for RSA key '%.100s': ", comment);
d861 1
a861 1
    strcpy(creds.service, "afs");
d863 1
a863 1
    strncpy(creds.realm, server_cell, REALM_SZ);
d938 1
a938 1
  sprintf(buf, "SSH-%d.%d-%.100s\n", 
d969 1
a969 1
	  strcpy(buf, "no");
@


1.4
log
@print username and host in password prompt
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.3 1999/09/28 04:45:37 provos Exp $");
a30 13
#ifdef KRB4
#include <krb.h>
#ifdef AFS
#if defined(HAVE_SYS_IOCTL_H) && SunOS != 4
#include <sys/ioctl.h>
#endif
#ifdef HAVE_SYS_FILIO_H
#include <sys/filio.h>
#endif
#include <kafs.h>
#endif /* AFS */
#endif /* KRB4 */

a147 1
      struct sockaddr_in sin;
d679 1
a679 1
  int r, type;
a684 1
  int plen;
a688 1
  debug("Trying Kerberos authentication.");
d693 1
a693 1
    debug("Kerberos V4: no realm for %.100s", get_canonical_hostname());
d701 1
a701 1
    debug("Kerberos V4 krb_mk_req failed: %.100s", krb_err_txt[r]);
d707 1
a707 1
     debug("get_cred failed: %.100s", krb_err_txt[r]);
d718 1
a718 1
  /* zero the buffer */
d725 1
a725 1
    debug("getsockname failed: %.100s", strerror(errno));
d731 1
a731 1
     debug("getpeername failed: %.100s", strerror(errno));
d757 1
a757 1
       debug("Kerberos V4 krb_rd_priv failed: %.100s", krb_err_txt[r]);
d760 1
a760 1
     /* fetch the (incremented) checksum that we supplied in the request */
a780 2

#ifdef KERBEROS_TGT_PASSING
d785 1
a785 1
  int r, plen, type;
d792 1
a792 1
  creds = xmalloc(sizeof(CREDENTIALS));
d794 2
a795 2
  if ((r=krb_get_tf_fullname(TKT_FILE,pname,pinst,prealm)) != KSUCCESS) {
    debug("Kerberos V4 tf_fullname failed: %.100s",krb_err_txt[r]);
d797 3
a799 3
}
  if ((r=krb_get_cred("krbtgt", prealm, prealm, creds)) != GC_OK) {
    debug("Kerberos V4 get_cred failed: %.100s", krb_err_txt[r]);
d803 1
a803 1
    debug("Kerberos V4 ticket expired: %.100s", TKT_FILE);
d816 1
a816 1

d818 1
a818 1
    debug("Kerberos TGT for realm %.100s rejected.", prealm);
a823 1
#endif /* KERBEROS_TGT_PASSING */
a824 1
/* Forwards our AFS tokens to the server. */
d830 1
a830 2
  int i, type;
  int len, plen;
d867 1
a867 1
    sprintf(creds.pname, "AFS ID %d", ct.ViceId);
d881 1
a881 1
      debug("AFS token for cell %.100s rejected.", server_cell);
a1003 1
  char buf[1024];
a1011 1
  struct stat st;
d1016 1
a1016 1
  u_int32_t rand;
d1295 1
a1295 1
#ifdef KERBEROS_TGT_PASSING
d1298 7
a1304 8
      options->kerberos_tgt_passing) {
    if (options->cipher == SSH_CIPHER_NONE)
      log("WARNING: Encryption is disabled! Ticket will be transmitted in the clear!");
    (void)send_kerberos_tgt();
  }
#endif /* KERBEROS_TGT_PASSING */
  
#ifdef AFS
d1314 1
a1314 1
#if defined(KRB4)
d1318 1
@


1.3
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.19 1999/06/14 14:41:41 bg Exp $");
d1403 3
d1409 1
a1409 1
      password = read_passphrase("Password: ", 0);
@


1.2
log
@use rresvport(), for random port allocation
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.1 1999/09/26 20:53:38 deraadt Exp $");
d20 1
a20 1
#include <gmp.h>
a21 1
#include "randoms.h"
d49 3
a51 2
int ssh_proxy_connect(const char *host, int port, uid_t original_real_uid,
		      const char *proxy_command, RandomState *random_state)
d146 1
a146 1
  packet_set_connection(pout[0], pin[1], random_state);
d193 1
a193 1
		const char *proxy_command, RandomState *random_state)
d219 1
a219 2
    return ssh_proxy_connect(host, port, original_real_uid, proxy_command,
			     random_state);
d346 1
a346 1
  packet_set_connection(sock, sock, random_state);
d354 2
a355 1
int try_agent_authentication()
a357 1
  MP_INT e, n, challenge;
d362 1
d369 3
a371 3
  mpz_init(&e);
  mpz_init(&n);
  mpz_init(&challenge);
d374 1
a374 1
  for (status = ssh_get_first_identity(auth, &bits, &e, &n, &comment);
d376 1
a376 1
       status = ssh_get_next_identity(auth, &bits, &e, &n, &comment))
d386 1
a386 1
      packet_put_mp_int(&n);
d406 1
a406 1
      packet_get_mp_int(&challenge, &clen);
d413 1
a413 1
      if (!ssh_decrypt_challenge(auth, bits, &e, &n, &challenge, 
d438 3
a440 3
	  mpz_clear(&e);
	  mpz_clear(&n);
	  mpz_clear(&challenge);
d450 3
a452 3
  mpz_clear(&e);
  mpz_clear(&n);
  mpz_clear(&challenge);
d461 2
a462 1
void respond_to_rsa_challenge(MP_INT *challenge, RSAPrivateKey *prv)
d466 1
a466 1
  int i;
d473 4
a476 1
  mp_linearize_msb_first(buf, 32, challenge);
d499 3
a501 2
int try_rsa_authentication(struct passwd *pw, const char *authfile,
			   int may_ask_passphrase)
d503 3
a505 3
  MP_INT challenge;
  RSAPrivateKey private_key;
  RSAPublicKey public_key;
d511 3
a513 1
  if (!load_public_key(authfile, &public_key, &comment))
d515 1
d521 1
a521 1
  packet_put_mp_int(&public_key.n);
d526 1
a526 1
  rsa_clear_public_key(&public_key);
d545 2
a546 2
  mpz_init(&challenge);
  packet_get_mp_int(&challenge, &clen);
d552 1
d555 1
a555 1
  if (!load_private_key(authfile, "", &private_key, NULL))
d573 1
a573 1
      if (!load_private_key(authfile, passphrase, &private_key, NULL))
d601 1
a601 1
  respond_to_rsa_challenge(&challenge, &private_key);
d604 1
a604 1
  rsa_clear_private_key(&private_key);
d607 1
a607 1
  mpz_clear(&challenge);
d625 2
a626 2
int try_rhosts_rsa_authentication(const char *local_user, 
				  RSAPrivateKey *host_key)
d629 1
a629 1
  MP_INT challenge;
d637 3
a639 3
  packet_put_int(host_key->bits);
  packet_put_mp_int(&host_key->e);
  packet_put_mp_int(&host_key->n);
d659 2
a660 2
  mpz_init(&challenge);
  packet_get_mp_int(&challenge, &clen);
d667 1
a667 1
  respond_to_rsa_challenge(&challenge, host_key);
d670 1
a670 1
  mpz_clear(&challenge);
d1019 2
a1020 2
void ssh_login(RandomState *state, int host_key_valid, 
	       RSAPrivateKey *own_host_key,
d1028 3
a1030 3
  MP_INT key;
  RSAPublicKey host_key;
  RSAPublicKey public_key;
d1039 1
d1071 4
a1074 3
  public_key.bits = packet_get_int();
  mpz_init(&public_key.e);
  packet_get_mp_int(&public_key.e, &clen);
d1076 2
a1077 2
  mpz_init(&public_key.n);
  packet_get_mp_int(&public_key.n, &clen);
d1081 4
a1084 3
  host_key.bits = packet_get_int();
  mpz_init(&host_key.e);
  packet_get_mp_int(&host_key.e, &clen);
d1086 2
a1087 2
  mpz_init(&host_key.n);
  packet_get_mp_int(&host_key.n, &clen);
d1101 1
a1101 1
	public_key.bits, host_key.bits);
d1108 3
a1110 2
  compute_session_id(session_id, check_bytes, host_key.bits, &host_key.n, 
		     public_key.bits, &public_key.n);
d1115 2
a1116 2
				       host, host_key.bits, 
				       &host_key.e, &host_key.n);
d1119 2
a1120 2
					 host_key.bits, &host_key.e, 
					 &host_key.n);
d1161 3
a1163 2
      if (!add_host_to_hostfile(options->user_hostfile, host, host_key.bits, 
				&host_key.e, &host_key.n))
d1198 1
a1198 9
  
  /* Initialize the random number generator. */
  sprintf(buf, "%.500s/%.200s", pw->pw_dir, SSH_CLIENT_SEEDFILE);
  if (stat(buf, &st) < 0)
    log("Creating random seed file ~/%.900s.  This may take a while.", 
	SSH_CLIENT_SEEDFILE);
  else
    debug("Initializing random; seed file %.900s", buf);
  random_initialize(state, buf);
d1203 6
a1208 6
  for (i = 0; i < 32; i++)
    session_key[i] = random_get_byte(state);

  /* Save the new random state. */
  random_save(state, buf);
  random_stir(state); /* This is supposed to be irreversible. */
d1213 2
a1214 1
  mpz_init_set_ui(&key, 0);
d1217 1
a1217 1
      mpz_mul_2exp(&key, &key, 8);
d1219 1
a1219 1
	mpz_add_ui(&key, &key, session_key[i] ^ session_id[i]);
d1221 1
a1221 1
	mpz_add_ui(&key, &key, session_key[i]);
d1226 1
a1226 1
  if (mpz_cmp(&public_key.n, &host_key.n) < 0)
d1229 2
a1230 1
      assert(host_key.bits >= public_key.bits + SSH_KEY_BITS_RESERVED);
d1232 2
a1233 2
      rsa_public_encrypt(&key, &key, &public_key, state);
      rsa_public_encrypt(&key, &key, &host_key, state);
d1238 2
a1239 1
      assert(public_key.bits >= host_key.bits + SSH_KEY_BITS_RESERVED);
d1241 2
a1242 2
      rsa_public_encrypt(&key, &key, &host_key, state);
      rsa_public_encrypt(&key, &key, &public_key, state);
d1245 1
a1245 1
  if (options->cipher == SSH_CIPHER_NOT_SET)
d1248 7
a1254 7
    else
      {
	debug("Cipher %d not supported, using %.100s instead.",
	      cipher_name(ssh_cipher_default),
	      cipher_name(SSH_FALLBACK_CIPHER));
	options->cipher = SSH_FALLBACK_CIPHER;
      }
d1272 1
a1272 1
  packet_put_mp_int(&key);
d1283 3
a1285 3
  mpz_clear(&key);
  rsa_clear_public_key(&public_key);
  rsa_clear_public_key(&host_key);
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d18 1
a18 1
RCSID("$Id: sshconnect.c,v 1.19 1999/06/14 14:41:41 bg Exp $");
d162 5
a166 23
      int p;
      for (p = 1023; p > 512; p--)
	{
	  sock = socket(AF_INET, SOCK_STREAM, 0);
	  if (sock < 0)
	    fatal("socket: %.100s", strerror(errno));
	  
	  /* Initialize the desired sockaddr_in structure. */
	  memset(&sin, 0, sizeof(sin));
	  sin.sin_family = AF_INET;
	  sin.sin_addr.s_addr = INADDR_ANY;
	  sin.sin_port = htons(p);

	  /* Try to bind the socket to the privileged port. */
	  if (bind(sock, (struct sockaddr *)&sin, sizeof(sin)) >= 0)
	    break; /* Success. */
	  if (errno == EADDRINUSE)
	    {
	      close(sock);
	      continue;
	    }
	  fatal("bind: %.100s", strerror(errno));
	}
@

