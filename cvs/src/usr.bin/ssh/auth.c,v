head	1.124;
access;
symbols
	OPENBSD_6_2:1.124.0.2
	OPENBSD_6_2_BASE:1.124
	OPENBSD_6_1:1.119.0.4
	OPENBSD_6_1_BASE:1.119
	OPENBSD_6_0:1.115.0.4
	OPENBSD_6_0_BASE:1.115
	OPENBSD_5_9:1.113.0.2
	OPENBSD_5_9_BASE:1.113
	OPENBSD_5_8:1.112.0.4
	OPENBSD_5_8_BASE:1.112
	OPENBSD_5_7:1.110.0.2
	OPENBSD_5_7_BASE:1.110
	OPENBSD_5_6:1.106.0.4
	OPENBSD_5_6_BASE:1.106
	OPENBSD_5_5:1.103.0.6
	OPENBSD_5_5_BASE:1.103
	OPENBSD_5_4:1.103.0.2
	OPENBSD_5_4_BASE:1.103
	OPENBSD_5_3:1.101.0.2
	OPENBSD_5_3_BASE:1.101
	OPENBSD_5_2:1.96.0.2
	OPENBSD_5_2_BASE:1.96
	OPENBSD_5_1_BASE:1.94
	OPENBSD_5_1:1.94.0.4
	OPENBSD_5_0:1.94.0.2
	OPENBSD_5_0_BASE:1.94
	OPENBSD_4_9:1.91.0.2
	OPENBSD_4_9_BASE:1.91
	OPENBSD_4_8:1.89.0.2
	OPENBSD_4_8_BASE:1.89
	OPENBSD_4_7:1.86.0.2
	OPENBSD_4_7_BASE:1.86
	OPENBSD_4_6:1.80.0.6
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.80.0.2
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.79.0.2
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.78.0.2
	OPENBSD_4_3_BASE:1.78
	OPENBSD_4_2:1.75.0.6
	OPENBSD_4_2_BASE:1.75
	OPENBSD_4_1:1.75.0.2
	OPENBSD_4_1_BASE:1.75
	OPENBSD_4_0:1.75.0.4
	OPENBSD_4_0_BASE:1.75
	OPENBSD_3_9:1.62.0.2
	OPENBSD_3_9_BASE:1.62
	OPENBSD_3_8:1.60.0.2
	OPENBSD_3_8_BASE:1.60
	OPENBSD_3_7:1.58.0.2
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	OPENBSD_3_5:1.51.0.2
	OPENBSD_3_5_BASE:1.51
	OPENBSD_3_4:1.49.0.2
	OPENBSD_3_4_BASE:1.49
	OPENBSD_3_3:1.46.0.2
	OPENBSD_3_3_BASE:1.46
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.124
date	2017.09.12.06.32.07;	author djm;	state Exp;
branches;
next	1.123;
commitid	Amj5uk8F1JrQpmI5;

1.123
date	2017.08.18.05.36.45;	author djm;	state Exp;
branches;
next	1.122;
commitid	VAPvuXREJeMOB6MT;

1.122
date	2017.06.24.06.34.38;	author djm;	state Exp;
branches;
next	1.121;
commitid	t1sqOvl7ysAY3CkV;

1.121
date	2017.05.30.08.52.19;	author markus;	state Exp;
branches;
next	1.120;
commitid	AQD3o1zTZEMIcuBx;

1.120
date	2017.05.17.01.24.17;	author djm;	state Exp;
branches;
next	1.119;
commitid	eeQm0WTdCYidaM5F;

1.119
date	2016.12.15.21.29.05;	author dtucker;	state Exp;
branches;
next	1.118;
commitid	PfubRxj7nkomWDnW;

1.118
date	2016.11.08.22.04.34;	author djm;	state Exp;
branches;
next	1.117;
commitid	FtkAQ8yUuVWBqM73;

1.117
date	2016.11.06.05.46.37;	author djm;	state Exp;
branches;
next	1.116;
commitid	poSnZnjhu4JbUKhm;

1.116
date	2016.08.13.17.47.41;	author markus;	state Exp;
branches;
next	1.115;
commitid	dl4RDERdJITM8DKC;

1.115
date	2016.06.15.00.40.40;	author dtucker;	state Exp;
branches;
next	1.114;
commitid	tKzHP0VzdIm2Rh2n;

1.114
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.113;
commitid	kr9hjdmg99uVnhW2;

1.113
date	2015.08.21.03.42.19;	author djm;	state Exp;
branches;
next	1.112;
commitid	2ppN3pOBKovge2C9;

1.112
date	2015.08.06.14.53.21;	author deraadt;	state Exp;
branches
	1.112.4.1;
next	1.111;
commitid	Mw9TxvBajPRImAX3;

1.111
date	2015.05.01.04.17.51;	author djm;	state Exp;
branches;
next	1.110;
commitid	3a9gRigFyICUTZQy;

1.110
date	2015.02.25.17.29.38;	author djm;	state Exp;
branches;
next	1.109;
commitid	sHymagfOwmjgQkln;

1.109
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	cBx23BaCk6gYBpRj;

1.108
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.107;
commitid	EbtriidyZdsmXksl;

1.107
date	2014.12.04.02.24.32;	author djm;	state Exp;
branches;
next	1.106;
commitid	0YGyOuIh3H3xTolw;

1.106
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.105;
commitid	z7plx8Gkj6l2sxem;

1.105
date	2014.07.03.11.16.55;	author djm;	state Exp;
branches;
next	1.104;
commitid	qUeYjXdfTNrKthSc;

1.104
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2013.05.19.02.42.42;	author djm;	state Exp;
branches;
next	1.102;

1.102
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.101;

1.101
date	2013.02.06.00.22.21;	author dtucker;	state Exp;
branches;
next	1.100;

1.100
date	2013.01.17.23.00.01;	author djm;	state Exp;
branches;
next	1.99;

1.99
date	2012.12.14.05.26.43;	author dtucker;	state Exp;
branches;
next	1.98;

1.98
date	2012.12.02.20.34.09;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2012.10.30.21.29.54;	author djm;	state Exp;
branches;
next	1.96;

1.96
date	2012.05.13.01.42.32;	author dtucker;	state Exp;
branches;
next	1.95;

1.95
date	2012.04.11.13.17.54;	author djm;	state Exp;
branches;
next	1.94;

1.94
date	2011.05.23.03.33.38;	author djm;	state Exp;
branches;
next	1.93;

1.93
date	2011.05.23.03.30.07;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2011.05.11.04.47.06;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2010.11.29.23.45.51;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2010.11.23.02.35.50;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.04.05.42.47;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.22.04.49.47;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2010.05.07.11.30.29;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2010.03.05.02.58.11;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2010.02.09.06.18.46;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2010.01.13.23.47.26;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.13.00.19.04;	author dtucker;	state Exp;
branches;
next	1.81;

1.81
date	2010.01.10.07.15.56;	author dtucker;	state Exp;
branches;
next	1.80;

1.80
date	2008.11.04.07.58.09;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2008.07.02.12.03.51;	author dtucker;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.21.08.15.29;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2007.08.23.02.55.51;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2007.08.23.02.49.43;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.73;

1.73
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.12.11.34.58;	author dtucker;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.10.16.37.36;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.30.11.40.21;	author dtucker;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.20.17.10.19;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2006.02.20.17.19.53;	author stevesk;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.60;

1.60
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2005.06.06.11.20.36;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.14.11.44.42;	author dtucker;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2005.01.22.08.17.59;	author dtucker;	state Exp;
branches;
next	1.56;

1.56
date	2004.07.28.09.40.29;	author markus;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2004.07.21.08.56.12;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2004.05.23.23.59.53;	author dtucker;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.08.00.01.37;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.21.11.57.02;	author djm;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.26.09.58.43;	author markus;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2003.06.02.09.17.34;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2002.11.04.10.07.53;	author markus;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2002.09.20.18.41.29;	author stevesk;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2002.08.08.23.54.52;	author stevesk;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.17.14.27.55;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.13.20.44.58;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.19.15.31.47;	author markus;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2002.03.19.14.27.39;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.18.03.41.08;	author provos;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.17.20.25.56;	author provos;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.15.11.00.38;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.01.13.12.10;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.28.20.56.00;	author stevesk;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.28.19.36.28;	author stevesk;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.29.14.32.03;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.17.19.14.34;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.08.20.02.24;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.03.10.01.20;	author markus;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.07.11.18.26.15;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.27.04.48.52;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.25.17.54.48;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.23.00.20.57;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.24.11.12.42;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.20.17.20.35;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.19.17.07.23;	author markus;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.03.17.17.27.59;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.02.18.54.31;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.22.21.59.43;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.12.16.16.23;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.04.15.32.22;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.03.10.08.37;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.21.19.05.43;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.18.16.59.59;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.13.18.56.48;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.09.07.21.13.36;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.04.20.30.07;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.17.21.37.24;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.26.21.28.31;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.04.26.20.56.29;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.10.30.29;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.10.09.14;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.08.55.22;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.28.21.15.45;	author markus;	state Exp;
branches;
next	;

1.6.2.1
date	2000.06.12.02.37.31;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.09.01.18.23.17;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2000.11.08.21.30.22;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.03.21.18.52.34;	author jason;	state Exp;
branches;
next	;

1.11.2.1
date	2001.02.16.20.12.53;	author jason;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.02.19.17.18.37;	author jason;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2001.05.07.21.09.26;	author jason;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.21.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.28.2.1
date	2001.11.14.03.24.38;	author jason;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2002.06.02.22.36.55;	author miod;	state Exp;
branches;
next	1.28.2.5;

1.28.2.5
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.41.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.05.18.04.50.37;	author jason;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2002.10.11.14.51.51;	author miod;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2003.04.03.22.35.16;	author miod;	state Exp;
branches;
next	;

1.45.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.46.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.49.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.51.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.56.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.56.2.3;

1.56.2.3
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.58.2.1
date	2005.09.04.18.39.52;	author brad;	state Exp;
branches;
next	;

1.60.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.62.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.112.4.1
date	2015.08.30.13.13.44;	author jasper;	state Exp;
branches;
next	;
commitid	9kImRtMB4puMMnCT;


desc
@@


1.124
log
@refactor channels.c

Move static state to a "struct ssh_channels" that is allocated at
runtime and tracked as a member of struct ssh.

Explicitly pass "struct ssh" to all channels functions.

Replace use of the legacy packet APIs in channels.c.

Rework sshd_config PermitOpen handling: previously the configuration
parser would call directly into the channels layer. After the refactor
this is not possible, as the channels structures are allocated at
connection time and aren't available when the configuration is parsed.
The server config parser now tracks PermitOpen itself and explicitly
configures the channels code later.

ok markus@@
@
text
@/* $OpenBSD: auth.c,v 1.123 2017/08/18 05:36:45 djm Exp $ */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <errno.h>
#include <fcntl.h>
#include <login_cap.h>
#include <paths.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <netdb.h>

#include "xmalloc.h"
#include "match.h"
#include "groupaccess.h"
#include "log.h"
#include "buffer.h"
#include "misc.h"
#include "servconf.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "auth-options.h"
#include "canohost.h"
#include "uidswap.h"
#include "packet.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "authfile.h"
#include "monitor_wrap.h"
#include "authfile.h"
#include "ssherr.h"
#include "compat.h"

/* import */
extern ServerOptions options;
extern int use_privsep;

/* Debugging messages */
Buffer auth_debug;
int auth_debug_init;

/*
 * Check if the user is allowed to log in via ssh. If user is listed
 * in DenyUsers or one of user's groups is listed in DenyGroups, false
 * will be returned. If AllowUsers isn't empty and user isn't listed
 * there, or if AllowGroups isn't empty and one of user's groups isn't
 * listed there, false will be returned.
 * If the user's shell is not executable, false will be returned.
 * Otherwise true is returned.
 */
int
allowed_user(struct passwd * pw)
{
	struct ssh *ssh = active_state; /* XXX */
	struct stat st;
	const char *hostname = NULL, *ipaddr = NULL;
	int r;
	u_int i;

	/* Shouldn't be called if pw is NULL, but better safe than sorry... */
	if (!pw || !pw->pw_name)
		return 0;

	/*
	 * Deny if shell does not exist or is not executable unless we
	 * are chrooting.
	 */
	if (options.chroot_directory == NULL ||
	    strcasecmp(options.chroot_directory, "none") == 0) {
		char *shell = xstrdup((pw->pw_shell[0] == '\0') ?
		    _PATH_BSHELL : pw->pw_shell); /* empty = /bin/sh */

		if (stat(shell, &st) != 0) {
			logit("User %.100s not allowed because shell %.100s "
			    "does not exist", pw->pw_name, shell);
			free(shell);
			return 0;
		}
		if (S_ISREG(st.st_mode) == 0 ||
		    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {
			logit("User %.100s not allowed because shell %.100s "
			    "is not executable", pw->pw_name, shell);
			free(shell);
			return 0;
		}
		free(shell);
	}

	if (options.num_deny_users > 0 || options.num_allow_users > 0 ||
	    options.num_deny_groups > 0 || options.num_allow_groups > 0) {
		hostname = auth_get_canonical_hostname(ssh, options.use_dns);
		ipaddr = ssh_remote_ipaddr(ssh);
	}

	/* Return false if user is listed in DenyUsers */
	if (options.num_deny_users > 0) {
		for (i = 0; i < options.num_deny_users; i++) {
			r = match_user(pw->pw_name, hostname, ipaddr,
			    options.deny_users[i]);
			if (r < 0) {
				fatal("Invalid DenyUsers pattern \"%.100s\"",
				    options.deny_users[i]);
			} else if (r != 0) {
				logit("User %.100s from %.100s not allowed "
				    "because listed in DenyUsers",
				    pw->pw_name, hostname);
				return 0;
			}
		}
	}
	/* Return false if AllowUsers isn't empty and user isn't listed there */
	if (options.num_allow_users > 0) {
		for (i = 0; i < options.num_allow_users; i++) {
			r = match_user(pw->pw_name, hostname, ipaddr,
			    options.allow_users[i]);
			if (r < 0) {
				fatal("Invalid AllowUsers pattern \"%.100s\"",
				    options.allow_users[i]);
			} else if (r == 1)
				break;
		}
		/* i < options.num_allow_users iff we break for loop */
		if (i >= options.num_allow_users) {
			logit("User %.100s from %.100s not allowed because "
			    "not listed in AllowUsers", pw->pw_name, hostname);
			return 0;
		}
	}
	if (options.num_deny_groups > 0 || options.num_allow_groups > 0) {
		/* Get the user's group access list (primary and supplementary) */
		if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
			logit("User %.100s from %.100s not allowed because "
			    "not in any group", pw->pw_name, hostname);
			return 0;
		}

		/* Return false if one of user's groups is listed in DenyGroups */
		if (options.num_deny_groups > 0)
			if (ga_match(options.deny_groups,
			    options.num_deny_groups)) {
				ga_free();
				logit("User %.100s from %.100s not allowed "
				    "because a group is listed in DenyGroups",
				    pw->pw_name, hostname);
				return 0;
			}
		/*
		 * Return false if AllowGroups isn't empty and one of user's groups
		 * isn't listed there
		 */
		if (options.num_allow_groups > 0)
			if (!ga_match(options.allow_groups,
			    options.num_allow_groups)) {
				ga_free();
				logit("User %.100s from %.100s not allowed "
				    "because none of user's groups are listed "
				    "in AllowGroups", pw->pw_name, hostname);
				return 0;
			}
		ga_free();
	}
	/* We found no reason not to let this user try to log on... */
	return 1;
}

/*
 * Formats any key left in authctxt->auth_method_key for inclusion in
 * auth_log()'s message. Also includes authxtct->auth_method_info if present.
 */
static char *
format_method_key(Authctxt *authctxt)
{
	const struct sshkey *key = authctxt->auth_method_key;
	const char *methinfo = authctxt->auth_method_info;
	char *fp, *ret = NULL;

	if (key == NULL)
		return NULL;

	if (key_is_cert(key)) {
		fp = sshkey_fingerprint(key->cert->signature_key,
		    options.fingerprint_hash, SSH_FP_DEFAULT);
		xasprintf(&ret, "%s ID %s (serial %llu) CA %s %s%s%s",
		    sshkey_type(key), key->cert->key_id,
		    (unsigned long long)key->cert->serial,
		    sshkey_type(key->cert->signature_key),
		    fp == NULL ? "(null)" : fp,
		    methinfo == NULL ? "" : ", ",
		    methinfo == NULL ? "" : methinfo);
		free(fp);
	} else {
		fp = sshkey_fingerprint(key, options.fingerprint_hash,
		    SSH_FP_DEFAULT);
		xasprintf(&ret, "%s %s%s%s", sshkey_type(key),
		    fp == NULL ? "(null)" : fp,
		    methinfo == NULL ? "" : ", ",
		    methinfo == NULL ? "" : methinfo);
		free(fp);
	}
	return ret;
}

void
auth_log(Authctxt *authctxt, int authenticated, int partial,
    const char *method, const char *submethod)
{
	struct ssh *ssh = active_state; /* XXX */
	void (*authlog) (const char *fmt,...) = verbose;
	const char *authmsg;
	char *extra = NULL;

	if (use_privsep && !mm_is_monitor() && !authctxt->postponed)
		return;

	/* Raise logging level */
	if (authenticated == 1 ||
	    !authctxt->valid ||
	    authctxt->failures >= options.max_authtries / 2 ||
	    strcmp(method, "password") == 0)
		authlog = logit;

	if (authctxt->postponed)
		authmsg = "Postponed";
	else if (partial)
		authmsg = "Partial";
	else
		authmsg = authenticated ? "Accepted" : "Failed";

	if ((extra = format_method_key(authctxt)) == NULL) {
		if (authctxt->auth_method_info != NULL)
			extra = xstrdup(authctxt->auth_method_info);
	}

	authlog("%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s",
	    authmsg,
	    method,
	    submethod != NULL ? "/" : "", submethod == NULL ? "" : submethod,
	    authctxt->valid ? "" : "invalid user ",
	    authctxt->user,
	    ssh_remote_ipaddr(ssh),
	    ssh_remote_port(ssh),
	    extra != NULL ? ": " : "",
	    extra != NULL ? extra : "");

	free(extra);
}

void
auth_maxtries_exceeded(Authctxt *authctxt)
{
	struct ssh *ssh = active_state; /* XXX */

	error("maximum authentication attempts exceeded for "
	    "%s%.100s from %.200s port %d ssh2",
	    authctxt->valid ? "" : "invalid user ",
	    authctxt->user,
	    ssh_remote_ipaddr(ssh),
	    ssh_remote_port(ssh));
	packet_disconnect("Too many authentication failures");
	/* NOTREACHED */
}

/*
 * Check whether root logins are disallowed.
 */
int
auth_root_allowed(const char *method)
{
	struct ssh *ssh = active_state; /* XXX */

	switch (options.permit_root_login) {
	case PERMIT_YES:
		return 1;
	case PERMIT_NO_PASSWD:
		if (strcmp(method, "publickey") == 0 ||
		    strcmp(method, "hostbased") == 0 ||
		    strcmp(method, "gssapi-with-mic") == 0)
			return 1;
		break;
	case PERMIT_FORCED_ONLY:
		if (forced_command) {
			logit("Root login accepted for forced command.");
			return 1;
		}
		break;
	}
	logit("ROOT LOGIN REFUSED FROM %.200s port %d",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
	return 0;
}


/*
 * Given a template and a passwd structure, build a filename
 * by substituting % tokenised options. Currently, %% becomes '%',
 * %h becomes the home directory and %u the username.
 *
 * This returns a buffer allocated by xmalloc.
 */
char *
expand_authorized_keys(const char *filename, struct passwd *pw)
{
	char *file, ret[PATH_MAX];
	int i;

	file = percent_expand(filename, "h", pw->pw_dir,
	    "u", pw->pw_name, (char *)NULL);

	/*
	 * Ensure that filename starts anchored. If not, be backward
	 * compatible and prepend the '%h/'
	 */
	if (*file == '/')
		return (file);

	i = snprintf(ret, sizeof(ret), "%s/%s", pw->pw_dir, file);
	if (i < 0 || (size_t)i >= sizeof(ret))
		fatal("expand_authorized_keys: path too long");
	free(file);
	return (xstrdup(ret));
}

char *
authorized_principals_file(struct passwd *pw)
{
	if (options.authorized_principals_file == NULL)
		return NULL;
	return expand_authorized_keys(options.authorized_principals_file, pw);
}

/* return ok if key exists in sysfile or userfile */
HostStatus
check_key_in_hostfiles(struct passwd *pw, struct sshkey *key, const char *host,
    const char *sysfile, const char *userfile)
{
	char *user_hostfile;
	struct stat st;
	HostStatus host_status;
	struct hostkeys *hostkeys;
	const struct hostkey_entry *found;

	hostkeys = init_hostkeys();
	load_hostkeys(hostkeys, host, sysfile);
	if (userfile != NULL) {
		user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
		if (options.strict_modes &&
		    (stat(user_hostfile, &st) == 0) &&
		    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		    (st.st_mode & 022) != 0)) {
			logit("Authentication refused for %.100s: "
			    "bad owner or modes for %.200s",
			    pw->pw_name, user_hostfile);
			auth_debug_add("Ignored %.200s: bad ownership or modes",
			    user_hostfile);
		} else {
			temporarily_use_uid(pw);
			load_hostkeys(hostkeys, host, user_hostfile);
			restore_uid();
		}
		free(user_hostfile);
	}
	host_status = check_key_in_hostkeys(hostkeys, key, &found);
	if (host_status == HOST_REVOKED)
		error("WARNING: revoked key for %s attempted authentication",
		    found->host);
	else if (host_status == HOST_OK)
		debug("%s: key for %s found at %s:%ld", __func__,
		    found->host, found->file, found->line);
	else
		debug("%s: key for host %s not found", __func__, host);

	free_hostkeys(hostkeys);

	return host_status;
}

static FILE *
auth_openfile(const char *file, struct passwd *pw, int strict_modes,
    int log_missing, char *file_type)
{
	char line[1024];
	struct stat st;
	int fd;
	FILE *f;

	if ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {
		if (log_missing || errno != ENOENT)
			debug("Could not open %s '%s': %s", file_type, file,
			   strerror(errno));
		return NULL;
	}

	if (fstat(fd, &st) < 0) {
		close(fd);
		return NULL;
	}
	if (!S_ISREG(st.st_mode)) {
		logit("User %s %s %s is not a regular file",
		    pw->pw_name, file_type, file);
		close(fd);
		return NULL;
	}
	unset_nonblock(fd);
	if ((f = fdopen(fd, "r")) == NULL) {
		close(fd);
		return NULL;
	}
	if (strict_modes &&
	    safe_path_fd(fileno(f), file, pw, line, sizeof(line)) != 0) {
		fclose(f);
		logit("Authentication refused: %s", line);
		auth_debug_add("Ignored %s: %s", file_type, line);
		return NULL;
	}

	return f;
}


FILE *
auth_openkeyfile(const char *file, struct passwd *pw, int strict_modes)
{
	return auth_openfile(file, pw, strict_modes, 1, "authorized keys");
}

FILE *
auth_openprincipals(const char *file, struct passwd *pw, int strict_modes)
{
	return auth_openfile(file, pw, strict_modes, 0,
	    "authorized principals");
}

struct passwd *
getpwnamallow(const char *user)
{
	struct ssh *ssh = active_state; /* XXX */
	extern login_cap_t *lc;
	auth_session_t *as;
	struct passwd *pw;
	struct connection_info *ci = get_connection_info(1, options.use_dns);

	ci->user = user;
	parse_server_match_config(&options, ci);
	log_change_level(options.log_level);
	process_permitopen(ssh, &options);

	pw = getpwnam(user);
	if (pw == NULL) {
		logit("Invalid user %.100s from %.100s port %d",
		    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
		return (NULL);
	}
	if (!allowed_user(pw))
		return (NULL);
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
		debug("unable to get login class: %s", user);
		return (NULL);
	}
	if ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||
	    auth_approval(as, lc, pw->pw_name, "ssh") <= 0) {
		debug("Approval failure for %s", user);
		pw = NULL;
	}
	if (as != NULL)
		auth_close(as);
	if (pw != NULL)
		return (pwcopy(pw));
	return (NULL);
}

/* Returns 1 if key is revoked by revoked_keys_file, 0 otherwise */
int
auth_key_is_revoked(struct sshkey *key)
{
	char *fp = NULL;
	int r;

	if (options.revoked_keys_file == NULL)
		return 0;
	if ((fp = sshkey_fingerprint(key, options.fingerprint_hash,
	    SSH_FP_DEFAULT)) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		error("%s: fingerprint key: %s", __func__, ssh_err(r));
		goto out;
	}

	r = sshkey_check_revoked(key, options.revoked_keys_file);
	switch (r) {
	case 0:
		break; /* not revoked */
	case SSH_ERR_KEY_REVOKED:
		error("Authentication key %s %s revoked by file %s",
		    sshkey_type(key), fp, options.revoked_keys_file);
		goto out;
	default:
		error("Error checking authentication key %s %s in "
		    "revoked keys file %s: %s", sshkey_type(key), fp,
		    options.revoked_keys_file, ssh_err(r));
		goto out;
	}

	/* Success */
	r = 0;

 out:
	free(fp);
	return r == 0 ? 0 : 1;
}

void
auth_debug_add(const char *fmt,...)
{
	char buf[1024];
	va_list args;

	if (!auth_debug_init)
		return;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);
	buffer_put_cstring(&auth_debug, buf);
}

void
auth_debug_send(void)
{
	char *msg;

	if (!auth_debug_init)
		return;
	while (buffer_len(&auth_debug)) {
		msg = buffer_get_string(&auth_debug, NULL);
		packet_send_debug("%s", msg);
		free(msg);
	}
}

void
auth_debug_reset(void)
{
	if (auth_debug_init)
		buffer_clear(&auth_debug);
	else {
		buffer_init(&auth_debug);
		auth_debug_init = 1;
	}
}

struct passwd *
fakepw(void)
{
	static struct passwd fake;

	memset(&fake, 0, sizeof(fake));
	fake.pw_name = "NOUSER";
	fake.pw_passwd =
	    "$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";
	fake.pw_gecos = "NOUSER";
	fake.pw_uid = (uid_t)-1;
	fake.pw_gid = (gid_t)-1;
	fake.pw_class = "";
	fake.pw_dir = "/nonexist";
	fake.pw_shell = "/nonexist";

	return (&fake);
}

/*
 * Returns the remote DNS hostname as a string. The returned string must not
 * be freed. NB. this will usually trigger a DNS query the first time it is
 * called.
 * This function does additional checks on the hostname to mitigate some
 * attacks on legacy rhosts-style authentication.
 * XXX is RhostsRSAAuthentication vulnerable to these?
 * XXX Can we remove these checks? (or if not, remove RhostsRSAAuthentication?)
 */

static char *
remote_hostname(struct ssh *ssh)
{
	struct sockaddr_storage from;
	socklen_t fromlen;
	struct addrinfo hints, *ai, *aitop;
	char name[NI_MAXHOST], ntop2[NI_MAXHOST];
	const char *ntop = ssh_remote_ipaddr(ssh);

	/* Get IP address of client. */
	fromlen = sizeof(from);
	memset(&from, 0, sizeof(from));
	if (getpeername(ssh_packet_get_connection_in(ssh),
	    (struct sockaddr *)&from, &fromlen) < 0) {
		debug("getpeername failed: %.100s", strerror(errno));
		return strdup(ntop);
	}

	debug3("Trying to reverse map address %.100s.", ntop);
	/* Map the IP address to a host name. */
	if (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),
	    NULL, 0, NI_NAMEREQD) != 0) {
		/* Host name not found.  Use ip address. */
		return strdup(ntop);
	}

	/*
	 * if reverse lookup result looks like a numeric hostname,
	 * someone is trying to trick us by PTR record like following:
	 *	1.1.1.10.in-addr.arpa.	IN PTR	2.3.4.5
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(name, NULL, &hints, &ai) == 0) {
		logit("Nasty PTR record \"%s\" is set up for %s, ignoring",
		    name, ntop);
		freeaddrinfo(ai);
		return strdup(ntop);
	}

	/* Names are stored in lowercase. */
	lowercase(name);

	/*
	 * Map it back to an IP address and check that the given
	 * address actually is an address of this host.  This is
	 * necessary because anyone with access to a name server can
	 * define arbitrary names for an IP address. Mapping from
	 * name to IP address can be trusted better (but can still be
	 * fooled if the intruder has access to the name server of
	 * the domain).
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = from.ss_family;
	hints.ai_socktype = SOCK_STREAM;
	if (getaddrinfo(name, NULL, &hints, &aitop) != 0) {
		logit("reverse mapping checking getaddrinfo for %.700s "
		    "[%s] failed.", name, ntop);
		return strdup(ntop);
	}
	/* Look for the address from the list of addresses. */
	for (ai = aitop; ai; ai = ai->ai_next) {
		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,
		    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&
		    (strcmp(ntop, ntop2) == 0))
				break;
	}
	freeaddrinfo(aitop);
	/* If we reached the end of the list, the address was not there. */
	if (ai == NULL) {
		/* Address not found for the host name. */
		logit("Address %.100s maps to %.600s, but this does not "
		    "map back to the address.", ntop, name);
		return strdup(ntop);
	}
	return strdup(name);
}

/*
 * Return the canonical name of the host in the other side of the current
 * connection.  The host name is cached, so it is efficient to call this
 * several times.
 */

const char *
auth_get_canonical_hostname(struct ssh *ssh, int use_dns)
{
	static char *dnsname;

	if (!use_dns)
		return ssh_remote_ipaddr(ssh);
	else if (dnsname != NULL)
		return dnsname;
	else {
		dnsname = remote_hostname(ssh);
		return dnsname;
	}
}
@


1.123
log
@Move several subprocess-related functions from various locations to
misc.c. Extend subprocess() to offer a little more control over stdio
disposition.

feedback & ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.122 2017/06/24 06:34:38 djm Exp $ */
d476 1
@


1.122
log
@refactor authentication logging

optionally record successful auth methods and public credentials
used in a file accessible to user sessions

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.121 2017/05/30 08:52:19 markus Exp $ */
a31 1
#include <libgen.h>
a407 92
/*
 * Check a given path for security. This is defined as all components
 * of the path to the file must be owned by either the owner of
 * of the file or root and no directories must be group or world writable.
 *
 * XXX Should any specific check be done for sym links ?
 *
 * Takes a file name, its stat information (preferably from fstat() to
 * avoid races), the uid of the expected owner, their home directory and an
 * error buffer plus max size as arguments.
 *
 * Returns 0 on success and -1 on failure
 */
int
auth_secure_path(const char *name, struct stat *stp, const char *pw_dir,
    uid_t uid, char *err, size_t errlen)
{
	char buf[PATH_MAX], homedir[PATH_MAX];
	char *cp;
	int comparehome = 0;
	struct stat st;

	if (realpath(name, buf) == NULL) {
		snprintf(err, errlen, "realpath %s failed: %s", name,
		    strerror(errno));
		return -1;
	}
	if (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)
		comparehome = 1;

	if (!S_ISREG(stp->st_mode)) {
		snprintf(err, errlen, "%s is not a regular file", buf);
		return -1;
	}
	if ((stp->st_uid != 0 && stp->st_uid != uid) ||
	    (stp->st_mode & 022) != 0) {
		snprintf(err, errlen, "bad ownership or modes for file %s",
		    buf);
		return -1;
	}

	/* for each component of the canonical path, walking upwards */
	for (;;) {
		if ((cp = dirname(buf)) == NULL) {
			snprintf(err, errlen, "dirname() failed");
			return -1;
		}
		strlcpy(buf, cp, sizeof(buf));

		if (stat(buf, &st) < 0 ||
		    (st.st_uid != 0 && st.st_uid != uid) ||
		    (st.st_mode & 022) != 0) {
			snprintf(err, errlen,
			    "bad ownership or modes for directory %s", buf);
			return -1;
		}

		/* If are past the homedir then we can stop */
		if (comparehome && strcmp(homedir, buf) == 0)
			break;

		/*
		 * dirname should always complete with a "/" path,
		 * but we can be paranoid and check for "." too
		 */
		if ((strcmp("/", buf) == 0) || (strcmp(".", buf) == 0))
			break;
	}
	return 0;
}

/*
 * Version of secure_path() that accepts an open file descriptor to
 * avoid races.
 *
 * Returns 0 on success and -1 on failure
 */
static int
secure_filename(FILE *f, const char *file, struct passwd *pw,
    char *err, size_t errlen)
{
	struct stat st;

	/* check the open file to avoid races */
	if (fstat(fileno(f), &st) < 0) {
		snprintf(err, errlen, "cannot stat file %s: %s",
		    file, strerror(errno));
		return -1;
	}
	return auth_secure_path(file, &st, pw->pw_dir, pw->pw_uid, err, errlen);
}

d440 1
a440 1
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
@


1.121
log
@switch from Key typedef with struct sshkey; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.120 2017/05/17 01:24:17 djm Exp $ */
d198 6
a203 2
void
auth_info(Authctxt *authctxt, const char *fmt, ...)
d205 28
a232 12
	va_list ap;
        int i;

	free(authctxt->info);
	authctxt->info = NULL;

	va_start(ap, fmt);
	i = vasprintf(&authctxt->info, fmt, ap);
	va_end(ap);

	if (i < 0 || authctxt->info == NULL)
		fatal("vasprintf failed");
d241 2
a242 1
	char *authmsg;
d261 5
d274 4
a277 4
	    authctxt->info != NULL ? ": " : "",
	    authctxt->info != NULL ? authctxt->info : "");
	free(authctxt->info);
	authctxt->info = NULL;
@


1.120
log
@allow LogLevel in sshd_config Match blocks; ok dtucker bz#2717
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.119 2016/12/15 21:29:05 dtucker Exp $ */
d339 1
a339 1
check_key_in_hostfiles(struct passwd *pw, Key *key, const char *host,
d570 1
a570 1
auth_key_is_revoked(Key *key)
@


1.119
log
@Add missing braces in DenyUsers code.  Patch from zev at bewilderbeest.net,
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.118 2016/11/08 22:04:34 djm Exp $ */
d542 1
@


1.118
log
@unbreak DenyUsers; reported by henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.117 2016/11/06 05:46:37 djm Exp $ */
d129 1
a129 1
		for (i = 0; i < options.num_deny_users; i++)
d141 1
@


1.117
log
@Validate address ranges for AllowUser/DenyUsers at configuration load
time and refuse to accept bad ones. It was previously possible to
specify invalid CIDR address ranges (e.g. djm@@127.1.2.3/55) and these
would always match.

Thanks to Laurence Parry for a detailed bug report. ok markus (for
a previous diff version)
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.116 2016/08/13 17:47:41 markus Exp $ */
d135 1
a135 1
			} else if (r != 1) {
@


1.116
log
@remove ssh1 server code; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.115 2016/06/15 00:40:40 dtucker Exp $ */
d89 1
d130 6
a135 2
			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.deny_users[i])) {
d144 7
a150 3
		for (i = 0; i < options.num_allow_users; i++)
			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.allow_users[i]))
d152 1
@


1.115
log
@Remove "POSSIBLE BREAK-IN ATTEMPT!" from log message about forward and
reverse DNS not matching.  We haven't supported IP-based auth methods
for a very long time so it's now misleading.  part of bz#2585, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.114 2016/03/07 19:02:43 djm Exp $ */
d229 1
a229 1
	authlog("%s %s%s%s for %s%.100s from %.200s port %d %s%s%s",
a236 1
	    compat20 ? "ssh2" : "ssh1",
d249 1
a249 1
	    "%s%.100s from %.200s port %d %s",
d253 1
a253 2
	    ssh_remote_port(ssh),
	    compat20 ? "ssh2" : "ssh1");
@


1.114
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.113 2015/08/21 03:42:19 djm Exp $ */
d724 1
a724 1
		    "[%s] failed - POSSIBLE BREAK-IN ATTEMPT!", name, ntop);
d739 1
a739 2
		    "map back to the address - POSSIBLE BREAK-IN ATTEMPT!",
		    ntop, name);
@


1.113
log
@fix inverted logic that broke PermitRootLogin;
reported by Mantas Mikulenas; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.112 2015/08/06 14:53:21 deraadt Exp $ */
d28 1
d41 1
d86 1
d122 2
a123 2
		hostname = get_canonical_hostname(options.use_dns);
		ipaddr = get_remote_ipaddr();
d208 1
d235 2
a236 2
	    get_remote_ipaddr(),
	    get_remote_port(),
d247 2
d253 2
a254 2
	    get_remote_ipaddr(),
	    get_remote_port(),
d266 2
d284 2
a285 1
	logit("ROOT LOGIN REFUSED FROM %.200s", get_remote_ipaddr());
d525 1
d536 2
a537 2
		logit("Invalid user %.100s from %.100s",
		    user, get_remote_ipaddr());
d654 111
@


1.112
log
@add prohibit-password as a synonymn for without-password, since the
without-password is causing too many questions.  Harden it to ban all
but pubkey, hostbased, and GSSAPI auth (when the latter is enabled)
from djm, ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.111 2015/05/01 04:17:51 djm Exp $ */
d266 1
a266 1
		    strcmp(method, "gssapi-with-mic"))
@


1.112.4.1
log
@MFC, original commit by djm@@

"fix inverted logic that broke PermitRootLogin;
reported by Mantas Mikulenas; ok markus@@"
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.112 2015/08/06 14:53:21 deraadt Exp $ */
d266 1
a266 1
		    strcmp(method, "gssapi-with-mic") == 0)
@


1.111
log
@make handling of AuthorizedPrincipalsFile=none more consistent
with other =none options; bz#2288 from Jakub Jelen; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.110 2015/02/25 17:29:38 djm Exp $ */
d264 3
a266 1
		if (strcmp(method, "password") != 0)
@


1.110
log
@don't leak validity of user in "too many authentication failures"
disconnect message; reported by Sebastian Reitenbach
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.109 2015/01/20 23:14:00 deraadt Exp $ */
d312 1
a312 2
	if (options.authorized_principals_file == NULL ||
	    strcasecmp(options.authorized_principals_file, "none") == 0)
@


1.109
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.108 2014/12/21 22:27:56 djm Exp $ */
d243 1
a243 1
	packet_disconnect("Too many authentication failures for "
d250 1
@


1.108
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.107 2014/12/04 02:24:32 djm Exp $ */
a27 1
#include <sys/param.h>
d39 1
d288 1
a288 1
	char *file, ret[MAXPATHLEN];
d380 1
a380 1
	char buf[MAXPATHLEN], homedir[MAXPATHLEN];
@


1.107
log
@add RevokedHostKeys option for the client

Allow textfile or KRL-based revocation of hostkeys.
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.106 2014/07/15 15:54:14 millert Exp $ */
d555 2
a556 1
	if ((fp = sshkey_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX)) == NULL) {
@


1.106
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.105 2014/07/03 11:16:55 djm Exp $ */
d60 2
a61 1
#include "krl.h"
d550 2
a551 2
#ifdef WITH_OPENSSL
	char *key_fp;
d555 8
a562 1
	switch (ssh_krl_file_contains_key(options.revoked_keys_file, key)) {
d564 5
a568 3
		return 0;	/* Not revoked */
	case -2:
		break;		/* Not a KRL */
d570 4
a573 1
		goto revoked;
d575 7
a581 24
#endif
	debug3("%s: treating %s as a key list", __func__,
	    options.revoked_keys_file);
	switch (key_in_file(key, options.revoked_keys_file, 0)) {
	case 0:
		/* key not revoked */
		return 0;
	case -1:
		/* Error opening revoked_keys_file: refuse all keys */
		error("Revoked keys file is unreadable: refusing public key "
		    "authentication");
		return 1;
#ifdef WITH_OPENSSL
	case 1:
 revoked:
		/* Key revoked */
		key_fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
		error("WARNING: authentication attempt with a revoked "
		    "%s key %s ", key_type(key), key_fp);
		free(key_fp);
		return 1;
#endif
	}
	fatal("key_in_file returned junk");
@


1.105
log
@make the "Too many authentication failures" message include the
user, source address, port and protocol in a format similar to the
authentication success / failure messages; bz#2199, ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.104 2014/04/29 18:01:49 markus Exp $ */
d46 1
a53 1
#include "misc.h"
@


1.104
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.103 2013/05/19 02:42:42 djm Exp $ */
d237 13
@


1.103
log
@Standardise logging of supplemental information during userauth. Keys
and ruser is now logged in the auth success/failure message alongside
the local username, remote host/port and protocol in use. Certificates
contents and CA are logged too.

Pushing all logging onto a single line simplifies log analysis as it is
no longer necessary to relate information scattered across multiple log
entries. "I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.102 2013/05/17 00:13:13 djm Exp $ */
d536 1
d549 1
d561 1
d570 1
@


1.102
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.101 2013/02/06 00:22:21 dtucker Exp $ */
d61 1
d184 17
d202 1
a202 1
    const char *method, const char *submethod, const char *info)
d224 1
a224 1
	authlog("%s %s%s%s for %s%.100s from %.200s port %d%s",
d232 5
a236 1
	    info);
@


1.101
log
@Fix comment, from jfree.e1 at gmail
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.100 2013/01/17 23:00:01 djm Exp $ */
d102 1
a102 1
			xfree(shell);
d109 1
a109 1
			xfree(shell);
d112 1
a112 1
		xfree(shell);
d268 1
a268 1
	xfree(file);
d310 1
a310 1
		xfree(user_hostfile);
d543 1
a543 1
		xfree(key_fp);
d574 1
a574 1
		xfree(msg);
@


1.100
log
@add support for Key Revocation Lists (KRLs). These are a compact way to
represent lists of revoked keys and certificates, taking as little as
a single bit of incremental cost to revoke a certificate by serial number.
KRLs are loaded via the existing RevokedKeys sshd_config option.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.99 2012/12/14 05:26:43 dtucker Exp $ */
d334 1
a334 1
 * Takes an the file name, its stat information (preferably from fstat() to
@


1.99
log
@use correct string in error message; from rustybsd at gmx.fr
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.98 2012/12/02 20:34:09 djm Exp $ */
d60 1
d518 10
a527 1

d538 1
@


1.98
log
@Fixes logging of partial authentication when privsep is enabled
Previously, we recorded "Failed xxx" since we reset authenticated before
calling auth_log() in auth2.c. This adds an explcit "Partial" state.

Add a "submethod" to auth_log() to report which submethod is used
for keyboard-interactive.

Fix multiple authentication when one of the methods is
keyboard-interactive.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.97 2012/10/30 21:29:54 djm Exp $ */
a406 1
	char buf[MAXPATHLEN];
d412 1
a412 1
		    buf, strerror(errno));
@


1.97
log
@new sshd_config option AuthorizedKeysCommand to support fetching
authorized_keys from a command in addition to (or instead of) from
the filesystem. The command is run as the target server user unless
another specified via a new AuthorizedKeysCommandUser option.

patch originally by jchadima AT redhat.com, reworked by me; feedback
and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.96 2012/05/13 01:42:32 dtucker Exp $ */
d182 2
a183 1
auth_log(Authctxt *authctxt, int authenticated, char *method, char *info)
d200 2
d205 1
a205 1
	authlog("%s %s for %s%.100s from %.200s port %d%s",
d208 1
d220 1
a220 1
auth_root_allowed(char *method)
@


1.96
log
@Add "Match LocalAddress" and "Match LocalPort" to sshd and adjust tests
to match.  Feedback and ok djm@@ markus@@.
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.95 2012/04/11 13:17:54 djm Exp $ */
a321 1

d323 1
a323 1
 * Check a given file for security. This is defined as all components
d329 2
a330 1
 * Takes an open file descriptor, the file name, a uid and and
d335 3
a337 3
static int
secure_filename(FILE *f, const char *file, struct passwd *pw,
    char *err, size_t errlen)
a338 1
	uid_t uid = pw->pw_uid;
d344 2
a345 2
	if (realpath(file, buf) == NULL) {
		snprintf(err, errlen, "realpath %s failed: %s", file,
d349 1
a349 1
	if (realpath(pw->pw_dir, homedir) != NULL)
d352 6
a357 4
	/* check the open file to avoid races */
	if (fstat(fileno(f), &st) < 0 ||
	    (st.st_uid != 0 && st.st_uid != uid) ||
	    (st.st_mode & 022) != 0) {
d391 22
@


1.95
log
@Support "none" as an argument for AuthorizedPrincipalsFile to indicate
no file should be read.
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.94 2011/05/23 03:33:38 djm Exp $ */
d454 1
d456 2
a457 2
	parse_server_match_config(&options, user,
	    get_canonical_hostname(options.use_dns), get_remote_ipaddr());
@


1.94
log
@make secure_filename() spam debug logs less
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.93 2011/05/23 03:30:07 djm Exp $ */
d270 2
a271 1
	if (options.authorized_principals_file == NULL)
@


1.93
log
@allow AuthorizedKeysFile to specify multiple files, separated by spaces.
Bring back authorized_keys2 as a default search path (to avoid breaking
existing users of this file), but override this in sshd_config so it will
be no longer used on fresh installs. Maybe in 2015 we can remove it
entierly :)

feedback and ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.92 2011/05/11 04:47:06 djm Exp $ */
a368 1
		debug3("secure_filename: checking '%s'", buf);
d378 1
a378 3
		if (comparehome && strcmp(homedir, buf) == 0) {
			debug3("secure_filename: terminating check at '%s'",
			    buf);
d380 1
a380 1
		}
@


1.92
log
@remove support for authorized_keys2; it is a relic from the early days
of protocol v.2 support and has been undocumented for many years;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.91 2010/11/29 23:45:51 djm Exp $ */
d244 1
a244 1
static char *
a264 6
}

char *
authorized_keys_file(struct passwd *pw)
{
	return expand_authorized_keys(options.authorized_keys_file, pw);
@


1.91
log
@automatically order the hostkeys requested by the client based on
which hostkeys are already recorded in known_hosts. This avoids
hostkey warnings when connecting to servers with new ECDSA keys
that are preferred by default; with markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.90 2010/11/23 02:35:50 djm Exp $ */
a270 6
}

char *
authorized_keys_file2(struct passwd *pw)
{
	return expand_authorized_keys(options.authorized_keys_file2, pw);
@


1.90
log
@use strict_modes already passed as function argument over referencing
global options.strict_modes
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.89 2010/08/04 05:42:47 djm Exp $ */
a291 1
	Key *found;
d295 2
d298 3
a300 5
	/* Check if we know the host and its host key. */
	found = key_new(key_is_cert(key) ? KEY_UNSPEC : key->type);
	host_status = check_host_in_hostfile(sysfile, host, key, found, NULL);

	if (host_status != HOST_OK && userfile != NULL) {
d313 1
a313 2
			host_status = check_host_in_hostfile(user_hostfile,
			    host, key, found, NULL);
d318 11
a328 1
	key_free(found);
a329 2
	debug2("check_key_in_hostfiles: key %s for %s", host_status == HOST_OK ?
	    "ok" : "not found", host);
@


1.89
log
@enable certificates for hostbased authentication, from Iain Morgan;
"looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.88 2010/06/22 04:49:47 djm Exp $ */
d431 1
a431 1
	if (options.strict_modes &&
@


1.88
log
@queue auth debug messages for bad ownership or permissions on the user's
keyfiles. These messages will be sent after the user has successfully
authenticated (where our client will display them with LogLevel=debug).
bz#1554; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.87 2010/05/07 11:30:29 djm Exp $ */
d298 1
a298 1
	found = key_new(key->type);
@


1.87
log
@add some optional indirection to matching of principal names listed
in certificates. Currently, a certificate must include the a user's name
to be accepted for authentication. This change adds the ability to
specify a list of certificate principal names that are acceptable.

When authenticating using a CA trusted through ~/.ssh/authorized_keys,
this adds a new principals="name1[,name2,...]" key option.

For CAs listed through sshd_config's TrustedCAKeys option, a new config
option "AuthorizedPrincipalsFile" specifies a per-user file containing
the list of acceptable names.

If either option is absent, the current behaviour of requiring the
username to appear in principals continues to apply.

These options are useful for role accounts, disjoint account namespaces
and "user@@realm"-style naming policies in certificates.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.86 2010/03/05 02:58:11 djm Exp $ */
d310 2
d435 1
@


1.86
log
@make the warning for a revoked key louder and more noticable
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.85 2010/03/04 10:36:03 djm Exp $ */
d279 8
d398 3
a400 2
FILE *
auth_openkeyfile(const char *file, struct passwd *pw, int strict_modes)
a406 4
	/*
	 * Open the file containing the authorized keys
	 * Fail quietly if file does not exist
	 */
d408 2
a409 2
		if (errno != ENOENT)
			debug("Could not open keyfile '%s': %s", file,
d419 2
a420 2
		logit("User %s authorized keys %s is not a regular file",
		    pw->pw_name, file);
d437 14
@


1.85
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.84 2010/02/09 06:18:46 djm Exp $ */
d489 2
a490 1
		error("%s key %s is revoked", key_type(key), key_fp);
@


1.84
log
@unbreak ChrootDirectory+internal-sftp by skipping check for executable shell
when chrooting; reported by danh AT wzrd.com; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.83 2010/01/13 23:47:26 djm Exp $ */
d58 1
d466 28
@


1.83
log
@when using ChrootDirectory, make sure we test for the existence of the
user's shell inside the chroot; bz #1679, patch from alex AT rtfs.hu;
ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.82 2010/01/13 00:19:04 dtucker Exp $ */
a81 1
	char *shell, *tmp, *chroot_path;
d89 2
a90 2
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
d92 18
a109 23
	shell = xstrdup((pw->pw_shell[0] == '\0') ?
	    _PATH_BSHELL : pw->pw_shell);

	/*
	 * Amend shell if chroot is requested.
	 */
	if (options.chroot_directory != NULL &&
	    strcasecmp(options.chroot_directory, "none") != 0) {
		tmp = tilde_expand_filename(options.chroot_directory,
		    pw->pw_uid);
		chroot_path = percent_expand(tmp, "h", pw->pw_dir,
		    "u", pw->pw_name, (char *)NULL);
		xfree(tmp);
		xasprintf(&tmp, "%s/%s", chroot_path, shell);
		xfree(shell);
		shell = tmp;
		free(chroot_path);
	}

	/* deny if shell does not exists or is not executable */
	if (stat(shell, &st) != 0) {
		logit("User %.100s not allowed because shell %.100s does not exist",
		    pw->pw_name, shell);
a110 8
		return 0;
	}
	if (S_ISREG(st.st_mode) == 0 ||
	    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {
		logit("User %.100s not allowed because shell %.100s is not executable",
		    pw->pw_name, shell);
		xfree(shell);
		return 0;
a111 1
	xfree(shell);
@


1.82
log
@Fix a couple of typos/mispellings in comments
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.81 2010/01/10 07:15:56 dtucker Exp $ */
d82 1
a82 1
	char *shell;
d93 18
a110 1
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;
d116 1
d123 1
d126 1
@


1.81
log
@Output a debug if we can't open an existing keyfile.  bz#1694, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.80 2008/11/04 07:58:09 djm Exp $ */
d368 1
a368 1
		/* If are passed the homedir then we can stop */
@


1.80
log
@need unistd.h for close() prototype
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.79 2008/07/02 12:03:51 dtucker Exp $ */
d396 4
a399 1
	if ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1)
d401 1
@


1.79
log
@Merge duplicate host key file checks, based in part on a patch from Rob
Holland via bz #1348 .  Also checks for non-regular files during protocol
1 RSA auth.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.78 2007/09/21 08:15:29 djm Exp $ */
d39 1
@


1.78
log
@unifdef -DBSD_AUTH
unifdef -USKEY

These options have been in use for some years;
ok markus@@ "no objection" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.77 2007/08/23 02:55:51 djm Exp $ */
d31 1
d323 1
a323 1
int
d381 40
@


1.77
log
@missed include bits from last commit
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.76 2007/08/23 02:49:43 djm Exp $ */
a385 1
#ifdef BSD_AUTH
a386 1
#endif
a403 1
#ifdef BSD_AUTH
a410 1
#endif
@


1.76
log
@unifdef HAVE_LOGIN_CAP; ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.75 2006/08/03 03:34:41 deraadt Exp $ */
d32 1
@


1.75
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.74 2006/08/01 23:22:47 stevesk Exp $ */
a383 1
#ifdef HAVE_LOGIN_CAP
a387 1
#endif
a400 1
#ifdef HAVE_LOGIN_CAP
a412 1
#endif
@


1.74
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.73 2006/07/26 02:35:17 stevesk Exp $ */
a25 2
#include "includes.h"

d42 1
d44 2
a48 2
#include "buffer.h"
#include "bufaux.h"
a50 1
#include "bufaux.h"
d52 3
@


1.73
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.72 2006/07/22 20:48:22 stevesk Exp $ */
d37 1
@


1.72
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.71 2006/07/12 11:34:58 dtucker Exp $ */
d30 1
@


1.71
log
@Add support for conditional directives to sshd_config via a "Match" keyword,
which works similarly to the "Host" directive in ssh_config.

Lines after a Match line override the default set in the main section
if the condition on the Match line is true, eg

AllowTcpForwarding yes
Match User anoncvs
        AllowTcpForwarding no

will allow port forwarding by all users except "anoncvs".

Currently only a very small subset of directives are supported.

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.70 2006/07/11 20:07:25 stevesk Exp $ */
d36 1
@


1.70
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.69 2006/07/10 16:37:36 stevesk Exp $ */
d387 3
@


1.69
log
@move #include <stdarg.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.68 2006/07/06 16:03:53 stevesk Exp $ */
d31 1
@


1.68
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.67 2006/03/30 11:40:21 dtucker Exp $ */
d34 1
@


1.67
log
@Prevent duplicate log messages when privsep=yes; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth.c,v 1.66 2006/03/25 13:17:01 djm Exp $ */
d33 1
@


1.66
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d48 1
d52 1
d170 3
@


1.65
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.64
log
@in a switch (), break after return or goto is stupid
@
text
@d225 2
a226 1
	char *file, *ret;
d238 2
a239 4
	ret = xmalloc(MAXPATHLEN);
	if (strlcpy(ret, pw->pw_dir, MAXPATHLEN) >= MAXPATHLEN ||
	    strlcat(ret, "/", MAXPATHLEN) >= MAXPATHLEN ||
	    strlcat(ret, file, MAXPATHLEN) >= MAXPATHLEN)
a240 1

d242 1
a242 1
	return (ret);
@


1.63
log
@RCSID() can die
@
text
@a198 1
		break;
@


1.62
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@a25 1
RCSID("$OpenBSD: auth.c,v 1.61 2006/02/08 12:15:27 stevesk Exp $");
@


1.62.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth.c,v 1.75 2006/08/03 03:34:41 deraadt Exp $ */
d25 3
a29 1
#include <sys/param.h>
a30 1
#include <errno.h>
a32 4
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
a37 1
#include "buffer.h"
a38 2
#include "key.h"
#include "hostfile.h"
d42 2
d46 1
a47 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
a50 1
extern int use_privsep;
a168 3
	if (use_privsep && !mm_is_monitor() && !authctxt->postponed)
		return;

d200 1
d227 1
a227 2
	char *file, ret[MAXPATHLEN];
	int i;
d239 4
a242 2
	i = snprintf(ret, sizeof(ret), "%s/%s", pw->pw_dir, file);
	if (i < 0 || (size_t)i >= sizeof(ret))
d244 1
d246 1
a246 1
	return (xstrdup(ret));
a381 3

	parse_server_match_config(&options, user,
	    get_canonical_hostname(options.use_dns), get_remote_ipaddr());
@


1.61
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d26 4
a29 1
RCSID("$OpenBSD: auth.c,v 1.60 2005/06/17 02:44:32 djm Exp $");
@


1.60
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.59 2005/06/06 11:20:36 djm Exp $");
d29 1
@


1.60.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth.c,v 1.75 2006/08/03 03:34:41 deraadt Exp $ */
d25 2
a26 3
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
a27 1
#include <errno.h>
a28 5
#include <paths.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
a33 1
#include "buffer.h"
a34 2
#include "key.h"
#include "hostfile.h"
d38 2
d42 1
a43 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
a46 1
extern int use_privsep;
a164 3
	if (use_privsep && !mm_is_monitor() && !authctxt->postponed)
		return;

d196 1
d223 1
a223 2
	char *file, ret[MAXPATHLEN];
	int i;
d235 4
a238 2
	i = snprintf(ret, sizeof(ret), "%s/%s", pw->pw_dir, file);
	if (i < 0 || (size_t)i >= sizeof(ret))
d240 1
d242 1
a242 1
	return (xstrdup(ret));
a377 3

	parse_server_match_config(&options, user,
	    get_canonical_hostname(options.use_dns), get_remote_ipaddr());
@


1.59
log
@introduce a generic %foo expansion function. replace existing % expansion and
add expansion to ControlPath; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.58 2005/03/14 11:44:42 dtucker Exp $");
d67 1
a67 1
	int i;
@


1.58
log
@Populate host for log message for logins denied by AllowUsers and DenyUsers.
(bz #999); ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.57 2005/01/22 08:17:59 dtucker Exp $");
d220 2
a221 2
char *
expand_filename(const char *filename, struct passwd *pw)
d223 1
a223 3
	Buffer buffer;
	char *file;
	const char *cp;
d225 2
a226 25
	/*
	 * Build the filename string in the buffer by making the appropriate
	 * substitutions to the given file name.
	 */
	buffer_init(&buffer);
	for (cp = filename; *cp; cp++) {
		if (cp[0] == '%' && cp[1] == '%') {
			buffer_append(&buffer, "%", 1);
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'h') {
			buffer_append(&buffer, pw->pw_dir, strlen(pw->pw_dir));
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'u') {
			buffer_append(&buffer, pw->pw_name,
			    strlen(pw->pw_name));
			cp++;
			continue;
		}
		buffer_append(&buffer, cp, 1);
	}
	buffer_append(&buffer, "\0", 1);
d232 8
a239 6
	file = xmalloc(MAXPATHLEN);
	cp = buffer_ptr(&buffer);
	if (*cp != '/')
		snprintf(file, MAXPATHLEN, "%s/%s", pw->pw_dir, cp);
	else
		strlcpy(file, cp, MAXPATHLEN);
d241 2
a242 2
	buffer_free(&buffer);
	return file;
d248 1
a248 1
	return expand_filename(options.authorized_keys_file, pw);
d254 1
a254 1
	return expand_filename(options.authorized_keys_file2, pw);
@


1.58.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.60 2005/06/17 02:44:32 djm Exp $");
d67 1
a67 1
	u_int i;
d220 2
a221 2
static char *
expand_authorized_keys(const char *filename, struct passwd *pw)
d223 3
a225 1
	char *file, *ret;
d227 25
a251 2
	file = percent_expand(filename, "h", pw->pw_dir,
	    "u", pw->pw_name, (char *)NULL);
d257 6
a262 8
	if (*file == '/')
		return (file);

	ret = xmalloc(MAXPATHLEN);
	if (strlcpy(ret, pw->pw_dir, MAXPATHLEN) >= MAXPATHLEN ||
	    strlcat(ret, "/", MAXPATHLEN) >= MAXPATHLEN ||
	    strlcat(ret, file, MAXPATHLEN) >= MAXPATHLEN)
		fatal("expand_authorized_keys: path too long");
d264 2
a265 2
	xfree(file);
	return (ret);
d271 1
a271 1
	return expand_authorized_keys(options.authorized_keys_file, pw);
d277 1
a277 1
	return expand_authorized_keys(options.authorized_keys_file2, pw);
@


1.57
log
@Log source of connections denied by AllowUsers, DenyUsers, AllowGroups and
DenyGroups.  bz #909, ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.56 2004/07/28 09:40:29 markus Exp $");
d92 2
a93 1
	if (options.num_deny_users > 0 || options.num_allow_users > 0) {
@


1.56
log
@more s/illegal/invalid/
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.55 2004/07/21 08:56:12 markus Exp $");
d102 3
a104 2
				logit("User %.100s not allowed because listed in DenyUsers",
				    pw->pw_name);
d116 2
a117 2
			logit("User %.100s not allowed because not listed in AllowUsers",
			    pw->pw_name);
d124 2
a125 2
			logit("User %.100s not allowed because not in any group",
			    pw->pw_name);
d134 3
a136 2
				logit("User %.100s not allowed because a group is listed in DenyGroups",
				    pw->pw_name);
d147 3
a149 2
				logit("User %.100s not allowed because none of user's groups are listed in AllowGroups",
				    pw->pw_name);
@


1.56.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.57 2005/01/22 08:17:59 dtucker Exp $");
d102 2
a103 3
				logit("User %.100s from %.100s not allowed "
				    "because listed in DenyUsers",
				    pw->pw_name, hostname);
d115 2
a116 2
			logit("User %.100s from %.100s not allowed because "
			    "not listed in AllowUsers", pw->pw_name, hostname);
d123 2
a124 2
			logit("User %.100s from %.100s not allowed because "
			    "not in any group", pw->pw_name, hostname);
d133 2
a134 3
				logit("User %.100s from %.100s not allowed "
				    "because a group is listed in DenyGroups",
				    pw->pw_name, hostname);
d145 2
a146 3
				logit("User %.100s from %.100s not allowed "
				    "because none of user's groups are listed "
				    "in AllowGroups", pw->pw_name, hostname);
@


1.56.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.58 2005/03/14 11:44:42 dtucker Exp $");
d92 1
a92 2
	if (options.num_deny_users > 0 || options.num_allow_users > 0 ||
	    options.num_deny_groups > 0 || options.num_allow_groups > 0) {
@


1.56.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.60 2005/06/17 02:44:32 djm Exp $");
d67 1
a67 1
	u_int i;
d220 2
a221 2
static char *
expand_authorized_keys(const char *filename, struct passwd *pw)
d223 3
a225 1
	char *file, *ret;
d227 25
a251 2
	file = percent_expand(filename, "h", pw->pw_dir,
	    "u", pw->pw_name, (char *)NULL);
d257 6
a262 8
	if (*file == '/')
		return (file);

	ret = xmalloc(MAXPATHLEN);
	if (strlcpy(ret, pw->pw_dir, MAXPATHLEN) >= MAXPATHLEN ||
	    strlcat(ret, "/", MAXPATHLEN) >= MAXPATHLEN ||
	    strlcat(ret, file, MAXPATHLEN) >= MAXPATHLEN)
		fatal("expand_authorized_keys: path too long");
d264 2
a265 2
	xfree(file);
	return (ret);
d271 1
a271 1
	return expand_authorized_keys(options.authorized_keys_file, pw);
d277 1
a277 1
	return expand_authorized_keys(options.authorized_keys_file2, pw);
@


1.55
log
@s/Illegal user/Invalid user/; many requests; ok djm, millert, niklas, miod, ...
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.54 2004/05/23 23:59:53 dtucker Exp $");
d176 1
a176 1
	    authctxt->valid ? "" : "illegal user ",
@


1.54
log
@Add MaxAuthTries sshd config option; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.53 2004/05/11 19:01:43 deraadt Exp $");
d400 1
a400 1
		logit("Illegal user %.100s from %.100s",
@


1.53
log
@improve some code lint did not like; djm millert ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.52 2004/05/08 00:01:37 deraadt Exp $");
d164 1
a164 1
	    authctxt->failures >= AUTH_FAIL_LOG ||
@


1.52
log
@make two tiny header files go away; djm ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.51 2003/11/21 11:57:02 djm Exp $");
d476 2
a477 2
	fake.pw_uid = -1;
	fake.pw_gid = -1;
@


1.51
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.50 2003/09/23 20:17:11 markus Exp $");
a40 1
#include "tildexpand.h"
@


1.51.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.56 2004/07/28 09:40:29 markus Exp $");
d41 1
d165 1
a165 1
	    authctxt->failures >= options.max_authtries / 2 ||
d177 1
a177 1
	    authctxt->valid ? "" : "invalid user ",
d401 1
a401 1
		logit("Invalid user %.100s from %.100s",
d477 2
a478 2
	fake.pw_uid = (uid_t)-1;
	fake.pw_gid = (gid_t)-1;
@


1.51.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.57 2005/01/22 08:17:59 dtucker Exp $");
d102 2
a103 3
				logit("User %.100s from %.100s not allowed "
				    "because listed in DenyUsers",
				    pw->pw_name, hostname);
d115 2
a116 2
			logit("User %.100s from %.100s not allowed because "
			    "not listed in AllowUsers", pw->pw_name, hostname);
d123 2
a124 2
			logit("User %.100s from %.100s not allowed because "
			    "not in any group", pw->pw_name, hostname);
d133 2
a134 3
				logit("User %.100s from %.100s not allowed "
				    "because a group is listed in DenyGroups",
				    pw->pw_name, hostname);
d145 2
a146 3
				logit("User %.100s from %.100s not allowed "
				    "because none of user's groups are listed "
				    "in AllowGroups", pw->pw_name, hostname);
@


1.50
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.49 2003/08/26 09:58:43 markus Exp $");
d475 1
a475 1
	    "$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";	
@


1.49
log
@fix passwd auth for 'username leaks via timing'; with djm@@, original patches from solar
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.48 2003/06/02 09:17:34 markus Exp $");
a153 8
}

Authctxt *
authctxt_new(void)
{
	Authctxt *authctxt = xmalloc(sizeof(*authctxt));
	memset(authctxt, 0, sizeof(*authctxt));
	return authctxt;
@


1.49.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.51 2003/11/21 11:57:02 djm Exp $");
d156 8
d483 1
a483 1
	    "$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";
@


1.49.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.56 2004/07/28 09:40:29 markus Exp $");
d41 1
d165 1
a165 1
	    authctxt->failures >= options.max_authtries / 2 ||
d177 1
a177 1
	    authctxt->valid ? "" : "invalid user ",
d401 1
a401 1
		logit("Invalid user %.100s from %.100s",
d477 2
a478 2
	fake.pw_uid = (uid_t)-1;
	fake.pw_gid = (gid_t)-1;
@


1.48
log
@deprecate VerifyReverseMapping since it's dangerous if combined
with IP based access control as noted by Mike Harding; replace with
a UseDNS option, UseDNS is on by default and includes the
VerifyReverseMapping check; with itojun@@, provos@@, jakob@@ and deraadt@@
ok deraadt@@, djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.47 2003/04/08 20:21:28 itojun Exp $");
d473 19
@


1.47
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.46 2002/11/04 10:07:53 markus Exp $");
d94 1
a94 1
		hostname = get_canonical_hostname(options.verify_reverse_mapping);
@


1.46
log
@don't compare against pw_home if realpath fails for pw_home (seen on AFS); ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.45 2002/09/20 18:41:29 stevesk Exp $");
d82 1
a82 1
		log("User %.100s not allowed because shell %.100s does not exist",
d88 1
a88 1
		log("User %.100s not allowed because shell %.100s is not executable",
d103 1
a103 1
				log("User %.100s not allowed because listed in DenyUsers",
d116 1
a116 1
			log("User %.100s not allowed because not listed in AllowUsers",
d124 1
a124 1
			log("User %.100s not allowed because not in any group",
d134 1
a134 1
				log("User %.100s not allowed because a group is listed in DenyGroups",
d146 1
a146 1
				log("User %.100s not allowed because none of user's groups are listed in AllowGroups",
d175 1
a175 1
		authlog = log;
d208 1
a208 1
			log("Root login accepted for forced command.");
d213 1
a213 1
	log("ROOT LOGIN REFUSED FROM %.200s", get_remote_ipaddr());
d305 1
a305 1
			log("Authentication refused for %.100s: "
d409 1
a409 1
		log("Illegal user %.100s from %.100s",
@


1.46.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.49 2003/08/26 09:58:43 markus Exp $");
d82 1
a82 1
		logit("User %.100s not allowed because shell %.100s does not exist",
d88 1
a88 1
		logit("User %.100s not allowed because shell %.100s is not executable",
d94 1
a94 1
		hostname = get_canonical_hostname(options.use_dns);
d103 1
a103 1
				logit("User %.100s not allowed because listed in DenyUsers",
d116 1
a116 1
			logit("User %.100s not allowed because not listed in AllowUsers",
d124 1
a124 1
			logit("User %.100s not allowed because not in any group",
d134 1
a134 1
				logit("User %.100s not allowed because a group is listed in DenyGroups",
d146 1
a146 1
				logit("User %.100s not allowed because none of user's groups are listed in AllowGroups",
d175 1
a175 1
		authlog = logit;
d208 1
a208 1
			logit("Root login accepted for forced command.");
d213 1
a213 1
	logit("ROOT LOGIN REFUSED FROM %.200s", get_remote_ipaddr());
d305 1
a305 1
			logit("Authentication refused for %.100s: "
d409 1
a409 1
		logit("Illegal user %.100s from %.100s",
a472 19
}

struct passwd *
fakepw(void)
{
	static struct passwd fake;

	memset(&fake, 0, sizeof(fake));
	fake.pw_name = "NOUSER";
	fake.pw_passwd =
	    "$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";	
	fake.pw_gecos = "NOUSER";
	fake.pw_uid = -1;
	fake.pw_gid = -1;
	fake.pw_class = "";
	fake.pw_dir = "/nonexist";
	fake.pw_shell = "/nonexist";

	return (&fake);
@


1.46.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.51 2003/11/21 11:57:02 djm Exp $");
d156 8
d483 1
a483 1
	    "$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";
@


1.45
log
@log illegal user here for missing privsep case (ssh2).
this is executed in the monitor. ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.44 2002/08/08 23:54:52 stevesk Exp $");
d343 1
d351 2
a352 5
	if (realpath(pw->pw_dir, homedir) == NULL) {
		snprintf(err, errlen, "realpath %s failed: %s", pw->pw_dir,
		    strerror(errno));
		return -1;
	}
d381 1
a381 1
		if (strcmp(homedir, buf) == 0) {
@


1.45.2.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.46 2002/11/04 10:07:53 markus Exp $");
a342 1
	int comparehome = 0;
d350 5
a354 2
	if (realpath(pw->pw_dir, homedir) != NULL)
		comparehome = 1;
d383 1
a383 1
		if (comparehome && strcmp(homedir, buf) == 0) {
@


1.45.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.49 2003/08/26 09:58:43 markus Exp $");
d82 1
a82 1
		logit("User %.100s not allowed because shell %.100s does not exist",
d88 1
a88 1
		logit("User %.100s not allowed because shell %.100s is not executable",
d94 1
a94 1
		hostname = get_canonical_hostname(options.use_dns);
d103 1
a103 1
				logit("User %.100s not allowed because listed in DenyUsers",
d116 1
a116 1
			logit("User %.100s not allowed because not listed in AllowUsers",
d124 1
a124 1
			logit("User %.100s not allowed because not in any group",
d134 1
a134 1
				logit("User %.100s not allowed because a group is listed in DenyGroups",
d146 1
a146 1
				logit("User %.100s not allowed because none of user's groups are listed in AllowGroups",
d175 1
a175 1
		authlog = logit;
d208 1
a208 1
			logit("Root login accepted for forced command.");
d213 1
a213 1
	logit("ROOT LOGIN REFUSED FROM %.200s", get_remote_ipaddr());
d305 1
a305 1
			logit("Authentication refused for %.100s: "
d409 1
a409 1
		logit("Illegal user %.100s from %.100s",
a472 19
}

struct passwd *
fakepw(void)
{
	static struct passwd fake;

	memset(&fake, 0, sizeof(fake));
	fake.pw_name = "NOUSER";
	fake.pw_passwd =
	    "$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";	
	fake.pw_gecos = "NOUSER";
	fake.pw_uid = -1;
	fake.pw_gid = -1;
	fake.pw_class = "";
	fake.pw_dir = "/nonexist";
	fake.pw_shell = "/nonexist";

	return (&fake);
@


1.44
log
@typo in comment
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.43 2002/05/17 14:27:55 millert Exp $");
d410 6
a415 1
	if (pw == NULL || !allowed_user(pw))
@


1.43
log
@Fix typo/thinko.  Pass in as to auth_approval(), not NULL.
Closes PR 2659.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.42 2002/05/13 20:44:58 markus Exp $");
d326 1
a326 1
 * of the path to the file must either be owned by either the owner of
@


1.42
log
@move the packet_send_debug handling from auth-options.c to auth.c; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.41 2002/03/19 15:31:47 markus Exp $");
d419 1
a419 1
	    auth_approval(NULL, lc, pw->pw_name, "ssh") <= 0) {
@


1.41
log
@check for NULL; from provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.40 2002/03/19 14:27:39 markus Exp $");
d43 2
d49 4
d430 40
@


1.41.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.42 2002/05/13 20:44:58 markus Exp $");
a42 2
#include "bufaux.h"
#include "packet.h"
a46 4
/* Debugging messages */
Buffer auth_debug;
int auth_debug_init;

a423 40
}

void
auth_debug_add(const char *fmt,...)
{
	char buf[1024];
	va_list args;

	if (!auth_debug_init)
		return;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);
	buffer_put_cstring(&auth_debug, buf);
}

void
auth_debug_send(void)
{
	char *msg;

	if (!auth_debug_init)
		return;
	while (buffer_len(&auth_debug)) {
		msg = buffer_get_string(&auth_debug, NULL);
		packet_send_debug("%s", msg);
		xfree(msg);
	}
}

void
auth_debug_reset(void)
{
	if (auth_debug_init)
		buffer_clear(&auth_debug);
	else {
		buffer_init(&auth_debug);
		auth_debug_init = 1;
	}
@


1.41.2.2
log
@Update to OpenSSH-3.2.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.43 2002/05/17 14:27:55 millert Exp $");
d419 1
a419 1
	    auth_approval(as, lc, pw->pw_name, "ssh") <= 0) {
@


1.41.2.3
log
@Pull in OpenSSH-3.4
@
text
@@


1.41.2.4
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.45 2002/09/20 18:41:29 stevesk Exp $");
d326 1
a326 1
 * of the path to the file must be owned by either the owner of
d410 1
a410 6
	if (pw == NULL) {
		log("Illegal user %.100s from %.100s",
		    user, get_remote_ipaddr());
		return (NULL);
	}
	if (!allowed_user(pw))
@


1.41.2.5
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.46 2002/11/04 10:07:53 markus Exp $");
a342 1
	int comparehome = 0;
d350 5
a354 2
	if (realpath(pw->pw_dir, homedir) != NULL)
		comparehome = 1;
d383 1
a383 1
		if (comparehome && strcmp(homedir, buf) == 0) {
@


1.40
log
@make getpwnamallow() allways call pwcopy()
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.39 2002/03/19 10:49:35 markus Exp $");
d421 3
a423 1
	return (pwcopy(pw));
@


1.39
log
@KNF whitespace
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.38 2002/03/18 03:41:08 provos Exp $");
d42 1
d421 1
a421 1
	return (pw);
@


1.38
log
@move auth_approval into getpwnamallow with help from millert@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.37 2002/03/17 20:25:56 provos Exp $");
d94 1
a94 1
 			if (match_user(pw->pw_name, hostname, ipaddr,
d96 2
a97 2
 				log("User %.100s not allowed because listed in DenyUsers",
 				    pw->pw_name);
d104 1
a104 1
 			if (match_user(pw->pw_name, hostname, ipaddr,
@


1.37
log
@getpwnamallow returns struct passwd * only if user valid; okay markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.36 2002/03/15 11:00:38 itojun Exp $");
d394 6
d403 11
a413 1
	if (pw != NULL && !allowed_user(pw))
d415 5
a419 1

@


1.36
log
@fix file type checking (use S_ISREG).  ok by markus
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.35 2002/03/01 13:12:10 markus Exp $");
d389 12
@


1.35
log
@undo the 'delay hostname lookup' change
match.c must not use compress.c (via canonhost.c/packet.c)
thanks to wilfried@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.34 2002/02/28 20:56:00 stevesk Exp $");
d79 2
a80 1
	if (!((st.st_mode & S_IFREG) && (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)))) {
@


1.34
log
@log user not allowed details, from dwd@@bell-labs.com; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.33 2002/02/28 19:36:28 stevesk Exp $");
d59 1
d85 5
d93 1
a93 1
			if (match_user(pw->pw_name, options.verify_reverse_mapping,
d103 1
a103 1
			if (match_user(pw->pw_name, options.verify_reverse_mapping,
@


1.33
log
@delay hostname lookup until we see a ``@@'' in DenyUsers and AllowUsers
for sshd -u0; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.32 2002/01/29 14:32:03 markus Exp $");
d73 3
a75 1
	if (stat(shell, &st) != 0)
d77 4
a80 1
	if (!((st.st_mode & S_IFREG) && (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP))))
d82 1
d88 3
a90 1
			    options.deny_users[i]))
d92 1
d101 3
a103 1
		if (i >= options.num_allow_users)
d105 1
d109 3
a111 1
		if (ga_init(pw->pw_name, pw->pw_gid) == 0)
d113 1
d120 2
d132 2
@


1.32
log
@s/ReverseMappingCheck/VerifyReverseMapping/ and avoid confusion; ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.31 2001/12/19 07:18:56 deraadt Exp $");
a58 1
	const char *hostname = NULL, *ipaddr = NULL;
a77 5
	if (options.num_deny_users > 0 || options.num_allow_users > 0) {
		hostname = get_canonical_hostname(options.verify_reverse_mapping);
		ipaddr = get_remote_ipaddr();
	}

d81 1
a81 1
			if (match_user(pw->pw_name, hostname, ipaddr,
d88 1
a88 1
			if (match_user(pw->pw_name, hostname, ipaddr,
@


1.31
log
@basic KNF done while i was looking for something else
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.30 2001/11/17 19:14:34 stevesk Exp $");
d80 1
a80 1
		hostname = get_canonical_hostname(options.reverse_mapping_check);
@


1.30
log
@enum/int type cleanup where it made sense to do so; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.29 2001/11/08 20:02:24 markus Exp $");
d223 1
a223 1
			     strlen(pw->pw_name));
d277 1
a277 1
		     (st.st_mode & 022) != 0)) {
d350 1
a350 1
			snprintf(err, errlen, 
@


1.29
log
@don't print ROOT in CAPS for the authentication messages, i.e.
	Accepted publickey for ROOT from 127.0.0.1 port 42734 ssh2
becomes
	Accepted publickey for root from 127.0.0.1 port 42734 ssh2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.28 2001/10/03 10:01:20 markus Exp $");
d266 1
a266 1
	int host_status;
@


1.28
log
@use realpath() for homedir, too. from jinmei@@isl.rdc.toshiba.co.jp
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.27 2001/07/11 18:26:15 markus Exp $");
d159 1
a159 1
	    authctxt->valid && authctxt->pw->pw_uid == 0 ? "ROOT" : authctxt->user,
@


1.28.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.29 2001/11/08 20:02:24 markus Exp $");
d159 1
a159 1
	    authctxt->user,
@


1.28.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.35 2002/03/01 13:12:10 markus Exp $");
d74 1
a74 3
	if (stat(shell, &st) != 0) {
		log("User %.100s not allowed because shell %.100s does not exist",
		    pw->pw_name, shell);
d76 1
a76 4
	}
	if (!((st.st_mode & S_IFREG) && (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)))) {
		log("User %.100s not allowed because shell %.100s is not executable",
		    pw->pw_name, shell);
a77 1
	}
d80 1
a80 1
		hostname = get_canonical_hostname(options.verify_reverse_mapping);
d87 2
a88 4
 			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.deny_users[i])) {
 				log("User %.100s not allowed because listed in DenyUsers",
 				    pw->pw_name);
a89 1
			}
d94 1
a94 1
 			if (match_user(pw->pw_name, hostname, ipaddr,
d98 1
a98 3
		if (i >= options.num_allow_users) {
			log("User %.100s not allowed because not listed in AllowUsers",
			    pw->pw_name);
a99 1
		}
d103 1
a103 3
		if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
			log("User %.100s not allowed because not in any group",
			    pw->pw_name);
a104 1
		}
a110 2
				log("User %.100s not allowed because a group is listed in DenyGroups",
				    pw->pw_name);
a120 2
				log("User %.100s not allowed because none of user's groups are listed in AllowGroups",
				    pw->pw_name);
d223 1
a223 1
			    strlen(pw->pw_name));
d266 1
a266 1
	HostStatus host_status;
d277 1
a277 1
		    (st.st_mode & 022) != 0)) {
d350 1
a350 1
			snprintf(err, errlen,
@


1.28.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.42 2002/05/13 20:44:58 markus Exp $");
a41 3
#include "misc.h"
#include "bufaux.h"
#include "packet.h"
a45 4
/* Debugging messages */
Buffer auth_debug;
int auth_debug_init;

d79 1
a79 2
	if (S_ISREG(st.st_mode) == 0 ||
	    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {
d93 1
a93 1
			if (match_user(pw->pw_name, hostname, ipaddr,
d95 2
a96 2
				log("User %.100s not allowed because listed in DenyUsers",
				    pw->pw_name);
d103 1
a103 1
			if (match_user(pw->pw_name, hostname, ipaddr,
a387 74
}

struct passwd *
getpwnamallow(const char *user)
{
#ifdef HAVE_LOGIN_CAP
	extern login_cap_t *lc;
#ifdef BSD_AUTH
	auth_session_t *as;
#endif
#endif
	struct passwd *pw;

	pw = getpwnam(user);
	if (pw == NULL || !allowed_user(pw))
		return (NULL);
#ifdef HAVE_LOGIN_CAP
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
		debug("unable to get login class: %s", user);
		return (NULL);
	}
#ifdef BSD_AUTH
	if ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||
	    auth_approval(NULL, lc, pw->pw_name, "ssh") <= 0) {
		debug("Approval failure for %s", user);
		pw = NULL;
	}
	if (as != NULL)
		auth_close(as);
#endif
#endif
	if (pw != NULL)
		return (pwcopy(pw));
	return (NULL);
}

void
auth_debug_add(const char *fmt,...)
{
	char buf[1024];
	va_list args;

	if (!auth_debug_init)
		return;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);
	buffer_put_cstring(&auth_debug, buf);
}

void
auth_debug_send(void)
{
	char *msg;

	if (!auth_debug_init)
		return;
	while (buffer_len(&auth_debug)) {
		msg = buffer_get_string(&auth_debug, NULL);
		packet_send_debug("%s", msg);
		xfree(msg);
	}
}

void
auth_debug_reset(void)
{
	if (auth_debug_init)
		buffer_clear(&auth_debug);
	else {
		buffer_init(&auth_debug);
		auth_debug_init = 1;
	}
@


1.28.2.4
log
@That long-delayed OpenSSH 3.2.3 update.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.43 2002/05/17 14:27:55 millert Exp $");
d419 1
a419 1
	    auth_approval(as, lc, pw->pw_name, "ssh") <= 0) {
@


1.28.2.5
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.45 2002/09/20 18:41:29 stevesk Exp $");
d326 1
a326 1
 * of the path to the file must be owned by either the owner of
d410 1
a410 6
	if (pw == NULL) {
		log("Illegal user %.100s from %.100s",
		    user, get_remote_ipaddr());
		return (NULL);
	}
	if (!allowed_user(pw))
@


1.27
log
@no need to call dirname(pw->pw_dir).
note that dirname(3) modifies its argument on some systems.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.26 2001/06/27 04:48:52 markus Exp $");
d314 1
a314 1
	char buf[MAXPATHLEN];
d323 5
d356 1
a356 1
		if (strcmp(pw->pw_dir, buf) == 0) {
@


1.26
log
@tridge@@samba.org
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.25 2001/06/25 17:54:48 provos Exp $");
a313 1
	char homedir[MAXPATHLEN];
a317 2
	strlcpy(homedir, dirname(pw->pw_dir), sizeof(homedir));

a332 2
	debug3("secure_filename: terminating check at '%s'", homedir);

a340 4
		/* If are passed the homedir then we can stop */
		if (strcmp(buf, homedir) == 0)
			break;

d350 6
@


1.25
log
@terminate secure_filename checking after checking homedir.  that way it
works on AFS.  okay markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.24 2001/06/23 00:20:57 markus Exp $");
d59 1
d79 5
d87 2
a88 1
			if (match_pattern(pw->pw_name, options.deny_users[i]))
d94 2
a95 1
			if (match_pattern(pw->pw_name, options.allow_users[i]))
@


1.24
log
@*known_hosts2 is obsolete for hostbased authentication and
only used for backward compat. merge ssh1/2 hostkey check
and move it to auth.c
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.23 2001/05/24 11:12:42 markus Exp $");
d302 2
a303 1
secure_filename(FILE *f, const char *file, uid_t uid, char *err, size_t errlen)
d305 2
d311 2
d328 2
d337 4
@


1.23
log
@fix comment; from jakob@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.22 2001/05/20 17:20:35 markus Exp $");
d40 2
d249 39
@


1.22
log
@configurable authorized_keys{,2} location; originally from peter@@; ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.21 2001/03/19 17:07:23 markus Exp $");
d251 1
a251 1
 * of the file or root and no directories must be world writable.
@


1.21
log
@undo /etc/shell and proto 2,1 change for openssh-2.5.2
@
text
@d26 3
a28 1
RCSID("$OpenBSD: auth.c,v 1.19 2001/03/02 18:54:31 deraadt Exp $");
d38 2
d177 129
@


1.21.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d26 1
a26 3
RCSID("$OpenBSD: auth.c,v 1.27 2001/07/11 18:26:15 markus Exp $");

#include <libgen.h>
a35 4
#include "buffer.h"
#include "bufaux.h"
#include "uidswap.h"
#include "tildexpand.h"
a52 1
	const char *hostname = NULL, *ipaddr = NULL;
a71 5
	if (options.num_deny_users > 0 || options.num_allow_users > 0) {
		hostname = get_canonical_hostname(options.reverse_mapping_check);
		ipaddr = get_remote_ipaddr();
	}

d75 1
a75 2
			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.deny_users[i]))
d81 1
a81 2
			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.allow_users[i]))
a172 176
	return 0;
}


/*
 * Given a template and a passwd structure, build a filename
 * by substituting % tokenised options. Currently, %% becomes '%',
 * %h becomes the home directory and %u the username.
 *
 * This returns a buffer allocated by xmalloc.
 */
char *
expand_filename(const char *filename, struct passwd *pw)
{
	Buffer buffer;
	char *file;
	const char *cp;

	/*
	 * Build the filename string in the buffer by making the appropriate
	 * substitutions to the given file name.
	 */
	buffer_init(&buffer);
	for (cp = filename; *cp; cp++) {
		if (cp[0] == '%' && cp[1] == '%') {
			buffer_append(&buffer, "%", 1);
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'h') {
			buffer_append(&buffer, pw->pw_dir, strlen(pw->pw_dir));
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'u') {
			buffer_append(&buffer, pw->pw_name,
			     strlen(pw->pw_name));
			cp++;
			continue;
		}
		buffer_append(&buffer, cp, 1);
	}
	buffer_append(&buffer, "\0", 1);

	/*
	 * Ensure that filename starts anchored. If not, be backward
	 * compatible and prepend the '%h/'
	 */
	file = xmalloc(MAXPATHLEN);
	cp = buffer_ptr(&buffer);
	if (*cp != '/')
		snprintf(file, MAXPATHLEN, "%s/%s", pw->pw_dir, cp);
	else
		strlcpy(file, cp, MAXPATHLEN);

	buffer_free(&buffer);
	return file;
}

char *
authorized_keys_file(struct passwd *pw)
{
	return expand_filename(options.authorized_keys_file, pw);
}

char *
authorized_keys_file2(struct passwd *pw)
{
	return expand_filename(options.authorized_keys_file2, pw);
}

/* return ok if key exists in sysfile or userfile */
HostStatus
check_key_in_hostfiles(struct passwd *pw, Key *key, const char *host,
    const char *sysfile, const char *userfile)
{
	Key *found;
	char *user_hostfile;
	struct stat st;
	int host_status;

	/* Check if we know the host and its host key. */
	found = key_new(key->type);
	host_status = check_host_in_hostfile(sysfile, host, key, found, NULL);

	if (host_status != HOST_OK && userfile != NULL) {
		user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
		if (options.strict_modes &&
		    (stat(user_hostfile, &st) == 0) &&
		    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		     (st.st_mode & 022) != 0)) {
			log("Authentication refused for %.100s: "
			    "bad owner or modes for %.200s",
			    pw->pw_name, user_hostfile);
		} else {
			temporarily_use_uid(pw);
			host_status = check_host_in_hostfile(user_hostfile,
			    host, key, found, NULL);
			restore_uid();
		}
		xfree(user_hostfile);
	}
	key_free(found);

	debug2("check_key_in_hostfiles: key %s for %s", host_status == HOST_OK ?
	    "ok" : "not found", host);
	return host_status;
}


/*
 * Check a given file for security. This is defined as all components
 * of the path to the file must either be owned by either the owner of
 * of the file or root and no directories must be group or world writable.
 *
 * XXX Should any specific check be done for sym links ?
 *
 * Takes an open file descriptor, the file name, a uid and and
 * error buffer plus max size as arguments.
 *
 * Returns 0 on success and -1 on failure
 */
int
secure_filename(FILE *f, const char *file, struct passwd *pw,
    char *err, size_t errlen)
{
	uid_t uid = pw->pw_uid;
	char buf[MAXPATHLEN];
	char *cp;
	struct stat st;

	if (realpath(file, buf) == NULL) {
		snprintf(err, errlen, "realpath %s failed: %s", file,
		    strerror(errno));
		return -1;
	}

	/* check the open file to avoid races */
	if (fstat(fileno(f), &st) < 0 ||
	    (st.st_uid != 0 && st.st_uid != uid) ||
	    (st.st_mode & 022) != 0) {
		snprintf(err, errlen, "bad ownership or modes for file %s",
		    buf);
		return -1;
	}

	/* for each component of the canonical path, walking upwards */
	for (;;) {
		if ((cp = dirname(buf)) == NULL) {
			snprintf(err, errlen, "dirname() failed");
			return -1;
		}
		strlcpy(buf, cp, sizeof(buf));

		debug3("secure_filename: checking '%s'", buf);
		if (stat(buf, &st) < 0 ||
		    (st.st_uid != 0 && st.st_uid != uid) ||
		    (st.st_mode & 022) != 0) {
			snprintf(err, errlen, 
			    "bad ownership or modes for directory %s", buf);
			return -1;
		}

		/* If are passed the homedir then we can stop */
		if (strcmp(pw->pw_dir, buf) == 0) {
			debug3("secure_filename: terminating check at '%s'",
			    buf);
			break;
		}
		/*
		 * dirname should always complete with a "/" path,
		 * but we can be paranoid and check for "." too
		 */
		if ((strcmp("/", buf) == 0) || (strcmp(".", buf) == 0))
			break;
	}
@


1.21.2.2
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.21.2.1 2001/09/27 19:03:54 jason Exp $");
d314 1
a314 1
	char buf[MAXPATHLEN], homedir[MAXPATHLEN];
a322 5
	if (realpath(pw->pw_dir, homedir) == NULL) {
		snprintf(err, errlen, "realpath %s failed: %s", pw->pw_dir,
		    strerror(errno));
		return -1;
	}
d351 1
a351 1
		if (strcmp(homedir, buf) == 0) {
@


1.21.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.21.2.2 2001/11/15 00:15:19 miod Exp $");
d159 1
a159 1
	    authctxt->user,
@


1.21.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.35 2002/03/01 13:12:10 markus Exp $");
d74 1
a74 3
	if (stat(shell, &st) != 0) {
		log("User %.100s not allowed because shell %.100s does not exist",
		    pw->pw_name, shell);
d76 1
a76 4
	}
	if (!((st.st_mode & S_IFREG) && (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)))) {
		log("User %.100s not allowed because shell %.100s is not executable",
		    pw->pw_name, shell);
a77 1
	}
d80 1
a80 1
		hostname = get_canonical_hostname(options.verify_reverse_mapping);
d87 2
a88 4
 			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.deny_users[i])) {
 				log("User %.100s not allowed because listed in DenyUsers",
 				    pw->pw_name);
a89 1
			}
d94 1
a94 1
 			if (match_user(pw->pw_name, hostname, ipaddr,
d98 1
a98 3
		if (i >= options.num_allow_users) {
			log("User %.100s not allowed because not listed in AllowUsers",
			    pw->pw_name);
a99 1
		}
d103 1
a103 3
		if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
			log("User %.100s not allowed because not in any group",
			    pw->pw_name);
a104 1
		}
a110 2
				log("User %.100s not allowed because a group is listed in DenyGroups",
				    pw->pw_name);
a120 2
				log("User %.100s not allowed because none of user's groups are listed in AllowGroups",
				    pw->pw_name);
d223 1
a223 1
			    strlen(pw->pw_name));
d266 1
a266 1
	HostStatus host_status;
d277 1
a277 1
		    (st.st_mode & 022) != 0)) {
d350 1
a350 1
			snprintf(err, errlen,
@


1.21.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.43 2002/05/17 14:27:55 millert Exp $");
a41 3
#include "misc.h"
#include "bufaux.h"
#include "packet.h"
a45 4
/* Debugging messages */
Buffer auth_debug;
int auth_debug_init;

d79 1
a79 2
	if (S_ISREG(st.st_mode) == 0 ||
	    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {
d93 1
a93 1
			if (match_user(pw->pw_name, hostname, ipaddr,
d95 2
a96 2
				log("User %.100s not allowed because listed in DenyUsers",
				    pw->pw_name);
d103 1
a103 1
			if (match_user(pw->pw_name, hostname, ipaddr,
a387 74
}

struct passwd *
getpwnamallow(const char *user)
{
#ifdef HAVE_LOGIN_CAP
	extern login_cap_t *lc;
#ifdef BSD_AUTH
	auth_session_t *as;
#endif
#endif
	struct passwd *pw;

	pw = getpwnam(user);
	if (pw == NULL || !allowed_user(pw))
		return (NULL);
#ifdef HAVE_LOGIN_CAP
	if ((lc = login_getclass(pw->pw_class)) == NULL) {
		debug("unable to get login class: %s", user);
		return (NULL);
	}
#ifdef BSD_AUTH
	if ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||
	    auth_approval(as, lc, pw->pw_name, "ssh") <= 0) {
		debug("Approval failure for %s", user);
		pw = NULL;
	}
	if (as != NULL)
		auth_close(as);
#endif
#endif
	if (pw != NULL)
		return (pwcopy(pw));
	return (NULL);
}

void
auth_debug_add(const char *fmt,...)
{
	char buf[1024];
	va_list args;

	if (!auth_debug_init)
		return;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);
	buffer_put_cstring(&auth_debug, buf);
}

void
auth_debug_send(void)
{
	char *msg;

	if (!auth_debug_init)
		return;
	while (buffer_len(&auth_debug)) {
		msg = buffer_get_string(&auth_debug, NULL);
		packet_send_debug("%s", msg);
		xfree(msg);
	}
}

void
auth_debug_reset(void)
{
	if (auth_debug_init)
		buffer_clear(&auth_debug);
	else {
		buffer_init(&auth_debug);
		auth_debug_init = 1;
	}
@


1.20
log
@check /etc/shells, too
@
text
@d53 1
a53 1
	char *shell, *cp;
a64 9

	/* disallow anyone who does not have a standard shell */
	setusershell();
	while ((cp = getusershell()) != NULL)
		if (strcmp(cp, shell) == 0)
			break;
	endusershell();
	if (cp == NULL)
		return 0;
@


1.19
log
@make copyright lines the same format
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.18 2001/02/22 21:59:43 markus Exp $");
d53 1
a53 1
	char *shell;
d65 9
@


1.18
log
@use pwcopy in ssh.c, too
@
text
@d2 1
a2 1
 * Copyright (c) 2000 Markus Friedl. All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.17 2001/02/12 16:16:23 markus Exp $");
@


1.17
log
@PermitRootLogin={yes,without-password,forced-commands-only,no}
(before this change, root could login even if PermitRootLogin==no)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.16 2001/02/04 15:32:22 stevesk Exp $");
a120 15
}

struct passwd *
pwcopy(struct passwd *pw)
{
	struct passwd *copy = xmalloc(sizeof(*copy));
	memset(copy, 0, sizeof(*copy));
	copy->pw_name = xstrdup(pw->pw_name);
	copy->pw_passwd = xstrdup(pw->pw_passwd);
	copy->pw_uid = pw->pw_uid;
	copy->pw_gid = pw->pw_gid;
	copy->pw_class = xstrdup(pw->pw_class);
	copy->pw_dir = xstrdup(pw->pw_dir);
	copy->pw_shell = xstrdup(pw->pw_shell);
	return copy;
@


1.16
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.15 2001/02/03 10:08:37 markus Exp $");
d167 1
a167 2
 * Check if the user is logging in as root and root logins are disallowed.
 * Note that root login is _allways_ allowed for forced commands.
d170 1
a170 1
auth_root_allowed(void)
d172 2
a173 1
	if (options.permit_root_login)
d175 11
a185 6
	if (forced_command) {
		log("Root login accepted for forced command.");
		return 1;
	} else {
		log("ROOT LOGIN REFUSED FROM %.200s", get_remote_ipaddr());
		return 0;
d187 2
@


1.15
log
@make ReverseMappingCheck optional in sshd_config; ok djm@@,dugsong@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.14 2001/01/21 19:05:43 markus Exp $");
d118 3
a120 3
        Authctxt *authctxt = xmalloc(sizeof(*authctxt));
        memset(authctxt, 0, sizeof(*authctxt));
        return authctxt;
@


1.14
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.13 2001/01/18 16:59:59 markus Exp $");
d179 1
a179 1
		log("ROOT LOGIN REFUSED FROM %.200s", get_canonical_hostname());
@


1.13
log
@1) removes fake skey from sshd, since this will be much
   harder with /usr/libexec/auth/login_XXX
2) share/unify code used in ssh-1 and ssh-2 authentication (server side)
3) make addition of BSD_AUTH and other challenge reponse methods
   easier.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.12 2001/01/13 18:56:48 markus Exp $");
a28 1
#include "ssh.h"
d30 2
a32 2
#include "groupaccess.h"

d35 1
@


1.12
log
@support supplementary group in {Allow,Deny}Groups
from stevesk@@pobox.com
@
text
@a1 10
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.11 2000/10/11 20:27:23 markus Exp $");
a28 1
#include "rsa.h"
d30 1
a30 4
#include "pty.h"
#include "packet.h"
#include "buffer.h"
#include "mpaux.h"
a31 3
#include "compat.h"
#include "channels.h"
#include "match.h"
a33 2
#include "bufaux.h"
#include "ssh2.h"
d35 1
a35 1
#include "session.h"
d113 69
@


1.11
log
@new cipher framework
@
text
@d36 1
a36 1
RCSID("$OpenBSD: auth.c,v 1.10 2000/09/07 21:13:36 markus Exp $");
d49 1
d60 5
a64 5
 * Check if the user is allowed to log in via ssh. If user is listed in
 * DenyUsers or user's primary group is listed in DenyGroups, false will
 * be returned. If AllowUsers isn't empty and user isn't listed there, or
 * if AllowGroups isn't empty and user isn't listed there, false will be
 * returned.
a71 1
	struct group *grp;
d76 1
a76 1
	if (!pw)
a92 2
		if (!pw->pw_name)
			return 0;
a98 2
		if (!pw->pw_name)
			return 0;
a105 1
	/* Get the primary group name if we need it. Return false if it fails */
d107 2
a108 2
		grp = getgrgid(pw->pw_gid);
		if (!grp)
d111 5
a115 3
		/* Return false if user's group is listed in DenyGroups */
		if (options.num_deny_groups > 0) {
			if (!grp->gr_name)
d117 1
a117 4
			for (i = 0; i < options.num_deny_groups; i++)
				if (match_pattern(grp->gr_name, options.deny_groups[i]))
					return 0;
		}
d119 1
a119 1
		 * Return false if AllowGroups isn't empty and user's group
d122 4
a125 9
		if (options.num_allow_groups > 0) {
			if (!grp->gr_name)
				return 0;
			for (i = 0; i < options.num_allow_groups; i++)
				if (match_pattern(grp->gr_name, options.allow_groups[i]))
					break;
			/* i < options.num_allow_groups iff we break for
			   loop */
			if (i >= options.num_allow_groups)
d127 2
a128 1
		}
@


1.11.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d2 10
d36 1
a36 1
RCSID("$OpenBSD: auth.c,v 1.17 2001/02/12 16:16:23 markus Exp $");
d39 9
d49 3
a51 3
#include "groupaccess.h"
#include "log.h"
#include "servconf.h"
d53 1
a53 2
#include "auth-options.h"
#include "canohost.h"
d59 5
a63 5
 * Check if the user is allowed to log in via ssh. If user is listed
 * in DenyUsers or one of user's groups is listed in DenyGroups, false
 * will be returned. If AllowUsers isn't empty and user isn't listed
 * there, or if AllowGroups isn't empty and one of user's groups isn't
 * listed there, false will be returned.
d71 1
d76 1
a76 1
	if (!pw || !pw->pw_name)
d93 2
d101 2
d110 1
d112 2
a113 2
		/* Get the user's group access list (primary and supplementary) */
		if (ga_init(pw->pw_name, pw->pw_gid) == 0)
d116 3
a118 5
		/* Return false if one of user's groups is listed in DenyGroups */
		if (options.num_deny_groups > 0)
			if (ga_match(options.deny_groups,
			    options.num_deny_groups)) {
				ga_free();
d120 4
a123 1
			}
d125 1
a125 1
		 * Return false if AllowGroups isn't empty and one of user's groups
d128 9
a136 4
		if (options.num_allow_groups > 0)
			if (!ga_match(options.allow_groups,
			    options.num_allow_groups)) {
				ga_free();
d138 1
a138 2
			}
		ga_free();
a141 76
}

Authctxt *
authctxt_new(void)
{
	Authctxt *authctxt = xmalloc(sizeof(*authctxt));
	memset(authctxt, 0, sizeof(*authctxt));
	return authctxt;
}

struct passwd *
pwcopy(struct passwd *pw)
{
	struct passwd *copy = xmalloc(sizeof(*copy));
	memset(copy, 0, sizeof(*copy));
	copy->pw_name = xstrdup(pw->pw_name);
	copy->pw_passwd = xstrdup(pw->pw_passwd);
	copy->pw_uid = pw->pw_uid;
	copy->pw_gid = pw->pw_gid;
	copy->pw_class = xstrdup(pw->pw_class);
	copy->pw_dir = xstrdup(pw->pw_dir);
	copy->pw_shell = xstrdup(pw->pw_shell);
	return copy;
}

void
auth_log(Authctxt *authctxt, int authenticated, char *method, char *info)
{
	void (*authlog) (const char *fmt,...) = verbose;
	char *authmsg;

	/* Raise logging level */
	if (authenticated == 1 ||
	    !authctxt->valid ||
	    authctxt->failures >= AUTH_FAIL_LOG ||
	    strcmp(method, "password") == 0)
		authlog = log;

	if (authctxt->postponed)
		authmsg = "Postponed";
	else
		authmsg = authenticated ? "Accepted" : "Failed";

	authlog("%s %s for %s%.100s from %.200s port %d%s",
	    authmsg,
	    method,
	    authctxt->valid ? "" : "illegal user ",
	    authctxt->valid && authctxt->pw->pw_uid == 0 ? "ROOT" : authctxt->user,
	    get_remote_ipaddr(),
	    get_remote_port(),
	    info);
}

/*
 * Check whether root logins are disallowed.
 */
int
auth_root_allowed(char *method)
{
	switch (options.permit_root_login) {
	case PERMIT_YES:
		return 1;
		break;
	case PERMIT_NO_PASSWD:
		if (strcmp(method, "password") != 0)
			return 1;
		break;
	case PERMIT_FORCED_ONLY:
		if (forced_command) {
			log("Root login accepted for forced command.");
			return 1;
		}
		break;
	}
	log("ROOT LOGIN REFUSED FROM %.200s", get_remote_ipaddr());
	return 0;
@


1.11.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.11.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.21 2001/03/19 17:07:23 markus Exp $");
d121 15
@


1.11.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@@


1.11.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d26 1
a26 3
RCSID("$OpenBSD: auth.c,v 1.27 2001/07/11 18:26:15 markus Exp $");

#include <libgen.h>
a35 4
#include "buffer.h"
#include "bufaux.h"
#include "uidswap.h"
#include "tildexpand.h"
a52 1
	const char *hostname = NULL, *ipaddr = NULL;
a71 5
	if (options.num_deny_users > 0 || options.num_allow_users > 0) {
		hostname = get_canonical_hostname(options.reverse_mapping_check);
		ipaddr = get_remote_ipaddr();
	}

d75 1
a75 2
			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.deny_users[i]))
d81 1
a81 2
			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.allow_users[i]))
a172 176
	return 0;
}


/*
 * Given a template and a passwd structure, build a filename
 * by substituting % tokenised options. Currently, %% becomes '%',
 * %h becomes the home directory and %u the username.
 *
 * This returns a buffer allocated by xmalloc.
 */
char *
expand_filename(const char *filename, struct passwd *pw)
{
	Buffer buffer;
	char *file;
	const char *cp;

	/*
	 * Build the filename string in the buffer by making the appropriate
	 * substitutions to the given file name.
	 */
	buffer_init(&buffer);
	for (cp = filename; *cp; cp++) {
		if (cp[0] == '%' && cp[1] == '%') {
			buffer_append(&buffer, "%", 1);
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'h') {
			buffer_append(&buffer, pw->pw_dir, strlen(pw->pw_dir));
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'u') {
			buffer_append(&buffer, pw->pw_name,
			     strlen(pw->pw_name));
			cp++;
			continue;
		}
		buffer_append(&buffer, cp, 1);
	}
	buffer_append(&buffer, "\0", 1);

	/*
	 * Ensure that filename starts anchored. If not, be backward
	 * compatible and prepend the '%h/'
	 */
	file = xmalloc(MAXPATHLEN);
	cp = buffer_ptr(&buffer);
	if (*cp != '/')
		snprintf(file, MAXPATHLEN, "%s/%s", pw->pw_dir, cp);
	else
		strlcpy(file, cp, MAXPATHLEN);

	buffer_free(&buffer);
	return file;
}

char *
authorized_keys_file(struct passwd *pw)
{
	return expand_filename(options.authorized_keys_file, pw);
}

char *
authorized_keys_file2(struct passwd *pw)
{
	return expand_filename(options.authorized_keys_file2, pw);
}

/* return ok if key exists in sysfile or userfile */
HostStatus
check_key_in_hostfiles(struct passwd *pw, Key *key, const char *host,
    const char *sysfile, const char *userfile)
{
	Key *found;
	char *user_hostfile;
	struct stat st;
	int host_status;

	/* Check if we know the host and its host key. */
	found = key_new(key->type);
	host_status = check_host_in_hostfile(sysfile, host, key, found, NULL);

	if (host_status != HOST_OK && userfile != NULL) {
		user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
		if (options.strict_modes &&
		    (stat(user_hostfile, &st) == 0) &&
		    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		     (st.st_mode & 022) != 0)) {
			log("Authentication refused for %.100s: "
			    "bad owner or modes for %.200s",
			    pw->pw_name, user_hostfile);
		} else {
			temporarily_use_uid(pw);
			host_status = check_host_in_hostfile(user_hostfile,
			    host, key, found, NULL);
			restore_uid();
		}
		xfree(user_hostfile);
	}
	key_free(found);

	debug2("check_key_in_hostfiles: key %s for %s", host_status == HOST_OK ?
	    "ok" : "not found", host);
	return host_status;
}


/*
 * Check a given file for security. This is defined as all components
 * of the path to the file must either be owned by either the owner of
 * of the file or root and no directories must be group or world writable.
 *
 * XXX Should any specific check be done for sym links ?
 *
 * Takes an open file descriptor, the file name, a uid and and
 * error buffer plus max size as arguments.
 *
 * Returns 0 on success and -1 on failure
 */
int
secure_filename(FILE *f, const char *file, struct passwd *pw,
    char *err, size_t errlen)
{
	uid_t uid = pw->pw_uid;
	char buf[MAXPATHLEN];
	char *cp;
	struct stat st;

	if (realpath(file, buf) == NULL) {
		snprintf(err, errlen, "realpath %s failed: %s", file,
		    strerror(errno));
		return -1;
	}

	/* check the open file to avoid races */
	if (fstat(fileno(f), &st) < 0 ||
	    (st.st_uid != 0 && st.st_uid != uid) ||
	    (st.st_mode & 022) != 0) {
		snprintf(err, errlen, "bad ownership or modes for file %s",
		    buf);
		return -1;
	}

	/* for each component of the canonical path, walking upwards */
	for (;;) {
		if ((cp = dirname(buf)) == NULL) {
			snprintf(err, errlen, "dirname() failed");
			return -1;
		}
		strlcpy(buf, cp, sizeof(buf));

		debug3("secure_filename: checking '%s'", buf);
		if (stat(buf, &st) < 0 ||
		    (st.st_uid != 0 && st.st_uid != uid) ||
		    (st.st_mode & 022) != 0) {
			snprintf(err, errlen, 
			    "bad ownership or modes for directory %s", buf);
			return -1;
		}

		/* If are passed the homedir then we can stop */
		if (strcmp(pw->pw_dir, buf) == 0) {
			debug3("secure_filename: terminating check at '%s'",
			    buf);
			break;
		}
		/*
		 * dirname should always complete with a "/" path,
		 * but we can be paranoid and check for "." too
		 */
		if ((strcmp("/", buf) == 0) || (strcmp(".", buf) == 0))
			break;
	}
@


1.11.2.6
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.11.2.5 2001/09/27 00:15:41 miod Exp $");
d314 1
a314 1
	char buf[MAXPATHLEN], homedir[MAXPATHLEN];
a322 5
	if (realpath(pw->pw_dir, homedir) == NULL) {
		snprintf(err, errlen, "realpath %s failed: %s", pw->pw_dir,
		    strerror(errno));
		return -1;
	}
d351 1
a351 1
		if (strcmp(homedir, buf) == 0) {
@


1.11.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.11.2.6 2001/11/15 00:14:59 miod Exp $");
d159 1
a159 1
	    authctxt->user,
@


1.11.2.8
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.35 2002/03/01 13:12:10 markus Exp $");
d74 1
a74 3
	if (stat(shell, &st) != 0) {
		log("User %.100s not allowed because shell %.100s does not exist",
		    pw->pw_name, shell);
d76 1
a76 4
	}
	if (!((st.st_mode & S_IFREG) && (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)))) {
		log("User %.100s not allowed because shell %.100s is not executable",
		    pw->pw_name, shell);
a77 1
	}
d80 1
a80 1
		hostname = get_canonical_hostname(options.verify_reverse_mapping);
d87 2
a88 4
 			if (match_user(pw->pw_name, hostname, ipaddr,
			    options.deny_users[i])) {
 				log("User %.100s not allowed because listed in DenyUsers",
 				    pw->pw_name);
a89 1
			}
d94 1
a94 1
 			if (match_user(pw->pw_name, hostname, ipaddr,
d98 1
a98 3
		if (i >= options.num_allow_users) {
			log("User %.100s not allowed because not listed in AllowUsers",
			    pw->pw_name);
a99 1
		}
d103 1
a103 3
		if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
			log("User %.100s not allowed because not in any group",
			    pw->pw_name);
a104 1
		}
a110 2
				log("User %.100s not allowed because a group is listed in DenyGroups",
				    pw->pw_name);
a120 2
				log("User %.100s not allowed because none of user's groups are listed in AllowGroups",
				    pw->pw_name);
d223 1
a223 1
			    strlen(pw->pw_name));
d266 1
a266 1
	HostStatus host_status;
d277 1
a277 1
		    (st.st_mode & 022) != 0)) {
d350 1
a350 1
			snprintf(err, errlen,
@


1.10
log
@some more Copyright fixes
@
text
@d36 1
a36 1
RCSID("$OpenBSD: auth.c,v 1.9 2000/09/07 20:27:49 deraadt Exp $");
a43 1
#include "cipher.h"
@


1.9
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d36 1
a36 1
RCSID("$OpenBSD: auth.c,v 1.8 2000/08/04 20:30:07 markus Exp $");
a57 1
extern char *forced_command;
@


1.8
log
@unused
@
text
@d4 8
d13 20
d36 1
a36 1
RCSID("$OpenBSD: auth.c,v 1.7 2000/05/17 21:37:24 deraadt Exp $");
@


1.7
log
@accept an empty shell in authentication; bug reported by chris@@tinker.ucr.edu
@
text
@d8 1
a8 1
RCSID("$OpenBSD: auth.c,v 1.6 2000/04/26 21:28:31 markus Exp $");
a26 2
#include "dispatch.h"

@


1.6
log
@split auth/sshconnect in one file per protocol version
@
text
@d8 1
a8 1
RCSID("$OpenBSD: auth.c,v 1.15 2000/04/18 15:01:30 markus Exp $");
d48 1
d55 6
d62 1
a62 1
	if (stat(pw->pw_shell, &st) != 0)
@


1.6.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d8 1
a8 1
RCSID("$OpenBSD: auth.c,v 1.7 2000/05/17 21:37:24 deraadt Exp $");
a47 1
	char *shell;
a53 6
	/*
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
	 */
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;

d55 1
a55 1
	if (stat(shell, &st) != 0)
@


1.6.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d8 1
a8 1
RCSID("$OpenBSD: auth.c,v 1.8 2000/08/04 20:30:07 markus Exp $");
d27 2
@


1.6.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@a3 8
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
a4 20
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d8 1
a8 1
RCSID("$OpenBSD: auth.c,v 1.11 2000/10/11 20:27:23 markus Exp $");
d16 1
d30 1
@


1.6.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d2 10
d36 1
a36 1
RCSID("$OpenBSD: auth.c,v 1.17 2001/02/12 16:16:23 markus Exp $");
d39 9
d49 3
a51 3
#include "groupaccess.h"
#include "log.h"
#include "servconf.h"
d53 1
a53 2
#include "auth-options.h"
#include "canohost.h"
d59 5
a63 5
 * Check if the user is allowed to log in via ssh. If user is listed
 * in DenyUsers or one of user's groups is listed in DenyGroups, false
 * will be returned. If AllowUsers isn't empty and user isn't listed
 * there, or if AllowGroups isn't empty and one of user's groups isn't
 * listed there, false will be returned.
d71 1
d76 1
a76 1
	if (!pw || !pw->pw_name)
d93 2
d101 2
d110 1
d112 2
a113 2
		/* Get the user's group access list (primary and supplementary) */
		if (ga_init(pw->pw_name, pw->pw_gid) == 0)
d116 3
a118 5
		/* Return false if one of user's groups is listed in DenyGroups */
		if (options.num_deny_groups > 0)
			if (ga_match(options.deny_groups,
			    options.num_deny_groups)) {
				ga_free();
d120 4
a123 1
			}
d125 1
a125 1
		 * Return false if AllowGroups isn't empty and one of user's groups
d128 9
a136 4
		if (options.num_allow_groups > 0)
			if (!ga_match(options.allow_groups,
			    options.num_allow_groups)) {
				ga_free();
d138 1
a138 2
			}
		ga_free();
a141 76
}

Authctxt *
authctxt_new(void)
{
	Authctxt *authctxt = xmalloc(sizeof(*authctxt));
	memset(authctxt, 0, sizeof(*authctxt));
	return authctxt;
}

struct passwd *
pwcopy(struct passwd *pw)
{
	struct passwd *copy = xmalloc(sizeof(*copy));
	memset(copy, 0, sizeof(*copy));
	copy->pw_name = xstrdup(pw->pw_name);
	copy->pw_passwd = xstrdup(pw->pw_passwd);
	copy->pw_uid = pw->pw_uid;
	copy->pw_gid = pw->pw_gid;
	copy->pw_class = xstrdup(pw->pw_class);
	copy->pw_dir = xstrdup(pw->pw_dir);
	copy->pw_shell = xstrdup(pw->pw_shell);
	return copy;
}

void
auth_log(Authctxt *authctxt, int authenticated, char *method, char *info)
{
	void (*authlog) (const char *fmt,...) = verbose;
	char *authmsg;

	/* Raise logging level */
	if (authenticated == 1 ||
	    !authctxt->valid ||
	    authctxt->failures >= AUTH_FAIL_LOG ||
	    strcmp(method, "password") == 0)
		authlog = log;

	if (authctxt->postponed)
		authmsg = "Postponed";
	else
		authmsg = authenticated ? "Accepted" : "Failed";

	authlog("%s %s for %s%.100s from %.200s port %d%s",
	    authmsg,
	    method,
	    authctxt->valid ? "" : "illegal user ",
	    authctxt->valid && authctxt->pw->pw_uid == 0 ? "ROOT" : authctxt->user,
	    get_remote_ipaddr(),
	    get_remote_port(),
	    info);
}

/*
 * Check whether root logins are disallowed.
 */
int
auth_root_allowed(char *method)
{
	switch (options.permit_root_login) {
	case PERMIT_YES:
		return 1;
		break;
	case PERMIT_NO_PASSWD:
		if (strcmp(method, "password") != 0)
			return 1;
		break;
	case PERMIT_FORCED_ONLY:
		if (forced_command) {
			log("Root login accepted for forced command.");
			return 1;
		}
		break;
	}
	log("ROOT LOGIN REFUSED FROM %.200s", get_remote_ipaddr());
	return 0;
@


1.6.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: auth.c,v 1.21 2001/03/19 17:07:23 markus Exp $");
d121 15
@


1.5
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d8 1
a8 5
RCSID("$OpenBSD: auth.c,v 1.4 2000/04/14 10:30:29 markus Exp $");

#include <openssl/dsa.h>
#include <openssl/rsa.h>
#include <openssl/evp.h>
d22 1
a28 5
#include "key.h"
#include "kex.h"
#include "dsa.h"
#include "uidswap.h"
#include "channels.h"
a110 816
}

/* import */
extern ServerOptions options;
extern char *forced_command;

/*
 * convert ssh auth msg type into description
 */
char *
get_authname(int type)
{
	static char buf[1024];
	switch (type) {
	case SSH_CMSG_AUTH_PASSWORD:
		return "password";
	case SSH_CMSG_AUTH_RSA:
		return "rsa";
	case SSH_CMSG_AUTH_RHOSTS_RSA:
		return "rhosts-rsa";
	case SSH_CMSG_AUTH_RHOSTS:
		return "rhosts";
#ifdef KRB4
	case SSH_CMSG_AUTH_KERBEROS:
		return "kerberos";
#endif
#ifdef SKEY
	case SSH_CMSG_AUTH_TIS_RESPONSE:
		return "s/key";
#endif
	}
	snprintf(buf, sizeof buf, "bad-auth-msg-%d", type);
	return buf;
}

#define AUTH_FAIL_MAX 6
#define AUTH_FAIL_LOG (AUTH_FAIL_MAX/2)
#define AUTH_FAIL_MSG "Too many authentication failures for %.100s"

/*
 * The user does not exist or access is denied,
 * but fake indication that authentication is needed.
 */
void
do_fake_authloop1(char *user)
{
	int attempt = 0;

	log("Faking authloop for illegal user %.200s from %.200s port %d",
	    user,
	    get_remote_ipaddr(),
	    get_remote_port());

	/* Indicate that authentication is needed. */
	packet_start(SSH_SMSG_FAILURE);
	packet_send();
	packet_write_wait();

	/*
	 * Keep reading packets, and always respond with a failure.  This is
	 * to avoid disclosing whether such a user really exists.
	 */
	for (attempt = 1;; attempt++) {
		/* Read a packet.  This will not return if the client disconnects. */
		int plen;
		int type = packet_read(&plen);
#ifdef SKEY
		unsigned int dlen;
		char *password, *skeyinfo;
		password = NULL;
		/* Try to send a fake s/key challenge. */
		if (options.skey_authentication == 1 &&
		    (skeyinfo = skey_fake_keyinfo(user)) != NULL) {
			if (type == SSH_CMSG_AUTH_TIS) {
				packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
				packet_put_string(skeyinfo, strlen(skeyinfo));
				packet_send();
				packet_write_wait();
				continue;
			} else if (type == SSH_CMSG_AUTH_PASSWORD &&
				   options.password_authentication &&
				   (password = packet_get_string(&dlen)) != NULL &&
				   dlen == 5 &&
				   strncasecmp(password, "s/key", 5) == 0 ) {
				packet_send_debug(skeyinfo);
			}
		}
		if (password != NULL)
			xfree(password);
#endif
		if (attempt > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, user);

		/*
		 * Send failure.  This should be indistinguishable from a
		 * failed authentication.
		 */
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
	}
	/* NOTREACHED */
	abort();
}

/*
 * read packets and try to authenticate local user *pw.
 * return if authentication is successfull
 */
void
do_authloop(struct passwd * pw)
{
	int attempt = 0;
	unsigned int bits;
	RSA *client_host_key;
	BIGNUM *n;
	char *client_user, *password;
	char user[1024];
	unsigned int dlen;
	int plen, nlen, elen;
	unsigned int ulen;
	int type = 0;
	void (*authlog) (const char *fmt,...) = verbose;

	/* Indicate that authentication is needed. */
	packet_start(SSH_SMSG_FAILURE);
	packet_send();
	packet_write_wait();

	for (attempt = 1;; attempt++) {
		int authenticated = 0;
		strlcpy(user, "", sizeof user);

		/* Get a packet from the client. */
		type = packet_read(&plen);

		/* Process the packet. */
		switch (type) {
#ifdef AFS
		case SSH_CMSG_HAVE_KERBEROS_TGT:
			if (!options.kerberos_tgt_passing) {
				/* packet_get_all(); */
				verbose("Kerberos tgt passing disabled.");
				break;
			} else {
				/* Accept Kerberos tgt. */
				char *tgt = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				if (!auth_kerberos_tgt(pw, tgt))
					verbose("Kerberos tgt REFUSED for %s", pw->pw_name);
				xfree(tgt);
			}
			continue;

		case SSH_CMSG_HAVE_AFS_TOKEN:
			if (!options.afs_token_passing || !k_hasafs()) {
				/* packet_get_all(); */
				verbose("AFS token passing disabled.");
				break;
			} else {
				/* Accept AFS token. */
				char *token_string = packet_get_string(&dlen);
				packet_integrity_check(plen, 4 + dlen, type);
				if (!auth_afs_token(pw, token_string))
					verbose("AFS token REFUSED for %s", pw->pw_name);
				xfree(token_string);
			}
			continue;
#endif /* AFS */
#ifdef KRB4
		case SSH_CMSG_AUTH_KERBEROS:
			if (!options.kerberos_authentication) {
				/* packet_get_all(); */
				verbose("Kerberos authentication disabled.");
				break;
			} else {
				/* Try Kerberos v4 authentication. */
				KTEXT_ST auth;
				char *tkt_user = NULL;
				char *kdata = packet_get_string((unsigned int *) &auth.length);
				packet_integrity_check(plen, 4 + auth.length, type);

				if (auth.length < MAX_KTXT_LEN)
					memcpy(auth.dat, kdata, auth.length);
				xfree(kdata);

				authenticated = auth_krb4(pw->pw_name, &auth, &tkt_user);

				if (authenticated) {
					snprintf(user, sizeof user, " tktuser %s", tkt_user);
					xfree(tkt_user);
				}
			}
			break;
#endif /* KRB4 */

		case SSH_CMSG_AUTH_RHOSTS:
			if (!options.rhosts_authentication) {
				verbose("Rhosts authentication disabled.");
				break;
			}
			/*
			 * Get client user name.  Note that we just have to
			 * trust the client; this is one reason why rhosts
			 * authentication is insecure. (Another is
			 * IP-spoofing on a local network.)
			 */
			client_user = packet_get_string(&ulen);
			packet_integrity_check(plen, 4 + ulen, type);

			/* Try to authenticate using /etc/hosts.equiv and
			   .rhosts. */
			authenticated = auth_rhosts(pw, client_user);

			snprintf(user, sizeof user, " ruser %s", client_user);
			xfree(client_user);
			break;

		case SSH_CMSG_AUTH_RHOSTS_RSA:
			if (!options.rhosts_rsa_authentication) {
				verbose("Rhosts with RSA authentication disabled.");
				break;
			}
			/*
			 * Get client user name.  Note that we just have to
			 * trust the client; root on the client machine can
			 * claim to be any user.
			 */
			client_user = packet_get_string(&ulen);

			/* Get the client host key. */
			client_host_key = RSA_new();
			if (client_host_key == NULL)
				fatal("RSA_new failed");
			client_host_key->e = BN_new();
			client_host_key->n = BN_new();
			if (client_host_key->e == NULL || client_host_key->n == NULL)
				fatal("BN_new failed");
			bits = packet_get_int();
			packet_get_bignum(client_host_key->e, &elen);
			packet_get_bignum(client_host_key->n, &nlen);

			if (bits != BN_num_bits(client_host_key->n))
				error("Warning: keysize mismatch for client_host_key: "
				      "actual %d, announced %d", BN_num_bits(client_host_key->n), bits);
			packet_integrity_check(plen, (4 + ulen) + 4 + elen + nlen, type);

			authenticated = auth_rhosts_rsa(pw, client_user, client_host_key);
			RSA_free(client_host_key);

			snprintf(user, sizeof user, " ruser %s", client_user);
			xfree(client_user);
			break;

		case SSH_CMSG_AUTH_RSA:
			if (!options.rsa_authentication) {
				verbose("RSA authentication disabled.");
				break;
			}
			/* RSA authentication requested. */
			n = BN_new();
			packet_get_bignum(n, &nlen);
			packet_integrity_check(plen, nlen, type);
			authenticated = auth_rsa(pw, n);
			BN_clear_free(n);
			break;

		case SSH_CMSG_AUTH_PASSWORD:
			if (!options.password_authentication) {
				verbose("Password authentication disabled.");
				break;
			}
			/*
			 * Read user password.  It is in plain text, but was
			 * transmitted over the encrypted channel so it is
			 * not visible to an outside observer.
			 */
			password = packet_get_string(&dlen);
			packet_integrity_check(plen, 4 + dlen, type);

			/* Try authentication with the password. */
			authenticated = auth_password(pw, password);

			memset(password, 0, strlen(password));
			xfree(password);
			break;

#ifdef SKEY
		case SSH_CMSG_AUTH_TIS:
			debug("rcvd SSH_CMSG_AUTH_TIS");
			if (options.skey_authentication == 1) {
				char *skeyinfo = skey_keyinfo(pw->pw_name);
				if (skeyinfo == NULL) {
					debug("generating fake skeyinfo for %.100s.", pw->pw_name);
					skeyinfo = skey_fake_keyinfo(pw->pw_name);
				}
				if (skeyinfo != NULL) {
					/* we send our s/key- in tis-challenge messages */
					debug("sending challenge '%s'", skeyinfo);
					packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
					packet_put_string(skeyinfo, strlen(skeyinfo));
					packet_send();
					packet_write_wait();
					continue;
				}
			}
			break;
		case SSH_CMSG_AUTH_TIS_RESPONSE:
			debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
			if (options.skey_authentication == 1) {
				char *response = packet_get_string(&dlen);
				debug("skey response == '%s'", response);
				packet_integrity_check(plen, 4 + dlen, type);
				authenticated = (skey_haskey(pw->pw_name) == 0 &&
						 skey_passcheck(pw->pw_name, response) != -1);
				xfree(response);
			}
			break;
#else
		case SSH_CMSG_AUTH_TIS:
			/* TIS Authentication is unsupported */
			log("TIS authentication unsupported.");
			break;
#endif

		default:
			/*
			 * Any unknown messages will be ignored (and failure
			 * returned) during authentication.
			 */
			log("Unknown message during authentication: type %d", type);
			break;
		}

		/*
		 * Check if the user is logging in as root and root logins
		 * are disallowed.
		 * Note that root login is allowed for forced commands.
		 */
		if (authenticated && pw->pw_uid == 0 && !options.permit_root_login) {
			if (forced_command) {
				log("Root login accepted for forced command.");
			} else {
				authenticated = 0;
				log("ROOT LOGIN REFUSED FROM %.200s",
				    get_canonical_hostname());
			}
		}

		/* Raise logging level */
		if (authenticated ||
		    attempt == AUTH_FAIL_LOG ||
		    type == SSH_CMSG_AUTH_PASSWORD)
			authlog = log;

		authlog("%s %s for %.200s from %.200s port %d%s",
			authenticated ? "Accepted" : "Failed",
			get_authname(type),
			pw->pw_uid == 0 ? "ROOT" : pw->pw_name,
			get_remote_ipaddr(),
			get_remote_port(),
			user);

		if (authenticated)
			return;

		if (attempt > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, pw->pw_name);

		/* Send a message indicating that the authentication attempt failed. */
		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
	}
}

/*
 * Performs authentication of an incoming connection.  Session key has already
 * been exchanged and encryption is enabled.
 */
void
do_authentication()
{
	struct passwd *pw, pwcopy;
	int plen;
	unsigned int ulen;
	char *user;

	/* Get the name of the user that we wish to log in as. */
	packet_read_expect(&plen, SSH_CMSG_USER);

	/* Get the user name. */
	user = packet_get_string(&ulen);
	packet_integrity_check(plen, (4 + ulen), SSH_CMSG_USER);

	setproctitle("%s", user);

#ifdef AFS
	/* If machine has AFS, set process authentication group. */
	if (k_hasafs()) {
		k_setpag();
		k_unlog();
	}
#endif /* AFS */

	/* Verify that the user is a valid user. */
	pw = getpwnam(user);
	if (!pw || !allowed_user(pw))
		do_fake_authloop1(user);
	xfree(user);

	/* Take a copy of the returned structure. */
	memset(&pwcopy, 0, sizeof(pwcopy));
	pwcopy.pw_name = xstrdup(pw->pw_name);
	pwcopy.pw_passwd = xstrdup(pw->pw_passwd);
	pwcopy.pw_uid = pw->pw_uid;
	pwcopy.pw_gid = pw->pw_gid;
	pwcopy.pw_dir = xstrdup(pw->pw_dir);
	pwcopy.pw_shell = xstrdup(pw->pw_shell);
	pw = &pwcopy;

	/*
	 * If we are not running as root, the user must have the same uid as
	 * the server.
	 */
	if (getuid() != 0 && pw->pw_uid != getuid())
		packet_disconnect("Cannot change user when server not running as root.");

	debug("Attempting authentication for %.100s.", pw->pw_name);

	/* If the user has no password, accept authentication immediately. */
	if (options.password_authentication &&
#ifdef KRB4
	    (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
#endif /* KRB4 */
	    auth_password(pw, "")) {
		/* Authentication with empty password succeeded. */
		log("Login for user %s from %.100s, accepted without authentication.",
		    pw->pw_name, get_remote_ipaddr());
	} else {
		/* Loop until the user has been authenticated or the
		   connection is closed, do_authloop() returns only if
		   authentication is successfull */
		do_authloop(pw);
	}

	/* The user has been authenticated and accepted. */
	packet_start(SSH_SMSG_SUCCESS);
	packet_send();
	packet_write_wait();

	/* Perform session preparation. */
	do_authenticated(pw);
}

/* import */
extern ServerOptions options;
extern unsigned char *session_id2;
extern int session_id2_len;

/* protocol */

void	input_service_request(int type, int plen);
void	input_userauth_request(int type, int plen);
void	protocol_error(int type, int plen);

/* auth */
int	ssh2_auth_none(struct passwd *pw);
int	ssh2_auth_password(struct passwd *pw);
int	ssh2_auth_pubkey(struct passwd *pw, unsigned char *raw, unsigned int rlen);

/* helper */
struct passwd*	 auth_set_user(char *u, char *s);
int	user_dsa_key_allowed(struct passwd *pw, Key *key);

typedef struct Authctxt Authctxt;
struct Authctxt {
	char *user;
	char *service;
	struct passwd pw;
	int valid;
};
static Authctxt	*authctxt = NULL;
static int userauth_success = 0;

/* set and get current user */

struct passwd*
auth_get_user(void)
{
	return (authctxt != NULL && authctxt->valid) ? &authctxt->pw : NULL;
}

struct passwd*
auth_set_user(char *u, char *s)
{
	struct passwd *pw, *copy;

	if (authctxt == NULL) {
		authctxt = xmalloc(sizeof(*authctxt));
		authctxt->valid = 0;
		authctxt->user = xstrdup(u);
		authctxt->service = xstrdup(s);
		setproctitle("%s", u);
		pw = getpwnam(u);
		if (!pw || !allowed_user(pw)) {
			log("auth_set_user: bad user %s", u);
			return NULL;
		}
		copy = &authctxt->pw;
		memset(copy, 0, sizeof(*copy));
		copy->pw_name = xstrdup(pw->pw_name);
		copy->pw_passwd = xstrdup(pw->pw_passwd);
		copy->pw_uid = pw->pw_uid;
		copy->pw_gid = pw->pw_gid;
		copy->pw_dir = xstrdup(pw->pw_dir);
		copy->pw_shell = xstrdup(pw->pw_shell);
		authctxt->valid = 1;
	} else {
		if (strcmp(u, authctxt->user) != 0 ||
		    strcmp(s, authctxt->service) != 0) {
			log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)",
			    u, s, authctxt->user, authctxt->service);
			return NULL;
		}
	}
	return auth_get_user();
}

/*
 * loop until userauth_success == TRUE
 */

void
do_authentication2()
{
	dispatch_init(&protocol_error);
	dispatch_set(SSH2_MSG_SERVICE_REQUEST, &input_service_request);
	dispatch_run(DISPATCH_BLOCK, &userauth_success);
	do_authenticated2();
}

void
protocol_error(int type, int plen)
{
	log("auth: protocol error: type %d plen %d", type, plen);
	packet_start(SSH2_MSG_UNIMPLEMENTED);
	packet_put_int(0);
	packet_send();
	packet_write_wait();
}

void
input_service_request(int type, int plen)
{
	unsigned int len;
	int accept = 0;
	char *service = packet_get_string(&len);
	packet_done();

	if (strcmp(service, "ssh-userauth") == 0) {
		if (!userauth_success) {
			accept = 1;
			/* now we can handle user-auth requests */
			dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &input_userauth_request);
		}
	}
	/* XXX all other service requests are denied */

	if (accept) {
		packet_start(SSH2_MSG_SERVICE_ACCEPT);
		packet_put_cstring(service);
		packet_send();
		packet_write_wait();
	} else {
		debug("bad service request %s", service);
		packet_disconnect("bad service request %s", service);
	}
	xfree(service);
}

void
input_userauth_request(int type, int plen)
{
	static int try = 0;
	unsigned int len, rlen;
	int authenticated = 0;
	char *raw, *user, *service, *method;
	struct passwd *pw;

	if (++try == AUTH_FAIL_MAX)
		packet_disconnect("too many failed userauth_requests");

	raw = packet_get_raw(&rlen);
	if (plen != rlen)
		fatal("plen != rlen");
	user = packet_get_string(&len);
	service = packet_get_string(&len);
	method = packet_get_string(&len);
	debug("userauth-request for user %s service %s method %s", user, service, method);

	/* XXX we only allow the ssh-connection service */
	pw = auth_set_user(user, service);
	if (pw && strcmp(service, "ssh-connection")==0) {
		if (strcmp(method, "none") == 0) {
			authenticated =	ssh2_auth_none(pw);
		} else if (strcmp(method, "password") == 0) {
			authenticated =	ssh2_auth_password(pw);
		} else if (strcmp(method, "publickey") == 0) {
			authenticated =	ssh2_auth_pubkey(pw, raw, rlen);
		}
	}
	/* XXX check if other auth methods are needed */
	if (authenticated == 1) {
		log("userauth success for %s method %s", user, method);
		/* turn off userauth */
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &protocol_error);
		packet_start(SSH2_MSG_USERAUTH_SUCCESS);
		packet_send();
		packet_write_wait();
		/* now we can break out */
		userauth_success = 1;
	} else if (authenticated == 0) {
		log("userauth failure for %s method %s", user, method);
		packet_start(SSH2_MSG_USERAUTH_FAILURE);
		packet_put_cstring("publickey,password");	/* XXX dynamic */
		packet_put_char(0);				/* XXX partial success, unused */
		packet_send();
		packet_write_wait();
	} else {
		log("userauth postponed for %s method %s", user, method);
	}
	xfree(service);
	xfree(user);
	xfree(method);
}

int
ssh2_auth_none(struct passwd *pw)
{
	packet_done();
	return auth_password(pw, "");
}
int
ssh2_auth_password(struct passwd *pw)
{
	char *password;
	int authenticated = 0;
	int change;
	unsigned int len;
	change = packet_get_char();
	if (change)
		log("password change not supported");
	password = packet_get_string(&len);
	packet_done();
	if (auth_password(pw, password))
		authenticated = 1;
	memset(password, 0, len);
	xfree(password);
	return authenticated;
}

int
ssh2_auth_pubkey(struct passwd *pw, unsigned char *raw, unsigned int rlen)
{
	Buffer b;
	Key *key;
	char *pkalg, *pkblob, *sig;
	unsigned int alen, blen, slen;
	int have_sig;
	int authenticated = 0;

	have_sig = packet_get_char();
	pkalg = packet_get_string(&alen);
	if (strcmp(pkalg, KEX_DSS) != 0) {
		xfree(pkalg);
		log("bad pkalg %s", pkalg);	/*XXX*/
		return 0;
	}
	pkblob = packet_get_string(&blen);
	key = dsa_key_from_blob(pkblob, blen);
	
	if (have_sig && key != NULL) {
		sig = packet_get_string(&slen);
		packet_done();
		buffer_init(&b);
		buffer_append(&b, session_id2, session_id2_len);
		buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
		if (slen + 4 > rlen)
			fatal("bad rlen/slen");
		buffer_append(&b, raw, rlen - slen - 4);
#ifdef DEBUG_DSS
		buffer_dump(&b);
#endif
		/* test for correct signature */
		if (user_dsa_key_allowed(pw, key) &&
		    dsa_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
			authenticated = 1;
		buffer_clear(&b);
		xfree(sig);
	} else if (!have_sig && key != NULL) {
		packet_done();
		debug("test key...");
		/* test whether pkalg/pkblob are acceptable */
		/* XXX fake reply and always send PK_OK ? */
		if (user_dsa_key_allowed(pw, key)) {
			packet_start(SSH2_MSG_USERAUTH_PK_OK);
			packet_put_string(pkalg, alen);
			packet_put_string(pkblob, blen);
			packet_send();
			packet_write_wait();
			authenticated = -1;
		}
	}
	xfree(pkalg);
	xfree(pkblob);
	return authenticated;
}

/* return 1 if user allows given key */
int
user_dsa_key_allowed(struct passwd *pw, Key *key)
{
	char line[8192], file[1024];
	int found_key = 0;
	unsigned int bits = -1;
	FILE *f;
	unsigned long linenum = 0;
	struct stat st;
	Key *found;

	/* Temporarily use the user's uid. */
	temporarily_use_uid(pw->pw_uid);

	/* The authorized keys. */
	snprintf(file, sizeof file, "%.500s/%.100s", pw->pw_dir,
	    SSH_USER_PERMITTED_KEYS2);

	/* Fail quietly if file does not exist */
	if (stat(file, &st) < 0) {
		/* Restore the privileged uid. */
		restore_uid();
		return 0;
	}
	/* Open the file containing the authorized keys. */
	f = fopen(file, "r");
	if (!f) {
		/* Restore the privileged uid. */
		restore_uid();
		packet_send_debug("Could not open %.900s for reading.", file);
		packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
		return 0;
	}
	if (options.strict_modes) {
		int fail = 0;
		char buf[1024];
		/* Check open file in order to avoid open/stat races */
		if (fstat(fileno(f), &st) < 0 ||
		    (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		    (st.st_mode & 022) != 0) {
			snprintf(buf, sizeof buf, "DSA authentication refused for %.100s: "
			    "bad ownership or modes for '%s'.", pw->pw_name, file);
			fail = 1;
		} else {
			/* Check path to SSH_USER_PERMITTED_KEYS */
			int i;
			static const char *check[] = {
				"", SSH_USER_DIR, NULL
			};
			for (i = 0; check[i]; i++) {
				snprintf(line, sizeof line, "%.500s/%.100s",
				    pw->pw_dir, check[i]);
				if (stat(line, &st) < 0 ||
				    (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
				    (st.st_mode & 022) != 0) {
					snprintf(buf, sizeof buf,
					    "DSA authentication refused for %.100s: "
					    "bad ownership or modes for '%s'.",
					    pw->pw_name, line);
					fail = 1;
					break;
				}
			}
		}
		if (fail) {
			log(buf);
			fclose(f);
			restore_uid();
			return 0;
		}
	}
	found_key = 0;
	found = key_new(KEY_DSA);

	while (fgets(line, sizeof(line), f)) {
		char *cp;
		linenum++;
		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#')
			continue;
		bits = key_read(found, &cp);
		if (bits == 0)
			continue;
		if (key_equal(found, key)) {
			found_key = 1;
			debug("matching key found: file %s, line %ld",
			    file, linenum);
			break;
		}
	}
	restore_uid();
	fclose(f);
	key_free(found);
	return found_key;
@


1.4
log
@whitespace cleanup
@
text
@d8 5
a12 1
RCSID("$OpenBSD: auth.c,v 1.3 2000/04/14 10:09:14 markus Exp $");
a25 1

d32 5
d51 1
a51 1
static int
d121 4
d574 6
d581 12
a592 3
void input_service_request(int type, int plen);
void input_userauth_request(int type, int plen);
void ssh2_pty_cleanup(void);
d604 2
d611 1
d648 14
a661 1
static void
d670 1
d699 1
d704 3
a706 3
	unsigned int len;
	int c, authenticated = 0;
	char *user, *service, *method;
d712 3
d723 2
a724 3
		if (strcmp(method, "none") == 0 && try == 1) {
			packet_done();
			authenticated = auth_password(pw, "");
d726 1
a726 9
			char *password;
			c = packet_get_char();
			if (c)
				debug("password change not supported");
			password = packet_get_string(&len);
			packet_done();
			authenticated = auth_password(pw, password);
			memset(password, 0, len);
			xfree(password);
d728 1
a728 16
			/* XXX TODO */
			char *pkalg, *pkblob, *sig;
			int have_sig = packet_get_char();
			pkalg = packet_get_string(&len);
			pkblob = packet_get_string(&len);
			if (have_sig) {
				sig = packet_get_string(&len);
				/* test for correct signature */
				packet_done();
				xfree(sig);
			} else {
				packet_done();
				/* test whether pkalg/pkblob are acceptable */
			}
			xfree(pkalg);
			xfree(pkblob);
d732 2
a733 1
	if (authenticated) {
a738 1
		log("userauth success for %s", user);
d741 2
a742 1
	} else {
d744 2
a745 2
		packet_put_cstring("password");
		packet_put_char(0);		/* partial success */
d748 2
d755 28
a782 2
void
do_authentication2()
d784 151
a934 4
	dispatch_init(&protocol_error);
	dispatch_set(SSH2_MSG_SERVICE_REQUEST, &input_service_request);
	dispatch_run(DISPATCH_BLOCK, &userauth_success);
	do_authenticated2();
@


1.3
log
@check payload for (illegal) extra data
@
text
@d8 1
a8 1
RCSID("$OpenBSD: auth.c,v 1.2 2000/04/06 08:55:22 markus Exp $");
d39 1
a39 1
 * returned. 
d41 1
a41 1
 * Otherwise true is returned. 
d187 4
a190 4
			           options.password_authentication &&
			           (password = packet_get_string(&dlen)) != NULL &&
			           dlen == 5 &&
			           strncasecmp(password, "s/key", 5) == 0 ) {
d440 15
a454 15
 
 		/*
 		 * Check if the user is logging in as root and root logins
 		 * are disallowed.
 		 * Note that root login is allowed for forced commands.
 		 */
 		if (authenticated && pw->pw_uid == 0 && !options.permit_root_login) {
 			if (forced_command) {
 				log("Root login accepted for forced command.");
 			} else {
 				authenticated = 0;
 				log("ROOT LOGIN REFUSED FROM %.200s",
 				    get_canonical_hostname());
 			}
  		}
d728 1
a728 1
void 
@


1.2
log
@ssh2 server side, see README.openssh2; enable with 'sshd -2'
@
text
@d8 1
a8 1
RCSID("$OpenBSD: auth.c,v 1.1 2000/03/28 21:15:45 markus Exp $");
d633 1
d676 1
d684 1
d690 2
a691 3
			char *pkalg;
			char *pkblob;
			c = packet_get_char();
d694 9
a710 1
		/* success! */
@


1.1
log
@split sshd.c -> auth.c session.c sshd.c plus cleanup and goto-removal
@
text
@d4 1
d8 1
a8 1
RCSID("$OpenBSD: auth.c,v 1.11 2000/03/16 23:14:37 markus Exp $");
d19 1
d23 3
d29 1
d560 165
@

