head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.8
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.4
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.2
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.30
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.28
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.26
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.24
	OPENBSD_5_0:1.35.0.22
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.20
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.18
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.14
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.16
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.12
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.10
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.8
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.6
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.24.0.12
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.10
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.8
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.6
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.39
date	2015.06.24.01.49.19;	author dtucker;	state Exp;
branches;
next	1.38;
commitid	Gg3Q30fNXgAMZ5CJ;

1.38
date	2015.06.22.12.29.57;	author dtucker;	state Exp;
branches;
next	1.37;
commitid	g4adbaadX8f0YVOv;

1.37
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2013.11.08.11.15.19;	author dtucker;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.17.01.31.10;	author stevesk;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.08.14.45.49;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.06.10.20.20;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.22.04.06.51;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.25.13.17.03;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.19.18.51.19;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.29.16.58.45;	author deraadt;	state Exp;
branches
	1.24.10.1
	1.24.12.1;
next	1.23;

1.23
date	2002.07.15.17.15.31;	author stevesk;	state Exp;
branches
	1.23.2.1
	1.23.4.1;
next	1.22;

1.22
date	2002.05.28.21.24.00;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.28.17.28.02;	author stevesk;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.01.21.50.51;	author stevesk;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.08.21.34.19;	author markus;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.08.08.18.20.15;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.20.16.32.22;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.04.08.11.24.33;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.06.21.00.16;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.21.19.06.01;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.29.10.48.56;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.20.19.37.22;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.17.09.33.40;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.07.20.27.55;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.08.28.03.50.54;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.20.01.39.45;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.14.10.30.34;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.11.24.19.53.54;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.11.24.00.26.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.11.23.22.25.56;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.09.30.08.34.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.38;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2000.09.01.18.23.25;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.11.08.21.31.36;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.03.12.15.44.18;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.21.18.53.19;	author jason;	state Exp;
branches;
next	;

1.9.2.1
date	2001.02.16.20.13.24;	author jason;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.02.19.17.19.42;	author jason;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.03.21.19.46.32;	author jason;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.05.07.21.09.39;	author jason;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2001.09.27.00.15.43;	author miod;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2002.03.08.17.04.44;	author brad;	state Exp;
branches;
next	;

1.16.2.1
date	2001.09.27.19.03.56;	author jason;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.18.2.1
date	2002.03.07.17.37.48;	author jason;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.05.17.00.03.25;	author miod;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	;

1.23.2.1
date	2003.09.16.21.20.29;	author brad;	state Exp;
branches;
next	;

1.23.4.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2004.03.04.18.18.17;	author brad;	state Exp;
branches;
next	;

1.24.10.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.24.12.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Revert previous commit.  We still want to call setgroups in the case where
there are zero groups to remove any that we might otherwise inherit (as
pointed out by grawity at gmail.com) and since the 2nd argument to
setgroups is always a static global it's always valid to dereference in
this case.  ok deraadt@@ djm@@
@
text
@/* $OpenBSD: uidswap.c,v 1.37 2015/01/16 06:40:12 deraadt Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Code for uid-swapping.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <errno.h>
#include <pwd.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>
#include <stdlib.h>

#include "log.h"
#include "uidswap.h"

/*
 * Note: all these functions must work in all of the following cases:
 *    1. euid=0, ruid=0
 *    2. euid=0, ruid!=0
 *    3. euid!=0, ruid!=0
 * Additionally, they must work regardless of whether the system has
 * POSIX saved uids or not.
 */

/* Lets assume that posix saved ids also work with seteuid, even though that
   is not part of the posix specification. */

/* Saved effective uid. */
static int	privileged = 0;
static int	temporarily_use_uid_effective = 0;
static uid_t	saved_euid = 0;
static gid_t	saved_egid;
static gid_t	saved_egroups[NGROUPS_MAX], user_groups[NGROUPS_MAX];
static int	saved_egroupslen = -1, user_groupslen = -1;

/*
 * Temporarily changes to the given uid.  If the effective user
 * id is not root, this does nothing.  This call cannot be nested.
 */
void
temporarily_use_uid(struct passwd *pw)
{
	/* Save the current euid, and egroups. */
	saved_euid = geteuid();
	saved_egid = getegid();
	debug("temporarily_use_uid: %u/%u (e=%u/%u)",
	    (u_int)pw->pw_uid, (u_int)pw->pw_gid,
	    (u_int)saved_euid, (u_int)saved_egid);
	if (saved_euid != 0) {
		privileged = 0;
		return;
	}
	privileged = 1;
	temporarily_use_uid_effective = 1;
	saved_egroupslen = getgroups(NGROUPS_MAX, saved_egroups);
	if (saved_egroupslen < 0)
		fatal("getgroups: %.100s", strerror(errno));

	/* set and save the user's groups */
	if (user_groupslen == -1) {
		if (initgroups(pw->pw_name, pw->pw_gid) < 0)
			fatal("initgroups: %s: %.100s", pw->pw_name,
			    strerror(errno));
		user_groupslen = getgroups(NGROUPS_MAX, user_groups);
		if (user_groupslen < 0)
			fatal("getgroups: %.100s", strerror(errno));
	}
	/* Set the effective uid to the given (unprivileged) uid. */
	if (setgroups(user_groupslen, user_groups) < 0)
		fatal("setgroups: %.100s", strerror(errno));
	if (setegid(pw->pw_gid) < 0)
		fatal("setegid %u: %.100s", (u_int)pw->pw_gid,
		    strerror(errno));
	if (seteuid(pw->pw_uid) == -1)
		fatal("seteuid %u: %.100s", (u_int)pw->pw_uid,
		    strerror(errno));
}

/*
 * Restores to the original (privileged) uid.
 */
void
restore_uid(void)
{
	/* it's a no-op unless privileged */
	if (!privileged) {
		debug("restore_uid: (unprivileged)");
		return;
	}
	if (!temporarily_use_uid_effective)
		fatal("restore_uid: temporarily_use_uid not effective");
	debug("restore_uid: %u/%u", (u_int)saved_euid, (u_int)saved_egid);
	/* Set the effective uid back to the saved privileged uid. */
	if (seteuid(saved_euid) < 0)
		fatal("seteuid %u: %.100s", (u_int)saved_euid, strerror(errno));
	if (setgroups(saved_egroupslen, saved_egroups) < 0)
		fatal("setgroups: %.100s", strerror(errno));
	if (setegid(saved_egid) < 0)
		fatal("setegid %u: %.100s", (u_int)saved_egid, strerror(errno));
	temporarily_use_uid_effective = 0;
}

/*
 * Permanently sets all uids to the given uid.  This cannot be
 * called while temporarily_use_uid is effective.
 */
void
permanently_set_uid(struct passwd *pw)
{
	if (temporarily_use_uid_effective)
		fatal("permanently_set_uid: temporarily_use_uid effective");
	debug("permanently_set_uid: %u/%u", (u_int)pw->pw_uid,
	    (u_int)pw->pw_gid);
	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0)
		fatal("setresgid %u: %s", (u_int)pw->pw_gid, strerror(errno));
	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0)
		fatal("setresuid %u: %s", (u_int)pw->pw_uid, strerror(errno));
}

void
permanently_drop_suid(uid_t uid)
{
	debug("permanently_drop_suid: %u", (u_int)uid);
	if (setresuid(uid, uid, uid) != 0)
		fatal("setresuid %u: %s", (u_int)uid, strerror(errno));
}
@


1.38
log
@Don't call setgroups if we have zero groups; there's no guarantee that it
won't try to deref the pointer.  Based on a patch from mail at quitesimple.org,
ok djm deraadt
@
text
@d79 1
a79 1
	if (user_groupslen > 0 && setgroups(user_groupslen, user_groups) < 0)
d106 1
a106 2
	if (saved_egroupslen > 0 &&
	    setgroups(saved_egroupslen, saved_egroups) < 0)
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.36 2013/11/08 11:15:19 dtucker Exp $ */
d79 1
a79 1
	if (setgroups(user_groupslen, user_groups) < 0)
d106 2
a107 1
	if (setgroups(saved_egroupslen, saved_egroups) < 0)
@


1.36
log
@Include stdlib.h for free() as per the man page.
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.35 2006/08/03 03:34:42 deraadt Exp $ */
a14 1
#include <sys/param.h>
d19 1
@


1.35
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.34 2006/07/26 02:35:17 stevesk Exp $ */
d21 1
@


1.34
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.33 2006/07/22 20:48:23 stevesk Exp $ */
a14 3
#include "includes.h"

#include <sys/types.h>
a15 1

d20 1
@


1.33
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.32 2006/07/17 01:31:10 stevesk Exp $ */
d18 1
@


1.32
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.31 2006/07/11 20:07:25 stevesk Exp $ */
d21 1
@


1.31
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.30 2006/07/06 16:03:53 stevesk Exp $ */
d21 1
@


1.30
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.29 2006/06/08 14:45:49 markus Exp $ */
d19 1
@


1.29
log
@do not set the gid, noted by solar; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.28 2006/06/06 10:20:20 markus Exp $ */
d16 4
@


1.28
log
@replace remaining setuid() calls with permanently_set_uid() and
check seteuid() return values; report Marcus Meissner; ok dtucker djm
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.27 2006/04/22 04:06:51 djm Exp $ */
a113 2
	if (pw == NULL)
		fatal("permanently_set_uid: no user given");
d122 8
@


1.27
log
@use setres[ug]id() to permanently revoke privileges; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: uidswap.c,v 1.26 2006/03/25 13:17:03 djm Exp $ */
d114 2
@


1.26
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d118 4
a121 8
	if (setegid(pw->pw_gid) < 0)
		fatal("setegid %u: %.100s", (u_int)pw->pw_gid, strerror(errno));
	if (setgid(pw->pw_gid) < 0)
		fatal("setgid %u: %.100s", (u_int)pw->pw_gid, strerror(errno));
	if (seteuid(pw->pw_uid) < 0)
		fatal("seteuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
	if (setuid(pw->pw_uid) < 0)
		fatal("setuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
@


1.25
log
@RCSID() can die
@
text
@d1 1
@


1.24
log
@seteuid and setegid; markus ok
@
text
@a14 1
RCSID("$OpenBSD: uidswap.c,v 1.23 2002/07/15 17:15:31 stevesk Exp $");
@


1.24.10.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: uidswap.c,v 1.35 2006/08/03 03:34:42 deraadt Exp $ */
d14 2
a15 6
#include <sys/param.h>
#include <errno.h>
#include <pwd.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
d118 8
a125 12
	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0)
		fatal("setresgid %u: %s", (u_int)pw->pw_gid, strerror(errno));
	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0)
		fatal("setresuid %u: %s", (u_int)pw->pw_uid, strerror(errno));
}

void
permanently_drop_suid(uid_t uid)
{
	debug("permanently_drop_suid: %u", (u_int)uid);
	if (setresuid(uid, uid, uid) != 0)
		fatal("setresuid %u: %s", (u_int)uid, strerror(errno));
@


1.24.12.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: uidswap.c,v 1.35 2006/08/03 03:34:42 deraadt Exp $ */
d14 2
a15 6
#include <sys/param.h>
#include <errno.h>
#include <pwd.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
d118 8
a125 12
	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0)
		fatal("setresgid %u: %s", (u_int)pw->pw_gid, strerror(errno));
	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0)
		fatal("setresuid %u: %s", (u_int)pw->pw_uid, strerror(errno));
}

void
permanently_drop_suid(uid_t uid)
{
	debug("permanently_drop_suid: %u", (u_int)uid);
	if (setresuid(uid, uid, uid) != 0)
		fatal("setresuid %u: %s", (u_int)uid, strerror(errno));
@


1.23
log
@little more debugging; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.22 2002/05/28 21:24:00 stevesk Exp $");
d118 2
d122 2
@


1.23.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.24 2003/05/29 16:58:45 deraadt Exp $");
a117 2
	if (setegid(pw->pw_gid) < 0)
		fatal("setegid %u: %.100s", (u_int)pw->pw_gid, strerror(errno));
a119 2
	if (seteuid(pw->pw_uid) < 0)
		fatal("seteuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
@


1.23.4.1
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.24 2003/05/29 16:58:45 deraadt Exp $");
a117 2
	if (setegid(pw->pw_gid) < 0)
		fatal("setegid %u: %.100s", (u_int)pw->pw_gid, strerror(errno));
a119 2
	if (seteuid(pw->pw_uid) < 0)
		fatal("seteuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
@


1.23.4.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@@


1.22
log
@use correct function name in fatal()
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.21 2002/05/28 17:28:02 stevesk Exp $");
d49 4
a52 2
	debug("temporarily_use_uid: %u/%u (e=%u)",
	    (u_int)pw->pw_uid, (u_int)pw->pw_gid, (u_int)saved_euid);
a58 1
	saved_egid = getegid();
a88 1
	debug("restore_uid");
d90 2
a91 1
	if (!privileged)
d93 1
d96 1
d116 2
@


1.21
log
@format spec change/casts and some KNF; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.20 2002/04/01 21:50:51 stevesk Exp $");
d112 1
a112 1
		fatal("restore_uid: temporarily_use_uid effective");
@


1.20
log
@typo: assign to self; ok markus@@ solar@@openwall.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.19 2001/12/19 07:18:56 deraadt Exp $");
d49 2
a50 2
	debug("temporarily_use_uid: %d/%d (e=%d)",
	    pw->pw_uid, pw->pw_gid, saved_euid);
d75 1
a75 1
		fatal("setegid %u: %.100s", (u_int) pw->pw_gid,
d78 1
a78 1
		fatal("seteuid %u: %.100s", (u_int) pw->pw_uid,
d96 1
a96 1
		fatal("seteuid %u: %.100s", (u_int) saved_euid, strerror(errno));
d100 1
a100 1
		fatal("setegid %u: %.100s", (u_int) saved_egid, strerror(errno));
d114 1
a114 1
		fatal("setgid %u: %.100s", (u_int) pw->pw_gid, strerror(errno));
d116 1
a116 1
		fatal("setuid %u: %.100s", (u_int) pw->pw_uid, strerror(errno));
@


1.20.2.1
log
@Pull in OpenSSH-3.4
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.22 2002/05/28 21:24:00 stevesk Exp $");
d49 2
a50 2
	debug("temporarily_use_uid: %u/%u (e=%u)",
	    (u_int)pw->pw_uid, (u_int)pw->pw_gid, (u_int)saved_euid);
d75 1
a75 1
		fatal("setegid %u: %.100s", (u_int)pw->pw_gid,
d78 1
a78 1
		fatal("seteuid %u: %.100s", (u_int)pw->pw_uid,
d96 1
a96 1
		fatal("seteuid %u: %.100s", (u_int)saved_euid, strerror(errno));
d100 1
a100 1
		fatal("setegid %u: %.100s", (u_int)saved_egid, strerror(errno));
d112 1
a112 1
		fatal("permanently_set_uid: temporarily_use_uid effective");
d114 1
a114 1
		fatal("setgid %u: %.100s", (u_int)pw->pw_gid, strerror(errno));
d116 1
a116 1
		fatal("setuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
@


1.20.2.2
log
@Update to OpenSSH 3.5
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.23 2002/07/15 17:15:31 stevesk Exp $");
d49 2
a50 4
	saved_egid = getegid();
	debug("temporarily_use_uid: %u/%u (e=%u/%u)",
	    (u_int)pw->pw_uid, (u_int)pw->pw_gid,
	    (u_int)saved_euid, (u_int)saved_egid);
d57 1
d88 1
d90 1
a90 2
	if (!privileged) {
		debug("restore_uid: (unprivileged)");
a91 1
	}
a93 1
	debug("restore_uid: %u/%u", (u_int)saved_euid, (u_int)saved_egid);
a112 2
	debug("permanently_set_uid: %u/%u", (u_int)pw->pw_uid,
	    (u_int)pw->pw_gid);
@


1.19
log
@basic KNF done while i was looking for something else
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.18 2001/08/08 21:34:19 markus Exp $");
a73 1
	pw->pw_gid = pw->pw_gid;
@


1.18
log
@undo last change; does not work for sshd
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.16 2001/04/20 16:32:22 markus Exp $");
d57 2
a58 2
	saved_egid = getegid();                                                       
	saved_egroupslen = getgroups(NGROUPS_MAX, saved_egroups);                           
d67 1
a67 1
		user_groupslen = getgroups(NGROUPS_MAX, user_groups);                           
@


1.18.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.19 2001/12/19 07:18:56 deraadt Exp $");
d57 2
a58 2
	saved_egid = getegid();
	saved_egroupslen = getgroups(NGROUPS_MAX, saved_egroups);
d67 1
a67 1
		user_groupslen = getgroups(NGROUPS_MAX, user_groups);
@


1.18.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.20 2002/04/01 21:50:51 stevesk Exp $");
d74 1
@


1.18.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.18.2.2 2002/05/17 00:03:25 miod Exp $");
d49 2
a50 2
	debug("temporarily_use_uid: %u/%u (e=%u)",
	    (u_int)pw->pw_uid, (u_int)pw->pw_gid, (u_int)saved_euid);
d75 1
a75 1
		fatal("setegid %u: %.100s", (u_int)pw->pw_gid,
d78 1
a78 1
		fatal("seteuid %u: %.100s", (u_int)pw->pw_uid,
d96 1
a96 1
		fatal("seteuid %u: %.100s", (u_int)saved_euid, strerror(errno));
d100 1
a100 1
		fatal("setegid %u: %.100s", (u_int)saved_egid, strerror(errno));
d112 1
a112 1
		fatal("permanently_set_uid: temporarily_use_uid effective");
d114 1
a114 1
		fatal("setgid %u: %.100s", (u_int)pw->pw_gid, strerror(errno));
d116 1
a116 1
		fatal("setuid %u: %.100s", (u_int)pw->pw_uid, strerror(errno));
@


1.18.2.4
log
@Update to OpenSSH 3.5
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.23 2002/07/15 17:15:31 stevesk Exp $");
d49 2
a50 4
	saved_egid = getegid();
	debug("temporarily_use_uid: %u/%u (e=%u/%u)",
	    (u_int)pw->pw_uid, (u_int)pw->pw_gid,
	    (u_int)saved_euid, (u_int)saved_egid);
d57 1
d88 1
d90 1
a90 2
	if (!privileged) {
		debug("restore_uid: (unprivileged)");
a91 1
	}
a93 1
	debug("restore_uid: %u/%u", (u_int)saved_euid, (u_int)saved_egid);
a112 2
	debug("permanently_set_uid: %u/%u", (u_int)pw->pw_uid,
	    (u_int)pw->pw_gid);
@


1.17
log
@permanently_set_uid is a noop if user is not privilegued;
fixes bug on solaris; from sbi@@uchicago.edu
@
text
@a111 3
	/* it's a no-op unless privileged */
	if (!privileged)
		return;
@


1.16
log
@set non-privileged gid before uid; tholo@@ and deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.15 2001/04/08 11:24:33 markus Exp $");
d112 3
@


1.16.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.18 2001/08/08 21:34:19 markus Exp $");
@


1.16.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.19 2001/12/19 07:18:56 deraadt Exp $");
d57 2
a58 2
	saved_egid = getegid();
	saved_egroupslen = getgroups(NGROUPS_MAX, saved_egroups);
d67 1
a67 1
		user_groupslen = getgroups(NGROUPS_MAX, user_groups);
@


1.16.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.20 2002/04/01 21:50:51 stevesk Exp $");
d74 1
@


1.15
log
@KNF
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.14 2001/04/06 21:00:16 markus Exp $");
d84 1
a84 1
 * Restores to the original uid.
d95 1
a95 1
	/* Set the effective uid back to the saved uid. */
d114 2
a117 2
	if (setgid(pw->pw_gid) < 0)
		fatal("setgid %u: %.100s", (u_int) pw->pw_gid, strerror(errno));
@


1.14
log
@do gid/groups-swap in addition to uid-swap, should help if /home/group
is chmod 750 + chgrp grp /home/group/, work be deraadt and me, thanks
to olar@@openwall.com is comments.  we had many requests for this.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.13 2001/01/21 19:06:01 markus Exp $");
d57 2
a58 2
        saved_egid = getegid();                                                       
        saved_egroupslen = getgroups(NGROUPS_MAX, saved_egroups);                           
d72 1
a72 1
        if (setgroups(user_groupslen, user_groups) < 0)
d74 2
a75 2
        pw->pw_gid = pw->pw_gid;
        if (setegid(pw->pw_gid) < 0)
d98 1
a98 1
        if (setgroups(saved_egroupslen, saved_egroups) < 0)
d100 1
a100 1
        if (setegid(saved_egid) < 0)
@


1.13
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.12 2000/12/29 10:48:56 markus Exp $");
a28 1
#ifdef _POSIX_SAVED_IDS
d31 1
a31 1
#define SAVED_IDS_WORK_WITH_SETEUID
d33 6
a38 2
static uid_t saved_euid = 0;
#endif /* _POSIX_SAVED_IDS */
d45 1
a45 1
temporarily_use_uid(uid_t uid)
d47 1
a47 2
#ifdef SAVED_IDS_WORK_WITH_SETEUID
	/* Save the current euid. */
d49 22
a70 9

	/* Set the effective uid to the given (unprivileged) uid. */
	if (seteuid(uid) == -1)
		debug("seteuid %u: %.100s", (u_int) uid, strerror(errno));
#else /* SAVED_IDS_WORK_WITH_SETEUID */
	/* Propagate the privileged uid to all of our uids. */
	if (setuid(geteuid()) < 0)
		debug("setuid %u: %.100s", (u_int) geteuid(), strerror(errno));

d72 9
a80 3
	if (seteuid(uid) == -1)
		debug("seteuid %u: %.100s", (u_int) uid, strerror(errno));
#endif /* SAVED_IDS_WORK_WITH_SETEUID */
d89 6
a94 1
#ifdef SAVED_IDS_WORK_WITH_SETEUID
d97 6
a102 9
		debug("seteuid %u: %.100s", (u_int) saved_euid, strerror(errno));
#else /* SAVED_IDS_WORK_WITH_SETEUID */
	/*
	 * We are unable to restore the real uid to its unprivileged value.
	 * Propagate the real uid (usually more privileged) to effective uid
	 * as well.
	 */
	setuid(getuid());
#endif /* SAVED_IDS_WORK_WITH_SETEUID */
d110 1
a110 1
permanently_set_uid(uid_t uid)
d112 6
a117 2
	if (setuid(uid) < 0)
		debug("setuid %u: %.100s", (u_int) uid, strerror(errno));
@


1.12
log
@sync with portable openssh; stevesk@@pobox.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.11 2000/12/20 19:37:22 markus Exp $");
d17 1
a17 1
#include "ssh.h"
@


1.11
log
@fix prototypes; from  stevesk@@pobox.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.10 2000/12/17 09:33:40 markus Exp $");
a32 2
#endif /* _POSIX_SAVED_IDS */

d35 1
@


1.10
log
@typo; from wsanchez@@apple.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.9 2000/09/07 20:27:55 deraadt Exp $");
d67 1
a67 1
restore_uid()
@


1.9
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.8 2000/08/28 03:50:54 deraadt Exp $");
d52 1
a52 1
#else /* SAVED_IDS_WORK_WITH_SETUID */
@


1.9.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.13 2001/01/21 19:06:01 markus Exp $");
d17 1
a17 1
#include "log.h"
d33 2
a36 1
#endif /* _POSIX_SAVED_IDS */
d52 1
a52 1
#else /* SAVED_IDS_WORK_WITH_SETEUID */
d67 1
a67 1
restore_uid(void)
@


1.9.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.9.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.9.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.16 2001/04/20 16:32:22 markus Exp $");
d29 1
d32 1
a32 1

d34 2
a35 6
static int	privileged = 0;
static int	temporarily_use_uid_effective = 0;
static uid_t	saved_euid = 0;
static gid_t	saved_egid;
static gid_t	saved_egroups[NGROUPS_MAX], user_groups[NGROUPS_MAX];
static int	saved_egroupslen = -1, user_groupslen = -1;
d42 1
a42 1
temporarily_use_uid(struct passwd *pw)
d44 2
a45 1
	/* Save the current euid, and egroups. */
d47 9
a55 22
	debug("temporarily_use_uid: %d/%d (e=%d)",
	    pw->pw_uid, pw->pw_gid, saved_euid);
	if (saved_euid != 0) {
		privileged = 0;
		return;
	}
	privileged = 1;
	temporarily_use_uid_effective = 1;
	saved_egid = getegid();                                                       
	saved_egroupslen = getgroups(NGROUPS_MAX, saved_egroups);                           
	if (saved_egroupslen < 0)
		fatal("getgroups: %.100s", strerror(errno));

	/* set and save the user's groups */
	if (user_groupslen == -1) {
		if (initgroups(pw->pw_name, pw->pw_gid) < 0)
			fatal("initgroups: %s: %.100s", pw->pw_name,
			    strerror(errno));
		user_groupslen = getgroups(NGROUPS_MAX, user_groups);                           
		if (user_groupslen < 0)
			fatal("getgroups: %.100s", strerror(errno));
	}
d57 3
a59 9
	if (setgroups(user_groupslen, user_groups) < 0)
		fatal("setgroups: %.100s", strerror(errno));
	pw->pw_gid = pw->pw_gid;
	if (setegid(pw->pw_gid) < 0)
		fatal("setegid %u: %.100s", (u_int) pw->pw_gid,
		    strerror(errno));
	if (seteuid(pw->pw_uid) == -1)
		fatal("seteuid %u: %.100s", (u_int) pw->pw_uid,
		    strerror(errno));
d63 1
a63 1
 * Restores to the original (privileged) uid.
d68 2
a69 7
	debug("restore_uid");
	/* it's a no-op unless privileged */
	if (!privileged)
		return;
	if (!temporarily_use_uid_effective)
		fatal("restore_uid: temporarily_use_uid not effective");
	/* Set the effective uid back to the saved privileged uid. */
d71 9
a79 6
		fatal("seteuid %u: %.100s", (u_int) saved_euid, strerror(errno));
	if (setgroups(saved_egroupslen, saved_egroups) < 0)
		fatal("setgroups: %.100s", strerror(errno));
	if (setegid(saved_egid) < 0)
		fatal("setegid %u: %.100s", (u_int) saved_egid, strerror(errno));
	temporarily_use_uid_effective = 0;
d87 1
a87 1
permanently_set_uid(struct passwd *pw)
d89 2
a90 6
	if (temporarily_use_uid_effective)
		fatal("restore_uid: temporarily_use_uid effective");
	if (setgid(pw->pw_gid) < 0)
		fatal("setgid %u: %.100s", (u_int) pw->pw_gid, strerror(errno));
	if (setuid(pw->pw_uid) < 0)
		fatal("setuid %u: %.100s", (u_int) pw->pw_uid, strerror(errno));
@


1.9.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.18 2001/08/08 21:34:19 markus Exp $");
@


1.9.2.6
log
@Merge OpenSSH 3.1.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.19 2001/12/19 07:18:56 deraadt Exp $");
d57 2
a58 2
	saved_egid = getegid();
	saved_egroupslen = getgroups(NGROUPS_MAX, saved_egroups);
d67 1
a67 1
		user_groupslen = getgroups(NGROUPS_MAX, user_groups);
@


1.8
log
@print uid/gid as unsigned
@
text
@a4 1
 * Created: Sat Sep  9 01:56:14 1995 ylo
d6 6
d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.7 2000/06/20 01:39:45 markus Exp $");
@


1.7
log
@OpenBSD tag
@
text
@d10 1
a10 1
RCSID("$OpenBSD: uidswap.c,v 1.6 2000/04/14 10:30:34 markus Exp $");
d46 1
a46 1
		debug("seteuid %d: %.100s", (int) uid, strerror(errno));
d50 1
a50 1
		debug("setuid %d: %.100s", (int) geteuid(), strerror(errno));
d54 1
a54 1
		debug("seteuid %d: %.100s", (int) uid, strerror(errno));
d67 1
a67 1
		debug("seteuid %d: %.100s", (int) saved_euid, strerror(errno));
d86 1
a86 1
		debug("setuid %d: %.100s", (int) uid, strerror(errno));
@


1.6
log
@whitespace cleanup
@
text
@d10 1
a10 1
RCSID("$Id: uidswap.c,v 1.5 1999/11/24 19:53:54 markus Exp $");
@


1.6.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d10 1
a10 1
RCSID("$OpenBSD: uidswap.c,v 1.8 2000/08/28 03:50:54 deraadt Exp $");
d46 1
a46 1
		debug("seteuid %u: %.100s", (u_int) uid, strerror(errno));
d50 1
a50 1
		debug("setuid %u: %.100s", (u_int) geteuid(), strerror(errno));
d54 1
a54 1
		debug("seteuid %u: %.100s", (u_int) uid, strerror(errno));
d67 1
a67 1
		debug("seteuid %u: %.100s", (u_int) saved_euid, strerror(errno));
d86 1
a86 1
		debug("setuid %u: %.100s", (u_int) uid, strerror(errno));
@


1.6.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
a6 6
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d10 1
a10 1
RCSID("$OpenBSD: uidswap.c,v 1.9 2000/09/07 20:27:55 deraadt Exp $");
@


1.6.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: uidswap.c,v 1.13 2001/01/21 19:06:01 markus Exp $");
d17 1
a17 1
#include "log.h"
d33 2
a36 1
#endif /* _POSIX_SAVED_IDS */
d52 1
a52 1
#else /* SAVED_IDS_WORK_WITH_SETEUID */
d67 1
a67 1
restore_uid(void)
@


1.6.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.5
log
@KNF, final part 3
@
text
@d10 1
a10 1
RCSID("$Id: uidswap.c,v 1.4 1999/11/24 00:26:04 deraadt Exp $");
d37 1
a37 1
void 
d61 1
a61 1
void 
d82 1
a82 1
void 
@


1.4
log
@much more KNF
@
text
@d10 1
a10 1
RCSID("$Id: uidswap.c,v 1.3 1999/11/23 22:25:56 markus Exp $");
d69 5
a73 4
	/* We are unable to restore the real uid to its unprivileged
	   value. */
	/* Propagate the real uid (usually more privileged) to effective
	   uid as well. */
@


1.3
log
@KNF part 1
@
text
@d2 6
a7 13

uidswap.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Sep  9 01:56:14 1995 ylo

Code for uid-swapping.

*/
d10 1
a10 1
RCSID("$Id: uidswap.c,v 1.2 1999/09/30 08:34:25 deraadt Exp $");
d15 8
a22 8
/* Note: all these functions must work in all of the following cases:

   1. euid=0, ruid=0
   2. euid=0, ruid!=0
   3. euid!=0, ruid!=0

   Additionally, they must work regardless of whether the system has
   POSIX saved uids or not. */
d33 4
a36 3
/* Temporarily changes to the given uid.  If the effective user id is not
   root, this does nothing.  This call cannot be nested. */

d58 3
a60 2
/* Restores to the original uid. */

d77 4
a80 3
/* Permanently sets all uids to the given uid.  This cannot be called while
   temporarily_use_uid is effective. */

@


1.2
log
@even smaller
@
text
@d17 1
a17 1
RCSID("$Id: uidswap.c,v 1.1 1999/09/26 20:53:38 deraadt Exp $");
d43 2
a44 1
void temporarily_use_uid(uid_t uid)
d47 2
d50 3
a52 7
  /* Save the current euid. */
  saved_euid = geteuid();

  /* Set the effective uid to the given (unprivileged) uid. */
  if (seteuid(uid) == -1)
    debug("seteuid %d: %.100s", (int)uid, strerror(errno));

d54 7
a60 9

  /* Propagate the privileged uid to all of our uids. */
  if (setuid(geteuid()) < 0)
    debug("setuid %d: %.100s", (int)geteuid(), strerror(errno));

  /* Set the effective uid to the given (unprivileged) uid. */
  if (seteuid(uid) == -1)
    debug("seteuid %d: %.100s", (int)uid, strerror(errno));

a61 1

d66 2
a67 1
void restore_uid()
d70 3
a72 5

  /* Set the effective uid back to the saved uid. */
  if (seteuid(saved_euid) < 0)
    debug("seteuid %d: %.100s", (int)saved_euid, strerror(errno));

d74 5
a78 6

  /* We are unable to restore the real uid to its unprivileged value. */
  /* Propagate the real uid (usually more privileged) to effective uid
     as well. */
  setuid(getuid());

d85 2
a86 1
void permanently_set_uid(uid_t uid)
d88 2
a89 2
  if (setuid(uid) < 0)
    debug("setuid %d: %.100s", (int)uid, strerror(errno));
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d17 1
a17 1
RCSID("$Id: uidswap.c,v 1.2 1999/05/04 11:59:27 bg Exp $");
a30 2
#ifdef HAVE_SETEUID

a95 29

#else /* HAVE_SETEUID */

YOUR_SYSTEM_DOES_NOT_PERMIT_UID_SWAPPING_READ_AND_EDIT_UIDSWAP_C;
/* If we ever come here, if means that your system does not support any of
   the uid swapping methods we are aware of.  Tough.  This means that
   ssh will have to read certain files as root, which causes some security
   problems.  Unless your are very concerned about security, you can
   comment out the above line.  The effect is that local users on your
   machine might be able to read each other's files.  Also, you may encounter
   problems if home directories are on a NFS volume.  You may also
   encounter other problems; please don't complain unless you have some idea
   how to fix it. */

void temporarily_use_uid(uid_t uid)
{
}

void restore_uid()
{
}

void permanently_set_uid(uid_t uid)
{
  if (setuid(uid) < 0)
    debug("setuid %d: %.100s", (int)uid, strerror(errno));
}

#endif /* HAVE_SETEUID */
@

