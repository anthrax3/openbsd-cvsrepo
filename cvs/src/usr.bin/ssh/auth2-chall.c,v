head	1.44;
access;
symbols
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.43.0.4
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.2
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.34.0.16
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.14
	OPENBSD_5_0:1.34.0.12
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.10
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.8
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.4
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.8
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.6
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_8:1.2.0.2;
locks; strict;
comment	@ * @;


1.44
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.43;
commitid	RYYIr1bk0phq4fXa;

1.43
date	2015.07.18.07.57.14;	author djm;	state Exp;
branches;
next	1.42;
commitid	eJI84auRWJpZCqXw;

1.42
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.41;
commitid	GrtSC5ve2VERgUln;

1.41
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2013.11.08.00.39.14;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2013.03.07.19.27.25;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2012.12.03.00.14.06;	author djm;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2012.12.02.20.34.09;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.09.04.32.22;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.21.08.15.29;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.03.03.01.40;	author stevesk;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.05.08.28.24;	author dtucker;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.17.07.17.54;	author djm;	state Exp;
branches
	1.24.2.1
	1.24.4.1;
next	1.23;

1.23
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.19.13.11.47;	author dtucker;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2004.06.01.14.20.45;	author dtucker;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2002.06.30.21.59.45;	author deraadt;	state Exp;
branches
	1.20.6.1
	1.20.8.1;
next	1.19;

1.19
date	2002.06.26.13.55.37;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2002.01.13.17.57.37;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.11.23.02.51;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.11.20.14.11;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.09.18.45.56;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.27.15.31.17;	author markus;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.06.23.15.12.17;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.03.20.06.11;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.18.14.13.28;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.28.22.43.31;	author markus;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.03.02.18.54.31;	author deraadt;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.01.21.19.05.43;	author markus;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.01.18.17.12.43;	author markus;	state Exp;
branches;
next	;

1.2.2.1
date	2001.02.16.20.12.53;	author jason;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.02.19.17.18.38;	author jason;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.05.07.21.09.26;	author jason;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.3.2.1
date	2001.03.12.15.44.07;	author jason;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.03.21.18.52.35;	author jason;	state Exp;
branches;
next	;

1.4.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2002.03.09.00.20.43;	author miod;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.8.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.06.26.18.22.34;	author miod;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	;

1.20.6.1
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.20.8.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	1.20.8.2;

1.20.8.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.21.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2005.09.02.03.44.59;	author brad;	state Exp;
branches;
next	;

1.22.2.1
date	2005.09.04.18.39.57;	author brad;	state Exp;
branches;
next	;

1.24.2.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.24.4.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.36.2.1
date	2013.11.08.05.52.21;	author djm;	state Exp;
branches;
next	;

1.38.2.1
date	2013.11.08.01.33.56;	author djm;	state Exp;
branches;
next	;


desc
@@


1.44
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@/* $OpenBSD: auth2-chall.c,v 1.43 2015/07/18 07:57:14 djm Exp $ */
/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Per Allansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
#include "ssh2.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "buffer.h"
#include "packet.h"
#include "dispatch.h"
#include "log.h"

static int auth2_challenge_start(Authctxt *);
static int send_userauth_info_request(Authctxt *);
static int input_userauth_info_response(int, u_int32_t, void *);

extern KbdintDevice bsdauth_device;

KbdintDevice *devices[] = {
	&bsdauth_device,
	NULL
};

typedef struct KbdintAuthctxt KbdintAuthctxt;
struct KbdintAuthctxt
{
	char *devices;
	void *ctxt;
	KbdintDevice *device;
	u_int nreq;
	u_int devices_done;
};

static KbdintAuthctxt *
kbdint_alloc(const char *devs)
{
	KbdintAuthctxt *kbdintctxt;
	Buffer b;
	int i;

	kbdintctxt = xcalloc(1, sizeof(KbdintAuthctxt));
	if (strcmp(devs, "") == 0) {
		buffer_init(&b);
		for (i = 0; devices[i]; i++) {
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, devices[i]->name,
			    strlen(devices[i]->name));
		}
		if ((kbdintctxt->devices = sshbuf_dup_string(&b)) == NULL)
			fatal("%s: sshbuf_dup_string failed", __func__);
		buffer_free(&b);
	} else {
		kbdintctxt->devices = xstrdup(devs);
	}
	debug("kbdint_alloc: devices '%s'", kbdintctxt->devices);
	kbdintctxt->ctxt = NULL;
	kbdintctxt->device = NULL;
	kbdintctxt->nreq = 0;

	return kbdintctxt;
}
static void
kbdint_reset_device(KbdintAuthctxt *kbdintctxt)
{
	if (kbdintctxt->ctxt) {
		kbdintctxt->device->free_ctx(kbdintctxt->ctxt);
		kbdintctxt->ctxt = NULL;
	}
	kbdintctxt->device = NULL;
}
static void
kbdint_free(KbdintAuthctxt *kbdintctxt)
{
	if (kbdintctxt->device)
		kbdint_reset_device(kbdintctxt);
	free(kbdintctxt->devices);
	explicit_bzero(kbdintctxt, sizeof(*kbdintctxt));
	free(kbdintctxt);
}
/* get next device */
static int
kbdint_next_device(Authctxt *authctxt, KbdintAuthctxt *kbdintctxt)
{
	size_t len;
	char *t;
	int i;

	if (kbdintctxt->device)
		kbdint_reset_device(kbdintctxt);
	do {
		len = kbdintctxt->devices ?
		    strcspn(kbdintctxt->devices, ",") : 0;

		if (len == 0)
			break;
		for (i = 0; devices[i]; i++) {
			if ((kbdintctxt->devices_done & (1 << i)) != 0 ||
			    !auth2_method_allowed(authctxt,
			    "keyboard-interactive", devices[i]->name))
				continue;
			if (strncmp(kbdintctxt->devices, devices[i]->name,
			    len) == 0) {
				kbdintctxt->device = devices[i];
				kbdintctxt->devices_done |= 1 << i;
			}
		}
		t = kbdintctxt->devices;
		kbdintctxt->devices = t[len] ? xstrdup(t+len+1) : NULL;
		free(t);
		debug2("kbdint_next_device: devices %s", kbdintctxt->devices ?
		    kbdintctxt->devices : "<empty>");
	} while (kbdintctxt->devices && !kbdintctxt->device);

	return kbdintctxt->device ? 1 : 0;
}

/*
 * try challenge-response, set authctxt->postponed if we have to
 * wait for the response.
 */
int
auth2_challenge(Authctxt *authctxt, char *devs)
{
	debug("auth2_challenge: user=%s devs=%s",
	    authctxt->user ? authctxt->user : "<nouser>",
	    devs ? devs : "<no devs>");

	if (authctxt->user == NULL || !devs)
		return 0;
	if (authctxt->kbdintctxt == NULL)
		authctxt->kbdintctxt = kbdint_alloc(devs);
	return auth2_challenge_start(authctxt);
}

/* unregister kbd-int callbacks and context */
void
auth2_challenge_stop(Authctxt *authctxt)
{
	/* unregister callback */
	dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);
	if (authctxt->kbdintctxt != NULL) {
		kbdint_free(authctxt->kbdintctxt);
		authctxt->kbdintctxt = NULL;
	}
}

/* side effect: sets authctxt->postponed if a reply was sent*/
static int
auth2_challenge_start(Authctxt *authctxt)
{
	KbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;

	debug2("auth2_challenge_start: devices %s",
	    kbdintctxt->devices ?  kbdintctxt->devices : "<empty>");

	if (kbdint_next_device(authctxt, kbdintctxt) == 0) {
		auth2_challenge_stop(authctxt);
		return 0;
	}
	debug("auth2_challenge_start: trying authentication method '%s'",
	    kbdintctxt->device->name);

	if ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {
		auth2_challenge_stop(authctxt);
		return 0;
	}
	if (send_userauth_info_request(authctxt) == 0) {
		auth2_challenge_stop(authctxt);
		return 0;
	}
	dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE,
	    &input_userauth_info_response);

	authctxt->postponed = 1;
	return 0;
}

static int
send_userauth_info_request(Authctxt *authctxt)
{
	KbdintAuthctxt *kbdintctxt;
	char *name, *instr, **prompts;
	u_int i, *echo_on;

	kbdintctxt = authctxt->kbdintctxt;
	if (kbdintctxt->device->query(kbdintctxt->ctxt,
	    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))
		return 0;

	packet_start(SSH2_MSG_USERAUTH_INFO_REQUEST);
	packet_put_cstring(name);
	packet_put_cstring(instr);
	packet_put_cstring("");		/* language not used */
	packet_put_int(kbdintctxt->nreq);
	for (i = 0; i < kbdintctxt->nreq; i++) {
		packet_put_cstring(prompts[i]);
		packet_put_char(echo_on[i]);
	}
	packet_send();
	packet_write_wait();

	for (i = 0; i < kbdintctxt->nreq; i++)
		free(prompts[i]);
	free(prompts);
	free(echo_on);
	free(name);
	free(instr);
	return 1;
}

static int
input_userauth_info_response(int type, u_int32_t seq, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	KbdintAuthctxt *kbdintctxt;
	int authenticated = 0, res;
	u_int i, nresp;
	const char *devicename = NULL;
	char **response = NULL;

	if (authctxt == NULL)
		fatal("input_userauth_info_response: no authctxt");
	kbdintctxt = authctxt->kbdintctxt;
	if (kbdintctxt == NULL || kbdintctxt->ctxt == NULL)
		fatal("input_userauth_info_response: no kbdintctxt");
	if (kbdintctxt->device == NULL)
		fatal("input_userauth_info_response: no device");

	authctxt->postponed = 0;	/* reset */
	nresp = packet_get_int();
	if (nresp != kbdintctxt->nreq)
		fatal("input_userauth_info_response: wrong number of replies");
	if (nresp > 100)
		fatal("input_userauth_info_response: too many replies");
	if (nresp > 0) {
		response = xcalloc(nresp, sizeof(char *));
		for (i = 0; i < nresp; i++)
			response[i] = packet_get_string(NULL);
	}
	packet_check_eom();

	res = kbdintctxt->device->respond(kbdintctxt->ctxt, nresp, response);

	for (i = 0; i < nresp; i++) {
		explicit_bzero(response[i], strlen(response[i]));
		free(response[i]);
	}
	free(response);

	switch (res) {
	case 0:
		/* Success! */
		authenticated = authctxt->valid ? 1 : 0;
		break;
	case 1:
		/* Authentication needs further interaction */
		if (send_userauth_info_request(authctxt) == 1)
			authctxt->postponed = 1;
		break;
	default:
		/* Failure! */
		break;
	}
	devicename = kbdintctxt->device->name;
	if (!authctxt->postponed) {
		if (authenticated) {
			auth2_challenge_stop(authctxt);
		} else {
			/* start next device */
			/* may set authctxt->postponed */
			auth2_challenge_start(authctxt);
		}
	}
	userauth_finish(authctxt, authenticated, "keyboard-interactive",
	    devicename);
	return 0;
}

void
privsep_challenge_enable(void)
{
	extern KbdintDevice mm_bsdauth_device;
	/* As long as SSHv1 has devices[0] hard coded this is fine */
	devices[0] = &mm_bsdauth_device;
}
@


1.43
log
@only query each keyboard-interactive device once per authentication
request regardless of how many times it is listed; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.42 2015/01/19 20:07:45 markus Exp $ */
d79 2
a80 2
		buffer_append(&b, "\0", 1);
		kbdintctxt->devices = xstrdup(buffer_ptr(&b));
@


1.42
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.41 2014/02/02 03:44:31 djm Exp $ */
d60 1
d127 2
a128 1
			if (!auth2_method_allowed(authctxt,
d131 2
a132 1
			if (strncmp(kbdintctxt->devices, devices[i]->name, len) == 0)
d134 2
@


1.41
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.40 2014/01/31 16:39:19 tedu Exp $ */
d44 1
a44 1
static void input_userauth_info_response(int, u_int32_t, void *);
d236 1
a236 1
static void
d301 1
@


1.40
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.39 2013/11/08 00:39:14 djm Exp $ */
d270 1
a270 1
		memset(response[i], 'r', strlen(response[i]));
@


1.39
log
@use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.38 2013/05/17 00:13:13 djm Exp $ */
d106 1
a106 1
	bzero(kbdintctxt, sizeof(*kbdintctxt));
@


1.38
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.37 2013/03/07 19:27:25 markus Exp $ */
d69 1
a69 1
	kbdintctxt = xmalloc(sizeof(KbdintAuthctxt));
@


1.38.2.1
log
@cherrypick commit:

date: 2013/11/08 00:39:15;  author: djm;  state: Exp;  lines: +2 -2;
use calloc for all structure allocations; from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.38 2013/05/17 00:13:13 djm Exp $ */
d69 1
a69 1
	kbdintctxt = xcalloc(1, sizeof(KbdintAuthctxt));
@


1.37
log
@add submethod support to AuthenticationMethods; ok and freedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.36 2012/12/03 00:14:06 djm Exp $ */
d105 3
a107 5
	if (kbdintctxt->devices) {
		xfree(kbdintctxt->devices);
		kbdintctxt->devices = NULL;
	}
	xfree(kbdintctxt);
d134 1
a134 1
		xfree(t);
d228 5
a232 5
		xfree(prompts[i]);
	xfree(prompts);
	xfree(echo_on);
	xfree(name);
	xfree(instr);
d271 1
a271 1
		xfree(response[i]);
d273 1
a273 2
	if (response)
		xfree(response);
@


1.36
log
@Fix compilation with -Wall -Werror (trivial type fixes)
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.35 2012/12/02 20:34:09 djm Exp $ */
d113 1
a113 1
kbdint_next_device(KbdintAuthctxt *kbdintctxt)
d127 4
a130 1
		for (i = 0; devices[i]; i++)
d133 1
d183 1
a183 1
	if (kbdint_next_device(kbdintctxt) == 0) {
@


1.36.2.1
log
@openssh-6.4 for the 5.3 branch; reminded by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.38.2.1 2013/11/08 01:33:56 djm Exp $ */
d69 1
a69 1
	kbdintctxt = xcalloc(1, sizeof(KbdintAuthctxt));
@


1.35
log
@Fixes logging of partial authentication when privsep is enabled
Previously, we recorded "Failed xxx" since we reset authenticated before
calling auth_log() in auth2.c. This adds an explcit "Partial" state.

Add a "submethod" to auth_log() to report which submethod is used
for keyboard-interactive.

Fix multiple authentication when one of the methods is
keyboard-interactive.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.34 2008/12/09 04:32:22 djm Exp $ */
d241 2
a242 1
	char *devicename = NULL, **response = NULL;
@


1.34
log
@replace by-hand string building with xasprinf(); ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.33 2007/09/21 08:15:29 djm Exp $ */
d241 1
a241 1
	char **response = NULL, *method;
d287 1
a287 3

	xasprintf(&method, "keyboard-interactive/%s", kbdintctxt->device->name);

d297 2
a298 2
	userauth_finish(authctxt, authenticated, method);
	xfree(method);
@


1.33
log
@unifdef -DBSD_AUTH
unifdef -USKEY

These options have been in use for some years;
ok markus@@ "no objection" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.32 2007/01/03 03:01:40 stevesk Exp $ */
d239 1
a239 1
	int authenticated = 0, res, len;
d288 1
a288 5
	len = strlen("keyboard-interactive") + 2 +
		strlen(kbdintctxt->device->name);
	method = xmalloc(len);
	snprintf(method, len, "keyboard-interactive/%s",
	    kbdintctxt->device->name);
@


1.32
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.31 2006/08/05 08:28:24 dtucker Exp $ */
a45 1
#ifdef BSD_AUTH
a46 5
#else
#ifdef SKEY
extern KbdintDevice skey_device;
#endif
#endif
a48 1
#ifdef BSD_AUTH
a49 5
#else
#ifdef SKEY
	&skey_device,
#endif
#endif
a309 1
#ifdef BSD_AUTH
a310 5
#else
#ifdef SKEY
	extern KbdintDevice mm_skey_device;
#endif
#endif
a311 1
#ifdef BSD_AUTH
a312 5
#else
#ifdef SKEY
	devices[0] = &mm_skey_device;
#endif
#endif
@


1.31
log
@Zap unused variables in -DSKEY code.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.30 2006/08/03 03:34:41 deraadt Exp $ */
d176 1
a176 1
	if (authctxt->kbdintctxt != NULL)  {
@


1.30
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.29 2006/08/01 23:22:47 stevesk Exp $ */
d324 1
a324 1
#endif
d327 1
@


1.29
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.28 2006/07/22 20:48:22 stevesk Exp $ */
d26 2
a27 1
#include "includes.h"
d32 1
d34 2
a38 1
#include "xmalloc.h"
@


1.28
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth2-chall.c,v 1.27 2006/03/25 13:17:01 djm Exp $ */
d28 1
@


1.27
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d27 2
@


1.26
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.25
log
@RCSID() can die
@
text
@d263 1
a263 1
		response = xmalloc(nresp * sizeof(char *));
@


1.24
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.23 2005/06/17 02:44:32 djm Exp $");
@


1.24.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth2-chall.c,v 1.31 2006/08/05 08:28:24 dtucker Exp $ */
d25 2
a27 6
#include <sys/types.h>

#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
a28 2
#include "key.h"
#include "hostfile.h"
d32 1
d264 1
a264 1
		response = xcalloc(nresp, sizeof(char *));
d318 1
a318 1
#else
a320 1
#endif
@


1.24.4.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth2-chall.c,v 1.31 2006/08/05 08:28:24 dtucker Exp $ */
d25 2
a27 6
#include <sys/types.h>

#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
a28 2
#include "key.h"
#include "hostfile.h"
d32 1
d264 1
a264 1
		response = xcalloc(nresp, sizeof(char *));
d318 1
a318 1
#else
a320 1
#endif
@


1.23
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.22 2005/01/19 13:11:47 dtucker Exp $");
d140 1
a140 1
		   kbdintctxt->devices : "<empty>");
@


1.22
log
@Have keyboard-interactive code call the drivers even for responses for
invalid logins.  This allows the drivers themselves to decide how to handle
them and prevent leaking information where possible.  Existing behaviour for
bsdauth is maintained by checking authctxt->valid in the bsdauth driver.
Note that any third-party kbdint drivers will now need to be able to handle
responses for invalid logins.  ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.21 2004/06/01 14:20:45 dtucker Exp $");
d212 1
a212 2
	int i;
	u_int *echo_on;
d245 2
a246 2
	int i, authenticated = 0, res, len;
	u_int nresp;
@


1.22.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.24 2005/07/17 07:17:54 djm Exp $");
d140 1
a140 1
		    kbdintctxt->devices : "<empty>");
d212 2
a213 1
	u_int i, *echo_on;
d246 2
a247 2
	int authenticated = 0, res, len;
	u_int i, nresp;
@


1.21
log
@Remove redundant #include; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.20 2002/06/30 21:59:45 deraadt Exp $");
d271 1
a271 6
	if (authctxt->valid) {
		res = kbdintctxt->device->respond(kbdintctxt->ctxt,
		    nresp, response);
	} else {
		res = -1;
	}
d283 1
a283 1
		authenticated = 1;
@


1.21.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.22 2005/01/19 13:11:47 dtucker Exp $");
d271 6
a276 1
	res = kbdintctxt->device->respond(kbdintctxt->ctxt, nresp, response);
d288 1
a288 1
		authenticated = authctxt->valid ? 1 : 0;
@


1.21.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.24 2005/07/17 07:17:54 djm Exp $");
d140 1
a140 1
		    kbdintctxt->devices : "<empty>");
d212 2
a213 1
	u_int i, *echo_on;
d246 2
a247 2
	int authenticated = 0, res, len;
	u_int i, nresp;
@


1.20
log
@minor KNF
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.19 2002/06/26 13:55:37 markus Exp $");
a33 1
#include "auth.h"
@


1.20.6.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.21 2004/06/01 14:20:45 dtucker Exp $");
d34 1
@


1.20.8.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.21 2004/06/01 14:20:45 dtucker Exp $");
d34 1
@


1.20.8.2
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.22 2005/01/19 13:11:47 dtucker Exp $");
d271 6
a276 1
	res = kbdintctxt->device->respond(kbdintctxt->ctxt, nresp, response);
d288 1
a288 1
		authenticated = authctxt->valid ? 1 : 0;
@


1.19
log
@make sure # of response matches # of queries, fixes int overflow; from ISS
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.18 2002/06/19 00:27:55 deraadt Exp $");
d266 1
a266 1
		response = xmalloc(nresp * sizeof(char*));
@


1.18
log
@KNF done automatically while reading....
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.17 2002/03/18 17:50:31 provos Exp $");
d66 1
d94 1
d214 1
a214 1
	u_int numprompts, *echo_on;
d218 1
a218 1
	    &name, &instr, &numprompts, &prompts, &echo_on))
d225 2
a226 2
	packet_put_int(numprompts);
	for (i = 0; i < numprompts; i++) {
d233 1
a233 1
	for (i = 0; i < numprompts; i++)
d261 4
@


1.17
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.16 2002/01/13 17:57:37 markus Exp $");
d222 1
a222 1
	packet_put_cstring(""); 	/* language not used */
@


1.17.2.1
log
@Pull in OpenSSH-3.4
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.19 2002/06/26 13:55:37 markus Exp $");
a65 1
	u_int nreq;
a92 1
	kbdintctxt->nreq = 0;
d212 1
a212 1
	u_int *echo_on;
d216 1
a216 1
	    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))
d222 3
a224 3
	packet_put_cstring("");		/* language not used */
	packet_put_int(kbdintctxt->nreq);
	for (i = 0; i < kbdintctxt->nreq; i++) {
d231 1
a231 1
	for (i = 0; i < kbdintctxt->nreq; i++)
a258 4
	if (nresp != kbdintctxt->nreq)
		fatal("input_userauth_info_response: wrong number of replies");
	if (nresp > 100)
		fatal("input_userauth_info_response: too many replies");
@


1.17.2.2
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.20 2002/06/30 21:59:45 deraadt Exp $");
d266 1
a266 1
		response = xmalloc(nresp * sizeof(char *));
@


1.16
log
@use buffer API and avoid static strings of fixed size; ok provos@@/mouring@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.15 2002/01/11 23:02:51 markus Exp $");
d312 19
@


1.15
log
@use snprintf; mouring@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.14 2002/01/11 20:14:11 markus Exp $");
d30 1
d72 1
a73 1
	char buf[1024];
d77 1
a77 1
		buf[0] = '\0';
d79 4
a82 3
			if (i != 0)
				strlcat(buf, ",", sizeof(buf));
			strlcat(buf, devices[i]->name, sizeof(buf));
d84 3
a86 2
		debug("kbdint_alloc: devices '%s'", buf);
		kbdintctxt->devices = xstrdup(buf);
d90 1
@


1.14
log
@use strlcpy not strlcat; mouring@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.13 2001/12/28 15:06:00 markus Exp $");
d294 2
a295 3
	strlcpy(method, "keyboard-interactive", len);
	strlcat(method, "/", len);
	strlcat(method, kbdintctxt->device->name, len);
@


1.13
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.12 2001/12/28 12:14:27 markus Exp $");
d294 1
a294 2
	method[0] = '\0';
	strlcat(method, "keyboard-interactive", len);
@


1.12
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.11 2001/12/20 22:50:24 djm Exp $");
d38 1
a38 1
static void input_userauth_info_response(int, int, u_int32_t, void *);
d237 1
a237 1
input_userauth_info_response(int type, int plen, u_int32_t seq, void *ctxt)
@


1.11
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.10 2001/12/19 07:18:56 deraadt Exp $");
d260 1
a260 1
	packet_done();
@


1.10
log
@basic KNF done while i was looking for something else
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.9 2001/12/09 18:45:56 markus Exp $");
d38 1
a38 1
static void input_userauth_info_response(int, int, void *);
d237 1
a237 1
input_userauth_info_response(int type, int plen, void *ctxt)
@


1.9
log
@add auth2_challenge_stop(), simplifies cleanup of kbd-int sessions,
fixes memleak.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.8 2001/09/27 15:31:17 markus Exp $");
d154 1
a154 1
	if (authctxt->kbdintctxt == NULL) 
@


1.8
log
@typos; from solar
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.7 2001/06/23 15:12:17 itojun Exp $");
d159 12
d181 1
a181 2
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
d188 1
a188 2
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
d192 1
a192 2
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
d283 2
a284 4
		authctxt->postponed = 1;
		if (send_userauth_info_request(authctxt) == 0) {
			authctxt->postponed = 0;
		}
a299 3
		/* unregister callback */
		dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);

d301 1
a301 2
			kbdint_free(kbdintctxt);
			authctxt->kbdintctxt = NULL;
@


1.8.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.16 2002/01/13 17:57:37 markus Exp $");
a29 1
#include "buffer.h"
d38 1
a38 1
static void input_userauth_info_response(int, u_int32_t, void *);
a70 1
	Buffer b;
d72 1
d76 1
a76 1
		buffer_init(&b);
d78 3
a80 4
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, devices[i]->name,
			    strlen(devices[i]->name));
d82 2
a83 3
		buffer_append(&b, "\0", 1);
		kbdintctxt->devices = xstrdup(buffer_ptr(&b));
		buffer_free(&b);
a86 1
	debug("kbdint_alloc: devices '%s'", kbdintctxt->devices);
d154 1
a154 1
	if (authctxt->kbdintctxt == NULL)
a158 12
/* unregister kbd-int callbacks and context */
void
auth2_challenge_stop(Authctxt *authctxt)
{
	/* unregister callback */
	dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);
	if (authctxt->kbdintctxt != NULL)  {
		kbdint_free(authctxt->kbdintctxt);
		authctxt->kbdintctxt = NULL;
	}
}

d169 2
a170 1
		auth2_challenge_stop(authctxt);
d177 2
a178 1
		auth2_challenge_stop(authctxt);
d182 2
a183 1
		auth2_challenge_stop(authctxt);
d228 1
a228 1
input_userauth_info_response(int type, u_int32_t seq, void *ctxt)
d251 1
a251 1
	packet_check_eom();
d274 4
a277 2
		if (send_userauth_info_request(authctxt) == 1)
			authctxt->postponed = 1;
d287 4
a290 2
	snprintf(method, len, "keyboard-interactive/%s",
	    kbdintctxt->device->name);
d293 3
d297 2
a298 1
			auth2_challenge_stop(authctxt);
@


1.8.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.17 2002/03/18 17:50:31 provos Exp $");
a311 19
}

void
privsep_challenge_enable(void)
{
#ifdef BSD_AUTH
	extern KbdintDevice mm_bsdauth_device;
#endif
#ifdef SKEY
	extern KbdintDevice mm_skey_device;
#endif
	/* As long as SSHv1 has devices[0] hard coded this is fine */
#ifdef BSD_AUTH
	devices[0] = &mm_bsdauth_device;
#else
#ifdef SKEY
	devices[0] = &mm_skey_device;
#endif
#endif
@


1.8.2.3
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.8.2.2 2002/05/17 00:03:23 miod Exp $");
d222 1
a222 1
	packet_put_cstring("");		/* language not used */
@


1.8.2.4
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.8.2.3 2002/06/22 07:23:16 miod Exp $");
a65 1
	u_int nreq;
a92 1
	kbdintctxt->nreq = 0;
d212 1
a212 1
	u_int *echo_on;
d216 1
a216 1
	    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))
d223 2
a224 2
	packet_put_int(kbdintctxt->nreq);
	for (i = 0; i < kbdintctxt->nreq; i++) {
d231 1
a231 1
	for (i = 0; i < kbdintctxt->nreq; i++)
a258 4
	if (nresp != kbdintctxt->nreq)
		fatal("input_userauth_info_response: wrong number of replies");
	if (nresp > 100)
		fatal("input_userauth_info_response: too many replies");
@


1.8.2.5
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.20 2002/06/30 21:59:45 deraadt Exp $");
d266 1
a266 1
		response = xmalloc(nresp * sizeof(char *));
@


1.7
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.6 2001/06/03 20:06:11 markus Exp $");
d142 1
a142 1
 * try challenge-reponse, set authctxt->postponed if we have to
@


1.6
log
@the challenge response device decides how to handle non-existing users.
-> fake challenges for skey and cryptocard
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.5 2001/05/18 14:13:28 markus Exp $");
d36 3
a38 3
static int auth2_challenge_start(Authctxt *authctxt);
static int send_userauth_info_request(Authctxt *authctxt);
static void input_userauth_info_response(int type, int plen, void *ctxt);
d67 1
a67 1
KbdintAuthctxt *
d92 1
a92 1
void
d101 1
a101 1
void
d113 1
a113 1
int
@


1.5
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.4 2001/03/28 22:43:31 markus Exp $");
d152 1
a152 1
	if (!authctxt->valid || authctxt->user == NULL || !devs)
@


1.4
log
@check auth_root_allowed for kbd-int auth, too.
@
text
@d3 1
d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.3 2001/03/02 18:54:31 deraadt Exp $");
d33 1
d36 104
a139 2
void send_userauth_into_request(Authctxt *authctxt, char *challenge, int echo);
void input_userauth_info_response(int type, int plen, void *ctxt);
d142 1
a142 1
 * try challenge-reponse, return -1 (= postponed) if we have to
d148 27
a174 1
	char *challenge;
d176 3
a178 1
	if (!authctxt->valid || authctxt->user == NULL)
d180 4
a183 1
	if ((challenge = get_challenge(authctxt, devs)) == NULL)
d185 1
a185 1
	send_userauth_into_request(authctxt, challenge, 0);
d188 1
d193 2
a194 2
void
send_userauth_into_request(Authctxt *authctxt, char *challenge, int echo)
d196 9
a204 1
	int nprompts = 1;
d207 8
a214 7
	/* name, instruction and language are unused */
	packet_put_cstring("");
	packet_put_cstring("");
	packet_put_cstring("");
	packet_put_int(nprompts);
	packet_put_cstring(challenge);
	packet_put_char(echo);
d217 8
d227 1
a227 1
void
d231 4
a234 3
	int authenticated = 0;
	u_int nresp, rlen;
	char *response, *method = "challenge-reponse";
d238 5
d246 31
a276 17
	if (nresp == 1) {
		response = packet_get_string(&rlen);
		packet_done();
		if (strlen(response) == 0) {
			/*
			 * if we received an empty response, resend challenge
			 * with echo enabled
			 */
			char *challenge = get_challenge(authctxt, NULL);
			if (challenge != NULL) {
				send_userauth_into_request(authctxt,
				    challenge, 1);
				authctxt->postponed = 1;
			}
		} else if (authctxt->valid) {
			authenticated = verify_response(authctxt, response);
			memset(response, 'r', rlen);
d278 4
a281 1
		xfree(response);
d283 11
a293 2
	/* unregister callback */
	if (!authctxt->postponed)
d296 9
d306 1
@


1.4.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@a2 1
 * Copyright (c) 2001 Per Allansson.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.7 2001/06/23 15:12:17 itojun Exp $");
a31 1
#include "auth.h"
d34 2
a35 104
static int auth2_challenge_start(Authctxt *);
static int send_userauth_info_request(Authctxt *);
static void input_userauth_info_response(int, int, void *);

#ifdef BSD_AUTH
extern KbdintDevice bsdauth_device;
#else
#ifdef SKEY
extern KbdintDevice skey_device;
#endif
#endif

KbdintDevice *devices[] = {
#ifdef BSD_AUTH
	&bsdauth_device,
#else
#ifdef SKEY
	&skey_device,
#endif
#endif
	NULL
};

typedef struct KbdintAuthctxt KbdintAuthctxt;
struct KbdintAuthctxt
{
	char *devices;
	void *ctxt;
	KbdintDevice *device;
};

static KbdintAuthctxt *
kbdint_alloc(const char *devs)
{
	KbdintAuthctxt *kbdintctxt;
	int i;
	char buf[1024];

	kbdintctxt = xmalloc(sizeof(KbdintAuthctxt));
	if (strcmp(devs, "") == 0) {
		buf[0] = '\0';
		for (i = 0; devices[i]; i++) {
			if (i != 0)
				strlcat(buf, ",", sizeof(buf));
			strlcat(buf, devices[i]->name, sizeof(buf));
		}
		debug("kbdint_alloc: devices '%s'", buf);
		kbdintctxt->devices = xstrdup(buf);
	} else {
		kbdintctxt->devices = xstrdup(devs);
	}
	kbdintctxt->ctxt = NULL;
	kbdintctxt->device = NULL;

	return kbdintctxt;
}
static void
kbdint_reset_device(KbdintAuthctxt *kbdintctxt)
{
	if (kbdintctxt->ctxt) {
		kbdintctxt->device->free_ctx(kbdintctxt->ctxt);
		kbdintctxt->ctxt = NULL;
	}
	kbdintctxt->device = NULL;
}
static void
kbdint_free(KbdintAuthctxt *kbdintctxt)
{
	if (kbdintctxt->device)
		kbdint_reset_device(kbdintctxt);
	if (kbdintctxt->devices) {
		xfree(kbdintctxt->devices);
		kbdintctxt->devices = NULL;
	}
	xfree(kbdintctxt);
}
/* get next device */
static int
kbdint_next_device(KbdintAuthctxt *kbdintctxt)
{
	size_t len;
	char *t;
	int i;

	if (kbdintctxt->device)
		kbdint_reset_device(kbdintctxt);
	do {
		len = kbdintctxt->devices ?
		    strcspn(kbdintctxt->devices, ",") : 0;

		if (len == 0)
			break;
		for (i = 0; devices[i]; i++)
			if (strncmp(kbdintctxt->devices, devices[i]->name, len) == 0)
				kbdintctxt->device = devices[i];
		t = kbdintctxt->devices;
		kbdintctxt->devices = t[len] ? xstrdup(t+len+1) : NULL;
		xfree(t);
		debug2("kbdint_next_device: devices %s", kbdintctxt->devices ?
		   kbdintctxt->devices : "<empty>");
	} while (kbdintctxt->devices && !kbdintctxt->device);

	return kbdintctxt->device ? 1 : 0;
}
d38 1
a38 1
 * try challenge-reponse, set authctxt->postponed if we have to
d44 1
a44 3
	debug("auth2_challenge: user=%s devs=%s",
	    authctxt->user ? authctxt->user : "<nouser>",
	    devs ? devs : "<no devs>");
d46 1
a46 1
	if (authctxt->user == NULL || !devs)
d48 1
a48 30
	if (authctxt->kbdintctxt == NULL) 
		authctxt->kbdintctxt = kbdint_alloc(devs);
	return auth2_challenge_start(authctxt);
}

/* side effect: sets authctxt->postponed if a reply was sent*/
static int
auth2_challenge_start(Authctxt *authctxt)
{
	KbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;

	debug2("auth2_challenge_start: devices %s",
	    kbdintctxt->devices ?  kbdintctxt->devices : "<empty>");

	if (kbdint_next_device(kbdintctxt) == 0) {
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
		return 0;
	}
	debug("auth2_challenge_start: trying authentication method '%s'",
	    kbdintctxt->device->name);

	if ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
		return 0;
	}
	if (send_userauth_info_request(authctxt) == 0) {
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
d50 1
a50 1
	}
a52 1

d57 2
a58 2
static int
send_userauth_info_request(Authctxt *authctxt)
d60 1
a60 9
	KbdintAuthctxt *kbdintctxt;
	char *name, *instr, **prompts;
	int i;
	u_int numprompts, *echo_on;

	kbdintctxt = authctxt->kbdintctxt;
	if (kbdintctxt->device->query(kbdintctxt->ctxt,
	    &name, &instr, &numprompts, &prompts, &echo_on))
		return 0;
d63 7
a69 8
	packet_put_cstring(name);
	packet_put_cstring(instr);
	packet_put_cstring(""); 	/* language not used */
	packet_put_int(numprompts);
	for (i = 0; i < numprompts; i++) {
		packet_put_cstring(prompts[i]);
		packet_put_char(echo_on[i]);
	}
a71 8

	for (i = 0; i < numprompts; i++)
		xfree(prompts[i]);
	xfree(prompts);
	xfree(echo_on);
	xfree(name);
	xfree(instr);
	return 1;
d74 1
a74 1
static void
d78 3
a80 4
	KbdintAuthctxt *kbdintctxt;
	int i, authenticated = 0, res, len;
	u_int nresp;
	char **response = NULL, *method;
a83 5
	kbdintctxt = authctxt->kbdintctxt;
	if (kbdintctxt == NULL || kbdintctxt->ctxt == NULL)
		fatal("input_userauth_info_response: no kbdintctxt");
	if (kbdintctxt->device == NULL)
		fatal("input_userauth_info_response: no device");
d87 18
a104 19
	if (nresp > 0) {
		response = xmalloc(nresp * sizeof(char*));
		for (i = 0; i < nresp; i++)
			response[i] = packet_get_string(NULL);
	}
	packet_done();

	if (authctxt->valid) {
		res = kbdintctxt->device->respond(kbdintctxt->ctxt,
		    nresp, response);
	} else {
		res = -1;
	}

	for (i = 0; i < nresp; i++) {
		memset(response[i], 'r', strlen(response[i]));
		xfree(response[i]);
	}
	if (response)
a105 16

	switch (res) {
	case 0:
		/* Success! */
		authenticated = 1;
		break;
	case 1:
		/* Authentication needs further interaction */
		authctxt->postponed = 1;
		if (send_userauth_info_request(authctxt) == 0) {
			authctxt->postponed = 0;
		}
		break;
	default:
		/* Failure! */
		break;
d107 2
a108 11

	len = strlen("keyboard-interactive") + 2 +
		strlen(kbdintctxt->device->name);
	method = xmalloc(len);
	method[0] = '\0';
	strlcat(method, "keyboard-interactive", len);
	strlcat(method, "/", len);
	strlcat(method, kbdintctxt->device->name, len);

	if (!authctxt->postponed) {
		/* unregister callback */
a110 9
		if (authenticated) {
			kbdint_free(kbdintctxt);
			authctxt->kbdintctxt = NULL;
		} else {
			/* start next device */
			/* may set authctxt->postponed */
			auth2_challenge_start(authctxt);
		}
	}
a111 1
	xfree(method);
@


1.4.2.2
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.4.2.1 2001/09/27 19:03:54 jason Exp $");
d142 1
a142 1
 * try challenge-response, set authctxt->postponed if we have to
@


1.4.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.16 2002/01/13 17:57:37 markus Exp $");
a29 1
#include "buffer.h"
d38 1
a38 1
static void input_userauth_info_response(int, u_int32_t, void *);
a70 1
	Buffer b;
d72 1
d76 1
a76 1
		buffer_init(&b);
d78 3
a80 4
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, devices[i]->name,
			    strlen(devices[i]->name));
d82 2
a83 3
		buffer_append(&b, "\0", 1);
		kbdintctxt->devices = xstrdup(buffer_ptr(&b));
		buffer_free(&b);
a86 1
	debug("kbdint_alloc: devices '%s'", kbdintctxt->devices);
d154 1
a154 1
	if (authctxt->kbdintctxt == NULL)
a158 12
/* unregister kbd-int callbacks and context */
void
auth2_challenge_stop(Authctxt *authctxt)
{
	/* unregister callback */
	dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);
	if (authctxt->kbdintctxt != NULL)  {
		kbdint_free(authctxt->kbdintctxt);
		authctxt->kbdintctxt = NULL;
	}
}

d169 2
a170 1
		auth2_challenge_stop(authctxt);
d177 2
a178 1
		auth2_challenge_stop(authctxt);
d182 2
a183 1
		auth2_challenge_stop(authctxt);
d228 1
a228 1
input_userauth_info_response(int type, u_int32_t seq, void *ctxt)
d251 1
a251 1
	packet_check_eom();
d274 4
a277 2
		if (send_userauth_info_request(authctxt) == 1)
			authctxt->postponed = 1;
d287 4
a290 2
	snprintf(method, len, "keyboard-interactive/%s",
	    kbdintctxt->device->name);
d293 3
d297 2
a298 1
			auth2_challenge_stop(authctxt);
@


1.4.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.17 2002/03/18 17:50:31 provos Exp $");
a311 19
}

void
privsep_challenge_enable(void)
{
#ifdef BSD_AUTH
	extern KbdintDevice mm_bsdauth_device;
#endif
#ifdef SKEY
	extern KbdintDevice mm_skey_device;
#endif
	/* As long as SSHv1 has devices[0] hard coded this is fine */
#ifdef BSD_AUTH
	devices[0] = &mm_bsdauth_device;
#else
#ifdef SKEY
	devices[0] = &mm_skey_device;
#endif
#endif
@


1.3
log
@make copyright lines the same format
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.2 2001/01/21 19:05:43 markus Exp $");
d107 2
a108 3
	auth_log(authctxt, authenticated, method, " ssh2");
	if (!authctxt->postponed) {
		/* unregister callback and send reply */
d110 2
a111 2
		userauth_reply(authctxt, authenticated);
	}
@


1.3.2.1
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Markus Friedl. All rights reserved.
@


1.3.2.2
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.3 2001/03/02 18:54:31 deraadt Exp $");
@


1.2
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Markus Friedl. All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.1 2001/01/18 17:12:43 markus Exp $");
@


1.2.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.2 2001/01/21 19:05:43 markus Exp $");
@


1.2.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.2.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.3 2001/03/02 18:54:31 deraadt Exp $");
@


1.2.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.4 2001/03/28 22:43:31 markus Exp $");
d107 3
a109 2
	/* unregister callback */
	if (!authctxt->postponed)
d111 2
a112 2

	userauth_finish(authctxt, authenticated, method);
@


1.2.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@a2 1
 * Copyright (c) 2001 Per Allansson.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: auth2-chall.c,v 1.7 2001/06/23 15:12:17 itojun Exp $");
a31 1
#include "auth.h"
d34 2
a35 104
static int auth2_challenge_start(Authctxt *);
static int send_userauth_info_request(Authctxt *);
static void input_userauth_info_response(int, int, void *);

#ifdef BSD_AUTH
extern KbdintDevice bsdauth_device;
#else
#ifdef SKEY
extern KbdintDevice skey_device;
#endif
#endif

KbdintDevice *devices[] = {
#ifdef BSD_AUTH
	&bsdauth_device,
#else
#ifdef SKEY
	&skey_device,
#endif
#endif
	NULL
};

typedef struct KbdintAuthctxt KbdintAuthctxt;
struct KbdintAuthctxt
{
	char *devices;
	void *ctxt;
	KbdintDevice *device;
};

static KbdintAuthctxt *
kbdint_alloc(const char *devs)
{
	KbdintAuthctxt *kbdintctxt;
	int i;
	char buf[1024];

	kbdintctxt = xmalloc(sizeof(KbdintAuthctxt));
	if (strcmp(devs, "") == 0) {
		buf[0] = '\0';
		for (i = 0; devices[i]; i++) {
			if (i != 0)
				strlcat(buf, ",", sizeof(buf));
			strlcat(buf, devices[i]->name, sizeof(buf));
		}
		debug("kbdint_alloc: devices '%s'", buf);
		kbdintctxt->devices = xstrdup(buf);
	} else {
		kbdintctxt->devices = xstrdup(devs);
	}
	kbdintctxt->ctxt = NULL;
	kbdintctxt->device = NULL;

	return kbdintctxt;
}
static void
kbdint_reset_device(KbdintAuthctxt *kbdintctxt)
{
	if (kbdintctxt->ctxt) {
		kbdintctxt->device->free_ctx(kbdintctxt->ctxt);
		kbdintctxt->ctxt = NULL;
	}
	kbdintctxt->device = NULL;
}
static void
kbdint_free(KbdintAuthctxt *kbdintctxt)
{
	if (kbdintctxt->device)
		kbdint_reset_device(kbdintctxt);
	if (kbdintctxt->devices) {
		xfree(kbdintctxt->devices);
		kbdintctxt->devices = NULL;
	}
	xfree(kbdintctxt);
}
/* get next device */
static int
kbdint_next_device(KbdintAuthctxt *kbdintctxt)
{
	size_t len;
	char *t;
	int i;

	if (kbdintctxt->device)
		kbdint_reset_device(kbdintctxt);
	do {
		len = kbdintctxt->devices ?
		    strcspn(kbdintctxt->devices, ",") : 0;

		if (len == 0)
			break;
		for (i = 0; devices[i]; i++)
			if (strncmp(kbdintctxt->devices, devices[i]->name, len) == 0)
				kbdintctxt->device = devices[i];
		t = kbdintctxt->devices;
		kbdintctxt->devices = t[len] ? xstrdup(t+len+1) : NULL;
		xfree(t);
		debug2("kbdint_next_device: devices %s", kbdintctxt->devices ?
		   kbdintctxt->devices : "<empty>");
	} while (kbdintctxt->devices && !kbdintctxt->device);

	return kbdintctxt->device ? 1 : 0;
}
d38 1
a38 1
 * try challenge-reponse, set authctxt->postponed if we have to
d44 1
a44 3
	debug("auth2_challenge: user=%s devs=%s",
	    authctxt->user ? authctxt->user : "<nouser>",
	    devs ? devs : "<no devs>");
d46 1
a46 1
	if (authctxt->user == NULL || !devs)
d48 1
a48 30
	if (authctxt->kbdintctxt == NULL) 
		authctxt->kbdintctxt = kbdint_alloc(devs);
	return auth2_challenge_start(authctxt);
}

/* side effect: sets authctxt->postponed if a reply was sent*/
static int
auth2_challenge_start(Authctxt *authctxt)
{
	KbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;

	debug2("auth2_challenge_start: devices %s",
	    kbdintctxt->devices ?  kbdintctxt->devices : "<empty>");

	if (kbdint_next_device(kbdintctxt) == 0) {
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
		return 0;
	}
	debug("auth2_challenge_start: trying authentication method '%s'",
	    kbdintctxt->device->name);

	if ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
		return 0;
	}
	if (send_userauth_info_request(authctxt) == 0) {
		kbdint_free(kbdintctxt);
		authctxt->kbdintctxt = NULL;
d50 1
a50 1
	}
a52 1

d57 2
a58 2
static int
send_userauth_info_request(Authctxt *authctxt)
d60 1
a60 9
	KbdintAuthctxt *kbdintctxt;
	char *name, *instr, **prompts;
	int i;
	u_int numprompts, *echo_on;

	kbdintctxt = authctxt->kbdintctxt;
	if (kbdintctxt->device->query(kbdintctxt->ctxt,
	    &name, &instr, &numprompts, &prompts, &echo_on))
		return 0;
d63 7
a69 8
	packet_put_cstring(name);
	packet_put_cstring(instr);
	packet_put_cstring(""); 	/* language not used */
	packet_put_int(numprompts);
	for (i = 0; i < numprompts; i++) {
		packet_put_cstring(prompts[i]);
		packet_put_char(echo_on[i]);
	}
a71 8

	for (i = 0; i < numprompts; i++)
		xfree(prompts[i]);
	xfree(prompts);
	xfree(echo_on);
	xfree(name);
	xfree(instr);
	return 1;
d74 1
a74 1
static void
d78 3
a80 4
	KbdintAuthctxt *kbdintctxt;
	int i, authenticated = 0, res, len;
	u_int nresp;
	char **response = NULL, *method;
a83 5
	kbdintctxt = authctxt->kbdintctxt;
	if (kbdintctxt == NULL || kbdintctxt->ctxt == NULL)
		fatal("input_userauth_info_response: no kbdintctxt");
	if (kbdintctxt->device == NULL)
		fatal("input_userauth_info_response: no device");
d87 18
a104 19
	if (nresp > 0) {
		response = xmalloc(nresp * sizeof(char*));
		for (i = 0; i < nresp; i++)
			response[i] = packet_get_string(NULL);
	}
	packet_done();

	if (authctxt->valid) {
		res = kbdintctxt->device->respond(kbdintctxt->ctxt,
		    nresp, response);
	} else {
		res = -1;
	}

	for (i = 0; i < nresp; i++) {
		memset(response[i], 'r', strlen(response[i]));
		xfree(response[i]);
	}
	if (response)
a105 16

	switch (res) {
	case 0:
		/* Success! */
		authenticated = 1;
		break;
	case 1:
		/* Authentication needs further interaction */
		authctxt->postponed = 1;
		if (send_userauth_info_request(authctxt) == 0) {
			authctxt->postponed = 0;
		}
		break;
	default:
		/* Failure! */
		break;
d107 2
a108 11

	len = strlen("keyboard-interactive") + 2 +
		strlen(kbdintctxt->device->name);
	method = xmalloc(len);
	method[0] = '\0';
	strlcat(method, "keyboard-interactive", len);
	strlcat(method, "/", len);
	strlcat(method, kbdintctxt->device->name, len);

	if (!authctxt->postponed) {
		/* unregister callback */
a110 9
		if (authenticated) {
			kbdint_free(kbdintctxt);
			authctxt->kbdintctxt = NULL;
		} else {
			/* start next device */
			/* may set authctxt->postponed */
			auth2_challenge_start(authctxt);
		}
	}
a111 1
	xfree(method);
@


1.2.2.6
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.2.2.5 2001/09/27 00:15:41 miod Exp $");
d142 1
a142 1
 * try challenge-response, set authctxt->postponed if we have to
@


1.2.2.7
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2-chall.c,v 1.16 2002/01/13 17:57:37 markus Exp $");
a29 1
#include "buffer.h"
d38 1
a38 1
static void input_userauth_info_response(int, u_int32_t, void *);
a70 1
	Buffer b;
d72 1
d76 1
a76 1
		buffer_init(&b);
d78 3
a80 4
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, devices[i]->name,
			    strlen(devices[i]->name));
d82 2
a83 3
		buffer_append(&b, "\0", 1);
		kbdintctxt->devices = xstrdup(buffer_ptr(&b));
		buffer_free(&b);
a86 1
	debug("kbdint_alloc: devices '%s'", kbdintctxt->devices);
d154 1
a154 1
	if (authctxt->kbdintctxt == NULL)
a158 12
/* unregister kbd-int callbacks and context */
void
auth2_challenge_stop(Authctxt *authctxt)
{
	/* unregister callback */
	dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);
	if (authctxt->kbdintctxt != NULL)  {
		kbdint_free(authctxt->kbdintctxt);
		authctxt->kbdintctxt = NULL;
	}
}

d169 2
a170 1
		auth2_challenge_stop(authctxt);
d177 2
a178 1
		auth2_challenge_stop(authctxt);
d182 2
a183 1
		auth2_challenge_stop(authctxt);
d228 1
a228 1
input_userauth_info_response(int type, u_int32_t seq, void *ctxt)
d251 1
a251 1
	packet_check_eom();
d274 4
a277 2
		if (send_userauth_info_request(authctxt) == 1)
			authctxt->postponed = 1;
d287 4
a290 2
	snprintf(method, len, "keyboard-interactive/%s",
	    kbdintctxt->device->name);
d293 3
d297 2
a298 1
			auth2_challenge_stop(authctxt);
@


1.1
log
@rename *-skey.c *-chall.c since the files are not skey specific
@
text
@d25 1
a25 1
RCSID("$OpenBSD: auth2-skey.c,v 1.3 2001/01/18 16:59:59 markus Exp $");
a26 1
#include "ssh.h"
d32 1
@

