head	1.29;
access;
symbols
	OPENBSD_6_0:1.29.0.10
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.6
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.30
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.28
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.26
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.24
	OPENBSD_5_0:1.27.0.22
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.20
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.18
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.14
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.16
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.12
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.10
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.8
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.6
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.4
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.12
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.10
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.8
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.6
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.4
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2;
locks; strict;
comment	@ * @;


1.29
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.28;
commitid	U9l75XYAjMKaQ8Jp;

1.28
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.04.05.15.59;	author djm;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches
	1.23.10.1
	1.23.12.1;
next	1.22;

1.22
date	2002.03.24.17.27.03;	author stevesk;	state Exp;
branches
	1.22.2.1
	1.22.4.1;
next	1.21;

1.21
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.28.15.46.33;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.23.17.59.02;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.31.13.35.11;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.25.22.07.40;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.28.13.57.33;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.27.19.37.23;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.17.19.27.15;	author stevesk;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.23.02.34.29;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.07.20.23.04;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.05.10.42.50;	author markus;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2001.04.04.22.04.35;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.04.09.48.34;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.03.23.32.12;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.03.19.53.29;	author markus;	state Exp;
branches;
next	;

1.5.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.07.21.09.30;	author jason;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.9.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	;

1.22.2.1
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.22.4.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.23.10.1
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.23.12.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.23.12.2;

1.23.12.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.23.12.3;

1.23.12.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.24.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;


desc
@@


1.29
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@/* $OpenBSD: kexgex.c,v 1.28 2014/01/09 23:20:00 djm Exp $ */
/*
 * Copyright (c) 2000 Niels Provos.  All rights reserved.
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <openssl/evp.h>
#include <signal.h>

#include "sshkey.h"
#include "cipher.h"
#include "kex.h"
#include "ssh2.h"
#include "ssherr.h"
#include "sshbuf.h"
#include "digest.h"

int
kexgex_hash(
    int hash_alg,
    const char *client_version_string,
    const char *server_version_string,
    const u_char *ckexinit, size_t ckexinitlen,
    const u_char *skexinit, size_t skexinitlen,
    const u_char *serverhostkeyblob, size_t sbloblen,
    int min, int wantbits, int max,
    const BIGNUM *prime,
    const BIGNUM *gen,
    const BIGNUM *client_dh_pub,
    const BIGNUM *server_dh_pub,
    const BIGNUM *shared_secret,
    u_char *hash, size_t *hashlen)
{
	struct sshbuf *b;
	int r;

	if (*hashlen < ssh_digest_bytes(SSH_DIGEST_SHA1))
		return SSH_ERR_INVALID_ARGUMENT;
	if ((b = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_put_cstring(b, client_version_string)) != 0 ||
	    (r = sshbuf_put_cstring(b, server_version_string)) != 0 ||
	    /* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
	    (r = sshbuf_put_u32(b, ckexinitlen+1)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_KEXINIT)) != 0 ||
	    (r = sshbuf_put(b, ckexinit, ckexinitlen)) != 0 ||
	    (r = sshbuf_put_u32(b, skexinitlen+1)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_KEXINIT)) != 0 ||
	    (r = sshbuf_put(b, skexinit, skexinitlen)) != 0 ||
	    (r = sshbuf_put_string(b, serverhostkeyblob, sbloblen)) != 0 ||
	    (min != -1 && (r = sshbuf_put_u32(b, min)) != 0) ||
	    (r = sshbuf_put_u32(b, wantbits)) != 0 ||
	    (max != -1 && (r = sshbuf_put_u32(b, max)) != 0) ||
	    (r = sshbuf_put_bignum2(b, prime)) != 0 ||
	    (r = sshbuf_put_bignum2(b, gen)) != 0 ||
	    (r = sshbuf_put_bignum2(b, client_dh_pub)) != 0 ||
	    (r = sshbuf_put_bignum2(b, server_dh_pub)) != 0 ||
	    (r = sshbuf_put_bignum2(b, shared_secret)) != 0) {
		sshbuf_free(b);
		return r;
	}
#ifdef DEBUG_KEXDH
	sshbuf_dump(b, stderr);
#endif
	if (ssh_digest_buffer(hash_alg, b, hash, *hashlen) != 0) {
		sshbuf_free(b);
		return SSH_ERR_LIBCRYPTO_ERROR;
	}
	sshbuf_free(b);
	*hashlen = ssh_digest_bytes(hash_alg);
#ifdef DEBUG_KEXDH
	dump_digest("hash", hash, *hashlen);
#endif
	return 0;
}
@


1.28
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexgex.c,v 1.27 2006/08/03 03:34:42 deraadt Exp $ */
d32 1
a32 2
#include "buffer.h"
#include "key.h"
d36 2
a38 1
#include "log.h"
d40 1
a40 1
void
d43 12
a54 10
    char *client_version_string,
    char *server_version_string,
    char *ckexinit, int ckexinitlen,
    char *skexinit, int skexinitlen,
    u_char *serverhostkeyblob, int sbloblen,
    int min, int wantbits, int max, BIGNUM *prime, BIGNUM *gen,
    BIGNUM *client_dh_pub,
    BIGNUM *server_dh_pub,
    BIGNUM *shared_secret,
    u_char **hash, u_int *hashlen)
d56 2
a57 2
	Buffer b;
	static u_char digest[SSH_DIGEST_MAX_LENGTH];
d59 24
a82 19
	buffer_init(&b);
	buffer_put_cstring(&b, client_version_string);
	buffer_put_cstring(&b, server_version_string);

	/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
	buffer_put_int(&b, ckexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, ckexinit, ckexinitlen);
	buffer_put_int(&b, skexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, skexinit, skexinitlen);

	buffer_put_string(&b, serverhostkeyblob, sbloblen);
	if (min == -1 || max == -1)
		buffer_put_int(&b, wantbits);
	else {
		buffer_put_int(&b, min);
		buffer_put_int(&b, wantbits);
		buffer_put_int(&b, max);
a83 6
	buffer_put_bignum2(&b, prime);
	buffer_put_bignum2(&b, gen);
	buffer_put_bignum2(&b, client_dh_pub);
	buffer_put_bignum2(&b, server_dh_pub);
	buffer_put_bignum2(&b, shared_secret);

d85 1
a85 1
	buffer_dump(&b);
d87 8
a94 7
	if (ssh_digest_buffer(hash_alg, &b, digest, sizeof(digest)) != 0)
		fatal("%s: ssh_digest_buffer failed", __func__);

	buffer_free(&b);

#ifdef DEBUG_KEX
	dump_digest("hash", digest, ssh_digest_bytes(hash_alg));
d96 1
a96 2
	*hash = digest;
	*hashlen = ssh_digest_bytes(hash_alg);
@


1.27
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: kexgex.c,v 1.26 2006/03/25 13:17:02 djm Exp $ */
d37 2
d42 1
a42 1
    const EVP_MD *evp_md,
d55 1
a55 2
	static u_char digest[EVP_MAX_MD_SIZE];
	EVP_MD_CTX md;
d86 2
d89 1
a89 3
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
	EVP_DigestFinal(&md, digest, NULL);
d91 3
a93 1
	buffer_free(&b);
d95 1
a95 4
	*hashlen = EVP_MD_size(evp_md);
#ifdef DEBUG_KEXDH
	dump_digest("hash", digest, *hashlen);
#endif
@


1.26
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d27 1
a27 1
#include "includes.h"
d30 1
d33 2
a34 1
#include "bufaux.h"
@


1.25
log
@RCSID() can die
@
text
@d1 1
@


1.24
log
@remove hardcoded hash lengths in key exchange code, allowing
implementation of KEX methods with different hashes (e.g. SHA-256);
ok markus@@ dtucker@@ stevesk@@
@
text
@a26 1
RCSID("$OpenBSD: kexgex.c,v 1.23 2003/02/16 17:09:57 markus Exp $");
@


1.24.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexgex.c,v 1.27 2006/08/03 03:34:42 deraadt Exp $ */
d26 2
a27 1
#include <sys/types.h>
a29 1
#include <signal.h>
d32 1
a32 2
#include "key.h"
#include "cipher.h"
@


1.24.2.2
log
@upgrade to OpenSSH 4.5
@
text
@@


1.23
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.22 2002/03/24 17:27:03 stevesk Exp $");
d36 1
a36 1
u_char *
d38 1
d47 2
a48 1
    BIGNUM *shared_secret)
a51 1
	const EVP_MD *evp_md = EVP_sha1();
d83 1
d89 2
a90 1

d92 1
a92 1
	dump_digest("hash", digest, EVP_MD_size(evp_md));
a93 1
	return digest;
@


1.23.12.1
log
@upgrade to OpenSSH 4.3
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.24 2005/11/04 05:15:59 djm Exp $");
d36 1
a36 1
void
a37 1
    const EVP_MD *evp_md,
d46 1
a46 2
    BIGNUM *shared_secret,
    u_char **hash, u_int *hashlen)
d50 1
a81 1

d87 1
a87 2
	*hash = digest;
	*hashlen = EVP_MD_size(evp_md);
d89 1
a89 1
	dump_digest("hash", digest, *hashlen);
d91 1
@


1.23.12.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexgex.c,v 1.27 2006/08/03 03:34:42 deraadt Exp $ */
d26 2
a27 1
#include <sys/types.h>
a29 1
#include <signal.h>
d32 1
a32 2
#include "key.h"
#include "cipher.h"
@


1.23.12.3
log
@upgrade to OpenSSH 4.5
@
text
@@


1.23.10.1
log
@upgrade to OpenSSH 4.3
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.24 2005/11/04 05:15:59 djm Exp $");
d36 1
a36 1
void
a37 1
    const EVP_MD *evp_md,
d46 1
a46 2
    BIGNUM *shared_secret,
    u_char **hash, u_int *hashlen)
d50 1
a81 1

d87 1
a87 2
	*hash = digest;
	*hashlen = EVP_MD_size(evp_md);
d89 1
a89 1
	dump_digest("hash", digest, *hashlen);
d91 1
@


1.22
log
@typo; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.21 2002/03/18 17:50:31 provos Exp $");
d29 1
a29 1
#include <openssl/bn.h>
a30 1
#include "xmalloc.h"
a32 1
#include "key.h"
a33 3
#include "log.h"
#include "packet.h"
#include "dh.h"
a34 2
#include "compat.h"
#include "monitor_wrap.h"
d36 1
a36 1
static u_char *
a91 315
}

/* client */

static void
kexgex_client(Kex *kex)
{
	BIGNUM *dh_server_pub = NULL, *shared_secret = NULL;
	BIGNUM *p = NULL, *g = NULL;
	Key *server_host_key;
	u_char *kbuf, *hash, *signature = NULL, *server_host_key_blob = NULL;
	u_int klen, kout, slen, sbloblen;
	int min, max, nbits;
	DH *dh;

	nbits = dh_estimate(kex->we_need * 8);

	if (datafellows & SSH_OLD_DHGEX) {
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD sent");

		/* Old GEX request */
		packet_start(SSH2_MSG_KEX_DH_GEX_REQUEST_OLD);
		packet_put_int(nbits);
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;
	} else {
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST sent");

		/* New GEX request */
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;
		packet_start(SSH2_MSG_KEX_DH_GEX_REQUEST);
		packet_put_int(min);
		packet_put_int(nbits);
		packet_put_int(max);
	}
#ifdef DEBUG_KEXDH
	fprintf(stderr, "\nmin = %d, nbits = %d, max = %d\n",
	    min, nbits, max);
#endif
	packet_send();

	debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_GROUP);

	if ((p = BN_new()) == NULL)
		fatal("BN_new");
	packet_get_bignum2(p);
	if ((g = BN_new()) == NULL)
		fatal("BN_new");
	packet_get_bignum2(g);
	packet_check_eom();

	if (BN_num_bits(p) < min || BN_num_bits(p) > max)
		fatal("DH_GEX group out of range: %d !< %d !< %d",
		    min, BN_num_bits(p), max);

	dh = dh_new_group(g, p);
	dh_gen_key(dh, kex->we_need * 8);

#ifdef DEBUG_KEXDH
	DHparams_print_fp(stderr, dh);
	fprintf(stderr, "pub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
#endif

	debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
	/* generate and send 'e', client DH public key */
	packet_start(SSH2_MSG_KEX_DH_GEX_INIT);
	packet_put_bignum2(dh->pub_key);
	packet_send();

	debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_REPLY);

	/* key, cert */
	server_host_key_blob = packet_get_string(&sbloblen);
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
	if (server_host_key == NULL)
		fatal("cannot decode server_host_key_blob");
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
	if (kex->verify_host_key == NULL)
		fatal("cannot verify server_host_key");
	if (kex->verify_host_key(server_host_key) == -1)
		fatal("server_host_key verification failed");

	/* DH paramter f, server public DH key */
	if ((dh_server_pub = BN_new()) == NULL)
		fatal("dh_server_pub == NULL");
	packet_get_bignum2(dh_server_pub);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "dh_server_pub= ");
	BN_print_fp(stderr, dh_server_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_server_pub));
#endif

	/* signed H */
	signature = packet_get_string(&slen);
	packet_check_eom();

	if (!dh_pub_is_valid(dh, dh_server_pub))
		packet_disconnect("bad server public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_server_pub, dh);
#ifdef DEBUG_KEXDH
	dump_digest("shared secret", kbuf, kout);
#endif
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_client: BN_new failed");
	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	if (datafellows & SSH_OLD_DHGEX)
		min = max = -1;

	/* calc and verify H */
	hash = kexgex_hash(
	    kex->client_version_string,
	    kex->server_version_string,
	    buffer_ptr(&kex->my), buffer_len(&kex->my),
	    buffer_ptr(&kex->peer), buffer_len(&kex->peer),
	    server_host_key_blob, sbloblen,
	    min, nbits, max,
	    dh->p, dh->g,
	    dh->pub_key,
	    dh_server_pub,
	    shared_secret
	);
	/* have keys, free DH */
	DH_free(dh);
	xfree(server_host_key_blob);
	BN_clear_free(dh_server_pub);

	if (key_verify(server_host_key, signature, slen, hash, 20) != 1)
		fatal("key_verify failed for server_host_key");
	key_free(server_host_key);
	xfree(signature);

	/* save session id */
	if (kex->session_id == NULL) {
		kex->session_id_len = 20;
		kex->session_id = xmalloc(kex->session_id_len);
		memcpy(kex->session_id, hash, kex->session_id_len);
	}
	kex_derive_keys(kex, hash, shared_secret);
	BN_clear_free(shared_secret);

	kex_finish(kex);
}

/* server */

static void
kexgex_server(Kex *kex)
{
	BIGNUM *shared_secret = NULL, *dh_client_pub = NULL;
	Key *server_host_key;
	DH *dh;
	u_char *kbuf, *hash, *signature = NULL, *server_host_key_blob = NULL;
	u_int sbloblen, klen, kout, slen;
	int min = -1, max = -1, nbits = -1, type;

	if (kex->load_host_key == NULL)
		fatal("Cannot load hostkey");
	server_host_key = kex->load_host_key(kex->hostkey_type);
	if (server_host_key == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);

	type = packet_read();
	switch (type) {
	case SSH2_MSG_KEX_DH_GEX_REQUEST:
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
		min = packet_get_int();
		nbits = packet_get_int();
		max = packet_get_int();
		min = MAX(DH_GRP_MIN, min);
		max = MIN(DH_GRP_MAX, max);
		break;
	case SSH2_MSG_KEX_DH_GEX_REQUEST_OLD:
		debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
		nbits = packet_get_int();
		min = DH_GRP_MIN;
		max = DH_GRP_MAX;
		/* unused for old GEX */
		break;
	default:
		fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
	}
	packet_check_eom();

	if (max < min || nbits < min || max < nbits)
		fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d",
		    min, nbits, max);

	/* Contact privileged parent */
	dh = PRIVSEP(choose_dh(min, nbits, max));
	if (dh == NULL)
		packet_disconnect("Protocol error: no matching DH grp found");

	debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
	packet_start(SSH2_MSG_KEX_DH_GEX_GROUP);
	packet_put_bignum2(dh->p);
	packet_put_bignum2(dh->g);
	packet_send();

	/* flush */
	packet_write_wait();

	/* Compute our exchange value in parallel with the client */
	dh_gen_key(dh, kex->we_need * 8);

	debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_INIT);

	/* key, cert */
	if ((dh_client_pub = BN_new()) == NULL)
		fatal("dh_client_pub == NULL");
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();

#ifdef DEBUG_KEXDH
	fprintf(stderr, "dh_client_pub= ");
	BN_print_fp(stderr, dh_client_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_client_pub));
#endif

#ifdef DEBUG_KEXDH
	DHparams_print_fp(stderr, dh);
	fprintf(stderr, "pub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
#endif
	if (!dh_pub_is_valid(dh, dh_client_pub))
		packet_disconnect("bad client public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_client_pub, dh);
#ifdef DEBUG_KEXDH
	dump_digest("shared secret", kbuf, kout);
#endif
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_server: BN_new failed");
	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	key_to_blob(server_host_key, &server_host_key_blob, &sbloblen);

	if (type == SSH2_MSG_KEX_DH_GEX_REQUEST_OLD)
		min = max = -1;

	/* calc H */			/* XXX depends on 'kex' */
	hash = kexgex_hash(
	    kex->client_version_string,
	    kex->server_version_string,
	    buffer_ptr(&kex->peer), buffer_len(&kex->peer),
	    buffer_ptr(&kex->my), buffer_len(&kex->my),
	    server_host_key_blob, sbloblen,
	    min, nbits, max,
	    dh->p, dh->g,
	    dh_client_pub,
	    dh->pub_key,
	    shared_secret
	);
	BN_clear_free(dh_client_pub);

	/* save session id := H */
	/* XXX hashlen depends on KEX */
	if (kex->session_id == NULL) {
		kex->session_id_len = 20;
		kex->session_id = xmalloc(kex->session_id_len);
		memcpy(kex->session_id, hash, kex->session_id_len);
	}

	/* sign H */
	/* XXX hashlen depends on KEX */
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, 20));

	/* destroy_sensitive_data(); */

	/* send server hostkey, DH pubkey 'f' and singed H */
	debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
	packet_start(SSH2_MSG_KEX_DH_GEX_REPLY);
	packet_put_string(server_host_key_blob, sbloblen);
	packet_put_bignum2(dh->pub_key);	/* f */
	packet_put_string(signature, slen);
	packet_send();

	xfree(signature);
	xfree(server_host_key_blob);
	/* have keys, free DH */
	DH_free(dh);

	kex_derive_keys(kex, hash, shared_secret);
	BN_clear_free(shared_secret);

	kex_finish(kex);
}

void
kexgex(Kex *kex)
{
	if (kex->server)
		kexgex_server(kex);
	else
		kexgex_client(kex);
@


1.22.2.1
log
@Merge OpenSSH 3.6.1
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.23 2003/02/16 17:09:57 markus Exp $");
d29 1
a29 1
#include <openssl/evp.h>
d31 1
d34 1
d36 3
d40 2
d43 1
a43 1
u_char *
d99 315
@


1.22.4.1
log
@Update to OpenSSH 3.6
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.23 2003/02/16 17:09:57 markus Exp $");
d29 1
a29 1
#include <openssl/evp.h>
d31 1
d34 1
d36 3
d40 2
d43 1
a43 1
u_char *
d99 315
@


1.22.4.2
log
@upgrade to OpenSSH 3.7
@
text
@@


1.21
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.20 2002/02/28 15:46:33 markus Exp $");
d263 1
a263 1
	DH *dh = dh;
@


1.20
log
@add some const EVP_MD for openssl-0.9.7
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.19 2002/02/24 19:14:59 markus Exp $");
d41 1
d300 2
a301 1
	dh = choose_dh(min, nbits, max);
d384 1
a384 1
	key_sign(server_host_key, &signature, &slen, hash, 20);
d395 1
@


1.19
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.18 2002/02/23 17:59:02 markus Exp $");
d56 1
a56 1
	EVP_MD *evp_md = EVP_sha1();
@


1.18
log
@don't allow garbage after payload.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.17 2002/01/31 13:35:11 markus Exp $");
d264 2
a265 2
	u_int sbloblen, klen, kout;
	int min = -1, max = -1, nbits = -1, type, slen;
@


1.17
log
@cross check announced key type and type from key blob
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.16 2002/01/25 22:07:40 markus Exp $");
d322 1
@


1.16
log
@use EVP_MD_size(evp_md) and not evp_md->md_size; ok steveks@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.15 2001/12/28 14:50:54 markus Exp $");
d179 2
a180 1

@


1.15
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.14 2001/12/28 13:57:33 markus Exp $");
d95 1
a95 1
	dump_digest("hash", digest, evp_md->md_size);
@


1.14
log
@packet_get_bignum* no longer returns a size
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.13 2001/12/28 12:14:27 markus Exp $");
d110 1
a110 1
	int plen, min, max, nbits;
d141 1
a141 1
	packet_read_expect(&plen, SSH2_MSG_KEX_DH_GEX_GROUP);
d172 1
a172 1
	packet_read_expect(&plen, SSH2_MSG_KEX_DH_GEX_REPLY);
d264 1
a264 1
	int min = -1, max = -1, nbits = -1, type, plen, slen;
d272 1
a272 1
	type = packet_read(&plen);
d315 1
a315 1
	packet_read_expect(&plen, SSH2_MSG_KEX_DH_GEX_INIT);
@


1.13
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.12 2001/12/27 19:37:23 markus Exp $");
d110 1
a110 1
	int dlen, plen, min, max, nbits;
d145 1
a145 1
	packet_get_bignum2(p, &dlen);
d148 1
a148 1
	packet_get_bignum2(g, &dlen);
d188 1
a188 1
	packet_get_bignum2(dh_server_pub, &dlen);
d264 1
a264 1
	int min = -1, max = -1, nbits = -1, type, plen, dlen, slen;
d320 1
a320 1
	packet_get_bignum2(dh_client_pub, &dlen);
@


1.12
log
@always use BN_clear_free instead of BN_free
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.11 2001/12/27 18:22:16 markus Exp $");
d149 1
a149 1
	packet_done();
d199 1
a199 1
	packet_done();
d292 1
a292 1
	packet_done();
@


1.11
log
@call fatal() for openssl allocation failures
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.10 2001/12/05 10:06:12 deraadt Exp $");
d235 1
a235 1
	BN_free(dh_server_pub);
d368 1
a368 1
	BN_free(dh_client_pub);
@


1.10
log
@minor KNF
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.9 2001/09/17 19:27:15 stevesk Exp $");
d186 1
a186 2
	dh_server_pub = BN_new();
	if (dh_server_pub == NULL)
d210 2
a211 1
	shared_secret = BN_new();
d318 1
a318 2
	dh_client_pub = BN_new();
	if (dh_client_pub == NULL)
d344 2
a345 1
	shared_secret = BN_new();
@


1.9
log
@u_char*/char* cleanup; ok markus@@
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.8 2001/06/23 15:12:19 itojun Exp $");
d273 1
a273 1
	switch(type){
@


1.9.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.20 2002/02/28 15:46:33 markus Exp $");
d56 1
a56 1
	const EVP_MD *evp_md = EVP_sha1();
d95 1
a95 1
	dump_digest("hash", digest, EVP_MD_size(evp_md));
d110 1
a110 1
	int min, max, nbits;
d141 1
a141 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_GROUP);
d145 1
a145 1
	packet_get_bignum2(p);
d148 2
a149 2
	packet_get_bignum2(g);
	packet_check_eom();
d172 1
a172 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_REPLY);
d179 1
a179 2
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
d186 2
a187 1
	if ((dh_server_pub = BN_new()) == NULL)
d189 1
a189 1
	packet_get_bignum2(dh_server_pub);
d200 1
a200 1
	packet_check_eom();
d211 1
a211 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_client: BN_new failed");
d235 1
a235 1
	BN_clear_free(dh_server_pub);
d263 2
a264 2
	u_int sbloblen, klen, kout, slen;
	int min = -1, max = -1, nbits = -1, type;
d272 2
a273 2
	type = packet_read();
	switch (type) {
d292 1
a292 1
	packet_check_eom();
d315 1
a315 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_INIT);
d318 2
a319 1
	if ((dh_client_pub = BN_new()) == NULL)
d321 1
a321 2
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();
d345 1
a345 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_server: BN_new failed");
d368 1
a368 1
	BN_clear_free(dh_client_pub);
@


1.9.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.22 2002/03/24 17:27:03 stevesk Exp $");
a40 1
#include "monitor_wrap.h"
d262 1
a262 1
	DH *dh;
d299 1
a299 2
	/* Contact privileged parent */
	dh = PRIVSEP(choose_dh(min, nbits, max));
d382 1
a382 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, 20));
a392 1

@


1.8
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.7 2001/06/23 02:34:29 markus Exp $");
d48 1
a48 1
    char *serverhostkeyblob, int sbloblen,
d237 1
a237 1
	if (key_verify(server_host_key, (u_char *)signature, slen, hash, 20) != 1)
d361 1
a361 1
	    (char *)server_host_key_blob, sbloblen,
d387 1
a387 1
	packet_put_string((char *)server_host_key_blob, sbloblen);
d389 1
a389 1
	packet_put_string((char *)signature, slen);
@


1.7
log
@get rid of known_hosts2, use it for hostkey lookup, but do not modify.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.6 2001/06/07 20:23:04 markus Exp $");
d42 1
a42 1
u_char *
d102 1
a102 1
void
d256 1
a256 1
void
@


1.6
log
@use xxx_put_cstring()
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.5 2001/04/05 10:42:50 markus Exp $");
d180 4
a183 3
	if (kex->check_host_key == NULL)
		fatal("cannot check server_host_key");
	kex->check_host_key(server_host_key);
@


1.5
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.4 2001/04/04 22:04:35 markus Exp $");
d60 2
a61 2
	buffer_put_string(&b, client_version_string, strlen(client_version_string));
	buffer_put_string(&b, server_version_string, strlen(server_version_string));
@


1.5.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.9 2001/09/17 19:27:15 stevesk Exp $");
d42 1
a42 1
static u_char *
d48 1
a48 1
    u_char *serverhostkeyblob, int sbloblen,
d60 2
a61 2
	buffer_put_cstring(&b, client_version_string);
	buffer_put_cstring(&b, server_version_string);
d102 1
a102 1
static void
d180 3
a182 4
	if (kex->verify_host_key == NULL)
		fatal("cannot verify server_host_key");
	if (kex->verify_host_key(server_host_key) == -1)
		fatal("server_host_key verification failed");
d236 1
a236 1
	if (key_verify(server_host_key, signature, slen, hash, 20) != 1)
d255 1
a255 1
static void
d360 1
a360 1
	    server_host_key_blob, sbloblen,
d386 1
a386 1
	packet_put_string(server_host_key_blob, sbloblen);
d388 1
a388 1
	packet_put_string(signature, slen);
@


1.5.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.20 2002/02/28 15:46:33 markus Exp $");
d56 1
a56 1
	const EVP_MD *evp_md = EVP_sha1();
d95 1
a95 1
	dump_digest("hash", digest, EVP_MD_size(evp_md));
d110 1
a110 1
	int min, max, nbits;
d141 1
a141 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_GROUP);
d145 1
a145 1
	packet_get_bignum2(p);
d148 2
a149 2
	packet_get_bignum2(g);
	packet_check_eom();
d172 1
a172 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_REPLY);
d179 1
a179 2
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
d186 2
a187 1
	if ((dh_server_pub = BN_new()) == NULL)
d189 1
a189 1
	packet_get_bignum2(dh_server_pub);
d200 1
a200 1
	packet_check_eom();
d211 1
a211 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_client: BN_new failed");
d235 1
a235 1
	BN_clear_free(dh_server_pub);
d263 2
a264 2
	u_int sbloblen, klen, kout, slen;
	int min = -1, max = -1, nbits = -1, type;
d272 2
a273 2
	type = packet_read();
	switch (type) {
d292 1
a292 1
	packet_check_eom();
d315 1
a315 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_INIT);
d318 2
a319 1
	if ((dh_client_pub = BN_new()) == NULL)
d321 1
a321 2
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();
d345 1
a345 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_server: BN_new failed");
d368 1
a368 1
	BN_clear_free(dh_client_pub);
@


1.5.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.22 2002/03/24 17:27:03 stevesk Exp $");
a40 1
#include "monitor_wrap.h"
d262 1
a262 1
	DH *dh;
d299 1
a299 2
	/* Contact privileged parent */
	dh = PRIVSEP(choose_dh(min, nbits, max));
d382 1
a382 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, 20));
a392 1

@


1.5.4.1
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.5 2001/04/05 10:42:50 markus Exp $");
@


1.5.4.2
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.9 2001/09/17 19:27:15 stevesk Exp $");
d42 1
a42 1
static u_char *
d48 1
a48 1
    u_char *serverhostkeyblob, int sbloblen,
d60 2
a61 2
	buffer_put_cstring(&b, client_version_string);
	buffer_put_cstring(&b, server_version_string);
d102 1
a102 1
static void
d180 3
a182 4
	if (kex->verify_host_key == NULL)
		fatal("cannot verify server_host_key");
	if (kex->verify_host_key(server_host_key) == -1)
		fatal("server_host_key verification failed");
d236 1
a236 1
	if (key_verify(server_host_key, signature, slen, hash, 20) != 1)
d255 1
a255 1
static void
d360 1
a360 1
	    server_host_key_blob, sbloblen,
d386 1
a386 1
	packet_put_string(server_host_key_blob, sbloblen);
d388 1
a388 1
	packet_put_string(signature, slen);
@


1.5.4.3
log
@Merge OpenSSH 3.1.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.20 2002/02/28 15:46:33 markus Exp $");
d56 1
a56 1
	const EVP_MD *evp_md = EVP_sha1();
d95 1
a95 1
	dump_digest("hash", digest, EVP_MD_size(evp_md));
d110 1
a110 1
	int min, max, nbits;
d141 1
a141 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_GROUP);
d145 1
a145 1
	packet_get_bignum2(p);
d148 2
a149 2
	packet_get_bignum2(g);
	packet_check_eom();
d172 1
a172 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_REPLY);
d179 1
a179 2
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
d186 2
a187 1
	if ((dh_server_pub = BN_new()) == NULL)
d189 1
a189 1
	packet_get_bignum2(dh_server_pub);
d200 1
a200 1
	packet_check_eom();
d211 1
a211 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_client: BN_new failed");
d235 1
a235 1
	BN_clear_free(dh_server_pub);
d263 2
a264 2
	u_int sbloblen, klen, kout, slen;
	int min = -1, max = -1, nbits = -1, type;
d272 2
a273 2
	type = packet_read();
	switch (type) {
d292 1
a292 1
	packet_check_eom();
d315 1
a315 1
	packet_read_expect(SSH2_MSG_KEX_DH_GEX_INIT);
d318 2
a319 1
	if ((dh_client_pub = BN_new()) == NULL)
d321 1
a321 2
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();
d345 1
a345 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexgex_server: BN_new failed");
d368 1
a368 1
	BN_clear_free(dh_client_pub);
@


1.4
log
@parse full kexinit packet.
make server-side more robust, too.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.3 2001/04/04 09:48:34 markus Exp $");
d72 1
a72 1
	if (min == -1 || max == -1) 
d208 1
a208 1
        dump_digest("shared secret", kbuf, kout);
d342 1
a342 1
        dump_digest("shared secret", kbuf, kout);
@


1.3
log
@don't sent multiple kexinit-requests.
send newkeys, block while waiting for newkeys.
fix comments.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.2 2001/04/03 23:32:12 markus Exp $");
d289 1
a289 1
		fatal("protocol error during kex, no DH_GEX_REQUEST");
@


1.2
log
@undo parts of recent my changes: main part of keyexchange does not
need dispatch-callbacks, since application data is delayed until
the keyexchange completes (if i understand the drafts correctly).

add some infrastructure for re-keying.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kexgex.c,v 1.1 2001/04/03 19:53:29 markus Exp $");
d231 2
a246 1

d250 1
a250 4
	kex_send_newkeys();

	/* have keys, free DH */
	DH_free(dh);
d392 2
d398 1
a398 4
	kex_send_newkeys();

	/* have keys, free DH */
	DH_free(dh);
@


1.1
log
@move kex to kex*.c, used dispatch_set() callbacks for kex. should
make rekeying easier.
@
text
@d27 1
a27 1
RCSID("$OpenBSD: kex.c,v 1.24 2001/03/28 21:59:40 provos Exp $");
a36 1
#include "dispatch.h"
a41 14
extern u_char *session_id2;
extern int session_id2_len;

typedef struct State State;
struct State {
	DH *dh;
	int min, nbits, max;
};

dispatch_fn kexgex_input_request;	/* C -> S */
dispatch_fn kexgex_input_group;		/* S -> C */
dispatch_fn kexgex_input_init;		/* C -> S */
dispatch_fn kexgex_input_reply;		/* S -> C */

d105 7
a111 1
	State *state;
d113 1
a113 5
	dispatch_set(SSH2_MSG_KEX_DH_GEX_GROUP, &kexgex_input_group);

	state = xmalloc(sizeof(*state));
	state->nbits = dh_estimate(kex->we_need * 8);
	kex->state = state;
d120 3
a122 3
		packet_put_int(state->nbits);
		state->min = DH_GRP_MIN;
		state->max = DH_GRP_MAX;
d127 2
a128 2
		state->min = DH_GRP_MIN;
		state->max = DH_GRP_MAX;
d130 3
a132 3
		packet_put_int(state->min);
		packet_put_int(state->nbits);
		packet_put_int(state->max);
d136 1
a136 1
	    state->min, state->nbits, state->max);
a138 1
}
d140 2
a141 12
void   
kexgex_input_group(int type, int plen, void *ctxt)
{
	DH *dh;
	int dlen;
	BIGNUM *p = 0, *g = 0;
	Kex *kex = (Kex*) ctxt;
	State *state = (State *) kex->state;

	debug("SSH2_MSG_KEX_DH_GEX_GROUP receivied");
	dispatch_set(SSH2_MSG_KEX_DH_GEX_GROUP, &kex_protocol_error);
	dispatch_set(SSH2_MSG_KEX_DH_GEX_REPLY, &kexgex_input_reply);
d149 1
d151 1
a151 1
	if (BN_num_bits(p) < state->min || BN_num_bits(p) > state->max)
d153 1
a153 1
		    state->min, BN_num_bits(p), state->max);
a157 2
	state->dh = dh;

a169 13
}

void   
kexgex_input_reply(int type, int plen, void *ctxt)
{
	BIGNUM *dh_server_pub = NULL, *shared_secret = NULL;
	Key *server_host_key;
	Kex *kex = (Kex*) ctxt;
	State *state = (State *) kex->state;
	DH *dh = state->dh;
	u_char *kbuf, *hash, *signature = NULL, *server_host_key_blob = NULL;
	u_int klen, kout, slen, sbloblen;
	int dlen, min, max;
d171 2
a172 2
	debug("SSH2_MSG_KEX_DH_GEX_REPLY received");
	dispatch_set(SSH2_MSG_KEX_DH_GEX_REPLY, &kex_protocol_error);
d215 1
a215 1
	if (datafellows & SSH_OLD_DHGEX) {
a216 4
	} else {
		min = state->min;
		max = state->max;
	}
d225 1
a225 1
	    min, state->nbits, max,
d239 7
a247 6
	packet_set_kex(kex);

	/* save session id */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);
a252 2
	xfree(state);
	kex->state = NULL;
d260 6
a265 1
	State *state;
d267 5
a271 17
	state = xmalloc(sizeof(*state));
	kex->state = state;
	
	dispatch_set(SSH2_MSG_KEX_DH_GEX_REQUEST, &kexgex_input_request);
	dispatch_set(SSH2_MSG_KEX_DH_GEX_REQUEST_OLD, &kexgex_input_request);
}

void
kexgex_input_request(int type, int plen, void *ctxt)
{
	Kex *kex = (Kex*) ctxt;
	State *state = (State *) kex->state;
	int min = -1, max = -1;

	dispatch_set(SSH2_MSG_KEX_DH_GEX_REQUEST, &kex_protocol_error);
	dispatch_set(SSH2_MSG_KEX_DH_GEX_REQUEST_OLD, &kex_protocol_error);
	dispatch_set(SSH2_MSG_KEX_DH_GEX_INIT, &kexgex_input_init);
d273 1
d278 1
a278 1
		state->nbits = packet_get_int();
a281 2
		state->min = min;
		state->max = max;
d285 1
a285 1
		state->nbits = packet_get_int();
a288 2
		state->min = -1;
		state->max = -1;
d290 2
d295 1
a295 1
	if (max < min || state->nbits < min || max < state->nbits)
d297 1
a297 1
		    min, state->nbits, max);
d299 2
a300 2
	state->dh = choose_dh(min, state->nbits, max);
	if (state->dh == NULL)
d305 2
a306 2
	packet_put_bignum2(state->dh->p);
	packet_put_bignum2(state->dh->g);
d313 1
a313 2
	dh_gen_key(state->dh, kex->we_need * 8);
}
d315 2
a316 20
void
kexgex_input_init(int type, int plen, void *ctxt)
{
	BIGNUM *shared_secret = NULL, *dh_client_pub = NULL;
	Key *server_host_key;
	Kex *kex = (Kex*) ctxt;
	State *state = (State *) kex->state;
	DH *dh = state->dh;
	u_char *kbuf, *hash, *signature = NULL, *server_host_key_blob = NULL;
	u_int sbloblen, klen, kout;
	int dlen, slen;

	if (kex->load_host_key == NULL)
		fatal("Cannot load hostkey");
	server_host_key = kex->load_host_key(kex->hostkey_type);
	if (server_host_key == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);

	dispatch_set(SSH2_MSG_KEX_DH_GEX_INIT, &kex_protocol_error);
	debug("SSH2_MSG_KEX_DH_GEX_INIT received");
d353 3
d363 1
a363 1
	    state->min, state->nbits, state->max,
d373 5
a377 3
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);
a393 1
	/* packet_write_wait(); */
a396 1
	packet_set_kex(kex);
a401 2
	xfree(state);
	kex->state = NULL;
@

