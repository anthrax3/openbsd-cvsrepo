head	1.133;
access;
symbols
	OPENBSD_6_1:1.131.0.4
	OPENBSD_6_1_BASE:1.131
	OPENBSD_6_0:1.118.0.4
	OPENBSD_6_0_BASE:1.118
	OPENBSD_5_9:1.117.0.2
	OPENBSD_5_9_BASE:1.117
	OPENBSD_5_8:1.109.0.2
	OPENBSD_5_8_BASE:1.109
	OPENBSD_5_7:1.105.0.2
	OPENBSD_5_7_BASE:1.105
	OPENBSD_5_6:1.99.0.4
	OPENBSD_5_6_BASE:1.99
	OPENBSD_5_5:1.98.0.4
	OPENBSD_5_5_BASE:1.98
	OPENBSD_5_4:1.91.0.2
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.88.0.2
	OPENBSD_5_3_BASE:1.88
	OPENBSD_5_2:1.86.0.8
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.86
	OPENBSD_5_1:1.86.0.6
	OPENBSD_5_0:1.86.0.4
	OPENBSD_5_0_BASE:1.86
	OPENBSD_4_9:1.86.0.2
	OPENBSD_4_9_BASE:1.86
	OPENBSD_4_8:1.82.0.4
	OPENBSD_4_8_BASE:1.82
	OPENBSD_4_7:1.82.0.2
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.81.0.4
	OPENBSD_4_6_BASE:1.81
	OPENBSD_4_5:1.80.0.2
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.79.0.6
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.79.0.4
	OPENBSD_4_3_BASE:1.79
	OPENBSD_4_2:1.79.0.2
	OPENBSD_4_2_BASE:1.79
	OPENBSD_4_1:1.77.0.2
	OPENBSD_4_1_BASE:1.77
	OPENBSD_4_0:1.76.0.4
	OPENBSD_4_0_BASE:1.76
	OPENBSD_3_9:1.65.0.2
	OPENBSD_3_9_BASE:1.65
	OPENBSD_3_8:1.64.0.2
	OPENBSD_3_8_BASE:1.64
	OPENBSD_3_7:1.60.0.4
	OPENBSD_3_7_BASE:1.60
	OPENBSD_3_6:1.60.0.2
	OPENBSD_3_6_BASE:1.60
	OPENBSD_3_5:1.56.0.2
	OPENBSD_3_5_BASE:1.56
	OPENBSD_3_4:1.55.0.2
	OPENBSD_3_4_BASE:1.55
	OPENBSD_3_3:1.54.0.2
	OPENBSD_3_3_BASE:1.54
	OPENBSD_3_2:1.51.0.2
	OPENBSD_3_2_BASE:1.51
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	OPENBSD_3_0:1.36.0.2
	OPENBSD_3_0_BASE:1.36
	OPENBSD_2_9_BASE:1.33
	OPENBSD_2_9:1.33.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.133
date	2017.05.30.14.23.52;	author markus;	state Exp;
branches;
next	1.132;
commitid	tEOGxoM4kvBMLD6J;

1.132
date	2017.04.30.23.10.43;	author djm;	state Exp;
branches;
next	1.131;
commitid	I15vriCkYNtbTkea;

1.131
date	2017.03.15.07.07.39;	author markus;	state Exp;
branches;
next	1.130;
commitid	ySZ3kk1oOy3i24Ib;

1.130
date	2017.03.10.04.07.20;	author djm;	state Exp;
branches;
next	1.129;
commitid	jIzoiBuLJ7h3Ymf6;

1.129
date	2017.03.10.03.45.40;	author dtucker;	state Exp;
branches;
next	1.128;
commitid	tjbZVI1jvpbiS0oa;

1.128
date	2017.02.03.23.01.19;	author djm;	state Exp;
branches;
next	1.127;
commitid	0GOZFYpYrdIWnKZ0;

1.127
date	2016.10.10.19.28.48;	author markus;	state Exp;
branches;
next	1.126;
commitid	idvnaSXavKustHDf;

1.126
date	2016.09.28.21.44.52;	author djm;	state Exp;
branches;
next	1.125;
commitid	dcmMFjyoLwi1xMmB;

1.125
date	2016.09.28.20.32.42;	author djm;	state Exp;
branches;
next	1.124;
commitid	TvNoQIkfkdH4jhbD;

1.124
date	2016.09.22.17.52.53;	author djm;	state Exp;
branches;
next	1.123;
commitid	24XlrT6KrgNX4lKF;

1.123
date	2016.09.21.19.53.12;	author djm;	state Exp;
branches;
next	1.122;
commitid	XK7Knv3Am8PdFbGY;

1.122
date	2016.09.19.19.02.19;	author markus;	state Exp;
branches;
next	1.121;
commitid	EtE4Ip50qA5cyvN4;

1.121
date	2016.09.12.23.31.27;	author djm;	state Exp;
branches;
next	1.120;
commitid	LKO6f6n1OiczQZjL;

1.120
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.119;
commitid	ZllbGwdb0fOmLhjK;

1.119
date	2016.09.06.09.14.05;	author markus;	state Exp;
branches;
next	1.118;
commitid	VOnuVOgH1XFyp45V;

1.118
date	2016.05.02.10.26.04;	author djm;	state Exp;
branches
	1.118.4.1;
next	1.117;
commitid	rVUG0L3JBpFl5b0k;

1.117
date	2016.02.08.10.57.07;	author djm;	state Exp;
branches
	1.117.2.1;
next	1.116;
commitid	eSwtzi7BWC7eBzrp;

1.116
date	2016.01.14.16.17.39;	author markus;	state Exp;
branches;
next	1.115;
commitid	W9ye0gltieEl87AJ;

1.115
date	2015.12.13.22.42.23;	author djm;	state Exp;
branches;
next	1.114;
commitid	1ml7B5FmYhobqWcy;

1.114
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.113;
commitid	qST12VGCwbX5zIfM;

1.113
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.112;
commitid	K3glY441IowbrjDE;

1.112
date	2015.11.13.04.39.35;	author djm;	state Exp;
branches;
next	1.111;
commitid	g4BiDrLxrvQbmNIa;

1.111
date	2015.10.13.00.21.27;	author djm;	state Exp;
branches;
next	1.110;
commitid	VRK59JXTmR8YmsB5;

1.110
date	2015.08.21.23.57.48;	author djm;	state Exp;
branches;
next	1.109;
commitid	jQHfyjlCOM5jpPmQ;

1.109
date	2015.07.30.00.01.34;	author djm;	state Exp;
branches;
next	1.108;
commitid	YReS3Mui4FCZvL7z;

1.108
date	2015.07.29.08.34.54;	author djm;	state Exp;
branches;
next	1.107;
commitid	0TsKMnfPfQ03zAOY;

1.107
date	2015.07.29.04.43.06;	author djm;	state Exp;
branches;
next	1.106;
commitid	2orWlXaVca3RWjbl;

1.106
date	2015.04.17.13.25.52;	author djm;	state Exp;
branches;
next	1.105;
commitid	KGilDP1XsSmVtOD4;

1.105
date	2015.01.30.00.22.25;	author djm;	state Exp;
branches;
next	1.104;
commitid	0hne80d5on2SEsVq;

1.104
date	2015.01.26.06.10.03;	author djm;	state Exp;
branches;
next	1.103;
commitid	F603CYAZ9E536XCr;

1.103
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	cBx23BaCk6gYBpRj;

1.102
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.101;
commitid	U9l75XYAjMKaQ8Jp;

1.101
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.100;
commitid	GrtSC5ve2VERgUln;

1.100
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.99;
commitid	UHlhoIB5NMb8eAPm;

1.99
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2014.01.25.20.35.37;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2014.01.25.10.12.50;	author dtucker;	state Exp;
branches;
next	1.95;

1.95
date	2014.01.12.08.13.13;	author djm;	state Exp;
branches;
next	1.94;

1.94
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.93;

1.93
date	2013.11.07.11.58.27;	author dtucker;	state Exp;
branches;
next	1.92;

1.92
date	2013.11.02.21.59.15;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.19.12.07.08;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2013.04.19.01.06.50;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2013.01.08.18.49.04;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2012.08.17.01.22.56;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2010.09.22.05.01.29;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2010.09.09.10.45.45;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.24.11.13.54;	author andreas;	state Exp;
branches;
next	1.81;

1.81
date	2009.05.27.06.34.36;	author andreas;	state Exp;
branches;
next	1.80;

1.80
date	2008.09.06.12.24.13;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.05.06.52.37;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2007.05.30.05.58.13;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2007.01.21.01.41.54;	author stevesk;	state Exp;
branches;
next	1.76;

1.76
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.74;

1.74
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.73;

1.73
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.20.18.48.34;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.19.18.53.12;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.07.09.07.40;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.04.05.15.59;	author djm;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2005.07.25.11.59.39;	author markus;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.16.01.35.24;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2005.06.17.02.44.32;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches
	1.60.2.1
	1.60.4.1;
next	1.59;

1.59
date	2004.06.13.12.53.24;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2004.05.09.01.26.48;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.09.01.19.27;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2003.04.01.10.31.26;	author markus;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2003.02.02.10.56.08;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2002.11.21.22.45.31;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.24.14.55.38;	author markus;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2002.05.15.15.47.49;	author mouring;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.26.23.14.51;	author markus;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.28.15.46.33;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.23.17.59.02;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.14.23.41.01;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.11.16.10.15;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.25.22.07.40;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.11.13.39.36;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.25.08.25.37;	author markus;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.06.23.15.12.18;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.30.15.50.46;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.05.10.42.50;	author markus;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2001.04.04.23.09.18;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.04.22.04.34;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.04.20.25.37;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.04.14.34.58;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.04.09.48.34;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.03.23.32.11;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.03.19.53.29;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.29.21.17.39;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.28.21.59.40;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.10.17.51.04;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.05.17.17.20;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.11.12.59.24;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.08.19.30.51;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.04.15.32.23;	author stevesk;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.21.19.05.49;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.08.21.48.17;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.20.19.37.22;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.19.23.17.56;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.15.17.30.14;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.12.19.50.37;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.10.11.04.02.17;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.07.20.27.51;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.10.16.30.25;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.20.01.39.41;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.25.20.45.20;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.08.17.42.25;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.04.14.10.30.31;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.12.09.39.10;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.12.07.03.05;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.12.06.37.02;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.03.20.06.15;	author markus;	state Exp;
branches;
next	;

1.6.2.1
date	2000.06.12.02.37.33;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.09.01.18.23.20;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2000.11.08.21.30.51;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.03.12.15.44.11;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.03.21.18.52.47;	author jason;	state Exp;
branches;
next	;

1.12.2.1
date	2001.02.16.20.13.03;	author jason;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.02.19.17.18.59;	author jason;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.03.21.19.46.25;	author jason;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.05.07.21.09.30;	author jason;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.33.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.36.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2002.06.26.18.22.35;	author miod;	state Exp;
branches;
next	;

1.49.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.49.2.4;

1.49.2.4
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.51.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2003.04.03.23.27.12;	author margarida;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	;

1.54.2.1
date	2003.05.11.12.01.52;	author margarida;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.55.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.56.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.60.2.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.60.4.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	1.60.4.2;

1.60.4.2
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.64.2.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.65.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;

1.117.2.1
date	2016.10.10.19.37.33;	author markus;	state Exp;
branches;
next	;
commitid	kT2lbqfPlRFmQ0cD;

1.118.4.1
date	2016.10.10.19.35.47;	author markus;	state Exp;
branches;
next	;
commitid	HA7TcxuuEcnlInIA;


desc
@@


1.133
log
@protocol handlers all get struct ssh passed; ok djm@@
@
text
@/* $OpenBSD: kex.c,v 1.132 2017/04/30 23:10:43 djm Exp $ */
/*
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WITH_OPENSSL
#include <openssl/crypto.h>
#endif

#include "ssh2.h"
#include "packet.h"
#include "compat.h"
#include "cipher.h"
#include "sshkey.h"
#include "kex.h"
#include "log.h"
#include "mac.h"
#include "match.h"
#include "misc.h"
#include "dispatch.h"
#include "monitor.h"

#include "ssherr.h"
#include "sshbuf.h"
#include "digest.h"

/* prototype */
static int kex_choose_conf(struct ssh *);
static int kex_input_newkeys(int, u_int32_t, struct ssh *);

static const char *proposal_names[PROPOSAL_MAX] = {
	"KEX algorithms",
	"host key algorithms",
	"ciphers ctos",
	"ciphers stoc",
	"MACs ctos",
	"MACs stoc",
	"compression ctos",
	"compression stoc",
	"languages ctos",
	"languages stoc",
};

struct kexalg {
	char *name;
	u_int type;
	int ec_nid;
	int hash_alg;
};
static const struct kexalg kexalgs[] = {
#ifdef WITH_OPENSSL
	{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },
	{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },
	{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },
	{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },
	{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },
	{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },
	{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },
	{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,
	    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },
	{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,
	    SSH_DIGEST_SHA384 },
	{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,
	    SSH_DIGEST_SHA512 },
#endif
	{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },
	{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },
	{ NULL, -1, -1, -1},
};

char *
kex_alg_list(char sep)
{
	char *ret = NULL, *tmp;
	size_t nlen, rlen = 0;
	const struct kexalg *k;

	for (k = kexalgs; k->name != NULL; k++) {
		if (ret != NULL)
			ret[rlen++] = sep;
		nlen = strlen(k->name);
		if ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {
			free(ret);
			return NULL;
		}
		ret = tmp;
		memcpy(ret + rlen, k->name, nlen + 1);
		rlen += nlen;
	}
	return ret;
}

static const struct kexalg *
kex_alg_by_name(const char *name)
{
	const struct kexalg *k;

	for (k = kexalgs; k->name != NULL; k++) {
		if (strcmp(k->name, name) == 0)
			return k;
	}
	return NULL;
}

/* Validate KEX method name list */
int
kex_names_valid(const char *names)
{
	char *s, *cp, *p;

	if (names == NULL || strcmp(names, "") == 0)
		return 0;
	if ((s = cp = strdup(names)) == NULL)
		return 0;
	for ((p = strsep(&cp, ",")); p && *p != '\0';
	    (p = strsep(&cp, ","))) {
		if (kex_alg_by_name(p) == NULL) {
			error("Unsupported KEX algorithm \"%.100s\"", p);
			free(s);
			return 0;
		}
	}
	debug3("kex names ok: [%s]", names);
	free(s);
	return 1;
}

/*
 * Concatenate algorithm names, avoiding duplicates in the process.
 * Caller must free returned string.
 */
char *
kex_names_cat(const char *a, const char *b)
{
	char *ret = NULL, *tmp = NULL, *cp, *p, *m;
	size_t len;

	if (a == NULL || *a == '\0')
		return NULL;
	if (b == NULL || *b == '\0')
		return strdup(a);
	if (strlen(b) > 1024*1024)
		return NULL;
	len = strlen(a) + strlen(b) + 2;
	if ((tmp = cp = strdup(b)) == NULL ||
	    (ret = calloc(1, len)) == NULL) {
		free(tmp);
		return NULL;
	}
	strlcpy(ret, a, len);
	for ((p = strsep(&cp, ",")); p && *p != '\0'; (p = strsep(&cp, ","))) {
		if ((m = match_list(ret, p, NULL)) != NULL) {
			free(m);
			continue; /* Algorithm already present */
		}
		if (strlcat(ret, ",", len) >= len ||
		    strlcat(ret, p, len) >= len) {
			free(tmp);
			free(ret);
			return NULL; /* Shouldn't happen */
		}
	}
	free(tmp);
	return ret;
}

/*
 * Assemble a list of algorithms from a default list and a string from a
 * configuration file. The user-provided string may begin with '+' to
 * indicate that it should be appended to the default or '-' that the
 * specified names should be removed.
 */
int
kex_assemble_names(const char *def, char **list)
{
	char *ret;

	if (list == NULL || *list == NULL || **list == '\0') {
		*list = strdup(def);
		return 0;
	}
	if (**list == '+') {
		if ((ret = kex_names_cat(def, *list + 1)) == NULL)
			return SSH_ERR_ALLOC_FAIL;
		free(*list);
		*list = ret;
	} else if (**list == '-') {
		if ((ret = match_filter_list(def, *list + 1)) == NULL)
			return SSH_ERR_ALLOC_FAIL;
		free(*list);
		*list = ret;
	}

	return 0;
}

/* put algorithm proposal into buffer */
int
kex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])
{
	u_int i;
	int r;

	sshbuf_reset(b);

	/*
	 * add a dummy cookie, the cookie will be overwritten by
	 * kex_send_kexinit(), each time a kexinit is set
	 */
	for (i = 0; i < KEX_COOKIE_LEN; i++) {
		if ((r = sshbuf_put_u8(b, 0)) != 0)
			return r;
	}
	for (i = 0; i < PROPOSAL_MAX; i++) {
		if ((r = sshbuf_put_cstring(b, proposal[i])) != 0)
			return r;
	}
	if ((r = sshbuf_put_u8(b, 0)) != 0 ||	/* first_kex_packet_follows */
	    (r = sshbuf_put_u32(b, 0)) != 0)	/* uint32 reserved */
		return r;
	return 0;
}

/* parse buffer and return algorithm proposal */
int
kex_buf2prop(struct sshbuf *raw, int *first_kex_follows, char ***propp)
{
	struct sshbuf *b = NULL;
	u_char v;
	u_int i;
	char **proposal = NULL;
	int r;

	*propp = NULL;
	if ((proposal = calloc(PROPOSAL_MAX, sizeof(char *))) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((b = sshbuf_fromb(raw)) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshbuf_consume(b, KEX_COOKIE_LEN)) != 0) /* skip cookie */
		goto out;
	/* extract kex init proposal strings */
	for (i = 0; i < PROPOSAL_MAX; i++) {
		if ((r = sshbuf_get_cstring(b, &(proposal[i]), NULL)) != 0)
			goto out;
		debug2("%s: %s", proposal_names[i], proposal[i]);
	}
	/* first kex follows / reserved */
	if ((r = sshbuf_get_u8(b, &v)) != 0 ||	/* first_kex_follows */
	    (r = sshbuf_get_u32(b, &i)) != 0)	/* reserved */
		goto out;
	if (first_kex_follows != NULL)
		*first_kex_follows = v;
	debug2("first_kex_follows %d ", v);
	debug2("reserved %u ", i);
	r = 0;
	*propp = proposal;
 out:
	if (r != 0 && proposal != NULL)
		kex_prop_free(proposal);
	sshbuf_free(b);
	return r;
}

void
kex_prop_free(char **proposal)
{
	u_int i;

	if (proposal == NULL)
		return;
	for (i = 0; i < PROPOSAL_MAX; i++)
		free(proposal[i]);
	free(proposal);
}

/* ARGSUSED */
static int
kex_protocol_error(int type, u_int32_t seq, struct ssh *ssh)
{
	int r;

	error("kex protocol error: type %d seq %u", type, seq);
	if ((r = sshpkt_start(ssh, SSH2_MSG_UNIMPLEMENTED)) != 0 ||
	    (r = sshpkt_put_u32(ssh, seq)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		return r;
	return 0;
}

static void
kex_reset_dispatch(struct ssh *ssh)
{
	ssh_dispatch_range(ssh, SSH2_MSG_TRANSPORT_MIN,
	    SSH2_MSG_TRANSPORT_MAX, &kex_protocol_error);
}

static int
kex_send_ext_info(struct ssh *ssh)
{
	int r;
	char *algs;

	if ((algs = sshkey_alg_list(0, 1, 1, ',')) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshpkt_start(ssh, SSH2_MSG_EXT_INFO)) != 0 ||
	    (r = sshpkt_put_u32(ssh, 1)) != 0 ||
	    (r = sshpkt_put_cstring(ssh, "server-sig-algs")) != 0 ||
	    (r = sshpkt_put_cstring(ssh, algs)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		goto out;
	/* success */
	r = 0;
 out:
	free(algs);
	return r;
}

int
kex_send_newkeys(struct ssh *ssh)
{
	int r;

	kex_reset_dispatch(ssh);
	if ((r = sshpkt_start(ssh, SSH2_MSG_NEWKEYS)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		return r;
	debug("SSH2_MSG_NEWKEYS sent");
	debug("expecting SSH2_MSG_NEWKEYS");
	ssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_input_newkeys);
	if (ssh->kex->ext_info_c)
		if ((r = kex_send_ext_info(ssh)) != 0)
			return r;
	return 0;
}

int
kex_input_ext_info(int type, u_int32_t seq, struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	u_int32_t i, ninfo;
	char *name, *val, *found;
	int r;

	debug("SSH2_MSG_EXT_INFO received");
	ssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &kex_protocol_error);
	if ((r = sshpkt_get_u32(ssh, &ninfo)) != 0)
		return r;
	for (i = 0; i < ninfo; i++) {
		if ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0)
			return r;
		if ((r = sshpkt_get_cstring(ssh, &val, NULL)) != 0) {
			free(name);
			return r;
		}
		debug("%s: %s=<%s>", __func__, name, val);
		if (strcmp(name, "server-sig-algs") == 0) {
			found = match_list("rsa-sha2-256", val, NULL);
			if (found) {
				kex->rsa_sha2 = 256;
				free(found);
			}
			found = match_list("rsa-sha2-512", val, NULL);
			if (found) {
				kex->rsa_sha2 = 512;
				free(found);
			}
		}
		free(name);
		free(val);
	}
	return sshpkt_get_end(ssh);
}

static int
kex_input_newkeys(int type, u_int32_t seq, struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	int r;

	debug("SSH2_MSG_NEWKEYS received");
	ssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);
	ssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);
	if ((r = sshpkt_get_end(ssh)) != 0)
		return r;
	if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)
		return r;
	kex->done = 1;
	sshbuf_reset(kex->peer);
	/* sshbuf_reset(kex->my); */
	kex->flags &= ~KEX_INIT_SENT;
	free(kex->name);
	kex->name = NULL;
	return 0;
}

int
kex_send_kexinit(struct ssh *ssh)
{
	u_char *cookie;
	struct kex *kex = ssh->kex;
	int r;

	if (kex == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	if (kex->flags & KEX_INIT_SENT)
		return 0;
	kex->done = 0;

	/* generate a random cookie */
	if (sshbuf_len(kex->my) < KEX_COOKIE_LEN)
		return SSH_ERR_INVALID_FORMAT;
	if ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	arc4random_buf(cookie, KEX_COOKIE_LEN);

	if ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||
	    (r = sshpkt_putb(ssh, kex->my)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		return r;
	debug("SSH2_MSG_KEXINIT sent");
	kex->flags |= KEX_INIT_SENT;
	return 0;
}

/* ARGSUSED */
int
kex_input_kexinit(int type, u_int32_t seq, struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	const u_char *ptr;
	u_int i;
	size_t dlen;
	int r;

	debug("SSH2_MSG_KEXINIT received");
	if (kex == NULL)
		return SSH_ERR_INVALID_ARGUMENT;

	ssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);
	ptr = sshpkt_ptr(ssh, &dlen);
	if ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)
		return r;

	/* discard packet */
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		if ((r = sshpkt_get_u8(ssh, NULL)) != 0)
			return r;
	for (i = 0; i < PROPOSAL_MAX; i++)
		if ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)
			return r;
	/*
	 * XXX RFC4253 sec 7: "each side MAY guess" - currently no supported
	 * KEX method has the server move first, but a server might be using
	 * a custom method or one that we otherwise don't support. We should
	 * be prepared to remember first_kex_follows here so we can eat a
	 * packet later.
	 * XXX2 - RFC4253 is kind of ambiguous on what first_kex_follows means
	 * for cases where the server *doesn't* go first. I guess we should
	 * ignore it when it is set for these cases, which is what we do now.
	 */
	if ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||	/* first_kex_follows */
	    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||	/* reserved */
	    (r = sshpkt_get_end(ssh)) != 0)
			return r;

	if (!(kex->flags & KEX_INIT_SENT))
		if ((r = kex_send_kexinit(ssh)) != 0)
			return r;
	if ((r = kex_choose_conf(ssh)) != 0)
		return r;

	if (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)
		return (kex->kex[kex->kex_type])(ssh);

	return SSH_ERR_INTERNAL_ERROR;
}

int
kex_new(struct ssh *ssh, char *proposal[PROPOSAL_MAX], struct kex **kexp)
{
	struct kex *kex;
	int r;

	*kexp = NULL;
	if ((kex = calloc(1, sizeof(*kex))) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((kex->peer = sshbuf_new()) == NULL ||
	    (kex->my = sshbuf_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = kex_prop2buf(kex->my, proposal)) != 0)
		goto out;
	kex->done = 0;
	kex_reset_dispatch(ssh);
	ssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);
	r = 0;
	*kexp = kex;
 out:
	if (r != 0)
		kex_free(kex);
	return r;
}

void
kex_free_newkeys(struct newkeys *newkeys)
{
	if (newkeys == NULL)
		return;
	if (newkeys->enc.key) {
		explicit_bzero(newkeys->enc.key, newkeys->enc.key_len);
		free(newkeys->enc.key);
		newkeys->enc.key = NULL;
	}
	if (newkeys->enc.iv) {
		explicit_bzero(newkeys->enc.iv, newkeys->enc.iv_len);
		free(newkeys->enc.iv);
		newkeys->enc.iv = NULL;
	}
	free(newkeys->enc.name);
	explicit_bzero(&newkeys->enc, sizeof(newkeys->enc));
	free(newkeys->comp.name);
	explicit_bzero(&newkeys->comp, sizeof(newkeys->comp));
	mac_clear(&newkeys->mac);
	if (newkeys->mac.key) {
		explicit_bzero(newkeys->mac.key, newkeys->mac.key_len);
		free(newkeys->mac.key);
		newkeys->mac.key = NULL;
	}
	free(newkeys->mac.name);
	explicit_bzero(&newkeys->mac, sizeof(newkeys->mac));
	explicit_bzero(newkeys, sizeof(*newkeys));
	free(newkeys);
}

void
kex_free(struct kex *kex)
{
	u_int mode;

#ifdef WITH_OPENSSL
	if (kex->dh)
		DH_free(kex->dh);
	if (kex->ec_client_key)
		EC_KEY_free(kex->ec_client_key);
#endif
	for (mode = 0; mode < MODE_MAX; mode++) {
		kex_free_newkeys(kex->newkeys[mode]);
		kex->newkeys[mode] = NULL;
	}
	sshbuf_free(kex->peer);
	sshbuf_free(kex->my);
	free(kex->session_id);
	free(kex->client_version_string);
	free(kex->server_version_string);
	free(kex->failed_choice);
	free(kex->hostkey_alg);
	free(kex->name);
	free(kex);
}

int
kex_setup(struct ssh *ssh, char *proposal[PROPOSAL_MAX])
{
	int r;

	if ((r = kex_new(ssh, proposal, &ssh->kex)) != 0)
		return r;
	if ((r = kex_send_kexinit(ssh)) != 0) {		/* we start */
		kex_free(ssh->kex);
		ssh->kex = NULL;
		return r;
	}
	return 0;
}

/*
 * Request key re-exchange, returns 0 on success or a ssherr.h error
 * code otherwise. Must not be called if KEX is incomplete or in-progress.
 */
int
kex_start_rekex(struct ssh *ssh)
{
	if (ssh->kex == NULL) {
		error("%s: no kex", __func__);
		return SSH_ERR_INTERNAL_ERROR;
	}
	if (ssh->kex->done == 0) {
		error("%s: requested twice", __func__);
		return SSH_ERR_INTERNAL_ERROR;
	}
	ssh->kex->done = 0;
	return kex_send_kexinit(ssh);
}

static int
choose_enc(struct sshenc *enc, char *client, char *server)
{
	char *name = match_list(client, server, NULL);

	if (name == NULL)
		return SSH_ERR_NO_CIPHER_ALG_MATCH;
	if ((enc->cipher = cipher_by_name(name)) == NULL) {
		free(name);
		return SSH_ERR_INTERNAL_ERROR;
	}
	enc->name = name;
	enc->enabled = 0;
	enc->iv = NULL;
	enc->iv_len = cipher_ivlen(enc->cipher);
	enc->key = NULL;
	enc->key_len = cipher_keylen(enc->cipher);
	enc->block_size = cipher_blocksize(enc->cipher);
	return 0;
}

static int
choose_mac(struct ssh *ssh, struct sshmac *mac, char *client, char *server)
{
	char *name = match_list(client, server, NULL);

	if (name == NULL)
		return SSH_ERR_NO_MAC_ALG_MATCH;
	if (mac_setup(mac, name) < 0) {
		free(name);
		return SSH_ERR_INTERNAL_ERROR;
	}
	/* truncate the key */
	if (ssh->compat & SSH_BUG_HMAC)
		mac->key_len = 16;
	mac->name = name;
	mac->key = NULL;
	mac->enabled = 0;
	return 0;
}

static int
choose_comp(struct sshcomp *comp, char *client, char *server)
{
	char *name = match_list(client, server, NULL);

	if (name == NULL)
		return SSH_ERR_NO_COMPRESS_ALG_MATCH;
	if (strcmp(name, "zlib@@openssh.com") == 0) {
		comp->type = COMP_DELAYED;
	} else if (strcmp(name, "zlib") == 0) {
		comp->type = COMP_ZLIB;
	} else if (strcmp(name, "none") == 0) {
		comp->type = COMP_NONE;
	} else {
		free(name);
		return SSH_ERR_INTERNAL_ERROR;
	}
	comp->name = name;
	return 0;
}

static int
choose_kex(struct kex *k, char *client, char *server)
{
	const struct kexalg *kexalg;

	k->name = match_list(client, server, NULL);

	debug("kex: algorithm: %s", k->name ? k->name : "(no match)");
	if (k->name == NULL)
		return SSH_ERR_NO_KEX_ALG_MATCH;
	if ((kexalg = kex_alg_by_name(k->name)) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	k->kex_type = kexalg->type;
	k->hash_alg = kexalg->hash_alg;
	k->ec_nid = kexalg->ec_nid;
	return 0;
}

static int
choose_hostkeyalg(struct kex *k, char *client, char *server)
{
	k->hostkey_alg = match_list(client, server, NULL);

	debug("kex: host key algorithm: %s",
	    k->hostkey_alg ? k->hostkey_alg : "(no match)");
	if (k->hostkey_alg == NULL)
		return SSH_ERR_NO_HOSTKEY_ALG_MATCH;
	k->hostkey_type = sshkey_type_from_name(k->hostkey_alg);
	if (k->hostkey_type == KEY_UNSPEC)
		return SSH_ERR_INTERNAL_ERROR;
	k->hostkey_nid = sshkey_ecdsa_nid_from_name(k->hostkey_alg);
	return 0;
}

static int
proposals_match(char *my[PROPOSAL_MAX], char *peer[PROPOSAL_MAX])
{
	static int check[] = {
		PROPOSAL_KEX_ALGS, PROPOSAL_SERVER_HOST_KEY_ALGS, -1
	};
	int *idx;
	char *p;

	for (idx = &check[0]; *idx != -1; idx++) {
		if ((p = strchr(my[*idx], ',')) != NULL)
			*p = '\0';
		if ((p = strchr(peer[*idx], ',')) != NULL)
			*p = '\0';
		if (strcmp(my[*idx], peer[*idx]) != 0) {
			debug2("proposal mismatch: my %s peer %s",
			    my[*idx], peer[*idx]);
			return (0);
		}
	}
	debug2("proposals match");
	return (1);
}

static int
kex_choose_conf(struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	struct newkeys *newkeys;
	char **my = NULL, **peer = NULL;
	char **cprop, **sprop;
	int nenc, nmac, ncomp;
	u_int mode, ctos, need, dh_need, authlen;
	int r, first_kex_follows;

	debug2("local %s KEXINIT proposal", kex->server ? "server" : "client");
	if ((r = kex_buf2prop(kex->my, NULL, &my)) != 0)
		goto out;
	debug2("peer %s KEXINIT proposal", kex->server ? "client" : "server");
	if ((r = kex_buf2prop(kex->peer, &first_kex_follows, &peer)) != 0)
		goto out;

	if (kex->server) {
		cprop=peer;
		sprop=my;
	} else {
		cprop=my;
		sprop=peer;
	}

	/* Check whether client supports ext_info_c */
	if (kex->server) {
		char *ext;

		ext = match_list("ext-info-c", peer[PROPOSAL_KEX_ALGS], NULL);
		kex->ext_info_c = (ext != NULL);
		free(ext);
	}

	/* Algorithm Negotiation */
	if ((r = choose_kex(kex, cprop[PROPOSAL_KEX_ALGS],
	    sprop[PROPOSAL_KEX_ALGS])) != 0) {
		kex->failed_choice = peer[PROPOSAL_KEX_ALGS];
		peer[PROPOSAL_KEX_ALGS] = NULL;
		goto out;
	}
	if ((r = choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],
	    sprop[PROPOSAL_SERVER_HOST_KEY_ALGS])) != 0) {
		kex->failed_choice = peer[PROPOSAL_SERVER_HOST_KEY_ALGS];
		peer[PROPOSAL_SERVER_HOST_KEY_ALGS] = NULL;
		goto out;
	}
	for (mode = 0; mode < MODE_MAX; mode++) {
		if ((newkeys = calloc(1, sizeof(*newkeys))) == NULL) {
			r = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		kex->newkeys[mode] = newkeys;
		ctos = (!kex->server && mode == MODE_OUT) ||
		    (kex->server && mode == MODE_IN);
		nenc  = ctos ? PROPOSAL_ENC_ALGS_CTOS  : PROPOSAL_ENC_ALGS_STOC;
		nmac  = ctos ? PROPOSAL_MAC_ALGS_CTOS  : PROPOSAL_MAC_ALGS_STOC;
		ncomp = ctos ? PROPOSAL_COMP_ALGS_CTOS : PROPOSAL_COMP_ALGS_STOC;
		if ((r = choose_enc(&newkeys->enc, cprop[nenc],
		    sprop[nenc])) != 0) {
			kex->failed_choice = peer[nenc];
			peer[nenc] = NULL;
			goto out;
		}
		authlen = cipher_authlen(newkeys->enc.cipher);
		/* ignore mac for authenticated encryption */
		if (authlen == 0 &&
		    (r = choose_mac(ssh, &newkeys->mac, cprop[nmac],
		    sprop[nmac])) != 0) {
			kex->failed_choice = peer[nmac];
			peer[nmac] = NULL;
			goto out;
		}
		if ((r = choose_comp(&newkeys->comp, cprop[ncomp],
		    sprop[ncomp])) != 0) {
			kex->failed_choice = peer[ncomp];
			peer[ncomp] = NULL;
			goto out;
		}
		debug("kex: %s cipher: %s MAC: %s compression: %s",
		    ctos ? "client->server" : "server->client",
		    newkeys->enc.name,
		    authlen == 0 ? newkeys->mac.name : "<implicit>",
		    newkeys->comp.name);
	}
	need = dh_need = 0;
	for (mode = 0; mode < MODE_MAX; mode++) {
		newkeys = kex->newkeys[mode];
		need = MAXIMUM(need, newkeys->enc.key_len);
		need = MAXIMUM(need, newkeys->enc.block_size);
		need = MAXIMUM(need, newkeys->enc.iv_len);
		need = MAXIMUM(need, newkeys->mac.key_len);
		dh_need = MAXIMUM(dh_need, cipher_seclen(newkeys->enc.cipher));
		dh_need = MAXIMUM(dh_need, newkeys->enc.block_size);
		dh_need = MAXIMUM(dh_need, newkeys->enc.iv_len);
		dh_need = MAXIMUM(dh_need, newkeys->mac.key_len);
	}
	/* XXX need runden? */
	kex->we_need = need;
	kex->dh_need = dh_need;

	/* ignore the next message if the proposals do not match */
	if (first_kex_follows && !proposals_match(my, peer) &&
	    !(ssh->compat & SSH_BUG_FIRSTKEX))
		ssh->dispatch_skip_packets = 1;
	r = 0;
 out:
	kex_prop_free(my);
	kex_prop_free(peer);
	return r;
}

static int
derive_key(struct ssh *ssh, int id, u_int need, u_char *hash, u_int hashlen,
    const struct sshbuf *shared_secret, u_char **keyp)
{
	struct kex *kex = ssh->kex;
	struct ssh_digest_ctx *hashctx = NULL;
	char c = id;
	u_int have;
	size_t mdsz;
	u_char *digest;
	int r;

	if ((mdsz = ssh_digest_bytes(kex->hash_alg)) == 0)
		return SSH_ERR_INVALID_ARGUMENT;
	if ((digest = calloc(1, ROUNDUP(need, mdsz))) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}

	/* K1 = HASH(K || H || "A" || session_id) */
	if ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL ||
	    ssh_digest_update_buffer(hashctx, shared_secret) != 0 ||
	    ssh_digest_update(hashctx, hash, hashlen) != 0 ||
	    ssh_digest_update(hashctx, &c, 1) != 0 ||
	    ssh_digest_update(hashctx, kex->session_id,
	    kex->session_id_len) != 0 ||
	    ssh_digest_final(hashctx, digest, mdsz) != 0) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
	ssh_digest_free(hashctx);
	hashctx = NULL;

	/*
	 * expand key:
	 * Kn = HASH(K || H || K1 || K2 || ... || Kn-1)
	 * Key = K1 || K2 || ... || Kn
	 */
	for (have = mdsz; need > have; have += mdsz) {
		if ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL ||
		    ssh_digest_update_buffer(hashctx, shared_secret) != 0 ||
		    ssh_digest_update(hashctx, hash, hashlen) != 0 ||
		    ssh_digest_update(hashctx, digest, have) != 0 ||
		    ssh_digest_final(hashctx, digest + have, mdsz) != 0) {
			r = SSH_ERR_LIBCRYPTO_ERROR;
			goto out;
		}
		ssh_digest_free(hashctx);
		hashctx = NULL;
	}
#ifdef DEBUG_KEX
	fprintf(stderr, "key '%c'== ", c);
	dump_digest("key", digest, need);
#endif
	*keyp = digest;
	digest = NULL;
	r = 0;
 out:
	free(digest);
	ssh_digest_free(hashctx);
	return r;
}

#define NKEYS	6
int
kex_derive_keys(struct ssh *ssh, u_char *hash, u_int hashlen,
    const struct sshbuf *shared_secret)
{
	struct kex *kex = ssh->kex;
	u_char *keys[NKEYS];
	u_int i, j, mode, ctos;
	int r;

	for (i = 0; i < NKEYS; i++) {
		if ((r = derive_key(ssh, 'A'+i, kex->we_need, hash, hashlen,
		    shared_secret, &keys[i])) != 0) {
			for (j = 0; j < i; j++)
				free(keys[j]);
			return r;
		}
	}
	for (mode = 0; mode < MODE_MAX; mode++) {
		ctos = (!kex->server && mode == MODE_OUT) ||
		    (kex->server && mode == MODE_IN);
		kex->newkeys[mode]->enc.iv  = keys[ctos ? 0 : 1];
		kex->newkeys[mode]->enc.key = keys[ctos ? 2 : 3];
		kex->newkeys[mode]->mac.key = keys[ctos ? 4 : 5];
	}
	return 0;
}

#ifdef WITH_OPENSSL
int
kex_derive_keys_bn(struct ssh *ssh, u_char *hash, u_int hashlen,
    const BIGNUM *secret)
{
	struct sshbuf *shared_secret;
	int r;

	if ((shared_secret = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_put_bignum2(shared_secret, secret)) == 0)
		r = kex_derive_keys(ssh, hash, hashlen, shared_secret);
	sshbuf_free(shared_secret);
	return r;
}
#endif


#if defined(DEBUG_KEX) || defined(DEBUG_KEXDH) || defined(DEBUG_KEXECDH)
void
dump_digest(char *msg, u_char *digest, int len)
{
	fprintf(stderr, "%s\n", msg);
	sshbuf_dump_data(digest, len, stderr);
}
#endif
@


1.132
log
@unifdef WITH_SSH1
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.131 2017/03/15 07:07:39 markus Exp $ */
d55 1
a55 1
static int kex_input_newkeys(int, u_int32_t, void *);
d306 1
a306 1
kex_protocol_error(int type, u_int32_t seq, void *ctxt)
a307 1
	struct ssh *ssh = active_state; /* XXX */
d365 1
a365 1
kex_input_ext_info(int type, u_int32_t seq, void *ctxt)
a366 1
	struct ssh *ssh = ctxt;
d403 1
a403 1
kex_input_newkeys(int type, u_int32_t seq, void *ctxt)
a404 1
	struct ssh *ssh = ctxt;
d455 1
a455 1
kex_input_kexinit(int type, u_int32_t seq, void *ctxt)
a456 1
	struct ssh *ssh = ctxt;
@


1.131
log
@disallow KEXINIT before NEWKEYS; ok djm; report by vegard.nossum at oracle.com
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.130 2017/03/10 04:07:20 djm Exp $ */
a968 41
#ifdef WITH_SSH1
int
derive_ssh1_session_id(BIGNUM *host_modulus, BIGNUM *server_modulus,
    u_int8_t cookie[8], u_int8_t id[16])
{
	u_int8_t hbuf[2048], sbuf[2048], obuf[SSH_DIGEST_MAX_LENGTH];
	struct ssh_digest_ctx *hashctx = NULL;
	size_t hlen, slen;
	int r;

	hlen = BN_num_bytes(host_modulus);
	slen = BN_num_bytes(server_modulus);
	if (hlen < (512 / 8) || (u_int)hlen > sizeof(hbuf) ||
	    slen < (512 / 8) || (u_int)slen > sizeof(sbuf))
		return SSH_ERR_KEY_BITS_MISMATCH;
	if (BN_bn2bin(host_modulus, hbuf) <= 0 ||
	    BN_bn2bin(server_modulus, sbuf) <= 0) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
	if ((hashctx = ssh_digest_start(SSH_DIGEST_MD5)) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if (ssh_digest_update(hashctx, hbuf, hlen) != 0 ||
	    ssh_digest_update(hashctx, sbuf, slen) != 0 ||
	    ssh_digest_update(hashctx, cookie, 8) != 0 ||
	    ssh_digest_final(hashctx, obuf, sizeof(obuf)) != 0) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
	memcpy(id, obuf, ssh_digest_bytes(SSH_DIGEST_MD5));
	r = 0;
 out:
	ssh_digest_free(hashctx);
	explicit_bzero(hbuf, sizeof(hbuf));
	explicit_bzero(sbuf, sizeof(sbuf));
	explicit_bzero(obuf, sizeof(obuf));
	return r;
}
#endif
@


1.130
log
@fix regression in 7.4 server-sig-algs, where we were accidentally
excluding SHA2 RSA signature methods. bz#2680, patch from Nuno
Goncalves; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.129 2017/03/10 03:45:40 dtucker Exp $ */
a323 1
	ssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);
d413 1
d528 1
@


1.129
log
@Plug some mem leaks mostly on error paths.  From jjelen at redhat.com
via bz#2687, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.128 2017/02/03 23:01:19 djm Exp $ */
d333 1
a333 1
	if ((algs = sshkey_alg_list(0, 1, ',')) == NULL)
@


1.128
log
@support =- for removing methods from algorithms lists, e.g.
Ciphers=-*cbc; suggested by Cristian Ionescu-Idbohrn in bz#2671
"I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.127 2016/10/10 19:28:48 markus Exp $ */
d161 1
a161 1
	char *ret = NULL, *tmp = NULL, *cp, *p;
d178 2
a179 1
		if (match_list(ret, p, NULL) != NULL)
d181 1
d634 2
a635 1
	if ((enc->cipher = cipher_by_name(name)) == NULL)
d637 1
d655 2
a656 1
	if (mac_setup(mac, name) < 0)
d658 1
d682 1
@


1.127
log
@Unregister the KEXINIT handler after message has been received.
Otherwise an unauthenticated peer can repeat the KEXINIT and cause
allocation of up to 128MB -- until the connection is closed.
Reported by shilei-c at 360.cn
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.126 2016/09/28 21:44:52 djm Exp $ */
d194 2
a195 1
 * indicate that it should be appended to the default.
d206 10
a215 2
	if (**list != '+') {
		return 0;
a217 4
	if ((ret = kex_names_cat(def, *list + 1)) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	free(*list);
	*list = ret;
@


1.126
log
@put back some pre-auth zlib bits that I shouldn't have removed -
they are still used by the client. Spotted by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.125 2016/09/28 20:32:42 djm Exp $ */
d464 1
@


1.125
log
@restore pre-auth compression support in the client -- the previous
commit was intended to remove it from the server only.

remove a few server-side pre-auth compression bits that escaped

adjust wording of Compression directive in sshd_config(5)

pointed out by naddy@@ ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.124 2016/09/22 17:52:53 djm Exp $ */
d665 2
@


1.124
log
@support plain curve25519-sha256 KEX algorithm now that it is
approaching standardisation (same algorithm is currently supported
as curve25519-sha256@@libssh.org)
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.123 2016/09/21 19:53:12 djm Exp $ */
a664 2
	} else if (strcmp(name, "zlib") == 0) {
		comp->type = COMP_ZLIB;
@


1.123
log
@correctly return errors from kex_send_ext_info(). Fix from Sami Farin
via https://github.com/openssh/openssh-portable/pull/50
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.122 2016/09/19 19:02:19 markus Exp $ */
d93 1
@


1.122
log
@move inbound NEWKEYS handling to kex layer; otherwise early NEWKEYS causes
NULL deref; found by Robert Swiecki/honggfuzz; fixed with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.121 2016/09/12 23:31:27 djm Exp $ */
d337 1
a337 1
	return 0;
@


1.121
log
@list all supported signature algorithms in the server-sig-algs
Reported by mb AT smartftp.com in bz#2547 and (independantly)
Ron Frederick; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.120 2016/09/12 01:22:38 deraadt Exp $ */
d407 2
@


1.120
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.119 2016/09/06 09:14:05 markus Exp $ */
d323 1
d325 2
d330 1
a330 1
	    (r = sshpkt_put_cstring(ssh, "rsa-sha2-256,rsa-sha2-512")) != 0 ||
d332 5
a336 1
		return r;
@


1.119
log
@update ext_info_c every time we receive a kexinit msg; fixes sending of
ext_info if privsep is disabled; report Aris Adamantiadis & Mancha; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.118 2016/05/02 10:26:04 djm Exp $ */
a25 1
#include <sys/param.h>	/* MAX roundup */
d813 8
a820 8
		need = MAX(need, newkeys->enc.key_len);
		need = MAX(need, newkeys->enc.block_size);
		need = MAX(need, newkeys->enc.iv_len);
		need = MAX(need, newkeys->mac.key_len);
		dh_need = MAX(dh_need, cipher_seclen(newkeys->enc.cipher));
		dh_need = MAX(dh_need, newkeys->enc.block_size);
		dh_need = MAX(dh_need, newkeys->enc.iv_len);
		dh_need = MAX(dh_need, newkeys->mac.key_len);
d851 1
a851 1
	if ((digest = calloc(1, roundup(need, mdsz))) == NULL) {
@


1.118
log
@add support for additional fixed DH groups from
draft-ietf-curdle-ssh-kex-sha2-03

diffie-hellman-group14-sha256 (2K group)
diffie-hellman-group16-sha512 (4K group)
diffie-hellman-group18-sha512 (8K group)

based on patch from Mark D. Baushke and Darren Tucker
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.117 2016/02/08 10:57:07 djm Exp $ */
d756 2
a757 4
		if (ext) {
			kex->ext_info_c = 1;
			free(ext);
		}
@


1.118.4.1
log
@MFC:
Unregister the KEXINIT handler after message has been received.
Otherwise an unauthenticated peer can repeat the KEXINIT and cause
allocation of up to 128MB -- until the connection is closed.
Reported by shilei-c at 360.cn
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.118 2016/05/02 10:26:04 djm Exp $ */
a454 1
	ssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);
@


1.117
log
@refactor activation of rekeying

This makes automatic rekeying internal to the packet code (previously
the server and client loops needed to assist). In doing to it makes
application of rekey limits more accurate by accounting for packets
about to be sent as well as packets queued during rekeying events
themselves.

Based on a patch from dtucker@@ which was in turn based on a patch
Aleksander Adamowski in bz#2521; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.116 2016/01/14 16:17:39 markus Exp $ */
d80 4
a83 1
	{ KEX_DH14, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },
@


1.117.2.1
log
@MFC:
Unregister the KEXINIT handler after message has been received.
Otherwise an unauthenticated peer can repeat the KEXINIT and cause
allocation of up to 128MB -- until the connection is closed.
Reported by shilei-c at 360.cn
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.117 2016/02/08 10:57:07 djm Exp $ */
a451 1
	ssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);
@


1.116
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.115 2015/12/13 22:42:23 djm Exp $ */
d586 19
@


1.115
log
@unbreak connections with peers that set first_kex_follows;
fix from Matt Johnston va bz#2515
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.114 2015/12/10 17:08:40 mmcc Exp $ */
a48 1
#include "roaming.h"
a726 11
	}

	/* Check whether server offers roaming */
	if (!kex->server) {
		char *roaming = match_list(KEX_RESUME,
		    peer[PROPOSAL_KEX_ALGS], NULL);

		if (roaming) {
			kex->roaming = 1;
			free(roaming);
		}
@


1.114
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.113 2015/12/04 16:41:28 markus Exp $ */
d267 2
a268 2
	if ((r = sshbuf_get_u8(b, &v)) != 0 ||
	    (r = sshbuf_get_u32(b, &i)) != 0)
d271 1
a271 1
		*first_kex_follows = i;
@


1.113
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.112 2015/11/13 04:39:35 djm Exp $ */
d888 1
a888 2
	if (digest)
		free(digest);
@


1.112
log
@send SSH2_MSG_UNIMPLEMENTED replies to unexpected messages during
KEX; bz#2949, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.111 2015/10/13 00:21:27 djm Exp $ */
d318 14
d344 3
d350 39
d569 2
d667 1
a667 1
	char *hostkeyalg = match_list(client, server, NULL);
d670 2
a671 2
	    hostkeyalg ? hostkeyalg : "(no match)");
	if (hostkeyalg == NULL)
d673 1
a673 1
	k->hostkey_type = sshkey_type_from_name(hostkeyalg);
d676 1
a676 2
	k->hostkey_nid = sshkey_ecdsa_nid_from_name(hostkeyalg);
	free(hostkeyalg);
d738 11
@


1.111
log
@free the correct IV length, don't assume it's always the cipher
blocksize; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.110 2015/08/21 23:57:48 djm Exp $ */
d299 8
a306 1
	error("Hm, kex protocol error: type %d seq %u", type, seq);
@


1.110
log
@Improve printing of KEX offers and decisions

The debug output now labels the client and server offers and the
negotiated options. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.109 2015/07/30 00:01:34 djm Exp $ */
d465 1
a465 1
		explicit_bzero(newkeys->enc.iv, newkeys->enc.block_size);
@


1.109
log
@Allow ssh_config and sshd_config kex parameters options be prefixed
by a '+' to indicate that the specified items be appended to the
default rather than replacing it.

approach suggested by dtucker@@, feedback dlg@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.108 2015/07/29 08:34:54 djm Exp $ */
d59 13
d264 1
a264 1
		debug2("kex_parse_kexinit: %s", proposal[i]);
d272 2
a273 2
	debug2("kex_parse_kexinit: first_kex_follows %d ", v);
	debug2("kex_parse_kexinit: reserved %u ", i);
d588 1
d604 2
d651 5
a655 2
	if ((r = kex_buf2prop(kex->my, NULL, &my)) != 0 ||
	    (r = kex_buf2prop(kex->peer, &first_kex_follows, &peer)) != 0)
d678 12
d722 1
a722 1
		debug("kex: %s %s %s %s",
a726 12
	}
	if ((r = choose_kex(kex, cprop[PROPOSAL_KEX_ALGS],
	    sprop[PROPOSAL_KEX_ALGS])) != 0) {
		kex->failed_choice = peer[PROPOSAL_KEX_ALGS];
		peer[PROPOSAL_KEX_ALGS] = NULL;
		goto out;
	}
	if ((r = choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],
	    sprop[PROPOSAL_SERVER_HOST_KEY_ALGS])) != 0) {
		kex->failed_choice = peer[PROPOSAL_SERVER_HOST_KEY_ALGS];
		peer[PROPOSAL_SERVER_HOST_KEY_ALGS] = NULL;
		goto out;
@


1.108
log
@fix bug in previous; was printing incorrect string for failed
host key algorithms negotiation
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.107 2015/07/29 04:43:06 djm Exp $ */
d137 62
@


1.107
log
@include the peer's offer when logging a failure to negotiate a
mutual set of algorithms (kex, pubkey, ciphers, etc.)
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.106 2015/04/17 13:25:52 djm Exp $ */
d643 2
a644 2
		kex->failed_choice = cprop[PROPOSAL_SERVER_HOST_KEY_ALGS];
		cprop[PROPOSAL_SERVER_HOST_KEY_ALGS] = NULL;
@


1.106
log
@don't try to cleanup NULL KEX proposals in kex_prop_free();
found by Jukka Taimisto and Markus Hietava
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.105 2015/01/30 00:22:25 djm Exp $ */
d430 1
d609 3
a611 1
		    sprop[nenc])) != 0)
d613 1
d618 3
a620 1
		    sprop[nmac])) != 0)
d622 1
d624 3
a626 1
		    sprop[ncomp])) != 0)
d628 1
d636 3
a638 3
	    sprop[PROPOSAL_KEX_ALGS])) != 0 ||
	    (r = choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],
	    sprop[PROPOSAL_SERVER_HOST_KEY_ALGS])) != 0)
d640 7
@


1.105
log
@fix ssh protocol 1, spotted by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.104 2015/01/26 06:10:03 djm Exp $ */
d213 2
@


1.104
log
@correctly match ECDSA subtype (== curve) for offered/recevied
host keys. Fixes connection-killing host key mismatches when
a server offers multiple ECDSA keys with different curve type
(an extremely unlikely configuration).

ok markus, "looks mechanical" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.103 2015/01/20 23:14:00 deraadt Exp $ */
d769 1
a769 1
	u_int8_t nbuf[2048], obuf[SSH_DIGEST_MAX_LENGTH];
d771 1
a771 1
	size_t len;
d774 4
a777 2
	len = BN_num_bytes(host_modulus);
	if (len < (512 / 8) || (u_int)len > sizeof(nbuf))
d779 11
a789 3
	if (BN_bn2bin(host_modulus, nbuf) <= 0 ||
	    (hashctx = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||
	    ssh_digest_update(hashctx, nbuf, len) != 0 ||
d799 2
a800 1
	explicit_bzero(nbuf, sizeof(nbuf));
@


1.103
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.102 2015/01/19 20:16:15 markus Exp $ */
d530 1
@


1.102
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.101 2015/01/19 20:07:45 markus Exp $ */
d26 1
a26 1
#include <sys/param.h>
@


1.101
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.100 2015/01/19 19:52:16 markus Exp $ */
a36 1
#include "xmalloc.h"
a37 1
#include "buffer.h"
d41 1
a41 1
#include "key.h"
d46 1
d50 3
d56 2
a57 2
static void kex_kexinit_finish(Kex *);
static void kex_choose_conf(Kex *);
d61 1
a61 1
	int type;
d85 1
a85 1
	char *ret = NULL;
d93 5
a97 1
		ret = xrealloc(ret, 1, rlen + nlen + 2);
d124 2
a125 1
	s = cp = xstrdup(names);
d140 2
a141 2
static void
kex_prop2buf(Buffer *b, char *proposal[PROPOSAL_MAX])
d144 3
a147 1
	buffer_clear(b);
d152 12
a163 6
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		buffer_put_char(b, 0);
	for (i = 0; i < PROPOSAL_MAX; i++)
		buffer_put_cstring(b, proposal[i]);
	buffer_put_char(b, 0);			/* first_kex_packet_follows */
	buffer_put_int(b, 0);			/* uint32 reserved */
d167 2
a168 2
static char **
kex_buf2prop(Buffer *raw, int *first_kex_follows)
d170 2
a171 1
	Buffer b;
d173 2
a174 1
	char **proposal;
d176 9
a184 7
	proposal = xcalloc(PROPOSAL_MAX, sizeof(char *));

	buffer_init(&b);
	buffer_append(&b, buffer_ptr(raw), buffer_len(raw));
	/* skip cookie */
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		buffer_get_char(&b);
d187 2
a188 1
		proposal[i] = buffer_get_cstring(&b,NULL);
d192 3
a194 1
	i = buffer_get_char(&b);
d197 1
a197 2
	debug2("kex_parse_kexinit: first_kex_follows %d ", i);
	i = buffer_get_int(&b);
d199 7
a205 2
	buffer_free(&b);
	return proposal;
d208 1
a208 1
static void
d227 1
a227 1
kex_reset_dispatch(void)
d229 1
a229 1
	dispatch_range(SSH2_MSG_TRANSPORT_MIN,
d231 1
a231 1
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
d234 2
a235 2
void
kex_finish(Kex *kex)
d237 1
a237 1
	kex_reset_dispatch();
d239 4
a242 3
	packet_start(SSH2_MSG_NEWKEYS);
	packet_send();
	/* packet_write_wait(); */
d244 11
a255 3
	debug("expecting SSH2_MSG_NEWKEYS");
	packet_read_expect(SSH2_MSG_NEWKEYS);
	packet_check_eom();
d257 3
a259 1

d261 2
a262 2
	buffer_clear(kex->peer);
	/* buffer_clear(kex->my); */
d266 1
d269 2
a270 2
void
kex_send_kexinit(Kex *kex)
a271 1
	u_int32_t rnd = 0;
d273 2
a274 1
	u_int i;
d276 4
a279 8
	if (kex == NULL) {
		error("kex_send_kexinit: no kex, cannot rekey");
		return;
	}
	if (kex->flags & KEX_INIT_SENT) {
		debug("KEX_INIT_SENT");
		return;
	}
d283 10
a292 12
	if (buffer_len(kex->my) < KEX_COOKIE_LEN)
		fatal("kex_send_kexinit: kex proposal too short");
	cookie = buffer_ptr(kex->my);
	for (i = 0; i < KEX_COOKIE_LEN; i++) {
		if (i % 4 == 0)
			rnd = arc4random();
		cookie[i] = rnd;
		rnd >>= 8;
	}
	packet_start(SSH2_MSG_KEXINIT);
	packet_put_raw(buffer_ptr(kex->my), buffer_len(kex->my));
	packet_send();
d295 1
d302 3
a304 1
	const char *ptr;
d307 1
a307 1
	Kex *kex = (Kex *)ctxt;
d311 1
a311 1
		fatal("kex_input_kexinit: no kex, cannot rekey");
d313 3
a315 2
	ptr = packet_get_raw(&dlen);
	buffer_append(kex->peer, ptr, dlen);
d319 2
a320 1
		packet_get_char();
d322 2
a323 1
		free(packet_get_string(NULL));
d334 10
a343 3
	(void) packet_get_char();	/* first_kex_follows */
	(void) packet_get_int();	/* reserved */
	packet_check_eom();
d345 30
a374 2
	kex_kexinit_finish(kex);
	return 0;
d408 2
a409 2
Kex *
kex_setup(char *proposal[PROPOSAL_MAX])
d411 1
a411 1
	struct kex *kex;
d413 9
a421 5
	if ((kex = calloc(1, sizeof(*kex))) == NULL)
		fatal("%s: calloc", __func__);
	if ((kex->peer = sshbuf_new()) == NULL ||
	    (kex->my = sshbuf_new()) == NULL) {
		fatal("%s: sshbuf_new", __func__);
d423 6
a428 7
	kex_prop2buf(kex->my, proposal);
	kex->done = 0;

	kex_send_kexinit(kex);					/* we start */
	kex_reset_dispatch();

	return kex;
d431 2
a432 2
static void
kex_kexinit_finish(Kex *kex)
d434 1
a434 2
	if (!(kex->flags & KEX_INIT_SENT))
		kex_send_kexinit(kex);
d436 6
a441 7
	kex_choose_conf(kex);

	if (kex->kex_type >= 0 && kex->kex_type < KEX_MAX &&
	    kex->kex[kex->kex_type] != NULL) {
		(kex->kex[kex->kex_type])(kex);
	} else {
		fatal("Unsupported key exchange %d", kex->kex_type);
d443 1
d446 2
a447 2
static void
choose_enc(Enc *enc, char *client, char *server)
d450 1
d452 1
a452 2
		fatal("no matching cipher found: client %s server %s",
		    client, server);
d454 1
a454 1
		fatal("matching cipher is not supported: %s", name);
d462 1
d465 2
a466 2
static void
choose_mac(Mac *mac, char *client, char *server)
d469 1
d471 1
a471 2
		fatal("no matching mac found: client %s server %s",
		    client, server);
d473 1
a473 1
		fatal("unsupported mac %s", name);
d475 1
a475 1
	if (datafellows & SSH_BUG_HMAC)
d480 1
d483 2
a484 2
static void
choose_comp(Comp *comp, char *client, char *server)
d487 1
d489 1
a489 1
		fatal("no matching comp found: client %s server %s", client, server);
d497 1
a497 1
		fatal("unsupported comp %s", name);
d500 1
d503 2
a504 2
static void
choose_kex(Kex *k, char *client, char *server)
d509 1
d511 1
a511 1
		fatal("Unable to negotiate a key exchange method");
d513 1
a513 1
		fatal("unsupported kex alg %s", k->name);
d517 1
d520 2
a521 2
static void
choose_hostkeyalg(Kex *k, char *client, char *server)
d524 1
d526 2
a527 2
		fatal("no hostkey alg");
	k->hostkey_type = key_type_from_name(hostkeyalg);
d529 1
a529 1
		fatal("bad hostkey alg '%s'", hostkeyalg);
d531 1
d558 2
a559 2
static void
kex_choose_conf(Kex *kex)
d561 3
a563 2
	Newkeys *newkeys;
	char **my, **peer;
d567 1
a567 1
	int first_kex_follows, type;
d569 3
a571 2
	my   = kex_buf2prop(kex->my, NULL);
	peer = kex_buf2prop(kex->peer, &first_kex_follows);
d583 3
a585 2
		char *roaming;
		roaming = match_list(KEX_RESUME, peer[PROPOSAL_KEX_ALGS], NULL);
d594 4
a597 1
		newkeys = xcalloc(1, sizeof(*newkeys));
d604 4
a607 1
		choose_enc(&newkeys->enc, cprop[nenc], sprop[nenc]);
d609 7
a615 4
		authlen = cipher_authlen(newkeys->enc.cipher);
		if (authlen == 0)
			choose_mac(&newkeys->mac, cprop[nmac], sprop[nmac]);
		choose_comp(&newkeys->comp, cprop[ncomp], sprop[ncomp]);
d622 5
a626 3
	choose_kex(kex, cprop[PROPOSAL_KEX_ALGS], sprop[PROPOSAL_KEX_ALGS]);
	choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],
	    sprop[PROPOSAL_SERVER_HOST_KEY_ALGS]);
d645 4
a648 5
	    !(datafellows & SSH_BUG_FIRSTKEX)) {
		type = packet_read();
		debug2("skipping next packet (type %u)", type);
	}

d651 1
d654 3
a656 3
static u_char *
derive_key(Kex *kex, int id, u_int need, u_char *hash, u_int hashlen,
    const u_char *shared_secret, u_int slen)
d658 2
a659 2
	Buffer b;
	struct ssh_digest_ctx *hashctx;
d664 1
d667 5
a671 5
		fatal("bad kex md size %zu", mdsz);
	digest = xmalloc(roundup(need, mdsz));

	buffer_init(&b);
	buffer_append(&b, shared_secret, slen);
d674 2
a675 3
	if ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL)
		fatal("%s: ssh_digest_start failed", __func__);
	if (ssh_digest_update_buffer(hashctx, &b) != 0 ||
d679 5
a683 4
	    kex->session_id_len) != 0)
		fatal("%s: ssh_digest_update failed", __func__);
	if (ssh_digest_final(hashctx, digest, mdsz) != 0)
		fatal("%s: ssh_digest_final failed", __func__);
d685 1
d693 2
a694 3
		if ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL)
			fatal("%s: ssh_digest_start failed", __func__);
		if (ssh_digest_update_buffer(hashctx, &b) != 0 ||
d696 5
a700 4
		    ssh_digest_update(hashctx, digest, have) != 0)
			fatal("%s: ssh_digest_update failed", __func__);
		if (ssh_digest_final(hashctx, digest + have, mdsz) != 0)
			fatal("%s: ssh_digest_final failed", __func__);
d702 1
a703 1
	buffer_free(&b);
d708 8
a715 1
	return digest;
d719 3
a721 3
void
kex_derive_keys(Kex *kex, u_char *hash, u_int hashlen,
    const u_char *shared_secret, u_int slen)
d723 1
d725 2
a726 1
	u_int i, mode, ctos;
d729 6
a734 2
		keys[i] = derive_key(kex, 'A'+i, kex->we_need, hash, hashlen,
		    shared_secret, slen);
a735 2

	debug2("kex_derive_keys");
d743 1
d747 3
a749 2
void
kex_derive_keys_bn(Kex *kex, u_char *hash, u_int hashlen, const BIGNUM *secret)
d751 2
a752 1
	Buffer shared_secret;
d754 6
a759 5
	buffer_init(&shared_secret);
	buffer_put_bignum2(&shared_secret, secret);
	kex_derive_keys(kex, hash, hashlen,
	    buffer_ptr(&shared_secret), buffer_len(&shared_secret));
	buffer_free(&shared_secret);
d764 1
a764 1
void
d769 3
a771 5
	int len;
	struct ssh_digest_ctx *hashctx;

	if ((hashctx = ssh_digest_start(SSH_DIGEST_MD5)) == NULL)
		fatal("%s: ssh_digest_start", __func__);
d775 9
a783 14
		fatal("%s: bad host modulus (len %d)", __func__, len);
	BN_bn2bin(host_modulus, nbuf);
	if (ssh_digest_update(hashctx, nbuf, len) != 0)
		fatal("%s: ssh_digest_update failed", __func__);

	len = BN_num_bytes(server_modulus);
	if (len < (512 / 8) || (u_int)len > sizeof(nbuf))
		fatal("%s: bad server modulus (len %d)", __func__, len);
	BN_bn2bin(server_modulus, nbuf);
	if (ssh_digest_update(hashctx, nbuf, len) != 0 ||
	    ssh_digest_update(hashctx, cookie, 8) != 0)
		fatal("%s: ssh_digest_update failed", __func__);
	if (ssh_digest_final(hashctx, obuf, sizeof(obuf)) != 0)
		fatal("%s: ssh_digest_final failed", __func__);
d785 3
a787 1

d790 1
a797 2
	int i;

d799 1
a799 8
	for (i = 0; i < len; i++) {
		fprintf(stderr, "%02x", digest[i]);
		if (i%32 == 31)
			fprintf(stderr, "\n");
		else if (i%8 == 7)
			fprintf(stderr, " ");
	}
	fprintf(stderr, "\n");
@


1.100
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.99 2014/04/29 18:01:49 markus Exp $ */
d193 1
a193 1
static void
d197 1
d266 1
a266 1
void
d301 1
@


1.99
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.98 2014/02/02 03:44:31 djm Exp $ */
d223 2
a224 2
	buffer_clear(&kex->peer);
	/* buffer_clear(&kex->my); */
d248 1
a248 1
	if (buffer_len(&kex->my) < KEX_COOKIE_LEN)
d250 1
a250 1
	cookie = buffer_ptr(&kex->my);
d258 1
a258 1
	packet_put_raw(buffer_ptr(&kex->my), buffer_len(&kex->my));
d268 3
a270 2
	char *ptr;
	u_int i, dlen;
d278 1
a278 1
	buffer_append(&kex->peer, ptr, dlen);
d302 31
d336 1
a336 1
	Kex *kex;
d338 7
a344 4
	kex = xcalloc(1, sizeof(*kex));
	buffer_init(&kex->peer);
	buffer_init(&kex->my);
	kex_prop2buf(&kex->my, proposal);
d483 2
a484 2
	my   = kex_buf2prop(&kex->my, NULL);
	peer = kex_buf2prop(&kex->peer, &first_kex_follows);
a609 2
Newkeys *current_keys[MODE_MAX];

a624 2
		current_keys[mode] = kex->newkeys[mode];
		kex->newkeys[mode] = NULL;
d627 3
a629 3
		current_keys[mode]->enc.iv  = keys[ctos ? 0 : 1];
		current_keys[mode]->enc.key = keys[ctos ? 2 : 3];
		current_keys[mode]->mac.key = keys[ctos ? 4 : 5];
a645 10

Newkeys *
kex_get_newkeys(int mode)
{
	Newkeys *ret;

	ret = current_keys[mode];
	current_keys[mode] = NULL;
	return ret;
}
@


1.98
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.97 2014/01/25 20:35:37 markus Exp $ */
d33 1
d35 1
d64 1
d75 1
d602 1
d614 1
d626 1
d659 1
@


1.97
log
@dh_need needs to be set to max(seclen, blocksize, ivlen, mac_len)
ok dtucker@@, noted by mancha
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.96 2014/01/25 10:12:50 dtucker Exp $ */
d649 2
a650 2
	memset(nbuf, 0, sizeof(nbuf));
	memset(obuf, 0, sizeof(obuf));
@


1.96
log
@Add a special case for the DH group size for 3des-cbc, which has an
effective strength much lower than the key size.  This causes problems
with some cryptlib implementations, which don't support group sizes larger
than 4k but also don't use the largest group size it does support as
specified in the RFC.  Based on a patch from Petr Lautrbach at Redhat,
reduced by me with input from Markus.  ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.95 2014/01/12 08:13:13 djm Exp $ */
d492 8
a499 10
		if (need < newkeys->enc.key_len)
			need = newkeys->enc.key_len;
		if (need < newkeys->enc.block_size)
			need = newkeys->enc.block_size;
		if (need < newkeys->enc.iv_len)
			need = newkeys->enc.iv_len;
		if (need < newkeys->mac.key_len)
			need = newkeys->mac.key_len;
		if (dh_need < cipher_seclen(newkeys->enc.cipher))
			dh_need = cipher_seclen(newkeys->enc.cipher);
@


1.95
log
@avoid use of OpenSSL BIGNUM type and functions for KEX with
Curve25519 by adding a buffer_put_bignum2_from_string() that stores
a string using the bignum encoding rules. Will make it easier to
build a reduced-feature OpenSSH without OpenSSL in the future;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.94 2014/01/09 23:20:00 djm Exp $ */
d441 1
a441 1
	u_int mode, ctos, need, authlen;
d489 1
a489 1
	need = 0;
d500 2
d505 1
@


1.94
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.93 2013/11/07 11:58:27 dtucker Exp $ */
d517 1
a517 1
    BIGNUM *shared_secret)
d531 1
a531 1
	buffer_put_bignum2(&b, shared_secret);
d574 2
a575 1
kex_derive_keys(Kex *kex, u_char *hash, u_int hashlen, BIGNUM *shared_secret)
d582 1
a582 1
		    shared_secret);
d595 12
@


1.93
log
@Output the effective values of Ciphers, MACs and KexAlgorithms when
the default has not been overridden.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.92 2013/11/02 21:59:15 markus Exp $ */
d49 1
d59 1
a59 1
	const EVP_MD *(*mdfunc)(void);
d62 12
a73 9
	{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, EVP_sha1 },
	{ KEX_DH14, KEX_DH_GRP14_SHA1, 0, EVP_sha1 },
	{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, EVP_sha1 },
	{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, EVP_sha256 },
	{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2, NID_X9_62_prime256v1, EVP_sha256 },
	{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1, EVP_sha384 },
	{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1, EVP_sha512 },
	{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, EVP_sha256 },
	{ NULL, -1, -1, NULL},
d394 1
a394 1
	k->evp_md = kexalg->mdfunc();
d520 1
a520 1
	EVP_MD_CTX md;
d523 1
a523 1
	int mdsz;
d526 2
a527 2
	if ((mdsz = EVP_MD_size(kex->evp_md)) <= 0)
		fatal("bad kex md size %d", mdsz);
d534 11
a544 7
	EVP_DigestInit(&md, kex->evp_md);
	if (!(datafellows & SSH_BUG_DERIVEKEY))
		EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
	EVP_DigestUpdate(&md, hash, hashlen);
	EVP_DigestUpdate(&md, &c, 1);
	EVP_DigestUpdate(&md, kex->session_id, kex->session_id_len);
	EVP_DigestFinal(&md, digest, NULL);
d552 9
a560 6
		EVP_DigestInit(&md, kex->evp_md);
		if (!(datafellows & SSH_BUG_DERIVEKEY))
			EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
		EVP_DigestUpdate(&md, hash, hashlen);
		EVP_DigestUpdate(&md, digest, have);
		EVP_DigestFinal(&md, digest + have, NULL);
d610 1
a610 3
	const EVP_MD *evp_md = EVP_md5();
	EVP_MD_CTX md;
	u_int8_t nbuf[2048], obuf[EVP_MAX_MD_SIZE];
d612 1
d614 2
a615 1
	EVP_DigestInit(&md, evp_md);
d621 2
a622 1
	EVP_DigestUpdate(&md, nbuf, len);
d628 6
a633 6
	EVP_DigestUpdate(&md, nbuf, len);

	EVP_DigestUpdate(&md, cookie, 8);

	EVP_DigestFinal(&md, obuf, NULL);
	memcpy(id, obuf, 16);
a636 1
	memset(&md, 0, sizeof(md));
@


1.92
log
@use curve25519 for default key exchange (curve25519-sha256@@libssh.org);
initial patch from Aris Adamantiadis; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.91 2013/05/17 00:13:13 djm Exp $ */
d73 1
a73 1
kex_alg_list(void)
d81 1
a81 1
			ret[rlen++] = '\n';
@


1.91
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.90 2013/04/19 12:07:08 djm Exp $ */
d68 1
@


1.90
log
@remove duplicated list entry pointed out by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.89 2013/04/19 01:06:50 djm Exp $ */
d114 1
a114 1
			xfree(s);
d119 1
a119 1
	xfree(s);
d179 2
a180 2
		xfree(proposal[i]);
	xfree(proposal);
d217 1
a217 1
	xfree(kex->name);
d274 1
a274 1
		xfree(packet_get_string(NULL));
d402 1
a402 1
	xfree(hostkeyalg);
d456 1
a456 1
			xfree(roaming);
@


1.89
log
@add the ability to query supported ciphers, MACs, key type and KEX
algorithms to ssh. Includes some refactoring of KEX and key type handling
to be table-driven; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.88 2013/01/08 18:49:04 markus Exp $ */
a64 1
	{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, EVP_sha1 },
@


1.88
log
@support AES-GCM as defined in RFC 5647 (but with simpler KEX handling)
ok and feedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.87 2012/08/17 01:22:56 djm Exp $ */
d54 48
d113 1
a113 7
	    	if (strcmp(p, KEX_DHGEX_SHA256) != 0 &&
		    strcmp(p, KEX_DHGEX_SHA1) != 0 &&
		    strcmp(p, KEX_DH14) != 0 &&
		    strcmp(p, KEX_DH1) != 0 &&
		    (strncmp(p, KEX_ECDH_SHA2_STEM,
		    sizeof(KEX_ECDH_SHA2_STEM) - 1) != 0 ||
		    kex_ecdh_name_to_nid(p) == -1)) {
d382 2
d387 5
a391 18
	if (strcmp(k->name, KEX_DH1) == 0) {
		k->kex_type = KEX_DH_GRP1_SHA1;
		k->evp_md = EVP_sha1();
	} else if (strcmp(k->name, KEX_DH14) == 0) {
		k->kex_type = KEX_DH_GRP14_SHA1;
		k->evp_md = EVP_sha1();
	} else if (strcmp(k->name, KEX_DHGEX_SHA1) == 0) {
		k->kex_type = KEX_DH_GEX_SHA1;
		k->evp_md = EVP_sha1();
	} else if (strcmp(k->name, KEX_DHGEX_SHA256) == 0) {
		k->kex_type = KEX_DH_GEX_SHA256;
		k->evp_md = EVP_sha256();
	} else if (strncmp(k->name, KEX_ECDH_SHA2_STEM,
	    sizeof(KEX_ECDH_SHA2_STEM) - 1) == 0) {
		k->kex_type = KEX_ECDH_SHA2;
		k->evp_md = kex_ecdh_name_to_evpmd(k->name);
	} else
		fatal("bad kex alg %s", k->name);
@


1.87
log
@add some comments about better handling first-KEX-follows notifications
from the server. Nothing uses these right now. No binary change
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.86 2010/09/22 05:01:29 djm Exp $ */
d296 1
d406 1
a406 1
	u_int mode, ctos, need;
d439 5
a443 2
		choose_enc (&newkeys->enc,  cprop[nenc],  sprop[nenc]);
		choose_mac (&newkeys->mac,  cprop[nmac],  sprop[nmac]);
d448 1
a448 1
		    newkeys->mac.name,
d461 2
@


1.86
log
@add a KexAlgorithms knob to the client and server configuration to allow
selection of which key exchange methods are used by ssh(1) and sshd(8)
and their order of preference.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.85 2010/09/09 10:45:45 djm Exp $ */
d234 12
a245 2
	(void) packet_get_char();
	(void) packet_get_int();
@


1.85
log
@ECDH/ECDSA compliance fix: these methods vary the hash function they use
(SHA256/384/512) depending on the length of the curve in use. The previous
code incorrectly used SHA256 in all cases.

This fix will cause authentication failure when using 384 or 521-bit curve
keys if one peer hasn't been upgraded and the other has. (256-bit curve
keys work ok). In particular you may need to specify HostkeyAlgorithms
when connecting to a server that has not been upgraded from an upgraded
client.

ok naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.84 2010/08/31 11:54:45 djm Exp $ */
d53 28
@


1.84
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.83 2010/08/31 09:58:37 djm Exp $ */
d316 2
a317 2
	} else if (strncmp(k->name, KEX_ECDH_SHA256,
	    sizeof(KEX_ECDH_SHA256) - 1) == 0) {
d319 1
a319 1
		k->evp_md = EVP_sha256();
@


1.83
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.82 2009/10/24 11:13:54 andreas Exp $ */
d316 4
d553 1
a553 1
#if defined(DEBUG_KEX) || defined(DEBUG_KEXDH)
d557 1
a557 1
	u_int i;
@


1.82
log
@Let the client detect if the server supports roaming by looking
for the resume@@appgate.com kex algorithm.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.81 2009/05/27 06:34:36 andreas Exp $ */
d90 1
a90 1
		proposal[i] = buffer_get_string(&b,NULL);
@


1.81
log
@Move the KEX_COOKIE_LEN define to kex.h
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.80 2008/09/06 12:24:13 djm Exp $ */
d48 1
d375 10
@


1.80
log
@OpenSSL 0.9.8h supplies a real EVP_sha256 so we do not need our
replacement anymore
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.79 2007/06/05 06:52:37 djm Exp $ */
a47 2

#define KEX_COOKIE_LEN	16
@


1.79
log
@Preserve MAC ctx between packets, saving 2xhash calls per-packet.
Yields around a 12-16% end-to-end speedup for arcfour256/hmac-md5

patch from markus@@ tested dtucker@@ and myself, ok markus@@ and me (I'm
committing at his request)
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.78 2007/05/30 05:58:13 djm Exp $ */
a50 2
extern const EVP_MD *evp_ssh_sha256(void);

d316 1
a316 1
		k->evp_md = evp_ssh_sha256();
@


1.78
log
@tidy: KNF, ARGSUSED and u_int
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.77 2007/01/21 01:41:54 stevesk Exp $ */
d273 1
a273 1
	if (mac_init(mac, name) < 0)
@


1.77
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.76 2006/08/03 03:34:42 deraadt Exp $ */
d81 1
a81 1
	int i;
d102 1
a102 1
	debug2("kex_parse_kexinit: reserved %d ", i);
d117 1
d189 1
d254 2
a255 1
		fatal("no matching cipher found: client %s server %s", client, server);
d271 2
a272 1
		fatal("no matching mac found: client %s server %s", client, server);
d306 1
a306 1
		fatal("no kex alg");
d384 2
a385 1
		ctos = (!kex->server && mode == MODE_OUT) || (kex->server && mode == MODE_IN);
@


1.76
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.75 2006/08/01 23:22:47 stevesk Exp $ */
d544 1
a544 1
	for (i = 0; i< len; i++) {
@


1.75
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.74 2006/07/26 13:57:17 stevesk Exp $ */
a25 2
#include "includes.h"

d28 1
a28 2
#include <openssl/crypto.h>

d33 3
a36 1
#include "xmalloc.h"
a37 1
#include "bufaux.h"
d41 1
a42 1
#include "key.h"
@


1.74
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.73 2006/07/26 02:35:17 stevesk Exp $ */
d32 1
@


1.73
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.72 2006/07/22 20:48:23 stevesk Exp $ */
d32 1
@


1.72
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kex.c,v 1.71 2006/03/25 13:17:02 djm Exp $ */
d27 2
@


1.71
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d29 2
@


1.70
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.69
log
@spacing
@
text
@d79 1
a79 1
	proposal = xmalloc(PROPOSAL_MAX * sizeof(char *));
d214 1
a214 2
	kex = xmalloc(sizeof(*kex));
	memset(kex, 0, sizeof(*kex));
d373 1
a373 2
		newkeys = xmalloc(sizeof(*newkeys));
		memset(newkeys, 0, sizeof(*newkeys));
@


1.68
log
@spacing
@
text
@d258 1
d274 1
d292 1
d483 2
a484 1
		ctos = (!kex->server && mode == MODE_OUT) || (kex->server && mode == MODE_IN);
@


1.67
log
@RCSID() can die
@
text
@d427 1
a427 1
 	digest = xmalloc(roundup(need, mdsz));
@


1.66
log
@Implement the diffie-hellman-group-exchange-sha256 key exchange method
using the SHA256 code in libc (and wrapper to make it into an OpenSSL
EVP), interop tested against CVS PuTTY
@
text
@a25 1
RCSID("$OpenBSD: kex.c,v 1.65 2005/11/04 05:15:59 djm Exp $");
@


1.65
log
@remove hardcoded hash lengths in key exchange code, allowing
implementation of KEX methods with different hashes (e.g. SHA-256);
ok markus@@ dtucker@@ stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.64 2005/07/25 11:59:39 markus Exp $");
d47 2
d306 3
@


1.65.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kex.c,v 1.76 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 6
#include <sys/param.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
d30 1
a31 1
#include "ssh2.h"
d33 1
d37 1
a38 1
#include "kex.h"
a46 2
extern const EVP_MD *evp_ssh_sha256(void);

d78 1
a78 1
	proposal = xcalloc(PROPOSAL_MAX, sizeof(char *));
d213 2
a214 1
	kex = xcalloc(1, sizeof(*kex));
a256 1

a271 1

a288 1

a303 3
	} else if (strcmp(k->name, KEX_DHGEX_SHA256) == 0) {
		k->kex_type = KEX_DH_GEX_SHA256;
		k->evp_md = evp_ssh_sha256();
d367 2
a368 1
		newkeys = xcalloc(1, sizeof(*newkeys));
d423 1
a423 1
	digest = xmalloc(roundup(need, mdsz));
d476 1
a476 2
		ctos = (!kex->server && mode == MODE_OUT) ||
		    (kex->server && mode == MODE_IN);
@


1.64
log
@add a new compression method that delays compression until the user
has been authenticated successfully and set compression to 'delayed'
for sshd.

this breaks older openssh clients (< 3.5) if they insist on
compression, so you have to re-enable compression in sshd_config.
ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.63 2005/07/17 07:17:55 djm Exp $");
d297 1
d300 2
a301 1
	} else if (strcmp(k->name, KEX_DHGEX) == 0) {
d303 1
d307 1
d411 2
a412 1
derive_key(Kex *kex, int id, u_int need, u_char *hash, BIGNUM *shared_secret)
a414 1
	const EVP_MD *evp_md = EVP_sha1();
d418 1
a418 1
	int mdsz = EVP_MD_size(evp_md);
d421 3
a423 3
	if (mdsz < 0)
		fatal("derive_key: mdsz < 0");
	digest = xmalloc(roundup(need, mdsz));
d429 1
a429 1
	EVP_DigestInit(&md, evp_md);
d432 1
a432 1
	EVP_DigestUpdate(&md, hash, mdsz);
d443 1
a443 1
		EVP_DigestInit(&md, evp_md);
d446 1
a446 1
		EVP_DigestUpdate(&md, hash, mdsz);
d462 1
a462 1
kex_derive_keys(Kex *kex, u_char *hash, BIGNUM *shared_secret)
d467 4
a470 2
	for (i = 0; i < NKEYS; i++)
		keys[i] = derive_key(kex, 'A'+i, kex->we_need, hash, shared_secret);
@


1.64.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.65 2005/11/04 05:15:59 djm Exp $");
a296 1
		k->evp_md = EVP_sha1();
d299 1
a299 2
		k->evp_md = EVP_sha1();
	} else if (strcmp(k->name, KEX_DHGEX_SHA1) == 0) {
a300 1
		k->evp_md = EVP_sha1();
a303 1

d407 1
a407 2
derive_key(Kex *kex, int id, u_int need, u_char *hash, u_int hashlen,
    BIGNUM *shared_secret)
d410 1
d414 1
a414 1
	int mdsz;
d417 3
a419 3
	if ((mdsz = EVP_MD_size(kex->evp_md)) <= 0)
		fatal("bad kex md size %d", mdsz);
 	digest = xmalloc(roundup(need, mdsz));
d425 1
a425 1
	EVP_DigestInit(&md, kex->evp_md);
d428 1
a428 1
	EVP_DigestUpdate(&md, hash, hashlen);
d439 1
a439 1
		EVP_DigestInit(&md, kex->evp_md);
d442 1
a442 1
		EVP_DigestUpdate(&md, hash, hashlen);
d458 1
a458 1
kex_derive_keys(Kex *kex, u_char *hash, u_int hashlen, BIGNUM *shared_secret)
d463 2
a464 4
	for (i = 0; i < NKEYS; i++) {
		keys[i] = derive_key(kex, 'A'+i, kex->we_need, hash, hashlen,
		    shared_secret);
	}
@


1.64.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kex.c,v 1.76 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 6
#include <sys/param.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
d30 1
a31 1
#include "ssh2.h"
d33 1
d37 1
a38 1
#include "kex.h"
a46 2
extern const EVP_MD *evp_ssh_sha256(void);

d78 1
a78 1
	proposal = xcalloc(PROPOSAL_MAX, sizeof(char *));
d213 2
a214 1
	kex = xcalloc(1, sizeof(*kex));
a256 1

a271 1

a288 1

a303 3
	} else if (strcmp(k->name, KEX_DHGEX_SHA256) == 0) {
		k->kex_type = KEX_DH_GEX_SHA256;
		k->evp_md = evp_ssh_sha256();
d367 2
a368 1
		newkeys = xcalloc(1, sizeof(*newkeys));
d423 1
a423 1
	digest = xmalloc(roundup(need, mdsz));
d476 1
a476 2
		ctos = (!kex->server && mode == MODE_OUT) ||
		    (kex->server && mode == MODE_IN);
@


1.63
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.62 2005/07/16 01:35:24 djm Exp $");
d278 4
a281 2
	if (strcmp(name, "zlib") == 0) {
		comp->type = 1;
d283 1
a283 1
		comp->type = 0;
@


1.62
log
@spacing
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.61 2005/06/17 02:44:32 djm Exp $");
d395 1
a395 1
	   !(datafellows & SSH_BUG_FIRSTKEX)) {
@


1.61
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.60 2004/06/21 17:36:31 avsm Exp $");
d414 1
a414 1
	
@


1.60
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.59 2004/06/13 12:53:24 djm Exp $");
d55 1
a55 1
	int i;
d104 1
a104 1
	int i;
d153 1
a153 1
	int i;
d186 1
a186 2
	int dlen;
	int i;
d345 1
a345 3
	int mode;
	int ctos;				/* direction: if true client-to-server */
	int need;
d405 1
a405 1
derive_key(Kex *kex, int id, int need, u_char *hash, BIGNUM *shared_secret)
d411 1
a411 1
	int have;
d413 5
a417 1
	u_char *digest = xmalloc(roundup(need, mdsz));
d459 1
a459 1
	int i, mode, ctos;
d497 1
a497 1
	if (len < (512 / 8) || len > sizeof(nbuf))
d503 1
a503 1
	if (len < (512 / 8) || len > sizeof(nbuf))
d522 1
a522 1
	int i;
@


1.60.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.64 2005/07/25 11:59:39 markus Exp $");
d55 1
a55 1
	u_int i;
d104 1
a104 1
	u_int i;
d153 1
a153 1
	u_int i;
d186 2
a187 1
	u_int i, dlen;
d279 2
a280 4
	if (strcmp(name, "zlib@@openssh.com") == 0) {
		comp->type = COMP_DELAYED;
	} else if (strcmp(name, "zlib") == 0) {
		comp->type = COMP_ZLIB;
d282 1
a282 1
		comp->type = COMP_NONE;
d346 3
a348 1
	u_int mode, ctos, need;
d398 1
a398 1
	    !(datafellows & SSH_BUG_FIRSTKEX)) {
d408 1
a408 1
derive_key(Kex *kex, int id, u_int need, u_char *hash, BIGNUM *shared_secret)
d414 1
a414 1
	u_int have;
d416 1
a416 5
	u_char *digest;

	if (mdsz < 0)
		fatal("derive_key: mdsz < 0");
	digest = xmalloc(roundup(need, mdsz));
d458 1
a458 1
	u_int i, mode, ctos;
d496 1
a496 1
	if (len < (512 / 8) || (u_int)len > sizeof(nbuf))
d502 1
a502 1
	if (len < (512 / 8) || (u_int)len > sizeof(nbuf))
d521 1
a521 1
	u_int i;
@


1.60.4.2
log
@upgrade to OpenSSH 4.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.65 2005/11/04 05:15:59 djm Exp $");
a296 1
		k->evp_md = EVP_sha1();
d299 1
a299 2
		k->evp_md = EVP_sha1();
	} else if (strcmp(k->name, KEX_DHGEX_SHA1) == 0) {
a300 1
		k->evp_md = EVP_sha1();
a303 1

d407 1
a407 2
derive_key(Kex *kex, int id, u_int need, u_char *hash, u_int hashlen,
    BIGNUM *shared_secret)
d410 1
d414 1
a414 1
	int mdsz;
d417 3
a419 3
	if ((mdsz = EVP_MD_size(kex->evp_md)) <= 0)
		fatal("bad kex md size %d", mdsz);
 	digest = xmalloc(roundup(need, mdsz));
d425 1
a425 1
	EVP_DigestInit(&md, kex->evp_md);
d428 1
a428 1
	EVP_DigestUpdate(&md, hash, hashlen);
d439 1
a439 1
		EVP_DigestInit(&md, kex->evp_md);
d442 1
a442 1
		EVP_DigestUpdate(&md, hash, hashlen);
d458 1
a458 1
kex_derive_keys(Kex *kex, u_char *hash, u_int hashlen, BIGNUM *shared_secret)
d463 2
a464 4
	for (i = 0; i < NKEYS; i++) {
		keys[i] = derive_key(kex, 'A'+i, kex->we_need, hash, hashlen,
		    shared_secret);
	}
@


1.60.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.64 2005/07/25 11:59:39 markus Exp $");
d55 1
a55 1
	u_int i;
d104 1
a104 1
	u_int i;
d153 1
a153 1
	u_int i;
d186 2
a187 1
	u_int i, dlen;
d279 2
a280 4
	if (strcmp(name, "zlib@@openssh.com") == 0) {
		comp->type = COMP_DELAYED;
	} else if (strcmp(name, "zlib") == 0) {
		comp->type = COMP_ZLIB;
d282 1
a282 1
		comp->type = COMP_NONE;
d346 3
a348 1
	u_int mode, ctos, need;
d398 1
a398 1
	    !(datafellows & SSH_BUG_FIRSTKEX)) {
d408 1
a408 1
derive_key(Kex *kex, int id, u_int need, u_char *hash, BIGNUM *shared_secret)
d414 1
a414 1
	u_int have;
d416 1
a416 5
	u_char *digest;

	if (mdsz < 0)
		fatal("derive_key: mdsz < 0");
	digest = xmalloc(roundup(need, mdsz));
d458 1
a458 1
	u_int i, mode, ctos;
d496 1
a496 1
	if (len < (512 / 8) || (u_int)len > sizeof(nbuf))
d502 1
a502 1
	if (len < (512 / 8) || (u_int)len > sizeof(nbuf))
d521 1
a521 1
	u_int i;
@


1.59
log
@implement diffie-hellman-group14-sha1 kex method (trivial extension to
existing diffie-hellman-group1-sha1); ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.58 2004/05/09 01:26:48 djm Exp $");
d151 1
a151 1
	u_int32_t rand = 0;
d171 3
a173 3
			rand = arc4random();
		cookie[i] = rand;
		rand >>= 8;
@


1.58
log
@don't overwrite what we are trying to compute
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.57 2004/05/09 01:19:27 djm Exp $");
d296 2
@


1.57
log
@kill some more tiny files; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.56 2003/11/21 11:57:03 djm Exp $");
d507 1
a507 1
	EVP_DigestFinal(&md, id, NULL);
@


1.56
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.55 2003/04/01 10:31:26 markus Exp $");
d480 33
@


1.56.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.60 2004/06/21 17:36:31 avsm Exp $");
d151 1
a151 1
	u_int32_t rnd = 0;
d171 3
a173 3
			rnd = arc4random();
		cookie[i] = rnd;
		rnd >>= 8;
a295 2
	} else if (strcmp(k->name, KEX_DH14) == 0) {
		k->kex_type = KEX_DH_GRP14_SHA1;
a479 33
}

void
derive_ssh1_session_id(BIGNUM *host_modulus, BIGNUM *server_modulus,
    u_int8_t cookie[8], u_int8_t id[16])
{
	const EVP_MD *evp_md = EVP_md5();
	EVP_MD_CTX md;
	u_int8_t nbuf[2048], obuf[EVP_MAX_MD_SIZE];
	int len;

	EVP_DigestInit(&md, evp_md);

	len = BN_num_bytes(host_modulus);
	if (len < (512 / 8) || len > sizeof(nbuf))
		fatal("%s: bad host modulus (len %d)", __func__, len);
	BN_bn2bin(host_modulus, nbuf);
	EVP_DigestUpdate(&md, nbuf, len);

	len = BN_num_bytes(server_modulus);
	if (len < (512 / 8) || len > sizeof(nbuf))
		fatal("%s: bad server modulus (len %d)", __func__, len);
	BN_bn2bin(server_modulus, nbuf);
	EVP_DigestUpdate(&md, nbuf, len);

	EVP_DigestUpdate(&md, cookie, 8);

	EVP_DigestFinal(&md, obuf, NULL);
	memcpy(id, obuf, 16);

	memset(nbuf, 0, sizeof(nbuf));
	memset(obuf, 0, sizeof(obuf));
	memset(&md, 0, sizeof(md));
@


1.55
log
@bugfix causes stalled connections for ssh.com < 3.0; noticed by ho@@; tested by ho@@ and myself
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.54 2003/02/16 17:09:57 markus Exp $");
d313 1
a313 1
static int 
d395 1
a395 1
	if (first_kex_follows && !proposals_match(my, peer) && 
@


1.55.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.56 2003/11/21 11:57:03 djm Exp $");
d313 1
a313 1
static int
d395 1
a395 1
	if (first_kex_follows && !proposals_match(my, peer) &&
@


1.55.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.60 2004/06/21 17:36:31 avsm Exp $");
d151 1
a151 1
	u_int32_t rnd = 0;
d171 3
a173 3
			rnd = arc4random();
		cookie[i] = rnd;
		rnd >>= 8;
a295 2
	} else if (strcmp(k->name, KEX_DH14) == 0) {
		k->kex_type = KEX_DH_GRP14_SHA1;
a479 33
}

void
derive_ssh1_session_id(BIGNUM *host_modulus, BIGNUM *server_modulus,
    u_int8_t cookie[8], u_int8_t id[16])
{
	const EVP_MD *evp_md = EVP_md5();
	EVP_MD_CTX md;
	u_int8_t nbuf[2048], obuf[EVP_MAX_MD_SIZE];
	int len;

	EVP_DigestInit(&md, evp_md);

	len = BN_num_bytes(host_modulus);
	if (len < (512 / 8) || len > sizeof(nbuf))
		fatal("%s: bad host modulus (len %d)", __func__, len);
	BN_bn2bin(host_modulus, nbuf);
	EVP_DigestUpdate(&md, nbuf, len);

	len = BN_num_bytes(server_modulus);
	if (len < (512 / 8) || len > sizeof(nbuf))
		fatal("%s: bad server modulus (len %d)", __func__, len);
	BN_bn2bin(server_modulus, nbuf);
	EVP_DigestUpdate(&md, nbuf, len);

	EVP_DigestUpdate(&md, cookie, 8);

	EVP_DigestFinal(&md, obuf, NULL);
	memcpy(id, obuf, 16);

	memset(nbuf, 0, sizeof(nbuf));
	memset(obuf, 0, sizeof(obuf));
	memset(&md, 0, sizeof(md));
@


1.54
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.53 2003/02/02 10:56:08 markus Exp $");
d395 2
a396 1
	if (first_kex_follows && !proposals_match(my, peer)) {
@


1.54.2.1
log
@Update OpenSSH to version 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.51.2.2 2003/04/03 23:27:12 margarida Exp $");
d395 1
a395 2
	if (first_kex_follows && !proposals_match(my, peer) && 
	   !(datafellows & SSH_BUG_FIRSTKEX)) {
@


1.54.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.55 2003/04/01 10:31:26 markus Exp $");
@


1.54.2.3
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.56 2003/11/21 11:57:03 djm Exp $");
d313 1
a313 1
static int
d395 1
a395 1
	if (first_kex_follows && !proposals_match(my, peer) &&
@


1.53
log
@add support for key exchange guesses; based on work by
avraham.fraenkel@@commatch.com; fixes bug #148; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.52 2002/11/21 22:45:31 markus Exp $");
a46 5
/* Use privilege separation for sshd */
int use_privsep;
struct monitor *pmonitor;


d235 4
a238 8
	switch (kex->kex_type) {
	case DH_GRP1_SHA1:
		kexdh(kex);
		break;
	case DH_GEX_SHA1:
		kexgex(kex);
		break;
	default:
d295 1
a295 1
		k->kex_type = DH_GRP1_SHA1;
d297 1
a297 1
		k->kex_type = DH_GEX_SHA1;
@


1.52
log
@debug->debug2, unify debug messages
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.51 2002/06/24 14:55:38 markus Exp $");
d77 1
a77 1
kex_buf2prop(Buffer *raw)
d97 2
d322 24
d356 1
d358 2
a359 2
	my   = kex_buf2prop(&kex->my);
	peer = kex_buf2prop(&kex->peer);
d402 6
@


1.51
log
@cat to (void) when output from buffer_get_X is ignored
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.50 2002/05/15 15:47:49 mouring Exp $");
d138 1
a138 1
	debug("waiting for SSH2_MSG_NEWKEYS");
d436 1
a436 1
	debug("kex_derive_keys");
@


1.51.2.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.54 2003/02/16 17:09:57 markus Exp $");
d47 5
d77 1
a77 1
kex_buf2prop(Buffer *raw, int *first_kex_follows)
a96 2
	if (first_kex_follows != NULL)
		*first_kex_follows = i;
d138 1
a138 1
	debug("expecting SSH2_MSG_NEWKEYS");
d238 8
a245 4
	if (kex->kex_type >= 0 && kex->kex_type < KEX_MAX &&
	    kex->kex[kex->kex_type] != NULL) {
		(kex->kex[kex->kex_type])(kex);
	} else {
d302 1
a302 1
		k->kex_type = KEX_DH_GRP1_SHA1;
d304 1
a304 1
		k->kex_type = KEX_DH_GEX_SHA1;
a319 24
static int 
proposals_match(char *my[PROPOSAL_MAX], char *peer[PROPOSAL_MAX])
{
	static int check[] = {
		PROPOSAL_KEX_ALGS, PROPOSAL_SERVER_HOST_KEY_ALGS, -1
	};
	int *idx;
	char *p;

	for (idx = &check[0]; *idx != -1; idx++) {
		if ((p = strchr(my[*idx], ',')) != NULL)
			*p = '\0';
		if ((p = strchr(peer[*idx], ',')) != NULL)
			*p = '\0';
		if (strcmp(my[*idx], peer[*idx]) != 0) {
			debug2("proposal mismatch: my %s peer %s",
			    my[*idx], peer[*idx]);
			return (0);
		}
	}
	debug2("proposals match");
	return (1);
}

a329 1
	int first_kex_follows, type;
d331 2
a332 2
	my   = kex_buf2prop(&kex->my, NULL);
	peer = kex_buf2prop(&kex->peer, &first_kex_follows);
a375 6
	/* ignore the next message if the proposals do not match */
	if (first_kex_follows && !proposals_match(my, peer)) {
		type = packet_read();
		debug2("skipping next packet (type %u)", type);
	}

d436 1
a436 1
	debug2("kex_derive_keys");
@


1.51.2.2
log
@Update to OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.55 2003/04/01 10:31:26 markus Exp $");
d395 1
a395 2
	if (first_kex_follows && !proposals_match(my, peer) && 
	   !(datafellows & SSH_BUG_FIRSTKEX)) {
@


1.51.2.3
log
@upgrade to OpenSSH 3.7
@
text
@@


1.50
log
@'monitor' variable clashes with at least one lame platform (NeXT).  Renamed
to 'pmonitor'.  provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.49 2002/03/26 23:14:51 markus Exp $");
d205 2
a206 2
	packet_get_char();
	packet_get_int();
@


1.49
log
@generate a new cookie for each SSH2_MSG_KEXINIT message we send out
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.48 2002/03/18 17:50:31 provos Exp $");
d49 1
a49 1
struct monitor *monitor;
@


1.49.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.50 2002/05/15 15:47:49 mouring Exp $");
d49 1
a49 1
struct monitor *pmonitor;
@


1.49.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.49.2.3
log
@Pull in OpenSSH-3.4
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.51 2002/06/24 14:55:38 markus Exp $");
d205 2
a206 2
	(void) packet_get_char();
	(void) packet_get_int();
@


1.49.2.4
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.55 2003/04/01 10:31:26 markus Exp $");
d47 5
d77 1
a77 1
kex_buf2prop(Buffer *raw, int *first_kex_follows)
a96 2
	if (first_kex_follows != NULL)
		*first_kex_follows = i;
d138 1
a138 1
	debug("expecting SSH2_MSG_NEWKEYS");
d238 8
a245 4
	if (kex->kex_type >= 0 && kex->kex_type < KEX_MAX &&
	    kex->kex[kex->kex_type] != NULL) {
		(kex->kex[kex->kex_type])(kex);
	} else {
d302 1
a302 1
		k->kex_type = KEX_DH_GRP1_SHA1;
d304 1
a304 1
		k->kex_type = KEX_DH_GEX_SHA1;
a319 24
static int 
proposals_match(char *my[PROPOSAL_MAX], char *peer[PROPOSAL_MAX])
{
	static int check[] = {
		PROPOSAL_KEX_ALGS, PROPOSAL_SERVER_HOST_KEY_ALGS, -1
	};
	int *idx;
	char *p;

	for (idx = &check[0]; *idx != -1; idx++) {
		if ((p = strchr(my[*idx], ',')) != NULL)
			*p = '\0';
		if ((p = strchr(peer[*idx], ',')) != NULL)
			*p = '\0';
		if (strcmp(my[*idx], peer[*idx]) != 0) {
			debug2("proposal mismatch: my %s peer %s",
			    my[*idx], peer[*idx]);
			return (0);
		}
	}
	debug2("proposals match");
	return (1);
}

a329 1
	int first_kex_follows, type;
d331 2
a332 2
	my   = kex_buf2prop(&kex->my, NULL);
	peer = kex_buf2prop(&kex->peer, &first_kex_follows);
a375 7
	/* ignore the next message if the proposals do not match */
	if (first_kex_follows && !proposals_match(my, peer) && 
	   !(datafellows & SSH_BUG_FIRSTKEX)) {
		type = packet_read();
		debug2("skipping next packet (type %u)", type);
	}

d436 1
a436 1
	debug2("kex_derive_keys");
@


1.48
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.47 2002/02/28 15:46:33 markus Exp $");
a59 1
	u_int32_t rand = 0;
d63 6
a68 6
	for (i = 0; i < KEX_COOKIE_LEN; i++) {
		if (i % 4 == 0)
			rand = arc4random();
		buffer_put_char(b, rand & 0xff);
		rand >>= 8;
	}
d154 4
d167 11
@


1.47
log
@add some const EVP_MD for openssl-0.9.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.46 2002/02/23 17:59:02 markus Exp $");
d43 1
d46 5
@


1.46
log
@don't allow garbage after payload.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.45 2002/02/14 23:41:01 markus Exp $");
d364 1
a364 1
	EVP_MD *evp_md = EVP_sha1();
@


1.45
log
@hide some more implementation details of cipher.[ch] and prepares for move
to EVP, ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.44 2002/02/11 16:10:15 markus Exp $");
d135 1
@


1.44
log
@restore kexinit handler if we reset the dispatcher, this unbreaks rekeying
s/kex_clear_dispatch/kex_reset_dispatch/
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.43 2002/01/25 22:07:40 markus Exp $");
d235 1
a235 2
	enc->cipher = cipher_by_name(name);
	if (enc->cipher == NULL)
d241 2
d345 4
a348 4
		if (need < newkeys->enc.cipher->key_len)
			need = newkeys->enc.cipher->key_len;
		if (need < newkeys->enc.cipher->block_size)
			need = newkeys->enc.cipher->block_size;
@


1.43
log
@use EVP_MD_size(evp_md) and not evp_md->md_size; ok steveks@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.42 2002/01/11 13:39:36 markus Exp $");
d116 1
a116 1
kex_clear_dispatch(void)
d120 1
d126 1
a126 1
	kex_clear_dispatch();
d204 1
a204 2
	kex_clear_dispatch();
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
@


1.42
log
@a single dispatch_protocol_error() that sends a message of type 'UNIMPLEMENTED'
dispatch_range(): set handler for a ranges message types
use dispatch_protocol_ignore() for authentication requests after
	successful authentication (the drafts requirement).
serverloop/clientloop now send a 'UNIMPLEMENTED' message instead of exiting.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.41 2001/12/28 15:06:00 markus Exp $");
d366 1
a366 1
	int mdsz = evp_md->md_size;
@


1.41
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.40 2001/12/28 14:50:54 markus Exp $");
d118 2
a119 5
	int i;

	/* Numbers 30-49 are used for kex packets */
	for (i = 30; i <= 49; i++)
		dispatch_set(i, &kex_protocol_error);
@


1.40
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.39 2001/12/28 12:14:27 markus Exp $");
d110 1
a110 1
kex_protocol_error(int type, int plen, u_int32_t seq, void *ctxt)
d112 1
a112 1
	error("Hm, kex protocol error: type %d plen %d", type, plen);
d167 1
a167 1
kex_input_kexinit(int type, int plen, u_int32_t seq, void *ctxt)
@


1.39
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.38 2001/12/20 22:50:24 djm Exp $");
a127 2
	int plen;

d136 1
a136 1
	packet_read_expect(&plen, SSH2_MSG_NEWKEYS);
@


1.38
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.37 2001/12/05 10:06:12 deraadt Exp $");
d190 1
a190 1
	packet_done();
@


1.37
log
@minor KNF
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.36 2001/06/25 08:25:37 markus Exp $");
d110 1
a110 1
kex_protocol_error(int type, int plen, void *ctxt)
d169 1
a169 1
kex_input_kexinit(int type, int plen, void *ctxt)
@


1.36
log
@update copyright for 2001
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.35 2001/06/23 15:12:18 itojun Exp $");
d222 1
a222 1
	switch(kex->kex_type) {
d447 1
a447 1
	for (i = 0; i< len; i++){
@


1.36.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.47 2002/02/28 15:46:33 markus Exp $");
d110 1
a110 1
kex_protocol_error(int type, u_int32_t seq, void *ctxt)
d112 1
a112 1
	error("Hm, kex protocol error: type %d seq %u", type, seq);
d116 1
a116 1
kex_reset_dispatch(void)
d118 5
a122 3
	dispatch_range(SSH2_MSG_TRANSPORT_MIN,
	    SSH2_MSG_TRANSPORT_MAX, &kex_protocol_error);
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
d128 3
a130 1
	kex_reset_dispatch();
d138 1
a138 2
	packet_read_expect(SSH2_MSG_NEWKEYS);
	packet_check_eom();
d169 1
a169 1
kex_input_kexinit(int type, u_int32_t seq, void *ctxt)
d190 1
a190 1
	packet_check_eom();
d208 2
a209 1
	kex_reset_dispatch();
d222 1
a222 1
	switch (kex->kex_type) {
d240 2
a241 1
	if ((enc->cipher = cipher_by_name(name)) == NULL)
a246 2
	enc->key_len = cipher_keylen(enc->cipher);
	enc->block_size = cipher_blocksize(enc->cipher);
d349 4
a352 4
		if (need < newkeys->enc.key_len)
			need = newkeys->enc.key_len;
		if (need < newkeys->enc.block_size)
			need = newkeys->enc.block_size;
d367 1
a367 1
	const EVP_MD *evp_md = EVP_sha1();
d371 1
a371 1
	int mdsz = EVP_MD_size(evp_md);
d447 1
a447 1
	for (i = 0; i< len; i++) {
@


1.36.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.50 2002/05/15 15:47:49 mouring Exp $");
a42 1
#include "monitor.h"
a45 5
/* Use privilege separation for sshd */
int use_privsep;
struct monitor *pmonitor;


d54 1
d58 6
a63 6
	/*
	 * add a dummy cookie, the cookie will be overwritten by
	 * kex_send_kexinit(), each time a kexinit is set
	 */
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		buffer_put_char(b, 0);
a148 4
	u_int32_t rand = 0;
	u_char *cookie;
	int i;

a157 11

	/* generate a random cookie */
	if (buffer_len(&kex->my) < KEX_COOKIE_LEN)
		fatal("kex_send_kexinit: kex proposal too short");
	cookie = buffer_ptr(&kex->my);
	for (i = 0; i < KEX_COOKIE_LEN; i++) {
		if (i % 4 == 0)
			rand = arc4random();
		cookie[i] = rand;
		rand >>= 8;
	}
@


1.36.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.36.2.2 2002/05/17 00:03:23 miod Exp $");
d205 2
a206 2
	(void) packet_get_char();
	(void) packet_get_int();
@


1.35
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d2 1
a2 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.34 2001/04/30 15:50:46 markus Exp $");
@


1.34
log
@allow interop with weaker key generation used by ssh-2.0.x, x < 10
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.33 2001/04/05 10:42:50 markus Exp $");
d46 3
a48 2
void	kex_kexinit_finish(Kex *kex);
void	kex_choose_conf(Kex *k);
d51 1
a51 1
void
d71 1
a71 1
char **
d99 1
a99 1
void
d109 1
a109 1
void
d115 1
a115 1
void
d214 1
a214 1
void
d234 1
a234 1
void
d248 1
a248 1
void
d263 1
a263 1
void
d278 1
a278 1
void
d291 1
a291 1
void
d303 1
a303 1
void
d363 1
a363 1
u_char *
@


1.33
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.32 2001/04/04 23:09:18 markus Exp $");
d378 2
a379 1
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
d392 2
a393 1
		EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
@


1.33.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.36 2001/06/25 08:25:37 markus Exp $");
d46 2
a47 3
/* prototype */
static void kex_kexinit_finish(Kex *);
static void kex_choose_conf(Kex *);
d50 1
a50 1
static void
d70 1
a70 1
static char **
d98 1
a98 1
static void
d108 1
a108 1
static void
d114 1
a114 1
static void
d213 1
a213 1
static void
d233 1
a233 1
static void
d247 1
a247 1
static void
d262 1
a262 1
static void
d277 1
a277 1
static void
d290 1
a290 1
static void
d302 1
a302 1
static void
d362 1
a362 1
static u_char *
d378 1
a378 2
	if (!(datafellows & SSH_BUG_DERIVEKEY))
		EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
d391 1
a391 2
		if (!(datafellows & SSH_BUG_DERIVEKEY))
			EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
@


1.33.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.47 2002/02/28 15:46:33 markus Exp $");
d110 1
a110 1
kex_protocol_error(int type, u_int32_t seq, void *ctxt)
d112 1
a112 1
	error("Hm, kex protocol error: type %d seq %u", type, seq);
d116 1
a116 1
kex_reset_dispatch(void)
d118 5
a122 3
	dispatch_range(SSH2_MSG_TRANSPORT_MIN,
	    SSH2_MSG_TRANSPORT_MAX, &kex_protocol_error);
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
d128 3
a130 1
	kex_reset_dispatch();
d138 1
a138 2
	packet_read_expect(SSH2_MSG_NEWKEYS);
	packet_check_eom();
d169 1
a169 1
kex_input_kexinit(int type, u_int32_t seq, void *ctxt)
d190 1
a190 1
	packet_check_eom();
d208 2
a209 1
	kex_reset_dispatch();
d222 1
a222 1
	switch (kex->kex_type) {
d240 2
a241 1
	if ((enc->cipher = cipher_by_name(name)) == NULL)
a246 2
	enc->key_len = cipher_keylen(enc->cipher);
	enc->block_size = cipher_blocksize(enc->cipher);
d349 4
a352 4
		if (need < newkeys->enc.key_len)
			need = newkeys->enc.key_len;
		if (need < newkeys->enc.block_size)
			need = newkeys->enc.block_size;
d367 1
a367 1
	const EVP_MD *evp_md = EVP_sha1();
d371 1
a371 1
	int mdsz = EVP_MD_size(evp_md);
d447 1
a447 1
	for (i = 0; i< len; i++) {
@


1.33.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.50 2002/05/15 15:47:49 mouring Exp $");
a42 1
#include "monitor.h"
a45 5
/* Use privilege separation for sshd */
int use_privsep;
struct monitor *pmonitor;


d54 1
d58 6
a63 6
	/*
	 * add a dummy cookie, the cookie will be overwritten by
	 * kex_send_kexinit(), each time a kexinit is set
	 */
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		buffer_put_char(b, 0);
a148 4
	u_int32_t rand = 0;
	u_char *cookie;
	int i;

a157 11

	/* generate a random cookie */
	if (buffer_len(&kex->my) < KEX_COOKIE_LEN)
		fatal("kex_send_kexinit: kex proposal too short");
	cookie = buffer_ptr(&kex->my);
	for (i = 0; i < KEX_COOKIE_LEN; i++) {
		if (i % 4 == 0)
			rand = arc4random();
		cookie[i] = rand;
		rand >>= 8;
	}
@


1.32
log
@clear+free keys,iv for rekeying.
+ fix DH mem leaks. ok niels@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.31 2001/04/04 22:04:34 markus Exp $");
d111 1
a111 1
        error("Hm, kex protocol error: type %d plen %d", type, plen);
d136 2
a137 2
        debug("waiting for SSH2_MSG_NEWKEYS");
        packet_read_expect(&plen, SSH2_MSG_NEWKEYS);
@


1.31
log
@parse full kexinit packet.
make server-side more robust, too.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.30 2001/04/04 20:25:37 markus Exp $");
d139 1
d144 2
@


1.30
log
@more robust rekeying
don't send channel data after rekeying is started.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.29 2001/04/04 14:34:58 markus Exp $");
d169 1
d178 9
@


1.29
log
@enable server side rekeying + some rekey related clientup.
todo: we should not send any non-KEX messages after we send KEXINIT
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.28 2001/04/04 09:48:34 markus Exp $");
d139 1
a139 1
	kex->newkeys = 1;
d156 1
d191 1
a191 1
	kex->newkeys = 0;
d311 1
d315 1
a315 1
		kex->keys[mode] = newkeys;
d334 1
a334 1
		newkeys = kex->keys[mode];
d358 1
a358 1
	u_char *digest = xmalloc(((need+mdsz-1)/mdsz)*mdsz);
d363 1
d365 3
a367 3
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));	/* shared_secret K */
	EVP_DigestUpdate(&md, hash, mdsz);		/* transport-06 */
	EVP_DigestUpdate(&md, &c, 1);			/* key id */
d371 5
a375 1
	/* expand */
d391 1
a391 1
Newkeys *x_newkeys[MODE_MAX];
a396 1
	Newkeys *newkeys;
d405 2
a406 1
		newkeys = kex->keys[mode];
d408 3
a410 4
		newkeys->enc.iv  = keys[ctos ? 0 : 1];
		newkeys->enc.key = keys[ctos ? 2 : 3];
		newkeys->mac.key = keys[ctos ? 4 : 5];
		x_newkeys[mode] = newkeys;
d417 5
a421 1
	return x_newkeys[mode];
@


1.28
log
@don't sent multiple kexinit-requests.
send newkeys, block while waiting for newkeys.
fix comments.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.27 2001/04/03 23:32:11 markus Exp $");
d115 10
d127 3
a129 1
	int i, plen;
a139 2
	for (i = 30; i <= 49; i++)
		dispatch_set(i, &kex_protocol_error);
d148 4
d171 2
a183 1
	int i;
d193 2
a194 3
	/* Numbers 30-49 are used for kex packets */
	for (i = 30; i <= 49; i++)
		dispatch_set(i, kex_protocol_error);
a195 1
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
@


1.27
log
@undo parts of recent my changes: main part of keyexchange does not
need dispatch-callbacks, since application data is delayed until
the keyexchange completes (if i understand the drafts correctly).

add some infrastructure for re-keying.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.26 2001/04/03 19:53:29 markus Exp $");
d115 1
a115 1
kex_send_newkeys(void)
d117 2
a122 7
}

void
kex_input_newkeys(int type, int plen, void *ctxt)
{
	Kex *kex = ctxt;
	int i;
d124 2
d138 4
d165 1
a165 1
kex_start(char *proposal[PROPOSAL_MAX])
a182 1
	dispatch_set(SSH2_MSG_NEWKEYS, &kex_input_newkeys);
@


1.26
log
@move kex to kex*.c, used dispatch_set() callbacks for kex. should
make rekeying easier.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.25 2001/03/29 21:17:39 markus Exp $");
d134 1
a134 1
	buffer_clear(&kex->my);
a154 1
	dispatch_set(SSH2_MSG_KEXINIT, &kex_protocol_error);
d276 1
a276 1
kex_choose_conf(Kex *k)
d278 1
d281 1
d286 2
a287 2
	my   = kex_buf2prop(&k->my);
	peer = kex_buf2prop(&k->peer);
d289 1
a289 1
	if (k->server) {
d298 4
a301 2
		int nenc, nmac, ncomp;
		ctos = (!k->server && mode == MODE_OUT) || (k->server && mode == MODE_IN);
d305 3
a307 3
		choose_enc (&k->enc [mode], cprop[nenc],  sprop[nenc]);
		choose_mac (&k->mac [mode], cprop[nmac],  sprop[nmac]);
		choose_comp(&k->comp[mode], cprop[ncomp], sprop[ncomp]);
d310 3
a312 3
		    k->enc[mode].name,
		    k->mac[mode].name,
		    k->comp[mode].name);
d314 2
a315 2
	choose_kex(k, cprop[PROPOSAL_KEX_ALGS], sprop[PROPOSAL_KEX_ALGS]);
	choose_hostkeyalg(k, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],
d319 7
a325 6
	    if (need < k->enc[mode].cipher->key_len)
		    need = k->enc[mode].cipher->key_len;
	    if (need < k->enc[mode].cipher->block_size)
		    need = k->enc[mode].cipher->block_size;
	    if (need < k->mac[mode].key_len)
		    need = k->mac[mode].key_len;
d328 1
a328 1
	k->we_need = need;
a331 1

d335 1
a335 1
derive_key(int id, int need, u_char *hash, BIGNUM *shared_secret)
d352 1
a352 1
	EVP_DigestUpdate(&md, hash, mdsz);		/* session id */
d371 2
d375 1
a375 1
kex_derive_keys(Kex *k, u_char *hash, BIGNUM *shared_secret)
d377 1
a377 3
	int i;
	int mode;
	int ctos;
d379 1
d382 1
a382 1
		keys[i] = derive_key('A'+i, k->we_need, hash, shared_secret);
d384 1
d386 6
a391 4
		ctos = (!k->server && mode == MODE_OUT) || (k->server && mode == MODE_IN);
		k->enc[mode].iv  = keys[ctos ? 0 : 1];
		k->enc[mode].key = keys[ctos ? 2 : 3];
		k->mac[mode].key = keys[ctos ? 4 : 5];
d393 6
@


1.25
log
@prepare for rekeying: move DH code to dh.c
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.24 2001/03/28 21:59:40 provos Exp $");
a28 3
#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/pem.h>
d42 1
d46 6
a51 2
Buffer *
kex_init(char *myproposal[PROPOSAL_MAX])
a52 2
	int first_kex_packet_follows = 0;
	u_char cookie[KEX_COOKIE_LEN];
d55 2
a56 1
	Buffer *ki = xmalloc(sizeof(*ki));
d60 1
a60 1
		cookie[i] = rand & 0xff;
a62 2
	buffer_init(ki);
	buffer_append(ki, (char *)cookie, sizeof cookie);
d64 3
a66 4
		buffer_put_cstring(ki, myproposal[i]);
	buffer_put_char(ki, first_kex_packet_follows);
	buffer_put_int(ki, 0);				/* uint32 reserved */
	return ki;
d69 3
a71 5
/* send kexinit, parse and save reply */
void
kex_exchange_kexinit(
    Buffer *my_kexinit, Buffer *peer_kexint,
    char *peer_proposal[PROPOSAL_MAX])
d73 1
d75 1
a75 2
	char *ptr;
	int plen;
d77 1
a77 6
	debug("send KEXINIT");
	packet_start(SSH2_MSG_KEXINIT);
	packet_put_raw(buffer_ptr(my_kexinit), buffer_len(my_kexinit));
	packet_send();
	packet_write_wait();
	debug("done");
d79 2
a80 10
	/*
	 * read and save raw KEXINIT payload in buffer. this is used during
	 * computation of the session_id and the session keys.
	 */
	debug("wait KEXINIT");
	packet_read_expect(&plen, SSH2_MSG_KEXINIT);
	ptr = packet_get_raw(&plen);
	buffer_append(peer_kexint, ptr, plen);

	/* parse packet and save algorithm proposal */
d83 1
a83 1
		packet_get_char();
d86 2
a87 2
		peer_proposal[i] = packet_get_string(NULL);
		debug("got kexinit: %s", peer_proposal[i]);
d89 7
a95 7
	/* first kex follow / reserved */
	i = packet_get_char();
	debug("first kex follow: %d ", i);
	i = packet_get_int();
	debug("reserved: %d ", i);
	packet_done();
	debug("done");
a97 1
#ifdef DEBUG_KEX
d99 1
a99 1
dump_digest(u_char *digest, int len)
d102 4
a105 6
	for (i = 0; i< len; i++){
		fprintf(stderr, "%02x", digest[i]);
		if(i%2!=0)
			fprintf(stderr, " ");
	}
	fprintf(stderr, "\n");
a106 1
#endif
d108 2
a109 10
u_char *
kex_hash(
    char *client_version_string,
    char *server_version_string,
    char *ckexinit, int ckexinitlen,
    char *skexinit, int skexinitlen,
    char *serverhostkeyblob, int sbloblen,
    BIGNUM *client_dh_pub,
    BIGNUM *server_dh_pub,
    BIGNUM *shared_secret)
d111 2
a112 4
	Buffer b;
	static u_char digest[EVP_MAX_MD_SIZE];
	EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
d114 8
a121 3
	buffer_init(&b);
	buffer_put_string(&b, client_version_string, strlen(client_version_string));
	buffer_put_string(&b, server_version_string, strlen(server_version_string));
d123 5
a127 12
	/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
	buffer_put_int(&b, ckexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, ckexinit, ckexinitlen);
	buffer_put_int(&b, skexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, skexinit, skexinitlen);

	buffer_put_string(&b, serverhostkeyblob, sbloblen);
	buffer_put_bignum2(&b, client_dh_pub);
	buffer_put_bignum2(&b, server_dh_pub);
	buffer_put_bignum2(&b, shared_secret);
d129 8
a136 3
#ifdef DEBUG_KEX
	buffer_dump(&b);
#endif
d138 8
a145 10
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
	EVP_DigestFinal(&md, digest, NULL);

	buffer_free(&b);

#ifdef DEBUG_KEX
	dump_digest(digest, evp_md->md_size);
#endif
	return digest;
d148 2
a149 11
u_char *
kex_hash_gex(
    char *client_version_string,
    char *server_version_string,
    char *ckexinit, int ckexinitlen,
    char *skexinit, int skexinitlen,
    char *serverhostkeyblob, int sbloblen,
    int min, int wantbits, int max, BIGNUM *prime, BIGNUM *gen,
    BIGNUM *client_dh_pub,
    BIGNUM *server_dh_pub,
    BIGNUM *shared_secret)
d151 3
a153 4
	Buffer b;
	static u_char digest[EVP_MAX_MD_SIZE];
	EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
d155 2
a156 3
	buffer_init(&b);
	buffer_put_string(&b, client_version_string, strlen(client_version_string));
	buffer_put_string(&b, server_version_string, strlen(server_version_string));
d158 2
a159 21
	/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
	buffer_put_int(&b, ckexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, ckexinit, ckexinitlen);
	buffer_put_int(&b, skexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, skexinit, skexinitlen);

	buffer_put_string(&b, serverhostkeyblob, sbloblen);
	if (min == -1 || max == -1) 
		buffer_put_int(&b, wantbits);
	else {
		buffer_put_int(&b, min);
		buffer_put_int(&b, wantbits);
		buffer_put_int(&b, max);
	}
	buffer_put_bignum2(&b, prime);
	buffer_put_bignum2(&b, gen);
	buffer_put_bignum2(&b, client_dh_pub);
	buffer_put_bignum2(&b, server_dh_pub);
	buffer_put_bignum2(&b, shared_secret);
d161 2
a162 3
#ifdef DEBUG_KEX
	buffer_dump(&b);
#endif
d164 5
a168 3
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
	EVP_DigestFinal(&md, digest, NULL);
d170 15
a184 6
	buffer_free(&b);

#ifdef DEBUG_KEX
	dump_digest(digest, evp_md->md_size);
#endif
	return digest;
d187 2
a188 2
u_char *
derive_key(int id, int need, u_char *hash, BIGNUM *shared_secret)
d190 2
a191 10
	Buffer b;
	EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
	char c = id;
	int have;
	int mdsz = evp_md->md_size;
	u_char *digest = xmalloc(((need+mdsz-1)/mdsz)*mdsz);

	buffer_init(&b);
	buffer_put_bignum2(&b, shared_secret);
d193 1
a193 6
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));	/* shared_secret K */
	EVP_DigestUpdate(&md, hash, mdsz);		/* transport-06 */
	EVP_DigestUpdate(&md, &c, 1);			/* key id */
	EVP_DigestUpdate(&md, hash, mdsz);		/* session id */
	EVP_DigestFinal(&md, digest, NULL);
d195 9
a203 7
	/* expand */
	for (have = mdsz; need > have; have += mdsz) {
		EVP_DigestInit(&md, evp_md);
		EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
		EVP_DigestUpdate(&md, hash, mdsz);
		EVP_DigestUpdate(&md, digest, have);
		EVP_DigestFinal(&md, digest + have, NULL);
a204 6
	buffer_free(&b);
#ifdef DEBUG_KEX
	fprintf(stderr, "Digest '%c'== ", c);
	dump_digest(digest, need);
#endif
	return digest;
d276 2
a277 2
Kex *
kex_choose_conf(char *cprop[PROPOSAL_MAX], char *sprop[PROPOSAL_MAX], int server)
d279 2
a283 1
	Kex *k;
d285 10
a294 3
	k = xmalloc(sizeof(*k));
	memset(k, 0, sizeof(*k));
	k->server = server;
d325 41
a365 1
	return k;
d369 1
a369 1
int
a385 1
	return 0;
d387 18
@


1.24
log
@forgot to include min and max params in hash, okay markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.23 2001/03/10 17:51:04 markus Exp $");
a30 1
#include <openssl/dh.h>
a112 107
}

/* diffie-hellman-group1-sha1 */

int
dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
{
	int i;
	int n = BN_num_bits(dh_pub);
	int bits_set = 0;

	if (dh_pub->neg) {
		log("invalid public DH value: negativ");
		return 0;
	}
	for (i = 0; i <= n; i++)
		if (BN_is_bit_set(dh_pub, i))
			bits_set++;
	debug("bits set: %d/%d", bits_set, BN_num_bits(dh->p));

	/* if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial */
	if (bits_set > 1 && (BN_cmp(dh_pub, dh->p) == -1))
		return 1;
	log("invalid public DH value (%d/%d)", bits_set, BN_num_bits(dh->p));
	return 0;
}

void
dh_gen_key(DH *dh, int need)
{
	int i, bits_set = 0, tries = 0;

	if (dh->p == NULL)
		fatal("dh_gen_key: dh->p == NULL");
	if (2*need >= BN_num_bits(dh->p))
		fatal("dh_gen_key: group too small: %d (2*need %d)",
		    BN_num_bits(dh->p), 2*need);
	do {
		if (dh->priv_key != NULL)
			BN_free(dh->priv_key);
		dh->priv_key = BN_new();
		if (dh->priv_key == NULL)
			fatal("dh_gen_key: BN_new failed");
		/* generate a 2*need bits random private exponent */
		if (!BN_rand(dh->priv_key, 2*need, 0, 0))
			fatal("dh_gen_key: BN_rand failed");
		if (DH_generate_key(dh) == 0)
			fatal("DH_generate_key");
		for (i = 0; i <= BN_num_bits(dh->priv_key); i++)
			if (BN_is_bit_set(dh->priv_key, i))
				bits_set++;
		debug("dh_gen_key: priv key bits set: %d/%d",
		    bits_set, BN_num_bits(dh->priv_key));
		if (tries++ > 10)
			fatal("dh_gen_key: too many bad keys: giving up");
	} while (!dh_pub_is_valid(dh, dh->pub_key));
}

DH *
dh_new_group_asc(const char *gen, const char *modulus)
{
	DH *dh;
	int ret;

	dh = DH_new();
	if (dh == NULL)
		fatal("DH_new");

	if ((ret = BN_hex2bn(&dh->p, modulus)) < 0)
		fatal("BN_hex2bn p");
	if ((ret = BN_hex2bn(&dh->g, gen)) < 0)
		fatal("BN_hex2bn g");

	return (dh);
}

/*
 * This just returns the group, we still need to generate the exchange
 * value.
 */

DH *
dh_new_group(BIGNUM *gen, BIGNUM *modulus)
{
	DH *dh;

	dh = DH_new();
	if (dh == NULL)
		fatal("DH_new");
	dh->p = modulus;
	dh->g = gen;

	return (dh);
}

DH *
dh_new_group1(void)
{
	static char *gen = "2", *group1 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE65381"
	    "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group1));
@


1.23
log
@add PreferredAuthentications
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.22 2001/03/05 17:17:20 markus Exp $");
d293 1
a293 1
    int minbits, BIGNUM *prime, BIGNUM *gen,
d316 7
a322 1
	buffer_put_int(&b, minbits);
@


1.22
log
@generate a 2*need size (~300 instead of 1024/2048) random private
exponent during the DH key agreement. according to Niels (the great
german advisor) this is safe since /etc/primes contains strong
primes only.

References:
        P. C. van Oorschot and M. J. Wiener, On Diffie-Hellman key
        agreement with short exponents, In Advances in Cryptology
        - EUROCRYPT'96, LNCS 1070, Springer-Verlag, 1996, pp.332-343.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.21 2001/02/11 12:59:24 markus Exp $");
d45 1
a375 39
#define NKEYS	6

#define	MAX_PROP	20
#define	SEP	","

char *
get_match(char *client, char *server)
{
	char *sproposals[MAX_PROP];
	char *c, *s, *p, *ret, *cp, *sp;
	int i, j, nproposals;

	c = cp = xstrdup(client);
	s = sp = xstrdup(server);

	for ((p = strsep(&sp, SEP)), i=0; p && *p != '\0';
	     (p = strsep(&sp, SEP)), i++) {
		if (i < MAX_PROP)
			sproposals[i] = p;
		else
			break;
	}
	nproposals = i;

	for ((p = strsep(&cp, SEP)), i=0; p && *p != '\0';
	     (p = strsep(&cp, SEP)), i++) {
		for (j = 0; j < nproposals; j++) {
			if (strcmp(p, sproposals[j]) == 0) {
				ret = xstrdup(p);
				xfree(c);
				xfree(s);
				return ret;
			}
		}
	}
	xfree(c);
	xfree(s);
	return NULL;
}
d379 1
a379 1
	char *name = get_match(client, server);
d393 1
a393 1
	char *name = get_match(client, server);
d408 1
a408 1
	char *name = get_match(client, server);
d423 1
a423 1
	k->name = get_match(client, server);
d436 1
a436 1
	char *hostkeyalg = get_match(client, server);
d489 1
@


1.21
log
@1) clean up the MAC support for SSH-2
2) allow you to specify the MAC with 'ssh -m'
3) or the 'MACs' keyword in ssh(d)_config
4) add hmac-{md5,sha1}-96
	ok stevesk@@, provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.20 2001/02/08 19:30:51 itojun Exp $");
d141 1
a141 1
dh_gen_key(DH *dh)
d143 1
a143 1
	int tries = 0;
d145 5
d151 8
d161 5
d167 1
a167 1
			fatal("dh_new_group1: too many bad keys: giving up");
@


1.20
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.19 2001/02/04 15:32:23 stevesk Exp $");
d44 1
d416 1
a416 7
	if (strcmp(name, "hmac-md5") == 0) {
		mac->md = EVP_md5();
	} else if (strcmp(name, "hmac-sha1") == 0) {
		mac->md = EVP_sha1();
	} else if (strcmp(name, "hmac-ripemd160@@openssh.com") == 0) {
		mac->md = EVP_ripemd160();
	} else {
d418 3
a420 1
	}
a421 2
	mac->mac_len = mac->md->md_size;
	mac->key_len = (datafellows & SSH_BUG_HMAC) ? 16 : mac->mac_len;
@


1.19
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.18 2001/01/21 19:05:49 markus Exp $");
d203 1
d215 1
@


1.18
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.17 2001/01/08 21:48:17 markus Exp $");
d82 1
a82 1
	packet_put_raw(buffer_ptr(my_kexinit), buffer_len(my_kexinit));	
d247 1
a247 1
	
d300 1
a300 1
	
d369 1
a369 1
	for ((p = strsep(&sp, SEP)), i=0; p && *p != '\0'; 
d378 1
a378 1
	for ((p = strsep(&cp, SEP)), i=0; p && *p != '\0'; 
@


1.17
log
@missing free; thanks stevesk@@pobox.com
@
text
@d26 7
a32 1
RCSID("$OpenBSD: kex.c,v 1.16 2000/12/20 19:37:22 markus Exp $");
a33 1
#include "ssh.h"
d40 1
a40 10

#include <openssl/bn.h>
#include <openssl/dh.h>

#include <openssl/crypto.h>
#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/dh.h>
#include <openssl/pem.h>

d43 1
@


1.16
log
@fix prototypes; from  stevesk@@pobox.com
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.15 2000/12/19 23:17:56 markus Exp $");
d468 1
@


1.15
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.14 2000/12/15 17:30:14 provos Exp $");
d193 1
a193 1
dh_new_group1()
@


1.14
log
@compute diffie-hellman in parallel between server and client. okay markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.13 2000/11/12 19:50:37 markus Exp $");
d54 1
a54 1
	unsigned char cookie[KEX_COOKIE_LEN];
d207 1
a207 1
dump_digest(unsigned char *digest, int len)
d218 1
a218 1
unsigned char *
d230 1
a230 1
	static unsigned char digest[EVP_MAX_MD_SIZE];
d267 1
a267 1
unsigned char *
d280 1
a280 1
	static unsigned char digest[EVP_MAX_MD_SIZE];
d320 2
a321 2
unsigned char *
derive_key(int id, int need, char unsigned *hash, BIGNUM *shared_secret)
d329 1
a329 1
	unsigned char *digest = xmalloc(((need+mdsz-1)/mdsz)*mdsz);
d515 1
a515 1
kex_derive_keys(Kex *k, unsigned char *hash, BIGNUM *shared_secret)
d520 1
a520 1
	unsigned char *keys[NKEYS];
@


1.13
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.12 2000/10/11 20:27:23 markus Exp $");
d142 1
a142 1
DH *
a152 1
	return dh;
d170 1
a170 1
	return (dh_gen_key(dh));
d173 5
d189 1
a189 1
	return (dh_gen_key(dh));
@


1.12
log
@new cipher framework
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.11 2000/10/11 04:02:17 provos Exp $");
d46 1
d458 2
a459 2
	k->hostkeyalg = get_match(client, server);
	if (k->hostkeyalg == NULL)
d461 3
a463 2
	if (strcmp(k->hostkeyalg, KEX_DSS) != 0)
		fatal("bad hostkey alg %s", k->hostkeyalg);
@


1.12.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d26 12
a37 1
RCSID("$OpenBSD: kex.c,v 1.21 2001/02/11 12:59:24 markus Exp $");
a44 7
#include "ssh2.h"
#include "xmalloc.h"
#include "buffer.h"
#include "bufaux.h"
#include "packet.h"
#include "compat.h"
#include "cipher.h"
a45 3
#include "key.h"
#include "log.h"
#include "mac.h"
d53 1
a53 1
	u_char cookie[KEX_COOKIE_LEN];
d84 1
a84 1
	packet_put_raw(buffer_ptr(my_kexinit), buffer_len(my_kexinit));
d141 1
a141 1
void
d152 1
d170 1
a170 1
	return (dh);
a172 5
/*
 * This just returns the group, we still need to generate the exchange
 * value.
 */

d184 1
a184 1
	return (dh);
d188 1
a188 1
dh_new_group1(void)
a200 1
#ifdef DEBUG_KEX
d202 1
a202 1
dump_digest(u_char *digest, int len)
a211 1
#endif
d213 1
a213 1
u_char *
d225 1
a225 1
	static u_char digest[EVP_MAX_MD_SIZE];
d245 1
a245 1

d262 1
a262 1
u_char *
d275 1
a275 1
	static u_char digest[EVP_MAX_MD_SIZE];
d298 1
a298 1

d315 2
a316 2
u_char *
derive_key(int id, int need, u_char *hash, BIGNUM *shared_secret)
d324 1
a324 1
	u_char *digest = xmalloc(((need+mdsz-1)/mdsz)*mdsz);
d367 1
a367 1
	for ((p = strsep(&sp, SEP)), i=0; p && *p != '\0';
d376 1
a376 1
	for ((p = strsep(&cp, SEP)), i=0; p && *p != '\0';
d411 7
a417 1
	if (mac_init(mac, name) < 0)
d419 1
a419 3
	/* truncate the key */
	if (datafellows & SSH_BUG_HMAC)
		mac->key_len = 16;
d421 2
d457 2
a458 2
	char *hostkeyalg = get_match(client, server);
	if (hostkeyalg == NULL)
d460 2
a461 4
	k->hostkey_type = key_type_from_name(hostkeyalg);
	if (k->hostkey_type == KEY_UNSPEC)
		fatal("bad hostkey alg '%s'", hostkeyalg);
	xfree(hostkeyalg);
d509 1
a509 1
kex_derive_keys(Kex *k, u_char *hash, BIGNUM *shared_secret)
d514 1
a514 1
	u_char *keys[NKEYS];
@


1.12.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.12.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.23 2001/03/10 17:51:04 markus Exp $");
a44 1
#include "match.h"
d141 1
a141 1
dh_gen_key(DH *dh, int need)
d143 1
a143 1
	int i, bits_set = 0, tries = 0;
a144 5
	if (dh->p == NULL)
		fatal("dh_gen_key: dh->p == NULL");
	if (2*need >= BN_num_bits(dh->p))
		fatal("dh_gen_key: group too small: %d (2*need %d)",
		    BN_num_bits(dh->p), 2*need);
a145 8
		if (dh->priv_key != NULL)
			BN_free(dh->priv_key);
		dh->priv_key = BN_new();
		if (dh->priv_key == NULL)
			fatal("dh_gen_key: BN_new failed");
		/* generate a 2*need bits random private exponent */
		if (!BN_rand(dh->priv_key, 2*need, 0, 0))
			fatal("dh_gen_key: BN_rand failed");
a147 5
		for (i = 0; i <= BN_num_bits(dh->priv_key); i++)
			if (BN_is_bit_set(dh->priv_key, i))
				bits_set++;
		debug("dh_gen_key: priv key bits set: %d/%d",
		    bits_set, BN_num_bits(dh->priv_key));
d149 1
a149 1
			fatal("dh_gen_key: too many bad keys: giving up");
d357 39
d399 1
a399 1
	char *name = match_list(client, server, NULL);
d413 1
a413 1
	char *name = match_list(client, server, NULL);
d428 1
a428 1
	char *name = match_list(client, server, NULL);
d443 1
a443 1
	k->name = match_list(client, server, NULL);
d456 1
a456 1
	char *hostkeyalg = match_list(client, server, NULL);
a508 1
#define NKEYS	6
@


1.12.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.33 2001/04/05 10:42:50 markus Exp $");
d29 4
a45 1
#include "dispatch.h"
d49 2
a50 6
void	kex_kexinit_finish(Kex *kex);
void	kex_choose_conf(Kex *k);

/* put algorithm proposal into buffer */
void
kex_prop2buf(Buffer *b, char *proposal[PROPOSAL_MAX])
d52 2
d56 1
a56 2

	buffer_clear(b);
d60 1
a60 1
		buffer_put_char(b, rand & 0xff);
d63 2
d66 4
a69 3
		buffer_put_cstring(b, proposal[i]);
	buffer_put_char(b, 0);			/* first_kex_packet_follows */
	buffer_put_int(b, 0);			/* uint32 reserved */
d72 5
a76 3
/* parse buffer and return algorithm proposal */
char **
kex_buf2prop(Buffer *raw)
a77 1
	Buffer b;
d79 2
a80 1
	char **proposal;
d82 6
a87 1
	proposal = xmalloc(PROPOSAL_MAX * sizeof(char *));
d89 10
a98 2
	buffer_init(&b);
	buffer_append(&b, buffer_ptr(raw), buffer_len(raw));
d101 1
a101 1
		buffer_get_char(&b);
d104 2
a105 2
		proposal[i] = buffer_get_string(&b,NULL);
		debug2("kex_parse_kexinit: %s", proposal[i]);
d107 7
a113 7
	/* first kex follows / reserved */
	i = buffer_get_char(&b);
	debug2("kex_parse_kexinit: first_kex_follows %d ", i);
	i = buffer_get_int(&b);
	debug2("kex_parse_kexinit: reserved %d ", i);
	buffer_free(&b);
	return proposal;
d116 4
a119 2
void
kex_prop_free(char **proposal)
d122 97
d220 1
a220 3
	for (i = 0; i < PROPOSAL_MAX; i++)
		xfree(proposal[i]);
	xfree(proposal);
d223 1
d225 1
a225 1
kex_protocol_error(int type, int plen, void *ctxt)
d227 7
a233 1
	error("Hm, kex protocol error: type %d plen %d", type, plen);
d235 1
d237 10
a246 2
void
kex_clear_dispatch(void)
d248 4
a251 1
	int i;
d253 3
a255 4
	/* Numbers 30-49 are used for kex packets */
	for (i = 30; i <= 49; i++)
		dispatch_set(i, &kex_protocol_error);
}
d257 12
a268 4
void
kex_finish(Kex *kex)
{
	int plen;
d270 3
a272 1
	kex_clear_dispatch();
d274 3
a276 4
	packet_start(SSH2_MSG_NEWKEYS);
	packet_send();
	/* packet_write_wait(); */
	debug("SSH2_MSG_NEWKEYS sent");
d278 1
a278 11
	debug("waiting for SSH2_MSG_NEWKEYS");
	packet_read_expect(&plen, SSH2_MSG_NEWKEYS);
	debug("SSH2_MSG_NEWKEYS received");

	kex->done = 1;
	buffer_clear(&kex->peer);
	/* buffer_clear(&kex->my); */
	kex->flags &= ~KEX_INIT_SENT;
	xfree(kex->name);
	kex->name = NULL;
}
d280 4
a283 17
void
kex_send_kexinit(Kex *kex)
{
	if (kex == NULL) {
		error("kex_send_kexinit: no kex, cannot rekey");
		return;
	}
	if (kex->flags & KEX_INIT_SENT) {
		debug("KEX_INIT_SENT");
		return;
	}
	kex->done = 0;
	packet_start(SSH2_MSG_KEXINIT);
	packet_put_raw(buffer_ptr(&kex->my), buffer_len(&kex->my));
	packet_send();
	debug("SSH2_MSG_KEXINIT sent");
	kex->flags |= KEX_INIT_SENT;
d286 11
a296 2
void
kex_input_kexinit(int type, int plen, void *ctxt)
d298 4
a301 4
	char *ptr;
	int dlen;
	int i;
	Kex *kex = (Kex *)ctxt;
d303 3
a305 3
	debug("SSH2_MSG_KEXINIT received");
	if (kex == NULL)
		fatal("kex_input_kexinit: no kex, cannot rekey");
d307 15
a321 2
	ptr = packet_get_raw(&dlen);
	buffer_append(&kex->peer, ptr, dlen);
d323 3
a325 8
	/* discard packet */
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		packet_get_char();
	for (i = 0; i < PROPOSAL_MAX; i++)
		xfree(packet_get_string(NULL));
	packet_get_char();
	packet_get_int();
	packet_done();
d327 3
a329 2
	kex_kexinit_finish(kex);
}
d331 1
a331 4
Kex *
kex_setup(char *proposal[PROPOSAL_MAX])
{
	Kex *kex;
d333 4
a336 12
	kex = xmalloc(sizeof(*kex));
	memset(kex, 0, sizeof(*kex));
	buffer_init(&kex->peer);
	buffer_init(&kex->my);
	kex_prop2buf(&kex->my, proposal);
	kex->done = 0;

	kex_send_kexinit(kex);					/* we start */
	kex_clear_dispatch();
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);

	return kex;
d339 2
a340 2
void
kex_kexinit_finish(Kex *kex)
d342 7
a348 2
	if (!(kex->flags & KEX_INIT_SENT))
		kex_send_kexinit(kex);
d350 2
a351 1
	kex_choose_conf(kex);
d353 14
a366 9
	switch(kex->kex_type) {
	case DH_GRP1_SHA1:
		kexdh(kex);
		break;
	case DH_GEX_SHA1:
		kexgex(kex);
		break;
	default:
		fatal("Unsupported key exchange %d", kex->kex_type);
d368 6
d445 2
a446 2
void
kex_choose_conf(Kex *kex)
a447 4
	Newkeys *newkeys;
	char **my, **peer;
	char **cprop, **sprop;
	int nenc, nmac, ncomp;
d451 1
d453 3
a455 2
	my   = kex_buf2prop(&kex->my);
	peer = kex_buf2prop(&kex->peer);
a456 9
	if (kex->server) {
		cprop=peer;
		sprop=my;
	} else {
		cprop=my;
		sprop=peer;
	}

	/* Algorithm Negotiation */
d458 2
a459 4
		newkeys = xmalloc(sizeof(*newkeys));
		memset(newkeys, 0, sizeof(*newkeys));
		kex->newkeys[mode] = newkeys;
		ctos = (!kex->server && mode == MODE_OUT) || (kex->server && mode == MODE_IN);
d463 3
a465 3
		choose_enc (&newkeys->enc,  cprop[nenc],  sprop[nenc]);
		choose_mac (&newkeys->mac,  cprop[nmac],  sprop[nmac]);
		choose_comp(&newkeys->comp, cprop[ncomp], sprop[ncomp]);
d468 3
a470 3
		    newkeys->enc.name,
		    newkeys->mac.name,
		    newkeys->comp.name);
d472 2
a473 2
	choose_kex(kex, cprop[PROPOSAL_KEX_ALGS], sprop[PROPOSAL_KEX_ALGS]);
	choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],
d477 6
a482 7
		newkeys = kex->newkeys[mode];
		if (need < newkeys->enc.cipher->key_len)
			need = newkeys->enc.cipher->key_len;
		if (need < newkeys->enc.cipher->block_size)
			need = newkeys->enc.cipher->block_size;
		if (need < newkeys->mac.key_len)
			need = newkeys->mac.key_len;
d485 2
a486 4
	kex->we_need = need;

	kex_prop_free(my);
	kex_prop_free(peer);
a488 44
u_char *
derive_key(Kex *kex, int id, int need, u_char *hash, BIGNUM *shared_secret)
{
	Buffer b;
	EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
	char c = id;
	int have;
	int mdsz = evp_md->md_size;
	u_char *digest = xmalloc(roundup(need, mdsz));

	buffer_init(&b);
	buffer_put_bignum2(&b, shared_secret);

	/* K1 = HASH(K || H || "A" || session_id) */
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
	EVP_DigestUpdate(&md, hash, mdsz);
	EVP_DigestUpdate(&md, &c, 1);
	EVP_DigestUpdate(&md, kex->session_id, kex->session_id_len);
	EVP_DigestFinal(&md, digest, NULL);

	/*
	 * expand key:
	 * Kn = HASH(K || H || K1 || K2 || ... || Kn-1)
	 * Key = K1 || K2 || ... || Kn
	 */
	for (have = mdsz; need > have; have += mdsz) {
		EVP_DigestInit(&md, evp_md);
		EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
		EVP_DigestUpdate(&md, hash, mdsz);
		EVP_DigestUpdate(&md, digest, have);
		EVP_DigestFinal(&md, digest + have, NULL);
	}
	buffer_free(&b);
#ifdef DEBUG_KEX
	fprintf(stderr, "key '%c'== ", c);
	dump_digest("key", digest, need);
#endif
	return digest;
}

Newkeys *current_keys[MODE_MAX];

d490 2
a491 2
void
kex_derive_keys(Kex *kex, u_char *hash, BIGNUM *shared_secret)
d493 3
a496 1
	int i, mode, ctos;
d499 1
a499 1
		keys[i] = derive_key(kex, 'A'+i, kex->we_need, hash, shared_secret);
a500 1
	debug("kex_derive_keys");
d502 4
a505 32
		current_keys[mode] = kex->newkeys[mode];
		kex->newkeys[mode] = NULL;
		ctos = (!kex->server && mode == MODE_OUT) || (kex->server && mode == MODE_IN);
		current_keys[mode]->enc.iv  = keys[ctos ? 0 : 1];
		current_keys[mode]->enc.key = keys[ctos ? 2 : 3];
		current_keys[mode]->mac.key = keys[ctos ? 4 : 5];
	}
}

Newkeys *
kex_get_newkeys(int mode)
{
	Newkeys *ret;

	ret = current_keys[mode];
	current_keys[mode] = NULL;
	return ret;
}

#if defined(DEBUG_KEX) || defined(DEBUG_KEXDH)
void
dump_digest(char *msg, u_char *digest, int len)
{
	int i;

	fprintf(stderr, "%s\n", msg);
	for (i = 0; i< len; i++){
		fprintf(stderr, "%02x", digest[i]);
		if (i%32 == 31)
			fprintf(stderr, "\n");
		else if (i%8 == 7)
			fprintf(stderr, " ");
d507 1
a507 1
	fprintf(stderr, "\n");
a508 1
#endif
@


1.12.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.36 2001/06/25 08:25:37 markus Exp $");
d46 2
a47 3
/* prototype */
static void kex_kexinit_finish(Kex *);
static void kex_choose_conf(Kex *);
d50 1
a50 1
static void
d70 1
a70 1
static char **
d98 1
a98 1
static void
d108 1
a108 1
static void
d114 1
a114 1
static void
d213 1
a213 1
static void
d233 1
a233 1
static void
d247 1
a247 1
static void
d262 1
a262 1
static void
d277 1
a277 1
static void
d290 1
a290 1
static void
d302 1
a302 1
static void
d362 1
a362 1
static u_char *
d378 1
a378 2
	if (!(datafellows & SSH_BUG_DERIVEKEY))
		EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
d391 1
a391 2
		if (!(datafellows & SSH_BUG_DERIVEKEY))
			EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
@


1.12.2.6
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.47 2002/02/28 15:46:33 markus Exp $");
d110 1
a110 1
kex_protocol_error(int type, u_int32_t seq, void *ctxt)
d112 1
a112 1
	error("Hm, kex protocol error: type %d seq %u", type, seq);
d116 1
a116 1
kex_reset_dispatch(void)
d118 5
a122 3
	dispatch_range(SSH2_MSG_TRANSPORT_MIN,
	    SSH2_MSG_TRANSPORT_MAX, &kex_protocol_error);
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);
d128 3
a130 1
	kex_reset_dispatch();
d138 1
a138 2
	packet_read_expect(SSH2_MSG_NEWKEYS);
	packet_check_eom();
d169 1
a169 1
kex_input_kexinit(int type, u_int32_t seq, void *ctxt)
d190 1
a190 1
	packet_check_eom();
d208 2
a209 1
	kex_reset_dispatch();
d222 1
a222 1
	switch (kex->kex_type) {
d240 2
a241 1
	if ((enc->cipher = cipher_by_name(name)) == NULL)
a246 2
	enc->key_len = cipher_keylen(enc->cipher);
	enc->block_size = cipher_blocksize(enc->cipher);
d349 4
a352 4
		if (need < newkeys->enc.key_len)
			need = newkeys->enc.key_len;
		if (need < newkeys->enc.block_size)
			need = newkeys->enc.block_size;
d367 1
a367 1
	const EVP_MD *evp_md = EVP_sha1();
d371 1
a371 1
	int mdsz = EVP_MD_size(evp_md);
d447 1
a447 1
	for (i = 0; i< len; i++) {
@


1.11
log
@First rough implementation of the diffie-hellman group exchange.  The
client can ask the server for bigger groups to perform the diffie-hellman
in, thus increasing the attack complexity when using ciphers with longer
keys.  University of Windsor provided network, T the company.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.10 2000/09/07 20:27:51 deraadt Exp $");
a33 1
#include "cipher.h"
d397 3
a399 22
	enc->type = cipher_number(name);

	switch (enc->type) {
	case SSH_CIPHER_3DES_CBC:
		enc->key_len = 24;
		enc->iv_len = 8;
		enc->block_size = 8;
		break;
	case SSH_CIPHER_BLOWFISH_CBC:
	case SSH_CIPHER_CAST128_CBC:
		enc->key_len = 16;
		enc->iv_len = 8;
		enc->block_size = 8;
		break;
	case SSH_CIPHER_ARCFOUR:
		enc->key_len = 16;
		enc->iv_len = 0;
		enc->block_size = 8;
		break;
	default:
		fatal("unsupported cipher %s", name);
	}
d496 4
a499 4
	    if (need < k->enc[mode].key_len)
		    need = k->enc[mode].key_len;
	    if (need < k->enc[mode].iv_len)
		    need = k->enc[mode].iv_len;
@


1.10
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.9 2000/07/10 16:30:25 ho Exp $");
a125 5
	/* we only accept g==2 */
	if (!BN_is_word(dh->g, 2)) {
		log("invalid DH base != 2");
		return 0;
	}
d143 46
d191 1
a191 1
	static char *group1 =
d198 2
a199 19
	DH *dh;
	int ret, tries = 0;
	dh = DH_new();
	if(dh == NULL)
		fatal("DH_new");
	ret = BN_hex2bn(&dh->p, group1);
	if(ret<0)
		fatal("BN_hex2bn");
	dh->g = BN_new();
	if(dh->g == NULL)
		fatal("DH_new g");
	BN_set_word(dh->g, 2);
	do {
		if (DH_generate_key(dh) == 0)
			fatal("DH_generate_key");
		if (tries++ > 10)
			fatal("dh_new_group1: too many bad keys: giving up");
	} while (!dh_pub_is_valid(dh, dh->pub_key));
	return dh;
d264 53
d467 5
a471 1
	if (strcmp(k->name, KEX_DH1) != 0)
@


1.9
log
@strtok() --> strsep(). (niels@@ ok)
@
text
@a11 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Markus Friedl.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.8 2000/06/20 01:39:41 markus Exp $");
@


1.8
log
@OpenBSD tag
@
text
@d31 1
a31 1
RCSID("$OpenBSD: kex.c,v 1.7 2000/05/25 20:45:20 markus Exp $");
d290 1
a290 1
	char *c, *s, *p, *ret;
d293 2
a294 2
	c = xstrdup(client);
	s = xstrdup(server);
d296 2
a297 1
	for ((p = strtok(s, SEP)), i=0; p; (p = strtok(NULL, SEP)), i++) {
d305 2
a306 1
	for ((p = strtok(c, SEP)), i=0; p; (p = strtok(NULL, SEP)), i++) {
@


1.7
log
@split kexinit/kexdh, factor out common code
@
text
@d31 1
a31 1
RCSID("$Id: kex.c,v 1.6 2000/05/08 17:42:25 markus Exp $");
@


1.6
log
@bug compat w/ ssh-2.0.13 x11, split out bugs
@
text
@d31 1
a31 1
RCSID("$Id: kex.c,v 1.5 2000/04/14 10:30:31 markus Exp $");
d38 1
d53 2
d58 2
a59 2
	char c = 0;
	unsigned char cookie[16];
d63 1
a63 1
	for (i = 0; i < 16; i++) {
d73 2
a74 2
	buffer_append(ki, &c, 1); /* boolean   first_kex_packet_follows */
	buffer_put_int(ki, 0);    /* uint32    0 (reserved for future extension) */
d78 44
a183 6
bignum_print(BIGNUM *b)
{
	BN_print_fp(stderr,b);
}

void
d290 1
a290 1
	char *p;
d293 4
a296 1
	for ((p = strtok(server, SEP)), i=0; p; (p = strtok(NULL, SEP)), i++) {
d304 9
a312 4
	for ((p = strtok(client, SEP)), i=0; p; (p = strtok(NULL, SEP)), i++) {
		for (j = 0; j < nproposals; j++)
			if (strcmp(p, sproposals[j]) == 0)
				return xstrdup(p);
d314 2
a408 1
	int i;
a435 4
	for (i = 0; i < PROPOSAL_MAX; i++) {
		xfree(cprop[i]);
		xfree(sprop[i]);
	}
d445 1
a445 3
	/* need runden? */
#define WE_NEED 32
	k->we_need = WE_NEED;
@


1.6.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d31 1
a31 1
RCSID("$Id: kex.c,v 1.7 2000/05/25 20:45:20 markus Exp $");
a37 1
#include "packet.h"
a51 2
#define KEX_COOKIE_LEN	16

d55 2
a56 2
	int first_kex_packet_follows = 0;
	unsigned char cookie[KEX_COOKIE_LEN];
d60 1
a60 1
	for (i = 0; i < KEX_COOKIE_LEN; i++) {
d70 2
a71 2
	buffer_put_char(ki, first_kex_packet_follows);
	buffer_put_int(ki, 0);				/* uint32 reserved */
a74 44
/* send kexinit, parse and save reply */
void
kex_exchange_kexinit(
    Buffer *my_kexinit, Buffer *peer_kexint,
    char *peer_proposal[PROPOSAL_MAX])
{
	int i;
	char *ptr;
	int plen;

	debug("send KEXINIT");
	packet_start(SSH2_MSG_KEXINIT);
	packet_put_raw(buffer_ptr(my_kexinit), buffer_len(my_kexinit));	
	packet_send();
	packet_write_wait();
	debug("done");

	/*
	 * read and save raw KEXINIT payload in buffer. this is used during
	 * computation of the session_id and the session keys.
	 */
	debug("wait KEXINIT");
	packet_read_expect(&plen, SSH2_MSG_KEXINIT);
	ptr = packet_get_raw(&plen);
	buffer_append(peer_kexint, ptr, plen);

	/* parse packet and save algorithm proposal */
	/* skip cookie */
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		packet_get_char();
	/* extract kex init proposal strings */
	for (i = 0; i < PROPOSAL_MAX; i++) {
		peer_proposal[i] = packet_get_string(NULL);
		debug("got kexinit: %s", peer_proposal[i]);
	}
	/* first kex follow / reserved */
	i = packet_get_char();
	debug("first kex follow: %d ", i);
	i = packet_get_int();
	debug("reserved: %d ", i);
	packet_done();
	debug("done");
}

d137 6
d249 1
a249 1
	char *c, *s, *p, *ret;
d252 1
a252 4
	c = xstrdup(client);
	s = xstrdup(server);

	for ((p = strtok(s, SEP)), i=0; p; (p = strtok(NULL, SEP)), i++) {
d260 4
a263 9
	for ((p = strtok(c, SEP)), i=0; p; (p = strtok(NULL, SEP)), i++) {
		for (j = 0; j < nproposals; j++) {
			if (strcmp(p, sproposals[j]) == 0) {
				ret = xstrdup(p);
				xfree(c);
				xfree(s);
				return ret;
			}
		}
a264 2
	xfree(c);
	xfree(s);
d358 1
d386 4
d399 3
a401 1
	/* XXX need runden? */
@


1.6.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d31 1
a31 1
RCSID("$OpenBSD: kex.c,v 1.9 2000/07/10 16:30:25 ho Exp $");
d290 1
a290 1
	char *c, *s, *p, *ret, *cp, *sp;
d293 2
a294 2
	c = cp = xstrdup(client);
	s = sp = xstrdup(server);
d296 1
a296 2
	for ((p = strsep(&sp, SEP)), i=0; p && *p != '\0'; 
	     (p = strsep(&sp, SEP)), i++) {
d304 1
a304 2
	for ((p = strsep(&cp, SEP)), i=0; p && *p != '\0'; 
	     (p = strsep(&cp, SEP)), i++) {
@


1.6.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d12 5
d31 1
a31 1
RCSID("$OpenBSD: kex.c,v 1.12 2000/10/11 20:27:23 markus Exp $");
d39 1
d131 5
d153 1
a153 1
dh_gen_key(DH *dh)
d155 19
a173 2
	int tries = 0;

a182 46
DH *
dh_new_group_asc(const char *gen, const char *modulus)
{
	DH *dh;
	int ret;

	dh = DH_new();
	if (dh == NULL)
		fatal("DH_new");

	if ((ret = BN_hex2bn(&dh->p, modulus)) < 0)
		fatal("BN_hex2bn p");
	if ((ret = BN_hex2bn(&dh->g, gen)) < 0)
		fatal("BN_hex2bn g");

	return (dh_gen_key(dh));
}

DH *
dh_new_group(BIGNUM *gen, BIGNUM *modulus)
{
	DH *dh;

	dh = DH_new();
	if (dh == NULL)
		fatal("DH_new");
	dh->p = modulus;
	dh->g = gen;

	return (dh_gen_key(dh));
}

DH *
dh_new_group1()
{
	static char *gen = "2", *group1 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE65381"
	    "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group1));
}

a244 53
kex_hash_gex(
    char *client_version_string,
    char *server_version_string,
    char *ckexinit, int ckexinitlen,
    char *skexinit, int skexinitlen,
    char *serverhostkeyblob, int sbloblen,
    int minbits, BIGNUM *prime, BIGNUM *gen,
    BIGNUM *client_dh_pub,
    BIGNUM *server_dh_pub,
    BIGNUM *shared_secret)
{
	Buffer b;
	static unsigned char digest[EVP_MAX_MD_SIZE];
	EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;

	buffer_init(&b);
	buffer_put_string(&b, client_version_string, strlen(client_version_string));
	buffer_put_string(&b, server_version_string, strlen(server_version_string));

	/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
	buffer_put_int(&b, ckexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, ckexinit, ckexinitlen);
	buffer_put_int(&b, skexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, skexinit, skexinitlen);

	buffer_put_string(&b, serverhostkeyblob, sbloblen);
	buffer_put_int(&b, minbits);
	buffer_put_bignum2(&b, prime);
	buffer_put_bignum2(&b, gen);
	buffer_put_bignum2(&b, client_dh_pub);
	buffer_put_bignum2(&b, server_dh_pub);
	buffer_put_bignum2(&b, shared_secret);
	
#ifdef DEBUG_KEX
	buffer_dump(&b);
#endif

	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
	EVP_DigestFinal(&md, digest, NULL);

	buffer_free(&b);

#ifdef DEBUG_KEX
	dump_digest(digest, evp_md->md_size);
#endif
	return digest;
}

unsigned char *
d326 22
a347 3
	enc->cipher = cipher_by_name(name);
	if (enc->cipher == NULL)
		fatal("matching cipher is not supported: %s", name);
d395 1
a395 5
	if (strcmp(k->name, KEX_DH1) == 0) {
		k->kex_type = DH_GRP1_SHA1;
	} else if (strcmp(k->name, KEX_DHGEX) == 0) {
		k->kex_type = DH_GEX_SHA1;
	} else
d440 4
a443 4
	    if (need < k->enc[mode].cipher->key_len)
		    need = k->enc[mode].cipher->key_len;
	    if (need < k->enc[mode].cipher->block_size)
		    need = k->enc[mode].cipher->block_size;
@


1.6.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d26 12
a37 1
RCSID("$OpenBSD: kex.c,v 1.21 2001/02/11 12:59:24 markus Exp $");
a44 7
#include "ssh2.h"
#include "xmalloc.h"
#include "buffer.h"
#include "bufaux.h"
#include "packet.h"
#include "compat.h"
#include "cipher.h"
a45 3
#include "key.h"
#include "log.h"
#include "mac.h"
d53 1
a53 1
	u_char cookie[KEX_COOKIE_LEN];
d84 1
a84 1
	packet_put_raw(buffer_ptr(my_kexinit), buffer_len(my_kexinit));
d141 1
a141 1
void
d152 1
d170 1
a170 1
	return (dh);
a172 5
/*
 * This just returns the group, we still need to generate the exchange
 * value.
 */

d184 1
a184 1
	return (dh);
d188 1
a188 1
dh_new_group1(void)
a200 1
#ifdef DEBUG_KEX
d202 1
a202 1
dump_digest(u_char *digest, int len)
a211 1
#endif
d213 1
a213 1
u_char *
d225 1
a225 1
	static u_char digest[EVP_MAX_MD_SIZE];
d245 1
a245 1

d262 1
a262 1
u_char *
d275 1
a275 1
	static u_char digest[EVP_MAX_MD_SIZE];
d298 1
a298 1

d315 2
a316 2
u_char *
derive_key(int id, int need, u_char *hash, BIGNUM *shared_secret)
d324 1
a324 1
	u_char *digest = xmalloc(((need+mdsz-1)/mdsz)*mdsz);
d367 1
a367 1
	for ((p = strsep(&sp, SEP)), i=0; p && *p != '\0';
d376 1
a376 1
	for ((p = strsep(&cp, SEP)), i=0; p && *p != '\0';
d411 7
a417 1
	if (mac_init(mac, name) < 0)
d419 1
a419 3
	/* truncate the key */
	if (datafellows & SSH_BUG_HMAC)
		mac->key_len = 16;
d421 2
d457 2
a458 2
	char *hostkeyalg = get_match(client, server);
	if (hostkeyalg == NULL)
d460 2
a461 4
	k->hostkey_type = key_type_from_name(hostkeyalg);
	if (k->hostkey_type == KEY_UNSPEC)
		fatal("bad hostkey alg '%s'", hostkeyalg);
	xfree(hostkeyalg);
d509 1
a509 1
kex_derive_keys(Kex *k, u_char *hash, BIGNUM *shared_secret)
d514 1
a514 1
	u_char *keys[NKEYS];
@


1.6.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.23 2001/03/10 17:51:04 markus Exp $");
a44 1
#include "match.h"
d141 1
a141 1
dh_gen_key(DH *dh, int need)
d143 1
a143 1
	int i, bits_set = 0, tries = 0;
a144 5
	if (dh->p == NULL)
		fatal("dh_gen_key: dh->p == NULL");
	if (2*need >= BN_num_bits(dh->p))
		fatal("dh_gen_key: group too small: %d (2*need %d)",
		    BN_num_bits(dh->p), 2*need);
a145 8
		if (dh->priv_key != NULL)
			BN_free(dh->priv_key);
		dh->priv_key = BN_new();
		if (dh->priv_key == NULL)
			fatal("dh_gen_key: BN_new failed");
		/* generate a 2*need bits random private exponent */
		if (!BN_rand(dh->priv_key, 2*need, 0, 0))
			fatal("dh_gen_key: BN_rand failed");
a147 5
		for (i = 0; i <= BN_num_bits(dh->priv_key); i++)
			if (BN_is_bit_set(dh->priv_key, i))
				bits_set++;
		debug("dh_gen_key: priv key bits set: %d/%d",
		    bits_set, BN_num_bits(dh->priv_key));
d149 1
a149 1
			fatal("dh_gen_key: too many bad keys: giving up");
d357 39
d399 1
a399 1
	char *name = match_list(client, server, NULL);
d413 1
a413 1
	char *name = match_list(client, server, NULL);
d428 1
a428 1
	char *name = match_list(client, server, NULL);
d443 1
a443 1
	k->name = match_list(client, server, NULL);
d456 1
a456 1
	char *hostkeyalg = match_list(client, server, NULL);
a508 1
#define NKEYS	6
@


1.5
log
@whitespace cleanup
@
text
@d31 1
a31 1
RCSID("$Id: kex.c,v 1.4 2000/04/12 09:39:10 markus Exp $");
d317 1
a317 1
	mac->key_len = datafellows ? 16 : mac->mac_len;
@


1.4
log
@#include <ssl/foo.h> -> <openssh/foo.h>
@
text
@d31 1
a31 1
RCSID("$Id: kex.c,v 1.3 2000/04/12 07:03:05 markus Exp $");
d146 2
a147 2
        for (i = 0; i< len; i++){
                fprintf(stderr, "%02x", digest[i]);
d151 1
a151 1
        fprintf(stderr, "\n");
d198 1
a198 1
        dump_digest(digest, evp_md->md_size);
d342 1
a342 1
    	if (strcmp(k->name, KEX_DH1) != 0)
@


1.3
log
@check for reasonable public DH values
@
text
@d31 1
a31 1
RCSID("$Id: kex.c,v 1.2 2000/04/12 06:37:02 markus Exp $");
d41 2
a42 2
#include <ssl/bn.h>
#include <ssl/dh.h>
d44 5
a48 5
#include <ssl/crypto.h>
#include <ssl/bio.h>
#include <ssl/bn.h>
#include <ssl/dh.h>
#include <ssl/pem.h>
@


1.2
log
@less debugging output
@
text
@d31 1
a31 1
RCSID("$Id: kex.c,v 1.1 2000/04/03 20:06:15 markus Exp $");
d77 28
d106 1
a106 1
new_dh_group1()
d116 1
a116 1
	int ret;
d120 1
a120 1
	ret = BN_hex2bn(&dh->p,group1);
d126 7
a132 3
	BN_set_word(dh->g,2);
	if (DH_generate_key(dh) == 0)
		fatal("DH_generate_key");
@


1.1
log
@DSA, keyexchange, algorithm agreement for ssh2
@
text
@d31 1
a31 1
RCSID("$Id: kex.c,v 1.17 2000/04/03 18:30:40 markus Exp $");
d345 1
a345 1
		log("kex: %s %s %s %s",
@

