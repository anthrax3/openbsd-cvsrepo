head	1.142;
access;
symbols
	OPENBSD_6_1:1.137.0.4
	OPENBSD_6_1_BASE:1.137
	OPENBSD_6_0:1.136.0.4
	OPENBSD_6_0_BASE:1.136
	OPENBSD_5_9:1.135.0.6
	OPENBSD_5_9_BASE:1.135
	OPENBSD_5_8:1.135.0.4
	OPENBSD_5_8_BASE:1.135
	OPENBSD_5_7:1.135.0.2
	OPENBSD_5_7_BASE:1.135
	OPENBSD_5_6:1.132.0.4
	OPENBSD_5_6_BASE:1.132
	OPENBSD_5_5:1.130.0.4
	OPENBSD_5_5_BASE:1.130
	OPENBSD_5_4:1.129.0.2
	OPENBSD_5_4_BASE:1.129
	OPENBSD_5_3:1.126.0.2
	OPENBSD_5_3_BASE:1.126
	OPENBSD_5_2:1.124.0.4
	OPENBSD_5_2_BASE:1.124
	OPENBSD_5_1_BASE:1.124
	OPENBSD_5_1:1.124.0.2
	OPENBSD_5_0:1.123.0.2
	OPENBSD_5_0_BASE:1.123
	OPENBSD_4_9:1.122.0.2
	OPENBSD_4_9_BASE:1.122
	OPENBSD_4_8:1.121.0.6
	OPENBSD_4_8_BASE:1.121
	OPENBSD_4_7:1.121.0.2
	OPENBSD_4_7_BASE:1.121
	OPENBSD_4_6:1.121.0.4
	OPENBSD_4_6_BASE:1.121
	OPENBSD_4_5:1.120.0.2
	OPENBSD_4_5_BASE:1.120
	OPENBSD_4_4:1.119.0.2
	OPENBSD_4_4_BASE:1.119
	OPENBSD_4_3:1.116.0.2
	OPENBSD_4_3_BASE:1.116
	OPENBSD_4_2:1.115.0.2
	OPENBSD_4_2_BASE:1.115
	OPENBSD_4_1:1.114.0.2
	OPENBSD_4_1_BASE:1.114
	OPENBSD_4_0:1.113.0.4
	OPENBSD_4_0_BASE:1.113
	OPENBSD_3_9:1.107.0.8
	OPENBSD_3_9_BASE:1.107
	OPENBSD_3_8:1.107.0.6
	OPENBSD_3_8_BASE:1.107
	OPENBSD_3_7:1.107.0.4
	OPENBSD_3_7_BASE:1.107
	OPENBSD_3_6:1.107.0.2
	OPENBSD_3_6_BASE:1.107
	OPENBSD_3_5:1.104.0.2
	OPENBSD_3_5_BASE:1.104
	OPENBSD_3_4:1.102.0.2
	OPENBSD_3_4_BASE:1.102
	OPENBSD_3_3:1.96.0.2
	OPENBSD_3_3_BASE:1.96
	OPENBSD_3_2:1.95.0.2
	OPENBSD_3_2_BASE:1.95
	OPENBSD_3_1:1.89.0.2
	OPENBSD_3_1_BASE:1.89
	OPENBSD_3_0:1.71.0.2
	OPENBSD_3_0_BASE:1.71
	OPENBSD_2_9_BASE:1.56
	OPENBSD_2_9:1.56.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.142
date	2017.05.31.07.00.13;	author markus;	state Exp;
branches;
next	1.141;
commitid	X93t1IqdA6G5YFwi;

1.141
date	2017.05.31.05.34.14;	author markus;	state Exp;
branches;
next	1.140;
commitid	w1hZJnjhoKj6wzty;

1.140
date	2017.05.30.14.29.59;	author markus;	state Exp;
branches;
next	1.139;
commitid	J58my16e4a8Rltt1;

1.139
date	2017.05.30.14.23.52;	author markus;	state Exp;
branches;
next	1.138;
commitid	tEOGxoM4kvBMLD6J;

1.138
date	2017.05.30.14.18.15;	author markus;	state Exp;
branches;
next	1.137;
commitid	WzNNZXNcMAmgkxwG;

1.137
date	2017.02.03.23.05.57;	author djm;	state Exp;
branches;
next	1.136;
commitid	qKya5c8dDE67faev;

1.136
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.135;
commitid	RYYIr1bk0phq4fXa;

1.135
date	2015.01.19.20.07.45;	author markus;	state Exp;
branches;
next	1.134;
commitid	GrtSC5ve2VERgUln;

1.134
date	2014.12.22.07.55.51;	author djm;	state Exp;
branches;
next	1.133;
commitid	Obssn4758PtR7Red;

1.133
date	2014.12.18.23.58.04;	author djm;	state Exp;
branches;
next	1.132;
commitid	Poc9D65SbPQLYYoy;

1.132
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.131;
commitid	z7plx8Gkj6l2sxem;

1.131
date	2014.07.03.11.16.55;	author djm;	state Exp;
branches;
next	1.130;
commitid	qUeYjXdfTNrKthSc;

1.130
date	2014.01.29.06.18.35;	author djm;	state Exp;
branches;
next	1.129;

1.129
date	2013.05.19.02.42.42;	author djm;	state Exp;
branches;
next	1.128;

1.128
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.127;

1.127
date	2013.03.07.19.27.25;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2012.12.02.20.34.09;	author djm;	state Exp;
branches;
next	1.125;

1.125
date	2012.11.04.11.09.15;	author djm;	state Exp;
branches;
next	1.124;

1.124
date	2011.12.07.05.44.38;	author djm;	state Exp;
branches;
next	1.123;

1.123
date	2011.03.10.02.52.57;	author djm;	state Exp;
branches;
next	1.122;

1.122
date	2010.08.31.09.58.37;	author djm;	state Exp;
branches;
next	1.121;

1.121
date	2009.06.22.05.39.28;	author dtucker;	state Exp;
branches;
next	1.120;

1.120
date	2008.11.04.08.22.12;	author djm;	state Exp;
branches;
next	1.119;

1.119
date	2008.07.04.23.30.16;	author djm;	state Exp;
branches;
next	1.118;

1.118
date	2008.07.02.13.30.34;	author djm;	state Exp;
branches;
next	1.117;

1.117
date	2008.07.02.12.36.39;	author djm;	state Exp;
branches;
next	1.116;

1.116
date	2007.09.29.00.25.51;	author dtucker;	state Exp;
branches;
next	1.115;

1.115
date	2007.04.14.22.01.58;	author stevesk;	state Exp;
branches;
next	1.114;

1.114
date	2007.03.01.10.28.02;	author dtucker;	state Exp;
branches;
next	1.113;

1.113
date	2006.08.03.03.34.41;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2006.07.22.20.48.22;	author stevesk;	state Exp;
branches;
next	1.111;

1.111
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.110;

1.110
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.109;

1.109
date	2006.03.20.18.17.20;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2004.07.28.09.40.29;	author markus;	state Exp;
branches
	1.107.6.1
	1.107.8.1;
next	1.106;

1.106
date	2004.07.21.10.33.31;	author djm;	state Exp;
branches;
next	1.105;

1.105
date	2004.05.23.23.59.53;	author dtucker;	state Exp;
branches;
next	1.104;

1.104
date	2003.11.04.08.54.09;	author djm;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2003.09.23.20.17.11;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2003.08.26.09.58.43;	author markus;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2003.08.22.13.22.27;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2003.08.22.10.56.08;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2003.06.24.08.23.46;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.14.02.15.47;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches;
next	1.96;

1.96
date	2003.02.06.21.22.43;	author markus;	state Exp;
branches
	1.96.2.1;
next	1.95;

1.95
date	2002.08.22.21.33.58;	author markus;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2002.06.30.21.54.16;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2002.05.31.11.35.15;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2002.05.25.18.51.07;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2002.05.13.02.37.39;	author itojun;	state Exp;
branches;
next	1.90;

1.90
date	2002.05.12.23.53.45;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2002.03.19.14.27.39;	author markus;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches;
next	1.87;

1.87
date	2002.03.18.01.12.14;	author provos;	state Exp;
branches;
next	1.86;

1.86
date	2002.03.17.20.25.56;	author provos;	state Exp;
branches;
next	1.85;

1.85
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2002.02.04.11.58.10;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2002.01.29.14.32.03;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2002.01.13.17.57.37;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2002.01.11.13.39.36;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2001.12.18.10.05.15;	author jakob;	state Exp;
branches;
next	1.75;

1.75
date	2001.12.09.18.45.56;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2001.12.05.03.56.39;	author itojun;	state Exp;
branches;
next	1.73;

1.73
date	2001.11.17.19.14.34;	author stevesk;	state Exp;
branches;
next	1.72;

1.72
date	2001.11.07.22.41.51;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2001.09.27.15.31.17;	author markus;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2001.09.20.13.46.48;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2001.07.23.18.14.58;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.26.05.50.11;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.25.20.26.37;	author stevesk;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.23.15.12.17;	author itojun;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.23.03.04.43;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.23.00.20.58;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.22.21.55.49;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2001.06.07.19.57.53;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.31.10.30.12;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2001.05.30.23.31.14;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.30.12.55.06;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.05.20.17.20.35;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.05.18.14.13.28;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.19.00.05.11;	author markus;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2001.04.18.23.43.25;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2001.04.18.22.48.26;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2001.04.18.22.03.44;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2001.04.12.19.15.24;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2001.04.06.21.00.08;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2001.04.04.20.32.56;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.03.28.22.43.31;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.03.21.11.43.44;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.20.18.57.04;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.11.13.25.36;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.04.01.46.29;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.01.02.45.10;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.22.21.59.44;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.13.22.49.40;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.12.16.16.23;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.10.12.52.02;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.08.18.20.01;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.08.18.12.30;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.07.22.35.46;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.04.15.32.22;	author stevesk;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.04.13.30.11;	author stevesk;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.22.23.06.39;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.22.08.32.53;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.21.19.05.44;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2001.01.20.17.34.25;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.01.20.15.55.20;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2001.01.19.15.55.10;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.18.17.00.00;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.13.18.56.48;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.13.18.21.48;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.08.22.29.05;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.28.14.25.51;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.19.23.17.55;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.03.11.15.02;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.12.19.50.37;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.14.12.16.56;	author markus;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.10.11.20.27.23;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.11.20.14.38;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.11.19.59.52;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.27.21.41.34;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.21.11.25.32;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.07.20.27.49;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.20.18.42.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.07.03.55.03;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.19.00.50.11;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.18.04.05.02;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.18.01.09.10;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.08.17.42.24;	author markus;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.05.06.17.45.36;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.05.18.50.57;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.01.23.13.39;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.01.07.45.08;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.27.15.23.02;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.27.08.01.25;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.26.21.28.32;	author markus;	state Exp;
branches;
next	;

1.8.2.1
date	2000.09.01.18.23.17;	author jason;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2000.11.08.21.30.25;	author jason;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.03.12.15.44.08;	author jason;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.03.21.18.52.35;	author jason;	state Exp;
branches;
next	;

1.20.2.1
date	2001.02.16.20.12.54;	author jason;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.02.19.17.18.39;	author jason;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.03.21.19.46.22;	author jason;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2001.05.07.21.09.26;	author jason;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2001.09.27.00.15.41;	author miod;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2001.11.15.00.14.59;	author miod;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.20.2.8;

1.20.2.8
date	2002.03.08.17.04.41;	author brad;	state Exp;
branches;
next	;

1.56.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.56.2.3;

1.56.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.56.2.4;

1.56.2.4
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.56.2.5;

1.56.2.5
date	2002.06.02.22.56.09;	author miod;	state Exp;
branches;
next	;

1.71.2.1
date	2001.11.14.03.24.38;	author jason;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.71.2.3;

1.71.2.3
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	1.71.2.4;

1.71.2.4
date	2002.06.22.07.23.16;	author miod;	state Exp;
branches;
next	1.71.2.5;

1.71.2.5
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.89.2.1
date	2002.05.18.04.12.10;	author jason;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2002.05.18.04.50.37;	author jason;	state Exp;
branches;
next	1.89.2.3;

1.89.2.3
date	2002.06.26.15.30.37;	author jason;	state Exp;
branches;
next	1.89.2.4;

1.89.2.4
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.89.2.5;

1.89.2.5
date	2003.04.03.22.35.16;	author miod;	state Exp;
branches;
next	;

1.95.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.95.2.2;

1.95.2.2
date	2003.09.16.21.20.24;	author brad;	state Exp;
branches;
next	;

1.96.2.1
date	2003.09.16.20.50.42;	author brad;	state Exp;
branches;
next	1.96.2.2;

1.96.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.102.2.1
date	2004.02.28.03.51.32;	author brad;	state Exp;
branches;
next	1.102.2.2;

1.102.2.2
date	2004.08.19.22.37.30;	author brad;	state Exp;
branches;
next	;

1.104.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.107.6.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.107.8.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.142
log
@remove now obsolete ctx from ssh_dispatch_run; ok djm@@
@
text
@/* $OpenBSD: auth2.c,v 1.141 2017/05/31 05:34:14 markus Exp $ */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>

#include <fcntl.h>
#include <pwd.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"
#include "xmalloc.h"
#include "ssh2.h"
#include "packet.h"
#include "log.h"
#include "buffer.h"
#include "misc.h"
#include "servconf.h"
#include "compat.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "dispatch.h"
#include "pathnames.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"

/* import */
extern ServerOptions options;
extern u_char *session_id2;
extern u_int session_id2_len;

/* methods */

extern Authmethod method_none;
extern Authmethod method_pubkey;
extern Authmethod method_passwd;
extern Authmethod method_kbdint;
extern Authmethod method_hostbased;
#ifdef GSSAPI
extern Authmethod method_gssapi;
#endif

Authmethod *authmethods[] = {
	&method_none,
	&method_pubkey,
#ifdef GSSAPI
	&method_gssapi,
#endif
	&method_passwd,
	&method_kbdint,
	&method_hostbased,
	NULL
};

/* protocol */

static int input_service_request(int, u_int32_t, struct ssh *);
static int input_userauth_request(int, u_int32_t, struct ssh *);

/* helper */
static Authmethod *authmethod_lookup(Authctxt *, const char *);
static char *authmethods_get(Authctxt *authctxt);

#define MATCH_NONE	0	/* method or submethod mismatch */
#define MATCH_METHOD	1	/* method matches (no submethod specified) */
#define MATCH_BOTH	2	/* method and submethod match */
#define MATCH_PARTIAL	3	/* method matches, submethod can't be checked */
static int list_starts_with(const char *, const char *, const char *);

char *
auth2_read_banner(void)
{
	struct stat st;
	char *banner = NULL;
	size_t len, n;
	int fd;

	if ((fd = open(options.banner, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) == -1) {
		close(fd);
		return (NULL);
	}
	if (st.st_size <= 0 || st.st_size > 1*1024*1024) {
		close(fd);
		return (NULL);
	}

	len = (size_t)st.st_size;		/* truncate */
	banner = xmalloc(len + 1);
	n = atomicio(read, fd, banner, len);
	close(fd);

	if (n != len) {
		free(banner);
		return (NULL);
	}
	banner[n] = '\0';

	return (banner);
}

static void
userauth_banner(void)
{
	char *banner = NULL;

	if (options.banner == NULL || (datafellows & SSH_BUG_BANNER) != 0)
		return;

	if ((banner = PRIVSEP(auth2_read_banner())) == NULL)
		goto done;

	packet_start(SSH2_MSG_USERAUTH_BANNER);
	packet_put_cstring(banner);
	packet_put_cstring("");		/* language, unused */
	packet_send();
	debug("userauth_banner: sent");
done:
	free(banner);
}

/*
 * loop until authctxt->success == TRUE
 */
void
do_authentication2(Authctxt *authctxt)
{
	struct ssh *ssh = active_state;		/* XXX */
	ssh->authctxt = authctxt;		/* XXX move to caller */
	ssh_dispatch_init(ssh, &dispatch_protocol_error);
	ssh_dispatch_set(ssh, SSH2_MSG_SERVICE_REQUEST, &input_service_request);
	ssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt->success);
	ssh->authctxt = NULL;
}

/*ARGSUSED*/
static int
input_service_request(int type, u_int32_t seq, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	u_int len;
	int acceptit = 0;
	char *service = packet_get_cstring(&len);
	packet_check_eom();

	if (authctxt == NULL)
		fatal("input_service_request: no authctxt");

	if (strcmp(service, "ssh-userauth") == 0) {
		if (!authctxt->success) {
			acceptit = 1;
			/* now we can handle user-auth requests */
			ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &input_userauth_request);
		}
	}
	/* XXX all other service requests are denied */

	if (acceptit) {
		packet_start(SSH2_MSG_SERVICE_ACCEPT);
		packet_put_cstring(service);
		packet_send();
		packet_write_wait();
	} else {
		debug("bad service request %s", service);
		packet_disconnect("bad service request %s", service);
	}
	free(service);
	return 0;
}

/*ARGSUSED*/
static int
input_userauth_request(int type, u_int32_t seq, struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	Authmethod *m = NULL;
	char *user, *service, *method, *style = NULL;
	int authenticated = 0;

	if (authctxt == NULL)
		fatal("input_userauth_request: no authctxt");

	user = packet_get_cstring(NULL);
	service = packet_get_cstring(NULL);
	method = packet_get_cstring(NULL);
	debug("userauth-request for user %s service %s method %s", user, service, method);
	debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);

	if ((style = strchr(user, ':')) != NULL)
		*style++ = 0;

	if (authctxt->attempt++ == 0) {
		/* setup auth context */
		authctxt->pw = PRIVSEP(getpwnamallow(user));
		if (authctxt->pw && strcmp(service, "ssh-connection")==0) {
			authctxt->valid = 1;
			debug2("%s: setting up authctxt for %s",
			    __func__, user);
		} else {
			/* Invalid user, fake password information */
			authctxt->pw = fakepw();
		}
		ssh_packet_set_log_preamble(ssh, "%suser %s",
		    authctxt->valid ? "authenticating " : "invalid ", user);
		setproctitle("%s%s", authctxt->valid ? user : "unknown",
		    use_privsep ? " [net]" : "");
		authctxt->user = xstrdup(user);
		authctxt->service = xstrdup(service);
		authctxt->style = style ? xstrdup(style) : NULL;
		if (use_privsep)
			mm_inform_authserv(service, style);
		userauth_banner();
		if (auth2_setup_methods_lists(authctxt) != 0)
			packet_disconnect("no authentication methods enabled");
	} else if (strcmp(user, authctxt->user) != 0 ||
	    strcmp(service, authctxt->service) != 0) {
		packet_disconnect("Change of username or service not allowed: "
		    "(%s,%s) -> (%s,%s)",
		    authctxt->user, authctxt->service, user, service);
	}
	/* reset state */
	auth2_challenge_stop(ssh);

#ifdef GSSAPI
	/* XXX move to auth2_gssapi_stop() */
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
#endif

	authctxt->postponed = 0;
	authctxt->server_caused_failure = 0;

	/* try to authenticate user */
	m = authmethod_lookup(authctxt, method);
	if (m != NULL && authctxt->failures < options.max_authtries) {
		debug2("input_userauth_request: try method %s", method);
		authenticated =	m->userauth(ssh);
	}
	userauth_finish(ssh, authenticated, method, NULL);

	free(service);
	free(user);
	free(method);
	return 0;
}

void
userauth_finish(struct ssh *ssh, int authenticated, const char *method,
    const char *submethod)
{
	Authctxt *authctxt = ssh->authctxt;
	char *methods;
	int partial = 0;

	if (!authctxt->valid && authenticated)
		fatal("INTERNAL ERROR: authenticated invalid user %s",
		    authctxt->user);
	if (authenticated && authctxt->postponed)
		fatal("INTERNAL ERROR: authenticated and postponed");

	/* Special handling for root */
	if (authenticated && authctxt->pw->pw_uid == 0 &&
	    !auth_root_allowed(method))
		authenticated = 0;

	if (authenticated && options.num_auth_methods != 0) {
		if (!auth2_update_methods_lists(authctxt, method, submethod)) {
			authenticated = 0;
			partial = 1;
		}
	}

	/* Log before sending the reply */
	auth_log(authctxt, authenticated, partial, method, submethod);

	if (authctxt->postponed)
		return;

	if (authenticated == 1) {
		/* turn off userauth */
		ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);
		packet_start(SSH2_MSG_USERAUTH_SUCCESS);
		packet_send();
		packet_write_wait();
		/* now we can break out */
		authctxt->success = 1;
		ssh_packet_set_log_preamble(ssh, "user %s", authctxt->user);
	} else {
		/* Allow initial try of "none" auth without failure penalty */
		if (!partial && !authctxt->server_caused_failure &&
		    (authctxt->attempt > 1 || strcmp(method, "none") != 0))
			authctxt->failures++;
		if (authctxt->failures >= options.max_authtries)
			auth_maxtries_exceeded(authctxt);
		methods = authmethods_get(authctxt);
		debug3("%s: failure partial=%d next methods=\"%s\"", __func__,
		    partial, methods);
		packet_start(SSH2_MSG_USERAUTH_FAILURE);
		packet_put_cstring(methods);
		packet_put_char(partial);
		packet_send();
		packet_write_wait();
		free(methods);
	}
}

/*
 * Checks whether method is allowed by at least one AuthenticationMethods
 * methods list. Returns 1 if allowed, or no methods lists configured.
 * 0 otherwise.
 */
int
auth2_method_allowed(Authctxt *authctxt, const char *method,
    const char *submethod)
{
	u_int i;

	/*
	 * NB. authctxt->num_auth_methods might be zero as a result of
	 * auth2_setup_methods_lists(), so check the configuration.
	 */
	if (options.num_auth_methods == 0)
		return 1;
	for (i = 0; i < authctxt->num_auth_methods; i++) {
		if (list_starts_with(authctxt->auth_methods[i], method,
		    submethod) != MATCH_NONE)
			return 1;
	}
	return 0;
}

static char *
authmethods_get(Authctxt *authctxt)
{
	Buffer b;
	char *list;
	u_int i;

	buffer_init(&b);
	for (i = 0; authmethods[i] != NULL; i++) {
		if (strcmp(authmethods[i]->name, "none") == 0)
			continue;
		if (authmethods[i]->enabled == NULL ||
		    *(authmethods[i]->enabled) == 0)
			continue;
		if (!auth2_method_allowed(authctxt, authmethods[i]->name,
		    NULL))
			continue;
		if (buffer_len(&b) > 0)
			buffer_append(&b, ",", 1);
		buffer_append(&b, authmethods[i]->name,
		    strlen(authmethods[i]->name));
	}
	if ((list = sshbuf_dup_string(&b)) == NULL)
		fatal("%s: sshbuf_dup_string failed", __func__);
	buffer_free(&b);
	return list;
}

static Authmethod *
authmethod_lookup(Authctxt *authctxt, const char *name)
{
	int i;

	if (name != NULL)
		for (i = 0; authmethods[i] != NULL; i++)
			if (authmethods[i]->enabled != NULL &&
			    *(authmethods[i]->enabled) != 0 &&
			    strcmp(name, authmethods[i]->name) == 0 &&
			    auth2_method_allowed(authctxt,
			    authmethods[i]->name, NULL))
				return authmethods[i];
	debug2("Unrecognized authentication method name: %s",
	    name ? name : "NULL");
	return NULL;
}

/*
 * Check a comma-separated list of methods for validity. Is need_enable is
 * non-zero, then also require that the methods are enabled.
 * Returns 0 on success or -1 if the methods list is invalid.
 */
int
auth2_methods_valid(const char *_methods, int need_enable)
{
	char *methods, *omethods, *method, *p;
	u_int i, found;
	int ret = -1;

	if (*_methods == '\0') {
		error("empty authentication method list");
		return -1;
	}
	omethods = methods = xstrdup(_methods);
	while ((method = strsep(&methods, ",")) != NULL) {
		for (found = i = 0; !found && authmethods[i] != NULL; i++) {
			if ((p = strchr(method, ':')) != NULL)
				*p = '\0';
			if (strcmp(method, authmethods[i]->name) != 0)
				continue;
			if (need_enable) {
				if (authmethods[i]->enabled == NULL ||
				    *(authmethods[i]->enabled) == 0) {
					error("Disabled method \"%s\" in "
					    "AuthenticationMethods list \"%s\"",
					    method, _methods);
					goto out;
				}
			}
			found = 1;
			break;
		}
		if (!found) {
			error("Unknown authentication method \"%s\" in list",
			    method);
			goto out;
		}
	}
	ret = 0;
 out:
	free(omethods);
	return ret;
}

/*
 * Prune the AuthenticationMethods supplied in the configuration, removing
 * any methods lists that include disabled methods. Note that this might
 * leave authctxt->num_auth_methods == 0, even when multiple required auth
 * has been requested. For this reason, all tests for whether multiple is
 * enabled should consult options.num_auth_methods directly.
 */
int
auth2_setup_methods_lists(Authctxt *authctxt)
{
	u_int i;

	if (options.num_auth_methods == 0)
		return 0;
	debug3("%s: checking methods", __func__);
	authctxt->auth_methods = xcalloc(options.num_auth_methods,
	    sizeof(*authctxt->auth_methods));
	authctxt->num_auth_methods = 0;
	for (i = 0; i < options.num_auth_methods; i++) {
		if (auth2_methods_valid(options.auth_methods[i], 1) != 0) {
			logit("Authentication methods list \"%s\" contains "
			    "disabled method, skipping",
			    options.auth_methods[i]);
			continue;
		}
		debug("authentication methods list %d: %s",
		    authctxt->num_auth_methods, options.auth_methods[i]);
		authctxt->auth_methods[authctxt->num_auth_methods++] =
		    xstrdup(options.auth_methods[i]);
	}
	if (authctxt->num_auth_methods == 0) {
		error("No AuthenticationMethods left after eliminating "
		    "disabled methods");
		return -1;
	}
	return 0;
}

static int
list_starts_with(const char *methods, const char *method,
    const char *submethod)
{
	size_t l = strlen(method);
	int match;
	const char *p;

	if (strncmp(methods, method, l) != 0)
		return MATCH_NONE;
	p = methods + l;
	match = MATCH_METHOD;
	if (*p == ':') {
		if (!submethod)
			return MATCH_PARTIAL;
		l = strlen(submethod);
		p += 1;
		if (strncmp(submethod, p, l))
			return MATCH_NONE;
		p += l;
		match = MATCH_BOTH;
	}
	if (*p != ',' && *p != '\0')
		return MATCH_NONE;
	return match;
}

/*
 * Remove method from the start of a comma-separated list of methods.
 * Returns 0 if the list of methods did not start with that method or 1
 * if it did.
 */
static int
remove_method(char **methods, const char *method, const char *submethod)
{
	char *omethods = *methods, *p;
	size_t l = strlen(method);
	int match;

	match = list_starts_with(omethods, method, submethod);
	if (match != MATCH_METHOD && match != MATCH_BOTH)
		return 0;
	p = omethods + l;
	if (submethod && match == MATCH_BOTH)
		p += 1 + strlen(submethod); /* include colon */
	if (*p == ',')
		p++;
	*methods = xstrdup(p);
	free(omethods);
	return 1;
}

/*
 * Called after successful authentication. Will remove the successful method
 * from the start of each list in which it occurs. If it was the last method
 * in any list, then authentication is deemed successful.
 * Returns 1 if the method completed any authentication list or 0 otherwise.
 */
int
auth2_update_methods_lists(Authctxt *authctxt, const char *method,
    const char *submethod)
{
	u_int i, found = 0;

	debug3("%s: updating methods list after \"%s\"", __func__, method);
	for (i = 0; i < authctxt->num_auth_methods; i++) {
		if (!remove_method(&(authctxt->auth_methods[i]), method,
		    submethod))
			continue;
		found = 1;
		if (*authctxt->auth_methods[i] == '\0') {
			debug2("authentication methods list %d complete", i);
			return 1;
		}
		debug3("authentication methods list %d remaining: \"%s\"",
		    i, authctxt->auth_methods[i]);
	}
	/* This should not happen, but would be bad if it did */
	if (!found)
		fatal("%s: method not in AuthenticationMethods", __func__);
	return 0;
}


@


1.141
log
@use the ssh_dispatch_run_fatal variant
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.140 2017/05/30 14:29:59 markus Exp $ */
d162 1
a162 1
	ssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt->success, ssh);
@


1.140
log
@switch auth2 to ssh_dispatch API; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.139 2017/05/30 14:23:52 markus Exp $ */
d162 1
a162 1
	ssh_dispatch_run(ssh, DISPATCH_BLOCK, &authctxt->success, ssh);
@


1.139
log
@protocol handlers all get struct ssh passed; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.138 2017/05/30 14:18:15 markus Exp $ */
d160 3
a162 3
	dispatch_init(&dispatch_protocol_error);
	dispatch_set(SSH2_MSG_SERVICE_REQUEST, &input_service_request);
	dispatch_run(DISPATCH_BLOCK, &authctxt->success, ssh);
d183 1
a183 1
			dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &input_userauth_request);
d252 1
a252 1
	auth2_challenge_stop(authctxt);
d256 2
a257 2
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
d267 1
a267 1
		authenticated =	m->userauth(authctxt);
d269 1
a269 1
	userauth_finish(authctxt, authenticated, method, NULL);
d278 1
a278 1
userauth_finish(Authctxt *authctxt, int authenticated, const char *method,
d281 1
a281 1
	struct ssh *ssh = active_state;	/* XXX */
d311 1
a311 1
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);
@


1.138
log
@sshd: pass struct ssh to auth functions; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.137 2017/02/03 23:05:57 djm Exp $ */
d86 2
a87 2
static int input_service_request(int, u_int32_t, void *);
static int input_userauth_request(int, u_int32_t, void *);
d168 1
a168 1
input_service_request(int type, u_int32_t seq, void *ctxt)
a169 1
	struct ssh *ssh = ctxt;
d203 1
a203 1
input_userauth_request(int type, u_int32_t seq, void *ctxt)
a204 1
	struct ssh *ssh = ctxt;
@


1.137
log
@use ssh_packet_set_log_preamble() to include connection username
in packet log messages, e.g.

Connection closed by invalid user foo 10.1.1.1 port 44056 [preauth]

ok markus@@ bz#113
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.136 2016/05/02 08:49:03 djm Exp $ */
d158 2
d162 2
a163 1
	dispatch_run(DISPATCH_BLOCK, &authctxt->success, authctxt);
d170 2
a171 1
	Authctxt *authctxt = ctxt;
d206 2
a207 2
	struct ssh *ssh = active_state;	/* XXX */
	Authctxt *authctxt = ctxt;
@


1.136
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.135 2015/01/19 20:07:45 markus Exp $ */
d202 1
d225 2
a226 1
			debug2("input_userauth_request: setting up authctxt for %s", user);
d228 1
a228 1
			logit("input_userauth_request: invalid user %s", user);
d231 2
d279 1
d315 1
@


1.135
log
@move dispatch to struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.134 2014/12/22 07:55:51 djm Exp $ */
d376 2
a377 2
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
@


1.134
log
@make internal handling of filename arguments of "none" more consistent
with ssh. "none" arguments are now replaced with NULL when the
configuration is finalised.

Simplifies checking later on (just need to test not-NULL rather than
that + strcmp) and cleans up some inconsistencies. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.133 2014/12/18 23:58:04 djm Exp $ */
d86 2
a87 2
static void input_service_request(int, u_int32_t, void *);
static void input_userauth_request(int, u_int32_t, void *);
d164 1
a164 1
static void
d195 1
d199 1
a199 1
static void
d268 1
@


1.133
log
@don't count partial authentication success as a failure against
MaxAuthTries; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.132 2014/07/15 15:54:14 millert Exp $ */
d137 1
a137 3
	if (options.banner == NULL ||
	    strcasecmp(options.banner, "none") == 0 ||
	    (datafellows & SSH_BUG_BANNER) != 0)
@


1.132
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.131 2014/07/03 11:16:55 djm Exp $ */
d312 1
a312 1
		if (!authctxt->server_caused_failure &&
@


1.131
log
@make the "Too many authentication failures" message include the
user, source address, port and protocol in a format similar to the
authentication success / failure messages; bz#2199, ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.130 2014/01/29 06:18:35 djm Exp $ */
d43 1
@


1.130
log
@remove experimental, never-enabled JPAKE code; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.129 2013/05/19 02:42:42 djm Exp $ */
d315 1
a315 1
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
@


1.129
log
@Standardise logging of supplemental information during userauth. Keys
and ruser is now logged in the auth success/failure message alongside
the local username, remote host/port and protocol in use. Certificates
contents and CA are logged too.

Pushing all logging onto a single line simplifies log analysis as it is
no longer necessary to relate information scattered across multiple log
entries. "I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.128 2013/05/17 00:13:13 djm Exp $ */
a69 3
#ifdef JPAKE
extern Authmethod method_jpake;
#endif
a76 3
#ifdef JPAKE
	&method_jpake,
#endif
a246 3
#ifdef JPAKE
	auth2_jpake_stop(authctxt);
#endif
@


1.128
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.127 2013/03/07 19:27:25 markus Exp $ */
d305 1
a305 1
	auth_log(authctxt, authenticated, partial, method, submethod, " ssh2");
@


1.127
log
@add submethod support to AuthenticationMethods; ok and freedback djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.126 2012/12/02 20:34:09 djm Exp $ */
d129 1
a129 1
		xfree(banner);
d156 1
a156 2
	if (banner)
		xfree(banner);
d201 1
a201 1
	xfree(service);
d274 3
a276 3
	xfree(service);
	xfree(user);
	xfree(method);
d333 1
a333 1
		xfree(methods);
@


1.126
log
@Fixes logging of partial authentication when privsep is enabled
Previously, we recorded "Failed xxx" since we reset authenticated before
calling auth_log() in auth2.c. This adds an explcit "Partial" state.

Add a "submethod" to auth_log() to report which submethod is used
for keyboard-interactive.

Fix multiple authentication when one of the methods is
keyboard-interactive.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.125 2012/11/04 11:09:15 djm Exp $ */
d97 6
a102 2
static int method_allowed(Authctxt *, const char *);
static int list_starts_with(const char *, const char *);
d299 1
a299 1
		if (!auth2_update_methods_lists(authctxt, method)) {
d343 3
a345 2
static int
method_allowed(Authctxt *authctxt, const char *method)
d356 2
a357 1
		if (list_starts_with(authctxt->auth_methods[i], method))
d377 2
a378 1
		if (!method_allowed(authctxt, authmethods[i]->name))
d401 2
a402 1
			    method_allowed(authctxt, authmethods[i]->name))
d417 1
a417 1
	char *methods, *omethods, *method;
d428 2
d495 2
a496 1
list_starts_with(const char *methods, const char *method)
d499 2
d503 16
a518 4
		return 0;
	if (methods[l] != ',' && methods[l] != '\0')
		return 0;
	return 1;
d527 1
a527 1
remove_method(char **methods, const char *method)
d529 1
a529 1
	char *omethods = *methods;
d531 1
d533 2
a534 1
	if (!list_starts_with(omethods, method))
d536 6
a541 1
	*methods = xstrdup(omethods + l + (omethods[l] == ',' ? 1 : 0));
d553 2
a554 1
auth2_update_methods_lists(Authctxt *authctxt, const char *method)
d560 2
a561 1
		if (!remove_method(&(authctxt->auth_methods[i]), method))
@


1.125
log
@Support multiple required authentication via an AuthenticationMethods
option. This option lists one or more comma-separated lists of
authentication method names. Successful completion of all the methods in
any list is required for authentication to complete;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.124 2011/12/07 05:44:38 djm Exp $ */
d269 1
a269 1
	userauth_finish(authctxt, authenticated, method);
d277 2
a278 1
userauth_finish(Authctxt *authctxt, int authenticated, char *method)
d286 2
a293 6
	/* Log before sending the reply */
	auth_log(authctxt, authenticated, method, " ssh2");

	if (authctxt->postponed)
		return;

d300 6
@


1.124
log
@fix some harmless and/or unreachable int overflows;
reported Xi Wang, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.123 2011/03/10 02:52:57 djm Exp $ */
d95 4
a98 2
static Authmethod *authmethod_lookup(const char *);
static char *authmethods_get(void);
d240 2
d264 1
a264 1
	m = authmethod_lookup(method);
d280 1
d297 7
a303 1
	/* XXX todo: check if multiple auth methods are needed */
d319 3
a321 1
		methods = authmethods_get();
d324 1
a324 1
		packet_put_char(0);	/* XXX partial success, unused */
d331 23
d355 1
a355 1
authmethods_get(void)
d359 1
a359 1
	int i;
d365 9
a373 7
		if (authmethods[i]->enabled != NULL &&
		    *(authmethods[i]->enabled) != 0) {
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, authmethods[i]->name,
			    strlen(authmethods[i]->name));
		}
d382 1
a382 1
authmethod_lookup(const char *name)
d390 2
a391 1
			    strcmp(name, authmethods[i]->name) == 0)
d397 143
@


1.123
log
@allow GSSAPI authentication to detect when a server-side failure causes
authentication failure and don't count such failures against MaxAuthTries;
bz#1244 from simon AT sxw.org.uk; ok markus@@ before lock
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.122 2010/08/31 09:58:37 djm Exp $ */
d112 1
a112 1
	if (st.st_size > 1*1024*1024) {
@


1.122
log
@Add buffer_get_cstring() and related functions that verify that the
string extracted from the buffer contains no embedded \0 characters*
This prevents random (possibly malicious) crap from being appended to
strings where it would not be noticed if the string is used with
a string(3) function.

Use the new API in a few sensitive places.

* actually, we allow a single one at the end of the string for now because
we don't know how many deployed implementations get this wrong, but don't
count on this to remain indefinitely.
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.121 2009/06/22 05:39:28 dtucker Exp $ */
d257 1
d303 2
a304 1
		if (authctxt->attempt > 1 || strcmp(method, "none") != 0)
@


1.121
log
@alphabetize includes; reduces diff vs portable and style(9).  ok stevesk djm
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.120 2008/11/04 08:22:12 djm Exp $ */
d172 1
a172 1
	char *service = packet_get_string(&len);
d211 3
a213 3
	user = packet_get_string(NULL);
	service = packet_get_string(NULL);
	method = packet_get_string(NULL);
@


1.120
log
@Add support for an experimental zero-knowledge password authentication
method using the J-PAKE protocol described in F. Hao, P. Ryan,
"Password Authenticated Key Exchange by Juggling", 16th Workshop on
Security Protocols, Cambridge, April 2008.

This method allows password-based authentication without exposing
the password to the server. Instead, the client and server exchange
cryptographic proofs to demonstrate of knowledge of the password while
revealing nothing useful to an attacker or compromised endpoint.

This is experimental, work-in-progress code and is presently
compiled-time disabled (turn on -DJPAKE in Makefile.inc).

"just commit it.  It isn't too intrusive." deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.119 2008/07/04 23:30:16 djm Exp $ */
d33 1
a34 1
#include <stdarg.h>
@


1.119
log
@Make protocol 1 MaxAuthTries logic match protocol 2's.

Do not treat the first protocol 2 authentication attempt as
a failure IFF it is for method "none".

Makes MaxAuthTries' user-visible behaviour identical for
protocol 1 vs 2.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.118 2008/07/02 13:30:34 djm Exp $ */
d70 3
d80 3
d246 3
d251 1
@


1.118
log
@really really remove the freebie "none" auth try for protocol 2
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.117 2008/07/02 12:36:39 djm Exp $ */
d291 4
a294 1
		if (++authctxt->failures >= options.max_authtries)
@


1.117
log
@Make protocol 2 MaxAuthTries behaviour a little more sensible:

Check whether client has exceeded MaxAuthTries before running
an authentication method and skip it if they have, previously it
would always allow one try (for "none" auth).

Preincrement failure count before post-auth test - previously this
checked and postincremented, also to allow one "none" try.

Together, these two changes always count the "none" auth method
which could be skipped by a malicious client (e.g. an SSH worm)
to get an extra attempt at a real auth method. They also make
MaxAuthTries=0 a useful way to block users entirely (esp. in a
sshd_config Match block).

Also, move sending of any preauth banner from "none" auth method
to the first call to input_userauth_request(), so worms that skip
the "none" method get to see it too.
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.116 2007/09/29 00:25:51 dtucker Exp $ */
d291 1
a291 1
		if (++authctxt->failures > options.max_authtries)
@


1.116
log
@Remove unused prototype.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.115 2007/04/14 22:01:58 stevesk Exp $ */
d28 2
d31 1
d35 1
d37 1
d92 56
a150 1

d231 1
d250 1
a250 1
	if (m != NULL) {
d291 1
a291 1
		if (authctxt->failures++ > options.max_authtries)
d343 1
@


1.115
log
@remove unused macro; from Dmitry V. Levin <ldv@@altlinux.org>
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.114 2007/03/01 10:28:02 dtucker Exp $ */
a85 1
int user_key_allowed(struct passwd *, Key *);
@


1.114
log
@Remove ChallengeResponseAuthentication support inside a Match
block as its interaction with KbdInteractive makes it difficult to
support.  Also, relocate the CR/kbdint option special-case code into
servconf.  "please commit" djm@@, ok markus@@ for the relocation.
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.113 2006/08/03 03:34:41 deraadt Exp $ */
a241 2

#define	DELIM	","
@


1.113
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.112 2006/07/22 20:48:22 stevesk Exp $ */
a94 4
	/* challenge-response is implemented via keyboard interactive */
	if (options.challenge_response_authentication)
		options.kbd_interactive_authentication = 1;

@


1.112
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.111 2006/07/06 16:03:53 stevesk Exp $ */
a25 1
#include "includes.h"
d31 1
d33 1
a34 1
#include "xmalloc.h"
d37 1
d40 2
a44 2
#include "monitor_wrap.h"

d48 1
@


1.111
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.110 2006/03/25 13:17:01 djm Exp $ */
d31 1
@


1.110
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d27 4
@


1.109
log
@sprinkle some ARGSUSED for table driven functions (which sometimes must ignore their args)
@
text
@d1 1
@


1.108
log
@RCSID() can die
@
text
@d96 1
d130 1
@


1.107
log
@more s/illegal/invalid/
@
text
@a25 1
RCSID("$OpenBSD: auth2.c,v 1.106 2004/07/21 10:33:31 djm Exp $");
@


1.107.6.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth2.c,v 1.113 2006/08/03 03:34:41 deraadt Exp $ */
d25 2
d28 1
a28 6
#include <sys/types.h>

#include <pwd.h>
#include <string.h>
#include <stdarg.h>

a29 1
#include "ssh2.h"
a31 1
#include "buffer.h"
a33 2
#include "key.h"
#include "hostfile.h"
d37 2
a41 1
#include "monitor_wrap.h"
a96 1
/*ARGSUSED*/
a129 1
/*ARGSUSED*/
@


1.107.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: auth2.c,v 1.113 2006/08/03 03:34:41 deraadt Exp $ */
d25 2
d28 1
a28 6
#include <sys/types.h>

#include <pwd.h>
#include <string.h>
#include <stdarg.h>

a29 1
#include "ssh2.h"
a31 1
#include "buffer.h"
a33 2
#include "key.h"
#include "hostfile.h"
d37 2
a41 1
#include "monitor_wrap.h"
a96 1
/*ARGSUSED*/
a129 1
/*ARGSUSED*/
@


1.106
log
@bz#899: Don't display invalid usernames in setproctitle
from peak AT argo.troja.mff.cuni.cz; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.105 2004/05/23 23:59:53 dtucker Exp $");
d157 1
a157 1
			logit("input_userauth_request: illegal user %s", user);
@


1.105
log
@Add MaxAuthTries sshd config option; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.104 2003/11/04 08:54:09 djm Exp $");
d160 1
a160 1
		setproctitle("%s%s", authctxt->pw ? user : "unknown",
@


1.104
log
@standardise arguments to auth methods - they should all take authctxt.
check authctxt->valid rather then pw != NULL; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.103 2003/09/23 20:17:11 markus Exp $");
d226 1
a226 1
		if (authctxt->failures++ > AUTH_FAIL_MAX)
@


1.104.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.107 2004/07/28 09:40:29 markus Exp $");
d157 1
a157 1
			logit("input_userauth_request: invalid user %s", user);
d160 1
a160 1
		setproctitle("%s%s", authctxt->valid ? user : "unknown",
d226 1
a226 1
		if (authctxt->failures++ > options.max_authtries)
@


1.103
log
@replace fatal_cleanup() and linked list of fatal callbacks with static
cleanup_exit() function.  re-refine cleanup_exit() where appropriate,
allocate sshd's authctxt eary to allow simpler cleanup in sshd.
tested by many, ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.102 2003/08/26 09:58:43 markus Exp $");
a79 1
int hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
@


1.102
log
@fix passwd auth for 'username leaks via timing'; with djm@@, original patches from solar
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.101 2003/08/22 13:22:27 markus Exp $");
a47 2
Authctxt *x_authctxt = NULL;

d86 2
a87 2
Authctxt *
do_authentication2(void)
a88 4
	Authctxt *authctxt = authctxt_new();

	x_authctxt = authctxt;		/*XXX*/

a95 2

	return (authctxt);
a236 8
}

/* get current user */

struct passwd*
auth_get_user(void)
{
	return (x_authctxt != NULL && x_authctxt->valid) ? x_authctxt->pw : NULL;
@


1.102.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.104 2003/11/04 08:54:09 djm Exp $");
d48 2
d82 1
d88 2
a89 2
void
do_authentication2(Authctxt *authctxt)
d91 4
d102 2
d245 8
@


1.102.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.107 2004/07/28 09:40:29 markus Exp $");
d157 1
a157 1
			logit("input_userauth_request: invalid user %s", user);
d160 1
a160 1
		setproctitle("%s%s", authctxt->valid ? user : "unknown",
d226 1
a226 1
		if (authctxt->failures++ > options.max_authtries)
@


1.101
log
@nuke "kerberos-2@@ssh.com"
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.100 2003/08/22 10:56:08 markus Exp $");
d167 1
@


1.100
log
@support GSS API user authentication; patches from Simon Wilkinson,
stripped down and tested by Jakob and myself.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.99 2003/06/24 08:23:46 markus Exp $");
a56 3
#ifdef KRB5
extern Authmethod method_kerberos;
#endif
a69 3
#ifdef KRB5
	&method_kerberos,
#endif
@


1.99
log
@int -> u_int; ok djm@@, deraadt@@, mouring@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.98 2003/05/14 02:15:47 markus Exp $");
d39 4
d60 3
d67 3
d189 6
@


1.98
log
@implement kerberos over ssh2 ("kerberos-2@@ssh.com"); tested with jakob@@
server interops with commercial client; ok jakob@@ djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.97 2003/04/08 20:21:28 itojun Exp $");
d42 1
a42 1
extern int session_id2_len;
@


1.97
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.96 2003/02/06 21:22:43 markus Exp $");
d53 3
d63 3
@


1.96
log
@undo broken fix for #387, fixes #486
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.94 2002/06/30 21:54:16 deraadt Exp $");
d156 1
a156 1
			log("input_userauth_request: illegal user %s", user);
@


1.96.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.102 2003/08/26 09:58:43 markus Exp $");
a38 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

d42 1
a42 1
extern u_int session_id2_len;
a52 3
#ifdef GSSAPI
extern Authmethod method_gssapi;
#endif
a56 3
#ifdef GSSAPI
	&method_gssapi,
#endif
d156 1
a156 2
			logit("input_userauth_request: illegal user %s", user);
			authctxt->pw = fakepw();
a172 6

#ifdef GSSAPI
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
#endif

@


1.96.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.104 2003/11/04 08:54:09 djm Exp $");
d48 2
d82 1
d88 2
a89 2
void
do_authentication2(Authctxt *authctxt)
d91 4
d102 2
d245 8
@


1.95
log
@auth_root_allowed() is handled by the monitor in the privsep case,
so skip this for use_privsep, ok stevesk@@, fixes bugzilla #387/325
@
text
@d198 1
a198 2
	if (!use_privsep &&
	    authenticated && authctxt->pw->pw_uid == 0 &&
@


1.95.2.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.96 2003/02/06 21:22:43 markus Exp $");
d198 2
a199 1
	if (authenticated && authctxt->pw->pw_uid == 0 &&
@


1.95.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.102 2003/08/26 09:58:43 markus Exp $");
a38 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

d42 1
a42 1
extern u_int session_id2_len;
a52 3
#ifdef GSSAPI
extern Authmethod method_gssapi;
#endif
a56 3
#ifdef GSSAPI
	&method_gssapi,
#endif
d156 1
a156 2
			logit("input_userauth_request: illegal user %s", user);
			authctxt->pw = fakepw();
a172 6

#ifdef GSSAPI
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
#endif

@


1.94
log
@lint asks that we use names that do not overlap
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.93 2002/05/31 11:35:15 markus Exp $");
d198 2
a199 1
	if (authenticated && authctxt->pw->pw_uid == 0 &&
@


1.93
log
@move Authmethod definitons to per-method file.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.92 2002/05/25 18:51:07 markus Exp $");
d101 1
a101 1
	int accept = 0;
d110 1
a110 1
			accept = 1;
d117 1
a117 1
	if (accept) {
@


1.92
log
@split auth2.c into one file per method; ok provos@@/deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.91 2002/05/13 02:37:39 itojun Exp $");
a44 1
static int one = 1;
d46 15
a60 5
typedef struct Authmethod Authmethod;
struct Authmethod {
	char	*name;
	int	(*userauth)(Authctxt *authctxt);
	int	*enabled;
a73 21
/* auth */

Authmethod authmethods[] = {
	{"none",
		userauth_none,
		&one},
	{"publickey",
		userauth_pubkey,
		&options.pubkey_authentication},
	{"password",
		userauth_passwd,
		&options.password_authentication},
	{"keyboard-interactive",
		userauth_kbdint,
		&options.kbd_interactive_authentication},
	{"hostbased",
		userauth_hostbased,
		&options.hostbased_authentication},
	{NULL, NULL, NULL}
};

a242 1
	Authmethod *method = NULL;
d245 1
d248 2
a249 2
	for (method = authmethods; method->name != NULL; method++) {
		if (strcmp(method->name, "none") == 0)
d251 2
a252 1
		if (method->enabled != NULL && *(method->enabled) != 0) {
d255 2
a256 1
			buffer_append(&b, method->name, strlen(method->name));
d268 2
a269 1
	Authmethod *method = NULL;
d271 7
a277 6
		for (method = authmethods; method->name != NULL; method++)
			if (method->enabled != NULL &&
			    *(method->enabled) != 0 &&
			    strcmp(name, method->name) == 0)
				return method;
	debug2("Unrecognized authentication method name: %s", name ? name : "NULL");
@


1.91
log
@less warnings.  skey_{respond,query} are public (in auth.h)
@
text
@d26 1
a26 3
RCSID("$OpenBSD: auth2.c,v 1.90 2002/05/12 23:53:45 djm Exp $");

#include <openssl/evp.h>
a29 2
#include "rsa.h"
#include "sshpty.h"
a30 1
#include "buffer.h"
a33 2
#include "channels.h"
#include "bufaux.h"
a34 1
#include "session.h"
a35 3
#include "key.h"
#include "cipher.h"
#include "kex.h"
a36 5
#include "uidswap.h"
#include "auth-options.h"
#include "hostfile.h"
#include "canohost.h"
#include "match.h"
a37 1
#include "atomicio.h"
a65 6
static void userauth_banner(void);
static int userauth_none(Authctxt *);
static int userauth_passwd(Authctxt *);
static int userauth_pubkey(Authctxt *);
static int userauth_hostbased(Authctxt *);
static int userauth_kbdint(Authctxt *);
a241 298
char *
auth2_read_banner(void)
{
	struct stat st;
	char *banner = NULL;
	off_t len, n;
	int fd;

	if ((fd = open(options.banner, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) == -1) {
		close(fd);
		return (NULL);
	}
	len = st.st_size;
	banner = xmalloc(len + 1);
	n = atomicio(read, fd, banner, len);
	close(fd);

	if (n != len) {
		free(banner);
		return (NULL);
	}
	banner[n] = '\0';
	
	return (banner);
}

static void
userauth_banner(void)
{
	char *banner = NULL;

	if (options.banner == NULL || (datafellows & SSH_BUG_BANNER))
		return;

	if ((banner = PRIVSEP(auth2_read_banner())) == NULL)
		goto done;

	packet_start(SSH2_MSG_USERAUTH_BANNER);
	packet_put_cstring(banner);
	packet_put_cstring("");		/* language, unused */
	packet_send();
	debug("userauth_banner: sent");
done:
	if (banner)
		xfree(banner);
	return;
}

static int
userauth_none(Authctxt *authctxt)
{
	/* disable method "none", only allowed one time */
	Authmethod *m = authmethod_lookup("none");
	if (m != NULL)
		m->enabled = NULL;
	packet_check_eom();
	userauth_banner();
	return (authctxt->valid ? PRIVSEP(auth_password(authctxt, "")) : 0);
}

static int
userauth_passwd(Authctxt *authctxt)
{
	char *password;
	int authenticated = 0;
	int change;
	u_int len;
	change = packet_get_char();
	if (change)
		log("password change not supported");
	password = packet_get_string(&len);
	packet_check_eom();
	if (authctxt->valid &&
	    PRIVSEP(auth_password(authctxt, password)) == 1)
		authenticated = 1;
	memset(password, 0, len);
	xfree(password);
	return authenticated;
}

static int
userauth_kbdint(Authctxt *authctxt)
{
	int authenticated = 0;
	char *lang, *devs;

	lang = packet_get_string(NULL);
	devs = packet_get_string(NULL);
	packet_check_eom();

	debug("keyboard-interactive devs %s", devs);

	if (options.challenge_response_authentication)
		authenticated = auth2_challenge(authctxt, devs);

	xfree(devs);
	xfree(lang);
	return authenticated;
}

static int
userauth_pubkey(Authctxt *authctxt)
{
	Buffer b;
	Key *key = NULL;
	char *pkalg;
	u_char *pkblob, *sig;
	u_int alen, blen, slen;
	int have_sig, pktype;
	int authenticated = 0;

	if (!authctxt->valid) {
		debug2("userauth_pubkey: disabled because of invalid user");
		return 0;
	}
	have_sig = packet_get_char();
	if (datafellows & SSH_BUG_PKAUTH) {
		debug2("userauth_pubkey: SSH_BUG_PKAUTH");
		/* no explicit pkalg given */
		pkblob = packet_get_string(&blen);
		buffer_init(&b);
		buffer_append(&b, pkblob, blen);
		/* so we have to extract the pkalg from the pkblob */
		pkalg = buffer_get_string(&b, &alen);
		buffer_free(&b);
	} else {
		pkalg = packet_get_string(&alen);
		pkblob = packet_get_string(&blen);
	}
	pktype = key_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		log("userauth_pubkey: unsupported public key algorithm: %s",
		    pkalg);
		goto done;
	}
	key = key_from_blob(pkblob, blen);
	if (key == NULL) {
		error("userauth_pubkey: cannot decode key: %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("userauth_pubkey: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
		goto done;
	}
	if (have_sig) {
		sig = packet_get_string(&slen);
		packet_check_eom();
		buffer_init(&b);
		if (datafellows & SSH_OLD_SESSIONID) {
			buffer_append(&b, session_id2, session_id2_len);
		} else {
			buffer_put_string(&b, session_id2, session_id2_len);
		}
		/* reconstruct packet */
		buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
		buffer_put_cstring(&b, authctxt->user);
		buffer_put_cstring(&b,
		    datafellows & SSH_BUG_PKSERVICE ?
		    "ssh-userauth" :
		    authctxt->service);
		if (datafellows & SSH_BUG_PKAUTH) {
			buffer_put_char(&b, have_sig);
		} else {
			buffer_put_cstring(&b, "publickey");
			buffer_put_char(&b, have_sig);
			buffer_put_cstring(&b, pkalg);
		}
		buffer_put_string(&b, pkblob, blen);
#ifdef DEBUG_PK
		buffer_dump(&b);
#endif
		/* test for correct signature */
		authenticated = 0;
		if (PRIVSEP(user_key_allowed(authctxt->pw, key)) &&
		    PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b),
				buffer_len(&b))) == 1)
			authenticated = 1;
		buffer_clear(&b);
		xfree(sig);
	} else {
		debug("test whether pkalg/pkblob are acceptable");
		packet_check_eom();

		/* XXX fake reply and always send PK_OK ? */
		/*
		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (PRIVSEP(user_key_allowed(authctxt->pw, key))) {
			packet_start(SSH2_MSG_USERAUTH_PK_OK);
			packet_put_string(pkalg, alen);
			packet_put_string(pkblob, blen);
			packet_send();
			packet_write_wait();
			authctxt->postponed = 1;
		}
	}
	if (authenticated != 1)
		auth_clear_options();
done:
	debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
	if (key != NULL)
		key_free(key);
	xfree(pkalg);
	xfree(pkblob);
	return authenticated;
}

static int
userauth_hostbased(Authctxt *authctxt)
{
	Buffer b;
	Key *key = NULL;
	char *pkalg, *cuser, *chost, *service;
	u_char *pkblob, *sig;
	u_int alen, blen, slen;
	int pktype;
	int authenticated = 0;

	if (!authctxt->valid) {
		debug2("userauth_hostbased: disabled because of invalid user");
		return 0;
	}
	pkalg = packet_get_string(&alen);
	pkblob = packet_get_string(&blen);
	chost = packet_get_string(NULL);
	cuser = packet_get_string(NULL);
	sig = packet_get_string(&slen);

	debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d",
	    cuser, chost, pkalg, slen);
#ifdef DEBUG_PK
	debug("signature:");
	buffer_init(&b);
	buffer_append(&b, sig, slen);
	buffer_dump(&b);
	buffer_free(&b);
#endif
	pktype = key_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		log("userauth_hostbased: unsupported "
		    "public key algorithm: %s", pkalg);
		goto done;
	}
	key = key_from_blob(pkblob, blen);
	if (key == NULL) {
		error("userauth_hostbased: cannot decode key: %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("userauth_hostbased: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
		goto done;
	}
	service = datafellows & SSH_BUG_HBSERVICE ? "ssh-userauth" :
	    authctxt->service;
	buffer_init(&b);
	buffer_put_string(&b, session_id2, session_id2_len);
	/* reconstruct packet */
	buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
	buffer_put_cstring(&b, authctxt->user);
	buffer_put_cstring(&b, service);
	buffer_put_cstring(&b, "hostbased");
	buffer_put_string(&b, pkalg, alen);
	buffer_put_string(&b, pkblob, blen);
	buffer_put_cstring(&b, chost);
	buffer_put_cstring(&b, cuser);
#ifdef DEBUG_PK
	buffer_dump(&b);
#endif
	/* test for allowed key and correct signature */
	authenticated = 0;
	if (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&
	    PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b),
			buffer_len(&b))) == 1)
		authenticated = 1;

	buffer_clear(&b);
done:
	debug2("userauth_hostbased: authenticated %d", authenticated);
	if (key != NULL)
		key_free(key);
	xfree(pkalg);
	xfree(pkblob);
	xfree(cuser);
	xfree(chost);
	xfree(sig);
	return authenticated;
}

a286 161
}

/* return 1 if user allows given key */
static int
user_key_allowed2(struct passwd *pw, Key *key, char *file)
{
	char line[8192];
	int found_key = 0;
	FILE *f;
	u_long linenum = 0;
	struct stat st;
	Key *found;
	char *fp;

	if (pw == NULL)
		return 0;

	/* Temporarily use the user's uid. */
	temporarily_use_uid(pw);

	debug("trying public key file %s", file);

	/* Fail quietly if file does not exist */
	if (stat(file, &st) < 0) {
		/* Restore the privileged uid. */
		restore_uid();
		return 0;
	}
	/* Open the file containing the authorized keys. */
	f = fopen(file, "r");
	if (!f) {
		/* Restore the privileged uid. */
		restore_uid();
		return 0;
	}
	if (options.strict_modes &&
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
		fclose(f);
		log("Authentication refused: %s", line);
		restore_uid();
		return 0;
	}

	found_key = 0;
	found = key_new(key->type);

	while (fgets(line, sizeof(line), f)) {
		char *cp, *options = NULL;
		linenum++;
		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#')
			continue;

		if (key_read(found, &cp) != 1) {
			/* no key?  check if there are options for this key */
			int quoted = 0;
			debug2("user_key_allowed: check options: '%s'", cp);
			options = cp;
			for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
				if (*cp == '\\' && cp[1] == '"')
					cp++;	/* Skip both */
				else if (*cp == '"')
					quoted = !quoted;
			}
			/* Skip remaining whitespace. */
			for (; *cp == ' ' || *cp == '\t'; cp++)
				;
			if (key_read(found, &cp) != 1) {
				debug2("user_key_allowed: advance: '%s'", cp);
				/* still no key?  advance to next line*/
				continue;
			}
		}
		if (key_equal(found, key) &&
		    auth_parse_options(pw, options, file, linenum) == 1) {
			found_key = 1;
			debug("matching key found: file %s, line %lu",
			    file, linenum);
			fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
			verbose("Found matching %s key: %s",
			    key_type(found), fp);
			xfree(fp);
			break;
		}
	}
	restore_uid();
	fclose(f);
	key_free(found);
	if (!found_key)
		debug2("key not found");
	return found_key;
}

/* check whether given key is in .ssh/authorized_keys* */
int
user_key_allowed(struct passwd *pw, Key *key)
{
	int success;
	char *file;

	file = authorized_keys_file(pw);
	success = user_key_allowed2(pw, key, file);
	xfree(file);
	if (success)
		return success;

	/* try suffix "2" for backward compat, too */
	file = authorized_keys_file2(pw);
	success = user_key_allowed2(pw, key, file);
	xfree(file);
	return success;
}

/* return 1 if given hostkey is allowed */
int
hostbased_key_allowed(struct passwd *pw, const char *cuser, char *chost,
    Key *key)
{
	const char *resolvedname, *ipaddr, *lookup;
	HostStatus host_status;
	int len;

	resolvedname = get_canonical_hostname(options.verify_reverse_mapping);
	ipaddr = get_remote_ipaddr();

	debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s",
	    chost, resolvedname, ipaddr);

	if (options.hostbased_uses_name_from_packet_only) {
		if (auth_rhosts2(pw, cuser, chost, chost) == 0)
			return 0;
		lookup = chost;
	} else {
		if (((len = strlen(chost)) > 0) && chost[len - 1] == '.') {
			debug2("stripping trailing dot from chost %s", chost);
			chost[len - 1] = '\0';
		}
		if (strcasecmp(resolvedname, chost) != 0)
			log("userauth_hostbased mismatch: "
			    "client sends %s, but we resolve %s to %s",
			    chost, ipaddr, resolvedname);
		if (auth_rhosts2(pw, cuser, resolvedname, ipaddr) == 0)
			return 0;
		lookup = resolvedname;
	}
	debug2("userauth_hostbased: access allowed by auth_rhosts2");

	host_status = check_key_in_hostfiles(pw, key, lookup,
	    _PATH_SSH_SYSTEM_HOSTFILE,
	    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);

	/* backward compat if no key has been found. */
	if (host_status == HOST_NEW)
		host_status = check_key_in_hostfiles(pw, key, lookup,
		    _PATH_SSH_SYSTEM_HOSTFILE2,
		    options.ignore_user_known_hosts ? NULL :
		    _PATH_SSH_USER_HOSTFILE2);

	return (host_status == HOST_OK);
@


1.90
log
@Fix sshd Banner option for privsep; ok markus@@ provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.89 2002/03/19 14:27:39 markus Exp $");
d54 1
@


1.89
log
@make getpwnamallow() allways call pwcopy()
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.88 2002/03/18 17:50:31 provos Exp $");
d264 2
a265 2
static void
userauth_banner(void)
d272 25
d299 2
a300 3
	if ((fd = open(options.banner, O_RDONLY)) < 0)
		return;
	if (fstat(fd, &st) < 0)
d302 1
a302 5
	len = st.st_size;
	banner = xmalloc(len + 1);
	if ((n = read(fd, banner, len)) < 0)
		goto done;
	banner[n] = '\0';
a310 1
	close(fd);
@


1.89.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.91 2002/05/13 02:37:39 itojun Exp $");
a53 1
#include "atomicio.h"
d264 2
a265 2
char *
auth2_read_banner(void)
d272 6
a277 6
	if ((fd = open(options.banner, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) == -1) {
		close(fd);
		return (NULL);
	}
d280 2
a281 7
	n = atomicio(read, fd, banner, len);
	close(fd);

	if (n != len) {
		free(banner);
		return (NULL);
	}
a282 15
	
	return (banner);
}

static void
userauth_banner(void)
{
	char *banner = NULL;

	if (options.banner == NULL || (datafellows & SSH_BUG_BANNER))
		return;

	if ((banner = PRIVSEP(auth2_read_banner())) == NULL)
		goto done;

d291 1
@


1.89.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.89.2.3
log
@Pull in OpenSSH-3.4
@
text
@d26 3
a28 1
RCSID("$OpenBSD: auth2.c,v 1.93 2002/05/31 11:35:15 markus Exp $");
d32 2
d35 1
d39 2
d42 1
d44 3
d48 5
d54 1
d62 1
d64 5
a68 15
/* methods */

extern Authmethod method_none;
extern Authmethod method_pubkey;
extern Authmethod method_passwd;
extern Authmethod method_kbdint;
extern Authmethod method_hostbased;

Authmethod *authmethods[] = {
	&method_none,
	&method_pubkey,
	&method_passwd,
	&method_kbdint,
	&method_hostbased,
	NULL
d82 27
d265 298
d576 1
a578 1
	int i;
d581 2
a582 2
	for (i = 0; authmethods[i] != NULL; i++) {
		if (strcmp(authmethods[i]->name, "none") == 0)
d584 1
a584 2
		if (authmethods[i]->enabled != NULL &&
		    *(authmethods[i]->enabled) != 0) {
d587 1
a587 2
			buffer_append(&b, authmethods[i]->name,
			    strlen(authmethods[i]->name));
d599 1
a599 2
	int i;

d601 6
a606 7
		for (i = 0; authmethods[i] != NULL; i++)
			if (authmethods[i]->enabled != NULL &&
			    *(authmethods[i]->enabled) != 0 &&
			    strcmp(name, authmethods[i]->name) == 0)
				return authmethods[i];
	debug2("Unrecognized authentication method name: %s",
	    name ? name : "NULL");
d608 161
@


1.89.2.4
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.95 2002/08/22 21:33:58 markus Exp $");
d101 1
a101 1
	int acceptit = 0;
d110 1
a110 1
			acceptit = 1;
d117 1
a117 1
	if (acceptit) {
d198 1
a198 2
	if (!use_privsep &&
	    authenticated && authctxt->pw->pw_uid == 0 &&
@


1.89.2.5
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.96 2003/02/06 21:22:43 markus Exp $");
d198 2
a199 1
	if (authenticated && authctxt->pw->pw_uid == 0 &&
@


1.88
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.85 2002/02/24 19:14:59 markus Exp $");
a49 1
#include "misc.h"
d185 2
a186 4
		struct passwd *pw = NULL;
		pw = PRIVSEP(getpwnamallow(user));
		if (pw && strcmp(service, "ssh-connection")==0) {
			authctxt->pw = pwcopy(pw);
d192 1
a192 5
		/* Free memory */
		if (use_privsep && pw != NULL)
			pwfree(pw);

		setproctitle("%s%s", pw ? user : "unknown",
a196 1

@


1.87
log
@have the authentication functions return the authentication context
and then do_authenticated; okay millert@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.86 2002/03/17 20:25:56 provos Exp $");
d54 1
d61 1
a61 1
static Authctxt	*x_authctxt = NULL;
d79 2
a80 2
static int user_key_allowed(struct passwd *, Key *);
static int hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
d187 1
a187 1
		pw = getpwnamallow(user);
d195 6
a200 1
		setproctitle("%s", pw ? user : "unknown");
d204 3
d312 1
a312 1
	return authctxt->valid ? auth_password(authctxt, "") : 0;
d328 1
a328 1
	    auth_password(authctxt, password) == 1)
d429 4
a432 2
		if (user_key_allowed(authctxt->pw, key) &&
		    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
d448 1
a448 1
		if (user_key_allowed(authctxt->pw, key)) {
d532 4
a535 2
	if (hostbased_key_allowed(authctxt->pw, cuser, chost, key) &&
	    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
d692 1
a692 1
static int
d712 1
a712 1
static int
@


1.86
log
@getpwnamallow returns struct passwd * only if user valid; okay markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.85 2002/02/24 19:14:59 markus Exp $");
d112 1
a112 1
void
d126 2
a127 1
	do_authenticated(authctxt);
@


1.85
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.84 2002/02/04 11:58:10 markus Exp $");
d185 2
a186 2
		pw = getpwnam(user);
		if (pw && allowed_user(pw) && strcmp(service, "ssh-connection")==0) {
@


1.84
log
@cross checking of announced vs actual pktype in pubkey/hostbaed auth; ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.83 2002/01/29 14:32:03 markus Exp $");
d350 2
a351 1
	char *pkalg, *pkblob, *sig;
d461 2
a462 1
	char *pkalg, *pkblob, *sig, *cuser, *chost, *service;
a743 1

@


1.83
log
@s/ReverseMappingCheck/VerifyReverseMapping/ and avoid confusion; ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.82 2002/01/13 17:57:37 markus Exp $");
d349 1
a349 1
	Key *key;
d376 3
a378 4
		log("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
		xfree(pkalg);
		xfree(pkblob);
		return 0;
d381 33
a413 25
	if (key != NULL) {
		if (have_sig) {
			sig = packet_get_string(&slen);
			packet_check_eom();
			buffer_init(&b);
			if (datafellows & SSH_OLD_SESSIONID) {
				buffer_append(&b, session_id2, session_id2_len);
			} else {
				buffer_put_string(&b, session_id2, session_id2_len);
			}
			/* reconstruct packet */
			buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
			buffer_put_cstring(&b, authctxt->user);
			buffer_put_cstring(&b,
			    datafellows & SSH_BUG_PKSERVICE ?
			    "ssh-userauth" :
			    authctxt->service);
			if (datafellows & SSH_BUG_PKAUTH) {
				buffer_put_char(&b, have_sig);
			} else {
				buffer_put_cstring(&b, "publickey");
				buffer_put_char(&b, have_sig);
				buffer_put_cstring(&b, pkalg);
			}
			buffer_put_string(&b, pkblob, blen);
d415 1
a415 1
			buffer_dump(&b);
d417 9
a425 9
			/* test for correct signature */
			if (user_key_allowed(authctxt->pw, key) &&
			    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
				authenticated = 1;
			buffer_clear(&b);
			xfree(sig);
		} else {
			debug("test whether pkalg/pkblob are acceptable");
			packet_check_eom();
d427 15
a441 16
			/* XXX fake reply and always send PK_OK ? */
			/*
			 * XXX this allows testing whether a user is allowed
			 * to login: if you happen to have a valid pubkey this
			 * message is sent. the message is NEVER sent at all
			 * if a user is not allowed to login. is this an
			 * issue? -markus
			 */
			if (user_key_allowed(authctxt->pw, key)) {
				packet_start(SSH2_MSG_USERAUTH_PK_OK);
				packet_put_string(pkalg, alen);
				packet_put_string(pkblob, blen);
				packet_send();
				packet_write_wait();
				authctxt->postponed = 1;
			}
a442 3
		if (authenticated != 1)
			auth_clear_options();
		key_free(key);
d444 3
d448 2
d459 1
a459 1
	Key *key;
d493 6
a498 1
		debug("userauth_hostbased: cannot decode key: %s", pkalg);
a522 2
	key_free(key);

d525 2
@


1.82
log
@use buffer API and avoid static strings of fixed size; ok provos@@/mouring@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.81 2002/01/11 13:39:36 markus Exp $");
d691 1
a691 1
	resolvedname = get_canonical_hostname(options.reverse_mapping_check);
@


1.81
log
@a single dispatch_protocol_error() that sends a message of type 'UNIMPLEMENTED'
dispatch_range(): set handler for a ranges message types
use dispatch_protocol_ignore() for authentication requests after
	successful authentication (the drafts requirement).
serverloop/clientloop now send a 'UNIMPLEMENTED' message instead of exiting.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.80 2001/12/28 15:06:00 markus Exp $");
d536 1
a536 1
	u_int size = 0;
d539 1
d544 3
a546 16
			if (size != 0)
				size += strlen(DELIM);
			size += strlen(method->name);
		}
	}
	size++;			/* trailing '\0' */
	list = xmalloc(size);
	list[0] = '\0';

	for (method = authmethods; method->name != NULL; method++) {
		if (strcmp(method->name, "none") == 0)
			continue;
		if (method->enabled != NULL && *(method->enabled) != 0) {
			if (list[0] != '\0')
				strlcat(list, DELIM, size);
			strlcat(list, method->name, size);
d549 3
@


1.80
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.79 2001/12/28 12:14:27 markus Exp $");
a73 1
static void protocol_error(int, u_int32_t, void *);
d123 1
a123 1
	dispatch_init(&protocol_error);
a129 10
protocol_error(int type, u_int32_t seq, void *ctxt)
{
	log("auth: protocol error: type %d", type);
	packet_start(SSH2_MSG_UNIMPLEMENTED);
	packet_put_int(seq);
	packet_send();
	packet_write_wait();
}

static void
d243 1
a243 1
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &protocol_error);
@


1.79
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.78 2001/12/20 22:50:24 djm Exp $");
d72 3
a74 3
static void input_service_request(int, int, u_int32_t, void *);
static void input_userauth_request(int, int, u_int32_t, void *);
static void protocol_error(int, int, u_int32_t, void *);
d131 1
a131 1
protocol_error(int type, int plen, u_int32_t seq, void *ctxt)
d133 1
a133 1
	log("auth: protocol error: type %d plen %d", type, plen);
d141 1
a141 1
input_service_request(int type, int plen, u_int32_t seq, void *ctxt)
d174 1
a174 1
input_userauth_request(int type, int plen, u_int32_t seq, void *ctxt)
@


1.78
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.77 2001/12/19 07:18:56 deraadt Exp $");
d147 1
a147 1
	packet_done();
d311 1
a311 1
	packet_done();
d327 1
a327 1
	packet_done();
d344 1
a344 1
	packet_done();
d396 1
a396 1
			packet_done();
d429 1
a429 1
			packet_done();
@


1.77
log
@basic KNF done while i was looking for something else
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.76 2001/12/18 10:05:15 jakob Exp $");
d72 3
a74 3
static void input_service_request(int, int, void *);
static void input_userauth_request(int, int, void *);
static void protocol_error(int, int, void *);
d131 1
a131 1
protocol_error(int type, int plen, void *ctxt)
d135 1
a135 1
	packet_put_int(0);
d141 1
a141 1
input_service_request(int type, int plen, void *ctxt)
d174 1
a174 1
input_userauth_request(int type, int plen, void *ctxt)
@


1.76
log
@log fingerprint on successful public key authentication; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.75 2001/12/09 18:45:56 markus Exp $");
d341 1
a341 1
	
d669 1
a669 1
			     key_type(found), fp);
@


1.75
log
@add auth2_challenge_stop(), simplifies cleanup of kbd-int sessions,
fixes memleak.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.74 2001/12/05 03:56:39 itojun Exp $");
d599 1
d667 4
@


1.74
log
@make it compile with more strict prototype checking
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.73 2001/11/17 19:14:34 stevesk Exp $");
d215 1
a215 1
	dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, &protocol_error);
a216 6
#ifdef BSD_AUTH
	if (authctxt->as) {
		auth_close(authctxt->as);
		authctxt->as = NULL;
	}
#endif
@


1.73
log
@enum/int type cleanup where it made sense to do so; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.72 2001/11/07 22:41:51 markus Exp $");
d114 1
a114 1
do_authentication2()
@


1.72
log
@unused includes
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.71 2001/09/27 15:31:17 markus Exp $");
d709 2
a710 1
	int host_status, len;
@


1.71
log
@typos; from solar
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.70 2001/09/20 13:46:48 markus Exp $");
a52 1
#include "tildexpand.h"
@


1.71.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.72 2001/11/07 22:41:51 markus Exp $");
d53 1
@


1.71.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.85 2002/02/24 19:14:59 markus Exp $");
d72 3
a74 2
static void input_service_request(int, u_int32_t, void *);
static void input_userauth_request(int, u_int32_t, void *);
d114 1
a114 1
do_authentication2(void)
d124 1
a124 1
	dispatch_init(&dispatch_protocol_error);
d131 11
a141 1
input_service_request(int type, u_int32_t seq, void *ctxt)
d147 1
a147 1
	packet_check_eom();
d174 1
a174 1
input_userauth_request(int type, u_int32_t seq, void *ctxt)
d215 1
a215 1
	auth2_challenge_stop(authctxt);
d217 6
d260 1
a260 1
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);
d317 1
a317 1
	packet_check_eom();
d333 1
a333 1
	packet_check_eom();
d347 1
a347 1

d350 1
a350 1
	packet_check_eom();
d366 2
a367 3
	Key *key = NULL;
	char *pkalg;
	u_char *pkblob, *sig;
d393 4
a396 3
		log("userauth_pubkey: unsupported public key algorithm: %s",
		    pkalg);
		goto done;
d399 25
a423 33
	if (key == NULL) {
		error("userauth_pubkey: cannot decode key: %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("userauth_pubkey: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
		goto done;
	}
	if (have_sig) {
		sig = packet_get_string(&slen);
		packet_check_eom();
		buffer_init(&b);
		if (datafellows & SSH_OLD_SESSIONID) {
			buffer_append(&b, session_id2, session_id2_len);
		} else {
			buffer_put_string(&b, session_id2, session_id2_len);
		}
		/* reconstruct packet */
		buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
		buffer_put_cstring(&b, authctxt->user);
		buffer_put_cstring(&b,
		    datafellows & SSH_BUG_PKSERVICE ?
		    "ssh-userauth" :
		    authctxt->service);
		if (datafellows & SSH_BUG_PKAUTH) {
			buffer_put_char(&b, have_sig);
		} else {
			buffer_put_cstring(&b, "publickey");
			buffer_put_char(&b, have_sig);
			buffer_put_cstring(&b, pkalg);
		}
		buffer_put_string(&b, pkblob, blen);
d425 1
a425 1
		buffer_dump(&b);
d427 9
a435 9
		/* test for correct signature */
		if (user_key_allowed(authctxt->pw, key) &&
		    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
			authenticated = 1;
		buffer_clear(&b);
		xfree(sig);
	} else {
		debug("test whether pkalg/pkblob are acceptable");
		packet_check_eom();
d437 16
a452 15
		/* XXX fake reply and always send PK_OK ? */
		/*
		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (user_key_allowed(authctxt->pw, key)) {
			packet_start(SSH2_MSG_USERAUTH_PK_OK);
			packet_put_string(pkalg, alen);
			packet_put_string(pkblob, blen);
			packet_send();
			packet_write_wait();
			authctxt->postponed = 1;
d454 3
a457 3
	if (authenticated != 1)
		auth_clear_options();
done:
a458 2
	if (key != NULL)
		key_free(key);
d468 2
a469 3
	Key *key = NULL;
	char *pkalg, *cuser, *chost, *service;
	u_char *pkblob, *sig;
d502 1
a502 6
		error("userauth_hostbased: cannot decode key: %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("userauth_hostbased: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
d527 2
a530 2
	if (key != NULL)
		key_free(key);
d553 1
a553 1
	Buffer b;
a555 1
	buffer_init(&b);
d560 16
a575 3
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, method->name, strlen(method->name));
a577 3
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
a604 1
	char *fp;
a671 4
			fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
			verbose("Found matching %s key: %s",
			    key_type(found), fp);
			xfree(fp);
d709 1
a709 2
	HostStatus host_status;
	int len;
d711 1
a711 1
	resolvedname = get_canonical_hostname(options.verify_reverse_mapping);
d749 1
@


1.71.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.91 2002/05/13 02:37:39 itojun Exp $");
d50 1
a53 2
#include "monitor_wrap.h"
#include "atomicio.h"
d60 1
a60 1
Authctxt *x_authctxt = NULL;
d78 2
a79 2
int user_key_allowed(struct passwd *, Key *);
int hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
d112 1
a112 1
Authctxt *
d126 1
a126 2

	return (authctxt);
d184 4
a187 2
		authctxt->pw = PRIVSEP(getpwnamallow(user));
		if (authctxt->pw && strcmp(service, "ssh-connection")==0) {
d193 1
a193 2
		setproctitle("%s%s", authctxt->pw ? user : "unknown",
		    use_privsep ? " [net]" : "");
a196 2
		if (use_privsep)
			mm_inform_authserv(service, style);
d262 2
a263 2
char *
auth2_read_banner(void)
d270 6
a275 6
	if ((fd = open(options.banner, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) == -1) {
		close(fd);
		return (NULL);
	}
d278 2
a279 7
	n = atomicio(read, fd, banner, len);
	close(fd);

	if (n != len) {
		free(banner);
		return (NULL);
	}
a280 15
	
	return (banner);
}

static void
userauth_banner(void)
{
	char *banner = NULL;

	if (options.banner == NULL || (datafellows & SSH_BUG_BANNER))
		return;

	if ((banner = PRIVSEP(auth2_read_banner())) == NULL)
		goto done;

d289 1
d302 1
a302 1
	return (authctxt->valid ? PRIVSEP(auth_password(authctxt, "")) : 0);
d318 1
a318 1
	    PRIVSEP(auth_password(authctxt, password)) == 1)
d419 2
a420 4
		authenticated = 0;
		if (PRIVSEP(user_key_allowed(authctxt->pw, key)) &&
		    PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b),
				buffer_len(&b))) == 1)
d436 1
a436 1
		if (PRIVSEP(user_key_allowed(authctxt->pw, key))) {
d520 2
a521 4
	authenticated = 0;
	if (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&
	    PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b),
			buffer_len(&b))) == 1)
d678 1
a678 1
int
d698 1
a698 1
int
@


1.71.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d26 3
a28 1
RCSID("$OpenBSD: auth2.c,v 1.93 2002/05/31 11:35:15 markus Exp $");
d32 2
d35 1
d39 2
d42 1
d44 3
d48 5
d54 1
d62 1
d64 5
a68 15
/* methods */

extern Authmethod method_none;
extern Authmethod method_pubkey;
extern Authmethod method_passwd;
extern Authmethod method_kbdint;
extern Authmethod method_hostbased;

Authmethod *authmethods[] = {
	&method_none,
	&method_pubkey,
	&method_passwd,
	&method_kbdint,
	&method_hostbased,
	NULL
d82 27
d265 298
d576 1
a578 1
	int i;
d581 2
a582 2
	for (i = 0; authmethods[i] != NULL; i++) {
		if (strcmp(authmethods[i]->name, "none") == 0)
d584 1
a584 2
		if (authmethods[i]->enabled != NULL &&
		    *(authmethods[i]->enabled) != 0) {
d587 1
a587 2
			buffer_append(&b, authmethods[i]->name,
			    strlen(authmethods[i]->name));
d599 1
a599 2
	int i;

d601 6
a606 7
		for (i = 0; authmethods[i] != NULL; i++)
			if (authmethods[i]->enabled != NULL &&
			    *(authmethods[i]->enabled) != 0 &&
			    strcmp(name, authmethods[i]->name) == 0)
				return authmethods[i];
	debug2("Unrecognized authentication method name: %s",
	    name ? name : "NULL");
d608 161
@


1.71.2.5
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.95 2002/08/22 21:33:58 markus Exp $");
d101 1
a101 1
	int acceptit = 0;
d110 1
a110 1
			acceptit = 1;
d117 1
a117 1
	if (acceptit) {
d198 1
a198 2
	if (!use_privsep &&
	    authenticated && authctxt->pw->pw_uid == 0 &&
@


1.70
log
@key_read returns now -1 or 1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.69 2001/07/23 18:14:58 stevesk Exp $");
d121 1
a121 1
	/* challenge-reponse is implemented via keyboard interactive */
@


1.69
log
@use %lu; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.68 2001/06/26 05:50:11 markus Exp $");
d648 1
a648 1
		if (key_read(found, &cp) == -1) {
d662 1
a662 1
			if (key_read(found, &cp) == -1) {
@


1.68
log
@new interface for secure_filename()
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.67 2001/06/25 20:26:37 stevesk Exp $");
d671 1
a671 1
			debug("matching key found: file %s, line %ld",
@


1.67
log
@prototype cleanup; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.66 2001/06/23 15:12:17 itojun Exp $");
d629 1
a629 1
	    secure_filename(f, file, pw->pw_uid, line, sizeof(line)) != 0) {
@


1.66
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.65 2001/06/23 03:04:43 markus Exp $");
d79 1
a79 1
char *authmethods_get(void);
d550 1
a550 1
char *
@


1.65
log
@restore correct ignore_user_known_hosts logic.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.64 2001/06/23 00:20:58 markus Exp $");
d73 3
a75 3
void	input_service_request(int type, int plen, void *ctxt);
void	input_userauth_request(int type, int plen, void *ctxt);
void	protocol_error(int type, int plen, void *ctxt);
d78 4
a81 6
Authmethod	*authmethod_lookup(const char *name);
char	*authmethods_get(void);
int	user_key_allowed(struct passwd *pw, Key *key);
int
hostbased_key_allowed(struct passwd *pw, const char *cuser, char *chost,
    Key *key);
d84 6
a89 7
void	userauth_banner(void);
void	userauth_reply(Authctxt *authctxt, int authenticated);
int	userauth_none(Authctxt *authctxt);
int	userauth_passwd(Authctxt *authctxt);
int	userauth_pubkey(Authctxt *authctxt);
int	userauth_hostbased(Authctxt *authctxt);
int	userauth_kbdint(Authctxt *authctxt);
d131 1
a131 1
void
d141 1
a141 1
void
d174 1
a174 1
void
d280 1
a280 1
void
d311 1
a311 1
int
d323 1
a323 1
int
d343 1
a343 1
int
d363 1
a363 1
int
d465 1
a465 1
int
d582 1
a582 1
Authmethod *
d597 1
a597 1
int
d685 1
a685 1
int
d705 1
a705 1
int
@


1.64
log
@*known_hosts2 is obsolete for hostbased authentication and
only used for backward compat. merge ssh1/2 hostkey check
and move it to auth.c
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.63 2001/06/22 21:55:49 markus Exp $");
d742 1
a742 1
            options.ignore_user_known_hosts ? _PATH_SSH_USER_HOSTFILE : NULL);
d748 2
a749 2
		    options.ignore_user_known_hosts ? _PATH_SSH_USER_HOSTFILE2 :
		    NULL);
@


1.63
log
@merge authorized_keys2 into authorized_keys.
authorized_keys2 is used for backward compat.
(just append authorized_keys2 to authorized_keys).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.62 2001/06/07 19:57:53 markus Exp $");
a711 1
	Key *found;
a712 2
	struct stat st;
	char *user_hostfile;
d740 10
a749 4
	/* XXX this is copied from auth-rh-rsa.c and should be shared */
	found = key_new(key->type);
	host_status = check_host_in_hostfile(_PATH_SSH_SYSTEM_HOSTFILE2, lookup,
	    key, found, NULL);
a750 22
	if (host_status != HOST_OK && !options.ignore_user_known_hosts) {
		user_hostfile = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE2,
		    pw->pw_uid);
		if (options.strict_modes &&
		    (stat(user_hostfile, &st) == 0) &&
		    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		     (st.st_mode & 022) != 0)) {
			log("Hostbased authentication refused for %.100s: "
			    "bad owner or modes for %.200s",
			    pw->pw_name, user_hostfile);
		} else {
			temporarily_use_uid(pw);
			host_status = check_host_in_hostfile(user_hostfile,
			    lookup, key, found, NULL);
			restore_uid();
		}
		xfree(user_hostfile);
	}
	key_free(found);

	debug2("userauth_hostbased: key %s for %s", host_status == HOST_OK ?
	    "ok" : "not found", lookup);
d753 1
@


1.62
log
@style is used for bsdauth.
disconnect on user/service change (ietf-drafts)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.61 2001/05/31 10:30:12 markus Exp $");
d601 1
a601 1
user_key_allowed(struct passwd *pw, Key *key)
d603 1
a603 1
	char line[8192], *file;
a615 2
	/* The authorized keys. */
	file = authorized_keys_file2(pw);
a621 1
		xfree(file);
a628 1
		xfree(file);
a632 1
		xfree(file);
a680 1
	xfree(file);
d685 20
@


1.61
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.60 2001/05/30 23:31:14 markus Exp $");
d211 6
a216 8
		authctxt->style = style ? xstrdup(style) : NULL; /* currently unused */
	} else if (authctxt->valid) {
		if (strcmp(user, authctxt->user) != 0 ||
		    strcmp(service, authctxt->service) != 0) {
			log("input_userauth_request: mismatch: (%s,%s)!=(%s,%s)",
			    user, service, authctxt->user, authctxt->service);
			authctxt->valid = 0;
		}
@


1.60
log
@merge
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.59 2001/05/30 12:55:06 markus Exp $");
d39 1
a39 1
#include "channel.h"
@


1.59
log
@channel layer cleanup: merge header files and split .c files
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.58 2001/05/20 17:20:35 markus Exp $");
d246 2
d260 23
a282 2
	if (!authctxt->postponed)
		userauth_reply(authctxt, authenticated);
a313 27
}

void
userauth_reply(Authctxt *authctxt, int authenticated)
{
	char *methods;

	/* XXX todo: check if multiple auth methods are needed */
	if (authenticated == 1) {
		/* turn off userauth */
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &protocol_error);
		packet_start(SSH2_MSG_USERAUTH_SUCCESS);
		packet_send();
		packet_write_wait();
		/* now we can break out */
		authctxt->success = 1;
	} else {
		if (authctxt->failures++ > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
		methods = authmethods_get();
		packet_start(SSH2_MSG_USERAUTH_FAILURE);
		packet_put_cstring(methods);
		packet_put_char(0);	/* XXX partial success, unused */
		packet_send();
		packet_write_wait();
		xfree(methods);
	}
@


1.58
log
@configurable authorized_keys{,2} location; originally from peter@@; ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.57 2001/05/18 14:13:28 markus Exp $");
d39 1
a39 1
#include "channels.h"
@


1.57
log
@improved kbd-interactive support. work by per@@appgate.com and me
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.56 2001/04/19 00:05:11 markus Exp $");
d609 1
a609 1
	char line[8192], file[MAXPATHLEN];
d623 2
a624 2
	snprintf(file, sizeof file, "%.500s/%.100s", pw->pw_dir,
	    _PATH_SSH_USER_PERMITTED_KEYS2);
d630 1
d638 1
d641 7
a647 39
	if (options.strict_modes) {
		int fail = 0;
		char buf[1024];
		/* Check open file in order to avoid open/stat races */
		if (fstat(fileno(f), &st) < 0 ||
		    (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		    (st.st_mode & 022) != 0) {
			snprintf(buf, sizeof buf,
			    "%s authentication refused for %.100s: "
			    "bad ownership or modes for '%s'.",
			    key_type(key), pw->pw_name, file);
			fail = 1;
		} else {
			/* Check path to _PATH_SSH_USER_PERMITTED_KEYS */
			int i;
			static const char *check[] = {
				"", _PATH_SSH_USER_DIR, NULL
			};
			for (i = 0; check[i]; i++) {
				snprintf(line, sizeof line, "%.500s/%.100s",
				    pw->pw_dir, check[i]);
				if (stat(line, &st) < 0 ||
				    (st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
				    (st.st_mode & 022) != 0) {
					snprintf(buf, sizeof buf,
					    "%s authentication refused for %.100s: "
					    "bad ownership or modes for '%s'.",
					    key_type(key), pw->pw_name, line);
					fail = 1;
					break;
				}
			}
		}
		if (fail) {
			fclose(f);
			log("%s", buf);
			restore_uid();
			return 0;
		}
d649 1
d692 1
@


1.56
log
@use local variable, no function call needed.
(btw, hostbased works now with ssh.com >= 2.0.13)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.55 2001/04/18 23:43:25 markus Exp $");
d54 1
d125 1
a125 1
	if (options.challenge_reponse_authentication)
d356 2
a357 3
	char *lang = NULL;
	char *devs = NULL;

d362 1
a362 1
	debug("keyboard-interactive language %s devs %s", lang, devs);
d364 1
a364 1
	if (options.challenge_reponse_authentication)
d367 1
a368 1
	xfree(devs);
@


1.56.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.70 2001/09/20 13:46:48 markus Exp $");
a53 1
#include "match.h"
d72 3
a74 3
static void input_service_request(int, int, void *);
static void input_userauth_request(int, int, void *);
static void protocol_error(int, int, void *);
d77 6
a82 4
static Authmethod *authmethod_lookup(const char *);
static char *authmethods_get(void);
static int user_key_allowed(struct passwd *, Key *);
static int hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
d85 7
a91 6
static void userauth_banner(void);
static int userauth_none(Authctxt *);
static int userauth_passwd(Authctxt *);
static int userauth_pubkey(Authctxt *);
static int userauth_hostbased(Authctxt *);
static int userauth_kbdint(Authctxt *);
d124 1
a124 1
	if (options.challenge_response_authentication)
d133 1
a133 1
static void
d143 1
a143 1
static void
d176 1
a176 1
static void
d210 8
a217 6
		authctxt->style = style ? xstrdup(style) : NULL;
	} else if (strcmp(user, authctxt->user) != 0 ||
	    strcmp(service, authctxt->service) != 0) {
		packet_disconnect("Change of username or service not allowed: "
		    "(%s,%s) -> (%s,%s)",
		    authctxt->user, authctxt->service, user, service);
a244 2
	char *methods;

d257 2
a258 23
	if (authctxt->postponed)
		return;

	/* XXX todo: check if multiple auth methods are needed */
	if (authenticated == 1) {
		/* turn off userauth */
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &protocol_error);
		packet_start(SSH2_MSG_USERAUTH_SUCCESS);
		packet_send();
		packet_write_wait();
		/* now we can break out */
		authctxt->success = 1;
	} else {
		if (authctxt->failures++ > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
		methods = authmethods_get();
		packet_start(SSH2_MSG_USERAUTH_FAILURE);
		packet_put_cstring(methods);
		packet_put_char(0);	/* XXX partial success, unused */
		packet_send();
		packet_write_wait();
		xfree(methods);
	}
d261 1
a261 1
static void
d292 28
a319 1
static int
d331 1
a331 1
static int
d351 1
a351 1
static int
d355 3
a357 2
	char *lang, *devs;
	
d362 1
a362 1
	debug("keyboard-interactive devs %s", devs);
d364 1
a364 1
	if (options.challenge_response_authentication)
d367 1
a368 1
	xfree(lang);
d372 1
a372 1
static int
d474 1
a474 1
static int
d559 1
a559 1
static char *
d591 1
a591 1
static Authmethod *
d606 2
a607 2
static int
user_key_allowed2(struct passwd *pw, Key *key, char *file)
d609 1
a609 1
	char line[8192];
d622 3
a624 1
	debug("trying public key file %s", file);
d639 39
a677 6
	if (options.strict_modes &&
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
		fclose(f);
		log("Authentication refused: %s", line);
		restore_uid();
		return 0;
a678 1

d691 1
a691 1
		if (key_read(found, &cp) != 1) {
d705 1
a705 1
			if (key_read(found, &cp) != 1) {
d714 1
a714 1
			debug("matching key found: file %s, line %lu",
a726 20
/* check whether given key is in .ssh/authorized_keys* */
static int
user_key_allowed(struct passwd *pw, Key *key)
{
	int success;
	char *file;

	file = authorized_keys_file(pw);
	success = user_key_allowed2(pw, key, file);
	xfree(file);
	if (success)
		return success;

	/* try suffix "2" for backward compat, too */
	file = authorized_keys_file2(pw);
	success = user_key_allowed2(pw, key, file);
	xfree(file);
	return success;
}

d728 1
a728 1
static int
d732 1
d734 2
d763 24
a786 10
	host_status = check_key_in_hostfiles(pw, key, lookup,
	    _PATH_SSH_SYSTEM_HOSTFILE,
	    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);

	/* backward compat if no key has been found. */
	if (host_status == HOST_NEW)
		host_status = check_key_in_hostfiles(pw, key, lookup,
		    _PATH_SSH_SYSTEM_HOSTFILE2,
		    options.ignore_user_known_hosts ? NULL :
		    _PATH_SSH_USER_HOSTFILE2);
d788 2
a791 1

@


1.56.2.2
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.56.2.1 2001/09/27 19:03:54 jason Exp $");
d121 1
a121 1
	/* challenge-response is implemented via keyboard interactive */
@


1.56.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.56.2.2 2001/11/15 00:15:19 miod Exp $");
d53 1
@


1.56.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.85 2002/02/24 19:14:59 markus Exp $");
d72 3
a74 2
static void input_service_request(int, u_int32_t, void *);
static void input_userauth_request(int, u_int32_t, void *);
d114 1
a114 1
do_authentication2(void)
d124 1
a124 1
	dispatch_init(&dispatch_protocol_error);
d131 11
a141 1
input_service_request(int type, u_int32_t seq, void *ctxt)
d147 1
a147 1
	packet_check_eom();
d174 1
a174 1
input_userauth_request(int type, u_int32_t seq, void *ctxt)
d215 1
a215 1
	auth2_challenge_stop(authctxt);
d217 6
d260 1
a260 1
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);
d317 1
a317 1
	packet_check_eom();
d333 1
a333 1
	packet_check_eom();
d347 1
a347 1

d350 1
a350 1
	packet_check_eom();
d366 2
a367 3
	Key *key = NULL;
	char *pkalg;
	u_char *pkblob, *sig;
d393 4
a396 3
		log("userauth_pubkey: unsupported public key algorithm: %s",
		    pkalg);
		goto done;
d399 25
a423 33
	if (key == NULL) {
		error("userauth_pubkey: cannot decode key: %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("userauth_pubkey: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
		goto done;
	}
	if (have_sig) {
		sig = packet_get_string(&slen);
		packet_check_eom();
		buffer_init(&b);
		if (datafellows & SSH_OLD_SESSIONID) {
			buffer_append(&b, session_id2, session_id2_len);
		} else {
			buffer_put_string(&b, session_id2, session_id2_len);
		}
		/* reconstruct packet */
		buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
		buffer_put_cstring(&b, authctxt->user);
		buffer_put_cstring(&b,
		    datafellows & SSH_BUG_PKSERVICE ?
		    "ssh-userauth" :
		    authctxt->service);
		if (datafellows & SSH_BUG_PKAUTH) {
			buffer_put_char(&b, have_sig);
		} else {
			buffer_put_cstring(&b, "publickey");
			buffer_put_char(&b, have_sig);
			buffer_put_cstring(&b, pkalg);
		}
		buffer_put_string(&b, pkblob, blen);
d425 1
a425 1
		buffer_dump(&b);
d427 9
a435 9
		/* test for correct signature */
		if (user_key_allowed(authctxt->pw, key) &&
		    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
			authenticated = 1;
		buffer_clear(&b);
		xfree(sig);
	} else {
		debug("test whether pkalg/pkblob are acceptable");
		packet_check_eom();
d437 16
a452 15
		/* XXX fake reply and always send PK_OK ? */
		/*
		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (user_key_allowed(authctxt->pw, key)) {
			packet_start(SSH2_MSG_USERAUTH_PK_OK);
			packet_put_string(pkalg, alen);
			packet_put_string(pkblob, blen);
			packet_send();
			packet_write_wait();
			authctxt->postponed = 1;
d454 3
a457 3
	if (authenticated != 1)
		auth_clear_options();
done:
a458 2
	if (key != NULL)
		key_free(key);
d468 2
a469 3
	Key *key = NULL;
	char *pkalg, *cuser, *chost, *service;
	u_char *pkblob, *sig;
d502 1
a502 6
		error("userauth_hostbased: cannot decode key: %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("userauth_hostbased: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
d527 2
a530 2
	if (key != NULL)
		key_free(key);
d553 1
a553 1
	Buffer b;
a555 1
	buffer_init(&b);
d560 16
a575 3
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, method->name, strlen(method->name));
a577 3
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
a604 1
	char *fp;
a671 4
			fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
			verbose("Found matching %s key: %s",
			    key_type(found), fp);
			xfree(fp);
d709 1
a709 2
	HostStatus host_status;
	int len;
d711 1
a711 1
	resolvedname = get_canonical_hostname(options.verify_reverse_mapping);
d749 1
@


1.56.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.91 2002/05/13 02:37:39 itojun Exp $");
d50 1
a53 2
#include "monitor_wrap.h"
#include "atomicio.h"
d60 1
a60 1
Authctxt *x_authctxt = NULL;
d78 2
a79 2
int user_key_allowed(struct passwd *, Key *);
int hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
d112 1
a112 1
Authctxt *
d126 1
a126 2

	return (authctxt);
d184 4
a187 2
		authctxt->pw = PRIVSEP(getpwnamallow(user));
		if (authctxt->pw && strcmp(service, "ssh-connection")==0) {
d193 1
a193 2
		setproctitle("%s%s", authctxt->pw ? user : "unknown",
		    use_privsep ? " [net]" : "");
a196 2
		if (use_privsep)
			mm_inform_authserv(service, style);
d262 2
a263 2
char *
auth2_read_banner(void)
d270 6
a275 6
	if ((fd = open(options.banner, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) == -1) {
		close(fd);
		return (NULL);
	}
d278 2
a279 7
	n = atomicio(read, fd, banner, len);
	close(fd);

	if (n != len) {
		free(banner);
		return (NULL);
	}
a280 15
	
	return (banner);
}

static void
userauth_banner(void)
{
	char *banner = NULL;

	if (options.banner == NULL || (datafellows & SSH_BUG_BANNER))
		return;

	if ((banner = PRIVSEP(auth2_read_banner())) == NULL)
		goto done;

d289 1
d302 1
a302 1
	return (authctxt->valid ? PRIVSEP(auth_password(authctxt, "")) : 0);
d318 1
a318 1
	    PRIVSEP(auth_password(authctxt, password)) == 1)
d419 2
a420 4
		authenticated = 0;
		if (PRIVSEP(user_key_allowed(authctxt->pw, key)) &&
		    PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b),
				buffer_len(&b))) == 1)
d436 1
a436 1
		if (PRIVSEP(user_key_allowed(authctxt->pw, key))) {
d520 2
a521 4
	authenticated = 0;
	if (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&
	    PRIVSEP(key_verify(key, sig, slen, buffer_ptr(&b),
			buffer_len(&b))) == 1)
d678 1
a678 1
int
d698 1
a698 1
int
@


1.55
log
@more ssh v2 hostbased-auth interop: ssh.com >= 2.1.0 works now
(however the 2.1.0 server seems to work only if debug is enabled...)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.54 2001/04/18 22:48:26 markus Exp $");
d431 1
a431 1
				buffer_put_cstring(&b, key_ssh_name(key));
@


1.54
log
@no longer const
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.53 2001/04/18 22:03:44 markus Exp $");
d479 1
a479 2
	char *pkalg, *pkblob, *sig;
	char *cuser, *chost;
d515 2
d518 1
a518 7
	if (datafellows & SSH_OLD_SESSIONID) {
		buffer_append(&b, session_id2, session_id2_len);
	} else {
		buffer_put_string(&b, session_id2, session_id2_len);
	}
	if (datafellows & SSH_BUG_HBSERVICE)
		debug("SSH_BUG_HBSERVICE");
d522 1
a522 4
	buffer_put_cstring(&b,
	    datafellows & SSH_BUG_HBSERVICE ?
	    "ssh-userauth" :
	    authctxt->service);
@


1.53
log
@use FDQN with trailing dot in the hostbased auth packets, ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.52 2001/04/12 19:15:24 markus Exp $");
d81 1
a81 1
hostbased_key_allowed(struct passwd *pw, const char *cuser, const char *chost,
d737 1
a737 1
hostbased_key_allowed(struct passwd *pw, const char *cuser, const char *chost,
@


1.52
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.51 2001/04/06 21:00:08 markus Exp $");
d744 1
a744 1
	int host_status;
d749 2
a750 2
	debug2("userauth_hostbased: resolvedname %s ipaddr %s",
	    resolvedname, ipaddr);
d757 4
@


1.51
log
@do gid/groups-swap in addition to uid-swap, should help if /home/group
is chmod 750 + chgrp grp /home/group/, work be deraadt and me, thanks
to olar@@openwall.com is comments.  we had many requests for this.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.50 2001/04/04 20:32:56 markus Exp $");
d51 3
d78 1
d80 3
a82 1
char	*authmethods_get(void);
d90 1
d106 3
d214 1
a214 1
			log("input_userauth_request: missmatch: (%s,%s)!=(%s,%s)",
d474 83
d733 62
@


1.50
log
@we don't care about missing bannerfiles; from tsoome@@ut.ee, ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.49 2001/03/28 22:43:31 markus Exp $");
d535 1
a535 1
	temporarily_use_uid(pw->pw_uid);
@


1.49
log
@check auth_root_allowed for kbd-int auth, too.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.48 2001/03/21 11:43:44 markus Exp $");
d261 1
a261 3
	if ((fd = open(options.banner, O_RDONLY)) < 0) {
		error("userauth_banner: open %s failed: %s",
		    options.banner, strerror(errno));
a262 1
	}
@


1.48
log
@merge common ssh v1/2 code
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.47 2001/03/20 18:57:04 markus Exp $");
d80 1
d225 10
a248 4

	xfree(service);
	xfree(user);
	xfree(method);
@


1.47
log
@add changes need for BSD_AUTH plus disabled BSD_AUTH code
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.46 2001/03/11 13:25:36 markus Exp $");
d119 1
a119 1
	do_authenticated2(authctxt);
@


1.46
log
@debug
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.45 2001/03/04 01:46:29 djm Exp $");
d211 6
d314 1
a314 1
	return authctxt->valid ? auth_password(authctxt->pw, "") : 0;
d330 1
a330 1
	    auth_password(authctxt->pw, password) == 1)
@


1.45
log
@Rename pty.[ch] -> sshpty.[ch] and login.[ch] to sshlogin.[ch] to avoid
header conflicts in portable; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.44 2001/03/01 02:45:10 deraadt Exp $");
d627 2
@


1.44
log
@KNF
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.43 2001/02/22 21:59:44 markus Exp $");
d33 1
a33 1
#include "pty.h"
@


1.43
log
@use pwcopy in ssh.c, too
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.42 2001/02/13 22:49:40 markus Exp $");
d579 1
a579 1
			log("%s",buf);
@


1.42
log
@setproctitle(user) only if getpwnam succeeds
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.41 2001/02/12 16:16:23 markus Exp $");
d50 1
a74 1
struct passwd	*pwcopy(struct passwd *pw);
@


1.41
log
@PermitRootLogin={yes,without-password,forced-commands-only,no}
(before this change, root could login even if PermitRootLogin==no)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.40 2001/02/10 12:52:02 markus Exp $");
a187 1
		setproctitle("%s", user);
d196 1
@


1.40
log
@offer passwd before s/key
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.39 2001/02/08 18:20:01 markus Exp $");
d223 2
a224 1
	if (authenticated && authctxt->pw->pw_uid == 0 && !auth_root_allowed())
@


1.39
log
@strict checking
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.38 2001/02/08 18:12:30 markus Exp $");
d92 3
a97 3
	{"password",
		userauth_passwd,
		&options.password_authentication},
@


1.38
log
@fix typo
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.37 2001/02/07 22:35:46 markus Exp $");
d277 1
a277 1
	if (authenticated) {
@


1.37
log
@move k_setpag() to a central place; ok dugsong@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.36 2001/02/04 15:32:22 stevesk Exp $");
d440 1
a440 1
				authenticated = -1;
@


1.36
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.35 2001/02/04 13:30:11 stevesk Exp $");
a115 7
#ifdef AFS
	/* If machine has AFS, set process authentication group. */
	if (k_hasafs()) {
		k_setpag();
		k_unlog();
	}
#endif
@


1.35
log
@remove duplicate #include's; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.34 2001/01/22 23:06:39 markus Exp $");
d192 1
a192 1
	if (authctxt->attempt++ == 0) { 
d278 1
a278 1
void   
d294 1
a294 1
                        packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
@


1.34
log
@rename skey -> challenge response.
auto-enable kbd-interactive for ssh2 if challenge-reponse is enabled.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.33 2001/01/22 08:32:53 markus Exp $");
a43 1
#include "auth.h"
@


1.33
log
@no need to include; from mouring@@etoh.eviladmin.org
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.32 2001/01/21 19:05:44 markus Exp $");
d113 4
d351 2
a352 1
	authenticated = auth2_challenge(authctxt, devs);
@


1.32
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.31 2001/01/20 17:34:25 markus Exp $");
a47 1
#include "kex.h"
a48 1

@


1.31
log
@typo
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.30 2001/01/20 15:55:20 markus Exp $");
a27 2
#include <openssl/dsa.h>
#include <openssl/rsa.h>
d30 1
a32 1
#include "ssh.h"
d36 1
a40 1
#include "ssh2.h"
d46 2
@


1.30
log
@pass the filename to auth_parse_options()
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.29 2001/01/19 15:55:10 markus Exp $");
d518 1
a518 1
	char line[8192], file[MAXPATHNAME];
@


1.29
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.28 2001/01/18 17:00:00 markus Exp $");
d518 1
a518 1
	char line[8192], file[1024];
d621 1
a621 1
		    auth_parse_options(pw, options, linenum) == 1) {
@


1.28
log
@1) removes fake skey from sshd, since this will be much
   harder with /usr/libexec/auth/login_XXX
2) share/unify code used in ssh-1 and ssh-2 authentication (server side)
3) make addition of BSD_AUTH and other challenge reponse methods
   easier.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.27 2001/01/13 18:56:48 markus Exp $");
d49 1
d533 1
a533 1
	    SSH_USER_PERMITTED_KEYS2);
d561 1
a561 1
			/* Check path to SSH_USER_PERMITTED_KEYS */
d564 1
a564 1
				"", SSH_USER_DIR, NULL
@


1.27
log
@support supplementary group in {Allow,Deny}Groups
from stevesk@@pobox.com
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.26 2001/01/13 18:21:48 markus Exp $");
a73 1

d110 2
a111 6
	Authctxt *authctxt = xmalloc(sizeof(*authctxt));
	memset(authctxt, 'a', sizeof(*authctxt));
	authctxt->valid = 0;
	authctxt->attempt = 0;
	authctxt->failures = 0;
	authctxt->success = 0;
d124 1
a124 1
	do_authenticated2();
d175 1
a175 1
	char *user, *service, *method;
d187 3
d204 1
d213 3
d217 1
a221 6
	} else {
		debug2("input_userauth_request: unsupported method %s", method);
	}
	if (!authctxt->valid && authenticated == 1) {
		log("input_userauth_request: INTERNAL ERROR: authenticated invalid user %s service %s", user, method);
		authenticated = 0;
d223 3
d228 1
a228 2
	if (authenticated == 1 &&
	    authctxt->valid && authctxt->pw->pw_uid == 0 && !options.permit_root_login) {
a229 2
		log("ROOT LOGIN REFUSED FROM %.200s", get_canonical_hostname());
	}
d232 4
a235 2
	userauth_log(authctxt, authenticated, method);
	userauth_reply(authctxt, authenticated);
a275 35
void
userauth_log(Authctxt *authctxt, int authenticated, char *method)
{
	void (*authlog) (const char *fmt,...) = verbose;
	char *user = NULL, *authmsg = NULL;

	/* Raise logging level */
	if (authenticated == 1 ||
	    !authctxt->valid ||
	    authctxt->failures >= AUTH_FAIL_LOG ||
	    strcmp(method, "password") == 0)
		authlog = log;

	if (authenticated == 1) {
		authmsg = "Accepted";
	} else if (authenticated == 0) {
		authmsg = "Failed";
	} else {
		authmsg = "Postponed";
	}

	if (authctxt->valid) {
		user = authctxt->pw->pw_uid == 0 ? "ROOT" : authctxt->user;
	} else {
		user = authctxt->user ? authctxt->user : "NOUSER";
	}

	authlog("%s %s for %.200s from %.200s port %d ssh2",
	    authmsg,
	    method,
	    user,
	    get_remote_ipaddr(),
	    get_remote_port());
}

d280 1
d282 1
a282 1
	if (authenticated == 1) {
d290 3
a292 3
	} else if (authenticated == 0) {
		if (authctxt->failures++ >= AUTH_FAIL_MAX)
			packet_disconnect("too many failed userauth_requests");
a299 2
	} else {
		/* do nothing, we did already send a reply */
d347 3
a349 5
#ifdef SKEY
	/* XXX hardcoded, we should look at devs */
	if (options.skey_authentication != 0)
		authenticated = auth2_skey(authctxt);
#endif
a630 15
}

struct passwd *
pwcopy(struct passwd *pw)
{
	struct passwd *copy = xmalloc(sizeof(*copy));
	memset(copy, 0, sizeof(*copy));
	copy->pw_name = xstrdup(pw->pw_name);
	copy->pw_passwd = xstrdup(pw->pw_passwd);
	copy->pw_uid = pw->pw_uid;
	copy->pw_gid = pw->pw_gid;
	copy->pw_class = xstrdup(pw->pw_class);
	copy->pw_dir = xstrdup(pw->pw_dir);
	copy->pw_shell = xstrdup(pw->pw_shell);
	return copy;
@


1.26
log
@enable kerberos passwd auth in ssh2, use k_setpag; ok hin, dugsong, from ksulliva@@psc.edu
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.25 2001/01/08 22:29:05 markus Exp $");
d301 1
a301 1
		user = "NOUSER";
@


1.25
log
@implement option 'Banner /etc/issue.net' for ssh2, move version to
2.3.1 (needed for bugcompat detection, 2.3.0 would fail if Banner
is enabled).
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.24 2000/12/28 14:25:51 markus Exp $");
d119 6
a124 3
#ifdef KRB4
	/* turn off kerberos, not supported by SSH2 */
	options.kerberos_authentication = 0;
@


1.24
log
@count authentication failures only
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.23 2000/12/19 23:17:55 markus Exp $");
d82 1
d240 33
d345 1
@


1.23
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.22 2000/12/03 11:15:02 markus Exp $");
d114 1
a180 2
	if (authctxt->attempt++ >= AUTH_FAIL_MAX)
		packet_disconnect("too many failed userauth_requests");
d186 1
a186 1
	debug("attempt #%d", authctxt->attempt);
d188 1
a188 1
	if (authctxt->attempt == 1) { 
d249 1
a249 1
	    authctxt->attempt >= AUTH_FAIL_LOG ||
d278 1
d289 3
a291 1
		char *methods = authmethods_get();
@


1.22
log
@support f-secure/ssh.com 2.0.12; ok niels@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.21 2000/11/12 19:50:37 markus Exp $");
d55 1
a55 1
extern unsigned char *session_id2;
d141 1
a141 1
	unsigned int len;
d318 1
a318 1
	unsigned int len;
d360 1
a360 1
	unsigned int alen, blen, slen;
d470 1
a470 1
	unsigned int size = 0;
d519 1
a519 1
	unsigned long linenum = 0;
@


1.21
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.20 2000/10/14 12:16:56 markus Exp $");
d369 13
a381 1
	pkalg = packet_get_string(&alen);
d384 2
a385 1
		log("bad pkalg %s", pkalg);
d387 1
a389 1
	pkblob = packet_get_string(&blen);
d405 1
a405 1
			    datafellows & SSH_BUG_PUBKEYAUTH ?
d408 7
a414 3
			buffer_put_cstring(&b, "publickey");
			buffer_put_char(&b, have_sig);
			buffer_put_cstring(&b, key_ssh_name(key));
@


1.20
log
@OpenSSH_2.3; note that is is not complete, but the version number needs to be changed for interoperability reasons
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.19 2000/10/11 20:27:23 markus Exp $");
a49 1
#include "dsa.h"
d78 1
a78 1
int	user_dsa_key_allowed(struct passwd *pw, Key *key);
d93 1
a93 1
		&options.dsa_authentication},
d361 1
a361 1
	int have_sig;
d370 3
a372 2
	if (strcmp(pkalg, KEX_DSS) != 0) {
		log("bad pkalg %s", pkalg);	/*XXX*/
d377 1
a377 1
	key = dsa_key_from_blob(pkblob, blen);
d397 1
a397 1
			buffer_put_cstring(&b, KEX_DSS);
d399 1
a399 1
#ifdef DEBUG_DSS
d403 2
a404 2
			if (user_dsa_key_allowed(authctxt->pw, key) &&
			    dsa_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
d420 1
a420 1
			if (user_dsa_key_allowed(authctxt->pw, key)) {
d433 1
d497 1
a497 1
user_dsa_key_allowed(struct passwd *pw, Key *key)
a500 1
	unsigned int bits = -1;
d581 1
a581 2
		bits = key_read(found, &cp);
		if (bits == 0) {
d584 1
d595 2
a596 2
			bits = key_read(found, &cp);
			if (bits == 0) {
@


1.20.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.42 2001/02/13 22:49:40 markus Exp $");
d28 2
a31 1
#include "ssh2.h"
d34 1
a37 1
#include "log.h"
d42 1
d46 1
a47 1
#include "cipher.h"
d49 2
a50 1
#include "pathnames.h"
d56 1
a56 1
extern u_char *session_id2;
d75 1
d79 1
a79 1
int	user_key_allowed(struct passwd *pw, Key *key);
a82 1
void	userauth_banner(void);
d94 4
a97 1
		&options.pubkey_authentication},
a100 3
	{"keyboard-interactive",
		userauth_kbdint,
		&options.kbd_interactive_authentication},
d111 5
a115 2
	Authctxt *authctxt = authctxt_new();

d118 4
a121 4
	/* challenge-reponse is implemented via keyboard interactive */
	if (options.challenge_reponse_authentication)
		options.kbd_interactive_authentication = 1;

d125 1
a125 1
	do_authenticated2(authctxt);
d142 1
a142 1
	u_int len;
d176 1
a176 1
	char *user, *service, *method, *style = NULL;
d181 2
d188 1
a188 4
	debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);

	if ((style = strchr(user, ':')) != NULL)
		*style++ = 0;
d190 1
a190 1
	if (authctxt->attempt++ == 0) {
d193 1
a201 1
		setproctitle("%s", pw ? user : "unknown");
a203 1
		authctxt->style = style ? xstrdup(style) : NULL; /* currently unused */
a211 3
	/* reset state */
	dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, &protocol_error);
	authctxt->postponed = 0;
a212 1
	/* try to authenticate user */
d217 6
a223 3
	if (!authctxt->valid && authenticated)
		fatal("INTERNAL ERROR: authenticated invalid user %s",
		    authctxt->user);
d226 2
a227 2
	if (authenticated && authctxt->pw->pw_uid == 0 &&
	    !auth_root_allowed(method))
d229 2
d233 2
a234 4
	auth_log(authctxt, authenticated, method, " ssh2");

	if (!authctxt->postponed)
		userauth_reply(authctxt, authenticated);
d241 1
d243 1
a243 1
userauth_banner(void)
d245 30
a274 29
	struct stat st;
	char *banner = NULL;
	off_t len, n;
	int fd;

	if (options.banner == NULL || (datafellows & SSH_BUG_BANNER))
		return;
	if ((fd = open(options.banner, O_RDONLY)) < 0) {
		error("userauth_banner: open %s failed: %s",
		    options.banner, strerror(errno));
		return;
	}
	if (fstat(fd, &st) < 0)
		goto done;
	len = st.st_size;
	banner = xmalloc(len + 1);
	if ((n = read(fd, banner, len)) < 0)
		goto done;
	banner[n] = '\0';
	packet_start(SSH2_MSG_USERAUTH_BANNER);
	packet_put_cstring(banner);
	packet_put_cstring("");		/* language, unused */
	packet_send();
	debug("userauth_banner: sent");
done:
	if (banner)
		xfree(banner);
	close(fd);
	return;
d277 1
a277 1
void
a279 2
	char *methods;

d289 2
a290 4
	} else {
		if (authctxt->failures++ > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
		methods = authmethods_get();
d297 2
a309 1
	userauth_banner();
d319 1
a319 1
	u_int len;
d345 5
a349 4

	if (options.challenge_reponse_authentication)
		authenticated = auth2_challenge(authctxt, devs);

d361 2
a362 2
	u_int alen, blen, slen;
	int have_sig, pktype;
d370 3
a372 17
	if (datafellows & SSH_BUG_PKAUTH) {
		debug2("userauth_pubkey: SSH_BUG_PKAUTH");
		/* no explicit pkalg given */
		pkblob = packet_get_string(&blen);
		buffer_init(&b);
		buffer_append(&b, pkblob, blen);
		/* so we have to extract the pkalg from the pkblob */
		pkalg = buffer_get_string(&b, &alen);
		buffer_free(&b);
	} else {
		pkalg = packet_get_string(&alen);
		pkblob = packet_get_string(&blen);
	}
	pktype = key_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		log("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
a373 1
		xfree(pkblob);
d376 2
a377 1
	key = key_from_blob(pkblob, blen);
d392 1
a392 1
			    datafellows & SSH_BUG_PKSERVICE ?
d395 3
a397 7
			if (datafellows & SSH_BUG_PKAUTH) {
				buffer_put_char(&b, have_sig);
			} else {
				buffer_put_cstring(&b, "publickey");
				buffer_put_char(&b, have_sig);
				buffer_put_cstring(&b, key_ssh_name(key));
			}
d399 1
a399 1
#ifdef DEBUG_PK
d403 2
a404 2
			if (user_key_allowed(authctxt->pw, key) &&
			    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
d420 1
a420 1
			if (user_key_allowed(authctxt->pw, key)) {
d426 1
a426 1
				authctxt->postponed = 1;
a432 1
	debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
d452 1
a452 1
	u_int size = 0;
d496 1
a496 1
user_key_allowed(struct passwd *pw, Key *key)
d498 1
a498 1
	char line[8192], file[MAXPATHLEN];
d500 1
d502 1
a502 1
	u_long linenum = 0;
d514 1
a514 1
	    _PATH_SSH_USER_PERMITTED_KEYS2);
d542 1
a542 1
			/* Check path to _PATH_SSH_USER_PERMITTED_KEYS */
d545 1
a545 1
				"", _PATH_SSH_USER_DIR, NULL
d581 2
a582 1
		if (key_read(found, &cp) == -1) {
a584 1
			debug2("user_key_allowed: check options: '%s'", cp);
d595 2
a596 2
			if (key_read(found, &cp) == -1) {
				debug2("user_key_allowed: advance: '%s'", cp);
d602 1
a602 1
		    auth_parse_options(pw, options, file, linenum) == 1) {
d613 15
@


1.20.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.20.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.46 2001/03/11 13:25:36 markus Exp $");
d33 1
a33 1
#include "sshpty.h"
a49 1
#include "misc.h"
d74 1
d579 1
a579 1
			log("%s", buf);
a626 2
	if (!found_key)
		debug2("key not found");
@


1.20.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.56 2001/04/19 00:05:11 markus Exp $");
a50 3
#include "hostfile.h"
#include "canohost.h"
#include "tildexpand.h"
d75 1
a76 4
int	user_key_allowed(struct passwd *pw, Key *key);
int
hostbased_key_allowed(struct passwd *pw, const char *cuser, char *chost,
    Key *key);
a79 1
void	userauth_reply(Authctxt *authctxt, int authenticated);
a82 1
int	userauth_hostbased(Authctxt *authctxt);
a97 3
	{"hostbased",
		userauth_hostbased,
		&options.hostbased_authentication},
d119 1
a119 1
	do_authenticated(authctxt);
d203 1
a203 1
			log("input_userauth_request: mismatch: (%s,%s)!=(%s,%s)",
a210 6
#ifdef BSD_AUTH
	if (authctxt->as) {
		auth_close(authctxt->as);
		authctxt->as = NULL;
	}
#endif
a217 10
	userauth_finish(authctxt, authenticated, method);

	xfree(service);
	xfree(user);
	xfree(method);
}

void
userauth_finish(Authctxt *authctxt, int authenticated, char *method)
{
d232 4
d248 3
a250 1
	if ((fd = open(options.banner, O_RDONLY)) < 0)
d252 1
d308 1
a308 1
	return authctxt->valid ? auth_password(authctxt, "") : 0;
d324 1
a324 1
	    auth_password(authctxt, password) == 1)
d411 1
a411 1
				buffer_put_cstring(&b, pkalg);
a453 75
int
userauth_hostbased(Authctxt *authctxt)
{
	Buffer b;
	Key *key;
	char *pkalg, *pkblob, *sig, *cuser, *chost, *service;
	u_int alen, blen, slen;
	int pktype;
	int authenticated = 0;

	if (!authctxt->valid) {
		debug2("userauth_hostbased: disabled because of invalid user");
		return 0;
	}
	pkalg = packet_get_string(&alen);
	pkblob = packet_get_string(&blen);
	chost = packet_get_string(NULL);
	cuser = packet_get_string(NULL);
	sig = packet_get_string(&slen);

	debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d",
	    cuser, chost, pkalg, slen);
#ifdef DEBUG_PK
	debug("signature:");
	buffer_init(&b);
	buffer_append(&b, sig, slen);
	buffer_dump(&b);
	buffer_free(&b);
#endif
	pktype = key_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		log("userauth_hostbased: unsupported "
		    "public key algorithm: %s", pkalg);
		goto done;
	}
	key = key_from_blob(pkblob, blen);
	if (key == NULL) {
		debug("userauth_hostbased: cannot decode key: %s", pkalg);
		goto done;
	}
	service = datafellows & SSH_BUG_HBSERVICE ? "ssh-userauth" :
	    authctxt->service;
	buffer_init(&b);
	buffer_put_string(&b, session_id2, session_id2_len);
	/* reconstruct packet */
	buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
	buffer_put_cstring(&b, authctxt->user);
	buffer_put_cstring(&b, service);
	buffer_put_cstring(&b, "hostbased");
	buffer_put_string(&b, pkalg, alen);
	buffer_put_string(&b, pkblob, blen);
	buffer_put_cstring(&b, chost);
	buffer_put_cstring(&b, cuser);
#ifdef DEBUG_PK
	buffer_dump(&b);
#endif
	/* test for allowed key and correct signature */
	if (hostbased_key_allowed(authctxt->pw, cuser, chost, key) &&
	    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
		authenticated = 1;

	buffer_clear(&b);
	key_free(key);

done:
	debug2("userauth_hostbased: authenticated %d", authenticated);
	xfree(pkalg);
	xfree(pkblob);
	xfree(cuser);
	xfree(chost);
	xfree(sig);
	return authenticated;
}

d525 1
a525 1
	temporarily_use_uid(pw);
a629 66
}

/* return 1 if given hostkey is allowed */
int
hostbased_key_allowed(struct passwd *pw, const char *cuser, char *chost,
    Key *key)
{
	Key *found;
	const char *resolvedname, *ipaddr, *lookup;
	struct stat st;
	char *user_hostfile;
	int host_status, len;

	resolvedname = get_canonical_hostname(options.reverse_mapping_check);
	ipaddr = get_remote_ipaddr();

	debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s",
	    chost, resolvedname, ipaddr);

	if (options.hostbased_uses_name_from_packet_only) {
		if (auth_rhosts2(pw, cuser, chost, chost) == 0)
			return 0;
		lookup = chost;
	} else {
		if (((len = strlen(chost)) > 0) && chost[len - 1] == '.') {
			debug2("stripping trailing dot from chost %s", chost);
			chost[len - 1] = '\0';
		}
		if (strcasecmp(resolvedname, chost) != 0)
			log("userauth_hostbased mismatch: "
			    "client sends %s, but we resolve %s to %s",
			    chost, ipaddr, resolvedname);
		if (auth_rhosts2(pw, cuser, resolvedname, ipaddr) == 0)
			return 0;
		lookup = resolvedname;
	}
	debug2("userauth_hostbased: access allowed by auth_rhosts2");

	/* XXX this is copied from auth-rh-rsa.c and should be shared */
	found = key_new(key->type);
	host_status = check_host_in_hostfile(_PATH_SSH_SYSTEM_HOSTFILE2, lookup,
	    key, found, NULL);

	if (host_status != HOST_OK && !options.ignore_user_known_hosts) {
		user_hostfile = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE2,
		    pw->pw_uid);
		if (options.strict_modes &&
		    (stat(user_hostfile, &st) == 0) &&
		    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||
		     (st.st_mode & 022) != 0)) {
			log("Hostbased authentication refused for %.100s: "
			    "bad owner or modes for %.200s",
			    pw->pw_name, user_hostfile);
		} else {
			temporarily_use_uid(pw);
			host_status = check_host_in_hostfile(user_hostfile,
			    lookup, key, found, NULL);
			restore_uid();
		}
		xfree(user_hostfile);
	}
	key_free(found);

	debug2("userauth_hostbased: key %s for %s", host_status == HOST_OK ?
	    "ok" : "not found", lookup);
	return (host_status == HOST_OK);
@


1.20.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.70 2001/09/20 13:46:48 markus Exp $");
a53 1
#include "match.h"
d72 3
a74 3
static void input_service_request(int, int, void *);
static void input_userauth_request(int, int, void *);
static void protocol_error(int, int, void *);
d77 6
a82 4
static Authmethod *authmethod_lookup(const char *);
static char *authmethods_get(void);
static int user_key_allowed(struct passwd *, Key *);
static int hostbased_key_allowed(struct passwd *, const char *, char *, Key *);
d85 7
a91 6
static void userauth_banner(void);
static int userauth_none(Authctxt *);
static int userauth_passwd(Authctxt *);
static int userauth_pubkey(Authctxt *);
static int userauth_hostbased(Authctxt *);
static int userauth_kbdint(Authctxt *);
d124 1
a124 1
	if (options.challenge_response_authentication)
d133 1
a133 1
static void
d143 1
a143 1
static void
d176 1
a176 1
static void
d210 8
a217 6
		authctxt->style = style ? xstrdup(style) : NULL;
	} else if (strcmp(user, authctxt->user) != 0 ||
	    strcmp(service, authctxt->service) != 0) {
		packet_disconnect("Change of username or service not allowed: "
		    "(%s,%s) -> (%s,%s)",
		    authctxt->user, authctxt->service, user, service);
a244 2
	char *methods;

d257 2
a258 23
	if (authctxt->postponed)
		return;

	/* XXX todo: check if multiple auth methods are needed */
	if (authenticated == 1) {
		/* turn off userauth */
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &protocol_error);
		packet_start(SSH2_MSG_USERAUTH_SUCCESS);
		packet_send();
		packet_write_wait();
		/* now we can break out */
		authctxt->success = 1;
	} else {
		if (authctxt->failures++ > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
		methods = authmethods_get();
		packet_start(SSH2_MSG_USERAUTH_FAILURE);
		packet_put_cstring(methods);
		packet_put_char(0);	/* XXX partial success, unused */
		packet_send();
		packet_write_wait();
		xfree(methods);
	}
d261 1
a261 1
static void
d292 28
a319 1
static int
d331 1
a331 1
static int
d351 1
a351 1
static int
d355 3
a357 2
	char *lang, *devs;
	
d362 1
a362 1
	debug("keyboard-interactive devs %s", devs);
d364 1
a364 1
	if (options.challenge_response_authentication)
d367 1
a368 1
	xfree(lang);
d372 1
a372 1
static int
d474 1
a474 1
static int
d559 1
a559 1
static char *
d591 1
a591 1
static Authmethod *
d606 2
a607 2
static int
user_key_allowed2(struct passwd *pw, Key *key, char *file)
d609 1
a609 1
	char line[8192];
d622 3
a624 1
	debug("trying public key file %s", file);
d639 39
a677 6
	if (options.strict_modes &&
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
		fclose(f);
		log("Authentication refused: %s", line);
		restore_uid();
		return 0;
a678 1

d691 1
a691 1
		if (key_read(found, &cp) != 1) {
d705 1
a705 1
			if (key_read(found, &cp) != 1) {
d714 1
a714 1
			debug("matching key found: file %s, line %lu",
a726 20
/* check whether given key is in .ssh/authorized_keys* */
static int
user_key_allowed(struct passwd *pw, Key *key)
{
	int success;
	char *file;

	file = authorized_keys_file(pw);
	success = user_key_allowed2(pw, key, file);
	xfree(file);
	if (success)
		return success;

	/* try suffix "2" for backward compat, too */
	file = authorized_keys_file2(pw);
	success = user_key_allowed2(pw, key, file);
	xfree(file);
	return success;
}

d728 1
a728 1
static int
d732 1
d734 2
d763 24
a786 10
	host_status = check_key_in_hostfiles(pw, key, lookup,
	    _PATH_SSH_SYSTEM_HOSTFILE,
	    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);

	/* backward compat if no key has been found. */
	if (host_status == HOST_NEW)
		host_status = check_key_in_hostfiles(pw, key, lookup,
		    _PATH_SSH_SYSTEM_HOSTFILE2,
		    options.ignore_user_known_hosts ? NULL :
		    _PATH_SSH_USER_HOSTFILE2);
d788 2
a791 1

@


1.20.2.6
log
@Merge OpenSSH 3.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.20.2.5 2001/09/27 00:15:41 miod Exp $");
d121 1
a121 1
	/* challenge-response is implemented via keyboard interactive */
@


1.20.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.20.2.6 2001/11/15 00:14:59 miod Exp $");
d53 1
@


1.20.2.8
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.85 2002/02/24 19:14:59 markus Exp $");
d72 3
a74 2
static void input_service_request(int, u_int32_t, void *);
static void input_userauth_request(int, u_int32_t, void *);
d114 1
a114 1
do_authentication2(void)
d124 1
a124 1
	dispatch_init(&dispatch_protocol_error);
d131 11
a141 1
input_service_request(int type, u_int32_t seq, void *ctxt)
d147 1
a147 1
	packet_check_eom();
d174 1
a174 1
input_userauth_request(int type, u_int32_t seq, void *ctxt)
d215 1
a215 1
	auth2_challenge_stop(authctxt);
d217 6
d260 1
a260 1
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);
d317 1
a317 1
	packet_check_eom();
d333 1
a333 1
	packet_check_eom();
d347 1
a347 1

d350 1
a350 1
	packet_check_eom();
d366 2
a367 3
	Key *key = NULL;
	char *pkalg;
	u_char *pkblob, *sig;
d393 4
a396 3
		log("userauth_pubkey: unsupported public key algorithm: %s",
		    pkalg);
		goto done;
d399 25
a423 33
	if (key == NULL) {
		error("userauth_pubkey: cannot decode key: %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("userauth_pubkey: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
		goto done;
	}
	if (have_sig) {
		sig = packet_get_string(&slen);
		packet_check_eom();
		buffer_init(&b);
		if (datafellows & SSH_OLD_SESSIONID) {
			buffer_append(&b, session_id2, session_id2_len);
		} else {
			buffer_put_string(&b, session_id2, session_id2_len);
		}
		/* reconstruct packet */
		buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
		buffer_put_cstring(&b, authctxt->user);
		buffer_put_cstring(&b,
		    datafellows & SSH_BUG_PKSERVICE ?
		    "ssh-userauth" :
		    authctxt->service);
		if (datafellows & SSH_BUG_PKAUTH) {
			buffer_put_char(&b, have_sig);
		} else {
			buffer_put_cstring(&b, "publickey");
			buffer_put_char(&b, have_sig);
			buffer_put_cstring(&b, pkalg);
		}
		buffer_put_string(&b, pkblob, blen);
d425 1
a425 1
		buffer_dump(&b);
d427 9
a435 9
		/* test for correct signature */
		if (user_key_allowed(authctxt->pw, key) &&
		    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
			authenticated = 1;
		buffer_clear(&b);
		xfree(sig);
	} else {
		debug("test whether pkalg/pkblob are acceptable");
		packet_check_eom();
d437 16
a452 15
		/* XXX fake reply and always send PK_OK ? */
		/*
		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (user_key_allowed(authctxt->pw, key)) {
			packet_start(SSH2_MSG_USERAUTH_PK_OK);
			packet_put_string(pkalg, alen);
			packet_put_string(pkblob, blen);
			packet_send();
			packet_write_wait();
			authctxt->postponed = 1;
d454 3
a457 3
	if (authenticated != 1)
		auth_clear_options();
done:
a458 2
	if (key != NULL)
		key_free(key);
d468 2
a469 3
	Key *key = NULL;
	char *pkalg, *cuser, *chost, *service;
	u_char *pkblob, *sig;
d502 1
a502 6
		error("userauth_hostbased: cannot decode key: %s", pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error("userauth_hostbased: type mismatch for decoded key "
		    "(received %d, expected %d)", key->type, pktype);
d527 2
a530 2
	if (key != NULL)
		key_free(key);
d553 1
a553 1
	Buffer b;
a555 1
	buffer_init(&b);
d560 16
a575 3
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, method->name, strlen(method->name));
a577 3
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
a604 1
	char *fp;
a671 4
			fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
			verbose("Found matching %s key: %s",
			    key_type(found), fp);
			xfree(fp);
d709 1
a709 2
	HostStatus host_status;
	int len;
d711 1
a711 1
	resolvedname = get_canonical_hostname(options.verify_reverse_mapping);
d749 1
@


1.19
log
@new cipher framework
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.18 2000/10/11 20:14:38 markus Exp $");
d383 3
a385 1
			if (datafellows & SSH_COMPAT_SESSIONID_ENCODING) {
a386 2
			} else {
				buffer_append(&b, session_id2, session_id2_len);
@


1.18
log
@add support for s/key (kbd-interactive) to ssh2, based on work by mkiernan@@avantgo.com and me
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.17 2000/10/11 19:59:52 markus Exp $");
a37 1
#include "cipher.h"
@


1.17
log
@clear auth options unless auth sucessfull
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.16 2000/09/27 21:41:34 markus Exp $");
d60 10
a75 4
/* auth */
int	ssh2_auth_none(struct passwd *pw);
int	ssh2_auth_password(struct passwd *pw);
int  	ssh2_auth_pubkey(struct passwd *pw, char *service);
d78 2
a79 1
struct passwd*	 auth_set_user(char *u, char *s);
d81 1
d83 20
a102 6
typedef struct Authctxt Authctxt;
struct Authctxt {
	char *user;
	char *service;
	struct passwd pw;
	int valid;
a103 2
static Authctxt	*authctxt = NULL;
static int userauth_success = 0;
d106 1
a106 1
 * loop until userauth_success == TRUE
d112 7
a118 4
	/* turn off skey/kerberos, not supported by SSH2 */
#ifdef SKEY
	options.skey_authentication = 0;
#endif
d120 1
a122 1

d125 1
a125 1
	dispatch_run(DISPATCH_BLOCK, &userauth_success, NULL);
d142 1
d148 3
d152 1
a152 1
		if (!userauth_success) {
d175 3
a177 3
	static void (*authlog) (const char *fmt,...) = verbose;
	static int attempt = 0;
	unsigned int len;
a178 2
	char *user, *service, *method, *authmsg = NULL;
	struct passwd *pw;
d180 3
a182 1
	if (++attempt == AUTH_FAIL_MAX)
d185 3
a187 3
	user = packet_get_string(&len);
	service = packet_get_string(&len);
	method = packet_get_string(&len);
d189 1
d191 20
a210 9
	/* XXX we only allow the ssh-connection service */
	pw = auth_set_user(user, service);
	if (pw && strcmp(service, "ssh-connection")==0) {
		if (strcmp(method, "none") == 0) {
			authenticated =	ssh2_auth_none(pw);
		} else if (strcmp(method, "password") == 0) {
			authenticated =	ssh2_auth_password(pw);
		} else if (strcmp(method, "publickey") == 0) {
			authenticated =	ssh2_auth_pubkey(pw, service);
d213 16
a228 1
	if (authenticated && pw && pw->pw_uid == 0 && !options.permit_root_login) {
d230 1
a230 2
		log("ROOT LOGIN REFUSED FROM %.200s",
		    get_canonical_hostname());
d233 16
d251 2
a252 1
	    attempt == AUTH_FAIL_LOG ||
a255 1
	/* Log before sending the reply */
d263 7
d271 6
a276 5
		authmsg,
		method,
		pw && pw->pw_uid == 0 ? "ROOT" : user,
		get_remote_ipaddr(),
		get_remote_port());
d278 3
d289 1
a289 1
		userauth_success = 1;
d291 1
d293 2
a294 2
		packet_put_cstring("publickey,password");	/* XXX dynamic */
		packet_put_char(0);				/* XXX partial success, unused */
d297 3
a300 4

	xfree(service);
	xfree(user);
	xfree(method);
d304 1
a304 1
ssh2_auth_none(struct passwd *pw)
d306 4
d311 1
a311 1
	return auth_password(pw, "");
d313 1
d315 1
a315 1
ssh2_auth_password(struct passwd *pw)
d326 2
a327 2
	if (options.password_authentication &&
	    auth_password(pw, password) == 1)
d333 23
d357 1
a357 1
ssh2_auth_pubkey(struct passwd *pw, char *service)
d366 2
a367 2
	if (options.dsa_authentication == 0) {
		debug("pubkey auth disabled");
d373 1
a374 1
		log("bad pkalg %s", pkalg);	/*XXX*/
d391 1
a391 1
			buffer_put_cstring(&b, pw->pw_name);
d395 1
a395 1
			    service);
d404 1
a404 1
			if (user_dsa_key_allowed(pw, key) &&
d410 1
d412 1
a412 2
			debug("test key...");
			/* test whether pkalg/pkblob are acceptable */
d421 1
a421 1
			if (user_dsa_key_allowed(pw, key)) {
d439 1
a439 1
/* set and get current user */
d444 1
a444 1
	return (authctxt != NULL && authctxt->valid) ? &authctxt->pw : NULL;
d447 4
a450 2
struct passwd*
auth_set_user(char *u, char *s)
d452 3
a454 1
	struct passwd *pw, *copy;
d456 7
a462 10
	if (authctxt == NULL) {
		authctxt = xmalloc(sizeof(*authctxt));
		authctxt->valid = 0;
		authctxt->user = xstrdup(u);
		authctxt->service = xstrdup(s);
		setproctitle("%s", u);
		pw = getpwnam(u);
		if (!pw || !allowed_user(pw)) {
			log("auth_set_user: illegal user %s", u);
			return NULL;
d464 12
a475 16
		copy = &authctxt->pw;
		memset(copy, 0, sizeof(*copy));
		copy->pw_name = xstrdup(pw->pw_name);
		copy->pw_passwd = xstrdup(pw->pw_passwd);
		copy->pw_uid = pw->pw_uid;
		copy->pw_gid = pw->pw_gid;
		copy->pw_class = xstrdup(pw->pw_class);
		copy->pw_dir = xstrdup(pw->pw_dir);
		copy->pw_shell = xstrdup(pw->pw_shell);
		authctxt->valid = 1;
	} else {
		if (strcmp(u, authctxt->user) != 0 ||
		    strcmp(s, authctxt->service) != 0) {
			log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)",
			    u, s, authctxt->user, authctxt->service);
			return NULL;
d478 15
a492 1
	return auth_get_user();
d507 3
d614 15
@


1.16
log
@use key_type()
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.15 2000/09/21 11:25:32 markus Exp $");
d322 2
@


1.15
log
@add context to dispatch_run
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.14 2000/09/07 20:27:49 deraadt Exp $");
d413 4
a416 2
			snprintf(buf, sizeof buf, "DSA authentication refused for %.100s: "
			    "bad ownership or modes for '%s'.", pw->pw_name, file);
d431 1
a431 1
					    "DSA authentication refused for %.100s: "
d433 1
a433 1
					    pw->pw_name, line);
d447 1
a447 1
	found = key_new(KEY_DSA);
@


1.14
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.13 2000/08/20 18:42:40 millert Exp $");
d62 3
a64 3
void	input_service_request(int type, int plen);
void	input_userauth_request(int type, int plen);
void	protocol_error(int type, int plen);
d102 1
a102 1
	dispatch_run(DISPATCH_BLOCK, &userauth_success);
d107 1
a107 1
protocol_error(int type, int plen)
d117 1
a117 1
input_service_request(int type, int plen)
d146 1
a146 1
input_userauth_request(int type, int plen)
@


1.13
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@a11 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Markus Friedl.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d24 1
d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.12 2000/07/07 03:55:03 todd Exp $");
@


1.12
log
@clean code is good code
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.10 2000/06/18 04:05:02 markus Exp $");
d363 1
@


1.11
log
@make userauth+pubkey interop with ssh.com-2.2.0
@
text
@a440 1
			log(buf);
d442 1
@


1.10
log
@split auth-rsa option parsing into auth-options
add options support to authorized_keys2
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.9 2000/06/18 01:09:10 markus Exp $");
d280 5
a284 2
			buffer_append(&b, session_id2, session_id2_len);

@


1.9
log
@implement bug compatibility with ssh-2.0.13 pubkey, server side
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.8 2000/05/08 17:42:24 markus Exp $");
d57 1
d448 1
a448 1
		char *cp;
d455 1
d457 21
a477 3
		if (bits == 0)
			continue;
		if (key_equal(found, key)) {
@


1.8
log
@bug compat w/ ssh-2.0.13 x11, split out bugs
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.7 2000/05/06 17:45:36 markus Exp $");
d72 1
a72 1
int	ssh2_auth_pubkey(struct passwd *pw, unsigned char *raw, unsigned int rlen);
d153 1
a153 1
	unsigned int len, rlen;
d155 1
a155 1
	char *raw, *user, *service, *method, *authmsg = NULL;
a160 3
	raw = packet_get_raw(&rlen);
	if (plen != rlen)
		fatal("plen != rlen");
d174 1
a174 1
			authenticated =	ssh2_auth_pubkey(pw, raw, rlen);
d252 1
a252 1
ssh2_auth_pubkey(struct passwd *pw, unsigned char *raw, unsigned int rlen)
a264 4
	if (datafellows & SSH_BUG_PUBKEYAUTH) {
		log("bug compatibility with ssh-2.0.13 pubkey not implemented");
		return 0;
	}
d280 2
d283 9
a291 3
			if (slen + 4 > rlen)
				fatal("bad rlen/slen");
			buffer_append(&b, raw, rlen - slen - 4);
@


1.8.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.13 2000/08/20 18:42:40 millert Exp $");
a56 1
#include "auth-options.h"
d72 1
a72 1
int  	ssh2_auth_pubkey(struct passwd *pw, char *service);
d153 1
a153 1
	unsigned int len;
d155 1
a155 1
	char *user, *service, *method, *authmsg = NULL;
d161 3
d177 1
a177 1
			authenticated =	ssh2_auth_pubkey(pw, service);
d255 1
a255 1
ssh2_auth_pubkey(struct passwd *pw, char *service)
d268 4
d286 1
a286 6
			if (datafellows & SSH_COMPAT_SESSIONID_ENCODING) {
				buffer_put_string(&b, session_id2, session_id2_len);
			} else {
				buffer_append(&b, session_id2, session_id2_len);
			}
			/* reconstruct packet */
d288 3
a290 9
			buffer_put_cstring(&b, pw->pw_name);
			buffer_put_cstring(&b,
			    datafellows & SSH_BUG_PUBKEYAUTH ?
			    "ssh-userauth" :
			    service);
			buffer_put_cstring(&b, "publickey");
			buffer_put_char(&b, have_sig);
			buffer_put_cstring(&b, KEX_DSS);
			buffer_put_string(&b, pkblob, blen);
a357 1
		copy->pw_class = xstrdup(pw->pw_class);
d436 1
a437 1
			log("%s",buf);
d446 1
a446 1
		char *cp, *options = NULL;
a452 1

d454 3
a456 21
		if (bits == 0) {
			/* no key?  check if there are options for this key */
			int quoted = 0;
			options = cp;
			for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
				if (*cp == '\\' && cp[1] == '"')
					cp++;	/* Skip both */
				else if (*cp == '"')
					quoted = !quoted;
			}
			/* Skip remaining whitespace. */
			for (; *cp == ' ' || *cp == '\t'; cp++)
				;
			bits = key_read(found, &cp);
			if (bits == 0) {
				/* still no key?  advance to next line*/
				continue;
			}
		}
		if (key_equal(found, key) &&
		    auth_parse_options(pw, options, linenum) == 1) {
@


1.8.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d12 5
a28 1

d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.20 2000/10/14 12:16:56 markus Exp $");
d42 1
a63 10
static Authctxt	*x_authctxt = NULL;
static int one = 1;

typedef struct Authmethod Authmethod;
struct Authmethod {
	char	*name;
	int	(*userauth)(Authctxt *authctxt);
	int	*enabled;
};

d66 3
a68 3
void	input_service_request(int type, int plen, void *ctxt);
void	input_userauth_request(int type, int plen, void *ctxt);
void	protocol_error(int type, int plen, void *ctxt);
d70 4
d76 1
a76 2
Authmethod	*authmethod_lookup(const char *name);
struct passwd	*pwcopy(struct passwd *pw);
a77 1
char	*authmethods_get(void);
d79 6
a84 20
/* auth */
int	userauth_none(Authctxt *authctxt);
int	userauth_passwd(Authctxt *authctxt);
int	userauth_pubkey(Authctxt *authctxt);
int	userauth_kbdint(Authctxt *authctxt);

Authmethod authmethods[] = {
	{"none",
		userauth_none,
		&one},
	{"publickey",
		userauth_pubkey,
		&options.dsa_authentication},
	{"keyboard-interactive",
		userauth_kbdint,
		&options.kbd_interactive_authentication},
	{"password",
		userauth_passwd,
		&options.password_authentication},
	{NULL, NULL, NULL}
d86 2
d90 1
a90 1
 * loop until authctxt->success == TRUE
d96 4
a99 7
	Authctxt *authctxt = xmalloc(sizeof(*authctxt));
	memset(authctxt, 'a', sizeof(*authctxt));
	authctxt->valid = 0;
	authctxt->attempt = 0;
	authctxt->success = 0;
	x_authctxt = authctxt;		/*XXX*/

a100 1
	/* turn off kerberos, not supported by SSH2 */
d103 1
d106 1
a106 1
	dispatch_run(DISPATCH_BLOCK, &authctxt->success, authctxt);
d111 1
a111 1
protocol_error(int type, int plen, void *ctxt)
d121 1
a121 1
input_service_request(int type, int plen, void *ctxt)
a122 1
	Authctxt *authctxt = ctxt;
a127 3
	if (authctxt == NULL)
		fatal("input_service_request: no authctxt");

d129 1
a129 1
		if (!authctxt->success) {
d150 1
a150 1
input_userauth_request(int type, int plen, void *ctxt)
d152 3
a154 3
	Authctxt *authctxt = ctxt;
	Authmethod *m = NULL;
	char *user, *service, *method;
d156 2
d159 1
a159 3
	if (authctxt == NULL)
		fatal("input_userauth_request: no authctxt");
	if (authctxt->attempt++ >= AUTH_FAIL_MAX)
d162 3
a164 3
	user = packet_get_string(NULL);
	service = packet_get_string(NULL);
	method = packet_get_string(NULL);
a165 1
	debug("attempt #%d", authctxt->attempt);
d167 9
a175 11
	if (authctxt->attempt == 1) { 
		/* setup auth context */
		struct passwd *pw = NULL;
		setproctitle("%s", user);
		pw = getpwnam(user);
		if (pw && allowed_user(pw) && strcmp(service, "ssh-connection")==0) {
			authctxt->pw = pwcopy(pw);
			authctxt->valid = 1;
			debug2("input_userauth_request: setting up authctxt for %s", user);
		} else {
			log("input_userauth_request: illegal user %s", user);
a176 17
		authctxt->user = xstrdup(user);
		authctxt->service = xstrdup(service);
	} else if (authctxt->valid) {
		if (strcmp(user, authctxt->user) != 0 ||
		    strcmp(service, authctxt->service) != 0) {
			log("input_userauth_request: missmatch: (%s,%s)!=(%s,%s)",
			    user, service, authctxt->user, authctxt->service);
			authctxt->valid = 0;
		}
	}

	m = authmethod_lookup(method);
	if (m != NULL) {
		debug2("input_userauth_request: try method %s", method);
		authenticated =	m->userauth(authctxt);
	} else {
		debug2("input_userauth_request: unsupported method %s", method);
d178 1
a178 8
	if (!authctxt->valid && authenticated == 1) {
		log("input_userauth_request: INTERNAL ERROR: authenticated invalid user %s service %s", user, method);
		authenticated = 0;
	}

	/* Special handling for root */
	if (authenticated == 1 &&
	    authctxt->valid && authctxt->pw->pw_uid == 0 && !options.permit_root_login) {
d180 2
a181 1
		log("ROOT LOGIN REFUSED FROM %.200s", get_canonical_hostname());
a183 16
	/* Log before sending the reply */
	userauth_log(authctxt, authenticated, method);
	userauth_reply(authctxt, authenticated);

	xfree(service);
	xfree(user);
	xfree(method);
}


void
userauth_log(Authctxt *authctxt, int authenticated, char *method)
{
	void (*authlog) (const char *fmt,...) = verbose;
	char *user = NULL, *authmsg = NULL;

d186 1
a186 2
	    !authctxt->valid ||
	    authctxt->attempt >= AUTH_FAIL_LOG ||
d190 1
a197 7

	if (authctxt->valid) {
		user = authctxt->pw->pw_uid == 0 ? "ROOT" : authctxt->user;
	} else {
		user = "NOUSER";
	}

d199 5
a203 6
	    authmsg,
	    method,
	    user,
	    get_remote_ipaddr(),
	    get_remote_port());
}
a204 3
void   
userauth_reply(Authctxt *authctxt, int authenticated)
{
d213 1
a213 1
		authctxt->success = 1;
a214 1
		char *methods = authmethods_get();
d216 2
a217 2
		packet_put_cstring(methods);
		packet_put_char(0);	/* XXX partial success, unused */
a219 3
		xfree(methods);
	} else {
		/* do nothing, we did already send a reply */
d221 4
d228 1
a228 1
userauth_none(Authctxt *authctxt)
a229 4
	/* disable method "none", only allowed one time */
	Authmethod *m = authmethod_lookup("none");
	if (m != NULL)
		m->enabled = NULL;
d231 1
a231 1
	return authctxt->valid ? auth_password(authctxt->pw, "") : 0;
a232 1

d234 1
a234 1
userauth_passwd(Authctxt *authctxt)
d245 2
a246 2
	if (authctxt->valid &&
	    auth_password(authctxt->pw, password) == 1)
a251 23

int
userauth_kbdint(Authctxt *authctxt)
{
	int authenticated = 0;
	char *lang = NULL;
	char *devs = NULL;

	lang = packet_get_string(NULL);
	devs = packet_get_string(NULL);
	packet_done();

	debug("keyboard-interactive language %s devs %s", lang, devs);
#ifdef SKEY
	/* XXX hardcoded, we should look at devs */
	if (options.skey_authentication != 0)
		authenticated = auth2_skey(authctxt);
#endif
	xfree(lang);
	xfree(devs);
	return authenticated;
}

d253 1
a253 1
userauth_pubkey(Authctxt *authctxt)
d262 2
a263 2
	if (!authctxt->valid) {
		debug2("userauth_pubkey: disabled because of invalid user");
d269 1
a270 1
		xfree(pkalg);
d280 3
a282 1
			if (datafellows & SSH_OLD_SESSIONID) {
a283 2
			} else {
				buffer_put_string(&b, session_id2, session_id2_len);
d287 1
a287 1
			buffer_put_cstring(&b, authctxt->user);
d291 1
a291 1
			    authctxt->service);
d300 1
a300 1
			if (user_dsa_key_allowed(authctxt->pw, key) &&
a305 1
			debug("test whether pkalg/pkblob are acceptable");
d307 2
a308 1

d317 1
a317 1
			if (user_dsa_key_allowed(authctxt->pw, key)) {
a325 2
		if (authenticated != 1)
			auth_clear_options();
d333 1
a333 1
/* get current user */
d338 1
a338 1
	return (x_authctxt != NULL && x_authctxt->valid) ? x_authctxt->pw : NULL;
d341 2
a342 4
#define	DELIM	","

char *
authmethods_get(void)
d344 1
a344 3
	Authmethod *method = NULL;
	unsigned int size = 0;
	char *list;
d346 10
a355 7
	for (method = authmethods; method->name != NULL; method++) {
		if (strcmp(method->name, "none") == 0)
			continue;
		if (method->enabled != NULL && *(method->enabled) != 0) {
			if (size != 0)
				size += strlen(DELIM);
			size += strlen(method->name);
d357 16
a372 12
	}
	size++;			/* trailing '\0' */
	list = xmalloc(size);
	list[0] = '\0';

	for (method = authmethods; method->name != NULL; method++) {
		if (strcmp(method->name, "none") == 0)
			continue;
		if (method->enabled != NULL && *(method->enabled) != 0) {
			if (list[0] != '\0')
				strlcat(list, DELIM, size);
			strlcat(list, method->name, size);
d375 1
a375 15
	return list;
}

Authmethod *
authmethod_lookup(const char *name)
{
	Authmethod *method = NULL;
	if (name != NULL)
		for (method = authmethods; method->name != NULL; method++)
			if (method->enabled != NULL &&
			    *(method->enabled) != 0 &&
			    strcmp(name, method->name) == 0)
				return method;
	debug2("Unrecognized authentication method name: %s", name ? name : "NULL");
	return NULL;
a389 3
	if (pw == NULL)
		return 0;

d417 2
a418 4
			snprintf(buf, sizeof buf,
			    "%s authentication refused for %.100s: "
			    "bad ownership or modes for '%s'.",
			    key_type(key), pw->pw_name, file);
d433 1
a433 1
					    "%s authentication refused for %.100s: "
d435 1
a435 1
					    key_type(key), pw->pw_name, line);
d449 1
a449 1
	found = key_new(key->type);
a491 15
}

struct passwd *
pwcopy(struct passwd *pw)
{
	struct passwd *copy = xmalloc(sizeof(*copy));
	memset(copy, 0, sizeof(*copy));
	copy->pw_name = xstrdup(pw->pw_name);
	copy->pw_passwd = xstrdup(pw->pw_passwd);
	copy->pw_uid = pw->pw_uid;
	copy->pw_gid = pw->pw_gid;
	copy->pw_class = xstrdup(pw->pw_class);
	copy->pw_dir = xstrdup(pw->pw_dir);
	copy->pw_shell = xstrdup(pw->pw_shell);
	return copy;
@


1.8.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.42 2001/02/13 22:49:40 markus Exp $");
d28 2
a31 1
#include "ssh2.h"
d34 1
a37 1
#include "log.h"
d42 1
d46 1
a47 1
#include "cipher.h"
d49 2
a50 1
#include "pathnames.h"
d56 1
a56 1
extern u_char *session_id2;
d75 1
d79 1
a79 1
int	user_key_allowed(struct passwd *pw, Key *key);
a82 1
void	userauth_banner(void);
d94 4
a97 1
		&options.pubkey_authentication},
a100 3
	{"keyboard-interactive",
		userauth_kbdint,
		&options.kbd_interactive_authentication},
d111 5
a115 2
	Authctxt *authctxt = authctxt_new();

d118 4
a121 4
	/* challenge-reponse is implemented via keyboard interactive */
	if (options.challenge_reponse_authentication)
		options.kbd_interactive_authentication = 1;

d125 1
a125 1
	do_authenticated2(authctxt);
d142 1
a142 1
	u_int len;
d176 1
a176 1
	char *user, *service, *method, *style = NULL;
d181 2
d188 1
a188 4
	debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);

	if ((style = strchr(user, ':')) != NULL)
		*style++ = 0;
d190 1
a190 1
	if (authctxt->attempt++ == 0) {
d193 1
a201 1
		setproctitle("%s", pw ? user : "unknown");
a203 1
		authctxt->style = style ? xstrdup(style) : NULL; /* currently unused */
a211 3
	/* reset state */
	dispatch_set(SSH2_MSG_USERAUTH_INFO_RESPONSE, &protocol_error);
	authctxt->postponed = 0;
a212 1
	/* try to authenticate user */
d217 6
a223 3
	if (!authctxt->valid && authenticated)
		fatal("INTERNAL ERROR: authenticated invalid user %s",
		    authctxt->user);
d226 2
a227 2
	if (authenticated && authctxt->pw->pw_uid == 0 &&
	    !auth_root_allowed(method))
d229 2
d233 2
a234 4
	auth_log(authctxt, authenticated, method, " ssh2");

	if (!authctxt->postponed)
		userauth_reply(authctxt, authenticated);
d241 1
d243 1
a243 1
userauth_banner(void)
d245 30
a274 29
	struct stat st;
	char *banner = NULL;
	off_t len, n;
	int fd;

	if (options.banner == NULL || (datafellows & SSH_BUG_BANNER))
		return;
	if ((fd = open(options.banner, O_RDONLY)) < 0) {
		error("userauth_banner: open %s failed: %s",
		    options.banner, strerror(errno));
		return;
	}
	if (fstat(fd, &st) < 0)
		goto done;
	len = st.st_size;
	banner = xmalloc(len + 1);
	if ((n = read(fd, banner, len)) < 0)
		goto done;
	banner[n] = '\0';
	packet_start(SSH2_MSG_USERAUTH_BANNER);
	packet_put_cstring(banner);
	packet_put_cstring("");		/* language, unused */
	packet_send();
	debug("userauth_banner: sent");
done:
	if (banner)
		xfree(banner);
	close(fd);
	return;
d277 1
a277 1
void
a279 2
	char *methods;

d289 2
a290 4
	} else {
		if (authctxt->failures++ > AUTH_FAIL_MAX)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
		methods = authmethods_get();
d297 2
a309 1
	userauth_banner();
d319 1
a319 1
	u_int len;
d345 5
a349 4

	if (options.challenge_reponse_authentication)
		authenticated = auth2_challenge(authctxt, devs);

d361 2
a362 2
	u_int alen, blen, slen;
	int have_sig, pktype;
d370 3
a372 17
	if (datafellows & SSH_BUG_PKAUTH) {
		debug2("userauth_pubkey: SSH_BUG_PKAUTH");
		/* no explicit pkalg given */
		pkblob = packet_get_string(&blen);
		buffer_init(&b);
		buffer_append(&b, pkblob, blen);
		/* so we have to extract the pkalg from the pkblob */
		pkalg = buffer_get_string(&b, &alen);
		buffer_free(&b);
	} else {
		pkalg = packet_get_string(&alen);
		pkblob = packet_get_string(&blen);
	}
	pktype = key_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		log("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
a373 1
		xfree(pkblob);
d376 2
a377 1
	key = key_from_blob(pkblob, blen);
d392 1
a392 1
			    datafellows & SSH_BUG_PKSERVICE ?
d395 3
a397 7
			if (datafellows & SSH_BUG_PKAUTH) {
				buffer_put_char(&b, have_sig);
			} else {
				buffer_put_cstring(&b, "publickey");
				buffer_put_char(&b, have_sig);
				buffer_put_cstring(&b, key_ssh_name(key));
			}
d399 1
a399 1
#ifdef DEBUG_PK
d403 2
a404 2
			if (user_key_allowed(authctxt->pw, key) &&
			    key_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
d420 1
a420 1
			if (user_key_allowed(authctxt->pw, key)) {
d426 1
a426 1
				authctxt->postponed = 1;
a432 1
	debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
d452 1
a452 1
	u_int size = 0;
d496 1
a496 1
user_key_allowed(struct passwd *pw, Key *key)
d498 1
a498 1
	char line[8192], file[MAXPATHLEN];
d500 1
d502 1
a502 1
	u_long linenum = 0;
d514 1
a514 1
	    _PATH_SSH_USER_PERMITTED_KEYS2);
d542 1
a542 1
			/* Check path to _PATH_SSH_USER_PERMITTED_KEYS */
d545 1
a545 1
				"", _PATH_SSH_USER_DIR, NULL
d581 2
a582 1
		if (key_read(found, &cp) == -1) {
a584 1
			debug2("user_key_allowed: check options: '%s'", cp);
d595 2
a596 2
			if (key_read(found, &cp) == -1) {
				debug2("user_key_allowed: advance: '%s'", cp);
d602 1
a602 1
		    auth_parse_options(pw, options, file, linenum) == 1) {
d613 15
@


1.8.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.46 2001/03/11 13:25:36 markus Exp $");
d33 1
a33 1
#include "sshpty.h"
a49 1
#include "misc.h"
d74 1
d579 1
a579 1
			log("%s", buf);
a626 2
	if (!found_key)
		debug2("key not found");
@


1.7
log
@add DSAAuthetication option to ssh/sshd, document SSH2 in sshd.8
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.6 2000/05/05 18:50:57 markus Exp $");
d266 4
@


1.6
log
@log failure before sending the reply
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.5 2000/05/01 23:13:39 djm Exp $");
d264 1
a264 1
	if (options.rsa_authentication == 0) {
@


1.5
log
@Add missing #ifdefs; ok - markus
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.4 2000/05/01 07:45:08 markus Exp $");
d186 21
a208 1
		authmsg = "Accepted";
a216 1
		authmsg = "Failed";
a221 2
	} else {
		authmsg = "Postponed";
a222 12
	/* Raise logging level */
	if (authenticated == 1||
	    attempt == AUTH_FAIL_LOG ||
	    strcmp(method, "password") == 0)
		authlog = log;

	authlog("%s %s for %.200s from %.200s port %d ssh2",
		authmsg,
		method,
		pw && pw->pw_uid == 0 ? "ROOT" : user,
		get_remote_ipaddr(),
		get_remote_port());
d301 7
@


1.4
log
@disable kerb,s/key in ssh2
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.3 2000/04/27 15:23:02 markus Exp $");
d96 1
d98 2
d101 1
@


1.3
log
@cleanup logging for sshd/2, respect PasswordAuth no
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.2 2000/04/27 08:01:25 markus Exp $");
d95 4
@


1.2
log
@xfree DSA blobs
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.1 2000/04/26 21:28:32 markus Exp $");
d143 2
a144 1
	static int try = 0;
d147 1
a147 1
	char *raw, *user, *service, *method;
d150 1
a150 1
	if (++try == AUTH_FAIL_MAX)
d172 7
a178 1
	/* XXX check if other auth methods are needed */
d180 1
a180 1
		log("userauth success for %s method %s", user, method);
d189 1
a189 1
		log("userauth failure for %s method %s", user, method);
d196 1
a196 1
		log("userauth postponed for %s method %s", user, method);
d198 13
d234 2
a235 1
	if (auth_password(pw, password))
a240 1

d251 4
d325 1
a325 1
			log("auth_set_user: bad user %s", u);
a377 2
		packet_send_debug("Could not open %.900s for reading.", file);
		packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
@


1.1
log
@split auth/sshconnect in one file per protocol version
@
text
@d30 1
a30 1
RCSID("$OpenBSD: auth2.c,v 1.1 2000/04/18 15:01:30 markus Exp $");
d240 10
a249 10
	
	if (have_sig && key != NULL) {
		sig = packet_get_string(&slen);
		packet_done();
		buffer_init(&b);
		buffer_append(&b, session_id2, session_id2_len);
		buffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);
		if (slen + 4 > rlen)
			fatal("bad rlen/slen");
		buffer_append(&b, raw, rlen - slen - 4);
d251 1
a251 1
		buffer_dump(&b);
d253 19
a271 18
		/* test for correct signature */
		if (user_dsa_key_allowed(pw, key) &&
		    dsa_verify(key, sig, slen, buffer_ptr(&b), buffer_len(&b)) == 1)
			authenticated = 1;
		buffer_clear(&b);
		xfree(sig);
	} else if (!have_sig && key != NULL) {
		packet_done();
		debug("test key...");
		/* test whether pkalg/pkblob are acceptable */
		/* XXX fake reply and always send PK_OK ? */
		if (user_dsa_key_allowed(pw, key)) {
			packet_start(SSH2_MSG_USERAUTH_PK_OK);
			packet_put_string(pkalg, alen);
			packet_put_string(pkblob, blen);
			packet_send();
			packet_write_wait();
			authenticated = -1;
d273 1
@

