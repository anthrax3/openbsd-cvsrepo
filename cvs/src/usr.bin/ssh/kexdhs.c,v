head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.24.0.6
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.1.0.10
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.8
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_2:1.1.0.4
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2017.05.30.14.23.52;	author markus;	state Exp;
branches;
next	1.24;
commitid	tEOGxoM4kvBMLD6J;

1.24
date	2016.05.02.10.26.04;	author djm;	state Exp;
branches;
next	1.23;
commitid	rVUG0L3JBpFl5b0k;

1.23
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.22;
commitid	K3glY441IowbrjDE;

1.22
date	2015.01.26.06.10.03;	author djm;	state Exp;
branches;
next	1.21;
commitid	F603CYAZ9E536XCr;

1.21
date	2015.01.20.07.55.33;	author djm;	state Exp;
branches;
next	1.20;
commitid	Setxb2a5y0nORr1C;

1.20
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.19;
commitid	U9l75XYAjMKaQ8Jp;

1.19
date	2015.01.19.19.52.16;	author markus;	state Exp;
branches;
next	1.18;
commitid	UHlhoIB5NMb8eAPm;

1.18
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.12.08.13.13;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.02.22.24.24;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.02.22.10.15;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2013.07.19.07.37.48;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.17.00.13.13;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.11.10.01.33.07;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.21.07.37.15;	author dtucker;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.31.16.33.12;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.04.05.15.59;	author djm;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.06.13.12.53.24;	author djm;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches
	1.1.4.1
	1.1.6.1
	1.1.8.1
	1.1.10.1;
next	;

1.1.4.1
date	2003.04.01.10.38.57;	author margarida;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.1.6.1
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.1.8.1
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.1.10.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.2.4.1
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.2.6.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.3.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.7.4.1
date	2006.11.08.00.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.25
log
@protocol handlers all get struct ssh passed; ok djm@@
@
text
@/* $OpenBSD: kexdhs.c,v 1.24 2016/05/02 10:26:04 djm Exp $ */
/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/types.h>
#include <string.h>
#include <signal.h>

#include <openssl/dh.h>

#include "sshkey.h"
#include "cipher.h"
#include "digest.h"
#include "kex.h"
#include "log.h"
#include "packet.h"
#include "dh.h"
#include "ssh2.h"

#include "dispatch.h"
#include "compat.h"
#include "ssherr.h"
#include "sshbuf.h"

static int input_kex_dh_init(int, u_int32_t, struct ssh *);

int
kexdh_server(struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	int r;

	/* generate server DH public key */
	switch (kex->kex_type) {
	case KEX_DH_GRP1_SHA1:
		kex->dh = dh_new_group1();
		break;
	case KEX_DH_GRP14_SHA1:
	case KEX_DH_GRP14_SHA256:
		kex->dh = dh_new_group14();
		break;
	case KEX_DH_GRP16_SHA512:
		kex->dh = dh_new_group16();
		break;
	case KEX_DH_GRP18_SHA512:
		kex->dh = dh_new_group18();
		break;
	default:
		r = SSH_ERR_INVALID_ARGUMENT;
		goto out;
	}
	if (kex->dh == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)
		goto out;

	debug("expecting SSH2_MSG_KEXDH_INIT");
	ssh_dispatch_set(ssh, SSH2_MSG_KEXDH_INIT, &input_kex_dh_init);
	r = 0;
 out:
	return r;
}

int
input_kex_dh_init(int type, u_int32_t seq, struct ssh *ssh)
{
	struct kex *kex = ssh->kex;
	BIGNUM *shared_secret = NULL, *dh_client_pub = NULL;
	struct sshkey *server_host_public, *server_host_private;
	u_char *kbuf = NULL, *signature = NULL, *server_host_key_blob = NULL;
	u_char hash[SSH_DIGEST_MAX_LENGTH];
	size_t sbloblen, slen;
	size_t klen = 0, hashlen;
	int kout, r;

	if (kex->load_host_public_key == NULL ||
	    kex->load_host_private_key == NULL) {
		r = SSH_ERR_INVALID_ARGUMENT;
		goto out;
	}
	server_host_public = kex->load_host_public_key(kex->hostkey_type,
	    kex->hostkey_nid, ssh);
	server_host_private = kex->load_host_private_key(kex->hostkey_type,
	    kex->hostkey_nid, ssh);
	if (server_host_public == NULL) {
		r = SSH_ERR_NO_HOSTKEY_LOADED;
		goto out;
	}

	/* key, cert */
	if ((dh_client_pub = BN_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((r = sshpkt_get_bignum2(ssh, dh_client_pub)) != 0 ||
	    (r = sshpkt_get_end(ssh)) != 0)
		goto out;

#ifdef DEBUG_KEXDH
	fprintf(stderr, "dh_client_pub= ");
	BN_print_fp(stderr, dh_client_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_client_pub));
#endif

#ifdef DEBUG_KEXDH
	DHparams_print_fp(stderr, kex->dh);
	fprintf(stderr, "pub= ");
	BN_print_fp(stderr, kex->dh->pub_key);
	fprintf(stderr, "\n");
#endif
	if (!dh_pub_is_valid(kex->dh, dh_client_pub)) {
		sshpkt_disconnect(ssh, "bad client public DH value");
		r = SSH_ERR_MESSAGE_INCOMPLETE;
		goto out;
	}

	klen = DH_size(kex->dh);
	if ((kbuf = malloc(klen)) == NULL ||
	    (shared_secret = BN_new()) == NULL) {
		r = SSH_ERR_ALLOC_FAIL;
		goto out;
	}
	if ((kout = DH_compute_key(kbuf, dh_client_pub, kex->dh)) < 0 ||
	    BN_bin2bn(kbuf, kout, shared_secret) == NULL) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}
#ifdef DEBUG_KEXDH
	dump_digest("shared secret", kbuf, kout);
#endif
	if ((r = sshkey_to_blob(server_host_public, &server_host_key_blob,
	    &sbloblen)) != 0)
		goto out;
	/* calc H */
	hashlen = sizeof(hash);
	if ((r = kex_dh_hash(
	    kex->hash_alg,
	    kex->client_version_string,
	    kex->server_version_string,
	    sshbuf_ptr(kex->peer), sshbuf_len(kex->peer),
	    sshbuf_ptr(kex->my), sshbuf_len(kex->my),
	    server_host_key_blob, sbloblen,
	    dh_client_pub,
	    kex->dh->pub_key,
	    shared_secret,
	    hash, &hashlen)) != 0)
		goto out;

	/* save session id := H */
	if (kex->session_id == NULL) {
		kex->session_id_len = hashlen;
		kex->session_id = malloc(kex->session_id_len);
		if (kex->session_id == NULL) {
			r = SSH_ERR_ALLOC_FAIL;
			goto out;
		}
		memcpy(kex->session_id, hash, kex->session_id_len);
	}

	/* sign H */
	if ((r = kex->sign(server_host_private, server_host_public, &signature,
	     &slen, hash, hashlen, kex->hostkey_alg, ssh->compat)) < 0)
		goto out;

	/* destroy_sensitive_data(); */

	/* send server hostkey, DH pubkey 'f' and singed H */
	if ((r = sshpkt_start(ssh, SSH2_MSG_KEXDH_REPLY)) != 0 ||
	    (r = sshpkt_put_string(ssh, server_host_key_blob, sbloblen)) != 0 ||
	    (r = sshpkt_put_bignum2(ssh, kex->dh->pub_key)) != 0 ||	/* f */
	    (r = sshpkt_put_string(ssh, signature, slen)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		goto out;

	if ((r = kex_derive_keys_bn(ssh, hash, hashlen, shared_secret)) == 0)
		r = kex_send_newkeys(ssh);
 out:
	explicit_bzero(hash, sizeof(hash));
	DH_free(kex->dh);
	kex->dh = NULL;
	if (dh_client_pub)
		BN_clear_free(dh_client_pub);
	if (kbuf) {
		explicit_bzero(kbuf, klen);
		free(kbuf);
	}
	if (shared_secret)
		BN_clear_free(shared_secret);
	free(server_host_key_blob);
	free(signature);
	return r;
}
@


1.24
log
@add support for additional fixed DH groups from
draft-ietf-curdle-ssh-kex-sha2-03

diffie-hellman-group14-sha256 (2K group)
diffie-hellman-group16-sha512 (4K group)
diffie-hellman-group18-sha512 (8K group)

based on patch from Mark D. Baushke and Darren Tucker
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.23 2015/12/04 16:41:28 markus Exp $ */
d47 1
a47 1
static int input_kex_dh_init(int, u_int32_t, void *);
d89 1
a89 1
input_kex_dh_init(int type, u_int32_t seq, void *ctxt)
a90 1
	struct ssh *ssh = ctxt;
@


1.23
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.22 2015/01/26 06:10:03 djm Exp $ */
d61 1
d64 6
d163 1
@


1.22
log
@correctly match ECDSA subtype (== curve) for offered/recevied
host keys. Fixes connection-killing host key mismatches when
a server offers multiple ECDSA keys with different curve type
(an extremely unlikely configuration).

ok markus, "looks mechanical" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.21 2015/01/20 07:55:33 djm Exp $ */
d179 2
a180 2
	if ((r = kex->sign(server_host_private, server_host_public,
	    &signature, &slen, hash, hashlen, ssh->compat)) < 0)
@


1.21
log
@fix hostkeys in agent; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.20 2015/01/19 20:16:15 markus Exp $ */
d99 4
a102 2
	server_host_public = kex->load_host_public_key(kex->hostkey_type, ssh);
	server_host_private = kex->load_host_private_key(kex->hostkey_type, ssh);
@


1.20
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.19 2015/01/19 19:52:16 markus Exp $ */
d99 3
a101 4
	if ((server_host_public = kex->load_host_public_key(kex->hostkey_type,
	    ssh)) == NULL ||
	    (server_host_private = kex->load_host_private_key(kex->hostkey_type,
	    ssh)) == NULL) {
@


1.19
log
@update packet.c & isolate, introduce struct ssh
a) switch packet.c to buffer api and isolate per-connection info into struct ssh
b) (de)serialization of the state is moved from monitor to packet.c
c) the old packet.c API is implemented in opacket.[ch]
d) compress.c/h is removed and integrated into packet.c
with and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.18 2014/02/02 03:44:31 djm Exp $ */
d33 1
a33 3
#include "xmalloc.h"
#include "buffer.h"
#include "key.h"
d35 1
d42 9
a50 2
void
kexdh_server(Kex *kex)
d52 2
a53 6
	BIGNUM *shared_secret = NULL, *dh_client_pub = NULL;
	DH *dh;
	Key *server_host_public, *server_host_private;
	u_char *kbuf, *hash, *signature = NULL, *server_host_key_blob = NULL;
	u_int sbloblen, klen, hashlen, slen;
	int kout;
d58 1
a58 1
		dh = dh_new_group1();
d61 1
a61 1
		dh = dh_new_group14();
d64 2
a65 1
		fatal("%s: Unexpected KEX type %d", __func__, kex->kex_type);
d67 6
a72 1
	dh_gen_key(dh, kex->we_need * 8);
d75 18
a92 1
	packet_read_expect(SSH2_MSG_KEXDH_INIT);
d95 11
a105 6
	    kex->load_host_private_key == NULL)
		fatal("Cannot load hostkey");
	server_host_public = kex->load_host_public_key(kex->hostkey_type);
	if (server_host_public == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);
	server_host_private = kex->load_host_private_key(kex->hostkey_type);
d108 7
a114 4
	if ((dh_client_pub = BN_new()) == NULL)
		fatal("dh_client_pub == NULL");
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();
d124 1
a124 1
	DHparams_print_fp(stderr, dh);
d126 1
a126 1
	BN_print_fp(stderr, dh->pub_key);
d129 5
a133 2
	if (!dh_pub_is_valid(dh, dh_client_pub))
		packet_disconnect("bad client public DH value");
d135 11
a145 4
	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	if ((kout = DH_compute_key(kbuf, dh_client_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d149 3
a151 9
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_server: BN_new failed");
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexdh_server: BN_bin2bn failed");
	explicit_bzero(kbuf, klen);
	free(kbuf);

	key_to_blob(server_host_public, &server_host_key_blob, &sbloblen);

d153 2
a154 1
	kex_dh_hash(
d157 2
a158 2
	    buffer_ptr(kex->peer), buffer_len(kex->peer),
	    buffer_ptr(kex->my), buffer_len(kex->my),
d161 1
a161 1
	    dh->pub_key,
d163 2
a164 3
	    &hash, &hashlen
	);
	BN_clear_free(dh_client_pub);
d169 5
a173 1
		kex->session_id = xmalloc(kex->session_id_len);
d178 3
a180 2
	kex->sign(server_host_private, server_host_public, &signature, &slen,
	    hash, hashlen);
d185 22
a206 6
	packet_start(SSH2_MSG_KEXDH_REPLY);
	packet_put_string(server_host_key_blob, sbloblen);
	packet_put_bignum2(dh->pub_key);	/* f */
	packet_put_string(signature, slen);
	packet_send();

d208 1
a208 7
	free(server_host_key_blob);
	/* have keys, free DH */
	DH_free(dh);

	kex_derive_keys_bn(kex, hash, hashlen, shared_secret);
	BN_clear_free(shared_secret);
	kex_finish(kex);
@


1.18
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.17 2014/01/12 08:13:13 djm Exp $ */
d119 2
a120 2
	    buffer_ptr(&kex->peer), buffer_len(&kex->peer),
	    buffer_ptr(&kex->my), buffer_len(&kex->my),
@


1.17
log
@avoid use of OpenSSL BIGNUM type and functions for KEX with
Curve25519 by adding a buffer_put_bignum2_from_string() that stores
a string using the bignum encoding rules. Will make it easier to
build a reduced-feature OpenSSH without OpenSSL in the future;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.16 2013/11/02 22:24:24 markus Exp $ */
d110 1
a110 1
	memset(kbuf, 0, klen);
@


1.16
log
@no need to include ssh-gss.h
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.15 2013/11/02 22:10:15 markus Exp $ */
d154 1
a154 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.15
log
@no need to include monitor_wrap.h
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.14 2013/07/19 07:37:48 markus Exp $ */
a41 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.14
log
@add ssh-agent(1) support to sshd(8); allows encrypted hostkeys,
or hostkeys on smartcards; most of the work by Zev Weiss; bz #1974
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.13 2013/05/17 00:13:13 djm Exp $ */
a44 1
#include "monitor_wrap.h"
@


1.13
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.12 2010/11/10 01:33:07 djm Exp $ */
a79 3
	if (server_host_private == NULL)
		fatal("Missing private key for hostkey type %d",
		    kex->hostkey_type);
d141 2
a142 3
	if (PRIVSEP(key_sign(server_host_private, &signature, &slen, hash,
	    hashlen)) < 0)
		fatal("kexdh_server: key_sign failed");
@


1.12
log
@use only libcrypto APIs that are retained with OPENSSL_NO_DEPRECATED.
these have been around for years by this time. ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.11 2010/02/26 20:29:54 djm Exp $ */
d118 1
a118 1
	xfree(kbuf);
d157 2
a158 2
	xfree(signature);
	xfree(server_host_key_blob);
@


1.11
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.10 2009/06/21 07:37:15 dtucker Exp $ */
d30 2
@


1.10
log
@abort if key_sign fails, preventing possible null deref.  Based on report
from Paolo Ganci, ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.9 2006/11/06 21:25:28 markus Exp $ */
d50 1
a50 1
	Key *server_host_key;
d71 2
a72 1
	if (kex->load_host_key == NULL)
d74 2
a75 2
	server_host_key = kex->load_host_key(kex->hostkey_type);
	if (server_host_key == NULL)
d77 4
d118 1
a118 1
	key_to_blob(server_host_key, &server_host_key_blob, &sbloblen);
d142 1
a142 1
	if (PRIVSEP(key_sign(server_host_key, &signature, &slen, hash,
@


1.9
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.8 2006/10/31 16:33:12 markus Exp $ */
d137 3
a139 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, hashlen));
@


1.8
log
@check DH_compute_key() for -1 even if it should not happen because of
earlier calls to dh_pub_is_valid(); report krahmer at suse.de; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.7 2006/08/03 03:34:42 deraadt Exp $ */
d108 2
a109 1
	BN_bin2bn(kbuf, kout, shared_secret);
@


1.7
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.6 2006/07/22 20:48:23 stevesk Exp $ */
d52 2
a53 2
	u_int sbloblen, klen, kout, hashlen;
	u_int slen;
d101 2
a102 1
	kout = DH_compute_key(kbuf, dh_client_pub, dh);
@


1.7.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.9 2006/11/06 21:25:28 markus Exp $ */
d52 2
a53 2
	u_int sbloblen, klen, hashlen, slen;
	int kout;
d101 1
a101 2
	if ((kout = DH_compute_key(kbuf, dh_client_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d107 1
a107 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexdh_server: BN_bin2bn failed");
@


1.6
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.5 2006/03/25 13:17:02 djm Exp $ */
a25 1
#include "includes.h"
d27 1
d29 1
d32 1
d34 1
d40 3
@


1.5
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d27 2
@


1.4
log
@RCSID() can die
@
text
@d1 1
@


1.3
log
@remove hardcoded hash lengths in key exchange code, allowing
implementation of KEX methods with different hashes (e.g. SHA-256);
ok markus@@ dtucker@@ stevesk@@
@
text
@a25 1
RCSID("$OpenBSD: kexdhs.c,v 1.2 2004/06/13 12:53:24 djm Exp $");
@


1.3.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexdhs.c,v 1.7 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 4

#include <sys/types.h>
#include <string.h>
#include <signal.h>
a28 1
#include "buffer.h"
a29 1
#include "cipher.h"
a34 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.3.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.9 2006/11/06 21:25:28 markus Exp $ */
d52 2
a53 2
	u_int sbloblen, klen, hashlen, slen;
	int kout;
d101 1
a101 2
	if ((kout = DH_compute_key(kbuf, dh_client_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d107 1
a107 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexdh_server: BN_bin2bn failed");
@


1.2
log
@implement diffie-hellman-group14-sha1 kex method (trivial extension to
existing diffie-hellman-group1-sha1); ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdhs.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
d44 1
a44 1
	u_int sbloblen, klen, kout;
d106 1
a106 1
	hash = kex_dh_hash(
d114 2
a115 1
	    shared_secret
a119 1
	/* XXX hashlen depends on KEX */
d121 1
a121 1
		kex->session_id_len = 20;
d127 1
a127 2
	/* XXX hashlen depends on KEX */
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, 20));
d143 1
a143 1
	kex_derive_keys(kex, hash, shared_secret);
@


1.2.6.1
log
@upgrade to OpenSSH 4.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdhs.c,v 1.3 2005/11/04 05:15:59 djm Exp $");
d44 1
a44 1
	u_int sbloblen, klen, kout, hashlen;
d106 1
a106 1
	kex_dh_hash(
d114 1
a114 2
	    shared_secret,
	    &hash, &hashlen
d119 1
d121 1
a121 1
		kex->session_id_len = hashlen;
d127 2
a128 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, hashlen));
d144 1
a144 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.2.6.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexdhs.c,v 1.7 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 4

#include <sys/types.h>
#include <string.h>
#include <signal.h>
a28 1
#include "buffer.h"
a29 1
#include "cipher.h"
a34 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.2.6.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: kexdhs.c,v 1.9 2006/11/06 21:25:28 markus Exp $ */
d52 2
a53 2
	u_int sbloblen, klen, hashlen, slen;
	int kout;
d101 1
a101 2
	if ((kout = DH_compute_key(kbuf, dh_client_pub, dh)) < 0)
		fatal("DH_compute_key: failed");
d107 1
a107 2
	if (BN_bin2bn(kbuf, kout, shared_secret) == NULL)
		fatal("kexdh_server: BN_bin2bn failed");
@


1.2.4.1
log
@upgrade to OpenSSH 4.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdhs.c,v 1.3 2005/11/04 05:15:59 djm Exp $");
d44 1
a44 1
	u_int sbloblen, klen, kout, hashlen;
d106 1
a106 1
	kex_dh_hash(
d114 1
a114 2
	    shared_secret,
	    &hash, &hashlen
d119 1
d121 1
a121 1
		kex->session_id_len = hashlen;
d127 2
a128 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, hashlen));
d144 1
a144 1
	kex_derive_keys(kex, hash, hashlen, shared_secret);
@


1.1
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.18 2002/03/18 17:50:31 provos Exp $");
d48 10
a57 1
	dh = dh_new_group1();
@


1.1.8.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdhs.c,v 1.2 2004/06/13 12:53:24 djm Exp $");
d48 1
a48 10
	switch (kex->kex_type) {
	case KEX_DH_GRP1_SHA1:
		dh = dh_new_group1();
		break;
	case KEX_DH_GRP14_SHA1:
		dh = dh_new_group14();
		break;
	default:
		fatal("%s: Unexpected KEX type %d", __func__, kex->kex_type);
	}
@


1.1.10.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdhs.c,v 1.2 2004/06/13 12:53:24 djm Exp $");
d48 1
a48 10
	switch (kex->kex_type) {
	case KEX_DH_GRP1_SHA1:
		dh = dh_new_group1();
		break;
	case KEX_DH_GRP14_SHA1:
		dh = dh_new_group14();
		break;
	default:
		fatal("%s: Unexpected KEX type %d", __func__, kex->kex_type);
	}
@


1.1.6.1
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdhs.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
@


1.1.4.1
log
@These were missed on the update to the last openssh.

Thanks to all who pointed it out.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdhs.c,v 1.1 2003/02/16 17:09:57 markus Exp $");
@


1.1.4.2
log
@upgrade to OpenSSH 3.7
@
text
@@


