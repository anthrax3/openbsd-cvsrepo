head	1.45;
access;
symbols
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.45.0.6
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.41.0.6
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.6
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.37.0.28
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.26
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.24
	OPENBSD_5_0:1.37.0.22
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.20
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.18
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.14
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.16
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.12
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.10
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.8
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.6
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.4
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.45
date	2016.06.30.05.17.05;	author dtucker;	state Exp;
branches;
next	1.44;
commitid	k0c31xkBZazsTvEi;

1.44
date	2016.05.30.18.34.41;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	lwTGkdPO31DnTUq5;

1.43
date	2016.05.25.23.48.45;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	NPBJoBfuBDOIqIQi;

1.42
date	2016.03.02.22.42.40;	author dtucker;	state Exp;
branches;
next	1.41;
commitid	kyzoHwOzjFTjav9W;

1.41
date	2015.01.14.13.54.13;	author djm;	state Exp;
branches;
next	1.40;
commitid	5mVYZPiIJUHzgjMn;

1.40
date	2013.09.19.00.24.52;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.02.13.33.05;	author dtucker;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.01.13.15.52;	author dtucker;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.08.01.23.36.12;	author stevesk;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.22.19.08.54;	author stevesk;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.21.21.26.55;	author stevesk;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.19.18.56.42;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2006.02.10.00.27.13;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.07.13.25.23;	author jaredy;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2005.04.28.10.17.56;	author moritz;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches
	1.22.2.1
	1.22.4.1;
next	1.21;

1.21
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.11.19.01.43;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.05.15.33.33;	author markus;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2003.12.02.12.15.10;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.20.11.39.28;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.23.20.18.52;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.31.12.14.22;	author markus;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2003.08.31.10.26.04;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.31.22.34.03;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.30.07.53.27;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.30.07.44.14;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.29.18.26.46;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.29.18.24.00;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.28.16.23.06;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.10.22.20.52;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.07.21.58.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.03.10.17.35;	author itojun;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.04.03.07.25.27;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.17.10.38.38;	author markus;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2003.01.12.16.57.02;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.10.08.19.07;	author fgsch;	state Exp;
branches;
next	;

1.3.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.3.4.1
date	2003.04.01.10.38.57;	author margarida;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.5.2.1
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.15.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.19.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.22.2.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.22.4.1
date	2005.09.04.18.40.02;	author brad;	state Exp;
branches;
next	;

1.24.2.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.26.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Explicitly check for 100% completion to avoid potential floating point
rounding error, which could cause progressmeter to report 99% on completion.
While there invert the test so the 100% case is clearer.  with & ok djm@@
@
text
@/* $OpenBSD: progressmeter.c,v 1.44 2016/05/30 18:34:41 schwarze Exp $ */
/*
 * Copyright (c) 2003 Nils Nordman.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/uio.h>

#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "progressmeter.h"
#include "atomicio.h"
#include "misc.h"

#define DEFAULT_WINSIZE 80
#define MAX_WINSIZE 512
#define PADDING 1		/* padding between the progress indicators */
#define UPDATE_INTERVAL 1	/* update the progress meter every second */
#define STALL_TIME 5		/* we're stalled after this many seconds */

/* determines whether we can output to the terminal */
static int can_output(void);

/* formats and inserts the specified size into the given buffer */
static void format_size(char *, int, off_t);
static void format_rate(char *, int, off_t);

/* window resizing */
static void sig_winch(int);
static void setscreensize(void);

/* updates the progressmeter to reflect the current state of the transfer */
void refresh_progress_meter(void);

/* signal handler for updating the progress meter */
static void update_progress_meter(int);

static double start;		/* start progress */
static double last_update;	/* last progress update */
static const char *file;	/* name of the file being transferred */
static off_t start_pos;		/* initial position of transfer */
static off_t end_pos;		/* ending position of transfer */
static off_t cur_pos;		/* transfer position as of last refresh */
static volatile off_t *counter;	/* progress counter */
static long stalled;		/* how long we have been stalled */
static int bytes_per_second;	/* current speed in bytes per second */
static int win_size;		/* terminal window size */
static volatile sig_atomic_t win_resized; /* for window resizing */

/* units for format_size */
static const char unit[] = " KMGT";

static int
can_output(void)
{
	return (getpgrp() == tcgetpgrp(STDOUT_FILENO));
}

static void
format_rate(char *buf, int size, off_t bytes)
{
	int i;

	bytes *= 100;
	for (i = 0; bytes >= 100*1000 && unit[i] != 'T'; i++)
		bytes = (bytes + 512) / 1024;
	if (i == 0) {
		i++;
		bytes = (bytes + 512) / 1024;
	}
	snprintf(buf, size, "%3lld.%1lld%c%s",
	    (long long) (bytes + 5) / 100,
	    (long long) (bytes + 5) / 10 % 10,
	    unit[i],
	    i ? "B" : " ");
}

static void
format_size(char *buf, int size, off_t bytes)
{
	int i;

	for (i = 0; bytes >= 10000 && unit[i] != 'T'; i++)
		bytes = (bytes + 512) / 1024;
	snprintf(buf, size, "%4lld%c%s",
	    (long long) bytes,
	    unit[i],
	    i ? "B" : " ");
}

void
refresh_progress_meter(void)
{
	char buf[MAX_WINSIZE + 1];
	off_t transferred;
	double elapsed, now;
	int percent;
	off_t bytes_left;
	int cur_speed;
	int hours, minutes, seconds;
	int i, len;
	int file_len;

	transferred = *counter - (cur_pos ? cur_pos : start_pos);
	cur_pos = *counter;
	now = monotime_double();
	bytes_left = end_pos - cur_pos;

	if (bytes_left > 0)
		elapsed = now - last_update;
	else {
		elapsed = now - start;
		/* Calculate true total speed when done */
		transferred = end_pos - start_pos;
		bytes_per_second = 0;
	}

	/* calculate speed */
	if (elapsed != 0)
		cur_speed = (transferred / elapsed);
	else
		cur_speed = transferred;

#define AGE_FACTOR 0.9
	if (bytes_per_second != 0) {
		bytes_per_second = (bytes_per_second * AGE_FACTOR) +
		    (cur_speed * (1.0 - AGE_FACTOR));
	} else
		bytes_per_second = cur_speed;

	/* filename */
	buf[0] = '\0';
	file_len = win_size - 35;
	if (file_len > 0) {
		len = snprintf(buf, file_len + 1, "\r%s", file);
		if (len < 0)
			len = 0;
		if (len >= file_len + 1)
			len = file_len;
		for (i = len; i < file_len; i++)
			buf[i] = ' ';
		buf[file_len] = '\0';
	}

	/* percent of transfer done */
	if (end_pos == 0 || cur_pos == end_pos)
		percent = 100;
	else
		percent = ((float)cur_pos / end_pos) * 100;
	snprintf(buf + strlen(buf), win_size - strlen(buf),
	    " %3d%% ", percent);

	/* amount transferred */
	format_size(buf + strlen(buf), win_size - strlen(buf),
	    cur_pos);
	strlcat(buf, " ", win_size);

	/* bandwidth usage */
	format_rate(buf + strlen(buf), win_size - strlen(buf),
	    (off_t)bytes_per_second);
	strlcat(buf, "/s ", win_size);

	/* ETA */
	if (!transferred)
		stalled += elapsed;
	else
		stalled = 0;

	if (stalled >= STALL_TIME)
		strlcat(buf, "- stalled -", win_size);
	else if (bytes_per_second == 0 && bytes_left)
		strlcat(buf, "  --:-- ETA", win_size);
	else {
		if (bytes_left > 0)
			seconds = bytes_left / bytes_per_second;
		else
			seconds = elapsed;

		hours = seconds / 3600;
		seconds -= hours * 3600;
		minutes = seconds / 60;
		seconds -= minutes * 60;

		if (hours != 0)
			snprintf(buf + strlen(buf), win_size - strlen(buf),
			    "%d:%02d:%02d", hours, minutes, seconds);
		else
			snprintf(buf + strlen(buf), win_size - strlen(buf),
			    "  %02d:%02d", minutes, seconds);

		if (bytes_left > 0)
			strlcat(buf, " ETA", win_size);
		else
			strlcat(buf, "    ", win_size);
	}

	atomicio(vwrite, STDOUT_FILENO, buf, win_size - 1);
	last_update = now;
}

/*ARGSUSED*/
static void
update_progress_meter(int ignore)
{
	int save_errno;

	save_errno = errno;

	if (win_resized) {
		setscreensize();
		win_resized = 0;
	}
	if (can_output())
		refresh_progress_meter();

	signal(SIGALRM, update_progress_meter);
	alarm(UPDATE_INTERVAL);
	errno = save_errno;
}

void
start_progress_meter(const char *f, off_t filesize, off_t *ctr)
{
	start = last_update = monotime_double();
	file = f;
	start_pos = *ctr;
	end_pos = filesize;
	cur_pos = 0;
	counter = ctr;
	stalled = 0;
	bytes_per_second = 0;

	setscreensize();
	if (can_output())
		refresh_progress_meter();

	signal(SIGALRM, update_progress_meter);
	signal(SIGWINCH, sig_winch);
	alarm(UPDATE_INTERVAL);
}

void
stop_progress_meter(void)
{
	alarm(0);

	if (!can_output())
		return;

	/* Ensure we complete the progress */
	if (cur_pos != end_pos)
		refresh_progress_meter();

	atomicio(vwrite, STDOUT_FILENO, "\n", 1);
}

/*ARGSUSED*/
static void
sig_winch(int sig)
{
	win_resized = 1;
}

static void
setscreensize(void)
{
	struct winsize winsize;

	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize) != -1 &&
	    winsize.ws_col != 0) {
		if (winsize.ws_col > MAX_WINSIZE)
			win_size = MAX_WINSIZE;
		else
			win_size = winsize.ws_col;
	} else
		win_size = DEFAULT_WINSIZE;
	win_size += 1;					/* trailing \0 */
}
@


1.44
log
@Backout rev. 1.43 for now.

The function update_progress_meter() calls refresh_progress_meter()
which calls snmprintf() which calls malloc(); but update_progress_meter()
acts as the SIGALRM signal handler.

"malloc(): error: recursive call" reported by sobrado@@.
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.43 2016/05/25 23:48:45 schwarze Exp $ */
d172 3
a174 1
	if (end_pos != 0)
a175 2
	else
		percent = 100;
@


1.43
log
@To prevent screwing up terminal settings when printing to the
terminal, for ASCII and UTF-8, escape bytes not forming characters
and bytes forming non-printable characters with vis(3) VIS_OCTAL.
For other character sets, abort printing of the current string in
these cases.  In particular,
* let scp(1) respect the local user's LC_CTYPE locale(1);
* sanitize data received from the remote host;
* sanitize filenames, usernames, and similar data even locally;
* take character display widths into account for the progressmeter.

This is believed to be sufficient to keep the local terminal safe
on OpenBSD, but bad things can still happen on other systems with
state-dependent locales because many places in the code print
unencoded ASCII characters into the output stream.

Using feedback from djm@@ and martijn@@,
various aspects discussed with many others.

deraadt@@ says it should go in now, i probably already hesitated too long
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.42 2016/03/02 22:42:40 dtucker Exp $ */
a31 1
#include <stdarg.h>
a39 1
#include "utf8.h"
d120 1
a120 1
	char buf[MAX_WINSIZE * 4 + 1];
d127 1
a127 1
	size_t i;
d158 1
a158 2
	buf[0] = '\r';
	buf[1] = '\0';
d161 8
a168 6
		(void) snmprintf(buf + 1, sizeof(buf) - 1 - 35,
		    &file_len, "%s", file);
		i = strlen(buf);
		while (++file_len < win_size - 35 && i + 1 < sizeof(buf))
			buf[i++] = ' ';
		buf[i] = '\0';
d176 1
a176 1
	snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
d180 1
a180 1
	format_size(buf + strlen(buf), sizeof(buf) - strlen(buf),
d182 1
a182 1
	strlcat(buf, " ", sizeof(buf));
d185 1
a185 1
	format_rate(buf + strlen(buf), sizeof(buf) - strlen(buf),
d187 1
a187 1
	strlcat(buf, "/s ", sizeof(buf));
d196 1
a196 1
		strlcat(buf, "- stalled -", sizeof(buf));
d198 1
a198 1
		strlcat(buf, "  --:-- ETA", sizeof(buf));
d211 1
a211 1
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
d214 1
a214 1
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
d218 1
a218 1
			strlcat(buf, " ETA", sizeof(buf));
d220 1
a220 1
			strlcat(buf, "    ", sizeof(buf));
a221 2
	if (win_size < 35)
		buf[win_size] = '\0';
d223 1
a223 1
	atomicio(vwrite, STDOUT_FILENO, buf, strlen(buf));
@


1.42
log
@Improve precision of progressmeter for sftp and scp by storing sub-second
timestamps.  Pointed out by mmcc@@, ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.41 2015/01/14 13:54:13 djm Exp $ */
d32 1
d41 1
d122 1
a122 1
	char buf[MAX_WINSIZE + 1];
d129 1
a129 1
	int i, len;
d160 2
a161 1
	buf[0] = '\0';
d164 6
a169 8
		len = snprintf(buf, file_len + 1, "\r%s", file);
		if (len < 0)
			len = 0;
		if (len >= file_len + 1)
			len = file_len;
		for (i = len; i < file_len; i++)
			buf[i] = ' ';
		buf[file_len] = '\0';
d177 1
a177 1
	snprintf(buf + strlen(buf), win_size - strlen(buf),
d181 1
a181 1
	format_size(buf + strlen(buf), win_size - strlen(buf),
d183 1
a183 1
	strlcat(buf, " ", win_size);
d186 1
a186 1
	format_rate(buf + strlen(buf), win_size - strlen(buf),
d188 1
a188 1
	strlcat(buf, "/s ", win_size);
d197 1
a197 1
		strlcat(buf, "- stalled -", win_size);
d199 1
a199 1
		strlcat(buf, "  --:-- ETA", win_size);
d212 1
a212 1
			snprintf(buf + strlen(buf), win_size - strlen(buf),
d215 1
a215 1
			snprintf(buf + strlen(buf), win_size - strlen(buf),
d219 1
a219 1
			strlcat(buf, " ETA", win_size);
d221 1
a221 1
			strlcat(buf, "    ", win_size);
d223 2
d226 1
a226 1
	atomicio(vwrite, STDOUT_FILENO, buf, win_size - 1);
@


1.41
log
@update sftp client and server to new buffer API.
pretty much just mechanical changes; with & ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.40 2013/09/19 00:24:52 djm Exp $ */
d64 2
a65 2
static time_t start;		/* start progress */
static time_t last_update;	/* last progress update */
a120 1
	time_t now;
d122 1
a122 1
	double elapsed;
d132 1
a132 1
	now = monotime();
d250 1
a250 1
	start = last_update = monotime();
@


1.40
log
@store the initial file offset so the progress meter doesn't freak out
when resuming sftp transfers. bz#2137; patch from Iain Morgan; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.39 2013/06/02 13:33:05 dtucker Exp $ */
d66 1
a66 1
static char *file;		/* name of the file being transferred */
d249 1
a249 1
start_progress_meter(char *f, off_t filesize, off_t *ctr)
@


1.39
log
@Add misc.h for monotim prototype.
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.38 2013/06/01 13:15:52 dtucker Exp $ */
d67 1
d131 1
a131 1
	transferred = *counter - cur_pos;
d141 1
a141 1
		transferred = end_pos;
d253 1
@


1.38
log
@Use clock_gettime(CLOCK_MONOTONIC ...) for ssh timers so that things like
keepalives and rekeying will work properly over clock steps.  Suggested by
markus@@, "looks good" djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.37 2006/08/03 03:34:42 deraadt Exp $ */
d39 1
@


1.37
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.36 2006/08/01 23:36:12 stevesk Exp $ */
d131 1
a131 1
	now = time(NULL);
d249 1
a249 1
	start = last_update = time(NULL);
@


1.36
log
@clean extra spaces
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.35 2006/08/01 23:22:47 stevesk Exp $ */
a25 2
#include "includes.h"

d28 1
@


1.35
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.34 2006/07/22 20:48:23 stevesk Exp $ */
d166 1
a166 1
		for (i = len;  i < file_len; i++ )
@


1.34
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.33 2006/07/22 19:08:54 stevesk Exp $ */
d33 1
@


1.33
log
@move #include <time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.32 2006/07/21 21:26:55 stevesk Exp $ */
d33 1
@


1.32
log
@ARGSUSED for signal handler
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.31 2006/07/17 01:31:09 stevesk Exp $ */
d33 1
@


1.31
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.30 2006/07/11 20:07:25 stevesk Exp $ */
d224 1
@


1.30
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: progressmeter.c,v 1.29 2006/03/25 13:17:02 djm Exp $ */
d28 1
d33 1
@


1.29
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 1
@


1.28
log
@ARGSUSED for signal handlers
@
text
@d1 1
@


1.27
log
@RCSID() can die
@
text
@d274 1
@


1.26
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@a25 1
RCSID("$OpenBSD: progressmeter.c,v 1.25 2006/02/10 00:27:13 stevesk Exp $");
@


1.26.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: progressmeter.c,v 1.37 2006/08/03 03:34:42 deraadt Exp $ */
d25 3
a27 1
#include <sys/types.h>
a28 1
#include <sys/uio.h>
a29 1
#include <errno.h>
a30 4
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
d160 1
a160 1
		for (i = len; i < file_len; i++)
a220 1
/*ARGSUSED*/
a274 1
/*ARGSUSED*/
@


1.25
log
@move #include <sys/ioctl.h> out of includes.h; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.24 2005/06/07 13:25:23 jaredy Exp $");
d29 2
@


1.24
log
@catch SIGWINCH and resize progress meter accordingly; ok markus dtucker
@
text
@d26 3
a28 1
RCSID("$OpenBSD: progressmeter.c,v 1.23 2005/04/28 10:17:56 moritz Exp $");
@


1.24.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: progressmeter.c,v 1.37 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 10
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/uio.h>

#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
d156 1
a156 1
		for (i = len; i < file_len; i++)
a216 1
/*ARGSUSED*/
a270 1
/*ARGSUSED*/
@


1.23
log
@add snprintf checks. ok djm@@ markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.22 2004/07/11 17:48:47 deraadt Exp $");
d44 4
d63 1
d224 4
a238 2
	struct winsize winsize;

d247 1
a247 10
	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize) != -1 &&
	    winsize.ws_col != 0) {
		if (winsize.ws_col > MAX_WINSIZE)
			win_size = MAX_WINSIZE;
		else
			win_size = winsize.ws_col;
	} else
		win_size = DEFAULT_WINSIZE;
	win_size += 1;					/* trailing \0 */

d252 1
d269 22
@


1.22
log
@spaces
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.21 2004/06/21 17:36:31 avsm Exp $");
d149 2
@


1.22.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.24 2005/06/07 13:25:23 jaredy Exp $");
a43 4
/* window resizing */
static void sig_winch(int);
static void setscreensize(void);

a58 1
static volatile sig_atomic_t win_resized; /* for window resizing */
a148 2
		if (len >= file_len + 1)
			len = file_len;
a216 4
	if (win_resized) {
		setscreensize();
		win_resized = 0;
	}
d228 2
d238 10
a247 1
	setscreensize();
a251 1
	signal(SIGWINCH, sig_winch);
a267 22
}

static void
sig_winch(int sig)
{
	win_resized = 1;
}

static void
setscreensize(void)
{
	struct winsize winsize;

	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize) != -1 &&
	    winsize.ws_col != 0) {
		if (winsize.ws_col > MAX_WINSIZE)
			win_size = MAX_WINSIZE;
		else
			win_size = winsize.ws_col;
	} else
		win_size = DEFAULT_WINSIZE;
	win_size += 1;					/* trailing \0 */
@


1.22.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.24 2005/06/07 13:25:23 jaredy Exp $");
a43 4
/* window resizing */
static void sig_winch(int);
static void setscreensize(void);

a58 1
static volatile sig_atomic_t win_resized; /* for window resizing */
a148 2
		if (len >= file_len + 1)
			len = file_len;
a216 4
	if (win_resized) {
		setscreensize();
		win_resized = 0;
	}
d228 2
d238 10
a247 1
	setscreensize();
a251 1
	signal(SIGWINCH, sig_winch);
a267 22
}

static void
sig_winch(int sig)
{
	win_resized = 1;
}

static void
setscreensize(void)
{
	struct winsize winsize;

	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize) != -1 &&
	    winsize.ws_col != 0) {
		if (winsize.ws_col > MAX_WINSIZE)
			win_size = MAX_WINSIZE;
		else
			win_size = winsize.ws_col;
	} else
		win_size = DEFAULT_WINSIZE;
	win_size += 1;					/* trailing \0 */
@


1.21
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.20 2004/05/11 19:01:43 deraadt Exp $");
d50 5
a54 5
static time_t start; 		/* start progress */
static time_t last_update; 	/* last progress update */
static char *file; 		/* name of the file being transferred */
static off_t end_pos; 		/* ending position of transfer */
static off_t cur_pos; 		/* transfer position as of last refresh */
d56 3
a58 3
static long stalled; 		/* how long we have been stalled */
static int bytes_per_second; 	/* current speed in bytes per second */
static int win_size; 		/* terminal window size */
@


1.20
log
@improve some code lint did not like; djm millert ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.19 2004/02/05 15:33:33 markus Exp $");
d226 1
a226 1
start_progress_meter(char *f, off_t filesize, off_t *stat)
d234 1
a234 1
	counter = stat;
@


1.19
log
@fix ETA for > 4GB; bugzilla #791; ok henning@@ deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.18 2003/12/02 12:15:10 markus Exp $");
d169 1
a169 1
	    bytes_per_second);
@


1.19.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.22 2004/07/11 17:48:47 deraadt Exp $");
d50 5
a54 5
static time_t start;		/* start progress */
static time_t last_update;	/* last progress update */
static char *file;		/* name of the file being transferred */
static off_t end_pos;		/* ending position of transfer */
static off_t cur_pos;		/* transfer position as of last refresh */
d56 3
a58 3
static long stalled;		/* how long we have been stalled */
static int bytes_per_second;	/* current speed in bytes per second */
static int win_size;		/* terminal window size */
d169 1
a169 1
	    (off_t)bytes_per_second);
d226 1
a226 1
start_progress_meter(char *f, off_t filesize, off_t *ctr)
d234 1
a234 1
	counter = ctr;
@


1.18
log
@improvments from andreas@@:
* saner speed estimate for transfers that takes less than a second by
  rounding the time to 1 second.
* when the transfer is finished calculate the actual total speed
  rather than the current speed which is given during the transfer
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.17 2003/11/20 11:39:28 markus Exp $");
d109 1
a109 1
	int bytes_left;
@


1.17
log
@fix rounding errors; from andreas@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.16 2003/09/23 20:18:52 markus Exp $");
d122 1
a122 1
	else
d124 4
d133 1
a133 1
		cur_speed = 0;
@


1.16
log
@don't print trailing \0; bug #709; Robert.Dahlem@@siemens.com
ok millert/deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.15 2003/08/31 12:14:22 markus Exp $");
d82 1
a82 1
	    (long long) bytes / 100,
@


1.15
log
@do write to buf[-1]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.14 2003/08/31 10:26:04 markus Exp $");
d202 1
a202 1
	atomicio(vwrite, STDOUT_FILENO, buf, win_size);
@


1.15.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.19 2004/02/05 15:33:33 markus Exp $");
d82 1
a82 1
	    (long long) (bytes + 5) / 100,
d109 1
a109 1
	off_t bytes_left;
d122 1
a122 1
	else {
a123 4
		/* Calculate true total speed when done */
		transferred = end_pos;
		bytes_per_second = 0;
	}
d129 1
a129 1
		cur_speed = transferred;
d202 1
a202 1
	atomicio(vwrite, STDOUT_FILENO, buf, win_size - 1);
@


1.15.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.22 2004/07/11 17:48:47 deraadt Exp $");
d50 5
a54 5
static time_t start;		/* start progress */
static time_t last_update;	/* last progress update */
static char *file;		/* name of the file being transferred */
static off_t end_pos;		/* ending position of transfer */
static off_t cur_pos;		/* transfer position as of last refresh */
d56 3
a58 3
static long stalled;		/* how long we have been stalled */
static int bytes_per_second;	/* current speed in bytes per second */
static int win_size;		/* terminal window size */
d169 1
a169 1
	    (off_t)bytes_per_second);
d226 1
a226 1
start_progress_meter(char *f, off_t filesize, off_t *ctr)
d234 1
a234 1
	counter = ctr;
@


1.14
log
@pass file_size + 1 to snprintf: fixes printing of truncated
file names; fix based on patch/report from sturm@@;
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.13 2003/07/31 22:34:03 markus Exp $");
d143 2
@


1.13
log
@print rate similar old version; round instead truncate;
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.12 2003/07/30 07:53:27 markus Exp $");
d142 1
a142 1
		len = snprintf(buf, file_len, "\r%s", file);
@


1.12
log
@whitespace
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.11 2003/07/30 07:44:14 markus Exp $");
d42 1
d60 3
d70 19
a90 1
	static const char unit[] = " KMGT";
d94 1
a94 1
		bytes /= 1024;
d140 1
a140 1
	file_len = win_size - 34;
d162 1
a162 1
	format_size(buf + strlen(buf), win_size - strlen(buf),
@


1.11
log
@use only 4 digits in format_size
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.10 2003/07/29 18:26:46 markus Exp $");
a64 1

d219 1
a219 1
	
d238 1
a238 1
	
@


1.10
log
@fix length for "- stalled -"
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.9 2003/07/29 18:24:00 markus Exp $");
d72 1
a72 1
	for (i = 0; bytes > 10240 && unit[i] != 'T'; i++)
d74 1
a74 1
	snprintf(buf, size, "%6lld%c%s",
a116 2
memset(buf, 'a', sizeof(buf));

d119 1
a119 1
	file_len = win_size - 36;
@


1.9
log
@replace 4 clause BSD licensed progressmeter code with a replacement
from Nils Nordman and myself; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.7 2003/06/10 22:20:52 deraadt Exp $");
d154 1
a154 1
		strlcat(buf, "  - stalled -", win_size);
@


1.8
log
@deal with typing of write vs read in atomicio
@
text
@d2 1
a2 2
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 * Copyright (c) 1999 Aaron Campbell.  All rights reserved.
a24 40
/*
 * Copyright (c) 1997-2003 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Luke Mewburn.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

d28 11
a38 1
#include <libgen.h>
d40 2
a41 2
#include "atomicio.h"
#include "progressmeter.h"
d43 2
a44 4
/* Number of seconds before xfer considered "stalled". */
#define STALLTIME	5
/* alarm() interval for updating progress meter. */
#define PROGRESSTIME	1
d46 1
a46 1
/* Signal handler used for updating the progress meter. */
d49 22
a70 2
/* Returns non-zero if we are the foreground process. */
static int foregroundproc(void);
d72 7
a78 2
/* Returns width of the terminal (for progress meter calculations). */
static int get_tty_width(void);
d80 18
a97 2
/* Visual statistics about files as they are transferred. */
static void draw_progress_meter(void);
d99 4
a102 2
/* Time a transfer started. */
static struct timeval start;
d104 5
a108 2
/* Number of bytes of current file transferred so far. */
static volatile off_t *statbytes;
d110 6
a115 2
/* Total size of current file. */
static off_t totalbytes;
d117 1
a117 2
/* Name of current file being transferred. */
static char *curfile;
d119 9
a127 2
/* Time of last update. */
static struct timeval lastupdate;
d129 23
a151 2
/* Size at the time of the last update. */
static off_t lastsize;
d153 9
a161 5
void
start_progress_meter(char *file, off_t filesize, off_t *counter)
{
	if ((curfile = basename(file)) == NULL)
		curfile = file;
d163 11
a173 5
	totalbytes = filesize;
	statbytes = counter;
	(void) gettimeofday(&start, (struct timezone *) 0);
	lastupdate = start;
	lastsize = 0;
d175 5
a179 4
	draw_progress_meter();
	signal(SIGALRM, update_progress_meter);
	alarm(PROGRESSTIME);
}
d181 2
a182 7
void
stop_progress_meter(void)
{
	alarm(0);
	draw_progress_meter();
	if (foregroundproc() != 0)
		atomicio(vwrite, fileno(stdout), "\n", 1);
d188 6
a193 1
	int save_errno = errno;
a194 1
	draw_progress_meter();
d196 1
a196 1
	alarm(PROGRESSTIME);
d200 2
a201 2
static int
foregroundproc(void)
d203 1
a203 2
	static pid_t pgrp = -1;
	int ctty_pgrp;
d205 20
a224 2
	if (pgrp == -1)
		pgrp = getpgrp();
d226 2
a227 2
	return ((ioctl(STDOUT_FILENO, TIOCGPGRP, &ctty_pgrp) != -1 &&
		 ctty_pgrp == pgrp));
d230 2
a231 2
static void
draw_progress_meter(void)
d233 1
a233 12
	static const char spaces[] = "                          "
	    "                                                   "
	    "                                                   "
	    "                                                   "
	    "                                                   "
	    "                                                   ";
	static const char prefixes[] = " KMGTP";
	struct timeval now, td, wait;
	off_t cursize, abbrevsize, bytespersec;
	double elapsed;
	int ratio, remaining, i, ai, bi, nspaces;
	char buf[512];
d235 1
a235 1
	if (foregroundproc() == 0)
d238 5
a242 84
	(void) gettimeofday(&now, (struct timezone *) 0);
	cursize = *statbytes;
	if (totalbytes != 0) {
		ratio = 100.0 * cursize / totalbytes;
		ratio = MAX(ratio, 0);
		ratio = MIN(ratio, 100);
	} else
		ratio = 100;

	abbrevsize = cursize;
	for (ai = 0; abbrevsize >= 10000 && ai < sizeof(prefixes); ai++)
		abbrevsize >>= 10;

	timersub(&now, &lastupdate, &wait);
	if (cursize > lastsize) {
		lastupdate = now;
		lastsize = cursize;
		wait.tv_sec = 0;
	}
	timersub(&now, &start, &td);
	elapsed = td.tv_sec + (td.tv_usec / 1000000.0);

	bytespersec = 0;
	if (cursize > 0) {
		bytespersec = cursize;
		if (elapsed > 0.0)
			bytespersec /= elapsed;
	}
	for (bi = 1; bytespersec >= 1024000 && bi < sizeof(prefixes); bi++)
		bytespersec >>= 10;

    	nspaces = MIN(get_tty_width() - 79, sizeof(spaces) - 1);

	snprintf(buf, sizeof(buf),
	    "\r%-45.45s%.*s%3d%% %4lld%c%c %3lld.%01d%cB/s",
	    curfile,
	    nspaces,
	    spaces,
	    ratio,
	    (long long)abbrevsize,
	    prefixes[ai],
	    ai == 0 ? ' ' : 'B',
	    (long long)(bytespersec / 1024),
	    (int)((bytespersec % 1024) * 10 / 1024),
	    prefixes[bi]
	);

	if (cursize <= 0 || elapsed <= 0.0 || cursize > totalbytes) {
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "   --:-- ETA");
	} else if (wait.tv_sec >= STALLTIME) {
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    " - stalled -");
	} else {
		if (cursize != totalbytes)
			remaining = (int)(totalbytes / (cursize / elapsed) -
			    elapsed);
		else
			remaining = elapsed;

		i = remaining / 3600;
		if (i)
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "%2d:", i);
		else
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "   ");
		i = remaining % 3600;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "%02d:%02d%s", i / 60, i % 60,
		    (cursize != totalbytes) ? " ETA" : "    ");
	}
	atomicio(vwrite, fileno(stdout), buf, strlen(buf));
}

static int
get_tty_width(void)
{
	struct winsize winsize;

	if (ioctl(fileno(stdout), TIOCGWINSZ, &winsize) != -1)
		return (winsize.ws_col ? winsize.ws_col : 80);
	else
		return (80);
@


1.7
log
@mostly ansi cleanup; pval ok
@
text
@d67 1
a67 1
RCSID("$OpenBSD: progressmeter.c,v 1.6 2003/04/07 21:58:05 millert Exp $");
d132 1
a132 1
		atomicio(write, fileno(stdout), "\n", 1);
d250 1
a250 1
	atomicio(write, fileno(stdout), buf, strlen(buf));
@


1.6
log
@The UCB copyright here is incorrect.  This code did not originate
at UCB, it was written by Luke Mewburn.  Updated the copyright at
the author's request.  markus@@ OK
@
text
@d67 1
a67 1
RCSID("$OpenBSD: progressmeter.c,v 1.5 2003/04/03 10:17:35 itojun Exp $");
d127 1
a127 1
stop_progress_meter()
d160 1
a160 1
draw_progress_meter()
@


1.5
log
@remove $OpenBSD$, as other *.c does not have it.
@
text
@d27 2
a28 1
 * Parts from:
d30 6
a35 2
 * Copyright (c) 1983, 1990, 1992, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
d47 5
a51 17
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d53 11
d67 1
a67 1
RCSID("$OpenBSD: progressmeter.c,v 1.4 2003/04/03 07:25:27 itojun Exp $");
@


1.5.2.1
log
@Merge OpenSSH 3.6.1
@
text
@d63 1
a63 1
RCSID("$OpenBSD: progressmeter.c,v 1.3 2003/03/17 10:38:38 markus Exp $");
@


1.4
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

d63 1
a63 1
RCSID("$OpenBSD: progressmeter.c,v 1.3 2003/03/17 10:38:38 markus Exp $");
@


1.3
log
@don't print \n if backgrounded; from ho@@
@
text
@d1 2
d65 1
a65 1
RCSID("$OpenBSD: progressmeter.c,v 1.2 2003/01/12 16:57:02 markus Exp $");
@


1.3.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d2 2
a3 1
 * Copyright (c) 2003 Nils Nordman.  All rights reserved.
d26 36
d63 3
a65 1
RCSID("$OpenBSD: progressmeter.c,v 1.15 2003/08/31 12:14:22 markus Exp $");
d67 1
a68 1
#include "atomicio.h"
d70 31
a100 12
#define DEFAULT_WINSIZE 80
#define MAX_WINSIZE 512
#define PADDING 1		/* padding between the progress indicators */
#define UPDATE_INTERVAL 1	/* update the progress meter every second */
#define STALL_TIME 5		/* we're stalled after this many seconds */

/* determines whether we can output to the terminal */
static int can_output(void);

/* formats and inserts the specified size into the given buffer */
static void format_size(char *, int, off_t);
static void format_rate(char *, int, off_t);
d102 2
a103 2
/* updates the progressmeter to reflect the current state of the transfer */
void refresh_progress_meter(void);
d105 5
a109 2
/* signal handler for updating the progress meter */
static void update_progress_meter(int);
d111 5
a115 9
static time_t start; 		/* start progress */
static time_t last_update; 	/* last progress update */
static char *file; 		/* name of the file being transferred */
static off_t end_pos; 		/* ending position of transfer */
static off_t cur_pos; 		/* transfer position as of last refresh */
static volatile off_t *counter;	/* progress counter */
static long stalled; 		/* how long we have been stalled */
static int bytes_per_second; 	/* current speed in bytes per second */
static int win_size; 		/* terminal window size */
d117 4
a120 2
/* units for format_size */
static const char unit[] = " KMGT";
d122 2
a123 2
static int
can_output(void)
d125 4
a128 1
	return (getpgrp() == tcgetpgrp(STDOUT_FILENO));
d132 1
a132 1
format_rate(char *buf, int size, off_t bytes)
d134 1
a134 1
	int i;
d136 4
a139 12
	bytes *= 100;
	for (i = 0; bytes >= 100*1000 && unit[i] != 'T'; i++)
		bytes = (bytes + 512) / 1024;
	if (i == 0) {
		i++;
		bytes = (bytes + 512) / 1024;
	}
	snprintf(buf, size, "%3lld.%1lld%c%s",
	    (long long) bytes / 100,
	    (long long) (bytes + 5) / 10 % 10,
	    unit[i],
	    i ? "B" : " ");
d142 2
a143 2
static void
format_size(char *buf, int size, off_t bytes)
d145 5
a149 1
	int i;
d151 2
a152 6
	for (i = 0; bytes >= 10000 && unit[i] != 'T'; i++)
		bytes = (bytes + 512) / 1024;
	snprintf(buf, size, "%4lld%c%s",
	    (long long) bytes,
	    unit[i],
	    i ? "B" : " ");
d155 2
a156 2
void
refresh_progress_meter(void)
d158 9
a166 3
	char buf[MAX_WINSIZE + 1];
	time_t now;
	off_t transferred;
d168 2
a169 11
	int percent;
	int bytes_left;
	int cur_speed;
	int hours, minutes, seconds;
	int i, len;
	int file_len;

	transferred = *counter - cur_pos;
	cur_pos = *counter;
	now = time(NULL);
	bytes_left = end_pos - cur_pos;
d171 2
a172 10
	if (bytes_left > 0)
		elapsed = now - last_update;
	else
		elapsed = now - start;

	/* calculate speed */
	if (elapsed != 0)
		cur_speed = (transferred / elapsed);
	else
		cur_speed = 0;
d174 6
a179 4
#define AGE_FACTOR 0.9
	if (bytes_per_second != 0) {
		bytes_per_second = (bytes_per_second * AGE_FACTOR) +
		    (cur_speed * (1.0 - AGE_FACTOR));
d181 1
a181 1
		bytes_per_second = cur_speed;
d183 9
a191 10
	/* filename */
	buf[0] = '\0';
	file_len = win_size - 35;
	if (file_len > 0) {
		len = snprintf(buf, file_len + 1, "\r%s", file);
		if (len < 0)
			len = 0;
		for (i = len;  i < file_len; i++ )
			buf[i] = ' ';
		buf[file_len] = '\0';
d193 2
d196 8
a203 23
	/* percent of transfer done */
	if (end_pos != 0)
		percent = ((float)cur_pos / end_pos) * 100;
	else
		percent = 100;
	snprintf(buf + strlen(buf), win_size - strlen(buf),
	    " %3d%% ", percent);

	/* amount transferred */
	format_size(buf + strlen(buf), win_size - strlen(buf),
	    cur_pos);
	strlcat(buf, " ", win_size);

	/* bandwidth usage */
	format_rate(buf + strlen(buf), win_size - strlen(buf),
	    bytes_per_second);
	strlcat(buf, "/s ", win_size);

	/* ETA */
	if (!transferred)
		stalled += elapsed;
	else
		stalled = 0;
d205 1
a205 9
	if (stalled >= STALL_TIME)
		strlcat(buf, "- stalled -", win_size);
	else if (bytes_per_second == 0 && bytes_left)
		strlcat(buf, "  --:-- ETA", win_size);
	else {
		if (bytes_left > 0)
			seconds = bytes_left / bytes_per_second;
		else
			seconds = elapsed;
d207 24
a230 8
		hours = seconds / 3600;
		seconds -= hours * 3600;
		minutes = seconds / 60;
		seconds -= minutes * 60;

		if (hours != 0)
			snprintf(buf + strlen(buf), win_size - strlen(buf),
			    "%d:%02d:%02d", hours, minutes, seconds);
d232 1
a232 2
			snprintf(buf + strlen(buf), win_size - strlen(buf),
			    "  %02d:%02d", minutes, seconds);
d234 4
a237 2
		if (bytes_left > 0)
			strlcat(buf, " ETA", win_size);
d239 6
a244 1
			strlcat(buf, "    ", win_size);
d246 1
a246 3

	atomicio(vwrite, STDOUT_FILENO, buf, win_size);
	last_update = now;
d249 2
a250 17
static void
update_progress_meter(int ignore)
{
	int save_errno;

	save_errno = errno;

	if (can_output())
		refresh_progress_meter();

	signal(SIGALRM, update_progress_meter);
	alarm(UPDATE_INTERVAL);
	errno = save_errno;
}

void
start_progress_meter(char *f, off_t filesize, off_t *stat)
d254 4
a257 38
	start = last_update = time(NULL);
	file = f;
	end_pos = filesize;
	cur_pos = 0;
	counter = stat;
	stalled = 0;
	bytes_per_second = 0;

	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize) != -1 &&
	    winsize.ws_col != 0) {
		if (winsize.ws_col > MAX_WINSIZE)
			win_size = MAX_WINSIZE;
		else
			win_size = winsize.ws_col;
	} else
		win_size = DEFAULT_WINSIZE;
	win_size += 1;					/* trailing \0 */

	if (can_output())
		refresh_progress_meter();

	signal(SIGALRM, update_progress_meter);
	alarm(UPDATE_INTERVAL);
}

void
stop_progress_meter(void)
{
	alarm(0);

	if (!can_output())
		return;

	/* Ensure we complete the progress */
	if (cur_pos != end_pos)
		refresh_progress_meter();

	atomicio(vwrite, STDOUT_FILENO, "\n", 1);
@


1.3.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: progressmeter.c,v 1.19 2004/02/05 15:33:33 markus Exp $");
d82 1
a82 1
	    (long long) (bytes + 5) / 100,
d109 1
a109 1
	off_t bytes_left;
d122 1
a122 1
	else {
a123 4
		/* Calculate true total speed when done */
		transferred = end_pos;
		bytes_per_second = 0;
	}
d129 1
a129 1
		cur_speed = transferred;
d202 1
a202 1
	atomicio(vwrite, STDOUT_FILENO, buf, win_size - 1);
@


1.3.4.1
log
@These were missed on the update to the last openssh.

Thanks to all who pointed it out.
@
text
@d63 1
a63 1
RCSID("$OpenBSD: progressmeter.c,v 1.3 2003/03/17 10:38:38 markus Exp $");
@


1.3.4.2
log
@upgrade to OpenSSH 3.7
@
text
@d2 2
a3 1
 * Copyright (c) 2003 Nils Nordman.  All rights reserved.
d26 36
d63 3
a65 1
RCSID("$OpenBSD: progressmeter.c,v 1.15 2003/08/31 12:14:22 markus Exp $");
d67 1
a68 1
#include "atomicio.h"
d70 31
a100 12
#define DEFAULT_WINSIZE 80
#define MAX_WINSIZE 512
#define PADDING 1		/* padding between the progress indicators */
#define UPDATE_INTERVAL 1	/* update the progress meter every second */
#define STALL_TIME 5		/* we're stalled after this many seconds */

/* determines whether we can output to the terminal */
static int can_output(void);

/* formats and inserts the specified size into the given buffer */
static void format_size(char *, int, off_t);
static void format_rate(char *, int, off_t);
d102 2
a103 2
/* updates the progressmeter to reflect the current state of the transfer */
void refresh_progress_meter(void);
d105 5
a109 2
/* signal handler for updating the progress meter */
static void update_progress_meter(int);
d111 5
a115 9
static time_t start; 		/* start progress */
static time_t last_update; 	/* last progress update */
static char *file; 		/* name of the file being transferred */
static off_t end_pos; 		/* ending position of transfer */
static off_t cur_pos; 		/* transfer position as of last refresh */
static volatile off_t *counter;	/* progress counter */
static long stalled; 		/* how long we have been stalled */
static int bytes_per_second; 	/* current speed in bytes per second */
static int win_size; 		/* terminal window size */
d117 4
a120 2
/* units for format_size */
static const char unit[] = " KMGT";
d122 2
a123 2
static int
can_output(void)
d125 4
a128 1
	return (getpgrp() == tcgetpgrp(STDOUT_FILENO));
d132 1
a132 1
format_rate(char *buf, int size, off_t bytes)
d134 1
a134 1
	int i;
d136 4
a139 12
	bytes *= 100;
	for (i = 0; bytes >= 100*1000 && unit[i] != 'T'; i++)
		bytes = (bytes + 512) / 1024;
	if (i == 0) {
		i++;
		bytes = (bytes + 512) / 1024;
	}
	snprintf(buf, size, "%3lld.%1lld%c%s",
	    (long long) bytes / 100,
	    (long long) (bytes + 5) / 10 % 10,
	    unit[i],
	    i ? "B" : " ");
d142 2
a143 2
static void
format_size(char *buf, int size, off_t bytes)
d145 5
a149 1
	int i;
d151 2
a152 6
	for (i = 0; bytes >= 10000 && unit[i] != 'T'; i++)
		bytes = (bytes + 512) / 1024;
	snprintf(buf, size, "%4lld%c%s",
	    (long long) bytes,
	    unit[i],
	    i ? "B" : " ");
d155 2
a156 2
void
refresh_progress_meter(void)
d158 9
a166 3
	char buf[MAX_WINSIZE + 1];
	time_t now;
	off_t transferred;
d168 2
a169 11
	int percent;
	int bytes_left;
	int cur_speed;
	int hours, minutes, seconds;
	int i, len;
	int file_len;

	transferred = *counter - cur_pos;
	cur_pos = *counter;
	now = time(NULL);
	bytes_left = end_pos - cur_pos;
d171 2
a172 10
	if (bytes_left > 0)
		elapsed = now - last_update;
	else
		elapsed = now - start;

	/* calculate speed */
	if (elapsed != 0)
		cur_speed = (transferred / elapsed);
	else
		cur_speed = 0;
d174 6
a179 4
#define AGE_FACTOR 0.9
	if (bytes_per_second != 0) {
		bytes_per_second = (bytes_per_second * AGE_FACTOR) +
		    (cur_speed * (1.0 - AGE_FACTOR));
d181 1
a181 1
		bytes_per_second = cur_speed;
d183 9
a191 10
	/* filename */
	buf[0] = '\0';
	file_len = win_size - 35;
	if (file_len > 0) {
		len = snprintf(buf, file_len + 1, "\r%s", file);
		if (len < 0)
			len = 0;
		for (i = len;  i < file_len; i++ )
			buf[i] = ' ';
		buf[file_len] = '\0';
d193 2
d196 8
a203 23
	/* percent of transfer done */
	if (end_pos != 0)
		percent = ((float)cur_pos / end_pos) * 100;
	else
		percent = 100;
	snprintf(buf + strlen(buf), win_size - strlen(buf),
	    " %3d%% ", percent);

	/* amount transferred */
	format_size(buf + strlen(buf), win_size - strlen(buf),
	    cur_pos);
	strlcat(buf, " ", win_size);

	/* bandwidth usage */
	format_rate(buf + strlen(buf), win_size - strlen(buf),
	    bytes_per_second);
	strlcat(buf, "/s ", win_size);

	/* ETA */
	if (!transferred)
		stalled += elapsed;
	else
		stalled = 0;
d205 1
a205 9
	if (stalled >= STALL_TIME)
		strlcat(buf, "- stalled -", win_size);
	else if (bytes_per_second == 0 && bytes_left)
		strlcat(buf, "  --:-- ETA", win_size);
	else {
		if (bytes_left > 0)
			seconds = bytes_left / bytes_per_second;
		else
			seconds = elapsed;
d207 24
a230 8
		hours = seconds / 3600;
		seconds -= hours * 3600;
		minutes = seconds / 60;
		seconds -= minutes * 60;

		if (hours != 0)
			snprintf(buf + strlen(buf), win_size - strlen(buf),
			    "%d:%02d:%02d", hours, minutes, seconds);
d232 1
a232 2
			snprintf(buf + strlen(buf), win_size - strlen(buf),
			    "  %02d:%02d", minutes, seconds);
d234 4
a237 2
		if (bytes_left > 0)
			strlcat(buf, " ETA", win_size);
d239 6
a244 1
			strlcat(buf, "    ", win_size);
d246 1
a246 3

	atomicio(vwrite, STDOUT_FILENO, buf, win_size);
	last_update = now;
d249 2
a250 17
static void
update_progress_meter(int ignore)
{
	int save_errno;

	save_errno = errno;

	if (can_output())
		refresh_progress_meter();

	signal(SIGALRM, update_progress_meter);
	alarm(UPDATE_INTERVAL);
	errno = save_errno;
}

void
start_progress_meter(char *f, off_t filesize, off_t *stat)
d254 4
a257 38
	start = last_update = time(NULL);
	file = f;
	end_pos = filesize;
	cur_pos = 0;
	counter = stat;
	stalled = 0;
	bytes_per_second = 0;

	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize) != -1 &&
	    winsize.ws_col != 0) {
		if (winsize.ws_col > MAX_WINSIZE)
			win_size = MAX_WINSIZE;
		else
			win_size = winsize.ws_col;
	} else
		win_size = DEFAULT_WINSIZE;
	win_size += 1;					/* trailing \0 */

	if (can_output())
		refresh_progress_meter();

	signal(SIGALRM, update_progress_meter);
	alarm(UPDATE_INTERVAL);
}

void
stop_progress_meter(void)
{
	alarm(0);

	if (!can_output())
		return;

	/* Ensure we complete the progress */
	if (cur_pos != end_pos)
		refresh_progress_meter();

	atomicio(vwrite, STDOUT_FILENO, "\n", 1);
@


1.2
log
@allow WARNINGS=yes; ok djm@@
@
text
@d63 1
a63 1
RCSID("$OpenBSD: progressmeter.c,v 1.1 2003/01/10 08:19:07 fgsch Exp $");
d127 2
a128 1
	atomicio(write, fileno(stdout), "\n", 1);
@


1.1
log
@sftp progress meter support.
original diffs by Nils Nordman <nino at nforced dot com> via markus@@, merged
to -current by me, djm@@ ok.
@
text
@d63 1
a63 1
RCSID("$OpenBSD: scp.c,v 1.95 2002/12/05 11:08:35 markus Exp $");
d68 1
d85 1
a85 1
static void draw_progress_meter();
@

