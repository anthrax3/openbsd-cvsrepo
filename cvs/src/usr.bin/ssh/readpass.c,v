head	1.51;
access;
symbols
	OPENBSD_6_2:1.51.0.10
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.51.0.8
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.6
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.50.0.8
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.50.0.6
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.48.0.10
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.8
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.6
	OPENBSD_5_0:1.48.0.4
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.47.0.18
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.47.0.14
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.47.0.16
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.12
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.10
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.8
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.47.0.6
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.47.0.4
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.28.0.6
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.4
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.27.0.4
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.51
date	2015.12.11.00.20.04;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	5insXikipROHNgzs;

1.50
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2010.12.15.00.49.27;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.44;

1.44
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.10.16.37.36;	author stevesk;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.09.15.15.10;	author stevesk;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.08.14.45.49;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.06.10.20.20;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.10.01.44.26;	author stevesk;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.02.21.13.22;	author markus;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2005.04.23.23.43.47;	author dtucker;	state Exp;
branches;
next	1.31;

1.31
date	2004.10.29.22.53.56;	author djm;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2004.06.17.15.10.14;	author djm;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.23.13.50.27;	author markus;	state Exp;
branches
	1.28.4.1
	1.28.6.1;
next	1.27;

1.27
date	2002.03.26.15.58.46;	author markus;	state Exp;
branches
	1.27.2.1
	1.27.4.1;
next	1.26;

1.26
date	2002.02.13.00.39.15;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.11.23.02.18;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.21.08.53.45;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.08.10.51.08;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.14.15.10.16;	author stevesk;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.07.10.21.49.12;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.02.22.29.20;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.24.05.35.33;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.23.15.12.19;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.06.17.52.07;	author mouring;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.02.01.25.39;	author mouring;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.18.21.57.41;	author markus;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.21.19.05.54;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.11.20.14.39;	author markus;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.06.20.01.39.44;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.14.10.30.32;	author markus;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.01.21.21.16.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.12.08.19.32.55;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.11.24.19.53.50;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.11.23.22.25.54;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	99.10.11.20.24.54;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	99.09.30.08.34.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.30.05.03.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.37;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.09.01.18.23.21;	author jason;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2000.11.08.21.31.08;	author jason;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.03.12.15.44.13;	author jason;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.03.21.18.52.58;	author jason;	state Exp;
branches;
next	;

1.12.2.1
date	2001.02.16.20.13.11;	author jason;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.02.19.17.19.13;	author jason;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.03.21.19.46.27;	author jason;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.05.07.21.09.32;	author jason;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.15.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.22.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	;

1.27.2.1
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.27.4.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.28.4.1
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.28.6.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.28.6.2;

1.28.6.2
date	2005.03.10.17.15.04;	author brad;	state Exp;
branches;
next	;

1.30.2.1
date	2005.03.10.16.28.27;	author brad;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2005.09.04.18.40.03;	author brad;	state Exp;
branches;
next	;

1.33.2.1
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.35.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Pass (char *)NULL rather than (char *)0 to execl and execlp.

ok dtucker@@
@
text
@/* $OpenBSD: readpass.c,v 1.50 2014/02/02 03:44:31 djm Exp $ */
/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <readpassphrase.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "misc.h"
#include "pathnames.h"
#include "log.h"
#include "ssh.h"
#include "uidswap.h"

static char *
ssh_askpass(char *askpass, const char *msg)
{
	pid_t pid, ret;
	size_t len;
	char *pass;
	int p[2], status;
	char buf[1024];
	void (*osigchld)(int);

	if (fflush(stdout) != 0)
		error("ssh_askpass: fflush: %s", strerror(errno));
	if (askpass == NULL)
		fatal("internal error: askpass undefined");
	if (pipe(p) < 0) {
		error("ssh_askpass: pipe: %s", strerror(errno));
		return NULL;
	}
	osigchld = signal(SIGCHLD, SIG_DFL);
	if ((pid = fork()) < 0) {
		error("ssh_askpass: fork: %s", strerror(errno));
		signal(SIGCHLD, osigchld);
		return NULL;
	}
	if (pid == 0) {
		permanently_drop_suid(getuid());
		close(p[0]);
		if (dup2(p[1], STDOUT_FILENO) < 0)
			fatal("ssh_askpass: dup2: %s", strerror(errno));
		execlp(askpass, askpass, msg, (char *)NULL);
		fatal("ssh_askpass: exec(%s): %s", askpass, strerror(errno));
	}
	close(p[1]);

	len = 0;
	do {
		ssize_t r = read(p[0], buf + len, sizeof(buf) - 1 - len);

		if (r == -1 && errno == EINTR)
			continue;
		if (r <= 0)
			break;
		len += r;
	} while (sizeof(buf) - 1 - len > 0);
	buf[len] = '\0';

	close(p[0]);
	while ((ret = waitpid(pid, &status, 0)) < 0)
		if (errno != EINTR)
			break;
	signal(SIGCHLD, osigchld);
	if (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0) {
		explicit_bzero(buf, sizeof(buf));
		return NULL;
	}

	buf[strcspn(buf, "\r\n")] = '\0';
	pass = xstrdup(buf);
	explicit_bzero(buf, sizeof(buf));
	return pass;
}

/*
 * Reads a passphrase from /dev/tty with echo turned off/on.  Returns the
 * passphrase (allocated with xmalloc).  Exits if EOF is encountered. If
 * RP_ALLOW_STDIN is set, the passphrase will be read from stdin if no
 * tty is available
 */
char *
read_passphrase(const char *prompt, int flags)
{
	char *askpass = NULL, *ret, buf[1024];
	int rppflags, use_askpass = 0, ttyfd;

	rppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;
	if (flags & RP_USE_ASKPASS)
		use_askpass = 1;
	else if (flags & RP_ALLOW_STDIN) {
		if (!isatty(STDIN_FILENO)) {
			debug("read_passphrase: stdin is not a tty");
			use_askpass = 1;
		}
	} else {
		rppflags |= RPP_REQUIRE_TTY;
		ttyfd = open(_PATH_TTY, O_RDWR);
		if (ttyfd >= 0)
			close(ttyfd);
		else {
			debug("read_passphrase: can't open %s: %s", _PATH_TTY,
			    strerror(errno));
			use_askpass = 1;
		}
	}

	if ((flags & RP_USE_ASKPASS) && getenv("DISPLAY") == NULL)
		return (flags & RP_ALLOW_EOF) ? NULL : xstrdup("");

	if (use_askpass && getenv("DISPLAY")) {
		if (getenv(SSH_ASKPASS_ENV))
			askpass = getenv(SSH_ASKPASS_ENV);
		else
			askpass = _PATH_SSH_ASKPASS_DEFAULT;
		if ((ret = ssh_askpass(askpass, prompt)) == NULL)
			if (!(flags & RP_ALLOW_EOF))
				return xstrdup("");
		return ret;
	}

	if (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {
		if (flags & RP_ALLOW_EOF)
			return NULL;
		return xstrdup("");
	}

	ret = xstrdup(buf);
	explicit_bzero(buf, sizeof(buf));
	return ret;
}

int
ask_permission(const char *fmt, ...)
{
	va_list args;
	char *p, prompt[1024];
	int allowed = 0;

	va_start(args, fmt);
	vsnprintf(prompt, sizeof(prompt), fmt, args);
	va_end(args);

	p = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);
	if (p != NULL) {
		/*
		 * Accept empty responses and responses consisting
		 * of the word "yes" as affirmative.
		 */
		if (*p == '\0' || *p == '\n' ||
		    strcasecmp(p, "yes") == 0)
			allowed = 1;
		free(p);
	}

	return (allowed);
}
@


1.50
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.49 2013/05/17 00:13:14 djm Exp $ */
d76 1
a76 1
		execlp(askpass, askpass, msg, (char *) 0);
@


1.49
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.48 2010/12/15 00:49:27 djm Exp $ */
d99 1
a99 1
		memset(buf, 0, sizeof(buf));
d105 1
a105 1
	memset(buf, 0, sizeof(buf));
d162 1
a162 1
	memset(buf, 'x', sizeof buf);
@


1.48
log
@fix ControlMaster=ask regression

reset SIGCHLD handler before fork (and restore it after) so we don't miss
the the askpass child's exit status. Correct test for exit status/signal to
account for waitpid() failure; with claudio@@ ok claudio@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.47 2006/08/03 03:34:42 deraadt Exp $ */
d186 1
a186 1
		xfree(p);
@


1.47
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.46 2006/08/01 23:22:47 stevesk Exp $ */
d33 1
d50 1
a50 1
	pid_t pid;
d53 1
a53 1
	int p[2], status, ret;
d55 1
d65 1
d68 1
d81 1
a81 1
	len = ret = 0;
d83 3
a85 2
		ret = read(p[0], buf + len, sizeof(buf) - 1 - len);
		if (ret == -1 && errno == EINTR)
d87 1
a87 1
		if (ret <= 0)
d89 1
a89 1
		len += ret;
d94 1
a94 1
	while (waitpid(pid, &status, 0) < 0)
d97 2
a98 2

	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
@


1.46
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.45 2006/07/26 13:57:17 stevesk Exp $ */
a24 2

#include "includes.h"
@


1.45
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.44 2006/07/22 20:48:23 stevesk Exp $ */
d36 1
@


1.44
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.43 2006/07/17 01:31:09 stevesk Exp $ */
d36 1
@


1.43
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.42 2006/07/11 20:07:25 stevesk Exp $ */
d36 1
@


1.42
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.41 2006/07/10 16:37:36 stevesk Exp $ */
d36 1
@


1.41
log
@move #include <stdarg.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.40 2006/07/09 15:15:10 stevesk Exp $ */
d31 1
@


1.40
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.39 2006/06/08 14:45:49 markus Exp $ */
d34 1
@


1.39
log
@do not set the gid, noted by solar; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.38 2006/06/06 10:20:20 markus Exp $ */
d31 1
@


1.38
log
@replace remaining setuid() calls with permanently_set_uid() and
check seteuid() return values; report Marcus Meissner; ok dtucker djm
@
text
@d1 1
a1 1
/* $OpenBSD: readpass.c,v 1.37 2006/03/25 13:17:02 djm Exp $ */
d63 1
a63 1
		permanently_set_uid(getpwuid(getuid()));
@


1.37
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d39 1
d63 1
a63 2
		seteuid(getuid());
		setuid(getuid());
@


1.36
log
@RCSID() can die
@
text
@d1 1
@


1.35
log
@move #include <sys/wait.h> out of includes.h; ok markus@@
@
text
@a25 1
RCSID("$OpenBSD: readpass.c,v 1.34 2006/02/08 12:15:27 stevesk Exp $");
@


1.35.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: readpass.c,v 1.47 2006/08/03 03:34:42 deraadt Exp $ */
d25 3
a30 2
#include <errno.h>
#include <fcntl.h>
a32 5
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a38 1
#include "uidswap.h"
d62 2
a63 1
		permanently_drop_suid(getuid());
@


1.34
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d26 4
a29 1
RCSID("$OpenBSD: readpass.c,v 1.33 2005/05/02 21:13:22 markus Exp $");
@


1.33
log
@missing {}
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.32 2005/04/23 23:43:47 dtucker Exp $");
d28 1
@


1.33.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: readpass.c,v 1.47 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 2
#include <sys/types.h>
#include <sys/wait.h>
a27 3
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
a28 5
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a34 1
#include "uidswap.h"
d58 2
a59 1
		permanently_drop_suid(getuid());
@


1.32
log
@Add debug message if read_passphrase can't open /dev/tty; bz #471; ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.31 2004/10/29 22:53:56 djm Exp $");
d111 1
a111 1
		if (!isatty(STDIN_FILENO))
d114 1
@


1.31
log
@factor out common permission-asking code to separate function; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.30 2004/06/17 15:10:14 djm Exp $");
d112 1
d119 3
a121 1
		else
d123 1
@


1.31.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.33 2005/05/02 21:13:22 markus Exp $");
d111 1
a111 2
		if (!isatty(STDIN_FILENO)) {
			debug("read_passphrase: stdin is not a tty");
a112 1
		}
d118 1
a118 3
		else {
			debug("read_passphrase: can't open %s: %s", _PATH_TTY,
			    strerror(errno));
a119 1
		}
@


1.30
log
@Add option for confirmation (ControlMaster=ask) via ssh-askpass before opening
shared connections; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.29 2004/05/08 00:21:31 djm Exp $");
d145 26
@


1.30.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.31 2004/10/29 22:53:56 djm Exp $");
a144 26
}

int
ask_permission(const char *fmt, ...)
{
	va_list args;
	char *p, prompt[1024];
	int allowed = 0;

	va_start(args, fmt);
	vsnprintf(prompt, sizeof(prompt), fmt, args);
	va_end(args);

	p = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);
	if (p != NULL) {
		/*
		 * Accept empty responses and responses consisting
		 * of the word "yes" as affirmative.
		 */
		if (*p == '\0' || *p == '\n' ||
		    strcasecmp(p, "yes") == 0)
			allowed = 1;
		xfree(p);
	}

	return (allowed);
@


1.30.2.2
log
@upgrade to OpenSSH 4.2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.33 2005/05/02 21:13:22 markus Exp $");
d111 1
a111 2
		if (!isatty(STDIN_FILENO)) {
			debug("read_passphrase: stdin is not a tty");
a112 1
		}
d118 1
a118 3
		else {
			debug("read_passphrase: can't open %s: %s", _PATH_TTY,
			    strerror(errno));
a119 1
		}
@


1.29
log
@kill a tiny header; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.28 2003/01/23 13:50:27 markus Exp $");
d108 3
a110 1
	if (flags & RP_ALLOW_STDIN) {
d121 3
@


1.28
log
@ssh-add -c, prompt user for confirmation (using ssh-askpass) when
private agent key is used; with djm@@; test by dugsong@@, djm@@; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.27 2002/03/26 15:58:46 markus Exp $");
d31 1
a31 1
#include "readpass.h"
@


1.28.4.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.30 2004/06/17 15:10:14 djm Exp $");
d31 1
a31 1
#include "misc.h"
d108 1
a108 3
	if (flags & RP_USE_ASKPASS)
		use_askpass = 1;
	else if (flags & RP_ALLOW_STDIN) {
a118 3

	if ((flags & RP_USE_ASKPASS) && getenv("DISPLAY") == NULL)
		return (flags & RP_ALLOW_EOF) ? NULL : xstrdup("");
@


1.28.6.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.30 2004/06/17 15:10:14 djm Exp $");
d31 1
a31 1
#include "misc.h"
d108 1
a108 3
	if (flags & RP_USE_ASKPASS)
		use_askpass = 1;
	else if (flags & RP_ALLOW_STDIN) {
a118 3

	if ((flags & RP_USE_ASKPASS) && getenv("DISPLAY") == NULL)
		return (flags & RP_ALLOW_EOF) ? NULL : xstrdup("");
@


1.28.6.2
log
@upgrade to OpenSSH 4.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.31 2004/10/29 22:53:56 djm Exp $");
a144 26
}

int
ask_permission(const char *fmt, ...)
{
	va_list args;
	char *p, prompt[1024];
	int allowed = 0;

	va_start(args, fmt);
	vsnprintf(prompt, sizeof(prompt), fmt, args);
	va_end(args);

	p = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);
	if (p != NULL) {
		/*
		 * Accept empty responses and responses consisting
		 * of the word "yes" as affirmative.
		 */
		if (*p == '\0' || *p == '\n' ||
		    strcasecmp(p, "yes") == 0)
			allowed = 1;
		xfree(p);
	}

	return (allowed);
@


1.27
log
@client side support for PASSWD_CHANGEREQ
based on work by johan.andersson@@appgate.com; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.26 2002/02/13 00:39:15 markus Exp $");
d51 1
a51 1
		return xstrdup("");
d55 1
a55 1
		return xstrdup("");
d84 5
d125 4
a128 1
		return ssh_askpass(askpass, prompt);
@


1.27.2.1
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.28 2003/01/23 13:50:27 markus Exp $");
d51 1
a51 1
		return NULL;
d55 1
a55 1
		return NULL;
a83 5
	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
		memset(buf, 0, sizeof(buf));
		return NULL;
	}

d120 1
a120 4
		if ((ret = ssh_askpass(askpass, prompt)) == NULL)
			if (!(flags & RP_ALLOW_EOF))
				return xstrdup("");
		return ret;
@


1.27.4.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.28 2003/01/23 13:50:27 markus Exp $");
d51 1
a51 1
		return NULL;
d55 1
a55 1
		return NULL;
a83 5
	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
		memset(buf, 0, sizeof(buf));
		return NULL;
	}

d120 1
a120 4
		if ((ret = ssh_askpass(askpass, prompt)) == NULL)
			if (!(flags & RP_ALLOW_EOF))
				return xstrdup("");
		return ret;
@


1.27.4.2
log
@upgrade to OpenSSH 3.7
@
text
@@


1.26
log
@readpass.c is not longer from UCB, since we now use readpassphrase(3)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.25 2002/01/11 23:02:18 markus Exp $");
d123 3
a125 1
	if (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL)
d127 1
@


1.25
log
@use _PATH_TTY
@
text
@d2 1
a2 2
 * Copyright (c) 1988, 1993
 *      The Regents of the University of California.  All rights reserved.
a11 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d13 10
a22 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.24 2001/12/21 08:53:45 djm Exp $");
@


1.24
log
@Avoid interruptable passphrase read; ok markus@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.23 2001/11/08 10:51:08 markus Exp $");
d117 1
a117 1
		ttyfd = open("/dev/tty", O_RDWR);
@


1.23
log
@don't strdup too much data; from gotoh@@taiyo.co.jp; ok millert.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.22 2001/07/14 15:10:16 stevesk Exp $");
d51 1
a51 1
	int p[2], status;
d76 12
a87 1
	len = read(p[0], buf, sizeof buf -1);
d92 1
a92 3
	if (len <= 1)
		return xstrdup("");
	buf[len] = '\0';
@


1.22
log
@delete spurious #includes; ok deraadt@@ markus@@
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.21 2001/07/10 21:49:12 markus Exp $");
d50 1
a50 1
	char *nl, *pass;
d76 1
a76 1
	len = read(p[0], buf, sizeof buf);
d83 2
a84 3
	nl = strchr(buf, '\n');
	if (nl)
		*nl = '\0';
@


1.22.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.23 2001/11/08 10:51:08 markus Exp $");
d50 1
a50 1
	char *pass;
d76 1
a76 1
	len = read(p[0], buf, sizeof buf -1);
d83 3
a85 2
	buf[len] = '\0';
	buf[strcspn(buf, "\r\n")] = '\0';
@


1.22.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d2 2
a3 1
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
d13 7
d21 11
a31 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.26 2002/02/13 00:39:15 markus Exp $");
d51 1
a51 1
	int p[2], status, ret;
d76 1
a76 12

	len = ret = 0;
	do {
		ret = read(p[0], buf + len, sizeof(buf) - 1 - len);
		if (ret == -1 && errno == EINTR)
			continue;
		if (ret <= 0)
			break;
		len += ret;
	} while (sizeof(buf) - 1 - len > 0);
	buf[len] = '\0';

d81 3
a83 1

d108 1
a108 1
		ttyfd = open(_PATH_TTY, O_RDWR);
@


1.22.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.27 2002/03/26 15:58:46 markus Exp $");
d123 1
a123 3
	if (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {
		if (flags & RP_ALLOW_EOF)
			return NULL;
a124 1
	}
@


1.21
log
@don't panic if fork or pipe fail (just return an empty passwd).
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.20 2001/07/02 22:29:20 markus Exp $");
a42 1
#include "atomicio.h"
@


1.20
log
@do not return NULL, use "" instead.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.19 2001/06/24 05:35:33 markus Exp $");
d59 8
a66 4
	if (pipe(p) < 0)
		fatal("ssh_askpass: pipe: %s", strerror(errno));
	if ((pid = fork()) < 0)
		fatal("ssh_askpass: fork: %s", strerror(errno));
@


1.19
log
@switch to readpassphrase(3)
2.7/8-stable needs readpassphrase.[ch] from libc
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.18 2001/06/23 15:12:19 itojun Exp $");
d122 1
a122 1
		return NULL;
@


1.18
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d35 3
a37 1
RCSID("$OpenBSD: readpass.c,v 1.17 2001/05/06 17:52:07 mouring Exp $");
a39 1
#include "cli.h"
a87 1

d89 4
a92 8
 * Reads a passphrase from /dev/tty with echo turned off.  Returns the
 * passphrase (allocated with xmalloc), being very careful to ensure that
 * no other userland buffer is storing the password.
 */
/*
 * Note:  the funcationallity of this routing has been moved to
 * cli_read_passphrase().  This routing remains to maintain
 * compatibility with existing code.
d95 1
a95 1
read_passphrase(const char *prompt, int from_stdin)
d97 2
a98 2
	char *askpass = NULL;
	int use_askpass = 0, ttyfd;
d100 2
a101 1
	if (from_stdin) {
d105 1
d121 6
a126 1
	return cli_read_passphrase(prompt, from_stdin, 0);
@


1.17
log
@Use const for 'prompt'.  Brought over from portable tree.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.16 2001/05/02 01:25:39 mouring Exp $");
d45 1
a45 1
char *
@


1.16
log
@Put the 'const' back into ssh_askpass() function.  Pointed out
by Mark Miller <markm@@swoon.net>.  OK Markus
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.15 2001/04/18 21:57:41 markus Exp $");
d99 1
a99 1
read_passphrase(char *prompt, int from_stdin)
@


1.15
log
@call askpass from ssh, too, based on work by roth@@feep.net, ok deraadt
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.14 2001/02/08 19:30:52 itojun Exp $");
d46 1
a46 1
ssh_askpass(char *askpass, char *msg)
@


1.15.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d35 1
a35 3
RCSID("$OpenBSD: readpass.c,v 1.22 2001/07/14 15:10:16 stevesk Exp $");

#include <readpassphrase.h>
d38 1
d42 1
d45 2
a46 2
static char *
ssh_askpass(char *askpass, const char *msg)
d58 4
a61 8
	if (pipe(p) < 0) {
		error("ssh_askpass: pipe: %s", strerror(errno));
		return xstrdup("");
	}
	if ((pid = fork()) < 0) {
		error("ssh_askpass: fork: %s", strerror(errno));
		return xstrdup("");
	}
d87 6
d94 3
a96 4
 * Reads a passphrase from /dev/tty with echo turned off/on.  Returns the
 * passphrase (allocated with xmalloc).  Exits if EOF is encountered. If
 * RP_ALLOW_STDIN is set, the passphrase will be read from stdin if no
 * tty is available
d99 1
a99 1
read_passphrase(const char *prompt, int flags)
d101 2
a102 2
	char *askpass = NULL, *ret, buf[1024];
	int rppflags, use_askpass = 0, ttyfd;
d104 1
a104 2
	rppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;
	if (flags & RP_ALLOW_STDIN) {
a107 1
		rppflags |= RPP_REQUIRE_TTY;
d123 1
a123 6
	if (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL)
		return xstrdup("");

	ret = xstrdup(buf);
	memset(buf, 'x', sizeof buf);
	return ret;
@


1.15.2.2
log
@Merge OpenSSH 3.0.1.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.15.2.1 2001/09/27 19:03:55 jason Exp $");
d50 1
a50 1
	char *pass;
d76 1
a76 1
	len = read(p[0], buf, sizeof buf -1);
d83 3
a85 2
	buf[len] = '\0';
	buf[strcspn(buf, "\r\n")] = '\0';
@


1.15.2.3
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d2 2
a3 1
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
d13 7
d21 11
a31 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.26 2002/02/13 00:39:15 markus Exp $");
d51 1
a51 1
	int p[2], status, ret;
d76 1
a76 12

	len = ret = 0;
	do {
		ret = read(p[0], buf + len, sizeof(buf) - 1 - len);
		if (ret == -1 && errno == EINTR)
			continue;
		if (ret <= 0)
			break;
		len += ret;
	} while (sizeof(buf) - 1 - len > 0);
	buf[len] = '\0';

d81 3
a83 1

d108 1
a108 1
		ttyfd = open(_PATH_TTY, O_RDWR);
@


1.15.2.4
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: readpass.c,v 1.27 2002/03/26 15:58:46 markus Exp $");
d123 1
a123 3
	if (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {
		if (flags & RP_ALLOW_EOF)
			return NULL;
a124 1
	}
@


1.14
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.13 2001/01/21 19:05:54 markus Exp $");
d40 47
d101 22
@


1.13
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.12 2000/10/11 20:14:39 markus Exp $");
d39 1
@


1.12
log
@add support for s/key (kbd-interactive) to ssh2, based on work by mkiernan@@avantgo.com and me
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.11 2000/06/20 01:39:44 markus Exp $");
a37 1
#include "ssh.h"
@


1.12.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.14 2001/02/08 19:30:52 itojun Exp $");
d38 1
a39 1
#include "readpass.h"
@


1.12.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.12.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@@


1.12.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.15 2001/04/18 21:57:41 markus Exp $");
a39 47
#include "pathnames.h"
#include "log.h"
#include "atomicio.h"
#include "ssh.h"

char *
ssh_askpass(char *askpass, char *msg)
{
	pid_t pid;
	size_t len;
	char *nl, *pass;
	int p[2], status;
	char buf[1024];

	if (fflush(stdout) != 0)
		error("ssh_askpass: fflush: %s", strerror(errno));
	if (askpass == NULL)
		fatal("internal error: askpass undefined");
	if (pipe(p) < 0)
		fatal("ssh_askpass: pipe: %s", strerror(errno));
	if ((pid = fork()) < 0)
		fatal("ssh_askpass: fork: %s", strerror(errno));
	if (pid == 0) {
		seteuid(getuid());
		setuid(getuid());
		close(p[0]);
		if (dup2(p[1], STDOUT_FILENO) < 0)
			fatal("ssh_askpass: dup2: %s", strerror(errno));
		execlp(askpass, askpass, msg, (char *) 0);
		fatal("ssh_askpass: exec(%s): %s", askpass, strerror(errno));
	}
	close(p[1]);
	len = read(p[0], buf, sizeof buf);
	close(p[0]);
	while (waitpid(pid, &status, 0) < 0)
		if (errno != EINTR)
			break;
	if (len <= 1)
		return xstrdup("");
	nl = strchr(buf, '\n');
	if (nl)
		*nl = '\0';
	pass = xstrdup(buf);
	memset(buf, 0, sizeof(buf));
	return pass;
}

a53 22
	char *askpass = NULL;
	int use_askpass = 0, ttyfd;

	if (from_stdin) {
		if (!isatty(STDIN_FILENO))
			use_askpass = 1;
	} else {
		ttyfd = open("/dev/tty", O_RDWR);
		if (ttyfd >= 0)
			close(ttyfd);
		else
			use_askpass = 1;
	}

	if (use_askpass && getenv("DISPLAY")) {
		if (getenv(SSH_ASKPASS_ENV))
			askpass = getenv(SSH_ASKPASS_ENV);
		else
			askpass = _PATH_SSH_ASKPASS_DEFAULT;
		return ssh_askpass(askpass, prompt);
	}

@


1.12.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d35 1
a35 3
RCSID("$OpenBSD: readpass.c,v 1.22 2001/07/14 15:10:16 stevesk Exp $");

#include <readpassphrase.h>
d38 1
d42 1
d45 2
a46 2
static char *
ssh_askpass(char *askpass, const char *msg)
d58 4
a61 8
	if (pipe(p) < 0) {
		error("ssh_askpass: pipe: %s", strerror(errno));
		return xstrdup("");
	}
	if ((pid = fork()) < 0) {
		error("ssh_askpass: fork: %s", strerror(errno));
		return xstrdup("");
	}
d87 6
d94 3
a96 4
 * Reads a passphrase from /dev/tty with echo turned off/on.  Returns the
 * passphrase (allocated with xmalloc).  Exits if EOF is encountered. If
 * RP_ALLOW_STDIN is set, the passphrase will be read from stdin if no
 * tty is available
d99 1
a99 1
read_passphrase(const char *prompt, int flags)
d101 2
a102 2
	char *askpass = NULL, *ret, buf[1024];
	int rppflags, use_askpass = 0, ttyfd;
d104 1
a104 2
	rppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;
	if (flags & RP_ALLOW_STDIN) {
a107 1
		rppflags |= RPP_REQUIRE_TTY;
d123 1
a123 6
	if (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL)
		return xstrdup("");

	ret = xstrdup(buf);
	memset(buf, 'x', sizeof buf);
	return ret;
@


1.12.2.6
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.12.2.5 2001/09/27 00:15:42 miod Exp $");
d50 1
a50 1
	char *pass;
d76 1
a76 1
	len = read(p[0], buf, sizeof buf -1);
d83 3
a85 2
	buf[len] = '\0';
	buf[strcspn(buf, "\r\n")] = '\0';
@


1.12.2.7
log
@Merge OpenSSH 3.1.
@
text
@d2 2
a3 1
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
d13 7
d21 11
a31 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.26 2002/02/13 00:39:15 markus Exp $");
d51 1
a51 1
	int p[2], status, ret;
d76 1
a76 12

	len = ret = 0;
	do {
		ret = read(p[0], buf + len, sizeof(buf) - 1 - len);
		if (ret == -1 && errno == EINTR)
			continue;
		if (ret <= 0)
			break;
		len += ret;
	} while (sizeof(buf) - 1 - len > 0);
	buf[len] = '\0';

d81 3
a83 1

d108 1
a108 1
		ttyfd = open(_PATH_TTY, O_RDWR);
@


1.11
log
@OpenBSD tag
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.10 2000/04/14 10:30:32 markus Exp $");
d39 1
a39 8

volatile int intr;

void
intcatch()
{
	intr = 1;
}
d46 5
d52 1
a52 1
read_passphrase(const char *prompt, int from_stdin)
d54 1
a54 63
	char buf[1024], *p, ch;
	struct termios tio, saved_tio;
	sigset_t oset, nset;
	struct sigaction sa, osa;
	int input, output, echo = 0;

	if (from_stdin) {
		input = STDIN_FILENO;
		output = STDERR_FILENO;
	} else
		input = output = open("/dev/tty", O_RDWR);

	if (input == -1)
		fatal("You have no controlling tty.  Cannot read passphrase.\n");

	/* block signals, get terminal modes and turn off echo */
	sigemptyset(&nset);
	sigaddset(&nset, SIGTSTP);
	(void) sigprocmask(SIG_BLOCK, &nset, &oset);
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = intcatch;
	(void) sigaction(SIGINT, &sa, &osa);

	intr = 0;

	if (tcgetattr(input, &saved_tio) == 0 && (saved_tio.c_lflag & ECHO)) {
		echo = 1;
		tio = saved_tio;
		tio.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);
		(void) tcsetattr(input, TCSANOW, &tio);
	}

	fflush(stdout);

	(void)write(output, prompt, strlen(prompt));
	for (p = buf; read(input, &ch, 1) == 1 && ch != '\n';) {
		if (intr)
			break;
		if (p < buf + sizeof(buf) - 1)
			*p++ = ch;
	}
	*p = '\0';
	if (!intr)
		(void)write(output, "\n", 1);

	/* restore terminal modes and allow signals */
	if (echo)
		tcsetattr(input, TCSANOW, &saved_tio);
	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
	(void) sigaction(SIGINT, &osa, NULL);

	if (intr) {
		kill(getpid(), SIGINT);
		sigemptyset(&nset);
		/* XXX tty has not neccessarily drained by now? */
		sigsuspend(&nset);
	}

	if (!from_stdin)
		(void)close(input);
	p = xstrdup(buf);
	memset(buf, 0, sizeof(buf));
	return (p);
@


1.10
log
@whitespace cleanup
@
text
@d35 1
a35 1
RCSID("$Id: readpass.c,v 1.9 2000/01/21 21:16:00 deraadt Exp $");
@


1.10.2.1
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.11 2000/06/20 01:39:44 markus Exp $");
@


1.10.2.2
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.12 2000/10/11 20:14:39 markus Exp $");
d39 8
a46 1
#include "cli.h"
a52 5
/*
 * Note:  the funcationallity of this routing has been moved to
 * cli_read_passphrase().  This routing remains to maintain
 * compatibility with existing code.
 */
d54 1
a54 1
read_passphrase(char *prompt, int from_stdin)
d56 63
a118 1
	return cli_read_passphrase(prompt, from_stdin, 0);
@


1.10.2.3
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d35 1
a35 1
RCSID("$OpenBSD: readpass.c,v 1.14 2001/02/08 19:30:52 itojun Exp $");
d38 1
a39 1
#include "readpass.h"
@


1.10.2.4
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@@


1.9
log
@instead of blocking SIGINT, catch it ourselves, so that we can clean the
tty modes up and kill ourselves -- instead of our process group leader (scp,
cvs, ...) going away and leaving us in noecho mode.  people with cbreak
shells never even noticed..
@
text
@d35 1
a35 1
RCSID("$Id: readpass.c,v 1.8 1999/12/08 19:32:55 deraadt Exp $");
d61 1
a61 1
  
@


1.8
log
@avoid stdio; based on work by markus, millert, and I
@
text
@d35 1
a35 1
RCSID("$Id: readpass.c,v 1.5 1999/11/23 22:25:54 markus Exp $");
d40 8
d59 1
a72 1
	sigaddset(&nset, SIGINT);
d75 5
d81 1
a81 1
	if (tcgetattr(input, &tio) == 0 && (tio.c_lflag & ECHO)) {
d83 1
a83 1
		saved_tio = tio;
d91 3
a93 1
	for (p = buf; read(input, &ch, 1) == 1 && ch != '\n';)
d96 1
d98 2
a99 1
	(void)write(output, "\n", 1);
d105 8
@


1.7
log
@KNF, final part 3
@
text
@d2 30
a31 12
 * 
 * readpass.c
 * 
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * 
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * 
 * Created: Mon Jul 10 22:08:59 1995 ylo
 * 
 * Functions for reading passphrases and passwords.
 * 
d35 1
a35 1
RCSID("$Id: readpass.c,v 1.6 1999/11/24 00:26:03 deraadt Exp $");
a39 19
/* Saved old terminal mode for read_passphrase. */
static struct termios saved_tio;

/* Old interrupt signal handler for read_passphrase. */
static void (*old_handler) (int sig) = NULL;

/* Interrupt signal handler for read_passphrase. */

void 
intr_handler(int sig)
{
	/* Restore terminal modes. */
	tcsetattr(fileno(stdin), TCSANOW, &saved_tio);
	/* Restore the old signal handler. */
	signal(sig, old_handler);
	/* Resend the signal, with the old handler. */
	kill(getpid(), sig);
}

d42 2
a43 3
 * passphrase (allocated with xmalloc).  Exits if EOF is encountered. The
 * passphrase if read from stdin if from_stdin is true (as is the case with
 * ssh-keygen).
a44 1

d48 25
a72 17
	char buf[1024], *cp;
	struct termios tio;
	FILE *f;

	if (from_stdin)
		f = stdin;
	else {
		/*
		 * Read the passphrase from /dev/tty to make it possible to
		 * ask it even when stdin has been redirected.
		 */
		f = fopen("/dev/tty", "r");
		if (!f) {
			/* No controlling terminal and no DISPLAY.  Nowhere to read. */
			fprintf(stderr, "You have no controlling tty and no DISPLAY.  Cannot read passphrase.\n");
			exit(1);
		}
a74 1
	/* Display the prompt (on stderr because stdout might be redirected). */
a75 2
	fprintf(stderr, "%s", prompt);
	fflush(stderr);
d77 15
a91 37
	/* Get terminal modes. */
	tcgetattr(fileno(f), &tio);
	saved_tio = tio;
	/* Save signal handler and set the new handler. */
	old_handler = signal(SIGINT, intr_handler);

	/* Set new terminal modes disabling all echo. */
	tio.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);
	tcsetattr(fileno(f), TCSANOW, &tio);

	/* Read the passphrase from the terminal. */
	if (fgets(buf, sizeof(buf), f) == NULL) {
		/* Got EOF.  Just exit. */
		/* Restore terminal modes. */
		tcsetattr(fileno(f), TCSANOW, &saved_tio);
		/* Restore the signal handler. */
		signal(SIGINT, old_handler);
		/* Print a newline (the prompt probably didn\'t have one). */
		fprintf(stderr, "\n");
		/* Close the file. */
		if (f != stdin)
			fclose(f);
		exit(1);
	}
	/* Restore terminal modes. */
	tcsetattr(fileno(f), TCSANOW, &saved_tio);
	/* Restore the signal handler. */
	(void) signal(SIGINT, old_handler);
	/* Remove newline from the passphrase. */
	if (strchr(buf, '\n'))
		*strchr(buf, '\n') = 0;
	/* Allocate a copy of the passphrase. */
	cp = xstrdup(buf);
	/*
	 * Clear the buffer so we don\'t leave copies of the passphrase
	 * laying around.
	 */
d93 1
a93 6
	/* Print a newline since the prompt probably didn\'t have one. */
	fprintf(stderr, "\n");
	/* Close the file. */
	if (f != stdin)
		fclose(f);
	return cp;
@


1.6
log
@much more KNF
@
text
@d17 1
a17 1
RCSID("$Id: readpass.c,v 1.5 1999/11/23 22:25:54 markus Exp $");
d41 6
a46 4
/* Reads a passphrase from /dev/tty with echo turned off.  Returns the
   passphrase (allocated with xmalloc).  Exits if EOF is encountered.
   The passphrase if read from stdin if from_stdin is true (as is the
   case with ssh-keygen).  */
d58 4
a61 2
		/* Read the passphrase from /dev/tty to make it possible
		   to ask it even when stdin has been redirected. */
d108 4
a111 2
	/* Clear the buffer so we don\'t leave copies of the passphrase
	   laying around. */
@


1.5
log
@KNF part 1
@
text
@d2 13
a14 13

readpass.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Mon Jul 10 22:08:59 1995 ylo

Functions for reading passphrases and passwords.

*/
d17 1
a17 1
RCSID("$Id: readpass.c,v 1.4 1999/10/11 20:24:54 markus Exp $");
@


1.4
log
@we do not ship ssh-askpass
@
text
@d17 1
a17 1
RCSID("$Id: readpass.c,v 1.3 1999/09/30 08:34:25 deraadt Exp $");
d26 1
a26 1
static void (*old_handler)(int sig) = NULL;
d30 2
a31 1
void intr_handler(int sig)
d33 6
a38 6
  /* Restore terminal modes. */
  tcsetattr(fileno(stdin), TCSANOW, &saved_tio);
  /* Restore the old signal handler. */
  signal(sig, old_handler);
  /* Resend the signal, with the old handler. */
  kill(getpid(), sig);
d41 2
a42 2
/* Reads a passphrase from /dev/tty with echo turned off.  Returns the 
   passphrase (allocated with xmalloc).  Exits if EOF is encountered. 
d46 2
a47 1
char *read_passphrase(const char *prompt, int from_stdin)
d49 15
a63 16
  char buf[1024], *cp;
  struct termios tio;
  FILE *f;
  
  if (from_stdin)
    f = stdin;
  else
    {
      /* Read the passphrase from /dev/tty to make it possible to ask it even 
	 when stdin has been redirected. */
      f = fopen("/dev/tty", "r");
      if (!f)
	{
	  /* No controlling terminal and no DISPLAY.  Nowhere to read. */
	  fprintf(stderr, "You have no controlling tty and no DISPLAY.  Cannot read passphrase.\n");
	  exit(1);
a64 1
    }
d66 47
a112 48
  /* Display the prompt (on stderr because stdout might be redirected). */
  fflush(stdout);
  fprintf(stderr, "%s", prompt);
  fflush(stderr);

  /* Get terminal modes. */
  tcgetattr(fileno(f), &tio);
  saved_tio = tio;
  /* Save signal handler and set the new handler. */
  old_handler = signal(SIGINT, intr_handler);

  /* Set new terminal modes disabling all echo. */
  tio.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);
  tcsetattr(fileno(f), TCSANOW, &tio);

  /* Read the passphrase from the terminal. */
  if (fgets(buf, sizeof(buf), f) == NULL)
    {
      /* Got EOF.  Just exit. */
      /* Restore terminal modes. */
      tcsetattr(fileno(f), TCSANOW, &saved_tio);
      /* Restore the signal handler. */
      signal(SIGINT, old_handler);
      /* Print a newline (the prompt probably didn\'t have one). */
      fprintf(stderr, "\n");
      /* Close the file. */
      if (f != stdin)
	fclose(f);
      exit(1);
    }
  /* Restore terminal modes. */
  tcsetattr(fileno(f), TCSANOW, &saved_tio);
  /* Restore the signal handler. */
  (void)signal(SIGINT, old_handler);
  /* Remove newline from the passphrase. */
  if (strchr(buf, '\n'))
    *strchr(buf, '\n') = 0;
  /* Allocate a copy of the passphrase. */
  cp = xstrdup(buf);
  /* Clear the buffer so we don\'t leave copies of the passphrase laying
     around. */
  memset(buf, 0, sizeof(buf));
  /* Print a newline since the prompt probably didn\'t have one. */
  fprintf(stderr, "\n");
  /* Close the file. */
  if (f != stdin)
    fclose(f);
  return cp;
@


1.3
log
@even smaller
@
text
@d17 1
a17 1
RCSID("$Id: readpass.c,v 1.2 1999/09/30 05:03:05 deraadt Exp $");
a59 21
	  if (getenv("DISPLAY"))
	    {
	      char command[512];
	      fprintf(stderr,
		      "Executing ssh-askpass to query the password...\n");
	      fflush(stdout);
	      fflush(stderr);
	      sprintf(command, "ssh-askpass '%.400s'", prompt);
	      f = popen(command, "r");
	      if (!fgets(buf, sizeof(buf), f))
		{
		  pclose(f);
		  fprintf(stderr, "No passphrase supplied.  Exiting.\n");
		  exit(1);
		}
	      pclose(f);
	      if (strchr(buf, '\n'))
		*strchr(buf, '\n') = 0;
	      return xstrdup(buf);
	    }

@


1.2
log
@cull more ancient garbage from pre-POSIX days
@
text
@d17 1
a17 1
RCSID("$Id: readpass.c,v 1.1 1999/09/26 20:53:37 deraadt Exp $");
d26 1
a26 1
static RETSIGTYPE (*old_handler)(int sig) = NULL;
d30 1
a30 1
RETSIGTYPE intr_handler(int sig)
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d17 1
a17 1
RCSID("$Id: readpass.c,v 1.2 1999/05/04 11:59:03 bg Exp $");
a22 1
#ifdef USING_TERMIOS
a23 4
#endif
#ifdef USING_SGTTY
static struct sgttyb saved_tio;
#endif
a32 1
#ifdef USING_TERMIOS
a33 4
#endif
#ifdef USING_SGTTY
  ioctl(fileno(stdin), TIOCSETP, &saved_tio);
#endif
a47 1
#ifdef USING_TERMIOS
a48 4
#endif
#ifdef USING_SGTTY
  struct sgttyb tio;
#endif
a92 1
#ifdef USING_TERMIOS
a93 4
#endif
#ifdef USING_SGTTY
  ioctl(fileno(f), TIOCGETP, &tio);
#endif
a98 1
#ifdef USING_TERMIOS
a100 5
#endif
#ifdef USING_SGTTY
  tio.sg_flags &= ~(ECHO);
  ioctl(fileno(f), TIOCSETP, &tio);
#endif
a106 1
#ifdef USING_TERMIOS
a107 4
#endif
#ifdef USING_SGTTY
      ioctl(fileno(f), TIOCSETP, &saved_tio);
#endif
a117 1
#ifdef USING_TERMIOS
a118 4
#endif
#ifdef USING_SGTTY
  ioctl(fileno(f), TIOCSETP, &saved_tio);
#endif
@

