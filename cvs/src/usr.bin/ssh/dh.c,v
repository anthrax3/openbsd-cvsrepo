head	1.62;
access;
symbols
	OPENBSD_6_1:1.62.0.4
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.60.0.4
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.57.0.4
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.57.0.2
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.53.0.6
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.49.0.6
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.4
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.2
	OPENBSD_5_0:1.48.0.8
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.6
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.4
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.47.0.8
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.4
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.44.0.4
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.42.0.4
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.31.0.8
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.6
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.31.0.4
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.62
date	2016.12.15.21.20.41;	author dtucker;	state Exp;
branches;
next	1.61;
commitid	ODCNzpRRWKbQpWyU;

1.61
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	ZllbGwdb0fOmLhjK;

1.60
date	2016.05.02.10.26.04;	author djm;	state Exp;
branches;
next	1.59;
commitid	rVUG0L3JBpFl5b0k;

1.59
date	2016.03.31.05.24.06;	author dtucker;	state Exp;
branches;
next	1.58;
commitid	qJf4qIUNTgGU7pVY;

1.58
date	2016.02.28.22.27.00;	author djm;	state Exp;
branches;
next	1.57;
commitid	WUBYcb6IpAMjSucN;

1.57
date	2015.05.27.23.39.18;	author dtucker;	state Exp;
branches;
next	1.56;
commitid	eEfyWHLDvL3lFUIb;

1.56
date	2015.03.26.06.59.28;	author djm;	state Exp;
branches;
next	1.55;
commitid	vHPKo4NMAPTTGI23;

1.55
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	cBx23BaCk6gYBpRj;

1.54
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.53;
commitid	U9l75XYAjMKaQ8Jp;

1.53
date	2013.11.21.00.45.44;	author djm;	state Exp;
branches;
next	1.52;

1.52
date	2013.10.08.11.42.13;	author dtucker;	state Exp;
branches;
next	1.51;

1.51
date	2013.07.02.12.31.43;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.21.05.42.32;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2011.12.07.05.44.38;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.01.11.37.33;	author grunk;	state Exp;
branches;
next	1.47;

1.47
date	2008.06.26.09.19.39;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.27.00.15.57;	author ray;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.07.13.02.07;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.18.22.27.55;	author stevesk;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.04.14.55.23;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.27.13.03.54;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.25.13.17.01;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.19.02.24.05;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2004.08.04.10.37.52;	author djm;	state Exp;
branches
	1.31.6.1
	1.31.8.1;
next	1.30;

1.30
date	2004.06.13.12.53.24;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.27.22.49.27;	author dtucker;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2004.02.27.22.44.56;	author dtucker;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.27.22.42.47;	author dtucker;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.16.15.51.54;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.18.13.02.21;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.08.20.21.28;	author itojun;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.11.21.22.22.50;	author markus;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.06.27.08.49.44;	author markus;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2002.03.06.00.23.27;	author markus;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2002.03.06.00.20.54;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.27.19.37.22;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.15.12.18;	author itojun;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.06.22.21.57.59;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.22.21.27.07;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.15.08.43.45;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.04.04.23.09.17;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.03.19.53.29;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.29.21.17.39;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.28.22.04.57;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.27.17.46.49;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.05.17.58.22;	author stevesk;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.21.19.05.49;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.15.21.43.51;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.16.17.55.43;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.11.20.11.35;	author markus;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2000.10.11.04.02.16;	author provos;	state Exp;
branches;
next	;

1.2.2.1
date	2001.02.16.20.13.01;	author jason;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.02.19.17.18.53;	author jason;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.03.21.19.46.24;	author jason;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.05.07.21.09.29;	author jason;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.2.4.1
date	2000.11.08.21.30.43;	author jason;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.03.12.15.44.10;	author jason;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.03.21.18.52.44;	author jason;	state Exp;
branches;
next	;

1.14.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	;

1.17.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.11.14.53.06;	author miod;	state Exp;
branches;
next	;

1.21.2.1
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.22.2.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2003.09.16.21.20.25;	author brad;	state Exp;
branches;
next	;

1.23.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2004.03.04.18.18.15;	author brad;	state Exp;
branches;
next	;

1.24.2.1
date	2004.02.28.03.51.33;	author brad;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2004.08.19.22.37.31;	author brad;	state Exp;
branches;
next	;

1.29.2.1
date	2004.08.19.04.13.26;	author brad;	state Exp;
branches;
next	;

1.31.6.1
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.31.8.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Fix text in error message.  Patch from zev at bewilderbeest.net.
@
text
@/* $OpenBSD: dh.c,v 1.61 2016/09/12 01:22:38 deraadt Exp $ */
/*
 * Copyright (c) 2000 Niels Provos.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <openssl/bn.h>
#include <openssl/dh.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "dh.h"
#include "pathnames.h"
#include "log.h"
#include "misc.h"
#include "ssherr.h"

static int
parse_prime(int linenum, char *line, struct dhgroup *dhg)
{
	char *cp, *arg;
	char *strsize, *gen, *prime;
	const char *errstr = NULL;
	long long n;

	dhg->p = dhg->g = NULL;
	cp = line;
	if ((arg = strdelim(&cp)) == NULL)
		return 0;
	/* Ignore leading whitespace */
	if (*arg == '\0')
		arg = strdelim(&cp);
	if (!arg || !*arg || *arg == '#')
		return 0;

	/* time */
	if (cp == NULL || *arg == '\0')
		goto truncated;
	arg = strsep(&cp, " "); /* type */
	if (cp == NULL || *arg == '\0')
		goto truncated;
	/* Ensure this is a safe prime */
	n = strtonum(arg, 0, 5, &errstr);
	if (errstr != NULL || n != MODULI_TYPE_SAFE) {
		error("moduli:%d: type is not %d", linenum, MODULI_TYPE_SAFE);
		goto fail;
	}
	arg = strsep(&cp, " "); /* tests */
	if (cp == NULL || *arg == '\0')
		goto truncated;
	/* Ensure prime has been tested and is not composite */
	n = strtonum(arg, 0, 0x1f, &errstr);
	if (errstr != NULL ||
	    (n & MODULI_TESTS_COMPOSITE) || !(n & ~MODULI_TESTS_COMPOSITE)) {
		error("moduli:%d: invalid moduli tests flag", linenum);
		goto fail;
	}
	arg = strsep(&cp, " "); /* tries */
	if (cp == NULL || *arg == '\0')
		goto truncated;
	n = strtonum(arg, 0, 1<<30, &errstr);
	if (errstr != NULL || n == 0) {
		error("moduli:%d: invalid primality trial count", linenum);
		goto fail;
	}
	strsize = strsep(&cp, " "); /* size */
	if (cp == NULL || *strsize == '\0' ||
	    (dhg->size = (int)strtonum(strsize, 0, 64*1024, &errstr)) == 0 ||
	    errstr) {
		error("moduli:%d: invalid prime length", linenum);
		goto fail;
	}
	/* The whole group is one bit larger */
	dhg->size++;
	gen = strsep(&cp, " "); /* gen */
	if (cp == NULL || *gen == '\0')
		goto truncated;
	prime = strsep(&cp, " "); /* prime */
	if (cp != NULL || *prime == '\0') {
 truncated:
		error("moduli:%d: truncated", linenum);
		goto fail;
	}

	if ((dhg->g = BN_new()) == NULL ||
	    (dhg->p = BN_new()) == NULL) {
		error("parse_prime: BN_new failed");
		goto fail;
	}
	if (BN_hex2bn(&dhg->g, gen) == 0) {
		error("moduli:%d: could not parse generator value", linenum);
		goto fail;
	}
	if (BN_hex2bn(&dhg->p, prime) == 0) {
		error("moduli:%d: could not parse prime value", linenum);
		goto fail;
	}
	if (BN_num_bits(dhg->p) != dhg->size) {
		error("moduli:%d: prime has wrong size: actual %d listed %d",
		    linenum, BN_num_bits(dhg->p), dhg->size - 1);
		goto fail;
	}
	if (BN_cmp(dhg->g, BN_value_one()) <= 0) {
		error("moduli:%d: generator is invalid", linenum);
		goto fail;
	}
	return 1;

 fail:
	if (dhg->g != NULL)
		BN_clear_free(dhg->g);
	if (dhg->p != NULL)
		BN_clear_free(dhg->p);
	dhg->g = dhg->p = NULL;
	return 0;
}

DH *
choose_dh(int min, int wantbits, int max)
{
	FILE *f;
	char line[4096];
	int best, bestcount, which;
	int linenum;
	struct dhgroup dhg;

	if ((f = fopen(_PATH_DH_MODULI, "r")) == NULL) {
		logit("WARNING: could not open %s (%s), using fixed modulus",
		    _PATH_DH_MODULI, strerror(errno));
		return (dh_new_group_fallback(max));
	}

	linenum = 0;
	best = bestcount = 0;
	while (fgets(line, sizeof(line), f)) {
		linenum++;
		if (!parse_prime(linenum, line, &dhg))
			continue;
		BN_clear_free(dhg.g);
		BN_clear_free(dhg.p);

		if (dhg.size > max || dhg.size < min)
			continue;

		if ((dhg.size > wantbits && dhg.size < best) ||
		    (dhg.size > best && best < wantbits)) {
			best = dhg.size;
			bestcount = 0;
		}
		if (dhg.size == best)
			bestcount++;
	}
	rewind(f);

	if (bestcount == 0) {
		fclose(f);
		logit("WARNING: no suitable primes in %s", _PATH_DH_MODULI);
		return (dh_new_group_fallback(max));
	}

	linenum = 0;
	which = arc4random_uniform(bestcount);
	while (fgets(line, sizeof(line), f)) {
		if (!parse_prime(linenum, line, &dhg))
			continue;
		if ((dhg.size > max || dhg.size < min) ||
		    dhg.size != best ||
		    linenum++ != which) {
			BN_clear_free(dhg.g);
			BN_clear_free(dhg.p);
			continue;
		}
		break;
	}
	fclose(f);
	if (linenum != which+1) {
		logit("WARNING: line %d disappeared in %s, giving up",
		    which, _PATH_DH_MODULI);
		return (dh_new_group_fallback(max));
	}

	return (dh_new_group(dhg.g, dhg.p));
}

/* diffie-hellman-groupN-sha1 */

int
dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
{
	int i;
	int n = BN_num_bits(dh_pub);
	int bits_set = 0;
	BIGNUM *tmp;

	if (dh_pub->neg) {
		logit("invalid public DH value: negative");
		return 0;
	}
	if (BN_cmp(dh_pub, BN_value_one()) != 1) {	/* pub_exp <= 1 */
		logit("invalid public DH value: <= 1");
		return 0;
	}

	if ((tmp = BN_new()) == NULL) {
		error("%s: BN_new failed", __func__);
		return 0;
	}
	if (!BN_sub(tmp, dh->p, BN_value_one()) ||
	    BN_cmp(dh_pub, tmp) != -1) {		/* pub_exp > p-2 */
		BN_clear_free(tmp);
		logit("invalid public DH value: >= p-1");
		return 0;
	}
	BN_clear_free(tmp);

	for (i = 0; i <= n; i++)
		if (BN_is_bit_set(dh_pub, i))
			bits_set++;
	debug2("bits set: %d/%d", bits_set, BN_num_bits(dh->p));

	/*
	 * if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial
	 */
	if (bits_set < 4) {
		logit("invalid public DH value (%d/%d)",
		   bits_set, BN_num_bits(dh->p));
		return 0;
	}
	return 1;
}

int
dh_gen_key(DH *dh, int need)
{
	int pbits;

	if (need < 0 || dh->p == NULL ||
	    (pbits = BN_num_bits(dh->p)) <= 0 ||
	    need > INT_MAX / 2 || 2 * need > pbits)
		return SSH_ERR_INVALID_ARGUMENT;
	if (need < 256)
		need = 256;
	/*
	 * Pollard Rho, Big step/Little Step attacks are O(sqrt(n)),
	 * so double requested need here.
	 */
	dh->length = MINIMUM(need * 2, pbits - 1);
	if (DH_generate_key(dh) == 0 ||
	    !dh_pub_is_valid(dh, dh->pub_key)) {
		BN_clear_free(dh->priv_key);
		return SSH_ERR_LIBCRYPTO_ERROR;
	}
	return 0;
}

DH *
dh_new_group_asc(const char *gen, const char *modulus)
{
	DH *dh;

	if ((dh = DH_new()) == NULL)
		return NULL;
	if (BN_hex2bn(&dh->p, modulus) == 0 ||
	    BN_hex2bn(&dh->g, gen) == 0) {
		DH_free(dh);
		return NULL;
	}
	return (dh);
}

/*
 * This just returns the group, we still need to generate the exchange
 * value.
 */

DH *
dh_new_group(BIGNUM *gen, BIGNUM *modulus)
{
	DH *dh;

	if ((dh = DH_new()) == NULL)
		return NULL;
	dh->p = modulus;
	dh->g = gen;

	return (dh);
}

/* rfc2409 "Second Oakley Group" (1024 bits) */
DH *
dh_new_group1(void)
{
	static char *gen = "2", *group1 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE65381"
	    "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group1));
}

/* rfc3526 group 14 "2048-bit MODP Group" */
DH *
dh_new_group14(void)
{
	static char *gen = "2", *group14 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE45B3D"
	    "C2007CB8" "A163BF05" "98DA4836" "1C55D39A" "69163FA8" "FD24CF5F"
	    "83655D23" "DCA3AD96" "1C62F356" "208552BB" "9ED52907" "7096966D"
	    "670C354E" "4ABC9804" "F1746C08" "CA18217C" "32905E46" "2E36CE3B"
	    "E39E772C" "180E8603" "9B2783A2" "EC07A28F" "B5C55DF0" "6F4C52C9"
	    "DE2BCBF6" "95581718" "3995497C" "EA956AE5" "15D22618" "98FA0510"
	    "15728E5A" "8AACAA68" "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group14));
}

/* rfc3526 group 16 "4096-bit MODP Group" */
DH *
dh_new_group16(void)
{
	static char *gen = "2", *group16 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE45B3D"
	    "C2007CB8" "A163BF05" "98DA4836" "1C55D39A" "69163FA8" "FD24CF5F"
	    "83655D23" "DCA3AD96" "1C62F356" "208552BB" "9ED52907" "7096966D"
	    "670C354E" "4ABC9804" "F1746C08" "CA18217C" "32905E46" "2E36CE3B"
	    "E39E772C" "180E8603" "9B2783A2" "EC07A28F" "B5C55DF0" "6F4C52C9"
	    "DE2BCBF6" "95581718" "3995497C" "EA956AE5" "15D22618" "98FA0510"
	    "15728E5A" "8AAAC42D" "AD33170D" "04507A33" "A85521AB" "DF1CBA64"
	    "ECFB8504" "58DBEF0A" "8AEA7157" "5D060C7D" "B3970F85" "A6E1E4C7"
	    "ABF5AE8C" "DB0933D7" "1E8C94E0" "4A25619D" "CEE3D226" "1AD2EE6B"
	    "F12FFA06" "D98A0864" "D8760273" "3EC86A64" "521F2B18" "177B200C"
	    "BBE11757" "7A615D6C" "770988C0" "BAD946E2" "08E24FA0" "74E5AB31"
	    "43DB5BFC" "E0FD108E" "4B82D120" "A9210801" "1A723C12" "A787E6D7"
	    "88719A10" "BDBA5B26" "99C32718" "6AF4E23C" "1A946834" "B6150BDA"
	    "2583E9CA" "2AD44CE8" "DBBBC2DB" "04DE8EF9" "2E8EFC14" "1FBECAA6"
	    "287C5947" "4E6BC05D" "99B2964F" "A090C3A2" "233BA186" "515BE7ED"
	    "1F612970" "CEE2D7AF" "B81BDD76" "2170481C" "D0069127" "D5B05AA9"
	    "93B4EA98" "8D8FDDC1" "86FFB7DC" "90A6C08F" "4DF435C9" "34063199"
	    "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group16));
}

/* rfc3526 group 18 "8192-bit MODP Group" */
DH *
dh_new_group18(void)
{
	static char *gen = "2", *group16 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE45B3D"
	    "C2007CB8" "A163BF05" "98DA4836" "1C55D39A" "69163FA8" "FD24CF5F"
	    "83655D23" "DCA3AD96" "1C62F356" "208552BB" "9ED52907" "7096966D"
	    "670C354E" "4ABC9804" "F1746C08" "CA18217C" "32905E46" "2E36CE3B"
	    "E39E772C" "180E8603" "9B2783A2" "EC07A28F" "B5C55DF0" "6F4C52C9"
	    "DE2BCBF6" "95581718" "3995497C" "EA956AE5" "15D22618" "98FA0510"
	    "15728E5A" "8AAAC42D" "AD33170D" "04507A33" "A85521AB" "DF1CBA64"
	    "ECFB8504" "58DBEF0A" "8AEA7157" "5D060C7D" "B3970F85" "A6E1E4C7"
	    "ABF5AE8C" "DB0933D7" "1E8C94E0" "4A25619D" "CEE3D226" "1AD2EE6B"
	    "F12FFA06" "D98A0864" "D8760273" "3EC86A64" "521F2B18" "177B200C"
	    "BBE11757" "7A615D6C" "770988C0" "BAD946E2" "08E24FA0" "74E5AB31"
	    "43DB5BFC" "E0FD108E" "4B82D120" "A9210801" "1A723C12" "A787E6D7"
	    "88719A10" "BDBA5B26" "99C32718" "6AF4E23C" "1A946834" "B6150BDA"
	    "2583E9CA" "2AD44CE8" "DBBBC2DB" "04DE8EF9" "2E8EFC14" "1FBECAA6"
	    "287C5947" "4E6BC05D" "99B2964F" "A090C3A2" "233BA186" "515BE7ED"
	    "1F612970" "CEE2D7AF" "B81BDD76" "2170481C" "D0069127" "D5B05AA9"
	    "93B4EA98" "8D8FDDC1" "86FFB7DC" "90A6C08F" "4DF435C9" "34028492"
	    "36C3FAB4" "D27C7026" "C1D4DCB2" "602646DE" "C9751E76" "3DBA37BD"
	    "F8FF9406" "AD9E530E" "E5DB382F" "413001AE" "B06A53ED" "9027D831"
	    "179727B0" "865A8918" "DA3EDBEB" "CF9B14ED" "44CE6CBA" "CED4BB1B"
	    "DB7F1447" "E6CC254B" "33205151" "2BD7AF42" "6FB8F401" "378CD2BF"
	    "5983CA01" "C64B92EC" "F032EA15" "D1721D03" "F482D7CE" "6E74FEF6"
	    "D55E702F" "46980C82" "B5A84031" "900B1C9E" "59E7C97F" "BEC7E8F3"
	    "23A97A7E" "36CC88BE" "0F1D45B7" "FF585AC5" "4BD407B2" "2B4154AA"
	    "CC8F6D7E" "BF48E1D8" "14CC5ED2" "0F8037E0" "A79715EE" "F29BE328"
	    "06A1D58B" "B7C5DA76" "F550AA3D" "8A1FBFF0" "EB19CCB1" "A313D55C"
	    "DA56C9EC" "2EF29632" "387FE8D7" "6E3C0468" "043E8F66" "3F4860EE"
	    "12BF2D5B" "0B7474D6" "E694F91E" "6DBE1159" "74A3926F" "12FEE5E4"
	    "38777CB6" "A932DF8C" "D8BEC4D0" "73B931BA" "3BC832B6" "8D9DD300"
	    "741FA7BF" "8AFC47ED" "2576F693" "6BA42466" "3AAB639C" "5AE4F568"
	    "3423B474" "2BF1C978" "238F16CB" "E39D652D" "E3FDB8BE" "FC848AD9"
	    "22222E04" "A4037C07" "13EB57A8" "1A23F0C7" "3473FC64" "6CEA306B"
	    "4BCBC886" "2F8385DD" "FA9D4B7F" "A2C087E8" "79683303" "ED5BDD3A"
	    "062B3CF5" "B3A278A6" "6D2A13F8" "3F44F82D" "DF310EE0" "74AB6A36"
	    "4597E899" "A0255DC1" "64F31CC5" "0846851D" "F9AB4819" "5DED7EA1"
	    "B1D510BD" "7EE74D73" "FAF36BC3" "1ECFA268" "359046F4" "EB879F92"
	    "4009438B" "481C6CD7" "889A002E" "D5EE382B" "C9190DA6" "FC026E47"
	    "9558E447" "5677E9AA" "9E3050E2" "765694DF" "C81F56E8" "80B96E71"
	    "60C980DD" "98EDD3DF" "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group16));
}

/* Select fallback group used by DH-GEX if moduli file cannot be read. */
DH *
dh_new_group_fallback(int max)
{
	debug3("%s: requested max size %d", __func__, max);
	if (max < 3072) {
		debug3("using 2k bit group 14");
		return dh_new_group14();
	} else if (max < 6144) {
		debug3("using 4k bit group 16");
		return dh_new_group16();
	}
	debug3("using 8k bit group 18");
	return dh_new_group18();
}

/*
 * Estimates the group order for a Diffie-Hellman group that has an
 * attack complexity approximately the same as O(2**bits).
 * Values from NIST Special Publication 800-57: Recommendation for Key
 * Management Part 1 (rev 3) limited by the recommended maximum value
 * from RFC4419 section 3.
 */
u_int
dh_estimate(int bits)
{
	if (bits <= 112)
		return 2048;
	if (bits <= 128)
		return 3072;
	if (bits <= 192)
		return 7680;
	return 8192;
}
@


1.61
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.60 2016/05/02 10:26:04 djm Exp $ */
d152 1
a152 1
		logit("WARNING: could open open %s (%s), using fixed modulus",
@


1.60
log
@add support for additional fixed DH groups from
draft-ietf-curdle-ssh-kex-sha2-03

diffie-hellman-group14-sha256 (2K group)
diffie-hellman-group16-sha512 (4K group)
diffie-hellman-group18-sha512 (8K group)

based on patch from Mark D. Baushke and Darren Tucker
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.59 2016/03/31 05:24:06 dtucker Exp $ */
a25 1
#include <sys/param.h>	/* MIN */
d271 1
a271 1
	dh->length = MIN(need * 2, pbits - 1);
@


1.59
log
@Remove fallback from moduli to "primes" file that was deprecated in 2001
and fix log messages referring to primes file.  Based on patch from
xnox at ubuntu.com via bz#2559.  "kill it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.58 2016/02/28 22:27:00 djm Exp $ */
d314 1
d329 1
d349 1
a349 4
/*
 * 4k bit fallback group used by DH-GEX if moduli file cannot be read.
 * Source: MODP group 16 from RFC3526.
 */
d351 1
a351 1
dh_new_group_fallback(int max)
d377 62
a438 2
	if (max < 4096) {
		debug3("requested max size %d, using 2k bit group 14", max);
d440 3
d444 2
a445 2
	debug3("using 4k bit group 16");
	return (dh_new_group_asc(gen, group16));
a454 1

@


1.58
log
@rearrange DH public value tests to be a little more clear

rearrange DH private value generation to explain rationale more
clearly and include an extra sanity check.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.57 2015/05/27 23:39:18 dtucker Exp $ */
d31 1
d152 3
a154 4
	if ((f = fopen(_PATH_DH_MODULI, "r")) == NULL &&
	    (f = fopen(_PATH_DH_PRIMES, "r")) == NULL) {
		logit("WARNING: %s does not exist, using fixed modulus",
		    _PATH_DH_MODULI);
d182 1
a182 1
		logit("WARNING: no suitable primes in %s", _PATH_DH_PRIMES);
d203 1
a203 1
		    which, _PATH_DH_PRIMES);
@


1.57
log
@Add a stronger (4k bit) fallback group that sshd can use when the moduli
file is missing or broken, sourced from RFC3526.  bz#2302, ok markus@@
(earlier version), djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.56 2015/03/26 06:59:28 djm Exp $ */
d246 9
a254 6
	/* if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial */
	if (bits_set > 1)
		return 1;

	logit("invalid public DH value (%d/%d)", bits_set, BN_num_bits(dh->p));
	return 0;
d266 6
@


1.56
log
@relax bits needed check to allow diffie-hellman-group1-sha1 key
exchange to complete for chacha20-poly1305 was selected as
symmetric cipher; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.55 2015/01/20 23:14:00 deraadt Exp $ */
d155 1
a155 1
		return (dh_new_group14());
d183 1
a183 1
		return (dh_new_group14());
d204 1
a204 1
		return (dh_new_group14());
d336 39
@


1.55
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.54 2015/01/19 20:16:15 markus Exp $ */
d261 1
a261 1
	    need > INT_MAX / 2 || 2 * need >= pbits)
@


1.54
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.53 2013/11/21 00:45:44 djm Exp $ */
d26 1
a26 1
#include <sys/param.h>
d34 1
@


1.53
log
@Add a new protocol 2 transport cipher "chacha20-poly1305@@openssh.com"
that combines Daniel Bernstein's ChaCha20 stream cipher and Poly1305 MAC
to build an authenticated encryption mode.

Inspired by and similar to Adam Langley's proposal for TLS:
http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03
but differs in layout used for the MAC calculation and the use of a
second ChaCha20 instance to separately encrypt packet lengths.
Details are in the PROTOCOL.chacha20poly1305 file.

Feedback markus@@, naddy@@; manpage bits Loganden Velvindron @@ AfriNIC
ok markus@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.52 2013/10/08 11:42:13 dtucker Exp $ */
d39 1
d108 5
a112 4
	if ((dhg->g = BN_new()) == NULL)
		fatal("parse_prime: BN_new failed");
	if ((dhg->p = BN_new()) == NULL)
		fatal("parse_prime: BN_new failed");
a129 1

a137 1
	error("Bad prime description in line %d", linenum);
d200 2
a201 2
	if (linenum != which+1)
		fatal("WARNING: line %d disappeared in %s, giving up",
d203 2
d253 1
a253 1
void
d258 4
a261 6
	if (need <= 0)
		fatal("%s: need <= 0", __func__);
	if (dh->p == NULL)
		fatal("%s: dh->p == NULL", __func__);
	if ((pbits = BN_num_bits(dh->p)) <= 0)
		fatal("%s: bits(p) <= 0", __func__);
d263 6
a268 4
	if (DH_generate_key(dh) == 0)
		fatal("%s: key generation failed", __func__);
	if (!dh_pub_is_valid(dh, dh->pub_key))
		fatal("%s: generated invalid key", __func__);
d277 6
a282 7
		fatal("dh_new_group_asc: DH_new");

	if (BN_hex2bn(&dh->p, modulus) == 0)
		fatal("BN_hex2bn p");
	if (BN_hex2bn(&dh->g, gen) == 0)
		fatal("BN_hex2bn g");

d297 1
a297 1
		fatal("dh_new_group: DH_new");
d345 1
a345 1
int
@


1.52
log
@Increase the size of the Diffie-Hellman groups requested for a each symmetric
key size.  New values from NIST Special Publication 800-57 with the upper
limit specified by RFC4419.  Pointed out by Peter Backes, ok djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.51 2013/07/02 12:31:43 markus Exp $ */
d254 1
a254 1
	int i, bits_set, tries = 0;
d256 2
a257 2
	if (need < 0)
		fatal("dh_gen_key: need < 0");
d259 8
a266 22
		fatal("dh_gen_key: dh->p == NULL");
	if (need > INT_MAX / 2 || 2 * need >= BN_num_bits(dh->p))
		fatal("dh_gen_key: group too small: %d (2*need %d)",
		    BN_num_bits(dh->p), 2*need);
	do {
		if (dh->priv_key != NULL)
			BN_clear_free(dh->priv_key);
		if ((dh->priv_key = BN_new()) == NULL)
			fatal("dh_gen_key: BN_new failed");
		/* generate a 2*need bits random private exponent */
		if (!BN_rand(dh->priv_key, 2*need, 0, 0))
			fatal("dh_gen_key: BN_rand failed");
		if (DH_generate_key(dh) == 0)
			fatal("DH_generate_key");
		for (i = 0, bits_set = 0; i <= BN_num_bits(dh->priv_key); i++)
			if (BN_is_bit_set(dh->priv_key, i))
				bits_set++;
		debug2("dh_gen_key: priv key bits set: %d/%d",
		    bits_set, BN_num_bits(dh->priv_key));
		if (tries++ > 10)
			fatal("dh_gen_key: too many bad keys: giving up");
	} while (!dh_pub_is_valid(dh, dh->pub_key));
@


1.51
log
@remove extra whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.50 2013/06/21 05:42:32 djm Exp $ */
d352 4
a355 2
 * attack complexity approximately the same as O(2**bits).  Estimate
 * with:  O(exp(1.9223 * (ln q)^(1/3) (ln ln q)^(2/3)))
d361 2
a362 1

d364 1
a364 1
		return (1024);	/* O(2**86) */
d366 2
a367 2
		return (2048);	/* O(2**116) */
	return (4096);		/* O(2**156) */
@


1.50
log
@sprinkle in some error() to explain moduli(5) parse failures
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.49 2011/12/07 05:44:38 djm Exp $ */
d48 1
a48 1
	dhg->p = dhg-> g = NULL;
@


1.49
log
@fix some harmless and/or unreachable int overflows;
reported Xi Wang, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.48 2009/10/01 11:37:33 grunk Exp $ */
d48 1
d60 1
a60 1
		goto fail;
d63 1
a63 1
		goto fail;
d66 2
a67 1
	if (errstr != NULL || n != MODULI_TYPE_SAFE)
d69 1
d72 1
a72 1
		goto fail;
d76 2
a77 1
	    (n & MODULI_TESTS_COMPOSITE) || !(n & ~MODULI_TESTS_COMPOSITE))
d79 1
d82 1
a82 1
		goto fail;
d84 2
a85 1
	if (errstr != NULL || n == 0)
d87 1
d91 2
a92 1
	    errstr)
d94 1
d99 1
a99 1
		goto fail;
d101 3
a103 1
	if (cp != NULL || *prime == '\0')
d105 1
d111 17
a127 11
	if (BN_hex2bn(&dhg->g, gen) == 0)
		goto failclean;

	if (BN_hex2bn(&dhg->p, prime) == 0)
		goto failclean;

	if (BN_num_bits(dhg->p) != dhg->size)
		goto failclean;

	if (BN_is_zero(dhg->g) || BN_is_one(dhg->g))
		goto failclean;
d129 1
a129 1
	return (1);
a130 3
 failclean:
	BN_clear_free(dhg->g);
	BN_clear_free(dhg->p);
d132 5
d138 1
a138 1
	return (0);
@


1.48
log
@fix a cast

ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.47 2008/06/26 09:19:39 djm Exp $ */
d236 2
@


1.47
log
@when loading moduli from /etc/moduli in sshd(8), check that they
are of the expected "safe prime" structure and have had
appropriate primality tests performed;
feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.46 2008/04/13 00:22:17 djm Exp $ */
d83 1
a83 1
	    (dhg->size = (u_int)strtonum(strsize, 0, 64*1024, &errstr)) == 0 ||
@


1.46
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.45 2007/09/27 00:15:57 ray Exp $ */
d46 1
d63 4
d70 5
d77 3
@


1.45
log
@Don't return -1 on error in dh_pub_is_valid(), since it evaluates
to true.

Also fix a typo.

Initial diff from Matthew Dempsky, input from djm.

OK djm, markus.
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.44 2006/11/07 13:02:07 markus Exp $ */
d153 1
a153 1
	which = arc4random() % bestcount;
@


1.44
log
@BN_hex2bn returns int; from dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.43 2006/11/06 21:25:28 markus Exp $ */
d185 1
a185 1
		logit("invalid public DH value: negativ");
d193 4
a196 2
	if ((tmp = BN_new()) == NULL)
		return (-1);
@


1.43
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.42 2006/08/03 03:34:42 deraadt Exp $ */
d254 1
a254 1
	if (BN_hex2bn(&dh->p, modulus) == NULL)
d256 1
a256 1
	if (BN_hex2bn(&dh->g, gen) == NULL)
@


1.42
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.41 2006/08/01 23:22:47 stevesk Exp $ */
d254 1
a254 1
	if (BN_hex2bn(&dh->p, modulus) == 0)
d256 1
a256 1
	if (BN_hex2bn(&dh->g, gen) == 0)
@


1.41
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.40 2006/07/26 13:57:17 stevesk Exp $ */
a24 2

#include "includes.h"
@


1.40
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.39 2006/07/26 02:35:17 stevesk Exp $ */
d33 1
@


1.39
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.38 2006/07/22 20:48:23 stevesk Exp $ */
d33 1
@


1.38
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.37 2006/07/18 22:27:55 stevesk Exp $ */
d27 2
@


1.37
log
@remove unneeded includes; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.36 2006/05/04 14:55:23 djm Exp $ */
d30 2
@


1.36
log
@tighter DH exponent checks here too; feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.35 2006/03/27 13:03:54 deraadt Exp $ */
a27 2
#include "xmalloc.h"

a29 1
#include <openssl/evp.h>
a30 3
#include "buffer.h"
#include "cipher.h"
#include "kex.h"
@


1.35
log
@use strtonum() instead of atoi(), limit dhg size to 64k; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: dh.c,v 1.34 2006/03/25 13:17:01 djm Exp $ */
d184 1
d190 15
d211 1
a211 1
	if (bits_set > 1 && (BN_cmp(dh_pub, dh->p) == -1))
d213 1
@


1.34
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d47 1
d72 2
a73 1
	    (dhg->size = atoi(strsize)) == 0)
@


1.33
log
@RCSID() can die
@
text
@d1 1
@


1.32
log
@potential NULL pointer dereferences detected by Coverity
via elad AT netbsd.org; ok deraadt@@
@
text
@a25 1
RCSID("$OpenBSD: dh.c,v 1.31 2004/08/04 10:37:52 djm Exp $");
@


1.31
log
@return group14 when no primes found - fixes hang on empty /etc/moduli;
ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.30 2004/06/13 12:53:24 djm Exp $");
d49 2
a50 1
	arg = strdelim(&cp);
@


1.31.6.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: dh.c,v 1.42 2006/08/03 03:34:42 deraadt Exp $ */
d25 4
a28 1
#include <sys/param.h>
d32 1
d34 3
a36 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

a46 1
	const char *errstr = NULL;
d49 1
a49 2
	if ((arg = strdelim(&cp)) == NULL)
		return 0;
d70 1
a70 2
	    (dhg->size = (u_int)strtonum(strsize, 0, 64*1024, &errstr)) == 0 ||
	    errstr)
a180 1
	BIGNUM *tmp;
a185 15
	if (BN_cmp(dh_pub, BN_value_one()) != 1) {	/* pub_exp <= 1 */
		logit("invalid public DH value: <= 1");
		return 0;
	}

	if ((tmp = BN_new()) == NULL)
		return (-1);
	if (!BN_sub(tmp, dh->p, BN_value_one()) ||
	    BN_cmp(dh_pub, tmp) != -1) {		/* pub_exp > p-2 */
		BN_clear_free(tmp);
		logit("invalid public DH value: >= p-1");
		return 0;
	}
	BN_clear_free(tmp);

d192 1
a192 1
	if (bits_set > 1)
a193 1

@


1.31.8.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: dh.c,v 1.42 2006/08/03 03:34:42 deraadt Exp $ */
d25 4
a28 1
#include <sys/param.h>
d32 1
d34 3
a36 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

a46 1
	const char *errstr = NULL;
d49 1
a49 2
	if ((arg = strdelim(&cp)) == NULL)
		return 0;
d70 1
a70 2
	    (dhg->size = (u_int)strtonum(strsize, 0, 64*1024, &errstr)) == 0 ||
	    errstr)
a180 1
	BIGNUM *tmp;
a185 15
	if (BN_cmp(dh_pub, BN_value_one()) != 1) {	/* pub_exp <= 1 */
		logit("invalid public DH value: <= 1");
		return 0;
	}

	if ((tmp = BN_new()) == NULL)
		return (-1);
	if (!BN_sub(tmp, dh->p, BN_value_one()) ||
	    BN_cmp(dh_pub, tmp) != -1) {		/* pub_exp > p-2 */
		BN_clear_free(tmp);
		logit("invalid public DH value: >= p-1");
		return 0;
	}
	BN_clear_free(tmp);

d192 1
a192 1
	if (bits_set > 1)
a193 1

@


1.30
log
@implement diffie-hellman-group14-sha1 kex method (trivial extension to
existing diffie-hellman-group1-sha1); ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.29 2004/02/27 22:49:27 dtucker Exp $");
d148 1
a148 1
		return (NULL);
@


1.29
log
@Reset bit counter at the right time, fixes debug output in the case where
the DH group is rejected.  ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.28 2004/02/27 22:44:56 dtucker Exp $");
d118 3
a120 2
		logit("WARNING: %s does not exist, using old modulus", _PATH_DH_MODULI);
		return (dh_new_group1());
d173 1
a173 1
/* diffie-hellman-group1-sha1 */
d274 19
@


1.29.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.31 2004/08/04 10:37:52 djm Exp $");
d118 2
a119 3
		logit("WARNING: %s does not exist, using fixed modulus",
		    _PATH_DH_MODULI);
		return (dh_new_group14());
d147 1
a147 1
		return (dh_new_group14());
d172 1
a172 1
/* diffie-hellman-groupN-sha1 */
a272 19
}

DH *
dh_new_group14(void)
{
	static char *gen = "2", *group14 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE45B3D"
	    "C2007CB8" "A163BF05" "98DA4836" "1C55D39A" "69163FA8" "FD24CF5F"
	    "83655D23" "DCA3AD96" "1C62F356" "208552BB" "9ED52907" "7096966D"
	    "670C354E" "4ABC9804" "F1746C08" "CA18217C" "32905E46" "2E36CE3B"
	    "E39E772C" "180E8603" "9B2783A2" "EC07A28F" "B5C55DF0" "6F4C52C9"
	    "DE2BCBF6" "95581718" "3995497C" "EA956AE5" "15D22618" "98FA0510"
	    "15728E5A" "8AACAA68" "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group14));
@


1.28
log
@Make /etc/moduli line buffer big enough for 8kbit primes, in case anyone
ever uses one.  ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.27 2004/02/27 22:42:47 dtucker Exp $");
d200 1
a200 1
	int i, bits_set = 0, tries = 0;
d217 1
a217 1
		for (i = 0; i <= BN_num_bits(dh->priv_key); i++)
@


1.27
log
@Prevent sshd from sending DH groups with a primitive generator of zero or
one, even if they are listed in /etc/moduli.  ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.26 2003/12/16 15:51:54 markus Exp $");
d111 1
a111 1
	char line[2048];
@


1.26
log
@use <= instead of < in dh_estimate; ok provos/hshoexer; do not return < DH_GRP_MIN
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.25 2003/09/18 13:02:21 miod Exp $");
d92 3
@


1.25
log
@A few signedness fixes for harmless situations; markus@@ ok
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.24 2003/04/08 20:21:28 itojun Exp $");
d282 1
a282 3
	if (bits < 64)
		return (512);	/* O(2**63) */
	if (bits < 128)
d284 1
a284 1
	if (bits < 192)
@


1.24
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.23 2002/11/21 22:22:50 markus Exp $");
d201 1
a201 1
	if (2*need >= BN_num_bits(dh->p))
@


1.24.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.26 2003/12/16 15:51:54 markus Exp $");
d201 1
a201 1
	if (need > INT_MAX / 2 || 2 * need >= BN_num_bits(dh->p))
d282 3
a284 1
	if (bits <= 128)
d286 1
a286 1
	if (bits <= 192)
@


1.24.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.31 2004/08/04 10:37:52 djm Exp $");
a93 3
	if (BN_is_zero(dhg->g) || BN_is_one(dhg->g))
		goto failclean;

d108 1
a108 1
	char line[4096];
d115 2
a116 3
		logit("WARNING: %s does not exist, using fixed modulus",
		    _PATH_DH_MODULI);
		return (dh_new_group14());
d144 1
a144 1
		return (dh_new_group14());
d169 1
a169 1
/* diffie-hellman-groupN-sha1 */
d197 1
a197 1
	int i, bits_set, tries = 0;
d214 1
a214 1
		for (i = 0, bits_set = 0; i <= BN_num_bits(dh->priv_key); i++)
a269 19
}

DH *
dh_new_group14(void)
{
	static char *gen = "2", *group14 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE45B3D"
	    "C2007CB8" "A163BF05" "98DA4836" "1C55D39A" "69163FA8" "FD24CF5F"
	    "83655D23" "DCA3AD96" "1C62F356" "208552BB" "9ED52907" "7096966D"
	    "670C354E" "4ABC9804" "F1746C08" "CA18217C" "32905E46" "2E36CE3B"
	    "E39E772C" "180E8603" "9B2783A2" "EC07A28F" "B5C55DF0" "6F4C52C9"
	    "DE2BCBF6" "95581718" "3995497C" "EA956AE5" "15D22618" "98FA0510"
	    "15728E5A" "8AACAA68" "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group14));
@


1.23
log
@debug->debug2
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.22 2002/06/27 08:49:44 markus Exp $");
d115 1
a115 1
		log("WARNING: %s does not exist, using old modulus", _PATH_DH_MODULI);
d143 1
a143 1
		log("WARNING: no suitable primes in %s", _PATH_DH_PRIMES);
d179 1
a179 1
		log("invalid public DH value: negativ");
d190 1
a190 1
	log("invalid public DH value (%d/%d)", bits_set, BN_num_bits(dh->p));
@


1.23.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.24 2003/04/08 20:21:28 itojun Exp $");
d115 1
a115 1
		logit("WARNING: %s does not exist, using old modulus", _PATH_DH_MODULI);
d143 1
a143 1
		logit("WARNING: no suitable primes in %s", _PATH_DH_PRIMES);
d179 1
a179 1
		logit("invalid public DH value: negativ");
d190 1
a190 1
	logit("invalid public DH value (%d/%d)", bits_set, BN_num_bits(dh->p));
@


1.23.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.26 2003/12/16 15:51:54 markus Exp $");
d201 1
a201 1
	if (need > INT_MAX / 2 || 2 * need >= BN_num_bits(dh->p))
d282 3
a284 1
	if (bits <= 128)
d286 1
a286 1
	if (bits <= 192)
@


1.22
log
@more checks for NULL pointers; from grendel@@zeitbombe.org; ok deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.21 2002/03/06 00:23:27 markus Exp $");
d185 1
a185 1
	debug("bits set: %d/%d", bits_set, BN_num_bits(dh->p));
d217 1
a217 1
		debug("dh_gen_key: priv key bits set: %d/%d",
@


1.22.2.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.23 2002/11/21 22:22:50 markus Exp $");
d185 1
a185 1
	debug2("bits set: %d/%d", bits_set, BN_num_bits(dh->p));
d217 1
a217 1
		debug2("dh_gen_key: priv key bits set: %d/%d",
@


1.22.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.24 2003/04/08 20:21:28 itojun Exp $");
d115 1
a115 1
		logit("WARNING: %s does not exist, using old modulus", _PATH_DH_MODULI);
d143 1
a143 1
		logit("WARNING: no suitable primes in %s", _PATH_DH_PRIMES);
d179 1
a179 1
		logit("invalid public DH value: negativ");
d190 1
a190 1
	logit("invalid public DH value (%d/%d)", bits_set, BN_num_bits(dh->p));
@


1.21
log
@undo
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.19 2001/12/27 19:37:22 markus Exp $");
d53 1
a53 1
	if (!*arg || *arg == '#')
@


1.21.2.1
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.22 2002/06/27 08:49:44 markus Exp $");
d53 1
a53 1
	if (!arg || !*arg || *arg == '#')
@


1.21.2.2
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.23 2002/11/21 22:22:50 markus Exp $");
d185 1
a185 1
	debug2("bits set: %d/%d", bits_set, BN_num_bits(dh->p));
d217 1
a217 1
		debug2("dh_gen_key: priv key bits set: %d/%d",
@


1.20
log
@compat.c
@
text
@a32 1
#include <openssl/err.h>
d210 2
a211 4
		if (!BN_rand(dh->priv_key, 2*need, 0, 0)) {
			int ecode = ERR_get_error();
			fatal("dh_gen_key: BN_rand failed: %s", ERR_error_string(ecode, NULL));
		}
@


1.19
log
@always use BN_clear_free instead of BN_free
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.18 2001/12/27 18:22:16 markus Exp $");
d33 1
d211 4
a214 2
		if (!BN_rand(dh->priv_key, 2*need, 0, 0))
			fatal("dh_gen_key: BN_rand failed");
@


1.18
log
@call fatal() for openssl allocation failures
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.17 2001/06/23 15:12:18 itojun Exp $");
d97 2
a98 2
	BN_free(dhg->g);
	BN_free(dhg->p);
d125 2
a126 2
		BN_free(dhg.g);
		BN_free(dhg.p);
d155 2
a156 2
			BN_free(dhg.g);
			BN_free(dhg.p);
d206 1
a206 1
			BN_free(dh->priv_key);
@


1.17
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.16 2001/06/22 21:57:59 provos Exp $");
d81 4
a84 2
	dhg->g = BN_new();
	dhg->p = BN_new();
d207 1
a207 2
		dh->priv_key = BN_new();
		if (dh->priv_key == NULL)
d229 2
a230 3
	dh = DH_new();
	if (dh == NULL)
		fatal("DH_new");
d250 2
a251 3
	dh = DH_new();
	if (dh == NULL)
		fatal("DH_new");
@


1.17.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.21 2002/03/06 00:23:27 markus Exp $");
d81 2
a82 4
	if ((dhg->g = BN_new()) == NULL)
		fatal("parse_prime: BN_new failed");
	if ((dhg->p = BN_new()) == NULL)
		fatal("parse_prime: BN_new failed");
d95 2
a96 2
	BN_clear_free(dhg->g);
	BN_clear_free(dhg->p);
d123 2
a124 2
		BN_clear_free(dhg.g);
		BN_clear_free(dhg.p);
d153 2
a154 2
			BN_clear_free(dhg.g);
			BN_clear_free(dhg.p);
d204 3
a206 2
			BN_clear_free(dh->priv_key);
		if ((dh->priv_key = BN_new()) == NULL)
d228 3
a230 2
	if ((dh = DH_new()) == NULL)
		fatal("dh_new_group_asc: DH_new");
d250 3
a252 2
	if ((dh = DH_new()) == NULL)
		fatal("dh_new_group: DH_new");
@


1.17.2.2
log
@Update to OpenSSH 3.5
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.22 2002/06/27 08:49:44 markus Exp $");
d53 1
a53 1
	if (!arg || !*arg || *arg == '#')
@


1.16
log
@increase linebuffer to deal with larger moduli; use rewind instead of
close/open
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.15 2001/06/22 21:27:07 provos Exp $");
d42 1
a42 1
int
@


1.15
log
@use /etc/moduli instead of /etc/primes, okay markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.14 2001/04/15 08:43:45 markus Exp $");
d106 1
a106 1
	char line[1024];
d137 1
a137 1
	fclose (f);
d140 1
a142 5
	}

	f = fopen(_PATH_DH_PRIMES, "r");
	if (!f) {
		fatal("WARNING: %s disappeared, giving up", _PATH_DH_PRIMES);
@


1.14
log
@some unused variable and typos; from tomh@@po.crl.go.jp
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.13 2001/04/04 23:09:17 markus Exp $");
d111 3
a113 3
	f = fopen(_PATH_DH_PRIMES, "r");
	if (!f) {
		log("WARNING: %s does not exist, using old prime", _PATH_DH_PRIMES);
@


1.14.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.17 2001/06/23 15:12:18 itojun Exp $");
d42 1
a42 1
static int
d106 1
a106 1
	char line[2048];
d111 3
a113 3
	if ((f = fopen(_PATH_DH_MODULI, "r")) == NULL &&
	    (f = fopen(_PATH_DH_PRIMES, "r")) == NULL) {
		log("WARNING: %s does not exist, using old modulus", _PATH_DH_MODULI);
d137 1
a137 1
	rewind(f);
a139 1
		fclose(f);
d142 5
@


1.14.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.21 2002/03/06 00:23:27 markus Exp $");
d81 2
a82 4
	if ((dhg->g = BN_new()) == NULL)
		fatal("parse_prime: BN_new failed");
	if ((dhg->p = BN_new()) == NULL)
		fatal("parse_prime: BN_new failed");
d95 2
a96 2
	BN_clear_free(dhg->g);
	BN_clear_free(dhg->p);
d123 2
a124 2
		BN_clear_free(dhg.g);
		BN_clear_free(dhg.p);
d153 2
a154 2
			BN_clear_free(dhg.g);
			BN_clear_free(dhg.p);
d204 3
a206 2
			BN_clear_free(dh->priv_key);
		if ((dh->priv_key = BN_new()) == NULL)
d228 3
a230 2
	if ((dh = DH_new()) == NULL)
		fatal("dh_new_group_asc: DH_new");
d250 3
a252 2
	if ((dh = DH_new()) == NULL)
		fatal("dh_new_group: DH_new");
@


1.13
log
@clear+free keys,iv for rekeying.
+ fix DH mem leaks. ok niels@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.12 2001/04/03 19:53:29 markus Exp $");
d83 1
a83 1
	if (BN_hex2bn(&dhg->g, gen) < 0)
d86 1
a86 1
	if (BN_hex2bn(&dhg->p, prime) < 0)
a230 1
	int ret;
d236 1
a236 1
	if ((ret = BN_hex2bn(&dh->p, modulus)) < 0)
d238 1
a238 1
	if ((ret = BN_hex2bn(&dh->g, gen)) < 0)
@


1.12
log
@move kex to kex*.c, used dispatch_set() callbacks for kex. should
make rekeying easier.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.11 2001/03/29 21:17:39 markus Exp $");
d154 3
a156 5
		if (dhg.size > max || dhg.size < min)
			continue;
		if (dhg.size != best)
			continue;
		if (linenum++ != which) {
d164 3
@


1.11
log
@prepare for rekeying: move DH code to dh.c
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.10 2001/03/28 22:04:57 provos Exp $");
d275 19
@


1.10
log
@more sanity checking on primes file
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.9 2001/03/27 17:46:49 provos Exp $");
d168 107
@


1.9
log
@make dh group exchange more flexible, allow min and max group size,
okay markus@@, deraadt@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.8 2001/03/05 17:58:22 stevesk Exp $");
a81 4
	if (BN_hex2bn(&dhg->g, gen) < 0) {
		BN_free(dhg->g);
		goto fail;
	}
d83 8
a90 5
	if (BN_hex2bn(&dhg->p, prime) < 0) {
		BN_free(dhg->g);
		BN_free(dhg->p);
		goto fail;
	}
d93 4
@


1.8
log
@spelling
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.7 2001/03/04 17:42:28 millert Exp $");
d72 2
d100 1
a100 1
choose_dh(int minbits)
d123 5
a127 2
		if ((dhg.size > minbits && dhg.size < best) ||
		    (dhg.size > best && best < minbits)) {
d137 2
a138 2
		log("WARNING: no primes in %s, using old prime", _PATH_DH_PRIMES);
		return (dh_new_group1());
d150 2
@


1.7
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.6 2001/01/21 19:05:49 markus Exp $");
d138 1
a138 1
		fatal("WARNING: %s dissappeared, giving up", _PATH_DH_PRIMES);
@


1.6
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.5 2001/01/19 15:55:11 markus Exp $");
d93 1
a93 1
	error("Bad prime description in line %d\n", linenum);
@


1.5
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.4 2001/01/15 21:43:51 markus Exp $");
a33 1
#include "ssh.h"
d35 1
d39 2
@


1.4
log
@use error() not stderr!
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.3 2000/11/16 17:55:43 markus Exp $");
d38 1
d104 1
a104 1
	f = fopen(DH_PRIMES, "r");
d106 1
a106 1
		log("WARNING: %s does not exist, using old prime", DH_PRIMES);
d130 1
a130 1
		log("WARNING: no primes in %s, using old prime", DH_PRIMES);
d134 1
a134 1
	f = fopen(DH_PRIMES, "r");
d136 1
a136 1
		fatal("WARNING: %s dissappeared, giving up", DH_PRIMES);
@


1.3
log
@do not use perror() in sshd, after the child is forked()
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.2 2000/10/11 20:11:35 markus Exp $");
d90 1
a90 1
	fprintf(stderr, "Bad prime description in line %d\n", linenum);
@


1.2
log
@Wall
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.1 2000/10/11 04:02:16 provos Exp $");
a104 1
		perror(DH_PRIMES);
d135 1
a135 2
		perror(DH_PRIMES);
		exit(1);
@


1.2.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.6 2001/01/21 19:05:49 markus Exp $");
d34 1
a35 1
#include "cipher.h"
a37 3
#include "pathnames.h"
#include "log.h"
#include "misc.h"
d90 1
a90 1
	error("Bad prime description in line %d\n", linenum);
d103 1
a103 1
	f = fopen(_PATH_DH_PRIMES, "r");
d105 2
a106 1
		log("WARNING: %s does not exist, using old prime", _PATH_DH_PRIMES);
d130 1
a130 1
		log("WARNING: no primes in %s, using old prime", _PATH_DH_PRIMES);
d134 1
a134 1
	f = fopen(_PATH_DH_PRIMES, "r");
d136 2
a137 1
		fatal("WARNING: %s dissappeared, giving up", _PATH_DH_PRIMES);
@


1.2.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.2.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.8 2001/03/05 17:58:22 stevesk Exp $");
d93 1
a93 1
	error("Bad prime description in line %d", linenum);
d138 1
a138 1
		fatal("WARNING: %s disappeared, giving up", _PATH_DH_PRIMES);
@


1.2.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.14 2001/04/15 08:43:45 markus Exp $");
a71 2
	/* The whole group is one bit larger */
	dhg->size++;
d80 4
d85 5
a89 8
	if (BN_hex2bn(&dhg->g, gen) == 0)
		goto failclean;

	if (BN_hex2bn(&dhg->p, prime) == 0)
		goto failclean;

	if (BN_num_bits(dhg->p) != dhg->size)
		goto failclean;
a91 4

 failclean:
	BN_free(dhg->g);
	BN_free(dhg->p);
d98 1
a98 1
choose_dh(int min, int wantbits, int max)
d121 2
a122 5
		if (dhg.size > max || dhg.size < min)
			continue;

		if ((dhg.size > wantbits && dhg.size < best) ||
		    (dhg.size > best && best < wantbits)) {
d132 2
a133 2
		log("WARNING: no suitable primes in %s", _PATH_DH_PRIMES);
		return (NULL);
d146 3
a148 3
		if ((dhg.size > max || dhg.size < min) ||
		    dhg.size != best ||
		    linenum++ != which) {
a155 3
	if (linenum != which+1)
		fatal("WARNING: line %d disappeared in %s, giving up",
		    which, _PATH_DH_PRIMES);
a157 125
}

/* diffie-hellman-group1-sha1 */

int
dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
{
	int i;
	int n = BN_num_bits(dh_pub);
	int bits_set = 0;

	if (dh_pub->neg) {
		log("invalid public DH value: negativ");
		return 0;
	}
	for (i = 0; i <= n; i++)
		if (BN_is_bit_set(dh_pub, i))
			bits_set++;
	debug("bits set: %d/%d", bits_set, BN_num_bits(dh->p));

	/* if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial */
	if (bits_set > 1 && (BN_cmp(dh_pub, dh->p) == -1))
		return 1;
	log("invalid public DH value (%d/%d)", bits_set, BN_num_bits(dh->p));
	return 0;
}

void
dh_gen_key(DH *dh, int need)
{
	int i, bits_set = 0, tries = 0;

	if (dh->p == NULL)
		fatal("dh_gen_key: dh->p == NULL");
	if (2*need >= BN_num_bits(dh->p))
		fatal("dh_gen_key: group too small: %d (2*need %d)",
		    BN_num_bits(dh->p), 2*need);
	do {
		if (dh->priv_key != NULL)
			BN_free(dh->priv_key);
		dh->priv_key = BN_new();
		if (dh->priv_key == NULL)
			fatal("dh_gen_key: BN_new failed");
		/* generate a 2*need bits random private exponent */
		if (!BN_rand(dh->priv_key, 2*need, 0, 0))
			fatal("dh_gen_key: BN_rand failed");
		if (DH_generate_key(dh) == 0)
			fatal("DH_generate_key");
		for (i = 0; i <= BN_num_bits(dh->priv_key); i++)
			if (BN_is_bit_set(dh->priv_key, i))
				bits_set++;
		debug("dh_gen_key: priv key bits set: %d/%d",
		    bits_set, BN_num_bits(dh->priv_key));
		if (tries++ > 10)
			fatal("dh_gen_key: too many bad keys: giving up");
	} while (!dh_pub_is_valid(dh, dh->pub_key));
}

DH *
dh_new_group_asc(const char *gen, const char *modulus)
{
	DH *dh;

	dh = DH_new();
	if (dh == NULL)
		fatal("DH_new");

	if (BN_hex2bn(&dh->p, modulus) == 0)
		fatal("BN_hex2bn p");
	if (BN_hex2bn(&dh->g, gen) == 0)
		fatal("BN_hex2bn g");

	return (dh);
}

/*
 * This just returns the group, we still need to generate the exchange
 * value.
 */

DH *
dh_new_group(BIGNUM *gen, BIGNUM *modulus)
{
	DH *dh;

	dh = DH_new();
	if (dh == NULL)
		fatal("DH_new");
	dh->p = modulus;
	dh->g = gen;

	return (dh);
}

DH *
dh_new_group1(void)
{
	static char *gen = "2", *group1 =
	    "FFFFFFFF" "FFFFFFFF" "C90FDAA2" "2168C234" "C4C6628B" "80DC1CD1"
	    "29024E08" "8A67CC74" "020BBEA6" "3B139B22" "514A0879" "8E3404DD"
	    "EF9519B3" "CD3A431B" "302B0A6D" "F25F1437" "4FE1356D" "6D51C245"
	    "E485B576" "625E7EC6" "F44C42E9" "A637ED6B" "0BFF5CB6" "F406B7ED"
	    "EE386BFB" "5A899FA5" "AE9F2411" "7C4B1FE6" "49286651" "ECE65381"
	    "FFFFFFFF" "FFFFFFFF";

	return (dh_new_group_asc(gen, group1));
}

/*
 * Estimates the group order for a Diffie-Hellman group that has an
 * attack complexity approximately the same as O(2**bits).  Estimate
 * with:  O(exp(1.9223 * (ln q)^(1/3) (ln ln q)^(2/3)))
 */

int
dh_estimate(int bits)
{

	if (bits < 64)
		return (512);	/* O(2**63) */
	if (bits < 128)
		return (1024);	/* O(2**86) */
	if (bits < 192)
		return (2048);	/* O(2**116) */
	return (4096);		/* O(2**156) */
@


1.2.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.17 2001/06/23 15:12:18 itojun Exp $");
d42 1
a42 1
static int
d106 1
a106 1
	char line[2048];
d111 3
a113 3
	if ((f = fopen(_PATH_DH_MODULI, "r")) == NULL &&
	    (f = fopen(_PATH_DH_PRIMES, "r")) == NULL) {
		log("WARNING: %s does not exist, using old modulus", _PATH_DH_MODULI);
d137 1
a137 1
	rewind(f);
a139 1
		fclose(f);
d142 5
@


1.2.2.6
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.21 2002/03/06 00:23:27 markus Exp $");
d81 2
a82 4
	if ((dhg->g = BN_new()) == NULL)
		fatal("parse_prime: BN_new failed");
	if ((dhg->p = BN_new()) == NULL)
		fatal("parse_prime: BN_new failed");
d95 2
a96 2
	BN_clear_free(dhg->g);
	BN_clear_free(dhg->p);
d123 2
a124 2
		BN_clear_free(dhg.g);
		BN_clear_free(dhg.p);
d153 2
a154 2
			BN_clear_free(dhg.g);
			BN_clear_free(dhg.p);
d204 3
a206 2
			BN_clear_free(dh->priv_key);
		if ((dh->priv_key = BN_new()) == NULL)
d228 3
a230 2
	if ((dh = DH_new()) == NULL)
		fatal("dh_new_group_asc: DH_new");
d250 3
a252 2
	if ((dh = DH_new()) == NULL)
		fatal("dh_new_group: DH_new");
@


1.2.4.1
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.2 2000/10/11 20:11:35 markus Exp $");
@


1.2.4.2
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.6 2001/01/21 19:05:49 markus Exp $");
d34 1
a35 1
#include "cipher.h"
a37 3
#include "pathnames.h"
#include "log.h"
#include "misc.h"
d90 1
a90 1
	error("Bad prime description in line %d\n", linenum);
d103 1
a103 1
	f = fopen(_PATH_DH_PRIMES, "r");
d105 2
a106 1
		log("WARNING: %s does not exist, using old prime", _PATH_DH_PRIMES);
d130 1
a130 1
		log("WARNING: no primes in %s, using old prime", _PATH_DH_PRIMES);
d134 1
a134 1
	f = fopen(_PATH_DH_PRIMES, "r");
d136 2
a137 1
		fatal("WARNING: %s dissappeared, giving up", _PATH_DH_PRIMES);
@


1.2.4.3
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dh.c,v 1.8 2001/03/05 17:58:22 stevesk Exp $");
d93 1
a93 1
	error("Bad prime description in line %d", linenum);
d138 1
a138 1
		fatal("WARNING: %s disappeared, giving up", _PATH_DH_PRIMES);
@


1.1
log
@First rough implementation of the diffie-hellman group exchange.  The
client can ask the server for bigger groups to perform the diffie-hellman
in, thus increasing the attack complexity when using ciphers with longer
keys.  University of Windsor provided network, T the company.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: dsa.c,v 1.11 2000/09/07 20:27:51 deraadt Exp $");
a98 1
	char *cp, *arg;
@

