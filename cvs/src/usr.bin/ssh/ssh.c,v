head	1.452;
access;
symbols
	OPENBSD_6_1:1.451.0.4
	OPENBSD_6_1_BASE:1.451
	OPENBSD_6_0:1.445.0.4
	OPENBSD_6_0_BASE:1.445
	OPENBSD_5_9:1.436.0.2
	OPENBSD_5_9_BASE:1.436
	OPENBSD_5_8:1.420.0.2
	OPENBSD_5_8_BASE:1.420
	OPENBSD_5_7:1.416.0.2
	OPENBSD_5_7_BASE:1.416
	OPENBSD_5_6:1.407.0.4
	OPENBSD_5_6_BASE:1.407
	OPENBSD_5_5:1.401.0.4
	OPENBSD_5_5_BASE:1.401
	OPENBSD_5_4:1.381.0.2
	OPENBSD_5_4_BASE:1.381
	OPENBSD_5_3:1.373.0.2
	OPENBSD_5_3_BASE:1.373
	OPENBSD_5_2:1.370.0.2
	OPENBSD_5_2_BASE:1.370
	OPENBSD_5_1_BASE:1.368
	OPENBSD_5_1:1.368.0.2
	OPENBSD_5_0:1.364.0.2
	OPENBSD_5_0_BASE:1.364
	OPENBSD_4_9:1.356.0.2
	OPENBSD_4_9_BASE:1.356
	OPENBSD_4_8:1.348.0.2
	OPENBSD_4_8_BASE:1.348
	OPENBSD_4_7:1.335.0.2
	OPENBSD_4_7_BASE:1.335
	OPENBSD_4_6:1.326.0.4
	OPENBSD_4_6_BASE:1.326
	OPENBSD_4_5:1.324.0.2
	OPENBSD_4_5_BASE:1.324
	OPENBSD_4_4:1.318.0.2
	OPENBSD_4_4_BASE:1.318
	OPENBSD_4_3:1.309.0.2
	OPENBSD_4_3_BASE:1.309
	OPENBSD_4_2:1.301.0.2
	OPENBSD_4_2_BASE:1.301
	OPENBSD_4_1:1.295.0.2
	OPENBSD_4_1_BASE:1.295
	OPENBSD_4_0:1.293.0.4
	OPENBSD_4_0_BASE:1.293
	OPENBSD_3_9:1.265.0.2
	OPENBSD_3_9_BASE:1.265
	OPENBSD_3_8:1.249.0.2
	OPENBSD_3_8_BASE:1.249
	OPENBSD_3_7:1.234.0.2
	OPENBSD_3_7_BASE:1.234
	OPENBSD_3_6:1.226.0.2
	OPENBSD_3_6_BASE:1.226
	OPENBSD_3_5:1.209.0.2
	OPENBSD_3_5_BASE:1.209
	OPENBSD_3_4:1.201.0.2
	OPENBSD_3_4_BASE:1.201
	OPENBSD_3_3:1.190.0.2
	OPENBSD_3_3_BASE:1.190
	OPENBSD_3_2:1.186.0.2
	OPENBSD_3_2_BASE:1.186
	OPENBSD_3_1:1.169.0.2
	OPENBSD_3_1_BASE:1.169
	OPENBSD_3_0:1.147.0.2
	OPENBSD_3_0_BASE:1.147
	OPENBSD_2_9_BASE:1.116
	OPENBSD_2_9:1.116.0.2
	OPENBSD_2_8:1.69.0.2
	OPENBSD_2_8_BASE:1.69
	OPENBSD_2_7:1.51.0.2
	OPENBSD_2_7_BASE:1.51
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24;
locks; strict;
comment	@ * @;


1.452
date	2017.04.28.03.20.27;	author dtucker;	state Exp;
branches;
next	1.451;
commitid	caVz6KsS81NStuJJ;

1.451
date	2017.03.10.04.07.20;	author djm;	state Exp;
branches;
next	1.450;
commitid	jIzoiBuLJ7h3Ymf6;

1.450
date	2017.03.08.12.07.47;	author djm;	state Exp;
branches;
next	1.449;
commitid	BZeLblbMQf36qHH0;

1.449
date	2017.02.17.02.04.15;	author djm;	state Exp;
branches;
next	1.448;
commitid	uIVa5sLuCavxhVOk;

1.448
date	2016.12.06.07.48.01;	author djm;	state Exp;
branches;
next	1.447;
commitid	sGbOU2yCL8mFliE5;

1.447
date	2016.09.30.09.19.13;	author markus;	state Exp;
branches;
next	1.446;
commitid	VHQRRel9yTEUINVH;

1.446
date	2016.09.12.23.31.27;	author djm;	state Exp;
branches;
next	1.445;
commitid	LKO6f6n1OiczQZjL;

1.445
date	2016.07.17.04.20.16;	author djm;	state Exp;
branches;
next	1.444;
commitid	Tgv3JW0XntG1C5ZI;

1.444
date	2016.07.16.06.57.55;	author jmc;	state Exp;
branches;
next	1.443;
commitid	YtGE59gQHprFvUUp;

1.443
date	2016.07.15.00.24.30;	author djm;	state Exp;
branches;
next	1.442;
commitid	PAQPO8bvkonq4i81;

1.442
date	2016.06.03.04.09.39;	author dtucker;	state Exp;
branches;
next	1.441;
commitid	KcqPbgryCK0G1AKK;

1.441
date	2016.06.03.03.14.41;	author dtucker;	state Exp;
branches;
next	1.440;
commitid	ovpSdW3xBjKJO7iw;

1.440
date	2016.05.04.14.29.58;	author markus;	state Exp;
branches;
next	1.439;
commitid	9ydzI4x49mjHtEkc;

1.439
date	2016.05.04.12.21.53;	author markus;	state Exp;
branches;
next	1.438;
commitid	cxcRWNRjlPdtRVOI;

1.438
date	2016.04.29.08.07.53;	author djm;	state Exp;
branches;
next	1.437;
commitid	RE6kD70UGwrQdBtC;

1.437
date	2016.03.07.19.02.43;	author djm;	state Exp;
branches;
next	1.436;
commitid	kr9hjdmg99uVnhW2;

1.436
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.435;
commitid	ut5A0buLh4mhCTFu;

1.435
date	2016.01.14.16.17.40;	author markus;	state Exp;
branches;
next	1.434;
commitid	W9ye0gltieEl87AJ;

1.434
date	2016.01.14.14.34.34;	author deraadt;	state Exp;
branches;
next	1.433;
commitid	ZDYRhanUMbi82fa7;

1.433
date	2016.01.13.23.04.47;	author djm;	state Exp;
branches;
next	1.432;
commitid	ALMWb9LK721aNRnl;

1.432
date	2015.12.11.03.20.09;	author djm;	state Exp;
branches;
next	1.431;
commitid	hFJ6cE4UDydDNV0L;

1.431
date	2015.12.10.17.08.40;	author mmcc;	state Exp;
branches;
next	1.430;
commitid	qST12VGCwbX5zIfM;

1.430
date	2015.11.19.08.23.27;	author djm;	state Exp;
branches;
next	1.429;
commitid	vjLZDEV1SOcsI3XO;

1.429
date	2015.10.25.23.42.00;	author dtucker;	state Exp;
branches;
next	1.428;
commitid	LijhWUrUi7tOK4YT;

1.428
date	2015.10.16.18.40.49;	author djm;	state Exp;
branches;
next	1.427;
commitid	sxstIfbmi5tEQrwk;

1.427
date	2015.10.15.23.51.40;	author djm;	state Exp;
branches;
next	1.426;
commitid	Zt9fWcnXm9hrhBex;

1.426
date	2015.09.24.06.15.11;	author djm;	state Exp;
branches;
next	1.425;
commitid	nGLvQjqT3Z8tECCC;

1.425
date	2015.09.11.06.55.46;	author jmc;	state Exp;
branches;
next	1.424;
commitid	MM3u3TBXEfkzeVjC;

1.424
date	2015.09.11.05.27.02;	author dtucker;	state Exp;
branches;
next	1.423;
commitid	Xz6DJt5ht2JAEXe1;

1.423
date	2015.09.11.03.47.28;	author djm;	state Exp;
branches;
next	1.422;
commitid	dGieB1hwzPDAUiiC;

1.422
date	2015.09.04.08.21.47;	author dtucker;	state Exp;
branches;
next	1.421;
commitid	FhVyfTnh6Klt0EZk;

1.421
date	2015.09.04.04.56.09;	author djm;	state Exp;
branches;
next	1.420;
commitid	c1aiPRHdvl1EdNYg;

1.420
date	2015.07.30.00.01.34;	author djm;	state Exp;
branches
	1.420.2.1;
next	1.419;
commitid	YReS3Mui4FCZvL7z;

1.419
date	2015.07.20.18.42.35;	author millert;	state Exp;
branches;
next	1.418;
commitid	7Dcxx9iQzCDrXjyl;

1.418
date	2015.05.04.06.10.48;	author djm;	state Exp;
branches;
next	1.417;
commitid	KfZDG8r2EByk0YBR;

1.417
date	2015.04.17.13.16.48;	author djm;	state Exp;
branches;
next	1.416;
commitid	OF8MIlkgiex2g7Ku;

1.416
date	2015.03.03.06.48.58;	author djm;	state Exp;
branches
	1.416.2.1;
next	1.415;
commitid	FmYNy3aFBDiZmN1Z;

1.415
date	2015.02.20.22.17.21;	author djm;	state Exp;
branches;
next	1.414;
commitid	9L88tCQWzQkTa0uX;

1.414
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.413;
commitid	cBx23BaCk6gYBpRj;

1.413
date	2015.01.16.07.19.48;	author djm;	state Exp;
branches;
next	1.412;
commitid	BvdbycsAVoioOVfP;

1.412
date	2015.01.14.20.05.27;	author djm;	state Exp;
branches;
next	1.411;
commitid	YqNUZu0ifI7Q95nk;

1.411
date	2015.01.08.10.15.45;	author djm;	state Exp;
branches;
next	1.410;
commitid	XfEeQEKsEJFBC2R6;

1.410
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.409;
commitid	yCis8OrOsfixbKpI;

1.409
date	2014.10.09.06.21.31;	author jmc;	state Exp;
branches;
next	1.408;
commitid	v1cNuSL1F1D0GTqB;

1.408
date	2014.10.08.22.20.25;	author djm;	state Exp;
branches;
next	1.407;
commitid	FjkSE9L51UbRANmo;

1.407
date	2014.07.17.07.22.19;	author djm;	state Exp;
branches;
next	1.406;
commitid	TDWPfvKEryjfRthw;

1.406
date	2014.07.15.15.54.14;	author millert;	state Exp;
branches;
next	1.405;
commitid	z7plx8Gkj6l2sxem;

1.405
date	2014.07.03.06.39.19;	author djm;	state Exp;
branches;
next	1.404;
commitid	USujq5Vfy6dBmgCF;

1.404
date	2014.06.27.16.41.56;	author markus;	state Exp;
branches;
next	1.403;
commitid	npS0wYoZKjQDRx0P;

1.403
date	2014.06.24.02.19.48;	author djm;	state Exp;
branches;
next	1.402;
commitid	uMHNOzHmukXm2zl0;

1.402
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.401;

1.401
date	2014.02.26.20.18.37;	author djm;	state Exp;
branches;
next	1.400;

1.400
date	2014.02.23.20.11.36;	author djm;	state Exp;
branches;
next	1.399;

1.399
date	2014.02.04.00.24.29;	author djm;	state Exp;
branches;
next	1.398;

1.398
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.397;

1.397
date	2013.12.29.05.42.16;	author djm;	state Exp;
branches;
next	1.396;

1.396
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.395;

1.395
date	2013.11.26.12.14.54;	author jmc;	state Exp;
branches;
next	1.394;

1.394
date	2013.11.25.18.04.21;	author deraadt;	state Exp;
branches;
next	1.393;

1.393
date	2013.11.21.00.45.44;	author djm;	state Exp;
branches;
next	1.392;

1.392
date	2013.11.07.11.58.27;	author dtucker;	state Exp;
branches;
next	1.391;

1.391
date	2013.10.25.23.04.51;	author djm;	state Exp;
branches;
next	1.390;

1.390
date	2013.10.24.08.19.36;	author djm;	state Exp;
branches;
next	1.389;

1.389
date	2013.10.23.03.05.19;	author djm;	state Exp;
branches;
next	1.388;

1.388
date	2013.10.17.00.46.49;	author djm;	state Exp;
branches;
next	1.387;

1.387
date	2013.10.16.22.58.01;	author djm;	state Exp;
branches;
next	1.386;

1.386
date	2013.10.16.22.49.39;	author djm;	state Exp;
branches;
next	1.385;

1.385
date	2013.10.16.02.31.46;	author djm;	state Exp;
branches;
next	1.384;

1.384
date	2013.10.14.23.31.01;	author djm;	state Exp;
branches;
next	1.383;

1.383
date	2013.10.14.23.28.23;	author djm;	state Exp;
branches;
next	1.382;

1.382
date	2013.10.14.22.22.04;	author djm;	state Exp;
branches;
next	1.381;

1.381
date	2013.07.25.00.29.10;	author djm;	state Exp;
branches;
next	1.380;

1.380
date	2013.07.20.01.44.37;	author djm;	state Exp;
branches;
next	1.379;

1.379
date	2013.07.12.05.48.55;	author djm;	state Exp;
branches;
next	1.378;

1.378
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.377;

1.377
date	2013.04.19.11.10.18;	author djm;	state Exp;
branches;
next	1.376;

1.376
date	2013.04.19.01.06.50;	author djm;	state Exp;
branches;
next	1.375;

1.375
date	2013.04.07.02.10.33;	author dtucker;	state Exp;
branches;
next	1.374;

1.374
date	2013.03.08.06.32.58;	author djm;	state Exp;
branches;
next	1.373;

1.373
date	2013.02.22.22.09.01;	author djm;	state Exp;
branches;
next	1.372;

1.372
date	2013.02.22.04.45.09;	author dtucker;	state Exp;
branches;
next	1.371;

1.371
date	2013.02.17.23.16.57;	author dtucker;	state Exp;
branches;
next	1.370;

1.370
date	2012.07.06.01.47.38;	author djm;	state Exp;
branches;
next	1.369;

1.369
date	2012.07.02.08.50.03;	author dtucker;	state Exp;
branches;
next	1.368;

1.368
date	2011.10.24.02.10.46;	author djm;	state Exp;
branches;
next	1.367;

1.367
date	2011.10.18.05.15.28;	author djm;	state Exp;
branches;
next	1.366;

1.366
date	2011.09.23.07.45.05;	author markus;	state Exp;
branches;
next	1.365;

1.365
date	2011.09.09.22.46.44;	author djm;	state Exp;
branches;
next	1.364;

1.364
date	2011.08.02.23.15.03;	author djm;	state Exp;
branches;
next	1.363;

1.363
date	2011.06.22.22.08.42;	author djm;	state Exp;
branches;
next	1.362;

1.362
date	2011.06.03.00.54.38;	author djm;	state Exp;
branches;
next	1.361;

1.361
date	2011.05.24.07.15.47;	author djm;	state Exp;
branches;
next	1.360;

1.360
date	2011.05.06.21.38.58;	author djm;	state Exp;
branches;
next	1.359;

1.359
date	2011.05.06.21.34.32;	author djm;	state Exp;
branches;
next	1.358;

1.358
date	2011.05.06.21.18.02;	author djm;	state Exp;
branches;
next	1.357;

1.357
date	2011.04.17.22.42.42;	author djm;	state Exp;
branches;
next	1.356;

1.356
date	2011.01.06.22.23.53;	author djm;	state Exp;
branches;
next	1.355;

1.355
date	2010.11.29.23.45.51;	author djm;	state Exp;
branches;
next	1.354;

1.354
date	2010.11.13.23.27.50;	author djm;	state Exp;
branches;
next	1.353;

1.353
date	2010.10.06.06.39.28;	author djm;	state Exp;
branches;
next	1.352;

1.352
date	2010.09.20.04.41.47;	author djm;	state Exp;
branches;
next	1.351;

1.351
date	2010.09.02.16.08.39;	author markus;	state Exp;
branches;
next	1.350;

1.350
date	2010.08.31.12.33.38;	author djm;	state Exp;
branches;
next	1.349;

1.349
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.348;

1.348
date	2010.08.16.04.06.06;	author djm;	state Exp;
branches;
next	1.347;

1.347
date	2010.08.12.23.34.39;	author tedu;	state Exp;
branches;
next	1.346;

1.346
date	2010.08.12.21.49.44;	author djm;	state Exp;
branches;
next	1.345;

1.345
date	2010.08.04.05.42.47;	author djm;	state Exp;
branches;
next	1.344;

1.344
date	2010.07.19.09.15.12;	author djm;	state Exp;
branches;
next	1.343;

1.343
date	2010.07.12.22.41.13;	author djm;	state Exp;
branches;
next	1.342;

1.342
date	2010.07.12.22.38.52;	author djm;	state Exp;
branches;
next	1.341;

1.341
date	2010.06.26.23.04.04;	author djm;	state Exp;
branches;
next	1.340;

1.340
date	2010.06.25.23.15.36;	author djm;	state Exp;
branches;
next	1.339;

1.339
date	2010.06.25.23.10.30;	author djm;	state Exp;
branches;
next	1.338;

1.338
date	2010.05.16.12.55.51;	author markus;	state Exp;
branches;
next	1.337;

1.337
date	2010.05.14.23.29.23;	author djm;	state Exp;
branches;
next	1.336;

1.336
date	2010.04.10.00.00.16;	author djm;	state Exp;
branches;
next	1.335;

1.335
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.334;

1.334
date	2010.02.08.22.03.05;	author jmc;	state Exp;
branches;
next	1.333;

1.333
date	2010.02.08.10.50.20;	author markus;	state Exp;
branches;
next	1.332;

1.332
date	2010.01.26.01.28.35;	author djm;	state Exp;
branches;
next	1.331;

1.331
date	2010.01.11.01.39.46;	author dtucker;	state Exp;
branches;
next	1.330;

1.330
date	2010.01.09.23.04.13;	author dtucker;	state Exp;
branches;
next	1.329;

1.329
date	2009.12.20.07.28.36;	author guenther;	state Exp;
branches;
next	1.328;

1.328
date	2009.10.28.16.38.18;	author reyk;	state Exp;
branches;
next	1.327;

1.327
date	2009.10.24.11.23.42;	author andreas;	state Exp;
branches;
next	1.326;

1.326
date	2009.07.02.02.11.47;	author dtucker;	state Exp;
branches;
next	1.325;

1.325
date	2009.03.17.21.37.00;	author markus;	state Exp;
branches;
next	1.324;

1.324
date	2009.02.12.03.00.56;	author djm;	state Exp;
branches;
next	1.323;

1.323
date	2009.01.22.10.02.34;	author djm;	state Exp;
branches;
next	1.322;

1.322
date	2008.11.01.17.40.33;	author stevesk;	state Exp;
branches;
next	1.321;

1.321
date	2008.10.09.06.54.22;	author jmc;	state Exp;
branches;
next	1.320;

1.320
date	2008.10.08.23.34.03;	author djm;	state Exp;
branches;
next	1.319;

1.319
date	2008.09.11.14.22.37;	author markus;	state Exp;
branches;
next	1.318;

1.318
date	2008.07.02.13.47.39;	author djm;	state Exp;
branches;
next	1.317;

1.317
date	2008.06.12.16.35.31;	author dtucker;	state Exp;
branches;
next	1.316;

1.316
date	2008.06.12.04.24.06;	author djm;	state Exp;
branches;
next	1.315;

1.315
date	2008.06.12.04.06.00;	author djm;	state Exp;
branches;
next	1.314;

1.314
date	2008.06.10.22.15.23;	author djm;	state Exp;
branches;
next	1.313;

1.313
date	2008.05.09.14.26.08;	author djm;	state Exp;
branches;
next	1.312;

1.312
date	2008.05.09.14.18.44;	author djm;	state Exp;
branches;
next	1.311;

1.311
date	2008.05.08.13.06.11;	author djm;	state Exp;
branches;
next	1.310;

1.310
date	2008.05.08.12.02.23;	author djm;	state Exp;
branches;
next	1.309;

1.309
date	2008.01.19.20.51.26;	author djm;	state Exp;
branches;
next	1.308;

1.308
date	2007.11.03.02.03.49;	author deraadt;	state Exp;
branches;
next	1.307;

1.307
date	2007.11.03.02.00.32;	author dtucker;	state Exp;
branches;
next	1.306;

1.306
date	2007.11.03.01.24.06;	author deraadt;	state Exp;
branches;
next	1.305;

1.305
date	2007.10.29.06.54.50;	author dtucker;	state Exp;
branches;
next	1.304;

1.304
date	2007.10.29.01.55.04;	author dtucker;	state Exp;
branches;
next	1.303;

1.303
date	2007.09.04.11.15.55;	author djm;	state Exp;
branches;
next	1.302;

1.302
date	2007.09.04.03.21.03;	author djm;	state Exp;
branches;
next	1.301;

1.301
date	2007.08.07.07.32.53;	author djm;	state Exp;
branches;
next	1.300;

1.300
date	2007.06.14.22.48.05;	author djm;	state Exp;
branches;
next	1.299;

1.299
date	2007.06.14.21.43.25;	author djm;	state Exp;
branches;
next	1.298;

1.298
date	2007.06.12.11.45.27;	author djm;	state Exp;
branches;
next	1.297;

1.297
date	2007.06.12.11.15.17;	author djm;	state Exp;
branches;
next	1.296;

1.296
date	2007.06.12.11.11.08;	author djm;	state Exp;
branches;
next	1.295;

1.295
date	2007.01.03.03.01.40;	author stevesk;	state Exp;
branches;
next	1.294;

1.294
date	2006.10.06.02.29.19;	author djm;	state Exp;
branches;
next	1.293;

1.293
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.293.4.1;
next	1.292;

1.292
date	2006.08.01.23.36.12;	author stevesk;	state Exp;
branches;
next	1.291;

1.291
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.290;

1.290
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.289;

1.289
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.288;

1.288
date	2006.07.17.01.31.10;	author stevesk;	state Exp;
branches;
next	1.287;

1.287
date	2006.07.12.22.42.32;	author stevesk;	state Exp;
branches;
next	1.286;

1.286
date	2006.07.12.22.28.52;	author stevesk;	state Exp;
branches;
next	1.285;

1.285
date	2006.07.11.20.27.56;	author stevesk;	state Exp;
branches;
next	1.284;

1.284
date	2006.07.11.20.16.43;	author stevesk;	state Exp;
branches;
next	1.283;

1.283
date	2006.07.11.18.50.48;	author markus;	state Exp;
branches;
next	1.282;

1.282
date	2006.07.11.10.12.07;	author dtucker;	state Exp;
branches;
next	1.281;

1.281
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.280;

1.280
date	2006.07.08.21.47.12;	author stevesk;	state Exp;
branches;
next	1.279;

1.279
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.278;

1.278
date	2006.07.03.08.54.20;	author stevesk;	state Exp;
branches;
next	1.277;

1.277
date	2006.07.02.17.12.58;	author stevesk;	state Exp;
branches;
next	1.276;

1.276
date	2006.04.25.08.02.27;	author dtucker;	state Exp;
branches;
next	1.275;

1.275
date	2006.03.30.10.41.25;	author djm;	state Exp;
branches;
next	1.274;

1.274
date	2006.03.28.00.12.31;	author deraadt;	state Exp;
branches;
next	1.273;

1.273
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.272;

1.272
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.271;

1.271
date	2006.03.20.18.42.26;	author deraadt;	state Exp;
branches;
next	1.270;

1.270
date	2006.03.20.18.26.55;	author deraadt;	state Exp;
branches;
next	1.269;

1.269
date	2006.03.20.18.14.02;	author deraadt;	state Exp;
branches;
next	1.268;

1.268
date	2006.03.19.18.59.30;	author deraadt;	state Exp;
branches;
next	1.267;

1.267
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.266;

1.266
date	2006.03.12.04.23.07;	author djm;	state Exp;
branches;
next	1.265;

1.265
date	2006.02.22.00.04.45;	author stevesk;	state Exp;
branches
	1.265.2.1;
next	1.264;

1.264
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches;
next	1.263;

1.263
date	2006.02.20.17.02.44;	author stevesk;	state Exp;
branches;
next	1.262;

1.262
date	2006.02.20.16.36.15;	author stevesk;	state Exp;
branches;
next	1.261;

1.261
date	2006.02.12.06.45.34;	author djm;	state Exp;
branches;
next	1.260;

1.260
date	2006.02.10.00.27.13;	author stevesk;	state Exp;
branches;
next	1.259;

1.259
date	2006.02.08.14.31.30;	author stevesk;	state Exp;
branches;
next	1.258;

1.258
date	2006.02.08.12.15.27;	author stevesk;	state Exp;
branches;
next	1.257;

1.257
date	2005.12.20.04.41.07;	author dtucker;	state Exp;
branches;
next	1.256;

1.256
date	2005.12.08.18.34.11;	author reyk;	state Exp;
branches;
next	1.255;

1.255
date	2005.12.06.22.38.27;	author reyk;	state Exp;
branches;
next	1.254;

1.254
date	2005.10.30.08.52.18;	author djm;	state Exp;
branches;
next	1.253;

1.253
date	2005.10.30.04.03.24;	author djm;	state Exp;
branches;
next	1.252;

1.252
date	2005.10.14.02.17.59;	author stevesk;	state Exp;
branches;
next	1.251;

1.251
date	2005.09.19.15.42.44;	author jmc;	state Exp;
branches;
next	1.250;

1.250
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.249;

1.249
date	2005.07.30.01.26.16;	author djm;	state Exp;
branches
	1.249.2.1;
next	1.248;

1.248
date	2005.07.16.01.35.24;	author djm;	state Exp;
branches;
next	1.247;

1.247
date	2005.07.04.00.58.43;	author djm;	state Exp;
branches;
next	1.246;

1.246
date	2005.06.25.22.47.49;	author djm;	state Exp;
branches;
next	1.245;

1.245
date	2005.06.18.04.30.36;	author djm;	state Exp;
branches;
next	1.244;

1.244
date	2005.06.17.22.53.46;	author djm;	state Exp;
branches;
next	1.243;

1.243
date	2005.06.16.03.38.36;	author djm;	state Exp;
branches;
next	1.242;

1.242
date	2005.06.08.11.25.09;	author djm;	state Exp;
branches;
next	1.241;

1.241
date	2005.06.06.11.20.36;	author djm;	state Exp;
branches;
next	1.240;

1.240
date	2005.05.27.08.30.37;	author djm;	state Exp;
branches;
next	1.239;

1.239
date	2005.05.10.10.30.43;	author djm;	state Exp;
branches;
next	1.238;

1.238
date	2005.05.10.10.28.11;	author djm;	state Exp;
branches;
next	1.237;

1.237
date	2005.04.26.13.08.37;	author jakob;	state Exp;
branches;
next	1.236;

1.236
date	2005.04.21.11.47.19;	author djm;	state Exp;
branches;
next	1.235;

1.235
date	2005.04.06.12.26.06;	author dtucker;	state Exp;
branches;
next	1.234;

1.234
date	2005.03.10.22.01.06;	author deraadt;	state Exp;
branches
	1.234.2.1;
next	1.233;

1.233
date	2005.03.01.17.22.06;	author jmc;	state Exp;
branches;
next	1.232;

1.232
date	2005.03.01.10.09.52;	author djm;	state Exp;
branches;
next	1.231;

1.231
date	2005.02.16.09.56.44;	author otto;	state Exp;
branches;
next	1.230;

1.230
date	2004.11.07.17.57.30;	author jmc;	state Exp;
branches;
next	1.229;

1.229
date	2004.11.07.00.01.46;	author djm;	state Exp;
branches;
next	1.228;

1.228
date	2004.09.23.13.00.04;	author djm;	state Exp;
branches;
next	1.227;

1.227
date	2004.09.15.00.46.01;	author deraadt;	state Exp;
branches;
next	1.226;

1.226
date	2004.09.07.23.41.30;	author djm;	state Exp;
branches
	1.226.2.1;
next	1.225;

1.225
date	2004.08.23.14.26.38;	author dtucker;	state Exp;
branches;
next	1.224;

1.224
date	2004.07.28.09.40.29;	author markus;	state Exp;
branches;
next	1.223;

1.223
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches;
next	1.222;

1.222
date	2004.06.23.14.31.01;	author dtucker;	state Exp;
branches;
next	1.221;

1.221
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.220;

1.220
date	2004.06.20.17.36.59;	author djm;	state Exp;
branches;
next	1.219;

1.219
date	2004.06.18.10.55.43;	author markus;	state Exp;
branches;
next	1.218;

1.218
date	2004.06.18.10.40.19;	author djm;	state Exp;
branches;
next	1.217;

1.217
date	2004.06.17.23.56.57;	author djm;	state Exp;
branches;
next	1.216;

1.216
date	2004.06.17.15.10.14;	author djm;	state Exp;
branches;
next	1.215;

1.215
date	2004.06.17.14.52.48;	author djm;	state Exp;
branches;
next	1.214;

1.214
date	2004.06.13.15.03.02;	author djm;	state Exp;
branches;
next	1.213;

1.213
date	2004.05.08.00.01.37;	author deraadt;	state Exp;
branches;
next	1.212;

1.212
date	2004.04.27.09.46.37;	author djm;	state Exp;
branches;
next	1.211;

1.211
date	2004.04.19.21.51.49;	author djm;	state Exp;
branches;
next	1.210;

1.210
date	2004.04.18.23.10.26;	author djm;	state Exp;
branches;
next	1.209;

1.209
date	2004.03.11.10.21.17;	author markus;	state Exp;
branches
	1.209.2.1;
next	1.208;

1.208
date	2004.03.10.09.45.06;	author markus;	state Exp;
branches;
next	1.207;

1.207
date	2004.03.09.22.11.05;	author markus;	state Exp;
branches;
next	1.206;

1.206
date	2003.12.16.15.49.51;	author markus;	state Exp;
branches;
next	1.205;

1.205
date	2003.12.09.17.30.05;	author markus;	state Exp;
branches;
next	1.204;

1.204
date	2003.11.24.00.16.35;	author dtucker;	state Exp;
branches;
next	1.203;

1.203
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.202;

1.202
date	2003.10.11.08.24.08;	author markus;	state Exp;
branches;
next	1.201;

1.201
date	2003.09.01.18.15.50;	author markus;	state Exp;
branches
	1.201.2.1;
next	1.200;

1.200
date	2003.08.13.09.07.10;	author markus;	state Exp;
branches;
next	1.199;

1.199
date	2003.08.13.08.46.30;	author markus;	state Exp;
branches;
next	1.198;

1.198
date	2003.07.22.13.35.22;	author markus;	state Exp;
branches;
next	1.197;

1.197
date	2003.07.16.10.34.53;	author markus;	state Exp;
branches;
next	1.196;

1.196
date	2003.07.03.08.09.06;	author djm;	state Exp;
branches;
next	1.195;

1.195
date	2003.07.02.20.37.48;	author markus;	state Exp;
branches;
next	1.194;

1.194
date	2003.06.12.19.12.03;	author markus;	state Exp;
branches;
next	1.193;

1.193
date	2003.05.15.13.52.10;	author djm;	state Exp;
branches;
next	1.192;

1.192
date	2003.05.11.20.30.25;	author markus;	state Exp;
branches;
next	1.191;

1.191
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.190;

1.190
date	2003.02.06.09.27.29;	author markus;	state Exp;
branches
	1.190.2.1;
next	1.189;

1.189
date	2002.12.09.16.50.30;	author millert;	state Exp;
branches;
next	1.188;

1.188
date	2002.11.27.17.53.35;	author markus;	state Exp;
branches;
next	1.187;

1.187
date	2002.11.21.23.04.33;	author markus;	state Exp;
branches;
next	1.186;

1.186
date	2002.09.19.01.58.18;	author djm;	state Exp;
branches
	1.186.2.1;
next	1.185;

1.185
date	2002.09.11.18.27.26;	author stevesk;	state Exp;
branches;
next	1.184;

1.184
date	2002.08.29.19.49.42;	author stevesk;	state Exp;
branches;
next	1.183;

1.183
date	2002.08.29.16.02.54;	author stevesk;	state Exp;
branches;
next	1.182;

1.182
date	2002.07.19.17.42.40;	author stevesk;	state Exp;
branches;
next	1.181;

1.181
date	2002.07.03.14.21.05;	author markus;	state Exp;
branches;
next	1.180;

1.180
date	2002.06.30.21.59.45;	author deraadt;	state Exp;
branches;
next	1.179;

1.179
date	2002.06.12.01.09.52;	author markus;	state Exp;
branches;
next	1.178;

1.178
date	2002.06.11.23.03.54;	author markus;	state Exp;
branches;
next	1.177;

1.177
date	2002.06.11.04.14.26;	author markus;	state Exp;
branches;
next	1.176;

1.176
date	2002.06.08.05.17.01;	author markus;	state Exp;
branches;
next	1.175;

1.175
date	2002.06.08.05.07.56;	author markus;	state Exp;
branches;
next	1.174;

1.174
date	2002.05.23.19.39.34;	author markus;	state Exp;
branches;
next	1.173;

1.173
date	2002.05.23.19.24.30;	author markus;	state Exp;
branches;
next	1.172;

1.172
date	2002.05.22.23.18.25;	author deraadt;	state Exp;
branches;
next	1.171;

1.171
date	2002.05.16.22.09.59;	author stevesk;	state Exp;
branches;
next	1.170;

1.170
date	2002.04.22.21.04.52;	author markus;	state Exp;
branches;
next	1.169;

1.169
date	2002.03.26.11.37.05;	author markus;	state Exp;
branches
	1.169.2.1;
next	1.168;

1.168
date	2002.03.25.21.04.02;	author markus;	state Exp;
branches;
next	1.167;

1.167
date	2002.03.25.17.34.27;	author markus;	state Exp;
branches;
next	1.166;

1.166
date	2002.03.21.22.44.05;	author rees;	state Exp;
branches;
next	1.165;

1.165
date	2002.03.19.10.49.35;	author markus;	state Exp;
branches;
next	1.164;

1.164
date	2002.02.14.23.28.00;	author markus;	state Exp;
branches;
next	1.163;

1.163
date	2002.02.07.09.35.39;	author markus;	state Exp;
branches;
next	1.162;

1.162
date	2002.02.06.14.55.16;	author markus;	state Exp;
branches;
next	1.161;

1.161
date	2002.02.05.14.32.55;	author markus;	state Exp;
branches;
next	1.160;

1.160
date	2002.02.03.17.58.21;	author markus;	state Exp;
branches;
next	1.159;

1.159
date	2002.01.27.18.08.17;	author stevesk;	state Exp;
branches;
next	1.158;

1.158
date	2002.01.16.13.17.51;	author markus;	state Exp;
branches;
next	1.157;

1.157
date	2001.12.28.15.06.00;	author markus;	state Exp;
branches;
next	1.156;

1.156
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.155;

1.155
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.154;

1.154
date	2001.12.27.20.39.58;	author markus;	state Exp;
branches;
next	1.153;

1.153
date	2001.12.20.22.50.24;	author djm;	state Exp;
branches;
next	1.152;

1.152
date	2001.12.19.17.16.13;	author stevesk;	state Exp;
branches;
next	1.151;

1.151
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2001.11.30.20.39.28;	author stevesk;	state Exp;
branches;
next	1.149;

1.149
date	2001.10.24.08.51.35;	author markus;	state Exp;
branches;
next	1.148;

1.148
date	2001.10.24.08.41.20;	author markus;	state Exp;
branches;
next	1.147;

1.147
date	2001.10.08.19.05.05;	author markus;	state Exp;
branches
	1.147.2.1;
next	1.146;

1.146
date	2001.10.01.21.38.53;	author markus;	state Exp;
branches;
next	1.145;

1.145
date	2001.09.28.15.46.29;	author markus;	state Exp;
branches;
next	1.144;

1.144
date	2001.09.24.03.38.58;	author stevesk;	state Exp;
branches;
next	1.143;

1.143
date	2001.09.20.13.50.40;	author markus;	state Exp;
branches;
next	1.142;

1.142
date	2001.09.03.20.58.33;	author stevesk;	state Exp;
branches;
next	1.141;

1.141
date	2001.08.29.23.27.23;	author stevesk;	state Exp;
branches;
next	1.140;

1.140
date	2001.08.29.23.13.10;	author stevesk;	state Exp;
branches;
next	1.139;

1.139
date	2001.08.28.15.39.48;	author markus;	state Exp;
branches;
next	1.138;

1.138
date	2001.08.11.22.51.27;	author jakob;	state Exp;
branches;
next	1.137;

1.137
date	2001.08.02.16.14.05;	author jakob;	state Exp;
branches;
next	1.136;

1.136
date	2001.08.02.15.43.57;	author jakob;	state Exp;
branches;
next	1.135;

1.135
date	2001.08.02.15.32.10;	author jakob;	state Exp;
branches;
next	1.134;

1.134
date	2001.08.01.23.38.45;	author markus;	state Exp;
branches;
next	1.133;

1.133
date	2001.08.01.22.03.33;	author markus;	state Exp;
branches;
next	1.132;

1.132
date	2001.07.31.09.28.44;	author jakob;	state Exp;
branches;
next	1.131;

1.131
date	2001.07.27.14.50.45;	author millert;	state Exp;
branches;
next	1.130;

1.130
date	2001.07.25.14.35.18;	author markus;	state Exp;
branches;
next	1.129;

1.129
date	2001.07.11.16.29.59;	author markus;	state Exp;
branches;
next	1.128;

1.128
date	2001.07.09.05.58.47;	author fgsch;	state Exp;
branches;
next	1.127;

1.127
date	2001.06.26.20.14.11;	author markus;	state Exp;
branches;
next	1.126;

1.126
date	2001.06.23.15.12.21;	author itojun;	state Exp;
branches;
next	1.125;

1.125
date	2001.06.22.23.35.21;	author markus;	state Exp;
branches;
next	1.124;

1.124
date	2001.06.07.20.23.05;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2001.05.31.10.30.17;	author markus;	state Exp;
branches;
next	1.122;

1.122
date	2001.05.30.15.20.10;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2001.05.30.12.55.13;	author markus;	state Exp;
branches;
next	1.120;

1.120
date	2001.05.28.08.04.39;	author markus;	state Exp;
branches;
next	1.119;

1.119
date	2001.05.24.18.57.53;	author stevesk;	state Exp;
branches;
next	1.118;

1.118
date	2001.05.04.23.47.34;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2001.04.30.11.18.52;	author markus;	state Exp;
branches;
next	1.116;

1.116
date	2001.04.17.12.55.04;	author markus;	state Exp;
branches
	1.116.2.1;
next	1.115;

1.115
date	2001.04.14.16.33.20;	author stevesk;	state Exp;
branches;
next	1.114;

1.114
date	2001.04.13.01.26.17;	author stevesk;	state Exp;
branches;
next	1.113;

1.113
date	2001.04.12.20.09.37;	author stevesk;	state Exp;
branches;
next	1.112;

1.112
date	2001.04.12.19.15.25;	author markus;	state Exp;
branches;
next	1.111;

1.111
date	2001.04.12.14.29.09;	author markus;	state Exp;
branches;
next	1.110;

1.110
date	2001.04.11.13.56.13;	author markus;	state Exp;
branches;
next	1.109;

1.109
date	2001.04.11.10.59.01;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2001.04.07.08.55.18;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2001.04.06.21.00.13;	author markus;	state Exp;
branches;
next	1.106;

1.106
date	2001.04.05.21.05.24;	author markus;	state Exp;
branches;
next	1.105;

1.105
date	2001.03.26.08.07.09;	author markus;	state Exp;
branches;
next	1.104;

1.104
date	2001.03.08.21.42.32;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2001.03.04.17.42.28;	author millert;	state Exp;
branches;
next	1.102;

1.102
date	2001.03.04.10.57.53;	author stevesk;	state Exp;
branches;
next	1.101;

1.101
date	2001.03.03.23.59.34;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2001.03.01.22.46.37;	author markus;	state Exp;
branches;
next	1.99;

1.99
date	2001.03.01.02.29.04;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2001.02.22.21.59.44;	author markus;	state Exp;
branches;
next	1.97;

1.97
date	2001.02.21.21.14.04;	author stevesk;	state Exp;
branches;
next	1.96;

1.96
date	2001.02.17.23.28.58;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2001.02.11.12.59.25;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2001.02.10.01.46.28;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2001.02.08.19.30.52;	author itojun;	state Exp;
branches;
next	1.92;

1.92
date	2001.02.06.23.06.21;	author jakob;	state Exp;
branches;
next	1.91;

1.91
date	2001.02.06.23.03.24;	author jakob;	state Exp;
branches;
next	1.90;

1.90
date	2001.02.06.22.43.02;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2001.02.06.22.07.42;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2001.02.04.15.32.26;	author stevesk;	state Exp;
branches;
next	1.87;

1.87
date	2001.02.04.15.14.14;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2001.01.31.20.37.23;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2001.01.29.12.36.10;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2001.01.21.19.05.58;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2001.01.15.21.40.10;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2001.01.13.19.14.09;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.01.13.18.32.50;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2000.12.27.11.51.54;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2000.12.12.23.11.48;	author markus;	state Exp;
branches;
next	1.76;

1.76
date	2000.12.12.22.30.01;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2000.11.30.07.02.35;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2000.11.23.21.03.47;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2000.11.15.19.58.08;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2000.11.06.23.13.26;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2000.11.06.23.04.56;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2000.10.27.07.32.19;	author markus;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2000.10.11.20.27.24;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2000.10.03.18.16.47;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2000.09.12.20.53.10;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2000.09.07.20.40.30;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2000.09.07.20.27.54;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2000.08.28.20.19.52;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2000.08.28.19.51.00;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2000.08.20.18.42.40;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2000.08.19.18.48.11;	author markus;	state Exp;
branches;
next	1.59;

1.59
date	2000.08.19.02.07.23;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2000.07.16.08.27.22;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2000.07.15.04.01.37;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2000.06.20.01.39.44;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2000.05.31.06.36.40;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2000.05.30.17.32.06;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2000.05.29.20.20.46;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2000.05.15.06.52.55;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2000.05.08.17.12.15;	author markus;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2000.04.28.08.10.20;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2000.04.26.20.56.30;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2000.04.14.10.11.12;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2000.04.12.07.45.44;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2000.04.04.15.19.42;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2000.03.28.20.31.28;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2000.03.23.21.52.02;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2000.03.22.09.55.10;	author markus;	state Exp;
branches;
next	1.41;

1.41
date	2000.02.28.19.51.58;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2000.02.20.20.05.19;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2000.01.04.13.41.32;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.01.04.09.07.59;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.04.00.08.00;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	99.12.12.19.20.03;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	99.12.01.13.59.15;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	99.11.24.20.15.35;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	99.11.24.19.53.52;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	99.11.23.22.25.55;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	99.11.15.21.05.03;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	99.11.14.21.45.07;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	99.11.11.23.36.53;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	99.11.10.23.36.44;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	99.10.28.21.29.26;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	99.10.26.22.38.51;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	99.10.14.18.17.42;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	99.10.12.21.04.22;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	99.10.03.21.50.04;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	99.09.30.20.39.08;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.09.30.18.28.36;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	99.09.30.14.05.41;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	99.09.30.05.53.04;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.09.30.05.43.33;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.09.30.05.11.29;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.09.30.05.03.05;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.09.30.04.30.03;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.09.30.04.10.28;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.09.29.21.15.54;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.09.29.21.14.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.09.29.18.27.23;	author dugsong;	state Exp;
branches;
next	1.9;

1.9
date	99.09.29.18.16.20;	author dugsong;	state Exp;
branches;
next	1.8;

1.8
date	99.09.29.12.16.35;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	99.09.29.11.45.50;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	99.09.29.06.15.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.06.15.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.00.10.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.28.07.57.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.37;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.38;	author deraadt;	state Exp;
branches;
next	;

1.51.2.1
date	2000.06.12.02.37.36;	author jason;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2000.09.01.18.23.23;	author jason;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2000.11.08.21.31.24;	author jason;	state Exp;
branches;
next	1.51.2.4;

1.51.2.4
date	2001.03.12.15.44.16;	author jason;	state Exp;
branches;
next	1.51.2.5;

1.51.2.5
date	2001.03.21.18.53.13;	author jason;	state Exp;
branches;
next	;

1.69.2.1
date	2001.02.16.20.13.20;	author jason;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2001.02.19.17.19.33;	author jason;	state Exp;
branches;
next	1.69.2.3;

1.69.2.3
date	2001.03.21.19.46.30;	author jason;	state Exp;
branches;
next	1.69.2.4;

1.69.2.4
date	2001.05.07.21.09.36;	author jason;	state Exp;
branches;
next	1.69.2.5;

1.69.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.69.2.6;

1.69.2.6
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.69.2.7;

1.69.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.69.2.8;

1.69.2.8
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.116.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.116.2.2;

1.116.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.116.2.3;

1.116.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.116.2.4;

1.116.2.4
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.116.2.5;

1.116.2.5
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.147.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.147.2.2;

1.147.2.2
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.147.2.3;

1.147.2.3
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.147.2.4;

1.147.2.4
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.147.2.5;

1.147.2.5
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.169.2.1
date	2002.05.18.04.12.11;	author jason;	state Exp;
branches;
next	1.169.2.2;

1.169.2.2
date	2002.05.18.04.50.38;	author jason;	state Exp;
branches;
next	1.169.2.3;

1.169.2.3
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.169.2.4;

1.169.2.4
date	2002.10.11.14.51.53;	author miod;	state Exp;
branches;
next	1.169.2.5;

1.169.2.5
date	2003.04.03.22.35.18;	author miod;	state Exp;
branches;
next	;

1.186.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.186.2.2;

1.186.2.2
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.190.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.190.2.2;

1.190.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.201.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.201.2.2;

1.201.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.209.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.209.2.2;

1.209.2.2
date	2005.03.10.17.15.05;	author brad;	state Exp;
branches;
next	;

1.226.2.1
date	2005.03.10.16.28.28;	author brad;	state Exp;
branches;
next	1.226.2.2;

1.226.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.226.2.3;

1.226.2.3
date	2005.09.02.03.45.01;	author brad;	state Exp;
branches;
next	;

1.234.2.1
date	2005.09.04.18.40.10;	author brad;	state Exp;
branches;
next	1.234.2.2;

1.234.2.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.249.2.1
date	2006.02.03.03.01.58;	author brad;	state Exp;
branches;
next	1.249.2.2;

1.249.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.249.2.3;

1.249.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.265.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.265.2.2;

1.265.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.293.4.1
date	2006.11.08.00.42.11;	author brad;	state Exp;
branches;
next	;

1.416.2.1
date	2016.01.14.11.53.20;	author sthen;	state Exp;
branches;
next	1.416.2.2;
commitid	T6tcqH9MXVck1Xkf;

1.416.2.2
date	2016.01.14.14.48.36;	author sthen;	state Exp;
branches;
next	;
commitid	gQA5KCdbB521AiGx;

1.420.2.1
date	2016.01.14.11.50.37;	author sthen;	state Exp;
branches;
next	1.420.2.2;
commitid	kuomKbPjnfGwrKrZ;

1.420.2.2
date	2016.01.14.14.48.18;	author sthen;	state Exp;
branches;
next	;
commitid	A7IQpw6n5l3sEY5z;


desc
@@


1.452
log
@Add SyslogFacility option to ssh(1) matching the equivalent option in
sshd(8).  bz#2705, patch from erahn at arista.com, ok djm@@
@
text
@/* $OpenBSD: ssh.c,v 1.451 2017/03/10 04:07:20 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Ssh client program.  This program can be used to log into a remote machine.
 * The software supports strong authentication, encryption, and forwarding
 * of X11, TCP/IP, and authentication connections.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 2000, 2001, 2002, 2003 Markus Friedl.  All rights reserved.
 *
 * Modified to work with SSL by Niels Provos <provos@@citi.umich.edu>
 * in Canada (German citizen).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <locale.h>

#ifdef WITH_OPENSSL
#include <openssl/evp.h>
#include <openssl/err.h>
#endif

#include "xmalloc.h"
#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
#include "canohost.h"
#include "compat.h"
#include "cipher.h"
#include "digest.h"
#include "packet.h"
#include "buffer.h"
#include "channels.h"
#include "key.h"
#include "authfd.h"
#include "authfile.h"
#include "pathnames.h"
#include "dispatch.h"
#include "clientloop.h"
#include "log.h"
#include "misc.h"
#include "readconf.h"
#include "sshconnect.h"
#include "kex.h"
#include "mac.h"
#include "sshpty.h"
#include "match.h"
#include "msg.h"
#include "uidswap.h"
#include "version.h"
#include "ssherr.h"
#include "myproposal.h"

#ifdef ENABLE_PKCS11
#include "ssh-pkcs11.h"
#endif

extern char *__progname;

/* Flag indicating whether debug mode is on.  May be set on the command line. */
int debug_flag = 0;

/* Flag indicating whether a tty should be requested */
int tty_flag = 0;

/* don't exec a shell */
int no_shell_flag = 0;

/*
 * Flag indicating that nothing should be read from stdin.  This can be set
 * on the command line.
 */
int stdin_null_flag = 0;

/*
 * Flag indicating that the current process should be backgrounded and
 * a new slave launched in the foreground for ControlPersist.
 */
int need_controlpersist_detach = 0;

/* Copies of flags for ControlPersist foreground slave */
int ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;

/*
 * Flag indicating that ssh should fork after authentication.  This is useful
 * so that the passphrase can be entered manually, and then ssh goes to the
 * background.
 */
int fork_after_authentication_flag = 0;

/*
 * General data structure for command line options and options configurable
 * in configuration files.  See readconf.h.
 */
Options options;

/* optional user configfile */
char *config = NULL;

/*
 * Name of the host we are connecting to.  This is the name given on the
 * command line, or the HostName specified for the user-supplied name in a
 * configuration file.
 */
char *host;

/* socket address the host resolves to */
struct sockaddr_storage hostaddr;

/* Private host keys. */
Sensitive sensitive_data;

/* Original real UID. */
uid_t original_real_uid;
uid_t original_effective_uid;

/* command to be executed */
Buffer command;

/* Should we execute a command or invoke a subsystem? */
int subsystem_flag = 0;

/* # of replies received for global requests */
static int remote_forward_confirms_received = 0;

/* mux.c */
extern int muxserver_sock;
extern u_int muxclient_command;

/* Prints a help message to the user.  This function never returns. */

static void
usage(void)
{
	fprintf(stderr,
"usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n"
"           [-D [bind_address:]port] [-E log_file] [-e escape_char]\n"
"           [-F configfile] [-I pkcs11] [-i identity_file]\n"
"           [-J [user@@]host[:port]] [-L address] [-l login_name] [-m mac_spec]\n"
"           [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]\n"
"           [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]\n"
"           [user@@]hostname [command]\n"
	);
	exit(255);
}

static int ssh_session(void);
static int ssh_session2(void);
static void load_public_identity_files(void);
static void main_sigchld_handler(int);

/* ~/ expand a list of paths. NB. assumes path[n] is heap-allocated. */
static void
tilde_expand_paths(char **paths, u_int num_paths)
{
	u_int i;
	char *cp;

	for (i = 0; i < num_paths; i++) {
		cp = tilde_expand_filename(paths[i], original_real_uid);
		free(paths[i]);
		paths[i] = cp;
	}
}

/*
 * Attempt to resolve a host name / port to a set of addresses and
 * optionally return any CNAMEs encountered along the way.
 * Returns NULL on failure.
 * NB. this function must operate with a options having undefined members.
 */
static struct addrinfo *
resolve_host(const char *name, int port, int logerr, char *cname, size_t clen)
{
	char strport[NI_MAXSERV];
	struct addrinfo hints, *res;
	int gaierr, loglevel = SYSLOG_LEVEL_DEBUG1;

	if (port <= 0)
		port = default_ssh_port();

	snprintf(strport, sizeof strport, "%d", port);
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = options.address_family == -1 ?
	    AF_UNSPEC : options.address_family;
	hints.ai_socktype = SOCK_STREAM;
	if (cname != NULL)
		hints.ai_flags = AI_CANONNAME;
	if ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {
		if (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))
			loglevel = SYSLOG_LEVEL_ERROR;
		do_log2(loglevel, "%s: Could not resolve hostname %.100s: %s",
		    __progname, name, ssh_gai_strerror(gaierr));
		return NULL;
	}
	if (cname != NULL && res->ai_canonname != NULL) {
		if (strlcpy(cname, res->ai_canonname, clen) >= clen) {
			error("%s: host \"%s\" cname \"%s\" too long (max %lu)",
			    __func__, name,  res->ai_canonname, (u_long)clen);
			if (clen > 0)
				*cname = '\0';
		}
	}
	return res;
}

/*
 * Attempt to resolve a numeric host address / port to a single address.
 * Returns a canonical address string.
 * Returns NULL on failure.
 * NB. this function must operate with a options having undefined members.
 */
static struct addrinfo *
resolve_addr(const char *name, int port, char *caddr, size_t clen)
{
	char addr[NI_MAXHOST], strport[NI_MAXSERV];
	struct addrinfo hints, *res;
	int gaierr;

	if (port <= 0)
		port = default_ssh_port();
	snprintf(strport, sizeof strport, "%u", port);
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = options.address_family == -1 ?
	    AF_UNSPEC : options.address_family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;
	if ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {
		debug2("%s: could not resolve name %.100s as address: %s",
		    __func__, name, ssh_gai_strerror(gaierr));
		return NULL;
	}
	if (res == NULL) {
		debug("%s: getaddrinfo %.100s returned no addresses",
		 __func__, name);
		return NULL;
	}
	if (res->ai_next != NULL) {
		debug("%s: getaddrinfo %.100s returned multiple addresses",
		    __func__, name);
		goto fail;
	}
	if ((gaierr = getnameinfo(res->ai_addr, res->ai_addrlen,
	    addr, sizeof(addr), NULL, 0, NI_NUMERICHOST)) != 0) {
		debug("%s: Could not format address for name %.100s: %s",
		    __func__, name, ssh_gai_strerror(gaierr));
		goto fail;
	}
	if (strlcpy(caddr, addr, clen) >= clen) {
		error("%s: host \"%s\" addr \"%s\" too long (max %lu)",
		    __func__, name,  addr, (u_long)clen);
		if (clen > 0)
			*caddr = '\0';
 fail:
		freeaddrinfo(res);
		return NULL;
	}
	return res;
}

/*
 * Check whether the cname is a permitted replacement for the hostname
 * and perform the replacement if it is.
 * NB. this function must operate with a options having undefined members.
 */
static int
check_follow_cname(int direct, char **namep, const char *cname)
{
	int i;
	struct allowed_cname *rule;

	if (*cname == '\0' || options.num_permitted_cnames == 0 ||
	    strcmp(*namep, cname) == 0)
		return 0;
	if (options.canonicalize_hostname == SSH_CANONICALISE_NO)
		return 0;
	/*
	 * Don't attempt to canonicalize names that will be interpreted by
	 * a proxy or jump host unless the user specifically requests so.
	 */
	if (!direct &&
	    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)
		return 0;
	debug3("%s: check \"%s\" CNAME \"%s\"", __func__, *namep, cname);
	for (i = 0; i < options.num_permitted_cnames; i++) {
		rule = options.permitted_cnames + i;
		if (match_pattern_list(*namep, rule->source_list, 1) != 1 ||
		    match_pattern_list(cname, rule->target_list, 1) != 1)
			continue;
		verbose("Canonicalized DNS aliased hostname "
		    "\"%s\" => \"%s\"", *namep, cname);
		free(*namep);
		*namep = xstrdup(cname);
		return 1;
	}
	return 0;
}

/*
 * Attempt to resolve the supplied hostname after applying the user's
 * canonicalization rules. Returns the address list for the host or NULL
 * if no name was found after canonicalization.
 * NB. this function must operate with a options having undefined members.
 */
static struct addrinfo *
resolve_canonicalize(char **hostp, int port)
{
	int i, direct, ndots;
	char *cp, *fullhost, newname[NI_MAXHOST];
	struct addrinfo *addrs;

	if (options.canonicalize_hostname == SSH_CANONICALISE_NO)
		return NULL;

	/*
	 * Don't attempt to canonicalize names that will be interpreted by
	 * a proxy unless the user specifically requests so.
	 */
	direct = option_clear_or_none(options.proxy_command) &&
	    options.jump_host == NULL;
	if (!direct &&
	    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)
		return NULL;

	/* Try numeric hostnames first */
	if ((addrs = resolve_addr(*hostp, port,
	    newname, sizeof(newname))) != NULL) {
		debug2("%s: hostname %.100s is address", __func__, *hostp);
		if (strcasecmp(*hostp, newname) != 0) {
			debug2("%s: canonicalised address \"%s\" => \"%s\"",
			    __func__, *hostp, newname);
			free(*hostp);
			*hostp = xstrdup(newname);
		}
		return addrs;
	}

	/* If domain name is anchored, then resolve it now */
	if ((*hostp)[strlen(*hostp) - 1] == '.') {
		debug3("%s: name is fully qualified", __func__);
		fullhost = xstrdup(*hostp);
		if ((addrs = resolve_host(fullhost, port, 0,
		    newname, sizeof(newname))) != NULL)
			goto found;
		free(fullhost);
		goto notfound;
	}

	/* Don't apply canonicalization to sufficiently-qualified hostnames */
	ndots = 0;
	for (cp = *hostp; *cp != '\0'; cp++) {
		if (*cp == '.')
			ndots++;
	}
	if (ndots > options.canonicalize_max_dots) {
		debug3("%s: not canonicalizing hostname \"%s\" (max dots %d)",
		    __func__, *hostp, options.canonicalize_max_dots);
		return NULL;
	}
	/* Attempt each supplied suffix */
	for (i = 0; i < options.num_canonical_domains; i++) {
		*newname = '\0';
		xasprintf(&fullhost, "%s.%s.", *hostp,
		    options.canonical_domains[i]);
		debug3("%s: attempting \"%s\" => \"%s\"", __func__,
		    *hostp, fullhost);
		if ((addrs = resolve_host(fullhost, port, 0,
		    newname, sizeof(newname))) == NULL) {
			free(fullhost);
			continue;
		}
 found:
		/* Remove trailing '.' */
		fullhost[strlen(fullhost) - 1] = '\0';
		/* Follow CNAME if requested */
		if (!check_follow_cname(direct, &fullhost, newname)) {
			debug("Canonicalized hostname \"%s\" => \"%s\"",
			    *hostp, fullhost);
		}
		free(*hostp);
		*hostp = fullhost;
		return addrs;
	}
 notfound:
	if (!options.canonicalize_fallback_local)
		fatal("%s: Could not resolve host \"%s\"", __progname, *hostp);
	debug2("%s: host %s not found in any suffix", __func__, *hostp);
	return NULL;
}

/*
 * Read per-user configuration file.  Ignore the system wide config
 * file if the user specifies a config file on the command line.
 */
static void
process_config_files(const char *host_arg, struct passwd *pw, int post_canon)
{
	char buf[PATH_MAX];
	int r;

	if (config != NULL) {
		if (strcasecmp(config, "none") != 0 &&
		    !read_config_file(config, pw, host, host_arg, &options,
		    SSHCONF_USERCONF | (post_canon ? SSHCONF_POSTCANON : 0)))
			fatal("Can't open user config file %.100s: "
			    "%.100s", config, strerror(errno));
	} else {
		r = snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir,
		    _PATH_SSH_USER_CONFFILE);
		if (r > 0 && (size_t)r < sizeof(buf))
			(void)read_config_file(buf, pw, host, host_arg,
			    &options, SSHCONF_CHECKPERM | SSHCONF_USERCONF |
			    (post_canon ? SSHCONF_POSTCANON : 0));

		/* Read systemwide configuration file after user config. */
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,
		    host, host_arg, &options,
		    post_canon ? SSHCONF_POSTCANON : 0);
	}
}

/* Rewrite the port number in an addrinfo list of addresses */
static void
set_addrinfo_port(struct addrinfo *addrs, int port)
{
	struct addrinfo *addr;

	for (addr = addrs; addr != NULL; addr = addr->ai_next) {
		switch (addr->ai_family) {
		case AF_INET:
			((struct sockaddr_in *)addr->ai_addr)->
			    sin_port = htons(port);
			break;
		case AF_INET6:
			((struct sockaddr_in6 *)addr->ai_addr)->
			    sin6_port = htons(port);
			break;
		}
	}
}

/*
 * Main program for the ssh client.
 */
int
main(int ac, char **av)
{
	struct ssh *ssh = NULL;
	int i, r, opt, exit_status, use_syslog, direct, config_test = 0;
	char *p, *cp, *line, *argv0, buf[PATH_MAX], *host_arg, *logfile;
	char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];
	char cname[NI_MAXHOST], uidstr[32], *conn_hash_hex;
	struct stat st;
	struct passwd *pw;
	int timeout_ms;
	extern int optind, optreset;
	extern char *optarg;
	struct Forward fwd;
	struct addrinfo *addrs = NULL;
	struct ssh_digest_ctx *md;
	u_char conn_hash[SSH_DIGEST_MAX_LENGTH];

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/*
	 * Discard other fds that are hanging around. These can cause problem
	 * with backgrounded ssh processes started by ControlPersist.
	 */
	closefrom(STDERR_FILENO + 1);

	/*
	 * Save the original real uid.  It will be needed later (uid-swapping
	 * may clobber the real uid).
	 */
	original_real_uid = getuid();
	original_effective_uid = geteuid();

	/*
	 * Use uid-swapping to give up root privileges for the duration of
	 * option processing.  We will re-instantiate the rights when we are
	 * ready to create the privileged port, and will permanently drop
	 * them when the port has been created (actually, when the connection
	 * has been made, as we may need to create the port several times).
	 */
	PRIV_END;

	/* If we are installed setuid root be careful to not drop core. */
	if (original_real_uid != original_effective_uid) {
		struct rlimit rlim;
		rlim.rlim_cur = rlim.rlim_max = 0;
		if (setrlimit(RLIMIT_CORE, &rlim) < 0)
			fatal("setrlimit failed: %.100s", strerror(errno));
	}
	/* Get user data. */
	pw = getpwuid(original_real_uid);
	if (!pw) {
		logit("No user exists for uid %lu", (u_long)original_real_uid);
		exit(255);
	}
	/* Take a copy of the returned structure. */
	pw = pwcopy(pw);

	/*
	 * Set our umask to something reasonable, as some files are created
	 * with the default umask.  This will make them world-readable but
	 * writable only by the owner, which is ok for all files for which we
	 * don't set the modes explicitly.
	 */
	umask(022);

	setlocale(LC_CTYPE, "");

	/*
	 * Initialize option structure to indicate that no values have been
	 * set.
	 */
	initialize_options(&options);

	/* Parse command-line arguments. */
	host = NULL;
	use_syslog = 0;
	logfile = NULL;
	argv0 = av[0];

 again:
	while ((opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvx"
	    "ACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy")) != -1) {
		switch (opt) {
		case '1':
			options.protocol = SSH_PROTO_1;
			break;
		case '2':
			options.protocol = SSH_PROTO_2;
			break;
		case '4':
			options.address_family = AF_INET;
			break;
		case '6':
			options.address_family = AF_INET6;
			break;
		case 'n':
			stdin_null_flag = 1;
			break;
		case 'f':
			fork_after_authentication_flag = 1;
			stdin_null_flag = 1;
			break;
		case 'x':
			options.forward_x11 = 0;
			break;
		case 'X':
			options.forward_x11 = 1;
			break;
		case 'y':
			use_syslog = 1;
			break;
		case 'E':
			logfile = optarg;
			break;
		case 'G':
			config_test = 1;
			break;
		case 'Y':
			options.forward_x11 = 1;
			options.forward_x11_trusted = 1;
			break;
		case 'g':
			options.fwd_opts.gateway_ports = 1;
			break;
		case 'O':
			if (options.stdio_forward_host != NULL)
				fatal("Cannot specify multiplexing "
				    "command with -W");
			else if (muxclient_command != 0)
				fatal("Multiplexing command already specified");
			if (strcmp(optarg, "check") == 0)
				muxclient_command = SSHMUX_COMMAND_ALIVE_CHECK;
			else if (strcmp(optarg, "forward") == 0)
				muxclient_command = SSHMUX_COMMAND_FORWARD;
			else if (strcmp(optarg, "exit") == 0)
				muxclient_command = SSHMUX_COMMAND_TERMINATE;
			else if (strcmp(optarg, "stop") == 0)
				muxclient_command = SSHMUX_COMMAND_STOP;
			else if (strcmp(optarg, "cancel") == 0)
				muxclient_command = SSHMUX_COMMAND_CANCEL_FWD;
			else if (strcmp(optarg, "proxy") == 0)
				muxclient_command = SSHMUX_COMMAND_PROXY;
			else
				fatal("Invalid multiplex command.");
			break;
		case 'P':	/* deprecated */
			options.use_privileged_port = 0;
			break;
		case 'Q':
			cp = NULL;
			if (strcmp(optarg, "cipher") == 0)
				cp = cipher_alg_list('\n', 0);
			else if (strcmp(optarg, "cipher-auth") == 0)
				cp = cipher_alg_list('\n', 1);
			else if (strcmp(optarg, "mac") == 0)
				cp = mac_alg_list('\n');
			else if (strcmp(optarg, "kex") == 0)
				cp = kex_alg_list('\n');
			else if (strcmp(optarg, "key") == 0)
				cp = sshkey_alg_list(0, 0, 0, '\n');
			else if (strcmp(optarg, "key-cert") == 0)
				cp = sshkey_alg_list(1, 0, 0, '\n');
			else if (strcmp(optarg, "key-plain") == 0)
				cp = sshkey_alg_list(0, 1, 0, '\n');
			else if (strcmp(optarg, "protocol-version") == 0) {
#ifdef WITH_SSH1
				cp = xstrdup("1\n2");
#else
				cp = xstrdup("2");
#endif
			}
			if (cp == NULL)
				fatal("Unsupported query \"%s\"", optarg);
			printf("%s\n", cp);
			free(cp);
			exit(0);
			break;
		case 'a':
			options.forward_agent = 0;
			break;
		case 'A':
			options.forward_agent = 1;
			break;
		case 'k':
			options.gss_deleg_creds = 0;
			break;
		case 'K':
			options.gss_authentication = 1;
			options.gss_deleg_creds = 1;
			break;
		case 'i':
			p = tilde_expand_filename(optarg, original_real_uid);
			if (stat(p, &st) < 0)
				fprintf(stderr, "Warning: Identity file %s "
				    "not accessible: %s.\n", p,
				    strerror(errno));
			else
				add_identity_file(&options, NULL, p, 1);
			free(p);
			break;
		case 'I':
#ifdef ENABLE_PKCS11
			free(options.pkcs11_provider);
			options.pkcs11_provider = xstrdup(optarg);
#else
			fprintf(stderr, "no support for PKCS#11.\n");
#endif
			break;
		case 'J':
			if (options.jump_host != NULL)
				fatal("Only a single -J option permitted");
			if (options.proxy_command != NULL)
				fatal("Cannot specify -J with ProxyCommand");
			if (parse_jump(optarg, &options, 1) == -1)
				fatal("Invalid -J argument");
			options.proxy_command = xstrdup("none");
			break;
		case 't':
			if (options.request_tty == REQUEST_TTY_YES)
				options.request_tty = REQUEST_TTY_FORCE;
			else
				options.request_tty = REQUEST_TTY_YES;
			break;
		case 'v':
			if (debug_flag == 0) {
				debug_flag = 1;
				options.log_level = SYSLOG_LEVEL_DEBUG1;
			} else {
				if (options.log_level < SYSLOG_LEVEL_DEBUG3) {
					debug_flag++;
					options.log_level++;
				}
			}
			break;
		case 'V':
			fprintf(stderr, "%s, %s\n",
			    SSH_VERSION,
#ifdef WITH_OPENSSL
			    SSLeay_version(SSLEAY_VERSION)
#else
			    "without OpenSSL"
#endif
			);
			if (opt == 'V')
				exit(0);
			break;
		case 'w':
			if (options.tun_open == -1)
				options.tun_open = SSH_TUNMODE_DEFAULT;
			options.tun_local = a2tun(optarg, &options.tun_remote);
			if (options.tun_local == SSH_TUNID_ERR) {
				fprintf(stderr,
				    "Bad tun device '%s'\n", optarg);
				exit(255);
			}
			break;
		case 'W':
			if (options.stdio_forward_host != NULL)
				fatal("stdio forward already specified");
			if (muxclient_command != 0)
				fatal("Cannot specify stdio forward with -O");
			if (parse_forward(&fwd, optarg, 1, 0)) {
				options.stdio_forward_host = fwd.listen_host;
				options.stdio_forward_port = fwd.listen_port;
				free(fwd.connect_host);
			} else {
				fprintf(stderr,
				    "Bad stdio forwarding specification '%s'\n",
				    optarg);
				exit(255);
			}
			options.request_tty = REQUEST_TTY_NO;
			no_shell_flag = 1;
			break;
		case 'q':
			options.log_level = SYSLOG_LEVEL_QUIET;
			break;
		case 'e':
			if (optarg[0] == '^' && optarg[2] == 0 &&
			    (u_char) optarg[1] >= 64 &&
			    (u_char) optarg[1] < 128)
				options.escape_char = (u_char) optarg[1] & 31;
			else if (strlen(optarg) == 1)
				options.escape_char = (u_char) optarg[0];
			else if (strcmp(optarg, "none") == 0)
				options.escape_char = SSH_ESCAPECHAR_NONE;
			else {
				fprintf(stderr, "Bad escape character '%s'.\n",
				    optarg);
				exit(255);
			}
			break;
		case 'c':
			if (ciphers_valid(*optarg == '+' ?
			    optarg + 1 : optarg)) {
				/* SSH2 only */
				free(options.ciphers);
				options.ciphers = xstrdup(optarg);
				options.cipher = SSH_CIPHER_INVALID;
				break;
			}
			/* SSH1 only */
			options.cipher = cipher_number(optarg);
			if (options.cipher == -1) {
				fprintf(stderr, "Unknown cipher type '%s'\n",
				    optarg);
				exit(255);
			}
			if (options.cipher == SSH_CIPHER_3DES)
				options.ciphers = xstrdup("3des-cbc");
			else if (options.cipher == SSH_CIPHER_BLOWFISH)
				options.ciphers = xstrdup("blowfish-cbc");
			else
				options.ciphers = xstrdup(KEX_CLIENT_ENCRYPT);
			break;
		case 'm':
			if (mac_valid(optarg)) {
				free(options.macs);
				options.macs = xstrdup(optarg);
			} else {
				fprintf(stderr, "Unknown mac type '%s'\n",
				    optarg);
				exit(255);
			}
			break;
		case 'M':
			if (options.control_master == SSHCTL_MASTER_YES)
				options.control_master = SSHCTL_MASTER_ASK;
			else
				options.control_master = SSHCTL_MASTER_YES;
			break;
		case 'p':
			options.port = a2port(optarg);
			if (options.port <= 0) {
				fprintf(stderr, "Bad port '%s'\n", optarg);
				exit(255);
			}
			break;
		case 'l':
			options.user = optarg;
			break;

		case 'L':
			if (parse_forward(&fwd, optarg, 0, 0))
				add_local_forward(&options, &fwd);
			else {
				fprintf(stderr,
				    "Bad local forwarding specification '%s'\n",
				    optarg);
				exit(255);
			}
			break;

		case 'R':
			if (parse_forward(&fwd, optarg, 0, 1)) {
				add_remote_forward(&options, &fwd);
			} else {
				fprintf(stderr,
				    "Bad remote forwarding specification "
				    "'%s'\n", optarg);
				exit(255);
			}
			break;

		case 'D':
			if (parse_forward(&fwd, optarg, 1, 0)) {
				add_local_forward(&options, &fwd);
			} else {
				fprintf(stderr,
				    "Bad dynamic forwarding specification "
				    "'%s'\n", optarg);
				exit(255);
			}
			break;

		case 'C':
			options.compression = 1;
			break;
		case 'N':
			no_shell_flag = 1;
			options.request_tty = REQUEST_TTY_NO;
			break;
		case 'T':
			options.request_tty = REQUEST_TTY_NO;
			break;
		case 'o':
			line = xstrdup(optarg);
			if (process_config_line(&options, pw,
			    host ? host : "", host ? host : "", line,
			    "command-line", 0, NULL, SSHCONF_USERCONF) != 0)
				exit(255);
			free(line);
			break;
		case 's':
			subsystem_flag = 1;
			break;
		case 'S':
			free(options.control_path);
			options.control_path = xstrdup(optarg);
			break;
		case 'b':
			options.bind_address = optarg;
			break;
		case 'F':
			config = optarg;
			break;
		default:
			usage();
		}
	}

	ac -= optind;
	av += optind;

	if (ac > 0 && !host) {
		if (strrchr(*av, '@@')) {
			p = xstrdup(*av);
			cp = strrchr(p, '@@');
			if (cp == NULL || cp == p)
				usage();
			options.user = p;
			*cp = '\0';
			host = xstrdup(++cp);
		} else
			host = xstrdup(*av);
		if (ac > 1) {
			optind = optreset = 1;
			goto again;
		}
		ac--, av++;
	}

	/* Check that we got a host name. */
	if (!host)
		usage();

	host_arg = xstrdup(host);

#ifdef WITH_OPENSSL
	OpenSSL_add_all_algorithms();
	ERR_load_crypto_strings();
#endif

	/* Initialize the command to execute on remote host. */
	buffer_init(&command);

	/*
	 * Save the command to execute on the remote host in a buffer. There
	 * is no limit on the length of the command, except by the maximum
	 * packet size.  Also sets the tty flag if there is no command.
	 */
	if (!ac) {
		/* No command specified - execute shell on a tty. */
		if (subsystem_flag) {
			fprintf(stderr,
			    "You must specify a subsystem to invoke.\n");
			usage();
		}
	} else {
		/* A command has been specified.  Store it into the buffer. */
		for (i = 0; i < ac; i++) {
			if (i)
				buffer_append(&command, " ", 1);
			buffer_append(&command, av[i], strlen(av[i]));
		}
	}

	/* Cannot fork to background if no command. */
	if (fork_after_authentication_flag && buffer_len(&command) == 0 &&
	    !no_shell_flag)
		fatal("Cannot fork into background without a command "
		    "to execute.");

	/*
	 * Initialize "log" output.  Since we are the client all output
	 * goes to stderr unless otherwise specified by -y or -E.
	 */
	if (use_syslog && logfile != NULL)
		fatal("Can't specify both -y and -E");
	if (logfile != NULL)
		log_redirect_stderr_to(logfile);
	log_init(argv0,
	    options.log_level == SYSLOG_LEVEL_NOT_SET ? 
	    SYSLOG_LEVEL_INFO : options.log_level,
	    options.log_facility == SYSLOG_FACILITY_NOT_SET ? 
	    SYSLOG_FACILITY_USER : options.log_facility,
	    !use_syslog);

	if (debug_flag)
		logit("%s, %s", SSH_VERSION,
#ifdef WITH_OPENSSL
		    SSLeay_version(SSLEAY_VERSION)
#else
		    "without OpenSSL"
#endif
		);

	/* Parse the configuration files */
	process_config_files(host_arg, pw, 0);

	/* Hostname canonicalisation needs a few options filled. */
	fill_default_options_for_canonicalization(&options);

	/* If the user has replaced the hostname then take it into use now */
	if (options.hostname != NULL) {
		/* NB. Please keep in sync with readconf.c:match_cfg_line() */
		cp = percent_expand(options.hostname,
		    "h", host, (char *)NULL);
		free(host);
		host = cp;
		free(options.hostname);
		options.hostname = xstrdup(host);
	}

	/* If canonicalization requested then try to apply it */
	lowercase(host);
	if (options.canonicalize_hostname != SSH_CANONICALISE_NO)
		addrs = resolve_canonicalize(&host, options.port);

	/*
	 * If CanonicalizePermittedCNAMEs have been specified but
	 * other canonicalization did not happen (by not being requested
	 * or by failing with fallback) then the hostname may still be changed
	 * as a result of CNAME following. 
	 *
	 * Try to resolve the bare hostname name using the system resolver's
	 * usual search rules and then apply the CNAME follow rules.
	 *
	 * Skip the lookup if a ProxyCommand is being used unless the user
	 * has specifically requested canonicalisation for this case via
	 * CanonicalizeHostname=always
	 */
	direct = option_clear_or_none(options.proxy_command) &&
	    options.jump_host == NULL;
	if (addrs == NULL && options.num_permitted_cnames != 0 && (direct ||
	    options.canonicalize_hostname == SSH_CANONICALISE_ALWAYS)) {
		if ((addrs = resolve_host(host, options.port,
		    option_clear_or_none(options.proxy_command),
		    cname, sizeof(cname))) == NULL) {
			/* Don't fatal proxied host names not in the DNS */
			if (option_clear_or_none(options.proxy_command))
				cleanup_exit(255); /* logged in resolve_host */
		} else
			check_follow_cname(direct, &host, cname);
	}

	/*
	 * If canonicalisation is enabled then re-parse the configuration
	 * files as new stanzas may match.
	 */
	if (options.canonicalize_hostname != 0) {
		debug("Re-reading configuration after hostname "
		    "canonicalisation");
		free(options.hostname);
		options.hostname = xstrdup(host);
		process_config_files(host_arg, pw, 1);
		/*
		 * Address resolution happens early with canonicalisation
		 * enabled and the port number may have changed since, so
		 * reset it in address list
		 */
		if (addrs != NULL && options.port > 0)
			set_addrinfo_port(addrs, options.port);
	}

	/* Fill configuration defaults. */
	fill_default_options(&options);

	/*
	 * If ProxyJump option specified, then construct a ProxyCommand now.
	 */
	if (options.jump_host != NULL) {
		char port_s[8];

		/* Consistency check */
		if (options.proxy_command != NULL)
			fatal("inconsistent options: ProxyCommand+ProxyJump");
		/* Never use FD passing for ProxyJump */
		options.proxy_use_fdpass = 0;
		snprintf(port_s, sizeof(port_s), "%d", options.jump_port);
		xasprintf(&options.proxy_command,
		    "ssh%s%s%s%s%s%s%s%s%s%.*s -W '[%%h]:%%p' %s",
		    /* Optional "-l user" argument if jump_user set */
		    options.jump_user == NULL ? "" : " -l ",
		    options.jump_user == NULL ? "" : options.jump_user,
		    /* Optional "-p port" argument if jump_port set */
		    options.jump_port <= 0 ? "" : " -p ",
		    options.jump_port <= 0 ? "" : port_s,
		    /* Optional additional jump hosts ",..." */
		    options.jump_extra == NULL ? "" : " -J ",
		    options.jump_extra == NULL ? "" : options.jump_extra,
		    /* Optional "-F" argumment if -F specified */
		    config == NULL ? "" : " -F ",
		    config == NULL ? "" : config,
		    /* Optional "-v" arguments if -v set */
		    debug_flag ? " -" : "",
		    debug_flag, "vvv",
		    /* Mandatory hostname */
		    options.jump_host);
		debug("Setting implicit ProxyCommand from ProxyJump: %s",
		    options.proxy_command);
	}

	if (options.port == 0)
		options.port = default_ssh_port();
	channel_set_af(options.address_family);

	/* Tidy and check options */
	if (options.host_key_alias != NULL)
		lowercase(options.host_key_alias);
	if (options.proxy_command != NULL &&
	    strcmp(options.proxy_command, "-") == 0 &&
	    options.proxy_use_fdpass)
		fatal("ProxyCommand=- and ProxyUseFDPass are incompatible");
	if (options.control_persist &&
	    options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {
		debug("UpdateHostKeys=ask is incompatible with ControlPersist; "
		    "disabling");
		options.update_hostkeys = 0;
	}
	if (options.connection_attempts <= 0)
		fatal("Invalid number of ConnectionAttempts");

	if (original_effective_uid != 0)
		options.use_privileged_port = 0;

	/* reinit */
	log_init(argv0, options.log_level, options.log_facility, !use_syslog);

	if (options.request_tty == REQUEST_TTY_YES ||
	    options.request_tty == REQUEST_TTY_FORCE)
		tty_flag = 1;

	/* Allocate a tty by default if no command specified. */
	if (buffer_len(&command) == 0)
		tty_flag = options.request_tty != REQUEST_TTY_NO;

	/* Force no tty */
	if (options.request_tty == REQUEST_TTY_NO ||
	    (muxclient_command && muxclient_command != SSHMUX_COMMAND_PROXY))
		tty_flag = 0;
	/* Do not allocate a tty if stdin is not a tty. */
	if ((!isatty(fileno(stdin)) || stdin_null_flag) &&
	    options.request_tty != REQUEST_TTY_FORCE) {
		if (tty_flag)
			logit("Pseudo-terminal will not be allocated because "
			    "stdin is not a terminal.");
		tty_flag = 0;
	}

	if (options.user == NULL)
		options.user = xstrdup(pw->pw_name);

	if (gethostname(thishost, sizeof(thishost)) == -1)
		fatal("gethostname: %s", strerror(errno));
	strlcpy(shorthost, thishost, sizeof(shorthost));
	shorthost[strcspn(thishost, ".")] = '\0';
	snprintf(portstr, sizeof(portstr), "%d", options.port);
	snprintf(uidstr, sizeof(uidstr), "%d", pw->pw_uid);

	if ((md = ssh_digest_start(SSH_DIGEST_SHA1)) == NULL ||
	    ssh_digest_update(md, thishost, strlen(thishost)) < 0 ||
	    ssh_digest_update(md, host, strlen(host)) < 0 ||
	    ssh_digest_update(md, portstr, strlen(portstr)) < 0 ||
	    ssh_digest_update(md, options.user, strlen(options.user)) < 0 ||
	    ssh_digest_final(md, conn_hash, sizeof(conn_hash)) < 0)
		fatal("%s: mux digest failed", __func__);
	ssh_digest_free(md);
	conn_hash_hex = tohex(conn_hash, ssh_digest_bytes(SSH_DIGEST_SHA1));

	if (options.local_command != NULL) {
		debug3("expanding LocalCommand: %s", options.local_command);
		cp = options.local_command;
		options.local_command = percent_expand(cp,
		    "C", conn_hash_hex,
		    "L", shorthost,
		    "d", pw->pw_dir,
		    "h", host,
		    "l", thishost,
		    "n", host_arg,
		    "p", portstr,
		    "r", options.user,
		    "u", pw->pw_name,
		    (char *)NULL);
		debug3("expanded LocalCommand: %s", options.local_command);
		free(cp);
	}

	if (options.control_path != NULL) {
		cp = tilde_expand_filename(options.control_path,
		    original_real_uid);
		free(options.control_path);
		options.control_path = percent_expand(cp,
		    "C", conn_hash_hex,
		    "L", shorthost,
		    "h", host,
		    "l", thishost,
		    "n", host_arg,
		    "p", portstr,
		    "r", options.user,
		    "u", pw->pw_name,
		    "i", uidstr,
		    (char *)NULL);
		free(cp);
	}
	free(conn_hash_hex);

	if (config_test) {
		dump_client_config(&options, host);
		exit(0);
	}

	if (muxclient_command != 0 && options.control_path == NULL)
		fatal("No ControlPath specified for \"-O\" command");
	if (options.control_path != NULL) {
		int sock;
		if ((sock = muxclient(options.control_path)) >= 0) {
			packet_set_connection(sock, sock);
			ssh = active_state; /* XXX */
			enable_compat20();	/* XXX */
			packet_set_mux();
			goto skip_connect;
		}
	}

	/*
	 * If hostname canonicalisation was not enabled, then we may not
	 * have yet resolved the hostname. Do so now.
	 */
	if (addrs == NULL && options.proxy_command == NULL) {
		debug2("resolving \"%s\" port %d", host, options.port);
		if ((addrs = resolve_host(host, options.port, 1,
		    cname, sizeof(cname))) == NULL)
			cleanup_exit(255); /* resolve_host logs the error */
	}

	timeout_ms = options.connection_timeout * 1000;

	/* Open a connection to the remote host. */
	if (ssh_connect(host, addrs, &hostaddr, options.port,
	    options.address_family, options.connection_attempts,
	    &timeout_ms, options.tcp_keep_alive,
	    options.use_privileged_port) != 0)
		exit(255);

	if (addrs != NULL)
		freeaddrinfo(addrs);

	packet_set_timeout(options.server_alive_interval,
	    options.server_alive_count_max);

	ssh = active_state; /* XXX */

	if (timeout_ms > 0)
		debug3("timeout: %d ms remain after connect", timeout_ms);

	/*
	 * If we successfully made the connection, load the host private key
	 * in case we will need it later for combined rsa-rhosts
	 * authentication. This must be done before releasing extra
	 * privileges, because the file is only readable by root.
	 * If we cannot access the private keys, load the public keys
	 * instead and try to execute the ssh-keysign helper instead.
	 */
	sensitive_data.nkeys = 0;
	sensitive_data.keys = NULL;
	sensitive_data.external_keysign = 0;
	if (options.rhosts_rsa_authentication ||
	    options.hostbased_authentication) {
		sensitive_data.nkeys = 9;
		sensitive_data.keys = xcalloc(sensitive_data.nkeys,
		    sizeof(Key));

		PRIV_START;
#if WITH_SSH1
		sensitive_data.keys[0] = key_load_private_type(KEY_RSA1,
		    _PATH_HOST_KEY_FILE, "", NULL, NULL);
#endif
		sensitive_data.keys[1] = key_load_private_cert(KEY_ECDSA,
		    _PATH_HOST_ECDSA_KEY_FILE, "", NULL);
		sensitive_data.keys[2] = key_load_private_cert(KEY_ED25519,
		    _PATH_HOST_ED25519_KEY_FILE, "", NULL);
		sensitive_data.keys[3] = key_load_private_cert(KEY_RSA,
		    _PATH_HOST_RSA_KEY_FILE, "", NULL);
		sensitive_data.keys[4] = key_load_private_cert(KEY_DSA,
		    _PATH_HOST_DSA_KEY_FILE, "", NULL);
		sensitive_data.keys[5] = key_load_private_type(KEY_ECDSA,
		    _PATH_HOST_ECDSA_KEY_FILE, "", NULL, NULL);
		sensitive_data.keys[6] = key_load_private_type(KEY_ED25519,
		    _PATH_HOST_ED25519_KEY_FILE, "", NULL, NULL);
		sensitive_data.keys[7] = key_load_private_type(KEY_RSA,
		    _PATH_HOST_RSA_KEY_FILE, "", NULL, NULL);
		sensitive_data.keys[8] = key_load_private_type(KEY_DSA,
		    _PATH_HOST_DSA_KEY_FILE, "", NULL, NULL);
		PRIV_END;

		if (options.hostbased_authentication == 1 &&
		    sensitive_data.keys[0] == NULL &&
		    sensitive_data.keys[5] == NULL &&
		    sensitive_data.keys[6] == NULL &&
		    sensitive_data.keys[7] == NULL &&
		    sensitive_data.keys[8] == NULL) {
			sensitive_data.keys[1] = key_load_cert(
			    _PATH_HOST_ECDSA_KEY_FILE);
			sensitive_data.keys[2] = key_load_cert(
			    _PATH_HOST_ED25519_KEY_FILE);
			sensitive_data.keys[3] = key_load_cert(
			    _PATH_HOST_RSA_KEY_FILE);
			sensitive_data.keys[4] = key_load_cert(
			    _PATH_HOST_DSA_KEY_FILE);
			sensitive_data.keys[5] = key_load_public(
			    _PATH_HOST_ECDSA_KEY_FILE, NULL);
			sensitive_data.keys[6] = key_load_public(
			    _PATH_HOST_ED25519_KEY_FILE, NULL);
			sensitive_data.keys[7] = key_load_public(
			    _PATH_HOST_RSA_KEY_FILE, NULL);
			sensitive_data.keys[8] = key_load_public(
			    _PATH_HOST_DSA_KEY_FILE, NULL);
			sensitive_data.external_keysign = 1;
		}
	}
	/*
	 * Get rid of any extra privileges that we may have.  We will no
	 * longer need them.  Also, extra privileges could make it very hard
	 * to read identity files and other non-world-readable files from the
	 * user's home directory if it happens to be on a NFS volume where
	 * root is mapped to nobody.
	 */
	if (original_effective_uid == 0) {
		PRIV_START;
		permanently_set_uid(pw);
	}

	/*
	 * Now that we are back to our own permissions, create ~/.ssh
	 * directory if it doesn't already exist.
	 */
	if (config == NULL) {
		r = snprintf(buf, sizeof buf, "%s%s%s", pw->pw_dir,
		    strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
		if (r > 0 && (size_t)r < sizeof(buf) && stat(buf, &st) < 0)
			if (mkdir(buf, 0700) < 0)
				error("Could not create directory '%.200s'.",
				    buf);
	}

	/* load options.identity_files */
	load_public_identity_files();

	/* optionally set the SSH_AUTHSOCKET_ENV_NAME varibale */
	if (options.identity_agent &&
	    strcmp(options.identity_agent, SSH_AUTHSOCKET_ENV_NAME) != 0) {
		if (strcmp(options.identity_agent, "none") == 0) {
			unsetenv(SSH_AUTHSOCKET_ENV_NAME);
		} else {
			p = tilde_expand_filename(options.identity_agent,
			    original_real_uid);
			cp = percent_expand(p, "d", pw->pw_dir,
			    "u", pw->pw_name, "l", thishost, "h", host,
			    "r", options.user, (char *)NULL);
			setenv(SSH_AUTHSOCKET_ENV_NAME, cp, 1);
			free(cp);
			free(p);
		}
	}

	/* Expand ~ in known host file names. */
	tilde_expand_paths(options.system_hostfiles,
	    options.num_system_hostfiles);
	tilde_expand_paths(options.user_hostfiles, options.num_user_hostfiles);

	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */
	signal(SIGCHLD, main_sigchld_handler);

	/* Log into the remote system.  Never returns if the login fails. */
	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr,
	    options.port, pw, timeout_ms);

	if (packet_connection_is_on_socket()) {
		verbose("Authenticated to %s ([%s]:%d).", host,
		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
	} else {
		verbose("Authenticated to %s (via proxy).", host);
	}

	/* We no longer need the private host keys.  Clear them now. */
	if (sensitive_data.nkeys != 0) {
		for (i = 0; i < sensitive_data.nkeys; i++) {
			if (sensitive_data.keys[i] != NULL) {
				/* Destroys contents safely */
				debug3("clear hostkey %d", i);
				key_free(sensitive_data.keys[i]);
				sensitive_data.keys[i] = NULL;
			}
		}
		free(sensitive_data.keys);
	}
	for (i = 0; i < options.num_identity_files; i++) {
		free(options.identity_files[i]);
		options.identity_files[i] = NULL;
		if (options.identity_keys[i]) {
			key_free(options.identity_keys[i]);
			options.identity_keys[i] = NULL;
		}
	}
	for (i = 0; i < options.num_certificate_files; i++) {
		free(options.certificate_files[i]);
		options.certificate_files[i] = NULL;
	}

 skip_connect:
	exit_status = compat20 ? ssh_session2() : ssh_session();
	packet_close();

	if (options.control_path != NULL && muxserver_sock != -1)
		unlink(options.control_path);

	/* Kill ProxyCommand if it is running. */
	ssh_kill_proxy_command();

	return exit_status;
}

static void
control_persist_detach(void)
{
	pid_t pid;
	int devnull, keep_stderr;

	debug("%s: backgrounding master process", __func__);

 	/*
 	 * master (current process) into the background, and make the
 	 * foreground process a client of the backgrounded master.
 	 */
	switch ((pid = fork())) {
	case -1:
		fatal("%s: fork: %s", __func__, strerror(errno));
	case 0:
		/* Child: master process continues mainloop */
 		break;
 	default:
		/* Parent: set up mux slave to connect to backgrounded master */
		debug2("%s: background process is %ld", __func__, (long)pid);
		stdin_null_flag = ostdin_null_flag;
		options.request_tty = orequest_tty;
		tty_flag = otty_flag;
 		close(muxserver_sock);
 		muxserver_sock = -1;
		options.control_master = SSHCTL_MASTER_NO;
 		muxclient(options.control_path);
		/* muxclient() doesn't return on success. */
 		fatal("Failed to connect to new control master");
 	}
	if ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {
		error("%s: open(\"/dev/null\"): %s", __func__,
		    strerror(errno));
	} else {
		keep_stderr = log_is_on_stderr() && debug_flag;
		if (dup2(devnull, STDIN_FILENO) == -1 ||
		    dup2(devnull, STDOUT_FILENO) == -1 ||
		    (!keep_stderr && dup2(devnull, STDERR_FILENO) == -1))
			error("%s: dup2: %s", __func__, strerror(errno));
		if (devnull > STDERR_FILENO)
			close(devnull);
	}
	daemon(1, 1);
	setproctitle("%s [mux]", options.control_path);
}

/* Do fork() after authentication. Used by "ssh -f" */
static void
fork_postauth(void)
{
	if (need_controlpersist_detach)
		control_persist_detach();
	debug("forking to background");
	fork_after_authentication_flag = 0;
	if (daemon(1, 1) < 0)
		fatal("daemon() failed: %.200s", strerror(errno));
}

/* Callback for remote forward global requests */
static void
ssh_confirm_remote_forward(int type, u_int32_t seq, void *ctxt)
{
	struct Forward *rfwd = (struct Forward *)ctxt;

	/* XXX verbose() on failure? */
	debug("remote forward %s for: listen %s%s%d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    rfwd->listen_path ? rfwd->listen_path :
	    rfwd->listen_host ? rfwd->listen_host : "",
	    (rfwd->listen_path || rfwd->listen_host) ? ":" : "",
	    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :
	    rfwd->connect_host, rfwd->connect_port);
	if (rfwd->listen_path == NULL && rfwd->listen_port == 0) {
		if (type == SSH2_MSG_REQUEST_SUCCESS) {
			rfwd->allocated_port = packet_get_int();
			logit("Allocated port %u for remote forward to %s:%d",
			    rfwd->allocated_port,
			    rfwd->connect_host, rfwd->connect_port);
			channel_update_permitted_opens(rfwd->handle,
			    rfwd->allocated_port);
		} else {
			channel_update_permitted_opens(rfwd->handle, -1);
		}
	}
	
	if (type == SSH2_MSG_REQUEST_FAILURE) {
		if (options.exit_on_forward_failure) {
			if (rfwd->listen_path != NULL)
				fatal("Error: remote port forwarding failed "
				    "for listen path %s", rfwd->listen_path);
			else
				fatal("Error: remote port forwarding failed "
				    "for listen port %d", rfwd->listen_port);
		} else {
			if (rfwd->listen_path != NULL)
				logit("Warning: remote port forwarding failed "
				    "for listen path %s", rfwd->listen_path);
			else
				logit("Warning: remote port forwarding failed "
				    "for listen port %d", rfwd->listen_port);
		}
	}
	if (++remote_forward_confirms_received == options.num_remote_forwards) {
		debug("All remote forwarding requests processed");
		if (fork_after_authentication_flag)
			fork_postauth();
	}
}

static void
client_cleanup_stdio_fwd(int id, void *arg)
{
	debug("stdio forwarding: done");
	cleanup_exit(0);
}

static void
ssh_stdio_confirm(int id, int success, void *arg)
{
	if (!success)
		fatal("stdio forwarding failed");
}

static void
ssh_init_stdio_forwarding(void)
{
	Channel *c;
	int in, out;

	if (options.stdio_forward_host == NULL)
		return;
	if (!compat20)
		fatal("stdio forwarding require Protocol 2");

	debug3("%s: %s:%d", __func__, options.stdio_forward_host,
	    options.stdio_forward_port);

	if ((in = dup(STDIN_FILENO)) < 0 ||
	    (out = dup(STDOUT_FILENO)) < 0)
		fatal("channel_connect_stdio_fwd: dup() in/out failed");
	if ((c = channel_connect_stdio_fwd(options.stdio_forward_host,
	    options.stdio_forward_port, in, out)) == NULL)
		fatal("%s: channel_connect_stdio_fwd failed", __func__);
	channel_register_cleanup(c->self, client_cleanup_stdio_fwd, 0);
	channel_register_open_confirm(c->self, ssh_stdio_confirm, NULL);
}

static void
ssh_init_forwarding(void)
{
	int success = 0;
	int i;

	/* Initiate local TCP/IP port forwardings. */
	for (i = 0; i < options.num_local_forwards; i++) {
		debug("Local connections to %.200s:%d forwarded to remote "
		    "address %.200s:%d",
		    (options.local_forwards[i].listen_path != NULL) ?
		    options.local_forwards[i].listen_path :
		    (options.local_forwards[i].listen_host == NULL) ?
		    (options.fwd_opts.gateway_ports ? "*" : "LOCALHOST") :
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    (options.local_forwards[i].connect_path != NULL) ?
		    options.local_forwards[i].connect_path :
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port);
		success += channel_setup_local_fwd_listener(
		    &options.local_forwards[i], &options.fwd_opts);
	}
	if (i > 0 && success != i && options.exit_on_forward_failure)
		fatal("Could not request local forwarding.");
	if (i > 0 && success == 0)
		error("Could not request local forwarding.");

	/* Initiate remote TCP/IP port forwardings. */
	for (i = 0; i < options.num_remote_forwards; i++) {
		debug("Remote connections from %.200s:%d forwarded to "
		    "local address %.200s:%d",
		    (options.remote_forwards[i].listen_path != NULL) ?
		    options.remote_forwards[i].listen_path :
		    (options.remote_forwards[i].listen_host == NULL) ?
		    "LOCALHOST" : options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    (options.remote_forwards[i].connect_path != NULL) ?
		    options.remote_forwards[i].connect_path :
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
		options.remote_forwards[i].handle =
		    channel_request_remote_forwarding(
		    &options.remote_forwards[i]);
		if (options.remote_forwards[i].handle < 0) {
			if (options.exit_on_forward_failure)
				fatal("Could not request remote forwarding.");
			else
				logit("Warning: Could not request remote "
				    "forwarding.");
		} else {
			client_register_global_confirm(ssh_confirm_remote_forward,
			    &options.remote_forwards[i]);
		}
	}

	/* Initiate tunnel forwarding. */
	if (options.tun_open != SSH_TUNMODE_NO) {
		if (client_request_tun_fwd(options.tun_open,
		    options.tun_local, options.tun_remote) == -1) {
			if (options.exit_on_forward_failure)
				fatal("Could not request tunnel forwarding.");
			else
				error("Could not request tunnel forwarding.");
		}
	}			
}

static void
check_agent_present(void)
{
	int r;

	if (options.forward_agent) {
		/* Clear agent forwarding if we don't have an agent. */
		if ((r = ssh_get_authentication_socket(NULL)) != 0) {
			options.forward_agent = 0;
			if (r != SSH_ERR_AGENT_NOT_PRESENT)
				debug("ssh_get_authentication_socket: %s",
				    ssh_err(r));
		}
	}
}

static int
ssh_session(void)
{
	int type;
	int interactive = 0;
	int have_tty = 0;
	struct winsize ws;
	char *cp;
	const char *display;
	char *proto = NULL, *data = NULL;

	/* Enable compression if requested. */
	if (options.compression) {
		debug("Requesting compression at level %d.",
		    options.compression_level);

		if (options.compression_level < 1 ||
		    options.compression_level > 9)
			fatal("Compression level must be from 1 (fast) to "
			    "9 (slow, best).");

		/* Send the request. */
		packet_start(SSH_CMSG_REQUEST_COMPRESSION);
		packet_put_int(options.compression_level);
		packet_send();
		packet_write_wait();
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			packet_start_compression(options.compression_level);
		else if (type == SSH_SMSG_FAILURE)
			logit("Warning: Remote host refused compression.");
		else
			packet_disconnect("Protocol error waiting for "
			    "compression response.");
	}
	/* Allocate a pseudo tty if appropriate. */
	if (tty_flag) {
		debug("Requesting pty.");

		/* Start the packet. */
		packet_start(SSH_CMSG_REQUEST_PTY);

		/* Store TERM in the packet.  There is no limit on the
		   length of the string. */
		cp = getenv("TERM");
		if (!cp)
			cp = "";
		packet_put_cstring(cp);

		/* Store window size in the packet. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);

		/* Store tty modes in the packet. */
		tty_make_modes(fileno(stdin), NULL);

		/* Send the packet, and wait for it to leave. */
		packet_send();
		packet_write_wait();

		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
			have_tty = 1;
		} else if (type == SSH_SMSG_FAILURE)
			logit("Warning: Remote host failed or refused to "
			    "allocate a pseudo tty.");
		else
			packet_disconnect("Protocol error waiting for pty "
			    "request response.");
	}
	/* Request X11 forwarding if enabled and DISPLAY is set. */
	display = getenv("DISPLAY");
	if (display == NULL && options.forward_x11)
		debug("X11 forwarding requested but DISPLAY not set");
	if (options.forward_x11 && client_x11_get_proto(display,
	    options.xauth_location, options.forward_x11_trusted,
	    options.forward_x11_timeout, &proto, &data) == 0) {
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication "
		    "spoofing.");
		x11_request_forwarding_with_spoofing(0, display, proto,
		    data, 0);
		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
		} else if (type == SSH_SMSG_FAILURE) {
			logit("Warning: Remote host denied X11 forwarding.");
		} else {
			packet_disconnect("Protocol error waiting for X11 "
			    "forwarding");
		}
	}
	/* Tell the packet module whether this is an interactive session. */
	packet_set_interactive(interactive,
	    options.ip_qos_interactive, options.ip_qos_bulk);

	/* Request authentication agent forwarding if appropriate. */
	check_agent_present();

	if (options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		auth_request_forwarding();

		/* Read response from the server. */
		type = packet_read();
		packet_check_eom();
		if (type != SSH_SMSG_SUCCESS)
			logit("Warning: Remote host denied authentication agent forwarding.");
	}

	/* Initiate port forwardings. */
	ssh_init_stdio_forwarding();
	ssh_init_forwarding();

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

	/*
	 * If requested and we are not interested in replies to remote
	 * forwarding requests, then let ssh continue in the background.
	 */
	if (fork_after_authentication_flag) {
		if (options.exit_on_forward_failure &&
		    options.num_remote_forwards > 0) {
			debug("deferring postauth fork until remote forward "
			    "confirmation received");
		} else
			fork_postauth();
	}

	/*
	 * If a command was specified on the command line, execute the
	 * command now. Otherwise request the server to start a shell.
	 */
	if (buffer_len(&command) > 0) {
		int len = buffer_len(&command);
		if (len > 900)
			len = 900;
		debug("Sending command: %.*s", len,
		    (u_char *)buffer_ptr(&command));
		packet_start(SSH_CMSG_EXEC_CMD);
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
		packet_send();
		packet_write_wait();
	} else {
		debug("Requesting shell.");
		packet_start(SSH_CMSG_EXEC_SHELL);
		packet_send();
		packet_write_wait();
	}

	/* Enter the interactive session. */
	return client_loop(have_tty, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
}

/* request pty/x11/agent/tcpfwd/shell for channel */
static void
ssh_session2_setup(int id, int success, void *arg)
{
	extern char **environ;
	const char *display;
	int interactive = tty_flag;
	char *proto = NULL, *data = NULL;

	if (!success)
		return; /* No need for error message, channels code sens one */

	display = getenv("DISPLAY");
	if (display == NULL && options.forward_x11)
		debug("X11 forwarding requested but DISPLAY not set");
	if (options.forward_x11 && client_x11_get_proto(display,
	    options.xauth_location, options.forward_x11_trusted,
	    options.forward_x11_timeout, &proto, &data) == 0) {
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication "
		    "spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto,
		    data, 1);
		client_expect_confirm(id, "X11 forwarding", CONFIRM_WARN);
		/* XXX exit_on_forward_failure */
		interactive = 1;
	}

	check_agent_present();
	if (options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

	/* Tell the packet module whether this is an interactive session. */
	packet_set_interactive(interactive,
	    options.ip_qos_interactive, options.ip_qos_bulk);

	client_session2_setup(id, tty_flag, subsystem_flag, getenv("TERM"),
	    NULL, fileno(stdin), &command, environ);
}

/* open new channel for a session */
static int
ssh_session2_open(void)
{
	Channel *c;
	int window, packetmax, in, out, err;

	if (stdin_null_flag) {
		in = open(_PATH_DEVNULL, O_RDONLY);
	} else {
		in = dup(STDIN_FILENO);
	}
	out = dup(STDOUT_FILENO);
	err = dup(STDERR_FILENO);

	if (in < 0 || out < 0 || err < 0)
		fatal("dup() in/out/err failed");

	/* enable nonblocking unless tty */
	if (!isatty(in))
		set_nonblock(in);
	if (!isatty(out))
		set_nonblock(out);
	if (!isatty(err))
		set_nonblock(err);

	window = CHAN_SES_WINDOW_DEFAULT;
	packetmax = CHAN_SES_PACKET_DEFAULT;
	if (tty_flag) {
		window >>= 1;
		packetmax >>= 1;
	}
	c = channel_new(
	    "session", SSH_CHANNEL_OPENING, in, out, err,
	    window, packetmax, CHAN_EXTENDED_WRITE,
	    "client-session", /*nonblock*/0);

	debug3("ssh_session2_open: channel_new: %d", c->self);

	channel_send_open(c->self);
	if (!no_shell_flag)
		channel_register_open_confirm(c->self,
		    ssh_session2_setup, NULL);

	return c->self;
}

static int
ssh_session2(void)
{
	int id = -1;

	/* XXX should be pre-session */
	if (!options.control_persist)
		ssh_init_stdio_forwarding();
	ssh_init_forwarding();

	/* Start listening for multiplex clients */
	if (!packet_get_mux())
		muxserver_listen();

 	/*
	 * If we are in control persist mode and have a working mux listen
	 * socket, then prepare to background ourselves and have a foreground
	 * client attach as a control slave.
	 * NB. we must save copies of the flags that we override for
	 * the backgrounding, since we defer attachment of the slave until
	 * after the connection is fully established (in particular,
	 * async rfwd replies have been received for ExitOnForwardFailure).
	 */
 	if (options.control_persist && muxserver_sock != -1) {
		ostdin_null_flag = stdin_null_flag;
		ono_shell_flag = no_shell_flag;
		orequest_tty = options.request_tty;
		otty_flag = tty_flag;
 		stdin_null_flag = 1;
 		no_shell_flag = 1;
 		tty_flag = 0;
		if (!fork_after_authentication_flag)
			need_controlpersist_detach = 1;
		fork_after_authentication_flag = 1;
 	}
	/*
	 * ControlPersist mux listen socket setup failed, attempt the
	 * stdio forward setup that we skipped earlier.
	 */
	if (options.control_persist && muxserver_sock == -1)
		ssh_init_stdio_forwarding();

	if (!no_shell_flag || (datafellows & SSH_BUG_DUMMYCHAN))
		id = ssh_session2_open();
	else {
		packet_set_interactive(
		    options.control_master == SSHCTL_MASTER_NO,
		    options.ip_qos_interactive, options.ip_qos_bulk);
	}

	/* If we don't expect to open a new session, then disallow it */
	if (options.control_master == SSHCTL_MASTER_NO &&
	    (datafellows & SSH_NEW_OPENSSH)) {
		debug("Requesting no-more-sessions@@openssh.com");
		packet_start(SSH2_MSG_GLOBAL_REQUEST);
		packet_put_cstring("no-more-sessions@@openssh.com");
		packet_put_char(0);
		packet_send();
	}

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

	/*
	 * If requested and we are not interested in replies to remote
	 * forwarding requests, then let ssh continue in the background.
	 */
	if (fork_after_authentication_flag) {
		if (options.exit_on_forward_failure &&
		    options.num_remote_forwards > 0) {
			debug("deferring postauth fork until remote forward "
			    "confirmation received");
		} else
			fork_postauth();
	}

	return client_loop(tty_flag, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, id);
}

/* Loads all IdentityFile and CertificateFile keys */
static void
load_public_identity_files(void)
{
	char *filename, *cp, thishost[NI_MAXHOST];
	char *pwdir = NULL, *pwname = NULL;
	Key *public;
	struct passwd *pw;
	int i;
	u_int n_ids, n_certs;
	char *identity_files[SSH_MAX_IDENTITY_FILES];
	Key *identity_keys[SSH_MAX_IDENTITY_FILES];
	char *certificate_files[SSH_MAX_CERTIFICATE_FILES];
	struct sshkey *certificates[SSH_MAX_CERTIFICATE_FILES];
#ifdef ENABLE_PKCS11
	Key **keys;
	int nkeys;
#endif /* PKCS11 */

	n_ids = n_certs = 0;
	memset(identity_files, 0, sizeof(identity_files));
	memset(identity_keys, 0, sizeof(identity_keys));
	memset(certificate_files, 0, sizeof(certificate_files));
	memset(certificates, 0, sizeof(certificates));

#ifdef ENABLE_PKCS11
	if (options.pkcs11_provider != NULL &&
	    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&
	    (pkcs11_init(!options.batch_mode) == 0) &&
	    (nkeys = pkcs11_add_provider(options.pkcs11_provider, NULL,
	    &keys)) > 0) {
		for (i = 0; i < nkeys; i++) {
			if (n_ids >= SSH_MAX_IDENTITY_FILES) {
				key_free(keys[i]);
				continue;
			}
			identity_keys[n_ids] = keys[i];
			identity_files[n_ids] =
			    xstrdup(options.pkcs11_provider); /* XXX */
			n_ids++;
		}
		free(keys);
	}
#endif /* ENABLE_PKCS11 */
	if ((pw = getpwuid(original_real_uid)) == NULL)
		fatal("load_public_identity_files: getpwuid failed");
	pwname = xstrdup(pw->pw_name);
	pwdir = xstrdup(pw->pw_dir);
	if (gethostname(thishost, sizeof(thishost)) == -1)
		fatal("load_public_identity_files: gethostname: %s",
		    strerror(errno));
	for (i = 0; i < options.num_identity_files; i++) {
		if (n_ids >= SSH_MAX_IDENTITY_FILES ||
		    strcasecmp(options.identity_files[i], "none") == 0) {
			free(options.identity_files[i]);
			options.identity_files[i] = NULL;
			continue;
		}
		cp = tilde_expand_filename(options.identity_files[i],
		    original_real_uid);
		filename = percent_expand(cp, "d", pwdir,
		    "u", pwname, "l", thishost, "h", host,
		    "r", options.user, (char *)NULL);
		free(cp);
		public = key_load_public(filename, NULL);
		debug("identity file %s type %d", filename,
		    public ? public->type : -1);
		free(options.identity_files[i]);
		identity_files[n_ids] = filename;
		identity_keys[n_ids] = public;

		if (++n_ids >= SSH_MAX_IDENTITY_FILES)
			continue;

		/*
		 * If no certificates have been explicitly listed then try
		 * to add the default certificate variant too.
		 */
		if (options.num_certificate_files != 0)
			continue;
		xasprintf(&cp, "%s-cert", filename);
		public = key_load_public(cp, NULL);
		debug("identity file %s type %d", cp,
		    public ? public->type : -1);
		if (public == NULL) {
			free(cp);
			continue;
		}
		if (!key_is_cert(public)) {
			debug("%s: key %s type %s is not a certificate",
			    __func__, cp, key_type(public));
			key_free(public);
			free(cp);
			continue;
		}
		/* NB. leave filename pointing to private key */
		identity_files[n_ids] = xstrdup(filename);
		identity_keys[n_ids] = public;
		n_ids++;
	}

	if (options.num_certificate_files > SSH_MAX_CERTIFICATE_FILES)
		fatal("%s: too many certificates", __func__);
	for (i = 0; i < options.num_certificate_files; i++) {
		cp = tilde_expand_filename(options.certificate_files[i],
		    original_real_uid);
		filename = percent_expand(cp, "d", pwdir,
		    "u", pwname, "l", thishost, "h", host,
		    "r", options.user, (char *)NULL);
		free(cp);

		public = key_load_public(filename, NULL);
		debug("certificate file %s type %d", filename,
		    public ? public->type : -1);
		free(options.certificate_files[i]);
		options.certificate_files[i] = NULL;
		if (public == NULL) {
			free(filename);
			continue;
		}
		if (!key_is_cert(public)) {
			debug("%s: key %s type %s is not a certificate",
			    __func__, filename, key_type(public));
			key_free(public);
			free(filename);
			continue;
		}
		certificate_files[n_certs] = filename;
		certificates[n_certs] = public;
		++n_certs;
	}

	options.num_identity_files = n_ids;
	memcpy(options.identity_files, identity_files, sizeof(identity_files));
	memcpy(options.identity_keys, identity_keys, sizeof(identity_keys));

	options.num_certificate_files = n_certs;
	memcpy(options.certificate_files,
	    certificate_files, sizeof(certificate_files));
	memcpy(options.certificates, certificates, sizeof(certificates));

	explicit_bzero(pwname, strlen(pwname));
	free(pwname);
	explicit_bzero(pwdir, strlen(pwdir));
	free(pwdir);
}

static void
main_sigchld_handler(int sig)
{
	int save_errno = errno;
	pid_t pid;
	int status;

	while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
	    (pid < 0 && errno == EINTR))
		;

	signal(sig, main_sigchld_handler);
	errno = save_errno;
}
@


1.451
log
@fix regression in 7.4 server-sig-algs, where we were accidentally
excluding SHA2 RSA signature methods. bz#2680, patch from Nuno
Goncalves; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.450 2017/03/08 12:07:47 djm Exp $ */
d979 5
a983 2
	    options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
	    SYSLOG_FACILITY_USER, !use_syslog);
d1124 1
a1124 1
	log_init(argv0, options.log_level, SYSLOG_FACILITY_USER, !use_syslog);
@


1.450
log
@quote [host]:port in generated ProxyJump commandline; the [ / ]
characters can confuse some shells (e.g. zsh).
Reported by Lauri Tirkkonen via bugs@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.449 2017/02/17 02:04:15 djm Exp $ */
d656 1
a656 1
				cp = sshkey_alg_list(0, 0, '\n');
d658 1
a658 1
				cp = sshkey_alg_list(1, 0, '\n');
d660 1
a660 1
				cp = sshkey_alg_list(0, 1, '\n');
@


1.449
log
@For ProxyJump/-J, surround host name with brackets to allow
literal IPv6 addresses. From Dick Visser; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.448 2016/12/06 07:48:01 djm Exp $ */
d1075 1
a1075 1
		    "ssh%s%s%s%s%s%s%s%s%s%.*s -W [%%h]:%%p %s",
@


1.448
log
@make IdentityFile successfully load and use certificates that have no
corresponding bare public key. E.g. just a private id_rsa and certificate
id_rsa-cert.pub (and no id_rsa.pub).

bz#2617 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.447 2016/09/30 09:19:13 markus Exp $ */
d1075 1
a1075 1
		    "ssh%s%s%s%s%s%s%s%s%s%.*s -W %%h:%%p %s",
@


1.447
log
@ssh proxy mux mode (-O proxy; idea from Simon Tatham):
- mux client speaks the ssh-packet protocol directly over unix-domain socket.
- mux server acts as a proxy, translates channel IDs and relays to the server.
- no filedescriptor passing necessary.
- combined with unix-domain forwarding it's even possible to run mux client
  and server on different machines.
feedback & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.446 2016/09/12 23:31:27 djm Exp $ */
d2081 2
a2083 1
		identity_files[n_ids] = cp;
@


1.446
log
@list all supported signature algorithms in the server-sig-algs
Reported by mb AT smartftp.com in bz#2547 and (independantly)
Ron Frederick; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.445 2016/07/17 04:20:16 djm Exp $ */
a200 4
/* from muxclient.c */
void muxclient(const char *);
void muxserver_listen(void);

d637 2
d1132 2
a1133 1
	if (options.request_tty == REQUEST_TTY_NO || muxclient_command != 0)
d1208 10
a1217 2
	if (options.control_path != NULL)
		muxclient(options.control_path);
d1404 1
d1915 2
a1916 1
	muxserver_listen();
@


1.445
log
@support UTF-8 characters in ssh(1) banners using schwarze@@'s
safe fmprintf printer; bz#2058

feedback schwarze@@ ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.444 2016/07/16 06:57:55 jmc Exp $ */
d658 1
a658 1
				cp = key_alg_list(0, 0);
d660 1
a660 1
				cp = key_alg_list(1, 0);
d662 1
a662 1
				cp = key_alg_list(0, 1);
@


1.444
log
@- add proxyjump to the options list
- formatting fixes
- update usage()

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.443 2016/07/15 00:24:30 djm Exp $ */
d65 1
d565 2
@


1.443
log
@Add a ProxyJump ssh_config(5) option and corresponding -J ssh(1)
command-line flag to allow simplified indirection through a
SSH bastion or "jump host".

These options construct a proxy command that connects to the
specified jump host(s) (more than one may be specified) and uses
port-forwarding to establish a connection to the next destination.

This codifies the safest way of indirecting connections through SSH
servers and makes it easy to use.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.442 2016/06/03 04:09:39 dtucker Exp $ */
d186 5
a190 4
"           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]\n"
"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
"           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]\n"
"           [-w local_tun[:remote_tun]] [user@@]hostname [command]\n"
@


1.442
log
@Allow ExitOnForwardFailure and ClearAllForwardings to be overridden when
using ssh -W (but still default to yes in that case).  bz#2577, ok djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.441 2016/06/03 03:14:41 dtucker Exp $ */
d318 1
a318 1
check_follow_cname(char **namep, const char *cname)
d330 1
a330 1
	 * a proxy unless the user specifically requests so.
d332 1
a332 1
	if (!option_clear_or_none(options.proxy_command) &&
d359 1
a359 1
	int i, ndots;
d370 3
a372 1
	if (!option_clear_or_none(options.proxy_command) &&
d427 1
a427 1
		if (!check_follow_cname(&fullhost, newname)) {
d500 1
a500 1
	int i, r, opt, exit_status, use_syslog, config_test = 0;
d578 1
a578 1
	    "ACD:E:F:GI:KL:MNO:PQ:R:S:TVw:W:XYy")) != -1) {
d703 9
d723 2
a724 1
				if (options.log_level < SYSLOG_LEVEL_DEBUG3)
d726 1
d1024 4
a1027 3
	if (addrs == NULL && options.num_permitted_cnames != 0 &&
	    (option_clear_or_none(options.proxy_command) ||
            options.canonicalize_hostname == SSH_CANONICALISE_ALWAYS)) {
d1035 1
a1035 1
			check_follow_cname(&host, cname);
d1059 35
@


1.441
log
@Move the host and port used by ssh -W into the Options struct.
This will make future changes a bit easier.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.440 2016/05/04 14:29:58 markus Exp $ */
a754 2
			options.clear_forwardings = 1;
			options.exit_on_forward_failure = 1;
@


1.440
log
@allow setting IdentityAgent to SSH_AUTH_SOCK; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.439 2016/05/04 12:21:53 markus Exp $ */
a138 4
/* forward stdio to remote host and port */
char *stdio_forward_host = NULL;
int stdio_forward_port = 0;

d620 1
a620 1
			if (stdio_forward_host != NULL)
d739 1
a739 1
			if (stdio_forward_host != NULL)
d744 2
a745 2
				stdio_forward_host = fwd.listen_host;
				stdio_forward_port = fwd.listen_port;
d1488 1
a1488 1
	if (stdio_forward_host == NULL)
d1493 2
a1494 1
	debug3("%s: %s:%d", __func__, stdio_forward_host, stdio_forward_port);
d1499 2
a1500 2
	if ((c = channel_connect_stdio_fwd(stdio_forward_host,
	    stdio_forward_port, in, out)) == NULL)
@


1.439
log
@IdentityAgent for specifying specific agent sockets; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.438 2016/04/29 08:07:53 djm Exp $ */
d1290 2
a1291 1
	if (options.identity_agent) {
@


1.438
log
@close ControlPersist background process stderr when not in
debug mode or when logging to a file or syslog.
bz#1988 ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.437 2016/03/07 19:02:43 djm Exp $ */
d1288 16
@


1.437
log
@refactor canohost.c: move functions that cache results closer to the
places that use them (authn and session code). After this, no state is
cached in canohost.c

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.436 2016/02/15 09:47:49 dtucker Exp $ */
d1349 1
a1349 1
	int devnull;
d1380 1
d1382 2
a1383 1
		    dup2(devnull, STDOUT_FILENO) == -1)
@


1.436
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.435 2016/01/14 16:17:40 markus Exp $ */
d501 1
d1191 2
d1303 1
a1303 1
		    get_remote_ipaddr(), get_remote_port());
@


1.435
log
@remove roaming support; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.434 2016/01/14 14:34:34 deraadt Exp $ */
d515 1
@


1.434
log
@Disable experimental client-side roaming support.  Server side was
disabled/gutted for years already, but this aspect was surprisingly
forgotten.
Thanks for report from Qualys
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.433 2016/01/13 23:04:47 djm Exp $ */
a97 1
#include "roaming.h"
@


1.433
log
@eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.432 2015/12/11 03:20:09 djm Exp $ */
a1901 3

	if (options.use_roaming)
		request_roaming();
@


1.432
log
@don't try to load SSHv1 private key when compiled without SSHv1
support. From Iain Morgan bz#2505
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.431 2015/12/10 17:08:40 mmcc Exp $ */
d1580 1
d1651 3
a1653 7
	if (options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted,
		    options.forward_x11_timeout,
		    &proto, &data);
d1743 1
d1751 3
a1753 6
	if (options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted,
		    options.forward_x11_timeout, &proto, &data);
@


1.431
log
@Remove NULL-checks before free().

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.430 2015/11/19 08:23:27 djm Exp $ */
d1211 1
d1214 1
@


1.430
log
@ban ConnectionAttempts=0, it makes no sense and would cause
ssh_connect_direct() to print an uninitialised stack variable;
bz#2500 reported by dvw AT phas.ubc.ca
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.429 2015/10/25 23:42:00 dtucker Exp $ */
d884 1
a884 2
			if (options.control_path != NULL)
				free(options.control_path);
@


1.429
log
@Expand tildes in filenames passed to -i before checking whether or not the
identity file exists.  This means that if the shell doesn't do the expansion
(eg because the option and filename were given as a single argument) then
we'll still add the key.  bz#2481, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.428 2015/10/16 18:40:49 djm Exp $ */
d1069 3
@


1.428
log
@better handle anchored FQDNs (e.g. 'cvs.openbsd.org.') in hostname
canonicalisation - treat them as already canonical and remove the
trailing '.' before matching ssh_config; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.427 2015/10/15 23:51:40 djm Exp $ */
d687 2
a688 1
			if (stat(optarg, &st) < 0) {
d690 1
a690 1
				    "not accessible: %s.\n", optarg,
d692 3
a694 3
				break;
			}
			add_identity_file(&options, NULL, optarg, 1);
@


1.427
log
@fix some signed/unsigned integer type mismatches in format
strings; reported by Nicholas Lemonias
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.426 2015/09/24 06:15:11 djm Exp $ */
d392 11
d426 1
d438 1
@


1.426
log
@add ssh_config CertificateFile option to explicitly list
a certificate; patch from Meghana Bhat on bz#2436; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.425 2015/09/11 06:55:46 jmc Exp $ */
d238 1
a238 1
	snprintf(strport, sizeof strport, "%u", port);
@


1.425
log
@sync -Q in usage() to SYNOPSIS; since it's drastically shorter,
i've reformatted the block to sync with the man (80 cols) and
saved a line;
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.424 2015/09/11 05:27:02 dtucker Exp $ */
d1307 4
d1897 1
a1902 1
	int i = 0;
d1905 2
a1906 1
	u_int n_ids;
d1909 2
d1916 1
a1916 1
	n_ids = 0;
d1919 2
d1952 1
d1971 6
a1976 1
		/* Try to add the certificate variant too */
d1993 1
a1993 2
		/* point to the original path, most likely the private key */
		identity_files[n_ids] = xstrdup(filename);
d1996 32
d2031 5
@


1.424
log
@Update usage to match man page.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.423 2015/09/11 03:47:28 djm Exp $ */
d191 3
a193 5
"           [-F configfile] [-I pkcs11] [-i identity_file]\n"
"           [-L address] [-l login_name] [-m mac_spec]\n"
"           [-O ctl_cmd] [-o option] [-p port]\n"
"           [-Q cipher | cipher-auth | mac | kex | key | protocol-version]\n"
"           [-R address] [-S ctl_path] [-W host:port]\n"
@


1.423
log
@expand %i in ControlPath to UID; bz#2449

patch from Christian Hesse w/ feedback from dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.422 2015/09/04 08:21:47 dtucker Exp $ */
d194 1
a194 1
"           [-Q cipher | cipher-auth | mac | kex | key]\n"
@


1.422
log
@Plug minor memory leaks when options are used more than once.  bz#2182,
patch from Tiago Cunha, ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.421 2015/09/04 04:56:09 djm Exp $ */
d494 1
a494 1
	char cname[NI_MAXHOST];
a503 1
	char *conn_hash_hex;
d1091 1
d1134 1
@


1.421
log
@add a debug2() right before DNS resolution; it's a place where
ssh could previously silently hang for a while. bz#2433
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.420 2015/07/30 00:01:34 djm Exp $ */
d600 1
a600 1
			logfile = xstrdup(optarg);
d687 1
d772 1
d792 2
a793 1
			if (mac_valid(optarg))
d795 1
a795 1
			else {
d956 1
a956 1
	if (logfile != NULL) {
a957 2
		free(logfile);
	}
@


1.420
log
@Allow ssh_config and sshd_config kex parameters options be prefixed
by a '+' to indicate that the specified items be appended to the
default rather than replacing it.

approach suggested by dtucker@@, feedback dlg@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.419 2015/07/20 18:42:35 millert Exp $ */
d1153 1
@


1.420.2.1
log
@MFC changes by djm@@cvs.openbsd.org, 2016/01/13 16:04:47

"eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@"
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.420 2015/07/30 00:01:34 djm Exp $ */
a1556 1
	char *proto = NULL, *data = NULL;
d1627 7
a1633 3
	if (options.forward_x11 && client_x11_get_proto(display,
	    options.xauth_location, options.forward_x11_trusted,
	    options.forward_x11_timeout, &proto, &data) == 0) {
a1722 1
	char *proto = NULL, *data = NULL;
d1730 6
a1735 3
	if (options.forward_x11 && client_x11_get_proto(display,
	    options.xauth_location, options.forward_x11_trusted,
	    options.forward_x11_timeout, &proto, &data) == 0) {
@


1.420.2.2
log
@MFC changes by: deraadt@@cvs.openbsd.org 2016/01/14 07:34:34

Disable experimental client-side roaming support.  Server side was
disabled/gutted for years already, but this aspect was surprisingly
forgotten.
Thanks for report from Qualys
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.420.2.1 2016/01/14 11:50:37 sthen Exp $ */
d1879 3
@


1.419
log
@Sync usage with SYNOPSIS
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.418 2015/05/04 06:10:48 djm Exp $ */
d101 1
d768 2
a769 1
			if (ciphers_valid(optarg)) {
d773 8
a780 15
			} else {
				/* SSH1 only */
				options.cipher = cipher_number(optarg);
				if (options.cipher == -1) {
					fprintf(stderr,
					    "Unknown cipher type '%s'\n",
					    optarg);
					exit(255);
				}
				if (options.cipher == SSH_CIPHER_3DES)
					options.ciphers = "3des-cbc";
				else if (options.cipher == SSH_CIPHER_BLOWFISH)
					options.ciphers = "blowfish-cbc";
				else
					options.ciphers = (char *)-1;
d782 6
@


1.418
log
@Remove pattern length argument from match_pattern_list(),
we only ever use it for strlen(pattern).

Prompted by hanno AT hboeck.de pointing an out-of-bound read
error caused by an incorrect pattern length found using AFL
and his own tools.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.417 2015/04/17 13:16:48 djm Exp $ */
d191 1
a191 1
"           [-L [bind_address:]port:host:hostport] [-l login_name] [-m mac_spec]\n"
d194 1
a194 1
"           [-R [bind_address:]port:host:hostport] [-S ctl_path] [-W host:port]\n"
@


1.417
log
@debug log missing DISPLAY environment when X11 forwarding
requested; bz#1682 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.416 2015/03/03 06:48:58 djm Exp $ */
d344 2
a345 4
		if (match_pattern_list(*namep, rule->source_list,
		    strlen(rule->source_list), 1) != 1 ||
		    match_pattern_list(cname, rule->target_list,
		    strlen(rule->target_list), 1) != 1)
@


1.416
log
@Allow "ssh -Q protocol-version" to list supported SSH protocol
versions. Useful for detecting builds without SSH v.1 support;
idea and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.415 2015/02/20 22:17:21 djm Exp $ */
d1626 2
d1729 2
@


1.416.2.1
log
@MFC changes by djm@@cvs.openbsd.org, 2016/01/13 16:04:47

"eliminate fallback from untrusted X11 forwarding to trusted
forwarding when the X server disables the SECURITY extension;
Reported by Thomas Hoger; ok deraadt@@"
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.416 2015/03/03 06:48:58 djm Exp $ */
a1557 1
	char *proto = NULL, *data = NULL;
d1626 7
a1632 3
	if (options.forward_x11 && client_x11_get_proto(display,
	    options.xauth_location, options.forward_x11_trusted,
	    options.forward_x11_timeout, &proto, &data) == 0) {
a1721 1
	char *proto = NULL, *data = NULL;
d1727 6
a1732 3
	if (options.forward_x11 && client_x11_get_proto(display,
	    options.xauth_location, options.forward_x11_trusted,
	    options.forward_x11_timeout, &proto, &data) == 0) {
@


1.416.2.2
log
@MFC changes by: deraadt@@cvs.openbsd.org 2016/01/14 07:34:34

Disable experimental client-side roaming support.  Server side was
disabled/gutted for years already, but this aspect was surprisingly
forgotten.
Thanks for report from Qualys
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.416.2.1 2016/01/14 11:53:20 sthen Exp $ */
d1876 3
@


1.415
log
@UpdateHostKeys fixes:

I accidentally changed the format of the hostkeys@@openssh.com messages
last week without changing the extension name, and this has been causing
connection failures for people who are running -current. First reported
by sthen@@

s/hostkeys@@openssh.com/hostkeys-00@@openssh.com/
Change the name of the proof message too, and reorder it a little.

Also, UpdateHostKeys=ask is incompatible with ControlPersist (no TTY
available to read the response) so disable UpdateHostKeys if it is in
ask mode and ControlPersist is active (and document this)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.414 2015/01/20 23:14:00 deraadt Exp $ */
d651 7
@


1.414
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.413 2015/01/16 07:19:48 djm Exp $ */
d1045 6
@


1.413
log
@when hostname canonicalisation is enabled, try to parse hostnames
as addresses before looking them up for canonicalisation.
fixes bz#2074 and avoids needless DNS lookups in some cases;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.412 2015/01/14 20:05:27 djm Exp $ */
a44 1
#include <sys/param.h>
d64 1
d442 1
a442 1
	char buf[MAXPATHLEN];
d493 1
a493 1
	char *p, *cp, *line, *argv0, buf[MAXPATHLEN], *host_arg, *logfile;
@


1.412
log
@move authfd.c and its tentacles to the new buffer/key API;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.411 2015/01/08 10:15:45 djm Exp $ */
d265 54
d368 1
a368 1
	char *cp, *fullhost, cname_target[NI_MAXHOST];
d382 13
d408 1
a408 1
		*cname_target = '\0';
d414 1
a414 1
		    cname_target, sizeof(cname_target))) == NULL) {
d421 1
a421 1
		if (!check_follow_cname(&fullhost, cname_target)) {
@


1.411
log
@reorder hostbased key attempts to better match the default
hostkey algorithms order in myproposal.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.410 2014/11/18 20:54:28 krw Exp $ */
d100 1
d1456 2
d1460 1
a1460 1
		if (!ssh_agent_present())
d1462 4
@


1.410
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.409 2014/10/09 06:21:31 jmc Exp $ */
d1116 1
a1116 3
		sensitive_data.keys[1] = key_load_private_cert(KEY_DSA,
		    _PATH_HOST_DSA_KEY_FILE, "", NULL);
		sensitive_data.keys[2] = key_load_private_cert(KEY_ECDSA,
d1118 2
d1122 3
a1124 5
		sensitive_data.keys[4] = key_load_private_cert(KEY_ED25519,
		    _PATH_HOST_ED25519_KEY_FILE, "", NULL);
		sensitive_data.keys[5] = key_load_private_type(KEY_DSA,
		    _PATH_HOST_DSA_KEY_FILE, "", NULL, NULL);
		sensitive_data.keys[6] = key_load_private_type(KEY_ECDSA,
d1126 2
d1130 2
a1131 2
		sensitive_data.keys[8] = key_load_private_type(KEY_ED25519,
		    _PATH_HOST_ED25519_KEY_FILE, "", NULL, NULL);
d1141 1
a1141 1
			    _PATH_HOST_DSA_KEY_FILE);
d1143 1
a1143 1
			    _PATH_HOST_ECDSA_KEY_FILE);
d1147 1
a1147 1
			    _PATH_HOST_ED25519_KEY_FILE);
d1149 1
a1149 1
			    _PATH_HOST_DSA_KEY_FILE, NULL);
d1151 1
a1151 1
			    _PATH_HOST_ECDSA_KEY_FILE, NULL);
d1155 1
a1155 1
			    _PATH_HOST_ED25519_KEY_FILE, NULL);
@


1.409
log
@tweak previous;
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.408 2014/10/08 22:20:25 djm Exp $ */
a49 1
#include <sys/types.h>
@


1.408
log
@Tweak config reparsing with host canonicalisation

Make the second pass through the config files always run when
hostname canonicalisation is enabled.

Add a "Match canonical" criteria that allows ssh_config Match
blocks to trigger only in the second config pass.

Add a -G option to ssh that causes it to parse its configuration
and dump the result to stdout, similar to "sshd -T"

Allow ssh_config Port options set in the second config parse
phase to be applied (they were being ignored).

bz#2267 bz#2286; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.407 2014/07/17 07:22:19 djm Exp $ */
d188 1
a188 1
"usage: ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n"
@


1.407
log
@reflect stdio-forward ("ssh -W host:port ...") failures in exit status.
previously we were always returning 0. bz#2255 reported by Brendan
Germain; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.406 2014/07/15 15:54:14 millert Exp $ */
d373 1
a373 1
process_config_files(struct passwd *pw)
d380 2
a381 2
		    !read_config_file(config, pw, host, &options,
		    SSHCONF_USERCONF))
d388 3
a390 2
			(void)read_config_file(buf, pw, host, &options,
			     SSHCONF_CHECKPERM|SSHCONF_USERCONF);
d393 23
a415 2
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw, host,
		    &options, 0);
d425 1
a425 1
	int i, r, opt, exit_status, use_syslog;
d503 1
a503 1
	    "ACD:E:F:I:KL:MNO:PQ:R:S:TVw:W:XYy")) != -1) {
d536 3
d787 3
a789 3
			if (process_config_line(&options, pw, host ? host : "",
			    line, "command-line", 0, NULL, SSHCONF_USERCONF)
			    != 0)
d898 1
a898 1
	process_config_files(pw);
d910 2
d946 2
a947 2
	 * If the target hostname has changed as a result of canonicalisation
	 * then re-parse the configuration files as new stanzas may match.
d949 13
a961 3
	if (strcasecmp(host_arg, host) != 0) {
		debug("Hostname has changed; re-reading configuration");
		process_config_files(pw);
d1058 5
@


1.406
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.405 2014/07/03 06:39:19 djm Exp $ */
d1314 7
d1340 1
@


1.405
log
@Add a %C escape sequence for LocalCommand and ControlPath that expands
to a unique identifer based on a has of the tuple of (local host,
remote user, hostname, port).

Helps avoid exceeding sockaddr_un's miserly pathname limits for mux
control paths.

bz#2220, based on patch from mancha1 AT zoho.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.404 2014/06/27 16:41:56 markus Exp $ */
d90 1
a92 1
#include "misc.h"
d412 1
a412 1
	Forward fwd;
d519 1
a519 1
			options.gateway_ports = 1;
d1259 1
a1259 1
	Forward *rfwd = (Forward *)ctxt;
d1264 6
a1269 4
	    rfwd->listen_host == NULL ? "" : rfwd->listen_host,
	    rfwd->listen_host == NULL ? "" : ":",
	    rfwd->listen_port, rfwd->connect_host, rfwd->connect_port);
	if (rfwd->listen_port == 0) {
d1283 15
a1297 6
		if (options.exit_on_forward_failure)
			fatal("Error: remote port forwarding failed for "
			    "listen port %d", rfwd->listen_port);
		else
			logit("Warning: remote port forwarding failed for "
			    "listen port %d", rfwd->listen_port);
d1345 2
d1348 1
a1348 1
		    (options.gateway_ports ? "*" : "LOCALHOST") :
d1351 2
d1356 1
a1356 5
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port,
		    options.gateway_ports);
d1367 2
d1372 2
d1378 1
a1378 4
		    options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
@


1.404
log
@fix remote fwding with same listen port but different listen address
with gerhard@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.403 2014/06/24 02:19:48 djm Exp $ */
d79 1
a181 1

d414 3
d976 10
d989 10
a998 3
		options.local_command = percent_expand(cp, "d", pw->pw_dir,
		    "h", host, "l", thishost, "n", host_arg, "r", options.user,
		    "p", portstr, "u", pw->pw_name, "L", shorthost,
d1008 9
a1016 3
		options.control_path = percent_expand(cp, "h", host,
		    "l", thishost, "n", host_arg, "r", options.user,
		    "p", portstr, "u", pw->pw_name, "L", shorthost,
d1020 2
@


1.403
log
@don't fatal() when hostname canonicalisation fails with a
ProxyCommand in use; continue and allow the ProxyCommand to
connect anyway (e.g. to a host with a name outside the DNS
behind a bastion)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.402 2014/04/29 18:01:49 markus Exp $ */
d1234 1
a1234 1
	debug("remote forward %s for: listen %d, connect %s:%d",
d1236 2
@


1.402
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.401 2014/02/26 20:18:37 djm Exp $ */
d905 8
a912 4
		if ((addrs = resolve_host(host, options.port, 1,
		    cname, sizeof(cname))) == NULL)
			cleanup_exit(255); /* resolve_host logs the error */
		check_follow_cname(&host, cname);
@


1.401
log
@bz#2205: avoid early hostname lookups unless canonicalisation is enabled;
ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.400 2014/02/23 20:11:36 djm Exp $ */
d67 1
d70 1
d608 7
a614 1
			    SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
d811 1
d814 1
d861 7
a867 1
		logit("%s, %s", SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
@


1.400
log
@reparse ssh_config and ~/.ssh/config if hostname canonicalisation changes
the hostname. This allows users to write configurations that always
refer to canonical hostnames, e.g.

CanonicalizeHostname yes
CanonicalDomains int.example.org example.org
CanonicalizeFallbackLocal no

Host *.int.example.org
    Compression off
Host *.example.org
    User djm

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.399 2014/02/04 00:24:29 djm Exp $ */
d874 11
a884 4
	 * If canonicalization not requested, or if it failed then try to
	 * resolve the bare hostname name using the system resolver's usual
	 * search rules. Skip the lookup if a ProxyCommand is being used
	 * unless the user has specifically requested canonicalisation.
d886 2
a887 1
	if (addrs == NULL && (option_clear_or_none(options.proxy_command) ||
d978 10
@


1.399
log
@delay lowercasing of hostname until right before hostname
canonicalisation to unbreak case-sensitive matching of ssh_config;
reported by Ike Devolder; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.398 2014/01/31 16:39:19 tedu Exp $ */
d221 6
d228 1
a228 1
resolve_host(const char *name, u_int port, int logerr, char *cname, size_t clen)
d234 3
d239 2
a240 1
	hints.ai_family = options.address_family;
d265 1
d282 1
a282 1
	if (options.proxy_command != NULL &&
d306 1
d309 1
a309 1
resolve_canonicalize(char **hostp, u_int port)
d317 1
d322 1
a322 1
	if (options.proxy_command != NULL &&
d325 1
d342 3
a344 1
		if ((addrs = resolve_host(fullhost, options.port, 0,
d361 2
a362 1
		fatal("%s: Could not resolve host \"%s\"", __progname, host);
d367 29
d853 20
d874 4
a877 2
	 * Read per-user configuration file.  Ignore the system wide config
	 * file if the user specifies a config file on the command line.
d879 7
a885 12
	if (config != NULL) {
		if (strcasecmp(config, "none") != 0 &&
		    !read_config_file(config, pw, host, &options,
		    SSHCONF_USERCONF))
			fatal("Can't open user config file %.100s: "
			    "%.100s", config, strerror(errno));
	} else {
		r = snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir,
		    _PATH_SSH_USER_CONFFILE);
		if (r > 0 && (size_t)r < sizeof(buf))
			(void)read_config_file(buf, pw, host, &options,
			     SSHCONF_CHECKPERM|SSHCONF_USERCONF);
d887 7
a893 3
		/* Read systemwide configuration file after user config. */
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw, host,
		    &options, 0);
d899 2
a937 31

	/* Get default port if port has not been set. */
	if (options.port == 0)
		options.port = default_ssh_port();

	/* preserve host name given on command line for %n expansion */
	if (options.hostname != NULL) {
		/* NB. Please keep in sync with readconf.c:match_cfg_line() */
		cp = percent_expand(options.hostname,
		    "h", host, (char *)NULL);
		free(host);
		host = cp;
	}

	/* If canonicalization requested then try to apply it */
	lowercase(host);
	if (options.canonicalize_hostname != SSH_CANONICALISE_NO)
		addrs = resolve_canonicalize(&host, options.port);
	/*
	 * If canonicalization not requested, or if it failed then try to
	 * resolve the bare hostname name using the system resolver's usual
	 * search rules. Skip the lookup if a ProxyCommand is being used
	 * unless the user has specifically requested canonicalisation.
	 */
	if (addrs == NULL && (options.proxy_command == NULL ||
            options.canonicalize_hostname == SSH_CANONICALISE_ALWAYS)) {
		if ((addrs = resolve_host(host, options.port, 1,
		    cname, sizeof(cname))) == NULL)
			cleanup_exit(255); /* resolve_host logs the error */
		check_follow_cname(&host, cname);
	}
@


1.398
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.397 2013/12/29 05:42:16 djm Exp $ */
a754 1
	lowercase(host);
d884 1
@


1.397
log
@don't forget to load Ed25519 certs too
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.396 2013/12/06 13:39:49 markus Exp $ */
d229 1
a229 1
	bzero(&hints, sizeof(hints));
d1652 2
a1653 2
	bzero(identity_files, sizeof(identity_files));
	bzero(identity_keys, sizeof(identity_keys));
d1728 1
a1728 1
	bzero(pwname, strlen(pwname));
d1730 1
a1730 1
	bzero(pwdir, strlen(pwdir));
@


1.396
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.395 2013/11/26 12:14:54 jmc Exp $ */
d964 1
a964 1
		sensitive_data.nkeys = 8;
d977 3
a979 1
		sensitive_data.keys[4] = key_load_private_type(KEY_DSA,
d981 1
a981 1
		sensitive_data.keys[5] = key_load_private_type(KEY_ECDSA,
d983 1
a983 1
		sensitive_data.keys[6] = key_load_private_type(KEY_RSA,
d985 1
a985 1
		sensitive_data.keys[7] = key_load_private_type(KEY_ED25519,
a990 1
		    sensitive_data.keys[4] == NULL &&
d993 2
a994 1
		    sensitive_data.keys[7] == NULL) {
d1001 3
a1003 1
			sensitive_data.keys[4] = key_load_public(
d1005 1
a1005 1
			sensitive_data.keys[5] = key_load_public(
d1007 1
a1007 1
			sensitive_data.keys[6] = key_load_public(
d1009 1
a1009 1
			sensitive_data.keys[7] = key_load_public(
@


1.395
log
@- put -Q in the right place
- Ar was a poor choice for the arguments to -Q. i've chosen an admittedly equally
poor Cm, at least consistent with the rest of the docs. also no need for multiple
instances
- zap a now redundant Nm
- usage() sync
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.394 2013/11/25 18:04:21 deraadt Exp $ */
d503 5
a507 1
				cp = key_alg_list();
d964 1
a964 1
		sensitive_data.nkeys = 7;
d983 2
d991 2
a992 1
		    sensitive_data.keys[6] == NULL) {
d1005 2
@


1.394
log
@improve -Q usage and such.  One usage change is that the option is now
case-sensitive
ok dtucker markus djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.393 2013/11/21 00:45:44 djm Exp $ */
d190 4
a193 4
"           [-O ctl_cmd] [-o option] [-p port] [-R [bind_address:]port:host:hostport]\n"
"           [-S ctl_path] [-Q cipher | cipher-auth | mac | kex | key]\n"
"           [-W host:port] [-w local_tun[:remote_tun]]\n"
"           [user@@]hostname [command]\n"
@


1.393
log
@Add a new protocol 2 transport cipher "chacha20-poly1305@@openssh.com"
that combines Daniel Bernstein's ChaCha20 stream cipher and Poly1305 MAC
to build an authenticated encryption mode.

Inspired by and similar to Adam Langley's proposal for TLS:
http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03
but differs in layout used for the MAC calculation and the use of a
second ChaCha20 instance to separately encrypt packet lengths.
Details are in the PROTOCOL.chacha20poly1305 file.

Feedback markus@@, naddy@@; manpage bits Loganden Velvindron @@ AfriNIC
ok markus@@ naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.392 2013/11/07 11:58:27 dtucker Exp $ */
d189 3
a191 3
"           [-L [bind_address:]port:host:hostport] [-Q protocol_feature]\n"
"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
"           [-R [bind_address:]port:host:hostport] [-S ctl_path]\n"
d492 1
a492 1
		case 'Q':	/* deprecated */
d494 1
a494 1
			if (strcasecmp(optarg, "cipher") == 0)
d496 1
a496 1
			else if (strcasecmp(optarg, "cipher-auth") == 0)
d498 1
a498 1
			else if (strcasecmp(optarg, "mac") == 0)
d500 1
a500 1
			else if (strcasecmp(optarg, "kex") == 0)
d502 1
a502 1
			else if (strcasecmp(optarg, "key") == 0)
@


1.392
log
@Output the effective values of Ciphers, MACs and KexAlgorithms when
the default has not been overridden.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.391 2013/10/25 23:04:51 djm Exp $ */
d495 3
a497 1
				cp = cipher_alg_list('\n');
@


1.391
log
@fix crash when using ProxyCommand caused by previous commit - was calling
freeaddrinfo(NULL); spotted by sthen@@ and Tim Ruehsen, patch by sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.390 2013/10/24 08:19:36 djm Exp $ */
d495 1
a495 1
				cp = cipher_alg_list();
d497 1
a497 1
				cp = mac_alg_list();
d499 1
a499 1
				cp = kex_alg_list();
@


1.390
log
@fix bug introduced in hostname canonicalisation commit: don't try to
resolve hostnames when a ProxyCommand is set unless the user has forced
canonicalisation; spotted by Iain Morgan
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.389 2013/10/23 03:05:19 djm Exp $ */
d936 3
a938 1
	freeaddrinfo(addrs);
@


1.389
log
@comment
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.388 2013/10/17 00:46:49 djm Exp $ */
d884 2
a885 1
	 * search rules.
d887 2
a888 1
	if (addrs == NULL) {
@


1.388
log
@rearrange check to reduce diff against -portable
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.387 2013/10/16 22:58:01 djm Exp $ */
d871 1
@


1.387
log
@one I missed in previous: s/isation/ization/
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.386 2013/10/16 22:49:39 djm Exp $ */
d836 2
d930 1
a930 1
	    original_effective_uid == 0 && options.use_privileged_port) != 0)
@


1.386
log
@s/canonicalise/canonicalize/ for consistency with existing spelling,
e.g. authorized_keys; pointed out by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.385 2013/10/16 02:31:46 djm Exp $ */
d293 2
a294 2
 * canonicalisation rules. Returns the address list for the host or NULL
 * if no name was found after canonicalisation.
d312 1
a312 1
	/* Don't apply canonicalisation to sufficiently-qualified hostnames */
d875 1
a875 1
	/* If canonicalisation requested then try to apply it */
d879 1
a879 1
	 * If canonicalisation not requested, or if it failed then try to
@


1.385
log
@Implement client-side hostname canonicalisation to allow an explicit
search path of domain suffixes to use to convert unqualified host names
to fully-qualified ones for host key matching.
This is particularly useful for host certificates, which would otherwise
need to list unqualified names alongside fully-qualified ones (and this
causes a number of problems).

"looks fine" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.384 2013/10/14 23:31:01 djm Exp $ */
d265 1
a265 1
	if (options.canonicalise_hostname == SSH_CANONICALISE_NO)
d268 1
a268 1
	 * Don't attempt to canonicalise names that will be interpreted by
d272 1
a272 1
	    options.canonicalise_hostname != SSH_CANONICALISE_ALWAYS)
d282 1
a282 1
		verbose("Canonicalised DNS aliased hostname "
d297 1
a297 1
resolve_canonicalise(char **hostp, u_int port)
d303 1
a303 1
	if (options.canonicalise_hostname == SSH_CANONICALISE_NO)
d306 1
a306 1
	 * Don't attempt to canonicalise names that will be interpreted by
d310 1
a310 1
	    options.canonicalise_hostname != SSH_CANONICALISE_ALWAYS)
d318 3
a320 3
	if (ndots > options.canonicalise_max_dots) {
		debug3("%s: not canonicalising hostname \"%s\" (max dots %d)",
		    __func__, *hostp, options.canonicalise_max_dots);
d337 1
a337 1
			debug("Canonicalised hostname \"%s\" => \"%s\"",
d344 1
a344 1
	if (!options.canonicalise_fallback_local)
d876 2
a877 2
	if (options.canonicalise_hostname != SSH_CANONICALISE_NO)
		addrs = resolve_canonicalise(&host, options.port);
@


1.384
log
@whitespace at EOL; pointed out by markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.383 2013/10/14 23:28:23 djm Exp $ */
d221 128
d358 1
d365 1
d735 1
a735 1
			host = ++cp;
d737 1
a737 1
			host = *av;
d749 3
a867 1
	host_arg = host;
d869 1
a869 1
		host = percent_expand(options.hostname,
d871 17
d925 4
a928 5
	if (ssh_connect(host, &hostaddr, options.port,
	    options.address_family, options.connection_attempts, &timeout_ms,
	    options.tcp_keep_alive,
	    original_effective_uid == 0 && options.use_privileged_port,
	    options.proxy_command) != 0)
d931 4
a1725 1

@


1.383
log
@refactor client config code a little:

add multistate option partsing to readconf.c, similar to servconf.c's
existing code.

move checking of options that accept "none" as an argument to readconf.c

add a lowercase() function and use it instead of explicit tolower() in
loops

part of a larger diff that was ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.382 2013/10/14 22:22:04 djm Exp $ */
d778 1
a778 1
	    options.tcp_keep_alive, 
d1030 1
a1030 1
	if (!compat20) 
d1202 1
a1202 1
		    options.forward_x11_trusted, 
@


1.382
log
@add a "Match" keyword to ssh_config that allows matching on hostname,
user and result of arbitrary commands. "nice work" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.381 2013/07/25 00:29:10 djm Exp $ */
d696 8
a755 18
	}

	/* force lowercase for hostkey matching */
	if (options.host_key_alias != NULL) {
		for (p = options.host_key_alias; *p; p++)
			if (isupper(*p))
				*p = (char)tolower(*p);
	}

	if (options.proxy_command != NULL &&
	    strcmp(options.proxy_command, "none") == 0) {
		free(options.proxy_command);
		options.proxy_command = NULL;
	}
	if (options.control_path != NULL &&
	    strcmp(options.control_path, "none") == 0) {
		free(options.control_path);
		options.control_path = NULL;
@


1.381
log
@daemonise backgrounded (ControlPersist'ed) multiplexing master to ensure
it is fully detached from its controlling terminal. based on debugging
and patch from tedu@@
ok dtucker@@ "be careful" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.380 2013/07/20 01:44:37 djm Exp $ */
d232 1
a232 1
	int dummy, timeout_ms;
a234 1
	struct servent *sp;
a567 1
			dummy = 1;
d569 2
a570 2
			if (process_config_line(&options, host ? host : "",
			    line, "command-line", 0, &dummy, SSHCONF_USERCONF)
d675 2
a676 1
		    !read_config_file(config, host, &options, SSHCONF_USERCONF))
d683 1
a683 1
			(void)read_config_file(buf, host, &options,
d687 1
a687 1
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host,
d723 2
a724 4
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}
@


1.380
log
@More useful error message on missing current user in /etc/passwd
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.379 2013/07/12 05:48:55 djm Exp $ */
d974 1
@


1.379
log
@set TCP nodelay for connections started with -N; bz#2124 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.378 2013/05/17 00:13:14 djm Exp $ */
d273 1
a273 1
		logit("You don't exist, go away!");
@


1.378
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.377 2013/04/19 11:10:18 djm Exp $ */
d1432 5
@


1.377
log
@add -Q to usage; reminded by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.376 2013/04/19 01:06:50 djm Exp $ */
d216 1
a216 1
		xfree(paths[i]);
d447 1
a447 1
				xfree(fwd.connect_host);
d575 1
a575 1
			xfree(line);
d662 1
a662 1
		xfree(logfile);
d750 1
a750 1
		xfree(cp);
d762 1
a762 1
		xfree(options.proxy_command);
d767 1
a767 1
		xfree(options.control_path);
d774 1
a774 1
		xfree(options.control_path);
d779 1
a779 1
		xfree(cp);
d910 1
a910 1
		xfree(sensitive_data.keys);
d913 2
a914 4
		if (options.identity_files[i]) {
			xfree(options.identity_files[i]);
			options.identity_files[i] = NULL;
		}
d1504 1
a1504 1
		xfree(keys);
d1517 1
a1517 1
			xfree(options.identity_files[i]);
d1525 1
a1525 1
		xfree(cp);
d1529 1
a1529 1
		xfree(options.identity_files[i]);
d1542 1
a1542 1
			xfree(cp);
d1549 1
a1549 1
			xfree(cp);
d1562 1
a1562 1
	xfree(pwname);
d1564 1
a1564 1
	xfree(pwdir);
@


1.376
log
@add the ability to query supported ciphers, MACs, key type and KEX
algorithms to ssh. Includes some refactoring of KEX and key type handling
to be table-driven; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.375 2013/04/07 02:10:33 dtucker Exp $ */
d189 1
a189 1
"           [-L [bind_address:]port:host:hostport]\n"
@


1.375
log
@Add -E option to ssh and sshd to append debugging logs to a specified file
instead of stderr or syslog.  ok markus@@, man page help jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.374 2013/03/08 06:32:58 djm Exp $ */
d301 1
a301 1
	    "ACD:E:F:I:KL:MNO:PR:S:TVw:W:XYy")) != -1) {
d362 16
@


1.374
log
@allow "ssh -f none ..." ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.373 2013/02/22 22:09:01 djm Exp $ */
d187 2
a188 2
"           [-D [bind_address:]port] [-e escape_char] [-F configfile]\n"
"           [-I pkcs11] [-i identity_file]\n"
d228 1
a228 1
	char *p, *cp, *line, *argv0, buf[MAXPATHLEN], *host_arg;
d296 1
d301 1
a301 1
	    "ACD:F:I:KL:MNO:PR:S:TVw:W:XYy")) != -1) {
d331 3
a404 1
				break;
d406 1
a406 1
			/* FALLTHROUGH */
d640 1
a640 1
	 * actually goes to stderr.
d642 6
d651 3
@


1.373
log
@Allow IdenityFile=none; ok markus deraadt (and dtucker for an earlier
version)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.372 2013/02/22 04:45:09 dtucker Exp $ */
d648 2
a649 1
		if (!read_config_file(config, host, &options, SSHCONF_USERCONF))
@


1.372
log
@Don't complain if IdentityFiles specified in system-wide configs are missing.
ok djm, deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.371 2013/02/17 23:16:57 dtucker Exp $ */
d1488 2
a1489 1
		if (n_ids >= SSH_MAX_IDENTITY_FILES) {
@


1.371
log
@Keep track of which IndentityFile options were manually supplied and which
were default options, and don't warn if the latter are missing.  ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.370 2012/07/06 01:47:38 djm Exp $ */
d553 2
a554 1
			    line, "command-line", 0, &dummy) != 0)
d648 1
a648 1
		if (!read_config_file(config, host, &options, 0))
d655 2
a656 1
			(void)read_config_file(buf, host, &options, 1);
@


1.370
log
@move setting of tty_flag to after config parsing so RequestTTY options
are correctly picked up. bz#1995 patch from przemoc AT gmail.com;
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.369 2012/07/02 08:50:03 dtucker Exp $ */
d379 1
a379 6
			if (options.num_identity_files >=
			    SSH_MAX_IDENTITY_FILES)
				fatal("Too many identity files specified "
				    "(max %d)", SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] =
			    xstrdup(optarg);
@


1.369
log
@set interactive ToS for forwarded X11 sessions.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.368 2011/10/24 02:10:46 djm Exp $ */
a611 4
	if (options.request_tty == REQUEST_TTY_YES ||
	    options.request_tty == REQUEST_TTY_FORCE)
		tty_flag = 1;

a618 1
		tty_flag = options.request_tty != REQUEST_TTY_NO;
a638 16
	/* Allocate a tty by default if no command specified. */
	if (buffer_len(&command) == 0)
		tty_flag = options.request_tty != REQUEST_TTY_NO;

	/* Force no tty */
	if (options.request_tty == REQUEST_TTY_NO || muxclient_command != 0)
		tty_flag = 0;
	/* Do not allocate a tty if stdin is not a tty. */
	if ((!isatty(fileno(stdin)) || stdin_null_flag) &&
	    options.request_tty != REQUEST_TTY_FORCE) {
		if (tty_flag)
			logit("Pseudo-terminal will not be allocated because "
			    "stdin is not a terminal.");
		tty_flag = 0;
	}

d673 20
@


1.368
log
@bz#1943: unbreak stdio forwarding when ControlPersist is in user - ssh
was incorrectly requesting the forward in both the control master and
slave. skip requesting it in the master to fix. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.367 2011/10/18 05:15:28 djm Exp $ */
d1310 4
@


1.367
log
@ssh(1): skip attempting to create ~/.ssh when -F is passed; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.366 2011/09/23 07:45:05 markus Exp $ */
d1011 2
a1012 2
static int
client_setup_stdio_fwd(const char *host_to_connect, u_short port_to_connect)
d1017 6
a1022 2
	debug3("client_setup_stdio_fwd %s:%d", host_to_connect,
	    port_to_connect);
d1024 2
a1025 3
	in = dup(STDIN_FILENO);
	out = dup(STDOUT_FILENO);
	if (in < 0 || out < 0)
d1027 3
a1029 4

	if ((c = channel_connect_stdio_fwd(host_to_connect, port_to_connect,
	    in, out)) == NULL)
		return 0;
a1030 1
	return 1;
a1038 9
	if (stdio_forward_host != NULL) {
		if (!compat20) {
			fatal("stdio forwarding require Protocol 2");
		}
		if (!client_setup_stdio_fwd(stdio_forward_host,
		    stdio_forward_port))
			fatal("Failed to connect in stdio forward mode.");
	}

d1229 1
d1368 2
d1376 4
a1379 3
	 * If we are in control persist mode, then prepare to background
	 * ourselves and have a foreground client attach as a control
	 * slave. NB. we must save copies of the flags that we override for
d1396 6
@


1.366
log
@unbreak remote portforwarding with dynamic allocated listen ports:
1) send the actual listen port in the open message (instead of 0).
   this allows multiple forwardings with a dynamic listen port
2) update the matching permit-open entry, so we can identify where
   to connect to
report: den at skbkontur.ru and P. Szczygielski
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.365 2011/09/09 22:46:44 djm Exp $ */
d844 8
a851 5
	r = snprintf(buf, sizeof buf, "%s%s%s", pw->pw_dir,
	    strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
	if (r > 0 && (size_t)r < sizeof(buf) && stat(buf, &st) < 0)
		if (mkdir(buf, 0700) < 0)
			error("Could not create directory '%.200s'.", buf);
@


1.365
log
@support for cancelling local and remote port forwards via the multiplex
socket. Use ssh -O cancel -L xx:xx:xx -R yy:yy:yy user@@host" to request
the cancellation of the specified forwardings; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.364 2011/08/02 23:15:03 djm Exp $ */
d973 11
a983 5
	if (type == SSH2_MSG_REQUEST_SUCCESS && rfwd->listen_port == 0) {
		rfwd->allocated_port = packet_get_int();
		logit("Allocated port %u for remote forward to %s:%d",
		    rfwd->allocated_port,
		    rfwd->connect_host, rfwd->connect_port);
d1075 2
a1076 1
		if (channel_request_remote_forwarding(
d1080 2
a1081 1
		    options.remote_forwards[i].connect_port) < 0) {
d1087 3
a1090 2
		client_register_global_confirm(ssh_confirm_remote_forward,
		    &options.remote_forwards[i]);
@


1.364
log
@typo in comment
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.363 2011/06/22 22:08:42 djm Exp $ */
d351 2
@


1.363
log
@hook up a channel confirm callback to warn the user then requested X11
forwarding was refused by the server; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.362 2011/06/03 00:54:38 djm Exp $ */
d680 1
a680 1
		/* Read systemwide configuration file after use config. */
@


1.362
log
@bz#1883 - setproctitle() to identify mux master; patch from Bert.Wesarg
AT googlemail.com; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.361 2011/05/24 07:15:47 djm Exp $ */
d1191 2
a1192 2
		x11_request_forwarding_with_spoofing(0, display, proto, data);

d1290 4
a1293 1
		x11_request_forwarding_with_spoofing(id, display, proto, data);
a1294 1
		/* XXX wait for reply */
@


1.361
log
@Remove undocumented legacy options UserKnownHostsFile2 and
GlobalKnownHostsFile2 by making UserKnownHostsFile/GlobalKnownHostsFile
accept multiple paths per line and making their defaults include
known_hosts2; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.360 2011/05/06 21:38:58 djm Exp $ */
d946 1
@


1.360
log
@fix dropping from previous diff
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.359 2011/05/06 21:34:32 djm Exp $ */
d207 14
d852 3
a854 9
	/* XXX mem-leaks: */
	options.system_hostfile =
	    tilde_expand_filename(options.system_hostfile, original_real_uid);
	options.user_hostfile =
	    tilde_expand_filename(options.user_hostfile, original_real_uid);
	options.system_hostfile2 =
	    tilde_expand_filename(options.system_hostfile2, original_real_uid);
	options.user_hostfile2 =
	    tilde_expand_filename(options.user_hostfile2, original_real_uid);
@


1.359
log
@Add a RequestTTY ssh_config option to allow configuration-based
control over tty allocation (like -t/-T); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.358 2011/05/06 21:18:02 djm Exp $ */
a1369 1
 		options.request_tty == REQUEST_TTY_NO;
@


1.358
log
@add a %L expansion (short-form of the local host name) for ControlPath;
sync some more expansions with LocalCommand; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.357 2011/04/17 22:42:42 djm Exp $ */
d108 1
a108 1
/* Flag indicating whether a tty should be allocated */
a109 2
int no_tty_flag = 0;
int force_tty_flag = 0;
d127 1
a127 1
int ostdin_null_flag, ono_shell_flag, ono_tty_flag, otty_flag;
d378 4
a381 3
			if (tty_flag)
				force_tty_flag = 1;
			tty_flag = 1;
d424 1
a424 1
			no_tty_flag = 1;
d533 1
a533 1
			no_tty_flag = 1;
d536 1
a536 1
			no_tty_flag = 1;
d596 4
d607 1
a607 1
		tty_flag = 1;
d630 1
a630 1
		tty_flag = 1;
d633 1
a633 1
	if (no_tty_flag || muxclient_command != 0)
d636 2
a637 1
	if ((!isatty(fileno(stdin)) || stdin_null_flag) && !force_tty_flag) {
d919 1
a919 2
		no_shell_flag = ono_shell_flag;
		no_tty_flag = ono_tty_flag;
d1366 1
a1366 1
		ono_tty_flag = no_tty_flag;
d1370 1
a1370 1
 		no_tty_flag = 1;
@


1.357
log
@allow graceful shutdown of multiplexing: request that a mux server removes
its listener socket and refuse future multiplexing requests; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.356 2011/01/06 22:23:53 djm Exp $ */
d217 1
d691 6
a697 5
		char thishost[NI_MAXHOST];

		if (gethostname(thishost, sizeof(thishost)) == -1)
			fatal("gethostname: %s", strerror(errno));
		snprintf(buf, sizeof(buf), "%d", options.port);
d702 2
a703 1
		    "p", buf, "u", pw->pw_name, (char *)NULL);
a726 5
		char thishost[NI_MAXHOST];

		if (gethostname(thishost, sizeof(thishost)) == -1)
			fatal("gethostname: %s", strerror(errno));
		snprintf(buf, sizeof(buf), "%d", options.port);
d730 4
a733 2
		options.control_path = percent_expand(cp, "p", buf, "h", host,
		    "r", options.user, "l", thishost, (char *)NULL);
@


1.356
log
@unbreak %n expansion in LocalCommand; patch from bert.wesarg AT
googlemail.com; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.355 2010/11/29 23:45:51 djm Exp $ */
d336 2
@


1.355
log
@automatically order the hostkeys requested by the client based on
which hostkeys are already recorded in known_hosts. This avoids
hostkey warnings when connecting to servers with new ECDSA keys
that are preferred by default; with markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.354 2010/11/13 23:27:50 djm Exp $ */
d216 1
a216 1
	char *p, *cp, *line, *argv0, buf[MAXPATHLEN];
d681 2
d697 1
a697 1
		    "h", host, "l", thishost, "n", host, "r", options.user,
@


1.354
log
@allow ssh and sshd to set arbitrary TOS/DSCP/QoS values instead of
hardcoding lowdelay/throughput.

bz#1733 patch from philipp AT redfish-solutions.com; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.353 2010/10/06 06:39:28 djm Exp $ */
d845 1
a845 1
	    pw, timeout_ms);
@


1.353
log
@kill proxy command on fatal() (we already kill it on clean exit);
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.352 2010/09/20 04:41:47 djm Exp $ */
d1189 2
a1190 1
	packet_set_interactive(interactive);
a1287 2

	packet_set_interactive(interactive);
@


1.352
log
@install a SIGCHLD handler to reap expiried child process; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.351 2010/09/02 16:08:39 markus Exp $ */
a176 3
/* pid of proxycommand child process */
pid_t proxy_command_pid = 0;

d883 2
a884 6
	/*
	 * Send SIGHUP to proxy command if used. We don't wait() in
	 * case it hangs and instead rely on init to reap the child
	 */
	if (proxy_command_pid > 1)
		kill(proxy_command_pid, SIGHUP);
@


1.351
log
@unbreak ControlPersist=yes for ControlMaster=yes; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.350 2010/08/31 12:33:38 djm Exp $ */
d52 1
d206 1
d844 1
d1513 16
@


1.350
log
@reintroduce commit from tedu@@, which I pulled out for release engineering:

  OpenSSL_add_all_algorithms is the name of the function we have a man page
  for, so use that.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.347 2010/08/12 23:34:39 tedu Exp $ */
d920 1
@


1.349
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.348 2010/08/16 04:06:06 djm Exp $ */
d589 1
a589 1
	SSLeay_add_all_algorithms();
@


1.348
log
@backout previous temporarily; discussed with deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.346 2010/08/12 21:49:44 djm Exp $ */
d764 1
a764 1
		sensitive_data.nkeys = 5;
d773 3
a775 1
		sensitive_data.keys[2] = key_load_private_cert(KEY_RSA,
d777 1
a777 1
		sensitive_data.keys[3] = key_load_private_type(KEY_DSA,
d779 3
a781 1
		sensitive_data.keys[4] = key_load_private_type(KEY_RSA,
d787 3
a789 2
		    sensitive_data.keys[3] == NULL &&
		    sensitive_data.keys[4] == NULL) {
d793 2
d796 1
a796 1
			sensitive_data.keys[3] = key_load_public(
d798 3
a800 1
			sensitive_data.keys[4] = key_load_public(
@


1.347
log
@OpenSSL_add_all_algorithms is the name of the function we have a man page
for, so use that.  ok djm
@
text
@d589 1
a589 1
	OpenSSL_add_all_algorithms();
@


1.346
log
@close any extra file descriptors inherited from parent at start and
reopen stdin/stdout to /dev/null when forking for ControlPersist.

prevents tools that fork and run a captive ssh for communication from
failing to exit when the ssh completes while they wait for these fds to
close. The inherited fds may persist arbitrarily long if a background
mux master has been started by ControlPersist. cvs and scp were effected
by this.

"please commit" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.345 2010/08/04 05:42:47 djm Exp $ */
d589 1
a589 1
	SSLeay_add_all_algorithms();
@


1.345
log
@enable certificates for hostbased authentication, from Iain Morgan;
"looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.344 2010/07/19 09:15:12 djm Exp $ */
d230 6
d888 1
d915 10
@


1.344
log
@add a "ControlPersist" option that automatically starts a background
ssh(1) multiplex master when connecting. This connection can stay alive
indefinitely, or can be set to automatically close after a user-specified
duration of inactivity. bz#1330 - patch by dwmw2 AT infradead.org, but
further hacked on by wmertens AT cisco.com, apb AT cequrux.com,
martin-mindrot-bugzilla AT earth.li and myself; "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.343 2010/07/12 22:41:13 djm Exp $ */
d758 1
a758 1
		sensitive_data.nkeys = 3;
d765 5
a769 1
		sensitive_data.keys[1] = key_load_private_type(KEY_DSA,
d771 1
a771 1
		sensitive_data.keys[2] = key_load_private_type(KEY_RSA,
d777 7
a783 3
		    sensitive_data.keys[1] == NULL &&
		    sensitive_data.keys[2] == NULL) {
			sensitive_data.keys[1] = key_load_public(
d785 1
a785 1
			sensitive_data.keys[2] = key_load_public(
@


1.343
log
@expand %h to the hostname in ssh_config Hostname options. While this
sounds useless, it is actually handy for working with unqualified
hostnames:

Host *.*
	Hostname %h
Host *
	Hostname %h.example.org

"I like it" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.342 2010/07/12 22:38:52 djm Exp $ */
d122 9
d870 44
d941 2
a942 6
		if (fork_after_authentication_flag) {
			fork_after_authentication_flag = 0;
			if (daemon(1, 1) < 0)
				fatal("daemon() failed: %.200s",
				    strerror(errno));
		}
d1186 7
a1192 6
	if (fork_after_authentication_flag &&
	    (!options.exit_on_forward_failure ||
	    options.num_remote_forwards == 0)) {
		fork_after_authentication_flag = 0;
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));
d1315 25
a1357 3
	/* Start listening for multiplex clients */
	muxserver_listen();

d1362 7
a1368 6
	if (fork_after_authentication_flag &&
	    (!options.exit_on_forward_failure ||
	    options.num_remote_forwards == 0)) {
		fork_after_authentication_flag = 0;
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));
@


1.342
log
@Make ExitOnForwardFailure work with fork-after-authentication ("ssh -f")
for protocol 2. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.341 2010/06/26 23:04:04 djm Exp $ */
d667 5
d681 2
a682 3
		    "h", options.hostname? options.hostname : host,
                    "l", thishost, "n", host, "r", options.user, "p", buf,
                    "u", pw->pw_name, (char *)NULL);
a685 3

	if (options.hostname != NULL)
		host = options.hostname;
@


1.341
log
@oops, forgot to #include <canohost.h>; spotted and patch from chl@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.340 2010/06/25 23:15:36 djm Exp $ */
d1285 7
a1291 2
	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag) {
@


1.340
log
@Add X11ForwardTimeout option to specify timeout for untrusted X11
authentication cookies to avoid fallback in X11 code to fully-trusted
implicit authentication using SO_PEERCRED described at:
http://lists.x.org/archives/xorg-devel/2010-May/008636.html

After the X11ForwardTimeout has expired the client will now refuse
incoming X11 channel opens.

based on patch from Tavis Ormandy; "nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.339 2010/06/25 23:10:30 djm Exp $ */
d73 1
@


1.339
log
@log the hostname and address that we connected to at LogLevel=verbose
after authentication is successful to mitigate "phishing" attacks by
servers with trusted keys that accept authentication silently and
automatically before presenting fake password/passphrase prompts;
"nice!" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.338 2010/05/16 12:55:51 markus Exp $ */
d1087 3
a1089 1
		    options.forward_x11_trusted, &proto, &data);
d1185 2
a1186 1
		    options.forward_x11_trusted, &proto, &data);
@


1.338
log
@mux support for remote forwarding with dynamic port allocation,
use with
	LPORT=`ssh -S muxsocket -R0:localhost:25 -O forward somehost`
feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.337 2010/05/14 23:29:23 djm Exp $ */
d812 7
@


1.337
log
@Pause the mux channel while waiting for reply from aynch callbacks.
Prevents misordering of replies if new requests arrive while waiting.

Extend channel open confirm callback to allow signalling failure
conditions as well as success. Use this to 1) fix a memory leak, 2)
start using the above pause mechanism and 3) delay sending a success/
failure message on mux slave session open until we receive a reply from
the server.

motivated by and with feedback from markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.336 2010/04/10 00:00:16 djm Exp $ */
d317 2
d863 1
d865 2
a866 2
			packet_get_int(),
			rfwd->connect_host, rfwd->connect_port);
@


1.336
log
@bz#1746 - suppress spurious tty warning when using -O and stdin
is not a tty; ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.335 2010/02/26 20:29:54 djm Exp $ */
d1159 1
a1159 1
ssh_session2_setup(int id, void *arg)
d1164 3
@


1.335
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.334 2010/02/08 22:03:05 jmc Exp $ */
d610 1
a610 1
	if (no_tty_flag)
@


1.334
log
@tweak previous; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.333 2010/02/08 10:50:20 markus Exp $ */
d1290 3
d1296 1
d1298 5
a1307 1
		int count = 0;
d1309 6
a1314 10
			count++;
			memmove(&options.identity_files[1],
			    &options.identity_files[0],
			    sizeof(char *) * (SSH_MAX_IDENTITY_FILES - 1));
			memmove(&options.identity_keys[1],
			    &options.identity_keys[0],
			    sizeof(Key *) * (SSH_MAX_IDENTITY_FILES - 1));
			options.num_identity_files++;
			options.identity_keys[0] = keys[i];
			options.identity_files[0] =
d1316 1
a1317 3
		if (options.num_identity_files > SSH_MAX_IDENTITY_FILES)
			options.num_identity_files = SSH_MAX_IDENTITY_FILES;
		i = count;
a1318 1
		/* XXX leaks some keys */
d1328 5
a1332 1
	for (; i < options.num_identity_files; i++) {
d1343 31
a1373 3
		options.identity_files[i] = filename;
		options.identity_keys[i] = public;
	}
@


1.333
log
@replace our obsolete smartcard code with PKCS#11.
	ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v2-20/pkcs-11v2-20.pdf
ssh(1) and ssh-keygen(1) use dlopen(3) directly to talk to a PKCS#11
provider (shared library) while ssh-agent(1) delegates PKCS#11 to
a forked a ssh-pkcs11-helper process.
PKCS#11 is currently a compile time option.
feedback and ok djm@@; inspired by patches from Alon Bar-Lev
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.332 2010/01/26 01:28:35 djm Exp $ */
d182 2
a183 1
"           [-i identity_file] [-L [bind_address:]port:host:hostport]\n"
@


1.332
log
@rewrite ssh(1) multiplexing code to a more sensible protocol.

The new multiplexing code uses channels for the listener and
accepted control sockets to make the mux master non-blocking, so
no stalls when processing messages from a slave.

avoid use of fatal() in mux master protocol parsing so an errant slave
process cannot take down a running master.

implement requesting of port-forwards over multiplexed sessions. Any
port forwards requested by the slave are added to those the master has
established.

add support for stdio forwarding ("ssh -W host:port ...") in mux slaves.

document master/slave mux protocol so that other tools can use it to
control a running ssh(1). Note: there are no guarantees that this
protocol won't be incompatibly changed (though it is versioned).

feedback Salvador Fandino, dtucker@@
channel changes ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.331 2010/01/11 01:39:46 dtucker Exp $ */
d97 2
a98 2
#ifdef SMARTCARD
#include "scard.h"
d352 2
a353 2
#ifdef SMARTCARD
			options.smartcard_device = xstrdup(optarg);
d355 1
a355 1
			fprintf(stderr, "no support for smartcards.\n");
d1289 1
a1289 1
#ifdef SMARTCARD
d1291 1
d1293 1
a1293 1
	if (options.smartcard_device != NULL &&
d1295 3
a1297 1
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL) {
d1299 1
a1299 1
		for (i = 0; keys[i] != NULL; i++) {
d1309 2
a1310 1
			options.identity_files[0] = sc_get_key_label(keys[i]);
d1316 1
d1318 1
a1318 1
#endif /* SMARTCARD */
@


1.331
log
@Add a 'netcat mode' (ssh -W).  This connects stdio on the client to a single
port forward on the server.  This allows, for example, using ssh as
a ProxyCommand to route connections via intermediate servers.
bz #1618, man page help from jmc@@, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.330 2010/01/09 23:04:13 dtucker Exp $ */
d309 5
d390 4
d895 1
d899 8
a906 2
	if ((c = channel_connect_stdio_fwd(host_to_connect, port_to_connect))
	    == NULL)
@


1.330
log
@Remove RoutingDomain from ssh since it's now not needed.  It can be replaced
with "route exec" or "nc -V" as a proxycommand.  "route exec" also ensures
that trafic such as DNS lookups stays withing the specified routingdomain.

For example (from reyk):
# route -T 2 exec /usr/sbin/sshd
or inherited from the parent process
$ route -T 2 exec sh
$ ssh 10.1.2.3

ok deraadt@@ markus@@ stevesk@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.327 2009/10/24 11:23:42 andreas Exp $ */
d127 4
d185 2
a186 1
"           [-w local_tun[:remote_tun]] [user@@]hostname [command]\n"
d271 1
a271 1
	    "ACD:F:I:KL:MNO:PR:S:TVw:XYy")) != -1) {
d384 16
d876 21
d901 9
@


1.329
log
@When passing user-controlled options with arguments to other programs,
pass the option and option argument as separate argv entries and
not smashed into one (e.g., as -l foo and not -lfoo).  Also, always
pass a "--" argument to stop option parsing, so that a positional
argument that starts with a '-' isn't treated as an option.  This
fixes some error cases as well as the handling of hostnames and
filenames that start with a '-'.

Based on a diff by halex@@
ok halex@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.328 2009/10/28 16:38:18 reyk Exp $ */
a619 1
	channel_set_rdomain(options.rdomain);
@


1.328
log
@Allow to set the rdomain in ssh/sftp/scp/sshd and ssh-keyscan.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.327 2009/10/24 11:23:42 andreas Exp $ */
d518 1
a518 1
	if (ac > 0 && !host && **av != '-') {
@


1.327
log
@Request roaming to be enabled if UseRoaming is true and the server
supports it.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.326 2009/07/02 02:11:47 dtucker Exp $ */
d620 1
@


1.326
log
@allow for long home dir paths (bz #1615).  ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.325 2009/03/17 21:37:00 markus Exp $ */
d94 1
d1206 3
@


1.325
log
@pass correct argv[0] to openlog(); ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.324 2009/02/12 03:00:56 djm Exp $ */
d45 1
d199 2
a200 2
	int i, opt, exit_status, use_syslog;
	char *p, *cp, *line, *argv0, buf[256];
d605 1
a605 1
		snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir,
d607 2
a608 1
		(void)read_config_file(buf, host, &options, 1);
d753 1
a753 1
	snprintf(buf, sizeof buf, "%.100s%s%.100s", pw->pw_dir,
d755 1
a755 1
	if (stat(buf, &st) < 0)
@


1.324
log
@support remote port forwarding with a zero listen port (-R0:...) to
dyamically allocate a listen port at runtime (this is actually
specified in rfc4254); bz#1003 ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.323 2009/01/22 10:02:34 djm Exp $ */
d199 1
a199 1
	char *p, *cp, *line, buf[256];
d260 1
d591 1
a591 1
	log_init(av[0],
d619 1
a619 1
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, !use_syslog);
@


1.323
log
@make a2port() return -1 when it encounters an invalid port number
rather than 0, which it will now treat as valid (needed for future work)

adjust current consumers of a2port() to check its return value is <= 0,
which in turn required some things to be converted from u_short => int

make use of int vs. u_short consistent in some other places too

feedback & ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.322 2008/11/01 17:40:33 stevesk Exp $ */
d443 1
a443 1
			if (parse_forward(&fwd, optarg, 0))
d454 1
a454 1
			if (parse_forward(&fwd, optarg, 0)) {
d465 1
a465 1
			if (parse_forward(&fwd, optarg, 1)) {
d821 1
d825 6
@


1.322
log
@merge dynamic forward parsing into parse_forward(); 'i think this is OK' djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.321 2008/10/09 06:54:22 jmc Exp $ */
d433 1
a433 1
			if (options.port == 0) {
@


1.321
log
@add -y to usage();
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.320 2008/10/08 23:34:03 djm Exp $ */
d443 1
a443 1
			if (parse_forward(&fwd, optarg))
d454 1
a454 1
			if (parse_forward(&fwd, optarg)) {
d465 2
a466 12
			cp = p = xstrdup(optarg);
			memset(&fwd, '\0', sizeof(fwd));
			fwd.connect_host = "socks";
			if ((fwd.listen_host = hpdelim(&cp)) == NULL) {
				fprintf(stderr, "Bad dynamic forwarding "
				    "specification '%.100s'\n", optarg);
				exit(255);
			}
			if (cp != NULL) {
				fwd.listen_port = a2port(cp);
				fwd.listen_host =
				    cleanhostname(fwd.listen_host);
d468 3
a470 7
				fwd.listen_port = a2port(fwd.listen_host);
				fwd.listen_host = NULL;
			}

			if (fwd.listen_port == 0) {
				fprintf(stderr, "Bad dynamic port '%s'\n",
				    optarg);
a472 2
			add_local_forward(&options, &fwd);
			xfree(p);
@


1.320
log
@Add -y option to force logging via syslog rather than stderr.
Useful for daemonised ssh connection (ssh -f). Patch originally from
and ok'd by markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.319 2008/09/11 14:22:37 markus Exp $ */
d174 1
a174 1
"usage: ssh [-1246AaCfgKkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
@


1.319
log
@only send eow and no-more-sessions requests to openssh 5 and newer;
fixes interop problems with broken ssh v2 implementations; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.318 2008/07/02 13:47:39 djm Exp $ */
d198 1
a198 1
	int i, opt, exit_status;
d259 1
d263 1
a263 1
	    "ACD:F:I:KL:MNO:PR:S:TVw:XY")) != -1) {
d290 3
d608 1
a608 1
	    SYSLOG_FACILITY_USER, 1);
d634 1
a634 1
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 1);
@


1.318
log
@When forking after authentication ("ssh -f") with ExitOnForwardFailure
enabled, delay the fork until after replies for any -R forwards have
been seen. Allows for robust detection of -R forward failure when
using -f (similar to bz#92); ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.317 2008/06/12 16:35:31 dtucker Exp $ */
d1184 2
a1185 1
	if (options.control_master == SSHCTL_MASTER_NO) {
@


1.317
log
@keyword expansion for localcommand.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.316 2008/06/12 04:24:06 djm Exp $ */
d844 1
a844 1
	if (++remote_forward_confirms_received == options.num_remote_forwards)
d846 7
a852 1
		/* XXX fork-after-authentication */
d1052 8
a1059 2
	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag)
d1062 1
d1201 2
a1202 1
	if (fork_after_authentication_flag)
d1205 1
@


1.316
log
@thal shalt not code past the eightieth column
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.315 2008/06/12 04:06:00 djm Exp $ */
d635 22
a664 6
	}

	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
@


1.315
log
@maintain an ordered queue of outstanding global requests that we
expect replies to, similar to the per-channel confirmation queue.

Use this queue to verify success or failure for remote forward
establishment in a race free way.

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.314 2008/06/10 22:15:23 djm Exp $ */
d101 1
a101 1
/* Flag indicating whether debug mode is on.  This can be set on the command line. */
d251 4
a254 1
	/* Initialize option structure to indicate that no values have been set. */
d261 2
a262 2
	while ((opt = getopt(ac, av,
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:KL:MNO:PR:S:TVw:XY")) != -1) {
d367 2
a368 1
				fprintf(stderr, "Bad tun device '%s'\n", optarg);
d471 2
a472 1
				fwd.listen_host = cleanhostname(fwd.listen_host);
d578 4
a581 2
	if (fork_after_authentication_flag && buffer_len(&command) == 0 && !no_shell_flag)
		fatal("Cannot fork into background without a command to execute.");
d593 2
a594 1
			logit("Pseudo-terminal will not be allocated because stdin is not a terminal.");
d602 2
a603 1
	log_init(av[0], options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
d746 2
a747 1
	snprintf(buf, sizeof buf, "%.100s%s%.100s", pw->pw_dir, strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
d768 1
a768 1
	/* Log into the remote system.  This never returns if the login fails. */
d919 2
a920 1
		debug("Requesting compression at level %d.", options.compression_level);
d922 4
a925 2
		if (options.compression_level < 1 || options.compression_level > 9)
			fatal("Compression level must be from 1 (fast) to 9 (slow, best).");
d938 2
a939 1
			packet_disconnect("Protocol error waiting for compression response.");
d976 2
a977 1
			logit("Warning: Remote host failed or refused to allocate a pseudo tty.");
d979 2
a980 1
			packet_disconnect("Protocol error waiting for pty request response.");
d990 2
a991 1
		debug("Requesting X11 forwarding with authentication spoofing.");
d1001 2
a1002 1
			packet_disconnect("Protocol error waiting for X11 forwarding");
d1043 2
a1044 1
		debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
d1076 2
a1077 1
		debug("Requesting X11 forwarding with authentication spoofing.");
d1197 2
a1198 1
			memmove(&options.identity_files[1], &options.identity_files[0],
d1200 2
a1201 1
			memmove(&options.identity_keys[1], &options.identity_keys[0],
a1238 1

@


1.314
log
@Add a no-more-sessions@@openssh.com global request extension that the
client sends when it knows that it will never request another session
(i.e. when session multiplexing is disabled). This allows a server to
disallow further session requests and terminate the session.

Why would a non-multiplexing client ever issue additional session
requests? It could have been attacked with something like SSH'jack:
http://www.storm.net.nz/projects/7

feedback & ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.313 2008/05/09 14:26:08 djm Exp $ */
d158 1
a158 1
static int client_global_request_id = 0;
d801 22
d871 2
a1039 25
}

void
client_global_request_reply_fwd(int type, u_int32_t seq, void *ctxt)
{
	int i;

	i = client_global_request_id++;
	if (i >= options.num_remote_forwards)
		return;
	debug("remote forward %s for: listen %d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    options.remote_forwards[i].listen_port,
	    options.remote_forwards[i].connect_host,
	    options.remote_forwards[i].connect_port);
	if (type == SSH2_MSG_REQUEST_FAILURE) {
		if (options.exit_on_forward_failure)
			fatal("Error: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
		else
			logit("Warning: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
	}
@


1.313
log
@dingo stole my diff hunk
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.312 2008/05/09 14:18:44 djm Exp $ */
d1134 9
@


1.312
log
@tidy up session multiplexing code, moving it into its own file and
making the function names more consistent - making ssh.c and
clientloop.c a fair bit more readable.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.311 2008/05/08 13:06:11 djm Exp $ */
d162 5
@


1.311
log
@Use new channel status confirmation callback system to properly deal
with "important" channel requests that fail, in particular command exec,
shell and subsystem requests. Previously we would optimistically assume
that the requests would always succeed, which could cause hangs if they
did not (e.g. when the server runs out of fds) or were unimplemented by
the server (bz #1384)

Also, properly report failing multiplex channel requests via the mux
client stderr (subject to LogLevel in the mux master) - better than
silently failing.

most bits ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.310 2008/05/08 12:02:23 djm Exp $ */
d44 2
a45 1
#include <sys/time.h>
a46 2
#include <sys/ioctl.h>
#include <sys/types.h>
a47 1
#include <sys/un.h>
d49 2
a50 1
#include <sys/queue.h>
a91 1
#include "monitor_fdpass.h"
a162 10
/* fd to control socket */
int control_fd = -1;

/* Multiplexing control command */
static u_int mux_command = 0;

/* Only used in control client mode */
volatile sig_atomic_t control_client_terminate = 0;
u_int control_server_pid = 0;

d182 4
a185 1
static void control_client(const char *path);
d290 1
a290 1
				mux_command = SSHMUX_COMMAND_ALIVE_CHECK;
d292 1
a292 1
				mux_command = SSHMUX_COMMAND_TERMINATE;
d661 1
a661 1
	if (mux_command != 0 && options.control_path == NULL)
d664 1
a664 1
		control_client(options.control_path);
d783 1
a783 1
	if (options.control_path != NULL && control_fd != -1)
a1037 41
static void
ssh_control_listener(void)
{
	struct sockaddr_un addr;
	mode_t old_umask;

	if (options.control_path == NULL ||
	    options.control_master == SSHCTL_MASTER_NO)
		return;

	debug("setting up multiplex master socket");

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(options.control_path) + 1;

	if (strlcpy(addr.sun_path, options.control_path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((control_fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	old_umask = umask(0177);
	if (bind(control_fd, (struct sockaddr *)&addr, addr.sun_len) == -1) {
		control_fd = -1;
		if (errno == EINVAL || errno == EADDRINUSE)
			fatal("ControlSocket %s already exists",
			    options.control_path);
		else
			fatal("%s bind(): %s", __func__, strerror(errno));
	}
	umask(old_umask);

	if (listen(control_fd, 64) == -1)
		fatal("%s listen(): %s", __func__, strerror(errno));

	set_nonblock(control_fd);
}

d1136 1
a1136 1
	ssh_control_listener();
a1204 233
static void
control_client_sighandler(int signo)
{
	control_client_terminate = signo;
}

static void
control_client_sigrelay(int signo)
{
	int save_errno = errno;

	if (control_server_pid > 1)
		kill(control_server_pid, signo);

	errno = save_errno;
}

static int
env_permitted(char *env)
{
	int i, ret;
	char name[1024], *cp;

	if ((cp = strchr(env, '=')) == NULL || cp == env)
		return (0);
	ret = snprintf(name, sizeof(name), "%.*s", (int)(cp - env), env);
	if (ret <= 0 || (size_t)ret >= sizeof(name))
		fatal("env_permitted: name '%.100s...' too long", env);

	for (i = 0; i < options.num_send_env; i++)
		if (match_pattern(name, options.send_env[i]))
			return (1);

	return (0);
}

static void
control_client(const char *path)
{
	struct sockaddr_un addr;
	int i, r, fd, sock, exitval[2], num_env;
	Buffer m;
	char *term;
	extern char **environ;
	u_int  flags;

	if (mux_command == 0)
		mux_command = SSHMUX_COMMAND_OPEN;

	switch (options.control_master) {
	case SSHCTL_MASTER_AUTO:
	case SSHCTL_MASTER_AUTO_ASK:
		debug("auto-mux: Trying existing master");
		/* FALLTHROUGH */
	case SSHCTL_MASTER_NO:
		break;
	default:
		return;
	}

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(path) + 1;

	if (strlcpy(addr.sun_path, path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	if (connect(sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
		if (mux_command != SSHMUX_COMMAND_OPEN) {
			fatal("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		if (errno == ENOENT)
			debug("Control socket \"%.100s\" does not exist", path);
		else {
			error("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		close(sock);
		return;
	}

	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}

	term = getenv("TERM");

	flags = 0;
	if (tty_flag)
		flags |= SSHMUX_FLAG_TTY;
	if (subsystem_flag)
		flags |= SSHMUX_FLAG_SUBSYS;
	if (options.forward_x11)
		flags |= SSHMUX_FLAG_X11_FWD;
	if (options.forward_agent)
		flags |= SSHMUX_FLAG_AGENT_FWD;

	signal(SIGPIPE, SIG_IGN);

	buffer_init(&m);

	/* Send our command to server */
	buffer_put_int(&m, mux_command);
	buffer_put_int(&m, flags);
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
		fatal("%s: msg_send", __func__);
	buffer_clear(&m);

	/* Get authorisation status and PID of controlee */
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != SSHMUX_VER)
		fatal("%s: wrong version", __func__);
	if (buffer_get_int(&m) != 1)
		fatal("Connection to master denied");
	control_server_pid = buffer_get_int(&m);

	buffer_clear(&m);

	switch (mux_command) {
	case SSHMUX_COMMAND_ALIVE_CHECK:
		fprintf(stderr, "Master running (pid=%d)\r\n",
		    control_server_pid);
		exit(0);
	case SSHMUX_COMMAND_TERMINATE:
		fprintf(stderr, "Exit request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_OPEN:
		/* continue below */
		break;
	default:
		fatal("silly mux_command %d", mux_command);
	}

	/* SSHMUX_COMMAND_OPEN */
	buffer_put_cstring(&m, term ? term : "");
	buffer_append(&command, "\0", 1);
	buffer_put_cstring(&m, buffer_ptr(&command));

	if (options.num_send_env == 0 || environ == NULL) {
		buffer_put_int(&m, 0);
	} else {
		/* Pass environment */
		num_env = 0;
		for (i = 0; environ[i] != NULL; i++)
			if (env_permitted(environ[i]))
				num_env++; /* Count */

		buffer_put_int(&m, num_env);

		for (i = 0; environ[i] != NULL && num_env >= 0; i++)
			if (env_permitted(environ[i])) {
				num_env--;
				buffer_put_cstring(&m, environ[i]);
			}
	}

	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
		fatal("%s: msg_send", __func__);

	if (mm_send_fd(sock, STDIN_FILENO) == -1 ||
	    mm_send_fd(sock, STDOUT_FILENO) == -1 ||
	    mm_send_fd(sock, STDERR_FILENO) == -1)
		fatal("%s: send fds failed", __func__);

	/* Wait for reply, so master has a chance to gather ttymodes */
	buffer_clear(&m);
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != SSHMUX_VER)
		fatal("%s: wrong version", __func__);
	buffer_free(&m);

	signal(SIGHUP, control_client_sighandler);
	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

	if (tty_flag)
		enter_raw_mode();

	/*
	 * Stick around until the controlee closes the client_fd.
	 * Before it does, it is expected to write this process' exit
	 * value (one int). This process must read the value and wait for
	 * the closure of the client_fd; if this one closes early, the 
	 * multiplex master will terminate early too (possibly losing data).
	 */
	exitval[0] = 0;
	for (i = 0; !control_client_terminate && i < (int)sizeof(exitval);) {
		r = read(sock, (char *)exitval + i, sizeof(exitval) - i);
		if (r == 0) {
			debug2("Received EOF from master");
			break;
		}
		if (r == -1) {
			if (errno == EINTR)
				continue;
			fatal("%s: read %s", __func__, strerror(errno));
		}
		i += r;
	}

	close(sock);
	leave_raw_mode();
	if (i > (int)sizeof(int))
		fatal("%s: master returned too much data (%d > %lu)",
		    __func__, i, sizeof(int));
	if (control_client_terminate) {
		debug2("Exiting on signal %d", control_client_terminate);
		exitval[0] = 255;
	} else if (i < (int)sizeof(int)) {
		debug2("Control master terminated unexpectedly");
		exitval[0] = 255;
	} else
		debug2("Received exit status from master %d", exitval[0]);

	if (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "Shared connection to %s closed.\r\n", host);

	exit(exitval[0]);
}
@


1.310
log
@Implement a channel success/failure status confirmation callback
mechanism. Each channel maintains a queue of callbacks, which will
be drained in order (RFC4253 guarantees confirm messages are not
reordered within an channel).

Also includes a abandonment callback to clean up if a channel is
closed without sending confirmation messages. This probably
shouldn't happen in compliant implementations, but it could be
abused to leak memory.

ok markus@@ (as part of a larger diff)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.309 2008/01/19 20:51:26 djm Exp $ */
a1021 15
static void
ssh_subsystem_reply(int type, u_int32_t seq, void *ctxt)
{
	int id, len;

	id = packet_get_int();
	len = buffer_len(&command);
	if (len > 900)
		len = 900;
	packet_check_eom();
	if (type == SSH2_MSG_CHANNEL_FAILURE)
		fatal("Request for subsystem '%.*s' failed on channel %d",
		    len, (u_char *)buffer_ptr(&command), id);
}

d1117 1
a1117 1
	    NULL, fileno(stdin), &command, environ, &ssh_subsystem_reply);
@


1.309
log
@ignore SIGPIPE in multiplex client mode - we can receive this if the
server runs out of fds on us midway. Report and patch from
gregory_shively AT fanniemae.com
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.308 2007/11/03 02:03:49 deraadt Exp $ */
d51 1
d1178 2
a1179 1
		channel_register_confirm(c->self, ssh_session2_setup, NULL);
@


1.308
log
@avoid errno trashing in signal handler; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.307 2007/11/03 02:00:32 dtucker Exp $ */
d1375 2
@


1.307
log
@Use xstrdup/xfree when saving pwname and pwdir; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.306 2007/11/03 01:24:06 deraadt Exp $ */
d1277 2
d1281 2
@


1.306
log
@bz #1377: getpwuid results were being clobbered by another getpw* call
inside tilde_expand_filename(); save the data we need carefully
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.305 2007/10/29 06:54:50 dtucker Exp $ */
d1243 2
a1244 2
	pwname = strdup(pw->pw_name);
	pwdir = strdup(pw->pw_dir);
d1263 1
a1263 1
	free(pwname);
d1265 1
a1265 1
	free(pwdir);
@


1.305
log
@Make LocalCommand work for Protocol 1 too; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.304 2007/10/29 01:55:04 dtucker Exp $ */
d1214 1
d1243 2
d1251 2
a1252 2
		filename = percent_expand(cp, "d", pw->pw_dir,
		    "u", pw->pw_name, "l", thishost, "h", host,
d1262 4
@


1.304
log
@Plug tiny mem leaks in ControlPath and ProxyCommand option processing; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.303 2007/09/04 11:15:55 djm Exp $ */
d985 5
@


1.303
log
@make ssh(1)'s ConnectTimeout option apply to both the TCP connection and
SSH banner exchange (previously it just covered the TCP connection).
This allows callers of ssh(1) to better detect and deal with stuck servers
that accept a TCP connection but don't progress the protocol, and also makes
ConnectTimeout useful for connections via a ProxyCommand;
feedback and "looks ok" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.302 2007/09/04 03:21:03 djm Exp $ */
d646 2
a647 1
	    strcmp(options.proxy_command, "none") == 0)
d649 1
d651 2
a652 1
	    strcmp(options.control_path, "none") == 0)
d654 1
d664 1
@


1.302
log
@make file descriptor passing code return an error rather than call fatal()
when it encounters problems, and use this to make session multiplexing
masters survive slaves failing to pass all stdio FDs; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.301 2007/08/07 07:32:53 djm Exp $ */
d205 1
a205 1
	int dummy;
d669 2
d673 2
a674 1
	    options.address_family, options.connection_attempts,
d679 3
d757 2
a758 1
	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr, pw);
@


1.301
log
@bz#1232: ensure that any specified LocalCommand is executed after the
tunnel device is opened. Also, make failures to open a tunnel device
fatal when ExitOnForwardFailure is active.
Reported by h.goebel AT goebel-consult.de; ok dtucker markus reyk deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.300 2007/06/14 22:48:05 djm Exp $ */
d1409 4
a1412 3
	mm_send_fd(sock, STDIN_FILENO);
	mm_send_fd(sock, STDOUT_FILENO);
	mm_send_fd(sock, STDERR_FILENO);
@


1.300
log
@when waiting for the multiplex exit status, read until the master end
writes an entire int of data *and* closes the client_fd; fixes mux
regression spotted by dtucker, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.299 2007/06/14 21:43:25 djm Exp $ */
d841 11
a1112 22
	if (options.tun_open != SSH_TUNMODE_NO) {
		Channel *c;
		int fd;

		debug("Requesting tun.");
		if ((fd = tun_open(options.tun_local,
		    options.tun_open)) >= 0) {
			c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
			    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
			    0, "tun", 1);
			c->datagram = 1;
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("tun@@openssh.com");
			packet_put_int(c->self);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
			packet_put_int(options.tun_open);
			packet_put_int(options.tun_remote);
			packet_send();
		}
	}

a1171 1
	ssh_control_listener();
d1180 3
@


1.299
log
@handle EINTR when waiting for mux exit status properly
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.298 2007/06/12 11:45:27 djm Exp $ */
d1289 1
a1289 1
	int i, r, fd, sock, exitval, num_env;
d1438 8
a1445 2
	/* Stick around until the controlee closes the client_fd */
	exitval = 0;
d1447 1
a1447 1
		r = read(sock, (char *)&exitval + i, sizeof(exitval) - i);
d1459 1
d1462 3
a1464 1

d1467 2
a1468 2
		exitval = 255;
	} else if (i < (int)sizeof(exitval)) {
d1470 1
a1470 1
		exitval = 255;
d1472 1
a1472 1
		debug2("Received exit status from master %d", exitval);
d1475 1
a1475 2
		fprintf(stderr, "Shared connection to %s closed.\r\n",
		    host);
d1477 1
a1477 1
	exit(exitval);
@


1.298
log
@improved exit message from multiplex slave sessions; bz #1262
reported by alexandre.nunes AT gmail.com; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.297 2007/06/12 11:15:17 djm Exp $ */
d1446 3
a1448 1
		if (r == -1 && errno != EINTR)
d1450 1
@


1.297
log
@Add "-K" flag for ssh to set GSSAPIAuthentication=yes and
GSSAPIDelegateCredentials=yes. This is symmetric with -k (disable GSSAPI)
and is useful for hosts with /home on Kerberised NFS; bz #1312
patch from Markus.Kuhn AT cl.cam.ac.uk; ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.296 2007/06/12 11:11:08 djm Exp $ */
d1463 2
a1464 1
		fprintf(stderr, "Connection to master closed.\r\n");
@


1.296
log
@fix slave exit value when a control master goes away without passing the
full exit status by ensuring that the slave reads a full int. bz#1261
reported by frekko AT gmail.com; ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.295 2007/01/03 03:01:40 stevesk Exp $ */
d180 1
a180 1
"usage: ssh [-1246AaCfgkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d262 1
a262 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVw:XY")) != -1) {
d315 4
@


1.295
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.294 2006/10/06 02:29:19 djm Exp $ */
d1436 2
a1437 2
	for (;!control_client_terminate;) {
		r = read(sock, &exitval, sizeof(exitval));
a1441 2
		if (r > 0)
			debug2("Received exit status from master %d", exitval);
d1444 1
d1446 2
d1449 1
a1449 1
	if (control_client_terminate)
d1451 6
a1456 4

	close(sock);

	leave_raw_mode();
@


1.294
log
@sys/resource.h needs sys/time.h; prompted by brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.293 2006/08/03 03:34:42 deraadt Exp $ */
d604 1
a604 1
	} else  {
@


1.293
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.292 2006/08/01 23:36:12 stevesk Exp $ */
d44 1
@


1.293.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.294 2006/10/06 02:29:19 djm Exp $ */
a43 1
#include <sys/time.h>
@


1.292
log
@clean extra spaces
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.291 2006/08/01 23:22:47 stevesk Exp $ */
d43 1
a43 2
#include "includes.h"

d67 1
a72 1
#include "xmalloc.h"
a74 1
#include "bufaux.h"
d1236 1
a1236 1
		    "u", pw->pw_name, "l", thishost, "h", host, 
@


1.291
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.290 2006/07/26 13:57:17 stevesk Exp $ */
d1211 1
a1211 1
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL ) {
@


1.290
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.289 2006/07/22 20:48:23 stevesk Exp $ */
d60 1
@


1.289
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.288 2006/07/17 01:31:10 stevesk Exp $ */
d60 1
@


1.288
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.287 2006/07/12 22:42:32 stevesk Exp $ */
d60 1
@


1.287
log
@move #include <stddef.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.286 2006/07/12 22:28:52 stevesk Exp $ */
d60 1
@


1.286
log
@move #include <netdb.h> out of includes.h; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.285 2006/07/11 20:27:56 stevesk Exp $ */
d59 1
@


1.285
log
@need <errno.h> here also (it's also included in <openssl/err.h>)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.284 2006/07/11 20:16:43 stevesk Exp $ */
d55 1
@


1.284
log
@cast asterisk field precision argument to int to remove warning;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.283 2006/07/11 18:50:48 markus Exp $ */
d53 1
@


1.283
log
@add ExitOnForwardFailure: terminate the connection if ssh(1)
cannot set up all requested dynamic, local, and remote port
forwardings. ok djm, dtucker, stevesk, jmc
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.282 2006/07/11 10:12:07 dtucker Exp $ */
d1264 1
a1264 1
	ret = snprintf(name, sizeof(name), "%.*s", (cp - env), env);
@


1.282
log
@Only copy the part of environment variable that we actually use.  Prevents
ssh bailing when SendEnv is used and an environment variable with a really
long value exists.  ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.281 2006/07/09 15:15:11 stevesk Exp $ */
d805 2
d819 1
a819 1
		channel_request_remote_forwarding(
d823 7
a829 1
		    options.remote_forwards[i].connect_port);
d1011 10
a1020 3
	if (type == SSH2_MSG_REQUEST_FAILURE)
		logit("Warning: remote port forwarding failed for listen "
		    "port %d", options.remote_forwards[i].listen_port);
@


1.281
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.280 2006/07/08 21:47:12 stevesk Exp $ */
d1244 1
a1244 1
	int i;
d1247 1
a1247 3
	if (strlcpy(name, env, sizeof(name)) >= sizeof(name))
		fatal("env_permitted: name too long");
	if ((cp = strchr(name, '=')) == NULL)
d1249 3
a1251 2

	*cp = '\0';
@


1.280
log
@move #include <sys/socket.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.279 2006/07/06 16:03:53 stevesk Exp $ */
d53 1
@


1.279
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.278 2006/07/03 08:54:20 stevesk Exp $ */
d48 1
@


1.278
log
@move #include "version.h" out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.277 2006/07/02 17:12:58 stevesk Exp $ */
d53 1
@


1.277
log
@more details and clarity for tun(4) device forwarding; ok and help
jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.276 2006/04/25 08:02:27 dtucker Exp $ */
d85 1
@


1.276
log
@Prevent ssh from trying to open private keys with bad permissions more than
once or prompting for their passphrases (which it subsequently ignores
anyway), similar to a previous change in ssh-add.  bz #1186, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.275 2006/03/30 10:41:25 djm Exp $ */
d175 1
a175 1
"           [-w tunnel:tunnel] [user@@]hostname [command]\n"
@


1.275
log
@add percent escape chars to the IdentityFile option, bz #1159 based
on a patch by imaging AT math.ualberta.ca; feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.274 2006/03/28 00:12:31 deraadt Exp $ */
d681 1
a681 1
		    _PATH_HOST_KEY_FILE, "", NULL);
d683 1
a683 1
		    _PATH_HOST_DSA_KEY_FILE, "", NULL);
d685 1
a685 1
		    _PATH_HOST_RSA_KEY_FILE, "", NULL);
@


1.274
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.273 2006/03/25 13:17:02 djm Exp $ */
d639 1
a639 1
		char me[NI_MAXHOST];
d641 1
a641 1
		if (gethostname(me, sizeof(me)) == -1)
d647 1
a647 1
		    "r", options.user, "l", me, (char *)NULL);
d1176 1
a1176 1
	char *filename;
d1179 1
d1203 5
d1209 1
a1209 1
		filename = tilde_expand_filename(options.identity_files[i],
d1211 4
@


1.273
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d676 1
a676 1
		sensitive_data.keys = xcalloc(sensitive_data.nkeys, 
@


1.272
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d1 1
@


1.271
log
@be strict with tolower() casting
@
text
@d675 1
a675 1
		sensitive_data.keys = xmalloc(sensitive_data.nkeys *
d1232 2
a1233 1
	strlcpy(name, env, sizeof(name));
@


1.270
log
@annoying spacing fixes getting in the way of real diffs
@
text
@d621 1
a621 1
				*p = tolower(*p);
@


1.269
log
@sprinkle u_int throughout pty subsystem, ok markus
@
text
@d1028 1
a1028 1
	if (bind(control_fd, (struct sockaddr*)&addr, addr.sun_len) == -1) {
d1281 1
a1281 1
	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1) {
@


1.268
log
@spacing
@
text
@d877 4
a880 4
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
@


1.267
log
@RCSID() can die
@
text
@d1287 1
a1287 1
	 		debug("Control socket \"%.100s\" does not exist", path);
d1289 1
a1289 1
	 		error("Control socket connect(%.100s): %s", path,
d1292 3
a1294 3
 		close(sock);
 		return;
 	}
d1296 8
a1303 8
 	if (stdin_null_flag) {
 		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
 			fatal("open(/dev/null): %s", strerror(errno));
 		if (dup2(fd, STDIN_FILENO) == -1)
 			fatal("dup2: %s", strerror(errno));
 		if (fd > STDERR_FILENO)
 			close(fd);
 	}
@


1.266
log
@knf nit
@
text
@a42 1
RCSID("$OpenBSD: ssh.c,v 1.265 2006/02/22 00:04:45 stevesk Exp $");
@


1.265
log
@move #include <ctype.h> out of includes.h; ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.264 2006/02/20 17:19:54 stevesk Exp $");
d250 1
a250 1
again:
@


1.265.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh.c,v 1.293 2006/08/03 03:34:42 deraadt Exp $ */
d42 3
a44 1
#include <sys/types.h>
a47 1
#include <sys/socket.h>
a51 3
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
a52 1
#include <pwd.h>
a53 5
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a57 1
#include "xmalloc.h"
d63 1
d66 1
a84 1
#include "version.h"
d175 1
a175 1
"           [-w local_tun[:remote_tun]] [user@@]hostname [command]\n"
d250 1
a250 1
 again:
d622 1
a622 1
				*p = (char)tolower(*p);
d639 1
a639 1
		char thishost[NI_MAXHOST];
d641 1
a641 1
		if (gethostname(thishost, sizeof(thishost)) == -1)
d647 1
a647 1
		    "r", options.user, "l", thishost, (char *)NULL);
d676 1
a676 1
		sensitive_data.keys = xcalloc(sensitive_data.nkeys,
d681 1
a681 1
		    _PATH_HOST_KEY_FILE, "", NULL, NULL);
d683 1
a683 1
		    _PATH_HOST_DSA_KEY_FILE, "", NULL, NULL);
d685 1
a685 1
		    _PATH_HOST_RSA_KEY_FILE, "", NULL, NULL);
a800 2
	if (i > 0 && success != i && options.exit_on_forward_failure)
		fatal("Could not request local forwarding.");
d813 1
a813 1
		if (channel_request_remote_forwarding(
d817 1
a817 7
		    options.remote_forwards[i].connect_port) < 0) {
			if (options.exit_on_forward_failure)
				fatal("Could not request remote forwarding.");
			else
				logit("Warning: Could not request remote "
				    "forwarding.");
		}
d878 4
a881 4
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
d999 3
a1001 10
	if (type == SSH2_MSG_REQUEST_FAILURE) {
		if (options.exit_on_forward_failure)
			fatal("Error: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
		else
			logit("Warning: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
	}
d1029 1
a1029 1
	if (bind(control_fd, (struct sockaddr *)&addr, addr.sun_len) == -1) {
d1176 1
a1176 1
	char *filename, *cp, thishost[NI_MAXHOST];
a1178 1
	struct passwd *pw;
d1184 1
a1184 1
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL) {
a1201 5
	if ((pw = getpwuid(original_real_uid)) == NULL)
		fatal("load_public_identity_files: getpwuid failed");
	if (gethostname(thishost, sizeof(thishost)) == -1)
		fatal("load_public_identity_files: gethostname: %s",
		    strerror(errno));
d1203 1
a1203 1
		cp = tilde_expand_filename(options.identity_files[i],
a1204 4
		filename = percent_expand(cp, "d", pw->pw_dir,
		    "u", pw->pw_name, "l", thishost, "h", host,
		    "r", options.user, (char *)NULL);
		xfree(cp);
d1230 1
a1230 1
	int i, ret;
d1233 2
a1234 1
	if ((cp = strchr(env, '=')) == NULL || cp == env)
d1236 2
a1237 3
	ret = snprintf(name, sizeof(name), "%.*s", (int)(cp - env), env);
	if (ret <= 0 || (size_t)ret >= sizeof(name))
		fatal("env_permitted: name '%.100s...' too long", env);
d1282 1
a1282 1
	if (connect(sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
d1288 1
a1288 1
			debug("Control socket \"%.100s\" does not exist", path);
d1290 1
a1290 1
			error("Control socket connect(%.100s): %s", path,
d1293 12
a1304 12
		close(sock);
		return;
	}

	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}
@


1.265.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.294 2006/10/06 02:29:19 djm Exp $ */
a43 1
#include <sys/time.h>
@


1.264
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.263 2006/02/20 17:02:44 stevesk Exp $");
d51 1
@


1.263
log
@move #include <signal.h> out of includes.h; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.262 2006/02/20 16:36:15 stevesk Exp $");
d49 1
@


1.262
log
@move #include <sys/un.h> out of includes.h; ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.261 2006/02/12 06:45:34 djm Exp $");
d51 1
@


1.261
log
@add a %l expansion code to the ControlPath, which is filled in with the
local hostname at runtime. Requested by henning@@ to avoid some problems
with /home on NFS; ok dtucker@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.260 2006/02/10 00:27:13 stevesk Exp $");
d47 2
@


1.260
log
@move #include <sys/ioctl.h> out of includes.h; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.259 2006/02/08 14:31:30 stevesk Exp $");
d634 4
d642 1
a642 1
		    "r", options.user, (char *)NULL);
@


1.259
log
@move #include <sys/resource.h> out of includes.h; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.258 2006/02/08 12:15:27 stevesk Exp $");
d46 1
@


1.258
log
@move #include <paths.h> out of includes.h; ok markus@@
@
text
@d43 3
a45 1
RCSID("$OpenBSD: ssh.c,v 1.257 2005/12/20 04:41:07 dtucker Exp $");
@


1.257
log
@exit(255) on error to match description in ssh(1); bz #1137; ok deraadt@@
@
text
@d43 3
a45 1
RCSID("$OpenBSD: ssh.c,v 1.256 2005/12/08 18:34:11 reyk Exp $");
@


1.256
log
@two changes to the new ssh tunnel support. this breaks compatibility
with the initial commit but is required for a portable approach.
- make the tunnel id u_int and platform friendly, use predefined types.
- support configuration of layer 2 (ethernet) or layer 3
(point-to-point, default) modes. configuration is done using the
Tunnel (yes|point-to-point|ethernet|no) option is ssh_config(5) and
restricted by the PermitTunnel (yes|point-to-point|ethernet|no) option
in sshd_config(5).

ok djm@@, man page bits by jmc@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.255 2005/12/06 22:38:27 reyk Exp $");
d167 1
a167 1
	exit(1);
d221 1
a221 1
		exit(1);
d344 1
a344 1
				exit(1);
d362 1
a362 1
				exit(1);
d377 1
a377 1
					exit(1);
d393 1
a393 1
				exit(1);
d406 1
a406 1
				exit(1);
d420 1
a420 1
				exit(1);
d431 1
a431 1
				exit(1);
d442 1
a442 1
				exit(1);
d455 1
a455 1
				exit(1);
d476 1
a476 1
				exit(1);
d646 1
a646 1
		exit(1);
@


1.255
log
@Add support for tun(4) forwarding over OpenSSH, based on an idea and
initial channel code bits by markus@@. This is a simple and easy way to
use OpenSSH for ad hoc virtual private network connections, e.g.
administrative tunnels or secure wireless access. It's based on a new
ssh channel and works similar to the existing TCP forwarding support,
except that it depends on the tun(4) network interface on both ends of
the connection for layer 2 or layer 3 tunneling. This diff also adds
support for LocalCommand in the ssh(1) client.

ok djm@@, markus@@, jmc@@ (manpages), tested and discussed with others
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.254 2005/10/30 08:52:18 djm Exp $");
d339 2
a340 1
			options.tun_open = 1;
d342 1
a342 1
			if (options.tun_local < -1) {
d1059 1
a1059 1
	if (options.tun_open) {
d1064 2
a1065 1
		if ((fd = tun_open(options.tun_local)) >= 0) {
d1075 1
@


1.254
log
@no need to escape single quotes in comments, no binary change
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.253 2005/10/30 04:03:24 djm Exp $");
d165 1
a165 1
"           [user@@]hostname [command]\n"
d242 1
a242 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVXY")) != -1) {
d338 8
d1058 20
d1141 5
@


1.253
log
@fix misleading debug message; ok dtucker@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.252 2005/10/14 02:17:59 stevesk Exp $");
d690 1
a690 1
	 * directory if it doesn\'t already exist.
d802 1
a802 1
		/* Clear agent forwarding if we don\'t have an agent. */
@


1.252
log
@no trailing "\n" for log functions; ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.251 2005/09/19 15:42:44 jmc Exp $");
d786 1
a786 2
		    (options.gateway_ports ? "*" : "LOCALHOST") :
		    options.remote_forwards[i].listen_host,
@


1.251
log
@update -D usage here too;
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.250 2005/09/13 23:40:07 djm Exp $");
d1004 1
a1004 1
		fatal("%s socket(): %s\n", __func__, strerror(errno));
d1013 1
a1013 1
			fatal("%s bind(): %s\n", __func__, strerror(errno));
d1018 1
a1018 1
		fatal("%s listen(): %s\n", __func__, strerror(errno));
@


1.250
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.249 2005/07/30 01:26:16 djm Exp $");
d161 1
a161 1
"           [-D port] [-e escape_char] [-F configfile]\n"
@


1.249
log
@fix -D listen_host initialisation, so it picks up gateway_ports setting
correctly
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.248 2005/07/16 01:35:24 djm Exp $");
d190 3
@


1.249.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.257 2005/12/20 04:41:07 dtucker Exp $");
d161 1
a161 1
"           [-D [bind_address:]port] [-e escape_char] [-F configfile]\n"
d165 1
a165 1
"           [-w tunnel:tunnel] [user@@]hostname [command]\n"
d167 1
a167 1
	exit(255);
a190 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d218 1
a218 1
		exit(255);
d239 1
a239 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVw:XY")) != -1) {
a334 9
		case 'w':
			if (options.tun_open == -1)
				options.tun_open = SSH_TUNMODE_DEFAULT;
			options.tun_local = a2tun(optarg, &options.tun_remote);
			if (options.tun_local == SSH_TUNID_ERR) {
				fprintf(stderr, "Bad tun device '%s'\n", optarg);
				exit(255);
			}
			break;
d350 1
a350 1
				exit(255);
d365 1
a365 1
					exit(255);
d381 1
a381 1
				exit(255);
d394 1
a394 1
				exit(255);
d408 1
a408 1
				exit(255);
d419 1
a419 1
				exit(255);
d430 1
a430 1
				exit(255);
d443 1
a443 1
				exit(255);
d464 1
a464 1
				exit(255);
d634 1
a634 1
		exit(255);
d687 1
a687 1
	 * directory if it doesn't already exist.
d783 2
a784 1
		    "LOCALHOST" : options.remote_forwards[i].listen_host,
d800 1
a800 1
		/* Clear agent forwarding if we don't have an agent. */
d1001 1
a1001 1
		fatal("%s socket(): %s", __func__, strerror(errno));
d1010 1
a1010 1
			fatal("%s bind(): %s", __func__, strerror(errno));
d1015 1
a1015 1
		fatal("%s listen(): %s", __func__, strerror(errno));
a1047 22
	if (options.tun_open != SSH_TUNMODE_NO) {
		Channel *c;
		int fd;

		debug("Requesting tun.");
		if ((fd = tun_open(options.tun_local,
		    options.tun_open)) >= 0) {
			c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
			    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
			    0, "tun", 1);
			c->datagram = 1;
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("tun@@openssh.com");
			packet_put_int(c->self);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
			packet_put_int(options.tun_open);
			packet_put_int(options.tun_remote);
			packet_send();
		}
	}

a1110 5

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);
@


1.249.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh.c,v 1.293 2006/08/03 03:34:42 deraadt Exp $ */
d42 2
a43 21
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a47 1
#include "xmalloc.h"
d53 1
d56 1
a74 1
#include "version.h"
d165 1
a165 1
"           [-w local_tun[:remote_tun]] [user@@]hostname [command]\n"
d240 1
a240 1
 again:
d612 1
a612 1
				*p = (char)tolower(*p);
a628 4
		char thishost[NI_MAXHOST];

		if (gethostname(thishost, sizeof(thishost)) == -1)
			fatal("gethostname: %s", strerror(errno));
d633 1
a633 1
		    "r", options.user, "l", thishost, (char *)NULL);
d662 1
a662 1
		sensitive_data.keys = xcalloc(sensitive_data.nkeys,
d667 1
a667 1
		    _PATH_HOST_KEY_FILE, "", NULL, NULL);
d669 1
a669 1
		    _PATH_HOST_DSA_KEY_FILE, "", NULL, NULL);
d671 1
a671 1
		    _PATH_HOST_RSA_KEY_FILE, "", NULL, NULL);
a786 2
	if (i > 0 && success != i && options.exit_on_forward_failure)
		fatal("Could not request local forwarding.");
d799 1
a799 1
		if (channel_request_remote_forwarding(
d803 1
a803 7
		    options.remote_forwards[i].connect_port) < 0) {
			if (options.exit_on_forward_failure)
				fatal("Could not request remote forwarding.");
			else
				logit("Warning: Could not request remote "
				    "forwarding.");
		}
d864 4
a867 4
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
d985 3
a987 10
	if (type == SSH2_MSG_REQUEST_FAILURE) {
		if (options.exit_on_forward_failure)
			fatal("Error: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
		else
			logit("Warning: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
	}
d1015 1
a1015 1
	if (bind(control_fd, (struct sockaddr *)&addr, addr.sun_len) == -1) {
d1162 1
a1162 1
	char *filename, *cp, thishost[NI_MAXHOST];
a1164 1
	struct passwd *pw;
d1170 1
a1170 1
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL) {
a1187 5
	if ((pw = getpwuid(original_real_uid)) == NULL)
		fatal("load_public_identity_files: getpwuid failed");
	if (gethostname(thishost, sizeof(thishost)) == -1)
		fatal("load_public_identity_files: gethostname: %s",
		    strerror(errno));
d1189 1
a1189 1
		cp = tilde_expand_filename(options.identity_files[i],
a1190 4
		filename = percent_expand(cp, "d", pw->pw_dir,
		    "u", pw->pw_name, "l", thishost, "h", host,
		    "r", options.user, (char *)NULL);
		xfree(cp);
d1216 1
a1216 1
	int i, ret;
d1219 2
a1220 1
	if ((cp = strchr(env, '=')) == NULL || cp == env)
d1222 2
a1223 3
	ret = snprintf(name, sizeof(name), "%.*s", (int)(cp - env), env);
	if (ret <= 0 || (size_t)ret >= sizeof(name))
		fatal("env_permitted: name '%.100s...' too long", env);
d1268 1
a1268 1
	if (connect(sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
d1274 1
a1274 1
			debug("Control socket \"%.100s\" does not exist", path);
d1276 1
a1276 1
			error("Control socket connect(%.100s): %s", path,
d1279 12
a1290 12
		close(sock);
		return;
	}

	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}
@


1.249.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.294 2006/10/06 02:29:19 djm Exp $ */
@


1.248
log
@spacing
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.247 2005/07/04 00:58:43 djm Exp $");
d437 1
a437 1
				fwd.listen_host = "";
@


1.247
log
@implement support for X11 and agent forwarding over multiplex slave
connections. Because of protocol limitations, the slave connections inherit
the master's DISPLAY and SSH_AUTH_SOCK rather than distinctly forwarding
their own.

ok dtucker@@ "put it in" deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.246 2005/06/25 22:47:49 djm Exp $");
d782 2
a783 2
		    (options.remote_forwards[i].listen_host == NULL) ? 
		    (options.gateway_ports ? "*" : "LOCALHOST") : 
d1028 1
a1028 1
	display = getenv("DISPLAY");	
d1244 1
a1244 1
 
d1253 1
a1253 1
  
@


1.246
log
@do the default port filling code a few lines earlier, so it really does fix %p
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.245 2005/06/18 04:30:36 djm Exp $");
d1254 1
a1254 2
	if ((term = getenv("TERM")) == NULL)
		term = "";
d1261 4
d1271 1
a1271 1
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
d1278 1
a1278 1
	if (buffer_get_char(&m) != 1)
d1302 1
a1302 1
	buffer_put_cstring(&m, term);
d1324 1
a1324 1
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
d1335 1
a1335 1
	if (buffer_get_char(&m) != 1)
@


1.245
log
@allow ControlPath=none, patch from dwmw2 AT infradead.org; ok dtucker@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.244 2005/06/17 22:53:46 djm Exp $");
d603 6
a627 6

	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}
@


1.244
log
@Fix ControlPath's %p expanding to "0" for a default port,
spotted dwmw2 AT infradead.org; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.243 2005/06/16 03:38:36 djm Exp $");
d606 3
@


1.243
log
@move x11_get_proto from ssh.c to clientloop.c, to make muliplexed xfwd easier
later; ok deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.242 2005/06/08 11:25:09 djm Exp $");
d188 1
d619 6
@


1.242
log
@add ControlMaster=auto/autoask options to support opportunistic multiplexing;
tested avsm@@ and jakob@@, ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.241 2005/06/06 11:20:36 djm Exp $");
a741 104
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"

static void
x11_get_proto(char **_proto, char **_data)
{
	char cmd[1024];
	char line[512];
	char xdisplay[512];
	static char proto[512], data[512];
	FILE *f;
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *display, *xauthdir, *xauthfile;
	struct stat st;

	xauthdir = xauthfile = NULL;
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';

	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if ((display = getenv("DISPLAY")) == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (options.forward_x11_trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
				    options.xauth_location, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    options.xauth_location,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
	}

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

	/*
	 * If we didn't get authentication data, just make up some
	 * data.  The forwarding code will check the validity of the
	 * response anyway, and substitute this data.  The X11
	 * server, however, will ignore this fake data and use
	 * whatever authentication mechanisms it was using otherwise
	 * for the local connection.
	 */
	if (!got_data) {
		u_int32_t rnd = 0;

		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
		for (i = 0; i < 16; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rnd & 0xff);
			rnd >>= 8;
		}
	}
}

d804 1
d866 2
a867 1
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
d870 2
a871 1
		x11_get_proto(&proto, &data);
d874 1
a874 1
		x11_request_forwarding_with_spoofing(0, proto, data);
d1015 2
d1018 2
a1019 2
	int interactive = tty_flag;
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
d1022 2
a1023 1
		x11_get_proto(&proto, &data);
d1026 1
a1026 1
		x11_request_forwarding_with_spoofing(id, proto, data);
@


1.241
log
@introduce a generic %foo expansion function. replace existing % expansion and
add expansion to ControlPath; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.240 2005/05/27 08:30:37 djm Exp $");
d384 4
a387 2
			options.control_master =
			    (options.control_master >= 1) ? 2 : 1;
d616 1
a616 3
	if (options.control_path != NULL && options.control_master == 0) {
		if (mux_command == 0)
			mux_command = SSHMUX_COMMAND_OPEN;
a617 1
	}
d1076 2
a1077 1
	if (options.control_path == NULL || options.control_master <= 0)
d1080 2
d1291 14
@


1.240
log
@fix -O for cases where no ControlPath has been specified or socket at
ControlPath is not contactable; spotted by and ok avsm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.239 2005/05/10 10:30:43 djm Exp $");
d605 6
a610 2
		options.control_path = tilde_expand_filename(
		   options.control_path, original_real_uid);
@


1.239
log
@report real errors on fallback from ControlMaster=no to normal connect
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.238 2005/05/10 10:28:11 djm Exp $");
d148 1
a148 1
static u_int mux_command = SSHMUX_COMMAND_OPEN;
d608 5
a612 1
	if (options.control_path != NULL && options.control_master == 0)
d614 1
d1299 4
@


1.238
log
@print nice error message for EADDRINUSE as well
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.237 2005/04/26 13:08:37 jakob Exp $");
d1294 6
a1299 1
 		debug("Couldn't connect to %s: %s", path, strerror(errno));
@


1.237
log
@fallback gracefully if client cannot connect to ControlPath. ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.236 2005/04/21 11:47:19 djm Exp $");
d1086 1
a1086 1
		if (errno == EINVAL)
@


1.236
log
@don't allocate a pty when -n flag (/dev/null stdin) is set, patch from
ignasi.roca AT fujitsu-siemens.com (bz #829); ok dtucker@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.235 2005/04/06 12:26:06 dtucker Exp $");
d609 1
a609 1
		control_client(options.control_path); /* This doesn't return */
a1280 9
	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}

d1293 15
a1307 3
	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1)
		fatal("Couldn't connect to %s: %s", path, strerror(errno));

@


1.235
log
@Fix debug call for port forwards; patch from pete at seebeyond.com, ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.234 2005/03/10 22:01:06 deraadt Exp $");
d548 1
a548 1
	if (!isatty(fileno(stdin)) && !force_tty_flag) {
@


1.234
log
@spacing
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.233 2005/03/01 17:22:06 jmc Exp $");
d868 2
@


1.234.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.249 2005/07/30 01:26:16 djm Exp $");
d148 1
a148 1
static u_int mux_command = 0;
a187 1
	struct servent *sp;
d384 2
a385 4
			if (options.control_master == SSHCTL_MASTER_YES)
				options.control_master = SSHCTL_MASTER_ASK;
			else
				options.control_master = SSHCTL_MASTER_YES;
d434 1
a434 1
				fwd.listen_host = NULL;
d548 1
a548 1
	if ((!isatty(fileno(stdin)) || stdin_null_flag) && !force_tty_flag) {
a599 6
	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}

a602 3
	if (options.control_path != NULL &&
	    strcmp(options.control_path, "none") == 0)
		options.control_path = NULL;
d605 5
a609 11
		snprintf(buf, sizeof(buf), "%d", options.port);
		cp = tilde_expand_filename(options.control_path,
		    original_real_uid);
		options.control_path = percent_expand(cp, "p", buf, "h", host,
		    "r", options.user, (char *)NULL);
		xfree(cp);
	}
	if (mux_command != 0 && options.control_path == NULL)
		fatal("No ControlPath specified for \"-O\" command");
	if (options.control_path != NULL)
		control_client(options.control_path);
d734 104
a867 2
		    (options.remote_forwards[i].listen_host == NULL) ?
		    (options.gateway_ports ? "*" : "LOCALHOST") :
a897 1
	const char *display;
d959 1
a959 2
	display = getenv("DISPLAY");
	if (options.forward_x11 && display != NULL) {
d962 1
a962 2
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
d965 1
a965 1
		x11_request_forwarding_with_spoofing(0, display, proto, data);
d1066 1
a1066 2
	if (options.control_path == NULL ||
	    options.control_master == SSHCTL_MASTER_NO)
a1068 2
	debug("setting up multiplex master socket");

d1084 1
a1084 1
		if (errno == EINVAL || errno == EADDRINUSE)
d1103 1
a1103 1
	const char *display;
d1105 1
a1105 3

	display = getenv("DISPLAY");
	if (options.forward_x11 && display != NULL) {
d1108 1
a1108 2
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
d1111 1
a1111 1
		x11_request_forwarding_with_spoofing(id, display, proto, data);
d1279 7
a1285 12
	if (mux_command == 0)
		mux_command = SSHMUX_COMMAND_OPEN;

	switch (options.control_master) {
	case SSHCTL_MASTER_AUTO:
	case SSHCTL_MASTER_AUTO_ASK:
		debug("auto-mux: Trying existing master");
		/* FALLTHROUGH */
	case SSHCTL_MASTER_NO:
		break;
	default:
		return;
d1300 2
a1301 23
	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1) {
		if (mux_command != SSHMUX_COMMAND_OPEN) {
			fatal("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		if (errno == ENOENT)
	 		debug("Control socket \"%.100s\" does not exist", path);
		else {
	 		error("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
 		close(sock);
 		return;
 	}

 	if (stdin_null_flag) {
 		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
 			fatal("open(/dev/null): %s", strerror(errno));
 		if (dup2(fd, STDIN_FILENO) == -1)
 			fatal("dup2: %s", strerror(errno));
 		if (fd > STDERR_FILENO)
 			close(fd);
 	}
d1303 2
a1304 1
	term = getenv("TERM");
a1310 4
	if (options.forward_x11)
		flags |= SSHMUX_FLAG_X11_FWD;
	if (options.forward_agent)
		flags |= SSHMUX_FLAG_AGENT_FWD;
d1317 1
a1317 1
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
d1324 1
a1324 1
	if (buffer_get_char(&m) != SSHMUX_VER)
d1348 1
a1348 1
	buffer_put_cstring(&m, term ? term : "");
d1370 1
a1370 1
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
d1381 1
a1381 1
	if (buffer_get_char(&m) != SSHMUX_VER)
@


1.234.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.257 2005/12/20 04:41:07 dtucker Exp $");
d161 1
a161 1
"           [-D [bind_address:]port] [-e escape_char] [-F configfile]\n"
d165 1
a165 1
"           [-w tunnel:tunnel] [user@@]hostname [command]\n"
d167 1
a167 1
	exit(255);
a190 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d218 1
a218 1
		exit(255);
d239 1
a239 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVw:XY")) != -1) {
a334 9
		case 'w':
			if (options.tun_open == -1)
				options.tun_open = SSH_TUNMODE_DEFAULT;
			options.tun_local = a2tun(optarg, &options.tun_remote);
			if (options.tun_local == SSH_TUNID_ERR) {
				fprintf(stderr, "Bad tun device '%s'\n", optarg);
				exit(255);
			}
			break;
d350 1
a350 1
				exit(255);
d365 1
a365 1
					exit(255);
d381 1
a381 1
				exit(255);
d394 1
a394 1
				exit(255);
d408 1
a408 1
				exit(255);
d419 1
a419 1
				exit(255);
d430 1
a430 1
				exit(255);
d443 1
a443 1
				exit(255);
d464 1
a464 1
				exit(255);
d634 1
a634 1
		exit(255);
d687 1
a687 1
	 * directory if it doesn't already exist.
d783 2
a784 1
		    "LOCALHOST" : options.remote_forwards[i].listen_host,
d800 1
a800 1
		/* Clear agent forwarding if we don't have an agent. */
d1001 1
a1001 1
		fatal("%s socket(): %s", __func__, strerror(errno));
d1010 1
a1010 1
			fatal("%s bind(): %s", __func__, strerror(errno));
d1015 1
a1015 1
		fatal("%s listen(): %s", __func__, strerror(errno));
a1047 22
	if (options.tun_open != SSH_TUNMODE_NO) {
		Channel *c;
		int fd;

		debug("Requesting tun.");
		if ((fd = tun_open(options.tun_local,
		    options.tun_open)) >= 0) {
			c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
			    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
			    0, "tun", 1);
			c->datagram = 1;
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("tun@@openssh.com");
			packet_put_int(c->self);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
			packet_put_int(options.tun_open);
			packet_put_int(options.tun_remote);
			packet_send();
		}
	}

a1110 5

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);
@


1.233
log
@sync usage() w/ man SYNOPSIS;
ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.232 2005/03/01 10:09:52 djm Exp $");
d848 2
a849 2
		    (options.local_forwards[i].listen_host == NULL) ? 
		    (options.gateway_ports ? "*" : "LOCALHOST") : 
d1334 1
a1334 1
		fprintf(stderr, "Master running (pid=%d)\r\n", 
@


1.232
log
@bz#413: allow optional specification of bind address for port forwardings.
Patch originally by Dan Astorian, but worked on by several people
Adds GatewayPorts=clientspecified option on server to allow remote forwards
to bind to client-specified ports.

ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.231 2005/02/16 09:56:44 otto Exp $");
d161 2
a162 2
"           [-D [listen-host:]port] [-e escape_char] [-F configfile]\n"
"           [-i identity_file] [-L [listen-host:]port:host:hostport]\n"
d164 1
a164 1
"           [-R [listen-host:]port:host:hostport] [-S ctl_path]\n"
@


1.231
log
@Better diagnostic if an identity file is not accesible. ok markus@@ djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.230 2004/11/07 17:57:30 jmc Exp $");
d161 4
a164 3
"           [-D port] [-e escape_char] [-F configfile] [-i identity_file]\n"
"           [-L port:host:hostport] [-l login_name] [-m mac_spec] [-O ctl_cmd]\n"
"           [-o option] [-p port] [-R port:host:hostport] [-S ctl_path]\n"
a181 2
	u_short fwd_port, fwd_host_port;
	char sfwd_port[6], sfwd_host_port[6];
d188 1
d399 3
a401 5
		case 'R':
			if (sscanf(optarg, "%5[0-9]:%255[^:]:%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3 &&
			    sscanf(optarg, "%5[0-9]/%255[^/]/%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3) {
d403 1
a403 1
				    "Bad forwarding specification '%s'\n",
d405 1
a405 2
				usage();
				/* NOTREACHED */
d407 6
a412 2
			if ((fwd_port = a2port(sfwd_port)) == 0 ||
			    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
d414 2
a415 1
				    "Bad forwarding port(s) '%s'\n", optarg);
a417 6
			if (opt == 'L')
				add_local_forward(&options, fwd_port, buf,
				    fwd_host_port);
			else if (opt == 'R')
				add_remote_forward(&options, fwd_port, buf,
				    fwd_host_port);
d421 17
a437 2
			fwd_port = a2port(optarg);
			if (fwd_port == 0) {
d442 2
a443 1
			add_local_forward(&options, fwd_port, "socks", 0);
d846 8
a853 4
		debug("Connections to local port %d forwarded to remote address %.200s:%d",
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port);
d855 4
a858 3
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port,
d866 6
a871 4
		debug("Connections to remote port %d forwarded to local address %.200s:%d",
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
d873 4
a876 3
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
d1052 3
a1054 3
	    options.remote_forwards[i].port,
	    options.remote_forwards[i].host,
	    options.remote_forwards[i].host_port);
d1056 2
a1057 2
		logit("Warning: remote port forwarding failed for listen port %d",
		    options.remote_forwards[i].port);
@


1.230
log
@usage():
- add -O
- sync -S w/ manpage
- remove -h
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.229 2004/11/07 00:01:46 djm Exp $");
d295 2
a296 1
				    "does not exist.\n", optarg);
@


1.229
log
@add basic control of a running multiplex master connection; including the
ability to check its status and request it to exit; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.228 2004/09/23 13:00:04 djm Exp $");
d160 1
a160 1
"usage: ssh [-1246AaCfghkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d162 3
a164 2
"           [-L port:host:hostport] [-l login_name] [-m mac_spec] [-o option]\n"
"           [-p port] [-R port:host:hostport] [-S ctl] [user@@]hostname [command]\n"
@


1.228
log
@correctly honour -n in multiplex client mode; spotted by sturm@@ ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.227 2004/09/15 00:46:01 deraadt Exp $");
d147 3
d237 1
a237 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNPR:S:TVXY")) != -1) {
d271 8
d1253 1
a1253 1
	char *cp;
d1255 1
d1281 8
a1288 2
	if ((cp = getenv("TERM")) == NULL)
		cp = "";
d1292 8
a1299 1
	/* Get PID of controlee */
d1302 1
a1302 1
	if (buffer_get_char(&m) != 0)
a1303 1
	/* Connection allowed? */
a1308 3
	buffer_put_int(&m, tty_flag);
	buffer_put_int(&m, subsystem_flag);
	buffer_put_cstring(&m, cp);
d1310 17
d1348 1
a1348 1
	if (ssh_msg_send(sock, /* version */0, &m) == -1)
d1359 2
a1360 2
	if (buffer_get_char(&m) != 0)
		fatal("%s: master returned error", __func__);
@


1.227
log
@/* fallthrough */ is something a programmer understands.  But
/* FALLTHROUGH */ is also understood by lint, so that is better.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.226 2004/09/07 23:41:30 djm Exp $");
d1240 1
a1240 1
	int i, r, sock, exitval, num_env;
d1244 9
@


1.226
log
@cleanup multiplex control socket on SIGHUP too, spotted by sturm@@
ok markus@@ deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.225 2004/08/23 14:26:38 dtucker Exp $");
d314 1
a314 1
			/* fallthrough */
@


1.226.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.233 2005/03/01 17:22:06 jmc Exp $");
a146 3
/* Multiplexing control command */
static u_int mux_command = SSHMUX_COMMAND_OPEN;

d157 4
a160 6
"usage: ssh [-1246AaCfgkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
"           [-D port] [-e escape_char] [-F configfile]\n"
"           [-i identity_file] [-L [bind_address:]port:host:hostport]\n"
"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
"           [-R [bind_address:]port:host:hostport] [-S ctl_path]\n"
"           [user@@]hostname [command]\n"
d177 2
a184 1
	Forward fwd;
d234 1
a234 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVXY")) != -1) {
a267 8
		case 'O':
			if (strcmp(optarg, "check") == 0)
				mux_command = SSHMUX_COMMAND_ALIVE_CHECK;
			else if (strcmp(optarg, "exit") == 0)
				mux_command = SSHMUX_COMMAND_TERMINATE;
			else
				fatal("Invalid multiplex command.");
			break;
d283 1
a283 2
				    "not accessible: %s.\n", optarg,
				    strerror(errno));
d314 1
a314 1
			/* FALLTHROUGH */
d386 5
a390 3
			if (parse_forward(&fwd, optarg))
				add_local_forward(&options, &fwd);
			else {
d392 1
a392 1
				    "Bad local forwarding specification '%s'\n",
d394 2
a395 1
				exit(1);
d397 2
a398 6
			break;

		case 'R':
			if (parse_forward(&fwd, optarg)) {
				add_remote_forward(&options, &fwd);
			} else {
d400 1
a400 2
				    "Bad remote forwarding specification "
				    "'%s'\n", optarg);
d403 6
d412 2
a413 17
			cp = p = xstrdup(optarg);
			memset(&fwd, '\0', sizeof(fwd));
			fwd.connect_host = "socks";
			if ((fwd.listen_host = hpdelim(&cp)) == NULL) {
				fprintf(stderr, "Bad dynamic forwarding "
				    "specification '%.100s'\n", optarg);
				exit(1);
			}
			if (cp != NULL) {
				fwd.listen_port = a2port(cp);
				fwd.listen_host = cleanhostname(fwd.listen_host);
			} else {
				fwd.listen_port = a2port(fwd.listen_host);
				fwd.listen_host = "";
			}

			if (fwd.listen_port == 0) {
d418 1
a418 2
			add_local_forward(&options, &fwd);
			xfree(p);
d821 4
a824 8
		debug("Local connections to %.200s:%d forwarded to remote "
		    "address %.200s:%d",
		    (options.local_forwards[i].listen_host == NULL) ? 
		    (options.gateway_ports ? "*" : "LOCALHOST") : 
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port);
d826 3
a828 4
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port,
d836 4
a839 6
		debug("Remote connections from %.200s:%d forwarded to "
		    "local address %.200s:%d",
		    options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
d841 3
a843 4
		    options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
d1019 3
a1021 3
	    options.remote_forwards[i].listen_port,
	    options.remote_forwards[i].connect_host,
	    options.remote_forwards[i].connect_port);
d1023 2
a1024 2
		logit("Warning: remote port forwarding failed for listen "
		    "port %d", options.remote_forwards[i].listen_port);
d1240 1
a1240 1
	int i, r, fd, sock, exitval, num_env;
d1242 1
a1242 1
	char *term;
a1243 10
	u_int  flags;

	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}
d1260 2
a1261 8
	if ((term = getenv("TERM")) == NULL)
		term = "";

	flags = 0;
	if (tty_flag)
		flags |= SSHMUX_FLAG_TTY;
	if (subsystem_flag)
		flags |= SSHMUX_FLAG_SUBSYS;
d1265 1
a1265 8
	/* Send our command to server */
	buffer_put_int(&m, mux_command);
	buffer_put_int(&m, flags);
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
		fatal("%s: msg_send", __func__);
	buffer_clear(&m);

	/* Get authorisation status and PID of controlee */
d1268 1
a1268 1
	if (buffer_get_char(&m) != 1)
d1270 1
d1276 3
a1279 17
	switch (mux_command) {
	case SSHMUX_COMMAND_ALIVE_CHECK:
		fprintf(stderr, "Master running (pid=%d)\r\n", 
		    control_server_pid);
		exit(0);
	case SSHMUX_COMMAND_TERMINATE:
		fprintf(stderr, "Exit request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_OPEN:
		/* continue below */
		break;
	default:
		fatal("silly mux_command %d", mux_command);
	}

	/* SSHMUX_COMMAND_OPEN */
	buffer_put_cstring(&m, term);
d1301 1
a1301 1
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
d1312 2
a1313 2
	if (buffer_get_char(&m) != 1)
		fatal("%s: wrong version", __func__);
@


1.226.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.234 2005/03/10 22:01:06 deraadt Exp $");
d848 2
a849 2
		    (options.local_forwards[i].listen_host == NULL) ?
		    (options.gateway_ports ? "*" : "LOCALHOST") :
d1334 1
a1334 1
		fprintf(stderr, "Master running (pid=%d)\r\n",
@


1.226.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.249 2005/07/30 01:26:16 djm Exp $");
d148 1
a148 1
static u_int mux_command = 0;
a187 1
	struct servent *sp;
d384 2
a385 4
			if (options.control_master == SSHCTL_MASTER_YES)
				options.control_master = SSHCTL_MASTER_ASK;
			else
				options.control_master = SSHCTL_MASTER_YES;
d434 1
a434 1
				fwd.listen_host = NULL;
d548 1
a548 1
	if ((!isatty(fileno(stdin)) || stdin_null_flag) && !force_tty_flag) {
a599 6
	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}

a602 3
	if (options.control_path != NULL &&
	    strcmp(options.control_path, "none") == 0)
		options.control_path = NULL;
d605 5
a609 11
		snprintf(buf, sizeof(buf), "%d", options.port);
		cp = tilde_expand_filename(options.control_path,
		    original_real_uid);
		options.control_path = percent_expand(cp, "p", buf, "h", host,
		    "r", options.user, (char *)NULL);
		xfree(cp);
	}
	if (mux_command != 0 && options.control_path == NULL)
		fatal("No ControlPath specified for \"-O\" command");
	if (options.control_path != NULL)
		control_client(options.control_path);
d734 104
a867 2
		    (options.remote_forwards[i].listen_host == NULL) ?
		    (options.gateway_ports ? "*" : "LOCALHOST") :
a897 1
	const char *display;
d959 1
a959 2
	display = getenv("DISPLAY");
	if (options.forward_x11 && display != NULL) {
d962 1
a962 2
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
d965 1
a965 1
		x11_request_forwarding_with_spoofing(0, display, proto, data);
d1066 1
a1066 2
	if (options.control_path == NULL ||
	    options.control_master == SSHCTL_MASTER_NO)
a1068 2
	debug("setting up multiplex master socket");

d1084 1
a1084 1
		if (errno == EINVAL || errno == EADDRINUSE)
d1103 1
a1103 1
	const char *display;
d1105 1
a1105 3

	display = getenv("DISPLAY");
	if (options.forward_x11 && display != NULL) {
d1108 1
a1108 2
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
d1111 1
a1111 1
		x11_request_forwarding_with_spoofing(id, display, proto, data);
d1279 7
a1285 12
	if (mux_command == 0)
		mux_command = SSHMUX_COMMAND_OPEN;

	switch (options.control_master) {
	case SSHCTL_MASTER_AUTO:
	case SSHCTL_MASTER_AUTO_ASK:
		debug("auto-mux: Trying existing master");
		/* FALLTHROUGH */
	case SSHCTL_MASTER_NO:
		break;
	default:
		return;
d1300 2
a1301 23
	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1) {
		if (mux_command != SSHMUX_COMMAND_OPEN) {
			fatal("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		if (errno == ENOENT)
	 		debug("Control socket \"%.100s\" does not exist", path);
		else {
	 		error("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
 		close(sock);
 		return;
 	}

 	if (stdin_null_flag) {
 		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
 			fatal("open(/dev/null): %s", strerror(errno));
 		if (dup2(fd, STDIN_FILENO) == -1)
 			fatal("dup2: %s", strerror(errno));
 		if (fd > STDERR_FILENO)
 			close(fd);
 	}
d1303 2
a1304 1
	term = getenv("TERM");
a1310 4
	if (options.forward_x11)
		flags |= SSHMUX_FLAG_X11_FWD;
	if (options.forward_agent)
		flags |= SSHMUX_FLAG_AGENT_FWD;
d1317 1
a1317 1
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
d1324 1
a1324 1
	if (buffer_get_char(&m) != SSHMUX_VER)
d1348 1
a1348 1
	buffer_put_cstring(&m, term ? term : "");
d1370 1
a1370 1
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
d1381 1
a1381 1
	if (buffer_get_char(&m) != SSHMUX_VER)
@


1.225
log
@Use permanently_set_uid() in ssh and ssh-keysign for consistency, matches
change in Portable; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.224 2004/07/28 09:40:29 markus Exp $");
d1316 1
@


1.224
log
@more s/illegal/invalid/
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.223 2004/07/11 17:48:47 deraadt Exp $");
d74 1
d637 4
a640 2
	seteuid(original_real_uid);
	setuid(original_real_uid);
@


1.223
log
@spaces
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.222 2004/06/23 14:31:01 dtucker Exp $");
d342 1
a342 1
				options.cipher = SSH_CIPHER_ILLEGAL;
@


1.222
log
@Fix counting in master/slave when passing environment variables; ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.221 2004/06/21 17:36:31 avsm Exp $");
d549 1
a549 1
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host, 
d1029 1
a1029 1
	
d1241 1
a1241 1
	
d1282 1
a1282 1
	} else {	
d1288 1
a1288 1
			
@


1.221
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.220 2004/06/20 17:36:59 djm Exp $");
d1291 3
a1293 2
		for (i = 0; environ[i] != NULL && num_env >= 0; i++, num_env--)
			if (env_permitted(environ[i]))
d1295 1
@


1.220
log
@filter passed env vars at slave in connection sharing case; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.219 2004/06/18 10:55:43 markus Exp $");
d795 1
a795 1
		u_int32_t rand = 0;
d802 1
a802 1
				rand = arc4random();
d804 2
a805 2
			    rand & 0xff);
			rand >>= 8;
@


1.219
log
@trim synopsis for -S, allow -S and -oControlMaster, -MM means 'ask'; ok djm
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.218 2004/06/18 10:40:19 djm Exp $");
d1214 19
d1237 1
a1237 1
	int i, r, sock, exitval;
d1280 15
a1294 6
	/* Pass environment */
	for (i = 0; environ != NULL && environ[i] != NULL; i++)
		;
	buffer_put_int(&m, i);
	for (i = 0; environ != NULL && environ[i] != NULL; i++)
		buffer_put_cstring(&m, environ[i]);
@


1.218
log
@delay signal handler setup until we have finished talking to the master.
allow interrupting of setup (e.g. if master is stuck); ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.217 2004/06/17 23:56:57 djm Exp $");
d159 1
a159 2
"           [-p port] [-R port:host:hostport] [-S ctl_path]\n"
"           [user@@]hostname [command]\n"
d370 2
a371 1
			options.control_master = 1;
a444 2
			if (options.control_master == -1)
				options.control_master = 0;
@


1.217
log
@sync usage() and SYNPOSIS with connection sharing changes
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.216 2004/06/17 15:10:14 djm Exp $");
a1242 4
	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

d1284 4
@


1.216
log
@Add option for confirmation (ControlMaster=ask) via ssh-askpass before opening
shared connections; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.215 2004/06/17 14:52:48 djm Exp $");
d156 1
a156 1
"usage: ssh [-1246AaCfghkNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d159 2
a160 1
"           [-p port] [-R port:host:hostport] [user@@]hostname [command]\n"
@


1.215
log
@support environment passing over shared connections; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.214 2004/06/13 15:03:02 djm Exp $");
d1031 1
a1031 1
	if (options.control_path == NULL || options.control_master != 1)
d1253 3
@


1.214
log
@implement session multiplexing in the client (the server has supported this
since 2.0); ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.213 2004/05/08 00:01:37 deraadt Exp $");
d1067 2
d1089 1
a1089 1
	    NULL, fileno(stdin), &command, &ssh_subsystem_reply);
d1219 1
a1219 1
	int r, sock, exitval;
d1222 1
a1254 2
	/* XXX: env passing */

d1262 7
@


1.213
log
@make two tiny header files go away; djm ok
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.212 2004/04/27 09:46:37 djm Exp $");
d56 1
d62 1
a66 1
#include "dispatch.h"
d72 2
d143 7
d167 1
d233 1
a233 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVXY")) != -1) {
d369 3
d440 7
d579 7
d694 3
d993 1
a993 1
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
a1024 1
/* request pty/x11/agent/tcpfwd/shell for channel */
d1026 1
a1026 1
ssh_session2_setup(int id, void *arg)
d1028 28
a1055 3
	int len;
	int interactive = 0;
	struct termios tio;
d1057 2
a1058 1
	debug2("ssh_session2_setup: id %d", id);
d1060 2
a1061 9
	if (tty_flag) {
		struct winsize ws;
		char *cp;
		cp = getenv("TERM");
		if (!cp)
			cp = "";
		/* Store window size in the packet. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));
d1063 6
a1068 14
		channel_request_start(id, "pty-req", 0);
		packet_put_cstring(cp);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
		tio = get_saved_tio();
		tty_make_modes(/*ignored*/ 0, &tio);
		packet_send();
		interactive = 1;
		/* XXX wait for reply */
	}
	if (options.forward_x11 &&
	    getenv("DISPLAY") != NULL) {
d1086 2
a1087 59
	/* Transfer any environment variables from client to server */
	if (options.num_send_env != 0) {
		int i, j, matched;
		extern char **environ;
		char *name, *val;

		debug("Sending environment.");
		for (i = 0; environ && environ[i] != NULL; i++) {
			/* Split */
			name = xstrdup(environ[i]);
			if ((val = strchr(name, '=')) == NULL) {
				free(name);
				continue;
			}
			*val++ = '\0';

			matched = 0;
			for (j = 0; j < options.num_send_env; j++) {
				if (match_pattern(name, options.send_env[j])) {
					matched = 1;
					break;
				}
			}
			if (!matched) {
				debug3("Ignored env %s", name);
				free(name);
				continue;
			}

			debug("Sending env %s = %s", name, val);
			channel_request_start(id, "env", 0);
			packet_put_cstring(name);
			packet_put_cstring(val);
			packet_send();
			free(name);
		}
	}

	len = buffer_len(&command);
	if (len > 0) {
		if (len > 900)
			len = 900;
		if (subsystem_flag) {
			debug("Sending subsystem: %.*s", len, (u_char *)buffer_ptr(&command));
			channel_request_start(id, "subsystem", /*want reply*/ 1);
			/* register callback for reply */
			/* XXX we assume that client_loop has already been called */
			dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &client_subsystem_reply);
			dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &client_subsystem_reply);
		} else {
			debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
			channel_request_start(id, "exec", 0);
		}
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
		packet_send();
	} else {
		channel_request_start(id, "shell", 0);
		packet_send();
	}
d1133 1
a1133 1
		channel_register_confirm(c->self, ssh_session2_setup);
d1145 1
d1198 107
@


1.212
log
@bz #815: implement ability to pass specified environment variables from the
client to the server; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.211 2004/04/19 21:51:49 djm Exp $");
a64 1
#include "tildexpand.h"
d69 1
a69 1
#include "sshtty.h"
@


1.211
log
@fix idiot typo that i introduced in my last commit;
spotted by cschneid AT cschneid.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.210 2004/04/18 23:10:26 djm Exp $");
d71 1
d1044 38
@


1.210
log
@perform strict ownership and modes checks for ~/.ssh/config files, as these
can be used to execute arbitrary programs; ok markus@@

NB. ssh will now exit when it detects a config with poor permissions
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.209 2004/03/11 10:21:17 markus Exp $");
d520 1
a520 1
		if (!read_config_file(config, host, &options, 0), 0)
@


1.209
log
@ssh, sshd: sync version output, ok djm
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.208 2004/03/10 09:45:06 markus Exp $");
d520 1
a520 1
		if (!read_config_file(config, host, &options))
d526 1
a526 1
		(void)read_config_file(buf, host, &options);
d529 2
a530 1
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host, &options);
@


1.209.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.224 2004/07/28 09:40:29 markus Exp $");
a55 1
#include "bufaux.h"
a60 1
#include "dispatch.h"
d65 2
d70 1
a70 4
#include "sshpty.h"
#include "match.h"
#include "msg.h"
#include "monitor_fdpass.h"
a139 7
/* fd to control socket */
int control_fd = -1;

/* Only used in control client mode */
volatile sig_atomic_t control_client_terminate = 0;
u_int control_server_pid = 0;

d146 1
a146 1
"usage: ssh [-1246AaCfghkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d149 1
a149 1
"           [-p port] [-R port:host:hostport] [-S ctl] [user@@]hostname [command]\n"
a156 1
static void control_client(const char *path);
d222 1
a222 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNPR:S:TVXY")) != -1) {
d331 1
a331 1
				options.cipher = SSH_CIPHER_INVALID;
a357 4
		case 'M':
			options.control_master =
			    (options.control_master >= 1) ? 2 : 1;
			break;
a425 5
		case 'S':
			if (options.control_path != NULL)
				free(options.control_path);
			options.control_path = xstrdup(optarg);
			break;
d520 1
a520 1
		if (!read_config_file(config, host, &options, 0))
d526 1
a526 1
		(void)read_config_file(buf, host, &options, 1);
d529 1
a529 2
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host,
		    &options, 0);
a556 7
	if (options.control_path != NULL) {
		options.control_path = tilde_expand_filename(
		   options.control_path, original_real_uid);
	}
	if (options.control_path != NULL && options.control_master == 0)
		control_client(options.control_path); /* This doesn't return */

a664 3
	if (options.control_path != NULL && control_fd != -1)
		unlink(options.control_path);

d764 1
a764 1
		u_int32_t rnd = 0;
d771 1
a771 1
				rnd = arc4random();
d773 2
a774 2
			    rnd & 0xff);
			rnd >>= 8;
d961 1
a961 1
ssh_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d993 1
d995 1
a995 1
ssh_control_listener(void)
d997 3
a999 2
	struct sockaddr_un addr;
	mode_t old_umask;
d1001 11
a1011 2
	if (options.control_path == NULL || options.control_master <= 0)
		return;
d1013 11
a1023 20
	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(options.control_path) + 1;

	if (strlcpy(addr.sun_path, options.control_path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((control_fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s\n", __func__, strerror(errno));

	old_umask = umask(0177);
	if (bind(control_fd, (struct sockaddr*)&addr, addr.sun_len) == -1) {
		control_fd = -1;
		if (errno == EINVAL)
			fatal("ControlSocket %s already exists",
			    options.control_path);
		else
			fatal("%s bind(): %s\n", __func__, strerror(errno));
d1025 2
a1026 16
	umask(old_umask);

	if (listen(control_fd, 64) == -1)
		fatal("%s listen(): %s\n", __func__, strerror(errno));

	set_nonblock(control_fd);
}

/* request pty/x11/agent/tcpfwd/shell for channel */
static void
ssh_session2_setup(int id, void *arg)
{
	extern char **environ;

	int interactive = tty_flag;
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
d1044 21
a1064 2
	client_session2_setup(id, tty_flag, subsystem_flag, getenv("TERM"),
	    NULL, fileno(stdin), &command, environ, &ssh_subsystem_reply);
d1110 1
a1110 1
		channel_register_confirm(c->self, ssh_session2_setup, NULL);
a1121 1
	ssh_control_listener();
a1173 146
}

static void
control_client_sighandler(int signo)
{
	control_client_terminate = signo;
}

static void
control_client_sigrelay(int signo)
{
	if (control_server_pid > 1)
		kill(control_server_pid, signo);
}

static int
env_permitted(char *env)
{
	int i;
	char name[1024], *cp;

	strlcpy(name, env, sizeof(name));
	if ((cp = strchr(name, '=')) == NULL)
		return (0);

	*cp = '\0';

	for (i = 0; i < options.num_send_env; i++)
		if (match_pattern(name, options.send_env[i]))
			return (1);

	return (0);
}

static void
control_client(const char *path)
{
	struct sockaddr_un addr;
	int i, r, sock, exitval, num_env;
	Buffer m;
	char *cp;
	extern char **environ;

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(path) + 1;

	if (strlcpy(addr.sun_path, path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1)
		fatal("Couldn't connect to %s: %s", path, strerror(errno));

	if ((cp = getenv("TERM")) == NULL)
		cp = "";

	buffer_init(&m);

	/* Get PID of controlee */
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: wrong version", __func__);
	/* Connection allowed? */
	if (buffer_get_int(&m) != 1)
		fatal("Connection to master denied");
	control_server_pid = buffer_get_int(&m);

	buffer_clear(&m);
	buffer_put_int(&m, tty_flag);
	buffer_put_int(&m, subsystem_flag);
	buffer_put_cstring(&m, cp);

	buffer_append(&command, "\0", 1);
	buffer_put_cstring(&m, buffer_ptr(&command));

	if (options.num_send_env == 0 || environ == NULL) {
		buffer_put_int(&m, 0);
	} else {
		/* Pass environment */
		num_env = 0;
		for (i = 0; environ[i] != NULL; i++)
			if (env_permitted(environ[i]))
				num_env++; /* Count */

		buffer_put_int(&m, num_env);

		for (i = 0; environ[i] != NULL && num_env >= 0; i++)
			if (env_permitted(environ[i])) {
				num_env--;
				buffer_put_cstring(&m, environ[i]);
			}
	}

	if (ssh_msg_send(sock, /* version */0, &m) == -1)
		fatal("%s: msg_send", __func__);

	mm_send_fd(sock, STDIN_FILENO);
	mm_send_fd(sock, STDOUT_FILENO);
	mm_send_fd(sock, STDERR_FILENO);

	/* Wait for reply, so master has a chance to gather ttymodes */
	buffer_clear(&m);
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: master returned error", __func__);
	buffer_free(&m);

	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

	if (tty_flag)
		enter_raw_mode();

	/* Stick around until the controlee closes the client_fd */
	exitval = 0;
	for (;!control_client_terminate;) {
		r = read(sock, &exitval, sizeof(exitval));
		if (r == 0) {
			debug2("Received EOF from master");
			break;
		}
		if (r > 0)
			debug2("Received exit status from master %d", exitval);
		if (r == -1 && errno != EINTR)
			fatal("%s: read %s", __func__, strerror(errno));
	}

	if (control_client_terminate)
		debug2("Exiting on signal %d", control_client_terminate);

	close(sock);

	leave_raw_mode();

	if (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "Connection to master closed.\r\n");

	exit(exitval);
@


1.209.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.233 2005/03/01 17:22:06 jmc Exp $");
a73 1
#include "uidswap.h"
a145 3
/* Multiplexing control command */
static u_int mux_command = SSHMUX_COMMAND_OPEN;

d156 4
a159 6
"usage: ssh [-1246AaCfgkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
"           [-D port] [-e escape_char] [-F configfile]\n"
"           [-i identity_file] [-L [bind_address:]port:host:hostport]\n"
"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
"           [-R [bind_address:]port:host:hostport] [-S ctl_path]\n"
"           [user@@]hostname [command]\n"
d176 2
a183 1
	Forward fwd;
d233 1
a233 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVXY")) != -1) {
a266 8
		case 'O':
			if (strcmp(optarg, "check") == 0)
				mux_command = SSHMUX_COMMAND_ALIVE_CHECK;
			else if (strcmp(optarg, "exit") == 0)
				mux_command = SSHMUX_COMMAND_TERMINATE;
			else
				fatal("Invalid multiplex command.");
			break;
d282 1
a282 2
				    "not accessible: %s.\n", optarg,
				    strerror(errno));
d313 1
a313 1
			/* FALLTHROUGH */
d385 5
a389 3
			if (parse_forward(&fwd, optarg))
				add_local_forward(&options, &fwd);
			else {
d391 1
a391 1
				    "Bad local forwarding specification '%s'\n",
d393 2
a394 1
				exit(1);
d396 2
a397 6
			break;

		case 'R':
			if (parse_forward(&fwd, optarg)) {
				add_remote_forward(&options, &fwd);
			} else {
d399 1
a399 2
				    "Bad remote forwarding specification "
				    "'%s'\n", optarg);
d402 6
d411 2
a412 17
			cp = p = xstrdup(optarg);
			memset(&fwd, '\0', sizeof(fwd));
			fwd.connect_host = "socks";
			if ((fwd.listen_host = hpdelim(&cp)) == NULL) {
				fprintf(stderr, "Bad dynamic forwarding "
				    "specification '%.100s'\n", optarg);
				exit(1);
			}
			if (cp != NULL) {
				fwd.listen_port = a2port(cp);
				fwd.listen_host = cleanhostname(fwd.listen_host);
			} else {
				fwd.listen_port = a2port(fwd.listen_host);
				fwd.listen_host = "";
			}

			if (fwd.listen_port == 0) {
d417 1
a417 2
			add_local_forward(&options, &fwd);
			xfree(p);
d636 2
a637 4
	if (original_effective_uid == 0) {
		PRIV_START;
		permanently_set_uid(pw);
	}
d818 4
a821 8
		debug("Local connections to %.200s:%d forwarded to remote "
		    "address %.200s:%d",
		    (options.local_forwards[i].listen_host == NULL) ? 
		    (options.gateway_ports ? "*" : "LOCALHOST") : 
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port);
d823 3
a825 4
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port,
d833 4
a836 6
		debug("Remote connections from %.200s:%d forwarded to "
		    "local address %.200s:%d",
		    options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
d838 3
a840 4
		    options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
d1016 3
a1018 3
	    options.remote_forwards[i].listen_port,
	    options.remote_forwards[i].connect_host,
	    options.remote_forwards[i].connect_port);
d1020 2
a1021 2
		logit("Warning: remote port forwarding failed for listen "
		    "port %d", options.remote_forwards[i].listen_port);
d1237 1
a1237 1
	int i, r, fd, sock, exitval, num_env;
d1239 1
a1239 1
	char *term;
a1240 10
	u_int  flags;

	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}
d1257 2
a1258 8
	if ((term = getenv("TERM")) == NULL)
		term = "";

	flags = 0;
	if (tty_flag)
		flags |= SSHMUX_FLAG_TTY;
	if (subsystem_flag)
		flags |= SSHMUX_FLAG_SUBSYS;
d1262 1
a1262 8
	/* Send our command to server */
	buffer_put_int(&m, mux_command);
	buffer_put_int(&m, flags);
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
		fatal("%s: msg_send", __func__);
	buffer_clear(&m);

	/* Get authorisation status and PID of controlee */
d1265 1
a1265 1
	if (buffer_get_char(&m) != 1)
d1267 1
d1273 3
a1276 17
	switch (mux_command) {
	case SSHMUX_COMMAND_ALIVE_CHECK:
		fprintf(stderr, "Master running (pid=%d)\r\n", 
		    control_server_pid);
		exit(0);
	case SSHMUX_COMMAND_TERMINATE:
		fprintf(stderr, "Exit request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_OPEN:
		/* continue below */
		break;
	default:
		fatal("silly mux_command %d", mux_command);
	}

	/* SSHMUX_COMMAND_OPEN */
	buffer_put_cstring(&m, term);
d1298 1
a1298 1
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
d1309 2
a1310 2
	if (buffer_get_char(&m) != 1)
		fatal("%s: wrong version", __func__);
a1312 1
	signal(SIGHUP, control_client_sighandler);
@


1.208
log
@trim usage to match ssh(1) and look more like unix. ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.207 2004/03/09 22:11:05 markus Exp $");
d304 2
a305 6
			fprintf(stderr,
			    "%s, SSH protocols %d.%d/%d.%d, %s\n",
			    SSH_VERSION,
			    PROTOCOL_MAJOR_1, PROTOCOL_MINOR_1,
			    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2,
			    SSLeay_version(SSLEAY_VERSION));
@


1.207
log
@increase x11 cookie lifetime to 20 minutes; ok djm
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.206 2003/12/16 15:49:51 markus Exp $");
d145 6
a150 43
	fprintf(stderr, "Usage: %s [options] host [command]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -l user     Log in using this user name.\n");
	fprintf(stderr, "  -n          Redirect input from " _PATH_DEVNULL ".\n");
	fprintf(stderr, "  -F config   Config file (default: ~/%s).\n",
	     _PATH_SSH_USER_CONFFILE);
	fprintf(stderr, "  -A          Enable authentication agent forwarding.\n");
	fprintf(stderr, "  -a          Disable authentication agent forwarding (default).\n");
	fprintf(stderr, "  -X          Enable X11 connection forwarding.\n");
	fprintf(stderr, "  -Y          Enable trusted X11 connection forwarding.\n");
	fprintf(stderr, "  -x          Disable X11 connection forwarding (default).\n");
	fprintf(stderr, "  -i file     Identity for public key authentication "
	    "(default: ~/.ssh/identity)\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -I reader   Set smartcard reader.\n");
#endif
	fprintf(stderr, "  -t          Tty; allocate a tty even if command is given.\n");
	fprintf(stderr, "  -T          Do not allocate a tty.\n");
	fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
	fprintf(stderr, "              Multiple -v increases verbosity.\n");
	fprintf(stderr, "  -V          Display version number only.\n");
	fprintf(stderr, "  -q          Quiet; don't display any warning messages.\n");
	fprintf(stderr, "  -f          Fork into background after authentication.\n");
	fprintf(stderr, "  -e char     Set escape character; ``none'' = disable (default: ~).\n");

	fprintf(stderr, "  -c cipher   Select encryption algorithm\n");
	fprintf(stderr, "  -m macs     Specify MAC algorithms for protocol version 2.\n");
	fprintf(stderr, "  -p port     Connect to this port.  Server must be on the same port.\n");
	fprintf(stderr, "  -L listen-port:host:port   Forward local port to remote address\n");
	fprintf(stderr, "  -R listen-port:host:port   Forward remote port to local address\n");
	fprintf(stderr, "              These cause %s to listen for connections on a port, and\n", __progname);
	fprintf(stderr, "              forward them to the other side by connecting to host:port.\n");
	fprintf(stderr, "  -D port     Enable dynamic application-level port forwarding.\n");
	fprintf(stderr, "  -C          Enable compression.\n");
	fprintf(stderr, "  -N          Do not execute a shell or command.\n");
	fprintf(stderr, "  -g          Allow remote hosts to connect to forwarded ports.\n");
	fprintf(stderr, "  -1          Force protocol version 1.\n");
	fprintf(stderr, "  -2          Force protocol version 2.\n");
	fprintf(stderr, "  -4          Use IPv4 only.\n");
	fprintf(stderr, "  -6          Use IPv6 only.\n");
	fprintf(stderr, "  -o 'option' Process the option as if it was read from a configuration file.\n");
	fprintf(stderr, "  -s          Invoke command (mandatory) as SSH2 subsystem.\n");
	fprintf(stderr, "  -b addr     Local IP address.\n");
@


1.206
log
@application layer keep alive (ServerAliveInterval ServerAliveCountMax)
for ssh(1), similar to the sshd(8) option; ok beck@@; with help from
jmc and dtucker@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.205 2003/12/09 17:30:05 markus Exp $");
d765 1
a765 1
				    " untrusted timeout 120 2>" _PATH_DEVNULL,
@


1.205
log
@don't modify argv for ssh -o; similar to sshd.c 1.283
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.204 2003/11/24 00:16:35 dtucker Exp $");
d1017 1
a1017 1
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
d1022 1
a1022 3
	if (i >= options.num_remote_forwards) {
		debug("client_global_request_reply: too many replies %d > %d",
		    i, options.num_remote_forwards);
a1023 1
	}
@


1.204
log
@Make ssh -k mean GSSAPIDelegateCredentials=no. Suggestion & ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.203 2003/11/21 11:57:03 djm Exp $");
d204 1
a204 1
	char *p, *cp, buf[256];
d458 1
d460 1
a460 1
			    optarg, "command-line", 0, &dummy) != 0)
d462 1
@


1.203
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.202 2003/10/11 08:24:08 markus Exp $");
d303 1
a303 1
			/* ignored for backward compatibility */
@


1.202
log
@remote x11 clients are now untrusted by default, uses xauth(8) to generate
untrusted cookies; ForwardX11Trusted=yes restores old behaviour.
ok deraadt; feedback and ok djm/fries
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.201 2003/09/01 18:15:50 markus Exp $");
d597 1
a597 1
	if (ssh_connect(host, &hostaddr, options.port, 
d705 1
a705 1
	 * Send SIGHUP to proxy command if used. We don't wait() in 
@


1.201
log
@remove unused kerberos code; ok henning@@
@
text
@d16 1
a16 1
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.200 2003/08/13 09:07:10 markus Exp $");
d154 1
d259 1
a259 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVX")) != -1) {
d286 4
d714 2
d719 1
d721 1
d724 2
a725 2
	int got_data = 0, i;
	char *display;
d728 1
d732 1
d741 37
a777 16
		/* Try to get Xauthority information for the display. */
		if (strncmp(display, "localhost:", 10) == 0)
			/*
			 * Handle FamilyLocal case where $DISPLAY does
			 * not match an authorization entry.  For this we
			 * just try "xauth list unix:displaynum.screennum".
			 * XXX: "localhost" match to determine FamilyLocal
			 *      is not perfect.
			 */
			snprintf(line, sizeof line, "%s list unix:%s 2>"
			    _PATH_DEVNULL, options.xauth_location, display+10);
		else
			snprintf(line, sizeof line, "%s list %.200s 2>"
			    _PATH_DEVNULL, options.xauth_location, display);
		debug2("x11_get_proto: %s", line);
		f = popen(line, "r");
d784 10
d805 3
a807 2
		logit("Warning: No xauth data; using fake authentication data for X11 forwarding.");
		strlcpy(proto, "MIT-MAGIC-COOKIE-1", sizeof proto);
d811 2
a812 1
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x", rand & 0xff);
@


1.201.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d16 1
a16 1
 * Copyright (c) 2000, 2001, 2002, 2003 Markus Friedl.  All rights reserved.
d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.206 2003/12/16 15:49:51 markus Exp $");
a153 1
	fprintf(stderr, "  -Y          Enable trusted X11 connection forwarding.\n");
d203 1
a203 1
	char *p, *cp, *line, buf[256];
d258 1
a258 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVXY")) != -1) {
a284 4
		case 'Y':
			options.forward_x11 = 1;
			options.forward_x11_trusted = 1;
			break;
d298 1
a298 1
			options.gss_deleg_creds = 0;
a452 1
			line = xstrdup(optarg);
d454 1
a454 1
			    line, "command-line", 0, &dummy) != 0)
a455 1
			xfree(line);
d592 1
a592 1
	if (ssh_connect(host, &hostaddr, options.port,
d700 1
a700 1
	 * Send SIGHUP to proxy command if used. We don't wait() in
a708 2
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"

a711 1
	char cmd[1024];
a712 1
	char xdisplay[512];
d715 2
a716 2
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *display, *xauthdir, *xauthfile;
a718 1
	xauthdir = xauthfile = NULL;
a721 1

d730 16
a745 37
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (options.forward_x11_trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 120 2>" _PATH_DEVNULL,
				    options.xauth_location, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    options.xauth_location,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
a751 10

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

d763 2
a764 3
		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
d768 1
a768 2
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rand & 0xff);
d971 1
a971 1
client_global_request_reply_fwd(int type, u_int32_t seq, void *ctxt)
d976 3
a978 1
	if (i >= options.num_remote_forwards)
d980 1
@


1.201.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.224 2004/07/28 09:40:29 markus Exp $");
a55 1
#include "bufaux.h"
a60 1
#include "dispatch.h"
d65 2
d70 1
a70 4
#include "sshpty.h"
#include "match.h"
#include "msg.h"
#include "monitor_fdpass.h"
a139 7
/* fd to control socket */
int control_fd = -1;

/* Only used in control client mode */
volatile sig_atomic_t control_client_terminate = 0;
u_int control_server_pid = 0;

d145 43
a187 6
	fprintf(stderr,
"usage: ssh [-1246AaCfghkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
"           [-D port] [-e escape_char] [-F configfile] [-i identity_file]\n"
"           [-L port:host:hostport] [-l login_name] [-m mac_spec] [-o option]\n"
"           [-p port] [-R port:host:hostport] [-S ctl] [user@@]hostname [command]\n"
	);
a193 1
static void control_client(const char *path);
d259 1
a259 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNPR:S:TVXY")) != -1) {
d341 6
a346 2
			fprintf(stderr, "%s, %s\n",
			    SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
d372 1
a372 1
				options.cipher = SSH_CIPHER_INVALID;
a398 4
		case 'M':
			options.control_master =
			    (options.control_master >= 1) ? 2 : 1;
			break;
a466 5
		case 'S':
			if (options.control_path != NULL)
				free(options.control_path);
			options.control_path = xstrdup(optarg);
			break;
d561 1
a561 1
		if (!read_config_file(config, host, &options, 0))
d567 1
a567 1
		(void)read_config_file(buf, host, &options, 1);
d570 1
a570 2
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host,
		    &options, 0);
a597 7
	if (options.control_path != NULL) {
		options.control_path = tilde_expand_filename(
		   options.control_path, original_real_uid);
	}
	if (options.control_path != NULL && options.control_master == 0)
		control_client(options.control_path); /* This doesn't return */

a705 3
	if (options.control_path != NULL && control_fd != -1)
		unlink(options.control_path);

d765 1
a765 1
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
d805 1
a805 1
		u_int32_t rnd = 0;
d812 1
a812 1
				rnd = arc4random();
d814 2
a815 2
			    rnd & 0xff);
			rnd >>= 8;
d1002 1
a1002 1
ssh_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d1034 1
d1036 1
a1036 1
ssh_control_listener(void)
d1038 3
a1040 2
	struct sockaddr_un addr;
	mode_t old_umask;
d1042 11
a1052 2
	if (options.control_path == NULL || options.control_master <= 0)
		return;
d1054 11
a1064 20
	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(options.control_path) + 1;

	if (strlcpy(addr.sun_path, options.control_path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((control_fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s\n", __func__, strerror(errno));

	old_umask = umask(0177);
	if (bind(control_fd, (struct sockaddr*)&addr, addr.sun_len) == -1) {
		control_fd = -1;
		if (errno == EINVAL)
			fatal("ControlSocket %s already exists",
			    options.control_path);
		else
			fatal("%s bind(): %s\n", __func__, strerror(errno));
d1066 2
a1067 16
	umask(old_umask);

	if (listen(control_fd, 64) == -1)
		fatal("%s listen(): %s\n", __func__, strerror(errno));

	set_nonblock(control_fd);
}

/* request pty/x11/agent/tcpfwd/shell for channel */
static void
ssh_session2_setup(int id, void *arg)
{
	extern char **environ;

	int interactive = tty_flag;
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
d1085 21
a1105 2
	client_session2_setup(id, tty_flag, subsystem_flag, getenv("TERM"),
	    NULL, fileno(stdin), &command, environ, &ssh_subsystem_reply);
d1151 1
a1151 1
		channel_register_confirm(c->self, ssh_session2_setup, NULL);
a1162 1
	ssh_control_listener();
a1214 146
}

static void
control_client_sighandler(int signo)
{
	control_client_terminate = signo;
}

static void
control_client_sigrelay(int signo)
{
	if (control_server_pid > 1)
		kill(control_server_pid, signo);
}

static int
env_permitted(char *env)
{
	int i;
	char name[1024], *cp;

	strlcpy(name, env, sizeof(name));
	if ((cp = strchr(name, '=')) == NULL)
		return (0);

	*cp = '\0';

	for (i = 0; i < options.num_send_env; i++)
		if (match_pattern(name, options.send_env[i]))
			return (1);

	return (0);
}

static void
control_client(const char *path)
{
	struct sockaddr_un addr;
	int i, r, sock, exitval, num_env;
	Buffer m;
	char *cp;
	extern char **environ;

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(path) + 1;

	if (strlcpy(addr.sun_path, path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1)
		fatal("Couldn't connect to %s: %s", path, strerror(errno));

	if ((cp = getenv("TERM")) == NULL)
		cp = "";

	buffer_init(&m);

	/* Get PID of controlee */
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: wrong version", __func__);
	/* Connection allowed? */
	if (buffer_get_int(&m) != 1)
		fatal("Connection to master denied");
	control_server_pid = buffer_get_int(&m);

	buffer_clear(&m);
	buffer_put_int(&m, tty_flag);
	buffer_put_int(&m, subsystem_flag);
	buffer_put_cstring(&m, cp);

	buffer_append(&command, "\0", 1);
	buffer_put_cstring(&m, buffer_ptr(&command));

	if (options.num_send_env == 0 || environ == NULL) {
		buffer_put_int(&m, 0);
	} else {
		/* Pass environment */
		num_env = 0;
		for (i = 0; environ[i] != NULL; i++)
			if (env_permitted(environ[i]))
				num_env++; /* Count */

		buffer_put_int(&m, num_env);

		for (i = 0; environ[i] != NULL && num_env >= 0; i++)
			if (env_permitted(environ[i])) {
				num_env--;
				buffer_put_cstring(&m, environ[i]);
			}
	}

	if (ssh_msg_send(sock, /* version */0, &m) == -1)
		fatal("%s: msg_send", __func__);

	mm_send_fd(sock, STDIN_FILENO);
	mm_send_fd(sock, STDOUT_FILENO);
	mm_send_fd(sock, STDERR_FILENO);

	/* Wait for reply, so master has a chance to gather ttymodes */
	buffer_clear(&m);
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != 0)
		fatal("%s: master returned error", __func__);
	buffer_free(&m);

	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

	if (tty_flag)
		enter_raw_mode();

	/* Stick around until the controlee closes the client_fd */
	exitval = 0;
	for (;!control_client_terminate;) {
		r = read(sock, &exitval, sizeof(exitval));
		if (r == 0) {
			debug2("Received EOF from master");
			break;
		}
		if (r > 0)
			debug2("Received exit status from master %d", exitval);
		if (r == -1 && errno != EINTR)
			fatal("%s: read %s", __func__, strerror(errno));
	}

	if (control_client_terminate)
		debug2("Exiting on signal %d", control_client_terminate);

	close(sock);

	leave_raw_mode();

	if (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "Connection to master closed.\r\n");

	exit(exitval);
@


1.200
log
@socks4->socks, since with support both 4 and 5; dtucker@@zip.com.au
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.199 2003/08/13 08:46:30 markus Exp $");
a152 1
	fprintf(stderr, "  -k          Disable Kerberos ticket forwarding.\n");
d298 1
a298 1
			options.kerberos_tgt_passing = 0;
@


1.199
log
@remove RhostsAuthentication; suggested by djm@@ before; ok djm@@, deraadt@@,
fgsch@@, miod@@, henning@@, jakob@@ and others
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.198 2003/07/22 13:35:22 markus Exp $");
d439 1
a439 1
			add_local_forward(&options, fwd_port, "socks4", 0);
@


1.198
log
@remove (already disabled) KRB4/AFS support, re-enable -k in ssh(1);
test+ok henning@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.197 2003/07/16 10:34:53 markus Exp $");
a591 6
	/* Disable rhosts authentication if not running as root. */
	if (original_effective_uid != 0 || !options.use_privileged_port) {
		debug("Rhosts Authentication disabled, "
		    "originating port will not be trusted.");
		options.rhosts_authentication = 0;
	}
a592 1

@


1.197
log
@don't exit on multiple -v or -d; ok deraadt@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.196 2003/07/03 08:09:06 djm Exp $");
d153 1
a153 3
#ifdef AFS
	fprintf(stderr, "  -k          Disable Kerberos ticket and AFS token forwarding.\n");
#endif				/* AFS */
a297 1
#ifdef AFS
a299 1
			options.afs_token_passing = 0;
a300 1
#endif
@


1.196
log
@fix AddressFamily option in config file, from brent@@graveland.net; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.195 2003/07/02 20:37:48 markus Exp $");
d332 1
a332 1
			if (0 == debug_flag) {
d335 3
a337 2
			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3) {
				options.log_level++;
d339 1
a339 2
			} else
				fatal("Too high debugging level.");
@


1.195
log
@convert hostkeyalias to lowercase, otherwise uppercase aliases will
not match at all; ok henning@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.194 2003/06/12 19:12:03 markus Exp $");
a77 4
/* Flag indicating whether IPv4 or IPv6.  This can be set on the command line.
   Default value is AF_UNSPEC means both IPv4 and IPv6. */
int IPv4or6 = AF_UNSPEC;

d270 1
a270 1
			IPv4or6 = AF_INET;
d273 1
a273 1
			IPv4or6 = AF_INET6;
a503 1
	channel_set_af(IPv4or6);
d575 2
d605 2
a606 2
	if (ssh_connect(host, &hostaddr, options.port, IPv4or6,
	    options.connection_attempts,
@


1.194
log
@add sc_get_key_label; larsch at trustcenter.de; bugzilla#591
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.193 2003/05/15 13:52:10 djm Exp $");
d588 7
@


1.193
log
@Make "ssh -V" print the OpenSSL version in a human readable form. Patch
from Craig Leres (mindrot at ee.lbl.gov); ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.192 2003/05/11 20:30:25 markus Exp $");
d1163 1
a1163 1
			options.identity_files[0] = xstrdup("smartcard key");;
@


1.192
log
@make channel_new() strdup the 'remote_name' (not the caller); ok theo
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.191 2003/04/08 20:21:29 itojun Exp $");
d347 1
a347 1
			    "%s, SSH protocols %d.%d/%d.%d, OpenSSL 0x%8.8lx\n",
d351 1
a351 1
			    SSLeay());
@


1.191
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.190 2003/02/06 09:27:29 markus Exp $");
d1111 1
a1111 1
	    xstrdup("client-session"), /*nonblock*/0);
@


1.190
log
@support 'ProxyCommand none'; bugzilla #433; binder@@arago.de; ok djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.189 2002/12/09 16:50:30 millert Exp $");
d243 1
a243 1
		log("You don't exist, go away!");
d549 1
a549 1
			log("Pseudo-terminal will not be allocated because stdin is not a terminal.");
d772 1
a772 1
		log("Warning: No xauth data; using fake authentication data for X11 forwarding.");
d852 1
a852 1
			log("Warning: Remote host refused compression.");
d891 1
a891 1
			log("Warning: Remote host failed or refused to allocate a pseudo tty.");
d909 1
a909 1
			log("Warning: Remote host denied X11 forwarding.");
d928 1
a928 1
			log("Warning: Remote host denied authentication agent forwarding.");
d996 1
a996 1
		log("Warning: remote port forwarding failed for listen port %d",
@


1.190.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.201 2003/09/01 18:15:50 markus Exp $");
d78 4
d157 3
d243 1
a243 1
		logit("You don't exist, go away!");
d274 1
a274 1
			options.address_family = AF_INET;
d277 1
a277 1
			options.address_family = AF_INET6;
d304 1
d306 2
a307 1
			/* ignored for backward compatibility */
d309 1
d336 1
a336 1
			if (debug_flag == 0) {
d339 2
a340 3
			} else {
				if (options.log_level < SYSLOG_LEVEL_DEBUG3)
					options.log_level++;
d342 2
a343 1
			}
d347 1
a347 1
			    "%s, SSH protocols %d.%d/%d.%d, %s\n",
d351 1
a351 1
			    SSLeay_version(SSLEAY_VERSION));
d448 1
a448 1
			add_local_forward(&options, fwd_port, "socks", 0);
d508 1
d549 1
a549 1
			logit("Pseudo-terminal will not be allocated because stdin is not a terminal.");
a579 2
	channel_set_af(options.address_family);

a588 7
	/* force lowercase for hostkey matching */
	if (options.host_key_alias != NULL) {
		for (p = options.host_key_alias; *p; p++)
			if (isupper(*p))
				*p = tolower(*p);
	}

d593 6
d600 3
a602 2
	if (ssh_connect(host, &hostaddr, options.port, 
	    options.address_family, options.connection_attempts,
d772 1
a772 1
		logit("Warning: No xauth data; using fake authentication data for X11 forwarding.");
d852 1
a852 1
			logit("Warning: Remote host refused compression.");
d891 1
a891 1
			logit("Warning: Remote host failed or refused to allocate a pseudo tty.");
d909 1
a909 1
			logit("Warning: Remote host denied X11 forwarding.");
d928 1
a928 1
			logit("Warning: Remote host denied authentication agent forwarding.");
d996 1
a996 1
		logit("Warning: remote port forwarding failed for listen port %d",
d1111 1
a1111 1
	    "client-session", /*nonblock*/0);
d1163 1
a1163 1
			options.identity_files[0] = sc_get_key_label(keys[i]);
@


1.190.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d16 1
a16 1
 * Copyright (c) 2000, 2001, 2002, 2003 Markus Friedl.  All rights reserved.
d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.206 2003/12/16 15:49:51 markus Exp $");
a153 1
	fprintf(stderr, "  -Y          Enable trusted X11 connection forwarding.\n");
d203 1
a203 1
	char *p, *cp, *line, buf[256];
d258 1
a258 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVXY")) != -1) {
a284 4
		case 'Y':
			options.forward_x11 = 1;
			options.forward_x11_trusted = 1;
			break;
d298 1
a298 1
			options.gss_deleg_creds = 0;
a452 1
			line = xstrdup(optarg);
d454 1
a454 1
			    line, "command-line", 0, &dummy) != 0)
a455 1
			xfree(line);
d592 1
a592 1
	if (ssh_connect(host, &hostaddr, options.port,
d700 1
a700 1
	 * Send SIGHUP to proxy command if used. We don't wait() in
a708 2
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"

a711 1
	char cmd[1024];
a712 1
	char xdisplay[512];
d715 2
a716 2
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *display, *xauthdir, *xauthfile;
a718 1
	xauthdir = xauthfile = NULL;
a721 1

d730 16
a745 37
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (options.forward_x11_trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 120 2>" _PATH_DEVNULL,
				    options.xauth_location, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    options.xauth_location,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
a751 10

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

d763 2
a764 3
		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
d768 1
a768 2
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rand & 0xff);
d971 1
a971 1
client_global_request_reply_fwd(int type, u_int32_t seq, void *ctxt)
d976 3
a978 1
	if (i >= options.num_remote_forwards)
d980 1
@


1.189
log
@Avoid setting optind to 0 as GNU getopt treats that like we do optreset.
markus@@ OK
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.188 2002/11/27 17:53:35 markus Exp $");
d588 4
@


1.188
log
@allow usernames with embedded '@@', e.g. scp user@@vhost@@realhost:file /tmp;
http://bugzilla.mindrot.org/show_bug.cgi?id=447; ok mouring@@, millert@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.187 2002/11/21 23:04:33 markus Exp $");
d495 2
a496 4
		ac--, av++;
		if (ac > 0) {
			optind = 0;
			optreset = 1;
d499 1
@


1.187
log
@debug->debug2
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.186 2002/09/19 01:58:18 djm Exp $");
d485 1
a485 1
		if (strchr(*av, '@@')) {
d487 1
a487 1
			cp = strchr(p, '@@');
@


1.186
log
@bugzilla.mindrot.org #223 - ProxyCommands don't exit.
Patch from dtucker@@zip.com.au; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.185 2002/09/11 18:27:26 stevesk Exp $");
d1005 1
a1005 1
	debug("ssh_session2_setup: id %d", id);
@


1.186.2.1
log
@Update to OpenSSH 3.6
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.190 2003/02/06 09:27:29 markus Exp $");
d485 1
a485 1
		if (strrchr(*av, '@@')) {
d487 1
a487 1
			cp = strrchr(p, '@@');
d495 4
a498 2
		if (ac > 1) {
			optind = optreset = 1;
a500 1
		ac--, av++;
a589 4
	if (options.proxy_command != NULL &&
	    strcmp(options.proxy_command, "none") == 0)
		options.proxy_command = NULL;

d1005 1
a1005 1
	debug2("ssh_session2_setup: id %d", id);
@


1.186.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.201 2003/09/01 18:15:50 markus Exp $");
d78 4
d157 3
d243 1
a243 1
		logit("You don't exist, go away!");
d274 1
a274 1
			options.address_family = AF_INET;
d277 1
a277 1
			options.address_family = AF_INET6;
d304 1
d306 2
a307 1
			/* ignored for backward compatibility */
d309 1
d336 1
a336 1
			if (debug_flag == 0) {
d339 2
a340 3
			} else {
				if (options.log_level < SYSLOG_LEVEL_DEBUG3)
					options.log_level++;
d342 2
a343 1
			}
d347 1
a347 1
			    "%s, SSH protocols %d.%d/%d.%d, %s\n",
d351 1
a351 1
			    SSLeay_version(SSLEAY_VERSION));
d448 1
a448 1
			add_local_forward(&options, fwd_port, "socks", 0);
d508 1
d549 1
a549 1
			logit("Pseudo-terminal will not be allocated because stdin is not a terminal.");
a579 2
	channel_set_af(options.address_family);

a588 7
	/* force lowercase for hostkey matching */
	if (options.host_key_alias != NULL) {
		for (p = options.host_key_alias; *p; p++)
			if (isupper(*p))
				*p = tolower(*p);
	}

d593 6
d600 3
a602 2
	if (ssh_connect(host, &hostaddr, options.port, 
	    options.address_family, options.connection_attempts,
d772 1
a772 1
		logit("Warning: No xauth data; using fake authentication data for X11 forwarding.");
d852 1
a852 1
			logit("Warning: Remote host refused compression.");
d891 1
a891 1
			logit("Warning: Remote host failed or refused to allocate a pseudo tty.");
d909 1
a909 1
			logit("Warning: Remote host denied X11 forwarding.");
d928 1
a928 1
			logit("Warning: Remote host denied authentication agent forwarding.");
d996 1
a996 1
		logit("Warning: remote port forwarding failed for listen port %d",
d1111 1
a1111 1
	    "client-session", /*nonblock*/0);
d1163 1
a1163 1
			options.identity_files[0] = sc_get_key_label(keys[i]);
@


1.185
log
@don't connect to agent to test for presence if we've previously
connected; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.184 2002/08/29 19:49:42 stevesk Exp $");
d141 3
d704 8
@


1.184
log
@shrink initial privilege bracket for setuid case; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.183 2002/08/29 16:02:54 stevesk Exp $");
d808 1
a808 2
		int authfd = ssh_get_authentication_socket();
		if (authfd < 0)
a809 2
		else
			ssh_close_authentication_socket(authfd);
@


1.183
log
@deprecate -P as UsePrivilegedPort defaults to no now; ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.182 2002/07/19 17:42:40 stevesk Exp $");
d221 9
a244 9

	/*
	 * Use uid-swapping to give up root privileges for the duration of
	 * option processing.  We will re-instantiate the rights when we are
	 * ready to create the privileged port, and will permanently drop
	 * them when the port has been created (actually, when the connection
	 * has been made, as we may need to create the port several times).
	 */
	PRIV_END;
@


1.182
log
@display a warning from ssh when XAuthLocation does not exist or xauth
returned no authentication data. ok markus@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.181 2002/07/03 14:21:05 markus Exp $");
a168 1
	fprintf(stderr, "  -P          Don't allocate a privileged port.\n");
d292 1
a292 1
		case 'P':
@


1.181
log
@re-enable ssh-keysign's sbit, but make ssh-keysign read /etc/ssh/ssh_config
and exit if HostbasedAuthentication is disabled globally. based on discussions
with deraadt, itojun and sommerfeld; ok itojun@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.180 2002/06/30 21:59:45 deraadt Exp $");
d713 1
d718 8
a725 1
	if (options.xauth_location && (display = getenv("DISPLAY"))) {
d740 1
a740 1
		debug2("x11_get_proto %s", line);
d759 1
@


1.180
log
@minor KNF
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.179 2002/06/12 01:09:52 markus Exp $");
d628 2
a629 1
		if (sensitive_data.keys[0] == NULL &&
@


1.179
log
@ssh_connect returns 0 on success
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.178 2002/06/11 23:03:54 markus Exp $");
d542 1
a542 1
	/* Force no tty*/
d616 2
a617 1
		sensitive_data.keys = xmalloc(sensitive_data.nkeys*sizeof(Key));
@


1.178
log
@remove unused cruft.
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.177 2002/06/11 04:14:26 markus Exp $");
d599 1
a599 1
	    options.proxy_command) < 0)
@


1.177
log
@no longer use uidswap.[ch] from the ssh client
run less code with euid==0 if ssh is installed setuid root
just switch the euid, don't switch the complete set of groups
(this is only needed by sshd). ok provos@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.176 2002/06/08 05:17:01 markus Exp $");
d205 1
a205 1
	int i, opt, exit_status, cerr;
d596 1
a596 1
	cerr = ssh_connect(host, &hostaddr, options.port, IPv4or6,
d599 2
a600 1
	    options.proxy_command);
d613 2
a614 2
	if (!cerr && (options.rhosts_rsa_authentication ||
	    options.hostbased_authentication)) {
a654 3

	if (cerr)
		exit(1);
@


1.176
log
@deprecate FallBackToRsh and UseRsh; patch from djm@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.175 2002/06/08 05:07:56 markus Exp $");
a55 1
#include "uidswap.h"
d130 1
a211 1
	uid_t original_effective_uid;
d245 1
a245 1
	temporarily_use_uid(pw);
a593 3
	/* Restore our superuser privileges. */
	restore_uid();

d598 2
a599 2
	    original_effective_uid != 0 || !options.use_privileged_port,
	    pw, options.proxy_command);
d616 2
d624 1
d643 2
a644 1
	permanently_set_uid(pw);
@


1.175
log
@nuke ptrace comment
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.174 2002/05/23 19:39:34 markus Exp $");
a194 38
/*
 * Connects to the given host using rsh (or prints an error message and exits
 * if rsh is not available).  This function never returns.
 */
static void
rsh_connect(char *host, char *user, Buffer * command)
{
	char *args[10];
	int i;

	log("Using rsh.  WARNING: Connection will not be encrypted.");
	/* Build argument list for rsh. */
	i = 0;
	args[i++] = _PATH_RSH;
	/* host may have to come after user on some systems */
	args[i++] = host;
	if (user) {
		args[i++] = "-l";
		args[i++] = user;
	}
	if (buffer_len(command) > 0) {
		buffer_append(command, "\0", 1);
		args[i++] = buffer_ptr(command);
	}
	args[i++] = NULL;
	if (debug_flag) {
		for (i = 0; args[i]; i++) {
			if (i != 0)
				fprintf(stderr, " ");
			fprintf(stderr, "%s", args[i]);
		}
		fprintf(stderr, "\n");
	}
	execv(_PATH_RSH, args);
	perror(_PATH_RSH);
	exit(1);
}

a594 18
	/*
	 * If using rsh has been selected, exec it now (without trying
	 * anything else).  Note that we must release privileges first.
	 */
	if (options.use_rsh) {
		/*
		 * Restore our superuser privileges.  This must be done
		 * before permanently setting the uid.
		 */
		restore_uid();

		/* Switch to the original uid permanently. */
		permanently_set_uid(pw);

		/* Execute rsh. */
		rsh_connect(host, options.user, &command);
		fatal("rsh_connect returned");
	}
d655 2
a656 11
	/* Check if the connection failed, and try "rsh" if appropriate. */
	if (cerr) {
		if (!options.fallback_to_rsh)
			exit(1);
		if (options.port != 0)
			log("Secure connection to %.100s on port %hu refused; "
			    "reverting to insecure method",
			    host, options.port);
		else
			log("Secure connection to %.100s refused; "
			    "reverting to insecure method.", host);
a657 3
		rsh_connect(host, options.user, &command);
		fatal("rsh_connect returned");
	}
@


1.174
log
@add comment about ssh-keysign
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.173 2002/05/23 19:24:30 markus Exp $");
a698 8
	 */

	/*
	 * Note that some legacy systems need to postpone the following call
	 * to permanently_set_uid() until the private hostkey is destroyed
	 * with RSA_free().  Otherwise the calling user could ptrace() the
	 * process, read the private hostkey and impersonate the host.
	 * OpenBSD does not allow ptracing of setuid processes.
@


1.173
log
@add /usr/libexec/ssh-keysign: a setuid helper program for hostbased authentication
in protocol v2 (needs to access the hostkeys).
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.172 2002/05/22 23:18:25 deraadt Exp $");
d666 2
@


1.172
log
@spelling; abishoff@@arc.nasa.gov
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.171 2002/05/16 22:09:59 stevesk Exp $");
d127 1
a127 4
struct {
	Key     **keys;
	int	nkeys;
} sensitive_data;
d669 1
d680 10
d749 1
a749 2
	ssh_login(sensitive_data.keys, sensitive_data.nkeys,
	    host, (struct sockaddr *)&hostaddr, pw);
@


1.171
log
@don't limit xauth pathlen on client side and longer print length on
server when debug; ok markus@@
patch from pin@@math.chalmers.se
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.170 2002/04/22 21:04:52 markus Exp $");
d102 1
a102 1
 * so that the pasphrase can be entered manually, and then ssh goes to the
d1107 1
a1107 1
			/* XXX we asume that client_loop has already been called */
@


1.170
log
@request reply (success/failure) for -R style fwd in protocol v2,
depends on ordered replies.
fixes http://bugzilla.mindrot.org/show_bug.cgi?id=215; ok provos@@
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.169 2002/03/26 11:37:05 markus Exp $");
d794 1
a794 1
			snprintf(line, sizeof line, "%.100s list unix:%s 2>"
d797 1
a797 1
			snprintf(line, sizeof line, "%.100s list %.200s 2>"
@


1.169
log
@update Copyright
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.168 2002/03/25 21:04:02 markus Exp $");
d141 3
d1025 21
@


1.169.2.1
log
@Update to OpenSSH-3.2.2
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.170 2002/04/22 21:04:52 markus Exp $");
a140 3
/* # of replies received for global requests */
static int client_global_request_id = 0;

a1021 21
}

void
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
{
	int i;

	i = client_global_request_id++;
	if (i >= options.num_remote_forwards) {
		debug("client_global_request_reply: too many replies %d > %d",
		    i, options.num_remote_forwards);
		return;
	}
	debug("remote forward %s for: listen %d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    options.remote_forwards[i].port,
	    options.remote_forwards[i].host,
	    options.remote_forwards[i].host_port);
	if (type == SSH2_MSG_REQUEST_FAILURE)
		log("Warning: remote port forwarding failed for listen port %d",
		    options.remote_forwards[i].port);
@


1.169.2.2
log
@Update to OpenSSH-3.2.3
@
text
@@


1.169.2.3
log
@Pull in OpenSSH-3.4
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.179 2002/06/12 01:09:52 markus Exp $");
d56 1
d102 1
a102 1
 * so that the passphrase can be entered manually, and then ssh goes to the
d127 4
a130 1
Sensitive sensitive_data;
a133 1
uid_t original_effective_uid;
d198 38
d246 1
a246 1
	int i, opt, exit_status;
d253 1
d287 1
a287 1
	PRIV_END;
d636 21
d659 1
a659 1
	if (ssh_connect(host, &hostaddr, options.port, IPv4or6,
d661 2
a662 3
	    original_effective_uid == 0 && options.use_privileged_port,
	    options.proxy_command) != 0)
		exit(1);
a668 2
	 * If we cannot access the private keys, load the public keys
	 * instead and try to execute the ssh-keysign helper instead.
d672 2
a673 3
	sensitive_data.external_keysign = 0;
	if (options.rhosts_rsa_authentication ||
	    options.hostbased_authentication) {
a675 2

		PRIV_START;
a681 11
		PRIV_END;

		if (sensitive_data.keys[0] == NULL &&
		    sensitive_data.keys[1] == NULL &&
		    sensitive_data.keys[2] == NULL) {
			sensitive_data.keys[1] = key_load_public(
			    _PATH_HOST_DSA_KEY_FILE, NULL);
			sensitive_data.keys[2] = key_load_public(
			    _PATH_HOST_RSA_KEY_FILE, NULL);
			sensitive_data.external_keysign = 1;
		}
d690 9
a698 2
	seteuid(original_real_uid);
	setuid(original_real_uid);
d709 15
d741 2
a742 1
	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr, pw);
d794 1
a794 1
			snprintf(line, sizeof line, "%s list unix:%s 2>"
d797 1
a797 1
			snprintf(line, sizeof line, "%s list %.200s 2>"
d1107 1
a1107 1
			/* XXX we assume that client_loop has already been called */
@


1.169.2.4
log
@Update to OpenSSH 3.5
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.186 2002/09/19 01:58:18 djm Exp $");
a140 3
/* pid of proxycommand child process */
pid_t proxy_command_pid = 0;

d169 1
a221 9
	/*
	 * Use uid-swapping to give up root privileges for the duration of
	 * option processing.  We will re-instantiate the rights when we are
	 * ready to create the privileged port, and will permanently drop
	 * them when the port has been created (actually, when the connection
	 * has been made, as we may need to create the port several times).
	 */
	PRIV_END;

d239 9
d293 1
a293 1
		case 'P':	/* deprecated */
d542 1
a542 1
	/* Force no tty */
d616 1
a616 2
		sensitive_data.keys = xmalloc(sensitive_data.nkeys *
		    sizeof(Key));
d627 1
a627 2
		if (options.hostbased_authentication == 1 &&
		    sensitive_data.keys[0] == NULL &&
a699 8

	/*
	 * Send SIGHUP to proxy command if used. We don't wait() in 
	 * case it hangs and instead rely on init to reap the child
	 */
	if (proxy_command_pid > 1)
		kill(proxy_command_pid, SIGHUP);

a710 1
	struct stat st;
d715 1
a715 8
	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if ((display = getenv("DISPLAY")) == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
d730 1
a730 1
		debug2("x11_get_proto: %s", line);
a748 1
		log("Warning: No xauth data; using fake authentication data for X11 forwarding.");
d798 2
a799 1
		if (!ssh_agent_present())
d801 2
@


1.169.2.5
log
@Merge OpenSSH 3.6.1
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.190 2003/02/06 09:27:29 markus Exp $");
d485 1
a485 1
		if (strrchr(*av, '@@')) {
d487 1
a487 1
			cp = strrchr(p, '@@');
d495 4
a498 2
		if (ac > 1) {
			optind = optreset = 1;
a500 1
		ac--, av++;
a589 4
	if (options.proxy_command != NULL &&
	    strcmp(options.proxy_command, "none") == 0)
		options.proxy_command = NULL;

d1005 1
a1005 1
	debug2("ssh_session2_setup: id %d", id);
@


1.168
log
@simplify num_identity_files handling
@
text
@d16 1
d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.167 2002/03/25 17:34:27 markus Exp $");
@


1.167
log
@change sc_get_key to sc_get_keys and hide smartcard details in scard.c
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.166 2002/03/21 22:44:05 rees Exp $");
a1179 2
			if (options.num_identity_files + 1 > SSH_MAX_IDENTITY_FILES)
				options.num_identity_files = SSH_MAX_IDENTITY_FILES - 1;
d1188 2
@


1.166
log
@Add PIN-protection for secret key.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.165 2002/03/19 10:49:35 markus Exp $");
a72 1
#include <openssl/engine.h>
d1169 1
d1171 2
a1172 1
	int i = 0;
a1173 1
#ifdef SMARTCARD
d1175 17
a1191 29
	    options.num_identity_files + 1 < SSH_MAX_IDENTITY_FILES &&
	    (public = sc_get_key(options.smartcard_device, NULL)) != NULL ) {
		Key *new;

		if (options.num_identity_files + 2 > SSH_MAX_IDENTITY_FILES)
			options.num_identity_files = SSH_MAX_IDENTITY_FILES - 2;
		memmove(&options.identity_files[2], &options.identity_files[0],
		    sizeof(char *) * options.num_identity_files);
		options.num_identity_files += 2;
		i = 2;

		/* XXX ssh1 vs ssh2 */
		new = key_new(KEY_RSA);
		new->flags = KEY_FLAG_EXT;
		BN_copy(new->rsa->n, public->rsa->n);
		BN_copy(new->rsa->e, public->rsa->e);
		RSA_set_method(new->rsa, sc_get_engine());
		options.identity_keys[0] = new;
		options.identity_files[0] = xstrdup("smartcard rsa key");;

		new = key_new(KEY_RSA1);
		new->flags = KEY_FLAG_EXT;
		BN_copy(new->rsa->n, public->rsa->n);
		BN_copy(new->rsa->e, public->rsa->e);
		RSA_set_method(new->rsa, sc_get_engine());
		options.identity_keys[1] = new;
		options.identity_files[1] = xstrdup("smartcard rsa1 key");

		key_free(public);
@


1.165
log
@KNF whitespace
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.164 2002/02/14 23:28:00 markus Exp $");
d1176 1
a1176 1
	    (public = sc_get_key(options.smartcard_device)) != NULL ) {
@


1.164
log
@increase the SSH v2 window size to 4 packets. comsumes a little
bit more memory for slow receivers but increases througput.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.163 2002/02/07 09:35:39 markus Exp $");
d465 1
a465 1
	  		    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
@


1.163
log
@remove bogus comments
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.162 2002/02/06 14:55:16 markus Exp $");
d1128 3
a1130 3
	if (!tty_flag) {
		window *= 2;
		packetmax *=2;
@


1.162
log
@channel_new never returns NULL, mouring@@; ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.161 2002/02/05 14:32:55 markus Exp $");
a1095 1
	/* channel_callback(id, SSH2_MSG_OPEN_CONFIGMATION, client_init, 0); */
a1096 1
	/* register different callback, etc. XXX */
@


1.161
log
@merge channel_request() into channel_request_start()
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.160 2002/02/03 17:58:21 markus Exp $");
a1137 2
	if (c == NULL)
		fatal("ssh_session2_open: channel_new failed");
@


1.160
log
@generic callbacks are not really used, remove and
add a callback for msg of type SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.159 2002/01/27 18:08:17 stevesk Exp $");
d1093 2
a1094 1
		channel_request(id, "shell", 0);
@


1.159
log
@handle simple case to identify FamilyLocal display; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.158 2002/01/16 13:17:51 markus Exp $");
d1144 1
a1144 3
		channel_register_callback(c->self,
		    SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
		    ssh_session2_setup, (void *)0);
@


1.158
log
@wrapper for channel_setup_fwd_listener
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.157 2001/12/28 15:06:00 markus Exp $");
d776 1
d781 1
a781 1
	if (options.xauth_location) {
d783 14
a796 2
		snprintf(line, sizeof line, "%.100s list %.200s 2>" _PATH_DEVNULL,
		    options.xauth_location, getenv("DISPLAY"));
@


1.157
log
@remove plen from the dispatch fn. it's no longer used.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.156 2001/12/28 14:50:54 markus Exp $");
d824 1
a824 1
		success += channel_request_local_forwarding(
@


1.156
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.155 2001/12/28 12:14:27 markus Exp $");
d997 1
a997 1
client_subsystem_reply(int type, int plen, u_int32_t seq, void *ctxt)
@


1.155
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.154 2001/12/27 20:39:58 markus Exp $");
a862 1
	int plen;
d880 1
a880 1
		type = packet_read(&plen);
d918 1
a918 1
		type = packet_read(&plen);
d937 1
a937 1
		type = packet_read(&plen);
d957 1
a957 1
		type = packet_read(&plen);
@


1.154
log
@get rid of packet_integrity_check, use packet_done() instead.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.153 2001/12/20 22:50:24 djm Exp $");
d959 1
a959 1
		packet_done();
d1006 1
a1006 1
	packet_done();
@


1.153
log
@Conformance fix: we should send failing packet sequence number when
responding with a SSH_MSG_UNIMPLEMENTED message. Spotted by
yakk@@yakk.dot.net; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.152 2001/12/19 17:16:13 stevesk Exp $");
d959 1
a959 1
		packet_integrity_check(plen, 0, type);
@


1.152
log
@change the buffer/packet interface to use void* vs. char*; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.151 2001/12/19 07:18:56 deraadt Exp $");
d998 1
a998 1
client_subsystem_reply(int type, int plen, void *ctxt)
@


1.151
log
@basic KNF done while i was looking for something else
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.150 2001/11/30 20:39:28 stevesk Exp $");
d980 1
a980 1
		debug("Sending command: %.*s", len, buffer_ptr(&command));
d1009 1
a1009 1
		    len, buffer_ptr(&command), id);
d1068 1
a1068 1
			debug("Sending subsystem: %.*s", len, buffer_ptr(&command));
d1075 1
a1075 1
			debug("Sending command: %.*s", len, buffer_ptr(&command));
@


1.150
log
@sscanf() length dependencies are clearer now; can also shrink proto
and data if desired, but i have not done that.  ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.149 2001/10/24 08:51:35 markus Exp $");
d475 1
a475 1
				     fwd_host_port);
d1133 2
a1134 2
		     SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
		     ssh_session2_setup, (void *)0);
@


1.149
log
@ignore SIGPIPE early, makes ssh work if agent dies, netbsd-pr via itojun@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.148 2001/10/24 08:41:20 markus Exp $");
d770 1
a770 1
x11_get_proto(char *proto, int proto_len, char *data, int data_len)
d773 1
d777 3
d786 1
a786 1
		    sscanf(line, "%*s %s %s", proto, data) == 2)
d802 1
a802 1
		strlcpy(proto, "MIT-MAGIC-COOKIE-1", proto_len);
d806 1
a806 1
			snprintf(data + 2 * i, data_len - 2 * i, "%02x", rand & 0xff);
d930 1
a930 1
		char proto[512], data[512];
d932 1
a932 1
		x11_get_proto(proto, sizeof proto, data, sizeof data);
d1046 1
a1046 1
		char proto[512], data[512];
d1048 1
a1048 1
		x11_get_proto(proto, sizeof proto, data, sizeof data);
@


1.148
log
@remove unused
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.147 2001/10/08 19:05:05 markus Exp $");
d734 2
@


1.147
log
@some more IPv4or6 cleanup
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.146 2001/10/01 21:38:53 markus Exp $");
a124 8

/*
 * Flag to indicate that we have received a window change signal which has
 * not yet been processed.  This will cause a message indicating the new
 * window size to be sent to the server a little later.  This is volatile
 * because this is updated in a signal handler.
 */
volatile int received_window_change_signal = 0;
@


1.147.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.149 2001/10/24 08:51:35 markus Exp $");
d126 8
a741 2

	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */
@


1.147.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.164 2002/02/14 23:28:00 markus Exp $");
d475 1
a475 1
				    fwd_host_port);
d770 1
a770 1
x11_get_proto(char **_proto, char **_data)
a772 1
	static char proto[512], data[512];
a774 1
	char *display;
d776 1
a776 4
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';
	if (options.xauth_location && (display = getenv("DISPLAY"))) {
d778 2
a779 14
		if (strncmp(display, "localhost:", 10) == 0)
			/*
			 * Handle FamilyLocal case where $DISPLAY does
			 * not match an authorization entry.  For this we
			 * just try "xauth list unix:displaynum.screennum".
			 * XXX: "localhost" match to determine FamilyLocal
			 *      is not perfect.
			 */
			snprintf(line, sizeof line, "%.100s list unix:%s 2>"
			    _PATH_DEVNULL, options.xauth_location, display+10);
		else
			snprintf(line, sizeof line, "%.100s list %.200s 2>"
			    _PATH_DEVNULL, options.xauth_location, display);
		debug2("x11_get_proto %s", line);
d782 1
a782 1
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
d798 1
a798 1
		strlcpy(proto, "MIT-MAGIC-COOKIE-1", sizeof proto);
d802 1
a802 1
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x", rand & 0xff);
d820 1
a820 1
		success += channel_setup_local_fwd_listener(
d859 1
d877 1
a877 1
		type = packet_read();
d915 1
a915 1
		type = packet_read();
d926 1
a926 1
		char *proto, *data;
d928 1
a928 1
		x11_get_proto(&proto, &data);
d934 1
a934 1
		type = packet_read();
d954 2
a955 2
		type = packet_read();
		packet_check_eom();
d976 1
a976 1
		debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
d994 1
a994 1
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d1002 1
a1002 1
	packet_check_eom();
d1005 1
a1005 1
		    len, (u_char *)buffer_ptr(&command), id);
d1042 1
a1042 1
		char *proto, *data;
d1044 1
a1044 1
		x11_get_proto(&proto, &data);
d1064 1
a1064 1
			debug("Sending subsystem: %.*s", len, (u_char *)buffer_ptr(&command));
d1071 1
a1071 1
			debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
d1077 1
a1077 2
		channel_request_start(id, "shell", 0);
		packet_send();
d1079 1
d1081 1
d1113 3
a1115 3
	if (tty_flag) {
		window >>= 1;
		packetmax >>= 1;
d1121 2
d1128 3
a1130 1
		channel_register_confirm(c->self, ssh_session2_setup);
@


1.147.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@a15 1
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.170 2002/04/22 21:04:52 markus Exp $");
d73 1
a140 3
/* # of replies received for global requests */
static int client_global_request_id = 0;

d465 1
a465 1
			    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
a1023 21
void
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
{
	int i;

	i = client_global_request_id++;
	if (i >= options.num_remote_forwards) {
		debug("client_global_request_reply: too many replies %d > %d",
		    i, options.num_remote_forwards);
		return;
	}
	debug("remote forward %s for: listen %d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    options.remote_forwards[i].port,
	    options.remote_forwards[i].host,
	    options.remote_forwards[i].host_port);
	if (type == SSH2_MSG_REQUEST_FAILURE)
		log("Warning: remote port forwarding failed for listen port %d",
		    options.remote_forwards[i].port);
}

d1170 1
d1172 1
a1172 1
	Key *public;
d1174 28
a1201 1
	Key **keys;
d1203 1
a1203 18
	if (options.smartcard_device != NULL &&
	    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL ) {
		int count = 0;
		for (i = 0; keys[i] != NULL; i++) {
			count++;
			memmove(&options.identity_files[1], &options.identity_files[0],
			    sizeof(char *) * (SSH_MAX_IDENTITY_FILES - 1));
			memmove(&options.identity_keys[1], &options.identity_keys[0],
			    sizeof(Key *) * (SSH_MAX_IDENTITY_FILES - 1));
			options.num_identity_files++;
			options.identity_keys[0] = keys[i];
			options.identity_files[0] = xstrdup("smartcard key");;
		}
		if (options.num_identity_files > SSH_MAX_IDENTITY_FILES)
			options.num_identity_files = SSH_MAX_IDENTITY_FILES;
		i = count;
		xfree(keys);
@


1.147.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.147.2.3 2002/05/17 00:03:24 miod Exp $");
d56 1
d102 1
a102 1
 * so that the passphrase can be entered manually, and then ssh goes to the
d127 4
a130 1
Sensitive sensitive_data;
a133 1
uid_t original_effective_uid;
d198 38
d246 1
a246 1
	int i, opt, exit_status;
d253 1
d287 1
a287 1
	PRIV_END;
d636 21
d659 1
a659 1
	if (ssh_connect(host, &hostaddr, options.port, IPv4or6,
d661 2
a662 3
	    original_effective_uid == 0 && options.use_privileged_port,
	    options.proxy_command) != 0)
		exit(1);
a668 2
	 * If we cannot access the private keys, load the public keys
	 * instead and try to execute the ssh-keysign helper instead.
d672 2
a673 3
	sensitive_data.external_keysign = 0;
	if (options.rhosts_rsa_authentication ||
	    options.hostbased_authentication) {
a675 2

		PRIV_START;
a681 11
		PRIV_END;

		if (sensitive_data.keys[0] == NULL &&
		    sensitive_data.keys[1] == NULL &&
		    sensitive_data.keys[2] == NULL) {
			sensitive_data.keys[1] = key_load_public(
			    _PATH_HOST_DSA_KEY_FILE, NULL);
			sensitive_data.keys[2] = key_load_public(
			    _PATH_HOST_RSA_KEY_FILE, NULL);
			sensitive_data.external_keysign = 1;
		}
d690 9
a698 2
	seteuid(original_real_uid);
	setuid(original_real_uid);
d709 15
d741 2
a742 1
	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr, pw);
d794 1
a794 1
			snprintf(line, sizeof line, "%s list unix:%s 2>"
d797 1
a797 1
			snprintf(line, sizeof line, "%s list %.200s 2>"
d1107 1
a1107 1
			/* XXX we assume that client_loop has already been called */
@


1.147.2.5
log
@Update to OpenSSH 3.5
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.186 2002/09/19 01:58:18 djm Exp $");
a140 3
/* pid of proxycommand child process */
pid_t proxy_command_pid = 0;

d169 1
a221 9
	/*
	 * Use uid-swapping to give up root privileges for the duration of
	 * option processing.  We will re-instantiate the rights when we are
	 * ready to create the privileged port, and will permanently drop
	 * them when the port has been created (actually, when the connection
	 * has been made, as we may need to create the port several times).
	 */
	PRIV_END;

d239 9
d293 1
a293 1
		case 'P':	/* deprecated */
d542 1
a542 1
	/* Force no tty */
d616 1
a616 2
		sensitive_data.keys = xmalloc(sensitive_data.nkeys *
		    sizeof(Key));
d627 1
a627 2
		if (options.hostbased_authentication == 1 &&
		    sensitive_data.keys[0] == NULL &&
a699 8

	/*
	 * Send SIGHUP to proxy command if used. We don't wait() in 
	 * case it hangs and instead rely on init to reap the child
	 */
	if (proxy_command_pid > 1)
		kill(proxy_command_pid, SIGHUP);

a710 1
	struct stat st;
d715 1
a715 8
	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if ((display = getenv("DISPLAY")) == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
d730 1
a730 1
		debug2("x11_get_proto: %s", line);
a748 1
		log("Warning: No xauth data; using fake authentication data for X11 forwarding.");
d798 2
a799 1
		if (!ssh_agent_present())
d801 2
@


1.146
log
@remove ugliness; vp@@drexel.edu via angelos
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.145 2001/09/28 15:46:29 markus Exp $");
d664 1
a664 1
	cerr = ssh_connect(host, &hostaddr, options.port,
@


1.145
log
@bug: read user config first; report kaukasoi@@elektroni.ee.tut.fi
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.144 2001/09/24 03:38:58 stevesk Exp $");
d554 1
@


1.144
log
@don't rely on <unistd.h> for getopt(3) extern variable declarations;
for portable.  ok deraadt@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.143 2001/09/20 13:50:40 markus Exp $");
d616 1
d618 1
a618 1
		/* Read systemwide configuration file. */
a619 1
		(void)read_config_file(buf, host, &options);
@


1.143
log
@bug compat: request a dummy channel for -N (no shell) sessions + cleanup; vinschen@@redhat.com
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.142 2001/09/03 20:58:33 stevesk Exp $");
d259 2
@


1.142
log
@fatal() for nonexistent -Fssh_config. ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.141 2001/08/29 23:27:23 stevesk Exp $");
d1011 1
d1013 1
a1013 1
ssh_session2_callback(int id, void *arg)
d1019 1
a1019 1
	debug("client_init id %d arg %ld", id, (long)arg);
d1088 1
d1090 1
a1090 1
ssh_session2_command(void)
d1125 1
a1125 1
		fatal("ssh_session2_command: channel_new failed");
d1127 1
a1127 1
	debug3("ssh_session2_command: channel_new: %d", c->self);
d1130 4
a1133 2
	channel_register_callback(c->self, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
	     ssh_session2_callback, (void *)0);
d1141 1
a1141 1
	int id;
d1146 2
a1147 1
	id = no_shell_flag ? -1 : ssh_session2_command();
@


1.141
log
@validate ports for -L/-R; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.140 2001/08/29 23:13:10 stevesk Exp $");
d608 3
a610 1
		read_config_file(config, host, &options);
d616 2
a617 2
		read_config_file(_PATH_HOST_CONFIG_FILE, host, &options);
		read_config_file(buf, host, &options);
@


1.140
log
@document -D and DynamicForward; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.139 2001/08/28 15:39:48 markus Exp $");
d253 1
d457 2
d460 4
a463 4
			if (sscanf(optarg, "%hu/%255[^/]/%hu", &fwd_port, buf,
			    &fwd_host_port) != 3 &&
			    sscanf(optarg, "%hu:%255[^:]:%hu", &fwd_port, buf,
			    &fwd_host_port) != 3) {
d465 1
a465 1
				    "Bad forwarding specification '%s'.\n",
d470 2
a471 8
			add_remote_forward(&options, fwd_port, buf,
			     fwd_host_port);
			break;
		case 'L':
			if (sscanf(optarg, "%hu/%255[^/]/%hu", &fwd_port, buf,
			    &fwd_host_port) != 3 &&
			    sscanf(optarg, "%hu:%255[^:]:%hu", &fwd_port, buf,
			    &fwd_host_port) != 3) {
d473 2
a474 4
				    "Bad forwarding specification '%s'.\n",
				    optarg);
				usage();
				/* NOTREACHED */
d476 6
a481 2
			add_local_forward(&options, fwd_port, buf,
			    fwd_host_port);
@


1.139
log
@allow: ssh -F configfile host
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.138 2001/08/11 22:51:27 jakob Exp $");
d189 1
@


1.138
log
@fix more paths beginning with "//"; <bradshaw@@staff.crosswalk.com>. ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.137 2001/08/02 16:14:05 jakob Exp $");
d113 3
d158 2
d306 1
a306 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:I:L:NPR:TVX")) != -1) {
d516 3
d603 14
a616 6
	/* Read per-user configuration file. */
	snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, _PATH_SSH_USER_CONFFILE);
	read_config_file(buf, host, &options);

	/* Read systemwide configuration file. */
	read_config_file(_PATH_HOST_CONFIG_FILE, host, &options);
@


1.137
log
@clean up some /* SMARTCARD */. ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.136 2001/08/02 15:43:57 jakob Exp $");
d688 1
a688 1
	snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, _PATH_SSH_USER_DIR);
@


1.136
log
@add /* SMARTCARD */ to #else/#endif. ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.135 2001/08/02 15:32:10 jakob Exp $");
d75 1
a75 1
#endif /* SMARTCARD */
d166 1
a166 1
#endif /* SMARTCARD */
d362 1
a362 1
#else /* SMARTCARD */
d364 1
a364 1
#endif /* SMARTCARD */
@


1.135
log
@add smartcard to usage(). ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.134 2001/08/01 23:38:45 markus Exp $");
d75 1
a75 1
#endif
d362 1
a362 1
#else
d364 1
a364 1
#endif
d1174 1
a1174 1
#endif
@


1.134
log
@support finish rsa keys.
free public keys after login -> call finish -> close smartcard.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.133 2001/08/01 22:03:33 markus Exp $");
d164 3
@


1.133
log
@use strings instead of ints for smartcard reader ids
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.132 2001/07/31 09:28:44 jakob Exp $");
d734 10
@


1.132
log
@add 'SmartcardDevice' client option to specify which smartcard device is used
to access a smartcard used for storing the user's private RSA key. ok markus@@.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.131 2001/07/27 14:50:45 millert Exp $");
d358 1
a358 1
			options.smartcard_device = atoi(optarg);
d1130 1
a1130 1
	if (options.smartcard_device >= 0 &&
@


1.131
log
@If smart card support is compiled in and a smart card is being used
for authentication, make it the first method used.  markus@@ OK
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.130 2001/07/25 14:35:18 markus Exp $");
a145 5
#ifdef SMARTCARD
/* Smartcard reader id */
int sc_reader_num = -1;
#endif

d358 1
a358 1
			sc_reader_num = atoi(optarg);
d1130 1
a1130 1
	if (sc_reader_num != -1 &&
d1132 1
a1132 1
	    (public = sc_get_key(sc_reader_num)) != NULL ) {
@


1.130
log
@cleanup connect(); connection_attempts 4 -> 1; from eivind@@freebsd.org
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.129 2001/07/11 16:29:59 markus Exp $");
d1132 1
a1132 1
	int i;
a1133 10
	for (i = 0; i < options.num_identity_files; i++) {
		filename = tilde_expand_filename(options.identity_files[i],
		    original_real_uid);
		public = key_load_public(filename, NULL);
		debug("identity file %s type %d", filename,
		    public ? public->type : -1);
		xfree(options.identity_files[i]);
		options.identity_files[i] = filename;
		options.identity_keys[i] = public;
	}
d1140 7
d1153 2
a1154 3
		i = options.num_identity_files++;
		options.identity_keys[i] = new;
		options.identity_files[i] = xstrdup("smartcard rsa key");;
d1161 2
a1162 3
		i = options.num_identity_files++;
		options.identity_keys[i] = new;
		options.identity_files[i] = xstrdup("smartcard rsa1 key");;
d1167 10
@


1.129
log
@sort options string, fix -p, add -k
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.128 2001/07/09 05:58:47 fgsch Exp $");
d247 1
a247 1
	int i, opt, exit_status, ok;
d645 1
a645 1
	ok = ssh_connect(host, &hostaddr, options.port,
d658 1
a658 1
	if (ok && (options.rhosts_rsa_authentication ||
d696 3
a698 1
	if (!ok) {
d700 3
a702 3
			log("Secure connection to %.100s on port %hu refused%.100s.",
			    host, options.port,
			    options.fallback_to_rsh ? "; reverting to insecure method" : "");
d704 2
a705 2
			log("Secure connection to %.100s refused%.100s.", host,
			    options.fallback_to_rsh ? "; reverting to insecure method" : "");
d707 2
a708 5
		if (options.fallback_to_rsh) {
			rsh_connect(host, options.user, &command);
			fatal("rsh_connect returned");
		}
		exit(1);
@


1.128
log
@Use getopt(3); markus@@ ok.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.127 2001/06/26 20:14:11 markus Exp $");
d303 1
a303 1
	    "1246nfxXgpaAki:I:tvVqe:c:m:p:l:R:L:D:CNTo:sb:")) != -1) {
@


1.127
log
@add smartcard support to the client, too (now you can use both
the agent and the client).
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.126 2001/06/23 15:12:21 itojun Exp $");
d247 1
a247 1
	int i, opt, optind, exit_status, ok;
d249 1
a249 1
	char *optarg, *p, *cp, buf[256];
d301 3
a303 31
	for (optind = 1; optind < ac; optind++) {
		if (av[optind][0] != '-') {
			if (host)
				break;
			if (strchr(av[optind], '@@')) {
				p = xstrdup(av[optind]);
				cp = strchr(p, '@@');
				if(cp == NULL || cp == p)
					usage();
				options.user = p;
				*cp = '\0';
				host = ++cp;
			} else
				host = av[optind];
			continue;
		}
		opt = av[optind][1];
		if (!opt)
			usage();
		if (strchr("eilcmpbILRDo", opt)) {   /* options with arguments */
			optarg = av[optind] + 2;
			if (strcmp(optarg, "") == 0) {
				if (optind >= ac - 1)
					usage();
				optarg = av[++optind];
			}
		} else {
			if (av[optind][2])
				usage();
			optarg = NULL;
		}
d350 2
a351 2
				fprintf(stderr, "Warning: Identity file %s does not exist.\n",
				    optarg);
d354 6
a359 4
			if (options.num_identity_files >= SSH_MAX_IDENTITY_FILES)
				fatal("Too many identity files specified (max %d)",
				    SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] = xstrdup(optarg);
d380 1
a380 1
			} else {
a381 1
			}
d398 2
a399 1
			    (u_char) optarg[1] >= 64 && (u_char) optarg[1] < 128)
d406 2
a407 1
				fprintf(stderr, "Bad escape character '%s'.\n", optarg);
d420 3
a422 1
					fprintf(stderr, "Unknown cipher type '%s'\n", optarg);
d425 1
a425 1
				if (options.cipher == SSH_CIPHER_3DES) {
d427 1
a427 1
				} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
d429 1
a429 1
				} else {
a430 1
				}
d437 2
a438 1
				fprintf(stderr, "Unknown mac type '%s'\n", optarg);
d457 3
a459 1
				fprintf(stderr, "Bad forwarding specification '%s'.\n", optarg);
d463 2
a464 1
			add_remote_forward(&options, fwd_port, buf, fwd_host_port);
d471 3
a473 1
				fprintf(stderr, "Bad forwarding specification '%s'.\n", optarg);
d477 2
a478 1
			add_local_forward(&options, fwd_port, buf, fwd_host_port);
d484 2
a485 1
				fprintf(stderr, "Bad dynamic port '%s'\n", optarg);
d503 2
a504 2
			if (process_config_line(&options, host ? host : "", optarg,
					 "command-line", 0, &dummy) != 0)
d518 22
d555 1
a555 1
	if (optind == ac) {
d559 2
a560 1
			fprintf(stderr, "You must specify a subsystem to invoke.\n");
d564 3
a566 4
		/* A command has been specified.  Store it into the
		   buffer. */
		for (i = optind; i < ac; i++) {
			if (i > optind)
@


1.126
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.125 2001/06/22 23:35:21 markus Exp $");
d72 5
d146 5
d320 1
a320 1
		if (strchr("eilcmpbLRDo", opt)) {   /* options with arguments */
d387 7
d1139 28
@


1.125
log
@don't overwrite argv (fixes ssh user@@host in 'ps'), report by ericj@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.124 2001/06/07 20:23:05 markus Exp $");
d143 1
a143 1
void
d193 1
a193 1
void
d227 3
a229 3
int	ssh_session(void);
int	ssh_session2(void);
void	load_public_identity_files(void);
d724 1
a724 1
void
d763 1
a763 1
void
d797 1
a797 1
void
d810 1
a810 1
int
d948 1
a948 1
void
d963 1
a963 1
void
d1039 1
a1039 1
int
d1086 1
a1086 1
int
d1105 1
a1105 1
void
@


1.124
log
@use xxx_put_cstring()
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.123 2001/05/31 10:30:17 markus Exp $");
d239 1
a239 1
	char *optarg, *cp, buf[256];
d295 4
a298 2
			if ((cp = strchr(av[optind], '@@'))) {
				if(cp == av[optind])
d300 1
a300 1
				options.user = av[optind];
@


1.123
log
@undo the .c file split, just merge the header and keep the cvs history
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.122 2001/05/30 15:20:10 markus Exp $");
d850 1
a850 1
		packet_put_string(cp, strlen(cp));
@


1.122
log
@merge functions, simplify.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.121 2001/05/30 12:55:13 markus Exp $");
d56 1
a56 1
#include "channel.h"
@


1.121
log
@channel layer cleanup: merge header files and split .c files
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.120 2001/05/28 08:04:39 markus Exp $");
d1077 1
a1077 1
	channel_open(c->self);
@


1.120
log
@fix usage()
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.119 2001/05/24 18:57:53 stevesk Exp $");
d56 1
a56 1
#include "channels.h"
@


1.119
log
@don't perform escape processing when ``EscapeChar none''; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.118 2001/05/04 23:47:34 markus Exp $");
d151 1
a151 1
	fprintf(stderr, "  -a          Disable authentication agent forwarding.\n");
d156 1
a156 1
	fprintf(stderr, "  -x          Disable X11 connection forwarding.\n");
d169 1
a169 2
	fprintf(stderr, "  -c cipher   Select encryption algorithm: "
	    "``3des'', ``blowfish''\n");
d185 1
a185 1
	fprintf(stderr, "  -b          Local IP address.\n");
@


1.118
log
@move to Channel **channels (instead of Channel *channels), fixes realloc problems.
channel_new now returns a Channel *, favour Channel * over channel id.
remove old channel_allocate interface.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.117 2001/04/30 11:18:52 markus Exp $");
d412 1
a412 1
				options.escape_char = -2;
d943 2
a944 1
	return client_loop(have_tty, tty_flag ? options.escape_char : -1, 0);
d1100 2
a1101 1
	return client_loop(tty_flag, tty_flag ? options.escape_char : -1, id);
@


1.117
log
@implement 'ssh -b bind_address' like 'telnet -b'
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.116 2001/04/17 12:55:04 markus Exp $");
d1040 2
a1041 2
	int id, window, packetmax;
	int in, out, err;
d1068 1
a1068 1
	id = channel_new(
d1072 2
d1075 1
a1075 1
debug("channel_new: %d", id);
d1077 2
a1078 2
	channel_open(id);
	channel_register_callback(id, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
d1081 1
a1081 1
	return id;
@


1.116
log
@undo socks5 and https support since they are not really used and
only bloat ssh.  remove -D from usage(), since '-D' is experimental.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.115 2001/04/14 16:33:20 stevesk Exp $");
d186 1
d309 1
a309 1
		if (strchr("eilcmpLRDo", opt)) {   /* options with arguments */
d507 3
@


1.116.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.144 2001/09/24 03:38:58 stevesk Exp $");
a71 5
#ifdef SMARTCARD
#include <openssl/engine.h>
#include "scard.h"
#endif

a107 3
/* optional user configfile */
char *config = NULL;

d143 1
a143 1
static void
a149 2
	fprintf(stderr, "  -F config   Config file (default: ~/%s).\n",
	     _PATH_SSH_USER_CONFFILE);
d151 1
a151 1
	fprintf(stderr, "  -a          Disable authentication agent forwarding (default).\n");
d156 1
a156 1
	fprintf(stderr, "  -x          Disable X11 connection forwarding (default).\n");
a158 3
#ifdef SMARTCARD
	fprintf(stderr, "  -I reader   Set smartcard reader.\n");
#endif
d169 2
a170 1
	fprintf(stderr, "  -c cipher   Select encryption algorithm\n");
a176 1
	fprintf(stderr, "  -D port     Enable dynamic application-level port forwarding.\n");
a185 1
	fprintf(stderr, "  -b addr     Local IP address.\n");
d193 1
a193 1
static void
d227 3
a229 3
static int ssh_session(void);
static int ssh_session2(void);
static void load_public_identity_files(void);
d237 1
a237 1
	int i, opt, exit_status, cerr;
d239 1
a239 2
	char sfwd_port[6], sfwd_host_port[6];
	char *p, *cp, buf[256];
a243 2
	extern int optind, optreset;
	extern char *optarg;
d291 29
a319 3
again:
	while ((opt = getopt(ac, av,
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVX")) != -1) {
d366 2
a367 2
				fprintf(stderr, "Warning: Identity file %s "
				    "does not exist.\n", optarg);
d370 4
a373 13
			if (options.num_identity_files >=
			    SSH_MAX_IDENTITY_FILES)
				fatal("Too many identity files specified "
				    "(max %d)", SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] =
			    xstrdup(optarg);
			break;
		case 'I':
#ifdef SMARTCARD
			options.smartcard_device = xstrdup(optarg);
#else
			fprintf(stderr, "no support for smartcards.\n");
#endif
d387 1
a387 1
			} else
d389 1
d406 1
a406 2
			    (u_char) optarg[1] >= 64 &&
			    (u_char) optarg[1] < 128)
d411 1
a411 1
				options.escape_char = SSH_ESCAPECHAR_NONE;
d413 1
a413 2
				fprintf(stderr, "Bad escape character '%s'.\n",
				    optarg);
d426 1
a426 3
					fprintf(stderr,
					    "Unknown cipher type '%s'\n",
					    optarg);
d429 1
a429 1
				if (options.cipher == SSH_CIPHER_3DES)
d431 1
a431 1
				else if (options.cipher == SSH_CIPHER_BLOWFISH)
d433 1
a433 1
				else
d435 1
d442 1
a442 2
				fprintf(stderr, "Unknown mac type '%s'\n",
				    optarg);
a455 2

		case 'L':
d457 5
a461 7
			if (sscanf(optarg, "%5[0-9]:%255[^:]:%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3 &&
			    sscanf(optarg, "%5[0-9]/%255[^/]/%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3) {
				fprintf(stderr,
				    "Bad forwarding specification '%s'\n",
				    optarg);
d465 10
a474 5
			if ((fwd_port = a2port(sfwd_port)) == 0 ||
	  		    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
				fprintf(stderr,
				    "Bad forwarding port(s) '%s'\n", optarg);
				exit(1);
d476 1
a476 6
			if (opt == 'L')
				add_local_forward(&options, fwd_port, buf,
				    fwd_host_port);
			else if (opt == 'R')
				add_remote_forward(&options, fwd_port, buf,
				     fwd_host_port);
d482 1
a482 2
				fprintf(stderr, "Bad dynamic port '%s'\n",
				    optarg);
d500 2
a501 2
			if (process_config_line(&options, host ? host : "",
			    optarg, "command-line", 0, &dummy) != 0)
a506 6
		case 'b':
			options.bind_address = optarg;
			break;
		case 'F':
			config = optarg;
			break;
a511 22
	ac -= optind;
	av += optind;

	if (ac > 0 && !host && **av != '-') {
		if (strchr(*av, '@@')) {
			p = xstrdup(*av);
			cp = strchr(p, '@@');
			if (cp == NULL || cp == p)
				usage();
			options.user = p;
			*cp = '\0';
			host = ++cp;
		} else
			host = *av;
		ac--, av++;
		if (ac > 0) {
			optind = 0;
			optreset = 1;
			goto again;
		}
	}

d527 1
a527 1
	if (!ac) {
d531 1
a531 2
			fprintf(stderr,
			    "You must specify a subsystem to invoke.\n");
d535 4
a538 3
		/* A command has been specified.  Store it into the buffer. */
		for (i = 0; i < ac; i++) {
			if (i)
d569 6
a574 16
	/*
	 * Read per-user configuration file.  Ignore the system wide config
	 * file if the user specifies a config file on the command line.
	 */
	if (config != NULL) {
		if (!read_config_file(config, host, &options))
			fatal("Can't open user config file %.100s: "
			    "%.100s", config, strerror(errno));
	} else  {
		snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir,
		    _PATH_SSH_USER_CONFFILE);

		/* Read systemwide configuration file. */
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host, &options);
		(void)read_config_file(buf, host, &options);
	}
d617 1
a617 1
	cerr = ssh_connect(host, &hostaddr, options.port,
d630 1
a630 1
	if (!cerr && (options.rhosts_rsa_authentication ||
d662 1
a662 1
	snprintf(buf, sizeof buf, "%.100s%s%.100s", pw->pw_dir, strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
d668 1
a668 3
	if (cerr) {
		if (!options.fallback_to_rsh)
			exit(1);
d670 3
a672 3
			log("Secure connection to %.100s on port %hu refused; "
			    "reverting to insecure method",
			    host, options.port);
d674 2
a675 2
			log("Secure connection to %.100s refused; "
			    "reverting to insecure method.", host);
d677 5
a681 2
		rsh_connect(host, options.user, &command);
		fatal("rsh_connect returned");
a712 10
	for (i = 0; i < options.num_identity_files; i++) {
		if (options.identity_files[i]) {
			xfree(options.identity_files[i]);
			options.identity_files[i] = NULL;
		}
		if (options.identity_keys[i]) {
			key_free(options.identity_keys[i]);
			options.identity_keys[i] = NULL;
		}
	}
d719 1
a719 1
static void
d758 1
a758 1
static void
d792 1
a792 1
static void
d805 1
a805 1
static int
d847 1
a847 1
		packet_put_cstring(cp);
d939 1
a939 2
	return client_loop(have_tty, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
d942 1
a942 1
static void
d957 2
a958 3
/* request pty/x11/agent/tcpfwd/shell for channel */
static void
ssh_session2_setup(int id, void *arg)
d964 1
a964 1
	debug("ssh_session2_setup: id %d", id);
d1033 2
a1034 3
/* open new channel for a session */
static int
ssh_session2_open(void)
d1036 2
a1037 2
	Channel *c;
	int window, packetmax, in, out, err;
d1064 1
a1064 1
	c = channel_new(
a1067 2
	if (c == NULL)
		fatal("ssh_session2_open: channel_new failed");
d1069 1
a1069 1
	debug3("ssh_session2_open: channel_new: %d", c->self);
d1071 3
a1073 5
	channel_send_open(c->self);
	if (!no_shell_flag)
		channel_register_callback(c->self,
		     SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
		     ssh_session2_setup, (void *)0);
d1075 1
a1075 1
	return c->self;
d1078 1
a1078 1
static int
d1081 1
a1081 1
	int id = -1;
d1086 1
a1086 2
	if (!no_shell_flag || (datafellows & SSH_BUG_DUMMYCHAN))
		id = ssh_session2_open();
d1093 1
a1093 2
	return client_loop(tty_flag, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, id);
d1096 1
a1096 1
static void
d1101 1
a1101 1
	int i = 0;
d1103 1
a1103 34
#ifdef SMARTCARD
	if (options.smartcard_device != NULL &&
	    options.num_identity_files + 1 < SSH_MAX_IDENTITY_FILES &&
	    (public = sc_get_key(options.smartcard_device)) != NULL ) {
		Key *new;

		if (options.num_identity_files + 2 > SSH_MAX_IDENTITY_FILES)
			options.num_identity_files = SSH_MAX_IDENTITY_FILES - 2;
		memmove(&options.identity_files[2], &options.identity_files[0],
		    sizeof(char *) * options.num_identity_files);
		options.num_identity_files += 2;
		i = 2;

		/* XXX ssh1 vs ssh2 */
		new = key_new(KEY_RSA);
		new->flags = KEY_FLAG_EXT;
		BN_copy(new->rsa->n, public->rsa->n);
		BN_copy(new->rsa->e, public->rsa->e);
		RSA_set_method(new->rsa, sc_get_engine());
		options.identity_keys[0] = new;
		options.identity_files[0] = xstrdup("smartcard rsa key");;

		new = key_new(KEY_RSA1);
		new->flags = KEY_FLAG_EXT;
		BN_copy(new->rsa->n, public->rsa->n);
		BN_copy(new->rsa->e, public->rsa->e);
		RSA_set_method(new->rsa, sc_get_engine());
		options.identity_keys[1] = new;
		options.identity_files[1] = xstrdup("smartcard rsa1 key");

		key_free(public);
	}
#endif /* SMARTCARD */
	for (; i < options.num_identity_files; i++) {
@


1.116.2.2
log
@Merge OpenSSH 3.0
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.116.2.1 2001/09/27 19:03:55 jason Exp $");
a553 1
	channel_set_af(IPv4or6);
a615 1
		(void)read_config_file(buf, host, &options);
d617 1
a617 1
		/* Read systemwide configuration file after use config. */
d619 1
d663 1
a663 1
	cerr = ssh_connect(host, &hostaddr, options.port, IPv4or6,
@


1.116.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.116.2.2 2001/11/15 00:15:19 miod Exp $");
d126 8
a741 2

	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */
@


1.116.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.164 2002/02/14 23:28:00 markus Exp $");
d475 1
a475 1
				    fwd_host_port);
d770 1
a770 1
x11_get_proto(char **_proto, char **_data)
a772 1
	static char proto[512], data[512];
a774 1
	char *display;
d776 1
a776 4
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';
	if (options.xauth_location && (display = getenv("DISPLAY"))) {
d778 2
a779 14
		if (strncmp(display, "localhost:", 10) == 0)
			/*
			 * Handle FamilyLocal case where $DISPLAY does
			 * not match an authorization entry.  For this we
			 * just try "xauth list unix:displaynum.screennum".
			 * XXX: "localhost" match to determine FamilyLocal
			 *      is not perfect.
			 */
			snprintf(line, sizeof line, "%.100s list unix:%s 2>"
			    _PATH_DEVNULL, options.xauth_location, display+10);
		else
			snprintf(line, sizeof line, "%.100s list %.200s 2>"
			    _PATH_DEVNULL, options.xauth_location, display);
		debug2("x11_get_proto %s", line);
d782 1
a782 1
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
d798 1
a798 1
		strlcpy(proto, "MIT-MAGIC-COOKIE-1", sizeof proto);
d802 1
a802 1
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x", rand & 0xff);
d820 1
a820 1
		success += channel_setup_local_fwd_listener(
d859 1
d877 1
a877 1
		type = packet_read();
d915 1
a915 1
		type = packet_read();
d926 1
a926 1
		char *proto, *data;
d928 1
a928 1
		x11_get_proto(&proto, &data);
d934 1
a934 1
		type = packet_read();
d954 2
a955 2
		type = packet_read();
		packet_check_eom();
d976 1
a976 1
		debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
d994 1
a994 1
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d1002 1
a1002 1
	packet_check_eom();
d1005 1
a1005 1
		    len, (u_char *)buffer_ptr(&command), id);
d1042 1
a1042 1
		char *proto, *data;
d1044 1
a1044 1
		x11_get_proto(&proto, &data);
d1064 1
a1064 1
			debug("Sending subsystem: %.*s", len, (u_char *)buffer_ptr(&command));
d1071 1
a1071 1
			debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
d1077 1
a1077 2
		channel_request_start(id, "shell", 0);
		packet_send();
d1079 1
d1081 1
d1113 3
a1115 3
	if (tty_flag) {
		window >>= 1;
		packetmax >>= 1;
d1121 2
d1128 3
a1130 1
		channel_register_confirm(c->self, ssh_session2_setup);
@


1.116.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@a15 1
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.170 2002/04/22 21:04:52 markus Exp $");
d73 1
a140 3
/* # of replies received for global requests */
static int client_global_request_id = 0;

d465 1
a465 1
			    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
a1023 21
void
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
{
	int i;

	i = client_global_request_id++;
	if (i >= options.num_remote_forwards) {
		debug("client_global_request_reply: too many replies %d > %d",
		    i, options.num_remote_forwards);
		return;
	}
	debug("remote forward %s for: listen %d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    options.remote_forwards[i].port,
	    options.remote_forwards[i].host,
	    options.remote_forwards[i].host_port);
	if (type == SSH2_MSG_REQUEST_FAILURE)
		log("Warning: remote port forwarding failed for listen port %d",
		    options.remote_forwards[i].port);
}

d1170 1
d1172 1
a1172 1
	Key *public;
d1174 28
a1201 1
	Key **keys;
d1203 1
a1203 18
	if (options.smartcard_device != NULL &&
	    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL ) {
		int count = 0;
		for (i = 0; keys[i] != NULL; i++) {
			count++;
			memmove(&options.identity_files[1], &options.identity_files[0],
			    sizeof(char *) * (SSH_MAX_IDENTITY_FILES - 1));
			memmove(&options.identity_keys[1], &options.identity_keys[0],
			    sizeof(Key *) * (SSH_MAX_IDENTITY_FILES - 1));
			options.num_identity_files++;
			options.identity_keys[0] = keys[i];
			options.identity_files[0] = xstrdup("smartcard key");;
		}
		if (options.num_identity_files > SSH_MAX_IDENTITY_FILES)
			options.num_identity_files = SSH_MAX_IDENTITY_FILES;
		i = count;
		xfree(keys);
@


1.115
log
@protocol 2 tty modes support; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.114 2001/04/13 01:26:17 stevesk Exp $");
a176 4
	fprintf(stderr, "  -D port     Dynamically forward local port to multiple remote addresses.\n");
	fprintf(stderr, "              Allows %s to act as an application-layer proxy.\n",
	    __progname);
	fprintf(stderr, "              Protocols supported: SOCKS4, SOCKS5, HTTPS\n");
@


1.114
log
@missing \n in error message
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.113 2001/04/12 20:09:37 stevesk Exp $");
d70 1
d862 1
a862 1
		tty_make_modes(fileno(stdin));
d966 1
d986 2
a987 1
		packet_put_cstring("");		/* XXX: encode terminal modes */
@


1.113
log
@robust port validation; ok markus@@ jakob@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.112 2001/04/12 19:15:25 markus Exp $");
d534 1
a534 1
			fprintf(stderr, "You must specify a subsystem to invoke.");
@


1.112
log
@implement HostbasedAuthentication (= RhostRSAAuthentication for ssh v2)
similar to RhostRSAAuthentication unless you enable (the experimental)
HostbasedUsesNameFromPacketOnly option.  please test. :)
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.111 2001/04/12 14:29:09 markus Exp $");
d242 1
a242 1
	char *optarg, *cp, *endofnumber, buf[256];
d450 2
a451 2
			options.port = strtol(optarg, &endofnumber, 0);
			if (optarg == endofnumber) {
d483 3
a485 3
			fwd_port = strtol(optarg, &endofnumber, 0);
			if (optarg == endofnumber) {
				fprintf(stderr, "Bad port '%s'\n", optarg);
@


1.111
log
@show debug output during option processing, report from pekkas@@netcore.fi
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.110 2001/04/11 13:56:13 markus Exp $");
d125 5
a129 2
/* Host private key. */
Key *host_private_key = NULL;
d631 7
a637 2
	if (ok && (options.protocol & SSH_PROTO_1)) {
		host_private_key = key_load_private_type(KEY_RSA1,
d639 4
d701 2
a702 1
	ssh_login(host_private_key, host, (struct sockaddr *)&hostaddr, pw);
d704 12
a715 3
	/* We no longer need the host private key.  Clear it now. */
	if (host_private_key != NULL)
		key_free(host_private_key);	/* Destroys contents safely */
@


1.110
log
@https-connect and socks5 support. i feel so bad.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.109 2001/04/11 10:59:01 markus Exp $");
d566 2
a567 1
	log_init(av[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
@


1.109
log
@use strtol() for ports, thanks jakob@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.108 2001/04/07 08:55:18 markus Exp $");
d174 3
a176 2
	fprintf(stderr, "              Allows SSH to act as an application-layer proxy.\n");
	fprintf(stderr, "              Protocols Supported: SOCKS4\n");
@


1.108
log
@allow the ssh client act as a SOCKS4 proxy (dynamic local portforwarding).
work by Dan Kaminsky <dankamin@@cisco.com> and me. thanks to Dan for this
great patch: use 'ssh -D 1080 host' and make netscape use localhost:1080 as
a socks proxy.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.107 2001/04/06 21:00:13 markus Exp $");
d238 1
a238 1
	char *optarg, *cp, buf[256];
d446 5
a450 1
			options.port = atoi(optarg);
d479 5
a483 1
			fwd_port = atoi(optarg);
@


1.107
log
@do gid/groups-swap in addition to uid-swap, should help if /home/group
is chmod 750 + chgrp grp /home/group/, work be deraadt and me, thanks
to olar@@openwall.com is comments.  we had many requests for this.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.106 2001/04/05 21:05:24 markus Exp $");
d173 3
d307 1
a307 1
		if (strchr("eilcmpLRo", opt)) {	/* options with arguments */
d473 6
@


1.106
log
@don't request a session for 'ssh -N', pointed out slade@@shore.net
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.105 2001/03/26 08:07:09 markus Exp $");
d255 9
d271 1
a271 1
	temporarily_use_uid(original_real_uid);
a543 9
	/* Get user data. */
	pw = getpwuid(original_real_uid);
	if (!pw) {
		log("You don't exist, go away!");
		exit(1);
	}
	/* Take a copy of the returned structure. */
	pw = pwcopy(pw);

d587 1
a587 1
		permanently_set_uid(original_real_uid);
d601 1
a601 2
	    original_real_uid,
	    options.proxy_command);
d628 1
a628 1
	permanently_set_uid(original_real_uid);
d670 1
a670 2
	ssh_login(host_private_key, host, (struct sockaddr *)&hostaddr,
	    original_real_uid);
@


1.105
log
@simpler key load/save interface, see authfile.h
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.104 2001/03/08 21:42:32 markus Exp $");
a928 3
	if (no_shell_flag)
		goto done;

a990 1
done:
d996 1
a996 1
ssh_session2(void)
d998 1
a998 1
	int window, packetmax, id;
a1019 8
	/* XXX should be pre-session */
	ssh_init_forwarding();

	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag)
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));

d1031 2
d1036 18
@


1.104
log
@implement client side of SSH2_MSG_USERAUTH_PK_OK (test public key ->
no need to do enter passphrase or do expensive sign operations if the
server does not accept key).
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.103 2001/03/04 17:42:28 millert Exp $");
a124 3
/* Flag indicating whether we have a valid host private key loaded. */
int host_private_key_loaded = 0;

d126 1
a126 1
RSA *host_private_key = NULL;
d611 2
a612 6
		Key k;
		host_private_key = RSA_new();
		k.type = KEY_RSA1;
		k.rsa = host_private_key;
		if (load_private_key(_PATH_HOST_KEY_FILE, "", &k, NULL))
			host_private_key_loaded = 1;
d671 2
a672 2
	ssh_login(host_private_key_loaded, host_private_key,
		  host, (struct sockaddr *)&hostaddr, original_real_uid);
d675 2
a676 2
	if (host_private_key_loaded)
		RSA_free(host_private_key);	/* Destroys contents safely */
a1049 20
int
guess_identity_file_type(const char *filename)
{
	struct stat st;
	Key *public;
	int type = KEY_RSA1; /* default */

	if (stat(filename, &st) < 0) {
		/* ignore this key */
		return KEY_UNSPEC;
	}
	public = key_new(type);
	if (!load_public_key(filename, public, NULL)) {
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
	}
	key_free(public);
	return type;
}

d1060 1
a1060 10
		public = key_new(KEY_RSA1);
		if (!load_public_key(filename, public, NULL)) {
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (!try_load_public_key(filename, public, NULL)) {
				debug("unknown identity file %s", filename);
				key_free(public);
				public = NULL;
			}
		}
@


1.103
log
@log functions should not be passed strings that end in newline as they
get passed on to syslog() and when logging to stderr, do_log() appends
its own newline.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.102 2001/03/04 10:57:53 stevesk Exp $");
d228 1
a228 1
int	guess_identity_file_type(const char *filename);
d663 5
a667 9
	/* Expand ~ in options.identity_files, known host file names. */
	/* XXX mem-leaks */
	for (i = 0; i < options.num_identity_files; i++) {
		options.identity_files[i] =
		    tilde_expand_filename(options.identity_files[i], original_real_uid);
		options.identity_files_type[i] = guess_identity_file_type(options.identity_files[i]);
		debug("identity file %s type %d", options.identity_files[i],
		    options.identity_files_type[i]);
	}
d1075 28
@


1.102
log
@add -m to usage; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.101 2001/03/03 23:59:34 markus Exp $");
d378 1
a378 1
				fatal("Too high debugging level.\n");
d534 1
a534 1
			log("Pseudo-terminal will not be allocated because stdin is not a terminal.\n");
d541 1
a541 1
		log("You don't exist, go away!\n");
@


1.101
log
@log*.c -> log.c
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.100 2001/03/01 22:46:37 markus Exp $");
d170 1
@


1.100
log
@don't truncate remote ssh-2 commands; from mkubita@@securities.cz
use min, not max for logging, fixes overflow.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.99 2001/03/01 02:29:04 deraadt Exp $");
d546 5
a550 3
	/* Initialize "log" output.  Since we are the client all output
	   actually goes to the terminal. */
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 0);
d563 1
a563 1
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 0);
@


1.99
log
@shorten usage by a line
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.98 2001/02/22 21:59:44 markus Exp $");
d921 2
a922 1
	len = MAX(len, 900);
d995 1
a995 1
		packet_put_string(buffer_ptr(&command), len);
@


1.98
log
@use pwcopy in ssh.c, too
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.97 2001/02/21 21:14:04 stevesk Exp $");
d156 2
a157 2
	fprintf(stderr, "  -i file     Identity for public key authentication\n");
	fprintf(stderr, "              (default: ~/.ssh/identity).\n");
d169 1
a169 2
			"``3des'', "
			"``blowfish''\n");
@


1.97
log
@-i supports DSA identities now; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.96 2001/02/17 23:28:58 deraadt Exp $");
d240 1
a240 1
	struct passwd *pw, pwcopy;
d545 1
a545 9
	memset(&pwcopy, 0, sizeof(pwcopy));
	pwcopy.pw_name = xstrdup(pw->pw_name);
	pwcopy.pw_passwd = xstrdup(pw->pw_passwd);
	pwcopy.pw_uid = pw->pw_uid;
	pwcopy.pw_gid = pw->pw_gid;
	pwcopy.pw_class = xstrdup(pw->pw_class);
	pwcopy.pw_dir = xstrdup(pw->pw_dir);
	pwcopy.pw_shell = xstrdup(pw->pw_shell);
	pw = &pwcopy;
@


1.96
log
@cleanup -V output; noted by millert
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.95 2001/02/11 12:59:25 markus Exp $");
d156 2
a157 1
	fprintf(stderr, "  -i file     Identity for RSA authentication (default: ~/.ssh/identity).\n");
@


1.95
log
@1) clean up the MAC support for SSH-2
2) allow you to specify the MAC with 'ssh -m'
3) or the 'MACs' keyword in ssh(d)_config
4) add hmac-{md5,sha1}-96
	ok stevesk@@, provos@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.94 2001/02/10 01:46:28 markus Exp $");
d381 2
a382 1
			fprintf(stderr, "SSH Version %s, protocol versions %d.%d/%d.%d.\n",
d385 2
a386 2
			    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2);
			fprintf(stderr, "Compiled with SSL (0x%8.8lx).\n", SSLeay());
@


1.94
log
@remove mapping of argv[0] -> hostname
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.93 2001/02/08 19:30:52 itojun Exp $");
d68 2
d297 1
a297 1
		if (strchr("eilcpLRo", opt)) {	/* options with arguments */
d424 8
@


1.93
log
@sync with netbsd tree changes.
- more strict prototypes, include necessary headers
- use paths.h/pathnames.h decls
- size_t typecase to int -> u_long
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.92 2001/02/06 23:06:21 jakob Exp $");
a276 6

	/* If program name is not one of the standard names, use it as host name. */
	cp = __progname;
	if (strcmp(cp, "rsh") && strcmp(cp, "ssh") && strcmp(cp, "rlogin") &&
	    strcmp(cp, "slogin") && strcmp(cp, "remsh"))
		host = cp;
@


1.92
log
@reorder -{1,2,4,6} options. ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.91 2001/02/06 23:03:24 jakob Exp $");
d141 1
a141 1
usage()
d146 1
a146 1
	fprintf(stderr, "  -n          Redirect input from /dev/null.\n");
d703 1
a703 1
		snprintf(line, sizeof line, "%.100s list %.200s 2>/dev/null",
d1016 1
a1016 1
		in = open("/dev/null", O_RDONLY);
@


1.91
log
@add -1 option (force protocol version 1). ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.90 2001/02/06 22:43:02 markus Exp $");
d176 2
a179 2
	fprintf(stderr, "  -1          Force protocol version 1.\n");
	fprintf(stderr, "  -2          Force protocol version 2.\n");
@


1.90
log
@remove confusing callback code
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.89 2001/02/06 22:07:42 markus Exp $");
d178 1
d314 3
@


1.89
log
@fatal() if subsystem fails
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.88 2001/02/04 15:32:26 stevesk Exp $");
d999 1
a1002 1
	clientloop_set_session_ident(id);
@


1.88
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.87 2001/02/04 15:14:14 deraadt Exp $");
d66 1
d914 14
d984 5
a988 1
			channel_request_start(id, "subsystem", 0);
@


1.87
log
@make the alpha happy
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.86 2001/01/31 20:37:23 markus Exp $");
d151 1
a151 1
        fprintf(stderr, "  -X          Enable X11 connection forwarding.\n");
d1013 1
a1013 1
	
@


1.86
log
@do not disconnect if local port forwarding fails, e.g. if port is already in use
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.85 2001/01/29 12:36:10 djm Exp $");
d918 1
a918 1
	debug("client_init id %d arg %d", id, (int)arg);
@


1.85
log
@Allow invocation of sybsystem by commandline (-s); ok markus@@
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.84 2001/01/21 19:05:58 markus Exp $");
d731 1
d733 1
d740 1
a740 1
		channel_request_local_forwarding(
d746 2
@


1.84
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.83 2001/01/19 15:55:11 markus Exp $");
d134 3
d179 1
d469 3
d495 4
d963 7
a969 2
		debug("Sending command: %.*s", len, buffer_ptr(&command));
		channel_request_start(id, "exec", 0);
@


1.83
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.82 2001/01/15 21:40:10 markus Exp $");
a44 2
#include <openssl/dsa.h>
#include <openssl/rsa.h>
d47 5
a52 1
#include "ssh.h"
a54 1
#include "readconf.h"
a55 4

#include "ssh1.h"
#include "ssh2.h"
#include "compat.h"
d62 5
@


1.82
log
@use log() instead of stderr
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.81 2001/01/13 19:14:09 markus Exp $");
d56 1
d63 1
d536 1
a536 1
	snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, SSH_USER_CONFFILE);
d540 1
a540 1
	read_config_file(HOST_CONFIG_FILE, host, &options);
d600 1
a600 1
		if (load_private_key(HOST_KEY_FILE, "", &k, NULL))
d624 1
a624 1
	snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, SSH_USER_DIR);
@


1.81
log
@move callback to headerfile
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.80 2001/01/13 18:32:50 markus Exp $");
d508 1
a508 1
			fprintf(stderr, "Pseudo-terminal will not be allocated because stdin is not a terminal.\n");
d515 1
a515 1
		fprintf(stderr, "You don't exist, go away!\n");
@


1.80
log
@split out keepalive from packet_interactive (from dale@@accentre.com)
set IPTOS_LOWDELAY TCP_NODELAY IPTOS_THROUGHPUT for ssh2, too.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.79 2000/12/27 11:51:54 markus Exp $");
d62 1
a892 2
extern void client_set_session_ident(int id);

d959 1
a959 1
	client_set_session_ident(id);
@


1.79
log
@multiple -t force pty allocation, document ORIGINAL_COMMAND
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.78 2000/12/19 23:17:58 markus Exp $");
d844 1
a844 2
	packet_set_interactive(interactive, options.keepalives);

d898 2
d923 1
d934 1
d959 1
@


1.78
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.77 2000/12/12 23:11:48 markus Exp $");
d74 2
a78 1
int no_tty_flag = 0;
d355 2
d505 1
a505 1
	if (!isatty(fileno(stdin))) {
@


1.77
log
@rhosts-rsa is no longer automagically disabled if ssh is not privileged.
UsePrivilegedPort=no disables rhosts-rsa _only_ for old servers.
these changes should not change the visible default behaviour of the ssh client.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.76 2000/12/12 22:30:01 markus Exp $");
d381 2
a382 2
			    (unsigned char) optarg[1] >= 64 && (unsigned char) optarg[1] < 128)
				options.escape_char = (unsigned char) optarg[1] & 31;
d384 1
a384 1
				options.escape_char = (unsigned char) optarg[0];
@


1.76
log
@consistently use __progname; from stevesk@@pobox.com
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.75 2000/11/30 07:02:35 markus Exp $");
d550 1
a550 1
		debug("Rhosts Authentication methods disabled, "
a552 1
		options.rhosts_rsa_authentication = 0;
d575 1
a575 4
	/*
	 * Open a connection to the remote host.  This needs root privileges
	 * if rhosts_{rsa_}authentication is enabled.
	 */
d578 4
a581 5
			 options.connection_attempts,
			 !options.rhosts_authentication &&
			 !options.rhosts_rsa_authentication,
			 original_real_uid,
			 options.proxy_command);
@


1.75
log
@check -T before isatty()
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.74 2000/11/23 21:03:47 markus Exp $");
a115 3
/* Value of argv[0] (set in the main program). */
char *av0;

d133 1
a133 1
	fprintf(stderr, "Usage: %s [options] host [command]\n", av0);
d161 1
a161 1
	fprintf(stderr, "              These cause %s to listen for connections on a port, and\n", av0);
a259 3
	/* Save our own name. */
	av0 = av[0];

d267 1
a267 4
	if (strchr(av0, '/'))
		cp = strrchr(av0, '/') + 1;
	else
		cp = av0;
@


1.74
log
@complain about invalid ciphers for ssh1/ssh2, fall back to reasonable defaults
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.73 2000/11/15 19:58:08 markus Exp $");
d507 3
a515 3
	/* force */
	if (no_tty_flag)
		tty_flag = 0;
@


1.73
log
@just ignore non existing user keys
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.72 2000/11/12 19:50:38 markus Exp $");
d408 2
a409 2
				Cipher *c = cipher_by_name(optarg);
				if (c == NULL || c->number < 0) {
d413 7
a419 1
				options.cipher = c->number;
@


1.72
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.71 2000/11/06 23:13:26 markus Exp $");
d1023 1
a1023 1
		perror(filename);
@


1.71
log
@do not disabled rhosts(rsa) if server port > 1024; from pekkas@@netcore.fi
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.70 2000/11/06 23:04:56 markus Exp $");
d47 1
d214 3
a216 2
int ssh_session(void);
int ssh_session2(void);
d354 1
a354 1
					optarg);
d359 2
a360 3
				      SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] =
				xstrdup(optarg);
d470 1
a544 14
	/* check if RSA support exists */
	if ((options.protocol & SSH_PROTO_1) &&
	    rsa_alive() == 0) {
		log("%s: no RSA support in libssl and libcrypto.  See ssl(8).",
		    __progname);
		log("Disabling protocol version 1");
		options.protocol &= ~ (SSH_PROTO_1|SSH_PROTO_1_PREFERRED);
	}
	if (! options.protocol & (SSH_PROTO_1|SSH_PROTO_2)) {
		fprintf(stderr, "%s: No protocol version available.\n",
		    __progname);
 		exit(1);
	}

d600 1
a600 1
		k.type = KEY_RSA;
d647 1
a647 1
	/* Expand ~ in options.identity_files. */
d649 1
a649 1
	for (i = 0; i < options.num_identity_files; i++)
d651 13
a663 13
			tilde_expand_filename(options.identity_files[i], original_real_uid);
	for (i = 0; i < options.num_identity_files2; i++)
		options.identity_files2[i] =
			tilde_expand_filename(options.identity_files2[i], original_real_uid);
	/* Expand ~ in known host file names. */
	options.system_hostfile = tilde_expand_filename(options.system_hostfile,
	    original_real_uid);
	options.user_hostfile = tilde_expand_filename(options.user_hostfile,
	    original_real_uid);
	options.system_hostfile2 = tilde_expand_filename(options.system_hostfile2,
	    original_real_uid);
	options.user_hostfile2 = tilde_expand_filename(options.user_hostfile2,
	    original_real_uid);
d1013 20
@


1.70
log
@agent forwarding and -R for ssh2, based on work from jhuuskon@@messi.uku.fi
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.69 2000/10/27 07:32:19 markus Exp $");
d565 2
@


1.69
log
@enable non-blocking IO on channels, and tty's (except for the client ttys).
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.68 2000/10/11 20:27:24 markus Exp $");
d727 43
a773 1
	int i;
a777 1
	int authfd;
a860 6
	/* Clear agent forwarding if we don\'t have an agent. */
	authfd = ssh_get_authentication_socket();
	if (authfd < 0)
		options.forward_agent = 0;
	else
		ssh_close_authentication_socket(authfd);
d863 2
a874 11
	/* Initiate local TCP/IP port forwardings. */
	for (i = 0; i < options.num_local_forwards; i++) {
		debug("Connections to local port %d forwarded to remote address %.200s:%d",
		      options.local_forwards[i].port,
		      options.local_forwards[i].host,
		      options.local_forwards[i].host_port);
		channel_request_local_forwarding(options.local_forwards[i].port,
						 options.local_forwards[i].host,
						 options.local_forwards[i].host_port,
						 options.gateway_ports);
	}
d876 2
a877 10
	/* Initiate remote TCP/IP port forwardings. */
	for (i = 0; i < options.num_remote_forwards; i++) {
		debug("Connections to remote port %d forwarded to local address %.200s:%d",
		      options.remote_forwards[i].port,
		      options.remote_forwards[i].host,
		      options.remote_forwards[i].host_port);
		channel_request_remote_forwarding(options.remote_forwards[i].port,
						  options.remote_forwards[i].host,
						  options.remote_forwards[i].host_port);
	}
a907 17
void
init_local_fwd(void)
{
	int i;
	/* Initiate local TCP/IP port forwardings. */
	for (i = 0; i < options.num_local_forwards; i++) {
		debug("Connections to local port %d forwarded to remote address %.200s:%d",
		      options.local_forwards[i].port,
		      options.local_forwards[i].host,
		      options.local_forwards[i].host_port);
		channel_request_local_forwarding(options.local_forwards[i].port,
						 options.local_forwards[i].host,
						 options.local_forwards[i].host_port,
						 options.gateway_ports);
	}
}

d911 1
a911 1
client_init(int id, void *arg)
d950 7
d999 2
a1000 2
	/* should be pre-session */
	init_local_fwd();
d1019 2
a1020 1
	channel_register_callback(id, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, client_init, (void *)0);
@


1.69.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.95 2001/02/11 12:59:25 markus Exp $");
d45 2
a46 1
#include <openssl/err.h>
d48 1
a49 5
#include "ssh1.h"
#include "ssh2.h"
#include "compat.h"
#include "cipher.h"
#include "xmalloc.h"
d52 1
d54 3
a60 10
#include "pathnames.h"
#include "clientloop.h"
#include "log.h"
#include "readconf.h"
#include "sshconnect.h"
#include "tildexpand.h"
#include "dispatch.h"
#include "misc.h"
#include "kex.h"
#include "mac.h"
a72 2
int no_tty_flag = 0;
int force_tty_flag = 0;
d76 1
d115 3
a129 3
/* Should we execute a command or invoke a subsystem? */
int subsystem_flag = 0;

d133 1
a133 1
usage(void)
d135 1
a135 1
	fprintf(stderr, "Usage: %s [options] host [command]\n", __progname);
d138 1
a138 1
	fprintf(stderr, "  -n          Redirect input from " _PATH_DEVNULL ".\n");
d144 1
a144 1
	fprintf(stderr, "  -X          Enable X11 connection forwarding.\n");
d163 1
a163 1
	fprintf(stderr, "              These cause %s to listen for connections on a port, and\n", __progname);
a167 2
	fprintf(stderr, "  -1          Force protocol version 1.\n");
	fprintf(stderr, "  -2          Force protocol version 2.\n");
d170 1
a171 1
	fprintf(stderr, "  -s          Invoke command (mandatory) as SSH2 subsystem.\n");
d213 2
a214 3
int	ssh_session(void);
int	ssh_session2(void);
int	guess_identity_file_type(const char *filename);
d261 3
d270 9
d296 1
a296 1
		if (strchr("eilcmpLRo", opt)) {	/* options with arguments */
a308 3
		case '1':
			options.protocol = SSH_PROTO_1;
			break;
d352 1
a352 1
				    optarg);
d357 3
a359 2
				    SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] = xstrdup(optarg);
a361 2
			if (tty_flag)
				force_tty_flag = 1;
d389 2
a390 2
			    (u_char) optarg[1] >= 64 && (u_char) optarg[1] < 128)
				options.escape_char = (u_char) optarg[1] & 31;
d392 1
a392 1
				options.escape_char = (u_char) optarg[0];
d407 2
a408 2
				options.cipher = cipher_number(optarg);
				if (options.cipher == -1) {
d412 1
a412 15
				if (options.cipher == SSH_CIPHER_3DES) {
					options.ciphers = "3des-cbc";
				} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
					options.ciphers = "blowfish-cbc";
				} else {
					options.ciphers = (char *)-1;
				}
			}
			break;
		case 'm':
			if (mac_valid(optarg))
				options.macs = xstrdup(optarg);
			else {
				fprintf(stderr, "Unknown mac type '%s'\n", optarg);
				exit(1);
a458 3
		case 's':
			subsystem_flag = 1;
			break;
a468 1
	ERR_load_crypto_strings();
a480 4
		if (subsystem_flag) {
			fprintf(stderr, "You must specify a subsystem to invoke.");
			usage();
		}
a498 3
	/* Force no tty*/
	if (no_tty_flag)
		tty_flag = 0;
d500 1
a500 1
	if (!isatty(fileno(stdin)) && !force_tty_flag) {
d502 1
a502 1
			log("Pseudo-terminal will not be allocated because stdin is not a terminal.\n");
d505 3
d512 1
a512 1
		log("You don't exist, go away!\n");
d531 1
a531 1
	snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, _PATH_SSH_USER_CONFFILE);
d535 1
a535 1
	read_config_file(_PATH_HOST_CONFIG_FILE, host, &options);
d543 14
a564 2
		debug("Rhosts Authentication disabled, "
		    "originating port will not be trusted.");
d566 1
d589 4
a592 1
	/* Open a connection to the remote host. */
d595 5
a599 4
	    options.connection_attempts,
	    original_effective_uid != 0 || !options.use_privileged_port,
	    original_real_uid,
	    options.proxy_command);
d610 1
a610 1
		k.type = KEY_RSA1;
d612 1
a612 1
		if (load_private_key(_PATH_HOST_KEY_FILE, "", &k, NULL))
d636 1
a636 1
	snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, _PATH_SSH_USER_DIR);
d657 1
a657 1
	/* Expand ~ in options.identity_files, known host file names. */
d659 1
a659 1
	for (i = 0; i < options.num_identity_files; i++) {
d661 13
a673 13
		    tilde_expand_filename(options.identity_files[i], original_real_uid);
		options.identity_files_type[i] = guess_identity_file_type(options.identity_files[i]);
		debug("identity file %s type %d", options.identity_files[i],
		    options.identity_files_type[i]);
	}
	options.system_hostfile =
	    tilde_expand_filename(options.system_hostfile, original_real_uid);
	options.user_hostfile =
	    tilde_expand_filename(options.user_hostfile, original_real_uid);
	options.system_hostfile2 =
	    tilde_expand_filename(options.system_hostfile2, original_real_uid);
	options.user_hostfile2 =
	    tilde_expand_filename(options.user_hostfile2, original_real_uid);
d697 1
a697 1
		snprintf(line, sizeof line, "%.100s list %.200s 2>" _PATH_DEVNULL,
a726 47
void
ssh_init_forwarding(void)
{
	int success = 0;
	int i;

	/* Initiate local TCP/IP port forwardings. */
	for (i = 0; i < options.num_local_forwards; i++) {
		debug("Connections to local port %d forwarded to remote address %.200s:%d",
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port);
		success += channel_request_local_forwarding(
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port,
		    options.gateway_ports);
	}
	if (i > 0 && success == 0)
		error("Could not request local forwarding.");

	/* Initiate remote TCP/IP port forwardings. */
	for (i = 0; i < options.num_remote_forwards; i++) {
		debug("Connections to remote port %d forwarded to local address %.200s:%d",
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
		channel_request_remote_forwarding(
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
	}
}

void
check_agent_present(void)
{
	if (options.forward_agent) {
		/* Clear agent forwarding if we don\'t have an agent. */
		int authfd = ssh_get_authentication_socket();
		if (authfd < 0)
			options.forward_agent = 0;
		else
			ssh_close_authentication_socket(authfd);
	}
}

d731 1
d736 1
d818 8
a825 1
	packet_set_interactive(interactive);
a827 2
	check_agent_present();

d838 11
d850 10
a859 2
	/* Initiate port forwardings. */
	ssh_init_forwarding();
d891 1
a891 1
client_subsystem_reply(int type, int plen, void *ctxt)
d893 13
a905 1
	int id, len;
d907 1
a907 8
	id = packet_get_int();
	len = buffer_len(&command);
	len = MAX(len, 900);
	packet_done();
	if (type == SSH2_MSG_CHANNEL_FAILURE)
		fatal("Request for subsystem '%.*s' failed on channel %d",
		    len, buffer_ptr(&command), id);
}
d910 1
a910 1
ssh_session2_callback(int id, void *arg)
d913 1
a913 3
	int interactive = 0;

	debug("client_init id %d arg %ld", id, (long)arg);
a935 1
		interactive = 1;
a945 1
		interactive = 1;
a948 7
	check_agent_present();
	if (options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

d953 2
a954 11
		if (subsystem_flag) {
			debug("Sending subsystem: %.*s", len, buffer_ptr(&command));
			channel_request_start(id, "subsystem", /*want reply*/ 1);
			/* register callback for reply */
			/* XXX we asume that client_loop has already been called */
			dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &client_subsystem_reply);
			dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &client_subsystem_reply);
		} else {
			debug("Sending command: %.*s", len, buffer_ptr(&command));
			channel_request_start(id, "exec", 0);
		}
a960 1

d963 1
a963 1
	packet_set_interactive(interactive);
d973 1
a973 1
		in = open(_PATH_DEVNULL, O_RDONLY);
d991 3
a993 3
	/* XXX should be pre-session */
	ssh_init_forwarding();

d1011 1
a1011 2
	channel_register_callback(id, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
	     ssh_session2_callback, (void *)0);
a1013 20
}

int
guess_identity_file_type(const char *filename)
{
	struct stat st;
	Key *public;
	int type = KEY_RSA1; /* default */

	if (stat(filename, &st) < 0) {
		/* ignore this key */
		return KEY_UNSPEC;
	}
	public = key_new(type);
	if (!load_public_key(filename, public, NULL)) {
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
	}
	key_free(public);
	return type;
@


1.69.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.96 2001/02/17 23:28:58 deraadt Exp $");
d381 1
a381 2
			fprintf(stderr,
			    "%s, SSH protocols %d.%d/%d.%d, OpenSSL 0x%8.8lx\n",
d384 2
a385 2
			    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2,
			    SSLeay());
@


1.69.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.104 2001/03/08 21:42:32 markus Exp $");
d156 1
a156 2
	fprintf(stderr, "  -i file     Identity for public key authentication "
	    "(default: ~/.ssh/identity)\n");
d168 2
a169 2
	    "``3des'', ``blowfish''\n");
	fprintf(stderr, "  -m macs     Specify MAC algorithms for protocol version 2.\n");
d227 1
a227 1
void	load_public_identity_files(void);
d239 1
a239 1
	struct passwd *pw;
d377 1
a377 1
				fatal("Too high debugging level.");
d533 1
a533 1
			log("Pseudo-terminal will not be allocated because stdin is not a terminal.");
d540 1
a540 1
		log("You don't exist, go away!");
d544 13
a556 7
	pw = pwcopy(pw);

	/*
	 * Initialize "log" output.  Since we are the client all output
	 * actually goes to stderr.
	 */
	log_init(av[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
d569 1
a569 1
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 1);
d668 9
a676 5
	/* load options.identity_files */
	load_public_identity_files();

	/* Expand ~ in known host file names. */
	/* XXX mem-leaks: */
d929 1
a929 2
	if (len > 900)
		len = 900;
d1002 1
a1002 1
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
a1082 28
}

void
load_public_identity_files(void)
{
	char *filename;
	Key *public;
	int i;

	for (i = 0; i < options.num_identity_files; i++) {
		filename = tilde_expand_filename(options.identity_files[i],
		    original_real_uid);
		public = key_new(KEY_RSA1);
		if (!load_public_key(filename, public, NULL)) {
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (!try_load_public_key(filename, public, NULL)) {
				debug("unknown identity file %s", filename);
				key_free(public);
				public = NULL;
			}
		}
		debug("identity file %s type %d", filename,
		    public ? public->type : -1);
		xfree(options.identity_files[i]);
		options.identity_files[i] = filename;
		options.identity_keys[i] = public;
	}
@


1.69.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.116 2001/04/17 12:55:04 markus Exp $");
a69 1
#include "sshtty.h"
d125 5
a129 5
/* Private host keys. */
struct {
	Key     **keys;
	int	nkeys;
} sensitive_data;
a257 9
	/* Get user data. */
	pw = getpwuid(original_real_uid);
	if (!pw) {
		log("You don't exist, go away!");
		exit(1);
	}
	/* Take a copy of the returned structure. */
	pw = pwcopy(pw);

d265 1
a265 1
	temporarily_use_uid(pw);
d298 1
a298 1
		if (strchr("eilcmpLRDo", opt)) {   /* options with arguments */
d437 1
a437 5
			options.port = a2port(optarg);
			if (options.port == 0) {
				fprintf(stderr, "Bad port '%s'\n", optarg);
				exit(1);
			}
a463 10

		case 'D':
			fwd_port = a2port(optarg);
			if (fwd_port == 0) {
				fprintf(stderr, "Bad dynamic port '%s'\n", optarg);
				exit(1);
			}
			add_local_forward(&options, fwd_port, "socks4", 0);
			break;

d507 1
a507 1
			fprintf(stderr, "You must specify a subsystem to invoke.\n");
d538 9
d551 1
a551 2
	log_init(av[0], options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
	    SYSLOG_FACILITY_USER, 1);
d590 1
a590 1
		permanently_set_uid(pw);
d604 2
a605 1
	    pw, options.proxy_command);
d613 7
a619 12
	sensitive_data.nkeys = 0;
	sensitive_data.keys = NULL;
	if (ok && (options.rhosts_rsa_authentication ||
	    options.hostbased_authentication)) {
		sensitive_data.nkeys = 3;
		sensitive_data.keys = xmalloc(sensitive_data.nkeys*sizeof(Key));
		sensitive_data.keys[0] = key_load_private_type(KEY_RSA1,
		    _PATH_HOST_KEY_FILE, "", NULL);
		sensitive_data.keys[1] = key_load_private_type(KEY_DSA,
		    _PATH_HOST_DSA_KEY_FILE, "", NULL);
		sensitive_data.keys[2] = key_load_private_type(KEY_RSA,
		    _PATH_HOST_RSA_KEY_FILE, "", NULL);
d636 1
a636 1
	permanently_set_uid(pw);
d678 2
a679 2
	ssh_login(sensitive_data.keys, sensitive_data.nkeys,
	    host, (struct sockaddr *)&hostaddr, pw);
d681 3
a683 12
	/* We no longer need the private host keys.  Clear them now. */
	if (sensitive_data.nkeys != 0) {
		for (i = 0; i < sensitive_data.nkeys; i++) {
			if (sensitive_data.keys[i] != NULL) {
				/* Destroys contents safely */
				debug3("clear hostkey %d", i);
				key_free(sensitive_data.keys[i]);
				sensitive_data.keys[i] = NULL;
			}
		}
		xfree(sensitive_data.keys);
	}
d829 1
a829 1
		tty_make_modes(fileno(stdin), NULL);
a932 1
	struct termios tio;
d936 3
d955 1
a955 2
		tio = get_saved_tio();
		tty_make_modes(/*ignored*/ 0, &tio);
d1001 1
d1007 1
a1007 1
ssh_session2_command(void)
d1009 1
a1009 1
	int id, window, packetmax;
d1031 8
a1049 2
debug("channel_new: %d", id);

d1054 1
a1054 1
	return id;
d1058 1
a1058 1
ssh_session2(void)
d1060 3
a1062 1
	int id;
d1064 11
a1074 11
	/* XXX should be pre-session */
	ssh_init_forwarding();

	id = no_shell_flag ? -1 : ssh_session2_command();

	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag)
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));

	return client_loop(tty_flag, tty_flag ? options.escape_char : -1, id);
d1087 10
a1096 1
		public = key_load_public(filename, NULL);
@


1.69.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.144 2001/09/24 03:38:58 stevesk Exp $");
a71 5
#ifdef SMARTCARD
#include <openssl/engine.h>
#include "scard.h"
#endif

a107 3
/* optional user configfile */
char *config = NULL;

d143 1
a143 1
static void
a149 2
	fprintf(stderr, "  -F config   Config file (default: ~/%s).\n",
	     _PATH_SSH_USER_CONFFILE);
d151 1
a151 1
	fprintf(stderr, "  -a          Disable authentication agent forwarding (default).\n");
d156 1
a156 1
	fprintf(stderr, "  -x          Disable X11 connection forwarding (default).\n");
a158 3
#ifdef SMARTCARD
	fprintf(stderr, "  -I reader   Set smartcard reader.\n");
#endif
d169 2
a170 1
	fprintf(stderr, "  -c cipher   Select encryption algorithm\n");
a176 1
	fprintf(stderr, "  -D port     Enable dynamic application-level port forwarding.\n");
a185 1
	fprintf(stderr, "  -b addr     Local IP address.\n");
d193 1
a193 1
static void
d227 3
a229 3
static int ssh_session(void);
static int ssh_session2(void);
static void load_public_identity_files(void);
d237 1
a237 1
	int i, opt, exit_status, cerr;
d239 1
a239 2
	char sfwd_port[6], sfwd_host_port[6];
	char *p, *cp, buf[256];
a243 2
	extern int optind, optreset;
	extern char *optarg;
d291 29
a319 3
again:
	while ((opt = getopt(ac, av,
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:NPR:TVX")) != -1) {
d366 2
a367 2
				fprintf(stderr, "Warning: Identity file %s "
				    "does not exist.\n", optarg);
d370 4
a373 13
			if (options.num_identity_files >=
			    SSH_MAX_IDENTITY_FILES)
				fatal("Too many identity files specified "
				    "(max %d)", SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] =
			    xstrdup(optarg);
			break;
		case 'I':
#ifdef SMARTCARD
			options.smartcard_device = xstrdup(optarg);
#else
			fprintf(stderr, "no support for smartcards.\n");
#endif
d387 1
a387 1
			} else
d389 1
d406 1
a406 2
			    (u_char) optarg[1] >= 64 &&
			    (u_char) optarg[1] < 128)
d411 1
a411 1
				options.escape_char = SSH_ESCAPECHAR_NONE;
d413 1
a413 2
				fprintf(stderr, "Bad escape character '%s'.\n",
				    optarg);
d426 1
a426 3
					fprintf(stderr,
					    "Unknown cipher type '%s'\n",
					    optarg);
d429 1
a429 1
				if (options.cipher == SSH_CIPHER_3DES)
d431 1
a431 1
				else if (options.cipher == SSH_CIPHER_BLOWFISH)
d433 1
a433 1
				else
d435 1
d442 1
a442 2
				fprintf(stderr, "Unknown mac type '%s'\n",
				    optarg);
a455 2

		case 'L':
d457 5
a461 7
			if (sscanf(optarg, "%5[0-9]:%255[^:]:%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3 &&
			    sscanf(optarg, "%5[0-9]/%255[^/]/%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3) {
				fprintf(stderr,
				    "Bad forwarding specification '%s'\n",
				    optarg);
d465 10
a474 5
			if ((fwd_port = a2port(sfwd_port)) == 0 ||
	  		    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
				fprintf(stderr,
				    "Bad forwarding port(s) '%s'\n", optarg);
				exit(1);
d476 1
a476 6
			if (opt == 'L')
				add_local_forward(&options, fwd_port, buf,
				    fwd_host_port);
			else if (opt == 'R')
				add_remote_forward(&options, fwd_port, buf,
				     fwd_host_port);
d482 1
a482 2
				fprintf(stderr, "Bad dynamic port '%s'\n",
				    optarg);
d500 2
a501 2
			if (process_config_line(&options, host ? host : "",
			    optarg, "command-line", 0, &dummy) != 0)
a506 6
		case 'b':
			options.bind_address = optarg;
			break;
		case 'F':
			config = optarg;
			break;
a511 22
	ac -= optind;
	av += optind;

	if (ac > 0 && !host && **av != '-') {
		if (strchr(*av, '@@')) {
			p = xstrdup(*av);
			cp = strchr(p, '@@');
			if (cp == NULL || cp == p)
				usage();
			options.user = p;
			*cp = '\0';
			host = ++cp;
		} else
			host = *av;
		ac--, av++;
		if (ac > 0) {
			optind = 0;
			optreset = 1;
			goto again;
		}
	}

d527 1
a527 1
	if (!ac) {
d531 1
a531 2
			fprintf(stderr,
			    "You must specify a subsystem to invoke.\n");
d535 4
a538 3
		/* A command has been specified.  Store it into the buffer. */
		for (i = 0; i < ac; i++) {
			if (i)
d569 6
a574 16
	/*
	 * Read per-user configuration file.  Ignore the system wide config
	 * file if the user specifies a config file on the command line.
	 */
	if (config != NULL) {
		if (!read_config_file(config, host, &options))
			fatal("Can't open user config file %.100s: "
			    "%.100s", config, strerror(errno));
	} else  {
		snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir,
		    _PATH_SSH_USER_CONFFILE);

		/* Read systemwide configuration file. */
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host, &options);
		(void)read_config_file(buf, host, &options);
	}
d617 1
a617 1
	cerr = ssh_connect(host, &hostaddr, options.port,
d630 1
a630 1
	if (!cerr && (options.rhosts_rsa_authentication ||
d662 1
a662 1
	snprintf(buf, sizeof buf, "%.100s%s%.100s", pw->pw_dir, strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
d668 1
a668 3
	if (cerr) {
		if (!options.fallback_to_rsh)
			exit(1);
d670 3
a672 3
			log("Secure connection to %.100s on port %hu refused; "
			    "reverting to insecure method",
			    host, options.port);
d674 2
a675 2
			log("Secure connection to %.100s refused; "
			    "reverting to insecure method.", host);
d677 5
a681 2
		rsh_connect(host, options.user, &command);
		fatal("rsh_connect returned");
a712 10
	for (i = 0; i < options.num_identity_files; i++) {
		if (options.identity_files[i]) {
			xfree(options.identity_files[i]);
			options.identity_files[i] = NULL;
		}
		if (options.identity_keys[i]) {
			key_free(options.identity_keys[i]);
			options.identity_keys[i] = NULL;
		}
	}
d719 1
a719 1
static void
d758 1
a758 1
static void
d792 1
a792 1
static void
d805 1
a805 1
static int
d847 1
a847 1
		packet_put_cstring(cp);
d939 1
a939 2
	return client_loop(have_tty, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
d942 1
a942 1
static void
d957 2
a958 3
/* request pty/x11/agent/tcpfwd/shell for channel */
static void
ssh_session2_setup(int id, void *arg)
d964 1
a964 1
	debug("ssh_session2_setup: id %d", id);
d1033 2
a1034 3
/* open new channel for a session */
static int
ssh_session2_open(void)
d1036 2
a1037 2
	Channel *c;
	int window, packetmax, in, out, err;
d1064 1
a1064 1
	c = channel_new(
a1067 2
	if (c == NULL)
		fatal("ssh_session2_open: channel_new failed");
d1069 1
a1069 1
	debug3("ssh_session2_open: channel_new: %d", c->self);
d1071 3
a1073 5
	channel_send_open(c->self);
	if (!no_shell_flag)
		channel_register_callback(c->self,
		     SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
		     ssh_session2_setup, (void *)0);
d1075 1
a1075 1
	return c->self;
d1078 1
a1078 1
static int
d1081 1
a1081 1
	int id = -1;
d1086 1
a1086 2
	if (!no_shell_flag || (datafellows & SSH_BUG_DUMMYCHAN))
		id = ssh_session2_open();
d1093 1
a1093 2
	return client_loop(tty_flag, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, id);
d1096 1
a1096 1
static void
d1101 1
a1101 1
	int i = 0;
d1103 1
a1103 34
#ifdef SMARTCARD
	if (options.smartcard_device != NULL &&
	    options.num_identity_files + 1 < SSH_MAX_IDENTITY_FILES &&
	    (public = sc_get_key(options.smartcard_device)) != NULL ) {
		Key *new;

		if (options.num_identity_files + 2 > SSH_MAX_IDENTITY_FILES)
			options.num_identity_files = SSH_MAX_IDENTITY_FILES - 2;
		memmove(&options.identity_files[2], &options.identity_files[0],
		    sizeof(char *) * options.num_identity_files);
		options.num_identity_files += 2;
		i = 2;

		/* XXX ssh1 vs ssh2 */
		new = key_new(KEY_RSA);
		new->flags = KEY_FLAG_EXT;
		BN_copy(new->rsa->n, public->rsa->n);
		BN_copy(new->rsa->e, public->rsa->e);
		RSA_set_method(new->rsa, sc_get_engine());
		options.identity_keys[0] = new;
		options.identity_files[0] = xstrdup("smartcard rsa key");;

		new = key_new(KEY_RSA1);
		new->flags = KEY_FLAG_EXT;
		BN_copy(new->rsa->n, public->rsa->n);
		BN_copy(new->rsa->e, public->rsa->e);
		RSA_set_method(new->rsa, sc_get_engine());
		options.identity_keys[1] = new;
		options.identity_files[1] = xstrdup("smartcard rsa1 key");

		key_free(public);
	}
#endif /* SMARTCARD */
	for (; i < options.num_identity_files; i++) {
@


1.69.2.6
log
@Merge OpenSSH 3.0
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.69.2.5 2001/09/27 00:15:42 miod Exp $");
a553 1
	channel_set_af(IPv4or6);
a615 1
		(void)read_config_file(buf, host, &options);
d617 1
a617 1
		/* Read systemwide configuration file after use config. */
d619 1
d663 1
a663 1
	cerr = ssh_connect(host, &hostaddr, options.port, IPv4or6,
@


1.69.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.69.2.6 2001/11/15 00:15:00 miod Exp $");
d126 8
a741 2

	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */
@


1.69.2.8
log
@Merge OpenSSH 3.1.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.164 2002/02/14 23:28:00 markus Exp $");
d475 1
a475 1
				    fwd_host_port);
d770 1
a770 1
x11_get_proto(char **_proto, char **_data)
a772 1
	static char proto[512], data[512];
a774 1
	char *display;
d776 1
a776 4
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';
	if (options.xauth_location && (display = getenv("DISPLAY"))) {
d778 2
a779 14
		if (strncmp(display, "localhost:", 10) == 0)
			/*
			 * Handle FamilyLocal case where $DISPLAY does
			 * not match an authorization entry.  For this we
			 * just try "xauth list unix:displaynum.screennum".
			 * XXX: "localhost" match to determine FamilyLocal
			 *      is not perfect.
			 */
			snprintf(line, sizeof line, "%.100s list unix:%s 2>"
			    _PATH_DEVNULL, options.xauth_location, display+10);
		else
			snprintf(line, sizeof line, "%.100s list %.200s 2>"
			    _PATH_DEVNULL, options.xauth_location, display);
		debug2("x11_get_proto %s", line);
d782 1
a782 1
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
d798 1
a798 1
		strlcpy(proto, "MIT-MAGIC-COOKIE-1", sizeof proto);
d802 1
a802 1
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x", rand & 0xff);
d820 1
a820 1
		success += channel_setup_local_fwd_listener(
d859 1
d877 1
a877 1
		type = packet_read();
d915 1
a915 1
		type = packet_read();
d926 1
a926 1
		char *proto, *data;
d928 1
a928 1
		x11_get_proto(&proto, &data);
d934 1
a934 1
		type = packet_read();
d954 2
a955 2
		type = packet_read();
		packet_check_eom();
d976 1
a976 1
		debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
d994 1
a994 1
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d1002 1
a1002 1
	packet_check_eom();
d1005 1
a1005 1
		    len, (u_char *)buffer_ptr(&command), id);
d1042 1
a1042 1
		char *proto, *data;
d1044 1
a1044 1
		x11_get_proto(&proto, &data);
d1064 1
a1064 1
			debug("Sending subsystem: %.*s", len, (u_char *)buffer_ptr(&command));
d1071 1
a1071 1
			debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
d1077 1
a1077 2
		channel_request_start(id, "shell", 0);
		packet_send();
d1079 1
d1081 1
d1113 3
a1115 3
	if (tty_flag) {
		window >>= 1;
		packetmax >>= 1;
d1121 2
d1128 3
a1130 1
		channel_register_confirm(c->self, ssh_session2_setup);
@


1.68
log
@new cipher framework
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.67 2000/10/03 18:16:47 markus Exp $");
d983 8
d1008 1
a1008 1
	    xstrdup("client-session"));
@


1.67
log
@do not resolve canonname, i have no idea why this was added oin ossh
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.66 2000/09/12 20:53:10 markus Exp $");
d407 2
a408 2
				options.cipher = cipher_number(optarg);
				if (options.cipher == -1) {
d412 1
@


1.66
log
@multiple debug levels
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.65 2000/09/07 20:40:30 markus Exp $");
a561 16
	/* Find canonic host name. */
	if (strchr(host, '.') == 0) {
		struct addrinfo hints;
		struct addrinfo *ai = NULL;
		int errgai;
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = IPv4or6;
		hints.ai_flags = AI_CANONNAME;
		hints.ai_socktype = SOCK_STREAM;
		errgai = getaddrinfo(host, NULL, &hints, &ai);
		if (errgai == 0) {
			if (ai->ai_canonname != NULL)
				host = xstrdup(ai->ai_canonname);
			freeaddrinfo(ai);
		}
	}
@


1.65
log
@cleanup window and packet sizes for ssh2 flow control; ok niels
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.64 2000/09/07 20:27:54 deraadt Exp $");
d150 1
d365 10
a382 2
			debug_flag = 1;
			options.log_level = SYSLOG_LEVEL_DEBUG;
@


1.64
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.63 2000/08/28 20:19:52 markus Exp $");
d997 3
a999 4
	window = 32*1024;
	if (tty_flag) {
		packetmax = window/8;
	} else {
d1001 1
a1001 1
		packetmax = window/2;
a1002 2

/*XXX MAXPACK */
d1005 2
a1006 1
	    window, packetmax, CHAN_EXTENDED_WRITE, xstrdup("client-session"));
@


1.63
log
@allow combination of -N and -f
@
text
@a4 1
 * Created: Sat Mar 18 16:36:11 1995 ylo
d9 30
a38 1
 * Modified to work with SSL by Niels Provos <provos@@citi.umich.edu> in Canada.
d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.62 2000/08/28 19:51:00 markus Exp $");
@


1.62
log
@enable -n and -f for ssh2
@
text
@d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.61 2000/08/20 18:42:40 millert Exp $");
d454 1
a454 1
	if (fork_after_authentication_flag && buffer_len(&command) == 0)
@


1.61
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.60 2000/08/19 18:48:11 markus Exp $");
d950 5
a954 6
	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag)
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));

	in  = dup(STDIN_FILENO);
d959 1
a959 1
		fatal("dump in/out/err failed");
d964 5
@


1.60
log
@support for ~. in ssh2
@
text
@d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.59 2000/08/19 02:07:23 deraadt Exp $");
d483 1
@


1.59
log
@accept remsh as a valid name as well; roman@@buildpoint.com
@
text
@d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.58 2000/07/16 08:27:22 markus Exp $");
d864 1
a864 1
	return client_loop(have_tty, tty_flag ? options.escape_char : -1);
d947 10
a956 3
	int in  = dup(STDIN_FILENO);
	int out = dup(STDOUT_FILENO);
	int err = dup(STDERR_FILENO);
d972 1
a976 1

d980 1
a980 1
	return client_loop(tty_flag, tty_flag ? options.escape_char : -1);
@


1.58
log
@make ssh-add accept dsa keys (the agent does not)
@
text
@d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.57 2000/07/15 04:01:37 djm Exp $");
d246 2
a247 2
	if (strcmp(cp, "rsh") != 0 && strcmp(cp, "ssh") != 0 &&
	    strcmp(cp, "rlogin") != 0 && strcmp(cp, "slogin") != 0)
@


1.57
log
@Always create ~/.ssh with mode 700; ok Markus
@
text
@d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.56 2000/06/20 01:39:44 markus Exp $");
a23 1
#include "authfd.h"
d31 1
@


1.56
log
@OpenBSD tag
@
text
@d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.55 2000/05/31 06:36:40 markus Exp $");
d615 1
a615 1
		if (mkdir(buf, 0755) < 0)
@


1.55
log
@xauth_location support; pr 1234
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.54 2000/05/30 17:32:06 markus Exp $");
@


1.54
log
@remove dependency on openssl-0.9.5a; green@@FreeBSD.org via kris@@FreeBSD.org
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.53 2000/05/29 20:20:46 markus Exp $");
d672 11
a682 11
#ifdef XAUTH_PATH
	/* Try to get Xauthority information for the display. */
	snprintf(line, sizeof line, "%.100s list %.200s 2>/dev/null",
		 XAUTH_PATH, getenv("DISPLAY"));
	f = popen(line, "r");
	if (f && fgets(line, sizeof(line), f) &&
	    sscanf(line, "%*s %s %s", proto, data) == 2)
		got_data = 1;
	if (f)
		pclose(f);
#endif /* XAUTH_PATH */
@


1.53
log
@forwardagent defaults to no, add ssh -A
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.52 2000/05/15 06:52:55 markus Exp $");
d430 1
a430 1
	OpenSSL_add_all_algorithms();
@


1.52
log
@fix usage()
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.51 2000/05/08 17:12:15 markus Exp $");
d111 1
d310 3
@


1.51
log
@complain about invalid ciphers in SSH1 (e.g. arcfour is SSH2 only)
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.50 2000/04/28 08:10:20 markus Exp $");
d115 1
d426 1
a426 1
        OpenSSL_add_all_algorithms();
@


1.51.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.55 2000/05/31 06:36:40 markus Exp $");
a110 1
	fprintf(stderr, "  -A          Enable authentication agent forwarding.\n");
a114 1
        fprintf(stderr, "  -X          Enable X11 connection forwarding.\n");
a308 3
		case 'A':
			options.forward_agent = 1;
			break;
d425 1
a425 1
	SSLeay_add_all_algorithms();
d667 11
a677 11
	if (options.xauth_location) {
		/* Try to get Xauthority information for the display. */
		snprintf(line, sizeof line, "%.100s list %.200s 2>/dev/null",
		    options.xauth_location, getenv("DISPLAY"));
		f = popen(line, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %s %s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
	}
@


1.51.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.63 2000/08/28 20:19:52 markus Exp $");
d24 1
a31 1
#include "authfd.h"
d246 2
a247 2
	if (strcmp(cp, "rsh") && strcmp(cp, "ssh") && strcmp(cp, "rlogin") &&
	    strcmp(cp, "slogin") && strcmp(cp, "remsh"))
d454 1
a454 1
	if (fork_after_authentication_flag && buffer_len(&command) == 0 && !no_shell_flag)
a482 1
	pwcopy.pw_class = xstrdup(pw->pw_class);
d615 1
a615 1
		if (mkdir(buf, 0700) < 0)
d864 1
a864 1
	return client_loop(have_tty, tty_flag ? options.escape_char : -1, 0);
d947 3
a949 9
	int in, out, err;

	if (stdin_null_flag) {
		in = open("/dev/null", O_RDONLY);
	} else {
		in = dup(STDIN_FILENO);
	}
	out = dup(STDOUT_FILENO);
	err = dup(STDERR_FILENO);
d952 1
a952 1
		fatal("dup() in/out/err failed");
a956 5
	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag)
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));

a964 1
/*XXX MAXPACK */
d969 1
d973 1
a973 1
	return client_loop(tty_flag, tty_flag ? options.escape_char : -1, id);
@


1.51.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
d10 1
a10 30
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 *
 * Modified to work with SSL by Niels Provos <provos@@citi.umich.edu>
 * in Canada (German citizen).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d14 1
a14 1
RCSID("$OpenBSD: ssh.c,v 1.69 2000/10/27 07:32:19 markus Exp $");
a121 1
	fprintf(stderr, "              Multiple -v increases verbosity.\n");
a335 10
			if (0 == debug_flag) {
				debug_flag = 1;
				options.log_level = SYSLOG_LEVEL_DEBUG1;
			} else if (options.log_level < SYSLOG_LEVEL_DEBUG3) {
				options.log_level++;
				break;
			} else {
				fatal("Too high debugging level.\n");
			}
			/* fallthrough */
d344 2
d370 2
a371 2
				Cipher *c = cipher_by_name(optarg);
				if (c == NULL || c->number < 0) {
a374 1
				options.cipher = c->number;
d525 16
a960 8
	/* enable nonblocking unless tty */
	if (!isatty(in))
		set_nonblock(in);
	if (!isatty(out))
		set_nonblock(out);
	if (!isatty(err))
		set_nonblock(err);

d969 4
a972 3
	window = CHAN_SES_WINDOW_DEFAULT;
	packetmax = CHAN_SES_PACKET_DEFAULT;
	if (!tty_flag) {
d974 1
a974 1
		packetmax *=2;
d976 2
d980 1
a980 2
	    window, packetmax, CHAN_EXTENDED_WRITE,
	    xstrdup("client-session"), /*nonblock*/0);
@


1.51.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.96 2001/02/17 23:28:58 deraadt Exp $");
d45 2
a46 1
#include <openssl/err.h>
d48 1
a49 5
#include "ssh1.h"
#include "ssh2.h"
#include "compat.h"
#include "cipher.h"
#include "xmalloc.h"
d52 1
d54 3
a60 10
#include "pathnames.h"
#include "clientloop.h"
#include "log.h"
#include "readconf.h"
#include "sshconnect.h"
#include "tildexpand.h"
#include "dispatch.h"
#include "misc.h"
#include "kex.h"
#include "mac.h"
a72 2
int no_tty_flag = 0;
int force_tty_flag = 0;
d76 1
d115 3
a129 3
/* Should we execute a command or invoke a subsystem? */
int subsystem_flag = 0;

d133 1
a133 1
usage(void)
d135 1
a135 1
	fprintf(stderr, "Usage: %s [options] host [command]\n", __progname);
d138 1
a138 1
	fprintf(stderr, "  -n          Redirect input from " _PATH_DEVNULL ".\n");
d144 1
a144 1
	fprintf(stderr, "  -X          Enable X11 connection forwarding.\n");
d163 1
a163 1
	fprintf(stderr, "              These cause %s to listen for connections on a port, and\n", __progname);
a167 2
	fprintf(stderr, "  -1          Force protocol version 1.\n");
	fprintf(stderr, "  -2          Force protocol version 2.\n");
d170 1
a171 1
	fprintf(stderr, "  -s          Invoke command (mandatory) as SSH2 subsystem.\n");
d213 2
a214 3
int	ssh_session(void);
int	ssh_session2(void);
int	guess_identity_file_type(const char *filename);
d261 3
d270 9
d296 1
a296 1
		if (strchr("eilcmpLRo", opt)) {	/* options with arguments */
a308 3
		case '1':
			options.protocol = SSH_PROTO_1;
			break;
d352 1
a352 1
				    optarg);
d357 3
a359 2
				    SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] = xstrdup(optarg);
a361 2
			if (tty_flag)
				force_tty_flag = 1;
d376 1
a376 2
			fprintf(stderr,
			    "%s, SSH protocols %d.%d/%d.%d, OpenSSL 0x%8.8lx\n",
d379 2
a380 2
			    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2,
			    SSLeay());
d389 2
a390 2
			    (u_char) optarg[1] >= 64 && (u_char) optarg[1] < 128)
				options.escape_char = (u_char) optarg[1] & 31;
d392 1
a392 1
				options.escape_char = (u_char) optarg[0];
d407 2
a408 2
				options.cipher = cipher_number(optarg);
				if (options.cipher == -1) {
d412 1
a412 15
				if (options.cipher == SSH_CIPHER_3DES) {
					options.ciphers = "3des-cbc";
				} else if (options.cipher == SSH_CIPHER_BLOWFISH) {
					options.ciphers = "blowfish-cbc";
				} else {
					options.ciphers = (char *)-1;
				}
			}
			break;
		case 'm':
			if (mac_valid(optarg))
				options.macs = xstrdup(optarg);
			else {
				fprintf(stderr, "Unknown mac type '%s'\n", optarg);
				exit(1);
a458 3
		case 's':
			subsystem_flag = 1;
			break;
a468 1
	ERR_load_crypto_strings();
a480 4
		if (subsystem_flag) {
			fprintf(stderr, "You must specify a subsystem to invoke.");
			usage();
		}
a498 3
	/* Force no tty*/
	if (no_tty_flag)
		tty_flag = 0;
d500 1
a500 1
	if (!isatty(fileno(stdin)) && !force_tty_flag) {
d502 1
a502 1
			log("Pseudo-terminal will not be allocated because stdin is not a terminal.\n");
d505 3
d512 1
a512 1
		log("You don't exist, go away!\n");
d531 1
a531 1
	snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, _PATH_SSH_USER_CONFFILE);
d535 1
a535 1
	read_config_file(_PATH_HOST_CONFIG_FILE, host, &options);
d543 14
a564 2
		debug("Rhosts Authentication disabled, "
		    "originating port will not be trusted.");
d566 1
d589 4
a592 1
	/* Open a connection to the remote host. */
d595 5
a599 4
	    options.connection_attempts,
	    original_effective_uid != 0 || !options.use_privileged_port,
	    original_real_uid,
	    options.proxy_command);
d610 1
a610 1
		k.type = KEY_RSA1;
d612 1
a612 1
		if (load_private_key(_PATH_HOST_KEY_FILE, "", &k, NULL))
d636 1
a636 1
	snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, _PATH_SSH_USER_DIR);
d657 1
a657 1
	/* Expand ~ in options.identity_files, known host file names. */
d659 1
a659 1
	for (i = 0; i < options.num_identity_files; i++) {
d661 13
a673 13
		    tilde_expand_filename(options.identity_files[i], original_real_uid);
		options.identity_files_type[i] = guess_identity_file_type(options.identity_files[i]);
		debug("identity file %s type %d", options.identity_files[i],
		    options.identity_files_type[i]);
	}
	options.system_hostfile =
	    tilde_expand_filename(options.system_hostfile, original_real_uid);
	options.user_hostfile =
	    tilde_expand_filename(options.user_hostfile, original_real_uid);
	options.system_hostfile2 =
	    tilde_expand_filename(options.system_hostfile2, original_real_uid);
	options.user_hostfile2 =
	    tilde_expand_filename(options.user_hostfile2, original_real_uid);
d697 1
a697 1
		snprintf(line, sizeof line, "%.100s list %.200s 2>" _PATH_DEVNULL,
a726 47
void
ssh_init_forwarding(void)
{
	int success = 0;
	int i;

	/* Initiate local TCP/IP port forwardings. */
	for (i = 0; i < options.num_local_forwards; i++) {
		debug("Connections to local port %d forwarded to remote address %.200s:%d",
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port);
		success += channel_request_local_forwarding(
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port,
		    options.gateway_ports);
	}
	if (i > 0 && success == 0)
		error("Could not request local forwarding.");

	/* Initiate remote TCP/IP port forwardings. */
	for (i = 0; i < options.num_remote_forwards; i++) {
		debug("Connections to remote port %d forwarded to local address %.200s:%d",
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
		channel_request_remote_forwarding(
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
	}
}

void
check_agent_present(void)
{
	if (options.forward_agent) {
		/* Clear agent forwarding if we don\'t have an agent. */
		int authfd = ssh_get_authentication_socket();
		if (authfd < 0)
			options.forward_agent = 0;
		else
			ssh_close_authentication_socket(authfd);
	}
}

d731 1
d736 1
d818 8
a825 1
	packet_set_interactive(interactive);
a827 2
	check_agent_present();

d838 11
d850 10
a859 2
	/* Initiate port forwardings. */
	ssh_init_forwarding();
d891 1
a891 1
client_subsystem_reply(int type, int plen, void *ctxt)
d893 13
a905 1
	int id, len;
d907 1
a907 8
	id = packet_get_int();
	len = buffer_len(&command);
	len = MAX(len, 900);
	packet_done();
	if (type == SSH2_MSG_CHANNEL_FAILURE)
		fatal("Request for subsystem '%.*s' failed on channel %d",
		    len, buffer_ptr(&command), id);
}
d910 1
a910 1
ssh_session2_callback(int id, void *arg)
d913 1
a913 3
	int interactive = 0;

	debug("client_init id %d arg %ld", id, (long)arg);
a935 1
		interactive = 1;
a945 1
		interactive = 1;
a948 7
	check_agent_present();
	if (options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

d953 2
a954 11
		if (subsystem_flag) {
			debug("Sending subsystem: %.*s", len, buffer_ptr(&command));
			channel_request_start(id, "subsystem", /*want reply*/ 1);
			/* register callback for reply */
			/* XXX we asume that client_loop has already been called */
			dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &client_subsystem_reply);
			dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &client_subsystem_reply);
		} else {
			debug("Sending command: %.*s", len, buffer_ptr(&command));
			channel_request_start(id, "exec", 0);
		}
a960 1

d963 1
a963 1
	packet_set_interactive(interactive);
d973 1
a973 1
		in = open(_PATH_DEVNULL, O_RDONLY);
d991 3
a993 3
	/* XXX should be pre-session */
	ssh_init_forwarding();

d1011 1
a1011 2
	channel_register_callback(id, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,
	     ssh_session2_callback, (void *)0);
a1013 20
}

int
guess_identity_file_type(const char *filename)
{
	struct stat st;
	Key *public;
	int type = KEY_RSA1; /* default */

	if (stat(filename, &st) < 0) {
		/* ignore this key */
		return KEY_UNSPEC;
	}
	public = key_new(type);
	if (!load_public_key(filename, public, NULL)) {
		/* ok, so we will assume this is 'some' key */
		type = KEY_UNSPEC;
	}
	key_free(public);
	return type;
@


1.51.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d42 1
a42 1
RCSID("$OpenBSD: ssh.c,v 1.104 2001/03/08 21:42:32 markus Exp $");
d156 1
a156 2
	fprintf(stderr, "  -i file     Identity for public key authentication "
	    "(default: ~/.ssh/identity)\n");
d168 2
a169 2
	    "``3des'', ``blowfish''\n");
	fprintf(stderr, "  -m macs     Specify MAC algorithms for protocol version 2.\n");
d227 1
a227 1
void	load_public_identity_files(void);
d239 1
a239 1
	struct passwd *pw;
d377 1
a377 1
				fatal("Too high debugging level.");
d533 1
a533 1
			log("Pseudo-terminal will not be allocated because stdin is not a terminal.");
d540 1
a540 1
		log("You don't exist, go away!");
d544 13
a556 7
	pw = pwcopy(pw);

	/*
	 * Initialize "log" output.  Since we are the client all output
	 * actually goes to stderr.
	 */
	log_init(av[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
d569 1
a569 1
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 1);
d668 9
a676 5
	/* load options.identity_files */
	load_public_identity_files();

	/* Expand ~ in known host file names. */
	/* XXX mem-leaks: */
d929 1
a929 2
	if (len > 900)
		len = 900;
d1002 1
a1002 1
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
a1082 28
}

void
load_public_identity_files(void)
{
	char *filename;
	Key *public;
	int i;

	for (i = 0; i < options.num_identity_files; i++) {
		filename = tilde_expand_filename(options.identity_files[i],
		    original_real_uid);
		public = key_new(KEY_RSA1);
		if (!load_public_key(filename, public, NULL)) {
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (!try_load_public_key(filename, public, NULL)) {
				debug("unknown identity file %s", filename);
				key_free(public);
				public = NULL;
			}
		}
		debug("identity file %s type %d", filename,
		    public ? public->type : -1);
		xfree(options.identity_files[i]);
		options.identity_files[i] = filename;
		options.identity_keys[i] = public;
	}
@


1.50
log
@support for x11-fwding, client+server
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.49 2000/04/26 20:56:30 markus Exp $");
d362 1
@


1.49
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.14 2000/04/18 15:01:33 markus Exp $");
d659 39
d771 4
a774 38
		char line[512], proto[512], data[512];
		FILE *f;
		int forwarded = 0, got_data = 0, i;

#ifdef XAUTH_PATH
		/* Try to get Xauthority information for the display. */
		snprintf(line, sizeof line, "%.100s list %.200s 2>/dev/null",
			 XAUTH_PATH, getenv("DISPLAY"));
		f = popen(line, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %s %s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
#endif /* XAUTH_PATH */
		/*
		 * If we didn't get authentication data, just make up some
		 * data.  The forwarding code will check the validity of the
		 * response anyway, and substitute this data.  The X11
		 * server, however, will ignore this fake data and use
		 * whatever authentication mechanisms it was using otherwise
		 * for the local connection.
		 */
		if (!got_data) {
			u_int32_t rand = 0;

			strlcpy(proto, "MIT-MAGIC-COOKIE-1", sizeof proto);
			for (i = 0; i < 16; i++) {
				if (i % 4 == 0)
					rand = arc4random();
				snprintf(data + 2 * i, sizeof data - 2 * i, "%02x", rand & 0xff);
				rand >>= 8;
			}
		}
		/*
		 * Got local authentication reasonable information. Request
		 * forwarding with authentication spoofing.
		 */
d776 1
a776 1
		x11_request_forwarding_with_spoofing(proto, data);
a780 1
			forwarded = 1;
d782 1
a782 1
		} else if (type == SSH_SMSG_FAILURE)
d784 1
a784 1
		else
d786 1
d909 11
@


1.48
log
@whitespace cleanup
@
text
@d14 5
a18 1
RCSID("$Id: ssh.c,v 1.47 2000/04/14 10:11:12 markus Exp $");
d31 4
d359 10
a368 4
			options.cipher = cipher_number(optarg);
			if (options.cipher == -1) {
				fprintf(stderr, "Unknown cipher type '%s'\n", optarg);
				exit(1);
d424 1
a424 3
	/* check if RSA support exists */
	if (rsa_alive() == 0) {
		extern char *__progname;
a425 5
		fprintf(stderr,
			"%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
			__progname);
		exit(1);
	}
d498 14
d578 2
a579 1
	if (ok) {
d581 3
a583 1
		if (load_private_key(HOST_KEY_FILE, "", host_private_key, NULL))
d629 1
d633 3
a635 1

d638 1
a638 1
							original_real_uid);
d640 5
a644 1
						      original_real_uid);
@


1.47
log
@ssh -2
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.46 2000/04/12 07:45:44 markus Exp $");
d245 2
a246 2
			        if(cp == av[optind])
				        usage();
a272 1

a275 1

a278 1

a281 1

a285 1

a288 1

a291 1

a294 1

a297 1

a318 1

a321 1

a333 1

a336 1

a349 1

a356 1

a359 1

a362 1

a373 1

a384 1

a387 1

a391 1

a394 1

a400 1

d611 1
a611 1
						        original_real_uid);
d780 1
a780 1
					  	 options.local_forwards[i].host,
d793 1
a793 1
				   		  options.remote_forwards[i].host_port);
d797 1
a797 1
	if (fork_after_authentication_flag) 
d836 1
a836 1
					  	 options.local_forwards[i].host,
@


1.46
log
@add Cipher and Protocol options to ssh/sshd, e.g.:
ssh -o 'Protocol 1,2' if you prefer proto 1, ssh -o 'Ciphers arcfour,3des-cbc'
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.45 2000/04/04 15:19:42 markus Exp $");
d131 1
d270 4
@


1.45
log
@ssh2 client implementation, interops w/ ssh.com and lsh servers.
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.44 2000/03/28 20:31:28 markus Exp $");
d35 1
d330 4
a333 2
			fprintf(stderr, "SSH Version %s, protocol version %d.%d.\n",
			    SSH_VERSION, PROTOCOL_MAJOR, PROTOCOL_MINOR);
@


1.44
log
@replace big switch() with function tables (prepare for ssh2)
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.43 2000/03/23 21:52:02 markus Exp $");
d23 3
d37 4
d90 3
a106 1
	fprintf(stderr, "  -X          Enable X11 connection forwarding.\n");
d109 1
d126 1
d172 3
d181 1
a181 1
	int i, opt, optind, type, exit_status, ok, authfd;
a183 2
	Buffer command;
	struct winsize ws;
d186 1
a186 2
	int interactive = 0, dummy;
	int have_pty = 0;
a187 1
	int plen;
d331 1
a331 1
			fprintf(stderr, "Compiled with SSL.\n");
d400 9
d469 4
d638 17
d708 1
a708 1
			have_pty = 1;
d837 27
a863 1
	exit_status = client_loop(have_pty, tty_flag ? options.escape_char : -1);
d865 69
a933 2
	/* Close the connection to the remote host. */
	packet_close();
d935 1
a935 2
	/* Exit with the status returned by the program on the remote side. */
	exit(exit_status);
@


1.43
log
@switch to raw mode only if he _get_ a pty (not if we _want_ a pty).
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.42 2000/03/22 09:55:10 markus Exp $");
d23 1
@


1.42
log
@remove unused cipher_attack_detected code
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.41 2000/02/28 19:51:58 markus Exp $");
d174 1
d665 1
a665 1
		if (type == SSH_SMSG_SUCCESS)
d667 2
a668 1
		else if (type == SSH_SMSG_FAILURE)
d796 1
a796 1
	exit_status = client_loop(tty_flag, tty_flag ? options.escape_char : -1);
@


1.41
log
@turn off x11-fwd for the client, too.
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.40 2000/02/20 20:05:19 markus Exp $");
a611 3

	/* Close connection cleanly after attack. */
	cipher_attack_detected = packet_disconnect;
@


1.40
log
@suppress AAAA query host when '-4' is used; from shin@@nd.net.fujitsu.co.jp
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.39 2000/01/04 13:41:32 markus Exp $");
d96 1
@


1.39
log
@more hints (hints.ai_socktype=SOCK_STREAM) for getaddrinfo, from itojun@@
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.38 2000/01/04 09:07:59 markus Exp $");
d492 1
a492 1
		hints.ai_family = AF_UNSPEC;
@


1.38
log
@'ssh @@host' is illegal (null user name), from karsten@@gedankenpolizei.de
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.37 2000/01/04 00:08:00 markus Exp $");
d494 1
@


1.37
log
@ipv6 support: mostly gethostbyname->getaddrinfo/getnameinfo, new features:
sshd allows multiple ListenAddress and Port options.  note that libwrap is
not IPv6-ready. (based on patches from <kick@@kyoto.wide.ad.jp> and
fujiwara@@rcac.tdi.co.jp)
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.36 1999/12/12 19:20:03 markus Exp $");
d230 2
@


1.36
log
@type conflict for 'extern Type *options' in channels.c; dot@@dotat.at
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.35 1999/12/01 13:59:15 markus Exp $");
d24 4
d60 1
a60 1
struct sockaddr_in hostaddr;
d115 2
d253 8
d358 4
a361 2
			if (sscanf(optarg, "%hu:%255[^:]:%hu", &fwd_port, buf,
				   &fwd_host_port) != 3) {
d370 4
a373 2
			if (sscanf(optarg, "%hu:%255[^:]:%hu", &fwd_port, buf,
				   &fwd_host_port) != 3) {
d486 11
a496 8
		struct hostent *hp = gethostbyname(host);
		if (hp != 0) {
			if (strchr(hp->h_name, '.') != 0)
				host = xstrdup(hp->h_name);
			else if (hp->h_aliases != 0
				 && hp->h_aliases[0] != 0
				 && strchr(hp->h_aliases[0], '.') != 0)
				host = xstrdup(hp->h_aliases[0]);
d603 1
a603 1
		  host, &hostaddr, original_real_uid);
@


1.35
log
@ports are u_short
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.34 1999/11/24 20:15:35 markus Exp $");
d731 2
a732 1
						 options.local_forwards[i].host_port);
@


1.34
log
@postpone fork_after_authentication until command execution,
request/patch from jahakala@@cc.jyu.fi via damien@@ibs.com.au
plus: use daemon() for backgrounding
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.33 1999/11/24 19:53:52 markus Exp $");
d159 2
a160 2
	int i, opt, optind, type, exit_status, ok, fwd_port, fwd_host_port,
	 authfd;
a336 4
			if (options.port < 1 || options.port > 65535) {
				fprintf(stderr, "Bad port %s.\n", optarg);
				exit(1);
			}
d344 1
a344 1
			if (sscanf(optarg, "%d:%255[^:]:%d", &fwd_port, buf,
d354 1
a354 1
			if (sscanf(optarg, "%d:%255[^:]:%d", &fwd_port, buf,
d556 1
a556 1
			log("Secure connection to %.100s on port %d refused%.100s.",
@


1.33
log
@KNF, final part 3
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.32 1999/11/24 00:26:03 deraadt Exp $");
a594 9
	/* If requested, fork and let ssh continue in the background. */
	if (fork_after_authentication_flag) {
		int ret = fork();
		if (ret == -1)
			fatal("fork failed: %.100s", strerror(errno));
		if (ret != 0)
			exit(0);
		setsid();
	}
d748 5
@


1.32
log
@much more KNF
@
text
@d14 1
a14 1
RCSID("$Id: ssh.c,v 1.31 1999/11/23 22:25:55 markus Exp $");
a26 2
/* Flag indicating whether to allocate a pseudo tty.  This can be set on the command
   line, and is automatically set if no command is given on the command line. */
d29 4
a32 2
/* Flag indicating that nothing should be read from stdin.  This can be set
   on the command line. */
d35 5
a39 3
/* Flag indicating that ssh should fork after authentication.  This is useful
   so that the pasphrase can be entered manually, and then ssh goes to the
   background. */
d42 4
a45 2
/* General data structure for command line options and options configurable
   in configuration files.  See readconf.h. */
d48 5
a52 3
/* Name of the host we are connecting to.  This is the name given on the
   command line, or the HostName specified for the user-supplied name
   in a configuration file. */
d58 6
a63 4
/* Flag to indicate that we have received a window change signal which has
   not yet been processed.  This will cause a message indicating the new
   window size to be sent to the server a little later.  This is volatile
   because this is updated in a signal handler. */
d170 4
a173 2
	/* Save the original real uid.  It will be needed later
	   (uid-swapping may clobber the real uid).  */
d184 7
a190 6
	/* Use uid-swapping to give up root privileges for the duration of
	   option processing.  We will re-instantiate the rights when we
	   are ready to create the privileged port, and will permanently
	   drop them when the port has been created (actually, when the
	   connection has been made, as we may need to create the port
	   several times). */
d193 6
a198 4
	/* Set our umask to something reasonable, as some files are
	   created with the default umask.  This will make them
	   world-readable but writable only by the owner, which is ok for
	   all files for which we don't set the modes explicitly. */
d399 5
a403 4
	/* Save the command to execute on the remote host in a buffer.
	   There is no limit on the length of the command, except by the
	   maximum packet size.  Also sets the tty flag if there is no
	   command. */
d487 4
a490 2
	/* If using rsh has been selected, exec it now (without trying
	   anything else).  Note that we must release privileges first. */
d492 4
a495 2
		/* Restore our superuser privileges.  This must be done
		   before permanently setting the uid. */
d508 4
a511 2
	/* Open a connection to the remote host.  This needs root
	   privileges if rhosts_{rsa_}authentication is enabled. */
d520 6
a525 4
	/* If we successfully made the connection, load the host private
	   key in case we will need it later for combined rsa-rhosts
	   authentication. This must be done before releasing extra
	   privileges, because the file is only readable by root. */
d531 15
a545 12
	/* Get rid of any extra privileges that we may have.  We will no
	   longer need them.  Also, extra privileges could make it very
	   hard to read identity files and other non-world-readable files
	   from the user's home directory if it happens to be on a NFS
	   volume where root is mapped to nobody. */

	/* Note that some legacy systems need to postpone the following
	   call to permanently_set_uid() until the private hostkey is
	   destroyed with RSA_free().  Otherwise the calling user could
	   ptrace() the process, read the private hostkey and impersonate
	   the host.  OpenBSD does not allow ptracing of setuid processes. */

d548 4
a551 2
	/* Now that we are back to our own permissions, create ~/.ssh
	   directory if it doesn\'t already exist. */
d679 8
a686 6
		/* If we didn't get authentication data, just make up some
		   data.  The forwarding code will check the validity of
		   the response anyway, and substitute this data.  The X11
		   server, however, will ignore this fake data and use
		   whatever authentication mechanisms it was using
		   otherwise for the local connection. */
d698 4
a701 2
		/* Got local authentication reasonable information.
		   Request forwarding with authentication spoofing. */
d758 4
a761 2
	/* If a command was specified on the command line, execute the
	   command now. Otherwise request the server to start a shell. */
@


1.31
log
@KNF part 1
@
text
@d2 10
a11 17

ssh.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Sat Mar 18 16:36:11 1995 ylo

Ssh client program.  This program can be used to log into a remote machine.
The software supports strong authentication, encryption, and forwarding
of X11, TCP/IP, and authentication connections.

Modified to work with SSL by Niels Provos <provos@@citi.umich.edu> in Canada.

*/
d14 1
a14 1
RCSID("$Id: ssh.c,v 1.30 1999/11/15 21:05:03 markus Exp $");
d107 4
a110 3
/* Connects to the given host using rsh (or prints an error message and exits
   if rsh is not available).  This function never returns. */

d145 3
a147 2
/* Main program for the ssh client. */

@


1.30
log
@a note for legay systems about secuity issues with permanently_set_uid(),
the private hostkey and ptrace()
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.29 1999/11/14 21:45:07 markus Exp $");
d31 1
a31 2
/* Flag indicating whether debug mode is on.  This can be set on the
   command line. */
d34 2
a35 3
/* Flag indicating whether to allocate a pseudo tty.  This can be set on the
   command line, and is automatically set if no command is given on the command
   line. */
d82 5
a86 5
  fprintf(stderr, "Usage: %s [options] host [command]\n", av0);
  fprintf(stderr, "Options:\n");
  fprintf(stderr, "  -l user     Log in using this user name.\n");
  fprintf(stderr, "  -n          Redirect input from /dev/null.\n");
  fprintf(stderr, "  -a          Disable authentication agent forwarding.\n");
d88 24
a111 24
  fprintf(stderr, "  -k          Disable Kerberos ticket and AFS token forwarding.\n");
#endif /* AFS */
  fprintf(stderr, "  -x          Disable X11 connection forwarding.\n");
  fprintf(stderr, "  -i file     Identity for RSA authentication (default: ~/.ssh/identity).\n");
  fprintf(stderr, "  -t          Tty; allocate a tty even if command is given.\n");
  fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
  fprintf(stderr, "  -V          Display version number only.\n");
  fprintf(stderr, "  -P          Don't allocate a privileged port.\n");
  fprintf(stderr, "  -q          Quiet; don't display any warning messages.\n");
  fprintf(stderr, "  -f          Fork into background after authentication.\n");
  fprintf(stderr, "  -e char     Set escape character; ``none'' = disable (default: ~).\n");

  fprintf(stderr, "  -c cipher   Select encryption algorithm: "
		  "``3des'', "
		  "``blowfish''\n");
  fprintf(stderr, "  -p port     Connect to this port.  Server must be on the same port.\n");
  fprintf(stderr, "  -L listen-port:host:port   Forward local port to remote address\n");
  fprintf(stderr, "  -R listen-port:host:port   Forward remote port to local address\n");
  fprintf(stderr, "              These cause %s to listen for connections on a port, and\n", av0);
  fprintf(stderr, "              forward them to the other side by connecting to host:port.\n");
  fprintf(stderr, "  -C          Enable compression.\n");
  fprintf(stderr, "  -g          Allow remote hosts to connect to forwarded ports.\n");
  fprintf(stderr, "  -o 'option' Process the option as if it was read from a configuration file.\n");
  exit(1);
d118 1
a118 1
rsh_connect(char *host, char *user, Buffer *command)
d120 29
a148 32
  char *args[10];
  int i;
  
  log("Using rsh.  WARNING: Connection will not be encrypted.");
  /* Build argument list for rsh. */
  i = 0;
  args[i++] = _PATH_RSH;
  args[i++] = host;    /* may have to come after user on some systems */
  if (user)
    {
      args[i++] = "-l";
      args[i++] = user;
    }
  if (buffer_len(command) > 0)
    {
      buffer_append(command, "\0", 1);
      args[i++] = buffer_ptr(command);
    }
  args[i++] = NULL;
  if (debug_flag)
    {
      for (i = 0; args[i]; i++)
	{
	  if (i != 0)
	    fprintf(stderr, " ");
	  fprintf(stderr, "%s", args[i]);
	}
      fprintf(stderr, "\n");
    }
  execv(_PATH_RSH, args);
  perror(_PATH_RSH);
  exit(1);
d156 22
a177 82
  int i, opt, optind, type, exit_status, ok, fwd_port, fwd_host_port, authfd;
  char *optarg, *cp, buf[256];
  Buffer command;
  struct winsize ws;
  struct stat st;
  struct passwd *pw, pwcopy;
  int interactive = 0, dummy;
  uid_t original_effective_uid;
  int plen;

  /* Save the original real uid.  It will be needed later (uid-swapping may
     clobber the real uid).  */
  original_real_uid = getuid();
  original_effective_uid = geteuid();

  /* If we are installed setuid root be careful to not drop core. */
  if (original_real_uid != original_effective_uid)
    {
      struct rlimit rlim;
      rlim.rlim_cur = rlim.rlim_max = 0;
      if (setrlimit(RLIMIT_CORE, &rlim) < 0)
	fatal("setrlimit failed: %.100s", strerror(errno));
    }

  /* Use uid-swapping to give up root privileges for the duration of option
     processing.  We will re-instantiate the rights when we are ready to
     create the privileged port, and will permanently drop them when the
     port has been created (actually, when the connection has been made, as
     we may need to create the port several times). */
  temporarily_use_uid(original_real_uid);

  /* Set our umask to something reasonable, as some files are created with 
     the default umask.  This will make them world-readable but writable 
     only by the owner, which is ok for all files for which we don't set
     the modes explicitly. */
  umask(022);
  
  /* Save our own name. */
  av0 = av[0];

  /* Initialize option structure to indicate that no values have been set. */
  initialize_options(&options);

  /* Parse command-line arguments. */
  host = NULL;

  /* If program name is not one of the standard names, use it as host name. */
  if (strchr(av0, '/'))
    cp = strrchr(av0, '/') + 1;
  else
    cp = av0;
  if (strcmp(cp, "rsh") != 0 && strcmp(cp, "ssh") != 0 &&
      strcmp(cp, "rlogin") != 0 && strcmp(cp, "slogin") != 0)
    host = cp;
  
  for (optind = 1; optind < ac; optind++)
    {
      if (av[optind][0] != '-')
	{
	  if (host)
	    break;
          if ((cp = strchr(av[optind], '@@'))) {
            options.user = av[optind];
            *cp = '\0';
            host = ++cp;
          }
          else
	    host = av[optind];
	  continue;
	}
      opt = av[optind][1];
      if (!opt)
	usage();
      if (strchr("eilcpLRo", opt)) /* options with arguments */
	{
	  optarg = av[optind] + 2;
	  if (strcmp(optarg, "") == 0)
	    {
	      if (optind >= ac - 1)
		usage();
	      optarg = av[++optind];
	    }
d179 88
a266 36
      else
	{
	  if (av[optind][2])
	    usage();
	  optarg = NULL;
	}
      switch (opt)
	{
	case 'n':
	  stdin_null_flag = 1;
	  break;

	case 'f':
	  fork_after_authentication_flag = 1;
	  stdin_null_flag = 1;
	  break;

	case 'x':
	  options.forward_x11 = 0;
	  break;

	case 'X':
	  options.forward_x11 = 1;
	  break;

	case 'g':
	  options.gateway_ports = 1;
	  break;

	case 'P':
	  options.use_privileged_port = 0;
	  break;

	case 'a':
	  options.forward_agent = 0;
	  break;
d268 4
a271 4
	case 'k':
	  options.kerberos_tgt_passing = 0;
	  options.afs_token_passing = 0;
	  break;
d273 99
a371 47
	case 'i':
	  if (stat(optarg, &st) < 0)
	    {
	      fprintf(stderr, "Warning: Identity file %s does not exist.\n",
		      optarg);
	      break;
	    }
	  if (options.num_identity_files >= SSH_MAX_IDENTITY_FILES)
	    fatal("Too many identity files specified (max %d)",
		  SSH_MAX_IDENTITY_FILES);
	  options.identity_files[options.num_identity_files++] = 
	    xstrdup(optarg);
	  break;

	case 't':
	  tty_flag = 1;
	  break;

	case 'v':
	case 'V':
	  fprintf(stderr, "SSH Version %s, protocol version %d.%d.\n",
		  SSH_VERSION, PROTOCOL_MAJOR, PROTOCOL_MINOR);
	  fprintf(stderr, "Compiled with SSL.\n");
	  if (opt == 'V')
	    exit(0);
	  debug_flag = 1;
	  options.log_level = SYSLOG_LEVEL_DEBUG;
	  break;

	case 'q':
	  options.log_level = SYSLOG_LEVEL_QUIET;
	  break;

	case 'e':
	  if (optarg[0] == '^' && optarg[2] == 0 &&
	      (unsigned char)optarg[1] >= 64 && (unsigned char)optarg[1] < 128)
	    options.escape_char = (unsigned char)optarg[1] & 31;
	  else
	    if (strlen(optarg) == 1)
	      options.escape_char = (unsigned char)optarg[0];
	    else
	      if (strcmp(optarg, "none") == 0)
		options.escape_char = -2;
	      else
		{
		  fprintf(stderr, "Bad escape character '%s'.\n", optarg);
		  exit(1);
d373 17
a389 1
	  break;
d391 254
a644 353
	case 'c':
	  options.cipher = cipher_number(optarg);
	  if (options.cipher == -1)
	    {
	      fprintf(stderr, "Unknown cipher type '%s'\n", optarg);
	      exit(1);
	    }
	  break;

	case 'p':
	  options.port = atoi(optarg);
	  if (options.port < 1 || options.port > 65535)
	    {
	      fprintf(stderr, "Bad port %s.\n", optarg);
	      exit(1);
	    }
	  break;

	case 'l':
	  options.user = optarg;
	  break;

	case 'R':
	  if (sscanf(optarg, "%d:%255[^:]:%d", &fwd_port, buf, 
		     &fwd_host_port) != 3)
	    {
	      fprintf(stderr, "Bad forwarding specification '%s'.\n", optarg);
	      usage();
	      /*NOTREACHED*/
	    }
	  add_remote_forward(&options, fwd_port, buf, fwd_host_port);
	  break;

	case 'L':
	  if (sscanf(optarg, "%d:%255[^:]:%d", &fwd_port, buf, 
		     &fwd_host_port) != 3)
	    {
	      fprintf(stderr, "Bad forwarding specification '%s'.\n", optarg);
	      usage();
	      /*NOTREACHED*/
	    }
	  add_local_forward(&options, fwd_port, buf, fwd_host_port);
	  break;

	case 'C':
	  options.compression = 1;
	  break;

	case 'o':
	  dummy = 1;
	  if (process_config_line(&options, host ? host : "", optarg,
			          "command-line", 0, &dummy) != 0)
            exit(1);
	  break;

	default:
	  usage();
	}
    }

 /* Check that we got a host name. */
  if (!host)
    usage();

  /* check if RSA support exists */
  if (rsa_alive() == 0) {
    extern char *__progname;

    fprintf(stderr,
      "%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
      __progname);
    exit(1);
  }

  /* Initialize the command to execute on remote host. */
  buffer_init(&command);

  /* Save the command to execute on the remote host in a buffer.  There is
     no limit on the length of the command, except by the maximum packet
     size.  Also sets the tty flag if there is no command. */
  if (optind == ac)
    {
      /* No command specified - execute shell on a tty. */
      tty_flag = 1;
    }
  else
    {
      /* A command has been specified.  Store it into the buffer. */
      for (i = optind; i < ac; i++)
	{
	  if (i > optind)
	    buffer_append(&command, " ", 1);
	  buffer_append(&command, av[i], strlen(av[i]));
	}
    }

  /* Cannot fork to background if no command. */
  if (fork_after_authentication_flag && buffer_len(&command) == 0)
    fatal("Cannot fork into background without a command to execute.");
  
  /* Allocate a tty by default if no command specified. */
  if (buffer_len(&command) == 0)
    tty_flag = 1;

  /* Do not allocate a tty if stdin is not a tty. */
  if (!isatty(fileno(stdin)))
    {
      if (tty_flag)
	fprintf(stderr, "Pseudo-terminal will not be allocated because stdin is not a terminal.\n");
      tty_flag = 0;
    }

  /* Get user data. */
  pw = getpwuid(original_real_uid);
  if (!pw)
    {
      fprintf(stderr, "You don't exist, go away!\n");
      exit(1);
    }
  
  /* Take a copy of the returned structure. */
  memset(&pwcopy, 0, sizeof(pwcopy));
  pwcopy.pw_name = xstrdup(pw->pw_name);
  pwcopy.pw_passwd = xstrdup(pw->pw_passwd);
  pwcopy.pw_uid = pw->pw_uid;
  pwcopy.pw_gid = pw->pw_gid;
  pwcopy.pw_dir = xstrdup(pw->pw_dir);
  pwcopy.pw_shell = xstrdup(pw->pw_shell);
  pw = &pwcopy;

  /* Initialize "log" output.  Since we are the client all output actually
     goes to the terminal. */
  log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 0);

  /* Read per-user configuration file. */
  snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, SSH_USER_CONFFILE);
  read_config_file(buf, host, &options);

  /* Read systemwide configuration file. */
  read_config_file(HOST_CONFIG_FILE, host, &options);

  /* Fill configuration defaults. */
  fill_default_options(&options);

  /* reinit */
  log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 0);

  if (options.user == NULL)
    options.user = xstrdup(pw->pw_name);

  if (options.hostname != NULL)
    host = options.hostname;

  /* Find canonic host name. */
  if (strchr(host, '.') == 0)
    {
      struct hostent *hp = gethostbyname(host);
      if (hp != 0)
	{
	  if (strchr(hp->h_name, '.') != 0)
	    host = xstrdup(hp->h_name);
	  else if (hp->h_aliases != 0
		   && hp->h_aliases[0] != 0
		   && strchr(hp->h_aliases[0], '.') != 0)
	    host = xstrdup(hp->h_aliases[0]);
	}
    }

  /* Disable rhosts authentication if not running as root. */
  if (original_effective_uid != 0 || !options.use_privileged_port)
    {
      options.rhosts_authentication = 0;
      options.rhosts_rsa_authentication = 0;
    }

  /* If using rsh has been selected, exec it now (without trying anything
     else).  Note that we must release privileges first. */
  if (options.use_rsh)
    {
      /* Restore our superuser privileges.  This must be done before
         permanently setting the uid. */
      restore_uid();

      /* Switch to the original uid permanently. */
      permanently_set_uid(original_real_uid);

      /* Execute rsh. */
      rsh_connect(host, options.user, &command);
      fatal("rsh_connect returned");
    }

  /* Restore our superuser privileges. */
  restore_uid();

  /* Open a connection to the remote host.  This needs root privileges if
     rhosts_{rsa_}authentication is enabled. */

  ok = ssh_connect(host, &hostaddr, options.port, options.connection_attempts,
		   !options.rhosts_authentication &&
		   !options.rhosts_rsa_authentication,
		   original_real_uid, options.proxy_command);

  /* If we successfully made the connection, load the host private key in
     case we will need it later for combined rsa-rhosts authentication. 
     This must be done before releasing extra privileges, because the file
     is only readable by root. */
  if (ok)
    {
      host_private_key = RSA_new();
      if (load_private_key(HOST_KEY_FILE, "", host_private_key, NULL))
	host_private_key_loaded = 1;
    }

  /* Get rid of any extra privileges that we may have.  We will no longer need
     them.  Also, extra privileges could make it very hard to read identity
     files and other non-world-readable files from the user's home directory
     if it happens to be on a NFS volume where root is mapped to nobody. */

  /* Note that some legacy systems need to postpone the following call to
     permanently_set_uid() until the private hostkey is destroyed with
     RSA_free().  Otherwise the calling user could ptrace() the process,
     read the private hostkey and impersonate the host.  OpenBSD does not
     allow ptracing of setuid processes. */

  permanently_set_uid(original_real_uid);

  /* Now that we are back to our own permissions, create ~/.ssh directory
     if it doesn\'t already exist. */
  snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir, SSH_USER_DIR);
  if (stat(buf, &st) < 0)
    if (mkdir(buf, 0755) < 0)
      error("Could not create directory '%.200s'.", buf);

  /* Check if the connection failed, and try "rsh" if appropriate. */
  if (!ok)
    {
      if (options.port != 0)
	log("Secure connection to %.100s on port %d refused%.100s.", 
	    host, options.port,
	    options.fallback_to_rsh ? "; reverting to insecure method" : "");
      else
	log("Secure connection to %.100s refused%.100s.", host,
	    options.fallback_to_rsh ? "; reverting to insecure method" : "");

      if (options.fallback_to_rsh)
	{
	  rsh_connect(host, options.user, &command);
	  fatal("rsh_connect returned");
	}
      exit(1);
    }

  /* Expand ~ in options.identity_files. */
  for (i = 0; i < options.num_identity_files; i++)
    options.identity_files[i] = 
      tilde_expand_filename(options.identity_files[i], original_real_uid);

  /* Expand ~ in known host file names. */
  options.system_hostfile = tilde_expand_filename(options.system_hostfile,
						  original_real_uid);
  options.user_hostfile = tilde_expand_filename(options.user_hostfile,
						original_real_uid);

  /* Log into the remote system.  This never returns if the login fails. */
  ssh_login(host_private_key_loaded, host_private_key, 
	    host, &hostaddr, original_real_uid);

  /* We no longer need the host private key.  Clear it now. */
  if (host_private_key_loaded)
    RSA_free(host_private_key); /* Destroys contents safely */

  /* Close connection cleanly after attack. */
  cipher_attack_detected = packet_disconnect;

  /* If requested, fork and let ssh continue in the background. */
  if (fork_after_authentication_flag)
    {
      int ret = fork();
      if (ret == -1)
	fatal("fork failed: %.100s", strerror(errno));
      if (ret != 0)
	exit(0);
      setsid();
    }

  /* Enable compression if requested. */
  if (options.compression)
    {
      debug("Requesting compression at level %d.", options.compression_level);

      if (options.compression_level < 1 || options.compression_level > 9)
	fatal("Compression level must be from 1 (fast) to 9 (slow, best).");

      /* Send the request. */
      packet_start(SSH_CMSG_REQUEST_COMPRESSION);
      packet_put_int(options.compression_level);
      packet_send();
      packet_write_wait();
      type = packet_read(&plen);
      if (type == SSH_SMSG_SUCCESS)
	packet_start_compression(options.compression_level);
      else if (type == SSH_SMSG_FAILURE)
	log("Warning: Remote host refused compression.");
      else
	packet_disconnect("Protocol error waiting for compression response.");
    }

  /* Allocate a pseudo tty if appropriate. */
  if (tty_flag)
    {
      debug("Requesting pty.");

      /* Start the packet. */
      packet_start(SSH_CMSG_REQUEST_PTY);

      /* Store TERM in the packet.  There is no limit on the length of the
         string. */
      cp = getenv("TERM");
      if (!cp)
	cp = "";
      packet_put_string(cp, strlen(cp));

      /* Store window size in the packet. */
      if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
	memset(&ws, 0, sizeof(ws));
      packet_put_int(ws.ws_row);
      packet_put_int(ws.ws_col);
      packet_put_int(ws.ws_xpixel);
      packet_put_int(ws.ws_ypixel);
      
      /* Store tty modes in the packet. */
      tty_make_modes(fileno(stdin));

      /* Send the packet, and wait for it to leave. */
      packet_send();
      packet_write_wait();

      /* Read response from the server. */
      type = packet_read(&plen);
      if (type == SSH_SMSG_SUCCESS)
	interactive = 1;
      else if (type == SSH_SMSG_FAILURE)
	log("Warning: Remote host failed or refused to allocate a pseudo tty.");
      else
	packet_disconnect("Protocol error waiting for pty request response.");
    }

  /* Request X11 forwarding if enabled and DISPLAY is set. */
  if (options.forward_x11 && getenv("DISPLAY") != NULL)
    {
      char line[512], proto[512], data[512];
      FILE *f;
      int forwarded = 0, got_data = 0, i;
d647 9
a655 9
      /* Try to get Xauthority information for the display. */
      snprintf(line, sizeof line, "%.100s list %.200s 2>/dev/null", 
	      XAUTH_PATH, getenv("DISPLAY"));
      f = popen(line, "r");
      if (f && fgets(line, sizeof(line), f) && 
	  sscanf(line, "%*s %s %s", proto, data) == 2)
	got_data = 1;
      if (f)
	pclose(f);
d657 101
a757 110
      /* If we didn't get authentication data, just make up some data.  The
	 forwarding code will check the validity of the response anyway, and
	 substitute this data.  The X11 server, however, will ignore this
	 fake data and use whatever authentication mechanisms it was using
	 otherwise for the local connection. */
      if (!got_data)
	{
          u_int32_t rand = 0;

	  strlcpy(proto, "MIT-MAGIC-COOKIE-1", sizeof proto);
          for (i = 0; i < 16; i++) {
            if (i % 4 == 0)
              rand = arc4random();
            snprintf(data + 2 * i, sizeof data - 2 * i, "%02x", rand & 0xff);
            rand >>= 8;
          }
	}

      /* Got local authentication reasonable information.  Request forwarding
	 with authentication spoofing. */
      debug("Requesting X11 forwarding with authentication spoofing.");
      x11_request_forwarding_with_spoofing(proto, data);

      /* Read response from the server. */
      type = packet_read(&plen);
      if (type == SSH_SMSG_SUCCESS)
	{
	  forwarded = 1;
	  interactive = 1;
	}
      else if (type == SSH_SMSG_FAILURE)
	log("Warning: Remote host denied X11 forwarding.");
      else
	packet_disconnect("Protocol error waiting for X11 forwarding");
    }

  /* Tell the packet module whether this is an interactive session. */
  packet_set_interactive(interactive, options.keepalives);

  /* Clear agent forwarding if we don\'t have an agent. */
  authfd = ssh_get_authentication_socket();
  if (authfd < 0)
    options.forward_agent = 0;
  else
    ssh_close_authentication_socket(authfd);

  /* Request authentication agent forwarding if appropriate. */
  if (options.forward_agent)
    {
      debug("Requesting authentication agent forwarding.");
      auth_request_forwarding();
      
      /* Read response from the server. */
      type = packet_read(&plen);
      packet_integrity_check(plen, 0, type);
      if (type != SSH_SMSG_SUCCESS)
	log("Warning: Remote host denied authentication agent forwarding.");
    }

  /* Initiate local TCP/IP port forwardings. */
  for (i = 0; i < options.num_local_forwards; i++)
    {
      debug("Connections to local port %d forwarded to remote address %.200s:%d",
	    options.local_forwards[i].port, options.local_forwards[i].host, 
	    options.local_forwards[i].host_port);
      channel_request_local_forwarding(options.local_forwards[i].port,
				       options.local_forwards[i].host,
				       options.local_forwards[i].host_port);
    }

  /* Initiate remote TCP/IP port forwardings. */
  for (i = 0; i < options.num_remote_forwards; i++)
    {
      debug("Connections to remote port %d forwarded to local address %.200s:%d",
	    options.remote_forwards[i].port, options.remote_forwards[i].host, 
	    options.remote_forwards[i].host_port);
      channel_request_remote_forwarding(options.remote_forwards[i].port,
					options.remote_forwards[i].host,
					options.remote_forwards[i].host_port);
    }

  /* If a command was specified on the command line, execute the command now.
     Otherwise request the server to start a shell. */
  if (buffer_len(&command) > 0)
    {
      int len = buffer_len(&command);
      if (len > 900)
	len = 900;
      debug("Sending command: %.*s", len, buffer_ptr(&command));
      packet_start(SSH_CMSG_EXEC_CMD);
      packet_put_string(buffer_ptr(&command), buffer_len(&command));
      packet_send();
      packet_write_wait();
    }
  else
    {
      debug("Requesting shell.");
      packet_start(SSH_CMSG_EXEC_SHELL);
      packet_send();
      packet_write_wait();
    }

  /* Enter the interactive session. */
  exit_status = client_loop(tty_flag, tty_flag ? options.escape_char : -1);

  /* Close the connection to the remote host. */
  packet_close();
  
  /* Exit with the status returned by the program on the remote side. */
  exit(exit_status);
@


1.29
log
@print _all_ bad config-options in ssh(1), too
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.28 1999/11/11 23:36:53 markus Exp $");
d553 7
@


1.28
log
@make all access to options via 'extern Options options'
and 'extern ServerOptions options' respectively;
options are no longer passed as arguments:
 * make options handling more consistent
 * remove #include "readconf.h" from ssh.h
 * readconf.h is only included if necessary
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.27 1999/11/10 23:36:44 markus Exp $");
d386 3
a388 2
	  process_config_line(&options, host ? host : "", optarg,
			      "command-line", 0, &dummy);
@


1.27
log
@add LogLevel {QUIET, FATAL, ERROR, INFO, CHAT, DEBUG} to ssh/sshd,
obsoletes QuietMode and FascistLogging in sshd.
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.26 1999/10/28 21:29:26 markus Exp $");
d593 1
a593 1
	    host, &hostaddr, &options, original_real_uid);
@


1.26
log
@save a few lines when disabling rhosts-{rsa-}auth
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.25 1999/10/26 22:38:51 markus Exp $");
a34 3
/* Flag indicating whether quiet mode is on. */
int quiet_flag = 0;

a305 1
	  debug_flag = 1;
d311 2
d316 1
a316 1
	  quiet_flag = 1;
d467 1
a467 1
  log_init(av[0], 1, debug_flag, quiet_flag, SYSLOG_FACILITY_USER);
d478 4
@


1.25
log
@don't define original_real_uid twice
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.24 1999/10/14 18:17:42 markus Exp $");
d502 1
a502 1
  if (original_effective_uid != 0)
d528 1
a528 7
     rhosts_{rsa_}authentication is true. */

  if (!options.use_privileged_port)
    {
       options.rhosts_authentication = 0;
       options.rhosts_rsa_authentication = 0;
    }
@


1.24
log
@fix old connect() race security-bug for ssh-agent and agent-forwarding
by removing the connect() junk, with the following restrictions:
1) change the version to "OpenSSH-1.1":
   agent-forwarding will work only between OpenSSH-1.1 client and
   OpenSSH-1.1 server
2) renamed the environment variable of OpenSSH-1.1 to
   "SSH_AUTH_SOCKET", since useing OpenSSH-1.0 ssh-add against the new
   ssh-agent does not work
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.23 1999/10/12 21:04:22 markus Exp $");
a159 2

uid_t original_real_uid;
@


1.23
log
@-P/UsePrivilegedPort from 1.2.27, it turns of allocation of priv. port
and disabled rhosts/rhosts-rsa, ok deraadt@@
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.22 1999/10/03 21:50:04 provos Exp $");
d739 1
a739 1
  authfd = ssh_get_authentication_fd();
@


1.22
log
@add code to detect DNS spoofing:

the main idea is to not only store the host key for the hostname but
also for the according IP address.  When we check the host key in the
known_hosts file, we also check the key against the according IP address.
When the server key changes, host_status = HOST_CHANGED.  If
check_host_in_hostfile() returns differing status for the IP address
that means that either DNS was spoofed or that the IP address
for the host and the host key changed at the same time.
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.21 1999/09/30 20:39:08 deraadt Exp $");
d100 1
d278 4
d530 8
a537 1
     rhosts_authentication is true. */
@


1.21
log
@reorder usage, like real ssh
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.20 1999/09/30 18:28:36 provos Exp $");
d61 3
d526 1
a526 1
  ok = ssh_connect(host, options.port, options.connection_attempts,
d587 1
a587 1
	    host, &options, original_real_uid);
@


1.20
log
@better way to deal with authfile cipher; dugsong@@
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.19 1999/09/30 14:05:41 provos Exp $");
a104 1
  fprintf(stderr, "  -g          Allow remote hosts to connect to forwarded ports.\n");
d110 1
@


1.19
log
@remove ``none''.
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.18 1999/09/30 05:53:04 deraadt Exp $");
a83 2
  int i;
  
@


1.18
log
@"ssh is a very large program" -- anonymous
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.17 1999/09/30 05:43:33 deraadt Exp $");
d103 3
a105 10
  fprintf(stderr, "  -c cipher   Select encryption algorithm: ");
  for (i = 1; i <= 6; i++)
    {
      const char *t = cipher_name(i);
      if (t[0] == 'n' && t[1] == 'o' && t[2] == ' ')
	continue;
      fprintf(stderr, "%s, ", t);
    }
  fprintf(stderr, "or none.\n");

@


1.17
log
@wringing out all the water
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.16 1999/09/30 05:11:29 deraadt Exp $");
a60 1
#ifdef SIGWINCH
a65 1
#endif /* SIGWINCH */
@


1.16
log
@do not bother with dinosaur pacification
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.15 1999/09/30 05:03:05 deraadt Exp $");
a190 1
#ifdef HAVE_SETRLIMIT
a194 3
#else
      fatal("ssh is installed setuid root.\n");
#endif
@


1.15
log
@cull more ancient garbage from pre-POSIX days
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.14 1999/09/30 04:30:03 deraadt Exp $");
a207 1
#ifdef HAVE_UMASK
a212 1
#endif /* HAVE_UMASK */
@


1.14
log
@more culling
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.13 1999/09/30 04:10:28 deraadt Exp $");
a120 1
#ifdef WITH_ZLIB
a121 1
#endif /* WITH_ZLIB */
a392 1
#ifdef WITH_ZLIB
a395 1
#endif /* WITH_ZLIB */
a620 1
#ifdef WITH_ZLIB
a641 1
#endif /* WITH_ZLIB */
@


1.13
log
@rely on paths.h more
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.12 1999/09/29 21:15:54 deraadt Exp $");
a219 5

#ifdef SOCKS
  /* Initialize SOCKS (the firewall traversal library). */
  SOCKSinit(av0);
#endif /* SOCKS */
@


1.12
log
@we have setsid
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.11 1999/09/29 21:14:16 deraadt Exp $");
a133 1
#ifdef RSH_PATH
d140 1
a140 1
  args[i++] = RSH_PATH;
d163 2
a164 2
  execv(RSH_PATH, args);
  perror(RSH_PATH);
a165 3
#else /* RSH_PATH */
  fatal("Rsh not available.");
#endif /* RSH_PATH */
@


1.11
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.10 1999/09/29 18:27:23 dugsong Exp $");
a630 1
#ifdef HAVE_SETSID
a631 1
#endif /* HAVE_SETSID */
@


1.10
log
@global original_real_uid
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.9 1999/09/29 18:16:20 dugsong Exp $");
d174 2
a400 6
	  if (fwd_port < 1024 && original_real_uid != 0)
	    {
	      fprintf(stderr, 
		      "Privileged ports can only be forwarded by root.\n");
	      exit(1);
	    }
d496 1
a496 1
  sprintf(buf, "%.100s/%.100s", pw->pw_dir, SSH_USER_CONFFILE);
d577 1
a577 1
  sprintf(buf, "%.100s/%.100s", pw->pw_dir, SSH_USER_DIR);
d709 1
a709 1
      sprintf(line, "%.100s list %.200s 2>/dev/null", 
d727 1
a727 1
	  strcpy(proto, "MIT-MAGIC-COOKIE-1");
d731 1
a731 1
            sprintf(data + 2 * i, "%02x", rand & 0xff);
@


1.9
log
@update krb4/AFS support to ssh-1.2.27-afs-kerberos-pl1 level, clean up unused variables, update manpages
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.8 1999/09/29 12:16:35 provos Exp $");
d78 2
a183 1
  static uid_t original_real_uid;
@


1.8
log
@-V in usage()
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.7 1999/09/29 11:45:50 provos Exp $");
d91 3
a93 3
#if defined(KERBEROS_TGT_PASSING) || defined(AFS)
  fprintf(stderr, "              This also disables passing of AFS tokens/Kerberos tickets.\n");
#endif /* KERBEROS_TGT_PASSING || AFS */
d182 1
a182 1
  uid_t original_real_uid;
d301 3
a303 1
#ifdef KERBEROS_TGT_PASSING
a304 2
#endif
#ifdef AFS
d306 1
a307 2
	  break;

d728 1
a728 1
          u_int32_t rand;
@


1.7
log
@correct the usage, disable agent forwarding is -a
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.6 1999/09/29 06:15:18 deraadt Exp $");
d98 1
@


1.6
log
@add -V option
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.4 1999/09/29 00:10:16 deraadt Exp $");
d90 1
a90 1
  fprintf(stderr, "  -k          Disable authentication agent forwarding.\n");
@


1.5
log
@test for RSA in the ssl library, real early on
@
text
@d327 1
d332 2
@


1.4
log
@GatewayPorts and ssh -g; markus.friedl@@informatik.uni-erlangen.de
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.3 1999/09/28 07:57:42 deraadt Exp $");
d424 10
@


1.3
log
@user@@host; aaron
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.2 1999/09/28 04:45:37 provos Exp $");
d113 1
d292 4
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d21 1
a21 1
RCSID("$Id: ssh.c,v 1.13 1999/05/11 19:27:16 bg Exp $");
d246 7
a252 1
	  host = av[optind];
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@d16 2
a23 1
#include "randoms.h"
a30 5
/* Random number generator state.  This is initialized in ssh_login, and
   left initialized.  This is used both by the packet module and by various
   other functions. */
RandomState random_state;

d76 1
a76 1
RSAPrivateKey host_private_key;
d81 2
a82 1
void usage()
d127 2
a128 1
void rsh_connect(char *host, char *user, Buffer *command)
d170 2
a171 1
int main(int ac, char **av)
a224 3
  /* Set RSA (actually gmp) memory allocation functions. */
  rsa_set_mp_memory_allocation();

a318 3
#ifdef RSAREF
	  fprintf(stderr, "Compiled with RSAREF.\n");
#elif defined(DO_SSL)
a319 3
#else  /* RSAREF */
	  fprintf(stderr, "Standard version.  Does not use RSAREF.\n");
#endif /* RSAREF */
d531 1
a531 3
     rhosts_authentication is true.  Note that the random_state is not
     yet used by this call, although a pointer to it is stored, and thus it
     need not be initialized. */
d535 1
a535 1
		   original_real_uid, options.proxy_command, &random_state);
d543 2
a544 1
      if (load_private_key(HOST_KEY_FILE, "", &host_private_key, NULL))
d591 2
a592 3
  /* Log into the remote system.  This never returns if the login fails. 
     Note: this initializes the random state, and leaves it initialized. */
  ssh_login(&random_state, host_private_key_loaded, &host_private_key, 
d597 1
a597 1
    rsa_clear_private_key(&host_private_key);
d704 2
d707 6
a712 2
	  for (i = 0; i < 16; i++)
	    sprintf(data + 2 * i, "%02x", random_get_byte(&random_state));
d718 1
a718 1
      x11_request_forwarding_with_spoofing(&random_state, proto, data);
@

