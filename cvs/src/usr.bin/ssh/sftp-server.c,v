head	1.110;
access;
symbols
	OPENBSD_6_0:1.109.0.6
	OPENBSD_6_0_BASE:1.109
	OPENBSD_5_9:1.109.0.2
	OPENBSD_5_9_BASE:1.109
	OPENBSD_5_8:1.106.0.2
	OPENBSD_5_8_BASE:1.106
	OPENBSD_5_7:1.105.0.2
	OPENBSD_5_7_BASE:1.105
	OPENBSD_5_6:1.103.0.6
	OPENBSD_5_6_BASE:1.103
	OPENBSD_5_5:1.103.0.4
	OPENBSD_5_5_BASE:1.103
	OPENBSD_5_4:1.97.0.2
	OPENBSD_5_4_BASE:1.97
	OPENBSD_5_3:1.96.0.2
	OPENBSD_5_3_BASE:1.96
	OPENBSD_5_2:1.94.0.6
	OPENBSD_5_2_BASE:1.94
	OPENBSD_5_1_BASE:1.94
	OPENBSD_5_1:1.94.0.4
	OPENBSD_5_0:1.94.0.2
	OPENBSD_5_0_BASE:1.94
	OPENBSD_4_9:1.93.0.2
	OPENBSD_4_9_BASE:1.93
	OPENBSD_4_8:1.91.0.4
	OPENBSD_4_8_BASE:1.91
	OPENBSD_4_7:1.91.0.2
	OPENBSD_4_7_BASE:1.91
	OPENBSD_4_6:1.85.0.4
	OPENBSD_4_6_BASE:1.85
	OPENBSD_4_5:1.84.0.4
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.84.0.2
	OPENBSD_4_4_BASE:1.84
	OPENBSD_4_3:1.78.0.2
	OPENBSD_4_3_BASE:1.78
	OPENBSD_4_2:1.73.0.2
	OPENBSD_4_2_BASE:1.73
	OPENBSD_4_1:1.71.0.2
	OPENBSD_4_1_BASE:1.71
	OPENBSD_4_0:1.70.0.4
	OPENBSD_4_0_BASE:1.70
	OPENBSD_3_9:1.52.0.2
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.47.0.4
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.47.0.2
	OPENBSD_3_6_BASE:1.47
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	OPENBSD_3_3:1.41.0.2
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.110
date	2016.09.12.01.22.38;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	ZllbGwdb0fOmLhjK;

1.109
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.108;
commitid	ut5A0buLh4mhCTFu;

1.108
date	2015.11.16.06.13.04;	author logan;	state Exp;
branches;
next	1.107;
commitid	JePCAxQ9TOAzpLyd;

1.107
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	0Dp7Dy9FuNZesYo2;

1.106
date	2015.04.24.01.36.01;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	LHkUmZjv49ojnnuH;

1.105
date	2015.01.20.23.14.00;	author deraadt;	state Exp;
branches;
next	1.104;
commitid	cBx23BaCk6gYBpRj;

1.104
date	2015.01.14.13.54.13;	author djm;	state Exp;
branches;
next	1.103;
commitid	5mVYZPiIJUHzgjMn;

1.103
date	2014.01.17.06.23.24;	author dtucker;	state Exp;
branches;
next	1.102;

1.102
date	2013.10.17.00.30.13;	author djm;	state Exp;
branches;
next	1.101;

1.101
date	2013.10.14.23.28.23;	author djm;	state Exp;
branches;
next	1.100;

1.100
date	2013.10.14.14.18.56;	author jmc;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.10.00.53.25;	author djm;	state Exp;
branches;
next	1.98;

1.98
date	2013.10.09.23.42.17;	author djm;	state Exp;
branches;
next	1.97;

1.97
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.96;

1.96
date	2013.01.04.19.26.38;	author jmc;	state Exp;
branches;
next	1.95;

1.95
date	2013.01.03.12.54.49;	author djm;	state Exp;
branches;
next	1.94;

1.94
date	2011.06.17.21.46.16;	author djm;	state Exp;
branches;
next	1.93;

1.93
date	2010.12.04.00.18.01;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2010.11.04.02.45.34;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2010.01.13.01.40.16;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2010.01.09.00.20.26;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2010.01.04.02.25.15;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2009.10.17.12.10.39;	author sobrado;	state Exp;
branches;
next	1.87;

1.87
date	2009.08.31.20.56.02;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2009.08.27.17.28.52;	author djm;	state Exp;
branches;
next	1.85;

1.85
date	2009.04.14.16.33.42;	author stevesk;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.26.06.10.09;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.09.13.02.39;	author dtucker;	state Exp;
branches;
next	1.82;

1.82
date	2008.06.08.17.04.41;	author dtucker;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.07.21.52.46;	author djm;	state Exp;
branches;
next	1.80;

1.80
date	2008.05.18.21.29.05;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2008.04.18.12.32.11;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2008.02.27.20.21.15;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2008.02.08.23.24.07;	author djm;	state Exp;
branches;
next	1.76;

1.76
date	2008.02.04.21.53.00;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2008.01.21.17.24.30;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2007.09.13.04.39.04;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.17.07.55.29;	author djm;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.18.01.12.43;	author stevesk;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.03.07.22.36;	author stevesk;	state Exp;
branches;
next	1.70;

1.70
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.25.02.59.21;	author stevesk;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.64;

1.64
date	2006.07.22.19.08.54;	author stevesk;	state Exp;
branches;
next	1.63;

1.63
date	2006.07.17.01.31.09;	author stevesk;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.10.11.25.53;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2006.07.10.11.24.54;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.58;

1.58
date	2006.07.06.10.47.57;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.30.09.58.16;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2006.03.25.01.13.23;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.25.00.05.41;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2006.02.08.23.51.24;	author stevesk;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.02.01.20.31;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.17.02.44.33;	author djm;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2004.06.25.05.38.48;	author dtucker;	state Exp;
branches
	1.47.2.1
	1.47.4.1;
next	1.46;

1.46
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.19.21.15.04;	author markus;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2003.11.10.16.23.41;	author jakob;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.25.22.39.36;	author miod;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.26.04.02.51;	author deraadt;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2003.03.05.22.33.43;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.06.09.29.18;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.11.22.41.50;	author djm;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2002.06.24.17.57.20;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.23.09.30.14;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.06.17.30.11;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.06.17.12.44;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.13.00.28.13;	author markus;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2001.12.29.21.56.01;	author stevesk;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.31.12.42.50;	author jakob;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.06.25.08.25.40;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.22.22.21.20;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.12.19.53.13;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.05.10.42.53;	author markus;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.03.14.22.50.25;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.07.10.11.23;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.03.22.07.50;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.03.21.40.30;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.21.09.12.56;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.07.18.01.18;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.04.22.21.19;	author stevesk;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.04.15.32.25;	author stevesk;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.04.15.23.08;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.04.11.11.54;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.21.19.05.56;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.16.20.54.27;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.15.21.46.38;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.15.21.45.29;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.10.22.56.22;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.19.22.43.44;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.09.14.08.27;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.07.20.27.53;	author deraadt;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;

1.5
date	2000.09.05.19.20.49;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.04.19.10.08;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.01.22.32.41;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.01.22.29.32;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.31.21.52.23;	author markus;	state Exp;
branches;
next	;

1.6.2.1
date	2001.02.16.20.13.15;	author jason;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.02.19.17.19.24;	author jason;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.03.21.19.46.29;	author jason;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.05.07.21.09.34;	author jason;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.6.4.1
date	2000.11.08.21.31.18;	author jason;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.03.12.15.44.15;	author jason;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.03.21.18.53.06;	author jason;	state Exp;
branches;
next	;

1.25.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	;

1.30.2.1
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.06.22.07.23.17;	author miod;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2002.10.11.14.53.07;	author miod;	state Exp;
branches;
next	;

1.33.2.1
date	2002.06.26.15.30.38;	author jason;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2002.10.11.14.51.52;	author miod;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.38.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2003.04.03.23.27.12;	author margarida;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2003.09.16.21.20.27;	author brad;	state Exp;
branches;
next	;

1.41.2.1
date	2003.09.16.20.50.43;	author brad;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.43.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.45.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	;

1.47.2.1
date	2005.09.02.03.45.00;	author brad;	state Exp;
branches;
next	;

1.47.4.1
date	2005.09.04.18.40.04;	author brad;	state Exp;
branches;
next	1.47.4.2;

1.47.4.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.48.2.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	;

1.52.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	;


desc
@@


1.110
log
@Add MAXIMUM(), MINIMUM(), and ROUNDUP() to misc.h, then use those definitions
rather than pulling <sys/param.h> and unknown namespace pollution.
ok djm markus dtucker
@
text
@/* $OpenBSD: sftp-server.c,v 1.109 2016/02/15 09:47:49 dtucker Exp $ */
/*
 * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/mount.h>
#include <sys/statvfs.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>
#include <time.h>
#include <unistd.h>
#include <stdarg.h>

#include "xmalloc.h"
#include "sshbuf.h"
#include "ssherr.h"
#include "log.h"
#include "misc.h"
#include "match.h"
#include "uidswap.h"

#include "sftp.h"
#include "sftp-common.h"

/* Our verbosity */
static LogLevel log_level = SYSLOG_LEVEL_ERROR;

/* Our client */
static struct passwd *pw = NULL;
static char *client_addr = NULL;

/* input and output queue */
struct sshbuf *iqueue;
struct sshbuf *oqueue;

/* Version of client */
static u_int version;

/* SSH2_FXP_INIT received */
static int init_done;

/* Disable writes */
static int readonly;

/* Requests that are allowed/denied */
static char *request_whitelist, *request_blacklist;

/* portable attributes, etc. */
typedef struct Stat Stat;

struct Stat {
	char *name;
	char *long_name;
	Attrib attrib;
};

/* Packet handlers */
static void process_open(u_int32_t id);
static void process_close(u_int32_t id);
static void process_read(u_int32_t id);
static void process_write(u_int32_t id);
static void process_stat(u_int32_t id);
static void process_lstat(u_int32_t id);
static void process_fstat(u_int32_t id);
static void process_setstat(u_int32_t id);
static void process_fsetstat(u_int32_t id);
static void process_opendir(u_int32_t id);
static void process_readdir(u_int32_t id);
static void process_remove(u_int32_t id);
static void process_mkdir(u_int32_t id);
static void process_rmdir(u_int32_t id);
static void process_realpath(u_int32_t id);
static void process_rename(u_int32_t id);
static void process_readlink(u_int32_t id);
static void process_symlink(u_int32_t id);
static void process_extended_posix_rename(u_int32_t id);
static void process_extended_statvfs(u_int32_t id);
static void process_extended_fstatvfs(u_int32_t id);
static void process_extended_hardlink(u_int32_t id);
static void process_extended_fsync(u_int32_t id);
static void process_extended(u_int32_t id);

struct sftp_handler {
	const char *name;	/* user-visible name for fine-grained perms */
	const char *ext_name;	/* extended request name */
	u_int type;		/* packet type, for non extended packets */
	void (*handler)(u_int32_t);
	int does_write;		/* if nonzero, banned for readonly mode */
};

struct sftp_handler handlers[] = {
	/* NB. SSH2_FXP_OPEN does the readonly check in the handler itself */
	{ "open", NULL, SSH2_FXP_OPEN, process_open, 0 },
	{ "close", NULL, SSH2_FXP_CLOSE, process_close, 0 },
	{ "read", NULL, SSH2_FXP_READ, process_read, 0 },
	{ "write", NULL, SSH2_FXP_WRITE, process_write, 1 },
	{ "lstat", NULL, SSH2_FXP_LSTAT, process_lstat, 0 },
	{ "fstat", NULL, SSH2_FXP_FSTAT, process_fstat, 0 },
	{ "setstat", NULL, SSH2_FXP_SETSTAT, process_setstat, 1 },
	{ "fsetstat", NULL, SSH2_FXP_FSETSTAT, process_fsetstat, 1 },
	{ "opendir", NULL, SSH2_FXP_OPENDIR, process_opendir, 0 },
	{ "readdir", NULL, SSH2_FXP_READDIR, process_readdir, 0 },
	{ "remove", NULL, SSH2_FXP_REMOVE, process_remove, 1 },
	{ "mkdir", NULL, SSH2_FXP_MKDIR, process_mkdir, 1 },
	{ "rmdir", NULL, SSH2_FXP_RMDIR, process_rmdir, 1 },
	{ "realpath", NULL, SSH2_FXP_REALPATH, process_realpath, 0 },
	{ "stat", NULL, SSH2_FXP_STAT, process_stat, 0 },
	{ "rename", NULL, SSH2_FXP_RENAME, process_rename, 1 },
	{ "readlink", NULL, SSH2_FXP_READLINK, process_readlink, 0 },
	{ "symlink", NULL, SSH2_FXP_SYMLINK, process_symlink, 1 },
	{ NULL, NULL, 0, NULL, 0 }
};

/* SSH2_FXP_EXTENDED submessages */
struct sftp_handler extended_handlers[] = {
	{ "posix-rename", "posix-rename@@openssh.com", 0,
	   process_extended_posix_rename, 1 },
	{ "statvfs", "statvfs@@openssh.com", 0, process_extended_statvfs, 0 },
	{ "fstatvfs", "fstatvfs@@openssh.com", 0, process_extended_fstatvfs, 0 },
	{ "hardlink", "hardlink@@openssh.com", 0, process_extended_hardlink, 1 },
	{ "fsync", "fsync@@openssh.com", 0, process_extended_fsync, 1 },
	{ NULL, NULL, 0, NULL, 0 }
};

static int
request_permitted(struct sftp_handler *h)
{
	char *result;

	if (readonly && h->does_write) {
		verbose("Refusing %s request in read-only mode", h->name);
		return 0;
	}
	if (request_blacklist != NULL &&
	    ((result = match_list(h->name, request_blacklist, NULL))) != NULL) {
		free(result);
		verbose("Refusing blacklisted %s request", h->name);
		return 0;
	}
	if (request_whitelist != NULL &&
	    ((result = match_list(h->name, request_whitelist, NULL))) != NULL) {
		free(result);
		debug2("Permitting whitelisted %s request", h->name);
		return 1;
	}
	if (request_whitelist != NULL) {
		verbose("Refusing non-whitelisted %s request", h->name);
		return 0;
	}
	return 1;
}

static int
errno_to_portable(int unixerrno)
{
	int ret = 0;

	switch (unixerrno) {
	case 0:
		ret = SSH2_FX_OK;
		break;
	case ENOENT:
	case ENOTDIR:
	case EBADF:
	case ELOOP:
		ret = SSH2_FX_NO_SUCH_FILE;
		break;
	case EPERM:
	case EACCES:
	case EFAULT:
		ret = SSH2_FX_PERMISSION_DENIED;
		break;
	case ENAMETOOLONG:
	case EINVAL:
		ret = SSH2_FX_BAD_MESSAGE;
		break;
	case ENOSYS:
		ret = SSH2_FX_OP_UNSUPPORTED;
		break;
	default:
		ret = SSH2_FX_FAILURE;
		break;
	}
	return ret;
}

static int
flags_from_portable(int pflags)
{
	int flags = 0;

	if ((pflags & SSH2_FXF_READ) &&
	    (pflags & SSH2_FXF_WRITE)) {
		flags = O_RDWR;
	} else if (pflags & SSH2_FXF_READ) {
		flags = O_RDONLY;
	} else if (pflags & SSH2_FXF_WRITE) {
		flags = O_WRONLY;
	}
	if (pflags & SSH2_FXF_APPEND)
		flags |= O_APPEND;
	if (pflags & SSH2_FXF_CREAT)
		flags |= O_CREAT;
	if (pflags & SSH2_FXF_TRUNC)
		flags |= O_TRUNC;
	if (pflags & SSH2_FXF_EXCL)
		flags |= O_EXCL;
	return flags;
}

static const char *
string_from_portable(int pflags)
{
	static char ret[128];

	*ret = '\0';

#define PAPPEND(str)	{				\
		if (*ret != '\0')			\
			strlcat(ret, ",", sizeof(ret));	\
		strlcat(ret, str, sizeof(ret));		\
	}

	if (pflags & SSH2_FXF_READ)
		PAPPEND("READ")
	if (pflags & SSH2_FXF_WRITE)
		PAPPEND("WRITE")
	if (pflags & SSH2_FXF_APPEND)
		PAPPEND("APPEND")
	if (pflags & SSH2_FXF_CREAT)
		PAPPEND("CREATE")
	if (pflags & SSH2_FXF_TRUNC)
		PAPPEND("TRUNCATE")
	if (pflags & SSH2_FXF_EXCL)
		PAPPEND("EXCL")

	return ret;
}

/* handle handles */

typedef struct Handle Handle;
struct Handle {
	int use;
	DIR *dirp;
	int fd;
	int flags;
	char *name;
	u_int64_t bytes_read, bytes_write;
	int next_unused;
};

enum {
	HANDLE_UNUSED,
	HANDLE_DIR,
	HANDLE_FILE
};

Handle *handles = NULL;
u_int num_handles = 0;
int first_unused_handle = -1;

static void handle_unused(int i)
{
	handles[i].use = HANDLE_UNUSED;
	handles[i].next_unused = first_unused_handle;
	first_unused_handle = i;
}

static int
handle_new(int use, const char *name, int fd, int flags, DIR *dirp)
{
	int i;

	if (first_unused_handle == -1) {
		if (num_handles + 1 <= num_handles)
			return -1;
		num_handles++;
		handles = xreallocarray(handles, num_handles, sizeof(Handle));
		handle_unused(num_handles - 1);
	}

	i = first_unused_handle;
	first_unused_handle = handles[i].next_unused;

	handles[i].use = use;
	handles[i].dirp = dirp;
	handles[i].fd = fd;
	handles[i].flags = flags;
	handles[i].name = xstrdup(name);
	handles[i].bytes_read = handles[i].bytes_write = 0;

	return i;
}

static int
handle_is_ok(int i, int type)
{
	return i >= 0 && (u_int)i < num_handles && handles[i].use == type;
}

static int
handle_to_string(int handle, u_char **stringp, int *hlenp)
{
	if (stringp == NULL || hlenp == NULL)
		return -1;
	*stringp = xmalloc(sizeof(int32_t));
	put_u32(*stringp, handle);
	*hlenp = sizeof(int32_t);
	return 0;
}

static int
handle_from_string(const u_char *handle, u_int hlen)
{
	int val;

	if (hlen != sizeof(int32_t))
		return -1;
	val = get_u32(handle);
	if (handle_is_ok(val, HANDLE_FILE) ||
	    handle_is_ok(val, HANDLE_DIR))
		return val;
	return -1;
}

static char *
handle_to_name(int handle)
{
	if (handle_is_ok(handle, HANDLE_DIR)||
	    handle_is_ok(handle, HANDLE_FILE))
		return handles[handle].name;
	return NULL;
}

static DIR *
handle_to_dir(int handle)
{
	if (handle_is_ok(handle, HANDLE_DIR))
		return handles[handle].dirp;
	return NULL;
}

static int
handle_to_fd(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return handles[handle].fd;
	return -1;
}

static int
handle_to_flags(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return handles[handle].flags;
	return 0;
}

static void
handle_update_read(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_read += bytes;
}

static void
handle_update_write(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_write += bytes;
}

static u_int64_t
handle_bytes_read(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_read);
	return 0;
}

static u_int64_t
handle_bytes_write(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_write);
	return 0;
}

static int
handle_close(int handle)
{
	int ret = -1;

	if (handle_is_ok(handle, HANDLE_FILE)) {
		ret = close(handles[handle].fd);
		free(handles[handle].name);
		handle_unused(handle);
	} else if (handle_is_ok(handle, HANDLE_DIR)) {
		ret = closedir(handles[handle].dirp);
		free(handles[handle].name);
		handle_unused(handle);
	} else {
		errno = ENOENT;
	}
	return ret;
}

static void
handle_log_close(int handle, char *emsg)
{
	if (handle_is_ok(handle, HANDLE_FILE)) {
		logit("%s%sclose \"%s\" bytes read %llu written %llu",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle),
		    (unsigned long long)handle_bytes_read(handle),
		    (unsigned long long)handle_bytes_write(handle));
	} else {
		logit("%s%sclosedir \"%s\"",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle));
	}
}

static void
handle_log_exit(void)
{
	u_int i;

	for (i = 0; i < num_handles; i++)
		if (handles[i].use != HANDLE_UNUSED)
			handle_log_close(i, "forced");
}

static int
get_handle(struct sshbuf *queue, int *hp)
{
	u_char *handle;
	int r;
	size_t hlen;

	*hp = -1;
	if ((r = sshbuf_get_string(queue, &handle, &hlen)) != 0)
		return r;
	if (hlen < 256)
		*hp = handle_from_string(handle, hlen);
	free(handle);
	return 0;
}

/* send replies */

static void
send_msg(struct sshbuf *m)
{
	int r;

	if ((r = sshbuf_put_stringb(oqueue, m)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	sshbuf_reset(m);
}

static const char *
status_to_message(u_int32_t status)
{
	const char *status_messages[] = {
		"Success",			/* SSH_FX_OK */
		"End of file",			/* SSH_FX_EOF */
		"No such file",			/* SSH_FX_NO_SUCH_FILE */
		"Permission denied",		/* SSH_FX_PERMISSION_DENIED */
		"Failure",			/* SSH_FX_FAILURE */
		"Bad message",			/* SSH_FX_BAD_MESSAGE */
		"No connection",		/* SSH_FX_NO_CONNECTION */
		"Connection lost",		/* SSH_FX_CONNECTION_LOST */
		"Operation unsupported",	/* SSH_FX_OP_UNSUPPORTED */
		"Unknown error"			/* Others */
	};
	return (status_messages[MINIMUM(status,SSH2_FX_MAX)]);
}

static void
send_status(u_int32_t id, u_int32_t status)
{
	struct sshbuf *msg;
	int r;

	debug3("request %u: sent status %u", id, status);
	if (log_level > SYSLOG_LEVEL_VERBOSE ||
	    (status != SSH2_FX_OK && status != SSH2_FX_EOF))
		logit("sent status %s", status_to_message(status));
	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_STATUS)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_u32(msg, status)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	if (version >= 3) {
		if ((r = sshbuf_put_cstring(msg,
		    status_to_message(status))) != 0 ||
		    (r = sshbuf_put_cstring(msg, "")) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
	}
	send_msg(msg);
	sshbuf_free(msg);
}
static void
send_data_or_handle(char type, u_int32_t id, const u_char *data, int dlen)
{
	struct sshbuf *msg;
	int r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, type)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_string(msg, data, dlen)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(msg);
	sshbuf_free(msg);
}

static void
send_data(u_int32_t id, const u_char *data, int dlen)
{
	debug("request %u: sent data len %d", id, dlen);
	send_data_or_handle(SSH2_FXP_DATA, id, data, dlen);
}

static void
send_handle(u_int32_t id, int handle)
{
	u_char *string;
	int hlen;

	handle_to_string(handle, &string, &hlen);
	debug("request %u: sent handle handle %d", id, handle);
	send_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);
	free(string);
}

static void
send_names(u_int32_t id, int count, const Stat *stats)
{
	struct sshbuf *msg;
	int i, r;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_NAME)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_u32(msg, count)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	debug("request %u: sent names count %d", id, count);
	for (i = 0; i < count; i++) {
		if ((r = sshbuf_put_cstring(msg, stats[i].name)) != 0 ||
		    (r = sshbuf_put_cstring(msg, stats[i].long_name)) != 0 ||
		    (r = encode_attrib(msg, &stats[i].attrib)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
	}
	send_msg(msg);
	sshbuf_free(msg);
}

static void
send_attrib(u_int32_t id, const Attrib *a)
{
	struct sshbuf *msg;
	int r;

	debug("request %u: sent attrib have 0x%x", id, a->flags);
	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_ATTRS)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = encode_attrib(msg, a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(msg);
	sshbuf_free(msg);
}

static void
send_statvfs(u_int32_t id, struct statvfs *st)
{
	struct sshbuf *msg;
	u_int64_t flag;
	int r;

	flag = (st->f_flag & ST_RDONLY) ? SSH2_FXE_STATVFS_ST_RDONLY : 0;
	flag |= (st->f_flag & ST_NOSUID) ? SSH2_FXE_STATVFS_ST_NOSUID : 0;

	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED_REPLY)) != 0 ||
	    (r = sshbuf_put_u32(msg, id)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_bsize)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_frsize)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_blocks)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_bfree)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_bavail)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_files)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_ffree)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_favail)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_fsid)) != 0 ||
	    (r = sshbuf_put_u64(msg, flag)) != 0 ||
	    (r = sshbuf_put_u64(msg, st->f_namemax)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(msg);
	sshbuf_free(msg);
}

/* parse incoming */

static void
process_init(void)
{
	struct sshbuf *msg;
	int r;

	if ((r = sshbuf_get_u32(iqueue, &version)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	verbose("received client version %u", version);
	if ((msg = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_u8(msg, SSH2_FXP_VERSION)) != 0 ||
	    (r = sshbuf_put_u32(msg, SSH2_FILEXFER_VERSION)) != 0 ||
	    /* POSIX rename extension */
	    (r = sshbuf_put_cstring(msg, "posix-rename@@openssh.com")) != 0 ||
	    (r = sshbuf_put_cstring(msg, "1")) != 0 || /* version */
	    /* statvfs extension */
	    (r = sshbuf_put_cstring(msg, "statvfs@@openssh.com")) != 0 ||
	    (r = sshbuf_put_cstring(msg, "2")) != 0 || /* version */
	    /* fstatvfs extension */
	    (r = sshbuf_put_cstring(msg, "fstatvfs@@openssh.com")) != 0 ||
	    (r = sshbuf_put_cstring(msg, "2")) != 0 || /* version */
	    /* hardlink extension */
	    (r = sshbuf_put_cstring(msg, "hardlink@@openssh.com")) != 0 ||
	    (r = sshbuf_put_cstring(msg, "1")) != 0 || /* version */
	    /* fsync extension */
	    (r = sshbuf_put_cstring(msg, "fsync@@openssh.com")) != 0 ||
	    (r = sshbuf_put_cstring(msg, "1")) != 0) /* version */
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	send_msg(msg);
	sshbuf_free(msg);
}

static void
process_open(u_int32_t id)
{
	u_int32_t pflags;
	Attrib a;
	char *name;
	int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: open flags %d", id, pflags);
	flags = flags_from_portable(pflags);
	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
	logit("open \"%s\" flags %s mode 0%o",
	    name, string_from_portable(pflags), mode);
	if (readonly &&
	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
		verbose("Refusing open request in read-only mode");
		status = SSH2_FX_PERMISSION_DENIED;
	} else {
		fd = open(name, flags, mode);
		if (fd < 0) {
			status = errno_to_portable(errno);
		} else {
			handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
			if (handle < 0) {
				close(fd);
			} else {
				send_handle(id, handle);
				status = SSH2_FX_OK;
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}

static void
process_close(u_int32_t id)
{
	int r, handle, ret, status = SSH2_FX_FAILURE;

	if ((r = get_handle(iqueue, &handle)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: close handle %u", id, handle);
	handle_log_close(handle, NULL);
	ret = handle_close(handle);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
}

static void
process_read(u_int32_t id)
{
	u_char buf[64*1024];
	u_int32_t len;
	int r, handle, fd, ret, status = SSH2_FX_FAILURE;
	u_int64_t off;

	if ((r = get_handle(iqueue, &handle)) != 0 ||
	    (r = sshbuf_get_u64(iqueue, &off)) != 0 ||
	    (r = sshbuf_get_u32(iqueue, &len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug("request %u: read \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
	if (len > sizeof buf) {
		len = sizeof buf;
		debug2("read change len %d", len);
	}
	fd = handle_to_fd(handle);
	if (fd >= 0) {
		if (lseek(fd, off, SEEK_SET) < 0) {
			error("process_read: seek failed");
			status = errno_to_portable(errno);
		} else {
			ret = read(fd, buf, len);
			if (ret < 0) {
				status = errno_to_portable(errno);
			} else if (ret == 0) {
				status = SSH2_FX_EOF;
			} else {
				send_data(id, buf, ret);
				status = SSH2_FX_OK;
				handle_update_read(handle, ret);
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
}

static void
process_write(u_int32_t id)
{
	u_int64_t off;
	size_t len;
	int r, handle, fd, ret, status;
	u_char *data;

	if ((r = get_handle(iqueue, &handle)) != 0 ||
	    (r = sshbuf_get_u64(iqueue, &off)) != 0 ||
	    (r = sshbuf_get_string(iqueue, &data, &len)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug("request %u: write \"%s\" (handle %d) off %llu len %zu",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
	fd = handle_to_fd(handle);

	if (fd < 0)
		status = SSH2_FX_FAILURE;
	else {
		if (!(handle_to_flags(handle) & O_APPEND) &&
				lseek(fd, off, SEEK_SET) < 0) {
			status = errno_to_portable(errno);
			error("process_write: seek failed");
		} else {
/* XXX ATOMICIO ? */
			ret = write(fd, data, len);
			if (ret < 0) {
				error("process_write: write failed");
				status = errno_to_portable(errno);
			} else if ((size_t)ret == len) {
				status = SSH2_FX_OK;
				handle_update_write(handle, ret);
			} else {
				debug2("nothing at all written");
				status = SSH2_FX_FAILURE;
			}
		}
	}
	send_status(id, status);
	free(data);
}

static void
process_do_stat(u_int32_t id, int do_lstat)
{
	Attrib a;
	struct stat st;
	char *name;
	int r, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
	r = do_lstat ? lstat(name, &st) : stat(name, &st);
	if (r < 0) {
		status = errno_to_portable(errno);
	} else {
		stat_to_attrib(&st, &a);
		send_attrib(id, &a);
		status = SSH2_FX_OK;
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(name);
}

static void
process_stat(u_int32_t id)
{
	process_do_stat(id, 0);
}

static void
process_lstat(u_int32_t id)
{
	process_do_stat(id, 1);
}

static void
process_fstat(u_int32_t id)
{
	Attrib a;
	struct stat st;
	int fd, r, handle, status = SSH2_FX_FAILURE;

	if ((r = get_handle(iqueue, &handle)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	debug("request %u: fstat \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
	fd = handle_to_fd(handle);
	if (fd >= 0) {
		r = fstat(fd, &st);
		if (r < 0) {
			status = errno_to_portable(errno);
		} else {
			stat_to_attrib(&st, &a);
			send_attrib(id, &a);
			status = SSH2_FX_OK;
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
}

static struct timeval *
attrib_to_tv(const Attrib *a)
{
	static struct timeval tv[2];

	tv[0].tv_sec = a->atime;
	tv[0].tv_usec = 0;
	tv[1].tv_sec = a->mtime;
	tv[1].tv_usec = 0;
	return tv;
}

static void
process_setstat(u_int32_t id)
{
	Attrib a;
	char *name;
	int r, status = SSH2_FX_OK;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug("request %u: setstat name \"%s\"", id, name);
	if (a.flags & SSH2_FILEXFER_ATTR_SIZE) {
		logit("set \"%s\" size %llu",
		    name, (unsigned long long)a.size);
		r = truncate(name, a.size);
		if (r == -1)
			status = errno_to_portable(errno);
	}
	if (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
		logit("set \"%s\" mode %04o", name, a.perm);
		r = chmod(name, a.perm & 07777);
		if (r == -1)
			status = errno_to_portable(errno);
	}
	if (a.flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
		char buf[64];
		time_t t = a.mtime;

		strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
		    localtime(&t));
		logit("set \"%s\" modtime %s", name, buf);
		r = utimes(name, attrib_to_tv(&a));
		if (r == -1)
			status = errno_to_portable(errno);
	}
	if (a.flags & SSH2_FILEXFER_ATTR_UIDGID) {
		logit("set \"%s\" owner %lu group %lu", name,
		    (u_long)a.uid, (u_long)a.gid);
		r = chown(name, a.uid, a.gid);
		if (r == -1)
			status = errno_to_portable(errno);
	}
	send_status(id, status);
	free(name);
}

static void
process_fsetstat(u_int32_t id)
{
	Attrib a;
	int handle, fd, r;
	int status = SSH2_FX_OK;

	if ((r = get_handle(iqueue, &handle)) != 0 ||
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug("request %u: fsetstat handle %d", id, handle);
	fd = handle_to_fd(handle);
	if (fd < 0)
		status = SSH2_FX_FAILURE;
	else {
		char *name = handle_to_name(handle);

		if (a.flags & SSH2_FILEXFER_ATTR_SIZE) {
			logit("set \"%s\" size %llu",
			    name, (unsigned long long)a.size);
			r = ftruncate(fd, a.size);
			if (r == -1)
				status = errno_to_portable(errno);
		}
		if (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
			logit("set \"%s\" mode %04o", name, a.perm);
			r = fchmod(fd, a.perm & 07777);
			if (r == -1)
				status = errno_to_portable(errno);
		}
		if (a.flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
			char buf[64];
			time_t t = a.mtime;

			strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
			    localtime(&t));
			logit("set \"%s\" modtime %s", name, buf);
			r = futimes(fd, attrib_to_tv(&a));
			if (r == -1)
				status = errno_to_portable(errno);
		}
		if (a.flags & SSH2_FILEXFER_ATTR_UIDGID) {
			logit("set \"%s\" owner %lu group %lu", name,
			    (u_long)a.uid, (u_long)a.gid);
			r = fchown(fd, a.uid, a.gid);
			if (r == -1)
				status = errno_to_portable(errno);
		}
	}
	send_status(id, status);
}

static void
process_opendir(u_int32_t id)
{
	DIR *dirp = NULL;
	char *path;
	int r, handle, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: opendir", id);
	logit("opendir \"%s\"", path);
	dirp = opendir(path);
	if (dirp == NULL) {
		status = errno_to_portable(errno);
	} else {
		handle = handle_new(HANDLE_DIR, path, 0, 0, dirp);
		if (handle < 0) {
			closedir(dirp);
		} else {
			send_handle(id, handle);
			status = SSH2_FX_OK;
		}

	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	free(path);
}

static void
process_readdir(u_int32_t id)
{
	DIR *dirp;
	struct dirent *dp;
	char *path;
	int r, handle;

	if ((r = get_handle(iqueue, &handle)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug("request %u: readdir \"%s\" (handle %d)", id,
	    handle_to_name(handle), handle);
	dirp = handle_to_dir(handle);
	path = handle_to_name(handle);
	if (dirp == NULL || path == NULL) {
		send_status(id, SSH2_FX_FAILURE);
	} else {
		struct stat st;
		char pathname[PATH_MAX];
		Stat *stats;
		int nstats = 10, count = 0, i;

		stats = xcalloc(nstats, sizeof(Stat));
		while ((dp = readdir(dirp)) != NULL) {
			if (count >= nstats) {
				nstats *= 2;
				stats = xreallocarray(stats, nstats, sizeof(Stat));
			}
/* XXX OVERFLOW ? */
			snprintf(pathname, sizeof pathname, "%s%s%s", path,
			    strcmp(path, "/") ? "/" : "", dp->d_name);
			if (lstat(pathname, &st) < 0)
				continue;
			stat_to_attrib(&st, &(stats[count].attrib));
			stats[count].name = xstrdup(dp->d_name);
			stats[count].long_name = ls_file(dp->d_name, &st, 0, 0);
			count++;
			/* send up to 100 entries in one message */
			/* XXX check packet size instead */
			if (count == 100)
				break;
		}
		if (count > 0) {
			send_names(id, count, stats);
			for (i = 0; i < count; i++) {
				free(stats[i].name);
				free(stats[i].long_name);
			}
		} else {
			send_status(id, SSH2_FX_EOF);
		}
		free(stats);
	}
}

static void
process_remove(u_int32_t id)
{
	char *name;
	int r, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: remove", id);
	logit("remove name \"%s\"", name);
	r = unlink(name);
	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	free(name);
}

static void
process_mkdir(u_int32_t id)
{
	Attrib a;
	char *name;
	int r, mode, status = SSH2_FX_FAILURE;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
	    (r = decode_attrib(iqueue, &a)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ?
	    a.perm & 07777 : 0777;
	debug3("request %u: mkdir", id);
	logit("mkdir name \"%s\" mode 0%o", name, mode);
	r = mkdir(name, mode);
	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	free(name);
}

static void
process_rmdir(u_int32_t id)
{
	char *name;
	int r, status;

	if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: rmdir", id);
	logit("rmdir name \"%s\"", name);
	r = rmdir(name);
	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	free(name);
}

static void
process_realpath(u_int32_t id)
{
	char resolvedname[PATH_MAX];
	char *path;
	int r;

	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if (path[0] == '\0') {
		free(path);
		path = xstrdup(".");
	}
	debug3("request %u: realpath", id);
	verbose("realpath \"%s\"", path);
	if (realpath(path, resolvedname) == NULL) {
		send_status(id, errno_to_portable(errno));
	} else {
		Stat s;
		attrib_clear(&s.attrib);
		s.name = s.long_name = resolvedname;
		send_names(id, 1, &s);
	}
	free(path);
}

static void
process_rename(u_int32_t id)
{
	char *oldpath, *newpath;
	int r, status;
	struct stat sb;

	if ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: rename", id);
	logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
	status = SSH2_FX_FAILURE;
	if (lstat(oldpath, &sb) == -1)
		status = errno_to_portable(errno);
	else if (S_ISREG(sb.st_mode)) {
		/* Race-free rename of regular files */
		if (link(oldpath, newpath) == -1) {
			if (errno == EOPNOTSUPP) {
				struct stat st;

				/*
				 * fs doesn't support links, so fall back to
				 * stat+rename.  This is racy.
				 */
				if (stat(newpath, &st) == -1) {
					if (rename(oldpath, newpath) == -1)
						status =
						    errno_to_portable(errno);
					else
						status = SSH2_FX_OK;
				}
			} else {
				status = errno_to_portable(errno);
			}
		} else if (unlink(oldpath) == -1) {
			status = errno_to_portable(errno);
			/* clean spare link */
			unlink(newpath);
		} else
			status = SSH2_FX_OK;
	} else if (stat(newpath, &sb) == -1) {
		if (rename(oldpath, newpath) == -1)
			status = errno_to_portable(errno);
		else
			status = SSH2_FX_OK;
	}
	send_status(id, status);
	free(oldpath);
	free(newpath);
}

static void
process_readlink(u_int32_t id)
{
	int r, len;
	char buf[PATH_MAX];
	char *path;

	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: readlink", id);
	verbose("readlink \"%s\"", path);
	if ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)
		send_status(id, errno_to_portable(errno));
	else {
		Stat s;

		buf[len] = '\0';
		attrib_clear(&s.attrib);
		s.name = s.long_name = buf;
		send_names(id, 1, &s);
	}
	free(path);
}

static void
process_symlink(u_int32_t id)
{
	char *oldpath, *newpath;
	int r, status;

	if ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: symlink", id);
	logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
	/* this will fail if 'newpath' exists */
	r = symlink(oldpath, newpath);
	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	free(oldpath);
	free(newpath);
}

static void
process_extended_posix_rename(u_int32_t id)
{
	char *oldpath, *newpath;
	int r, status;

	if ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: posix-rename", id);
	logit("posix-rename old \"%s\" new \"%s\"", oldpath, newpath);
	r = rename(oldpath, newpath);
	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	free(oldpath);
	free(newpath);
}

static void
process_extended_statvfs(u_int32_t id)
{
	char *path;
	struct statvfs st;
	int r;

	if ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	debug3("request %u: statvfs", id);
	logit("statvfs \"%s\"", path);

	if (statvfs(path, &st) != 0)
		send_status(id, errno_to_portable(errno));
	else
		send_statvfs(id, &st);
        free(path);
}

static void
process_extended_fstatvfs(u_int32_t id)
{
	int r, handle, fd;
	struct statvfs st;

	if ((r = get_handle(iqueue, &handle)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	debug("request %u: fstatvfs \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
	if ((fd = handle_to_fd(handle)) < 0) {
		send_status(id, SSH2_FX_FAILURE);
		return;
	}
	if (fstatvfs(fd, &st) != 0)
		send_status(id, errno_to_portable(errno));
	else
		send_statvfs(id, &st);
}

static void
process_extended_hardlink(u_int32_t id)
{
	char *oldpath, *newpath;
	int r, status;

	if ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	debug3("request %u: hardlink", id);
	logit("hardlink old \"%s\" new \"%s\"", oldpath, newpath);
	r = link(oldpath, newpath);
	status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	free(oldpath);
	free(newpath);
}

static void
process_extended_fsync(u_int32_t id)
{
	int handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;

	if ((r = get_handle(iqueue, &handle)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	debug3("request %u: fsync (handle %u)", id, handle);
	verbose("fsync \"%s\"", handle_to_name(handle));
	if ((fd = handle_to_fd(handle)) < 0)
		status = SSH2_FX_NO_SUCH_FILE;
	else if (handle_is_ok(handle, HANDLE_FILE)) {
		r = fsync(fd);
		status = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
	send_status(id, status);
}

static void
process_extended(u_int32_t id)
{
	char *request;
	int i, r;

	if ((r = sshbuf_get_cstring(iqueue, &request, NULL)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	for (i = 0; extended_handlers[i].handler != NULL; i++) {
		if (strcmp(request, extended_handlers[i].ext_name) == 0) {
			if (!request_permitted(&extended_handlers[i]))
				send_status(id, SSH2_FX_PERMISSION_DENIED);
			else
				extended_handlers[i].handler(id);
			break;
		}
	}
	if (extended_handlers[i].handler == NULL) {
		error("Unknown extended request \"%.100s\"", request);
		send_status(id, SSH2_FX_OP_UNSUPPORTED);	/* MUST */
	}
	free(request);
}

/* stolen from ssh-agent */

static void
process(void)
{
	u_int msg_len;
	u_int buf_len;
	u_int consumed;
	u_char type;
	const u_char *cp;
	int i, r;
	u_int32_t id;

	buf_len = sshbuf_len(iqueue);
	if (buf_len < 5)
		return;		/* Incomplete message. */
	cp = sshbuf_ptr(iqueue);
	msg_len = get_u32(cp);
	if (msg_len > SFTP_MAX_MSG_LENGTH) {
		error("bad message from %s local user %s",
		    client_addr, pw->pw_name);
		sftp_server_cleanup_exit(11);
	}
	if (buf_len < msg_len + 4)
		return;
	if ((r = sshbuf_consume(iqueue, 4)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	buf_len -= 4;
	if ((r = sshbuf_get_u8(iqueue, &type)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	switch (type) {
	case SSH2_FXP_INIT:
		process_init();
		init_done = 1;
		break;
	case SSH2_FXP_EXTENDED:
		if (!init_done)
			fatal("Received extended request before init");
		if ((r = sshbuf_get_u32(iqueue, &id)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		process_extended(id);
		break;
	default:
		if (!init_done)
			fatal("Received %u request before init", type);
		if ((r = sshbuf_get_u32(iqueue, &id)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		for (i = 0; handlers[i].handler != NULL; i++) {
			if (type == handlers[i].type) {
				if (!request_permitted(&handlers[i])) {
					send_status(id,
					    SSH2_FX_PERMISSION_DENIED);
				} else {
					handlers[i].handler(id);
				}
				break;
			}
		}
		if (handlers[i].handler == NULL)
			error("Unknown message %u", type);
	}
	/* discard the remaining bytes from the current packet */
	if (buf_len < sshbuf_len(iqueue)) {
		error("iqueue grew unexpectedly");
		sftp_server_cleanup_exit(255);
	}
	consumed = buf_len - sshbuf_len(iqueue);
	if (msg_len < consumed) {
		error("msg_len %u < consumed %u", msg_len, consumed);
		sftp_server_cleanup_exit(255);
	}
	if (msg_len > consumed &&
	    (r = sshbuf_consume(iqueue, msg_len - consumed)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
}

/* Cleanup handler that logs active handles upon normal exit */
void
sftp_server_cleanup_exit(int i)
{
	if (pw != NULL && client_addr != NULL) {
		handle_log_exit();
		logit("session closed for local user %s from [%s]",
		    pw->pw_name, client_addr);
	}
	_exit(i);
}

static void
sftp_server_usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-ehR] [-d start_directory] [-f log_facility] "
	    "[-l log_level]\n\t[-P blacklisted_requests] "
	    "[-p whitelisted_requests] [-u umask]\n"
	    "       %s -Q protocol_feature\n",
	    __progname, __progname);
	exit(1);
}

int
sftp_server_main(int argc, char **argv, struct passwd *user_pw)
{
	fd_set *rset, *wset;
	int i, r, in, out, max, ch, skipargs = 0, log_stderr = 0;
	ssize_t len, olen, set_size;
	SyslogFacility log_facility = SYSLOG_FACILITY_AUTH;
	char *cp, *homedir = NULL, buf[4*4096];
	long mask;

	extern char *optarg;
	extern char *__progname;

	ssh_malloc_init();	/* must be called before any mallocs */
	log_init(__progname, log_level, log_facility, log_stderr);

	pw = pwcopy(user_pw);

	while (!skipargs && (ch = getopt(argc, argv,
	    "d:f:l:P:p:Q:u:cehR")) != -1) {
		switch (ch) {
		case 'Q':
			if (strcasecmp(optarg, "requests") != 0) {
				fprintf(stderr, "Invalid query type\n");
				exit(1);
			}
			for (i = 0; handlers[i].handler != NULL; i++)
				printf("%s\n", handlers[i].name);
			for (i = 0; extended_handlers[i].handler != NULL; i++)
				printf("%s\n", extended_handlers[i].name);
			exit(0);
			break;
		case 'R':
			readonly = 1;
			break;
		case 'c':
			/*
			 * Ignore all arguments if we are invoked as a
			 * shell using "sftp-server -c command"
			 */
			skipargs = 1;
			break;
		case 'e':
			log_stderr = 1;
			break;
		case 'l':
			log_level = log_level_number(optarg);
			if (log_level == SYSLOG_LEVEL_NOT_SET)
				error("Invalid log level \"%s\"", optarg);
			break;
		case 'f':
			log_facility = log_facility_number(optarg);
			if (log_facility == SYSLOG_FACILITY_NOT_SET)
				error("Invalid log facility \"%s\"", optarg);
			break;
		case 'd':
			cp = tilde_expand_filename(optarg, user_pw->pw_uid);
			homedir = percent_expand(cp, "d", user_pw->pw_dir,
			    "u", user_pw->pw_name, (char *)NULL);
			free(cp);
			break;
		case 'p':
			if (request_whitelist != NULL)
				fatal("Permitted requests already set");
			request_whitelist = xstrdup(optarg);
			break;
		case 'P':
			if (request_blacklist != NULL)
				fatal("Refused requests already set");
			request_blacklist = xstrdup(optarg);
			break;
		case 'u':
			errno = 0;
			mask = strtol(optarg, &cp, 8);
			if (mask < 0 || mask > 0777 || *cp != '\0' ||
			    cp == optarg || (mask == 0 && errno != 0))
				fatal("Invalid umask \"%s\"", optarg);
			(void)umask((mode_t)mask);
			break;
		case 'h':
		default:
			sftp_server_usage();
		}
	}

	log_init(__progname, log_level, log_facility, log_stderr);

	if ((cp = getenv("SSH_CONNECTION")) != NULL) {
		client_addr = xstrdup(cp);
		if ((cp = strchr(client_addr, ' ')) == NULL) {
			error("Malformed SSH_CONNECTION variable: \"%s\"",
			    getenv("SSH_CONNECTION"));
			sftp_server_cleanup_exit(255);
		}
		*cp = '\0';
	} else
		client_addr = xstrdup("UNKNOWN");

	logit("session opened for local user %s from [%s]",
	    pw->pw_name, client_addr);

	in = STDIN_FILENO;
	out = STDOUT_FILENO;

	max = 0;
	if (in > max)
		max = in;
	if (out > max)
		max = out;

	if ((iqueue = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((oqueue = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);

	rset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));
	wset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));

	if (homedir != NULL) {
		if (chdir(homedir) != 0) {
			error("chdir to \"%s\" failed: %s", homedir,
			    strerror(errno));
		}
	}

	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
	for (;;) {
		memset(rset, 0, set_size);
		memset(wset, 0, set_size);

		/*
		 * Ensure that we can read a full buffer and handle
		 * the worst-case length packet it can generate,
		 * otherwise apply backpressure by stopping reads.
		 */
		if ((r = sshbuf_check_reserve(iqueue, sizeof(buf))) == 0 &&
		    (r = sshbuf_check_reserve(oqueue,
		    SFTP_MAX_MSG_LENGTH)) == 0)
			FD_SET(in, rset);
		else if (r != SSH_ERR_NO_BUFFER_SPACE)
			fatal("%s: sshbuf_check_reserve failed: %s",
			    __func__, ssh_err(r));

		olen = sshbuf_len(oqueue);
		if (olen > 0)
			FD_SET(out, wset);

		if (select(max+1, rset, wset, NULL, NULL) < 0) {
			if (errno == EINTR)
				continue;
			error("select: %s", strerror(errno));
			sftp_server_cleanup_exit(2);
		}

		/* copy stdin to iqueue */
		if (FD_ISSET(in, rset)) {
			len = read(in, buf, sizeof buf);
			if (len == 0) {
				debug("read eof");
				sftp_server_cleanup_exit(0);
			} else if (len < 0) {
				error("read: %s", strerror(errno));
				sftp_server_cleanup_exit(1);
			} else if ((r = sshbuf_put(iqueue, buf, len)) != 0) {
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			}
		}
		/* send oqueue to stdout */
		if (FD_ISSET(out, wset)) {
			len = write(out, sshbuf_ptr(oqueue), olen);
			if (len < 0) {
				error("write: %s", strerror(errno));
				sftp_server_cleanup_exit(1);
			} else if ((r = sshbuf_consume(oqueue, len)) != 0) {
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			}
		}

		/*
		 * Process requests from client if we can fit the results
		 * into the output buffer, otherwise stop processing input
		 * and let the output queue drain.
		 */
		r = sshbuf_check_reserve(oqueue, SFTP_MAX_MSG_LENGTH);
		if (r == 0)
			process();
		else if (r != SSH_ERR_NO_BUFFER_SPACE)
			fatal("%s: sshbuf_check_reserve: %s",
			    __func__, ssh_err(r));
	}
}
@


1.109
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.108 2015/11/16 06:13:04 logan Exp $ */
a17 1
#include <sys/param.h>	/* MIN */
d499 1
a499 1
	return (status_messages[MIN(status,SSH2_FX_MAX)]);
@


1.108
log
@1) Use xcalloc() instead of xmalloc() to check for  potential overflow.
   (Feedback from both mmcc@@ and djm@@)
2) move set_size just before the for loop. (suggested by djm@@)

OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.107 2015/08/20 22:32:42 deraadt Exp $ */
d1486 1
@


1.107
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.106 2015/04/24 01:36:01 deraadt Exp $ */
d1587 2
a1588 3
	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
	rset = xmalloc(set_size);
	wset = xmalloc(set_size);
d1597 1
@


1.106
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.105 2015/01/20 23:14:00 deraadt Exp $ */
d1588 2
a1589 2
	rset = (fd_set *)xmalloc(set_size);
	wset = (fd_set *)xmalloc(set_size);
@


1.105
log
@Reduce use of <sys/param.h> and transition to <limits.h> throughout.
ok djm markus
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.104 2015/01/14 13:54:13 djm Exp $ */
d301 1
a301 1
		handles = xrealloc(handles, num_handles, sizeof(Handle));
d1042 1
a1042 1
				stats = xrealloc(stats, nstats, sizeof(Stat));
@


1.104
log
@update sftp client and server to new buffer API.
pretty much just mechanical changes; with & ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.103 2014/01/17 06:23:24 dtucker Exp $ */
d18 1
a21 1
#include <sys/param.h>
d1034 1
a1034 1
		char pathname[MAXPATHLEN];
d1129 1
a1129 1
	char resolvedname[MAXPATHLEN];
d1210 1
a1210 1
	char buf[MAXPATHLEN];
@


1.103
log
@fix log message statvfs.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.102 2013/10/17 00:30:13 djm Exp $ */
d37 2
a38 1
#include "buffer.h"
a46 5
/* helper */
#define get_int64()			buffer_get_int64(&iqueue);
#define get_int()			buffer_get_int(&iqueue);
#define get_string(lenp)		buffer_get_string(&iqueue, lenp);

d55 2
a56 2
static Buffer iqueue;
static Buffer oqueue;
a261 6
static Attrib *
get_attrib(void)
{
	return decode_attrib(&iqueue);
}

d325 1
a325 1
handle_to_string(int handle, char **stringp, int *hlenp)
d336 1
a336 1
handle_from_string(const char *handle, u_int hlen)
d458 1
a458 1
get_handle(void)
d460 7
a466 5
	char *handle;
	int val = -1;
	u_int hlen;

	handle = get_string(&hlen);
d468 1
a468 1
		val = handle_from_string(handle, hlen);
d470 1
a470 1
	return val;
d476 1
a476 1
send_msg(Buffer *m)
d478 1
a478 1
	int mlen = buffer_len(m);
d480 3
a482 3
	buffer_put_int(&oqueue, mlen);
	buffer_append(&oqueue, buffer_ptr(m), mlen);
	buffer_consume(m, mlen);
d506 2
a507 1
	Buffer msg;
d513 6
a518 4
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_STATUS);
	buffer_put_int(&msg, id);
	buffer_put_int(&msg, status);
d520 4
a523 2
		buffer_put_cstring(&msg, status_to_message(status));
		buffer_put_cstring(&msg, "");
d525 2
a526 2
	send_msg(&msg);
	buffer_free(&msg);
d529 1
a529 1
send_data_or_handle(char type, u_int32_t id, const char *data, int dlen)
d531 2
a532 1
	Buffer msg;
d534 8
a541 6
	buffer_init(&msg);
	buffer_put_char(&msg, type);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, data, dlen);
	send_msg(&msg);
	buffer_free(&msg);
d545 1
a545 1
send_data(u_int32_t id, const char *data, int dlen)
d554 1
a554 1
	char *string;
d566 2
a567 2
	Buffer msg;
	int i;
d569 6
a574 4
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_NAME);
	buffer_put_int(&msg, id);
	buffer_put_int(&msg, count);
d577 4
a580 3
		buffer_put_cstring(&msg, stats[i].name);
		buffer_put_cstring(&msg, stats[i].long_name);
		encode_attrib(&msg, &stats[i].attrib);
d582 2
a583 2
	send_msg(&msg);
	buffer_free(&msg);
d589 2
a590 1
	Buffer msg;
d593 8
a600 6
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_ATTRS);
	buffer_put_int(&msg, id);
	encode_attrib(&msg, a);
	send_msg(&msg);
	buffer_free(&msg);
d606 1
a606 1
	Buffer msg;
d608 1
d613 18
a630 16
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_EXTENDED_REPLY);
	buffer_put_int(&msg, id);
	buffer_put_int64(&msg, st->f_bsize);
	buffer_put_int64(&msg, st->f_frsize);
	buffer_put_int64(&msg, st->f_blocks);
	buffer_put_int64(&msg, st->f_bfree);
	buffer_put_int64(&msg, st->f_bavail);
	buffer_put_int64(&msg, st->f_files);
	buffer_put_int64(&msg, st->f_ffree);
	buffer_put_int64(&msg, st->f_favail);
	buffer_put_int64(&msg, st->f_fsid);
	buffer_put_int64(&msg, flag);
	buffer_put_int64(&msg, st->f_namemax);
	send_msg(&msg);
	buffer_free(&msg);
d638 2
a639 1
	Buffer msg;
d641 2
a642 1
	version = get_int();
d644 22
a665 20
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_VERSION);
	buffer_put_int(&msg, SSH2_FILEXFER_VERSION);
	/* POSIX rename extension */
	buffer_put_cstring(&msg, "posix-rename@@openssh.com");
	buffer_put_cstring(&msg, "1"); /* version */
	/* statvfs extension */
	buffer_put_cstring(&msg, "statvfs@@openssh.com");
	buffer_put_cstring(&msg, "2"); /* version */
	/* fstatvfs extension */
	buffer_put_cstring(&msg, "fstatvfs@@openssh.com");
	buffer_put_cstring(&msg, "2"); /* version */
	/* hardlink extension */
	buffer_put_cstring(&msg, "hardlink@@openssh.com");
	buffer_put_cstring(&msg, "1"); /* version */
	/* fsync extension */
	buffer_put_cstring(&msg, "fsync@@openssh.com");
	buffer_put_cstring(&msg, "1"); /* version */
	send_msg(&msg);
	buffer_free(&msg);
d672 1
a672 1
	Attrib *a;
d674 6
a679 1
	int handle, fd, flags, mode, status = SSH2_FX_FAILURE;
a680 2
	name = get_string(NULL);
	pflags = get_int();		/* portable flags */
a681 1
	a = get_attrib();
d683 1
a683 1
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a->perm : 0666;
d690 1
a690 1
	  	status = SSH2_FX_PERMISSION_DENIED;
d713 4
a716 1
	int handle, ret, status = SSH2_FX_FAILURE;
a717 1
	handle = get_handle();
d728 1
a728 1
	char buf[64*1024];
d730 1
a730 1
	int handle, fd, ret, status = SSH2_FX_FAILURE;
d733 4
a736 3
	handle = get_handle();
	off = get_int64();
	len = get_int();
d770 8
a777 7
	u_int len;
	int handle, fd, ret, status;
	char *data;

	handle = get_handle();
	off = get_int64();
	data = get_string(&len);
d779 1
a779 1
	debug("request %u: write \"%s\" (handle %d) off %llu len %d",
d782 1
a782 1
	
d815 4
a818 1
	int ret, status = SSH2_FX_FAILURE;
a819 1
	name = get_string(NULL);
d822 2
a823 2
	ret = do_lstat ? lstat(name, &st) : stat(name, &st);
	if (ret < 0) {
d852 1
a852 1
	int fd, ret, handle, status = SSH2_FX_FAILURE;
d854 2
a855 1
	handle = get_handle();
d860 2
a861 2
		ret = fstat(fd, &st);
		if (ret < 0) {
d888 1
a888 1
	Attrib *a;
d890 5
a894 1
	int status = SSH2_FX_OK, ret;
a895 2
	name = get_string(NULL);
	a = get_attrib();
d897 1
a897 1
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
d899 3
a901 3
		    name, (unsigned long long)a->size);
		ret = truncate(name, a->size);
		if (ret == -1)
d904 4
a907 4
	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
		logit("set \"%s\" mode %04o", name, a->perm);
		ret = chmod(name, a->perm & 07777);
		if (ret == -1)
d910 1
a910 1
	if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
d912 1
a912 1
		time_t t = a->mtime;
d917 2
a918 2
		ret = utimes(name, attrib_to_tv(a));
		if (ret == -1)
d921 1
a921 1
	if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
d923 3
a925 3
		    (u_long)a->uid, (u_long)a->gid);
		ret = chown(name, a->uid, a->gid);
		if (ret == -1)
d935 2
a936 2
	Attrib *a;
	int handle, fd, ret;
d939 4
a942 2
	handle = get_handle();
	a = get_attrib();
d950 1
a950 1
		if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
d952 3
a954 3
			    name, (unsigned long long)a->size);
			ret = ftruncate(fd, a->size);
			if (ret == -1)
d957 4
a960 4
		if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
			logit("set \"%s\" mode %04o", name, a->perm);
			ret = fchmod(fd, a->perm & 07777);
			if (ret == -1)
d963 1
a963 1
		if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
d965 1
a965 1
			time_t t = a->mtime;
d970 2
a971 2
			ret = futimes(fd, attrib_to_tv(a));
			if (ret == -1)
d974 1
a974 1
		if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
d976 3
a978 3
			    (u_long)a->uid, (u_long)a->gid);
			ret = fchown(fd, a->uid, a->gid);
			if (ret == -1)
d990 4
a993 1
	int handle, status = SSH2_FX_FAILURE;
a994 1
	path = get_string(NULL);
d1021 4
a1024 1
	int handle;
a1025 1
	handle = get_handle();
d1075 4
a1078 2
	int status = SSH2_FX_FAILURE;
	int ret;
a1079 1
	name = get_string(NULL);
d1082 2
a1083 2
	ret = unlink(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1091 1
a1091 1
	Attrib *a;
d1093 5
a1097 1
	int ret, mode, status = SSH2_FX_FAILURE;
d1099 2
a1100 4
	name = get_string(NULL);
	a = get_attrib();
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ?
	    a->perm & 07777 : 0777;
d1103 2
a1104 2
	ret = mkdir(name, mode);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1113 4
a1116 1
	int ret, status;
a1117 1
	name = get_string(NULL);
d1120 2
a1121 2
	ret = rmdir(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1131 4
a1135 1
	path = get_string(NULL);
d1157 1
a1157 1
	int status;
d1160 4
a1163 2
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
d1209 1
a1209 1
	int len;
d1213 3
a1215 1
	path = get_string(NULL);
d1235 5
a1239 1
	int ret, status;
a1240 2
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
d1244 2
a1245 2
	ret = symlink(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1255 5
a1259 1
	int ret, status;
a1260 2
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
d1263 2
a1264 2
	ret = rename(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1275 1
d1277 2
a1278 1
	path = get_string(NULL);
d1292 1
a1292 1
	int handle, fd;
d1295 2
a1296 1
	handle = get_handle();
d1313 5
a1317 1
	int ret, status;
a1318 2
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
d1321 2
a1322 2
	ret = link(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1331 1
a1331 1
	int handle, fd, ret, status = SSH2_FX_OP_UNSUPPORTED;
d1333 2
a1334 1
	handle = get_handle();
d1340 2
a1341 2
		ret = fsync(fd);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1350 1
a1350 1
	u_int i;
d1352 2
a1353 1
	request = get_string(NULL);
d1375 6
a1380 2
	u_int msg_len, buf_len, consumed, type, i;
	u_char *cp;
d1383 1
a1383 1
	buf_len = buffer_len(&iqueue);
d1386 1
a1386 1
	cp = buffer_ptr(&iqueue);
d1395 2
a1396 1
	buffer_consume(&iqueue, 4);
d1398 2
a1399 1
	type = buffer_get_char(&iqueue);
d1409 2
a1410 1
		id = get_int();
d1416 2
a1417 1
		id = get_int();
d1433 1
a1433 1
	if (buf_len < buffer_len(&iqueue)) {
d1437 1
a1437 1
	consumed = buf_len - buffer_len(&iqueue);
d1442 3
a1444 2
	if (msg_len > consumed)
		buffer_consume(&iqueue, msg_len - consumed);
d1477 1
a1477 1
	int i, in, out, max, ch, skipargs = 0, log_stderr = 0;
d1582 4
a1585 2
	buffer_init(&iqueue);
	buffer_init(&oqueue);
d1607 3
a1609 2
		if (buffer_check_alloc(&iqueue, sizeof(buf)) &&
		    buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
d1611 3
d1615 1
a1615 1
		olen = buffer_len(&oqueue);
d1635 3
a1637 2
			} else {
				buffer_append(&iqueue, buf, len);
d1642 1
a1642 1
			len = write(out, buffer_ptr(&oqueue), olen);
d1646 3
a1648 2
			} else {
				buffer_consume(&oqueue, len);
d1657 2
a1658 1
		if (buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
d1660 3
@


1.102
log
@fsync@@openssh.com protocol extension for sftp-server
client support to allow calling fsync() faster successful transfer
patch mostly by imorgan AT nas.nasa.gov; bz#1798
"fine" markus@@ "grumble OK" deraadt@@ "doesn't sound bad to me" millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.101 2013/10/14 23:28:23 djm Exp $ */
d1231 2
a1232 2
	debug3("request %u: statfs", id);
	logit("statfs \"%s\"", path);
@


1.101
log
@refactor client config code a little:

add multistate option partsing to readconf.c, similar to servconf.c's
existing code.

move checking of options that accept "none" as an argument to readconf.c

add a lowercase() function and use it instead of explicit tolower() in
loops

part of a larger diff that was ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.100 2013/10/14 14:18:56 jmc Exp $ */
d106 1
d147 1
d648 3
d1275 17
@


1.100
log
@tweak previous;
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.99 2013/10/10 00:53:25 djm Exp $ */
d224 2
d252 2
d277 1
d301 1
a301 1
handle_new(int use, const char *name, int fd, DIR *dirp)
d319 1
d382 8
d676 1
a676 1
			handle = handle_new(HANDLE_FILE, name, fd, NULL);
d762 2
a763 1
		if (lseek(fd, off, SEEK_SET) < 0) {
d968 1
a968 1
		handle = handle_new(HANDLE_DIR, path, 0, dirp);
@


1.99
log
@add -Q, -P and -p to usage() before jmc@@ catches me
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.98 2013/10/09 23:42:17 djm Exp $ */
d1367 4
a1370 3
	    "[-l log_level]\n\t[-p request_whitelist] [-P request_blacklist] "
	    "[-Q feature] [-u umask]\n",
	    __progname);
@


1.98
log
@Add ability to whitelist and/or blacklist sftp protocol requests by name.
Refactor dispatch loop and consolidate read-only mode checks.
Make global variables static, since sftp-server is linked into sshd(8).

ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.97 2013/05/17 00:13:14 djm Exp $ */
d1367 2
a1368 1
	    "[-l log_level]\n\t[-u umask]\n",
@


1.97
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.96 2013/01/04 19:26:38 jmc Exp $ */
d40 1
d52 1
a52 1
LogLevel log_level = SYSLOG_LEVEL_ERROR;
d55 2
a56 2
struct passwd *pw = NULL;
char *client_addr = NULL;
d59 2
a60 2
Buffer iqueue;
Buffer oqueue;
d63 4
a66 1
u_int version;
d69 4
a72 1
int readonly;
a74 1

d83 94
d637 1
a637 1
process_open(void)
d639 1
a639 1
	u_int32_t id, pflags;
a643 1
	id = get_int();
d653 5
a657 3
	    ((flags & O_ACCMODE) == O_WRONLY || (flags & O_ACCMODE) == O_RDWR))
		status = SSH2_FX_PERMISSION_DENIED;
	else {
d677 1
a677 1
process_close(void)
a678 1
	u_int32_t id;
a680 1
	id = get_int();
d690 1
a690 1
process_read(void)
d693 1
a693 1
	u_int32_t id, len;
a696 1
	id = get_int();
d730 1
a730 1
process_write(void)
a731 1
	u_int32_t id;
a736 1
	id = get_int();
a746 2
	else if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
d771 1
a771 1
process_do_stat(int do_lstat)
a774 1
	u_int32_t id;
a777 1
	id = get_int();
d795 1
a795 1
process_stat(void)
d797 1
a797 1
	process_do_stat(0);
d801 1
a801 1
process_lstat(void)
d803 1
a803 1
	process_do_stat(1);
d807 1
a807 1
process_fstat(void)
a810 1
	u_int32_t id;
a812 1
	id = get_int();
d844 1
a844 1
process_setstat(void)
a846 1
	u_int32_t id;
a849 1
	id = get_int();
a852 4
	if (readonly) {
		status = SSH2_FX_PERMISSION_DENIED;
		a->flags = 0;
	}
d889 1
a889 1
process_fsetstat(void)
a891 1
	u_int32_t id;
a894 1
	id = get_int();
a900 2
	else if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
d940 1
a940 1
process_opendir(void)
a944 1
	u_int32_t id;
a945 1
	id = get_int();
d968 1
a968 1
process_readdir(void)
a973 1
	u_int32_t id;
a974 1
	id = get_int();
d1022 1
a1022 1
process_remove(void)
a1024 1
	u_int32_t id;
a1027 1
	id = get_int();
d1031 2
a1032 6
	if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
	else {
		ret = unlink(name);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
d1038 1
a1038 1
process_mkdir(void)
a1040 1
	u_int32_t id;
a1043 1
	id = get_int();
d1050 2
a1051 6
	if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
	else {
		ret = mkdir(name, mode);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
d1057 1
a1057 1
process_rmdir(void)
a1058 1
	u_int32_t id;
a1061 1
	id = get_int();
d1065 2
a1066 6
	if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
	else {
		ret = rmdir(name);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
d1072 1
a1072 1
process_realpath(void)
a1074 1
	u_int32_t id;
a1076 1
	id = get_int();
d1096 1
a1096 1
process_rename(void)
a1097 1
	u_int32_t id;
a1101 1
	id = get_int();
d1107 1
a1107 3
	if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
	else if (lstat(oldpath, &sb) == -1)
d1147 1
a1147 1
process_readlink(void)
a1148 1
	u_int32_t id;
a1152 1
	id = get_int();
d1170 1
a1170 1
process_symlink(void)
a1171 1
	u_int32_t id;
a1174 1
	id = get_int();
d1180 2
a1181 6
	if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
	else {
		ret = symlink(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
d1197 2
a1198 6
	if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
	else {
		ret = rename(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
d1250 2
a1251 6
	if (readonly)
		status = SSH2_FX_PERMISSION_DENIED;
	else {
		ret = link(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
d1258 1
a1258 1
process_extended(void)
a1259 1
	u_int32_t id;
d1261 1
a1262 1
	id = get_int();
d1264 11
a1274 9
	if (strcmp(request, "posix-rename@@openssh.com") == 0)
		process_extended_posix_rename(id);
	else if (strcmp(request, "statvfs@@openssh.com") == 0)
		process_extended_statvfs(id);
	else if (strcmp(request, "fstatvfs@@openssh.com") == 0)
		process_extended_fstatvfs(id);
	else if (strcmp(request, "hardlink@@openssh.com") == 0)
		process_extended_hardlink(id);
	else
d1276 1
d1285 1
a1285 4
	u_int msg_len;
	u_int buf_len;
	u_int consumed;
	u_int type;
d1287 1
d1304 1
d1308 1
a1308 54
		break;
	case SSH2_FXP_OPEN:
		process_open();
		break;
	case SSH2_FXP_CLOSE:
		process_close();
		break;
	case SSH2_FXP_READ:
		process_read();
		break;
	case SSH2_FXP_WRITE:
		process_write();
		break;
	case SSH2_FXP_LSTAT:
		process_lstat();
		break;
	case SSH2_FXP_FSTAT:
		process_fstat();
		break;
	case SSH2_FXP_SETSTAT:
		process_setstat();
		break;
	case SSH2_FXP_FSETSTAT:
		process_fsetstat();
		break;
	case SSH2_FXP_OPENDIR:
		process_opendir();
		break;
	case SSH2_FXP_READDIR:
		process_readdir();
		break;
	case SSH2_FXP_REMOVE:
		process_remove();
		break;
	case SSH2_FXP_MKDIR:
		process_mkdir();
		break;
	case SSH2_FXP_RMDIR:
		process_rmdir();
		break;
	case SSH2_FXP_REALPATH:
		process_realpath();
		break;
	case SSH2_FXP_STAT:
		process_stat();
		break;
	case SSH2_FXP_RENAME:
		process_rename();
		break;
	case SSH2_FXP_READLINK:
		process_readlink();
		break;
	case SSH2_FXP_SYMLINK:
		process_symlink();
d1311 4
a1314 1
		process_extended();
d1317 16
a1332 2
		error("Unknown message %d", type);
		break;
d1341 1
a1341 1
		error("msg_len %d < consumed %d", msg_len, consumed);
d1376 1
a1376 1
	int in, out, max, ch, skipargs = 0, log_stderr = 0;
d1389 2
a1390 1
	while (!skipargs && (ch = getopt(argc, argv, "d:f:l:u:cehR")) != -1) {
d1392 11
d1431 10
@


1.96
log
@sftp-server.8: add argument name to -d
sftp-server.c: add -d to usage()

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.95 2013/01/03 12:54:49 djm Exp $ */
d313 1
a313 1
		xfree(handles[handle].name);
d317 1
a317 1
		xfree(handles[handle].name);
d361 1
a361 1
	xfree(handle);
d444 1
a444 1
	xfree(string);
d572 1
a572 1
	xfree(name);
d673 1
a673 1
	xfree(data);
d699 1
a699 1
	xfree(name);
d801 1
a801 1
	xfree(name);
d886 1
a886 1
	xfree(path);
d935 2
a936 2
				xfree(stats[i].name);
				xfree(stats[i].long_name);
d941 1
a941 1
		xfree(stats);
d964 1
a964 1
	xfree(name);
d989 1
a989 1
	xfree(name);
d1010 1
a1010 1
	xfree(name);
d1023 1
a1023 1
		xfree(path);
d1036 1
a1036 1
	xfree(path);
d1090 2
a1091 2
	xfree(oldpath);
	xfree(newpath);
d1116 1
a1116 1
	xfree(path);
d1139 2
a1140 2
	xfree(oldpath);
	xfree(newpath);
d1160 2
a1161 2
	xfree(oldpath);
	xfree(newpath);
d1178 1
a1178 1
        xfree(path);
d1217 2
a1218 2
	xfree(oldpath);
	xfree(newpath);
d1239 1
a1239 1
	xfree(request);
@


1.95
log
@allow specification of an alternate start directory for sftp-server(8)
"I like this" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.94 2011/06/17 21:46:16 djm Exp $ */
d1365 2
a1366 1
	    "usage: %s [-ehR] [-f log_facility] [-l log_level] [-u umask]\n",
@


1.94
log
@the protocol version should be unsigned; bz#1913 reported by mb AT
smartftp.com
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.93 2010/12/04 00:18:01 djm Exp $ */
d1377 1
a1377 1
	char *cp, buf[4*4096];
d1385 3
a1387 1
	while (!skipargs && (ch = getopt(argc, argv, "f:l:u:cehR")) != -1) {
d1412 6
a1444 2
	pw = pwcopy(user_pw);

d1463 7
@


1.93
log
@add a protocol extension to support a hard link operation. It is
available through the "ln" command in the client. The old "ln"
behaviour of creating a symlink is available using its "-s" option
or through the preexisting "symlink" command; based on a patch from
miklos AT szeredi.hu in bz#1555; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.92 2010/11/04 02:45:34 djm Exp $ */
d62 1
a62 1
int version;
d516 1
a516 1
	verbose("received client version %d", version);
@


1.92
log
@umask should be parsed as octal. reported by candland AT xmission.com;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.91 2010/01/13 01:40:16 djm Exp $ */
d529 3
d1201 21
d1235 2
@


1.91
log
@support '-h' (human-readable units) for sftp's ls command, just like
ls(1); ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.90 2010/01/09 00:20:26 djm Exp $ */
d1352 1
a1352 2
	const char *errmsg;
	mode_t mask;
d1385 6
a1390 5
			mask = (mode_t)strtonum(optarg, 0, 0777, &errmsg);
			if (errmsg != NULL)
				fatal("Invalid umask \"%s\": %s",
				    optarg, errmsg);
			(void)umask(mask);
@


1.90
log
@add a 'read-only' mode to sftp-server(8) that disables open in write mode
and all other fs-modifying protocol methods. bz#430 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.89 2010/01/04 02:25:15 djm Exp $ */
d922 1
a922 1
			stats[count].long_name = ls_file(dp->d_name, &st, 0);
@


1.89
log
@bz#1566 don't unnecessarily dup() in and out fds for sftp-server; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.88 2009/10/17 12:10:39 sobrado Exp $ */
d64 3
d550 7
a556 7
	fd = open(name, flags, mode);
	if (fd < 0) {
		status = errno_to_portable(errno);
	} else {
		handle = handle_new(HANDLE_FILE, name, fd, NULL);
		if (handle < 0) {
			close(fd);
d558 7
a564 2
			send_handle(id, handle);
			status = SSH2_FX_OK;
d634 1
a634 1
	int handle, fd, ret, status = SSH2_FX_FAILURE;
d645 6
a650 1
	if (fd >= 0) {
d665 1
d762 4
d814 1
a814 1
	if (fd < 0) {
d816 3
a818 1
	} else {
d954 6
a959 2
	ret = unlink(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d979 6
a984 2
	ret = mkdir(name, mode);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1000 6
a1005 2
	ret = rmdir(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1050 3
a1052 1
	if (lstat(oldpath, &sb) == -1)
d1129 6
a1134 2
	ret = symlink(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d1144 1
d1150 7
a1156 4
	if (rename(oldpath, newpath) == -1)
		send_status(id, errno_to_portable(errno));
	else
		send_status(id, SSH2_FX_OK);
d1339 1
a1339 1
	    "usage: %s [-eh] [-f log_facility] [-l log_level] [-u umask]\n",
d1360 1
a1360 1
	while (!skipargs && (ch = getopt(argc, argv, "f:l:u:che")) != -1) {
d1362 3
@


1.88
log
@sort flags.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.87 2009/08/31 20:56:02 djm Exp $ */
d1371 2
a1372 2
	in = dup(STDIN_FILENO);
	out = dup(STDOUT_FILENO);
@


1.87
log
@check correct variable for error message, spotted by martynas@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.86 2009/08/27 17:28:52 djm Exp $ */
d1297 1
a1297 1
	    "usage: %s [-he] [-l log_level] [-f log_facility] [-u umask]\n",
@


1.86
log
@allow setting an explicit umask on the commandline to override whatever
default the user has. bz#1229; ok dtucker@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.85 2009/04/14 16:33:42 stevesk Exp $ */
d1342 1
a1342 1
			if (cp != NULL)
@


1.85
log
@remove unused option character from getopt() optstring; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.84 2008/06/26 06:10:09 djm Exp $ */
d1297 2
a1298 1
	    "usage: %s [-he] [-l log_level] [-f log_facility]\n", __progname);
d1310 2
d1318 1
a1318 1
	while (!skipargs && (ch = getopt(argc, argv, "f:l:che")) != -1) {
d1339 7
@


1.84
log
@allow the sftp chmod(2)-equivalent operation to set set[ug]id/sticky
bits. Note that this only affects explicit setting of modes (e.g. via
sftp(1)'s chmod command) and not file transfers. (bz#1310)
ok deraadt@@ at c2k8
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.83 2008/06/09 13:02:39 dtucker Exp $ */
d1315 1
a1315 1
	while (!skipargs && (ch = getopt(argc, argv, "C:f:l:che")) != -1) {
@


1.83
log
@Extend 32bit -> 64bit values for statvfs extension missed in previous commit.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.82 2008/06/08 17:04:41 dtucker Exp $ */
d757 1
a757 1
		ret = chmod(name, a->perm & 0777);
d810 1
a810 1
			ret = fchmod(fd, a->perm & 0777);
d952 1
a952 1
	    a->perm & 0777 : 0777;
@


1.82
log
@Add case for ENOSYS in errno_to_portable; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.81 2008/06/07 21:52:46 djm Exp $ */
d490 2
a491 2
	buffer_put_int(&msg, st->f_bsize);
	buffer_put_int(&msg, st->f_frsize);
d499 2
a500 2
	buffer_put_int(&msg, flag);
	buffer_put_int(&msg, st->f_namemax);
@


1.81
log
@statvfs member fsid needs to be wider, increase it to 64 bits and
crank extension revision number to 2; prodded and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.80 2008/05/18 21:29:05 djm Exp $ */
d97 3
@


1.80
log
@comment extension announcement
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.79 2008/04/18 12:32:11 djm Exp $ */
d495 1
a495 1
	buffer_put_int(&msg, st->f_fsid);
d519 1
a519 1
	buffer_put_cstring(&msg, "1"); /* version */
d522 1
a522 1
	buffer_put_cstring(&msg, "1"); /* version */
@


1.79
log
@introduce sftp extension methods statvfs@@openssh.com and
fstatvfs@@openssh.com that implement statvfs(2)-like operations,
based on a patch from miklos AT szeredi.hu (bz#1399)

also add a "df" command to the sftp client that uses the
statvfs@@openssh.com to produce a df(1)-like display of filesystem
space and inode utilisation

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.78 2008/02/27 20:21:15 djm Exp $ */
d517 1
d520 1
@


1.78
log
@add an extension method "posix-rename@@openssh.com" to perform POSIX atomic
rename() operations. based on patch from miklos AT szeredi.hu in bz#1400;
ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.77 2008/02/08 23:24:07 djm Exp $ */
d22 2
d475 27
d517 4
d1115 36
d1160 4
@


1.77
log
@add sshd_config ChrootDirectory option to chroot(2) users to a directory and
tweak internal sftp server to work with it (no special files in chroot
required). ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.76 2008/02/04 21:53:00 markus Exp $ */
d485 3
d1065 17
d1089 4
a1092 1
	send_status(id, SSH2_FX_OP_UNSUPPORTED);		/* MUST */
@


1.76
log
@link sftp-server into sshd; feedback and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.75 2008/01/21 17:24:30 djm Exp $ */
d1201 1
a1201 1
sftp_server_main(int argc, char **argv)
a1211 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d1255 1
a1255 5
	if ((pw = getpwuid(getuid())) == NULL) {
		error("No user found for uid %lu", (u_long)getuid());
		sftp_server_cleanup_exit(255);
	}
	pw = pwcopy(pw);
@


1.75
log
@Remove the fixed 100 handle limit in sftp-server and allocate as many
as we have available file descriptors. Patch from miklos AT szeredi.hu;
ok dtucker@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.74 2007/09/13 04:39:04 djm Exp $ */
d1092 1
a1092 1
		cleanup_exit(11);
d1165 4
a1168 2
	if (buf_len < buffer_len(&iqueue))
		fatal("iqueue grew unexpectedly");
d1170 4
a1173 2
	if (msg_len < consumed)
		fatal("msg_len %d < consumed %d", msg_len, consumed);
d1180 1
a1180 1
cleanup_exit(int i)
d1191 1
a1191 1
usage(void)
d1201 1
a1201 1
main(int argc, char **argv)
d1241 1
a1241 1
			usage();
d1249 2
a1250 2
		if ((cp = strchr(client_addr, ' ')) == NULL)
			fatal("Malformed SSH_CONNECTION variable: \"%s\"",
d1252 2
d1258 4
a1261 2
	if ((pw = getpwuid(getuid())) == NULL)
		fatal("No user found for uid %lu", (u_long)getuid());
d1304 1
a1304 1
			cleanup_exit(2);
d1312 1
a1312 1
				cleanup_exit(0);
d1315 1
a1315 1
				cleanup_exit(1);
d1325 1
a1325 1
				cleanup_exit(1);
@


1.74
log
@fix incorrect test when setting syslog facility; from Jan Pechanec
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.73 2007/05/17 07:55:29 djm Exp $ */
d167 1
d176 9
a184 9
Handle	handles[100];

static void
handle_init(void)
{
	u_int i;

	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
		handles[i].use = HANDLE_UNUSED;
d190 18
a207 1
	u_int i;
d209 1
a209 11
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++) {
		if (handles[i].use == HANDLE_UNUSED) {
			handles[i].use = use;
			handles[i].dirp = dirp;
			handles[i].fd = fd;
			handles[i].name = xstrdup(name);
			handles[i].bytes_read = handles[i].bytes_write = 0;
			return i;
		}
	}
	return -1;
d215 1
a215 2
	return i >= 0 && (u_int)i < sizeof(handles)/sizeof(Handle) &&
	    handles[i].use == type;
a304 1
		handles[handle].use = HANDLE_UNUSED;
d306 1
a308 1
		handles[handle].use = HANDLE_UNUSED;
d310 1
d338 1
a338 1
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
a1257 2

	handle_init();
@


1.73
log
@bz#1286 stop reading and processing commands when input or output buffer
is nearly full, otherwise sftp-server would happily try to grow the
input/output buffers past the maximum supported by the buffer API and
promptly fatal()
based on patch from Thue Janus Kristensen; feedback & ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.72 2007/04/18 01:12:43 stevesk Exp $ */
d1225 1
a1225 1
			if (log_level == SYSLOG_FACILITY_NOT_SET)
@


1.72
log
@cast "%llu" format spec to (unsigned long long); do not assume a
u_int64_t arg is the same as 'unsigned long long'.

from Dmitry V. Levin <ldv@@altlinux.org>

ok markus@@ 'Yes, that looks correct' millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.71 2007/01/03 07:22:36 stevesk Exp $ */
d1196 1
a1196 1
	char *cp;
d1274 9
a1282 1
		FD_SET(in, rset);
a1295 1
			char buf[4*4096];
d1317 8
a1324 2
		/* process requests from client */
		process();
@


1.71
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.70 2006/08/03 03:34:42 deraadt Exp $ */
d317 2
a318 1
		    handle_bytes_read(handle), handle_bytes_write(handle));
d701 2
a702 1
		logit("set \"%s\" size %llu", name, a->size);
d754 2
a755 1
			logit("set \"%s\" size %llu", name, a->size);
@


1.70
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.69 2006/08/01 23:22:47 stevesk Exp $ */
d661 1
a661 1
	if (fd  >= 0) {
@


1.69
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.68 2006/07/26 13:57:17 stevesk Exp $ */
a16 1
#include "includes.h"
d29 1
d32 1
d34 1
a35 1
#include "bufaux.h"
a36 1
#include "xmalloc.h"
d135 1
a135 1
		strlcat(ret, str, sizeof(ret)); 	\
d1208 1
a1208 1
			 * shell using "sftp-server -c command" 
@


1.68
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.67 2006/07/26 02:35:17 stevesk Exp $ */
d28 1
@


1.67
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.66 2006/07/25 02:59:21 stevesk Exp $ */
d27 1
@


1.66
log
@move #include <sys/time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.65 2006/07/22 20:48:23 stevesk Exp $ */
d22 1
@


1.65
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.64 2006/07/22 19:08:54 stevesk Exp $ */
d21 1
@


1.64
log
@move #include <time.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.63 2006/07/17 01:31:09 stevesk Exp $ */
d25 1
@


1.63
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.62 2006/07/11 20:07:25 stevesk Exp $ */
d25 1
@


1.62
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.61 2006/07/10 11:25:53 djm Exp $ */
d25 1
@


1.61
log
@don't log variables that aren't yet set
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.60 2006/07/10 11:24:54 djm Exp $ */
d23 1
@


1.60
log
@remove optind - it isn't used here
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.59 2006/07/09 15:15:11 stevesk Exp $ */
a481 1
	debug3("request %u: open flags %d", id, pflags);
d484 1
@


1.59
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.58 2006/07/06 10:47:57 djm Exp $ */
a1186 1
	extern int optind;
@


1.58
log
@add commandline options to enable logging of transactions; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.57 2006/03/30 09:58:16 djm Exp $ */
d23 1
@


1.57
log
@replace {GET,PUT}_XXBIT macros with functionally similar functions,
silencing a heap of lint warnings. also allows them to use
__bounded__ checking which can't be applied to macros; requested
by and feedback from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.56 2006/03/25 13:17:02 djm Exp $ */
d29 1
d38 7
a44 1
#define TRACE				debug
d116 27
d157 1
d188 1
d252 30
d301 25
d352 2
a353 2
static void
send_status(u_int32_t id, u_int32_t status)
a354 1
	Buffer msg;
d367 2
d370 9
a378 1
	TRACE("sent status id %u error %u", id, status);
d384 1
a384 2
		buffer_put_cstring(&msg,
		    status_messages[MIN(status,SSH2_FX_MAX)]);
d406 1
a406 1
	TRACE("sent data id %u len %d", id, dlen);
d417 1
a417 1
	TRACE("sent handle id %u handle %d", id, handle);
d432 1
a432 1
	TRACE("sent names id %u count %d", id, count);
d447 1
a447 1
	TRACE("sent attrib id %u have 0x%x", id, a->flags);
d464 1
a464 1
	TRACE("client version %d", version);
d481 1
d487 2
a488 1
	TRACE("open id %u name %s flags %d mode 0%o", id, name, pflags, mode);
d514 2
a515 1
	TRACE("close id %u handle %d", id, handle);
d534 2
a535 2
	TRACE("read id %u handle %d off %llu len %d", id, handle,
	    (unsigned long long)off, len);
d538 1
a538 1
		logit("read change len %d", len);
d554 1
d576 2
a577 2
	TRACE("write id %u handle %d off %llu len %d", id, handle,
	    (unsigned long long)off, len);
d591 1
d593 1
a593 1
				logit("nothing at all written");
d612 2
a613 1
	TRACE("%sstat id %u name %s", do_lstat ? "l" : "", id, name);
d649 2
a650 1
	TRACE("fstat id %u handle %d", id, handle);
d689 1
a689 1
	TRACE("setstat id %u name %s", id, name);
d691 1
d697 1
d703 6
d714 2
d735 1
a735 1
	TRACE("fsetstat id %u handle %d", id, handle);
d740 2
d743 1
d749 1
d755 6
d766 2
d786 2
a787 1
	TRACE("opendir id %u path %s", id, path);
d817 2
a818 1
	TRACE("readdir id %u handle %d", id, handle);
d825 1
a825 1
		char pathname[1024];
d872 2
a873 1
	TRACE("remove id %u name %s", id, name);
d893 2
a894 1
	TRACE("mkdir id %u name %s mode 0%o", id, name, mode);
d910 2
a911 1
	TRACE("rmdir id %u name %s", id, name);
d931 2
a932 1
	TRACE("realpath id %u path %s", id, path);
d955 2
a956 1
	TRACE("rename id %u old %s new %s", id, oldpath, newpath);
d1007 2
a1008 1
	TRACE("readlink id %u path %s", id, path);
d1032 2
a1033 1
	TRACE("symlink id %u old %s new %s", id, oldpath, newpath);
d1071 3
a1073 2
		error("bad message ");
		exit(11);
d1147 1
a1147 1
		fatal("iqueue grows");
d1155 22
d1178 1
a1178 1
main(int ac, char **av)
d1181 1
a1181 1
	int in, out, max;
d1183 6
d1193 47
a1239 1
	/* XXX should use getopt */
a1242 4
#ifdef DEBUG_SFTP_SERVER
	log_init("sftp-server", SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 0);
#endif

d1271 2
a1272 1
			exit(2);
d1281 1
a1281 1
				exit(0);
d1283 2
a1284 2
				error("read error");
				exit(1);
d1293 2
a1294 2
				error("write error");
				exit(1);
@


1.56
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a25 1
#include "getput.h"
d172 1
a172 1
	PUT_32BIT(*stringp, handle);
d184 1
a184 1
	val = GET_32BIT(handle);
d932 1
a932 1
	msg_len = GET_32BIT(cp);
@


1.55
log
@change OpenSSH's xrealloc() function from being xrealloc(p, new_size) to
xrealloc(p, new_nmemb, new_itemsize).

realloc is particularly prone to integer overflows because it is almost
always allocating "n * size" bytes, so this is a far safer API;
ok deraadt@@
@
text
@d1 1
@


1.54
log
@introduce xcalloc() and xasprintf() failure-checked allocations functions
and use them throughout openssh

xcalloc is particularly important because malloc(nmemb * size) is a
dangerous idiom (subject to integer overflow) and it is time for it to
die

feedback and ok deraadt@@
@
text
@d703 1
a703 1
				stats = xrealloc(stats, nstats * sizeof(Stat));
@


1.53
log
@RCSID() can die
@
text
@d699 1
a699 1
		stats = xmalloc(nstats * sizeof(Stat));
@


1.52
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@a16 1
RCSID("$OpenBSD: sftp-server.c,v 1.51 2006/02/08 23:51:24 stevesk Exp $");
@


1.52.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sftp-server.c,v 1.70 2006/08/03 03:34:42 deraadt Exp $ */
d16 2
a20 2
#include <sys/time.h>
#include <sys/param.h>
a22 9
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>
#include <time.h>
#include <unistd.h>
#include <stdarg.h>
a23 1
#include "xmalloc.h"
d25 2
d28 1
a29 1
#include "uidswap.h"
d38 1
a38 7

/* Our verbosity */
LogLevel log_level = SYSLOG_LEVEL_ERROR;

/* Our client */
struct passwd *pw = NULL;
char *client_addr = NULL;
a109 27
static const char *
string_from_portable(int pflags)
{
	static char ret[128];

	*ret = '\0';

#define PAPPEND(str)	{				\
		if (*ret != '\0')			\
			strlcat(ret, ",", sizeof(ret));	\
		strlcat(ret, str, sizeof(ret));		\
	}

	if (pflags & SSH2_FXF_READ)
		PAPPEND("READ")
	if (pflags & SSH2_FXF_WRITE)
		PAPPEND("WRITE")
	if (pflags & SSH2_FXF_CREAT)
		PAPPEND("CREATE")
	if (pflags & SSH2_FXF_TRUNC)
		PAPPEND("TRUNCATE")
	if (pflags & SSH2_FXF_EXCL)
		PAPPEND("EXCL")

	return ret;
}

a123 1
	u_int64_t bytes_read, bytes_write;
a153 1
			handles[i].bytes_read = handles[i].bytes_write = 0;
d173 1
a173 1
	put_u32(*stringp, handle);
d185 1
a185 1
	val = get_u32(handle);
a216 30
static void
handle_update_read(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_read += bytes;
}

static void
handle_update_write(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_write += bytes;
}

static u_int64_t
handle_bytes_read(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_read);
	return 0;
}

static u_int64_t
handle_bytes_write(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_write);
	return 0;
}

a235 25
static void
handle_log_close(int handle, char *emsg)
{
	if (handle_is_ok(handle, HANDLE_FILE)) {
		logit("%s%sclose \"%s\" bytes read %llu written %llu",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle),
		    handle_bytes_read(handle), handle_bytes_write(handle));
	} else {
		logit("%s%sclosedir \"%s\"",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle));
	}
}

static void
handle_log_exit(void)
{
	u_int i;

	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
		if (handles[i].use != HANDLE_UNUSED)
			handle_log_close(i, "forced");
}

d262 2
a263 2
static const char *
status_to_message(u_int32_t status)
d265 1
a277 2
	return (status_messages[MIN(status,SSH2_FX_MAX)]);
}
d279 1
a279 9
static void
send_status(u_int32_t id, u_int32_t status)
{
	Buffer msg;

	debug3("request %u: sent status %u", id, status);
	if (log_level > SYSLOG_LEVEL_VERBOSE ||
	    (status != SSH2_FX_OK && status != SSH2_FX_EOF))
		logit("sent status %s", status_to_message(status));
d285 2
a286 1
		buffer_put_cstring(&msg, status_to_message(status));
d308 1
a308 1
	debug("request %u: sent data len %d", id, dlen);
d319 1
a319 1
	debug("request %u: sent handle handle %d", id, handle);
d334 1
a334 1
	debug("request %u: sent names count %d", id, count);
d349 1
a349 1
	debug("request %u: sent attrib have 0x%x", id, a->flags);
d366 1
a366 1
	verbose("received client version %d", version);
a384 1
	debug3("request %u: open flags %d", id, pflags);
d388 1
a388 2
	logit("open \"%s\" flags %s mode 0%o",
	    name, string_from_portable(pflags), mode);
d414 1
a414 2
	debug3("request %u: close handle %u", id, handle);
	handle_log_close(handle, NULL);
d433 2
a434 2
	debug("request %u: read \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
d437 1
a437 1
		debug2("read change len %d", len);
a452 1
				handle_update_read(handle, ret);
d474 2
a475 2
	debug("request %u: write \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
a488 1
				handle_update_write(handle, ret);
d490 1
a490 1
				debug2("nothing at all written");
d509 1
a509 2
	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
d545 1
a545 2
	debug("request %u: fstat \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
d584 1
a584 1
	debug("request %u: setstat name \"%s\"", id, name);
a585 1
		logit("set \"%s\" size %llu", name, a->size);
a590 1
		logit("set \"%s\" mode %04o", name, a->perm);
a595 6
		char buf[64];
		time_t t = a->mtime;

		strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
		    localtime(&t));
		logit("set \"%s\" modtime %s", name, buf);
a600 2
		logit("set \"%s\" owner %lu group %lu", name,
		    (u_long)a->uid, (u_long)a->gid);
d620 1
a620 1
	debug("request %u: fsetstat handle %d", id, handle);
a624 2
		char *name = handle_to_name(handle);

a625 1
			logit("set \"%s\" size %llu", name, a->size);
a630 1
			logit("set \"%s\" mode %04o", name, a->perm);
a635 6
			char buf[64];
			time_t t = a->mtime;

			strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
			    localtime(&t));
			logit("set \"%s\" modtime %s", name, buf);
a640 2
			logit("set \"%s\" owner %lu group %lu", name,
			    (u_long)a->uid, (u_long)a->gid);
d659 1
a659 2
	debug3("request %u: opendir", id);
	logit("opendir \"%s\"", path);
d689 1
a689 2
	debug("request %u: readdir \"%s\" (handle %d)", id,
	    handle_to_name(handle), handle);
d696 1
a696 1
		char pathname[MAXPATHLEN];
d700 1
a700 1
		stats = xcalloc(nstats, sizeof(Stat));
d704 1
a704 1
				stats = xrealloc(stats, nstats, sizeof(Stat));
d743 1
a743 2
	debug3("request %u: remove", id);
	logit("remove name \"%s\"", name);
d763 1
a763 2
	debug3("request %u: mkdir", id);
	logit("mkdir name \"%s\" mode 0%o", name, mode);
d779 1
a779 2
	debug3("request %u: rmdir", id);
	logit("rmdir name \"%s\"", name);
d799 1
a799 2
	debug3("request %u: realpath", id);
	verbose("realpath \"%s\"", path);
d822 1
a822 2
	debug3("request %u: rename", id);
	logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
d873 1
a873 2
	debug3("request %u: readlink", id);
	verbose("readlink \"%s\"", path);
d897 1
a897 2
	debug3("request %u: symlink", id);
	logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
d933 1
a933 1
	msg_len = get_u32(cp);
d935 2
a936 3
		error("bad message from %s local user %s",
		    client_addr, pw->pw_name);
		cleanup_exit(11);
d1010 1
a1010 1
		fatal("iqueue grew unexpectedly");
a1017 22
/* Cleanup handler that logs active handles upon normal exit */
void
cleanup_exit(int i)
{
	if (pw != NULL && client_addr != NULL) {
		handle_log_exit();
		logit("session closed for local user %s from [%s]",
		    pw->pw_name, client_addr);
	}
	_exit(i);
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-he] [-l log_level] [-f log_facility]\n", __progname);
	exit(1);
}

d1019 1
a1019 1
main(int argc, char **argv)
d1022 1
a1022 1
	int in, out, max, ch, skipargs = 0, log_stderr = 0;
a1023 5
	SyslogFacility log_facility = SYSLOG_FACILITY_AUTH;
	char *cp;

	extern char *optarg;
	extern char *__progname;
d1028 1
a1028 1
	log_init(__progname, log_level, log_facility, log_stderr);
d1030 1
a1030 27
	while (!skipargs && (ch = getopt(argc, argv, "C:f:l:che")) != -1) {
		switch (ch) {
		case 'c':
			/*
			 * Ignore all arguments if we are invoked as a
			 * shell using "sftp-server -c command"
			 */
			skipargs = 1;
			break;
		case 'e':
			log_stderr = 1;
			break;
		case 'l':
			log_level = log_level_number(optarg);
			if (log_level == SYSLOG_LEVEL_NOT_SET)
				error("Invalid log level \"%s\"", optarg);
			break;
		case 'f':
			log_facility = log_facility_number(optarg);
			if (log_level == SYSLOG_FACILITY_NOT_SET)
				error("Invalid log facility \"%s\"", optarg);
			break;
		case 'h':
		default:
			usage();
		}
	}
d1032 3
a1034 19
	log_init(__progname, log_level, log_facility, log_stderr);

	if ((cp = getenv("SSH_CONNECTION")) != NULL) {
		client_addr = xstrdup(cp);
		if ((cp = strchr(client_addr, ' ')) == NULL)
			fatal("Malformed SSH_CONNECTION variable: \"%s\"",
			    getenv("SSH_CONNECTION"));
		*cp = '\0';
	} else
		client_addr = xstrdup("UNKNOWN");

	if ((pw = getpwuid(getuid())) == NULL)
		fatal("No user found for uid %lu", (u_long)getuid());
	pw = pwcopy(pw);

	logit("session opened for local user %s from [%s]",
	    pw->pw_name, client_addr);

	handle_init();
d1064 1
a1064 2
			error("select: %s", strerror(errno));
			cleanup_exit(2);
d1073 1
a1073 1
				cleanup_exit(0);
d1075 2
a1076 2
				error("read: %s", strerror(errno));
				cleanup_exit(1);
d1085 2
a1086 2
				error("write: %s", strerror(errno));
				cleanup_exit(1);
@


1.51
log
@move #include <dirent.h> out of includes.h; ok markus@@
@
text
@d17 4
a20 1
RCSID("$OpenBSD: sftp-server.c,v 1.50 2006/01/02 01:20:31 djm Exp $");
@


1.50
log
@use a common max. packet length, no binary change
@
text
@d17 3
a19 1
RCSID("$OpenBSD: sftp-server.c,v 1.49 2005/09/13 23:40:07 djm Exp $");
@


1.49
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.48 2005/06/17 02:44:33 djm Exp $");
d929 1
a929 1
	if (msg_len > 256 * 1024) {
@


1.48
log
@make this -Wsign-compare clean; ok avsm@@ markus@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.47 2004/06/25 05:38:48 dtucker Exp $");
d24 1
d1019 3
@


1.48.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.50 2006/01/02 01:20:31 djm Exp $");
a23 1
#include "misc.h"
d928 1
a928 1
	if (msg_len > SFTP_MAX_MSG_LENGTH) {
a1017 3

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();
@


1.48.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: sftp-server.c,v 1.70 2006/08/03 03:34:42 deraadt Exp $ */
d16 2
a18 17
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/param.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>
#include <time.h>
#include <unistd.h>
#include <stdarg.h>

#include "xmalloc.h"
d20 2
d23 1
a24 1
#include "uidswap.h"
d33 1
a33 7

/* Our verbosity */
LogLevel log_level = SYSLOG_LEVEL_ERROR;

/* Our client */
struct passwd *pw = NULL;
char *client_addr = NULL;
a104 27
static const char *
string_from_portable(int pflags)
{
	static char ret[128];

	*ret = '\0';

#define PAPPEND(str)	{				\
		if (*ret != '\0')			\
			strlcat(ret, ",", sizeof(ret));	\
		strlcat(ret, str, sizeof(ret));		\
	}

	if (pflags & SSH2_FXF_READ)
		PAPPEND("READ")
	if (pflags & SSH2_FXF_WRITE)
		PAPPEND("WRITE")
	if (pflags & SSH2_FXF_CREAT)
		PAPPEND("CREATE")
	if (pflags & SSH2_FXF_TRUNC)
		PAPPEND("TRUNCATE")
	if (pflags & SSH2_FXF_EXCL)
		PAPPEND("EXCL")

	return ret;
}

a118 1
	u_int64_t bytes_read, bytes_write;
a148 1
			handles[i].bytes_read = handles[i].bytes_write = 0;
d168 1
a168 1
	put_u32(*stringp, handle);
d180 1
a180 1
	val = get_u32(handle);
a211 30
static void
handle_update_read(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_read += bytes;
}

static void
handle_update_write(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_write += bytes;
}

static u_int64_t
handle_bytes_read(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_read);
	return 0;
}

static u_int64_t
handle_bytes_write(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_write);
	return 0;
}

a230 25
static void
handle_log_close(int handle, char *emsg)
{
	if (handle_is_ok(handle, HANDLE_FILE)) {
		logit("%s%sclose \"%s\" bytes read %llu written %llu",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle),
		    handle_bytes_read(handle), handle_bytes_write(handle));
	} else {
		logit("%s%sclosedir \"%s\"",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle));
	}
}

static void
handle_log_exit(void)
{
	u_int i;

	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
		if (handles[i].use != HANDLE_UNUSED)
			handle_log_close(i, "forced");
}

d257 2
a258 2
static const char *
status_to_message(u_int32_t status)
d260 1
a272 7
	return (status_messages[MIN(status,SSH2_FX_MAX)]);
}

static void
send_status(u_int32_t id, u_int32_t status)
{
	Buffer msg;
d274 1
a274 4
	debug3("request %u: sent status %u", id, status);
	if (log_level > SYSLOG_LEVEL_VERBOSE ||
	    (status != SSH2_FX_OK && status != SSH2_FX_EOF))
		logit("sent status %s", status_to_message(status));
d280 2
a281 1
		buffer_put_cstring(&msg, status_to_message(status));
d303 1
a303 1
	debug("request %u: sent data len %d", id, dlen);
d314 1
a314 1
	debug("request %u: sent handle handle %d", id, handle);
d329 1
a329 1
	debug("request %u: sent names count %d", id, count);
d344 1
a344 1
	debug("request %u: sent attrib have 0x%x", id, a->flags);
d361 1
a361 1
	verbose("received client version %d", version);
a379 1
	debug3("request %u: open flags %d", id, pflags);
d383 1
a383 2
	logit("open \"%s\" flags %s mode 0%o",
	    name, string_from_portable(pflags), mode);
d409 1
a409 2
	debug3("request %u: close handle %u", id, handle);
	handle_log_close(handle, NULL);
d428 2
a429 2
	debug("request %u: read \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
d432 1
a432 1
		debug2("read change len %d", len);
a447 1
				handle_update_read(handle, ret);
d469 2
a470 2
	debug("request %u: write \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
a483 1
				handle_update_write(handle, ret);
d485 1
a485 1
				debug2("nothing at all written");
d504 1
a504 2
	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
d540 1
a540 2
	debug("request %u: fstat \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
d579 1
a579 1
	debug("request %u: setstat name \"%s\"", id, name);
a580 1
		logit("set \"%s\" size %llu", name, a->size);
a585 1
		logit("set \"%s\" mode %04o", name, a->perm);
a590 6
		char buf[64];
		time_t t = a->mtime;

		strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
		    localtime(&t));
		logit("set \"%s\" modtime %s", name, buf);
a595 2
		logit("set \"%s\" owner %lu group %lu", name,
		    (u_long)a->uid, (u_long)a->gid);
d615 1
a615 1
	debug("request %u: fsetstat handle %d", id, handle);
a619 2
		char *name = handle_to_name(handle);

a620 1
			logit("set \"%s\" size %llu", name, a->size);
a625 1
			logit("set \"%s\" mode %04o", name, a->perm);
a630 6
			char buf[64];
			time_t t = a->mtime;

			strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
			    localtime(&t));
			logit("set \"%s\" modtime %s", name, buf);
a635 2
			logit("set \"%s\" owner %lu group %lu", name,
			    (u_long)a->uid, (u_long)a->gid);
d654 1
a654 2
	debug3("request %u: opendir", id);
	logit("opendir \"%s\"", path);
d684 1
a684 2
	debug("request %u: readdir \"%s\" (handle %d)", id,
	    handle_to_name(handle), handle);
d691 1
a691 1
		char pathname[MAXPATHLEN];
d695 1
a695 1
		stats = xcalloc(nstats, sizeof(Stat));
d699 1
a699 1
				stats = xrealloc(stats, nstats, sizeof(Stat));
d738 1
a738 2
	debug3("request %u: remove", id);
	logit("remove name \"%s\"", name);
d758 1
a758 2
	debug3("request %u: mkdir", id);
	logit("mkdir name \"%s\" mode 0%o", name, mode);
d774 1
a774 2
	debug3("request %u: rmdir", id);
	logit("rmdir name \"%s\"", name);
d794 1
a794 2
	debug3("request %u: realpath", id);
	verbose("realpath \"%s\"", path);
d817 1
a817 2
	debug3("request %u: rename", id);
	logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
d868 1
a868 2
	debug3("request %u: readlink", id);
	verbose("readlink \"%s\"", path);
d892 1
a892 2
	debug3("request %u: symlink", id);
	logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
d928 1
a928 1
	msg_len = get_u32(cp);
d930 2
a931 3
		error("bad message from %s local user %s",
		    client_addr, pw->pw_name);
		cleanup_exit(11);
d1005 1
a1005 1
		fatal("iqueue grew unexpectedly");
a1012 22
/* Cleanup handler that logs active handles upon normal exit */
void
cleanup_exit(int i)
{
	if (pw != NULL && client_addr != NULL) {
		handle_log_exit();
		logit("session closed for local user %s from [%s]",
		    pw->pw_name, client_addr);
	}
	_exit(i);
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-he] [-l log_level] [-f log_facility]\n", __progname);
	exit(1);
}

d1014 1
a1014 1
main(int argc, char **argv)
d1017 1
a1017 1
	int in, out, max, ch, skipargs = 0, log_stderr = 0;
a1018 5
	SyslogFacility log_facility = SYSLOG_FACILITY_AUTH;
	char *cp;

	extern char *optarg;
	extern char *__progname;
d1023 1
a1023 1
	log_init(__progname, log_level, log_facility, log_stderr);
d1025 1
a1025 27
	while (!skipargs && (ch = getopt(argc, argv, "C:f:l:che")) != -1) {
		switch (ch) {
		case 'c':
			/*
			 * Ignore all arguments if we are invoked as a
			 * shell using "sftp-server -c command"
			 */
			skipargs = 1;
			break;
		case 'e':
			log_stderr = 1;
			break;
		case 'l':
			log_level = log_level_number(optarg);
			if (log_level == SYSLOG_LEVEL_NOT_SET)
				error("Invalid log level \"%s\"", optarg);
			break;
		case 'f':
			log_facility = log_facility_number(optarg);
			if (log_level == SYSLOG_FACILITY_NOT_SET)
				error("Invalid log facility \"%s\"", optarg);
			break;
		case 'h':
		default:
			usage();
		}
	}
d1027 3
a1029 19
	log_init(__progname, log_level, log_facility, log_stderr);

	if ((cp = getenv("SSH_CONNECTION")) != NULL) {
		client_addr = xstrdup(cp);
		if ((cp = strchr(client_addr, ' ')) == NULL)
			fatal("Malformed SSH_CONNECTION variable: \"%s\"",
			    getenv("SSH_CONNECTION"));
		*cp = '\0';
	} else
		client_addr = xstrdup("UNKNOWN");

	if ((pw = getpwuid(getuid())) == NULL)
		fatal("No user found for uid %lu", (u_long)getuid());
	pw = pwcopy(pw);

	logit("session opened for local user %s from [%s]",
	    pw->pw_name, client_addr);

	handle_init();
d1059 1
a1059 2
			error("select: %s", strerror(errno));
			cleanup_exit(2);
d1068 1
a1068 1
				cleanup_exit(0);
d1070 2
a1071 2
				error("read: %s", strerror(errno));
				cleanup_exit(1);
d1080 2
a1081 2
				error("write: %s", strerror(errno));
				cleanup_exit(1);
@


1.47
log
@Fall back to stat+rename if filesystem doesn't doesn't support hard
links.  bz#823, ok djm@@
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.46 2004/06/21 17:36:31 avsm Exp $");
d131 1
a131 1
	int i;
d140 1
a140 1
	int i;
d157 1
a157 1
	return i >= 0 && i < sizeof(handles)/sizeof(Handle) &&
d478 1
a478 1
			if (ret == -1) {
d481 1
a481 1
			} else if (ret == len) {
@


1.47.4.1
log
@upgrade to OpenSSH 4.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.48 2005/06/17 02:44:33 djm Exp $");
d131 1
a131 1
	u_int i;
d140 1
a140 1
	u_int i;
d157 1
a157 1
	return i >= 0 && (u_int)i < sizeof(handles)/sizeof(Handle) &&
d478 1
a478 1
			if (ret < 0) {
d481 1
a481 1
			} else if ((size_t)ret == len) {
@


1.47.4.2
log
@upgrade to OpenSSH 4.3
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.50 2006/01/02 01:20:31 djm Exp $");
a23 1
#include "misc.h"
d928 1
a928 1
	if (msg_len > SFTP_MAX_MSG_LENGTH) {
a1017 3

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();
@


1.47.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.48 2005/06/17 02:44:33 djm Exp $");
d131 1
a131 1
	u_int i;
d140 1
a140 1
	u_int i;
d157 1
a157 1
	return i >= 0 && (u_int)i < sizeof(handles)/sizeof(Handle) &&
d478 1
a478 1
			if (ret < 0) {
d481 1
a481 1
			} else if ((size_t)ret == len) {
@


1.46
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.45 2004/02/19 21:15:04 markus Exp $");
d822 19
a840 3
		if (link(oldpath, newpath) == -1)
			status = errno_to_portable(errno);
		else if (unlink(oldpath) == -1) {
@


1.45
log
@switch to new license.template
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.44 2003/11/10 16:23:41 jakob Exp $");
d257 1
a257 1
send_status(u_int32_t id, u_int32_t error)
d273 1
a273 1
	TRACE("sent status id %u error %u", id, error);
d277 1
a277 1
	buffer_put_int(&msg, error);
d280 1
a280 1
		    status_messages[MIN(error,SSH2_FX_MAX)]);
d846 1
a846 1
	char link[MAXPATHLEN];
d852 1
a852 1
	if ((len = readlink(path, link, sizeof(link) - 1)) == -1)
d857 1
a857 1
		link[len] = '\0';
d859 1
a859 1
		s.name = s.long_name = link;
@


1.45.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.47 2004/06/25 05:38:48 dtucker Exp $");
d257 1
a257 1
send_status(u_int32_t id, u_int32_t status)
d273 1
a273 1
	TRACE("sent status id %u error %u", id, status);
d277 1
a277 1
	buffer_put_int(&msg, status);
d280 1
a280 1
		    status_messages[MIN(status,SSH2_FX_MAX)]);
d822 3
a824 19
		if (link(oldpath, newpath) == -1) {
			if (errno == EOPNOTSUPP) {
				struct stat st;

				/*
				 * fs doesn't support links, so fall back to
				 * stat+rename.  This is racy.
				 */
				if (stat(newpath, &st) == -1) {
					if (rename(oldpath, newpath) == -1)
						status =
						    errno_to_portable(errno);
					else
						status = SSH2_FX_OK;
				}
			} else {
				status = errno_to_portable(errno);
			}
		} else if (unlink(oldpath) == -1) {
d846 1
a846 1
	char buf[MAXPATHLEN];
d852 1
a852 1
	if ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)
d857 1
a857 1
		buf[len] = '\0';
d859 1
a859 1
		s.name = s.long_name = buf;
@


1.44
log
@constify. ok markus@@ & djm@@
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d4 3
a6 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d8 7
a14 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.43 2003/06/25 22:39:36 miod Exp $");
@


1.43
log
@Typo police: attribute is better written with an 'r'.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.42 2003/04/08 20:21:29 itojun Exp $");
d146 1
a146 1
handle_new(int use, char *name, int fd, DIR *dirp)
d181 1
a181 1
handle_from_string(char *handle, u_int hlen)
d295 1
a295 1
send_data_or_handle(char type, u_int32_t id, char *data, int dlen)
d308 1
a308 1
send_data(u_int32_t id, char *data, int dlen)
d327 1
a327 1
send_names(u_int32_t id, int count, Stat *stats)
d347 1
a347 1
send_attrib(u_int32_t id, Attrib *a)
d564 1
a564 1
attrib_to_tv(Attrib *a)
@


1.43.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
d4 8
a11 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d13 10
a22 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.45 2004/02/19 21:15:04 markus Exp $");
d146 1
a146 1
handle_new(int use, const char *name, int fd, DIR *dirp)
d181 1
a181 1
handle_from_string(const char *handle, u_int hlen)
d295 1
a295 1
send_data_or_handle(char type, u_int32_t id, const char *data, int dlen)
d308 1
a308 1
send_data(u_int32_t id, const char *data, int dlen)
d327 1
a327 1
send_names(u_int32_t id, int count, const Stat *stats)
d347 1
a347 1
send_attrib(u_int32_t id, const Attrib *a)
d564 1
a564 1
attrib_to_tv(const Attrib *a)
@


1.43.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.47 2004/06/25 05:38:48 dtucker Exp $");
d257 1
a257 1
send_status(u_int32_t id, u_int32_t status)
d273 1
a273 1
	TRACE("sent status id %u error %u", id, status);
d277 1
a277 1
	buffer_put_int(&msg, status);
d280 1
a280 1
		    status_messages[MIN(status,SSH2_FX_MAX)]);
d822 3
a824 19
		if (link(oldpath, newpath) == -1) {
			if (errno == EOPNOTSUPP) {
				struct stat st;

				/*
				 * fs doesn't support links, so fall back to
				 * stat+rename.  This is racy.
				 */
				if (stat(newpath, &st) == -1) {
					if (rename(oldpath, newpath) == -1)
						status =
						    errno_to_portable(errno);
					else
						status = SSH2_FX_OK;
				}
			} else {
				status = errno_to_portable(errno);
			}
		} else if (unlink(oldpath) == -1) {
d846 1
a846 1
	char buf[MAXPATHLEN];
d852 1
a852 1
	if ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)
d857 1
a857 1
		buf[len] = '\0';
d859 1
a859 1
		s.name = s.long_name = buf;
@


1.42
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.41 2003/03/26 04:02:51 deraadt Exp $");
d49 1
a49 1
/* portable attibutes, etc. */
@


1.41
log
@one last fix to the tree: race fix broke stuff; pr 3169; srp@@srparish.net,
help from djm
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.40 2003/03/05 22:33:43 markus Exp $");
d439 1
a439 1
		log("read change len %d", len);
d492 1
a492 1
				log("nothing at all written");
@


1.41.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.43 2003/06/25 22:39:36 miod Exp $");
d49 1
a49 1
/* portable attributes, etc. */
d439 1
a439 1
		logit("read change len %d", len);
d492 1
a492 1
				logit("nothing at all written");
@


1.41.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
d4 8
a11 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d13 10
a22 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.45 2004/02/19 21:15:04 markus Exp $");
d146 1
a146 1
handle_new(int use, const char *name, int fd, DIR *dirp)
d181 1
a181 1
handle_from_string(const char *handle, u_int hlen)
d295 1
a295 1
send_data_or_handle(char type, u_int32_t id, const char *data, int dlen)
d308 1
a308 1
send_data(u_int32_t id, const char *data, int dlen)
d327 1
a327 1
send_names(u_int32_t id, int count, const Stat *stats)
d347 1
a347 1
send_attrib(u_int32_t id, const Attrib *a)
d564 1
a564 1
attrib_to_tv(const Attrib *a)
@


1.40
log
@fix memory leaks; from dlheine@@suif.Stanford.EDU/CLOUSEAU; ok djm@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.39 2003/02/06 09:29:18 markus Exp $");
d819 1
d825 2
a826 2
	/* fail if 'newpath' exists */
	if (link(oldpath, newpath) == -1)
d828 16
a843 6
	else if (unlink(oldpath) == -1) {
		status = errno_to_portable(errno);
		/* clean spare link */
		unlink(newpath);
	} else
		status = SSH2_FX_OK;
@


1.39
log
@fix races in rename/symlink; from Tony Finch; ok djm@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.38 2002/09/11 22:41:50 djm Exp $");
d155 1
a155 1
			handles[i].name = name;
d227 1
d231 1
d395 1
a395 1
		handle = handle_new(HANDLE_FILE, xstrdup(name), fd, NULL);
d666 1
a666 1
		handle = handle_new(HANDLE_DIR, xstrdup(path), 0, dirp);
@


1.38
log
@support for short/long listings and globbing in "ls"; ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.37 2002/06/24 17:57:20 deraadt Exp $");
a814 1
	struct stat st;
d816 1
a816 1
	int ret, status = SSH2_FX_FAILURE;
d823 8
a830 4
	if (stat(newpath, &st) == -1) {
		ret = rename(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
a863 1
	struct stat st;
d865 1
a865 1
	int ret, status = SSH2_FX_FAILURE;
d871 3
a873 5
	/* fail if 'newpath' exists */
	if (stat(newpath, &st) == -1) {
		ret = symlink(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
@


1.38.2.1
log
@Update to OpenSSH 3.6
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.40 2003/03/05 22:33:43 markus Exp $");
d155 1
a155 1
			handles[i].name = xstrdup(name);
a226 1
		xfree(handles[handle].name);
a229 1
		xfree(handles[handle].name);
d393 1
a393 1
		handle = handle_new(HANDLE_FILE, name, fd, NULL);
d664 1
a664 1
		handle = handle_new(HANDLE_DIR, path, 0, dirp);
d815 1
d817 1
a817 1
	int status;
d824 4
a827 8
	if (link(oldpath, newpath) == -1)
		status = errno_to_portable(errno);
	else if (unlink(oldpath) == -1) {
		status = errno_to_portable(errno);
		/* clean spare link */
		unlink(newpath);
	} else
		status = SSH2_FX_OK;
d861 1
d863 1
a863 1
	int ret, status;
d869 5
a873 3
	/* this will fail if 'newpath' exists */
	ret = symlink(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
@


1.38.2.2
log
@Update to OpenSSH 3.6.1
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.41 2003/03/26 04:02:51 deraadt Exp $");
a818 1
	struct stat sb;
d824 2
a825 2
	status = SSH2_FX_FAILURE;
	if (lstat(oldpath, &sb) == -1)
d827 6
a832 16
	else if (S_ISREG(sb.st_mode)) {
		/* Race-free rename of regular files */
		if (link(oldpath, newpath) == -1)
			status = errno_to_portable(errno);
		else if (unlink(oldpath) == -1) {
			status = errno_to_portable(errno);
			/* clean spare link */
			unlink(newpath);
		} else
			status = SSH2_FX_OK;
	} else if (stat(newpath, &sb) == -1) {
		if (rename(oldpath, newpath) == -1)
			status = errno_to_portable(errno);
		else
			status = SSH2_FX_OK;
	}
@


1.38.2.3
log
@upgrade to OpenSSH 3.7
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.43 2003/06/25 22:39:36 miod Exp $");
d49 1
a49 1
/* portable attributes, etc. */
d439 1
a439 1
		logit("read change len %d", len);
d492 1
a492 1
				logit("nothing at all written");
@


1.37
log
@explicit (u_int) for uid and gid
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.36 2002/06/23 09:30:14 deraadt Exp $");
a677 42
/*
 * drwxr-xr-x    5 markus   markus       1024 Jan 13 18:39 .ssh
 */
static char *
ls_file(char *name, struct stat *st)
{
	int ulen, glen, sz = 0;
	struct passwd *pw;
	struct group *gr;
	struct tm *ltime = localtime(&st->st_mtime);
	char *user, *group;
	char buf[1024], mode[11+1], tbuf[12+1], ubuf[11+1], gbuf[11+1];

	strmode(st->st_mode, mode);
	if ((pw = getpwuid(st->st_uid)) != NULL) {
		user = pw->pw_name;
	} else {
		snprintf(ubuf, sizeof ubuf, "%u", (u_int)st->st_uid);
		user = ubuf;
	}
	if ((gr = getgrgid(st->st_gid)) != NULL) {
		group = gr->gr_name;
	} else {
		snprintf(gbuf, sizeof gbuf, "%u", (u_int)st->st_gid);
		group = gbuf;
	}
	if (ltime != NULL) {
		if (time(NULL) - st->st_mtime < (365*24*60*60)/2)
			sz = strftime(tbuf, sizeof tbuf, "%b %e %H:%M", ltime);
		else
			sz = strftime(tbuf, sizeof tbuf, "%b %e  %Y", ltime);
	}
	if (sz == 0)
		tbuf[0] = '\0';
	ulen = MAX(strlen(user), 8);
	glen = MAX(strlen(group), 8);
	snprintf(buf, sizeof buf, "%s %3d %-*s %-*s %8llu %s %s", mode,
	    st->st_nlink, ulen, user, glen, group,
	    (unsigned long long)st->st_size, tbuf, name);
	return xstrdup(buf);
}

d713 1
a713 1
			stats[count].long_name = ls_file(dp->d_name, &st);
@


1.36
log
@bunch of u_int vs int stuff
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.35 2002/06/06 17:30:11 markus Exp $");
d695 1
a695 1
		snprintf(ubuf, sizeof ubuf, "%u", st->st_uid);
d701 1
a701 1
		snprintf(gbuf, sizeof gbuf, "%u", st->st_gid);
@


1.35
log
@use get_int() macro (hide iqueue)
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.34 2002/06/06 17:12:44 markus Exp $");
d279 1
a279 1
	TRACE("sent status id %d error %d", id, error);
d308 1
a308 1
	TRACE("sent data id %d len %d", id, dlen);
d319 1
a319 1
	TRACE("sent handle id %d handle %d", id, handle);
d334 1
a334 1
	TRACE("sent names id %d count %d", id, count);
d349 1
a349 1
	TRACE("sent attrib id %d have 0x%x", id, a->flags);
d388 1
a388 1
	TRACE("open id %d name %s flags %d mode 0%o", id, name, pflags, mode);
d414 1
a414 1
	TRACE("close id %d handle %d", id, handle);
d433 1
a433 1
	TRACE("read id %d handle %d off %llu len %d", id, handle,
d474 1
a474 1
	TRACE("write id %d handle %d off %llu len %d", id, handle,
d509 1
a509 1
	TRACE("%sstat id %d name %s", do_lstat ? "l" : "", id, name);
d545 1
a545 1
	TRACE("fstat id %d handle %d", id, handle);
d579 1
a579 2
	int ret;
	int status = SSH2_FX_OK;
d584 1
a584 1
	TRACE("setstat id %d name %s", id, name);
d620 1
a620 1
	TRACE("fsetstat id %d handle %d", id, handle);
d659 1
a659 1
	TRACE("opendir id %d path %s", id, path);
d695 1
a695 1
		snprintf(ubuf, sizeof ubuf, "%d", st->st_uid);
d701 1
a701 1
		snprintf(gbuf, sizeof gbuf, "%d", st->st_gid);
d731 1
a731 1
	TRACE("readdir id %d handle %d", id, handle);
d741 1
d785 1
a785 1
	TRACE("remove id %d name %s", id, name);
d805 1
a805 1
	TRACE("mkdir id %d name %s mode 0%o", id, name, mode);
d821 1
a821 1
	TRACE("rmdir id %d name %s", id, name);
d841 1
a841 1
	TRACE("realpath id %d path %s", id, path);
d864 1
a864 1
	TRACE("rename id %d old %s new %s", id, oldpath, newpath);
d885 1
a885 1
	TRACE("readlink id %d path %s", id, path);
d910 1
a910 1
	TRACE("symlink id %d old %s new %s", id, oldpath, newpath);
@


1.34
log
@discard remaining bytes of current request; ok provos@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.33 2002/02/13 00:28:13 markus Exp $");
d365 1
a365 1
	version = buffer_get_int(&iqueue);
@


1.33
log
@handle SSH2_FILEXFER_ATTR_SIZE in SSH2_FXP_(F)SETSTAT; ok djm@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.32 2001/12/29 21:56:01 stevesk Exp $");
d939 2
d944 2
a945 1
	if (buffer_len(&iqueue) < 5)
d953 1
a953 1
	if (buffer_len(&iqueue) < msg_len + 4)
d956 1
d1023 8
@


1.33.2.1
log
@Pull in OpenSSH-3.4
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.37 2002/06/24 17:57:20 deraadt Exp $");
d279 1
a279 1
	TRACE("sent status id %u error %u", id, error);
d308 1
a308 1
	TRACE("sent data id %u len %d", id, dlen);
d319 1
a319 1
	TRACE("sent handle id %u handle %d", id, handle);
d334 1
a334 1
	TRACE("sent names id %u count %d", id, count);
d349 1
a349 1
	TRACE("sent attrib id %u have 0x%x", id, a->flags);
d365 1
a365 1
	version = get_int();
d388 1
a388 1
	TRACE("open id %u name %s flags %d mode 0%o", id, name, pflags, mode);
d414 1
a414 1
	TRACE("close id %u handle %d", id, handle);
d433 1
a433 1
	TRACE("read id %u handle %d off %llu len %d", id, handle,
d474 1
a474 1
	TRACE("write id %u handle %d off %llu len %d", id, handle,
d509 1
a509 1
	TRACE("%sstat id %u name %s", do_lstat ? "l" : "", id, name);
d545 1
a545 1
	TRACE("fstat id %u handle %d", id, handle);
d579 2
a580 1
	int status = SSH2_FX_OK, ret;
d585 1
a585 1
	TRACE("setstat id %u name %s", id, name);
d621 1
a621 1
	TRACE("fsetstat id %u handle %d", id, handle);
d660 1
a660 1
	TRACE("opendir id %u path %s", id, path);
d696 1
a696 1
		snprintf(ubuf, sizeof ubuf, "%u", (u_int)st->st_uid);
d702 1
a702 1
		snprintf(gbuf, sizeof gbuf, "%u", (u_int)st->st_gid);
d732 1
a732 1
	TRACE("readdir id %u handle %d", id, handle);
a741 1

d785 1
a785 1
	TRACE("remove id %u name %s", id, name);
d805 1
a805 1
	TRACE("mkdir id %u name %s mode 0%o", id, name, mode);
d821 1
a821 1
	TRACE("rmdir id %u name %s", id, name);
d841 1
a841 1
	TRACE("realpath id %u path %s", id, path);
d864 1
a864 1
	TRACE("rename id %u old %s new %s", id, oldpath, newpath);
d885 1
a885 1
	TRACE("readlink id %u path %s", id, path);
d910 1
a910 1
	TRACE("symlink id %u old %s new %s", id, oldpath, newpath);
a938 2
	u_int buf_len;
	u_int consumed;
d942 1
a942 2
	buf_len = buffer_len(&iqueue);
	if (buf_len < 5)
d950 1
a950 1
	if (buf_len < msg_len + 4)
a952 1
	buf_len -= 4;
a1018 8
	/* discard the remaining bytes from the current packet */
	if (buf_len < buffer_len(&iqueue))
		fatal("iqueue grows");
	consumed = buf_len - buffer_len(&iqueue);
	if (msg_len < consumed)
		fatal("msg_len %d < consumed %d", msg_len, consumed);
	if (msg_len > consumed)
		buffer_consume(&iqueue, msg_len - consumed);
@


1.33.2.2
log
@Update to OpenSSH 3.5
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.38 2002/09/11 22:41:50 djm Exp $");
d678 42
d755 1
a755 1
			stats[count].long_name = ls_file(dp->d_name, &st, 0);
@


1.33.2.3
log
@Merge OpenSSH 3.6.1
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.41 2003/03/26 04:02:51 deraadt Exp $");
d155 1
a155 1
			handles[i].name = xstrdup(name);
a226 1
		xfree(handles[handle].name);
a229 1
		xfree(handles[handle].name);
d393 1
a393 1
		handle = handle_new(HANDLE_FILE, name, fd, NULL);
d664 1
a664 1
		handle = handle_new(HANDLE_DIR, path, 0, dirp);
d815 1
d817 1
a817 2
	int status;
	struct stat sb;
d823 4
a826 18
	status = SSH2_FX_FAILURE;
	if (lstat(oldpath, &sb) == -1)
		status = errno_to_portable(errno);
	else if (S_ISREG(sb.st_mode)) {
		/* Race-free rename of regular files */
		if (link(oldpath, newpath) == -1)
			status = errno_to_portable(errno);
		else if (unlink(oldpath) == -1) {
			status = errno_to_portable(errno);
			/* clean spare link */
			unlink(newpath);
		} else
			status = SSH2_FX_OK;
	} else if (stat(newpath, &sb) == -1) {
		if (rename(oldpath, newpath) == -1)
			status = errno_to_portable(errno);
		else
			status = SSH2_FX_OK;
d861 1
d863 1
a863 1
	int ret, status;
d869 5
a873 3
	/* this will fail if 'newpath' exists */
	ret = symlink(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
@


1.32
log
@remove unneeded casts and some char->u_char cleanup; ok markus@@
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.31 2001/12/19 07:18:56 deraadt Exp $");
d586 5
d626 5
@


1.31
log
@basic KNF done while i was looking for something else
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.30 2001/07/31 12:42:50 jakob Exp $");
d934 1
a934 1
	cp = (u_char *) buffer_ptr(&iqueue);
@


1.30
log
@avoid paths beginning with "//"; <vinschen@@redhat.com>
ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.29 2001/06/25 08:25:40 markus Exp $");
d141 1
a141 1
	for(i = 0; i < sizeof(handles)/sizeof(Handle); i++)
d150 1
a150 1
	for(i = 0; i < sizeof(handles)/sizeof(Handle); i++) {
d754 1
a754 1
			for(i = 0; i < count; i++) {
d880 1
a880 1
		
@


1.30.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.33 2002/02/13 00:28:13 markus Exp $");
d141 1
a141 1
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
d150 1
a150 1
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++) {
a585 5
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
		ret = truncate(name, a->size);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
a620 5
		if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
			ret = ftruncate(fd, a->size);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
d754 1
a754 1
			for (i = 0; i < count; i++) {
d880 1
a880 1

d934 1
a934 1
	cp = buffer_ptr(&iqueue);
@


1.30.2.2
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.30.2.1 2002/03/07 17:37:47 jason Exp $");
d365 1
a365 1
	version = get_int();
a938 2
	u_int buf_len;
	u_int consumed;
d942 1
a942 2
	buf_len = buffer_len(&iqueue);
	if (buf_len < 5)
d950 1
a950 1
	if (buf_len < msg_len + 4)
a952 1
	buf_len -= 4;
a1018 8
	/* discard the remaining bytes from the current packet */
	if (buf_len < buffer_len(&iqueue))
		fatal("iqueue grows");
	consumed = buf_len - buffer_len(&iqueue);
	if (msg_len < consumed)
		fatal("msg_len %d < consumed %d", msg_len, consumed);
	if (msg_len > consumed)
		buffer_consume(&iqueue, msg_len - consumed);
@


1.30.2.3
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.30.2.2 2002/06/22 07:23:17 miod Exp $");
d279 1
a279 1
	TRACE("sent status id %u error %u", id, error);
d308 1
a308 1
	TRACE("sent data id %u len %d", id, dlen);
d319 1
a319 1
	TRACE("sent handle id %u handle %d", id, handle);
d334 1
a334 1
	TRACE("sent names id %u count %d", id, count);
d349 1
a349 1
	TRACE("sent attrib id %u have 0x%x", id, a->flags);
d388 1
a388 1
	TRACE("open id %u name %s flags %d mode 0%o", id, name, pflags, mode);
d414 1
a414 1
	TRACE("close id %u handle %d", id, handle);
d433 1
a433 1
	TRACE("read id %u handle %d off %llu len %d", id, handle,
d474 1
a474 1
	TRACE("write id %u handle %d off %llu len %d", id, handle,
d509 1
a509 1
	TRACE("%sstat id %u name %s", do_lstat ? "l" : "", id, name);
d545 1
a545 1
	TRACE("fstat id %u handle %d", id, handle);
d579 2
a580 1
	int status = SSH2_FX_OK, ret;
d585 1
a585 1
	TRACE("setstat id %u name %s", id, name);
d621 1
a621 1
	TRACE("fsetstat id %u handle %d", id, handle);
d660 1
a660 1
	TRACE("opendir id %u path %s", id, path);
d696 1
a696 1
		snprintf(ubuf, sizeof ubuf, "%u", (u_int)st->st_uid);
d702 1
a702 1
		snprintf(gbuf, sizeof gbuf, "%u", (u_int)st->st_gid);
d732 1
a732 1
	TRACE("readdir id %u handle %d", id, handle);
a741 1

d785 1
a785 1
	TRACE("remove id %u name %s", id, name);
d805 1
a805 1
	TRACE("mkdir id %u name %s mode 0%o", id, name, mode);
d821 1
a821 1
	TRACE("rmdir id %u name %s", id, name);
d841 1
a841 1
	TRACE("realpath id %u path %s", id, path);
d864 1
a864 1
	TRACE("rename id %u old %s new %s", id, oldpath, newpath);
d885 1
a885 1
	TRACE("readlink id %u path %s", id, path);
d910 1
a910 1
	TRACE("symlink id %u old %s new %s", id, oldpath, newpath);
@


1.30.2.4
log
@Update to OpenSSH 3.5
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.38 2002/09/11 22:41:50 djm Exp $");
d678 42
d755 1
a755 1
			stats[count].long_name = ls_file(dp->d_name, &st, 0);
@


1.29
log
@update copyright for 2001
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.28 2001/06/23 15:12:20 itojun Exp $");
d739 2
a740 2
			snprintf(pathname, sizeof pathname,
			    "%s/%s", path, dp->d_name);
@


1.28
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d2 1
a2 1
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.27 2001/06/22 22:21:20 markus Exp $");
@


1.27
log
@allow long usernames/groups in readdir
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.26 2001/05/12 19:53:13 markus Exp $");
d59 1
a59 1
int
d90 1
a90 1
int
d112 1
a112 1
Attrib *
d136 1
a136 1
void
d145 1
a145 1
int
d162 1
a162 1
int
d169 1
a169 1
int
d180 1
a180 1
int
d194 1
a194 1
char *
d203 1
a203 1
DIR *
d211 1
a211 1
int
d219 1
a219 1
int
d236 1
a236 1
int
d252 1
a252 1
void
d262 1
a262 1
void
d292 1
a292 1
void
d305 1
a305 1
void
d312 1
a312 1
void
d324 1
a324 1
void
d344 1
a344 1
void
d360 1
a360 1
void
d374 1
a374 1
void
d406 1
a406 1
void
d420 1
a420 1
void
d460 1
a460 1
void
d498 1
a498 1
void
d523 1
a523 1
void
d529 1
a529 1
void
d535 1
a535 1
void
d561 1
a561 1
struct timeval *
d573 1
a573 1
void
d605 1
a605 1
void
d640 1
a640 1
void
d672 1
a672 1
char *
d711 1
a711 1
void
d765 1
a765 1
void
d782 1
a782 1
void
d802 1
a802 1
void
d818 1
a818 1
void
d843 1
a843 1
void
d865 1
a865 1
void
d889 1
a889 1
void
d911 1
a911 1
void
d925 1
a925 1
void
@


1.26
log
@readlink does not NULL-terminate; mhe@@home.se
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.25 2001/04/05 10:42:53 markus Exp $");
d675 1
a675 1
	int sz = 0;
d703 5
a707 2
	snprintf(buf, sizeof buf, "%s %3d %-8.8s %-8.8s %8llu %s %s", mode,
	    st->st_nlink, user, group, (unsigned long long)st->st_size, tbuf, name);
@


1.25
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.24 2001/03/14 22:50:25 deraadt Exp $");
d866 1
d873 1
a873 1
	if (readlink(path, link, sizeof(link) - 1) == -1)
d878 1
a878 1
		link[sizeof(link) - 1] = '\0';
@


1.25.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.30 2001/07/31 12:42:50 jakob Exp $");
d59 1
a59 1
static int
d90 1
a90 1
static int
d112 1
a112 1
static Attrib *
d136 1
a136 1
static void
d145 1
a145 1
static int
d162 1
a162 1
static int
d169 1
a169 1
static int
d180 1
a180 1
static int
d194 1
a194 1
static char *
d203 1
a203 1
static DIR *
d211 1
a211 1
static int
d219 1
a219 1
static int
d236 1
a236 1
static int
d252 1
a252 1
static void
d262 1
a262 1
static void
d292 1
a292 1
static void
d305 1
a305 1
static void
d312 1
a312 1
static void
d324 1
a324 1
static void
d344 1
a344 1
static void
d360 1
a360 1
static void
d374 1
a374 1
static void
d406 1
a406 1
static void
d420 1
a420 1
static void
d460 1
a460 1
static void
d498 1
a498 1
static void
d523 1
a523 1
static void
d529 1
a529 1
static void
d535 1
a535 1
static void
d561 1
a561 1
static struct timeval *
d573 1
a573 1
static void
d605 1
a605 1
static void
d640 1
a640 1
static void
d672 1
a672 1
static char *
d675 1
a675 1
	int ulen, glen, sz = 0;
d703 2
a704 5
	ulen = MAX(strlen(user), 8);
	glen = MAX(strlen(group), 8);
	snprintf(buf, sizeof buf, "%s %3d %-*s %-*s %8llu %s %s", mode,
	    st->st_nlink, ulen, user, glen, group,
	    (unsigned long long)st->st_size, tbuf, name);
d708 1
a708 1
static void
d736 2
a737 2
			snprintf(pathname, sizeof pathname, "%s%s%s", path,
			    strcmp(path, "/") ? "/" : "", dp->d_name);
d762 1
a762 1
static void
d779 1
a779 1
static void
d799 1
a799 1
static void
d815 1
a815 1
static void
d840 1
a840 1
static void
d862 1
a862 1
static void
a865 1
	int len;
d872 1
a872 1
	if ((len = readlink(path, link, sizeof(link) - 1)) == -1)
d877 1
a877 1
		link[len] = '\0';
d885 1
a885 1
static void
d907 1
a907 1
static void
d921 1
a921 1
static void
@


1.25.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.33 2002/02/13 00:28:13 markus Exp $");
d141 1
a141 1
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
d150 1
a150 1
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++) {
a585 5
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
		ret = truncate(name, a->size);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
a620 5
		if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
			ret = ftruncate(fd, a->size);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
d754 1
a754 1
			for (i = 0; i < count; i++) {
d880 1
a880 1

d934 1
a934 1
	cp = buffer_ptr(&iqueue);
@


1.24
log
@note no getopt()
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.23 2001/03/07 10:11:23 djm Exp $");
d285 1
a285 1
		buffer_put_cstring(&msg, 
@


1.23
log
@Support for new draft (draft-ietf-secsh-filexfer-01). New symlink handling
functions and small protocol change.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.22 2001/03/03 22:07:50 deraadt Exp $");
d1013 2
@


1.22
log
@KNF
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.21 2001/03/03 21:40:30 millert Exp $");
d46 3
d266 12
d284 5
a363 1
	int version = buffer_get_int(&iqueue);
d365 1
d863 45
d991 6
@


1.21
log
@Dynamically allocate fd_set; deraadt@@ OK
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.20 2001/02/21 09:12:56 deraadt Exp $");
d60 1
d91 1
d124 1
d130 1
d137 1
d146 1
d181 1
d220 1
d239 1
d253 1
d263 1
d276 1
d297 1
d309 1
d328 1
d545 1
@


1.20
log
@careful with & and &&; markus ok
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.19 2001/02/07 18:01:18 itojun Exp $");
d923 1
a923 1
	fd_set rset, wset;
d925 1
a925 1
	ssize_t len, olen;
d945 4
d950 2
a951 2
		FD_ZERO(&rset);
		FD_ZERO(&wset);
d953 1
a953 1
		FD_SET(in, &rset);
d956 1
a956 1
			FD_SET(out, &wset);
d958 1
a958 1
		if (select(max+1, &rset, &wset, NULL, NULL) < 0) {
d965 1
a965 1
		if (FD_ISSET(in, &rset)) {
d979 1
a979 1
		if (FD_ISSET(out, &wset)) {
@


1.19
log
@unsigned long long -> %llu, not %qu.  markus ok
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.18 2001/02/04 22:21:19 stevesk Exp $");
d90 2
a91 2
	if (pflags & SSH2_FXF_READ &&
	    pflags & SSH2_FXF_WRITE) {
@


1.18
log
@SSH2_FILEXFER_ATTR_UIDGID support; ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.17 2001/02/04 15:32:25 stevesk Exp $");
d398 1
a398 1
	TRACE("read id %d handle %d off %qd len %d", id, handle,
d439 1
a439 1
	TRACE("write id %d handle %d off %qd len %d", id, handle,
d667 2
a668 2
	snprintf(buf, sizeof buf, "%s %3d %-8.8s %-8.8s %8qd %s %s", mode,
	    st->st_nlink, user, group, (long long)st->st_size, tbuf, name);
@


1.17
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.16 2001/02/04 15:23:08 deraadt Exp $");
d560 5
d592 5
@


1.16
log
@make gcc on the alpha even happier
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.15 2001/02/04 11:11:54 djm Exp $");
d204 1
a204 1
	if (handle_is_ok(handle, HANDLE_FILE)) 
d605 1
a605 1
	dirp = opendir(path); 
d616 1
a616 1
		
d920 1
a920 1
        log_init("sftp-server", SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 0);
@


1.15
log
@Basic interactive sftp client; ok theo@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.14 2001/01/21 19:05:56 markus Exp $");
d398 2
a399 1
	TRACE("read id %d handle %d off %qd len %d", id, handle, off, len);
d439 2
a440 1
	TRACE("write id %d handle %d off %qd len %d", id, handle, off, len);
@


1.14
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.13 2001/01/16 20:54:27 markus Exp $");
d34 1
a47 1
typedef struct Attrib Attrib;
d50 1
a50 13
struct Attrib
{
	u_int32_t	flags;
	u_int64_t	size;
	u_int32_t	uid;
	u_int32_t	gid;
	u_int32_t	perm;
	u_int32_t	atime;
	u_int32_t	mtime;
};

struct Stat
{
a104 84
}

void
attrib_clear(Attrib *a)
{
	a->flags = 0;
	a->size = 0;
	a->uid = 0;
	a->gid = 0;
	a->perm = 0;
	a->atime = 0;
	a->mtime = 0;
}

Attrib *
decode_attrib(Buffer *b)
{
	static Attrib a;
	attrib_clear(&a);
	a.flags = buffer_get_int(b);
	if (a.flags & SSH2_FILEXFER_ATTR_SIZE) {
		a.size = buffer_get_int64(b);
	}
	if (a.flags & SSH2_FILEXFER_ATTR_UIDGID) {
		a.uid = buffer_get_int(b);
		a.gid = buffer_get_int(b);
	}
	if (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
		a.perm = buffer_get_int(b);
	}
	if (a.flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
		a.atime = buffer_get_int(b);
		a.mtime = buffer_get_int(b);
	}
	/* vendor-specific extensions */
	if (a.flags & SSH2_FILEXFER_ATTR_EXTENDED) {
		char *type, *data;
		int i, count;
		count = buffer_get_int(b);
		for (i = 0; i < count; i++) {
			type = buffer_get_string(b, NULL);
			data = buffer_get_string(b, NULL);
			xfree(type);
			xfree(data);
		}
	}
	return &a;
}

void
encode_attrib(Buffer *b, Attrib *a)
{
	buffer_put_int(b, a->flags);
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
		buffer_put_int64(b, a->size);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
		buffer_put_int(b, a->uid);
		buffer_put_int(b, a->gid);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
		buffer_put_int(b, a->perm);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
		buffer_put_int(b, a->atime);
		buffer_put_int(b, a->mtime);
	}
}

void
stat_to_attrib(struct stat *st, Attrib *a)
{
	attrib_clear(a);
	a->flags = 0;
	a->flags |= SSH2_FILEXFER_ATTR_SIZE;
	a->size = st->st_size;
	a->flags |= SSH2_FILEXFER_ATTR_UIDGID;
	a->uid = st->st_uid;
	a->gid = st->st_gid;
	a->flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
	a->perm = st->st_mode;
	a->flags |= SSH2_FILEXFER_ATTR_ACMODTIME;
	a->atime = st->st_atime;
	a->mtime = st->st_mtime;
@


1.13
log
@remove some statics. simpler handles; idea from nisse@@lysator.liu.se
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.12 2001/01/15 21:46:38 markus Exp $");
a26 1
#include "ssh.h"
d30 1
@


1.12
log
@readable long listing for sftp-server, ok deraadt@@
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.11 2001/01/15 21:45:29 markus Exp $");
d186 2
a187 2
Attrib *
stat_to_attrib(struct stat *st)
d189 12
a200 14
	static Attrib a;
	attrib_clear(&a);
	a.flags = 0;
	a.flags |= SSH2_FILEXFER_ATTR_SIZE;
	a.size = st->st_size;
	a.flags |= SSH2_FILEXFER_ATTR_UIDGID;
	a.uid = st->st_uid;
	a.gid = st->st_gid;
	a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
	a.perm = st->st_mode;
	a.flags |= SSH2_FILEXFER_ATTR_ACMODTIME;
	a.atime = st->st_atime;
	a.mtime = st->st_mtime;
	return &a;
a258 1
	char buf[1024];
d261 3
a263 3
	snprintf(buf, sizeof buf, "%d", handle);
	*stringp = xstrdup(buf);
	*hlenp = strlen(*stringp);
d270 2
a271 5
/* XXX OVERFLOW ? */
	char *ep;
	long lval = strtol(handle, &ep, 10);
	int val = lval;
	if (*ep != '\0')
d273 1
d560 1
a560 1
	Attrib *a;
d573 2
a574 2
		a = stat_to_attrib(&st);
		send_attrib(id, a);
d597 1
a597 1
	Attrib *a;
d611 2
a612 2
			a = stat_to_attrib(&st);
			send_attrib(id, a);
a772 1
		Attrib *a;
d788 1
a788 2
			a = stat_to_attrib(&st);
			stats[count].attrib = *a;
@


1.11
log
@rename must fail if newpath exists, debug off by default
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.10 2001/01/10 22:56:22 markus Exp $");
d723 1
a723 4
 * XXX, draft-ietf-secsh-filexfer-00.txt says: 
 * The recommended format for the longname field is as follows:
 * -rwxr-xr-x   1 mjos     staff      348911 Mar 25 14:29 t-filexfer
 * 1234567890 123 12345678 12345678 12345678 123456789012
d728 30
a757 4
	char buf[1024];
	snprintf(buf, sizeof buf, "0%o %d %d %qd %d %s",
	    st->st_mode, st->st_uid, st->st_gid, (long long)st->st_size,
	    (int)st->st_mtime, name);
@


1.10
log
@cleanup sftp-server implementation:
	add buffer_get_int64, buffer_put_int64, GET_64BIT, PUT_64BIT
	parse SSH2_FILEXFER_ATTR_EXTENDED
	send SSH2_FX_EOF if readdir returns no more entries
	reply to SSH2_FXP_EXTENDED messages
	use #defines from the draft.
	move #definitions to sftp.h
more info:
http://www.ietf.org/internet-drafts/draft-ietf-secsh-filexfer-00.txt
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.9 2000/12/19 23:17:58 markus Exp $");
d777 1
d876 1
d878 1
a878 1
	int ret, status;
d884 5
a888 2
	ret = rename(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d997 1
d999 1
@


1.9
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.8 2000/12/19 22:43:44 markus Exp $");
d33 1
a33 54
/* version */
#define	SSH_FILEXFER_VERSION		2

/* client to server */
#define	SSH_FXP_INIT			1
#define	SSH_FXP_OPEN			3
#define	SSH_FXP_CLOSE			4
#define	SSH_FXP_READ			5
#define	SSH_FXP_WRITE			6
#define	SSH_FXP_LSTAT			7
#define	SSH_FXP_FSTAT			8
#define	SSH_FXP_SETSTAT			9
#define	SSH_FXP_FSETSTAT		10
#define	SSH_FXP_OPENDIR			11
#define	SSH_FXP_READDIR			12
#define	SSH_FXP_REMOVE			13
#define	SSH_FXP_MKDIR			14
#define	SSH_FXP_RMDIR			15
#define	SSH_FXP_REALPATH		16
#define	SSH_FXP_STAT			17
#define	SSH_FXP_RENAME			18

/* server to client */
#define	SSH_FXP_VERSION			2
#define	SSH_FXP_STATUS			101
#define	SSH_FXP_HANDLE			102
#define	SSH_FXP_DATA			103
#define	SSH_FXP_NAME			104
#define	SSH_FXP_ATTRS			105

/* portable open modes */
#define	SSH_FXF_READ			0x01
#define	SSH_FXF_WRITE			0x02
#define	SSH_FXF_APPEND			0x04
#define	SSH_FXF_CREAT			0x08
#define	SSH_FXF_TRUNC			0x10
#define	SSH_FXF_EXCL			0x20

/* attributes */
#define	SSH_FXA_HAVE_SIZE		0x01
#define	SSH_FXA_HAVE_UGID		0x02
#define	SSH_FXA_HAVE_PERM		0x04
#define	SSH_FXA_HAVE_TIME		0x08

/* status messages */
#define	SSH_FX_OK			0x00
#define	SSH_FX_EOF			0x01
#define	SSH_FX_NO_SUCH_FILE		0x02
#define	SSH_FX_PERMISSION_DENIED	0x03
#define	SSH_FX_FAILURE			0x04
#define	SSH_FX_BAD_MESSAGE		0x05
#define	SSH_FX_NO_CONNECTION		0x06
#define	SSH_FX_CONNECTION_LOST		0x07

d36 1
d39 1
a39 1
#define TRACE				log
a52 2
	u_int32_t	size_high;
	u_int32_t	size_low;
d74 1
a74 1
		ret = SSH_FX_OK;
d80 1
a80 1
		ret = SSH_FX_NO_SUCH_FILE;
d85 1
a85 1
		ret = SSH_FX_PERMISSION_DENIED;
d89 1
a89 1
		ret = SSH_FX_BAD_MESSAGE;
d92 1
a92 1
		ret = SSH_FX_FAILURE;
d102 2
a103 2
	if (pflags & SSH_FXF_READ &&
	    pflags & SSH_FXF_WRITE) {
d105 1
a105 1
	} else if (pflags & SSH_FXF_READ) {
d107 1
a107 1
	} else if (pflags & SSH_FXF_WRITE) {
d110 1
a110 1
	if (pflags & SSH_FXF_CREAT)
d112 1
a112 1
	if (pflags & SSH_FXF_TRUNC)
d114 1
a114 1
	if (pflags & SSH_FXF_EXCL)
a122 2
	a->size_low = 0;
	a->size_high = 0;
d137 2
a138 4
	if (a.flags & SSH_FXA_HAVE_SIZE) {
		a.size_high = buffer_get_int(b);
		a.size_low = buffer_get_int(b);
		a.size = (((u_int64_t) a.size_high) << 32) + a.size_low;
d140 1
a140 1
	if (a.flags & SSH_FXA_HAVE_UGID) {
d144 1
a144 1
	if (a.flags & SSH_FXA_HAVE_PERM) {
d147 1
a147 1
	if (a.flags & SSH_FXA_HAVE_TIME) {
d151 12
d170 2
a171 3
	if (a->flags & SSH_FXA_HAVE_SIZE) {
		buffer_put_int(b, a->size_high);
		buffer_put_int(b, a->size_low);
d173 1
a173 1
	if (a->flags & SSH_FXA_HAVE_UGID) {
d177 1
a177 1
	if (a->flags & SSH_FXA_HAVE_PERM) {
d180 1
a180 1
	if (a->flags & SSH_FXA_HAVE_TIME) {
d192 1
a192 1
	a.flags |= SSH_FXA_HAVE_SIZE;
d194 1
a194 3
	a.size_low = a.size;
	a.size_high = (u_int32_t) (a.size >> 32);
	a.flags |= SSH_FXA_HAVE_UGID;
d197 1
a197 1
	a.flags |= SSH_FXA_HAVE_PERM;
d199 1
a199 1
	a.flags |= SSH_FXA_HAVE_TIME;
d254 2
a255 1
	return i >= 0 && i < sizeof(handles)/sizeof(Handle) && handles[i].use == type;
d330 1
a330 1
	int val;
d333 2
a334 1
	val = handle_from_string(handle, hlen);
d356 1
a356 1
	buffer_put_char(&msg, SSH_FXP_STATUS);
d378 1
a378 1
	send_data_or_handle(SSH_FXP_DATA, id, data, dlen);
d388 1
a388 1
	send_data_or_handle(SSH_FXP_HANDLE, id, string, hlen);
d398 1
a398 1
	buffer_put_char(&msg, SSH_FXP_NAME);
d417 1
a417 1
	buffer_put_char(&msg, SSH_FXP_ATTRS);
d434 2
a435 2
	buffer_put_char(&msg, SSH_FXP_VERSION);
	buffer_put_int(&msg, SSH_FILEXFER_VERSION);
d446 1
a446 1
	int handle, fd, flags, mode, status = SSH_FX_FAILURE;
d450 1
a450 1
	pflags = get_int();
d453 1
a453 1
	mode = (a->flags & SSH_FXA_HAVE_PERM) ? a->perm : 0666;
d464 1
a464 1
			status = SSH_FX_OK;
d467 1
a467 1
	if (status != SSH_FX_OK)
d476 1
a476 1
	int handle, ret, status = SSH_FX_FAILURE;
d482 1
a482 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH_FX_OK;
d490 2
a491 2
	u_int32_t id, off_high, off_low, len;
	int handle, fd, ret, status = SSH_FX_FAILURE;
d496 1
a496 2
	off_high = get_int();
	off_low = get_int();
a498 1
	off = (((u_int64_t) off_high) << 32) + off_low;
d514 1
a514 1
				status = SSH_FX_EOF;
d517 1
a517 1
				status = SSH_FX_OK;
d521 1
a521 1
	if (status != SSH_FX_OK)
d528 1
a528 1
	u_int32_t id, off_high, off_low;
d531 1
a531 1
	int handle, fd, ret, status = SSH_FX_FAILURE;
d536 1
a536 2
	off_high = get_int();
	off_low = get_int();
a538 1
	off = (((u_int64_t) off_high) << 32) + off_low;
d552 1
a552 1
				status = SSH_FX_OK;
d569 1
a569 1
	int ret, status = SSH_FX_FAILURE;
d580 1
a580 1
		status = SSH_FX_OK;
d582 1
a582 1
	if (status != SSH_FX_OK)
d605 1
a605 1
	int fd, ret, handle, status = SSH_FX_FAILURE;
d618 1
a618 1
			status = SSH_FX_OK;
d621 1
a621 1
	if (status != SSH_FX_OK)
d643 1
a643 1
	int status = SSH_FX_OK;
d649 1
a649 1
	if (a->flags & SSH_FXA_HAVE_PERM) {
d654 1
a654 1
	if (a->flags & SSH_FXA_HAVE_TIME) {
d669 1
a669 1
	int status = SSH_FX_OK;
d677 1
a677 1
		status = SSH_FX_FAILURE;
d679 1
a679 1
		if (a->flags & SSH_FXA_HAVE_PERM) {
d684 1
a684 1
		if (a->flags & SSH_FXA_HAVE_TIME) {
d698 1
a698 1
	int handle, status = SSH_FX_FAILURE;
d713 1
a713 1
			status = SSH_FX_OK;
d717 1
a717 1
	if (status != SSH_FX_OK)
d722 6
d733 2
a734 2
	    st->st_mode, st->st_uid, st->st_gid, (long long)st->st_size,(int) st->st_mtime,
	    name);
d753 1
a753 1
		send_status(id, SSH_FX_FAILURE);
d780 8
a787 4
		send_names(id, count, stats);
		for(i = 0; i < count; i++) {
			xfree(stats[i].name);
			xfree(stats[i].long_name);
d798 1
a798 1
	int status = SSH_FX_FAILURE;
d805 1
a805 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH_FX_OK;
d816 1
a816 1
	int ret, mode, status = SSH_FX_FAILURE;
d821 2
a822 1
	mode = (a->flags & SSH_FXA_HAVE_PERM) ? a->perm & 0777 : 0777;
d825 1
a825 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH_FX_OK;
d841 1
a841 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH_FX_OK;
d883 1
a883 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH_FX_OK;
d889 11
d923 1
a923 1
	case SSH_FXP_INIT:
d926 1
a926 1
	case SSH_FXP_OPEN:
d929 1
a929 1
	case SSH_FXP_CLOSE:
d932 1
a932 1
	case SSH_FXP_READ:
d935 1
a935 1
	case SSH_FXP_WRITE:
d938 1
a938 1
	case SSH_FXP_LSTAT:
d941 1
a941 1
	case SSH_FXP_FSTAT:
d944 1
a944 1
	case SSH_FXP_SETSTAT:
d947 1
a947 1
	case SSH_FXP_FSETSTAT:
d950 1
a950 1
	case SSH_FXP_OPENDIR:
d953 1
a953 1
	case SSH_FXP_READDIR:
d956 1
a956 1
	case SSH_FXP_REMOVE:
d959 1
a959 1
	case SSH_FXP_MKDIR:
d962 1
a962 1
	case SSH_FXP_RMDIR:
d965 1
a965 1
	case SSH_FXP_REALPATH:
d968 1
a968 1
	case SSH_FXP_STAT:
d971 1
a971 1
	case SSH_FXP_RENAME:
d974 3
d991 2
@


1.8
log
@remove() -> unlink() for consistency
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.7 2000/12/09 14:08:27 markus Exp $");
d935 3
a937 3
	unsigned int msg_len;
	unsigned int type;
	unsigned char *cp;
d941 1
a941 1
	cp = (unsigned char *) buffer_ptr(&iqueue);
@


1.7
log
@"" -> "." for realpath; from vinschen@@redhat.com
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.6 2000/09/07 20:27:53 deraadt Exp $");
d845 1
a845 1
	ret = remove(name);
@


1.6
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.5 2000/09/05 19:20:49 markus Exp $");
d895 4
@


1.6.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.19 2001/02/07 18:01:18 itojun Exp $");
d27 1
a30 1
#include "log.h"
d33 54
a86 2
#include "sftp.h"
#include "sftp-common.h"
a88 1
#define get_int64()			buffer_get_int64(&iqueue);
d91 1
a91 1
#define TRACE				debug
d99 1
d102 15
a116 1
struct Stat {
d128 1
a128 1
		ret = SSH2_FX_OK;
d134 1
a134 1
		ret = SSH2_FX_NO_SUCH_FILE;
d139 1
a139 1
		ret = SSH2_FX_PERMISSION_DENIED;
d143 1
a143 1
		ret = SSH2_FX_BAD_MESSAGE;
d146 1
a146 1
		ret = SSH2_FX_FAILURE;
d156 2
a157 2
	if (pflags & SSH2_FXF_READ &&
	    pflags & SSH2_FXF_WRITE) {
d159 1
a159 1
	} else if (pflags & SSH2_FXF_READ) {
d161 1
a161 1
	} else if (pflags & SSH2_FXF_WRITE) {
d164 1
a164 1
	if (pflags & SSH2_FXF_CREAT)
d166 1
a166 1
	if (pflags & SSH2_FXF_TRUNC)
d168 1
a168 1
	if (pflags & SSH2_FXF_EXCL)
d173 81
d303 1
a303 2
	return i >= 0 && i < sizeof(handles)/sizeof(Handle) &&
	    handles[i].use == type;
d309 1
d312 3
a314 3
	*stringp = xmalloc(sizeof(int32_t));
	PUT_32BIT(*stringp, handle);
	*hlenp = sizeof(int32_t);
d321 5
a325 2
	int val;
	if (hlen != sizeof(int32_t))
a326 1
	val = GET_32BIT(handle);
d353 1
a353 1
	if (handle_is_ok(handle, HANDLE_FILE))
d378 1
a378 1
	int val = -1;
d381 1
a381 2
	if (hlen < 256)
		val = handle_from_string(handle, hlen);
d403 1
a403 1
	buffer_put_char(&msg, SSH2_FXP_STATUS);
d425 1
a425 1
	send_data_or_handle(SSH2_FXP_DATA, id, data, dlen);
d435 1
a435 1
	send_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);
d445 1
a445 1
	buffer_put_char(&msg, SSH2_FXP_NAME);
d464 1
a464 1
	buffer_put_char(&msg, SSH2_FXP_ATTRS);
d481 2
a482 2
	buffer_put_char(&msg, SSH2_FXP_VERSION);
	buffer_put_int(&msg, SSH2_FILEXFER_VERSION);
d493 1
a493 1
	int handle, fd, flags, mode, status = SSH2_FX_FAILURE;
d497 1
a497 1
	pflags = get_int();		/* portable flags */
d500 1
a500 1
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a->perm : 0666;
d511 1
a511 1
			status = SSH2_FX_OK;
d514 1
a514 1
	if (status != SSH2_FX_OK)
d523 1
a523 1
	int handle, ret, status = SSH2_FX_FAILURE;
d529 1
a529 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d537 2
a538 2
	u_int32_t id, len;
	int handle, fd, ret, status = SSH2_FX_FAILURE;
d543 2
a544 1
	off = get_int64();
d547 2
a548 2
	TRACE("read id %d handle %d off %llu len %d", id, handle,
	    (unsigned long long)off, len);
d563 1
a563 1
				status = SSH2_FX_EOF;
d566 1
a566 1
				status = SSH2_FX_OK;
d570 1
a570 1
	if (status != SSH2_FX_OK)
d577 1
a577 1
	u_int32_t id;
d580 1
a580 1
	int handle, fd, ret, status = SSH2_FX_FAILURE;
d585 2
a586 1
	off = get_int64();
d589 2
a590 2
	TRACE("write id %d handle %d off %llu len %d", id, handle,
	    (unsigned long long)off, len);
d603 1
a603 1
				status = SSH2_FX_OK;
d616 1
a616 1
	Attrib a;
d620 1
a620 1
	int ret, status = SSH2_FX_FAILURE;
d629 3
a631 3
		stat_to_attrib(&st, &a);
		send_attrib(id, &a);
		status = SSH2_FX_OK;
d633 1
a633 1
	if (status != SSH2_FX_OK)
d653 1
a653 1
	Attrib a;
d656 1
a656 1
	int fd, ret, handle, status = SSH2_FX_FAILURE;
d667 3
a669 3
			stat_to_attrib(&st, &a);
			send_attrib(id, &a);
			status = SSH2_FX_OK;
d672 1
a672 1
	if (status != SSH2_FX_OK)
d694 1
a694 1
	int status = SSH2_FX_OK;
d700 1
a700 1
	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
d705 1
a705 1
	if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
a709 5
	if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
		ret = chown(name, a->uid, a->gid);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
d720 1
a720 1
	int status = SSH2_FX_OK;
d728 1
a728 1
		status = SSH2_FX_FAILURE;
d730 1
a730 1
		if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
d735 1
a735 1
		if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
a739 5
		if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
			ret = fchown(fd, a->uid, a->gid);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
d749 1
a749 1
	int handle, status = SSH2_FX_FAILURE;
d755 1
a755 1
	dirp = opendir(path);
d764 1
a764 1
			status = SSH2_FX_OK;
d766 1
a766 1

d768 1
a768 1
	if (status != SSH2_FX_OK)
a772 3
/*
 * drwxr-xr-x    5 markus   markus       1024 Jan 13 18:39 .ssh
 */
d776 4
a779 30
	int sz = 0;
	struct passwd *pw;
	struct group *gr;
	struct tm *ltime = localtime(&st->st_mtime);
	char *user, *group;
	char buf[1024], mode[11+1], tbuf[12+1], ubuf[11+1], gbuf[11+1];

	strmode(st->st_mode, mode);
	if ((pw = getpwuid(st->st_uid)) != NULL) {
		user = pw->pw_name;
	} else {
		snprintf(ubuf, sizeof ubuf, "%d", st->st_uid);
		user = ubuf;
	}
	if ((gr = getgrgid(st->st_gid)) != NULL) {
		group = gr->gr_name;
	} else {
		snprintf(gbuf, sizeof gbuf, "%d", st->st_gid);
		group = gbuf;
	}
	if (ltime != NULL) {
		if (time(NULL) - st->st_mtime < (365*24*60*60)/2)
			sz = strftime(tbuf, sizeof tbuf, "%b %e %H:%M", ltime);
		else
			sz = strftime(tbuf, sizeof tbuf, "%b %e  %Y", ltime);
	}
	if (sz == 0)
		tbuf[0] = '\0';
	snprintf(buf, sizeof buf, "%s %3d %-8.8s %-8.8s %8llu %s %s", mode,
	    st->st_nlink, user, group, (unsigned long long)st->st_size, tbuf, name);
d798 1
a798 1
		send_status(id, SSH2_FX_FAILURE);
d800 1
d816 2
a817 1
			stat_to_attrib(&st, &(stats[count].attrib));
a821 1
			/* XXX check packet size instead */
d825 4
a828 8
		if (count > 0) {
			send_names(id, count, stats);
			for(i = 0; i < count; i++) {
				xfree(stats[i].name);
				xfree(stats[i].long_name);
			}
		} else {
			send_status(id, SSH2_FX_EOF);
d839 1
a839 1
	int status = SSH2_FX_FAILURE;
d845 2
a846 2
	ret = unlink(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d857 1
a857 1
	int ret, mode, status = SSH2_FX_FAILURE;
d862 1
a862 2
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ?
	    a->perm & 0777 : 0777;
d865 1
a865 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d881 1
a881 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
a894 4
	if (path[0] == '\0') {
		xfree(path);
		path = xstrdup(".");
	}
a910 1
	struct stat st;
d912 1
a912 1
	int ret, status = SSH2_FX_FAILURE;
d918 2
a919 5
	/* fail if 'newpath' exists */
	if (stat(newpath, &st) == -1) {
		ret = rename(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
a924 11
void
process_extended(void)
{
	u_int32_t id;
	char *request;

	id = get_int();
	request = get_string(NULL);
	send_status(id, SSH2_FX_OP_UNSUPPORTED);		/* MUST */
	xfree(request);
}
d931 3
a933 3
	u_int msg_len;
	u_int type;
	u_char *cp;
d937 1
a937 1
	cp = (u_char *) buffer_ptr(&iqueue);
d948 1
a948 1
	case SSH2_FXP_INIT:
d951 1
a951 1
	case SSH2_FXP_OPEN:
d954 1
a954 1
	case SSH2_FXP_CLOSE:
d957 1
a957 1
	case SSH2_FXP_READ:
d960 1
a960 1
	case SSH2_FXP_WRITE:
d963 1
a963 1
	case SSH2_FXP_LSTAT:
d966 1
a966 1
	case SSH2_FXP_FSTAT:
d969 1
a969 1
	case SSH2_FXP_SETSTAT:
d972 1
a972 1
	case SSH2_FXP_FSETSTAT:
d975 1
a975 1
	case SSH2_FXP_OPENDIR:
d978 1
a978 1
	case SSH2_FXP_READDIR:
d981 1
a981 1
	case SSH2_FXP_REMOVE:
d984 1
a984 1
	case SSH2_FXP_MKDIR:
d987 1
a987 1
	case SSH2_FXP_RMDIR:
d990 1
a990 1
	case SSH2_FXP_REALPATH:
d993 1
a993 1
	case SSH2_FXP_STAT:
d996 1
a996 1
	case SSH2_FXP_RENAME:
a998 3
	case SSH2_FXP_EXTENDED:
		process_extended();
		break;
a1012 4

#ifdef DEBUG_SFTP_SERVER
	log_init("sftp-server", SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 0);
#endif
@


1.6.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.6.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.24 2001/03/14 22:50:25 deraadt Exp $");
a45 3
/* Version of client */
int version;

a59 1

d90 2
a91 3

	if ((pflags & SSH2_FXF_READ) &&
	    (pflags & SSH2_FXF_WRITE)) {
a121 1

a126 1

a132 1

a140 1

a174 1

a212 1

a230 1

a243 1

a252 13
	const char *status_messages[] = {
		"Success",			/* SSH_FX_OK */
		"End of file",			/* SSH_FX_EOF */
		"No such file",			/* SSH_FX_NO_SUCH_FILE */
		"Permission denied",		/* SSH_FX_PERMISSION_DENIED */
		"Failure",			/* SSH_FX_FAILURE */
		"Bad message",			/* SSH_FX_BAD_MESSAGE */
		"No connection",		/* SSH_FX_NO_CONNECTION */
		"Connection lost",		/* SSH_FX_CONNECTION_LOST */
		"Operation unsupported",	/* SSH_FX_OP_UNSUPPORTED */
		"Unknown error"			/* Others */
	};

a257 5
	if (version >= 3) {
		buffer_put_cstring(&msg, 
		    status_messages[MIN(error,SSH2_FX_MAX)]);
		buffer_put_cstring(&msg, "");
	}
a264 1

a284 1

a295 1

a313 1

d329 1
a330 1
	version = buffer_get_int(&iqueue);
a529 1

a826 45
process_readlink(void)
{
	u_int32_t id;
	char link[MAXPATHLEN];
	char *path;

	id = get_int();
	path = get_string(NULL);
	TRACE("readlink id %d path %s", id, path);
	if (readlink(path, link, sizeof(link) - 1) == -1)
		send_status(id, errno_to_portable(errno));
	else {
		Stat s;
		
		link[sizeof(link) - 1] = '\0';
		attrib_clear(&s.attrib);
		s.name = s.long_name = link;
		send_names(id, 1, &s);
	}
	xfree(path);
}

void
process_symlink(void)
{
	u_int32_t id;
	struct stat st;
	char *oldpath, *newpath;
	int ret, status = SSH2_FX_FAILURE;

	id = get_int();
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
	TRACE("symlink id %d old %s new %s", id, oldpath, newpath);
	/* fail if 'newpath' exists */
	if (stat(newpath, &st) == -1) {
		ret = symlink(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
	send_status(id, status);
	xfree(oldpath);
	xfree(newpath);
}

void
a910 6
	case SSH2_FXP_READLINK:
		process_readlink();
		break;
	case SSH2_FXP_SYMLINK:
		process_symlink();
		break;
d923 1
a923 1
	fd_set *rset, *wset;
d925 1
a925 3
	ssize_t len, olen, set_size;

	/* XXX should use getopt */
a944 4
	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
	rset = (fd_set *)xmalloc(set_size);
	wset = (fd_set *)xmalloc(set_size);

d946 2
a947 2
		memset(rset, 0, set_size);
		memset(wset, 0, set_size);
d949 1
a949 1
		FD_SET(in, rset);
d952 1
a952 1
			FD_SET(out, wset);
d954 1
a954 1
		if (select(max+1, rset, wset, NULL, NULL) < 0) {
d961 1
a961 1
		if (FD_ISSET(in, rset)) {
d975 1
a975 1
		if (FD_ISSET(out, wset)) {
@


1.6.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.25 2001/04/05 10:42:53 markus Exp $");
d285 1
a285 1
		buffer_put_cstring(&msg,
@


1.6.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.30 2001/07/31 12:42:50 jakob Exp $");
d59 1
a59 1
static int
d90 1
a90 1
static int
d112 1
a112 1
static Attrib *
d136 1
a136 1
static void
d145 1
a145 1
static int
d162 1
a162 1
static int
d169 1
a169 1
static int
d180 1
a180 1
static int
d194 1
a194 1
static char *
d203 1
a203 1
static DIR *
d211 1
a211 1
static int
d219 1
a219 1
static int
d236 1
a236 1
static int
d252 1
a252 1
static void
d262 1
a262 1
static void
d292 1
a292 1
static void
d305 1
a305 1
static void
d312 1
a312 1
static void
d324 1
a324 1
static void
d344 1
a344 1
static void
d360 1
a360 1
static void
d374 1
a374 1
static void
d406 1
a406 1
static void
d420 1
a420 1
static void
d460 1
a460 1
static void
d498 1
a498 1
static void
d523 1
a523 1
static void
d529 1
a529 1
static void
d535 1
a535 1
static void
d561 1
a561 1
static struct timeval *
d573 1
a573 1
static void
d605 1
a605 1
static void
d640 1
a640 1
static void
d672 1
a672 1
static char *
d675 1
a675 1
	int ulen, glen, sz = 0;
d703 2
a704 5
	ulen = MAX(strlen(user), 8);
	glen = MAX(strlen(group), 8);
	snprintf(buf, sizeof buf, "%s %3d %-*s %-*s %8llu %s %s", mode,
	    st->st_nlink, ulen, user, glen, group,
	    (unsigned long long)st->st_size, tbuf, name);
d708 1
a708 1
static void
d736 2
a737 2
			snprintf(pathname, sizeof pathname, "%s%s%s", path,
			    strcmp(path, "/") ? "/" : "", dp->d_name);
d762 1
a762 1
static void
d779 1
a779 1
static void
d799 1
a799 1
static void
d815 1
a815 1
static void
d840 1
a840 1
static void
d862 1
a862 1
static void
a865 1
	int len;
d872 1
a872 1
	if ((len = readlink(path, link, sizeof(link) - 1)) == -1)
d877 1
a877 1
		link[len] = '\0';
d885 1
a885 1
static void
d907 1
a907 1
static void
d921 1
a921 1
static void
@


1.6.2.6
log
@Merge OpenSSH 3.1.
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001, 2002 Markus Friedl.  All rights reserved.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.33 2002/02/13 00:28:13 markus Exp $");
d141 1
a141 1
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
d150 1
a150 1
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++) {
a585 5
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
		ret = truncate(name, a->size);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
a620 5
		if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
			ret = ftruncate(fd, a->size);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
d754 1
a754 1
			for (i = 0; i < count; i++) {
d880 1
a880 1

d934 1
a934 1
	cp = buffer_ptr(&iqueue);
@


1.6.4.1
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.6 2000/09/07 20:27:53 deraadt Exp $");
@


1.6.4.2
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.19 2001/02/07 18:01:18 itojun Exp $");
d27 1
a30 1
#include "log.h"
d33 54
a86 2
#include "sftp.h"
#include "sftp-common.h"
a88 1
#define get_int64()			buffer_get_int64(&iqueue);
d91 1
a91 1
#define TRACE				debug
d99 1
d102 15
a116 1
struct Stat {
d128 1
a128 1
		ret = SSH2_FX_OK;
d134 1
a134 1
		ret = SSH2_FX_NO_SUCH_FILE;
d139 1
a139 1
		ret = SSH2_FX_PERMISSION_DENIED;
d143 1
a143 1
		ret = SSH2_FX_BAD_MESSAGE;
d146 1
a146 1
		ret = SSH2_FX_FAILURE;
d156 2
a157 2
	if (pflags & SSH2_FXF_READ &&
	    pflags & SSH2_FXF_WRITE) {
d159 1
a159 1
	} else if (pflags & SSH2_FXF_READ) {
d161 1
a161 1
	} else if (pflags & SSH2_FXF_WRITE) {
d164 1
a164 1
	if (pflags & SSH2_FXF_CREAT)
d166 1
a166 1
	if (pflags & SSH2_FXF_TRUNC)
d168 1
a168 1
	if (pflags & SSH2_FXF_EXCL)
d173 81
d303 1
a303 2
	return i >= 0 && i < sizeof(handles)/sizeof(Handle) &&
	    handles[i].use == type;
d309 1
d312 3
a314 3
	*stringp = xmalloc(sizeof(int32_t));
	PUT_32BIT(*stringp, handle);
	*hlenp = sizeof(int32_t);
d321 5
a325 2
	int val;
	if (hlen != sizeof(int32_t))
a326 1
	val = GET_32BIT(handle);
d353 1
a353 1
	if (handle_is_ok(handle, HANDLE_FILE))
d378 1
a378 1
	int val = -1;
d381 1
a381 2
	if (hlen < 256)
		val = handle_from_string(handle, hlen);
d403 1
a403 1
	buffer_put_char(&msg, SSH2_FXP_STATUS);
d425 1
a425 1
	send_data_or_handle(SSH2_FXP_DATA, id, data, dlen);
d435 1
a435 1
	send_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);
d445 1
a445 1
	buffer_put_char(&msg, SSH2_FXP_NAME);
d464 1
a464 1
	buffer_put_char(&msg, SSH2_FXP_ATTRS);
d481 2
a482 2
	buffer_put_char(&msg, SSH2_FXP_VERSION);
	buffer_put_int(&msg, SSH2_FILEXFER_VERSION);
d493 1
a493 1
	int handle, fd, flags, mode, status = SSH2_FX_FAILURE;
d497 1
a497 1
	pflags = get_int();		/* portable flags */
d500 1
a500 1
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a->perm : 0666;
d511 1
a511 1
			status = SSH2_FX_OK;
d514 1
a514 1
	if (status != SSH2_FX_OK)
d523 1
a523 1
	int handle, ret, status = SSH2_FX_FAILURE;
d529 1
a529 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d537 2
a538 2
	u_int32_t id, len;
	int handle, fd, ret, status = SSH2_FX_FAILURE;
d543 2
a544 1
	off = get_int64();
d547 2
a548 2
	TRACE("read id %d handle %d off %llu len %d", id, handle,
	    (unsigned long long)off, len);
d563 1
a563 1
				status = SSH2_FX_EOF;
d566 1
a566 1
				status = SSH2_FX_OK;
d570 1
a570 1
	if (status != SSH2_FX_OK)
d577 1
a577 1
	u_int32_t id;
d580 1
a580 1
	int handle, fd, ret, status = SSH2_FX_FAILURE;
d585 2
a586 1
	off = get_int64();
d589 2
a590 2
	TRACE("write id %d handle %d off %llu len %d", id, handle,
	    (unsigned long long)off, len);
d603 1
a603 1
				status = SSH2_FX_OK;
d616 1
a616 1
	Attrib a;
d620 1
a620 1
	int ret, status = SSH2_FX_FAILURE;
d629 3
a631 3
		stat_to_attrib(&st, &a);
		send_attrib(id, &a);
		status = SSH2_FX_OK;
d633 1
a633 1
	if (status != SSH2_FX_OK)
d653 1
a653 1
	Attrib a;
d656 1
a656 1
	int fd, ret, handle, status = SSH2_FX_FAILURE;
d667 3
a669 3
			stat_to_attrib(&st, &a);
			send_attrib(id, &a);
			status = SSH2_FX_OK;
d672 1
a672 1
	if (status != SSH2_FX_OK)
d694 1
a694 1
	int status = SSH2_FX_OK;
d700 1
a700 1
	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
d705 1
a705 1
	if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
a709 5
	if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
		ret = chown(name, a->uid, a->gid);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
d720 1
a720 1
	int status = SSH2_FX_OK;
d728 1
a728 1
		status = SSH2_FX_FAILURE;
d730 1
a730 1
		if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
d735 1
a735 1
		if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
a739 5
		if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
			ret = fchown(fd, a->uid, a->gid);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
d749 1
a749 1
	int handle, status = SSH2_FX_FAILURE;
d755 1
a755 1
	dirp = opendir(path);
d764 1
a764 1
			status = SSH2_FX_OK;
d766 1
a766 1

d768 1
a768 1
	if (status != SSH2_FX_OK)
a772 3
/*
 * drwxr-xr-x    5 markus   markus       1024 Jan 13 18:39 .ssh
 */
d776 4
a779 30
	int sz = 0;
	struct passwd *pw;
	struct group *gr;
	struct tm *ltime = localtime(&st->st_mtime);
	char *user, *group;
	char buf[1024], mode[11+1], tbuf[12+1], ubuf[11+1], gbuf[11+1];

	strmode(st->st_mode, mode);
	if ((pw = getpwuid(st->st_uid)) != NULL) {
		user = pw->pw_name;
	} else {
		snprintf(ubuf, sizeof ubuf, "%d", st->st_uid);
		user = ubuf;
	}
	if ((gr = getgrgid(st->st_gid)) != NULL) {
		group = gr->gr_name;
	} else {
		snprintf(gbuf, sizeof gbuf, "%d", st->st_gid);
		group = gbuf;
	}
	if (ltime != NULL) {
		if (time(NULL) - st->st_mtime < (365*24*60*60)/2)
			sz = strftime(tbuf, sizeof tbuf, "%b %e %H:%M", ltime);
		else
			sz = strftime(tbuf, sizeof tbuf, "%b %e  %Y", ltime);
	}
	if (sz == 0)
		tbuf[0] = '\0';
	snprintf(buf, sizeof buf, "%s %3d %-8.8s %-8.8s %8llu %s %s", mode,
	    st->st_nlink, user, group, (unsigned long long)st->st_size, tbuf, name);
d798 1
a798 1
		send_status(id, SSH2_FX_FAILURE);
d800 1
d816 2
a817 1
			stat_to_attrib(&st, &(stats[count].attrib));
a821 1
			/* XXX check packet size instead */
d825 4
a828 8
		if (count > 0) {
			send_names(id, count, stats);
			for(i = 0; i < count; i++) {
				xfree(stats[i].name);
				xfree(stats[i].long_name);
			}
		} else {
			send_status(id, SSH2_FX_EOF);
d839 1
a839 1
	int status = SSH2_FX_FAILURE;
d845 2
a846 2
	ret = unlink(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d857 1
a857 1
	int ret, mode, status = SSH2_FX_FAILURE;
d862 1
a862 2
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ?
	    a->perm & 0777 : 0777;
d865 1
a865 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
d881 1
a881 1
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
a894 4
	if (path[0] == '\0') {
		xfree(path);
		path = xstrdup(".");
	}
a910 1
	struct stat st;
d912 1
a912 1
	int ret, status = SSH2_FX_FAILURE;
d918 2
a919 5
	/* fail if 'newpath' exists */
	if (stat(newpath, &st) == -1) {
		ret = rename(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
a924 11
void
process_extended(void)
{
	u_int32_t id;
	char *request;

	id = get_int();
	request = get_string(NULL);
	send_status(id, SSH2_FX_OP_UNSUPPORTED);		/* MUST */
	xfree(request);
}
d931 3
a933 3
	u_int msg_len;
	u_int type;
	u_char *cp;
d937 1
a937 1
	cp = (u_char *) buffer_ptr(&iqueue);
d948 1
a948 1
	case SSH2_FXP_INIT:
d951 1
a951 1
	case SSH2_FXP_OPEN:
d954 1
a954 1
	case SSH2_FXP_CLOSE:
d957 1
a957 1
	case SSH2_FXP_READ:
d960 1
a960 1
	case SSH2_FXP_WRITE:
d963 1
a963 1
	case SSH2_FXP_LSTAT:
d966 1
a966 1
	case SSH2_FXP_FSTAT:
d969 1
a969 1
	case SSH2_FXP_SETSTAT:
d972 1
a972 1
	case SSH2_FXP_FSETSTAT:
d975 1
a975 1
	case SSH2_FXP_OPENDIR:
d978 1
a978 1
	case SSH2_FXP_READDIR:
d981 1
a981 1
	case SSH2_FXP_REMOVE:
d984 1
a984 1
	case SSH2_FXP_MKDIR:
d987 1
a987 1
	case SSH2_FXP_RMDIR:
d990 1
a990 1
	case SSH2_FXP_REALPATH:
d993 1
a993 1
	case SSH2_FXP_STAT:
d996 1
a996 1
	case SSH2_FXP_RENAME:
a998 3
	case SSH2_FXP_EXTENDED:
		process_extended();
		break;
a1012 4

#ifdef DEBUG_SFTP_SERVER
	log_init("sftp-server", SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 0);
#endif
@


1.6.4.3
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.24 2001/03/14 22:50:25 deraadt Exp $");
a45 3
/* Version of client */
int version;

a59 1

d90 2
a91 3

	if ((pflags & SSH2_FXF_READ) &&
	    (pflags & SSH2_FXF_WRITE)) {
a121 1

a126 1

a132 1

a140 1

a174 1

a212 1

a230 1

a243 1

a252 13
	const char *status_messages[] = {
		"Success",			/* SSH_FX_OK */
		"End of file",			/* SSH_FX_EOF */
		"No such file",			/* SSH_FX_NO_SUCH_FILE */
		"Permission denied",		/* SSH_FX_PERMISSION_DENIED */
		"Failure",			/* SSH_FX_FAILURE */
		"Bad message",			/* SSH_FX_BAD_MESSAGE */
		"No connection",		/* SSH_FX_NO_CONNECTION */
		"Connection lost",		/* SSH_FX_CONNECTION_LOST */
		"Operation unsupported",	/* SSH_FX_OP_UNSUPPORTED */
		"Unknown error"			/* Others */
	};

a257 5
	if (version >= 3) {
		buffer_put_cstring(&msg, 
		    status_messages[MIN(error,SSH2_FX_MAX)]);
		buffer_put_cstring(&msg, "");
	}
a264 1

a284 1

a295 1

a313 1

d329 1
a330 1
	version = buffer_get_int(&iqueue);
a529 1

a826 45
process_readlink(void)
{
	u_int32_t id;
	char link[MAXPATHLEN];
	char *path;

	id = get_int();
	path = get_string(NULL);
	TRACE("readlink id %d path %s", id, path);
	if (readlink(path, link, sizeof(link) - 1) == -1)
		send_status(id, errno_to_portable(errno));
	else {
		Stat s;
		
		link[sizeof(link) - 1] = '\0';
		attrib_clear(&s.attrib);
		s.name = s.long_name = link;
		send_names(id, 1, &s);
	}
	xfree(path);
}

void
process_symlink(void)
{
	u_int32_t id;
	struct stat st;
	char *oldpath, *newpath;
	int ret, status = SSH2_FX_FAILURE;

	id = get_int();
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
	TRACE("symlink id %d old %s new %s", id, oldpath, newpath);
	/* fail if 'newpath' exists */
	if (stat(newpath, &st) == -1) {
		ret = symlink(oldpath, newpath);
		status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	}
	send_status(id, status);
	xfree(oldpath);
	xfree(newpath);
}

void
a910 6
	case SSH2_FXP_READLINK:
		process_readlink();
		break;
	case SSH2_FXP_SYMLINK:
		process_symlink();
		break;
d923 1
a923 1
	fd_set *rset, *wset;
d925 1
a925 3
	ssize_t len, olen, set_size;

	/* XXX should use getopt */
a944 4
	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
	rset = (fd_set *)xmalloc(set_size);
	wset = (fd_set *)xmalloc(set_size);

d946 2
a947 2
		memset(rset, 0, set_size);
		memset(wset, 0, set_size);
d949 1
a949 1
		FD_SET(in, rset);
d952 1
a952 1
			FD_SET(out, wset);
d954 1
a954 1
		if (select(max+1, rset, wset, NULL, NULL) < 0) {
d961 1
a961 1
		if (FD_ISSET(in, rset)) {
d975 1
a975 1
		if (FD_ISSET(out, wset)) {
@


1.5
log
@cleanup
@
text
@a11 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Markus Friedl.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 1
a25 1
RCSID("$OpenBSD: sftp-server.c,v 1.4 2000/09/04 19:10:08 markus Exp $");
@


1.4
log
@more cast fixes; from mouring@@pconline.com
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-server.c,v 1.3 2000/09/01 22:32:41 markus Exp $");
d197 1
a197 1
	a.flags = get_int();
d199 2
a200 2
		a.size_high = get_int();
		a.size_low = get_int();
d204 2
a205 2
		a.uid = get_int();
		a.gid = get_int();
d208 1
a208 1
		a.perm = get_int();
d211 2
a212 2
		a.atime = get_int();
		a.mtime = get_int();
d324 1
a324 1
handle_from_string(char *handle, int hlen)
d383 2
a384 1
	int hlen, val;
d584 1
a584 1
	int len;
d1015 1
a1015 1
	size_t len, olen;
@


1.3
log
@fix cast; mouring@@pconline.com
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-server.c,v 1.2 2000/09/01 22:29:32 markus Exp $");
d201 1
a201 1
		a.size = (u_int64_t) a.size_high << 32 + a.size_low;
d551 1
a551 1
	off = (u_int64_t) off_high << 32 + off_low;
d593 1
a593 1
	off = (u_int64_t) off_high << 32 + off_low;
d782 1
a782 1
	    st->st_mode, st->st_uid, st->st_gid, st->st_size, st->st_mtime,
@


1.2
log
@portability fixes
@
text
@d30 1
a30 1
RCSID("$OpenBSD: sftp-server.c,v 1.33 2000/08/19 21:34:43 markus Exp $");
d247 1
a247 1
	a.size_high = (u_int32_t) a.size >> 32;
@


1.1
log
@implement a SFTP server. interops with sftp2, scp2 and the windows
client from ssh.com
@
text
@d128 1
a128 1
errno_to_portable(int errno)
d131 1
a131 1
	switch (errno) {
d201 1
a201 3
		a.size = a.size_high;
		a.size <<= 32;
		a.size += a.size_low;
d246 2
a247 2
	a.size_low = st->st_size;
	a.size_high = st->st_size >> 32;
a483 2
	if (version != SSH_FILEXFER_VERSION)
		exit(1);
d551 1
a551 3
	off = off_high;
	off <<= 32;
	off += off_low;
d593 1
a593 3
	off = off_high;
	off <<= 32;
	off += off_low;
d916 1
a916 2
	int ret;
	int status = SSH_FX_FAILURE;
d923 1
a923 2
	if (ret != -1)
		status = SSH_FX_OK;
@

