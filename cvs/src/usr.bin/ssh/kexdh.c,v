head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.6
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.30
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.28
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.26
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.24
	OPENBSD_5_0:1.23.0.22
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.20
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.18
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.14
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.16
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.12
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.10
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.8
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.12
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.10
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.8
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.6
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.4
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2;
locks; strict;
comment	@ * @;


1.26
date	2016.05.02.10.26.04;	author djm;	state Exp;
branches;
next	1.25;
commitid	rVUG0L3JBpFl5b0k;

1.25
date	2015.01.19.20.16.15;	author markus;	state Exp;
branches;
next	1.24;
commitid	U9l75XYAjMKaQ8Jp;

1.24
date	2014.01.09.23.20.00;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.04.05.15.59;	author djm;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2003.02.16.17.09.57;	author markus;	state Exp;
branches
	1.19.10.1
	1.19.12.1;
next	1.18;

1.18
date	2002.03.18.17.50.31;	author provos;	state Exp;
branches
	1.18.2.1
	1.18.4.1;
next	1.17;

1.17
date	2002.02.28.15.46.33;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.23.17.59.02;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.31.13.35.11;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.25.22.07.40;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.28.14.50.54;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.28.13.57.33;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.28.12.14.27;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.27.19.37.22;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.27.18.22.16;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.17.19.27.15;	author stevesk;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.06.23.15.12.18;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.23.02.34.29;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.07.20.23.04;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.04.09.48.34;	author markus;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.04.03.23.32.12;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.03.19.53.29;	author markus;	state Exp;
branches;
next	;

1.3.2.1
date	2001.09.27.19.03.54;	author jason;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.03.09.00.20.44;	author miod;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2002.06.02.22.56.10;	author miod;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.07.21.09.30;	author jason;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.08.17.04.42;	author brad;	state Exp;
branches;
next	;

1.7.2.1
date	2002.03.07.17.37.46;	author jason;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.05.17.00.03.23;	author miod;	state Exp;
branches;
next	;

1.18.2.1
date	2003.04.03.22.35.17;	author miod;	state Exp;
branches;
next	;

1.18.4.1
date	2003.04.01.00.12.13;	author margarida;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2003.09.16.21.20.26;	author brad;	state Exp;
branches;
next	;

1.19.10.1
date	2006.02.03.02.53.44;	author brad;	state Exp;
branches;
next	;

1.19.12.1
date	2006.02.03.03.01.56;	author brad;	state Exp;
branches;
next	1.19.12.2;

1.19.12.2
date	2006.10.06.03.19.32;	author brad;	state Exp;
branches;
next	;

1.20.2.1
date	2006.09.30.04.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.26
log
@add support for additional fixed DH groups from
draft-ietf-curdle-ssh-kex-sha2-03

diffie-hellman-group14-sha256 (2K group)
diffie-hellman-group16-sha512 (4K group)
diffie-hellman-group18-sha512 (8K group)

based on patch from Mark D. Baushke and Darren Tucker
ok markus@@
@
text
@/* $OpenBSD: kexdh.c,v 1.25 2015/01/19 20:16:15 markus Exp $ */
/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <signal.h>

#include <openssl/evp.h>

#include "ssh2.h"
#include "sshkey.h"
#include "cipher.h"
#include "kex.h"
#include "ssherr.h"
#include "sshbuf.h"
#include "digest.h"

int
kex_dh_hash(
    int hash_alg,
    const char *client_version_string,
    const char *server_version_string,
    const u_char *ckexinit, size_t ckexinitlen,
    const u_char *skexinit, size_t skexinitlen,
    const u_char *serverhostkeyblob, size_t sbloblen,
    const BIGNUM *client_dh_pub,
    const BIGNUM *server_dh_pub,
    const BIGNUM *shared_secret,
    u_char *hash, size_t *hashlen)
{
	struct sshbuf *b;
	int r;

	if (*hashlen < ssh_digest_bytes(hash_alg))
		return SSH_ERR_INVALID_ARGUMENT;
	if ((b = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if ((r = sshbuf_put_cstring(b, client_version_string)) != 0 ||
	    (r = sshbuf_put_cstring(b, server_version_string)) != 0 ||
	    /* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
	    (r = sshbuf_put_u32(b, ckexinitlen+1)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_KEXINIT)) != 0 ||
	    (r = sshbuf_put(b, ckexinit, ckexinitlen)) != 0 ||
	    (r = sshbuf_put_u32(b, skexinitlen+1)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_KEXINIT)) != 0 ||
	    (r = sshbuf_put(b, skexinit, skexinitlen)) != 0 ||
	    (r = sshbuf_put_string(b, serverhostkeyblob, sbloblen)) != 0 ||
	    (r = sshbuf_put_bignum2(b, client_dh_pub)) != 0 ||
	    (r = sshbuf_put_bignum2(b, server_dh_pub)) != 0 ||
	    (r = sshbuf_put_bignum2(b, shared_secret)) != 0) {
		sshbuf_free(b);
		return r;
	}
#ifdef DEBUG_KEX
	sshbuf_dump(b, stderr);
#endif
	if (ssh_digest_buffer(hash_alg, b, hash, *hashlen) != 0) {
		sshbuf_free(b);
		return SSH_ERR_LIBCRYPTO_ERROR;
	}
	sshbuf_free(b);
	*hashlen = ssh_digest_bytes(hash_alg);
#ifdef DEBUG_KEX
	dump_digest("hash", hash, *hashlen);
#endif
	return 0;
}
@


1.25
log
@adapt kex to sshbuf and struct ssh; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdh.c,v 1.24 2014/01/09 23:20:00 djm Exp $ */
d42 1
d56 1
a56 1
	if (*hashlen < ssh_digest_bytes(SSH_DIGEST_SHA1))
d79 1
a79 1
	if (ssh_digest_buffer(SSH_DIGEST_SHA1, b, hash, *hashlen) != 0) {
d84 1
a84 1
	*hashlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
@


1.24
log
@Introduce digest API and use it to perform all hashing operations
rather than calling OpenSSL EVP_Digest* directly. Will make it easier
to build a reduced-feature OpenSSH without OpenSSL in future;
feedback, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: kexdh.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
a31 1
#include "buffer.h"
d33 1
a33 1
#include "key.h"
d36 2
a38 1
#include "log.h"
d40 1
a40 1
void
d42 9
a50 9
    char *client_version_string,
    char *server_version_string,
    char *ckexinit, int ckexinitlen,
    char *skexinit, int skexinitlen,
    u_char *serverhostkeyblob, int sbloblen,
    BIGNUM *client_dh_pub,
    BIGNUM *server_dh_pub,
    BIGNUM *shared_secret,
    u_char **hash, u_int *hashlen)
d52 2
a53 19
	Buffer b;
	static u_char digest[SSH_DIGEST_MAX_LENGTH];

	buffer_init(&b);
	buffer_put_cstring(&b, client_version_string);
	buffer_put_cstring(&b, server_version_string);

	/* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
	buffer_put_int(&b, ckexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, ckexinit, ckexinitlen);
	buffer_put_int(&b, skexinitlen+1);
	buffer_put_char(&b, SSH2_MSG_KEXINIT);
	buffer_append(&b, skexinit, skexinitlen);

	buffer_put_string(&b, serverhostkeyblob, sbloblen);
	buffer_put_bignum2(&b, client_dh_pub);
	buffer_put_bignum2(&b, server_dh_pub);
	buffer_put_bignum2(&b, shared_secret);
d55 20
d76 1
a76 1
	buffer_dump(&b);
d78 6
a83 5
	if (ssh_digest_buffer(SSH_DIGEST_SHA1, &b, digest, sizeof(digest)) != 0)
		fatal("%s: ssh_digest_buffer failed", __func__);

	buffer_free(&b);

d85 1
a85 1
	dump_digest("hash", digest, ssh_digest_bytes(SSH_DIGEST_SHA1));
d87 1
a87 2
	*hash = digest;
	*hashlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
@


1.23
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: kexdh.c,v 1.22 2006/03/25 13:17:02 djm Exp $ */
d37 2
d53 1
a53 3
	static u_char digest[EVP_MAX_MD_SIZE];
	const EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
d75 2
a76 3
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, buffer_ptr(&b), buffer_len(&b));
	EVP_DigestFinal(&md, digest, NULL);
d81 1
a81 1
	dump_digest("hash", digest, EVP_MD_size(evp_md));
d84 1
a84 1
	*hashlen = EVP_MD_size(evp_md);
@


1.22
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d26 3
a28 1
#include "includes.h"
a32 1
#include "bufaux.h"
d34 2
@


1.21
log
@RCSID() can die
@
text
@d1 1
@


1.20
log
@remove hardcoded hash lengths in key exchange code, allowing
implementation of KEX methods with different hashes (e.g. SHA-256);
ok markus@@ dtucker@@ stevesk@@
@
text
@a25 1
RCSID("$OpenBSD: kexdh.c,v 1.19 2003/02/16 17:09:57 markus Exp $");
@


1.20.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexdh.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 3
#include <sys/types.h>

#include <signal.h>
d31 1
a32 2
#include "key.h"
#include "cipher.h"
@


1.19
log
@split kex into client and server code, no need to link
server code into the client; ok provos@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.18 2002/03/18 17:50:31 provos Exp $");
d35 1
a35 1
u_char *
d44 2
a45 1
    BIGNUM *shared_secret)
d81 2
a82 1
	return digest;
@


1.19.12.1
log
@upgrade to OpenSSH 4.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.20 2005/11/04 05:15:59 djm Exp $");
d35 1
a35 1
void
d44 1
a44 2
    BIGNUM *shared_secret,
    u_char **hash, u_int *hashlen)
d80 1
a80 2
	*hash = digest;
	*hashlen = EVP_MD_size(evp_md);
@


1.19.12.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: kexdh.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d25 2
a26 3
#include <sys/types.h>

#include <signal.h>
d31 1
a32 2
#include "key.h"
#include "cipher.h"
@


1.19.10.1
log
@upgrade to OpenSSH 4.3
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.20 2005/11/04 05:15:59 djm Exp $");
d35 1
a35 1
void
d44 1
a44 2
    BIGNUM *shared_secret,
    u_char **hash, u_int *hashlen)
d80 1
a80 2
	*hash = digest;
	*hashlen = EVP_MD_size(evp_md);
@


1.18
log
@integrate privilege separated openssh; its turned off by default for now.
work done by me and markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.17 2002/02/28 15:46:33 markus Exp $");
d28 1
a28 2
#include <openssl/crypto.h>
#include <openssl/bn.h>
a29 1
#include "xmalloc.h"
d32 1
a32 1
#include "key.h"
a33 5
#include "log.h"
#include "packet.h"
#include "dh.h"
#include "ssh2.h"
#include "monitor_wrap.h"
d35 1
a35 1
static u_char *
a80 219
}

/* client */

static void
kexdh_client(Kex *kex)
{
	BIGNUM *dh_server_pub = NULL, *shared_secret = NULL;
	DH *dh;
	Key *server_host_key;
	u_char *server_host_key_blob = NULL, *signature = NULL;
	u_char *kbuf, *hash;
	u_int klen, kout, slen, sbloblen;

	/* generate and send 'e', client DH public key */
	dh = dh_new_group1();
	dh_gen_key(dh, kex->we_need * 8);
	packet_start(SSH2_MSG_KEXDH_INIT);
	packet_put_bignum2(dh->pub_key);
	packet_send();

	debug("sending SSH2_MSG_KEXDH_INIT");
#ifdef DEBUG_KEXDH
	DHparams_print_fp(stderr, dh);
	fprintf(stderr, "pub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
#endif

	debug("expecting SSH2_MSG_KEXDH_REPLY");
	packet_read_expect(SSH2_MSG_KEXDH_REPLY);

	/* key, cert */
	server_host_key_blob = packet_get_string(&sbloblen);
	server_host_key = key_from_blob(server_host_key_blob, sbloblen);
	if (server_host_key == NULL)
		fatal("cannot decode server_host_key_blob");
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
	if (kex->verify_host_key == NULL)
		fatal("cannot verify server_host_key");
	if (kex->verify_host_key(server_host_key) == -1)
		fatal("server_host_key verification failed");

	/* DH paramter f, server public DH key */
	if ((dh_server_pub = BN_new()) == NULL)
		fatal("dh_server_pub == NULL");
	packet_get_bignum2(dh_server_pub);

#ifdef DEBUG_KEXDH
	fprintf(stderr, "dh_server_pub= ");
	BN_print_fp(stderr, dh_server_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_server_pub));
#endif

	/* signed H */
	signature = packet_get_string(&slen);
	packet_check_eom();

	if (!dh_pub_is_valid(dh, dh_server_pub))
		packet_disconnect("bad server public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_server_pub, dh);
#ifdef DEBUG_KEXDH
	dump_digest("shared secret", kbuf, kout);
#endif
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_client: BN_new failed");
	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	/* calc and verify H */
	hash = kex_dh_hash(
	    kex->client_version_string,
	    kex->server_version_string,
	    buffer_ptr(&kex->my), buffer_len(&kex->my),
	    buffer_ptr(&kex->peer), buffer_len(&kex->peer),
	    server_host_key_blob, sbloblen,
	    dh->pub_key,
	    dh_server_pub,
	    shared_secret
	);
	xfree(server_host_key_blob);
	BN_clear_free(dh_server_pub);
	DH_free(dh);

	if (key_verify(server_host_key, signature, slen, hash, 20) != 1)
		fatal("key_verify failed for server_host_key");
	key_free(server_host_key);
	xfree(signature);

	/* save session id */
	if (kex->session_id == NULL) {
		kex->session_id_len = 20;
		kex->session_id = xmalloc(kex->session_id_len);
		memcpy(kex->session_id, hash, kex->session_id_len);
	}

	kex_derive_keys(kex, hash, shared_secret);
	BN_clear_free(shared_secret);
	kex_finish(kex);
}

/* server */

static void
kexdh_server(Kex *kex)
{
	BIGNUM *shared_secret = NULL, *dh_client_pub = NULL;
	DH *dh;
	Key *server_host_key;
	u_char *kbuf, *hash, *signature = NULL, *server_host_key_blob = NULL;
	u_int sbloblen, klen, kout;
	u_int slen;

	/* generate server DH public key */
	dh = dh_new_group1();
	dh_gen_key(dh, kex->we_need * 8);

	debug("expecting SSH2_MSG_KEXDH_INIT");
	packet_read_expect(SSH2_MSG_KEXDH_INIT);

	if (kex->load_host_key == NULL)
		fatal("Cannot load hostkey");
	server_host_key = kex->load_host_key(kex->hostkey_type);
	if (server_host_key == NULL)
		fatal("Unsupported hostkey type %d", kex->hostkey_type);

	/* key, cert */
	if ((dh_client_pub = BN_new()) == NULL)
		fatal("dh_client_pub == NULL");
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();

#ifdef DEBUG_KEXDH
	fprintf(stderr, "dh_client_pub= ");
	BN_print_fp(stderr, dh_client_pub);
	fprintf(stderr, "\n");
	debug("bits %d", BN_num_bits(dh_client_pub));
#endif

#ifdef DEBUG_KEXDH
	DHparams_print_fp(stderr, dh);
	fprintf(stderr, "pub= ");
	BN_print_fp(stderr, dh->pub_key);
	fprintf(stderr, "\n");
#endif
	if (!dh_pub_is_valid(dh, dh_client_pub))
		packet_disconnect("bad client public DH value");

	klen = DH_size(dh);
	kbuf = xmalloc(klen);
	kout = DH_compute_key(kbuf, dh_client_pub, dh);
#ifdef DEBUG_KEXDH
	dump_digest("shared secret", kbuf, kout);
#endif
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_server: BN_new failed");
	BN_bin2bn(kbuf, kout, shared_secret);
	memset(kbuf, 0, klen);
	xfree(kbuf);

	key_to_blob(server_host_key, &server_host_key_blob, &sbloblen);

	/* calc H */
	hash = kex_dh_hash(
	    kex->client_version_string,
	    kex->server_version_string,
	    buffer_ptr(&kex->peer), buffer_len(&kex->peer),
	    buffer_ptr(&kex->my), buffer_len(&kex->my),
	    server_host_key_blob, sbloblen,
	    dh_client_pub,
	    dh->pub_key,
	    shared_secret
	);
	BN_clear_free(dh_client_pub);

	/* save session id := H */
	/* XXX hashlen depends on KEX */
	if (kex->session_id == NULL) {
		kex->session_id_len = 20;
		kex->session_id = xmalloc(kex->session_id_len);
		memcpy(kex->session_id, hash, kex->session_id_len);
	}

	/* sign H */
	/* XXX hashlen depends on KEX */
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, 20));

	/* destroy_sensitive_data(); */

	/* send server hostkey, DH pubkey 'f' and singed H */
	packet_start(SSH2_MSG_KEXDH_REPLY);
	packet_put_string(server_host_key_blob, sbloblen);
	packet_put_bignum2(dh->pub_key);	/* f */
	packet_put_string(signature, slen);
	packet_send();

	xfree(signature);
	xfree(server_host_key_blob);
	/* have keys, free DH */
	DH_free(dh);

	kex_derive_keys(kex, hash, shared_secret);
	BN_clear_free(shared_secret);
	kex_finish(kex);
}

void
kexdh(Kex *kex)
{
	if (kex->server)
		kexdh_server(kex);
	else
		kexdh_client(kex);
@


1.18.2.1
log
@Merge OpenSSH 3.6.1
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.19 2003/02/16 17:09:57 markus Exp $");
d28 2
a29 1
#include <openssl/evp.h>
d31 1
d34 5
d40 1
a40 1
#include "kex.h"
d42 1
a42 1
u_char *
d88 219
@


1.18.4.1
log
@Update to OpenSSH 3.6
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.19 2003/02/16 17:09:57 markus Exp $");
d28 2
a29 1
#include <openssl/evp.h>
d31 1
d34 5
d40 1
a40 1
#include "kex.h"
d42 1
a42 1
u_char *
d88 219
@


1.18.4.2
log
@upgrade to OpenSSH 3.7
@
text
@@


1.17
log
@add some const EVP_MD for openssl-0.9.7
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.16 2002/02/24 19:14:59 markus Exp $");
d40 1
d279 1
a279 1
	key_sign(server_host_key, &signature, &slen, hash, 20);
@


1.16
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.15 2002/02/23 17:59:02 markus Exp $");
d54 1
a54 1
	EVP_MD *evp_md = EVP_sha1();
@


1.15
log
@don't allow garbage after payload.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.14 2002/01/31 13:35:11 markus Exp $");
d204 1
a204 1
	int slen;
@


1.14
log
@cross check announced key type and type from key blob
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.13 2002/01/25 22:07:40 markus Exp $");
d223 1
@


1.13
log
@use EVP_MD_size(evp_md) and not evp_md->md_size; ok steveks@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.12 2001/12/28 14:50:54 markus Exp $");
d124 2
a125 1

@


1.12
log
@packet_read* no longer return the packet length, since it's not used.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.11 2001/12/28 13:57:33 markus Exp $");
d84 1
a84 1
	dump_digest("hash", digest, evp_md->md_size);
@


1.11
log
@packet_get_bignum* no longer returns a size
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.10 2001/12/28 12:14:27 markus Exp $");
a99 1
	int plen;
d117 1
a117 1
	packet_read_expect(&plen, SSH2_MSG_KEXDH_REPLY);
d203 1
a203 1
	int slen, plen;
d210 1
a210 1
	packet_read_expect(&plen, SSH2_MSG_KEXDH_INIT);
@


1.10
log
@s/packet_done/packet_check_eom/ (end-of-message); ok djm@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.9 2001/12/27 19:37:22 markus Exp $");
d100 1
a100 1
	int dlen, plen;
d134 1
a134 1
	packet_get_bignum2(dh_server_pub, &dlen);
d204 1
a204 1
	int dlen, slen, plen;
d222 1
a222 1
	packet_get_bignum2(dh_client_pub, &dlen);
@


1.9
log
@always use BN_clear_free instead of BN_free
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.8 2001/12/27 18:22:16 markus Exp $");
d145 1
a145 1
	packet_done();
@


1.8
log
@call fatal() for openssl allocation failures
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.7 2001/09/17 19:27:15 stevesk Exp $");
d174 1
a174 1
	BN_free(dh_server_pub);
d265 1
a265 1
	BN_free(dh_client_pub);
@


1.7
log
@u_char*/char* cleanup; ok markus@@
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.6 2001/06/23 15:12:18 itojun Exp $");
d132 1
a132 2
	dh_server_pub = BN_new();
	if (dh_server_pub == NULL)
d156 2
a157 1
	shared_secret = BN_new();
d220 1
a220 2
	dh_client_pub = BN_new();
	if (dh_client_pub == NULL)
d246 2
a247 1
	shared_secret = BN_new();
@


1.7.2.1
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.17 2002/02/28 15:46:33 markus Exp $");
d54 1
a54 1
	const EVP_MD *evp_md = EVP_sha1();
d84 1
a84 1
	dump_digest("hash", digest, EVP_MD_size(evp_md));
d100 1
d118 1
a118 1
	packet_read_expect(SSH2_MSG_KEXDH_REPLY);
d125 1
a125 2
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
d132 2
a133 1
	if ((dh_server_pub = BN_new()) == NULL)
d135 1
a135 1
	packet_get_bignum2(dh_server_pub);
d146 1
a146 1
	packet_check_eom();
d157 1
a157 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_client: BN_new failed");
d174 1
a174 1
	BN_clear_free(dh_server_pub);
d204 1
a204 1
	u_int slen;
d211 1
a211 1
	packet_read_expect(SSH2_MSG_KEXDH_INIT);
d220 2
a221 1
	if ((dh_client_pub = BN_new()) == NULL)
d223 1
a223 2
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();
d247 1
a247 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_server: BN_new failed");
d265 1
a265 1
	BN_clear_free(dh_client_pub);
@


1.7.2.2
log
@Update OpenSSH to version 3.2.2.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.18 2002/03/18 17:50:31 provos Exp $");
a39 1
#include "monitor_wrap.h"
d278 1
a278 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, 20));
@


1.6
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.5 2001/06/23 02:34:29 markus Exp $");
d47 1
a47 1
    char *serverhostkeyblob, int sbloblen,
d97 1
a97 1
	char *server_host_key_blob = NULL, *signature = NULL;
d177 1
a177 1
	if (key_verify(server_host_key, (u_char *)signature, slen, hash, 20) != 1)
d260 1
a260 1
	    (char *)server_host_key_blob, sbloblen,
d283 1
a283 1
	packet_put_string((char *)server_host_key_blob, sbloblen);
d285 1
a285 1
	packet_put_string((char *)signature, slen);
@


1.5
log
@get rid of known_hosts2, use it for hostkey lookup, but do not modify.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.4 2001/06/07 20:23:04 markus Exp $");
d41 1
a41 1
u_char *
d91 1
a91 1
void
d196 1
a196 1
void
@


1.4
log
@use xxx_put_cstring()
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.3 2001/04/04 09:48:34 markus Exp $");
d126 4
a129 3
	if (kex->check_host_key == NULL)
		fatal("cannot check server_host_key");
	kex->check_host_key(server_host_key);
@


1.3
log
@don't sent multiple kexinit-requests.
send newkeys, block while waiting for newkeys.
fix comments.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.2 2001/04/03 23:32:12 markus Exp $");
d58 2
a59 2
	buffer_put_string(&b, client_version_string, strlen(client_version_string));
	buffer_put_string(&b, server_version_string, strlen(server_version_string));
@


1.3.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.7 2001/09/17 19:27:15 stevesk Exp $");
d41 1
a41 1
static u_char *
d47 1
a47 1
    u_char *serverhostkeyblob, int sbloblen,
d58 2
a59 2
	buffer_put_cstring(&b, client_version_string);
	buffer_put_cstring(&b, server_version_string);
d91 1
a91 1
static void
d97 1
a97 1
	u_char *server_host_key_blob = NULL, *signature = NULL;
d126 3
a128 4
	if (kex->verify_host_key == NULL)
		fatal("cannot verify server_host_key");
	if (kex->verify_host_key(server_host_key) == -1)
		fatal("server_host_key verification failed");
d176 1
a176 1
	if (key_verify(server_host_key, signature, slen, hash, 20) != 1)
d195 1
a195 1
static void
d259 1
a259 1
	    server_host_key_blob, sbloblen,
d282 1
a282 1
	packet_put_string(server_host_key_blob, sbloblen);
d284 1
a284 1
	packet_put_string(signature, slen);
@


1.3.2.2
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.17 2002/02/28 15:46:33 markus Exp $");
d54 1
a54 1
	const EVP_MD *evp_md = EVP_sha1();
d84 1
a84 1
	dump_digest("hash", digest, EVP_MD_size(evp_md));
d100 1
d118 1
a118 1
	packet_read_expect(SSH2_MSG_KEXDH_REPLY);
d125 1
a125 2
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
d132 2
a133 1
	if ((dh_server_pub = BN_new()) == NULL)
d135 1
a135 1
	packet_get_bignum2(dh_server_pub);
d146 1
a146 1
	packet_check_eom();
d157 1
a157 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_client: BN_new failed");
d174 1
a174 1
	BN_clear_free(dh_server_pub);
d204 1
a204 1
	u_int slen;
d211 1
a211 1
	packet_read_expect(SSH2_MSG_KEXDH_INIT);
d220 2
a221 1
	if ((dh_client_pub = BN_new()) == NULL)
d223 1
a223 2
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();
d247 1
a247 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_server: BN_new failed");
d265 1
a265 1
	BN_clear_free(dh_client_pub);
@


1.3.2.3
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.18 2002/03/18 17:50:31 provos Exp $");
a39 1
#include "monitor_wrap.h"
d278 1
a278 1
	PRIVSEP(key_sign(server_host_key, &signature, &slen, hash, 20));
@


1.3.4.1
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.3 2001/04/04 09:48:34 markus Exp $");
@


1.3.4.2
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.7 2001/09/17 19:27:15 stevesk Exp $");
d41 1
a41 1
static u_char *
d47 1
a47 1
    u_char *serverhostkeyblob, int sbloblen,
d58 2
a59 2
	buffer_put_cstring(&b, client_version_string);
	buffer_put_cstring(&b, server_version_string);
d91 1
a91 1
static void
d97 1
a97 1
	u_char *server_host_key_blob = NULL, *signature = NULL;
d126 3
a128 4
	if (kex->verify_host_key == NULL)
		fatal("cannot verify server_host_key");
	if (kex->verify_host_key(server_host_key) == -1)
		fatal("server_host_key verification failed");
d176 1
a176 1
	if (key_verify(server_host_key, signature, slen, hash, 20) != 1)
d195 1
a195 1
static void
d259 1
a259 1
	    server_host_key_blob, sbloblen,
d282 1
a282 1
	packet_put_string(server_host_key_blob, sbloblen);
d284 1
a284 1
	packet_put_string(signature, slen);
@


1.3.4.3
log
@Merge OpenSSH 3.1.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.17 2002/02/28 15:46:33 markus Exp $");
d54 1
a54 1
	const EVP_MD *evp_md = EVP_sha1();
d84 1
a84 1
	dump_digest("hash", digest, EVP_MD_size(evp_md));
d100 1
d118 1
a118 1
	packet_read_expect(SSH2_MSG_KEXDH_REPLY);
d125 1
a125 2
	if (server_host_key->type != kex->hostkey_type)
		fatal("type mismatch for decoded server_host_key_blob");
d132 2
a133 1
	if ((dh_server_pub = BN_new()) == NULL)
d135 1
a135 1
	packet_get_bignum2(dh_server_pub);
d146 1
a146 1
	packet_check_eom();
d157 1
a157 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_client: BN_new failed");
d174 1
a174 1
	BN_clear_free(dh_server_pub);
d204 1
a204 1
	u_int slen;
d211 1
a211 1
	packet_read_expect(SSH2_MSG_KEXDH_INIT);
d220 2
a221 1
	if ((dh_client_pub = BN_new()) == NULL)
d223 1
a223 2
	packet_get_bignum2(dh_client_pub);
	packet_check_eom();
d247 1
a247 2
	if ((shared_secret = BN_new()) == NULL)
		fatal("kexdh_server: BN_new failed");
d265 1
a265 1
	BN_clear_free(dh_client_pub);
@


1.2
log
@undo parts of recent my changes: main part of keyexchange does not
need dispatch-callbacks, since application data is delayed until
the keyexchange completes (if i understand the drafts correctly).

add some infrastructure for re-keying.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kexdh.c,v 1.1 2001/04/03 19:53:29 markus Exp $");
d173 1
a174 1
	BN_free(dh_server_pub);
d190 1
a190 1
	kex_send_newkeys();
d286 1
d289 2
d294 1
a294 4
	kex_send_newkeys();

	/* have keys, free DH */
	DH_free(dh);
@


1.1
log
@move kex to kex*.c, used dispatch_set() callbacks for kex. should
make rekeying easier.
@
text
@d26 1
a26 1
RCSID("$OpenBSD: kex.c,v 1.24 2001/03/28 21:59:40 provos Exp $");
a36 1
#include "dispatch.h"
a40 11
extern u_char *session_id2;
extern int session_id2_len;

dispatch_fn kexdh_input_init;		/* C -> S */
dispatch_fn kexdh_input_reply;		/* S -> C */

typedef struct State State;
struct State {
	DH *dh;
};

d94 7
a100 6
	State *state;

	dispatch_set(SSH2_MSG_KEXDH_REPLY, &kexdh_input_reply);

	state = xmalloc(sizeof(State));
	kex->state = state;
d103 2
a104 2
	state->dh = dh_new_group1();
	dh_gen_key(state->dh, kex->we_need * 8);
d106 1
a106 1
	packet_put_bignum2(state->dh->pub_key);
d109 1
a109 1
	debug("SSH2_MSG_KEXDH_INIT sent");
d111 1
a111 1
	DHparams_print_fp(stderr, state->dh);
d113 1
a113 1
	BN_print_fp(stderr, state->dh->pub_key);
a115 13
}

void   
kexdh_input_reply(int type, int plen, void *ctxt)
{
	BIGNUM *dh_server_pub = NULL, *shared_secret = NULL;
	Key *server_host_key;
	char *server_host_key_blob = NULL, *signature = NULL;
	u_char *kbuf, *hash;
	u_int klen, kout, slen, sbloblen;
	int dlen;
	Kex *kex = (Kex *)ctxt;
	State *state = (State *)kex->state;
d117 2
a118 2
	debug("SSH2_MSG_KEXDH_REPLY received");
	dispatch_set(SSH2_MSG_KEXDH_REPLY, &kex_protocol_error);
d147 1
a147 1
	if (!dh_pub_is_valid(state->dh, dh_server_pub))
d150 1
a150 1
	klen = DH_size(state->dh);
d152 1
a152 1
	kout = DH_compute_key(kbuf, dh_server_pub, state->dh);
d168 1
a168 1
	    state->dh->pub_key,
d173 1
a173 1
	DH_free(state->dh);
d181 7
a189 1
	packet_set_kex(kex);
a190 8

	/* save session id */
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);

	xfree(state);
	kex->state = NULL;
a197 15
	State *state;

	dispatch_set(SSH2_MSG_KEXDH_INIT, &kexdh_input_init);

	state = xmalloc(sizeof(*state));
	kex->state = state;

	/* generate server DH public key */
	state->dh = dh_new_group1();
	dh_gen_key(state->dh, kex->we_need * 8);
}

void   
kexdh_input_init(int type, int plen, void *ctxt)
{
d199 1
d203 5
a207 4
	int dlen, slen;
	Kex *kex = (Kex*) ctxt;
	State *state = (State*) kex->state;
	DH *dh = state->dh;
d209 2
a210 2
	debug("SSH2_MSG_KEXDH_INIT received");
	dispatch_set(SSH2_MSG_KEXDH_INIT, &kex_protocol_error);
d268 5
a272 3
	session_id2_len = 20;
	session_id2 = xmalloc(session_id2_len);
	memcpy(session_id2, hash, session_id2_len);
a290 1
	packet_set_kex(kex);
a294 2
	xfree(state);
	kex->state = NULL;
@

