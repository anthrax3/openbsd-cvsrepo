head	1.304;
access;
symbols
	OPENBSD_6_1:1.299.0.4
	OPENBSD_6_1_BASE:1.299
	OPENBSD_6_0:1.290.0.4
	OPENBSD_6_0_BASE:1.290
	OPENBSD_5_9:1.288.0.2
	OPENBSD_5_9_BASE:1.288
	OPENBSD_5_8:1.276.0.2
	OPENBSD_5_8_BASE:1.276
	OPENBSD_5_7:1.266.0.2
	OPENBSD_5_7_BASE:1.266
	OPENBSD_5_6:1.249.0.4
	OPENBSD_5_6_BASE:1.249
	OPENBSD_5_5:1.241.0.4
	OPENBSD_5_5_BASE:1.241
	OPENBSD_5_4:1.230.0.2
	OPENBSD_5_4_BASE:1.230
	OPENBSD_5_3:1.225.0.2
	OPENBSD_5_3_BASE:1.225
	OPENBSD_5_2:1.216.0.2
	OPENBSD_5_2_BASE:1.216
	OPENBSD_5_1_BASE:1.212
	OPENBSD_5_1:1.212.0.2
	OPENBSD_5_0:1.210.0.2
	OPENBSD_5_0_BASE:1.210
	OPENBSD_4_9:1.205.0.2
	OPENBSD_4_9_BASE:1.205
	OPENBSD_4_8:1.197.0.2
	OPENBSD_4_8_BASE:1.197
	OPENBSD_4_7:1.185.0.2
	OPENBSD_4_7_BASE:1.185
	OPENBSD_4_6:1.174.0.4
	OPENBSD_4_6_BASE:1.174
	OPENBSD_4_5:1.173.0.2
	OPENBSD_4_5_BASE:1.173
	OPENBSD_4_4:1.171.0.2
	OPENBSD_4_4_BASE:1.171
	OPENBSD_4_3:1.165.0.2
	OPENBSD_4_3_BASE:1.165
	OPENBSD_4_2:1.160.0.4
	OPENBSD_4_2_BASE:1.160
	OPENBSD_4_1:1.160.0.2
	OPENBSD_4_1_BASE:1.160
	OPENBSD_4_0:1.154.0.4
	OPENBSD_4_0_BASE:1.154
	OPENBSD_3_9:1.136.0.2
	OPENBSD_3_9_BASE:1.136
	OPENBSD_3_8:1.128.0.2
	OPENBSD_3_8_BASE:1.128
	OPENBSD_3_7:1.122.0.2
	OPENBSD_3_7_BASE:1.122
	OPENBSD_3_6:1.117.0.2
	OPENBSD_3_6_BASE:1.117
	OPENBSD_3_5:1.113.0.2
	OPENBSD_3_5_BASE:1.113
	OPENBSD_3_4:1.108.0.2
	OPENBSD_3_4_BASE:1.108
	OPENBSD_3_3:1.102.0.2
	OPENBSD_3_3_BASE:1.102
	OPENBSD_3_2:1.101.0.2
	OPENBSD_3_2_BASE:1.101
	OPENBSD_3_1:1.98.0.2
	OPENBSD_3_1_BASE:1.98
	OPENBSD_3_0:1.82.0.2
	OPENBSD_3_0_BASE:1.82
	OPENBSD_2_9_BASE:1.60
	OPENBSD_2_9:1.60.0.2
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.304
date	2017.05.30.14.16.41;	author markus;	state Exp;
branches;
next	1.303;
commitid	qvTM0EqWXxMps7F0;

1.303
date	2017.05.07.23.15.59;	author djm;	state Exp;
branches;
next	1.302;
commitid	uIPOxK9LAWTB4bJn;

1.302
date	2017.04.30.23.18.44;	author djm;	state Exp;
branches;
next	1.301;
commitid	NPnVhZTcf5ddO7Ys;

1.301
date	2017.04.30.23.10.43;	author djm;	state Exp;
branches;
next	1.300;
commitid	I15vriCkYNtbTkea;

1.300
date	2017.04.29.04.12.25;	author djm;	state Exp;
branches;
next	1.299;
commitid	WG9mzIT0boRtKmGp;

1.299
date	2017.03.10.04.26.06;	author djm;	state Exp;
branches;
next	1.298;
commitid	OsKbkEZNWapKjTtj;

1.298
date	2017.03.06.02.03.20;	author dtucker;	state Exp;
branches;
next	1.297;
commitid	Qr8KgeTVoJJF9lm0;

1.297
date	2017.03.06.00.44.51;	author dtucker;	state Exp;
branches;
next	1.296;
commitid	qN1ZonIRGWaUpi9A;

1.296
date	2017.03.03.06.13.11;	author djm;	state Exp;
branches;
next	1.295;
commitid	5rUMDkI0ZbpKuxKy;

1.295
date	2017.02.17.02.32.05;	author dtucker;	state Exp;
branches;
next	1.294;
commitid	D17ymYC2h1oK9gL8;

1.294
date	2017.02.10.03.36.40;	author djm;	state Exp;
branches;
next	1.293;
commitid	ZFBCT6NFd0LrpBFy;

1.293
date	2017.02.08.20.32.43;	author millert;	state Exp;
branches;
next	1.292;
commitid	C0wnyUg1OME5U42n;

1.292
date	2016.09.12.03.29.16;	author dtucker;	state Exp;
branches;
next	1.291;
commitid	qZxDxhXfJCykUUFY;

1.291
date	2016.09.12.03.25.20;	author dtucker;	state Exp;
branches;
next	1.290;
commitid	T8kZWiFq2eA4BaAl;

1.290
date	2016.05.02.09.36.42;	author djm;	state Exp;
branches;
next	1.289;
commitid	g1pzvVA0Azqu3umf;

1.289
date	2016.05.02.08.49.03;	author djm;	state Exp;
branches;
next	1.288;
commitid	RYYIr1bk0phq4fXa;

1.288
date	2016.02.15.09.47.49;	author dtucker;	state Exp;
branches;
next	1.287;
commitid	ut5A0buLh4mhCTFu;

1.287
date	2015.12.11.03.19.09;	author djm;	state Exp;
branches;
next	1.286;
commitid	2E8Vrkc7F6a99V57;

1.286
date	2015.12.11.02.31.47;	author mmcc;	state Exp;
branches;
next	1.285;
commitid	f7EpsYIFQYQNXTtF;

1.285
date	2015.12.04.16.41.28;	author markus;	state Exp;
branches;
next	1.284;
commitid	K3glY441IowbrjDE;

1.284
date	2015.11.28.06.50.52;	author deraadt;	state Exp;
branches;
next	1.283;
commitid	Cw9bn1BBmUj9Wfu4;

1.283
date	2015.11.20.23.04.01;	author halex;	state Exp;
branches;
next	1.282;
commitid	hA5PtN32koh8qWoq;

1.282
date	2015.11.19.01.12.32;	author djm;	state Exp;
branches;
next	1.281;
commitid	bHugWpYAlslhCOkX;

1.281
date	2015.11.19.01.08.55;	author djm;	state Exp;
branches;
next	1.280;
commitid	HrzGeuKItIoUaPu0;

1.280
date	2015.11.18.08.37.28;	author djm;	state Exp;
branches;
next	1.279;
commitid	6uXYaO3VnKoaOxkQ;

1.279
date	2015.11.16.22.53.07;	author djm;	state Exp;
branches;
next	1.278;
commitid	abfCncm5wNrrBUqM;

1.278
date	2015.11.13.04.34.15;	author djm;	state Exp;
branches;
next	1.277;
commitid	epcZt98isMTyr8z5;

1.277
date	2015.08.19.23.17.51;	author djm;	state Exp;
branches;
next	1.276;
commitid	moL29CRmtonAsmaV;

1.276
date	2015.07.03.03.49.45;	author djm;	state Exp;
branches;
next	1.275;
commitid	XxrOOTFUKuLzoQb7;

1.275
date	2015.07.03.03.43.18;	author djm;	state Exp;
branches;
next	1.274;
commitid	cnvu1kGgoFFYv6D3;

1.274
date	2015.05.28.07.37.31;	author djm;	state Exp;
branches;
next	1.273;
commitid	1gHUMUd1A44hqA4g;

1.273
date	2015.05.28.04.40.13;	author djm;	state Exp;
branches;
next	1.272;
commitid	qha23tzfLKtRyxyw;

1.272
date	2015.05.21.12.01.19;	author djm;	state Exp;
branches;
next	1.271;
commitid	SrOLz2LkCSkaqOO8;

1.271
date	2015.04.27.01.52.30;	author djm;	state Exp;
branches;
next	1.270;
commitid	YUkhAUcfWvVRd3vD;

1.270
date	2015.04.24.01.36.01;	author deraadt;	state Exp;
branches;
next	1.269;
commitid	LHkUmZjv49ojnnuH;

1.269
date	2015.04.17.13.19.22;	author djm;	state Exp;
branches;
next	1.268;
commitid	dcpRjslykkbOEELc;

1.268
date	2015.03.31.11.06.49;	author tobias;	state Exp;
branches;
next	1.267;
commitid	BhWeudltOSy7bdvQ;

1.267
date	2015.03.23.06.06.38;	author djm;	state Exp;
branches;
next	1.266;
commitid	NHqLvLsLa7Ylg5sk;

1.266
date	2015.02.26.20.45.47;	author djm;	state Exp;
branches;
next	1.265;
commitid	1AeQQ6SQheZTTPNv;

1.265
date	2015.02.24.15.24.05;	author naddy;	state Exp;
branches;
next	1.264;
commitid	p5RoOkcHXvtcyxH5;

1.264
date	2015.02.23.22.21.21;	author djm;	state Exp;
branches;
next	1.263;
commitid	lxwlOdh3DW8rYwk9;

1.263
date	2015.02.23.16.55.31;	author djm;	state Exp;
branches;
next	1.262;
commitid	XbpV9JwdqeYZhdUz;

1.262
date	2015.02.16.22.08.57;	author djm;	state Exp;
branches;
next	1.261;
commitid	iBG3mh48h4UsmNe0;

1.261
date	2015.01.30.01.10.33;	author djm;	state Exp;
branches;
next	1.260;
commitid	TRmit1x08XMcp7vb;

1.260
date	2015.01.30.00.59.19;	author djm;	state Exp;
branches;
next	1.259;
commitid	TxLy8D9y8Tm8WUw8;

1.259
date	2015.01.28.22.36.00;	author djm;	state Exp;
branches;
next	1.258;
commitid	P7KG9D8zB61mMUPV;

1.258
date	2015.01.19.00.32.54;	author deraadt;	state Exp;
branches;
next	1.257;
commitid	r8wKKx9jDWiK7eSN;

1.257
date	2015.01.18.21.51.19;	author djm;	state Exp;
branches;
next	1.256;
commitid	fE0QhFbJjYu6Ckwl;

1.256
date	2015.01.18.21.49.42;	author djm;	state Exp;
branches;
next	1.255;
commitid	C73hXUFgF0kZ7vOm;

1.255
date	2015.01.18.13.22.28;	author djm;	state Exp;
branches;
next	1.254;
commitid	c6Y1fG6pxQ8ZZCgp;

1.254
date	2015.01.16.15.55.07;	author djm;	state Exp;
branches;
next	1.253;
commitid	dflXUFcNhFOUIlKN;

1.253
date	2015.01.16.06.40.12;	author deraadt;	state Exp;
branches;
next	1.252;
commitid	Uu5nFG3wCl0LACBb;

1.252
date	2015.01.15.09.40.00;	author djm;	state Exp;
branches;
next	1.251;
commitid	akRUKeZEbb3ylbKG;

1.251
date	2014.12.21.22.27.56;	author djm;	state Exp;
branches;
next	1.250;
commitid	EbtriidyZdsmXksl;

1.250
date	2014.08.21.01.08.52;	author doug;	state Exp;
branches;
next	1.249;
commitid	ti47Ets7tAnpzZsc;

1.249
date	2014.07.03.03.47.27;	author djm;	state Exp;
branches;
next	1.248;
commitid	cTMTBdCXqAaczInM;

1.248
date	2014.07.03.03.34.09;	author djm;	state Exp;
branches;
next	1.247;
commitid	O9Tt7hhD3nOW2fIY;

1.247
date	2014.06.24.01.13.21;	author djm;	state Exp;
branches;
next	1.246;
commitid	1h9UxAQmwdaqUzyX;

1.246
date	2014.04.29.18.01.49;	author markus;	state Exp;
branches;
next	1.245;

1.245
date	2014.04.28.03.09.18;	author djm;	state Exp;
branches;
next	1.244;

1.244
date	2014.04.20.09.24.26;	author logan;	state Exp;
branches;
next	1.243;

1.243
date	2014.03.15.17.28.26;	author deraadt;	state Exp;
branches;
next	1.242;

1.242
date	2014.03.12.04.50.32;	author djm;	state Exp;
branches;
next	1.241;

1.241
date	2014.02.05.20.13.25;	author naddy;	state Exp;
branches;
next	1.240;

1.240
date	2014.02.02.03.44.31;	author djm;	state Exp;
branches;
next	1.239;

1.239
date	2014.01.31.16.39.19;	author tedu;	state Exp;
branches;
next	1.238;

1.238
date	2013.12.06.13.39.49;	author markus;	state Exp;
branches;
next	1.237;

1.237
date	2013.12.06.13.34.54;	author markus;	state Exp;
branches;
next	1.236;

1.236
date	2013.12.06.03.40.51;	author djm;	state Exp;
branches;
next	1.235;

1.235
date	2013.10.23.04.16.22;	author djm;	state Exp;
branches;
next	1.234;

1.234
date	2013.09.02.22.00.34;	author deraadt;	state Exp;
branches;
next	1.233;

1.233
date	2013.08.28.12.34.27;	author mikeb;	state Exp;
branches;
next	1.232;

1.232
date	2013.08.13.18.33.08;	author djm;	state Exp;
branches;
next	1.231;

1.231
date	2013.08.13.18.32.08;	author djm;	state Exp;
branches;
next	1.230;

1.230
date	2013.07.20.01.44.37;	author djm;	state Exp;
branches;
next	1.229;

1.229
date	2013.07.12.05.42.03;	author djm;	state Exp;
branches;
next	1.228;

1.228
date	2013.07.12.00.20.00;	author djm;	state Exp;
branches;
next	1.227;

1.227
date	2013.05.17.00.13.14;	author djm;	state Exp;
branches;
next	1.226;

1.226
date	2013.04.19.01.01.00;	author djm;	state Exp;
branches;
next	1.225;

1.225
date	2013.02.10.23.32.10;	author djm;	state Exp;
branches;
next	1.224;

1.224
date	2013.01.18.07.59.46;	author jmc;	state Exp;
branches;
next	1.223;

1.223
date	2013.01.17.23.00.01;	author djm;	state Exp;
branches;
next	1.222;

1.222
date	2013.01.09.05.40.17;	author djm;	state Exp;
branches;
next	1.221;

1.221
date	2013.01.03.23.22.58;	author djm;	state Exp;
branches;
next	1.220;

1.220
date	2012.12.03.00.14.06;	author djm;	state Exp;
branches;
next	1.219;

1.219
date	2012.11.14.02.32.15;	author djm;	state Exp;
branches;
next	1.218;

1.218
date	2012.10.02.07.07.45;	author djm;	state Exp;
branches;
next	1.217;

1.217
date	2012.08.17.01.25.58;	author djm;	state Exp;
branches;
next	1.216;

1.216
date	2012.07.06.06.38.03;	author jmc;	state Exp;
branches;
next	1.215;

1.215
date	2012.07.06.00.41.59;	author dtucker;	state Exp;
branches;
next	1.214;

1.214
date	2012.05.23.03.28.28;	author djm;	state Exp;
branches;
next	1.213;

1.213
date	2012.02.29.11.21.26;	author djm;	state Exp;
branches;
next	1.212;

1.212
date	2011.10.16.15.02.41;	author jmc;	state Exp;
branches;
next	1.211;

1.211
date	2011.10.16.11.02.46;	author dtucker;	state Exp;
branches;
next	1.210;

1.210
date	2011.04.18.00.46.05;	author djm;	state Exp;
branches;
next	1.209;

1.209
date	2011.04.12.04.23.50;	author djm;	state Exp;
branches;
next	1.208;

1.208
date	2011.03.24.22.14.54;	author stevesk;	state Exp;
branches;
next	1.207;

1.207
date	2011.03.23.16.50.04;	author stevesk;	state Exp;
branches;
next	1.206;

1.206
date	2011.03.23.15.16.22;	author stevesk;	state Exp;
branches;
next	1.205;

1.205
date	2011.01.11.06.13.10;	author djm;	state Exp;
branches;
next	1.204;

1.204
date	2010.10.28.11.22.09;	author djm;	state Exp;
branches;
next	1.203;

1.203
date	2010.09.02.17.21.50;	author naddy;	state Exp;
branches;
next	1.202;

1.202
date	2010.09.02.16.07.25;	author markus;	state Exp;
branches;
next	1.201;

1.201
date	2010.08.31.12.33.38;	author djm;	state Exp;
branches;
next	1.200;

1.200
date	2010.08.31.11.54.45;	author djm;	state Exp;
branches;
next	1.199;

1.199
date	2010.08.16.04.06.06;	author djm;	state Exp;
branches;
next	1.198;

1.198
date	2010.08.12.23.34.38;	author tedu;	state Exp;
branches;
next	1.197;

1.197
date	2010.08.04.06.07.11;	author djm;	state Exp;
branches;
next	1.196;

1.196
date	2010.08.04.05.40.39;	author djm;	state Exp;
branches;
next	1.195;

1.195
date	2010.07.16.04.45.30;	author djm;	state Exp;
branches;
next	1.194;

1.194
date	2010.06.30.07.26.03;	author jmc;	state Exp;
branches;
next	1.193;

1.193
date	2010.06.29.23.15.30;	author djm;	state Exp;
branches;
next	1.192;

1.192
date	2010.06.23.02.59.02;	author djm;	state Exp;
branches;
next	1.191;

1.191
date	2010.06.22.04.32.06;	author djm;	state Exp;
branches;
next	1.190;

1.190
date	2010.05.20.23.46.02;	author djm;	state Exp;
branches;
next	1.189;

1.189
date	2010.04.23.22.48.31;	author djm;	state Exp;
branches;
next	1.188;

1.188
date	2010.04.23.01.47.41;	author djm;	state Exp;
branches;
next	1.187;

1.187
date	2010.04.16.06.47.04;	author jmc;	state Exp;
branches;
next	1.186;

1.186
date	2010.04.16.01.47.26;	author djm;	state Exp;
branches;
next	1.185;

1.185
date	2010.03.15.19.40.02;	author stevesk;	state Exp;
branches;
next	1.184;

1.184
date	2010.03.07.22.16.01;	author djm;	state Exp;
branches;
next	1.183;

1.183
date	2010.03.04.23.27.25;	author djm;	state Exp;
branches;
next	1.182;

1.182
date	2010.03.04.20.35.08;	author djm;	state Exp;
branches;
next	1.181;

1.181
date	2010.03.04.10.36.03;	author djm;	state Exp;
branches;
next	1.180;

1.180
date	2010.03.02.23.20.57;	author djm;	state Exp;
branches;
next	1.179;

1.179
date	2010.02.26.20.29.54;	author djm;	state Exp;
branches;
next	1.178;

1.178
date	2010.02.09.00.50.59;	author djm;	state Exp;
branches;
next	1.177;

1.177
date	2010.02.08.10.50.20;	author markus;	state Exp;
branches;
next	1.176;

1.176
date	2010.01.11.10.51.07;	author djm;	state Exp;
branches;
next	1.175;

1.175
date	2009.08.27.17.33.49;	author djm;	state Exp;
branches;
next	1.174;

1.174
date	2009.06.22.05.39.28;	author dtucker;	state Exp;
branches;
next	1.173;

1.173
date	2009.02.21.19.32.04;	author tobias;	state Exp;
branches;
next	1.172;

1.172
date	2008.11.07.00.42.12;	author stevesk;	state Exp;
branches;
next	1.171;

1.171
date	2008.07.13.21.22.52;	author sthen;	state Exp;
branches;
next	1.170;

1.170
date	2008.06.12.21.14.46;	author grunk;	state Exp;
branches;
next	1.169;

1.169
date	2008.06.11.22.20.46;	author grunk;	state Exp;
branches;
next	1.168;

1.168
date	2008.06.11.21.38.25;	author grunk;	state Exp;
branches;
next	1.167;

1.167
date	2008.06.11.21.01.35;	author grunk;	state Exp;
branches;
next	1.166;

1.166
date	2008.05.19.15.46.31;	author djm;	state Exp;
branches;
next	1.165;

1.165
date	2008.01.19.22.37.19;	author djm;	state Exp;
branches;
next	1.164;

1.164
date	2008.01.19.22.22.58;	author djm;	state Exp;
branches;
next	1.163;

1.163
date	2007.10.02.17.49.58;	author chl;	state Exp;
branches;
next	1.162;

1.162
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.161;

1.161
date	2007.09.09.11.38.01;	author sobrado;	state Exp;
branches;
next	1.160;

1.160
date	2007.01.21.01.41.54;	author stevesk;	state Exp;
branches;
next	1.159;

1.159
date	2007.01.12.20.20.41;	author jmc;	state Exp;
branches;
next	1.158;

1.158
date	2007.01.03.03.01.40;	author stevesk;	state Exp;
branches;
next	1.157;

1.157
date	2007.01.03.00.53.38;	author stevesk;	state Exp;
branches;
next	1.156;

1.156
date	2006.11.14.19.41.04;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2006.11.06.21.25.28;	author markus;	state Exp;
branches;
next	1.154;

1.154
date	2006.08.03.03.34.42;	author deraadt;	state Exp;
branches
	1.154.4.1;
next	1.153;

1.153
date	2006.08.01.23.22.47;	author stevesk;	state Exp;
branches;
next	1.152;

1.152
date	2006.07.26.13.57.17;	author stevesk;	state Exp;
branches;
next	1.151;

1.151
date	2006.07.26.02.35.17;	author stevesk;	state Exp;
branches;
next	1.150;

1.150
date	2006.07.22.20.48.23;	author stevesk;	state Exp;
branches;
next	1.149;

1.149
date	2006.07.17.01.31.10;	author stevesk;	state Exp;
branches;
next	1.148;

1.148
date	2006.07.11.20.07.25;	author stevesk;	state Exp;
branches;
next	1.147;

1.147
date	2006.07.09.15.15.11;	author stevesk;	state Exp;
branches;
next	1.146;

1.146
date	2006.07.06.16.22.39;	author stevesk;	state Exp;
branches;
next	1.145;

1.145
date	2006.07.06.16.03.53;	author stevesk;	state Exp;
branches;
next	1.144;

1.144
date	2006.05.17.12.43.34;	author markus;	state Exp;
branches;
next	1.143;

1.143
date	2006.03.30.11.05.17;	author dtucker;	state Exp;
branches;
next	1.142;

1.142
date	2006.03.25.18.40.14;	author deraadt;	state Exp;
branches;
next	1.141;

1.141
date	2006.03.25.13.17.02;	author djm;	state Exp;
branches;
next	1.140;

1.140
date	2006.03.20.18.26.55;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.19.18.51.18;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2006.03.15.08.46.44;	author jakob;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.13.08.43.16;	author dtucker;	state Exp;
branches;
next	1.136;

1.136
date	2006.02.20.17.19.54;	author stevesk;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2005.11.29.02.04.55;	author dtucker;	state Exp;
branches;
next	1.134;

1.134
date	2005.11.28.05.16.53;	author dtucker;	state Exp;
branches;
next	1.133;

1.133
date	2005.10.31.11.12.49;	author djm;	state Exp;
branches;
next	1.132;

1.132
date	2005.10.30.08.52.18;	author djm;	state Exp;
branches;
next	1.131;

1.131
date	2005.10.14.02.17.59;	author stevesk;	state Exp;
branches;
next	1.130;

1.130
date	2005.10.07.11.13.57;	author markus;	state Exp;
branches;
next	1.129;

1.129
date	2005.09.13.23.40.07;	author djm;	state Exp;
branches;
next	1.128;

1.128
date	2005.07.17.07.17.55;	author djm;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2005.06.08.03.50.00;	author djm;	state Exp;
branches;
next	1.126;

1.126
date	2005.05.26.09.08.12;	author dtucker;	state Exp;
branches;
next	1.125;

1.125
date	2005.05.24.02.05.09;	author avsm;	state Exp;
branches;
next	1.124;

1.124
date	2005.05.23.22.44.01;	author avsm;	state Exp;
branches;
next	1.123;

1.123
date	2005.04.05.13.45.31;	author otto;	state Exp;
branches;
next	1.122;

1.122
date	2005.03.11.14.59.06;	author markus;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2005.03.10.22.01.06;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2005.03.02.01.27.41;	author djm;	state Exp;
branches;
next	1.119;

1.119
date	2005.03.01.10.42.49;	author djm;	state Exp;
branches;
next	1.118;

1.118
date	2004.12.23.17.38.07;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2004.07.11.17.48.47;	author deraadt;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2004.06.21.17.36.31;	author avsm;	state Exp;
branches;
next	1.115;

1.115
date	2004.05.09.00.06.47;	author djm;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.08.00.21.31;	author djm;	state Exp;
branches;
next	1.113;

1.113
date	2003.12.22.09.16.58;	author djm;	state Exp;
branches
	1.113.2.1;
next	1.112;

1.112
date	2003.11.23.23.18.45;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2003.11.21.11.57.03;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2003.10.14.19.42.10;	author jakob;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.18.13.02.21;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2003.08.14.16.08.58;	author markus;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2003.07.28.09.49.56;	author djm;	state Exp;
branches;
next	1.106;

1.106
date	2003.05.15.03.10.52;	author djm;	state Exp;
branches;
next	1.105;

1.105
date	2003.05.14.18.16.20;	author jakob;	state Exp;
branches;
next	1.104;

1.104
date	2003.05.11.16.56.48;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.08.20.21.29;	author itojun;	state Exp;
branches;
next	1.102;

1.102
date	2002.11.26.00.45.03;	author wcobb;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2002.06.23.09.39.55;	author deraadt;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2002.06.19.00.27.55;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2002.06.09.13.32.01;	author markus;	state Exp;
branches;
next	1.98;

1.98
date	2002.03.27.22.21.45;	author markus;	state Exp;
branches
	1.98.2.1;
next	1.97;

1.97
date	2002.03.25.17.34.27;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2002.03.21.21.54.34;	author rees;	state Exp;
branches;
next	1.95;

1.95
date	2002.03.21.16.54.53;	author markus;	state Exp;
branches;
next	1.94;

1.94
date	2002.02.25.16.33.27;	author markus;	state Exp;
branches;
next	1.93;

1.93
date	2002.02.24.19.14.59;	author markus;	state Exp;
branches;
next	1.92;

1.92
date	2002.02.16.20.40.08;	author stevesk;	state Exp;
branches;
next	1.91;

1.91
date	2002.01.18.18.14.17;	author stevesk;	state Exp;
branches;
next	1.90;

1.90
date	2002.01.09.13.49.27;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2001.12.29.21.56.01;	author stevesk;	state Exp;
branches;
next	1.88;

1.88
date	2001.12.27.18.10.29;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2001.12.21.08.52.22;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2001.12.19.07.18.56;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2001.12.05.10.06.12;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2001.11.17.19.14.34;	author stevesk;	state Exp;
branches;
next	1.83;

1.83
date	2001.10.25.21.14.32;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2001.09.28.12.07.09;	author djm;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2001.09.17.20.50.22;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2001.09.17.19.27.15;	author stevesk;	state Exp;
branches;
next	1.79;

1.79
date	2001.08.02.16.14.05;	author jakob;	state Exp;
branches;
next	1.78;

1.78
date	2001.08.02.15.43.57;	author jakob;	state Exp;
branches;
next	1.77;

1.77
date	2001.08.02.15.06.52;	author jakob;	state Exp;
branches;
next	1.76;

1.76
date	2001.08.02.08.58.35;	author jakob;	state Exp;
branches;
next	1.75;

1.75
date	2001.08.02.00.10.17;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2001.08.01.23.33.09;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2001.07.26.20.04.27;	author rees;	state Exp;
branches;
next	1.72;

1.72
date	2001.07.02.22.40.18;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.29.07.11.01;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.29.07.06.34;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.28.19.57.35;	author stevesk;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.27.05.42.25;	author markus;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.27.05.35.42;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.26.02.47.07;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.24.05.35.33;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.23.17.05.22;	author markus;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.23.15.12.20;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2001.06.23.06.41.10;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.25.14.37.32;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2001.04.23.22.14.13;	author markus;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2001.04.23.21.57.07;	author markus;	state Exp;
branches;
next	1.58;

1.58
date	2001.04.22.13.41.02;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2001.04.22.13.25.37;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.15.16.58.03;	author markus;	state Exp;
branches;
next	1.55;

1.55
date	2001.04.05.10.42.54;	author markus;	state Exp;
branches;
next	1.54;

1.54
date	2001.04.03.13.56.11;	author stevesk;	state Exp;
branches;
next	1.53;

1.53
date	2001.03.26.23.23.24;	author markus;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.26.08.07.09;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.21.14.20.45;	author jakob;	state Exp;
branches;
next	1.50;

1.50
date	2001.03.12.22.02.02;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2001.03.11.22.33.24;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2001.03.11.16.39.03;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.11.15.04.16;	author jakob;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.09.03.14.39;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.22.08.03.51;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.22.06.43.55;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.12.16.16.23;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.04.15.32.26;	author stevesk;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.21.19.05.57;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.19.15.55.11;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.13.18.03.07;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2000.12.28.18.58.39;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.22.16.49.40;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2000.12.19.23.17.58;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.25.17.19.33;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.15.20.24.43;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.12.19.50.38;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.09.21.30.44;	author markus;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.09.07.20.27.54;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.19.21.34.43;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.15.04.01.37;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.07.03.55.04;	author todd;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.20.01.39.44;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.30.17.32.06;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.08.18.23.07;	author markus;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2000.05.03.02.52.56;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.02.22.18.04;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.01.08.20.56;	author hugh;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.27.08.01.27;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.26.21.55.04;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.26.20.56.29;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.14.10.30.33;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.16.20.56.14;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.04.14.34.09;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.04.13.16.16;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	99.11.24.19.53.52;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	99.11.24.00.26.03;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.11.23.22.25.55;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	99.11.21.21.58.31;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.11.20.19.53.40;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	99.11.20.10.02.53;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	99.11.16.22.49.28;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	99.11.16.22.27.54;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	99.10.01.02.38.09;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.21.14.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.06.15.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.09.28.19.42.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.04.45.37;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.09.26.20.53.37;	author deraadt;	state Exp;
branches;
next	;

1.25.2.1
date	2000.06.12.02.37.35;	author jason;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2000.09.01.18.23.23;	author jason;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2000.11.08.21.31.22;	author jason;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2001.03.12.15.44.16;	author jason;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2001.03.21.18.53.09;	author jason;	state Exp;
branches;
next	;

1.32.2.1
date	2001.02.16.20.13.18;	author jason;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.02.19.17.19.29;	author jason;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2001.03.21.19.46.30;	author jason;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2001.05.07.21.09.36;	author jason;	state Exp;
branches;
next	1.32.2.5;

1.32.2.5
date	2001.09.27.00.15.42;	author miod;	state Exp;
branches;
next	1.32.2.6;

1.32.2.6
date	2001.11.15.00.15.00;	author miod;	state Exp;
branches;
next	1.32.2.7;

1.32.2.7
date	2001.11.15.22.50.30;	author miod;	state Exp;
branches;
next	1.32.2.8;

1.32.2.8
date	2002.03.08.17.04.43;	author brad;	state Exp;
branches;
next	;

1.60.2.1
date	2001.09.27.19.03.55;	author jason;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2001.11.15.00.15.19;	author miod;	state Exp;
branches;
next	1.60.2.3;

1.60.2.3
date	2001.11.15.22.51.15;	author miod;	state Exp;
branches;
next	1.60.2.4;

1.60.2.4
date	2002.03.09.00.20.45;	author miod;	state Exp;
branches;
next	1.60.2.5;

1.60.2.5
date	2002.06.02.22.56.11;	author miod;	state Exp;
branches;
next	;

1.82.2.1
date	2001.11.14.03.24.39;	author jason;	state Exp;
branches;
next	1.82.2.2;

1.82.2.2
date	2002.03.07.17.37.47;	author jason;	state Exp;
branches;
next	1.82.2.3;

1.82.2.3
date	2002.05.17.00.03.24;	author miod;	state Exp;
branches;
next	1.82.2.4;

1.82.2.4
date	2002.06.22.07.23.18;	author miod;	state Exp;
branches;
next	1.82.2.5;

1.82.2.5
date	2002.06.26.18.22.36;	author miod;	state Exp;
branches;
next	;

1.98.2.1
date	2002.06.26.15.30.39;	author jason;	state Exp;
branches;
next	1.98.2.2;

1.98.2.2
date	2003.04.03.22.35.18;	author miod;	state Exp;
branches;
next	;

1.101.2.1
date	2003.04.01.00.12.14;	author margarida;	state Exp;
branches;
next	1.101.2.2;

1.101.2.2
date	2003.09.16.21.20.28;	author brad;	state Exp;
branches;
next	;

1.102.2.1
date	2003.09.16.20.50.44;	author brad;	state Exp;
branches;
next	1.102.2.2;

1.102.2.2
date	2004.03.04.18.18.16;	author brad;	state Exp;
branches;
next	;

1.108.2.1
date	2004.02.28.03.51.34;	author brad;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2004.08.19.22.37.32;	author brad;	state Exp;
branches;
next	;

1.113.2.1
date	2004.08.19.04.13.27;	author brad;	state Exp;
branches;
next	1.113.2.2;

1.113.2.2
date	2005.03.10.17.15.05;	author brad;	state Exp;
branches;
next	;

1.117.2.1
date	2005.03.10.16.28.28;	author brad;	state Exp;
branches;
next	1.117.2.2;

1.117.2.2
date	2005.06.05.02.22.39;	author brad;	state Exp;
branches;
next	1.117.2.3;

1.117.2.3
date	2005.09.02.03.45.01;	author brad;	state Exp;
branches;
next	;

1.122.2.1
date	2005.09.04.18.40.10;	author brad;	state Exp;
branches;
next	1.122.2.2;

1.122.2.2
date	2006.02.03.02.53.45;	author brad;	state Exp;
branches;
next	;

1.128.2.1
date	2006.02.03.03.01.57;	author brad;	state Exp;
branches;
next	1.128.2.2;

1.128.2.2
date	2006.10.06.03.19.33;	author brad;	state Exp;
branches;
next	1.128.2.3;

1.128.2.3
date	2006.11.08.00.44.05;	author brad;	state Exp;
branches;
next	;

1.136.2.1
date	2006.09.30.04.06.51;	author brad;	state Exp;
branches;
next	1.136.2.2;

1.136.2.2
date	2006.11.08.00.17.14;	author brad;	state Exp;
branches;
next	;

1.154.4.1
date	2006.11.08.00.42.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.304
log
@remove unused wrapper functions from key.[ch]; ok djm@@
@
text
@/* $OpenBSD: ssh-keygen.c,v 1.303 2017/05/07 23:15:59 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1994 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Identity and host key generation and maintenance.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <openssl/evp.h>
#include <openssl/pem.h>

#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <locale.h>

#include "xmalloc.h"
#include "sshkey.h"
#include "rsa.h"
#include "authfile.h"
#include "uuencode.h"
#include "sshbuf.h"
#include "pathnames.h"
#include "log.h"
#include "misc.h"
#include "match.h"
#include "hostfile.h"
#include "dns.h"
#include "ssh.h"
#include "ssh2.h"
#include "ssherr.h"
#include "atomicio.h"
#include "krl.h"
#include "digest.h"
#include "utf8.h"

#ifdef ENABLE_PKCS11
#include "ssh-pkcs11.h"
#endif

#ifdef WITH_OPENSSL
# define DEFAULT_KEY_TYPE_NAME "rsa"
#else
# define DEFAULT_KEY_TYPE_NAME "ed25519"
#endif

/* Number of bits in the RSA/DSA key.  This value can be set on the command line. */
#define DEFAULT_BITS		2048
#define DEFAULT_BITS_DSA	1024
#define DEFAULT_BITS_ECDSA	256
u_int32_t bits = 0;

/*
 * Flag indicating that we just want to change the passphrase.  This can be
 * set on the command line.
 */
int change_passphrase = 0;

/*
 * Flag indicating that we just want to change the comment.  This can be set
 * on the command line.
 */
int change_comment = 0;

int quiet = 0;

int log_level = SYSLOG_LEVEL_INFO;

/* Flag indicating that we want to hash a known_hosts file */
int hash_hosts = 0;
/* Flag indicating that we want lookup a host in known_hosts file */
int find_host = 0;
/* Flag indicating that we want to delete a host from a known_hosts file */
int delete_host = 0;

/* Flag indicating that we want to show the contents of a certificate */
int show_cert = 0;

/* Flag indicating that we just want to see the key fingerprint */
int print_fingerprint = 0;
int print_bubblebabble = 0;

/* Hash algorithm to use for fingerprints. */
int fingerprint_hash = SSH_FP_HASH_DEFAULT;

/* The identity file name, given on the command line or entered by the user. */
char identity_file[1024];
int have_identity = 0;

/* This is set to the passphrase if given on the command line. */
char *identity_passphrase = NULL;

/* This is set to the new passphrase if given on the command line. */
char *identity_new_passphrase = NULL;

/* This is set to the new comment if given on the command line. */
char *identity_comment = NULL;

/* Path to CA key when certifying keys. */
char *ca_key_path = NULL;

/* Certificate serial number */
unsigned long long cert_serial = 0;

/* Key type when certifying */
u_int cert_key_type = SSH2_CERT_TYPE_USER;

/* "key ID" of signed key */
char *cert_key_id = NULL;

/* Comma-separated list of principal names for certifying keys */
char *cert_principals = NULL;

/* Validity period for certificates */
u_int64_t cert_valid_from = 0;
u_int64_t cert_valid_to = ~0ULL;

/* Certificate options */
#define CERTOPT_X_FWD	(1)
#define CERTOPT_AGENT_FWD	(1<<1)
#define CERTOPT_PORT_FWD	(1<<2)
#define CERTOPT_PTY		(1<<3)
#define CERTOPT_USER_RC	(1<<4)
#define CERTOPT_DEFAULT	(CERTOPT_X_FWD|CERTOPT_AGENT_FWD| \
			 CERTOPT_PORT_FWD|CERTOPT_PTY|CERTOPT_USER_RC)
u_int32_t certflags_flags = CERTOPT_DEFAULT;
char *certflags_command = NULL;
char *certflags_src_addr = NULL;

/* Arbitrary extensions specified by user */
struct cert_userext {
	char *key;
	char *val;
	int crit;
};
struct cert_userext *cert_userext;
size_t ncert_userext;

/* Conversion to/from various formats */
int convert_to = 0;
int convert_from = 0;
enum {
	FMT_RFC4716,
	FMT_PKCS8,
	FMT_PEM
} convert_format = FMT_RFC4716;
int print_public = 0;
int print_generic = 0;

char *key_type_name = NULL;

/* Load key from this PKCS#11 provider */
char *pkcs11provider = NULL;

/* Use new OpenSSH private key format when writing SSH2 keys instead of PEM */
int use_new_format = 0;

/* Cipher for new-format private keys */
char *new_format_cipher = NULL;

/*
 * Number of KDF rounds to derive new format keys /
 * number of primality trials when screening moduli.
 */
int rounds = 0;

/* argv0 */
extern char *__progname;

char hostname[NI_MAXHOST];

#ifdef WITH_OPENSSL
/* moduli.c */
int gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t, char *, unsigned long,
    unsigned long);
#endif

static void
type_bits_valid(int type, const char *name, u_int32_t *bitsp)
{
#ifdef WITH_OPENSSL
	u_int maxbits, nid;
#endif

	if (type == KEY_UNSPEC)
		fatal("unknown key type %s", key_type_name);
	if (*bitsp == 0) {
#ifdef WITH_OPENSSL
		if (type == KEY_DSA)
			*bitsp = DEFAULT_BITS_DSA;
		else if (type == KEY_ECDSA) {
			if (name != NULL &&
			    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)
				*bitsp = sshkey_curve_nid_to_bits(nid);
			if (*bitsp == 0)
				*bitsp = DEFAULT_BITS_ECDSA;
		} else
#endif
			*bitsp = DEFAULT_BITS;
	}
#ifdef WITH_OPENSSL
	maxbits = (type == KEY_DSA) ?
	    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;
	if (*bitsp > maxbits)
		fatal("key bits exceeds maximum %d", maxbits);
	switch (type) {
	case KEY_DSA:
		if (*bitsp != 1024)
			fatal("Invalid DSA key length: must be 1024 bits");
		break;
	case KEY_RSA:
		if (*bitsp < SSH_RSA_MINIMUM_MODULUS_SIZE)
			fatal("Invalid RSA key length: minimum is %d bits",
			    SSH_RSA_MINIMUM_MODULUS_SIZE);
		break;
	case KEY_ECDSA:
		if (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)
			fatal("Invalid ECDSA key length: valid lengths are "
			    "256, 384 or 521 bits");
	}
#endif
}

static void
ask_filename(struct passwd *pw, const char *prompt)
{
	char buf[1024];
	char *name = NULL;

	if (key_type_name == NULL)
		name = _PATH_SSH_CLIENT_ID_RSA;
	else {
		switch (sshkey_type_from_name(key_type_name)) {
		case KEY_DSA_CERT:
		case KEY_DSA:
			name = _PATH_SSH_CLIENT_ID_DSA;
			break;
		case KEY_ECDSA_CERT:
		case KEY_ECDSA:
			name = _PATH_SSH_CLIENT_ID_ECDSA;
			break;
		case KEY_RSA_CERT:
		case KEY_RSA:
			name = _PATH_SSH_CLIENT_ID_RSA;
			break;
		case KEY_ED25519:
		case KEY_ED25519_CERT:
			name = _PATH_SSH_CLIENT_ID_ED25519;
			break;
		default:
			fatal("bad key type");
		}
	}
	snprintf(identity_file, sizeof(identity_file),
	    "%s/%s", pw->pw_dir, name);
	printf("%s (%s): ", prompt, identity_file);
	fflush(stdout);
	if (fgets(buf, sizeof(buf), stdin) == NULL)
		exit(1);
	buf[strcspn(buf, "\n")] = '\0';
	if (strcmp(buf, "") != 0)
		strlcpy(identity_file, buf, sizeof(identity_file));
	have_identity = 1;
}

static struct sshkey *
load_identity(char *filename)
{
	char *pass;
	struct sshkey *prv;
	int r;

	if ((r = sshkey_load_private(filename, "", &prv, NULL)) == 0)
		return prv;
	if (r != SSH_ERR_KEY_WRONG_PASSPHRASE)
		fatal("Load key \"%s\": %s", filename, ssh_err(r));
	if (identity_passphrase)
		pass = xstrdup(identity_passphrase);
	else
		pass = read_passphrase("Enter passphrase: ", RP_ALLOW_STDIN);
	r = sshkey_load_private(filename, pass, &prv, NULL);
	explicit_bzero(pass, strlen(pass));
	free(pass);
	if (r != 0)
		fatal("Load key \"%s\": %s", filename, ssh_err(r));
	return prv;
}

#define SSH_COM_PUBLIC_BEGIN		"---- BEGIN SSH2 PUBLIC KEY ----"
#define SSH_COM_PUBLIC_END		"---- END SSH2 PUBLIC KEY ----"
#define SSH_COM_PRIVATE_BEGIN		"---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----"
#define	SSH_COM_PRIVATE_KEY_MAGIC	0x3f6ff9eb

#ifdef WITH_OPENSSL
static void
do_convert_to_ssh2(struct passwd *pw, struct sshkey *k)
{
	size_t len;
	u_char *blob;
	char comment[61];
	int r;

	if ((r = sshkey_to_blob(k, &blob, &len)) != 0)
		fatal("key_to_blob failed: %s", ssh_err(r));
	/* Comment + surrounds must fit into 72 chars (RFC 4716 sec 3.3) */
	snprintf(comment, sizeof(comment),
	    "%u-bit %s, converted by %s@@%s from OpenSSH",
	    sshkey_size(k), sshkey_type(k),
	    pw->pw_name, hostname);

	fprintf(stdout, "%s\n", SSH_COM_PUBLIC_BEGIN);
	fprintf(stdout, "Comment: \"%s\"\n", comment);
	dump_base64(stdout, blob, len);
	fprintf(stdout, "%s\n", SSH_COM_PUBLIC_END);
	sshkey_free(k);
	free(blob);
	exit(0);
}

static void
do_convert_to_pkcs8(struct sshkey *k)
{
	switch (sshkey_type_plain(k->type)) {
	case KEY_RSA:
		if (!PEM_write_RSA_PUBKEY(stdout, k->rsa))
			fatal("PEM_write_RSA_PUBKEY failed");
		break;
	case KEY_DSA:
		if (!PEM_write_DSA_PUBKEY(stdout, k->dsa))
			fatal("PEM_write_DSA_PUBKEY failed");
		break;
	case KEY_ECDSA:
		if (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))
			fatal("PEM_write_EC_PUBKEY failed");
		break;
	default:
		fatal("%s: unsupported key type %s", __func__, sshkey_type(k));
	}
	exit(0);
}

static void
do_convert_to_pem(struct sshkey *k)
{
	switch (sshkey_type_plain(k->type)) {
	case KEY_RSA:
		if (!PEM_write_RSAPublicKey(stdout, k->rsa))
			fatal("PEM_write_RSAPublicKey failed");
		break;
#if notyet /* OpenSSH 0.9.8 lacks this function */
	case KEY_DSA:
		if (!PEM_write_DSAPublicKey(stdout, k->dsa))
			fatal("PEM_write_DSAPublicKey failed");
		break;
#endif
	/* XXX ECDSA? */
	default:
		fatal("%s: unsupported key type %s", __func__, sshkey_type(k));
	}
	exit(0);
}

static void
do_convert_to(struct passwd *pw)
{
	struct sshkey *k;
	struct stat st;
	int r;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));
	if ((r = sshkey_load_public(identity_file, &k, NULL)) != 0)
		k = load_identity(identity_file);
	switch (convert_format) {
	case FMT_RFC4716:
		do_convert_to_ssh2(pw, k);
		break;
	case FMT_PKCS8:
		do_convert_to_pkcs8(k);
		break;
	case FMT_PEM:
		do_convert_to_pem(k);
		break;
	default:
		fatal("%s: unknown key format %d", __func__, convert_format);
	}
	exit(0);
}

/*
 * This is almost exactly the bignum1 encoding, but with 32 bit for length
 * instead of 16.
 */
static void
buffer_get_bignum_bits(struct sshbuf *b, BIGNUM *value)
{
	u_int bytes, bignum_bits;
	int r;

	if ((r = sshbuf_get_u32(b, &bignum_bits)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	bytes = (bignum_bits + 7) / 8;
	if (sshbuf_len(b) < bytes)
		fatal("%s: input buffer too small: need %d have %zu",
		    __func__, bytes, sshbuf_len(b));
	if (BN_bin2bn(sshbuf_ptr(b), bytes, value) == NULL)
		fatal("%s: BN_bin2bn failed", __func__);
	if ((r = sshbuf_consume(b, bytes)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
}

static struct sshkey *
do_convert_private_ssh2_from_blob(u_char *blob, u_int blen)
{
	struct sshbuf *b;
	struct sshkey *key = NULL;
	char *type, *cipher;
	u_char e1, e2, e3, *sig = NULL, data[] = "abcde12345";
	int r, rlen, ktype;
	u_int magic, i1, i2, i3, i4;
	size_t slen;
	u_long e;

	if ((b = sshbuf_from(blob, blen)) == NULL)
		fatal("%s: sshbuf_from failed", __func__);
	if ((r = sshbuf_get_u32(b, &magic)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	if (magic != SSH_COM_PRIVATE_KEY_MAGIC) {
		error("bad magic 0x%x != 0x%x", magic,
		    SSH_COM_PRIVATE_KEY_MAGIC);
		sshbuf_free(b);
		return NULL;
	}
	if ((r = sshbuf_get_u32(b, &i1)) != 0 ||
	    (r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(b, &cipher, NULL)) != 0 ||
	    (r = sshbuf_get_u32(b, &i2)) != 0 ||
	    (r = sshbuf_get_u32(b, &i3)) != 0 ||
	    (r = sshbuf_get_u32(b, &i4)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
	debug("ignore (%d %d %d %d)", i1, i2, i3, i4);
	if (strcmp(cipher, "none") != 0) {
		error("unsupported cipher %s", cipher);
		free(cipher);
		sshbuf_free(b);
		free(type);
		return NULL;
	}
	free(cipher);

	if (strstr(type, "dsa")) {
		ktype = KEY_DSA;
	} else if (strstr(type, "rsa")) {
		ktype = KEY_RSA;
	} else {
		sshbuf_free(b);
		free(type);
		return NULL;
	}
	if ((key = sshkey_new_private(ktype)) == NULL)
		fatal("sshkey_new_private failed");
	free(type);

	switch (key->type) {
	case KEY_DSA:
		buffer_get_bignum_bits(b, key->dsa->p);
		buffer_get_bignum_bits(b, key->dsa->g);
		buffer_get_bignum_bits(b, key->dsa->q);
		buffer_get_bignum_bits(b, key->dsa->pub_key);
		buffer_get_bignum_bits(b, key->dsa->priv_key);
		break;
	case KEY_RSA:
		if ((r = sshbuf_get_u8(b, &e1)) != 0 ||
		    (e1 < 30 && (r = sshbuf_get_u8(b, &e2)) != 0) ||
		    (e1 < 30 && (r = sshbuf_get_u8(b, &e3)) != 0))
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		e = e1;
		debug("e %lx", e);
		if (e < 30) {
			e <<= 8;
			e += e2;
			debug("e %lx", e);
			e <<= 8;
			e += e3;
			debug("e %lx", e);
		}
		if (!BN_set_word(key->rsa->e, e)) {
			sshbuf_free(b);
			sshkey_free(key);
			return NULL;
		}
		buffer_get_bignum_bits(b, key->rsa->d);
		buffer_get_bignum_bits(b, key->rsa->n);
		buffer_get_bignum_bits(b, key->rsa->iqmp);
		buffer_get_bignum_bits(b, key->rsa->q);
		buffer_get_bignum_bits(b, key->rsa->p);
		if ((r = rsa_generate_additional_parameters(key->rsa)) != 0)
			fatal("generate RSA parameters failed: %s", ssh_err(r));
		break;
	}
	rlen = sshbuf_len(b);
	if (rlen != 0)
		error("do_convert_private_ssh2_from_blob: "
		    "remaining bytes in key blob %d", rlen);
	sshbuf_free(b);

	/* try the key */
	if (sshkey_sign(key, &sig, &slen, data, sizeof(data), NULL, 0) != 0 ||
	    sshkey_verify(key, sig, slen, data, sizeof(data), 0) != 0) {
		sshkey_free(key);
		free(sig);
		return NULL;
	}
	free(sig);
	return key;
}

static int
get_line(FILE *fp, char *line, size_t len)
{
	int c;
	size_t pos = 0;

	line[0] = '\0';
	while ((c = fgetc(fp)) != EOF) {
		if (pos >= len - 1)
			fatal("input line too long.");
		switch (c) {
		case '\r':
			c = fgetc(fp);
			if (c != EOF && c != '\n' && ungetc(c, fp) == EOF)
				fatal("unget: %s", strerror(errno));
			return pos;
		case '\n':
			return pos;
		}
		line[pos++] = c;
		line[pos] = '\0';
	}
	/* We reached EOF */
	return -1;
}

static void
do_convert_from_ssh2(struct passwd *pw, struct sshkey **k, int *private)
{
	int r, blen, escaped = 0;
	u_int len;
	char line[1024];
	u_char blob[8096];
	char encoded[8096];
	FILE *fp;

	if ((fp = fopen(identity_file, "r")) == NULL)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));
	encoded[0] = '\0';
	while ((blen = get_line(fp, line, sizeof(line))) != -1) {
		if (blen > 0 && line[blen - 1] == '\\')
			escaped++;
		if (strncmp(line, "----", 4) == 0 ||
		    strstr(line, ": ") != NULL) {
			if (strstr(line, SSH_COM_PRIVATE_BEGIN) != NULL)
				*private = 1;
			if (strstr(line, " END ") != NULL) {
				break;
			}
			/* fprintf(stderr, "ignore: %s", line); */
			continue;
		}
		if (escaped) {
			escaped--;
			/* fprintf(stderr, "escaped: %s", line); */
			continue;
		}
		strlcat(encoded, line, sizeof(encoded));
	}
	len = strlen(encoded);
	if (((len % 4) == 3) &&
	    (encoded[len-1] == '=') &&
	    (encoded[len-2] == '=') &&
	    (encoded[len-3] == '='))
		encoded[len-3] = '\0';
	blen = uudecode(encoded, blob, sizeof(blob));
	if (blen < 0)
		fatal("uudecode failed.");
	if (*private)
		*k = do_convert_private_ssh2_from_blob(blob, blen);
	else if ((r = sshkey_from_blob(blob, blen, k)) != 0)
		fatal("decode blob failed: %s", ssh_err(r));
	fclose(fp);
}

static void
do_convert_from_pkcs8(struct sshkey **k, int *private)
{
	EVP_PKEY *pubkey;
	FILE *fp;

	if ((fp = fopen(identity_file, "r")) == NULL)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));
	if ((pubkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {
		fatal("%s: %s is not a recognised public key format", __func__,
		    identity_file);
	}
	fclose(fp);
	switch (EVP_PKEY_type(pubkey->type)) {
	case EVP_PKEY_RSA:
		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
			fatal("sshkey_new failed");
		(*k)->type = KEY_RSA;
		(*k)->rsa = EVP_PKEY_get1_RSA(pubkey);
		break;
	case EVP_PKEY_DSA:
		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
			fatal("sshkey_new failed");
		(*k)->type = KEY_DSA;
		(*k)->dsa = EVP_PKEY_get1_DSA(pubkey);
		break;
	case EVP_PKEY_EC:
		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
			fatal("sshkey_new failed");
		(*k)->type = KEY_ECDSA;
		(*k)->ecdsa = EVP_PKEY_get1_EC_KEY(pubkey);
		(*k)->ecdsa_nid = sshkey_ecdsa_key_to_nid((*k)->ecdsa);
		break;
	default:
		fatal("%s: unsupported pubkey type %d", __func__,
		    EVP_PKEY_type(pubkey->type));
	}
	EVP_PKEY_free(pubkey);
	return;
}

static void
do_convert_from_pem(struct sshkey **k, int *private)
{
	FILE *fp;
	RSA *rsa;
#ifdef notyet
	DSA *dsa;
#endif

	if ((fp = fopen(identity_file, "r")) == NULL)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));
	if ((rsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL)) != NULL) {
		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
			fatal("sshkey_new failed");
		(*k)->type = KEY_RSA;
		(*k)->rsa = rsa;
		fclose(fp);
		return;
	}
#if notyet /* OpenSSH 0.9.8 lacks this function */
	rewind(fp);
	if ((dsa = PEM_read_DSAPublicKey(fp, NULL, NULL, NULL)) != NULL) {
		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
			fatal("sshkey_new failed");
		(*k)->type = KEY_DSA;
		(*k)->dsa = dsa;
		fclose(fp);
		return;
	}
	/* XXX ECDSA */
#endif
	fatal("%s: unrecognised raw private key format", __func__);
}

static void
do_convert_from(struct passwd *pw)
{
	struct sshkey *k = NULL;
	int r, private = 0, ok = 0;
	struct stat st;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));

	switch (convert_format) {
	case FMT_RFC4716:
		do_convert_from_ssh2(pw, &k, &private);
		break;
	case FMT_PKCS8:
		do_convert_from_pkcs8(&k, &private);
		break;
	case FMT_PEM:
		do_convert_from_pem(&k, &private);
		break;
	default:
		fatal("%s: unknown key format %d", __func__, convert_format);
	}

	if (!private) {
		if ((r = sshkey_write(k, stdout)) == 0)
			ok = 1;
		if (ok)
			fprintf(stdout, "\n");
	} else {
		switch (k->type) {
		case KEY_DSA:
			ok = PEM_write_DSAPrivateKey(stdout, k->dsa, NULL,
			    NULL, 0, NULL, NULL);
			break;
		case KEY_ECDSA:
			ok = PEM_write_ECPrivateKey(stdout, k->ecdsa, NULL,
			    NULL, 0, NULL, NULL);
			break;
		case KEY_RSA:
			ok = PEM_write_RSAPrivateKey(stdout, k->rsa, NULL,
			    NULL, 0, NULL, NULL);
			break;
		default:
			fatal("%s: unsupported key type %s", __func__,
			    sshkey_type(k));
		}
	}

	if (!ok)
		fatal("key write failed");
	sshkey_free(k);
	exit(0);
}
#endif

static void
do_print_public(struct passwd *pw)
{
	struct sshkey *prv;
	struct stat st;
	int r;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0)
		fatal("%s: %s", identity_file, strerror(errno));
	prv = load_identity(identity_file);
	if ((r = sshkey_write(prv, stdout)) != 0)
		error("sshkey_write failed: %s", ssh_err(r));
	sshkey_free(prv);
	fprintf(stdout, "\n");
	exit(0);
}

static void
do_download(struct passwd *pw)
{
#ifdef ENABLE_PKCS11
	struct sshkey **keys = NULL;
	int i, nkeys;
	enum sshkey_fp_rep rep;
	int fptype;
	char *fp, *ra;

	fptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;
	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;

	pkcs11_init(0);
	nkeys = pkcs11_add_provider(pkcs11provider, NULL, &keys);
	if (nkeys <= 0)
		fatal("cannot read public key from pkcs11");
	for (i = 0; i < nkeys; i++) {
		if (print_fingerprint) {
			fp = sshkey_fingerprint(keys[i], fptype, rep);
			ra = sshkey_fingerprint(keys[i], fingerprint_hash,
			    SSH_FP_RANDOMART);
			if (fp == NULL || ra == NULL)
				fatal("%s: sshkey_fingerprint fail", __func__);
			printf("%u %s %s (PKCS11 key)\n", sshkey_size(keys[i]),
			    fp, sshkey_type(keys[i]));
			if (log_level >= SYSLOG_LEVEL_VERBOSE)
				printf("%s\n", ra);
			free(ra);
			free(fp);
		} else {
			(void) sshkey_write(keys[i], stdout); /* XXX check */
			fprintf(stdout, "\n");
		}
		sshkey_free(keys[i]);
	}
	free(keys);
	pkcs11_terminate();
	exit(0);
#else
	fatal("no pkcs11 support");
#endif /* ENABLE_PKCS11 */
}

static struct sshkey *
try_read_key(char **cpp)
{
	struct sshkey *ret;
	int r;

	if ((ret = sshkey_new(KEY_UNSPEC)) == NULL)
		fatal("sshkey_new failed");
	if ((r = sshkey_read(ret, cpp)) == 0)
		return ret;
	/* Not a key */
	sshkey_free(ret);
	return NULL;
}

static void
fingerprint_one_key(const struct sshkey *public, const char *comment)
{
	char *fp = NULL, *ra = NULL;
	enum sshkey_fp_rep rep;
	int fptype;

	fptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;
	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;
	fp = sshkey_fingerprint(public, fptype, rep);
	ra = sshkey_fingerprint(public, fingerprint_hash, SSH_FP_RANDOMART);
	if (fp == NULL || ra == NULL)
		fatal("%s: sshkey_fingerprint failed", __func__);
	mprintf("%u %s %s (%s)\n", sshkey_size(public), fp,
	    comment ? comment : "no comment", sshkey_type(public));
	if (log_level >= SYSLOG_LEVEL_VERBOSE)
		printf("%s\n", ra);
	free(ra);
	free(fp);
}

static void
fingerprint_private(const char *path)
{
	struct stat st;
	char *comment = NULL;
	struct sshkey *public = NULL;
	int r;

	if (stat(identity_file, &st) < 0)
		fatal("%s: %s", path, strerror(errno));
	if ((r = sshkey_load_public(path, &public, &comment)) != 0) {
		debug("load public \"%s\": %s", path, ssh_err(r));
		if ((r = sshkey_load_private(path, NULL,
		    &public, &comment)) != 0) {
			debug("load private \"%s\": %s", path, ssh_err(r));
			fatal("%s is not a key file.", path);
		}
	}

	fingerprint_one_key(public, comment);
	sshkey_free(public);
	free(comment);
}

static void
do_fingerprint(struct passwd *pw)
{
	FILE *f;
	struct sshkey *public = NULL;
	char *comment = NULL, *cp, *ep, line[SSH_MAX_PUBKEY_BYTES];
	int i, invalid = 1;
	const char *path;
	u_long lnum = 0;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	path = identity_file;

	if (strcmp(identity_file, "-") == 0) {
		f = stdin;
		path = "(stdin)";
	} else if ((f = fopen(path, "r")) == NULL)
		fatal("%s: %s: %s", __progname, path, strerror(errno));

	while (read_keyfile_line(f, path, line, sizeof(line), &lnum) == 0) {
		cp = line;
		cp[strcspn(cp, "\n")] = '\0';
		/* Trim leading space and comments */
		cp = line + strspn(line, " \t");
		if (*cp == '#' || *cp == '\0')
			continue;

		/*
		 * Input may be plain keys, private keys, authorized_keys
		 * or known_hosts.
		 */

		/*
		 * Try private keys first. Assume a key is private if
		 * "SSH PRIVATE KEY" appears on the first line and we're
		 * not reading from stdin (XXX support private keys on stdin).
		 */
		if (lnum == 1 && strcmp(identity_file, "-") != 0 &&
		    strstr(cp, "PRIVATE KEY") != NULL) {
			fclose(f);
			fingerprint_private(path);
			exit(0);
		}

		/*
		 * If it's not a private key, then this must be prepared to
		 * accept a public key prefixed with a hostname or options.
		 * Try a bare key first, otherwise skip the leading stuff.
		 */
		if ((public = try_read_key(&cp)) == NULL) {
			i = strtol(cp, &ep, 10);
			if (i == 0 || ep == NULL ||
			    (*ep != ' ' && *ep != '\t')) {
				int quoted = 0;

				comment = cp;
				for (; *cp && (quoted || (*cp != ' ' &&
				    *cp != '\t')); cp++) {
					if (*cp == '\\' && cp[1] == '"')
						cp++;	/* Skip both */
					else if (*cp == '"')
						quoted = !quoted;
				}
				if (!*cp)
					continue;
				*cp++ = '\0';
			}
		}
		/* Retry after parsing leading hostname/key options */
		if (public == NULL && (public = try_read_key(&cp)) == NULL) {
			debug("%s:%lu: not a public key", path, lnum);
			continue;
		}

		/* Find trailing comment, if any */
		for (; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (*cp != '\0' && *cp != '#')
			comment = cp;

		fingerprint_one_key(public, comment);
		sshkey_free(public);
		invalid = 0; /* One good key in the file is sufficient */
	}
	fclose(f);

	if (invalid)
		fatal("%s is not a public key file.", path);
	exit(0);
}

static void
do_gen_all_hostkeys(struct passwd *pw)
{
	struct {
		char *key_type;
		char *key_type_display;
		char *path;
	} key_types[] = {
#ifdef WITH_OPENSSL
		{ "rsa", "RSA" ,_PATH_HOST_RSA_KEY_FILE },
		{ "dsa", "DSA", _PATH_HOST_DSA_KEY_FILE },
		{ "ecdsa", "ECDSA",_PATH_HOST_ECDSA_KEY_FILE },
#endif /* WITH_OPENSSL */
		{ "ed25519", "ED25519",_PATH_HOST_ED25519_KEY_FILE },
		{ NULL, NULL, NULL }
	};

	int first = 0;
	struct stat st;
	struct sshkey *private, *public;
	char comment[1024];
	int i, type, fd, r;
	FILE *f;

	for (i = 0; key_types[i].key_type; i++) {
		if (stat(key_types[i].path, &st) == 0)
			continue;
		if (errno != ENOENT) {
			error("Could not stat %s: %s", key_types[i].path,
			    strerror(errno));
			first = 0;
			continue;
		}

		if (first == 0) {
			first = 1;
			printf("%s: generating new host keys: ", __progname);
		}
		printf("%s ", key_types[i].key_type_display);
		fflush(stdout);
		type = sshkey_type_from_name(key_types[i].key_type);
		strlcpy(identity_file, key_types[i].path, sizeof(identity_file));
		bits = 0;
		type_bits_valid(type, NULL, &bits);
		if ((r = sshkey_generate(type, bits, &private)) != 0) {
			error("sshkey_generate failed: %s", ssh_err(r));
			first = 0;
			continue;
		}
		if ((r = sshkey_from_private(private, &public)) != 0)
			fatal("sshkey_from_private failed: %s", ssh_err(r));
		snprintf(comment, sizeof comment, "%s@@%s", pw->pw_name,
		    hostname);
		if ((r = sshkey_save_private(private, identity_file, "",
		    comment, use_new_format, new_format_cipher, rounds)) != 0) {
			error("Saving key \"%s\" failed: %s",
			    identity_file, ssh_err(r));
			sshkey_free(private);
			sshkey_free(public);
			first = 0;
			continue;
		}
		sshkey_free(private);
		strlcat(identity_file, ".pub", sizeof(identity_file));
		fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
		if (fd == -1) {
			error("Could not save your public key in %s",
			    identity_file);
			sshkey_free(public);
			first = 0;
			continue;
		}
		f = fdopen(fd, "w");
		if (f == NULL) {
			error("fdopen %s failed", identity_file);
			close(fd);
			sshkey_free(public);
			first = 0;
			continue;
		}
		if ((r = sshkey_write(public, f)) != 0) {
			error("write key failed: %s", ssh_err(r));
			fclose(f);
			sshkey_free(public);
			first = 0;
			continue;
		}
		fprintf(f, " %s\n", comment);
		fclose(f);
		sshkey_free(public);

	}
	if (first != 0)
		printf("\n");
}

struct known_hosts_ctx {
	const char *host;	/* Hostname searched for in find/delete case */
	FILE *out;		/* Output file, stdout for find_hosts case */
	int has_unhashed;	/* When hashing, original had unhashed hosts */
	int found_key;		/* For find/delete, host was found */
	int invalid;		/* File contained invalid items; don't delete */
};

static int
known_hosts_hash(struct hostkey_foreach_line *l, void *_ctx)
{
	struct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;
	char *hashed, *cp, *hosts, *ohosts;
	int has_wild = l->hosts && strcspn(l->hosts, "*?!") != strlen(l->hosts);
	int was_hashed = l->hosts && l->hosts[0] == HASH_DELIM;

	switch (l->status) {
	case HKF_STATUS_OK:
	case HKF_STATUS_MATCHED:
		/*
		 * Don't hash hosts already already hashed, with wildcard
		 * characters or a CA/revocation marker.
		 */
		if (was_hashed || has_wild || l->marker != MRK_NONE) {
			fprintf(ctx->out, "%s\n", l->line);
			if (has_wild && !find_host) {
				logit("%s:%lu: ignoring host name "
				    "with wildcard: %.64s", l->path,
				    l->linenum, l->hosts);
			}
			return 0;
		}
		/*
		 * Split any comma-separated hostnames from the host list,
		 * hash and store separately.
		 */
		ohosts = hosts = xstrdup(l->hosts);
		while ((cp = strsep(&hosts, ",")) != NULL && *cp != '\0') {
			lowercase(cp);
			if ((hashed = host_hash(cp, NULL, 0)) == NULL)
				fatal("hash_host failed");
			fprintf(ctx->out, "%s %s\n", hashed, l->rawkey);
			ctx->has_unhashed = 1;
		}
		free(ohosts);
		return 0;
	case HKF_STATUS_INVALID:
		/* Retain invalid lines, but mark file as invalid. */
		ctx->invalid = 1;
		logit("%s:%lu: invalid line", l->path, l->linenum);
		/* FALLTHROUGH */
	default:
		fprintf(ctx->out, "%s\n", l->line);
		return 0;
	}
	/* NOTREACHED */
	return -1;
}

static int
known_hosts_find_delete(struct hostkey_foreach_line *l, void *_ctx)
{
	struct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;
	enum sshkey_fp_rep rep;
	int fptype;
	char *fp;

	fptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;
	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;

	if (l->status == HKF_STATUS_MATCHED) {
		if (delete_host) {
			if (l->marker != MRK_NONE) {
				/* Don't remove CA and revocation lines */
				fprintf(ctx->out, "%s\n", l->line);
			} else {
				/*
				 * Hostname matches and has no CA/revoke
				 * marker, delete it by *not* writing the
				 * line to ctx->out.
				 */
				ctx->found_key = 1;
				if (!quiet)
					printf("# Host %s found: line %lu\n",
					    ctx->host, l->linenum);
			}
			return 0;
		} else if (find_host) {
			ctx->found_key = 1;
			if (!quiet) {
				printf("# Host %s found: line %lu %s\n",
				    ctx->host,
				    l->linenum, l->marker == MRK_CA ? "CA" :
				    (l->marker == MRK_REVOKE ? "REVOKED" : ""));
			}
			if (hash_hosts)
				known_hosts_hash(l, ctx);
			else if (print_fingerprint) {
				fp = sshkey_fingerprint(l->key, fptype, rep);
				mprintf("%s %s %s %s\n", ctx->host,
				    sshkey_type(l->key), fp, l->comment);
				free(fp);
			} else
				fprintf(ctx->out, "%s\n", l->line);
			return 0;
		}
	} else if (delete_host) {
		/* Retain non-matching hosts when deleting */
		if (l->status == HKF_STATUS_INVALID) {
			ctx->invalid = 1;
			logit("%s:%lu: invalid line", l->path, l->linenum);
		}
		fprintf(ctx->out, "%s\n", l->line);
	}
	return 0;
}

static void
do_known_hosts(struct passwd *pw, const char *name)
{
	char *cp, tmp[PATH_MAX], old[PATH_MAX];
	int r, fd, oerrno, inplace = 0;
	struct known_hosts_ctx ctx;
	u_int foreach_options;

	if (!have_identity) {
		cp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);
		if (strlcpy(identity_file, cp, sizeof(identity_file)) >=
		    sizeof(identity_file))
			fatal("Specified known hosts path too long");
		free(cp);
		have_identity = 1;
	}

	memset(&ctx, 0, sizeof(ctx));
	ctx.out = stdout;
	ctx.host = name;

	/*
	 * Find hosts goes to stdout, hash and deletions happen in-place
	 * A corner case is ssh-keygen -HF foo, which should go to stdout
	 */
	if (!find_host && (hash_hosts || delete_host)) {
		if (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||
		    strlcat(tmp, ".XXXXXXXXXX", sizeof(tmp)) >= sizeof(tmp) ||
		    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||
		    strlcat(old, ".old", sizeof(old)) >= sizeof(old))
			fatal("known_hosts path too long");
		umask(077);
		if ((fd = mkstemp(tmp)) == -1)
			fatal("mkstemp: %s", strerror(errno));
		if ((ctx.out = fdopen(fd, "w")) == NULL) {
			oerrno = errno;
			unlink(tmp);
			fatal("fdopen: %s", strerror(oerrno));
		}
		inplace = 1;
	}

	/* XXX support identity_file == "-" for stdin */
	foreach_options = find_host ? HKF_WANT_MATCH : 0;
	foreach_options |= print_fingerprint ? HKF_WANT_PARSE_KEY : 0;
	if ((r = hostkeys_foreach(identity_file,
	    hash_hosts ? known_hosts_hash : known_hosts_find_delete, &ctx,
	    name, NULL, foreach_options)) != 0) {
		if (inplace)
			unlink(tmp);
		fatal("%s: hostkeys_foreach failed: %s", __func__, ssh_err(r));
	}

	if (inplace)
		fclose(ctx.out);

	if (ctx.invalid) {
		error("%s is not a valid known_hosts file.", identity_file);
		if (inplace) {
			error("Not replacing existing known_hosts "
			    "file because of errors");
			unlink(tmp);
		}
		exit(1);
	} else if (delete_host && !ctx.found_key) {
		logit("Host %s not found in %s", name, identity_file);
		if (inplace)
			unlink(tmp);
	} else if (inplace) {
		/* Backup existing file */
		if (unlink(old) == -1 && errno != ENOENT)
			fatal("unlink %.100s: %s", old, strerror(errno));
		if (link(identity_file, old) == -1)
			fatal("link %.100s to %.100s: %s", identity_file, old,
			    strerror(errno));
		/* Move new one into place */
		if (rename(tmp, identity_file) == -1) {
			error("rename\"%s\" to \"%s\": %s", tmp, identity_file,
			    strerror(errno));
			unlink(tmp);
			unlink(old);
			exit(1);
		}

		printf("%s updated.\n", identity_file);
		printf("Original contents retained as %s\n", old);
		if (ctx.has_unhashed) {
			logit("WARNING: %s contains unhashed entries", old);
			logit("Delete this file to ensure privacy "
			    "of hostnames");
		}
	}

	exit (find_host && !ctx.found_key);
}

/*
 * Perform changing a passphrase.  The argument is the passwd structure
 * for the current user.
 */
static void
do_change_passphrase(struct passwd *pw)
{
	char *comment;
	char *old_passphrase, *passphrase1, *passphrase2;
	struct stat st;
	struct sshkey *private;
	int r;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0)
		fatal("%s: %s", identity_file, strerror(errno));
	/* Try to load the file with empty passphrase. */
	r = sshkey_load_private(identity_file, "", &private, &comment);
	if (r == SSH_ERR_KEY_WRONG_PASSPHRASE) {
		if (identity_passphrase)
			old_passphrase = xstrdup(identity_passphrase);
		else
			old_passphrase =
			    read_passphrase("Enter old passphrase: ",
			    RP_ALLOW_STDIN);
		r = sshkey_load_private(identity_file, old_passphrase,
		    &private, &comment);
		explicit_bzero(old_passphrase, strlen(old_passphrase));
		free(old_passphrase);
		if (r != 0)
			goto badkey;
	} else if (r != 0) {
 badkey:
		fatal("Failed to load key %s: %s", identity_file, ssh_err(r));
	}
	if (comment)
		mprintf("Key has comment '%s'\n", comment);

	/* Ask the new passphrase (twice). */
	if (identity_new_passphrase) {
		passphrase1 = xstrdup(identity_new_passphrase);
		passphrase2 = NULL;
	} else {
		passphrase1 =
			read_passphrase("Enter new passphrase (empty for no "
			    "passphrase): ", RP_ALLOW_STDIN);
		passphrase2 = read_passphrase("Enter same passphrase again: ",
		    RP_ALLOW_STDIN);

		/* Verify that they are the same. */
		if (strcmp(passphrase1, passphrase2) != 0) {
			explicit_bzero(passphrase1, strlen(passphrase1));
			explicit_bzero(passphrase2, strlen(passphrase2));
			free(passphrase1);
			free(passphrase2);
			printf("Pass phrases do not match.  Try again.\n");
			exit(1);
		}
		/* Destroy the other copy. */
		explicit_bzero(passphrase2, strlen(passphrase2));
		free(passphrase2);
	}

	/* Save the file using the new passphrase. */
	if ((r = sshkey_save_private(private, identity_file, passphrase1,
	    comment, use_new_format, new_format_cipher, rounds)) != 0) {
		error("Saving key \"%s\" failed: %s.",
		    identity_file, ssh_err(r));
		explicit_bzero(passphrase1, strlen(passphrase1));
		free(passphrase1);
		sshkey_free(private);
		free(comment);
		exit(1);
	}
	/* Destroy the passphrase and the copy of the key in memory. */
	explicit_bzero(passphrase1, strlen(passphrase1));
	free(passphrase1);
	sshkey_free(private);		 /* Destroys contents */
	free(comment);

	printf("Your identification has been saved with the new passphrase.\n");
	exit(0);
}

/*
 * Print the SSHFP RR.
 */
static int
do_print_resource_record(struct passwd *pw, char *fname, char *hname)
{
	struct sshkey *public;
	char *comment = NULL;
	struct stat st;
	int r;

	if (fname == NULL)
		fatal("%s: no filename", __func__);
	if (stat(fname, &st) < 0) {
		if (errno == ENOENT)
			return 0;
		fatal("%s: %s", fname, strerror(errno));
	}
	if ((r = sshkey_load_public(fname, &public, &comment)) != 0)
		fatal("Failed to read v2 public key from \"%s\": %s.",
		    fname, ssh_err(r));
	export_dns_rr(hname, public, stdout, print_generic);
	sshkey_free(public);
	free(comment);
	return 1;
}

/*
 * Change the comment of a private key file.
 */
static void
do_change_comment(struct passwd *pw)
{
	char new_comment[1024], *comment, *passphrase;
	struct sshkey *private;
	struct sshkey *public;
	struct stat st;
	FILE *f;
	int r, fd;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0)
		fatal("%s: %s", identity_file, strerror(errno));
	if ((r = sshkey_load_private(identity_file, "",
	    &private, &comment)) == 0)
		passphrase = xstrdup("");
	else if (r != SSH_ERR_KEY_WRONG_PASSPHRASE)
		fatal("Cannot load private key \"%s\": %s.",
		    identity_file, ssh_err(r));
	else {
		if (identity_passphrase)
			passphrase = xstrdup(identity_passphrase);
		else if (identity_new_passphrase)
			passphrase = xstrdup(identity_new_passphrase);
		else
			passphrase = read_passphrase("Enter passphrase: ",
			    RP_ALLOW_STDIN);
		/* Try to load using the passphrase. */
		if ((r = sshkey_load_private(identity_file, passphrase,
		    &private, &comment)) != 0) {
			explicit_bzero(passphrase, strlen(passphrase));
			free(passphrase);
			fatal("Cannot load private key \"%s\": %s.",
			    identity_file, ssh_err(r));
		}
	}

	if (private->type != KEY_ED25519 && !use_new_format) {
		error("Comments are only supported for keys stored in "
		    "the new format (-o).");
		explicit_bzero(passphrase, strlen(passphrase));
		sshkey_free(private);
		exit(1);
	}
	if (comment)
		printf("Key now has comment '%s'\n", comment);
	else
		printf("Key now has no comment\n");

	if (identity_comment) {
		strlcpy(new_comment, identity_comment, sizeof(new_comment));
	} else {
		printf("Enter new comment: ");
		fflush(stdout);
		if (!fgets(new_comment, sizeof(new_comment), stdin)) {
			explicit_bzero(passphrase, strlen(passphrase));
			sshkey_free(private);
			exit(1);
		}
		new_comment[strcspn(new_comment, "\n")] = '\0';
	}

	/* Save the file using the new passphrase. */
	if ((r = sshkey_save_private(private, identity_file, passphrase,
	    new_comment, use_new_format, new_format_cipher, rounds)) != 0) {
		error("Saving key \"%s\" failed: %s",
		    identity_file, ssh_err(r));
		explicit_bzero(passphrase, strlen(passphrase));
		free(passphrase);
		sshkey_free(private);
		free(comment);
		exit(1);
	}
	explicit_bzero(passphrase, strlen(passphrase));
	free(passphrase);
	if ((r = sshkey_from_private(private, &public)) != 0)
		fatal("sshkey_from_private failed: %s", ssh_err(r));
	sshkey_free(private);

	strlcat(identity_file, ".pub", sizeof(identity_file));
	fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1)
		fatal("Could not save your public key in %s", identity_file);
	f = fdopen(fd, "w");
	if (f == NULL)
		fatal("fdopen %s failed: %s", identity_file, strerror(errno));
	if ((r = sshkey_write(public, f)) != 0)
		fatal("write key failed: %s", ssh_err(r));
	sshkey_free(public);
	fprintf(f, " %s\n", new_comment);
	fclose(f);

	free(comment);

	printf("The comment in your key file has been changed.\n");
	exit(0);
}

static void
add_flag_option(struct sshbuf *c, const char *name)
{
	int r;

	debug3("%s: %s", __func__, name);
	if ((r = sshbuf_put_cstring(c, name)) != 0 ||
	    (r = sshbuf_put_string(c, NULL, 0)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));
}

static void
add_string_option(struct sshbuf *c, const char *name, const char *value)
{
	struct sshbuf *b;
	int r;

	debug3("%s: %s=%s", __func__, name, value);
	if ((b = sshbuf_new()) == NULL)
		fatal("%s: sshbuf_new failed", __func__);
	if ((r = sshbuf_put_cstring(b, value)) != 0 ||
	    (r = sshbuf_put_cstring(c, name)) != 0 ||
	    (r = sshbuf_put_stringb(c, b)) != 0)
		fatal("%s: buffer error: %s", __func__, ssh_err(r));

	sshbuf_free(b);
}

#define OPTIONS_CRITICAL	1
#define OPTIONS_EXTENSIONS	2
static void
prepare_options_buf(struct sshbuf *c, int which)
{
	size_t i;

	sshbuf_reset(c);
	if ((which & OPTIONS_CRITICAL) != 0 &&
	    certflags_command != NULL)
		add_string_option(c, "force-command", certflags_command);
	if ((which & OPTIONS_EXTENSIONS) != 0 &&
	    (certflags_flags & CERTOPT_X_FWD) != 0)
		add_flag_option(c, "permit-X11-forwarding");
	if ((which & OPTIONS_EXTENSIONS) != 0 &&
	    (certflags_flags & CERTOPT_AGENT_FWD) != 0)
		add_flag_option(c, "permit-agent-forwarding");
	if ((which & OPTIONS_EXTENSIONS) != 0 &&
	    (certflags_flags & CERTOPT_PORT_FWD) != 0)
		add_flag_option(c, "permit-port-forwarding");
	if ((which & OPTIONS_EXTENSIONS) != 0 &&
	    (certflags_flags & CERTOPT_PTY) != 0)
		add_flag_option(c, "permit-pty");
	if ((which & OPTIONS_EXTENSIONS) != 0 &&
	    (certflags_flags & CERTOPT_USER_RC) != 0)
		add_flag_option(c, "permit-user-rc");
	if ((which & OPTIONS_CRITICAL) != 0 &&
	    certflags_src_addr != NULL)
		add_string_option(c, "source-address", certflags_src_addr);
	for (i = 0; i < ncert_userext; i++) {
		if ((cert_userext[i].crit && (which & OPTIONS_EXTENSIONS)) ||
		    (!cert_userext[i].crit && (which & OPTIONS_CRITICAL)))
			continue;
		if (cert_userext[i].val == NULL)
			add_flag_option(c, cert_userext[i].key);
		else {
			add_string_option(c, cert_userext[i].key,
			    cert_userext[i].val);
		}
	}
}

static struct sshkey *
load_pkcs11_key(char *path)
{
#ifdef ENABLE_PKCS11
	struct sshkey **keys = NULL, *public, *private = NULL;
	int r, i, nkeys;

	if ((r = sshkey_load_public(path, &public, NULL)) != 0)
		fatal("Couldn't load CA public key \"%s\": %s",
		    path, ssh_err(r));

	nkeys = pkcs11_add_provider(pkcs11provider, identity_passphrase, &keys);
	debug3("%s: %d keys", __func__, nkeys);
	if (nkeys <= 0)
		fatal("cannot read public key from pkcs11");
	for (i = 0; i < nkeys; i++) {
		if (sshkey_equal_public(public, keys[i])) {
			private = keys[i];
			continue;
		}
		sshkey_free(keys[i]);
	}
	free(keys);
	sshkey_free(public);
	return private;
#else
	fatal("no pkcs11 support");
#endif /* ENABLE_PKCS11 */
}

static void
do_ca_sign(struct passwd *pw, int argc, char **argv)
{
	int r, i, fd;
	u_int n;
	struct sshkey *ca, *public;
	char valid[64], *otmp, *tmp, *cp, *out, *comment, **plist = NULL;
	FILE *f;

#ifdef ENABLE_PKCS11
	pkcs11_init(1);
#endif
	tmp = tilde_expand_filename(ca_key_path, pw->pw_uid);
	if (pkcs11provider != NULL) {
		if ((ca = load_pkcs11_key(tmp)) == NULL)
			fatal("No PKCS#11 key matching %s found", ca_key_path);
	} else
		ca = load_identity(tmp);
	free(tmp);

	if (key_type_name != NULL &&
	    sshkey_type_from_name(key_type_name) != ca->type)  {
		fatal("CA key type %s doesn't match specified %s",
		    sshkey_ssh_name(ca), key_type_name);
	}

	for (i = 0; i < argc; i++) {
		/* Split list of principals */
		n = 0;
		if (cert_principals != NULL) {
			otmp = tmp = xstrdup(cert_principals);
			plist = NULL;
			for (; (cp = strsep(&tmp, ",")) != NULL; n++) {
				plist = xreallocarray(plist, n + 1, sizeof(*plist));
				if (*(plist[n] = xstrdup(cp)) == '\0')
					fatal("Empty principal name");
			}
			free(otmp);
		}
	
		tmp = tilde_expand_filename(argv[i], pw->pw_uid);
		if ((r = sshkey_load_public(tmp, &public, &comment)) != 0)
			fatal("%s: unable to open \"%s\": %s",
			    __func__, tmp, ssh_err(r));
		if (public->type != KEY_RSA && public->type != KEY_DSA &&
		    public->type != KEY_ECDSA && public->type != KEY_ED25519)
			fatal("%s: key \"%s\" type %s cannot be certified",
			    __func__, tmp, sshkey_type(public));

		/* Prepare certificate to sign */
		if ((r = sshkey_to_certified(public)) != 0)
			fatal("Could not upgrade key %s to certificate: %s",
			    tmp, ssh_err(r));
		public->cert->type = cert_key_type;
		public->cert->serial = (u_int64_t)cert_serial;
		public->cert->key_id = xstrdup(cert_key_id);
		public->cert->nprincipals = n;
		public->cert->principals = plist;
		public->cert->valid_after = cert_valid_from;
		public->cert->valid_before = cert_valid_to;
		prepare_options_buf(public->cert->critical, OPTIONS_CRITICAL);
		prepare_options_buf(public->cert->extensions,
		    OPTIONS_EXTENSIONS);
		if ((r = sshkey_from_private(ca,
		    &public->cert->signature_key)) != 0)
			fatal("sshkey_from_private (ca key): %s", ssh_err(r));

		if ((r = sshkey_certify(public, ca, key_type_name)) != 0)
			fatal("Couldn't certify key %s: %s", tmp, ssh_err(r));

		if ((cp = strrchr(tmp, '.')) != NULL && strcmp(cp, ".pub") == 0)
			*cp = '\0';
		xasprintf(&out, "%s-cert.pub", tmp);
		free(tmp);

		if ((fd = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)
			fatal("Could not open \"%s\" for writing: %s", out,
			    strerror(errno));
		if ((f = fdopen(fd, "w")) == NULL)
			fatal("%s: fdopen: %s", __func__, strerror(errno));
		if ((r = sshkey_write(public, f)) != 0)
			fatal("Could not write certified key to %s: %s",
			    out, ssh_err(r));
		fprintf(f, " %s\n", comment);
		fclose(f);

		if (!quiet) {
			sshkey_format_cert_validity(public->cert,
			    valid, sizeof(valid));
			logit("Signed %s key %s: id \"%s\" serial %llu%s%s "
			    "valid %s", sshkey_cert_type(public),
			    out, public->cert->key_id,
			    (unsigned long long)public->cert->serial,
			    cert_principals != NULL ? " for " : "",
			    cert_principals != NULL ? cert_principals : "",
			    valid);
		}

		sshkey_free(public);
		free(out);
	}
#ifdef ENABLE_PKCS11
	pkcs11_terminate();
#endif
	exit(0);
}

static u_int64_t
parse_relative_time(const char *s, time_t now)
{
	int64_t mul, secs;

	mul = *s == '-' ? -1 : 1;

	if ((secs = convtime(s + 1)) == -1)
		fatal("Invalid relative certificate time %s", s);
	if (mul == -1 && secs > now)
		fatal("Certificate time %s cannot be represented", s);
	return now + (u_int64_t)(secs * mul);
}

static u_int64_t
parse_absolute_time(const char *s)
{
	struct tm tm;
	time_t tt;
	char buf[32], *fmt;

	/*
	 * POSIX strptime says "The application shall ensure that there
	 * is white-space or other non-alphanumeric characters between
	 * any two conversion specifications" so arrange things this way.
	 */
	switch (strlen(s)) {
	case 8:
		fmt = "%Y-%m-%d";
		snprintf(buf, sizeof(buf), "%.4s-%.2s-%.2s", s, s + 4, s + 6);
		break;
	case 14:
		fmt = "%Y-%m-%dT%H:%M:%S";
		snprintf(buf, sizeof(buf), "%.4s-%.2s-%.2sT%.2s:%.2s:%.2s",
		    s, s + 4, s + 6, s + 8, s + 10, s + 12);
		break;
	default:
		fatal("Invalid certificate time format %s", s);
	}

	memset(&tm, 0, sizeof(tm));
	if (strptime(buf, fmt, &tm) == NULL)
		fatal("Invalid certificate time %s", s);
	if ((tt = mktime(&tm)) < 0)
		fatal("Certificate time %s cannot be represented", s);
	return (u_int64_t)tt;
}

static void
parse_cert_times(char *timespec)
{
	char *from, *to;
	time_t now = time(NULL);
	int64_t secs;

	/* +timespec relative to now */
	if (*timespec == '+' && strchr(timespec, ':') == NULL) {
		if ((secs = convtime(timespec + 1)) == -1)
			fatal("Invalid relative certificate life %s", timespec);
		cert_valid_to = now + secs;
		/*
		 * Backdate certificate one minute to avoid problems on hosts
		 * with poorly-synchronised clocks.
		 */
		cert_valid_from = ((now - 59)/ 60) * 60;
		return;
	}

	/*
	 * from:to, where
	 * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS
	 *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS
	 */
	from = xstrdup(timespec);
	to = strchr(from, ':');
	if (to == NULL || from == to || *(to + 1) == '\0')
		fatal("Invalid certificate life specification %s", timespec);
	*to++ = '\0';

	if (*from == '-' || *from == '+')
		cert_valid_from = parse_relative_time(from, now);
	else
		cert_valid_from = parse_absolute_time(from);

	if (*to == '-' || *to == '+')
		cert_valid_to = parse_relative_time(to, now);
	else
		cert_valid_to = parse_absolute_time(to);

	if (cert_valid_to <= cert_valid_from)
		fatal("Empty certificate validity interval");
	free(from);
}

static void
add_cert_option(char *opt)
{
	char *val, *cp;
	int iscrit = 0;

	if (strcasecmp(opt, "clear") == 0)
		certflags_flags = 0;
	else if (strcasecmp(opt, "no-x11-forwarding") == 0)
		certflags_flags &= ~CERTOPT_X_FWD;
	else if (strcasecmp(opt, "permit-x11-forwarding") == 0)
		certflags_flags |= CERTOPT_X_FWD;
	else if (strcasecmp(opt, "no-agent-forwarding") == 0)
		certflags_flags &= ~CERTOPT_AGENT_FWD;
	else if (strcasecmp(opt, "permit-agent-forwarding") == 0)
		certflags_flags |= CERTOPT_AGENT_FWD;
	else if (strcasecmp(opt, "no-port-forwarding") == 0)
		certflags_flags &= ~CERTOPT_PORT_FWD;
	else if (strcasecmp(opt, "permit-port-forwarding") == 0)
		certflags_flags |= CERTOPT_PORT_FWD;
	else if (strcasecmp(opt, "no-pty") == 0)
		certflags_flags &= ~CERTOPT_PTY;
	else if (strcasecmp(opt, "permit-pty") == 0)
		certflags_flags |= CERTOPT_PTY;
	else if (strcasecmp(opt, "no-user-rc") == 0)
		certflags_flags &= ~CERTOPT_USER_RC;
	else if (strcasecmp(opt, "permit-user-rc") == 0)
		certflags_flags |= CERTOPT_USER_RC;
	else if (strncasecmp(opt, "force-command=", 14) == 0) {
		val = opt + 14;
		if (*val == '\0')
			fatal("Empty force-command option");
		if (certflags_command != NULL)
			fatal("force-command already specified");
		certflags_command = xstrdup(val);
	} else if (strncasecmp(opt, "source-address=", 15) == 0) {
		val = opt + 15;
		if (*val == '\0')
			fatal("Empty source-address option");
		if (certflags_src_addr != NULL)
			fatal("source-address already specified");
		if (addr_match_cidr_list(NULL, val) != 0)
			fatal("Invalid source-address list");
		certflags_src_addr = xstrdup(val);
	} else if (strncasecmp(opt, "extension:", 10) == 0 ||
		   (iscrit = (strncasecmp(opt, "critical:", 9) == 0))) {
		val = xstrdup(strchr(opt, ':') + 1);
		if ((cp = strchr(val, '=')) != NULL)
			*cp++ = '\0';
		cert_userext = xreallocarray(cert_userext, ncert_userext + 1,
		    sizeof(*cert_userext));
		cert_userext[ncert_userext].key = val;
		cert_userext[ncert_userext].val = cp == NULL ?
		    NULL : xstrdup(cp);
		cert_userext[ncert_userext].crit = iscrit;
		ncert_userext++;
	} else
		fatal("Unsupported certificate option \"%s\"", opt);
}

static void
show_options(struct sshbuf *optbuf, int in_critical)
{
	char *name, *arg;
	struct sshbuf *options, *option = NULL;
	int r;

	if ((options = sshbuf_fromb(optbuf)) == NULL)
		fatal("%s: sshbuf_fromb failed", __func__);
	while (sshbuf_len(options) != 0) {
		sshbuf_free(option);
		option = NULL;
		if ((r = sshbuf_get_cstring(options, &name, NULL)) != 0 ||
		    (r = sshbuf_froms(options, &option)) != 0)
			fatal("%s: buffer error: %s", __func__, ssh_err(r));
		printf("                %s", name);
		if (!in_critical &&
		    (strcmp(name, "permit-X11-forwarding") == 0 ||
		    strcmp(name, "permit-agent-forwarding") == 0 ||
		    strcmp(name, "permit-port-forwarding") == 0 ||
		    strcmp(name, "permit-pty") == 0 ||
		    strcmp(name, "permit-user-rc") == 0))
			printf("\n");
		else if (in_critical &&
		    (strcmp(name, "force-command") == 0 ||
		    strcmp(name, "source-address") == 0)) {
			if ((r = sshbuf_get_cstring(option, &arg, NULL)) != 0)
				fatal("%s: buffer error: %s",
				    __func__, ssh_err(r));
			printf(" %s\n", arg);
			free(arg);
		} else {
			printf(" UNKNOWN OPTION (len %zu)\n",
			    sshbuf_len(option));
			sshbuf_reset(option);
		}
		free(name);
		if (sshbuf_len(option) != 0)
			fatal("Option corrupt: extra data at end");
	}
	sshbuf_free(option);
	sshbuf_free(options);
}

static void
print_cert(struct sshkey *key)
{
	char valid[64], *key_fp, *ca_fp;
	u_int i;

	key_fp = sshkey_fingerprint(key, fingerprint_hash, SSH_FP_DEFAULT);
	ca_fp = sshkey_fingerprint(key->cert->signature_key,
	    fingerprint_hash, SSH_FP_DEFAULT);
	if (key_fp == NULL || ca_fp == NULL)
		fatal("%s: sshkey_fingerprint fail", __func__);
	sshkey_format_cert_validity(key->cert, valid, sizeof(valid));

	printf("        Type: %s %s certificate\n", sshkey_ssh_name(key),
	    sshkey_cert_type(key));
	printf("        Public key: %s %s\n", sshkey_type(key), key_fp);
	printf("        Signing CA: %s %s\n",
	    sshkey_type(key->cert->signature_key), ca_fp);
	printf("        Key ID: \"%s\"\n", key->cert->key_id);
	printf("        Serial: %llu\n", (unsigned long long)key->cert->serial);
	printf("        Valid: %s\n", valid);
	printf("        Principals: ");
	if (key->cert->nprincipals == 0)
		printf("(none)\n");
	else {
		for (i = 0; i < key->cert->nprincipals; i++)
			printf("\n                %s",
			    key->cert->principals[i]);
		printf("\n");
	}
	printf("        Critical Options: ");
	if (sshbuf_len(key->cert->critical) == 0)
		printf("(none)\n");
	else {
		printf("\n");
		show_options(key->cert->critical, 1);
	}
	printf("        Extensions: ");
	if (sshbuf_len(key->cert->extensions) == 0)
		printf("(none)\n");
	else {
		printf("\n");
		show_options(key->cert->extensions, 0);
	}
}

static void
do_show_cert(struct passwd *pw)
{
	struct sshkey *key = NULL;
	struct stat st;
	int r, is_stdin = 0, ok = 0;
	FILE *f;
	char *cp, line[SSH_MAX_PUBKEY_BYTES];
	const char *path;
	u_long lnum = 0;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (strcmp(identity_file, "-") != 0 && stat(identity_file, &st) < 0)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));

	path = identity_file;
	if (strcmp(path, "-") == 0) {
		f = stdin;
		path = "(stdin)";
		is_stdin = 1;
	} else if ((f = fopen(identity_file, "r")) == NULL)
		fatal("fopen %s: %s", identity_file, strerror(errno));

	while (read_keyfile_line(f, path, line, sizeof(line), &lnum) == 0) {
		sshkey_free(key);
		key = NULL;
		/* Trim leading space and comments */
		cp = line + strspn(line, " \t");
		if (*cp == '#' || *cp == '\0')
			continue;
		if ((key = sshkey_new(KEY_UNSPEC)) == NULL)
			fatal("sshkey_new");
		if ((r = sshkey_read(key, &cp)) != 0) {
			error("%s:%lu: invalid key: %s", path,
			    lnum, ssh_err(r));
			continue;
		}
		if (!sshkey_is_cert(key)) {
			error("%s:%lu is not a certificate", path, lnum);
			continue;
		}
		ok = 1;
		if (!is_stdin && lnum == 1)
			printf("%s:\n", path);
		else
			printf("%s:%lu:\n", path, lnum);
		print_cert(key);
	}
	sshkey_free(key);
	fclose(f);
	exit(ok ? 0 : 1);
}

#ifdef WITH_OPENSSL
static void
load_krl(const char *path, struct ssh_krl **krlp)
{
	struct sshbuf *krlbuf;
	int r, fd;

	if ((krlbuf = sshbuf_new()) == NULL)
		fatal("sshbuf_new failed");
	if ((fd = open(path, O_RDONLY)) == -1)
		fatal("open %s: %s", path, strerror(errno));
	if ((r = sshkey_load_file(fd, krlbuf)) != 0)
		fatal("Unable to load KRL: %s", ssh_err(r));
	close(fd);
	/* XXX check sigs */
	if ((r = ssh_krl_from_blob(krlbuf, krlp, NULL, 0)) != 0 ||
	    *krlp == NULL)
		fatal("Invalid KRL file: %s", ssh_err(r));
	sshbuf_free(krlbuf);
}

static void
update_krl_from_file(struct passwd *pw, const char *file, int wild_ca,
    const struct sshkey *ca, struct ssh_krl *krl)
{
	struct sshkey *key = NULL;
	u_long lnum = 0;
	char *path, *cp, *ep, line[SSH_MAX_PUBKEY_BYTES];
	unsigned long long serial, serial2;
	int i, was_explicit_key, was_sha1, r;
	FILE *krl_spec;

	path = tilde_expand_filename(file, pw->pw_uid);
	if (strcmp(path, "-") == 0) {
		krl_spec = stdin;
		free(path);
		path = xstrdup("(standard input)");
	} else if ((krl_spec = fopen(path, "r")) == NULL)
		fatal("fopen %s: %s", path, strerror(errno));

	if (!quiet)
		printf("Revoking from %s\n", path);
	while (read_keyfile_line(krl_spec, path, line, sizeof(line),
	    &lnum) == 0) {
		was_explicit_key = was_sha1 = 0;
		cp = line + strspn(line, " \t");
		/* Trim trailing space, comments and strip \n */
		for (i = 0, r = -1; cp[i] != '\0'; i++) {
			if (cp[i] == '#' || cp[i] == '\n') {
				cp[i] = '\0';
				break;
			}
			if (cp[i] == ' ' || cp[i] == '\t') {
				/* Remember the start of a span of whitespace */
				if (r == -1)
					r = i;
			} else
				r = -1;
		}
		if (r != -1)
			cp[r] = '\0';
		if (*cp == '\0')
			continue;
		if (strncasecmp(cp, "serial:", 7) == 0) {
			if (ca == NULL && !wild_ca) {
				fatal("revoking certificates by serial number "
				    "requires specification of a CA key");
			}
			cp += 7;
			cp = cp + strspn(cp, " \t");
			errno = 0;
			serial = strtoull(cp, &ep, 0);
			if (*cp == '\0' || (*ep != '\0' && *ep != '-'))
				fatal("%s:%lu: invalid serial \"%s\"",
				    path, lnum, cp);
			if (errno == ERANGE && serial == ULLONG_MAX)
				fatal("%s:%lu: serial out of range",
				    path, lnum);
			serial2 = serial;
			if (*ep == '-') {
				cp = ep + 1;
				errno = 0;
				serial2 = strtoull(cp, &ep, 0);
				if (*cp == '\0' || *ep != '\0')
					fatal("%s:%lu: invalid serial \"%s\"",
					    path, lnum, cp);
				if (errno == ERANGE && serial2 == ULLONG_MAX)
					fatal("%s:%lu: serial out of range",
					    path, lnum);
				if (serial2 <= serial)
					fatal("%s:%lu: invalid serial range "
					    "%llu:%llu", path, lnum,
					    (unsigned long long)serial,
					    (unsigned long long)serial2);
			}
			if (ssh_krl_revoke_cert_by_serial_range(krl,
			    ca, serial, serial2) != 0) {
				fatal("%s: revoke serial failed",
				    __func__);
			}
		} else if (strncasecmp(cp, "id:", 3) == 0) {
			if (ca == NULL && !wild_ca) {
				fatal("revoking certificates by key ID "
				    "requires specification of a CA key");
			}
			cp += 3;
			cp = cp + strspn(cp, " \t");
			if (ssh_krl_revoke_cert_by_key_id(krl, ca, cp) != 0)
				fatal("%s: revoke key ID failed", __func__);
		} else {
			if (strncasecmp(cp, "key:", 4) == 0) {
				cp += 4;
				cp = cp + strspn(cp, " \t");
				was_explicit_key = 1;
			} else if (strncasecmp(cp, "sha1:", 5) == 0) {
				cp += 5;
				cp = cp + strspn(cp, " \t");
				was_sha1 = 1;
			} else {
				/*
				 * Just try to process the line as a key.
				 * Parsing will fail if it isn't.
				 */
			}
			if ((key = sshkey_new(KEY_UNSPEC)) == NULL)
				fatal("sshkey_new");
			if ((r = sshkey_read(key, &cp)) != 0)
				fatal("%s:%lu: invalid key: %s",
				    path, lnum, ssh_err(r));
			if (was_explicit_key)
				r = ssh_krl_revoke_key_explicit(krl, key);
			else if (was_sha1)
				r = ssh_krl_revoke_key_sha1(krl, key);
			else
				r = ssh_krl_revoke_key(krl, key);
			if (r != 0)
				fatal("%s: revoke key failed: %s",
				    __func__, ssh_err(r));
			sshkey_free(key);
		}
	}
	if (strcmp(path, "-") != 0)
		fclose(krl_spec);
	free(path);
}

static void
do_gen_krl(struct passwd *pw, int updating, int argc, char **argv)
{
	struct ssh_krl *krl;
	struct stat sb;
	struct sshkey *ca = NULL;
	int fd, i, r, wild_ca = 0;
	char *tmp;
	struct sshbuf *kbuf;

	if (*identity_file == '\0')
		fatal("KRL generation requires an output file");
	if (stat(identity_file, &sb) == -1) {
		if (errno != ENOENT)
			fatal("Cannot access KRL \"%s\": %s",
			    identity_file, strerror(errno));
		if (updating)
			fatal("KRL \"%s\" does not exist", identity_file);
	}
	if (ca_key_path != NULL) {
		if (strcasecmp(ca_key_path, "none") == 0)
			wild_ca = 1;
		else {
			tmp = tilde_expand_filename(ca_key_path, pw->pw_uid);
			if ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)
				fatal("Cannot load CA public key %s: %s",
				    tmp, ssh_err(r));
			free(tmp);
		}
	}

	if (updating)
		load_krl(identity_file, &krl);
	else if ((krl = ssh_krl_init()) == NULL)
		fatal("couldn't create KRL");

	if (cert_serial != 0)
		ssh_krl_set_version(krl, cert_serial);
	if (identity_comment != NULL)
		ssh_krl_set_comment(krl, identity_comment);

	for (i = 0; i < argc; i++)
		update_krl_from_file(pw, argv[i], wild_ca, ca, krl);

	if ((kbuf = sshbuf_new()) == NULL)
		fatal("sshbuf_new failed");
	if (ssh_krl_to_blob(krl, kbuf, NULL, 0) != 0)
		fatal("Couldn't generate KRL");
	if ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)
		fatal("open %s: %s", identity_file, strerror(errno));
	if (atomicio(vwrite, fd, (void *)sshbuf_ptr(kbuf), sshbuf_len(kbuf)) !=
	    sshbuf_len(kbuf))
		fatal("write %s: %s", identity_file, strerror(errno));
	close(fd);
	sshbuf_free(kbuf);
	ssh_krl_free(krl);
	sshkey_free(ca);
}

static void
do_check_krl(struct passwd *pw, int argc, char **argv)
{
	int i, r, ret = 0;
	char *comment;
	struct ssh_krl *krl;
	struct sshkey *k;

	if (*identity_file == '\0')
		fatal("KRL checking requires an input file");
	load_krl(identity_file, &krl);
	for (i = 0; i < argc; i++) {
		if ((r = sshkey_load_public(argv[i], &k, &comment)) != 0)
			fatal("Cannot load public key %s: %s",
			    argv[i], ssh_err(r));
		r = ssh_krl_check_key(krl, k);
		printf("%s%s%s%s: %s\n", argv[i],
		    *comment ? " (" : "", comment, *comment ? ")" : "",
		    r == 0 ? "ok" : "REVOKED");
		if (r != 0)
			ret = 1;
		sshkey_free(k);
		free(comment);
	}
	ssh_krl_free(krl);
	exit(ret);
}
#endif

static void
usage(void)
{
	fprintf(stderr,
	    "usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa]\n"
	    "                  [-N new_passphrase] [-C comment] [-f output_keyfile]\n"
	    "       ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]\n"
	    "       ssh-keygen -i [-m key_format] [-f input_keyfile]\n"
	    "       ssh-keygen -e [-m key_format] [-f input_keyfile]\n"
	    "       ssh-keygen -y [-f input_keyfile]\n"
	    "       ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]\n"
	    "       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]\n"
	    "       ssh-keygen -B [-f input_keyfile]\n");
#ifdef ENABLE_PKCS11
	fprintf(stderr,
	    "       ssh-keygen -D pkcs11\n");
#endif
	fprintf(stderr,
	    "       ssh-keygen -F hostname [-f known_hosts_file] [-l]\n"
	    "       ssh-keygen -H [-f known_hosts_file]\n"
	    "       ssh-keygen -R hostname [-f known_hosts_file]\n"
	    "       ssh-keygen -r hostname [-f input_keyfile] [-g]\n"
#ifdef WITH_OPENSSL
	    "       ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]\n"
	    "       ssh-keygen -T output_file -f input_file [-v] [-a rounds] [-J num_lines]\n"
	    "                  [-j start_line] [-K checkpt] [-W generator]\n"
#endif
	    "       ssh-keygen -s ca_key -I certificate_identity [-h] [-n principals]\n"
	    "                  [-O option] [-V validity_interval] [-z serial_number] file ...\n"
	    "       ssh-keygen -L [-f input_keyfile]\n"
	    "       ssh-keygen -A\n"
	    "       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]\n"
	    "                  file ...\n"
	    "       ssh-keygen -Q -f krl_file file ...\n");
	exit(1);
}

/*
 * Main program for key management.
 */
int
main(int argc, char **argv)
{
	char dotsshdir[PATH_MAX], comment[1024], *passphrase1, *passphrase2;
	char *rr_hostname = NULL, *ep, *fp, *ra;
	struct sshkey *private, *public;
	struct passwd *pw;
	struct stat st;
	int r, opt, type, fd;
	int gen_all_hostkeys = 0, gen_krl = 0, update_krl = 0, check_krl = 0;
	FILE *f;
	const char *errstr;
#ifdef WITH_OPENSSL
	/* Moduli generation/screening */
	char out_file[PATH_MAX], *checkpoint = NULL;
	u_int32_t memory = 0, generator_wanted = 0;
	int do_gen_candidates = 0, do_screen_candidates = 0;
	unsigned long start_lineno = 0, lines_to_process = 0;
	BIGNUM *start = NULL;
#endif

	extern int optind;
	extern char *optarg;

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	OpenSSL_add_all_algorithms();
	log_init(argv[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);

	setlocale(LC_CTYPE, "");

	/* we need this for the home * directory.  */
	pw = getpwuid(getuid());
	if (!pw)
		fatal("No user exists for uid %lu", (u_long)getuid());
	if (gethostname(hostname, sizeof(hostname)) < 0)
		fatal("gethostname: %s", strerror(errno));

	/* Remaining characters: UYdw */
	while ((opt = getopt(argc, argv, "ABHLQXceghiklopquvxy"
	    "C:D:E:F:G:I:J:K:M:N:O:P:R:S:T:V:W:Z:"
	    "a:b:f:g:j:m:n:r:s:t:z:")) != -1) {
		switch (opt) {
		case 'A':
			gen_all_hostkeys = 1;
			break;
		case 'b':
			bits = (u_int32_t)strtonum(optarg, 256, 32768, &errstr);
			if (errstr)
				fatal("Bits has bad value %s (%s)",
					optarg, errstr);
			break;
		case 'E':
			fingerprint_hash = ssh_digest_alg_by_name(optarg);
			if (fingerprint_hash == -1)
				fatal("Invalid hash algorithm \"%s\"", optarg);
			break;
		case 'F':
			find_host = 1;
			rr_hostname = optarg;
			break;
		case 'H':
			hash_hosts = 1;
			break;
		case 'I':
			cert_key_id = optarg;
			break;
		case 'R':
			delete_host = 1;
			rr_hostname = optarg;
			break;
		case 'L':
			show_cert = 1;
			break;
		case 'l':
			print_fingerprint = 1;
			break;
		case 'B':
			print_bubblebabble = 1;
			break;
		case 'm':
			if (strcasecmp(optarg, "RFC4716") == 0 ||
			    strcasecmp(optarg, "ssh2") == 0) {
				convert_format = FMT_RFC4716;
				break;
			}
			if (strcasecmp(optarg, "PKCS8") == 0) {
				convert_format = FMT_PKCS8;
				break;
			}
			if (strcasecmp(optarg, "PEM") == 0) {
				convert_format = FMT_PEM;
				break;
			}
			fatal("Unsupported conversion format \"%s\"", optarg);
		case 'n':
			cert_principals = optarg;
			break;
		case 'o':
			use_new_format = 1;
			break;
		case 'p':
			change_passphrase = 1;
			break;
		case 'c':
			change_comment = 1;
			break;
		case 'f':
			if (strlcpy(identity_file, optarg,
			    sizeof(identity_file)) >= sizeof(identity_file))
				fatal("Identity filename too long");
			have_identity = 1;
			break;
		case 'g':
			print_generic = 1;
			break;
		case 'P':
			identity_passphrase = optarg;
			break;
		case 'N':
			identity_new_passphrase = optarg;
			break;
		case 'Q':
			check_krl = 1;
			break;
		case 'O':
			add_cert_option(optarg);
			break;
		case 'Z':
			new_format_cipher = optarg;
			break;
		case 'C':
			identity_comment = optarg;
			break;
		case 'q':
			quiet = 1;
			break;
		case 'e':
		case 'x':
			/* export key */
			convert_to = 1;
			break;
		case 'h':
			cert_key_type = SSH2_CERT_TYPE_HOST;
			certflags_flags = 0;
			break;
		case 'k':
			gen_krl = 1;
			break;
		case 'i':
		case 'X':
			/* import key */
			convert_from = 1;
			break;
		case 'y':
			print_public = 1;
			break;
		case 's':
			ca_key_path = optarg;
			break;
		case 't':
			key_type_name = optarg;
			break;
		case 'D':
			pkcs11provider = optarg;
			break;
		case 'u':
			update_krl = 1;
			break;
		case 'v':
			if (log_level == SYSLOG_LEVEL_INFO)
				log_level = SYSLOG_LEVEL_DEBUG1;
			else {
				if (log_level >= SYSLOG_LEVEL_DEBUG1 &&
				    log_level < SYSLOG_LEVEL_DEBUG3)
					log_level++;
			}
			break;
		case 'r':
			rr_hostname = optarg;
			break;
		case 'a':
			rounds = (int)strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("Invalid number: %s (%s)",
					optarg, errstr);
			break;
		case 'V':
			parse_cert_times(optarg);
			break;
		case 'z':
			errno = 0;
			cert_serial = strtoull(optarg, &ep, 10);
			if (*optarg < '0' || *optarg > '9' || *ep != '\0' ||
			    (errno == ERANGE && cert_serial == ULLONG_MAX))
				fatal("Invalid serial number \"%s\"", optarg);
			break;
#ifdef WITH_OPENSSL
		/* Moduli generation/screening */
		case 'G':
			do_gen_candidates = 1;
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
			break;
		case 'J':
			lines_to_process = strtoul(optarg, NULL, 10);
			break;
		case 'j':
			start_lineno = strtoul(optarg, NULL, 10);
			break;
		case 'K':
			if (strlen(optarg) >= PATH_MAX)
				fatal("Checkpoint filename too long");
			checkpoint = xstrdup(optarg);
			break;
		case 'M':
			memory = (u_int32_t)strtonum(optarg, 1, UINT_MAX,
			    &errstr);
			if (errstr)
				fatal("Memory limit is %s: %s", errstr, optarg);
			break;
		case 'S':
			/* XXX - also compare length against bits */
			if (BN_hex2bn(&start, optarg) == 0)
				fatal("Invalid start point.");
			break;
		case 'T':
			do_screen_candidates = 1;
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
			break;
		case 'W':
			generator_wanted = (u_int32_t)strtonum(optarg, 1,
			    UINT_MAX, &errstr);
			if (errstr != NULL)
				fatal("Desired generator invalid: %s (%s)",
				    optarg, errstr);
			break;
#endif /* WITH_OPENSSL */
		case '?':
		default:
			usage();
		}
	}

	/* reinit */
	log_init(argv[0], log_level, SYSLOG_FACILITY_USER, 1);

	argv += optind;
	argc -= optind;

	if (ca_key_path != NULL) {
		if (argc < 1 && !gen_krl) {
			error("Too few arguments.");
			usage();
		}
	} else if (argc > 0 && !gen_krl && !check_krl) {
		error("Too many arguments.");
		usage();
	}
	if (change_passphrase && change_comment) {
		error("Can only have one of -p and -c.");
		usage();
	}
	if (print_fingerprint && (delete_host || hash_hosts)) {
		error("Cannot use -l with -H or -R.");
		usage();
	}
#ifdef WITH_OPENSSL
	if (gen_krl) {
		do_gen_krl(pw, update_krl, argc, argv);
		return (0);
	}
	if (check_krl) {
		do_check_krl(pw, argc, argv);
		return (0);
	}
#endif
	if (ca_key_path != NULL) {
		if (cert_key_id == NULL)
			fatal("Must specify key id (-I) when certifying");
		do_ca_sign(pw, argc, argv);
	}
	if (show_cert)
		do_show_cert(pw);
	if (delete_host || hash_hosts || find_host)
		do_known_hosts(pw, rr_hostname);
	if (pkcs11provider != NULL)
		do_download(pw);
	if (print_fingerprint || print_bubblebabble)
		do_fingerprint(pw);
	if (change_passphrase)
		do_change_passphrase(pw);
	if (change_comment)
		do_change_comment(pw);
#ifdef WITH_OPENSSL
	if (convert_to)
		do_convert_to(pw);
	if (convert_from)
		do_convert_from(pw);
#endif
	if (print_public)
		do_print_public(pw);
	if (rr_hostname != NULL) {
		unsigned int n = 0;

		if (have_identity) {
			n = do_print_resource_record(pw,
			    identity_file, rr_hostname);
			if (n == 0)
				fatal("%s: %s", identity_file, strerror(errno));
			exit(0);
		} else {

			n += do_print_resource_record(pw,
			    _PATH_HOST_RSA_KEY_FILE, rr_hostname);
			n += do_print_resource_record(pw,
			    _PATH_HOST_DSA_KEY_FILE, rr_hostname);
			n += do_print_resource_record(pw,
			    _PATH_HOST_ECDSA_KEY_FILE, rr_hostname);
			n += do_print_resource_record(pw,
			    _PATH_HOST_ED25519_KEY_FILE, rr_hostname);
			if (n == 0)
				fatal("no keys found.");
			exit(0);
		}
	}

#ifdef WITH_OPENSSL
	if (do_gen_candidates) {
		FILE *out = fopen(out_file, "w");

		if (out == NULL) {
			error("Couldn't open modulus candidate file \"%s\": %s",
			    out_file, strerror(errno));
			return (1);
		}
		if (bits == 0)
			bits = DEFAULT_BITS;
		if (gen_candidates(out, memory, bits, start) != 0)
			fatal("modulus candidate generation failed");

		return (0);
	}

	if (do_screen_candidates) {
		FILE *in;
		FILE *out = fopen(out_file, "a");

		if (have_identity && strcmp(identity_file, "-") != 0) {
			if ((in = fopen(identity_file, "r")) == NULL) {
				fatal("Couldn't open modulus candidate "
				    "file \"%s\": %s", identity_file,
				    strerror(errno));
			}
		} else
			in = stdin;

		if (out == NULL) {
			fatal("Couldn't open moduli file \"%s\": %s",
			    out_file, strerror(errno));
		}
		if (prime_test(in, out, rounds == 0 ? 100 : rounds,
		    generator_wanted, checkpoint,
		    start_lineno, lines_to_process) != 0)
			fatal("modulus screening failed");
		return (0);
	}
#endif

	if (gen_all_hostkeys) {
		do_gen_all_hostkeys(pw);
		return (0);
	}

	if (key_type_name == NULL)
		key_type_name = DEFAULT_KEY_TYPE_NAME;

	type = sshkey_type_from_name(key_type_name);
	type_bits_valid(type, key_type_name, &bits);

	if (!quiet)
		printf("Generating public/private %s key pair.\n",
		    key_type_name);
	if ((r = sshkey_generate(type, bits, &private)) != 0)
		fatal("sshkey_generate failed");
	if ((r = sshkey_from_private(private, &public)) != 0)
		fatal("sshkey_from_private failed: %s\n", ssh_err(r));

	if (!have_identity)
		ask_filename(pw, "Enter file in which to save the key");

	/* Create ~/.ssh directory if it doesn't already exist. */
	snprintf(dotsshdir, sizeof dotsshdir, "%s/%s",
	    pw->pw_dir, _PATH_SSH_USER_DIR);
	if (strstr(identity_file, dotsshdir) != NULL) {
		if (stat(dotsshdir, &st) < 0) {
			if (errno != ENOENT) {
				error("Could not stat %s: %s", dotsshdir,
				    strerror(errno));
			} else if (mkdir(dotsshdir, 0700) < 0) {
				error("Could not create directory '%s': %s",
				    dotsshdir, strerror(errno));
			} else if (!quiet)
				printf("Created directory '%s'.\n", dotsshdir);
		}
	}
	/* If the file already exists, ask the user to confirm. */
	if (stat(identity_file, &st) >= 0) {
		char yesno[3];
		printf("%s already exists.\n", identity_file);
		printf("Overwrite (y/n)? ");
		fflush(stdout);
		if (fgets(yesno, sizeof(yesno), stdin) == NULL)
			exit(1);
		if (yesno[0] != 'y' && yesno[0] != 'Y')
			exit(1);
	}
	/* Ask for a passphrase (twice). */
	if (identity_passphrase)
		passphrase1 = xstrdup(identity_passphrase);
	else if (identity_new_passphrase)
		passphrase1 = xstrdup(identity_new_passphrase);
	else {
passphrase_again:
		passphrase1 =
			read_passphrase("Enter passphrase (empty for no "
			    "passphrase): ", RP_ALLOW_STDIN);
		passphrase2 = read_passphrase("Enter same passphrase again: ",
		    RP_ALLOW_STDIN);
		if (strcmp(passphrase1, passphrase2) != 0) {
			/*
			 * The passphrases do not match.  Clear them and
			 * retry.
			 */
			explicit_bzero(passphrase1, strlen(passphrase1));
			explicit_bzero(passphrase2, strlen(passphrase2));
			free(passphrase1);
			free(passphrase2);
			printf("Passphrases do not match.  Try again.\n");
			goto passphrase_again;
		}
		/* Clear the other copy of the passphrase. */
		explicit_bzero(passphrase2, strlen(passphrase2));
		free(passphrase2);
	}

	if (identity_comment) {
		strlcpy(comment, identity_comment, sizeof(comment));
	} else {
		/* Create default comment field for the passphrase. */
		snprintf(comment, sizeof comment, "%s@@%s", pw->pw_name, hostname);
	}

	/* Save the key with the given passphrase and comment. */
	if ((r = sshkey_save_private(private, identity_file, passphrase1,
	    comment, use_new_format, new_format_cipher, rounds)) != 0) {
		error("Saving key \"%s\" failed: %s",
		    identity_file, ssh_err(r));
		explicit_bzero(passphrase1, strlen(passphrase1));
		free(passphrase1);
		exit(1);
	}
	/* Clear the passphrase. */
	explicit_bzero(passphrase1, strlen(passphrase1));
	free(passphrase1);

	/* Clear the private key and the random number generator. */
	sshkey_free(private);

	if (!quiet)
		printf("Your identification has been saved in %s.\n", identity_file);

	strlcat(identity_file, ".pub", sizeof(identity_file));
	if ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)
		fatal("Unable to save public key to %s: %s",
		    identity_file, strerror(errno));
	if ((f = fdopen(fd, "w")) == NULL)
		fatal("fdopen %s failed: %s", identity_file, strerror(errno));
	if ((r = sshkey_write(public, f)) != 0)
		error("write key failed: %s", ssh_err(r));
	fprintf(f, " %s\n", comment);
	fclose(f);

	if (!quiet) {
		fp = sshkey_fingerprint(public, fingerprint_hash,
		    SSH_FP_DEFAULT);
		ra = sshkey_fingerprint(public, fingerprint_hash,
		    SSH_FP_RANDOMART);
		if (fp == NULL || ra == NULL)
			fatal("sshkey_fingerprint failed");
		printf("Your public key has been saved in %s.\n",
		    identity_file);
		printf("The key fingerprint is:\n");
		printf("%s %s\n", fp, comment);
		printf("The key's randomart image is:\n");
		printf("%s\n", ra);
		free(ra);
		free(fp);
	}

	sshkey_free(public);
	exit(0);
}
@


1.303
log
@Refuse RSA keys <1024 bits in length. Improve reporting for keys that
do not meet this requirement. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.302 2017/04/30 23:18:44 djm Exp $ */
d481 1
a481 1
		fatal("key_new_private failed");
d759 1
a759 1
		error("key_write failed: %s", ssh_err(r));
d1006 1
a1006 1
			error("key_generate failed: %s", ssh_err(r));
d1462 1
a1462 1
		fatal("key_from_private failed: %s", ssh_err(r));
d1649 1
a1649 1
			fatal("key_from_private (ca key): %s", ssh_err(r));
d1967 1
a1967 1
			fatal("key_new");
d2114 1
a2114 1
				fatal("key_new");
d2652 1
a2652 1
		fatal("key_generate failed");
d2654 1
a2654 1
		fatal("key_from_private failed: %s\n", ssh_err(r));
@


1.302
log
@remove KEY_RSA1

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.301 2017/04/30 23:10:43 djm Exp $ */
d223 15
a237 7
	if (type == KEY_DSA && *bitsp != 1024)
		fatal("DSA keys must be 1024 bits");
	else if (type != KEY_ECDSA && type != KEY_ED25519 && *bitsp < 1024)
		fatal("Key must at least be 1024 bits");
	else if (type == KEY_ECDSA && sshkey_ecdsa_bits_to_nid(*bitsp) == -1)
		fatal("Invalid ECDSA key length - valid lengths are "
		    "256, 384 or 521 bits");
@


1.301
log
@unifdef WITH_SSH1
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.300 2017/04/29 04:12:25 djm Exp $ */
a242 3
		case KEY_RSA1:
			name = _PATH_SSH_CLIENT_IDENTITY;
			break;
a311 2
	if (k->type == KEY_RSA1)
		fatal("version 1 keys are not supported");
a332 1
	case KEY_RSA1:
a354 1
	case KEY_RSA1:
a806 7
	if ((ret = sshkey_new(KEY_RSA1)) == NULL)
		fatal("sshkey_new failed");
	/* Try RSA1 */
	if ((r = sshkey_read(ret, cpp)) == 0)
		return ret;
	/* Try modern */
	sshkey_free(ret);
d1415 2
a1416 3
	if (private->type != KEY_RSA1 && private->type != KEY_ED25519 &&
	    !use_new_format) {
		error("Comments are only supported for RSA1 or keys stored in "
a2214 2
# define RSA1_USAGE ""

d2219 1
a2219 1
	    "usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa%s]\n"
d2227 1
a2227 1
	    "       ssh-keygen -B [-f input_keyfile]\n", RSA1_USAGE);
@


1.300
log
@allow ssh-keygen to include arbitrary string or flag certificate
extensions and critical options. ok markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.299 2017/03/10 04:26:06 djm Exp $ */
a975 3
#ifdef WITH_SSH1
		{ "rsa1", "RSA1", _PATH_HOST_KEY_FILE },
#endif /* WITH_SSH1 */
a2229 3
#ifdef WITH_SSH1
# define RSA1_USAGE " | rsa1"
#else
a2230 1
#endif
@


1.299
log
@ensure hostname is lower-case before hashing it; bz#2591 reported by
Griff Miller II; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.298 2017/03/06 02:03:20 dtucker Exp $ */
d146 9
d1527 2
d1551 11
d1798 2
a1799 1
	char *val;
d1839 12
@


1.298
log
@Check l->hosts before dereferencing; fixes potential null pointer deref.
ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.297 2017/03/06 00:44:51 dtucker Exp $ */
d1095 1
@


1.297
log
@linenum is unsigned long so use %lu in log formats.  ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.296 2017/03/03 06:13:11 djm Exp $ */
d1071 1
a1071 1
	int was_hashed = l->hosts[0] == HASH_DELIM;
@


1.296
log
@fix ssh-keygen -H accidentally corrupting known_hosts that contained
already-hashed entries. HKF_MATCH_HOST_HASHED is only set by
hostkeys_foreach() when hostname matching is in use, so we need to look
for the hash marker explicitly.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.295 2017/02/17 02:32:05 dtucker Exp $ */
d1083 1
a1083 1
				logit("%s:%ld: ignoring host name "
d1105 1
a1105 1
		logit("%s:%ld: invalid line", l->path, l->linenum);
d1139 1
a1139 1
					printf("# Host %s found: line %ld\n",
d1146 1
a1146 1
				printf("# Host %s found: line %ld %s\n",
d1166 1
a1166 1
			logit("%s:%ld: invalid line", l->path, l->linenum);
@


1.295
log
@Do not show rsa1 key type in usage when compiled without SSH1 support.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.294 2017/02/10 03:36:40 djm Exp $ */
d1071 1
d1080 1
a1080 2
		if ((l->match & HKF_MATCH_HOST_HASHED) != 0 ||
		    has_wild || l->marker != MRK_NONE) {
@


1.294
log
@Sanitise escape sequences in key comments sent to printf but preserve
valid UTF-8 when the locale supports it; bz#2520 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.293 2017/02/08 20:32:43 millert Exp $ */
d2197 6
d2207 1
a2207 1
	    "usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa | rsa1]\n"
d2215 1
a2215 1
	    "       ssh-keygen -B [-f input_keyfile]\n");
@


1.293
log
@Avoid printf %s NULL.  From semarie@@, OK djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.292 2016/09/12 03:29:16 dtucker Exp $ */
d31 1
d51 1
d834 1
a834 1
	printf("%u %s %s (%s)\n", sshkey_size(public), fp,
d1155 1
a1155 1
				printf("%s %s %s %s\n", ctx->host,
d1306 1
a1306 1
		printf("Key has comment '%s'\n", comment);
d2267 2
@


1.292
log
@Spaces->tabs.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.291 2016/09/12 03:25:20 dtucker Exp $ */
d1428 4
a1431 1
	printf("Key now has comment '%s'\n", comment);
@


1.291
log
@Style whitespace fix.  Also happens to remove a no-op diff with portable.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.290 2016/05/02 09:36:42 djm Exp $ */
d2439 1
a2439 1
                        break;
d2442 1
a2442 1
                        break;
@


1.290
log
@support SHA256 and SHA512 RSA signatures in certificates;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.289 2016/05/02 08:49:03 djm Exp $ */
d203 1
a203 2
		}
		else
@


1.289
log
@fix signed/unsigned errors reported by clang-3.7; add
sshbuf_dup_string() to replace a common idiom of
strdup(sshbuf_ptr()) with better safety checking;
feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.288 2016/02/15 09:47:49 dtucker Exp $ */
d1587 6
d1634 2
a1635 2
		if (sshkey_certify(public, ca) != 0)
			fatal("Couldn't not certify key %s", tmp);
@


1.288
log
@Add a function to enable security-related malloc_options.  With and ok
deraadt@@, something similar has been in the snaps for a while.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.287 2015/12/11 03:19:09 djm Exp $ */
d873 1
a873 1
	long int lnum = 0;
d936 1
a936 1
			debug("%s:%ld: not a public key", path, lnum);
d1908 1
a1908 1
	long int lnum = 0;
@


1.287
log
@use SSH_MAX_PUBKEY_BYTES consistently as buffer size when reading key
files. Increase it to match the size of the buffers already being used.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.286 2015/12/11 02:31:47 mmcc Exp $ */
d2251 1
@


1.286
log
@Remove NULL-checks before sshkey_free().

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.285 2015/12/04 16:41:28 markus Exp $ */
d870 1
a870 1
	char *comment = NULL, *cp, *ep, line[16*1024];
d1906 1
a1906 1
	char *cp, line[2048];
@


1.285
log
@implement SHA2-{256,512} for RSASSA-PKCS1-v1_5 signatures (user and host auth)
based on draft-rsa-dsa-sha2-256-03.txt and draft-ssh-ext-info-04.txt;
with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.284 2015/11/28 06:50:52 deraadt Exp $ */
d2155 1
a2155 2
	if (ca != NULL)
		sshkey_free(ca);
@


1.284
log
@do not leak temp file if there is no known_hosts file
from craig leres, ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.283 2015/11/20 23:04:01 halex Exp $ */
d517 1
a517 1
	if (sshkey_sign(key, &sig, &slen, data, sizeof(data), 0) != 0 ||
@


1.283
log
@allow comment change for all supported formats

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.282 2015/11/19 01:12:32 djm Exp $ */
d1219 3
a1221 1
	    name, NULL, foreach_options)) != 0)
d1223 1
@


1.282
log
@trailing whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.281 2015/11/19 01:08:55 djm Exp $ */
d1417 5
a1421 3
	/* XXX what about new-format keys? */
	if (private->type != KEY_RSA1) {
		error("Comments are only supported for RSA1 keys.");
@


1.281
log
@move the certificate validity formatting code to sshkey.[ch]
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.280 2015/11/18 08:37:28 djm Exp $ */
d1643 1
a1643 1
			sshkey_format_cert_validity(public->cert, 
d1646 1
a1646 1
			    "valid %s", sshkey_cert_type(public), 
d1685 1
a1685 1
	 * POSIX strptime says "The application shall ensure that there 
@


1.280
log
@fix "ssh-keygen -l" of private key, broken in support for
multiple plain keys on stdin
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.279 2015/11/16 22:53:07 djm Exp $ */
a1474 38
static const char *
fmt_validity(u_int64_t valid_from, u_int64_t valid_to)
{
	char from[32], to[32];
	static char ret[64];
	time_t tt;
	struct tm *tm;

	*from = *to = '\0';
	if (valid_from == 0 && valid_to == 0xffffffffffffffffULL)
		return "forever";

	if (valid_from != 0) {
		/* XXX revisit INT_MAX in 2038 :) */
		tt = valid_from > INT_MAX ? INT_MAX : valid_from;
		tm = localtime(&tt);
		strftime(from, sizeof(from), "%Y-%m-%dT%H:%M:%S", tm);
	}
	if (valid_to != 0xffffffffffffffffULL) {
		/* XXX revisit INT_MAX in 2038 :) */
		tt = valid_to > INT_MAX ? INT_MAX : valid_to;
		tm = localtime(&tt);
		strftime(to, sizeof(to), "%Y-%m-%dT%H:%M:%S", tm);
	}

	if (valid_from == 0) {
		snprintf(ret, sizeof(ret), "before %s", to);
		return ret;
	}
	if (valid_to == 0xffffffffffffffffULL) {
		snprintf(ret, sizeof(ret), "after %s", from);
		return ret;
	}

	snprintf(ret, sizeof(ret), "from %s to %s", from, to);
	return ret;
}

d1568 1
a1568 1
	char *otmp, *tmp, *cp, *out, *comment, **plist = NULL;
d1643 2
d1651 1
a1651 1
			    fmt_validity(cert_valid_from, cert_valid_to));
d1851 1
a1851 1
	char *key_fp, *ca_fp;
d1859 1
d1868 1
a1868 2
	printf("        Valid: %s\n",
	    fmt_validity(key->cert->valid_after, key->cert->valid_before));
@


1.279
log
@Allow fingerprinting from standard input "ssh-keygen -lf -"

Support fingerprinting multiple plain keys in a file and authorized_keys
files too (bz#1319)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.278 2015/11/13 04:34:15 djm Exp $ */
d851 9
a859 2
	if ((r = sshkey_load_public(path, &public, &comment)) != 0)
		fatal("Error loading public key \"%s\": %s", path, ssh_err(r));
d904 1
a904 1
		    strstr(cp, "SSH PRIVATE KEY") != NULL) {
@


1.278
log
@support multiple certificates (one per line) and reading from
standard input (using "-f -") for "ssh-keygen -L";
ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.277 2015/08/19 23:17:51 djm Exp $ */
d798 22
d821 1
a821 1
do_fingerprint(struct passwd *pw)
d823 1
a823 4
	FILE *f;
	struct sshkey *public;
	char *comment = NULL, *cp, *ep, line[16*1024], *fp, *ra;
	int r, i, skip = 0, num = 0, invalid = 1;
a825 1
	struct stat st;
d829 39
d870 1
a870 25
	if (stat(identity_file, &st) < 0)
		fatal("%s: %s", identity_file, strerror(errno));
	if ((r = sshkey_load_public(identity_file, &public, &comment)) != 0)
		debug2("Error loading public key \"%s\": %s",
		    identity_file, ssh_err(r));
	else {
		fp = sshkey_fingerprint(public, fptype, rep);
		ra = sshkey_fingerprint(public, fingerprint_hash,
		    SSH_FP_RANDOMART);
		if (fp == NULL || ra == NULL)
			fatal("%s: sshkey_fingerprint fail", __func__);
		printf("%u %s %s (%s)\n", sshkey_size(public), fp, comment,
		    sshkey_type(public));
		if (log_level >= SYSLOG_LEVEL_VERBOSE)
			printf("%s\n", ra);
		sshkey_free(public);
		free(comment);
		free(ra);
		free(fp);
		exit(0);
	}
	if (comment) {
		free(comment);
		comment = NULL;
	}
d872 13
a884 2
	if ((f = fopen(identity_file, "r")) == NULL)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));
d886 40
a925 6
	while (fgets(line, sizeof(line), f)) {
		if ((cp = strchr(line, '\n')) == NULL) {
			error("line %d too long: %.40s...",
			    num + 1, line);
			skip = 1;
			continue;
d927 3
a929 3
		num++;
		if (skip) {
			skip = 0;
a931 1
		*cp = '\0';
d933 2
a934 2
		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
d936 1
a936 5
		if (!*cp || *cp == '\n' || *cp == '#')
			continue;
		i = strtol(cp, &ep, 10);
		if (i == 0 || ep == NULL || (*ep != ' ' && *ep != '\t')) {
			int quoted = 0;
d938 2
a939 36
			for (; *cp && (quoted || (*cp != ' ' &&
			    *cp != '\t')); cp++) {
				if (*cp == '\\' && cp[1] == '"')
					cp++;	/* Skip both */
				else if (*cp == '"')
					quoted = !quoted;
			}
			if (!*cp)
				continue;
			*cp++ = '\0';
		}
		ep = cp;
		if ((public = sshkey_new(KEY_RSA1)) == NULL)
			fatal("sshkey_new failed");
		if ((r = sshkey_read(public, &cp)) != 0) {
			cp = ep;
			sshkey_free(public);
			if ((public = sshkey_new(KEY_UNSPEC)) == NULL)
				fatal("sshkey_new failed");
			if ((r = sshkey_read(public, &cp)) != 0) {
				sshkey_free(public);
				continue;
			}
		}
		comment = *cp ? cp : comment;
		fp = sshkey_fingerprint(public, fptype, rep);
		ra = sshkey_fingerprint(public, fingerprint_hash,
		    SSH_FP_RANDOMART);
		if (fp == NULL || ra == NULL)
			fatal("%s: sshkey_fingerprint fail", __func__);
		printf("%u %s %s (%s)\n", sshkey_size(public), fp,
		    comment ? comment : "no comment", sshkey_type(public));
		if (log_level >= SYSLOG_LEVEL_VERBOSE)
			printf("%s\n", ra);
		free(ra);
		free(fp);
d941 1
a941 1
		invalid = 0;
d946 1
a946 1
		fatal("%s is not a public key file.", identity_file);
@


1.277
log
@fixed unlink([uninitialised memory]) reported by Mateusz Kocielski;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.276 2015/07/03 03:49:45 djm Exp $ */
d1839 1
a1839 1
do_show_cert(struct passwd *pw)
a1840 2
	struct sshkey *key;
	struct stat st;
a1842 11
	int r;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));
	if ((r = sshkey_load_public(identity_file, &key, NULL)) != 0)
		fatal("Cannot load public key \"%s\": %s",
		    identity_file, ssh_err(r));
	if (!sshkey_is_cert(key))
		fatal("%s is not a certificate", identity_file);
a1849 1
	printf("%s:\n", identity_file);
d1882 54
a1935 1
	exit(0);
@


1.276
log
@refuse to generate or accept RSA keys smaller than 1024 bits;
feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.275 2015/07/03 03:43:18 djm Exp $ */
d1189 2
a1190 1
		unlink(tmp);
@


1.275
log
@delete support for legacy v00 certificates; "sure" markus@@ dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.274 2015/05/28 07:37:31 djm Exp $ */
d215 2
a216 2
	else if (type != KEY_ECDSA && type != KEY_ED25519 && *bitsp < 768)
		fatal("Key must at least be 768 bits");
@


1.274
log
@wrap all moduli-related code in #ifdef WITH_OPENSSL.
based on patch from Reuben Hawkins; bz#2388
feedback and ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.273 2015/05/28 04:40:13 djm Exp $ */
a236 1
		case KEY_DSA_CERT_V00:
a244 1
		case KEY_RSA_CERT_V00:
a1560 19
	int v00 = 0; /* legacy keys */

	if (key_type_name != NULL) {
		switch (sshkey_type_from_name(key_type_name)) {
		case KEY_RSA_CERT_V00:
		case KEY_DSA_CERT_V00:
			v00 = 1;
			break;
		case KEY_UNSPEC:
			if (strcasecmp(key_type_name, "v00") == 0) {
				v00 = 1;
				break;
			} else if (strcasecmp(key_type_name, "v01") == 0)
				break;
			/* FALLTHROUGH */
		default:
			fatal("unknown key type %s", key_type_name);
		}
	}
d1597 1
a1597 1
		if ((r = sshkey_to_certified(public, v00)) != 0)
d1607 3
a1609 9
		if (v00) {
			prepare_options_buf(public->cert->critical,
			    OPTIONS_CRITICAL|OPTIONS_EXTENSIONS);
		} else {
			prepare_options_buf(public->cert->critical,
			    OPTIONS_CRITICAL);
			prepare_options_buf(public->cert->extensions,
			    OPTIONS_EXTENSIONS);
		}
d1794 1
a1794 1
show_options(struct sshbuf *optbuf, int v00, int in_critical)
d1809 1
a1809 1
		if ((v00 || !in_critical) && 
d1816 1
a1816 1
		else if ((v00 || in_critical) &&
d1843 1
a1843 1
	u_int i, v00;
a1854 1
	v00 = key->type == KEY_RSA_CERT_V00 || key->type == KEY_DSA_CERT_V00;
d1869 1
a1869 4
	if (!v00) {
		printf("        Serial: %llu\n",
		    (unsigned long long)key->cert->serial);
	}
d1886 1
a1886 1
		show_options(key->cert->critical, v00, 1);
d1888 6
a1893 8
	if (!v00) {
		printf("        Extensions: ");
		if (sshbuf_len(key->cert->extensions) == 0)
			printf("(none)\n");
		else {
			printf("\n");
			show_options(key->cert->extensions, v00, 0);
		}
@


1.273
log
@make ssh-keygen default to ed25519 keys when compiled without
OpenSSL; bz#2388, ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.272 2015/05/21 12:01:19 djm Exp $ */
d177 1
d182 1
d2188 1
d2192 1
d2210 1
a2210 2
	char *checkpoint = NULL;
	char out_file[PATH_MAX], *rr_hostname = NULL, *ep, *fp, *ra;
d2215 6
a2222 1
	int gen_all_hostkeys = 0, gen_krl = 0, update_krl = 0, check_krl = 0;
d2225 1
a2225 2
	FILE *f;
	const char *errstr;
a2271 6
		case 'J':
			lines_to_process = strtoul(optarg, NULL, 10);
                        break;
		case 'j':
			start_lineno = strtoul(optarg, NULL, 10);
                        break;
d2313 2
a2314 2
			if (strlcpy(identity_file, optarg, sizeof(identity_file)) >=
			    sizeof(identity_file))
a2385 7
		case 'W':
			generator_wanted = (u_int32_t)strtonum(optarg, 1,
			    UINT_MAX, &errstr);
			if (errstr)
				fatal("Desired generator has bad value: %s (%s)",
					optarg, errstr);
			break;
d2392 9
a2400 4
		case 'M':
			memory = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr)
				fatal("Memory limit is %s: %s", errstr, optarg);
d2402 2
d2410 6
a2415 6
		case 'T':
			do_screen_candidates = 1;
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
			break;
d2421 6
d2432 5
a2436 2
		case 'V':
			parse_cert_times(optarg);
d2438 6
a2443 6
		case 'z':
			errno = 0;
			cert_serial = strtoull(optarg, &ep, 10);
			if (*optarg < '0' || *optarg > '9' || *ep != '\0' ||
			    (errno == ERANGE && cert_serial == ULLONG_MAX))
				fatal("Invalid serial number \"%s\"", optarg);
d2445 1
d2535 1
d2575 1
@


1.272
log
@Support "ssh-keygen -lF hostname" to find search known_hosts and
print key hashes. Already advertised by ssh-keygen(1), but not
delivered by code; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.271 2015/04/27 01:52:30 djm Exp $ */
d55 6
d2570 1
a2570 1
		key_type_name = "rsa";
@


1.271
log
@fix compilation with OPENSSL=no; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.270 2015/04/24 01:36:01 deraadt Exp $ */
d1066 6
d1100 6
a1105 1
			else
d1126 1
d1163 2
d1167 1
a1167 1
	    name, NULL, find_host ? HKF_WANT_MATCH : 0)) != 0)
@


1.270
log
@rename xrealloc() to xreallocarray() since it follows that form.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.269 2015/04/17 13:19:22 djm Exp $ */
d179 1
d181 1
d186 1
d197 1
d200 1
a204 1
#ifdef WITH_OPENSSL
@


1.269
log
@use error/logit/fatal instead of fprintf(stderr, ...) and exit(0),
fix a few errors that were being printed to stdout instead of stderr
and a few non-errors that were going to stderr instead of stdout
bz#2325; ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.268 2015/03/31 11:06:49 tobias Exp $ */
d1575 1
a1575 1
				plist = xrealloc(plist, n + 1, sizeof(*plist));
@


1.268
log
@Comments are only supported for RSA1 keys. If a user tried to add one and
entered his passphrase, explicitly clear it before exit. This is done in
all other error paths, too.

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.267 2015/03/23 06:06:38 djm Exp $ */
d181 2
a182 4
	if (type == KEY_UNSPEC) {
		fprintf(stderr, "unknown key type %s\n", key_type_name);
		exit(1);
	}
d198 2
a199 4
	if (*bitsp > maxbits) {
		fprintf(stderr, "key bits exceeds maximum %d\n", maxbits);
		exit(1);
	}
d243 1
a243 3
			fprintf(stderr, "bad key type\n");
			exit(1);
			break;
d246 4
a249 2
	snprintf(identity_file, sizeof(identity_file), "%s/%s", pw->pw_dir, name);
	fprintf(stderr, "%s (%s): ", prompt, identity_file);
d295 4
a298 8
	if (k->type == KEY_RSA1) {
		fprintf(stderr, "version 1 keys are not supported\n");
		exit(1);
	}
	if ((r = sshkey_to_blob(k, &blob, &len)) != 0) {
		fprintf(stderr, "key_to_blob failed: %s\n", ssh_err(r));
		exit(1);
	}
d525 2
a526 4
		if (pos >= len - 1) {
			fprintf(stderr, "input line too long.\n");
			exit(1);
		}
d530 2
a531 4
			if (c != EOF && c != '\n' && ungetc(c, fp) == EOF) {
				fprintf(stderr, "unget: %s\n", strerror(errno));
				exit(1);
			}
d583 2
a584 4
	if (blen < 0) {
		fprintf(stderr, "uudecode failed.\n");
		exit(1);
	}
d587 2
a588 4
	else if ((r = sshkey_from_blob(blob, blen, k)) != 0) {
		fprintf(stderr, "decode blob failed: %s\n", ssh_err(r));
		exit(1);
	}
d718 2
a719 4
	if (!ok) {
		fprintf(stderr, "key write failed\n");
		exit(1);
	}
d734 2
a735 4
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
d738 1
a738 1
		fprintf(stderr, "key_write failed: %s", ssh_err(r));
d803 2
a804 4
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
d896 2
a897 4
	if (invalid) {
		printf("%s is not a public key file.\n", identity_file);
		exit(1);
	}
d932 1
a932 1
			printf("Could not stat %s: %s", key_types[i].path,
d949 1
a949 2
			fprintf(stderr, "key_generate failed: %s\n",
			    ssh_err(r));
d959 2
a960 2
			printf("Saving key \"%s\" failed: %s\n", identity_file,
			    ssh_err(r));
d970 1
a970 1
			printf("Could not save your public key in %s\n",
d978 1
a978 1
			printf("fdopen %s failed\n", identity_file);
d985 1
a985 1
			fprintf(stderr, "write key failed: %s\n", ssh_err(r));
d1026 2
a1027 2
				fprintf(stderr, "%s:%ld: ignoring host name "
				    "with wildcard: %.64s\n", l->path,
d1048 1
a1048 1
		fprintf(stderr, "%s:%ld: invalid line\n", l->path, l->linenum);
d1098 1
a1098 2
			fprintf(stderr, "%s:%ld: invalid line\n",
			    l->path, l->linenum);
d1156 1
a1156 2
		fprintf(stderr, "%s is not a valid known_hosts file.\n",
		    identity_file);
d1158 2
a1159 2
			fprintf(stderr, "Not replacing existing known_hosts "
			    "file because of errors\n");
d1164 1
a1164 2
		fprintf(stderr, "Host %s not found in %s\n",
		    name, identity_file);
d1182 2
a1183 2
		fprintf(stderr, "%s updated.\n", identity_file);
		fprintf(stderr, "Original contents retained as %s\n", old);
d1185 3
a1187 4
			fprintf(stderr, "WARNING: %s contains unhashed "
			    "entries\n", old);
			fprintf(stderr, "Delete this file to ensure privacy "
			    "of hostnames\n");
d1209 2
a1210 4
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
d1228 1
a1228 3
		fprintf(stderr, "Failed to load key \"%s\": %s\n",
		    identity_file, ssh_err(r));
		exit(1);
d1261 1
a1261 1
		printf("Saving key \"%s\" failed: %s.\n",
d1295 1
a1295 2
		perror(fname);
		exit(1);
d1297 2
a1298 2
	if ((r = sshkey_load_public(fname, &public, &comment)) != 0) {
		printf("Failed to read v2 public key from \"%s\": %s.\n",
a1299 2
		exit(1);
	}
d1321 2
a1322 4
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
d1326 2
a1327 2
	else if (r != SSH_ERR_KEY_WRONG_PASSPHRASE) {
		printf("Cannot load private key \"%s\": %s.\n",
d1329 1
a1329 2
		exit(1);
	} else {
d1342 1
a1342 1
			printf("Cannot load private key \"%s\": %s.\n",
a1343 1
			exit(1);
d1346 1
d1348 1
a1348 1
		fprintf(stderr, "Comments are only supported for RSA1 keys.\n");
d1371 1
a1371 1
		printf("Saving key \"%s\" failed: %s\n",
d1387 2
a1388 4
	if (fd == -1) {
		printf("Could not save your public key in %s\n", identity_file);
		exit(1);
	}
d1390 2
a1391 4
	if (f == NULL) {
		printf("fdopen %s failed\n", identity_file);
		exit(1);
	}
d1393 1
a1393 1
		fprintf(stderr, "write key failed: %s\n", ssh_err(r));
d1553 1
a1553 2
			fprintf(stderr, "unknown key type %s\n", key_type_name);
			exit(1);
d2207 4
a2210 8
	if (!pw) {
		printf("No user exists for uid %lu\n", (u_long)getuid());
		exit(1);
	}
	if (gethostname(hostname, sizeof(hostname)) < 0) {
		perror("gethostname");
		exit(1);
	}
d2425 1
a2425 1
			printf("Too few arguments.\n");
d2429 1
a2429 1
		printf("Too many arguments.\n");
d2433 1
a2433 1
		printf("Can only have one of -p and -c.\n");
d2437 1
a2437 1
		printf("Cannot use -l with -H or -R.\n");
d2481 2
a2482 4
			if (n == 0) {
				perror(identity_file);
				exit(1);
			}
d2554 4
a2557 8
	if ((r = sshkey_generate(type, bits, &private)) != 0) {
		fprintf(stderr, "key_generate failed\n");
		exit(1);
	}
	if ((r = sshkey_from_private(private, &public)) != 0) {
		fprintf(stderr, "key_from_private failed: %s\n", ssh_err(r));
		exit(1);
	}
d2627 1
a2627 1
		printf("Saving key \"%s\" failed: %s\n",
d2644 5
a2648 10
	fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
		printf("Could not save your public key in %s\n", identity_file);
		exit(1);
	}
	f = fdopen(fd, "w");
	if (f == NULL) {
		printf("fdopen %s failed\n", identity_file);
		exit(1);
	}
d2650 1
a2650 1
		fprintf(stderr, "write key failed: %s\n", ssh_err(r));
@


1.267
log
@for ssh-keygen -A, don't try (and fail) to generate
ssh v.1 keys when compiled without SSH1 support
RSA/DSA/ECDSA keys when compiled without OpenSSL
based on patch by Mike Frysinger; bz#2369
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.266 2015/02/26 20:45:47 djm Exp $ */
d1388 1
@


1.266
log
@don't printf NULL key comments; reported by Tom Christensen
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.265 2015/02/24 15:24:05 naddy Exp $ */
d933 2
d936 1
d940 1
@


1.265
log
@add -v (show ASCII art) to -l's synopsis; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.264 2015/02/23 22:21:21 djm Exp $ */
d1259 2
a1260 1
	printf("Key has comment '%s'\n", comment);
@


1.264
log
@further silence spurious error message even when -v is specified
(e.g. to get visual host keys); reported by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.263 2015/02/23 16:55:31 djm Exp $ */
d2189 1
a2189 1
	    "       ssh-keygen -l [-E fingerprint_hash] [-f input_keyfile]\n"
@


1.263
log
@silence a spurious error message when listing fingerprints for
known_hosts; bz#2342
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.262 2015/02/16 22:08:57 djm Exp $ */
d828 1
a828 1
		debug("Error loading public key \"%s\": %s",
@


1.262
log
@Refactor hostkeys_foreach() and dependent code
Deal with IP addresses (i.e. CheckHostIP)
Don't clobber known_hosts when nothing changed
ok markus@@ as part of larger commit
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.261 2015/01/30 01:10:33 djm Exp $ */
d828 1
a828 1
		error("Error loading public key \"%s\": %s",
@


1.261
log
@permit KRLs that revoke certificates by serial number or key ID
without scoping to a particular CA; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.260 2015/01/30 00:59:19 djm Exp $ */
d1036 32
a1067 2
	/* Retain invalid lines when hashing, but mark file as invalid. */
	if (l->status == HKF_STATUS_INVALID) {
d1070 2
d1075 2
a1076 27

	/*
	 * Don't hash hosts already already hashed, with wildcard characters
	 * or a CA/revocation marker.
	 */
	if (l->was_hashed || has_wild || l->marker != MRK_NONE) {
		fprintf(ctx->out, "%s\n", l->line);
		if (has_wild && !find_host) {
			fprintf(stderr, "%s:%ld: ignoring host name "
			    "with wildcard: %.64s\n", l->path,
			    l->linenum, l->hosts);
		}
		return 0;
	}
	/*
	 * Split any comma-separated hostnames from the host list,
	 * hash and store separately.
	 */
	ohosts = hosts = xstrdup(l->hosts);
	while ((cp = strsep(&hosts, ",")) != NULL && *cp != '\0') {
		if ((hashed = host_hash(cp, NULL, 0)) == NULL)
			fatal("hash_host failed");
		fprintf(ctx->out, "%s %s\n", hashed, l->rawkey);
		ctx->has_unhashed = 1;
	}
	free(ohosts);
	return 0;
d1084 1
a1084 1
	if (l->status == HKF_STATUS_HOST_MATCHED) {
d1171 1
a1171 1
	    name, find_host ? HKF_WANT_MATCH_HOST : 0)) != 0)
@


1.260
log
@missing parentheses after if in do_convert_from() broke
private key conversion from other formats some time in 2010;
bz#2345 reported by jjelen AT redhat.com
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.259 2015/01/28 22:36:00 djm Exp $ */
d1958 1
a1958 1
update_krl_from_file(struct passwd *pw, const char *file,
d2000 1
a2000 1
			if (ca == NULL) {
d2037 1
a2037 1
			if (ca == NULL) {
d2088 1
a2088 1
	int fd, i, r;
d2102 9
a2110 5
		tmp = tilde_expand_filename(ca_key_path, pw->pw_uid);
		if ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)
			fatal("Cannot load CA public key %s: %s",
			    tmp, ssh_err(r));
		free(tmp);
d2124 1
a2124 1
		update_krl_from_file(pw, argv[i], ca, krl);
@


1.259
log
@update to new API (key_fingerprint => sshkey_fingerprint)
check sshkey_fingerprint return values;
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.258 2015/01/19 00:32:54 deraadt Exp $ */
d709 1
a709 1
	if (!private)
d714 1
a714 1
	else {
@


1.258
log
@djm, your /usr/include tree is old
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.257 2015/01/18 21:51:19 djm Exp $ */
d786 2
d834 2
d905 2
d1892 2
d2210 1
a2210 1
	char out_file[PATH_MAX], *rr_hostname = NULL, *ep;
d2697 1
a2697 1
		char *fp = sshkey_fingerprint(public, fingerprint_hash,
d2699 1
a2699 1
		char *ra = sshkey_fingerprint(public, fingerprint_hash,
d2701 2
@


1.257
log
@some feedback from markus@@: comment hostkeys_foreach()
context and avoid a member in it.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.256 2015/01/18 21:49:42 djm Exp $ */
d1117 1
a1117 1
	char *cp, tmp[MAXPATHLEN], old[MAXPATHLEN];
@


1.256
log
@make ssh-keygen use hostkeys_foreach(). Removes some
horrendous code; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.255 2015/01/18 13:22:28 djm Exp $ */
d1016 5
a1020 3
	FILE *out;
	const char *host;
	int has_unhashed, found_key, inplace, invalid;
a1047 1
			ctx->has_unhashed = 1;
d1118 1
a1118 1
	int r, fd, oerrno;
d1152 1
a1152 1
		ctx.inplace = 1;
d1161 1
a1161 1
	if (ctx.inplace)
d1167 1
a1167 1
		if (ctx.inplace) {
d1177 1
a1177 1
	} else if (ctx.inplace) {
@


1.255
log
@infer key length correctly when user specified a fully-
qualified key name instead of using the -b bits option;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.254 2015/01/16 15:55:07 djm Exp $ */
d1015 8
a1022 3
static void
printhost(FILE *f, const char *name, struct sshkey *public,
    int ca, int revoked, int hash)
d1024 11
a1034 19
	if (print_fingerprint) {
		enum sshkey_fp_rep rep;
		int fptype;
		char *fp, *ra;

		fptype = print_bubblebabble ?
		    SSH_DIGEST_SHA1 : fingerprint_hash;
		rep = print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;
		fp = sshkey_fingerprint(public, fptype, rep);
		ra = sshkey_fingerprint(public, fingerprint_hash,
		    SSH_FP_RANDOMART);
		printf("%u %s %s (%s)\n", sshkey_size(public), fp, name,
		    sshkey_type(public));
		if (log_level >= SYSLOG_LEVEL_VERBOSE)
			printf("%s\n", ra);
		free(ra);
		free(fp);
	} else {
		int r;
d1036 21
a1056 1
		if (hash && (name = host_hash(name, NULL, 0)) == NULL)
d1058 51
a1108 5
		fprintf(f, "%s%s%s ", ca ? CA_MARKER " " : "",
		    revoked ? REVOKE_MARKER " " : "" , name);
		if ((r = sshkey_write(public, f)) != 0)
			fatal("key_write failed: %s", ssh_err(r));
		fprintf(f, "\n");
d1110 1
d1116 3
a1118 7
	FILE *in, *out = stdout;
	struct sshkey *pub;
	char *cp, *cp2, *kp, *kp2;
	char line[16*1024], tmp[PATH_MAX], old[PATH_MAX];
	int c, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;
	int r, ca, revoked;
	int found_key = 0;
a1127 2
	if ((in = fopen(identity_file, "r")) == NULL)
		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));
d1129 4
a1132 1
	/* XXX this code is a mess; refactor -djm */
d1144 1
a1144 1
		if ((c = mkstemp(tmp)) == -1)
d1146 2
a1147 2
		if ((out = fdopen(c, "w")) == NULL) {
			c = errno;
d1149 1
a1149 1
			fatal("fdopen: %s", strerror(c));
d1151 1
a1151 1
		inplace = 1;
d1154 5
a1158 67
	while (fgets(line, sizeof(line), in)) {
		if ((cp = strchr(line, '\n')) == NULL) {
			error("line %d too long: %.40s...", num + 1, line);
			skip = 1;
			invalid = 1;
			continue;
		}
		num++;
		if (skip) {
			skip = 0;
			continue;
		}
		*cp = '\0';

		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#') {
			if (inplace)
				fprintf(out, "%s\n", cp);
			continue;
		}
		/* Check whether this is a CA key or revocation marker */
		if (strncasecmp(cp, CA_MARKER, sizeof(CA_MARKER) - 1) == 0 &&
		    (cp[sizeof(CA_MARKER) - 1] == ' ' ||
		    cp[sizeof(CA_MARKER) - 1] == '\t')) {
			ca = 1;
			cp += sizeof(CA_MARKER);
		} else
			ca = 0;
		if (strncasecmp(cp, REVOKE_MARKER,
		    sizeof(REVOKE_MARKER) - 1) == 0 &&
		    (cp[sizeof(REVOKE_MARKER) - 1] == ' ' ||
		    cp[sizeof(REVOKE_MARKER) - 1] == '\t')) {
			revoked = 1;
			cp += sizeof(REVOKE_MARKER);
		} else
			revoked = 0;

		/* Find the end of the host name portion. */
		for (kp = cp; *kp && *kp != ' ' && *kp != '\t'; kp++)
			;

		if (*kp == '\0' || *(kp + 1) == '\0') {
			error("line %d missing key: %.40s...",
			    num, line);
			invalid = 1;
			continue;
		}
		*kp++ = '\0';
		kp2 = kp;

		if ((pub = sshkey_new(KEY_RSA1)) == NULL)
			fatal("sshkey_new failed");
		if ((r = sshkey_read(pub, &kp)) != 0) {
			kp = kp2;
			sshkey_free(pub);
			if ((pub = sshkey_new(KEY_UNSPEC)) == NULL)
				fatal("sshkey_new failed");
			if ((r = sshkey_read(pub, &kp)) != 0) {
				error("line %d invalid key: %.40s...",
				    num, line);
				sshkey_free(pub);
				invalid = 1;
				continue;
			}
		}
d1160 2
a1161 84
		if (*cp == HASH_DELIM) {
			if (find_host || delete_host) {
				cp2 = host_hash(name, cp, strlen(cp));
				if (cp2 == NULL) {
					error("line %d: invalid hashed "
					    "name: %.64s...", num, line);
					invalid = 1;
					continue;
				}
				c = (strcmp(cp2, cp) == 0);
				if (find_host && c) {
					if (!quiet)
						printf("# Host %s found: "
						    "line %d type %s%s\n", name,
						    num, sshkey_type(pub),
						    ca ? " (CA key)" :
						    revoked? " (revoked)" : "");
					printhost(out, cp, pub, ca, revoked, 0);
					found_key = 1;
				}
				if (delete_host) {
					if (!c || ca || revoked) {
						printhost(out, cp, pub,
						    ca, revoked, 0);
					} else {
						printf("# Host %s found: "
						    "line %d type %s\n", name,
						    num, sshkey_type(pub));
					}
				}
			} else if (hash_hosts)
				printhost(out, cp, pub, ca, revoked, 0);
		} else {
			if (find_host || delete_host) {
				c = (match_hostname(name, cp,
				    strlen(cp)) == 1);
				if (find_host && c) {
					if (!quiet)
						printf("# Host %s found: "
						    "line %d type %s%s\n", name,
						    num, sshkey_type(pub),
						    ca ? " (CA key)" : "");
					printhost(out, name, pub, ca, revoked,
					    hash_hosts && !(ca || revoked));
					found_key = 1;
				}
				if (delete_host) {
					if (!c || ca || revoked) {
						printhost(out, cp, pub,
						    ca, revoked, 0);
					} else {
						printf("# Host %s found: "
						    "line %d type %s\n", name,
						    num, sshkey_type(pub));
					}
				}
			} else if (hash_hosts && (ca || revoked)) {
				/* Don't hash CA and revoked keys' hostnames */
				printhost(out, cp, pub, ca, revoked, 0);
				has_unhashed = 1;
			} else if (hash_hosts) {
				/* Hash each hostname separately */
				for (cp2 = strsep(&cp, ",");
				    cp2 != NULL && *cp2 != '\0';
				    cp2 = strsep(&cp, ",")) {
					if (strcspn(cp2, "*?!") !=
					    strlen(cp2)) {
						fprintf(stderr, "Warning: "
						    "ignoring host name with "
						    "metacharacters: %.64s\n",
						    cp2);
						printhost(out, cp2, pub, ca,
						    revoked, 0);
						has_unhashed = 1;
					} else {
						printhost(out, cp2, pub, ca,
						    revoked, 1);
					}
				}
			}
		}
		sshkey_free(pub);
	}
	fclose(in);
d1163 1
a1163 1
	if (invalid) {
d1166 1
a1166 1
		if (inplace) {
a1168 1
			fclose(out);
d1172 5
a1176 5
	}

	if (inplace) {
		fclose(out);

d1194 1
a1194 1
		if (has_unhashed) {
d1202 1
a1202 1
	exit (find_host && !found_key);
@


1.254
log
@regression: incorrect error message on otherwise-successful
ssh-keygen -A. Reported by Dmitry Orlov, via deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.253 2015/01/16 06:40:12 deraadt Exp $ */
d177 1
a177 1
type_bits_valid(int type, u_int32_t *bitsp)
d179 1
a179 1
	u_int maxbits;
d188 7
a194 2
		else if (type == KEY_ECDSA)
			*bitsp = DEFAULT_BITS_ECDSA;
d961 1
a961 1
		type_bits_valid(type, &bits);
d2657 1
a2657 1
	type_bits_valid(type, &bits);
@


1.253
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.252 2015/01/15 09:40:00 djm Exp $ */
d994 2
a995 2
		if (!sshkey_write(public, f)) {
			fprintf(stderr, "write key failed\n");
@


1.252
log
@sync ssh-keysign, ssh-keygen and some dependencies to the new
buffer/key API; mostly mechanical, ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.251 2014/12/21 22:27:56 djm Exp $ */
a17 1
#include <sys/param.h>
d30 1
d1050 1
a1050 1
	char line[16*1024], tmp[MAXPATHLEN], old[MAXPATHLEN];
d2278 1
a2278 1
	char dotsshdir[MAXPATHLEN], comment[1024], *passphrase1, *passphrase2;
d2280 1
a2280 1
	char out_file[MAXPATHLEN], *rr_hostname = NULL, *ep;
d2493 1
a2493 1
			if (strlen(optarg) >= MAXPATHLEN)
@


1.251
log
@Add FingerprintHash option to control algorithm used for key
fingerprints. Default changes from MD5 to SHA256 and format
from hex to base64.

Feedback and ok naddy@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.250 2014/08/21 01:08:52 doug Exp $ */
d33 1
a33 1
#include "key.h"
d37 1
a37 1
#include "buffer.h"
d46 1
d204 1
a204 1
	else if (type == KEY_ECDSA && key_ecdsa_bits_to_nid(*bitsp) == -1)
d219 1
a219 1
		switch (key_type_from_name(key_type_name)) {
d257 1
a257 1
static Key *
d261 2
a262 1
	Key *prv;
d264 13
a276 11
	prv = key_load_private(filename, "", NULL);
	if (prv == NULL) {
		if (identity_passphrase)
			pass = xstrdup(identity_passphrase);
		else
			pass = read_passphrase("Enter passphrase: ",
			    RP_ALLOW_STDIN);
		prv = key_load_private(filename, pass, NULL);
		explicit_bzero(pass, strlen(pass));
		free(pass);
	}
d287 1
a287 1
do_convert_to_ssh2(struct passwd *pw, Key *k)
d289 1
a289 1
	u_int len;
d292 1
d298 2
a299 2
	if (key_to_blob(k, &blob, &len) <= 0) {
		fprintf(stderr, "key_to_blob failed\n");
d305 1
a305 1
	    key_size(k), key_type(k),
d312 1
a312 1
	key_free(k);
d318 1
a318 1
do_convert_to_pkcs8(Key *k)
d320 1
a320 1
	switch (key_type_plain(k->type)) {
d335 1
a335 1
		fatal("%s: unsupported key type %s", __func__, key_type(k));
d341 1
a341 1
do_convert_to_pem(Key *k)
d343 1
a343 1
	switch (key_type_plain(k->type)) {
d357 1
a357 1
		fatal("%s: unsupported key type %s", __func__, key_type(k));
d365 1
a365 1
	Key *k;
d367 1
d373 2
a374 7
	if ((k = key_load_public(identity_file, NULL)) == NULL) {
		if ((k = load_identity(identity_file)) == NULL) {
			fprintf(stderr, "load failed\n");
			exit(1);
		}
	}

d391 4
d396 1
a396 1
buffer_get_bignum_bits(Buffer *b, BIGNUM *value)
d398 2
a399 2
	u_int bignum_bits = buffer_get_int(b);
	u_int bytes = (bignum_bits + 7) / 8;
d401 10
a410 6
	if (buffer_len(b) < bytes)
		fatal("buffer_get_bignum_bits: input buffer too small: "
		    "need %d have %d", bytes, buffer_len(b));
	if (BN_bin2bn(buffer_ptr(b), bytes, value) == NULL)
		fatal("buffer_get_bignum_bits: BN_bin2bn failed");
	buffer_consume(b, bytes);
d413 1
a413 1
static Key *
d416 2
a417 2
	Buffer b;
	Key *key = NULL;
d419 4
a422 3
	u_char *sig = NULL, data[] = "abcde12345";
	int magic, rlen, ktype, i1, i2, i3, i4;
	u_int slen;
d425 4
a428 2
	buffer_init(&b);
	buffer_append(&b, blob, blen);
a429 1
	magic = buffer_get_int(&b);
d431 3
a433 2
		error("bad magic 0x%x != 0x%x", magic, SSH_COM_PRIVATE_KEY_MAGIC);
		buffer_free(&b);
d436 7
a442 6
	i1 = buffer_get_int(&b);
	type   = buffer_get_string(&b, NULL);
	cipher = buffer_get_string(&b, NULL);
	i2 = buffer_get_int(&b);
	i3 = buffer_get_int(&b);
	i4 = buffer_get_int(&b);
d447 1
a447 1
		buffer_free(&b);
d458 1
a458 1
		buffer_free(&b);
d462 2
a463 1
	key = key_new_private(ktype);
d468 5
a472 5
		buffer_get_bignum_bits(&b, key->dsa->p);
		buffer_get_bignum_bits(&b, key->dsa->g);
		buffer_get_bignum_bits(&b, key->dsa->q);
		buffer_get_bignum_bits(&b, key->dsa->pub_key);
		buffer_get_bignum_bits(&b, key->dsa->priv_key);
d475 5
a479 1
		e = buffer_get_char(&b);
d483 1
a483 1
			e += buffer_get_char(&b);
d486 1
a486 1
			e += buffer_get_char(&b);
d490 2
a491 2
			buffer_free(&b);
			key_free(key);
d494 7
a500 8
		buffer_get_bignum_bits(&b, key->rsa->d);
		buffer_get_bignum_bits(&b, key->rsa->n);
		buffer_get_bignum_bits(&b, key->rsa->iqmp);
		buffer_get_bignum_bits(&b, key->rsa->q);
		buffer_get_bignum_bits(&b, key->rsa->p);
		if (rsa_generate_additional_parameters(key->rsa) != 0)
			fatal("%s: rsa_generate_additional_parameters "
			    "error", __func__);
d503 1
a503 1
	rlen = buffer_len(&b);
d507 1
a507 1
	buffer_free(&b);
d510 6
a515 2
	key_sign(key, &sig, &slen, data, sizeof(data));
	key_verify(key, sig, slen, data, sizeof(data));
d551 1
a551 1
do_convert_from_ssh2(struct passwd *pw, Key **k, int *private)
d553 1
a553 1
	int blen;
a557 1
	int escaped = 0;
d594 4
a597 5
	*k = *private ?
	    do_convert_private_ssh2_from_blob(blob, blen) :
	    key_from_blob(blob, blen);
	if (*k == NULL) {
		fprintf(stderr, "decode blob failed.\n");
d604 1
a604 1
do_convert_from_pkcs8(Key **k, int *private)
d618 2
a619 1
		*k = key_new(KEY_UNSPEC);
d624 2
a625 1
		*k = key_new(KEY_UNSPEC);
d630 2
a631 1
		*k = key_new(KEY_UNSPEC);
d634 1
a634 1
		(*k)->ecdsa_nid = key_ecdsa_key_to_nid((*k)->ecdsa);
d645 1
a645 1
do_convert_from_pem(Key **k, int *private)
d656 2
a657 1
		*k = key_new(KEY_UNSPEC);
d666 2
a667 1
		*k = key_new(KEY_UNSPEC);
d681 2
a682 2
	Key *k = NULL;
	int private = 0, ok = 0;
d705 2
a706 1
		ok = key_write(k, stdout);
d725 1
a725 1
			    key_type(k));
d733 1
a733 1
	key_free(k);
d741 1
a741 1
	Key *prv;
d743 1
d752 3
a754 7
	if (prv == NULL) {
		fprintf(stderr, "load failed\n");
		exit(1);
	}
	if (!key_write(prv, stdout))
		fprintf(stderr, "key_write failed");
	key_free(prv);
d763 1
a763 1
	Key **keys = NULL;
d765 1
a765 1
	enum fp_rep rep;
d778 2
a779 2
			fp = key_fingerprint(keys[i], fptype, rep);
			ra = key_fingerprint(keys[i], fingerprint_hash,
d781 2
a782 2
			printf("%u %s %s (PKCS11 key)\n", key_size(keys[i]),
			    fp, key_type(keys[i]));
d788 1
a788 1
			key_write(keys[i], stdout);
d791 1
a791 1
		key_free(keys[i]);
d805 1
a805 1
	Key *public;
d807 2
a808 2
	int i, skip = 0, num = 0, invalid = 1;
	enum fp_rep rep;
d820 6
a825 4
	public = key_load_public(identity_file, &comment);
	if (public != NULL) {
		fp = key_fingerprint(public, fptype, rep);
		ra = key_fingerprint(public, fingerprint_hash,
d827 2
a828 2
		printf("%u %s %s (%s)\n", key_size(public), fp, comment,
		    key_type(public));
d831 1
a831 1
		key_free(public);
d880 3
a882 2
		public = key_new(KEY_RSA1);
		if (key_read(public, &cp) != 1) {
d884 5
a888 4
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (key_read(public, &cp) != 1) {
				key_free(public);
d893 2
a894 2
		fp = key_fingerprint(public, fptype, rep);
		ra = key_fingerprint(public, fingerprint_hash,
d896 2
a897 2
		printf("%u %s %s (%s)\n", key_size(public), fp,
		    comment ? comment : "no comment", key_type(public));
d902 1
a902 1
		key_free(public);
d932 1
a932 1
	Key *private, *public;
d934 1
a934 1
	int i, type, fd;
d953 1
a953 1
		type = key_type_from_name(key_types[i].key_type);
d957 3
a959 3
		private = key_generate(type, bits);
		if (private == NULL) {
			fprintf(stderr, "key_generate failed\n");
d963 2
a964 1
		public  = key_from_private(private);
d967 6
a972 5
		if (!key_save_private(private, identity_file, "", comment,
		    use_new_format, new_format_cipher, rounds)) {
			printf("Saving the key failed: %s.\n", identity_file);
			key_free(private);
			key_free(public);
d976 1
a976 1
		key_free(private);
d982 1
a982 1
			key_free(public);
d990 1
a990 1
			key_free(public);
d994 1
a994 1
		if (!key_write(public, f)) {
d997 1
a997 1
			key_free(public);
d1003 1
a1003 1
		key_free(public);
d1011 2
a1012 1
printhost(FILE *f, const char *name, Key *public, int ca, int revoked, int hash)
d1015 1
a1015 1
		enum fp_rep rep;
d1022 2
a1023 2
		fp = key_fingerprint(public, fptype, rep);
		ra = key_fingerprint(public, fingerprint_hash,
d1025 2
a1026 2
		printf("%u %s %s (%s)\n", key_size(public), fp, name,
		    key_type(public));
d1032 2
d1038 2
a1039 2
		if (!key_write(public, f))
			fatal("key_write failed");
d1048 1
a1048 1
	Key *pub;
d1052 1
a1052 1
	int ca, revoked;
d1122 1
a1122 1
 			revoked = 1;
d1140 3
a1142 2
		pub = key_new(KEY_RSA1);
		if (key_read(pub, &kp) != 1) {
d1144 4
a1147 3
			key_free(pub);
			pub = key_new(KEY_UNSPEC);
			if (key_read(pub, &kp) != 1) {
d1150 1
a1150 1
				key_free(pub);
d1170 1
a1170 1
						    num, key_type(pub),
d1183 1
a1183 1
						    num, key_type(pub));
d1196 1
a1196 1
						    num, key_type(pub),
d1209 1
a1209 1
						    num, key_type(pub));
d1237 1
a1237 1
		key_free(pub);
d1294 2
a1295 1
	Key *private;
d1304 2
a1305 2
	private = key_load_private(identity_file, "", &comment);
	if (private == NULL) {
d1312 2
a1313 2
		private = key_load_private(identity_file, old_passphrase,
		    &comment);
d1316 7
a1322 4
		if (private == NULL) {
			printf("Bad passphrase.\n");
			exit(1);
		}
d1352 4
a1355 3
	if (!key_save_private(private, identity_file, passphrase1, comment,
	    use_new_format, new_format_cipher, rounds)) {
		printf("Saving the key failed: %s.\n", identity_file);
d1358 1
a1358 1
		key_free(private);
d1365 1
a1365 1
	key_free(private);		 /* Destroys contents */
d1378 1
a1378 1
	Key *public;
d1381 1
d1391 4
a1394 6
	public = key_load_public(fname, &comment);
	if (public != NULL) {
		export_dns_rr(hname, public, stdout, print_generic);
		key_free(public);
		free(comment);
		return 1;
d1396 4
a1399 5
	if (comment)
		free(comment);

	printf("failed to read v2 public key from %s.\n", fname);
	exit(1);
d1409 2
a1410 2
	Key *private;
	Key *public;
d1413 1
a1413 1
	int fd;
d1421 8
a1428 2
	private = key_load_private(identity_file, "", &comment);
	if (private == NULL) {
d1437 2
a1438 2
		private = key_load_private(identity_file, passphrase, &comment);
		if (private == NULL) {
d1441 2
a1442 1
			printf("Bad passphrase.\n");
a1444 2
	} else {
		passphrase = xstrdup("");
d1448 1
a1448 1
		key_free(private);
d1460 1
a1460 1
			key_free(private);
d1467 4
a1470 3
	if (!key_save_private(private, identity_file, passphrase, new_comment,
	    use_new_format, new_format_cipher, rounds)) {
		printf("Saving the key failed: %s.\n", identity_file);
d1473 1
a1473 1
		key_free(private);
d1479 3
a1481 2
	public = key_from_private(private);
	key_free(private);
d1494 3
a1496 3
	if (!key_write(public, f))
		fprintf(stderr, "write key failed\n");
	key_free(public);
d1545 1
a1545 1
add_flag_option(Buffer *c, const char *name)
d1547 2
d1550 3
a1552 2
	buffer_put_cstring(c, name);
	buffer_put_string(c, NULL, 0);
d1556 1
a1556 1
add_string_option(Buffer *c, const char *name, const char *value)
d1558 2
a1559 1
	Buffer b;
d1562 6
a1567 5
	buffer_init(&b);
	buffer_put_cstring(&b, value);

	buffer_put_cstring(c, name);
	buffer_put_string(c, buffer_ptr(&b), buffer_len(&b));
d1569 1
a1569 1
	buffer_free(&b);
d1575 1
a1575 1
prepare_options_buf(Buffer *c, int which)
d1577 1
a1577 1
	buffer_clear(c);
d1601 1
a1601 1
static Key *
d1605 2
a1606 2
	Key **keys = NULL, *public, *private = NULL;
	int i, nkeys;
d1608 3
a1610 2
	if ((public = key_load_public(path, NULL)) == NULL)
		fatal("Couldn't load CA public key \"%s\"", path);
d1617 1
a1617 1
		if (key_equal_public(public, keys[i])) {
d1621 1
a1621 1
		key_free(keys[i]);
d1624 1
a1624 1
	key_free(public);
d1634 1
a1634 1
	int i, fd;
d1636 1
a1636 1
	Key *ca, *public;
d1642 1
a1642 1
		switch (key_type_from_name(key_type_name)) {
d1667 2
a1668 2
	} else if ((ca = load_identity(tmp)) == NULL)
		fatal("Couldn't load CA key \"%s\"", tmp);
d1686 3
a1688 2
		if ((public = key_load_public(tmp, &comment)) == NULL)
			fatal("%s: unable to open \"%s\"", __func__, tmp);
d1692 1
a1692 1
			    __func__, tmp, key_type(public));
d1695 3
a1697 2
		if (key_to_certified(public, v00) != 0)
			fatal("Could not upgrade key %s to certificate", tmp);
d1714 3
a1716 1
		public->cert->signature_key = key_from_private(ca);
d1718 1
a1718 1
		if (key_certify(public, ca) != 0)
d1731 3
a1733 2
		if (!key_write(public, f))
			fatal("Could not write certified key to %s", out);
d1739 1
a1739 1
			    "valid %s", key_cert_type(public), 
d1747 1
a1747 1
		key_free(public);
d1898 1
a1898 1
show_options(const Buffer *optbuf, int v00, int in_critical)
d1901 11
a1911 12
	const u_char *data;
	u_int dlen;
	Buffer options, option;

	buffer_init(&options);
	buffer_append(&options, buffer_ptr(optbuf), buffer_len(optbuf));

	buffer_init(&option);
	while (buffer_len(&options) != 0) {
		name = buffer_get_string(&options, NULL);
		data = buffer_get_string_ptr(&options, &dlen);
		buffer_append(&option, data, dlen);
d1923 3
a1925 1
			arg = buffer_get_cstring(&option, NULL);
d1929 3
a1931 3
			printf(" UNKNOWN OPTION (len %u)\n",
			    buffer_len(&option));
			buffer_clear(&option);
d1934 1
a1934 1
		if (buffer_len(&option) != 0)
d1937 2
a1938 2
	buffer_free(&option);
	buffer_free(&options);
d1944 1
a1944 1
	Key *key;
d1948 1
d1954 4
a1957 3
	if ((key = key_load_public(identity_file, NULL)) == NULL)
		fatal("%s is not a public key", identity_file);
	if (!key_is_cert(key))
d1961 2
a1962 2
	key_fp = key_fingerprint(key, fingerprint_hash, SSH_FP_DEFAULT);
	ca_fp = key_fingerprint(key->cert->signature_key,
d1966 3
a1968 3
	printf("        Type: %s %s certificate\n", key_ssh_name(key),
	    key_cert_type(key));
	printf("        Public key: %s %s\n", key_type(key), key_fp);
d1970 1
a1970 1
	    key_type(key->cert->signature_key), ca_fp);
d1988 1
a1988 1
	if (buffer_len(key->cert->critical) == 0)
d1996 1
a1996 1
		if (buffer_len(key->cert->extensions) == 0)
d2010 2
a2011 2
	Buffer krlbuf;
	int fd;
d2013 2
a2014 1
	buffer_init(&krlbuf);
d2017 2
a2018 2
	if (!key_load_file(fd, path, &krlbuf))
		fatal("Unable to load KRL");
d2021 1
a2021 1
	if (ssh_krl_from_blob(&krlbuf, krlp, NULL, 0) != 0 ||
d2023 2
a2024 2
		fatal("Invalid KRL file");
	buffer_free(&krlbuf);
d2028 2
a2029 2
update_krl_from_file(struct passwd *pw, const char *file, const Key *ca,
    struct ssh_krl *krl)
d2031 1
a2031 1
	Key *key = NULL;
d2130 1
a2130 1
			if ((key = key_new(KEY_UNSPEC)) == NULL)
d2132 3
a2134 2
			if (key_read(key, &cp) != 1)
				fatal("%s:%lu: invalid key", path, lnum);
d2142 3
a2144 2
				fatal("%s: revoke key failed", __func__);
			key_free(key);
d2157 2
a2158 2
	Key *ca = NULL;
	int fd, i;
d2160 1
a2160 1
	Buffer kbuf;
d2173 3
a2175 2
		if ((ca = key_load_public(tmp, NULL)) == NULL)
			fatal("Cannot load CA public key %s", tmp);
d2192 3
a2194 2
	buffer_init(&kbuf);
	if (ssh_krl_to_blob(krl, &kbuf, NULL, 0) != 0)
d2198 2
a2199 2
	if (atomicio(vwrite, fd, buffer_ptr(&kbuf), buffer_len(&kbuf)) !=
	    buffer_len(&kbuf))
d2202 1
a2202 1
	buffer_free(&kbuf);
d2205 1
a2205 1
		key_free(ca);
d2214 1
a2214 1
	Key *k;
d2220 3
a2222 2
		if ((k = key_load_public(argv[i], &comment)) == NULL)
			fatal("Cannot load public key %s", argv[i]);
d2229 1
a2229 1
		key_free(k);
d2280 2
a2281 2
	char out_file[MAXPATHLEN], *ep, *rr_hostname = NULL;
	Key *private, *public;
d2284 1
a2284 1
	int opt, type, fd;
d2651 1
a2651 1
	type = key_type_from_name(key_type_name);
d2655 3
a2657 3
		printf("Generating public/private %s key pair.\n", key_type_name);
	private = key_generate(type, bits);
	if (private == NULL) {
d2661 4
a2664 1
	public  = key_from_private(private);
d2732 4
a2735 3
	if (!key_save_private(private, identity_file, passphrase1, comment,
	    use_new_format, new_format_cipher, rounds)) {
		printf("Saving the key failed: %s.\n", identity_file);
d2745 1
a2745 1
	key_free(private);
d2761 2
a2762 2
	if (!key_write(public, f))
		fprintf(stderr, "write key failed\n");
d2767 1
a2767 1
		char *fp = key_fingerprint(public, fingerprint_hash,
d2769 1
a2769 1
		char *ra = key_fingerprint(public, fingerprint_hash,
d2781 1
a2781 1
	key_free(public);
@


1.250
log
@Free resources on error in mkstemp and fdopen

ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.249 2014/07/03 03:47:27 djm Exp $ */
d48 1
d90 3
d744 1
a744 1
	enum fp_type fptype;
d747 2
a748 2
	fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
d757 1
a757 1
			ra = key_fingerprint(keys[i], SSH_FP_MD5,
d787 1
a787 1
	enum fp_type fptype;
d790 2
a791 3
	fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;

d801 2
a802 1
		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
d868 2
a869 1
		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
d987 1
a987 1
		enum fp_type fptype;
d990 3
a992 2
		fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
		rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
d994 2
a995 1
		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
d1904 1
a1904 1
	key_fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
d1906 1
a1906 1
	    SSH_FP_MD5, SSH_FP_HEX);
d2185 1
a2185 1
	    "       ssh-keygen -l [-f input_keyfile]\n"
d2250 1
a2250 1
	/* Remaining characters: EUYdw */
d2252 2
a2253 1
	    "C:D:F:G:I:J:K:M:N:O:P:R:S:T:V:W:Z:a:b:f:g:j:m:n:r:s:t:z:")) != -1) {
d2264 5
d2700 3
a2702 2
		char *fp = key_fingerprint(public, SSH_FP_MD5, SSH_FP_HEX);
		char *ra = key_fingerprint(public, SSH_FP_MD5,
@


1.249
log
@When hashing or removing hosts using ssh-keygen, don't choke on
@@revoked markers and don't remove @@cert-authority markers;
bz#2241, reported by mlindgren AT runelind.net
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.248 2014/07/03 03:34:09 djm Exp $ */
d956 1
d963 1
@


1.248
log
@standardise on NI_MAXHOST for gethostname() string lengths; about
1/2 the cases were using it already. Fixes bz#2239 en passant
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.247 2014/06/24 01:13:21 djm Exp $ */
d976 1
a976 1
printhost(FILE *f, const char *name, Key *public, int ca, int hash)
d996 2
a997 1
		fprintf(f, "%s%s%s ", ca ? CA_MARKER : "", ca ? " " : "", name);
d1012 1
a1012 1
	int ca;
d1026 1
d1070 1
a1070 1
		/* Check whether this is a CA key */
d1078 8
d1129 3
a1131 2
						    ca ? " (CA key)" : "");
					printhost(out, cp, pub, ca, 0);
d1135 4
a1138 3
					if (!c && !ca)
						printhost(out, cp, pub, ca, 0);
					else
d1142 1
d1145 1
a1145 1
				printhost(out, cp, pub, ca, 0);
d1156 2
a1157 2
					printhost(out, name, pub,
					    ca, hash_hosts && !ca);
d1161 4
a1164 3
					if (!c && !ca)
						printhost(out, cp, pub, ca, 0);
					else
d1168 1
d1170 4
d1175 1
d1179 1
a1179 6
					if (ca) {
						fprintf(stderr, "Warning: "
						    "ignoring CA key for host: "
						    "%.64s\n", cp2);
						printhost(out, cp2, pub, ca, 0);
					} else if (strcspn(cp2, "*?!") !=
d1185 7
a1191 3
						printhost(out, cp2, pub, ca, 0);
					} else
						printhost(out, cp2, pub, ca, 1);
a1192 1
				has_unhashed = 1;
@


1.247
log
@New key API: refactor key-related functions to be more library-like,
existing API is offered as a set of wrappers.

with and ok markus@@

Thanks also to Ben Hawkes, David Tomaschik, Ivan Fratric, Matthew
Dempsky and Ron Bowes for a detailed review a few months ago.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.246 2014/04/29 18:01:49 markus Exp $ */
d25 1
d164 1
a164 1
char hostname[MAXHOSTNAMELEN];
@


1.246
log
@make compiling against OpenSSL optional (make OPENSSL=no);
reduces algorithms to curve25519, aes-ctr, chacha, ed25519;
allows us to explore further options; with and ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.245 2014/04/28 03:09:18 djm Exp $ */
d476 3
a478 1
		rsa_generate_additional_parameters(key->rsa);
d1627 1
a1627 1
			prepare_options_buf(&public->cert->critical,
d1630 1
a1630 1
			prepare_options_buf(&public->cert->critical,
d1632 1
a1632 1
			prepare_options_buf(&public->cert->extensions,
d1903 1
a1903 1
	if (buffer_len(&key->cert->critical) == 0)
d1907 1
a1907 1
		show_options(&key->cert->critical, v00, 1);
d1911 1
a1911 1
		if (buffer_len(&key->cert->extensions) == 0)
d1915 1
a1915 1
			show_options(&key->cert->extensions, v00, 0);
@


1.245
log
@buffer_get_string_ptr's return should be const to remind
callers that futzing with it will futz with the actual buffer
contents
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.244 2014/04/20 09:24:26 logan Exp $ */
d193 1
d201 1
d276 1
d704 1
d1581 1
d1583 1
d1666 1
d1668 1
d1919 1
d2142 1
d2442 1
d2451 1
d2469 1
d2474 1
@


1.244
log
@Add support for SSHFP DNS records for ED25519 key types.

OK from djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.243 2014/03/15 17:28:26 deraadt Exp $ */
d1808 2
a1809 2
	char *name;
	u_char *data;
d1832 3
a1834 3
			data = buffer_get_string(&option, NULL);
			printf(" %s\n", data);
			free(data);
@


1.243
log
@Improve usage() and documentation towards the standard form.  In particular,
this line saves a lot of man page reading time.
    usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa | rsa1]
                      [-N new_passphrase] [-C comment] [-f output_keyfile]
ok schwarze jmc
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.242 2014/03/12 04:50:32 djm Exp $ */
d2482 2
a2483 1

@


1.242
log
@don't count on things that accept arguments by reference to clear
things for us on error; most things do, but it's unsafe form.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.241 2014/02/05 20:13:25 naddy Exp $ */
d2137 10
a2146 8
	fprintf(stderr, "usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -A          Generate non-existent host keys for all key types.\n");
	fprintf(stderr, "  -a number   Number of KDF rounds for new key format or moduli primality tests.\n");
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
	fprintf(stderr, "  -b bits     Number of bits in the key to create.\n");
	fprintf(stderr, "  -C comment  Provide new comment.\n");
	fprintf(stderr, "  -c          Change comment in private and public key files.\n");
d2148 2
a2149 1
	fprintf(stderr, "  -D pkcs11   Download public key from pkcs11 token.\n");
d2151 15
a2165 39
	fprintf(stderr, "  -e          Export OpenSSH to foreign format key file.\n");
	fprintf(stderr, "  -F hostname Find hostname in known hosts file.\n");
	fprintf(stderr, "  -f filename Filename of the key file.\n");
	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli.\n");
	fprintf(stderr, "  -g          Use generic DNS resource record format.\n");
	fprintf(stderr, "  -H          Hash names in known_hosts file.\n");
	fprintf(stderr, "  -h          Generate host certificate instead of a user certificate.\n");
	fprintf(stderr, "  -I key_id   Key identifier to include in certificate.\n");
	fprintf(stderr, "  -i          Import foreign format to OpenSSH key file.\n");
	fprintf(stderr, "  -J number   Screen this number of moduli lines.\n");
	fprintf(stderr, "  -j number   Start screening moduli at specified line.\n");
	fprintf(stderr, "  -K checkpt  Write checkpoints to this file.\n");
	fprintf(stderr, "  -k          Generate a KRL file.\n");
	fprintf(stderr, "  -L          Print the contents of a certificate.\n");
	fprintf(stderr, "  -l          Show fingerprint of key file.\n");
	fprintf(stderr, "  -M memory   Amount of memory (MB) to use for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -m key_fmt  Conversion format for -e/-i (PEM|PKCS8|RFC4716).\n");
	fprintf(stderr, "  -N phrase   Provide new passphrase.\n");
	fprintf(stderr, "  -n name,... User/host principal names to include in certificate\n");
	fprintf(stderr, "  -O option   Specify a certificate option.\n");
	fprintf(stderr, "  -o          Enforce new private key format.\n");
	fprintf(stderr, "  -P phrase   Provide old passphrase.\n");
	fprintf(stderr, "  -p          Change passphrase of private key file.\n");
	fprintf(stderr, "  -Q          Test whether key(s) are revoked in KRL.\n");
	fprintf(stderr, "  -q          Quiet.\n");
	fprintf(stderr, "  -R hostname Remove host from known_hosts file.\n");
	fprintf(stderr, "  -r hostname Print DNS resource record.\n");
	fprintf(stderr, "  -S start    Start point (hex) for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -s ca_key   Certify keys with CA key.\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli.\n");
	fprintf(stderr, "  -t type     Specify type of key to create.\n");
	fprintf(stderr, "  -u          Update KRL rather than creating a new one.\n");
	fprintf(stderr, "  -V from:to  Specify certificate validity interval.\n");
	fprintf(stderr, "  -v          Verbose.\n");
	fprintf(stderr, "  -W gen      Generator to use for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -y          Read private key file and print public key.\n");
	fprintf(stderr, "  -Z cipher   Specify a cipher for new private key format.\n");
	fprintf(stderr, "  -z serial   Specify a serial number.\n");

@


1.241
log
@tweak synopsis: calling ssh-keygen without any arguments is fine; ok jmc@@

while here, fix ordering in usage(); requested by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.240 2014/02/02 03:44:31 djm Exp $ */
d402 1
a402 1
	u_char *sig, data[] = "abcde12345";
@


1.240
log
@convert memset of potentially-private data to explicit_bzero()
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.239 2014/01/31 16:39:19 tedu Exp $ */
d2184 1
a2185 1
	fprintf(stderr, "  -Z cipher   Specify a cipher for new private key format.\n");
@


1.239
log
@replace most bzero with explicit_bzero, except a few that cna be memset
ok djm dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.238 2013/12/06 13:39:49 markus Exp $ */
d263 1
a263 1
		memset(pass, 0, strlen(pass));
d1246 1
a1246 1
		memset(old_passphrase, 0, strlen(old_passphrase));
d1268 2
a1269 2
			memset(passphrase1, 0, strlen(passphrase1));
			memset(passphrase2, 0, strlen(passphrase2));
d1276 1
a1276 1
		memset(passphrase2, 0, strlen(passphrase2));
d1284 1
a1284 1
		memset(passphrase1, 0, strlen(passphrase1));
d1291 1
a1291 1
	memset(passphrase1, 0, strlen(passphrase1));
d1363 1
a1363 1
			memset(passphrase, 0, strlen(passphrase));
d1384 1
a1384 1
			memset(passphrase, 0, strlen(passphrase));
d1395 1
a1395 1
		memset(passphrase, 0, strlen(passphrase));
d1401 1
a1401 1
	memset(passphrase, 0, strlen(passphrase));
d2616 2
a2617 2
			memset(passphrase1, 0, strlen(passphrase1));
			memset(passphrase2, 0, strlen(passphrase2));
d2624 1
a2624 1
		memset(passphrase2, 0, strlen(passphrase2));
d2639 1
a2639 1
		memset(passphrase1, 0, strlen(passphrase1));
d2644 1
a2644 1
	memset(passphrase1, 0, strlen(passphrase1));
@


1.238
log
@support ed25519 keys (hostkeys and user identities) using the public domain
ed25519 reference code from SUPERCOP, see http://ed25519.cr.yp.to/software.html
feedback, help & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.237 2013/12/06 13:34:54 markus Exp $ */
d1704 1
a1704 1
	bzero(&tm, sizeof(tm));
@


1.237
log
@new private key format, bcrypt as KDF by default; details in PROTOCOL.key;
feedback and lots help from djm; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.236 2013/12/06 03:40:51 djm Exp $ */
d195 1
a195 1
	else if (type != KEY_ECDSA && *bitsp < 768)
d229 4
d888 1
d1604 1
a1604 1
		    public->type != KEY_ECDSA)
@


1.236
log
@remove duplicated character ('g') in getopt() string;
document the (few) remaining option characters so we don't have to rummage
next time.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.235 2013/10/23 04:16:22 djm Exp $ */
d148 12
d923 2
a924 1
		if (!key_save_private(private, identity_file, "", comment)) {
d1276 2
a1277 1
	if (!key_save_private(private, identity_file, passphrase1, comment)) {
d1387 2
a1388 1
	if (!key_save_private(private, identity_file, passphrase, new_comment)) {
d2135 1
a2135 1
	fprintf(stderr, "  -a trials   Number of trials for screening DH-GEX moduli.\n");
d2163 1
d2180 1
d2198 1
a2198 1
	u_int32_t memory = 0, generator_wanted = 0, trials = 100;
d2226 3
a2228 3
	/* Remaining characters: EUYZdow */
	while ((opt = getopt(argc, argv, "ABHLQXceghiklpquvxy"
	    "C:D:F:G:I:J:K:M:N:O:P:R:S:T:V:W:a:b:f:j:m:n:r:s:t:z:")) != -1) {
d2286 3
d2316 3
d2377 1
a2377 1
			trials = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
d2379 1
a2379 1
				fatal("Invalid number of trials: %s (%s)",
d2538 2
a2539 1
		if (prime_test(in, out, trials, generator_wanted, checkpoint,
d2631 2
a2632 1
	if (!key_save_private(private, identity_file, passphrase1, comment)) {
@


1.235
log
@Make code match documentation: relative-specified certificate expiry time
should be relative to current time and not the validity start time.
Reported by Petr Lautrbach; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.234 2013/09/02 22:00:34 deraadt Exp $ */
d2209 1
d2211 1
a2211 1
	    "C:D:F:G:I:J:K:M:N:O:P:R:S:T:V:W:a:b:f:g:j:m:n:r:s:t:z:")) != -1) {
@


1.234
log
@All the instances of arc4random_stir() are bogus, since arc4random()
does this itself, inside itself, and has for a very long time..  Actually,
this was probably reducing the entropy available.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.233 2013/08/28 12:34:27 mikeb Exp $ */
d1729 1
a1729 1
		cert_valid_to = parse_relative_time(to, cert_valid_from);
@


1.233
log
@improve batch processing a bit by making use of the quite flag a bit
more often and exit with a non zero code if asked to find a hostname
in a known_hosts file and it wasn't there;

originally from reyk@@,  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.232 2013/08/13 18:33:08 djm Exp $ */
a897 1
		arc4random_stir();
a918 1
		arc4random_stir();
a2524 2
	arc4random_stir();

a2617 1
	arc4random_stir();
@


1.232
log
@another of the same typo
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.231 2013/08/13 18:32:08 djm Exp $ */
d989 1
d1092 5
a1096 4
					printf("# Host %s found: "
					    "line %d type %s%s\n", name,
					    num, key_type(pub),
					    ca ? " (CA key)" : "");
d1098 1
d1115 5
a1119 4
					printf("# Host %s found: "
					    "line %d type %s%s\n", name,
					    num, key_type(pub),
					    ca ? " (CA key)" : "");
d1122 1
d1198 1
a1198 1
	exit(0);
@


1.231
log
@typo in error message; from Stephan Rickauer
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.230 2013/07/20 01:44:37 djm Exp $ */
d1988 1
a1988 1
				fatal("revoking certificated by key ID "
@


1.230
log
@More useful error message on missing current user in /etc/passwd
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.229 2013/07/12 05:42:03 djm Exp $ */
d1951 1
a1951 1
				fatal("revoking certificated by serial number "
@


1.229
log
@do_print_resource_record() can never be called with a NULL filename, so
don't attempt (and bungle) asking for one if it has not been specified
bz#2127 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.228 2013/07/12 00:20:00 djm Exp $ */
d2198 1
a2198 1
		printf("You don't exist, go away!\n");
@


1.228
log
@fix pointer-signedness warnings from clang/llvm-3.3; "seems nice" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.227 2013/05/17 00:13:14 djm Exp $ */
d1289 1
a1289 1
		ask_filename(pw, "Enter file in which the key is");
@


1.227
log
@bye, bye xfree(); ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.226 2013/04/19 01:01:00 djm Exp $ */
d518 1
a518 1
		if (line[blen - 1] == '\\')
d1785 2
a1786 1
	u_char *name, *data;
@


1.226
log
@fix some memory leaks; bz#2088 ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.225 2013/02/10 23:32:10 djm Exp $ */
d248 1
a248 1
		xfree(pass);
d284 1
a284 1
	xfree(blob);
d409 1
a409 1
		xfree(cipher);
d411 1
a411 1
		xfree(type);
d414 1
a414 1
	xfree(cipher);
d422 1
a422 1
		xfree(type);
d426 1
a426 1
	xfree(type);
d469 1
a469 1
	xfree(sig);
d736 2
a737 2
			xfree(ra);
			xfree(fp);
d744 1
a744 1
	xfree(keys);
d781 3
a783 3
		xfree(comment);
		xfree(ra);
		xfree(fp);
d787 1
a787 1
		xfree(comment);
d846 2
a847 2
		xfree(ra);
		xfree(fp);
d968 2
a969 2
		xfree(ra);
		xfree(fp);
d995 1
a995 1
		xfree(cp);
d1226 1
a1226 1
		xfree(old_passphrase);
d1249 2
a1250 2
			xfree(passphrase1);
			xfree(passphrase2);
d1256 1
a1256 1
		xfree(passphrase2);
d1263 1
a1263 1
		xfree(passphrase1);
d1265 1
a1265 1
		xfree(comment);
d1270 1
a1270 1
	xfree(passphrase1);
d1272 1
a1272 1
	xfree(comment);
d1300 1
a1300 1
		xfree(comment);
d1304 1
a1304 1
		xfree(comment);
d1342 1
a1342 1
			xfree(passphrase);
d1373 1
a1373 1
		xfree(passphrase);
d1375 1
a1375 1
		xfree(comment);
d1379 1
a1379 1
	xfree(passphrase);
d1400 1
a1400 1
	xfree(comment);
d1517 1
a1517 1
	xfree(keys);
d1561 1
a1561 1
	xfree(tmp);
d1574 1
a1574 1
			xfree(otmp);
d1612 1
a1612 1
		xfree(tmp);
d1635 1
a1635 1
		xfree(out);
d1732 1
a1732 1
	xfree(from);
d1810 1
a1810 1
			xfree(data);
d1816 1
a1816 1
		xfree(name);
d2052 1
a2052 1
		xfree(tmp);
d2586 2
a2587 2
			xfree(passphrase1);
			xfree(passphrase2);
d2593 1
a2593 1
		xfree(passphrase2);
d2607 1
a2607 1
		xfree(passphrase1);
d2612 1
a2612 1
	xfree(passphrase1);
d2647 2
a2648 2
		xfree(ra);
		xfree(fp);
@


1.225
log
@append to moduli file when screening candidates rather than overwriting.
allows resumption of interrupted screen; patch from Christophe Garault
in bz#1957; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.224 2013/01/18 07:59:46 jmc Exp $ */
d2026 1
d2079 2
@


1.224
log
@-u before -V in usage();
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.223 2013/01/17 23:00:01 djm Exp $ */
d2492 1
a2492 1
		FILE *out = fopen(out_file, "w");
@


1.223
log
@add support for Key Revocation Lists (KRLs). These are a compact way to
represent lists of revoked keys and certificates, taking as little as
a single bit of incremental cost to revoke a certificate by serial number.
KRLs are loaded via the existing RevokedKeys sshd_config option.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.222 2013/01/09 05:40:17 djm Exp $ */
d2151 1
a2152 1
	fprintf(stderr, "  -u          Update KRL rather than creating a new one.\n");
@


1.222
log
@correctly initialise fingerprint type for fingerprinting PKCS#11 keys
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.221 2013/01/03 23:22:58 djm Exp $ */
d43 1
d45 2
d1888 220
d2133 1
d2143 1
d2152 1
d2169 1
a2169 1
	char out_file[MAXPATHLEN], *rr_hostname = NULL, *ep;
d2176 1
a2176 1
	int gen_all_hostkeys = 0;
d2202 2
a2203 2
	while ((opt = getopt(argc, argv, "AegiqpclBHLhvxXyF:b:f:t:D:I:J:j:K:P:"
	    "m:N:n:O:C:r:g:R:T:G:M:S:s:a:V:W:z:")) != -1) {
d2282 3
d2303 3
d2323 3
d2401 1
a2401 1
		if (argc < 1) {
d2405 1
a2405 1
	} else if (argc > 0) {
d2416 8
@


1.221
log
@allow fingerprinting of keys hosted in PKCS#11 tokens: ssh-keygen -lD ...
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.220 2012/12/03 00:14:06 djm Exp $ */
d716 3
@


1.220
log
@Fix compilation with -Wall -Werror (trivial type fixes)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.219 2012/11/14 02:32:15 djm Exp $ */
d713 3
d722 14
a735 1
		key_write(keys[i], stdout);
a736 1
		fprintf(stdout, "\n");
d2176 1
a2176 1
		printf("Cannot use -l with -D or -R.\n");
d2188 2
a2226 2
	if (pkcs11provider != NULL)
		do_download(pw);
@


1.219
log
@allow the full range of unsigned serial numbers; 'fine' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.218 2012/10/02 07:07:45 djm Exp $ */
d102 1
a102 1
long long cert_serial = 0;
@


1.218
log
@fix -z option, broken in revision 1.215
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.217 2012/08/17 01:25:58 djm Exp $ */
d1925 1
a1925 1
	char out_file[MAXPATHLEN], *rr_hostname = NULL;
d2129 5
a2133 3
			cert_serial = strtonum(optarg, 0, LLONG_MAX, &errstr);
			if (errstr)
				fatal("Invalid serial number: %s", errstr);
@


1.217
log
@print details of which host lines were deleted when using
"ssh-keygen -R host"; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.216 2012/07/06 06:38:03 jmc Exp $ */
d1959 1
a1959 1
	    "m:N:n:O:C:r:g:R:T:G:M:S:s:a:V:W:z")) != -1) {
@


1.216
log
@missing full stop in usage();
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.215 2012/07/06 00:41:59 dtucker Exp $ */
d1076 8
a1083 2
				if (delete_host && !c && !ca)
					printhost(out, cp, pub, ca, 0);
d1098 8
a1105 2
				if (delete_host && !c && !ca)
					printhost(out, cp, pub, ca, 0);
@


1.215
log
@Add options to specify starting line number and number of lines to process
when screening moduli candidates.  This allows processing of different
parts of a candidate moduli file in parallel.  man page help jmc@@, ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.214 2012/05/23 03:28:28 djm Exp $ */
d1877 1
a1877 1
	fprintf(stderr, "  -J number   Screen this number of moduli lines\n");
@


1.214
log
@add support for RFC6594 SSHFP DNS records for ECDSA key types.
patch from bugzilla-m67 AT nulld.me in bz#1978; ok + tweak markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.213 2012/02/29 11:21:26 djm Exp $ */
d152 2
a153 1
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t, char *);
d1877 2
d1921 1
d1946 2
a1947 2
	while ((opt = getopt(argc, argv, "AegiqpclBHLhvxXyF:b:f:t:D:I:K:P:m:N:n:"
	    "O:C:r:g:R:T:G:M:S:s:a:V:W:z:")) != -1) {
d1968 6
d2232 2
a2233 2
		if (prime_test(in, out, trials, generator_wanted, checkpoint)
		    != 0)
@


1.213
log
@allow conversion of RSA1 keys to public PEM and PKCS8; "nice" markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.212 2011/10/16 15:02:41 jmc Exp $ */
d2178 2
@


1.212
log
@put -K in the right place (usage());
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.211 2011/10/16 11:02:46 dtucker Exp $ */
d261 4
d288 1
d311 1
a343 4
	}
	if (k->type == KEY_RSA1) {
		fprintf(stderr, "version 1 keys are not supported\n");
		exit(1);
@


1.211
log
@Add optional checkpoints for moduli screening.  feedback & ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.210 2011/04/18 00:46:05 djm Exp $ */
a1870 1
	fprintf(stderr, "  -K checkpt  Write checkpoints to this file.\n");
d1874 1
@


1.210
log
@certificate options are supposed to be packed in lexical order of option
name (though we don't actually enforce this at present). Move one up
that was out of sequence
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.209 2011/04/12 04:23:50 djm Exp $ */
d152 1
a152 1
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t);
d1871 1
d1907 1
d1940 1
a1940 1
	while ((opt = getopt(argc, argv, "AegiqpclBHLhvxXyF:b:f:t:D:I:P:m:N:n:"
d2091 5
d2218 2
a2219 1
		if (prime_test(in, out, trials, generator_wanted) != 0)
@


1.209
log
@fix -Wshadow
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.208 2011/03/24 22:14:54 stevesk Exp $ */
d1441 3
a1454 3
	if ((which & OPTIONS_EXTENSIONS) != 0 &&
	    (certflags_flags & CERTOPT_X_FWD) != 0)
		add_flag_option(c, "permit-X11-forwarding");
@


1.208
log
@use strcasecmp() for "clear" cert permission option also; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.207 2011/03/23 16:50:04 stevesk Exp $ */
d155 1
a155 1
type_bits_valid(int type, u_int32_t *bits)
d163 1
a163 1
	if (*bits == 0) {
d165 1
a165 1
			*bits = DEFAULT_BITS_DSA;
d167 1
a167 1
			*bits = DEFAULT_BITS_ECDSA;
d169 1
a169 1
			*bits = DEFAULT_BITS;
d173 1
a173 1
	if (*bits > maxbits) {
d177 1
a177 1
	if (type == KEY_DSA && *bits != 1024)
d179 1
a179 1
	else if (type != KEY_ECDSA && *bits < 768)
d181 1
a181 1
	else if (type == KEY_ECDSA && key_ecdsa_bits_to_nid(*bits) == -1)
@


1.207
log
@remove -d, documentation removed >10 years ago; ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.206 2011/03/23 15:16:22 stevesk Exp $ */
d1704 1
a1704 1
	if (strcmp(opt, "clear") == 0)
@


1.206
log
@Add -A option.  For each of the key types (rsa1, rsa, dsa and ecdsa)
for which host keys do not exist, generate the host keys with the
default key file path, an empty passphrase, default bits for the key
type, and default comment.  This will be used by /etc/rc to generate
new host keys.  Idea from deraadt.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.205 2011/01/11 06:13:10 djm Exp $ */
d1938 1
a1938 1
	while ((opt = getopt(argc, argv, "AdegiqpclBHLhvxXyF:b:f:t:D:I:P:m:N:n:"
a2036 3
			break;
		case 'd':
			key_type_name = "dsa";
@


1.205
log
@some unsigned long long casts that make things a bit easier for
portable without resorting to dropping PRIu64 formats everywhere
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.204 2010/10/28 11:22:09 djm Exp $ */
d155 32
d837 92
d1856 1
a1910 1
	u_int maxbits;
d1913 1
d1938 1
a1938 1
	while ((opt = getopt(argc, argv, "degiqpclBHLhvxXyF:b:f:t:D:I:P:m:N:n:"
d1941 3
d2219 5
d2230 2
a2231 25
	if (type == KEY_UNSPEC) {
		fprintf(stderr, "unknown key type %s\n", key_type_name);
		exit(1);
	}
	if (bits == 0) {
		if (type == KEY_DSA)
			bits = DEFAULT_BITS_DSA;
		else if (type == KEY_ECDSA)
			bits = DEFAULT_BITS_ECDSA;
		else
			bits = DEFAULT_BITS;
	}
	maxbits = (type == KEY_DSA) ?
	    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;
	if (bits > maxbits) {
		fprintf(stderr, "key bits exceeds maximum %d\n", maxbits);
		exit(1);
	}
	if (type == KEY_DSA && bits != 1024)
		fatal("DSA keys must be 1024 bits");
	else if (type != KEY_ECDSA && bits < 768)
		fatal("Key must at least be 768 bits");
	else if (type == KEY_ECDSA && key_ecdsa_bits_to_nid(bits) == -1)
		fatal("Invalid ECDSA key length - valid lengths are "
		    "256, 384 or 521 bits");
@


1.204
log
@fix a possible NULL deref on loading a corrupt ECDH key

store ECDH group information in private keys files as "named groups"
rather than as a set of explicit group parameters (by setting
the OPENSSL_EC_NAMED_CURVE flag). This makes for shorter key files and
retrieves the group's OpenSSL NID that we need for various things.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.203 2010/09/02 17:21:50 naddy Exp $ */
d1467 2
a1468 1
			    out, public->cert->key_id, public->cert->serial,
d1693 4
a1696 2
	if (!v00)
		printf("        Serial: %llu\n", key->cert->serial);
@


1.203
log
@Switch ECDSA default key size to 256 bits, which according to RFC5656
should still be better than our current RSA-2048 default.
ok djm@@, markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.202 2010/09/02 16:07:25 markus Exp $ */
d548 1
a548 2
		(*k)->ecdsa_nid = key_ecdsa_group_to_nid(
		    EC_KEY_get0_group((*k)->ecdsa));
@


1.202
log
@permit -b 256, 384 or 521 as key size for ECDSA; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.201 2010/08/31 12:33:38 djm Exp $ */
d52 1
a52 1
#define DEFAULT_BITS_ECDSA	521
@


1.201
log
@reintroduce commit from tedu@@, which I pulled out for release engineering:

  OpenSSL_add_all_algorithms is the name of the function we have a man page
  for, so use that.  ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.198 2010/08/12 23:34:38 tedu Exp $ */
d1815 1
a1815 1
			bits = (u_int32_t)strtonum(optarg, 768, 32768, &errstr);
d2115 2
@


1.200
log
@Implement Elliptic Curve Cryptography modes for key exchange (ECDH) and
host/user keys (ECDSA) as specified by RFC5656. ECDH and ECDSA offer
better performance than plain DH and DSA at the same equivalent symmetric
key length, as well as much shorter keys.

Only the mandatory sections of RFC5656 are implemented, specifically the
three REQUIRED curves nistp256, nistp384 and nistp521 and only ECDH and
ECDSA. Point compression (optional in RFC5656 is NOT implemented).

Certificate host and user keys using the new ECDSA key types are supported.

Note that this code has not been tested for interoperability and may be
subject to change.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.199 2010/08/16 04:06:06 djm Exp $ */
d1797 1
a1797 1
	SSLeay_add_all_algorithms();
@


1.199
log
@backout previous temporarily; discussed with deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.197 2010/08/04 06:07:11 djm Exp $ */
d52 1
d172 4
d260 4
d284 1
d544 7
d586 1
d627 4
d1421 2
a1422 1
		if (public->type != KEY_RSA && public->type != KEY_DSA)
d2099 8
a2106 2
	if (bits == 0)
		bits = (type == KEY_DSA) ? DEFAULT_BITS_DSA : DEFAULT_BITS;
d2115 3
@


1.198
log
@OpenSSL_add_all_algorithms is the name of the function we have a man page
for, so use that.  ok djm
@
text
@d1774 1
a1774 1
	OpenSSL_add_all_algorithms();
@


1.197
log
@Support CA keys in PKCS#11 tokens; feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.196 2010/08/04 05:40:39 djm Exp $ */
d1774 1
a1774 1
	SSLeay_add_all_algorithms();
@


1.196
log
@tighten the rules for certificate encoding by requiring that options
appear in lexical order and make our ssh-keygen comply. ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.195 2010/07/16 04:45:30 djm Exp $ */
d141 2
d652 1
a652 1
do_download(struct passwd *pw, char *pkcs11provider)
d1315 29
a1353 5
	tmp = tilde_expand_filename(ca_key_path, pw->pw_uid);
	if ((ca = load_identity(tmp)) == NULL)
		fatal("Couldn't load CA key \"%s\"", tmp);
	xfree(tmp);

d1373 9
d1454 1
d1756 1
a1756 2
	char out_file[MAXPATHLEN], *pkcs11provider = NULL;
	char *rr_hostname = NULL;
d2026 1
a2026 1
		do_download(pw, pkcs11provider);
@


1.195
log
@avoid bogus compiler warning
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.194 2010/06/30 07:26:03 jmc Exp $ */
d1290 3
a1292 3
	if ((which & OPTIONS_EXTENSIONS) != 0 &&
	    (certflags_flags & CERTOPT_X_FWD) != 0)
		add_flag_option(c, "permit-X11-forwarding");
d1305 3
a1307 3
	if ((which & OPTIONS_CRITICAL) != 0 &&
	    certflags_command != NULL)
		add_string_option(c, "force-command", certflags_command);
@


1.194
log
@sort usage();
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.193 2010/06/29 23:15:30 djm Exp $ */
d575 1
a575 1
	int private = 0, ok;
@


1.193
log
@allow import (-i) and export (-e) of PEM and PKCS#8 encoded keys;
bz#1749; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.192 2010/06/23 02:59:02 djm Exp $ */
d1690 1
d1692 1
a1692 1
	fprintf(stderr, "  -M memory   Amount of memory (MB) to use for generating DH-GEX moduli.\n");
a1693 1
	fprintf(stderr, "  -N phrase   Provide new passphrase.\n");
d1700 1
a1701 1
	fprintf(stderr, "  -S start    Start point (hex) for generating DH-GEX moduli.\n");
@


1.192
log
@fix printing of extensions in v01 certificates that I broke in r1.190
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.191 2010/06/22 04:32:06 djm Exp $ */
d128 8
a135 3
/* Dump public key file in format used by real and the original SSH 2 */
int convert_to_ssh2 = 0;
int convert_from_ssh2 = 0;
d141 1
d216 1
a216 1
do_convert_to_ssh2(struct passwd *pw)
a217 1
	Key *k;
a220 1
	struct stat st;
a221 16
	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	if ((k = key_load_public(identity_file, NULL)) == NULL) {
		if ((k = load_identity(identity_file)) == NULL) {
			fprintf(stderr, "load failed\n");
			exit(1);
		}
	}
	if (k->type == KEY_RSA1) {
		fprintf(stderr, "version 1 keys are not supported\n");
		exit(1);
	}
d242 75
d454 1
a454 1
do_convert_from_ssh2(struct passwd *pw)
a455 1
	Key *k;
d461 1
a461 2
	struct stat st;
	int escaped = 0, private = 0, ok;
a463 6
	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
d473 1
a473 1
				private = 1;
d498 1
a498 1
	k = private ?
d501 1
a501 1
	if (k == NULL) {
d505 112
a616 5
	ok = private ?
	    (k->type == KEY_DSA ?
		 PEM_write_DSAPrivateKey(stdout, k->dsa, NULL, NULL, 0, NULL, NULL) :
		 PEM_write_RSAPrivateKey(stdout, k->rsa, NULL, NULL, 0, NULL, NULL)) :
	    key_write(k, stdout);
a621 3
	if (!private)
		fprintf(stdout, "\n");
	fclose(fp);
d1679 1
a1679 1
	fprintf(stderr, "  -e          Convert OpenSSH to RFC 4716 key file.\n");
d1687 1
a1687 1
	fprintf(stderr, "  -i          Convert RFC 4716 to OpenSSH key file.\n");
d1690 1
d1753 1
a1753 1
	while ((opt = getopt(argc, argv, "degiqpclBHLhvxXyF:b:f:t:D:I:P:N:n:"
d1785 15
d1836 1
a1836 1
			convert_to_ssh2 = 1;
d1845 1
a1845 1
			convert_from_ssh2 = 1;
d1961 4
a1964 4
	if (convert_to_ssh2)
		do_convert_to_ssh2(pw);
	if (convert_from_ssh2)
		do_convert_from_ssh2(pw);
@


1.191
log
@standardise error messages when attempting to open private key
files to include "progname: filename: error reason"
bz#1783; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.190 2010/05/20 23:46:02 djm Exp $ */
d1405 42
d1452 1
a1452 3
	Buffer options, option;
	u_char *name, *data;
	u_int i, dlen, v00;
d1493 1
a1493 32
		buffer_init(&options);
		buffer_append(&options,
		    buffer_ptr(&key->cert->critical),
		    buffer_len(&key->cert->critical));
		buffer_init(&option);
		while (buffer_len(&options) != 0) {
			name = buffer_get_string(&options, NULL);
			data = buffer_get_string_ptr(&options, &dlen);
			buffer_append(&option, data, dlen);
			printf("                %s", name);
			if (strcmp(name, "permit-X11-forwarding") == 0 ||
			    strcmp(name, "permit-agent-forwarding") == 0 ||
			    strcmp(name, "permit-port-forwarding") == 0 ||
			    strcmp(name, "permit-pty") == 0 ||
			    strcmp(name, "permit-user-rc") == 0)
				printf("\n");
			else if (strcmp(name, "force-command") == 0 ||
			    strcmp(name, "source-address") == 0) {
				data = buffer_get_string(&option, NULL);
				printf(" %s\n", data);
				xfree(data);
			} else {
				printf(" UNKNOWN OPTION (len %u)\n",
				    buffer_len(&option));
				buffer_clear(&option);
			}
			xfree(name);
			if (buffer_len(&option) != 0)
				fatal("Option corrupt: extra data at end");
		}
		buffer_free(&option);
		buffer_free(&options);
d1501 1
a1501 14
			buffer_init(&options);
			buffer_append(&options,
			    buffer_ptr(&key->cert->extensions),
			    buffer_len(&key->cert->extensions));
			buffer_init(&option);
			while (buffer_len(&options) != 0) {
				name = buffer_get_string(&options, NULL);
				(void)buffer_get_string_ptr(&options, &dlen);
				printf("                %s UNKNOWN OPTION "
				    "(len %u)\n", name, dlen);
				xfree(name);
			}
			buffer_free(&option);
			buffer_free(&options);
@


1.190
log
@Move the permit-* options to the non-critical "extensions" field for v01
certificates. The logic is that if another implementation fails to
implement them then the connection just loses features rather than fails
outright.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.189 2010/04/23 22:48:31 djm Exp $ */
d409 2
a410 5
	fp = fopen(identity_file, "r");
	if (fp == NULL) {
		perror(identity_file);
		exit(1);
	}
d553 32
a584 8
	f = fopen(identity_file, "r");
	if (f != NULL) {
		while (fgets(line, sizeof(line), f)) {
			if ((cp = strchr(line, '\n')) == NULL) {
				error("line %d too long: %.40s...",
				    num + 1, line);
				skip = 1;
				continue;
d586 1
a586 3
			num++;
			if (skip) {
				skip = 0;
d588 8
a595 25
			}
			*cp = '\0';

			/* Skip leading whitespace, empty and comment lines. */
			for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
				;
			if (!*cp || *cp == '\n' || *cp == '#')
				continue;
			i = strtol(cp, &ep, 10);
			if (i == 0 || ep == NULL || (*ep != ' ' && *ep != '\t')) {
				int quoted = 0;
				comment = cp;
				for (; *cp && (quoted || (*cp != ' ' &&
				    *cp != '\t')); cp++) {
					if (*cp == '\\' && cp[1] == '"')
						cp++;	/* Skip both */
					else if (*cp == '"')
						quoted = !quoted;
				}
				if (!*cp)
					continue;
				*cp++ = '\0';
			}
			ep = cp;
			public = key_new(KEY_RSA1);
a596 1
				cp = ep;
d598 1
a598 5
				public = key_new(KEY_UNSPEC);
				if (key_read(public, &cp) != 1) {
					key_free(public);
					continue;
				}
a599 11
			comment = *cp ? cp : comment;
			fp = key_fingerprint(public, fptype, rep);
			ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
			printf("%u %s %s (%s)\n", key_size(public), fp,
			    comment ? comment : "no comment", key_type(public));
			if (log_level >= SYSLOG_LEVEL_VERBOSE)
				printf("%s\n", ra);
			xfree(ra);
			xfree(fp);
			key_free(public);
			invalid = 0;
d601 11
a611 1
		fclose(f);
d613 2
d669 1
a669 1
		fatal("fopen: %s", strerror(errno));
d1416 2
a1417 4
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
@


1.189
log
@refuse to generate keys longer than OPENSSL_[RD]SA_MAX_MODULUS_BITS,
since we would refuse to use them anyway. bz#1516; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.188 2010/04/23 01:47:41 djm Exp $ */
d117 10
a126 11
#define CRITOPT_X_FWD	(1)
#define CRITOPT_AGENT_FWD	(1<<1)
#define CRITOPT_PORT_FWD	(1<<2)
#define CRITOPT_PTY		(1<<3)
#define CRITOPT_USER_RC	(1<<4)
#define CRITOPT_DEFAULT	(CRITOPT_X_FWD|CRITOPT_AGENT_FWD| \
				CRITOPT_PORT_FWD|CRITOPT_PTY| \
				CRITOPT_USER_RC)
u_int32_t critical_flags = CRITOPT_DEFAULT;
char *critical_command = NULL;
char *critical_src_addr = NULL;
d1127 2
d1130 1
a1130 1
prepare_options_buf(Buffer *c)
d1133 2
a1134 1
	if ((critical_flags & CRITOPT_X_FWD) != 0)
d1136 2
a1137 1
	if ((critical_flags & CRITOPT_AGENT_FWD) != 0)
d1139 2
a1140 1
	if ((critical_flags & CRITOPT_PORT_FWD) != 0)
d1142 2
a1143 1
	if ((critical_flags & CRITOPT_PTY) != 0)
d1145 2
a1146 1
	if ((critical_flags & CRITOPT_USER_RC) != 0)
d1148 6
a1153 4
	if (critical_command != NULL)
		add_string_option(c, "force-command", critical_command);
	if (critical_src_addr != NULL)
		add_string_option(c, "source-address", critical_src_addr);
d1221 9
a1229 1
		prepare_options_buf(&public->cert->critical);
d1365 1
a1365 1
		critical_flags = 0;
d1367 1
a1367 1
		critical_flags &= ~CRITOPT_X_FWD;
d1369 1
a1369 1
		critical_flags |= CRITOPT_X_FWD;
d1371 1
a1371 1
		critical_flags &= ~CRITOPT_AGENT_FWD;
d1373 1
a1373 1
		critical_flags |= CRITOPT_AGENT_FWD;
d1375 1
a1375 1
		critical_flags &= ~CRITOPT_PORT_FWD;
d1377 1
a1377 1
		critical_flags |= CRITOPT_PORT_FWD;
d1379 1
a1379 1
		critical_flags &= ~CRITOPT_PTY;
d1381 1
a1381 1
		critical_flags |= CRITOPT_PTY;
d1383 1
a1383 1
		critical_flags &= ~CRITOPT_USER_RC;
d1385 1
a1385 1
		critical_flags |= CRITOPT_USER_RC;
d1390 1
a1390 1
		if (critical_command != NULL)
d1392 1
a1392 1
		critical_command = xstrdup(val);
d1397 1
a1397 1
		if (critical_src_addr != NULL)
d1401 1
a1401 1
		critical_src_addr = xstrdup(val);
d1673 1
a1673 1
			critical_flags = 0;
@


1.188
log
@bz#1740: display a more helpful error message when $HOME is
inaccessible while trying to create .ssh directory. Based on patch
from jchadima AT redhat.com; ok dtucker@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.187 2010/04/16 06:47:04 jmc Exp $ */
d1558 1
d1860 6
@


1.187
log
@tweak previous; ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.186 2010/04/16 01:47:26 djm Exp $ */
d1874 13
a1886 7
	snprintf(dotsshdir, sizeof dotsshdir, "%s/%s", pw->pw_dir, _PATH_SSH_USER_DIR);
	if (strstr(identity_file, dotsshdir) != NULL &&
	    stat(dotsshdir, &st) < 0) {
		if (mkdir(dotsshdir, 0700) < 0)
			error("Could not create directory '%s'.", dotsshdir);
		else if (!quiet)
			printf("Created directory '%s'.\n", dotsshdir);
@


1.186
log
@revised certificate format ssh-{dss,rsa}-cert-v01@@openssh.com with the
following changes:

move the nonce field to the beginning of the certificate where it can
better protect against chosen-prefix attacks on the signature hash

Rename "constraints" field to "critical options"

Add a new non-critical "extensions" field

Add a serial number

The older format is still support for authentication and cert generation
(use "ssh-keygen -t v00 -s ca_key ..." to generate a v00 certificate)

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.185 2010/03/15 19:40:02 stevesk Exp $ */
d1526 1
a1526 1
	fprintf(stderr, "  -O cnstr    Specify a certificate option.\n");
d1540 1
@


1.185
log
@also print certificate type (user or host) for ssh-keygen -L
ok djm kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.184 2010/03/07 22:16:01 djm Exp $ */
d100 3
d116 12
a127 12
/* Certificate constraints */
#define CONSTRAINT_X_FWD	(1)
#define CONSTRAINT_AGENT_FWD	(1<<1)
#define CONSTRAINT_PORT_FWD	(1<<2)
#define CONSTRAINT_PTY		(1<<3)
#define CONSTRAINT_USER_RC	(1<<4)
#define CONSTRAINT_DEFAULT	(CONSTRAINT_X_FWD|CONSTRAINT_AGENT_FWD| \
				CONSTRAINT_PORT_FWD|CONSTRAINT_PTY| \
				CONSTRAINT_USER_RC)
u_int32_t constraint_flags = CONSTRAINT_DEFAULT;
char *constraint_command = NULL;
char *constraint_src_addr = NULL;
d159 2
d164 2
d1106 1
a1106 1
add_flag_constraint(Buffer *c, const char *name)
d1114 1
a1114 1
add_string_constraint(Buffer *c, const char *name, const char *value)
d1129 1
a1129 1
prepare_constraint_buf(Buffer *c)
a1130 1

d1132 14
a1145 14
	if ((constraint_flags & CONSTRAINT_X_FWD) != 0)
		add_flag_constraint(c, "permit-X11-forwarding");
	if ((constraint_flags & CONSTRAINT_AGENT_FWD) != 0)
		add_flag_constraint(c, "permit-agent-forwarding");
	if ((constraint_flags & CONSTRAINT_PORT_FWD) != 0)
		add_flag_constraint(c, "permit-port-forwarding");
	if ((constraint_flags & CONSTRAINT_PTY) != 0)
		add_flag_constraint(c, "permit-pty");
	if ((constraint_flags & CONSTRAINT_USER_RC) != 0)
		add_flag_constraint(c, "permit-user-rc");
	if (constraint_command != NULL)
		add_string_constraint(c, "force-command", constraint_command);
	if (constraint_src_addr != NULL)
		add_string_constraint(c, "source-address", constraint_src_addr);
d1156 1
d1163 19
d1204 1
a1204 1
		if (key_to_certified(public) != 0)
d1207 1
d1213 1
a1213 1
		prepare_constraint_buf(&public->cert->constraints);
d1234 4
a1237 4
		if (!quiet)
			logit("Signed %s key %s: id \"%s\"%s%s valid %s",
			    cert_key_type == SSH2_CERT_TYPE_USER?"user":"host",
			    out, cert_key_id,
d1241 1
d1344 1
a1344 1
add_cert_constraint(char *opt)
d1349 1
a1349 1
		constraint_flags = 0;
d1351 1
a1351 1
		constraint_flags &= ~CONSTRAINT_X_FWD;
d1353 1
a1353 1
		constraint_flags |= CONSTRAINT_X_FWD;
d1355 1
a1355 1
		constraint_flags &= ~CONSTRAINT_AGENT_FWD;
d1357 1
a1357 1
		constraint_flags |= CONSTRAINT_AGENT_FWD;
d1359 1
a1359 1
		constraint_flags &= ~CONSTRAINT_PORT_FWD;
d1361 1
a1361 1
		constraint_flags |= CONSTRAINT_PORT_FWD;
d1363 1
a1363 1
		constraint_flags &= ~CONSTRAINT_PTY;
d1365 1
a1365 1
		constraint_flags |= CONSTRAINT_PTY;
d1367 1
a1367 1
		constraint_flags &= ~CONSTRAINT_USER_RC;
d1369 1
a1369 1
		constraint_flags |= CONSTRAINT_USER_RC;
d1373 2
a1374 2
			fatal("Empty force-command constraint");
		if (constraint_command != NULL)
d1376 1
a1376 1
		constraint_command = xstrdup(val);
d1380 2
a1381 2
			fatal("Empty source-address constraint");
		if (constraint_src_addr != NULL)
d1385 1
a1385 1
		constraint_src_addr = xstrdup(val);
d1387 1
a1387 1
		fatal("Unsupported certificate constraint \"%s\"", opt);
d1396 1
a1396 1
	Buffer constraints, constraint;
d1398 1
a1398 1
	u_int i, dlen;
d1410 2
a1411 1
	
d1417 4
a1420 3
	printf("        %s %s certificate %s\n", key_type(key),
	    key_cert_type(key), key_fp);
	printf("        Signed by %s CA %s\n",
d1422 3
a1424 1
	printf("        Key ID \"%s\"\n", key->cert->key_id);
d1436 2
a1437 2
	printf("        Constraints: ");
	if (buffer_len(&key->cert->constraints) == 0)
d1441 9
a1449 9
		buffer_init(&constraints);
		buffer_append(&constraints,
		    buffer_ptr(&key->cert->constraints),
		    buffer_len(&key->cert->constraints));
		buffer_init(&constraint);
		while (buffer_len(&constraints) != 0) {
			name = buffer_get_string(&constraints, NULL);
			data = buffer_get_string_ptr(&constraints, &dlen);
			buffer_append(&constraint, data, dlen);
d1459 1
a1459 1
				data = buffer_get_string(&constraint, NULL);
d1463 3
a1465 3
				printf(" UNKNOWN CONSTRAINT (len %u)\n",
				    buffer_len(&constraint));
				buffer_clear(&constraint);
d1468 26
a1493 2
			if (buffer_len(&constraint) != 0)
				fatal("Constraint corrupt: extra data at end");
a1494 2
		buffer_free(&constraint);
		buffer_free(&constraints);
a1495 1

d1526 1
a1526 1
	fprintf(stderr, "  -O cnstr    Specify a certificate constraint.\n");
d1584 1
a1584 1
	    "O:C:r:g:R:T:G:M:S:s:a:V:W:")) != -1) {
d1640 1
a1640 1
			add_cert_constraint(optarg);
d1655 1
a1655 1
			constraint_flags = 0;
d1704 1
a1704 1
			if (errstr) {
a1705 1
			}
d1726 5
@


1.184
log
@make internal strptime string match strftime format;
suggested by vinschen AT redhat.com and markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.183 2010/03/04 23:27:25 djm Exp $ */
d1388 2
a1389 1
	printf("        %s certificate %s\n", key_type(key), key_fp);
@


1.183
log
@"force-command" is not spelled "forced-command"; spotted by
imorgan AT nas.nasa.gov
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.182 2010/03/04 20:35:08 djm Exp $ */
d1249 2
a1250 2
		fmt = "%Y/%m/%d";
		snprintf(buf, sizeof(buf), "%.4s/%.2s/%.2s", s, s + 4, s + 6);
d1253 2
a1254 2
		fmt = "%Y/%m/%d %H:%M:%S";
		snprintf(buf, sizeof(buf), "%.4s/%.2s/%.2s %.2s:%.2s:%.2s",
@


1.182
log
@Add a -L flag to print the contents of a certificate; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.181 2010/03/04 10:36:03 djm Exp $ */
d1137 1
a1137 1
		add_string_constraint(c, "forced-command", constraint_command);
@


1.181
log
@Add a TrustedUserCAKeys option to sshd_config to specify CA keys that
are trusted to authenticate users (in addition than doing it per-user
in authorized_keys).

Add a RevokedKeys option to sshd_config and a @@revoked marker to
known_hosts to allow keys to me revoked and banned for user or host
authentication.

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.180 2010/03/02 23:20:57 djm Exp $ */
d77 3
d1061 1
a1061 1
fmt_validity(void)
d1069 1
a1069 2
	if (cert_valid_from == 0 &&
	    cert_valid_to == 0xffffffffffffffffULL)
d1072 1
a1072 1
	if (cert_valid_from != 0) {
d1074 1
a1074 1
		tt = cert_valid_from > INT_MAX ? INT_MAX : cert_valid_from;
d1078 1
a1078 1
	if (cert_valid_to != 0xffffffffffffffffULL) {
d1080 1
a1080 1
		tt = cert_valid_to > INT_MAX ? INT_MAX : cert_valid_to;
d1085 1
a1085 1
	if (cert_valid_from == 0) {
d1089 1
a1089 1
	if (cert_valid_to == 0xffffffffffffffffULL) {
d1213 1
a1213 1
			    fmt_validity());
d1363 83
d1467 1
d1529 1
a1529 1
	while ((opt = getopt(argc, argv, "degiqpclBHhvxXyF:b:f:t:D:I:P:N:n:"
d1552 3
d1708 2
@


1.180
log
@POSIX strptime is stricter than OpenBSD's so do a little dance to
appease it.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.179 2010/02/26 20:29:54 djm Exp $ */
d1295 1
a1295 1
		fatal("Invalid certificate life specification %s", optarg);
@


1.179
log
@Add support for certificate key types for users and hosts.

OpenSSH certificate key types are not X.509 certificates, but a much
simpler format that encodes a public key, identity information and
some validity constraints and signs it with a CA key. CA keys are
regular SSH keys. This certificate style avoids the attack surface
of X.509 certificates and is very easy to deploy.

Certified host keys allow automatic acceptance of new host keys
when a CA certificate is marked as trusted in ~/.ssh/known_hosts.
see VERIFYING HOST KEYS in ssh(1) for details.

Certified user keys allow authentication of users when the signing
CA key is marked as trusted in authorized_keys. See "AUTHORIZED_KEYS
FILE FORMAT" in sshd(8) for details.

Certificates are minted using ssh-keygen(1), documentation is in
the "CERTIFICATES" section of that manpage.

Documentation on the format of certificates is in the file
PROTOCOL.certkeys

feedback and ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.178 2010/02/09 00:50:59 djm Exp $ */
d1238 1
d1240 16
a1255 1
	if (strlen(s) != 8 && strlen(s) != 14)
d1257 1
d1260 1
a1260 2
	if (strptime(s,
	    strlen(s) == 8 ? "%Y%m%d" : "%Y%m%d%H%M%S", &tm) == NULL)
@


1.178
log
@fix -Wall
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.177 2010/02/08 10:50:20 markus Exp $ */
d43 1
d94 29
d616 1
a616 1
print_host(FILE *f, const char *name, Key *public, int hash)
d636 1
a636 1
		fprintf(f, "%s ", name);
d647 1
a647 1
	Key *public;
d651 1
d707 9
d719 1
d729 2
a730 2
		public = key_new(KEY_RSA1);
		if (key_read(public, &kp) != 1) {
d732 3
a734 3
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (key_read(public, &kp) != 1) {
d737 1
a737 1
				key_free(public);
d755 4
a758 3
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, cp, public, 0);
d760 2
a761 2
				if (delete_host && !c)
					print_host(out, cp, public, 0);
d763 1
a763 1
				print_host(out, cp, public, 0);
d770 5
a774 4
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, name, public,
					    hash_hosts);
d776 2
a777 2
				if (delete_host && !c)
					print_host(out, cp, public, 0);
d782 7
a788 1
					if (strcspn(cp2, "*?!") != strlen(cp2))
d793 3
a795 2
					else
						print_host(out, cp2, public, 1);
d800 1
a800 1
		key_free(public);
d1057 287
d1363 2
d1368 1
d1370 1
d1376 1
d1380 1
d1427 2
a1428 2
	while ((opt = getopt(argc, argv,
	    "degiqpclBHvxXyF:b:f:t:D:P:N:C:r:g:R:T:G:M:S:a:W:")) != -1) {
d1443 3
d1456 3
d1480 3
d1494 4
d1509 3
d1566 3
d1578 9
a1586 1
	if (optind < argc) {
d1597 5
@


1.177
log
@replace our obsolete smartcard code with PKCS#11.
	ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v2-20/pkcs-11v2-20.pdf
ssh(1) and ssh-keygen(1) use dlopen(3) directly to talk to a PKCS#11
provider (shared library) while ssh-agent(1) delegates PKCS#11 to
a forked a ssh-pkcs11-helper process.
PKCS#11 is currently a compile time option.
feedback and ok djm@@; inspired by patches from Alon Bar-Lev
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.176 2010/01/11 10:51:07 djm Exp $ */
d455 1
a455 1
do_download(struct passwd *pw, const char *pkcs11provider)
@


1.176
log
@when converting keys, truncate key comments at 72 chars as per RFC4716;
bz#1630 reported by tj AT castaglia.org; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.175 2009/08/27 17:33:49 djm Exp $ */
d44 2
a45 2
#ifdef SMARTCARD
#include "scard.h"
a453 1
#ifdef SMARTCARD
d455 1
a455 27
do_upload(struct passwd *pw, const char *sc_reader_id)
{
	Key *prv = NULL;
	struct stat st;
	int ret;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	prv = load_identity(identity_file);
	if (prv == NULL) {
		error("load failed");
		exit(1);
	}
	ret = sc_put_key(prv, sc_reader_id);
	key_free(prv);
	if (ret < 0)
		exit(1);
	logit("loading key done");
	exit(0);
}

static void
do_download(struct passwd *pw, const char *sc_reader_id)
d457 1
d459 1
a459 1
	int i;
d461 5
a465 4
	keys = sc_get_keys(sc_reader_id, NULL);
	if (keys == NULL)
		fatal("cannot read public key from smartcard");
	for (i = 0; keys[i]; i++) {
d471 1
d473 3
a476 1
#endif /* SMARTCARD */
d1017 3
a1019 3
#ifdef SMARTCARD
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
#endif /* SMARTCARD */
a1037 3
#ifdef SMARTCARD
	fprintf(stderr, "  -U reader   Upload private key to smartcard.\n");
#endif /* SMARTCARD */
d1052 1
a1052 1
	char out_file[MAXPATHLEN], *reader_id = NULL;
d1057 1
a1057 1
	int opt, type, fd, download = 0;
d1085 1
a1085 1
	    "degiqpclBHvxXyF:b:f:t:U:D:P:N:C:r:g:R:T:G:M:S:a:W:")) != -1) {
d1157 1
a1157 4
			download = 1;
			/*FALLTHROUGH*/
		case 'U':
			reader_id = optarg;
d1265 2
a1266 10
	if (reader_id != NULL) {
#ifdef SMARTCARD
		if (download)
			do_download(pw, reader_id);
		else
			do_upload(pw, reader_id);
#else /* SMARTCARD */
		fatal("no support for smartcards.");
#endif /* SMARTCARD */
	}
@


1.175
log
@force use of correct hash function for random-art signature display
as it was inheriting the wrong one when bubblebabble signatures were
activated; bz#1611 report and patch from fwojcik+openssh AT besh.com;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.174 2009/06/22 05:39:28 dtucker Exp $ */
d176 1
d199 3
a201 3
	fprintf(stdout, "%s\n", SSH_COM_PUBLIC_BEGIN);
	fprintf(stdout,
	    "Comment: \"%u-bit %s, converted from OpenSSH by %s@@%s\"\n",
d204 3
@


1.174
log
@alphabetize includes; reduces diff vs portable and style(9).  ok stevesk djm
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.173 2009/02/21 19:32:04 tobias Exp $ */
d519 1
a519 1
		ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
d584 1
a584 1
			ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
d614 1
a614 1
		ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
@


1.173
log
@Added missing newlines in error messages.

ok dtucker
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.172 2008/11/07 00:42:12 stevesk Exp $ */
d16 1
a17 1
#include <sys/socket.h>
@


1.172
log
@spelling/typo in comment
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.171 2008/07/13 21:22:52 sthen Exp $ */
d130 1
a130 1
			fprintf(stderr, "bad key type");
d416 1
a416 1
		fprintf(stderr, "key write failed");
d1010 1
a1010 1
		printf("fdopen %s failed", identity_file);
d1014 1
a1014 1
		fprintf(stderr, "write key failed");
d1356 1
a1356 1
		fprintf(stderr, "key_generate failed");
d1446 1
a1446 1
		printf("fdopen %s failed", identity_file);
d1450 1
a1450 1
		fprintf(stderr, "write key failed");
@


1.171
log
@Change "ssh-keygen -F [host] -l" to not display random art unless
-v is also specified, making it consistent with the manual and other
uses of -l.

ok grunk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.170 2008/06/12 21:14:46 grunk Exp $ */
d1416 1
a1416 1
		/* Create default commend field for the passphrase. */
@


1.170
log
@make ssh-keygen -lf show the key type just as ssh-add -l would do it
ok djm@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.169 2008/06/11 22:20:46 grunk Exp $ */
d615 4
a618 2
		printf("%u %s %s (%s)\n%s\n", key_size(public), fp, name,
		    key_type(public), ra);
@


1.169
log
@ssh-keygen would write fingerprints to STDOUT, and random art to STDERR,
that is not how it was envisioned.
Also correct manpage saying that -v is needed along with -l for it to work.

spotted by naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.168 2008/06/11 21:38:25 grunk Exp $ */
d520 2
a521 1
		printf("%u %s %s\n", key_size(public), fp, comment);
d585 2
a586 2
			printf("%u %s %s\n", key_size(public), fp,
			    comment ? comment : "no comment");
d615 2
a616 1
		printf("%u %s %s\n%s\n", key_size(public), fp, name, ra);
@


1.168
log
@ssh-keygen -lv -f /etc/ssh/ssh_host_rsa_key.pub
would not display you the random art as intended, spotted by canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.167 2008/06/11 21:01:35 grunk Exp $ */
d67 2
d521 2
a522 1
		verbose("%s", ra);
d586 2
a587 1
			verbose("%s\n", ra);
a1076 1
	int log_level = SYSLOG_LEVEL_INFO;
@


1.167
log
@Introduce SSH Fingerprint ASCII Visualization, a technique inspired by the
graphical hash visualization schemes known as "random art", and by
Dan Kaminsky's musings on the subject during a BlackOp talk at the
23C3 in Berlin.

Scientific publication (original paper):
"Hash Visualization: a New Technique to improve Real-World Security",
Perrig A. and Song D., 1999, International Workshop on Cryptographic
Techniques and E-Commerce (CrypTEC '99)
http://sparrow.ece.cmu.edu/~adrian/projects/validation/validation.pdf

The algorithm used here is a worm crawling over a discrete plane,
leaving a trace (augmenting the field) everywhere it goes.
Movement is taken from dgst_raw 2bit-wise.  Bumping into walls
makes the respective movement vector be ignored for this turn,
thus switching to the other color of the chessboard.
Graphs are not unambiguous for now, because circles in graphs can be
walked in either direction.

discussions with several people,
help, corrections and ok markus@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.166 2008/05/19 15:46:31 djm Exp $ */
d517 1
a517 1
		ra = key_fingerprint(public, fptype, rep);
d519 1
a519 1
		verbose("%s\n", ra);
@


1.166
log
@support -l (print fingerprint) in combination with -F (find host) to
search for a host in ~/.ssh/known_hosts and display its fingerprint;
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.165 2008/01/19 22:37:19 djm Exp $ */
d499 1
a499 1
	char *comment = NULL, *cp, *ep, line[16*1024], *fp;
d517 1
d519 1
d522 1
d580 1
d583 2
d604 1
a604 1
		char *fp;
d609 3
a611 1
		printf("%u %s %s\n", key_size(public), fp, name);
d1449 2
d1455 3
@


1.165
log
@unbreak line numbering (broken in revision 1.164), fix error message
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.164 2008/01/19 22:22:58 djm Exp $ */
d595 18
a612 6
	if (hash && (name = host_hash(name, NULL, 0)) == NULL)
		fatal("hash_host failed");
	fprintf(f, "%s ", name);
	if (!key_write(public, f))
		fatal("key_write failed");
	fprintf(f, "\n");
d1231 4
@


1.164
log
@when hashing individual hosts (ssh-keygen -Hf hostname), make sure we
hash just the specified hostname and not the entire hostspec from the
keyfile. It may be of the form "hostname,ipaddr", which would lead to
a hash that never matches. report and fix from jp AT devnull.cz
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.163 2007/10/02 17:49:58 chl Exp $ */
d500 1
a500 1
	int i, skip = 0, num = 1, invalid = 1;
d532 2
a533 1
				error("line %d too long: %.40s...", num, line);
d610 1
a610 1
	int c, skip = 0, inplace = 0, num = 1, invalid = 0, has_unhashed = 0;
d646 1
a646 1
			error("line %d too long: %.40s...", num, line);
d745 1
a745 1
		fprintf(stderr, "%s is not a valid known_host file.\n",
@


1.163
log
@handles zero-sized strings that fgets can return
properly removes trailing newline
removes an unused variable
correctly counts line number

"looks ok" ray@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.162 2007/09/11 15:47:17 gilles Exp $ */
d592 1
a592 1
print_host(FILE *f, char *name, Key *public, int hash)
d719 2
a720 1
					print_host(out, cp, public, hash_hosts);
@


1.162
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.161 2007/09/09 11:38:01 sobrado Exp $ */
d531 1
a531 2
			i = strlen(line) - 1;
			if (line[i] != '\n') {
d541 1
a541 1
			line[i] = '\0';
d609 1
a609 1
	int c, i, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;
d644 1
a644 3
		num++;
		i = strlen(line) - 1;
		if (line[i] != '\n') {
d650 1
d655 1
a655 1
		line[i] = '\0';
@


1.161
log
@sort synopsis and options in ssh-agent(1); usage is lowercase

ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.160 2007/01/21 01:41:54 stevesk Exp $ */
d137 1
a137 2
	if (strchr(buf, '\n'))
		*strchr(buf, '\n') = 0;
d957 1
a957 2
		if (strchr(new_comment, '\n'))
			*strchr(new_comment, '\n') = 0;
@


1.160
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.159 2007/01/12 20:20:41 jmc Exp $ */
d1002 1
a1002 1
	fprintf(stderr, "Usage: %s [options]\n", __progname);
@


1.159
log
@more secsh -> rfc 4716 updates;

spotted by wiz@@netbsd
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.158 2007/01/03 03:01:40 stevesk Exp $ */
d237 1
a237 1
	magic  = buffer_get_int(&b);
d280 1
a280 1
		e  = buffer_get_char(&b);
@


1.158
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.157 2007/01/03 00:53:38 stevesk Exp $ */
d1012 1
a1012 1
	fprintf(stderr, "  -e          Convert OpenSSH to IETF SECSH key file.\n");
d1018 1
a1018 1
	fprintf(stderr, "  -i          Convert IETF SECSH to OpenSSH key file.\n");
@


1.157
log
@remove small dead code; arnaud.lacombe.1@@ulaval.ca via Coverity scan
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.156 2006/11/14 19:41:04 deraadt Exp $ */
d249 1
a249 1
	debug("ignore (%d %d %d %d)", i1,i2,i3,i4);
d549 1
a549 1
				continue ;
@


1.156
log
@use argc and argv not some made up short form
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.155 2006/11/06 21:25:28 markus Exp $ */
d342 2
a343 3
	if (c == EOF)
		return -1;
	return pos;
@


1.155
log
@add missing checks for openssl return codes; with & ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.154 2006/08/03 03:34:42 deraadt Exp $ */
d1045 1
a1045 1
main(int ac, char **av)
d1068 1
a1068 1
	log_init(av[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
d1081 1
a1081 1
	while ((opt = getopt(ac, av,
d1214 1
a1214 1
	log_init(av[0], log_level, SYSLOG_FACILITY_USER, 1);
d1216 1
a1216 1
	if (optind < ac) {
@


1.154
log
@almost entirely get rid of the culture of ".h files that include .h files"
ok djm, sort of ok stevesk
makes the pain stop in one easy step
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.153 2006/08/01 23:22:47 stevesk Exp $ */
d218 2
a219 1
	BN_bin2bn(buffer_ptr(b), bytes, value);
@


1.154.4.1
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.155 2006/11/06 21:25:28 markus Exp $ */
d218 1
a218 2
	if (BN_bin2bn(buffer_ptr(b), bytes, value) == NULL)
		fatal("buffer_get_bignum_bits: BN_bin2bn failed");
@


1.153
log
@move #include <stdio.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.152 2006/07/26 13:57:17 stevesk Exp $ */
a14 2
#include "includes.h"

d17 1
a36 1
#include "bufaux.h"
@


1.152
log
@move #include <stdlib.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.151 2006/07/26 02:35:17 stevesk Exp $ */
d27 1
@


1.151
log
@move #include <sys/param.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.150 2006/07/22 20:48:23 stevesk Exp $ */
d27 1
@


1.150
log
@move #include <string.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.149 2006/07/17 01:31:10 stevesk Exp $ */
d19 1
@


1.149
log
@move #include <unistd.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.148 2006/07/11 20:07:25 stevesk Exp $ */
d26 1
@


1.148
log
@move #include <errno.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.147 2006/07/09 15:15:11 stevesk Exp $ */
d26 1
@


1.147
log
@move #include <fcntl.h> out of includes.h
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.146 2006/07/06 16:22:39 stevesk Exp $ */
d23 1
@


1.146
log
@move #include "dns.h" up
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.145 2006/07/06 16:03:53 stevesk Exp $ */
d23 1
@


1.145
log
@move #include <pwd.h> out of includes.h; ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.144 2006/05/17 12:43:34 markus Exp $ */
d37 1
a41 1
#include "dns.h"
@


1.144
log
@fix leak; coverity via Kylene Jo Hall
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.143 2006/03/30 11:05:17 dtucker Exp $ */
d22 2
@


1.143
log
@Correctly handle truncated files while converting keys; ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.142 2006/03/25 18:40:14 deraadt Exp $ */
d517 1
a517 1
	if (comment)
d519 2
@


1.142
log
@cast strtonum() result to right type
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.141 2006/03/25 13:17:02 djm Exp $ */
d334 2
@


1.141
log
@Put $OpenBSD$ tags back (as comments) to replace the RCSID()s that
Theo nuked - our scripts to sync -portable need them in the files
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1073 1
a1073 1
			bits = strtonum(optarg, 768, 32768, &errstr);
d1160 2
a1161 1
			generator_wanted = strtonum(optarg, 1, UINT_MAX, &errstr);
d1167 1
a1167 1
			trials = strtonum(optarg, 1, UINT_MAX, &errstr);
d1173 1
a1173 1
			memory = strtonum(optarg, 1, UINT_MAX, &errstr);
@


1.140
log
@annoying spacing fixes getting in the way of real diffs
@
text
@d1 1
@


1.139
log
@RCSID() can die
@
text
@d108 1
a108 1
	else
d124 1
a124 1

d319 1
a319 1
		switch(c) {
d1142 1
@


1.138
log
@if no key file are given when printing the DNS host record, use the
host key file(s) as default. ok djm@@
@
text
@a14 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.137 2006/03/13 08:43:16 dtucker Exp $");
@


1.137
log
@Make ssh-keygen handle CR and CRLF line termination when converting IETF
format keys, in adition to vanilla LF.  mindrot #1157, tested by Chris
Pepper, ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.136 2006/02/20 17:19:54 stevesk Exp $");
d862 2
a863 2
static void
do_print_resource_record(struct passwd *pw, char *hname)
d869 1
a869 1
	if (!have_identity)
d871 4
a874 2
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
d877 1
a877 1
	public = key_load_public(identity_file, &comment);
d882 1
a882 1
		exit(0);
d887 1
a887 1
	printf("failed to read v2 public key from %s.\n", identity_file);
d1225 21
a1245 1
		do_print_resource_record(pw, rr_hostname);
@


1.136
log
@move #include <sys/stat.h> out of includes.h; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.135 2005/11/29 02:04:55 dtucker Exp $");
d308 29
d343 1
a343 1
	char line[1024], *p;
d362 2
a363 6
	while (fgets(line, sizeof(line), fp)) {
		if (!(p = strchr(line, '\n'))) {
			fprintf(stderr, "input line too long.\n");
			exit(1);
		}
		if (p > line && p[-1] == '\\')
a379 1
		*p = '\0';
@


1.136.2.1
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-keygen.c,v 1.154 2006/08/03 03:34:42 deraadt Exp $ */
d14 3
a18 2
#include <sys/socket.h>
#include <sys/param.h>
a22 8
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

d29 1
a34 1
#include "dns.h"
d39 1
d109 1
a109 1
	else {
d125 1
a125 1
	}
a307 31
static int
get_line(FILE *fp, char *line, size_t len)
{
	int c;
	size_t pos = 0;

	line[0] = '\0';
	while ((c = fgetc(fp)) != EOF) {
		if (pos >= len - 1) {
			fprintf(stderr, "input line too long.\n");
			exit(1);
		}
		switch (c) {
		case '\r':
			c = fgetc(fp);
			if (c != EOF && c != '\n' && ungetc(c, fp) == EOF) {
				fprintf(stderr, "unget: %s\n", strerror(errno));
				exit(1);
			}
			return pos;
		case '\n':
			return pos;
		}
		line[pos++] = c;
		line[pos] = '\0';
	}
	if (c == EOF)
		return -1;
	return pos;
}

d314 1
a314 1
	char line[1024];
d333 6
a338 2
	while ((blen = get_line(fp, line, sizeof(line))) != -1) {
		if (line[blen - 1] == '\\')
d355 1
d491 1
a491 1
	if (comment) {
a492 2
		comment = NULL;
	}
d838 2
a839 2
static int
do_print_resource_record(struct passwd *pw, char *fname, char *hname)
d845 1
a845 1
	if (fname == NULL)
d847 2
a848 4
	if (stat(fname, &st) < 0) {
		if (errno == ENOENT)
			return 0;
		perror(fname);
d851 1
a851 1
	public = key_load_public(fname, &comment);
d856 1
a856 1
		return 1;
d861 1
a861 1
	printf("failed to read v2 public key from %s.\n", fname);
d1047 1
a1047 1
			bits = (u_int32_t)strtonum(optarg, 768, 32768, &errstr);
a1116 1
			/*FALLTHROUGH*/
d1133 1
a1133 2
			generator_wanted = (u_int32_t)strtonum(optarg, 1,
			    UINT_MAX, &errstr);
d1139 1
a1139 1
			trials = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
d1145 1
a1145 1
			memory = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
d1199 1
a1199 21
		unsigned int n = 0;

		if (have_identity) {
			n = do_print_resource_record(pw,
			    identity_file, rr_hostname);
			if (n == 0) {
				perror(identity_file);
				exit(1);
			}
			exit(0);
		} else {

			n += do_print_resource_record(pw,
			    _PATH_HOST_RSA_KEY_FILE, rr_hostname);
			n += do_print_resource_record(pw,
			    _PATH_HOST_DSA_KEY_FILE, rr_hostname);

			if (n == 0)
				fatal("no keys found.");
			exit(0);
		}
@


1.136.2.2
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.155 2006/11/06 21:25:28 markus Exp $ */
d218 1
a218 2
	if (BN_bin2bn(buffer_ptr(b), bytes, value) == NULL)
		fatal("buffer_get_bignum_bits: BN_bin2bn failed");
@


1.135
log
@Populate default key sizes before checking them; from & ok tim@@
@
text
@d15 4
a18 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.134 2005/11/28 05:16:53 dtucker Exp $");
@


1.134
log
@Enforce DSA key length of exactly 1024 bits to comply with FIPS-186-2,
increase minumum RSA key size to 768 bits and update man page to reflect
these.  Patch originally bz#1119 (senthilkumar_sen at hotpop.com),
ok djm@@, grudging ok deraadt@@.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.133 2005/10/31 11:12:49 djm Exp $");
d1257 2
a1262 2
	if (bits == 0)
		bits = (type == KEY_DSA) ? DEFAULT_BITS_DSA : DEFAULT_BITS;
@


1.133
log
@generate a protocol 2 RSA key by default
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.132 2005/10/30 08:52:18 djm Exp $");
d1044 1
a1044 1
			bits = strtonum(optarg, 512, 32768, &errstr);
d1257 2
@


1.132
log
@no need to escape single quotes in comments, no binary change
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.131 2005/10/14 02:17:59 stevesk Exp $");
d1249 3
a1251 4
	if (key_type_name == NULL) {
		printf("You must specify a key type (-t).\n");
		usage();
	}
@


1.131
log
@no trailing "\n" for log functions; ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.130 2005/10/07 11:13:57 markus Exp $");
d1272 1
a1272 1
	/* Create ~/.ssh directory if it doesn\'t already exist. */
@


1.130
log
@change DSA default back to 1024, as it's defined for 1024 bits only
and this causes interop problems with other clients.  moreover,
in order to improve the security of DSA you need to change more
components of DSA key generation (e.g. the internal SHA1 hash);
ok deraadt
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.129 2005/09/13 23:40:07 djm Exp $");
d1220 1
a1220 1
			fatal("modulus candidate generation failed\n");
d1243 1
a1243 1
			fatal("modulus screening failed\n");
@


1.129
log
@ensure that stdio fds are attached; ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.128 2005/07/17 07:17:55 djm Exp $");
d38 4
a41 2
/* Number of bits in the RSA/DSA key.  This value can be changed on the command line. */
u_int32_t bits = 2048;
d1217 2
d1260 2
@


1.128
log
@knf says that a 2nd level indent is four (not three or five) spaces
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.127 2005/06/08 03:50:00 djm Exp $");
d1020 3
@


1.128.2.1
log
@upgrade to OpenSSH 4.3
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.135 2005/11/29 02:04:55 dtucker Exp $");
d38 2
a39 4
/* Number of bits in the RSA/DSA key.  This value can be set on the command line. */
#define DEFAULT_BITS		2048
#define DEFAULT_BITS_DSA	1024
u_int32_t bits = 0;
a1020 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d1039 1
a1039 1
			bits = strtonum(optarg, 768, 32768, &errstr);
a1211 2
		if (bits == 0)
			bits = DEFAULT_BITS;
d1213 1
a1213 1
			fatal("modulus candidate generation failed");
d1236 1
a1236 1
			fatal("modulus screening failed");
d1242 4
a1245 3
	if (key_type_name == NULL)
		key_type_name = "rsa";

a1250 4
	if (bits == 0)
		bits = (type == KEY_DSA) ? DEFAULT_BITS_DSA : DEFAULT_BITS;
	if (type == KEY_DSA && bits != 1024)
		fatal("DSA keys must be 1024 bits");
d1263 1
a1263 1
	/* Create ~/.ssh directory if it doesn't already exist. */
@


1.128.2.2
log
@upgrade to OpenSSH 4.4
@
text
@a0 1
/* $OpenBSD: ssh-keygen.c,v 1.154 2006/08/03 03:34:42 deraadt Exp $ */
d14 2
a15 4
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/param.h>
a19 8
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

d26 1
a31 1
#include "dns.h"
d36 1
d106 1
a106 1
	else {
d122 1
a122 1
	}
a304 31
static int
get_line(FILE *fp, char *line, size_t len)
{
	int c;
	size_t pos = 0;

	line[0] = '\0';
	while ((c = fgetc(fp)) != EOF) {
		if (pos >= len - 1) {
			fprintf(stderr, "input line too long.\n");
			exit(1);
		}
		switch (c) {
		case '\r':
			c = fgetc(fp);
			if (c != EOF && c != '\n' && ungetc(c, fp) == EOF) {
				fprintf(stderr, "unget: %s\n", strerror(errno));
				exit(1);
			}
			return pos;
		case '\n':
			return pos;
		}
		line[pos++] = c;
		line[pos] = '\0';
	}
	if (c == EOF)
		return -1;
	return pos;
}

d311 1
a311 1
	char line[1024];
d330 6
a335 2
	while ((blen = get_line(fp, line, sizeof(line))) != -1) {
		if (line[blen - 1] == '\\')
d352 1
d488 1
a488 1
	if (comment) {
a489 2
		comment = NULL;
	}
d835 2
a836 2
static int
do_print_resource_record(struct passwd *pw, char *fname, char *hname)
d842 1
a842 1
	if (fname == NULL)
d844 2
a845 4
	if (stat(fname, &st) < 0) {
		if (errno == ENOENT)
			return 0;
		perror(fname);
d848 1
a848 1
	public = key_load_public(fname, &comment);
d853 1
a853 1
		return 1;
d858 1
a858 1
	printf("failed to read v2 public key from %s.\n", fname);
d1044 1
a1044 1
			bits = (u_int32_t)strtonum(optarg, 768, 32768, &errstr);
a1113 1
			/*FALLTHROUGH*/
d1130 1
a1130 2
			generator_wanted = (u_int32_t)strtonum(optarg, 1,
			    UINT_MAX, &errstr);
d1136 1
a1136 1
			trials = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
d1142 1
a1142 1
			memory = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
d1196 1
a1196 21
		unsigned int n = 0;

		if (have_identity) {
			n = do_print_resource_record(pw,
			    identity_file, rr_hostname);
			if (n == 0) {
				perror(identity_file);
				exit(1);
			}
			exit(0);
		} else {

			n += do_print_resource_record(pw,
			    _PATH_HOST_RSA_KEY_FILE, rr_hostname);
			n += do_print_resource_record(pw,
			    _PATH_HOST_DSA_KEY_FILE, rr_hostname);

			if (n == 0)
				fatal("no keys found.");
			exit(0);
		}
@


1.128.2.3
log
@upgrade to OpenSSH 4.5
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.155 2006/11/06 21:25:28 markus Exp $ */
d218 1
a218 2
	if (BN_bin2bn(buffer_ptr(b), bytes, value) == NULL)
		fatal("buffer_get_bignum_bits: BN_bin2bn failed");
@


1.127
log
@increase default rsa/dsa key length from 1024 to 2048 bits; ok markus@@ deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.126 2005/05/26 09:08:12 dtucker Exp $");
d741 1
a741 1
			     "of hostnames\n");
@


1.126
log
@uint32_t -> u_int32_t for consistency; ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.125 2005/05/24 02:05:09 avsm Exp $");
d39 1
a39 1
u_int32_t bits = 1024;
@


1.125
log
@some style nits from dmiller@@, and use a fatal() instead of a printf()/exit
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.124 2005/05/23 22:44:01 avsm Exp $");
d1011 1
a1011 1
	uint32_t memory = 0, generator_wanted = 0, trials = 100;
@


1.124
log
@- removes signed/unsigned comparisons in moduli generation
- use strtonum instead of atoi where its easier
- check some strlcpy overflow and fatal instead of truncate
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.123 2005/04/05 13:45:31 otto Exp $");
d1011 1
a1011 1
        uint32_t memory = 0, generator_wanted = 0, trials = 100;
d1016 1
a1019 1
	const char *errstr;
d1040 3
a1042 4
			if (errstr) {
				printf("Bits has bad value %s (%s)\n", optarg, errstr);
				exit(1);
			}
@


1.123
log
@sync and sort usage(). ok jmc@@ markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.122 2005/03/11 14:59:06 markus Exp $");
d39 1
a39 1
int bits = 1024;
d93 1
a93 1
int gen_candidates(FILE *, int, int, BIGNUM *);
d1010 2
a1011 2
	int opt, type, fd, download = 0, memory = 0;
	int generator_wanted = 0, trials = 100;
d1019 1
d1039 3
a1041 3
			bits = atoi(optarg);
			if (bits < 512 || bits > 32768) {
				printf("Bits has bad value.\n");
d1069 3
a1071 1
			strlcpy(identity_file, optarg, sizeof(identity_file));
d1126 4
a1129 3
			generator_wanted = atoi(optarg);
			if (generator_wanted < 1)
				fatal("Desired generator has bad value.");
d1132 4
a1135 1
			trials = atoi(optarg);
d1138 4
a1141 1
			memory = atoi(optarg);
d1145 3
a1147 1
			strlcpy(out_file, optarg, sizeof(out_file));
d1151 3
a1153 1
			strlcpy(out_file, optarg, sizeof(out_file));
@


1.122
log
@typo, missing \n; mpech
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.121 2005/03/10 22:01:06 deraadt Exp $");
d962 2
d965 1
d967 3
d971 1
d973 1
d975 1
d978 3
d983 4
a986 1
	fprintf(stderr, "  -y          Read private key file and print public key.\n");
a987 7
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
	fprintf(stderr, "  -H          Hash names in known_hosts file\n");
	fprintf(stderr, "  -F hostname Find hostname in known hosts file\n");
	fprintf(stderr, "  -C comment  Provide new comment.\n");
	fprintf(stderr, "  -N phrase   Provide new passphrase.\n");
	fprintf(stderr, "  -P phrase   Provide old passphrase.\n");
	fprintf(stderr, "  -r hostname Print DNS resource record.\n");
a988 1
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
d991 3
a993 3

	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli\n");
@


1.122.2.1
log
@upgrade to OpenSSH 4.2
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.128 2005/07/17 07:17:55 djm Exp $");
d39 1
a39 1
u_int32_t bits = 2048;
d93 1
a93 1
int gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);
d741 1
a741 1
			    "of hostnames\n");
a961 2
	fprintf(stderr, "  -a trials   Number of trials for screening DH-GEX moduli.\n");
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
a962 1
	fprintf(stderr, "  -C comment  Provide new comment.\n");
a963 3
#ifdef SMARTCARD
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
#endif /* SMARTCARD */
a964 1
	fprintf(stderr, "  -F hostname Find hostname in known hosts file.\n");
a965 1
	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli.\n");
a966 1
	fprintf(stderr, "  -H          Hash names in known_hosts file.\n");
d969 8
a976 1
	fprintf(stderr, "  -M memory   Amount of memory (MB) to use for generating DH-GEX moduli.\n");
a978 3
	fprintf(stderr, "  -p          Change passphrase of private key file.\n");
	fprintf(stderr, "  -q          Quiet.\n");
	fprintf(stderr, "  -R hostname Remove host from known_hosts file.\n");
a979 3
	fprintf(stderr, "  -S start    Start point (hex) for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli.\n");
	fprintf(stderr, "  -t type     Specify type of key to create.\n");
d981 1
d984 3
a986 3
	fprintf(stderr, "  -v          Verbose.\n");
	fprintf(stderr, "  -W gen      Generator to use for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -y          Read private key file and print public key.\n");
d1003 2
a1004 2
	int opt, type, fd, download = 0;
	u_int32_t memory = 0, generator_wanted = 0, trials = 100;
a1008 1
	const char *errstr;
d1031 5
a1035 4
			bits = strtonum(optarg, 512, 32768, &errstr);
			if (errstr)
				fatal("Bits has bad value %s (%s)",
					optarg, errstr);
d1061 1
a1061 3
			if (strlcpy(identity_file, optarg, sizeof(identity_file)) >=
			    sizeof(identity_file))
				fatal("Identity filename too long");
d1116 3
a1118 4
			generator_wanted = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr)
				fatal("Desired generator has bad value: %s (%s)",
					optarg, errstr);
d1121 1
a1121 4
			trials = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr)
				fatal("Invalid number of trials: %s (%s)",
					optarg, errstr);
d1124 1
a1124 4
			memory = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr) {
				fatal("Memory limit is %s: %s", errstr, optarg);
			}
d1128 1
a1128 3
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
d1132 1
a1132 3
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
@


1.122.2.2
log
@upgrade to OpenSSH 4.3
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.135 2005/11/29 02:04:55 dtucker Exp $");
d38 2
a39 4
/* Number of bits in the RSA/DSA key.  This value can be set on the command line. */
#define DEFAULT_BITS		2048
#define DEFAULT_BITS_DSA	1024
u_int32_t bits = 0;
a1020 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d1039 1
a1039 1
			bits = strtonum(optarg, 768, 32768, &errstr);
a1211 2
		if (bits == 0)
			bits = DEFAULT_BITS;
d1213 1
a1213 1
			fatal("modulus candidate generation failed");
d1236 1
a1236 1
			fatal("modulus screening failed");
d1242 4
a1245 3
	if (key_type_name == NULL)
		key_type_name = "rsa";

a1250 4
	if (bits == 0)
		bits = (type == KEY_DSA) ? DEFAULT_BITS_DSA : DEFAULT_BITS;
	if (type == KEY_DSA && bits != 1024)
		fatal("DSA keys must be 1024 bits");
d1263 1
a1263 1
	/* Create ~/.ssh directory if it doesn't already exist. */
@


1.121
log
@spacing
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.120 2005/03/02 01:27:41 djm Exp $");
d710 1
a710 1
			    "file beacuse of errors");
@


1.120
log
@ignore hostnames with metachars when hashing; ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.119 2005/03/01 10:42:49 djm Exp $");
d687 1
a687 1
				for(cp2 = strsep(&cp, ",");
@


1.119
log
@add tools for managing known_hosts files with hashed hostnames, including
hashing existing files and deleting hosts by name; ok markus@@ deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.118 2004/12/23 17:38:07 markus Exp $");
d689 9
a697 2
				    cp2 = strsep(&cp, ","))
					print_host(out, cp2, public, 1);
@


1.118
log
@leak; from mpech
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.117 2004/07/11 17:48:47 deraadt Exp $");
d30 2
d55 7
d553 188
d967 2
d992 1
a992 1
	char *resource_record_hostname = NULL;
d1021 1
a1021 1
	    "degiqpclBRvxXyb:f:t:U:D:P:N:C:r:g:T:G:M:S:a:W:")) != -1) {
d1030 11
a1071 4
		case 'R':
			/* unused */
			exit(0);
			break;
d1106 1
a1106 1
			resource_record_hostname = optarg;
d1149 2
d1163 2
a1164 2
	if (resource_record_hostname != NULL) {
		do_print_resource_record(pw, resource_record_hostname);
@


1.117
log
@spaces
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.116 2004/06/21 17:36:31 avsm Exp $");
d242 1
@


1.117.2.1
log
@upgrade to OpenSSH 4.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.120 2005/03/02 01:27:41 djm Exp $");
a29 2
#include "match.h"
#include "hostfile.h"
a52 7
/* Flag indicating that we want to hash a known_hosts file */
int hash_hosts = 0;
/* Flag indicating that we want lookup a host in known_hosts file */
int find_host = 0;
/* Flag indicating that we want to delete a host from a known_hosts file */
int delete_host = 0;

a241 1
		buffer_free(&b);
a542 195
static void
print_host(FILE *f, char *name, Key *public, int hash)
{
	if (hash && (name = host_hash(name, NULL, 0)) == NULL)
		fatal("hash_host failed");
	fprintf(f, "%s ", name);
	if (!key_write(public, f))
		fatal("key_write failed");
	fprintf(f, "\n");
}

static void
do_known_hosts(struct passwd *pw, const char *name)
{
	FILE *in, *out = stdout;
	Key *public;
	char *cp, *cp2, *kp, *kp2;
	char line[16*1024], tmp[MAXPATHLEN], old[MAXPATHLEN];
	int c, i, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;

	if (!have_identity) {
		cp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);
		if (strlcpy(identity_file, cp, sizeof(identity_file)) >=
		    sizeof(identity_file))
			fatal("Specified known hosts path too long");
		xfree(cp);
		have_identity = 1;
	}
	if ((in = fopen(identity_file, "r")) == NULL)
		fatal("fopen: %s", strerror(errno));

	/*
	 * Find hosts goes to stdout, hash and deletions happen in-place
	 * A corner case is ssh-keygen -HF foo, which should go to stdout
	 */
	if (!find_host && (hash_hosts || delete_host)) {
		if (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||
		    strlcat(tmp, ".XXXXXXXXXX", sizeof(tmp)) >= sizeof(tmp) ||
		    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||
		    strlcat(old, ".old", sizeof(old)) >= sizeof(old))
			fatal("known_hosts path too long");
		umask(077);
		if ((c = mkstemp(tmp)) == -1)
			fatal("mkstemp: %s", strerror(errno));
		if ((out = fdopen(c, "w")) == NULL) {
			c = errno;
			unlink(tmp);
			fatal("fdopen: %s", strerror(c));
		}
		inplace = 1;
	}

	while (fgets(line, sizeof(line), in)) {
		num++;
		i = strlen(line) - 1;
		if (line[i] != '\n') {
			error("line %d too long: %.40s...", num, line);
			skip = 1;
			invalid = 1;
			continue;
		}
		if (skip) {
			skip = 0;
			continue;
		}
		line[i] = '\0';

		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#') {
			if (inplace)
				fprintf(out, "%s\n", cp);
			continue;
		}
		/* Find the end of the host name portion. */
		for (kp = cp; *kp && *kp != ' ' && *kp != '\t'; kp++)
			;
		if (*kp == '\0' || *(kp + 1) == '\0') {
			error("line %d missing key: %.40s...",
			    num, line);
			invalid = 1;
			continue;
		}
		*kp++ = '\0';
		kp2 = kp;

		public = key_new(KEY_RSA1);
		if (key_read(public, &kp) != 1) {
			kp = kp2;
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (key_read(public, &kp) != 1) {
				error("line %d invalid key: %.40s...",
				    num, line);
				key_free(public);
				invalid = 1;
				continue;
			}
		}

		if (*cp == HASH_DELIM) {
			if (find_host || delete_host) {
				cp2 = host_hash(name, cp, strlen(cp));
				if (cp2 == NULL) {
					error("line %d: invalid hashed "
					    "name: %.64s...", num, line);
					invalid = 1;
					continue;
				}
				c = (strcmp(cp2, cp) == 0);
				if (find_host && c) {
					printf("# Host %s found: "
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, cp, public, 0);
				}
				if (delete_host && !c)
					print_host(out, cp, public, 0);
			} else if (hash_hosts)
				print_host(out, cp, public, 0);
		} else {
			if (find_host || delete_host) {
				c = (match_hostname(name, cp,
				    strlen(cp)) == 1);
				if (find_host && c) {
					printf("# Host %s found: "
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, cp, public, hash_hosts);
				}
				if (delete_host && !c)
					print_host(out, cp, public, 0);
			} else if (hash_hosts) {
				for(cp2 = strsep(&cp, ",");
				    cp2 != NULL && *cp2 != '\0';
				    cp2 = strsep(&cp, ",")) {
					if (strcspn(cp2, "*?!") != strlen(cp2))
						fprintf(stderr, "Warning: "
						    "ignoring host name with "
						    "metacharacters: %.64s\n",
						    cp2);
					else
						print_host(out, cp2, public, 1);
				}
				has_unhashed = 1;
			}
		}
		key_free(public);
	}
	fclose(in);

	if (invalid) {
		fprintf(stderr, "%s is not a valid known_host file.\n",
		    identity_file);
		if (inplace) {
			fprintf(stderr, "Not replacing existing known_hosts "
			    "file beacuse of errors");
			fclose(out);
			unlink(tmp);
		}
		exit(1);
	}

	if (inplace) {
		fclose(out);

		/* Backup existing file */
		if (unlink(old) == -1 && errno != ENOENT)
			fatal("unlink %.100s: %s", old, strerror(errno));
		if (link(identity_file, old) == -1)
			fatal("link %.100s to %.100s: %s", identity_file, old,
			    strerror(errno));
		/* Move new one into place */
		if (rename(tmp, identity_file) == -1) {
			error("rename\"%s\" to \"%s\": %s", tmp, identity_file,
			    strerror(errno));
			unlink(tmp);
			unlink(old);
			exit(1);
		}

		fprintf(stderr, "%s updated.\n", identity_file);
		fprintf(stderr, "Original contents retained as %s\n", old);
		if (has_unhashed) {
			fprintf(stderr, "WARNING: %s contains unhashed "
			    "entries\n", old);
			fprintf(stderr, "Delete this file to ensure privacy "
			     "of hostnames\n");
		}
	}

	exit(0);
}

a768 2
	fprintf(stderr, "  -H          Hash names in known_hosts file\n");
	fprintf(stderr, "  -F hostname Find hostname in known hosts file\n");
d792 1
a792 1
	char *rr_hostname = NULL;
d821 1
a821 1
	    "degiqpclBHvxXyF:b:f:t:U:D:P:N:C:r:g:R:T:G:M:S:a:W:")) != -1) {
a829 11
		case 'F':
			find_host = 1;
			rr_hostname = optarg;
			break;
		case 'H':
			hash_hosts = 1;
			break;
		case 'R':
			delete_host = 1;
			rr_hostname = optarg;
			break;
d861 4
d899 1
a899 1
			rr_hostname = optarg;
a941 2
	if (delete_host || hash_hosts || find_host)
		do_known_hosts(pw, rr_hostname);
d954 2
a955 2
	if (rr_hostname != NULL) {
		do_print_resource_record(pw, rr_hostname);
@


1.117.2.2
log
@upgrade to OpenSSH 4.1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.122 2005/03/11 14:59:06 markus Exp $");
d687 1
a687 1
				for (cp2 = strsep(&cp, ",");
d710 1
a710 1
			    "file because of errors\n");
@


1.117.2.3
log
@upgrade to OpenSSH 4.2
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.128 2005/07/17 07:17:55 djm Exp $");
d39 1
a39 1
u_int32_t bits = 2048;
d93 1
a93 1
int gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);
d741 1
a741 1
			    "of hostnames\n");
a961 2
	fprintf(stderr, "  -a trials   Number of trials for screening DH-GEX moduli.\n");
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
a962 1
	fprintf(stderr, "  -C comment  Provide new comment.\n");
a963 3
#ifdef SMARTCARD
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
#endif /* SMARTCARD */
a964 1
	fprintf(stderr, "  -F hostname Find hostname in known hosts file.\n");
a965 1
	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli.\n");
a966 1
	fprintf(stderr, "  -H          Hash names in known_hosts file.\n");
d969 8
a976 1
	fprintf(stderr, "  -M memory   Amount of memory (MB) to use for generating DH-GEX moduli.\n");
a978 3
	fprintf(stderr, "  -p          Change passphrase of private key file.\n");
	fprintf(stderr, "  -q          Quiet.\n");
	fprintf(stderr, "  -R hostname Remove host from known_hosts file.\n");
a979 3
	fprintf(stderr, "  -S start    Start point (hex) for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli.\n");
	fprintf(stderr, "  -t type     Specify type of key to create.\n");
d981 1
d984 3
a986 3
	fprintf(stderr, "  -v          Verbose.\n");
	fprintf(stderr, "  -W gen      Generator to use for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -y          Read private key file and print public key.\n");
d1003 2
a1004 2
	int opt, type, fd, download = 0;
	u_int32_t memory = 0, generator_wanted = 0, trials = 100;
a1008 1
	const char *errstr;
d1031 5
a1035 4
			bits = strtonum(optarg, 512, 32768, &errstr);
			if (errstr)
				fatal("Bits has bad value %s (%s)",
					optarg, errstr);
d1061 1
a1061 3
			if (strlcpy(identity_file, optarg, sizeof(identity_file)) >=
			    sizeof(identity_file))
				fatal("Identity filename too long");
d1116 3
a1118 4
			generator_wanted = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr)
				fatal("Desired generator has bad value: %s (%s)",
					optarg, errstr);
d1121 1
a1121 4
			trials = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr)
				fatal("Invalid number of trials: %s (%s)",
					optarg, errstr);
d1124 1
a1124 4
			memory = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr) {
				fatal("Memory limit is %s: %s", errstr, optarg);
			}
d1128 1
a1128 3
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
d1132 1
a1132 3
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
@


1.116
log
@make ssh -Wshadow clean, no functional changes
markus@@ ok
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.115 2004/05/09 00:06:47 djm Exp $");
d893 1
a893 1
				if (log_level >= SYSLOG_LEVEL_DEBUG1 && 
@


1.115
log
@zap another tiny header; ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.114 2004/05/08 00:21:31 djm Exp $");
d191 2
a192 2
	u_int bits = buffer_get_int(b);
	u_int bytes = (bits + 7) / 8;
d629 1
a629 1
do_print_resource_record(struct passwd *pw, char *hostname)
d643 1
a643 1
		export_dns_rr(hostname, public, stdout, print_generic);
@


1.114
log
@kill a tiny header; ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.113 2003/12/22 09:16:58 djm Exp $");
a29 1
#include "moduli.h"
d83 4
a907 4
			if (trials < TRIAL_MINIMUM) {
				fatal("Minimum primality trials is %d",
				    TRIAL_MINIMUM);
			}
a910 5
			if (memory != 0 &&
			   (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
				fatal("Invalid memory amount (min %ld, max %ld)",
				    LARGE_MINIMUM, LARGE_MAXIMUM);
			}
@


1.113
log
@tidy up moduli generation debugging, add -v (verbose/debug) option to
ssh-keygen; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.112 2003/11/23 23:18:45 djm Exp $");
d29 1
a29 1
#include "readpass.h"
@


1.113.2.1
log
@upgrade to OpenSSH 3.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.117 2004/07/11 17:48:47 deraadt Exp $");
d29 2
a30 1
#include "misc.h"
a83 4
/* moduli.c */
int gen_candidates(FILE *, int, int, BIGNUM *);
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t);

d188 2
a189 2
	u_int bignum_bits = buffer_get_int(b);
	u_int bytes = (bignum_bits + 7) / 8;
d626 1
a626 1
do_print_resource_record(struct passwd *pw, char *hname)
d640 1
a640 1
		export_dns_rr(hname, public, stdout, print_generic);
d890 1
a890 1
				if (log_level >= SYSLOG_LEVEL_DEBUG1 &&
d905 4
d912 5
@


1.113.2.2
log
@upgrade to OpenSSH 4.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.120 2005/03/02 01:27:41 djm Exp $");
a29 2
#include "match.h"
#include "hostfile.h"
a52 7
/* Flag indicating that we want to hash a known_hosts file */
int hash_hosts = 0;
/* Flag indicating that we want lookup a host in known_hosts file */
int find_host = 0;
/* Flag indicating that we want to delete a host from a known_hosts file */
int delete_host = 0;

a241 1
		buffer_free(&b);
a542 195
static void
print_host(FILE *f, char *name, Key *public, int hash)
{
	if (hash && (name = host_hash(name, NULL, 0)) == NULL)
		fatal("hash_host failed");
	fprintf(f, "%s ", name);
	if (!key_write(public, f))
		fatal("key_write failed");
	fprintf(f, "\n");
}

static void
do_known_hosts(struct passwd *pw, const char *name)
{
	FILE *in, *out = stdout;
	Key *public;
	char *cp, *cp2, *kp, *kp2;
	char line[16*1024], tmp[MAXPATHLEN], old[MAXPATHLEN];
	int c, i, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;

	if (!have_identity) {
		cp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);
		if (strlcpy(identity_file, cp, sizeof(identity_file)) >=
		    sizeof(identity_file))
			fatal("Specified known hosts path too long");
		xfree(cp);
		have_identity = 1;
	}
	if ((in = fopen(identity_file, "r")) == NULL)
		fatal("fopen: %s", strerror(errno));

	/*
	 * Find hosts goes to stdout, hash and deletions happen in-place
	 * A corner case is ssh-keygen -HF foo, which should go to stdout
	 */
	if (!find_host && (hash_hosts || delete_host)) {
		if (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||
		    strlcat(tmp, ".XXXXXXXXXX", sizeof(tmp)) >= sizeof(tmp) ||
		    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||
		    strlcat(old, ".old", sizeof(old)) >= sizeof(old))
			fatal("known_hosts path too long");
		umask(077);
		if ((c = mkstemp(tmp)) == -1)
			fatal("mkstemp: %s", strerror(errno));
		if ((out = fdopen(c, "w")) == NULL) {
			c = errno;
			unlink(tmp);
			fatal("fdopen: %s", strerror(c));
		}
		inplace = 1;
	}

	while (fgets(line, sizeof(line), in)) {
		num++;
		i = strlen(line) - 1;
		if (line[i] != '\n') {
			error("line %d too long: %.40s...", num, line);
			skip = 1;
			invalid = 1;
			continue;
		}
		if (skip) {
			skip = 0;
			continue;
		}
		line[i] = '\0';

		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#') {
			if (inplace)
				fprintf(out, "%s\n", cp);
			continue;
		}
		/* Find the end of the host name portion. */
		for (kp = cp; *kp && *kp != ' ' && *kp != '\t'; kp++)
			;
		if (*kp == '\0' || *(kp + 1) == '\0') {
			error("line %d missing key: %.40s...",
			    num, line);
			invalid = 1;
			continue;
		}
		*kp++ = '\0';
		kp2 = kp;

		public = key_new(KEY_RSA1);
		if (key_read(public, &kp) != 1) {
			kp = kp2;
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (key_read(public, &kp) != 1) {
				error("line %d invalid key: %.40s...",
				    num, line);
				key_free(public);
				invalid = 1;
				continue;
			}
		}

		if (*cp == HASH_DELIM) {
			if (find_host || delete_host) {
				cp2 = host_hash(name, cp, strlen(cp));
				if (cp2 == NULL) {
					error("line %d: invalid hashed "
					    "name: %.64s...", num, line);
					invalid = 1;
					continue;
				}
				c = (strcmp(cp2, cp) == 0);
				if (find_host && c) {
					printf("# Host %s found: "
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, cp, public, 0);
				}
				if (delete_host && !c)
					print_host(out, cp, public, 0);
			} else if (hash_hosts)
				print_host(out, cp, public, 0);
		} else {
			if (find_host || delete_host) {
				c = (match_hostname(name, cp,
				    strlen(cp)) == 1);
				if (find_host && c) {
					printf("# Host %s found: "
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, cp, public, hash_hosts);
				}
				if (delete_host && !c)
					print_host(out, cp, public, 0);
			} else if (hash_hosts) {
				for(cp2 = strsep(&cp, ",");
				    cp2 != NULL && *cp2 != '\0';
				    cp2 = strsep(&cp, ",")) {
					if (strcspn(cp2, "*?!") != strlen(cp2))
						fprintf(stderr, "Warning: "
						    "ignoring host name with "
						    "metacharacters: %.64s\n",
						    cp2);
					else
						print_host(out, cp2, public, 1);
				}
				has_unhashed = 1;
			}
		}
		key_free(public);
	}
	fclose(in);

	if (invalid) {
		fprintf(stderr, "%s is not a valid known_host file.\n",
		    identity_file);
		if (inplace) {
			fprintf(stderr, "Not replacing existing known_hosts "
			    "file beacuse of errors");
			fclose(out);
			unlink(tmp);
		}
		exit(1);
	}

	if (inplace) {
		fclose(out);

		/* Backup existing file */
		if (unlink(old) == -1 && errno != ENOENT)
			fatal("unlink %.100s: %s", old, strerror(errno));
		if (link(identity_file, old) == -1)
			fatal("link %.100s to %.100s: %s", identity_file, old,
			    strerror(errno));
		/* Move new one into place */
		if (rename(tmp, identity_file) == -1) {
			error("rename\"%s\" to \"%s\": %s", tmp, identity_file,
			    strerror(errno));
			unlink(tmp);
			unlink(old);
			exit(1);
		}

		fprintf(stderr, "%s updated.\n", identity_file);
		fprintf(stderr, "Original contents retained as %s\n", old);
		if (has_unhashed) {
			fprintf(stderr, "WARNING: %s contains unhashed "
			    "entries\n", old);
			fprintf(stderr, "Delete this file to ensure privacy "
			     "of hostnames\n");
		}
	}

	exit(0);
}

a768 2
	fprintf(stderr, "  -H          Hash names in known_hosts file\n");
	fprintf(stderr, "  -F hostname Find hostname in known hosts file\n");
d792 1
a792 1
	char *rr_hostname = NULL;
d821 1
a821 1
	    "degiqpclBHvxXyF:b:f:t:U:D:P:N:C:r:g:R:T:G:M:S:a:W:")) != -1) {
a829 11
		case 'F':
			find_host = 1;
			rr_hostname = optarg;
			break;
		case 'H':
			hash_hosts = 1;
			break;
		case 'R':
			delete_host = 1;
			rr_hostname = optarg;
			break;
d861 4
d899 1
a899 1
			rr_hostname = optarg;
a941 2
	if (delete_host || hash_hosts || find_host)
		do_known_hosts(pw, rr_hostname);
d954 2
a955 2
	if (rr_hostname != NULL) {
		do_print_resource_record(pw, rr_hostname);
@


1.112
log
@consistency PATH_MAX -> MAXPATHLEN; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.111 2003/11/21 11:57:03 djm Exp $");
d796 1
d818 1
a818 1
	    "degiqpclBRxXyb:f:t:U:D:P:N:C:r:g:T:G:M:S:a:W:")) != -1) {
d886 9
d936 4
@


1.111
log
@unexpand and delete whitespace at EOL; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.110 2003/10/14 19:42:10 jakob Exp $");
d788 1
a788 1
	char out_file[PATH_MAX], *reader_id = NULL;
@


1.110
log
@include SSHFP lookup code (not enabled by default). ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.109 2003/09/18 13:02:21 miod Exp $");
d896 1
a896 1
				fatal("Minimum primality trials is %d", 
d902 1
a902 1
			if (memory != 0 && 
d962 1
a962 1
		
d981 1
a981 1
				    "file \"%s\": %s", identity_file, 
@


1.109
log
@A few signedness fixes for harmless situations; markus@@ ok
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.108 2003/08/14 16:08:58 markus Exp $");
a34 1
#ifdef DNS
a35 1
#endif
a621 1
#ifdef DNS
a650 1
#endif /* DNS */
a768 1
#ifdef DNS
a769 1
#endif /* DNS */
a946 1
#ifdef DNS
a947 3
#else /* DNS */
		fatal("no DNS support.");
#endif /* DNS */
@


1.108
log
@exit after primetest, ok djm@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.107 2003/07/28 09:49:56 djm Exp $");
d190 2
a191 2
	int bits = buffer_get_int(b);
	int bytes = (bits + 7) / 8;
@


1.108.2.1
log
@upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.113 2003/12/22 09:16:58 djm Exp $");
d35 1
d37 1
d190 2
a191 2
	u_int bits = buffer_get_int(b);
	u_int bytes = (bits + 7) / 8;
d624 1
d654 1
d773 1
d775 1
d794 1
a794 1
	char out_file[MAXPATHLEN], *reader_id = NULL;
a801 1
	int log_level = SYSLOG_LEVEL_INFO;
d823 1
a823 1
	    "degiqpclBRvxXyb:f:t:U:D:P:N:C:r:g:T:G:M:S:a:W:")) != -1) {
a890 9
		case 'v':
			if (log_level == SYSLOG_LEVEL_INFO)
				log_level = SYSLOG_LEVEL_DEBUG1;
			else {
				if (log_level >= SYSLOG_LEVEL_DEBUG1 && 
				    log_level < SYSLOG_LEVEL_DEBUG3)
					log_level++;
			}
			break;
d902 1
a902 1
				fatal("Minimum primality trials is %d",
d908 1
a908 1
			if (memory != 0 &&
a931 4

	/* reinit */
	log_init(av[0], log_level, SYSLOG_FACILITY_USER, 1);

d953 1
d955 3
d972 1
a972 1

d991 1
a991 1
				    "file \"%s\": %s", identity_file,
@


1.108.2.2
log
@upgrade to OpenSSH 3.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.117 2004/07/11 17:48:47 deraadt Exp $");
d29 2
a30 1
#include "misc.h"
a83 4
/* moduli.c */
int gen_candidates(FILE *, int, int, BIGNUM *);
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t);

d188 2
a189 2
	u_int bignum_bits = buffer_get_int(b);
	u_int bytes = (bignum_bits + 7) / 8;
d626 1
a626 1
do_print_resource_record(struct passwd *pw, char *hname)
d640 1
a640 1
		export_dns_rr(hname, public, stdout, print_generic);
d890 1
a890 1
				if (log_level >= SYSLOG_LEVEL_DEBUG1 &&
d905 4
d912 5
@


1.107
log
@Support for generating Diffie-Hellman groups (/etc/moduli) from ssh-keygen.
Based on code from Phil Karn, William Allen Simpson and Niels Provos.
ok markus@@, thanks jmc@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.106 2003/05/15 03:10:52 djm Exp $");
d1003 1
@


1.106
log
@avoid warning; ok jakob@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.105 2003/05/14 18:16:20 jakob Exp $");
d30 1
d781 3
d794 1
a794 1
	char *reader_id = NULL;
d799 4
a802 1
	int opt, type, fd, download = 0;
d809 1
d822 2
a823 1
	while ((opt = getopt(ac, av, "degiqpclBRxXyb:f:t:U:D:P:N:C:r:")) != -1) {
d894 33
d968 35
@


1.105
log
@add experimental support for verifying hos keys using DNS as described
in draft-ietf-secsh-dns-xx.txt. more information in README.dns.
ok markus@@ and henning@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.104 2003/05/11 16:56:48 markus Exp $");
d33 3
@


1.104
log
@change key_load_public to try to read a public from:
rsa1 private or rsa1 public and ssh2 keys.
this makes ssh-keygen -e fail for ssh1 keys more gracefully
for example; report from itojun (netbsd pr 20550).
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.103 2003/04/08 20:21:29 itojun Exp $");
d73 1
d620 32
d758 1
d769 3
d788 1
d811 1
a811 1
	while ((opt = getopt(ac, av, "deiqpclBRxXyb:f:t:U:D:P:N:C:")) != -1) {
d836 3
d879 3
d907 7
@


1.103
log
@rename log() into logit() to avoid name conflict.  markus ok, from netbsd
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.102 2002/11/26 00:45:03 wcobb Exp $");
d161 4
@


1.102
log
@Remove unnecessary fflush(stderr) calls, stderr is unbuffered by default.
ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.101 2002/06/23 09:39:55 deraadt Exp $");
d414 1
a414 1
	log("loading key done");
@


1.102.2.1
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.108 2003/08/14 16:08:58 markus Exp $");
a29 1
#include "moduli.h"
a33 3
#ifdef DNS
#include "dns.h"
#endif
a72 1
int print_generic = 0;
a161 4
	if (k->type == KEY_RSA1) {
		fprintf(stderr, "version 1 keys are not supported\n");
		exit(1);
	}
d414 1
a414 1
	logit("loading key done");
a614 32
#ifdef DNS
/*
 * Print the SSHFP RR.
 */
static void
do_print_resource_record(struct passwd *pw, char *hostname)
{
	Key *public;
	char *comment = NULL;
	struct stat st;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	public = key_load_public(identity_file, &comment);
	if (public != NULL) {
		export_dns_rr(hostname, public, stdout, print_generic);
		key_free(public);
		xfree(comment);
		exit(0);
	}
	if (comment)
		xfree(comment);

	printf("failed to read v2 public key from %s.\n", identity_file);
	exit(1);
}
#endif /* DNS */

a720 1
	fprintf(stderr, "  -g          Use generic DNS resource record format.\n");
a730 3
#ifdef DNS
	fprintf(stderr, "  -r hostname Print DNS resource record.\n");
#endif /* DNS */
a735 3
	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli\n");

d746 1
a746 2
	char out_file[PATH_MAX], *reader_id = NULL;
	char *resource_record_hostname = NULL;
d750 1
a750 4
	int opt, type, fd, download = 0, memory = 0;
	int generator_wanted = 0, trials = 100;
	int do_gen_candidates = 0, do_screen_candidates = 0;
	BIGNUM *start = NULL;
a756 1
	log_init(av[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
d769 1
a769 2
	while ((opt = getopt(ac, av,
	    "degiqpclBRxXyb:f:t:U:D:P:N:C:r:g:T:G:M:S:a:W:")) != -1) {
a793 3
		case 'g':
			print_generic = 1;
			break;
a833 36
		case 'r':
			resource_record_hostname = optarg;
			break;
		case 'W':
			generator_wanted = atoi(optarg);
			if (generator_wanted < 1)
				fatal("Desired generator has bad value.");
			break;
		case 'a':
			trials = atoi(optarg);
			if (trials < TRIAL_MINIMUM) {
				fatal("Minimum primality trials is %d", 
				    TRIAL_MINIMUM);
			}
			break;
		case 'M':
			memory = atoi(optarg);
			if (memory != 0 && 
			   (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
				fatal("Invalid memory amount (min %ld, max %ld)",
				    LARGE_MINIMUM, LARGE_MAXIMUM);
			}
			break;
		case 'G':
			do_gen_candidates = 1;
			strlcpy(out_file, optarg, sizeof(out_file));
			break;
		case 'T':
			do_screen_candidates = 1;
			strlcpy(out_file, optarg, sizeof(out_file));
			break;
		case 'S':
			/* XXX - also compare length against bits */
			if (BN_hex2bn(&start, optarg) == 0)
				fatal("Invalid start point.");
			break;
a858 7
	if (resource_record_hostname != NULL) {
#ifdef DNS
		do_print_resource_record(pw, resource_record_hostname);
#else /* DNS */
		fatal("no DNS support.");
#endif /* DNS */
	}
a867 36
	}

	if (do_gen_candidates) {
		FILE *out = fopen(out_file, "w");
		
		if (out == NULL) {
			error("Couldn't open modulus candidate file \"%s\": %s",
			    out_file, strerror(errno));
			return (1);
		}
		if (gen_candidates(out, memory, bits, start) != 0)
			fatal("modulus candidate generation failed\n");

		return (0);
	}

	if (do_screen_candidates) {
		FILE *in;
		FILE *out = fopen(out_file, "w");

		if (have_identity && strcmp(identity_file, "-") != 0) {
			if ((in = fopen(identity_file, "r")) == NULL) {
				fatal("Couldn't open modulus candidate "
				    "file \"%s\": %s", identity_file, 
				    strerror(errno));
			}
		} else
			in = stdin;

		if (out == NULL) {
			fatal("Couldn't open moduli file \"%s\": %s",
			    out_file, strerror(errno));
		}
		if (prime_test(in, out, trials, generator_wanted) != 0)
			fatal("modulus screening failed\n");
		return (0);
@


1.102.2.2
log
@upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8upgrade to OpenSSH 3.8
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.113 2003/12/22 09:16:58 djm Exp $");
d35 1
d37 1
d190 2
a191 2
	u_int bits = buffer_get_int(b);
	u_int bytes = (bits + 7) / 8;
d624 1
d654 1
d773 1
d775 1
d794 1
a794 1
	char out_file[MAXPATHLEN], *reader_id = NULL;
a801 1
	int log_level = SYSLOG_LEVEL_INFO;
d823 1
a823 1
	    "degiqpclBRvxXyb:f:t:U:D:P:N:C:r:g:T:G:M:S:a:W:")) != -1) {
a890 9
		case 'v':
			if (log_level == SYSLOG_LEVEL_INFO)
				log_level = SYSLOG_LEVEL_DEBUG1;
			else {
				if (log_level >= SYSLOG_LEVEL_DEBUG1 && 
				    log_level < SYSLOG_LEVEL_DEBUG3)
					log_level++;
			}
			break;
d902 1
a902 1
				fatal("Minimum primality trials is %d",
d908 1
a908 1
			if (memory != 0 &&
a931 4

	/* reinit */
	log_init(av[0], log_level, SYSLOG_FACILITY_USER, 1);

d953 1
d955 3
d972 1
a972 1

d991 1
a991 1
				    "file \"%s\": %s", identity_file,
@


1.101
log
@u_int stuff
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.100 2002/06/19 00:27:55 deraadt Exp $");
a107 1
	fflush(stderr);
@


1.101.2.1
log
@Update to OpenSSH 3.6
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.102 2002/11/26 00:45:03 wcobb Exp $");
d108 1
@


1.101.2.2
log
@upgrade to OpenSSH 3.7
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.108 2003/08/14 16:08:58 markus Exp $");
a29 1
#include "moduli.h"
a33 3
#ifdef DNS
#include "dns.h"
#endif
a72 1
int print_generic = 0;
a161 4
	if (k->type == KEY_RSA1) {
		fprintf(stderr, "version 1 keys are not supported\n");
		exit(1);
	}
d414 1
a414 1
	logit("loading key done");
a614 32
#ifdef DNS
/*
 * Print the SSHFP RR.
 */
static void
do_print_resource_record(struct passwd *pw, char *hostname)
{
	Key *public;
	char *comment = NULL;
	struct stat st;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	public = key_load_public(identity_file, &comment);
	if (public != NULL) {
		export_dns_rr(hostname, public, stdout, print_generic);
		key_free(public);
		xfree(comment);
		exit(0);
	}
	if (comment)
		xfree(comment);

	printf("failed to read v2 public key from %s.\n", identity_file);
	exit(1);
}
#endif /* DNS */

a720 1
	fprintf(stderr, "  -g          Use generic DNS resource record format.\n");
a730 3
#ifdef DNS
	fprintf(stderr, "  -r hostname Print DNS resource record.\n");
#endif /* DNS */
a735 3
	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli\n");

d746 1
a746 2
	char out_file[PATH_MAX], *reader_id = NULL;
	char *resource_record_hostname = NULL;
d750 1
a750 4
	int opt, type, fd, download = 0, memory = 0;
	int generator_wanted = 0, trials = 100;
	int do_gen_candidates = 0, do_screen_candidates = 0;
	BIGNUM *start = NULL;
a756 1
	log_init(av[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
d769 1
a769 2
	while ((opt = getopt(ac, av,
	    "degiqpclBRxXyb:f:t:U:D:P:N:C:r:g:T:G:M:S:a:W:")) != -1) {
a793 3
		case 'g':
			print_generic = 1;
			break;
a833 36
		case 'r':
			resource_record_hostname = optarg;
			break;
		case 'W':
			generator_wanted = atoi(optarg);
			if (generator_wanted < 1)
				fatal("Desired generator has bad value.");
			break;
		case 'a':
			trials = atoi(optarg);
			if (trials < TRIAL_MINIMUM) {
				fatal("Minimum primality trials is %d", 
				    TRIAL_MINIMUM);
			}
			break;
		case 'M':
			memory = atoi(optarg);
			if (memory != 0 && 
			   (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {
				fatal("Invalid memory amount (min %ld, max %ld)",
				    LARGE_MINIMUM, LARGE_MAXIMUM);
			}
			break;
		case 'G':
			do_gen_candidates = 1;
			strlcpy(out_file, optarg, sizeof(out_file));
			break;
		case 'T':
			do_screen_candidates = 1;
			strlcpy(out_file, optarg, sizeof(out_file));
			break;
		case 'S':
			/* XXX - also compare length against bits */
			if (BN_hex2bn(&start, optarg) == 0)
				fatal("Invalid start point.");
			break;
a858 7
	if (resource_record_hostname != NULL) {
#ifdef DNS
		do_print_resource_record(pw, resource_record_hostname);
#else /* DNS */
		fatal("no DNS support.");
#endif /* DNS */
	}
a867 36
	}

	if (do_gen_candidates) {
		FILE *out = fopen(out_file, "w");
		
		if (out == NULL) {
			error("Couldn't open modulus candidate file \"%s\": %s",
			    out_file, strerror(errno));
			return (1);
		}
		if (gen_candidates(out, memory, bits, start) != 0)
			fatal("modulus candidate generation failed\n");

		return (0);
	}

	if (do_screen_candidates) {
		FILE *in;
		FILE *out = fopen(out_file, "w");

		if (have_identity && strcmp(identity_file, "-") != 0) {
			if ((in = fopen(identity_file, "r")) == NULL) {
				fatal("Couldn't open modulus candidate "
				    "file \"%s\": %s", identity_file, 
				    strerror(errno));
			}
		} else
			in = stdin;

		if (out == NULL) {
			fatal("Couldn't open moduli file \"%s\": %s",
			    out_file, strerror(errno));
		}
		if (prime_test(in, out, trials, generator_wanted) != 0)
			fatal("modulus screening failed\n");
		return (0);
@


1.100
log
@KNF done automatically while reading....
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.99 2002/06/09 13:32:01 markus Exp $");
d169 1
a169 1
	    "Comment: \"%d-bit %s, converted from OpenSSH by %s@@%s\"\n",
d461 1
a461 1
		printf("%d %s %s\n", key_size(public), fp, comment);
d495 2
a496 1
				for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
d519 1
a519 1
			printf("%d %s %s\n", key_size(public), fp,
@


1.99
log
@use tab not spaces (|unexpand)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.98 2002/03/27 22:21:45 markus Exp $");
d139 1
a139 1
#define SSH_COM_PUBLIC_END  		"---- END SSH2 PUBLIC KEY ----"
@


1.98
log
@try to import keys with extra trailing === (seen with ssh.com < 2.0.12)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.97 2002/03/25 17:34:27 markus Exp $");
d415 1
a415 1
        log("loading key done");
@


1.98.2.1
log
@Pull in OpenSSH-3.4
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.101 2002/06/23 09:39:55 deraadt Exp $");
d139 1
a139 1
#define SSH_COM_PUBLIC_END		"---- END SSH2 PUBLIC KEY ----"
d169 1
a169 1
	    "Comment: \"%u-bit %s, converted from OpenSSH by %s@@%s\"\n",
d415 1
a415 1
	log("loading key done");
d461 1
a461 1
		printf("%u %s %s\n", key_size(public), fp, comment);
d495 1
a495 2
				for (; *cp && (quoted || (*cp != ' ' &&
				    *cp != '\t')); cp++) {
d518 1
a518 1
			printf("%u %s %s\n", key_size(public), fp,
@


1.98.2.2
log
@Merge OpenSSH 3.6.1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.102 2002/11/26 00:45:03 wcobb Exp $");
d108 1
@


1.97
log
@change sc_get_key to sc_get_keys and hide smartcard details in scard.c
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.96 2002/03/21 21:54:34 rees Exp $");
d289 1
d334 6
@


1.96
log
@Add PIN-protection for secret key.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.95 2002/03/21 16:54:53 markus Exp $");
d415 2
a416 1
	Key *pub = NULL;
d418 2
a419 2
	pub = sc_get_key(sc_reader_id, NULL);
	if (pub == NULL)
d421 6
a426 3
	key_write(pub, stdout);
	key_free(pub);
	fprintf(stdout, "\n");
@


1.95
log
@move key upload to scard.[ch]
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.94 2002/02/25 16:33:27 markus Exp $");
d417 1
a417 1
	pub = sc_get_key(sc_reader_id);
@


1.94
log
@more u_* fixes
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.93 2002/02/24 19:14:59 markus Exp $");
a31 2
#include <sectok.h>
#include <openssl/engine.h>
a385 28
#define NUM_RSA_KEY_ELEMENTS 5+1
#define COPY_RSA_KEY(x, i) \
	do { \
		len = BN_num_bytes(prv->rsa->x); \
		elements[i] = xmalloc(len); \
		debug("#bytes %d", len); \
		if (BN_bn2bin(prv->rsa->x, elements[i]) < 0) \
			goto done; \
	} while (0)

static int
get_AUT0(char *aut0)
{
	EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
	char *pass;

	pass = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
	if (pass == NULL)
		return -1;
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, pass, strlen(pass));
	EVP_DigestFinal(&md, aut0, NULL);
	memset(pass, 0, strlen(pass));
	xfree(pass);
	return 0;
}

d391 1
a391 6
	u_char *elements[NUM_RSA_KEY_ELEMENTS];
	u_char key_fid[2];
	u_char DEFAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};
	u_char AUT0[EVP_MAX_MD_SIZE];
	int len, status = 1, i, fd = -1, ret;
	int sw = 0, cla = 0x00;
a392 2
	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		elements[i] = NULL;
d397 1
a397 1
		goto done;
d402 1
a402 1
		goto done;
d404 6
a409 73
	COPY_RSA_KEY(q, 0);
	COPY_RSA_KEY(p, 1);
	COPY_RSA_KEY(iqmp, 2);
	COPY_RSA_KEY(dmq1, 3);
	COPY_RSA_KEY(dmp1, 4);
	COPY_RSA_KEY(n, 5);
	len = BN_num_bytes(prv->rsa->n);
	fd = sectok_friendly_open(sc_reader_id, STONOWAIT, &sw);
	if (fd < 0) {
		error("sectok_open failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (! sectok_cardpresent(fd)) {
		error("smartcard in reader %s not present",
		    sc_reader_id);
		goto done;
	}
	ret = sectok_reset(fd, 0, NULL, &sw);
	if (ret <= 0) {
		error("sectok_reset failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if ((cla = cyberflex_inq_class(fd)) < 0) {
		error("cyberflex_inq_class failed");
		goto done;
	}
	memcpy(AUT0, DEFAUT0, sizeof(DEFAUT0));
	if (cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
		if (get_AUT0(AUT0) < 0 ||
		    cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
			error("cyberflex_verify_AUT0 failed");
			goto done;
		}
	}
	key_fid[0] = 0x00;
	key_fid[1] = 0x12;
	if (cyberflex_load_rsa_priv(fd, cla, key_fid, 5, 8*len, elements,
	    &sw) < 0) {
		error("cyberflex_load_rsa_priv failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_priv done");
	key_fid[0] = 0x73;
	key_fid[1] = 0x68;
	if (cyberflex_load_rsa_pub(fd, cla, key_fid, len, elements[5],
	    &sw) < 0) {
		error("cyberflex_load_rsa_pub failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_pub done");
	status = 0;
	log("loading key done");
done:

	memset(elements[0], '\0', BN_num_bytes(prv->rsa->q));
	memset(elements[1], '\0', BN_num_bytes(prv->rsa->p));
	memset(elements[2], '\0', BN_num_bytes(prv->rsa->iqmp));
	memset(elements[3], '\0', BN_num_bytes(prv->rsa->dmq1));
	memset(elements[4], '\0', BN_num_bytes(prv->rsa->dmp1));
	memset(elements[5], '\0', BN_num_bytes(prv->rsa->n));

	if (prv)
		key_free(prv);
	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		if (elements[i])
			xfree(elements[i]);
	if (fd != -1)
		sectok_close(fd);
	exit(status);
@


1.93
log
@signed vs. unsigned: make size arguments u_int, ok stevesk@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.92 2002/02/16 20:40:08 stevesk Exp $");
d149 1
a149 1
	int len;
@


1.92
log
@default to rsa keyfile path for non key generation operations where
keyfile not specified.  fixes core dump in those cases.  ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.91 2002/01/18 18:14:17 stevesk Exp $");
d195 1
a195 1
do_convert_private_ssh2_from_blob(u_char *blob, int blen)
@


1.91
log
@unneeded cast cleanup; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.90 2002/01/09 13:49:27 markus Exp $");
d89 1
a89 8
	switch (key_type_from_name(key_type_name)) {
	case KEY_RSA1:
		name = _PATH_SSH_CLIENT_IDENTITY;
		break;
	case KEY_DSA:
		name = _PATH_SSH_CLIENT_ID_DSA;
		break;
	case KEY_RSA:
d91 17
a107 6
		break;
	default:
		fprintf(stderr, "bad key type");
		exit(1);
		break;
	}
@


1.90
log
@append \n only for public keys
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.89 2001/12/29 21:56:01 stevesk Exp $");
d331 1
a331 1
	blen = uudecode(encoded, (u_char *)blob, sizeof(blob));
@


1.89
log
@remove unneeded casts and some char->u_char cleanup; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.88 2001/12/27 18:10:29 markus Exp $");
d353 2
a354 1
	fprintf(stdout, "\n");
@


1.88
log
@-t is only needed for key generation (unbreaks -i, -e, etc).
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.87 2001/12/21 08:52:22 djm Exp $");
d186 1
a186 1
	BN_bin2bn((u_char *)buffer_ptr(b), bytes, value);
@


1.87
log
@Remove default (rsa1) key type; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.86 2001/12/19 07:18:56 deraadt Exp $");
a930 4
	if (key_type_name == NULL) {
		printf("You must specify a key type (-t).\n");
		usage();
	}
d960 4
@


1.86
log
@basic KNF done while i was looking for something else
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.85 2001/12/05 10:06:12 deraadt Exp $");
d76 1
a76 2
/* default to RSA for SSH-1 */
char *key_type_name = "rsa1";
d833 1
a833 1
	char dotsshdir[16 * 1024], comment[1024], *passphrase1, *passphrase2;
d929 4
@


1.85
log
@minor KNF
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.84 2001/11/17 19:14:34 stevesk Exp $");
d669 1
a669 1
		     RP_ALLOW_STDIN);
d747 1
a747 1
	}	
@


1.84
log
@enum/int type cleanup where it made sense to do so; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.83 2001/10/25 21:14:32 markus Exp $");
d271 1
a271 1
	if(rlen != 0)
d392 1
a392 1
	} while(0)
@


1.83
log
@better docu for fingerprinting, ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.82 2001/09/28 12:07:09 djm Exp $");
d533 3
a535 1
	int i, skip = 0, num = 1, invalid = 1, rep, fptype;
@


1.82
log
@bzero private key after loading to smartcard; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.81 2001/09/17 20:50:22 markus Exp $");
d614 1
a614 1
		printf("%s is not a valid key file.\n", identity_file);
@


1.82.2.1
log
@Pull in patches from current (Errata 002):
Update to OpenSSH-3.0.1 via errata patch (Instead of using release tarball)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.83 2001/10/25 21:14:32 markus Exp $");
d614 1
a614 1
		printf("%s is not a public key file.\n", identity_file);
@


1.82.2.2
log
@Update to OpenSSH-3.1 on 3.0-stable branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.94 2002/02/25 16:33:27 markus Exp $");
d76 2
a77 1
char *key_type_name = NULL;
d90 8
a97 1
	if (key_type_name == NULL)
d99 6
a104 17
	else
		switch (key_type_from_name(key_type_name)) {
		case KEY_RSA1:
			name = _PATH_SSH_CLIENT_IDENTITY;
			break;
		case KEY_DSA:
			name = _PATH_SSH_CLIENT_ID_DSA;
			break;
		case KEY_RSA:
			name = _PATH_SSH_CLIENT_ID_RSA;
			break;
		default:
			fprintf(stderr, "bad key type");
			exit(1);
			break;
		}

d146 1
a146 1
	u_int len;
d187 1
a187 1
	BN_bin2bn(buffer_ptr(b), bytes, value);
d192 1
a192 1
do_convert_private_ssh2_from_blob(u_char *blob, u_int blen)
d271 1
a271 1
	if (rlen != 0)
d332 1
a332 1
	blen = uudecode(encoded, blob, sizeof(blob));
d354 1
a354 2
	if (!private)
		fprintf(stdout, "\n");
d392 1
a392 1
	} while (0)
d533 1
a533 3
	int i, skip = 0, num = 1, invalid = 1;
	enum fp_rep rep;
	enum fp_type fptype;
d667 1
a667 1
		    RP_ALLOW_STDIN);
d745 1
a745 1
	}
d832 1
a832 1
	char dotsshdir[MAXPATHLEN], comment[1024], *passphrase1, *passphrase2;
a958 4
	if (key_type_name == NULL) {
		printf("You must specify a key type (-t).\n");
		usage();
	}
@


1.82.2.3
log
@Update OpenSSH to version 3.2.2.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.98 2002/03/27 22:21:45 markus Exp $");
d32 2
a290 1
	u_int len;
a334 6
	len = strlen(encoded);
	if (((len % 4) == 3) &&
	    (encoded[len-1] == '=') &&
	    (encoded[len-2] == '=') &&
	    (encoded[len-3] == '='))
		encoded[len-3] = '\0';
d388 28
d421 6
a426 1
	int ret;
d428 2
d434 1
a434 1
		exit(1);
d439 35
a473 1
		exit(1);
d475 39
a513 6
	ret = sc_put_key(prv, sc_reader_id);
	key_free(prv);
	if (ret < 0)
		exit(1);
        log("loading key done");
	exit(0);
d519 1
a519 2
	Key **keys = NULL;
	int i;
d521 2
a522 2
	keys = sc_get_keys(sc_reader_id, NULL);
	if (keys == NULL)
d524 3
a526 6
	for (i = 0; keys[i]; i++) {
		key_write(keys[i], stdout);
		key_free(keys[i]);
		fprintf(stdout, "\n");
	}
	xfree(keys);
@


1.82.2.4
log
@Update OpenSSH to version 3.3 (with local changes, configuration files still
living in /etc and privsep user being nobody).
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.82.2.3 2002/05/17 00:03:24 miod Exp $");
d139 1
a139 1
#define SSH_COM_PUBLIC_END		"---- END SSH2 PUBLIC KEY ----"
d415 1
a415 1
	log("loading key done");
@


1.82.2.5
log
@There was an update to OpenSSH 3.4, and people rejoiced.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.82.2.4 2002/06/22 07:23:18 miod Exp $");
d169 1
a169 1
	    "Comment: \"%u-bit %s, converted from OpenSSH by %s@@%s\"\n",
d461 1
a461 1
		printf("%u %s %s\n", key_size(public), fp, comment);
d495 1
a495 2
				for (; *cp && (quoted || (*cp != ' ' &&
				    *cp != '\t')); cp++) {
d518 1
a518 1
			printf("%u %s %s\n", key_size(public), fp,
@


1.81
log
@better error handling if you try to export a bad key to ssh.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.80 2001/09/17 19:27:15 stevesk Exp $");
d494 8
@


1.80
log
@u_char*/char* cleanup; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.79 2001/08/02 16:14:05 jakob Exp $");
d162 4
a165 1
	key_to_blob(k, &blob, &len);
@


1.79
log
@clean up some /* SMARTCARD */. ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.78 2001/08/02 15:43:57 jakob Exp $");
d189 1
a189 1
do_convert_private_ssh2_from_blob(char *blob, int blen)
d286 1
a286 1
	char blob[8096];
@


1.78
log
@add /* SMARTCARD */ to #else/#endif. ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.77 2001/08/02 15:06:52 jakob Exp $");
d35 1
a35 1
#endif /* SMARTCARD */
@


1.77
log
@more verbose usage(). ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.76 2001/08/02 08:58:35 jakob Exp $");
d35 1
a35 1
#endif
d514 1
a514 1
#endif
d941 1
a941 1
#else
d943 1
a943 1
#endif
@


1.76
log
@change -u (upload smartcard key) to -U. ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.75 2001/08/02 00:10:17 markus Exp $");
d791 21
a811 2
	printf("Usage: %s [-ceilpqyB] [-t type] [-b bits] [-f file] [-C comment] "
	    "[-N new-pass] [-P pass]\n", __progname);
@


1.75
log
@add -D readerid option (download, i.e. print public RSA key to stdout).
check for card present when uploading keys.
use strings instead of ints for smartcard reader ids, too.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.74 2001/08/01 23:33:09 markus Exp $");
d826 1
a826 1
	while ((opt = getopt(ac, av, "deiqpclBRxXyb:f:t:u:D:P:N:C:")) != -1) {
d888 1
a888 1
		case 'u':
@


1.74
log
@allow uploading RSA keys for non-default AUT0 (sha1 over passphrase like sectok).
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.73 2001/07/26 20:04:27 rees Exp $");
a19 4
#ifdef SMARTCARD
#include <sectok.h>
#endif

d31 5
d410 1
a410 1
do_upload(struct passwd *pw, int reader)
d441 1
a441 1
	fd = sectok_open(reader, STONOWAIT, &sw);
d443 6
a448 1
                error("sectok_open failed: %s", sectok_get_sw(sw));
d453 1
a453 1
                error("sectok_reset failed: %s", sectok_get_sw(sw));
d500 14
d803 1
a805 1
	int opt, type, fd, reader = -1;
d807 1
d826 1
a826 1
	while ((opt = getopt(ac, av, "deiqpclBRxXyb:f:t:u:P:N:C:")) != -1) {
d886 2
d889 1
a889 1
			reader = atoi(optarg); /*XXX*/
d916 1
a916 1
	if (reader != -1)
d918 4
a921 1
		do_upload(pw, reader);
d925 1
@


1.73
log
@Inquire Cyberflex class for 0xf0 cards
change aid to conform to 7816-5
remove gratuitous fid selects
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.72 2001/07/02 22:40:18 markus Exp $");
d379 1
d390 18
a410 3
#ifndef SMARTCARD
	fatal("no support for smartcards.");
#else
d415 2
a416 1
	u_char AUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};
d440 1
a440 1
	fd = sectok_open(reader, 0, &sw);
d442 1
a442 1
		error("sectok_open failed");
d447 1
a447 1
		error("sectok_reset failed");
d454 7
a460 3
	if (cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(AUT0)) < 0) {
		error("cyberflex_verify_AUT0 failed");
		goto done;
d493 1
a494 1
}
d894 1
d896 3
@


1.72
log
@update for sectok.h interface changes.
improve error handling.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.71 2001/06/29 07:11:01 markus Exp $");
a398 1
	u_char atr[256];
d423 1
a423 1
	fd = sectok_open(reader, 0, NULL);
d428 1
a428 1
	ret = sectok_reset(fd, 0, atr, &sw);
@


1.71
log
@initialize early
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.70 2001/06/29 07:06:34 markus Exp $");
d399 1
a399 1
        u_char atr[256];
d402 1
a402 1
	int r1 = 0, r2 = 0, cla = 0x00;
d424 3
a426 3
        fd = scopen(reader, 0, NULL);
        if (fd < 0) {
                error("scopen failed");
d428 4
a431 4
        }
        ret = screset(fd, atr, NULL);
        if (ret <= 0) {
                error("screset failed");
d433 1
a433 1
        }
d445 2
a446 2
	    &r1, &r2) < 0) {
		error("cyberflex_load_rsa_priv failed: %s", get_r1r2s(r1, r1));
d449 1
a449 1
	if (r1 != 0x90 && r1 != 0x61)
d455 2
a456 2
	    &r1, &r2) < 0) {
		error("cyberflex_load_rsa_pub failed: %s", get_r1r2s(r1, r1));
d459 1
a459 1
	if (r1 != 0x90 && r1 != 0x61)
d468 2
a469 1
		xfree(elements[i]);
d471 1
a471 1
		scclose(fd);
@


1.70
log
@new error handling for cyberflex_*
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.69 2001/06/28 19:57:35 stevesk Exp $");
d404 2
a416 2
	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		elements[i] = NULL;
@


1.69
log
@'\0' terminated data[] is ok; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.68 2001/06/27 05:42:25 markus Exp $");
d384 1
a384 1
error("#bytes %d", len); \
d402 1
a402 1
	int cla = 0x00;
d426 1
a426 1
                error("scopen failed %d.", fd);
d431 1
a431 1
                error("screset failed.");
d444 6
a449 1
	if (cyberflex_load_rsa_priv(fd, cla, key_fid, 5, 8*len, elements) < 0)
d454 6
a459 1
	if (cyberflex_load_rsa_pub(fd, cla, key_fid, len, elements[5]) < 0)
@


1.68
log
@s/generate_additional_parameters/rsa_generate_additional_parameters/
http://www.humppa.com/
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.67 2001/06/27 05:35:42 markus Exp $");
d193 1
a193 1
	u_char *sig, data[10] = "abcde12345";
@


1.67
log
@use cyberflex_inq_class to inquire class.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.66 2001/06/26 02:47:07 markus Exp $");
d263 1
a263 1
		generate_additional_parameters(key->rsa);
@


1.66
log
@allow loading a private RSA key to a cyberflex card.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.65 2001/06/24 05:35:33 markus Exp $");
a414 4
{
	prv->type = KEY_RSA;
	key_write(prv, stderr);
}
d434 4
@


1.65
log
@switch to readpassphrase(3)
2.7/8-stable needs readpassphrase.[ch] from libc
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.64 2001/06/23 17:05:22 markus Exp $");
d20 4
d35 1
d379 86
d754 1
a754 1
	int opt, type, fd;
d774 1
a774 1
	while ((opt = getopt(ac, av, "deiqpclBRxXyb:f:t:P:N:C:")) != -1) {
a782 1

a785 1

a788 1

a791 1

a794 1

a798 1

a801 1

a804 1

a807 1

a810 1

a814 1

a819 1

a824 1

a827 1

a830 1

d834 3
a836 1

d862 2
@


1.64
log
@fix import for (broken?) ssh.com/f-secure private keys
(i tested > 1000 RSA keys)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.63 2001/06/23 15:12:20 itojun Exp $");
d122 2
a123 1
			pass = read_passphrase("Enter passphrase: ", 1);
d491 5
a495 2
			old_passphrase = read_passphrase("Enter old passphrase: ", 1);
		private = key_load_private(identity_file, old_passphrase , &comment);
d511 4
a514 2
			read_passphrase("Enter new passphrase (empty for no passphrase): ", 1);
		passphrase2 = read_passphrase("Enter same passphrase again: ", 1);
d575 2
a576 1
			passphrase = read_passphrase("Enter passphrase: ", 1);
d832 4
a835 2
			read_passphrase("Enter passphrase (empty for no passphrase): ", 1);
		passphrase2 = read_passphrase("Enter same passphrase again: ", 1);
d837 4
a840 1
			/* The passphrases do not match.  Clear them and retry. */
@


1.63
log
@more strict prototypes.  raise warning level in Makefile.inc.  markus ok'ed
TODO; cleanup headers
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.62 2001/06/23 06:41:10 markus Exp $");
d186 2
d189 1
a190 1
	char *type, *cipher;
d265 5
a269 10
#ifdef DEBUG_PK
	{
		u_int slen;
		u_char *sig, data[10] = "abcde12345";

		key_sign(key, &sig, &slen, data, sizeof(data));
		key_verify(key, sig, slen, data, sizeof(data));
		xfree(sig);
	}
#endif
d308 3
@


1.62
log
@try to decode ssh-3.0.0 private rsa keys
(allow migration to openssh, not vice versa), #910
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.61 2001/05/25 14:37:32 markus Exp $");
d78 1
a78 1
void
d111 1
a111 1
Key *
d135 1
a135 1
void
d168 1
a168 1
void
d181 1
a181 1
Key *
d276 1
a276 1
void
d349 1
a349 1
void
d373 1
a373 1
void
d470 1
a470 1
void
d546 1
a546 1
void
d639 1
a639 1
void
@


1.61
log
@use -P for -e and -y, too.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.60 2001/04/23 22:14:13 markus Exp $");
d186 2
a187 1
	int ignore, magic, rlen, ktype;
d199 1
a199 1
	ignore = buffer_get_int(&b);
d202 4
a205 4
	ignore = buffer_get_int(&b);
	ignore = buffer_get_int(&b);
	ignore = buffer_get_int(&b);

d235 11
a245 1
		if (!BN_set_word(key->rsa->e, (u_long) buffer_get_char(&b))) {
d268 2
a269 2
		key_sign(key, &sig, &slen, data, sizeof data);
		key_verify(key, sig, slen, data, sizeof data);
@


1.60
log
@remove debug
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.59 2001/04/23 21:57:07 markus Exp $");
d112 1
a112 1
try_load_pem_key(char *filename)
d119 4
a122 1
		pass = read_passphrase("Enter passphrase: ", 1);
d150 1
a150 1
		if ((k = try_load_pem_key(identity_file)) == NULL) {
d350 1
a350 1
	prv = try_load_pem_key(identity_file);
@


1.60.2.1
log
@Pull in OpenSSH-2.9.9
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.81 2001/09/17 20:50:22 markus Exp $");
a30 6
#ifdef SMARTCARD
#include <sectok.h>
#include <openssl/engine.h>
#include "scard.h"
#endif

d78 1
a78 1
static void
d111 2
a112 2
static Key *
load_identity(char *filename)
d119 1
a119 5
		if (identity_passphrase)
			pass = xstrdup(identity_passphrase);
		else
			pass = read_passphrase("Enter passphrase: ",
			    RP_ALLOW_STDIN);
d132 1
a132 1
static void
d147 1
a147 1
		if ((k = load_identity(identity_file)) == NULL) {
d152 1
a152 4
	if (key_to_blob(k, &blob, &len) <= 0) {
		fprintf(stderr, "key_to_blob failed\n");
		exit(1);
	}
d165 1
a165 1
static void
d178 2
a179 2
static Key *
do_convert_private_ssh2_from_blob(u_char *blob, int blen)
d183 1
a184 4
	u_char *sig, data[] = "abcde12345";
	int magic, rlen, ktype, i1, i2, i3, i4;
	u_int slen;
	u_long e;
d195 1
a195 1
	i1 = buffer_get_int(&b);
d198 4
a201 4
	i2 = buffer_get_int(&b);
	i3 = buffer_get_int(&b);
	i4 = buffer_get_int(&b);
	debug("ignore (%d %d %d %d)", i1,i2,i3,i4);
d231 1
a231 11
		e  = buffer_get_char(&b);
		debug("e %lx", e);
		if (e < 30) {
			e <<= 8;
			e += buffer_get_char(&b);
			debug("e %lx", e);
			e <<= 8;
			e += buffer_get_char(&b);
			debug("e %lx", e);
		}
		if (!BN_set_word(key->rsa->e, e)) {
d241 1
a241 1
		rsa_generate_additional_parameters(key->rsa);
d249 10
a258 5

	/* try the key */
	key_sign(key, &sig, &slen, data, sizeof(data));
	key_verify(key, sig, slen, data, sizeof(data));
	xfree(sig);
d262 1
a262 1
static void
d268 1
a268 1
	u_char blob[8096];
a296 3
			if (strstr(line, " END ") != NULL) {
				break;
			}
d335 1
a335 1
static void
d347 1
a347 1
	prv = load_identity(identity_file);
d359 1
a359 137
#ifdef SMARTCARD
#define NUM_RSA_KEY_ELEMENTS 5+1
#define COPY_RSA_KEY(x, i) \
	do { \
		len = BN_num_bytes(prv->rsa->x); \
		elements[i] = xmalloc(len); \
		debug("#bytes %d", len); \
		if (BN_bn2bin(prv->rsa->x, elements[i]) < 0) \
			goto done; \
	} while(0)

static int
get_AUT0(char *aut0)
{
	EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
	char *pass;

	pass = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
	if (pass == NULL)
		return -1;
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, pass, strlen(pass));
	EVP_DigestFinal(&md, aut0, NULL);
	memset(pass, 0, strlen(pass));
	xfree(pass);
	return 0;
}

static void
do_upload(struct passwd *pw, const char *sc_reader_id)
{
	Key *prv = NULL;
	struct stat st;
	u_char *elements[NUM_RSA_KEY_ELEMENTS];
	u_char key_fid[2];
	u_char DEFAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};
	u_char AUT0[EVP_MAX_MD_SIZE];
	int len, status = 1, i, fd = -1, ret;
	int sw = 0, cla = 0x00;

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		elements[i] = NULL;
	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		goto done;
	}
	prv = load_identity(identity_file);
	if (prv == NULL) {
		error("load failed");
		goto done;
	}
	COPY_RSA_KEY(q, 0);
	COPY_RSA_KEY(p, 1);
	COPY_RSA_KEY(iqmp, 2);
	COPY_RSA_KEY(dmq1, 3);
	COPY_RSA_KEY(dmp1, 4);
	COPY_RSA_KEY(n, 5);
	len = BN_num_bytes(prv->rsa->n);
	fd = sectok_friendly_open(sc_reader_id, STONOWAIT, &sw);
	if (fd < 0) {
		error("sectok_open failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (! sectok_cardpresent(fd)) {
		error("smartcard in reader %s not present",
		    sc_reader_id);
		goto done;
	}
	ret = sectok_reset(fd, 0, NULL, &sw);
	if (ret <= 0) {
		error("sectok_reset failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if ((cla = cyberflex_inq_class(fd)) < 0) {
		error("cyberflex_inq_class failed");
		goto done;
	}
	memcpy(AUT0, DEFAUT0, sizeof(DEFAUT0));
	if (cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
		if (get_AUT0(AUT0) < 0 ||
		    cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
			error("cyberflex_verify_AUT0 failed");
			goto done;
		}
	}
	key_fid[0] = 0x00;
	key_fid[1] = 0x12;
	if (cyberflex_load_rsa_priv(fd, cla, key_fid, 5, 8*len, elements,
	    &sw) < 0) {
		error("cyberflex_load_rsa_priv failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_priv done");
	key_fid[0] = 0x73;
	key_fid[1] = 0x68;
	if (cyberflex_load_rsa_pub(fd, cla, key_fid, len, elements[5],
	    &sw) < 0) {
		error("cyberflex_load_rsa_pub failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_pub done");
	status = 0;
	log("loading key done");
done:
	if (prv)
		key_free(prv);
	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		if (elements[i])
			xfree(elements[i]);
	if (fd != -1)
		sectok_close(fd);
	exit(status);
}

static void
do_download(struct passwd *pw, const char *sc_reader_id)
{
	Key *pub = NULL;

	pub = sc_get_key(sc_reader_id);
	if (pub == NULL)
		fatal("cannot read public key from smartcard");
	key_write(pub, stdout);
	key_free(pub);
	fprintf(stdout, "\n");
	exit(0);
}
#endif /* SMARTCARD */

static void
d456 1
a456 1
static void
d476 2
a477 5
			old_passphrase =
			    read_passphrase("Enter old passphrase: ",
			    RP_ALLOW_STDIN);
		private = key_load_private(identity_file, old_passphrase,
		    &comment);
d493 2
a494 4
			read_passphrase("Enter new passphrase (empty for no "
			    "passphrase): ", RP_ALLOW_STDIN);
		passphrase2 = read_passphrase("Enter same passphrase again: ",
		     RP_ALLOW_STDIN);
d532 1
a532 1
static void
d555 1
a555 2
			passphrase = read_passphrase("Enter passphrase: ",
			    RP_ALLOW_STDIN);
d625 1
a625 1
static void
d628 2
a629 21
	fprintf(stderr, "Usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -b bits     Number of bits in the key to create.\n");
	fprintf(stderr, "  -c          Change comment in private and public key files.\n");
	fprintf(stderr, "  -e          Convert OpenSSH to IETF SECSH key file.\n");
	fprintf(stderr, "  -f filename Filename of the key file.\n");
	fprintf(stderr, "  -i          Convert IETF SECSH to OpenSSH key file.\n");
	fprintf(stderr, "  -l          Show fingerprint of key file.\n");
	fprintf(stderr, "  -p          Change passphrase of private key file.\n");
	fprintf(stderr, "  -q          Quiet.\n");
	fprintf(stderr, "  -y          Read private key file and print public key.\n");
	fprintf(stderr, "  -t type     Specify type of key to create.\n");
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
	fprintf(stderr, "  -C comment  Provide new comment.\n");
	fprintf(stderr, "  -N phrase   Provide new passphrase.\n");
	fprintf(stderr, "  -P phrase   Provide old passphrase.\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
	fprintf(stderr, "  -U reader   Upload private key to smartcard.\n");
#endif /* SMARTCARD */

a639 1
	char *reader_id = NULL;
d642 1
a643 1
	int opt, type, fd, download = 0;
d662 1
a662 1
	while ((opt = getopt(ac, av, "deiqpclBRxXyb:f:t:U:D:P:N:C:")) != -1) {
d671 1
d675 1
d679 1
d683 1
d687 1
d692 1
d696 1
d700 1
d704 1
d708 1
d713 1
d719 1
d725 1
d729 1
d733 1
d737 1
a737 5
		case 'D':
			download = 1;
		case 'U':
			reader_id = optarg;
			break;
a762 10
	if (reader_id != NULL) {
#ifdef SMARTCARD
		if (download)
			do_download(pw, reader_id);
		else
			do_upload(pw, reader_id);
#else /* SMARTCARD */
		fatal("no support for smartcards.");
#endif /* SMARTCARD */
	}
d811 2
a812 4
			read_passphrase("Enter passphrase (empty for no "
			    "passphrase): ", RP_ALLOW_STDIN);
		passphrase2 = read_passphrase("Enter same passphrase again: ",
		    RP_ALLOW_STDIN);
d814 1
a814 4
			/*
			 * The passphrases do not match.  Clear them and
			 * retry.
			 */
@


1.60.2.2
log
@Merge OpenSSH 3.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.60.2.1 2001/09/27 19:03:55 jason Exp $");
a493 8

	memset(elements[0], '\0', BN_num_bytes(prv->rsa->q));
	memset(elements[1], '\0', BN_num_bytes(prv->rsa->p));
	memset(elements[2], '\0', BN_num_bytes(prv->rsa->iqmp));
	memset(elements[3], '\0', BN_num_bytes(prv->rsa->dmq1));
	memset(elements[4], '\0', BN_num_bytes(prv->rsa->dmp1));
	memset(elements[5], '\0', BN_num_bytes(prv->rsa->n));

@


1.60.2.3
log
@Merge OpenSSH 3.0.1.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.60.2.2 2001/11/15 00:15:19 miod Exp $");
d614 1
a614 1
		printf("%s is not a public key file.\n", identity_file);
@


1.60.2.4
log
@Merge OpenSSH 3.1, keeping /etc as configuration files directory.
(i.e. OpenSSH 3.1 + openbsd29_3.1.patch)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.94 2002/02/25 16:33:27 markus Exp $");
d76 2
a77 1
char *key_type_name = NULL;
d90 8
a97 1
	if (key_type_name == NULL)
d99 6
a104 17
	else
		switch (key_type_from_name(key_type_name)) {
		case KEY_RSA1:
			name = _PATH_SSH_CLIENT_IDENTITY;
			break;
		case KEY_DSA:
			name = _PATH_SSH_CLIENT_ID_DSA;
			break;
		case KEY_RSA:
			name = _PATH_SSH_CLIENT_ID_RSA;
			break;
		default:
			fprintf(stderr, "bad key type");
			exit(1);
			break;
		}

d146 1
a146 1
	u_int len;
d187 1
a187 1
	BN_bin2bn(buffer_ptr(b), bytes, value);
d192 1
a192 1
do_convert_private_ssh2_from_blob(u_char *blob, u_int blen)
d271 1
a271 1
	if (rlen != 0)
d332 1
a332 1
	blen = uudecode(encoded, blob, sizeof(blob));
d354 1
a354 2
	if (!private)
		fprintf(stdout, "\n");
d392 1
a392 1
	} while (0)
d533 1
a533 3
	int i, skip = 0, num = 1, invalid = 1;
	enum fp_rep rep;
	enum fp_type fptype;
d667 1
a667 1
		    RP_ALLOW_STDIN);
d745 1
a745 1
	}
d832 1
a832 1
	char dotsshdir[MAXPATHLEN], comment[1024], *passphrase1, *passphrase2;
a958 4
	if (key_type_name == NULL) {
		printf("You must specify a key type (-t).\n");
		usage();
	}
@


1.60.2.5
log
@Upgrade to OpenSSH 3.2.3.

Except for improbable compilation error fixes, this should be the last
commit made to the 2.9-STABLE branche. Have fun upgrading.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.98 2002/03/27 22:21:45 markus Exp $");
d32 2
a290 1
	u_int len;
a334 6
	len = strlen(encoded);
	if (((len % 4) == 3) &&
	    (encoded[len-1] == '=') &&
	    (encoded[len-2] == '=') &&
	    (encoded[len-3] == '='))
		encoded[len-3] = '\0';
d388 28
d421 6
a426 1
	int ret;
d428 2
d434 1
a434 1
		exit(1);
d439 35
a473 1
		exit(1);
d475 39
a513 6
	ret = sc_put_key(prv, sc_reader_id);
	key_free(prv);
	if (ret < 0)
		exit(1);
        log("loading key done");
	exit(0);
d519 1
a519 2
	Key **keys = NULL;
	int i;
d521 2
a522 2
	keys = sc_get_keys(sc_reader_id, NULL);
	if (keys == NULL)
d524 3
a526 6
	for (i = 0; keys[i]; i++) {
		key_write(keys[i], stdout);
		key_free(keys[i]);
		fprintf(stdout, "\n");
	}
	xfree(keys);
@


1.59
log
@allow public key for -e, too
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.58 2001/04/22 13:41:02 markus Exp $");
d297 1
a297 1
			fprintf(stderr, "ignore: %s", line);
d302 1
a302 1
			fprintf(stderr, "escaped: %s", line);
@


1.58
log
@style, noted by stevesk; sort flags in usage
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.57 2001/04/22 13:25:37 markus Exp $");
d135 1
a135 1
	Key *prv;
d146 5
a150 4
	prv = try_load_pem_key(identity_file);
	if (prv == NULL) {
		fprintf(stderr, "load failed\n");
		exit(1);
d152 1
a152 1
	key_to_blob(prv, &blob, &len);
d156 1
a156 1
	    key_size(prv), key_type(prv),
d160 1
a160 1
	key_free(prv);
@


1.57
log
@rename arguments -x -> -e (export key), -X -> -i (import key)
xref draft-ietf-secsh-publickeyfile-01.txt
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.56 2001/04/15 16:58:03 markus Exp $");
d627 1
a627 1
	printf("Usage: %s [-lBpqxiec] [-t type] [-b bits] [-f file] [-C comment] "
@


1.56
log
@don't use errno for key_{load,save}_private; discussion w/ solar@@openwall
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.55 2001/04/05 10:42:54 markus Exp $");
d627 1
a627 1
	printf("Usage: %s [-lBpqxXyc] [-t type] [-b bits] [-f file] [-C comment] "
d661 1
a661 1
	while ((opt = getopt(ac, av, "dqpclBRxXyb:f:t:P:N:C:")) != -1) {
d713 1
d715 1
d719 1
d721 1
@


1.55
log
@fix whitespace: unexpand + trailing spaces.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.54 2001/04/03 13:56:11 stevesk Exp $");
d511 1
a511 2
		printf("Saving the key failed: %s: %s.\n",
		       identity_file, strerror(errno));
d589 1
a589 2
		printf("Saving the key failed: %s: %s.\n",
		       identity_file, strerror(errno));
d831 1
a831 2
		printf("Saving the key failed: %s: %s.\n",
		    identity_file, strerror(errno));
@


1.54
log
@free() -> xfree()
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.53 2001/03/26 23:23:24 markus Exp $");
d117 1
a117 1
 	prv = key_load_private(filename, "", NULL);
@


1.53
log
@try to read private f-secure ssh v2 rsa keys.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.52 2001/03/26 08:07:09 markus Exp $");
d255 1
a255 1
		free(sig);
@


1.52
log
@simpler key load/save interface, see authfile.h
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.51 2001/03/21 14:20:45 jakob Exp $");
d22 1
d169 1
d171 2
a172 1
		fatal("buffer_get_bignum_bits: input buffer too small");
a180 1
	DSA *dsa;
d182 1
a182 1
	int ignore, magic, rlen;
a199 1
	xfree(type);
d205 1
d210 6
a215 6
	key = key_new(KEY_DSA);
	dsa = key->dsa;
	dsa->priv_key = BN_new();
	if (dsa->priv_key == NULL) {
		error("alloc priv_key failed");
		key_free(key);
d218 25
a242 5
	buffer_get_bignum_bits(&b, dsa->p);
	buffer_get_bignum_bits(&b, dsa->g);
	buffer_get_bignum_bits(&b, dsa->q);
	buffer_get_bignum_bits(&b, dsa->pub_key);
	buffer_get_bignum_bits(&b, dsa->priv_key);
d245 2
a246 1
		error("do_convert_private_ssh2_from_blob: remaining bytes in key blob %d", rlen);
d248 10
d320 3
a322 1
	    PEM_write_DSAPrivateKey(stdout, k->dsa, NULL, NULL, 0, NULL, NULL) :
@


1.51
log
@add -B flag to usage
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.50 2001/03/12 22:02:02 markus Exp $");
d110 2
a111 2
int
try_load_key(char *filename, Key *k)
d113 7
a119 6
	int success = 1;
	if (!load_private_key(filename, "", k, NULL)) {
		char *pass = read_passphrase("Enter passphrase: ", 1);
		if (!load_private_key(filename, pass, k, NULL)) {
			success = 0;
		}
d123 1
a123 1
	return success;
d134 1
a134 1
	Key *k;
d145 2
a146 2
	k = key_new(KEY_UNSPEC);
	if (!try_load_key(identity_file, k)) {
d150 1
a150 1
	key_to_blob(k, &blob, &len);
d154 1
a154 1
	    key_size(k), key_type(k),
d158 1
a158 1
	key_free(k);
d302 1
a302 1
	Key *k;
d311 2
a312 2
	k = key_new(KEY_UNSPEC);
	if (!try_load_key(identity_file, k)) {
d316 1
a316 1
	if (!key_write(k, stdout))
d318 1
a318 1
	key_free(k);
d329 1
a329 1
	int i, skip = 0, num = 1, invalid = 1, success = 0, rep, type;
d332 2
a333 2
	type = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
	rep =  print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
d341 4
a344 15
	public = key_new(KEY_RSA1);
	if (load_public_key(identity_file, public, &comment)) {
		success = 1;
	} else {
		key_free(public);
		public = key_new(KEY_UNSPEC);
		if (try_load_public_key(identity_file, public, &comment))
			success = 1;
		else
			debug("try_load_public_key KEY_UNSPEC failed");
	}
	if (success) {
		fp = key_fingerprint(public, type, rep);
		printf("%d %s %s\n", key_size(public),
		    fp, comment);
d350 2
d400 1
a400 1
			fp = key_fingerprint(public, type, rep);
d404 1
a408 1
	key_free(public);
a426 2
	Key *public;
	int type = KEY_RSA1;
a433 7
	public = key_new(type);
	if (!load_public_key(identity_file, public, NULL)) {
		type = KEY_UNSPEC;
	} else {
		/* Clear the public key since we are just about to load the whole file. */
		key_free(public);
	}
d435 2
a436 2
	private = key_new(type);
	if (!load_private_key(identity_file, "", private, &comment)) {
d441 4
a444 3
		if (!load_private_key(identity_file, old_passphrase, private, &comment)) {
			memset(old_passphrase, 0, strlen(old_passphrase));
			xfree(old_passphrase);
a447 2
		memset(old_passphrase, 0, strlen(old_passphrase));
		xfree(old_passphrase);
d475 1
a475 1
	if (!save_private_key(identity_file, passphrase1, private, comment)) {
d501 2
a502 1
	Key *private, *public;
d513 2
a514 15
	/*
	 * Try to load the public key from the file the verify that it is
	 * readable and of the proper format.
	 */
	public = key_new(KEY_RSA1);
	if (!load_public_key(identity_file, public, NULL)) {
		printf("%s is not a valid key file.\n", identity_file);
		printf("Comments are only supported in RSA1 keys\n");
		exit(1);
	}

	private = key_new(KEY_RSA1);
	if (load_private_key(identity_file, "", private, &comment))
		passphrase = xstrdup("");
	else {
d522 2
a523 1
		if (!load_private_key(identity_file, passphrase, private, &comment)) {
d529 2
d532 5
d554 1
a554 1
	if (!save_private_key(identity_file, passphrase, private, new_comment)) {
d565 1
d797 1
a797 1
	if (!save_private_key(identity_file, passphrase1, private, comment)) {
@


1.50
log
@remove old key_fingerprint interface, s/_ex//
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.49 2001/03/11 22:33:24 markus Exp $");
d615 1
a615 1
	printf("Usage: %s [-lpqxXyc] [-t type] [-b bits] [-f file] [-C comment] "
@


1.49
log
@remove -v again. use -B instead for bubblebabble. make -B consistent
with -l and make -B work with /path/to/known_hosts. ok deraadt@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.48 2001/03/11 16:39:03 deraadt Exp $");
d352 1
a352 1
		fp = key_fingerprint_ex(public, type, rep);
d408 1
a408 1
			fp = key_fingerprint_ex(public, type, rep);
d853 1
d857 2
a858 1
		printf("%s %s\n", key_fingerprint(public), comment);
@


1.48
log
@KNF, and SHA1 binary output is just creeping featurism
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.47 2001/03/11 15:04:16 jakob Exp $");
d49 1
a67 1
int print_verbose = 0;
a324 1

d327 2
a328 2
	char *comment = NULL, *cp, *ep, line[16*1024];
	int i, skip = 0, num = 1, invalid = 1, success = 0;
d331 3
d352 3
a354 15
		char *digest_md5, *digest_bubblebabble;

		digest_md5 = key_fingerprint_ex(public, SSH_FP_MD5, SSH_FP_HEX);
		digest_bubblebabble = key_fingerprint_ex(public, SSH_FP_SHA1,
		    SSH_FP_BUBBLEBABBLE);

		if (print_verbose) {
			printf("comment:      %s\n", comment);
			printf("size:         %d\n", key_size(public));
			printf("md5:          %s\n", digest_md5);
			printf("bubblebabble: %s\n", digest_bubblebabble);
		} else {
			printf("%d %s %s\n", key_size(public), digest_md5, comment);
		}

d357 1
a357 3
		xfree(digest_md5);
		xfree(digest_bubblebabble);

d408 2
a409 2
			printf("%d %s %s\n", key_size(public),
			    key_fingerprint(public),
d411 1
d649 1
a649 1
	while ((opt = getopt(ac, av, "dqpclRxXyvb:f:t:P:N:C:")) != -1) {
d663 4
a712 4
		case 'v':
			print_verbose = 1;
			break;

d734 1
a734 1
	if (print_fingerprint)
@


1.47
log
@print both md5, sha1 and bubblebabble fingerprints when using
ssh-keygen -l -v. ok markus@@.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.46 2001/03/09 03:14:39 deraadt Exp $");
d350 1
a350 1
		char *digest_md5, *digest_sha1, *digest_bubblebabble;
d353 2
a354 2
		digest_sha1 = key_fingerprint_ex(public, SSH_FP_SHA1, SSH_FP_HEX);
		digest_bubblebabble = key_fingerprint_ex(public, SSH_FP_SHA1, SSH_FP_BUBBLEBABBLE);
d356 1
a356 1
		if(print_verbose) {
a359 1
			printf("sha1:         %s\n", digest_sha1);
a367 1
		xfree(digest_sha1);
@


1.46
log
@create *.pub files with umask 0644, so that you can mv them to authorized_keys
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.45 2001/02/22 08:03:51 deraadt Exp $");
d67 1
d350 16
a365 1
		printf("%d %s %s\n", key_size(public), key_fingerprint(public), comment);
d368 4
d662 1
a662 1
	while ((opt = getopt(ac, av, "dqpclRxXyb:f:t:P:N:C:")) != -1) {
d720 4
@


1.45
log
@bye bye -d
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.44 2001/02/22 06:43:55 deraadt Exp $");
d511 2
a512 4
	char new_comment[1024], *comment;
	Key *private;
	Key *public;
	char *passphrase;
d515 1
d583 2
a584 2
	f = fopen(identity_file, "w");
	if (!f) {
d588 5
d620 1
d622 1
a622 1
	int opt, type;
a624 2
	Key *private;
	Key *public;
d826 2
a827 2
	f = fopen(identity_file, "w");
	if (!f) {
d829 5
@


1.44
log
@document -d, and -t defaults to rsa1
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.43 2001/02/12 16:16:23 markus Exp $");
d604 1
a604 1
	printf("Usage: %s [-lpqxXycd] [-t type] [-b bits] [-f file] [-C comment] "
@


1.43
log
@PermitRootLogin={yes,without-password,forced-commands-only,no}
(before this change, root could login even if PermitRootLogin==no)
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.42 2001/02/04 15:32:26 stevesk Exp $");
d604 2
a605 1
	printf("Usage: %s [-lpqxXyc] [-t type] [-b bits] [-f file] [-C comment] [-N new-pass] [-P pass]\n", __progname);
@


1.42
log
@unexpand and remove end-of-line whitespace; ok markus@@
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.41 2001/01/21 19:05:57 markus Exp $");
d531 1
@


1.41
log
@split ssh.h and try to cleanup the #include mess. remove unnecessary #includes.
rename util.[ch] -> misc.[ch]
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.40 2001/01/19 15:55:11 markus Exp $");
d127 1
a127 1
#define	SSH_COM_PRIVATE_KEY_MAGIC	0x3f6ff9eb                                          
@


1.40
log
@move ssh1 definitions to ssh1.h, pathnames to pathnames.h
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.39 2001/01/13 18:03:07 markus Exp $");
a18 2
#include <openssl/rsa.h>
#include <openssl/dsa.h>
a19 1
#include "ssh.h"
a21 1
#include "rsa.h"
a23 1

d27 2
@


1.39
log
@getopt() returns -1 not EOF; stevesk@@pobox.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.38 2000/12/28 18:58:39 markus Exp $");
d31 1
d87 1
a87 1
		name = SSH_CLIENT_IDENTITY;
d90 1
a90 1
		name = SSH_CLIENT_ID_DSA;
d93 1
a93 1
		name = SSH_CLIENT_ID_RSA;
d754 1
a754 1
	snprintf(dotsshdir, sizeof dotsshdir, "%s/%s", pw->pw_dir, SSH_USER_DIR);
@


1.38
log
@enable 'ssh-keygen -l -f ~/.ssh/{authorized_keys,known_hosts}{,2}'
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.37 2000/12/22 16:49:40 markus Exp $");
d639 1
a639 1
	while ((opt = getopt(ac, av, "dqpclRxXyb:f:t:P:N:C:")) != EOF) {
@


1.37
log
@fix ssh-keygen -x -t type > file; from Roumen.Petrov@@skalasoft.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.36 2000/12/19 23:17:58 markus Exp $");
a330 1
	u_int ignore;
d348 1
a348 1
			error("try_load_public_key KEY_UNSPEC failed");
a356 3
	/* XXX RSA1 only */

	public = key_new(KEY_RSA1);
d393 9
a401 6
			if (auth_rsa_read_key(&cp, &ignore, public->rsa->e, public->rsa->n)) {
				invalid = 0;
				comment = *cp ? cp : comment;
				printf("%d %s %s\n", key_size(public),
				    key_fingerprint(public),
				    comment ? comment : "no comment");
d403 5
@


1.36
log
@replace 'unsigned bla' with 'u_bla' everywhere. also, replace 'char unsigned'
with u_char.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.35 2000/11/25 17:19:33 markus Exp $");
d100 2
a101 2
	printf("%s (%s): ", prompt, identity_file);
	fflush(stdout);
@


1.35
log
@print keytype when generating a key.
reasonable defaults for RSA1/RSA/DSA keys.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.34 2000/11/15 20:24:43 millert Exp $");
d136 1
a136 1
	unsigned char *blob;
d170 1
a170 1
	BN_bin2bn((unsigned char *)buffer_ptr(b), bytes, value);
d274 1
a274 1
	blen = uudecode(encoded, (unsigned char *)blob, sizeof(blob));
d331 1
a331 1
	unsigned int ignore;
@


1.34
log
@Add missing \n at the end of an error message.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.33 2000/11/12 19:50:38 markus Exp $");
d70 2
a71 3
/* key type */
int dsa_mode = 0;		/* compat */
char *key_type_name = NULL;
d82 18
a99 3
	snprintf(identity_file, sizeof(identity_file), "%s/%s",
	    pw->pw_dir,
	    dsa_mode ? SSH_CLIENT_ID_DSA: SSH_CLIENT_IDENTITY);
d613 1
a613 1
	int opt;
a615 1
	int type = KEY_RSA1;
a696 1
			dsa_mode = 1;
a700 1
			dsa_mode = (strcmp(optarg, "dsa") == 0);
d731 4
a734 6
	if (key_type_name != NULL) {
		type = key_type_from_name(key_type_name);
		if (type == KEY_UNSPEC) {
			fprintf(stderr, "unknown key type %s\n", key_type_name);
			exit(1);
		}
d737 1
a737 1
		printf("Generating public/private key pair.\n");
@


1.33
log
@add support for RSA to SSH2.  please test.

there are now 3 types of keys: RSA1 is used by ssh-1 only,
RSA and DSA are used by SSH2.

you can use 'ssh-keygen -t rsa -f ssh2_rsa_file' to generate RSA
keys for SSH2 and use the RSA keys for hostkeys or for user keys.

SSH2 RSA or DSA keys are added to .ssh/authorised_keys2 as before.

IdentityFile2, HostDsaKey and DSAAuthentication are obsolete.
you can use multiple IdentityFile and HostKey for all types of keys.

the option DSAAuthentication is replaced by PubkeyAuthetication.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.32 2000/10/09 21:30:44 markus Exp $");
d723 1
a723 1
			fprintf(stderr, "unknown key type %s", key_type_name);
@


1.32
log
@-X now reads private ssh.com DSA keys, too.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.31 2000/09/07 20:27:54 deraadt Exp $");
a25 1
#include "dsa.h"
d69 4
a72 1
int dsa_mode = 0;
d131 1
a131 1
	k = key_new(KEY_DSA);
d136 1
a136 1
	dsa_make_key_blob(k, &blob, &len);
d267 1
a267 1
	    dsa_key_from_blob(blob, blen);
a288 2
	int len;
	unsigned char *blob;
d297 1
a297 1
	k = key_new(KEY_DSA);
a301 1
	dsa_make_key_blob(k, &blob, &len);
a304 1
	xfree(blob);
a311 1
	/* XXX RSA1 only */
d316 1
a316 1
	int i, skip = 0, num = 1, invalid = 1;
d326 1
a326 1
	public = key_new(KEY_RSA);
d328 2
a329 2
		printf("%d %s %s\n", BN_num_bits(public->rsa->n),
		    key_fingerprint(public), comment);
d331 10
d344 3
d413 1
a413 1
	int type = dsa_mode ? KEY_DSA : KEY_RSA;
d421 4
a424 8

	if (type == KEY_RSA) {
		/* XXX this works currently only for RSA */
		public = key_new(type);
		if (!load_public_key(identity_file, public, NULL)) {
			printf("%s is not a valid key file.\n", identity_file);
			exit(1);
		}
a427 1

d512 1
a512 1
	public = key_new(KEY_RSA);
d518 1
a518 1
	private = key_new(KEY_RSA);
d587 1
a587 1
	printf("Usage: %s [-lpqxXydc] [-b bits] [-f file] [-C comment] [-N new-pass] [-P pass]\n", __progname);
d602 1
d605 1
d622 1
a622 1
	while ((opt = getopt(ac, av, "dqpclRxXyb:f:P:N:C:")) != EOF) {
d666 2
a667 4
			if (rsa_alive() == 0)
				exit(1);
			else
				exit(0);
d683 1
d687 5
a704 7
	/* check if RSA support is needed and exists */
	if (dsa_mode == 0 && rsa_alive() == 0) {
		fprintf(stderr,
			"%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
			__progname);
		exit(1);
	}
d720 4
a723 6
	if (dsa_mode != 0) {
		if (!quiet)
			printf("Generating DSA parameter and key.\n");
		public = private = dsa_generate_key(bits);
		if (private == NULL) {
			fprintf(stderr, "dsa_generate_keys failed");
a725 7
	} else {
		if (quiet)
			rsa_set_verbose(0);
		/* Generate the rsa key pair. */
		public = key_new(KEY_RSA);
		private = key_new(KEY_RSA);
		rsa_generate_key(private->rsa, public->rsa, bits);
d727 8
d803 1
a803 3
	if (private != public) {
		key_free(private);
	}
@


1.32.2.1
log
@Pull in OpenSSH 2.5.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.43 2001/02/12 16:16:23 markus Exp $");
d19 2
d22 1
d25 2
d29 1
a31 3
#include "pathnames.h"
#include "log.h"
#include "readpass.h"
d70 1
a70 3

/* default to RSA for SSH-1 */
char *key_type_name = "rsa1";
d81 5
a85 20
	char *name = NULL;

	switch (key_type_from_name(key_type_name)) {
	case KEY_RSA1:
		name = _PATH_SSH_CLIENT_IDENTITY;
		break;
	case KEY_DSA:
		name = _PATH_SSH_CLIENT_ID_DSA;
		break;
	case KEY_RSA:
		name = _PATH_SSH_CLIENT_ID_RSA;
		break;
	default:
		fprintf(stderr, "bad key type");
		exit(1);
		break;
	}
	snprintf(identity_file, sizeof(identity_file), "%s/%s", pw->pw_dir, name);
	fprintf(stderr, "%s (%s): ", prompt, identity_file);
	fflush(stderr);
d113 1
a113 1
#define	SSH_COM_PRIVATE_KEY_MAGIC	0x3f6ff9eb
d120 1
a120 1
	u_char *blob;
d129 1
a129 1
	k = key_new(KEY_UNSPEC);
d134 1
a134 1
	key_to_blob(k, &blob, &len);
d154 1
a154 1
	BN_bin2bn((u_char *)buffer_ptr(b), bytes, value);
d258 1
a258 1
	blen = uudecode(encoded, (u_char *)blob, sizeof(blob));
d265 1
a265 1
	    key_from_blob(blob, blen);
d287 2
d297 1
a297 1
	k = key_new(KEY_UNSPEC);
d302 1
d306 1
d314 1
d319 2
a320 1
	int i, skip = 0, num = 1, invalid = 1, success = 0;
d329 1
a329 1
	public = key_new(KEY_RSA1);
d331 2
a332 11
		success = 1;
	} else {
		key_free(public);
		public = key_new(KEY_UNSPEC);
		if (try_load_public_key(identity_file, public, &comment))
			success = 1;
		else
			debug("try_load_public_key KEY_UNSPEC failed");
	}
	if (success) {
		printf("%d %s %s\n", key_size(public), key_fingerprint(public), comment);
a333 1
		xfree(comment);
d373 6
a378 9
			public = key_new(KEY_RSA1);
			if (key_read(public, &cp) != 1) {
				cp = ep;
				key_free(public);
				public = key_new(KEY_UNSPEC);
				if (key_read(public, &cp) != 1) {
					key_free(public);
					continue;
				}
a379 5
			comment = *cp ? cp : comment;
			printf("%d %s %s\n", key_size(public),
			    key_fingerprint(public),
			    comment ? comment : "no comment");
			invalid = 0;
d403 1
a403 1
	int type = KEY_RSA1;
d411 8
a418 4
	public = key_new(type);
	if (!load_public_key(identity_file, public, NULL)) {
		type = KEY_UNSPEC;
	} else {
d422 1
d507 1
a507 1
	public = key_new(KEY_RSA1);
a509 1
		printf("Comments are only supported in RSA1 keys\n");
d513 1
a513 1
	private = key_new(KEY_RSA1);
d582 1
a582 1
	printf("Usage: %s [-lpqxXyc] [-t type] [-b bits] [-f file] [-C comment] [-N new-pass] [-P pass]\n", __progname);
d594 1
a594 1
	int opt, type;
a598 1

d615 1
a615 1
	while ((opt = getopt(ac, av, "dqpclRxXyb:f:t:P:N:C:")) != -1) {
d659 4
a662 2
			/* unused */
			exit(0);
d678 1
a678 5
			key_type_name = "dsa";
			break;

		case 't':
			key_type_name = optarg;
d694 7
d716 15
a730 11
	type = key_type_from_name(key_type_name);
	if (type == KEY_UNSPEC) {
		fprintf(stderr, "unknown key type %s\n", key_type_name);
		exit(1);
	}
	if (!quiet)
		printf("Generating public/private %s key pair.\n", key_type_name);
	private = key_generate(type, bits);
	if (private == NULL) {
		fprintf(stderr, "key_generate failed");
		exit(1);
a731 1
	public  = key_from_private(private);
d737 1
a737 1
	snprintf(dotsshdir, sizeof dotsshdir, "%s/%s", pw->pw_dir, _PATH_SSH_USER_DIR);
d800 3
a802 1
	key_free(private);
@


1.32.2.2
log
@Pull in OpenSSH-2.5.1
@
text
@@


1.32.2.3
log
@Pull in OpenSSH-2.5.2 for 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.50 2001/03/12 22:02:02 markus Exp $");
a48 1
int print_bubblebabble = 0;
d324 1
d327 2
a328 2
	char *comment = NULL, *cp, *ep, line[16*1024], *fp;
	int i, skip = 0, num = 1, invalid = 1, success = 0, rep, type;
a330 3
	type = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
	rep =  print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;

d349 1
a349 3
		fp = key_fingerprint(public, type, rep);
		printf("%d %s %s\n", key_size(public),
		    fp, comment);
a351 1
		xfree(fp);
d402 2
a403 2
			fp = key_fingerprint(public, type, rep);
			printf("%d %s %s\n", key_size(public), fp,
a404 1
			xfree(fp);
d511 4
a514 2
	char new_comment[1024], *comment, *passphrase;
	Key *private, *public;
a516 1
	int fd;
d584 2
a585 2
	fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
a588 5
	f = fdopen(fd, "w");
	if (f == NULL) {
		printf("fdopen %s failed", identity_file);
		exit(1);
	}
d604 1
a604 2
	printf("Usage: %s [-lpqxXyc] [-t type] [-b bits] [-f file] [-C comment] "
	    "[-N new-pass] [-P pass]\n", __progname);
a614 1
	Key *private, *public;
d616 1
a616 1
	int opt, type, fd;
d619 2
d638 1
a638 1
	while ((opt = getopt(ac, av, "dqpclBRxXyb:f:t:P:N:C:")) != -1) {
a651 4
		case 'B':
			print_bubblebabble = 1;
			break;

d719 1
a719 1
	if (print_fingerprint || print_bubblebabble)
d822 2
a823 2
	fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
a826 5
	f = fdopen(fd, "w");
	if (f == NULL) {
		printf("fdopen %s failed", identity_file);
		exit(1);
	}
a832 1
		char *fp = key_fingerprint(public, SSH_FP_MD5, SSH_FP_HEX);
d836 1
a836 2
		printf("%s %s\n", fp, comment);
		xfree(fp);
@


1.32.2.4
log
@Pull in OpenSSH-2.9 to 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.60 2001/04/23 22:14:13 markus Exp $");
a21 1
#include "rsa.h"
d110 2
a111 2
Key *
try_load_pem_key(char *filename)
d113 6
a118 7
	char *pass;
	Key *prv;

	prv = key_load_private(filename, "", NULL);
	if (prv == NULL) {
		pass = read_passphrase("Enter passphrase: ", 1);
		prv = key_load_private(filename, pass, NULL);
d122 1
a122 1
	return prv;
d144 4
a147 5
	if ((k = key_load_public(identity_file, NULL)) == NULL) {
		if ((k = try_load_pem_key(identity_file)) == NULL) {
			fprintf(stderr, "load failed\n");
			exit(1);
		}
a166 1

d168 1
a168 2
		fatal("buffer_get_bignum_bits: input buffer too small: "
		    "need %d have %d", bytes, buffer_len(b));
d177 1
d179 1
a179 1
	int ignore, magic, rlen, ktype;
d197 1
a202 1
		xfree(type);
d207 6
a212 6
	if (strstr(type, "dsa")) {
		ktype = KEY_DSA;
	} else if (strstr(type, "rsa")) {
		ktype = KEY_RSA;
	} else {
		xfree(type);
d215 5
a219 25
	key = key_new_private(ktype);
	xfree(type);

	switch (key->type) {
	case KEY_DSA:
		buffer_get_bignum_bits(&b, key->dsa->p);
		buffer_get_bignum_bits(&b, key->dsa->g);
		buffer_get_bignum_bits(&b, key->dsa->q);
		buffer_get_bignum_bits(&b, key->dsa->pub_key);
		buffer_get_bignum_bits(&b, key->dsa->priv_key);
		break;
	case KEY_RSA:
		if (!BN_set_word(key->rsa->e, (u_long) buffer_get_char(&b))) {
			buffer_free(&b);
			key_free(key);
			return NULL;
		}
		buffer_get_bignum_bits(&b, key->rsa->d);
		buffer_get_bignum_bits(&b, key->rsa->n);
		buffer_get_bignum_bits(&b, key->rsa->iqmp);
		buffer_get_bignum_bits(&b, key->rsa->q);
		buffer_get_bignum_bits(&b, key->rsa->p);
		generate_additional_parameters(key->rsa);
		break;
	}
d222 1
a222 2
		error("do_convert_private_ssh2_from_blob: "
		    "remaining bytes in key blob %d", rlen);
a223 10
#ifdef DEBUG_PK
	{
		u_int slen;
		u_char *sig, data[10] = "abcde12345";

		key_sign(key, &sig, &slen, data, sizeof data);
		key_verify(key, sig, slen, data, sizeof data);
		xfree(sig);
	}
#endif
d262 1
a262 1
			/* fprintf(stderr, "ignore: %s", line); */
d267 1
a267 1
			/* fprintf(stderr, "escaped: %s", line); */
d286 1
a286 3
	    (k->type == KEY_DSA ?
		 PEM_write_DSAPrivateKey(stdout, k->dsa, NULL, NULL, 0, NULL, NULL) :
		 PEM_write_RSAPrivateKey(stdout, k->rsa, NULL, NULL, 0, NULL, NULL)) :
d301 1
a301 1
	Key *prv;
d310 2
a311 2
	prv = try_load_pem_key(identity_file);
	if (prv == NULL) {
d315 1
a315 1
	if (!key_write(prv, stdout))
d317 1
a317 1
	key_free(prv);
d328 1
a328 1
	int i, skip = 0, num = 1, invalid = 1, rep, fptype;
d331 2
a332 2
	fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
d340 15
a354 4
	public = key_load_public(identity_file, &comment);
	if (public != NULL) {
		fp = key_fingerprint(public, fptype, rep);
		printf("%d %s %s\n", key_size(public), fp, comment);
a359 2
	if (comment)
		xfree(comment);
d408 1
a408 1
			fp = key_fingerprint(public, fptype, rep);
a411 1
			key_free(public);
d416 1
d435 2
d444 7
d452 2
a453 2
	private = key_load_private(identity_file, "", &comment);
	if (private == NULL) {
d458 3
a460 4
		private = key_load_private(identity_file, old_passphrase , &comment);
		memset(old_passphrase, 0, strlen(old_passphrase));
		xfree(old_passphrase);
		if (private == NULL) {
d464 2
d493 3
a495 2
	if (!key_save_private(private, identity_file, passphrase1, comment)) {
		printf("Saving the key failed: %s.\n", identity_file);
d519 1
a519 2
	Key *private;
	Key *public;
d530 15
a544 2
	private = key_load_private(identity_file, "", &comment);
	if (private == NULL) {
d552 1
a552 2
		private = key_load_private(identity_file, passphrase, &comment);
		if (private == NULL) {
a557 2
	} else {
		passphrase = xstrdup("");
a558 5
	if (private->type != KEY_RSA1) {
		fprintf(stderr, "Comments are only supported for RSA1 keys.\n");
		key_free(private);
		exit(1);
	}	
d576 3
a578 2
	if (!key_save_private(private, identity_file, passphrase, new_comment)) {
		printf("Saving the key failed: %s.\n", identity_file);
a586 1
	public = key_from_private(private);
d615 1
a615 1
	printf("Usage: %s [-ceilpqyB] [-t type] [-b bits] [-f file] [-C comment] "
d649 1
a649 1
	while ((opt = getopt(ac, av, "deiqpclBRxXyb:f:t:P:N:C:")) != -1) {
a700 1
		case 'e':
a701 1
			/* export key */
a704 1
		case 'i':
a705 1
			/* import key */
d818 3
a820 2
	if (!key_save_private(private, identity_file, passphrase1, comment)) {
		printf("Saving the key failed: %s.\n", identity_file);
@


1.32.2.5
log
@Pull in OpenSSH 2.9.9 to the 2.8 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.81 2001/09/17 20:50:22 markus Exp $");
a30 6
#ifdef SMARTCARD
#include <sectok.h>
#include <openssl/engine.h>
#include "scard.h"
#endif

d78 1
a78 1
static void
d111 2
a112 2
static Key *
load_identity(char *filename)
d119 1
a119 5
		if (identity_passphrase)
			pass = xstrdup(identity_passphrase);
		else
			pass = read_passphrase("Enter passphrase: ",
			    RP_ALLOW_STDIN);
d132 1
a132 1
static void
d147 1
a147 1
		if ((k = load_identity(identity_file)) == NULL) {
d152 1
a152 4
	if (key_to_blob(k, &blob, &len) <= 0) {
		fprintf(stderr, "key_to_blob failed\n");
		exit(1);
	}
d165 1
a165 1
static void
d178 2
a179 2
static Key *
do_convert_private_ssh2_from_blob(u_char *blob, int blen)
d183 1
a184 4
	u_char *sig, data[] = "abcde12345";
	int magic, rlen, ktype, i1, i2, i3, i4;
	u_int slen;
	u_long e;
d195 1
a195 1
	i1 = buffer_get_int(&b);
d198 4
a201 4
	i2 = buffer_get_int(&b);
	i3 = buffer_get_int(&b);
	i4 = buffer_get_int(&b);
	debug("ignore (%d %d %d %d)", i1,i2,i3,i4);
d231 1
a231 11
		e  = buffer_get_char(&b);
		debug("e %lx", e);
		if (e < 30) {
			e <<= 8;
			e += buffer_get_char(&b);
			debug("e %lx", e);
			e <<= 8;
			e += buffer_get_char(&b);
			debug("e %lx", e);
		}
		if (!BN_set_word(key->rsa->e, e)) {
d241 1
a241 1
		rsa_generate_additional_parameters(key->rsa);
d249 10
a258 5

	/* try the key */
	key_sign(key, &sig, &slen, data, sizeof(data));
	key_verify(key, sig, slen, data, sizeof(data));
	xfree(sig);
d262 1
a262 1
static void
d268 1
a268 1
	u_char blob[8096];
a296 3
			if (strstr(line, " END ") != NULL) {
				break;
			}
d335 1
a335 1
static void
d347 1
a347 1
	prv = load_identity(identity_file);
d359 1
a359 137
#ifdef SMARTCARD
#define NUM_RSA_KEY_ELEMENTS 5+1
#define COPY_RSA_KEY(x, i) \
	do { \
		len = BN_num_bytes(prv->rsa->x); \
		elements[i] = xmalloc(len); \
		debug("#bytes %d", len); \
		if (BN_bn2bin(prv->rsa->x, elements[i]) < 0) \
			goto done; \
	} while(0)

static int
get_AUT0(char *aut0)
{
	EVP_MD *evp_md = EVP_sha1();
	EVP_MD_CTX md;
	char *pass;

	pass = read_passphrase("Enter passphrase for smartcard: ", RP_ALLOW_STDIN);
	if (pass == NULL)
		return -1;
	EVP_DigestInit(&md, evp_md);
	EVP_DigestUpdate(&md, pass, strlen(pass));
	EVP_DigestFinal(&md, aut0, NULL);
	memset(pass, 0, strlen(pass));
	xfree(pass);
	return 0;
}

static void
do_upload(struct passwd *pw, const char *sc_reader_id)
{
	Key *prv = NULL;
	struct stat st;
	u_char *elements[NUM_RSA_KEY_ELEMENTS];
	u_char key_fid[2];
	u_char DEFAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};
	u_char AUT0[EVP_MAX_MD_SIZE];
	int len, status = 1, i, fd = -1, ret;
	int sw = 0, cla = 0x00;

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		elements[i] = NULL;
	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		goto done;
	}
	prv = load_identity(identity_file);
	if (prv == NULL) {
		error("load failed");
		goto done;
	}
	COPY_RSA_KEY(q, 0);
	COPY_RSA_KEY(p, 1);
	COPY_RSA_KEY(iqmp, 2);
	COPY_RSA_KEY(dmq1, 3);
	COPY_RSA_KEY(dmp1, 4);
	COPY_RSA_KEY(n, 5);
	len = BN_num_bytes(prv->rsa->n);
	fd = sectok_friendly_open(sc_reader_id, STONOWAIT, &sw);
	if (fd < 0) {
		error("sectok_open failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (! sectok_cardpresent(fd)) {
		error("smartcard in reader %s not present",
		    sc_reader_id);
		goto done;
	}
	ret = sectok_reset(fd, 0, NULL, &sw);
	if (ret <= 0) {
		error("sectok_reset failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if ((cla = cyberflex_inq_class(fd)) < 0) {
		error("cyberflex_inq_class failed");
		goto done;
	}
	memcpy(AUT0, DEFAUT0, sizeof(DEFAUT0));
	if (cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
		if (get_AUT0(AUT0) < 0 ||
		    cyberflex_verify_AUT0(fd, cla, AUT0, sizeof(DEFAUT0)) < 0) {
			error("cyberflex_verify_AUT0 failed");
			goto done;
		}
	}
	key_fid[0] = 0x00;
	key_fid[1] = 0x12;
	if (cyberflex_load_rsa_priv(fd, cla, key_fid, 5, 8*len, elements,
	    &sw) < 0) {
		error("cyberflex_load_rsa_priv failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_priv done");
	key_fid[0] = 0x73;
	key_fid[1] = 0x68;
	if (cyberflex_load_rsa_pub(fd, cla, key_fid, len, elements[5],
	    &sw) < 0) {
		error("cyberflex_load_rsa_pub failed: %s", sectok_get_sw(sw));
		goto done;
	}
	if (!sectok_swOK(sw))
		goto done;
	log("cyberflex_load_rsa_pub done");
	status = 0;
	log("loading key done");
done:
	if (prv)
		key_free(prv);
	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		if (elements[i])
			xfree(elements[i]);
	if (fd != -1)
		sectok_close(fd);
	exit(status);
}

static void
do_download(struct passwd *pw, const char *sc_reader_id)
{
	Key *pub = NULL;

	pub = sc_get_key(sc_reader_id);
	if (pub == NULL)
		fatal("cannot read public key from smartcard");
	key_write(pub, stdout);
	key_free(pub);
	fprintf(stdout, "\n");
	exit(0);
}
#endif /* SMARTCARD */

static void
d456 1
a456 1
static void
d476 2
a477 5
			old_passphrase =
			    read_passphrase("Enter old passphrase: ",
			    RP_ALLOW_STDIN);
		private = key_load_private(identity_file, old_passphrase,
		    &comment);
d493 2
a494 4
			read_passphrase("Enter new passphrase (empty for no "
			    "passphrase): ", RP_ALLOW_STDIN);
		passphrase2 = read_passphrase("Enter same passphrase again: ",
		     RP_ALLOW_STDIN);
d532 1
a532 1
static void
d555 1
a555 2
			passphrase = read_passphrase("Enter passphrase: ",
			    RP_ALLOW_STDIN);
d625 1
a625 1
static void
d628 2
a629 21
	fprintf(stderr, "Usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -b bits     Number of bits in the key to create.\n");
	fprintf(stderr, "  -c          Change comment in private and public key files.\n");
	fprintf(stderr, "  -e          Convert OpenSSH to IETF SECSH key file.\n");
	fprintf(stderr, "  -f filename Filename of the key file.\n");
	fprintf(stderr, "  -i          Convert IETF SECSH to OpenSSH key file.\n");
	fprintf(stderr, "  -l          Show fingerprint of key file.\n");
	fprintf(stderr, "  -p          Change passphrase of private key file.\n");
	fprintf(stderr, "  -q          Quiet.\n");
	fprintf(stderr, "  -y          Read private key file and print public key.\n");
	fprintf(stderr, "  -t type     Specify type of key to create.\n");
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
	fprintf(stderr, "  -C comment  Provide new comment.\n");
	fprintf(stderr, "  -N phrase   Provide new passphrase.\n");
	fprintf(stderr, "  -P phrase   Provide old passphrase.\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
	fprintf(stderr, "  -U reader   Upload private key to smartcard.\n");
#endif /* SMARTCARD */

a639 1
	char *reader_id = NULL;
d642 1
a643 1
	int opt, type, fd, download = 0;
d662 1
a662 1
	while ((opt = getopt(ac, av, "deiqpclBRxXyb:f:t:U:D:P:N:C:")) != -1) {
d671 1
d675 1
d679 1
d683 1
d687 1
d692 1
d696 1
d700 1
d704 1
d708 1
d713 1
d719 1
d725 1
d729 1
d733 1
d737 1
a737 5
		case 'D':
			download = 1;
		case 'U':
			reader_id = optarg;
			break;
a762 10
	if (reader_id != NULL) {
#ifdef SMARTCARD
		if (download)
			do_download(pw, reader_id);
		else
			do_upload(pw, reader_id);
#else /* SMARTCARD */
		fatal("no support for smartcards.");
#endif /* SMARTCARD */
	}
d811 2
a812 4
			read_passphrase("Enter passphrase (empty for no "
			    "passphrase): ", RP_ALLOW_STDIN);
		passphrase2 = read_passphrase("Enter same passphrase again: ",
		    RP_ALLOW_STDIN);
d814 1
a814 4
			/*
			 * The passphrases do not match.  Clear them and
			 * retry.
			 */
@


1.32.2.6
log
@Merge OpenSSH 3.0
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.32.2.5 2001/09/27 00:15:42 miod Exp $");
a493 8

	memset(elements[0], '\0', BN_num_bytes(prv->rsa->q));
	memset(elements[1], '\0', BN_num_bytes(prv->rsa->p));
	memset(elements[2], '\0', BN_num_bytes(prv->rsa->iqmp));
	memset(elements[3], '\0', BN_num_bytes(prv->rsa->dmq1));
	memset(elements[4], '\0', BN_num_bytes(prv->rsa->dmp1));
	memset(elements[5], '\0', BN_num_bytes(prv->rsa->n));

@


1.32.2.7
log
@Merge OpenSSH 3.0.1.

This is likely to be the last commit to the 2.8-STABLE branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.32.2.6 2001/11/15 00:15:00 miod Exp $");
d614 1
a614 1
		printf("%s is not a public key file.\n", identity_file);
@


1.32.2.8
log
@Merge OpenSSH 3.1.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.94 2002/02/25 16:33:27 markus Exp $");
d76 2
a77 1
char *key_type_name = NULL;
d90 8
a97 1
	if (key_type_name == NULL)
d99 6
a104 17
	else
		switch (key_type_from_name(key_type_name)) {
		case KEY_RSA1:
			name = _PATH_SSH_CLIENT_IDENTITY;
			break;
		case KEY_DSA:
			name = _PATH_SSH_CLIENT_ID_DSA;
			break;
		case KEY_RSA:
			name = _PATH_SSH_CLIENT_ID_RSA;
			break;
		default:
			fprintf(stderr, "bad key type");
			exit(1);
			break;
		}

d146 1
a146 1
	u_int len;
d187 1
a187 1
	BN_bin2bn(buffer_ptr(b), bytes, value);
d192 1
a192 1
do_convert_private_ssh2_from_blob(u_char *blob, u_int blen)
d271 1
a271 1
	if (rlen != 0)
d332 1
a332 1
	blen = uudecode(encoded, blob, sizeof(blob));
d354 1
a354 2
	if (!private)
		fprintf(stdout, "\n");
d392 1
a392 1
	} while (0)
d533 1
a533 3
	int i, skip = 0, num = 1, invalid = 1;
	enum fp_rep rep;
	enum fp_type fptype;
d667 1
a667 1
		    RP_ALLOW_STDIN);
d745 1
a745 1
	}
d832 1
a832 1
	char dotsshdir[MAXPATHLEN], comment[1024], *passphrase1, *passphrase2;
a958 4
	if (key_type_name == NULL) {
		printf("You must specify a key type (-t).\n");
		usage();
	}
@


1.31
log
@cleanup copyright notices on all files.  I have attempted to be accurate with
the details.  everything is now under Tatu's licence (which I copied from his
readme), and/or the core-sdi bsd-ish thing for deattack, or various openbsd
developers under a 2-term bsd licence.  We're not changing any rules, just
being accurate.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.30 2000/08/19 21:34:43 markus Exp $");
d30 3
d110 4
a113 2
#define SSH_COM_MAGIC_BEGIN "---- BEGIN SSH2 PUBLIC KEY ----"
#define SSH_COM_MAGIC_END   "---- END SSH2 PUBLIC KEY ----"
d135 1
a135 1
	fprintf(stdout, "%s\n", SSH_COM_MAGIC_BEGIN);
d137 2
a138 2
	    "Comment: \"%d-bit DSA, converted from openssh by %s@@%s\"\n",
	    BN_num_bits(k->dsa->p),
d141 1
a141 1
	fprintf(stdout, "%s\n", SSH_COM_MAGIC_END);
d148 65
d221 1
a221 1
	int escaped = 0;
d245 2
d263 14
a276 3
	k = dsa_key_from_blob(blob, blen);
	if (!key_write(k, stdout))
		fprintf(stderr, "key_write failed");
@


1.30
log
@add SSH2/DSA support to the agent and some other DSA related cleanups.
(note that we cannot talk to ssh.com's ssh2 agents)
@
text
@a4 1
 * Created: Mon Mar 27 02:26:40 1995 ylo
d6 6
d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.29 2000/07/15 04:01:37 djm Exp $");
@


1.29
log
@Always create ~/.ssh with mode 700; ok Markus
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.28 2000/07/07 03:55:04 todd Exp $");
a18 1
#include "fingerprint.h"
d226 2
a228 1
	BIGNUM *e, *n;
a247 1
	key_free(public);
a248 1
	/* XXX */
a250 2
		n = BN_new();
		e = BN_new();
d285 1
a285 1
			if (auth_rsa_read_key(&cp, &ignore, e, n)) {
d288 2
a289 2
				printf("%d %s %s\n", BN_num_bits(n),
				    fingerprint(e, n),
a292 2
		BN_free(e);
		BN_free(n);
d295 1
@


1.28
log
@clean code is good code
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.26 2000/05/30 17:32:06 markus Exp $");
d657 1
a657 1
		if (mkdir(dotsshdir, 0755) < 0)
@


1.27
log
@OpenBSD tag
@
text
@d126 1
a126 1
	fprintf(stdout, SSH_COM_MAGIC_BEGIN "\n");
d132 1
a132 1
	fprintf(stdout, SSH_COM_MAGIC_END "\n");
@


1.26
log
@remove dependency on openssl-0.9.5a; green@@FreeBSD.org via kris@@FreeBSD.org
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.25 2000/05/08 18:23:07 markus Exp $");
@


1.25
log
@handle escapes in real and original key format, ok millert@@
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.24 2000/05/03 02:52:56 deraadt Exp $");
d519 1
a519 1
	OpenSSL_add_all_algorithms();
@


1.25.2.1
log
@lovin' CVS... update patch branch to OpenSSH-2.1.1
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.26 2000/05/30 17:32:06 markus Exp $");
d519 1
a519 1
	SSLeay_add_all_algorithms();
@


1.25.2.2
log
@Pull in the rest of openssh-2.2.0 to 2.7 branch (luvin' cvs...)
@
text
@d10 1
a10 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.30 2000/08/19 21:34:43 markus Exp $");
d19 1
d126 1
a126 1
	fprintf(stdout, "%s\n", SSH_COM_MAGIC_BEGIN);
d132 1
a132 1
	fprintf(stdout, "%s\n", SSH_COM_MAGIC_END);
a226 2
	/* XXX RSA1 only */

d228 1
d248 1
d250 1
d253 2
d289 1
a289 1
			if (auth_rsa_read_key(&cp, &ignore, public->rsa->e, public->rsa->n)) {
d292 2
a293 2
				printf("%d %s %s\n", key_size(public),
				    key_fingerprint(public),
d297 2
a300 1
	key_free(public);
d657 1
a657 1
		if (mkdir(dotsshdir, 0700) < 0)
@


1.25.2.3
log
@openssh-2.3.0 (again) for 2.7 branch
@
text
@d5 1
a6 6
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
d10 1
a10 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.32 2000/10/09 21:30:44 markus Exp $");
a24 3
#include "buffer.h"
#include "bufaux.h"

d102 2
a103 4
#define SSH_COM_PUBLIC_BEGIN		"---- BEGIN SSH2 PUBLIC KEY ----"
#define SSH_COM_PUBLIC_END  		"---- END SSH2 PUBLIC KEY ----"
#define SSH_COM_PRIVATE_BEGIN		"---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----"
#define	SSH_COM_PRIVATE_KEY_MAGIC	0x3f6ff9eb                                          
d125 1
a125 1
	fprintf(stdout, "%s\n", SSH_COM_PUBLIC_BEGIN);
d127 2
a128 2
	    "Comment: \"%d-bit %s, converted from OpenSSH by %s@@%s\"\n",
	    key_size(k), key_type(k),
d131 1
a131 1
	fprintf(stdout, "%s\n", SSH_COM_PUBLIC_END);
a137 65
buffer_get_bignum_bits(Buffer *b, BIGNUM *value)
{
	int bits = buffer_get_int(b);
	int bytes = (bits + 7) / 8;
	if (buffer_len(b) < bytes)
		fatal("buffer_get_bignum_bits: input buffer too small");
	BN_bin2bn((unsigned char *)buffer_ptr(b), bytes, value);
	buffer_consume(b, bytes);
}

Key *
do_convert_private_ssh2_from_blob(char *blob, int blen)
{
	Buffer b;
	DSA *dsa;
	Key *key = NULL;
	int ignore, magic, rlen;
	char *type, *cipher;

	buffer_init(&b);
	buffer_append(&b, blob, blen);

	magic  = buffer_get_int(&b);
	if (magic != SSH_COM_PRIVATE_KEY_MAGIC) {
		error("bad magic 0x%x != 0x%x", magic, SSH_COM_PRIVATE_KEY_MAGIC);
		buffer_free(&b);
		return NULL;
	}
	ignore = buffer_get_int(&b);
	type   = buffer_get_string(&b, NULL);
	cipher = buffer_get_string(&b, NULL);
	ignore = buffer_get_int(&b);
	ignore = buffer_get_int(&b);
	ignore = buffer_get_int(&b);
	xfree(type);

	if (strcmp(cipher, "none") != 0) {
		error("unsupported cipher %s", cipher);
		xfree(cipher);
		buffer_free(&b);
		return NULL;
	}
	xfree(cipher);

	key = key_new(KEY_DSA);
	dsa = key->dsa;
	dsa->priv_key = BN_new();
	if (dsa->priv_key == NULL) {
		error("alloc priv_key failed");
		key_free(key);
		return NULL;
	}
	buffer_get_bignum_bits(&b, dsa->p);
	buffer_get_bignum_bits(&b, dsa->g);
	buffer_get_bignum_bits(&b, dsa->q);
	buffer_get_bignum_bits(&b, dsa->pub_key);
	buffer_get_bignum_bits(&b, dsa->priv_key);
	rlen = buffer_len(&b);
	if(rlen != 0)
		error("do_convert_private_ssh2_from_blob: remaining bytes in key blob %d", rlen);
	buffer_free(&b);
	return key;
}

void
d146 1
a146 1
	int escaped = 0, private = 0, ok;
a169 2
			if (strstr(line, SSH_COM_PRIVATE_BEGIN) != NULL)
				private = 1;
d186 3
a188 14
	k = private ?
	    do_convert_private_ssh2_from_blob(blob, blen) :
	    dsa_key_from_blob(blob, blen);
	if (k == NULL) {
		fprintf(stderr, "decode blob failed.\n");
		exit(1);
	}
	ok = private ?
	    PEM_write_DSAPrivateKey(stdout, k->dsa, NULL, NULL, 0, NULL, NULL) :
	    key_write(k, stdout);
	if (!ok) {
		fprintf(stderr, "key write failed");
		exit(1);
	}
@


1.25.2.4
log
@OpenSSH-2.5.1 for 2.7 patch branch
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.43 2001/02/12 16:16:23 markus Exp $");
d19 2
d22 1
d25 2
d29 1
a31 3
#include "pathnames.h"
#include "log.h"
#include "readpass.h"
d70 1
a70 3

/* default to RSA for SSH-1 */
char *key_type_name = "rsa1";
d81 5
a85 20
	char *name = NULL;

	switch (key_type_from_name(key_type_name)) {
	case KEY_RSA1:
		name = _PATH_SSH_CLIENT_IDENTITY;
		break;
	case KEY_DSA:
		name = _PATH_SSH_CLIENT_ID_DSA;
		break;
	case KEY_RSA:
		name = _PATH_SSH_CLIENT_ID_RSA;
		break;
	default:
		fprintf(stderr, "bad key type");
		exit(1);
		break;
	}
	snprintf(identity_file, sizeof(identity_file), "%s/%s", pw->pw_dir, name);
	fprintf(stderr, "%s (%s): ", prompt, identity_file);
	fflush(stderr);
d113 1
a113 1
#define	SSH_COM_PRIVATE_KEY_MAGIC	0x3f6ff9eb
d120 1
a120 1
	u_char *blob;
d129 1
a129 1
	k = key_new(KEY_UNSPEC);
d134 1
a134 1
	key_to_blob(k, &blob, &len);
d154 1
a154 1
	BN_bin2bn((u_char *)buffer_ptr(b), bytes, value);
d258 1
a258 1
	blen = uudecode(encoded, (u_char *)blob, sizeof(blob));
d265 1
a265 1
	    key_from_blob(blob, blen);
d287 2
d297 1
a297 1
	k = key_new(KEY_UNSPEC);
d302 1
d306 1
d314 1
d319 2
a320 1
	int i, skip = 0, num = 1, invalid = 1, success = 0;
d329 1
a329 1
	public = key_new(KEY_RSA1);
d331 2
a332 11
		success = 1;
	} else {
		key_free(public);
		public = key_new(KEY_UNSPEC);
		if (try_load_public_key(identity_file, public, &comment))
			success = 1;
		else
			debug("try_load_public_key KEY_UNSPEC failed");
	}
	if (success) {
		printf("%d %s %s\n", key_size(public), key_fingerprint(public), comment);
a333 1
		xfree(comment);
d373 6
a378 9
			public = key_new(KEY_RSA1);
			if (key_read(public, &cp) != 1) {
				cp = ep;
				key_free(public);
				public = key_new(KEY_UNSPEC);
				if (key_read(public, &cp) != 1) {
					key_free(public);
					continue;
				}
a379 5
			comment = *cp ? cp : comment;
			printf("%d %s %s\n", key_size(public),
			    key_fingerprint(public),
			    comment ? comment : "no comment");
			invalid = 0;
d403 1
a403 1
	int type = KEY_RSA1;
d411 8
a418 4
	public = key_new(type);
	if (!load_public_key(identity_file, public, NULL)) {
		type = KEY_UNSPEC;
	} else {
d422 1
d507 1
a507 1
	public = key_new(KEY_RSA1);
a509 1
		printf("Comments are only supported in RSA1 keys\n");
d513 1
a513 1
	private = key_new(KEY_RSA1);
d582 1
a582 1
	printf("Usage: %s [-lpqxXyc] [-t type] [-b bits] [-f file] [-C comment] [-N new-pass] [-P pass]\n", __progname);
d594 1
a594 1
	int opt, type;
a598 1

d615 1
a615 1
	while ((opt = getopt(ac, av, "dqpclRxXyb:f:t:P:N:C:")) != -1) {
d659 4
a662 2
			/* unused */
			exit(0);
d678 1
a678 5
			key_type_name = "dsa";
			break;

		case 't':
			key_type_name = optarg;
d694 7
d716 15
a730 11
	type = key_type_from_name(key_type_name);
	if (type == KEY_UNSPEC) {
		fprintf(stderr, "unknown key type %s\n", key_type_name);
		exit(1);
	}
	if (!quiet)
		printf("Generating public/private %s key pair.\n", key_type_name);
	private = key_generate(type, bits);
	if (private == NULL) {
		fprintf(stderr, "key_generate failed");
		exit(1);
a731 1
	public  = key_from_private(private);
d737 1
a737 1
	snprintf(dotsshdir, sizeof dotsshdir, "%s/%s", pw->pw_dir, _PATH_SSH_USER_DIR);
d800 3
a802 1
	key_free(private);
@


1.25.2.5
log
@Pull in OpenSSH-2.5.2 for 2.7 branch.
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.50 2001/03/12 22:02:02 markus Exp $");
a48 1
int print_bubblebabble = 0;
d324 1
d327 2
a328 2
	char *comment = NULL, *cp, *ep, line[16*1024], *fp;
	int i, skip = 0, num = 1, invalid = 1, success = 0, rep, type;
a330 3
	type = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
	rep =  print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;

d349 1
a349 3
		fp = key_fingerprint(public, type, rep);
		printf("%d %s %s\n", key_size(public),
		    fp, comment);
a351 1
		xfree(fp);
d402 2
a403 2
			fp = key_fingerprint(public, type, rep);
			printf("%d %s %s\n", key_size(public), fp,
a404 1
			xfree(fp);
d511 4
a514 2
	char new_comment[1024], *comment, *passphrase;
	Key *private, *public;
a516 1
	int fd;
d584 2
a585 2
	fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
a588 5
	f = fdopen(fd, "w");
	if (f == NULL) {
		printf("fdopen %s failed", identity_file);
		exit(1);
	}
d604 1
a604 2
	printf("Usage: %s [-lpqxXyc] [-t type] [-b bits] [-f file] [-C comment] "
	    "[-N new-pass] [-P pass]\n", __progname);
a614 1
	Key *private, *public;
d616 1
a616 1
	int opt, type, fd;
d619 2
d638 1
a638 1
	while ((opt = getopt(ac, av, "dqpclBRxXyb:f:t:P:N:C:")) != -1) {
a651 4
		case 'B':
			print_bubblebabble = 1;
			break;

d719 1
a719 1
	if (print_fingerprint || print_bubblebabble)
d822 2
a823 2
	fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
a826 5
	f = fdopen(fd, "w");
	if (f == NULL) {
		printf("fdopen %s failed", identity_file);
		exit(1);
	}
a832 1
		char *fp = key_fingerprint(public, SSH_FP_MD5, SSH_FP_HEX);
d836 1
a836 2
		printf("%s %s\n", fp, comment);
		xfree(fp);
@


1.24
log
@simplify usage
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.23 2000/05/02 22:18:04 markus Exp $");
d147 1
d163 6
d174 4
a177 3
		if (!(p = strchr(line, '\n'))) {
			fprintf(stderr, "input line too long.\n");
			exit(1);
@


1.23
log
@default DSA key file ~/.ssh/id_dsa
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.22 2000/05/01 08:20:56 hugh Exp $");
d491 1
a491 2
	printf("ssh-keygen version %s\n", SSH_VERSION);
	printf("Usage: %s [-b bits] [-c] [-d] [-f file] [-l] [-p] [-q] [-x] [-y] [-C comment] [-N new-pass] [-P pass] [-X]\n", __progname);
@


1.22
log
@Put -d into usage and reorder. markus ok.
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.21 2000/04/27 08:01:27 markus Exp $");
d75 2
a76 1
		 pw->pw_dir, SSH_CLIENT_IDENTITY);
@


1.21
log
@xfree DSA blobs
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.20 2000/04/26 21:55:04 deraadt Exp $");
d491 1
a491 1
	printf("Usage: %s [-b bits] [-p] [-c] [-l] [-x] [-X] [-y] [-f file] [-P pass] [-N new-pass] [-C comment]\n", __progname);
@


1.20
log
@add -R flag: exit code indicates if RSA is alive
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.19 2000/04/26 20:56:29 markus Exp $");
d133 1
d210 1
@


1.19
log
@add DSA pubkey auth and other SSH2 fixes.  use ssh-keygen -[xX]
for trading keys with the real and the original SSH, directly from the
people who invented the SSH protocol.
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.7 2000/04/18 15:01:32 markus Exp $");
d522 1
a522 1
	while ((opt = getopt(ac, av, "dqpclxXyb:f:P:N:C:")) != EOF) {
d563 7
@


1.18
log
@whitespace cleanup
@
text
@d10 6
a15 1
RCSID("$Id: ssh-keygen.c,v 1.17 2000/03/16 20:56:14 markus Exp $");
a16 1
#include "rsa.h"
d20 5
d26 1
a26 7
/* Generated private key. */
RSA *private_key;

/* Generated public key. */
RSA *public_key;

/* Number of bits in the RSA key.  This value can be changed on the command line. */
d59 6
d68 2
d87 126
d218 1
a218 1
	RSA *public_key;
d230 5
a234 7
	
	public_key = RSA_new();
	if (load_public_key(identity_file, public_key, &comment)) {
		printf("%d %s %s\n", BN_num_bits(public_key->n),
		    fingerprint(public_key->e, public_key->n),
		    comment);
		RSA_free(public_key);
d237 1
a237 1
	RSA_free(public_key);
d239 1
d307 3
a309 1
	RSA *private_key;
d317 10
a326 4
	public_key = RSA_new();
	if (!load_public_key(identity_file, public_key, NULL)) {
		printf("%s is not a valid key file.\n", identity_file);
		exit(1);
a327 2
	/* Clear the public key since we are just about to load the whole file. */
	RSA_free(public_key);
d330 2
a331 2
	private_key = RSA_new();
	if (!load_private_key(identity_file, "", private_key, &comment)) {
d336 1
a336 1
		if (!load_private_key(identity_file, old_passphrase, private_key, &comment)) {
d371 1
a371 1
	if (!save_private_key(identity_file, passphrase1, private_key, comment)) {
d376 1
a376 1
		RSA_free(private_key);
d383 1
a383 1
	RSA_free(private_key);	/* Destroys contents */
d397 2
a398 1
	RSA *private_key;
a401 1
	char *tmpbuf;
d413 2
a414 2
	public_key = RSA_new();
	if (!load_public_key(identity_file, public_key, NULL)) {
a417 1
	private_key = RSA_new();
d419 2
a420 1
	if (load_private_key(identity_file, "", private_key, &comment))
d430 1
a430 1
		if (!load_private_key(identity_file, passphrase, private_key, &comment)) {
d446 1
a446 1
			RSA_free(private_key);
d454 1
a454 1
	if (!save_private_key(identity_file, passphrase, private_key, new_comment)) {
d459 1
a459 1
		RSA_free(private_key);
d465 1
a465 1
	RSA_free(private_key);
d473 4
a476 7
	fprintf(f, "%d ", BN_num_bits(public_key->n));
	tmpbuf = BN_bn2dec(public_key->e);
	fprintf(f, "%s ", tmpbuf);
	free(tmpbuf);
	tmpbuf = BN_bn2dec(public_key->n);
	fprintf(f, "%s %s\n", tmpbuf, new_comment);
	free(tmpbuf);
d489 1
a489 1
	printf("Usage: %s [-b bits] [-p] [-c] [-l] [-f file] [-P pass] [-N new-pass] [-C comment]\n", __progname);
a500 1
	char *tmpbuf;
d504 2
a505 1
	char hostname[MAXHOSTNAMELEN];
d509 2
a510 7
	/* check if RSA support exists */
	if (rsa_alive() == 0) {
		fprintf(stderr,
			"%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
			__progname);
		exit(1);
	}
d517 4
d522 1
a522 1
	while ((opt = getopt(ac, av, "qpclb:f:P:N:C:")) != EOF) {
d565 16
d594 7
d607 6
d616 16
a631 7
	if (quiet)
		rsa_set_verbose(0);

	/* Generate the rsa key pair. */
	private_key = RSA_new();
	public_key = RSA_new();
	rsa_generate_key(private_key, public_key, bits);
a683 4
		if (gethostname(hostname, sizeof(hostname)) < 0) {
			perror("gethostname");
			exit(1);
		}
d688 1
a688 1
	if (!save_private_key(identity_file, passphrase1, private_key, comment)) {
d690 1
a690 1
		       identity_file, strerror(errno));
d700 3
a702 1
	RSA_free(private_key);
d714 3
a716 7
	fprintf(f, "%d ", BN_num_bits(public_key->n));
	tmpbuf = BN_bn2dec(public_key->e);
	fprintf(f, "%s ", tmpbuf);
	free(tmpbuf);
	tmpbuf = BN_bn2dec(public_key->n);
	fprintf(f, "%s %s\n", tmpbuf, comment);
	free(tmpbuf);
d720 2
a721 1
		printf("Your public key has been saved in %s.\n", identity_file);
d723 1
a723 3
		printf("%d %s %s\n", BN_num_bits(public_key->n),
		       fingerprint(public_key->e, public_key->n),
		       comment);
d725 2
@


1.17
log
@-pedantic: signed vs. unsigned, void*-arithm, etc
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.16 2000/02/04 14:34:09 markus Exp $");
d507 1
a507 1
	  	/* Create default commend field for the passphrase. */
@


1.16
log
@typo
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.15 2000/02/04 13:16:16 markus Exp $");
d84 1
d142 1
a142 1
			if (auth_rsa_read_key(&cp, &i, e, n)) {
@


1.15
log
@enable ssh-keygen -l -f ~/.ssh/known_hosts, ok deraadt@@
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.14 1999/11/24 19:53:52 markus Exp $");
d82 1
a82 1
	char *comment = NULL, char *cp, *ep, line[16*1024];
@


1.14
log
@KNF, final part 3
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.13 1999/11/24 00:26:03 deraadt Exp $");
d79 2
a80 1
	char *comment;
d82 2
d92 1
d94 11
a104 5
	if (!load_public_key(identity_file, public_key, &comment)) {
		char *cp, line[1024];
		BIGNUM *e, *n;
		int dummy, invalid = 0;
		FILE *f = fopen(identity_file, "r");
d107 40
a146 9
		if (f && fgets(line, sizeof(line), f)) {
			cp = line;
			line[strlen(line) - 1] = '\0';
			if (auth_rsa_read_key(&cp, &dummy, e, n)) {
				public_key->e = e;
				public_key->n = n;
				comment = xstrdup(cp ? cp : "no comment");
			} else {
				invalid = 1;
a147 8
		} else {
			invalid = 1;
		}
		if (invalid) {
			printf("%s is not a valid key file.\n", identity_file);
			BN_free(e);
			BN_free(n);
			exit(1);
d149 7
a156 4
	printf("%d %s %s\n", BN_num_bits(public_key->n),
	       fingerprint(public_key->e, public_key->n),
	       comment);
	RSA_free(public_key);
d349 1
a349 1
	printf("Usage: %s [-b bits] [-p] [-c] [-f file] [-P pass] [-N new-pass] [-C comment]\n", __progname);
@


1.13
log
@much more KNF
@
text
@d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.12 1999/11/23 22:25:55 markus Exp $");
d23 1
a23 2
/* Number of bits in the RSA key.  This value can be changed on the command
   line. */
d26 4
a29 2
/* Flag indicating that we just want to change the passphrase.  This can be
   set on the command line. */
d32 4
a35 2
/* Flag indicating that we just want to change the comment.  This can be set
   on the command line. */
a137 1
	/* Check if the file exists. */
a141 2
	/* Try to load the public key from the file the verify that it is
	   readable and of the proper format. */
a152 1
		/* Read passphrase from the user. */
a156 1
		/* Try to load using the passphrase. */
a162 1
		/* Destroy the passphrase. */
a225 1
	/* Check if the file exists. */
d230 4
a233 2
	/* Try to load the public key from the file the verify that it is
	   readable and of the proper format. */
d240 1
a240 1
	/* Try to load the file with empty passphrase. */
a243 1
		/* Read passphrase from the user. */
a269 1
		/* Remove terminating newline from comment. */
a283 1
	/* Destroy the passphrase and the private key in memory. */
a287 2
	/* Save the public key in text format in a file with the same name
	   but .pub appended. */
a334 2
		extern char *__progname;

d340 1
a340 2
	/* Get user\'s passwd structure.  We need this for the home
	   directory. */
d346 1
a346 1
	/* Parse command line arguments. */
a404 3

	/* If the user requested to change the passphrase, do it now.
	   This function never returns. */
a406 3

	/* If the user requested to change the comment, do it now.  This
	   function never returns. */
a466 2
	/* Create default commend field for the passphrase.  The user can
	   later edit this field. */
d470 1
a496 2
	/* Save the public key in text format in a file with the same name
	   but .pub appended. */
@


1.12
log
@KNF part 1
@
text
@d2 6
a7 13

ssh-keygen.c

Author: Tatu Ylonen <ylo@@cs.hut.fi>

Copyright (c) 1994 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
                   All rights reserved

Created: Mon Mar 27 02:26:40 1995 ylo

Identity and host key generation and maintenance.

*/
d10 1
a10 1
RCSID("$Id: ssh-keygen.c,v 1.11 1999/11/21 21:58:31 markus Exp $");
d121 4
a124 3
/* Perform changing a passphrase.  The argument is the passwd structure
   for the current user. */

d214 3
a216 2
/* Change the comment of a private key file. */

d324 3
a326 2
/* Main program for key management. */

@


1.11
log
@don't create ~/.ssh only if the user wants to store the private key there.
show fingerprint instead of public-key after keygeneration. ok niels@@
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.10 1999/11/20 19:53:40 markus Exp $");
d66 12
a77 12
  char buf[1024];
  snprintf(identity_file, sizeof(identity_file), "%s/%s",
           pw->pw_dir, SSH_CLIENT_IDENTITY);
  printf("%s (%s): ", prompt, identity_file);
  fflush(stdout);
  if (fgets(buf, sizeof(buf), stdin) == NULL)
    exit(1);
  if (strchr(buf, '\n'))
    *strchr(buf, '\n') = 0;
  if (strcmp(buf, "") != 0)
    strlcpy(identity_file, buf, sizeof(identity_file));
  have_identity = 1;
d83 43
a125 45
  char *comment;
  RSA *public_key;
  struct stat st;

  if (!have_identity)
    ask_filename(pw, "Enter file in which the key is");
  if (stat(identity_file, &st) < 0)
    {
      perror(identity_file);
      exit(1);
    }
  public_key = RSA_new();
  if (!load_public_key(identity_file, public_key, &comment)) {
    char *cp, line[1024];
    BIGNUM *e, *n;
    int dummy, invalid = 0;
    FILE *f = fopen(identity_file, "r");
    n = BN_new();
    e = BN_new();
    if (f && fgets(line, sizeof(line), f)) {
      cp = line;
      line[strlen(line)-1] = '\0';
      if (auth_rsa_read_key(&cp, &dummy, e, n)) {
        public_key->e = e;
        public_key->n = n;
	comment = xstrdup(cp ? cp : "no comment");
      } else {
        invalid = 1;
      } 
    } else {
      invalid = 1;
    }
    if (invalid) {
      printf("%s is not a valid key file.\n", identity_file);
      BN_free(e);
      BN_free(n);
      exit(1);
    }
  }
    
  printf("%d %s %s\n", BN_num_bits(public_key->n),
	 fingerprint(public_key->e, public_key->n),
	 comment);
  RSA_free(public_key);
  exit(0);
d134 81
a214 90
  char *comment;
  char *old_passphrase, *passphrase1, *passphrase2;
  struct stat st;
  RSA *private_key;

  if (!have_identity)
    ask_filename(pw, "Enter file in which the key is");
  /* Check if the file exists. */
  if (stat(identity_file, &st) < 0)
    {
      perror(identity_file);
      exit(1);
    }
  
  /* Try to load the public key from the file the verify that it is
     readable and of the proper format. */
  public_key = RSA_new();
  if (!load_public_key(identity_file, public_key, NULL))
    {
      printf("%s is not a valid key file.\n", identity_file);
      exit(1);
    }
  /* Clear the public key since we are just about to load the whole file. */
  RSA_free(public_key);

  /* Try to load the file with empty passphrase. */
  private_key = RSA_new();
  if (!load_private_key(identity_file, "", private_key, &comment)) {
    /* Read passphrase from the user. */
    if (identity_passphrase)
      old_passphrase = xstrdup(identity_passphrase);
    else
      old_passphrase = read_passphrase("Enter old passphrase: ", 1);
    /* Try to load using the passphrase. */
    if (!load_private_key(identity_file, old_passphrase, private_key, &comment))
      {
	memset(old_passphrase, 0, strlen(old_passphrase));
	xfree(old_passphrase);
	printf("Bad passphrase.\n");
	exit(1);
      }
    /* Destroy the passphrase. */
    memset(old_passphrase, 0, strlen(old_passphrase));
    xfree(old_passphrase);
  }
  printf("Key has comment '%s'\n", comment);
  
  /* Ask the new passphrase (twice). */
  if (identity_new_passphrase)
    {
      passphrase1 = xstrdup(identity_new_passphrase);
      passphrase2 = NULL;
    }
  else
    {
      passphrase1 = 
	read_passphrase("Enter new passphrase (empty for no passphrase): ", 1);
      passphrase2 = read_passphrase("Enter same passphrase again: ", 1);

      /* Verify that they are the same. */
      if (strcmp(passphrase1, passphrase2) != 0)
	{
	  memset(passphrase1, 0, strlen(passphrase1));
	  memset(passphrase2, 0, strlen(passphrase2));
	  xfree(passphrase1);
	  xfree(passphrase2);
	  printf("Pass phrases do not match.  Try again.\n");
	  exit(1);
	}
      /* Destroy the other copy. */
      memset(passphrase2, 0, strlen(passphrase2));
      xfree(passphrase2);
    }

  /* Save the file using the new passphrase. */
  if (!save_private_key(identity_file, passphrase1, private_key, comment))
    {
      printf("Saving the key failed: %s: %s.\n",
	     identity_file, strerror(errno));
      memset(passphrase1, 0, strlen(passphrase1));
      xfree(passphrase1);
      RSA_free(private_key);
      xfree(comment);
      exit(1);
    }
  /* Destroy the passphrase and the copy of the key in memory. */
  memset(passphrase1, 0, strlen(passphrase1));
  xfree(passphrase1);
  RSA_free(private_key); /* Destroys contents */
  xfree(comment);
d216 2
a217 2
  printf("Your identification has been saved with the new passphrase.\n");
  exit(0);
d225 89
a313 104
  char new_comment[1024], *comment;
  RSA *private_key;
  char *passphrase;
  struct stat st;
  FILE *f;
  char *tmpbuf;

  if (!have_identity)
    ask_filename(pw, "Enter file in which the key is");
  /* Check if the file exists. */
  if (stat(identity_file, &st) < 0)
    {
      perror(identity_file);
      exit(1);
    }
  
  /* Try to load the public key from the file the verify that it is
     readable and of the proper format. */
  public_key = RSA_new();
  if (!load_public_key(identity_file, public_key, NULL))
    {
      printf("%s is not a valid key file.\n", identity_file);
      exit(1);
    }

  private_key = RSA_new();
  /* Try to load the file with empty passphrase. */
  if (load_private_key(identity_file, "", private_key, &comment))
    passphrase = xstrdup("");
  else
    {
      /* Read passphrase from the user. */
      if (identity_passphrase)
	passphrase = xstrdup(identity_passphrase);
      else
	if (identity_new_passphrase)
	  passphrase = xstrdup(identity_new_passphrase);
	else
	  passphrase = read_passphrase("Enter passphrase: ", 1);
      /* Try to load using the passphrase. */
      if (!load_private_key(identity_file, passphrase, private_key, &comment))
	{
	  memset(passphrase, 0, strlen(passphrase));
	  xfree(passphrase);
	  printf("Bad passphrase.\n");
	  exit(1);
	}
    }
  printf("Key now has comment '%s'\n", comment);

  if (identity_comment)
    {
      strlcpy(new_comment, identity_comment, sizeof(new_comment));
    }
  else
    {
      printf("Enter new comment: ");
      fflush(stdout);
      if (!fgets(new_comment, sizeof(new_comment), stdin))
	{
	  memset(passphrase, 0, strlen(passphrase));
	  RSA_free(private_key);
	  exit(1);
	}
      
      /* Remove terminating newline from comment. */
      if (strchr(new_comment, '\n'))
	*strchr(new_comment, '\n') = 0;
    }
      
  /* Save the file using the new passphrase. */
  if (!save_private_key(identity_file, passphrase, private_key, new_comment))
    {
      printf("Saving the key failed: %s: %s.\n",
	     identity_file, strerror(errno));
      memset(passphrase, 0, strlen(passphrase));
      xfree(passphrase);
      RSA_free(private_key);
      xfree(comment);
      exit(1);
    }

  /* Destroy the passphrase and the private key in memory. */
  memset(passphrase, 0, strlen(passphrase));
  xfree(passphrase);
  RSA_free(private_key);

  /* Save the public key in text format in a file with the same name but
     .pub appended. */
  strlcat(identity_file, ".pub", sizeof(identity_file));
  f = fopen(identity_file, "w");
  if (!f)
    {
      printf("Could not save your public key in %s\n", identity_file);
      exit(1);
    }
  fprintf(f, "%d ", BN_num_bits(public_key->n));
  tmpbuf = BN_bn2dec(public_key->e);
  fprintf(f, "%s ", tmpbuf);
  free (tmpbuf);
  tmpbuf = BN_bn2dec(public_key->n);
  fprintf(f, "%s %s\n", tmpbuf, new_comment);
  free (tmpbuf);
  fclose(f);
d315 1
a315 1
  xfree(comment);
d317 2
a318 2
  printf("The comment in your key file has been changed.\n");
  exit(0);
d324 3
a326 3
  printf("ssh-keygen version %s\n", SSH_VERSION);
  printf("Usage: %s [-b bits] [-p] [-c] [-f file] [-P pass] [-N new-pass] [-C comment]\n", __progname);
  exit(1);
d334 209
a542 230
  char dotsshdir[16*1024], comment[1024], *passphrase1, *passphrase2;
  struct passwd *pw;
  char *tmpbuf;
  int opt;
  struct stat st;
  FILE *f;
  char hostname[MAXHOSTNAMELEN];
  extern int optind;
  extern char *optarg;

  /* check if RSA support exists */
  if (rsa_alive() == 0) {
    extern char *__progname;

    fprintf(stderr,
      "%s: no RSA support in libssl and libcrypto.  See ssl(8).\n",
      __progname);
    exit(1);
  }

  /* Get user\'s passwd structure.  We need this for the home directory. */
  pw = getpwuid(getuid());
  if (!pw)
    {
      printf("You don't exist, go away!\n");
      exit(1);
    }

  /* Parse command line arguments. */
  while ((opt = getopt(ac, av, "qpclb:f:P:N:C:")) != EOF)
    {
      switch (opt)
	{
	case 'b':
	  bits = atoi(optarg);
	  if (bits < 512 || bits > 32768)
	    {
	      printf("Bits has bad value.\n");
	      exit(1);
	    }
	  break;

	case 'l':
	  print_fingerprint = 1;
	  break;

	case 'p':
	  change_passphrase = 1;
	  break;

	case 'c':
	  change_comment = 1;
	  break;

	case 'f':
	  strlcpy(identity_file, optarg, sizeof(identity_file));
	  have_identity = 1;
	  break;
	  
	case 'P':
	  identity_passphrase = optarg;
	  break;

	case 'N':
	  identity_new_passphrase = optarg;
	  break;

	case 'C':
	  identity_comment = optarg;
	  break;

        case 'q':
	  quiet = 1;
	  break;

	case '?':
	default:
	  usage();
	}
    }
  if (optind < ac)
    {
      printf("Too many arguments.\n");
      usage();
    }
  if (change_passphrase && change_comment)
    {
      printf("Can only have one of -p and -c.\n");
      usage();
    }

  if (print_fingerprint)
    do_fingerprint(pw);

  /* If the user requested to change the passphrase, do it now.  This
     function never returns. */
  if (change_passphrase)
    do_change_passphrase(pw);

  /* If the user requested to change the comment, do it now.  This function
     never returns. */
  if (change_comment)
    do_change_comment(pw);

  arc4random_stir();

  if (quiet)
    rsa_set_verbose(0);

  /* Generate the rsa key pair. */
  private_key = RSA_new();
  public_key = RSA_new();
  rsa_generate_key(private_key, public_key, bits);

  if (!have_identity)
    ask_filename(pw, "Enter file in which to save the key");

  /* Create ~/.ssh directory if it doesn\'t already exist. */
  snprintf(dotsshdir, sizeof dotsshdir, "%s/%s", pw->pw_dir, SSH_USER_DIR);
  if (strstr(identity_file, dotsshdir) != NULL &&
      stat(dotsshdir, &st) < 0) {
    if (mkdir(dotsshdir, 0755) < 0)
      error("Could not create directory '%s'.", dotsshdir);
    else if(!quiet)
      printf("Created directory '%s'.\n", dotsshdir);
 }

  /* If the file already exists, ask the user to confirm. */
  if (stat(identity_file, &st) >= 0)
    {
      char yesno[3];
      printf("%s already exists.\n", identity_file);
      printf("Overwrite (y/n)? ");
      fflush(stdout);
      if (fgets(yesno, sizeof(yesno), stdin) == NULL)
	exit(1);
      if (yesno[0] != 'y' && yesno[0] != 'Y')
	exit(1);
    }
  
  /* Ask for a passphrase (twice). */
  if (identity_passphrase)
    passphrase1 = xstrdup(identity_passphrase);
  else
    if (identity_new_passphrase)
      passphrase1 = xstrdup(identity_new_passphrase);
    else
      {
      passphrase_again:
	passphrase1 = 
	  read_passphrase("Enter passphrase (empty for no passphrase): ", 1);
	passphrase2 = read_passphrase("Enter same passphrase again: ", 1);
	if (strcmp(passphrase1, passphrase2) != 0)
	  {
	    /* The passphrases do not match.  Clear them and retry. */
	    memset(passphrase1, 0, strlen(passphrase1));
	    memset(passphrase2, 0, strlen(passphrase2));
	    xfree(passphrase1);
	    xfree(passphrase2);
	    printf("Passphrases do not match.  Try again.\n");
	    goto passphrase_again;
	  }
	/* Clear the other copy of the passphrase. */
	memset(passphrase2, 0, strlen(passphrase2));
	xfree(passphrase2);
      }

  /* Create default commend field for the passphrase.  The user can later
     edit this field. */
  if (identity_comment)
    {
      strlcpy(comment, identity_comment, sizeof(comment));
    }
  else
    {
      if (gethostname(hostname, sizeof(hostname)) < 0)
	{
	  perror("gethostname");
	  exit(1);
	}
      snprintf(comment, sizeof comment, "%s@@%s", pw->pw_name, hostname);
    }

  /* Save the key with the given passphrase and comment. */
  if (!save_private_key(identity_file, passphrase1, private_key, comment))
    {
      printf("Saving the key failed: %s: %s.\n",
	     identity_file, strerror(errno));
      memset(passphrase1, 0, strlen(passphrase1));
      xfree(passphrase1);
      exit(1);
    }
  /* Clear the passphrase. */
  memset(passphrase1, 0, strlen(passphrase1));
  xfree(passphrase1);

  /* Clear the private key and the random number generator. */
  RSA_free(private_key);
  arc4random_stir();

  if (!quiet)
    printf("Your identification has been saved in %s.\n", identity_file);

  /* Save the public key in text format in a file with the same name but
     .pub appended. */
  strlcat(identity_file, ".pub", sizeof(identity_file));
  f = fopen(identity_file, "w");
  if (!f)
    {
      printf("Could not save your public key in %s\n", identity_file);
      exit(1);
    }
  fprintf(f, "%d ", BN_num_bits(public_key->n));
  tmpbuf = BN_bn2dec(public_key->e);
  fprintf(f, "%s ", tmpbuf);
  free(tmpbuf);
  tmpbuf = BN_bn2dec(public_key->n);
  fprintf(f, "%s %s\n", tmpbuf, comment);
  free(tmpbuf);
  fclose(f);

  if (!quiet) {
    printf("Your public key has been saved in %s.\n", identity_file);
    printf("The key fingerprint is:\n");
    printf("%d %s %s\n", BN_num_bits(public_key->n),
	   fingerprint(public_key->e, public_key->n),
	   comment);
  }
  
  exit(0);
@


1.10
log
@replace xstrdup+strcat with strlcat+fixed buffer, fixes OF (bad me)
exit if writing the key fails (no infinit loop)
print usage() everytime we get bad options
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.9 1999/11/20 10:02:53 markus Exp $");
d360 1
a360 1
  char buf[16384], buf2[1024], *passphrase1, *passphrase2;
a387 6
  /* Create ~/.ssh directory if it doesn\'t already exist. */
  snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, SSH_USER_DIR);
  if (stat(buf, &st) < 0)
    if (mkdir(buf, 0755) < 0)
      error("Could not create directory '%s'.", buf);

d477 11
a487 1
  /* If the file aready exists, ask the user to confirm. */
d490 1
d494 1
a494 1
      if (fgets(buf2, sizeof(buf2), stdin) == NULL)
d496 1
a496 1
      if (buf2[0] != 'y' && buf2[0] != 'Y')
d531 1
a531 1
      strlcpy(buf2, identity_comment, sizeof(buf2));
d540 1
a540 1
      snprintf(buf2, sizeof buf2, "%s@@%s", pw->pw_name, hostname);
d544 1
a544 1
  if (!save_private_key(identity_file, passphrase1, private_key, buf2))
a562 12
  /* Display the public key on the screen. */
  if (!quiet) {
    printf("Your public key is:\n");
    printf("%d ", BN_num_bits(public_key->n));
    tmpbuf = BN_bn2dec(public_key->e);
    printf("%s ", tmpbuf);
    free(tmpbuf);
    tmpbuf = BN_bn2dec(public_key->n);
    printf("%s %s\n", tmpbuf, buf2);
    free(tmpbuf);
  }

d577 1
a577 1
  fprintf(f, "%s %s\n", tmpbuf, buf2);
d581 7
a587 2
  if (!quiet)
    printf("Your public key has been saved in %s\n", identity_file);
@


1.9
log
@overflow, djm@@mindrot.org
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.8 1999/11/16 22:49:28 markus Exp $");
d47 3
a49 2
/* This is set to the identity file name if given on the command line. */
char *identity_file = NULL;
d60 2
a61 2
/* Perform changing a passphrase.  The argument is the passwd structure
   for the current user. */
d63 2
a64 2
char *
get_filename(struct passwd *pw, const char *prompt)
d66 12
a77 18
  char buf[1024], default_file[1024];

  /* Read key file name. */
  if (identity_file != NULL) {
    return xstrdup(identity_file);
  } else {
    snprintf(default_file, sizeof default_file, "%s/%s",
             pw->pw_dir, SSH_CLIENT_IDENTITY);
    printf("%s (%s): ", prompt, default_file);
    fflush(stdout);
    if (fgets(buf, sizeof(buf), stdin) == NULL)
      exit(1);
    if (strchr(buf, '\n'))
      *strchr(buf, '\n') = 0;
    if (strcmp(buf, "") == 0)
      return xstrdup(default_file);
  }
  return xstrdup(buf);
d83 1
a83 1
  char *file, *comment;
d87 3
a89 2
  file = get_filename(pw, "Enter file in which the key is");
  if (stat(file, &st) < 0)
d91 1
a91 1
      perror(file);
d95 1
a95 1
  if (!load_public_key(file, public_key, &comment)) {
d99 1
a99 1
    FILE *f = fopen(file, "r");
d116 1
a116 1
      printf("%s is not a valid key file.\n", file);
d130 2
d136 1
a136 1
  char *file, *comment;
d141 2
a142 1
  file = get_filename(pw, "Enter file in which the key is");
d144 1
a144 1
  if (stat(file, &st) < 0)
d146 1
a146 1
      perror(file);
d153 1
a153 1
  if (!load_public_key(file, public_key, NULL))
d155 1
a155 1
      printf("%s is not a valid key file.\n", file);
d163 1
a163 1
  if (!load_private_key(file, "", private_key, &comment)) {
d170 1
a170 1
    if (!load_private_key(file, old_passphrase, private_key, &comment))
d211 1
a211 1
  if (!save_private_key(file, passphrase1, private_key, comment))
d214 1
a214 1
	     file, strerror(errno));
d236 1
a236 1
  char new_comment[1024], *file, *comment;
d243 2
a244 1
  file = get_filename(pw, "Enter file in which the key is");
d246 1
a246 1
  if (stat(file, &st) < 0)
d248 1
a248 1
      perror(file);
d255 1
a255 1
  if (!load_public_key(file, public_key, NULL))
d257 1
a257 1
      printf("%s is not a valid key file.\n", file);
d263 1
a263 1
  if (load_private_key(file, "", private_key, &comment))
d276 1
a276 1
      if (!load_private_key(file, passphrase, private_key, &comment))
d307 1
a307 1
  if (!save_private_key(file, passphrase, private_key, new_comment))
d310 1
a310 1
	     file, strerror(errno));
d325 2
a326 3
  file = xrealloc(file, strlen(file) + 5);
  strcat(file, ".pub");
  f = fopen(file, "w");
d329 1
a329 1
      printf("Could not save your public key in %s\n", file);
d347 8
d362 1
a362 1
  char *file, *tmpbuf;
d421 2
a422 1
	  identity_file = optarg;
d443 1
a443 3
	  printf("ssh-keygen version %s\n", SSH_VERSION);
	  printf("Usage: %s [-b bits] [-p] [-c] [-f file] [-P pass] [-N new-pass] [-C comment]\n", av[0]);
	  exit(1);
d449 1
a449 1
      exit(1);
d454 1
a454 1
      exit(1);
d480 2
a481 3
 ask_file_again:

  file = get_filename(pw, "Enter file in which to save the key");
d484 1
a484 1
  if (stat(file, &st) >= 0)
d486 1
a486 1
      printf("%s already exists.\n", file);
d539 1
a539 1
  if (!save_private_key(file, passphrase1, private_key, buf2))
d542 1
a542 1
	     file, strerror(errno));
d545 1
a545 2
      xfree(file);
      goto ask_file_again;
d556 1
a556 1
    printf("Your identification has been saved in %s.\n", file);
d572 2
a573 2
  strcat(file, ".pub");
  f = fopen(file, "w");
d576 1
a576 1
      printf("Could not save your public key in %s\n", file);
d589 1
a589 1
    printf("Your public key has been saved in %s\n", file);
@


1.8
log
@rsa key fingerprints, idea from Bjoern Groenvall <bg@@sics.se>
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.7 1999/11/16 22:27:54 markus Exp $");
d325 1
@


1.7
log
@move common prompt-for-filename-code into own function
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.6 1999/10/01 02:38:09 provos Exp $");
d22 1
d44 3
d86 50
d387 1
a387 1
  while ((opt = getopt(ac, av, "qpcb:f:P:N:C:")) != EOF)
d400 4
d449 3
@


1.6
log
@get rid of references to randomseedfile we dont need it.  for sshd
just spit out a warning that the configuration option is obsolete.
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.5 1999/09/29 21:14:16 deraadt Exp $");
d58 2
a59 2
void
do_change_passphrase(struct passwd *pw)
d61 1
a61 4
  char buf[1024], *comment;
  char *old_passphrase, *passphrase1, *passphrase2;
  struct stat st;
  RSA *private_key;
d65 1
a65 2
      strncpy(buf, identity_file, sizeof(buf));
      buf[sizeof(buf) - 1] = '\0';
d67 3
a69 1
    printf("Enter file in which the key is ($HOME/%s): ", SSH_CLIENT_IDENTITY);
d76 1
a76 1
      snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
d78 10
d89 1
d91 1
a91 1
  if (stat(buf, &st) < 0)
d93 1
a93 1
      perror(buf);
d100 1
a100 1
  if (!load_public_key(buf, public_key, NULL))
d102 1
a102 1
      printf("%s is not a valid key file.\n", buf);
d110 1
a110 1
  if (!load_private_key(buf, "", private_key, &comment)) {
d117 1
a117 1
    if (!load_private_key(buf, old_passphrase, private_key, &comment))
d158 1
a158 1
  if (!save_private_key(buf, passphrase1, private_key, comment))
d161 1
a161 1
	     buf, strerror(errno));
d183 1
a183 1
  char buf[1024], new_comment[1024], *comment;
d190 1
a190 19
  /* Read key file name. */
  if (identity_file)
    {
      strncpy(buf, identity_file, sizeof(buf));
      buf[sizeof(buf) - 1] = '\0';
    }
  else
    {
      printf("Enter file in which the key is ($HOME/%s): ", 
	     SSH_CLIENT_IDENTITY);
      fflush(stdout);
      if (fgets(buf, sizeof(buf), stdin) == NULL)
	exit(1);
      if (strchr(buf, '\n'))
	*strchr(buf, '\n') = 0;
      if (strcmp(buf, "") == 0)
	snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
    }

d192 1
a192 1
  if (stat(buf, &st) < 0)
d194 1
a194 1
      perror(buf);
d201 1
a201 1
  if (!load_public_key(buf, public_key, NULL))
d203 1
a203 1
      printf("%s is not a valid key file.\n", buf);
d209 1
a209 1
  if (load_private_key(buf, "", private_key, &comment))
d222 1
a222 1
      if (!load_private_key(buf, passphrase, private_key, &comment))
d234 1
a234 2
      strncpy(new_comment, identity_comment, sizeof(new_comment));
      new_comment[sizeof(new_comment) - 1] = '\0';
d253 1
a253 1
  if (!save_private_key(buf, passphrase, private_key, new_comment))
d256 1
a256 1
	     buf, strerror(errno));
d271 2
a272 2
  strcat(buf, ".pub");
  f = fopen(buf, "w");
d275 1
a275 1
      printf("Could not save your public key in %s\n", buf);
d300 1
a300 1
  char *tmpbuf;
d414 1
a414 18
  /* Ask for a file to save the key in. */
  if (identity_file)
    {
      strncpy(buf, identity_file, sizeof(buf));
      buf[sizeof(buf) - 1] = '\0';
    }
  else
    {
      printf("Enter file in which to save the key ($HOME/%s): ", 
	     SSH_CLIENT_IDENTITY);
      fflush(stdout);
      if (fgets(buf, sizeof(buf), stdin) == NULL)
	exit(1);
      if (strchr(buf, '\n'))
	*strchr(buf, '\n') = 0;
      if (strcmp(buf, "") == 0)
	snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
    }
d417 1
a417 1
  if (stat(buf, &st) >= 0)
d419 1
a419 1
      printf("%s already exists.\n", buf);
d472 1
a472 1
  if (!save_private_key(buf, passphrase1, private_key, buf2))
d475 1
a475 1
	     buf, strerror(errno));
d478 1
d490 1
a490 1
    printf("Your identification has been saved in %s.\n", buf);
d506 2
a507 2
  strcat(buf, ".pub");
  f = fopen(buf, "w");
d510 1
a510 1
      printf("Could not save your public key in %s\n", buf);
d523 1
a523 1
    printf("Your public key has been saved in %s\n", buf);
@


1.5
log
@numerous sprintf, strncpy, strcpy cleanups
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.4 1999/09/29 06:15:00 deraadt Exp $");
a411 4
  /* Initialize random number generator.  This may take a while if the
     user has no seed file, so display a message to the user. */
  if (!quiet)
    printf("Initializing random number generator...\n");
@


1.4
log
@test for RSA in the ssl library, real early on
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.3 1999/09/28 19:42:05 deraadt Exp $");
a18 3
#ifndef HAVE_GETHOSTNAME
#include <sys/utsname.h>
#endif
d78 1
a78 1
      sprintf(buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
d197 1
a197 1
	sprintf(buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
d314 1
a314 5
#ifdef HAVE_GETHOSTNAME
  char hostname[257];
#else
  struct utsname uts;
#endif
d337 1
a337 1
  sprintf(buf, "%s/%s", pw->pw_dir, SSH_USER_DIR);
d444 1
a444 1
	sprintf(buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
d490 1
a490 2
      strncpy(buf2, identity_comment, sizeof(buf2));
      buf2[sizeof(buf2) - 1] = '\0';
a493 1
#ifdef HAVE_GETHOSTNAME
d499 1
a499 9
      sprintf(buf2, "%s@@%s", pw->pw_name, hostname);
#else
      if (uname(&uts) < 0)
	{
	  perror("uname");
	  exit(1);
	}
      sprintf(buf2, "%s@@%s", pw->pw_name, uts.nodename);
#endif
@


1.3
log
@put q in getopt
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.2 1999/09/28 04:45:37 provos Exp $");
d324 10
@


1.2
log
@convert all uses of gmp to SSL bignum
convert all used of rsa to SSL rsa functions
remove all use of randomstate to OpenBSD arc4random() and arc4_stir()
all this done at a long long night in Canada.
@
text
@d17 1
a17 1
RCSID("$Id: ssh-keygen.c,v 1.2 1999/05/04 11:59:17 bg Exp $");
d340 1
a340 1
  while ((opt = getopt(ac, av, "pcb:f:P:N:C:")) != EOF)
@


1.1
log
@i bet a lot of people didn't know what ssh 1.2.16 had a nice license.
well, except for the patent issues.  someone in sweden (forget their
name at the moment) cleaned out most of the patented code, and now
this code removes rsa code.  when this is done, it will link against
libssl, but the work isn't completely done yet.  then we need to bring
this up to modern days, featurewise.
@
text
@a21 1
#include "randoms.h"
d27 1
a27 1
RSAPrivateKey private_key;
d30 1
a30 4
RSAPublicKey public_key;

/* Random number generator state. */
RandomState state;
d44 2
d61 2
a62 1
void do_change_passphrase(struct passwd *pw)
a64 1
  RSAPrivateKey private_key;
d67 1
d70 1
a70 2
  if (identity_file != NULL)
    {
d73 10
a82 13
    }
  else
    {
      printf("Enter file in which the key is ($HOME/%s): ", 
	     SSH_CLIENT_IDENTITY);
      fflush(stdout);
      if (fgets(buf, sizeof(buf), stdin) == NULL)
	exit(1);
      if (strchr(buf, '\n'))
	*strchr(buf, '\n') = 0;
      if (strcmp(buf, "") == 0)
	sprintf(buf, "%s/%s", pw->pw_dir, SSH_CLIENT_IDENTITY);
    }
d93 2
a94 1
  if (!load_public_key(buf, &public_key, NULL))
d100 1
a100 1
  rsa_clear_public_key(&public_key);
d103 19
a121 19
  if (!load_private_key(buf, "", &private_key, &comment))
    {
      /* Read passphrase from the user. */
      if (identity_passphrase)
	old_passphrase = xstrdup(identity_passphrase);
      else
	old_passphrase = read_passphrase("Enter old passphrase: ", 1);
      /* Try to load using the passphrase. */
      if (!load_private_key(buf, old_passphrase, &private_key, &comment))
	{
	  memset(old_passphrase, 0, strlen(old_passphrase));
	  xfree(old_passphrase);
	  printf("Bad passphrase.\n");
	  exit(1);
	}
      /* Destroy the passphrase. */
      memset(old_passphrase, 0, strlen(old_passphrase));
      xfree(old_passphrase);
    }
d152 1
a152 1
  if (!save_private_key(buf, passphrase1, &private_key, comment, &state))
d158 1
a158 1
      rsa_clear_private_key(&private_key);
d165 1
a165 1
  rsa_clear_private_key(&private_key);
d174 2
a175 1
void do_change_comment(struct passwd *pw)
d178 1
a178 1
  RSAPrivateKey private_key;
d182 1
d212 2
a213 1
  if (!load_public_key(buf, &public_key, NULL))
d219 1
d221 1
a221 1
  if (load_private_key(buf, "", &private_key, &comment))
d234 1
a234 1
      if (!load_private_key(buf, passphrase, &private_key, &comment))
d256 1
a256 1
	  rsa_clear_private_key(&private_key);
d266 1
a266 2
  if (!save_private_key(buf, passphrase, &private_key, new_comment, 
			&state))
d272 1
a272 1
      rsa_clear_private_key(&private_key);
d280 1
a280 1
  rsa_clear_private_key(&private_key);
d291 7
a297 5
  fprintf(f, "%d ", public_key.bits);
  mpz_out_str(f, 10, &public_key.e);
  fprintf(f, " ");
  mpz_out_str(f, 10, &public_key.n);
  fprintf(f, " %s\n", new_comment);
d308 2
a309 1
int main(int ac, char **av)
d313 1
d377 4
d411 6
a416 7
  printf("Initializing random number generator...\n");
  sprintf(buf, "%s/%s", pw->pw_dir, SSH_CLIENT_SEEDFILE);
  random_initialize(&state, buf);

  /* Save random seed so we don\'t need to do all that time-consuming
     environmental noise collection the next time. */
  random_save(&state, buf);
d419 3
a421 6
  rsa_generate_key(&private_key, &public_key, &state, bits);

  /* Save the state again, just to remove any fear that the previous state
     could be used to recreate the key.  (That should not be possible anyway
     since the pool is stirred after save and some noise is added.) */
  random_save(&state, buf);
d510 1
a510 1
  if (!save_private_key(buf, passphrase1, &private_key, buf2, &state))
d523 2
a524 2
  rsa_clear_private_key(&private_key);
  random_clear(&state);
d526 2
a527 1
  printf("Your identification has been saved in %s.\n", buf);
d530 10
a539 6
  printf("Your public key is:\n");
  printf("%d ", public_key.bits);
  mpz_out_str(stdout, 10, &public_key.e);
  printf(" ");
  mpz_out_str(stdout, 10, &public_key.n);
  printf(" %s\n", buf2);
d550 7
a556 5
  fprintf(f, "%d ", public_key.bits);
  mpz_out_str(f, 10, &public_key.e);
  fprintf(f, " ");
  mpz_out_str(f, 10, &public_key.n);
  fprintf(f, " %s\n", buf2);
d559 2
a560 1
  printf("Your public key has been saved in %s\n", buf);
@

