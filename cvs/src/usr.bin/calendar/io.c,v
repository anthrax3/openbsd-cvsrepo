head	1.44;
access;
symbols
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.16
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.14
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.12
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.10
	OPENBSD_5_0:1.35.0.8
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.6
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.10
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.6
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.4
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.4
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.4
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.08.31.09.38.47;	author jsg;	state Exp;
branches;
next	1.43;
commitid	d2eKextzIhWB25Pr;

1.43
date	2015.12.08.19.04.50;	author mmcc;	state Exp;
branches;
next	1.42;
commitid	ckwpUKLIIVPtpryy;

1.42
date	2015.10.23.12.36.23;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	eE8F9bKe9DKYyawf;

1.41
date	2015.10.23.11.43.16;	author zhuk;	state Exp;
branches;
next	1.40;
commitid	8WPctGg8P39mEwQm;

1.40
date	2015.10.23.11.01.30;	author zhuk;	state Exp;
branches;
next	1.39;
commitid	EtzX6H9DzQFqjah1;

1.39
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	6b2lLILbgCR1fvia;

1.38
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.37;
commitid	IbVxlqGw2UipKdDr;

1.37
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2013.11.26.13.18.53;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.11.20.50.54;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.24.19.36.10;	author moritz;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.16.16.45.11;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.14.15.56.35;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.15.14.28.56;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.10.15.31.01;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.10.15.00.27;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.02.14.58.46;	author tom;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.14.23.54.11;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.03.02.56.06;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.06.19.59.12;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.13.09.09.29;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.18.20.34.44;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.16.00.30.58;	author vincent;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.03.18.17.48;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.27.18.19.20;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.27.02.55.01;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.26.20.38.55;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.03.16.15.08;	author pjanzen;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.03.15.53.00;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.09.07.04.48;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.05.21.27.16;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.07.19.36.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.02.04.10.47;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.11.25.03.46.47;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	99.04.20.23.03.25;	author pjanzen;	state Exp;
branches;
next	1.6;

1.6
date	98.12.13.07.31.08;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	98.11.08.04.31.13;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.03.30.06.59.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.02.14.21.07.21;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.09.12.04.12.48;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.12.05.06.04.40;	author millert;	state Exp;
branches;
next	;


desc
@@


1.44
log
@fix fd leaks in error paths
ok guenther@@
@
text
@/*	$OpenBSD: io.c,v 1.43 2015/12/08 19:04:50 mmcc Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <locale.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "pathnames.h"
#include "calendar.h"


struct iovec header[] = {
	{ "From: ", 6 },
	{ NULL, 0 },
	{ " (Reminder Service)\nTo: ", 24 },
	{ NULL, 0 },
	{ "\nSubject: ", 10 },
	{ NULL, 0 },
	{ "'s Calendar\nPrecedence: bulk\n",  29 },
	{ "Auto-Submitted: auto-generated\n\n", 32 },
};


void
cal(void)
{
	int ch, l, i, bodun = 0, bodun_maybe = 0, var, printing;
	struct event *events, *cur_evt, *ev1, *tmp;
	char buf[2048 + 1], *prefix = NULL, *p;
	struct match *m;
	FILE *fp;

	events = NULL;
	cur_evt = NULL;
	if ((fp = opencal()) == NULL)
		return;
	for (printing = 0; fgets(buf, sizeof(buf), stdin) != NULL;) {
		if ((p = strchr(buf, '\n')) != NULL)
			*p = '\0';
		else
			while ((ch = getchar()) != '\n' && ch != EOF);
		for (l = strlen(buf); l > 0 && isspace(buf[l - 1]); l--)
			;
		buf[l] = '\0';
		if (buf[0] == '\0')
			continue;
		if (strncmp(buf, "LANG=", 5) == 0) {
			(void) setlocale(LC_ALL, buf + 5);
			setnnames();
			/* XXX remove KOI8 lines after 5.9 is out */
			if (!strcmp(buf + 5, "ru_RU.UTF-8") ||
			    !strcmp(buf + 5, "uk_UA.UTF-8") ||
			    !strcmp(buf + 5, "by_BY.UTF-8") ||
			    !strcmp(buf + 5, "ru_RU.KOI8-R") ||
			    !strcmp(buf + 5, "uk_UA.KOI8-U") ||
			    !strcmp(buf + 5, "by_BY.KOI8-B")) {
				bodun_maybe++;
				bodun = 0;
				free(prefix);
				prefix = NULL;
			} else
				bodun_maybe = 0;
			continue;
		} else if (strncmp(buf, "CALENDAR=", 9) == 0) {
			char *ep;

			if (buf[9] == '\0')
				calendar = 0;
			else if (!strcasecmp(buf + 9, "julian")) {
				calendar = JULIAN;
				errno = 0;
				julian = strtoul(buf + 14, &ep, 10);
				if (buf[0] == '\0' || *ep != '\0')
					julian = 13;
				if ((errno == ERANGE && julian == ULONG_MAX) ||
				    julian > 14)
					errx(1, "Julian calendar offset is too large");
			} else if (!strcasecmp(buf + 9, "gregorian"))
				calendar = GREGORIAN;
			else if (!strcasecmp(buf + 9, "lunar"))
				calendar = LUNAR;
		} else if (bodun_maybe && strncmp(buf, "BODUN=", 6) == 0) {
			bodun++;
			free(prefix);
			if ((prefix = strdup(buf + 6)) == NULL)
				err(1, NULL);
			continue;
		}
		/* User defined names for special events */
		if ((p = strchr(buf, '='))) {
			for (i = 0; i < NUMEV; i++) {
				if (strncasecmp(buf, spev[i].name,
				    spev[i].nlen) == 0 &&
				    (p - buf == spev[i].nlen) &&
				    buf[spev[i].nlen + 1]) {
					p++;
					free(spev[i].uname);
					if ((spev[i].uname = strdup(p)) == NULL)
						err(1, NULL);
					spev[i].ulen = strlen(p);
					i = NUMEV + 1;
				}
			}
			if (i > NUMEV)
				continue;
		}
		if (buf[0] != '\t') {
			printing = (m = isnow(buf, bodun)) ? 1 : 0;
			if ((p = strchr(buf, '\t')) == NULL) {
				printing = 0;
				continue;
			}
			/* Need the following to catch hardwired "variable"
			 * dates */
			if (p > buf && p[-1] == '*')
				var = 1;
			else
				var = 0;
			if (printing) {
				struct match *foo;

				ev1 = NULL;
				while (m) {
					cur_evt = malloc(sizeof(struct event));
					if (cur_evt == NULL)
						err(1, NULL);

					cur_evt->when = m->when;
					snprintf(cur_evt->print_date,
					    sizeof(cur_evt->print_date), "%s%c",
					    m->print_date, (var + m->var) ? '*' : ' ');
					if (ev1) {
						cur_evt->desc = ev1->desc;
						cur_evt->ldesc = NULL;
					} else {
						if (m->bodun && prefix) {
							if (asprintf(&cur_evt->ldesc,
							    "\t%s %s", prefix,
							    p + 1) == -1)
								err(1, NULL);
						} else if ((cur_evt->ldesc =
						    strdup(p)) == NULL)
							err(1, NULL);
						cur_evt->desc = &(cur_evt->ldesc);
						ev1 = cur_evt;
					}
					insert(&events, cur_evt);
					foo = m;
					m = m->next;
					free(foo);
				}
			}
		} else if (printing) {
			if (asprintf(&p, "%s\n%s", ev1->ldesc,
			    buf) == -1)
				err(1, NULL);
			free(ev1->ldesc);
			ev1->ldesc = p;
		}
	}
	tmp = events;
	while (tmp) {
		(void)fprintf(fp, "%s%s\n", tmp->print_date, *(tmp->desc));
		tmp = tmp->next;
	}
	tmp = events;
	while (tmp) {
		events = tmp;
		free(tmp->ldesc);
		tmp = tmp->next;
		free(events);
	}
	closecal(fp);
}

int
getfield(char *p, char **endp, int *flags)
{
	int val, var, i;
	char *start, savech;

	for (; !isdigit((unsigned char)*p) && !isalpha((unsigned char)*p) &&
	    *p != '*' && *p != '\t'; ++p)
		;
	if (*p == '*') {			/* `*' is every month */
		*flags |= F_ISMONTH;
		*endp = p+1;
		return (-1);	/* means 'every month' */
	}
	if (isdigit((unsigned char)*p)) {
		val = strtol(p, &p, 10);	/* if 0, it's failure */
		for (; !isdigit((unsigned char)*p) &&
		    !isalpha((unsigned char)*p) && *p != '*'; ++p)
			;
		*endp = p;
		return (val);
	}
	for (start = p; isalpha((unsigned char)*++p);)
		;

	/* Sunday-1 */
	if (*p == '+' || *p == '-')
		for(; isdigit((unsigned char)*++p); )
			;

	savech = *p;
	*p = '\0';

	/* Month */
	if ((val = getmonth(start)) != 0)
		*flags |= F_ISMONTH;

	/* Day */
	else if ((val = getday(start)) != 0) {
		*flags |= F_ISDAY;

		/* variable weekday */
		if ((var = getdayvar(start)) != 0) {
			if (var <= 5 && var >= -4)
				val += var * 10;
#ifdef DEBUG
			printf("var: %d\n", var);
#endif
		}
	}

	/* Try specials (Easter, Paskha, ...) */
	else {
		for (i = 0; i < NUMEV; i++) {
			if (strncasecmp(start, spev[i].name, spev[i].nlen) == 0) {
				start += spev[i].nlen;
				val = i + 1;
				i = NUMEV + 1;
			} else if (spev[i].uname != NULL &&
			    strncasecmp(start, spev[i].uname, spev[i].ulen) == 0) {
				start += spev[i].ulen;
				val = i + 1;
				i = NUMEV + 1;
			}
		}
		if (i > NUMEV) {
			const char *errstr;

			switch (*start) {
			case '-':
			case '+':
				var = strtonum(start + 1, 0, 365, &errstr);
				if (errstr)
					return (0); /* Someone is just being silly */
				if (*start == '-')
					var = -var;
				val += (NUMEV + 1) * var;
				/* We add one to the matching event and multiply by
				 * (NUMEV + 1) so as not to return 0 if there's a match.
				 * val will overflow if there is an obscenely large
				 * number of special events. */
				break;
			}
			*flags |= F_SPECIAL;
		}
		if (!(*flags & F_SPECIAL)) {
			/* undefined rest */
			*p = savech;
			return (0);
		}
	}
	for (*p = savech; !isdigit((unsigned char)*p) &&
	    !isalpha((unsigned char)*p) && *p != '*' && *p != '\t'; ++p)
		;
	*endp = p;
	return (val);
}


FILE *
opencal(void)
{
	int pdes[2], fdin;
	struct stat st;

	/* open up calendar file as stdin */
	if ((fdin = open(calendarFile, O_RDONLY)) == -1 ||
	    fstat(fdin, &st) == -1 || !S_ISREG(st.st_mode)) {
		if (!doall) {
			char *home = getenv("HOME");
			if (home == NULL || *home == '\0')
				errx(1, "cannot get home directory");
			if (!(chdir(home) == 0 &&
			    chdir(calendarHome) == 0 &&
			    (fdin = open(calendarFile, O_RDONLY)) != -1))
				errx(1, "no calendar file: ``%s'' or ``~/%s/%s''",
				    calendarFile, calendarHome, calendarFile);
		}
	}

	if (pipe(pdes) < 0) {
		close(fdin);
		return (NULL);
	}
	switch (vfork()) {
	case -1:			/* error */
		(void)close(pdes[0]);
		(void)close(pdes[1]);
		close(fdin);
		return (NULL);
	case 0:
		dup2(fdin, STDIN_FILENO);
		/* child -- set stdout to pipe input */
		if (pdes[1] != STDOUT_FILENO) {
			(void)dup2(pdes[1], STDOUT_FILENO);
			(void)close(pdes[1]);
		}
		(void)close(pdes[0]);
		/*
		 * Set stderr to /dev/null.  Necessary so that cron does not
		 * wait for cpp to finish if it's running calendar -a.
		 */
		if (doall) {
			int fderr;
			fderr = open(_PATH_DEVNULL, O_WRONLY, 0);
			if (fderr == -1)
				_exit(0);
			(void)dup2(fderr, STDERR_FILENO);
			(void)close(fderr);
		}
		execl(_PATH_CPP, "cpp", "-traditional", "-undef", "-U__GNUC__",
		    "-P", "-I.", _PATH_INCLUDE, (char *)NULL);
		warn(_PATH_CPP);
		_exit(1);
	}
	/* parent -- set stdin to pipe output */
	(void)dup2(pdes[0], STDIN_FILENO);
	(void)close(pdes[0]);
	(void)close(pdes[1]);

	/* not reading all calendar files, just set output to stdout */
	if (!doall)
		return (stdout);

	/* set output to a temporary file, so if no output don't send mail */
	return(tmpfile());
}

void
closecal(FILE *fp)
{
	struct stat sbuf;
	int nread, pdes[2], status;
	char buf[1024];

	if (!doall)
		return;

	(void)rewind(fp);
	if (fstat(fileno(fp), &sbuf) || !sbuf.st_size)
		goto done;
	if (pipe(pdes) < 0)
		goto done;
	switch (vfork()) {
	case -1:			/* error */
		(void)close(pdes[0]);
		(void)close(pdes[1]);
		goto done;
	case 0:
		/* child -- set stdin to pipe output */
		if (pdes[0] != STDIN_FILENO) {
			(void)dup2(pdes[0], STDIN_FILENO);
			(void)close(pdes[0]);
		}
		(void)close(pdes[1]);
		execl(_PATH_SENDMAIL, "sendmail", "-i", "-t", "-F",
		    "\"Reminder Service\"", (char *)NULL);
		warn(_PATH_SENDMAIL);
		_exit(1);
	}
	/* parent -- write to pipe input */
	(void)close(pdes[0]);

	header[1].iov_base = header[3].iov_base = pw->pw_name;
	header[1].iov_len = header[3].iov_len = strlen(pw->pw_name);
	writev(pdes[1], header, 8);
	while ((nread = read(fileno(fp), buf, sizeof(buf))) > 0)
		(void)write(pdes[1], buf, nread);
	(void)close(pdes[1]);
done:	(void)fclose(fp);
	while (wait(&status) >= 0)
		;
}


void
insert(struct event **head, struct event *cur_evt)
{
	struct event *tmp, *tmp2;

	if (*head) {
		/* Insert this one in order */
		tmp = *head;
		tmp2 = NULL;
		while (tmp->next &&
		    tmp->when <= cur_evt->when) {
			tmp2 = tmp;
			tmp = tmp->next;
		}
		if (tmp->when > cur_evt->when) {
			cur_evt->next = tmp;
			if (tmp2)
				tmp2->next = cur_evt;
			else
				*head = cur_evt;
		} else {
			cur_evt->next = tmp->next;
			tmp->next = cur_evt;
		}
	} else {
		*head = cur_evt;
		cur_evt->next = NULL;
	}
}
@


1.43
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.42 2015/10/23 12:36:23 deraadt Exp $	*/
d338 2
a339 1
	if (pipe(pdes) < 0)
d341 1
d346 1
@


1.42
log
@delete ) that jumped in
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.41 2015/10/23 11:43:16 zhuk Exp $	*/
d101 1
a101 2
				if (prefix)
					free(prefix);
d126 1
a126 2
			if (prefix)
				free(prefix);
d139 1
a139 2
					if (spev[i].uname != NULL)
						free(spev[i].uname);
d211 1
a211 2
		if (tmp->ldesc)
			free(tmp->ldesc);
@


1.41
log
@A bit of whitespace cleanup, to make further diffs smaller.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.40 2015/10/23 11:01:30 zhuk Exp $	*/
d95 1
a95 1
			    !strcmp(buf + 5, "by_BY.UTF-8")) ||
@


1.40
log
@Fix BODUN handling after switch to UTF-8.

Still wondering if this functionality should be removed, but I'll leave
the decision to those who drink alcohol.

Input from & okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.39 2015/04/18 18:28:37 deraadt Exp $	*/
d166 1
a166 1
				
d172 1
a172 1
	
d305 1
a305 1
			*flags |= F_SPECIAL;	
d357 1
a357 1
		/* 
@


1.39
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.38 2015/03/15 00:41:28 millert Exp $	*/
d92 5
a96 1
			if (!strcmp(buf + 5, "ru_RU.KOI8-R") ||
@


1.38
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.37 2015/01/16 06:40:06 deraadt Exp $	*/
d284 3
a286 1
			switch(*start) {
d289 2
a290 2
				var = atoi(start);
				if (var > 365 || var < -365)
d292 2
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.36 2013/11/26 13:18:53 deraadt Exp $	*/
a46 1
#include <tzfile.h>
@


1.36
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.35 2009/10/27 23:59:36 deraadt Exp $	*/
a31 1
#include <sys/param.h>
d49 1
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.34 2007/10/17 20:10:44 chl Exp $	*/
d225 2
a226 1
	for (; !isdigit(*p) && !isalpha(*p) && *p != '*' && *p != '\t'; ++p)
d233 1
a233 1
	if (isdigit(*p)) {
d235 2
a236 1
		for (; !isdigit(*p) && !isalpha(*p) && *p != '*'; ++p)
d241 1
a241 1
	for (start = p; isalpha(*++p);)
d246 1
a246 1
		for(; isdigit(*++p); )
d306 2
a307 1
	for (*p = savech; !isdigit(*p) && !isalpha(*p) && *p != '*' && *p != '\t'; ++p)
@


1.34
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.33 2006/12/11 20:50:54 deraadt Exp $	*/
a30 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)calendar.c  8.3 (Berkeley) 3/25/94";
#else
static const char rcsid[] = "$OpenBSD: io.c,v 1.33 2006/12/11 20:50:54 deraadt Exp $";
#endif
#endif /* not lint */
@


1.33
log
@rfc 3834 support: Auto-Submitted: auto-generated on lots of things; from Tamas TEVESZ; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.32 2005/11/24 19:36:10 moritz Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: io.c,v 1.32 2005/11/24 19:36:10 moritz Exp $";
a87 1
	size_t nlen;
@


1.32
log
@fix use after free introduced in r1.30. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.31 2005/11/16 16:45:11 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: io.c,v 1.31 2005/11/16 16:45:11 deraadt Exp $";
d76 2
a77 1
	{ "'s Calendar\nPrecedence: bulk\n\n",  30 },
d429 1
a429 1
	writev(pdes[1], header, 7);
@


1.31
log
@knf & cleanup; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.30 2005/11/14 15:56:35 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: io.c,v 1.30 2005/11/14 15:56:35 deraadt Exp $";
d210 1
a210 2
			free(ev1->ldesc);
			if (asprintf(&ev1->ldesc, "%s\n%s", ev1->ldesc,
d213 2
a214 1
		
@


1.30
log
@use asprintf(); ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.29 2005/04/15 14:28:56 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: io.c,v 1.29 2005/04/15 14:28:56 otto Exp $";
d70 7
a76 7
	{"From: ", 6},
	{NULL, 0},
	{" (Reminder Service)\nTo: ", 24},
	{NULL, 0},
	{"\nSubject: ", 10},
	{NULL, 0},
	{"'s Calendar\nPrecedence: bulk\n\n",  30},
d83 1
a83 6
	int printing;
	char *p;
	FILE *fp;
	int ch, l, i, bodun = 0, bodun_maybe = 0;
	int var;
	char buf[2048 + 1], *prefix = NULL;
d85 1
d88 1
d147 12
a158 9
			if (strncasecmp(buf, spev[i].name, spev[i].nlen) == 0 &&
			    (p - buf == spev[i].nlen) && buf[spev[i].nlen + 1]) {
				p++;
				if (spev[i].uname != NULL)
					free(spev[i].uname);
				if ((spev[i].uname = strdup(p)) == NULL)
					err(1, NULL);
				spev[i].ulen = strlen(p);
				i = NUMEV + 1;
d160 2
a161 3
			}
		if (i > NUMEV)
			continue;
d180 19
a198 15
				cur_evt = (struct event *) malloc(sizeof(struct event));
				if (cur_evt == NULL)
					err(1, NULL);

				cur_evt->when = m->when;
				snprintf(cur_evt->print_date,
				    sizeof(cur_evt->print_date), "%s%c",
				    m->print_date, (var + m->var) ? '*' : ' ');
				if (ev1) {
					cur_evt->desc = ev1->desc;
					cur_evt->ldesc = NULL;
				} else {
					if (m->bodun && prefix) {
						if (asprintf(&cur_evt->ldesc,
						    "\t%s %s", prefix, p + 1) == -1)
d200 7
a206 10
					} else if ((cur_evt->ldesc =
					    strdup(p)) == NULL)
						err(1, NULL);
					cur_evt->desc = &(cur_evt->ldesc);
					ev1 = cur_evt;
				}
				insert(&events, cur_evt);
				foo = m;
				m = m->next;
				free(foo);
d234 1
a234 3
getfield(p, endp, flags)
	char *p, **endp;
	int *flags;
d258 2
a259 2
	    for(; isdigit(*++p);)
		;
d270 1
a270 1
	    *flags |= F_ISDAY;
d272 4
a275 4
	    /* variable weekday */
	    if ((var = getdayvar(start)) != 0) {
		if (var <= 5 && var >= -4)
		    val += var * 10;
d277 1
a277 1
		printf("var: %d\n", var);
d279 1
a279 1
	    }
d300 9
a308 9
			   var = atoi(start);
			   if (var > 365 || var < -365)
				   return (0); /* Someone is just being silly */
			   val += (NUMEV + 1) * var;
			   /* We add one to the matching event and multiply by
			    * (NUMEV + 1) so as not to return 0 if there's a match.
			    * val will overflow if there is an obscenely large
			    * number of special events. */
			   break;
d310 1
a310 1
		*flags |= F_SPECIAL;	
d313 1
a313 1
		/* undefined rest */
d392 1
a392 2
closecal(fp)
	FILE *fp;
d439 1
a439 3
insert(head, cur_evt)
	struct event **head;
	struct event *cur_evt;
@


1.29
log
@Remove standard defines from cpp processing, to prevent accidental
substitutions (e.g. i386 -> 1). From John L. Scarfone, PR 4176.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.28 2004/12/10 15:31:01 mickey Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: io.c,v 1.28 2004/12/10 15:31:01 mickey Exp $";
d194 2
a195 5
						int l1 = strlen(prefix);
						int l2 = strlen(p);
						int len = l1 + l2 + 2;
						if ((cur_evt->ldesc =
						    malloc(len)) == NULL)
a196 2
						snprintf(cur_evt->ldesc, len,
						    "\t%s %s", prefix, p + 1);
d209 4
a212 4
		}
		else if (printing) {
			nlen = strlen(ev1->ldesc) + strlen(buf) + 2;
			if ((ev1->ldesc = realloc(ev1->ldesc, nlen)) == NULL)
d214 1
a214 1
			snprintf(ev1->ldesc, nlen, "%s\n%s", ev1->ldesc, buf);
@


1.28
log
@cleanup extra includes and -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.27 2004/12/10 15:00:27 mickey Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: io.c,v 1.27 2004/12/10 15:00:27 mickey Exp $";
d380 2
a381 2
		execl(_PATH_CPP, "cpp", "-traditional", "-P", "-I.",
		    _PATH_INCLUDE, (char *)NULL);
@


1.27
log
@allow calendar files in julian
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.26 2004/06/02 14:58:46 tom Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.26 2004/06/02 14:58:46 tom Exp $";
@


1.26
log
@Don't want text in err() call following malloc failures.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.25 2004/01/14 23:54:11 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.25 2004/01/14 23:54:11 millert Exp $";
d121 19
a139 2
		}
		if (bodun_maybe && strncmp(buf, "BODUN=", 6) == 0) {
d145 1
@


1.25
log
@calendar relies on cpp -traditional behavior so explicitly specify -traditional
when running cpp.  mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.24 2003/06/03 02:56:06 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.24 2003/06/03 02:56:06 millert Exp $";
d181 1
a181 1
							err(1, "malloc");
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.23 2003/04/06 19:59:12 grange Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.23 2003/04/06 19:59:12 grange Exp $";
d362 2
a363 1
		execl(_PATH_CPP, "cpp", "-P", "-I.", _PATH_INCLUDE, (char *)NULL);
@


1.23
log
@kill strcat
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.22 2003/03/13 09:09:29 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: io.c,v 1.22 2003/03/13 09:09:29 deraadt Exp $";
@


1.22
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.21 2002/12/18 20:34:44 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.21 2002/12/18 20:34:44 mickey Exp $";
d95 1
d202 2
a203 2
			if ((ev1->ldesc = realloc(ev1->ldesc,
			    (2 + strlen(ev1->ldesc) + strlen(buf)))) == NULL)
d205 1
a205 2
			strcat(ev1->ldesc, "\n");
			strcat(ev1->ldesc, buf);
@


1.21
log
@t'was not enough space malloced when generating the bodun entries
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.20 2002/10/16 00:30:58 vincent Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.20 2002/10/16 00:30:58 vincent Exp $";
d181 1
d183 1
a183 1
						    malloc(l1 + l2 + 2)) == NULL)
d185 1
a185 1
						sprintf(cur_evt->ldesc,
@


1.20
log
@ don't bork if there's a "calendar" directory in the current directory....

 ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.19 2001/11/19 19:02:13 mpech Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.19 2001/11/19 19:02:13 mpech Exp $";
d182 1
a182 1
						    malloc(l1 + l2)) == NULL)
@


1.19
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.18 2001/10/03 18:17:48 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.18 2001/10/03 18:17:48 deraadt Exp $";
d85 1
a85 1
cal()
d318 1
a318 1
opencal()
d320 2
a321 2
	int pdes[2];
	int fdin;
d324 2
a325 1
	if ((fdin = open(calendarFile, O_RDONLY)) == -1) {
d337 1
d353 2
a354 1
		/* Set stderr to /dev/null.  Necessary so that cron does not
@


1.18
log
@error printout fix; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.17 2001/09/27 18:19:20 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.17 2001/09/27 18:19:20 mickey Exp $";
d87 2
a88 2
	register int printing;
	register char *p;
@


1.17
log
@some fixes and cleanups some from dfa@@solo.ee, some pointed
out by pjanzen@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.16 2001/09/27 02:55:01 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.16 2001/09/27 02:55:01 mickey Exp $";
d332 1
a332 1
				errx(1, "no calendar file: ``%s'' or ``~/%s/%s",
@


1.16
log
@-Wall passage for prev commit
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.15 2001/09/26 20:38:55 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.15 2001/09/26 20:38:55 mickey Exp $";
d92 1
a92 1
	char buf[2048 + 1];
d117 4
a120 1
				bodun = bodun_always;
d125 1
a125 1
		if (bodun_maybe && strncmp(buf, "BODUN=", 6) == 0)
d127 5
d178 2
a179 2
					if (m->prefix[0]) {
						int l1 = strlen(m->prefix);
d183 3
a185 3
							err(1, "realloc");
						sprintf(cur_evt->ldesc, "\t%s%s",
						    m->prefix, p + 1);
@


1.15
log
@special procesing for cyrillic calendars (.ru, .ua, .by for now).
does not affect any existing behaviour for everything else.
old idea expressed by form@@; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.14 2001/09/03 16:15:08 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.14 2001/09/03 16:15:08 pjanzen Exp $";
d90 1
a90 1
	int ch, l, i, bodun, bodun_maybe;
@


1.14
log
@No longer any reason to care if calendar file is a pipe or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.13 2001/09/03 15:53:00 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.13 2001/09/03 15:53:00 pjanzen Exp $";
d90 1
a90 1
	int ch, l, i;
d113 7
d122 2
d142 1
a142 1
			printing = (m = isnow(buf)) ? 1 : 0;
d170 10
a179 1
					if ((cur_evt->ldesc = strdup(p)) == NULL)
@


1.13
log
@- Prevent users from hanging or killing 'calendar -a', at the cost of
one additional fork() per user who has a calendar file.  Side effect is
that root runs much less code.
- Use login caps so we don't, for example, give a user more processes than
he's allowed.
- tmpfile() rather than mkstemp() means never leaving junk behind.
- Don't let 'calendar -a' take more than a day.

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.12 2001/07/09 07:04:48 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.12 2001/07/09 07:04:48 deraadt Exp $";
a55 1
#include <sys/file.h>
d60 1
a83 2
int	openf(char *path);

a289 24
char path[MAXPATHLEN];

int
openf(path)
	char *path;
{
	struct stat st;
	int fd;

	fd = open(path, O_RDONLY|O_NONBLOCK);
	if (fd == -1)
		return (-1);
	if (fstat(fd, &st) == -1) {
		close(fd);
		return (-1);
	}
	if ((st.st_mode & S_IFMT) != S_IFREG) {
		close (fd);
		return (-1);
	}

	fcntl(fd, F_SETFD, fcntl(fd, F_GETFD, 0) &~ O_NONBLOCK);
	return (fd);
}
d298 1
a298 1
	if ((fdin = openf(calendarFile)) == -1) {
d305 1
a305 1
			    (fdin = openf(calendarFile)) != -1))
@


1.12
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.11 2001/06/05 21:27:16 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.11 2001/06/05 21:27:16 pjanzen Exp $";
a72 4
char *calendarFile = "calendar";  /* default calendar file */
char *calendarHome = ".calendar"; /* HOME */
char *calendarNoMail = "nomail";  /* don't sent mail if this file exist */

d320 1
a320 1
	int fd, pdes[2];
a321 1
	struct stat sbuf;
d325 1
a325 8
		if (doall) {
			if (chdir(calendarHome) != 0)
				return (NULL);
			if (stat(calendarNoMail, &sbuf) == 0)
				return (NULL);
			if ((fdin = openf(calendarFile)) == -1)
				return (NULL);
		} else {
d351 11
a361 2
		(void)setuid(geteuid());
		(void)setgid(getegid());
d376 1
a376 4
	(void)snprintf(path, sizeof(path), "%s/_calXXXXXX", _PATH_TMP);
	if ((fd = mkstemp(path)) < 0)
		return (NULL);
	return (fdopen(fd, "w+"));
a406 2
		(void)setuid(geteuid());
		(void)setgid(getegid());
a421 1
	(void)unlink(path);
@


1.11
log
@errx->err where errno is set
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.10 2000/12/07 19:36:37 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.10 2000/12/07 19:36:37 deraadt Exp $";
d365 1
a365 1
		execl(_PATH_CPP, "cpp", "-P", "-I.", _PATH_INCLUDE, NULL);
d416 1
a416 1
		    "\"Reminder Service\"", NULL);
@


1.10
log
@only accept real files for the calendar file.  requires some cute
nonblocking hackery.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.9 2000/08/02 04:10:47 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.9 2000/08/02 04:10:47 millert Exp $";
d130 1
a130 1
					errx(1, "cannot allocate memory");
d157 1
a157 1
					errx(1, "cannot allocate memory");
d168 1
a168 1
						errx(1, "cannot allocate memory");
d182 1
a182 1
				errx(1, "cannot allocate memory");
@


1.9
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.8 1999/11/25 03:46:47 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.8 1999/11/25 03:46:47 pjanzen Exp $";
d56 1
d88 2
d111 1
a111 3
		for (l = strlen(buf);
		     l > 0 && isspace(buf[l - 1]);
		     l--)
d298 23
d325 1
d329 1
a329 1
	if (!freopen(calendarFile, "r", stdin)) {
d331 6
a336 6
		    if (chdir(calendarHome) != 0)
			return (NULL);
		    if (stat(calendarNoMail, &sbuf) == 0)
		        return (NULL);
		    if (!freopen(calendarFile, "r", stdin))
		        return (NULL);
d341 3
a343 3
		        chdir(home);
			if (!(chdir(calendarHome) == 0 &&
			      freopen(calendarFile, "r", stdin)))
d356 2
a357 1
		/* child -- stdin already setup, set stdout to pipe input */
d431 2
a432 1
	while (wait(&status) >= 0);
@


1.8
log
@Parse dates only before the first <tab> character; otherwise, weekly events
whose description starts with a valid month are misparsed.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.7 1999/04/20 23:03:25 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.7 1999/04/20 23:03:25 pjanzen Exp $";
d313 4
a316 1
		        chdir(getenv("HOME"));
@


1.7
log
@Don't call sendmail with "-f root" since sendmail isn't run by a "trusted
user".  Removes the X-Authentication-Warning.  From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.6 1998/12/13 07:31:08 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.6 1998/12/13 07:31:08 pjanzen Exp $";
d210 1
a210 1
	for (; !isdigit(*p) && !isalpha(*p) && *p != '*'; ++p)
d289 1
a289 1
	for (*p = savech; !isdigit(*p) && !isalpha(*p) && *p != '*'; ++p)
@


1.6
log
@Show periodic events the correct number of times.
Calculate special events (Easter) correctly regardless of which year
they occur in (thus fixing user/562).
Keep locales and special event names from propogating from one user
to the next during "calendar -a".
Set up a framework to handle special events other than Easter (for instance,
Jewish events, eventually).
Various other fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.5 1998/11/08 04:31:13 pjanzen Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.5 1998/11/08 04:31:13 pjanzen Exp $";
d387 1
a387 1
		    "\"Reminder Service\"", "-f", "root", NULL);
@


1.5
log
@Sort output by date; include framework for showing periodic events more than
once
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.4 1998/03/30 06:59:27 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.4 1998/03/30 06:59:27 deraadt Exp $";
a75 2
struct fixs neaster, npaskha;

d93 1
a93 1
	int ch, l;
d96 1
a96 1
	struct event *events, *cur_evt, *tmp;
d120 15
a134 14
		if (strncasecmp(buf, "Easter=", 7) == 0 && buf[7]) {
			if (neaster.name != NULL)
				free(neaster.name);
			if ((neaster.name = strdup(buf + 7)) == NULL)
				errx(1, "cannot allocate memory");
			neaster.len = strlen(buf + 7);
			continue;
		}
		if (strncasecmp(buf, "Paskha=", 7) == 0 && buf[7]) {
			if (npaskha.name != NULL)
				free(npaskha.name);
			if ((npaskha.name = strdup(buf + 7)) == NULL)
				errx(1, "cannot allocate memory");
			npaskha.len = strlen(buf + 7);
d139 2
a140 1
			if ((p = strchr(buf, '\t')) == NULL)
d142 1
a149 1
				struct tm tm;
a150 1
				char *dsc;
d152 1
a152 1
				dsc = NULL;
d158 9
a166 21
				tm.tm_sec = 0;  /* unused */
				tm.tm_min = 0;  /* unused */
				tm.tm_hour = 12; /* unused */
				tm.tm_wday = 0; /* unused */
				tm.tm_mon = m->month - 1;
				tm.tm_mday = m->day;
				tm.tm_year = m->year;
				tm.tm_isdst = tp->tm_isdst; /* unused */
				tm.tm_gmtoff = tp->tm_gmtoff; /* unused */
				tm.tm_zone = tp->tm_zone; /* unused */
				(void)strftime(cur_evt->print_date,
				    sizeof(cur_evt->print_date) - 1,
				/*    "%a %b %d", &tm);  Skip weekdays */
				    "%b %d", &tm);
				strcat(cur_evt->print_date,
				    (var + m->var) ? "*" : " ");
				cur_evt->when = mktime(&tm);
				if (dsc)
					cur_evt->desc = dsc;
				else {
					if ((cur_evt->desc = strdup(p)) == NULL)
d168 2
a169 1
					dsc = cur_evt->desc;
d179 2
a180 2
			if ((cur_evt->desc = realloc(cur_evt->desc,
			    (2 + strlen(cur_evt->desc) + strlen(buf)))) == NULL)
d182 2
a183 2
			strcat(cur_evt->desc, "\n");
			strcat(cur_evt->desc, buf);
d188 5
a192 3
		(void)fprintf(fp, "%s%s\n", tmp->print_date, tmp->desc);
		/* Can't free descriptions since they may be shared */
		(void)realloc(tmp->desc, 0);
d194 2
d207 1
a207 1
	int val, var;
d212 1
a212 1
	if (*p == '*') {			/* `*' is current month */
d215 1
a215 1
		return (tp->tm_mon + 1);
d245 1
a245 1
		if (var <=5 && var >= -4)
d253 1
a253 9
	/* Easter */
	else if ((val = geteaster(start, tp->tm_year + TM_YEAR_BASE)) != 0)
	    *flags |= F_EASTER;

	/* Paskha */
	else if ((val = getpaskha(start, tp->tm_year + TM_YEAR_BASE)) != 0)
	    *flags |= F_EASTER;

	/* undefined rest */
d255 33
a287 2
		*p = savech;
		return (0);
@


1.4
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.3 1998/02/14 21:07:21 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.3 1998/02/14 21:07:21 millert Exp $";
a95 2
	int month;
	int day;
d98 2
d101 2
d139 1
a139 1
			printing = isnow(buf, &month, &day, &var) ? 1 : 0;
d142 2
d146 2
d150 8
a157 1
				char dbuf[30];
d161 1
a161 1
				tm.tm_hour = 0; /* unused */
d163 3
a165 3
				tm.tm_mon = month - 1;
				tm.tm_mday = day;
				tm.tm_year = tp->tm_year; /* unused */
d169 19
a187 5
				(void)strftime(dbuf, sizeof(dbuf), "%a %b %d",
				    &tm);
				(void)fprintf(fp, "%s%c%s\n",
				    dbuf + 4/* skip weekdays */,
				    var ? '*' : ' ', p);
d190 16
a205 2
		else if (printing)
			fprintf(fp, "%s\n", buf);
d388 33
@


1.3
log
@Give correct format to strftime(3) instead of using "%c" and making
assumptions as to what that will look like (which is idiotic as %c
is locale-dependent).
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.2 1997/09/12 04:12:48 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.2 1997/09/12 04:12:48 millert Exp $";
d65 1
d221 1
a221 1
	else if ((val = geteaster(start, tp->tm_year + 1900)) != 0)
d225 1
a225 1
	else if ((val = getpaskha(start, tp->tm_year + 1900)) != 0)
@


1.2
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.1 1996/12/05 06:04:40 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: io.c,v 1.1 1996/12/05 06:04:40 millert Exp $";
d152 5
a156 2
				(void)strftime(dbuf, sizeof(dbuf), "%c", &tm);
				dbuf[10] = '\0';
@


1.1
log
@FreeBSD calendar(1) + OpenBSD changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: $";
d256 2
a257 1
				errx(1, "no calendar file: ``%s'' or ``~/%s/%s\n", calendarFile, calendarHome, calendarFile);
@
