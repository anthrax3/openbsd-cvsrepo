head	1.2;
access;
symbols
	OPENBSD_4_7:1.1.1.1.0.46
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.48
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.44
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.42
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.40
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.38
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.36
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.34
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.32
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.30
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.28
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.26
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.24
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.22
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.20
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.18
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.16
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.14
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.12
	OPENBSD_2_8:1.1.1.1.0.10
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	ian_1998-Sep-28:1.1.1.1
	ian:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2010.07.01.02.32.41;	author ian;	state dead;
branches;
next	1.1;

1.1
date	98.09.28.16.01.27;	author ian;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.28.16.01.27;	author ian;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove a long-dead skeleton found under the floorboards.
"go for it" tedu@@, "kill it" deraadt@@
@
text
@#print
Write a subroutine myexp(x) which expects a floating
argument x and returns the floating point value
of e to the x.  An adequate algorithm
for the purpose is the standard Maclaurin series

   x            2       3       4
  e  = 1 + x + x /2! + x /3! + x /4! + ...
Name your routine myexp(), not exp().  You can test it, then,
by comparing it with the system routine as well as by
comparing it with tables.  Leave it on file
myexp.c, and then type "ready".
#once #create reldif.c
double reldif(a,b)
 double a,b;
{
double c,d;
if (a==0. && b==0.) return(0.);
c = a>0 ? a : -a;
d = b>0 ? b : -b;
c = c>d ? c : d;
return( (a-b)/c );
}
#once #create tzaqc.c
main()
{
double x,y, log(), myexp(), reldif();
for(x=1.; x<5.; x=+ 0.2)
  {
  y = myexp(x);
 if (reldif(x, log(y)) >1.e-5) return(1);
  }
return(0);
}
exp()
{
printf("Cheat! you called the system routine\n");
return(1.2);
}
#user
cc tzaqc.c myexp.o reldif.c
a.out
#succeed
/* one way */
double myexp(x)
double x;
{
	double term, sum, dabs();
	int n;
	
	term = sum = 1.0;
	n = 1;
	while (dabs(term) > dabs(sum)/1.e8) {
		term = term * x / n++;
		sum += term;
	}
	return(sum);
}

double dabs(x)
double x;
{
	return(x>0 ? x : -x);
}
#log
#next
50.1a 10
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import BTL learn(1) lessons/C
@
text
@@
