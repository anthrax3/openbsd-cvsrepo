head	1.70;
access;
symbols
	OPENBSD_6_2:1.70.0.10
	OPENBSD_6_2_BASE:1.70
	OPENBSD_6_1:1.70.0.8
	OPENBSD_6_1_BASE:1.70
	OPENBSD_6_0:1.70.0.4
	OPENBSD_6_0_BASE:1.70
	OPENBSD_5_9:1.70.0.2
	OPENBSD_5_9_BASE:1.70
	OPENBSD_5_8:1.67.0.4
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.65.0.18
	OPENBSD_5_6_BASE:1.65
	OPENBSD_5_5:1.65.0.16
	OPENBSD_5_5_BASE:1.65
	OPENBSD_5_4:1.65.0.12
	OPENBSD_5_4_BASE:1.65
	OPENBSD_5_3:1.65.0.10
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.8
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.6
	OPENBSD_5_0:1.65.0.4
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.65.0.2
	OPENBSD_4_9_BASE:1.65
	OPENBSD_4_8:1.58.0.4
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.57.0.10
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.57.0.6
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.57.0.4
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.56.0.16
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.56.0.14
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.56.0.12
	OPENBSD_4_0_BASE:1.56
	OPENBSD_3_9:1.56.0.10
	OPENBSD_3_9_BASE:1.56
	OPENBSD_3_8:1.56.0.8
	OPENBSD_3_8_BASE:1.56
	OPENBSD_3_7:1.56.0.6
	OPENBSD_3_7_BASE:1.56
	OPENBSD_3_6:1.56.0.4
	OPENBSD_3_6_BASE:1.56
	OPENBSD_3_5:1.56.0.2
	OPENBSD_3_5_BASE:1.56
	OPENBSD_3_4:1.54.0.2
	OPENBSD_3_4_BASE:1.54
	OPENBSD_3_3:1.51.0.2
	OPENBSD_3_3_BASE:1.51
	OPENBSD_3_2:1.46.0.2
	OPENBSD_3_2_BASE:1.46
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	OPENBSD_3_0:1.42.0.2
	OPENBSD_3_0_BASE:1.42
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.2
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.31.0.10
	OPENBSD_2_7_BASE:1.31
	OPENBSD_2_6:1.31.0.8
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.31.0.6
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.31.0.4
	OPENBSD_2_4_BASE:1.31
	OPENBSD_2_3:1.31.0.2
	OPENBSD_2_3_BASE:1.31
	OPENBSD_2_2:1.30.0.2
	OPENBSD_2_2_BASE:1.30
	OPENBSD_2_1:1.21.0.2
	OPENBSD_2_1_BASE:1.21
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.70
date	2015.10.30.19.45.03;	author miod;	state Exp;
branches;
next	1.69;
commitid	nGZhoGod3UoQYv9V;

1.69
date	2015.10.24.19.47.44;	author miod;	state Exp;
branches;
next	1.68;
commitid	SDfTQVGVOufenmat;

1.68
date	2015.10.23.03.44.59;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	S6fSsjJDkd4RSH1U;

1.67
date	2015.04.15.02.12.00;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	8rADNyoMd4msoGB9;

1.66
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	Uu5nFG3wCl0LACBb;

1.65
date	2011.01.11.10.07.56;	author robert;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.13.14.46.19;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2010.12.10.19.55.37;	author martynas;	state Exp;
branches;
next	1.62;

1.62
date	2010.12.09.16.10.00;	author sobrado;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.09.16.02.42;	author sobrado;	state Exp;
branches;
next	1.60;

1.60
date	2010.12.09.15.50.55;	author sobrado;	state Exp;
branches;
next	1.59;

1.59
date	2010.12.09.15.45.30;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.27.23.59.44;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.19.21.03.51;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2003.11.09.20.13.58;	author otto;	state Exp;
branches;
next	1.55;

1.55
date	2003.09.26.21.43.32;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.21.23.27.33;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.20.18.15.35;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.12.17.19.52.02;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2002.12.08.16.50.07;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.12.07.22.54.13;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.11.08.23.20.19;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2002.10.16.01.06.32;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.22.04.51.17;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.29.10.47.10;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.18.16.37.59;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.18.04.41.09;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.25.21.29.31;	author hin;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.25.16.18.38;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.31.18.41.16;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.31.17.34.17;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.29.21.40.36;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.02.22.44.49;	author hin;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.15.07.13.50;	author deraadt;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.08.20.18.42.41;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.30.16.00.21;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	98.03.25.21.27.27;	author art;	state Exp;
branches
	1.31.10.1;
next	1.30;

1.30
date	97.09.11.11.21.55;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.06.29.11.10.35;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	97.06.27.06.59.58;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	97.06.23.09.23.12;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.06.22.23.03.10;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.06.21.12.18.05;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.06.20.22.09.53;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.06.20.21.59.17;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.06.20.02.12.40;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.02.18.20.07.56;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	97.02.11.18.26.32;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.02.11.05.00.55;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	97.01.15.23.43.16;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	96.12.22.03.26.03;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	96.10.27.16.49.17;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	96.10.26.03.19.31;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	96.10.23.01.28.57;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	96.10.21.19.33.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.10.21.19.31.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.10.21.19.26.24;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.10.21.18.55.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.10.16.00.37.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.12.20.40.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.10.12.17.13.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.10.08.18.36.56;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.22.01.58.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.39.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.07.09.51.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.16.22.20.38;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches;
next	;

1.31.10.1
date	2000.10.06.20.20.59;	author jason;	state Exp;
branches;
next	;

1.34.2.1
date	2000.12.08.09.03.15;	author hin;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Redo 1.69, but correctly, so that this really works for yp setups.
@
text
@/*	$OpenBSD: su.c,v 1.69 2015/10/24 19:47:44 miod Exp $	*/

/*
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/resource.h>

#include <err.h>
#include <errno.h>
#include <grp.h>
#include <login_cap.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <utmp.h>
#include <stdarg.h>
#include <bsd_auth.h>

char   *getloginname(void);
char   *ontty(void);
int	chshell(const char *);
int	verify_user(char *, struct passwd *, char *, login_cap_t *,
	    auth_session_t *);
void	usage(void);
void	auth_err(auth_session_t *, int, const char *, ...);
void	auth_errx(auth_session_t *, int, const char *, ...);

int
main(int argc, char **argv)
{
	int asme = 0, asthem = 0, ch, fastlogin = 0, emlogin = 0, prio;
	int altshell = 0, homeless = 0;
	char *user, *shell = NULL, *avshell, *username, **np;
	char *class = NULL, *style = NULL, *p;
	enum { UNSET, YES, NO } iscsh = UNSET;
	char avshellbuf[PATH_MAX];
	extern char **environ;
	auth_session_t *as;
	struct passwd *pwd;
	login_cap_t *lc;
	uid_t ruid;
	u_int flags;

	if (pledge("stdio rpath getpw proc exec id", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "a:c:fKLlms:-")) != -1)
		switch (ch) {
		case 'a':
			if (style)
				usage();
			style = optarg;
			break;
		case 'c':
			if (class)
				usage();
			class = optarg;
			break;
		case 'f':
			fastlogin = 1;
			break;
		case 'K':
			if (style)
				usage();
			style = "passwd";
			break;
		case 'L':
			emlogin = 1;
			break;
		case 'l':
		case '-':
			asme = 0;
			asthem = 1;
			break;
		case 'm':
			asme = 1;
			asthem = 0;
			break;
		case 's':
			altshell = 1;
			shell = optarg;
			break;
		default:
			usage();
		}
	argv += optind;

	errno = 0;
	prio = getpriority(PRIO_PROCESS, 0);
	if (errno)
		prio = 0;
	setpriority(PRIO_PROCESS, 0, -2);
	openlog("su", LOG_CONS, 0);

	if ((as = auth_open()) == NULL) {
		syslog(LOG_ERR, "auth_open: %m");
		err(1, "unable to initialize BSD authentication");
	}
	auth_setoption(as, "login", "yes");

	/* get current login name and shell */
	ruid = getuid();
	username = getlogin();

	if (ruid && class)
		auth_errx(as, 1, "only the superuser may specify a login class");

	if (ruid && altshell)
		auth_errx(as, 1, "only the superuser may specify a login shell");

	if (username != NULL)
		auth_setoption(as, "invokinguser", username);

	if (username == NULL || (pwd = getpwnam(username)) == NULL ||
	    pwd->pw_uid != ruid)
		pwd = getpwuid(ruid);
	if (pwd == NULL)
		auth_errx(as, 1, "who are you?");
	if ((username = strdup(pwd->pw_name)) == NULL)
		auth_errx(as, 1, "can't allocate memory");
	if (asme && !altshell) {
		if (pwd->pw_shell && *pwd->pw_shell) {
			if ((shell = strdup(pwd->pw_shell)) == NULL)
				auth_errx(as, 1, "can't allocate memory");
		} else {
			shell = _PATH_BSHELL;
			iscsh = NO;
		}
	}

	for (;;) {
		/* get target user, default to root unless in -L mode */
		if (*argv) {
			user = *argv;
		} else if (emlogin) {
			if ((user = getloginname()) == NULL) {
				auth_close(as);
				exit(1);
			}
		} else {
			user = "root";
		}
		/* style may be specified as part of the username */
		if ((p = strchr(user, ':')) != NULL) {
			*p++ = '\0';
			style = p;	/* XXX overrides -a flag */
		}

		/*
		 * Clean and setup our current authentication session.
		 * Note that options *are* not cleared.
		 */
		auth_clean(as);
		if (auth_setitem(as, AUTHV_INTERACTIVE, "True") != 0 ||
		    auth_setitem(as, AUTHV_NAME, user) != 0)
			auth_errx(as, 1, "can't allocate memory");
		if ((user = auth_getitem(as, AUTHV_NAME)) == NULL)
			auth_errx(as, 1, "internal error");
		if (auth_setpwd(as, NULL) || (pwd = auth_getpwd(as)) == NULL) {
			if (emlogin)
				pwd = NULL;
			else
				auth_errx(as, 1, "unknown login %s", user);
		}

		/* If the user specified a login class, use it */
		if (!class && pwd && pwd->pw_class && pwd->pw_class[0] != '\0')
			class = strdup(pwd->pw_class);
		if ((lc = login_getclass(class)) == NULL)
			auth_errx(as, 1, "no such login class: %s",
			    class ? class : LOGIN_DEFCLASS);

		if ((ruid == 0 && !emlogin) ||
		    verify_user(username, pwd, style, lc, as) == 0)
			break;
		syslog(LOG_AUTH|LOG_WARNING, "BAD SU %s to %s%s",
		    username, user, ontty());
		if (!emlogin) {
			fprintf(stderr, "Sorry\n");
			auth_close(as);
			exit(1);
		}
		fprintf(stderr, "Login incorrect\n");
	}

	if (pledge("stdio rpath getpw exec id", NULL) == -1)
		err(1, "pledge");

	if (!altshell) {
		if (asme) {
			/* if asme and non-std target shell, must be root */
			if (ruid && !chshell(shell))
				auth_errx(as, 1, "permission denied (shell).");
		} else if (pwd->pw_shell && *pwd->pw_shell) {
			if ((shell = strdup(pwd->pw_shell)) == NULL)
				auth_errx(as, 1, "can't allocate memory");
			iscsh = UNSET;
		} else {
			shell = _PATH_BSHELL;
			iscsh = NO;
		}
	}

	if ((p = strrchr(shell, '/')))
		avshell = p+1;
	else
		avshell = shell;

	/* if we're forking a csh, we want to slightly muck the args */
	if (iscsh == UNSET)
		iscsh = strcmp(avshell, "csh") ? NO : YES;

	if (!asme) {
		if (asthem) {
			p = getenv("TERM");
			if ((environ = calloc(1, sizeof (char *))) == NULL)
				auth_errx(as, 1, "calloc");
			if (setusercontext(lc, pwd, pwd->pw_uid, LOGIN_SETPATH))
				auth_err(as, 1, "unable to set user context");
			if (p && setenv("TERM", p, 1) == -1)
				auth_err(as, 1, "unable to set environment");

			setegid(pwd->pw_gid);
			seteuid(pwd->pw_uid);

			homeless = chdir(pwd->pw_dir);
			if (homeless) {
				if (login_getcapbool(lc, "requirehome", 0)) {
					auth_err(as, 1, "%s", pwd->pw_dir);
				} else {
					printf("No home directory %s!\n", pwd->pw_dir);
					printf("Logging in with home = \"/\".\n");
					if (chdir("/") < 0)
						auth_err(as, 1, "/");
				}
			}
			setegid(0);	/* XXX use a saved gid instead? */
			seteuid(0);
		} else if (pwd->pw_uid == 0) {
			if (setusercontext(lc,
			    pwd, pwd->pw_uid, LOGIN_SETPATH|LOGIN_SETUMASK))
				auth_err(as, 1, "unable to set user context");
		}
		if (asthem || pwd->pw_uid) {
			if (setenv("LOGNAME", pwd->pw_name, 1) == -1 ||
			    setenv("USER", pwd->pw_name, 1) == -1)
				auth_err(as, 1, "unable to set environment");
		}
		if (setenv("HOME", homeless ? "/" : pwd->pw_dir, 1) == -1 ||
		    setenv("SHELL", shell, 1) == -1)
			auth_err(as, 1, "unable to set environment");
	} else if (altshell) {
		if (setenv("SHELL", shell, 1) == -1)
			auth_err(as, 1, "unable to set environment");
	}

	np = *argv ? argv : argv - 1;
	if (iscsh == YES) {
		if (fastlogin)
			*np-- = "-f";
		if (asme)
			*np-- = "-m";
	}

	if (asthem) {
		avshellbuf[0] = '-';
		strlcpy(avshellbuf+1, avshell, sizeof(avshellbuf) - 1);
		avshell = avshellbuf;
	} else if (iscsh == YES) {
		/* csh strips the first character... */
		avshellbuf[0] = '_';
		strlcpy(avshellbuf+1, avshell, sizeof(avshellbuf) - 1);
		avshell = avshellbuf;
	}

	*np = avshell;

	if (ruid != 0)
		syslog(LOG_NOTICE|LOG_AUTH, "%s to %s%s",
		    username, user, ontty());

	setpriority(PRIO_PROCESS, 0, prio);
	if (emlogin) {
		flags = LOGIN_SETALL & ~LOGIN_SETPATH;
		/*
		 * Only call setlogin() if this process is a session leader.
		 * In practice, this means the login name will be set only if
		 * we are exec'd by a shell.  This is important because
		 * otherwise the parent shell's login name would change too.
		 */
		if (getsid(0) != getpid())
			flags &= ~LOGIN_SETLOGIN;
	} else {
		flags = LOGIN_SETRESOURCES|LOGIN_SETGROUP|LOGIN_SETUSER;
		if (asthem)
			flags |= LOGIN_SETENV|LOGIN_SETPRIORITY|LOGIN_SETUMASK;
	}
	if (setusercontext(lc, pwd, pwd->pw_uid, flags) != 0)
		auth_err(as, 1, "unable to set user context");

	if (pledge("stdio rpath exec", NULL) == -1)
		err(1, "pledge");

	if (pwd->pw_uid && auth_approval(as, lc, pwd->pw_name, "su") <= 0)
		auth_err(as, 1, "approval failure");
	auth_close(as);

	execv(shell, np);
	err(1, "%s", shell);
}

int
verify_user(char *from, struct passwd *pwd, char *style,
    login_cap_t *lc, auth_session_t *as)
{
	struct group *gr;
	char **g, *cp;
	int authok;

	/*
	 * If we are trying to become root and the default style
	 * is being used, don't bother to look it up (we might be
	 * be su'ing up to fix /etc/login.conf)
	 */
	if ((pwd == NULL || pwd->pw_uid != 0 || style == NULL ||
	    strcmp(style, LOGIN_DEFSTYLE) != 0) &&
	    (style = login_getstyle(lc, style, "auth-su")) == NULL)
		auth_errx(as, 1, "invalid authentication type");

	/*
	 * Let the authentication program know whether they are
	 * in group wheel or not (if trying to become super user)
	 */
	if (pwd != NULL && pwd->pw_uid == 0 && (gr = getgrgid(0)) != NULL &&
	    gr->gr_mem != NULL && *(gr->gr_mem) != NULL) {
		for (g = gr->gr_mem; *g; ++g) {
			if (strcmp(from, *g) == 0) {
				auth_setoption(as, "wheel", "yes");
				break;
			}
		}
		if (!*g)
			auth_setoption(as, "wheel", "no");
	}

	auth_verify(as, style, NULL, lc->lc_class, (char *)NULL);
	authok = auth_getstate(as);
	if ((authok & AUTH_ALLOW) == 0) {
		if ((cp = auth_getvalue(as, "errormsg")) != NULL)
			fprintf(stderr, "%s\n", cp);
		return(1);
	}
	return(0);
}

int
chshell(const char *sh)
{
	char *cp;
	int found = 0;

	setusershell();
	while ((cp = getusershell()) != NULL) {
		if (strcmp(cp, sh) == 0) {
			found = 1;
			break;
		}
	}
	endusershell();
	return (found);
}

char *
ontty(void)
{
	static char buf[PATH_MAX + 4];
	char *p;

	buf[0] = 0;
	if ((p = ttyname(STDERR_FILENO)))
		snprintf(buf, sizeof(buf), " on %s", p);
	return (buf);
}

/*
 * Allow for a '.' and 16 characters for any instance as well as
 * space for a ':' and 16 characters defining the authentication type.
 */
#define NBUFSIZ		(UT_NAMESIZE + 1 + 16 + 1 + 16)

char *
getloginname(void)
{
	static char nbuf[NBUFSIZ], *p;
	int ch;

	for (;;) {
		printf("login: ");
		for (p = nbuf; (ch = getchar()) != '\n'; ) {
			if (ch == EOF)
				return (NULL);
			if (p < nbuf + (NBUFSIZ - 1))
				*p++ = ch;
		}
		if (p > nbuf) {
			if (nbuf[0] == '-') {
				fprintf(stderr,
				    "login names may not start with '-'.\n");
			} else {
				*p = '\0';
				break;
			}
		}
	}
	return (nbuf);
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-fKLlm] [-a auth-type] [-c login-class] "
	    "[-s login-shell]\n"
	    "%-*s[login [shell arguments]]\n", __progname,
	    (int)strlen(__progname) + 8, "");
	exit(1);
}

void
auth_err(auth_session_t *as, int eval, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarn(fmt, ap);
	va_end(ap);
	auth_close(as);
	exit(eval);
}

void
auth_errx(auth_session_t *as, int eval, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarnx(fmt, ap);
	va_end(ap);
	auth_close(as);
	exit(eval);
}
@


1.69
log
@Move removal of "getpw" pledge after all setusercontext() calls, for yp sake.
Noticed by matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.68 2015/10/23 03:44:59 deraadt Exp $	*/
d218 3
a287 3

	if (pledge("stdio rpath exec id", NULL) == -1)
		err(1, "pledge");
@


1.68
log
@pledge "stdio rpath getpw proc exec id" at start, much like doas.
2 further pledges are possible, not as many as doas can do, because the
order of some su operations is a bit different.  also it is trying
harder to please non-root nfs mounts?
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.67 2015/04/15 02:12:00 deraadt Exp $	*/
a217 3
	if (pledge("stdio rpath exec id", NULL) == -1)
		err(1, "pledge");

d285 3
@


1.67
log
@remove historical (void)foo (which were only here to hide lint's
undrenchable thirst for false positives)
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.66 2015/01/16 06:40:13 deraadt Exp $	*/
d76 3
d218 3
d332 4
@


1.66
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.65 2011/01/11 10:07:56 robert Exp $	*/
d121 1
a121 1
	(void)setpriority(PRIO_PROCESS, 0, -2);
d257 2
a258 2
					(void)printf("No home directory %s!\n", pwd->pw_dir);
					(void)printf("Logging in with home = \"/\".\n");
d308 1
a308 1
	(void)setpriority(PRIO_PROCESS, 0, prio);
d420 1
a420 1
		(void)printf("login: ");
d429 1
a429 1
				(void)fprintf(stderr,
@


1.65
log
@Allow su -l to login to a user that has a non-existent home directory,
unless requirehome is specified in login.conf for the login class.
If requirehome is not specified the user will be logged in with HOME=/
This is what login(1) and ssh(1) does too.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.64 2010/12/13 14:46:19 millert Exp $	*/
a31 1
#include <sys/param.h>
d46 1
d68 1
a68 1
	char avshellbuf[MAXPATHLEN];
d398 1
a398 1
	static char buf[MAXPATHLEN + 4];
@


1.64
log
@Call setusercontext() with the LOGIN_SETENV flag for "su -l" to pick up
environment variables specified in login.conf.
Based on a diff from robert@@.  OK robert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.63 2010/12/10 19:55:37 martynas Exp $	*/
d64 1
a64 1
	int altshell = 0;
d177 1
a177 1
		
d251 12
a262 2
			if (chdir(pwd->pw_dir) < 0)
				auth_err(as, 1, "%s", pwd->pw_dir);
d275 1
a275 1
		if (setenv("HOME", pwd->pw_dir, 1) == -1 ||
@


1.63
log
@- don't use memory from the session we've already cleaned in the
loop.  fixes "login foo" and "su -L foo".  ok millert@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.62 2010/12/09 16:10:00 sobrado Exp $	*/
d309 5
a313 3
	} else
		flags = (asthem ? (LOGIN_SETPRIORITY | LOGIN_SETUMASK) : 0) |
		    LOGIN_SETRESOURCES | LOGIN_SETGROUP | LOGIN_SETUSER;
@


1.62
log
@spacing, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.61 2010/12/09 16:02:42 sobrado Exp $	*/
d197 1
a197 1
			class = pwd->pw_class;
@


1.61
log
@usage should fit on a 80-column display

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.60 2010/12/09 15:50:55 sobrado Exp $	*/
d436 1
a436 1
	    (int)strlen(__progname) +8, "");
@


1.60
log
@add -s to usage
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.59 2010/12/09 15:45:30 millert Exp $	*/
d434 3
a436 1
	    "[-s login-shell] [login [shell arguments]]\n", __progname);
@


1.59
log
@Add support for "-s shell" to su(1).  This can be used by the superuser
to run a different shell than what the password database contains.
Based on a diff from robert@@.  OK robert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.58 2009/10/27 23:59:44 deraadt Exp $	*/
d434 1
a434 1
	    "[login [shell arguments]]\n", __progname);
@


1.58
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.57 2007/10/19 21:03:51 deraadt Exp $	*/
d64 1
d76 1
a76 1
	while ((ch = getopt(argc, argv, "a:c:fKLlm-")) != -1)
d108 4
d137 3
d150 1
a150 1
	if (asme) {
d215 13
a227 11
	if (asme) {
		/* if asme and non-standard target shell, must be root */
		if (!chshell(pwd->pw_shell) && ruid)
			auth_errx(as, 1, "permission denied (shell).");
	} else if (pwd->pw_shell && *pwd->pw_shell) {
		if ((shell = strdup(pwd->pw_shell)) == NULL)
			auth_errx(as, 1, "can't allocate memory");
		iscsh = UNSET;
	} else {
		shell = _PATH_BSHELL;
		iscsh = NO;
d267 3
@


1.57
log
@do setegid() before seteuid(); see pr 5605 for more info; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.56 2003/11/09 20:13:58 otto Exp $	*/
a30 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1988 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "from: @@(#)su.c	5.26 (Berkeley) 7/6/91";
#else
static const char rcsid[] = "$OpenBSD: su.c,v 1.56 2003/11/09 20:13:58 otto Exp $";
#endif
#endif /* not lint */
@


1.56
log
@Typos in comments from Jared Yanovich <jjy2+ at pitt dot edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.55 2003/09/26 21:43:32 miod Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.55 2003/09/26 21:43:32 miod Exp $";
d253 1
a254 1
			setegid(pwd->pw_gid);
d257 1
a258 1
			setegid(0);	/* XXX use a saved gid instead? */
@


1.55
log
@Typos: defintion -> definition, proccess -> process

There are more occurences hiding in binutils, lynx and afs but I am too
lazy to report them upstream at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.54 2003/06/21 23:27:33 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.54 2003/06/21 23:27:33 deraadt Exp $";
d398 1
a398 1
 * space for a ':' and 16 charcters defining the authentication type.
@


1.54
log
@correct sign of flags; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.53 2003/06/20 18:15:35 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.53 2003/06/20 18:15:35 millert Exp $";
d303 1
a303 1
		 * Only call setlogin() if this proccess is a session leader.
@


1.53
log
@Call setusershell() before using getusershell() to guarantee we
start checking on the first line of /etc/shells.
Also call endusershell() when we are done.  From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.52 2003/06/03 02:56:17 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.52 2003/06/03 02:56:17 millert Exp $";
d77 1
a77 1
	int asme = 0, asthem = 0, ch, fastlogin = 0, emlogin = 0, flags, prio;
d87 1
@


1.52
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.51 2002/12/17 19:52:02 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.51 2002/12/17 19:52:02 millert Exp $";
d67 1
a67 1
int	chshell(char *);
d367 1
a367 1
chshell(char *sh)
d370 1
d372 9
a380 4
	while ((cp = getusershell()) != NULL)
		if (strcmp(cp, sh) == 0)
			return (1);
	return (0);
@


1.51
log
@Only call setlogin() if this proccess is a session leader.
In practice, this means the login name will be set only if
we are exec'd by a shell.  This is important because
otherwise the parent shell's login name would change too.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.50 2002/12/08 16:50:07 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.50 2002/12/08 16:50:07 millert Exp $";
@


1.50
log
@GNU semantics say that if optstring begins with '-' then
each non-option shall be treated as arguments to option '\1'.

BSD getopt match '-' in optstring with a '-' on the command line.
This is used to support deprecated options like "su -" that would
otherwise prevent the use of getopt().

Resolving this simply requires that the leading '-' be moved somewhere
else (I moved it to the end of optstring) since position within
optstring is not meaningful.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.49 2002/12/07 22:54:13 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.49 2002/12/07 22:54:13 millert Exp $";
d303 1
a303 1
	if (emlogin)
d305 9
a313 1
	else
@


1.49
log
@Repair -a flag parsing which I broke in revision 1.47.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.48 2002/11/08 23:20:19 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.48 2002/11/08 23:20:19 millert Exp $";
d92 1
a92 1
	while ((ch = getopt(argc, argv, "-a:c:fKLlm")) != -1)
@


1.48
log
@In login emulation mode use the same setusercontext() flags as
login(1).  Previously, setlogin() was not being done in -L mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.47 2002/10/16 01:06:32 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.47 2002/10/16 01:06:32 millert Exp $";
d184 2
a185 3
			style = p;
		} else
			style = NULL;	/* XXX overrides -a flag */
@


1.47
log
@Add a new flag, -L, to cause su(1) to loop asking for a login/password
repeatedly until the user authenticates or interrupts things.
This will be used to make login(1) no longer setuid.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.46 2002/07/22 04:51:17 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.46 2002/07/22 04:51:17 millert Exp $";
d81 1
a81 1
	int asme = 0, asthem = 0, ch, fastlogin = 0, emlogin = 0, prio;
d304 6
a309 3
	if (setusercontext(lc, pwd, pwd->pw_uid,
	    (asthem ? (LOGIN_SETPRIORITY | LOGIN_SETUMASK) : 0) |
	    LOGIN_SETRESOURCES | LOGIN_SETGROUP | LOGIN_SETUSER))
@


1.46
log
@auth_close() was not actually getting called in auth_errx?() (not
that it really makes much of a difference).  Call vwarnx?() instead
of verrx?() and then do the exit inline after auth_close().
That's what I get for doing a cut & paste from err.c...
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.45 2002/05/29 10:47:10 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.45 2002/05/29 10:47:10 deraadt Exp $";
d65 1
d69 1
d72 2
d79 1
a79 3
main(argc, argv)
	int argc;
	char **argv;
d81 1
a81 1
	int asme = 0, asthem = 0, authok, ch, fastlogin = 0, prio;
d83 1
a83 1
	char *class = NULL, *style = NULL, *p, **g, *fullname;
a88 1
	struct group *gr;
d92 1
a92 1
	while ((ch = getopt(argc, argv, "-a:c:fKlm")) != -1)
d112 4
a116 1
		case 'l':
d146 3
d169 19
a187 29
	/* get target login information, default to root */
	user = *argv ? *argv : "root";
	np = *argv ? argv : argv - 1;

	if ((pwd = getpwnam(user)) == NULL)
		auth_errx(as, 1, "unknown login %s", user);
	if ((pwd = pw_dup(pwd)) == NULL)
		auth_errx(as, 1, "can't allocate memory");
	user = pwd->pw_name;

	/* If the user specified a login class and we are root, use it */
	if (ruid && class)
		auth_errx(as, 1, "only the superuser may specify a login class");
	if (class)
		pwd->pw_class = class;
	if ((lc = login_getclass(pwd->pw_class)) == NULL)
		auth_errx(as, 1, "no such login class: %s",
		    class ? class : LOGIN_DEFCLASS);

	if (ruid) {
		/*
		 * If we are trying to become root and the default style
		 * is being used, don't bother to look it up (we might be
		 * be su'ing up to fix /etc/login.conf)
		 */
		if ((pwd->pw_uid || !style || strcmp(style, LOGIN_DEFSTYLE)) &&
		    (style = login_getstyle(lc, style, "auth-su")) == NULL)
			auth_errx(as, 1, "invalid authentication type");
		fullname = user;
d189 2
a190 2
		 * Let the authentication program know whether they are
		 * in group wheel or not (if trying to become super user)
d192 11
a202 10
		if (pwd->pw_uid == 0 && (gr = getgrgid((gid_t)0)) &&
		    gr->gr_mem && *(gr->gr_mem)) {
			for (g = gr->gr_mem; *g; ++g) {
				if (strcmp(username, *g) == 0) {
					auth_setoption(as, "wheel", "yes");
					break;
				}
			}
			if (!*g)
				auth_setoption(as, "wheel", "no");
d205 13
a217 5
		auth_verify(as, style, fullname, lc->lc_class, NULL);
		authok = auth_getstate(as);
		if ((authok & AUTH_ALLOW) == 0) {
			if ((p = auth_getvalue(as, "errormsg")) != NULL)
				fprintf(stderr, "%s\n", p);
a218 2
			syslog(LOG_AUTH|LOG_WARNING, "BAD SU %s to %s%s",
			    username, user, ontty());
d222 1
d230 2
a231 1
		shell = pwd->pw_shell;
d278 1
d317 45
a361 2
chshell(sh)
	char *sh;
d372 1
a372 1
ontty()
d383 33
d417 1
a417 1
usage()
d421 2
a422 2
	fprintf(stderr, "usage: %s [-fKlm] [-a auth-type] %s ", __progname,
	    "[-c login-class] [login [shell arguments]]\n");
@


1.45
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.44 2002/02/19 19:39:39 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.44 2002/02/19 19:39:39 millert Exp $";
d347 1
d349 2
a350 1
	verr(eval, fmt, ap);
d352 1
a352 1
	va_end(ap);
d359 1
d361 2
a362 1
	verrx(eval, fmt, ap);
d364 1
a364 1
	va_end(ap);
@


1.44
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.43 2002/02/16 21:27:54 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.43 2002/02/16 21:27:54 millert Exp $";
d79 5
d85 1
a85 1
	enum { UNSET, YES, NO } iscsh;
d88 1
a89 6
	login_cap_t *lc;
	auth_session_t *as;
	int asme, asthem, authok, ch, fastlogin, prio;
	char *class, *style, *p, **g;
	char *user, *shell, *avshell, *username, **np, *fullname;
	char avshellbuf[MAXPATHLEN];
a90 3
	iscsh = UNSET;
	class = shell = style = NULL;
	asme = asthem = fastlogin = 0;
d92 1
a92 1
		switch(ch) {
a119 1
		case '?':
d195 2
a196 2
		if (pwd->pw_uid == 0 && (gr = getgrgid((gid_t)0))
		    && gr->gr_mem && *(gr->gr_mem)) {
d213 2
a214 2
			syslog(LOG_AUTH|LOG_WARNING,
				"BAD SU %s to %s%s", username, user, ontty());
d289 1
a289 1
			
@


1.43
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.42 2001/09/18 16:37:59 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.42 2001/09/18 16:37:59 millert Exp $";
a64 1
#ifdef __STDC__
a65 3
#else
#include <varargs.h>
#endif
a347 1
#ifdef __STDC__
a348 4
#else
auth_err(va_alist)
	va_dcl
#endif
a350 1
#ifdef __STDC__
a351 10
#else
	auth_session_t *as;
	int eval;
	const char *fmt;

	va_start(ap);
	as = va_arg(ap, auth_session_t *);
	eval = va_arg(ap, int);
	fmt = va_arg(ap, const char *);
#endif
a357 1
#ifdef __STDC__
a358 4
#else
auth_errx(va_alist)
	va_dcl
#endif
a360 1
#ifdef __STDC__
a361 10
#else
	auth_session_t *as;
	int eval;
	const char *fmt;

	va_start(ap);
	as = va_arg(ap, auth_session_t *);
	eval = va_arg(ap, int);
	fmt = va_arg(ap, const char *);
#endif
@


1.42
log
@check strdup() rval
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.41 2001/09/18 04:41:09 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.41 2001/09/18 04:41:09 millert Exp $";
d72 5
a76 5
char   *ontty __P((void));
int	chshell __P((char *));
void	usage __P((void));
void	auth_err __P((auth_session_t *, int, const char *, ...));
void	auth_errx __P((auth_session_t *, int, const char *, ...));
@


1.41
log
@Make a private copy of pwd via pw_dup() since its contents can get
clobbered later on.  For some reason this only seems to affect YP.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.40 2001/06/25 21:29:31 hin Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: su.c,v 1.40 2001/06/25 21:29:31 hin Exp $";
d162 2
a163 1
			shell = strdup(pwd->pw_shell);
@


1.40
log
@Instead of trying to do clever and figure out a root instance for Kerberos,
send tell the auth program who the invoking user is, and rely on it to handle
root instances for Kerberos.

This makes the code much cleaner and simpler.

ok millertt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.39 2001/06/25 16:18:38 millert Exp $	*/
d37 1
a37 1
char copyright[] =
d43 5
a47 2
/*static char sccsid[] = "from: @@(#)su.c	5.26 (Berkeley) 7/6/91";*/
static char rcsid[] = "$OpenBSD: su.c,v 1.39 2001/06/25 16:18:38 millert Exp $";
d93 1
a93 1
	char shellbuf[MAXPATHLEN], avshellbuf[MAXPATHLEN];
d150 1
a150 1
	if(username != NULL)
d159 1
a159 1
		auth_err(as, 1, "can't allocate memory");
d162 1
a162 2
			strlcpy(shellbuf, pwd->pw_shell, sizeof(shellbuf));
			shell = shellbuf;
d175 3
a177 2
	if ((user = strdup(pwd->pw_name)) == NULL)
		auth_err(as, 1, "can't allocate memory");
@


1.39
log
@Add a "login" option to allow differentiation between authentication
that creates a login session vs. a simple identity check.  Gets
passed as a -v option to the login scripts.  To be used by kerberos
to know when to create new tickets.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.38 2001/05/31 18:41:16 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.38 2001/05/31 18:41:16 millert Exp $";
d146 4
d194 1
a194 8
		if (pwd->pw_uid || strcmp(user, "root") != 0)
			fullname = user;
		else {
			if ((fullname =
			    malloc(strlen(username) + 6)) == NULL)
				auth_err(as, 1, NULL);
			(void)sprintf(fullname, "%s.root", username);
		}
@


1.38
log
@nuke errant ARGSTR that I osmehow missed in the last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.37 2001/05/31 17:34:17 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.37 2001/05/31 17:34:17 millert Exp $";
d139 1
a139 1
		err(1, "unable to begin authentication");
d141 1
@


1.37
log
@no longer need ARGSTR macro; sync usage() with man page
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.36 2001/05/29 21:40:36 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.36 2001/05/29 21:40:36 millert Exp $";
d345 1
a345 1
	    ARGSTR, "[-c login-class] [login [shell arguments]]\n");
@


1.36
log
@add support for BSD authentication
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.35 2000/12/02 22:44:49 hin Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.35 2000/12/02 22:44:49 hin Exp $";
a68 2
#define	ARGSTR	"-a:c:fKlm"

d95 1
a95 1
	while ((ch = getopt(argc, argv, ARGSTR)) != -1)
d344 2
a345 2
	(void)fprintf(stderr, "usage: %s [%s] [-a auth-type] %s ",
	    "[-c login-class] [login [argument ...]]\n", __progname, ARGSTR);
@


1.35
log
@Check for symlinks before overwriting kerberos ticket files.
While i'm at it, make sure not to use Kerberos at all if there is no
local srvtab.
Based on patch from Todd Miller.  Reported by <jouko@@solutions.fi>.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.34 2000/09/15 07:13:50 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.34 2000/09/15 07:13:50 deraadt Exp $";
d62 2
a63 19
#include <fcntl.h>

#ifdef  SKEY
#include <skey.h>                                                       
#endif                                                                       

#ifdef KERBEROS
#include <des.h>
#include <kerberosIV/krb.h>
#include <netdb.h>

int kerberos __P((char *username, char *user, int uid));

#define	ARGSTR	"-Kc:flm"

int use_kerberos = 1;
char krbtkfile[MAXPATHLEN];
char lrealm[REALM_SZ];
int ksettkfile(char *);
d65 1
a65 1
#define	ARGSTR	"-c:flm"
d67 3
d73 3
d83 2
a84 2
	register struct passwd *pwd;
	register char *p, **g;
d88 4
a91 3
	int asme, ch, asthem, fastlogin, prio;
	enum { UNSET, YES, NO } iscsh;
	char *user, *shell, *avshell, *username, *class, **np;
d95 1
a95 1
	shell = class = NULL;
d98 5
a102 4
		switch((char)ch) {
#ifdef KERBEROS
		case 'K':
			use_kerberos = 0;
a103 1
#endif
d105 2
d112 5
d128 1
a128 4
			(void)fprintf(stderr,
			    "usage: su [%s] [login [shell arguments]]\n",
			    ARGSTR);
			exit(1);
d139 5
d151 1
a151 1
		errx(1, "who are you?");
d153 1
a153 1
		err(1, "can't allocate memory");
d156 2
a157 2
			shell = strncpy(shellbuf, pwd->pw_shell, sizeof(shellbuf) - 1);
			shellbuf[sizeof(shellbuf) - 1] = '\0';
d166 1
a166 1
	np = *argv ? argv : argv-1;
d169 1
a169 1
		errx(1, "unknown login %s", user);
d171 1
a171 1
		err(1, "can't allocate memory");
d175 1
a175 1
		errx(1, "only the superuser may specify a login class");
d179 1
a179 1
		errx(1, "no such login class: %s",
a181 5
#if KERBEROS
	if (ksettkfile(user))
		use_kerberos = 0;
#endif

d183 20
a202 5
#ifdef KERBEROS
	    if (!use_kerberos || kerberos(username, user, pwd->pw_uid))
#endif
	    {
		/* only allow those in group zero to su to root. */
d204 4
a207 5
		    && gr->gr_mem && *(gr->gr_mem))
			for (g = gr->gr_mem;; ++g) {
				if (!*g)
					errx(1, "you are not in the correct group to su %s.", user);
				if (strcmp(username, *g) == 0)
d209 4
d214 11
a224 17
		/* if target requires a password, verify it */
		if (*pwd->pw_passwd) {
			p = getpass("Password:");
#ifdef SKEY
			if (strcasecmp(p, "s/key") == 0) {
				if (skey_authenticate(user))
					goto badlogin;
			} else
#endif
			if (strcmp(pwd->pw_passwd, crypt(p, pwd->pw_passwd))) {
badlogin:
				fprintf(stderr, "Sorry\n");
				syslog(LOG_AUTH|LOG_WARNING,
					"BAD SU %s to %s%s", username,
					user, ontty());
				exit(1);
			}
a225 7
	    }
	    if (pwd->pw_expire && time(NULL) >= pwd->pw_expire) {
		    fprintf(stderr, "Sorry - account expired\n");
		    syslog(LOG_AUTH|LOG_WARNING, "BAD SU %s to %s%s", username,
			    user, ontty());
		    exit(1);
	    }
d231 1
a231 1
			errx(1, "permission denied (shell).");
d253 1
a253 1
				errx(1, "calloc");
d255 3
a257 5
				err(1, "unable to set user context");
			if (p) {
				if (setenv("TERM", p, 1) == -1)
					err(1, "unable to set environment");
			}
d262 1
a262 1
				err(1, "%s", pwd->pw_dir);
a265 1
			/* XXX - this seems questionable to me */
d268 1
a268 1
				err(1, "unable to set user context");
d273 1
a273 1
				err(1, "unable to set environment");
d277 1
a277 7
			err(1, "unable to set environment");
	}

#ifdef KERBEROS
	if (*krbtkfile) {
		if (setenv("KRBTKFILE", krbtkfile, 1) == -1)
			err(1, "unable to set environment");
a278 1
#endif
d289 1
a289 2
		strncpy(avshellbuf+1, avshell, sizeof(avshellbuf) - 2);
		avshellbuf[sizeof(avshellbuf) - 1] = '\0';
d294 1
a294 2
		strncpy(avshellbuf+1, avshell, sizeof(avshellbuf) - 2);
		avshellbuf[sizeof(avshellbuf) - 1] = '\0';
d308 4
a311 1
		err(1, "unable to set user context");
d321 1
a321 1
	register char *cp;
a331 1
	char *p, *ttyname();
d333 1
d341 2
a342 7
#ifdef KERBEROS
int koktologin __P((char *, char *, char *));

int
kerberos(username, user, uid)
	char *username, *user;
	int uid;
d344 1
a344 18
	KTEXT_ST ticket;
	AUTH_DAT authdata;
	struct hostent *hp;
	int kerno, fd;
	in_addr_t faddr;
	char hostname[MAXHOSTNAMELEN], savehost[MAXHOSTNAMELEN];
	char *ontty(), *krb_get_phost();

	/* Don't bother with Kerberos if there is no srvtab file */
	if ((fd = open(KEYFILE, O_RDONLY, 0)) < 0)
		return (1);
	close(fd);

	if (koktologin(username, lrealm, user) && !uid) {
		(void)fprintf(stderr, "kerberos su: not in %s's ACL.\n", user);
		return (1);
	}
	(void)krb_set_tkt_string(krbtkfile);
d346 3
a348 100
	/*
	 * Set real as well as effective ID to 0 for the moment,
	 * to make the kerberos library do the right thing.
	 */
	if (setuid(0) < 0) {
		warn("setuid");
		return (1);
	}

	/*
	 * Little trick here -- if we are su'ing to root,
	 * we need to get a ticket for "xxx.root", where xxx represents
	 * the name of the person su'ing.  Otherwise (non-root case),
	 * we need to get a ticket for "yyy.", where yyy represents
	 * the name of the person being su'd to, and the instance is null
	 */

	printf("%s%s@@%s's ", (uid == 0 ? username : user), 
	       (uid == 0 ? ".root" : ""), lrealm);
	fflush(stdout);
	kerno = krb_get_pw_in_tkt((uid == 0 ? username : user),
		(uid == 0 ? "root" : ""), lrealm,
	    	"krbtgt", lrealm, DEFAULT_TKT_LIFE, 0);

	if (kerno != KSUCCESS) {
		if (kerno == KDC_PR_UNKNOWN) {
			warnx("kerberos principal unknown: %s.%s@@%s",
				(uid == 0 ? username : user),
				(uid == 0 ? "root" : ""), lrealm);
			return (1);
		}
		warnx("unable to su: %s", krb_err_txt[kerno]);
		syslog(LOG_NOTICE|LOG_AUTH,
		    "BAD Kerberos SU: %s to %s%s: %s",
		    username, user, ontty(), krb_err_txt[kerno]);
		return (1);
	}

	/*
	 * Set the owner of the ticket file to root but bail if someone
	 * has nefariously swapped a link in place of the file.
	 */
	fd = open(krbtkfile, O_RDWR|O_NOFOLLOW, 0);
	if (fd == -1) {
		warn("unable to open ticket file");
		(void)unlink(krbtkfile);
		return (1);
	}
	if (fchown(fd, uid, -1) < 0) {
		warn("fchown");
		(void)unlink(krbtkfile);
		return (1);
	}
	close(fd);

	(void)setpriority(PRIO_PROCESS, 0, -2);

	if (gethostname(hostname, sizeof(hostname)) == -1) {
		warn("gethostname");
		dest_tkt();
		return (1);
	}

	(void)strncpy(savehost, krb_get_phost(hostname), sizeof(savehost) - 1);
	savehost[sizeof(savehost) - 1] = '\0';

	kerno = krb_mk_req(&ticket, "rcmd", savehost, lrealm, 33);

	if (kerno == KDC_PR_UNKNOWN) {
		warnx("Warning: TGT not verified.");
		syslog(LOG_NOTICE|LOG_AUTH,
		    "%s to %s%s, TGT not verified (%s); %s.%s not registered?",
		    username, user, ontty(), krb_err_txt[kerno],
		    "rcmd", savehost);
	} else if (kerno != KSUCCESS) {
		warnx("Unable to use TGT: %s", krb_err_txt[kerno]);
		syslog(LOG_NOTICE|LOG_AUTH, "failed su: %s to %s%s: %s",
		    username, user, ontty(), krb_err_txt[kerno]);
		dest_tkt();
		return (1);
	} else {
		if (!(hp = gethostbyname(hostname))) {
			warnx("can't get addr of %s", hostname);
			dest_tkt();
			return (1);
		}
		(void)memcpy((void *)&faddr, (void *)hp->h_addr, sizeof(faddr));

		if ((kerno = krb_rd_req(&ticket, "rcmd", savehost, faddr,
		    &authdata, "")) != KSUCCESS) {
			warnx("unable to verify rcmd ticket: %s",
			      krb_err_txt[kerno]);
			syslog(LOG_NOTICE|LOG_AUTH,
			    "failed su: %s to %s%s: %s", username,
			     user, ontty(), krb_err_txt[kerno]);
			dest_tkt();
			return (1);
		}
	}
	return (0);
d351 7
a357 3
int
koktologin(name, realm, toname)
	char *name, *realm, *toname;
d359 16
a374 17
	register AUTH_DAT *kdata;
	AUTH_DAT kdata_st;

	memset((void *)&kdata_st, 0, sizeof(kdata_st));
	kdata = &kdata_st;

	(void)strncpy(kdata->pname, name, sizeof(kdata->pname) - 1);
	kdata->pname[sizeof(kdata->pname) - 1] = '\0';

	(void)strncpy(kdata->pinst,
	    ((strcmp(toname, "root") == 0) ? "root" : ""), sizeof(kdata->pinst) - 1);
	kdata->pinst[sizeof(kdata->pinst) -1] = '\0';

	(void)strncpy(kdata->prealm, realm, sizeof(kdata->prealm) - 1);
	kdata->prealm[sizeof(kdata->prealm) -1] = '\0';

	return (kuserok(kdata, toname));
d377 7
a383 3
int
ksettkfile(user)
	char *user;
d385 16
a400 5
	if (krb_get_lrealm(lrealm, 1) != KSUCCESS)
		return (1);
	(void)snprintf(krbtkfile, sizeof(krbtkfile), "%s_%s_%u", TKT_ROOT,
		user, getuid());
	return (0);
a401 1
#endif
@


1.34
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.33 2000/08/20 18:42:41 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.33 2000/08/20 18:42:41 millert Exp $";
d62 1
d362 1
a362 1
	int kerno;
d367 5
d416 12
a427 2
	if (chown(krbtkfile, uid, -1) < 0) {
		warn("chown");
d431 1
@


1.34.2.1
log
@Bring recent kerberos fix into -stable
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.35 2000/12/02 22:44:49 hin Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.35 2000/12/02 22:44:49 hin Exp $";
a61 1
#include <fcntl.h>
d361 1
a361 1
	int kerno, fd;
a365 5
	/* Don't bother with Kerberos if there is no srvtab file */
	if ((fd = open(KEYFILE, O_RDONLY, 0)) < 0)
		return (1);
	close(fd);

d410 2
a411 12
	/*
	 * Set the owner of the ticket file to root but bail if someone
	 * has nefariously swapped a link in place of the file.
	 */
	fd = open(krbtkfile, O_RDWR|O_NOFOLLOW, 0);
	if (fd == -1) {
		warn("unable to open ticket file");
		(void)unlink(krbtkfile);
		return (1);
	}
	if (fchown(fd, uid, -1) < 0) {
		warn("fchown");
a414 1
	close(fd);
@


1.33
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.32 2000/06/30 16:00:21 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.32 2000/06/30 16:00:21 millert Exp $";
d256 4
a259 2
			if (p)
				(void)setenv("TERM", p, 1);
d274 3
a276 2
			(void)setenv("LOGNAME", pwd->pw_name, 1);
			(void)setenv("USER", pwd->pw_name, 1);
d278 3
a280 2
		(void)setenv("HOME", pwd->pw_dir, 1);
		(void)setenv("SHELL", shell, 1);
d284 4
a287 2
	if (*krbtkfile)
		(void)setenv("KRBTKFILE", krbtkfile, 1);
@


1.32
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.31 1998/03/25 21:27:27 art Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.31 1998/03/25 21:27:27 art Exp $";
d54 1
d74 1
a74 1
#define	ARGSTR	"-Kflm"
d81 1
a81 1
#define	ARGSTR	"-flm"
d97 1
d99 2
a100 2
	enum { UNSET, YES, NO } iscsh = UNSET;
	char *user, *shell = NULL, *avshell, *username, **np;
d103 2
d113 3
d173 9
a248 12
	/* set permissions */
	if (setegid(pwd->pw_gid) < 0)
		err(1, "setegid");
	if (setgid(pwd->pw_gid) < 0)
		err(1, "setgid");
	if (initgroups(user, pwd->pw_gid))
		err(1, "initgroups failed");
	if (seteuid(pwd->pw_uid) < 0)
		err(1, "seteuid");
	if (setuid(pwd->pw_uid) < 0)
		err(1, "setuid");

d254 2
a255 1
			(void)setenv("PATH", _PATH_DEFPATH, 1);
d262 1
a262 1
				errx(1, "no directory");
d265 5
d311 4
@


1.31
log
@explicit braces to avoid ambigious `else', some small -Wall fixes
and prettier output when asking for kerberos passwd.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.30 1997/09/11 11:21:55 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.30 1997/09/11 11:21:55 deraadt Exp $";
d303 1
a303 1
	err(1, shell);
@


1.31.10.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.31 1998/03/25 21:27:27 art Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.31 1998/03/25 21:27:27 art Exp $";
d303 1
a303 1
	err(1, "%s", shell);
@


1.30
log
@cleanup -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.29 1997/06/29 11:10:35 provos Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.29 1997/06/29 11:10:35 provos Exp $";
d98 1
a98 1
	char *user, *shell, *avshell, *username, **np;
d147 1
a147 1
	if (asme)
d155 1
d331 2
a366 3
	 *
	 * We should have a way to set the ticket lifetime,
	 * with a system default for root.
d368 4
d443 1
@


1.29
log
@new location of des.h
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.28 1997/06/27 06:59:58 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.28 1997/06/27 06:59:58 deraadt Exp $";
d71 2
d223 1
a223 1
	if (p = strrchr(shell, '/'))
d324 1
a324 1
	if (p = ttyname(STDERR_FILENO))
d330 1
a337 1
	register char *p;
@


1.28
log
@fix up KRBTKFILE confusion; dm@@ and traister@@gate.net
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.27 1997/06/23 09:23:12 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.27 1997/06/23 09:23:12 deraadt Exp $";
d67 1
a67 1
#include <kerberosIV/des.h>
@


1.27
log
@long != int
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.26 1997/06/22 23:03:10 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.26 1997/06/22 23:03:10 deraadt Exp $";
d74 3
a76 1
int got_ticket;
a97 3
#ifdef KERBEROS
	char *k;
#endif
d163 5
a244 3
#ifdef KERBEROS
			k = getenv("KRBTKFILE");
#endif
a249 4
#ifdef KERBEROS
			if (k && got_ticket)
				(void)setenv("KRBTKFILE", k, 1);
#endif
d266 5
a337 1
	char lrealm[REALM_SZ], krbtkfile[MAXPATHLEN];
a340 2
	if (krb_get_lrealm(lrealm, 1) != KSUCCESS)
		return (1);
d345 1
a345 2
	(void)snprintf(krbtkfile, sizeof(krbtkfile), "%s_%s_%u", TKT_ROOT,
		user, getuid());
a346 2
	(void)setenv("KRBTKFILE", krbtkfile, 1);
	(void)krb_set_tkt_string(krbtkfile);
a433 1
	got_ticket = 1;
d457 11
@


1.26
log
@%u for uid
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.25 1997/06/21 12:18:05 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.25 1997/06/21 12:18:05 deraadt Exp $";
d335 1
a335 1
	u_long faddr;
@


1.25
log
@push KRBTKFILE only if new ticket; dm@@openbsd.org and traister@@gate.net
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.24 1997/06/20 22:09:53 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.24 1997/06/20 22:09:53 deraadt Exp $";
d346 1
a346 1
	(void)snprintf(krbtkfile, sizeof(krbtkfile), "%s_%s_%d", TKT_ROOT,
@


1.24
log
@worry about #ifdef KERBEROS
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.23 1997/06/20 21:59:17 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.23 1997/06/20 21:59:17 deraadt Exp $";
d74 1
d250 1
a250 1
			if (k)
d438 1
@


1.23
log
@when building new environment, do not destroy KRBTKFILE; traister@@gate.net
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.22 1997/06/20 02:12:40 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.22 1997/06/20 02:12:40 deraadt Exp $";
d93 1
a93 1
	char *user, *shell, *avshell, *username, *k, **np;
d95 3
@


1.22
log
@do not conflict with realloc() in setenv(); traister@@gate.net
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.21 1997/02/18 20:07:56 tholo Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.21 1997/02/18 20:07:56 tholo Exp $";
d93 1
a93 1
	char *user, *shell, *avshell, *username, **cleanenv, **np;
d237 4
a240 1
			if ((cleanenv = calloc(1, sizeof (char *))) == NULL)
a241 1
			environ = cleanenv;
d245 4
@


1.21
log
@Undo last changes; it makes it impossible to suspect su in Kerberos mode,
and also interferes with multiple sessions by removing tickets potentially
in use by those other sessions.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.20 1997/02/11 18:26:32 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.20 1997/02/11 18:26:32 millert Exp $";
d93 1
a93 1
	char *user, *shell, *avshell, *username, *cleanenv[10], **np;
d237 2
a238 1
			cleanenv[0] = NULL;
@


1.20
log
@Fix for non-kerberos.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.19 1997/02/11 05:00:55 tholo Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.19 1997/02/11 05:00:55 tholo Exp $";
a69 2
#include <fcntl.h>
#include <sys/stat.h>
a72 3
void	 kdestroy __P((void));
void	 dofork __P((void));

a73 1
char krbtkfile[MAXPATHLEN];
a80 24
#ifdef KERBEROS
void
dofork()
{
    pid_t child;

    if (!(child = fork()))
	    return; /* Child process */

    /* Setup stuff?  This would be things we could do in parallel with login */
    (void) chdir("/");	/* Let's not keep the fs busy... */
    
    /* If we're the parent, watch the child until it dies */
    while (wait(0) != child)
	    ;

    /* Run kdestroy to destroy tickets */
    kdestroy();

    /* Leave */
    exit(0);
}
#endif

d162 1
a162 2
	    if (use_kerberos == 0 ||
		(use_kerberos = !kerberos(username, user, pwd->pw_uid)) == 0)
a221 6
#if defined(KERBEROS) || defined(KERBEROS5)
	/* Fork so that we can call kdestroy */
	if (use_kerberos)
	    dofork();
#endif

d325 1
a325 1
	char lrealm[REALM_SZ];
a449 57
}

void
kdestroy()
{
        char *file = krbtkfile;
	int i, fd;
	extern int errno;
	struct stat statb;
	char buf[BUFSIZ];
#ifdef TKT_SHMEM
	char shmidname[MAXPATHLEN];
#endif /* TKT_SHMEM */

	if (use_kerberos == 0)
	    return;

	errno = 0;
	if (lstat(file, &statb) < 0)
	    goto out;

	if (!(statb.st_mode & S_IFREG)
#ifdef notdef
	    || statb.st_mode & 077
#endif
	    )
		goto out;

	if ((fd = open(file, O_RDWR, 0)) < 0)
	    goto out;

	bzero(buf, BUFSIZ);

	for (i = 0; i < statb.st_size; i += BUFSIZ)
	    if (write(fd, buf, BUFSIZ) != BUFSIZ) {
		(void) fsync(fd);
		(void) close(fd);
		goto out;
	    }

	(void) fsync(fd);
	(void) close(fd);

	(void) unlink(file);

out:
	if (errno != 0) return;
#ifdef TKT_SHMEM
	/* 
	 * handle the shared memory case 
	 */
	(void) strcpy(shmidname, file);
	(void) strcat(shmidname, ".shm");
	if (krb_shm_dest(shmidname) != KSUCCESS)
	    return;
#endif /* TKT_SHMEM */
	return;
@


1.19
log
@Handle tickets the same way as login(1) does; remove when session ends
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.18 1997/01/15 23:43:16 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.18 1997/01/15 23:43:16 millert Exp $";
d192 2
a193 1
	    if (!use_kerberos || kerberos(username, user, pwd->pw_uid))
a195 1
		use_kerberos = 0;
@


1.18
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.17 1996/12/22 03:26:03 tholo Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.17 1996/12/22 03:26:03 tholo Exp $";
d70 2
d75 3
d79 1
d87 24
d195 1
d253 6
d362 1
a362 1
	char lrealm[REALM_SZ], krbtkfile[MAXPATHLEN];
d487 57
@


1.17
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.16 1996/10/27 16:49:17 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.16 1996/10/27 16:49:17 millert Exp $";
d97 1
a97 1
	while ((ch = getopt(argc, argv, ARGSTR)) != EOF)
@


1.16
log
@Don't use "user" arg verbatim from argv, use the sanitized one in
struct passwd just to be safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.15 1996/10/26 03:19:31 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.15 1996/10/26 03:19:31 millert Exp $";
d223 2
d229 2
@


1.15
log
@Now sets $LOGNAME as per POSIX.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.14 1996/10/23 01:28:57 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.14 1996/10/23 01:28:57 millert Exp $";
d157 2
@


1.14
log
@skey_authenticate() now fakes up a challenge if user does not
have an entry in the keys file.  Don't want to give info to
information gathering attack.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.13 1996/10/21 19:33:36 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.13 1996/10/21 19:33:36 deraadt Exp $";
d244 2
a245 1
		if (asthem || pwd->pw_uid)
d247 1
@


1.13
log
@compile
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.11 1996/10/21 19:26:24 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.11 1996/10/21 19:26:24 millert Exp $";
d177 1
a177 3
				if (skey_haskey(user))
					errx(1, "Sorry, you have no s/key.");
				else if (skey_authenticate(user))
@


1.12
log
@Test first, then commit, eh?
@
text
@d430 1
a430 1
	memset((void *)&kdata_st, 0, sizeof(*kdata_st));
d438 1
a438 1
	kdata->pinst[sizeof(kdata->pinst) -1] '\0';
@


1.11
log
@save a cycle on strncpy() -- pointed out by Theo
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.10 1996/10/21 18:55:56 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.10 1996/10/21 18:55:56 millert Exp $";
d430 1
a430 1
	memset((void *)kdata_st, 0, sizeof(*kdata_st));
@


1.10
log
@sheer raging paranoia -- possible buf olfow.  Does not look exploitable.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.9 1996/10/16 00:37:11 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.9 1996/10/16 00:37:11 millert Exp $";
d144 1
a144 1
			shell = strncpy(shellbuf, pwd->pw_shell, sizeof(shellbuf));
d261 1
a261 1
		strncpy(avshellbuf+1, avshell, sizeof(avshellbuf) - 1);
d267 1
a267 1
		strncpy(avshellbuf+1, avshell, sizeof(avshellbuf) - 1);
d385 1
a385 1
	(void)strncpy(savehost, krb_get_phost(hostname), sizeof(savehost));
d433 1
a433 1
	(void)strncpy(kdata->pname, name, sizeof(kdata->pname));
d437 1
a437 1
	    ((strcmp(toname, "root") == 0) ? "root" : ""), sizeof(kdata->pinst));
d440 1
a440 1
	(void)strncpy(kdata->prealm, realm, sizeof(kdata->prealm));
@


1.9
log
@Check ret val of strdup(3) -- may be NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.8 1996/10/12 20:40:37 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.8 1996/10/12 20:40:37 millert Exp $";
d143 4
a146 3
		if (pwd->pw_shell && *pwd->pw_shell)
			shell = strcpy(shellbuf, pwd->pw_shell);
		else {
d261 2
a262 1
		strcpy(avshellbuf+1, avshell);
d267 2
a268 1
		strcpy(avshellbuf+1, avshell);
d408 1
a408 1
		(void)bcopy((char *)hp->h_addr, (char *)&faddr, sizeof(faddr));
d430 1
d432 11
a442 5
	bzero((caddr_t) kdata, sizeof(*kdata));
	(void)strcpy(kdata->pname, name);
	(void)strcpy(kdata->pinst,
	    ((strcmp(toname, "root") == 0) ? "root" : ""));
	(void)strcpy(kdata->prealm, realm);
@


1.8
log
@su.c: minor cleanup, some from FreeBSD
su.1: Examples from FreeBSD + minor nits fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.7 1996/10/12 17:13:57 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.7 1996/10/12 17:13:57 millert Exp $";
d90 1
a90 1
	uid_t ruid, getuid();
d140 2
a141 1
	username = strdup(pwd->pw_name);
d144 1
a144 1
			shell = strcpy(shellbuf,  pwd->pw_shell);
d278 1
a278 1
	err(1, "%s", shell);
@


1.7
log
@Fix suage string to match man page.  NetBSD PR #2837
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.6 1996/10/08 18:36:56 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.6 1996/10/08 18:36:56 deraadt Exp $";
d50 6
a55 1
#include <syslog.h>
a57 2
#include <pwd.h>
#include <grp.h>
d59 1
d61 4
a64 1
#include <paths.h>
d78 2
a79 2
extern char *crypt();
int chshell();
a86 1
	extern int errno, optind;
a94 1
	char *getpass(), *getenv(), *getlogin(), *ontty();
d138 2
a139 4
	if (pwd == NULL) {
		fprintf(stderr, "su: who are you?\n");
		exit(1);
	}
d153 2
a154 4
	if ((pwd = getpwnam(user)) == NULL) {
		fprintf(stderr, "su: unknown login %s\n", user);
		exit(1);
	}
d165 3
a167 7
				if (!*g) {
					(void)fprintf(stderr,
			    "su: you are not in the correct group to su %s.\n",
					    user);
					exit(1);
				}
				if (!strcmp(username, *g))
d175 4
a178 9
				if (skey_haskey(user)) {
					fprintf(stderr, "Sorry, you have no s/key.\n");
					exit(1);
				} else {
					if (skey_authenticate(user)) {
						goto badlogin;
					}
				}

d191 6
d201 2
a202 5
		if (!chshell(pwd->pw_shell) && ruid) {
			(void)fprintf(stderr,
				"su: permission denied (shell).\n");
			exit(1);
		}
d211 1
a211 1
	if (p = rindex(shell, '/'))
d221 6
a226 12
	if (setgid(pwd->pw_gid) < 0) {
		perror("su: setgid");
		exit(1);
	}
	if (initgroups(user, pwd->pw_gid)) {
		(void)fprintf(stderr, "su: initgroups failed.\n");
		exit(1);
	}
	if (setuid(pwd->pw_uid) < 0) {
		perror("su: setuid");
		exit(1);
	}
d239 2
a240 4
			if (chdir(pwd->pw_dir) < 0) {
				fprintf(stderr, "su: no directory\n");
				exit(1);
			}
d277 1
a277 2
	(void)fprintf(stderr, "su: %s not found.\n", shell);
	exit(1);
a284 1
	char *getusershell();
d287 1
a287 1
		if (!strcmp(cp, sh))
d300 1
a300 1
		sprintf(buf, " on %s", p);
d325 2
a326 1
	(void)sprintf(krbtkfile, "%s_%s_%d", TKT_ROOT, user, getuid());
d335 1
a335 1
		perror("su: setuid");
d355 1
a355 1
			fprintf(stderr, "principal unknown: %s.%s@@%s\n",
d360 1
a360 2
		(void)fprintf(stderr, "su: unable to su: %s\n",
		    krb_err_txt[kerno]);
d368 1
a368 1
		perror("su: chown:");
d376 1
a376 1
		perror("su: gethostname");
d387 1
a387 1
		(void)fprintf(stderr, "Warning: TGT not verified.\n");
d393 1
a393 2
		(void)fprintf(stderr, "Unable to use TGT: %s\n",
		    krb_err_txt[kerno]);
d400 1
a400 2
			(void)fprintf(stderr, "su: can't get addr of %s\n",
			    hostname);
d408 2
a409 3
			(void)fprintf(stderr,
			    "su: unable to verify rcmd ticket: %s\n",
			    krb_err_txt[kerno]);
@


1.6
log
@export $TERM only if passed in; joerg@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.5 1996/07/22 01:58:55 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.5 1996/07/22 01:58:55 deraadt Exp $";
d113 2
a114 1
			(void)fprintf(stderr, "usage: su [%s] [login]\n",
@


1.5
log
@seteuid for chdir
@
text
@d1 1
a1 1
/*	$OpenBSD: su.c,v 1.4 1996/06/26 05:39:34 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.4 1996/06/26 05:39:34 deraadt Exp $";
d244 2
a245 1
			(void)setenv("TERM", p, 1);
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: su.c,v 1.3 1996/01/07 09:51:22 deraadt Exp $";
d245 3
d252 2
@


1.3
log
@more traditional semantics. if wheel group has no listed users, anyone
can su to root. default wheel group lists "root" as a user, thus
defaulting to a secure envirment. from arnej@@pvv.unit.no; netbsd pr#1894
@
text
@d1 2
d44 1
a44 1
static char rcsid[] = "$Id: su.c,v 1.2 1995/12/16 22:20:38 tholo Exp $";
@


1.2
log
@Make it possible to build without SKEY support
Add support for building with kerberosIV
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: su.c,v 1.1.1.1 1995/10/18 08:46:10 deraadt Exp $";
d158 2
a159 1
		if (pwd->pw_uid == 0 && (gr = getgrgid((gid_t)0)))
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: su.c,v 1.10 1994/05/24 06:52:23 deraadt Exp $";
a313 1
	extern char *krb_err_txt[];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
