head	1.27;
access;
symbols
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.26
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.24
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.20
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.18
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.16
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.14
	OPENBSD_5_0:1.24.0.12
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.10
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.8
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.8
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.6
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.27
date	2016.04.02.14.37.42;	author krw;	state Exp;
branches;
next	1.26;
commitid	rfpOX4oSITckBvQ2;

1.26
date	2015.11.01.14.02.37;	author tim;	state Exp;
branches;
next	1.25;
commitid	DGBCoLUZ9OlrnUNp;

1.25
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Uu5nFG3wCl0LACBb;

1.24
date	2008.11.12.16.13.46;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.11.20.50.54;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.26.17.06.39;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.06.21.50.24;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.01.52.41;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.06.15.34.08;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.06.10.45.49;	author mpech;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.02.20.10.46;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.28.20.58.35;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.14.04.29.04;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.15.32.10;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.16.03.50.42;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.09.07.04.52;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.20.21.53.49;	author pjanzen;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.20.18.42.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.06.21.22.14.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.09.09.00.04.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.24.03.43.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.07.02.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.06.31.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.05.17.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.07.23.04.31.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.07.23.04.24.35;	author millert;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Another use for fcntl() and thus of the superfluous 3rd parameter
is when sanitising standard fd's before calling daemon().

Use a tweaked version of the ssh(1) function in all three places
found using fcntl() this way.

ok jca@@ beck@@
@
text
@/*	$OpenBSD: skeyaudit.c,v 1.26 2015/11/01 14:02:37 tim Exp $	*/

/*
 * Copyright (c) 1997, 2000, 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <login_cap.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <skey.h>

void notify(struct passwd *, int, int);
void sanitise_stdfd(void);
FILE *runsendmail(struct passwd *, int *);
__dead void usage(void);

void
sanitise_stdfd(void)
{
	int nullfd, dupfd;

	if ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
		fprintf(stderr, "Couldn't open /dev/null: %s\n",
		    strerror(errno));
		exit(1);
	}
	while (++dupfd <= STDERR_FILENO) {
		/* Only populate closed fds. */
		if (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {
			if (dup2(nullfd, dupfd) == -1) {
				fprintf(stderr, "dup2: %s\n", strerror(errno));
				exit(1);
			}
		}
	}
	if (nullfd > STDERR_FILENO)
		close(nullfd);
}

int
main(int argc, char **argv)
{
	struct passwd *pw;
	struct skey key;
	char *name;
	int ch, left, aflag, iflag, limit;

	if (pledge("stdio rpath wpath flock getpw proc exec id", NULL) == -1)
		err(1, "pledge");

	aflag = iflag = 0;
	limit = 12;
	while ((ch = getopt(argc, argv, "ail:")) != -1)
		switch(ch) {
		case 'a':
			if (getuid() != 0)
				errx(1, "only root may use the -a flag");
			aflag = 1;
			break;
		case 'i':
			iflag = 1;
			break;
		case 'l':
			errno = 0;
			if ((limit = (int)strtol(optarg, NULL, 10)) == 0)
				errno = ERANGE;
			if (errno) {
				warn("key limit");
				usage();
			}
			break;
		default:
			usage();
	}

	if (iflag) {
		if (pledge("stdio rpath wpath flock getpw", NULL) == -1)
			err(1, "pledge");
	}

	 /* If we are in interactive mode, STDOUT_FILENO *must* be open. */
	if (iflag && fcntl(STDOUT_FILENO, F_GETFL) == -1 && errno == EBADF)
		exit(1);

	/*
	 * Make sure STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO are open.
	 * If not, open /dev/null in their place or bail.
	 */
	sanitise_stdfd();

	if (argc - optind > 0)
		usage();

	/* Need key.keyfile zero'd at the very least */
	(void)memset(&key, 0, sizeof(key));

	left = 0;
	if (aflag) {
		while ((ch = skeygetnext(&key)) == 0) {
			left = key.n - 1;
			if ((pw = getpwnam(key.logname)) == NULL)
				continue;
			if (left >= limit)
				continue;
			(void)fclose(key.keyfile);
			key.keyfile = NULL;
			notify(pw, left, iflag);
		}
		if (ch == -1)
			errx(-1, "cannot open %s", _PATH_SKEYDIR);
	} else {
		if ((pw = getpwuid(getuid())) == NULL)
			errx(1, "no passwd entry for uid %u", getuid());
		if ((name = strdup(pw->pw_name)) == NULL)
			err(1, "cannot allocate memory");
		sevenbit(name);

		switch (skeylookup(&key, name)) {
			case 0:		/* Success! */
				left = key.n - 1;
				break;
			case -1:	/* File error */
				errx(1, "cannot open %s/%s", _PATH_SKEYDIR,
				    name);
				break;
			case 1:		/* Unknown user */
				errx(1, "user %s is not listed in %s", name,
				    _PATH_SKEYDIR);
		}
		(void)fclose(key.keyfile);

		if (left < limit)
			notify(pw, left, iflag);
	}
		
	exit(0);
}

void
notify(struct passwd *pw, int seq, int interactive)
{
	static char hostname[HOST_NAME_MAX+1];
	pid_t pid;
	FILE *out;

	/* Only set this once */
	if (hostname[0] == '\0' && gethostname(hostname, sizeof(hostname)) == -1)
		strlcpy(hostname, "unknown", sizeof(hostname));

	if (interactive)
		out = stdout;
	else
		out = runsendmail(pw, &pid);

	if (!interactive)
		(void)fprintf(out,
		   "Auto-Submitted: auto-generated\n"
		   "To: %s\nSubject: IMPORTANT action required\n", pw->pw_name);

	if (seq)
		(void)fprintf(out,
"\nYou are nearing the end of your current S/Key sequence for account\n\
%s on system %s.\n\n\
Your S/Key sequence number is now %d.  When it reaches zero\n\
you will no longer be able to use S/Key to log into the system.\n\n",
pw->pw_name, hostname, seq);
	else
		(void)fprintf(out,
"\nYou are at the end of your current S/Key sequence for account\n\
%s on system %s.\n\n\
At this point you can no longer use S/Key to log into the system.\n\n",
pw->pw_name, hostname);
	(void)fprintf(out,
"Type \"skeyinit -s\" to reinitialize your sequence number.\n\n");

	if (!interactive) {
		(void)fclose(out);
		(void)waitpid(pid, NULL, 0);
	}
}

FILE *
runsendmail(struct passwd *pw, pid_t *pidp)
{
	FILE *fp;
	int pfd[2];
	pid_t pid;

	if (pipe(pfd) < 0)
		return(NULL);

	switch (pid = fork()) {
	case -1:			/* fork(2) failed */
		(void)close(pfd[0]);
		(void)close(pfd[1]);
		return(NULL);
	case 0:				/* In child */
		(void)close(pfd[1]);
		(void)dup2(pfd[0], STDIN_FILENO);
		(void)close(pfd[0]);

		/* Run sendmail as target user not root */
		if (getuid() == 0 &&
		    setusercontext(NULL, pw, pw->pw_uid, LOGIN_SETALL) != 0) {
			warn("cannot set user context");
			_exit(127);
		}

		execl(_PATH_SENDMAIL, "sendmail", "-t", (char *)NULL);
		warn("cannot run \"%s -t\"", _PATH_SENDMAIL);
		_exit(127);
	}

	/* In parent */
	*pidp = pid;
	fp = fdopen(pfd[1], "w");
	(void)close(pfd[0]);

	return(fp);
}

__dead void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr, "usage: %s [-ai] [-l limit]\n",
	    __progname);
	exit(1);
}
@


1.26
log
@Pledge; OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.25 2015/01/16 06:40:11 deraadt Exp $	*/
d39 1
d43 23
d107 4
a113 1
	 * If we are in interactive mode, STDOUT_FILENO *must* be open.
d115 1
a115 8
	for (ch = STDIN_FILENO; ch <= STDERR_FILENO; ch++) {
		if (fcntl(ch, F_GETFL, 0) == -1 && errno == EBADF) {
			if (ch == STDOUT_FILENO && iflag)
				exit(1);	/* need stdout for -i */
			if (open(_PATH_DEVNULL, O_RDWR, 0644) == -1)
				exit(1);	/* just bail */
		}
	}
@


1.25
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.24 2008/11/12 16:13:46 sobrado Exp $	*/
d50 3
d76 5
@


1.24
log
@Usage -> usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.23 2006/12/11 20:50:54 deraadt Exp $	*/
a22 1
#include <sys/param.h>
d140 1
a140 1
	static char hostname[MAXHOSTNAMELEN];
@


1.23
log
@rfc 3834 support: Auto-Submitted: auto-generated on lots of things; from Tamas TEVESZ; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.22 2005/10/26 17:06:39 millert Exp $	*/
d226 1
a226 1
	(void)fprintf(stderr, "Usage: %s [-ai] [-l limit]\n",
@


1.22
log
@3rd arg to F_GETFL fcntl doesn't need to be a pointer, 0 is fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.21 2005/07/06 21:50:24 jmc Exp $	*/
d156 1
@


1.21
log
@- simplify SYNOPSIS
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.20 2003/06/03 01:52:41 millert Exp $	*/
d82 1
a82 1
		if (fcntl(ch, F_GETFL, &left) == -1 && errno == EBADF) {
@


1.20
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.19 2003/05/06 15:34:08 millert Exp $	*/
d225 1
a225 1
	(void)fprintf(stderr, "Usage: %s [-a] [-i] [-l limit]\n",
@


1.19
log
@Don't call setusercontext() to change uid unless uid == 0; found by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.18 2003/05/06 10:45:49 mpech Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.18
log
@While I'm here sync usage() w/ manual.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.17 2003/05/02 20:10:46 millert Exp $	*/
d212 2
a213 1
		if (setusercontext(NULL, pw, pw->pw_uid, LOGIN_SETALL) != 0) {
@


1.17
log
@o Don't close stdout in interactive mode; mpech@@
Extra paranoia:
o Close keyfile by hand each time in -a mode so we don't leak an fd
to sendmail
o If any of std{out,in,err} are not open, open /dev/null in their stead.
o If stdout is not open and -i was specified, just exit since there
  is nowhere to print the info.

Thanks for mpech@@ for his testing and bug finding ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.16 2003/04/28 20:58:35 millert Exp $	*/
d235 1
a235 1
	(void)fprintf(stderr, "Usage: %s [-i] [-l limit]\n",
@


1.16
log
@Don't try to close key.keyfile in -a mode, skeygetnext() will have
already done it and we are headed for exit anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.15 2003/03/14 04:29:04 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997, 2000 Todd C. Miller <Todd.Miller@@courtesan.com>
d28 4
d39 1
d62 1
a62 1
	left = aflag = iflag = 0;
d87 14
d107 1
d115 2
d185 2
a186 2
	(void)fclose(out);
	if (!interactive)
d188 1
@


1.15
log
@Replace strcpy() of a constant w/ strlcpy() for easy grepping;
from Raymond M Schneider
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.14 2002/05/29 15:32:10 millert Exp $	*/
a98 2
		else
			(void)fclose(key.keyfile);
@


1.14
log
@Don't call fclose() on a NULL file handle; from markus@@
Also:
Use ANSI function headers
Use pid_t for pids
Never do exit(-1)
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.13 2002/05/16 03:50:42 millert Exp $	*/
d138 1
a138 1
		strcpy(hostname, "unknown");
@


1.13
log
@Change S/Key stuff from using a flat file (/etc/skeykeys) to a directory
where each user gets their own file, which is owned by that user.

An old S/Key database may be converted by running "skeyinit -C" as root.

Programs that need to access the S/Key database no longer need to be
setuid root.  They must now be setgid auth instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.12 2002/02/16 21:27:52 millert Exp $	*/
a44 2
extern char *__progname;

d47 1
a47 1
void usage(void);
d50 1
a50 3
main(argc, argv)
	int argc;
	char **argv;
a53 1
	int ch, errs = 0, left = 0, aflag = 0, iflag = 0, limit = 12;
d55 1
d57 2
a61 1
			aflag = 1;
d64 1
d108 1
a108 2
		errs = skeylookup(&key, name);
		switch (errs) {
d113 2
a114 1
				errx(errs, "cannot open %s", _PATH_SKEYDIR);
d117 1
a117 1
				warnx("%s is not listed in %s", name,
d122 1
a122 1
		if (!errs && left < limit)
d126 1
a126 1
	exit(errs);
d130 1
a130 4
notify(pw, seq, interactive)
	struct passwd *pw;
	int seq;
	int interactive;
d133 1
a133 1
	int pid;
d171 1
a171 3
runsendmail(pw, pidp)
	struct passwd *pw;
	int *pidp;
d174 2
a175 1
	int pfd[2], pid;
d208 3
a210 2
void
usage()
d212 2
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.11 2001/07/09 07:04:52 deraadt Exp $	*/
a60 3
	if (geteuid() != 0)
		errx(1, "must be setuid root");

d100 1
a100 1
			errx(-1, "cannot open %s", _PATH_SKEYKEYS);
d116 1
a116 1
				errx(errs, "cannot open %s", _PATH_SKEYKEYS);
d120 1
a120 1
				    _PATH_SKEYKEYS);
@


1.11
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.10 2000/09/20 21:53:49 pjanzen Exp $	*/
d47 3
a49 3
void notify __P((struct passwd *, int, int));
FILE *runsendmail __P((struct passwd *, int *));
void usage __P((void));
@


1.10
log
@Change the message if the S/Key sequence has expired.  millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.9 2000/08/20 18:42:40 millert Exp $	*/
d205 1
a205 1
		execl(_PATH_SENDMAIL, "sendmail", "-t", NULL);
@


1.9
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.8 1998/06/21 22:14:02 millert Exp $	*/
d157 2
a158 1
	(void)fprintf(out,
d161 2
a162 3
Your S/key sequence number is now %d.  When it reaches zero\n\
you will no longer be able to use S/Key to login into the system.\n\n\
Type \"skeyinit -s\" to reinitialize your sequence number.\n\n",
d164 8
@


1.8
log
@Remove the advertising clause in my old license, it impedes free use
of the code as a large number of similar clauses makes it impossible
to write an ad for a product using the code...
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.7 1997/09/09 00:04:19 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Todd C. Miller <Todd.Miller@@courtesan.com>
d30 3
d36 1
a44 4
#include <sys/types.h>
#include <sys/param.h>
#include <sys/wait.h>

d47 2
a48 2
void notify __P((char *, uid_t, gid_t, int, int));
FILE *runsendmail __P((char *, uid_t, gid_t, int *));
d100 1
a100 1
			notify(key.logname, pw->pw_uid, pw->pw_gid, left, iflag);
d128 1
a128 1
			notify(name, pw->pw_uid, pw->pw_gid, left, iflag);
d135 2
a136 4
notify(user, uid, gid, seq, interactive)
	char *user;
	uid_t uid;
	gid_t gid;
d151 1
a151 1
		out = runsendmail(user, uid, gid, &pid);
d155 1
a155 1
		    "To: %s\nSubject: IMPORTANT action required\n", user);
d163 1
a163 1
user, hostname, seq);
d171 2
a172 4
runsendmail(user, uid, gid, pidp)
	char *user;
	uid_t uid;
	gid_t gid;
d192 4
a195 6
		initgroups(user, gid);
		setegid(gid);
		setgid(gid);
		setlogin(user);
		seteuid(uid);
		setuid(uid);
@


1.7
log
@use setlogin(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.6 1997/07/24 03:43:59 millert Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Todd C. Miller.
 * 4. The name of the author may not be used to endorse or promote products
@


1.6
log
@Add -a (audit all users) flag and do our pipes.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.5 1997/07/23 07:02:02 millert Exp $	*/
d202 1
@


1.5
log
@Use _PATH_SKEYKEYS and fix a typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.4 1997/07/23 06:31:17 millert Exp $	*/
d46 1
d50 2
d61 5
a65 3
	int ch, errs, left = 0, iflag = 0, limit = 12;
	char *name, hostname[MAXHOSTNAMELEN];
	FILE *out;
d67 1
a67 1
	while ((ch = getopt(argc, argv, "il:")) != -1)
d69 5
d93 5
a97 9
	if ((pw = getpwuid(getuid())) == NULL)
		errx(1, "no passwd entry for uid %u", getuid());
	if ((name = strdup(pw->pw_name)) == NULL)
		err(1, "cannot allocate memory");
	sevenbit(name);

	errs = skeylookup(&key, name);
	switch (errs) {
		case 0:		/* Success! */
d99 33
a131 6
			break;
		case -1:	/* File error */
			warnx("cannot open %s", _PATH_SKEYKEYS);
			break;
		case 1:		/* Unknown user */
			warnx("%s is not listed in %s", name, _PATH_SKEYKEYS);
d133 3
a135 1
	(void)fclose(key.keyfile);
d137 11
a147 6
	/* Run sendmail as user not root */
	seteuid(getuid());
	setuid(getuid());

	if (errs || left >= limit)
		exit(errs);
d149 2
a150 1
	if (gethostname(hostname, sizeof(hostname)) == -1)
d153 1
a153 1
	if (iflag) {
d155 2
a156 6
	} else {
		char cmd[sizeof(_PATH_SENDMAIL) + 3];

		sprintf(cmd, "%s -t", _PATH_SENDMAIL);
		out = popen(cmd, "w");
	}
d158 1
a158 1
	if (!iflag)
d160 1
a160 1
		    "To: %s\nSubject: IMPORTANT action required\n", name);
d168 1
a168 1
name, hostname, left - 1);
d170 3
a172 6
	if (iflag)
		(void)fclose(out);
	else
		(void)pclose(out);
	
	exit(0);
d175 42
@


1.4
log
@close keyfile nicely.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.3 1997/07/23 05:17:46 millert Exp $	*/
d95 1
a95 2
			/* XXX - _PATH_SKEYFILE should be in paths.h? */
			warnx("cannot open /etc/skeykeys");
d98 1
a98 1
			warnx("%s is not listed in /etc/skeykeys", name);
d100 1
a100 1
	(void)fclose(mp->keyfile);
@


1.3
log
@Add a seteuid() just in case someone decides to make this setuid
by some uid other than 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyaudit.c,v 1.2 1997/07/23 04:31:17 millert Exp $	*/
d101 1
@


1.2
log
@copyright
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 3
a104 1
	setuid(getuid());	/* Run sendmail as user not root */
@


1.1
log
@Replace skeyaudit.sh with a setuid binary (necessary for mode 0600 skeykeys)
@
text
@d1 32
@
