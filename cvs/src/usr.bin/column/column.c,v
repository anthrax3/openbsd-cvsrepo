head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.8
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.09.04.20.33.36;	author martijn;	state Exp;
branches;
next	1.24;
commitid	KuvflCaEtfU9WwDf;

1.24
date	2016.08.31.20.43.57;	author martijn;	state Exp;
branches;
next	1.23;
commitid	flAOWDhdvUHFv98K;

1.23
date	2016.03.17.05.27.10;	author bentley;	state Exp;
branches;
next	1.22;
commitid	0afdJPZPXUfvItJV;

1.22
date	2015.11.03.04.55.44;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	W0DCFZGfkfXcwtZH;

1.21
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	sbrB3Q5CNxcwZpfU;

1.20
date	2015.10.05.13.30.30;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	rSXobTeKTvip1j7I;

1.19
date	2014.05.22.19.50.34;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2014.05.17.20.05.07;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.22.09.39.38;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.26.13.18.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.01.13.30.21;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.01.01.26.23;	author jdixon;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.10.19.14.58;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.26.22.24.09;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.02.56.07;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.12.05.16.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.12.09.00.48.03;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.30.11.46.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.42.21;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Add full UTF-8 support to column(1).

Feedback and OK schwarze@@
@
text
@/*	$OpenBSD: column.c,v 1.24 2016/08/31 20:43:57 martijn Exp $	*/
/*	$NetBSD: column.c,v 1.4 1995/09/02 05:53:03 jtc Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <wchar.h>
#include <wctype.h>

void  c_columnate(void);
void *ereallocarray(void *, size_t, size_t);
void *ecalloc(size_t, size_t);
void  input(FILE *);
void  maketbl(void);
void  print(void);
void  r_columnate(void);
__dead void usage(void);

struct field {
	char *content;
	int width;
};

int termwidth;			/* default terminal width */
int entries;			/* number of records */
int eval;			/* exit value */
int *maxwidths;			/* longest record per column */
struct field **table;		/* one array of pointers per line */
wchar_t *separator = L"\t ";	/* field separator for table option */

int
main(int argc, char *argv[])
{
	struct winsize win;
	FILE *fp;
	int ch, tflag, xflag;
	char *p;
	const char *errstr;

	setlocale(LC_CTYPE, "");

	termwidth = 0;
	if ((p = getenv("COLUMNS")) != NULL)
		termwidth = strtonum(p, 1, INT_MAX, NULL);
	if (termwidth == 0 && ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
	    win.ws_col > 0)
		termwidth = win.ws_col;
	if (termwidth == 0)
		termwidth = 80;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	tflag = xflag = 0;
	while ((ch = getopt(argc, argv, "c:s:tx")) != -1) {
		switch(ch) {
		case 'c':
			termwidth = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr != NULL)
				errx(1, "%s: %s", errstr, optarg);
			break;
		case 's':
			if ((separator = reallocarray(NULL, strlen(optarg) + 1,
			    sizeof(*separator))) == NULL)
				err(1, NULL);
			if (mbstowcs(separator, optarg, strlen(optarg) + 1) ==
			    (size_t) -1)
				err(1, "sep");
			break;
		case 't':
			tflag = 1;
			break;
		case 'x':
			xflag = 1;
			break;
		default:
			usage();
		}
	}

	if (!tflag)
		separator = L"";
	argv += optind;

	if (*argv == NULL) {
		input(stdin);
	} else {
		for (; *argv; ++argv) {
			if ((fp = fopen(*argv, "r"))) {
				input(fp);
				(void)fclose(fp);
			} else {
				warn("%s", *argv);
				eval = 1;
			}
		}
	}

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if (!entries)
		return eval;

	if (tflag)
		maketbl();
	else if (*maxwidths >= termwidth)
		print();
	else if (xflag)
		c_columnate();
	else
		r_columnate();
	return eval;
}

#define	INCR_NEXTTAB(x)	(x = (x + 8) & ~7)
void
c_columnate(void)
{
	int col, numcols;
	struct field **row;

	INCR_NEXTTAB(*maxwidths);
	if ((numcols = termwidth / *maxwidths) == 0)
		numcols = 1;
	for (col = 0, row = table;; ++row) {
		fputs((*row)->content, stdout);
		if (!--entries)
			break;
		if (++col == numcols) {
			col = 0;
			putchar('\n');
		} else {
			while (INCR_NEXTTAB((*row)->width) <= *maxwidths)
				putchar('\t');
		}
	}
	putchar('\n');
}

void
r_columnate(void)
{
	int base, col, numcols, numrows, row;

	INCR_NEXTTAB(*maxwidths);
	if ((numcols = termwidth / *maxwidths) == 0)
		numcols = 1;
	numrows = entries / numcols;
	if (entries % numcols)
		++numrows;

	for (base = row = 0; row < numrows; base = ++row) {
		for (col = 0; col < numcols; ++col, base += numrows) {
			fputs(table[base]->content, stdout);
			if (base + numrows >= entries)
				break;
			while (INCR_NEXTTAB(table[base]->width) <= *maxwidths)
				putchar('\t');
		}
		putchar('\n');
	}
}

void
print(void)
{
	int row;

	for (row = 0; row < entries; row++)
		puts(table[row]->content);
}


void
maketbl(void)
{
	struct field **row;
	int col;

	for (row = table; entries--; ++row) {
		for (col = 0; (*row)[col + 1].content != NULL; ++col)
			printf("%s%*s  ", (*row)[col].content,
			    maxwidths[col] - (*row)[col].width, "");
		puts((*row)[col].content);
	}
}

#define	DEFNUM		1000
#define	DEFCOLS		25

void
input(FILE *fp)
{
	static int maxentry = 0;
	static int maxcols = 0;
	static struct field *cols = NULL;
	int col, width, twidth;
	size_t blen;
	ssize_t llen;
	char *p, *s, *buf = NULL;
	wchar_t wc;
	int wlen;

	while ((llen = getline(&buf, &blen, fp)) > -1) {
		if (buf[llen - 1] == '\n')
			buf[llen - 1] = '\0';

		p = buf;
		for (col = 0;; col++) {

			/* Skip lines containing nothing but whitespace. */

			for (s = p; (wlen = mbtowc(&wc, s, MB_CUR_MAX)) > 0;
			     s += wlen)
				if (!iswspace(wc))
					break;
			if (*s == '\0')
				break;

			/* Skip leading, multiple, and trailing separators. */

			while ((wlen = mbtowc(&wc, p, MB_CUR_MAX)) > 0 &&
			    wcschr(separator, wc) != NULL)
				p += wlen;
			if (*p == '\0')
				break;

			/*
			 * Found a non-empty field.
			 * Remember the start and measure the width.
			 */

			s = p;
			width = 0;
			while (*p != '\0') {
				if ((wlen = mbtowc(&wc, p, MB_CUR_MAX)) == -1) {
					width++;
					p++;
					continue;
				}
				if (wcschr(separator, wc) != NULL)
					break;
				if (*p == '\t')
					INCR_NEXTTAB(width);
				else  {
					width += (twidth = wcwidth(wc)) == -1 ?
					    1 : twidth;
				}
				p += wlen;
			}

			if (col + 1 >= maxcols) {
				if (maxcols > INT_MAX - DEFCOLS)
					err(1, "too many columns");
				maxcols += DEFCOLS;
				cols = ereallocarray(cols, maxcols,
				    sizeof(*cols));
				maxwidths = ereallocarray(maxwidths, maxcols,
				    sizeof(*maxwidths));
				memset(maxwidths + col, 0,
				    DEFCOLS * sizeof(*maxwidths));
			}

			/*
			 * Remember the width of the field,
			 * NUL-terminate and remeber the content,
			 * and advance beyond the separator, if any.
			 */

			cols[col].width = width;
			if (maxwidths[col] < width)
				maxwidths[col] = width;
			if (*p != '\0') {
				*p = '\0';
				p += wlen;
			}
			if ((cols[col].content = strdup(s)) == NULL)
				err(1, NULL);
		}
		if (col == 0)
			continue;

		/* Found a non-empty line; remember it. */

		if (entries == maxentry) {
			if (maxentry > INT_MAX - DEFNUM)
				errx(1, "too many input lines");
			maxentry += DEFNUM;
			table = ereallocarray(table, maxentry, sizeof(*table));
		}
		table[entries] = ereallocarray(NULL, col + 1,
		    sizeof(*(table[entries])));
		table[entries][col].content = NULL;
		while (col--)
			table[entries][col] = cols[col];
		entries++;
	}
}

void *
ereallocarray(void *ptr, size_t nmemb, size_t size)
{
	if ((ptr = reallocarray(ptr, nmemb, size)) == NULL)
		err(1, NULL);
	return ptr;
}

void *
ecalloc(size_t nmemb, size_t size)
{
	void *ptr;

	if ((ptr = calloc(nmemb, size)) == NULL)
		err(1, NULL);
	return ptr;
}

__dead void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: column [-tx] [-c columns] [-s sep] [file ...]\n");
	exit(1);
}
@


1.24
log
@Complete do-over for column to prepare for implementing UTF-8 support.
Fix a few bugs while here, namely:
- Fix the width-calculation of a tab-character
- Correct treatment of files without trailing newlines.
- Repair "-xc 7"
- Overflow protection for the number of rows and columns

Lots of help from and OK schwarze@@
Get it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.23 2016/03/17 05:27:10 bentley Exp $	*/
d39 1
d44 2
d66 1
a66 1
char *separator = "\t ";	/* field separator for table option */
d77 2
d100 6
a105 1
			separator = optarg;
d119 1
a119 1
		separator = "";
d235 1
a235 1
	int col, width;
d239 2
d251 3
a253 2
			for (s = p; s != '\0'; s++)
				if (!isspace((unsigned char)*s))
d260 3
a262 2
			while (*p != '\0' && strchr(separator, *p) != NULL)
				p++;
d273 9
a281 2
			while (*p != '\0' && strchr(separator, *p) == NULL) {
				if (*p++ == '\t')
d283 5
a287 2
				else
					width++;
d311 4
a314 2
			if (*p != '\0')
				*p++ = '\0';
@


1.23
log
@Switch (non-curses, non-ksh) programs that use COLUMNS to a single idiom.

Previously behaviors were all over the map. This changes them to
use COLUMNS first, and either terminal width or a hardcoded value
(typically 80) as appropriate.

ok deraadt@@; man bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.22 2015/11/03 04:55:44 mmcc Exp $	*/
d51 6
a56 1
void  usage(void);
a58 1

d61 2
a62 2
int maxlength;			/* longest record */
char **list;			/* array of pointers to records */
d87 1
a87 1
	while ((ch = getopt(argc, argv, "c:s:tx")) != -1)
a102 1
		case '?':
d106 4
a109 1
	argc -= optind;
d112 1
a112 1
	if (!*argv) {
d130 1
a130 1
		exit(eval);
d134 1
a134 1
	else if (maxlength >= termwidth)
d140 1
a140 1
	exit(eval);
d143 1
a143 1
#define	TAB	8
d147 2
a148 2
	int chcnt, col, cnt, endcol, numcols;
	char **lp;
d150 5
a154 5
	maxlength = (maxlength + TAB) & ~(TAB - 1);
	numcols = termwidth / maxlength;
	endcol = maxlength;
	for (chcnt = col = 0, lp = list;; ++lp) {
		chcnt += printf("%s", *lp);
d158 1
a158 2
			chcnt = col = 0;
			endcol = maxlength;
d161 2
a162 5
			while ((cnt = ((chcnt + TAB) & ~(TAB - 1))) <= endcol) {
				(void)putchar('\t');
				chcnt = cnt;
			}
			endcol += maxlength;
d165 1
a165 2
	if (chcnt)
		putchar('\n');
d171 1
a171 1
	int base, chcnt, cnt, col, endcol, numcols, numrows, row;
d173 2
a174 3
	maxlength = (maxlength + TAB) & ~(TAB - 1);
	numcols = termwidth / maxlength;
	if (numcols == 0)
d180 4
a183 5
	for (row = 0; row < numrows; ++row) {
		endcol = maxlength;
		for (base = row, chcnt = col = 0; col < numcols; ++col) {
			chcnt += printf("%s", list[base]);
			if ((base += numrows) >= entries)
d185 2
a186 5
			while ((cnt = ((chcnt + TAB) & ~(TAB - 1))) <= endcol) {
				(void)putchar('\t');
				chcnt = cnt;
			}
			endcol += maxlength;
d195 1
a195 2
	int cnt;
	char **lp;
d197 2
a198 2
	for (cnt = entries, lp = list; cnt--; ++lp)
		(void)printf("%s\n", *lp);
a200 5
typedef struct _tbl {
	char **list;
	int cols, *len;
} TBL;
#define	DEFCOLS	25
d205 8
a212 31
	TBL *t;
	int coloff, cnt;
	char *p, **lp;
	int *lens, maxcols = DEFCOLS;
	TBL *tbl;
	char **cols;

	t = tbl = ecalloc(entries, sizeof(TBL));
	cols = ereallocarray(NULL, maxcols, sizeof(char *));
	lens = ecalloc(maxcols, sizeof(int));
	for (cnt = 0, lp = list; cnt < entries; ++cnt, ++lp, ++t) {
		for (coloff = 0, p = *lp; (cols[coloff] = strtok(p, separator));
		    p = NULL)
			if (++coloff == maxcols) {
				maxcols += DEFCOLS;
				cols = ereallocarray(cols, maxcols, 
				    sizeof(char *));
				lens = ereallocarray(lens, maxcols,
				    sizeof(int));
				memset(lens + coloff, 0, DEFCOLS * sizeof(int));
			}
		if (coloff == 0)
			continue;
		t->list = ecalloc(coloff, sizeof(char *));
		t->len = ecalloc(coloff, sizeof(int));
		for (t->cols = coloff; --coloff >= 0;) {
			t->list[coloff] = cols[coloff];
			t->len[coloff] = strlen(cols[coloff]);
			if (t->len[coloff] > lens[coloff])
				lens[coloff] = t->len[coloff];
		}
a213 11
	for (cnt = 0, t = tbl; cnt < entries; ++cnt, ++t) {
		if (t->cols > 0) {
			for (coloff = 0; coloff < t->cols - 1; ++coloff)
				(void)printf("%s%*s", t->list[coloff],
				    lens[coloff] - t->len[coloff] + 2, " ");
			(void)printf("%s\n", t->list[coloff]);
		}
	}
	free(tbl);
	free(lens);
	free(cols);
d217 1
a217 1
#define	MAXLINELEN	(LINE_MAX + 1)
d222 71
a292 9
	static size_t maxentry = DEFNUM;
	int len;
	char *p, buf[MAXLINELEN];

	if (!list)
		list = ecalloc(maxentry, sizeof(char *));
	while (fgets(buf, MAXLINELEN, fp)) {
		for (p = buf; isspace((unsigned char)*p); ++p);
		if (!*p)
d294 3
a296 9
		if (!(p = strchr(p, '\n'))) {
			warnx("line too long");
			eval = 1;
			continue;
		}
		*p = '\0';
		len = p - buf;
		if (maxlength < len)
			maxlength = len;
d298 2
d301 1
a301 2
			list = ereallocarray(list, maxentry, sizeof(char *));
			memset(list + entries, 0, DEFNUM * sizeof(char *));
d303 6
a308 2
		if (!(list[entries++] = strdup(buf)))
			err(1, NULL);
d313 1
a313 1
ereallocarray(void *oldp, size_t sz1, size_t sz2)
d315 1
a315 3
	void *p;

	if (!(p = reallocarray(oldp, sz1, sz2)))
d317 1
a317 1
	return (p);
d321 1
a321 1
ecalloc(size_t sz1, size_t sz2)
d323 1
a323 1
	void *p;
d325 1
a325 1
	if (!(p = calloc(sz1, sz2)))
d327 1
a327 1
	return (p);
d330 1
a330 1
void
a332 1

@


1.22
log
@Blank line before pledge().
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.21 2015/10/09 01:37:07 deraadt Exp $	*/
d53 1
a53 1
int termwidth = 80;		/* default terminal width */
d70 5
a74 7
	if (ioctl(1, TIOCGWINSZ, &win) == -1 || !win.ws_col) {
		if ((p = getenv("COLUMNS")) && *p != '\0') {
			termwidth = strtonum(p, 1, INT_MAX, &errstr);
			if (errstr != NULL)
				errx(1, "%s: %s", errstr, p);
		}
	} else
d76 2
@


1.21
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.20 2015/10/05 13:30:30 deraadt Exp $	*/
d119 1
@


1.20
log
@tame "stdio rpath" or tame "stdio" suffices for all of these programs.
fairly easy to audit by running nm and noticing nothing beyond base
stdio except for fopen/freopen.  Then review all callpaths to those
functions, and place the tame() calls.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.19 2014/05/22 19:50:34 millert Exp $	*/
d79 2
a80 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
d119 2
a120 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.19
log
@If we have to realloc() "list" we need to zero out the new entries
to match the behavior of the initial calloc().  The "cols" array
does not actually need to be zeroed so use reallocarray() instead
of calloc().  Also fix a memory leak of tbl and initialize the value
of maxcols/maxentry in the assignment instead of in the ecalloc()
call.  OK espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.18 2014/05/17 20:05:07 espie Exp $	*/
d79 3
d106 1
a106 1
	if (!*argv)
d108 9
a116 7
	else for (; *argv; ++argv)
		if ((fp = fopen(*argv, "r"))) {
			input(fp);
			(void)fclose(fp);
		} else {
			warn("%s", *argv);
			eval = 1;
d118 3
@


1.18
log
@fix alloc idioms. watch out for emalloc that's actually a calloc in disguise
okay chl@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.17 2014/01/22 09:39:38 jsg Exp $	*/
d209 1
a209 1
	int *lens, maxcols;
d214 1
a214 1
	cols = ecalloc((maxcols = DEFCOLS), sizeof(char *));
d246 1
d257 1
a257 1
	static size_t maxentry;
d262 1
a262 1
		list = ecalloc((maxentry = DEFNUM), sizeof(char *));
d279 1
@


1.17
log
@fix leaks
ok krw@@ deraadt@@ benno@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.16 2013/11/26 13:18:55 deraadt Exp $	*/
d45 2
a46 2
void *emalloc(size_t);
void *erealloc(void *, size_t);
d213 3
a215 3
	t = tbl = emalloc(entries * sizeof(TBL));
	cols = emalloc((maxcols = DEFCOLS) * sizeof(char *));
	lens = emalloc(maxcols * sizeof(int));
d221 4
a224 2
				cols = erealloc(cols, maxcols * sizeof(char *));
				lens = erealloc(lens, maxcols * sizeof(int));
d229 2
a230 2
		t->list = emalloc(coloff * sizeof(char *));
		t->len = emalloc(coloff * sizeof(int));
d261 1
a261 1
		list = emalloc((maxentry = DEFNUM) * sizeof(char *));
d277 1
a277 1
			list = erealloc(list, maxentry * sizeof(char *));
d285 1
a285 1
emalloc(size_t size)
d289 1
a289 1
	if (!(p = malloc(size)))
a290 1
	memset(p, 0, size);
d295 1
a295 1
erealloc(void *oldp, size_t size)
d299 1
a299 1
	if (!(p = realloc(oldp, size)))
@


1.16
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.15 2009/10/27 23:59:36 deraadt Exp $	*/
d244 2
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.14 2007/08/01 13:30:21 millert Exp $	*/
d259 1
a259 1
		for (p = buf; isspace(*p); ++p);
@


1.14
log
@Refactor realloc() + checks into erealloc()
Fix a NULL dereference when the -t flag is given and a line
consists solely of delimiters.  OK deraadt@@, fixes PR 5555
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.13 2007/05/01 01:26:23 jdixon Exp $	*/
a31 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)column.c	8.4 (Berkeley) 5/4/95";
#endif
static char rcsid[] = "$OpenBSD: column.c,v 1.13 2007/05/01 01:26:23 jdixon Exp $";
#endif /* not lint */
@


1.13
log
@use strtonum; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.12 2007/03/20 03:50:39 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: column.c,v 1.12 2007/03/20 03:50:39 tedu Exp $";
d59 1
d222 1
a222 1
	int *lens, *lens2, maxcols;
d224 1
a224 1
	char **cols, **cols2;
a232 9
				if (!(cols2 = realloc(cols, (u_int)maxcols +
				    DEFCOLS * sizeof(char *))) ||
				    !(lens2 = realloc(lens,
				    (u_int)maxcols + DEFCOLS * sizeof(int))))
					err(1, NULL);
				cols = cols2;
				lens = lens2;
				memset(lens + maxcols, 0,
				    DEFCOLS * sizeof(int));
d234 3
d238 2
d250 6
a255 4
		for (coloff = 0; coloff < t->cols  - 1; ++coloff)
			(void)printf("%s%*s", t->list[coloff],
			    lens[coloff] - t->len[coloff] + 2, " ");
		(void)printf("%s\n", t->list[coloff]);
d285 2
a286 7
			char **nlist;	
			size_t nsize = maxentry + DEFNUM;

			if (!(nlist = realloc(list, nsize * sizeof(char *))))
				err(1, NULL);
			list = nlist;
			maxentry = nsize;
d301 10
@


1.12
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.11 2006/03/10 19:14:58 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: column.c,v 1.11 2006/03/10 19:14:58 otto Exp $";
d80 1
d83 5
a87 2
		if ((p = getenv("COLUMNS")))
			termwidth = atoi(p);
d95 3
a97 1
			termwidth = atoi(optarg);
@


1.11
log
@realloc & size_t police; simplify some pointer arithmetic; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.10 2003/09/26 22:24:09 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: column.c,v 1.10 2003/09/26 22:24:09 tedu Exp $";
d267 1
a267 1
		for (p = buf; *p && isspace(*p); ++p);
@


1.10
log
@better realloc.  ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.9 2003/06/10 22:20:45 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: column.c,v 1.9 2003/06/10 22:20:45 deraadt Exp $";
d58 1
a58 1
void *emalloc(int);
d233 2
a234 2
				memset((char *)lens + maxcols * sizeof(int),
				    0, DEFCOLS * sizeof(int));
d260 1
a260 1
	static int maxentry;
d280 4
a283 3
			maxentry += DEFNUM;
			if (!(list = realloc(list,
			    (u_int)maxentry * sizeof(char *))))
d285 2
d288 2
a289 1
		list[entries++] = strdup(buf);
d294 1
a294 1
emalloc(int size)
d296 1
a296 1
	char *p;
@


1.9
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.8 2003/06/03 02:56:07 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: column.c,v 1.8 2003/06/03 02:56:07 millert Exp $";
d215 1
a215 1
	int *lens, maxcols;
d217 1
a217 1
	char **cols;
d226 1
a226 1
				if (!(cols = realloc(cols, (u_int)maxcols +
d228 1
a228 1
				    !(lens = realloc(lens,
d231 2
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.7 2002/02/16 21:27:45 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: column.c,v 1.7 2002/02/16 21:27:45 millert Exp $";
d74 1
a74 3
main(argc, argv)
	int argc;
	char **argv;
d136 1
a136 1
c_columnate()
d165 1
a165 1
r_columnate()
d194 1
a194 1
print()
d210 1
a210 1
maketbl()
d256 1
a256 2
input(fp)
	FILE *fp;
d288 1
a288 2
emalloc(size)
	int size;
d299 1
a299 1
usage()
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.6 2001/07/12 05:16:59 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: column.c,v 1.6 2001/07/12 05:16:59 deraadt Exp $";
@


1.6
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.5 1999/12/09 00:48:03 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: column.c,v 1.5 1999/12/09 00:48:03 millert Exp $";
d61 7
a67 7
void  c_columnate __P((void));
void *emalloc __P((int));
void  input __P((FILE *));
void  maketbl __P((void));
void  print __P((void));
void  r_columnate __P((void));
void  usage __P((void));
@


1.5
log
@Avoid divide by zero, spotted by aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.4 1997/06/30 11:46:21 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: column.c,v 1.4 1997/06/30 11:46:21 deraadt Exp $";
d88 1
a88 1
		if (p = getenv("COLUMNS"))
d118 1
a118 1
		if (fp = fopen(*argv, "r")) {
d159 1
a159 1
			while ((cnt = (chcnt + TAB & ~(TAB - 1))) <= endcol) {
d189 1
a189 1
			while ((cnt = (chcnt + TAB & ~(TAB - 1))) <= endcol) {
d229 1
a229 1
		for (coloff = 0, p = *lp; cols[coloff] = strtok(p, separator);
@


1.4
log
@repair usage; charnier@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.3 1997/01/15 23:42:21 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: column.c,v 1.3 1997/01/15 23:42:21 millert Exp $";
d177 2
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.2 1996/06/26 05:32:16 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: column.c,v 1.2 1996/06/26 05:32:16 deraadt Exp $";
d309 1
a309 1
	    "usage: column [-tx] [-c columns] [file ...]\n");
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: column.c,v 1.4 1995/09/02 05:53:03 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: column.c,v 1.4 1995/09/02 05:53:03 jtc Exp $";
d94 1
a94 1
	while ((ch = getopt(argc, argv, "c:s:tx")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: column.c,v 1.4 1995/09/02 05:53:03 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
