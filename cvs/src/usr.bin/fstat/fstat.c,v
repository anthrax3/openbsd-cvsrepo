head	1.90;
access;
symbols
	OPENBSD_6_1:1.90.0.2
	OPENBSD_6_1_BASE:1.90
	OPENBSD_6_0:1.88.0.2
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.80.0.6
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.80.0.2
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.77.0.4
	OPENBSD_5_6_BASE:1.77
	OPENBSD_5_5:1.76.0.4
	OPENBSD_5_5_BASE:1.76
	OPENBSD_5_4:1.75.0.2
	OPENBSD_5_4_BASE:1.75
	OPENBSD_5_3:1.73.0.2
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.72.0.4
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.2
	OPENBSD_5_0:1.71.0.2
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.70.0.6
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.70.0.4
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.70.0.2
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.67.0.4
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.61.0.2
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.58.0.2
	OPENBSD_4_2_BASE:1.58
	OPENBSD_4_1:1.57.0.4
	OPENBSD_4_1_BASE:1.57
	OPENBSD_4_0:1.57.0.2
	OPENBSD_4_0_BASE:1.57
	OPENBSD_3_9:1.55.0.2
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.52.0.2
	OPENBSD_3_8_BASE:1.52
	OPENBSD_3_7:1.50.0.2
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.49.0.4
	OPENBSD_3_6_BASE:1.49
	OPENBSD_3_5:1.49.0.2
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	OPENBSD_3_3:1.41.0.4
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.41.0.2
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.36.0.2
	OPENBSD_3_1_BASE:1.36
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.4
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.90
date	2017.01.21.12.21.57;	author deraadt;	state Exp;
branches;
next	1.89;
commitid	YkRvCySDf8eOWybK;

1.89
date	2016.10.02.23.16.08;	author guenther;	state Exp;
branches;
next	1.88;
commitid	vh3VI9XDCXDPAZOO;

1.88
date	2016.05.04.19.48.08;	author jca;	state Exp;
branches;
next	1.87;
commitid	pjrI8Uv5D3MXA8k7;

1.87
date	2016.04.25.19.18.41;	author tedu;	state Exp;
branches;
next	1.86;
commitid	gkGRXuaZYSQDVf3h;

1.86
date	2016.01.02.13.22.52;	author semarie;	state Exp;
branches;
next	1.85;
commitid	2NTW7dG0Mb3RGXcw;

1.85
date	2015.12.30.19.02.12;	author mestre;	state Exp;
branches;
next	1.84;
commitid	4zOVkvTUER3LMIT9;

1.84
date	2015.11.17.17.17.24;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	u14e7GciC0XG0i2j;

1.83
date	2015.10.23.13.21.10;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	I005waiPphRZIu6m;

1.82
date	2015.10.12.14.09.32;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	Jln42izJnr25ebyM;

1.81
date	2015.10.10.14.29.05;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	YB9TrWttzpjpWZYt;

1.80
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	Uu5nFG3wCl0LACBb;

1.79
date	2014.08.20.11.23.42;	author mikeb;	state Exp;
branches;
next	1.78;
commitid	vzc4wz1s3pDevb7K;

1.78
date	2014.08.10.07.29.45;	author guenther;	state Exp;
branches;
next	1.77;
commitid	kZ5JqTJL53sFPxYj;

1.77
date	2014.05.30.07.14.46;	author guenther;	state Exp;
branches;
next	1.76;

1.76
date	2013.10.22.16.40.27;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2013.03.31.01.42.28;	author bluhm;	state Exp;
branches;
next	1.74;

1.74
date	2013.03.24.15.09.13;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2012.11.30.14.40.03;	author mikeb;	state Exp;
branches;
next	1.72;

1.72
date	2012.01.07.05.38.12;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2011.07.09.00.45.40;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2009.07.12.21.33.30;	author nicm;	state Exp;
branches;
next	1.68;

1.68
date	2009.07.08.16.04.00;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2009.06.15.04.19.59;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.11.21.09.46;	author chl;	state Exp;
branches;
next	1.65;

1.65
date	2009.06.07.03.10.09;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.03.14.45.55;	author jj;	state Exp;
branches;
next	1.63;

1.63
date	2009.05.31.19.31.23;	author thib;	state Exp;
branches;
next	1.62;

1.62
date	2008.10.07.02.20.12;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2008.04.08.14.46.45;	author thib;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.01.22.06.02;	author sobrado;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.02.15.19.32;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.07.23.20.19;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.19.22.31.20;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.26.17.47.11;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.54;

1.54
date	2005.12.17.13.56.02;	author pedro;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.13.22.21.02;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.04.01.54.09;	author djm;	state Exp;
branches;
next	1.51;

1.51
date	2005.05.26.05.15.56;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2004.11.17.01.47.20;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.08.19.28.56;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.09.04.46.44;	author jmc;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.02.21.04.10;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.28.16.49.44;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.25.21.19.19;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.10.22.20.46;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.13.01.41.48;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2002.08.04.00.48.34;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.13.06.02.57;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.12.06.07.15;	author mpech;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.19.22.01.15;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.18.17.54.15;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.14.06.51.41;	author mpech;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.01.18.59.59;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.26.01.37.16;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.12.05.17.06;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.22.22.43.20;	author pvalchev;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.12.00.15.11;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.16.23.40.48;	author hugh;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.30.16.00.14;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.17.16.26.19;	author itojun;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	99.10.29.14.06.16;	author art;	state Exp;
branches;
next	1.24;

1.24
date	99.07.02.19.23.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.07.01.21.41.58;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.04.30.02.26.59;	author art;	state Exp;
branches;
next	1.21;

1.21
date	98.11.30.10.19.02;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.09.08.20.49.33;	author art;	state Exp;
branches;
next	1.19;

1.19
date	98.09.07.01.04.13;	author art;	state Exp;
branches;
next	1.18;

1.18
date	98.09.06.22.48.46;	author art;	state Exp;
branches;
next	1.17;

1.17
date	98.07.09.20.28.00;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	98.07.08.22.14.12;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.07.05.18.42.41;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.06.25.06.21.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.12.06.21.19.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.08.25.22.27.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.08.00.33.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.06.05.07.46.55;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.05.30.12.27.50;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.01.15.23.42.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.12.22.03.25.52;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.08.17.09.10.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.12.19.45.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.06.18.05.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.05.19.04.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.32.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.16;	author deraadt;	state Exp;
branches;
next	;

1.26.2.1
date	2000.10.06.19.59.49;	author jason;	state Exp;
branches;
next	;


desc
@@


1.90
log
@Expose the close-on-exec flag near the R/W flags.
ok guenther
@
text
@/*	$OpenBSD: fstat.c,v 1.89 2016/10/02 23:16:08 guenther Exp $	*/

/*
 * Copyright (c) 2009 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/vnode.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/eventvar.h>
#include <sys/sysctl.h>
#include <sys/filedesc.h>
#define _KERNEL /* for DTYPE_* */
#include <sys/file.h>
#undef _KERNEL

#include <net/route.h>
#include <netinet/in.h>

#include <netdb.h>
#include <arpa/inet.h>

#include <sys/pipe.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <kvm.h>
#include <limits.h>
#include <nlist.h>
#include <pwd.h>
#include <search.h>
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <err.h>

#include "fstat.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

struct fileargs fileargs = SLIST_HEAD_INITIALIZER(fileargs);

int	fsflg;	/* show files on same filesystem as file(s) argument */
int	pflg;	/* show files open by a particular pid */
int	uflg;	/* show files open by a particular (effective) user */
int	checkfile; /* true if restricting to particular files or filesystems */
int	nflg;	/* (numerical) display f.s. and rdev as dev_t */
int	oflg;	/* display file offset */
int	sflg;	/* display file xfer/bytes counters */
int	vflg;	/* display errors in locating kernel data objects etc... */
int	cflg; 	/* fuser only */

int	fuser;	/* 1 if we are fuser, 0 if we are fstat */
int	signo;	/* signal to send (fuser only) */

kvm_t *kd;
uid_t uid;

void fstat_dofile(struct kinfo_file *);
void fstat_header(void);
void getinetproto(int);
__dead void usage(void);
int getfname(char *);
void kqueuetrans(struct kinfo_file *);
void pipetrans(struct kinfo_file *);
struct kinfo_file *splice_find(char, u_int64_t);
void splice_insert(char, u_int64_t, struct kinfo_file *);
void find_splices(struct kinfo_file *, int);
void print_inet_details(struct kinfo_file *);
void print_inet6_details(struct kinfo_file *);
void print_sock_details(struct kinfo_file *);
void socktrans(struct kinfo_file *);
void vtrans(struct kinfo_file *);
const char *inet6_addrstr(struct in6_addr *);
int signame_to_signum(char *);
void hide(void *p);

int hideroot;

void
hide(void *p)
{
	printf("%p", hideroot ? NULL : p);
}

int
main(int argc, char *argv[])
{
	struct passwd *passwd;
	struct kinfo_file *kf, *kflast;
	int arg, ch, what;
	char *memf, *nlistf, *optstr;
	char buf[_POSIX2_LINE_MAX];
	const char *errstr;
	int cnt, flags;

	hideroot = getuid();

	arg = -1;
	what = KERN_FILE_BYPID;
	nlistf = memf = NULL;
	oflg = 0;

	/* are we fstat(1) or fuser(1)? */
	if (strcmp(__progname, "fuser") == 0) {
		fuser = 1;
		optstr = "cfks:uM:N:";
	} else {
		fuser = 0;
		optstr = "fnop:su:vN:M:";
	}

	/*
	 * fuser and fstat share three flags: -f, -s and -u.  In both cases
	 * -f is a boolean, but for -u fstat wants an argument while fuser
	 * does not and for -s fuser wants an argument whereas fstat does not.
	 */
	while ((ch = getopt(argc, argv, optstr)) != -1)
		switch ((char)ch) {
		case 'c':
			if (fsflg)
				usage();
			cflg = 1;
			break;
		case 'f':
			if (cflg)
				usage();
			fsflg = 1;
			break;
		case 'k':
			sflg = 1;
			signo = SIGKILL;
			break;
		case 'M':
			memf = optarg;
			break;
		case 'N':
			nlistf = optarg;
			break;
		case 'n':
			nflg = 1;
			break;
		case 'o':
			oflg = 1;
			break;
		case 'p':
			if (pflg++)
				usage();
			arg = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL) {
				warnx("-p requires a process id, %s: %s",
					errstr, optarg);
				usage();
			}
			what = KERN_FILE_BYPID;
			break;
		case 's':
			sflg = 1;
			if (fuser) {
				signo = signame_to_signum(optarg);
				if (signo == -1) {
					warnx("invalid signal %s", optarg);
					usage();
				}
			}
			break;
		case 'u':
			if (uflg++)
				usage();
			if (!fuser) {
				if (!(passwd = getpwnam(optarg))) {
					arg = strtonum(optarg, 0, UID_MAX,
					    &errstr);
					if (errstr != NULL) {
						errx(1, "%s: unknown uid",
						    optarg);
					}
				} else
					arg = passwd->pw_uid;
				what = KERN_FILE_BYUID;
			}
			break;
		case 'v':
			vflg = 1;
			break;
		default:
			usage();
		}

	/*
	 * get the uid, for oflg and sflg
	 */
	uid = getuid();

	/*
	 * Use sysctl unless inspecting an alternate kernel.
	 */
	if (nlistf == NULL || memf == NULL)
		flags = KVM_NO_FILES;
	else
		flags = O_RDONLY;

	if ((kd = kvm_openfiles(nlistf, memf, NULL, flags, buf)) == NULL)
		errx(1, "%s", buf);

	if (*(argv += optind)) {
		for (; *argv; ++argv) {
			if (getfname(*argv))
				checkfile = 1;
		}
		/* file(s) specified, but none accessible */
		if (!checkfile)
			exit(1);
	} else if (fuser)
		usage();

	if (!fuser && fsflg && !checkfile) {
		/* fstat -f with no files means use wd */
		if (getfname(".") == 0)
			exit(1);
		checkfile = 1;
	}

	if ((kf = kvm_getfiles(kd, what, arg, sizeof(*kf), &cnt)) == NULL)
		errx(1, "%s", kvm_geterr(kd));

	if (fuser) {
		/*
		 * fuser
		 *  uflg: need "getpw"
		 *  sflg: need "proc" (might call kill(2))
		 */
		if (uflg && sflg) {
			if (pledge("stdio rpath getpw proc", NULL) == -1)
				err(1, "pledge");
		} else if (uflg) {
			if (pledge("stdio rpath getpw", NULL) == -1)
				err(1, "pledge");
		} else if (sflg) {
			if (pledge("stdio rpath proc", NULL) == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio rpath", NULL) == -1)
				err(1, "pledge");
		}
	} else {
		/* fstat */
		if (pledge("stdio rpath getpw", NULL) == -1)
			err(1, "pledge");
	}

	find_splices(kf, cnt);
	if (!fuser)
		fstat_header();
	for (kflast = &kf[cnt]; kf < kflast; ++kf) {
		if (fuser)
			fuser_check(kf);
		else
			fstat_dofile(kf);
	}
	if (fuser)
		fuser_run();

	exit(0);
}

void
fstat_header(void)
{
	if (nflg)
		printf("%s",
"USER     CMD          PID   FD  DEV      INUM       MODE   R/W    SZ|DV");
	else
		printf("%s",
"USER     CMD          PID   FD MOUNT        INUM MODE         R/W    SZ|DV");
	if (oflg)
		printf("%s", ":OFFSET  ");
	if (checkfile && fsflg == 0)
		printf(" NAME");
	if (sflg)
		printf("    XFERS   KBYTES");
	putchar('\n');
}

char	*Uname, *Comm;
uid_t	*procuid;
pid_t	Pid;

#define PREFIX(i) do { \
	printf("%-8.8s %-10s %5ld", Uname, Comm, (long)Pid); \
	switch (i) { \
	case KERN_FILE_TEXT: \
		printf(" text"); \
		break; \
	case KERN_FILE_CDIR: \
		printf("   wd"); \
		break; \
	case KERN_FILE_RDIR: \
		printf(" root"); \
		break; \
	case KERN_FILE_TRACE: \
		printf("   tr"); \
		break; \
	default: \
		printf(" %4d", i); \
		break; \
	} \
} while (0)

/*
 * print open files attributed to this process
 */
void
fstat_dofile(struct kinfo_file *kf)
{

	Uname = user_from_uid(kf->p_uid, 0);
	procuid = &kf->p_uid;
	Pid = kf->p_pid;
	Comm = kf->p_comm;

	switch (kf->f_type) {
	case DTYPE_VNODE:
		vtrans(kf);
		break;
	case DTYPE_SOCKET:
		if (checkfile == 0)
			socktrans(kf);
		break;
	case DTYPE_PIPE:
		if (checkfile == 0)
			pipetrans(kf);
		break;
	case DTYPE_KQUEUE:
		if (checkfile == 0)
			kqueuetrans(kf);
		break;
	default:
		if (vflg) {
			warnx("unknown file type %d for file %d of pid %ld",
			    kf->f_type, kf->fd_fd, (long)Pid);
		}
		break;
	}
}

void
vtrans(struct kinfo_file *kf)
{
	const char *badtype = NULL;
	char rwep[5], mode[12];
	char *filename = NULL;

	if (kf->v_type == VNON)
		badtype = "none";
	else if (kf->v_type == VBAD)
		badtype = "bad";
	else if (kf->v_tag == VT_NON && !(kf->v_flag & VCLONE))
		badtype = "none";	/* not a clone */

	if (checkfile) {
		int fsmatch = 0;
		struct filearg *fa;

		if (badtype)
			return;
		SLIST_FOREACH(fa, &fileargs, next) {
			if (fa->dev == kf->va_fsid) {
				fsmatch = 1;
				if (fa->ino == kf->va_fileid) {
					filename = fa->name;
					break;
				}
			}
		}
		if (fsmatch == 0 || (filename == NULL && fsflg == 0))
			return;
	}
	PREFIX(kf->fd_fd);
	if (badtype) {
		(void)printf(" -           -  %10s    -\n", badtype);
		return;
	}

	if (nflg)
		(void)printf(" %2ld,%-2ld", (long)major(kf->va_fsid),
		    (long)minor(kf->va_fsid));
	else if (!(kf->v_flag & VCLONE))
		(void)printf(" %-8s", kf->f_mntonname);
	else
		(void)printf(" clone   ");
	if (nflg)
		(void)snprintf(mode, sizeof(mode), "%o", kf->va_mode);
	else
		strmode(kf->va_mode, mode);
	printf(" %8llu%s %11s", kf->va_fileid,
	    kf->va_nlink == 0 ? "*" : " ",
	    mode);
	rwep[0] = '\0';
	if (kf->f_flag & FREAD)
		strlcat(rwep, "r", sizeof rwep);
	if (kf->f_flag & FWRITE)
		strlcat(rwep, "w", sizeof rwep);
	if (kf->fd_ofileflags & UF_EXCLOSE)
		strlcat(rwep, "e", sizeof rwep);
	printf(" %4s", rwep);
	switch (kf->v_type) {
	case VBLK:
	case VCHR: {
		char *name;

		if (nflg || ((name = devname(kf->va_rdev,
		    kf->v_type == VCHR ?  S_IFCHR : S_IFBLK)) == NULL))
			printf("   %2d,%-3d", major(kf->va_rdev), minor(kf->va_rdev));
		else
			printf("  %7s", name);
		if (oflg)
			printf("         ");
		break;
	}
	default:
		printf(" %8llu", kf->va_size);
		if (oflg) {
			if (uid == 0 || uid == *procuid)
				printf(":%-8llu", kf->f_offset);
			else
				printf(":%-8s", "*");
		}
	}
	if (sflg) {
		if (uid == 0 || uid == *procuid) {
			printf(" %8llu %8llu",
			    (kf->f_rxfer + kf->f_rwfer),
			    (kf->f_rbytes + kf->f_wbytes) / 1024);
		} else {
			printf(" %8s %8s", "*", "*");
		}
	}
	if (filename && !fsflg)
		printf(" %s", filename);
	putchar('\n');
}

void
pipetrans(struct kinfo_file *kf)
{
	void *maxaddr;

	PREFIX(kf->fd_fd);

	printf(" ");

	/*
	 * We don't have enough space to fit both peer and own address, so
	 * we select the higher address so both ends of the pipe have the
	 * same visible addr. (it's the higher address because when the other
	 * end closes, it becomes 0)
	 */
	maxaddr = (void *)(uintptr_t)MAXIMUM(kf->f_data, kf->pipe_peer);

	printf("pipe ");
	hide(maxaddr);
	printf(" state: %s%s%s",
	    (kf->pipe_state & PIPE_WANTR) ? "R" : "",
	    (kf->pipe_state & PIPE_WANTW) ? "W" : "",
	    (kf->pipe_state & PIPE_EOF) ? "E" : "");
	if (sflg)
		printf("\t%8llu %8llu",
		    (kf->f_rxfer + kf->f_rwfer),
		    (kf->f_rbytes + kf->f_wbytes) / 1024);
	printf("\n");
	return;
}

void
kqueuetrans(struct kinfo_file *kf)
{
	PREFIX(kf->fd_fd);

	printf(" ");

	printf("kqueue ");
	hide((void *)(uintptr_t)kf->f_data);
	printf(" %d state: %s%s\n",
	    kf->kq_count,
	    (kf->kq_state & KQ_SEL) ? "S" : "",
	    (kf->kq_state & KQ_SLEEP) ? "W" : "");
	return;
}

const char *
inet6_addrstr(struct in6_addr *p)
{
	struct sockaddr_in6 sin6;
	static char hbuf[NI_MAXHOST];
	const int niflags = NI_NUMERICHOST;

	memset(&sin6, 0, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_addr = *p;
	if (IN6_IS_ADDR_LINKLOCAL(p) &&
	    *(u_int16_t *)&sin6.sin6_addr.s6_addr[2] != 0) {
		sin6.sin6_scope_id =
		    ntohs(*(u_int16_t *)&sin6.sin6_addr.s6_addr[2]);
		sin6.sin6_addr.s6_addr[2] = sin6.sin6_addr.s6_addr[3] = 0;
	}

	if (getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
	    hbuf, sizeof(hbuf), NULL, 0, niflags))
		return "invalid";

	return hbuf;
}

void
splice_insert(char type, u_int64_t ptr, struct kinfo_file *data)
{
	ENTRY entry, *found;

	if (asprintf(&entry.key, "%c%llx", type, hideroot ? 0 : ptr) == -1)
		err(1, NULL);
	entry.data = data;
	if ((found = hsearch(entry, ENTER)) == NULL)
		err(1, "hsearch");
	/* if it's ambiguous, set the data to NULL */
	if (found->data != data)
		found->data = NULL;
}

struct kinfo_file *
splice_find(char type, u_int64_t ptr)
{
	ENTRY entry, *found;
	char buf[20];

	snprintf(buf, sizeof(buf), "%c%llx", type, hideroot ? 0 : ptr);
	entry.key = buf;
	found = hsearch(entry, FIND);
	return (found != NULL ? found->data : NULL);
}

void
find_splices(struct kinfo_file *kf, int cnt)
{
	int i, created;

	created = 0;
	for (i = 0; i < cnt; i++) {
		if (kf[i].f_type != DTYPE_SOCKET ||
		    (kf[i].so_splice == 0 && kf[i].so_splicelen != -1))
			continue;
		if (created++ == 0) {
			if (hcreate(1000) == 0)
				err(1, "hcreate");
		}
		splice_insert('>', kf[i].f_data, &kf[i]);
		if (kf[i].so_splice != 0)
			splice_insert('<', kf[i].so_splice, &kf[i]);
	}
}

void
print_inet_details(struct kinfo_file *kf)
{
	struct in_addr laddr, faddr;

	memcpy(&laddr, kf->inp_laddru, sizeof(laddr));
	memcpy(&faddr, kf->inp_faddru, sizeof(faddr));
	if (kf->so_protocol == IPPROTO_TCP) {
		printf(" ");
		hide((void *)(uintptr_t)kf->inp_ppcb);
		printf(" %s:%d", laddr.s_addr == INADDR_ANY ? "*" :
		    inet_ntoa(laddr), ntohs(kf->inp_lport));
		if (kf->inp_fport) {
			if (kf->so_state & SS_CONNECTOUT)
				printf(" --> ");
			else
				printf(" <-- ");
			printf("%s:%d",
			    faddr.s_addr == INADDR_ANY ? "*" :
			    inet_ntoa(faddr), ntohs(kf->inp_fport));
		}
	} else if (kf->so_protocol == IPPROTO_UDP) {
		printf(" %s:%d", laddr.s_addr == INADDR_ANY ? "*" :
		    inet_ntoa(laddr), ntohs(kf->inp_lport));
		if (kf->inp_fport) {
			printf(" <-> %s:%d",
			    faddr.s_addr == INADDR_ANY ? "*" :
			    inet_ntoa(faddr), ntohs(kf->inp_fport));
		}
	} else if (kf->so_pcb) {
		printf(" ");
		hide((void *)(uintptr_t)kf->so_pcb);
	}
}

void
print_inet6_details(struct kinfo_file *kf)
{
	char xaddrbuf[NI_MAXHOST + 2];
	struct in6_addr laddr6, faddr6;

	memcpy(&laddr6, kf->inp_laddru, sizeof(laddr6));
	memcpy(&faddr6, kf->inp_faddru, sizeof(faddr6));
	if (kf->so_protocol == IPPROTO_TCP) {
		printf(" ");
		hide((void *)(uintptr_t)kf->inp_ppcb);
		snprintf(xaddrbuf, sizeof(xaddrbuf), "[%s]",
		    inet6_addrstr(&laddr6));
		printf(" %s:%d",
		    IN6_IS_ADDR_UNSPECIFIED(&laddr6) ? "*" :
		    xaddrbuf, ntohs(kf->inp_lport));
		if (kf->inp_fport) {
			if (kf->so_state & SS_CONNECTOUT)
				printf(" --> ");
			else
				printf(" <-- ");
			snprintf(xaddrbuf, sizeof(xaddrbuf), "[%s]",
			    inet6_addrstr(&faddr6));
			printf("%s:%d",
			    IN6_IS_ADDR_UNSPECIFIED(&faddr6) ? "*" :
			    xaddrbuf, ntohs(kf->inp_fport));
		}
	} else if (kf->so_protocol == IPPROTO_UDP) {
		snprintf(xaddrbuf, sizeof(xaddrbuf), "[%s]",
		    inet6_addrstr(&laddr6));
		printf(" %s:%d",
		    IN6_IS_ADDR_UNSPECIFIED(&laddr6) ? "*" :
		    xaddrbuf, ntohs(kf->inp_lport));
		if (kf->inp_fport) {
			snprintf(xaddrbuf, sizeof(xaddrbuf), "[%s]",
			    inet6_addrstr(&faddr6));
			printf(" <-> %s:%d",
			    IN6_IS_ADDR_UNSPECIFIED(&faddr6) ? "*" :
			    xaddrbuf, ntohs(kf->inp_fport));
		}
	} else if (kf->so_pcb) {
		printf(" ");
		hide((void *)(uintptr_t)kf->so_pcb);
	}
}

void
print_sock_details(struct kinfo_file *kf)
{
	if (kf->so_family == AF_INET)
		print_inet_details(kf);
	else if (kf->so_family == AF_INET6)
		print_inet6_details(kf);
}

void
socktrans(struct kinfo_file *kf)
{
	static char *stypename[] = {
		"unused",	/* 0 */
		"stream",	/* 1 */
		"dgram",	/* 2 */
		"raw",		/* 3 */
		"rdm",		/* 4 */
		"seqpak"	/* 5 */
	};
#define	STYPEMAX 5
	char *stype, stypebuf[24];

	PREFIX(kf->fd_fd);

	if (kf->so_type > STYPEMAX) {
		snprintf(stypebuf, sizeof(stypebuf), "?%d", kf->so_type);
		stype = stypebuf;
	} else {
		stype = stypename[kf->so_type];
	}

	/*
	 * protocol specific formatting
	 *
	 * Try to find interesting things to print.  For tcp, the interesting
	 * thing is the address of the tcpcb, for udp and others, just the
	 * inpcb (socket pcb).  For unix domain, its the address of the socket
	 * pcb and the address of the connected pcb (if connected).  Otherwise
	 * just print the protocol number and address of the socket itself.
	 * The idea is not to duplicate netstat, but to make available enough
	 * information for further analysis.
	 */
	switch (kf->so_family) {
	case AF_INET:
		printf("* internet %s", stype);
		getinetproto(kf->so_protocol);
		print_inet_details(kf);
		break;
	case AF_INET6:
		printf("* internet6 %s", stype);
		getinetproto(kf->so_protocol);
		print_inet6_details(kf);
		break;
	case AF_UNIX:
		/* print address of pcb and connected pcb */
		printf("* unix %s", stype);
		if (kf->so_pcb) {
			printf(" ");
			hide((void *)(uintptr_t)kf->so_pcb);
			if (kf->unp_conn) {
				char shoconn[4], *cp;

				cp = shoconn;
				if (!(kf->so_state & SS_CANTRCVMORE))
					*cp++ = '<';
				*cp++ = '-';
				if (!(kf->so_state & SS_CANTSENDMORE))
					*cp++ = '>';
				*cp = '\0';
				printf(" %s ", shoconn);
				hide((void *)(uintptr_t)kf->unp_conn);
			}
		}
		break;
	case AF_MPLS:
		/* print protocol number and socket address */
		printf("* mpls %s", stype);
		printf(" %d ", kf->so_protocol);
		hide((void *)(uintptr_t)kf->f_data);
		break;
	case AF_ROUTE:
		/* print protocol number and socket address */
		printf("* route %s", stype);
		printf(" %d ", kf->so_protocol);
		hide((void *)(uintptr_t)kf->f_data);
		break;
	default:
		/* print protocol number and socket address */
		printf("* %d %s", kf->so_family, stype);
		printf(" %d ", kf->so_protocol);
		hide((void *)(uintptr_t)kf->f_data);
	}
	if (kf->so_splice != 0 || kf->so_splicelen == -1) {
		struct kinfo_file *from, *to;

		from = splice_find('<', kf->f_data);
		to = NULL;
		if (kf->so_splice != 0)
			to = splice_find('>', kf->so_splice);

		if (to != NULL && from == to) {
			printf(" <==>");
			print_sock_details(to);
		} else if (kf->so_splice != 0) {
			printf(" ==>");
			if (to != NULL)
				print_sock_details(to);
		} else if (kf->so_splicelen == -1) {
			printf(" <==");
			if (from != NULL)
				print_sock_details(from);
		}
	}
	if (sflg)
		printf("\t%8llu %8llu",
		    (kf->f_rxfer + kf->f_rwfer),
		    (kf->f_rbytes + kf->f_wbytes) / 1024);
	printf("\n");
}

/*
 * getinetproto --
 *	print name of protocol number
 */
void
getinetproto(int number)
{
	static int isopen;
	struct protoent *pe;

	if (!isopen)
		setprotoent(++isopen);
	if ((pe = getprotobynumber(number)) != NULL)
		printf(" %s", pe->p_name);
	else
		printf(" %d", number);
}

int
getfname(char *filename)
{
	static struct statfs *mntbuf;
	static int nmounts;
	int i;
	struct stat sb;
	struct filearg *cur;

	if (stat(filename, &sb)) {
		warn("%s", filename);
		return (0);
	}

	/*
	 * POSIX specifies "For block special devices, all processes using any
	 * file on that device are listed".  However the -f flag description
	 * states "The report shall be only for the named files", so we only
	 * look up a block device if the -f flag has not be specified.
	 */
	if (fuser && !fsflg && S_ISBLK(sb.st_mode)) {
		if (mntbuf == NULL) {
			nmounts = getmntinfo(&mntbuf, MNT_NOWAIT);
			if (nmounts == -1)
				err(1, "getmntinfo");
		}
		for (i = 0; i < nmounts; i++) {
			if (!strcmp(mntbuf[i].f_mntfromname, filename)) {
				if (stat(mntbuf[i].f_mntonname, &sb) == -1) {
					warn("%s", filename);
					return (0);
				}
				cflg = 1;
				break;
			}
		}
	}

	if ((cur = malloc(sizeof(*cur))) == NULL)
		err(1, NULL);

	cur->ino = sb.st_ino;
	cur->dev = sb.st_dev & 0xffff;
	cur->name = filename;
	TAILQ_INIT(&cur->fusers);
	SLIST_INSERT_HEAD(&fileargs, cur, next);
	return (1);
}

int
signame_to_signum(char *sig)
{
	int n;
	const char *errstr = NULL;

	if (isdigit((unsigned char)*sig)) {
		n = strtonum(sig, 0, NSIG - 1, &errstr);
		return (errstr ? -1 : n);
	}
	if (!strncasecmp(sig, "sig", 3))
		sig += 3;
	for (n = 1; n < NSIG; n++) {
		if (!strcasecmp(sys_signame[n], sig))
			return (n);
	}
	return (-1);
}

void
usage(void)
{
	if (fuser) {
		fprintf(stderr, "usage: fuser [-cfku] [-M core] "
		    "[-N system] [-s signal] file ...\n");
	} else {
		fprintf(stderr, "usage: fstat [-fnosv] [-M core] [-N system] "
		    "[-p pid] [-u user] [file ...]\n");
	}
	exit(1);
}
@


1.89
log
@Indicate with an asterisk when a file has been unlinked.

from Sebastien Marie
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.88 2016/05/04 19:48:08 jca Exp $	*/
d57 1
d321 1
a321 1
"USER     CMD          PID   FD  DEV      INUM       MODE R/W    SZ|DV");
d324 1
a324 1
"USER     CMD          PID   FD MOUNT        INUM MODE       R/W    SZ|DV");
d400 1
a400 1
	char rw[3], mode[12];
d448 1
a448 1
	rw[0] = '\0';
d450 1
a450 1
		strlcat(rw, "r", sizeof rw);
d452 4
a455 2
		strlcat(rw, "w", sizeof rw);
	printf(" %2s", rw);
@


1.88
log
@Kill #ifdef INET6 occurrences in userland.

Prompted by and ok millert@@

(tcpdump and libpcap left untouched, the #ifdef force is too strong with
those)
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.87 2016/04/25 19:18:41 tedu Exp $	*/
d444 3
a446 1
	printf(" %8llu %11s", kf->va_fileid, mode);
@


1.87
log
@remove systrace support
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.86 2016/01/02 13:22:52 semarie Exp $	*/
a117 1
#ifdef INET6
a118 1
#endif
a534 1
#ifdef INET6
a558 1
#endif
a641 1
#ifdef INET6
a686 1
#endif
a692 1
#ifdef INET6
a694 1
#endif
a736 1
#ifdef INET6
a741 1
#endif
@


1.86
log
@fixes fuser(1) when invoking with -u: it requires "getpw" promise.

problem reported by Michael Reed m.reed at mykolab dot com.

ok tb@@ and benno@@ (which as provided near the same diff, but 5min later :p)
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.85 2015/12/30 19:02:12 mestre Exp $	*/
a122 1
void systracetrans(struct kinfo_file *);
a387 4
	case DTYPE_SYSTRACE:
		if (checkfile == 0)
			systracetrans(kf);
		break;
a533 13
	return;
}

void
systracetrans(struct kinfo_file *kf)
{
	PREFIX(kf->fd_fd);

	printf(" ");

	printf("systrace ");
	hide((void *)(uintptr_t)kf->f_data);
	printf(" npol %d\n", kf->str_npolicies);
@


1.85
log
@Declare usage() as __dead, and while here align a few variables to the rest of
the list and also ANSI one function. No functional change.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.84 2015/11/17 17:17:24 deraadt Exp $	*/
d279 12
a290 1
		if (sflg) { /* fuser might call kill(2) */
d298 1
@


1.84
log
@Missing "getpw" pledges, these were unnoticed because nobody expects
a user_from_uid(3) call...
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.83 2015/10/23 13:21:10 deraadt Exp $	*/
d99 1
a99 1
int 	cflg; 	/* fuser only */
d101 2
a102 2
int 	fuser;	/* 1 if we are fuser, 0 if we are fstat */
int 	signo;	/* signal to send (fuser only) */
d110 1
a110 1
void usage(void);
d830 1
a830 2
getinetproto(number)
	int number;
@


1.83
log
@getnameinfo() no longer needs pledge "route".  this drops to
pledge "stdio rpath".
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.82 2015/10/12 14:09:32 deraadt Exp $	*/
d287 1
a287 1
		if (pledge("stdio rpath", NULL) == -1)
@


1.82
log
@in fuser mode with -k or -s mode, kill(2) might be called and
route lookups won't be needed; so expand the pledge setup to handle
3 codepaths.
from theo buehler
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.81 2015/10/10 14:29:05 deraadt Exp $	*/
d287 1
a287 1
		if (pledge("stdio rpath route", NULL) == -1)
@


1.81
log
@pledge "stdio rpath route" seems to be working.  route is needed for
pretty printing some addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.80 2015/01/16 06:40:08 deraadt Exp $	*/
d278 12
a289 2
	if (pledge("stdio rpath route", NULL) == -1)
		err(1, "pledge");
@


1.80
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.79 2014/08/20 11:23:42 mikeb Exp $	*/
d277 3
@


1.79
log
@Remove userland bits related to the crypto(4) interface;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.78 2014/08/10 07:29:45 guenther Exp $	*/
d48 1
a48 1
#include <sys/param.h>
d87 2
d485 1
a485 1
	maxaddr = (void *)(uintptr_t)MAX(kf->f_data, kf->pipe_peer);
@


1.78
log
@Don't need to know how to format bluetooth socket info here
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.77 2014/05/30 07:14:46 guenther Exp $	*/
a109 1
void cryptotrans(struct kinfo_file *);
a361 4
	case DTYPE_CRYPTO:
		if (checkfile == 0)
			cryptotrans(kf);
		break;
a512 12
}

void
cryptotrans(struct kinfo_file *kf)
{
	PREFIX(kf->fd_fd);

	printf(" ");

	printf("crypto ");
	hide((void *)(uintptr_t)kf->f_data);
	printf("\n");
@


1.77
log
@AF_NATM support was removed before 5.5
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.76 2013/10/22 16:40:27 guenther Exp $	*/
a789 6
		printf(" %d ", kf->so_protocol);
		hide((void *)(uintptr_t)kf->f_data);
		break;
	case AF_BLUETOOTH:
		/* print protocol number and socket address */
		printf("* bluetooth %s", stype);
@


1.76
log
@- add UNIX-domain socket info to struct kinfo_file2
- convert netstat from kvm_getfiles() to kvm_getfile2() using that
- delete kvm_getfiles() and KERN_FILE as no longer used (bump libkvm's major)
- rename kvm_getfile2() to kvm_getfiles(), kinfo_file2 to kinfo_file
  and KERN_FILE2 to KERN_FILE.

ok deraadt@@, millert@@
ports scan sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.75 2013/03/31 01:42:28 bluhm Exp $	*/
a795 6
		printf(" %d ", kf->so_protocol);
		hide((void *)(uintptr_t)kf->f_data);
		break;
	case AF_NATM:
		/* print protocol number and socket address */
		printf("* natm %s", stype);
@


1.75
log
@A space got lost in fstat state output, put it back.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.74 2013/03/24 15:09:13 deraadt Exp $	*/
d105 1
a105 1
void fstat_dofile(struct kinfo_file2 *);
d110 7
a116 7
void cryptotrans(struct kinfo_file2 *);
void kqueuetrans(struct kinfo_file2 *);
void pipetrans(struct kinfo_file2 *);
struct kinfo_file2 *splice_find(char, u_int64_t);
void splice_insert(char, u_int64_t, struct kinfo_file2 *);
void find_splices(struct kinfo_file2 *, int);
void print_inet_details(struct kinfo_file2 *);
d118 1
a118 1
void print_inet6_details(struct kinfo_file2 *);
d120 4
a123 4
void print_sock_details(struct kinfo_file2 *);
void socktrans(struct kinfo_file2 *);
void systracetrans(struct kinfo_file2 *);
void vtrans(struct kinfo_file2 *);
d140 1
a140 1
	struct kinfo_file2 *kf, *kflast;
d274 1
a274 1
	if ((kf = kvm_getfile2(kd, what, arg, sizeof(*kf), &cnt)) == NULL)
d339 1
a339 1
fstat_dofile(struct kinfo_file2 *kf)
d381 1
a381 1
vtrans(struct kinfo_file2 *kf)
d474 1
a474 1
pipetrans(struct kinfo_file2 *kf)
d505 1
a505 1
kqueuetrans(struct kinfo_file2 *kf)
d521 1
a521 1
cryptotrans(struct kinfo_file2 *kf)
d533 1
a533 1
systracetrans(struct kinfo_file2 *kf)
d573 1
a573 1
splice_insert(char type, u_int64_t ptr, struct kinfo_file2 *data)
d587 1
a587 1
struct kinfo_file2 *
d600 1
a600 1
find_splices(struct kinfo_file2 *kf, int cnt)
d620 1
a620 1
print_inet_details(struct kinfo_file2 *kf)
d656 1
a656 1
print_inet6_details(struct kinfo_file2 *kf)
d703 1
a703 1
print_sock_details(struct kinfo_file2 *kf)
d714 1
a714 1
socktrans(struct kinfo_file2 *kf)
d812 1
a812 1
		struct kinfo_file2 *from, *to;
@


1.74
log
@Do not leak kernel pointers, unless operating as root.  Some other display
functionality is lost, but one can argue that privacy was being violated
there...
ok various, including bluhm and guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.73 2012/11/30 14:40:03 mikeb Exp $	*/
d492 1
a492 1
	printf("state: %s%s%s",
@


1.73
log
@makes cloned devices line up well with the rest of the output;
ok guenther, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.72 2012/01/07 05:38:12 guenther Exp $	*/
d126 9
d147 2
d201 1
a201 1
				warnx("-p requires a process id, %s: %s", 
d222 1
a222 1
					arg = strtonum(optarg, 0, UID_MAX, 
d455 1
a455 1
			else 
d462 2
a463 2
		    	(kf->f_rxfer + kf->f_rwfer),
		    	(kf->f_rbytes + kf->f_wbytes) / 1024);
d490 3
a492 1
	printf("pipe %p state: %s%s%s", maxaddr,
d511 3
a513 1
	printf("kqueue %p %d state: %s%s\n", (void *)(uintptr_t)kf->f_data,
d527 3
a529 1
	printf("crypto %p\n", (void *)(uintptr_t)kf->f_data);
d539 3
a541 2
	printf("systrace %p npol %d\n", (void *)(uintptr_t)kf->f_data,
	    kf->str_npolicies);
d577 1
a577 1
	if (asprintf(&entry.key, "%c%llx", type, ptr) == -1)
d593 1
a593 1
	snprintf(buf, sizeof(buf), "%c%llx", type, ptr);
d627 2
a628 1
		printf(" %p", (void *)(uintptr_t)kf->inp_ppcb);
d648 4
a651 2
	} else if (kf->so_pcb)
		printf(" %p", (void *)(uintptr_t)kf->so_pcb);
d664 2
a665 1
		printf(" %p", (void *)(uintptr_t)kf->inp_ppcb);
d695 4
a698 2
	} else if (kf->so_pcb)
		printf(" %p", (void *)(uintptr_t)kf->so_pcb);
d764 2
a765 1
			printf(" %p", (void *)(uintptr_t)kf->so_pcb);
d776 2
a777 2
				printf(" %s %p", shoconn,
				    (void *)(uintptr_t)kf->unp_conn);
d784 2
a785 2
		printf(" %d %p", kf->so_protocol,
		    (void *)(uintptr_t)kf->f_data);
d790 2
a791 2
		printf(" %d %p", kf->so_protocol,
		    (void *)(uintptr_t)kf->f_data);
d796 2
a797 2
		printf(" %d %p", kf->so_protocol,
		    (void *)(uintptr_t)kf->f_data);
d802 2
a803 2
		printf(" %d %p", kf->so_protocol,
		    (void *)(uintptr_t)kf->f_data);
d808 2
a809 2
		printf(" %d %p", kf->so_protocol,
		    (void *)(uintptr_t)kf->f_data);
@


1.72
log
@Add rtable id and thread id to struct kinfo_proc (and fix process id)
and add an 'rtableid' keyword to ps.

Add rtable id, thread id, and socket splice info to struct kinfo_file2
and make fstat display socket splice information.

Remove old KVM_PROC2 and kinfo_proc2 interfaces; bump libkvm major

Socket splice info and corrections from bluhm@@  "Lovely" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.71 2011/07/09 00:45:40 henning Exp $	*/
d413 1
a413 1
		(void)printf(" clone");
@


1.71
log
@rmove rotten netatalk bits
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.70 2009/10/27 23:59:38 deraadt Exp $	*/
d76 1
a106 1
void fuser_dofile(struct kinfo_file2 *);
d113 8
d266 1
d555 135
a701 5
	struct in_addr laddr, faddr;
#ifdef INET6
	char xaddrbuf[NI_MAXHOST + 2];
	struct in6_addr laddr6, faddr6;
#endif
a725 2
		memcpy(&laddr, kf->inp_laddru, sizeof(laddr));
		memcpy(&faddr, kf->inp_faddru, sizeof(faddr));
d727 1
a727 23
		if (kf->so_protocol == IPPROTO_TCP) {
			printf(" %p", (void *)(uintptr_t)kf->inp_ppcb);
			printf(" %s:%d", laddr.s_addr == INADDR_ANY ? "*" :
			    inet_ntoa(laddr), ntohs(kf->inp_lport));
			if (kf->inp_fport) {
				if (kf->so_state & SS_CONNECTOUT)
					printf(" --> ");
				else
					printf(" <-- ");
				printf("%s:%d",
				    faddr.s_addr == INADDR_ANY ? "*" :
				    inet_ntoa(faddr), ntohs(kf->inp_fport));
			}
		} else if (kf->so_protocol == IPPROTO_UDP) {
			printf(" %s:%d", laddr.s_addr == INADDR_ANY ? "*" :
			    inet_ntoa(laddr), ntohs(kf->inp_lport));
			if (kf->inp_fport) {
				printf(" <-> %s:%d",
				    faddr.s_addr == INADDR_ANY ? "*" :
				    inet_ntoa(faddr), ntohs(kf->inp_fport));
			}
		} else if (kf->so_pcb)
			printf(" %p", (void *)(uintptr_t)kf->so_pcb);
a731 2
		memcpy(&laddr6, kf->inp_laddru, sizeof(laddr6));
		memcpy(&faddr6, kf->inp_faddru, sizeof(faddr6));
d733 1
a733 33
		if (kf->so_protocol == IPPROTO_TCP) {
			printf(" %p", (void *)(uintptr_t)kf->inp_ppcb);
			snprintf(xaddrbuf, sizeof(xaddrbuf), "[%s]",
			    inet6_addrstr(&laddr6));
			printf(" %s:%d",
			    IN6_IS_ADDR_UNSPECIFIED(&laddr6) ? "*" :
			    xaddrbuf, ntohs(kf->inp_lport));
			if (kf->inp_fport) {
				if (kf->so_state & SS_CONNECTOUT)
					printf(" --> ");
				else
					printf(" <-- ");
				snprintf(xaddrbuf, sizeof(xaddrbuf), "[%s]",
				    inet6_addrstr(&faddr6));
				printf("%s:%d",
				    IN6_IS_ADDR_UNSPECIFIED(&faddr6) ? "*" :
				    xaddrbuf, ntohs(kf->inp_fport));
			}
		} else if (kf->so_protocol == IPPROTO_UDP) {
			snprintf(xaddrbuf, sizeof(xaddrbuf), "[%s]",
			    inet6_addrstr(&laddr6));
			printf(" %s:%d",
			    IN6_IS_ADDR_UNSPECIFIED(&laddr6) ? "*" :
			    xaddrbuf, ntohs(kf->inp_lport));
			if (kf->inp_fport) {
				snprintf(xaddrbuf, sizeof(xaddrbuf), "[%s]",
				    inet6_addrstr(&faddr6));
				printf(" <-> %s:%d",
				    IN6_IS_ADDR_UNSPECIFIED(&faddr6) ? "*" :
				    xaddrbuf, ntohs(kf->inp_fport));
			}
		} else if (kf->so_pcb)
			printf(" %p", (void *)(uintptr_t)kf->so_pcb);
d785 21
@


1.70
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.69 2009/07/12 21:33:30 nicm Exp $	*/
a695 6
		printf(" %d %p", kf->so_protocol,
		    (void *)(uintptr_t)kf->f_data);
		break;
	case AF_APPLETALK:
		/* print protocol number and socket address */
		printf("* appletalk %s", stype);
@


1.69
log
@Accept numeric UIDs as well as usernames like pgrep etc.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.68 2009/07/08 16:04:00 millert Exp $	*/
a46 11

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static const char sccsid[] = "from: @@(#)fstat.c	8.1 (Berkeley) 6/6/93";*/
static const char rcsid[] = "$OpenBSD: fstat.c,v 1.68 2009/07/08 16:04:00 millert Exp $";
#endif /* not lint */
@


1.68
log
@Add POSIX-compliant fuser mode to fstat.  Originally based on
a diff from Peter Werner but largely rewritten to use kinfo_file2.
OK deraadt@@ with man fixes from jmc@@ and sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.67 2009/06/15 04:19:59 miod Exp $	*/
d56 1
a56 1
static const char rcsid[] = "$OpenBSD: fstat.c,v 1.67 2009/06/15 04:19:59 miod Exp $";
d213 9
a221 2
				if (!(passwd = getpwnam(optarg)))
					errx(1, "%s: unknown uid", optarg);
a222 1
				arg = passwd->pw_uid;
@


1.67
log
@Do not print non-vnode information if asked to report information on a
particular file, regression introduced in 1.66 and reported by Navan Carson
on misc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.66 2009/06/11 21:09:46 chl Exp $	*/
d49 1
a49 1
static char copyright[] =
d55 2
a56 2
/*static char sccsid[] = "from: @@(#)fstat.c	8.1 (Berkeley) 6/6/93";*/
static char *rcsid = "$OpenBSD: fstat.c,v 1.66 2009/06/11 21:09:46 chl Exp $";
d60 2
d87 1
d95 3
a97 7
typedef struct devs {
	struct	devs *next;
	long	fsid;
	ino_t	ino;
	char	*name;
} DEVS;
DEVS *devs;
d107 4
d115 3
a117 2

void dofiles(struct kinfo_file2 *);
d128 1
d136 1
a136 1
	char *memf, *nlistf;
d145 16
a160 1
	while ((ch = getopt(argc, argv, "fnop:su:vN:M:")) != -1)
d162 5
d168 2
d172 4
d201 7
d212 6
a217 4
			if (!(passwd = getpwnam(optarg)))
				errx(1, "%s: unknown uid", optarg);
			what = KERN_FILE_BYUID;
			arg = passwd->pw_uid;
d247 2
a248 1
		if (!checkfile)	/* file(s) specified, but none accessible */
d250 2
a251 1
	}
d253 2
a254 2
	if (fsflg && !checkfile) {
		/* -f with no files means use wd */
d262 18
a292 4

	for (kflast = &kf[cnt]; kf < kflast; ++kf)
		dofiles(kf);
	exit(0);
d324 1
a324 1
dofiles(struct kinfo_file2 *kf)
d381 1
a381 1
		DEVS *d;
d385 2
a386 2
		for (d = devs; d != NULL; d = d->next) {
			if (d->fsid == kf->va_fsid) {
d388 2
a389 2
				if (d->ino == kf->va_fileid) {
					filename = d->name;
d596 1
a596 1
			printf(" %p", kf->inp_ppcb);
d617 1
a617 1
			printf(" %p", kf->so_pcb);
d626 1
a626 1
			printf(" %p", kf->inp_ppcb);
d657 1
a657 1
			printf(" %p", kf->so_pcb);
d664 1
a664 1
			printf(" %p", kf->so_pcb);
d745 5
a749 2
	struct stat statbuf;
	DEVS *cur;
d751 1
a751 1
	if (stat(filename, &statbuf)) {
d753 1
a753 1
		return(0);
a754 4
	if ((cur = malloc(sizeof(DEVS))) == NULL)
		err(1, "malloc");
	cur->next = devs;
	devs = cur;
d756 29
a784 2
	cur->ino = statbuf.st_ino;
	cur->fsid = statbuf.st_dev & 0xffff;
d786 22
a807 1
	return(1);
d813 7
a819 2
	fprintf(stderr, "usage: fstat [-fnosv] [-M core] [-N system] "
	    "[-p pid] [-u user] [file ...]\n");
@


1.66
log
@remove unused variables

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.65 2009/06/07 03:10:09 millert Exp $	*/
d56 1
a56 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.65 2009/06/07 03:10:09 millert Exp $";
d281 2
a282 1
		socktrans(kf);
d285 2
a286 1
		pipetrans(kf);
d289 2
a290 1
		kqueuetrans(kf);
d293 2
a294 1
		cryptotrans(kf);
d297 2
a298 1
		systracetrans(kf);
@


1.65
log
@Use the new kvm_getfile2 interface to do the dirty work.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.64 2009/06/03 14:45:55 jj Exp $	*/
d56 1
a56 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.64 2009/06/03 14:45:55 jj Exp $";
d501 1
a501 2
	int len;
	char *dname, *stype, stypebuf[24];
@


1.64
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@d1 17
a17 1
/*	$OpenBSD: fstat.c,v 1.63 2009/05/31 19:31:23 thib Exp $	*/
d56 1
a56 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.63 2009/05/31 19:31:23 thib Exp $";
a59 3
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/user.h>
a63 3
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/event.h>
a64 1
#include <sys/unpcb.h>
d66 1
a66 5
#include <sys/filedesc.h>
#define	_KERNEL
#include <sys/mount.h>
#include <crypto/cryptodev.h>
#include <dev/systrace.h>
a67 2
#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
a68 9
#include <nfs/nfsproto.h>
#include <nfs/rpcv2.h>
#include <nfs/nfs.h>
#include <nfs/nfsnode.h>

#include <nnpfs/nnpfs_config.h>
#include <nnpfs/nnpfs_node.h>

#include <miscfs/specfs/specdev.h>
a71 8
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif
d80 1
a83 1
#include <paths.h>
d86 1
a89 1
#include <netdb.h>
a90 6
#include "fstat.h"

#define	TEXT	-1
#define	CDIR	-2
#define	RDIR	-3
#define	TRACE	-4
a108 17
struct file **ofiles;	/* buffer of pointers to file structures */
int maxfiles;
#define ALLOC_OFILES(d)	\
	if ((d) > maxfiles) { \
		free(ofiles); \
		ofiles = calloc((d), sizeof(struct file *)); \
		if (ofiles == NULL) \
			err(1, "malloc"); \
		maxfiles = (d); \
	}

/*
 * a kvm_read that returns true if everything is read
 */
#define KVM_READ(kaddr, paddr, len) \
	(kvm_read(kd, (u_long)(kaddr), (void *)(paddr), (len)) == (len))

d112 2
a113 8
int ufs_filestat(struct vnode *, struct filestat *);
int ext2fs_filestat(struct vnode *, struct filestat *);
int isofs_filestat(struct vnode *, struct filestat *);
int msdos_filestat(struct vnode *, struct filestat *);
int nfs_filestat(struct vnode *, struct filestat *);
int nnpfs_filestat(struct vnode *, struct filestat *);
int spec_filestat(struct vnode *, struct filestat *);
void dofiles(struct kinfo_proc2 *);
d117 6
a122 7
void socktrans(struct socket *, int, struct file *);
void vtrans(struct vnode *, int, int, struct file *);
void pipetrans(struct pipe *, int, struct file *);
void kqueuetrans(struct kqueue *, int, struct file *);
void cryptotrans(void *, int, struct file *);
void systracetrans(struct fsystrace *, int, struct file *);
char *getmnton(struct mount *);
a127 2
	extern char *optarg;
	extern int optind;
d129 1
a129 1
	struct kinfo_proc2 *p, *plast;
d134 1
a134 2
	int cnt;
	gid_t gid;
d136 2
a137 2
	arg = 0;
	what = KERN_PROC_ALL;
d166 1
a166 1
			what = KERN_PROC_PID;
d176 1
a176 1
			what = KERN_PROC_UID;
a188 1

d192 1
a192 2
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
d194 4
a197 4
	gid = getgid();
	if (nlistf != NULL || memf != NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");
d199 1
a199 1
	if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, buf)) == NULL)
a201 4
	if (nlistf == NULL && memf == NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

a210 2
	ALLOC_OFILES(256);	/* reserve space for file pointers */

d218 1
a218 1
	if ((p = kvm_getproc2(kd, what, arg, sizeof(*p), &cnt)) == NULL)
d234 2
a235 5
	for (plast = &p[cnt]; p < plast; ++p) {
		if (p->p_stat == SZOMB)
			continue;
		dofiles(p);
	}
d246 1
a246 1
	case TEXT: \
d249 1
a249 1
	case CDIR: \
d252 1
a252 1
	case RDIR: \
d255 1
a255 1
	case TRACE: \
d268 1
a268 1
dofiles(struct kinfo_proc2 *kp)
a269 9
	int i;
	struct file file;
	struct filedesc0 filed0;
#define	filed	filed0.fd_fd

	Uname = user_from_uid(kp->p_uid, 0);
	procuid = &kp->p_uid;
	Pid = kp->p_pid;
	Comm = kp->p_comm;
d271 4
a274 22
	if (kp->p_fd == 0)
		return;
	if (!KVM_READ(kp->p_fd, &filed0, sizeof (filed0))) {
		dprintf("can't read filedesc at %p for pid %ld",
		    (void *)(u_long)kp->p_fd, (long)Pid);
		return;
	}
	if (filed.fd_nfiles < 0 || filed.fd_lastfile >= filed.fd_nfiles ||
	    filed.fd_freefile > filed.fd_lastfile + 1) {
		dprintf("filedesc corrupted at %p for pid %ld",
		    (void *)(u_long)kp->p_fd, (long)Pid);
		return;
	}
	/*
	 * root directory vnode, if one
	 */
	if (filed.fd_rdir)
		vtrans(filed.fd_rdir, RDIR, FREAD, NULL);
	/*
	 * current working directory vnode
	 */
	vtrans(filed.fd_cdir, CDIR, FREAD, NULL);
d276 23
a298 51
	/*
	 * ktrace vnode, if one
	 */
	if (kp->p_tracep)
		vtrans((struct vnode *)(u_long)kp->p_tracep, TRACE, FREAD|FWRITE, NULL);
	/*
	 * open files
	 */
#define FPSIZE	(sizeof (struct file *))
	ALLOC_OFILES(filed.fd_lastfile+1);
	if (filed.fd_nfiles > NDFILE) {
		if (!KVM_READ(filed.fd_ofiles, ofiles,
		    (filed.fd_lastfile+1) * FPSIZE)) {
			dprintf("can't read file structures at %p for pid %ld",
			    filed.fd_ofiles, (long)Pid);
			return;
		}
	} else
		bcopy(filed0.fd_dfiles, ofiles, (filed.fd_lastfile+1) * FPSIZE);
	for (i = 0; i <= filed.fd_lastfile; i++) {
		if (ofiles[i] == NULL)
			continue;
		if (!KVM_READ(ofiles[i], &file, sizeof (struct file))) {
			dprintf("can't read file %d at %p for pid %ld",
				i, ofiles[i], (long)Pid);
			continue;
		}
		if (file.f_type == DTYPE_VNODE)
			vtrans((struct vnode *)file.f_data, i, file.f_flag,
			    &file);
		else if (file.f_type == DTYPE_SOCKET) {
			if (checkfile == 0)
				socktrans((struct socket *)file.f_data, i,
				    &file);
		} else if (file.f_type == DTYPE_PIPE) {
			if (checkfile == 0)
				pipetrans((struct pipe *)file.f_data, i, &file);
		} else if (file.f_type == DTYPE_KQUEUE) {
			if (checkfile == 0)
				kqueuetrans((struct kqueue *)file.f_data, i,
				    &file);
		} else if (file.f_type == DTYPE_CRYPTO) {
			if (checkfile == 0)
				cryptotrans(file.f_data, i, &file);
		} else if (file.f_type == DTYPE_SYSTRACE) {
			if (checkfile == 0)
				systracetrans((struct fsystrace *)file.f_data,
				    i, &file);
		} else {
			dprintf("unknown file type %d for file %d of pid %ld",
				file.f_type, i, (long)Pid);
d300 1
d305 1
a305 1
vtrans(struct vnode *vp, int i, int flag, struct file *fp)
d307 5
a311 11
	struct vnode vn;
	struct filestat fst;
	char rw[3], mode[17];
	char *badtype = NULL, *filename;

	filename = badtype = NULL;
	if (!KVM_READ(vp, &vn, sizeof (struct vnode))) {
		dprintf("can't read vnode at %p for pid %ld", vp, (long)Pid);
		return;
	}
	if (vn.v_type == VNON)
d313 1
a313 1
	else if (vn.v_type == VBAD)
d315 3
a317 42
	else
		switch (vn.v_tag) {
		case VT_UFS:
		case VT_MFS:
			if (!ufs_filestat(&vn, &fst))
				badtype = "error";
			break;
		case VT_NFS:
			if (!nfs_filestat(&vn, &fst))
				badtype = "error";
			break;
		case VT_EXT2FS:
			if (!ext2fs_filestat(&vn, &fst))
				badtype = "error";
			break;
		case VT_ISOFS:
			if (!isofs_filestat(&vn, &fst))
				badtype = "error";
			break;
		case VT_MSDOSFS:
			if (!msdos_filestat(&vn, &fst))
				badtype = "error";
			break;
		case VT_NNPFS:
			if (!nnpfs_filestat(&vn, &fst))
				badtype = "error";
			break;
		case VT_NON:
			if (vn.v_flag & VCLONE) {
				if (!spec_filestat(&vn, &fst))
					badtype = "error";
			} else {
				badtype = "none";	/* not a clone */
			}
			break;
		default: {
			static char unknown[30];
			snprintf(badtype = unknown, sizeof unknown,
			    "?(%x)", vn.v_tag);
			break;
		}
	}
d324 2
a325 2
		for (d = devs; d != NULL; d = d->next)
			if (d->fsid == fst.fsid) {
d327 1
a327 1
				if (d->ino == fst.fileid) {
d332 1
d336 1
a336 1
	PREFIX(i);
d343 4
a346 4
		(void)printf(" %2ld,%-2ld", (long)major(fst.fsid),
		    (long)minor(fst.fsid));
	else if (!(vn.v_flag & VCLONE))
		(void)printf(" %-8s", getmnton(vn.v_mount));
d350 1
a350 1
		(void)snprintf(mode, sizeof mode, "%o", fst.mode);
d352 2
a353 2
		strmode(fst.mode, mode);
	(void)printf(" %8ld %11s", fst.fileid, mode);
d355 1
a355 1
	if (flag & FREAD)
d357 1
a357 1
	if (flag & FWRITE)
d360 1
a360 1
	switch (vn.v_type) {
d365 3
a367 3
		if (nflg || ((name = devname(fst.rdev, vn.v_type == VCHR ?
		    S_IFCHR : S_IFBLK)) == NULL))
			printf("   %2d,%-3d", major(fst.rdev), minor(fst.rdev));
d375 1
a375 1
		printf(" %8lld", (long long)fst.size);
d378 1
a378 1
				printf(":%-8lld", (long long)(fp? fp->f_offset : 0));
d385 3
a387 3
			printf(" %8lld %8lld",
		    	(long long)(fp? fp->f_rxfer + fp->f_wxfer : 0),
		    	(long long)(fp? fp->f_rbytes + fp->f_wbytes : 0) / 1024);
a396 200
int
ufs_filestat(struct vnode *vp, struct filestat *fsp)
{
	struct inode inode;
	struct ufs1_dinode di1;

	if (!KVM_READ(VTOI(vp), &inode, sizeof (inode))) {
		dprintf("can't read inode at %p for pid %ld",
		    VTOI(vp), (long)Pid);
		return 0;
	}

	if (!KVM_READ(inode.i_din1, &di1, sizeof(struct ufs1_dinode))) {
		dprintf("can't read dinode at %p for pid %ld",
		    inode.i_din1, (long)Pid);
		return (0);
	}

	inode.i_din1 = &di1;

	fsp->fsid = inode.i_dev & 0xffff;
	fsp->fileid = (long)inode.i_number;
	fsp->mode = inode.i_ffs1_mode;
	fsp->size = inode.i_ffs1_size;
	fsp->rdev = inode.i_ffs1_rdev;

	return 1;
}

int
ext2fs_filestat(struct vnode *vp, struct filestat *fsp)
{
	struct inode inode;
	struct ext2fs_dinode e2di;

	if (!KVM_READ(VTOI(vp), &inode, sizeof (inode))) {
		dprintf("can't read inode at %p for pid %ld",
		    VTOI(vp), (long)Pid);
		return 0;
	}

	if (!KVM_READ(inode.i_e2din, &e2di, sizeof(struct ext2fs_dinode))) {
		dprintf("can't read dinode at %p for pid %ld",
		    inode.i_e2din, (long)Pid);
		return (0);
	}

	inode.i_e2din = &e2di;

	fsp->fsid = inode.i_dev & 0xffff;
	fsp->fileid = (long)inode.i_number;
	fsp->mode = inode.i_e2fs_mode;
	fsp->size = inode.i_e2fs_size;
	fsp->rdev = 0;	/* XXX */

	return 1;
}

int
msdos_filestat(struct vnode *vp, struct filestat *fsp)
{
#if 0
	struct inode inode;

	if (!KVM_READ(VTOI(vp), &inode, sizeof (inode))) {
		dprintf("can't read inode at %p for pid %ld",
		    VTOI(vp), (long)Pid);
		return 0;
	}
	fsp->fsid = inode.i_dev & 0xffff;
	fsp->fileid = (long)inode.i_number;
	fsp->mode = inode.i_e2fs_mode;
	fsp->size = inode.i_e2fs_size;
	fsp->rdev = 0;	/* XXX */
#endif

	return 1;
}

int
nfs_filestat(struct vnode *vp, struct filestat *fsp)
{
	struct nfsnode nfsnode;
	mode_t mode;

	if (!KVM_READ(VTONFS(vp), &nfsnode, sizeof (nfsnode))) {
		dprintf("can't read nfsnode at %p for pid %ld",
		    VTONFS(vp), (long)Pid);
		return 0;
	}
	fsp->fsid = nfsnode.n_vattr.va_fsid;
	fsp->fileid = nfsnode.n_vattr.va_fileid;
	fsp->size = nfsnode.n_size;
	fsp->rdev = nfsnode.n_vattr.va_rdev;
	mode = (mode_t)nfsnode.n_vattr.va_mode;
	switch (vp->v_type) {
	case VREG:
		mode |= S_IFREG;
		break;
	case VDIR:
		mode |= S_IFDIR;
		break;
	case VBLK:
		mode |= S_IFBLK;
		break;
	case VCHR:
		mode |= S_IFCHR;
		break;
	case VLNK:
		mode |= S_IFLNK;
		break;
	case VSOCK:
		mode |= S_IFSOCK;
		break;
	case VFIFO:
		mode |= S_IFIFO;
		break;
	default:
		break;
	}
	fsp->mode = mode;

	return 1;
}

int
nnpfs_filestat(struct vnode *vp, struct filestat *fsp)
{
	struct nnpfs_node nnpfs_node;

	if (!KVM_READ(VNODE_TO_XNODE(vp), &nnpfs_node, sizeof (nnpfs_node))) {
		dprintf("can't read nnpfs_node at %p for pid %ld",
		    VTOI(vp), (long)Pid);
		return 0;
	}
	fsp->fsid = nnpfs_node.attr.va_fsid;
	fsp->fileid = (long)nnpfs_node.attr.va_fileid;
	fsp->mode = nnpfs_node.attr.va_mode;
	fsp->size = nnpfs_node.attr.va_size;
	fsp->rdev = nnpfs_node.attr.va_rdev;

	return 1;
}

int
spec_filestat(struct vnode *vp, struct filestat *fsp)
{
	struct specinfo		specinfo;
	struct vnode		parent;

	if (!KVM_READ(vp->v_specinfo, &specinfo, sizeof(struct specinfo))) {
		dprintf("can't read specinfo at %p for pid %ld",
		     vp->v_specinfo, (long) Pid);
		return (0);
	}

	vp->v_specinfo = &specinfo;

	if (!KVM_READ(vp->v_specparent, &parent, sizeof(struct vnode))) {
		dprintf("can't read parent vnode at %p for pid %ld",
		     vp->v_specparent, (long) Pid);
		return (0);
	}

	if (!ufs_filestat(&parent, fsp))
		return (0);

	if (nflg)
		fsp->rdev = vp->v_rdev;

	return (1);
}

char *
getmnton(struct mount *m)
{
	static struct mount mount;
	static struct mtab {
		struct mtab *next;
		struct mount *m;
		char mntonname[MNAMELEN];
	} *mhead = NULL;
	struct mtab *mt;

	for (mt = mhead; mt != NULL; mt = mt->next)
		if (m == mt->m)
			return (mt->mntonname);
	if (!KVM_READ(m, &mount, sizeof(struct mount))) {
		warn("can't read mount table at %p", m);
		return (NULL);
	}
	if ((mt = malloc(sizeof (struct mtab))) == NULL)
		err(1, "malloc");
	mt->m = m;
	bcopy(&mount.mnt_stat.f_mntonname[0], &mt->mntonname[0], MNAMELEN);
	mt->next = mhead;
	mhead = mt;
	return (mt->mntonname);
}

d398 1
a398 1
pipetrans(struct pipe *pipe, int i, struct file *fp)
a399 1
	struct pipe pi;
d402 1
a402 1
	PREFIX(i);
a405 6
	/* fill in socket */
	if (!KVM_READ(pipe, &pi, sizeof(struct pipe))) {
		dprintf("can't read pipe at %p", pipe);
		goto bad;
	}

d412 1
a412 1
	maxaddr = MAX(pipe, pi.pipe_peer);
d415 3
a417 3
	    (pi.pipe_state & PIPE_WANTR) ? "R" : "",
	    (pi.pipe_state & PIPE_WANTW) ? "W" : "",
	    (pi.pipe_state & PIPE_EOF) ? "E" : "");
d419 3
a421 3
		printf("\t%8lld %8lld",
		    (long long)(fp? fp->f_rxfer + fp->f_wxfer : 0),
		    (long long)(fp? fp->f_rbytes + fp->f_wbytes : 0) / 1024);
a423 2
bad:
	printf("* error\n");
d427 1
a427 1
kqueuetrans(struct kqueue *kq, int i, struct file *fp)
d429 1
a429 3
	struct kqueue kqi;

	PREFIX(i);
d433 4
a436 9
	/* fill it in */
	if (!KVM_READ(kq, &kqi, sizeof(struct kqueue))) {
		dprintf("can't read kqueue at %p", kq);
		goto bad;
	}

	printf("kqueue %p %d state: %s%s\n", kq, kqi.kq_count,
	    (kqi.kq_state & KQ_SEL) ? "S" : "",
	    (kqi.kq_state & KQ_SLEEP) ? "W" : "");
a437 2
bad:
	printf("* error\n");
d441 1
a441 1
cryptotrans(void *f, int i, struct file *fp)
d443 1
a443 1
	PREFIX(i);
d447 1
a447 1
	printf("crypto %p\n", f);
d451 1
a451 1
systracetrans(struct fsystrace *f, int i, struct file *fp)
d453 1
a453 3
	struct fsystrace fi;

	PREFIX(i);
d457 2
a458 7
	/* fill it in */
	if (!KVM_READ(f, &fi, sizeof(fi))) {
		dprintf("can't read fsystrace at %p", f);
		goto bad;
	}

	printf("systrace %p npol %d\n", f, fi.npolicies);
a459 2
bad:
	printf("* error\n");
d490 1
a490 1
socktrans(struct socket *sock, int i, struct file *fp)
a500 5
	struct socket	so;
	struct protosw	proto;
	struct domain	dom;
	struct inpcb	inpcb;
	struct unpcb	unpcb;
d502 2
a503 1
	char dname[32];
d506 1
d509 1
a509 1
	PREFIX(i);
d511 5
a515 4
	/* fill in socket */
	if (!KVM_READ(sock, &so, sizeof(struct socket))) {
		dprintf("can't read sock at %p", sock);
		goto bad;
a517 24
	/* fill in protosw entry */
	if (!KVM_READ(so.so_proto, &proto, sizeof(struct protosw))) {
		dprintf("can't read protosw at %p", so.so_proto);
		goto bad;
	}

	/* fill in domain */
	if (!KVM_READ(proto.pr_domain, &dom, sizeof(struct domain))) {
		dprintf("can't read domain at %p", proto.pr_domain);
		goto bad;
	}

	if ((len = kvm_read(kd, (u_long)dom.dom_name, dname,
	    sizeof(dname) - 1)) != sizeof(dname) -1) {
		dprintf("can't read domain name at %p", dom.dom_name);
		dname[0] = '\0';
	} else
		dname[len] = '\0';

	if ((u_short)so.so_type > STYPEMAX)
		printf("* %s ?%d", dname, so.so_type);
	else
		printf("* %s %s", dname, stypename[so.so_type]);

d529 1
a529 1
	switch (dom.dom_family) {
d531 10
a540 16
		getinetproto(proto.pr_protocol);
		if (proto.pr_protocol == IPPROTO_TCP) {
			if (so.so_pcb == NULL)
				break;
			if (kvm_read(kd, (u_long)so.so_pcb, (char *)&inpcb,
			    sizeof(struct inpcb)) != sizeof(struct inpcb)) {
				dprintf("can't read inpcb at %p", so.so_pcb);
				goto bad;
			}
			printf(" %p", inpcb.inp_ppcb);
			printf(" %s:%d",
			    inpcb.inp_laddr.s_addr == INADDR_ANY ? "*" :
			    inet_ntoa(inpcb.inp_laddr),
			    ntohs(inpcb.inp_lport));
			if (inpcb.inp_fport) {
				if (so.so_state & SS_CONNECTOUT)
d545 2
a546 3
				    inpcb.inp_faddr.s_addr == INADDR_ANY ? "*" :
				    inet_ntoa(inpcb.inp_faddr),
				    ntohs(inpcb.inp_fport));
d548 7
a554 7
		} else if (proto.pr_protocol == IPPROTO_UDP) {
			if (so.so_pcb == NULL)
				break;
			if (kvm_read(kd, (u_long)so.so_pcb, (char *)&inpcb,
			    sizeof(struct inpcb)) != sizeof(struct inpcb)) {
				dprintf("can't read inpcb at %p", so.so_pcb);
				goto bad;
d556 2
a557 11
			printf(" %s:%d",
			    inpcb.inp_laddr.s_addr == INADDR_ANY ? "*" :
			    inet_ntoa(inpcb.inp_laddr),
			    ntohs(inpcb.inp_lport));
			if (inpcb.inp_fport)
				printf(" <-> %s:%d",
				    inpcb.inp_faddr.s_addr == INADDR_ANY ? "*" :
				    inet_ntoa(inpcb.inp_faddr),
				    ntohs(inpcb.inp_fport));
		} else if (so.so_pcb)
			printf(" %p", so.so_pcb);
d561 6
a566 10
		getinetproto(proto.pr_protocol);
		if (proto.pr_protocol == IPPROTO_TCP) {
			if (so.so_pcb == NULL)
				break;
			if (kvm_read(kd, (u_long)so.so_pcb, (char *)&inpcb,
			    sizeof(struct inpcb)) != sizeof(struct inpcb)) {
				dprintf("can't read inpcb at %p", so.so_pcb);
				goto bad;
			}
			printf(" %p", inpcb.inp_ppcb);
d568 1
a568 1
			    inet6_addrstr(&inpcb.inp_laddr6));
d570 4
a573 5
			    IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_laddr6) ? "*" :
			    xaddrbuf,
			    ntohs(inpcb.inp_lport));
			if (inpcb.inp_fport) {
				if (so.so_state & SS_CONNECTOUT)
d578 1
a578 1
				    inet6_addrstr(&inpcb.inp_faddr6));
d580 2
a581 11
				    IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_faddr6) ? "*" :
				    xaddrbuf,
				    ntohs(inpcb.inp_fport));
			}
		} else if (proto.pr_protocol == IPPROTO_UDP) {
			if (so.so_pcb == NULL)
				break;
			if (kvm_read(kd, (u_long)so.so_pcb, (char *)&inpcb,
			    sizeof(struct inpcb)) != sizeof(struct inpcb)) {
				dprintf("can't read inpcb at %p", so.so_pcb);
				goto bad;
d583 1
d585 1
a585 1
			    inet6_addrstr(&inpcb.inp_laddr6));
d587 3
a589 4
			    IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_laddr6) ? "*" :
			    xaddrbuf,
			    ntohs(inpcb.inp_lport));
			if (inpcb.inp_fport) {
d591 1
a591 1
				    inet6_addrstr(&inpcb.inp_faddr6));
d593 2
a594 3
				    IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_faddr6) ? "*" :
				    xaddrbuf,
				    ntohs(inpcb.inp_fport));
d596 2
a597 2
		} else if (so.so_pcb)
			printf(" %p", so.so_pcb);
d602 4
a605 8
		if (so.so_pcb) {
			printf(" %p", so.so_pcb);
			if (kvm_read(kd, (u_long)so.so_pcb, (char *)&unpcb,
			    sizeof(struct unpcb)) != sizeof(struct unpcb)){
				dprintf("can't read unpcb at %p", so.so_pcb);
				goto bad;
			}
			if (unpcb.unp_conn) {
d609 1
a609 1
				if (!(so.so_state & SS_CANTRCVMORE))
d612 1
a612 1
				if (!(so.so_state & SS_CANTSENDMORE))
d616 1
a616 1
				    unpcb.unp_conn);
d620 30
d652 3
a654 1
		printf(" %d %p", proto.pr_protocol, sock);
d657 3
a659 3
		printf("\t%8lld %8lld",
		    (long long)(fp? fp->f_rxfer + fp->f_wxfer : 0),
		    (long long)(fp? fp->f_rbytes + fp->f_wbytes : 0) / 1024);
a660 3
	return;
bad:
	printf("* error\n");
@


1.63
log
@Don't define NFS before including kernel header files,
besides it being gnarly its useless since no magic is
done if it is define.

pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.61 2008/04/08 14:46:45 thib Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.61 2008/04/08 14:46:45 thib Exp $";
d71 2
a72 2
#include <xfs/xfs_config.h>
#include <xfs/xfs_node.h>
d154 1
a154 1
int xfs_filestat(struct vnode *, struct filestat *);
d456 2
a457 2
		case VT_XFS:
			if (!xfs_filestat(&vn, &fst))
d679 1
a679 1
xfs_filestat(struct vnode *vp, struct filestat *fsp)
d681 1
a681 1
	struct xfs_node xfs_node;
d683 2
a684 2
	if (!KVM_READ(VNODE_TO_XNODE(vp), &xfs_node, sizeof (xfs_node))) {
		dprintf("can't read xfs_node at %p for pid %ld",
d688 5
a692 5
	fsp->fsid = xfs_node.attr.va_fsid;
	fsp->fileid = (long)xfs_node.attr.va_fileid;
	fsp->mode = xfs_node.attr.va_mode;
	fsp->size = xfs_node.attr.va_size;
	fsp->rdev = xfs_node.attr.va_rdev;
@


1.62
log
@Do not display file offsets and a few other pieces of information, except
to the user or the superuser.  Display * for those fields instead.  From
PR 5113, but modified to use copyout correctly.
comments from tedu, ok from others
@
text
@a65 1
#define NFS
a69 1
#undef NFS
@


1.61
log
@bring cloning up too date; Munge it so it will work with atleast
oga@@'s upcoming DRM changes and too some degree ratchov@@'s audio
work. It still works for bpf's though.

Parts from ratchov@@; fstat(1) parts from Pedro Martelletto;
tested by many, ok'ed by a few;
"get going with cloning" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.60 2007/10/01 22:06:02 sobrado Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.60 2007/10/01 22:06:02 sobrado Exp $";
d149 1
d236 6
d300 1
d336 1
d534 15
a548 2
		if (oflg)
			printf(":%-8lld", (long long)(fp? fp->f_offset : 0));
a549 4
	if (sflg)
		printf(" %8lld %8lld",
		    (long long)(fp? fp->f_rxfer + fp->f_wxfer : 0),
		    (long long)(fp? fp->f_rbytes + fp->f_wbytes : 0) / 1024);
@


1.60
log
@sort the fields in manual page in the same order as in fstat output;
use the same name for fields in the manual page and command output;
while here, fix spacing

millert@@ has observed that this change makes the header fields consistent
with what is the output by NetBSD and FreeBSD too

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.59 2007/09/02 15:19:32 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.59 2007/09/02 15:19:32 deraadt Exp $";
d76 2
d156 1
d422 1
a422 1
	if (vn.v_type == VNON || vn.v_tag == VT_NON)
d453 8
d490 1
d494 2
d497 1
a497 1
		(void)printf(" %-8s", getmnton(vn.v_mount));
d679 29
@


1.59
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.58 2007/04/07 23:20:19 tedu Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.58 2007/04/07 23:20:19 tedu Exp $";
d186 1
a186 1
		switch((char)ch) {
d269 1
a269 1
"USER     CMD          PID   FD  DEV      INUM       MODE R/W    DV|SZ");
d272 1
a272 1
"USER     CMD          PID   FD MOUNT        INUM MODE       R/W    DV|SZ");
d294 1
a294 1
	switch(i) { \
d879 1
a879 1
	switch(dom.dom_family) {
@


1.58
log
@use strtonum, from jason dixon
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.57 2006/06/19 22:31:20 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.57 2006/06/19 22:31:20 deraadt Exp $";
d134 1
a134 1
		ofiles = malloc((d) * sizeof(struct file *)); \
@


1.57
log
@oops, forgot \n at end of kqueue lines; Nicholas Marriott
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.56 2006/03/26 17:47:11 mickey Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.56 2006/03/26 17:47:11 mickey Exp $";
d177 1
d205 4
a208 2
			if (!isdigit(*optarg)) {
				warnx( "-p requires a process id");
a211 1
			arg = atoi(optarg);
@


1.56
log
@do per file io accounting and show that in fstat as well; pedro@@ marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.55 2005/12/28 20:48:18 pedro Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.55 2005/12/28 20:48:18 pedro Exp $";
d745 1
a745 1
	printf("kqueue %p %d state: %s%s", kq, kqi.kq_count,
@


1.55
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.54 2005/12/17 13:56:02 pedro Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.54 2005/12/17 13:56:02 pedro Exp $";
d126 1
a155 1
void socktrans(struct socket *, int);
a156 1
void vtrans(struct vnode *, int, int, off_t);
d158 6
a163 4
void pipetrans(struct pipe *, int);
void kqueuetrans(struct kqueue *, int);
void cryptotrans(void *, int);
void systracetrans(struct fsystrace *, int);
d184 1
a184 1
	while ((ch = getopt(argc, argv, "fnop:u:vN:M:")) != -1)
d211 3
d274 4
a277 3
		printf(" NAME\n");
	else
		putchar('\n');
d343 1
a343 1
		vtrans(filed.fd_rdir, RDIR, FREAD, 0);
d347 2
a348 1
	vtrans(filed.fd_cdir, CDIR, FREAD, 0);
d353 1
a353 1
		vtrans((struct vnode *)(u_long)kp->p_tracep, TRACE, FREAD|FWRITE, 0);
d378 1
a378 1
			    file.f_offset);
d381 2
a382 1
				socktrans((struct socket *)file.f_data, i);
d385 1
a385 1
				pipetrans((struct pipe *)file.f_data, i);
d388 2
a389 1
				kqueuetrans((struct kqueue *)file.f_data, i);
d392 1
a392 1
				cryptotrans(file.f_data, i);
d395 2
a396 1
				systracetrans((struct fsystrace *)file.f_data, i);
d405 1
a405 1
vtrans(struct vnode *vp, int i, int flag, off_t offset)
d510 1
a510 1
			printf(":%-8lld", (long long)offset);
d512 4
d693 1
a693 1
pipetrans(struct pipe *pipe, int i)
d716 1
a716 1
	printf("pipe %p state: %s%s%s\n", maxaddr,
d720 5
d731 1
a731 1
kqueuetrans(struct kqueue *kq, int i)
d745 1
a745 1
	printf("kqueue %p %d state: %s%s\n", kq, kqi.kq_count,
d754 1
a754 1
cryptotrans(void *f, int i)
d764 1
a764 1
systracetrans(struct fsystrace *f, int i)
d812 1
a812 1
socktrans(struct socket *sock, int i)
d1007 4
d1060 1
a1060 1
	fprintf(stderr, "usage: fstat [-fnov] [-M core] [-N system] "
@


1.54
log
@Remove the 'on disk' inode (dinode) from the 'in memory' inode in UFS.
Instead of having the dinode inside the inode structure itself, we now
have just a pointer to it, and use a separate pool to allocate dinodes
as needed. Inspiration from FreeBSD, various testing for a while, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.53 2005/12/13 22:21:02 mickey Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.53 2005/12/13 22:21:02 mickey Exp $";
d530 3
a532 3
	fsp->mode = inode.i_ffs_mode;
	fsp->size = inode.i_ffs_size;
	fsp->rdev = inode.i_ffs_rdev;
@


1.53
log
@give inode 8 positions (new ver w/ missing spaces deraadt pt out); millert@@ krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.52 2005/07/04 01:54:09 djm Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.52 2005/07/04 01:54:09 djm Exp $";
d512 1
d519 9
d541 1
d548 9
@


1.52
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.51 2005/05/26 05:15:56 tedu Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.51 2005/05/26 05:15:56 tedu Exp $";
d263 1
a263 1
"USER     CMD          PID   FD  DEV    INUM       MODE R/W    DV|SZ");
d266 1
a266 1
"USER     CMD          PID   FD MOUNT      INUM MODE       R/W    DV|SZ");
d465 1
a465 1
		(void)printf(" -         -  %10s    -\n", badtype);
d477 1
a477 1
	(void)printf(" %6ld %11s", fst.fileid, mode);
@


1.51
log
@null removal fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.50 2004/11/17 01:47:20 itojun Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.50 2004/11/17 01:47:20 itojun Exp $";
d177 1
d229 4
a232 4
	if (nlistf != NULL || memf != NULL) {
		setegid(getgid());
		setgid(getgid());
	}
d237 3
a239 2
	setegid(getgid());
	setgid(getgid());
@


1.50
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.49 2004/01/08 19:28:56 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.49 2004/01/08 19:28:56 millert Exp $";
a64 1
#include <miscfs/nullfs/null.h>
a152 1
int null_filestat(struct vnode *, struct filestat *);
a436 4
		case VT_NULL:
			if (!null_filestat(&vn, &fst))
				badtype = "error";
			break;
a625 75

	return 1;
}

int
null_filestat(struct vnode *vp, struct filestat *fsp)
{
	struct null_node node;
	struct filestat fst;
	struct vnode vn;
	int fail = 1;

	memset(&fst, 0, sizeof fst);

	if (!KVM_READ(VTONULL(vp), &node, sizeof (node))) {
		dprintf("can't read node at %p for pid %ld",
		    VTONULL(vp), (long)Pid);
		return 0;
	}

	/*
	 * Attempt to find information that might be useful.
	 */
	if (node.null_lowervp) {
		if (!KVM_READ(node.null_lowervp, &vn, sizeof (vn))) {
			dprintf("can't read vnode at %p for pid %ld",
			    node.null_lowervp, (long)Pid);
			return 0;
		}

		fail = 0;
		if (vn.v_type == VNON || vn.v_tag == VT_NON)
			fail = 1;
		else if (vn.v_type == VBAD)
			fail = 1;
		else
			switch (vn.v_tag) {
			case VT_UFS:
			case VT_MFS:
				if (!ufs_filestat(&vn, &fst))
					fail = 1;
				break;
			case VT_NFS:
				if (!nfs_filestat(&vn, &fst))
					fail = 1;
				break;
			case VT_EXT2FS:
				if (!ext2fs_filestat(&vn, &fst))
					fail = 1;
				break;
			case VT_ISOFS:
				if (!isofs_filestat(&vn, &fst))
					fail = 1;
				break;
			case VT_MSDOSFS:
				if (!msdos_filestat(&vn, &fst))
					fail = 1;
				break;
			case VT_XFS:
				if (!xfs_filestat(&vn, &fst))
					fail = 1;
				break;
			default:
				break;
			}
	}

	fsp->fsid = (long)node.null_vnode;
	if (fail)
		fsp->fileid = (long)node.null_lowervp;
	else
		fsp->fileid = fst.fileid;
	fsp->mode = fst.mode;
	fsp->size = fst.mode;
	fsp->rdev = fst.mode;
@


1.49
log
@Convert to kvm_getproc2(); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.48 2003/09/09 04:46:44 jmc Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.48 2003/09/09 04:46:44 jmc Exp $";
d831 1
a831 5
#ifdef NI_WITHSCOPEID
	const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
	const int niflags = NI_NUMERICHOST
#endif
@


1.48
log
@add missing -o and sort options in usage();
from Andrey Matveev;
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.47 2003/07/02 21:04:10 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.47 2003/07/02 21:04:10 deraadt Exp $";
d155 1
a155 1
void dofiles(struct kinfo_proc *);
d174 1
a174 1
	struct kinfo_proc *p, *plast;
d259 1
a259 1
	if ((p = kvm_getprocs(kd, what, arg, &cnt)) == NULL)
d275 1
a275 1
		if (p->kp_proc.p_stat == SZOMB)
d310 1
a310 1
dofiles(struct kinfo_proc *kp)
a315 2
	struct proc *p = &kp->kp_proc;
	struct eproc *ep = &kp->kp_eproc;
d317 3
a319 3
	Uname = user_from_uid(ep->e_ucred.cr_uid, 0);
	Pid = p->p_pid;
	Comm = p->p_comm;
d321 1
a321 1
	if (p->p_fd == NULL)
d323 1
a323 1
	if (!KVM_READ(p->p_fd, &filed0, sizeof (filed0))) {
d325 1
a325 1
		    p->p_fd, (long)Pid);
d331 1
a331 1
		    p->p_fd, (long)Pid);
d346 2
a347 2
	if (p->p_tracep)
		vtrans(p->p_tracep, TRACE, FREAD|FWRITE, 0);
@


1.47
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.46 2003/06/28 16:49:44 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.46 2003/06/28 16:49:44 deraadt Exp $";
d1103 2
a1104 2
	fprintf(stderr, "usage: fstat [-fnv] [-p pid] [-u user] "
	    "[-N system] [-M core] [file ...]\n");
@


1.46
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.45 2003/06/25 21:19:19 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.45 2003/06/25 21:19:19 deraadt Exp $";
d163 4
a166 2
void cryptotrans(void *, int i);
void systracetrans(struct fsystrace *, int i);
d403 1
a403 1
	char *badtype = NULL, *filename, *getmnton(struct mount *);
@


1.45
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.44 2003/06/10 22:20:46 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.44 2003/06/10 22:20:46 deraadt Exp $";
d121 3
a123 3
int	fsflg,	/* show files on same filesystem as file(s) argument */
	pflg,	/* show files open by a particular pid */
	uflg;	/* show files open by a particular (effective) user */
@


1.44
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.43 2003/06/03 02:56:08 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.43 2003/06/03 02:56:08 millert Exp $";
a315 1
	extern char *user_from_uid();
d401 1
a401 1
	char *badtype = NULL, *filename, *getmnton();
@


1.43
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.42 2003/05/13 01:41:48 tedu Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.42 2003/05/13 01:41:48 tedu Exp $";
d619 1
a619 3
xfs_filestat(vp, fsp)
	struct vnode *vp;
	struct filestat *fsp;
@


1.42
log
@repair damage after layer fs changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.41 2002/08/04 00:48:34 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.41 2002/08/04 00:48:34 deraadt Exp $";
@


1.41
log
@move kvm opening to earliest possible place
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.40 2002/07/13 06:02:57 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.40 2002/07/13 06:02:57 deraadt Exp $";
d62 1
a63 1
#define	_KERNEL
@


1.40
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.39 2002/06/12 06:07:15 mpech Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.39 2002/06/12 06:07:15 mpech Exp $";
d228 15
a259 15

	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	if (nlistf != NULL || memf != NULL) {
		setegid(getgid());
		setgid(getgid());
	}

	if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, buf)) == NULL)
		errx(1, "%s", buf);

	setegid(getgid());
	setgid(getgid());
@


1.39
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.38 2002/05/19 22:01:15 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.38 2002/05/19 22:01:15 deraadt Exp $";
d171 1
a171 3
main(argc, argv)
	int argc;
	char **argv;
d312 1
a312 2
dofiles(kp)
	struct kinfo_proc *kp;
d401 1
a401 5
vtrans(vp, i, flag, offset)
	struct vnode *vp;
	int i;
	int flag;
	off_t offset;
d518 1
a518 3
ufs_filestat(vp, fsp)
	struct vnode *vp;
	struct filestat *fsp;
d537 1
a537 3
ext2fs_filestat(vp, fsp)
	struct vnode *vp;
	struct filestat *fsp;
d556 1
a556 3
msdos_filestat(vp, fsp)
	struct vnode *vp;
	struct filestat *fsp;
d577 1
a577 3
nfs_filestat(vp, fsp)
	struct vnode *vp;
	struct filestat *fsp;
d644 1
a644 3
null_filestat(vp, fsp)
	struct vnode *vp;
	struct filestat *fsp;
d719 1
a719 2
getmnton(m)
	struct mount *m;
d746 1
a746 3
pipetrans(pipe, i)
	struct pipe *pipe;
	int i;
d779 1
a779 3
kqueuetrans(kq, i)
	struct kqueue *kq;
	int i;
d802 1
a802 3
cryptotrans(f, i)
	void *f;
	int i;
a808 3
	return;
bad:
	printf("* error\n");
d812 1
a812 3
systracetrans(f, i)
	struct fsystrace *f;
	int i;
d834 1
a834 2
inet6_addrstr(p)
	struct in6_addr *p;
d864 1
a864 3
socktrans(sock, i)
	struct socket *sock;
	int i;
d1085 1
a1085 2
getfname(filename)
	char *filename;
d1106 1
a1106 1
usage()
@


1.38
log
@misc cleanups, and grok systrace better
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.37 2002/05/18 17:54:15 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.37 2002/05/18 17:54:15 deraadt Exp $";
d290 1
a290 1
	printf("%-8.8s %-10s %5d", Uname, Comm, Pid); \
d332 2
a333 1
		dprintf("can't read filedesc at %p for pid %d", p->p_fd, Pid);
d338 2
a339 1
		dprintf("filedesc corrupted at %p for pid %d", p->p_fd, Pid);
d364 2
a365 2
			dprintf("can't read file structures at %p for pid %d",
			    filed.fd_ofiles, Pid);
d374 2
a375 2
			dprintf("can't read file %d at %p for pid %d",
				i, ofiles[i], Pid);
d397 2
a398 2
			dprintf("unknown file type %d for file %d of pid %d",
				file.f_type, i, Pid);
d417 1
a417 1
		dprintf("can't read vnode at %p for pid %d", vp, Pid);
d532 2
a533 1
		dprintf("can't read inode at %p for pid %d", VTOI(vp), Pid);
d553 2
a554 1
		dprintf("can't read inode at %p for pid %d", VTOI(vp), Pid);
d575 2
a576 1
		dprintf("can't read inode at %p for pid %d", VTOI(vp), Pid);
d598 2
a599 1
		dprintf("can't read nfsnode at %p for pid %d", VTONFS(vp), Pid);
d645 2
a646 1
		dprintf("can't read xfs_node at %p for pid %d", VTOI(vp), Pid);
d671 2
a672 1
		dprintf("can't read node at %p for pid %d", VTONULL(vp), Pid);
d681 2
a682 2
			dprintf("can't read vnode at %p for pid %d",
			    node.null_lowervp, Pid);
@


1.37
log
@grok crypto/kqueue/systrace vnodes
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.36 2002/03/14 06:51:41 mpech Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.36 2002/03/14 06:51:41 mpech Exp $";
d63 1
d65 1
a65 1
#define	_KERNEL
d125 1
a125 1
int 	fsflg,	/* show files on same filesystem as file(s) argument */
d128 1
a128 1
int 	checkfile; /* true if restricting to particular files or filesystems */
d168 1
a168 1
void systracetrans(void *, int i);
a225 1
		case '?':
a322 1

d377 2
a378 1
			vtrans((struct vnode *)file.f_data, i, file.f_flag, file.f_offset);
d393 1
a393 1
				systracetrans((void *)file.f_data, i);
d781 1
a781 1
	printf("pipe %p state: %s%s%s", maxaddr,
a784 2

	printf("\n");
d807 1
a807 1
	printf("kqueue %p %d state: %s%s", kq, kqi.kq_count,
a809 2

	printf("\n");
d824 1
a824 3
	printf("crypto %p", f);

	printf("\n");
d832 1
a832 1
	void *f;
d835 2
d841 5
a845 1
	printf("systrace %p", f);
d847 1
a847 1
	printf("\n");
d873 1
a873 1
			ntohs(*(u_int16_t *)&sin6.sin6_addr.s6_addr[2]);
d878 1
a878 1
			hbuf, sizeof(hbuf), NULL, 0, niflags))
d892 1
a892 1
		"stream", 	/* 1 */
d934 1
a934 2
	}
	else
d1133 2
a1134 2
	(void)fprintf(stderr,
 "usage: fstat [-fnv] [-p pid] [-u user] [-N system] [-M core] [file ...]\n");
@


1.36
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.35 2002/02/16 21:27:46 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.35 2002/02/16 21:27:46 millert Exp $";
d57 2
d63 1
d165 3
d385 9
d785 61
@


1.35
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.34 2001/12/01 18:59:59 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.34 2001/12/01 18:59:59 deraadt Exp $";
d202 1
a202 1
				warnx( "-p requires a process id\n");
@


1.34
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.33 2001/11/26 01:37:16 itojun Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.33 2001/11/26 01:37:16 itojun Exp $";
d148 14
a161 14
int ufs_filestat __P((struct vnode *, struct filestat *));
int ext2fs_filestat __P((struct vnode *, struct filestat *));
int isofs_filestat __P((struct vnode *, struct filestat *));
int msdos_filestat __P((struct vnode *, struct filestat *));
int nfs_filestat __P((struct vnode *, struct filestat *));
int xfs_filestat __P((struct vnode *, struct filestat *));
int null_filestat __P((struct vnode *, struct filestat *));
void dofiles __P((struct kinfo_proc *));
void getinetproto __P((int));
void socktrans __P((struct socket *, int));
void usage __P((void));
void vtrans __P((struct vnode *, int, int, off_t));
int getfname __P((char *));
void pipetrans __P((struct pipe *, int));
@


1.33
log
@fix AF_INET6 dgram socket printing (missing curly brace)
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.32 2001/11/19 19:02:14 mpech Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.32 2001/11/19 19:02:14 mpech Exp $";
d141 1
a141 1
 * a kvm_read that returns true if everything is read 
d235 1
a235 1
	if (fsflg && !checkfile) {	
d283 2
a284 1
#define PREFIX(i) printf("%-8.8s %-10s %5d", Uname, Comm, Pid); \
d301 2
a302 1
	}
d437 1
a437 1
			break;		
d440 2
a441 1
			sprintf(badtype = unknown, "?(%x)", vn.v_tag);
d473 1
a473 1
		(void)sprintf(mode, "%o", fst.mode);
d479 1
a479 1
		strcat(rw, "r");
d481 1
a481 1
		strcat(rw, "w");
d488 1
a488 1
		if (nflg || ((name = devname(fst.rdev, vn.v_type == VCHR ? 
d610 1
a610 1
	};
d704 1
a704 1
		fsp->fileid = fst.fileid; 
d767 4
a770 4
	       (pi.pipe_state & PIPE_WANTR) ? "R" : "",
	       (pi.pipe_state & PIPE_WANTW) ? "W" : "",
	       (pi.pipe_state & PIPE_EOF) ? "E" : "");
	
d867 1
a867 1
	/* 
@


1.32
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.31 2001/07/12 05:17:06 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.31 2001/07/12 05:17:06 deraadt Exp $";
d965 1
a965 1
			if (inpcb.inp_fport)
d972 1
@


1.31
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.30 2001/06/22 22:43:20 pvalchev Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.30 2001/06/22 22:43:20 pvalchev Exp $";
d170 1
a170 1
	register struct passwd *passwd;
d444 1
a444 1
		register DEVS *d;
d572 1
a572 1
	register mode_t mode;
d719 1
a719 1
	register struct mtab *mt;
d1019 1
a1019 1
	register struct protoent *pe;
@


1.30
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.29 2000/09/12 00:15:11 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.29 2000/09/12 00:15:11 deraadt Exp $";
d153 2
d465 2
a466 1
		(void)printf(" %2d,%-2d", major(fst.fsid), minor(fst.fsid));
d495 1
a495 1
		printf(" %8qd", fst.size);
d497 1
a497 1
			printf(":%-8qd", offset);
@


1.29
log
@work around Art's lack of testing
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.28 2000/07/16 23:40:48 hugh Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.28 2000/07/16 23:40:48 hugh Exp $";
d227 1
a227 1
		if (!checkfile)	/* file(s) specified, but none accessable */
@


1.28
log
@Add -o option for printing file offset. Also some whitespace reformatting.
Handy. Checked by millert and niklas.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.27 2000/06/30 16:00:14 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.27 2000/06/30 16:00:14 millert Exp $";
d74 1
@


1.27
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.26 2000/01/17 16:26:19 itojun Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.26 2000/01/17 16:26:19 itojun Exp $";
d125 1
d156 1
a156 1
void vtrans __P((struct vnode *, int, int));
d177 2
a178 1
	while ((ch = getopt(argc, argv, "fnp:u:vN:M:")) != -1)
d192 3
d258 1
a258 1
"USER     CMD          PID   FD  DEV    INUM       MODE SZ|DV R/W");
d261 3
a263 1
"USER     CMD          PID   FD MOUNT      INUM MODE         SZ|DV R/W");
d334 1
a334 1
		vtrans(filed.fd_rdir, RDIR, FREAD);
d338 1
a338 1
	vtrans(filed.fd_cdir, CDIR, FREAD);
d343 1
a343 1
		vtrans(p->p_tracep, TRACE, FREAD|FWRITE);
d367 1
a367 1
			vtrans((struct vnode *)file.f_data, i, file.f_flag);
d382 1
a382 1
vtrans(vp, i, flag)
d386 1
d469 7
a475 1
	(void)printf(" %6ld %10s", fst.fileid, mode);
d483 1
a483 1
			printf("  %2d,%-2d", major(fst.rdev), minor(fst.rdev));
d485 3
a487 1
			printf(" %6s", name);
d491 3
a493 1
		printf(" %6qd", fst.size);
a494 6
	rw[0] = '\0';
	if (flag & FREAD)
		strcat(rw, "r");
	if (flag & FWRITE)
		strcat(rw, "w");
	printf(" %2s", rw);
d496 1
a496 1
		printf("  %s", filename);
@


1.26
log
@IPv6 support.  netbsd PR 9199 with adaptation to NRL inpcb.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.25 1999/10/29 14:06:16 art Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.25 1999/10/29 14:06:16 art Exp $";
d1021 1
a1021 1
		warn(filename);
@


1.26.2.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.27 2000/06/30 16:00:14 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.27 2000/06/30 16:00:14 millert Exp $";
d1021 1
a1021 1
		warn("%s", filename);
@


1.25
log
@The PIPE_NODIRECT define is no longer needed
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.24 1999/07/02 19:23:50 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.24 1999/07/02 19:23:50 deraadt Exp $";
d82 6
d758 32
d811 3
d905 55
@


1.24
log
@use getprotobynumber(); safe since it does not do YP
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.23 1999/07/01 21:41:58 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.23 1999/07/01 21:41:58 deraadt Exp $";
a83 2
#define PIPE_NODIRECT		/* XXX - define here, since it's not defined
				   outside _KERNEL */
@


1.23
log
@pretty good attempt at supporting nullfs
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.22 1999/04/30 02:26:59 art Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.22 1999/04/30 02:26:59 art Exp $";
d99 1
d908 2
a909 1
	char *cp;
d911 5
a915 20
	switch(number) {
	case IPPROTO_IP:
		cp = "ip"; break;
	case IPPROTO_ICMP:
		cp ="icmp"; break;
	case IPPROTO_GGP:
		cp ="ggp"; break;
	case IPPROTO_TCP:
		cp ="tcp"; break;
	case IPPROTO_EGP:
		cp ="egp"; break;
	case IPPROTO_PUP:
		cp ="pup"; break;
	case IPPROTO_UDP:
		cp ="udp"; break;
	case IPPROTO_IDP:
		cp ="idp"; break;
	case IPPROTO_RAW:
		cp ="raw"; break;
	default:
a916 3
		return;
	}
	printf(" %s", cp);
@


1.22
log
@add support for pipes since sparc uses new pipe code by default now
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.21 1998/11/30 10:19:02 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.21 1998/11/30 10:19:02 deraadt Exp $";
d60 1
d65 1
a67 1
#include <sys/mount.h>
d416 4
d608 76
@


1.21
log
@fix error outputs; form
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.20 1998/09/08 20:49:33 art Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.20 1998/09/08 20:49:33 art Exp $";
d83 4
d151 1
d358 4
a361 2
		}
		else {
d633 37
@


1.20
log
@back out the pipe code that breaks on sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.18 1998/09/06 22:48:46 art Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.18 1998/09/06 22:48:46 art Exp $";
d193 1
a193 1
				err(1, "%s: unknown uid", optarg);
d233 1
a233 1
		err(1, buf);
d239 1
a239 1
		err(1, kvm_geterr(kd));
@


1.19
log
@support for pipes
@
text
@a82 2
#include <sys/pipe.h>

a146 1
void pipetrans __P((struct pipe *, int));
d353 2
a354 4
		} else if (file.f_type == DTYPE_PIPE) {
			if (checkfile == 0)
				pipetrans((struct pipe *)file.f_data, i);
		} else {
a625 37
}

void
pipetrans(pipe, i)
	struct pipe *pipe;
	int i;
{
	struct pipe pi;
	void *maxaddr;

	PREFIX(i);

	printf(" ");

	/* fill in socket */
	if (!KVM_READ(pipe, &pi, sizeof(struct pipe))) {
		dprintf("can't read pipe at %p", pipe);
		goto bad;
	}

	/*
	 * We don't have enough space to fit both peer and own address, so
	 * we select the higher address so both ends of the pipe have the
	 * same visible addr. (it's the higher address because when the other
	 * end closes, it becomes 0)
	 */
	maxaddr = MAX(pipe, pi.pipe_peer);

	printf("pipe %p state: %s%s%s", maxaddr,
	       (pi.pipe_state & PIPE_WANTR) ? "R" : "",
	       (pi.pipe_state & PIPE_WANTW) ? "W" : "",
	       (pi.pipe_state & PIPE_EOF) ? "E" : "");
	
	printf("\n");
	return;
bad:
	printf("* error\n");
@


1.18
log
@understand XFS nodes
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.17 1998/07/09 20:28:00 mickey Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.17 1998/07/09 20:28:00 mickey Exp $";
d83 2
d149 1
d356 4
a359 2
		}
		else {
d631 37
@


1.17
log
@fix socket printing bug, missed {}
use err/warn everywhere
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.16 1998/07/08 22:14:12 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.16 1998/07/08 22:14:12 deraadt Exp $";
d73 2
d404 4
d580 19
@


1.16
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.15 1998/07/05 18:42:41 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.15 1998/07/05 18:42:41 deraadt Exp $";
d92 1
a114 2
#define dprintf	if (vflg) fprintf

d121 2
a122 4
		if (ofiles == NULL) { \
			fprintf(stderr, "fstat: %s\n", strerror(errno)); \
			exit(1); \
		} \
d181 1
a181 2
				fprintf(stderr,
				    "fstat: -p requires a process id\n");
d190 2
a191 5
			if (!(passwd = getpwnam(optarg))) {
				fprintf(stderr, "%s: unknown uid\n",
				    optarg);
				exit(1);
			}
d230 2
a231 4
	if ((kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, buf)) == NULL) {
		fprintf(stderr, "fstat: %s\n", buf);
		exit(1);
	}
d236 2
a237 4
	if ((p = kvm_getprocs(kd, what, arg, &cnt)) == NULL) {
		fprintf(stderr, "fstat: %s\n", kvm_geterr(kd));
		exit(1);
	}
d302 1
a302 2
		dprintf(stderr, "can't read filedesc at %p for pid %d\n",
			p->p_fd, Pid);
d307 1
a307 2
		dprintf(stderr, "filedesc corrupted at %p for pid %d\n",
			p->p_fd, Pid);
d332 1
a332 2
			dprintf(stderr,
			    "can't read file structures at %p for pid %d\n",
d342 1
a342 1
			dprintf(stderr, "can't read file %d at %p for pid %d\n",
d353 1
a353 2
			dprintf(stderr, 
				"unknown file type %d for file %d of pid %d\n",
d372 1
a372 2
		dprintf(stderr, "can't read vnode at %p for pid %d\n",
			vp, Pid);
d473 1
a473 2
		dprintf(stderr, "can't read inode at %p for pid %d\n",
			VTOI(vp), Pid);
d493 1
a493 2
		dprintf(stderr, "can't read inode at %p for pid %d\n",
			VTOI(vp), Pid);
d514 1
a514 2
		dprintf(stderr, "can't read inode at %p for pid %d\n",
			VTOI(vp), Pid);
d536 1
a536 2
		dprintf(stderr, "can't read nfsnode at %p for pid %d\n",
			VTONFS(vp), Pid);
d566 2
d591 1
a591 1
		fprintf(stderr, "can't read mount table at %p\n", m);
d594 2
a595 4
	if ((mt = malloc(sizeof (struct mtab))) == NULL) {
		fprintf(stderr, "fstat: %s\n", strerror(errno));
		exit(1);
	}
d629 1
a629 1
		dprintf(stderr, "can't read sock at %p\n", sock);
d635 1
a635 1
		dprintf(stderr, "can't read protosw at %p", so.so_proto);
d641 1
a641 1
		dprintf(stderr, "can't read domain at %p\n", proto.pr_domain);
d647 1
a647 2
		dprintf(stderr, "can't read domain name at %p\n",
			dom.dom_name);
d677 1
a677 2
				dprintf(stderr, "can't read inpcb at %p\n",
				    so.so_pcb);
d685 1
a685 1
			if (inpcb.inp_fport)
d694 1
d700 1
a700 2
				dprintf(stderr, "can't read inpcb at %p\n",
				    so.so_pcb);
d721 1
a721 2
				dprintf(stderr, "can't read unpcb at %p\n",
				    so.so_pcb);
d793 1
a793 1
		fprintf(stderr, "fstat: %s: %s\n", filename, strerror(errno));
d796 2
a797 4
	if ((cur = malloc(sizeof(DEVS))) == NULL) {
		fprintf(stderr, "fstat: %s\n", strerror(errno));
		exit(1);
	}
@


1.15
log
@check kvm_read() better; msaitoh
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.14 1998/06/25 06:21:34 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.14 1998/06/25 06:21:34 deraadt Exp $";
d241 4
@


1.14
log
@first cut at isofs support
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.13 1997/12/06 21:19:34 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.13 1997/12/06 21:19:34 deraadt Exp $";
d662 1
a662 1
	    sizeof(dname) - 1)) < 0) {
@


1.13
log
@tag direction based on SS_CONNECTOUT
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.12 1997/08/25 22:27:59 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.12 1997/08/25 22:27:59 deraadt Exp $";
d92 1
a106 8
struct  filestat {
	long		fsid;
	long		fileid;
	mode_t		mode;
	u_int64_t	size;
	dev_t		rdev;
};

d139 2
d265 1
a265 1
int	Pid;
d406 8
d515 23
@


1.12
log
@everywhere i look, bugs pop up... sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.11 1997/07/08 00:33:02 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.11 1997/07/08 00:33:02 millert Exp $";
d678 5
a682 1
				printf(" <-> %s:%d",
@


1.11
log
@-Wall happiness
Clean up some 64bit issues and remove bogus/unnecesary casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.10 1997/06/05 07:46:55 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.10 1997/06/05 07:46:55 deraadt Exp $";
a113 6
#ifdef notdef
struct nlist nl[] = {
	{ "" },
};
#endif

a245 6
#ifdef notdef
	if (kvm_nlist(kd, nl) != 0) {
		fprintf(stderr, "fstat: no namelist: %s\n", kvm_geterr(kd));
		exit(1);
	}
#endif
d383 1
a383 1
	char rw[3], mode[15];
d412 1
a412 1
			static char unknown[20];
@


1.10
log
@;;
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.9 1997/05/30 12:27:50 downsj Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.9 1997/05/30 12:27:50 downsj Exp $";
d91 1
d107 5
a111 5
	long	fsid;
	long	fileid;
	mode_t	mode;
	u_long	size;
	dev_t	rdev;
d146 1
a146 1
	(kvm_read(kd, (u_long)(kaddr), (char *)(paddr), (len)) == (len))
d150 9
a158 3
int ufs_filestat(), ext2fs_filestat(), nfs_filestat();
void dofiles(), getinetproto(), socktrans();
void usage(), vtrans();
d160 1
d310 1
a310 1
	int i, last;
d326 1
a326 1
		dprintf(stderr, "can't read filedesc at %x for pid %d\n",
d332 1
a332 1
		dprintf(stderr, "filedesc corrupted at %x for pid %d\n",
d359 1
a359 1
			    "can't read file structures at %x for pid %d\n",
d369 1
a369 1
			dprintf(stderr, "can't read file %d at %x for pid %d\n",
d400 1
a400 1
		dprintf(stderr, "can't read vnode at %x for pid %d\n",
d459 1
a459 1
	(void)printf(" %6d %10s", fst.fileid, mode);
d473 1
a473 1
		printf(" %6d", fst.size);
d494 1
a494 1
		dprintf(stderr, "can't read inode at %x for pid %d\n",
d500 2
a501 2
	fsp->mode = (mode_t)inode.i_ffs_mode;
	fsp->size = (u_long)inode.i_ffs_size;
d515 1
a515 1
		dprintf(stderr, "can't read inode at %x for pid %d\n",
d521 2
a522 2
	fsp->mode = (mode_t)inode.i_e2fs_mode;
	fsp->size = (u_long)inode.i_e2fs_size;
d537 1
a537 1
		dprintf(stderr, "can't read nfsnode at %x for pid %d\n",
d591 1
a591 1
		fprintf(stderr, "can't read mount table at %x\n", m);
d631 1
a631 1
		dprintf(stderr, "can't read sock at %x\n", sock);
d637 1
a637 1
		dprintf(stderr, "can't read protosw at %x", so.so_proto);
d643 1
a643 1
		dprintf(stderr, "can't read domain at %x\n", proto.pr_domain);
d649 1
a649 1
		dprintf(stderr, "can't read domain name at %x\n",
d680 1
a680 1
				dprintf(stderr, "can't read inpcb at %x\n",
d684 1
a684 1
			printf(" %lx", (long)inpcb.inp_ppcb);
d699 1
a699 1
				dprintf(stderr, "can't read inpcb at %x\n",
d713 1
a713 1
			printf(" %lx", (long)so.so_pcb);
d718 1
a718 1
			printf(" %lx", (long)so.so_pcb);
d721 1
a721 1
				dprintf(stderr, "can't read unpcb at %x\n",
d735 2
a736 2
				printf(" %s %lx", shoconn,
				    (long)unpcb.unp_conn);
d742 1
a742 1
		printf(" %d %lx", proto.pr_protocol, (long)sock);
d786 1
@


1.9
log
@Fix FFS and add ext2fs support.
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.8 1997/01/15 23:42:30 millert Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.8 1997/01/15 23:42:30 millert Exp $";
d418 1
a418 1
			break;;
@


1.8
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.7 1996/12/22 03:25:52 tholo Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.7 1996/12/22 03:25:52 tholo Exp $";
d149 1
a149 1
int ufs_filestat(), nfs_filestat();
a402 3
			if (!ufs_filestat(&vn, &fst))
				badtype = "error";
			break;
d411 4
d492 24
a515 3
	fsp->mode = (mode_t)inode.i_mode;
	fsp->size = (u_long)inode.i_size;
	fsp->rdev = inode.i_rdev;
@


1.7
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.6 1996/08/17 09:10:47 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.6 1996/08/17 09:10:47 deraadt Exp $";
d169 1
a169 1
	while ((ch = getopt(argc, argv, "fnp:u:vN:M:")) != EOF)
@


1.6
log
@<->
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.5 1996/08/12 19:45:47 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.5 1996/08/12 19:45:47 deraadt Exp $";
d235 2
a236 1
	if (nlistf != NULL || memf != NULL)
d238 1
@


1.5
log
@lsof-like support for fstat, whee
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.4 1996/08/06 18:05:51 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.4 1996/08/06 18:05:51 deraadt Exp $";
d658 1
a658 1
				printf(" -> %s:%d",
d676 1
a676 1
				printf(" -> %s:%d",
@


1.4
log
@careful buf oflow, no longer use strcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: fstat.c,v 1.2 1996/03/27 19:32:24 niklas Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: fstat.c,v 1.2 1996/03/27 19:32:24 niklas Exp $";
d79 2
d643 27
a669 11
		if (proto.pr_protocol == IPPROTO_TCP ) {
			if (so.so_pcb) {
				if (kvm_read(kd, (u_long)so.so_pcb,
				    (char *)&inpcb, sizeof(struct inpcb))
				    != sizeof(struct inpcb)) {
					dprintf(stderr, 
					    "can't read inpcb at %x\n",
					    so.so_pcb);
					goto bad;
				}
				printf(" %lx", (long)inpcb.inp_ppcb);
d671 10
a680 2
		}
		else if (so.so_pcb)
@


1.3
log
@fstat options -N and -M failed; netbsd pr#2374; from osymh@@gemini.oscs.montana.edu
@
text
@d411 1
a411 1
			static char unknown[10];
d591 1
a591 1
	char dname[32], *strcpy();
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD$";
d167 1
a167 1
	while ((ch = getopt(argc, argv, "fnp:u:vNM")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 2
d44 1
a44 1
static char *rcsid = "$Id: fstat.c,v 1.14 1995/03/28 17:24:12 jtc Exp $";
d67 1
a67 1
#include <nfs/nfsv2.h>
d82 1
d161 1
d236 2
a237 2
	if ((kd = kvm_open(nlistf, memf, NULL, O_RDONLY, NULL)) == NULL) {
		fprintf(stderr, "fstat: %s\n", kvm_geterr(kd));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
