head	1.37;
access;
symbols
	OPENBSD_4_8:1.34.0.4
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.10
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.6
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.30.0.8
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.6
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.4
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.4
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.15.0.4
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2010.09.22.13.01.10;	author deraadt;	state dead;
branches;
next	1.36;

1.36
date	2010.09.22.11.39.01;	author pirofti;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.22.11.10.52;	author lum;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.11.18.22.42;	author cloder;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.09.12.36.38;	author chl;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.17.10.59.26;	author moritz;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.04.01.54.10;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2004.10.02.04.14.39;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.04.21.55.12;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.10.22.20.48;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.07.21.13.54;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.13.09.09.33;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.08.11.55.07;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.08.10.37.41;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.04.16.22.19;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.02.04.10.48;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.06.06.24.39;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.08.17.09.13.16;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.06.10.22.38.03;	author pjanzen;	state Exp;
branches;
next	1.13;

1.13
date	99.05.13.12.59.29;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	98.06.23.23.30.19;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.09.11.19.02.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.04.28.06.03.51;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.04.28.05.48.32;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.04.02.17.21.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.02.08.28.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.22.03.25.56;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.10.28.00.45.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.16.02.26.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.25.01.02.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Kill msgs.  Noone uses it, and it has a longjmp in it.
Lots of agreement.
@
text
@/*	$OpenBSD: msgs.c,v 1.36 2010/09/22 11:39:01 pirofti Exp $	*/
/*	$NetBSD: msgs.c,v 1.7 1995/09/28 06:57:40 tls Exp $	*/

/*-
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * msgs - a user bulletin board program
 *
 * usage:
 *	msgs [fhlopqr] [[-]number]	to read messages
 *	msgs -s				to place messages
 *	msgs -c [-days]			to clean up the bulletin board
 *
 * prompt commands are:
 *	y	print message
 *	n	flush message, go to next message
 *	q	flush message, quit
 *	p	print message, turn on 'pipe thru more' mode
 *	P	print message, turn off 'pipe thru more' mode
 *	-	reprint last message
 *	s[-][<num>] [<filename>]	save message
 *	m[-][<num>]	mail with message in temp mbox
 *	x	exit without flushing this message
 *	<num>	print message number <num>
 */

#define OBJECT		/* will object to messages without Subjects */
#define REJECT	/* will reject messages without Subjects
			   (OBJECT must be defined also) */
#undef UNBUFFERED	/* use unbuffered output */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <dirent.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <setjmp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>
#include "pathnames.h"

#define CMODE	0664		/* bounds file creation mode */
#define NO	0
#define YES	1
#define SUPERUSER	0	/* superuser uid */
#define DAEMON		1	/* daemon uid */
#define NLINES	24		/* default number of lines/crt screen */
#define NDAYS	21		/* default keep time for messages */
#define DAYS	*24*60*60	/* seconds/day */
#define MSGSRC	".msgsrc"	/* user's rc file */
#define BOUNDS	"bounds"	/* message bounds file */
#define NEXT	"Next message? [yq]"
#define MORE	"More? [ynq]"
#define NOMORE	"(No more) [q] ?"

typedef	char	bool;

FILE	*msgsrc;
FILE	*newmsg;
char	*sep = "-";
char	inbuf[BUFSIZ];
char	fname[MAXPATHLEN];
char	cmdbuf[MAXPATHLEN + MAXPATHLEN];
char	subj[128];
char	from[128];
char	date[128];
char	*ptr;
char	*in;
bool	local;
bool	ruptible;
bool	totty;
bool	seenfrom;
bool	seensubj;
bool	blankline;
bool	printing = NO;
bool	mailing = NO;
bool	quitit = NO;
bool	sending = NO;
bool	restricted = NO;
int	uid;
int	msg;
int	prevmsg;
int	lct;
int	nlines;
int	Lpp = 0;
time_t	t;
time_t	keep;
volatile sig_atomic_t	intrpflg = 0;

void prmesg(int);
void onintr(int);
void onsusp(int);
int linecnt(FILE *);
int next(char *, int);
void ask(char *);
void gfrsub(FILE *);
char *nxtfld(char *);

/* option initialization */
bool	hdrs = NO;
bool	qopt = NO;
bool	hush = NO;
bool	send_msg = NO;
bool	locomode = NO;
bool	use_pager = NO;
bool	clean = NO;
bool	lastcmd = NO;
jmp_buf	tstpbuf;

int
main(int argc, char *argv[])
{
	bool newrc, already;
	int rcfirst = 0;		/* first message to print (from .rc) */
	int rcback = 0;			/* amount to back off of rcfirst */
	int firstmsg = 0, nextmsg = 0, lastmsg = 0;
	int blast = 0;
	FILE *bounds;
	char *cp;

#ifdef UNBUFFERED
	setbuf(stdout, NULL);
#endif

	time(&t);
	uid = getuid();
	if (setresuid(uid, uid, uid) == -1) {
		perror("setresuid");
		exit(1);
	}
	ruptible = (signal(SIGINT, SIG_IGN) == SIG_DFL);
	if (ruptible)
		signal(SIGINT, SIG_DFL);

	argc--, argv++;
	while (argc > 0) {
		if (isdigit(argv[0][0])) {	/* starting message # */
			rcfirst = atoi(argv[0]);
		} else if (isdigit(argv[0][1])) {	/* backward offset */
			rcback = atoi(&(argv[0][1]));
		} else {
			ptr = *argv;
			while (*ptr) {
				switch (*ptr++) {
				case '-':
					break;
				case 'c':
					if (uid != SUPERUSER && uid != DAEMON) {
						fprintf(stderr, "Sorry\n");
						exit(1);
					}
					clean = YES;
					break;
				case 'f':	/* silently */
					hush = YES;
					break;
				case 'h':	/* headers only */
					hdrs = YES;
					break;
				case 'l':	/* local msgs only */
					locomode = YES;
					break;
				case 'o':	/* option to save last message */
					lastcmd = YES;
					break;
				case 'p':	/* pipe thru 'more' during long msgs */
					use_pager = YES;
					break;
				case 'q':	/* query only */
					qopt = YES;
					break;
				case 'r':	/* restricted */
					restricted = YES;
					break;
				case 's':	/* sending TO msgs */
					send_msg = YES;
					break;
				default:
					fprintf(stderr,
					    "usage: msgs [fhlopqr] [[-]number]\n"
					    "       msgs [-s]\n"
					    "       msgs [-c [-days]]\n");
					exit(1);
				}
			}
		}
		argc--, argv++;
	}

	/*
	 * determine current message bounds
	 */
	snprintf(fname, sizeof(fname), "%s/%s", _PATH_MSGS, BOUNDS);
	bounds = fopen(fname, "r");

	if (bounds == NULL) {
		if (errno == ENOENT) {
			if ((bounds = fopen(fname, "w+")) == NULL) {
				perror(fname);
				exit(1);
			}
			fprintf(bounds, "1 0\n");
			rewind(bounds);
		} else {
			perror(fname);
			exit(1);
		}
	}

	fscanf(bounds, "%d %d\n", &firstmsg, &lastmsg);
	fclose(bounds);
	blast = lastmsg;	/* save upper bound */

	if (clean)
		keep = t - (rcback? rcback : NDAYS) DAYS;

	if (clean || bounds == NULL) {	/* relocate message bounds */
		struct dirent *dp;
		struct stat stbuf;
		bool seenany = NO;
		DIR	*dirp;

		dirp = opendir(_PATH_MSGS);
		if (dirp == NULL) {
			perror(_PATH_MSGS);
			exit(errno);
		}
		chmod(fname, CMODE);

		firstmsg = 32767;
		lastmsg = 0;

		for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)){
			int i = 0;

			cp = dp->d_name;
			if (dp->d_ino == 0)
				continue;
			if (dp->d_namlen == 0)
				continue;

			if (clean)
				snprintf(inbuf, sizeof(inbuf), "%s/%s",
				    _PATH_MSGS, cp);

			while (isdigit(*cp))
				i = i * 10 + *cp++ - '0';
			if (*cp)
				continue;	/* not a message! */

			if (clean) {
				if (stat(inbuf, &stbuf) != 0)
					continue;
				if (stbuf.st_mtime < keep &&
				    stbuf.st_mode&S_IWRITE) {
					unlink(inbuf);
					continue;
				}
			}

			if (i > lastmsg)
				lastmsg = i;
			if (i < firstmsg)
				firstmsg = i;
			seenany = YES;
		}
		closedir(dirp);

		if (!seenany) {
			if (blast != 0)	/* never lower the upper bound! */
				lastmsg = blast;
			firstmsg = lastmsg + 1;
		} else if (blast > lastmsg)
			lastmsg = blast;

		if (!send_msg) {
			bounds = fopen(fname, "w");
			if (bounds == NULL) {
				perror(fname);
				exit(errno);
			}
			chmod(fname, CMODE);
			fprintf(bounds, "%d %d\n", firstmsg, lastmsg);
			fclose(bounds);
		}
	}

	if (send_msg) {
		/*
		 * Send mode - place msgs in _PATH_MSGS
		 */
		bounds = fopen(fname, "w");
		if (bounds == NULL) {
			perror(fname);
			exit(errno);
		}

		nextmsg = lastmsg + 1;
		snprintf(fname, sizeof(fname), "%s/%d", _PATH_MSGS, nextmsg);
		newmsg = fopen(fname, "w");
		if (newmsg == NULL) {
			perror(fname);
			exit(errno);
		}
		chmod(fname, 0644);

		fprintf(bounds, "%d %d\n", firstmsg, nextmsg);
		fclose(bounds);

		sending = YES;
		if (ruptible)
			signal(SIGINT, onintr);

		if (isatty(fileno(stdin))) {
			struct passwd *pw;

			if ((pw = getpwuid(uid)) == NULL) {
				perror("getpwuid");
				exit(1);
			}
			printf("Message %d:\nFrom %s %sSubject: ",
			    nextmsg, pw->pw_name, ctime(&t));
			fflush(stdout);
			if (fgets(inbuf, sizeof inbuf, stdin) == NULL)
				errx(1, "could not read input");
			putchar('\n');
			fflush(stdout);
			fprintf(newmsg, "From %s %sSubject: %s\n",
			    pw->pw_name, ctime(&t), inbuf);
			blankline = seensubj = YES;
		} else
			blankline = seensubj = NO;
		for (;;) {
			if (fgets(inbuf, sizeof inbuf, stdin) == NULL)
				break;
			blankline = (blankline || (inbuf[0] == '\n'));
			seensubj = (seensubj ||
			    (!blankline && (strncmp(inbuf, "Subj", 4) == 0)));
			fputs(inbuf, newmsg);
		}
#ifdef OBJECT
		if (!seensubj) {
			printf("NOTICE: Messages should have a Subject field!\n");
#ifdef REJECT
			unlink(fname);
#endif
			exit(1);
		}
#endif
		exit(ferror(stdin));
	}
	if (clean)
		exit(0);

	/*
	 * prepare to display messages
	 */
	totty = (isatty(fileno(stdout)) != 0);
	use_pager = use_pager && totty;

	if ((cp = getenv("HOME")) == NULL || *cp == '\0') {
		fprintf(stderr, "Error, no home directory!\n");
		exit(1);
	}
	snprintf(fname, sizeof(fname), "%s/%s", cp, MSGSRC);
	msgsrc = fopen(fname, "r");
	if (msgsrc) {
		newrc = NO;
		fscanf(msgsrc, "%d\n", &nextmsg);
		fclose(msgsrc);
		if (nextmsg > lastmsg+1) {
			printf("Warning: bounds have been reset (%d, %d)\n",
			    firstmsg, lastmsg);
			truncate(fname, (off_t)0);
			newrc = YES;
		} else if (!rcfirst)
			rcfirst = nextmsg - rcback;
	} else
		newrc = YES;
	msgsrc = fopen(fname, "r+");
	if (msgsrc == NULL)
		msgsrc = fopen(fname, "w");
	if (msgsrc == NULL) {
		perror(fname);
		exit(errno);
	}
	if (rcfirst) {
		if (rcfirst > lastmsg+1) {
			printf("Warning: the last message is number %d.\n",
			    lastmsg);
			rcfirst = nextmsg;
		}
		if (rcfirst > firstmsg)
			firstmsg = rcfirst;	/* don't set below first msg */
	}
	if (newrc) {
		nextmsg = firstmsg;
		fseeko(msgsrc, (off_t)0, SEEK_SET);
		fprintf(msgsrc, "%d\n", nextmsg);
		fflush(msgsrc);
	}

	if (totty) {
		struct winsize win;
		if (ioctl(fileno(stdout), TIOCGWINSZ, &win) != -1)
			Lpp = win.ws_row;
		if (Lpp <= 0) {
			char *ttype = getenv("TERM");

			if (ttype != (char *)NULL) {
				if (tgetent(NULL, ttype) <= 0
				    || (Lpp = tgetnum("li")) <= 0) {
					Lpp = NLINES;
				}
			} else
				Lpp = NLINES;
		}
	}
	Lpp -= 6;	/* for headers, etc. */

	already = NO;
	prevmsg = firstmsg;
	printing = YES;
	if (ruptible)
		signal(SIGINT, onintr);

	/*
	 * Main program loop
	 */
	for (msg = firstmsg; msg <= lastmsg; msg++) {

		snprintf(fname, sizeof(fname), "%s/%d", _PATH_MSGS, msg);
		newmsg = fopen(fname, "r");
		if (newmsg == NULL)
			continue;

		gfrsub(newmsg);		/* get From and Subject fields */
		if (locomode && !local) {
			fclose(newmsg);
			continue;
		}

		if (qopt) {	/* This has to be located here */
			printf("There are new messages.\n");
			exit(0);
		}

		if (already && !hdrs)
			putchar('\n');

		/*
		 * Print header
		 */
		if (totty)
			signal(SIGTSTP, onsusp);
		(void) setjmp(tstpbuf);
		already = YES;
		nlines = 2;
		if (seenfrom) {
			printf("Message %d:\nFrom %s %s", msg, from, date);
			nlines++;
		}
		if (seensubj) {
			printf("Subject: %s", subj);
			nlines++;
		} else {
			if (seenfrom) {
				putchar('\n');
				nlines++;
			}
			while (nlines < 6 &&
			    fgets(inbuf, sizeof inbuf, newmsg) &&
			    inbuf[0] != '\n') {
				fputs(inbuf, stdout);
				nlines++;
			}
		}

		lct = linecnt(newmsg);
		if (lct)
			printf("(%d%slines) ", lct, seensubj? " " : " more ");

		if (hdrs) {
			printf("\n-----\n");
			fclose(newmsg);
			continue;
		}

		/*
		 * Ask user for command
		 */
		if (totty)
			ask(lct? MORE : (msg==lastmsg? NOMORE : NEXT));
		else
			inbuf[0] = 'y';
		if (totty)
			signal(SIGTSTP, SIG_DFL);
cmnd:
		in = inbuf;
		switch (*in) {
		case 'x':
		case 'X':
			exit(0);

		case 'q':
		case 'Q':
			quitit = YES;
			printf("--Postponed--\n");
			exit(0);
			/* intentional fall-thru */
		case 'n':
		case 'N':
			if (msg >= nextmsg)
				sep = "Flushed";
			prevmsg = msg;
			break;

		case 'p':
		case 'P':
			use_pager = (*in++ == 'p');
			/* intentional fallthru */
		case '\n':
		case 'y':
		default:
			if (*in == '-') {
				msg = prevmsg-1;
				sep = "replay";
				break;
			}
			if (isdigit(*in)) {
				msg = next(in, sizeof inbuf);
				sep = in;
				break;
			}

			prmesg(nlines + lct + (seensubj? 1 : 0));
			prevmsg = msg;
		}

		printf("--%s--\n", (intrpflg ? "Interrupt" : sep));
		sep = "-";
		if (msg >= nextmsg) {
			nextmsg = msg + 1;
			fseeko(msgsrc, (off_t)0, SEEK_SET);
			fprintf(msgsrc, "%d\n", nextmsg);
			fflush(msgsrc);
		}
		if (newmsg)
			fclose(newmsg);
		if (quitit)
			break;
	}

	/*
	 * Make sure .rc file gets updated
	 */
	if (--msg >= nextmsg) {
		nextmsg = msg + 1;
		fseeko(msgsrc, (off_t)0, SEEK_SET);
		fprintf(msgsrc, "%d\n", nextmsg);
		fflush(msgsrc);
	}
	if (already && !quitit && lastcmd && totty) {
		/*
		 * save or reply to last message?
		 */
		msg = prevmsg;
		ask(NOMORE);
		if (inbuf[0] == '-' || isdigit(inbuf[0]))
			goto cmnd;
	}
	if (!(already || hush || qopt))
		printf("No new messages.\n");
	exit(0);
}

void
prmesg(int length)
{
	FILE *outf;
	char *env_pager;

	if (use_pager && length > Lpp) {
		signal(SIGPIPE, SIG_IGN);
		signal(SIGQUIT, SIG_IGN);
		if ((env_pager = getenv("PAGER")) == NULL || *env_pager == '\0') {
			snprintf(cmdbuf, sizeof(cmdbuf), _PATH_PAGER, Lpp);
		} else {
			snprintf(cmdbuf, sizeof(cmdbuf), "%s", env_pager);
		}
		outf = popen(cmdbuf, "w");
		if (!outf)
			outf = stdout;
		else
			setbuf(outf, (char *)NULL);
	}
	else
		outf = stdout;

	if (seensubj)
		putc('\n', outf);

	while (fgets(inbuf, sizeof inbuf, newmsg)) {
		fputs(inbuf, outf);
		if (ferror(outf)) {
			clearerr(outf);
			break;
		}
	}

	if (outf != stdout) {
		pclose(outf);
		signal(SIGPIPE, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
	} else {
		fflush(stdout);
	}

	/* trick to force wait on output */
	tcdrain(fileno(stdout));
}

/* ARGSUSED */
void
onintr(int signo)
{
	int save_errno = errno;

	signal(SIGINT, onintr);
	if (mailing)
		unlink(fname);
	if (sending) {
		unlink(fname);
		write(STDOUT_FILENO, "--Killed--\n", strlen("--Killed--\n"));
		_exit(1);
	}
	if (printing) {
		write(STDOUT_FILENO, "\n", 1);
		if (hdrs)
			_exit(0);
		if (newmsg)
			fseeko(newmsg, (off_t)0, SEEK_END);
		intrpflg = 1;
	}
	errno = save_errno;
}

/*
 * We have just gotten a susp.  Suspend and prepare to resume.
 */
/* ARGSUSED */
void
onsusp(int signo)
{
	int save_errno = errno;
	sigset_t emptyset;

	signal(SIGTSTP, SIG_DFL);
	sigemptyset(&emptyset);
	sigprocmask(SIG_SETMASK, &emptyset, NULL);
	kill(0, SIGTSTP);
	signal(SIGTSTP, onsusp);
	errno = save_errno;

	if (!mailing)
		longjmp(tstpbuf, 1);
}

int
linecnt(FILE *f)
{
	off_t oldpos = ftello(f);

	int l = 0;
	char lbuf[BUFSIZ];

	while (fgets(lbuf, sizeof lbuf, f))
		l++;
	clearerr(f);
	fseeko(f, oldpos, SEEK_SET);
	return (l);
}

int
next(char *buf, int len)
{
	int i;
	sscanf(buf, "%d", &i);
	snprintf(buf, len, "Goto %d", i);
	return(--i);
}

void
ask(char *prompt)
{
	char	inch;
	int	n, cmsg, fd;
	off_t	oldpos;
	FILE	*cpfrom, *cpto;

	printf("%s ", prompt);
	fflush(stdout);
	intrpflg = 0;
	if (fgets(inbuf, sizeof inbuf, stdin) == NULL)
		errx(1, "could not read input");
	inbuf[strcspn(inbuf, "\n")] = '\0';
	if (intrpflg)
		inbuf[0] = 'x';

	/*
	 * Handle 'mail' and 'save' here.
	 */
	if (((inch = inbuf[0]) == 's' || inch == 'm') && !restricted) {
		if (inbuf[1] == '-')
			cmsg = prevmsg;
		else if (isdigit(inbuf[1]))
			cmsg = atoi(&inbuf[1]);
		else
			cmsg = msg;
		snprintf(fname, sizeof(fname), "%s/%d", _PATH_MSGS, cmsg);

		oldpos = ftello(newmsg);

		cpfrom = fopen(fname, "r");
		if (!cpfrom) {
			printf("Message %d not found\n", cmsg);
			ask (prompt);
			return;
		}

		if (inch == 's') {
			in = nxtfld(inbuf);
			if (*in) {
				for (n=0;
				    in[n] > ' ' && n < sizeof fname - 1;
				    n++) {
					fname[n] = in[n];
				}
				fname[n] = NULL;
			}
			else
				strlcpy(fname, "Messages", sizeof fname);
			fd = open(fname, O_RDWR|O_EXCL|O_CREAT|O_APPEND, 0666);
		} else {
			strlcpy(fname, _PATH_TMPFILE, sizeof fname);
			fd = mkstemp(fname);
			if (fd != -1) {
				snprintf(cmdbuf, sizeof(cmdbuf), _PATH_MAIL, fname);
				mailing = YES;
			}
		}
		if (fd == -1 || (cpto = fdopen(fd, "a")) == NULL) {
			if (fd != -1)
				close(fd);
			perror(fname);
			mailing = NO;
			fseeko(newmsg, oldpos, SEEK_SET);
			ask(prompt);
			return;
		}

		while ((n = fread(inbuf, 1, sizeof inbuf, cpfrom)))
			fwrite(inbuf, 1, n, cpto);

		fclose(cpfrom);
		fclose(cpto);
		fseeko(newmsg, oldpos, SEEK_SET);	/* reposition current message */
		if (inch == 's')
			printf("Message %d saved in \"%s\"\n", cmsg, fname);
		else {
			system(cmdbuf);
			unlink(fname);
			mailing = NO;
		}
		ask(prompt);
	}
}

void
gfrsub(FILE *infile)
{
	off_t frompos;

	seensubj = seenfrom = NO;
	local = YES;
	subj[0] = from[0] = date[0] = NULL;

	/*
	 * Is this a normal message?
	 */
	if (fgets(inbuf, sizeof inbuf, infile)) {
		if (strncmp(inbuf, "From", 4)==0) {
			/*
			 * expected form starts with From
			 */
			seenfrom = YES;
			frompos = ftello(infile);
			ptr = from;
			in = nxtfld(inbuf);
			if (*in) {
				while (*in && *in > ' ' &&
				    ptr - from < sizeof from -1) {
					if (*in == ':' || *in == '@@' || *in == '!')
						local = NO;
					*ptr++ = *in++;
				}
			}
			*ptr = NULL;
			if (*(in = nxtfld(in)))
				strncpy(date, in, sizeof date);
			else {
				date[0] = '\n';
				date[1] = NULL;
			}
		} else {
			/*
			 * not the expected form
			 */
			fseeko(infile, (off_t)0, SEEK_SET);
			return;
		}
	} else
		/*
		 * empty file ?
		 */
		return;

	/*
	 * look for Subject line until EOF or a blank line
	 */
	while (fgets(inbuf, sizeof inbuf, infile) &&
	    !(blankline = (inbuf[0] == '\n'))) {
		/*
		 * extract Subject line
		 */
		if (!seensubj && strncmp(inbuf, "Subj", 4)==0) {
			seensubj = YES;
			frompos = ftello(infile);
			strncpy(subj, nxtfld(inbuf), sizeof subj);
		}
	}
	if (!blankline)
		/*
		 * ran into EOF
		 */
		fseeko(infile, frompos, SEEK_SET);

	if (!seensubj)
		/*
		 * for possible use with Mail
		 */
		strncpy(subj, "(No Subject)\n", sizeof subj);
}

char *
nxtfld(char *s)
{
	if (*s)
		while (*s && *s > ' ')
			s++;	/* skip over this field */
	if (*s)
		while (*s && *s <= ' ')
			s++;	/* find start of next field */
	return (s);
}
@


1.36
log
@nextmsg could be used uninitialized as well.

``Go ahead, its free'' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.35 2010/09/22 11:10:52 lum Exp $	*/
@


1.35
log
@Initialise firstmsg so we do not have random number when
bounds file is empty.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.34 2009/10/27 23:59:40 deraadt Exp $	*/
d153 1
a153 1
	int firstmsg = 0, nextmsg, lastmsg = 0;
@


1.34
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.33 2007/09/11 18:22:42 cloder Exp $	*/
d153 1
a153 1
	int firstmsg, nextmsg, lastmsg = 0;
@


1.33
log
@Avoid setting a global pointer variable from signal handlers
OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.32 2007/09/09 12:36:38 chl Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)msgs.c	8.2 (Berkeley) 4/28/95";
#else
static char rcsid[] = "$OpenBSD: msgs.c,v 1.32 2007/09/09 12:36:38 chl Exp $";
#endif
#endif /* not lint */
@


1.32
log
@check fgets return value
use strcspn to properly overwrite '\n' in fgets returned buffer

with help and ok from moritz@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.31 2007/05/17 10:59:26 moritz Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.31 2007/05/17 10:59:26 moritz Exp $";
a129 1
bool	intrpflg = NO;
d139 1
d591 1
a591 1
		printf("--%s--\n", sep);
a691 1
		sep = "Interrupt";
d694 1
a694 1
		intrpflg = YES;
d754 1
a754 1
	intrpflg = NO;
@


1.31
log
@Check getpwuid() return value for NULL before dereferencing it.

ok ray@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.30 2005/07/04 01:54:10 djm Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.30 2005/07/04 01:54:10 djm Exp $";
d78 1
d375 2
a376 1
			fgets(inbuf, sizeof inbuf, stdin);
d385 1
a385 2
			fgets(inbuf, sizeof inbuf, stdin);
			if (feof(stdin) || ferror(stdin))
d756 3
a758 3
	(void) fgets(inbuf, sizeof inbuf, stdin);
	if ((n = strlen(inbuf)) > 0 && inbuf[n - 1] == '\n')
		inbuf[n - 1] = '\0';
@


1.30
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.29 2004/10/02 04:14:39 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.29 2004/10/02 04:14:39 deraadt Exp $";
d365 6
a370 1
			ptr = getpwuid(uid)->pw_name;
d372 1
a372 1
			    nextmsg, ptr, ctime(&t));
d378 1
a378 1
			    ptr, ctime(&t), inbuf);
@


1.29
log
@ftello and fseek ok and such, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.28 2003/10/04 21:55:12 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.28 2003/10/04 21:55:12 jmc Exp $";
d176 5
a180 2
	seteuid(uid = getuid());
	setuid(uid);
@


1.28
log
@- sort options
- document -o
- sync usage() with SYNOPSIS
- various tweaks

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.27 2003/06/10 22:20:48 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.27 2003/06/10 22:20:48 deraadt Exp $";
d186 3
a188 5
		}
		else if (isdigit(argv[0][1])) {	/* backward offset */
			rcback = atoi( &( argv[0][1] ) );
		}
		else {
d190 40
a229 8
			while (*ptr) switch (*ptr++) {

			case '-':
				break;

			case 'c':
				if (uid != SUPERUSER && uid != DAEMON) {
					fprintf(stderr, "Sorry\n");
a231 42
				clean = YES;
				break;

			case 'f':		/* silently */
				hush = YES;
				break;

			case 'h':		/* headers only */
				hdrs = YES;
				break;

			case 'l':		/* local msgs only */
				locomode = YES;
				break;

			case 'o':		/* option to save last message */
				lastcmd = YES;
				break;

			case 'p':		/* pipe thru 'more' during long msgs */
				use_pager = YES;
				break;

			case 'q':		/* query only */
				qopt = YES;
				break;

			case 'r':		/* restricted */
				restricted = YES;
				break;
 

			case 's':		/* sending TO msgs */
				send_msg = YES;
				break;

			default:
				fprintf(stderr,
					"usage: msgs [fhlopqr] [[-]number]\n"
					"       msgs [-s]\n"
					"       msgs [-c [-days]]\n");
				exit(1);
d251 1
a251 2
		}
		else {
d291 1
a291 1
					 _PATH_MSGS, cp);
d301 2
a302 2
				if (stbuf.st_mtime < keep
				    && stbuf.st_mode&S_IWRITE) {
d320 1
a320 2
		}
		else if (blast > lastmsg)
d364 1
a364 1
				nextmsg, ptr, ctime(&t));
d370 1
a370 1
				ptr, ctime(&t), inbuf);
d372 1
a372 2
		}
		else
d379 2
a380 1
			seensubj = (seensubj || (!blankline && (strncmp(inbuf, "Subj", 4) == 0)));
d415 1
a415 1
				firstmsg, lastmsg);
d418 1
a418 2
		}
		else if (!rcfirst)
d420 1
a420 2
	}
	else
d432 1
a432 1
				lastmsg);
d440 1
a440 1
		fseek(msgsrc, 0L, 0);
d508 1
a508 2
		}
		else {
d513 3
a515 3
			while (nlines < 6
			    && fgets(inbuf, sizeof inbuf, newmsg)
			    && inbuf[0] != '\n') {
d543 3
a545 15
			case 'x':
			case 'X':
				exit(0);

			case 'q':
			case 'Q':
				quitit = YES;
				printf("--Postponed--\n");
				exit(0);
				/* intentional fall-thru */
			case 'n':
			case 'N':
				if (msg >= nextmsg) sep = "Flushed";
				prevmsg = msg;
				break;
d547 12
a558 17
			case 'p':
			case 'P':
				use_pager = (*in++ == 'p');
				/* intentional fallthru */
			case '\n':
			case 'y':
			default:
				if (*in == '-') {
					msg = prevmsg-1;
					sep = "replay";
					break;
				}
				if (isdigit(*in)) {
					msg = next(in, sizeof inbuf);
					sep = in;
					break;
				}
d560 17
a576 2
				prmesg(nlines + lct + (seensubj? 1 : 0));
				prevmsg = msg;
d578 2
d586 1
a586 1
			fseek(msgsrc, 0L, 0);
d601 1
a601 1
		fseek(msgsrc, 0L, 0);
d657 1
a657 2
	}
	else {
d665 1
d667 1
a667 1
onintr(int unused)
d669 2
d676 2
a677 2
		puts("--Killed--");
		exit(1);
d680 1
a680 1
		putchar('\n');
d682 1
a682 1
			exit(0);
d685 1
a685 1
			fseek(newmsg, 0L, 2);
d688 1
d694 1
d696 1
a696 1
onsusp(int unused)
d698 1
d706 2
d715 2
a716 1
	off_t oldpos = ftell(f);
d723 1
a723 1
	fseek(f, oldpos, 0);
d765 1
a765 1
		oldpos = ftell(newmsg);
d778 2
a779 2
				     in[n] > ' ' && n < sizeof fname - 1;
				     n++) {
d787 1
a787 2
		}
		else {
d800 1
a800 1
			fseek(newmsg, oldpos, 0);
d810 1
a810 1
		fseek(newmsg, oldpos, 0);	/* reposition current message */
d840 1
a840 1
			frompos = ftell(infile);
d858 1
a858 2
		}
		else {
d862 1
a862 1
			fseek(infile, 0L, 0);
d865 1
a865 2
	}
	else
d874 2
a875 2
	while (fgets(inbuf, sizeof inbuf, infile)
	    && !(blankline = (inbuf[0] == '\n'))) {
d881 1
a881 1
			frompos = ftell(infile);
d889 1
a889 1
		fseek(infile, frompos, 0);
d901 6
a906 2
	if (*s) while (*s && *s > ' ') s++;	/* skip over this field */
	if (*s) while (*s && *s <= ' ') s++;	/* find start of next field */
@


1.27
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.26 2003/06/03 02:56:13 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.26 2003/06/03 02:56:13 millert Exp $";
d240 3
a242 1
					"usage: msgs [fhlopqr] [[-]number]\n");
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.25 2003/04/07 21:13:54 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.25 2003/04/07 21:13:54 deraadt Exp $";
d161 1
a161 3
main(argc, argv)
	int argc;
	char *argv[];
d635 1
a635 2
prmesg(length)
int length;
d682 1
a682 2
onintr(unused)
	int unused;
d707 1
a707 2
onsusp(unused)
	int unused;
d721 1
a721 2
linecnt(f)
	FILE *f;
d735 1
a735 3
next(buf, len)
	char *buf;
	int len;
d744 1
a744 2
ask(prompt)
	char *prompt;
d831 1
a831 2
gfrsub(infile)
	FILE *infile;
d909 1
a909 2
nxtfld(s)
	char *s;
@


1.25
log
@replace strcpy calls that got inlined by gcc; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.24 2003/03/13 09:09:33 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.24 2003/03/13 09:09:33 deraadt Exp $";
@


1.24
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.23 2002/08/08 11:55:07 ho Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.23 2002/08/08 11:55:07 ho Exp $";
d805 1
a805 1
				strcpy(fname, "Messages");
d809 1
a809 1
			strcpy(fname, _PATH_TMPFILE);
@


1.23
log
@sizeof fname, not sizeof *fname
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.22 2002/08/08 10:37:41 ho Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.22 2002/08/08 10:37:41 ho Exp $";
d148 1
a148 1
int next(char *);
d593 1
a593 1
					msg = next(in);
d745 1
a745 1
next(buf)
d747 1
d751 1
a751 1
	sprintf(buf, "Goto %d", i);
@


1.22
log
@3rd arg for open, plus some bounds checking. miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.21 2002/02/16 21:27:49 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.21 2002/02/16 21:27:49 millert Exp $";
d797 1
a797 1
				     in[n] > ' ' && n < sizeof *fname - 1;
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.20 2002/01/04 16:22:19 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.20 2002/01/04 16:22:19 art Exp $";
d796 3
a798 1
				for (n=0; in[n] > ' '; n++) { /* sizeof fname? */
d805 1
a805 1
			fd = open(fname, O_RDWR|O_EXCL|O_CREAT|O_APPEND);
@


1.20
log
@Don't longjmp(..., 0)
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.19 2001/11/19 19:02:15 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.19 2001/11/19 19:02:15 mpech Exp $";
d144 8
a151 8
void prmesg __P((int));
void onintr __P((int));
void onsusp __P((int));
int linecnt __P((FILE *));
int next __P((char *));
void ask __P((char *));
void gfrsub __P((FILE *));
char *nxtfld __P((char *));
@


1.19
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.18 2001/09/04 23:35:59 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.18 2001/09/04 23:35:59 millert Exp $";
d726 1
a726 1
		longjmp(tstpbuf, 0);
@


1.18
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.17 2000/08/02 04:10:48 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.17 2000/08/02 04:10:48 millert Exp $";
d298 1
a298 1
			register int i = 0;
@


1.17
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.16 2000/07/06 06:24:39 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.16 2000/07/06 06:24:39 deraadt Exp $";
d718 2
d721 2
a722 1
	sigsetmask(0);
@


1.16
log
@snprintf with %s when copying the pager
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.15 1999/08/17 09:13:16 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.15 1999/08/17 09:13:16 millert Exp $";
d175 1
a297 1
			register char *cp = dp->d_name;
d300 1
d421 5
a425 1
	snprintf(fname, sizeof(fname), "%s/%s", getenv("HOME"), MSGSRC);
@


1.15
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.14 1999/06/10 22:38:03 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.14 1999/06/10 22:38:03 pjanzen Exp $";
d648 1
a648 1
			snprintf(cmdbuf, sizeof(cmdbuf), env_pager);
@


1.14
log
@Handle PAGER in a manner consistent with the Single Unix Specification:
that is, use PAGER rather than "more" if it is defined and non-null, not
just if it is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.13 1999/05/13 12:59:29 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.13 1999/05/13 12:59:29 aaron Exp $";
a78 1
#include <sys/file.h>
d83 1
@


1.13
log
@create /var/msgs/bounds if it does not exist and reset it to its default
state so the (improved) man page does not lie; emory@@hellyeah.com
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.12 1998/06/23 23:30:19 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.12 1998/06/23 23:30:19 deraadt Exp $";
d645 1
a645 1
		if ((env_pager = getenv("PAGER")) == NULL) {
@


1.12
log
@complain correctly when /var/msgs/bounds does not exist; fullermd@@futuresouth.com
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.11 1997/09/11 19:02:55 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.11 1997/09/11 19:02:55 deraadt Exp $";
d259 12
a270 2
		perror(fname);
		exit(1);
@


1.11
log
@oflow, indent
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.10 1997/04/28 06:03:51 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.10 1997/04/28 06:03:51 downsj Exp $";
d258 3
a260 4
	if (bounds != NULL) {
		fscanf(bounds, "%d %d\n", &firstmsg, &lastmsg);
		fclose(bounds);
		blast = lastmsg;	/* save upper bound */
d262 4
@


1.10
log
@Clean up terminal type handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.9 1997/04/28 05:48:32 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.9 1997/04/28 05:48:32 downsj Exp $";
d234 3
a236 3
                        case 'r':               /* restricted */
                                restricted = YES;
                                break;
d411 3
a413 3
                fscanf(msgsrc, "%d\n", &nextmsg);
                fclose(msgsrc);
                if (nextmsg > lastmsg+1) {
d422 5
a426 5
        else
        	newrc = YES;
        msgsrc = fopen(fname, "r+");
        if (msgsrc == NULL)
               msgsrc = fopen(fname, "w");
d632 5
a636 5
                if ((env_pager = getenv("PAGER")) == NULL) {
                        snprintf(cmdbuf, sizeof(cmdbuf), _PATH_PAGER, Lpp);
                } else {
                        strcpy(cmdbuf, env_pager);
                }
d754 1
a754 1
        if (((inch = inbuf[0]) == 's' || inch == 'm') && !restricted) {
@


1.9
log
@Modernize protyped, switch to libtermlib.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.8 1997/04/02 17:21:24 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.8 1997/04/02 17:21:24 deraadt Exp $";
a71 1
#define V7		/* will look for TERM in the environment */
a446 1
#ifdef V7
d452 8
a459 2
			if (tgetent(inbuf, getenv("TERM")) <= 0
			    || (Lpp = tgetnum("li")) <= 0) {
a460 1
			}
a462 1
#endif
@


1.8
log
@buf oflows, thanks imp & millert
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.7 1997/04/02 08:28:01 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.7 1997/04/02 08:28:01 deraadt Exp $";
d76 1
a76 1
/* #define UNBUFFERED	/* use unbuffered output */
d91 1
d145 8
a152 3
char	*nxtfld();
void	onintr();
void	onsusp();
d165 1
d167 2
a168 1
int argc; char *argv[];
d620 1
d669 2
a670 1
onintr()
d695 2
a696 1
onsusp()
a697 1

d706 1
d708 1
a708 1
FILE *f;
d721 1
d723 1
a723 1
char *buf;
d731 1
d733 1
a733 1
char *prompt;
d800 1
a800 1
		while (n = fread(inbuf, 1, sizeof inbuf, cpfrom))
d817 1
d819 1
a819 1
FILE *infile;
d898 1
a898 1
char *s;
@


1.7
log
@use mkstemp (millert, please double check)
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.6 1996/12/22 03:25:56 tholo Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.6 1996/12/22 03:25:56 tholo Exp $";
d116 2
a117 2
char	fname[128];
char	cmdbuf[128];
d825 7
a831 5
			if (*in) while (*in && *in > ' ') {
				if (*in == ':' || *in == '@@' || *in == '!')
					local = NO;
				*ptr++ = *in++;
				/* what about sizeof from ? */
@


1.6
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.5 1996/10/28 00:45:58 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.5 1996/10/28 00:45:58 millert Exp $";
d767 1
d771 8
a778 7
			mktemp(fname);
			snprintf(cmdbuf, sizeof(cmdbuf), _PATH_MAIL, fname);
			mailing = YES;
		}
		if ((fd = open(fname, O_RDWR|O_EXCL|O_CREAT|O_APPEND)) == -1 ||
		    (cpto = fdopen(fd, "a")) == NULL) {
			if (fd == -1)
@


1.5
log
@Use snprintf().  Solves $HOME overflow and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.4 1996/09/16 02:26:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.4 1996/09/16 02:26:12 deraadt Exp $";
d174 2
a175 1
	setuid(uid = getuid());
@


1.4
log
@_PATH_TMP -> _PATH_TMPFILE; avoid /tmp//fooXXXX where possible too
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.3 1996/06/26 05:37:18 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.3 1996/06/26 05:37:18 deraadt Exp $";
d247 1
a247 1
	sprintf(fname, "%s/%s", _PATH_MSGS, BOUNDS);
d285 2
a286 1
				sprintf(inbuf, "%s/%s", _PATH_MSGS, cp);
d342 1
a342 1
		sprintf(fname, "%s/%d", _PATH_MSGS, nextmsg);
d399 1
a399 1
	sprintf(fname, "%s/%s", getenv("HOME"), MSGSRC);
d465 1
a465 1
		sprintf(fname, "%s/%d", _PATH_MSGS, msg);
d621 1
a621 1
                        sprintf(cmdbuf, _PATH_PAGER, Lpp);
d745 1
a745 1
		sprintf(fname, "%s/%d", _PATH_MSGS, cmsg);
d770 1
a770 1
			sprintf(cmdbuf, _PATH_MAIL, fname);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: msgs.c,v 1.7 1995/09/28 06:57:40 tls Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: msgs.c,v 1.7 1995/09/28 06:57:40 tls Exp $";
d767 1
a767 1
			strcpy(fname, _PATH_TMP);
@


1.2
log
@mktemp open/fdopen
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: msgs.c,v 1.7 1995/09/28 06:57:40 tls Exp $";
@


1.1
log
@Initial revision
@
text
@d79 1
a142 1
char	*mktemp();
d720 1
a720 1
	int	n, cmsg;
d771 4
a774 2
		cpto = fopen(fname, "a");
		if (!cpto) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
