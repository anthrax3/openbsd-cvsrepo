head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	sbrB3Q5CNxcwZpfU;

1.18
date	2015.10.05.06.04.18;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	fM4U0UkMogMi9Ig0;

1.17
date	2015.05.09.20.36.18;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	gLrfHiGNcl8xBk3R;

1.16
date	2015.05.08.16.30.07;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	nOD7QDz68wOQ1nuo;

1.15
date	2015.05.08.12.30.27;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	hvWmBb2zq3s39n7e;

1.14
date	2014.10.17.21.27.10;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	V98Qo5xX6K36MFay;

1.13
date	2014.10.16.13.45.12;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	5YXJcIGVF5dw2CiJ;

1.12
date	2014.10.08.19.59.58;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	94IIGPQQlycbNbEe;

1.11
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.01.01.26.19;	author jdixon;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.02.56.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.21.18.15.09;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.21.30.12;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.06.17.20.53.58;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.42.20;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Change all tame callers to namechange to pledge(2).
@
text
@/*	$OpenBSD: col.c,v 1.18 2015/10/05 06:04:18 deraadt Exp $	*/
/*	$NetBSD: col.c,v 1.7 1995/09/02 05:48:50 jtc Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Michael Rendell of the Memorial University of Newfoundland.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <err.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>

#define	BS	'\b'		/* backspace */
#define	TAB	'\t'		/* tab */
#define	SPACE	' '		/* space */
#define	NL	'\n'		/* newline */
#define	CR	'\r'		/* carriage return */
#define	ESC	'\033'		/* escape */
#define	SI	'\017'		/* shift in to normal character set */
#define	SO	'\016'		/* shift out to alternate character set */
#define	VT	'\013'		/* vertical tab (aka reverse line feed) */

/* build up at least this many lines before flushing them out */
#define	BUFFER_MARGIN		32

typedef char CSET;

typedef struct char_str {
#define	CS_NORMAL	1
#define	CS_ALTERNATE	2
	size_t		c_column;	/* column character is in */
	CSET		c_set;		/* character set (currently only 2) */
	char		c_char;		/* character in question */
} CHAR;

typedef struct line_str LINE;
struct line_str {
	CHAR	*l_line;		/* characters on the line */
	LINE	*l_prev;		/* previous line */
	LINE	*l_next;		/* next line */
	size_t	l_lsize;		/* allocated sizeof l_line */
	size_t	l_line_len;		/* strlen(l_line) */
	size_t	l_max_col;		/* max column in the line */
	int	l_needs_sort;		/* set if chars went in out of order */
};

void	addto_lineno(int *, int);
LINE   *alloc_line(void);
void	dowarn(int);
void	flush_line(LINE *);
void	flush_lines(int);
void	flush_blanks(void);
void	free_line(LINE *);
void	usage(void);
void   *xreallocarray(void *, size_t, size_t);

CSET	last_set;		/* char_set of last char printed */
LINE   *lines;
int	compress_spaces;	/* if doing space -> tab conversion */
int	fine;			/* if `fine' resolution (half lines) */
int	max_bufd_lines;		/* max # of half lines to keep in memory */
int	nblank_lines;		/* # blanks after last flushed line */
int	no_backspaces;		/* if not to output any backspaces */

#define	PUTC(ch) \
	if (putchar(ch) == EOF) \
		err(1, "stdout");

int
main(int argc, char *argv[])
{
	int ch;
	CHAR *c;
	CSET cur_set;			/* current character set */
	LINE *l;			/* current line */
	int extra_lines;		/* # of lines above first line */
	size_t cur_col;			/* current column */
	int cur_line;			/* line number of current position */
	int max_line;			/* max value of cur_line */
	int this_line;			/* line l points to */
	int nflushd_lines;		/* number of lines that were flushed */
	int adjust, opt, warned;
	const char *errstr;

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	max_bufd_lines = 256;
	compress_spaces = 1;		/* compress spaces into tabs */
	while ((opt = getopt(argc, argv, "bfhl:x")) != -1)
		switch (opt) {
		case 'b':		/* do not output backspaces */
			no_backspaces = 1;
			break;
		case 'f':		/* allow half forward line feeds */
			fine = 1;
			break;
		case 'h':		/* compress spaces into tabs */
			compress_spaces = 1;
			break;
		case 'l':		/* buffered line count */
			max_bufd_lines = strtonum(optarg, 1,
			    (INT_MAX - BUFFER_MARGIN) / 2, &errstr) * 2;
			if (errstr != NULL)
				errx(1, "bad -l argument, %s: %s", errstr, 
					optarg);
			break;
		case 'x':		/* do not compress spaces into tabs */
			compress_spaces = 0;
			break;
		case '?':
		default:
			usage();
		}

	if (optind != argc)
		usage();

	adjust = extra_lines = warned = 0;
	cur_col = 0;
	cur_line = max_line = nflushd_lines = this_line = 0;
	cur_set = last_set = CS_NORMAL;
	lines = l = alloc_line();

	while ((ch = getchar()) != EOF) {
		if (!isgraph(ch)) {
			switch (ch) {
			case BS:		/* can't go back further */
				if (cur_col == 0)
					continue;
				--cur_col;
				continue;
			case CR:
				cur_col = 0;
				continue;
			case ESC:		/* just ignore EOF */
				/*
				 * In the input stream, accept both the
				 * XPG5 sequences ESC-digit and the
				 * traditional BSD sequences ESC-ctrl.
				 */
				switch(getchar()) {
				case '7':  /* reverse line feed */
					/* FALLTHROUGH */
				case '\007':
					addto_lineno(&cur_line, -2);
					break;
				case '8':  /* reverse half-line feed */
					/* FALLTHROUGH */
				case '\010':
					addto_lineno(&cur_line, -1);
					break;
				case '9':  /* forward half-line feed */
					/* FALLTHROUGH */
				case '\011':
					addto_lineno(&cur_line, 1);
					if (cur_line > max_line)
						max_line = cur_line;
				}
				continue;
			case NL:
				addto_lineno(&cur_line, 2);
				if (cur_line > max_line)
					max_line = cur_line;
				cur_col = 0;
				continue;
			case SPACE:
				++cur_col;
				continue;
			case SI:
				cur_set = CS_NORMAL;
				continue;
			case SO:
				cur_set = CS_ALTERNATE;
				continue;
			case TAB:		/* adjust column */
				cur_col |= 7;
				++cur_col;
				continue;
			case VT:
				addto_lineno(&cur_line, -2);
				continue;
			}
			continue;
		}

		/* Must stuff ch in a line - are we at the right one? */
		if (cur_line + adjust != this_line) {
			LINE *lnew;

			/* round up to next line */
			adjust = !fine && (cur_line & 1);

			if (cur_line + adjust < this_line) {
				while (cur_line + adjust < this_line &&
				    l->l_prev != NULL) {
					l = l->l_prev;
					this_line--;
				}
				if (cur_line + adjust < this_line) {
					if (nflushd_lines == 0) {
						/*
						 * Allow backup past first
						 * line if nothing has been
						 * flushed yet.
						 */
						while (cur_line + adjust
						    < this_line) {
							lnew = alloc_line();
							l->l_prev = lnew;
							lnew->l_next = l;
							l = lines = lnew;
							extra_lines++;
							this_line--;
						}
					} else {
						if (!warned++)
							dowarn(cur_line);
						cur_line = this_line - adjust;
					}
				}
			} else {
				/* may need to allocate here */
				while (cur_line + adjust > this_line) {
					if (l->l_next == NULL) {
						l->l_next = alloc_line();
						l->l_next->l_prev = l;
					}
					l = l->l_next;
					this_line++;
				}
			}
			if (this_line > nflushd_lines &&
			    this_line - nflushd_lines >=
			    max_bufd_lines + BUFFER_MARGIN) {
				if (extra_lines) {
					flush_lines(extra_lines);
					extra_lines = 0;
				}
				flush_lines(this_line - nflushd_lines -
				    max_bufd_lines);
				nflushd_lines = this_line - max_bufd_lines;
			}
		}
		/* grow line's buffer? */
		if (l->l_line_len + 1 >= l->l_lsize) {
			size_t need;

			need = l->l_lsize ? l->l_lsize : 45;
			l->l_line = xreallocarray(l->l_line,
			    need, 2 * sizeof(CHAR));
			l->l_lsize = need * 2;
		}
		c = &l->l_line[l->l_line_len++];
		c->c_char = ch;
		c->c_set = cur_set;
		c->c_column = cur_col;
		/*
		 * If things are put in out of order, they will need sorting
		 * when it is flushed.
		 */
		if (cur_col < l->l_max_col)
			l->l_needs_sort = 1;
		else
			l->l_max_col = cur_col;
		cur_col++;
	}
	if (extra_lines)
		flush_lines(extra_lines);

	/* goto the last line that had a character on it */
	for (; l->l_next; l = l->l_next)
		this_line++;
	flush_lines(this_line - nflushd_lines + 1);

	/* make sure we leave things in a sane state */
	if (last_set != CS_NORMAL)
		PUTC(SI);

	/* flush out the last few blank lines */
	if (max_line > this_line)
		nblank_lines = max_line - this_line;
	if (max_line & 1)
		nblank_lines++;
	flush_blanks();
	exit(0);
}

void
flush_lines(int nflush)
{
	LINE *l;

	while (--nflush >= 0) {
		l = lines;
		lines = l->l_next;
		if (l->l_line) {
			flush_blanks();
			flush_line(l);
		}
		if (l->l_line || l->l_next)
			nblank_lines++;
		if (l->l_line)
			(void)free((void *)l->l_line);
		free_line(l);
	}
	if (lines)
		lines->l_prev = NULL;
}

/*
 * Print a number of newline/half newlines.  If fine flag is set, nblank_lines
 * is the number of half line feeds, otherwise it is the number of whole line
 * feeds.
 */
void
flush_blanks(void)
{
	int half, i, nb;

	half = 0;
	nb = nblank_lines;
	if (nb & 1) {
		if (fine)
			half = 1;
		else
			nb++;
	}
	nb /= 2;
	for (i = nb; --i >= 0;)
		PUTC('\n');
	if (half) {
		/*
		 * In the output stream, always generate
		 * escape sequences conforming to XPG5.
		 */
		PUTC(ESC);
		PUTC('9');
		if (!nb)
			PUTC('\r');
	}
	nblank_lines = 0;
}

/*
 * Write a line to stdout taking care of space to tab conversion (-h flag)
 * and character set shifts.
 */
void
flush_line(LINE *l)
{
	CHAR *c, *endc;
	size_t nchars, last_col, this_col;

	last_col = 0;
	nchars = l->l_line_len;

	if (l->l_needs_sort) {
		static CHAR *sorted;
		static size_t count_size, i, sorted_size;
		static int *count, save, tot;

		/*
		 * Do an O(n) sort on l->l_line by column being careful to
		 * preserve the order of characters in the same column.
		 */
		if (l->l_lsize > sorted_size) {
			sorted_size = l->l_lsize;
			sorted = xreallocarray(sorted,
			    sorted_size, sizeof(CHAR));
		}
		if (l->l_max_col >= count_size) {
			count_size = l->l_max_col + 1;
			count = xreallocarray(count,
			    count_size, sizeof(int));
		}
		memset(count, 0, sizeof(*count) * (l->l_max_col + 1));
		for (i = nchars, c = l->l_line; i-- > 0; c++)
			count[c->c_column]++;

		/*
		 * calculate running total (shifted down by 1) to use as
		 * indices into new line.
		 */
		for (tot = 0, i = 0; i <= l->l_max_col; i++) {
			save = count[i];
			count[i] = tot;
			tot += save;
		}

		for (i = nchars, c = l->l_line; i-- > 0; c++)
			sorted[count[c->c_column]++] = *c;
		c = sorted;
	} else
		c = l->l_line;
	while (nchars > 0) {
		this_col = c->c_column;
		endc = c;
		do {
			++endc;
		} while (--nchars > 0 && this_col == endc->c_column);

		/* if -b only print last character */
		if (no_backspaces)
			c = endc - 1;

		if (this_col > last_col) {
			size_t nspace = this_col - last_col;

			if (compress_spaces && nspace > 1) {
				size_t ntabs;

				ntabs = ((last_col % 8) + nspace) / 8;
				if (ntabs) {
					nspace -= (ntabs * 8) - (last_col % 8);
					while (ntabs-- > 0)
						PUTC('\t');
				}
			}
			while (nspace-- > 0)
				PUTC(' ');
			last_col = this_col;
		}
		last_col++;

		for (;;) {
			if (c->c_set != last_set) {
				switch (c->c_set) {
				case CS_NORMAL:
					PUTC(SI);
					break;
				case CS_ALTERNATE:
					PUTC(SO);
				}
				last_set = c->c_set;
			}
			PUTC(c->c_char);
			if (++c >= endc)
				break;
			PUTC('\b');
		}
	}
}

/*
 * Increment or decrement a line number, checking for overflow.
 * Stop one below INT_MAX such that the adjust variable is safe.
 */
void
addto_lineno(int *lno, int offset)
{
	if (offset > 0) {
		if (*lno >= INT_MAX - offset)
			errx(1, "too many lines");
	} else {
		if (*lno < INT_MIN - offset)
			errx(1, "too many reverse line feeds");
	}
	*lno += offset;
}

#define	NALLOC 64

static LINE *line_freelist;

LINE *
alloc_line(void)
{
	LINE *l;
	int i;

	if (!line_freelist) {
		l = xreallocarray(NULL, NALLOC, sizeof(LINE));
		line_freelist = l;
		for (i = 1; i < NALLOC; i++, l++)
			l->l_next = l + 1;
		l->l_next = NULL;
	}
	l = line_freelist;
	line_freelist = l->l_next;

	memset(l, 0, sizeof(LINE));
	return (l);
}

void
free_line(LINE *l)
{

	l->l_next = line_freelist;
	line_freelist = l;
}

void *
xreallocarray(void *p, size_t n, size_t size)
{

	if (!(p = reallocarray(p, n, size)))
		err(1, "realloc failed");
	return (p);
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: col [-bfhx] [-l num]\n");
	exit(1);
}

void
dowarn(int line)
{

	warnx("warning: can't back up %s",
		line < 0 ? "past first line" : "-- line already flushed");
}
@


1.18
log
@col can be locked down with tame "stdio", in case it is fed nasty input,
or if it has bugs.  The previous commits by schwarze indicate the latter
case was very true until recently...
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.17 2015/05/09 20:36:18 schwarze Exp $	*/
d116 2
a117 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.17
log
@For half and reverse line feeds, recognize SUSv2-style escape-digit
sequences in the input stream in addition to traditional BSD-style
escape-control-char sequences because traditional tools, for example
Heirloom roff, produce SUSv2-style sequences.  Switch the encoding
of forward half line feeds in the output of -f back to SUSv2 style
because that's likely to work with more tools than the non-standard
traditional BSD-style sequence.  Fully document these choices.

Issues originally reported by bapt at FreeBSD.
OK millert@@ jmc@@, and bapt@@ also more or less agrees with the direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.16 2015/05/08 16:30:07 schwarze Exp $	*/
d115 3
@


1.16
log
@Avoid scattering octal escapes all over the place,
use the definitions given at the top of the file.
No functional change.
From bapt at FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.15 2015/05/08 12:30:27 schwarze Exp $	*/
a52 3
#define	RLF	'\007'		/* ESC-07 reverse line feed */
#define	RHLF	'\010'		/* ESC-010 reverse half-line feed */
#define	FHLF	'\011'		/* ESC-011 forward half-line feed */
d165 5
d171 3
a173 1
				case RLF:
d176 3
a178 1
				case RHLF:
d181 3
a183 1
				case FHLF:
d361 4
d366 1
a366 1
		PUTC('\011');
@


1.15
log
@Fix about ten integer overflows and underflows and a handful of logic
errors in line number handling.  Detailed explanations were sent to tech@@
on October 18, 2014.
OK doug@@, and bapt at FreeBSD says he likes the direction
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.14 2014/10/17 21:27:10 schwarze Exp $	*/
d298 1
a298 1
		PUTC('\017');
d353 1
a353 1
		PUTC('\033');
d446 1
a446 1
					PUTC('\017');
d449 1
a449 1
					PUTC('\016');
@


1.14
log
@Correctly encode half line feed in the output stream for -f;
this patch only changes two bits, note that '\011' != '9' == '\071'.
Bug introduced by the original author, Michael Rendell, and
committed by Keith Bostic on May 22, 1990 (CSRG SCCS rev. 5.1).

The following operating systems are affected: 4.3BSD Reno, BSD Net/2,
4.4BSD, 4.4BSD Lite1, 4.4BSD Lite2, and all versions of 386BSD,
NetBSD, OpenBSD, FreeBSD, DragonFly, Debian GNU/Linux (package
bsdmainutils) and probably many others.

"that's a fun one" millert@@, "nice find" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.13 2014/10/16 13:45:12 schwarze Exp $	*/
d81 1
d95 1
a95 1
int	max_bufd_lines;		/* max # lines to keep in memory */
d119 1
a119 1
	max_bufd_lines = 128;
d133 2
a134 1
			max_bufd_lines = strtonum(optarg, 1, INT_MAX, &errstr);
a149 3
	/* this value is in half lines */
	max_bufd_lines *= 2;

d170 1
a170 1
					cur_line -= 2;
d173 1
a173 1
					cur_line--;
d176 1
a176 1
					cur_line++;
d182 1
a182 1
				cur_line += 2;
d201 1
a201 1
				cur_line -= 2;
d208 1
a208 1
		if (cur_line != this_line - adjust) {
a209 1
			int nmove;
d211 8
a218 7
			adjust = 0;
			nmove = cur_line - this_line;
			if (!fine) {
				/* round up to next line */
				if (cur_line & 1) {
					adjust = 1;
					nmove++;
d220 1
a220 5
			}
			if (nmove < 0) {
				for (; nmove < 0 && l->l_prev; nmove++)
					l = l->l_prev;
				if (nmove) {
d227 2
a228 1
						for (; nmove < 0; nmove++) {
d234 1
d239 1
a239 1
						cur_line -= nmove;
d244 5
a248 1
				for (; nmove > 0 && l->l_next; nmove--)
d250 1
a250 5
				for (; nmove > 0; nmove--) {
					lnew = alloc_line();
					lnew->l_prev = l;
					l->l_next = lnew;
					l = lnew;
d253 10
a262 5
			this_line = cur_line + adjust;
			nmove = this_line - nflushd_lines;
			if (nmove >= max_bufd_lines + BUFFER_MARGIN) {
				nflushd_lines += nmove - max_bufd_lines;
				flush_lines(nmove - max_bufd_lines);
d288 2
a289 2
	if (max_line == 0)
		exit(0);	/* no lines, so just exit */
d294 1
a294 1
	flush_lines(this_line - nflushd_lines + extra_lines + 1);
d301 2
a302 1
	nblank_lines = max_line - this_line;
a304 3
	else if (!nblank_lines)
		/* missing a \n on the last line? */
		nblank_lines = 2;
d321 2
a322 1
		nblank_lines++;
d459 17
@


1.13
log
@1) Fix a segfault triggered by an input line containing two consecutive
backspace characters beyond column MAX_SHRT, overflowing c_column.
2) Fix imcomplete initialization of the final element of the *count
array by adding a missing pair of parentheses.
3) For code clarity and extra safety, change all variables dealing
with column numbers from int to size_t such that they cannot overflow.
Found while reviewing the patch from deraadt@@'s reallocarray() rampage.
Feedback and OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.12 2014/10/08 19:59:58 deraadt Exp $	*/
d353 1
a353 1
		PUTC('9');
@


1.12
log
@use the reallocarray idiom; ok ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.11 2009/10/27 23:59:36 deraadt Exp $	*/
d65 1
a65 1
	short		c_column;	/* column character is in */
d75 3
a77 2
	int	l_lsize;		/* allocated sizeof l_line */
	int	l_line_len;		/* strlen(l_line) */
a78 1
	int	l_max_col;		/* max column in the line */
d110 1
a110 1
	int cur_col;			/* current column */
d151 2
a152 1
	adjust = cur_col = extra_lines = warned = 0;
d265 1
a265 1
			int need;
d368 1
a368 1
	int nchars, last_col, this_col;
d375 2
a376 1
		static int count_size, *count, i, save, sorted_size, tot;
d392 2
a393 2
		memset((char *)count, 0, sizeof(int) * l->l_max_col + 1);
		for (i = nchars, c = l->l_line; --i >= 0; c++)
d406 1
a406 1
		for (i = nchars, c = l->l_line; --i >= 0; c++)
d423 1
a423 1
			int nspace = this_col - last_col;
d426 1
a426 1
				int ntabs;
d431 1
a431 1
					while (--ntabs >= 0)
d435 1
a435 1
			while (--nspace >= 0)
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.10 2007/05/01 01:26:19 jdixon Exp $	*/
d88 1
a88 1
void   *xmalloc(void *, size_t);
d266 4
a269 4
			need = l->l_lsize ? l->l_lsize * 2 : 90;
			l->l_line = (CHAR *)xmalloc((void *) l->l_line,
			    (unsigned) need * sizeof(CHAR));
			l->l_lsize = need;
d382 2
a383 2
			sorted = (CHAR *)xmalloc((void *)sorted,
			    (unsigned)sizeof(CHAR) * sorted_size);
d387 2
a388 2
			count = (int *)xmalloc((void *)count,
			    (unsigned)sizeof(int) * count_size);
d469 1
a469 1
		l = (LINE *)xmalloc(NULL, sizeof(LINE) * NALLOC);
d491 1
a491 1
xmalloc(void *p, size_t size)
d494 1
a494 1
	if (!(p = (void *)realloc(p, size)))
@


1.10
log
@use strtonum; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.9 2003/06/10 22:20:45 deraadt Exp $	*/
a34 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1990, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)col.c	8.5 (Berkeley) 5/4/95";
#endif
static char rcsid[] = "$OpenBSD: col.c,v 1.9 2003/06/10 22:20:45 deraadt Exp $";
#endif /* not lint */
@


1.9
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.8 2003/06/03 02:56:06 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: col.c,v 1.8 2003/06/03 02:56:06 millert Exp $";
d55 1
d129 1
d145 4
a148 5
			if ((max_bufd_lines = atoi(optarg)) <= 0) {
				(void)fprintf(stderr,
				    "col: bad -l argument %s.\n", optarg);
				exit(1);
			}
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.7 2002/02/16 21:27:45 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: col.c,v 1.7 2002/02/16 21:27:45 millert Exp $";
d115 1
a115 3
main(argc, argv)
	int argc;
	char **argv;
d321 1
a321 2
flush_lines(nflush)
	int nflush;
d347 1
a347 1
flush_blanks()
d376 1
a376 2
flush_line(l)
	LINE *l;
d475 1
a475 1
alloc_line()
d495 1
a495 2
free_line(l)
	LINE *l;
d503 1
a503 3
xmalloc(p, size)
	void *p;
	size_t size;
d512 1
a512 1
usage()
d519 1
a519 2
dowarn(line)
	int line;
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.6 2000/11/21 18:15:09 aaron Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: col.c,v 1.6 2000/11/21 18:15:09 aaron Exp $";
@


1.6
log
@Sync usage() output with man page; mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.5 1997/07/25 21:30:12 mickey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: col.c,v 1.5 1997/07/25 21:30:12 mickey Exp $";
d97 8
a104 8
LINE   *alloc_line __P((void));
void	dowarn __P((int));
void	flush_line __P((LINE *));
void	flush_lines __P((int));
void	flush_blanks __P((void));
void	free_line __P((LINE *));
void	usage __P((void));
void   *xmalloc __P((void *, size_t));
@


1.5
log
@use err(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.4 1997/06/17 20:53:58 kstailey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: col.c,v 1.4 1997/06/17 20:53:58 kstailey Exp $";
d525 1
a525 2

	(void)fprintf(stderr, "usage: col [-bfx] [-l nline]\n");
@


1.4
log
@(foo *)NULL -> NULL + err msg for realloc failure
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.3 1997/01/15 23:42:20 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: col.c,v 1.3 1997/01/15 23:42:20 millert Exp $";
a103 1
void	wrerr __P((void));
d116 1
a116 1
		wrerr();
a526 8
	exit(1);
}

void
wrerr()
{

	(void)fprintf(stderr, "col: write error.\n");
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.2 1996/06/26 05:32:10 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: col.c,v 1.2 1996/06/26 05:32:10 deraadt Exp $";
d490 1
a490 1
		l = (LINE *)xmalloc((void *)NULL, sizeof(LINE) * NALLOC);
d519 1
a519 1
		err(1, NULL);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: col.c,v 1.7 1995/09/02 05:48:50 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: col.c,v 1.7 1995/09/02 05:48:50 jtc Exp $";
d138 1
a138 1
	while ((opt = getopt(argc, argv, "bfhl:x")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: col.c,v 1.7 1995/09/02 05:48:50 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
