head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.6
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.8
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.12
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.10
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2017.02.22.14.09.09;	author tom;	state Exp;
branches;
next	1.31;
commitid	nAPt4vmnn9AFX7cB;

1.31
date	2017.01.21.10.05.23;	author krw;	state Exp;
branches;
next	1.30;
commitid	2TCnu9GSdnkxWFXU;

1.30
date	2017.01.20.10.26.16;	author krw;	state Exp;
branches;
next	1.29;
commitid	Pe0EG0ahmNlf0T9t;

1.29
date	2016.10.11.19.27.39;	author martijn;	state Exp;
branches;
next	1.28;
commitid	uIGOQvb1uQGcEWzC;

1.28
date	2016.05.30.18.10.29;	author martijn;	state Exp;
branches;
next	1.27;
commitid	xRqKL9iXOMbpDX7P;

1.27
date	2015.10.26.14.08.47;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	ksSlO3H6uvWUGQLY;

1.26
date	2015.07.20.18.24.15;	author jasper;	state Exp;
branches;
next	1.25;
commitid	6520Ru6g0NkYHjek;

1.25
date	2015.07.19.17.21.21;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	ggtlRbxIQ1u8wK90;

1.24
date	2015.07.17.20.38.57;	author jasper;	state Exp;
branches;
next	1.23;
commitid	gIxBwsB4DhHv7II6;

1.23
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	6b2lLILbgCR1fvia;

1.22
date	2015.04.13.05.11.23;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	1HsMYADrlCUVu9eX;

1.21
date	2014.12.12.03.22.35;	author jsg;	state Exp;
branches;
next	1.20;
commitid	z6LBlmtBOebdqj7i;

1.20
date	2014.12.01.06.37.25;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	WKV8chPEisRdx6Iw;

1.19
date	2013.11.28.18.24.55;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2011.09.17.15.29.19;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.26.08.47.07;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.24.13.59.15;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.07.21.51.37;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.09.00.23.57;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.07.02.58.23;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.10.22.20.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.11.06.16.36;	author jsyn;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.15.21.47.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	99.06.06.15.42.24;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.04.30.06.21.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.09.11.11.21.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Remove unused-with-dead-store variable oldpsanl.

From Daniel Cegielka - thanks

ok jca@@
@
text
@/*	$OpenBSD: process.c,v 1.31 2017/01/21 10:05:23 krw Exp $	*/

/*-
 * Copyright (c) 1992 Diomidis Spinellis.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Diomidis Spinellis of Imperial College, University of London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "defs.h"
#include "extern.h"

static SPACE HS, PS, SS;
#define	pd		PS.deleted
#define	ps		PS.space
#define	psl		PS.len
#define	psanl		PS.append_newline
#define	hs		HS.space
#define	hsl		HS.len

static inline int	 applies(struct s_command *);
static void		 flush_appends(void);
static void		 lputs(char *);
static inline int	 regexec_e(regex_t *, const char *, int, int, size_t,
			     size_t);
static void		 regsub(SPACE *, char *, char *);
static int		 substitute(struct s_command *);

struct s_appends *appends;	/* Array of pointers to strings to append. */
static int appendx;		/* Index into appends array. */
size_t appendnum;		/* Size of appends array. */

static int lastaddr;		/* Set by applies if last address of a range. */
static int sdone;		/* If any substitutes since last line input. */
				/* Iov structure for 'w' commands. */
static regex_t *defpreg;
size_t maxnsub;
regmatch_t *match;

#define OUT() do {\
	fwrite(ps, 1, psl, outfile);\
	if (psanl) fputc('\n', outfile);\
} while (0)

void
process(void)
{
	struct s_command *cp;
	SPACE tspace;
	size_t len, oldpsl;
	char *p;

	for (linenum = 0; mf_fgets(&PS, REPLACE);) {
		pd = 0;
top:
		cp = prog;
redirect:
		while (cp != NULL) {
			if (!applies(cp)) {
				cp = cp->next;
				continue;
			}
			switch (cp->code) {
			case '{':
				cp = cp->u.c;
				goto redirect;
			case 'a':
				if (appendx >= appendnum) {
					appends = xreallocarray(appends,
					    appendnum,
					    2 * sizeof(struct s_appends));
					appendnum *= 2;
				}
				appends[appendx].type = AP_STRING;
				appends[appendx].s = cp->t;
				appends[appendx].len = strlen(cp->t);
				appendx++;
				break;
			case 'b':
				cp = cp->u.c;
				goto redirect;
			case 'c':
				pd = 1;
				psl = 0;
				if (cp->a2 == NULL || lastaddr || lastline())
					(void)fprintf(outfile, "%s", cp->t);
				break;
			case 'd':
				pd = 1;
				goto new;
			case 'D':
				if (pd)
					goto new;
				if (psl == 0 ||
				    (p = memchr(ps, '\n', psl)) == NULL) {
					pd = 1;
					goto new;
				} else {
					psl -= (p + 1) - ps;
					memmove(ps, p + 1, psl);
					goto top;
				}
			case 'g':
				cspace(&PS, hs, hsl, REPLACE);
				break;
			case 'G':
				cspace(&PS, "\n", 1, 0);
				cspace(&PS, hs, hsl, 0);
				break;
			case 'h':
				cspace(&HS, ps, psl, REPLACE);
				break;
			case 'H':
				cspace(&HS, "\n", 1, 0);
				cspace(&HS, ps, psl, 0);
				break;
			case 'i':
				(void)fprintf(outfile, "%s", cp->t);
				break;
			case 'l':
				lputs(ps);
				break;
			case 'n':
				if (!nflag && !pd)
					OUT();
				flush_appends();
				if (!mf_fgets(&PS, REPLACE))
					exit(0);
				pd = 0;
				break;
			case 'N':
				flush_appends();
				cspace(&PS, "\n", 1, 0);
				if (!mf_fgets(&PS, 0))
					exit(0);
				break;
			case 'p':
				if (pd)
					break;
				OUT();
				break;
			case 'P':
				if (pd)
					break;
				if ((p = memchr(ps, '\n', psl)) != NULL) {
					oldpsl = psl;
					psl = p - ps;
					psanl = 1;
					OUT();
					psl = oldpsl;
				} else {
					OUT();
				}
				break;
			case 'q':
				if (!nflag && !pd)
					OUT();
				flush_appends();
				exit(0);
			case 'r':
				if (appendx >= appendnum) {
					appends = xreallocarray(appends,
					    appendnum,
					    2 * sizeof(struct s_appends));
					appendnum *= 2;
				}
				appends[appendx].type = AP_FILE;
				appends[appendx].s = cp->t;
				appends[appendx].len = strlen(cp->t);
				appendx++;
				break;
			case 's':
				sdone |= substitute(cp);
				break;
			case 't':
				if (sdone) {
					sdone = 0;
					cp = cp->u.c;
					goto redirect;
				}
				break;
			case 'w':
				if (pd)
					break;
				if (cp->u.fd == -1 && (cp->u.fd = open(cp->t,
				    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
				    DEFFILEMODE)) == -1)
					error(FATAL, "%s: %s",
					    cp->t, strerror(errno));
				if (write(cp->u.fd, ps, psl) != psl ||
				    write(cp->u.fd, "\n", 1) != 1)
					error(FATAL, "%s: %s",
					    cp->t, strerror(errno));
				break;
			case 'x':
				if (hs == NULL)
					cspace(&HS, "", 0, REPLACE);
				tspace = PS;
				PS = HS;
				psanl = tspace.append_newline;
				HS = tspace;
				break;
			case 'y':
				if (pd || psl == 0)
					break;
				for (p = ps, len = psl; len--; ++p)
					*p = cp->u.y[(unsigned char)*p];
				break;
			case ':':
			case '}':
				break;
			case '=':
				(void)fprintf(outfile, "%lu\n", linenum);
			}
			cp = cp->next;
		} /* for all cp */

new:		if (!nflag && !pd)
			OUT();
		flush_appends();
	} /* for all lines */
}

/*
 * TRUE if the address passed matches the current program state
 * (lastline, linenumber, ps).
 */
#define	MATCH(a)						\
	(a)->type == AT_RE ? regexec_e((a)->u.r, ps, 0, 1, 0, psl) :	\
	    (a)->type == AT_LINE ? linenum == (a)->u.l : lastline()

/*
 * Return TRUE if the command applies to the current line.  Sets the inrange
 * flag to process ranges.  Interprets the non-select (``!'') flag.
 */
static inline int
applies(struct s_command *cp)
{
	int r;

	lastaddr = 0;
	if (cp->a1 == NULL && cp->a2 == NULL)
		r = 1;
	else if (cp->a2)
		if (cp->inrange) {
			if (MATCH(cp->a2)) {
				cp->inrange = 0;
				lastaddr = 1;
			}
			r = 1;
		} else if (MATCH(cp->a1)) {
			/*
			 * If the second address is a number less than or
			 * equal to the line number first selected, only
			 * one line shall be selected.
			 *	-- POSIX 1003.2
			 */
			if (cp->a2->type == AT_LINE &&
			    linenum >= cp->a2->u.l)
				lastaddr = 1;
			else
				cp->inrange = 1;
			r = 1;
		} else
			r = 0;
	else
		r = MATCH(cp->a1);
	return (cp->nonsel ? !r : r);
}

/*
 * Reset all inrange markers.
 */
void
resetranges(void)
{
	struct s_command *cp;

	for (cp = prog; cp; cp = cp->code == '{' ? cp->u.c : cp->next)
		if (cp->a2)
			cp->inrange = 0;
}

/*
 * substitute --
 *	Do substitutions in the pattern space.  Currently, we build a
 *	copy of the new pattern space in the substitute space structure
 *	and then swap them.
 */
static int
substitute(struct s_command *cp)
{
	SPACE tspace;
	regex_t *re;
	regoff_t slen;
	int n, lastempty;
	size_t le = 0;
	char *s;

	s = ps;
	re = cp->u.s->re;
	if (re == NULL) {
		if (defpreg != NULL && cp->u.s->maxbref > defpreg->re_nsub) {
			linenum = cp->u.s->linenum;
			error(COMPILE, "\\%d not defined in the RE",
			    cp->u.s->maxbref);
		}
	}
	if (!regexec_e(re, ps, 0, 0, 0, psl))
		return (0);

	SS.len = 0;				/* Clean substitute space. */
	slen = psl;
	n = cp->u.s->n;
	lastempty = 1;

	do {
		/* Copy the leading retained string. */
		if (n <= 1 && (match[0].rm_so > le))
			cspace(&SS, s, match[0].rm_so - le, APPEND);

		/* Skip zero-length matches right after other matches. */
		if (lastempty || (match[0].rm_so - le) ||
		    match[0].rm_so != match[0].rm_eo) {
			if (n <= 1) {
				/* Want this match: append replacement. */
				regsub(&SS, ps, cp->u.s->new);
				if (n == 1)
					n = -1;
			} else {
				/* Want a later match: append original. */
				if (match[0].rm_eo - le)
					cspace(&SS, s, match[0].rm_eo - le,
					    APPEND);
				n--;
			}
		}

		/* Move past this match. */
		s = ps + match[0].rm_eo;
		slen = psl - match[0].rm_eo;
		le = match[0].rm_eo;

		/*
		 * After a zero-length match, advance one byte,
		 * and at the end of the line, terminate.
		 */
		if (match[0].rm_so == match[0].rm_eo) {
			if (*s == '\0' || *s == '\n')
				slen = -1;
			else
				slen--;
			if (*s != '\0') {
				cspace(&SS, s++, 1, APPEND);
				le++;
			}
			lastempty = 1;
		} else
			lastempty = 0;

	} while (n >= 0 && slen >= 0 &&
	    regexec_e(re, ps, REG_NOTBOL, 0, le, psl));

	/* Did not find the requested number of matches. */
	if (n > 0)
		return (0);

	/* Copy the trailing retained string. */
	if (slen > 0)
		cspace(&SS, s, slen, APPEND);

	/*
	 * Swap the substitute space and the pattern space, and make sure
	 * that any leftover pointers into stdio memory get lost.
	 */
	tspace = PS;
	PS = SS;
	psanl = tspace.append_newline;
	SS = tspace;
	SS.space = SS.back;

	/* Handle the 'p' flag. */
	if (cp->u.s->p)
		OUT();

	/* Handle the 'w' flag. */
	if (cp->u.s->wfile && !pd) {
		if (cp->u.s->wfd == -1 && (cp->u.s->wfd = open(cp->u.s->wfile,
		    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC, DEFFILEMODE)) == -1)
			error(FATAL, "%s: %s", cp->u.s->wfile, strerror(errno));
		if (write(cp->u.s->wfd, ps, psl) != psl ||
		    write(cp->u.s->wfd, "\n", 1) != 1)
			error(FATAL, "%s: %s", cp->u.s->wfile, strerror(errno));
	}
	return (1);
}

/*
 * Flush append requests.  Always called before reading a line,
 * therefore it also resets the substitution done (sdone) flag.
 */
static void
flush_appends(void)
{
	FILE *f;
	int count, i;
	char buf[8 * 1024];

	for (i = 0; i < appendx; i++)
		switch (appends[i].type) {
		case AP_STRING:
			fwrite(appends[i].s, sizeof(char), appends[i].len,
			    outfile);
			break;
		case AP_FILE:
			/*
			 * Read files probably shouldn't be cached.  Since
			 * it's not an error to read a non-existent file,
			 * it's possible that another program is interacting
			 * with the sed script through the file system.  It
			 * would be truly bizarre, but possible.  It's probably
			 * not that big a performance win, anyhow.
			 */
			if ((f = fopen(appends[i].s, "r")) == NULL)
				break;
			while ((count = fread(buf, sizeof(char), sizeof(buf), f)))
				(void)fwrite(buf, sizeof(char), count, outfile);
			(void)fclose(f);
			break;
		}
	if (ferror(outfile))
		error(FATAL, "%s: %s", outfname, strerror(errno ? errno : EIO));
	appendx = sdone = 0;
}

static void
lputs(char *s)
{
	int count;
	extern int termwidth;
	const char *escapes;
	char *p;

	for (count = 0; *s; ++s) {
		if (count >= termwidth) {
			(void)fprintf(outfile, "\\\n");
			count = 0;
		}
		if (isascii((unsigned char)*s) && isprint((unsigned char)*s)
		    && *s != '\\') {
			(void)fputc(*s, outfile);
			count++;
		} else if (*s == '\n') {
			(void)fputc('$', outfile);
			(void)fputc('\n', outfile);
			count = 0;
		} else {
			escapes = "\\\a\b\f\r\t\v";
			(void)fputc('\\', outfile);
			if ((p = strchr(escapes, *s))) {
				(void)fputc("\\abfrtv"[p - escapes], outfile);
				count += 2;
			} else {
				(void)fprintf(outfile, "%03o", *(u_char *)s);
				count += 4;
			}
		}
	}
	(void)fputc('$', outfile);
	(void)fputc('\n', outfile);
	if (ferror(outfile))
		error(FATAL, "%s: %s", outfname, strerror(errno ? errno : EIO));
}

static inline int
regexec_e(regex_t *preg, const char *string, int eflags,
    int nomatch, size_t start, size_t stop)
{
	int eval;

	if (preg == NULL) {
		if (defpreg == NULL)
			error(FATAL, "first RE may not be empty");
	} else
		defpreg = preg;

	/* Set anchors */
	match[0].rm_so = start;
	match[0].rm_eo = stop;

	eval = regexec(defpreg, string,
	    nomatch ? 0 : maxnsub + 1, match, eflags | REG_STARTEND);
	switch (eval) {
	case 0:
		return (1);
	case REG_NOMATCH:
		return (0);
	}
	error(FATAL, "RE error: %s", strregerror(eval, defpreg));
}

/*
 * regsub - perform substitutions after a regexp match
 * Based on a routine by Henry Spencer
 */
static void
regsub(SPACE *sp, char *string, char *src)
{
	int len, no;
	char c, *dst;

#define	NEEDSP(reqlen)							\
	if (sp->len + (reqlen) + 1 >= sp->blen) {			\
		size_t newlen = sp->blen + (reqlen) + 1024;		\
		sp->space = sp->back = xrealloc(sp->back, newlen);	\
		sp->blen = newlen;					\
		dst = sp->space + sp->len;				\
	}

	dst = sp->space + sp->len;
	while ((c = *src++) != '\0') {
		if (c == '&')
			no = 0;
		else if (c == '\\' && isdigit((unsigned char)*src))
			no = *src++ - '0';
		else
			no = -1;
		if (no < 0) {		/* Ordinary character. */
			if (c == '\\' && (*src == '\\' || *src == '&'))
				c = *src++;
			NEEDSP(1);
			*dst++ = c;
			++sp->len;
		} else if (match[no].rm_so != -1 && match[no].rm_eo != -1) {
			len = match[no].rm_eo - match[no].rm_so;
			NEEDSP(len);
			memmove(dst, string + match[no].rm_so, len);
			dst += len;
			sp->len += len;
		}
	}
	NEEDSP(1);
	*dst = '\0';
}

/*
 * aspace --
 *	Append the source space to the destination space, allocating new
 *	space as necessary.
 */
void
cspace(SPACE *sp, const char *p, size_t len, enum e_spflag spflag)
{
	size_t tlen;

	/* Make sure SPACE has enough memory and ramp up quickly. */
	tlen = sp->len + len + 1;
	if (tlen > sp->blen) {
		size_t newlen = tlen + 1024;
		sp->space = sp->back = xrealloc(sp->back, newlen);
		sp->blen = newlen;
	}

	if (spflag == REPLACE)
		sp->len = 0;

	memmove(sp->space + sp->len, p, len);

	sp->space[sp->len += len] = '\0';
}

/*
 * Close all cached opened files and report any errors
 */
void
cfclose(struct s_command *cp, struct s_command *end)
{

	for (; cp != end; cp = cp->next)
		switch (cp->code) {
		case 's':
			if (cp->u.s->wfd != -1 && close(cp->u.s->wfd))
				error(FATAL,
				    "%s: %s", cp->u.s->wfile, strerror(errno));
			cp->u.s->wfd = -1;
			break;
		case 'w':
			if (cp->u.fd != -1 && close(cp->u.fd))
				error(FATAL, "%s: %s", cp->t, strerror(errno));
			cp->u.fd = -1;
			break;
		case '{':
			cfclose(cp->u.c, cp->next);
			break;
		}
}
@


1.31
log
@Nuke more whitespace caught in the headlights of "warning:"
rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.30 2017/01/20 10:26:16 krw Exp $	*/
a91 1
	int oldpsanl;
a186 1
					oldpsanl = psanl;
@


1.30
log
@Split error() into error() and warning() so error() can be marked __dead to
appease gcc.

ok procter@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.29 2016/10/11 19:27:39 martijn Exp $	*/
d396 1
a396 1
			 	cspace(&SS, s++, 1, APPEND);
d571 2
a572 2
 			if (c == '\\' && (*src == '\\' || *src == '&'))
 				c = *src++;
d574 1
a574 1
 			*dst++ = c;
d576 1
a576 1
 		} else if (match[no].rm_so != -1 && match[no].rm_eo != -1) {
@


1.29
log
@Fix an off by one error when no matches were found in a substitute.
By pfg@@ from FreeBSD

OK millert@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.28 2016/05/30 18:10:29 martijn Exp $	*/
a541 1
	/* NOTREACHED */
@


1.28
log
@Make sed use the new REG_STARTEND | REG_NOTBOL combination. This fixes a begin
of word mismatch as reported by jsg@@.

Discussed with otto@@ and others early on, earlier version tested in ports build
by aja@@

OK millert@@
Few readability tweaks and OK schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.27 2015/10/26 14:08:47 mmcc Exp $	*/
d407 1
a407 1
	if (n > 1)
@


1.27
log
@Rename err() to error() to prevent confusion with the stdlib function.

Discussed with jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.26 2015/07/20 18:24:15 jasper Exp $	*/
d64 2
a65 1
static inline int	 regexec_e(regex_t *, const char *, int, int, size_t);
d271 1
a271 1
	(a)->type == AT_RE ? regexec_e((a)->u.r, ps, 0, 1, psl) :	\
d339 1
d351 1
a351 1
	if (!regexec_e(re, s, 0, 0, psl))
d361 2
a362 2
		if (n <= 1 && match[0].rm_so)
			cspace(&SS, s, match[0].rm_so, APPEND);
d365 1
a365 1
		if (lastempty || match[0].rm_so ||
d369 1
a369 1
				regsub(&SS, s, cp->u.s->new);
d374 3
a376 2
				if (match[0].rm_eo)
					cspace(&SS, s, match[0].rm_eo, APPEND);
d382 3
a384 2
		s += match[0].rm_eo;
		slen -= match[0].rm_eo;
d395 1
a395 1
			if (*s != '\0')
d397 2
d403 2
a404 1
	} while (n >= 0 && slen >= 0 && regexec_e(re, s, REG_NOTBOL, 0, slen));
d519 1
a519 1
    int nomatch, size_t slen)
d530 2
a531 2
	match[0].rm_so = 0;
	match[0].rm_eo = slen;
@


1.26
log
@fix eyesore whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.25 2015/07/19 17:21:21 deraadt Exp $	*/
d229 1
a229 1
					err(FATAL, "%s: %s",
d233 1
a233 1
					err(FATAL, "%s: %s",
d345 1
a345 1
			err(COMPILE, "\\%d not defined in the RE",
d425 1
a425 1
			err(FATAL, "%s: %s", cp->u.s->wfile, strerror(errno));
d428 1
a428 1
			err(FATAL, "%s: %s", cp->u.s->wfile, strerror(errno));
d467 1
a467 1
		err(FATAL, "%s: %s", outfname, strerror(errno ? errno : EIO));
d507 1
a507 1
		err(FATAL, "%s: %s", outfname, strerror(errno ? errno : EIO));
d518 1
a518 1
			err(FATAL, "first RE may not be empty");
d534 1
a534 1
	err(FATAL, "RE error: %s", strregerror(eval, defpreg));
d619 1
a619 1
				err(FATAL,
d625 1
a625 1
				err(FATAL, "%s: %s", cp->t, strerror(errno));
@


1.25
log
@figure out the linewidth at initialization, rather than late
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.24 2015/07/17 20:38:57 jasper Exp $	*/
d444 1
a444 1
	for (i = 0; i < appendx; i++) 
d447 1
a447 1
			fwrite(appends[i].s, sizeof(char), appends[i].len, 
d479 1
a479 1
	for (count = 0; *s; ++s) { 
d515 1
a515 1
	
d525 1
a525 1
	
@


1.24
log
@add -i flag to sed to do in-place editing; mostly based on freebsd

feedback/ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.23 2015/04/18 18:28:37 deraadt Exp $	*/
a37 1
#include <sys/ioctl.h>
d475 1
a477 17
	struct winsize win;
	static int termwidth = -1;

	if (outfile != stdout)
		termwidth = 60;

	if (termwidth == -1) {
		termwidth = 0;
		if ((p = getenv("COLUMNS")))
			termwidth = strtonum(p, 0, INT_MAX, NULL);
		if (termwidth == 0 &&
		    ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
		    win.ws_col > 0)
			termwidth = win.ws_col;
		if (termwidth == 0)
			termwidth = 60;
	}
@


1.23
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.22 2015/04/13 05:11:23 deraadt Exp $	*/
d58 1
d80 4
a83 1
#define OUT(s) do { fwrite(s, sizeof(u_char), psl, stdout); } while (0)
d92 1
d126 2
a127 2
				if (cp->a2 == NULL || lastaddr)
					(void)printf("%s", cp->t);
d136 1
a136 1
				    (p = memchr(ps, '\n', psl - 1)) == NULL) {
d148 1
a148 2
				if (hs == NULL)
					cspace(&HS, "\n", 1, REPLACE);
d155 1
d159 1
a159 1
				(void)printf("%s", cp->t);
d166 1
a166 1
					OUT(ps);
d174 2
a175 3
				if (!mf_fgets(&PS, 0)) {
					if (!nflag && !pd)
						OUT(ps);
a176 1
				}
d181 1
a181 1
				OUT(ps);
d186 1
a186 2
				if (psl != 0 &&
				    (p = memchr(ps, '\n', psl - 1)) != NULL) {
d188 4
a191 2
					psl = (p + 1) - ps;
					OUT(ps);
d194 1
a194 1
					OUT(ps);
d199 1
a199 1
					OUT(ps);
d232 2
a233 1
				if (write(cp->u.fd, ps, psl) != psl)
d239 1
a239 1
					cspace(&HS, "\n", 1, REPLACE);
d242 1
d248 1
a248 1
				for (p = ps, len = psl; --len; ++p)
d255 1
a255 1
				(void)printf("%lu\n", linenum);
d261 1
a261 1
			OUT(ps);
d272 1
a272 1
	    (a)->type == AT_LINE ? linenum == (a)->u.l : lastline
d314 13
d414 1
d420 1
a420 1
		OUT(ps);
d427 2
a428 1
		if (write(cp->u.s->wfd, ps, psl) != psl)
d449 1
a449 1
			    stdout);
d463 1
a463 1
				(void)fwrite(buf, sizeof(char), count, stdout);
d467 2
a468 2
	if (ferror(stdout))
		err(FATAL, "stdout: %s", strerror(errno ? errno : EIO));
d476 2
a477 1
	char *escapes, *p;
d481 3
d498 1
a498 1
			(void)printf("\\\n");
d503 1
a503 1
			(void)putchar(*s);
d505 5
a509 1
		} else if (*s != '\n') {
d511 1
a511 1
			(void)putchar('\\');
d513 1
a513 1
				(void)putchar("\\abfrtv"[p - escapes]);
d516 1
a516 1
				(void)printf("%03o", *(u_char *)s);
d521 4
a524 4
	(void)putchar('$');
	(void)putchar('\n');
	if (ferror(stdout))
		err(FATAL, "stdout: %s", strerror(errno ? errno : EIO));
d539 1
a539 3
	/* Set anchors, discounting trailing newline (if any). */
	if (slen > 0 && string[slen - 1] == '\n')
		slen--;
d605 1
a605 1
cspace(SPACE *sp, char *p, size_t len, enum e_spflag spflag)
@


1.22
log
@correct multiplication idiom during xreallocarray, and expand appendnum
to size_t to avoid overflow after allocation success
ok guenther doug
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.21 2014/12/12 03:22:35 jsg Exp $	*/
d460 1
d462 3
a464 2
			termwidth = atoi(p);
		else if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
d467 1
a467 1
		else
@


1.21
log
@Rework the pointer swap in the 'P' command to make the intent
clearer and avoid a crash on 'g;P' found by Sebastien Marie with
the afl fuzzer.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.20 2014/12/01 06:37:25 deraadt Exp $	*/
d70 1
a70 1
int appendnum;			/* Size of appends array. */
d106 2
a107 2
					    appendnum *= 2,
					    sizeof(struct s_appends));
d199 1
a199 1
				if (appendx >= appendnum)
d201 4
a204 2
					    appendnum *= 2,
					    sizeof(struct s_appends));
@


1.20
log
@sed has a xreallocarray(), but two n*s cases were not replaced
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.19 2013/11/28 18:24:55 deraadt Exp $	*/
d187 4
a191 3
				OUT(ps);
				if (p != NULL)
					psl = oldpsl;
@


1.19
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.18 2011/09/17 15:29:19 schwarze Exp $	*/
d105 3
a107 3
					appends = xrealloc(appends,
					    sizeof(struct s_appends) *
					    (appendnum * 2));
d199 3
a201 3
					appends = xrealloc(appends,
					    sizeof(struct s_appends) *
					    (appendnum *= 2));
@


1.18
log
@Rewrite the main loop of the "sed s/..." command, to fix multiple
issues regarding the replacement of zero-length strings.

This commit brings back rev. 1.16, but without the regression that
forced the backout:  No NUL bytes will be output now, not even when
the input file lacks a trailing newline character and there is a
zero-length match at the end.

OK otto@@ deraadt@@;
and naddy@@ (who originally found the regression) checked that
the regression is indeed fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.17 2011/07/26 08:47:07 schwarze Exp $	*/
d471 2
a472 1
		if (isascii(*s) && isprint(*s) && *s != '\\') {
d545 1
a545 1
		else if (c == '\\' && isdigit(*src))
@


1.17
log
@Backout previous, naddy@@ found the following regression:
When the input does not end in a trailing newline character
and there is an empty match at the end, the new code adds
a spurious '\0' character.
I have a fix, but otto@@ prefers backout and full re-evaluation
after release.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.16 2011/07/24 13:59:15 schwarze Exp $	*/
d315 1
a315 1
	size_t re_off, slen;
d336 10
a345 9
	switch (n) {
	case 0:					/* Global */
		do {
			if (lastempty || match[0].rm_so != match[0].rm_eo) {
				/* Locate start of replaced string. */
				re_off = match[0].rm_so;
				/* Copy leading retained string. */
				cspace(&SS, s, re_off, APPEND);
				/* Add in regular expression. */
d347 2
a348 7
			}

			/* Move past this match. */
			if (match[0].rm_so != match[0].rm_eo) {
				s += match[0].rm_eo;
				slen -= match[0].rm_eo;
				lastempty = 0;
d350 4
a353 9
				if (match[0].rm_so == 0)
					cspace(&SS, s, match[0].rm_so + 1,
					    APPEND);
				else
					cspace(&SS, s + match[0].rm_so, 1,
					    APPEND);
				s += match[0].rm_so + 1;
				slen -= match[0].rm_so + 1;
				lastempty = 1;
a354 11
		} while (slen > 0 && regexec_e(re, s, REG_NOTBOL, 0, slen));
		/* Copy trailing retained string. */
		if (slen > 0)
			cspace(&SS, s, slen, APPEND);
		break;
	default:				/* Nth occurrence */
		while (--n) {
			s += match[0].rm_eo;
			slen -= match[0].rm_eo;
			if (!regexec_e(re, s, REG_NOTBOL, 0, slen))
				return (0);
d356 2
a357 9
		/* FALLTHROUGH */
	case 1:					/* 1st occurrence */
		/* Locate start of replaced string. */
		re_off = match[0].rm_so + (s - ps);
		/* Copy leading retained string. */
		cspace(&SS, ps, re_off, APPEND);
		/* Add in regular expression. */
		regsub(&SS, s, cp->u.s->new);
		/* Copy trailing retained string. */
d360 24
a384 2
		break;
	}
@


1.16
log
@Rewrite the main loop of the "sed s/..." command, shortening it by ten
lines and simplifying it by removing the switch statement implementing
/g, /1, and /2 separately and repetitively.
The idea to make the loop control variable slen, i.e. the length of the
string remaining to be processed, signed, and stay in the loop even when
slen == 0 (i.e. at the end of the string), lifted from FreeBSD by otto@@.
On i386, process.o shrinks by 440 bytes, and the sed binary by 23 bytes.

This fixes multiple aspects of the replacement of multiple (/g) or
specific (e.g. /2) instances of zero-length matches, both with BREs and
EREs, both with and without a trailing newline character on the input.

Feedback and OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.15 2009/10/27 23:59:43 deraadt Exp $	*/
d315 1
a315 1
	regoff_t slen;
d336 9
a344 10
	do {
		/* Copy the leading retained string. */
		if (n <= 1 && match[0].rm_so)
			cspace(&SS, s, match[0].rm_so, APPEND);

		/* Skip zero-length matches right after other matches. */
		if (lastempty || match[0].rm_so ||
		    match[0].rm_so != match[0].rm_eo) {
			if (n <= 1) {
				/* Want this match: append replacement. */
d346 7
a352 2
				if (n == 1)
					n = -1;
d354 9
a362 4
				/* Want a later match: append original. */
				if (match[0].rm_eo)
					cspace(&SS, s, match[0].rm_eo, APPEND);
				n--;
d364 11
d376 9
a384 2

		/* Move past this match. */
a386 23

		/*
		 * After a zero-length match, advance one byte,
		 * and at the end of the line, terminate.
		 */
		if (match[0].rm_so == match[0].rm_eo) {
			if (*s == '\n')
				slen = -1;
			else
				slen--;
			cspace(&SS, s++, 1, APPEND);
			lastempty = 1;
		} else
			lastempty = 0;

	} while (n >= 0 && slen >= 0 && regexec_e(re, s, REG_NOTBOL, 0, slen));

	/* Did not find the requested number of matches. */
	if (n > 1)
		return (0);

	/* Copy the trailing retained string. */
	if (slen > 0)
d388 2
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.14 2008/10/07 21:51:37 millert Exp $	*/
d315 1
a315 1
	size_t re_off, slen;
d336 10
a345 9
	switch (n) {
	case 0:					/* Global */
		do {
			if (lastempty || match[0].rm_so != match[0].rm_eo) {
				/* Locate start of replaced string. */
				re_off = match[0].rm_so;
				/* Copy leading retained string. */
				cspace(&SS, s, re_off, APPEND);
				/* Add in regular expression. */
d347 2
a348 7
			}

			/* Move past this match. */
			if (match[0].rm_so != match[0].rm_eo) {
				s += match[0].rm_eo;
				slen -= match[0].rm_eo;
				lastempty = 0;
d350 4
a353 9
				if (match[0].rm_so == 0)
					cspace(&SS, s, match[0].rm_so + 1,
					    APPEND);
				else
					cspace(&SS, s + match[0].rm_so, 1,
					    APPEND);
				s += match[0].rm_so + 1;
				slen -= match[0].rm_so + 1;
				lastempty = 1;
a354 11
		} while (slen > 0 && regexec_e(re, s, REG_NOTBOL, 0, slen));
		/* Copy trailing retained string. */
		if (slen > 0)
			cspace(&SS, s, slen, APPEND);
		break;
	default:				/* Nth occurrence */
		while (--n) {
			s += match[0].rm_eo;
			slen -= match[0].rm_eo;
			if (!regexec_e(re, s, REG_NOTBOL, 0, slen))
				return (0);
d356 2
a357 9
		/* FALLTHROUGH */
	case 1:					/* 1st occurrence */
		/* Locate start of replaced string. */
		re_off = match[0].rm_so + (s - ps);
		/* Copy leading retained string. */
		cspace(&SS, ps, re_off, APPEND);
		/* Add in regular expression. */
		regsub(&SS, s, cp->u.s->new);
		/* Copy trailing retained string. */
d360 23
a383 2
		break;
	}
@


1.14
log
@The 'l' command should not encode newlines.  Also document that
backspace is escaped as \b.  OK phessler@@ and jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.13 2006/10/09 00:23:57 tedu Exp $	*/
a34 5

#ifndef lint
/* from: static char sccsid[] = "@@(#)process.c	8.1 (Berkeley) 6/6/93"; */
static const char rcsid[] = "$OpenBSD: process.c,v 1.13 2006/10/09 00:23:57 tedu Exp $";
#endif /* not lint */
@


1.13
log
@pretty.  the comma operator should not be used to cram two statements into
an if without braces, or worse, into a return.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.12 2003/11/07 02:58:23 tedu Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: process.c,v 1.12 2003/11/07 02:58:23 tedu Exp $";
d484 2
a485 2
		} else {
			escapes = "\\\a\b\f\n\r\t\v";
d488 1
a488 1
				(void)putchar("\\abfnrtv"[p - escapes]);
@


1.12
log
@prevent overflow, see freebsd r1.32.  also, do nicer reallocs.
ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.11 2003/06/10 22:20:51 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: process.c,v 1.11 2003/06/10 22:20:51 deraadt Exp $";
d84 1
a84 1
#define OUT(s) { fwrite(s, sizeof(u_char), psl, stdout); }
d166 1
a166 1
					OUT(ps)
d176 1
a176 1
						OUT(ps)
d183 1
a183 1
				OUT(ps)
d193 1
a193 1
				OUT(ps)
d199 1
a199 1
					OUT(ps)
d257 1
a257 1
			OUT(ps)
d306 1
a306 1
	return (cp->nonsel ? ! r : r);
d407 1
a407 1
		OUT(ps)
d466 1
a466 1
	if (termwidth == -1)
d474 1
d522 1
a522 1
	switch(eval) {
d610 1
a610 1
		switch(cp->code) {
@


1.11
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.10 2003/06/03 02:56:16 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: process.c,v 1.10 2003/06/03 02:56:16 millert Exp $";
d109 1
a109 1
				if (appendx >= appendnum)
d112 3
a114 1
					    (appendnum *= 2));
d542 4
a545 3
	if (sp->len >= sp->blen - (reqlen) - 1) {			\
		sp->blen += (reqlen) + 1024;				\
		sp->space = sp->back = xrealloc(sp->back, sp->blen);	\
d588 3
a590 2
		sp->blen = tlen + 1024;
		sp->space = sp->back = xrealloc(sp->back, sp->blen);
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.9 2002/06/11 06:16:36 jsyn Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: process.c,v 1.9 2002/06/11 06:16:36 jsyn Exp $";
d87 1
a87 1
process()
d273 1
a273 2
applies(cp)
	struct s_command *cp;
d314 1
a314 2
substitute(cp)
	struct s_command *cp;
d423 1
a423 1
flush_appends()
d457 1
a457 2
lputs(s)
	char *s;
d500 2
a501 5
regexec_e(preg, string, eflags, nomatch, slen)
	regex_t *preg;
	const char *string;
	int eflags, nomatch;
	size_t slen;
d534 1
a534 3
regsub(sp, string, src)
	SPACE *sp;
	char *string, *src;
d578 1
a578 5
cspace(sp, p, len, spflag)
	SPACE *sp;
	char *p;
	size_t len;
	enum e_spflag spflag;
d601 1
a601 2
cfclose(cp, end)
	struct s_command *cp, *end;
@


1.9
log
@kill err(3) newlines; ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.8 2002/04/15 21:47:45 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d38 1
a38 1
static char *rcsid = "$OpenBSD: process.c,v 1.8 2002/04/15 21:47:45 millert Exp $";
@


1.8
log
@Fix sed(1) in the case where a last line is specified and hold space
is not specified, and then the first part of the pattern space is
deleted, when there are two or more input lines, as this results
in subtraction of one from an unsigned integral value of '0'.  That
bogus value is used in one case for a loop (that will run far too
many times in this case) and a function to search for a value within
a specified range of memory, however now the range of memory is
obscenely large and a segmentation (or memory) fault will occur.
This is fixed by checking for and appropriately handling a nil
pattern space as if the specified search in memory failed, as indeed
it obviously will with nil pattern space.

From Tim J. Robbins by way of FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.7 2002/02/16 21:27:52 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: process.c,v 1.7 2002/02/16 21:27:52 millert Exp $";
d230 1
a230 1
					err(FATAL, "%s: %s\n",
d233 1
a233 1
					err(FATAL, "%s: %s\n",
d417 1
a417 1
			err(FATAL, "%s: %s\n", cp->u.s->wfile, strerror(errno));
d419 1
a419 1
			err(FATAL, "%s: %s\n", cp->u.s->wfile, strerror(errno));
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.6 2001/11/19 19:02:16 mpech Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: process.c,v 1.6 2001/11/19 19:02:16 mpech Exp $";
d137 2
a138 1
				if ((p = memchr(ps, '\n', psl - 1)) == NULL) {
d190 2
a191 1
				if ((p = memchr(ps, '\n', psl - 1)) != NULL) {
d244 1
a244 1
				if (pd)
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.5 1999/06/06 15:42:24 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: process.c,v 1.5 1999/06/06 15:42:24 deraadt Exp $";
d70 6
a75 6
static inline int	 applies __P((struct s_command *));
static void		 flush_appends __P((void));
static void		 lputs __P((char *));
static inline int	 regexec_e __P((regex_t *, const char *, int, int, size_t));
static void		 regsub __P((SPACE *, char *, char *));
static int		 substitute __P((struct s_command *));
@


1.5
log
@make G newline if hold is empty
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.4 1998/04/30 06:21:16 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: process.c,v 1.4 1998/04/30 06:21:16 deraadt Exp $";
d462 1
a462 1
	register char *s;
d464 2
a465 2
	register int count;
	register char *escapes, *p;
d546 2
a547 2
	register int len, no;
	register char c, *dst;
d616 1
a616 1
	register struct s_command *cp, *end;
@


1.4
log
@make y command 8 bit clean; Elmar.Bartel@@informatik.tu-muenchen.de
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.3 1997/09/11 11:21:07 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: process.c,v 1.3 1997/09/11 11:21:07 deraadt Exp $";
d149 2
@


1.3
log
@extra ()
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.2 1996/06/26 05:39:08 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: process.c,v 1.2 1996/06/26 05:39:08 deraadt Exp $";
d243 1
a243 1
					*p = cp->u.y[*p];
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: process.c,v 1.1.1.1 1995/10/18 08:46:05 deraadt Exp $";
d448 1
a448 1
			while (count = fread(buf, sizeof(char), sizeof(buf), f))
d468 1
a468 1
		if (p = getenv("COLUMNS"))
d487 1
a487 1
			if (p = strchr(escapes, *s)) {
@


1.1
log
@Initial revision
@
text
@d1 2
d42 1
a42 1
static char *rcsid = "$Id: process.c,v 1.17 1995/07/11 04:09:50 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
