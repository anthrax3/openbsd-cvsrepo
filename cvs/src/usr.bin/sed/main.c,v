head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.22
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.20
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.14
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.12
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2017.01.20.10.26.16;	author krw;	state Exp;
branches;
next	1.33;
commitid	Pe0EG0ahmNlf0T9t;

1.33
date	2016.07.14.08.31.18;	author semarie;	state Exp;
branches;
next	1.32;
commitid	X351wak6SvhlNPZD;

1.32
date	2016.03.17.05.27.10;	author bentley;	state Exp;
branches;
next	1.31;
commitid	0afdJPZPXUfvItJV;

1.31
date	2016.01.01.20.55.13;	author tb;	state Exp;
branches;
next	1.30;
commitid	k3PDg4pAKfXMhz6j;

1.30
date	2015.10.26.22.22.56;	author jca;	state Exp;
branches;
next	1.29;
commitid	3dLPacwGbMeN0lnn;

1.29
date	2015.10.26.14.08.47;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	ksSlO3H6uvWUGQLY;

1.28
date	2015.10.25.20.18.37;	author tobias;	state Exp;
branches;
next	1.27;
commitid	Ursbfsi509ItmKaf;

1.27
date	2015.10.10.20.18.30;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	QjQod45GFoW0lZGP;

1.26
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	sbrB3Q5CNxcwZpfU;

1.25
date	2015.10.03.00.58.59;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	SBOnl0qSwoH5Bgu9;

1.24
date	2015.07.19.17.21.21;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	ggtlRbxIQ1u8wK90;

1.23
date	2015.07.19.06.14.23;	author sthen;	state Exp;
branches;
next	1.22;
commitid	ySfcpTzad3wXKXlf;

1.22
date	2015.07.18.09.33.00;	author jmc;	state Exp;
branches;
next	1.21;
commitid	aH1OF2IXXENNlMOh;

1.21
date	2015.07.17.21.54.26;	author jasper;	state Exp;
branches;
next	1.20;
commitid	j8eXckLLUMDfK8uk;

1.20
date	2015.07.17.21.21.02;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	HhSxuzPMbLCqgBzA;

1.19
date	2015.07.17.20.38.57;	author jasper;	state Exp;
branches;
next	1.18;
commitid	gIxBwsB4DhHv7II6;

1.18
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.17;
commitid	9QOFSShUOtA0kQLF;

1.17
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.07.03.30.56;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.16.16.34.32;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.09.10.58.32;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.08.17.26.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.16.20.19.27;	author sobrado;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.20.06.07.57;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.09.00.23.57;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.10.22.20.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.02.56.16;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.13.15.47.11;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.23.22.40.42;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.43.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.39.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.21.21.50.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Split error() into error() and warning() so error() can be marked __dead to
appease gcc.

ok procter@@ deraadt@@
@
text
@/*	$OpenBSD: main.c,v 1.33 2016/07/14 08:31:18 semarie Exp $	*/

/*-
 * Copyright (c) 1992 Diomidis Spinellis.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Diomidis Spinellis of Imperial College, University of London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <regex.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <libgen.h>

#include "defs.h"
#include "extern.h"

/*
 * Linked list of units (strings and files) to be compiled
 */
struct s_compunit {
	struct s_compunit *next;
	enum e_cut {CU_FILE, CU_STRING} type;
	char *s;			/* Pointer to string or fname */
};

/*
 * Linked list pointer to compilation units and pointer to current
 * next pointer.
 */
static struct s_compunit *script, **cu_nextp = &script;

/*
 * Linked list of files to be processed
 */
struct s_flist {
	char *fname;
	struct s_flist *next;
};

/*
 * Linked list pointer to files and pointer to current
 * next pointer.
 */
static struct s_flist *files, **fl_nextp = &files;

FILE *infile;			/* Current input file */
FILE *outfile;			/* Current output file */

int Eflag, aflag, eflag, nflag;
static int rval;	/* Exit status */

/*
 * Current file and line number; line numbers restart across compilation
 * units, but span across input files.  The latter is optional if editing
 * in place.
 */
const char *fname;		/* File name. */
const char *outfname;		/* Output file name */
static char oldfname[PATH_MAX];	/* Old file name (for in-place editing) */
static char tmpfname[PATH_MAX];	/* Temporary file name (for in-place editing) */
char *inplace;			/* Inplace edit file extension */
u_long linenum;

static void add_compunit(enum e_cut, char *);
static void add_file(char *);
static int next_files_have_lines(void);

int termwidth;

int
main(int argc, char *argv[])
{
	struct winsize win;
	int c, fflag;
	char *p;

	fflag = 0;
	inplace = NULL;
	while ((c = getopt(argc, argv, "Eae:f:i::nru")) != -1)
		switch (c) {
		case 'E':
		case 'r':
			Eflag = 1;
			break;
		case 'a':
			aflag = 1;
			break;
		case 'e':
			eflag = 1;
			add_compunit(CU_STRING, optarg);
			break;
		case 'f':
			fflag = 1;
			add_compunit(CU_FILE, optarg);
			break;
		case 'i':
			inplace = optarg ? optarg : "";
			break;
		case 'n':
			nflag = 1;
			break;
		case 'u':
			setvbuf(stdout, NULL, _IOLBF, 0);
			break;
		default:
		case '?':
			(void)fprintf(stderr,
			    "usage: sed [-aEnru] [-i[extension]] command [file ...]\n"
			    "       sed [-aEnru] [-e command] [-f command_file] [-i[extension]] [file ...]\n");
			exit(1);
		}
	argc -= optind;
	argv += optind;

	termwidth = 0;
	if ((p = getenv("COLUMNS")) != NULL)
		termwidth = strtonum(p, 0, INT_MAX, NULL);
	if (termwidth == 0 && ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
	    win.ws_col > 0)
		termwidth = win.ws_col;
	if (termwidth == 0)
		termwidth = 80;

	if (inplace != NULL) {
		if (pledge("stdio rpath wpath cpath fattr chown", NULL) == -1)
			error(FATAL, "pledge: %s", strerror(errno));
	} else {
		if (pledge("stdio rpath wpath cpath", NULL) == -1)
			error(FATAL, "pledge: %s", strerror(errno));
	}

	/* First usage case; script is the first arg */
	if (!eflag && !fflag && *argv) {
		add_compunit(CU_STRING, *argv);
		argv++;
	}

	compile();

	/* Continue with first and start second usage */
	if (*argv)
		for (; *argv; argv++)
			add_file(*argv);
	else
		add_file(NULL);
	process();
	cfclose(prog, NULL);
	if (fclose(stdout))
		error(FATAL, "stdout: %s", strerror(errno));
	exit (rval);
}

/*
 * Like fgets, but go through the chain of compilation units chaining them
 * together.  Empty strings and files are ignored.
 */
char *
cu_fgets(char **outbuf, size_t *outsize)
{
	static enum {ST_EOF, ST_FILE, ST_STRING} state = ST_EOF;
	static FILE *f;		/* Current open file */
	static char *s;		/* Current pointer inside string */
	static char string_ident[30];
	size_t len;
	char *p;

	if (*outbuf == NULL)
		*outsize = 0;

again:
	switch (state) {
	case ST_EOF:
		if (script == NULL)
			return (NULL);
		linenum = 0;
		switch (script->type) {
		case CU_FILE:
			if ((f = fopen(script->s, "r")) == NULL)
				error(FATAL,
				    "%s: %s", script->s, strerror(errno));
			fname = script->s;
			state = ST_FILE;
			goto again;
		case CU_STRING:
			if ((snprintf(string_ident,
			    sizeof(string_ident), "\"%s\"", script->s)) >=
			    sizeof(string_ident))
				strlcpy(string_ident +
				    sizeof(string_ident) - 6, " ...\"", 5);
			fname = string_ident;
			s = script->s;
			state = ST_STRING;
			goto again;
		}
	case ST_FILE:
		if ((p = fgetln(f, &len)) != NULL) {
			linenum++;
			if (len >= *outsize) {
				free(*outbuf);
				*outsize = ROUNDLEN(len + 1);
				*outbuf = xmalloc(*outsize);
			}
			memcpy(*outbuf, p, len);
			(*outbuf)[len] = '\0';
			if (linenum == 1 && p[0] == '#' && p[1] == 'n')
				nflag = 1;
			return (*outbuf);
		}
		script = script->next;
		(void)fclose(f);
		state = ST_EOF;
		goto again;
	case ST_STRING:
		if (linenum == 0 && s[0] == '#' && s[1] == 'n')
			nflag = 1;
		p = *outbuf;
		len = *outsize;
		for (;;) {
			if (len <= 1) {
				*outbuf = xrealloc(*outbuf,
				    *outsize + _POSIX2_LINE_MAX);
				p = *outbuf + *outsize - len;
				len += _POSIX2_LINE_MAX;
				*outsize += _POSIX2_LINE_MAX;
			}
			switch (*s) {
			case '\0':
				state = ST_EOF;
				if (s == script->s) {
					script = script->next;
					goto again;
				} else {
					script = script->next;
					*p = '\0';
					linenum++;
					return (*outbuf);
				}
			case '\n':
				*p++ = '\n';
				*p = '\0';
				s++;
				linenum++;
				return (*outbuf);
			default:
				*p++ = *s++;
				len--;
			}
		}
	}

	return (NULL);
}

/*
 * Like fgets, but go through the list of files chaining them together.
 * Set len to the length of the line.
 */
int
mf_fgets(SPACE *sp, enum e_spflag spflag)
{
	struct stat sb;
	size_t len;
	char *p;
	int c, fd;
	static int firstfile;

	if (infile == NULL) {
		/* stdin? */
		if (files->fname == NULL) {
			if (inplace != NULL)
				error(FATAL, "-i may not be used with stdin");
			infile = stdin;
			fname = "stdin";
			outfile = stdout;
			outfname = "stdout";
		}

		firstfile = 1;
	}

	for (;;) {
		if (infile != NULL && (c = getc(infile)) != EOF) {
			(void)ungetc(c, infile);
			break;
		}
		/* If we are here then either eof or no files are open yet */
		if (infile == stdin) {
			sp->len = 0;
			return (0);
		}
		if (infile != NULL) {
			fclose(infile);
			if (*oldfname != '\0') {
				if (rename(fname, oldfname) != 0) {
					warning("rename()");
					unlink(tmpfname);
					exit(1);
				}
				*oldfname = '\0';
			}
			if (*tmpfname != '\0') {
				if (outfile != NULL && outfile != stdout)
					fclose(outfile);
				outfile = NULL;
				rename(tmpfname, fname);
				*tmpfname = '\0';
			}
			outfname = NULL;
		}
		if (firstfile == 0)
			files = files->next;
		else
			firstfile = 0;
		if (files == NULL) {
			sp->len = 0;
			return (0);
		}
		fname = files->fname;
		if (inplace != NULL) {
			if (lstat(fname, &sb) != 0)
				error(FATAL, "%s: %s", fname,
				    strerror(errno ? errno : EIO));
			if (!S_ISREG(sb.st_mode))
				error(FATAL, "%s: %s %s", fname,
				    "in-place editing only",
				    "works for regular files");
			if (*inplace != '\0') {
				strlcpy(oldfname, fname,
				    sizeof(oldfname));
				len = strlcat(oldfname, inplace,
				    sizeof(oldfname));
				if (len > sizeof(oldfname))
					error(FATAL, "%s: name too long", fname);
			}
			len = snprintf(tmpfname, sizeof(tmpfname), "%s/sedXXXXXXXXXX",
			    dirname(fname));
			if (len >= sizeof(tmpfname))
				error(FATAL, "%s: name too long", fname);
			if ((fd = mkstemp(tmpfname)) == -1)
				error(FATAL, "%s: %s", fname, strerror(errno));
			if ((outfile = fdopen(fd, "w")) == NULL) {
				unlink(tmpfname);
				error(FATAL, "%s", fname);
			}
			fchown(fileno(outfile), sb.st_uid, sb.st_gid);
			fchmod(fileno(outfile), sb.st_mode & ALLPERMS);
			outfname = tmpfname;
			linenum = 0;
			resetranges();
		} else {
			outfile = stdout;
			outfname = "stdout";
		}
		if ((infile = fopen(fname, "r")) == NULL) {
			warning("%s", strerror(errno));
			rval = 1;
			continue;
		}
	}

	/*
	 * We are here only when infile is open and we still have something
	 * to read from it.
	 *
	 * Use fgetln so that we can handle essentially infinite input data.
	 * Can't use the pointer into the stdio buffer as the process space
	 * because the ungetc() can cause it to move.
	 */
	p = fgetln(infile, &len);
	if (ferror(infile))
		error(FATAL, "%s: %s", fname, strerror(errno ? errno : EIO));
	if (len != 0 && p[len - 1] == '\n') {
		sp->append_newline = 1;
		len--;
	} else if (!lastline()) {
		sp->append_newline = 1;
	} else {
		sp->append_newline = 0;
	}
	cspace(sp, p, len, spflag);

	linenum++;

	return (1);
}

/*
 * Add a compilation unit to the linked list
 */
static void
add_compunit(enum e_cut type, char *s)
{
	struct s_compunit *cu;

	cu = xmalloc(sizeof(struct s_compunit));
	cu->type = type;
	cu->s = s;
	cu->next = NULL;
	*cu_nextp = cu;
	cu_nextp = &cu->next;
}

/*
 * Add a file to the linked list
 */
static void
add_file(char *s)
{
	struct s_flist *fp;

	fp = xmalloc(sizeof(struct s_flist));
	fp->next = NULL;
	*fl_nextp = fp;
	fp->fname = s;
	fl_nextp = &fp->next;
}


static int
next_files_have_lines()
{
	struct s_flist *file;
	FILE *file_fd;
	int ch;

	file = files;
	while ((file = file->next) != NULL) {
		if ((file_fd = fopen(file->fname, "r")) == NULL)
			continue;

		if ((ch = getc(file_fd)) != EOF) {
			/*
			 * This next file has content, therefore current
			 * file doesn't contains the last line.
			 */
			ungetc(ch, file_fd);
			fclose(file_fd);
			return (1);
		}
		fclose(file_fd);
	}
	return (0);
}

int
lastline(void)
{
	int ch;

	if (feof(infile)) {
		return !(
		    (inplace == NULL) &&
		    next_files_have_lines());
	}
	if ((ch = getc(infile)) == EOF) {
		return !(
		    (inplace == NULL) &&
		    next_files_have_lines());
	}
	ungetc(ch, infile);
	return (0);
}
@


1.33
log
@make several program to use "chown" promise.

it allows chown(2) call to change the user or group on a file.

- usr.bin/compress : aka gzip
- usr.bin/mg : open a file for writing
- usr.bin/sed : inplace editing
- usr.bin/sort : if outfile equals one of the input files

ok deraadt@@ tb@@

(and a reminder from Remi Locherer)

warning: in order to use it, you must have a recent kernel with the new
promise.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2016/03/17 05:27:10 bentley Exp $	*/
d288 2
a289 1
	/* NOTREACHED */
d333 1
a333 1
					error(WARNING, "rename()");
d393 1
a393 1
			error(WARNING, "%s", strerror(errno));
@


1.32
log
@Switch (non-curses, non-ksh) programs that use COLUMNS to a single idiom.

Previously behaviors were all over the map. This changes them to
use COLUMNS first, and either terminal width or a hardcoded value
(typically 80) as appropriate.

ok deraadt@@; man bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2016/01/01 20:55:13 tb Exp $	*/
d163 1
a163 1
		if (pledge("stdio rpath wpath cpath fattr", NULL) == -1)
@


1.31
log
@Improve error message for sed -i by appending strerror(errno).
From Michael Reed, thanks!

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2015/10/26 22:22:56 jca Exp $	*/
d153 2
a154 1
	if ((p = getenv("COLUMNS")))
d156 1
a156 2
	if (termwidth == 0 &&
	    ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
d160 1
a160 1
		termwidth = 60;
@


1.30
log
@Use error(FATAL) instead of what was previously err(1,...)

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2015/10/26 14:08:47 mmcc Exp $	*/
d377 1
a377 1
				error(FATAL, "%s", fname);
@


1.29
log
@Rename err() to error() to prevent confusion with the stdlib function.

Discussed with jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2015/10/25 20:18:37 tobias Exp $	*/
d164 1
a164 1
			error(1, "pledge");
d167 1
a167 1
			error(1, "pledge");
d358 1
a358 1
				error(1, "%s: %s", fname,
@


1.28
log
@Write error message instead of duplicated file name on error.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2015/10/10 20:18:30 deraadt Exp $	*/
d164 1
a164 1
			err(1, "pledge");
d167 1
a167 1
			err(1, "pledge");
d187 1
a187 1
		err(FATAL, "stdout: %s", strerror(errno));
d217 1
a217 1
				err(FATAL,
d308 1
a308 1
				err(FATAL, "-i may not be used with stdin");
d332 1
a332 1
					err(WARNING, "rename()");
d358 1
a358 1
				err(1, "%s: %s", fname,
d361 1
a361 1
				err(FATAL, "%s: %s %s", fname,
d370 1
a370 1
					err(FATAL, "%s: name too long", fname);
d375 1
a375 1
				err(FATAL, "%s: name too long", fname);
d377 1
a377 1
				err(FATAL, "%s", fname);
d380 1
a380 1
				err(FATAL, "%s", fname);
d392 1
a392 1
			err(WARNING, "%s", strerror(errno));
d408 1
a408 1
		err(FATAL, "%s: %s", fname, strerror(errno ? errno : EIO));
@


1.27
log
@normalize the ordering of tame requests (particularily, "rpath wpath cpath",
which i have put in that order). this is not important, but helps look
for outliers which might be strange.  it hints that "ioctl" should be
reassessed in a few places, to see if "tty" is better; that "unix" may
be used in some places where "route" could now work.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2015/10/09 01:37:08 deraadt Exp $	*/
d392 1
a392 1
			err(WARNING, "%s", fname);
@


1.26
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2015/10/03 00:58:59 deraadt Exp $	*/
d163 1
a163 1
		if (pledge("stdio wpath rpath cpath fattr", NULL) == -1)
d166 1
a166 1
		if (pledge("stdio wpath rpath cpath", NULL) == -1)
@


1.25
log
@sed only works on files, so the obvious goal is to remove it's network
access in case it is exploited.  tame with "stdio wpath rpath cpath"
seesms to covers all usage cases, except -i performs a fchmod() on the
in-place file, so conditionally also needs "fattr".
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2015/07/19 17:21:21 deraadt Exp $	*/
d163 2
a164 2
		if (tame("stdio wpath rpath cpath fattr", NULL) == -1)
			err(1, "tame");
d166 2
a167 2
		if (tame("stdio wpath rpath cpath", NULL) == -1)
			err(1, "tame");
@


1.24
log
@figure out the linewidth at initialization, rather than late
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2015/07/19 06:14:23 sthen Exp $	*/
d161 8
@


1.23
log
@Print strerror, not just the filename, if opening the inplace file fails.
ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2015/07/18 09:33:00 jmc Exp $	*/
d37 1
d106 2
d111 1
d113 1
d152 9
@


1.22
log
@various fixes; ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2015/07/17 21:54:26 jasper Exp $	*/
d336 2
a337 1
				err(1, "%s", fname);
@


1.21
log
@add missing prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2015/07/17 21:21:02 deraadt Exp $	*/
d141 2
a142 2
			    "usage: sed [-aEnru] [-i [extension]] command [file ...]\n"
			    "       sed [-aEnru] [-i [extension]] [-e command] [-f command_file] [file ...]\n");
@


1.20
log
@7 space indents??
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2015/07/17 20:38:57 jasper Exp $	*/
d103 1
@


1.19
log
@add -i flag to sed to do in-place editing; mostly based on freebsd

feedback/ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2014/11/26 18:34:51 millert Exp $	*/
d435 8
a442 18
       struct s_flist *file;
       FILE *file_fd;
       int ch;

       file = files;
       while ((file = file->next) != NULL) {
	       if ((file_fd = fopen(file->fname, "r")) == NULL)
		       continue;

	       if ((ch = getc(file_fd)) != EOF) {
		       /*
			* This next file has content, therefore current
			* file doesn't contains the last line.
			*/
		       ungetc(ch, file_fd);
		       fclose(file_fd);
		       return (1);
	       }
d444 12
a455 4
	       fclose(file_fd);
       }

       return (0);
@


1.18
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2009/10/27 23:59:43 deraadt Exp $	*/
d37 1
d49 1
d83 3
d87 1
d91 2
a92 1
 * units, but span across input files.
d94 5
a98 1
char *fname;			/* File name. */
a99 1
int lastline;			/* TRUE on the last line of the last file */
d110 2
a111 1
	while ((c = getopt(argc, argv, "Eae:f:nru")) != -1)
d128 3
d140 2
a141 2
			    "usage: sed [-aEnru] command [file ...]\n"
			    "       sed [-aEnru] [-e command] [-f command_file] [file ...]\n");
d165 1
a165 1
	exit (0);
d275 1
a275 1
	static FILE *f;		/* Current open file */
d278 16
a293 1
	int c;
d295 19
a313 6
	if (f == NULL)
		/* Advance to first non-empty file */
		for (;;) {
			if (files == NULL) {
				lastline = 1;
				return (0);
d315 6
a320 8
			if (files->fname == NULL) {
				f = stdin;
				fname = "stdin";
			} else {
				fname = files->fname;
				if ((f = fopen(fname, "r")) == NULL)
					err(FATAL, "%s: %s",
					    fname, strerror(errno));
d322 25
a346 3
			if ((c = getc(f)) != EOF) {
				(void)ungetc(c, f);
				break;
d348 23
a370 2
			(void)fclose(f);
			files = files->next;
a371 4

	if (lastline) {
		sp->len = 0;
		return (0);
d375 3
d382 2
a383 2
	p = fgetln(f, &len);
	if (ferror(f))
d385 8
d396 1
a396 18
	/* Advance to next non-empty file */
	while ((c = getc(f)) == EOF) {
		(void)fclose(f);
		files = files->next;
		if (files == NULL) {
			lastline = 1;
			return (1);
		}
		if (files->fname == NULL) {
			f = stdin;
			fname = "stdin";
		} else {
			fname = files->fname;
			if ((f = fopen(fname, "r")) == NULL)
				err(FATAL, "%s: %s", fname, strerror(errno));
		}
	}
	(void)ungetc(c, f);
d429 48
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2009/08/07 03:30:56 djm Exp $	*/
d121 1
a121 1
			setlinebuf(stdout);
@


1.16
log
@add -E flag to compile regular expressions using the extended POSIX
syntax. The -E flag is compatible with the other BSDs and OSX. -r is
also provided as an alias for compatibility with GNU sed.

feedback from jmc@@ and millert@@
ok millert@@ pyr@@ henning@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2008/10/16 16:34:32 millert Exp $	*/
a34 8

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
/* from: static char sccsid[] = "@@(#)main.c	8.2 (Berkeley) 1/3/94"; */
static const char rcsid[] = "$OpenBSD: main.c,v 1.15 2008/10/16 16:34:32 millert Exp $";
#endif /* not lint */
@


1.15
log
@Move memory allocation closer to where it is needed.  Also make
a distinction between len and size.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2008/10/09 10:58:32 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.14 2008/10/09 10:58:32 millert Exp $";
d89 1
a89 1
int aflag, eflag, nflag;
d108 1
a108 1
	while ((c = getopt(argc, argv, "ae:f:nu")) != -1)
d110 4
d134 2
a135 2
			    "usage: sed [-anu] command [file ...]\n"
			    "       sed [-anu] [-e command] [-f command_file] [file ...]\n");
@


1.14
log
@Don't strip newline when reading lines; matches the original behavior.
From otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2008/10/08 17:26:47 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.13 2008/10/08 17:26:47 millert Exp $";
d49 1
d163 1
a163 1
cu_fgets(char **outbuf, size_t *outlen)
d172 3
d203 1
a203 4
			if (len >= *outlen) {
				do {
					*outlen *= 2;
				} while (len >= *outlen);
d205 2
a206 1
				*outbuf = xmalloc(*outlen);
d222 1
a222 1
		len = *outlen;
d224 6
a229 5
			if (len-- <= 1) {
				*outbuf = xrealloc(*outbuf, *outlen * 2);
				p = *outbuf + *outlen - len - 1;
				len += *outlen;
				*outlen *= 2;
d251 1
@


1.13
log
@Allow sed to handle arbitrarily long lines.  Also plug a memory
leak noticed in the process.  Closes PR 5303.  OK otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2007/10/16 20:19:27 sobrado Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.12 2007/10/16 20:19:27 sobrado Exp $";
a198 2
			if (len > 0 && p[len-1] == '\n')
				len--;
@


1.12
log
@sync the synopsis and usage of commands

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2007/03/20 06:07:57 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.11 2007/03/20 06:07:57 ray Exp $";
d162 1
a162 1
cu_fgets(char *buf, int n)
d168 1
d197 1
a197 1
		if ((p = fgets(buf, n, f)) != NULL) {
d199 12
a210 1
			if (linenum == 1 && buf[0] == '#' && buf[1] == 'n')
d212 1
a212 1
			return (p);
d221 2
a222 1
		p = buf;
d224 5
a228 4
			if (n-- <= 1) {
				*p = '\0';
				linenum++;
				return (buf);
d240 1
a240 1
					return (buf);
d247 1
a247 1
				return (buf);
@


1.11
log
@Add line-buffering flag (-u).

OK deraadt@@ and jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2006/10/09 00:23:57 tedu Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.10 2006/10/09 00:23:57 tedu Exp $";
d129 2
a130 1
"usage:\tsed script [-anu] [file ...]\n\tsed [-anu] [-e script] ... [-f script_file] ... [file ...]\n");
@


1.10
log
@pretty.  the comma operator should not be used to cram two statements into
an if without braces, or worse, into a return.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2003/06/10 22:20:50 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.9 2003/06/10 22:20:50 deraadt Exp $";
d107 1
a107 1
	while ((c = getopt(argc, argv, "ae:f:n")) != -1)
d123 3
d129 1
a129 1
"usage:\tsed script [-an] [file ...]\n\tsed [-an] [-e script] ... [-f script_file] ... [file ...]\n");
@


1.9
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2003/06/03 02:56:16 millert Exp $	*/
d37 1
a37 1
static char copyright[] =
a39 3
#endif /* not lint */

#ifndef lint
d41 1
a41 1
static char *rcsid = "$OpenBSD: main.c,v 1.8 2003/06/03 02:56:16 millert Exp $";
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2003/03/13 15:47:11 deraadt Exp $	*/
d44 1
a44 1
static char *rcsid = "$OpenBSD: main.c,v 1.7 2003/03/13 15:47:11 deraadt Exp $";
d105 1
a105 3
main(argc, argv)
	int argc;
	char *argv[];
d161 1
a161 3
cu_fgets(buf, n)
	char *buf;
	int n;
d246 1
a246 3
mf_fgets(sp, spflag)
	SPACE *sp;
	enum e_spflag spflag;
d318 1
a318 3
add_compunit(type, s)
	enum e_cut type;
	char *s;
d334 1
a334 2
add_file(s)
	char *s;
@


1.7
log
@a few more strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2002/02/16 21:27:52 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static char *rcsid = "$OpenBSD: main.c,v 1.6 2002/02/16 21:27:52 millert Exp $";
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1998/06/23 22:40:42 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: main.c,v 1.5 1998/06/23 22:40:42 millert Exp $";
d195 2
a196 2
				(void)strcpy(string_ident +
				    sizeof(string_ident) - 6, " ...\"");
@


1.5
log
@Fix snprintf return value usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1997/01/15 23:43:12 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: main.c,v 1.4 1997/01/15 23:43:12 millert Exp $";
d105 2
a106 2
static void add_compunit __P((enum e_cut, char *));
static void add_file __P((char *));
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/06/26 05:39:07 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: main.c,v 1.3 1996/06/26 05:39:07 deraadt Exp $";
d194 1
a194 1
			    sizeof(string_ident) - 1)
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: main.c,v 1.2 1996/05/21 21:50:46 deraadt Exp $";
d116 1
a116 1
	while ((c = getopt(argc, argv, "ae:f:n")) != EOF)
@


1.2
log
@getc/ungetc use an int
@
text
@d1 2
d48 1
a48 1
static char *rcsid = "$Id: main.c,v 1.1.1.1 1995/10/18 08:46:05 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d46 1
a46 1
static char *rcsid = "$Id: main.c,v 1.7 1995/02/23 17:25:23 jtc Exp $";
d258 2
a259 1
	char c, *p;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
