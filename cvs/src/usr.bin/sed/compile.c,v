head	1.42;
access;
symbols
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.12
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.10
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.6
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.14
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2017.08.01.18.05.53;	author martijn;	state Exp;
branches;
next	1.41;
commitid	0d4IOtz5uSid3xaa;

1.41
date	2017.01.20.10.26.16;	author krw;	state Exp;
branches;
next	1.40;
commitid	Pe0EG0ahmNlf0T9t;

1.40
date	2015.10.26.22.24.44;	author jca;	state Exp;
branches;
next	1.39;
commitid	kN5Xwz13R25qi4WT;

1.39
date	2015.10.26.14.08.47;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	ksSlO3H6uvWUGQLY;

1.38
date	2015.06.23.22.52.55;	author millert;	state Exp;
branches;
next	1.37;
commitid	D3xbOXH7KMen9xny;

1.37
date	2014.12.12.03.32.55;	author jsg;	state Exp;
branches;
next	1.36;
commitid	z5jmhnFNG04WBO9R;

1.36
date	2014.10.08.04.19.08;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	OuNVp736YkNFjTSK;

1.35
date	2013.11.28.18.24.55;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.11.15.20.26.00;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.01.17.04.24;	author naddy;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.01.17.02.02;	author naddy;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.23.15.24.41;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.07.03.30.56;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2008.10.16.16.34.32;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.09.21.14.58;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2008.10.09.16.40.56;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2008.10.08.17.26.47;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.09.08.37.44;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.09.00.23.56;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.11.07.11.44;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.10.11.41.26;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.09.19.39.40;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.13.17.11.17;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.17.16.13.33;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.07.17.56.26;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.10.22.20.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.02.56.16;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.09.21.31.03;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.11.06.16.36;	author jsyn;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	98.09.24.03.00.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.09.22.21.21.43;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	98.02.15.10.38.35;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.01.21.03.51.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.01.18.22.01.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.11.14.03.59.25;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.04.28.20.23.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Apply stricter pledge rules if possible. These are based on the usage of
the 'w' and 'r' functions and the 'w' flag to the 's' function.

If non of the above is used and input is being read from stdin, we drop
all the way down to stdio!

Original inspiration by benno@@.

OK millert@@
@
text
@/*	$OpenBSD: compile.c,v 1.41 2017/01/20 10:26:16 krw Exp $	*/

/*-
 * Copyright (c) 1992 Diomidis Spinellis.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Diomidis Spinellis of Imperial College, University of London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "defs.h"
#include "extern.h"

#define LHSZ	128
#define	LHMASK	(LHSZ - 1)
static struct labhash {
	struct	labhash *lh_next;
	u_int	lh_hash;
	struct	s_command *lh_cmd;
	int	lh_ref;
} *labels[LHSZ];

static char	 *compile_addr(char *, struct s_addr *);
static char	 *compile_ccl(char **, char *);
static char	 *compile_delimited(char *, char *, int);
static char	 *compile_flags(char *, struct s_subst *);
static char	 *compile_re(char *, regex_t **);
static char	 *compile_subst(char *, struct s_subst *);
static char	 *compile_text(void);
static char	 *compile_tr(char *, char **);
static struct s_command
		**compile_stream(struct s_command **);
static char	 *duptoeol(char *, char *, char **);
static void	  enterlabel(struct s_command *);
static struct s_command
		 *findlabel(char *);
static void	  fixuplabel(struct s_command *, struct s_command *);
static void	  uselabel(void);

/*
 * Command specification.  This is used to drive the command parser.
 */
struct s_format {
	char code;				/* Command code */
	int naddr;				/* Number of address args */
	enum e_args args;			/* Argument type */
};

static struct s_format cmd_fmts[] = {
	{'{', 2, GROUP},
	{'}', 0, ENDGROUP},
	{'a', 1, TEXT},
	{'b', 2, BRANCH},
	{'c', 2, TEXT},
	{'d', 2, EMPTY},
	{'D', 2, EMPTY},
	{'g', 2, EMPTY},
	{'G', 2, EMPTY},
	{'h', 2, EMPTY},
	{'H', 2, EMPTY},
	{'i', 1, TEXT},
	{'l', 2, EMPTY},
	{'n', 2, EMPTY},
	{'N', 2, EMPTY},
	{'p', 2, EMPTY},
	{'P', 2, EMPTY},
	{'q', 1, EMPTY},
	{'r', 1, RFILE},
	{'s', 2, SUBST},
	{'t', 2, BRANCH},
	{'w', 2, WFILE},
	{'x', 2, EMPTY},
	{'y', 2, TR},
	{'!', 2, NONSEL},
	{':', 0, LABEL},
	{'#', 0, COMMENT},
	{'=', 1, EMPTY},
	{'\0', 0, COMMENT},
};

/* The compiled program. */
struct s_command *prog;

/*
 * Compile the program into prog.
 * Initialise appends.
 */
void
compile(void)
{
	*compile_stream(&prog) = NULL;
	fixuplabel(prog, NULL);
	uselabel();
	appends = xreallocarray(NULL, appendnum, sizeof(struct s_appends));
	match = xreallocarray(NULL, maxnsub + 1, sizeof(regmatch_t));
}

#define EATSPACE() do {							\
	if (p)								\
		while (isascii((unsigned char)*p) &&			\
		    isspace((unsigned char)*p))				\
			p++;						\
	} while (0)

static struct s_command **
compile_stream(struct s_command **link)
{
	char *p;
	static char *lbuf;	/* To avoid excessive malloc calls */
	static size_t bufsize;
	struct s_command *cmd, *cmd2, *stack;
	struct s_format *fp;
	int naddr;				/* Number of addresses */

	stack = 0;
	for (;;) {
		if ((p = cu_fgets(&lbuf, &bufsize)) == NULL) {
			if (stack != 0)
				error(COMPILE, "unexpected EOF (pending }'s)");
			return (link);
		}

semicolon:	EATSPACE();
		if (*p == '#' || *p == '\0')
			continue;
		if (*p == ';') {
			p++;
			goto semicolon;
		}
		*link = cmd = xmalloc(sizeof(struct s_command));
		link = &cmd->next;
		cmd->nonsel = cmd->inrange = 0;
		/* First parse the addresses */
		naddr = 0;

/* Valid characters to start an address */
#define	addrchar(c)	(strchr("0123456789/\\$", (c)))
		if (addrchar(*p)) {
			naddr++;
			cmd->a1 = xmalloc(sizeof(struct s_addr));
			p = compile_addr(p, cmd->a1);
			EATSPACE();				/* EXTENSION */
			if (*p == ',') {
				p++;
				EATSPACE();			/* EXTENSION */
				naddr++;
				cmd->a2 = xmalloc(sizeof(struct s_addr));
				p = compile_addr(p, cmd->a2);
				EATSPACE();
			} else {
				cmd->a2 = 0;
			}
		} else {
			cmd->a1 = cmd->a2 = 0;
		}

nonsel:		/* Now parse the command */
		if (!*p)
			error(COMPILE, "command expected");
		cmd->code = *p;
		for (fp = cmd_fmts; fp->code; fp++)
			if (fp->code == *p)
				break;
		if (!fp->code)
			error(COMPILE, "invalid command code %c", *p);
		if (naddr > fp->naddr)
			error(COMPILE,
			    "command %c expects up to %d address(es), found %d",
			    *p, fp->naddr, naddr);
		switch (fp->args) {
		case NONSEL:			/* ! */
			p++;
			EATSPACE();
			cmd->nonsel = 1;
			goto nonsel;
		case GROUP:			/* { */
			p++;
			EATSPACE();
			cmd->next = stack;
			stack = cmd;
			link = &cmd->u.c;
			if (*p)
				goto semicolon;
			break;
		case ENDGROUP:
			/*
			 * Short-circuit command processing, since end of
			 * group is really just a noop.
			 */
			cmd->nonsel = 1;
			if (stack == 0)
				error(COMPILE, "unexpected }");
			cmd2 = stack;
			stack = cmd2->next;
			cmd2->next = cmd;
			/*FALLTHROUGH*/
		case EMPTY:		/* d D g G h H l n N p P q x = \0 */
			p++;
			EATSPACE();
			if (*p == ';') {
				p++;
				link = &cmd->next;
				goto semicolon;
			}
			if (*p)
				error(COMPILE,
"extra characters at the end of %c command", cmd->code);
			break;
		case TEXT:			/* a c i */
			p++;
			EATSPACE();
			if (*p != '\\')
				error(COMPILE, "command %c expects \\ followed by"
				    " text", cmd->code);
			p++;
			EATSPACE();
			if (*p)
				error(COMPILE, "extra characters after \\ at the"
				    " end of %c command", cmd->code);
			cmd->t = compile_text();
			break;
		case COMMENT:			/* \0 # */
			break;
		case WFILE:			/* w */
			p++;
			EATSPACE();
			if (*p == '\0')
				error(COMPILE, "filename expected");
			cmd->t = duptoeol(p, "w command", NULL);
			if (aflag) {
				cmd->u.fd = -1;
				pledge_wpath = 1;
			}
			else if ((cmd->u.fd = open(p,
			    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
			    DEFFILEMODE)) == -1)
				error(FATAL, "%s: %s", p, strerror(errno));
			break;
		case RFILE:			/* r */
			pledge_rpath = 1;
			p++;
			EATSPACE();
			cmd->t = duptoeol(p, "read command", NULL);
			break;
		case BRANCH:			/* b t */
			p++;
			EATSPACE();
			if (*p == '\0')
				cmd->t = NULL;
			else
				cmd->t = duptoeol(p, "branch", &p);
			if (*p == ';') {
				p++;
				goto semicolon;
			}
			break;
		case LABEL:			/* : */
			p++;
			EATSPACE();
			cmd->t = duptoeol(p, "label", &p);
			if (strlen(cmd->t) == 0)
				error(COMPILE, "empty label");
			enterlabel(cmd);
			if (*p == ';') {
				p++;
				goto semicolon;
			}
			break;
		case SUBST:			/* s */
			p++;
			if (*p == '\0' || *p == '\\')
				error(COMPILE, "substitute pattern can not be"
				    " delimited by newline or backslash");
			cmd->u.s = xmalloc(sizeof(struct s_subst));
			p = compile_re(p, &cmd->u.s->re);
			if (p == NULL)
				error(COMPILE, "unterminated substitute pattern");
			--p;
			p = compile_subst(p, cmd->u.s);
			p = compile_flags(p, cmd->u.s);
			EATSPACE();
			if (*p == ';') {
				p++;
				link = &cmd->next;
				goto semicolon;
			}
			break;
		case TR:			/* y */
			p++;
			p = compile_tr(p, (char **)&cmd->u.y);
			EATSPACE();
			if (*p == ';') {
				p++;
				link = &cmd->next;
				goto semicolon;
			}
			if (*p)
				error(COMPILE, "extra text at the end of a"
				    " transform command");
			break;
		}
	}
}

/*
 * Get a delimited string.  P points to the delimeter of the string; d points
 * to a buffer area.  Newline and delimiter escapes are processed; other
 * escapes are ignored.
 *
 * Returns a pointer to the first character after the final delimiter or NULL
 * in the case of a non-terminated string.  The character array d is filled
 * with the processed string.
 */
static char *
compile_delimited(char *p, char *d, int is_tr)
{
	char c;

	c = *p++;
	if (c == '\0')
		return (NULL);
	else if (c == '\\')
		error(COMPILE, "\\ can not be used as a string delimiter");
	else if (c == '\n')
		error(COMPILE, "newline can not be used as a string delimiter");
	while (*p) {
		if (*p == '[' && *p != c) {
			if ((d = compile_ccl(&p, d)) == NULL)
				error(COMPILE, "unbalanced brackets ([])");
			continue;
		} else if (*p == '\\' && p[1] == '[') {
			*d++ = *p++;
		} else if (*p == '\\' && p[1] == c) {
			p++;
		} else if (*p == '\\' && p[1] == 'n') {
			*d++ = '\n';
			p += 2;
			continue;
		} else if (*p == '\\' && p[1] == '\\') {
			if (is_tr)
				p++;
			else
				*d++ = *p++;
		} else if (*p == c) {
			*d = '\0';
			return (p + 1);
		}
		*d++ = *p++;
	}
	return (NULL);
}


/* compile_ccl: expand a POSIX character class */
static char *
compile_ccl(char **sp, char *t)
{
	int c, d;
	char *s = *sp;

	*t++ = *s++;
	if (*s == '^')
		*t++ = *s++;
	if (*s == ']')
		*t++ = *s++;
	for (; *s && (*t = *s) != ']'; s++, t++)
		if (*s == '[' && ((d = *(s+1)) == '.' || d == ':' || d == '=')) {
			*++t = *++s, t++, s++;
			for (c = *s; (*t = *s) != ']' || c != d; s++, t++)
				if ((c = *s) == '\0')
					return NULL;
		} else if (*s == '\\' && s[1] == 'n') {
			*t = '\n';
			s++;
		}
	if (*s == ']') {
		*sp = ++s;
		return (++t);
	} else {
		return (NULL);
	}
}

/*
 * Get a regular expression.  P points to the delimiter of the regular
 * expression; repp points to the address of a regexp pointer.  Newline
 * and delimiter escapes are processed; other escapes are ignored.
 * Returns a pointer to the first character after the final delimiter
 * or NULL in the case of a non terminated regular expression.  The regexp
 * pointer is set to the compiled regular expression.
 * Cflags are passed to regcomp.
 */
static char *
compile_re(char *p, regex_t **repp)
{
	int eval;
	char *re;

	re = xmalloc(strlen(p) + 1); /* strlen(re) <= strlen(p) */
	p = compile_delimited(p, re, 0);
	if (p && strlen(re) == 0) {
		*repp = NULL;
		free(re);
		return (p);
	}
	*repp = xmalloc(sizeof(regex_t));
	if (p && (eval = regcomp(*repp, re, Eflag ? REG_EXTENDED : 0)) != 0)
		error(COMPILE, "RE error: %s", strregerror(eval, *repp));
	if (maxnsub < (*repp)->re_nsub)
		maxnsub = (*repp)->re_nsub;
	free(re);
	return (p);
}

/*
 * Compile the substitution string of a regular expression and set res to
 * point to a saved copy of it.  Nsub is the number of parenthesized regular
 * expressions.
 */
static char *
compile_subst(char *p, struct s_subst *s)
{
	static char *lbuf;
	static size_t bufsize;
	int asize, ref, size;
	char c, *text, *op, *sp;
	int sawesc = 0;

	c = *p++;			/* Terminator character */
	if (c == '\0')
		return (NULL);

	s->maxbref = 0;
	s->linenum = linenum;
	text = NULL;
	asize = size = 0;
	do {
		size_t len = ROUNDLEN(strlen(p) + 1);
		if (asize - size < len) {
			do {
				asize += len;
			} while (asize - size < len);
			text = xrealloc(text, asize);
		}
		op = sp = text + size;
		for (; *p; p++) {
			if (*p == '\\' || sawesc) {
				/*
				 * If this is a continuation from the last
				 * buffer, we won't have a character to
				 * skip over.
				 */
				if (sawesc)
					sawesc = 0;
				else
					p++;

				if (*p == '\0') {
					/*
					 * This escaped character is continued
					 * in the next part of the line.  Note
					 * this fact, then cause the loop to
					 * exit w/ normal EOL case and reenter
					 * above with the new buffer.
					 */
					sawesc = 1;
					p--;
					continue;
				} else if (strchr("123456789", *p) != NULL) {
					*sp++ = '\\';
					ref = *p - '0';
					if (s->re != NULL &&
					    ref > s->re->re_nsub)
						error(COMPILE,
"\\%c not defined in the RE", *p);
					if (s->maxbref < ref)
						s->maxbref = ref;
				} else if (*p == '&' || *p == '\\')
					*sp++ = '\\';
			} else if (*p == c) {
				p++;
				*sp++ = '\0';
				size += sp - op;
				s->new = xrealloc(text, size);
				return (p);
			} else if (*p == '\n') {
				error(COMPILE,
"unescaped newline inside substitute pattern");
			}
			*sp++ = *p;
		}
		size += sp - op;
	} while ((p = cu_fgets(&lbuf, &bufsize)));
	error(COMPILE, "unterminated substitute in regular expression");
}

/*
 * Compile the flags of the s command
 */
static char *
compile_flags(char *p, struct s_subst *s)
{
	int gn;			/* True if we have seen g or n */
	long l;
	char wfile[PATH_MAX], *q, *eq;

	s->n = 1;				/* Default */
	s->p = 0;
	s->wfile = NULL;
	s->wfd = -1;
	for (gn = 0;;) {
		EATSPACE();			/* EXTENSION */
		switch (*p) {
		case 'g':
			if (gn)
				error(COMPILE, "more than one number or 'g' in"
				    " substitute flags");
			gn = 1;
			s->n = 0;
			break;
		case '\0':
		case '\n':
		case ';':
			return (p);
		case 'p':
			s->p = 1;
			break;
		case '1': case '2': case '3':
		case '4': case '5': case '6':
		case '7': case '8': case '9':
			if (gn)
				error(COMPILE, "more than one number or 'g' in"
				    " substitute flags");
			gn = 1;
			l = strtol(p, &p, 10);
			if (l <= 0 || l >= INT_MAX)
				error(COMPILE,
				    "number in substitute flags out of range");
			s->n = (int)l;
			continue;
		case 'w':
			p++;
#ifdef HISTORIC_PRACTICE
			if (*p != ' ') {
				warning("space missing before w wfile");
				return (p);
			}
#endif
			EATSPACE();
			q = wfile;
			eq = wfile + sizeof(wfile) - 1;
			while (*p) {
				if (*p == '\n')
					break;
				if (q >= eq)
					error(COMPILE, "wfile too long");
				*q++ = *p++;
			}
			*q = '\0';
			if (q == wfile)
				error(COMPILE, "no wfile specified");
			s->wfile = strdup(wfile);
			if (aflag)
				pledge_wpath = 1;
			else if ((s->wfd = open(wfile,
			    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
			    DEFFILEMODE)) == -1)
				error(FATAL, "%s: %s", wfile, strerror(errno));
			return (p);
		default:
			error(COMPILE,
			    "bad flag in substitute command: '%c'", *p);
			break;
		}
		p++;
	}
}

/*
 * Compile a translation set of strings into a lookup table.
 */
static char *
compile_tr(char *p, char **transtab)
{
	int i;
	char *lt, *op, *np;
	char *old = NULL, *new = NULL;

	if (*p == '\0' || *p == '\\')
		error(COMPILE,
"transform pattern can not be delimited by newline or backslash");
	old = xmalloc(strlen(p) + 1);
	p = compile_delimited(p, old, 1);
	if (p == NULL) {
		error(COMPILE, "unterminated transform source string");
		goto bad;
	}
	new = xmalloc(strlen(p) + 1);
	p = compile_delimited(--p, new, 1);
	if (p == NULL) {
		error(COMPILE, "unterminated transform target string");
		goto bad;
	}
	EATSPACE();
	if (strlen(new) != strlen(old)) {
		error(COMPILE, "transform strings are not the same length");
		goto bad;
	}
	/* We assume characters are 8 bits */
	lt = xmalloc(UCHAR_MAX + 1);
	for (i = 0; i <= UCHAR_MAX; i++)
		lt[i] = (char)i;
	for (op = old, np = new; *op; op++, np++)
		lt[(u_char)*op] = *np;
	*transtab = lt;
	free(old);
	free(new);
	return (p);
bad:
	free(old);
	free(new);
	return (NULL);
}

/*
 * Compile the text following an a, c, or i command.
 */
static char *
compile_text(void)
{
	int asize, esc_nl, size;
	char *lbuf, *text, *p, *op, *s;
	size_t bufsize;

	lbuf = text = NULL;
	asize = size = 0;
	while ((p = cu_fgets(&lbuf, &bufsize))) {
		size_t len = ROUNDLEN(strlen(p) + 1);
		if (asize - size < len) {
			do {
				asize += len;
			} while (asize - size < len);
			text = xrealloc(text, asize);
		}
		op = s = text + size;
		for (esc_nl = 0; *p != '\0'; p++) {
			if (*p == '\\' && p[1] != '\0' && *++p == '\n')
				esc_nl = 1;
			*s++ = *p;
		}
		size += s - op;
		if (!esc_nl) {
			*s = '\0';
			break;
		}
	}
	free(lbuf);
	text = xrealloc(text, size + 1);
	text[size] = '\0';
	return (text);
}

/*
 * Get an address and return a pointer to the first character after
 * it.  Fill the structure pointed to according to the address.
 */
static char *
compile_addr(char *p, struct s_addr *a)
{
	char *end;

	switch (*p) {
	case '\\':				/* Context address */
		++p;
		/* FALLTHROUGH */
	case '/':				/* Context address */
		p = compile_re(p, &a->u.r);
		if (p == NULL)
			error(COMPILE, "unterminated regular expression");
		a->type = AT_RE;
		return (p);

	case '$':				/* Last line */
		a->type = AT_LAST;
		return (p + 1);
						/* Line number */
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		a->type = AT_LINE;
		a->u.l = strtoul(p, &end, 10);
		return (end);
	default:
		error(COMPILE, "expected context address");
		return (NULL);
	}
}

/*
 * duptoeol --
 *	Return a copy of all the characters up to \n or \0.
 */
static char *
duptoeol(char *s, char *ctype, char **semi)
{
	size_t len;
	int ws;
	char *start;

	ws = 0;
	if (semi) {
		for (start = s; *s != '\0' && *s != '\n' && *s != ';'; ++s)
			ws = isspace((unsigned char)*s);
	} else {
		for (start = s; *s != '\0' && *s != '\n'; ++s)
			ws = isspace((unsigned char)*s);
		*s = '\0';
	}
	if (ws)
		warning("whitespace after %s", ctype);
	len = s - start + 1;
	if (semi)
		*semi = s;
	s = xmalloc(len);
	strlcpy(s, start, len);
	return (s);
}

/*
 * Convert goto label names to addresses, and count a and r commands, in
 * the given subset of the script.  Free the memory used by labels in b
 * and t commands (but not by :).
 *
 * TODO: Remove } nodes
 */
static void
fixuplabel(struct s_command *cp, struct s_command *end)
{

	for (; cp != end; cp = cp->next)
		switch (cp->code) {
		case 'a':
		case 'r':
			appendnum++;
			break;
		case 'b':
		case 't':
			/* Resolve branch target. */
			if (cp->t == NULL) {
				cp->u.c = NULL;
				break;
			}
			if ((cp->u.c = findlabel(cp->t)) == NULL)
				error(COMPILE, "undefined label '%s'", cp->t);
			free(cp->t);
			break;
		case '{':
			/* Do interior commands. */
			fixuplabel(cp->u.c, cp->next);
			break;
		}
}

/*
 * Associate the given command label for later lookup.
 */
static void
enterlabel(struct s_command *cp)
{
	struct labhash **lhp, *lh;
	u_char *p;
	u_int h, c;

	for (h = 0, p = (u_char *)cp->t; (c = *p) != 0; p++)
		h = (h << 5) + h + c;
	lhp = &labels[h & LHMASK];
	for (lh = *lhp; lh != NULL; lh = lh->lh_next)
		if (lh->lh_hash == h && strcmp(cp->t, lh->lh_cmd->t) == 0)
			error(COMPILE, "duplicate label '%s'", cp->t);
	lh = xmalloc(sizeof *lh);
	lh->lh_next = *lhp;
	lh->lh_hash = h;
	lh->lh_cmd = cp;
	lh->lh_ref = 0;
	*lhp = lh;
}

/*
 * Find the label contained in the command l in the command linked
 * list cp.  L is excluded from the search.  Return NULL if not found.
 */
static struct s_command *
findlabel(char *name)
{
	struct labhash *lh;
	u_char *p;
	u_int h, c;

	for (h = 0, p = (u_char *)name; (c = *p) != 0; p++)
		h = (h << 5) + h + c;
	for (lh = labels[h & LHMASK]; lh != NULL; lh = lh->lh_next) {
		if (lh->lh_hash == h && strcmp(name, lh->lh_cmd->t) == 0) {
			lh->lh_ref = 1;
			return (lh->lh_cmd);
		}
	}
	return (NULL);
}

/*
 * Warn about any unused labels.  As a side effect, release the label hash
 * table space.
 */
static void
uselabel(void)
{
	struct labhash *lh, *next;
	int i;

	for (i = 0; i < LHSZ; i++) {
		for (lh = labels[i]; lh != NULL; lh = next) {
			next = lh->lh_next;
			if (!lh->lh_ref)
				warning("unused label '%s'",
				    lh->lh_cmd->t);
			free(lh);
		}
	}
}
@


1.41
log
@Split error() into error() and warning() so error() can be marked __dead to
appease gcc.

ok procter@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.40 2015/10/26 22:24:44 jca Exp $	*/
d267 1
a267 1
			if (aflag)
d269 2
d277 1
d600 3
a602 1
			if (!aflag && (s->wfd = open(wfile,
@


1.40
log
@Tidy up error() levels: merge COMPILE and COMPILE2, and kill ERROR (unused)

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.39 2015/10/26 14:08:47 mmcc Exp $	*/
a522 1
				/* NOTREACHED */
a528 1
	/* NOTREACHED */
d579 1
a579 1
				error(WARNING, "space missing before w wfile");
d751 1
a751 1
		error(WARNING, "whitespace after %s", ctype);
d855 1
a855 1
				error(WARNING, "unused label '%s'",
@


1.39
log
@Rename err() to error() to prevent confusion with the stdlib function.

Discussed with jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.38 2015/06/23 22:52:55 millert Exp $	*/
d787 1
a787 1
				error(COMPILE2, "undefined label '%s'", cp->t);
d812 1
a812 1
			error(COMPILE2, "duplicate label '%s'", cp->t);
@


1.38
log
@POSIX specifies that that multiple '!' characters preceding a
function should be treated as a single negation.  From FreeBSD
via Liviu Daia.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.37 2014/12/12 03:32:55 jsg Exp $	*/
d156 1
a156 1
				err(COMPILE, "unexpected EOF (pending }'s)");
d196 1
a196 1
			err(COMPILE, "command expected");
d202 1
a202 1
			err(COMPILE, "invalid command code %c", *p);
d204 1
a204 1
			err(COMPILE,
d229 1
a229 1
				err(COMPILE, "unexpected }");
d243 1
a243 1
				err(COMPILE,
d250 1
a250 1
				err(COMPILE, "command %c expects \\ followed by"
d255 1
a255 1
				err(COMPILE, "extra characters after \\ at the"
d265 1
a265 1
				err(COMPILE, "filename expected");
d272 1
a272 1
				err(FATAL, "%s: %s", p, strerror(errno));
d296 1
a296 1
				err(COMPILE, "empty label");
d306 1
a306 1
				err(COMPILE, "substitute pattern can not be"
d311 1
a311 1
				err(COMPILE, "unterminated substitute pattern");
d332 1
a332 1
				err(COMPILE, "extra text at the end of a"
d357 1
a357 1
		err(COMPILE, "\\ can not be used as a string delimiter");
d359 1
a359 1
		err(COMPILE, "newline can not be used as a string delimiter");
d363 1
a363 1
				err(COMPILE, "unbalanced brackets ([])");
d442 1
a442 1
		err(COMPILE, "RE error: %s", strregerror(eval, *repp));
d508 1
a508 1
						err(COMPILE,
d521 1
a521 1
				err(COMPILE,
d529 1
a529 1
	err(COMPILE, "unterminated substitute in regular expression");
d552 1
a552 1
				err(COMPILE, "more than one number or 'g' in"
d568 1
a568 1
				err(COMPILE, "more than one number or 'g' in"
d573 1
a573 1
				err(COMPILE,
d581 1
a581 1
				err(WARNING, "space missing before w wfile");
d592 1
a592 1
					err(COMPILE, "wfile too long");
d597 1
a597 1
				err(COMPILE, "no wfile specified");
d602 1
a602 1
				err(FATAL, "%s: %s", wfile, strerror(errno));
d605 1
a605 1
			err(COMPILE,
d624 1
a624 1
		err(COMPILE,
d629 1
a629 1
		err(COMPILE, "unterminated transform source string");
d635 1
a635 1
		err(COMPILE, "unterminated transform target string");
d640 1
a640 1
		err(COMPILE, "transform strings are not the same length");
d713 1
a713 1
			err(COMPILE, "unterminated regular expression");
d727 1
a727 1
		err(COMPILE, "expected context address");
d753 1
a753 1
		err(WARNING, "whitespace after %s", ctype);
d787 1
a787 1
				err(COMPILE2, "undefined label '%s'", cp->t);
d812 1
a812 1
			err(COMPILE2, "duplicate label '%s'", cp->t);
d857 1
a857 1
				err(WARNING, "unused label '%s'",
@


1.37
log
@Bounds check the file path used in the 'w' command.  Modified version
of a diff from Sebastien Marie to prevent a crash found by Sebastien
with the afl fuzzer.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.36 2014/10/08 04:19:08 deraadt Exp $	*/
d211 1
a211 1
			cmd->nonsel = ! cmd->nonsel;
@


1.36
log
@add a xreallocarray() like the existing fatal xmalloc(), and use it to
detect potential integer.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.35 2013/11/28 18:24:55 deraadt Exp $	*/
d541 1
a541 1
	char wfile[PATH_MAX], *q;
d587 1
d591 2
@


1.35
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.34 2010/11/15 20:26:00 millert Exp $	*/
d131 2
a132 2
	appends = xmalloc(sizeof(struct s_appends) * appendnum);
	match = xmalloc((maxnsub + 1) * sizeof(regmatch_t));
@


1.34
log
@NUL-terminate buffer in compiler_text() after realloc, not before.
Now that we have dynamically sized buffers there may not be room
for the NUL until after realloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.33 2010/07/01 17:04:24 naddy Exp $	*/
d137 2
a138 1
		while (isascii(*p) && isspace(*p))			\
d743 1
a743 1
			ws = isspace(*s);
d746 1
a746 1
			ws = isspace(*s);
@


1.33
log
@Follow POSIX (IEEE Std 1003.1, 2004 Edition) in the implementation
of the y (translate) command.

"If a backslash character is immediately followed by a backslash
character in string1 or string2, the two backslash characters shall
be counted as a single literal backslash character"

From FreeBSD; ok millert@@ halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.32 2010/07/01 17:02:02 naddy Exp $	*/
d688 1
d690 1
a690 1
	return (xrealloc(text, size + 1));
@


1.32
log
@Allow [ to be used as a delimiter.

From FreeBSD; ok millert@@ halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.31 2009/10/27 23:59:43 deraadt Exp $	*/
d62 1
a62 1
static char	 *compile_delimited(char *, char *);
d348 1
a348 1
compile_delimited(char *p, char *d)
d373 4
a376 1
			*d++ = *p++;
d433 1
a433 1
	p = compile_delimited(p, re);
d623 1
a623 1
	p = compile_delimited(p, old);
d629 1
a629 1
	p = compile_delimited(--p, new);
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.30 2009/10/23 15:24:41 reyk Exp $	*/
d360 1
a360 1
		if (*p == '[') {
@


1.30
log
@When adding text due to an a, c, or i command, don't eat the space(s) at
the beginning of the lines since the addition is supposed to be "verbatim".

From NetBSD, also matches the bahaviour of GNU sed

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.29 2009/08/07 03:30:56 djm Exp $	*/
a34 5

#ifndef lint
/* from: static char sccsid[] = "@@(#)compile.c	8.2 (Berkeley) 4/28/95"; */
static const char rcsid[] = "$OpenBSD: compile.c,v 1.29 2009/08/07 03:30:56 djm Exp $";
#endif /* not lint */
@


1.29
log
@add -E flag to compile regular expressions using the extended POSIX
syntax. The -E flag is compatible with the other BSDs and OSX. -r is
also provided as an alias for compatibility with GNU sed.

feedback from jmc@@ and millert@@
ok millert@@ pyr@@ henning@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.28 2008/10/16 16:34:32 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: compile.c,v 1.28 2008/10/16 16:34:32 millert Exp $";
a677 1
		EATSPACE();
@


1.28
log
@Move memory allocation closer to where it is needed.  Also make
a distinction between len and size.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.27 2008/10/09 21:14:58 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: compile.c,v 1.27 2008/10/09 21:14:58 millert Exp $";
d442 1
a442 1
	if (p && (eval = regcomp(*repp, re, 0)) != 0)
@


1.27
log
@Now that len is set later in compile_subst() we need to move the
xmalloc call that goes with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.26 2008/10/09 16:40:56 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: compile.c,v 1.26 2008/10/09 16:40:56 millert Exp $";
d151 1
a151 1
	static size_t len = _POSIX2_LINE_MAX;
a156 2
	if (!lbuf)
		lbuf = xmalloc(len);
d158 1
a158 1
		if ((p = cu_fgets(&lbuf, &len)) == NULL) {
d459 1
a459 1
	static size_t len;
a467 6
	len = strlen(p);
	if (len < _POSIX2_LINE_MAX)
		len = _POSIX2_LINE_MAX;
	if (!lbuf)
		lbuf = xmalloc(len);

d470 2
a471 3
	asize = 2 * len + 1;
	text = xmalloc(asize);
	size = 0;
d473 2
a474 1
		if (asize - size < len + 1) {
d476 2
a477 2
				asize *= 2;
			} while (asize - size < len + 1);
d529 1
a529 1
	} while ((p = cu_fgets(&lbuf, &len)));
d665 1
a665 1
	size_t len = _POSIX2_LINE_MAX;
d667 5
a671 6
	lbuf = xmalloc(len);
	asize = 2 * len + 1;
	text = xmalloc(asize);
	size = 0;
	while (cu_fgets(&lbuf, &len)) {
		if (asize - size < len + 1) {
d673 2
a674 2
				asize *= 2;
			} while (asize - size < len + 1);
a677 1
		p = lbuf;
@


1.26
log
@In compile_subst(), adjust for the fact that the initial buffer
that is passed in may now be larger than _POSIX2_LINE_MAX.
Thanks to pedro@@ for the test case.  OK pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.25 2008/10/08 17:26:47 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: compile.c,v 1.25 2008/10/08 17:26:47 millert Exp $";
a465 3
	if (!lbuf)
		lbuf = xmalloc(len);

d473 3
@


1.25
log
@Allow sed to handle arbitrarily long lines.  Also plug a memory
leak noticed in the process.  Closes PR 5303.  OK otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.24 2007/03/20 03:50:39 tedu Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: compile.c,v 1.24 2007/03/20 03:50:39 tedu Exp $";
d461 1
a461 1
	static size_t len = _POSIX2_LINE_MAX;
d473 3
@


1.24
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.23 2007/01/09 08:37:44 otto Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: compile.c,v 1.23 2007/01/09 08:37:44 otto Exp $";
d150 2
a151 1
	static char lbuf[_POSIX2_LINE_MAX + 1];	/* To save stack */
d157 2
d160 1
a160 1
		if ((p = cu_fgets(lbuf, sizeof(lbuf))) == NULL) {
d434 1
a434 1
	char re[_POSIX2_LINE_MAX + 1];
d436 1
d440 1
d448 1
d460 2
a461 1
	static char lbuf[_POSIX2_LINE_MAX + 1];
d466 3
d475 1
a475 1
	asize = 2 * _POSIX2_LINE_MAX + 1;
d479 6
d534 1
a534 5
		if (asize - size < _POSIX2_LINE_MAX + 1) {
			asize *= 2;
			text = xrealloc(text, asize);
		}
	} while (cu_fgets(p = lbuf, sizeof(lbuf)));
d547 1
a547 1
	char wfile[_POSIX2_LINE_MAX + 1], *q;
d624 1
a624 2
	char old[_POSIX2_LINE_MAX + 1];
	char new[_POSIX2_LINE_MAX + 1];
d629 1
d633 1
a633 1
		return (NULL);
d635 1
d639 1
a639 1
		return (NULL);
d644 1
a644 1
		return (NULL);
d653 2
d656 4
d669 2
a670 2
	char *text, *p, *op, *s;
	char lbuf[_POSIX2_LINE_MAX + 1];
d672 2
a673 1
	asize = 2 * _POSIX2_LINE_MAX + 1;
d676 7
a682 1
	while (cu_fgets(lbuf, sizeof(lbuf))) {
a695 4
		if (asize - size < _POSIX2_LINE_MAX + 1) {
			asize *= 2;
			text = xmalloc(asize);
		}
d697 1
@


1.23
log
@Accept empty command, from Matthew R. Dempsky; ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.22 2006/10/09 00:23:56 tedu Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: compile.c,v 1.22 2006/10/09 00:23:56 tedu Exp $";
d142 1
a142 1
		while (*p && isascii(*p) && isspace(*p))		\
@


1.22
log
@pretty.  the comma operator should not be used to cram two statements into
an if without braces, or worse, into a return.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.21 2005/04/11 07:11:44 deraadt Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: compile.c,v 1.21 2005/04/11 07:11:44 deraadt Exp $";
d164 1
a164 1
		if (p && (*p == '#' || *p == '\0'))
d166 4
@


1.21
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.20 2004/07/10 11:41:26 otto Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.20 2004/07/10 11:41:26 otto Exp $";
d186 1
a186 1
			} else
d188 2
a189 1
		} else
d191 1
d204 2
a205 1
"command %c expects up to %d address(es), found %d", *p, fp->naddr, naddr);
d249 2
a250 2
				err(COMPILE,
"command %c expects \\ followed by text", cmd->code);
d254 2
a255 2
				err(COMPILE,
"extra characters after \\ at the end of %c command", cmd->code);
d305 2
a306 2
				err(COMPILE,
"substitute pattern can not be delimited by newline or backslash");
d331 2
a332 2
				err(COMPILE,
"extra text at the end of a transform command");
d366 1
a366 1
		} else if (*p == '\\' && p[1] == c)
d368 1
a368 1
		else if (*p == '\\' && p[1] == 'n') {
d372 1
a372 1
		} else if (*p == '\\' && p[1] == '\\')
d374 1
a374 1
		else if (*p == c) {
d402 10
a411 3
		} else if (*s == '\\' && s[1] == 'n')
			    *t = '\n', s++;
	return (*s == ']') ? *sp = ++s, ++t : NULL;
d542 2
a543 2
				err(COMPILE,
"more than one number or 'g' in substitute flags");
d558 2
a559 2
				err(COMPILE,
"more than one number or 'g' in substitute flags");
@


1.20
log
@xmalloc()->xrealloc() so that patterns larger than _POSIX2_LINE_MAX*2-1
work.  From mycroft@@netbsd.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.19 2004/07/09 19:39:40 otto Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.19 2004/07/09 19:39:40 otto Exp $";
d265 1
a265 1
			else if ((cmd->u.fd = open(p, 
d689 1
a689 1
	case '0': case '1': case '2': case '3': case '4': 
d811 1
a811 1
/* 
@


1.19
log
@From the other BSDs: fix a bug that made sed(1) fail if the last
character of the line buffer was a backslash.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.18 2004/06/13 17:11:17 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.18 2004/06/13 17:11:17 deraadt Exp $";
d506 1
a506 1
			text = xmalloc(asize);
@


1.18
log
@1-byte overflow; ryo@@nerv.org, otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.17 2004/02/17 16:13:33 otto Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.17 2004/02/17 16:13:33 otto Exp $";
d443 1
d457 23
a479 3
			if (*p == '\\') {
				p++;
				if (strchr("123456789", *p) != NULL) {
@


1.17
log
@Unbreak numeric flag parsing. Based on a fix from Jared Yanovich; this
version with millert@@. Resolves PR 3677.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.16 2003/10/07 17:56:26 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.16 2003/10/07 17:56:26 deraadt Exp $";
d599 1
a599 1
	lt = xmalloc(UCHAR_MAX);
@


1.16
log
@handle ; terminators for strings like other sed programs do.  this is
apparently an extension, but without it you cannot express longer labelled
sed scripts as one-liners.  noted by seb@@todesplanet.de apr 2002.  also
noted by cerille lefevre a bit later.  fixed by otto and myself, tested
on tree builds to be careful
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.15 2003/06/10 22:20:50 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.15 2003/06/10 22:20:50 deraadt Exp $";
d499 1
d530 6
a535 3
			/* XXX Check for overflow */
			s->n = (int)strtol(p, &p, 10);
			break;
@


1.15
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.14 2003/06/03 02:56:16 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.14 2003/06/03 02:56:16 millert Exp $";
d75 1
a75 1
static char	 *duptoeol(char *, char *);
d262 1
a262 1
			cmd->t = duptoeol(p, "w command");
d273 1
a273 1
			cmd->t = duptoeol(p, "read command");
d281 5
a285 1
				cmd->t = duptoeol(p, "branch");
d290 2
a291 2
			cmd->t = duptoeol(p, "label");
			if (strlen(p) == 0)
d294 4
d680 1
a680 1
duptoeol(char *s, char *ctype)
d687 8
a694 3
	for (start = s; *s != '\0' && *s != '\n'; ++s)
		ws = isspace(*s);
	*s = '\0';
d698 5
a702 1
	return (memmove(xmalloc(len), start, len));
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.13 2002/07/09 21:31:03 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.13 2002/07/09 21:31:03 deraadt Exp $";
d131 1
a131 1
compile()
d147 1
a147 2
compile_stream(link)
	struct s_command **link;
d337 1
a337 2
compile_delimited(p, d)
	char *p, *d;
d375 1
a375 3
compile_ccl(sp, t)
	char **sp;
	char *t;
d406 1
a406 3
compile_re(p, repp)
	char *p;
	regex_t **repp;
d430 1
a430 3
compile_subst(p, s)
	char *p;
	struct s_subst *s;
d488 1
a488 3
compile_flags(p, s)
	char *p;
	struct s_subst *s;
d561 1
a561 3
compile_tr(p, transtab)
	char *p;
	char **transtab;
d600 1
a600 1
compile_text()
d637 1
a637 3
compile_addr(p, a)
	char *p;
	struct s_addr *a;
d672 1
a672 3
duptoeol(s, ctype)
	char *s;
	char *ctype;
d696 1
a696 2
fixuplabel(cp, end)
	struct s_command *cp, *end;
d727 1
a727 2
enterlabel(cp)
	struct s_command *cp;
d752 1
a752 2
findlabel(name)
	char *name;
d774 1
a774 1
uselabel()
@


1.13
log
@make sed r command not bail out. try sed -e "/a/r"
vtamara@@wimsey.informatik.uni-kl.de, pr 2755
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.12 2002/06/11 06:16:36 jsyn Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.12 2002/06/11 06:16:36 jsyn Exp $";
@


1.12
log
@kill err(3) newlines; ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.11 2002/02/16 21:27:52 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.11 2002/02/16 21:27:52 millert Exp $";
d278 1
a278 4
			if (*p == '\0')
				err(COMPILE, "filename expected");
			else
				cmd->t = duptoeol(p, "read command");
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.10 2001/11/19 19:02:16 mpech Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.10 2001/11/19 19:02:16 mpech Exp $";
d273 1
a273 1
				err(FATAL, "%s: %s\n", p, strerror(errno));
d563 1
a563 1
				err(FATAL, "%s: %s\n", wfile, strerror(errno));
@


1.10
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.9 1998/09/24 03:00:59 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.9 1998/09/24 03:00:59 millert Exp $";
d69 8
a76 8
static char	 *compile_addr __P((char *, struct s_addr *));
static char	 *compile_ccl __P((char **, char *));
static char	 *compile_delimited __P((char *, char *));
static char	 *compile_flags __P((char *, struct s_subst *));
static char	 *compile_re __P((char *, regex_t **));
static char	 *compile_subst __P((char *, struct s_subst *));
static char	 *compile_text __P((void));
static char	 *compile_tr __P((char *, char **));
d78 3
a80 3
		**compile_stream __P((struct s_command **));
static char	 *duptoeol __P((char *, char *));
static void	  enterlabel __P((struct s_command *));
d82 3
a84 3
		 *findlabel __P((char *));
static void	  fixuplabel __P((struct s_command *, struct s_command *));
static void	  uselabel __P((void));
@


1.9
log
@correct sccsid, not like it really matters
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.8 1998/09/22 21:21:43 brian Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.8 1998/09/22 21:21:43 brian Exp $";
d154 1
a154 1
	register char *p;
d694 1
a694 1
	register char *s;
d754 3
a756 3
	register struct labhash **lhp, *lh;
	register u_char *p;
	register u_int h, c;
d780 3
a782 3
	register struct labhash *lh;
	register u_char *p;
	register u_int h, c;
d802 2
a803 2
	register struct labhash *lh, *next;
	register int i;
@


1.8
log
@Terminate our output string correctly if we've got
an ``a'' command that has an escaped newline on the
last line of the last script that we're processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.7 1998/02/15 10:38:35 deraadt Exp $	*/
d41 2
a42 2
/* from: static char sccsid[] = "@@(#)compile.c	8.1 (Berkeley) 6/6/93"; */
static char *rcsid = "$OpenBSD: compile.c,v 1.7 1998/02/15 10:38:35 deraadt Exp $";
@


1.7
log
@fix a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.6 1998/01/21 03:51:49 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.6 1998/01/21 03:51:49 millert Exp $";
d647 1
@


1.6
log
@Back out last change.  ed and sed should not use extended regular expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.5 1998/01/18 22:01:53 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.5 1998/01/18 22:01:53 millert Exp $";
d616 1
a616 1
 * Compile the text following an a or i command.
@


1.5
log
@Support extended (modern) instead of basic (obsolescent)
regular expressions.  hubert.feyrer@@rz.uni-regensburg.de
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.4 1997/11/14 03:59:25 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.4 1997/11/14 03:59:25 deraadt Exp $";
d430 1
a430 1
	if (p && (eval = regcomp(*repp, re, REG_EXTENDED)) != 0)
@


1.4
log
@fix for a line continuation bug, more than a year ald. work by mckusick,
bostic, mark@@linus.demon.co.uk, davidg, and bde.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.3 1997/04/28 20:23:19 millert Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.3 1997/04/28 20:23:19 millert Exp $";
d430 1
a430 1
	if (p && (eval = regcomp(*repp, re, 0)) != 0)
@


1.3
log
@Use strtoul() not strtol() when assigning to an unsigned long.
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.2 1996/06/26 05:39:05 deraadt Exp $	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.2 1996/06/26 05:39:05 deraadt Exp $";
d621 1
a621 1
	int asize, size;
d632 3
a634 3
		for (; *p; p++) {
			if (*p == '\\')
				p++;
d638 1
a638 1
		if (p[-2] != '\\') {
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
static char *rcsid = "$OpenBSD: compile.c,v 1.1.1.1 1995/10/18 08:46:05 deraadt Exp $";
d679 1
a679 1
		a->u.l = strtol(p, &end, 10);
@


1.1
log
@Initial revision
@
text
@d1 2
d42 1
a42 1
static char *rcsid = "$Id: compile.c,v 1.14 1995/03/09 11:19:24 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
