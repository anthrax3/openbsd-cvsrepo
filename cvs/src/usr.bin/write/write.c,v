head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.8
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.8
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.6
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.6
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.8
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.8
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.6
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.02.05.19.00.39;	author martijn;	state Exp;
branches;
next	1.32;
commitid	tIZaqzAG05LUXuIK;

1.32
date	2015.10.20.20.21.18;	author bluhm;	state Exp;
branches;
next	1.31;
commitid	qCliIo89jDXS5VF6;

1.31
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	sbrB3Q5CNxcwZpfU;

1.30
date	2015.10.06.03.25.02;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	WyuLJUC1l6gTnOXp;

1.29
date	2015.10.05.07.09.46;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	I8sAquoGdBeCwt0y;

1.28
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2013.04.16.19.24.55;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.06.13.42.35;	author sobrado;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.04.21.13.42;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.04.01.54.11;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.10.00.06.52;	author david;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.10.22.20.54;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.13.15.47.12;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.09.08.15.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.04.01.26.40;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.21.07.32.55;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.02.16.25.30;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.06.53.55;	author jasoni;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.19.17.58.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.02.21.08.28.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.07.06.18.35.20;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.10.26.22.49.12;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.10.25.06.15.03;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.26.10.28.20;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.26.10.22.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.44.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.17.12.39.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.23.09.44.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Make write explicitly ASCII only by transforming UTF-8 characters and non-ASCII
bytes to a single '?'. This prevents sending of potentially harmful bytes to
terminals who don't support UTF-8.

written with help from schwarze@@
text suggestions by jmc@@

OK schwarze@@ and semarie@@
@
text
@/*	$OpenBSD: write.c,v 1.32 2015/10/20 20:21:18 bluhm Exp $	*/
/*	$NetBSD: write.c,v 1.5 1995/08/31 21:48:32 jtc Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jef Poskanzer and Craig Leres of the Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <utmp.h>

void done(int sig);
void do_write(char *, char *, uid_t);
void wr_fputs(char *);
void search_utmp(char *, char *, int, char *, uid_t);
int term_chk(char *, int *, time_t *, int);
int utmp_chk(char *, char *);
static int isu8cont(unsigned char c);

int
main(int argc, char *argv[])
{
	char tty[PATH_MAX], *mytty, *cp;
	int msgsok, myttyfd;
	time_t atime;
	uid_t myuid;

	/* check that sender has write enabled */
	if (isatty(fileno(stdin)))
		myttyfd = fileno(stdin);
	else if (isatty(fileno(stdout)))
		myttyfd = fileno(stdout);
	else if (isatty(fileno(stderr)))
		myttyfd = fileno(stderr);
	else
		errx(1, "can't find your tty");
	if (!(mytty = ttyname(myttyfd)))
		errx(1, "can't find your tty's name");
	if ((cp = strrchr(mytty, '/')))
		mytty = cp + 1;
	if (term_chk(mytty, &msgsok, &atime, 1))
		exit(1);
	if (!msgsok)
		warnx("you have write permission turned off");

	myuid = getuid();

	/* check args */
	switch (argc) {
	case 2:
		search_utmp(argv[1], tty, sizeof tty, mytty, myuid);
		do_write(tty, mytty, myuid);
		break;
	case 3:
		if (!strncmp(argv[2], _PATH_DEV, sizeof(_PATH_DEV) - 1))
			argv[2] += sizeof(_PATH_DEV) - 1;
		if (utmp_chk(argv[1], argv[2]))
			errx(1, "%s is not logged in on %s",
			    argv[1], argv[2]);
		if (term_chk(argv[2], &msgsok, &atime, 1))
			exit(1);
		if (myuid && !msgsok)
			errx(1, "%s has messages disabled on %s",
			    argv[1], argv[2]);
		do_write(argv[2], mytty, myuid);
		break;
	default:
		(void)fprintf(stderr, "usage: write user [ttyname]\n");
		exit(1);
	}
	done(0);

	/* NOTREACHED */
	return (0);
}

/*
 * utmp_chk - checks that the given user is actually logged in on
 *     the given tty
 */
int
utmp_chk(char *user, char *tty)
{
	struct utmp u;
	int ufd;

	if ((ufd = open(_PATH_UTMP, O_RDONLY)) < 0)
		return(1);	/* no utmp, cannot talk to users */

	while (read(ufd, (char *) &u, sizeof(u)) == sizeof(u))
		if (strncmp(user, u.ut_name, sizeof(u.ut_name)) == 0 &&
		    strncmp(tty, u.ut_line, sizeof(u.ut_line)) == 0) {
			(void)close(ufd);
			return(0);
		}

	(void)close(ufd);
	return(1);
}

/*
 * search_utmp - search utmp for the "best" terminal to write to
 *
 * Ignores terminals with messages disabled, and of the rest, returns
 * the one with the most recent access time.  Returns as value the number
 * of the user's terminals with messages enabled, or -1 if the user is
 * not logged in at all.
 *
 * Special case for writing to yourself - ignore the terminal you're
 * writing from, unless that's the only terminal with messages enabled.
 */
void
search_utmp(char *user, char *tty, int ttyl, char *mytty, uid_t myuid)
{
	struct utmp u;
	time_t bestatime, atime;
	int ufd, nloggedttys, nttys, msgsok, user_is_me;
	char atty[UT_LINESIZE + 1];

	if ((ufd = open(_PATH_UTMP, O_RDONLY)) < 0)
		err(1, "%s", _PATH_UTMP);

	nloggedttys = nttys = 0;
	bestatime = 0;
	user_is_me = 0;
	while (read(ufd, (char *) &u, sizeof(u)) == sizeof(u))
		if (strncmp(user, u.ut_name, sizeof(u.ut_name)) == 0) {
			++nloggedttys;
			(void)strncpy(atty, u.ut_line, UT_LINESIZE);
			atty[UT_LINESIZE] = '\0';
			if (term_chk(atty, &msgsok, &atime, 0))
				continue;	/* bad term? skip */
			if (myuid && !msgsok)
				continue;	/* skip ttys with msgs off */
			if (strcmp(atty, mytty) == 0) {
				user_is_me = 1;
				continue;	/* don't write to yourself */
			}
			++nttys;
			if (atime > bestatime) {
				bestatime = atime;
				(void)strlcpy(tty, atty, ttyl);
			}
		}

	(void)close(ufd);
	if (nloggedttys == 0)
		errx(1, "%s is not logged in", user);
	if (nttys == 0) {
		if (user_is_me) {		/* ok, so write to yourself! */
			(void)strlcpy(tty, mytty, ttyl);
			return;
		}
		errx(1, "%s has messages disabled", user);
	} else if (nttys > 1)
		warnx("%s is logged in more than once; writing to %s",
		    user, tty);
}

/*
 * term_chk - check that a terminal exists, and get the message bit
 *     and the access time
 */
int
term_chk(char *tty, int *msgsokP, time_t *atimeP, int showerror)
{
	struct stat s;
	char path[PATH_MAX];

	(void)snprintf(path, sizeof(path), "%s%s", _PATH_DEV, tty);
	if (stat(path, &s) < 0) {
		if (showerror)
			warn("%s", path);
		return(1);
	}
	*msgsokP = (s.st_mode & S_IWGRP) != 0;	/* group write bit */
	*atimeP = s.st_atime;
	return(0);
}

/*
 * do_write - actually make the connection
 */
void
do_write(char *tty, char *mytty, uid_t myuid)
{
	char *login, *nows;
	struct passwd *pwd;
	time_t now;
	char path[PATH_MAX], host[HOST_NAME_MAX+1], line[512];
	gid_t gid;
	int fd;

	/* Determine our login name before the we reopen() stdout */
	if ((login = getlogin()) == NULL) {
		if ((pwd = getpwuid(myuid)))
			login = pwd->pw_name;
		else
			login = "???";
	}

	(void)snprintf(path, sizeof(path), "%s%s", _PATH_DEV, tty);
	fd = open(path, O_WRONLY, 0666);
	if (fd == -1)
		err(1, "open %s", path);
	fflush(stdout);
	if (dup2(fd, STDOUT_FILENO) == -1)
		err(1, "dup2 %s", path);
	if (fd != STDOUT_FILENO)
		close(fd);

	/* revoke privs, now that we have opened the tty */
	gid = getgid();
	if (setresgid(gid, gid, gid) == -1)
		err(1, "setresgid");

	/*
	 * Unfortunately this is rather late - well after utmp
	 * parsing, then pinned by the tty open and setresgid
	 */
	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	(void)signal(SIGINT, done);
	(void)signal(SIGHUP, done);

	/* print greeting */
	if (gethostname(host, sizeof(host)) < 0)
		(void)strlcpy(host, "???", sizeof host);
	now = time(NULL);
	nows = ctime(&now);
	nows[16] = '\0';
	(void)printf("\r\n\007\007\007Message from %s@@%s on %s at %s ...\r\n",
	    login, host, mytty, nows + 11);

	while (fgets(line, sizeof(line), stdin) != NULL)
		wr_fputs(line);
}

/*
 * done - cleanup and exit
 */
void
done(int sig)
{
	(void)write(STDOUT_FILENO, "EOF\r\n", 5);
	if (sig)
		_exit(0);
	else
		exit(0);
}

/*
 * wr_fputs - like fputs(), but makes control characters visible and
 *     turns \n into \r\n
 */
void
wr_fputs(char *s)
{

#define	PUTC(c)	if (putchar(c) == EOF) goto err;

	for (; *s != '\0'; ++s) {
		if (*s == '\n') {
			PUTC('\r');
			PUTC('\n');
			continue;
		}
		if (isu8cont(*s))
			continue;
		if (isprint(*s) || isspace(*s) || *s == '\a') {
			PUTC(*s);
		} else {
			PUTC('?');
		}

	}
	return;

err:	err(1, NULL);
#undef PUTC
}

static int
isu8cont(unsigned char c)
{
	return (c & (0x80 | 0x40)) == 0x80;
}
@


1.32
log
@Fix write to other user's tty.  The device has to be opened with
O_WRONLY, but without O_CREAT.  So freopen(3) has to be replaced
with open(2) and dup2(2).
from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.31 2015/10/09 01:37:09 deraadt Exp $	*/
d37 1
d39 6
a47 1
#include <signal.h>
a48 3
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
a49 1
#include <limits.h>
a50 2
#include <err.h>
#include <vis.h>
d58 1
a299 2
	u_char c;
	char visout[5], *s2;
d304 1
a304 2
		c = toascii(*s);
		if (c == '\n') {
d309 8
a316 3
		vis(visout, c, VIS_SAFE|VIS_NOSLASH, s[1]);
		for (s2 = visout; *s2; s2++)
			PUTC(*s2);
d322 6
@


1.31
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.30 2015/10/06 03:25:02 deraadt Exp $	*/
d231 1
d242 8
a249 2
	if ((freopen(path, "r+", stdout)) == NULL)
		err(1, "%s", path);
@


1.30
log
@unfortunately tame "stdio" can only happen well after the sequence of:
utmp parsing, tty opening, setresgid to drop privs.  it only protects
a basic io loop.
discussed with doug
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.29 2015/10/05 07:09:46 deraadt Exp $	*/
d253 2
a254 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.29
log
@Since the dawn of time, this has contained freopen() for the tty path
with mode "w", as root, since "w" implies O_CREAT.  That will create
the raw file in /dev if it does not yet exist (due to a lie in utmp).
It should use "r+", to open it for for O_RDWR only.
Oh man this reminds me of 1988, how old is this bug?
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.28 2015/01/16 06:40:14 deraadt Exp $	*/
d248 7
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.27 2013/04/16 19:24:55 deraadt Exp $	*/
d241 1
a241 1
	if ((freopen(path, "w", stdout)) == NULL)
@


1.27
log
@remove casts to time_t * which are not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.26 2009/10/27 23:59:50 deraadt Exp $	*/
a35 1
#include <sys/param.h>
d47 1
d62 1
a62 1
	char tty[MAXPATHLEN], *mytty, *cp;
d207 1
a207 1
	char path[MAXPATHLEN];
d229 1
a229 1
	char path[MAXPATHLEN], host[MAXHOSTNAMELEN], line[512];
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.25 2008/07/06 13:42:35 sobrado Exp $	*/
d255 1
a255 1
	now = time((time_t *)NULL);
@


1.25
log
@sync synopsis and usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.24 2006/10/04 21:13:42 deraadt Exp $	*/
a34 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)write.c	8.2 (Berkeley) 4/27/95";
#endif
static char *rcsid = "$OpenBSD: write.c,v 1.24 2006/10/04 21:13:42 deraadt Exp $";
#endif /* not lint */
@


1.24
log
@if the utmp file is (mysteriously gone) do not assume that the user is
on the specified tty; problem noted by ilja@@suresec.org, ok various
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.23 2005/07/04 01:54:11 djm Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: write.c,v 1.23 2005/07/04 01:54:11 djm Exp $";
d120 1
a120 1
		(void)fprintf(stderr, "usage: write user [tty]\n");
@


1.23
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.22 2003/07/10 00:06:52 david Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: write.c,v 1.22 2003/07/10 00:06:52 david Exp $";
d140 1
a140 1
		return(0);	/* ignore error, shouldn't happen anyway */
@


1.22
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.21 2003/06/10 22:20:54 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: write.c,v 1.21 2003/06/10 22:20:54 deraadt Exp $";
d243 1
d258 3
a260 2
	setegid(getgid());
	setgid(getgid());
@


1.21
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.20 2003/06/03 02:56:24 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: write.c,v 1.20 2003/06/03 02:56:24 millert Exp $";
d53 1
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.19 2003/03/13 15:47:12 deraadt Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: write.c,v 1.19 2003/03/13 15:47:12 deraadt Exp $";
d72 1
a72 1
main(int argc, char **argv)
@


1.19
log
@a few more strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.18 2002/12/09 08:15:29 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char *rcsid = "$OpenBSD: write.c,v 1.18 2002/12/09 08:15:29 deraadt Exp $";
@


1.18
log
@do not use sys/types.h and sys/param.h together; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.17 2002/08/04 01:26:40 deraadt Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.17 2002/08/04 01:26:40 deraadt Exp $";
d71 1
a71 1
void search_utmp(char *, char *, char *, uid_t);
d106 1
a106 1
		search_utmp(argv[1], tty, mytty, myuid);
d168 1
a168 1
search_utmp(char *user, char *tty, char *mytty, uid_t myuid)
d197 1
a197 1
				(void)strcpy(tty, atty);
d206 1
a206 1
			(void)strcpy(tty, mytty);
d268 1
a268 1
		(void)strcpy(host, "???");
@


1.17
log
@ansi, and revoke privs after opening the tty
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.16 2002/02/21 07:32:55 fgsch Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.16 2002/02/21 07:32:55 fgsch Exp $";
a52 1
#include <sys/types.h>
@


1.16
log
@use sizeof w/ defines; niklas@@ millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.15 2002/02/16 21:27:59 millert Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.15 2002/02/16 21:27:59 millert Exp $";
d77 1
a77 3
main(argc, argv)
	int argc;
	char **argv;
d79 2
a80 1
	char *cp;
a82 2
	int msgsok, myttyfd;
	char tty[MAXPATHLEN], *mytty;
d138 1
a138 2
utmp_chk(user, tty)
	char *user, *tty;
d169 1
a169 3
search_utmp(user, tty, mytty, myuid)
	char *user, *tty, *mytty;
	uid_t myuid;
d221 1
a221 4
term_chk(tty, msgsokP, atimeP, showerror)
	char *tty;
	int *msgsokP, showerror;
	time_t *atimeP;
d241 1
a241 3
do_write(tty, mytty, myuid)
	char *tty, *mytty;
	uid_t myuid;
d260 4
d298 1
a298 2
wr_fputs(s)
	char *s;
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.14 2001/11/19 19:02:18 mpech Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.14 2001/11/19 19:02:18 mpech Exp $";
d114 2
a115 2
		if (!strncmp(argv[2], _PATH_DEV, strlen(_PATH_DEV)))
			argv[2] += strlen(_PATH_DEV);
@


1.14
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.13 2001/11/02 16:25:30 deraadt Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.13 2001/11/02 16:25:30 deraadt Exp $";
d69 6
a74 6
void done __P((int sig));
void do_write __P((char *, char *, uid_t));
void wr_fputs __P((char *));
void search_utmp __P((char *, char *, char *, uid_t));
int term_chk __P((char *, int *, time_t *, int));
int utmp_chk __P((char *, char *));
@


1.13
log
@avoid stdio in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.12 2001/06/27 06:53:55 jasoni Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.12 2001/06/27 06:53:55 jasoni Exp $";
d81 1
a81 1
	register char *cp;
d254 2
a255 2
	register char *login, *nows;
	register struct passwd *pwd;
d306 1
a306 1
	register char *s;
d308 1
a308 1
	register u_char c;
@


1.12
log
@-Wall cleanup; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.11 2001/01/19 17:58:21 deraadt Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.11 2001/01/19 17:58:21 deraadt Exp $";
d293 1
a293 1
	(void)printf("EOF\r\n");	/* XXX signal race */
@


1.11
log
@mark remaining signal races which are difficult to fix, and fix a few partially
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.10 1999/02/21 08:28:16 deraadt Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.10 1999/02/21 08:28:16 deraadt Exp $";
d98 1
a98 1
	if (cp = strrchr(mytty, '/'))
d131 1
d133 1
d260 2
a261 2
	if ((login = getlogin()) == NULL)
		if (pwd = getpwuid(myuid))
d265 1
@


1.10
log
@vis() buf overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.9 1998/07/06 18:35:20 deraadt Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.9 1998/07/06 18:35:20 deraadt Exp $";
d69 1
a69 1
void done(); 
d130 1
a130 1
	done();
d288 1
a288 1
done()
d290 5
a294 2
	(void)printf("EOF\r\n");
	exit(0);
@


1.9
log
@kill non-POSIX S_IWRITE
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.8 1996/10/26 22:49:12 downsj Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.8 1996/10/26 22:49:12 downsj Exp $";
d303 1
a303 1
	char visout[4], *s2;
@


1.8
log
@missed one change, pointed out by Alex Nash <nash@@mcs.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.7 1996/10/25 06:15:03 downsj Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.7 1996/10/25 06:15:03 downsj Exp $";
d239 1
a239 1
	*msgsokP = (s.st_mode & (S_IWRITE >> 3)) != 0;	/* group write bit */
@


1.7
log
@kill sprintf, use paths.h
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.6 1996/08/26 10:28:20 deraadt Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.6 1996/08/26 10:28:20 deraadt Exp $";
d115 1
a115 1
			argv[2] += 5;
@


1.6
log
@VIS_NOSLASH
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.5 1996/08/26 10:22:11 deraadt Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.5 1996/08/26 10:22:11 deraadt Exp $";
d62 1
d114 1
a114 1
		if (!strncmp(argv[2], "/dev/", 5))
d233 1
a233 1
	(void)sprintf(path, "/dev/%s", tty);
d264 1
a264 1
	(void)sprintf(path, "/dev/%s", tty);
@


1.5
log
@vis this baby too
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.4 1996/06/26 05:44:00 deraadt Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.4 1996/06/26 05:44:00 deraadt Exp $";
d313 1
a313 1
		vis(visout, c, VIS_SAFE, s[1]);
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: write.c,v 1.5 1995/08/31 21:48:32 jtc Exp $	*/
d50 1
a50 1
static char *rcsid = "$OpenBSD: write.c,v 1.5 1995/08/31 21:48:32 jtc Exp $";
d66 1
d301 2
a302 1
	register char c;
d310 2
a311 9
		} else if (!isprint(c) && !isspace(c) && c != '\007') {
			if (c & 0x80) {
				PUTC('M');
				PUTC('-');
				c &= ~0x80;
			} else {
				PUTC('^');
				c &= ~0x40;
			}
d313 3
a315 1
		PUTC(c);
@


1.3
log
@handle meta characters; good security idea from freebsd
@
text
@d1 1
d50 1
a50 1
static char *rcsid = "$NetBSD: write.c,v 1.5 1995/08/31 21:48:32 jtc Exp $";
@


1.2
log
@warn if my permissions are off; but still allow a write
@
text
@a306 1
			PUTC('\n');
d308 10
a317 4
			PUTC('^');
			PUTC(c^0x40);	/* DEL to ?, others to alpha */
		} else
			PUTC(c);
@


1.1
log
@Initial revision
@
text
@d100 1
a100 1
		errx(1, "you have write permission turned off");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
