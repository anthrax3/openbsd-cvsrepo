head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2016.12.18.06.11.23;	author krw;	state Exp;
branches;
next	1.18;
commitid	fCnIjtvaaZwmYSr8;

1.18
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.17;
commitid	01nAnartGL7onLD3;

1.17
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.16;
commitid	ruCZ2IKF0FB0ebCr;

1.16
date	2016.01.06.22.29.38;	author millert;	state Exp;
branches;
next	1.15;
commitid	RiORzAsItDrPYyBm;

1.15
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	gtDERb7QyXwKGs62;

1.14
date	2015.04.24.21.48.31;	author brynet;	state Exp;
branches;
next	1.13;
commitid	snOxq6D74oYtevTu;

1.13
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.12;
commitid	06bi6U3x4gFFf2G1;

1.12
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.49;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.55;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.07.27.22.28.24;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.01.18.58;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.20.22.56.13;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.16.09;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.37.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Nuke more unused variables.

ok millert@@
@
text
@/*	$OpenBSD: vs_msg.c,v 1.18 2016/05/27 09:18:12 martijn Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "../common/common.h"
#include "vi.h"

typedef enum {
	SCROLL_W,			/* User wait. */
	SCROLL_W_EX,			/* User wait, or enter : to continue. */
	SCROLL_W_QUIT			/* User wait, or enter q to quit. */
					/*
					 * SCROLL_W_QUIT has another semantic
					 * -- only wait if the screen is full
					 */
} sw_t;

static void	vs_divider(SCR *);
static void	vs_msgsave(SCR *, mtype_t, char *, size_t);
static void	vs_output(SCR *, mtype_t, const char *, int);
static void	vs_scroll(SCR *, int *, sw_t);
static void	vs_wait(SCR *, int *, sw_t);

/*
 * vs_busy --
 *	Display, update or clear a busy message.
 *
 * This routine is the default editor interface for vi busy messages.  It
 * implements a standard strategy of stealing lines from the bottom of the
 * vi text screen.  Screens using an alternate method of displaying busy
 * messages, e.g. X11 clock icons, should set their scr_busy function to the
 * correct function before calling the main editor routine.
 *
 * PUBLIC: void vs_busy(SCR *, const char *, busy_t);
 */
void
vs_busy(SCR *sp, const char *msg, busy_t btype)
{
	GS *gp;
	VI_PRIVATE *vip;
	static const char flagc[] = "|/-\\";
	struct timespec ts, ts_diff;
	size_t notused;

	/* Ex doesn't display busy messages. */
	if (F_ISSET(sp, SC_EX | SC_SCR_EXWROTE))
		return;

	gp = sp->gp;
	vip = VIP(sp);

	/*
	 * Most of this routine is to deal with the screen sharing real estate
	 * between the normal edit messages and the busy messages.  Logically,
	 * all that's needed is something that puts up a message, periodically
	 * updates it, and then goes away.
	 */
	switch (btype) {
	case BUSY_ON:
		++vip->busy_ref;
		if (vip->totalcount != 0 || vip->busy_ref != 1)
			break;

		/* Initialize state for updates. */
		vip->busy_ch = 0;
		(void)clock_gettime(CLOCK_MONOTONIC, &vip->busy_ts);

		/* Save the current cursor. */
		(void)gp->scr_cursor(sp, &vip->busy_oldy, &vip->busy_oldx);

		/* Display the busy message. */
		(void)gp->scr_move(sp, LASTLINE(sp), 0);
		(void)gp->scr_addstr(sp, msg, strlen(msg));
		(void)gp->scr_cursor(sp, &notused, &vip->busy_fx);
		(void)gp->scr_clrtoeol(sp);
		(void)gp->scr_move(sp, LASTLINE(sp), vip->busy_fx);
		break;
	case BUSY_OFF:
		if (vip->busy_ref == 0)
			break;
		--vip->busy_ref;

		/*
		 * If the line isn't in use for another purpose, clear it.
		 * Always return to the original position.
		 */
		if (vip->totalcount == 0 && vip->busy_ref == 0) {
			(void)gp->scr_move(sp, LASTLINE(sp), 0);
			(void)gp->scr_clrtoeol(sp);
		}
		(void)gp->scr_move(sp, vip->busy_oldy, vip->busy_oldx);
		break;
	case BUSY_UPDATE:
		if (vip->totalcount != 0 || vip->busy_ref == 0)
			break;

		/* Update no more than every 1/8 of a second. */
		(void)clock_gettime(CLOCK_MONOTONIC, &ts);
		ts_diff = ts;
		ts_diff.tv_sec -= vip->busy_ts.tv_sec;
		ts_diff.tv_nsec -= vip->busy_ts.tv_nsec;
		if (ts_diff.tv_nsec < 0) {
			ts_diff.tv_sec--;
			ts_diff.tv_nsec += 1000000000;
		}
		if ((ts_diff.tv_sec == 0 && ts_diff.tv_nsec < 125000000) ||
		    ts_diff.tv_sec < 0)
			return;
		vip->busy_ts = ts;

		/* Display the update. */
		if (vip->busy_ch == sizeof(flagc) - 1)
			vip->busy_ch = 0;
		(void)gp->scr_move(sp, LASTLINE(sp), vip->busy_fx);
		(void)gp->scr_addstr(sp, flagc + vip->busy_ch++, 1);
		(void)gp->scr_move(sp, LASTLINE(sp), vip->busy_fx);
		break;
	}
	(void)gp->scr_refresh(sp, 0);
}

/* 
 * vs_home --
 *	Home the cursor to the bottom row, left-most column.
 *
 * PUBLIC: void vs_home(SCR *);
 */
void
vs_home(SCR *sp)
{
	(void)sp->gp->scr_move(sp, LASTLINE(sp), 0);
	(void)sp->gp->scr_refresh(sp, 0);
}

/*
 * vs_update --
 *	Update a command.
 *
 * PUBLIC: void vs_update(SCR *, const char *, const char *);
 */
void
vs_update(SCR *sp, const char *m1, const char *m2)
{
	GS *gp;
	size_t len, mlen, oldx, oldy;

	gp = sp->gp;

	/*
	 * This routine displays a message on the bottom line of the screen,
	 * without updating any of the command structures that would keep it
	 * there for any period of time, i.e. it is overwritten immediately.
	 *
	 * It's used by the ex read and ! commands when the user's command is
	 * expanded, and by the ex substitution confirmation prompt.
	 */
	if (F_ISSET(sp, SC_SCR_EXWROTE)) {
		(void)ex_printf(sp,
		    "%s\n", m1 == NULL? "" : m1, m2 == NULL ? "" : m2);
		(void)ex_fflush(sp);
	}

	/*
	 * Save the cursor position, the substitute-with-confirmation code
	 * will have already set it correctly.
	 */
	(void)gp->scr_cursor(sp, &oldy, &oldx);

	/* Clear the bottom line. */
	(void)gp->scr_move(sp, LASTLINE(sp), 0);
	(void)gp->scr_clrtoeol(sp);

	/*
	 * XXX
	 * Don't let long file names screw up the screen.
	 */
	if (m1 != NULL) {
		mlen = len = strlen(m1);
		if (len > sp->cols - 2)
			mlen = len = sp->cols - 2;
		(void)gp->scr_addstr(sp, m1, mlen);
	} else
		len = 0;
	if (m2 != NULL) {
		mlen = strlen(m2);
		if (len + mlen > sp->cols - 2)
			mlen = (sp->cols - 2) - len;
		(void)gp->scr_addstr(sp, m2, mlen);
	}

	(void)gp->scr_move(sp, oldy, oldx);
	(void)gp->scr_refresh(sp, 0);
}

/*
 * vs_msg --
 *	Display ex output or error messages for the screen.
 *
 * This routine is the default editor interface for all ex output, and all ex
 * and vi error/informational messages.  It implements the standard strategy
 * of stealing lines from the bottom of the vi text screen.  Screens using an
 * alternate method of displaying messages, e.g. dialog boxes, should set their
 * scr_msg function to the correct function before calling the editor.
 *
 * PUBLIC: void vs_msg(SCR *, mtype_t, char *, size_t);
 */
void
vs_msg(SCR *sp, mtype_t mtype, char *line, size_t len)
{
	GS *gp;
	VI_PRIVATE *vip;
	size_t maxcols, oldx, oldy, padding;
	const char *e, *s, *t;

	gp = sp->gp;
	vip = VIP(sp);

	/*
	 * Ring the bell if it's scheduled.
	 *
	 * XXX
	 * Shouldn't we save this, too?
	 */
	if (F_ISSET(sp, SC_TINPUT_INFO) || F_ISSET(gp, G_BELLSCHED)) {
		if (F_ISSET(sp, SC_SCR_VI)) {
			F_CLR(gp, G_BELLSCHED);
			(void)gp->scr_bell(sp);
		} else
			F_SET(gp, G_BELLSCHED);
	}

	/*
	 * If vi is using the error line for text input, there's no screen
	 * real-estate for the error message.  Nothing to do without some
	 * information as to how important the error message is.
	 */
	if (F_ISSET(sp, SC_TINPUT_INFO))
		return;

	/*
	 * Ex or ex controlled screen output.
	 *
	 * If output happens during startup, e.g., a .exrc file, we may be
	 * in ex mode but haven't initialized the screen.  Initialize here,
	 * and in this case, stay in ex mode.
	 *
	 * If the SC_SCR_EXWROTE bit is set, then we're switching back and
	 * forth between ex and vi, but the screen is trashed and we have
	 * to respect that.  Switch to ex mode long enough to put out the
	 * message.
	 *
	 * If the SC_EX_WAIT_NO bit is set, turn it off -- we're writing to
	 * the screen, so previous opinions are ignored.
	 */
	if (F_ISSET(sp, SC_EX | SC_SCR_EXWROTE)) {
		if (!F_ISSET(sp, SC_SCR_EX)) {
			if (F_ISSET(sp, SC_SCR_EXWROTE)) {
				if (sp->gp->scr_screen(sp, SC_EX))
					return;
			} else
				if (ex_init(sp))
					return;
		}

		if (mtype == M_ERR)
			(void)gp->scr_attr(sp, SA_INVERSE, 1);
		(void)printf("%.*s", (int)len, line);
		if (mtype == M_ERR)
			(void)gp->scr_attr(sp, SA_INVERSE, 0);
		(void)fflush(stdout);

		F_CLR(sp, SC_EX_WAIT_NO);

		if (!F_ISSET(sp, SC_SCR_EX))
			(void)sp->gp->scr_screen(sp, SC_VI);
		return;
	}

	/* If the vi screen isn't ready, save the message. */
	if (!F_ISSET(sp, SC_SCR_VI)) {
		(void)vs_msgsave(sp, mtype, line, len);
		return;
	}

	/* Save the cursor position. */
	(void)gp->scr_cursor(sp, &oldy, &oldx);

	/* If it's an ex output message, just write it out. */
	if (mtype == M_NONE) {
		vs_output(sp, mtype, line, len);
		goto ret;
	}

	/*
	 * If it's a vi message, strip the trailing <newline> so we can
	 * try and paste messages together.
	 */
	if (line[len - 1] == '\n')
		--len;

	/*
	 * If a message won't fit on a single line, try to split on a <blank>.
	 * If a subsequent message fits on the same line, write a separator
	 * and output it.  Otherwise, put out a newline.
	 *
	 * Need up to two padding characters normally; a semi-colon and a
	 * separating space.  If only a single line on the screen, add some
	 * more for the trailing continuation message.
	 *
	 * XXX
	 * Assume that periods and semi-colons take up a single column on the
	 * screen.
	 *
	 * XXX
	 * There are almost certainly pathological cases that will break this
	 * code.
	 */
	if (IS_ONELINE(sp))
		(void)msg_cmsg(sp, CMSG_CONT_S, &padding);
	else
		padding = 0;
	padding += 2;

	maxcols = sp->cols - 1;
	if (vip->lcontinue != 0) {
		if (len + vip->lcontinue + padding > maxcols)
			vs_output(sp, vip->mtype, ".\n", 2);
		else  {
			vs_output(sp, vip->mtype, ";", 1);
			vs_output(sp, M_NONE, " ", 1);
		}
	}
	vip->mtype = mtype;
	for (s = line;; s = t) {
		for (; len > 0 && isblank(*s); --len, ++s);
		if (len == 0)
			break;
		if (len + vip->lcontinue > maxcols) {
			for (e = s + (maxcols - vip->lcontinue);
			    e > s && !isblank(*e); --e);
			if (e == s)
				 e = t = s + (maxcols - vip->lcontinue);
			else
				for (t = e; isblank(e[-1]); --e);
		} else
			e = t = s + len;

		/*
		 * If the message ends in a period, discard it, we want to
		 * gang messages where possible.
		 */
		len -= t - s;
		if (len == 0 && (e - s) > 1 && s[(e - s) - 1] == '.')
			--e;
		vs_output(sp, mtype, s, e - s);

		if (len != 0)
			vs_output(sp, M_NONE, "\n", 1);

		if (INTERRUPTED(sp))
			break;
	}

ret:	(void)gp->scr_move(sp, oldy, oldx);
	(void)gp->scr_refresh(sp, 0);
}

/*
 * vs_output --
 *	Output the text to the screen.
 */
static void
vs_output(SCR *sp, mtype_t mtype, const char *line, int llen)
{
	CHAR_T *kp;
	GS *gp;
	VI_PRIVATE *vip;
	size_t chlen, notused;
	int ch, len, tlen;
	const char *p, *t;
	char *cbp, *ecbp, cbuf[128];

	gp = sp->gp;
	vip = VIP(sp);
	for (p = line; llen > 0;) {
		/* Get the next physical line. */
		if ((p = memchr(line, '\n', llen)) == NULL)
			len = llen;
		else
			len = p - line;

		/*
		 * The max is sp->cols characters, and we may have already
		 * written part of the line.
		 */
		if (len + vip->lcontinue > sp->cols)
			len = sp->cols - vip->lcontinue;

		/*
		 * If the first line output, do nothing.  If the second line
		 * output, draw the divider line.  If drew a full screen, we
		 * remove the divider line.  If it's a continuation line, move
		 * to the continuation point, else, move the screen up.
		 */
		if (vip->lcontinue == 0) {
			if (!IS_ONELINE(sp)) {
				if (vip->totalcount == 1) {
					(void)gp->scr_move(sp,
					    LASTLINE(sp) - 1, 0);
					(void)gp->scr_clrtoeol(sp);
					(void)vs_divider(sp);
					F_SET(vip, VIP_DIVIDER);
					++vip->totalcount;
					++vip->linecount;
				}
				if (vip->totalcount == sp->t_maxrows &&
				    F_ISSET(vip, VIP_DIVIDER)) {
					--vip->totalcount;
					--vip->linecount;
					F_CLR(vip, VIP_DIVIDER);
				}
			}
			if (vip->totalcount != 0)
				vs_scroll(sp, NULL, SCROLL_W_QUIT);

			(void)gp->scr_move(sp, LASTLINE(sp), 0);
			++vip->totalcount;
			++vip->linecount;

			if (INTERRUPTED(sp))
				break;
		} else
			(void)gp->scr_move(sp, LASTLINE(sp), vip->lcontinue);

		/* Error messages are in inverse video. */
		if (mtype == M_ERR)
			(void)gp->scr_attr(sp, SA_INVERSE, 1);

		/* Display the line, doing character translation. */
#define	FLUSH {								\
	*cbp = '\0';							\
	(void)gp->scr_addstr(sp, cbuf, cbp - cbuf);			\
	cbp = cbuf;							\
}
		ecbp = (cbp = cbuf) + sizeof(cbuf) - 1;
		for (t = line, tlen = len; tlen--; ++t) {
			ch = *t;
			/*
			 * Replace tabs with spaces, there are places in
			 * ex that do column calculations without looking
			 * at <tabs> -- and all routines that care about
			 * <tabs> do their own expansions.  This catches
			 * <tabs> in things like tag search strings.
			 */
			if (ch == '\t')
				ch = ' ';
			chlen = KEY_LEN(sp, ch);
			if (cbp + chlen >= ecbp)
				FLUSH;
			for (kp = KEY_NAME(sp, ch); chlen--;)
				*cbp++ = *kp++;
		}
		if (cbp > cbuf)
			FLUSH;
		if (mtype == M_ERR)
			(void)gp->scr_attr(sp, SA_INVERSE, 0);

		/* Clear the rest of the line. */
		(void)gp->scr_clrtoeol(sp);

		/* If we loop, it's a new line. */
		vip->lcontinue = 0;

		/* Reset for the next line. */
		line += len;
		llen -= len;
		if (p != NULL) {
			++line;
			--llen;
		}
	}

	/* Set up next continuation line. */
	if (p == NULL)
		gp->scr_cursor(sp, &notused, &vip->lcontinue);
}

/*
 * vs_ex_resolve --
 *	Deal with ex message output.
 *
 * This routine is called when exiting a colon command to resolve any ex
 * output that may have occurred.
 *
 * PUBLIC: int vs_ex_resolve(SCR *, int *);
 */
int
vs_ex_resolve(SCR *sp, int *continuep)
{
	EVENT ev;
	GS *gp;
	VI_PRIVATE *vip;
	sw_t wtype;

	gp = sp->gp;
	vip = VIP(sp);
	*continuep = 0;

	/* If we ran any ex command, we can't trust the cursor position. */
	F_SET(vip, VIP_CUR_INVALID);

	/* Terminate any partially written message. */
	if (vip->lcontinue != 0) {
		vs_output(sp, vip->mtype, ".", 1);
		vip->lcontinue = 0;

		vip->mtype = M_NONE;
	}

	/*
	 * If we switched out of the vi screen into ex, switch back while we
	 * figure out what to do with the screen and potentially get another
	 * command to execute.
	 *
	 * If we didn't switch into ex, we're not required to wait, and less
	 * than 2 lines of output, we can continue without waiting for the
	 * wait.
	 *
	 * Note, all other code paths require waiting, so we leave the report
	 * of modified lines until later, so that we won't wait for no other
	 * reason than a threshold number of lines were modified.  This means
	 * we display cumulative line modification reports for groups of ex
	 * commands.  That seems right to me (well, at least not wrong).
	 */
	if (F_ISSET(sp, SC_SCR_EXWROTE)) {
		if (sp->gp->scr_screen(sp, SC_VI))
			return (1);
	} else
		if (!F_ISSET(sp, SC_EX_WAIT_YES) && vip->totalcount < 2) {
			F_CLR(sp, SC_EX_WAIT_NO);
			return (0);
		}

	/* Clear the required wait flag, it's no longer needed. */
	F_CLR(sp, SC_EX_WAIT_YES);

	/*
	 * Wait, unless explicitly told not to wait or the user interrupted
	 * the command.  If the user is leaving the screen, for any reason,
	 * they can't continue with further ex commands.
	 */
	if (!F_ISSET(sp, SC_EX_WAIT_NO) && !INTERRUPTED(sp)) {
		wtype = F_ISSET(sp, SC_EXIT | SC_EXIT_FORCE |
		    SC_FSWITCH | SC_SSWITCH) ? SCROLL_W : SCROLL_W_EX;
		if (F_ISSET(sp, SC_SCR_EXWROTE))
			vs_wait(sp, continuep, wtype);
		else
			vs_scroll(sp, continuep, wtype);
		if (*continuep)
			return (0);
	}

	/* If ex wrote on the screen, refresh the screen image. */
	if (F_ISSET(sp, SC_SCR_EXWROTE))
		F_SET(vip, VIP_N_EX_PAINT);

	/*
	 * If we're not the bottom of the split screen stack, the screen
	 * image itself is wrong, so redraw everything.
	 */
	if (TAILQ_NEXT(sp, q))
		F_SET(sp, SC_SCR_REDRAW);

	/* If ex changed the underlying file, the map itself is wrong. */
	if (F_ISSET(vip, VIP_N_EX_REDRAW))
		F_SET(sp, SC_SCR_REFORMAT);

	/* Ex may have switched out of the alternate screen, return. */
	(void)gp->scr_attr(sp, SA_ALTERNATE, 1);

	/*
	 * Whew.  We're finally back home, after what feels like years.
	 * Kiss the ground.
	 */
	F_CLR(sp, SC_SCR_EXWROTE | SC_EX_WAIT_NO);

	/*
	 * We may need to repaint some of the screen, e.g.:
	 *
	 *	:set
	 *	:!ls
	 *
	 * gives us a combination of some lines that are "wrong", and a need
	 * for a full refresh.
	 */
	if (vip->totalcount > 1) {
		/* Set up the redraw of the overwritten lines. */
		ev.e_event = E_REPAINT;
		ev.e_flno = vip->totalcount >=
		    sp->rows ? 1 : sp->rows - vip->totalcount;
		ev.e_tlno = sp->rows;

		/* Reset the count of overwriting lines. */
		vip->linecount = vip->lcontinue = vip->totalcount = 0;

		/* Redraw. */
		(void)vs_repaint(sp, &ev);
	} else
		/* Reset the count of overwriting lines. */
		vip->linecount = vip->lcontinue = vip->totalcount = 0;

	return (0);
}

/*
 * vs_resolve --
 *	Deal with message output.
 *
 * PUBLIC: int vs_resolve(SCR *, SCR *, int);
 */
int
vs_resolve(SCR *sp, SCR *csp, int forcewait)
{
	EVENT ev;
	GS *gp;
	MSGS *mp;
	VI_PRIVATE *vip;
	size_t oldy, oldx;
	int redraw;

	/*
	 * Vs_resolve is called from the main vi loop and the refresh function
	 * to periodically ensure that the user has seen any messages that have
	 * been displayed and that any status lines are correct.  The sp screen
	 * is the screen we're checking, usually the current screen.  When it's
	 * not, csp is the current screen, used for final cursor positioning.
	 */
	gp = sp->gp;
	vip = VIP(sp);
	if (csp == NULL)
		csp = sp;

	/* Save the cursor position. */
	(void)gp->scr_cursor(csp, &oldy, &oldx);

	/* Ring the bell if it's scheduled. */
	if (F_ISSET(gp, G_BELLSCHED)) {
		F_CLR(gp, G_BELLSCHED);
		(void)gp->scr_bell(sp);
	}

	/* Display new file status line. */
	if (F_ISSET(sp, SC_STATUS)) {
		F_CLR(sp, SC_STATUS);
		msgq_status(sp, sp->lno, MSTAT_TRUNCATE);
	}

	/* Report on line modifications. */
	mod_rpt(sp);

	/*
	 * Flush any saved messages.  If the screen isn't ready, refresh
	 * it.  (A side-effect of screen refresh is that we can display
	 * messages.)  Once this is done, don't trust the cursor.  That
	 * extra refresh screwed the pooch.
	 */
	if (LIST_FIRST(&gp->msgq) != NULL) {
		if (!F_ISSET(sp, SC_SCR_VI) && vs_refresh(sp, 1))
			return (1);
		while ((mp = LIST_FIRST(&gp->msgq)) != NULL) {
			gp->scr_msg(sp, mp->mtype, mp->buf, mp->len);
			LIST_REMOVE(mp, q);
			free(mp->buf);
			free(mp);
		}
		F_SET(vip, VIP_CUR_INVALID);
	}

	switch (vip->totalcount) {
	case 0:
		redraw = 0;
		break;
	case 1:
		/*
		 * If we're switching screens, we have to wait for messages,
		 * regardless.  If we don't wait, skip updating the modeline.
		 */
		if (forcewait)
			vs_scroll(sp, NULL, SCROLL_W);
		else
			F_SET(vip, VIP_S_MODELINE);

		redraw = 0;
		break;
	default:
		/*
		 * If >1 message line in use, prompt the user to continue and
		 * repaint overwritten lines.
		 */
		vs_scroll(sp, NULL, SCROLL_W);

		ev.e_event = E_REPAINT;
		ev.e_flno = vip->totalcount >=
		    sp->rows ? 1 : sp->rows - vip->totalcount;
		ev.e_tlno = sp->rows;

		redraw = 1;
		break;
	}

	/* Reset the count of overwriting lines. */
	vip->linecount = vip->lcontinue = vip->totalcount = 0;

	/* Redraw. */
	if (redraw)
		(void)vs_repaint(sp, &ev);

	/* Restore the cursor position. */
	(void)gp->scr_move(csp, oldy, oldx);

	return (0);
}

/*
 * vs_scroll --
 *	Scroll the screen for output.
 */
static void
vs_scroll(SCR *sp, int *continuep, sw_t wtype)
{
	GS *gp;
	VI_PRIVATE *vip;

	gp = sp->gp;
	vip = VIP(sp);
	if (!IS_ONELINE(sp)) {
		/*
		 * Scroll the screen.  Instead of scrolling the entire screen,
		 * delete the line above the first line output so preserve the
		 * maximum amount of the screen.
		 */
		(void)gp->scr_move(sp, vip->totalcount <
		    sp->rows ? LASTLINE(sp) - vip->totalcount : 0, 0);
		(void)gp->scr_deleteln(sp);

		/* If there are screens below us, push them back into place. */
		if (TAILQ_NEXT(sp, q)) {
			(void)gp->scr_move(sp, LASTLINE(sp), 0);
			(void)gp->scr_insertln(sp);
		}
	}
	if (wtype == SCROLL_W_QUIT && vip->linecount < sp->t_maxrows)
		return;
	vs_wait(sp, continuep, wtype);
}

/*
 * vs_wait --
 *	Prompt the user to continue.
 */
static void
vs_wait(SCR *sp, int *continuep, sw_t wtype)
{
	EVENT ev;
	VI_PRIVATE *vip;
	const char *p;
	GS *gp;
	size_t len;

	gp = sp->gp;
	vip = VIP(sp);

	(void)gp->scr_move(sp, LASTLINE(sp), 0);
	if (IS_ONELINE(sp))
		p = msg_cmsg(sp, CMSG_CONT_S, &len);
	else
		switch (wtype) {
		case SCROLL_W_QUIT:
			p = msg_cmsg(sp, CMSG_CONT_Q, &len);
			break;
		case SCROLL_W_EX:
			p = msg_cmsg(sp, CMSG_CONT_EX, &len);
			break;
		case SCROLL_W:
			p = msg_cmsg(sp, CMSG_CONT, &len);
			break;
		default:
			abort();
			/* NOTREACHED */
		}
	(void)gp->scr_addstr(sp, p, len);

	++vip->totalcount;
	vip->linecount = 0;

	(void)gp->scr_clrtoeol(sp);
	(void)gp->scr_refresh(sp, 0);

	/* Get a single character from the terminal. */
	if (continuep != NULL)
		*continuep = 0;
	for (;;) {
		if (v_event_get(sp, &ev, 0, 0))
			return;
		if (ev.e_event == E_CHARACTER)
			break;
		if (ev.e_event == E_INTERRUPT) {
			ev.e_c = CH_QUIT;
			F_SET(gp, G_INTERRUPTED);
			break;
		}
		(void)gp->scr_bell(sp);
	}
	switch (wtype) {
	case SCROLL_W_QUIT:
		if (ev.e_c == CH_QUIT)
			F_SET(gp, G_INTERRUPTED);
		break;
	case SCROLL_W_EX:
		if (ev.e_c == ':' && continuep != NULL)
			*continuep = 1;
		break;
	case SCROLL_W:
		break;
	}
}

/*
 * vs_divider --
 *	Draw a dividing line between the screen and the output.
 */
static void
vs_divider(SCR *sp)
{
	GS *gp;
	size_t len;

#define	DIVIDESTR	"+=+=+=+=+=+=+=+"
	len =
	    sizeof(DIVIDESTR) - 1 > sp->cols ? sp->cols : sizeof(DIVIDESTR) - 1;
	gp = sp->gp;
	(void)gp->scr_attr(sp, SA_INVERSE, 1);
	(void)gp->scr_addstr(sp, DIVIDESTR, len);
	(void)gp->scr_attr(sp, SA_INVERSE, 0);
}

/*
 * vs_msgsave --
 *	Save a message for later display.
 */
static void
vs_msgsave(SCR *sp, mtype_t mt, char *p, size_t len)
{
	GS *gp;
	MSGS *mp_c, *mp_n;

	/*
	 * We have to handle messages before we have any place to put them.
	 * If there's no screen support yet, allocate a msg structure, copy
	 * in the message, and queue it on the global structure.  If we can't
	 * allocate memory here, we're genuinely screwed, dump the message
	 * to stderr in the (probably) vain hope that someone will see it.
	 */
	CALLOC_GOTO(sp, mp_n, 1, sizeof(MSGS));
	MALLOC_GOTO(sp, mp_n->buf, len);

	memmove(mp_n->buf, p, len);
	mp_n->len = len;
	mp_n->mtype = mt;

	gp = sp->gp;
	if ((mp_c = LIST_FIRST(&gp->msgq)) == NULL) {
		LIST_INSERT_HEAD(&gp->msgq, mp_n, q);
	} else {
		for (; LIST_NEXT(mp_c, q) != NULL; mp_c = LIST_NEXT(mp_c, q));
		LIST_INSERT_AFTER(mp_c, mp_n, q);
	}
	return;

alloc_err:
	if (mp_n != NULL)
		free(mp_n);
	(void)fprintf(stderr, "%.*s\n", (int)len, p);
}
@


1.18
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.16 2016/01/06 22:29:38 millert Exp $	*/
d64 1
a64 1
	size_t len, notused;
@


1.17
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d396 1
d402 1
a402 1
	char *kp, *cbp, *ecbp, cbuf[128];
@


1.16
log
@Remove the msg_cat() function and adjust its former callers.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.15 2015/12/07 20:39:19 mmcc Exp $	*/
a395 1
	CHAR_T *kp;
d401 1
a401 1
	char *cbp, *ecbp, cbuf[128];
@


1.15
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.14 2015/04/24 21:48:31 brynet Exp $	*/
a64 1
	const char *p;
a92 1
		p = msg_cat(sp, msg, &len);
d94 1
a94 1
		(void)gp->scr_addstr(sp, p, len);
@


1.14
log
@struct timespec/clock_gettime(3) conversion for vi(1).

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.13 2014/11/12 04:28:41 bentley Exp $	*/
d887 2
a888 2
	CALLOC_GOTO(sp, mp_n, MSGS *, 1, sizeof(MSGS));
	MALLOC_GOTO(sp, mp_n->buf, char *, len);
@


1.13
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.12 2013/11/28 22:12:40 krw Exp $	*/
d23 1
d63 1
a63 1
	struct timeval tv;
d88 1
a88 1
		(void)gettimeofday(&vip->busy_tv, NULL);
d121 10
a130 3
		(void)gettimeofday(&tv, NULL);
		if (((tv.tv_sec - vip->busy_tv.tv_sec) * 1000000 +
		    (tv.tv_usec - vip->busy_tv.tv_usec)) < 125000)
d132 1
a132 1
		vip->busy_tv = tv;
@


1.12
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.11 2009/10/27 23:59:49 deraadt Exp $	*/
d57 1
a57 4
vs_busy(sp, msg, btype)
	SCR *sp;
	const char *msg;
	busy_t btype;
d144 1
a144 2
vs_home(sp)
	SCR *sp;
d157 1
a157 3
vs_update(sp, m1, m2)
	SCR *sp;
	const char *m1, *m2;
d223 1
a223 5
vs_msg(sp, mtype, line, len)
	SCR *sp;
	mtype_t mtype;
	char *line;
	size_t len;
d388 1
a388 5
vs_output(sp, mtype, line, llen)
	SCR *sp;
	mtype_t mtype;
	const char *line;
	int llen;
d513 1
a513 3
vs_ex_resolve(sp, continuep)
	SCR *sp;
	int *continuep;
d637 1
a637 3
vs_resolve(sp, csp, forcewait)
	SCR *sp, *csp;
	int forcewait;
d744 1
a744 4
vs_scroll(sp, continuep, wtype)
	SCR *sp;
	int *continuep;
	sw_t wtype;
d777 1
a777 4
vs_wait(sp, continuep, wtype)
	SCR *sp;
	int *continuep;
	sw_t wtype;
d848 1
a848 2
vs_divider(sp)
	SCR *sp;
d867 1
a867 5
vs_msgsave(sp, mt, p, len)
	SCR *sp;
	mtype_t mt;
	char *p;
	size_t len;
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.10 2006/04/22 03:09:15 ray Exp $	*/
d602 1
a602 1
	if (CIRCLEQ_NEXT(sp, q) != CIRCLEQ_END(&sp->gp->dq))
d783 1
a783 1
		if (CIRCLEQ_NEXT(sp, q) != CIRCLEQ_END(&sp->gp->dq)) {
@


1.10
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.9 2006/01/08 21:05:40 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)vs_msg.c	10.77 (Berkeley) 10/13/96";
#endif /* not lint */
@


1.9
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.8 2005/10/17 19:12:16 otto Exp $	*/
d412 1
a412 1
	int ch, len, rlen, tlen;
d418 1
a418 1
	for (p = line, rlen = llen; llen > 0;) {
@


1.8
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.7 2002/02/16 21:27:58 millert Exp $	*/
d253 1
a253 1
	if (F_ISSET(sp, SC_TINPUT_INFO) || F_ISSET(gp, G_BELLSCHED))
d259 1
d285 1
a285 1
		if (!F_ISSET(sp, SC_SCR_EX))
d292 1
d354 1
a354 1
	if (vip->lcontinue != 0)
d361 1
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_msg.c,v 1.6 2001/01/29 01:58:55 niklas Exp $	*/
d603 1
a603 1
	if (sp->q.cqe_next != (void *)&sp->gp->dq)
d701 1
a701 1
	if (gp->msgq.lh_first != NULL) {
d704 1
a704 1
		while ((mp = gp->msgq.lh_first) != NULL) {
d784 1
a784 1
		if (sp->q.cqe_next != (void *)&sp->gp->dq) {
d917 1
a917 1
	if ((mp_c = gp->msgq.lh_first) == NULL) {
d920 1
a920 1
		for (; mp_c->q.le_next != NULL; mp_c = mp_c->q.le_next);
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 5
a46 5
static void	vs_divider __P((SCR *));
static void	vs_msgsave __P((SCR *, mtype_t, char *, size_t));
static void	vs_output __P((SCR *, mtype_t, const char *, int));
static void	vs_scroll __P((SCR *, int *, sw_t));
static void	vs_wait __P((SCR *, int *, sw_t));
d58 1
a58 1
 * PUBLIC: void vs_busy __P((SCR *, const char *, busy_t));
d148 1
a148 1
 * PUBLIC: void vs_home __P((SCR *));
d162 1
a162 1
 * PUBLIC: void vs_update __P((SCR *, const char *, const char *));
d230 1
a230 1
 * PUBLIC: void vs_msg __P((SCR *, mtype_t, char *, size_t));
d525 1
a525 1
 * PUBLIC: int vs_ex_resolve __P((SCR *, int *));
d651 1
a651 1
 * PUBLIC: int vs_resolve __P((SCR *, SCR *, int));
@


1.5
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.4
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_msg.c	10.76 (Berkeley) 9/26/96";
d649 1
a649 4
 * This routine is called from the main vi loop to periodically ensure that
 * the user has seen any messages that have been displayed.
 *
 * PUBLIC: int vs_resolve __P((SCR *, int));
d652 2
a653 2
vs_resolve(sp, forcewait)
	SCR *sp;
d663 7
d672 2
d676 1
a676 1
	(void)gp->scr_cursor(sp, &oldy, &oldx);
d751 1
a751 1
	(void)gp->scr_move(sp, oldy, oldx);
@


1.3
log
@nvi 1.74
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_msg.c	10.75 (Berkeley) 8/17/96";
d651 2
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_msg.c	10.73 (Berkeley) 6/28/96";
a42 1
static int	vs_scr_resolve __P((SCR *, int));
d574 1
a574 1
	/* Clear the required wait flag -- we're going to wait. */
d647 1
a647 1
 *	Cycle through each screen, dealing with message output.
a650 2
 *
 * PUBLIC: int vs_resolve __P((SCR *, int));
a653 21
	SCR *sp;
	int forcewait;
{
	SCR *tsp;

	for (tsp = sp->gp->dq.cqh_first;
	    tsp != (void *)&sp->gp->dq; tsp = tsp->q.cqe_next)
		if (vs_scr_resolve(tsp, forcewait))
			return (1);
	return (0);
}

/*
 * vs_scr_resolve --
 *	Deal with message output.
 *
 * This routine is called from the main vi loop to periodically ensure that
 * the user has seen any messages that have been displayed.
 */
static int
vs_scr_resolve(sp, forcewait)
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_msg.c	10.65 (Berkeley) 5/15/96";
d41 1
d43 1
a43 1
static void	vs_msgsave __P((SCR *, mtype_t, char *, size_t));
d240 1
a240 1
	size_t oldx, oldy, padding;
d279 2
a280 2
	 * If the SC_EX_DONTWAIT bit is set, turn it off -- we're writing,
	 * so previous opinions should be ignored.
d298 1
a298 1
		F_CLR(sp, SC_EX_DONTWAIT);
a313 15
	/*
	 * If the message type is changing, terminate any previous message
	 * and move to a new line.
	 */
	if (mtype != vip->mtype) {
		if (vip->lcontinue != 0) {
			if (vip->mtype == M_NONE)
				vs_output(sp, vip->mtype, "\n", 1);
			else
				vs_output(sp, vip->mtype, ".\n", 2);
			vip->lcontinue = 0;
		}
		vip->mtype = mtype;
	}

d350 1
d352 2
a353 2
		if (len + vip->lcontinue + padding >= sp->cols)
			vs_output(sp, mtype, ".\n", 2);
d355 1
a355 1
			vs_output(sp, mtype, ";", 1);
d358 3
a360 2
	for (s = line; len > 0; s = t) {
		for (; isblank(*s) && --len != 0; ++s);
d363 2
a364 2
		if (len + vip->lcontinue > sp->cols) {
			for (e = s + (sp->cols - vip->lcontinue);
d367 1
a367 1
				 e = t = s + (sp->cols - vip->lcontinue);
d370 9
a378 11
		} else {
			e = s + len;
			/*
			 * XXX:
			 * If t isn't initialized for "s = t", len will be
			 * equal to 0.  Shut the freakin' compiler up.
			 */
			t = s;
		}
		len -= e - s;
		if ((e - s) > 1 && s[(e - s) - 1] == '.')
d381 1
d384 1
d540 1
a540 1
	/* If we ran an ex command, we don't trust the cursor. */
d543 8
d556 9
a564 12
	 * If we didn't switch into ex and only 0 or 1 lines of output, we may
	 * be able to continue w/o making the user wait.  First, if no lines of
	 * output, we can simply return, leaving the line modifications report
	 * to the next call to vs_resolve from the main vi loop.  Else, output
	 * that report and see if that pushes us over the edge.  If it does, we
	 * wait, else we can return, again leaving the line modification report
	 * until later.
	 *
	 * Note, all other code paths require waiting, so those cases leave the
	 * report of modified lines until later.  As a result, groups of ex
	 * commands will have cumulative line modification reports.  That seems
	 * right (well, at least not wrong) to me.
d569 4
a572 11
	} else {
		if (vip->totalcount < 2) {
			if (vip->totalcount == 0) {
				F_CLR(sp, SC_EX_DONTWAIT);
				return (0);
			}
			msgq_rpt(sp);
			if (vip->totalcount < 2) {
				F_CLR(sp, SC_EX_DONTWAIT);
				return (0);
			}
d574 3
a576 1
	}
d583 1
a583 1
	if (!F_ISSET(sp, SC_EX_DONTWAIT) && !INTERRUPTED(sp)) {
d609 3
d616 1
a616 1
	F_CLR(sp, SC_SCR_EXWROTE | SC_EX_DONTWAIT);
d624 2
a625 2
	 * gives us a combination of some lines that are "wrong", and a
	 * need for a full refresh.
d648 1
a648 1
 *	Deal with message output.
d653 1
a653 1
 * PUBLIC: int vs_resolve __P((SCR *));
d656 22
a677 1
vs_resolve(sp)
d679 1
d707 1
a707 1
	msgq_rpt(sp);
d732 9
a741 3

		/* Skip the modeline if it's in use. */
		F_SET(vip, VIP_S_MODELINE);
d754 1
@
