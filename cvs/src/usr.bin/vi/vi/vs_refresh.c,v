head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.8
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.16
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.22
date	2016.01.30.21.31.08;	author martijn;	state Exp;
branches;
next	1.21;
commitid	zLPqRo5te1vGR4dO;

1.21
date	2016.01.06.22.29.38;	author millert;	state Exp;
branches;
next	1.20;
commitid	RiORzAsItDrPYyBm;

1.20
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.19;
commitid	adBvXLg05bJxz6yx;

1.19
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.18;
commitid	06bi6U3x4gFFf2G1;

1.18
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.10.21.21.50;	author martynas;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.49;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.08.18.11.42;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.11.06.58.00;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.11.06.55.56;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.04.16.18.06;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.29.01.58.55;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.07.10.10.09.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.27.22.28.24;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.10.16.01.18.59;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.09.17.17.19.11;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.20.22.56.14;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.16.09;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.37.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@replace tail with basename

OK tb@@
@
text
@/*	$OpenBSD: vs_refresh.c,v 1.21 2016/01/06 22:29:38 millert Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <libgen.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../common/common.h"
#include "vi.h"

#define	UPDATE_CURSOR	0x01			/* Update the cursor. */
#define	UPDATE_SCREEN	0x02			/* Flush to screen. */

static void	vs_modeline(SCR *);
static int	vs_paint(SCR *, u_int);

/*
 * v_repaint --
 *	Repaint selected lines from the screen.
 *
 * PUBLIC: int vs_repaint(SCR *, EVENT *);
 */
int
vs_repaint(SCR *sp, EVENT *evp)
{
	SMAP *smp;

	for (; evp->e_flno <= evp->e_tlno; ++evp->e_flno) {
		smp = HMAP + evp->e_flno - 1;
		SMAP_FLUSH(smp);
		if (vs_line(sp, smp, NULL, NULL))
			return (1);
	}
	return (0);
}

/*
 * vs_refresh --
 *	Refresh all screens.
 *
 * PUBLIC: int vs_refresh(SCR *, int);
 */
int
vs_refresh(SCR *sp, int forcepaint)
{
	GS *gp;
	SCR *tsp;
	int need_refresh;
	u_int priv_paint, pub_paint;

	gp = sp->gp;

	/*
	 * 1: Refresh the screen.
	 *
	 * If SC_SCR_REDRAW is set in the current screen, repaint everything
	 * that we can find, including status lines.
	 */
	if (F_ISSET(sp, SC_SCR_REDRAW))
		TAILQ_FOREACH(tsp, &gp->dq, q)
			if (tsp != sp)
				F_SET(tsp, SC_SCR_REDRAW | SC_STATUS);

	/*
	 * 2: Related or dirtied screens, or screens with messages.
	 *
	 * If related screens share a view into a file, they may have been
	 * modified as well.  Refresh any screens that aren't exiting that
	 * have paint or dirty bits set.  Always update their screens, we
	 * are not likely to get another chance.  Finally, if we refresh any
	 * screens other than the current one, the cursor will be trashed.
	 */
	pub_paint = SC_SCR_REFORMAT | SC_SCR_REDRAW;
	priv_paint = VIP_CUR_INVALID | VIP_N_REFRESH;
	if (O_ISSET(sp, O_NUMBER))
		priv_paint |= VIP_N_RENUMBER;
	TAILQ_FOREACH(tsp, &gp->dq, q)
		if (tsp != sp && !F_ISSET(tsp, SC_EXIT | SC_EXIT_FORCE) &&
		    (F_ISSET(tsp, pub_paint) ||
		    F_ISSET(VIP(tsp), priv_paint))) {
			(void)vs_paint(tsp,
			    (F_ISSET(VIP(tsp), VIP_CUR_INVALID) ?
			    UPDATE_CURSOR : 0) | UPDATE_SCREEN);
			F_SET(VIP(sp), VIP_CUR_INVALID);
		}

	/*
	 * 3: Refresh the current screen.
	 *
	 * Always refresh the current screen, it may be a cursor movement.
	 * Also, always do it last -- that way, SC_SCR_REDRAW can be set
	 * in the current screen only, and the screen won't flash.
	 */
	if (vs_paint(sp, UPDATE_CURSOR | (!forcepaint &&
	    F_ISSET(sp, SC_SCR_VI) && KEYS_WAITING(sp) ? 0 : UPDATE_SCREEN)))
		return (1);

	/*
	 * 4: Paint any missing status lines.
	 *
	 * XXX
	 * This is fairly evil.  Status lines are written using the vi message
	 * mechanism, since we have no idea how long they are.  Since we may be
	 * painting screens other than the current one, we don't want to make
	 * the user wait.  We depend heavily on there not being any other lines
	 * currently waiting to be displayed and the message truncation code in
	 * the msgq_status routine working.
	 *
	 * And, finally, if we updated any status lines, make sure the cursor
	 * gets back to where it belongs.
	 */
	need_refresh = 0;
	TAILQ_FOREACH(tsp, &gp->dq, q)
		if (F_ISSET(tsp, SC_STATUS)) {
			need_refresh = 1;
			vs_resolve(tsp, sp, 0);
		}
	if (need_refresh)
		(void)gp->scr_refresh(sp, 0);

	/*
	 * A side-effect of refreshing the screen is that it's now ready
	 * for everything else, i.e. messages.
	 */
	F_SET(sp, SC_SCR_VI);
	return (0);
}

/*
 * vs_paint --
 *	This is the guts of the vi curses screen code.  The idea is that
 *	the SCR structure passed in contains the new coordinates of the
 *	screen.  What makes this hard is that we don't know how big
 *	characters are, doing input can put the cursor in illegal places,
 *	and we're frantically trying to avoid repainting unless it's
 *	absolutely necessary.  If you change this code, you'd better know
 *	what you're doing.  It's subtle and quick to anger.
 */
static int
vs_paint(SCR *sp, u_int flags)
{
	GS *gp;
	SMAP *smp, tmp;
	VI_PRIVATE *vip;
	recno_t lastline, lcnt;
	size_t cwtotal, cnt, len, notused, off, y;
	int ch = 0, didpaint, isempty, leftright_warp;
	char *p;

#define	 LNO	sp->lno			/* Current file line. */
#define	OLNO	vip->olno		/* Remembered file line. */
#define	 CNO	sp->cno			/* Current file column. */
#define	OCNO	vip->ocno		/* Remembered file column. */
#define	SCNO	vip->sc_col		/* Current screen column. */

	gp = sp->gp;
	vip = VIP(sp);
	didpaint = leftright_warp = 0;

	/*
	 * 5: Reformat the lines.
	 *
	 * If the lines themselves have changed (:set list, for example),
	 * fill in the map from scratch.  Adjust the screen that's being
	 * displayed if the leftright flag is set.
	 */
	if (F_ISSET(sp, SC_SCR_REFORMAT)) {
		/* Invalidate the line size cache. */
		VI_SCR_CFLUSH(vip);

		/* Toss vs_line() cached information. */
		if (F_ISSET(sp, SC_SCR_TOP)) {
			if (vs_sm_fill(sp, LNO, P_TOP))
				return (1);
		}
		else if (F_ISSET(sp, SC_SCR_CENTER)) {
			if (vs_sm_fill(sp, LNO, P_MIDDLE))
				return (1);
		} else {
			if (LNO == HMAP->lno || LNO == TMAP->lno) {
				cnt = vs_screens(sp, LNO, &CNO);
				if (LNO == HMAP->lno && cnt < HMAP->soff)
					HMAP->soff = cnt;
				if (LNO == TMAP->lno && cnt > TMAP->soff)
					TMAP->soff = cnt;
			}

			if (vs_sm_fill(sp, OOBLNO, P_TOP))
				return (1);
		}
		F_SET(sp, SC_SCR_REDRAW);
	}

	/*
	 * 6: Line movement.
	 *
	 * Line changes can cause the top line to change as well.  As
	 * before, if the movement is large, the screen is repainted.
	 *
	 * 6a: Small screens.
	 *
	 * Users can use the window, w300, w1200 and w9600 options to make
	 * the screen artificially small.  The behavior of these options
	 * in the historic vi wasn't all that consistent, and, in fact, it
	 * was never documented how various screen movements affected the
	 * screen size.  Generally, one of three things would happen:
	 *	1: The screen would expand in size, showing the line
	 *	2: The screen would scroll, showing the line
	 *	3: The screen would compress to its smallest size and
	 *		repaint.
	 * In general, scrolling didn't cause compression (200^D was handled
	 * the same as ^D), movement to a specific line would (:N where N
	 * was 1 line below the screen caused a screen compress), and cursor
	 * movement would scroll if it was 11 lines or less, and compress if
	 * it was more than 11 lines.  (And, no, I have no idea where the 11
	 * comes from.)
	 *
	 * What we do is try and figure out if the line is less than half of
	 * a full screen away.  If it is, we expand the screen if there's
	 * room, and then scroll as necessary.  The alternative is to compress
	 * and repaint.
	 *
	 * !!!
	 * This code is a special case from beginning to end.  Unfortunately,
	 * home modems are still slow enough that it's worth having.
	 *
	 * XXX
	 * If the line a really long one, i.e. part of the line is on the
	 * screen but the column offset is not, we'll end up in the adjust
	 * code, when we should probably have compressed the screen.
	 */
	if (IS_SMALL(sp)) {
		if (LNO < HMAP->lno) {
			lcnt = vs_sm_nlines(sp, HMAP, LNO, sp->t_maxrows);
			if (lcnt <= HALFSCREEN(sp))
				for (; lcnt && sp->t_rows != sp->t_maxrows;
				     --lcnt, ++sp->t_rows) {
					++TMAP;
					if (vs_sm_1down(sp))
						return (1);
				}
			else
				goto small_fill;
		} else if (LNO > TMAP->lno) {
			lcnt = vs_sm_nlines(sp, TMAP, LNO, sp->t_maxrows);
			if (lcnt <= HALFSCREEN(sp))
				for (; lcnt && sp->t_rows != sp->t_maxrows;
				     --lcnt, ++sp->t_rows) {
					if (vs_sm_next(sp, TMAP, TMAP + 1))
						return (1);
					++TMAP;
					if (vs_line(sp, TMAP, NULL, NULL))
						return (1);
				}
			else {
small_fill:			(void)gp->scr_move(sp, LASTLINE(sp), 0);
				(void)gp->scr_clrtoeol(sp);
				for (; sp->t_rows > sp->t_minrows;
				    --sp->t_rows, --TMAP) {
					(void)gp->scr_move(sp, TMAP - HMAP, 0);
					(void)gp->scr_clrtoeol(sp);
				}
				if (vs_sm_fill(sp, LNO, P_FILL))
					return (1);
				F_SET(sp, SC_SCR_REDRAW);
				goto adjust;
			}
		}
	}

	/*
	 * 6b: Line down, or current screen.
	 */
	if (LNO >= HMAP->lno) {
		/* Current screen. */
		if (LNO <= TMAP->lno)
			goto adjust;
		if (F_ISSET(sp, SC_SCR_TOP))
			goto top;
		if (F_ISSET(sp, SC_SCR_CENTER))
			goto middle;

		/*
		 * If less than half a screen above the line, scroll down
		 * until the line is on the screen.
		 */
		lcnt = vs_sm_nlines(sp, TMAP, LNO, HALFTEXT(sp));
		if (lcnt < HALFTEXT(sp)) {
			while (lcnt--)
				if (vs_sm_1up(sp))
					return (1);
			goto adjust;
		}
		goto bottom;
	}

	/*
	 * 6c: If not on the current screen, may request center or top.
	 */
	if (F_ISSET(sp, SC_SCR_TOP))
		goto top;
	if (F_ISSET(sp, SC_SCR_CENTER))
		goto middle;

	/*
	 * 6d: Line up.
	 */
	lcnt = vs_sm_nlines(sp, HMAP, LNO, HALFTEXT(sp));
	if (lcnt < HALFTEXT(sp)) {
		/*
		 * If less than half a screen below the line, scroll up until
		 * the line is the first line on the screen.  Special check so
		 * that if the screen has been emptied, we refill it.
		 */
		if (db_exist(sp, HMAP->lno)) {
			while (lcnt--)
				if (vs_sm_1down(sp))
					return (1);
			goto adjust;
		}

		/*
		 * If less than a half screen from the bottom of the file,
		 * put the last line of the file on the bottom of the screen.
		 */
bottom:		if (db_last(sp, &lastline))
			return (1);
		tmp.lno = LNO;
		tmp.coff = HMAP->coff;
		tmp.soff = 1;
		lcnt = vs_sm_nlines(sp, &tmp, lastline, sp->t_rows);
		if (lcnt < HALFTEXT(sp)) {
			if (vs_sm_fill(sp, lastline, P_BOTTOM))
				return (1);
			F_SET(sp, SC_SCR_REDRAW);
			goto adjust;
		}
		/* It's not close, just put the line in the middle. */
		goto middle;
	}

	/*
	 * If less than half a screen from the top of the file, put the first
	 * line of the file at the top of the screen.  Otherwise, put the line
	 * in the middle of the screen.
	 */
	tmp.lno = 1;
	tmp.coff = HMAP->coff;
	tmp.soff = 1;
	lcnt = vs_sm_nlines(sp, &tmp, LNO, HALFTEXT(sp));
	if (lcnt < HALFTEXT(sp)) {
		if (vs_sm_fill(sp, 1, P_TOP))
			return (1);
	} else
middle:		if (vs_sm_fill(sp, LNO, P_MIDDLE))
			return (1);
	if (0) {
top:		if (vs_sm_fill(sp, LNO, P_TOP))
			return (1);
	}
	F_SET(sp, SC_SCR_REDRAW);

	/*
	 * At this point we know part of the line is on the screen.  Since
	 * scrolling is done using logical lines, not physical, all of the
	 * line may not be on the screen.  While that's not necessarily bad,
	 * if the part the cursor is on isn't there, we're going to lose.
	 * This can be tricky; if the line covers the entire screen, lno
	 * may be the same as both ends of the map, that's why we test BOTH
	 * the top and the bottom of the map.  This isn't a problem for
	 * left-right scrolling, the cursor movement code handles the problem.
	 *
	 * There's a performance issue here if editing *really* long lines.
	 * This gets to the right spot by scrolling, and, in a binary, by
	 * scrolling hundreds of lines.  If the adjustment looks like it's
	 * going to be a serious problem, refill the screen and repaint.
	 */
adjust:	if (!O_ISSET(sp, O_LEFTRIGHT) &&
	    (LNO == HMAP->lno || LNO == TMAP->lno)) {
		cnt = vs_screens(sp, LNO, &CNO);
		if (LNO == HMAP->lno && cnt < HMAP->soff) {
			if ((HMAP->soff - cnt) > HALFTEXT(sp)) {
				HMAP->soff = cnt;
				vs_sm_fill(sp, OOBLNO, P_TOP);
				F_SET(sp, SC_SCR_REDRAW);
			} else
				while (cnt < HMAP->soff)
					if (vs_sm_1down(sp))
						return (1);
		}
		if (LNO == TMAP->lno && cnt > TMAP->soff) {
			if ((cnt - TMAP->soff) > HALFTEXT(sp)) {
				TMAP->soff = cnt;
				vs_sm_fill(sp, OOBLNO, P_BOTTOM);
				F_SET(sp, SC_SCR_REDRAW);
			} else
				while (cnt > TMAP->soff)
					if (vs_sm_1up(sp))
						return (1);
		}
	}

	/*
	 * If the screen needs to be repainted, skip cursor optimization.
	 * However, in the code above we skipped leftright scrolling on
	 * the grounds that the cursor code would handle it.  Make sure
	 * the right screen is up.
	 */
	if (F_ISSET(sp, SC_SCR_REDRAW)) {
		if (O_ISSET(sp, O_LEFTRIGHT))
			goto slow;
		goto paint;
	}

	/*
	 * 7: Cursor movements (current screen only).
	 */
	if (!LF_ISSET(UPDATE_CURSOR))
		goto number;

	/*
	 * Decide cursor position.  If the line has changed, the cursor has
	 * moved over a tab, or don't know where the cursor was, reparse the
	 * line.  Otherwise, we've just moved over fixed-width characters,
	 * and can calculate the left/right scrolling and cursor movement
	 * without reparsing the line.  Note that we don't know which (if any)
	 * of the characters between the old and new cursor positions changed.
	 *
	 * XXX
	 * With some work, it should be possible to handle tabs quickly, at
	 * least in obvious situations, like moving right and encountering
	 * a tab, without reparsing the whole line.
	 *
	 * If the line we're working with has changed, reread it..
	 */
	if (F_ISSET(vip, VIP_CUR_INVALID) || LNO != OLNO)
		goto slow;

	/* Otherwise, if nothing's changed, ignore the cursor. */
	if (CNO == OCNO)
		goto fast;

	/*
	 * Get the current line.  If this fails, we either have an empty
	 * file and can just repaint, or there's a real problem.  This
	 * isn't a performance issue because there aren't any ways to get
	 * here repeatedly.
	 */
	if (db_eget(sp, LNO, &p, &len, &isempty)) {
		if (isempty)
			goto slow;
		return (1);
	}

#ifdef DEBUG
	/* Sanity checking. */
	if (CNO >= len && len != 0) {
		msgq(sp, M_ERR, "Error: %s/%d: cno (%u) >= len (%u)",
		     basename(__FILE__), __LINE__, CNO, len);
		return (1);
	}
#endif
	/*
	 * The basic scheme here is to look at the characters in between
	 * the old and new positions and decide how big they are on the
	 * screen, and therefore, how many screen positions to move.
	 */
	if (CNO < OCNO) {
		/*
		 * 7a: Cursor moved left.
		 *
		 * Point to the old character.  The old cursor position can
		 * be past EOL if, for example, we just deleted the rest of
		 * the line.  In this case, since we don't know the width of
		 * the characters we traversed, we have to do it slowly.
		 */
		p += OCNO;
		cnt = (OCNO - CNO) + 1;
		if (OCNO >= len)
			goto slow;

		/*
		 * Quick sanity check -- it's hard to figure out exactly when
		 * we cross a screen boundary as we do in the cursor right
		 * movement.  If cnt is so large that we're going to cross the
		 * boundary no matter what, stop now.
		 */
		if (SCNO + 1 + MAX_CHARACTER_COLUMNS < cnt)
			goto slow;

		/*
		 * Count up the widths of the characters.  If it's a tab
		 * character, go do it the slow way.
		 */
		for (cwtotal = 0; cnt--; cwtotal += KEY_LEN(sp, ch))
			if ((ch = *(u_char *)p--) == '\t')
				goto slow;

		/*
		 * Decrement the screen cursor by the total width of the
		 * characters minus 1.
		 */
		cwtotal -= 1;

		/*
		 * If we're moving left, and there's a wide character in the
		 * current position, go to the end of the character.
		 */
		if (KEY_LEN(sp, ch) > 1)
			cwtotal -= KEY_LEN(sp, ch) - 1;

		/*
		 * If the new column moved us off of the current logical line,
		 * calculate a new one.  If doing leftright scrolling, we've
		 * moved off of the current screen, as well.
		 */
		if (SCNO < cwtotal)
			goto slow;
		SCNO -= cwtotal;
	} else {
		/*
		 * 7b: Cursor moved right.
		 *
		 * Point to the first character to the right.
		 */
		p += OCNO + 1;
		cnt = CNO - OCNO;

		/*
		 * Count up the widths of the characters.  If it's a tab
		 * character, go do it the slow way.  If we cross a
		 * screen boundary, we can quit.
		 */
		for (cwtotal = SCNO; cnt--;) {
			if ((ch = *(u_char *)p++) == '\t')
				goto slow;
			if ((cwtotal += KEY_LEN(sp, ch)) >= SCREEN_COLS(sp))
				break;
		}

		/*
		 * Increment the screen cursor by the total width of the
		 * characters.
		 */
		SCNO = cwtotal;

		/* See screen change comment in section 6a. */
		if (SCNO >= SCREEN_COLS(sp))
			goto slow;
	}

	/*
	 * 7c: Fast cursor update.
	 *
	 * We have the current column, retrieve the current row.
	 */
fast:	(void)gp->scr_cursor(sp, &y, &notused);
	goto done_cursor;

	/*
	 * 7d: Slow cursor update.
	 *
	 * Walk through the map and find the current line.
	 */
slow:	for (smp = HMAP; smp->lno != LNO; ++smp);

	/*
	 * 7e: Leftright scrolling adjustment.
	 *
	 * If doing left-right scrolling and the cursor movement has changed
	 * the displayed screen, scroll the screen left or right, unless we're
	 * updating the info line in which case we just scroll that one line.
	 * We adjust the offset up or down until we have a window that covers
	 * the current column, making sure that we adjust differently for the
	 * first screen as compared to subsequent ones.
	 */
	if (O_ISSET(sp, O_LEFTRIGHT)) {
		/*
		 * Get the screen column for this character, and correct
		 * for the number option offset.
		 */
		cnt = vs_columns(sp, NULL, LNO, &CNO, NULL);
		if (O_ISSET(sp, O_NUMBER))
			cnt -= O_NUMBER_LENGTH;

		/* Adjust the window towards the beginning of the line. */
		off = smp->coff;
		if (off >= cnt) {
			do {
				if (off >= O_VAL(sp, O_SIDESCROLL))
					off -= O_VAL(sp, O_SIDESCROLL);
				else {
					off = 0;
					break;
				}
			} while (off >= cnt);
			goto shifted;
		}

		/* Adjust the window towards the end of the line. */
		if ((off == 0 && off + SCREEN_COLS(sp) < cnt) ||
		    (off != 0 && off + sp->cols < cnt)) {
			do {
				off += O_VAL(sp, O_SIDESCROLL);
			} while (off + sp->cols < cnt);

shifted:		/* Fill in screen map with the new offset. */
			if (F_ISSET(sp, SC_TINPUT_INFO))
				smp->coff = off;
			else {
				for (smp = HMAP; smp <= TMAP; ++smp)
					smp->coff = off;
				leftright_warp = 1;
			}
			goto paint;
		}

		/*
		 * We may have jumped here to adjust a leftright screen because
		 * redraw was set.  If so, we have to paint the entire screen.
		 */
		if (F_ISSET(sp, SC_SCR_REDRAW))
			goto paint;
	}

	/*
	 * Update the screen lines for this particular file line until we
	 * have a new screen cursor position.
	 */
	for (y = -1,
	    vip->sc_smap = NULL; smp <= TMAP && smp->lno == LNO; ++smp) {
		if (vs_line(sp, smp, &y, &SCNO))
			return (1);
		if (y != -1) {
			vip->sc_smap = smp;
			break;
		}
	}
	goto done_cursor;

	/*
	 * 8: Repaint the entire screen.
	 *
	 * Lost big, do what you have to do.  We flush the cache, since
	 * SC_SCR_REDRAW gets set when the screen isn't worth fixing, and
	 * it's simpler to repaint.  So, don't trust anything that we
	 * think we know about it.
	 */
paint:	for (smp = HMAP; smp <= TMAP; ++smp)
		SMAP_FLUSH(smp);
	for (y = -1, vip->sc_smap = NULL, smp = HMAP; smp <= TMAP; ++smp) {
		if (vs_line(sp, smp, &y, &SCNO))
			return (1);
		if (y != -1 && vip->sc_smap == NULL)
			vip->sc_smap = smp;
	}
	/*
	 * If it's a small screen and we're redrawing, clear the unused lines,
	 * ex may have overwritten them.
	 */
	if (F_ISSET(sp, SC_SCR_REDRAW) && IS_SMALL(sp))
		for (cnt = sp->t_rows; cnt <= sp->t_maxrows; ++cnt) {
			(void)gp->scr_move(sp, cnt, 0);
			(void)gp->scr_clrtoeol(sp);
		}

	didpaint = 1;

done_cursor:
	/*
	 * Sanity checking.  When the repainting code messes up, the usual
	 * result is we don't repaint the cursor and so sc_smap will be
	 * NULL.  If we're debugging, die, otherwise restart from scratch.
	 */
#ifdef DEBUG
	if (vip->sc_smap == NULL)
		abort();
#else
	if (vip->sc_smap == NULL) {
		if (F_ISSET(sp, SC_SCR_REFORMAT))
			return (0);
		F_SET(sp, SC_SCR_REFORMAT);
		return (vs_paint(sp, flags));
	}
#endif

	/*
	 * 9: Set the remembered cursor values.
	 */
	OCNO = CNO;
	OLNO = LNO;

	/*
	 * 10: Repaint the line numbers.
	 *
	 * If O_NUMBER is set and the VIP_N_RENUMBER bit is set, and we
	 * didn't repaint the screen, repaint all of the line numbers,
	 * they've changed.
	 */
number:	if (O_ISSET(sp, O_NUMBER) &&
	    F_ISSET(vip, VIP_N_RENUMBER) && !didpaint && vs_number(sp))
		return (1);

	/*
	 * 11: Update the mode line, position the cursor, and flush changes.
	 *
	 * If we warped the screen, we have to refresh everything.
	 */
	if (leftright_warp)
		LF_SET(UPDATE_CURSOR | UPDATE_SCREEN);

	if (LF_ISSET(UPDATE_SCREEN) && !IS_ONELINE(sp) &&
	    !F_ISSET(vip, VIP_S_MODELINE) && !F_ISSET(sp, SC_TINPUT_INFO))
		vs_modeline(sp);

	if (LF_ISSET(UPDATE_CURSOR)) {
		(void)gp->scr_move(sp, y, SCNO);

		/*
		 * XXX
		 * If the screen shifted, we recalculate the "most favorite"
		 * cursor position.  Vi won't know that we've warped the
		 * screen, so it's going to have a wrong idea about where the
		 * cursor should be.  This is vi's problem, and fixing it here
		 * is a gross layering violation.
		 */
		if (leftright_warp)
			(void)vs_column(sp, &sp->rcm);
	}

	if (LF_ISSET(UPDATE_SCREEN))
		(void)gp->scr_refresh(sp, F_ISSET(vip, VIP_N_EX_PAINT));

	/* 12: Clear the flags that are handled by this routine. */
	F_CLR(sp, SC_SCR_CENTER | SC_SCR_REDRAW | SC_SCR_REFORMAT | SC_SCR_TOP);
	F_CLR(vip, VIP_CUR_INVALID |
	    VIP_N_EX_PAINT | VIP_N_REFRESH | VIP_N_RENUMBER | VIP_S_MODELINE);

	return (0);

#undef	 LNO
#undef	OLNO
#undef	 CNO
#undef	OCNO
#undef	SCNO
}

/*
 * vs_modeline --
 *	Update the mode line.
 */
static void
vs_modeline(SCR *sp)
{
	static char * const modes[] = {
		"Append",			/* SM_APPEND */
		"Change",			/* SM_CHANGE */
		"Command",			/* SM_COMMAND */
		"Insert",			/* SM_INSERT */
		"Replace",			/* SM_REPLACE */
	};
	GS *gp;
	size_t cols, curcol, curlen, endpoint, len, midpoint;
	const char *t = NULL;
	int ellipsis;
	char *p, buf[20];

	/*
	 * It's possible that this routine will be called after sp->frp
	 * has been set to NULL by file_end().  We return immediately
	 * to avoid a SEGV.
	 */
	if (sp->frp == NULL)
		return;

	gp = sp->gp;

	/*
	 * We put down the file name, the ruler, the mode and the dirty flag.
	 * If there's not enough room, there's not enough room, we don't play
	 * any special games.  We try to put the ruler in the middle and the
	 * mode and dirty flag at the end.
	 *
	 * !!!
	 * Leave the last character blank, in case it's a really dumb terminal
	 * with hardware scroll.  Second, don't paint the last character in the
	 * screen, SunOS 4.1.1 and Ultrix 4.2 curses won't let you.
	 *
	 * Move to the last line on the screen.
	 */
	(void)gp->scr_move(sp, LASTLINE(sp), 0);

	/* If more than one screen in the display, show the file name. */
	curlen = 0;
	if (IS_SPLIT(sp)) {
		for (p = sp->frp->name; *p != '\0'; ++p);
		for (ellipsis = 0, cols = sp->cols / 2; --p > sp->frp->name;) {
			if (*p == '/') {
				++p;
				break;
			}
			if ((curlen += KEY_LEN(sp, *p)) > cols) {
				ellipsis = 3;
				curlen +=
				    KEY_LEN(sp, '.') * 3 + KEY_LEN(sp, ' ');
				while (curlen > cols) {
					++p;
					curlen -= KEY_LEN(sp, *p);
				}
				break;
			}
		}
		if (ellipsis) {
			while (ellipsis--)
				(void)gp->scr_addstr(sp,
				    KEY_NAME(sp, '.'), KEY_LEN(sp, '.'));
			(void)gp->scr_addstr(sp,
			    KEY_NAME(sp, ' '), KEY_LEN(sp, ' '));
		}
		for (; *p != '\0'; ++p)
			(void)gp->scr_addstr(sp,
			    KEY_NAME(sp, *p), KEY_LEN(sp, *p));
	}

	/* Clear the rest of the line. */
	(void)gp->scr_clrtoeol(sp);

	/*
	 * Display the ruler.  If we're not at the midpoint yet, move there.
	 * Otherwise, add in two extra spaces.
	 *
	 * Adjust the current column for the fact that the editor uses it as
	 * a zero-based number.
	 *
	 * XXX
	 * Assume that numbers, commas, and spaces only take up a single
	 * column on the screen.
	 */
	cols = sp->cols - 1;
	if (O_ISSET(sp, O_RULER)) {
		vs_column(sp, &curcol);
		len = snprintf(buf, sizeof(buf), "%lu,%zu",
		    (ulong)sp->lno, curcol + 1);

		midpoint = (cols - ((len + 1) / 2)) / 2;
		if (curlen < midpoint) {
			(void)gp->scr_move(sp, LASTLINE(sp), midpoint);
			curlen += len;
		} else if (curlen + 2 + len < cols) {
			(void)gp->scr_addstr(sp, "  ", 2);
			curlen += 2 + len;
		}
		(void)gp->scr_addstr(sp, buf, len);
	}

	/*
	 * Display the mode and the modified flag, as close to the end of the
	 * line as possible, but guaranteeing at least two spaces between the
	 * ruler and the modified flag.
	 */
#define	MODESIZE	9
	endpoint = cols;
	if (O_ISSET(sp, O_SHOWMODE)) {
		if (F_ISSET(sp->ep, F_MODIFIED))
			--endpoint;
		t = modes[sp->showmode];
		endpoint -= (len = strlen(t));
	}

	if (endpoint > curlen + 2) {
		(void)gp->scr_move(sp, LASTLINE(sp), endpoint);
		if (O_ISSET(sp, O_SHOWMODE)) {
			if (F_ISSET(sp->ep, F_MODIFIED))
				(void)gp->scr_addstr(sp,
				    KEY_NAME(sp, '*'), KEY_LEN(sp, '*'));
			(void)gp->scr_addstr(sp, t, len);
		}
	}
}
@


1.21
log
@Remove the msg_cat() function and adjust its former callers.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.20 2016/01/06 22:28:52 millert Exp $	*/
d20 1
d477 1
a477 1
		     tail(__FILE__), __LINE__, CNO, len);
@


1.20
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.19 2014/11/12 04:28:41 bentley Exp $	*/
d883 2
a884 2
		t = msg_cat(sp, modes[sp->showmode], &len);
		endpoint -= len;
@


1.19
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.18 2013/11/28 22:12:40 krw Exp $	*/
d773 5
a777 5
		"215|Append",			/* SM_APPEND */
		"216|Change",			/* SM_CHANGE */
		"217|Command",			/* SM_COMMAND */
		"218|Insert",			/* SM_INSERT */
		"219|Replace",			/* SM_REPLACE */
@


1.18
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.17 2011/04/10 21:21:50 martynas Exp $	*/
d41 1
a41 3
vs_repaint(sp, evp)
	SCR *sp;
	EVENT *evp;
d61 1
a61 3
vs_refresh(sp, forcepaint)
	SCR *sp;
	int forcepaint;
d157 1
a157 3
vs_paint(sp, flags)
	SCR *sp;
	u_int flags;
d770 1
a770 2
vs_modeline(sp)
	SCR *sp;
@


1.17
log
@Fix display glitch leading to crash.  If we're reformatting, check
the screens necessary to display the line and modify head or tail
of the smap accordingly;  since it might have changed due to e.g.
smaller tabstop value.

Reported by Patrick Keshishian who submitted a wrong diff and didn't
care to even test this one.
OK millert@@, krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.16 2009/10/27 23:59:49 deraadt Exp $	*/
d81 1
a81 1
		CIRCLEQ_FOREACH(tsp, &gp->dq, q)
d98 1
a98 1
	CIRCLEQ_FOREACH(tsp, &gp->dq, q)
d134 1
a134 1
	CIRCLEQ_FOREACH(tsp, &gp->dq, q)
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.15 2008/03/08 18:11:42 otto Exp $	*/
d202 9
a210 1
		} else
d213 1
@


1.15
log
@avoid inifite recursion on certain error conditions; from netbsd;
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.14 2006/03/11 06:58:00 ray Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)vs_refresh.c	10.44 (Berkeley) 10/13/96";
#endif /* not lint */
@


1.14
log
@Silence 39 warnings.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.13 2006/03/11 06:55:56 ray Exp $	*/
d698 2
@


1.13
log
@Silence uninitialized variable warning.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.12 2006/03/04 16:18:06 miod Exp $	*/
d781 1
a781 1
	const char *t;
d859 2
a860 2
		len =
		    snprintf(buf, sizeof(buf), "%lu,%lu", sp->lno, curcol + 1);
@


1.12
log
@the the
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.11 2006/01/08 21:05:40 miod Exp $	*/
d174 1
a174 1
	int ch, didpaint, isempty, leftright_warp;
@


1.11
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.10 2005/10/17 19:12:16 otto Exp $	*/
d511 1
a511 1
		 * character, go do it the the slow way.
d549 1
a549 1
		 * character, go do it the the slow way.  If we cross a
@


1.10
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.9 2002/02/16 21:27:58 millert Exp $	*/
d250 1
a250 1
	if (IS_SMALL(sp))
d287 1
d399 1
a399 1
		if (LNO == HMAP->lno && cnt < HMAP->soff)
d408 2
a409 1
		if (LNO == TMAP->lno && cnt > TMAP->soff)
d418 1
d619 2
a620 2
		if (off == 0 && off + SCREEN_COLS(sp) < cnt ||
		    off != 0 && off + sp->cols < cnt) {
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_refresh.c,v 1.8 2001/01/29 01:58:55 niklas Exp $	*/
d85 1
a85 2
		for (tsp = gp->dq.cqh_first;
		    tsp != (void *)&gp->dq; tsp = tsp->q.cqe_next)
d102 1
a102 2
	for (tsp = gp->dq.cqh_first;
	    tsp != (void *)&gp->dq; tsp = tsp->q.cqe_next)
d137 2
a138 2
	for (need_refresh = 0, tsp = gp->dq.cqh_first;
	    tsp != (void *)&gp->dq; tsp = tsp->q.cqe_next)
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 2
a36 2
static void	vs_modeline __P((SCR *));
static int	vs_paint __P((SCR *, u_int));
d42 1
a42 1
 * PUBLIC: int vs_repaint __P((SCR *, EVENT *));
d64 1
a64 1
 * PUBLIC: int vs_refresh __P((SCR *, int));
@


1.7
log
@Fix a SEGV after you HUP vi; dean@@netbsd.org
@
text
@d1 2
@


1.6
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d782 8
@


1.5
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_refresh.c	10.43 (Berkeley) 9/26/96";
d69 1
d71 1
d74 2
d83 2
a84 2
		for (tsp = sp->gp->dq.cqh_first;
		    tsp != (void *)&sp->gp->dq; tsp = tsp->q.cqe_next)
d101 2
a102 2
	for (tsp = sp->gp->dq.cqh_first;
	    tsp != (void *)&sp->gp->dq; tsp = tsp->q.cqe_next)
d133 3
d137 8
a144 4
	for (tsp = sp->gp->dq.cqh_first;
	    tsp != (void *)&sp->gp->dq; tsp = tsp->q.cqe_next)
		if (F_ISSET(tsp, SC_STATUS))
			vs_resolve(tsp, 0);
@


1.4
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_refresh.c	10.41 (Berkeley) 9/15/96";
d85 1
a85 17
	 * 2: Paint any missing status lines.
	 *
	 * XXX
	 * This is fairly evil.  Status lines are written using the vi message
	 * mechanism, since we have no idea how long they are.  Since we may be
	 * painting screens other than the current one, we don't want to make
	 * the user wait.  We depend heavily on there not being any other lines
	 * currently waiting to be displayed and the message truncation code in
	 * the msgq_status routine working.
	 */
	for (tsp = sp->gp->dq.cqh_first;
	    tsp != (void *)&sp->gp->dq; tsp = tsp->q.cqe_next)
		if (F_ISSET(tsp, SC_STATUS))
			vs_resolve(tsp, 0);

	/*
	 * 3: Related or dirtied screens, or screens with messages.
d109 1
a109 1
	 * 4: Refresh the current screen.
d120 16
d163 1
a163 1
	int ch, didpaint, isempty, leftright_warp, shifted;
d582 4
a585 1
		/* Get the screen column for this character. */
d587 2
a588 2

		shifted = 0;
d593 1
a593 1
			while (off >= cnt)
d600 2
a601 1
			shifted = 1;
d607 1
a607 1
			while (off + sp->cols < cnt)
d609 1
a609 2
			shifted = 1;
		}
d611 1
a611 2
		/* Fill in screen map with the new offset. */
		if (shifted) {
@


1.3
log
@nvi 1.74
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_refresh.c	10.39 (Berkeley) 8/17/96";
d90 4
a93 4
	 * painting screens other than the current one, we don't want want to
	 * make the user wait.  We depend heavily on there not being any other
	 * lines currently waiting to be displayed and the message truncation
	 * code in the msgq_status routine working.
a671 1
#ifdef DEBUG
d674 2
a675 1
	 * result is we don't repaint the cursor.  Die now.
d677 1
d680 5
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_refresh.c	10.37 (Berkeley) 6/12/96";
d76 1
a76 1
	 * that we can find.
d82 1
a82 1
				F_SET(tsp, SC_SCR_REDRAW);
d85 17
a101 1
	 * 2: Related or dirtied screens, or screens with messages.
d125 1
a125 1
	 * 3: Refresh the current screen.
d177 1
a177 1
	 * 4: Reformat the lines.
d202 1
a202 1
	 * 5: Line movement.
d207 1
a207 1
	 * 5a: Small screens.
d278 1
a278 1
	 * 5b: Line down, or current screen.
d304 1
a304 1
	 * 5c: If not on the current screen, may request center or top.
d312 1
a312 1
	 * 5d: Line up.
d420 1
a420 1
	 * 6: Cursor movements (current screen only).
d474 1
a474 1
		 * 6a: Cursor moved left.
d526 1
a526 1
		 * 6b: Cursor moved right.
d557 1
a557 1
	 * 6c: Fast cursor update.
d565 1
a565 1
	 * 6d: Slow cursor update.
d572 1
a572 1
	 * 6e: Leftright scrolling adjustment.
d644 1
a644 1
	 * 7: Repaint the entire screen.
d682 1
a682 1
	 * 8: Set the remembered cursor values.
d688 1
a688 1
	 * 9: Repaint the line numbers.
d699 1
a699 1
	 * 10: Update the mode line, position the cursor, and flush changes.
d728 1
a728 1
	/* 11: Clear the flags that are handled by this routine. */
d760 1
d775 2
d778 1
a778 1
	cols = sp->cols - 1;
d780 1
d782 17
a798 5
	for (p = sp->frp->name; *p != '\0'; ++p);
	while (--p > sp->frp->name) {
		if (*p == '/') {
			++p;
			break;
d800 6
a805 4
		if ((curlen += KEY_LEN(sp, *p)) > cols) {
			curlen -= KEY_LEN(sp, *p);
			++p;
			break;
a806 8
	}

	/*
	 * Move to the last line on the screen.  If more than one screen in
	 * the display, show the file name.  Clear the rest of the line.
	 */
	(void)gp->scr_move(sp, LASTLINE(sp), 0);
	if (IS_SPLIT(sp))
d810 3
d826 1
d829 2
a830 1
		len = snprintf(buf, sizeof(buf), "%lu,%lu", sp->lno, curcol + 1);
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_refresh.c	10.35 (Berkeley) 5/7/96";
d147 1
a147 1
	int ch, didpaint, isempty, leftright_warp;
d569 3
a571 1
		/* Adjust the window toward the beginning of the line. */
d573 10
a582 7
		while (off >= cnt)
			if (off >= O_VAL(sp, O_SIDESCROLL))
				off -= O_VAL(sp, O_SIDESCROLL);
			else {
				off = 0;
				break;
			}
d584 1
a584 1
		/* Adjust the window toward the end of the line. */
d586 5
a590 3
		    off != 0 && off + sp->cols < cnt)
		while (off + sp->cols < cnt)
			off += O_VAL(sp, O_SIDESCROLL);
d593 2
a594 4
		if (F_ISSET(sp, SC_TINPUT_INFO))
			smp->coff = off;
		else {
			for (smp = HMAP; smp <= TMAP; ++smp)
d596 6
a601 1
			leftright_warp = 1;
d603 7
a609 1
		goto paint;
@
