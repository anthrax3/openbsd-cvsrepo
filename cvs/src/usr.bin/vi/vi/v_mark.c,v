head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.10
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.6
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.03.29.01.04.23;	author bcallah;	state Exp;
branches;
next	1.9;
commitid	KcEgXMM3P7dpQPm7;

1.9
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.8;
commitid	06bi6U3x4gFFf2G1;

1.8
date	2009.10.27.23.59.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.51;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.16.01.18.47;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove SA_INTERRUPT, HISTORIC_PRACTICE, and HISTORICAL_PRACTICE using
unifdef. It seems clear that no one was using these (SA_INTERRUPT didn't
even build the other way). Tweak comments as appropriate.

ok brynet@@
@
text
@/*	$OpenBSD: v_mark.c,v 1.9 2014/11/12 04:28:41 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>

#include "../common/common.h"
#include "vi.h"

/*
 * v_mark -- m[a-z]
 *	Set a mark.
 *
 * PUBLIC: int v_mark(SCR *, VICMD *);
 */
int
v_mark(SCR *sp, VICMD *vp)
{
	return (mark_set(sp, vp->character, &vp->m_start, 1));
}

enum which {BQMARK, FQMARK};
static int mark(SCR *, VICMD *, enum which);


/*
 * v_bmark -- `['`a-z]
 *	Move to a mark.
 *
 * Moves to a mark, setting both row and column.
 *
 * !!!
 * Although not commonly known, the "'`" and "'`" forms are historically
 * valid.  The behavior is determined by the first character, so "`'" is
 * the same as "``".  Remember this fact -- you'll be amazed at how many
 * people don't know it and will be delighted that you are able to tell
 * them.
 *
 * PUBLIC: int v_bmark(SCR *, VICMD *);
 */
int
v_bmark(SCR *sp, VICMD *vp)
{
	return (mark(sp, vp, BQMARK));
}

/*
 * v_fmark -- '['`a-z]
 *	Move to a mark.
 *
 * Move to the first nonblank character of the line containing the mark.
 *
 * PUBLIC: int v_fmark(SCR *, VICMD *);
 */
int
v_fmark(SCR *sp, VICMD *vp)
{
	return (mark(sp, vp, FQMARK));
}

/*
 * mark --
 *	Mark commands.
 */
static int
mark(SCR *sp, VICMD *vp, enum which cmd)
{
	MARK m;
	size_t len;

	if (mark_get(sp, vp->character, &vp->m_stop, M_BERR))
		return (1);

	/*
	 * !!!
	 * Historically, BQMARKS for character positions that no longer
	 * existed acted as FQMARKS.
	 *
	 * FQMARKS move to the first non-blank.
	 */
	switch (cmd) {
	case BQMARK:
		if (db_get(sp, vp->m_stop.lno, DBG_FATAL, NULL, &len))
			return (1);
		if (vp->m_stop.cno < len ||
		    (vp->m_stop.cno == len && len == 0))
			break;

		if (ISMOTION(vp))
			F_SET(vp, VM_LMODE);
		cmd = FQMARK;
		/* FALLTHROUGH */
	case FQMARK:
		vp->m_stop.cno = 0;
		if (nonblank(sp, vp->m_stop.lno, &vp->m_stop.cno))
			return (1);
		break;
	default:
		abort();
	}

	/* Non-motion commands move to the end of the range. */
	if (!ISMOTION(vp)) {
		vp->m_final = vp->m_stop;
		return (0);
	}

	/*
	 * !!!
	 * If a motion component to a BQMARK, the cursor has to move.
	 */
	if (cmd == BQMARK &&
	    vp->m_stop.lno == vp->m_start.lno &&
	    vp->m_stop.cno == vp->m_start.cno) {
		v_nomove(sp);
		return (1);
	}

	/*
	 * If the motion is in the reverse direction, switch the start and
	 * stop MARK's so that it's in a forward direction.  (There's no
	 * reason for this other than to make the tests below easier.  The
	 * code in vi.c:vi() would have done the switch.)  Both forward
	 * and backward motions can happen for any kind of search command.
	 */
	if (vp->m_start.lno > vp->m_stop.lno ||
	    (vp->m_start.lno == vp->m_stop.lno &&
	    vp->m_start.cno > vp->m_stop.cno)) {
		m = vp->m_start;
		vp->m_start = vp->m_stop;
		vp->m_stop = m;
	}

	/*
	 * Yank cursor motion, when associated with marks as motion commands,
	 * historically behaved as follows:
	 *
	 * ` motion			' motion
	 *		Line change?		Line change?
	 *		Y	N		Y	N
	 *	      --------------	      ---------------
	 * FORWARD:  |	NM	NM	      | NM	NM
	 *	     |			      |
	 * BACKWARD: |	M	M	      | M	NM(1)
	 *
	 * where NM means the cursor didn't move, and M means the cursor
	 * moved to the mark.
	 *
	 * As the cursor was usually moved for yank commands associated
	 * with backward motions, this implementation regularizes it by
	 * changing the NM at position (1) to be an M.  This makes mark
	 * motions match search motions, which is probably A Good Thing.
	 *
	 * Delete cursor motion was always to the start of the text region,
	 * regardless.  Ignore other motion commands.
	 */
	vp->m_final = vp->m_start;

	/*
	 * Forward marks are always line oriented, and it's set in the
	 * vcmd.c table.
	 */
	if (cmd == FQMARK)
		return (0);

	/*
	 * BQMARK'S moving backward and starting at column 0, and ones moving
	 * forward and ending at column 0 are corrected to the last column of
	 * the previous line.  Otherwise, adjust the starting/ending point to
	 * the character before the current one (this is safe because we know
	 * the search had to move to succeed).
	 *
	 * Mark motions become line mode opertions if they start at the first
	 * nonblank and end at column 0 of another line.
	 */
	if (vp->m_start.lno < vp->m_stop.lno && vp->m_stop.cno == 0) {
		if (db_get(sp, --vp->m_stop.lno, DBG_FATAL, NULL, &len))
			return (1);
		vp->m_stop.cno = len ? len - 1 : 0;
		len = 0;
		if (nonblank(sp, vp->m_start.lno, &len))
			return (1);
		if (vp->m_start.cno <= len)
			F_SET(vp, VM_LMODE);
	} else
		--vp->m_stop.cno;

	return (0);
}
@


1.9
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_mark.c,v 1.8 2009/10/27 23:59:48 deraadt Exp $	*/
a172 14
#ifdef HISTORICAL_PRACTICE
	if (ISCMD(vp->rkp, 'y')) {
		if ((cmd == BQMARK ||
		    cmd == FQMARK && vp->m_start.lno != vp->m_stop.lno) &&
		    (vp->m_start.lno > vp->m_stop.lno ||
		    vp->m_start.lno == vp->m_stop.lno &&
		    vp->m_start.cno > vp->m_stop.cno))
			vp->m_final = vp->m_stop;
	} else if (ISCMD(vp->rkp, 'd'))
		if (vp->m_start.lno > vp->m_stop.lno ||
		    vp->m_start.lno == vp->m_stop.lno &&
		    vp->m_start.cno > vp->m_stop.cno)
			vp->m_final = vp->m_stop;
#else
a173 1
#endif
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: v_mark.c,v 1.7 2006/04/22 03:09:15 ray Exp $	*/
d33 1
a33 3
v_mark(sp, vp)
	SCR *sp;
	VICMD *vp;
d58 1
a58 3
v_bmark(sp, vp)
	SCR *sp;
	VICMD *vp;
d72 1
a72 3
v_fmark(sp, vp)
	SCR *sp;
	VICMD *vp;
d82 1
a82 4
mark(sp, vp, cmd)
	SCR *sp;
	VICMD *vp;
	enum which cmd;
@


1.7
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_mark.c,v 1.6 2006/01/08 21:05:40 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)v_mark.c	10.8 (Berkeley) 9/20/96";
#endif /* not lint */
@


1.6
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_mark.c,v 1.5 2002/02/16 21:27:58 millert Exp $	*/
a96 1
	dir_t dir;
d161 1
a161 3
		dir = BACKWARD;
	} else
		dir = FORWARD;
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_mark.c,v 1.4 2001/01/29 01:58:51 niklas Exp $	*/
d116 1
a116 1
		    vp->m_stop.cno == len && len == 0)
d157 2
a158 2
	    vp->m_start.lno == vp->m_stop.lno &&
	    vp->m_start.cno > vp->m_stop.cno) {
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 * PUBLIC: int v_mark __P((SCR *, VICMD *));
d45 1
a45 1
static int mark __P((SCR *, VICMD *, enum which));
d61 1
a61 1
 * PUBLIC: int v_bmark __P((SCR *, VICMD *));
d77 1
a77 1
 * PUBLIC: int v_fmark __P((SCR *, VICMD *));
@


1.3
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d1 2
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)v_mark.c	10.7 (Berkeley) 3/6/96";
d218 2
a219 2
	 * Mark motions become line mode opertions if they start at column 0
	 * and end at column 0 of another line.
d224 5
a228 1
		if (vp->m_start.cno == 0)
a229 1
		vp->m_stop.cno = len ? len - 1 : 0;
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)v_mark.c	8.10 (Berkeley) 8/17/94";
d22 1
a22 1
#include <signal.h>
a23 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d25 1
a26 1
#include "vcmd.h"
d31 2
d35 1
a35 1
v_mark(sp, ep, vp)
d37 1
a37 2
	EXF *ep;
	VICMDARG *vp;
d39 1
a39 1
	return (mark_set(sp, ep, vp->character, &vp->m_start, 1));
d42 2
a43 2
enum which {BMARK, FMARK};
static int mark __P((SCR *, EXF *, VICMDARG *, enum which));
d58 2
d62 1
a62 1
v_bmark(sp, ep, vp)
d64 1
a64 2
	EXF *ep;
	VICMDARG *vp;
d66 1
a66 1
	return (mark(sp, ep, vp, BMARK));
d74 2
d78 1
a78 1
v_fmark(sp, ep, vp)
d80 1
a80 2
	EXF *ep;
	VICMDARG *vp;
d82 1
a82 1
	return (mark(sp, ep, vp, FMARK));
d85 4
d90 1
a90 1
mark(sp, ep, vp, cmd)
d92 1
a92 2
	EXF *ep;
	VICMDARG *vp;
d95 1
a97 1
	enum direction dir;
d99 1
a99 1
	if (mark_get(sp, ep, vp->character, &vp->m_stop))
d102 20
a121 2
	/* Forward marks move to the first non-blank. */
	if (cmd == FMARK) {
d123 1
a123 1
		if (nonblank(sp, ep, vp->m_stop.lno, &vp->m_stop.cno))
d125 3
d138 1
a138 1
	 * If a motion component, the cursor has to move.
d140 2
a141 1
	if (vp->m_stop.lno == vp->m_start.lno &&
d152 1
a152 1
	 * and backward motions can happen for either kind of mark command.
a156 1
		dir = BACKWARD;
d160 1
d165 34
a198 14
	 * BACKWARD:
	 *	VC_D commands move to the end of the range.  VC_Y stays at
	 *	the start unless the end of the range is on a different line,
	 *	when it moves to the end of the range.  Ignore VC_C and
	 *	VC_DEF.
	 *
	 * FORWARD:
	 *	VC_D and VC_Y commands don't move.  Ignore VC_C and VC_DEF.
	 */
	if (dir == BACKWARD)
		if (F_ISSET(vp, VC_D) ||
		    F_ISSET(vp, VC_Y) && vp->m_start.lno != vp->m_stop.lno)
			vp->m_final = vp->m_start;
		else
d200 3
a202 5
	else
		vp->m_final = vp->m_start;

	if (cmd == FMARK)
		return (0);
d206 1
a206 2
	 * vcmd.c table.  Backward marks that start and stop at column
	 * 0 of the line are also line mode commands. 
d208 2
a209 2
	if (vp->m_start.cno == 0 && vp->m_stop.cno == 0)
		F_SET(vp, VM_LMODE);
d212 8
a219 5
	 * BMARK'S that move backward and start at column 0, or move forward
	 * and end at column 0 are corrected to the last column of the previous
	 * line.  Else, adjust the starting/ending point to the character
	 * before the current one (this is safe because we know the command had
	 * to move to succeed).
d222 1
a222 2
		if (file_gline(sp, ep, --vp->m_stop.lno, &len) == NULL) {
			GETLINE_ERR(sp, vp->m_stop.lno);
d224 2
a225 1
		}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
