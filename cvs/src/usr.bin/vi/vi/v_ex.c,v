head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.6
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.8
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.12;
commitid	adBvXLg05bJxz6yx;

1.12
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.11;
commitid	06bi6U3x4gFFf2G1;

1.11
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.14.17.44.53;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.20.01.00.36;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.17.19.12.41;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.50;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.16.04;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@/*	$OpenBSD: v_ex.c,v 1.12 2014/11/12 04:28:41 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"
#include "vi.h"

static int v_ecl(SCR *);
static int v_ecl_init(SCR *);
static int v_ecl_log(SCR *, TEXT *);
static int v_ex_done(SCR *, VICMD *);
static int v_exec_ex(SCR *, VICMD *, EXCMD *);

/*
 * v_again -- &
 *	Repeat the previous substitution.
 *
 * PUBLIC: int v_again(SCR *, VICMD *);
 */
int
v_again(SCR *sp, VICMD *vp)
{
	ARGS *ap[2], a;
	EXCMD cmd;

	ex_cinit(&cmd, C_SUBAGAIN, 2, vp->m_start.lno, vp->m_start.lno, 1, ap);
	ex_cadd(&cmd, &a, "", 1);

	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_exmode -- Q
 *	Switch the editor into EX mode.
 *
 * PUBLIC: int v_exmode(SCR *, VICMD *);
 */
int
v_exmode(SCR *sp, VICMD *vp)
{
	GS *gp;

	gp = sp->gp;

	/* Try and switch screens -- the screen may not permit it. */
	if (gp->scr_screen(sp, SC_EX)) {
		msgq(sp, M_ERR,
		    "The Q command requires the ex terminal interface");
		return (1);
	}
	(void)gp->scr_attr(sp, SA_ALTERNATE, 0);

	/* Save the current cursor position. */
	sp->frp->lno = sp->lno;
	sp->frp->cno = sp->cno;
	F_SET(sp->frp, FR_CURSORSET);

	/* Switch to ex mode. */
	F_CLR(sp, SC_VI | SC_SCR_VI);
	F_SET(sp, SC_EX);

	/* Move out of the vi screen. */
	(void)ex_puts(sp, "\n");

	return (0);
}

/*
 * v_join -- [count]J
 *	Join lines together.
 *
 * PUBLIC: int v_join(SCR *, VICMD *);
 */
int
v_join(SCR *sp, VICMD *vp)
{
	EXCMD cmd;
	int lno;

	/*
	 * YASC.
	 * The general rule is that '#J' joins # lines, counting the current
	 * line.  However, 'J' and '1J' are the same as '2J', i.e. join the
	 * current and next lines.  This doesn't map well into the ex command
	 * (which takes two line numbers), so we handle it here.  Note that
	 * we never test for EOF -- historically going past the end of file
	 * worked just fine.
	 */
	lno = vp->m_start.lno + 1;
	if (F_ISSET(vp, VC_C1SET) && vp->count > 2)
		lno = vp->m_start.lno + (vp->count - 1);

	ex_cinit(&cmd, C_JOIN, 2, vp->m_start.lno, lno, 0, NULL);
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_shiftl -- [count]<motion
 *	Shift lines left.
 *
 * PUBLIC: int v_shiftl(SCR *, VICMD *);
 */
int
v_shiftl(SCR *sp, VICMD *vp)
{
	ARGS *ap[2], a;
	EXCMD cmd;

	ex_cinit(&cmd, C_SHIFTL, 2, vp->m_start.lno, vp->m_stop.lno, 0, ap);
	ex_cadd(&cmd, &a, "<", 1);
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_shiftr -- [count]>motion
 *	Shift lines right.
 *
 * PUBLIC: int v_shiftr(SCR *, VICMD *);
 */
int
v_shiftr(SCR *sp, VICMD *vp)
{
	ARGS *ap[2], a;
	EXCMD cmd;

	ex_cinit(&cmd, C_SHIFTR, 2, vp->m_start.lno, vp->m_stop.lno, 0, ap);
	ex_cadd(&cmd, &a, ">", 1);
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_suspend -- ^Z
 *	Suspend vi.
 *
 * PUBLIC: int v_suspend(SCR *, VICMD *);
 */
int
v_suspend(SCR *sp, VICMD *vp)
{
	ARGS *ap[2], a;
	EXCMD cmd;

	ex_cinit(&cmd, C_STOP, 0, OOBLNO, OOBLNO, 0, ap);
	ex_cadd(&cmd, &a, "suspend", sizeof("suspend") - 1);
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_switch -- ^^
 *	Switch to the previous file.
 *
 * PUBLIC: int v_switch(SCR *, VICMD *);
 */
int
v_switch(SCR *sp, VICMD *vp)
{
	ARGS *ap[2], a;
	EXCMD cmd;
	char *name;

	/*
	 * Try the alternate file name, then the previous file
	 * name.  Use the real name, not the user's current name.
	 */
	if (sp->alt_name == NULL) {
		msgq(sp, M_ERR, "No previous file to edit");
		return (1);
	}
	if ((name = strdup(sp->alt_name)) == NULL) {
		msgq(sp, M_SYSERR, NULL);
		return (1);
	}

	/* If autowrite is set, write out the file. */
	if (file_m1(sp, 0, FS_ALL)) {
		free(name);
		return (1);
	}

	ex_cinit(&cmd, C_EDIT, 0, OOBLNO, OOBLNO, 0, ap);
	ex_cadd(&cmd, &a, name, strlen(name));
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_tagpush -- ^[
 *	Do a tag search on the cursor keyword.
 *
 * PUBLIC: int v_tagpush(SCR *, VICMD *);
 */
int
v_tagpush(SCR *sp, VICMD *vp)
{
	ARGS *ap[2], a;
	EXCMD cmd;

	ex_cinit(&cmd, C_TAG, 0, OOBLNO, 0, 0, ap);
	ex_cadd(&cmd, &a, VIP(sp)->keyw, strlen(VIP(sp)->keyw));
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_tagpop -- ^T
 *	Pop the tags stack.
 *
 * PUBLIC: int v_tagpop(SCR *, VICMD *);
 */
int
v_tagpop(SCR *sp, VICMD *vp)
{
	EXCMD cmd;

	ex_cinit(&cmd, C_TAGPOP, 0, OOBLNO, 0, 0, NULL);
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_filter -- [count]!motion command(s)
 *	Run range through shell commands, replacing text.
 *
 * PUBLIC: int v_filter(SCR *, VICMD *);
 */
int
v_filter(SCR *sp, VICMD *vp)
{
	EXCMD cmd;
	TEXT *tp;

	/*
	 * !!!
	 * Historical vi permitted "!!" in an empty file, and it's handled
	 * as a special case in the ex_bang routine.  Don't modify this setup
	 * without understanding that one.  In particular, note that we're
	 * manipulating the ex argument structures behind ex's back.
	 *
	 * !!!
	 * Historical vi did not permit the '!' command to be associated with
	 * a non-line oriented motion command, in general, although it did
	 * with search commands.  So, !f; and !w would fail, but !/;<CR>
	 * would succeed, even if they all moved to the same location in the
	 * current line.  I don't see any reason to disallow '!' using any of
	 * the possible motion commands.
	 *
	 * !!!
	 * Historical vi ran the last bang command if N or n was used as the
	 * search motion.
	 */
	if (F_ISSET(vp, VC_ISDOT) ||
	    ISCMD(vp->rkp, 'N') || ISCMD(vp->rkp, 'n')) {
		ex_cinit(&cmd, C_BANG,
		    2, vp->m_start.lno, vp->m_stop.lno, 0, NULL);
		EXP(sp)->argsoff = 0;			/* XXX */

		if (argv_exp1(sp, &cmd, "!", 1, 1))
			return (1);
		cmd.argc = EXP(sp)->argsoff;		/* XXX */
		cmd.argv = EXP(sp)->args;		/* XXX */
		return (v_exec_ex(sp, vp, &cmd));
	}

	/* Get the command from the user. */
	if (v_tcmd(sp, vp,
	    '!', TXT_BS | TXT_CR | TXT_ESCAPE | TXT_FILEC | TXT_PROMPT))
		return (1);

	/*
	 * Check to see if the user changed their mind.
	 *
	 * !!!
	 * Entering <escape> on an empty line was historically an error,
	 * this implementation doesn't bother.
	 */
	tp = TAILQ_FIRST(&sp->tiq);
	if (tp->term != TERM_OK) {
		vp->m_final.lno = sp->lno;
		vp->m_final.cno = sp->cno;
		return (0);
	}

	/* Home the cursor. */
	vs_home(sp);

	ex_cinit(&cmd, C_BANG, 2, vp->m_start.lno, vp->m_stop.lno, 0, NULL);
	EXP(sp)->argsoff = 0;			/* XXX */

	if (argv_exp1(sp, &cmd, tp->lb + 1, tp->len - 1, 1))
		return (1);
	cmd.argc = EXP(sp)->argsoff;		/* XXX */
	cmd.argv = EXP(sp)->args;		/* XXX */
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_event_exec --
 *	Execute some command(s) based on an event.
 *
 * PUBLIC: int v_event_exec(SCR *, VICMD *);
 */
int
v_event_exec(SCR *sp, VICMD *vp)
{
	EXCMD cmd;

	switch (vp->ev.e_event) {
	case E_QUIT:
		ex_cinit(&cmd, C_QUIT, 0, OOBLNO, OOBLNO, 0, NULL);
		break;
	case E_WRITE:
		ex_cinit(&cmd, C_WRITE, 0, OOBLNO, OOBLNO, 0, NULL);
		break;
	default:
		abort();
	}
	return (v_exec_ex(sp, vp, &cmd));
}

/*
 * v_exec_ex --
 *	Execute an ex command.
 */
static int
v_exec_ex(SCR *sp, VICMD *vp, EXCMD *exp)
{
	int rval;

	rval = exp->cmd->fn(sp, exp);
	return (v_ex_done(sp, vp) || rval);
}

/*
 * v_ex -- :
 *	Execute a colon command line.
 *
 * PUBLIC: int v_ex(SCR *, VICMD *);
 */
int
v_ex(SCR *sp, VICMD *vp)
{
	GS *gp;
	TEXT *tp;
	int do_cedit, do_resolution, ifcontinue;

	gp = sp->gp;

	/*
	 * !!!
	 * If we put out more than a single line of messages, or ex trashes
	 * the screen, the user may continue entering ex commands.  We find
	 * this out when we do the screen/message resolution.  We can't enter
	 * completely into ex mode however, because the user can elect to
	 * return into vi mode by entering any key, i.e. we have to be in raw
	 * mode.
	 */
	for (do_cedit = do_resolution = 0;;) {
		/*
		 * !!!
		 * There may already be an ex command waiting to run.  If
		 * so, we continue with it.
		 */
		if (!EXCMD_RUNNING(gp)) {
			/* Get a command. */
			if (v_tcmd(sp, vp, ':',
			    TXT_BS | TXT_CEDIT | TXT_FILEC | TXT_PROMPT))
				return (1);
			tp = TAILQ_FIRST(&sp->tiq);

			/*
			 * If the user entered a single <esc>, they want to
			 * edit their colon command history.  If they already
			 * entered some text, move it into the edit history.
			 */
			if (tp->term == TERM_CEDIT) {
				if (tp->len > 1 && v_ecl_log(sp, tp))
					return (1);
				do_cedit = 1;
				break;
			}

			/* If the user changed their mind, return. */
			if (tp->term != TERM_OK)
				break;

			/* Log the command. */
			if (O_STR(sp, O_CEDIT) != NULL && v_ecl_log(sp, tp))
				return (1);

			/* Push a command on the command stack. */
			if (ex_run_str(sp, NULL, tp->lb, tp->len, 0, 1))
				return (1);
		}

		/* Home the cursor. */
		vs_home(sp);

		/*
		 * !!!
		 * If the editor wrote the screen behind curses back, put out
		 * a <newline> so that we don't overwrite the user's command
		 * with its output or the next want-to-continue? message.  This
		 * doesn't belong here, but I can't find another place to put
		 * it.  See, we resolved the output from the last ex command,
		 * and the user entered another one.  This is the only place
		 * where we have control before the ex command writes output.
		 * We could get control in vs_msg(), but we have no way to know
		 * if command didn't put out any output when we try and resolve
		 * this command.  This fixes a bug where combinations of ex
		 * commands, e.g. ":set<CR>:!date<CR>:set" didn't look right.
		 */
		if (F_ISSET(sp, SC_SCR_EXWROTE))
			(void)putchar('\n');

		/* Call the ex parser. */
		(void)ex_cmd(sp);

		/* Flush ex messages. */
		(void)ex_fflush(sp);

		/* Resolve any messages. */
		if (vs_ex_resolve(sp, &ifcontinue))
			return (1);

		/*
		 * Continue or return.  If continuing, make sure that we
		 * eventually do resolution.
		 */
		if (!ifcontinue)
			break;
		do_resolution = 1;

		/* If we're continuing, it's a new command. */
		++sp->ccnt;
	}

	/*
	 * If the user previously continued an ex command, we have to do
	 * resolution to clean up the screen.  Don't wait, we already did
	 * that.
	 */
	if (do_resolution) {
		F_SET(sp, SC_EX_WAIT_NO);
		if (vs_ex_resolve(sp, &ifcontinue))
			return (1);
	}

	/* Cleanup from the ex command. */
	if (v_ex_done(sp, vp))
		return (1);

	/* The user may want to edit their colon command history. */
	if (do_cedit)
		return (v_ecl(sp));

	return (0);
}

/*
 * v_ex_done --
 *	Cleanup from an ex command.
 */
static int
v_ex_done(SCR *sp, VICMD *vp)
{
	size_t len;

	/*
	 * The only cursor modifications are real, however, the underlying
	 * line may have changed; don't trust anything.  This code has been
	 * a remarkably fertile place for bugs.  Do a reality check on a
	 * cursor value, and make sure it's okay.  If necessary, change it.
	 * Ex keeps track of the line number, but it cares less about the
	 * column and it may have disappeared.
	 *
	 * Don't trust ANYTHING.
	 *
	 * XXX
	 * Ex will soon have to start handling the column correctly; see
	 * the POSIX 1003.2 standard.
	 */
	if (db_eget(sp, sp->lno, NULL, &len, NULL)) {
		sp->lno = 1;
		sp->cno = 0;
	} else if (sp->cno >= len)
		sp->cno = len ? len - 1 : 0;

	vp->m_final.lno = sp->lno;
	vp->m_final.cno = sp->cno;

	/*
	 * Don't re-adjust the cursor after executing an ex command,
	 * and ex movements are permanent.
	 */
	F_CLR(vp, VM_RCM_MASK);
	F_SET(vp, VM_RCM_SET);

	return (0);
}

/*
 * v_ecl --
 *	Start an edit window on the colon command-line commands.
 */
static int
v_ecl(SCR *sp)
{
	GS *gp;
	SCR *new;

	/* Initialize the screen, if necessary. */
	gp = sp->gp;
	if (gp->ccl_sp == NULL && v_ecl_init(sp))
		return (1);

	/* Get a new screen. */
	if (screen_init(gp, sp, &new))
		return (1);
	if (vs_split(sp, new, 1)) {
		(void)screen_end(new);
		return (1);
	}

	/* Attach to the screen. */
	new->ep = gp->ccl_sp->ep;
	++new->ep->refcnt;

	new->frp = gp->ccl_sp->frp;
	new->frp->flags = sp->frp->flags;

	/* Move the cursor to the end. */
	(void)db_last(new, &new->lno);
	if (new->lno == 0)
		new->lno = 1;

	/* Remember the originating window. */
	sp->ccl_parent = sp;

	/* It's a special window. */
	F_SET(new, SC_COMEDIT);

	/* Set up the switch. */
	sp->nextdisp = new;
	F_SET(sp, SC_SSWITCH);
	return (0);
}

/*
 * v_ecl_exec --
 *	Execute a command from a colon command-line window.
 *
 * PUBLIC: int v_ecl_exec(SCR *);
 */
int
v_ecl_exec(SCR *sp)
{
	size_t len;
	char *p;

	if (db_get(sp, sp->lno, 0, &p, &len) && sp->lno == 1) {
		v_emsg(sp, NULL, VIM_EMPTY);
		return (1);
	}
	if (len == 0) {
		msgq(sp, M_BERR, "No ex command to execute");
		return (1);
	}
	
	/* Push the command on the command stack. */
	if (ex_run_str(sp, NULL, p, len, 0, 0))
		return (1);

	/* Set up the switch. */
	sp->nextdisp = sp->ccl_parent;
	F_SET(sp, SC_EXIT);
	return (0);
}

/*
 * v_ecl_log --
 *	Log a command into the colon command-line log file.
 */
static int
v_ecl_log(SCR *sp, TEXT *tp)
{
	EXF *save_ep;
	recno_t lno;
	int rval;

	/* Initialize the screen, if necessary. */
	if (sp->gp->ccl_sp == NULL && v_ecl_init(sp))
		return (1);

	/*
	 * Don't log colon command window commands into the colon command
	 * window...
	 */
	if (sp->ep == sp->gp->ccl_sp->ep)
		return (0);

	/*
	 * XXX
	 * Swap the current EXF with the colon command file EXF.  This
	 * isn't pretty, but too many routines "know" that sp->ep points
	 * to the current EXF.
	 */
	save_ep = sp->ep;
	sp->ep = sp->gp->ccl_sp->ep;
	if (db_last(sp, &lno)) {
		sp->ep = save_ep;
		return (1);
	}
	rval = db_append(sp, 0, lno, tp->lb, tp->len);
	sp->ep = save_ep;
	return (rval);
}

/*
 * v_ecl_init --
 *	Initialize the colon command-line log file.
 */
static int
v_ecl_init(SCR *sp)
{
	FREF *frp;
	GS *gp;

	gp = sp->gp;

	/* Get a temporary file. */
	if ((frp = file_add(sp, NULL)) == NULL)
		return (1);

	/*
	 * XXX
	 * Create a screen -- the file initialization code wants one.
	 */
	if (screen_init(gp, sp, &gp->ccl_sp))
		return (1);
	if (file_init(gp->ccl_sp, frp, NULL, 0)) {
		(void)screen_end(gp->ccl_sp);
		return (1);
	}

	/* The underlying file isn't recoverable. */
	F_CLR(gp->ccl_sp->ep, F_RCV_ON);

	return (0);
}
@


1.12
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_ex.c,v 1.11 2013/11/25 23:27:11 krw Exp $	*/
d68 1
a68 1
		    "207|The Q command requires the ex terminal interface");
d186 1
a186 1
		msgq(sp, M_ERR, "180|No previous file to edit");
d582 1
a582 1
		msgq(sp, M_BERR, "307|No ex command to execute");
@


1.11
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_ex.c,v 1.10 2009/11/14 17:44:53 jsg Exp $	*/
d41 1
a41 3
v_again(sp, vp)
	SCR *sp;
	VICMD *vp;
d59 1
a59 3
v_exmode(sp, vp)
	SCR *sp;
	VICMD *vp;
d95 1
a95 3
v_join(sp, vp)
	SCR *sp;
	VICMD *vp;
d124 1
a124 3
v_shiftl(sp, vp)
	SCR *sp;
	VICMD *vp;
d141 1
a141 3
v_shiftr(sp, vp)
	SCR *sp;
	VICMD *vp;
d158 1
a158 3
v_suspend(sp, vp)
	SCR *sp;
	VICMD *vp;
d175 1
a175 3
v_switch(sp, vp)
	SCR *sp;
	VICMD *vp;
d212 1
a212 3
v_tagpush(sp, vp)
	SCR *sp;
	VICMD *vp;
d229 1
a229 3
v_tagpop(sp, vp)
	SCR *sp;
	VICMD *vp;
d244 1
a244 3
v_filter(sp, vp)
	SCR *sp;
	VICMD *vp;
d320 1
a320 3
v_event_exec(sp, vp)
	SCR *sp;
	VICMD *vp;
d342 1
a342 4
v_exec_ex(sp, vp, exp)
	SCR *sp;
	VICMD *vp;
	EXCMD *exp;
d357 1
a357 3
v_ex(sp, vp)
	SCR *sp;
	VICMD *vp;
d481 1
a481 3
v_ex_done(sp, vp)
	SCR *sp;
	VICMD *vp;
d523 1
a523 2
v_ecl(sp)
	SCR *sp;
d572 1
a572 2
v_ecl_exec(sp)
	SCR *sp;
d601 1
a601 3
v_ecl_log(sp, tp)
	SCR *sp;
	TEXT *tp;
d640 1
a640 2
v_ecl_init(sp)
	SCR *sp;
@


1.10
log
@fix leaks in error paths found by parfait
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_ex.c,v 1.9 2009/10/27 23:59:47 deraadt Exp $	*/
d313 1
a313 1
	tp = CIRCLEQ_FIRST(&sp->tiq);
d412 1
a412 1
			tp = CIRCLEQ_FIRST(&sp->tiq);
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: v_ex.c,v 1.8 2006/03/20 01:00:36 pvalchev Exp $	*/
d209 2
a210 1
	if (file_m1(sp, 0, FS_ALL))
d212 1
@


1.8
log
@if we're in visual mode reading a command, check the termination value
of v_tcmd() and bail if it's not TERM_OK as opposed to in a more
specific case.  this is based on the NetBSD ^C fix but after
discussion with otto@@.  while it did not affect the specific crash
it is more correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_ex.c,v 1.7 2006/02/17 19:12:41 otto Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)v_ex.c	10.42 (Berkeley) 6/28/96";
#endif /* not lint */
@


1.7
log
@Fix use after free. Problem hunted down by wilfried@@; ok fgsch@@
millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_ex.c,v 1.6 2005/10/17 19:12:16 otto Exp $	*/
d428 2
a429 2
			/* If the user didn't enter anything, return. */
			if (tp->term == TERM_BS)
@


1.6
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_ex.c,v 1.5 2002/02/16 21:27:58 millert Exp $	*/
d203 1
a203 1
	if ((name = sp->alt_name) == NULL) {
d205 4
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_ex.c,v 1.4 2001/01/29 01:58:50 niklas Exp $	*/
d311 1
a311 1
	tp = sp->tiq.cqh_first;
d410 1
a410 1
			tp = sp->tiq.cqh_first;
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 5
a36 5
static int v_ecl __P((SCR *));
static int v_ecl_init __P((SCR *));
static int v_ecl_log __P((SCR *, TEXT *));
static int v_ex_done __P((SCR *, VICMD *));
static int v_exec_ex __P((SCR *, VICMD *, EXCMD *));
d42 1
a42 1
 * PUBLIC: int v_again __P((SCR *, VICMD *));
d62 1
a62 1
 * PUBLIC: int v_exmode __P((SCR *, VICMD *));
d100 1
a100 1
 * PUBLIC: int v_join __P((SCR *, VICMD *));
d131 1
a131 1
 * PUBLIC: int v_shiftl __P((SCR *, VICMD *));
d150 1
a150 1
 * PUBLIC: int v_shiftr __P((SCR *, VICMD *));
d169 1
a169 1
 * PUBLIC: int v_suspend __P((SCR *, VICMD *));
d188 1
a188 1
 * PUBLIC: int v_switch __P((SCR *, VICMD *));
d221 1
a221 1
 * PUBLIC: int v_tagpush __P((SCR *, VICMD *));
d240 1
a240 1
 * PUBLIC: int v_tagpop __P((SCR *, VICMD *));
d257 1
a257 1
 * PUBLIC: int v_filter __P((SCR *, VICMD *));
d335 1
a335 1
 * PUBLIC: int v_event_exec __P((SCR *, VICMD *));
d377 1
a377 1
 * PUBLIC: int v_ex __P((SCR *, VICMD *));
d597 1
a597 1
 * PUBLIC: int v_ecl_exec __P((SCR *));
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d1 2
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)v_ex.c	10.38 (Berkeley) 4/28/96";
d67 4
d72 1
a72 1
	if (sp->gp->scr_screen(sp, SC_EX)) {
d77 1
a348 3
	case E_WRITEQUIT:
		ex_cinit(&cmd, C_WQ, 0, OOBLNO, OOBLNO, 0, NULL);
		break;
d483 1
a483 1
		F_SET(sp, SC_EX_DONTWAIT);
d532 8
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)v_ex.c	8.12 (Berkeley) 8/17/94";
a21 1
#include <signal.h>
d23 1
d25 1
a25 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d27 1
a28 2
#include "excmd.h"
#include "vcmd.h"
d30 5
a34 2
static void excmd __P((EXCMDARG *,
    int, int, recno_t, recno_t, int, ARGS *[], ARGS *, char *));
d39 2
d43 1
a43 1
v_again(sp, ep, vp)
d45 1
a45 2
	EXF *ep;
	VICMDARG *vp;
d48 1
a48 1
	EXCMDARG cmd;
d50 4
a53 3
	excmd(&cmd, C_SUBAGAIN,
	    2, vp->m_start.lno, vp->m_start.lno, 1, ap, &a, "");
	return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d57 87
a143 2
 * v_at -- @@
 *	Execute a buffer.
d146 1
a146 1
v_at(sp, ep, vp)
d148 1
a148 2
	EXF *ep;
	VICMDARG *vp;
d151 1
a151 1
	EXCMDARG cmd;
d153 46
a198 4
        excmd(&cmd, C_AT, 0, OOBLNO, OOBLNO, 0, ap, &a, NULL);
	if (F_ISSET(vp, VC_BUFFER)) {
		F_SET(&cmd, E_BUFFER);
		cmd.buffer = vp->buffer;
d200 8
a207 1
        return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d211 4
a214 2
 * v_ex -- :
 *	Execute a colon command line.
d217 1
a217 1
v_ex(sp, ep, vp)
d219 1
a219 2
	EXF *ep;
	VICMDARG *vp;
d221 6
a226 1
	return (sp->s_ex_run(sp, ep, &vp->m_final));
d230 4
a233 2
 * v_exmode -- Q
 *	Switch the editor into EX mode.
d236 1
a236 1
v_exmode(sp, ep, vp)
d238 1
a238 2
	EXF *ep;
	VICMDARG *vp;
d240 1
a240 4
	/* Save the current line/column number. */
	sp->frp->lno = sp->lno;
	sp->frp->cno = sp->cno;
	F_SET(sp->frp, FR_CURSORSET);
d242 2
a243 5
	/* Switch to ex mode. */
	sp->saved_vi_mode = F_ISSET(sp, S_VI_CURSES | S_VI_XAW);
	F_CLR(sp, S_SCREENS);
	F_SET(sp, S_EX);
	return (0);
d249 2
d253 1
a253 1
v_filter(sp, ep, vp)
d255 1
a255 2
	EXF *ep;
	VICMDARG *vp;
d257 1
a257 2
	ARGS *ap[2], a;
	EXCMDARG cmd;
d274 4
d279 7
a285 5
	excmd(&cmd, C_BANG,
	    2, vp->m_start.lno, vp->m_stop.lno, 0, ap, &a, NULL);
	EXP(sp)->argsoff = 0;			/* XXX */
	if (F_ISSET(vp,  VC_ISDOT)) {
		if (argv_exp1(sp, ep, &cmd, "!", 1, 1))
d287 9
a295 12
	} else {
		/* Get the command from the user. */
		if (sp->s_get(sp, ep, sp->tiqp,
		    '!', TXT_BS | TXT_CR | TXT_ESCAPE | TXT_PROMPT) != INP_OK)
			return (1);
		/*
		 * Len is 0 if backspaced over the prompt,
		 * 1 if only CR entered.
		 */
		tp = sp->tiqp->cqh_first;
		if (tp->len <= 1)
			return (0);
d297 12
a308 2
		if (argv_exp1(sp, ep, &cmd, tp->lb + 1, tp->len - 1, 1))
			return (1);
d310 9
d321 1
a321 1
	return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d325 4
a328 2
 * v_join -- [count]J
 *	Join lines together.
d331 1
a331 1
v_join(sp, ep, vp)
d333 1
a333 2
	EXF *ep;
	VICMDARG *vp;
d335 1
a335 3
	ARGS *ap[2], a;
	EXCMDARG cmd;
	int lno;
d337 14
a350 15
	/*
	 * YASC.
	 * The general rule is that '#J' joins # lines, counting the current
	 * line.  However, 'J' and '1J' are the same as '2J', i.e. join the
	 * current and next lines.  This doesn't map well into the ex command
	 * (which takes two line numbers), so we handle it here.  Note that
	 * we never test for EOF -- historically going past the end of file
	 * worked just fine.
	 */
	lno = vp->m_start.lno + 1;
	if (F_ISSET(vp, VC_C1SET) && vp->count > 2)
		lno = vp->m_start.lno + (vp->count - 1);

	excmd(&cmd, C_JOIN, 2, vp->m_start.lno, lno, 0, ap, &a, NULL);
	return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d354 2
a355 2
 * v_shiftl -- [count]<motion
 *	Shift lines left.
d357 2
a358 2
int
v_shiftl(sp, ep, vp)
d360 2
a361 2
	EXF *ep;
	VICMDARG *vp;
d363 1
a363 2
	ARGS *ap[2], a;
	EXCMDARG cmd;
d365 2
a366 3
	excmd(&cmd, C_SHIFTL,
	    2, vp->m_start.lno, vp->m_stop.lno, 0, ap, &a, "<");
	return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d370 4
a373 2
 * v_shiftr -- [count]>motion
 *	Shift lines right.
d376 1
a376 1
v_shiftr(sp, ep, vp)
d378 1
a378 2
	EXF *ep;
	VICMDARG *vp;
d380 113
a492 2
	ARGS *ap[2], a;
	EXCMDARG cmd;
d494 1
a494 3
	excmd(&cmd, C_SHIFTR,
	    2, vp->m_start.lno, vp->m_stop.lno, 0, ap, &a, ">");
	return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d498 2
a499 2
 * v_switch -- ^^
 *	Switch to the previous file.
d501 2
a502 2
int
v_switch(sp, ep, vp)
d504 1
a504 2
	EXF *ep;
	VICMDARG *vp;
d506 1
a506 3
	ARGS *ap[2], a;
	EXCMDARG cmd;
	char *name;
d509 12
a520 2
	 * Try the alternate file name, then the previous file
	 * name.  Use the real name, not the user's current name.
d522 25
a546 2
	if ((name = sp->alt_name) == NULL) {
		msgq(sp, M_ERR, "No previous file to edit");
a547 1
	}
d549 5
a553 2
	/* If autowrite is set, write out the file. */
	if (file_m1(sp, ep, 0, FS_ALL))
d555 1
d557 22
a578 2
	excmd(&cmd, C_EDIT, 0, OOBLNO, OOBLNO, 0, ap, &a, name);
	return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d582 4
a585 2
 * v_tagpush -- ^[
 *	Do a tag search on a the cursor keyword.
d588 1
a588 1
v_tagpush(sp, ep, vp)
a589 2
	EXF *ep;
	VICMDARG *vp;
d591 15
a605 2
	ARGS *ap[2], a;
	EXCMDARG cmd;
d607 4
a610 2
	excmd(&cmd, C_TAG, 0, OOBLNO, 0, 0, ap, &a, vp->keyword);
	return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d614 2
a615 2
 * v_tagpop -- ^T
 *	Pop the tags stack.
d617 2
a618 2
int
v_tagpop(sp, ep, vp)
d620 1
a620 2
	EXF *ep;
	VICMDARG *vp;
d622 14
a635 2
	ARGS *ap[2], a;
	EXCMDARG cmd;
d637 15
a651 2
	excmd(&cmd, C_TAGPOP, 0, OOBLNO, 0, 0, ap, &a, NULL);
	return (sp->s_ex_cmd(sp, ep, &cmd, &vp->m_final));
d655 31
a685 29
 * excmd --
 *	Build an EX command structure.
 */
static void
excmd(cmdp, cmd_id, naddr, lno1, lno2, force, ap, a, arg)
	EXCMDARG *cmdp;
	int cmd_id, force, naddr;
	recno_t lno1, lno2;
	ARGS *ap[2], *a;
	char *arg;
{
	memset(cmdp, 0, sizeof(EXCMDARG));
	cmdp->cmd = &cmds[cmd_id];
	cmdp->addrcnt = naddr;
	cmdp->addr1.lno = lno1;
	cmdp->addr2.lno = lno2;
	cmdp->addr1.cno = cmdp->addr2.cno = 1;
	if (force)
		cmdp->flags |= E_FORCE;
	if ((a->bp = arg) == NULL) {
		cmdp->argc = 0;
		a->len = 0;
	} else {
		cmdp->argc = 1;
		a->len = strlen(arg);
	}
	ap[0] = a;
	ap[1] = NULL;
	cmdp->argv = ap;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
