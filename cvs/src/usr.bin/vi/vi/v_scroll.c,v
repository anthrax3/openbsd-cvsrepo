head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.10
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	Uu5nFG3wCl0LACBb;

1.9
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.8;
commitid	06bi6U3x4gFFf2G1;

1.8
date	2009.10.27.23.59.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.04.16.18.06;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.52;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.11.26.22.49.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: v_scroll.c,v 1.9 2014/11/12 04:28:41 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>

#include "../common/common.h"
#include "vi.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

static void goto_adjust(VICMD *);

/*
 * The historic vi had a problem in that all movements were by physical
 * lines, not by logical, or screen lines.  Arguments can be made that this
 * is the right thing to do.  For example, single line movements, such as
 * 'j' or 'k', should probably work on physical lines.  Commands like "dj",
 * or "j.", where '.' is a change command, make more sense for physical lines
 * than they do for logical lines.
 *
 * These arguments, however, don't apply to scrolling commands like ^D and
 * ^F -- if the window is fairly small, using physical lines can result in
 * a half-page scroll repainting the entire screen, which is not what the
 * user wanted.  Second, if the line is larger than the screen, using physical
 * lines can make it impossible to display parts of the line -- there aren't
 * any commands that don't display the beginning of the line in historic vi,
 * and if both the beginning and end of the line can't be on the screen at
 * the same time, you lose.  This is even worse in the case of the H, L, and
 * M commands -- for large lines, they may all refer to the same line and
 * will result in no movement at all.
 *
 * Another issue is that page and half-page scrolling commands historically
 * moved to the first non-blank character in the new line.  If the line is
 * approximately the same size as the screen, this loses because the cursor
 * before and after a ^D, may refer to the same location on the screen.  In
 * this implementation, scrolling commands set the cursor to the first non-
 * blank character if the line changes because of the scroll.  Otherwise,
 * the cursor is left alone.
 *
 * This implementation does the scrolling (^B, ^D, ^F, ^U, ^Y, ^E), and the
 * cursor positioning commands (H, L, M) commands using logical lines, not
 * physical.
 */

/*
 * v_lgoto -- [count]G
 *	Go to first non-blank character of the line count, the last line
 *	of the file by default.
 *
 * PUBLIC: int v_lgoto(SCR *, VICMD *);
 */
int
v_lgoto(SCR *sp, VICMD *vp)
{
	recno_t nlines;

	if (F_ISSET(vp, VC_C1SET)) {
		if (!db_exist(sp, vp->count)) {
			/*
			 * !!!
			 * Historically, 1G was legal in an empty file.
			 */
			if (vp->count == 1) {
				if (db_last(sp, &nlines))
					return (1);
				if (nlines == 0)
					return (0);
			}
			v_eof(sp, &vp->m_start);
			return (1);
		}
		vp->m_stop.lno = vp->count;
	} else {
		if (db_last(sp, &nlines))
			return (1);
		vp->m_stop.lno = nlines ? nlines : 1;
	}
	goto_adjust(vp);
	return (0);
}

/*
 * v_home -- [count]H
 *	Move to the first non-blank character of the logical line
 *	count - 1 from the top of the screen, 0 by default.
 *
 * PUBLIC: int v_home(SCR *, VICMD *);
 */
int
v_home(SCR *sp, VICMD *vp)
{
	if (vs_sm_position(sp, &vp->m_stop,
	    F_ISSET(vp, VC_C1SET) ? vp->count - 1 : 0, P_TOP))
		return (1);
	goto_adjust(vp);
	return (0);
}

/*
 * v_middle -- M
 *	Move to the first non-blank character of the logical line
 *	in the middle of the screen.
 *
 * PUBLIC: int v_middle(SCR *, VICMD *);
 */
int
v_middle(SCR *sp, VICMD *vp)
{
	/*
	 * Yielding to none in our quest for compatibility with every
	 * historical blemish of vi, no matter how strange it might be,
	 * we permit the user to enter a count and then ignore it.
	 */
	if (vs_sm_position(sp, &vp->m_stop, 0, P_MIDDLE))
		return (1);
	goto_adjust(vp);
	return (0);
}

/*
 * v_bottom -- [count]L
 *	Move to the first non-blank character of the logical line
 *	count - 1 from the bottom of the screen, 0 by default.
 *
 * PUBLIC: int v_bottom(SCR *, VICMD *);
 */
int
v_bottom(SCR *sp, VICMD *vp)
{
	if (vs_sm_position(sp, &vp->m_stop,
	    F_ISSET(vp, VC_C1SET) ? vp->count - 1 : 0, P_BOTTOM))
		return (1);
	goto_adjust(vp);
	return (0);
}

static void
goto_adjust(VICMD *vp)
{
	/* Guess that it's the end of the range. */
	vp->m_final = vp->m_stop;

	/*
	 * Non-motion commands move the cursor to the end of the range, and
	 * then to the NEXT nonblank of the line.  Historic vi always moved
	 * to the first nonblank in the line; since the H, M, and L commands
	 * are logical motions in this implementation, we do the next nonblank
	 * so that it looks approximately the same to the user.  To make this
	 * happen, the VM_RCM_SETNNB flag is set in the vcmd.c command table.
	 *
	 * If it's a motion, it's more complicated.  The best possible solution
	 * is probably to display the first nonblank of the line the cursor
	 * will eventually rest on.  This is tricky, particularly given that if
	 * the associated command is a delete, we don't yet know what line that
	 * will be.  So, we clear the VM_RCM_SETNNB flag, and set the first
	 * nonblank flag (VM_RCM_SETFNB).  Note, if the lines are sufficiently
	 * long, this can cause the cursor to warp out of the screen.  It's too
	 * hard to fix.
	 *
	 * XXX
	 * The G command is always first nonblank, so it's okay to reset it.
	 */
	if (ISMOTION(vp)) {
		F_CLR(vp, VM_RCM_MASK);
		F_SET(vp, VM_RCM_SETFNB);
	} else
		return;

	/*
	 * If moving backward in the file, delete and yank move to the end
	 * of the range, unless the line didn't change, in which case yank
	 * doesn't move.  If moving forward in the file, delete and yank
	 * stay at the start of the range.  Ignore others.
	 */
	if (vp->m_stop.lno < vp->m_start.lno ||
	    (vp->m_stop.lno == vp->m_start.lno &&
	    vp->m_stop.cno < vp->m_start.cno)) {
		if (ISCMD(vp->rkp, 'y') && vp->m_stop.lno == vp->m_start.lno)
			vp->m_final = vp->m_start;
	} else
		vp->m_final = vp->m_start;
}

/*
 * v_up -- [count]^P, [count]k, [count]-
 *	Move up by lines.
 *
 * PUBLIC: int v_up(SCR *, VICMD *);
 */
int
v_up(SCR *sp, VICMD *vp)
{
	recno_t lno;

	lno = F_ISSET(vp, VC_C1SET) ? vp->count : 1;
	if (vp->m_start.lno <= lno) {
		v_sof(sp, &vp->m_start);
		return (1);
	}
	vp->m_stop.lno = vp->m_start.lno - lno;
	vp->m_final = vp->m_stop;
	return (0);
}

/*
 * v_cr -- [count]^M
 *	In a script window, send the line to the shell.
 *	In a regular window, move down by lines.
 *
 * PUBLIC: int v_cr(SCR *, VICMD *);
 */
int
v_cr(SCR *sp, VICMD *vp)
{
	/* If it's a colon command-line edit window, it's an ex command. */
	if (F_ISSET(sp, SC_COMEDIT))
		return (v_ecl_exec(sp));

	/* If it's a script window, exec the line. */
	if (F_ISSET(sp, SC_SCRIPT))
		return (sscr_exec(sp, vp->m_start.lno));

	/* Otherwise, it's the same as v_down(). */
	return (v_down(sp, vp));
}

/*
 * v_down -- [count]^J, [count]^N, [count]j, [count]^M, [count]+
 *	Move down by lines.
 *
 * PUBLIC: int v_down(SCR *, VICMD *);
 */
int
v_down(SCR *sp, VICMD *vp)
{
	recno_t lno;

	lno = vp->m_start.lno + (F_ISSET(vp, VC_C1SET) ? vp->count : 1);
	if (!db_exist(sp, lno)) {
		v_eof(sp, &vp->m_start);
		return (1);
	}
	vp->m_stop.lno = lno;
	vp->m_final = ISMOTION(vp) ? vp->m_start : vp->m_stop;
	return (0);
}

/*
 * v_hpageup -- [count]^U
 *	Page up half screens.
 *
 * PUBLIC: int v_hpageup(SCR *, VICMD *);
 */
int
v_hpageup(SCR *sp, VICMD *vp)
{
	/*
	 * Half screens always succeed unless already at SOF.
	 *
	 * !!!
	 * Half screens set the scroll value, even if the command
	 * ultimately failed, in historic vi.  Probably a don't care.
	 */
	if (F_ISSET(vp, VC_C1SET))
		sp->defscroll = vp->count;
	if (vs_sm_scroll(sp, &vp->m_stop, sp->defscroll, CNTRL_U))
		return (1);
	vp->m_final = vp->m_stop;
	return (0);
}

/*
 * v_hpagedown -- [count]^D
 *	Page down half screens.
 *
 * PUBLIC: int v_hpagedown(SCR *, VICMD *);
 */
int
v_hpagedown(SCR *sp, VICMD *vp)
{
	/*
	 * Half screens always succeed unless already at EOF.
	 *
	 * !!!
	 * Half screens set the scroll value, even if the command
	 * ultimately failed, in historic vi.  Probably a don't care.
	 */
	if (F_ISSET(vp, VC_C1SET))
		sp->defscroll = vp->count;
	if (vs_sm_scroll(sp, &vp->m_stop, sp->defscroll, CNTRL_D))
		return (1);
	vp->m_final = vp->m_stop;
	return (0);
}

/*
 * v_pagedown -- [count]^F
 *	Page down full screens.
 * !!!
 * Historic vi did not move to the EOF if the screen couldn't move, i.e.
 * if EOF was already displayed on the screen.  This implementation does
 * move to EOF in that case, making ^F more like the historic ^D.
 *
 * PUBLIC: int v_pagedown(SCR *, VICMD *);
 */
int
v_pagedown(SCR *sp, VICMD *vp)
{
	recno_t offset;

	/*
	 * !!!
	 * The calculation in IEEE Std 1003.2-1992 (POSIX) is:
	 *
	 *	top_line = top_line + count * (window - 2);
	 *
	 * which was historically wrong.  The correct one is:
	 *
	 *	top_line = top_line + count * window - 2;
	 *
	 * i.e. the two line "overlap" was only subtracted once.  Which
	 * makes no sense, but then again, an overlap makes no sense for
	 * any screen but the "next" one anyway.  We do it the historical
	 * way as there's no good reason to change it.
	 *
	 * If the screen has been split, use the smaller of the current
	 * window size and the window option value.
	 *
	 * It possible for this calculation to be less than 1; move at
	 * least one line.
	 */
	offset = (F_ISSET(vp, VC_C1SET) ? vp->count : 1) * (IS_SPLIT(sp) ?
	    MINIMUM(sp->t_maxrows, O_VAL(sp, O_WINDOW)) : O_VAL(sp, O_WINDOW));
	offset = offset <= 2 ? 1 : offset - 2;
	if (vs_sm_scroll(sp, &vp->m_stop, offset, CNTRL_F))
		return (1);
	vp->m_final = vp->m_stop;
	return (0);
}

/*
 * v_pageup -- [count]^B
 *	Page up full screens.
 *
 * !!!
 * Historic vi did not move to the SOF if the screen couldn't move, i.e.
 * if SOF was already displayed on the screen.  This implementation does
 * move to SOF in that case, making ^B more like the historic ^U.
 *
 * PUBLIC: int v_pageup(SCR *, VICMD *);
 */
int
v_pageup(SCR *sp, VICMD *vp)
{
	recno_t offset;

	/*
	 * !!!
	 * The calculation in IEEE Std 1003.2-1992 (POSIX) is:
	 *
	 *	top_line = top_line - count * (window - 2);
	 *
	 * which was historically wrong.  The correct one is:
	 *
	 *	top_line = (top_line - count * window) + 2;
	 *
	 * A simpler expression is that, as with ^F, we scroll exactly:
	 *
	 *	count * window - 2
	 *
	 * lines.
	 *
	 * Bizarre.  As with ^F, an overlap makes no sense for anything
	 * but the first screen.  We do it the historical way as there's
	 * no good reason to change it.
	 *
	 * If the screen has been split, use the smaller of the current
	 * window size and the window option value.
	 *
	 * It possible for this calculation to be less than 1; move at
	 * least one line.
	 */
	offset = (F_ISSET(vp, VC_C1SET) ? vp->count : 1) * (IS_SPLIT(sp) ?
	    MINIMUM(sp->t_maxrows, O_VAL(sp, O_WINDOW)) : O_VAL(sp, O_WINDOW));
	offset = offset <= 2 ? 1 : offset - 2;
	if (vs_sm_scroll(sp, &vp->m_stop, offset, CNTRL_B))
		return (1);
	vp->m_final = vp->m_stop;
	return (0);
}

/*
 * v_lineup -- [count]^Y
 *	Page up by lines.
 *
 * PUBLIC: int v_lineup(SCR *, VICMD *);
 */
int
v_lineup(SCR *sp, VICMD *vp)
{
	/*
	 * The cursor moves down, staying with its original line, unless it
	 * reaches the bottom of the screen.
	 */
	if (vs_sm_scroll(sp,
	    &vp->m_stop, F_ISSET(vp, VC_C1SET) ? vp->count : 1, CNTRL_Y))
		return (1);
	vp->m_final = vp->m_stop;
	return (0);
}

/*
 * v_linedown -- [count]^E
 *	Page down by lines.
 *
 * PUBLIC: int v_linedown(SCR *, VICMD *);
 */
int
v_linedown(SCR *sp, VICMD *vp)
{
	/*
	 * The cursor moves up, staying with its original line, unless it
	 * reaches the top of the screen.
	 */
	if (vs_sm_scroll(sp,
	    &vp->m_stop, F_ISSET(vp, VC_C1SET) ? vp->count : 1, CNTRL_E))
		return (1);
	vp->m_final = vp->m_stop;
	return (0);
}
@


1.9
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_scroll.c,v 1.8 2009/10/27 23:59:48 deraadt Exp $	*/
a13 1
#include <sys/param.h>
d25 2
d349 1
a349 1
	    MIN(sp->t_maxrows, O_VAL(sp, O_WINDOW)) : O_VAL(sp, O_WINDOW));
d400 1
a400 1
	    MIN(sp->t_maxrows, O_VAL(sp, O_WINDOW)) : O_VAL(sp, O_WINDOW));
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: v_scroll.c,v 1.7 2006/03/04 16:18:06 miod Exp $	*/
d68 1
a68 3
v_lgoto(sp, vp)
	SCR *sp;
	VICMD *vp;
d105 1
a105 3
v_home(sp, vp)
	SCR *sp;
	VICMD *vp;
d122 1
a122 3
v_middle(sp, vp)
	SCR *sp;
	VICMD *vp;
d143 1
a143 3
v_bottom(sp, vp)
	SCR *sp;
	VICMD *vp;
d153 1
a153 2
goto_adjust(vp)
	VICMD *vp;
d206 1
a206 3
v_up(sp, vp)
	SCR *sp;
	VICMD *vp;
d228 1
a228 3
v_cr(sp, vp)
	SCR *sp;
	VICMD *vp;
d249 1
a249 3
v_down(sp, vp)
	SCR *sp;
	VICMD *vp;
d270 1
a270 3
v_hpageup(sp, vp)
	SCR *sp;
	VICMD *vp;
d294 1
a294 3
v_hpagedown(sp, vp)
	SCR *sp;
	VICMD *vp;
d322 1
a322 3
v_pagedown(sp, vp)
	SCR *sp;
	VICMD *vp;
d368 1
a368 3
v_pageup(sp, vp)
	SCR *sp;
	VICMD *vp;
d414 1
a414 3
v_lineup(sp, vp)
	SCR *sp;
	VICMD *vp;
d434 1
a434 3
v_linedown(sp, vp)
	SCR *sp;
	VICMD *vp;
@


1.7
log
@the the
@
text
@d1 1
a1 1
/*	$OpenBSD: v_scroll.c,v 1.6 2006/01/08 21:05:40 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)v_scroll.c	10.9 (Berkeley) 4/27/96";
#endif /* not lint */
@


1.6
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_scroll.c,v 1.5 2002/02/16 21:27:58 millert Exp $	*/
d340 1
a340 1
 * move to EOF in that case, making ^F more like the the historic ^D.
d388 1
a388 1
 * move to SOF in that case, making ^B more like the the historic ^U.
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_scroll.c,v 1.4 2001/01/29 01:58:52 niklas Exp $	*/
d204 2
a205 2
	    vp->m_stop.lno == vp->m_start.lno &&
	    vp->m_stop.cno < vp->m_start.cno) {
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
a30 1
static void goto_adjust __P((VICMD *));
d69 1
a69 1
 * PUBLIC: int v_lgoto __P((SCR *, VICMD *));
d108 1
a108 1
 * PUBLIC: int v_home __P((SCR *, VICMD *));
d127 1
a127 1
 * PUBLIC: int v_middle __P((SCR *, VICMD *));
d150 1
a150 1
 * PUBLIC: int v_bottom __P((SCR *, VICMD *));
d216 1
a216 1
 * PUBLIC: int v_up __P((SCR *, VICMD *));
d240 1
a240 1
 * PUBLIC: int v_cr __P((SCR *, VICMD *));
d263 1
a263 1
 * PUBLIC: int v_down __P((SCR *, VICMD *));
d286 1
a286 1
 * PUBLIC: int v_hpageup __P((SCR *, VICMD *));
d312 1
a312 1
 * PUBLIC: int v_hpagedown __P((SCR *, VICMD *));
d342 1
a342 1
 * PUBLIC: int v_pagedown __P((SCR *, VICMD *));
d390 1
a390 1
 * PUBLIC: int v_pageup __P((SCR *, VICMD *));
d438 1
a438 1
 * PUBLIC: int v_lineup __P((SCR *, VICMD *));
d460 1
a460 1
 * PUBLIC: int v_linedown __P((SCR *, VICMD *));
@


1.3
log
@o Update README files etc. from nvi-1.79 so they have the correct info
o make port.h empty since we there is nothing we lack
o include <sys/param.h>, not <sys/types.h> in files that use MIN/MAX macros
o add perl api support since we have libperl (off by default)
@
text
@d1 2
@


1.2
log
@new vi
@
text
@d16 1
a16 1
#include <sys/types.h>
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)v_scroll.c	8.22 (Berkeley) 8/17/94";
a22 1
#include <signal.h>
a23 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d25 1
a26 2
#include "excmd.h"
#include "vcmd.h"
d28 1
a28 1
static void goto_adjust __P((VICMDARG *));
d66 2
d70 1
a70 1
v_lgoto(sp, ep, vp)
d72 1
a72 2
	EXF *ep;
	VICMDARG *vp;
d77 12
a88 2
		if (file_gline(sp, ep, vp->count, NULL) == NULL) {
			v_eof(sp, ep, &vp->m_start);
d93 1
a93 1
		if (file_lline(sp, ep, &nlines))
d105 2
d109 1
a109 1
v_home(sp, ep, vp)
d111 1
a111 2
	EXF *ep;
	VICMDARG *vp;
d113 1
a113 1
	if (sp->s_position(sp, ep, &vp->m_stop,
d124 2
d128 1
a128 1
v_middle(sp, ep, vp)
d130 1
a130 2
	EXF *ep;
	VICMDARG *vp;
d137 1
a137 1
	if (sp->s_position(sp, ep, &vp->m_stop, 0, P_MIDDLE))
d147 2
d151 1
a151 1
v_bottom(sp, ep, vp)
d153 1
a153 2
	EXF *ep;
	VICMDARG *vp;
d155 1
a155 1
	if (sp->s_position(sp, ep, &vp->m_stop,
d164 1
a164 1
	VICMDARG *vp;
d196 4
a199 4
	 * If moving backward in the file, VC_D and VC_Y move to the end
	 * of the range, unless the line didn't change, in which case VC_Y
	 * doesn't move.  If moving forward in the file, VC_D and VC_Y stay
	 * at the start of the range.  Ignore VC_C and VC_DEF.
d204 1
a204 1
		if (F_ISSET(vp, VC_Y) && vp->m_stop.lno == vp->m_start.lno)
d213 2
d217 1
a217 1
v_up(sp, ep, vp)
d219 1
a219 2
	EXF *ep;
	VICMDARG *vp;
d237 2
d241 1
a241 1
v_cr(sp, ep, vp)
d243 1
a243 2
	EXF *ep;
	VICMDARG *vp;
d245 10
a254 6
	/*
	 * If it's a script window, exec the line,
	 * otherwise it's the same as v_down().
	 */
	return (F_ISSET(sp, S_SCRIPT) ?
	    sscr_exec(sp, ep, vp->m_start.lno) : v_down(sp, ep, vp));
d260 2
d264 1
a264 1
v_down(sp, ep, vp)
d266 1
a266 2
	EXF *ep;
	VICMDARG *vp;
d271 2
a272 2
	if (file_gline(sp, ep, lno, NULL) == NULL) {
		v_eof(sp, ep, &vp->m_start);
d283 2
d287 1
a287 1
v_hpageup(sp, ep, vp)
d289 1
a289 2
	EXF *ep;
	VICMDARG *vp;
d300 1
a300 1
	if (sp->s_scroll(sp, ep, &vp->m_stop, sp->defscroll, CNTRL_U))
d309 2
d313 1
a313 1
v_hpagedown(sp, ep, vp)
d315 1
a315 2
	EXF *ep;
	VICMDARG *vp;
d326 1
a326 1
	if (sp->s_scroll(sp, ep, &vp->m_stop, sp->defscroll, CNTRL_D))
d339 2
d343 1
a343 1
v_pagedown(sp, ep, vp)
d345 1
a345 2
	EXF *ep;
	VICMDARG *vp;
d362 1
a362 1
	 * was as there's no good reason to change it.
d367 1
a367 2
	 * Given a one-line screen with the cursor on line 1, it would be
	 * possible for this to fail, i.e. "1 + 1 * 1 - 2 = 0".  Move at
d370 4
a373 10
#define	IS_SPLIT_SCREEN(sp)						\
	((sp)->q.cqe_prev != (void *)&(sp)->gp->dq ||			\
	    (sp)->q.cqe_next != (void *)&(sp)->gp->dq)

	offset = (F_ISSET(vp, VC_C1SET) ? vp->count : 1) *
	    (IS_SPLIT_SCREEN(sp) ?
	    MIN(sp->t_maxrows, O_VAL(sp, O_WINDOW)) : O_VAL(sp, O_WINDOW)) - 2;
	if (offset == 0)
		offset = 1;
	if (sp->s_scroll(sp, ep, &vp->m_stop, offset, CNTRL_F))
d387 2
d391 1
a391 1
v_pageup(sp, ep, vp)
d393 1
a393 2
	EXF *ep;
	VICMDARG *vp;
d420 1
a420 2
	 * Given a one-line screen with the cursor on line 1, it would be
	 * possible for this to fail, i.e. "1 + 1 * 1 - 2 = 0".  Move at
d423 4
a426 6
	offset = (F_ISSET(vp, VC_C1SET) ? vp->count : 1) *
	    (IS_SPLIT_SCREEN(sp) ?
	    MIN(sp->t_maxrows, O_VAL(sp, O_WINDOW)) : O_VAL(sp, O_WINDOW)) - 2;
	if (offset == 0)
		offset = 1;
	if (sp->s_scroll(sp, ep, &vp->m_stop, offset, CNTRL_B))
d435 2
d439 1
a439 1
v_lineup(sp, ep, vp)
d441 1
a441 2
	EXF *ep;
	VICMDARG *vp;
d447 1
a447 1
	if (sp->s_scroll(sp, ep,
d457 2
d461 1
a461 1
v_linedown(sp, ep, vp)
d463 1
a463 2
	EXF *ep;
	VICMDARG *vp;
d469 1
a469 1
	if (sp->s_scroll(sp, ep,
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
