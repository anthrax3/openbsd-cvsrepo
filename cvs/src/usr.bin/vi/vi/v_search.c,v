head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.13;
commitid	adBvXLg05bJxz6yx;

1.13
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.12;
commitid	06bi6U3x4gFFf2G1;

1.12
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.48;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.52;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.06.23.22.40.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.01.18.49;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.16.05;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@/*	$OpenBSD: v_search.c,v 1.13 2014/11/12 04:28:41 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../common/common.h"
#include "vi.h"

static int v_exaddr(SCR *, VICMD *, dir_t);
static int v_search(SCR *, VICMD *, char *, size_t, u_int, dir_t);

/*
 * v_srch -- [count]?RE[? offset]
 *	Ex address search backward.
 *
 * PUBLIC: int v_searchb(SCR *, VICMD *);
 */
int
v_searchb(SCR *sp, VICMD *vp)
{
	return (v_exaddr(sp, vp, BACKWARD));
}

/*
 * v_searchf -- [count]/RE[/ offset]
 *	Ex address search forward.
 *
 * PUBLIC: int v_searchf(SCR *, VICMD *);
 */
int
v_searchf(SCR *sp, VICMD *vp)
{
	return (v_exaddr(sp, vp, FORWARD));
}

/*
 * v_exaddr --
 *	Do a vi search (which is really an ex address).
 */
static int
v_exaddr(SCR *sp, VICMD *vp, dir_t dir)
{
	static EXCMDLIST fake = { "search" };
	EXCMD *cmdp;
	GS *gp;
	TEXT *tp;
	recno_t s_lno;
	size_t len, s_cno, tlen;
	int err, nb, type;
	char *cmd, *t, buf[20];

	/*
	 * !!!
	 * If using the search command as a motion, any addressing components
	 * are lost, i.e. y/ptrn/+2, when repeated, is the same as y/ptrn/.
	 */
	if (F_ISSET(vp, VC_ISDOT))
		return (v_search(sp, vp,
		    NULL, 0, SEARCH_PARSE | SEARCH_MSG | SEARCH_SET, dir));

	/* Get the search pattern. */
	if (v_tcmd(sp, vp, dir == BACKWARD ? CH_BSEARCH : CH_FSEARCH,
	    TXT_BS | TXT_CR | TXT_ESCAPE | TXT_PROMPT |
	    (O_ISSET(sp, O_SEARCHINCR) ? TXT_SEARCHINCR : 0)))
		return (1);

	tp = TAILQ_FIRST(&sp->tiq);

	/* If the user backspaced over the prompt, do nothing. */
	if (tp->term == TERM_BS)
		return (1);

	/*
	 * If the user was doing an incremental search, then we've already
	 * updated the cursor and moved to the right location.  Return the
	 * correct values, we're done.
	 */
	if (tp->term == TERM_SEARCH) {
		vp->m_stop.lno = sp->lno;
		vp->m_stop.cno = sp->cno;
		if (ISMOTION(vp))
			return (v_correct(sp, vp, 0));
		vp->m_final = vp->m_stop;
		return (0);
	}

	/*
	 * If the user entered <escape> or <carriage-return>, the length is
	 * 1 and the right thing will happen, i.e. the prompt will be used
	 * as a command character.
	 *
	 * Build a fake ex command structure.
	 */
	gp = sp->gp;
	gp->excmd.cp = tp->lb;
	gp->excmd.clen = tp->len;
	F_INIT(&gp->excmd, E_VISEARCH);

	/*
	 * XXX
	 * Warn if the search wraps.  This is a pretty special case, but it's
	 * nice feature that wasn't in the original implementations of ex/vi.
	 * (It was added at some point to System V's version.)  This message
	 * is only displayed if there are no keys in the queue. The problem is
	 * the command is going to succeed, and the message is informational,
	 * not an error.  If a macro displays it repeatedly, e.g., the pattern
	 * only occurs once in the file and wrapscan is set, you lose big.  For
	 * example, if the macro does something like:
	 *
	 *	:map K /pattern/^MjK
	 *
	 * Each search will display the message, but the following "/pattern/"
	 * will immediately overwrite it, with strange results.  The System V
	 * vi displays the "wrapped" message multiple times, but because it's
	 * overwritten each time, it's not as noticeable.  As we don't discard
	 * messages, it's a real problem for us.
	 */
	if (!KEYS_WAITING(sp))
		F_SET(&gp->excmd, E_SEARCH_WMSG);
		
	/* Save the current line/column. */
	s_lno = sp->lno;
	s_cno = sp->cno;

	/*
	 * !!!
	 * Historically, vi / and ? commands were full-blown ex addresses,
	 * including ';' delimiters, trailing <blank>'s, multiple search
	 * strings (separated by semi-colons) and, finally, full-blown z
	 * commands after the / and ? search strings.  (If the search was
	 * being used as a motion, the trailing z command was ignored.
	 * Also, we do some argument checking on the z command, to be sure
	 * that it's not some other random command.) For multiple search
	 * strings, leading <blank>'s at the second and subsequent strings
	 * were eaten as well.  This has some (unintended?) side-effects:
	 * the command /ptrn/;3 is legal and results in moving to line 3.
	 * I suppose you could use it to optionally move to line 3...
	 *
	 * !!!
	 * Historically, if any part of the search command failed, the cursor
	 * remained unmodified (even if ; was used).  We have to play games
	 * because the underlying ex parser thinks we're modifying the cursor
	 * as we go, but I think we're compatible with historic practice.
	 *
	 * !!!
	 * Historically, the command "/STRING/;   " failed, apparently it
	 * confused the parser.  We're not that compatible.
	 */
	cmdp = &gp->excmd;
	if (ex_range(sp, cmdp, &err))
		return (1);
	
	/*
	 * Remember where any remaining command information is, and clean
	 * up the fake ex command.
	 */
	cmd = cmdp->cp;
	len = cmdp->clen;
	gp->excmd.clen = 0;

	if (err)
		goto err2;

	/* Copy out the new cursor position and make sure it's okay. */
	switch (cmdp->addrcnt) {
	case 1:
		vp->m_stop = cmdp->addr1;
		break;
	case 2:
		vp->m_stop = cmdp->addr2;
		break;
	}
	if (!db_exist(sp, vp->m_stop.lno)) {
		ex_badaddr(sp, &fake,
		    vp->m_stop.lno == 0 ? A_ZERO : A_EOF, NUM_OK);
		goto err2;
	}

	/*
	 * !!!
	 * Historic practice is that a trailing 'z' was ignored if it was a
	 * motion command.  Should probably be an error, but not worth the
	 * effort.
	 */
	if (ISMOTION(vp))
		return (v_correct(sp, vp, F_ISSET(cmdp, E_DELTA)));
		
	/*
	 * !!!
	 * Historically, if it wasn't a motion command, a delta in the search
	 * pattern turns it into a first nonblank movement.
	 */
	nb = F_ISSET(cmdp, E_DELTA);

	/* Check for the 'z' command. */
	if (len != 0) {
		if (*cmd != 'z')
			goto err1;

		/* No blanks, just like the z command. */
		for (t = cmd + 1, tlen = len - 1; tlen > 0; ++t, --tlen)
			if (!isdigit(*t))
				break;
		if (tlen &&
		    (*t == '-' || *t == '.' || *t == '+' || *t == '^')) {
			++t;
			--tlen;
			type = 1;
		} else
			type = 0;
		if (tlen)
			goto err1;

		/* The z command will do the nonblank for us. */
		nb = 0;

		/* Default to z+. */
		if (!type &&
		    v_event_push(sp, NULL, "+", 1, CH_NOMAP | CH_QUOTED))
			return (1);

		/* Push the user's command. */
		if (v_event_push(sp, NULL, cmd, len, CH_NOMAP | CH_QUOTED))
			return (1);

		/* Push line number so get correct z display. */
		tlen = snprintf(buf,
		    sizeof(buf), "%lu", (u_long)vp->m_stop.lno);
		if (tlen >= sizeof(buf))
			tlen = sizeof(buf) - 1;
		if (v_event_push(sp, NULL, buf, tlen, CH_NOMAP | CH_QUOTED))
			return (1);
		 
		/* Don't refresh until after 'z' happens. */
		F_SET(VIP(sp), VIP_S_REFRESH);
	}

	/* Non-motion commands move to the end of the range. */
	vp->m_final = vp->m_stop;
	if (nb) {
		F_CLR(vp, VM_RCM_MASK);
		F_SET(vp, VM_RCM_SETFNB);
	}
	return (0);

err1:	msgq(sp, M_ERR,
	    "Characters after search string, line offset and/or z command");
err2:	vp->m_final.lno = s_lno;
	vp->m_final.cno = s_cno;
	return (1);
}

/*
 * v_searchN -- N
 *	Reverse last search.
 *
 * PUBLIC: int v_searchN(SCR *, VICMD *);
 */
int
v_searchN(SCR *sp, VICMD *vp)
{
	dir_t dir;

	switch (sp->searchdir) {
	case BACKWARD:
		dir = FORWARD;
		break;
	case FORWARD:
		dir = BACKWARD;
		break;
	default:
		dir = sp->searchdir;
		break;
	}
	return (v_search(sp, vp, NULL, 0, SEARCH_PARSE, dir));
}

/*
 * v_searchn -- n
 *	Repeat last search.
 *
 * PUBLIC: int v_searchn(SCR *, VICMD *);
 */
int
v_searchn(SCR *sp, VICMD *vp)
{
	return (v_search(sp, vp, NULL, 0, SEARCH_PARSE, sp->searchdir));
}

/*
 * v_searchw -- [count]^A
 *	Search for the word under the cursor.
 *
 * PUBLIC: int v_searchw(SCR *, VICMD *);
 */
int
v_searchw(SCR *sp, VICMD *vp)
{
	size_t blen, len;
	int rval;
	char *bp;

	len = VIP(sp)->klen + sizeof(RE_WSTART) + sizeof(RE_WSTOP);
	GET_SPACE_RET(sp, bp, blen, len);
	len = snprintf(bp, blen, "%s%s%s", RE_WSTART, VIP(sp)->keyw, RE_WSTOP);
	if (len >= blen)
		len = blen - 1;

	rval = v_search(sp, vp, bp, len, SEARCH_SET, FORWARD);

	FREE_SPACE(sp, bp, blen);
	return (rval);
}

/*
 * v_search --
 *	The search commands.
 */
static int
v_search(SCR *sp, VICMD *vp, char *ptrn, size_t plen, u_int flags, dir_t dir)
{
	/* Display messages. */
	LF_SET(SEARCH_MSG);

	/* If it's a motion search, offset past end-of-line is okay. */
	if (ISMOTION(vp))
		LF_SET(SEARCH_EOL);

	/*
	 * XXX
	 * Warn if the search wraps.  See the comment above, in v_exaddr().
	 */
	if (!KEYS_WAITING(sp))
		LF_SET(SEARCH_WMSG);
		
	switch (dir) {
	case BACKWARD:
		if (b_search(sp,
		    &vp->m_start, &vp->m_stop, ptrn, plen, NULL, flags))
			return (1);
		break;
	case FORWARD:
		if (f_search(sp,
		    &vp->m_start, &vp->m_stop, ptrn, plen, NULL, flags))
			return (1);
		break;
	case NOTSET:
		msgq(sp, M_ERR, "No previous search pattern");
		return (1);
	default:
		abort();
	}

	/* Correct motion commands, otherwise, simply move to the location. */
	if (ISMOTION(vp)) {
		if (v_correct(sp, vp, 0))
			return(1);
	} else
		vp->m_final = vp->m_stop;
	return (0);
}

/*
 * v_correct --
 *	Handle command with a search as the motion.
 *
 * !!!
 * Historically, commands didn't affect the line searched to/from if the
 * motion command was a search and the final position was the start/end
 * of the line.  There were some special cases and vi was not consistent;
 * it was fairly easy to confuse it.  For example, given the two lines:
 *
 *	abcdefghi
 *	ABCDEFGHI
 *
 * placing the cursor on the 'A' and doing y?$ would so confuse it that 'h'
 * 'k' and put would no longer work correctly.  In any case, we try to do
 * the right thing, but it's not going to exactly match historic practice.
 *
 * PUBLIC: int v_correct(SCR *, VICMD *, int);
 */
int
v_correct(SCR *sp, VICMD *vp, int isdelta)
{
	MARK m;
	size_t len;

	/*
	 * !!!
	 * We may have wrapped if wrapscan was set, and we may have returned
	 * to the position where the cursor started.  Historic vi didn't cope
	 * with this well.  Yank wouldn't beep, but the first put after the
	 * yank would move the cursor right one column (without adding any
	 * text) and the second would put a copy of the current line.  The
	 * change and delete commands would beep, but would leave the cursor
	 * on the colon command line.  I believe that there are macros that
	 * depend on delete, at least, failing.  For now, commands that use
	 * search as a motion component fail when the search returns to the
	 * original cursor position.
	 */
	if (vp->m_start.lno == vp->m_stop.lno &&
	    vp->m_start.cno == vp->m_stop.cno) {
		msgq(sp, M_BERR, "Search wrapped to original position");
		return (1);
	}

	/*
	 * !!!
	 * Searches become line mode operations if there was a delta specified
	 * to the search pattern.
	 */
	if (isdelta)
		F_SET(vp, VM_LMODE);

	/*
	 * If the motion is in the reverse direction, switch the start and
	 * stop MARK's so that it's in a forward direction.  (There's no
	 * reason for this other than to make the tests below easier.  The
	 * code in vi.c:vi() would have done the switch.)  Both forward
	 * and backward motions can happen for any kind of search command
	 * because of the wrapscan option.
	 */
	if (vp->m_start.lno > vp->m_stop.lno ||
	    (vp->m_start.lno == vp->m_stop.lno &&
	    vp->m_start.cno > vp->m_stop.cno)) {
		m = vp->m_start;
		vp->m_start = vp->m_stop;
		vp->m_stop = m;
	}

	/*
	 * BACKWARD:
	 *	Delete and yank commands move to the end of the range.
	 *	Ignore others.
	 *
	 * FORWARD:
	 *	Delete and yank commands don't move.  Ignore others.
	 */
	vp->m_final = vp->m_start;

	/*
	 * !!!
	 * Delta'd searches don't correct based on column positions.
	 */
	if (isdelta)
		return (0);

	/*
	 * !!!
	 * Backward searches starting at column 0, and forward searches ending
	 * at column 0 are corrected to the last column of the previous line.
	 * Otherwise, adjust the starting/ending point to the character before
	 * the current one (this is safe because we know the search had to move
	 * to succeed).
	 *
	 * Searches become line mode operations if they start at the first
	 * nonblank and end at column 0 of another line.
	 */
	if (vp->m_start.lno < vp->m_stop.lno && vp->m_stop.cno == 0) {
		if (db_get(sp, --vp->m_stop.lno, DBG_FATAL, NULL, &len))
			return (1);
		vp->m_stop.cno = len ? len - 1 : 0;
		len = 0;
		if (nonblank(sp, vp->m_start.lno, &len))
			return (1);
		if (vp->m_start.cno <= len)
			F_SET(vp, VM_LMODE);
	} else
		--vp->m_stop.cno;

	return (0);
}
@


1.13
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_search.c,v 1.12 2013/11/25 23:27:11 krw Exp $	*/
d267 1
a267 1
	    "188|Characters after search string, line offset and/or z command");
d368 1
a368 1
		msgq(sp, M_ERR, "189|No previous search pattern");
d423 1
a423 1
		msgq(sp, M_BERR, "190|Search wrapped to original position");
@


1.12
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_search.c,v 1.11 2009/10/27 23:59:48 deraadt Exp $	*/
d39 1
a39 3
v_searchb(sp, vp)
	SCR *sp;
	VICMD *vp;
d51 1
a51 3
v_searchf(sp, vp)
	SCR *sp;
	VICMD *vp;
d61 1
a61 4
v_exaddr(sp, vp, dir)
	SCR *sp;
	VICMD *vp;
	dir_t dir;
d280 1
a280 3
v_searchN(sp, vp)
	SCR *sp;
	VICMD *vp;
d305 1
a305 3
v_searchn(sp, vp)
	SCR *sp;
	VICMD *vp;
d317 1
a317 3
v_searchw(sp, vp)
	SCR *sp;
	VICMD *vp;
d340 1
a340 7
v_search(sp, vp, ptrn, plen, flags, dir)
	SCR *sp;
	VICMD *vp;
	u_int flags;
	char *ptrn;
	size_t plen;
	dir_t dir;
d403 1
a403 4
v_correct(sp, vp, isdelta)
	SCR *sp;
	VICMD *vp;
	int isdelta;
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: v_search.c,v 1.10 2006/04/22 03:09:15 ray Exp $	*/
d94 1
a94 1
	tp = CIRCLEQ_FIRST(&sp->tiq);
@


1.10
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_search.c,v 1.9 2006/01/08 21:05:40 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)v_search.c	10.18 (Berkeley) 9/19/96";
#endif /* not lint */
@


1.9
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_search.c,v 1.8 2005/10/17 19:12:16 otto Exp $	*/
a430 1
	dir_t dir;
d475 1
a475 3
		dir = BACKWARD;
	} else
		dir = FORWARD;
@


1.8
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: v_search.c,v 1.7 2002/02/16 21:27:58 millert Exp $	*/
d471 2
a472 2
	    vp->m_start.lno == vp->m_stop.lno &&
	    vp->m_start.cno > vp->m_stop.cno) {
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_search.c,v 1.6 2001/01/29 01:58:52 niklas Exp $	*/
d98 1
a98 1
	tp = sp->tiq.cqh_first;
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 2
a34 2
static int v_exaddr __P((SCR *, VICMD *, dir_t));
static int v_search __P((SCR *, VICMD *, char *, size_t, u_int, dir_t));
d40 1
a40 1
 * PUBLIC: int v_searchb __P((SCR *, VICMD *));
d54 1
a54 1
 * PUBLIC: int v_searchf __P((SCR *, VICMD *));
d288 1
a288 1
 * PUBLIC: int v_searchN __P((SCR *, VICMD *));
d315 1
a315 1
 * PUBLIC: int v_searchn __P((SCR *, VICMD *));
d329 1
a329 1
 * PUBLIC: int v_searchw __P((SCR *, VICMD *));
d423 1
a423 1
 * PUBLIC: int v_correct __P((SCR *, VICMD *, int));
@


1.5
log
@Fix snprintf return value usage.
@
text
@d1 2
@


1.4
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d258 2
d341 2
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)v_search.c	10.17 (Berkeley) 6/30/96";
d499 2
a500 2
	 * Searches become line mode operations if they start at column 0 and
	 * end at column 0 of another line.
d505 5
a509 1
		if (vp->m_start.cno == 0)
a510 1
		vp->m_stop.cno = len ? len - 1 : 0;
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)v_search.c	10.16 (Berkeley) 5/8/96";
d32 1
a32 1
static int v_search __P((SCR *, VICMD *, char *, u_int, dir_t));
d88 1
a88 1
		    NULL, SEARCH_PARSE | SEARCH_MSG | SEARCH_SET, dir));
d126 1
a126 1
	F_SET(&gp->excmd, E_VISEARCH);
d128 22
d304 1
a304 1
	return (v_search(sp, vp, NULL, SEARCH_PARSE, dir));
d318 1
a318 1
	return (v_search(sp, vp, NULL, SEARCH_PARSE, sp->searchdir));
d338 1
a338 1
	(void)snprintf(bp, blen, "%s%s%s", RE_WSTART, VIP(sp)->keyw, RE_WSTOP);
d340 1
a340 1
	rval = v_search(sp, vp, bp, SEARCH_SET, FORWARD);
d351 1
a351 1
v_search(sp, vp, ptrn, flags, dir)
d356 1
d359 14
d375 2
a376 2
		if (b_search(sp, &vp->m_start, &vp->m_stop, ptrn, NULL,
		    flags | SEARCH_MSG | (ISMOTION(vp) ? SEARCH_EOL : 0)))
d380 2
a381 2
		if (f_search(sp, &vp->m_start, &vp->m_stop, ptrn, NULL,
		    flags | SEARCH_MSG | (ISMOTION(vp) ? SEARCH_EOL : 0)))
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)v_search.c	8.34 (Berkeley) 8/17/94";
d21 1
a23 1
#include <signal.h>
a26 1
#include <termios.h>
d28 2
a29 3
#include "compat.h"
#include <db.h>
#include <regex.h>
d31 2
a32 2
#include "vi.h"
#include "vcmd.h"
d34 13
a46 4
static int correct __P((SCR *, EXF *, VICMDARG *, u_int));
static int getptrn __P((SCR *, EXF *, ARG_CHAR_T, char **, size_t *));
static int search __P((SCR *,
    EXF *, VICMDARG *, char *, size_t, u_int, enum direction));
d49 4
a52 2
 * v_searchn -- n
 *	Repeat last search.
d55 1
a55 1
v_searchn(sp, ep, vp)
d57 1
a57 2
	EXF *ep;
	VICMDARG *vp;
d59 197
a255 1
	return (search(sp, ep, vp, NULL, 0, SEARCH_MSG, sp->searchdir));
d261 2
d265 1
a265 1
v_searchN(sp, ep, vp)
d267 1
a267 2
	EXF *ep;
	VICMDARG *vp;
d269 1
a269 1
	enum direction dir;
d278 1
a278 1
	default:			/* NOTSET handled in search(). */
d282 1
a282 1
	return (search(sp, ep, vp, NULL, 0, SEARCH_MSG, dir));
d286 4
a289 2
 * v_searchb -- [count]?RE[? offset]
 *	Search backward.
d292 1
a292 1
v_searchb(sp, ep, vp)
d294 1
a294 2
	EXF *ep;
	VICMDARG *vp;
d296 1
a296 42
	size_t len;
	char *ptrn;

	if (F_ISSET(vp, VC_ISDOT))
		ptrn = NULL;
	else {
		if (getptrn(sp, ep, CH_BSEARCH, &ptrn, &len))
			return (1);
		if (len == 0) {
			F_SET(vp, VM_NOMOTION);
			return (0);
		}
	}
	return (search(sp, ep, vp, ptrn, len,
	    SEARCH_MSG | SEARCH_PARSE | SEARCH_SET, BACKWARD));
}

/*
 * v_searchf -- [count]/RE[/ offset]
 *	Search forward.
 */
int
v_searchf(sp, ep, vp)
	SCR *sp;
	EXF *ep;
	VICMDARG *vp;
{
	size_t len;
	char *ptrn;

	if (F_ISSET(vp, VC_ISDOT))
		ptrn = NULL;
	else {
		if (getptrn(sp, ep, CH_FSEARCH, &ptrn, &len))
			return (1);
		if (len == 0) {
			F_SET(vp, VM_NOMOTION);
			return (0);
		}
	}
	return (search(sp, ep, vp, ptrn, len,
	    SEARCH_MSG | SEARCH_PARSE | SEARCH_SET, FORWARD));
d302 2
d306 1
a306 1
v_searchw(sp, ep, vp)
d308 1
a308 2
	EXF *ep;
	VICMDARG *vp;
d314 1
a314 1
	len = vp->kbuflen + sizeof(RE_WSTART) + sizeof(RE_WSTOP);
d316 1
a316 1
	(void)snprintf(bp, blen, "%s%s%s", RE_WSTART, vp->keyword, RE_WSTOP);
d318 1
a318 1
	rval = search(sp, ep, vp, bp, 0, SEARCH_MSG | SEARCH_TERM, FORWARD);
d324 4
d329 1
a329 1
search(sp, ep, vp, ptrn, len, flags, dir)
d331 1
a331 2
	EXF *ep;
	VICMDARG *vp;
d334 1
a334 2
	size_t len;
	enum direction dir;
d336 4
a339 19
	char *eptrn;

	if (ISMOTION(vp))
		flags |= SEARCH_EOL;

	for (;;) {
		switch (dir) {
		case BACKWARD:
			if (b_search(sp, ep,
			    &vp->m_start, &vp->m_stop, ptrn, &eptrn, &flags))
				return (1);
			break;
		case FORWARD:
			if (f_search(sp, ep,
			    &vp->m_start, &vp->m_stop, ptrn, &eptrn, &flags))
				return (1);
			break;
		case NOTSET:
			msgq(sp, M_ERR, "No previous search pattern");
d341 4
a344 51
		default:
			abort();
		}

		/*
		 * !!!
		 * Historically, vi permitted trailing <blank>'s, multiple
		 * search strings (separated by semi-colons) and full-blown
		 * z commands after / and ? search strings.  In the case of
		 * multiple search strings, leading <blank>'s on the second
		 * and subsequent strings was eaten as well.
		 *
		 * !!!
		 * However, the command "/STRING/;   " failed, apparently it
		 * confused the parser.  We're not *that* compatible.
		 *
		 * The N, n, and ^A commands also get to here, but they've
		 * set ptrn to NULL, len to 0, or the SEARCH_TERM flag, or
		 * some combination thereof.
		 */
		if (ptrn == NULL || len == 0)
			break;
		len -= eptrn - ptrn;
		for (; len > 0 && isblank(*eptrn); ++eptrn, --len);
		if (len == 0)
			break;

		switch (*eptrn) {
		case ';':
			for (++eptrn; --len > 0 && isblank(*eptrn); ++eptrn);
			ptrn = eptrn;
			switch (*eptrn) {
			case '/':
				dir = FORWARD;
				break;
			case '?':
				dir = BACKWARD;
				break;
			default:
				goto usage;
			}
			ptrn = eptrn;
			vp->m_start = vp->m_stop;
			continue;
		case 'z':
			if (term_push(sp, eptrn, len, CH_NOMAP | CH_QUOTED))
				return (1);
			goto ret;
		default:
usage:			msgq(sp, M_ERR,
			    "Characters after search string and/or delta");
d346 6
a351 1
		}
d354 4
a357 4
	/* Non-motion commands move to the end of the range. */
ret:	if (ISMOTION(vp)) {
		if (correct(sp, ep, vp, flags))
			return (1);
d364 1
a364 26
 * getptrn --
 *	Get the search pattern.
 */
static int
getptrn(sp, ep, prompt, ptrnp, lenp)
	SCR *sp;
	EXF *ep;
	ARG_CHAR_T prompt;
	char **ptrnp;
	size_t *lenp;
{
	TEXT *tp;

	if (sp->s_get(sp, ep, sp->tiqp, prompt,
	    TXT_BS | TXT_CR | TXT_ESCAPE | TXT_PROMPT) != INP_OK)
		return (1);

	/* Len is 0 if backspaced over the prompt, 1 if only CR entered. */
	tp = sp->tiqp->cqh_first;
	*ptrnp = tp->lb;
	*lenp = tp->len;
	return (0);
}

/*
 * correct --
d379 2
d382 2
a383 2
static int
correct(sp, ep, vp, flags)
d385 2
a386 3
	EXF *ep;
	VICMDARG *vp;
	u_int flags;
d388 1
a388 1
	enum direction dir;
d407 1
a407 1
		msgq(sp, M_BERR, "Search wrapped to original position");
d413 2
a414 2
	 * Searches become line mode operations if there was a delta
	 * specified to the search pattern.
d416 1
a416 1
	if (LF_ISSET(SEARCH_DELTA))
a429 1
		dir = BACKWARD;
d433 1
d439 2
a440 4
	 *	VC_D commands move to the end of the range.  VC_Y stays at
	 *	the start unless the end of the range is on a different line,
	 *	when it moves to the end of the range.  Ignore VC_C and
	 *	VC_DEF.
d443 7
a449 1
	 *	VC_D and VC_Y commands don't move.  Ignore VC_C and VC_DEF.
d451 2
a452 8
	if (dir == BACKWARD)
		if (F_ISSET(vp, VC_D) ||
		    F_ISSET(vp, VC_Y) && vp->m_start.lno != vp->m_stop.lno)
			vp->m_final = vp->m_start;
		else
			vp->m_final = vp->m_stop;
	else
		vp->m_final = vp->m_start;
d466 1
a466 2
		if (file_gline(sp, ep, --vp->m_stop.lno, &len) == NULL) {
			GETLINE_ERR(sp, vp->m_stop.lno);
a467 1
		}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
