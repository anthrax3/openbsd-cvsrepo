head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.12
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.22
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.20
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.16
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.34
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.30
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.28
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.26
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.24
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.22
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.20
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.18
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.16
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.14
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.5;
commitid	06bi6U3x4gFFf2G1;

1.5
date	2009.10.27.23.59.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.51;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@/*	$OpenBSD: v_left.c,v 1.5 2009/10/27 23:59:48 deraadt Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <limits.h>
#include <stdio.h>

#include "../common/common.h"
#include "vi.h"

/*
 * v_left -- [count]^H, [count]h
 *	Move left by columns.
 *
 * PUBLIC: int v_left(SCR *, VICMD *);
 */
int
v_left(SCR *sp, VICMD *vp)
{
	recno_t cnt;

	/*
	 * !!!
	 * The ^H and h commands always failed in the first column.
	 */
	if (vp->m_start.cno == 0) {
		v_sol(sp);
		return (1);
	}

	/* Find the end of the range. */
	cnt = F_ISSET(vp, VC_C1SET) ? vp->count : 1;
	if (vp->m_start.cno > cnt)
		vp->m_stop.cno = vp->m_start.cno - cnt;
	else
		vp->m_stop.cno = 0;

	/*
	 * All commands move to the end of the range.  Motion commands
	 * adjust the starting point to the character before the current
	 * one.
	 */
	if (ISMOTION(vp))
		--vp->m_start.cno;
	vp->m_final = vp->m_stop;
	return (0);
}

/*
 * v_cfirst -- [count]_
 *	Move to the first non-blank character in a line.
 *
 * PUBLIC: int v_cfirst(SCR *, VICMD *);
 */
int
v_cfirst(SCR *sp, VICMD *vp)
{
	recno_t cnt, lno;

	/*
	 * !!!
	 * If the _ is a motion component, it makes the command a line motion
	 * e.g. "d_" deletes the line.  It also means that the cursor doesn't
	 * move.
	 *
	 * The _ command never failed in the first column.
	 */
	if (ISMOTION(vp))
		F_SET(vp, VM_LMODE);
	/*
	 * !!!
	 * Historically a specified count makes _ move down count - 1
	 * rows, so, "3_" is the same as "2j_".
	 */
	cnt = F_ISSET(vp, VC_C1SET) ? vp->count : 1;
	if (cnt != 1) {
		--vp->count;
		return (v_down(sp, vp));
	}

	/*
	 * Move to the first non-blank.
	 *
	 * Can't just use RCM_SET_FNB, in case _ is used as the motion
	 * component of another command.
	 */
	vp->m_stop.cno = 0;
	if (nonblank(sp, vp->m_stop.lno, &vp->m_stop.cno))
		return (1);

	/*
	 * !!!
	 * The _ command has to fail if the file is empty and we're doing
	 * a delete.  If deleting line 1, and 0 is the first nonblank,
	 * make the check.
	 */
	if (vp->m_stop.lno == 1 &&
	    vp->m_stop.cno == 0 && ISCMD(vp->rkp, 'd')) {
		if (db_last(sp, &lno))
			return (1);
		if (lno == 0) {
			v_sol(sp);
			return (1);
		}
	}

	/*
	 * Delete and non-motion commands move to the end of the range,
	 * yank stays at the start.  Ignore others.
	 */
	vp->m_final =
	    ISMOTION(vp) && ISCMD(vp->rkp, 'y') ? vp->m_start : vp->m_stop;
	return (0);
}

/*
 * v_first -- ^
 *	Move to the first non-blank character in this line.
 *
 * PUBLIC: int v_first(SCR *, VICMD *);
 */
int
v_first(SCR *sp, VICMD *vp)
{
	/*
	 * !!!
	 * Yielding to none in our quest for compatibility with every
	 * historical blemish of vi, no matter how strange it might be,
	 * we permit the user to enter a count and then ignore it.
	 */

	/*
	 * Move to the first non-blank.
	 *
	 * Can't just use RCM_SET_FNB, in case ^ is used as the motion
	 * component of another command.
	 */
	vp->m_stop.cno = 0;
	if (nonblank(sp, vp->m_stop.lno, &vp->m_stop.cno))
		return (1);

	/*
	 * !!!
	 * The ^ command succeeded if used as a command when the cursor was
	 * on the first non-blank in the line, but failed if used as a motion
	 * component in the same situation.
	 */
	if (ISMOTION(vp) && vp->m_start.cno == vp->m_stop.cno) {
		v_sol(sp);
		return (1);
	}

	/*
	 * If moving right, non-motion commands move to the end of the range.
	 * Delete and yank stay at the start.  Motion commands adjust the
	 * ending point to the character before the current ending charcter.
	 *
	 * If moving left, all commands move to the end of the range.  Motion
	 * commands adjust the starting point to the character before the
	 * current starting character.
	 */
	if (vp->m_start.cno < vp->m_stop.cno)
		if (ISMOTION(vp)) {
			--vp->m_stop.cno;
			vp->m_final = vp->m_start;
		} else
			vp->m_final = vp->m_stop;
	else {
		if (ISMOTION(vp))
			--vp->m_start.cno;
		vp->m_final = vp->m_stop;
	}
	return (0);
}

/*
 * v_ncol -- [count]|
 *	Move to column count or the first column on this line.  If the
 *	requested column is past EOL, move to EOL.  The nasty part is
 *	that we have to know character column widths to make this work.
 *
 * PUBLIC: int v_ncol(SCR *, VICMD *);
 */
int
v_ncol(SCR *sp, VICMD *vp)
{
	if (F_ISSET(vp, VC_C1SET) && vp->count > 1) {
		--vp->count;
		vp->m_stop.cno =
		    vs_colpos(sp, vp->m_start.lno, (size_t)vp->count);
		/*
		 * !!!
		 * The | command succeeded if used as a command and the cursor
		 * didn't move, but failed if used as a motion component in the
		 * same situation.
		 */
		if (ISMOTION(vp) && vp->m_stop.cno == vp->m_start.cno) {
			v_nomove(sp);
			return (1);
		}
	} else {
		/*
		 * !!!
		 * The | command succeeded if used as a command in column 0
		 * without a count, but failed if used as a motion component
		 * in the same situation.
		 */
		if (ISMOTION(vp) && vp->m_start.cno == 0) {
			v_sol(sp);
			return (1);
		}
		vp->m_stop.cno = 0;
	}

	/*
	 * If moving right, non-motion commands move to the end of the range.
	 * Delete and yank stay at the start.  Motion commands adjust the
	 * ending point to the character before the current ending charcter.
	 *
	 * If moving left, all commands move to the end of the range.  Motion
	 * commands adjust the starting point to the character before the
	 * current starting character.
	 */
	if (vp->m_start.cno < vp->m_stop.cno)
		if (ISMOTION(vp)) {
			--vp->m_stop.cno;
			vp->m_final = vp->m_start;
		} else
			vp->m_final = vp->m_stop;
	else {
		if (ISMOTION(vp))
			--vp->m_start.cno;
		vp->m_final = vp->m_stop;
	}
	return (0);
}

/*
 * v_zero -- 0
 *	Move to the first column on this line.
 *
 * PUBLIC: int v_zero(SCR *, VICMD *);
 */
int
v_zero(SCR *sp, VICMD *vp)
{
	/*
	 * !!!
	 * The 0 command succeeded if used as a command in the first column
	 * but failed if used as a motion component in the same situation.
	 */
	if (ISMOTION(vp) && vp->m_start.cno == 0) {
		v_sol(sp);
		return (1);
	}

	/*
	 * All commands move to the end of the range.  Motion commands
	 * adjust the starting point to the character before the current
	 * one.
	 */
	vp->m_stop.cno = 0;
	if (ISMOTION(vp))
		--vp->m_start.cno;
	vp->m_final = vp->m_stop;
	return (0);
}
@


1.5
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: v_left.c,v 1.4 2002/02/16 21:27:58 millert Exp $	*/
d32 1
a32 3
v_left(sp, vp)
	SCR *sp;
	VICMD *vp;
d70 1
a70 3
v_cfirst(sp, vp)
	SCR *sp;
	VICMD *vp;
d137 1
a137 3
v_first(sp, vp)
	SCR *sp;
	VICMD *vp;
d199 1
a199 3
v_ncol(sp, vp)
	SCR *sp;
	VICMD *vp;
d259 1
a259 3
v_zero(sp, vp)
	SCR *sp;
	VICMD *vp;
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: v_left.c,v 1.3 2001/01/29 01:58:51 niklas Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)v_left.c	10.7 (Berkeley) 3/6/96";
#endif /* not lint */
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
 * PUBLIC: int v_left __P((SCR *, VICMD *));
d73 1
a73 1
 * PUBLIC: int v_cfirst __P((SCR *, VICMD *));
d142 1
a142 1
 * PUBLIC: int v_first __P((SCR *, VICMD *));
d206 1
a206 1
 * PUBLIC: int v_ncol __P((SCR *, VICMD *));
d268 1
a268 1
 * PUBLIC: int v_zero __P((SCR *, VICMD *));
@


1.2
log
@new vi
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)v_left.c	8.11 (Berkeley) 8/17/94";
a21 1
#include <signal.h>
a22 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d24 1
a25 1
#include "vcmd.h"
d30 2
d34 1
a34 1
v_left(sp, ep, vp)
d36 1
a36 2
	EXF *ep;
	VICMDARG *vp;
d57 3
a59 4
	 * VC_D and non-motion commands move to the end of the range,
	 * VC_Y stays at the start.  Ignore VC_C and VC_DEF.  Motion
	 * commands adjust the starting point to the character before
	 * the current one.
a60 1
	vp->m_final = F_ISSET(vp, VC_Y) ? vp->m_start : vp->m_stop;
d63 1
d70 2
d74 1
a74 1
v_cfirst(sp, ep, vp)
d76 1
a76 2
	EXF *ep;
	VICMDARG *vp;
d78 1
a78 1
	recno_t cnt;
d98 1
a98 1
		return (v_down(sp, ep, vp));
d108 1
a108 1
	if (nonblank(sp, ep, vp->m_stop.lno, &vp->m_stop.cno))
d112 18
a129 2
	 * VC_D and non-motion commands move to the end of the range,
	 * VC_Y stays at the start.  Ignore VC_C and VC_DEF.
d131 2
a132 1
	vp->m_final = F_ISSET(vp, VC_Y) ? vp->m_start : vp->m_stop;
d139 2
d143 1
a143 1
v_first(sp, ep, vp)
d145 1
a145 2
	EXF *ep;
	VICMDARG *vp;
d161 1
a161 1
	if (nonblank(sp, ep, vp->m_stop.lno, &vp->m_stop.cno))
d166 3
a168 3
	 * The ^ command succeeded if used as a command without a whitespace
	 * character preceding the cursor in the line, but failed if used as
	 * a motion component in the same situation.
d170 1
a170 1
	if (ISMOTION(vp) && vp->m_start.cno <= vp->m_stop.cno) {
d176 7
a182 4
	 * VC_D and non-motion commands move to the end of the range,
	 * VC_Y stays at the start.  Ignore VC_C and VC_DEF.  Motion
	 * commands adjust the starting point to the character before
	 * the current one.
d184 11
a194 3
	vp->m_final = F_ISSET(vp, VC_Y) ? vp->m_start : vp->m_stop;
	if (ISMOTION(vp))
		--vp->m_start.cno;
d203 2
d207 1
a207 1
v_ncol(sp, ep, vp)
d209 1
a209 2
	EXF *ep;
	VICMDARG *vp;
d214 1
a214 1
		    sp->s_colpos(sp, ep, vp->m_start.lno, (size_t)vp->count);
d241 6
a246 4
	 * VC_D and VC_Y stay at the start.  If moving left, non-motion and
	 * VC_D commands move to the end of the range.  VC_Y remains at the
	 * start.  Ignore VC_C and VC_DEF.  Motion left commands adjust the
	 * starting point to the character before the current one.
d249 5
a253 1
		vp->m_final = ISMOTION(vp) ? vp->m_start : vp->m_stop;
d255 2
a257 5
		if (ISMOTION(vp)) {
			if (F_ISSET(vp, VC_Y))
				vp->m_final = vp->m_start;
			--vp->m_start.cno;
		}
d265 2
d269 1
a269 1
v_zero(sp, ep, vp)
d271 1
a271 2
	EXF *ep;
	VICMDARG *vp;
d284 3
a286 4
	 * VC_D and non-motion commands move to the end of the range,
	 * VC_Y stays at the start.  Ignore VC_C and VC_DEF.  Motion
	 * commands adjust the starting point to the character before
	 * the current one.
a288 1
	vp->m_final = F_ISSET(vp, VC_Y) ? vp->m_start : vp->m_stop;
d291 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
