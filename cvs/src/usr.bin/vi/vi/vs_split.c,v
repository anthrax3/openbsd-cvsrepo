head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.8
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.6
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.15;
commitid	01nAnartGL7onLD3;

1.15
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.14;
commitid	ruCZ2IKF0FB0ebCr;

1.14
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.13;
commitid	adBvXLg05bJxz6yx;

1.13
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.12;
commitid	gtDERb7QyXwKGs62;

1.12
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.11;
commitid	06bi6U3x4gFFf2G1;

1.11
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.11.06.58.00;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.55;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.07.27.22.28.25;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.01.19.01;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.23.13.18.20;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.16.10;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.37.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: vs_split.c,v 1.14 2016/01/06 22:28:52 millert Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../common/common.h"
#include "vi.h"

static SCR *vs_getbg(SCR *, char *);

/*
 * vs_split --
 *	Create a new screen.
 *
 * PUBLIC: int vs_split(SCR *, SCR *, int);
 */
int
vs_split(SCR *sp, SCR *new, int ccl)
{
	GS *gp;
	SMAP *smp;
	size_t half;
	int issmallscreen, splitup;

	gp = sp->gp;

	/* Check to see if it's possible. */
	/* XXX: The IS_ONELINE fix will change this, too. */
	if (sp->rows < 4) {
		msgq(sp, M_ERR,
		    "Screen must be larger than %d lines to split", 4 - 1);
		return (1);
	}

	/* Wait for any messages in the screen. */
	vs_resolve(sp, NULL, 1);

	half = sp->rows / 2;
	if (ccl && half > 6)
		half = 6;

	/* Get a new screen map. */
	CALLOC(sp, _HMAP(new), SIZE_HMAP(sp), sizeof(SMAP));
	if (_HMAP(new) == NULL)
		return (1);
	_HMAP(new)->lno = sp->lno;
	_HMAP(new)->coff = 0;
	_HMAP(new)->soff = 1;

	/*
	 * Small screens: see vs_refresh.c section 6a.  Set a flag so
	 * we know to fix the screen up later.
	 */
	issmallscreen = IS_SMALL(sp);

	/* The columns in the screen don't change. */
	new->cols = sp->cols;

	/*
	 * Split the screen, and link the screens together.  If creating a
	 * screen to edit the colon command line or the cursor is in the top
	 * half of the current screen, the new screen goes under the current
	 * screen.  Else, it goes above the current screen.
	 *
	 * Recalculate current cursor position based on sp->lno, we're called
	 * with the cursor on the colon command line.  Then split the screen
	 * in half and update the shared information.
	 */
	splitup =
	    !ccl && (vs_sm_cursor(sp, &smp) ? 0 : (smp - HMAP) + 1) >= half;
	if (splitup) {				/* Old is bottom half. */
		new->rows = sp->rows - half;	/* New. */
		new->woff = sp->woff;
		sp->rows = half;		/* Old. */
		sp->woff += new->rows;
						/* Link in before old. */
		TAILQ_INSERT_BEFORE(sp, new, q);

		/*
		 * If the parent is the bottom half of the screen, shift
		 * the map down to match on-screen text.
		 */
		memmove(_HMAP(sp), _HMAP(sp) + new->rows,
		    (sp->t_maxrows - new->rows) * sizeof(SMAP));
	} else {				/* Old is top half. */
		new->rows = half;		/* New. */
		sp->rows -= half;		/* Old. */
		new->woff = sp->woff + sp->rows;
						/* Link in after old. */
		TAILQ_INSERT_AFTER(&gp->dq, sp, new, q);
	}

	/* Adjust maximum text count. */
	sp->t_maxrows = IS_ONELINE(sp) ? 1 : sp->rows - 1;
	new->t_maxrows = IS_ONELINE(new) ? 1 : new->rows - 1;

	/*
	 * Small screens: see vs_refresh.c, section 6a.
	 *
	 * The child may have different screen options sizes than the parent,
	 * so use them.  Guarantee that text counts aren't larger than the
	 * new screen sizes.
	 */
	if (issmallscreen) {
		/* Fix the text line count for the parent. */
		if (splitup)
			sp->t_rows -= new->rows;

		/* Fix the parent screen. */
		if (sp->t_rows > sp->t_maxrows)
			sp->t_rows = sp->t_maxrows;
		if (sp->t_minrows > sp->t_maxrows)
			sp->t_minrows = sp->t_maxrows;

		/* Fix the child screen. */
		new->t_minrows = new->t_rows = O_VAL(sp, O_WINDOW);
		if (new->t_rows > new->t_maxrows)
			new->t_rows = new->t_maxrows;
		if (new->t_minrows > new->t_maxrows)
			new->t_minrows = new->t_maxrows;
	} else {
		sp->t_minrows = sp->t_rows = IS_ONELINE(sp) ? 1 : sp->rows - 1;

		/*
		 * The new screen may be a small screen, even if the parent
		 * was not.  Don't complain if O_WINDOW is too large, we're
		 * splitting the screen so the screen is much smaller than
		 * normal.
		 */
		new->t_minrows = new->t_rows = O_VAL(sp, O_WINDOW);
		if (new->t_rows > new->rows - 1)
			new->t_minrows = new->t_rows =
			    IS_ONELINE(new) ? 1 : new->rows - 1;
	}

	/* Adjust the ends of the new and old maps. */
	_TMAP(sp) = IS_ONELINE(sp) ?
	    _HMAP(sp) : _HMAP(sp) + (sp->t_rows - 1);
	_TMAP(new) = IS_ONELINE(new) ?
	    _HMAP(new) : _HMAP(new) + (new->t_rows - 1);

	/* Reset the length of the default scroll. */
	if ((sp->defscroll = sp->t_maxrows / 2) == 0)
		sp->defscroll = 1;
	if ((new->defscroll = new->t_maxrows / 2) == 0)
		new->defscroll = 1;

	/*
	 * Initialize the screen flags:
	 *
	 * If we're in vi mode in one screen, we don't have to reinitialize.
	 * This isn't just a cosmetic fix.  The path goes like this:
	 *
	 *	return into vi(), SC_SSWITCH set
	 *	call vs_refresh() with SC_STATUS set
	 *	call vs_resolve to display the status message
	 *	call vs_refresh() because the SC_SCR_VI bit isn't set
	 *
	 * Things go downhill at this point.
	 *
	 * Draw the new screen from scratch, and add a status line.
	 */
	F_SET(new,
	    SC_SCR_REFORMAT | SC_STATUS |
	    F_ISSET(sp, SC_EX | SC_VI | SC_SCR_VI | SC_SCR_EX));
	return (0);
}

/*
 * vs_discard --
 *	Discard the screen, folding the real-estate into a related screen,
 *	if one exists, and return that screen.
 *
 * PUBLIC: int vs_discard(SCR *, SCR **);
 */
int
vs_discard(SCR *sp, SCR **spp)
{
	SCR *nsp;
	dir_t dir;

	/*
	 * Save the old screen's cursor information.
	 *
	 * XXX
	 * If called after file_end(), and the underlying file was a tmp
	 * file, it may have gone away.
	 */
	if (sp->frp != NULL) {
		sp->frp->lno = sp->lno;
		sp->frp->cno = sp->cno;
		F_SET(sp->frp, FR_CURSORSET);
	}

	/*
	 * Add into a previous screen and then into a subsequent screen, as
	 * they're the closest to the current screen.  If that doesn't work,
	 * there was no screen to join.
	 */
	if ((nsp = TAILQ_PREV(sp, _dqh, q))) {
		nsp->rows += sp->rows;
		sp = nsp;
		dir = FORWARD;
	} else if ((nsp = TAILQ_NEXT(sp, q))) {
		nsp->woff = sp->woff;
		nsp->rows += sp->rows;
		sp = nsp;
		dir = BACKWARD;
	} else {
		sp = NULL;
		dir = 0;	/* unused */
	}

	if (spp != NULL)
		*spp = sp;
	if (sp == NULL)
		return (0);
		
	/*
	 * Make no effort to clean up the discarded screen's information.  If
	 * it's not exiting, we'll do the work when the user redisplays it.
	 *
	 * Small screens: see vs_refresh.c section 6a.  Adjust text line info,
	 * unless it's a small screen.
	 *
	 * Reset the length of the default scroll.
	 */
	if (!IS_SMALL(sp))
		sp->t_rows = sp->t_minrows = sp->rows - 1;
	sp->t_maxrows = sp->rows - 1;
	sp->defscroll = sp->t_maxrows / 2;
	*(HMAP + (sp->t_rows - 1)) = *TMAP;
	TMAP = HMAP + (sp->t_rows - 1);

	/*
	 * Draw the new screen from scratch, and add a status line.
	 *
	 * XXX
	 * We could play games with the map, if this were ever to be a
	 * performance problem, but I wrote the code a few times and it
	 * was never clean or easy.
	 */
	switch (dir) {
	case FORWARD:
		vs_sm_fill(sp, OOBLNO, P_TOP);
		break;
	case BACKWARD:
		vs_sm_fill(sp, OOBLNO, P_BOTTOM);
		break;
	default:
		abort();
	}

	F_SET(sp, SC_STATUS);
	return (0);
}

/*
 * vs_fg --
 *	Background the current screen, and foreground a new one.
 *
 * PUBLIC: int vs_fg(SCR *, SCR **, CHAR_T *, int);
 */
int
vs_fg(SCR *sp, SCR **nspp, CHAR_T *name, int newscreen)
{
	GS *gp;
	SCR *nsp;

	gp = sp->gp;

	if (newscreen)
		/* Get the specified background screen. */
		nsp = vs_getbg(sp, name);
	else
		/* Swap screens. */
		if (vs_swap(sp, &nsp, name))
			return (1);

	if ((*nspp = nsp) == NULL) {
		msgq_str(sp, M_ERR, name,
		    name == NULL ?
		    "There are no background screens" :
		    "There's no background screen editing a file named %s");
		return (1);
	}

	if (newscreen) {
		/* Remove the new screen from the background queue. */
		TAILQ_REMOVE(&gp->hq, nsp, q);

		/* Split the screen; if we fail, hook the screen back in. */
		if (vs_split(sp, nsp, 0)) {
			TAILQ_INSERT_TAIL(&gp->hq, nsp, q);
			return (1);
		}
	} else {
		/* Move the old screen to the background queue. */
		TAILQ_REMOVE(&gp->dq, sp, q);
		TAILQ_INSERT_TAIL(&gp->hq, sp, q);
	}
	return (0);
}

/*
 * vs_bg --
 *	Background the screen, and switch to the next one.
 *
 * PUBLIC: int vs_bg(SCR *);
 */
int
vs_bg(SCR *sp)
{
	GS *gp;
	SCR *nsp;

	gp = sp->gp;

	/* Try and join with another screen. */
	if (vs_discard(sp, &nsp))
		return (1);
	if (nsp == NULL) {
		msgq(sp, M_ERR,
		    "You may not background your only displayed screen");
		return (1);
	}

	/* Move the old screen to the background queue. */
	TAILQ_REMOVE(&gp->dq, sp, q);
	TAILQ_INSERT_TAIL(&gp->hq, sp, q);

	/* Toss the screen map. */
	free(_HMAP(sp));
	_HMAP(sp) = NULL;

	/* Switch screens. */
	sp->nextdisp = nsp;
	F_SET(sp, SC_SSWITCH);

	return (0);
}

/*
 * vs_swap --
 *	Swap the current screen with a backgrounded one.
 *
 * PUBLIC: int vs_swap(SCR *, SCR **, char *);
 */
int
vs_swap(SCR *sp, SCR **nspp, char *name)
{
	GS *gp;
	SCR *nsp;

	gp = sp->gp;

	/* Get the specified background screen. */
	if ((*nspp = nsp = vs_getbg(sp, name)) == NULL)
		return (0);

	/*
	 * Save the old screen's cursor information.
	 *
	 * XXX
	 * If called after file_end(), and the underlying file was a tmp
	 * file, it may have gone away.
	 */
	if (sp->frp != NULL) {
		sp->frp->lno = sp->lno;
		sp->frp->cno = sp->cno;
		F_SET(sp->frp, FR_CURSORSET);
	}

	/* Switch screens. */
	sp->nextdisp = nsp;
	F_SET(sp, SC_SSWITCH);

	/* Initialize terminal information. */
	VIP(nsp)->srows = VIP(sp)->srows;

	/* Initialize screen information. */
	nsp->cols = sp->cols;
	nsp->rows = sp->rows;	/* XXX: Only place in vi that sets rows. */
	nsp->woff = sp->woff;

	/*
	 * Small screens: see vs_refresh.c, section 6a.
	 *
	 * The new screens may have different screen options sizes than the
	 * old one, so use them.  Make sure that text counts aren't larger
	 * than the new screen sizes.
	 */
	if (IS_SMALL(nsp)) {
		nsp->t_minrows = nsp->t_rows = O_VAL(nsp, O_WINDOW);
		if (nsp->t_rows > sp->t_maxrows)
			nsp->t_rows = nsp->t_maxrows;
		if (nsp->t_minrows > sp->t_maxrows)
			nsp->t_minrows = nsp->t_maxrows;
	} else
		nsp->t_rows = nsp->t_maxrows = nsp->t_minrows = nsp->rows - 1;

	/* Reset the length of the default scroll. */
	nsp->defscroll = nsp->t_maxrows / 2;

	/* Allocate a new screen map. */
	CALLOC_RET(nsp, _HMAP(nsp), SIZE_HMAP(nsp), sizeof(SMAP));
	_TMAP(nsp) = _HMAP(nsp) + (nsp->t_rows - 1);

	/* Fill the map. */
	if (vs_sm_fill(nsp, nsp->lno, P_FILL))
		return (1);

	/*
	 * The new screen replaces the old screen in the parent/child list.
	 * We insert the new screen after the old one.  If we're exiting,
	 * the exit will delete the old one, if we're foregrounding, the fg
	 * code will move the old one to the background queue.
	 */
	TAILQ_REMOVE(&gp->hq, nsp, q);
	TAILQ_INSERT_AFTER(&gp->dq, sp, nsp, q);

	/*
	 * Don't change the screen's cursor information other than to
	 * note that the cursor is wrong.
	 */
	F_SET(VIP(nsp), VIP_CUR_INVALID);

	/* Draw the new screen from scratch, and add a status line. */
	F_SET(nsp, SC_SCR_REDRAW | SC_STATUS);
	return (0);
}

/*
 * vs_resize --
 *	Change the absolute size of the current screen.
 *
 * PUBLIC: int vs_resize(SCR *, long, adj_t);
 */
int
vs_resize(SCR *sp, long count, adj_t adj)
{
	GS *gp;
	SCR *g, *s;
	size_t g_off, s_off;

	gp = sp->gp;

	/*
	 * Figure out which screens will grow, which will shrink, and
	 * make sure it's possible.
	 */
	if (count == 0)
		return (0);
	if (adj == A_SET) {
		if (sp->t_maxrows == count)
			return (0);
		if (sp->t_maxrows > count) {
			adj = A_DECREASE;
			count = sp->t_maxrows - count;
		} else {
			adj = A_INCREASE;
			count = count - sp->t_maxrows;
		}
	}

	g_off = s_off = 0;
	if (adj == A_DECREASE) {
		if (count < 0)
			count = -count;
		s = sp;
		if (s->t_maxrows < MINIMUM_SCREEN_ROWS + count)
			goto toosmall;
		if ((g = TAILQ_PREV(sp, _dqh, q)) == NULL) {
			if ((g = TAILQ_NEXT(sp, q)) == NULL)
				goto toobig;
			g_off = -count;
		} else
			s_off = count;
	} else {
		g = sp;
		if ((s = TAILQ_NEXT(sp, q)))
			if (s->t_maxrows < MINIMUM_SCREEN_ROWS + count)
				s = NULL;
			else
				s_off = count;
		else
			s = NULL;
		if (s == NULL) {
			if ((s = TAILQ_PREV(sp, _dqh, q)) == NULL) {
toobig:				msgq(sp, M_BERR, adj == A_DECREASE ?
				    "The screen cannot shrink" :
				    "The screen cannot grow");
				return (1);
			}
			if (s->t_maxrows < MINIMUM_SCREEN_ROWS + count) {
toosmall:			msgq(sp, M_BERR,
				    "The screen can only shrink to %d rows",
				    MINIMUM_SCREEN_ROWS);
				return (1);
			}
			g_off = -count;
		}
	}

	/*
	 * Fix up the screens; we could optimize the reformatting of the
	 * screen, but this isn't likely to be a common enough operation
	 * to make it worthwhile.
	 */
	s->rows += -count;
	s->woff += s_off;
	g->rows += count;
	g->woff += g_off;

	g->t_rows += count;
	if (g->t_minrows == g->t_maxrows)
		g->t_minrows += count;
	g->t_maxrows += count;
	_TMAP(g) += count;
	F_SET(g, SC_SCR_REFORMAT | SC_STATUS);

	s->t_rows -= count;
	s->t_maxrows -= count;
	if (s->t_minrows > s->t_maxrows)
		s->t_minrows = s->t_maxrows;
	_TMAP(s) -= count;
	F_SET(s, SC_SCR_REFORMAT | SC_STATUS);

	return (0);
}

/*
 * vs_getbg --
 *	Get the specified background screen, or, if name is NULL, the first
 *	background screen.
 */
static SCR *
vs_getbg(SCR *sp, char *name)
{
	GS *gp;
	SCR *nsp;
	char *p;

	gp = sp->gp;

	/* If name is NULL, return the first background screen on the list. */
	if (name == NULL)
		return (TAILQ_FIRST(&gp->hq));

	/* Search for a full match. */
	TAILQ_FOREACH(nsp, &gp->hq, q) {
		if (!strcmp(nsp->frp->name, name))
			return(nsp);
	}

	/* Search for a last-component match. */
	TAILQ_FOREACH(nsp, &gp->hq, q) {
		if ((p = strrchr(nsp->frp->name, '/')) == NULL)
			p = nsp->frp->name;
		else
			++p;
		if (!strcmp(p, name))
			return(nsp);
	}

	return (NULL);
}
@


1.15
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d281 1
a281 1
 * PUBLIC: int vs_fg(SCR *, SCR **, char *, int);
d284 1
a284 1
vs_fg(SCR *sp, SCR **nspp, char *name, int newscreen)
@


1.14
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_split.c,v 1.13 2015/12/07 20:39:19 mmcc Exp $	*/
d281 1
a281 1
 * PUBLIC: int vs_fg(SCR *, SCR **, CHAR_T *, int);
d284 1
a284 1
vs_fg(SCR *sp, SCR **nspp, CHAR_T *name, int newscreen)
@


1.13
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_split.c,v 1.12 2014/11/12 04:28:41 bentley Exp $	*/
d50 1
a50 1
		    "222|Screen must be larger than %d lines to split", 4 - 1);
d302 2
a303 2
		    "223|There are no background screens" :
		    "224|There's no background screen editing a file named %s");
d343 1
a343 1
		    "225|You may not background your only displayed screen");
d510 2
a511 2
				    "227|The screen cannot shrink" :
				    "228|The screen cannot grow");
d516 1
a516 1
				    "226|The screen can only shrink to %d rows",
@


1.12
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_split.c,v 1.11 2013/11/28 22:12:40 krw Exp $	*/
d62 1
a62 1
	CALLOC(sp, _HMAP(new), SMAP *, SIZE_HMAP(sp), sizeof(SMAP));
d425 1
a425 1
	CALLOC_RET(nsp, _HMAP(nsp), SMAP *, SIZE_HMAP(nsp), sizeof(SMAP));
@


1.11
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_split.c,v 1.10 2009/10/27 23:59:49 deraadt Exp $	*/
d37 1
a37 3
vs_split(sp, new, ccl)
	SCR *sp, *new;
	int ccl;		/* Colon-command line split. */
d196 1
a196 2
vs_discard(sp, spp)
	SCR *sp, **spp;
d284 1
a284 4
vs_fg(sp, nspp, name, newscreen)
	SCR *sp, **nspp;
	CHAR_T *name;
	int newscreen;
d331 1
a331 2
vs_bg(sp)
	SCR *sp;
d369 1
a369 3
vs_swap(sp, nspp, name)
	SCR *sp, **nspp;
	char *name;
d459 1
a459 4
vs_resize(sp, count, adj)
	SCR *sp;
	long count;
	adj_t adj;
d557 1
a557 3
vs_getbg(sp, name)
	SCR *sp;
	char *name;
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_split.c,v 1.9 2006/03/11 06:58:00 ray Exp $	*/
d98 1
a98 1
		CIRCLEQ_INSERT_BEFORE(&gp->dq, sp, new, q);
d111 1
a111 1
		CIRCLEQ_INSERT_AFTER(&gp->dq, sp, new, q);
d222 1
a222 1
	if ((nsp = CIRCLEQ_PREV(sp, q)) != CIRCLEQ_END(&sp->gp->dq)) {
d226 1
a226 1
	} else if ((nsp = CIRCLEQ_NEXT(sp, q)) != CIRCLEQ_END(&sp->gp->dq)) {
d315 1
a315 1
		CIRCLEQ_REMOVE(&gp->hq, nsp, q);
d319 1
a319 1
			CIRCLEQ_INSERT_TAIL(&gp->hq, nsp, q);
d324 2
a325 2
		CIRCLEQ_REMOVE(&gp->dq, sp, q);
		CIRCLEQ_INSERT_TAIL(&gp->hq, sp, q);
d355 2
a356 2
	CIRCLEQ_REMOVE(&gp->dq, sp, q);
	CIRCLEQ_INSERT_TAIL(&gp->hq, sp, q);
d447 2
a448 2
	CIRCLEQ_REMOVE(&gp->hq, nsp, q);
	CIRCLEQ_INSERT_AFTER(&gp->dq, sp, nsp, q);
d504 2
a505 2
		if ((g = CIRCLEQ_PREV(sp, q)) == CIRCLEQ_END(&gp->dq)) {
			if ((g = CIRCLEQ_NEXT(sp, q)) == CIRCLEQ_END(&gp->dq))
d512 1
a512 1
		if ((s = CIRCLEQ_NEXT(sp, q)) != CIRCLEQ_END(&gp->dq))
d520 1
a520 1
			if ((s = CIRCLEQ_PREV(sp, q)) == CIRCLEQ_END(&gp->dq)) {
d580 2
a581 4
	if (name == NULL) {
		nsp = CIRCLEQ_FIRST(&gp->hq);
		return (nsp == (void *)&gp->hq ? NULL : nsp);
	}
d584 1
a584 1
	CIRCLEQ_FOREACH(nsp, &gp->hq, q)
d586 2
a587 3
			break;
	if (nsp != (void *)&gp->hq)
		return (nsp);
d590 1
a590 1
	CIRCLEQ_FOREACH(nsp, &gp->hq, q) {
d596 1
a596 1
			break;
a597 2
	if (nsp != (void *)&gp->hq)
		return (nsp);
@


1.9
log
@Silence 39 warnings.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_split.c,v 1.8 2005/10/17 19:12:16 otto Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)vs_split.c	10.31 (Berkeley) 10/13/96";
#endif /* not lint */
@


1.8
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_split.c,v 1.7 2002/02/16 21:27:58 millert Exp $	*/
d235 1
a235 1
	} else
d237 2
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs_split.c,v 1.6 2001/01/29 01:58:55 niklas Exp $	*/
d226 1
a226 1
	if ((nsp = sp->q.cqe_prev) != (void *)&sp->gp->dq) {
d230 1
a230 1
	} else if ((nsp = sp->q.cqe_next) != (void *)&sp->gp->dq) {
d506 2
a507 2
		if ((g = sp->q.cqe_prev) == (void *)&gp->dq) {
			if ((g = sp->q.cqe_next) == (void *)&gp->dq)
d514 1
a514 1
		if ((s = sp->q.cqe_next) != (void *)&gp->dq)
d522 1
a522 1
			if ((s = sp->q.cqe_prev) == (void *)&gp->dq) {
d583 1
a583 1
		nsp = gp->hq.cqh_first;
d588 1
a588 2
	for (nsp = gp->hq.cqh_first;
	    nsp != (void *)&gp->hq; nsp = nsp->q.cqe_next)
d595 1
a595 2
	for (nsp = gp->hq.cqh_first;
	    nsp != (void *)&gp->hq; nsp = nsp->q.cqe_next) {
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
static SCR *vs_getbg __P((SCR *, char *));
d38 1
a38 1
 * PUBLIC: int vs_split __P((SCR *, SCR *, int));
d199 1
a199 1
 * PUBLIC: int vs_discard __P((SCR *, SCR **));
d286 1
a286 1
 * PUBLIC: int vs_fg __P((SCR *, SCR **, CHAR_T *, int));
d336 1
a336 1
 * PUBLIC: int vs_bg __P((SCR *));
d375 1
a375 1
 * PUBLIC: int vs_swap __P((SCR *, SCR **, char *));
d467 1
a467 1
 * PUBLIC: int vs_resize __P((SCR *, long, adj_t));
@


1.5
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.4
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_split.c	10.30 (Berkeley) 9/20/96";
d59 1
a59 1
	vs_resolve(sp, 1);
@


1.3
log
@nvi 1.75
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_split.c	10.29 (Berkeley) 8/19/96";
d51 1
d92 2
a93 1
	splitup = !ccl && (vs_sm_cursor(sp, &smp) ? 0 : smp - HMAP) > half;
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_split.c	10.28 (Berkeley) 6/30/96";
d169 18
a186 3
	/* Draw the new screen from scratch, and add a status line. */
	F_SET(new, SC_SCR_REFORMAT | SC_STATUS);

@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vs_split.c	10.24 (Berkeley) 5/4/96";
d30 2
d56 4
d267 1
a267 1
 * PUBLIC: int vs_fg __P((SCR *, CHAR_T *));
d270 2
a271 2
vs_fg(csp, name)
	SCR *csp;
d273 1
d276 11
a286 1
	SCR *sp;
d288 2
a289 4
	if (vs_swap(csp, &sp, name))
		return (1);
	if (sp == NULL) {
		msgq_str(csp, M_ERR, name,
d296 14
a309 5
	/* Move the old screen to the hidden queue. */
	gp = csp->gp;
	CIRCLEQ_REMOVE(&gp->dq, csp, q);
	CIRCLEQ_INSERT_TAIL(&gp->hq, csp, q);

d320 2
a321 2
vs_bg(csp)
	SCR *csp;
d324 3
a326 1
	SCR *sp;
d329 1
a329 1
	if (vs_discard(csp, &sp))
d331 2
a332 2
	if (sp == NULL) {
		msgq(csp, M_ERR,
d337 3
a339 4
	/* Move the old screen to the hidden queue. */
	gp = csp->gp;
	CIRCLEQ_REMOVE(&gp->dq, csp, q);
	CIRCLEQ_INSERT_TAIL(&gp->hq, csp, q);
d342 2
a343 2
	free(_HMAP(csp));
	_HMAP(csp) = NULL;
d346 2
a347 2
	csp->nextdisp = sp;
	F_SET(csp, SC_SSWITCH);
d354 1
a354 1
 *	Swap the current screen with a hidden one.
d359 2
a360 2
vs_swap(csp, nsp, name)
	SCR *csp, **nsp;
d364 3
a366 2
	SCR *sp;
	int issmallscreen;
d368 2
a369 8
	/* Find the screen, or, if name is NULL, the first screen. */
	gp = csp->gp;
	for (sp = gp->hq.cqh_first;
	    sp != (void *)&gp->hq; sp = sp->q.cqe_next)
		if (name == NULL || !strcmp(sp->frp->name, name))
			break;
	if (sp == (void *)&gp->hq) {
		*nsp = NULL;
a370 2
	}
	*nsp = sp;
d379 4
a382 4
	if (csp->frp != NULL) {
		csp->frp->lno = csp->lno;
		csp->frp->cno = csp->cno;
		F_SET(csp->frp, FR_CURSORSET);
d386 2
a387 2
	csp->nextdisp = sp;
	F_SET(csp, SC_SSWITCH);
d390 1
a390 3
	VIP(sp)->srows = VIP(csp)->srows;

	issmallscreen = IS_SMALL(sp);
d393 3
a395 3
	sp->cols = csp->cols;
	sp->rows = csp->rows;	/* XXX: Only place in vi that sets rows. */
	sp->woff = csp->woff;
d404 6
a409 6
	if (issmallscreen) {
		sp->t_minrows = sp->t_rows = O_VAL(sp, O_WINDOW);
		if (sp->t_rows > csp->t_maxrows)
			sp->t_rows = sp->t_maxrows;
		if (sp->t_minrows > csp->t_maxrows)
			sp->t_minrows = sp->t_maxrows;
d411 1
a411 1
		sp->t_rows = sp->t_maxrows = sp->t_minrows = sp->rows - 1;
d414 1
a414 1
	sp->defscroll = sp->t_maxrows / 2;
d417 2
a418 2
	CALLOC_RET(sp, HMAP, SMAP *, SIZE_HMAP(sp), sizeof(SMAP));
	TMAP = HMAP + (sp->t_rows - 1);
d421 1
a421 1
	if (vs_sm_fill(sp, sp->lno, P_FILL))
d428 1
a428 1
	 * code will move the old one to the hidden queue.
d430 2
a431 2
	CIRCLEQ_REMOVE(&gp->hq, sp, q);
	CIRCLEQ_INSERT_AFTER(&gp->dq, csp, sp, q);
d437 1
a437 1
	F_SET(VIP(sp), VIP_CUR_INVALID);
d440 1
a440 1
	F_SET(sp, SC_SCR_REDRAW | SC_STATUS);
d544 46
@
