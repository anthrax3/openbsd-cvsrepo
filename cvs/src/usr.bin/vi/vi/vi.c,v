head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.4
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.18
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.14
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.12
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.10
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.8
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2017.04.18.01.45.35;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Pd2TRHz7UBFr9JGt;

1.20
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.19;
commitid	01nAnartGL7onLD3;

1.19
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.18;
commitid	ruCZ2IKF0FB0ebCr;

1.18
date	2016.01.20.08.43.27;	author bentley;	state Exp;
branches;
next	1.17;
commitid	etzsUqpfZbRGvPEg;

1.17
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.16;
commitid	adBvXLg05bJxz6yx;

1.16
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	gtDERb7QyXwKGs62;

1.15
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.14;
commitid	06bi6U3x4gFFf2G1;

1.14
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.48;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.08.05.22.25;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.29.01.58.54;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.07.27.22.28.23;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.10.16.01.18.54;	author michaels;	state Exp;
branches;
next	1.5;

1.5
date	96.08.20.22.56.12;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.47;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.16.07;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.37.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@free(NULL) is ok so use it; from Michael W. Bombardieri
@
text
@/*	$OpenBSD: vi.c,v 1.20 2016/05/27 09:18:12 martijn Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"
#include "vi.h"

typedef enum {
	GC_ERR, GC_ERR_NOFLUSH, GC_EVENT, GC_FATAL, GC_INTERRUPT, GC_OK
} gcret_t;

static VIKEYS const
	       *v_alias(SCR *, VICMD *, VIKEYS const *);
static gcret_t	v_cmd(SCR *, VICMD *, VICMD *, VICMD *, int *, int *);
static int	v_count(SCR *, CHAR_T, u_long *);
static void	v_dtoh(SCR *);
static int	v_init(SCR *);
static gcret_t	v_key(SCR *, int, EVENT *, u_int32_t);
static int	v_keyword(SCR *);
static int	v_motion(SCR *, VICMD *, VICMD *, int *);

#if defined(DEBUG) && defined(COMLOG)
static void	v_comlog(SCR *, VICMD *);
#endif

/*
 * Side-effect:
 *	The dot structure can be set by the underlying vi functions,
 *	see v_Put() and v_put().
 */
#define	DOT		(&VIP(sp)->sdot)
#define	DOTMOTION	(&VIP(sp)->sdotmotion)

/*
 * vi --
 * 	Main vi command loop.
 *
 * PUBLIC: int vi(SCR **);
 */
int
vi(SCR **spp)
{
	GS *gp;
	MARK abs;
	SCR *next, *sp;
	VICMD cmd, *vp;
	VI_PRIVATE *vip;
	int comcount, mapped, rval;

	/* Get the first screen. */
	sp = *spp;
	gp = sp->gp;

	/* Initialize the command structure. */
	vp = &cmd;
	memset(vp, 0, sizeof(VICMD));

	/* Reset strange attraction. */
	F_SET(vp, VM_RCM_SET);

	/* Initialize the vi screen. */
	if (v_init(sp))
		return (1);

	/* Set the focus. */
	(void)sp->gp->scr_rename(sp, sp->frp->name, 1);

	for (vip = VIP(sp), rval = 0;;) {
		/* Resolve messages. */
		if (!MAPPED_KEYS_WAITING(sp) && vs_resolve(sp, NULL, 0))
			goto ret;

		/*
		 * If not skipping a refresh, return to command mode and
		 * refresh the screen.
		 */
		if (F_ISSET(vip, VIP_S_REFRESH))
			F_CLR(vip, VIP_S_REFRESH);
		else {
			sp->showmode = SM_COMMAND;
			if (vs_refresh(sp, 0))
				goto ret;
		}

		/* Set the new favorite position. */
		if (F_ISSET(vp, VM_RCM_SET | VM_RCM_SETFNB | VM_RCM_SETNNB)) {
			F_CLR(vip, VIP_RCM_LAST);
			(void)vs_column(sp, &sp->rcm);
		}

		/*
		 * If not currently in a map, log the cursor position,
		 * and set a flag so that this command can become the
		 * DOT command.
		 */
		if (MAPPED_KEYS_WAITING(sp))
			mapped = 1;
		else {
			if (log_cursor(sp))
				goto err;
			mapped = 0;
		}

		/*
		 * There may be an ex command waiting, and we returned here
		 * only because we exited a screen or file.  In this case,
		 * we simply go back into the ex parser.
		 */
		if (EXCMD_RUNNING(gp)) {
			vp->kp = &vikeys[':'];
			goto ex_continue;
		}

		/* Refresh the command structure. */
		memset(vp, 0, sizeof(VICMD));

		/*
		 * We get a command, which may or may not have an associated
		 * motion.  If it does, we get it too, calling its underlying
		 * function to get the resulting mark.  We then call the
		 * command setting the cursor to the resulting mark.
		 *
		 * !!!
		 * Vi historically flushed mapped characters on error, but
		 * entering extra <escape> characters at the beginning of
		 * a map wasn't considered an error -- in fact, users would
		 * put leading <escape> characters in maps to clean up vi
		 * state before the map was interpreted.  Beauty!
		 */
		switch (v_cmd(sp, DOT, vp, NULL, &comcount, &mapped)) {
		case GC_ERR:
			goto err;
		case GC_ERR_NOFLUSH:
			goto gc_err_noflush;
		case GC_EVENT:
			if (v_event_exec(sp, vp))
				goto err;
			goto gc_event;
		case GC_FATAL:
			goto ret;
		case GC_INTERRUPT:
			goto intr;
		case GC_OK:
			break;
		}

		/* Check for security setting. */
		if (F_ISSET(vp->kp, V_SECURE) && O_ISSET(sp, O_SECURE)) {
			ex_emsg(sp, KEY_NAME(sp, vp->key), EXM_SECURE);
			goto err;
		}

		/*
		 * Historical practice: if a dot command gets a new count,
		 * any motion component goes away, i.e. "d3w2." deletes a
		 * total of 5 words.
		 */
		if (F_ISSET(vp, VC_ISDOT) && comcount)
			DOTMOTION->count = 1;

		/* Copy the key flags into the local structure. */
		F_SET(vp, vp->kp->flags);

		/* Prepare to set the previous context. */
		if (F_ISSET(vp, V_ABS | V_ABS_C | V_ABS_L)) {
			abs.lno = sp->lno;
			abs.cno = sp->cno;
		}

		/*
		 * Set the three cursor locations to the current cursor.  The
		 * underlying routines don't bother if the cursor doesn't move.
		 * This also handles line commands (e.g. Y) defaulting to the
		 * current line.
		 */
		vp->m_start.lno = vp->m_stop.lno = vp->m_final.lno = sp->lno;
		vp->m_start.cno = vp->m_stop.cno = vp->m_final.cno = sp->cno;

		/*
		 * Do any required motion; v_motion sets the from MARK and the
		 * line mode flag, as well as the VM_RCM flags.
		 */
		if (F_ISSET(vp, V_MOTION) &&
		    v_motion(sp, DOTMOTION, vp, &mapped)) {
			if (INTERRUPTED(sp))
				goto intr;
			goto err;
		}

		/*
		 * If a count is set and the command is line oriented, set the
		 * to MARK here relative to the cursor/from MARK.  This is for
		 * commands that take both counts and motions, i.e. "4yy" and
		 * "y%".  As there's no way the command can know which the user
		 * did, we have to do it here.  (There are commands that are
		 * line oriented and that take counts ("#G", "#H"), for which
		 * this calculation is either completely meaningless or wrong.
		 * Each command must validate the value for itself.
		 */
		if (F_ISSET(vp, VC_C1SET) && F_ISSET(vp, VM_LMODE))
			vp->m_stop.lno += vp->count - 1;

		/* Increment the command count. */
		++sp->ccnt;

#if defined(DEBUG) && defined(COMLOG)
		v_comlog(sp, vp);
#endif
		/* Call the function. */
ex_continue:	if (vp->kp->func(sp, vp))
			goto err;
gc_event:
#ifdef DEBUG
		/* Make sure no function left the temporary space locked. */
		if (F_ISSET(gp, G_TMP_INUSE)) {
			F_CLR(gp, G_TMP_INUSE);
			msgq(sp, M_ERR,
			    "vi: temporary buffer not released");
		}
#endif
		/*
		 * If we're exiting this screen, move to the next one, or, if
		 * there aren't any more, return to the main editor loop.  The
		 * ordering is careful, don't discard the contents of sp until
		 * the end.
		 */
		if (F_ISSET(sp, SC_EXIT | SC_EXIT_FORCE)) {
			if (file_end(sp, NULL, F_ISSET(sp, SC_EXIT_FORCE)))
				goto ret;
			if (vs_discard(sp, &next))
				goto ret;
			if (next == NULL && vs_swap(sp, &next, NULL))
				goto ret;
			*spp = next;
			if (screen_end(sp))
				goto ret;
			if (next == NULL)
				break;

			/* Switch screens, change focus. */
			sp = next;
			vip = VIP(sp);
			(void)sp->gp->scr_rename(sp, sp->frp->name, 1);

			/* Don't trust the cursor. */
			F_SET(vip, VIP_CUR_INVALID);

			continue;
		}

		/*
		 * Set the dot command structure.
		 *
		 * !!!
		 * Historically, commands which used mapped keys did not
		 * set the dot command, with the exception of the text
		 * input commands.
		 */
		if (F_ISSET(vp, V_DOT) && !mapped) {
			*DOT = cmd;
			F_SET(DOT, VC_ISDOT);

			/*
			 * If a count was supplied for both the command and
			 * its motion, the count was used only for the motion.
			 * Turn the count back on for the dot structure.
			 */
			if (F_ISSET(vp, VC_C1RESET))
				F_SET(DOT, VC_C1SET);

			/* VM flags aren't retained. */
			F_CLR(DOT, VM_COMMASK | VM_RCM_MASK);
		}

		/*
		 * Some vi row movements are "attracted" to the last position
		 * set, i.e. the VM_RCM commands are moths to the VM_RCM_SET
		 * commands' candle.  If the movement is to the EOL the vi
		 * command handles it.  If it's to the beginning, we handle it
		 * here.
		 *
		 * Note, some commands (e.g. _, ^) don't set the VM_RCM_SETFNB
		 * flag, but do the work themselves.  The reason is that they
		 * have to modify the column in case they're being used as a
		 * motion component.  Other similar commands (e.g. +, -) don't
		 * have to modify the column because they are always line mode
		 * operations when used as motions, so the column number isn't
		 * of any interest.
		 *
		 * Does this totally violate the screen and editor layering?
		 * You betcha.  As they say, if you think you understand it,
		 * you don't.
		 */
		switch (F_ISSET(vp, VM_RCM_MASK)) {
		case 0:
		case VM_RCM_SET:
			break;
		case VM_RCM:
			vp->m_final.cno = vs_rcm(sp,
			    vp->m_final.lno, F_ISSET(vip, VIP_RCM_LAST));
			break;
		case VM_RCM_SETLAST:
			F_SET(vip, VIP_RCM_LAST);
			break;
		case VM_RCM_SETFNB:
			vp->m_final.cno = 0;
			/* FALLTHROUGH */
		case VM_RCM_SETNNB:
			if (nonblank(sp, vp->m_final.lno, &vp->m_final.cno))
				goto err;
			break;
		default:
			abort();
		}

		/* Update the cursor. */
		sp->lno = vp->m_final.lno;
		sp->cno = vp->m_final.cno;

		/*
		 * Set the absolute mark -- set even if a tags or similar
		 * command, since the tag may be moving to the same file.
		 */
		if ((F_ISSET(vp, V_ABS) ||
		    (F_ISSET(vp, V_ABS_L) && sp->lno != abs.lno) ||
		    (F_ISSET(vp, V_ABS_C) &&
		    (sp->lno != abs.lno || sp->cno != abs.cno))) &&
		    mark_set(sp, ABSMARK1, &abs, 1))
			goto err;

		if (0) {
err:			if (v_event_flush(sp, CH_MAPPED))
				msgq(sp, M_BERR,
			    "Vi command failed: mapped keys discarded");
		}

		/*
		 * Check and clear interrupts.  There's an obvious race, but
		 * it's not worth fixing.
		 */
gc_err_noflush:	if (INTERRUPTED(sp)) {
intr:			CLR_INTERRUPT(sp);
			if (v_event_flush(sp, CH_MAPPED))
				msgq(sp, M_ERR,
				    "Interrupted: mapped keys discarded");
			else
				msgq(sp, M_ERR, "Interrupted");
		}

		/* If the last command switched screens, update. */
		if (F_ISSET(sp, SC_SSWITCH)) {
			F_CLR(sp, SC_SSWITCH);

			/*
			 * If the current screen is still displayed, it will
			 * need a new status line.
			 */
			F_SET(sp, SC_STATUS);

			/* Switch screens, change focus. */
			sp = sp->nextdisp;
			vip = VIP(sp);
			(void)sp->gp->scr_rename(sp, sp->frp->name, 1);

			/* Don't trust the cursor. */
			F_SET(vip, VIP_CUR_INVALID);

			/* Refresh so we can display messages. */
			if (vs_refresh(sp, 1))
				return (1);
		}

		/* If the last command switched files, change focus. */
		if (F_ISSET(sp, SC_FSWITCH)) {
			F_CLR(sp, SC_FSWITCH);
			(void)sp->gp->scr_rename(sp, sp->frp->name, 1);
		}

		/* If leaving vi, return to the main editor loop. */
		if (F_ISSET(gp, G_SRESTART) || F_ISSET(sp, SC_EX)) {
			*spp = sp;
			v_dtoh(sp);
			break;
		}
	}
	if (0)
ret:		rval = 1;
	return (rval);
}

#define	KEY(key, ec_flags) {						\
	if ((gcret = v_key(sp, 0, &ev, (ec_flags))) != GC_OK)		\
		return (gcret);						\
	if (ev.e_value == K_ESCAPE)					\
		goto esc;						\
	if (F_ISSET(&ev.e_ch, CH_MAPPED))				\
		*mappedp = 1;						\
	(key) = ev.e_c;							\
}

/*
 * The O_TILDEOP option makes the ~ command take a motion instead
 * of a straight count.  This is the replacement structure we use
 * instead of the one currently in the VIKEYS table.
 *
 * XXX
 * This should probably be deleted -- it's not all that useful, and
 * we get help messages wrong.
 */
VIKEYS const tmotion = {
	v_mulcase,	V_CNT|V_DOT|V_MOTION|VM_RCM_SET,
	"[count]~[count]motion",
	" ~ change case to motion"
};

/*
 * v_cmd --
 *
 * The command structure for vi is less complex than ex (and don't think
 * I'm not grateful!)  The command syntax is:
 *
 *	[count] [buffer] [count] key [[motion] | [buffer] [character]]
 *
 * and there are several special cases.  The motion value is itself a vi
 * command, with the syntax:
 *
 *	[count] key [character]
 */
static gcret_t
v_cmd(SCR *sp, VICMD *dp, VICMD *vp, VICMD *ismotion, int *comcountp,
    int *mappedp)
{
	enum { COMMANDMODE, ISPARTIAL, NOTPARTIAL } cpart;
	EVENT ev;
	VIKEYS const *kp;
	gcret_t gcret;
	u_int flags;
	CHAR_T key;
	char *s;

	/*
	 * Get a key.
	 *
	 * <escape> cancels partial commands, i.e. a command where at least
	 * one non-numeric character has been entered.  Otherwise, it beeps
	 * the terminal.
	 *
	 * !!!
	 * POSIX 1003.2-1992 explicitly disallows cancelling commands where
	 * all that's been entered is a number, requiring that the terminal
	 * be alerted.
	 */
	cpart = ismotion == NULL ? COMMANDMODE : ISPARTIAL;
	if ((gcret =
	    v_key(sp, ismotion == NULL, &ev, EC_MAPCOMMAND)) != GC_OK) {
		if (gcret == GC_EVENT)
			vp->ev = ev;
		return (gcret);
	}
	if (ev.e_value == K_ESCAPE)
		goto esc;
	if (F_ISSET(&ev.e_ch, CH_MAPPED))
		*mappedp = 1;
	key = ev.e_c;

	if (ismotion == NULL)
		cpart = NOTPARTIAL;

	/* Pick up optional buffer. */
	if (key == '"') {
		cpart = ISPARTIAL;
		if (ismotion != NULL) {
			v_emsg(sp, NULL, VIM_COMBUF);
			return (GC_ERR);
		}
		KEY(vp->buffer, 0);
		F_SET(vp, VC_BUFFER);

		KEY(key, EC_MAPCOMMAND);
	}

	/*
	 * Pick up optional count, where a leading 0 is not a count,
	 * it's a command.
	 */
	if (isdigit(key) && key != '0') {
		if (v_count(sp, key, &vp->count))
			return (GC_ERR);
		F_SET(vp, VC_C1SET);
		*comcountp = 1;

		KEY(key, EC_MAPCOMMAND);
	} else
		*comcountp = 0;

	/* Pick up optional buffer. */
	if (key == '"') {
		cpart = ISPARTIAL;
		if (F_ISSET(vp, VC_BUFFER)) {
			msgq(sp, M_ERR, "Only one buffer may be specified");
			return (GC_ERR);
		}
		if (ismotion != NULL) {
			v_emsg(sp, NULL, VIM_COMBUF);
			return (GC_ERR);
		}
		KEY(vp->buffer, 0);
		F_SET(vp, VC_BUFFER);

		KEY(key, EC_MAPCOMMAND);
	}

	/* Check for an OOB command key. */
	cpart = ISPARTIAL;
	if (key > MAXVIKEY) {
		v_emsg(sp, KEY_NAME(sp, key), VIM_NOCOM);
		return (GC_ERR);
	}
	kp = &vikeys[vp->key = key];

	/*
	 * !!!
	 * Historically, D accepted and then ignored a count.  Match it.
	 */
	if (vp->key == 'D' && F_ISSET(vp, VC_C1SET)) {
		*comcountp = 0;
		vp->count = 0;
		F_CLR(vp, VC_C1SET);
	}

	/* Check for command aliases. */
	if (kp->func == NULL && (kp = v_alias(sp, vp, kp)) == NULL)
		return (GC_ERR);

	/* The tildeop option makes the ~ command take a motion. */
	if (key == '~' && O_ISSET(sp, O_TILDEOP))
		kp = &tmotion;

	vp->kp = kp;

	/*
	 * Find the command.  The only legal command with no underlying
	 * function is dot.  It's historic practice that <escape> doesn't
	 * just erase the preceding number, it beeps the terminal as well.
	 * It's a common problem, so just beep the terminal unless verbose
	 * was set.
	 */
	if (kp->func == NULL) {
		if (key != '.') {
			v_emsg(sp, KEY_NAME(sp, key),
			    ev.e_value == K_ESCAPE ? VIM_NOCOM_B : VIM_NOCOM);
			return (GC_ERR);
		}

		/* If called for a motion command, stop now. */
		if (dp == NULL)
			goto usage;

		/*
		 * !!!
		 * If a '.' is immediately entered after an undo command, we
		 * replay the log instead of redoing the last command.  This
		 * is necessary because 'u' can't set the dot command -- see
		 * vi/v_undo.c:v_undo for details.
		 */
		if (VIP(sp)->u_ccnt == sp->ccnt) {
			vp->kp = &vikeys['u'];
			F_SET(vp, VC_ISDOT);
			return (GC_OK);
		}

		/* Otherwise, a repeatable command must have been executed. */
		if (!F_ISSET(dp, VC_ISDOT)) {
			msgq(sp, M_ERR, "No command to repeat");
			return (GC_ERR);
		}

		/* Set new count/buffer, if any, and return. */
		if (F_ISSET(vp, VC_C1SET)) {
			F_SET(dp, VC_C1SET);
			dp->count = vp->count;
		}
		if (F_ISSET(vp, VC_BUFFER))
			dp->buffer = vp->buffer;

		*vp = *dp;
		return (GC_OK);
	}

	/* Set the flags based on the command flags. */
	flags = kp->flags;

	/* Check for illegal count. */
	if (F_ISSET(vp, VC_C1SET) && !LF_ISSET(V_CNT))
		goto usage;

	/* Illegal motion command. */
	if (ismotion == NULL) {
		/* Illegal buffer. */
		if (!LF_ISSET(V_OBUF) && F_ISSET(vp, VC_BUFFER))
			goto usage;

		/* Required buffer. */
		if (LF_ISSET(V_RBUF)) {
			KEY(vp->buffer, 0);
			F_SET(vp, VC_BUFFER);
		}
	}

	/*
	 * Special case: '[', ']' and 'Z' commands.  Doesn't the fact that
	 * the *single* characters don't mean anything but the *doubled*
	 * characters do, just frost your shorts?
	 */
	if (vp->key == '[' || vp->key == ']' || vp->key == 'Z') {
		/*
		 * Historically, half entered [[, ]] or Z commands weren't
		 * cancelled by <escape>, the terminal was beeped instead.
		 * POSIX.2-1992 probably didn't notice, and requires that
		 * they be cancelled instead of beeping.  Seems fine to me.
		 *
		 * Don't set the EC_MAPCOMMAND flag, apparently ] is a popular
		 * vi meta-character, and we don't want the user to wait while
		 * we time out a possible mapping.  This *appears* to match
		 * historic vi practice, but with mapping characters, you Just
		 * Never Know.
		 */
		KEY(key, 0);

		if (vp->key != key) {
usage:			if (ismotion == NULL)
				s = kp->usage;
			else if (ismotion->key == '~' && O_ISSET(sp, O_TILDEOP))
				s = tmotion.usage;
			else
				s = vikeys[ismotion->key].usage;
			v_emsg(sp, s, VIM_USAGE);
			return (GC_ERR);
		}
	}
	/* Special case: 'z' command. */
	if (vp->key == 'z') {
		KEY(vp->character, 0);
		if (isdigit(vp->character)) {
			if (v_count(sp, vp->character, &vp->count2))
				return (GC_ERR);
			F_SET(vp, VC_C2SET);
			KEY(vp->character, 0);
		}
	}

	/*
	 * Commands that have motion components can be doubled to
	 * imply the current line.
	 */
	if (ismotion != NULL && ismotion->key != key && !LF_ISSET(V_MOVE)) {
		msgq(sp, M_ERR, "%s may not be used as a motion command",
		    KEY_NAME(sp, key));
		return (GC_ERR);
	}

	/* Required character. */
	if (LF_ISSET(V_CHAR))
		KEY(vp->character, 0);

	/* Get any associated cursor word. */
	if (F_ISSET(kp, V_KEYW) && v_keyword(sp))
		return (GC_ERR);

	return (GC_OK);

esc:	switch (cpart) {
	case COMMANDMODE:
		msgq(sp, M_BERR, "Already in command mode");
		return (GC_ERR_NOFLUSH);
	case ISPARTIAL:
		break;
	case NOTPARTIAL:
		(void)sp->gp->scr_bell(sp);
		break;
	}
	return (GC_ERR);
}

/*
 * v_motion --
 *
 * Get resulting motion mark.
 */
static int
v_motion(SCR *sp, VICMD *dm, VICMD *vp, int *mappedp)
{
	VICMD motion;
	size_t len;
	u_long cnt;
	u_int flags;
	int tilde_reset, notused;

	/*
	 * If '.' command, use the dot motion, else get the motion command.
	 * Clear any line motion flags, the subsequent motion isn't always
	 * the same, i.e. "/aaa" may or may not be a line motion.
	 */
	if (F_ISSET(vp, VC_ISDOT)) {
		motion = *dm;
		F_SET(&motion, VC_ISDOT);
		F_CLR(&motion, VM_COMMASK);
	} else {
		memset(&motion, 0, sizeof(VICMD));
		if (v_cmd(sp, NULL, &motion, vp, &notused, mappedp) != GC_OK)
			return (1);
	}

	/*
	 * A count may be provided both to the command and to the motion, in
	 * which case the count is multiplicative.  For example, "3y4y" is the
	 * same as "12yy".  This count is provided to the motion command and
	 * not to the regular function.
	 */
	cnt = motion.count = F_ISSET(&motion, VC_C1SET) ? motion.count : 1;
	if (F_ISSET(vp, VC_C1SET)) {
		motion.count *= vp->count;
		F_SET(&motion, VC_C1SET);

		/*
		 * Set flags to restore the original values of the command
		 * structure so dot commands can change the count values,
		 * e.g. "2dw" "3." deletes a total of five words.
		 */
		F_CLR(vp, VC_C1SET);
		F_SET(vp, VC_C1RESET);
	}

	/*
	 * Some commands can be repeated to indicate the current line.  In
	 * this case, or if the command is a "line command", set the flags
	 * appropriately.  If not a doubled command, run the function to get
	 * the resulting mark.
 	 */
	if (vp->key == motion.key) {
		F_SET(vp, VM_LDOUBLE | VM_LMODE);

		/* Set the origin of the command. */
		vp->m_start.lno = sp->lno;
		vp->m_start.cno = 0;

		/*
		 * Set the end of the command.
		 *
		 * If the current line is missing, i.e. the file is empty,
		 * historic vi permitted a "cc" or "!!" command to insert
		 * text.
		 */
		vp->m_stop.lno = sp->lno + motion.count - 1;
		if (db_get(sp, vp->m_stop.lno, 0, NULL, &len)) {
			if (vp->m_stop.lno != 1 ||
			    (vp->key != 'c' && vp->key != '!')) {
				v_emsg(sp, NULL, VIM_EMPTY);
				return (1);
			}
			vp->m_stop.cno = 0;
		} else
			vp->m_stop.cno = len ? len - 1 : 0;
	} else {
		/*
		 * Motion commands change the underlying movement (*snarl*).
		 * For example, "l" is illegal at the end of a line, but "dl"
		 * is not.  Set flags so the function knows the situation.
		 */
		motion.rkp = vp->kp;

		/*
		 * XXX
		 * Use yank instead of creating a new motion command, it's a
		 * lot easier for now.
		 */
		if (vp->kp == &tmotion) {
			tilde_reset = 1;
			vp->kp = &vikeys['y'];
		} else
			tilde_reset = 0;

		/*
		 * Copy the key flags into the local structure, except for the
		 * RCM flags -- the motion command will set the RCM flags in
		 * the vp structure if necessary.  This means that the motion
		 * command is expected to determine where the cursor ends up!
		 * However, we save off the current RCM mask and restore it if
		 * it no RCM flags are set by the motion command, with a small
		 * modification.
		 *
		 * We replace the VM_RCM_SET flag with the VM_RCM flag.  This
		 * is so that cursor movement doesn't set the relative position
		 * unless the motion command explicitly specified it.  This
		 * appears to match historic practice, but I've never been able
		 * to develop a hard-and-fast rule.
		 */
		flags = F_ISSET(vp, VM_RCM_MASK);
		if (LF_ISSET(VM_RCM_SET)) {
			LF_SET(VM_RCM);
			LF_CLR(VM_RCM_SET);
		}
		F_CLR(vp, VM_RCM_MASK);
		F_SET(&motion, motion.kp->flags & ~VM_RCM_MASK);

		/*
		 * Set the three cursor locations to the current cursor.  This
		 * permits commands like 'j' and 'k', that are line oriented
		 * motions and have special cursor suck semantics when they are
		 * used as standalone commands, to ignore column positioning.
		 */
		motion.m_final.lno =
		    motion.m_stop.lno = motion.m_start.lno = sp->lno;
		motion.m_final.cno =
		    motion.m_stop.cno = motion.m_start.cno = sp->cno;

		/* Run the function. */
		if ((motion.kp->func)(sp, &motion))
			return (1);

		/*
		 * If the current line is missing, i.e. the file is empty,
		 * historic vi allowed "c<motion>" or "!<motion>" to insert
		 * text.  Otherwise fail -- most motion commands will have
		 * already failed, but some, e.g. G, succeed in empty files.
		 */
		if (!db_exist(sp, vp->m_stop.lno)) {
			if (vp->m_stop.lno != 1 ||
			    (vp->key != 'c' && vp->key != '!')) {
				v_emsg(sp, NULL, VIM_EMPTY);
				return (1);
			}
			vp->m_stop.cno = 0;
		}

		/*
		 * XXX
		 * See above.
		 */
		if (tilde_reset)
			vp->kp = &tmotion;

		/*
		 * Copy cut buffer, line mode and cursor position information
		 * from the motion command structure, i.e. anything that the
		 * motion command can set for us.  The commands can flag the
		 * movement as a line motion (see v_sentence) as well as set
		 * the VM_RCM_* flags explicitly.
		 */
		F_SET(vp, F_ISSET(&motion, VM_COMMASK | VM_RCM_MASK));

		/*
		 * If the motion command set no relative motion flags, use
		 * the (slightly) modified previous values.
		 */
		if (!F_ISSET(vp, VM_RCM_MASK))
			F_SET(vp, flags);

		/*
		 * Commands can change behaviors based on the motion command
		 * used, for example, the ! command repeated the last bang
		 * command if N or n was used as the motion.
		 */
		vp->rkp = motion.kp;

		/*
		 * Motion commands can reset all of the cursor information.
		 * If the motion is in the reverse direction, switch the
		 * from and to MARK's so that it's in a forward direction.
		 * Motions are from the from MARK to the to MARK (inclusive).
		 */
		if (motion.m_start.lno > motion.m_stop.lno ||
		    (motion.m_start.lno == motion.m_stop.lno &&
		    motion.m_start.cno > motion.m_stop.cno)) {
			vp->m_start = motion.m_stop;
			vp->m_stop = motion.m_start;
		} else {
			vp->m_start = motion.m_start;
			vp->m_stop = motion.m_stop;
		}
		vp->m_final = motion.m_final;
	}

	/*
	 * If the command sets dot, save the motion structure.  The motion
	 * count was changed above and needs to be reset, that's why this
	 * is done here, and not in the calling routine.
	 */
	if (F_ISSET(vp->kp, V_DOT)) {
		*dm = motion;
		dm->count = cnt;
	}
	return (0);
}

/*
 * v_init --
 *	Initialize the vi screen.
 */
static int
v_init(SCR *sp)
{
	GS *gp;
	VI_PRIVATE *vip;

	gp = sp->gp;
	vip = VIP(sp);

	/* Switch into vi. */
	if (gp->scr_screen(sp, SC_VI))
		return (1);
	(void)gp->scr_attr(sp, SA_ALTERNATE, 1);

	F_CLR(sp, SC_EX | SC_SCR_EX);
	F_SET(sp, SC_VI);

	/*
	 * Initialize screen values.
	 *
	 * Small windows: see vs_refresh(), section 6a.
	 *
	 * Setup:
	 *	t_minrows is the minimum rows to display
	 *	t_maxrows is the maximum rows to display (rows - 1)
	 *	t_rows is the rows currently being displayed
	 */
	sp->rows = vip->srows = O_VAL(sp, O_LINES);
	sp->cols = O_VAL(sp, O_COLUMNS);
	sp->t_rows = sp->t_minrows = O_VAL(sp, O_WINDOW);
	if (sp->rows != 1) {
		if (sp->t_rows > sp->rows - 1) {
			sp->t_minrows = sp->t_rows = sp->rows - 1;
			msgq(sp, M_INFO,
			    "Windows option value is too large, max is %u",
			    sp->t_rows);
		}
		sp->t_maxrows = sp->rows - 1;
	} else
		sp->t_maxrows = 1;
	sp->woff = 0;

	/* Create a screen map. */
	CALLOC_RET(sp, HMAP, SIZE_HMAP(sp), sizeof(SMAP));
	TMAP = HMAP + (sp->t_rows - 1);
	HMAP->lno = sp->lno;
	HMAP->coff = 0;
	HMAP->soff = 1;

	/*
	 * Fill the screen map from scratch -- try and center the line.  That
	 * way if we're starting with a file we've seen before, we'll put the
	 * line in the middle, otherwise, it won't work and we'll end up with
	 * the line at the top.
	 */
	F_CLR(sp, SC_SCR_TOP);
	F_SET(sp, SC_SCR_REFORMAT | SC_SCR_CENTER);

	/* Invalidate the cursor. */
	F_SET(vip, VIP_CUR_INVALID);

	/* Paint the screen image from scratch. */
	F_SET(vip, VIP_N_EX_PAINT);

	return (0);
}

/*
 * v_dtoh --
 *	Move all but the current screen to the hidden queue.
 */
static void
v_dtoh(SCR *sp)
{
	GS *gp;
	SCR *tsp;
	int hidden;

	/* Move all screens to the hidden queue, tossing screen maps. */
	hidden = 0;
	gp = sp->gp;
	while ((tsp = TAILQ_FIRST(&gp->dq))) {
		free(_HMAP(tsp));
		_HMAP(tsp) = NULL;
		TAILQ_REMOVE(&gp->dq, tsp, q);
		TAILQ_INSERT_TAIL(&gp->hq, tsp, q);
		++hidden;
	}

	/* Move current screen back to the display queue. */
	TAILQ_REMOVE(&gp->hq, sp, q);
	TAILQ_INSERT_TAIL(&gp->dq, sp, q);

	/*
	 * XXX
	 * Don't bother internationalizing this message, it's going to
	 * go away as soon as we have one-line screens.  --TK
	 */
	if (hidden > 1)
		msgq(sp, M_INFO,
		    "%d screens backgrounded; use :display to list them",
		    hidden - 1);
}

/*
 * v_keyword --
 *	Get the word (or non-word) the cursor is on.
 */
static int
v_keyword(SCR *sp)
{
	VI_PRIVATE *vip;
	size_t beg, end, len;
	int moved, state;
	char *p;

	if (db_get(sp, sp->lno, DBG_FATAL, &p, &len))
		return (1);

	/*
	 * !!!
	 * Historically, tag commands skipped over any leading whitespace
	 * characters.  Make this true in general when using cursor words.
	 * If movement, getting a cursor word implies moving the cursor to
	 * its beginning.  Refresh now.
	 *
	 * !!!
	 * Find the beginning/end of the keyword.  Keywords are currently
	 * used for cursor-word searching and for tags.  Historical vi
	 * only used the word in a tag search from the cursor to the end
	 * of the word, i.e. if the cursor was on the 'b' in " abc ", the
	 * tag was "bc".  For consistency, we make cursor word searches
	 * follow the same rule.
	 */
	for (moved = 0,
	    beg = sp->cno; beg < len && isspace(p[beg]); moved = 1, ++beg);
	if (beg >= len) {
		msgq(sp, M_BERR, "Cursor not in a word");
		return (1);
	}
	if (moved) {
		sp->cno = beg;
		(void)vs_refresh(sp, 0);
	}

	/* Find the end of the word. */
	for (state = inword(p[beg]),
	    end = beg; ++end < len && state == inword(p[end]););

	vip = VIP(sp);
	len = (end - beg);
	BINC_RET(sp, vip->keyw, vip->klen, len);
	memmove(vip->keyw, p + beg, len);
	vip->keyw[len] = '\0';				/* XXX */
	return (0);
}

/*
 * v_alias --
 *	Check for a command alias.
 */
static VIKEYS const *
v_alias(SCR *sp, VICMD *vp, VIKEYS const *kp)
{
	CHAR_T push;

	switch (vp->key) {
	case 'C':			/* C -> c$ */
		push = '$';
		vp->key = 'c';
		break;
	case 'D':			/* D -> d$ */
		push = '$';
		vp->key = 'd';
		break;
	case 'S':			/* S -> c_ */
		push = '_';
		vp->key = 'c';
		break;
	case 'Y':			/* Y -> y_ */
		push = '_';
		vp->key = 'y';
		break;
	default:
		return (kp);
	}
	return (v_event_push(sp,
	    NULL, &push, 1, CH_NOMAP | CH_QUOTED) ? NULL : &vikeys[vp->key]);
}

/*
 * v_count --
 *	Return the next count.
 */
static int
v_count(SCR *sp, CHAR_T fkey, u_long *countp)
{
	EVENT ev;
	u_long count, tc;

	ev.e_c = fkey;
	count = tc = 0;
	do {
		/*
		 * XXX
		 * Assume that overflow results in a smaller number.
		 */
		tc = count * 10 + ev.e_c - '0';
		if (count > tc) {
			/* Toss to the next non-digit. */
			do {
				if (v_key(sp, 0, &ev,
				    EC_MAPCOMMAND | EC_MAPNODIGIT) != GC_OK)
					return (1);
			} while (isdigit(ev.e_c));
			msgq(sp, M_ERR,
			    "Number larger than %lu", ULONG_MAX);
			return (1);
		}
		count = tc;
		if (v_key(sp, 0, &ev, EC_MAPCOMMAND | EC_MAPNODIGIT) != GC_OK)
			return (1);
	} while (isdigit(ev.e_c));
	*countp = count;
	return (0);
}

/*
 * v_key --
 *	Return the next event.
 */
static gcret_t
v_key(SCR *sp, int command_events, EVENT *evp, u_int32_t ec_flags)
{
	u_int32_t quote;

	for (quote = 0;;) {
		if (v_event_get(sp, evp, 0, ec_flags | quote))
			return (GC_FATAL);
		quote = 0;

		switch (evp->e_event) {
		case E_CHARACTER:
			/*
			 * !!!
			 * Historically, ^V was ignored in the command stream,
			 * although it had a useful side-effect of interrupting
			 * mappings.  Adding a quoting bit to the call probably
			 * extends historic practice, but it feels right.
			 */
			if (evp->e_value == K_VLNEXT) {
				quote = EC_QUOTED;
				break;
			}
			return (GC_OK);
		case E_ERR:
		case E_EOF:
			return (GC_FATAL);
		case E_INTERRUPT:
			/*
			 * !!!
			 * Historically, vi beeped on command level interrupts.
			 *
			 * Historically, vi exited to ex mode if no file was
			 * named on the command line, and two interrupts were
			 * generated in a row.  (Just figured you might want
			 * to know that.)
			 */
			(void)sp->gp->scr_bell(sp);
			return (GC_INTERRUPT);
		case E_REPAINT:
			if (vs_repaint(sp, evp))
				return (GC_FATAL);
			break;
		case E_WRESIZE:
			return (GC_ERR);
		case E_QUIT:
		case E_WRITE:
			if (command_events)
				return (GC_EVENT);
			/* FALLTHROUGH */
		default:
			v_event_err(sp, evp);
			return (GC_ERR);
		}
	}
	/* NOTREACHED */
}

#if defined(DEBUG) && defined(COMLOG)
/*
 * v_comlog --
 *	Log the contents of the command structure.
 */
static void
v_comlog(SCR *sp, VICMD *vp)
{
	TRACE(sp, "vcmd: %c", vp->key);
	if (F_ISSET(vp, VC_BUFFER))
		TRACE(sp, " buffer: %c", vp->buffer);
	if (F_ISSET(vp, VC_C1SET))
		TRACE(sp, " c1: %lu", vp->count);
	if (F_ISSET(vp, VC_C2SET))
		TRACE(sp, " c2: %lu", vp->count2);
	TRACE(sp, " flags: 0x%x\n", vp->flags);
}
#endif
@


1.20
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.18 2016/01/20 08:43:27 bentley Exp $	*/
d1004 2
a1005 4
		if (_HMAP(tsp) != NULL) {
			free(_HMAP(tsp));
			_HMAP(tsp) = NULL;
		}
@


1.19
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d37 1
a37 1
static int	v_count(SCR *, char, u_long *);
d460 1
a460 1
	char key;
d1088 1
a1088 1
	char push;
d1119 1
a1119 1
v_count(SCR *sp, char fkey, u_long *countp)
@


1.18
log
@Remove ARG_CHAR_T, a relic from when the code was written K&R style.

ok millert@@ schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.17 2016/01/06 22:28:52 millert Exp $	*/
d37 1
a37 1
static int	v_count(SCR *, CHAR_T, u_long *);
d460 1
a460 1
	CHAR_T key;
d1088 1
a1088 1
	CHAR_T push;
d1119 1
a1119 1
v_count(SCR *sp, CHAR_T fkey, u_long *countp)
@


1.17
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.16 2015/12/07 20:39:19 mmcc Exp $	*/
d37 1
a37 1
static int	v_count(SCR *, ARG_CHAR_T, u_long *);
d1119 1
a1119 1
v_count(SCR *sp, ARG_CHAR_T fkey, u_long *countp)
@


1.16
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.15 2014/11/12 04:28:41 bentley Exp $	*/
d240 1
a240 1
			    "232|vi: temporary buffer not released");
d356 1
a356 1
			    "110|Vi command failed: mapped keys discarded");
d367 1
a367 1
				    "231|Interrupted: mapped keys discarded");
d369 1
a369 1
				msgq(sp, M_ERR, "236|Interrupted");
d522 1
a522 1
			msgq(sp, M_ERR, "234|Only one buffer may be specified");
d596 1
a596 1
			msgq(sp, M_ERR, "208|No command to repeat");
d679 1
a679 1
		msgq(sp, M_ERR, "210|%s may not be used as a motion command",
d696 1
a696 1
		msgq(sp, M_BERR, "211|Already in command mode");
d956 1
a956 1
			    "214|Windows option value is too large, max is %u",
d1061 1
a1061 1
		msgq(sp, M_BERR, "212|Cursor not in a word");
d1140 1
a1140 1
			    "235|Number larger than %lu", ULONG_MAX);
@


1.15
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.14 2013/11/28 22:12:40 krw Exp $	*/
d965 1
a965 1
	CALLOC_RET(sp, HMAP, SMAP *, SIZE_HMAP(sp), sizeof(SMAP));
@


1.14
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.13 2009/10/27 23:59:48 deraadt Exp $	*/
d63 1
a63 2
vi(spp)
	SCR **spp;
d452 2
a453 5
v_cmd(sp, dp, vp, ismotion, comcountp, mappedp)
	SCR *sp;
	VICMD *dp, *vp;
	VICMD *ismotion;	/* Previous key if getting motion component. */
	int *comcountp, *mappedp;
d713 1
a713 4
v_motion(sp, dm, vp, mappedp)
	SCR *sp;
	VICMD *dm, *vp;
	int *mappedp;
d923 1
a923 2
v_init(sp)
	SCR *sp;
d994 1
a994 2
v_dtoh(sp)
	SCR *sp;
d1033 1
a1033 2
v_keyword(sp)
	SCR *sp;
d1086 1
a1086 4
v_alias(sp, vp, kp)
	SCR *sp;
	VICMD *vp;
	VIKEYS const *kp;
d1119 1
a1119 4
v_count(sp, fkey, countp)
	SCR *sp;
	ARG_CHAR_T fkey;
	u_long *countp;
d1156 1
a1156 5
v_key(sp, command_events, evp, ec_flags)
	SCR *sp;
	int command_events;
	EVENT *evp;
	u_int32_t ec_flags;
d1219 1
a1219 3
v_comlog(sp, vp)
	SCR *sp;
	VICMD *vp;
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.12 2006/01/08 21:05:40 miod Exp $	*/
d1010 3
a1012 2
	for (hidden = 0, gp = sp->gp;
	    (tsp = CIRCLEQ_FIRST(&gp->dq)) != CIRCLEQ_END(&gp->dq); ++hidden) {
d1017 3
a1019 2
		CIRCLEQ_REMOVE(&gp->dq, tsp, q);
		CIRCLEQ_INSERT_TAIL(&gp->hq, tsp, q);
d1023 2
a1024 2
	CIRCLEQ_REMOVE(&gp->hq, sp, q);
	CIRCLEQ_INSERT_TAIL(&gp->dq, sp, q);
@


1.12
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.11 2005/10/17 19:12:16 otto Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)vi.c	10.57 (Berkeley) 10/13/96";
#endif /* not lint */
@


1.11
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.10 2005/01/08 05:22:25 pvalchev Exp $	*/
d352 3
a354 3
		    F_ISSET(vp, V_ABS_L) && sp->lno != abs.lno ||
		    F_ISSET(vp, V_ABS_C) &&
		    (sp->lno != abs.lno || sp->cno != abs.cno)) &&
d419 1
a419 1
	if ((gcret = v_key(sp, 0, &ev, ec_flags)) != GC_OK)		\
d425 1
a425 1
	key = ev.e_c;							\
d790 1
a790 1
			   vp->key != 'c' && vp->key != '!') {
d862 1
a862 1
			   vp->key != 'c' && vp->key != '!') {
d906 2
a907 2
		    motion.m_start.lno == motion.m_stop.lno &&
		    motion.m_start.cno > motion.m_stop.cno) {
@


1.10
log
@Fix for FreeBSD PR#12801 from Sven Verdoolaege (nvi maintainer) via FreeBSD
(an infinite loop at certain case when options "comment" and "leftright"
are used)
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.9 2002/02/16 21:27:58 millert Exp $	*/
d1015 1
a1015 1
	    (tsp = gp->dq.cqh_first) != (void *)&gp->dq; ++hidden) {
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.8 2001/01/29 01:58:54 niklas Exp $	*/
d989 1
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 8
a46 8
	       *v_alias __P((SCR *, VICMD *, VIKEYS const *));
static gcret_t	v_cmd __P((SCR *, VICMD *, VICMD *, VICMD *, int *, int *));
static int	v_count __P((SCR *, ARG_CHAR_T, u_long *));
static void	v_dtoh __P((SCR *));
static int	v_init __P((SCR *));
static gcret_t	v_key __P((SCR *, int, EVENT *, u_int32_t));
static int	v_keyword __P((SCR *));
static int	v_motion __P((SCR *, VICMD *, VICMD *, int *));
d49 1
a49 1
static void	v_comlog __P((SCR *, VICMD *));
d64 1
a64 1
 * PUBLIC: int vi __P((SCR **));
@


1.7
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.6
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vi.c	10.56 (Berkeley) 9/25/96";
d95 1
a95 1
		if (!MAPPED_KEYS_WAITING(sp) && vs_resolve(sp, 0))
@


1.5
log
@nvi 1.74
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vi.c	10.55 (Berkeley) 8/17/96";
d42 1
a42 1
static gcret_t	v_key __P((SCR *, int, EVENT *, u_int));
@


1.4
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vi.c	10.53 (Berkeley) 8/11/96";
a72 1
	u_int flags;
d381 1
a381 1
			 * want a new status line.
d383 1
a383 2
			if (F_ISSET(sp, SC_STATUS) && vs_resolve(sp, 0))
				goto ret;
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vi.c	10.52 (Berkeley) 6/30/96";
d91 3
d266 1
a266 1
			/* Switch, and display a status line. */
d269 3
d273 1
d387 1
a387 1
			/* Switch screens. */
d390 1
d400 5
a404 2
		/* If the last command switched files, we don't care. */
		F_CLR(sp, SC_FSWITCH);
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)vi.c	10.47 (Berkeley) 5/18/96";
d93 1
a93 1
		if (!MAPPED_KEYS_WAITING(sp) && vs_resolve(sp))
d377 1
a377 1
			if (F_ISSET(sp, SC_STATUS) && vs_resolve(sp))
a577 6
		/* A repeatable command must have been executed. */
		if (!F_ISSET(dp, VC_ISDOT)) {
			msgq(sp, M_ERR, "208|No command to repeat");
			return (GC_ERR);
		}

d591 6
d632 1
a632 1
	 * characters do just frost your shorts?
d640 6
d647 1
a647 1
		KEY(key, EC_MAPCOMMAND);
d926 1
d929 1
d933 1
a933 1
	if (sp->gp->scr_screen(sp, SC_VI))
d935 2
d1208 2
a1211 1
		case E_WRITEQUIT:
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)vi.c	8.91 (Berkeley) 8/17/94";
a23 1
#include <signal.h>
d27 1
a27 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d29 1
a30 1
#include "vcmd.h"
d32 17
a48 8
static int getcmd __P((SCR *, EXF *,
		VICMDARG *, VICMDARG *, VICMDARG *, int *, int *));
static __inline int
	   getcount __P((SCR *, ARG_CHAR_T, u_long *));
static __inline int
	   getkey __P((SCR *, CH *, u_int));
static int getkeyword __P((SCR *, EXF *, VICMDARG *, u_int));
static int getmotion __P((SCR *, EXF *, VICMDARG *, VICMDARG *, int *));
d61 2
d65 2
a66 3
vi(sp, ep)
	SCR *sp;
	EXF *ep;
d68 1
d70 16
a85 3
	VICMDARG cmd, *vp;
	u_int flags, saved_mode;
	int comcount, eval, mapped;
d87 2
a88 2
	/* Start vi and paint the screen. */
	if (v_init(sp, ep))
d91 4
a94 2
	/* Command initialization. */
	memset(&cmd, 0, sizeof(VICMDARG));
d96 10
a105 6
	for (eval = 0, vp = &cmd;;) {
		/* Refresh the screen. */
		sp->showmode = "Command";
		if (sp->s_refresh(sp, ep)) {
			eval = 1;
			break;
d110 2
a111 2
			sp->rcm_last = 0;
			(void)sp->s_column(sp, ep, &sp->rcm);
d122 1
a122 1
			if (log_cursor(sp, ep))
d128 13
d145 7
d153 2
a154 1
		if (getcmd(sp, ep, DOT, vp, NULL, &comcount, &mapped))
d156 19
a186 5
		/* Get any associated keyword. */
		if (F_ISSET(vp, V_KEYNUM | V_KEYW) &&
		    getkeyword(sp, ep, vp, vp->flags))
			goto err;

d203 8
a210 15
		 * Do any required motion; getmotion sets the from MARK and the
		 * line mode flag.  We save off the RCM mask and only restore
		 * it if it no RCM flags are set by the motion command.  This
		 * means that the motion command is expected to determine where
		 * the cursor ends up!
		 */
		if (F_ISSET(vp, V_MOTION)) {
			flags = F_ISSET(vp, VM_RCM_MASK);
			F_CLR(vp, VM_RCM_MASK);
			if (getmotion(sp, ep, DOTMOTION, vp, &mapped))
				goto err;
			if (F_ISSET(vp, VM_NOMOTION))
				goto err;
			if (!F_ISSET(vp, VM_RCM_MASK))
				F_SET(vp, flags);
d229 5
a233 3
		/* Save the mode and call the function. */
		saved_mode = F_ISSET(sp, S_SCREENS | S_MAJOR_CHANGE);
		if ((vp->kp->func)(sp, ep, vp))
d235 1
d238 2
a239 1
		if (F_ISSET(sp->gp, G_TMP_INUSE)) {
d241 1
a241 2
			    "Error: vi: temporary buffer not released");
			return (1);
d245 24
a268 5
		 * If that command took us out of vi or changed the screen,
		 * then exit the loop without further action.
		 */
		 if (saved_mode != F_ISSET(sp, S_SCREENS | S_MAJOR_CHANGE))
			break;
d274 3
a276 2
		 * Historically, no command which used any mapped keys became
		 * the dot command.
d297 3
a299 4
		 * commands' candle.  It's broken into two parts.  Here we deal
		 * with the command flags.  In sp->relative(), we deal with the
		 * screen flags.  If the movement is to the EOL the vi command
		 * handles it.  If it's to the beginning, we handle it here.
d318 2
a319 1
			vp->m_final.cno = sp->s_rcm(sp, ep, vp->m_final.lno);
d322 1
a322 1
			sp->rcm_last = 1;
d328 1
a328 1
			if (nonblank(sp, ep, vp->m_final.lno, &vp->m_final.cno))
d347 1
a347 1
		    mark_set(sp, ep, ABSMARK1, &abs, 1))
d350 5
a354 2
		if (!MAPPED_KEYS_WAITING(sp))
			(void)msg_rpt(sp, 1);
d357 2
a358 11
		 * Check and clear the interrupts.  There's an obvious race,
		 * but it's not worth cleaning up.  This is done after the
		 * err: lable, so that if the "error" was an interupt it gets
		 * cleaned up.
		 *
		 * !!!
		 * Previous versions of nvi cleared mapped characters on error,
		 * even if it wasn't an interrupt.  This feature was removed as
		 * users complained that it wasn't historic practice and that
		 * they used leading (illegal) <escape> characters in the map
		 * to clean up vi state before the map was interpreted.
d360 31
a390 4
err:		if (INTERRUPTED(sp))
			term_flush(sp, "Interrupted", CH_MAPPED);
		CLR_INTERRUPT(sp);
	}
d392 2
a393 3
	/* Free allocated keyword memory. */
	if (cmd.keyword != NULL)
		free(cmd.keyword);
d395 10
a404 1
	return (v_end(sp) || eval);
d407 4
a410 4
#define	KEY(key, map) {							\
	if (getkey(sp, &ikey, map))					\
		return (1);						\
	if (ikey.value == K_ESCAPE)					\
d412 1
a412 1
	if (F_ISSET(&ikey, CH_MAPPED))					\
d414 1
a414 1
	key = ikey.ch;							\
d423 2
a424 2
 * Note, I used VC_Y instead of creating a new motion command, it's
 * a lot easier.
d427 1
a427 1
	v_mulcase,	V_CNT|V_DOT|V_MOTION|VC_Y|VM_RCM_SET,
d433 1
a433 1
 * getcmd --
d445 2
a446 2
static int
getcmd(sp, ep, dp, vp, ismotion, comcountp, mappedp)
d448 2
a449 3
	EXF *ep;
	VICMDARG *dp, *vp;
	VICMDARG *ismotion;	/* Previous key if getting motion component. */
d453 1
d455 1
a456 1
	CH ikey;
a459 4
	/* Refresh the command structure. */
	memset(&vp->vp_startzero, 0,
	    (char *)&vp->vp_endzero - (char *)&vp->vp_startzero);

d473 12
a484 1
	KEY(key, TXT_MAPCOMMAND);
d492 2
a493 3
			msgq(sp, M_BERR,
			    "Buffers should be specified before the command");
			return (1);
d498 1
a498 1
		KEY(key, TXT_MAPCOMMAND);
d506 2
a507 2
		if (getcount(sp, key, &vp->count))
			return (1);
d511 1
a511 1
		KEY(key, TXT_MAPCOMMAND);
d519 2
a520 2
			msgq(sp, M_ERR, "Only one buffer can be specified");
			return (1);
d523 2
a524 3
			msgq(sp, M_BERR,
			    "Buffers should be specified before the command");
			return (1);
d529 1
a529 1
		KEY(key, TXT_MAPCOMMAND);
d535 2
a536 2
		msgq(sp, M_BERR, "%s isn't a vi command", KEY_NAME(sp, key));
		return (1);
d540 14
d569 3
a571 3
			msgq(sp, ikey.value == K_ESCAPE ? M_BERR : M_ERR,
			    "%s isn't a vi command", KEY_NAME(sp, key));
			return (1);
d580 2
a581 2
			msgq(sp, M_ERR, "No command to repeat");
			return (1);
d594 1
a594 1
			return (0);
d604 1
d606 1
a606 1
		return (0);
d641 1
a641 1
		KEY(key, TXT_MAPCOMMAND);
d650 2
a651 2
			msgq(sp, M_ERR, "Usage: %s", s);
			return (1);
d658 2
a659 2
			if (getcount(sp, vp->character, &vp->count2))
				return (1);
d670 1
a670 1
		msgq(sp, M_ERR, "%s may not be used as a motion command",
d672 1
a672 1
		return (1);
d679 5
a683 1
	return (0);
d687 2
a688 2
		msgq(sp, M_BERR, "Already in command mode");
		break;
d692 1
a692 1
		(void)sp->s_bell(sp);
d695 1
a695 1
	return (1);
d699 1
a699 1
 * getmotion --
d704 1
a704 1
getmotion(sp, ep, dm, vp, mappedp)
d706 1
a706 2
	EXF *ep;
	VICMDARG *dm, *vp;
d709 1
a709 2
	MARK m;
	VICMDARG motion;
d712 2
a713 1
	int notused;
d724 5
a728 2
	} else if (getcmd(sp, ep, NULL, &motion, vp, &notused, mappedp))
		return (1);
d771 1
a771 1
		if (file_gline(sp, ep, vp->m_stop.lno, &len) == NULL) {
d774 1
a774 3
				m.lno = sp->lno;
				m.cno = sp->cno;
				v_eof(sp, ep, &m);
d786 1
a786 1
		F_SET(&motion, vp->kp->flags & VC_COMMASK);
d789 3
a791 3
		 * Copy the key flags into the local structure, except for
		 * the RCM flags, the motion command will set the RCM flags
		 * in the vp structure as necessary.
d793 27
d834 1
a834 1
		if ((motion.kp->func)(sp, ep, &motion))
d838 22
d869 14
a911 2
#define	innum(c)	(isdigit(c) || strchr("abcdefABCDEF", c))

d913 2
a914 2
 * getkeyword --
 *	Get the "word" the cursor is on.
d917 1
a917 1
getkeyword(sp, ep, kp, flags)
a918 3
	EXF *ep;
	VICMDARG *kp;
	u_int flags;
d920 3
a922 3
	recno_t lno;
	size_t beg, end, len;
	char *p;
d924 2
a925 7
	if ((p = file_gline(sp, ep, sp->lno, &len)) == NULL) {
		if (file_lline(sp, ep, &lno))
			return (1);
		if (lno == 0)
			v_eof(sp, ep, NULL);
		else
			GETLINE_ERR(sp, sp->lno);
d927 2
a928 1
	}
d931 8
a938 3
	 * !!!
	 * Historically, tag commands skipped over any leading whitespace
	 * characters.
d940 14
a953 1
	for (beg = sp->cno; beg < len && isspace(p[beg]); ++beg);
d955 6
a960 5
	if (beg >= len ||
	    LF_ISSET(V_KEYW) && !inword(p[beg]) ||
	    LF_ISSET(V_KEYNUM) && !innum(p[beg]) &&
	    p[beg] != '-' && p[beg] != '+')
		goto noword;
d963 4
a966 7
	 * !!!
	 * Find the beginning/end of the keyword.  Keywords (V_KEYW) are
	 * used for cursor-word searching and for tags.  Historical vi
	 * only used the word in a tag search from the cursor to the end
	 * of the word, i.e. if the cursor was on the 'b' in " abc ", the
	 * tag was "bc".  For no particular reason, we make the cursor
	 * word searches follow the same rule.
d968 4
a971 27
	if (beg != 0)
		if (LF_ISSET(V_KEYW)) {
#ifdef	MOVE_TO_KEYWORD_BEGINNING
			for (;;) {
				--beg;
				if (!inword(p[beg])) {
					++beg;
					break;
				}
				if (beg == 0)
					break;
			}
#endif
		} else {
			for (;;) {
				--beg;
				if (!innum(p[beg])) {
					if (beg > 0 && p[beg - 1] == '0' &&
					    (p[beg] == 'X' || p[beg] == 'x'))
						--beg;
					else
						++beg;
					break;
				}
				if (beg == 0)
					break;
			}
d973 2
a974 5
			/* Skip possible leading sign. */
			if (beg != 0 && p[beg] != '0' &&
			    (p[beg - 1] == '+' || p[beg - 1] == '-'))
				--beg;
		}
d976 2
a977 13
	if (LF_ISSET(V_KEYW)) {
		for (end = beg; ++end < len && inword(p[end]););
		--end;
	} else {
		for (end = beg; ++end < len;) {
			if (p[end] == 'X' || p[end] == 'x') {
				if (end != beg + 1 || p[beg] != '0')
					break;
				continue;
			}
			if (!innum(p[end]))
				break;
		}
d979 18
a996 5
		/* Just a sign isn't a number. */
		if (end == beg && (p[beg] == '+' || p[beg] == '-')) {
noword:			msgq(sp, M_BERR, "Cursor not in a %s",
			    LF_ISSET(V_KEYW) ? "word" : "number");
			return (1);
d998 2
a999 1
		--end;
d1002 31
d1034 13
a1046 2
	 * Getting a keyword implies moving the cursor to its beginning.
	 * Refresh now.
d1048 7
a1054 1
	if (beg != sp->cno) {
d1056 1
a1056 1
		sp->s_refresh(sp, ep);
d1059 9
a1067 11
	/*
	 * XXX
	 * 8-bit clean problem.  Numeric keywords are handled using strtol(3)
	 * and friends.  This would have to be fixed in v_increment and here
	 * to not depend on a trailing NULL.
	 */
	len = (end - beg) + 2;				/* XXX */
	kp->klen = (end - beg) + 1;
	BINC_RET(sp, kp->keyword, kp->kbuflen, len);
	memmove(kp->keyword, p + beg, kp->klen);
	kp->keyword[kp->klen] = '\0';			/* XXX */
d1072 37
a1108 1
 * getcount --
d1111 2
a1112 2
static __inline int
getcount(sp, fkey, countp)
d1117 1
a1118 1
	CH ikey;
d1120 1
a1120 1
	ikey.ch = fkey;
d1123 5
a1127 2
		/* Assume that overflow results in a smaller number. */
		tc = count * 10 + ikey.ch - '0';
d1131 2
a1132 2
				if (getkey(sp, &ikey,
				    TXT_MAPCOMMAND | TXT_MAPNODIGIT))
d1134 3
a1136 2
			} while (isdigit(ikey.ch));
			msgq(sp, M_ERR, "Number larger than %lu", ULONG_MAX);
d1140 1
a1140 1
		if (getkey(sp, &ikey, TXT_MAPCOMMAND | TXT_MAPNODIGIT))
d1142 1
a1142 1
	} while (isdigit(ikey.ch));
d1148 2
a1149 2
 * getkey --
 *	Return the next key.
d1151 2
a1152 2
static __inline int
getkey(sp, ikeyp, map)
d1154 3
a1156 2
	CH *ikeyp;
	u_int map;
d1158 50
a1207 18
	switch (term_key(sp, ikeyp, map)) {
	case INP_EOF:
	case INP_ERR:
		F_SET(sp, S_EXIT_FORCE);
		return (1);
	case INP_INTR:
		/*
		 * !!!
		 * Historically, vi beeped on command level interrupts.
		 *
		 * Historically, vi exited to ex mode if no file was named
		 * on the command line, and two interrupts were generated
		 * in a row.  (Just figured you might want to know that.)
		 */
		(void)sp->s_bell(sp);
		return (1);
	case INP_OK:
		return (0);
d1211 21
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
