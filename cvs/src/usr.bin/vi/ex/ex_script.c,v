head	1.26;
access;
symbols
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.4
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.8
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.6
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.25;
commitid	01nAnartGL7onLD3;

1.25
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.24;
commitid	ruCZ2IKF0FB0ebCr;

1.24
date	2016.04.19.17.42.09;	author martijn;	state Exp;
branches;
next	1.23;
commitid	nms6UAjClEAqNbH2;

1.23
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.22;
commitid	adBvXLg05bJxz6yx;

1.22
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	gtDERb7QyXwKGs62;

1.21
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.20;
commitid	T0XpHzXjuQBl1V3E;

1.20
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.19;
commitid	06bi6U3x4gFFf2G1;

1.19
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2012.12.20.20.28.12;	author naddy;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.03.22.05.46;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.10.14.03.18;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.02.15.19.35;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.02.22.44.06;	author dhartmei;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.17.02.22.56;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.12.06.07.17;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.09.07.04.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.44;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.15.07.13.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.10.16.01.18.36;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: ex_script.c,v 1.24 2016/04/19 17:42:09 martijn Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Brian Hirt.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <bitstring.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>		/* XXX: OSF/1 bug: include before <grp.h> */
#include <grp.h>
#include <limits.h>
#include <poll.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <util.h>

#include "../common/common.h"
#include "../vi/vi.h"
#include "script.h"
#include "pathnames.h"

static void	sscr_check(SCR *);
static int	sscr_getprompt(SCR *);
static int	sscr_init(SCR *);
static int	sscr_insert(SCR *);
static int	sscr_matchprompt(SCR *, char *, size_t, size_t *);
static int	sscr_setprompt(SCR *, char *, size_t);

/*
 * ex_script -- : sc[ript][!] [file]
 *	Switch to script mode.
 *
 * PUBLIC: int ex_script(SCR *, EXCMD *);
 */
int
ex_script(SCR *sp, EXCMD *cmdp)
{
	/* Vi only command. */
	if (!F_ISSET(sp, SC_VI)) {
		msgq(sp, M_ERR,
		    "The script command is only available in vi mode");
		return (1);
	}

	/* Switch to the new file. */
	if (cmdp->argc != 0 && ex_edit(sp, cmdp))
		return (1);

	/* Create the shell, figure out the prompt. */
	if (sscr_init(sp))
		return (1);

	return (0);
}

/*
 * sscr_init --
 *	Create a pty setup for a shell.
 */
static int
sscr_init(SCR *sp)
{
	SCRIPT *sc;
	char *sh, *sh_path;

	/* We're going to need a shell. */
	if (opts_empty(sp, O_SHELL, 0))
		return (1);

	MALLOC_RET(sp, sc, sizeof(SCRIPT));
	sp->script = sc;
	sc->sh_prompt = NULL;
	sc->sh_prompt_len = 0;

	/*
	 * There are two different processes running through this code.
	 * They are the shell and the parent.
	 */
	sc->sh_master = sc->sh_slave = -1;

	if (tcgetattr(STDIN_FILENO, &sc->sh_term) == -1) {
		msgq(sp, M_SYSERR, "tcgetattr");
		goto err;
	}

	/*
	 * Turn off output postprocessing and echo.
	 */
	sc->sh_term.c_oflag &= ~OPOST;
	sc->sh_term.c_cflag &= ~(ECHO|ECHOE|ECHONL|ECHOK);

	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &sc->sh_win) == -1) {
		msgq(sp, M_SYSERR, "tcgetattr");
		goto err;
	}

	if (openpty(&sc->sh_master,
	    &sc->sh_slave, sc->sh_name, &sc->sh_term, &sc->sh_win) == -1) {
		msgq(sp, M_SYSERR, "pty");
		goto err;
	}

	/*
	 * __TK__ huh?
	 * Don't use vfork() here, because the signal semantics differ from
	 * implementation to implementation.
	 */
	switch (sc->sh_pid = fork()) {
	case -1:			/* Error. */
		msgq(sp, M_SYSERR, "fork");
err:		if (sc->sh_master != -1)
			(void)close(sc->sh_master);
		if (sc->sh_slave != -1)
			(void)close(sc->sh_slave);
		return (1);
	case 0:				/* Utility. */
		/*
		 * XXX
		 * So that shells that do command line editing turn it off.
		 */
		if (setenv("TERM", "emacs", 1) == -1 ||
		    setenv("TERMCAP", "emacs:", 1) == -1 ||
		    setenv("EMACS", "t", 1) == -1)
			_exit(126);

		(void)setsid();
		/*
		 * 4.4BSD allocates a controlling terminal using the TIOCSCTTY
		 * ioctl, not by opening a terminal device file.  POSIX 1003.1
		 * doesn't define a portable way to do this.
		 */
		(void)ioctl(sc->sh_slave, TIOCSCTTY, 0);
		(void)close(sc->sh_master);
		(void)dup2(sc->sh_slave, STDIN_FILENO);
		(void)dup2(sc->sh_slave, STDOUT_FILENO);
		(void)dup2(sc->sh_slave, STDERR_FILENO);
		(void)close(sc->sh_slave);

		/* Assumes that all shells have -i. */
		sh_path = O_STR(sp, O_SHELL);
		if ((sh = strrchr(sh_path, '/')) == NULL)
			sh = sh_path;
		else
			++sh;
		execl(sh_path, sh, "-i", (char *)NULL);
		msgq_str(sp, M_SYSERR, sh_path, "execl: %s");
		_exit(127);
	default:			/* Parent. */
		break;
	}

	if (sscr_getprompt(sp))
		return (1);

	F_SET(sp, SC_SCRIPT);
	F_SET(sp->gp, G_SCRWIN);
	return (0);
}

/*
 * sscr_getprompt --
 *	Eat lines printed by the shell until a line with no trailing
 *	carriage return comes; set the prompt from that line.
 */
static int
sscr_getprompt(SCR *sp)
{
	CHAR_T *endp, *p, *t, buf[1024];
	SCRIPT *sc;
	struct pollfd pfd[1];
	recno_t lline;
	size_t llen, len;
	u_int value;
	int nr;

	endp = buf;
	len = sizeof(buf);

	/* Wait up to a second for characters to read. */
	sc = sp->script;
	pfd[0].fd = sc->sh_master;
	pfd[0].events = POLLIN;
	switch (poll(pfd, 1, 5 * 1000)) {
	case -1:		/* Error or interrupt. */
		msgq(sp, M_SYSERR, "poll");
		goto prompterr;
	case  0:		/* Timeout */
		msgq(sp, M_ERR, "Error: timed out");
		goto prompterr;
	default:		/* Characters to read. */
		break;
	}

	/* Read the characters. */
more:	len = sizeof(buf) - (endp - buf);
	switch (nr = read(sc->sh_master, endp, len)) {
	case  0:			/* EOF. */
		msgq(sp, M_ERR, "Error: shell: EOF");
		goto prompterr;
	case -1:			/* Error or interrupt. */
		msgq(sp, M_SYSERR, "shell");
		goto prompterr;
	default:
		endp += nr;
		break;
	}

	/* If any complete lines, push them into the file. */
	for (p = t = buf; p < endp; ++p) {
		value = KEY_VAL(sp, *p);
		if (value == K_CR || value == K_NL) {
			if (db_last(sp, &lline) ||
			    db_append(sp, 0, lline, t, p - t))
				goto prompterr;
			t = p + 1;
		}
	}
	if (p > buf) {
		memmove(buf, t, endp - t);
		endp = buf + (endp - t);
	}
	if (endp == buf)
		goto more;

	/* Wait up 1/10 of a second to make sure that we got it all. */
	switch (poll(pfd, 1, 100)) {
	case -1:		/* Error or interrupt. */
		msgq(sp, M_SYSERR, "poll");
		goto prompterr;
	case  0:		/* Timeout */
		break;
	default:		/* Characters to read. */
		goto more;
	}

	/* Timed out, so theoretically we have a prompt. */
	llen = endp - buf;
	endp = buf;

	/* Append the line into the file. */
	if (db_last(sp, &lline) || db_append(sp, 0, lline, buf, llen)) {
prompterr:	sscr_end(sp);
		return (1);
	}

	return (sscr_setprompt(sp, buf, llen));
}

/*
 * sscr_exec --
 *	Take a line and hand it off to the shell.
 *
 * PUBLIC: int sscr_exec(SCR *, recno_t);
 */
int
sscr_exec(SCR *sp, recno_t lno)
{
	SCRIPT *sc;
	recno_t last_lno;
	size_t blen, len, last_len, tlen;
	int isempty, matchprompt, nw, rval;
	char *bp, *p;

	/* If there's a prompt on the last line, append the command. */
	if (db_last(sp, &last_lno))
		return (1);
	if (db_get(sp, last_lno, DBG_FATAL, &p, &last_len))
		return (1);
	if (sscr_matchprompt(sp, p, last_len, &tlen) && tlen == 0) {
		matchprompt = 1;
		GET_SPACE_RET(sp, bp, blen, last_len + 128);
		memmove(bp, p, last_len);
	} else
		matchprompt = 0;

	/* Get something to execute. */
	if (db_eget(sp, lno, &p, &len, &isempty)) {
		if (isempty)
			goto empty;
		goto err1;
	}

	/* Empty lines aren't interesting. */
	if (len == 0)
		goto empty;

	/* Delete any prompt. */
	if (sscr_matchprompt(sp, p, len, &tlen)) {
		if (tlen == len) {
empty:			msgq(sp, M_BERR, "No command to execute");
			goto err1;
		}
		p += (len - tlen);
		len = tlen;
	}

	/* Push the line to the shell. */
	sc = sp->script;
	if ((nw = write(sc->sh_master, p, len)) != len)
		goto err2;
	rval = 0;
	if (write(sc->sh_master, "\n", 1) != 1) {
err2:		if (nw == 0)
			errno = EIO;
		msgq(sp, M_SYSERR, "shell");
		goto err1;
	}

	if (matchprompt) {
		ADD_SPACE_RET(sp, bp, blen, last_len + len);
		memmove(bp + last_len, p, len);
		if (db_set(sp, last_lno, bp, last_len + len))
err1:			rval = 1;
	}
	if (matchprompt)
		FREE_SPACE(sp, bp, blen);
	return (rval);
}

/*
 * sscr_check_input -
 *	Check for input from command input or scripting windows.
 *
 * PUBLIC: int sscr_check_input(SCR *sp);
 */
int
sscr_check_input(SCR *sp)
{
	GS *gp;
	SCR *tsp;
	struct pollfd *pfd;
	int nfds, rval;

	gp = sp->gp;
	rval = 0;

	/* Allocate space for pfd. */   
	nfds = 1;
	TAILQ_FOREACH(tsp, &gp->dq, q)
		if (F_ISSET(sp, SC_SCRIPT))
			nfds++;
	pfd = calloc(nfds, sizeof(struct pollfd));
	if (pfd == NULL) {
		msgq(sp, M_SYSERR, "malloc");
		return (1);
	}

	/* Setup events bitmasks. */
	pfd[0].fd = STDIN_FILENO;
	pfd[0].events = POLLIN;
	nfds = 1;
	TAILQ_FOREACH(tsp, &gp->dq, q)
		if (F_ISSET(sp, SC_SCRIPT)) {
			pfd[nfds].fd = sp->script->sh_master;
			pfd[nfds].events = POLLIN;
			nfds++;
		}

loop:
	/* Check for input. */
	switch (poll(pfd, nfds, INFTIM)) {
	case -1:
		msgq(sp, M_SYSERR, "poll");
		rval = 1;
		/* FALLTHROUGH */
	case 0:
		goto done;
	default:
		break;
	}

	/* Only insert from the scripting windows if no command input */
	if (!(pfd[0].revents & POLLIN)) {
		nfds = 1;
		TAILQ_FOREACH(tsp, &gp->dq, q)
			if (F_ISSET(sp, SC_SCRIPT)) {
				if ((pfd[nfds].revents & POLLHUP) && sscr_end(sp))
					goto done;
				if ((pfd[nfds].revents & POLLIN) && sscr_insert(sp))
					goto done;
				nfds++;
			}
		goto loop;
	}
done:
	free(pfd);
	return (rval);
}

/*
 * sscr_input --
 *	Read any waiting shell input.
 *
 * PUBLIC: int sscr_input(SCR *);
 */
int
sscr_input(SCR *sp)
{
	GS *gp;
	struct pollfd *pfd;
	int nfds, rval;

	gp = sp->gp;
	rval = 0;

	/* Allocate space for pfd. */
	nfds = 0;
	TAILQ_FOREACH(sp, &gp->dq, q)
		if (F_ISSET(sp, SC_SCRIPT))
			nfds++;
	if (nfds == 0)
		return (0);
	pfd = calloc(nfds, sizeof(struct pollfd));
	if (pfd == NULL) {
		msgq(sp, M_SYSERR, "malloc");
		return (1);
	}

	/* Setup events bitmasks. */
	nfds = 0;
	TAILQ_FOREACH(sp, &gp->dq, q)
		if (F_ISSET(sp, SC_SCRIPT)) {
			pfd[nfds].fd = sp->script->sh_master;
			pfd[nfds].events = POLLIN;
			nfds++;
		}

loop:
	/* Check for input. */
	switch (poll(pfd, nfds, 0)) {
	case -1:
		msgq(sp, M_SYSERR, "poll");
		rval = 1;
		/* FALLTHROUGH */
	case 0:
		goto done;
	default:
		break;
	}

	/* Read the input. */
	nfds = 0;
	TAILQ_FOREACH(sp, &gp->dq, q)
		if (F_ISSET(sp, SC_SCRIPT)) {
			if ((pfd[nfds].revents & POLLHUP) && sscr_end(sp))
				goto done;
			if ((pfd[nfds].revents & POLLIN) && sscr_insert(sp))
				goto done;
			nfds++;
		}
	goto loop;
done:
	free(pfd);
	return (rval);
}

/*
 * sscr_insert --
 *	Take a line from the shell and insert it into the file.
 */
static int
sscr_insert(SCR *sp)
{
	CHAR_T *endp, *p, *t;
	SCRIPT *sc;
	struct pollfd pfd[1];
	recno_t lno;
	size_t blen, len, tlen;
	u_int value;
	int nr, rval;
	char *bp;

	/* Find out where the end of the file is. */
	if (db_last(sp, &lno))
		return (1);

#define	MINREAD	1024
	GET_SPACE_RET(sp, bp, blen, MINREAD);
	endp = bp;

	/* Read the characters. */
	rval = 1;
	sc = sp->script;
more:	switch (nr = read(sc->sh_master, endp, MINREAD)) {
	case  0:			/* EOF; shell just exited. */
		sscr_end(sp);
		rval = 0;
		goto ret;
	case -1:			/* Error or interrupt. */
		msgq(sp, M_SYSERR, "shell");
		goto ret;
	default:
		endp += nr;
		break;
	}

	/* Append the lines into the file. */
	for (p = t = bp; p < endp; ++p) {
		value = KEY_VAL(sp, *p);
		if (value == K_CR || value == K_NL) {
			len = p - t;
			if (db_append(sp, 1, lno++, t, len))
				goto ret;
			t = p + 1;
		}
	}
	if (p > t) {
		len = p - t;
		/*
		 * If the last thing from the shell isn't another prompt, wait
		 * up to 1/10 of a second for more stuff to show up, so that
		 * we don't break the output into two separate lines.  Don't
		 * want to hang indefinitely because some program is hanging,
		 * confused the shell, or whatever.
		 */
		if (!sscr_matchprompt(sp, t, len, &tlen) || tlen != 0) {
			pfd[0].fd = sc->sh_master;
			pfd[0].events = POLLIN;
			if (poll(pfd, 1, 100) > 0) {
				memmove(bp, t, len);
				endp = bp + len;
				goto more;
			}
		}
		if (sscr_setprompt(sp, t, len))
			return (1);
		if (db_append(sp, 1, lno++, t, len))
			goto ret;
	}

	/* The cursor moves to EOF. */
	sp->lno = lno;
	sp->cno = len ? len - 1 : 0;
	rval = vs_refresh(sp, 1);

ret:	FREE_SPACE(sp, bp, blen);
	return (rval);
}

/*
 * sscr_setprompt --
 *
 * Set the prompt to the last line we got from the shell.
 *
 */
static int
sscr_setprompt(SCR *sp, char *buf, size_t len)
{
	SCRIPT *sc;

	sc = sp->script;
	if (sc->sh_prompt)
		free(sc->sh_prompt);
	MALLOC(sp, sc->sh_prompt, len + 1);
	if (sc->sh_prompt == NULL) {
		sscr_end(sp);
		return (1);
	}
	memmove(sc->sh_prompt, buf, len);
	sc->sh_prompt_len = len;
	sc->sh_prompt[len] = '\0';
	return (0);
}

/*
 * sscr_matchprompt --
 *	Check to see if a line matches the prompt.  Nul's indicate
 *	parts that can change, in both content and size.
 */
static int
sscr_matchprompt(SCR *sp, char *lp, size_t line_len, size_t *lenp)
{
	SCRIPT *sc;
	size_t prompt_len;
	char *pp;

	sc = sp->script;
	if (line_len < (prompt_len = sc->sh_prompt_len))
		return (0);

	for (pp = sc->sh_prompt;
	    prompt_len && line_len; --prompt_len, --line_len) {
		if (*pp == '\0') {
			for (; prompt_len && *pp == '\0'; --prompt_len, ++pp);
			if (!prompt_len)
				return (0);
			for (; line_len && *lp != *pp; --line_len, ++lp);
			if (!line_len)
				return (0);
		}
		if (*pp++ != *lp++)
			break;
	}

	if (prompt_len)
		return (0);
	if (lenp != NULL)
		*lenp = line_len;
	return (1);
}

/*
 * sscr_end --
 *	End the pipe to a shell.
 *
 * PUBLIC: int sscr_end(SCR *);
 */
int
sscr_end(SCR *sp)
{
	SCRIPT *sc;

	if ((sc = sp->script) == NULL)
		return (0);

	/* Turn off the script flags. */
	F_CLR(sp, SC_SCRIPT);
	sscr_check(sp);

	/* Close down the parent's file descriptors. */
	if (sc->sh_master != -1)
	    (void)close(sc->sh_master);
	if (sc->sh_slave != -1)
	    (void)close(sc->sh_slave);

	/* This should have killed the child. */
	(void)proc_wait(sp, sc->sh_pid, "script-shell", 0, 0);

	/* Free memory. */
	free(sc->sh_prompt);
	free(sc);
	sp->script = NULL;

	return (0);
}

/*
 * sscr_check --
 *	Set/clear the global scripting bit.
 */
static void
sscr_check(SCR *sp)
{
	GS *gp;

	gp = sp->gp;
	TAILQ_FOREACH(sp, &gp->dq, q)
		if (F_ISSET(sp, SC_SCRIPT)) {
			F_SET(gp, G_SCRWIN);
			return;
		}
	F_CLR(gp, G_SCRWIN);
}
@


1.25
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d188 1
a188 1
	char *endp, *p, *t, buf[1024];
d484 1
a484 1
	char *endp, *p, *t;
@


1.24
log
@Remove not implemented decliration of sscr_pty.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.23 2016/01/06 22:28:52 millert Exp $	*/
d188 1
a188 1
	CHAR_T *endp, *p, *t, buf[1024];
d484 1
a484 1
	CHAR_T *endp, *p, *t;
@


1.23
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.22 2015/12/07 20:39:19 mmcc Exp $	*/
a46 1
static int	sscr_pty(int *, int *, char *, size_t, struct termios *, void *);
@


1.22
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.21 2014/11/12 16:29:04 millert Exp $	*/
d62 1
a62 1
		    "150|The script command is only available in vi mode");
d311 1
a311 1
empty:			msgq(sp, M_BERR, "151|No command to execute");
@


1.21
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.20 2014/11/12 04:28:41 bentley Exp $	*/
d91 1
a91 1
	MALLOC_RET(sp, sc, SCRIPT *, sizeof(SCRIPT));
d575 1
a575 1
	MALLOC(sp, sc->sh_prompt, char *, len + 1);
@


1.20
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.19 2013/11/28 22:12:40 krw Exp $	*/
a147 1
#ifdef TIOCSCTTY
d151 1
a151 2
		 * doesn't define a portable way to do this.  If TIOCSCTTY is
		 * not available, hope that the open does it.
a153 1
#endif
@


1.19
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.18 2012/12/20 20:28:12 naddy Exp $	*/
d57 1
a57 3
ex_script(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d82 1
a82 2
sscr_init(sp)
	SCR *sp;
d190 1
a190 2
sscr_getprompt(sp)
	SCR *sp;
d280 1
a280 3
sscr_exec(sp, lno)
	SCR *sp;
	recno_t lno;
d421 1
a421 2
sscr_input(sp)
	SCR *sp;
d486 1
a486 2
sscr_insert(sp)
	SCR *sp;
d571 1
a571 4
sscr_setprompt(sp, buf, len)
	SCR *sp;
	char *buf;
	size_t len;
d595 1
a595 4
sscr_matchprompt(sp, lp, line_len, lenp)
	SCR *sp;
	char *lp;
	size_t line_len, *lenp;
d633 1
a633 2
sscr_end(sp)
	SCR *sp;
d666 1
a666 2
sscr_check(sp)
	SCR *sp;
@


1.18
log
@use openpty() rather than hand-rolled pty opening code; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.17 2012/12/03 22:05:46 millert Exp $	*/
d369 1
a369 1
	CIRCLEQ_FOREACH(tsp, &gp->dq, q)
d382 1
a382 1
	CIRCLEQ_FOREACH(tsp, &gp->dq, q)
d405 1
a405 1
		CIRCLEQ_FOREACH(tsp, &gp->dq, q)
d439 1
a439 1
	CIRCLEQ_FOREACH(sp, &gp->dq, q)
d452 1
a452 1
	CIRCLEQ_FOREACH(sp, &gp->dq, q)
d474 1
a474 1
	CIRCLEQ_FOREACH(sp, &gp->dq, q)
d687 1
a687 1
	CIRCLEQ_FOREACH(sp, &gp->dq, q)
@


1.17
log
@Fix hang when exiting shell in script mode.  OK naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.16 2009/10/27 23:59:47 deraadt Exp $	*/
a20 3
#ifdef HAVE_SYS5_PTY
#include <sys/stropts.h>
#endif
d35 1
a115 1
#ifdef TIOCGWINSZ
d121 2
a122 10
	if (sscr_pty(&sc->sh_master,
	    &sc->sh_slave, sc->sh_name, sizeof(sc->sh_name),
	    &sc->sh_term, &sc->sh_win) == -1) {
		msgq(sp, M_SYSERR, "pty");
		goto err;
	}
#else
	if (sscr_pty(&sc->sh_master,
	    &sc->sh_slave, sc->sh_name, sizeof(sc->sh_name),
	    &sc->sh_term, NULL) == -1) {
a125 1
#endif
a693 175

#ifdef HAVE_SYS5_PTY
static int ptys_open(int, char *);
static int ptym_open(char *, size_t);

static int
sscr_pty(amaster, aslave, name, namelen, termp, winp)
	int *amaster, *aslave;
	char *name;
	size_t namelen;
	struct termios *termp;
	void *winp;
{
	int master, slave, ttygid;

	/* open master terminal */
	if ((master = ptym_open(name, namelen)) < 0)  {
		errno = ENOENT;	/* out of ptys */
		return (-1);
	}

	/* open slave terminal */
	if ((slave = ptys_open(master, name)) >= 0) {
		*amaster = master;
		*aslave = slave;
	} else {
		errno = ENOENT;	/* out of ptys */
		return (-1);
	}

	if (termp)
		(void) tcsetattr(slave, TCSAFLUSH, termp);
#ifdef TIOCSWINSZ
	if (winp != NULL)
		(void) ioctl(slave, TIOCSWINSZ, (struct winsize *)winp);
#endif
	return (0);
}

/*
 * ptym_open --
 *	This function opens a master pty and returns the file descriptor
 *	to it.  pts_name is also returned which is the name of the slave.
 */
static int
ptym_open(pts_name, pts_namelen)
	char *pts_name;
	size_t pts_namelen;
{
	int fdm;
	char *ptr, *ptsname();

	strlcpy(pts_name, _PATH_SYSV_PTY, pts_namelen);
	if ((fdm = open(pts_name, O_RDWR)) < 0 )
		return (-1);

	if (grantpt(fdm) < 0) {
		close(fdm);
		return (-2);
	}

	if (unlockpt(fdm) < 0) {
		close(fdm);
		return (-3);
	}

	if (unlockpt(fdm) < 0) {
		close(fdm);
		return (-3);
	}

	/* get slave's name */
	if ((ptr = ptsname(fdm)) == NULL) {
		close(fdm);
		return (-3);
	}
	strlcpy(pts_name, ptr, pts_namelen);
	return (fdm);
}

/*
 * ptys_open --
 *	This function opens the slave pty.
 */
static int
ptys_open(fdm, pts_name)
	int fdm;
	char *pts_name;
{
	int fds;

	if ((fds = open(pts_name, O_RDWR)) < 0) {
		close(fdm);
		return (-5);
	}

	if (ioctl(fds, I_PUSH, "ptem") < 0) {
		close(fds);
		close(fdm);
		return (-6);
	}

	if (ioctl(fds, I_PUSH, "ldterm") < 0) {
		close(fds);
		close(fdm);
		return (-7);
	}

	if (ioctl(fds, I_PUSH, "ttcompat") < 0) {
		close(fds);
		close(fdm);
		return (-8);
	}

	return (fds);
}

#else /* !HAVE_SYS5_PTY */

static int
sscr_pty(amaster, aslave, name, namelen, termp, winp)
	int *amaster, *aslave;
	char *name;
	size_t namelen;
	struct termios *termp;
	void *winp;
{
	static char line[] = "/dev/ptyXX";
	char *cp1, *cp2;
	int master, slave, ttygid;
	struct group *gr;

	if ((gr = getgrnam("tty")) != NULL)
		ttygid = gr->gr_gid;
	else
		ttygid = -1;

	for (cp1 = "pqrs"; *cp1; cp1++) {
		line[8] = *cp1;
		for (cp2 = "0123456789abcdef"; *cp2; cp2++) {
			line[5] = 'p';
			line[9] = *cp2;
			if ((master = open(line, O_RDWR, 0)) == -1) {
				if (errno == ENOENT)
					return (-1);	/* out of ptys */
			} else {
				line[5] = 't';
				(void) chown(line, getuid(), ttygid);
				(void) chmod(line, S_IRUSR|S_IWUSR|S_IWGRP);
#ifdef HAVE_REVOKE
				(void) revoke(line);
#endif
				if ((slave = open(line, O_RDWR, 0)) != -1) {
					*amaster = master;
					*aslave = slave;
					if (name)
						strlcpy(name, line, namelen);
					if (termp)
						(void) tcsetattr(slave, 
							TCSAFLUSH, termp);
#ifdef TIOCSWINSZ
					if (winp)
						(void) ioctl(slave, TIOCSWINSZ, 
							(char *)winp);
#endif
					return (0);
				}
				(void) close(master);
			}
		}
	}
	errno = ENOENT;	/* out of ptys */
	return (-1);
}
#endif /* HAVE_SYS5_PTY */
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.15 2009/06/10 14:03:18 millert Exp $	*/
d419 1
a419 1
				if ((pfd[nfds++].revents & POLLIN) && sscr_insert(sp))
d421 3
d488 3
a490 1
			if ((pfd[nfds++].revents & POLLIN) && sscr_insert(sp))
d492 1
@


1.15
log
@Use poll() instead of select().  The sscr_check_input() bit is
adapted from nvi 1.81.  Tested by several people during the hackathon.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.14 2007/09/02 15:19:35 deraadt Exp $	*/
a15 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_script.c	10.30 (Berkeley) 9/24/96";
#endif /* not lint */
@


1.14
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.13 2006/01/08 21:05:40 miod Exp $	*/
a23 3
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
d367 67
d444 2
a445 3
	struct timeval tv;
	fd_set *rdfd;
	int maxfd;
d448 1
d450 2
a451 2
	/* Allocate space for rdfd. */
	maxfd = STDIN_FILENO;
d453 6
a458 4
		if (F_ISSET(sp, SC_SCRIPT) && sp->script->sh_master > maxfd)
			maxfd = sp->script->sh_master;
	rdfd = (fd_set *)calloc(howmany(maxfd + 1, NFDBITS), sizeof(fd_mask));
	if (rdfd == NULL) {
d463 2
a464 5
loop:	memset(rdfd, 0, howmany(maxfd + 1, NFDBITS) * sizeof(fd_mask));
	tv.tv_sec = 0;
	tv.tv_usec = 0;

	/* Set up the input mask. */
d466 5
a470 2
		if (F_ISSET(sp, SC_SCRIPT))
			FD_SET(sp->script->sh_master, rdfd);
d472 1
d474 1
a474 1
	switch (select(maxfd + 1, rdfd, NULL, NULL, &tv)) {
d476 3
a478 3
		msgq(sp, M_SYSERR, "select");
		free(rdfd);
		return (1);
d480 1
a480 2
		free(rdfd);
		return (0);
d486 1
d488 3
a490 4
		if (F_ISSET(sp, SC_SCRIPT) &&
		    FD_ISSET(sp->script->sh_master, rdfd) && sscr_insert(sp)) {
			free(rdfd);
			return (1);
d493 3
@


1.13
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.12 2005/10/17 19:12:16 otto Exp $	*/
d391 1
a391 1
	rdfd = (fd_set *)malloc(howmany(maxfd + 1, NFDBITS) * sizeof(fd_mask));
@


1.12
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.11 2003/09/02 22:44:06 dhartmei Exp $	*/
d382 1
a382 1
	int maxfd, nfd;
a436 1
	struct timeval tv;
@


1.11
log
@switch to dynamic fd_set and poll. patch entirely from millert@@.
ok deraadt@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.10 2003/04/17 02:22:56 itojun Exp $	*/
d388 1
a388 1
	for (sp = gp->dq.cqh_first; sp != (void *)&gp->dq; sp = sp->q.cqe_next)
d402 1
a402 1
	for (sp = gp->dq.cqh_first; sp != (void *)&gp->dq; sp = sp->q.cqe_next)
d420 1
a420 1
	for (sp = gp->dq.cqh_first; sp != (void *)&gp->dq; sp = sp->q.cqe_next)
d629 1
a629 1
	for (sp = gp->dq.cqh_first; sp != (void *)&gp->dq; sp = sp->q.cqe_next)
@


1.10
log
@eliminate strcpy/sprintf.  reviewed by deraadt and millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.9 2002/06/12 06:07:17 mpech Exp $	*/
d40 1
a214 1
	struct timeval tv;
d217 1
a217 1
	fd_set fdset;
a222 1
	FD_ZERO(&fdset);
a226 2
	tv.tv_sec = 5;
	tv.tv_usec = 0;
d228 3
a230 2
	FD_SET(sc->sh_master, &fdset);
	switch (select(sc->sh_master + 1, &fdset, NULL, NULL, &tv)) {
d232 1
a232 1
		msgq(sp, M_SYSERR, "select");
d237 1
a237 1
	case  1:		/* Characters to read. */
d273 1
a273 3
	tv.tv_sec = 0;
	tv.tv_usec = 100000;
	switch (select(sc->sh_master + 1, &fdset, NULL, NULL, &tv)) {
d275 1
a275 1
		msgq(sp, M_SYSERR, "select");
d279 1
a279 1
	case  1:		/* Characters to read. */
d380 3
a382 3
	struct timeval poll;
	fd_set rdfd;
	int maxfd;
d386 14
a399 4
loop:	maxfd = 0;
	FD_ZERO(&rdfd);
	poll.tv_sec = 0;
	poll.tv_usec = 0;
d403 2
a404 5
		if (F_ISSET(sp, SC_SCRIPT)) {
			FD_SET(sp->script->sh_master, &rdfd);
			if (sp->script->sh_master > maxfd)
				maxfd = sp->script->sh_master;
		}
d407 1
a407 1
	switch (select(maxfd + 1, &rdfd, NULL, NULL, &poll)) {
d410 1
d413 1
d422 2
a423 1
		    FD_ISSET(sp->script->sh_master, &rdfd) && sscr_insert(sp))
d425 1
d440 1
a440 1
	fd_set rdfd;
d491 3
a493 6
			tv.tv_sec = 0;
			tv.tv_usec = 100000;
			FD_ZERO(&rdfd);
			FD_SET(sc->sh_master, &rdfd);
			if (select(sc->sh_master + 1,
			    &rdfd, NULL, NULL, &tv) == 1) {
@


1.9
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.8 2002/02/16 21:27:57 millert Exp $	*/
d55 1
a55 1
static int	sscr_pty(int *, int *, char *, struct termios *, void *);
d131 2
a132 1
	    &sc->sh_slave, sc->sh_name, &sc->sh_term, &sc->sh_win) == -1) {
d138 2
a139 1
	    &sc->sh_slave, sc->sh_name, &sc->sh_term, NULL) == -1) {
d635 1
a635 1
static int ptym_open(char *);
d638 1
a638 1
sscr_pty(amaster, aslave, name, termp, winp)
d641 1
d648 1
a648 1
	if ((master = ptym_open(name)) < 0)  {
d677 1
a677 1
ptym_open(pts_name)
d679 1
d684 1
a684 1
	strcpy(pts_name, _PATH_SYSV_PTY);
d708 1
a708 1
	strcpy(pts_name, ptr);
d752 1
a752 1
sscr_pty(amaster, aslave, name, termp, winp)
d755 1
d788 1
a788 1
						strcpy(name, line);
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.7 2001/11/19 19:02:17 mpech Exp $	*/
d602 1
a602 1
	(void)proc_wait(sp, (long)sc->sh_pid, "script-shell", 0, 0);
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.6 2001/07/09 07:04:57 deraadt Exp $	*/
d50 7
a56 7
static void	sscr_check __P((SCR *));
static int	sscr_getprompt __P((SCR *));
static int	sscr_init __P((SCR *));
static int	sscr_insert __P((SCR *));
static int	sscr_matchprompt __P((SCR *, char *, size_t, size_t *));
static int	sscr_pty __P((int *, int *, char *, struct termios *, void *));
static int	sscr_setprompt __P((SCR *, char *, size_t));
d62 1
a62 1
 * PUBLIC: int ex_script __P((SCR *, EXCMD *));
d302 1
a302 1
 * PUBLIC: int sscr_exec __P((SCR *, recno_t));
d375 1
a375 1
 * PUBLIC: int sscr_input __P((SCR *));
d580 1
a580 1
 * PUBLIC: int sscr_end __P((SCR *));
d632 2
a633 2
static int ptys_open __P((int, char *));
static int ptym_open __P((char *));
@


1.6
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_script.c,v 1.5 2001/01/29 01:58:44 niklas Exp $	*/
d755 2
a756 2
	register char *cp1, *cp2;
	register int master, slave, ttygid;
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d188 1
a188 1
		execl(sh_path, sh, "-i", NULL);
@


1.4
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 2
@


1.3
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d159 4
a162 3
		(void)setenv("TERM", "emacs", 1);
		(void)setenv("TERMCAP", "emacs:", 1);
		(void)setenv("EMACS", "t", 1);
@


1.2
log
@new vi
@
text
@d16 1
a16 1
static const char sccsid[] = "@@(#)ex_script.c	10.29 (Berkeley) 5/12/96";
d196 1
a196 1
	F_SET(sp->gp, G_SCRIPT);
d622 1
a622 1
			F_SET(gp, G_SCRIPT);
d625 1
a625 1
	F_CLR(gp, G_SCRIPT);
@


1.1
log
@Initial revision
@
text
@d4 2
d7 2
a8 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d10 1
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d13 2
d16 1
a16 1
static char sccsid[] = "@@(#)ex_script.c	8.19 (Berkeley) 8/17/94";
d22 7
d34 3
a37 2
#include <signal.h>
#include <stdio.h>
d43 2
a44 6
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
d46 1
d48 7
a54 9
/*
 * XXX
 */
int openpty __P((int *, int *, char *, struct termios *, struct winsize *));

static int sscr_getprompt __P((SCR *, EXF *));
static int sscr_init __P((SCR *, EXF *));
static int sscr_matchprompt __P((SCR *, char *, size_t, size_t *));
static int sscr_setprompt __P((SCR *, char *, size_t));
d58 1
d60 1
a60 1
 *	Switch to script mode.
d63 1
a63 1
ex_script(sp, ep, cmdp)
d65 1
a65 2
	EXF *ep;
	EXCMDARG *cmdp;
d68 1
a68 1
	if (!IN_VI_MODE(sp)) {
d70 1
a70 1
		    "The script command is only available in vi mode");
d75 1
a75 1
	if (cmdp->argc != 0 && ex_edit(sp, ep, cmdp))
d78 2
a79 7
	/*
	 * Create the shell, figure out the prompt.
	 *
	 * !!!
	 * The files just switched, use sp->ep.
	 */
	if (sscr_init(sp, sp->ep))
d90 1
a90 1
sscr_init(sp, ep)
a91 1
	EXF *ep;
d96 4
d122 1
d128 1
a128 1
	if (openpty(&sc->sh_master,
d130 1
a130 1
		msgq(sp, M_SYSERR, "openpty");
d133 7
d142 1
a145 1
	SIGBLOCK(sp->gp);
a147 2
		SIGUNBLOCK(sp->gp);

a154 3
		/* The utility has default signal behavior. */
		sig_end();

d159 3
a161 3
		(void)putenv("TERM=emacs");
		(void)putenv("TERMCAP=emacs:");
		(void)putenv("EMACS=t");
d186 1
a186 2
		msgq(sp, M_ERR,
		    "Error: execl: %s: %s", sh_path, strerror(errno));
a188 1
		SIGUNBLOCK(sp->gp);
d192 1
a192 1
	if (sscr_getprompt(sp, ep))
d195 2
a196 1
	F_SET(sp, S_REDRAW | S_SCRIPT);
a197 1

d206 1
a206 1
sscr_getprompt(sp, ep)
a207 1
	EXF *ep;
d256 2
a257 2
			if (file_lline(sp, ep, &lline) ||
			    file_aline(sp, ep, 0, lline, t, p - t))
d287 1
a287 2
	if (file_lline(sp, ep, &lline) ||
	    file_aline(sp, ep, 0, lline, buf, llen)) {
d298 2
d302 1
a302 1
sscr_exec(sp, ep, lno)
a303 1
	EXF *ep;
d309 1
a309 1
	int matchprompt, nw, rval;
d313 1
a313 1
	if (file_lline(sp, ep, &last_lno))
d315 1
a315 2
	if ((p = file_gline(sp, ep, last_lno, &last_len)) == NULL) {
		GETLINE_ERR(sp, last_lno);
a316 1
	}
d325 2
a326 4
	if ((p = file_gline(sp, ep, lno, &len)) == NULL) {
		if (file_lline(sp, ep, &lno))
			goto err1;
		if (lno == 0)
a327 2
		else
			GETLINE_ERR(sp, lno);
d338 1
a338 1
empty:			msgq(sp, M_BERR, "Nothing to execute");
d360 1
a360 1
		if (file_sline(sp, ep, last_lno, bp, last_len + len))
d370 3
a372 1
 *	Take a line from the shell and insert it into the file.
d378 47
a426 1
	EXF *ep;
d428 1
d436 1
a436 2
	ep = sp->ep;
	if (file_lline(sp, ep, &lno))
a448 1
		F_CLR(sp, S_SCRIPT);
d464 1
a464 1
			if (file_aline(sp, ep, 1, lno++, t, len))
d481 2
a482 2
			FD_SET(sc->sh_master, &sp->rdfd);
			FD_CLR(STDIN_FILENO, &sp->rdfd);
d484 1
a484 1
			    &sp->rdfd, NULL, NULL, &tv) == 1) {
d492 1
a492 1
		if (file_aline(sp, ep, 1, lno++, t, len))
d499 1
a499 1
	rval = sp->s_refresh(sp, ep);
d514 1
a514 1
	char* buf;
d521 1
a521 1
		FREE(sc->sh_prompt, sc->sh_prompt_len);
d576 2
a583 1
	int rval;
d588 3
a590 2
	/* Turn off the script flag. */
	F_CLR(sp, S_SCRIPT);
d599 1
a599 1
	rval = proc_wait(sp, (long)sc->sh_pid, "script-shell", 0);
d602 2
a603 2
	FREE(sc->sh_prompt, sc->sh_prompt_len);
	FREE(sc, sizeof(SCRIPT));
d606 191
a796 1
	return (rval);
d798 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
