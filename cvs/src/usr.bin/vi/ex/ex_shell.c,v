head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.10
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.6
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.18
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.14
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.12
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.10
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.14
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.12
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.10
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.03.28.12.54.37;	author bcallah;	state Exp;
branches;
next	1.14;
commitid	SxN2AJ1XDjDCBdrf;

1.14
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	Uu5nFG3wCl0LACBb;

1.13
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.12;
commitid	06bi6U3x4gFFf2G1;

1.12
date	2014.11.10.21.31.42;	author tedu;	state Exp;
branches;
next	1.11;
commitid	69Pn8C3VMgeMEZUy;

1.11
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.12.06.07.17;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.09.07.04.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.44;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.08.23.13.18.17;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.37;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.54;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@vi was using two separate isblank functions: one defined in <ctype.h> and
the other #defined in common/key.h. There is no reason to have both. For
consistency use the isblank function from <ctype.h>, remove the #define in
common/key.h, and add #include <ctype.h> to the files that were missing the
header.

ok brynet@@
@
text
@/*	$OpenBSD: ex_shell.c,v 1.14 2015/01/16 06:40:14 deraadt Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/queue.h>
#include <sys/wait.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

/*
 * ex_shell -- :sh[ell]
 *	Invoke the program named in the SHELL environment variable
 *	with the argument -i.
 *
 * PUBLIC: int ex_shell(SCR *, EXCMD *);
 */
int
ex_shell(SCR *sp, EXCMD *cmdp)
{
	int rval;
	char buf[PATH_MAX];

	/* We'll need a shell. */
	if (opts_empty(sp, O_SHELL, 0))
		return (1);

	/*
	 * XXX
	 * Assumes all shells use -i.
	 */
	(void)snprintf(buf, sizeof(buf), "%s -i", O_STR(sp, O_SHELL));

	/* Restore the window name. */
	(void)sp->gp->scr_rename(sp, NULL, 0);

	/* If we're still in a vi screen, move out explicitly. */
	rval = ex_exec_proc(sp, cmdp, buf, NULL, !F_ISSET(sp, SC_SCR_EXWROTE));

	/* Set the window name. */
	(void)sp->gp->scr_rename(sp, sp->frp->name, 1);

	/*
	 * !!!
	 * Historically, vi didn't require a continue message after the
	 * return of the shell.  Match it.
	 */
	F_SET(sp, SC_EX_WAIT_NO);

	return (rval);
}

/*
 * ex_exec_proc --
 *	Run a separate process.
 *
 * PUBLIC: int ex_exec_proc(SCR *, EXCMD *, char *, const char *, int);
 */
int
ex_exec_proc(SCR *sp, EXCMD *cmdp, char *cmd, const char *msg,
    int need_newline)
{
	GS *gp;
	const char *name;
	pid_t pid;

	gp = sp->gp;

	/* We'll need a shell. */
	if (opts_empty(sp, O_SHELL, 0))
		return (1);

	/* Enter ex mode. */
	if (F_ISSET(sp, SC_VI)) {
		if (gp->scr_screen(sp, SC_EX)) {
			ex_emsg(sp, cmdp->cmd->name, EXM_NOCANON);
			return (1);
		}
		(void)gp->scr_attr(sp, SA_ALTERNATE, 0);
		F_SET(sp, SC_SCR_EX | SC_SCR_EXWROTE);
	}

	/* Put out additional newline, message. */
	if (need_newline)
		(void)ex_puts(sp, "\n");
	if (msg != NULL) {
		(void)ex_puts(sp, msg);
		(void)ex_puts(sp, "\n");
	}
	(void)ex_fflush(sp);

	switch (pid = vfork()) {
	case -1:			/* Error. */
		msgq(sp, M_SYSERR, "vfork");
		return (1);
	case 0:				/* Utility. */
		if ((name = strrchr(O_STR(sp, O_SHELL), '/')) == NULL)
			name = O_STR(sp, O_SHELL);
		else
			++name;
		execl(O_STR(sp, O_SHELL), name, "-c", cmd, (char *)NULL);
		msgq_str(sp, M_SYSERR, O_STR(sp, O_SHELL), "execl: %s");
		_exit(127);
		/* NOTREACHED */
	default:			/* Parent. */
		return (proc_wait(sp, pid, cmd, 0, 0));
	}
	/* NOTREACHED */
}

/*
 * proc_wait --
 *	Wait for one of the processes.
 *
 * !!!
 * The pid_t type varies in size from a short to a long depending on the
 * system.  It has to be cast into something or the standard promotion
 * rules get you.  I'm using a long based on the belief that nobody is
 * going to make it unsigned and it's unlikely to be a quad.
 *
 * PUBLIC: int proc_wait(SCR *, pid_t, const char *, int, int);
 */
int
proc_wait(SCR *sp, pid_t pid, const char *cmd, int silent, int okpipe)
{
	size_t len;
	int nf, pstat;
	char *p;

	/* Wait for the utility, ignoring interruptions. */
	for (;;) {
		errno = 0;
		if (waitpid(pid, &pstat, 0) != -1)
			break;
		if (errno != EINTR) {
			msgq(sp, M_SYSERR, "waitpid");
			return (1);
		}
	}

	/*
	 * Display the utility's exit status.  Ignore SIGPIPE from the
	 * parent-writer, as that only means that the utility chose to
	 * exit before reading all of its input.
	 */
	if (WIFSIGNALED(pstat) && (!okpipe || WTERMSIG(pstat) != SIGPIPE)) {
		for (; isblank(*cmd); ++cmd);
		p = msg_print(sp, cmd, &nf);
		len = strlen(p);
		msgq(sp, M_ERR, "%.*s%s: received signal: %s%s",
		    MINIMUM(len, 20), p, len > 20 ? " ..." : "",
		    strsignal(WTERMSIG(pstat)),
		    WCOREDUMP(pstat) ? "; core dumped" : "");
		if (nf)
			FREE_SPACE(sp, p, 0);
		return (1);
	}

	if (WIFEXITED(pstat) && WEXITSTATUS(pstat)) {
		/*
		 * Remain silent for "normal" errors when doing shell file
		 * name expansions, they almost certainly indicate nothing
		 * more than a failure to match.
		 *
		 * Remain silent for vi read filter errors.  It's historic
		 * practice.
		 */
		if (!silent) {
			for (; isblank(*cmd); ++cmd);
			p = msg_print(sp, cmd, &nf);
			len = strlen(p);
			msgq(sp, M_ERR, "%.*s%s: exited with status %d",
			    MINIMUM(len, 20), p, len > 20 ? " ..." : "",
			    WEXITSTATUS(pstat));
			if (nf)
				FREE_SPACE(sp, p, 0);
		}
		return (1);
	}
	return (0);
}
@


1.14
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_shell.c,v 1.13 2014/11/12 04:28:41 bentley Exp $	*/
d18 1
@


1.13
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_shell.c,v 1.12 2014/11/10 21:31:42 tedu Exp $	*/
a13 1
#include <sys/param.h>
d28 2
d41 1
a41 1
	char buf[MAXPATHLEN];
d170 1
a170 1
		    MIN(len, 20), p, len > 20 ? " ..." : "",
d192 1
a192 1
			    MIN(len, 20), p, len > 20 ? " ..." : "",
@


1.12
log
@remove old, unnecessary compat code. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_shell.c,v 1.11 2009/10/27 23:59:47 deraadt Exp $	*/
d37 1
a37 3
ex_shell(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d78 2
a79 6
ex_exec_proc(sp, cmdp, cmd, msg, need_newline)
	SCR *sp;
	EXCMD *cmdp;
	char *cmd;
	const char *msg;
	int need_newline;
d142 1
a142 5
proc_wait(sp, pid, cmd, silent, okpipe)
	SCR *sp;
	pid_t pid;
	const char *cmd;
	int silent, okpipe;
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_shell.c,v 1.10 2006/01/08 21:05:40 miod Exp $	*/
a28 2
static const char *sigmsg(int);

d180 1
a180 1
		    sigmsg(WTERMSIG(pstat)),
a208 165
}

/*
 * XXX
 * The sys_siglist[] table in the C library has this information, but there's
 * no portable way to get to it.  (Believe me, I tried.)
 */
typedef struct _sigs {
	int	 number;		/* signal number */
	char	*message;		/* related message */
} SIGS;

SIGS const sigs[] = {
#ifdef SIGABRT
	{ SIGABRT,	"Abort trap" },
#endif
#ifdef SIGALRM
	{ SIGALRM,	"Alarm clock" },
#endif
#ifdef SIGBUS
	{ SIGBUS,	"Bus error" },
#endif
#ifdef SIGCLD
	{ SIGCLD,	"Child exited or stopped" },
#endif
#ifdef SIGCHLD
	{ SIGCHLD,	"Child exited" },
#endif
#ifdef SIGCONT
	{ SIGCONT,	"Continued" },
#endif
#ifdef SIGDANGER
	{ SIGDANGER,	"System crash imminent" },
#endif
#ifdef SIGEMT
	{ SIGEMT,	"EMT trap" },
#endif
#ifdef SIGFPE
	{ SIGFPE,	"Floating point exception" },
#endif
#ifdef SIGGRANT
	{ SIGGRANT,	"HFT monitor mode granted" },
#endif
#ifdef SIGHUP
	{ SIGHUP,	"Hangup" },
#endif
#ifdef SIGILL
	{ SIGILL,	"Illegal instruction" },
#endif
#ifdef SIGINFO
	{ SIGINFO,	"Information request" },
#endif
#ifdef SIGINT
	{ SIGINT,	"Interrupt" },
#endif
#ifdef SIGIO
	{ SIGIO,	"I/O possible" },
#endif
#ifdef SIGIOT
	{ SIGIOT,	"IOT trap" },
#endif
#ifdef SIGKILL
	{ SIGKILL,	"Killed" },
#endif
#ifdef SIGLOST
	{ SIGLOST,	"Record lock" },
#endif
#ifdef SIGMIGRATE
	{ SIGMIGRATE,	"Migrate process to another CPU" },
#endif
#ifdef SIGMSG
	{ SIGMSG,	"HFT input data pending" },
#endif
#ifdef SIGPIPE
	{ SIGPIPE,	"Broken pipe" },
#endif
#ifdef SIGPOLL
	{ SIGPOLL,	"I/O possible" },
#endif
#ifdef SIGPRE
	{ SIGPRE,	"Programming error" },
#endif
#ifdef SIGPROF
	{ SIGPROF,	"Profiling timer expired" },
#endif
#ifdef SIGPWR
	{ SIGPWR,	"Power failure imminent" },
#endif
#ifdef SIGRETRACT
	{ SIGRETRACT,	"HFT monitor mode retracted" },
#endif
#ifdef SIGQUIT
	{ SIGQUIT,	"Quit" },
#endif
#ifdef SIGSAK
	{ SIGSAK,	"Secure Attention Key" },
#endif
#ifdef SIGSEGV
	{ SIGSEGV,	"Segmentation fault" },
#endif
#ifdef SIGSOUND
	{ SIGSOUND,	"HFT sound sequence completed" },
#endif
#ifdef SIGSTOP
	{ SIGSTOP,	"Suspended (signal)" },
#endif
#ifdef SIGSYS
	{ SIGSYS,	"Bad system call" },
#endif
#ifdef SIGTERM
	{ SIGTERM,	"Terminated" },
#endif
#ifdef SIGTRAP
	{ SIGTRAP,	"Trace/BPT trap" },
#endif
#ifdef SIGTSTP
	{ SIGTSTP,	"Suspended" },
#endif
#ifdef SIGTTIN
	{ SIGTTIN,	"Stopped (tty input)" },
#endif
#ifdef SIGTTOU
	{ SIGTTOU,	"Stopped (tty output)" },
#endif
#ifdef SIGURG
	{ SIGURG,	"Urgent I/O condition" },
#endif
#ifdef SIGUSR1
	{ SIGUSR1,	"User defined signal 1" },
#endif
#ifdef SIGUSR2
	{ SIGUSR2,	"User defined signal 2" },
#endif
#ifdef SIGVTALRM
	{ SIGVTALRM,	"Virtual timer expired" },
#endif
#ifdef SIGWINCH
	{ SIGWINCH,	"Window size changes" },
#endif
#ifdef SIGXCPU
	{ SIGXCPU,	"Cputime limit exceeded" },
#endif
#ifdef SIGXFSZ
	{ SIGXFSZ,	"Filesize limit exceeded" },
#endif
};

/*
 * sigmsg --
 * 	Return a pointer to a message describing a signal.
 */
static const char *
sigmsg(signo)
	int signo;
{
	static char buf[40];
	const SIGS *sigp;
	int n;

	for (n = 0,
	    sigp = &sigs[0]; n < sizeof(sigs) / sizeof(sigs[0]); ++n, ++sigp)
		if (sigp->number == signo)
			return (sigp->message);
	(void)snprintf(buf, sizeof(buf), "Unknown signal: %d", signo);
	return (buf);
@


1.10
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_shell.c,v 1.9 2002/06/12 06:07:17 mpech Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_shell.c	10.38 (Berkeley) 8/19/96";
#endif /* not lint */
@


1.9
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_shell.c,v 1.8 2002/02/16 21:27:57 millert Exp $	*/
d229 1
a229 1
	SIGABRT,	"Abort trap",
d232 1
a232 1
	SIGALRM,	"Alarm clock",
d235 1
a235 1
	SIGBUS,		"Bus error",
d238 1
a238 1
	SIGCLD,		"Child exited or stopped",
d241 1
a241 1
	SIGCHLD,	"Child exited",
d244 1
a244 1
	SIGCONT,	"Continued",
d247 1
a247 1
	SIGDANGER,	"System crash imminent",
d250 1
a250 1
	SIGEMT,		"EMT trap",
d253 1
a253 1
	SIGFPE,		"Floating point exception",
d256 1
a256 1
	SIGGRANT,	"HFT monitor mode granted",
d259 1
a259 1
	SIGHUP,		"Hangup",
d262 1
a262 1
	SIGILL,		"Illegal instruction",
d265 1
a265 1
	SIGINFO,	"Information request",
d268 1
a268 1
	SIGINT,		"Interrupt",
d271 1
a271 1
	SIGIO,		"I/O possible",
d274 1
a274 1
	SIGIOT,		"IOT trap",
d277 1
a277 1
	SIGKILL,	"Killed",
d280 1
a280 1
	SIGLOST,	"Record lock",
d283 1
a283 1
	SIGMIGRATE,	"Migrate process to another CPU",
d286 1
a286 1
	SIGMSG,		"HFT input data pending",
d289 1
a289 1
	SIGPIPE,	"Broken pipe",
d292 1
a292 1
	SIGPOLL,	"I/O possible",
d295 1
a295 1
	SIGPRE,		"Programming error",
d298 1
a298 1
	SIGPROF,	"Profiling timer expired",
d301 1
a301 1
	SIGPWR,		"Power failure imminent",
d304 1
a304 1
	SIGRETRACT,	"HFT monitor mode retracted",
d307 1
a307 1
	SIGQUIT,	"Quit",
d310 1
a310 1
	SIGSAK,		"Secure Attention Key",
d313 1
a313 1
	SIGSEGV,	"Segmentation fault",
d316 1
a316 1
	SIGSOUND,	"HFT sound sequence completed",
d319 1
a319 1
	SIGSTOP,	"Suspended (signal)",
d322 1
a322 1
	SIGSYS,		"Bad system call",
d325 1
a325 1
	SIGTERM,	"Terminated",
d328 1
a328 1
	SIGTRAP,	"Trace/BPT trap",
d331 1
a331 1
	SIGTSTP,	"Suspended",
d334 1
a334 1
	SIGTTIN,	"Stopped (tty input)",
d337 1
a337 1
	SIGTTOU,	"Stopped (tty output)",
d340 1
a340 1
	SIGURG,		"Urgent I/O condition",
d343 1
a343 1
	SIGUSR1,	"User defined signal 1",
d346 1
a346 1
	SIGUSR2,	"User defined signal 2",
d349 1
a349 1
	SIGVTALRM,	"Virtual timer expired",
d352 1
a352 1
	SIGWINCH,	"Window size changes",
d355 1
a355 1
	SIGXCPU,	"Cputime limit exceeded",
d358 1
a358 1
	SIGXFSZ,	"Filesize limit exceeded",
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_shell.c,v 1.7 2001/07/09 07:04:57 deraadt Exp $	*/
d136 1
a136 1
		return (proc_wait(sp, (long)pid, cmd, 0, 0));
d151 1
a151 1
 * PUBLIC: int proc_wait(SCR *, long, const char *, int, int);
d156 1
a156 1
	long pid;
d167 1
a167 1
		if (waitpid((pid_t)pid, &pstat, 0) != -1)
@


1.7
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_shell.c,v 1.6 2001/01/29 01:58:44 niklas Exp $	*/
d33 1
a33 1
static const char *sigmsg __P((int));
d40 1
a40 1
 * PUBLIC: int ex_shell __P((SCR *, EXCMD *));
d83 1
a83 1
 * PUBLIC: int ex_exec_proc __P((SCR *, EXCMD *, char *, const char *, int));
d151 1
a151 1
 * PUBLIC: int proc_wait __P((SCR *, long, const char *, int, int));
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d131 1
a131 1
		execl(O_STR(sp, O_SHELL), name, "-c", cmd, NULL);
@


1.5
log
@nvi 1.75
@
text
@d1 2
@


1.4
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_shell.c	10.37 (Berkeley) 8/11/96";
d59 1
a59 1
	(void)cl_rename(sp, NULL, 0);
d65 1
a65 1
	(void)cl_rename(sp, sp->frp->name, 1);
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_shell.c	10.35 (Berkeley) 6/28/96";
d58 4
a61 1
	/* If we're stil in a vi screen, move out explicitly. */
d63 3
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_shell.c	10.33 (Berkeley) 4/27/96";
d66 1
a66 1
	F_SET(sp, SC_EX_DONTWAIT);
d85 1
d89 2
d97 1
a97 1
		if (sp->gp->scr_screen(sp, SC_EX)) {
d101 1
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)ex_shell.c	8.26 (Berkeley) 8/17/94";
d18 1
a18 1
#include <sys/time.h>
d25 1
a26 1
#include <termios.h>
d29 3
a31 7
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
#include "../svi/svi_screen.h"
d37 2
d41 1
a41 1
ex_shell(sp, ep, cmdp)
d43 1
a43 2
	EXF *ep;
	EXCMDARG *cmdp;
d45 1
d48 8
d57 12
a68 1
	return (ex_exec_proc(sp, buf, "\n", NULL));
d74 2
d78 1
a78 1
ex_exec_proc(sp, cmd, p1, p2)
d80 4
a83 1
	char *cmd, *p1, *p2;
a86 1
	int rval, teardown;
d88 2
a89 2
	/* Clear the rest of the screen. */
	if (sp->s_clear(sp))
d92 8
a99 2
	/* Save ex/vi terminal settings, and restore the original ones. */
	teardown = !ex_sleave(sp);
d101 8
a108 11
	/*
	 * Flush waiting messages (autowrite, for example) so the output
	 * matches historic practice.
	 */
	(void)sex_refresh(sp, sp->ep);

	/* Put out various messages. */
	if (p1 != NULL)
		(void)write(STDOUT_FILENO, p1, strlen(p1));
	if (p2 != NULL)
		(void)write(STDOUT_FILENO, p2, strlen(p2));
a109 1
	SIGBLOCK(sp->gp);
a111 2
		SIGUNBLOCK(sp->gp);

d113 1
a113 2
		rval = 1;
		break;
a114 3
		/* The utility has default signal behavior. */
		sig_end();

d120 1
a120 2
		msgq(sp, M_ERR, "Error: execl: %s: %s",
		    O_STR(sp, O_SHELL), strerror(errno));
d124 4
a127 1
		SIGUNBLOCK(sp->gp);
d129 32
a160 2
		rval = proc_wait(sp, (long)pid, cmd, 0);
		break;
a162 4
	/* Restore ex/vi terminal settings. */
	if (teardown)
		ex_rleave(sp);

d164 3
a166 5
	 * XXX
	 * Stat of the tty structures (see ex_sleave, ex_rleave) only give
	 * us 1-second resolution on the tty changes.  A fast '!' command,
	 * e.g. ":!pwd" can beat us to the refresh.  When there's better
	 * resolution from the stat(2) timers, this can go away.
d168 181
a348 1
	F_SET(sp, S_REFRESH);
d350 18
a367 1
	return (rval);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
