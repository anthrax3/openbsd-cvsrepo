head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.4
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.6
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.6.0.16
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.14
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.12
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.16;
commitid	01nAnartGL7onLD3;

1.16
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.15;
commitid	ruCZ2IKF0FB0ebCr;

1.15
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.14;
commitid	adBvXLg05bJxz6yx;

1.14
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	gtDERb7QyXwKGs62;

1.13
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.12;
commitid	06bi6U3x4gFFf2G1;

1.12
date	2013.12.01.13.42.42;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.14.12.32.29;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.43;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.07.27.22.28.18;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.52;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.35.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: ex_global.c,v 1.15 2016/01/06 22:28:52 millert Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"

enum which {GLOBAL, V};

static int ex_g_setup(SCR *, EXCMD *, enum which);

/*
 * ex_global -- [line [,line]] g[lobal][!] /pattern/ [commands]
 *	Exec on lines matching a pattern.
 *
 * PUBLIC: int ex_global(SCR *, EXCMD *);
 */
int
ex_global(SCR *sp, EXCMD *cmdp)
{
	return (ex_g_setup(sp,
	    cmdp, FL_ISSET(cmdp->iflags, E_C_FORCE) ? V : GLOBAL));
}

/*
 * ex_v -- [line [,line]] v /pattern/ [commands]
 *	Exec on lines not matching a pattern.
 *
 * PUBLIC: int ex_v(SCR *, EXCMD *);
 */
int
ex_v(SCR *sp, EXCMD *cmdp)
{
	return (ex_g_setup(sp, cmdp, V));
}

/*
 * ex_g_setup --
 *	Ex global and v commands.
 */
static int
ex_g_setup(SCR *sp, EXCMD *cmdp, enum which cmd)
{
	CHAR_T *ptrn, *p, *t;
	EXCMD *ecp;
	MARK abs_mark;
	RANGE *rp;
	busy_t btype;
	recno_t start, end;
	regex_t *re;
	regmatch_t match[1];
	size_t len;
	int cnt, delim, eval;
	char *dbp;

	NEEDFILE(sp, cmdp);

	if (F_ISSET(sp, SC_EX_GLOBAL)) {
		msgq(sp, M_ERR,
	"The %s command can't be used as part of a global or v command",
		    cmdp->cmd->name);
		return (1);
	}

	/*
	 * Skip leading white space.  Historic vi allowed any non-alphanumeric
	 * to serve as the global command delimiter.
	 */
	if (cmdp->argc == 0)
		goto usage;
	for (p = cmdp->argv[0]->bp; isblank(*p); ++p);
	if (*p == '\0' || isalnum(*p) ||
	    *p == '\\' || *p == '|' || *p == '\n') {
usage:		ex_emsg(sp, cmdp->cmd->usage, EXM_USAGE);
		return (1);
	}
	delim = *p++;

	/*
	 * Get the pattern string, toss escaped characters.
	 *
	 * QUOTING NOTE:
	 * Only toss an escaped character if it escapes a delimiter.
	 */
	for (ptrn = t = p;;) {
		if (p[0] == '\0' || p[0] == delim) {
			if (p[0] == delim)
				++p;
			/*
			 * !!!
			 * Nul terminate the pattern string -- it's passed
			 * to regcomp which doesn't understand anything else.
			 */
			*t = '\0';
			break;
		}
		if (p[0] == '\\') {
			if (p[1] == delim)
				++p;
			else if (p[1] == '\\')
				*t++ = *p++;
		}
		*t++ = *p++;
	}

	/* If the pattern string is empty, use the last one. */
	if (*ptrn == '\0') {
		if (sp->re == NULL) {
			ex_emsg(sp, NULL, EXM_NOPREVRE);
			return (1);
		}

		/* Re-compile the RE if necessary. */
		if (!F_ISSET(sp, SC_RE_SEARCH) && re_compile(sp,
		    sp->re, sp->re_len, NULL, NULL, &sp->re_c, RE_C_SEARCH))
			return (1);
	} else {
		/* Compile the RE. */
		if (re_compile(sp, ptrn, t - ptrn,
		    &sp->re, &sp->re_len, &sp->re_c, RE_C_SEARCH))
			return (1);

		/*
		 * Set saved RE.  Historic practice is that globals set
		 * direction as well as the RE.
		 */
		sp->searchdir = FORWARD;
	}
	re = &sp->re_c;

	/* The global commands always set the previous context mark. */
	abs_mark.lno = sp->lno;
	abs_mark.cno = sp->cno;
	if (mark_set(sp, ABSMARK1, &abs_mark, 1))
		return (1);

	/* Get an EXCMD structure. */
	CALLOC_RET(sp, ecp, 1, sizeof(EXCMD));
	TAILQ_INIT(&ecp->rq);

	/*
	 * Get a copy of the command string; the default command is print.
	 * Don't worry about a set of <blank>s with no command, that will
	 * default to print in the ex parser.  We need to have two copies
	 * because the ex parser may step on the command string when it's
	 * parsing it.
	 */
	if ((len = cmdp->argv[0]->len - (p - cmdp->argv[0]->bp)) == 0) {
		p = "pp";
		len = 1;
	}

	MALLOC_RET(sp, ecp->cp, len * 2);
	ecp->o_cp = ecp->cp;
	ecp->o_clen = len;
	memcpy(ecp->cp + len, p, len);
	ecp->range_lno = OOBLNO;
	FL_SET(ecp->agv_flags, cmd == GLOBAL ? AGV_GLOBAL : AGV_V);
	LIST_INSERT_HEAD(&sp->gp->ecq, ecp, q);

	/*
	 * For each line...  The semantics of global matching are that we first
	 * have to decide which lines are going to get passed to the command,
	 * and then pass them to the command, ignoring other changes.  There's
	 * really no way to do this in a single pass, since arbitrary line
	 * creation, deletion and movement can be done in the ex command.  For
	 * example, a good vi clone test is ":g/X/mo.-3", or "g/X/.,.+1d".
	 * What we do is create linked list of lines that are tracked through
	 * each ex command.  There's a callback routine which the DB interface
	 * routines call when a line is created or deleted.  This doesn't help
	 * the layering much.
	 */
	btype = BUSY_ON;
	cnt = INTERRUPT_CHECK;
	for (start = cmdp->addr1.lno,
	    end = cmdp->addr2.lno; start <= end; ++start) {
		if (cnt-- == 0) {
			if (INTERRUPTED(sp)) {
				LIST_REMOVE(ecp, q);
				free(ecp->cp);
				free(ecp);
				break;
			}
			search_busy(sp, btype);
			btype = BUSY_UPDATE;
			cnt = INTERRUPT_CHECK;
		}
		if (db_get(sp, start, DBG_FATAL, &dbp, &len))
			return (1);
		match[0].rm_so = 0;
		match[0].rm_eo = len;
		switch (eval =
		    regexec(&sp->re_c, dbp, 0, match, REG_STARTEND)) {
		case 0:
			if (cmd == V)
				continue;
			break;
		case REG_NOMATCH:
			if (cmd == GLOBAL)
				continue;
			break;
		default:
			re_error(sp, eval, &sp->re_c);
			break;
		}

		/* If follows the last entry, extend the last entry's range. */
		if ((rp = TAILQ_LAST(&ecp->rq, _rh)) && rp->stop == start - 1) {
			++rp->stop;
			continue;
		}

		/* Allocate a new range, and append it to the list. */
		CALLOC(sp, rp, 1, sizeof(RANGE));
		if (rp == NULL)
			return (1);
		rp->start = rp->stop = start;
		TAILQ_INSERT_TAIL(&ecp->rq, rp, q);
	}
	search_busy(sp, BUSY_OFF);
	return (0);
}

/*
 * ex_g_insdel --
 *	Update the ranges based on an insertion or deletion.
 *
 * PUBLIC: int ex_g_insdel(SCR *, lnop_t, recno_t);
 */
int
ex_g_insdel(SCR *sp, lnop_t op, recno_t lno)
{
	EXCMD *ecp;
	RANGE *nrp, *rp;

	/* All insert/append operations are done as inserts. */
	if (op == LINE_APPEND)
		abort();

	if (op == LINE_RESET)
		return (0);

	LIST_FOREACH(ecp, &sp->gp->ecq, q) {
		if (!FL_ISSET(ecp->agv_flags, AGV_AT | AGV_GLOBAL | AGV_V))
			continue;
		for (rp = TAILQ_FIRST(&ecp->rq); rp != NULL; rp = nrp) {
			nrp = TAILQ_NEXT(rp, q);

			/* If range less than the line, ignore it. */
			if (rp->stop < lno)
				continue;
			
			/*
			 * If range greater than the line, decrement or
			 * increment the range.
			 */
			if (rp->start > lno) {
				if (op == LINE_DELETE) {
					--rp->start;
					--rp->stop;
				} else {
					++rp->start;
					++rp->stop;
				}
				continue;
			}

			/*
			 * Lno is inside the range, decrement the end point
			 * for deletion, and split the range for insertion.
			 * In the latter case, since we're inserting a new
			 * element, neither range can be exhausted.
			 */
			if (op == LINE_DELETE) {
				if (rp->start > --rp->stop) {
					TAILQ_REMOVE(&ecp->rq, rp, q);
					free(rp);
				}
			} else {
				CALLOC_RET(sp, nrp, 1, sizeof(RANGE));
				nrp->start = lno + 1;
				nrp->stop = rp->stop + 1;
				rp->stop = lno - 1;
				TAILQ_INSERT_AFTER(&ecp->rq, rp, nrp, q);
				rp = nrp;
			}
		}

		/*
		 * If the command deleted/inserted lines, the cursor moves to
		 * the line after the deleted/inserted line.
		 */
		ecp->range_lno = lno;
	}
	return (0);
}
@


1.16
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d64 1
a64 1
	char *ptrn, *p, *t;
@


1.15
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.14 2015/12/07 20:39:19 mmcc Exp $	*/
d64 1
a64 1
	CHAR_T *ptrn, *p, *t;
@


1.14
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.13 2014/11/12 04:28:41 bentley Exp $	*/
d80 1
a80 1
	"124|The %s command can't be used as part of a global or v command",
@


1.13
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.12 2013/12/01 13:42:42 krw Exp $	*/
d158 1
a158 1
	CALLOC_RET(sp, ecp, EXCMD *, 1, sizeof(EXCMD));
d173 1
a173 1
	MALLOC_RET(sp, ecp->cp, char *, len * 2);
d234 1
a234 1
		CALLOC(sp, rp, RANGE *, 1, sizeof(RANGE));
d300 1
a300 1
				CALLOC_RET(sp, nrp, RANGE *, 1, sizeof(RANGE));
@


1.12
log
@Convert the ranges CIRCLEQ to TAILQ.

ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.11 2009/10/27 23:59:47 deraadt Exp $	*/
d39 1
a39 3
ex_global(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d52 1
a52 3
ex_v(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d62 1
a62 4
ex_g_setup(sp, cmdp, cmd)
	SCR *sp;
	EXCMD *cmdp;
	enum which cmd;
d251 1
a251 4
ex_g_insdel(sp, op, lno)
	SCR *sp;
	lnop_t op;
	recno_t lno;
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.10 2007/05/14 12:32:29 pyr Exp $	*/
d166 1
a166 1
	CIRCLEQ_INIT(&ecp->rq);
d235 1
a235 2
		if ((rp = CIRCLEQ_LAST(&ecp->rq)) != CIRCLEQ_END(&ecp->rq) &&
		    rp->stop == start - 1) {
d245 1
a245 1
		CIRCLEQ_INSERT_TAIL(&ecp->rq, rp, q);
d276 2
a277 3
		for (rp = CIRCLEQ_FIRST(&ecp->rq); rp != CIRCLEQ_END(&ecp->rq);
		    rp = nrp) {
			nrp = CIRCLEQ_NEXT(rp, q);
d306 1
a306 1
					CIRCLEQ_REMOVE(&ecp->rq, rp, q);
d314 1
a314 1
				CIRCLEQ_INSERT_AFTER(&ecp->rq, rp, nrp, q);
@


1.10
log
@use sys/queue macros instead of accessing fields directly.
no binary change.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.9 2006/04/22 03:09:15 ray Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_global.c	10.22 (Berkeley) 10/10/96";
#endif /* not lint */
@


1.9
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.8 2006/01/08 21:05:40 miod Exp $	*/
d239 1
a239 1
		if ((rp = ecp->rq.cqh_last) != (void *)&ecp->rq &&
@


1.8
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.7 2005/10/17 19:12:16 otto Exp $	*/
d77 1
a77 1
	MARK abs;
d163 3
a165 3
	abs.lno = sp->lno;
	abs.cno = sp->cno;
	if (mark_set(sp, ABSMARK1, &abs, 1))
@


1.7
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.6 2002/02/16 21:27:57 millert Exp $	*/
d128 1
a128 1
		if (p[0] == '\\')
d133 1
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_global.c,v 1.5 2001/01/29 01:58:43 niklas Exp $	*/
d277 1
a277 1
	for (ecp = sp->gp->ecq.lh_first; ecp != NULL; ecp = ecp->q.le_next) {
d280 3
a282 2
		for (rp = ecp->rq.cqh_first; rp != (void *)&ecp->rq; rp = nrp) {
			nrp = rp->q.cqe_next;
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
static int ex_g_setup __P((SCR *, EXCMD *, enum which));
d40 1
a40 1
 * PUBLIC: int ex_global __P((SCR *, EXCMD *));
d55 1
a55 1
 * PUBLIC: int ex_v __P((SCR *, EXCMD *));
d259 1
a259 1
 * PUBLIC: int ex_g_insdel __P((SCR *, lnop_t, recno_t));
@


1.4
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_global.c	10.21 (Berkeley) 6/30/96";
d73 1
d83 1
a83 1
	char *ptrn, *p, *t;
d176 1
a176 1
	if ((len = strlen(p)) == 0) {
d216 1
a216 1
		if (db_get(sp, start, DBG_FATAL, &p, &len))
d220 2
a221 1
		switch (eval = regexec(&sp->re_c, p, 0, match, REG_STARTEND)) {
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_global.c	10.20 (Berkeley) 5/3/96";
d140 3
a142 3
		/* Compile the RE if necessary. */
		if (!F_ISSET(sp, SC_RE_SEARCH) &&
		    re_compile(sp, sp->re, NULL, NULL, &sp->re_c, RE_C_SEARCH))
d146 2
a147 2
		if (re_compile(sp,
		    ptrn, &sp->re, &sp->re_len, &sp->re_c, RE_C_SEARCH))
d180 1
a180 2
	/* See ex.h for a discussion of SEARCH_TERMINATION. */
	MALLOC_RET(sp, ecp->cp, char *, len * 2 + SEARCH_TERMINATION);
d183 1
a183 1
	memmove(ecp->cp + len + SEARCH_TERMINATION, p, len);
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)ex_global.c	8.43 (Berkeley) 8/17/94";
a17 1
#include <sys/time.h>
a22 1
#include <signal.h>
a25 1
#include <termios.h>
d28 1
a28 6
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
d30 1
a30 1
enum which {GLOBAL, VGLOBAL};
d32 1
a32 1
static int	global __P((SCR *, EXF *, EXCMDARG *, enum which));
d37 2
d41 1
a41 1
ex_global(sp, ep, cmdp)
d43 1
a43 2
	EXF *ep;
	EXCMDARG *cmdp;
d45 2
a46 2
	return (global(sp, ep,
	    cmdp, F_ISSET(cmdp, E_FORCE) ? VGLOBAL : GLOBAL));
d50 1
a50 1
 * ex_vglobal -- [line [,line]] v[global] /pattern/ [commands]
d52 2
d56 1
a56 1
ex_vglobal(sp, ep, cmdp)
d58 1
a58 2
	EXF *ep;
	EXCMDARG *cmdp;
d60 1
a60 1
	return (global(sp, ep, cmdp, VGLOBAL));
d63 4
d68 1
a68 1
global(sp, ep, cmdp, cmd)
d70 1
a70 2
	EXF *ep;
	EXCMDARG *cmdp;
d73 1
d76 3
a78 2
	EX_PRIVATE *exp;
	recno_t elno, lno;
d80 12
a91 4
	regex_t *re, lre;
	size_t clen, len;
	int delim, eval, reflags, replaced, rval;
	char *cb, *ptrn, *p, *t;
d94 2
a95 2
	 * Skip leading white space.  Historic vi allowed any non-
	 * alphanumeric to serve as the global command delimiter.
d97 2
d100 3
a102 2
	if (*p == '\0' || isalnum(*p)) {
		msgq(sp, M_ERR, "Usage: %s", cmdp->cmd->usage);
d125 5
a129 2
		if (p[0] == '\\' && p[1] == delim)
			++p;
d135 2
a136 2
		if (!F_ISSET(sp, S_SRE_SET)) {
			msgq(sp, M_ERR, "No previous regular expression");
a138 8
		re = &sp->sre;
	} else {
		/* Set RE flags. */
		reflags = 0;
		if (O_ISSET(sp, O_EXTENDED))
			reflags |= REG_EXTENDED;
		if (O_ISSET(sp, O_IGNORECASE))
			reflags |= REG_ICASE;
d140 3
a142 2
		/* Convert vi-style RE's to POSIX 1003.2 RE's. */
		if (re_conv(sp, &ptrn, &replaced))
d144 1
a144 1

d146 2
a147 9
		re = &lre;
		eval = regcomp(re, ptrn, reflags);

		/* Free up any allocated memory. */
		if (replaced)
			FREE_SPACE(sp, ptrn, 0);

		if (eval) {
			re_error(sp, eval, re);
a148 1
		}
d151 2
a152 2
		 * Set saved RE.  Historic practice is that
		 * globals set direction as well as the RE.
a153 1
		sp->sre = lre;
a154 1
		F_SET(sp, S_SRE_SET);
d156 11
d171 3
a173 1
	 * default to print in the ex parser.
d175 3
a177 3
	if ((clen = strlen(p)) == 0) {
		p = "p";
		clen = 1;
a178 2
	MALLOC_RET(sp, cb, char *, clen);
	memmove(cb, p, clen);
d180 8
a187 15
	/*
	 * The global commands sets the substitute RE as well as
	 * the everything-else RE.
	 */
	sp->subre = sp->sre;
	F_SET(sp, S_SUBRE_SET);

	/* Set the global flag. */
	F_SET(sp, S_GLOBAL);

	/* The global commands always set the previous context mark. */
	abs.lno = sp->lno;
	abs.cno = sp->cno;
	if (mark_set(sp, ep, ABSMARK1, &abs, 1))
		goto err;
d201 14
a214 11
	exp = EXP(sp);
	for (rval = 0, lno = cmdp->addr1.lno,
	    elno = cmdp->addr2.lno; lno <= elno; ++lno) {
		/* Someone's unhappy, time to stop. */
		if (INTERRUPTED(sp))
			goto interrupted;

		/* Get the line and search for a match. */
		if ((t = file_gline(sp, ep, lno, &len)) == NULL) {
			GETLINE_ERR(sp, lno);
			goto err;
d216 2
d220 1
a220 1
		switch(eval = regexec(re, t, 1, match, REG_STARTEND)) {
d222 1
a222 1
			if (cmd == VGLOBAL)
d230 2
a231 2
			re_error(sp, eval, re);
			goto err;
d235 2
a236 2
		if ((rp = exp->rangeq.cqh_last) != (void *)&exp->rangeq &&
		    rp->stop == lno - 1) {
a243 40
			goto err;
		rp->start = rp->stop = lno;
		CIRCLEQ_INSERT_TAIL(&exp->rangeq, rp, q);
	}

	exp = EXP(sp);
	exp->range_lno = OOBLNO;
	for (;;) {
		/*
		 * Start at the beginning of the range each time, it may have
		 * been changed (or exhausted) if lines were inserted/deleted.
		 */
		if ((rp = exp->rangeq.cqh_first) == (void *)&exp->rangeq)
			break;
		if (rp->start > rp->stop) {
			CIRCLEQ_REMOVE(&exp->rangeq, exp->rangeq.cqh_first, q);
			free(rp);
			continue;
		}

		/*
		 * Execute the command, setting the cursor to the line so that
		 * relative addressing works.  This means that the cursor moves
		 * to the last line sent to the command, by default, even if
		 * the command fails.
		 */
		exp->range_lno = sp->lno = rp->start++;
		if (ex_cmd(sp, ep, cb, clen, 0))
			goto err;

		/* Someone's unhappy, time to stop. */
		if (INTERRUPTED(sp)) {
interrupted:		msgq(sp, M_INFO, "Interrupted");
			break;
		}
	}

	/* Set the cursor to the new value, making sure it exists. */
	if (exp->range_lno != OOBLNO) {
		if (file_lline(sp, ep, &lno))
d245 2
a246 5
		sp->lno =
		    lno < exp->range_lno ? (lno ? lno : 1) : exp->range_lno;
	}
	if (0) {
err:		rval = 1;
d248 2
a249 14

	/* Command we ran may have set the autoprint flag, clear it. */
	F_CLR(exp, EX_AUTOPRINT);

	/* Clear the global flag. */
	F_CLR(sp, S_GLOBAL);

	/* Free any remaining ranges and the command buffer. */
	while ((rp = exp->rangeq.cqh_first) != (void *)&exp->rangeq) {
		CIRCLEQ_REMOVE(&exp->rangeq, exp->rangeq.cqh_first, q);
		free(rp);
	}
	free(cb);
	return (rval);
d253 1
a253 1
 * global_insdel --
d255 2
d258 2
a259 2
void
global_insdel(sp, ep, op, lno)
d261 1
a261 2
	EXF *ep;
	enum operation op;
d264 1
a264 1
	EX_PRIVATE *exp;
d267 6
a272 1
	exp = EXP(sp);
d274 4
a277 6
	switch (op) {
	case LINE_APPEND:
		return;
	case LINE_DELETE:
		for (rp = exp->rangeq.cqh_first;
		    rp != (void *)&exp->rangeq; rp = nrp) {
d279 1
d283 5
a287 1
			/* If range greater than the line, decrement range. */
d289 7
a295 21
				--rp->start;
				--rp->stop;
				continue;
			}
			/* Lno is inside the range, decrement the end point. */
			if (rp->start > --rp->stop) {
				CIRCLEQ_REMOVE(&exp->rangeq, rp, q);
				free(rp);
			}
		}
		break;
	case LINE_INSERT:
		for (rp = exp->rangeq.cqh_first;
		    rp != (void *)&exp->rangeq; rp = rp->q.cqe_next) {
			/* If range less than the line, ignore it. */
			if (rp->stop < lno)
				continue;
			/* If range greater than the line, increment range. */
			if (rp->start >= lno) {
				++rp->start;
				++rp->stop;
d298 1
d300 4
a303 3
			 * Lno is inside the range, so the range must be split.
			 * Since we're inserting a new element, neither range
			 * can be exhausted.
d305 12
a316 4
			CALLOC(sp, nrp, RANGE *, 1, sizeof(RANGE));
			if (nrp == NULL) {
				F_SET(sp, S_INTERRUPTED);
				return;
a317 5
			nrp->start = lno + 1;
			nrp->stop = rp->stop + 1;
			rp->stop = lno - 1;
			CIRCLEQ_INSERT_AFTER(&exp->rangeq, rp, nrp, q);
			rp = nrp;
d319 6
a324 3
		break;
	case LINE_RESET:
		return;
d326 1
a326 5
	/*
	 * If the command deleted/inserted lines, the cursor moves to
	 * the line after the deleted/inserted line.
	 */
	exp->range_lno = lno;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
