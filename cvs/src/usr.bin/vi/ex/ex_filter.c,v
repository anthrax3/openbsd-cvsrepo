head	1.15;
access;
symbols
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.16
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.14
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.10
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.14
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.14
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.12
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.08.01.18.27.35;	author bentley;	state Exp;
branches;
next	1.14;
commitid	NOKOkHbanuF52TAH;

1.14
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.13;
commitid	adBvXLg05bJxz6yx;

1.13
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.11;
commitid	06bi6U3x4gFFf2G1;

1.11
date	2011.07.10.13.20.25;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.21.21.38.17;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.12.06.07.17;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.17.19.42.34;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.09.07.04.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.07.27.22.28.17;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.35.44;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove vi's "directory" option and TMPDIR support.

ok jung@@
@
text
@/*	$OpenBSD: ex_filter.c,v 1.14 2016/01/06 22:28:52 millert Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1991, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"

static int filter_ldisplay(SCR *, FILE *);

/*
 * ex_filter --
 *	Run a range of lines through a filter utility and optionally
 *	replace the original text with the stdout/stderr output of
 *	the utility.
 *
 * PUBLIC: int ex_filter(SCR *, 
 * PUBLIC:    EXCMD *, MARK *, MARK *, MARK *, char *, enum filtertype);
 */
int
ex_filter(SCR *sp, EXCMD *cmdp, MARK *fm, MARK *tm, MARK *rp, char *cmd,
    enum filtertype ftype)
{
	FILE *ifp, *ofp;
	pid_t parent_writer_pid, utility_pid;
	recno_t nread;
	int input[2], output[2], fd, rval;
	char *name, tname[] = "/tmp/vi.XXXXXXXXXX";

	rval = 0;

	/* Set return cursor position, which is never less than line 1. */
	*rp = *fm;
	if (rp->lno == 0)
		rp->lno = 1;

	/* We're going to need a shell. */
	if (opts_empty(sp, O_SHELL, 0))
		return (1);

	/*
	 * There are three different processes running through this code.
	 * They are the utility, the parent-writer and the parent-reader.
	 * The parent-writer is the process that writes from the file to
	 * the utility, the parent reader is the process that reads from
	 * the utility.
	 *
	 * Input and output are named from the utility's point of view.
	 * The utility reads from input[0] and the parent(s) write to
	 * input[1].  The parent(s) read from output[0] and the utility
	 * writes to output[1].
	 *
	 * !!!
	 * Historically, in the FILTER_READ case, the utility reads from
	 * the terminal (e.g. :r! cat works).  Otherwise open up utility
	 * input pipe.
	 */
	ofp = NULL;
	input[0] = input[1] = output[0] = output[1] = -1;

	if (ftype == FILTER_BANG) {
		fd = mkstemp(tname);
		if (fd == -1) {
			msgq(sp, M_SYSERR,
			    "Unable to create temporary file");
			if (fd != -1) {
				(void)close(fd);
				(void)unlink(tname);
			}
			goto err;
		}
		if (unlink(tname) == -1)
			msgq(sp, M_SYSERR, "unlink");
		if ((ifp = fdopen(fd, "w")) == NULL) {
			msgq(sp, M_SYSERR, "fdopen");
			(void)close(fd);
			goto err;
		}
		if ((input[0] = dup(fd)) == -1) {
			msgq(sp, M_SYSERR, "dup");
			(void)fclose(ifp);
			goto err;
		}
		/*
		 * Write the selected lines into the temporary file.
		 * This instance of ifp is closed by ex_writefp.
		 */
		if (ex_writefp(sp, "filter", ifp, fm, tm, NULL, NULL, 1))
			goto err;
		if (lseek(input[0], 0, SEEK_SET) == -1) {
			msgq(sp, M_SYSERR, "lseek");
			goto err;
		}
	} else if (ftype != FILTER_READ && pipe(input) < 0) {
		msgq(sp, M_SYSERR, "pipe");
		goto err;
	}

	/* Open up utility output pipe. */
	if (pipe(output) < 0) {
		msgq(sp, M_SYSERR, "pipe");
		goto err;
	}
	if ((ofp = fdopen(output[0], "r")) == NULL) {
		msgq(sp, M_SYSERR, "fdopen");
		goto err;
	}

	/* Fork off the utility process. */
	switch (utility_pid = vfork()) {
	case -1:			/* Error. */
		msgq(sp, M_SYSERR, "vfork");
err:		if (input[0] != -1)
			(void)close(input[0]);
		if (input[1] != -1)
			(void)close(input[1]);
		if (ofp != NULL)
			(void)fclose(ofp);
		else if (output[0] != -1)
			(void)close(output[0]);
		if (output[1] != -1)
			(void)close(output[1]);
		return (1);
	case 0:				/* Utility. */
		/*
		 * Redirect stdin from the read end of the input pipe, and
		 * redirect stdout/stderr to the write end of the output pipe.
		 *
		 * !!!
		 * Historically, ex only directed stdout into the input pipe,
		 * letting stderr come out on the terminal as usual.  Vi did
		 * not, directing both stdout and stderr into the input pipe.
		 * We match that practice in both ex and vi for consistency.
		 */
		if (input[0] != -1)
			(void)dup2(input[0], STDIN_FILENO);
		(void)dup2(output[1], STDOUT_FILENO);
		(void)dup2(output[1], STDERR_FILENO);

		/* Close the utility's file descriptors. */
		if (input[0] != -1)
			(void)close(input[0]);
		if (input[1] != -1)
			(void)close(input[1]);
		(void)close(output[0]);
		(void)close(output[1]);

		if ((name = strrchr(O_STR(sp, O_SHELL), '/')) == NULL)
			name = O_STR(sp, O_SHELL);
		else
			++name;

		execl(O_STR(sp, O_SHELL), name, "-c", cmd, (char *)NULL);
		msgq_str(sp, M_SYSERR, O_STR(sp, O_SHELL), "execl: %s");
		_exit (127);
		/* NOTREACHED */
	default:			/* Parent-reader, parent-writer. */
		/* Close the pipe ends neither parent will use. */
		if (input[0] != -1)
			(void)close(input[0]);
		(void)close(output[1]);
		break;
	}

	/*
	 * FILTER_RBANG, FILTER_READ:
	 *
	 * Reading is the simple case -- we don't need a parent writer,
	 * so the parent reads the output from the read end of the output
	 * pipe until it finishes, then waits for the child.  Ex_readfp
	 * appends to the MARK, and closes ofp.
	 *
	 * For FILTER_RBANG, there is nothing to write to the utility.
	 * Make sure it doesn't wait forever by closing its standard
	 * input.
	 *
	 * !!!
	 * Set the return cursor to the last line read in for FILTER_READ.
	 * Historically, this behaves differently from ":r file" command,
	 * which leaves the cursor at the first line read in.  Check to
	 * make sure that it's not past EOF because we were reading into an
	 * empty file.
	 */
	if (ftype == FILTER_RBANG || ftype == FILTER_READ) {
		if (ftype == FILTER_RBANG)
			(void)close(input[1]);

		if (ex_readfp(sp, "filter", ofp, fm, &nread, 1))
			rval = 1;
		sp->rptlines[L_ADDED] += nread;
		if (ftype == FILTER_READ) {
			if (fm->lno == 0)
				rp->lno = nread;
			else
				rp->lno += nread;
		}
	}

	/*
	 * FILTER_WRITE
	 *
	 * Here we need both a reader and a writer.  Temporary files are
	 * expensive and we'd like to avoid disk I/O.  Using pipes has the
	 * obvious starvation conditions.  It's done as follows:
	 *
	 *	fork
	 *	child
	 *		write lines out
	 *		exit
	 *	parent
	 *		read and display lines
	 *		wait for child
	 *
	 * We get away without locking the underlying database because we know
	 * that filter_ldisplay() does not modify it.  When the DB code has
	 * locking, we should treat vi as if it were multiple applications
	 * sharing a database, and do the required locking.  If necessary a
	 * work-around would be to do explicit locking in the line.c:db_get()
	 * code, based on the flag set here.
	 */
	if (ftype == FILTER_WRITE) {
		F_SET(sp->ep, F_MULTILOCK);
		switch (parent_writer_pid = fork()) {
		case -1:		/* Error. */
			msgq(sp, M_SYSERR, "fork");
			(void)close(input[1]);
			(void)close(output[0]);
			rval = 1;
			break;
		case 0:			/* Parent-writer. */
			/*
			 * Write the selected lines to the write end of the
			 * input pipe.  This instance of ifp is closed by
			 * ex_writefp.
			 */
			(void)close(output[0]);
			if ((ifp = fdopen(input[1], "w")) == NULL)
				_exit (1);
			_exit(ex_writefp(sp, "filter",
			    ifp, fm, tm, NULL, NULL, 1));
			/* NOTREACHED */
		default:		/* Parent-reader. */
			(void)close(input[1]);
			/*
			 * Read the output from the read end of the output
			 * pipe and display it.  Filter_ldisplay closes ofp.
			 */
			if (filter_ldisplay(sp, ofp))
				rval = 1;

			/* Wait for the parent-writer. */
			if (proc_wait(sp,
			    parent_writer_pid, "parent-writer", 0, 1))
				rval = 1;
			break;
		}
		F_CLR(sp->ep, F_MULTILOCK);
	}

	/*
	 * FILTER_BANG
	 *
	 * Here we need a temporary file because our database lacks locking.
	 *
	 * XXX
	 * Temporary files are expensive and we'd like to avoid disk I/O.
	 * When the DB code has locking, we should treat vi as if it were
	 * multiple applications sharing a database, and do the required
	 * locking.  If necessary a work-around would be to do explicit
	 * locking in the line.c:db_get() code, based on F_MULTILOCK flag set
	 * here.
	 */
	if (ftype == FILTER_BANG) {
		/*
		 * Read the output from the read end of the output
		 * pipe.  Ex_readfp appends to the MARK and closes
		 * ofp.
		 */
		if (ex_readfp(sp, "filter", ofp, tm, &nread, 1))
			rval = 1;
		sp->rptlines[L_ADDED] += nread;

		/* Delete any lines written to the utility. */
		if (rval == 0 &&
		    (cut(sp, NULL, fm, tm, CUT_LINEMODE) ||
		    del(sp, fm, tm, 1))) {
			rval = 1;
			goto uwait;
		}

		/*
		 * If the filter had no output, we may have just deleted
		 * the cursor.  Don't do any real error correction, we'll
		 * try and recover later.
		 */
		 if (rp->lno > 1 && !db_exist(sp, rp->lno))
			--rp->lno;
	}

	/*
	 * !!!
	 * Ignore errors on vi file reads, to make reads prettier.  It's
	 * completely inconsistent, and historic practice.
	 */
uwait:	return (proc_wait(sp, utility_pid, cmd,
	    ftype == FILTER_READ && F_ISSET(sp, SC_VI) ? 1 : 0, 0) || rval);
}

/*
 * filter_ldisplay --
 *	Display output from a utility.
 *
 * !!!
 * Historically, the characters were passed unmodified to the terminal.
 * We use the ex print routines to make sure they're printable.
 */
static int
filter_ldisplay(SCR *sp, FILE *fp)
{
	size_t len;

	EX_PRIVATE *exp;

	for (exp = EXP(sp); !ex_getline(sp, fp, &len) && !INTERRUPTED(sp);)
		if (ex_ldisplay(sp, exp->ibp, len, 0, 0))
			break;
	if (ferror(fp))
		msgq(sp, M_SYSERR, "filter read");
	(void)fclose(fp);
	return (0);
}
@


1.14
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.13 2015/01/16 06:40:14 deraadt Exp $	*/
d48 1
a48 1
	char *name, tname[PATH_MAX];
a81 4
		if (opts_empty(sp, O_TMP_DIRECTORY, 0))
			goto err;
		(void)snprintf(tname, sizeof(tname),
		    "%s/vi.XXXXXXXXXX", O_STR(sp, O_TMP_DIRECTORY));
@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.12 2014/11/12 04:28:41 bentley Exp $	*/
d89 1
a89 1
			    "237|Unable to create temporary file");
@


1.12
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.11 2011/07/10 13:20:25 millert Exp $	*/
a13 1
#include <sys/param.h>
d48 1
a48 1
	char *name, tname[MAXPATHLEN];
@


1.11
log
@Rename O_DIRECTORY to O_TMP_DIRECTORY to avoid a namespace collision
with sys/fcntl.h.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.10 2009/10/27 23:59:47 deraadt Exp $	*/
d42 2
a43 6
ex_filter(sp, cmdp, fm, tm, rp, cmd, ftype)
	SCR *sp;
	EXCMD *cmdp;
	MARK *fm, *tm, *rp;
	char *cmd;
	enum filtertype ftype;
d343 1
a343 3
filter_ldisplay(sp, fp)
	SCR *sp;
	FILE *fp;
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.9 2006/12/21 21:38:17 otto Exp $	*/
d87 1
a87 1
		if (opts_empty(sp, O_DIRECTORY, 0))
d90 1
a90 1
		    "%s/vi.XXXXXXXXXX", O_STR(sp, O_DIRECTORY));
@


1.9
log
@Fix !command piping by Alexander Bluhm in PR 5325. Tested by quite a
few on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.8 2006/01/08 21:05:40 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_filter.c	10.34 (Berkeley) 10/23/96";
#endif /* not lint */
@


1.8
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.7 2002/06/12 06:07:17 mpech Exp $	*/
d18 2
d56 2
a57 2
	int input[2], output[2], rval;
	char *name;
d89 39
a127 1
	if (ftype != FILTER_READ && pipe(input) < 0) {
a229 1
		goto uwait;
d233 1
a233 1
	 * FILTER_BANG, FILTER_WRITE
d244 1
a244 5
	 *		FILTER_BANG:
	 *			read lines into the file
	 *			delete old lines
	 *		FILTER_WRITE
	 *			read and display lines
a246 1
	 * XXX
d248 5
a252 8
	 * that none of the records that we're reading will be modified until
	 * after we've read them.  This depends on the fact that the current
	 * B+tree implementation doesn't balance pages or similar things when
	 * it inserts new records.  When the DB code has locking, we should
	 * treat vi as if it were multiple applications sharing a database, and
	 * do the required locking.  If necessary a work-around would be to do
	 * explicit locking in the line.c:db_get() code, based on the flag set
	 * here.
d254 23
a276 22
	F_SET(sp->ep, F_MULTILOCK);
	switch (parent_writer_pid = fork()) {
	case -1:			/* Error. */
		msgq(sp, M_SYSERR, "fork");
		(void)close(input[1]);
		(void)close(output[0]);
		rval = 1;
		break;
	case 0:				/* Parent-writer. */
		/*
		 * Write the selected lines to the write end of the input
		 * pipe.  This instance of ifp is closed by ex_writefp.
		 */
		(void)close(output[0]);
		if ((ifp = fdopen(input[1], "w")) == NULL)
			_exit (1);
		_exit(ex_writefp(sp, "filter", ifp, fm, tm, NULL, NULL, 1));

		/* NOTREACHED */
	default:			/* Parent-reader. */
		(void)close(input[1]);
		if (ftype == FILTER_WRITE) {
d283 4
a286 7
		} else {
			/*
			 * Read the output from the read end of the output
			 * pipe.  Ex_readfp appends to the MARK and closes
			 * ofp.
			 */
			if (ex_readfp(sp, "filter", ofp, tm, &nread, 1))
d288 1
a288 1
			sp->rptlines[L_ADDED] += nread;
d290 2
d293 20
a312 3
		/* Wait for the parent-writer. */
		if (proc_wait(sp,
		    parent_writer_pid, "parent-writer", 0, 1))
d314 1
d317 1
a317 1
		if (rval == 0 && ftype == FILTER_BANG &&
d321 1
a321 1
			break;
a330 1
		break;
a331 1
	F_CLR(sp->ep, F_MULTILOCK);
@


1.7
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.6 2002/02/17 19:42:34 millert Exp $	*/
d184 1
a184 1
		if (ftype == FILTER_READ)
d189 1
@


1.6
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.5 2002/02/16 21:27:57 millert Exp $	*/
d263 1
a263 1
		    (long)parent_writer_pid, "parent-writer", 0, 1))
d290 1
a290 1
uwait:	return (proc_wait(sp, (long)utility_pid, cmd,
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.4 2001/07/09 07:04:57 deraadt Exp $	*/
d40 2
a41 2
 * PUBLIC: int ex_filter __P((SCR *, 
 * PUBLIC:    EXCMD *, MARK *, MARK *, MARK *, char *, enum filtertype));
@


1.4
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_filter.c,v 1.3 2001/01/29 01:58:42 niklas Exp $	*/
d32 1
a32 1
static int filter_ldisplay __P((SCR *, FILE *));
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 1
		execl(O_STR(sp, O_SHELL), name, "-c", cmd, NULL);
@


1.2
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_filter.c	10.33 (Berkeley) 4/27/96";
d267 1
a267 1
		    delete(sp, fm, tm, 1))) {
@
