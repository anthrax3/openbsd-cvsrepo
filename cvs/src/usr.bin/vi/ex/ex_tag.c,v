head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.13.0.16
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.12
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.16
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.14
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.12
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.10
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.23;
commitid	adBvXLg05bJxz6yx;

1.23
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	gtDERb7QyXwKGs62;

1.22
date	2015.11.19.07.53.31;	author bentley;	state Exp;
branches;
next	1.21;
commitid	aNUlDSFtbBwW1Tdz;

1.21
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.19;
commitid	T0XpHzXjuQBl1V3E;

1.19
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.18;
commitid	06bi6U3x4gFFf2G1;

1.18
date	2014.11.10.21.40.11;	author tedu;	state Exp;
branches;
next	1.17;
commitid	XlFK1Ymau5jKpy9T;

1.17
date	2013.12.01.19.26.37;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2013.12.01.16.47.59;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.14.17.44.53;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.11.06.58.00;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.29.01.58.44;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.12.09.38.19;	author art;	state Exp;
branches;
next	1.6;

1.6
date	98.06.23.22.40.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.04.25.05.45.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.17.17.19.06;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.57;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@/*	$OpenBSD: ex_tag.c,v 1.23 2015/12/07 20:39:19 mmcc Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * David Hitz of Auspex Systems, Inc.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/mman.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"
#include "../vi/vi.h"
#include "tag.h"

static char	*binary_search(char *, char *, char *);
static int	 compare(char *, char *, char *);
static void	 ctag_file(SCR *, TAGF *, char *, char **, size_t *);
static int	 ctag_search(SCR *, char *, size_t, char *);
static int	 ctag_sfile(SCR *, TAGF *, TAGQ *, char *);
static TAGQ	*ctag_slist(SCR *, char *);
static char	*linear_search(char *, char *, char *);
static int	 tag_copy(SCR *, TAG *, TAG **);
static int	 tag_pop(SCR *, TAGQ *, int);
static int	 tagf_copy(SCR *, TAGF *, TAGF **);
static int	 tagf_free(SCR *, TAGF *);
static int	 tagq_copy(SCR *, TAGQ *, TAGQ **);

/*
 * ex_tag_first --
 *	The tag code can be entered from main, e.g., "vi -t tag".
 *
 * PUBLIC: int ex_tag_first(SCR *, char *);
 */
int
ex_tag_first(SCR *sp, char *tagarg)
{
	ARGS *ap[2], a;
	EXCMD cmd;

	/* Build an argument for the ex :tag command. */
	ex_cinit(&cmd, C_TAG, 0, OOBLNO, OOBLNO, 0, ap);
	ex_cadd(&cmd, &a, tagarg, strlen(tagarg));

	/*
	 * XXX
	 * Historic vi went ahead and created a temporary file when it failed
	 * to find the tag.  We match historic practice, but don't distinguish
	 * between real error and failure to find the tag.
	 */
	if (ex_tag_push(sp, &cmd))
		return (0);

	/* Display tags in the center of the screen. */
	F_CLR(sp, SC_SCR_TOP);
	F_SET(sp, SC_SCR_CENTER);

	return (0);
}

/*
 * ex_tag_push -- ^]
 *		  :tag[!] [string]
 *
 * Enter a new TAGQ context based on a ctag string.
 *
 * PUBLIC: int ex_tag_push(SCR *, EXCMD *);
 */
int
ex_tag_push(SCR *sp, EXCMD *cmdp)
{
	EX_PRIVATE *exp;
	FREF *frp;
	TAG *rtp;
	TAGQ *rtqp, *tqp;
	recno_t lno;
	size_t cno;
	long tl;
	int force, istmp;

	exp = EXP(sp);
	switch (cmdp->argc) {
	case 1:
		if (exp->tag_last != NULL)
			free(exp->tag_last);

		if ((exp->tag_last = strdup(cmdp->argv[0]->bp)) == NULL) {
			msgq(sp, M_SYSERR, NULL);
			return (1);
		}

		/* Taglength may limit the number of characters. */
		if ((tl =
		    O_VAL(sp, O_TAGLENGTH)) != 0 && strlen(exp->tag_last) > tl)
			exp->tag_last[tl] = '\0';
		break;
	case 0:
		if (exp->tag_last == NULL) {
			msgq(sp, M_ERR, "No previous tag entered");
			return (1);
		}
		break;
	default:
		abort();
	}

	/* Get the tag information. */
	if ((tqp = ctag_slist(sp, exp->tag_last)) == NULL)
		return (1);

	/*
	 * Allocate all necessary memory before swapping screens.  Initialize
	 * flags so we know what to free.
	 */
	rtp = NULL;
	rtqp = NULL;
	if (TAILQ_EMPTY(&exp->tq)) {
		/* Initialize the `local context' tag queue structure. */
		CALLOC_GOTO(sp, rtqp, 1, sizeof(TAGQ));
		TAILQ_INIT(&rtqp->tagq);

		/* Initialize and link in its tag structure. */
		CALLOC_GOTO(sp, rtp, 1, sizeof(TAG));
		TAILQ_INSERT_HEAD(&rtqp->tagq, rtp, q);
		rtqp->current = rtp;
	}

	/*
	 * Stick the current context information in a convenient place, we're
	 * about to lose it.  Note, if we're called on editor startup, there
	 * will be no FREF structure.
	 */
	frp = sp->frp;
	lno = sp->lno;
	cno = sp->cno;
	istmp = frp == NULL ||
	    (F_ISSET(frp, FR_TMPFILE) && !F_ISSET(cmdp, E_NEWSCREEN));

	/* Try to switch to the tag. */
	force = FL_ISSET(cmdp->iflags, E_C_FORCE);
	if (F_ISSET(cmdp, E_NEWSCREEN)) {
		if (ex_tag_Nswitch(sp, TAILQ_FIRST(&tqp->tagq), force))
			goto err;

		/* Everything else gets done in the new screen. */
		sp = sp->nextdisp;
		exp = EXP(sp);
	} else
		if (ex_tag_nswitch(sp, TAILQ_FIRST(&tqp->tagq), force))
			goto err;

	/*
	 * If this is the first tag, put a `current location' queue entry
	 * in place, so we can pop all the way back to the current mark.
	 * Note, it doesn't point to much of anything, it's a placeholder.
	 */
	if (TAILQ_EMPTY(&exp->tq)) {
		TAILQ_INSERT_HEAD(&exp->tq, rtqp, q);
	} else
		rtqp = TAILQ_FIRST(&exp->tq);

	/* Link the new TAGQ structure into place. */
	TAILQ_INSERT_HEAD(&exp->tq, tqp, q);

	(void)ctag_search(sp,
	    tqp->current->search, tqp->current->slen, tqp->tag);

	/*
	 * Move the current context from the temporary save area into the
	 * right structure.
	 *
	 * If we were in a temporary file, we don't have a context to which
	 * we can return, so just make it be the same as what we're moving
	 * to.  It will be a little odd that ^T doesn't change anything, but
	 * I don't think it's a big deal.
	 */
	if (istmp) {
		rtqp->current->frp = sp->frp;
		rtqp->current->lno = sp->lno;
		rtqp->current->cno = sp->cno;
	} else {
		rtqp->current->frp = frp;
		rtqp->current->lno = lno;
		rtqp->current->cno = cno;
	}
	return (0);

err:
alloc_err:
	if (rtqp != NULL)
		free(rtqp);
	if (rtp != NULL)
		free(rtp);
	tagq_free(sp, tqp);
	return (1);
}

/* 
 * ex_tag_next --
 *	Switch context to the next TAG.
 *
 * PUBLIC: int ex_tag_next(SCR *, EXCMD *);
 */
int
ex_tag_next(SCR *sp, EXCMD *cmdp)
{
	EX_PRIVATE *exp;
	TAG *tp;
	TAGQ *tqp;

	exp = EXP(sp);
	if ((tqp = TAILQ_FIRST(&exp->tq)) == NULL) {
		tag_msg(sp, TAG_EMPTY, NULL);
		return (1);
	}
	if ((tp = TAILQ_NEXT(tqp->current, q)) == NULL) {
		msgq(sp, M_ERR, "Already at the last tag of this group");
		return (1);
	}
	if (ex_tag_nswitch(sp, tp, FL_ISSET(cmdp->iflags, E_C_FORCE)))
		return (1);
	tqp->current = tp;

	(void)ctag_search(sp, tp->search, tp->slen, tqp->tag);

	return (0);
}

/* 
 * ex_tag_prev --
 *	Switch context to the next TAG.
 *
 * PUBLIC: int ex_tag_prev(SCR *, EXCMD *);
 */
int
ex_tag_prev(SCR *sp, EXCMD *cmdp)
{
	EX_PRIVATE *exp;
	TAG *tp;
	TAGQ *tqp;

	exp = EXP(sp);
	if ((tqp = TAILQ_FIRST(&exp->tq)) == NULL) {
		tag_msg(sp, TAG_EMPTY, NULL);
		return (0);
	}
	if ((tp = TAILQ_PREV(tqp->current, _tagqh, q)) == NULL) {
		msgq(sp, M_ERR, "Already at the first tag of this group");
		return (1);
	}
	if (ex_tag_nswitch(sp, tp, FL_ISSET(cmdp->iflags, E_C_FORCE)))
		return (1);
	tqp->current = tp;

	(void)ctag_search(sp, tp->search, tp->slen, tqp->tag);

	return (0);
}

/*
 * ex_tag_nswitch --
 *	Switch context to the specified TAG.
 *
 * PUBLIC: int ex_tag_nswitch(SCR *, TAG *, int);
 */
int
ex_tag_nswitch(SCR *sp, TAG *tp, int force)
{
	/* Get a file structure. */
	if (tp->frp == NULL && (tp->frp = file_add(sp, tp->fname)) == NULL)
		return (1);

	/* If not changing files, return, we're done. */
	if (tp->frp == sp->frp)
		return (0);

	/* Check for permission to leave. */
	if (file_m1(sp, force, FS_ALL | FS_POSSIBLE))
		return (1);

	/* Initialize the new file. */
	if (file_init(sp, tp->frp, NULL, FS_SETALT))
		return (1);

	/* Display tags in the center of the screen. */
	F_CLR(sp, SC_SCR_TOP);
	F_SET(sp, SC_SCR_CENTER);

	/* Switch. */
	F_SET(sp, SC_FSWITCH);
	return (0);
}

/*
 * ex_tag_Nswitch --
 *	Switch context to the specified TAG in a new screen.
 *
 * PUBLIC: int ex_tag_Nswitch(SCR *, TAG *, int);
 */
int
ex_tag_Nswitch(SCR *sp, TAG *tp, int force)
{
	SCR *new;

	/* Get a file structure. */
	if (tp->frp == NULL && (tp->frp = file_add(sp, tp->fname)) == NULL)
		return (1);

	/* Get a new screen. */
	if (screen_init(sp->gp, sp, &new))
		return (1);
	if (vs_split(sp, new, 0)) {
		(void)file_end(new, new->ep, 1);
		(void)screen_end(new);
		return (1);
	}

	/* Get a backing file. */
	if (tp->frp == sp->frp) {
		/* Copy file state. */
		new->ep = sp->ep;
		++new->ep->refcnt;

		new->frp = tp->frp;
		new->frp->flags = sp->frp->flags;
	} else if (file_init(new, tp->frp, NULL, force)) {
		(void)vs_discard(new, NULL);
		(void)screen_end(new);
		return (1);
	}

	/* Create the argument list. */
	new->cargv = new->argv = ex_buildargv(sp, NULL, tp->frp->name);

	/* Display tags in the center of the screen. */
	F_CLR(new, SC_SCR_TOP);
	F_SET(new, SC_SCR_CENTER);

	/* Switch. */
	sp->nextdisp = new;
	F_SET(sp, SC_SSWITCH);

	return (0);
}

/*
 * ex_tag_pop -- ^T
 *		 :tagp[op][!] [number | file]
 *
 *	Pop to a previous TAGQ context.
 *
 * PUBLIC: int ex_tag_pop(SCR *, EXCMD *);
 */
int
ex_tag_pop(SCR *sp, EXCMD *cmdp)
{
	EX_PRIVATE *exp;
	TAGQ *tqp, *dtqp = NULL;
	size_t arglen;
	long off;
	char *arg, *p, *t;

	/* Check for an empty stack. */
	exp = EXP(sp);
	if (TAILQ_EMPTY(&exp->tq)) {
		tag_msg(sp, TAG_EMPTY, NULL);
		return (1);
	}

	/* Find the last TAG structure that we're going to DISCARD! */
	switch (cmdp->argc) {
	case 0:				/* Pop one tag. */
		dtqp = TAILQ_FIRST(&exp->tq);
		break;
	case 1:				/* Name or number. */
		arg = cmdp->argv[0]->bp;
		off = strtol(arg, &p, 10);
		if (*p != '\0')
			goto filearg;

		/* Number: pop that many queue entries. */
		if (off < 1)
			return (0);
		TAILQ_FOREACH(tqp, &exp->tq, q) {
			if (--off <= 1)
				break;
		}
		if (tqp == NULL) {
			msgq(sp, M_ERR,
	"Less than %s entries on the tags stack; use :display t[ags]",
			    arg);
			return (1);
		}
		dtqp = tqp;
		break;

		/* File argument: pop to that queue entry. */
filearg:	arglen = strlen(arg);
		for (tqp = TAILQ_FIRST(&exp->tq); tqp;
		    dtqp = tqp, tqp = TAILQ_NEXT(tqp, q)) {
			/* Don't pop to the current file. */
			if (tqp == TAILQ_FIRST(&exp->tq))
				continue;
			p = tqp->current->frp->name;
			if ((t = strrchr(p, '/')) == NULL)
				t = p;
			else
				++t;
			if (!strncmp(arg, t, arglen))
				break;
		}
		if (tqp == NULL) {
			msgq_str(sp, M_ERR, arg,
	"No file %s on the tags stack to return to; use :display t[ags]");
			return (1);
		}
		if (tqp == TAILQ_FIRST(&exp->tq))
			return (0);
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	return (tag_pop(sp, dtqp, FL_ISSET(cmdp->iflags, E_C_FORCE)));
}

/*
 * ex_tag_top -- :tagt[op][!]
 *	Clear the tag stack.
 *
 * PUBLIC: int ex_tag_top(SCR *, EXCMD *);
 */
int
ex_tag_top(SCR *sp, EXCMD *cmdp)
{
	EX_PRIVATE *exp;

	exp = EXP(sp);

	/* Check for an empty stack. */
	if (TAILQ_EMPTY(&exp->tq)) {
		tag_msg(sp, TAG_EMPTY, NULL);
		return (1);
	}

	/* Return to the oldest information. */
	return (tag_pop(sp,
	    TAILQ_PREV(TAILQ_LAST(&exp->tq, _tqh), _tqh, q),
	    FL_ISSET(cmdp->iflags, E_C_FORCE)));
}

/*
 * tag_pop --
 *	Pop up to and including the specified TAGQ context.
 */
static int
tag_pop(SCR *sp, TAGQ *dtqp, int force)
{
	EX_PRIVATE *exp;
	TAG *tp;
	TAGQ *tqp;

	exp = EXP(sp);

	/*
	 * Update the cursor from the saved TAG information of the TAG
	 * structure we're moving to.
	 */
	tp = TAILQ_NEXT(dtqp, q)->current;
	if (tp->frp == sp->frp) {
		sp->lno = tp->lno;
		sp->cno = tp->cno;
	} else {
		if (file_m1(sp, force, FS_ALL | FS_POSSIBLE))
			return (1);

		tp->frp->lno = tp->lno;
		tp->frp->cno = tp->cno;
		F_SET(sp->frp, FR_CURSORSET);
		if (file_init(sp, tp->frp, NULL, FS_SETALT))
			return (1);

		F_SET(sp, SC_FSWITCH);
	}

	/* Pop entries off the queue up to and including dtqp. */
	do {
		tqp = TAILQ_FIRST(&exp->tq);
		if (tagq_free(sp, tqp))
			return (0);
	} while (tqp != dtqp);

	/*
	 * If only a single tag left, we've returned to the first tag point,
	 * and the stack is now empty.
	 */
	if (TAILQ_NEXT(TAILQ_FIRST(&exp->tq), q) == NULL)
		tagq_free(sp, TAILQ_FIRST(&exp->tq));

	return (0);
}

/*
 * ex_tag_display --
 *	Display the list of tags.
 *
 * PUBLIC: int ex_tag_display(SCR *);
 */
int
ex_tag_display(SCR *sp)
{
	EX_PRIVATE *exp;
	TAG *tp;
	TAGQ *tqp;
	int cnt;
	size_t len;
	char *p;

	exp = EXP(sp);
	if (TAILQ_EMPTY(&exp->tq)) {
		tag_msg(sp, TAG_EMPTY, NULL);
		return (0);
	}
	tqp = TAILQ_FIRST(&exp->tq);

	/*
	 * We give the file name 20 columns and the search string the rest.
	 * If there's not enough room, we don't do anything special, it's
	 * not worth the effort, it just makes the display more confusing.
	 *
	 * We also assume that characters in file names map 1-1 to printing
	 * characters.  This might not be true, but I don't think it's worth
	 * fixing.  (The obvious fix is to pass the filenames through the
	 * msg_print function.)
	 */
#define	L_NAME	30		/* Name. */
#define	L_SLOP	 4		/* Leading number plus trailing *. */
#define	L_SPACE	 5		/* Spaces after name, before tag. */
#define	L_TAG	20		/* Tag. */
	if (sp->cols <= L_NAME + L_SLOP) {
		msgq(sp, M_ERR, "Display too small.");
		return (0);
	}

	/*
	 * Display the list of tags for each queue entry.  The first entry
	 * is numbered, and the current tag entry has an asterisk appended.
	 */
	cnt = 0;
	TAILQ_FOREACH(tqp, &exp->tq, q) {
		if (INTERRUPTED(sp))
			break;
		++cnt;
		TAILQ_FOREACH(tp, &tqp->tagq, q) {
			if (tp == TAILQ_FIRST(&tqp->tagq))
				(void)ex_printf(sp, "%2d ", cnt);
			else
				(void)ex_printf(sp, "   ");
			p = tp->frp == NULL ? tp->fname : tp->frp->name;
			if ((len = strlen(p)) > L_NAME) {
				len = len - (L_NAME - 4);
				(void)ex_printf(sp, "   ... %*.*s",
				    L_NAME - 4, L_NAME - 4, p + len);
			} else
				(void)ex_printf(sp,
				    "   %*.*s", L_NAME, L_NAME, p);
			if (tqp->current == tp)
				(void)ex_printf(sp, "*");

			if (tp == TAILQ_FIRST(&tqp->tagq) && tqp->tag != NULL &&
			    (sp->cols - L_NAME) >= L_TAG + L_SPACE) {
				len = strlen(tqp->tag);
				if (len > sp->cols - (L_NAME + L_SPACE))
					len = sp->cols - (L_NAME + L_SPACE);
				(void)ex_printf(sp, "%s%.*s",
				    tqp->current == tp ? "    " : "     ",
				    (int)len, tqp->tag);
			}
			(void)ex_printf(sp, "\n");
		}
	}
	return (0);
}

/*
 * ex_tag_copy --
 *	Copy a screen's tag structures.
 *
 * PUBLIC: int ex_tag_copy(SCR *, SCR *);
 */
int
ex_tag_copy(SCR *orig, SCR *sp)
{
	EX_PRIVATE *oexp, *nexp;
	TAGQ *aqp, *tqp;
	TAG *ap, *tp;
	TAGF *atfp, *tfp;

	oexp = EXP(orig);
	nexp = EXP(sp);

	/* Copy tag queue and tags stack. */
	TAILQ_FOREACH(aqp, &oexp->tq, q) {
		if (tagq_copy(sp, aqp, &tqp))
			return (1);
		TAILQ_FOREACH(ap, &aqp->tagq, q) {
			if (tag_copy(sp, ap, &tp))
				return (1);
			/* Set the current pointer. */
			if (aqp->current == ap)
				tqp->current = tp;
			TAILQ_INSERT_TAIL(&tqp->tagq, tp, q);
		}
		TAILQ_INSERT_TAIL(&nexp->tq, tqp, q);
	}

	/* Copy list of tag files. */
	TAILQ_FOREACH(atfp, &oexp->tagfq, q) {
		if (tagf_copy(sp, atfp, &tfp))
			return (1);
		TAILQ_INSERT_TAIL(&nexp->tagfq, tfp, q);
	}

	/* Copy the last tag. */
	if (oexp->tag_last != NULL &&
	    (nexp->tag_last = strdup(oexp->tag_last)) == NULL) {
		msgq(sp, M_SYSERR, NULL);
		return (1);
	}
	return (0);
}

/*
 * tagf_copy --
 *	Copy a TAGF structure and return it in new memory.
 */
static int
tagf_copy(SCR *sp, TAGF *otfp, TAGF **tfpp)
{
	TAGF *tfp;

	MALLOC_RET(sp, tfp, sizeof(TAGF));
	*tfp = *otfp;

	/* XXX: Allocate as part of the TAGF structure!!! */
	if ((tfp->name = strdup(otfp->name)) == NULL) {
		free(tfp);
		return (1);
	}

	*tfpp = tfp;
	return (0);
}

/*
 * tagq_copy --
 *	Copy a TAGQ structure and return it in new memory.
 */
static int
tagq_copy(SCR *sp, TAGQ *otqp, TAGQ **tqpp)
{
	TAGQ *tqp;
	size_t len;

	len = sizeof(TAGQ);
	if (otqp->tag != NULL)
		len += otqp->tlen + 1;
	MALLOC_RET(sp, tqp, len);
	memcpy(tqp, otqp, len);

	TAILQ_INIT(&tqp->tagq);
	tqp->current = NULL;
	if (otqp->tag != NULL)
		tqp->tag = tqp->buf;

	*tqpp = tqp;
	return (0);
}

/*
 * tag_copy --
 *	Copy a TAG structure and return it in new memory.
 */
static int
tag_copy(SCR *sp, TAG *otp, TAG **tpp)
{
	TAG *tp;
	size_t len;

	len = sizeof(TAG);
	if (otp->fname != NULL)
		len += otp->fnlen + 1;
	if (otp->search != NULL)
		len += otp->slen + 1;
	MALLOC_RET(sp, tp, len);
	memcpy(tp, otp, len);

	if (otp->fname != NULL)
		tp->fname = tp->buf;
	if (otp->search != NULL)
		tp->search = tp->fname + otp->fnlen + 1;

	*tpp = tp;
	return (0);
}

/*
 * tagf_free --
 *	Free a TAGF structure.
 */
static int
tagf_free(SCR *sp, TAGF *tfp)
{
	EX_PRIVATE *exp;

	exp = EXP(sp);
	TAILQ_REMOVE(&exp->tagfq, tfp, q);
	free(tfp->name);
	free(tfp);
	return (0);
}

/*
 * tagq_free --
 *	Free a TAGQ structure (and associated TAG structures).
 *
 * PUBLIC: int tagq_free(SCR *, TAGQ *);
 */
int
tagq_free(SCR *sp, TAGQ *tqp)
{
	EX_PRIVATE *exp;
	TAGQ *ttqp;
	TAG *tp;

	exp = EXP(sp);
	while ((tp = TAILQ_FIRST(&tqp->tagq))) {
		TAILQ_REMOVE(&tqp->tagq, tp, q);
		free(tp);
	}
	/*
	 * !!!
	 * If allocated and then the user failed to switch files, the TAGQ
	 * structure was never attached to any list.
	 */
	TAILQ_FOREACH(ttqp, &exp->tq, q) {
		if (ttqp == tqp) {
			TAILQ_REMOVE(&exp->tq, tqp, q);
			break;
		}
	}
	free(tqp);
	return (0);
}

/*
 * tag_msg
 *	A few common messages.
 *
 * PUBLIC: void tag_msg(SCR *, tagmsg_t, char *);
 */
void
tag_msg(SCR *sp, tagmsg_t msg, char *tag)
{
	switch (msg) {
	case TAG_BADLNO:
		msgq_str(sp, M_ERR, tag,
	    "%s: the tag's line number is past the end of the file");
		break;
	case TAG_EMPTY:
		msgq(sp, M_INFO, "The tags stack is empty");
		break;
	case TAG_SEARCH:
		msgq_str(sp, M_ERR, tag, "%s: search pattern not found");
		break;
	default:
		abort();
	}
}

/*
 * ex_tagf_alloc --
 *	Create a new list of ctag files.
 *
 * PUBLIC: int ex_tagf_alloc(SCR *, char *);
 */
int
ex_tagf_alloc(SCR *sp, char *str)
{
	EX_PRIVATE *exp;
	TAGF *tfp;
	size_t len;
	char *p, *t;

	/* Free current queue. */
	exp = EXP(sp);
	while ((tfp = TAILQ_FIRST(&exp->tagfq)) != NULL)
		tagf_free(sp, tfp);

	/* Create new queue. */
	for (p = t = str;; ++p) {
		if (*p == '\0' || isblank(*p)) {
			if ((len = p - t) > 1) {
				MALLOC_RET(sp, tfp, sizeof(TAGF));
				MALLOC(sp, tfp->name, len + 1);
				if (tfp->name == NULL) {
					free(tfp);
					return (1);
				}
				memcpy(tfp->name, t, len);
				tfp->name[len] = '\0';
				tfp->flags = 0;
				TAILQ_INSERT_TAIL(&exp->tagfq, tfp, q);
			}
			t = p + 1;
		}
		if (*p == '\0')
			 break;
	}
	return (0);
}
						/* Free previous queue. */
/*
 * ex_tag_free --
 *	Free the ex tag information.
 *
 * PUBLIC: int ex_tag_free(SCR *);
 */
int
ex_tag_free(SCR *sp)
{
	EX_PRIVATE *exp;
	TAGF *tfp;
	TAGQ *tqp;

	/* Free up tag information. */
	exp = EXP(sp);
	while ((tqp = TAILQ_FIRST(&exp->tq)))
		tagq_free(sp, tqp);	/* tagq_free removes tqp from queue. */
	while ((tfp = TAILQ_FIRST(&exp->tagfq)) != NULL)
		tagf_free(sp, tfp);
	if (exp->tag_last != NULL)
		free(exp->tag_last);
	return (0);
}

/*
 * ctag_search --
 *	Search a file for a tag.
 */
static int
ctag_search(SCR *sp, char *search, size_t slen, char *tag)
{
	MARK m;
	char *p;

	/*
	 * !!!
	 * The historic tags file format (from a long, long time ago...)
	 * used a line number, not a search string.  I got complaints, so
	 * people are still using the format.  POSIX 1003.2 permits it.
	 */
	if (isdigit(search[0])) {
		m.lno = atoi(search);
		if (!db_exist(sp, m.lno)) {
			tag_msg(sp, TAG_BADLNO, tag);
			return (1);
		}
	} else {
		/*
		 * Search for the tag; cheap fallback for C functions
		 * if the name is the same but the arguments have changed.
		 */
		m.lno = 1;
		m.cno = 0;
		if (f_search(sp, &m, &m,
		    search, slen, NULL, SEARCH_FILE | SEARCH_TAG)) {
			if ((p = strrchr(search, '(')) != NULL) {
				slen = p - search;
				if (f_search(sp, &m, &m, search, slen,
				    NULL, SEARCH_FILE | SEARCH_TAG))
					goto notfound;
			} else {
notfound:			tag_msg(sp, TAG_SEARCH, tag);
				return (1);
			}
		}
		/*
		 * !!!
		 * Historically, tags set the search direction if it wasn't
		 * already set.
		 */
		if (sp->searchdir == NOTSET)
			sp->searchdir = FORWARD;
	}

	/*
	 * !!!
	 * Tags move to the first non-blank, NOT the search pattern start.
	 */
	sp->lno = m.lno;
	sp->cno = 0;
	(void)nonblank(sp, sp->lno, &sp->cno);
	return (0);
}

/*
 * ctag_slist --
 *	Search the list of tags files for a tag, and return tag queue.
 */
static TAGQ *
ctag_slist(SCR *sp, char *tag)
{
	EX_PRIVATE *exp;
	TAGF *tfp;
	TAGQ *tqp;
	size_t len;
	int echk;

	exp = EXP(sp);

	/* Allocate and initialize the tag queue structure. */
	len = strlen(tag);
	CALLOC_GOTO(sp, tqp, 1, sizeof(TAGQ) + len + 1);
	TAILQ_INIT(&tqp->tagq);
	tqp->tag = tqp->buf;
	memcpy(tqp->tag, tag, (tqp->tlen = len) + 1);

	/*
	 * Find the tag, only display missing file messages once, and
	 * then only if we didn't find the tag.
	 */
	echk = 0;
	TAILQ_FOREACH(tfp, &exp->tagfq, q)
		if (ctag_sfile(sp, tfp, tqp, tag)) {
			echk = 1;
			F_SET(tfp, TAGF_ERR);
		} else
			F_CLR(tfp, TAGF_ERR | TAGF_ERR_WARN);

	/* Check to see if we found anything. */
	if (TAILQ_EMPTY(&tqp->tagq)) {
		msgq_str(sp, M_ERR, tag, "%s: tag not found");
		if (echk)
			TAILQ_FOREACH(tfp, &exp->tagfq, q)
				if (F_ISSET(tfp, TAGF_ERR) &&
				    !F_ISSET(tfp, TAGF_ERR_WARN)) {
					errno = tfp->errnum;
					msgq_str(sp, M_SYSERR, tfp->name, "%s");
					F_SET(tfp, TAGF_ERR_WARN);
				}
		free(tqp);
		return (NULL);
	}

	tqp->current = TAILQ_FIRST(&tqp->tagq);
	return (tqp);

alloc_err:
	return (NULL);
}

/*
 * ctag_sfile --
 *	Search a tags file for a tag, adding any found to the tag queue.
 */
static int
ctag_sfile(SCR *sp, TAGF *tfp, TAGQ *tqp, char *tname)
{
	struct stat sb;
	TAG *tp;
	size_t dlen, nlen, slen;
	int fd, i, nf1, nf2;
	char *back, *cname, *dname, *front, *map, *name, *p, *search, *t;

	if ((fd = open(tfp->name, O_RDONLY, 0)) < 0) {
		tfp->errnum = errno;
		return (1);
	}

	/*
	 * XXX
	 * We'd like to test if the file is too big to mmap.  Since we don't
	 * know what size or type off_t's or size_t's are, what the largest
	 * unsigned integral type is, or what random insanity the local C
	 * compiler will perpetrate, doing the comparison in a portable way
	 * is flatly impossible.  Hope mmap fails if the file is too large.
	 */
	if (fstat(fd, &sb) != 0 ||
	    (map = mmap(NULL, (size_t)sb.st_size, PROT_READ | PROT_WRITE,
	    MAP_PRIVATE, fd, (off_t)0)) == MAP_FAILED) {
		tfp->errnum = errno;
		(void)close(fd);
		return (1);
	}

	front = map;
	back = front + sb.st_size;
	front = binary_search(tname, front, back);
	front = linear_search(tname, front, back);
	if (front == NULL)
		goto done;

	/*
	 * Initialize and link in the tag structure(s).  The historic ctags
	 * file format only permitted a single tag location per tag.  The
	 * obvious extension to permit multiple tags locations per tag is to
	 * output multiple records in the standard format.  Unfortunately,
	 * this won't work correctly with historic ex/vi implementations,
	 * because their binary search assumes that there's only one record
	 * per tag, and so will use a random tag entry if there si more than
	 * one.  This code handles either format.
	 *
	 * The tags file is in the following format:
	 *
	 *	<tag> <filename> <line number> | <pattern>
	 *
	 * Figure out how long everything is so we can allocate in one swell
	 * foop, but discard anything that looks wrong.
	 */
	for (;;) {
		/* Nul-terminate the end of the line. */
		for (p = front; p < back && *p != '\n'; ++p);
		if (p == back || *p != '\n')
			break;
		*p = '\0';

		/* Update the pointers for the next time. */
		t = p + 1;
		p = front;
		front = t;

		/* Break the line into tokens. */
		for (i = 0; i < 2 && (t = strsep(&p, "\t ")) != NULL; ++i)
			switch (i) {
			case 0:			/* Tag. */
				cname = t;
				break;
			case 1:			/* Filename. */
				name = t;
				nlen = strlen(name);
				break;
			}

		/* Check for corruption. */
		if (i != 2 || p == NULL || t == NULL)
			goto corrupt;

		/* The rest of the string is the search pattern. */
		search = p;
		if ((slen = strlen(p)) == 0) {
corrupt:		p = msg_print(sp, tname, &nf1);
			t = msg_print(sp, tfp->name, &nf2);
			msgq(sp, M_ERR, "%s: corrupted tag in %s", p, t);
			if (nf1)
				FREE_SPACE(sp, p, 0);
			if (nf2)
				FREE_SPACE(sp, t, 0);
			continue;
		}

		/* Check for passing the last entry. */
		if (strcmp(tname, cname))
			break;

		/* Resolve the file name. */
		ctag_file(sp, tfp, name, &dname, &dlen);

		CALLOC_GOTO(sp, tp,
		    1, sizeof(TAG) + dlen + 2 + nlen + 1 + slen + 1);
		tp->fname = tp->buf;
		if (dlen != 0) {
			memcpy(tp->fname, dname, dlen);
			tp->fname[dlen] = '/';
			++dlen;
		}
		memcpy(tp->fname + dlen, name, nlen + 1);
		tp->fnlen = dlen + nlen;
		tp->search = tp->fname + tp->fnlen + 1;
		memcpy(tp->search, search, (tp->slen = slen) + 1);
		TAILQ_INSERT_TAIL(&tqp->tagq, tp, q);
	}

alloc_err:
done:	if (munmap(map, (size_t)sb.st_size))
		msgq(sp, M_SYSERR, "munmap");
	if (close(fd))
		msgq(sp, M_SYSERR, "close");
	return (0);
}

/*
 * ctag_file --
 *	Search for the right path to this file.
 */
static void
ctag_file(SCR *sp, TAGF *tfp, char *name, char **dirp, size_t *dlenp)
{
	struct stat sb;
	char *p, buf[PATH_MAX];

	/*
	 * !!!
	 * If the tag file path is a relative path, see if it exists.  If it
	 * doesn't, look relative to the tags file path.  It's okay for a tag
	 * file to not exist, and historically, vi simply displayed a "new"
	 * file.  However, if the path exists relative to the tag file, it's
	 * pretty clear what's happening, so we may as well get it right.
	 */
	*dlenp = 0;
	if (name[0] != '/' &&
	    stat(name, &sb) && (p = strrchr(tfp->name, '/')) != NULL) {
		*p = '\0';
		(void)snprintf(buf, sizeof(buf), "%s/%s", tfp->name, name);
		if (stat(buf, &sb) == 0) {
			*dirp = tfp->name;
			*dlenp = strlen(*dirp);
		}
		*p = '/';
	}
}

/*
 * Binary search for "string" in memory between "front" and "back".
 *
 * This routine is expected to return a pointer to the start of a line at
 * *or before* the first word matching "string".  Relaxing the constraint
 * this way simplifies the algorithm.
 *
 * Invariants:
 * 	front points to the beginning of a line at or before the first
 *	matching string.
 *
 * 	back points to the beginning of a line at or after the first
 *	matching line.
 *
 * Base of the Invariants.
 * 	front = NULL;
 *	back = EOF;
 *
 * Advancing the Invariants:
 *
 * 	p = first newline after halfway point from front to back.
 *
 * 	If the string at "p" is not greater than the string to match,
 *	p is the new front.  Otherwise it is the new back.
 *
 * Termination:
 *
 * 	The definition of the routine allows it return at any point,
 *	since front is always at or before the line to print.
 *
 * 	In fact, it returns when the chosen "p" equals "back".  This
 *	implies that there exists a string is least half as long as
 *	(back - front), which in turn implies that a linear search will
 *	be no more expensive than the cost of simply printing a string or two.
 *
 * 	Trying to continue with binary search at this point would be
 *	more trouble than it's worth.
 */
#define	EQUAL		0
#define	GREATER		1
#define	LESS		(-1)

#define	SKIP_PAST_NEWLINE(p, back)	while ((p) < (back) && *(p)++ != '\n');

static char *
binary_search(char *string, char *front, char *back)
{
	char *p;

	p = front + (back - front) / 2;
	SKIP_PAST_NEWLINE(p, back);

	while (p != back) {
		if (compare(string, p, back) == GREATER)
			front = p;
		else
			back = p;
		p = front + (back - front) / 2;
		SKIP_PAST_NEWLINE(p, back);
	}
	return (front);
}

/*
 * Find the first line that starts with string, linearly searching from front
 * to back.
 *
 * Return NULL for no such line.
 *
 * This routine assumes:
 *
 * 	o front points at the first character in a line.
 *	o front is before or at the first line to be printed.
 */
static char *
linear_search(char *string, char *front, char *back)
{
	while (front < back) {
		switch (compare(string, front, back)) {
		case EQUAL:		/* Found it. */
			return (front);
		case LESS:		/* No such string. */
			return (NULL);
		case GREATER:		/* Keep going. */
			break;
		}
		SKIP_PAST_NEWLINE(front, back);
	}
	return (NULL);
}

/*
 * Return LESS, GREATER, or EQUAL depending on how the string1 compares
 * with string2 (s1 ??? s2).
 *
 * 	o Matches up to len(s1) are EQUAL.
 *	o Matches up to len(s2) are GREATER.
 *
 * The string "s1" is null terminated.  The string s2 is '\t', space, (or
 * "back") terminated.
 *
 * !!!
 * Reasonably modern ctags programs use tabs as separators, not spaces.
 * However, historic programs did use spaces, and, I got complaints.
 */
static int
compare(char *s1, char *s2, char *back)
{
	for (; *s1 && s2 < back && (*s2 != '\t' && *s2 != ' '); ++s1, ++s2)
		if (*s1 != *s2)
			return (*s1 < *s2 ? LESS : GREATER);
	return (*s1 ? GREATER : s2 < back &&
	    (*s2 != '\t' && *s2 != ' ') ? LESS : EQUAL);
}
@


1.23
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.22 2015/11/19 07:53:31 bentley Exp $	*/
d120 1
a120 1
			msgq(sp, M_ERR, "158|No previous tag entered");
d238 1
a238 1
		msgq(sp, M_ERR, "282|Already at the last tag of this group");
d269 1
a269 1
		msgq(sp, M_ERR, "255|Already at the first tag of this group");
d411 1
a411 1
	"159|Less than %s entries on the tags stack; use :display t[ags]",
d435 1
a435 1
	"160|No file %s on the tags stack to return to; use :display t[ags]");
d563 1
a563 1
		msgq(sp, M_ERR, "292|Display too small.");
d790 1
a790 1
	    "164|%s: the tag's line number is past the end of the file");
d793 1
a793 1
		msgq(sp, M_INFO, "165|The tags stack is empty");
d796 1
a796 1
		msgq_str(sp, M_ERR, tag, "166|%s: search pattern not found");
d965 1
a965 1
		msgq_str(sp, M_ERR, tag, "162|%s: tag not found");
d1076 1
a1076 1
			msgq(sp, M_ERR, "163|%s: corrupted tag in %s", p, t);
@


1.22
log
@Remove cscope support in vi.

It makes no sense to keep support for a non-base tool in base, especially
for a feature that few if any people use.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.21 2015/01/16 06:40:14 deraadt Exp $	*/
d140 1
a140 1
		CALLOC_GOTO(sp, rtqp, TAGQ *, 1, sizeof(TAGQ));
d144 1
a144 1
		CALLOC_GOTO(sp, rtp, TAG *, 1, sizeof(TAG));
d664 1
a664 1
	MALLOC_RET(sp, tfp, TAGF *, sizeof(TAGF));
d690 1
a690 1
	MALLOC_RET(sp, tqp, TAGQ *, len);
d717 1
a717 1
	MALLOC_RET(sp, tp, TAG *, len);
d826 2
a827 2
				MALLOC_RET(sp, tfp, TAGF *, sizeof(TAGF));
				MALLOC(sp, tfp->name, char *, len + 1);
d946 1
a946 1
	CALLOC_GOTO(sp, tqp, TAGQ *, 1, sizeof(TAGQ) + len + 1);
d1092 1
a1092 1
		    TAG *, 1, sizeof(TAG) + dlen + 2 + nlen + 1 + slen + 1);
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.20 2014/11/12 16:29:04 millert Exp $	*/
d245 2
a246 4
	if (F_ISSET(tqp, TAG_CSCOPE))
		(void)cscope_search(sp, tqp, tp);
	else
		(void)ctag_search(sp, tp->search, tp->slen, tqp->tag);
d276 2
a277 4
	if (F_ISSET(tqp, TAG_CSCOPE))
		(void)cscope_search(sp, tqp, tp);
	else
		(void)ctag_search(sp, tp->search, tp->slen, tqp->tag);
@


1.20
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.19 2014/11/12 04:28:41 bentley Exp $	*/
a16 1
#include <sys/param.h>
d1126 1
a1126 1
	char *p, buf[MAXPATHLEN];
@


1.19
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.18 2014/11/10 21:40:11 tedu Exp $	*/
a17 1
#include <sys/types.h>		/* XXX: param.h may not have included types.h */
a1009 8
	 * Some old BSD systems require MAP_FILE as an argument when mapping
	 * regular files.
	 */
#ifndef MAP_FILE
#define	MAP_FILE	0
#endif
	/*
	 * XXX
d1018 1
a1018 1
	    MAP_FILE | MAP_PRIVATE, fd, (off_t)0)) == MAP_FAILED) {
@


1.18
log
@remove various bits of autoconf cruft. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.17 2013/12/01 19:26:37 krw Exp $	*/
d59 1
a59 3
ex_tag_first(sp, tagarg)
	SCR *sp;
	char *tagarg;
d93 1
a93 3
ex_tag_push(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d228 1
a228 3
ex_tag_next(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d261 1
a261 3
ex_tag_prev(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d294 1
a294 4
ex_tag_nswitch(sp, tp, force)
	SCR *sp;
	TAG *tp;
	int force;
d328 1
a328 4
ex_tag_Nswitch(sp, tp, force)
	SCR *sp;
	TAG *tp;
	int force;
d382 1
a382 3
ex_tag_pop(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d462 1
a462 3
ex_tag_top(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d485 1
a485 4
tag_pop(sp, dtqp, force)
	SCR *sp;
	TAGQ *dtqp;
	int force;
d538 1
a538 2
ex_tag_display(sp)
	SCR *sp;
d620 1
a620 2
ex_tag_copy(orig, sp)
	SCR *orig, *sp;
d666 1
a666 3
tagf_copy(sp, otfp, tfpp)
	SCR *sp;
	TAGF *otfp, **tfpp;
d688 1
a688 3
tagq_copy(sp, otqp, tqpp)
	SCR *sp;
	TAGQ *otqp, **tqpp;
d713 1
a713 3
tag_copy(sp, otp, tpp)
	SCR *sp;
	TAG *otp, **tpp;
d740 1
a740 3
tagf_free(sp, tfp)
	SCR *sp;
	TAGF *tfp;
d758 1
a758 3
tagq_free(sp, tqp)
	SCR *sp;
	TAGQ *tqp;
d791 1
a791 4
tag_msg(sp, msg, tag)
	SCR *sp;
	tagmsg_t msg;
	char *tag;
d816 1
a816 3
ex_tagf_alloc(sp, str)
	SCR *sp;
	char *str;
d858 1
a858 2
ex_tag_free(sp)
	SCR *sp;
d880 1
a880 4
ctag_search(sp, search, slen, tag)
	SCR *sp;
	char *search, *tag;
	size_t slen;
d940 1
a940 3
ctag_slist(sp, tag)
	SCR *sp;
	char *tag;
d996 1
a996 5
ctag_sfile(sp, tfp, tqp, tname)
	SCR *sp;
	TAGF *tfp;
	TAGQ *tqp;
	char *tname;
d1133 1
a1133 5
ctag_file(sp, tfp, name, dirp, dlenp)
	SCR *sp;
	TAGF *tfp;
	char *name, **dirp;
	size_t *dlenp;
d1204 1
a1204 2
binary_search(string, front, back)
	char *string, *front, *back;
d1234 1
a1234 2
linear_search(string, front, back)
	char *string, *front, *back;
d1265 1
a1265 2
compare(s1, s2, back)
	char *s1, *s2, *back;
@


1.17
log
@Change the tags queue from CIRCLEQ to TAILQ.

ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.16 2013/12/01 16:47:59 krw Exp $	*/
a18 2

#ifdef HAVE_SYS_MMAN_H
a19 2
#endif

@


1.16
log
@Change the tag queue from CIRCLEQ to TAILQ.

Fixes & ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.15 2009/11/14 17:44:53 jsg Exp $	*/
d151 1
a151 1
		CIRCLEQ_INIT(&rtqp->tagq);
d155 1
a155 1
		CIRCLEQ_INSERT_HEAD(&rtqp->tagq, rtp, q);
d173 1
a173 1
		if (ex_tag_Nswitch(sp, CIRCLEQ_FIRST(&tqp->tagq), force))
d180 1
a180 1
		if (ex_tag_nswitch(sp, CIRCLEQ_FIRST(&tqp->tagq), force))
d249 1
a249 1
	if ((tp = CIRCLEQ_NEXT(tqp->current, q)) == CIRCLEQ_END(&tqp->tagq)) {
d284 1
a284 1
	if ((tp = CIRCLEQ_PREV(tqp->current, q)) == CIRCLEQ_END(&tqp->tagq)) {
d608 2
a609 2
		CIRCLEQ_FOREACH(tp, &tqp->tagq, q) {
			if (tp == CIRCLEQ_FIRST(&tqp->tagq))
d624 1
a624 1
			if (tp == CIRCLEQ_FIRST(&tqp->tagq) && tqp->tag != NULL &&
d661 1
a661 1
		CIRCLEQ_FOREACH(ap, &aqp->tagq, q) {
d667 1
a667 1
			CIRCLEQ_INSERT_TAIL(&tqp->tagq, tp, q);
d730 1
a730 1
	CIRCLEQ_INIT(&tqp->tagq);
d802 2
a803 2
	while ((tp = CIRCLEQ_FIRST(&tqp->tagq)) != CIRCLEQ_END(&tqp->tagq)) {
		CIRCLEQ_REMOVE(&tqp->tagq, tp, q);
d1001 1
a1001 1
	CIRCLEQ_INIT(&tqp->tagq);
d1018 1
a1018 1
	if (CIRCLEQ_FIRST(&tqp->tagq) == CIRCLEQ_END(&tqp->tagq)) {
d1032 1
a1032 1
	tqp->current = CIRCLEQ_FIRST(&tqp->tagq);
d1169 1
a1169 1
		CIRCLEQ_INSERT_TAIL(&tqp->tagq, tp, q);
@


1.15
log
@fix leaks in error paths found by parfait
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.14 2009/10/27 23:59:47 deraadt Exp $	*/
d148 1
a148 1
	if (CIRCLEQ_FIRST(&exp->tq) == CIRCLEQ_END(&exp->tq)) {
d188 2
a189 2
	if (CIRCLEQ_FIRST(&exp->tq) == CIRCLEQ_END(&exp->tq)) {
		CIRCLEQ_INSERT_HEAD(&exp->tq, rtqp, q);
d191 1
a191 1
		rtqp = CIRCLEQ_FIRST(&exp->tq);
d194 1
a194 1
	CIRCLEQ_INSERT_HEAD(&exp->tq, tqp, q);
d245 1
a245 1
	if ((tqp = CIRCLEQ_FIRST(&exp->tq)) == CIRCLEQ_END(&exp->tq)) {
d280 1
a280 1
	if ((tqp = CIRCLEQ_FIRST(&exp->tq)) == CIRCLEQ_END(&exp->tq)) {
d412 1
a412 1
	if (CIRCLEQ_FIRST(&exp->tq) == CIRCLEQ_END(&exp->tq)) {
d420 1
a420 1
		dtqp = CIRCLEQ_FIRST(&exp->tq);
d431 5
a435 4
		for (tqp = CIRCLEQ_FIRST(&exp->tq);
		    tqp != CIRCLEQ_END(&exp->tq) && --off > 1;
		    tqp = CIRCLEQ_NEXT(tqp, q));
		if (tqp == (void *)&exp->tq) {
d446 2
a447 3
		for (tqp = CIRCLEQ_FIRST(&exp->tq);
		    tqp != CIRCLEQ_END(&exp->tq);
		    dtqp = tqp, tqp = CIRCLEQ_NEXT(tqp, q)) {
d449 1
a449 1
			if (tqp == CIRCLEQ_FIRST(&exp->tq))
d459 1
a459 1
		if (tqp == (void *)&exp->tq) {
d464 1
a464 1
		if (tqp == CIRCLEQ_FIRST(&exp->tq))
d491 1
a491 1
	if (CIRCLEQ_FIRST(&exp->tq) == CIRCLEQ_END(&exp->tq)) {
d498 1
a498 1
	    CIRCLEQ_PREV(CIRCLEQ_LAST(&exp->tq), q),
d522 1
a522 1
	tp = CIRCLEQ_NEXT(dtqp, q)->current;
d541 1
a541 1
		tqp = CIRCLEQ_FIRST(&exp->tq);
d550 2
a551 2
	if (CIRCLEQ_NEXT(CIRCLEQ_FIRST(&exp->tq), q) == CIRCLEQ_END(&exp->tq))
		tagq_free(sp, CIRCLEQ_FIRST(&exp->tq));
d574 1
a574 1
	if ((tqp = CIRCLEQ_FIRST(&exp->tq)) == CIRCLEQ_END(&exp->tq)) {
d578 1
d603 5
a607 2
	for (cnt = 1, tqp = CIRCLEQ_FIRST(&exp->tq); !INTERRUPTED(sp) &&
	    tqp != CIRCLEQ_END(&exp->tq); ++cnt, tqp = CIRCLEQ_NEXT(tqp, q))
d635 1
d658 1
a658 1
	CIRCLEQ_FOREACH(aqp, &oexp->tq, q) {
d669 1
a669 1
		CIRCLEQ_INSERT_TAIL(&nexp->tq, tqp, q);
d798 1
d811 6
a816 2
	if (CIRCLEQ_NEXT(tqp, q) != NULL)
		CIRCLEQ_REMOVE(&exp->tq, tqp, q);
d909 2
a910 2
	while ((tqp = CIRCLEQ_FIRST(&exp->tq)) != CIRCLEQ_END(&exp->tq))
		tagq_free(sp, tqp);
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.13 2006/03/11 06:58:00 ray Exp $	*/
d698 2
a699 1
	if ((tfp->name = strdup(otfp->name)) == NULL)
d701 1
@


1.13
log
@Silence 39 warnings.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.12 2006/01/08 21:05:40 miod Exp $	*/
a15 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_tag.c	10.36 (Berkeley) 9/15/96";
#endif /* not lint */
@


1.12
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.11 2005/10/17 19:12:16 otto Exp $	*/
d409 1
a409 1
	TAGQ *tqp, *dtqp;
d473 1
d575 1
a575 1
	char *p, *sep;
@


1.11
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.10 2002/02/16 21:27:57 millert Exp $	*/
d172 1
a172 1
	    F_ISSET(frp, FR_TMPFILE) && !F_ISSET(cmdp, E_NEWSCREEN);
d942 1
a942 1
		    search, slen, NULL, SEARCH_FILE | SEARCH_TAG))
d952 1
d1248 1
a1248 1
#define	SKIP_PAST_NEWLINE(p, back)	while (p < back && *p++ != '\n');
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.9 2001/11/19 19:02:17 mpech Exp $	*/
d152 1
a152 1
	if (exp->tq.cqh_first == (void *)&exp->tq) {
d177 1
a177 1
		if (ex_tag_Nswitch(sp, tqp->tagq.cqh_first, force))
d184 1
a184 1
		if (ex_tag_nswitch(sp, tqp->tagq.cqh_first, force))
d192 1
a192 1
	if (exp->tq.cqh_first == (void *)&exp->tq) {
d195 1
a195 1
		rtqp = exp->tq.cqh_first;
d249 1
a249 1
	if ((tqp = exp->tq.cqh_first) == (void *)&exp->tq) {
d253 1
a253 1
	if ((tp = tqp->current->q.cqe_next) == (void *)&tqp->tagq) {
d284 1
a284 1
	if ((tqp = exp->tq.cqh_first) == (void *)&exp->tq) {
d288 1
a288 1
	if ((tp = tqp->current->q.cqe_prev) == (void *)&tqp->tagq) {
d416 1
a416 1
	if (exp->tq.cqh_first == (void *)&exp->tq) {
d424 1
a424 1
		dtqp = exp->tq.cqh_first;
d435 3
a437 3
		for (tqp = exp->tq.cqh_first;
		    tqp != (void *)&exp->tq && --off > 1;
		    tqp = tqp->q.cqe_next);
d449 3
a451 3
		for (tqp = exp->tq.cqh_first;
		    tqp != (void *)&exp->tq;
		    dtqp = tqp, tqp = tqp->q.cqe_next) {
d453 1
a453 1
			if (tqp == exp->tq.cqh_first)
d468 1
a468 1
		if (tqp == exp->tq.cqh_first)
d494 1
a494 1
	if (exp->tq.cqh_first == (void *)&exp->tq) {
d501 2
a502 1
	    exp->tq.cqh_last->q.cqe_prev, FL_ISSET(cmdp->iflags, E_C_FORCE)));
d525 1
a525 1
	tp = dtqp->q.cqe_next->current;
d544 1
a544 1
		tqp = exp->tq.cqh_first;
d553 2
a554 2
	if (exp->tq.cqh_first->q.cqe_next == (void *)&exp->tq)
		tagq_free(sp, exp->tq.cqh_first);
d577 1
a577 1
	if ((tqp = exp->tq.cqh_first) == (void *)&exp->tq) {
d605 4
a608 5
	for (cnt = 1, tqp = exp->tq.cqh_first; !INTERRUPTED(sp) &&
	    tqp != (void *)&exp->tq; ++cnt, tqp = tqp->q.cqe_next)
		for (tp = tqp->tagq.cqh_first;
		    tp != (void *)&tqp->tagq; tp = tp->q.cqe_next) {
			if (tp == tqp->tagq.cqh_first)
d623 1
a623 1
			if (tp == tqp->tagq.cqh_first && tqp->tag != NULL &&
d656 1
a656 2
	for (aqp = oexp->tq.cqh_first;
	    aqp != (void *)&oexp->tq; aqp = aqp->q.cqe_next) {
d659 1
a659 2
		for (ap = aqp->tagq.cqh_first;
		    ap != (void *)&aqp->tagq; ap = ap->q.cqe_next) {
d671 1
a671 2
	for (atfp = oexp->tagfq.tqh_first;
	    atfp != NULL; atfp = atfp->q.tqe_next) {
d797 1
a797 1
	while ((tp = tqp->tagq.cqh_first) != (void *)&tqp->tagq) {
d806 1
a806 1
	if (tqp->q.cqe_next != NULL)
d858 1
a858 1
	while ((tfp = exp->tagfq.tqh_first) != NULL)
d900 1
a900 1
	while ((tqp = exp->tq.cqh_first) != (void *)&exp->tq)
d902 1
a902 1
	while ((tfp = exp->tagfq.tqh_first) != NULL)
d999 2
a1000 2
	for (echk = 0,
	    tfp = exp->tagfq.tqh_first; tfp != NULL; tfp = tfp->q.tqe_next)
d1008 1
a1008 1
	if (tqp->tagq.cqh_first == (void *)&tqp->tagq) {
d1011 1
a1011 2
			for (tfp = exp->tagfq.tqh_first;
			    tfp != NULL; tfp = tfp->q.tqe_next)
d1022 1
a1022 1
	tqp->current = tqp->tagq.cqh_first;
@


1.9
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_tag.c,v 1.8 2001/01/29 01:58:44 niklas Exp $	*/
d47 12
a58 12
static char	*binary_search __P((char *, char *, char *));
static int	 compare __P((char *, char *, char *));
static void	 ctag_file __P((SCR *, TAGF *, char *, char **, size_t *));
static int	 ctag_search __P((SCR *, char *, size_t, char *));
static int	 ctag_sfile __P((SCR *, TAGF *, TAGQ *, char *));
static TAGQ	*ctag_slist __P((SCR *, char *));
static char	*linear_search __P((char *, char *, char *));
static int	 tag_copy __P((SCR *, TAG *, TAG **));
static int	 tag_pop __P((SCR *, TAGQ *, int));
static int	 tagf_copy __P((SCR *, TAGF *, TAGF **));
static int	 tagf_free __P((SCR *, TAGF *));
static int	 tagq_copy __P((SCR *, TAGQ *, TAGQ **));
d64 1
a64 1
 * PUBLIC: int ex_tag_first __P((SCR *, char *));
d100 1
a100 1
 * PUBLIC: int ex_tag_push __P((SCR *, EXCMD *));
d237 1
a237 1
 * PUBLIC: int ex_tag_next __P((SCR *, EXCMD *));
d272 1
a272 1
 * PUBLIC: int ex_tag_prev __P((SCR *, EXCMD *));
d307 1
a307 1
 * PUBLIC: int ex_tag_nswitch __P((SCR *, TAG *, int));
d344 1
a344 1
 * PUBLIC: int ex_tag_Nswitch __P((SCR *, TAG *, int));
d401 1
a401 1
 * PUBLIC: int ex_tag_pop __P((SCR *, EXCMD *));
d482 1
a482 1
 * PUBLIC: int ex_tag_top __P((SCR *, EXCMD *));
d562 1
a562 1
 * PUBLIC: int ex_tag_display __P((SCR *));
d641 1
a641 1
 * PUBLIC: int ex_tag_copy __P((SCR *, SCR *));
d789 1
a789 1
 * PUBLIC: int tagq_free __P((SCR *, TAGQ *));
d819 1
a819 1
 * PUBLIC: void tag_msg __P((SCR *, tagmsg_t, char *));
d847 1
a847 1
 * PUBLIC: int ex_tagf_alloc __P((SCR *, char *));
d891 1
a891 1
 * PUBLIC: int ex_tag_free __P((SCR *));
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1255 1
a1255 1
	register char *string, *front, *back;
d1257 1
a1257 1
	register char *p;
d1318 1
a1318 1
	register char *s1, *s2, *back;
@


1.7
log
@When checking mmap return, check for MAP_FAILED, not -1.
@
text
@d1 2
@


1.6
log
@Fix snprintf return value usage.
@
text
@d1071 1
a1071 1
	    MAP_FILE | MAP_PRIVATE, fd, (off_t)0)) == (caddr_t)-1) {
@


1.5
log
@fix relative tags in vi; Frank Mayhar <frank@@exit.com>
@
text
@a1183 1
	size_t len;
d1198 1
a1198 1
		len = snprintf(buf, sizeof(buf), "%s/%s", tfp->name, name);
@


1.4
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@a1199 1
		*p = '/';
d1204 1
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d16 1
a16 1
static const char sccsid[] = "@@(#)ex_tag.c	10.35 (Berkeley) 6/30/96";
d872 1
a872 1
				memmove(tfp->name, t, len);
@


1.2
log
@new vi
@
text
@d16 1
a16 1
static const char sccsid[] = "@@(#)ex_tag.c	10.32 (Berkeley) 5/16/96";
d48 1
a48 1
static int	 ctag_search __P((SCR *, char *, char *));
d198 2
a199 1
	(void)ctag_search(sp, tqp->current->search, tqp->tag);
d262 1
a262 1
		(void)ctag_search(sp, tp->search, tqp->tag);
d297 1
a297 1
		(void)ctag_search(sp, tp->search, tqp->tag);
d802 7
a808 1
	CIRCLEQ_REMOVE(&exp->tq, tqp, q);
d827 2
a828 1
		msgq_str(sp, M_ERR, tag, "164|%s: the tag line doesn't exist");
d915 1
a915 1
ctag_search(sp, search, tag)
d918 1
d943 1
a943 1
		    search, NULL, SEARCH_FILE | SEARCH_TAG))
d945 3
a947 4
				p[1] = '\0';
				if (f_search(sp, &m, &m,
				    search, NULL, SEARCH_FILE | SEARCH_TAG)) {
					p[1] = '(';
a948 2
				}
				p[1] = '(';
@


1.1
log
@Initial revision
@
text
@d4 2
d10 1
a10 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d13 2
d16 1
a16 1
static char sccsid[] = "@@(#)ex_tag.c	8.45 (Berkeley) 8/17/94";
d20 3
d24 2
a34 1
#include <signal.h>
a38 1
#include <termios.h>
d41 2
a42 6
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
d47 4
d52 5
a56 2
static int	 search __P((SCR *, char *, char *, char **));
static int	 tag_get __P((SCR *, char *, char **, char **, char **));
d59 4
a62 2
 * ex_tagfirst --
 *	The tag code can be entered from main, i.e. "vi -t tag".
d65 1
a65 1
ex_tagfirst(sp, tagarg)
d69 2
a70 10
	FREF *frp;
	MARK m;
	long tl;
	u_int flags;
	int sval;
	char *p, *tag, *name, *search;

	/* Taglength may limit the number of characters. */
	if ((tl = O_VAL(sp, O_TAGLENGTH)) != 0 && strlen(tagarg) > tl)
		tagarg[tl] = '\0';
d72 3
a74 9
	/* Get the tag information. */
	if (tag_get(sp, tagarg, &tag, &name, &search))
		return (1);

	/* Create the file entry. */
	if ((frp = file_add(sp, name)) == NULL)
		return (1);
	if (file_init(sp, frp, NULL, 0))
		return (1);
d77 4
a80 4
	 * !!!
	 * The historic tags file format (from a long, long time ago...)
	 * used a line number, not a search string.  I got complaints, so
	 * people are still using the format.
d82 6
a87 25
	if (isdigit(search[0])) {
		m.lno = atoi(search);
		m.cno = 0;
	} else {
		/*
		 * Search for the tag; cheap fallback for C functions if
		 * the name is the same but the arguments have changed.
		 */
		m.lno = 1;
		m.cno = 0;
		flags = SEARCH_FILE | SEARCH_TAG | SEARCH_TERM;
		sval = f_search(sp, sp->ep, &m, &m, search, NULL, &flags);
		if (sval && (p = strrchr(search, '(')) != NULL) {
			p[1] = '\0';
			sval = f_search(sp, sp->ep,
			    &m, &m, search, NULL, &flags);
		}
		if (sval)
			msgq(sp, M_ERR, "%s: search pattern not found", tag);
	}

	/* Set up the screen. */
	frp->lno = m.lno;
	frp->cno = m.cno;
	F_SET(frp, FR_CURSORSET);
a88 5
	/* Might as well make this the default tag. */
	if ((EXP(sp)->tlast = strdup(tagarg)) == NULL) {
		msgq(sp, M_SYSERR, NULL);
		return (1);
	}
a91 13
/* Free a tag or tagf structure from a queue. */
#define	FREETAG(tp) {							\
	TAILQ_REMOVE(&exp->tagq, (tp), q);				\
	if ((tp)->search != NULL)					\
		free((tp)->search);					\
	FREE((tp), sizeof(TAGF));					\
}
#define	FREETAGF(tfp) {							\
	TAILQ_REMOVE(&exp->tagfq, (tfp), q);				\
	free((tfp)->name);						\
	FREE((tfp), sizeof(TAGF));					\
}

d93 2
a94 2
 * ex_tagpush -- :tag [file]
 *	Move to a new tag.
d96 3
a98 8
 * The tags stacks in nvi are a bit tricky.  Each tag contains a file name,
 * search string, and line/column numbers.  The search string is only used
 * for the first access and for user display.  The first record on the stack
 * is the place where we first did a tag, so it has no search string.  The
 * second record is the first tag, and so on.  Note, this means that the
 * "current" tag is always on the stack.  Each tag has a line/column which is
 * the location from which the user tagged the following TAG entry, and which
 * is used as the return location.
d101 1
a101 1
ex_tagpush(sp, ep, cmdp)
d103 1
a103 2
	EXF *ep;
	EXCMDARG *cmdp;
a104 1
	enum {TC_CHANGE, TC_CURRENT} which;
d107 4
a110 4
	MARK m;
	TAG *tp;
	u_int flags;
	int sval;
d112 1
a112 1
	char *name, *p, *search, *tag;
d117 4
a120 3
		if (exp->tlast != NULL)
			FREE(exp->tlast, strlen(exp->tlast) + 1);
		if ((exp->tlast = strdup(cmdp->argv[0]->bp)) == NULL) {
d124 5
d131 2
a132 2
		if (exp->tlast == NULL) {
			msgq(sp, M_ERR, "No previous tag entered");
a139 4
	/* Taglength may limit the number of characters. */
	if ((tl = O_VAL(sp, O_TAGLENGTH)) != 0 && strlen(exp->tlast) > tl)
		exp->tlast[tl] = '\0';

d141 1
a141 1
	if (tag_get(sp, exp->tlast, &tag, &name, &search))
d144 39
a182 9
	/* Get the (possibly new) FREF structure. */
	if ((frp = file_add(sp, name)) == NULL)
		goto err;

	if (sp->frp == frp)
		which = TC_CURRENT;
	else {
		if (file_m1(sp, sp->ep,
		    F_ISSET(cmdp, E_FORCE), FS_ALL | FS_POSSIBLE))
a183 2
		which = TC_CHANGE;
	}
d186 22
a207 6
	 * Get a tag structure -- if this is the first tag, push it on the
	 * stack as a placeholder and get another tag structure.  Set the
	 * line/column of the most recent element on the stack to be the
	 * current values, including the file pointer.  Then push the new
	 * TAG onto the stack with the new file and search string for user
	 * display.
d209 8
a216 4
	CALLOC(sp, tp, TAG *, 1, sizeof(TAG));
	if (tp != NULL && exp->tagq.tqh_first == NULL) {
		TAILQ_INSERT_HEAD(&exp->tagq, tp, q);
		CALLOC(sp, tp, TAG *, 1, sizeof(TAG));
d218 31
a248 4
	if (exp->tagq.tqh_first != NULL) {
		exp->tagq.tqh_first->frp = sp->frp;
		exp->tagq.tqh_first->lno = sp->lno;
		exp->tagq.tqh_first->cno = sp->cno;
d250 3
a252 7
	if (tp != NULL) {
		if ((tp->search = strdup(search)) == NULL)
			msgq(sp, M_SYSERR, NULL);
		else
			tp->slen = strlen(search);
		tp->frp = frp;
		TAILQ_INSERT_HEAD(&exp->tagq, tp, q);
d254 3
d258 29
a286 8
	/* Switch files. */
	if (which == TC_CHANGE && file_init(sp, frp, NULL, 0)) {
		if (tp != NULL)
			FREETAG(tp);
		/* Handle special, first-tag case. */
		if (exp->tagq.tqh_first->q.tqe_next == NULL)
			TAILQ_REMOVE(&exp->tagq, exp->tagq.tqh_first, q);
err:		free(tag);
d289 3
d293 83
a375 42
	/*
	 * !!!
	 * Historic vi accepted a line number as well as a search
	 * string, and people are apparently still using the format.
	 */
	if (isdigit(search[0])) {
		m.lno = atoi(search);
		m.cno = 0;
		sval = 0;
	} else {
		/*
		 * Search for the tag; cheap fallback for C functions
		 * if the name is the same but the arguments have changed.
		 */
		m.lno = 1;
		m.cno = 0;
		flags = SEARCH_FILE | SEARCH_TAG | SEARCH_TERM;
		sval = f_search(sp, sp->ep, &m, &m, search, NULL, &flags);
		if (sval && (p = strrchr(search, '(')) != NULL) {
			p[1] = '\0';
			sval = f_search(sp, sp->ep,
			     &m, &m, search, NULL, &flags);
			p[1] = '(';
		}
		if (sval)
			msgq(sp, M_ERR, "%s: search pattern not found", tag);
	}
	free(tag);

	switch (which) {
	case TC_CHANGE:
		frp->lno = m.lno;
		frp->cno = m.cno;
		F_SET(frp, FR_CURSORSET);
		F_SET(sp, S_FSWITCH);
		break;
	case TC_CURRENT:
		if (sval)
			return (1);
		sp->lno = m.lno;
		sp->cno = m.cno;
		break;
d377 12
d393 6
a398 2
 * ex_tagpop -- :tagp[op][!] [number | file]
 *	Pop the tag stack.
d401 1
a401 1
ex_tagpop(sp, ep, cmdp)
d403 1
a403 2
	EXF *ep;
	EXCMDARG *cmdp;
d406 2
a407 1
	TAG *ntp, *tp;
a408 1
	size_t arglen;
d413 2
a414 2
	if (exp->tagq.tqh_first == NULL) {
		msgq(sp, M_INFO, "The tags stack is empty");
d418 1
d421 1
a421 1
		ntp = exp->tagq.tqh_first;
d426 38
a463 31
		if (*p == '\0') {
			if (off < 1)
				return (0);
			for (tp = exp->tagq.tqh_first;
			    tp != NULL && --off > 1; tp = tp->q.tqe_next);
			if (tp == NULL) {
				msgq(sp, M_ERR,
"Less than %s entries on the tags stack; use :display to see the tags stack",
				    arg);
				return (1);
			}
			ntp = tp;
		} else {
			arglen = strlen(arg);
			for (tp = exp->tagq.tqh_first;
			    tp != NULL; ntp = tp, tp = tp->q.tqe_next) {
				/* Use the user's original file name. */
				p = tp->frp->name;
				if ((t = strrchr(p, '/')) == NULL)
					t = p;
				else
					++t;
				if (!strncmp(arg, t, arglen))
					break;
			}
			if (tp == NULL) {
				msgq(sp, M_ERR,
"No file named %s on the tags stack; use :display to see the tags stack",
				    arg);
				return (1);
			}
d465 2
d472 2
a473 11
	/* Update the cursor from the saved TAG information. */
	tp = ntp->q.tqe_next;
	if (tp->frp == sp->frp) {
		sp->lno = tp->lno;
		sp->cno = tp->cno;
	} else {
		if (file_m1(sp, ep,
		    F_ISSET(cmdp, E_FORCE), FS_ALL | FS_POSSIBLE))
			return (1);
		if (file_init(sp, tp->frp, NULL, 0))
			return (1);
d475 12
a486 3
		tp->frp->lno = tp->lno;
		tp->frp->cno = tp->cno;
		F_SET(sp->frp, FR_CURSORSET);
d488 1
a488 2
		F_SET(sp, S_FSWITCH);
	}
d490 4
a493 6
	/* Pop entries off the queue up to ntp. */
	for (;;) {
		tp = exp->tagq.tqh_first;
		FREETAG(tp);
		if (tp == ntp)
			break;
d496 3
a498 4
	/* If returning to the first tag, the stack is now empty. */
	if (exp->tagq.tqh_first->q.tqe_next == NULL)
		TAILQ_REMOVE(&exp->tagq, exp->tagq.tqh_first, q);
	return (0);
d502 2
a503 2
 * ex_tagtop -- :tagt[op][!]
 *	Clear the tag stack.
d505 2
a506 2
int
ex_tagtop(sp, ep, cmdp)
d508 2
a509 2
	EXF *ep;
	EXCMDARG *cmdp;
d513 1
a514 1
	/* Find oldest saved information. */
a515 6
	for (tp = exp->tagq.tqh_first;
	    tp != NULL && tp->q.tqe_next != NULL; tp = tp->q.tqe_next);
	if (tp == NULL) {
		msgq(sp, M_INFO, "The tags stack is empty");
		return (1);
	}
d517 5
a521 1
	/* If not switching files, it's easy; else do the work. */
d526 1
a526 4
		if (file_m1(sp, sp->ep,
		    F_ISSET(cmdp, E_FORCE), FS_ALL | FS_POSSIBLE))
			return (1);
		if (file_init(sp, tp->frp, NULL, 0))
d531 3
d535 1
a535 2
		F_SET(sp->frp, FR_CURSORSET);
		F_SET(sp, S_FSWITCH);
d538 14
a551 3
	/* Empty out the queue. */
	while ((tp = exp->tagq.tqh_first) != NULL)
		FREETAG(tp);
d556 1
a556 1
 * ex_tagdisplay --
d558 2
d562 1
a562 1
ex_tagdisplay(sp, ep)
a563 1
	EXF *ep;
d567 1
a567 1
	size_t len, maxlen;
d569 2
a570 1
	char *name;
d573 21
a593 2
	if ((tp = exp->tagq.tqh_first) == NULL) {
		(void)ex_printf(EXCOOKIE, "No tags to display.\n");
d598 2
a599 2
	 * Figure out the formatting.  MNOC is the maximum
	 * number of file name columns before we split the line.
d601 6
a606 15
#define	MNOC	15
	for (maxlen = 0,
	    tp = exp->tagq.tqh_first; tp != NULL; tp = tp->q.tqe_next) {
		len = strlen(name = tp->frp->name);	/* The original name. */
		if (maxlen < len && len < MNOC)
			maxlen = len;
	}

	for (cnt = 1, tp = exp->tagq.tqh_first; tp != NULL;
	    ++cnt, tp = tp->q.tqe_next) {
		len = strlen(name = tp->frp->name);	/* The original name. */
		if (len > maxlen || len + tp->slen > sp->cols)
			if (tp == NULL || tp->search == NULL)
				(void)ex_printf(EXCOOKIE,
				    "%2d %s\n", cnt, name);
d608 192
a799 11
				(void)ex_printf(EXCOOKIE,
				     "%2d %s\n** %*.*s %s\n", cnt, name,
				     (int)maxlen, (int)maxlen, "", tp->search);
		else
			if (tp == NULL || tp->search == NULL)
				(void)ex_printf(EXCOOKIE, "%2d %*.*s\n",
				    cnt, (int)maxlen, (int)len, name);
			else
				(void)ex_printf(EXCOOKIE, "%2d %*.*s %s\n",
				    cnt, (int)maxlen, (int)len, name,
				    tp->search);
d801 2
d807 31
a837 2
 * ex_tagalloc --
 *	Create a new list of tag files.
d840 1
a840 1
ex_tagalloc(sp, str)
d845 1
a845 1
	TAGF *tp;
d851 2
a852 2
	while ((tp = exp->tagfq.tqh_first) != NULL)
		FREETAGF(tp);
d858 4
a861 4
				MALLOC_RET(sp, tp, TAGF *, sizeof(TAGF));
				MALLOC(sp, tp->name, char *, len + 1);
				if (tp->name == NULL) {
					FREE(tp, sizeof(TAGF));
d864 4
a867 4
				memmove(tp->name, t, len);
				tp->name[len] = '\0';
				tp->flags = 0;
				TAILQ_INSERT_TAIL(&exp->tagfq, tp, q);
d878 4
a881 2
 * ex_tagfree --
 *	Free the tags file list.
d884 1
a884 1
ex_tagfree(sp)
a887 1
	TAG *tp;
d889 1
d893 2
a894 2
	while ((tp = exp->tagq.tqh_first) != NULL)
		FREETAG(tp);
d896 3
a898 3
		FREETAGF(tfp);
	if (exp->tlast != NULL)
		free(exp->tlast);
d903 2
a904 2
 * ex_tagcopy --
 *	Copy a screen's tag structures.
d906 4
a909 3
int
ex_tagcopy(orig, sp)
	SCR *orig, *sp;
d911 2
a912 3
	EX_PRIVATE *oexp, *nexp;
	TAG *ap, *tp;
	TAGF *atfp, *tfp;
d914 40
a953 12
	/* Copy tag stack. */
	oexp = EXP(orig);
	nexp = EXP(sp);
	for (ap = oexp->tagq.tqh_first; ap != NULL; ap = ap->q.tqe_next) {
		MALLOC(sp, tp, TAG *, sizeof(TAG));
		if (tp == NULL)
			goto nomem;
		*tp = *ap;
		if (ap->search != NULL &&
		    (tp->search = strdup(ap->search)) == NULL)
			goto nomem;
		TAILQ_INSERT_TAIL(&nexp->tagq, tp, q);
d956 7
a962 18
	/* Copy list of tag files. */
	for (atfp = oexp->tagfq.tqh_first;
	    atfp != NULL; atfp = atfp->q.tqe_next) {
		MALLOC(sp, tfp, TAGF *, sizeof(TAGF));
		if (tfp == NULL)
			goto nomem;
		*tfp = *atfp;
		if ((tfp->name = strdup(atfp->name)) == NULL)
			goto nomem;
		TAILQ_INSERT_TAIL(&nexp->tagfq, tfp, q);
	}

	/* Copy the last tag. */
	if (oexp->tlast != NULL &&
	    (nexp->tlast = strdup(oexp->tlast)) == NULL) {
nomem:		msgq(sp, M_SYSERR, NULL);
		return (1);
	}
d967 2
a968 2
 * tag_get --
 *	Get a tag from the tags files.
d970 2
a971 2
static int
tag_get(sp, tag, tagp, filep, searchp)
d973 1
a973 1
	char *tag, **tagp, **filep, **searchp;
a974 1
	struct stat sb;
d977 12
a988 3
	size_t plen, slen, tlen;
	int dne;
	char *p, pbuf[MAXPATHLEN];
d994 12
a1005 22
	dne = 0;
	exp = EXP(sp);
	for (p = NULL, tfp = exp->tagfq.tqh_first;
	    tfp != NULL && p == NULL; tfp = tfp->q.tqe_next) {
		errno = 0;
		F_CLR(tfp, TAGF_DNE);
		if (search(sp, tfp->name, tag, &p))
			if (errno == ENOENT) {
				if (!F_ISSET(tfp, TAGF_DNE_WARN)) {
					dne = 1;
					F_SET(tfp, TAGF_DNE);
				}
			} else
				msgq(sp, M_SYSERR, tfp->name);
		else
			if (p != NULL)
				break;
	}

	if (p == NULL) {
		msgq(sp, M_ERR, "%s: tag not found", tag);
		if (dne)
d1008 5
a1012 4
				if (F_ISSET(tfp, TAGF_DNE)) {
					errno = ENOENT;
					msgq(sp, M_SYSERR, tfp->name);
					F_SET(tfp, TAGF_DNE_WARN);
d1014 2
a1015 1
		return (1);
d1018 2
a1019 19
	/*
	 * Set the return pointers; tagp points to the tag, and, incidentally
	 * the allocated string, filep points to the file name, and searchp
	 * points to the search string.  All three are nul-terminated.
	 */
	for (*tagp = p; *p && !isblank(*p); ++p);
	if (*p == '\0')
		goto malformed;
	for (*p++ = '\0'; isblank(*p); ++p);
	for (*filep = p; *p && !isblank(*p); ++p);
	if (*p == '\0')
		goto malformed;
	for (*p++ = '\0'; isblank(*p); ++p);
	*searchp = p;
	if (*p == '\0') {
malformed:	free(*tagp);
		msgq(sp, M_ERR, "%s: corrupted tag in %s", tag, tfp->name);
		return (1);
	}
d1021 2
a1022 32
	/*
	 * !!!
	 * If the tag file path is a relative path, see if it exists.  If it
	 * doesn't, look relative to the tags file path.  It's okay for a tag
	 * file to not exist, and, historically, vi simply displayed a "new"
	 * file.  However, if the path exists relative to the tag file, it's
	 * pretty clear what's happening, so we may as well do it right.
	 */
	if ((*filep)[0] != '/'
	    && stat(*filep, &sb) && (p = strrchr(tfp->name, '/')) != NULL) {
		*p = '\0';
		plen = snprintf(pbuf, sizeof(pbuf), "%s/%s", tfp->name, *filep);
		*p = '/';
		if (stat(pbuf, &sb) == 0) {
			slen = strlen(*searchp);
			tlen = strlen(*tagp);
			MALLOC(sp, p, char *, plen + slen + tlen + 5);
			if (p != NULL) {
				memmove(p, *tagp, tlen);
				free(*tagp);
				*tagp = p;
				*(p += tlen) = '\0';
				memmove(++p, pbuf, plen);
				*filep = p;
				*(p += plen) = '\0';
				memmove(++p, *searchp, slen);
				*searchp = p;
				*(p += slen) = '\0';
			}
		}
	}
	return (0);
a1024 4
#define	EQUAL		0
#define	GREATER		1
#define	LESS		(-1)

d1026 2
a1027 2
 * search --
 *	Search a file for a tag.
d1030 1
a1030 1
search(sp, name, tname, tag)
d1032 3
a1034 1
	char *name, *tname, **tag;
d1037 4
a1040 2
	int fd, len;
	char *endp, *back, *front, *map, *p;
d1042 2
a1043 1
	if ((fd = open(name, O_RDONLY, 0)) < 0)
d1045 1
d1049 8
d1061 1
a1061 2
	 * is flatly impossible.  Hope that malloc fails if the file is too
	 * large.
d1063 4
a1066 2
	if (fstat(fd, &sb) || (map = mmap(NULL, (size_t)sb.st_size,
	    PROT_READ, MAP_PRIVATE, fd, (off_t)0)) == (caddr_t)-1) {
d1070 1
a1072 1

d1075 64
d1140 2
a1141 4
	if (front == NULL || (endp = strchr(front, '\n')) == NULL) {
		*tag = NULL;
		goto done;
	}
d1143 13
a1155 5
	len = endp - front;
	MALLOC(sp, p, char *, len + 1);
	if (p == NULL) {
		*tag = NULL;
		goto done;
a1156 3
	memmove(p, front, len);
	p[len] = '\0';
	*tag = p;
d1158 1
d1167 36
d1240 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
