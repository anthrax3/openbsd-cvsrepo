head	1.14;
access;
symbols
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.22
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.18
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.04.18.01.45.35;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	Pd2TRHz7UBFr9JGt;

1.13
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.12;
commitid	01nAnartGL7onLD3;

1.12
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.11;
commitid	ruCZ2IKF0FB0ebCr;

1.11
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.10;
commitid	adBvXLg05bJxz6yx;

1.10
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.9;
commitid	06bi6U3x4gFFf2G1;

1.9
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.11.06.58.00;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.43;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.08.20.22.56.06;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.36;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.54;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@free(NULL) is ok so use it; from Michael W. Bombardieri
@
text
@/*	$OpenBSD: ex_read.c,v 1.13 2016/05/27 09:18:12 martijn Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../common/common.h"
#include "../vi/vi.h"

/*
 * ex_read --	:read [file]
 *		:read [!cmd]
 *	Read from a file or utility.
 *
 * !!!
 * Historical vi wouldn't undo a filter read, for no apparent reason.
 *
 * PUBLIC: int ex_read(SCR *, EXCMD *);
 */
int
ex_read(SCR *sp, EXCMD *cmdp)
{
	enum { R_ARG, R_EXPANDARG, R_FILTER } which;
	struct stat sb;
	CHAR_T *arg, *name;
	EX_PRIVATE *exp;
	FILE *fp;
	FREF *frp;
	GS *gp;
	MARK rm;
	recno_t nlines;
	size_t arglen;
	int argc, rval;
	char *p;

	gp = sp->gp;

	/*
	 * 0 args: read the current pathname.
	 * 1 args: check for "read !arg".
	 */
	switch (cmdp->argc) {
	case 0:
		which = R_ARG;
		arg = NULL;	/* unused */
		arglen = 0;	/* unused */
		break;
	case 1:
		arg = cmdp->argv[0]->bp;
		arglen = cmdp->argv[0]->len;
		if (*arg == '!') {
			++arg;
			--arglen;
			which = R_FILTER;

			/* Secure means no shell access. */
			if (O_ISSET(sp, O_SECURE)) {
				ex_emsg(sp, cmdp->cmd->name, EXM_SECURE_F);
				return (1);
			}
		} else
			which = R_EXPANDARG;
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	/* Load a temporary file if no file being edited. */
	if (sp->ep == NULL) {
		if ((frp = file_add(sp, NULL)) == NULL)
			return (1);
		if (file_init(sp, frp, NULL, 0))
			return (1);
	}

	switch (which) {
	case R_FILTER:
		/*
		 * File name and bang expand the user's argument.  If
		 * we don't get an additional argument, it's illegal.
		 */
		argc = cmdp->argc;
		if (argv_exp1(sp, cmdp, arg, arglen, 1))
			return (1);
		if (argc == cmdp->argc) {
			ex_emsg(sp, cmdp->cmd->usage, EXM_USAGE);
			return (1);
		}
		argc = cmdp->argc - 1;

		/* Set the last bang command. */
		exp = EXP(sp);
		free(exp->lastbcomm);
		if ((exp->lastbcomm =
		    strdup(cmdp->argv[argc]->bp)) == NULL) {
			msgq(sp, M_SYSERR, NULL);
			return (1);
		}

		/*
		 * Vi redisplayed the user's argument if it changed, ex
		 * always displayed a !, plus the user's argument if it
		 * changed.
		 */
		if (F_ISSET(sp, SC_VI)) {
			if (F_ISSET(cmdp, E_MODIFY))
				(void)vs_update(sp, "!", cmdp->argv[argc]->bp);
		} else {
			if (F_ISSET(cmdp, E_MODIFY))
				(void)ex_printf(sp,
				    "!%s\n", cmdp->argv[argc]->bp);
			else
				(void)ex_puts(sp, "!\n");
			(void)ex_fflush(sp);
		}

		/*
		 * Historically, filter reads as the first ex command didn't
		 * wait for the user. If SC_SCR_EXWROTE not already set, set
		 * the don't-wait flag.
		 */
		if (!F_ISSET(sp, SC_SCR_EXWROTE))
			F_SET(sp, SC_EX_WAIT_NO);

		/*
		 * Switch into ex canonical mode.  The reason to restore the
		 * original terminal modes for read filters is so that users
		 * can do things like ":r! cat /dev/tty".
		 *
		 * !!!
		 * We do not output an extra <newline>, so that we don't touch
		 * the screen on a normal read.
		 */
		if (F_ISSET(sp, SC_VI)) {
			if (gp->scr_screen(sp, SC_EX)) {
				ex_emsg(sp, cmdp->cmd->name, EXM_NOCANON_F);
				return (1);
			}
			/*
			 * !!!
			 * Historically, the read command doesn't switch to
			 * the alternate X11 xterm screen, if doing a filter
			 * read -- don't set SA_ALTERNATE.
			 */
			F_SET(sp, SC_SCR_EX | SC_SCR_EXWROTE);
		}

		if (ex_filter(sp, cmdp, &cmdp->addr1,
		    NULL, &rm, cmdp->argv[argc]->bp, FILTER_READ))
			return (1);

		/* The filter version of read set the autoprint flag. */
		F_SET(cmdp, E_AUTOPRINT);

		/*
		 * If in vi mode, move to the first nonblank.  Might have
		 * switched into ex mode, so saved the original SC_VI value.
		 */
		sp->lno = rm.lno;
		if (F_ISSET(sp, SC_VI)) {
			sp->cno = 0;
			(void)nonblank(sp, sp->lno, &sp->cno);
		}
		return (0);
	case R_ARG:
		name = sp->frp->name;
		break;
	case R_EXPANDARG:
		if (argv_exp2(sp, cmdp, arg, arglen))
			return (1);
		/*
		 *  0 args: impossible.
		 *  1 args: impossible (I hope).
		 *  2 args: read it.
		 * >2 args: object, too many args.
		 *
		 * The 1 args case depends on the argv_sexp() function refusing
		 * to return success without at least one non-blank character.
		 */
		switch (cmdp->argc) {
		case 0:
		case 1:
			abort();
			/* NOTREACHED */
		case 2:
			name = cmdp->argv[1]->bp;
			/*
			 * !!!
			 * Historically, the read and write commands renamed
			 * "unnamed" files, or, if the file had a name, set
			 * the alternate file name.
			 */
			if (F_ISSET(sp->frp, FR_TMPFILE) &&
			    !F_ISSET(sp->frp, FR_EXNAMED)) {
				if ((p = v_strdup(sp, cmdp->argv[1]->bp,
				    cmdp->argv[1]->len)) != NULL) {
					free(sp->frp->name);
					sp->frp->name = p;
				}
				/*
				 * The file has a real name, it's no longer a
				 * temporary, clear the temporary file flags.
				 */
				F_CLR(sp->frp, FR_TMPEXIT | FR_TMPFILE);
				F_SET(sp->frp, FR_NAMECHANGE | FR_EXNAMED);

				/* Notify the screen. */
				(void)sp->gp->scr_rename(sp, sp->frp->name, 1);
			} else
				set_alt_name(sp, name);
			break;
		default:
			ex_emsg(sp, cmdp->argv[0]->bp, EXM_FILECOUNT);
			return (1);
		
		}
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	/*
	 * !!!
	 * Historically, vi did not permit reads from non-regular files, nor
	 * did it distinguish between "read !" and "read!", so there was no
	 * way to "force" it.  We permit reading from named pipes too, since
	 * they didn't exist when the original implementation of vi was done
	 * and they seem a reasonable addition.
	 */
	if ((fp = fopen(name, "r")) == NULL || fstat(fileno(fp), &sb)) {
		msgq_str(sp, M_SYSERR, name, "%s");
		return (1);
	}
	if (!S_ISFIFO(sb.st_mode) && !S_ISREG(sb.st_mode)) {
		(void)fclose(fp);
		msgq(sp, M_ERR,
		    "Only regular files and named pipes may be read");
		return (1);
	}

	/* Try and get a lock. */
	if (file_lock(sp, NULL, NULL, fileno(fp), 0) == LOCK_UNAVAIL)
		msgq(sp, M_ERR, "%s: read lock was unavailable", name);

	rval = ex_readfp(sp, name, fp, &cmdp->addr1, &nlines, 0);

	/*
	 * In vi, set the cursor to the first line read in, if anything read
	 * in, otherwise, the address.  (Historic vi set it to the line after
	 * the address regardless, but since that line may not exist we don't
	 * bother.)
	 *
	 * In ex, set the cursor to the last line read in, if anything read in,
	 * otherwise, the address.
	 */
	if (F_ISSET(sp, SC_VI)) {
		sp->lno = cmdp->addr1.lno;
		if (nlines)
			++sp->lno;
	} else
		sp->lno = cmdp->addr1.lno + nlines;
	return (rval);
}

/*
 * ex_readfp --
 *	Read lines into the file.
 *
 * PUBLIC: int ex_readfp(SCR *, char *, FILE *, MARK *, recno_t *, int);
 */
int
ex_readfp(SCR *sp, char *name, FILE *fp, MARK *fm, recno_t *nlinesp,
    int silent)
{
	EX_PRIVATE *exp;
	GS *gp;
	recno_t lcnt, lno;
	size_t len;
	u_long ccnt;			/* XXX: can't print off_t portably. */
	int nf, rval;
	char *p;

	gp = sp->gp;
	exp = EXP(sp);

	/*
	 * Add in the lines from the output.  Insertion starts at the line
	 * following the address.
	 */
	ccnt = 0;
	lcnt = 0;
	p = "Reading...";
	for (lno = fm->lno; !ex_getline(sp, fp, &len); ++lno, ++lcnt) {
		if ((lcnt + 1) % INTERRUPT_CHECK == 0) {
			if (INTERRUPTED(sp))
				break;
			if (!silent) {
				gp->scr_busy(sp, p,
				    p == NULL ? BUSY_UPDATE : BUSY_ON);
				p = NULL;
			}
		}
		if (db_append(sp, 1, lno, exp->ibp, len))
			goto err;
		ccnt += len;
	}

	if (ferror(fp) || fclose(fp))
		goto err;

	/* Return the number of lines read in. */
	if (nlinesp != NULL)
		*nlinesp = lcnt;

	if (!silent) {
		p = msg_print(sp, name, &nf);
		msgq(sp, M_INFO,
		    "%s: %lu lines, %lu characters", p, lcnt, ccnt);
		if (nf)
			FREE_SPACE(sp, p, 0);
	}

	rval = 0;
	if (0) {
err:		msgq_str(sp, M_SYSERR, name, "%s");
		(void)fclose(fp);
		rval = 1;
	}

	if (!silent)
		gp->scr_busy(sp, NULL, BUSY_OFF);
	return (rval);
}
@


1.13
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_read.c,v 1.11 2016/01/06 22:28:52 millert Exp $	*/
d114 1
a114 2
		if (exp->lastbcomm != NULL)
			free(exp->lastbcomm);
@


1.12
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d45 1
a45 1
	char *arg, *name;
@


1.11
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_read.c,v 1.10 2014/11/12 04:28:41 bentley Exp $	*/
d45 1
a45 1
	CHAR_T *arg, *name;
@


1.10
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_read.c,v 1.9 2009/10/27 23:59:47 deraadt Exp $	*/
d260 1
a260 1
		    "145|Only regular files and named pipes may be read");
d266 1
a266 1
		msgq(sp, M_ERR, "146|%s: read lock was unavailable", name);
d315 1
a315 1
	p = "147|Reading...";
d341 1
a341 1
		    "148|%s: %lu lines, %lu characters", p, lcnt, ccnt);
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_read.c,v 1.8 2006/03/11 06:58:00 ray Exp $	*/
d41 1
a41 3
ex_read(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d295 2
a296 7
ex_readfp(sp, name, fp, fm, nlinesp, silent)
	SCR *sp;
	char *name;
	FILE *fp;
	MARK *fm;
	recno_t *nlinesp;
	int silent;
@


1.8
log
@Silence 39 warnings.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_read.c,v 1.7 2002/02/16 21:27:57 millert Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_read.c	10.38 (Berkeley) 8/12/96";
#endif /* not lint */
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_read.c,v 1.6 2001/01/29 01:58:43 niklas Exp $	*/
d71 2
d246 3
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
 * PUBLIC: int ex_read __P((SCR *, EXCMD *));
d293 1
a293 1
 * PUBLIC: int ex_readfp __P((SCR *, char *, FILE *, MARK *, recno_t *, int));
@


1.5
log
@nvi 1.74
@
text
@d1 2
@


1.4
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_read.c	10.37 (Berkeley) 7/12/96";
d270 7
a276 4
	 * Set the cursor to the first line read in, if anything read
	 * in, otherwise, the address.  (Historic vi set it to the
	 * line after the address regardless, but since that line may
	 * not exist we don't bother.)
d278 6
a283 4
	sp->lno = cmdp->addr1.lno;
	if (nlines)
		++sp->lno;

@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_read.c	10.36 (Berkeley) 6/28/96";
d232 1
a232 1
				(void)gp->scr_rename(sp);
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_read.c	10.31 (Berkeley) 5/8/96";
d147 1
a147 1
			F_SET(sp, SC_EX_DONTWAIT);
d159 1
a159 1
			if (sp->gp->scr_screen(sp, SC_EX)) {
d163 6
d246 5
a250 3
	 * Historically, vi did not permit reads from non-regular files,
	 * nor did it distinguish between "read !" and "read!", so there
	 * was no way to "force" it.
d256 1
a256 1
	if (!S_ISREG(sb.st_mode)) {
d258 2
a259 1
		msgq(sp, M_ERR, "145|Only regular files may be read");
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)ex_read.c	8.41 (Berkeley) 8/17/94";
a24 1
#include <signal.h>
a27 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d29 2
a30 2
#include "vi.h"
#include "excmd.h"
d35 1
a35 1
 * Read from a file or utility.
d39 2
d43 1
a43 1
ex_read(sp, ep, cmdp)
d45 1
a45 2
	EXF *ep;
	EXCMDARG *cmdp;
d47 1
d52 2
d56 2
a57 2
	size_t arglen, blen, len;
	int btear, farg, rval;
d60 2
d63 2
a64 4
	 *  0 args: we're done.
	 *  1 args: check for "read !arg".
	 *  2 args: check for "read ! arg".
	 * >2 args: object, too many args.
a65 1
	farg = 0;
d68 1
d76 9
a84 2
			farg = 1;
		}
a85 8
	case 2:
		if (cmdp->argv[0]->len == 1 && cmdp->argv[0]->bp[0] == '!')  {
			arg = cmdp->argv[1]->bp;
			arglen = cmdp->argv[1]->len;
			farg = 2;
			break;
		}
		/* FALLTHROUGH */
d87 2
a88 1
		goto badarg;
d91 5
a95 3
	if (farg != 0) {
		/* File name and bang expand the user's argument. */
		if (argv_exp1(sp, ep, cmdp, arg, arglen, 1))
d97 1
d99 14
a112 3
		/* If argc unchanged, there wasn't anything to expand. */
		if (cmdp->argc == farg)
			goto usage;
d118 2
a119 1
		if ((exp->lastbcomm = strdup(cmdp->argv[farg]->bp)) == NULL) {
d124 15
a138 9
		/* Redisplay the user's argument if it's changed. */
		if (F_ISSET(cmdp, E_MODIFY) && IN_VI_MODE(sp)) {
			len = cmdp->argv[farg]->len;
			GET_SPACE_RET(sp, p, blen, len + 2);
			p[0] = '!';
			memmove(p + 1,
			    cmdp->argv[farg]->bp, cmdp->argv[farg]->len + 1);
			(void)sp->s_busy(sp, p);
			FREE_SPACE(sp, p, blen);
d141 27
a167 2
		if (filtercmd(sp, ep, &cmdp->addr1,
		    NULL, &rm, cmdp->argv[farg]->bp, FILTER_READ))
d171 1
a171 1
		F_SET(EXP(sp), EX_AUTOPRINT);
d173 4
a176 1
		/* If in vi mode, move to the first nonblank. */
d178 1
a178 1
		if (IN_VI_MODE(sp)) {
d180 1
a180 1
			(void)nonblank(sp, ep, sp->lno, &sp->cno);
d183 1
a183 15
	}

	/* Shell and file name expand the user's argument. */
	if (argv_exp2(sp, ep, cmdp, arg, arglen, 0))
		return (1);

	/*
	 *  0 args: no arguments, read the current file, don't set the
	 *	    alternate file name.
	 *  1 args: read it, switching to it or settgin the alternate file
	 *	    name.
	 * >1 args: object, too many args.
	 */
	switch (cmdp->argc) {
	case 1:
d186 3
a188 2
	case 2:
		name = cmdp->argv[1]->bp;
d190 7
a196 3
		 * !!!
		 * Historically, if you had an "unnamed" file, the read command
		 * renamed the file.
d198 37
a234 10
		if (F_ISSET(sp->frp, FR_TMPFILE) &&
		    !F_ISSET(sp->frp, FR_READNAMED)) {
			if ((p = v_strdup(sp,
			    cmdp->argv[1]->bp, cmdp->argv[1]->len)) != NULL) {
				free(sp->frp->name);
				sp->frp->name = p;
			}
			F_SET(sp->frp, FR_NAMECHANGE | FR_READNAMED);
		} else
			set_alt_name(sp, name);
a235 5
	default:
badarg:		msgq(sp, M_ERR,
		    "%s expanded into too many file names", cmdp->argv[0]->bp);
usage:		msgq(sp, M_ERR, "Usage: %s", cmdp->cmd->usage);
		return (1);
d245 1
a245 1
		msgq(sp, M_SYSERR, "%s", name);
d250 1
a250 1
		msgq(sp, M_ERR, "Only regular files may be read");
d254 5
a258 5
	/* Turn on busy message. */
	btear = F_ISSET(sp, S_EXSILENT) ? 0 : !busy_on(sp, "Reading...");
	rval = ex_readfp(sp, ep, name, fp, &cmdp->addr1, &nlines, 1);
	if (btear)
		busy_off(sp);
d276 2
d280 1
a280 1
ex_readfp(sp, ep, name, fp, fm, nlinesp, success_msg)
a281 1
	EXF *ep;
d286 1
a286 1
	int success_msg;
d289 1
d293 2
a294 1
	int rval;
d296 1
a296 1
	rval = 0;
d305 1
d307 8
a314 8
		if (INTERRUPTED(sp)) {
			if (!success_msg)
				msgq(sp, M_INFO, "Interrupted");
			break;
		}
		if (file_aline(sp, ep, 1, lno, exp->ibp, len)) {
			rval = 1;
			break;
d316 2
d321 2
a322 12
	if (ferror(fp)) {
		msgq(sp, M_SYSERR, "%s", name);
		rval = 1;
	}

	if (fclose(fp)) {
		msgq(sp, M_SYSERR, "%s", name);
		return (1);
	}

	if (rval)
		return (1);
d328 14
a341 4
	if (success_msg)
		msgq(sp, M_INFO, "%s%s: %lu line%s, %lu characters",
		    INTERRUPTED(sp) ? "Interrupted read: " : "",
		    name, lcnt, lcnt == 1 ? "" : "s", ccnt);
d343 3
a345 1
	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
