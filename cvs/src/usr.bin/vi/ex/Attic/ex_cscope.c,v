head	1.27;
access;
symbols
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.27
date	2015.11.19.07.53.31;	author bentley;	state dead;
branches;
next	1.26;
commitid	aNUlDSFtbBwW1Tdz;

1.26
date	2015.04.24.21.48.31;	author brynet;	state Exp;
branches;
next	1.25;
commitid	snOxq6D74oYtevTu;

1.25
date	2015.04.21.01.41.42;	author jsg;	state Exp;
branches;
next	1.24;
commitid	TFSARARFq0Kq2Cki;

1.24
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2014.11.14.20.27.03;	author tedu;	state Exp;
branches;
next	1.22;
commitid	aIZ8ZvbLlUW9obxb;

1.22
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.21;
commitid	T0XpHzXjuQBl1V3E;

1.21
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.20;
commitid	06bi6U3x4gFFf2G1;

1.20
date	2013.12.01.19.26.37;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.12.01.16.47.59;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2013.08.22.04.43.40;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.29.13.07.13;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.20.03.56.13;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.09.20.01.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.17.19.42.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.09.07.04.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.42;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.09.17.17.19.03;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.17.58.34;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.15.52;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.35.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove cscope support in vi.

It makes no sense to keep support for a non-base tool in base, especially
for a feature that few if any people use.
@
text
@/*	$OpenBSD: ex_cscope.c,v 1.26 2015/04/24 21:48:31 brynet Exp $	*/

/*-
 * Copyright (c) 1994, 1996
 *	Rob Mayoff.  All rights reserved.
 * Copyright (c) 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <termios.h>
#include <unistd.h>

#include "../common/common.h"
#include "tag.h"

#define	CSCOPE_DBFILE		"cscope.out"
#define	CSCOPE_PATHS		"cscope.tpath"

/*
 * 0name	find all uses of name
 * 1name	find definition of name
 * 2name	find all function calls made from name
 * 3name	find callers of name
 * 4string	find text string (cscope 12.9)
 * 4name	find assignments to name (cscope 13.3)
 * 5pattern	change pattern -- NOT USED
 * 6pattern	find pattern
 * 7name	find files with name as substring
 * 8name	find files #including name
 */
#define	FINDHELP "\
find c|d|e|f|g|i|s|t buffer|pattern\n\
      c: find callers of name\n\
      d: find all function calls made from name\n\
      e: find pattern\n\
      f: find files with name as substring\n\
      g: find definition of name\n\
      i: find files #including name\n\
      s: find all uses of name\n\
      t: find assignments to name"

static int cscope_add(SCR *, EXCMD *, char *);
static int cscope_find(SCR *, EXCMD*, char *);
static int cscope_help(SCR *, EXCMD *, char *);
static int cscope_kill(SCR *, EXCMD *, char *);
static int cscope_reset(SCR *, EXCMD *, char *);

typedef struct _cc {
	char	 *name;
	int	(*function)(SCR *, EXCMD *, char *);
	char	 *help_msg;
	char	 *usage_msg;
} CC;

static CC const cscope_cmds[] = {
	{ "add",   cscope_add,
	  "Add a new cscope database", "add file | directory" },
	{ "find",  cscope_find,
	  "Query the databases for a pattern", FINDHELP },
	{ "help",  cscope_help,
	  "Show help for cscope commands", "help [command]" },
	{ "kill",  cscope_kill,
	  "Kill a cscope connection", "kill number" },
	{ "reset", cscope_reset,
	  "Discard all current cscope connections", "reset" },
	{ NULL }
};

static TAGQ	*create_cs_cmd(SCR *, char *, size_t *);
static int	 csc_help(SCR *, char *);
static void	 csc_file(SCR *, CSC *, char *, char **, size_t *, int *);
static int	 get_paths(SCR *, CSC *);
static CC const	*lookup_ccmd(char *);
static int	 parse(SCR *, CSC *, TAGQ *, int *);
static int	 read_prompt(SCR *, CSC *);
static int	 run_cscope(SCR *, CSC *, char *);
static int	 start_cscopes(SCR *, EXCMD *);
static int	 terminate(SCR *, CSC *, int);

/*
 * ex_cscope --
 *	Perform an ex cscope.
 *
 * PUBLIC: int ex_cscope(SCR *, EXCMD *);
 */
int
ex_cscope(SCR *sp, EXCMD *cmdp)
{
	CC const *ccp;
	EX_PRIVATE *exp;
	int i;
	char *cmd, *p;

	/* Initialize the default cscope directories. */
	exp = EXP(sp);
	if (!F_ISSET(exp, EXP_CSCINIT) && start_cscopes(sp, cmdp))
		return (1);
	F_SET(exp, EXP_CSCINIT);

	/* Skip leading whitespace. */
	for (p = cmdp->argv[0]->bp, i = cmdp->argv[0]->len; i > 0; --i, ++p)
		if (!isspace(*p))
			break;
	if (i == 0)
		goto usage;

	/* Skip the command to any arguments. */
	for (cmd = p; i > 0; --i, ++p)
		if (isspace(*p))
			break;
	if (*p != '\0') {
		*p++ = '\0';
		for (; isspace(*p); ++p);
	}

	if ((ccp = lookup_ccmd(cmd)) == NULL) {
usage:		msgq(sp, M_ERR, "309|Use \"cscope help\" for help");
		return (1);
	}

	/* Call the underlying function. */
	return (ccp->function(sp, cmdp, p));
}

/*
 * start_cscopes --
 *	Initialize the cscope package.
 */
static int
start_cscopes(SCR *sp, EXCMD *cmdp)
{
	size_t blen, len;
	char *bp, *cscopes, *p, *t;

	/*
	 * EXTENSION #1:
	 *
	 * If the CSCOPE_DIRS environment variable is set, we treat it as a
	 * list of cscope directories that we're using, similar to the tags
	 * edit option.
	 *
	 * XXX
	 * This should probably be an edit option, although that implies that
	 * we start/stop cscope processes periodically, instead of once when
	 * the editor starts.
	 */
	if ((cscopes = getenv("CSCOPE_DIRS")) == NULL)
		return (0);
	len = strlen(cscopes);
	GET_SPACE_RET(sp, bp, blen, len);
	memcpy(bp, cscopes, len + 1);

	for (cscopes = t = bp; (p = strsep(&t, "\t :")) != NULL;)
		if (*p != '\0')
			(void)cscope_add(sp, cmdp, p);

	FREE_SPACE(sp, bp, blen);
	return (0);
}

/*
 * cscope_add --
 *	The cscope add command.
 */
static int
cscope_add(SCR *sp, EXCMD *cmdp, char *dname)
{
	struct stat sb;
	EX_PRIVATE *exp;
	CSC *csc;
	size_t len;
	int cur_argc;
	char *dbname, path[PATH_MAX];

	exp = EXP(sp);

	/*
	 *  0 additional args: usage.
	 *  1 additional args: matched a file.
	 * >1 additional args: object, too many args.
	 */
	cur_argc = cmdp->argc;
	if (argv_exp2(sp, cmdp, dname, strlen(dname)))
		return (1);
	if (cmdp->argc == cur_argc) {
		(void)csc_help(sp, "add");
		return (1);
	}
	if (cmdp->argc == cur_argc + 1)
		dname = cmdp->argv[cur_argc]->bp;
	else {
		ex_emsg(sp, dname, EXM_FILECOUNT);
		return (1);
	}

	/*
	 * The user can specify a specific file (so they can have multiple
	 * Cscope databases in a single directory) or a directory.  If the
	 * file doesn't exist, we're done.  If it's a directory, append the
	 * standard database file name and try again.  Store the directory
	 * name regardless so that we can use it as a base for searches.
	 */
	if (stat(dname, &sb)) {
		msgq(sp, M_SYSERR, dname);
		return (1);
	}
	if (S_ISDIR(sb.st_mode)) {
		(void)snprintf(path, sizeof(path),
		    "%s/%s", dname, CSCOPE_DBFILE);
		if (stat(path, &sb)) {
			msgq(sp, M_SYSERR, path);
			return (1);
		}
		dbname = CSCOPE_DBFILE;
	} else if ((dbname = strrchr(dname, '/')) != NULL)
		*dbname++ = '\0';
	else {
		dbname = dname;
		dname = ".";
	}

	/* Allocate a cscope connection structure and initialize its fields. */
	len = strlen(dname);
	CALLOC_RET(sp, csc, CSC *, 1, sizeof(CSC) + len);
	csc->dname = csc->buf;
	csc->dlen = len;
	memcpy(csc->dname, dname, len);
	csc->mtim = sb.st_mtim;

	/* Get the search paths for the cscope. */
	if (get_paths(sp, csc))
		goto err;

	/* Start the cscope process. */
	if (run_cscope(sp, csc, dbname))
		goto err;

	/*
	 * Add the cscope connection to the screen's list.  From now on, 
	 * on error, we have to call terminate, which expects the csc to
	 * be on the chain.
	 */
	LIST_INSERT_HEAD(&exp->cscq, csc, q);

	/* Read the initial prompt from the cscope to make sure it's okay. */
	if (read_prompt(sp, csc))
		return (1);

	return (0);

err:	free(csc);
	return (1);
}

/*
 * get_paths --
 *	Get the directories to search for the files associated with this
 *	cscope database.
 */
static int
get_paths(SCR *sp, CSC *csc)
{
	struct stat sb;
	int fd, nentries;
	size_t len;
	char *p, **pathp, buf[PATH_MAX * 2];

	/*
	 * EXTENSION #2:
	 *
	 * If there's a cscope directory with a file named CSCOPE_PATHS, it
	 * contains a colon-separated list of paths in which to search for
	 * files returned by cscope.
	 *
	 * XXX
	 * These paths are absolute paths, and not relative to the cscope
	 * directory.  To fix this, rewrite the each path using the cscope
	 * directory as a prefix.
	 */
	(void)snprintf(buf, sizeof(buf), "%s/%s", csc->dname, CSCOPE_PATHS);
	if (stat(buf, &sb) == 0) {
		/* Read in the CSCOPE_PATHS file. */
		len = sb.st_size;
		MALLOC_RET(sp, csc->pbuf, char *, len + 1);
		if ((fd = open(buf, O_RDONLY, 0)) < 0 ||
		    read(fd, csc->pbuf, len) != len) {
			 msgq_str(sp, M_SYSERR, buf, "%s");
			 if (fd >= 0)
				(void)close(fd);
			 return (1);
		}
		(void)close(fd);
		csc->pbuf[len] = '\0';

		/* Count up the entries. */
		for (nentries = 0, p = csc->pbuf; *p != '\0'; ++p)
			if (p[0] == ':' && p[1] != '\0')
				++nentries;

		/* Build an array of pointers to the paths. */
		CALLOC_GOTO(sp,
		    csc->paths, char **, nentries + 1, sizeof(char **));
		for (pathp = csc->paths, p = strtok(csc->pbuf, ":");
		    p != NULL; p = strtok(NULL, ":"))
			*pathp++ = p;
		return (0);
	}

	/*
	 * If the CSCOPE_PATHS file doesn't exist, we look for files
	 * relative to the cscope directory.
	 */
	if ((csc->pbuf = strdup(csc->dname)) == NULL) {
		msgq(sp, M_SYSERR, NULL);
		return (1);
	}
	CALLOC_GOTO(sp, csc->paths, char **, 2, sizeof(char *));
	csc->paths[0] = csc->pbuf;
	return (0);

alloc_err:
	if (csc->pbuf != NULL) {
		free(csc->pbuf);
		csc->pbuf = NULL;
	}
	return (1);
}

/*
 * run_cscope --
 *	Fork off the cscope process.
 */
static int
run_cscope(SCR *sp, CSC *csc, char *dbname)
{
	int to_cs[2], from_cs[2];
	char cmd[PATH_MAX * 2];

	/*
	 * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from
	 * from_cs[0] and writes to to_cs[1].
	 */
	to_cs[0] = to_cs[1] = from_cs[0] = from_cs[1] = -1;
	if (pipe(to_cs) < 0 || pipe(from_cs) < 0) {
		msgq(sp, M_SYSERR, "pipe");
		goto err;
	}
	switch (csc->pid = vfork()) {
	case -1:
		msgq(sp, M_SYSERR, "vfork");
err:		if (to_cs[0] != -1)
			(void)close(to_cs[0]);
		if (to_cs[1] != -1)
			(void)close(to_cs[1]);
		if (from_cs[0] != -1)
			(void)close(from_cs[0]);
		if (from_cs[1] != -1)
			(void)close(from_cs[1]);
		return (1);
	case 0:				/* child: run cscope. */
		(void)dup2(to_cs[0], STDIN_FILENO);
		(void)dup2(from_cs[1], STDOUT_FILENO);
		(void)dup2(from_cs[1], STDERR_FILENO);

		/* Close unused file descriptors. */
		(void)close(to_cs[1]);
		(void)close(from_cs[0]);

		/* Run the cscope command. */
#define	CSCOPE_CMD_FMT		"cd '%s' && exec cscope -dl -f %s"
		(void)snprintf(cmd, sizeof(cmd),
		    CSCOPE_CMD_FMT, csc->dname, dbname);
		(void)execl(_PATH_BSHELL, "sh", "-c", cmd, (char *)NULL);
		msgq_str(sp, M_SYSERR, cmd, "execl: %s");
		_exit (127);
		/* NOTREACHED */
	default:			/* parent. */
		/* Close unused file descriptors. */
		(void)close(to_cs[0]);
		(void)close(from_cs[1]);

		/*
		 * Save the file descriptors for later duplication, and
		 * reopen as streams.
		 */
		csc->to_fd = to_cs[1];
		csc->to_fp = fdopen(to_cs[1], "w");
		csc->from_fd = from_cs[0];
		csc->from_fp = fdopen(from_cs[0], "r");
		break;
	}
	return (0);
}

/*
 * cscope_find --
 *	The cscope find command.
 */
static int
cscope_find(SCR *sp, EXCMD *cmdp, char *pattern)
{
	CSC *csc, *csc_next;
	EX_PRIVATE *exp;
	FREF *frp;
	TAGQ *rtqp, *tqp;
	TAG *rtp;
	recno_t lno;
	size_t cno, search;
	int force, istmp, matches;

	exp = EXP(sp);

	/* Check for connections. */
	if (LIST_FIRST(&exp->cscq) == NULL) {
		msgq(sp, M_ERR, "310|No cscope connections running");
		return (1);
	}

	/*
	 * Allocate all necessary memory before doing anything hard.  If the
	 * tags stack is empty, we'll need the `local context' TAGQ structure
	 * later.
	 */
	rtp = NULL;
	rtqp = NULL;
	if (TAILQ_EMPTY(&exp->tq)) {
		/* Initialize the `local context' tag queue structure. */
		CALLOC_GOTO(sp, rtqp, TAGQ *, 1, sizeof(TAGQ));
		TAILQ_INIT(&rtqp->tagq);

		/* Initialize and link in its tag structure. */
		CALLOC_GOTO(sp, rtp, TAG *, 1, sizeof(TAG));
		TAILQ_INSERT_HEAD(&rtqp->tagq, rtp, q);
		rtqp->current = rtp; 
	}

	/* Create the cscope command. */
	if ((tqp = create_cs_cmd(sp, pattern, &search)) == NULL)
		goto err;

	/*
	 * Stick the current context in a convenient place, we'll lose it
	 * when we switch files.
	 */
	frp = sp->frp;
	lno = sp->lno;
	cno = sp->cno;
	istmp = F_ISSET(sp->frp, FR_TMPFILE) && !F_ISSET(cmdp, E_NEWSCREEN);

	/* Search all open connections for a match. */
	matches = 0;
	for (csc = LIST_FIRST(&exp->cscq); csc != NULL; csc = csc_next) {
		/* Copy csc->q.lh_next here in case csc is killed. */
		csc_next = LIST_NEXT(csc, q);

		/*
		 * Send the command to the cscope program.  (We skip the
		 * first two bytes of the command, because we stored the
		 * search cscope command character and a leading space
		 * there.)
		 */
		(void)fprintf(csc->to_fp, "%lu%s\n", (unsigned long)search,
		    tqp->tag + 2);
		(void)fflush(csc->to_fp);

		/* Read the output. */
		if (parse(sp, csc, tqp, &matches)) {
			if (rtqp != NULL)
				free(rtqp);
			tagq_free(sp, tqp);
			return (1);
		}
	}

	if (matches == 0) {
		msgq(sp, M_INFO, "278|No matches for query");
		return (0);
	}

	tqp->current = TAILQ_FIRST(&tqp->tagq);

	/* Try to switch to the first tag. */
	force = FL_ISSET(cmdp->iflags, E_C_FORCE);
	if (F_ISSET(cmdp, E_NEWSCREEN)) {
		if (ex_tag_Nswitch(sp, tqp->current, force))
			goto err;

		/* Everything else gets done in the new screen. */
		sp = sp->nextdisp;
		exp = EXP(sp);
	} else
		if (ex_tag_nswitch(sp, tqp->current, force))
			goto err;

	/*
	 * If this is the first tag, put a `current location' queue entry
	 * in place, so we can pop all the way back to the current mark.
	 * Note, it doesn't point to much of anything, it's a placeholder.
	 */
	if (TAILQ_EMPTY(&exp->tq)) {
		TAILQ_INSERT_HEAD(&exp->tq, rtqp, q);
	} else
		rtqp = TAILQ_FIRST(&exp->tq);

	/* Link the current TAGQ structure into place. */
	TAILQ_INSERT_HEAD(&exp->tq, tqp, q);

	(void)cscope_search(sp, tqp, tqp->current);

	/*
	 * Move the current context from the temporary save area into the
	 * right structure.
	 *
	 * If we were in a temporary file, we don't have a context to which
	 * we can return, so just make it be the same as what we're moving
	 * to.  It will be a little odd that ^T doesn't change anything, but
	 * I don't think it's a big deal.
	 */
	if (istmp) {
		rtqp->current->frp = sp->frp;
		rtqp->current->lno = sp->lno;
		rtqp->current->cno = sp->cno;
	} else {
		rtqp->current->frp = frp;
		rtqp->current->lno = lno;
		rtqp->current->cno = cno;
	}

	return (0);

err:
alloc_err:
	if (rtqp != NULL)
		free(rtqp);
	if (rtp != NULL)
		free(rtp);
	return (1);
}

/*
 * create_cs_cmd --
 *	Build a cscope command, creating and initializing the base TAGQ.
 */
static TAGQ *
create_cs_cmd(SCR *sp, char *pattern, size_t *searchp)
{
	CB *cbp;
	TAGQ *tqp;
	size_t tlen;
	char *p;

	/*
	 * Cscope supports a "change pattern" command which we never use,
	 * cscope command 5.  Set CSCOPE_QUERIES[5] to " " since the user
	 * can't pass " " as the first character of pattern.  That way the
	 * user can't ask for pattern 5 so we don't need any special-case
	 * code.
	 */
#define	CSCOPE_QUERIES		"sgdct efi"

	if (pattern == NULL)
		goto usage;

	/* Skip leading blanks, check for command character. */
	for (; isblank(pattern[0]); ++pattern);
	if (pattern[0] == '\0' || !isblank(pattern[1]))
		goto usage;
	for (*searchp = 0, p = CSCOPE_QUERIES;
	    *p != '\0' && *p != pattern[0]; ++*searchp, ++p);
	if (*p == '\0') {
		msgq(sp, M_ERR,
		    "311|%s: unknown search type: use one of %s",
		    KEY_NAME(sp, pattern[0]), CSCOPE_QUERIES);
		return (NULL);
	}

	/* Skip <blank> characters to the pattern. */
	for (p = pattern + 1; isblank(*p); ++p);
	if (*p == '\0') {
usage:		(void)csc_help(sp, "find");
		return (NULL);
	}

	/* The user can specify the contents of a buffer as the pattern. */
	cbp = NULL;
	if (p[0] == '"' && p[1] != '\0' && p[2] == '\0')
		CBNAME(sp, cbp, p[1]);
	if (cbp != NULL) {
		p = TAILQ_FIRST(&cbp->textq)->lb;
		tlen = TAILQ_FIRST(&cbp->textq)->len;
	} else
		tlen = strlen(p);

	/* Allocate and initialize the TAGQ structure. */
	CALLOC(sp, tqp, TAGQ *, 1, sizeof(TAGQ) + tlen + 3);
	if (tqp == NULL)
		return (NULL);
	TAILQ_INIT(&tqp->tagq);
	tqp->tag = tqp->buf;
	tqp->tag[0] = pattern[0];
	tqp->tag[1] = ' ';
	tqp->tlen = tlen + 2;
	memcpy(tqp->tag + 2, p, tlen);
	tqp->tag[tlen + 2] = '\0';
	F_SET(tqp, TAG_CSCOPE);

	return (tqp);
}

/*
 * parse --
 *	Parse the cscope output.
 */
static int
parse(SCR *sp, CSC *csc, TAGQ *tqp, int *matchesp)
{
	TAG *tp;
	recno_t slno;
	size_t dlen, nlen, slen;
	int ch, i, isolder, nlines;
	char *dname, *name, *search, *p, *t, dummy[2], buf[2048];

	for (;;) {
		if (!fgets(buf, sizeof(buf), csc->from_fp))
			goto io_err;

		/*
		 * If the database is out of date, or there's some other
		 * problem, cscope will output error messages before the
		 * number-of-lines output.  Display/discard any output
		 * that doesn't match what we want.
		 */
#define	CSCOPE_NLINES_FMT	"cscope: %d lines%1[\n]"
		if (sscanf(buf, CSCOPE_NLINES_FMT, &nlines, dummy) == 2)
			break;
		buf[strcspn(buf, "\n")] = '\0';
		msgq(sp, M_ERR, "%s: \"%s\"", csc->dname, buf);
	}

	while (nlines--) {
		if (fgets(buf, sizeof(buf), csc->from_fp) == NULL)
			goto io_err;

		/* If the line's too long for the buffer, discard it. */
		if ((p = strchr(buf, '\n')) == NULL) {
			while ((ch = getc(csc->from_fp)) != EOF && ch != '\n');
			continue;
		}
		*p = '\0';

		/*
		 * The cscope output is in the following format:
		 *
		 *	<filename> <context> <line number> <pattern>
		 *
		 * Figure out how long everything is so we can allocate in one
		 * swell foop, but discard anything that looks wrong.
		 */
		for (p = buf, i = 0;
		    i < 3 && (t = strsep(&p, "\t ")) != NULL; ++i)
			switch (i) {
			case 0:			/* Filename. */
				name = t;
				nlen = strlen(name);
				break;
			case 1:			/* Context. */
				break;
			case 2:			/* Line number. */
				slno = (recno_t)atol(t);
				break;
			}
		if (i != 3 || p == NULL || t == NULL)
			continue;

		/* The rest of the string is the search pattern. */
		search = p;
		slen = strlen(p);

		/* Resolve the file name. */
		csc_file(sp, csc, name, &dname, &dlen, &isolder);

		/*
		 * If the file is older than the cscope database, that is,
		 * the database was built since the file was last modified,
		 * or there wasn't a search string, use the line number.
		 */
		if (isolder || strcmp(search, "<unknown>") == 0) {
			search = NULL;
			slen = 0;
		}

		/*
		 * Allocate and initialize a tag structure plus the variable
		 * length cscope information that follows it.
		 */
		CALLOC_RET(sp, tp,
		    TAG *, 1, sizeof(TAG) + dlen + 2 + nlen + 1 + slen + 1);
		tp->fname = tp->buf;
		if (dlen != 0) {
			memcpy(tp->fname, dname, dlen);
			tp->fname[dlen] = '/';
			++dlen;
		}
		memcpy(tp->fname + dlen, name, nlen + 1);
		tp->fnlen = dlen + nlen;
		tp->slno = slno;
		if (slen != 0) {
			tp->search = tp->fname + tp->fnlen + 1;
			memcpy(tp->search, search, (tp->slen = slen) + 1);
		}
		TAILQ_INSERT_TAIL(&tqp->tagq, tp, q);

		++*matchesp;
	}

	(void)read_prompt(sp, csc);
	return (0);

io_err:	if (feof(csc->from_fp))
		errno = EIO;
	msgq_str(sp, M_SYSERR, "%s", csc->dname);
	terminate(sp, csc, 0);
	return (1);
}

/*
 * csc_file --
 *	Search for the right path to this file.
 */
static void
csc_file(SCR *sp, CSC *csc, char *name, char **dirp, size_t *dlenp,
    int *isolderp)
{
	struct stat sb;
	char **pp, buf[PATH_MAX];

	/*
	 * Check for the file in all of the listed paths.  If we don't
	 * find it, we simply return it unchanged.  We have to do this
	 * now, even though it's expensive, because if the user changes
	 * directories, we can't change our minds as to where the file
	 * lives.
	 */
	for (pp = csc->paths; *pp != NULL; ++pp) {
		(void)snprintf(buf, sizeof(buf), "%s/%s", *pp, name);
		if (stat(buf, &sb) == 0) {
			*dirp = *pp;
			*dlenp = strlen(*pp);
			*isolderp = timespeccmp(
			    &sb.st_mtim, &csc->mtim, <);
			return;
		}
	}
	*dlenp = 0;
}

/*
 * cscope_help --
 *	The cscope help command.
 */
static int
cscope_help(SCR *sp, EXCMD *cmdp, char *subcmd)
{
	return (csc_help(sp, subcmd));
}

/*
 * csc_help --
 *	Display help/usage messages.
 */
static int
csc_help(SCR *sp, char *cmd)
{
	CC const *ccp;

	if (cmd != NULL && *cmd != '\0') {
		if ((ccp = lookup_ccmd(cmd)) == NULL) {
			ex_printf(sp,
			    "%s doesn't match any cscope command\n", cmd);
			return (1);
		} else {
			ex_printf(sp,
		          "Command: %s (%s)\n", ccp->name, ccp->help_msg);
			ex_printf(sp, "  Usage: %s\n", ccp->usage_msg);
			return (0);
		}
	}

	ex_printf(sp, "cscope commands:\n");
	for (ccp = cscope_cmds; ccp->name != NULL; ++ccp)
		ex_printf(sp, "  %*s: %s\n", 5, ccp->name, ccp->help_msg);
	return (0);
}

/*
 * cscope_kill --
 *	The cscope kill command.
 */
static int
cscope_kill(SCR *sp, EXCMD *cmdp, char *cn)
{
	return (terminate(sp, NULL, atoi(cn)));
}

/*
 * terminate --
 *	Detach from a cscope process.
 */
static int
terminate(SCR *sp, CSC *csc, int n)
{
	EX_PRIVATE *exp;
	int i, pstat;

	exp = EXP(sp);

	/*
	 * We either get a csc structure or a number.  If not provided a
	 * csc structure, find the right one.
	 */
	if (csc == NULL) {
		if (n < 1)
			goto badno;
		for (i = 1, csc = LIST_FIRST(&exp->cscq);
		    csc != NULL; csc = LIST_NEXT(csc, q), i++)
			if (i == n)
				break;
		if (csc == NULL) {
badno:			msgq(sp, M_ERR, "312|%d: no such cscope session", n);
			return (1);
		}
	}

	/*
	 * XXX
	 * Theoretically, we have the only file descriptors to the process,
	 * so closing them should let it exit gracefully, deleting temporary
	 * files, etc.  The original vi cscope integration sent the cscope
	 * connection a SIGTERM signal, so I'm not sure if closing the file
	 * descriptors is sufficient.
	 */
	if (csc->from_fp != NULL)
		(void)fclose(csc->from_fp);
	if (csc->to_fp != NULL)
		(void)fclose(csc->to_fp);
	(void)waitpid(csc->pid, &pstat, 0);

	/* Discard cscope connection information. */
	LIST_REMOVE(csc, q);
	if (csc->pbuf != NULL)
		free(csc->pbuf);
	if (csc->paths != NULL)
		free(csc->paths);
	free(csc);
	return (0);
}

/*
 * cscope_reset --
 *	The cscope reset command.
 */
static int
cscope_reset(SCR *sp, EXCMD *cmdp, char *notusedp)
{
	EX_PRIVATE *exp;

	for (exp = EXP(sp); LIST_FIRST(&exp->cscq) != NULL;)
		if (cscope_kill(sp, cmdp, "1"))
			return (1);
	return (0);
}

/*
 * cscope_display --
 *	Display current connections.
 *
 * PUBLIC: int cscope_display(SCR *);
 */
int
cscope_display(SCR *sp)
{
	EX_PRIVATE *exp;
	CSC *csc;
	int i;

	exp = EXP(sp);
	if (LIST_FIRST(&exp->cscq) == NULL) {
		ex_printf(sp, "No cscope connections.\n");
		return (0);
	}
	for (i = 1,
	    csc = LIST_FIRST(&exp->cscq); csc != NULL; ++i, csc = LIST_NEXT(csc, q))
		ex_printf(sp,
		    "%2d %s (process %ld)\n", i, csc->dname, (long)csc->pid);
	return (0);
}

/*
 * cscope_search --
 *	Search a file for a cscope entry.
 *
 * PUBLIC: int cscope_search(SCR *, TAGQ *, TAG *);
 */
int
cscope_search(SCR *sp, TAGQ *tqp, TAG *tp)
{
	MARK m;

	/* If we don't have a search pattern, use the line number. */
	if (tp->search == NULL) {
		if (!db_exist(sp, tp->slno)) {
			tag_msg(sp, TAG_BADLNO, tqp->tag);
			return (1);
		}
		m.lno = tp->slno;
	} else {
		/*
		 * Search for the tag; cheap fallback for C functions
		 * if the name is the same but the arguments have changed.
		 */
		m.lno = 1;
		m.cno = 0;
		if (f_search(sp, &m, &m,
		    tp->search, tp->slen, NULL, SEARCH_CSCOPE | SEARCH_FILE)) {
			tag_msg(sp, TAG_SEARCH, tqp->tag);
			return (1);
		}

		/*
		 * !!!
		 * Historically, tags set the search direction if it wasn't
		 * already set.
		 */
		if (sp->searchdir == NOTSET)
			sp->searchdir = FORWARD;
	}

	/*
	 * !!!
	 * Tags move to the first non-blank, NOT the search pattern start.
	 */
	sp->lno = m.lno;
	sp->cno = 0;
	(void)nonblank(sp, sp->lno, &sp->cno);
	return (0);
}


/*
 * lookup_ccmd --
 *	Return a pointer to the command structure.
 */
static CC const *
lookup_ccmd(char *name)
{
	CC const *ccp;
	size_t len;

	len = strlen(name);
	for (ccp = cscope_cmds; ccp->name != NULL; ++ccp)
		if (strncmp(name, ccp->name, len) == 0)
			return (ccp);
	return (NULL);
}

/*
 * read_prompt --
 *	Read a prompt from cscope.
 */
static int
read_prompt(SCR *sp, CSC *csc)
{
	int ch;

#define	CSCOPE_PROMPT		">> "
	for (;;) {
		while ((ch =
		    getc(csc->from_fp)) != EOF && ch != CSCOPE_PROMPT[0]);
		if (ch == EOF) {
			terminate(sp, csc, 0);
			return (1);
		}
		if (getc(csc->from_fp) != CSCOPE_PROMPT[1])
			continue;
		if (getc(csc->from_fp) != CSCOPE_PROMPT[2])
			continue;
		break;
	}
	return (0);
}
@


1.26
log
@struct timespec/clock_gettime(3) conversion for vi(1).

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.25 2015/04/21 01:41:42 jsg Exp $	*/
@


1.25
log
@init both fds passed to pipe as -1 instead of initing one twice
ok deraadt@@ guenther@@ miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.24 2015/01/16 06:40:14 deraadt Exp $	*/
d29 1
d248 1
a248 1
	csc->mtime = sb.st_mtime;
d769 2
a770 1
			*isolderp = sb.st_mtime < csc->mtime;
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.23 2014/11/14 20:27:03 tedu Exp $	*/
d362 1
a362 1
	to_cs[0] = to_cs[1] = from_cs[0] = from_cs[0] = -1;
@


1.23
log
@from natano:
_PATH_BSHELL, _PATH_SENDMAIL, _PATH_TMP and _PATH_TTY are defined in
<paths.h> and _PATH_SYSV_TTY is unused. All of them can be removed from
pathnames.h. The other defines can be made unconditionally.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.22 2014/11/12 16:29:04 millert Exp $	*/
a13 1
#include <sys/param.h>
d192 1
a192 1
	char *dbname, path[MAXPATHLEN];
d285 1
a285 1
	char *p, **pathp, buf[MAXPATHLEN * 2];
d356 1
a356 1
	char cmd[MAXPATHLEN * 2];
d754 1
a754 1
	char **pp, buf[MAXPATHLEN];
@


1.22
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.21 2014/11/12 04:28:41 bentley Exp $	*/
d25 1
a33 1
#include "pathnames.h"
@


1.21
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.20 2013/12/01 19:26:37 krw Exp $	*/
a14 1
#include <sys/types.h>		/* XXX: param.h may not have included types.h */
@


1.20
log
@Change the tags queue from CIRCLEQ to TAILQ.

ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.19 2013/12/01 16:47:59 krw Exp $	*/
d108 1
a108 3
ex_cscope(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d151 1
a151 3
start_cscopes(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d187 1
a187 4
cscope_add(sp, cmdp, dname)
	SCR *sp;
	EXCMD *cmdp;
	char *dname;
d282 1
a282 3
get_paths(sp, csc)
	SCR *sp;
	CSC *csc;
d355 1
a355 4
run_cscope(sp, csc, dbname)
	SCR *sp;
	CSC *csc;
	char *dbname;
d421 1
a421 4
cscope_find(sp, cmdp, pattern)
	SCR *sp;
	EXCMD *cmdp;
	char *pattern;
d566 1
a566 4
create_cs_cmd(sp, pattern, searchp)
	SCR *sp;
	char *pattern;
	size_t *searchp;
d636 1
a636 5
parse(sp, csc, tqp, matchesp)
	SCR *sp;
	CSC *csc;
	TAGQ *tqp;
	int *matchesp;
d752 2
a753 6
csc_file(sp, csc, name, dirp, dlenp, isolderp)
	SCR *sp;
	CSC *csc;
	char *name, **dirp;
	size_t *dlenp;
	int *isolderp;
d782 1
a782 4
cscope_help(sp, cmdp, subcmd)
	SCR *sp;
	EXCMD *cmdp;
	char *subcmd;
d792 1
a792 3
csc_help(sp, cmd)
	SCR *sp;
	char *cmd;
d820 1
a820 4
cscope_kill(sp, cmdp, cn)
	SCR *sp;
	EXCMD *cmdp;
	char *cn;
d830 1
a830 4
terminate(sp, csc, n)
	SCR *sp;
	CSC *csc;
	int n;
d883 1
a883 4
cscope_reset(sp, cmdp, notusedp)
	SCR *sp;
	EXCMD *cmdp;
	char *notusedp;
d900 1
a900 2
cscope_display(sp)
	SCR *sp;
d925 1
a925 4
cscope_search(sp, tqp, tp)
	SCR *sp;
	TAGQ *tqp;
	TAG *tp;
d974 1
a974 2
lookup_ccmd(name)
	char *name;
d991 1
a991 3
read_prompt(sp, csc)
	SCR *sp;
	CSC *csc;
@


1.19
log
@Change the tag queue from CIRCLEQ to TAILQ.

Fixes & ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.18 2013/11/25 23:27:11 krw Exp $	*/
d465 1
a465 1
		CIRCLEQ_INIT(&rtqp->tagq);
d469 1
a469 1
		CIRCLEQ_INSERT_HEAD(&rtqp->tagq, rtp, q);
d516 1
a516 1
	tqp->current = CIRCLEQ_FIRST(&tqp->tagq);
d637 1
a637 1
	CIRCLEQ_INIT(&tqp->tagq);
d754 1
a754 1
		CIRCLEQ_INSERT_TAIL(&tqp->tagq, tp, q);
@


1.18
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.17 2013/08/22 04:43:40 guenther Exp $	*/
d462 1
a462 1
	if (CIRCLEQ_FIRST(&exp->tq) == CIRCLEQ_END(&exp->tq)) {
d536 2
a537 2
	if (CIRCLEQ_FIRST(&exp->tq) == CIRCLEQ_END(&exp->tq)) {
		CIRCLEQ_INSERT_HEAD(&exp->tq, rtqp, q);
d539 1
a539 1
		rtqp = CIRCLEQ_FIRST(&exp->tq);
d542 1
a542 1
	CIRCLEQ_INSERT_HEAD(&exp->tq, tqp, q);
@


1.17
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.16 2009/10/27 23:59:47 deraadt Exp $	*/
d628 2
a629 2
		p = CIRCLEQ_FIRST(&cbp->textq)->lb;
		tlen = CIRCLEQ_FIRST(&cbp->textq)->len;
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.15 2008/08/29 13:07:13 oga Exp $	*/
d498 2
a499 1
		(void)fprintf(csc->to_fp, "%d%s\n", search, tqp->tag + 2);
@


1.15
log
@Fix nvi's cscope support in the case that someone provided a filename
without a directory (e.g. :cscope add cscope.out). Found and fixed by
Paul Irofti, with help from me; Thanks!

upstream nvi also has this fix.

ok otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.14 2007/09/11 15:47:17 gilles Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_cscope.c	10.13 (Berkeley) 9/15/96";
#endif /* not lint */
@


1.14
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.13 2007/03/20 03:56:13 tedu Exp $	*/
d249 4
@


1.13
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.12 2006/01/08 21:05:40 miod Exp $	*/
d678 1
a678 2
		if ((p = strchr(buf, '\n')) != NULL)
			*p = '\0';
@


1.12
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.11 2005/10/17 19:12:16 otto Exp $	*/
d140 1
a140 1
		for (; *p && isspace(*p); ++p);
d616 1
a616 1
	for (p = pattern + 1; *p != '\0' && isblank(*p); ++p);
@


1.11
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.10 2003/07/09 20:01:31 millert Exp $	*/
d827 1
a827 1
	if (cmd != NULL && *cmd != '\0')
d838 1
@


1.10
log
@Fix double free; eric jackson
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.9 2002/06/12 06:07:16 mpech Exp $	*/
d450 1
a450 1
	if (exp->cscq.lh_first == NULL) {
d462 1
a462 1
	if (exp->tq.cqh_first == (void *)&exp->tq) {
d488 1
a488 1
	for (csc = exp->cscq.lh_first; csc != NULL; csc = csc_next) {
d490 1
a490 1
		csc_next = csc->q.le_next;
d515 1
a515 1
	tqp->current = tqp->tagq.cqh_first;
d535 1
a535 1
	if (exp->tq.cqh_first == (void *)&exp->tq) {
d538 1
a538 1
		rtqp = exp->tq.cqh_first;
d627 2
a628 2
		p = cbp->textq.cqh_first->lb;
		tlen = cbp->textq.cqh_first->len;
d880 2
a881 2
		for (i = 1, csc = exp->cscq.lh_first;
		    csc != NULL; csc = csc->q.le_next, i++)
d926 1
a926 1
	for (exp = EXP(sp); exp->cscq.lh_first != NULL;)
d947 1
a947 1
	if (exp->cscq.lh_first == NULL) {
d952 1
a952 1
	    csc = exp->cscq.lh_first; csc != NULL; ++i, csc = csc->q.le_next)
@


1.9
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.8 2002/02/17 19:42:34 millert Exp $	*/
d274 1
a274 2
	if (read_prompt(sp, csc)) {
		terminate(sp, csc, 0);
a275 1
	}
@


1.8
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.7 2002/02/16 21:27:57 millert Exp $	*/
d956 1
a956 1
		    "%2d %s (process %lu)\n", i, csc->dname, (u_long)csc->pid);
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.6 2001/07/09 07:04:57 deraadt Exp $	*/
d96 1
a96 2
static void	 csc_file __P((SCR *,
		    CSC *, char *, char **, size_t *, int *));
@


1.6
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_cscope.c,v 1.5 2001/01/29 01:58:42 niklas Exp $	*/
d67 5
a71 5
static int cscope_add __P((SCR *, EXCMD *, char *));
static int cscope_find __P((SCR *, EXCMD*, char *));
static int cscope_help __P((SCR *, EXCMD *, char *));
static int cscope_kill __P((SCR *, EXCMD *, char *));
static int cscope_reset __P((SCR *, EXCMD *, char *));
d75 1
a75 1
	int	(*function) __P((SCR *, EXCMD *, char *));
d94 2
a95 2
static TAGQ	*create_cs_cmd __P((SCR *, char *, size_t *));
static int	 csc_help __P((SCR *, char *));
d98 7
a104 7
static int	 get_paths __P((SCR *, CSC *));
static CC const	*lookup_ccmd __P((char *));
static int	 parse __P((SCR *, CSC *, TAGQ *, int *));
static int	 read_prompt __P((SCR *, CSC *));
static int	 run_cscope __P((SCR *, CSC *, char *));
static int	 start_cscopes __P((SCR *, EXCMD *));
static int	 terminate __P((SCR *, CSC *, int));
d110 1
a110 1
 * PUBLIC: int ex_cscope __P((SCR *, EXCMD *));
d939 1
a939 1
 * PUBLIC: int cscope_display __P((SCR *));
d965 1
a965 1
 * PUBLIC: int cscope_search __P((SCR *, TAGQ *, TAG *));
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d409 1
a409 1
		(void)execl(_PATH_BSHELL, "sh", "-c", cmd, NULL);
@


1.4
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d1 2
@


1.3
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_cscope.c	10.12 (Berkeley) 8/11/96";
a27 1
#include <signal.h>
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_cscope.c	10.8 (Berkeley) 6/30/96";
d37 1
d81 1
a81 1
	   "Add a new cscope database", "add db-name" },
d101 1
a101 1
static int	 run_cscope __P((SCR *, CSC *));
d162 1
a162 1
	char *bp, *cscopes, *p;
d182 1
a182 1
	for (cscopes = bp; (p = strsep(&bp, "\t ")) != NULL;)
d185 2
d204 2
a205 1
	char path[MAXPATHLEN];
d209 6
d217 1
a217 14
	/*
	 *  0 args: impossible.
	 *  1 args: usage.
	 *  2 args: matched a directory.
	 * >2 args: object, too many args.
	 *
	 * The 1 args case depends on the argv_sexp() function refusing
	 * to return success without at least one non-blank character.
	 */
	switch (cmdp->argc) {
	case 0:
		abort();
		/* NOTREACHED */
	case 1:
d220 4
a223 4
	case 2:
		dname = cmdp->argv[1]->bp;
		break;
	default:
d228 9
a236 5
	/* If the database file doesn't exist, we're done. */
	(void)snprintf(path, sizeof(path),
	    "%s/%s", cmdp->argv[1]->bp, CSCOPE_DBFILE);
	if (stat(path, &sb)) {
		msgq(sp, M_SYSERR, path);
d239 10
d263 1
a263 1
	if (run_cscope(sp, csc))
d366 1
a366 1
run_cscope(sp, csc)
d369 1
d405 4
a408 3
#define	CSCOPE_CMD_FMT		"cd '%s' && exec cscope -dl"
		(void)snprintf(cmd, sizeof(cmd), CSCOPE_CMD_FMT, csc->dname);
		(void)execl("/bin/sh", "sh", "-c", cmd, NULL);
d664 1
a664 1
	int ch, i, isnewer, nlines;
d725 1
a725 1
		csc_file(sp, csc, name, &dname, &dlen, &isnewer);
d728 3
a730 3
		 * If the file was modified more recently than the cscope
		 * database, or there wasn't a search string, use the line
		 * number.
d732 1
a732 1
		if (isnewer || strcmp(search, "<unknown>") == 0) {
d776 1
a776 1
csc_file(sp, csc, name, dirp, dlenp, isnewerp)
d781 1
a781 1
	int *isnewerp;
d798 1
a798 1
			*isnewerp = sb.st_mtime > csc->mtime;
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_cscope.c	10.6 (Berkeley) 5/16/96";
d715 1
a715 1
		 * If the file was modified less recently than the cscope
d719 1
a719 1
		if (!isnewer || strcmp(search, "<unknown>") == 0) {
d785 1
a785 1
			*isnewerp = sb.st_mtime >= csc->mtime;
d976 1
a976 1
		    tp->search, NULL, SEARCH_CSCOPE | SEARCH_FILE)) {
@
