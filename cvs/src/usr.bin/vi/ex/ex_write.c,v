head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.6
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.8
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.18
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.12;
commitid	adBvXLg05bJxz6yx;

1.12
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.11;
commitid	06bi6U3x4gFFf2G1;

1.11
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.20.03.56.13;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.30.19.43.27;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.11.06.52.00;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.17.19.42.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.40;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.59;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.44;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@/*	$OpenBSD: ex_write.c,v 1.12 2014/11/12 04:28:41 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"

enum which {WN, WQ, WRITE, XIT};
static int exwr(SCR *, EXCMD *, enum which);

/*
 * ex_wn --	:wn[!] [>>] [file]
 *	Write to a file and switch to the next one.
 *
 * PUBLIC: int ex_wn(SCR *, EXCMD *);
 */
int
ex_wn(SCR *sp, EXCMD *cmdp)
{
	if (exwr(sp, cmdp, WN))
		return (1);
	if (file_m3(sp, 0))
		return (1);

	/* The file name isn't a new file to edit. */
	cmdp->argc = 0;

	return (ex_next(sp, cmdp));
}

/*
 * ex_wq --	:wq[!] [>>] [file]
 *	Write to a file and quit.
 *
 * PUBLIC: int ex_wq(SCR *, EXCMD *);
 */
int
ex_wq(SCR *sp, EXCMD *cmdp)
{
	int force;

	if (exwr(sp, cmdp, WQ))
		return (1);
	if (file_m3(sp, 0))
		return (1);

	force = FL_ISSET(cmdp->iflags, E_C_FORCE);

	if (ex_ncheck(sp, force))
		return (1);

	F_SET(sp, force ? SC_EXIT_FORCE : SC_EXIT);
	return (0);
}

/*
 * ex_write --	:write[!] [>>] [file]
 *		:write [!] [cmd]
 *	Write to a file.
 *
 * PUBLIC: int ex_write(SCR *, EXCMD *);
 */
int
ex_write(SCR *sp, EXCMD *cmdp)
{
	return (exwr(sp, cmdp, WRITE));
}


/*
 * ex_xit -- :x[it]! [file]
 *	Write out any modifications and quit.
 *
 * PUBLIC: int ex_xit(SCR *, EXCMD *);
 */
int
ex_xit(SCR *sp, EXCMD *cmdp)
{
	int force;

	NEEDFILE(sp, cmdp);

	if (F_ISSET(sp->ep, F_MODIFIED) && exwr(sp, cmdp, XIT))
		return (1);
	if (file_m3(sp, 0))
		return (1);

	force = FL_ISSET(cmdp->iflags, E_C_FORCE);

	if (ex_ncheck(sp, force))
		return (1);

	F_SET(sp, force ? SC_EXIT_FORCE : SC_EXIT);
	return (0);
}

/*
 * exwr --
 *	The guts of the ex write commands.
 */
static int
exwr(SCR *sp, EXCMD *cmdp, enum which cmd)
{
	MARK rm;
	int flags;
	char *name, *p = NULL;

	NEEDFILE(sp, cmdp);

	/* All write commands can have an associated '!'. */
	LF_INIT(FS_POSSIBLE);
	if (FL_ISSET(cmdp->iflags, E_C_FORCE))
		LF_SET(FS_FORCE);

	/* Skip any leading whitespace. */
	if (cmdp->argc != 0)
		for (p = cmdp->argv[0]->bp; isblank(*p); ++p)
			;

	/* If "write !" it's a pipe to a utility. */
	if (cmdp->argc != 0 && cmd == WRITE && *p == '!') {
		/* Secure means no shell access. */
		if (O_ISSET(sp, O_SECURE)) {
			ex_emsg(sp, cmdp->cmd->name, EXM_SECURE_F);
			return (1);
		}

		/* Expand the argument. */
		for (++p; isblank(*p); ++p);
		if (*p == '\0') {
			ex_emsg(sp, cmdp->cmd->usage, EXM_USAGE);
			return (1);
		}
		if (argv_exp1(sp, cmdp, p, strlen(p), 1))
			return (1);

		/*
		 * Historically, vi waited after a write filter even if there
		 * wasn't any output from the command.  People complained when
		 * nvi waited only if there was output, wanting the visual cue
		 * that the program hadn't written anything.
		 */
		F_SET(sp, SC_EX_WAIT_YES);

		/*
		 * !!!
		 * Ignore the return cursor position, the cursor doesn't
		 * move.
		 */
		if (ex_filter(sp, cmdp, &cmdp->addr1,
		    &cmdp->addr2, &rm, cmdp->argv[1]->bp, FILTER_WRITE))
			return (1);

		/* Ex terminates with a bang, even if the command fails. */
		if (!F_ISSET(sp, SC_VI) && !F_ISSET(sp, SC_EX_SILENT))
			(void)ex_puts(sp, "!\n");

		return (0);
	}

	/* Set the FS_ALL flag if we're writing the entire file. */
	if (cmdp->addr1.lno <= 1 && !db_exist(sp, cmdp->addr2.lno + 1))
		LF_SET(FS_ALL);

	/* If "write >>" it's an append to a file. */
	if (cmdp->argc != 0 && cmd != XIT && p[0] == '>' && p[1] == '>') {
		LF_SET(FS_APPEND);

		/* Skip ">>" and whitespace. */
		for (p += 2; isblank(*p); ++p);
	}

	/* If no other arguments, just write the file back. */
	if (cmdp->argc == 0 || *p == '\0')
		return (file_write(sp,
		    &cmdp->addr1, &cmdp->addr2, NULL, flags));

	/* Build an argv so we get an argument count and file expansion. */
	if (argv_exp2(sp, cmdp, p, strlen(p)))
		return (1);

	/*
	 *  0 args: impossible.
	 *  1 args: impossible (I hope).
	 *  2 args: read it.
	 * >2 args: object, too many args.
	 *
	 * The 1 args case depends on the argv_sexp() function refusing
	 * to return success without at least one non-blank character.
	 */
	switch (cmdp->argc) {
	case 0:
	case 1:
		abort();
		/* NOTREACHED */
	case 2:
		name = cmdp->argv[1]->bp;

		/*
		 * !!!
		 * Historically, the read and write commands renamed
		 * "unnamed" files, or, if the file had a name, set
		 * the alternate file name.
		 */
		if (F_ISSET(sp->frp, FR_TMPFILE) &&
		    !F_ISSET(sp->frp, FR_EXNAMED)) {
			if ((p = v_strdup(sp,
			    cmdp->argv[1]->bp, cmdp->argv[1]->len)) != NULL) {
				free(sp->frp->name);
				sp->frp->name = p;
			}
			/*
			 * The file has a real name, it's no longer a
			 * temporary, clear the temporary file flags.
			 *
			 * !!!
			 * If we're writing the whole file, FR_NAMECHANGE
			 * will be cleared by the write routine -- this is
			 * historic practice.
			 */
			F_CLR(sp->frp, FR_TMPEXIT | FR_TMPFILE);
			F_SET(sp->frp, FR_NAMECHANGE | FR_EXNAMED);

			/* Notify the screen. */
			(void)sp->gp->scr_rename(sp, sp->frp->name, 1);
		} else
			set_alt_name(sp, name);
		break;
	default:
		ex_emsg(sp, p, EXM_FILECOUNT);
		return (1);
	}

	return (file_write(sp, &cmdp->addr1, &cmdp->addr2, name, flags));
}

/*
 * ex_writefp --
 *	Write a range of lines to a FILE *.
 *
 * PUBLIC: int ex_writefp(SCR *,
 * PUBLIC:    char *, FILE *, MARK *, MARK *, u_long *, u_long *, int);
 */
int
ex_writefp(SCR *sp, char *name, FILE *fp, MARK *fm, MARK *tm, u_long *nlno,
    u_long *nch, int silent)
{
	struct stat sb;
	GS *gp;
	u_long ccnt;			/* XXX: can't print off_t portably. */
	recno_t fline, tline, lcnt;
	size_t len;
	int rval;
	char *msg, *p;

	gp = sp->gp;
	fline = fm->lno;
	tline = tm->lno;

	if (nlno != NULL) {
		*nch = 0;
		*nlno = 0;
	}

	/*
	 * The vi filter code has multiple processes running simultaneously,
	 * and one of them calls ex_writefp().  The "unsafe" function calls
	 * in this code are to db_get() and msgq().  Db_get() is safe, see
	 * the comment in ex_filter.c:ex_filter() for details.  We don't call
	 * msgq if the multiple process bit in the EXF is set.
	 *
	 * !!!
	 * Historic vi permitted files of 0 length to be written.  However,
	 * since the way vi got around dealing with "empty" files was to
	 * always have a line in the file no matter what, it wrote them as
	 * files of a single, empty line.  We write empty files.
	 *
	 * "Alex, I'll take vi trivia for $1000."
	 */
	ccnt = 0;
	lcnt = 0;
	msg = "Writing...";
	if (tline != 0)
		for (; fline <= tline; ++fline, ++lcnt) {
			/* Caller has to provide any interrupt message. */
			if ((lcnt + 1) % INTERRUPT_CHECK == 0) {
				if (INTERRUPTED(sp))
					break;
				if (!silent) {
					gp->scr_busy(sp, msg, msg == NULL ?
					    BUSY_UPDATE : BUSY_ON);
					msg = NULL;
				}
			}
			if (db_get(sp, fline, DBG_FATAL, &p, &len))
				goto err;
			if (fwrite(p, 1, len, fp) != len)
				goto err;
			ccnt += len;
			if (putc('\n', fp) != '\n')
				break;
			++ccnt;
		}

	if (fflush(fp))
		goto err;
	/*
	 * XXX
	 * I don't trust NFS -- check to make sure that we're talking to
	 * a regular file and sync so that NFS is forced to flush.
	 */
	if (!fstat(fileno(fp), &sb) &&
	    S_ISREG(sb.st_mode) && fsync(fileno(fp)))
		goto err;

	if (fclose(fp)) {
		fp = NULL;
		goto err;
	}

	rval = 0;
	if (0) {
err:		if (!F_ISSET(sp->ep, F_MULTILOCK))
			msgq_str(sp, M_SYSERR, name, "%s");
		if (fp != NULL)
			(void)fclose(fp);
		rval = 1;
	}

	if (!silent)
		gp->scr_busy(sp, NULL, BUSY_OFF);

	/* Report the possibly partial transfer. */
	if (nlno != NULL) {
		*nch = ccnt;
		*nlno = lcnt;
	}
	return (rval);
}
@


1.12
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_write.c,v 1.11 2009/10/27 23:59:47 deraadt Exp $	*/
d304 1
a304 1
	msg = "253|Writing...";
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_write.c,v 1.10 2007/03/20 03:56:13 tedu Exp $	*/
d40 1
a40 3
ex_wn(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d60 1
a60 3
ex_wq(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d86 1
a86 3
ex_write(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d99 1
a99 3
ex_xit(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d124 1
a124 4
exwr(sp, cmdp, cmd)
	SCR *sp;
	EXCMD *cmdp;
	enum which cmd;
d267 2
a268 7
ex_writefp(sp, name, fp, fm, tm, nlno, nch, silent)
	SCR *sp;
	char *name;
	FILE *fp;
	MARK *fm, *tm;
	u_long *nlno, *nch;
	int silent;
@


1.10
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_write.c,v 1.9 2006/05/30 19:43:27 pvalchev Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_write.c	10.30 (Berkeley) 7/12/96";
#endif /* not lint */
@


1.9
log
@avoid double fclose(), from coverity/NetBSD; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_write.c,v 1.8 2006/03/11 06:52:00 ray Exp $	*/
d154 1
a154 1
		for (p = cmdp->argv[0]->bp; *p != '\0' && isblank(*p); ++p)
d166 1
a166 1
		for (++p; *p && isblank(*p); ++p);
d207 1
a207 1
		for (p += 2; *p && isblank(*p); ++p);
@


1.8
log
@Initialize p to NULL to prevent gcc warning.
Clarify a for statement.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_write.c,v 1.7 2002/02/17 19:42:34 millert Exp $	*/
d358 2
a359 1
	if (fclose(fp))
d361 1
d367 2
a368 1
		(void)fclose(fp);
@


1.7
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_write.c,v 1.6 2002/02/16 21:27:57 millert Exp $	*/
d143 1
a143 1
	char *name, *p;
d154 2
a155 1
		for (p = cmdp->argv[0]->bp; *p != '\0' && isblank(*p); ++p);
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_write.c,v 1.5 2001/01/29 01:58:45 niklas Exp $	*/
d277 2
a278 2
 * PUBLIC: int ex_writefp __P((SCR *,
 * PUBLIC:    char *, FILE *, MARK *, MARK *, u_long *, u_long *, int));
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
a35 1
static int exwr __P((SCR *, EXCMD *, enum which));
d41 1
a41 1
 * PUBLIC: int ex_wn __P((SCR *, EXCMD *));
d63 1
a63 1
 * PUBLIC: int ex_wq __P((SCR *, EXCMD *));
d91 1
a91 1
 * PUBLIC: int ex_write __P((SCR *, EXCMD *));
d106 1
a106 1
 * PUBLIC: int ex_xit __P((SCR *, EXCMD *));
@


1.4
log
@nvi 1.73
@
text
@d1 2
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_write.c	10.28 (Berkeley) 6/28/96";
d196 1
a196 1
	if (cmdp->addr1.lno == 1 && !db_exist(sp, cmdp->addr2.lno + 1))
d259 1
a259 1
			(void)sp->gp->scr_rename(sp);
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_write.c	10.25 (Berkeley) 5/8/96";
d162 1
a167 1
		/* Expand the argument. */
d172 8
d195 4
d207 2
a208 4
	/* If no arguments, just write the file back. */
	if (cmdp->argc == 0 || *p == '\0') {
		if (F_ISSET(cmdp, E_ADDR2_ALL))
			LF_SET(FS_ALL);
a210 1
	}
a267 2
	if (F_ISSET(cmdp, E_ADDR2_ALL))
		LF_SET(FS_ALL);
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)ex_write.c	8.38 (Berkeley) 8/17/94";
a18 1
#include <sys/time.h>
a24 1
#include <signal.h>
d26 1
a27 1
#include <termios.h>
d30 1
a30 6
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
d33 1
a33 2

static int exwr __P((SCR *, EXF *, EXCMDARG *, enum which));
d38 2
d42 1
a42 1
ex_wn(sp, ep, cmdp)
d44 1
a44 2
	EXF *ep;
	EXCMDARG *cmdp;
d46 1
a46 1
	if (exwr(sp, ep, cmdp, WN))
d48 1
a48 1
	if (file_m3(sp, ep, 0))
d54 1
a54 1
	return (ex_next(sp, ep, cmdp));
d60 2
d64 1
a64 1
ex_wq(sp, ep, cmdp)
d66 1
a66 2
	EXF *ep;
	EXCMDARG *cmdp;
d70 1
a70 1
	if (exwr(sp, ep, cmdp, WQ))
d72 1
a72 1
	if (file_m3(sp, ep, 0))
d75 1
a75 1
	force = F_ISSET(cmdp, E_FORCE);
d80 1
a80 1
	F_SET(sp, force ? S_EXIT_FORCE : S_EXIT);
d88 2
d92 1
a92 1
ex_write(sp, ep, cmdp)
d94 1
a94 2
	EXF *ep;
	EXCMDARG *cmdp;
d96 1
a96 1
	return (exwr(sp, ep, cmdp, WRITE));
d102 1
d104 1
a104 1
 *	Write out any modifications and quit.
d107 1
a107 1
ex_xit(sp, ep, cmdp)
d109 1
a109 2
	EXF *ep;
	EXCMDARG *cmdp;
d113 3
a115 1
	if (F_ISSET((ep), F_MODIFIED) && exwr(sp, ep, cmdp, XIT))
d117 1
a117 1
	if (file_m3(sp, ep, 0))
d120 1
a120 1
	force = F_ISSET(cmdp, E_FORCE);
d125 1
a125 1
	F_SET(sp, force ? S_EXIT_FORCE : S_EXIT);
d134 1
a134 1
exwr(sp, ep, cmdp, cmd)
d136 1
a136 2
	EXF *ep;
	EXCMDARG *cmdp;
a138 1
	EX_PRIVATE *exp;
d143 2
d147 1
a147 1
	if (F_ISSET(cmdp, E_FORCE))
d152 1
a152 1
		for (p = cmdp->argv[0]->bp; *p && isblank(*p); ++p);
d154 7
a160 7
	/* If no arguments, just write the file back. */
	if (cmdp->argc == 0 || *p == '\0') {
		if (F_ISSET(cmdp, E_ADDR2_ALL))
			LF_SET(FS_ALL);
		return (file_write(sp, ep,
		    &cmdp->addr1, &cmdp->addr2, NULL, flags));
	}
a161 3
	/* If "write !" it's a pipe to a utility. */
	exp = EXP(sp);
	if (cmd == WRITE && *p == '!') {
d164 1
a164 1
			msgq(sp, M_ERR, "Usage: %s", cmdp->cmd->usage);
d168 1
a168 1
		if (argv_exp1(sp, ep, cmdp, p, strlen(p), 0))
d170 8
a177 2
		if (filtercmd(sp, ep, &cmdp->addr1, &cmdp->addr2,
		    &rm, cmdp->argv[1]->bp, FILTER_WRITE))
d179 5
a183 1
		sp->lno = rm.lno;
d188 1
a188 1
	if (cmd != XIT && p[0] == '>' && p[1] == '>') {
d195 8
d204 1
a204 1
	if (argv_exp2(sp, ep, cmdp, p, strlen(p), 0))
d207 9
d217 1
d219 5
d225 4
a228 3
		 * Nothing to expand, write the current file.
		 * XXX
		 * Should never happen, already checked this case.
d230 23
a252 6
		name = NULL;
		break;
	case 2:
		/* One new argument, write it. */
		name = cmdp->argv[exp->argsoff - 1]->bp;
		set_alt_name(sp, name);
d255 1
a255 4
		/* If expanded to more than one argument, object. */
		msgq(sp, M_ERR, "%s expanded into too many file names",
		    cmdp->argv[0]->bp);
		msgq(sp, M_ERR, "Usage: %s", cmdp->cmd->usage);
d261 1
a261 1
	return (file_write(sp, ep, &cmdp->addr1, &cmdp->addr2, name, flags));
d267 3
d272 1
a272 1
ex_writefp(sp, ep, name, fp, fm, tm, nlno, nch)
a273 1
	EXF *ep;
d278 1
d281 1
d285 2
a286 2
	int sv_errno;
	char *p;
d288 1
d300 2
a301 2
	 * in this code are to file_gline() and msgq().  File_gline() is safe,
	 * see the comment in filter.c:filtercmd() for details.  We don't call
d314 2
a315 1
	if (tline != 0) {
d318 8
a325 8
			if (INTERRUPTED(sp))
				break;
			if ((p = file_gline(sp, ep, fline, &len)) == NULL)
				break;
			if (fwrite(p, 1, len, fp) != len) {
				msgq(sp, M_SYSERR, name);
				(void)fclose(fp);
				return (1);
d327 4
a335 1
	}
d337 7
a343 1
	/* If it's a regular file, sync it so that NFS is forced to flush. */
d345 1
a345 4
	    S_ISREG(sb.st_mode) && fsync(fileno(fp))) {
		sv_errno = errno;
		(void)fclose(fp);
		errno = sv_errno;
d347 1
a347 1
	}
d350 13
d367 1
a367 5
	return (0);

err:	if (!F_ISSET(ep, F_MULTILOCK))
		msgq(sp, M_SYSERR, name);
	return (1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
