head	1.20;
access;
symbols
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.13.0.22
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.20
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.16
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.12
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.16
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.14
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.12
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.10
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.19;
commitid	01nAnartGL7onLD3;

1.19
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.18;
commitid	ruCZ2IKF0FB0ebCr;

1.18
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.17;
commitid	adBvXLg05bJxz6yx;

1.17
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	gtDERb7QyXwKGs62;

1.16
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.15;
commitid	T0XpHzXjuQBl1V3E;

1.15
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.14;
commitid	06bi6U3x4gFFf2G1;

1.14
date	2014.10.14.22.23.12;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	mpIoFH2QkbUBhYb5;

1.13
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.19.42.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.09.07.04.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.29.01.58.41;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.16.01.18.33;	author michaels;	state Exp;
branches;
next	1.5;

1.5
date	96.08.20.22.56.04;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.33;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.50;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.35.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: ex_argv.c,v 1.18 2016/01/06 22:28:52 millert Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"

static int argv_alloc(SCR *, size_t);
static int argv_comp(const void *, const void *);
static int argv_fexp(SCR *, EXCMD *,
	char *, size_t, char *, size_t *, char **, size_t *, int);
static int argv_lexp(SCR *, EXCMD *, char *);
static int argv_sexp(SCR *, char **, size_t *, size_t *);

/*
 * argv_init --
 *	Build  a prototype arguments list.
 *
 * PUBLIC: int argv_init(SCR *, EXCMD *);
 */
int
argv_init(SCR *sp, EXCMD *excp)
{
	EX_PRIVATE *exp;

	exp = EXP(sp);
	exp->argsoff = 0;
	argv_alloc(sp, 1);

	excp->argv = exp->args;
	excp->argc = exp->argsoff;
	return (0);
}

/*
 * argv_exp0 --
 *	Append a string to the argument list.
 *
 * PUBLIC: int argv_exp0(SCR *, EXCMD *, char *, size_t);
 */
int
argv_exp0(SCR *sp, EXCMD *excp, char *cmd, size_t cmdlen)
{
	EX_PRIVATE *exp;

	exp = EXP(sp);
	argv_alloc(sp, cmdlen);
	memcpy(exp->args[exp->argsoff]->bp, cmd, cmdlen);
	exp->args[exp->argsoff]->bp[cmdlen] = '\0';
	exp->args[exp->argsoff]->len = cmdlen;
	++exp->argsoff;
	excp->argv = exp->args;
	excp->argc = exp->argsoff;
	return (0);
}

/*
 * argv_exp1 --
 *	Do file name expansion on a string, and append it to the
 *	argument list.
 *
 * PUBLIC: int argv_exp1(SCR *, EXCMD *, char *, size_t, int);
 */
int
argv_exp1(SCR *sp, EXCMD *excp, char *cmd, size_t cmdlen, int is_bang)
{
	size_t blen, len;
	char *bp, *p, *t;

	GET_SPACE_RET(sp, bp, blen, 512);

	len = 0;
	if (argv_fexp(sp, excp, cmd, cmdlen, bp, &len, &bp, &blen, is_bang)) {
		FREE_SPACE(sp, bp, blen);
		return (1);
	}

	/* If it's empty, we're done. */
	if (len != 0) {
		for (p = bp, t = bp + len; p < t; ++p)
			if (!isblank(*p))
				break;
		if (p == t)
			goto ret;
	} else
		goto ret;

	(void)argv_exp0(sp, excp, bp, len);

ret:	FREE_SPACE(sp, bp, blen);
	return (0);
}

/*
 * argv_exp2 --
 *	Do file name and shell expansion on a string, and append it to
 *	the argument list.
 *
 * PUBLIC: int argv_exp2(SCR *, EXCMD *, char *, size_t);
 */
int
argv_exp2(SCR *sp, EXCMD *excp, char *cmd, size_t cmdlen)
{
	size_t blen, len, n;
	int rval;
	char *bp, *mp, *p;

	GET_SPACE_RET(sp, bp, blen, 512);

#define	SHELLECHO	"echo "
#define	SHELLOFFSET	(sizeof(SHELLECHO) - 1)
	memcpy(bp, SHELLECHO, SHELLOFFSET);
	p = bp + SHELLOFFSET;
	len = SHELLOFFSET;

#if defined(DEBUG) && 0
	TRACE(sp, "file_argv: {%.*s}\n", (int)cmdlen, cmd);
#endif

	if (argv_fexp(sp, excp, cmd, cmdlen, p, &len, &bp, &blen, 0)) {
		rval = 1;
		goto err;
	}

#if defined(DEBUG) && 0
	TRACE(sp, "before shell: %d: {%s}\n", len, bp);
#endif

	/*
	 * Do shell word expansion -- it's very, very hard to figure out what
	 * magic characters the user's shell expects.  Historically, it was a
	 * union of v7 shell and csh meta characters.  We match that practice
	 * by default, so ":read \%" tries to read a file named '%'.  It would
	 * make more sense to pass any special characters through the shell,
	 * but then, if your shell was csh, the above example will behave
	 * differently in nvi than in vi.  If you want to get other characters
	 * passed through to your shell, change the "meta" option.
	 *
	 * To avoid a function call per character, we do a first pass through
	 * the meta characters looking for characters that aren't expected
	 * to be there, and then we can ignore them in the user's argument.
	 */
	if (opts_empty(sp, O_SHELL, 1) || opts_empty(sp, O_SHELLMETA, 1))
		n = 0;
	else {
		for (p = mp = O_STR(sp, O_SHELLMETA); *p != '\0'; ++p)
			if (isblank(*p) || isalnum(*p))
				break;
		p = bp + SHELLOFFSET;
		n = len - SHELLOFFSET;
		if (*p != '\0') {
			for (; n > 0; --n, ++p)
				if (strchr(mp, *p) != NULL)
					break;
		} else
			for (; n > 0; --n, ++p)
				if (!isblank(*p) &&
				    !isalnum(*p) && strchr(mp, *p) != NULL)
					break;
	}

	/*
	 * If we found a meta character in the string, fork a shell to expand
	 * it.  Unfortunately, this is comparatively slow.  Historically, it
	 * didn't matter much, since users don't enter meta characters as part
	 * of pathnames that frequently.  The addition of filename completion
	 * broke that assumption because it's easy to use.  As a result, lots
	 * folks have complained that the expansion code is too slow.  So, we
	 * detect filename completion as a special case, and do it internally.
	 * Note that this code assumes that the <asterisk> character is the
	 * match-anything meta character.  That feels safe -- if anyone writes
	 * a shell that doesn't follow that convention, I'd suggest giving them
	 * a festive hot-lead enema.
	 */
	switch (n) {
	case 0:
		p = bp + SHELLOFFSET;
		len -= SHELLOFFSET;
		rval = argv_exp3(sp, excp, p, len);
		break;
	case 1:
		if (*p == '*') {
			*p = '\0';
			rval = argv_lexp(sp, excp, bp + SHELLOFFSET);
			break;
		}
		/* FALLTHROUGH */
	default:
		if (argv_sexp(sp, &bp, &blen, &len)) {
			rval = 1;
			goto err;
		}
		p = bp;
		rval = argv_exp3(sp, excp, p, len);
		break;
	}

err:	FREE_SPACE(sp, bp, blen);
	return (rval);
}

/*
 * argv_exp3 --
 *	Take a string and break it up into an argv, which is appended
 *	to the argument list.
 *
 * PUBLIC: int argv_exp3(SCR *, EXCMD *, char *, size_t);
 */
int
argv_exp3(SCR *sp, EXCMD *excp, char *cmd, size_t cmdlen)
{
	EX_PRIVATE *exp;
	size_t len;
	int ch, off;
	char *ap, *p;

	for (exp = EXP(sp); cmdlen > 0; ++exp->argsoff) {
		/* Skip any leading whitespace. */
		for (; cmdlen > 0; --cmdlen, ++cmd) {
			ch = *cmd;
			if (!isblank(ch))
				break;
		}
		if (cmdlen == 0)
			break;

		/*
		 * Determine the length of this whitespace delimited
		 * argument.
		 *
		 * QUOTING NOTE:
		 *
		 * Skip any character preceded by the user's quoting
		 * character.
		 */
		for (ap = cmd, len = 0; cmdlen > 0; ++cmd, --cmdlen, ++len) {
			ch = *cmd;
			if (IS_ESCAPE(sp, excp, ch) && cmdlen > 1) {
				++cmd;
				--cmdlen;
			} else if (isblank(ch))
				break;
		}

		/*
		 * Copy the argument into place.
		 *
		 * QUOTING NOTE:
		 *
		 * Lose quote chars.
		 */
		argv_alloc(sp, len);
		off = exp->argsoff;
		exp->args[off]->len = len;
		for (p = exp->args[off]->bp; len > 0; --len, *p++ = *ap++)
			if (IS_ESCAPE(sp, excp, *ap))
				++ap;
		*p = '\0';
	}
	excp->argv = exp->args;
	excp->argc = exp->argsoff;

#if defined(DEBUG) && 0
	for (cnt = 0; cnt < exp->argsoff; ++cnt)
		TRACE(sp, "arg %d: {%s}\n", cnt, exp->argv[cnt]);
#endif
	return (0);
}

/*
 * argv_fexp --
 *	Do file name and bang command expansion.
 */
static int
argv_fexp(SCR *sp, EXCMD *excp, char *cmd, size_t cmdlen, char *p,
    size_t *lenp, char **bpp, size_t *blenp, int is_bang)
{
	EX_PRIVATE *exp;
	char *bp, *t;
	size_t blen, len, off, tlen;

	/* Replace file name characters. */
	for (bp = *bpp, blen = *blenp, len = *lenp; cmdlen > 0; --cmdlen, ++cmd)
		switch (*cmd) {
		case '!':
			if (!is_bang)
				goto ins_ch;
			exp = EXP(sp);
			if (exp->lastbcomm == NULL) {
				msgq(sp, M_ERR,
				    "No previous command to replace \"!\"");
				return (1);
			}
			len += tlen = strlen(exp->lastbcomm);
			off = p - bp;
			ADD_SPACE_RET(sp, bp, blen, len);
			p = bp + off;
			memcpy(p, exp->lastbcomm, tlen);
			p += tlen;
			F_SET(excp, E_MODIFY);
			break;
		case '%':
			if ((t = sp->frp->name) == NULL) {
				msgq(sp, M_ERR,
				    "No filename to substitute for %%");
				return (1);
			}
			tlen = strlen(t);
			len += tlen;
			off = p - bp;
			ADD_SPACE_RET(sp, bp, blen, len);
			p = bp + off;
			memcpy(p, t, tlen);
			p += tlen;
			F_SET(excp, E_MODIFY);
			break;
		case '#':
			if ((t = sp->alt_name) == NULL) {
				msgq(sp, M_ERR,
				    "No filename to substitute for #");
				return (1);
			}
			len += tlen = strlen(t);
			off = p - bp;
			ADD_SPACE_RET(sp, bp, blen, len);
			p = bp + off;
			memcpy(p, t, tlen);
			p += tlen;
			F_SET(excp, E_MODIFY);
			break;
		case '\\':
			/*
			 * QUOTING NOTE:
			 *
			 * Strip any backslashes that protected the file
			 * expansion characters.
			 */
			if (cmdlen > 1 &&
			    (cmd[1] == '%' || cmd[1] == '#' || cmd[1] == '!')) {
				++cmd;
				--cmdlen;
			}
			/* FALLTHROUGH */
		default:
ins_ch:			++len;
			off = p - bp;
			ADD_SPACE_RET(sp, bp, blen, len);
			p = bp + off;
			*p++ = *cmd;
		}

	/* Nul termination. */
	++len;
	off = p - bp;
	ADD_SPACE_RET(sp, bp, blen, len);
	p = bp + off;
	*p = '\0';

	/* Return the new string length, buffer, buffer length. */
	*lenp = len - 1;
	*bpp = bp;
	*blenp = blen;
	return (0);
}

/*
 * argv_alloc --
 *	Make more space for arguments.
 */
static int
argv_alloc(SCR *sp, size_t len)
{
	ARGS *ap;
	EX_PRIVATE *exp;
	int cnt, off;

	/*
	 * Allocate room for another argument, always leaving
	 * enough room for an ARGS structure with a length of 0.
	 */
#define	INCREMENT	20
	exp = EXP(sp);
	off = exp->argsoff;
	if (exp->argscnt == 0 || off + 2 >= exp->argscnt - 1) {
		cnt = exp->argscnt + INCREMENT;
		REALLOCARRAY(sp, exp->args, cnt, sizeof(ARGS *));
		if (exp->args == NULL) {
			(void)argv_free(sp);
			goto mem;
		}
		memset(&exp->args[exp->argscnt], 0, INCREMENT * sizeof(ARGS *));
		exp->argscnt = cnt;
	}

	/* First argument. */
	if (exp->args[off] == NULL) {
		CALLOC(sp, exp->args[off], 1, sizeof(ARGS));
		if (exp->args[off] == NULL)
			goto mem;
	}

	/* First argument buffer. */
	ap = exp->args[off];
	ap->len = 0;
	if (ap->blen < len + 1) {
		ap->blen = len + 1;
		REALLOCARRAY(sp, ap->bp, ap->blen, sizeof(CHAR_T));
		if (ap->bp == NULL) {
			ap->bp = NULL;
			ap->blen = 0;
			F_CLR(ap, A_ALLOCATED);
mem:			msgq(sp, M_SYSERR, NULL);
			return (1);
		}
		F_SET(ap, A_ALLOCATED);
	}

	/* Second argument. */
	if (exp->args[++off] == NULL) {
		CALLOC(sp, exp->args[off], 1, sizeof(ARGS));
		if (exp->args[off] == NULL)
			goto mem;
	}
	/* 0 length serves as end-of-argument marker. */
	exp->args[off]->len = 0;
	return (0);
}

/*
 * argv_free --
 *	Free up argument structures.
 *
 * PUBLIC: int argv_free(SCR *);
 */
int
argv_free(SCR *sp)
{
	EX_PRIVATE *exp;
	int off;

	exp = EXP(sp);
	if (exp->args != NULL) {
		for (off = 0; off < exp->argscnt; ++off) {
			if (exp->args[off] == NULL)
				continue;
			if (F_ISSET(exp->args[off], A_ALLOCATED))
				free(exp->args[off]->bp);
			free(exp->args[off]);
		}
		free(exp->args);
	}
	exp->args = NULL;
	exp->argscnt = 0;
	exp->argsoff = 0;
	return (0);
}

/*
 * argv_lexp --
 *	Find all file names matching the prefix and append them to the
 *	buffer.
 */
static int
argv_lexp(SCR *sp, EXCMD *excp, char *path)
{
	struct dirent *dp;
	DIR *dirp;
	EX_PRIVATE *exp;
	int off;
	size_t dlen, nlen;
	char *dname, *name, *p;

	exp = EXP(sp);

	/* Set up the name and length for comparison. */
	if ((p = strrchr(path, '/')) == NULL) {
		dname = ".";
		dlen = 0;
		name = path;
	} else { 
		if (p == path) {
			dname = "/";
			dlen = 1;
		} else {
			*p = '\0';
			dname = path;
			dlen = strlen(path);
		}
		name = p + 1;
	}
	nlen = strlen(name);

	if ((dirp = opendir(dname)) == NULL) {
		msgq_str(sp, M_SYSERR, dname, "%s");
		return (1);
	}
	for (off = exp->argsoff; (dp = readdir(dirp)) != NULL;) {
		if (nlen == 0) {
			if (dp->d_name[0] == '.')
				continue;
		} else {
			if (dp->d_namlen < nlen ||
			    memcmp(dp->d_name, name, nlen))
				continue;
		}

		/* Directory + name + slash + null. */
		argv_alloc(sp, dlen + dp->d_namlen + 2);
		p = exp->args[exp->argsoff]->bp;
		if (dlen != 0) {
			memcpy(p, dname, dlen);
			p += dlen;
			if (dlen > 1 || dname[0] != '/')
				*p++ = '/';
		}
		memcpy(p, dp->d_name, dp->d_namlen + 1);
		exp->args[exp->argsoff]->len = dlen + dp->d_namlen + 1;
		++exp->argsoff;
		excp->argv = exp->args;
		excp->argc = exp->argsoff;
	}
	closedir(dirp);

	if (off == exp->argsoff) {
		/*
		 * If we didn't find a match, complain that the expansion
		 * failed.  We can't know for certain that's the error, but
		 * it's a good guess, and it matches historic practice. 
		 */
		msgq(sp, M_ERR, "Shell expansion failed");
		return (1);
	}
	qsort(exp->args + off, exp->argsoff - off, sizeof(ARGS *), argv_comp);
	return (0);
}

/*
 * argv_comp --
 *	Alphabetic comparison.
 */
static int
argv_comp(const void *a, const void *b)
{
	return (strcmp((char *)(*(ARGS **)a)->bp, (char *)(*(ARGS **)b)->bp));
}

/*
 * argv_sexp --
 *	Fork a shell, pipe a command through it, and read the output into
 *	a buffer.
 */
static int
argv_sexp(SCR *sp, char **bpp, size_t *blenp, size_t *lenp)
{
	enum { SEXP_ERR, SEXP_EXPANSION_ERR, SEXP_OK } rval;
	FILE *ifp;
	pid_t pid;
	size_t blen, len;
	int ch, std_output[2];
	char *bp, *p, *sh, *sh_path;

	/* Secure means no shell access. */
	if (O_ISSET(sp, O_SECURE)) {
		msgq(sp, M_ERR,
"Shell expansions not supported when the secure edit option is set");
		return (1);
	}

	sh_path = O_STR(sp, O_SHELL);
	if ((sh = strrchr(sh_path, '/')) == NULL)
		sh = sh_path;
	else
		++sh;

	/* Local copies of the buffer variables. */
	bp = *bpp;
	blen = *blenp;

	/*
	 * There are two different processes running through this code, named
	 * the utility (the shell) and the parent. The utility reads standard
	 * input and writes standard output and standard error output.  The
	 * parent writes to the utility, reads its standard output and ignores
	 * its standard error output.  Historically, the standard error output
	 * was discarded by vi, as it produces a lot of noise when file patterns
	 * don't match.
	 *
	 * The parent reads std_output[0], and the utility writes std_output[1].
	 */
	ifp = NULL;
	std_output[0] = std_output[1] = -1;
	if (pipe(std_output) < 0) {
		msgq(sp, M_SYSERR, "pipe");
		return (1);
	}
	if ((ifp = fdopen(std_output[0], "r")) == NULL) {
		msgq(sp, M_SYSERR, "fdopen");
		goto err;
	}

	/*
	 * Do the minimal amount of work possible, the shell is going to run
	 * briefly and then exit.  We sincerely hope.
	 */
	switch (pid = vfork()) {
	case -1:			/* Error. */
		msgq(sp, M_SYSERR, "vfork");
err:		if (ifp != NULL)
			(void)fclose(ifp);
		else if (std_output[0] != -1)
			close(std_output[0]);
		if (std_output[1] != -1)
			close(std_output[0]);
		return (1);
	case 0:				/* Utility. */
		/* Redirect stdout to the write end of the pipe. */
		(void)dup2(std_output[1], STDOUT_FILENO);

		/* Close the utility's file descriptors. */
		(void)close(std_output[0]);
		(void)close(std_output[1]);
		(void)close(STDERR_FILENO);

		/*
		 * XXX
		 * Assume that all shells have -c.
		 */
		execl(sh_path, sh, "-c", bp, (char *)NULL);
		msgq_str(sp, M_SYSERR, sh_path, "Error: execl: %s");
		_exit(127);
	default:			/* Parent. */
		/* Close the pipe ends the parent won't use. */
		(void)close(std_output[1]);
		break;
	}

	/*
	 * Copy process standard output into a buffer.
	 *
	 * !!!
	 * Historic vi apparently discarded leading \n and \r's from
	 * the shell output stream.  We don't on the grounds that any
	 * shell that does that is broken.
	 */
	for (p = bp, len = 0, ch = EOF;
	    (ch = getc(ifp)) != EOF; *p++ = ch, --blen, ++len)
		if (blen < 5) {
			ADD_SPACE_GOTO(sp, bp, *blenp, *blenp * 2);
			p = bp + len;
			blen = *blenp - len;
		}

	/* Delete the final newline, nul terminate the string. */
	if (p > bp && (p[-1] == '\n' || p[-1] == '\r')) {
		--p;
		--len;
	}
	*p = '\0';
	*lenp = len;
	*bpp = bp;		/* *blenp is already updated. */

	if (ferror(ifp))
		goto ioerr;
	if (fclose(ifp)) {
ioerr:		msgq_str(sp, M_ERR, sh, "I/O error: %s");
alloc_err:	rval = SEXP_ERR;
	} else
		rval = SEXP_OK;

	/*
	 * Wait for the process.  If the shell process fails (e.g., "echo $q"
	 * where q wasn't a defined variable) or if the returned string has
	 * no characters or only blank characters, (e.g., "echo $5"), complain
	 * that the shell expansion failed.  We can't know for certain that's
	 * the error, but it's a good guess, and it matches historic practice.
	 * This won't catch "echo foo_$5", but that's not a common error and
	 * historic vi didn't catch it either.
	 */
	if (proc_wait(sp, pid, sh, 1, 0))
		rval = SEXP_EXPANSION_ERR;

	for (p = bp; len; ++p, --len)
		if (!isblank(*p))
			break;
	if (len == 0)
		rval = SEXP_EXPANSION_ERR;

	if (rval == SEXP_EXPANSION_ERR)
		msgq(sp, M_ERR, "Shell expansion failed");

	return (rval == SEXP_OK ? 0 : 1);
}
@


1.19
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d428 1
a428 1
		REALLOC(sp, ap->bp, ap->blen);
@


1.18
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.17 2015/12/07 20:39:19 mmcc Exp $	*/
d428 1
a428 1
		REALLOCARRAY(sp, ap->bp, ap->blen, sizeof(CHAR_T));
@


1.17
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.16 2014/11/12 16:29:04 millert Exp $	*/
d312 1
a312 1
				    "115|No previous command to replace \"!\"");
d326 1
a326 1
				    "116|No filename to substitute for %%");
d341 1
a341 1
				    "117|No filename to substitute for #");
d551 1
a551 1
		msgq(sp, M_ERR, "304|Shell expansion failed");
d586 1
a586 1
"289|Shell expansions not supported when the secure edit option is set");
d650 1
a650 1
		msgq_str(sp, M_SYSERR, sh_path, "118|Error: execl: %s");
d686 1
a686 1
ioerr:		msgq_str(sp, M_ERR, sh, "119|I/O error: %s");
d710 1
a710 1
		msgq(sp, M_ERR, "304|Shell expansion failed");
@


1.16
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.15 2014/11/12 04:28:41 bentley Exp $	*/
d407 1
a407 1
		REALLOCARRAY(sp, exp->args, ARGS **, cnt, sizeof(ARGS *));
d418 1
a418 1
		CALLOC(sp, exp->args[off], ARGS *, 1, sizeof(ARGS));
d428 1
a428 1
		REALLOCARRAY(sp, ap->bp, CHAR_T *, ap->blen, sizeof(CHAR_T));
d441 1
a441 1
		CALLOC(sp, exp->args[off], ARGS *, 1, sizeof(ARGS));
@


1.15
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.14 2014/10/14 22:23:12 deraadt Exp $	*/
d491 1
a491 1
	size_t dlen, len, nlen;
a513 5
	/*
	 * XXX
	 * We don't use the d_namlen field, it's not portable enough; we
	 * assume that d_name is nul terminated, instead.
	 */
a521 1
			len = strlen(dp->d_name);
d523 2
a524 2
			len = strlen(dp->d_name);
			if (len < nlen || memcmp(dp->d_name, name, nlen))
d529 1
a529 1
		argv_alloc(sp, dlen + len + 2);
d537 2
a538 2
		memcpy(p, dp->d_name, len + 1);
		exp->args[exp->argsoff]->len = dlen + len + 1;
@


1.14
log
@create a REALLOCARRAY macro, and use it where it gives us overflow
protection for free
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.13 2009/10/27 23:59:47 deraadt Exp $	*/
d43 1
a43 3
argv_init(sp, excp)
	SCR *sp;
	EXCMD *excp;
d63 1
a63 5
argv_exp0(sp, excp, cmd, cmdlen)
	SCR *sp;
	EXCMD *excp;
	char *cmd;
	size_t cmdlen;
d86 1
a86 6
argv_exp1(sp, excp, cmd, cmdlen, is_bang)
	SCR *sp;
	EXCMD *excp;
	char *cmd;
	size_t cmdlen;
	int is_bang;
d123 1
a123 5
argv_exp2(sp, excp, cmd, cmdlen)
	SCR *sp;
	EXCMD *excp;
	char *cmd;
	size_t cmdlen;
d231 1
a231 5
argv_exp3(sp, excp, cmd, cmdlen)
	SCR *sp;
	EXCMD *excp;
	char *cmd;
	size_t cmdlen;
d296 2
a297 6
argv_fexp(sp, excp, cmd, cmdlen, p, lenp, bpp, blenp, is_bang)
	SCR *sp;
	EXCMD *excp;
	char *cmd, *p, **bpp;
	size_t cmdlen, *lenp, *blenp;
	int is_bang;
d392 1
a392 3
argv_alloc(sp, len)
	SCR *sp;
	size_t len;
d457 1
a457 2
argv_free(sp)
	SCR *sp;
d485 1
a485 4
argv_lexp(sp, excp, path)
	SCR *sp;
	EXCMD *excp;
	char *path;
d569 1
a569 2
argv_comp(a, b)
	const void *a, *b;
d580 1
a580 4
argv_sexp(sp, bpp, blenp, lenp)
	SCR *sp;
	char **bpp;
	size_t *blenp, *lenp;
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.12 2006/04/22 03:09:15 ray Exp $	*/
d432 1
a432 1
		REALLOC(sp, exp->args, ARGS **, cnt * sizeof(ARGS *));
d453 1
a453 1
		REALLOC(sp, ap->bp, CHAR_T *, ap->blen * sizeof(CHAR_T));
@


1.12
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.11 2002/06/12 06:07:16 mpech Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_argv.c	10.26 (Berkeley) 9/20/96";
#endif /* not lint */
@


1.11
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.10 2002/02/17 19:42:34 millert Exp $	*/
a102 1
	EX_PRIVATE *exp;
a108 1
	exp = EXP(sp);
@


1.10
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.9 2002/02/16 21:27:57 millert Exp $	*/
d745 1
a745 1
	if (proc_wait(sp, (long)pid, sh, 1, 0))
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.8 2001/07/09 07:04:57 deraadt Exp $	*/
d35 2
a36 2
static int argv_fexp __P((SCR *, EXCMD *,
	char *, size_t, char *, size_t *, char **, size_t *, int));
@


1.8
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_argv.c,v 1.7 2001/01/29 01:58:41 niklas Exp $	*/
d33 2
a34 2
static int argv_alloc __P((SCR *, size_t));
static int argv_comp __P((const void *, const void *));
d37 2
a38 2
static int argv_lexp __P((SCR *, EXCMD *, char *));
static int argv_sexp __P((SCR *, char **, size_t *, size_t *));
d44 1
a44 1
 * PUBLIC: int argv_init __P((SCR *, EXCMD *));
d66 1
a66 1
 * PUBLIC: int argv_exp0 __P((SCR *, EXCMD *, char *, size_t));
d93 1
a93 1
 * PUBLIC: int argv_exp1 __P((SCR *, EXCMD *, char *, size_t, int));
d137 1
a137 1
 * PUBLIC: int argv_exp2 __P((SCR *, EXCMD *, char *, size_t));
d249 1
a249 1
 * PUBLIC: int argv_exp3 __P((SCR *, EXCMD *, char *, size_t));
d485 1
a485 1
 * PUBLIC: int argv_free __P((SCR *));
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d694 1
a694 1
		execl(sh_path, sh, "-c", bp, NULL);
@


1.6
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d1 2
@


1.5
log
@nvi 1.74
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_argv.c	10.25 (Berkeley) 8/13/96";
d328 1
a328 1
	size_t blen, len, tlen;
d343 1
d345 1
d358 1
d360 1
d372 1
d374 1
d394 1
d396 1
d402 1
d404 1
@


1.4
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_argv.c	10.23 (Berkeley) 8/11/96";
d32 1
d35 1
a35 2
static int argv_prefix __P((SCR *,
	char *, char *, char **, size_t *, size_t *));
d77 1
a77 1
	memmove(exp->args[exp->argsoff]->bp, cmd, cmdlen);
d152 1
a152 1
	memmove(bp, SHELLECHO, SHELLOFFSET);
d219 1
d223 2
a224 9
			*p++ = '\0';
			n = p - bp;
			if (argv_prefix(sp,
			    bp + SHELLOFFSET, p, &bp, &blen, &len)) {
				rval = 1;
				goto err;
			}
			p = bp + n;
			len -= n;
d234 1
a237 6
#if defined(DEBUG) && 0
	TRACE(sp, "after shell: %d: {%s}\n", len, bp);
#endif

	rval = argv_exp3(sp, excp, p, len);

d344 1
a344 1
			memmove(p, exp->lastbcomm, tlen);
d357 1
a357 1
			memmove(p, t, tlen);
d369 1
a369 1
			memmove(p, t, tlen);
d500 1
a500 1
 * argv_prefix --
d505 1
a505 1
argv_prefix(sp, path, wp, bpp, blenp, lenp)
d507 2
a508 2
	char *path, *wp, **bpp;
	size_t *blenp, *lenp;
d510 1
d512 6
a517 3
	struct dirent *dp;
	size_t blen, clen, dlen, doffset, len, nlen;
	char *bp, *dname, *name, *p;
d519 1
a519 4
	/*
	 * Open the directory, set up the name and length for comparison,
	 * the prepended directory and length.
	 */
d521 1
a522 1
		dname = ".";
d527 1
a527 1
			dlen = 0;
d537 5
d546 10
d557 7
a563 37
	/* Local copies of the buffer variables. */
	bp = *bpp;
	blen = *blenp;

	/*
	 * We're passed a pointer to the name (after the echo command at
	 * the start of the buffer) and a pointer to the place to start
	 * writing.  Set a pointer to the start of the write area, and a
	 * value for the amount of space we have to write.
	 */
	p = wp;
	len = wp - bp;
	blen -= len;

	/*
	 * Read the directory, checking for files with a matching prefix.
	 *
	 * XXX
	 * We don't use the d_namlen field, it's not portable enough; we
	 * assume that d_name is nul terminated, instead.
	 */
	while ((dp = readdir(dirp)) != NULL) {
		clen = strlen(dp->d_name);
		if (nlen == 0 ||
		    (clen >= nlen && !memcmp(dp->d_name, name, nlen))) {
			if (blen < clen + dlen + 5) {
				doffset = dname - bp;
				ADD_SPACE_GOTO(sp, bp, *blenp,
				    *blenp * 2 + clen + dlen + 5);
				p = bp + len;
				blen = *blenp - len;
				if (dname == path)
					dname = bp + doffset;
			}
			if (dlen != 0) {
				memcpy(p, dname, dlen);
				p += dlen;
a564 8
				len += dlen + 1;
				blen -= dlen + 1;
			}
			memcpy(p, dp->d_name, clen);
			p += clen;
			*p++ = ' ';
			len += clen + 1;
			blen -= clen + 1;
d566 5
d572 1
a572 1
	(void)closedir(dirp);
d574 6
a579 6
	/*
	 * If we didn't find a match, complain that the expansion failed.  We
	 * can't know for certain that's the error, but it's a good guess, and
	 * it matches historic practice. 
	 */
	if (p == wp) {
d581 1
a581 1
alloc_err:	return (1);
d583 3
d587 9
a595 6
	/* Delete the final <space>, nul terminate the string. */
	*--p = '\0';
	*lenp = len - 1;
	*bpp = bp;		/* *blenp is already updated. */

	return (0);
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_argv.c	10.19 (Berkeley) 3/30/96";
d21 1
d33 3
a35 1
	       char *, size_t, char *, size_t *, char **, size_t *, int));
d189 2
d192 1
a192 1
			for (p = bp, n = len; n > 0; --n, ++p)
d196 1
a196 1
			for (p = bp, n = len; n > 0; --n, ++p)
d201 34
a234 1
	if (n > 0) {
d240 1
a240 3
	} else {
		p = bp + SHELLOFFSET;
		len -= SHELLOFFSET;
d511 110
d651 1
d731 1
d733 2
a734 3
		*--p = '\0';
	} else
		*p = '\0';
@


1.2
log
@new vi
@
text
@d275 1
a275 1
			if (IS_ESCAPE(sp, excp, *(u_char *)ap))
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)ex_argv.c	8.38 (Berkeley) 8/17/94";
a17 1
#include <sys/time.h>
a22 1
#include <signal.h>
a25 1
#include <termios.h>
d28 1
a28 6
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
d31 1
a31 1
static int argv_fexp __P((SCR *, EXCMDARG *,
d38 2
d42 1
a42 1
argv_init(sp, ep, excp)
d44 1
a44 2
	EXF *ep;
	EXCMDARG *excp;
d60 2
d64 1
a64 1
argv_exp0(sp, ep, excp, cmd, cmdlen)
d66 1
a66 2
	EXF *ep;
	EXCMDARG *excp;
d87 2
d91 1
a91 1
argv_exp1(sp, ep, excp, cmd, cmdlen, is_bang)
d93 1
a93 2
	EXF *ep;
	EXCMDARG *excp;
d121 2
a122 2
	(void)argv_exp0(sp, ep, excp, bp, len);
		
d131 2
d135 1
a135 1
argv_exp2(sp, ep, excp, cmd, cmdlen, is_bang)
d137 1
a137 2
	EXF *ep;
	EXCMDARG *excp;
a139 1
	int is_bang;
d157 1
a157 1
	if (argv_fexp(sp, excp, cmd, cmdlen, p, &len, &bp, &blen, is_bang)) {
d178 1
a178 1
	 * to be there.
d180 5
a184 11
	for (p = mp = O_STR(sp, O_META); *p != '\0'; ++p)
		if (isblank(*p) || isalnum(*p))
			break;
	if (*p != '\0') {
		for (p = bp, n = len; n > 0; --n, ++p)
			if (strchr(mp, *p) != NULL)
				break;
	} else
		for (p = bp, n = len; n > 0; --n, ++p)
			if (!isblank(*p) &&
			    !isalnum(*p) && strchr(mp, *p) != NULL)
d186 10
d211 1
a211 1
	rval = argv_exp3(sp, ep, excp, p, len);
d221 2
d225 1
a225 1
argv_exp3(sp, ep, excp, cmd, cmdlen)
d227 1
a227 2
	EXF *ep;
	EXCMDARG *excp;
d257 1
a257 1
			if (IS_ESCAPE(sp, ch) && cmdlen > 1) {
d275 1
a275 1
			if (IS_ESCAPE(sp, *(u_char *)ap))
d296 1
a296 1
	EXCMDARG *excp;
d314 1
a314 1
				    "No previous command to replace \"!\"");
d326 1
a326 1
				    "No filename to substitute for %%");
d339 1
a339 1
				    "No filename to substitute for #");
d355 2
a356 1
			if (cmdlen > 1 && (cmd[1] == '%' || cmd[1] == '#')) {
d406 1
a406 1
		memset(&exp->args[off], 0, INCREMENT * sizeof(ARGS *));
d447 2
d464 1
a464 1
			FREE(exp->args[off], sizeof(ARGS));
d466 1
a466 1
		FREE(exp->args, exp->argscnt * sizeof(ARGS *));
d485 1
d489 1
a489 1
	int ch, rval, output[2];
d492 6
a497 2
	bp = *bpp;
	blen = *blenp;
d505 3
d509 9
a517 5
	 * There are two different processes running through this code.
	 * They are named the utility and the parent. The utility reads
	 * from standard input and writes to the parent.  The parent reads
	 * from the utility and writes into the buffer.  The parent reads
	 * from output[0], and the utility writes to output[1].
d519 3
a521 1
	if (pipe(output) < 0) {
d525 1
a525 1
	if ((ifp = fdopen(output[0], "r")) == NULL) {
d531 2
a532 2
	 * Do the minimal amount of work possible, the shell is going
	 * to run briefly and then exit.  Hopefully.
a533 1
	SIGBLOCK(sp->gp);
a535 2
		SIGUNBLOCK(sp->gp);

d537 6
a542 2
err:		(void)close(output[0]);
		(void)close(output[1]);
d545 2
a546 6
		/* The utility has default signal behavior. */
		sig_end();

		/* Redirect stdout/stderr to the write end of the pipe. */
		(void)dup2(output[1], STDOUT_FILENO);
		(void)dup2(output[1], STDERR_FILENO);
d549 3
a551 2
		(void)close(output[0]);
		(void)close(output[1]);
d553 4
a556 1
		/* Assumes that all shells have -c. */
d558 1
a558 2
		msgq(sp, M_ERR,
		    "Error: execl: %s: %s", sh_path, strerror(errno));
d561 2
a562 4
		SIGUNBLOCK(sp->gp);

		/* Close the pipe end the parent won't use. */
		(void)close(output[1]);
a565 2
	rval = 0;

d567 1
a567 1
	 * Copy process output into a buffer.
d577 1
a577 1
			ADD_SPACE_GOTO(sp, bp, blen, *blenp * 2);
d589 21
d611 5
a615 5
	if (ferror(ifp)) {
		msgq(sp, M_ERR, "I/O error: %s", sh);
binc_err:	rval = 1;
	}
	(void)fclose(ifp);
d617 2
a618 1
	*bpp = bp;		/* *blenp is already updated. */
d620 1
a620 2
	/* Wait for the process. */
	return (proc_wait(sp, (long)pid, sh, 0) || rval);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
