head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.22
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.20
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.16
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.14
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.12
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.18
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.14
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.12
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.10
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.8
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.01.06.22.29.38;	author millert;	state Exp;
branches;
next	1.9;
commitid	RiORzAsItDrPYyBm;

1.9
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.8;
commitid	adBvXLg05bJxz6yx;

1.8
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.7;
commitid	06bi6U3x4gFFf2G1;

1.7
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.42;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.16.01.18.34;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.35.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove the msg_cat() function and adjust its former callers.
From Martijn van Duren
@
text
@/*	$OpenBSD: ex_bang.c,v 1.9 2016/01/06 22:28:52 millert Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"
#include "../vi/vi.h"

/*
 * ex_bang -- :[line [,line]] ! command
 *
 * Pass the rest of the line after the ! character to the program named by
 * the O_SHELL option.
 *
 * Historical vi did NOT do shell expansion on the arguments before passing
 * them, only file name expansion.  This means that the O_SHELL program got
 * "$t" as an argument if that is what the user entered.  Also, there's a
 * special expansion done for the bang command.  Any exclamation points in
 * the user's argument are replaced by the last, expanded ! command.
 *
 * There's some fairly amazing slop in this routine to make the different
 * ways of getting here display the right things.  It took a long time to
 * get it right (wrong?), so be careful.
 *
 * PUBLIC: int ex_bang(SCR *, EXCMD *);
 */
int
ex_bang(SCR *sp, EXCMD *cmdp)
{
	enum filtertype ftype;
	ARGS *ap;
	EX_PRIVATE *exp;
	MARK rm;
	recno_t lno;
	int rval;
	const char *msg;

	ap = cmdp->argv[0];
	if (ap->len == 0) {
		ex_emsg(sp, cmdp->cmd->usage, EXM_USAGE);
		return (1);
	}

	/* Set the "last bang command" remembered value. */
	exp = EXP(sp);
	if (exp->lastbcomm != NULL)
		free(exp->lastbcomm);
	if ((exp->lastbcomm = strdup(ap->bp)) == NULL) {
		msgq(sp, M_SYSERR, NULL);
		return (1);
	}

	/*
	 * If the command was modified by the expansion, it was historically
	 * redisplayed.
	 */
	if (F_ISSET(cmdp, E_MODIFY) && !F_ISSET(sp, SC_EX_SILENT)) {
		/*
		 * Display the command if modified.  Historic ex/vi displayed
		 * the command if it was modified due to file name and/or bang
		 * expansion.  If piping lines in vi, it would be immediately
		 * overwritten by any error or line change reporting.
		 */
		if (F_ISSET(sp, SC_VI))
			vs_update(sp, "!", ap->bp);
		else {
			(void)ex_printf(sp, "!%s\n", ap->bp);
			(void)ex_fflush(sp);
		}
	}

	/*
	 * If no addresses were specified, run the command.  If there's an
	 * underlying file, it's been modified and autowrite is set, write
	 * the file back.  If the file has been modified, autowrite is not
	 * set and the warn option is set, tell the user about the file.
	 */
	if (cmdp->addrcnt == 0) {
		msg = NULL;
		if (sp->ep != NULL && F_ISSET(sp->ep, F_MODIFIED)) {
			if (O_ISSET(sp, O_AUTOWRITE)) {
				if (file_aw(sp, FS_ALL))
					return (0);
			} else if (O_ISSET(sp, O_WARN) &&
			    !F_ISSET(sp, SC_EX_SILENT))
				msg = "File modified since last write.";
		}

		/* If we're still in a vi screen, move out explicitly. */
		(void)ex_exec_proc(sp,
		    cmdp, ap->bp, msg, !F_ISSET(sp, SC_EX | SC_SCR_EXWROTE));
	}

	/*
	 * If addresses were specified, pipe lines from the file through the
	 * command.
	 *
	 * Historically, vi lines were replaced by both the stdout and stderr
	 * lines of the command, but ex lines by only the stdout lines.  This
	 * makes no sense to me, so nvi makes it consistent for both, and
	 * matches vi's historic behavior.
	 */
	else {
		NEEDFILE(sp, cmdp);

		/* Autoprint is set historically, even if the command fails. */
		F_SET(cmdp, E_AUTOPRINT);

		/*
		 * !!!
		 * Historical vi permitted "!!" in an empty file.  When this
		 * happens, we arrive here with two addresses of 1,1 and a
		 * bad attitude.  The simple solution is to turn it into a
		 * FILTER_READ operation, with the exception that stdin isn't
		 * opened for the utility, and the cursor position isn't the
		 * same.  The only historic glitch (I think) is that we don't
		 * put an empty line into the default cut buffer, as historic
		 * vi did.  Imagine, if you can, my disappointment.
		 */
		ftype = FILTER_BANG;
		if (cmdp->addr1.lno == 1 && cmdp->addr2.lno == 1) {
			if (db_last(sp, &lno))
				return (1);
			if (lno == 0) {
				cmdp->addr1.lno = cmdp->addr2.lno = 0;
				ftype = FILTER_RBANG;
			}
		}
		rval = ex_filter(sp, cmdp,
		    &cmdp->addr1, &cmdp->addr2, &rm, ap->bp, ftype);

		/*
		 * If in vi mode, move to the first nonblank.
		 *
		 * !!!
		 * Historic vi wasn't consistent in this area -- if you used
		 * a forward motion it moved to the first nonblank, but if you
		 * did a backward motion it didn't.  And, if you followed a
		 * backward motion with a forward motion, it wouldn't move to
		 * the nonblank for either.  Going to the nonblank generally
		 * seems more useful and consistent, so we do it.
		 */
		sp->lno = rm.lno;
		if (F_ISSET(sp, SC_VI)) {
			sp->cno = 0;
			(void)nonblank(sp, sp->lno, &sp->cno);
		} else
			sp->cno = rm.cno;
	}

	/* Ex terminates with a bang, even if the command fails. */
	if (!F_ISSET(sp, SC_VI) && !F_ISSET(sp, SC_EX_SILENT))
		(void)ex_puts(sp, "!\n");

	/*
	 * XXX
	 * The ! commands never return an error, so that autoprint always
	 * happens in the ex parser.
	 */
	return (0);
}
@


1.9
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_bang.c,v 1.8 2014/11/12 04:28:41 bentley Exp $	*/
d106 1
a106 3
				msg = msg_cat(sp,
				    "File modified since last write.",
				    NULL);
@


1.8
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_bang.c,v 1.7 2009/10/27 23:59:47 deraadt Exp $	*/
d107 1
a107 1
				    "303|File modified since last write.",
@


1.7
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_bang.c,v 1.6 2006/01/08 21:05:40 miod Exp $	*/
d48 1
a48 3
ex_bang(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
@


1.6
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_bang.c,v 1.5 2002/02/16 21:27:57 millert Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_bang.c	10.33 (Berkeley) 9/23/96";
#endif /* not lint */
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_bang.c,v 1.4 2001/01/29 01:58:42 niklas Exp $	*/
d106 1
a106 1
		if (sp->ep != NULL && F_ISSET(sp->ep, F_MODIFIED))
d115 1
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
 * PUBLIC: int ex_bang __P((SCR *, EXCMD *));
@


1.3
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d1 2
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_bang.c	10.32 (Berkeley) 5/18/96";
d97 4
a100 4
	 * If no addresses were specified, run the command.  If the file has
	 * been modified and autowrite is set, write the file back.  If the
	 * file has been modified, autowrite is not set and the warn option is
	 * set, tell the user about the file.
d104 1
a104 1
		if (F_ISSET(sp->ep, F_MODIFIED))
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)ex_bang.c	8.35 (Berkeley) 8/17/94";
a22 1
#include <signal.h>
a25 1
#include <termios.h>
d28 2
a29 7
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
#include "../sex/sex_screen.h"
d46 2
d50 1
a50 1
ex_bang(sp, ep, cmdp)
d52 1
a52 2
	EXF *ep;
	EXCMDARG *cmdp;
a58 1
	size_t blen;
d60 1
a60 1
	char *bp, *msg;
d64 1
a64 1
		msgq(sp, M_ERR, "Usage: %s", cmdp->cmd->usage);
d68 1
a68 1
	/* Set the last bang command. */
d78 2
a79 4
	 * If the command was modified by the expansion, we redisplay it.
	 * Redisplaying it in vi mode is tricky, and handled separately
	 * in each case below.  If we're in ex mode, it's easy, so we just
	 * do it here.
d81 1
a81 6
	bp = NULL;
	if (F_ISSET(cmdp, E_MODIFY) && !F_ISSET(sp, S_EXSILENT)) {
		if (IN_EX_MODE(sp)) {
			(void)ex_printf(EXCOOKIE, "!%s\n", ap->bp);
			(void)ex_fflush(EXCOOKIE);
		}
d83 1
a83 1
		 * Vi: Display the command if modified.  Historic vi displayed
d85 2
a86 6
		 * expansion.  If piping lines, it was immediately overwritten
		 * by any error or line change reporting.  We don't the user to
		 * have to page through the responses, so we only post it until
		 * it's erased by something else.  Otherwise, pass it on to the
		 * ex_exec_proc routine to display after the screen has been
		 * cleaned up.
d88 5
a92 6
		if (IN_VI_MODE(sp)) {
			GET_SPACE_RET(sp, bp, blen, ap->len + 3);
			bp[0] = '!';
			memmove(bp + 1, ap->bp, ap->len);
			bp[ap->len + 1] = '\n';
			bp[ap->len + 2] = '\0';
d97 23
d124 3
a126 3
	 * lines of the command, but ex by only the stdout lines.  This makes
	 * no sense to me, so nvi makes it consistent for both, and matches
	 * vi's historic behavior.
d128 3
a130 1
	if (cmdp->addrcnt != 0) {
d132 1
a132 5
		F_SET(exp, EX_AUTOPRINT);

		/* Vi gets a busy message. */
		if (bp != NULL)
			(void)sp->s_busy(sp, bp);
d136 2
a137 2
		 * Historical vi permitted "!!" in an empty file.  When it
		 * happens, we get called with two addresses of 1,1 and a
d139 5
a143 3
		 * FILTER_READ operation, but that means that we don't put
		 * an empty line into the default cut buffer as did historic
		 * vi.  Tough.
d145 1
a145 1
		ftype = FILTER;
d147 1
a147 1
			if (file_lline(sp, ep, &lno))
d151 1
a151 1
				ftype = FILTER_READ;
d154 1
a154 1
		rval = filtercmd(sp, ep,
d166 1
a166 1
		 * seems more useful, so we do it.
d168 6
a173 44
		if (rval == 0) {
			sp->lno = rm.lno;
			if (IN_VI_MODE(sp)) {
				sp->cno = 0;
				(void)nonblank(sp, ep, sp->lno, &sp->cno);
			}
		}
		goto ret2;
	}

	/*
	 * If no addresses were specified, run the command.  If the file
	 * has been modified and autowrite is set, write the file back.
	 * If the file has been modified, autowrite is not set and the
	 * warn option is set, tell the user about the file.
	 */
	msg = NULL;
	if (F_ISSET(ep, F_MODIFIED))
		if (O_ISSET(sp, O_AUTOWRITE)) {
			if (file_write(sp, ep, NULL, NULL, NULL, FS_ALL)) {
				rval = 1;
				goto ret1;
			}
		} else if (O_ISSET(sp, O_WARN) && !F_ISSET(sp, S_EXSILENT))
			msg = "File modified since last write.\n";

	/* Run the command. */
	rval = ex_exec_proc(sp, ap->bp, bp, msg);

	/* Vi requires user permission to continue. */
	if (IN_VI_MODE(sp))
		F_SET(sp, S_CONTINUE);

ret2:	if (IN_EX_MODE(sp)) {
		/*
		 * Put ex error messages out so they aren't confused with
		 * the autoprint output.
		 */
		if (rval)
			(void)sex_refresh(sp, sp->ep);

		/* Ex terminates with a bang, even if the command fails. */
		if (!F_ISSET(sp, S_EXSILENT))
			(void)write(STDOUT_FILENO, "!\n", 2);
d176 3
a178 3
	/* Free the extra space. */
ret1:	if (bp != NULL)
		FREE_SPACE(sp, bp, blen);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
