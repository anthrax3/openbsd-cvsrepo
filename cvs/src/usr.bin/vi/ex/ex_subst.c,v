head	1.29;
access;
symbols
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.16
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.14
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.12
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.10
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.09.02.15.38.42;	author martijn;	state Exp;
branches;
next	1.28;
commitid	Jsd98nqNmZcnmXfN;

1.28
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.27;
commitid	01nAnartGL7onLD3;

1.27
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.26;
commitid	ruCZ2IKF0FB0ebCr;

1.26
date	2016.01.06.22.29.38;	author millert;	state Exp;
branches;
next	1.25;
commitid	RiORzAsItDrPYyBm;

1.25
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.24;
commitid	adBvXLg05bJxz6yx;

1.24
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.23;
commitid	gtDERb7QyXwKGs62;

1.23
date	2015.11.19.07.53.31;	author bentley;	state Exp;
branches;
next	1.22;
commitid	aNUlDSFtbBwW1Tdz;

1.22
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.20;
commitid	06bi6U3x4gFFf2G1;

1.20
date	2014.10.14.22.23.12;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	mpIoFH2QkbUBhYb5;

1.19
date	2014.09.09.14.10.35;	author millert;	state Exp;
branches;
next	1.18;
commitid	FGG0NDsEwamoGfhd;

1.18
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.27.18.24.06;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.08.21.05.40;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.17.19.42.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.29.01.58.44;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.11.26.22.49.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.08.24.19.15.25;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.08.24.18.49.24;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.17.17.19.05;	author michaels;	state Exp;
branches;
next	1.5;

1.5
date	96.08.23.13.18.18;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.38;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.56;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.36.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Fix the begin of word issue in vi(1).
Similar fix went in sed and ed.

Feedback and OK schwarze@@
@
text
@/*	$OpenBSD: ex_subst.c,v 1.28 2016/05/27 09:18:12 martijn Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"
#include "../vi/vi.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

#define	SUB_FIRST	0x01		/* The 'r' flag isn't reasonable. */
#define	SUB_MUSTSETR	0x02		/* The 'r' flag is required. */

static int re_conv(SCR *, char **, size_t *, int *);
static int re_sub(SCR *, char *, char **, size_t *, size_t *, regmatch_t [10]);
static int re_tag_conv(SCR *, char **, size_t *, int *);
static int s(SCR *, EXCMD *, char *, regex_t *, u_int);

/*
 * ex_s --
 *	[line [,line]] s[ubstitute] [[/;]pat[/;]/repl[/;] [cgr] [count] [#lp]]
 *
 *	Substitute on lines matching a pattern.
 *
 * PUBLIC: int ex_s(SCR *, EXCMD *);
 */
int
ex_s(SCR *sp, EXCMD *cmdp)
{
	regex_t *re;
	size_t blen, len;
	u_int flags;
	int delim;
	char *bp, *ptrn, *rep, *p, *t;

	/*
	 * Skip leading white space.
	 *
	 * !!!
	 * Historic vi allowed any non-alphanumeric to serve as the
	 * substitution command delimiter.
	 *
	 * !!!
	 * If the arguments are empty, it's the same as &, i.e. we
	 * repeat the last substitution.
	 */
	if (cmdp->argc == 0)
		goto subagain;
	for (p = cmdp->argv[0]->bp,
	    len = cmdp->argv[0]->len; len > 0; --len, ++p) {
		if (!isblank(*p))
			break;
	}
	if (len == 0)
subagain:	return (ex_subagain(sp, cmdp));

	delim = *p++;
	if (isalnum(delim) || delim == '\\')
		return (s(sp, cmdp, p, &sp->subre_c, SUB_MUSTSETR));

	/*
	 * !!!
	 * The full-blown substitute command reset the remembered
	 * state of the 'c' and 'g' suffices.
	 */
	sp->c_suffix = sp->g_suffix = 0;

	/*
	 * Get the pattern string, toss escaping characters.
	 *
	 * !!!
	 * Historic vi accepted any of the following forms:
	 *
	 *	:s/abc/def/		change "abc" to "def"
	 *	:s/abc/def		change "abc" to "def"
	 *	:s/abc/			delete "abc"
	 *	:s/abc			delete "abc"
	 *
	 * QUOTING NOTE:
	 *
	 * Only toss an escaping character if it escapes a delimiter.
	 * This means that "s/A/\\\\f" replaces "A" with "\\f".  It
	 * would be nice to be more regular, i.e. for each layer of
	 * escaping a single escaping character is removed, but that's
	 * not how the historic vi worked.
	 */
	for (ptrn = t = p;;) {
		if (p[0] == '\0' || p[0] == delim) {
			if (p[0] == delim)
				++p;
			/*
			 * !!!
			 * Nul terminate the pattern string -- it's passed
			 * to regcomp which doesn't understand anything else.
			 */
			*t = '\0';
			break;
		}
		if (p[0] == '\\') {
			if (p[1] == delim)
				++p;
			else if (p[1] == '\\')
				*t++ = *p++;
		}
		*t++ = *p++;
	}

	/*
	 * If the pattern string is empty, use the last RE (not just the
	 * last substitution RE).
	 */
	if (*ptrn == '\0') {
		if (sp->re == NULL) {
			ex_emsg(sp, NULL, EXM_NOPREVRE);
			return (1);
		}

		/* Re-compile the RE if necessary. */
		if (!F_ISSET(sp, SC_RE_SEARCH) && re_compile(sp,
		    sp->re, sp->re_len, NULL, NULL, &sp->re_c, RE_C_SEARCH))
			return (1);
		flags = 0;
	} else {
		/*
		 * !!!
		 * Compile the RE.  Historic practice is that substitutes set
		 * the search direction as well as both substitute and search
		 * RE's.  We compile the RE twice, as we don't want to bother
		 * ref counting the pattern string and (opaque) structure.
		 */
		if (re_compile(sp, ptrn, t - ptrn,
		    &sp->re, &sp->re_len, &sp->re_c, RE_C_SEARCH))
			return (1);
		if (re_compile(sp, ptrn, t - ptrn,
		    &sp->subre, &sp->subre_len, &sp->subre_c, RE_C_SUBST))
			return (1);
		
		flags = SUB_FIRST;
		sp->searchdir = FORWARD;
	}
	re = &sp->re_c;

	/*
	 * Get the replacement string.
	 *
	 * The special character & (\& if O_MAGIC not set) matches the
	 * entire RE.  No handling of & is required here, it's done by
	 * re_sub().
	 *
	 * The special character ~ (\~ if O_MAGIC not set) inserts the
	 * previous replacement string into this replacement string.
	 * Count ~'s to figure out how much space we need.  We could
	 * special case nonexistent last patterns or whether or not
	 * O_MAGIC is set, but it's probably not worth the effort.
	 *
	 * QUOTING NOTE:
	 *
	 * Only toss an escaping character if it escapes a delimiter or
	 * if O_MAGIC is set and it escapes a tilde.
	 *
	 * !!!
	 * If the entire replacement pattern is "%", then use the last
	 * replacement pattern.  This semantic was added to vi in System
	 * V and then percolated elsewhere, presumably around the time
	 * that it was added to their version of ed(1).
	 */
	if (p[0] == '\0' || p[0] == delim) {
		if (p[0] == delim)
			++p;
		if (sp->repl != NULL)
			free(sp->repl);
		sp->repl = NULL;
		sp->repl_len = 0;
	} else if (p[0] == '%' && (p[1] == '\0' || p[1] == delim))
		p += p[1] == delim ? 2 : 1;
	else {
		for (rep = p, len = 0;
		    p[0] != '\0' && p[0] != delim; ++p, ++len)
			if (p[0] == '~')
				len += sp->repl_len;
		GET_SPACE_RET(sp, bp, blen, len);
		for (t = bp, len = 0, p = rep;;) {
			if (p[0] == '\0' || p[0] == delim) {
				if (p[0] == delim)
					++p;
				break;
			}
			if (p[0] == '\\') {
				if (p[1] == delim)
					++p;
				else if (p[1] == '\\') {
					*t++ = *p++;
					++len;
				} else if (p[1] == '~') {
					++p;
					if (!O_ISSET(sp, O_MAGIC))
						goto tilde;
				}
			} else if (p[0] == '~' && O_ISSET(sp, O_MAGIC)) {
tilde:				++p;
				memcpy(t, sp->repl, sp->repl_len);
				t += sp->repl_len;
				len += sp->repl_len;
				continue;
			}
			*t++ = *p++;
			++len;
		}
		if ((sp->repl_len = len) != 0) {
			if (sp->repl != NULL)
				free(sp->repl);
			if ((sp->repl = malloc(len)) == NULL) {
				msgq(sp, M_SYSERR, NULL);
				FREE_SPACE(sp, bp, blen);
				return (1);
			}
			memcpy(sp->repl, bp, len);
		}
		FREE_SPACE(sp, bp, blen);
	}
	return (s(sp, cmdp, p, re, flags));
}

/*
 * ex_subagain --
 *	[line [,line]] & [cgr] [count] [#lp]]
 *
 *	Substitute using the last substitute RE and replacement pattern.
 *
 * PUBLIC: int ex_subagain(SCR *, EXCMD *);
 */
int
ex_subagain(SCR *sp, EXCMD *cmdp)
{
	if (sp->subre == NULL) {
		ex_emsg(sp, NULL, EXM_NOPREVRE);
		return (1);
	}
	if (!F_ISSET(sp, SC_RE_SUBST) && re_compile(sp,
	    sp->subre, sp->subre_len, NULL, NULL, &sp->subre_c, RE_C_SUBST))
		return (1);
	return (s(sp,
	    cmdp, cmdp->argc ? cmdp->argv[0]->bp : NULL, &sp->subre_c, 0));
}

/*
 * ex_subtilde --
 *	[line [,line]] ~ [cgr] [count] [#lp]]
 *
 *	Substitute using the last RE and last substitute replacement pattern.
 *
 * PUBLIC: int ex_subtilde(SCR *, EXCMD *);
 */
int
ex_subtilde(SCR *sp, EXCMD *cmdp)
{
	if (sp->re == NULL) {
		ex_emsg(sp, NULL, EXM_NOPREVRE);
		return (1);
	}
	if (!F_ISSET(sp, SC_RE_SEARCH) && re_compile(sp,
	    sp->re, sp->re_len, NULL, NULL, &sp->re_c, RE_C_SEARCH))
		return (1);
	return (s(sp,
	    cmdp, cmdp->argc ? cmdp->argv[0]->bp : NULL, &sp->re_c, 0));
}

/*
 * s --
 * Do the substitution.  This stuff is *really* tricky.  There are lots of
 * special cases, and general nastiness.  Don't mess with it unless you're
 * pretty confident.
 * 
 * The nasty part of the substitution is what happens when the replacement
 * string contains newlines.  It's a bit tricky -- consider the information
 * that has to be retained for "s/f\(o\)o/^M\1^M\1/".  The solution here is
 * to build a set of newline offsets which we use to break the line up later,
 * when the replacement is done.  Don't change it unless you're *damned*
 * confident.
 */
#define	NEEDNEWLINE(sp) {						\
	if ((sp)->newl_len == (sp)->newl_cnt) {				\
		(sp)->newl_len += 25;					\
		REALLOCARRAY((sp), (sp)->newl,				\
		    (sp)->newl_len, sizeof(size_t));			\
		if ((sp)->newl == NULL) {				\
			(sp)->newl_len = 0;				\
			return (1);					\
		}							\
	}								\
}

#define	BUILD(sp, l, len) {						\
	if (lbclen + (len) > lblen) {					\
		lblen += MAXIMUM(lbclen + (len), 256);			\
		REALLOC((sp), lb, lblen);				\
		if (lb == NULL) {					\
			lbclen = 0;					\
			return (1);					\
		}							\
	}								\
	memcpy(lb + lbclen, (l), (len));				\
	lbclen += (len);						\
}

#define	NEEDSP(sp, len, pnt) {						\
	if (lbclen + (len) > lblen) {					\
		lblen += MAXIMUM(lbclen + (len), 256);			\
		REALLOC((sp), lb, lblen);				\
		if (lb == NULL) {					\
			lbclen = 0;					\
			return (1);					\
		}							\
		(pnt) = lb + lbclen;					\
	}								\
}

static int
s(SCR *sp, EXCMD *cmdp, char *s, regex_t *re, u_int flags)
{
	EVENT ev;
	MARK from, to;
	TEXTH tiq;
	recno_t elno, lno, slno;
	regmatch_t match[10];
	size_t blen, cnt, last, lbclen, lblen, len, llen;
	size_t offset, saved_offset, scno;
	int lflag, nflag, pflag, rflag;
	int didsub, do_eol_match, eflags, nempty, eval;
	int linechanged, matched, quit, rval;
	unsigned long ul;
	char *bp, *lb;

	NEEDFILE(sp, cmdp);

	slno = sp->lno;
	scno = sp->cno;

	/*
	 * !!!
	 * Historically, the 'g' and 'c' suffices were always toggled as flags,
	 * so ":s/A/B/" was the same as ":s/A/B/ccgg".  If O_EDCOMPATIBLE was
	 * not set, they were initialized to 0 for all substitute commands.  If
	 * O_EDCOMPATIBLE was set, they were initialized to 0 only if the user
	 * specified substitute/replacement patterns (see ex_s()).
	 */
	if (!O_ISSET(sp, O_EDCOMPATIBLE))
		sp->c_suffix = sp->g_suffix = 0;

	/*
	 * Historic vi permitted the '#', 'l' and 'p' options in vi mode, but
	 * it only displayed the last change.  I'd disallow them, but they are
	 * useful in combination with the [v]global commands.  In the current
	 * model the problem is combining them with the 'c' flag -- the screen
	 * would have to flip back and forth between the confirm screen and the
	 * ex print screen, which would be pretty awful.  We do display all
	 * changes, though, for what that's worth.
	 *
	 * !!!
	 * Historic vi was fairly strict about the order of "options", the
	 * count, and "flags".  I'm somewhat fuzzy on the difference between
	 * options and flags, anyway, so this is a simpler approach, and we
	 * just take it them in whatever order the user gives them.  (The ex
	 * usage statement doesn't reflect this.)
	 */
	lflag = nflag = pflag = rflag = 0;
	if (s == NULL)
		goto noargs;
	for (lno = OOBLNO; *s != '\0'; ++s)
		switch (*s) {
		case ' ':
		case '\t':
			continue;
		case '+':
			++cmdp->flagoff;
			break;
		case '-':
			--cmdp->flagoff;
			break;
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			if (lno != OOBLNO)
				goto usage;
			errno = 0;
			if ((ul = strtoul(s, &s, 10)) >= UINT_MAX)
				errno = ERANGE;
			if (*s == '\0')		/* Loop increment correction. */
				--s;
			if (errno == ERANGE) {
				if (ul >= UINT_MAX)
					msgq(sp, M_ERR, "Count overflow");
				else
					msgq(sp, M_SYSERR, NULL);
				return (1);
			}
			lno = (recno_t)ul;
			/*
			 * In historic vi, the count was inclusive from the
			 * second address.
			 */
			cmdp->addr1.lno = cmdp->addr2.lno;
			cmdp->addr2.lno += lno - 1;
			if (!db_exist(sp, cmdp->addr2.lno) &&
			    db_last(sp, &cmdp->addr2.lno))
				return (1);
			break;
		case '#':
			nflag = 1;
			break;
		case 'c':
			sp->c_suffix = !sp->c_suffix;

			/* Ex text structure initialization. */
			if (F_ISSET(sp, SC_EX)) {
				memset(&tiq, 0, sizeof(TEXTH));
				TAILQ_INIT(&tiq);
			}
			break;
		case 'g':
			sp->g_suffix = !sp->g_suffix;
			break;
		case 'l':
			lflag = 1;
			break;
		case 'p':
			pflag = 1;
			break;
		case 'r':
			if (LF_ISSET(SUB_FIRST)) {
				msgq(sp, M_ERR,
		    "Regular expression specified; r flag meaningless");
				return (1);
			}
			if (!F_ISSET(sp, SC_RE_SEARCH)) {
				ex_emsg(sp, NULL, EXM_NOPREVRE);
				return (1);
			}
			rflag = 1;
			re = &sp->re_c;
			break;
		default:
			goto usage;
		}

	if (*s != '\0' || (!rflag && LF_ISSET(SUB_MUSTSETR))) {
usage:		ex_emsg(sp, cmdp->cmd->usage, EXM_USAGE);
		return (1);
	}

noargs:	if (F_ISSET(sp, SC_VI) && sp->c_suffix && (lflag || nflag || pflag)) {
		msgq(sp, M_ERR,
"The #, l and p flags may not be combined with the c flag in vi mode");
		return (1);
	}

	/*
	 * bp:		if interactive, line cache
	 * blen:	if interactive, line cache length
	 * lb:		build buffer pointer.
	 * lbclen:	current length of built buffer.
	 * lblen;	length of build buffer.
	 */
	bp = lb = NULL;
	blen = lbclen = lblen = 0;

	/* For each line... */
	for (matched = quit = 0, lno = cmdp->addr1.lno,
	    elno = cmdp->addr2.lno; !quit && lno <= elno; ++lno) {

		/* Someone's unhappy, time to stop. */
		if (INTERRUPTED(sp))
			break;

		/* Get the line. */
		if (db_get(sp, lno, DBG_FATAL, &s, &llen))
			goto err;

		/*
		 * Make a local copy if doing confirmation -- when calling
		 * the confirm routine we're likely to lose the cached copy.
		 */
		if (sp->c_suffix) {
			if (bp == NULL) {
				GET_SPACE_RET(sp, bp, blen, llen);
			} else
				ADD_SPACE_RET(sp, bp, blen, llen);
			memcpy(bp, s, llen);
			s = bp;
		}

		/* Start searching from the beginning. */
		offset = 0;
		len = llen;

		/* Reset the build buffer offset. */
		lbclen = 0;

		/* Reset empty match test variable. */
		nempty = -1;

		/*
		 * We don't want to have to do a setline if the line didn't
		 * change -- keep track of whether or not this line changed.
		 * If doing confirmations, don't want to keep setting the
		 * line if change is refused -- keep track of substitutions.
		 */
		didsub = linechanged = 0;

		/* New line, do an EOL match. */
		do_eol_match = 1;

		/* It's not nul terminated, but we pretend it is. */
		eflags = REG_STARTEND;

		/* The search area is from s + offset to the EOL.  */
nextmatch:	match[0].rm_so = offset;
		match[0].rm_eo = llen;

		/* Get the next match. */
		eval = regexec(re, (char *)s, 10, match, eflags);

		/*
		 * There wasn't a match or if there was an error, deal with
		 * it.  If there was a previous match in this line, resolve
		 * the changes into the database.  Otherwise, just move on.
		 */
		if (eval == REG_NOMATCH)
			goto endmatch;
		if (eval != 0) {
			re_error(sp, eval, re);
			goto err;
		}
		matched = 1;

		/* Only the first search can match an anchored expression. */
		eflags |= REG_NOTBOL;

		/*
		 * !!!
		 * It's possible to match 0-length strings -- for example, the
		 * command s;a*;X;, when matched against the string "aabb" will
		 * result in "XbXbX", i.e. the matches are "aa", the space
		 * between the b's and the space between the b's and the end of
		 * the string.  There is a similar space between the beginning
		 * of the string and the a's.  The rule that we use (because vi
		 * historically used it) is that any 0-length match, occurring
		 * immediately after a match, is ignored.  Otherwise, the above
		 * example would have resulted in "XXbXbX".  Another example is
		 * incorrectly using " *" to replace groups of spaces with one
		 * space.
		 *
		 * If the match is empty and at the same place as the end of the
		 * previous match, ignore the match and move forward.  If
		 * there's no more characters in the string, we were
		 * attempting to match after the last character, so quit.
		 */
		if (match[0].rm_so == nempty && match[0].rm_eo == nempty) {
			nempty = -1;
			if (len == 0)
				goto endmatch;
			BUILD(sp, s + offset, 1)
			++offset;
			--len;
			goto nextmatch;
		}

		/* Confirm change. */
		if (sp->c_suffix) {
			/*
			 * Set the cursor position for confirmation.  Note,
			 * if we matched on a '$', the cursor may be past
			 * the end of line.
			 */
			from.lno = to.lno = lno;
			from.cno = match[0].rm_so;
			to.cno = match[0].rm_eo;
			/*
			 * Both ex and vi have to correct for a change before
			 * the first character in the line.
			 */
			if (llen == 0)
				from.cno = to.cno = 0;
			if (F_ISSET(sp, SC_VI)) {
				/*
				 * Only vi has to correct for a change after
				 * the last character in the line.
				 *
				 * XXX
				 * It would be nice to change the vi code so
				 * that we could display a cursor past EOL.
				 */
				if (to.cno >= llen)
					to.cno = llen - 1;
				if (from.cno >= llen)
					from.cno = llen - 1;

				sp->lno = from.lno;
				sp->cno = from.cno;
				if (vs_refresh(sp, 1))
					goto err;

				vs_update(sp, "Confirm change? [n]", NULL);

				if (v_event_get(sp, &ev, 0, 0))
					goto err;
				switch (ev.e_event) {
				case E_CHARACTER:
					break;
				case E_EOF:
				case E_ERR:
				case E_INTERRUPT:
					goto lquit;
				default:
					v_event_err(sp, &ev);
					goto lquit;
				}
			} else {
				if (ex_print(sp, cmdp, &from, &to, 0) ||
				    ex_scprint(sp, &from, &to))
					goto lquit;
				if (ex_txt(sp, &tiq, 0, TXT_CR))
					goto err;
				ev.e_c = TAILQ_FIRST(&tiq)->lb[0];
			}

			switch (ev.e_c) {
			case CH_YES:
				break;
			default:
			case CH_NO:
				didsub = 0;
				BUILD(sp, s + offset, match[0].rm_eo - offset);
				goto skip;
			case CH_QUIT:
				/* Set the quit/interrupted flags. */
lquit:				quit = 1;
				F_SET(sp->gp, G_INTERRUPTED);

				/*
				 * Resolve any changes, then return to (and
				 * exit from) the main loop.
				 */
				goto endmatch;
			}
		}

		/*
		 * Set the cursor to the last position changed, converting
		 * from 1-based to 0-based.
		 */
		sp->lno = lno;
		sp->cno = match[0].rm_so;

		/* Copy the bytes before the match into the build buffer. */
		BUILD(sp, s + offset, match[0].rm_so - offset);

		/* Substitute the matching bytes. */
		didsub = 1;
		if (re_sub(sp, s, &lb, &lbclen, &lblen, match))
			goto err;

		/* Set the change flag so we know this line was modified. */
		linechanged = 1;

		/* Move past the matched bytes. */
skip:		offset = match[0].rm_eo;
		len = llen - match[0].rm_eo;

		/* A match cannot be followed by an empty pattern. */
		nempty = match[0].rm_eo;

		/*
		 * If doing a global change with confirmation, we have to
		 * update the screen.  The basic idea is to store the line
		 * so the screen update routines can find it, and restart.
		 */
		if (didsub && sp->c_suffix && sp->g_suffix) {
			/*
			 * The new search offset will be the end of the
			 * modified line.
			 */
			saved_offset = lbclen;

			/* Copy the rest of the line. */
			if (len)
				BUILD(sp, s + offset, len)

			/* Set the new offset. */
			offset = saved_offset;

			/* Store inserted lines, adjusting the build buffer. */
			last = 0;
			if (sp->newl_cnt) {
				for (cnt = 0;
				    cnt < sp->newl_cnt; ++cnt, ++lno, ++elno) {
					if (db_insert(sp, lno,
					    lb + last, sp->newl[cnt] - last))
						goto err;
					last = sp->newl[cnt] + 1;
					++sp->rptlines[L_ADDED];
				}
				lbclen -= last;
				offset -= last;
				sp->newl_cnt = 0;
			}

			/* Store and retrieve the line. */
			if (db_set(sp, lno, lb + last, lbclen))
				goto err;
			if (db_get(sp, lno, DBG_FATAL, &s, &llen))
				goto err;
			ADD_SPACE_RET(sp, bp, blen, llen)
			memcpy(bp, s, llen);
			s = bp;
			len = llen - offset;

			/* Restart the build. */
			lbclen = 0;
			BUILD(sp, s, offset);

			/*
			 * If we haven't already done the after-the-string
			 * match, do one.  Set REG_NOTEOL so the '$' pattern
			 * only matches once.
			 */
			if (!do_eol_match)
				goto endmatch;
			if (offset == len) {
				do_eol_match = 0;
				eflags |= REG_NOTEOL;
			}
			goto nextmatch;
		}

		/*
		 * If it's a global:
		 *
		 * If at the end of the string, do a test for the after
		 * the string match.  Set REG_NOTEOL so the '$' pattern
		 * only matches once.
		 */
		if (sp->g_suffix && do_eol_match) {
			if (len == 0) {
				do_eol_match = 0;
				eflags |= REG_NOTEOL;
			}
			goto nextmatch;
		}

endmatch:	if (!linechanged)
			continue;

		/* Copy any remaining bytes into the build buffer. */
		if (len)
			BUILD(sp, s + offset, len)

		/* Store inserted lines, adjusting the build buffer. */
		last = 0;
		if (sp->newl_cnt) {
			for (cnt = 0;
			    cnt < sp->newl_cnt; ++cnt, ++lno, ++elno) {
				if (db_insert(sp,
				    lno, lb + last, sp->newl[cnt] - last))
					goto err;
				last = sp->newl[cnt] + 1;
				++sp->rptlines[L_ADDED];
			}
			lbclen -= last;
			sp->newl_cnt = 0;
		}

		/* Store the changed line. */
		if (db_set(sp, lno, lb + last, lbclen))
			goto err;

		/* Update changed line counter. */
		if (sp->rptlchange != lno) {
			sp->rptlchange = lno;
			++sp->rptlines[L_CHANGED];
		}

		/*
		 * !!!
		 * Display as necessary.  Historic practice is to only
		 * display the last line of a line split into multiple
		 * lines.
		 */
		if (lflag || nflag || pflag) {
			from.lno = to.lno = lno;
			from.cno = to.cno = 0;
			if (lflag)
				(void)ex_print(sp, cmdp, &from, &to, E_C_LIST);
			if (nflag)
				(void)ex_print(sp, cmdp, &from, &to, E_C_HASH);
			if (pflag)
				(void)ex_print(sp, cmdp, &from, &to, E_C_PRINT);
		}
	}

	/*
	 * !!!
	 * Historically, vi attempted to leave the cursor at the same place if
	 * the substitution was done at the current cursor position.  Otherwise
	 * it moved it to the first non-blank of the last line changed.  There
	 * were some problems: for example, :s/$/foo/ with the cursor on the
	 * last character of the line left the cursor on the last character, or
	 * the & command with multiple occurrences of the matching string in the
	 * line usually left the cursor in a fairly random position.
	 *
	 * We try to do the same thing, with the exception that if the user is
	 * doing substitution with confirmation, we move to the last line about
	 * which the user was consulted, as opposed to the last line that they
	 * actually changed.  This prevents a screen flash if the user doesn't
	 * change many of the possible lines.
	 */
	if (!sp->c_suffix && (sp->lno != slno || sp->cno != scno)) {
		sp->cno = 0;
		(void)nonblank(sp, sp->lno, &sp->cno);
	}

	/*
	 * If not in a global command, and nothing matched, say so.
	 * Else, if none of the lines displayed, put something up.
	 */
	rval = 0;
	if (!matched) {
		if (!F_ISSET(sp, SC_EX_GLOBAL)) {
			msgq(sp, M_ERR, "No match found");
			goto err;
		}
	} else if (!lflag && !nflag && !pflag)
		F_SET(cmdp, E_AUTOPRINT);

	if (0) {
err:		rval = 1;
	}

	if (bp != NULL)
		FREE_SPACE(sp, bp, blen);
	if (lb != NULL)
		free(lb);
	return (rval);
}

/*
 * re_compile --
 *	Compile the RE.
 *
 * PUBLIC: int re_compile(SCR *,
 * PUBLIC:     char *, size_t, char **, size_t *, regex_t *, u_int);
 */
int
re_compile(SCR *sp, char *ptrn, size_t plen, char **ptrnp, size_t *lenp,
    regex_t *rep, u_int flags)
{
	size_t len;
	int reflags, replaced, rval;
	char *p;

	/* Set RE flags. */
	reflags = 0;
	if (!LF_ISSET(RE_C_TAG)) {
		if (O_ISSET(sp, O_EXTENDED))
			reflags |= REG_EXTENDED;
		if (O_ISSET(sp, O_IGNORECASE))
			reflags |= REG_ICASE;
		if (O_ISSET(sp, O_ICLOWER)) {
			for (p = ptrn, len = plen; len > 0; ++p, --len)
				if (isupper(*p))
					break;
			if (len == 0)
				reflags |= REG_ICASE;
		}
	}

	/* If we're replacing a saved value, clear the old one. */
	if (LF_ISSET(RE_C_SEARCH) && F_ISSET(sp, SC_RE_SEARCH)) {
		regfree(&sp->re_c);
		F_CLR(sp, SC_RE_SEARCH);
	}
	if (LF_ISSET(RE_C_SUBST) && F_ISSET(sp, SC_RE_SUBST)) {
		regfree(&sp->subre_c);
		F_CLR(sp, SC_RE_SUBST);
	}

	/*
	 * If we're saving the string, it's a pattern we haven't seen before,
	 * so convert the vi-style RE's to POSIX 1003.2 RE's.  Save a copy for
	 * later recompilation.   Free any previously saved value.
	 */
	if (ptrnp != NULL) {
		if (LF_ISSET(RE_C_TAG)) {
			if (re_tag_conv(sp, &ptrn, &plen, &replaced))
				return (1);
		} else
			if (re_conv(sp, &ptrn, &plen, &replaced))
				return (1);

		/* Discard previous pattern. */
		if (*ptrnp != NULL) {
			free(*ptrnp);
			*ptrnp = NULL;
		}
		if (lenp != NULL)
			*lenp = plen;

		/*
		 * Copy the string into allocated memory.
		 *
		 * XXX
		 * Regcomp isn't 8-bit clean, so the pattern is nul-terminated
		 * for now.  There's just no other solution.  
		 */
		MALLOC(sp, *ptrnp, plen + 1);
		if (*ptrnp != NULL) {
			memcpy(*ptrnp, ptrn, plen);
			(*ptrnp)[plen] = '\0';
		}

		/* Free up conversion-routine-allocated memory. */
		if (replaced)
			FREE_SPACE(sp, ptrn, 0);

		if (*ptrnp == NULL)
			return (1);

		ptrn = *ptrnp;
	}

	/*
	 * XXX
	 * Regcomp isn't 8-bit clean, so we just lost if the pattern
	 * contained a nul.  Bummer!
	 */
	if ((rval = regcomp(rep, ptrn, /* plen, */ reflags)) != 0) {
		if (!LF_ISSET(RE_C_SILENT))
			re_error(sp, rval, rep); 
		return (1);
	}

	if (LF_ISSET(RE_C_SEARCH))
		F_SET(sp, SC_RE_SEARCH);
	if (LF_ISSET(RE_C_SUBST))
		F_SET(sp, SC_RE_SUBST);

	return (0);
}

/*
 * re_conv --
 *	Convert vi's regular expressions into something that the
 *	the POSIX 1003.2 RE functions can handle.
 *
 * There are two conversions we make to make vi's RE's (specifically
 * the global, search, and substitute patterns) work with POSIX RE's.
 * We assume that \<ptrn\> does "word" searches, which is non-standard
 * but supported by most regexp libraries..
 *
 * 1: If O_MAGIC is not set, strip backslashes from the magic character
 *    set (.[*~) that have them, and add them to the ones that don't.
 * 2: If O_MAGIC is not set, the string "\~" is replaced with the text
 *    from the last substitute command's replacement string.  If O_MAGIC
 *    is set, it's the string "~".
 *
 * !!!/XXX
 * This doesn't exactly match the historic behavior of vi because we do
 * the ~ substitution before calling the RE engine, so magic characters
 * in the replacement string will be expanded by the RE engine, and they
 * weren't historically.  It's a bug.
 */
static int
re_conv(SCR *sp, char **ptrnp, size_t *plenp, int *replacedp)
{
	size_t blen, len, needlen;
	int magic;
	char *bp, *p, *t;

	/*
	 * First pass through, we figure out how much space we'll need.
	 * We do it in two passes, on the grounds that most of the time
	 * the user is doing a search and won't have magic characters.
	 * That way we can skip most of the memory allocation and copies.
	 */
	magic = 0;
	for (p = *ptrnp, len = *plenp, needlen = 0; len > 0; ++p, --len)
		switch (*p) {
		case '\\':
			if (len > 1) {
				--len;
				switch (*++p) {
				case '~':
					if (!O_ISSET(sp, O_MAGIC)) {
						magic = 1;
						needlen += sp->repl_len;
					}
					break;
				case '.':
				case '[':
				case '*':
					if (!O_ISSET(sp, O_MAGIC)) {
						magic = 1;
						needlen += 1;
					}
					break;
				default:
					needlen += 2;
				}
			} else
				needlen += 1;
			break;
		case '~':
			if (O_ISSET(sp, O_MAGIC)) {
				magic = 1;
				needlen += sp->repl_len;
			}
			break;
		case '.':
		case '[':
		case '*':
			if (!O_ISSET(sp, O_MAGIC)) {
				magic = 1;
				needlen += 2;
			}
			break;
		default:
			needlen += 1;
			break;
		}

	if (!magic) {
		*replacedp = 0;
		return (0);
	}

	/* Get enough memory to hold the final pattern. */
	*replacedp = 1;
	GET_SPACE_RET(sp, bp, blen, needlen);

	for (p = *ptrnp, len = *plenp, t = bp; len > 0; ++p, --len)
		switch (*p) {
		case '\\':
			if (len > 1) {
				--len;
				switch (*++p) {
				case '~':
					if (O_ISSET(sp, O_MAGIC))
						*t++ = '~';
					else {
						memcpy(t,
						    sp->repl, sp->repl_len);
						t += sp->repl_len;
					}
					break;
				case '.':
				case '[':
				case '*':
					if (O_ISSET(sp, O_MAGIC))
						*t++ = '\\';
					*t++ = *p;
					break;
				default:
					*t++ = '\\';
					*t++ = *p;
				}
			} else
				*t++ = '\\';
			break;
		case '~':
			if (O_ISSET(sp, O_MAGIC)) {
				memcpy(t, sp->repl, sp->repl_len);
				t += sp->repl_len;
			} else
				*t++ = '~';
			break;
		case '.':
		case '[':
		case '*':
			if (!O_ISSET(sp, O_MAGIC))
				*t++ = '\\';
			*t++ = *p;
			break;
		default:
			*t++ = *p;
			break;
		}

	*ptrnp = bp;
	*plenp = t - bp;
	return (0);
}

/*
 * re_tag_conv --
 *	Convert a tags search path into something that the POSIX
 *	1003.2 RE functions can handle.
 */
static int
re_tag_conv(SCR *sp, char **ptrnp, size_t *plenp, int *replacedp)
{
	size_t blen, len;
	int lastdollar;
	char *bp, *p, *t;

	len = *plenp;

	/* Max memory usage is 2 times the length of the string. */
	*replacedp = 1;
	GET_SPACE_RET(sp, bp, blen, len * 2);

	p = *ptrnp;
	t = bp;

	/* If the last character is a '/' or '?', we just strip it. */
	if (len > 0 && (p[len - 1] == '/' || p[len - 1] == '?'))
		--len;

	/* If the next-to-last or last character is a '$', it's magic. */
	if (len > 0 && p[len - 1] == '$') {
		--len;
		lastdollar = 1;
	} else
		lastdollar = 0;

	/* If the first character is a '/' or '?', we just strip it. */
	if (len > 0 && (p[0] == '/' || p[0] == '?')) {
		++p;
		--len;
	}

	/* If the first or second character is a '^', it's magic. */
	if (p[0] == '^') {
		*t++ = *p++;
		--len;
	}

	/*
	 * Escape every other magic character we can find, meanwhile stripping
	 * the backslashes ctags inserts when escaping the search delimiter
	 * characters.
	 */
	for (; len > 0; --len) {
		if (p[0] == '\\' && (p[1] == '/' || p[1] == '?')) {
			++p;
			--len;
		} else if (strchr("^.[]$*", p[0]))
			*t++ = '\\';
		*t++ = *p++;
		if (len == 0)
			break;
	}
	if (lastdollar)
		*t++ = '$';

	*ptrnp = bp;
	*plenp = t - bp;
	return (0);
}

/*
 * re_error --
 *	Report a regular expression error.
 *
 * PUBLIC: void re_error(SCR *, int, regex_t *);
 */
void
re_error(SCR *sp, int errcode, regex_t *preg)
{
	size_t s;
	char *oe;

	s = regerror(errcode, preg, "", 0);
	if ((oe = malloc(s)) == NULL)
		msgq(sp, M_SYSERR, NULL);
	else {
		(void)regerror(errcode, preg, oe, s);
		msgq(sp, M_ERR, "RE error: %s", oe);
		free(oe);
	}
}

/*
 * re_sub --
 * 	Do the substitution for a regular expression.
 */
static int
re_sub(SCR *sp, char *ip, char **lbp, size_t *lbclenp, size_t *lblenp,
    regmatch_t match[10])
{
	enum { C_NOTSET, C_LOWER, C_ONELOWER, C_ONEUPPER, C_UPPER } conv;
	size_t lbclen, lblen;		/* Local copies. */
	size_t mlen;			/* Match length. */
	size_t rpl;			/* Remaining replacement length. */
	char *rp;			/* Replacement pointer. */
	int ch;
	int no;				/* Match replacement offset. */
	char *p, *t;			/* Buffer pointers. */
	char *lb;			/* Local copies. */

	lb = *lbp;			/* Get local copies. */
	lbclen = *lbclenp;
	lblen = *lblenp;

	/*
	 * QUOTING NOTE:
	 *
	 * There are some special sequences that vi provides in the
	 * replacement patterns.
	 *	 & string the RE matched (\& if nomagic set)
	 *	\# n-th regular subexpression
	 *	\E end \U, \L conversion
	 *	\e end \U, \L conversion
	 *	\l convert the next character to lower-case
	 *	\L convert to lower-case, until \E, \e, or end of replacement
	 *	\u convert the next character to upper-case
	 *	\U convert to upper-case, until \E, \e, or end of replacement
	 *
	 * Otherwise, since this is the lowest level of replacement, discard
	 * all escaping characters.  This (hopefully) matches historic practice.
	 */
#define	OUTCH(ch, nltrans) {						\
	CHAR_T __ch = (ch);						\
	u_int __value = KEY_VAL(sp, __ch);				\
	if ((nltrans) && (__value == K_CR || __value == K_NL)) {	\
		NEEDNEWLINE(sp);					\
		sp->newl[sp->newl_cnt++] = lbclen;			\
	} else if (conv != C_NOTSET) {					\
		switch (conv) {						\
		case C_ONELOWER:					\
			conv = C_NOTSET;				\
			/* FALLTHROUGH */				\
		case C_LOWER:						\
			if (isupper(__ch))				\
				__ch = tolower(__ch);			\
			break;						\
		case C_ONEUPPER:					\
			conv = C_NOTSET;				\
			/* FALLTHROUGH */				\
		case C_UPPER:						\
			if (islower(__ch))				\
				__ch = toupper(__ch);			\
			break;						\
		default:						\
			abort();					\
		}							\
	}								\
	NEEDSP(sp, 1, p);						\
	*p++ = __ch;							\
	++lbclen;							\
}
	conv = C_NOTSET;
	for (rp = sp->repl, rpl = sp->repl_len, p = lb + lbclen; rpl--;) {
		switch (ch = *rp++) {
		case '&':
			if (O_ISSET(sp, O_MAGIC)) {
				no = 0;
				goto subzero;
			}
			break;
		case '\\':
			if (rpl == 0)
				break;
			--rpl;
			switch (ch = *rp) {
			case '&':
				++rp;
				if (!O_ISSET(sp, O_MAGIC)) {
					no = 0;
					goto subzero;
				}
				break;
			case '0': case '1': case '2': case '3': case '4':
			case '5': case '6': case '7': case '8': case '9':
				no = *rp++ - '0';
subzero:			if (match[no].rm_so == -1 ||
			    	    match[no].rm_eo == -1)
					break;
				mlen = match[no].rm_eo - match[no].rm_so;
				for (t = ip + match[no].rm_so; mlen--; ++t)
					OUTCH(*t, 0);
				continue;
			case 'e':
			case 'E':
				++rp;
				conv = C_NOTSET;
				continue;
			case 'l':
				++rp;
				conv = C_ONELOWER;
				continue;
			case 'L':
				++rp;
				conv = C_LOWER;
				continue;
			case 'u':
				++rp;
				conv = C_ONEUPPER;
				continue;
			case 'U':
				++rp;
				conv = C_UPPER;
				continue;
			default:
				++rp;
				break;
			}
		}
		OUTCH(ch, 1);
	}

	*lbp = lb;			/* Update caller's information. */
	*lbclenp = lbclen;
	*lblenp = lblen;
	return (0);
}
@


1.28
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.26 2016/01/06 22:29:38 millert Exp $	*/
d349 1
a349 1
	int didsub, do_eol_match, eflags, empty_ok, eval;
d518 2
a519 2
		/* Reset empty match flag. */
		empty_ok = 1;
d535 3
a537 9
		/*
		 * The search area is from s + offset to the EOL.
		 *
		 * Generally, match[0].rm_so is the offset of the start
		 * of the match from the start of the search, and offset
		 * is the offset of the start of the last search.
		 */
nextmatch:	match[0].rm_so = 0;
		match[0].rm_eo = len;
d540 1
a540 1
		eval = regexec(re, (char *)s + offset, 10, match, eflags);
d572 4
a575 5
		 * The way we do this is that if we just had a successful match,
		 * the starting offset does not skip characters, and the match
		 * is empty, ignore the match and move forward.  If there's no
		 * more characters in the string, we were attempting to match
		 * after the last character, so quit.
d577 2
a578 2
		if (!empty_ok && match[0].rm_so == 0 && match[0].rm_eo == 0) {
			empty_ok = 1;
d595 2
a596 2
			from.cno = match[0].rm_so + offset;
			to.cno = match[0].rm_eo + offset;
d652 1
a652 1
				BUILD(sp, s +offset, match[0].rm_eo);
d675 1
a675 1
		BUILD(sp, s + offset, match[0].rm_so);
d679 1
a679 1
		if (re_sub(sp, s + offset, &lb, &lbclen, &lblen, match))
d686 2
a687 2
skip:		offset += match[0].rm_eo;
		len -= match[0].rm_eo;
d690 1
a690 1
		empty_ok = 0;
@


1.27
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d1248 1
a1248 1
	char __ch = (ch);						\
@


1.26
log
@Remove the msg_cat() function and adjust its former callers.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.25 2016/01/06 22:28:52 millert Exp $	*/
d1248 1
a1248 1
	CHAR_T __ch = (ch);						\
@


1.25
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.24 2015/12/07 20:39:19 mmcc Exp $	*/
d629 1
a629 2
				vs_update(sp, msg_cat(sp,
				    "Confirm change? [n]", NULL), NULL);
@


1.24
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.23 2015/11/19 07:53:31 bentley Exp $	*/
d411 1
a411 1
					msgq(sp, M_ERR, "153|Count overflow");
d451 1
a451 1
		    "155|Regular expression specified; r flag meaningless");
d472 1
a472 1
"156|The #, l and p flags may not be combined with the c flag in vi mode");
d630 1
a630 1
				    "169|Confirm change? [n]", NULL), NULL);
d856 1
a856 1
			msgq(sp, M_ERR, "157|No match found");
@


1.23
log
@Remove cscope support in vi.

It makes no sense to keep support for a non-base tool in base, especially
for a feature that few if any people use.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.22 2015/01/16 06:40:14 deraadt Exp $	*/
d304 1
a304 1
		REALLOCARRAY((sp), (sp)->newl, size_t *,		\
d316 1
a316 1
		REALLOC((sp), lb, char *, lblen);			\
d329 1
a329 1
		REALLOC((sp), lb, char *, lblen);			\
d942 1
a942 1
		MALLOC(sp, *ptrnp, char *, plen + 1);
@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.21 2014/11/12 04:28:41 bentley Exp $	*/
a34 1
static int re_cscope_conv(SCR *, char **, size_t *, int *);
d890 1
a890 1
	if (!LF_ISSET(RE_C_CSCOPE | RE_C_TAG)) {
d920 1
a920 11
		if (LF_ISSET(RE_C_CSCOPE)) {
			if (re_cscope_conv(sp, &ptrn, &plen, &replaced))
				return (1);
			/*
			 * XXX
			 * Currently, the match-any-<blank> expression used in
			 * re_cscope_conv() requires extended RE's.  This may
			 * not be right or safe.
			 */
			reflags |= REG_EXTENDED;
		} else if (LF_ISSET(RE_C_TAG)) {
a1180 56

	*ptrnp = bp;
	*plenp = t - bp;
	return (0);
}

/*
 * re_cscope_conv --
 *	 Convert a cscope search path into something that the POSIX
 *      1003.2 RE functions can handle.
 */
static int
re_cscope_conv(SCR *sp, char **ptrnp, size_t *plenp, int *replacedp)
{
	size_t blen, len, nspaces;
	char *bp, *p, *t;

	/*
	 * Each space in the source line printed by cscope represents an
	 * arbitrary sequence of spaces, tabs, and comments.
	 */
#define	CSCOPE_RE_SPACE		"([ \t]|/\\*([^*]|\\*/)*\\*/)*"
	for (nspaces = 0, p = *ptrnp, len = *plenp; len > 0; ++p, --len)
		if (*p == ' ')
			++nspaces;

	/*
	 * Allocate plenty of space:
	 *	the string, plus potential escaping characters;
	 *	nspaces + 2 copies of CSCOPE_RE_SPACE;
	 *	^, $, nul terminator characters.
	 */
	*replacedp = 1;
	len = (p - *ptrnp) * 2 + (nspaces + 2) * sizeof(CSCOPE_RE_SPACE) + 3;
	GET_SPACE_RET(sp, bp, blen, len);

	p = *ptrnp;
	t = bp;

	*t++ = '^';
	memcpy(t, CSCOPE_RE_SPACE, sizeof(CSCOPE_RE_SPACE) - 1);
	t += sizeof(CSCOPE_RE_SPACE) - 1;

	for (len = *plenp; len > 0; ++p, --len)
		if (*p == ' ') {
			memcpy(t, CSCOPE_RE_SPACE, sizeof(CSCOPE_RE_SPACE) - 1);
			t += sizeof(CSCOPE_RE_SPACE) - 1;
		} else {
			if (strchr("\\^.[]$*+?()|{}", *p))
				*t++ = '\\';
			*t++ = *p;
		}

	memcpy(t, CSCOPE_RE_SPACE, sizeof(CSCOPE_RE_SPACE) - 1);
	t += sizeof(CSCOPE_RE_SPACE) - 1;
	*t++ = '$';
@


1.21
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.20 2014/10/14 22:23:12 deraadt Exp $	*/
a13 1
#include <sys/param.h>
d29 2
d316 1
a316 1
		lblen += MAX(lbclen + (len), 256);			\
d329 1
a329 1
		lblen += MAX(lbclen + (len), 256);			\
@


1.20
log
@create a REALLOCARRAY macro, and use it where it gives us overflow
protection for free
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.19 2014/09/09 14:10:35 millert Exp $	*/
d48 1
a48 3
ex_s(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d253 1
a253 3
ex_subagain(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d275 1
a275 3
ex_subtilde(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d339 1
a339 6
s(sp, cmdp, s, re, flags)
	SCR *sp;
	EXCMD *cmdp;
	char *s;
	regex_t *re;
	u_int flags;
d881 2
a882 6
re_compile(sp, ptrn, plen, ptrnp, lenp, rep, flags)
	SCR *sp;
	char *ptrn, **ptrnp;
	size_t plen, *lenp;
	regex_t *rep;
	u_int flags;
d1010 1
a1010 5
re_conv(sp, ptrnp, plenp, replacedp)
	SCR *sp;
	char **ptrnp;
	size_t *plenp;
	int *replacedp;
d1136 1
a1136 5
re_tag_conv(sp, ptrnp, plenp, replacedp)
	SCR *sp;
	char **ptrnp;
	size_t *plenp;
	int *replacedp;
d1203 1
a1203 5
re_cscope_conv(sp, ptrnp, plenp, replacedp)
	SCR *sp;
	char **ptrnp;
	size_t *plenp;
	int *replacedp;
d1260 1
a1260 4
re_error(sp, errcode, preg)
	SCR *sp;
	int errcode;
	regex_t *preg;
d1280 2
a1281 6
re_sub(sp, ip, lbp, lbclenp, lblenp, match)
	SCR *sp;
	char *ip;			/* Input line. */
	char **lbp;
	size_t *lbclenp, *lblenp;
	regmatch_t match[10];
@


1.19
log
@We no longer need to convert "\<" and "\>" to "[[:<:]]" and "[[:>:]]"
respectively now that the former is natively supported.  OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.18 2013/11/25 23:27:11 krw Exp $	*/
d310 2
a311 2
		REALLOC((sp), (sp)->newl, size_t *,			\
		    (sp)->newl_len * sizeof(size_t));			\
@


1.18
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.17 2009/10/27 23:59:47 deraadt Exp $	*/
d1007 1
a1007 1
 * There are three conversions we make to make vi's RE's (specifically
d1009 2
a1016 2
 * 3: The pattern \<ptrn\> does "word" searches, convert it to use the
 *    new RE escapes.
a1047 8
				case '<':
					magic = 1;
					needlen += sizeof(RE_WSTART);
					break;
				case '>':
					magic = 1;
					needlen += sizeof(RE_WSTOP);
					break;
a1101 10
				case '<':
					memcpy(t,
					    RE_WSTART, sizeof(RE_WSTART) - 1);
					t += sizeof(RE_WSTART) - 1;
					break;
				case '>':
					memcpy(t,
					    RE_WSTOP, sizeof(RE_WSTOP) - 1);
					t += sizeof(RE_WSTOP) - 1;
					break;
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.16 2007/03/27 18:24:06 otto Exp $	*/
d447 1
a447 1
				CIRCLEQ_INIT(&tiq);
d662 1
a662 1
				ev.e_c = CIRCLEQ_FIRST(&tiq)->lb[0];
@


1.16
log
@Catch OOB access for tag searches mathching lines ending with \
From patrick keshishian with a twist by me. ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.15 2006/04/22 03:09:15 ray Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_subst.c	10.37 (Berkeley) 9/15/96";
#endif /* not lint */
@


1.15
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.14 2006/01/08 21:05:40 miod Exp $	*/
d1231 2
@


1.14
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.13 2005/10/17 19:12:16 otto Exp $	*/
d363 1
a363 1
	int cflag, lflag, nflag, pflag, rflag;
d401 1
a401 1
	cflag = lflag = nflag = pflag = rflag = 0;
@


1.13
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.12 2002/02/17 19:42:34 millert Exp $	*/
d125 1
a125 1
		if (p[0] == '\\')
d130 1
d312 6
a317 6
	if (sp->newl_len == sp->newl_cnt) {				\
		sp->newl_len += 25;					\
		REALLOC(sp, sp->newl, size_t *,				\
		    sp->newl_len * sizeof(size_t));			\
		if (sp->newl == NULL) {					\
			sp->newl_len = 0;				\
d326 1
a326 1
		REALLOC(sp, lb, char *, lblen);				\
d332 2
a333 2
	memcpy(lb + lbclen, l, len);					\
	lbclen += len;							\
d339 1
a339 1
		REALLOC(sp, lb, char *, lblen);				\
d344 1
a344 1
		pnt = lb + lbclen;					\
d480 1
a480 1
	if (*s != '\0' || !rflag && LF_ISSET(SUB_MUSTSETR)) {
d1371 1
a1371 1
	if (nltrans && (__value == K_CR || __value == K_NL)) {		\
@


1.12
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.11 2002/02/16 21:27:57 millert Exp $	*/
d665 1
a665 1
				ev.e_c = tiq.cqh_first->lb[0];
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_subst.c,v 1.10 2001/01/29 01:58:44 niklas Exp $	*/
d39 1
a39 2
static int re_sub __P((SCR *,
		char *, char **, size_t *, size_t *, regmatch_t [10]));
d891 2
a892 2
 * PUBLIC: int re_compile __P((SCR *,
 * PUBLIC:     char *, size_t, char **, size_t *, regex_t *, u_int));
@


1.10
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 2
a38 2
static int re_conv __P((SCR *, char **, size_t *, int *));
static int re_cscope_conv __P((SCR *, char **, size_t *, int *));
d41 2
a42 2
static int re_tag_conv __P((SCR *, char **, size_t *, int *));
static int s __P((SCR *, EXCMD *, char *, regex_t *, u_int));
d50 1
a50 1
 * PUBLIC: int ex_s __P((SCR *, EXCMD *));
d256 1
a256 1
 * PUBLIC: int ex_subagain __P((SCR *, EXCMD *));
d280 1
a280 1
 * PUBLIC: int ex_subtilde __P((SCR *, EXCMD *));
d1304 1
a1304 1
 * PUBLIC: void re_error __P((SCR *, int, regex_t *));
@


1.9
log
@o Update README files etc. from nvi-1.79 so they have the correct info
o make port.h empty since we there is nothing we lack
o include <sys/param.h>, not <sys/types.h> in files that use MIN/MAX macros
o add perl api support since we have libperl (off by default)
@
text
@d1 2
@


1.8
log
@Check for >= UINT_MAX not > UINT_MAX
@
text
@d16 1
a16 1
#include <sys/types.h>
@


1.7
log
@64bit fix wrt strtoul(3).  Fix send to Keith.
@
text
@d418 1
a418 1
			if ((ul = strtoul(s, &s, 10)) > UINT_MAX)
d423 1
a423 1
				if (ul > UINT_MAX)
@


1.6
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d364 1
d418 2
a419 1
			lno = strtoul(s, &s, 10);
d423 1
a423 1
				if (lno == LONG_MAX)
a424 2
				else if (lno == LONG_MIN)
					msgq(sp, M_ERR, "154|Count underflow");
d429 1
@


1.5
log
@nvi 1.75
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_subst.c	10.36 (Berkeley) 8/20/96";
d225 1
a225 1
				memmove(t, sp->repl, sp->repl_len);
d241 1
a241 1
			memmove(sp->repl, bp, len);
d330 1
a330 1
	memmove(lb + lbclen, l, len);					\
d519 1
a519 1
			memmove(bp, s, llen);
d753 1
a753 1
			memmove(bp, s, llen);
@


1.4
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_subst.c	10.35 (Berkeley) 8/11/96";
d1222 1
a1222 2
		/* Ctags escapes the search delimiter characters. */
		if (p[0] == '\\' && (p[1] == '/' || p[1] == '?'))
d1224 2
a1225 1
		else if (strchr("^.[]$*", p[0]))
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_subst.c	10.32 (Berkeley) 6/30/96";
d94 1
a94 1
	 * Get the pattern string, toss escaped characters.
d106 1
a106 1
	 * Only toss an escape character if it escapes a delimiter.
d109 1
a109 1
	 * escaping a single escape character is removed, but that's
d182 1
a182 1
	 * Only toss an escape character if it escapes a delimiter or
d1211 1
a1211 1
	if (p[0] == '^')
d1213 2
d1283 1
a1283 1
			if (strchr("\\^.[]$*", *p))
d1363 1
a1363 1
	 * all escape characters.  This (hopefully) follows historic practice.
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_subst.c	10.30 (Berkeley) 5/16/96";
d35 2
a36 2
static int re_conv __P((SCR *, char **, int *));
static int re_cscope_conv __P((SCR *, char **, int *));
d39 1
a39 1
static int re_tag_conv __P((SCR *, char **, int *));
d142 3
a144 3
		/* Compile the RE if necessary. */
		if (!F_ISSET(sp, SC_RE_SEARCH) &&
		    re_compile(sp, sp->re, NULL, NULL, &sp->re_c, RE_C_SEARCH))
d155 2
a156 2
		if (re_compile(sp,
		    ptrn, &sp->re, &sp->re_len, &sp->re_c, RE_C_SEARCH))
d158 2
a159 2
		if (re_compile(sp,
		    ptrn, &sp->subre, &sp->subre_len, &sp->subre_c, RE_C_SUBST))
d265 2
a266 2
	if (!F_ISSET(sp, SC_RE_SUBST) &&
	    re_compile(sp, sp->subre, NULL, NULL, &sp->subre_c, RE_C_SUBST))
d289 2
a290 2
	if (!F_ISSET(sp, SC_RE_SEARCH) &&
	    re_compile(sp, sp->re, NULL, NULL, &sp->re_c, RE_C_SEARCH))
a357 1
	long llno;
d417 1
a417 1
			llno = strtoul(s, &s, 10);
a419 5
			lno = llno;
			if (llno != lno) {
				errno = ERANGE;
				llno = LONG_MAX;
			}
d421 1
a421 1
				if (llno == LONG_MAX)
d423 1
a423 1
				else if (llno == LONG_MIN)
d890 1
a890 1
 * PUBLIC:     char *, char **, size_t *, regex_t *, u_int));
d893 1
a893 1
re_compile(sp, ptrn, ptrnp, lenp, rep, flags)
d896 1
a896 1
	size_t *lenp;
d912 1
a912 1
			for (p = ptrn; *p != '\0'; ++p)
d915 1
a915 1
			if (*p == '\0')
a934 1
	replaced = 0;
a935 4
		if (*ptrnp != NULL) {
			free(*ptrnp);
			*ptrnp = NULL;
		}
d937 1
a937 1
			if (re_cscope_conv(sp, &ptrn, &replaced))
d947 1
a947 1
			if (re_tag_conv(sp, &ptrn, &replaced))
d950 1
a950 1
			if (re_conv(sp, &ptrn, &replaced))
d952 6
a957 1
		len = strlen(ptrn);
d959 20
a978 2
			*lenp = len;
		if ((*ptrnp = v_strdup(sp, ptrn, len)) == NULL)
d980 2
d984 6
a989 7
	rval = regcomp(rep, ptrn, reflags);

	/* Free up any allocated memory. */
	if (replaced)
		FREE_SPACE(sp, ptrn, 0);

	if (rval) {
d1026 1
a1026 1
re_conv(sp, ptrnp, replacedp)
d1029 1
d1032 1
a1032 1
	size_t blen, needlen;
d1040 1
a1040 1
	 * That way we can skip the malloc and memmove's.
d1042 2
a1043 1
	for (p = *ptrnp, magic = 0, needlen = 0; *p != '\0'; ++p)
d1046 4
a1049 11
			switch (*++p) {
			case '<':
				magic = 1;
				needlen += sizeof(RE_WSTART);
				break;
			case '>':
				magic = 1;
				needlen += sizeof(RE_WSTOP);
				break;
			case '~':
				if (!O_ISSET(sp, O_MAGIC)) {
d1051 3
a1053 7
					needlen += sp->repl_len;
				}
				break;
			case '.':
			case '[':
			case '*':
				if (!O_ISSET(sp, O_MAGIC)) {
d1055 18
a1072 1
					needlen += 1;
d1074 2
a1075 4
				break;
			default:
				needlen += 2;
			}
d1101 3
a1103 7
	/*
	 * Get enough memory to hold the final pattern.
	 *
	 * XXX
	 * It's nul-terminated, for now.
	 */
	GET_SPACE_RET(sp, bp, blen, needlen + 1);
d1105 1
a1105 1
	for (p = *ptrnp, t = bp; *p != '\0'; ++p)
d1108 32
a1139 15
			switch (*++p) {
			case '<':
				memmove(t, RE_WSTART, sizeof(RE_WSTART) - 1);
				t += sizeof(RE_WSTART) - 1;
				break;
			case '>':
				memmove(t, RE_WSTOP, sizeof(RE_WSTOP) - 1);
				t += sizeof(RE_WSTOP) - 1;
				break;
			case '~':
				if (O_ISSET(sp, O_MAGIC))
					*t++ = '~';
				else {
					memmove(t, sp->repl, sp->repl_len);
					t += sp->repl_len;
d1141 1
a1141 9
				break;
			case '.':
			case '[':
			case '*':
				if (O_ISSET(sp, O_MAGIC))
					*t++ = '\\';
				*t++ = *p;
				break;
			default:
a1142 2
				*t++ = *p;
			}
d1146 1
a1146 1
				memmove(t, sp->repl, sp->repl_len);
a1161 1
	*t = '\0';
d1164 1
a1164 1
	*replacedp = 1;
d1174 1
a1174 1
re_tag_conv(sp, ptrnp, replacedp)
d1177 1
d1184 1
a1184 3
	*replacedp = 0;

	len = strlen(p = *ptrnp);
d1187 1
d1190 1
d1193 7
a1199 6
	/* The last character is a '/' or '?', we just strip it. */
	if (p[len - 1] == '/' || p[len - 1] == '?')
		p[len - 1] = '\0';

	/* The next-to-last character is a '$', and it's magic. */
	if (p[len - 2] == '$') {
a1200 1
		p[len - 2] = '\0';
d1204 2
a1205 2
	/* The first character is a '/' or '?', we just strip it. */
	if (p[0] == '/' || p[0] == '?')
d1207 2
d1210 1
a1210 1
	/* The second character is a '^', and it's magic. */
d1215 2
a1216 2
	 * Escape every other magic character we can find, stripping the
	 * backslashes ctags inserts to escape the search delimiter
d1219 1
a1219 1
	while (p[0]) {
a1228 1
	*t++ = '\0';
d1231 1
a1231 1
	*replacedp = 1;
d1241 1
a1241 1
re_cscope_conv(sp, ptrnp, replacedp)
d1244 1
d1248 1
a1248 1
	char *bp, *p, *re;
d1255 1
a1255 1
	for (nspaces = 0, p = *ptrnp; *p != '\0'; ++p)
d1261 3
a1263 3
	 *	the string, plus potential escaping characters
	 *	nspaces + 2 copies of CSCOPE_RE_SPACE
	 *	^, $, nul terminator characters
d1265 1
d1269 11
a1279 9
	p = bp;
	*p++ = '^';
	memcpy(p, CSCOPE_RE_SPACE, sizeof(CSCOPE_RE_SPACE) - 1);
	p += sizeof(CSCOPE_RE_SPACE) - 1;

	for (re = *ptrnp; *re != '\0'; ++re)
		if (*re == ' ') {
			memcpy(p, CSCOPE_RE_SPACE, sizeof(CSCOPE_RE_SPACE) - 1);
			p += sizeof(CSCOPE_RE_SPACE) - 1;
d1281 3
a1283 3
			if (strchr("\\^.[]$*", *re))
				*p++ = '\\';
			*p++ = *re;
d1286 3
a1288 4
	memcpy(p, CSCOPE_RE_SPACE, sizeof(CSCOPE_RE_SPACE) - 1);
	p += sizeof(CSCOPE_RE_SPACE) - 1;
	*p++ = '$';
	*p = '\0';
d1291 1
a1291 1
	*replacedp = 1;
d1363 1
a1363 1
#define	OUTCH(ch) {							\
d1366 1
a1366 1
	if (__value == K_CR || __value == K_NL) {			\
d1422 1
a1422 1
					OUTCH(*t);
d1450 1
a1450 1
		OUTCH(ch);
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)ex_subst.c	8.59 (Berkeley) 8/17/94";
a23 1
#include <signal.h>
a26 1
#include <termios.h>
d29 2
a30 6
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
d35 6
a40 4
static __inline int	regsub __P((SCR *, char *,
			    char **, size_t *, size_t *, regmatch_t [10]));
static int		substitute __P((SCR *, EXF *,
			    EXCMDARG *, char *, regex_t *, u_int));
d43 1
a43 1
 * ex_substitute --
d47 2
d51 1
a51 1
ex_substitute(sp, ep, cmdp)
d53 1
a53 2
	EXF *ep;
	EXCMDARG *cmdp;
d55 1
a55 1
	regex_t *re, lre;
d58 1
a58 1
	int delim, eval, reflags, replaced;
d72 2
d80 2
a81 1
		return (ex_subagain(sp, ep, cmdp));
d83 2
a84 3
	if (isalnum(delim))
		return (substitute(sp, ep,
		    cmdp, p, &sp->subre, SUB_MUSTSETR));
d92 1
a92 1
	
d137 2
a138 2
		if (!F_ISSET(sp, S_SRE_SET)) {
			msgq(sp, M_ERR, "No previous regular expression");
d141 5
a145 1
		re = &sp->sre;
a147 23
		/* Set RE flags. */
		reflags = 0;
		if (O_ISSET(sp, O_EXTENDED))
			reflags |= REG_EXTENDED;
		if (O_ISSET(sp, O_IGNORECASE))
			reflags |= REG_ICASE;

		/* Convert vi-style RE's to POSIX 1003.2 RE's. */
		if (re_conv(sp, &ptrn, &replaced))
			return (1);

		/* Compile the RE. */
		eval = regcomp(&lre, (char *)ptrn, reflags);

		/* Free up any allocated memory. */
		if (replaced)
			FREE_SPACE(sp, ptrn, 0);

		if (eval) {
			re_error(sp, eval, &lre);
			return (1);
		}

a148 2
		 * Set saved RE.
		 *
d150 4
a153 2
		 * Historic practice is that substitutes set the search
		 * direction as well as both substitute and search RE's.
d155 8
a163 7
		sp->sre = lre;
		F_SET(sp, S_SRE_SET);
		sp->subre = lre;
		F_SET(sp, S_SUBRE_SET);

		re = &lre;
		flags = SUB_FIRST;
d165 1
d172 1
a172 1
	 * regsub().
d195 1
a195 1
			FREE(sp->repl, sp->repl_len);
d245 1
a245 1
	return (substitute(sp, ep, cmdp, p, re, flags));
d253 2
d257 1
a257 1
ex_subagain(sp, ep, cmdp)
d259 1
a259 2
	EXF *ep;
	EXCMDARG *cmdp;
d261 2
a262 2
	if (!F_ISSET(sp, S_SUBRE_SET)) {
		msgq(sp, M_ERR, "No previous regular expression");
d265 5
a269 1
	return (substitute(sp, ep, cmdp, cmdp->argv[0]->bp, &sp->subre, 0));
d277 2
d281 1
a281 1
ex_subtilde(sp, ep, cmdp)
d283 1
a283 2
	EXF *ep;
	EXCMDARG *cmdp;
d285 2
a286 2
	if (!F_ISSET(sp, S_SRE_SET)) {
		msgq(sp, M_ERR, "No previous regular expression");
d289 5
a293 1
	return (substitute(sp, ep, cmdp, cmdp->argv[0]->bp, &sp->sre, 0));
d297 5
d306 1
a306 1
 * when the replacement is done.  Don't change it unless you're pretty damned
a345 6
/*
 * substitute --
 *	Do the substitution.  This stuff is *really* tricky.  There are
 *	lots of special cases, and general nastiness.  Don't mess with it
 * 	unless you're pretty confident.
 */
d347 1
a347 1
substitute(sp, ep, cmdp, s, re, flags)
d349 1
a349 2
	EXF *ep;
	EXCMDARG *cmdp;
d354 1
d356 3
a358 2
	recno_t elno;
	long lno;
d360 2
a361 1
	size_t blen, cnt, last, lbclen, lblen, len, llen, offset, saved_offset;
d367 5
d378 1
a378 1
	 * specified substitute/replacement patterns (see ex_substitute()).
d400 2
d418 1
a418 1
			lno = strtoul(s, &s, 10);
d421 5
d427 4
a430 4
				if (lno == LONG_MAX)
					msgq(sp, M_ERR, "Count overflow");
				else if (lno == LONG_MIN)
					msgq(sp, M_ERR, "Count underflow");
d441 3
d450 6
d469 1
a469 1
		    "Regular expression specified; r flag meaningless");
d472 2
a473 3
			if (!F_ISSET(sp, S_SRE_SET)) {
				msgq(sp, M_ERR,
				    "No previous regular expression");
d477 1
a477 1
			re = &sp->sre;
d484 1
a484 1
usage:		msgq(sp, M_ERR, "Usage: %s", cmdp->cmd->usage);
d488 1
a488 1
	if (IN_VI_MODE(sp) && sp->c_suffix && (lflag || nflag || pflag)) {
d490 1
a490 1
	"The #, l and p flags may not be combined with the c flag in vi mode");
d509 1
a509 3
		if (INTERRUPTED(sp)) {
			if (!F_ISSET(sp, S_GLOBAL))
				msgq(sp, M_INFO, "Interrupted");
a510 1
		}
d513 2
a514 4
		if ((s = file_gline(sp, ep, lno, &llen)) == NULL) {
			GETLINE_ERR(sp, lno);
			goto ret1;
		}
d575 1
a575 1
			goto ret1;
a617 5
			 *
			 * XXX
			 * We may want to "fix" this in the confirm routine,
			 * if the confirm routine should be able to display
			 * a cursor past EOL.
d621 5
a625 1
			to.cno = match[0].rm_eo;
d628 9
a636 1
			else {
d641 29
d671 3
a673 2
			switch (sp->s_confirm(sp, ep, &from, &to)) {
			case CONF_YES:
d675 2
a676 1
			case CONF_NO:
d680 4
a683 7
			case CONF_QUIT:
				/* Set the quit flag. */
				quit = 1;

				/* If interruptible, pass the info back. */
				if (F_ISSET(sp, S_INTERRUPTIBLE))
					F_SET(sp, S_INTERRUPTED);
d686 2
a687 2
				 * If any changes, resolve them, otherwise
				 * return to the main loop.
d693 7
d705 2
a706 2
		if (regsub(sp, s + offset, &lb, &lbclen, &lblen, match))
			goto ret1;
d742 1
a742 1
					if (file_iline(sp, ep, lno,
d744 1
a744 1
						goto ret1;
d754 4
a757 6
			if (file_sline(sp, ep, lno, lb + last, lbclen))
				goto ret1;
			if ((s = file_gline(sp, ep, lno, &llen)) == NULL) {
				GETLINE_ERR(sp, lno);
				goto ret1;
			}
d808 1
a808 1
				if (file_iline(sp, ep,
d810 1
a810 1
					goto ret1;
d819 2
a820 2
		if (file_sline(sp, ep, lno, lb + last, lbclen))
			goto ret1;
d838 1
a838 1
				ex_print(sp, ep, &from, &to, E_F_LIST);
d840 1
a840 1
				ex_print(sp, ep, &from, &to, E_F_HASH);
d842 1
a842 1
				ex_print(sp, ep, &from, &to, E_F_PRINT);
a843 10

		if (!sp->c_suffix)
			sp->lno = lno;

		/*
		 * !!!
		 * Move the cursor to the last line changed.
		 */
		if (!sp->c_suffix)
			sp->lno = lno;
d848 7
a854 1
	 * Move the cursor to the first non-blank of the last line change.
d856 5
a860 3
	 * XXX
	 * This is NOT backward compatible with historic vi, which always
	 * moved to the last line actually changed.
d862 1
a862 1
	if (!sp->c_suffix) {
d864 1
a864 1
		(void)nonblank(sp, ep, sp->lno, &sp->cno);
d871 1
d873 4
a876 2
		if (!F_ISSET(sp, S_GLOBAL))
			msgq(sp, M_INFO, "No match found");
d878 1
a878 1
		F_SET(EXP(sp), EX_AUTOPRINT);
a879 1
	rval = 0;
d881 1
a881 1
ret1:		rval = 1;
d892 404
a1295 1
 * regsub --
d1298 2
a1299 2
static __inline int
regsub(sp, ip, lbp, lbclenp, lblenp, match)
d1337 1
a1337 1
#define	ADDCH(ch) {							\
d1396 1
a1396 1
					ADDCH(*t);
d1424 1
a1424 1
		ADDCH(ch);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
