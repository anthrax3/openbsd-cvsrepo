head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.18
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.14
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.12
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.10
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.15;
commitid	01nAnartGL7onLD3;

1.15
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.14;
commitid	ruCZ2IKF0FB0ebCr;

1.14
date	2016.01.20.08.43.27;	author bentley;	state Exp;
branches;
next	1.13;
commitid	etzsUqpfZbRGvPEg;

1.13
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.12;
commitid	06bi6U3x4gFFf2G1;

1.12
date	2014.07.10.20.33.42;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	WDTqciNSEVIXS5FL;

1.11
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.08.21.06.38;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.01.58.45;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.07.27.22.28.18;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.01.18.37;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.09.17.17.19.07;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.15.57;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.36.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: ex_txt.c,v 1.14 2016/01/20 08:43:27 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../common/common.h"
#include "../vi/vi.h"

/*
 * !!!
 * The backslash characters was special when it preceded a newline as part of
 * a substitution replacement pattern.  For example, the input ":a\<cr>" would
 * failed immediately with an error, as the <cr> wasn't part of a substitution
 * replacement pattern.  This implies a frightening integration of the editor
 * and the parser and/or the RE engine.  There's no way I'm going to reproduce
 * those semantics.
 *
 * So, if backslashes are special, this code inserts the backslash and the next
 * character into the string, without regard for the character or the command
 * being entered.  Since "\<cr>" was illegal historically (except for the one
 * special case), and the command will fail eventually, no historical scripts
 * should break (presuming they didn't depend on the failure mode itself or the
 * characters remaining when failure occurred.
 */

static int	txt_dent(SCR *, TEXT *);
static void	txt_prompt(SCR *, TEXT *, CHAR_T, u_int32_t);

/*
 * ex_txt --
 *	Get lines from the terminal for ex.
 *
 * PUBLIC: int ex_txt(SCR *, TEXTH *, CHAR_T, u_int32_t);
 */
int
ex_txt(SCR *sp, TEXTH *tiqh, CHAR_T prompt, u_int32_t flags)
{
	EVENT ev;
	GS *gp;
	TEXT ait, *ntp, *tp;
	carat_t carat_st;
	size_t cnt;
	int rval;

	rval = 0;

	/*
	 * Get a TEXT structure with some initial buffer space, reusing the
	 * last one if it's big enough.  (All TEXT bookkeeping fields default
	 * to 0 -- text_init() handles this.)
	 */
	if (!TAILQ_EMPTY(tiqh)) {
		tp = TAILQ_FIRST(tiqh);
		if (TAILQ_NEXT(tp, q) || tp->lb_len < 32) {
			text_lfree(tiqh);
			goto newtp;
		}
		tp->len = 0;
	} else {
newtp:		if ((tp = text_init(sp, NULL, 0, 32)) == NULL)
			goto err;
		TAILQ_INSERT_HEAD(tiqh, tp, q);
	}

	/* Set the starting line number. */
	tp->lno = sp->lno + 1;

	/*
	 * If it's a terminal, set up autoindent, put out the prompt, and
	 * set it up so we know we were suspended.  Otherwise, turn off
	 * the autoindent flag, as that requires less special casing below.
	 *
	 * XXX
	 * Historic practice is that ^Z suspended command mode (but, because
	 * it ran in cooked mode, it was unaffected by the autowrite option.)
	 * On restart, any "current" input was discarded, whether in insert
	 * mode or not, and ex was in command mode.  This code matches historic
	 * practice, but not 'cause it's easier.
	 */
	gp = sp->gp;
	if (F_ISSET(gp, G_SCRIPTED))
		LF_CLR(TXT_AUTOINDENT);
	else {
		if (LF_ISSET(TXT_AUTOINDENT)) {
			LF_SET(TXT_EOFCHAR);
			if (v_txt_auto(sp, sp->lno, NULL, 0, tp))
				goto err;
		}
		txt_prompt(sp, tp, prompt, flags);
	}

	for (carat_st = C_NOTSET;;) {
		if (v_event_get(sp, &ev, 0, 0))
			goto err;

		/* Deal with all non-character events. */
		switch (ev.e_event) {
		case E_CHARACTER:
			break;
		case E_ERR:
			goto err;
		case E_REPAINT:
		case E_WRESIZE:
			continue;
		case E_EOF:
			rval = 1;
			/* FALLTHROUGH */
		case E_INTERRUPT:
			/*
			 * Handle EOF/SIGINT events by discarding partially
			 * entered text and returning.  EOF returns failure,
			 * E_INTERRUPT returns success.
			 */
			goto notlast;
		default:
			v_event_err(sp, &ev);
			goto notlast;
		}

		/*
		 * Deal with character events.
		 *
		 * Check to see if the character fits into the input buffer.
		 * (Use tp->len, ignore overwrite and non-printable chars.)
		 */
		BINC_GOTO(sp, tp->lb, tp->lb_len, tp->len + 1);

		switch (ev.e_value) {
		case K_CR:
			/*
			 * !!!
			 * Historically, <carriage-return>'s in the command
			 * weren't special, so the ex parser would return an
			 * unknown command error message.  However, if they
			 * terminated the command if they were in a map.  I'm
			 * pretty sure this still isn't right, but it handles
			 * what I've seen so far.
			 */
			if (!F_ISSET(&ev.e_ch, CH_MAPPED))
				goto ins_ch;
			/* FALLTHROUGH */
		case K_NL:
			/*
			 * '\' can escape <carriage-return>/<newline>.  We
			 * don't discard the backslash because we need it
			 * to get the <newline> through the ex parser.
			 */
			if (LF_ISSET(TXT_BACKSLASH) &&
			    tp->len != 0 && tp->lb[tp->len - 1] == '\\')
				goto ins_ch;

			/*
			 * CR returns from the ex command line.
			 *
			 * XXX
			 * Terminate with a nul, needed by filter.
			 */
			if (LF_ISSET(TXT_CR)) {
				tp->lb[tp->len] = '\0';
				goto done;
			}

			/*
			 * '.' may terminate text input mode; free the current
			 * TEXT.
			 */
			if (LF_ISSET(TXT_DOTTERM) && tp->len == tp->ai + 1 &&
			    tp->lb[tp->len - 1] == '.') {
notlast:			TAILQ_REMOVE(tiqh, tp, q);
				text_free(tp);
				goto done;
			}

			/* Set up bookkeeping for the new line. */
			if ((ntp = text_init(sp, NULL, 0, 32)) == NULL)
				goto err;
			ntp->lno = tp->lno + 1;

			/*
			 * Reset the autoindent line value.  0^D keeps the ai
			 * line from changing, ^D changes the level, even if
			 * there were no characters in the old line.  Note, if
			 * using the current tp structure, use the cursor as
			 * the length, the autoindent characters may have been
			 * erased.
			 */
			if (LF_ISSET(TXT_AUTOINDENT)) {
				if (carat_st == C_NOCHANGE) {
					if (v_txt_auto(sp,
					    OOBLNO, &ait, ait.ai, ntp))
						goto err;
					free(ait.lb);
				} else
					if (v_txt_auto(sp,
					    OOBLNO, tp, tp->len, ntp))
						goto err;
				carat_st = C_NOTSET;
			}
			txt_prompt(sp, ntp, prompt, flags);

			/*
			 * Swap old and new TEXT's, and insert the new TEXT
			 * into the queue.
			 */
			tp = ntp;
			TAILQ_INSERT_TAIL(tiqh, tp, q);
			break;
		case K_CARAT:			/* Delete autoindent chars. */
			if (tp->len <= tp->ai && LF_ISSET(TXT_AUTOINDENT))
				carat_st = C_CARATSET;
			goto ins_ch;
		case K_ZERO:			/* Delete autoindent chars. */
			if (tp->len <= tp->ai && LF_ISSET(TXT_AUTOINDENT))
				carat_st = C_ZEROSET;
			goto ins_ch;
		case K_CNTRLD:			/* Delete autoindent char. */
			/*
			 * !!!
			 * Historically, the ^D command took (but then ignored)
			 * a count.  For simplicity, we don't return it unless
			 * it's the first character entered.  The check for len
			 * equal to 0 is okay, TXT_AUTOINDENT won't be set.
			 */
			if (LF_ISSET(TXT_CNTRLD)) {
				for (cnt = 0; cnt < tp->len; ++cnt)
					if (!isblank(tp->lb[cnt]))
						break;
				if (cnt == tp->len) {
					tp->len = 1;
					tp->lb[0] = ev.e_c;
					tp->lb[1] = '\0';

					/*
					 * Put out a line separator, in case
					 * the command fails.
					 */
					(void)putchar('\n');
					goto done;
				}
			}

			/*
			 * POSIX 1003.1b-1993, paragraph 7.1.1.9, states that
			 * the EOF characters are discarded if there are other
			 * characters to process in the line, i.e. if the EOF
			 * is not the first character in the line.  For this
			 * reason, historic ex discarded the EOF characters,
			 * even if occurring in the middle of the input line.
			 * We match that historic practice.
			 *
			 * !!!
			 * The test for discarding in the middle of the line is
			 * done in the switch, because the CARAT forms are N+1,
			 * not N.
			 *
			 * !!!
			 * There's considerable magic to make the terminal code
			 * return the EOF character at all.  See that code for
			 * details.
			 */
			if (!LF_ISSET(TXT_AUTOINDENT) || tp->len == 0)
				continue;
			switch (carat_st) {
			case C_CARATSET:		/* ^^D */
				if (tp->len > tp->ai + 1)
					continue;

				/* Save the ai string for later. */
				ait.lb = NULL;
				ait.lb_len = 0;
				BINC_GOTO(sp, ait.lb, ait.lb_len, tp->ai);
				memcpy(ait.lb, tp->lb, tp->ai);
				ait.ai = ait.len = tp->ai;

				carat_st = C_NOCHANGE;
				goto leftmargin;
			case C_ZEROSET:			/* 0^D */
				if (tp->len > tp->ai + 1)
					continue;

				carat_st = C_NOTSET;
leftmargin:			(void)gp->scr_ex_adjust(sp, EX_TERM_CE);
				tp->ai = tp->len = 0;
				break;
			case C_NOTSET:			/* ^D */
				if (tp->len > tp->ai)
					continue;

				if (txt_dent(sp, tp))
					goto err;
				break;
			default:
				abort();
			}

			/* Clear and redisplay the line. */
			(void)gp->scr_ex_adjust(sp, EX_TERM_CE);
			txt_prompt(sp, tp, prompt, flags);
			break;
		default:
			/*
			 * See the TXT_BEAUTIFY comment in vi/v_txt_ev.c.
			 *
			 * Silently eliminate any iscntrl() character that was
			 * not already handled specially, except for <tab> and
			 * <ff>.
			 */
ins_ch:			if (LF_ISSET(TXT_BEAUTIFY) && iscntrl(ev.e_c) &&
			    ev.e_value != K_FORMFEED && ev.e_value != K_TAB)
				break;

			tp->lb[tp->len++] = ev.e_c;
			break;
		}
	}
	/* NOTREACHED */

done:	return (rval);

err:	
alloc_err:
	return (1);
}

/*
 * txt_prompt --
 *	Display the ex prompt, line number, ai characters.  Characters had
 *	better be printable by the terminal driver, but that's its problem,
 *	not ours.
 */
static void
txt_prompt(SCR *sp, TEXT *tp, CHAR_T prompt, u_int32_t flags)
{
	/* Display the prompt. */
	if (LF_ISSET(TXT_PROMPT))
		(void)printf("%c", prompt);

	/* Display the line number. */
	if (LF_ISSET(TXT_NUMBER) && O_ISSET(sp, O_NUMBER))
		(void)printf("%6lu  ", (u_long)tp->lno);

	/* Print out autoindent string. */
	if (LF_ISSET(TXT_AUTOINDENT))
		(void)printf("%.*s", (int)tp->ai, tp->lb);
	(void)fflush(stdout);
}

/*
 * txt_dent --
 *	Handle ^D outdents.
 *
 * Ex version of vi/v_ntext.c:txt_dent().  See that code for the (usual)
 * ranting and raving.  This is a fair bit simpler as ^T isn't special.
 */
static int
txt_dent(SCR *sp, TEXT *tp)
{
	u_long sw, ts;
	size_t cno, off, scno, spaces, tabs;

	ts = O_VAL(sp, O_TABSTOP);
	sw = O_VAL(sp, O_SHIFTWIDTH);

	/* Get the current screen column. */
	for (off = scno = 0; off < tp->len; ++off)
		if (tp->lb[off] == '\t')
			scno += COL_OFF(scno, ts);
		else
			++scno;

	/* Get the previous shiftwidth column. */
	cno = scno--;
	scno -= scno % sw;

	/*
	 * Since we don't know what comes before the character(s) being
	 * deleted, we have to resolve the autoindent characters .  The
	 * example is a <tab>, which doesn't take up a full shiftwidth
	 * number of columns because it's preceded by <space>s.  This is
	 * easy to get if the user sets shiftwidth to a value less than
	 * tabstop, and then uses ^T to indent, and ^D to outdent.
	 *
	 * Count up spaces/tabs needed to get to the target.
	 */
	for (cno = 0, tabs = 0; cno + COL_OFF(cno, ts) <= scno; ++tabs)
		cno += COL_OFF(cno, ts);
	spaces = scno - cno;

	/* Make sure there's enough room. */
	BINC_RET(sp, tp->lb, tp->lb_len, tabs + spaces + 1);

	/* Adjust the final ai character count. */
	tp->ai = tabs + spaces;

	/* Enter the replacement characters. */
	for (tp->len = 0; tabs > 0; --tabs)
		tp->lb[tp->len++] = '\t';
	for (; spaces > 0; --spaces)
		tp->lb[tp->len++] = ' ';
	return (0);
}
@


1.15
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d45 1
a45 1
static void	txt_prompt(SCR *, TEXT *, char, u_int32_t);
d51 1
a51 1
 * PUBLIC: int ex_txt(SCR *, TEXTH *, char, u_int32_t);
d54 1
a54 1
ex_txt(SCR *sp, TEXTH *tiqh, char prompt, u_int32_t flags)
d350 1
a350 1
txt_prompt(SCR *sp, TEXT *tp, char prompt, u_int32_t flags)
@


1.14
log
@Remove ARG_CHAR_T, a relic from when the code was written K&R style.

ok millert@@ schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_txt.c,v 1.13 2014/11/12 04:28:41 bentley Exp $	*/
d45 1
a45 1
static void	txt_prompt(SCR *, TEXT *, CHAR_T, u_int32_t);
d51 1
a51 1
 * PUBLIC: int ex_txt(SCR *, TEXTH *, CHAR_T, u_int32_t);
d54 1
a54 1
ex_txt(SCR *sp, TEXTH *tiqh, CHAR_T prompt, u_int32_t flags)
d350 1
a350 1
txt_prompt(SCR *sp, TEXT *tp, CHAR_T prompt, u_int32_t flags)
@


1.13
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_txt.c,v 1.12 2014/07/10 20:33:42 deraadt Exp $	*/
d45 1
a45 1
static void	txt_prompt(SCR *, TEXT *, ARG_CHAR_T, u_int32_t);
d51 1
a51 1
 * PUBLIC: int ex_txt(SCR *, TEXTH *, ARG_CHAR_T, u_int32_t);
d54 1
a54 1
ex_txt(SCR *sp, TEXTH *tiqh, ARG_CHAR_T prompt, u_int32_t flags)
d350 1
a350 1
txt_prompt(SCR *sp, TEXT *tp, ARG_CHAR_T prompt, u_int32_t flags)
@


1.12
log
@add missing include file to bring in protos
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_txt.c,v 1.11 2013/11/25 23:27:11 krw Exp $	*/
d54 1
a54 5
ex_txt(sp, tiqh, prompt, flags)
	SCR *sp;
	TEXTH *tiqh;
	ARG_CHAR_T prompt;
	u_int32_t flags;
d350 1
a350 5
txt_prompt(sp, tp, prompt, flags)
	SCR *sp;
	TEXT *tp;
	ARG_CHAR_T prompt;
	u_int32_t flags;
d374 1
a374 3
txt_dent(sp, tp)
	SCR *sp;
	TEXT *tp;
@


1.11
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_txt.c,v 1.10 2009/10/27 23:59:47 deraadt Exp $	*/
d25 1
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_txt.c,v 1.9 2006/01/08 21:06:38 miod Exp $	*/
d73 3
a75 3
	if (CIRCLEQ_FIRST(tiqh) != CIRCLEQ_END(tiqh)) {
		tp = CIRCLEQ_FIRST(tiqh);
		if (CIRCLEQ_NEXT(tp, q) != CIRCLEQ_END(tiqh) || tp->lb_len < 32) {
d83 1
a83 1
		CIRCLEQ_INSERT_HEAD(tiqh, tp, q);
d190 1
a190 1
notlast:			CIRCLEQ_REMOVE(tiqh, tp, q);
d227 1
a227 1
			CIRCLEQ_INSERT_TAIL(tiqh, tp, q);
@


1.9
log
@Appease gcc 3 and the C gods by fixing a couple of undefined statements;
from Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_txt.c,v 1.8 2005/10/17 19:12:16 otto Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_txt.c	10.17 (Berkeley) 10/10/96";
#endif /* not lint */
@


1.8
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_txt.c,v 1.7 2002/02/16 21:27:57 millert Exp $	*/
d403 2
a404 2
	cno = scno;
	scno -= --scno % sw;
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_txt.c,v 1.6 2001/01/29 01:58:45 niklas Exp $	*/
d77 3
a79 3
	if (tiqh->cqh_first != (void *)tiqh) {
		tp = tiqh->cqh_first;
		if (tp->q.cqe_next != (void *)tiqh || tp->lb_len < 32) {
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 2
a48 2
static int	txt_dent __P((SCR *, TEXT *));
static void	txt_prompt __P((SCR *, TEXT *, ARG_CHAR_T, u_int32_t));
d54 1
a54 1
 * PUBLIC: int ex_txt __P((SCR *, TEXTH *, ARG_CHAR_T, u_int32_t));
@


1.5
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.4
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_txt.c	10.16 (Berkeley) 9/24/96";
d167 3
a169 2
			 * '\' can escape <carriage-return>/<newline>.  Toss
			 * the backslash.
d172 1
a172 2
			    tp->len != 0 && tp->lb[tp->len - 1] == '\\') {
				--tp->len;
a173 1
			}
@


1.3
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_txt.c	10.15 (Berkeley) 9/15/96";
d104 3
a106 1
	if (F_ISSET(gp, G_STDIN_TTY)) {
d113 1
a113 2
	} else
		LF_CLR(TXT_AUTOINDENT);
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_txt.c	10.14 (Berkeley) 6/30/96";
d295 1
a295 1
				memmove(ait.lb, tp->lb, tp->ai);
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_txt.c	10.13 (Berkeley) 3/6/96";
d125 1
@
