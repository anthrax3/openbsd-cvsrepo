head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.18
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.14
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.12
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.10
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.8
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.16
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.14
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.12
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.13;
commitid	01nAnartGL7onLD3;

1.13
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.12;
commitid	ruCZ2IKF0FB0ebCr;

1.12
date	2016.01.06.22.29.38;	author millert;	state Exp;
branches;
next	1.11;
commitid	RiORzAsItDrPYyBm;

1.11
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.10;
commitid	adBvXLg05bJxz6yx;

1.10
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.9;
commitid	06bi6U3x4gFFf2G1;

1.9
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.41;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.07.27.22.28.16;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.50;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.35.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: ex_append.c,v 1.12 2016/01/06 22:29:38 millert Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "../common/common.h"

enum which {APPEND, CHANGE, INSERT};

static int ex_aci(SCR *, EXCMD *, enum which);

/*
 * ex_append -- :[line] a[ppend][!]
 *	Append one or more lines of new text after the specified line,
 *	or the current line if no address is specified.
 *
 * PUBLIC: int ex_append(SCR *, EXCMD *);
 */
int
ex_append(SCR *sp, EXCMD *cmdp)
{
	return (ex_aci(sp, cmdp, APPEND));
}

/*
 * ex_change -- :[line[,line]] c[hange][!] [count]
 *	Change one or more lines to the input text.
 *
 * PUBLIC: int ex_change(SCR *, EXCMD *);
 */
int
ex_change(SCR *sp, EXCMD *cmdp)
{
	return (ex_aci(sp, cmdp, CHANGE));
}

/*
 * ex_insert -- :[line] i[nsert][!]
 *	Insert one or more lines of new text before the specified line,
 *	or the current line if no address is specified.
 *
 * PUBLIC: int ex_insert(SCR *, EXCMD *);
 */
int
ex_insert(SCR *sp, EXCMD *cmdp)
{
	return (ex_aci(sp, cmdp, INSERT));
}

/*
 * ex_aci --
 *	Append, change, insert in ex.
 */
static int
ex_aci(SCR *sp, EXCMD *cmdp, enum which cmd)
{
	CHAR_T *p, *t;
	GS *gp;
	TEXT *tp;
	TEXTH tiq;
	recno_t cnt, lno;
	size_t len;
	u_int32_t flags;
	int need_newline;

	gp = sp->gp;
	NEEDFILE(sp, cmdp);

	/*
	 * If doing a change, replace lines for as long as possible.  Then,
	 * append more lines or delete remaining lines.  Changes to an empty
	 * file are appends, inserts are the same as appends to the previous
	 * line.
	 *
	 * !!!
	 * Set the address to which we'll append.  We set sp->lno to this
	 * address as well so that autoindent works correctly when get text
	 * from the user.
	 */
	lno = cmdp->addr1.lno;
	sp->lno = lno;
	if ((cmd == CHANGE || cmd == INSERT) && lno != 0)
		--lno;

	/*
	 * !!!
	 * If the file isn't empty, cut changes into the unnamed buffer.
	 */
	if (cmd == CHANGE && cmdp->addr1.lno != 0 &&
	    (cut(sp, NULL, &cmdp->addr1, &cmdp->addr2, CUT_LINEMODE) ||
	    del(sp, &cmdp->addr1, &cmdp->addr2, 1)))
		return (1);

	/*
	 * !!!
	 * Anything that was left after the command separator becomes part
	 * of the inserted text.  Apparently, it was common usage to enter:
	 *
	 *	:g/pattern/append|stuff1
	 *
	 * and append the line of text "stuff1" to the lines containing the
	 * pattern.  It was also historically legal to enter:
	 *
	 *	:append|stuff1
	 *	stuff2
	 *	.
	 *
	 * and the text on the ex command line would be appended as well as
	 * the text inserted after it.  There was an historic bug however,
	 * that the user had to enter *two* terminating lines (the '.' lines)
	 * to terminate text input mode, in this case.  This whole thing
	 * could be taken too far, however.  Entering:
	 *
	 *	:append|stuff1\
	 *	stuff2
	 *	stuff3
	 *	.
	 *
	 * i.e. mixing and matching the forms confused the historic vi, and,
	 * not only did it take two terminating lines to terminate text input
	 * mode, but the trailing backslashes were retained on the input.  We
	 * match historic practice except that we discard the backslashes.
	 *
	 * Input lines specified on the ex command line lines are separated by
	 * <newline>s.  If there is a trailing delimiter an empty line was
	 * inserted.  There may also be a leading delimiter, which is ignored
	 * unless it's also a trailing delimiter.  It is possible to encounter
	 * a termination line, i.e. a single '.', in a global command, but not
	 * necessary if the text insert command was the last of the global
	 * commands.
	 */
	if (cmdp->save_cmdlen != 0) {
		for (p = cmdp->save_cmd,
		    len = cmdp->save_cmdlen; len > 0; p = t) {
			for (t = p; len > 0 && t[0] != '\n'; ++t, --len);
			if (t != p || len == 0) {
				if (F_ISSET(sp, SC_EX_GLOBAL) &&
				    t - p == 1 && p[0] == '.') {
					++t;
					if (len > 0)
						--len;
					break;
				}
				if (db_append(sp, 1, lno++, p, t - p))
					return (1);
			}
			if (len != 0) {
				++t;
				if (--len == 0 &&
				    db_append(sp, 1, lno++, "", 0))
					return (1);
			}
		}
		/*
		 * If there's any remaining text, we're in a global, and
		 * there's more command to parse.
		 *
		 * !!!
		 * We depend on the fact that non-global commands will eat the
		 * rest of the command line as text input, and before getting
		 * any text input from the user.  Otherwise, we'd have to save
		 * off the command text before or during the call to the text
		 * input function below.
		 */
		if (len != 0)
			cmdp->save_cmd = t;
		cmdp->save_cmdlen = len;
	}

	if (F_ISSET(sp, SC_EX_GLOBAL)) {
		if ((sp->lno = lno) == 0 && db_exist(sp, 1))
			sp->lno = 1;
		return (0);
	}

	/*
	 * If not in a global command, read from the terminal.
	 *
	 * If this code is called by vi, we want to reset the terminal and use
	 * ex's line get routine.  It actually works fine if we use vi's get
	 * routine, but it doesn't look as nice.  Maybe if we had a separate
	 * window or something, but getting a line at a time looks awkward.
	 * However, depending on the screen that we're using, that may not
	 * be possible.
	 */
	if (F_ISSET(sp, SC_VI)) {
		if (gp->scr_screen(sp, SC_EX)) {
			ex_emsg(sp, cmdp->cmd->name, EXM_NOCANON);
			return (1);
		}

		/* If we're still in the vi screen, move out explicitly. */
		need_newline = !F_ISSET(sp, SC_SCR_EXWROTE);
		F_SET(sp, SC_SCR_EX | SC_SCR_EXWROTE);
		if (need_newline)
			(void)ex_puts(sp, "\n");

		/*
		 * !!!
		 * Users of historical versions of vi sometimes get confused
		 * when they enter append mode, and can't seem to get out of
		 * it.  Give them an informational message.
		 */
		(void)ex_puts(sp, "Entering ex input mode.\n");
		(void)ex_fflush(sp);
	}

	/*
	 * Set input flags; the ! flag turns off autoindent for append,
	 * change and insert.
	 */
	LF_INIT(TXT_DOTTERM | TXT_NUMBER);
	if (!FL_ISSET(cmdp->iflags, E_C_FORCE) && O_ISSET(sp, O_AUTOINDENT))
		LF_SET(TXT_AUTOINDENT);
	if (O_ISSET(sp, O_BEAUTIFY))
		LF_SET(TXT_BEAUTIFY);

	/*
	 * This code can't use the common screen TEXTH structure (sp->tiq),
	 * as it may already be in use, e.g. ":append|s/abc/ABC/" would fail
	 * as we are only halfway through the text when the append code fires.
	 * Use a local structure instead.  (The ex code would have to use a
	 * local structure except that we're guaranteed to finish remaining
	 * characters in the common TEXTH structure when they were inserted
	 * into the file, above.)
	 */
	memset(&tiq, 0, sizeof(TEXTH));
	TAILQ_INIT(&tiq);

	if (ex_txt(sp, &tiq, 0, flags))
		return (1);

	cnt = 0;
	TAILQ_FOREACH(tp, &tiq, q) {
		if (db_append(sp, 1, lno++, tp->lb, tp->len))
			return (1);
		cnt++;
	}

	/*
	 * Set sp->lno to the final line number value (correcting for a
	 * possible 0 value) as that's historically correct for the final
	 * line value, whether or not the user entered any text.
	 */
	if ((sp->lno = lno) == 0 && db_exist(sp, 1))
		sp->lno = 1;

	return (0);
}
@


1.13
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d74 1
a74 1
	char *p, *t;
@


1.12
log
@Remove the msg_cat() function and adjust its former callers.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_append.c,v 1.11 2016/01/06 22:28:52 millert Exp $	*/
d74 1
a74 1
	CHAR_T *p, *t;
@


1.11
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_append.c,v 1.10 2014/11/12 04:28:41 bentley Exp $	*/
d221 1
a221 3
		(void)ex_puts(sp,
		    msg_cat(sp, "Entering ex input mode.", NULL));
		(void)ex_puts(sp, "\n");
@


1.10
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_append.c,v 1.9 2013/11/25 23:27:11 krw Exp $	*/
d222 1
a222 1
		    msg_cat(sp, "273|Entering ex input mode.", NULL));
@


1.9
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_append.c,v 1.8 2009/10/27 23:59:47 deraadt Exp $	*/
d37 1
a37 3
ex_append(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d49 1
a49 3
ex_change(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d62 1
a62 3
ex_insert(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
d72 1
a72 4
ex_aci(sp, cmdp, cmd)
	SCR *sp;
	EXCMD *cmdp;
	enum which cmd;
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_append.c,v 1.7 2005/10/17 19:12:16 otto Exp $	*/
d256 1
a256 1
	CIRCLEQ_INIT(&tiq);
d261 2
a262 2
	for (cnt = 0, tp = CIRCLEQ_FIRST(&tiq);
	    tp != (TEXT *)&tiq; ++cnt, tp = CIRCLEQ_NEXT(tp, q))
d265 2
@


1.7
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_append.c,v 1.6 2002/02/16 21:27:57 millert Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)ex_append.c	10.30 (Berkeley) 10/23/96";
#endif /* not lint */
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_append.c,v 1.5 2001/01/29 01:58:41 niklas Exp $	*/
d265 2
a266 2
	for (cnt = 0, tp = tiq.cqh_first;
	    tp != (TEXT *)&tiq; ++cnt, tp = tp->q.cqe_next)
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
static int ex_aci __P((SCR *, EXCMD *, enum which));
d38 1
a38 1
 * PUBLIC: int ex_append __P((SCR *, EXCMD *));
d52 1
a52 1
 * PUBLIC: int ex_change __P((SCR *, EXCMD *));
d67 1
a67 1
 * PUBLIC: int ex_insert __P((SCR *, EXCMD *));
@


1.4
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_append.c	10.29 (Berkeley) 6/28/96";
d119 1
a119 1
	    delete(sp, &cmdp->addr1, &cmdp->addr2, 1)))
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)ex_append.c	10.27 (Berkeley) 4/27/96";
d86 1
d94 1
d215 1
a215 1
		if (sp->gp->scr_screen(sp, SC_EX)) {
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)ex_append.c	8.24 (Berkeley) 8/17/94";
a17 1
#include <sys/time.h>
a20 1
#include <signal.h>
a22 1
#include <termios.h>
d25 1
a25 7
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "excmd.h"
#include "../sex/sex_screen.h"
d29 1
a29 1
static int aci __P((SCR *, EXF *, EXCMDARG *, enum which));
d35 2
d39 1
a39 1
ex_append(sp, ep, cmdp)
d41 1
a41 2
	EXF *ep;
	EXCMDARG *cmdp;
d43 1
a43 1
	return (aci(sp, ep, cmdp, APPEND));
d49 2
d53 1
a53 1
ex_change(sp, ep, cmdp)
d55 1
a55 2
	EXF *ep;
	EXCMDARG *cmdp;
d57 1
a57 1
	return (aci(sp, ep, cmdp, CHANGE));
d64 2
d68 1
a68 1
ex_insert(sp, ep, cmdp)
d70 1
a70 2
	EXF *ep;
	EXCMDARG *cmdp;
d72 1
a72 1
	return (aci(sp, ep, cmdp, INSERT));
d75 4
d80 1
a80 1
aci(sp, ep, cmdp, cmd)
d82 1
a82 2
	EXF *ep;
	EXCMDARG *cmdp;
d85 1
a85 2
	MARK m;
	TEXTH *sv_tiqp, tiq;
d87 5
a91 3
	struct termios t;
	u_int flags;
	int rval;
d93 1
a93 1
	rval = 0;
d96 61
a156 2
	 * Set input flags; the ! flag turns off autoindent for append,
	 * change and insert.
d158 37
a194 5
	LF_INIT(TXT_DOTTERM | TXT_NLECHO);
	if (!F_ISSET(cmdp, E_FORCE) && O_ISSET(sp, O_AUTOINDENT))
		LF_SET(TXT_AUTOINDENT);
	if (O_ISSET(sp, O_BEAUTIFY))
		LF_SET(TXT_BEAUTIFY);
d196 5
a200 2
	/* Input is interruptible. */
	F_SET(sp, S_INTERRUPTIBLE);
d203 1
a203 4
	 * If this code is called by vi, the screen TEXTH structure (sp->tiqp)
	 * may already be in use, e.g. ":append|s/abc/ABC/" would fail as we're
	 * only halfway through the line when the append code fires.  Use the
	 * local structure instead.
d206 1
a206 1
	 * ex's s_get() routine.  It actually works fine if we use vi's s_get()
d209 2
d212 5
a216 10
	if (IN_VI_MODE(sp)) {
		memset(&tiq, 0, sizeof(TEXTH));
		CIRCLEQ_INIT(&tiq);
		sv_tiqp = sp->tiqp;
		sp->tiqp = &tiq;

		if (F_ISSET(sp->gp, G_STDIN_TTY))
			SEX_RAW(t);
		(void)write(STDOUT_FILENO, "\n", 1);
		LF_SET(TXT_NLECHO);
d218 16
d236 9
a244 2
	/* Set the line number, so that autoindent works correctly. */
	sp->lno = cmdp->addr1.lno;
a245 3
	if (sex_get(sp, ep, sp->tiqp, 0, flags) != INP_OK)
		goto err;
	
d247 18
a264 26
	 * If doing a change, replace lines for as long as possible.  Then,
	 * append more lines or delete remaining lines.  Changes to an empty
	 * file are just appends, and inserts are the same as appends to the
	 * previous line.
	 *
	 * !!!
	 * Adjust the current line number for the commands to match historic
	 * practice if the user doesn't enter anything, and set the address
	 * to which we'll append.  This is safe because an address of 0 is
	 * illegal for change and insert.
	 */
	m = cmdp->addr1;
	switch (cmd) {
	case INSERT:
		--m.lno;
		/* FALLTHROUGH */
	case APPEND:
		if (sp->lno == 0)
			sp->lno = 1;
		break;
	case CHANGE:
		--m.lno;
		if (sp->lno != 1)
			--sp->lno;
		break;
	}
d267 3
a269 2
	 * !!!
	 * Cut into the unnamed buffer.
d271 2
a272 13
	if (cmd == CHANGE &&
	    (cut(sp, ep, NULL, &cmdp->addr1, &cmdp->addr2, CUT_LINEMODE) ||
	    delete(sp, ep, &cmdp->addr1, &cmdp->addr2, 1)))
		goto err;

	for (tp = sp->tiqp->cqh_first;
	    tp != (TEXT *)sp->tiqp; tp = tp->q.cqe_next) {
		if (file_aline(sp, ep, 1, m.lno, tp->lb, tp->len)) {
err:			rval = 1;
			break;
		}
		sp->lno = ++m.lno;
	}
d274 1
a274 12
	if (IN_VI_MODE(sp)) {
		sp->tiqp = sv_tiqp;
		text_lfree(&tiq);

		/* Reset the terminal state. */
		if (F_ISSET(sp->gp, G_STDIN_TTY)) {
			if (SEX_NORAW(t))
				rval = 1;
			F_SET(sp, S_REFRESH);
		}
	}
	return (rval);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
