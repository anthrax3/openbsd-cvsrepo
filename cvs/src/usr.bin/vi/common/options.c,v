head	1.24;
access;
symbols
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.16
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.14
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.10
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.13.0.16
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.12
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2017.06.30.14.42.05;	author bentley;	state Exp;
branches;
next	1.23;
commitid	pFWuvWkjb60wY7ul;

1.23
date	2017.04.18.01.45.35;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	Pd2TRHz7UBFr9JGt;

1.22
date	2016.08.01.18.27.35;	author bentley;	state Exp;
branches;
next	1.21;
commitid	NOKOkHbanuF52TAH;

1.21
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.20;
commitid	adBvXLg05bJxz6yx;

1.20
date	2016.01.06.22.27.39;	author millert;	state Exp;
branches;
next	1.19;
commitid	WTL2xUDqwK7LLJKC;

1.19
date	2015.11.24.10.28.14;	author bentley;	state Exp;
branches;
next	1.18;
commitid	fR19JxljUS7FFrGN;

1.18
date	2014.11.14.20.27.03;	author tedu;	state Exp;
branches;
next	1.17;
commitid	aIZ8ZvbLlUW9obxb;

1.17
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.16;
commitid	06bi6U3x4gFFf2G1;

1.16
date	2011.07.10.13.20.25;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.22.17.12.40;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.11.07.04.53;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.07.21.13.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.29.01.58.31;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.22.00.16.27;	author naddy;	state Exp;
branches;
next	1.7;

1.7
date	97.07.27.22.28.08;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.10.16.01.18.19;	author michaels;	state Exp;
branches;
next	1.5;

1.5
date	96.09.17.17.18.54;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.23;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.21;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Add mdoc(7) macros to vi's built-in lists of roff paragraph/section macros.

ok jmc@@, no objection schwarze@@
@
text
@/*	$OpenBSD: options.c,v 1.23 2017/04/18 01:45:35 deraadt Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1991, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "../vi/vi.h"
#include "pathnames.h"

static int	 	 opts_abbcmp(const void *, const void *);
static int	 	 opts_cmp(const void *, const void *);
static int	 	 opts_print(SCR *, OPTLIST const *);

/*
 * O'Reilly noted options and abbreviations are from "Learning the VI Editor",
 * Fifth Edition, May 1992.  There's no way of knowing what systems they are
 * actually from.
 *
 * HPUX noted options and abbreviations are from "The Ultimate Guide to the
 * VI and EX Text Editors", 1990.
 */
OPTLIST const optlist[] = {
/* O_ALTWERASE	  4.4BSD */
	{"altwerase",	f_altwerase,	OPT_0BOOL,	0},
/* O_AUTOINDENT	    4BSD */
	{"autoindent",	NULL,		OPT_0BOOL,	0},
/* O_AUTOPRINT	    4BSD */
	{"autoprint",	NULL,		OPT_1BOOL,	0},
/* O_AUTOWRITE	    4BSD */
	{"autowrite",	NULL,		OPT_0BOOL,	0},
/* O_BACKUP	  4.4BSD */
	{"backup",	NULL,		OPT_STR,	0},
/* O_BEAUTIFY	    4BSD */
	{"beautify",	NULL,		OPT_0BOOL,	0},
/* O_CDPATH	  4.4BSD */
	{"cdpath",	NULL,		OPT_STR,	0},
/* O_CEDIT	  4.4BSD */
	{"cedit",	NULL,		OPT_STR,	0},
/* O_COLUMNS	  4.4BSD */
	{"columns",	f_columns,	OPT_NUM,	OPT_NOSAVE},
/* O_COMMENT	  4.4BSD */
	{"comment",	NULL,		OPT_0BOOL,	0},
/* O_EDCOMPATIBLE   4BSD */
	{"edcompatible",NULL,		OPT_0BOOL,	0},
/* O_ESCAPETIME	  4.4BSD */
	{"escapetime",	NULL,		OPT_NUM,	0},
/* O_ERRORBELLS	    4BSD */
	{"errorbells",	NULL,		OPT_0BOOL,	0},
/* O_EXRC	System V (undocumented) */
	{"exrc",	NULL,		OPT_0BOOL,	0},
/* O_EXTENDED	  4.4BSD */
	{"extended",	f_recompile,	OPT_0BOOL,	0},
/* O_FILEC	  4.4BSD */
	{"filec",	NULL,		OPT_STR,	0},
/* O_FLASH	    HPUX */
	{"flash",	NULL,		OPT_0BOOL,	0},
/* O_HARDTABS	    4BSD */
	{"hardtabs",	NULL,		OPT_NUM,	0},
/* O_ICLOWER	  4.4BSD */
	{"iclower",	f_recompile,	OPT_0BOOL,	0},
/* O_IGNORECASE	    4BSD */
	{"ignorecase",	f_recompile,	OPT_0BOOL,	0},
/* O_KEYTIME	  4.4BSD */
	{"keytime",	NULL,		OPT_NUM,	0},
/* O_LEFTRIGHT	  4.4BSD */
	{"leftright",	f_reformat,	OPT_0BOOL,	0},
/* O_LINES	  4.4BSD */
	{"lines",	f_lines,	OPT_NUM,	OPT_NOSAVE},
/* O_LISP	    4BSD
 *	XXX
 *	When the lisp option is implemented, delete the OPT_NOSAVE flag,
 *	so that :mkexrc dumps it.
 */
	{"lisp",	f_lisp,		OPT_0BOOL,	OPT_NOSAVE},
/* O_LIST	    4BSD */
	{"list",	f_reformat,	OPT_0BOOL,	0},
/* O_LOCKFILES	  4.4BSD
 *	XXX
 *	Locking isn't reliable enough over NFS to require it, in addition,
 *	it's a serious startup performance problem over some remote links.
 */
	{"lock",	NULL,		OPT_1BOOL,	0},
/* O_MAGIC	    4BSD */
	{"magic",	NULL,		OPT_1BOOL,	0},
/* O_MATCHTIME	  4.4BSD */
	{"matchtime",	NULL,		OPT_NUM,	0},
/* O_MESG	    4BSD */
	{"mesg",	NULL,		OPT_1BOOL,	0},
/* O_MODELINE	    4BSD
 *	!!!
 *	This has been documented in historical systems as both "modeline"
 *	and as "modelines".  Regardless of the name, this option represents
 *	a security problem of mammoth proportions, not to mention a stunning
 *	example of what your intro CS professor referred to as the perils of
 *	mixing code and data.  Don't add it, or I will kill you.
 */
	{"modeline",	NULL,		OPT_0BOOL,	OPT_NOSET},
/* O_NOPRINT	  4.4BSD */
	{"noprint",	f_print,	OPT_STR,	OPT_EARLYSET},
/* O_NUMBER	    4BSD */
	{"number",	f_reformat,	OPT_0BOOL,	0},
/* O_OCTAL	  4.4BSD */
	{"octal",	f_print,	OPT_0BOOL,	OPT_EARLYSET},
/* O_OPEN	    4BSD */
	{"open",	NULL,		OPT_1BOOL,	0},
/* O_OPTIMIZE	    4BSD */
	{"optimize",	NULL,		OPT_1BOOL,	0},
/* O_PARAGRAPHS	    4BSD */
	{"paragraphs",	f_paragraph,	OPT_STR,	0},
/* O_PATH	  4.4BSD */
	{"path",	NULL,		OPT_STR,	0},
/* O_PRINT	  4.4BSD */
	{"print",	f_print,	OPT_STR,	OPT_EARLYSET},
/* O_PROMPT	    4BSD */
	{"prompt",	NULL,		OPT_1BOOL,	0},
/* O_READONLY	    4BSD (undocumented) */
	{"readonly",	f_readonly,	OPT_0BOOL,	OPT_ALWAYS},
/* O_RECDIR	  4.4BSD */
	{"recdir",	NULL,		OPT_STR,	0},
/* O_REDRAW	    4BSD */
	{"redraw",	NULL,		OPT_0BOOL,	0},
/* O_REMAP	    4BSD */
	{"remap",	NULL,		OPT_1BOOL,	0},
/* O_REPORT	    4BSD */
	{"report",	NULL,		OPT_NUM,	0},
/* O_RULER	  4.4BSD */
	{"ruler",	NULL,		OPT_0BOOL,	0},
/* O_SCROLL	    4BSD */
	{"scroll",	NULL,		OPT_NUM,	0},
/* O_SEARCHINCR	  4.4BSD */
	{"searchincr",	NULL,		OPT_0BOOL,	0},
/* O_SECTIONS	    4BSD */
	{"sections",	f_section,	OPT_STR,	0},
/* O_SECURE	  4.4BSD */
	{"secure",	NULL,		OPT_0BOOL,	OPT_NOUNSET},
/* O_SHELL	    4BSD */
	{"shell",	NULL,		OPT_STR,	0},
/* O_SHELLMETA	  4.4BSD */
	{"shellmeta",	NULL,		OPT_STR,	0},
/* O_SHIFTWIDTH	    4BSD */
	{"shiftwidth",	NULL,		OPT_NUM,	OPT_NOZERO},
/* O_SHOWMATCH	    4BSD */
	{"showmatch",	NULL,		OPT_0BOOL,	0},
/* O_SHOWMODE	  4.4BSD */
	{"showmode",	NULL,		OPT_0BOOL,	0},
/* O_SIDESCROLL	  4.4BSD */
	{"sidescroll",	NULL,		OPT_NUM,	OPT_NOZERO},
/* O_SLOWOPEN	    4BSD  */
	{"slowopen",	NULL,		OPT_0BOOL,	0},
/* O_SOURCEANY	    4BSD (undocumented)
 *	!!!
 *	Historic vi, on startup, source'd $HOME/.exrc and ./.exrc, if they
 *	were owned by the user.  The sourceany option was an undocumented
 *	feature of historic vi which permitted the startup source'ing of
 *	.exrc files the user didn't own.  This is an obvious security problem,
 *	and we ignore the option.
 */
	{"sourceany",	NULL,		OPT_0BOOL,	OPT_NOSET},
/* O_TABSTOP	    4BSD */
	{"tabstop",	f_reformat,	OPT_NUM,	OPT_NOZERO},
/* O_TAGLENGTH	    4BSD */
	{"taglength",	NULL,		OPT_NUM,	0},
/* O_TAGS	    4BSD */
	{"tags",	NULL,		OPT_STR,	0},
/* O_TERM	    4BSD
 *	!!!
 *	By default, the historic vi always displayed information about two
 *	options, redraw and term.  Term seems sufficient.
 */
	{"term",	NULL,		OPT_STR,	OPT_ADISP|OPT_NOSAVE},
/* O_TERSE	    4BSD */
	{"terse",	NULL,		OPT_0BOOL,	0},
/* O_TILDEOP      4.4BSD */
	{"tildeop",	NULL,		OPT_0BOOL,	0},
/* O_TIMEOUT	    4BSD (undocumented) */
	{"timeout",	NULL,		OPT_1BOOL,	0},
/* O_TTYWERASE	  4.4BSD */
	{"ttywerase",	f_ttywerase,	OPT_0BOOL,	0},
/* O_VERBOSE	  4.4BSD */
	{"verbose",	NULL,		OPT_0BOOL,	0},
/* O_W1200	    4BSD */
	{"w1200",	f_w1200,	OPT_NUM,	OPT_NDISP|OPT_NOSAVE},
/* O_W300	    4BSD */
	{"w300",	f_w300,		OPT_NUM,	OPT_NDISP|OPT_NOSAVE},
/* O_W9600	    4BSD */
	{"w9600",	f_w9600,	OPT_NUM,	OPT_NDISP|OPT_NOSAVE},
/* O_WARN	    4BSD */
	{"warn",	NULL,		OPT_1BOOL,	0},
/* O_WINDOW	    4BSD */
	{"window",	f_window,	OPT_NUM,	0},
/* O_WINDOWNAME	    4BSD */
	{"windowname",	NULL,		OPT_0BOOL,	0},
/* O_WRAPLEN	  4.4BSD */
	{"wraplen",	NULL,		OPT_NUM,	0},
/* O_WRAPMARGIN	    4BSD */
	{"wrapmargin",	NULL,		OPT_NUM,	0},
/* O_WRAPSCAN	    4BSD */
	{"wrapscan",	NULL,		OPT_1BOOL,	0},
/* O_WRITEANY	    4BSD */
	{"writeany",	NULL,		OPT_0BOOL,	0},
	{NULL},
};

typedef struct abbrev {
        char *name;
        int offset;
} OABBREV;

static OABBREV const abbrev[] = {
	{"ai",		O_AUTOINDENT},		/*     4BSD */
	{"ap",		O_AUTOPRINT},		/*     4BSD */
	{"aw",		O_AUTOWRITE},		/*     4BSD */
	{"bf",		O_BEAUTIFY},		/*     4BSD */
	{"co",		O_COLUMNS},		/*   4.4BSD */
	{"eb",		O_ERRORBELLS},		/*     4BSD */
	{"ed",		O_EDCOMPATIBLE},	/*     4BSD */
	{"ex",		O_EXRC},		/* System V (undocumented) */
	{"ht",		O_HARDTABS},		/*     4BSD */
	{"ic",		O_IGNORECASE},		/*     4BSD */
	{"li",		O_LINES},		/*   4.4BSD */
	{"modelines",	O_MODELINE},		/*     HPUX */
	{"nu",		O_NUMBER},		/*     4BSD */
	{"opt",		O_OPTIMIZE},		/*     4BSD */
	{"para",	O_PARAGRAPHS},		/*     4BSD */
	{"re",		O_REDRAW},		/* O'Reilly */
	{"ro",		O_READONLY},		/*     4BSD (undocumented) */
	{"scr",		O_SCROLL},		/*     4BSD (undocumented) */
	{"sect",	O_SECTIONS},		/* O'Reilly */
	{"sh",		O_SHELL},		/*     4BSD */
	{"slow",	O_SLOWOPEN},		/*     4BSD */
	{"sm",		O_SHOWMATCH},		/*     4BSD */
	{"smd",		O_SHOWMODE},		/*     4BSD */
	{"sw",		O_SHIFTWIDTH},		/*     4BSD */
	{"tag",		O_TAGS},		/*     4BSD (undocumented) */
	{"tl",		O_TAGLENGTH},		/*     4BSD */
	{"to",		O_TIMEOUT},		/*     4BSD (undocumented) */
	{"ts",		O_TABSTOP},		/*     4BSD */
	{"tty",		O_TERM},		/*     4BSD (undocumented) */
	{"ttytype",	O_TERM},		/*     4BSD (undocumented) */
	{"w",		O_WINDOW},		/* O'Reilly */
	{"wa",		O_WRITEANY},		/*     4BSD */
	{"wi",		O_WINDOW},		/*     4BSD (undocumented) */
	{"wl",		O_WRAPLEN},		/*   4.4BSD */
	{"wm",		O_WRAPMARGIN},		/*     4BSD */
	{"ws",		O_WRAPSCAN},		/*     4BSD */
	{NULL},
};

/*
 * opts_init --
 *	Initialize some of the options.
 *
 * PUBLIC: int opts_init(SCR *, int *);
 */
int
opts_init(SCR *sp, int *oargs)
{
	ARGS *argv[2], a, b;
	OPTLIST const *op;
	u_long v;
	int optindx;
	char *s, b1[1024];

	a.bp = b1;
	b.bp = NULL;
	a.len = b.len = 0;
	argv[0] = &a;
	argv[1] = &b;

	/* Set numeric and string default values. */
#define	OI(indx, str) {							\
	if ((str) != b1)	/* GCC puts strings in text-space. */	\
		(void)strlcpy(b1, (str), sizeof(b1));			\
	a.len = strlen(b1);						\
	if (opts_set(sp, argv, NULL)) {					\
		optindx = indx;						\
		goto err;						\
	}								\
}
	/*
	 * Indirect global options to global space.  Specifically, set up
	 * terminal, lines, columns first, they're used by other options.
	 * Note, don't set the flags until we've set up the indirection.
	 */
	if (o_set(sp, O_TERM, 0, NULL, GO_TERM)) {
		optindx = O_TERM;
		goto err;
	}
	F_SET(&sp->opts[O_TERM], OPT_GLOBAL);
	if (o_set(sp, O_LINES, 0, NULL, GO_LINES)) {
		optindx = O_LINES;
		goto err;
	}
	F_SET(&sp->opts[O_LINES], OPT_GLOBAL);
	if (o_set(sp, O_COLUMNS, 0, NULL, GO_COLUMNS)) {
		optindx = O_COLUMNS;
		goto err;
	}
	F_SET(&sp->opts[O_COLUMNS], OPT_GLOBAL);
	if (o_set(sp, O_SECURE, 0, NULL, GO_SECURE)) {
		optindx = O_SECURE;
		goto err;
	}
	F_SET(&sp->opts[O_SECURE], OPT_GLOBAL);

	/* Initialize string values. */
	(void)snprintf(b1, sizeof(b1),
	    "cdpath=%s", (s = getenv("CDPATH")) == NULL ? ":" : s);
	OI(O_CDPATH, b1);
	OI(O_ESCAPETIME, "escapetime=1");
	OI(O_FILEC, "filec=\t");
	OI(O_KEYTIME, "keytime=6");
	OI(O_MATCHTIME, "matchtime=7");
	OI(O_REPORT, "report=5");
	OI(O_PARAGRAPHS, "paragraphs=IPLPPPQPP LIpplpipbpBlBdPpLpIt");
	(void)snprintf(b1, sizeof(b1), "path=%s", "");
	OI(O_PATH, b1);
	(void)snprintf(b1, sizeof(b1), "recdir=%s", _PATH_PRESERVE);
	OI(O_RECDIR, b1);
	OI(O_SECTIONS, "sections=NHSHH HUnhshShSs");
	(void)snprintf(b1, sizeof(b1),
	    "shell=%s", (s = getenv("SHELL")) == NULL ? _PATH_BSHELL : s);
	OI(O_SHELL, b1);
	OI(O_SHELLMETA, "shellmeta=~{[*?$`'\"\\");
	OI(O_SHIFTWIDTH, "shiftwidth=8");
	OI(O_SIDESCROLL, "sidescroll=16");
	OI(O_TABSTOP, "tabstop=8");
	(void)snprintf(b1, sizeof(b1), "tags=%s", _PATH_TAGS);
	OI(O_TAGS, b1);

	/*
	 * XXX
	 * Initialize O_SCROLL here, after term; initializing term should
	 * have created a LINES/COLUMNS value.
	 */
	if ((v = (O_VAL(sp, O_LINES) - 1) / 2) == 0)
		v = 1;
	(void)snprintf(b1, sizeof(b1), "scroll=%ld", v);
	OI(O_SCROLL, b1);

	/*
	 * The default window option values are:
	 *		8 if baud rate <=  600
	 *	       16 if baud rate <= 1200
	 *	LINES - 1 if baud rate  > 1200
	 *
	 * Note, the windows option code will correct any too-large value
	 * or when the O_LINES value is 1.
	 */
	if (sp->gp->scr_baud(sp, &v))
		return (1);
	if (v <= 600)
		v = 8;
	else if (v <= 1200)
		v = 16;
	else
		v = O_VAL(sp, O_LINES) - 1;
	(void)snprintf(b1, sizeof(b1), "window=%lu", v);
	OI(O_WINDOW, b1);

	/*
	 * Set boolean default values, and copy all settings into the default
	 * information.  OS_NOFREE is set, we're copying, not replacing.
	 */
	for (op = optlist, optindx = 0; op->name != NULL; ++op, ++optindx)
		switch (op->type) {
		case OPT_0BOOL:
			break;
		case OPT_1BOOL:
			O_SET(sp, optindx);
			O_D_SET(sp, optindx);
			break;
		case OPT_NUM:
			o_set(sp, optindx, OS_DEF, NULL, O_VAL(sp, optindx));
			break;
		case OPT_STR:
			if (O_STR(sp, optindx) != NULL && o_set(sp, optindx,
			    OS_DEF | OS_NOFREE | OS_STRDUP, O_STR(sp, optindx), 0))
				goto err;
			break;
		default:
			abort();
		}

	/*
	 * !!!
	 * Some options can be initialized by the command name or the
	 * command-line arguments.  They don't set the default values,
	 * it's historic practice.
	 */
	for (; *oargs != -1; ++oargs)
		OI(*oargs, optlist[*oargs].name);
	return (0);
#undef OI

err:	msgq(sp, M_ERR,
	    "Unable to set default %s option", optlist[optindx].name);
	return (1);
}

/*
 * opts_set --
 *	Change the values of one or more options.
 *
 * PUBLIC: int opts_set(SCR *, ARGS *[], char *);
 */
int
opts_set(SCR *sp, ARGS *argv[], char *usage)
{
	enum optdisp disp;
	enum nresult nret;
	OPTLIST const *op;
	OPTION *spo;
	u_long value, turnoff;
	int ch, equals, nf, nf2, offset, qmark, rval;
	char *endp, *name, *p, *sep, *t;

	disp = NO_DISPLAY;
	for (rval = 0; argv[0]->len != 0; ++argv) {
		/*
		 * The historic vi dumped the options for each occurrence of
		 * "all" in the set list.  Puhleeze.
		 */
		if (!strcmp(argv[0]->bp, "all")) {
			disp = ALL_DISPLAY;
			continue;
		}

		/* Find equals sign or question mark. */
		for (sep = NULL, equals = qmark = 0,
		    p = name = argv[0]->bp; (ch = *p) != '\0'; ++p)
			if (ch == '=' || ch == '?') {
				if (p == name) {
					if (usage != NULL)
						msgq(sp, M_ERR,
						    "Usage: %s", usage);
					return (1);
				}
				sep = p;
				if (ch == '=')
					equals = 1;
				else
					qmark = 1;
				break;
			}

		turnoff = 0;
		op = NULL;
		if (sep != NULL)
			*sep++ = '\0';

		/* Search for the name, then name without any leading "no". */
		if ((op = opts_search(name)) == NULL &&
		    name[0] == 'n' && name[1] == 'o') {
			turnoff = 1;
			name += 2;
			op = opts_search(name);
		}
		if (op == NULL) {
			opts_nomatch(sp, name);
			rval = 1;
			continue;
		}

		/* Find current option values. */
		offset = op - optlist;
		spo = sp->opts + offset;

		/*
		 * !!!
		 * Historically, the question mark could be a separate
		 * argument.
		 */
		if (!equals && !qmark &&
		    argv[1]->len == 1 && argv[1]->bp[0] == '?') {
			++argv;
			qmark = 1;
		}

		/* Set name, value. */
		switch (op->type) {
		case OPT_0BOOL:
		case OPT_1BOOL:
			/* Some options may not be reset. */
			if (F_ISSET(op, OPT_NOUNSET) && turnoff) {
				msgq_str(sp, M_ERR, name,
			    "set: the %s option may not be turned off");
				rval = 1;
				break;
			}

			/* Some options may not be set. */
			if (F_ISSET(op, OPT_NOSET) && !turnoff) {
				msgq_str(sp, M_ERR, name,
			    "set: the %s option may never be turned on");
				rval = 1;
				break;
			}

			if (equals) {
				msgq_str(sp, M_ERR, name,
			    "set: [no]%s option doesn't take a value");
				rval = 1;
				break;
			}
			if (qmark) {
				if (!disp)
					disp = SELECT_DISPLAY;
				F_SET(spo, OPT_SELECTED);
				break;
			}

			/*
			 * Do nothing if the value is unchanged, the underlying
			 * functions can be expensive.
			 */
			if (!F_ISSET(op, OPT_ALWAYS)) {
				if (turnoff) {
					if (!O_ISSET(sp, offset))
						break;
				} else {
					if (O_ISSET(sp, offset))
						break;
				}
			}

			if (F_ISSET(op, OPT_EARLYSET)) {
			    /* Set the value. */
			    if (turnoff)
				O_CLR(sp, offset);
			    else
				O_SET(sp, offset);
			}

			/* Report to subsystems. */
			if ((op->func != NULL &&
			    op->func(sp, spo, NULL, &turnoff)) ||
			    ex_optchange(sp, offset, NULL, &turnoff) ||
			    v_optchange(sp, offset, NULL, &turnoff) ||
			    sp->gp->scr_optchange(sp, offset, NULL, &turnoff)) {
				rval = 1;
				break;
			}

			if (!F_ISSET(op, OPT_EARLYSET)) {
			    /* Set the value. */
			    if (turnoff)
				O_CLR(sp, offset);
			    else
				O_SET(sp, offset);
			}
			break;
		case OPT_NUM:
			if (turnoff) {
				msgq_str(sp, M_ERR, name,
				    "set: %s option isn't a boolean");
				rval = 1;
				break;
			}
			if (qmark || !equals) {
				if (!disp)
					disp = SELECT_DISPLAY;
				F_SET(spo, OPT_SELECTED);
				break;
			}

			if (!isdigit(sep[0]))
				goto badnum;
			if ((nret =
			    nget_uslong(&value, sep, &endp, 10)) != NUM_OK) {
				p = msg_print(sp, name, &nf);
				t = msg_print(sp, sep, &nf2);
				switch (nret) {
				case NUM_ERR:
					msgq(sp, M_SYSERR,
					    "set: %s option: %s", p, t);
					break;
				case NUM_OVER:
					msgq(sp, M_ERR,
			    "set: %s option: %s: value overflow", p, t);
					break;
				case NUM_OK:
				case NUM_UNDER:
					abort();
				}
				if (nf)
					FREE_SPACE(sp, p, 0);
				if (nf2)
					FREE_SPACE(sp, t, 0);
				rval = 1;
				break;
			}
			if (*endp && !isblank(*endp)) {
badnum:				p = msg_print(sp, name, &nf);
				t = msg_print(sp, sep, &nf2);
				msgq(sp, M_ERR,
		    "set: %s option: %s is an illegal number", p, t);
				if (nf)
					FREE_SPACE(sp, p, 0);
				if (nf2)
					FREE_SPACE(sp, t, 0);
				rval = 1;
				break;
			}

			/* Some options may never be set to zero. */
			if (F_ISSET(op, OPT_NOZERO) && value == 0) {
				msgq_str(sp, M_ERR, name,
			    "set: the %s option may never be set to 0");
				rval = 1;
				break;
			}

			/*
			 * Do nothing if the value is unchanged, the underlying
			 * functions can be expensive.
			 */
			if (!F_ISSET(op, OPT_ALWAYS) &&
			    O_VAL(sp, offset) == value)
				break;

			if (F_ISSET(op, OPT_EARLYSET)) {
			    /* Set the value. */
			    if (o_set(sp, offset, 0, NULL, value)) {
				rval = 1;
				break;
			    }
			}

			/* Report to subsystems. */
			if ((op->func != NULL &&
			    op->func(sp, spo, sep, &value)) ||
			    ex_optchange(sp, offset, sep, &value) ||
			    v_optchange(sp, offset, sep, &value) ||
			    sp->gp->scr_optchange(sp, offset, sep, &value)) {
				rval = 1;
				break;
			}

			if (!F_ISSET(op, OPT_EARLYSET)) {
			    /* Set the value. */
			    if (o_set(sp, offset, 0, NULL, value))
				rval = 1;
			}
			break;
		case OPT_STR:
			if (turnoff) {
				msgq_str(sp, M_ERR, name,
				    "set: %s option isn't a boolean");
				rval = 1;
				break;
			}
			if (qmark || !equals) {
				if (!disp)
					disp = SELECT_DISPLAY;
				F_SET(spo, OPT_SELECTED);
				break;
			}

			/*
			 * Do nothing if the value is unchanged, the underlying
			 * functions can be expensive.
			 */
			if (!F_ISSET(op, OPT_ALWAYS) &&
			    O_STR(sp, offset) != NULL &&
			    !strcmp(O_STR(sp, offset), sep))
				break;

			if (F_ISSET(op, OPT_EARLYSET)) {
			    /* Set the value. */
			    if (o_set(sp, offset, OS_STRDUP, sep, 0)) {
				rval = 1;
				break;
			    }
			}

			/* Report to subsystems. */
			if ((op->func != NULL &&
			    op->func(sp, spo, sep, NULL)) ||
			    ex_optchange(sp, offset, sep, NULL) ||
			    v_optchange(sp, offset, sep, NULL) ||
			    sp->gp->scr_optchange(sp, offset, sep, NULL)) {
				rval = 1;
				break;
			}

			if (!F_ISSET(op, OPT_EARLYSET)) {
			    /* Set the value. */
			    if (o_set(sp, offset, OS_STRDUP, sep, 0))
				rval = 1;
			}
			break;
		default:
			abort();
		}
	}
	if (disp != NO_DISPLAY)
		opts_dump(sp, disp);
	return (rval);
}

/*
 * o_set --
 *	Set an option's value.
 *
 * PUBLIC: int o_set(SCR *, int, u_int, char *, u_long);
 */
int
o_set(SCR *sp, int opt, u_int flags, char *str, u_long val)
{
	OPTION *op;

	/* Set a pointer to the options area. */
	op = F_ISSET(&sp->opts[opt], OPT_GLOBAL) ?
	    &sp->gp->opts[sp->opts[opt].o_cur.val] : &sp->opts[opt];

	/* Copy the string, if requested. */
	if (LF_ISSET(OS_STRDUP) && (str = strdup(str)) == NULL) {
		msgq(sp, M_SYSERR, NULL);
		return (1);
	}

	/* Free the previous string, if requested, and set the value. */
	if (LF_ISSET(OS_DEF))
		if (LF_ISSET(OS_STR | OS_STRDUP)) {
			if (!LF_ISSET(OS_NOFREE) && op->o_def.str != NULL)
				free(op->o_def.str);
			op->o_def.str = str;
		} else
			op->o_def.val = val;
	else
		if (LF_ISSET(OS_STR | OS_STRDUP)) {
			if (!LF_ISSET(OS_NOFREE) && op->o_cur.str != NULL)
				free(op->o_cur.str);
			op->o_cur.str = str;
		} else
			op->o_cur.val = val;
	return (0);
}

/*
 * opts_empty --
 *	Return 1 if the string option is invalid, 0 if it's OK.
 *
 * PUBLIC: int opts_empty(SCR *, int, int);
 */
int
opts_empty(SCR *sp, int off, int silent)
{
	char *p;

	if ((p = O_STR(sp, off)) == NULL || p[0] == '\0') {
		if (!silent)
			msgq_str(sp, M_ERR, optlist[off].name,
			    "No %s edit option specified");
		return (1);
	}
	return (0);
}

/*
 * opts_dump --
 *	List the current values of selected options.
 *
 * PUBLIC: void opts_dump(SCR *, enum optdisp);
 */
void
opts_dump(SCR *sp, enum optdisp type)
{
	OPTLIST const *op;
	int base, b_num, cnt, col, colwidth, curlen, s_num;
	int numcols, numrows, row;
	int b_op[O_OPTIONCOUNT], s_op[O_OPTIONCOUNT];
	char nbuf[20];

	/*
	 * Options are output in two groups -- those that fit in a column and
	 * those that don't.  Output is done on 6 character "tab" boundaries
	 * for no particular reason.  (Since we don't output tab characters,
	 * we can ignore the terminal's tab settings.)  Ignore the user's tab
	 * setting because we have no idea how reasonable it is.
	 *
	 * Find a column width we can live with, testing from 10 columns to 1.
	 */
	for (numcols = 10; numcols > 1; --numcols) {
		colwidth = sp->cols / numcols & ~(STANDARD_TAB - 1);
		if (colwidth >= 10) {
			colwidth =
			    (colwidth + STANDARD_TAB) & ~(STANDARD_TAB - 1);
			numcols = sp->cols / colwidth;
			break;
		}
		colwidth = 0;
	}

	/*
	 * Get the set of options to list, entering them into
	 * the column list or the overflow list.
	 */
	for (b_num = s_num = 0, op = optlist; op->name != NULL; ++op) {
		cnt = op - optlist;

		/* If OPT_NDISP set, it's never displayed. */
		if (F_ISSET(op, OPT_NDISP))
			continue;

		switch (type) {
		case ALL_DISPLAY:		/* Display all. */
			break;
		case CHANGED_DISPLAY:		/* Display changed. */
			/* If OPT_ADISP set, it's always "changed". */
			if (F_ISSET(op, OPT_ADISP))
				break;
			switch (op->type) {
			case OPT_0BOOL:
			case OPT_1BOOL:
			case OPT_NUM:
				if (O_VAL(sp, cnt) == O_D_VAL(sp, cnt))
					continue;
				break;
			case OPT_STR:
				if (O_STR(sp, cnt) == O_D_STR(sp, cnt) ||
				    (O_D_STR(sp, cnt) != NULL &&
				    !strcmp(O_STR(sp, cnt), O_D_STR(sp, cnt))))
					continue;
				break;
			}
			break;
		case SELECT_DISPLAY:		/* Display selected. */
			if (!F_ISSET(&sp->opts[cnt], OPT_SELECTED))
				continue;
			break;
		default:
		case NO_DISPLAY:
			abort();
		}
		F_CLR(&sp->opts[cnt], OPT_SELECTED);

		curlen = strlen(op->name);
		switch (op->type) {
		case OPT_0BOOL:
		case OPT_1BOOL:
			if (!O_ISSET(sp, cnt))
				curlen += 2;
			break;
		case OPT_NUM:
			(void)snprintf(nbuf,
			    sizeof(nbuf), "%ld", O_VAL(sp, cnt));
			curlen += strlen(nbuf);
			break;
		case OPT_STR:
			if (O_STR(sp, cnt) != NULL)
				curlen += strlen(O_STR(sp, cnt));
			curlen += 3;
			break;
		}
		/* Offset by 2 so there's a gap. */
		if (curlen <= colwidth - 2)
			s_op[s_num++] = cnt;
		else
			b_op[b_num++] = cnt;
	}

	if (s_num > 0) {
		/* Figure out the number of rows. */
		if (s_num > numcols) {
			numrows = s_num / numcols;
			if (s_num % numcols)
				++numrows;
		} else
			numrows = 1;

		/* Display the options in sorted order. */
		for (row = 0; row < numrows;) {
			for (base = row, col = 0; col < numcols; ++col) {
				cnt = opts_print(sp, &optlist[s_op[base]]);
				if ((base += numrows) >= s_num)
					break;
				(void)ex_printf(sp, "%*s",
				    (int)(colwidth - cnt), "");
			}
			if (++row < numrows || b_num)
				(void)ex_puts(sp, "\n");
		}
	}

	for (row = 0; row < b_num;) {
		(void)opts_print(sp, &optlist[b_op[row]]);
		if (++row < b_num)
			(void)ex_puts(sp, "\n");
	}
	(void)ex_puts(sp, "\n");
}

/*
 * opts_print --
 *	Print out an option.
 */
static int
opts_print(SCR *sp, OPTLIST const *op)
{
	int curlen, offset;

	curlen = 0;
	offset = op - optlist;
	switch (op->type) {
	case OPT_0BOOL:
	case OPT_1BOOL:
		curlen += ex_printf(sp,
		    "%s%s", O_ISSET(sp, offset) ? "" : "no", op->name);
		break;
	case OPT_NUM:
		curlen += ex_printf(sp, "%s=%ld", op->name, O_VAL(sp, offset));
		break;
	case OPT_STR:
		curlen += ex_printf(sp, "%s=\"%s\"", op->name,
		    O_STR(sp, offset) == NULL ? "" : O_STR(sp, offset));
		break;
	}
	return (curlen);
}

/*
 * opts_save --
 *	Write the current configuration to a file.
 *
 * PUBLIC: int opts_save(SCR *, FILE *);
 */
int
opts_save(SCR *sp, FILE *fp)
{
	OPTLIST const *op;
	int ch, cnt;
	char *p;

	for (op = optlist; op->name != NULL; ++op) {
		if (F_ISSET(op, OPT_NOSAVE))
			continue;
		cnt = op - optlist;
		switch (op->type) {
		case OPT_0BOOL:
		case OPT_1BOOL:
			if (O_ISSET(sp, cnt))
				(void)fprintf(fp, "set %s\n", op->name);
			else
				(void)fprintf(fp, "set no%s\n", op->name);
			break;
		case OPT_NUM:
			(void)fprintf(fp,
			    "set %s=%-3ld\n", op->name, O_VAL(sp, cnt));
			break;
		case OPT_STR:
			if (O_STR(sp, cnt) == NULL)
				break;
			(void)fprintf(fp, "set ");
			for (p = op->name; (ch = *p) != '\0'; ++p) {
				if (isblank(ch) || ch == '\\')
					(void)putc('\\', fp);
				(void)putc(ch, fp);
			}
			(void)putc('=', fp);
			for (p = O_STR(sp, cnt); (ch = *p) != '\0'; ++p) {
				if (isblank(ch) || ch == '\\')
					(void)putc('\\', fp);
				(void)putc(ch, fp);
			}
			(void)putc('\n', fp);
			break;
		}
		if (ferror(fp)) {
			msgq(sp, M_SYSERR, NULL);
			return (1);
		}
	}
	return (0);
}

/* 
 * opts_search --
 *	Search for an option.
 *
 * PUBLIC: OPTLIST const *opts_search(char *);
 */
OPTLIST const *
opts_search(char *name)
{
	OPTLIST const *op, *found;
	OABBREV atmp, *ap;
	OPTLIST otmp;
	size_t len;

	/* Check list of abbreviations. */
	atmp.name = name;
	if ((ap = bsearch(&atmp, abbrev, sizeof(abbrev) / sizeof(OABBREV) - 1,
	    sizeof(OABBREV), opts_abbcmp)) != NULL)
		return (optlist + ap->offset);

	/* Check list of options. */
	otmp.name = name;
	if ((op = bsearch(&otmp, optlist, sizeof(optlist) / sizeof(OPTLIST) - 1,
	    sizeof(OPTLIST), opts_cmp)) != NULL)
		return (op);
		
	/*
	 * Check to see if the name is the prefix of one (and only one)
	 * option.  If so, return the option.
	 */
	len = strlen(name);
	for (found = NULL, op = optlist; op->name != NULL; ++op) {
		if (op->name[0] < name[0])
			continue;
		if (op->name[0] > name[0])
			break;
		if (!memcmp(op->name, name, len)) {
			if (found != NULL)
				return (NULL);
			found = op;
		}
	}
	return (found);
}

/* 
 * opts_nomatch --
 *	Standard nomatch error message for options.
 *
 * PUBLIC: void opts_nomatch(SCR *, char *);
 */
void
opts_nomatch(SCR *sp, char *name)
{
	msgq_str(sp, M_ERR, name,
	    "set: no %s option: 'set all' gives all option values");
}

static int
opts_abbcmp(const void *a, const void *b)
{
        return(strcmp(((OABBREV *)a)->name, ((OABBREV *)b)->name));
}

static int
opts_cmp(const void *a, const void *b)
{
        return(strcmp(((OPTLIST *)a)->name, ((OPTLIST *)b)->name));
}

/*
 * opts_copy --
 *	Copy a screen's OPTION array.
 *
 * PUBLIC: int opts_copy(SCR *, SCR *);
 */
int
opts_copy(SCR *orig, SCR *sp)
{
	int cnt, rval;

	/* Copy most everything without change. */
	memcpy(sp->opts, orig->opts, sizeof(orig->opts));

	/* Copy the string edit options. */
	for (cnt = rval = 0; cnt < O_OPTIONCOUNT; ++cnt) {
		if (optlist[cnt].type != OPT_STR ||
		    F_ISSET(&optlist[cnt], OPT_GLOBAL))
			continue;
		/*
		 * If never set, or already failed, NULL out the entries --
		 * have to continue after failure, otherwise would have two
		 * screens referencing the same memory.
		 */
		if (rval || O_STR(sp, cnt) == NULL) {
			o_set(sp, cnt, OS_NOFREE | OS_STR, NULL, 0);
			o_set(sp, cnt, OS_DEF | OS_NOFREE | OS_STR, NULL, 0);
			continue;
		}

		/* Copy the current string. */
		if (o_set(sp, cnt, OS_NOFREE | OS_STRDUP, O_STR(sp, cnt), 0)) {
			o_set(sp, cnt, OS_DEF | OS_NOFREE | OS_STR, NULL, 0);
			goto nomem;
		}

		/* Copy the default string. */
		if (O_D_STR(sp, cnt) != NULL && o_set(sp, cnt,
		    OS_DEF | OS_NOFREE | OS_STRDUP, O_D_STR(sp, cnt), 0)) {
nomem:			msgq(orig, M_SYSERR, NULL);
			rval = 1;
		}
	}
	return (rval);
}

/*
 * opts_free --
 *	Free all option strings
 *
 * PUBLIC: void opts_free(SCR *);
 */
void
opts_free(SCR *sp)
{
	int cnt;

	for (cnt = 0; cnt < O_OPTIONCOUNT; ++cnt) {
		if (optlist[cnt].type != OPT_STR ||
		    F_ISSET(&optlist[cnt], OPT_GLOBAL))
			continue;
		free(O_STR(sp, cnt));
		free(O_D_STR(sp, cnt));
	}
}
@


1.23
log
@free(NULL) is ok so use it; from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.22 2016/08/01 18:27:35 bentley Exp $	*/
d338 1
a338 1
	OI(O_PARAGRAPHS, "paragraphs=IPLPPPQPP LIpplpipbp");
d343 1
a343 1
	OI(O_SECTIONS, "sections=NHSHH HUnhsh");
@


1.22
log
@Remove vi's "directory" option and TMPDIR support.

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.21 2016/01/06 22:28:52 millert Exp $	*/
d1132 2
a1133 4
		if (O_STR(sp, cnt) != NULL)
			free(O_STR(sp, cnt));
		if (O_D_STR(sp, cnt) != NULL)
			free(O_D_STR(sp, cnt));
@


1.21
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.20 2016/01/06 22:27:39 millert Exp $	*/
a65 2
/* O_TMP_DIRECTORY	    4BSD */
	{"directory",	NULL,		OPT_STR,	0},
a237 1
	{"dir",		O_TMP_DIRECTORY},	/*     4BSD */
a332 11

	/*
	 * !!!
	 * Vi historically stored temporary files in /var/tmp.  We store them
	 * in /tmp by default, hoping it's a memory based file system.  There
	 * are two ways to change this -- the user can set either the directory
	 * option or the TMPDIR environmental variable.
	 */
	(void)snprintf(b1, sizeof(b1),
	    "directory=%s", (s = getenv("TMPDIR")) == NULL ? _PATH_TMP : s);
	OI(O_TMP_DIRECTORY, b1);
@


1.20
log
@Remove the message catalog DB.  This removes the msg_open() and
msg_close() functions along with the msgcat command.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.19 2015/11/24 10:28:14 bentley Exp $	*/
d434 1
a434 1
	    "031|Unable to set default %s option", optlist[optindx].name);
d473 1
a473 1
						    "032|Usage: %s", usage);
d524 1
a524 1
			    "291|set: the %s option may not be turned off");
d532 1
a532 1
			    "313|set: the %s option may never be turned on");
d539 1
a539 1
			    "034|set: [no]%s option doesn't take a value");
d593 1
a593 1
				    "035|set: %s option isn't a boolean");
d613 1
a613 1
					    "036|set: %s option: %s", p, t);
d617 1
a617 1
			    "037|set: %s option: %s: value overflow", p, t);
d634 1
a634 1
		    "038|set: %s option: %s is an illegal number", p, t);
d646 1
a646 1
			    "314|set: the %s option may never be set to 0");
d686 1
a686 1
				    "039|set: %s option isn't a boolean");
d792 1
a792 1
			    "305|No %s edit option specified");
d1070 1
a1070 1
	    "033|set: no %s option: 'set all' gives all option values");
@


1.19
log
@Turn on filename tab completion in vi by default.

From FreeBSD.

ok claudio@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.18 2014/11/14 20:27:03 tedu Exp $	*/
a122 2
/* O_MSGCAT	  4.4BSD */
	{"msgcat",	f_msgcat,	OPT_STR,	0},
a350 2
	(void)snprintf(b1, sizeof(b1), "msgcat=%s", _PATH_MSGCAT);
	OI(O_MSGCAT, b1);
@


1.18
log
@from natano:
_PATH_BSHELL, _PATH_SENDMAIL, _PATH_TMP and _PATH_TTY are defined in
<paths.h> and _PATH_SYSV_TTY is unused. All of them can be removed from
pathnames.h. The other defines can be made unconditionally.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.17 2014/11/12 04:28:41 bentley Exp $	*/
d350 1
@


1.17
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.16 2011/07/10 13:20:25 millert Exp $	*/
d23 1
@


1.16
log
@Rename O_DIRECTORY to O_TMP_DIRECTORY to avoid a namespace collision
with sys/fcntl.h.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.15 2009/11/22 17:12:40 nicm Exp $	*/
d283 1
a283 3
opts_init(sp, oargs)
	SCR *sp;
	int *oargs;
d447 1
a447 4
opts_set(sp, argv, usage)
	SCR *sp;
	ARGS *argv[];
	char *usage;
d748 1
a748 6
o_set(sp, opt, flags, str, val)
	SCR *sp;
	int opt;
	u_int flags;
	char *str;
	u_long val;
d787 1
a787 3
opts_empty(sp, off, silent)
	SCR *sp;
	int off, silent;
d807 1
a807 3
opts_dump(sp, type)
	SCR *sp;
	enum optdisp type;
d939 1
a939 3
opts_print(sp, op)
	SCR *sp;
	OPTLIST const *op;
d969 1
a969 3
opts_save(sp, fp)
	SCR *sp;
	FILE *fp;
d1024 1
a1024 2
opts_search(name)
	char *name;
d1069 1
a1069 3
opts_nomatch(sp, name)
	SCR *sp;
	char *name;
d1076 1
a1076 2
opts_abbcmp(a, b)
        const void *a, *b;
d1082 1
a1082 2
opts_cmp(a, b)
        const void *a, *b;
d1094 1
a1094 2
opts_copy(orig, sp)
	SCR *orig, *sp;
d1140 1
a1140 2
opts_free(sp)
	SCR *sp;
@


1.15
log
@Change the flash option to be off by default. Now that xterm has the flash
capability in terminfo, vi was using it instead of beeping, but it is too slow
for some machines.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.14 2009/10/27 23:59:47 deraadt Exp $	*/
d65 1
a65 1
/* O_DIRECTORY	    4BSD */
d241 1
a241 1
	{"dir",		O_DIRECTORY},		/*     4BSD */
d349 1
a349 1
	OI(O_DIRECTORY, b1);
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.13 2006/03/11 07:04:53 ray Exp $	*/
d80 1
a80 1
	{"flash",	NULL,		OPT_1BOOL,	0},
@


1.13
log
@Fixes the `optindx' might be used uninitialized in this function
warning, fixes a spacing nit in a macro, and cleans up a very bad
preprocessor abuse (``if LF_ISSET(OS_DEF)''!)

optindx turns out to be the index number of the gigantic option
list at the beginning of the file.  All we need to do is set it
before every ``goto err''.

The first four are global options, which you can just set optindx
to the second argument of o_set().

The last one is in a loop that uses cnt as the index.  Since that
is cnt's only use, I just removed cnt and used optindx instead.
optindx is always updated and we use one less variable.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.12 2006/01/08 21:05:39 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)options.c	10.51 (Berkeley) 10/14/96";
#endif /* not lint */
@


1.12
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.11 2003/04/07 21:13:54 deraadt Exp $	*/
d294 1
a294 1
	int cnt, optindx;
d309 1
a309 1
		 optindx = indx;					\
d318 2
a319 1
	if (o_set(sp, O_TERM, 0, NULL, GO_TERM))
d321 1
d323 2
a324 1
	if (o_set(sp, O_LINES, 0, NULL, GO_LINES))
d326 1
d328 2
a329 1
	if (o_set(sp, O_COLUMNS, 0, NULL, GO_COLUMNS))
d331 1
d333 2
a334 1
	if (o_set(sp, O_SECURE, 0, NULL, GO_SECURE))
d336 1
d410 1
a410 1
	for (op = optlist, cnt = 0; op->name != NULL; ++op, ++cnt)
d415 2
a416 2
			O_SET(sp, cnt);
			O_D_SET(sp, cnt);
d419 1
a419 1
			o_set(sp, cnt, OS_DEF, NULL, O_VAL(sp, cnt));
d422 2
a423 2
			if (O_STR(sp, cnt) != NULL && o_set(sp, cnt,
			    OS_DEF | OS_NOFREE | OS_STRDUP, O_STR(sp, cnt), 0))
d777 1
a777 1
	if LF_ISSET(OS_DEF)
@


1.11
log
@replace strcpy calls that got inlined by gcc; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.10 2002/02/16 21:27:57 millert Exp $	*/
d305 2
a306 2
	if (str != b1)		/* GCC puts strings in text-space. */	\
		(void)strlcpy(b1, str, sizeof b1);			\
d557 1
a557 1
			if (!F_ISSET(op, OPT_ALWAYS))
d565 1
d576 2
a577 2
			if (op->func != NULL &&
			    op->func(sp, spo, NULL, &turnoff) ||
d671 2
a672 2
			if (op->func != NULL &&
			    op->func(sp, spo, sep, &value) ||
d718 2
a719 2
			if (op->func != NULL &&
			    op->func(sp, spo, sep, NULL) ||
d872 2
a873 2
				    O_D_STR(sp, cnt) != NULL &&
				    !strcmp(O_STR(sp, cnt), O_D_STR(sp, cnt)))
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 2001/01/29 01:58:31 niklas Exp $	*/
d306 1
a306 1
		(void)strcpy(b1, str);					\
@


1.9
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 3
a38 3
static int	 	 opts_abbcmp __P((const void *, const void *));
static int	 	 opts_cmp __P((const void *, const void *));
static int	 	 opts_print __P((SCR *, OPTLIST const *));
d284 1
a284 1
 * PUBLIC: int opts_init __P((SCR *, int *));
d442 1
a442 1
 * PUBLIC: int opts_set __P((SCR *, ARGS *[], char *));
d745 1
a745 1
 * PUBLIC: int o_set __P((SCR *, int, u_int, char *, u_long));
d789 1
a789 1
 * PUBLIC: int opts_empty __P((SCR *, int, int));
d811 1
a811 1
 * PUBLIC: void opts_dump __P((SCR *, enum optdisp));
d977 1
a977 1
 * PUBLIC: int opts_save __P((SCR *, FILE *));
d1034 1
a1034 1
 * PUBLIC: OPTLIST const *opts_search __P((char *));
d1080 1
a1080 1
 * PUBLIC: void opts_nomatch __P((SCR *, char *));
d1109 1
a1109 1
 * PUBLIC: int opts_copy __P((SCR *, SCR *));
d1156 1
a1156 1
 * PUBLIC: void opts_free __P((SCR *));
@


1.8
log
@Fix noprint/print/octal options; from NetBSD.
reviewed by millert@@
@
text
@d1 2
@


1.7
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d127 1
a127 1
	{"noprint",	f_print,	OPT_STR,	0},
d131 1
a131 1
	{"octal",	f_print,	OPT_0BOOL,	0},
d141 1
a141 1
	{"print",	f_print,	OPT_STR,	0},
d564 8
d582 3
a584 2
			/* Set the value. */
			if (turnoff)
d586 1
a586 1
			else
d588 1
d659 8
d677 3
a679 2
			/* Set the value. */
			if (o_set(sp, offset, 0, NULL, value))
d681 1
d706 8
d724 3
a726 2
			/* Set the value. */
			if (o_set(sp, offset, OS_STRDUP, sep, 0))
d728 1
@


1.6
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)options.c	10.50 (Berkeley) 10/1/96";
a496 1

d498 1
a498 2
			msgq_str(sp, M_ERR, name,
		    "033|set: no %s option: 'set all' gives all option values");
d1042 15
@


1.5
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)options.c	10.49 (Berkeley) 9/15/96";
d397 2
a398 2
	 * Set boolean default values, and copy all settings into the
	 * the default information.
d412 2
a413 2
			if (O_STR(sp, cnt) != NULL && o_set(sp,
			    cnt, OS_DEF | OS_STRDUP, O_STR(sp, cnt), 0))
d699 1
a699 1
			if (o_set(sp, offset, OS_FREE | OS_STRDUP, sep, 0))
a736 1

d738 4
a741 4
	if LF_ISSET(OS_DEF) {
		if (LF_ISSET(OS_FREE) && op->o_def.str != NULL)
			free(op->o_def.str);
		if (LF_ISSET(OS_STR | OS_STRDUP))
d743 1
a743 1
		else
d745 4
a748 4
	} else {
		if (LF_ISSET(OS_FREE) && op->o_cur.str != NULL)
			free(op->o_cur.str);
		if (LF_ISSET(OS_STR | OS_STRDUP))
d750 1
a750 1
		else
a751 1
	}
d1086 2
a1087 2
			o_set(sp, cnt, OS_STR, NULL, 0);
			o_set(sp, cnt, OS_DEF | OS_STR, NULL, 0);
d1092 2
a1093 2
		if (o_set(sp, cnt, OS_STRDUP, O_STR(sp, cnt), 0)) {
			o_set(sp, cnt, OS_DEF | OS_STR, NULL, 0);
d1098 2
a1099 2
		if (O_D_STR(sp, cnt) != NULL &&
		    o_set(sp, cnt, OS_DEF | OS_STRDUP, O_D_STR(sp, cnt), 0)) {
@


1.4
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)options.c	10.48 (Berkeley) 8/10/96";
d1075 1
a1075 1
	memmove(sp->opts, orig->opts, sizeof(orig->opts));
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)options.c	10.46 (Berkeley) 6/26/96";
d138 2
d220 1
a220 1
	{"windowname",	f_windowname,	OPT_0BOOL,	0},
d351 2
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)options.c	10.43 (Berkeley) 5/16/96";
d217 2
d259 1
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)options.c	8.66 (Berkeley) 8/17/94";
a24 1
#include <signal.h>
a27 1
#include <termios.h>
d30 3
a32 7
#include "compat.h"
#include <db.h>
#include <regex.h>
#include <pathnames.h>

#include "vi.h"
#include "excmd.h"
a35 1
static OPTLIST const	*opts_prefix __P((char *));
d46 1
a46 1
static OPTLIST const optlist[] = {
d55 2
d60 3
a62 1
	{"cdpath",	f_cdpath,	OPT_STR,	0},
a66 2
/* O_DIGRAPH	  XXX: Elvis */
	{"digraph",	NULL,		OPT_0BOOL,	0},
d71 2
d78 3
a80 1
	{"extended",	NULL,		OPT_0BOOL,	0},
d85 2
d88 1
a88 1
	{"ignorecase",	NULL,		OPT_0BOOL,	0},
d92 1
a92 1
	{"leftright",	f_leftright,	OPT_0BOOL,	0},
d95 4
a98 5
/* O_LISP	    4BSD */
/*
 * XXX
 * When the lisp option is implemented, delete
 * the OPT_NOSAVE flag, so that :mkexrc dumps it.
d102 7
a108 1
	{"list",	f_list,		OPT_0BOOL,	0},
d114 14
a127 5
	{"mesg",	f_mesg,		OPT_1BOOL,	0},
/* O_META	  4.4BSD */
	{"meta",	NULL,		OPT_STR,	0},
/* O_MODELINE	    4BSD */
	{"modeline",	f_modeline,	OPT_0BOOL,	0},
d129 1
a129 1
	{"number",	f_number,	OPT_0BOOL,	0},
d131 1
a131 1
	{"octal",	f_octal,	OPT_0BOOL,	0},
d138 2
d143 1
a143 1
	{"readonly",	f_readonly,	OPT_0BOOL,	0},
d151 1
a151 1
	{"report",	NULL,		OPT_NUM,	OPT_NOSTR},
d156 2
d160 2
d164 2
d167 1
a167 3
	{"shiftwidth",	f_shiftwidth,	OPT_NUM,	0},
/* O_SHOWDIRTY	  4.4BSD */
	{"showdirty",	NULL,		OPT_0BOOL,	0},
d173 1
a173 1
	{"sidescroll",	NULL,		OPT_NUM,	0},
d176 9
a184 2
/* O_SOURCEANY	    4BSD (undocumented) */
	{"sourceany",	f_sourceany,	OPT_0BOOL,	0},
d186 1
a186 1
	{"tabstop",	f_tabstop,	OPT_NUM,	0},
d188 1
a188 1
	{"taglength",	NULL,		OPT_NUM,	OPT_NOSTR},
d190 7
a196 3
	{"tags",	f_tags,		OPT_STR,	0},
/* O_TERM	    4BSD */
	{"term",	f_term,		OPT_STR,	OPT_NOSAVE},
d208 1
a208 1
	{"w1200",	f_w1200,	OPT_NUM,	OPT_NEVER|OPT_NOSAVE},
d210 1
a210 1
	{"w300",	f_w300,		OPT_NUM,	OPT_NEVER|OPT_NOSAVE},
d212 1
a212 1
	{"w9600",	f_w9600,	OPT_NUM,	OPT_NEVER|OPT_NOSAVE},
d217 2
d220 1
a220 1
	{"wrapmargin",	NULL,		OPT_NUM,	OPT_NOSTR},
d267 1
d275 3
a277 2
 *	Initialize some of the options.  Since the user isn't really
 *	"setting" these variables, don't set their OPT_SET bits.
d280 1
a280 1
opts_init(sp)
d282 1
d287 1
a287 1
	int cnt;
a290 1
	a.len = 0;
d292 1
a292 1
	b.len = 0;
d296 2
a297 1
#define	SET_DEF(opt, str) {						\
d301 3
a303 4
	if (opts_set(sp, NULL, argv)) {					\
		msgq(sp, M_ERR,						\
		    "Unable to set default %s option", optlist[opt]);	\
		return (1);						\
a304 1
	F_CLR(&sp->opts[opt], OPT_SET);					\
d306 22
a327 10
	/* Set default values. */
	for (op = optlist, cnt = 0; op->name != NULL; ++op, ++cnt)
		if (op->type == OPT_0BOOL)
			O_CLR(sp, cnt);
		else if (op->type == OPT_1BOOL)
			O_SET(sp, cnt);

	(void)snprintf(b1, sizeof(b1), "cdpath=%s",
	    (s = getenv("CDPATH")) == NULL ? ":" : s);
	SET_DEF(O_CDPATH, b1);
d336 10
a345 8
	(void)snprintf(b1, sizeof(b1), "directory=%s",
	    (s = getenv("TMPDIR")) == NULL ? _PATH_TMP : s);
	SET_DEF(O_DIRECTORY, b1);
	SET_DEF(O_KEYTIME, "keytime=6");
	SET_DEF(O_MATCHTIME, "matchtime=7");
	SET_DEF(O_META, "meta=~{[*?$`'\"\\");
	SET_DEF(O_REPORT, "report=5");
	SET_DEF(O_PARAGRAPHS, "paragraphs=IPLPPPQPP LIpplpipbp");
d347 9
a355 8
	SET_DEF(O_RECDIR, b1);
	SET_DEF(O_SECTIONS, "sections=NHSHH HUnhsh");
	(void)snprintf(b1, sizeof(b1), "shell=%s",
	    (s = getenv("SHELL")) == NULL ? _PATH_BSHELL : s);
	SET_DEF(O_SHELL, b1);
	SET_DEF(O_SHIFTWIDTH, "shiftwidth=8");
	SET_DEF(O_SIDESCROLL, "sidescroll=16");
	SET_DEF(O_TABSTOP, "tabstop=8");
d357 1
a357 4
	SET_DEF(O_TAGS, b1);
	(void)snprintf(b1, sizeof(b1), "term=%s",
	    (s = getenv("TERM")) == NULL ? "unknown" : s);
	SET_DEF(O_TERM, b1);
d361 2
a362 3
	 * Initialize ^D, ^U scrolling value here, after TERM.  (We didn't
	 * have the options information when the screen was initialized.)
	 * Initializing term should have created a LINES/COLUMNS value.
d364 4
a367 3
	sp->defscroll = O_VAL(sp, O_LINES) / 2;
	(void)snprintf(b1, sizeof(b1), "scroll=%ld", sp->defscroll);
	SET_DEF(O_SCROLL, b1);
d374 3
d378 2
a379 1
	v = baud_from_bval(sp);
d387 1
a387 1
	SET_DEF(O_WINDOW, b1);
d389 23
a411 1
	SET_DEF(O_WRAPMARGIN, "wrapmargin=0");
d414 4
a417 2
	 * By default, the historic vi always displayed information
	 * about two options, redraw and term.  Term seems sufficient.
d419 2
a420 1
	F_SET(&sp->opts[O_TERM], OPT_SET);
d422 5
d432 2
d436 1
a436 1
opts_set(sp, usage, argv)
d438 1
a439 1
	ARGS *argv[];
d442 1
a442 1
	OABBREV atmp, *ap;
a443 1
	OPTLIST otmp;
d446 2
a447 2
	int ch, equals, offset, qmark, rval;
	char *endp, *name, *p, *sep; 
d466 2
a467 2
						msgq(sp,
						    M_ERR, "Usage: %s", usage);
d483 3
a485 18
		/* Check list of abbreviations. */
		atmp.name = name;
		if ((ap = bsearch(&atmp, abbrev,
		    sizeof(abbrev) / sizeof(OABBREV) - 1,
		    sizeof(OABBREV), opts_abbcmp)) != NULL) {
			op = optlist + ap->offset;
			goto found;
		}

		/* Check list of options. */
		otmp.name = name;
		if ((op = bsearch(&otmp, optlist,
		    sizeof(optlist) / sizeof(OPTLIST) - 1,
		    sizeof(OPTLIST), opts_cmp)) != NULL)
			goto found;

		/* Try the name without any leading "no". */
		if (name[0] == 'n' && name[1] == 'o') {
d488 2
a489 2
		} else
			goto prefix;
d491 4
a494 23
		/* Check list of abbreviations. */
		atmp.name = name;
		if ((ap = bsearch(&atmp, abbrev,
		    sizeof(abbrev) / sizeof(OABBREV) - 1,
		    sizeof(OABBREV), opts_abbcmp)) != NULL) {
			op = optlist + ap->offset;
			goto found;
		}

		/* Check list of options. */
		otmp.name = name;
		if ((op = bsearch(&otmp, optlist,
		    sizeof(optlist) / sizeof(OPTLIST) - 1,
		    sizeof(OPTLIST), opts_cmp)) != NULL)
			goto found;

		/* Check for prefix match. */
prefix:		op = opts_prefix(name);

found:		if (op == NULL) {
			msgq(sp, M_ERR,
			    "no %s option: 'set all' gives all option values",
			    name);
d517 16
d534 3
a536 3
				msgq(sp, M_ERR,
				    "set: [no]%s option doesn't take a value",
				    name);
d545 12
a556 4
			if (op->func != NULL) {
				if (op->func(sp, spo, NULL, turnoff)) {
					rval = 1;
					break;
d558 13
a570 1
			} else if (turnoff)
d574 1
a574 1
			goto change;
a575 7
			/*
			 * !!!
			 * Extension to historic vi.  If the OPT_NOSTR flag is
			 * set, a numeric option may be turned off by using a
			 * "no" prefix, e.g. "nowrapmargin".  (We assume that
			 * setting the value to 0 turns a numeric option off.)
			 */
d577 3
a579 6
				if (F_ISSET(op, OPT_NOSTR)) {
					value = 0;
					goto nostr;
				}
				msgq(sp, M_ERR,
				    "set: %s option isn't a boolean", name);
d588 27
a614 1
			value = strtol(sep, &endp, 10);
d616 2
d619 14
a632 1
				    "set %s: illegal number %s", name, sep);
d635 23
a657 8
nostr:			if (op->func != NULL) {
				if (op->func(sp, spo, sep, value)) {
					rval = 1;
					break;
				}
			} else
				O_VAL(sp, offset) = value;
			goto change;
d660 3
a662 2
				msgq(sp, M_ERR,
				    "set: %s option isn't a boolean", name);
d671 18
a688 14
			if (op->func != NULL) {
				if (op->func(sp, spo, sep, (u_long)0)) {
					rval = 1;
					break;
				}
			} else {
				if (F_ISSET(&sp->opts[offset], OPT_ALLOCATED))
					free(O_STR(sp, offset));
				if ((O_STR(sp, offset) = strdup(sep)) == NULL) {
					msgq(sp, M_SYSERR, NULL);
					rval = 1;
					break;
				} else
					F_SET(&sp->opts[offset], OPT_ALLOCATED);
d690 4
a693 3
change:			if (sp->s_optchange != NULL)
				(void)sp->s_optchange(sp, offset);
			F_SET(&sp->opts[offset], OPT_SET);
d705 68
d775 2
a789 12
	 * XXX
	 * It's possible to get here by putting "set option" in the
	 * .exrc file.  I can't think of a clean way to layer this,
	 * or a reasonable check to make, so we block it here.
	 */
	if (sp->stdfp == NULL) {
		msgq(sp, M_ERR,
		    "Option display requires that the screen be initialized");
		return;
	}

	/*
d796 1
a796 1
	 * Find a column width we can live with.
d798 2
a799 2
	for (cnt = 6; cnt > 1; --cnt) {
		colwidth = (sp->cols - 1) / cnt & ~(STANDARD_TAB - 1);
d803 1
d816 2
a817 2
		/* If OPT_NEVER set, it's never displayed. */
		if (F_ISSET(op, OPT_NEVER))
d824 17
a840 2
			if (!F_ISSET(&sp->opts[cnt], OPT_SET))
				continue;
a848 1
			/* NOTREACHED */
d865 3
a867 1
			curlen += strlen(O_STR(sp, cnt)) + 3;
d870 2
a871 2
		/* Offset by two so there's a gap. */
		if (curlen < colwidth - 2)
d878 1
a878 2
		/* Figure out the number of columns. */
		numcols = (sp->cols - 1) / colwidth;
d892 2
a893 2
				(void)ex_printf(EXCOOKIE,
				    "%*s", (int)(colwidth - cnt), "");
d896 1
a896 1
				(void)ex_printf(EXCOOKIE, "\n");
d903 1
a903 1
			(void)ex_printf(EXCOOKIE, "\n");
d905 1
a905 1
	(void)ex_printf(EXCOOKIE, "\n");
d924 1
a924 1
		curlen += ex_printf(EXCOOKIE,
d928 1
a928 2
		curlen += ex_printf(EXCOOKIE,
		     "%s=%ld", op->name, O_VAL(sp, offset));
d931 2
a932 2
		curlen += ex_printf(EXCOOKIE,
		    "%s=\"%s\"", op->name, O_STR(sp, offset));
d941 2
d967 1
a967 1
			    "set %s=%-3d\n", op->name, O_VAL(sp, cnt));
d970 2
d988 1
a988 1
			msgq(sp, M_ERR, "I/O error: %s", strerror(errno));
d995 5
a999 4
/*
 * opts_prefix --
 *	Check to see if the name is the prefix of one (and only one)
 *	option.  If so, return the option.
d1001 2
a1002 2
static OPTLIST const *
opts_prefix(name)
d1005 3
a1007 1
	OPTLIST const *op, *save_op;
d1010 16
a1025 1
	save_op = NULL;
d1027 1
a1027 1
	for (op = optlist; op->name != NULL; ++op) {
d1033 1
a1033 1
			if (save_op != NULL)
d1035 1
a1035 1
			save_op = op;
d1038 1
a1038 1
	return (save_op);
a1055 18
 * opts_free --
 *	Free all option strings
 */
void
opts_free(sp)
	SCR *sp;
{
	int cnt;
	char *p;

	for (cnt = 0; cnt < O_OPTIONCOUNT; ++cnt)
		if (F_ISSET(&sp->opts[cnt], OPT_ALLOCATED)) {
			p = O_STR(sp, cnt);
			FREE(p, strlen(p) + 1);
		}
}

/*
d1058 2
d1065 1
a1065 2
	OPTION *op;
	int cnt;
d1070 27
a1096 10
	/*
	 * Allocate copies of the strings -- keep trying to reallocate
	 * after ENOMEM failure, otherwise end up with more than one
	 * screen referencing the original memory.
	 */
	for (op = sp->opts, cnt = 0; cnt < O_OPTIONCOUNT; ++cnt, ++op)
		if (F_ISSET(&sp->opts[cnt], OPT_ALLOCATED) &&
		    (O_STR(sp, cnt) = strdup(O_STR(sp, cnt))) == NULL) {
			msgq(orig, M_SYSERR, NULL);
			return (1);
d1098 25
a1122 1
	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
