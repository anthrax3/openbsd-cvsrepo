head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.22
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.20
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.16
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.14
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.12
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.34
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.30
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.28
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.26
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.24
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.22
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.20
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.18
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.16
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.14
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.12
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.10;
commitid	adBvXLg05bJxz6yx;

1.10
date	2016.01.06.22.27.39;	author millert;	state Exp;
branches;
next	1.9;
commitid	WTL2xUDqwK7LLJKC;

1.9
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.8;
commitid	06bi6U3x4gFFf2G1;

1.8
date	2014.10.08.00.53.45;	author dlg;	state Exp;
branches;
next	1.7;
commitid	e4kguqilQ0qGEk6A;

1.7
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.31;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.24;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@/*	$OpenBSD: options_f.c,v 1.10 2016/01/06 22:27:39 millert Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"

/*
 * PUBLIC: int f_altwerase(SCR *, OPTION *, char *, u_long *);
 */
int
f_altwerase(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	if (!*valp)
		O_CLR(sp, O_TTYWERASE);
	return (0);
}

/*
 * PUBLIC: int f_columns(SCR *, OPTION *, char *, u_long *);
 */
int
f_columns(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	/* Validate the number. */
	if (*valp < MINIMUM_SCREEN_COLS) {
		msgq(sp, M_ERR, "Screen columns too small, less than %d",
		    MINIMUM_SCREEN_COLS);
		return (1);
	}

	/*
	 * !!!
	 * It's not uncommon for allocation of huge chunks of memory to cause
	 * core dumps on various systems.  So, we prune out numbers that are
	 * "obviously" wrong.  Vi will not work correctly if it has the wrong
	 * number of lines/columns for the screen, but at least we don't drop
	 * core.
	 */
#define	MAXIMUM_SCREEN_COLS	768
	if (*valp > MAXIMUM_SCREEN_COLS) {
		msgq(sp, M_ERR, "Screen columns too large, greater than %d",
		    MAXIMUM_SCREEN_COLS);
		return (1);
	}
	return (0);
}

/*
 * PUBLIC: int f_lines(SCR *, OPTION *, char *, u_long *);
 */
int
f_lines(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	/* Validate the number. */
	if (*valp < MINIMUM_SCREEN_ROWS) {
		msgq(sp, M_ERR, "Screen lines too small, less than %d",
		    MINIMUM_SCREEN_ROWS);
		return (1);
	}

	/*
	 * !!!
	 * It's not uncommon for allocation of huge chunks of memory to cause
	 * core dumps on various systems.  So, we prune out numbers that are
	 * "obviously" wrong.  Vi will not work correctly if it has the wrong
	 * number of lines/columns for the screen, but at least we don't drop
	 * core.
	 */
#define	MAXIMUM_SCREEN_ROWS	500
	if (*valp > MAXIMUM_SCREEN_ROWS) {
		msgq(sp, M_ERR, "Screen lines too large, greater than %d",
		    MAXIMUM_SCREEN_ROWS);
		return (1);
	}

	/*
	 * Set the value, and the related scroll value.  If no window
	 * value set, set a new default window.
	 */
	o_set(sp, O_LINES, 0, NULL, *valp);
	if (*valp == 1) {
		sp->defscroll = 1;

		if (O_VAL(sp, O_WINDOW) == O_D_VAL(sp, O_WINDOW) ||
		    O_VAL(sp, O_WINDOW) > *valp) {
			o_set(sp, O_WINDOW, 0, NULL, 1);
			o_set(sp, O_WINDOW, OS_DEF, NULL, 1);
		}
	} else {
		sp->defscroll = (*valp - 1) / 2;

		if (O_VAL(sp, O_WINDOW) == O_D_VAL(sp, O_WINDOW) ||
		    O_VAL(sp, O_WINDOW) > *valp) {
			o_set(sp, O_WINDOW, 0, NULL, *valp - 1);
			o_set(sp, O_WINDOW, OS_DEF, NULL, *valp - 1);
		}
	}
	return (0);
}

/*
 * PUBLIC: int f_lisp(SCR *, OPTION *, char *, u_long *);
 */
int
f_lisp(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	msgq(sp, M_ERR, "The lisp option is not implemented");
	return (0);
}

/*
 * PUBLIC: int f_paragraph(SCR *, OPTION *, char *, u_long *);
 */
int
f_paragraph(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	if (strlen(str) & 1) {
		msgq(sp, M_ERR,
		    "The paragraph option must be in two character groups");
		return (1);
	}
	return (0);
}

/*
 * PUBLIC: int f_print(SCR *, OPTION *, char *, u_long *);
 */
int
f_print(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	/* Reinitialize the key fast lookup table. */
	v_key_ilookup(sp);

	/* Reformat the screen. */
	F_SET(sp, SC_SCR_REFORMAT);
	return (0);
}

/*
 * PUBLIC: int f_readonly(SCR *, OPTION *, char *, u_long *);
 */
int
f_readonly(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	/*
	 * !!!
	 * See the comment in exf.c.
	 */
	if (*valp)
		F_CLR(sp, SC_READONLY);
	else
		F_SET(sp, SC_READONLY);
	return (0);
}

/*
 * PUBLIC: int f_recompile(SCR *, OPTION *, char *, u_long *);
 */
int
f_recompile(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	if (F_ISSET(sp, SC_RE_SEARCH)) {
		regfree(&sp->re_c);
		F_CLR(sp, SC_RE_SEARCH);
	}
	if (F_ISSET(sp, SC_RE_SUBST)) {
		regfree(&sp->subre_c);
		F_CLR(sp, SC_RE_SUBST);
	}
	return (0);
}

/*
 * PUBLIC: int f_reformat(SCR *, OPTION *, char *, u_long *);
 */
int
f_reformat(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	F_SET(sp, SC_SCR_REFORMAT);
	return (0);
}

/*
 * PUBLIC: int f_section(SCR *, OPTION *, char *, u_long *);
 */
int
f_section(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	if (strlen(str) & 1) {
		msgq(sp, M_ERR,
		    "The section option must be in two character groups");
		return (1);
	}
	return (0);
}

/*
 * PUBLIC: int f_ttywerase(SCR *, OPTION *, char *, u_long *);
 */
int
f_ttywerase(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	if (!*valp)
		O_CLR(sp, O_ALTWERASE);
	return (0);
}

/*
 * PUBLIC: int f_w300(SCR *, OPTION *, char *, u_long *);
 */
int
f_w300(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	u_long v;

	/* Historical behavior for w300 was < 1200. */
	if (sp->gp->scr_baud(sp, &v))
		return (1);
	if (v >= 1200)
		return (0);

	return (f_window(sp, op, str, valp));
}

/*
 * PUBLIC: int f_w1200(SCR *, OPTION *, char *, u_long *);
 */
int
f_w1200(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	u_long v;

	/* Historical behavior for w1200 was == 1200. */
	if (sp->gp->scr_baud(sp, &v))
		return (1);
	if (v < 1200 || v > 4800)
		return (0);

	return (f_window(sp, op, str, valp));
}

/*
 * PUBLIC: int f_w9600(SCR *, OPTION *, char *, u_long *);
 */
int
f_w9600(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	u_long v;

	/* Historical behavior for w9600 was > 1200. */
	if (sp->gp->scr_baud(sp, &v))
		return (1);
	if (v <= 4800)
		return (0);

	return (f_window(sp, op, str, valp));
}

/*
 * PUBLIC: int f_window(SCR *, OPTION *, char *, u_long *);
 */
int
f_window(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	if (*valp >= O_VAL(sp, O_LINES) - 1 &&
	    (*valp = O_VAL(sp, O_LINES) - 1) == 0)
		*valp = 1;
	return (0);
}
@


1.10
log
@Remove the message catalog DB.  This removes the msg_open() and
msg_close() functions along with the msgcat command.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: options_f.c,v 1.9 2014/11/12 04:28:41 bentley Exp $	*/
d48 1
a48 1
		msgq(sp, M_ERR, "040|Screen columns too small, less than %d",
d63 1
a63 1
		msgq(sp, M_ERR, "041|Screen columns too large, greater than %d",
d78 1
a78 1
		msgq(sp, M_ERR, "042|Screen lines too small, less than %d",
d93 1
a93 1
		msgq(sp, M_ERR, "043|Screen lines too large, greater than %d",
d129 1
a129 1
	msgq(sp, M_ERR, "044|The lisp option is not implemented");
d141 1
a141 1
		    "048|The paragraph option must be in two character groups");
d213 1
a213 1
		    "049|The section option must be in two character groups");
@


1.9
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options_f.c,v 1.8 2014/10/08 00:53:45 dlg Exp $	*/
a129 10
	return (0);
}

/*
 * PUBLIC: int f_msgcat(SCR *, OPTION *, char *, u_long *);
 */
int
f_msgcat(SCR *sp, OPTION *op, char *str, u_long *valp)
{
	(void)msg_open(sp, str);
@


1.8
log
@bump max columns out to 768. screens are getting bigger...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options_f.c,v 1.7 2009/10/27 23:59:47 deraadt Exp $	*/
d33 1
a33 5
f_altwerase(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d44 1
a44 5
f_columns(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d74 1
a74 5
f_lines(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d127 1
a127 5
f_lisp(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d137 1
a137 5
f_msgcat(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d147 1
a147 5
f_paragraph(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d161 1
a161 5
f_print(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d175 1
a175 5
f_readonly(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d192 1
a192 5
f_recompile(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d209 1
a209 5
f_reformat(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d219 1
a219 5
f_section(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d233 1
a233 5
f_ttywerase(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d244 1
a244 5
f_w300(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d261 1
a261 5
f_w1200(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d278 1
a278 5
f_w9600(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
d295 1
a295 5
f_window(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
@


1.7
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: options_f.c,v 1.6 2002/02/16 21:27:57 millert Exp $	*/
d69 1
a69 1
#define	MAXIMUM_SCREEN_COLS	500
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: options_f.c,v 1.5 2001/01/29 01:58:31 niklas Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)options_f.c	10.25 (Berkeley) 7/12/96";
#endif /* not lint */
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 * PUBLIC: int f_altwerase __P((SCR *, OPTION *, char *, u_long *));
d49 1
a49 1
 * PUBLIC: int f_columns __P((SCR *, OPTION *, char *, u_long *));
d83 1
a83 1
 * PUBLIC: int f_lines __P((SCR *, OPTION *, char *, u_long *));
d140 1
a140 1
 * PUBLIC: int f_lisp __P((SCR *, OPTION *, char *, u_long *));
d154 1
a154 1
 * PUBLIC: int f_msgcat __P((SCR *, OPTION *, char *, u_long *));
d168 1
a168 1
 * PUBLIC: int f_paragraph __P((SCR *, OPTION *, char *, u_long *));
d186 1
a186 1
 * PUBLIC: int f_print __P((SCR *, OPTION *, char *, u_long *));
d204 1
a204 1
 * PUBLIC: int f_readonly __P((SCR *, OPTION *, char *, u_long *));
d225 1
a225 1
 * PUBLIC: int f_recompile __P((SCR *, OPTION *, char *, u_long *));
d246 1
a246 1
 * PUBLIC: int f_reformat __P((SCR *, OPTION *, char *, u_long *));
d260 1
a260 1
 * PUBLIC: int f_section __P((SCR *, OPTION *, char *, u_long *));
d278 1
a278 1
 * PUBLIC: int f_ttywerase __P((SCR *, OPTION *, char *, u_long *));
d293 1
a293 1
 * PUBLIC: int f_w300 __P((SCR *, OPTION *, char *, u_long *));
d314 1
a314 1
 * PUBLIC: int f_w1200 __P((SCR *, OPTION *, char *, u_long *));
d335 1
a335 1
 * PUBLIC: int f_w9600 __P((SCR *, OPTION *, char *, u_long *));
d356 1
a356 1
 * PUBLIC: int f_window __P((SCR *, OPTION *, char *, u_long *));
@


1.4
log
@nvi 1.73
@
text
@d1 2
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)options_f.c	10.24 (Berkeley) 6/26/96";
a365 27
	return (0);
}

/*
 * PUBLIC: int f_windowname __P((SCR *, OPTION *, char *, u_long *));
 */
int
f_windowname(sp, op, str, valp)
	SCR *sp;
	OPTION *op;
	char *str;
	u_long *valp;
{
	/*
	 * XXX
	 * The cl_rename routine depends on the O_WINDOWNAME value being
	 * already set, because it's a destructive action, and it wants
	 * to make sure we have permission.  This doesn't apply to other
	 * screen types where the naming won't be destructive, so we don't
	 * want to move the check up out of the screen code.
	 */
	if (*valp)
		O_CLR(sp, O_WINDOWNAME);
	else
		O_SET(sp, O_WINDOWNAME);

	(void)sp->gp->scr_rename(sp);
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)options_f.c	10.23 (Berkeley) 5/4/96";
d366 27
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)options_f.c	8.36 (Berkeley) 8/17/94";
a18 1
#include <sys/time.h>
a23 1
#include <signal.h>
a26 1
#include <termios.h>
d29 1
a29 19
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
#include "../ex/tag.h"

static int	opt_dup __P((SCR *, int, char *));
static int	opt_putenv __P((char *));

#define	DECL(f)								\
	int								\
	f(sp, op, str, val)						\
		SCR *sp;						\
		OPTION *op;						\
		char *str;						\
		u_long val;
#define	CALL(f)								\
	f(sp, op, str, val)
d31 9
a39 3
#define	turnoff	val

DECL(f_altwerase)
d41 1
a41 4
	if (turnoff)
		O_CLR(sp, O_ALTWERASE);
	else {
		O_SET(sp, O_ALTWERASE);
a42 1
	}
d46 9
a54 1
DECL(f_cdpath)
a55 7
	return (opt_dup(sp, O_CDPATH, str));
}

DECL(f_columns)
{
	char buf[25];

d57 2
a58 2
	if (val < MINIMUM_SCREEN_COLS) {
		msgq(sp, M_ERR, "Screen columns too small, less than %d",
d62 13
a74 3
	/* Set the columns value in the environment for curses. */
	(void)snprintf(buf, sizeof(buf), "COLUMNS=%lu", val);
	if (opt_putenv(buf))
d76 1
a76 9

	/* This is expensive, don't do it unless it's necessary. */
	if (O_VAL(sp, O_COLUMNS) == val)
		return (0);

	/* Set the value. */
	O_VAL(sp, O_COLUMNS) =  val;

	F_SET(sp, S_RESIZE);
d80 9
a88 11
DECL(f_leftright)
{
	if (turnoff)
		O_CLR(sp, O_LEFTRIGHT);
	else
		O_SET(sp, O_LEFTRIGHT);
	F_SET(sp, S_REFORMAT | S_REDRAW);
	return (0);
}

DECL(f_lines)
a89 2
	char buf[25];

d91 2
a92 2
	if (val < MINIMUM_SCREEN_ROWS) {
		msgq(sp, M_ERR, "Screen lines too small, less than %d",
a96 12
	/* Set the rows value in the environment for curses. */
	(void)snprintf(buf, sizeof(buf), "ROWS=%lu", val);
	if (opt_putenv(buf))
		return (1);

	/* This is expensive, don't do it unless it's necessary. */
	if (O_VAL(sp, O_LINES) == val)
		return (0);

	/* Set the value. */
	O_VAL(sp, O_LINES) = val;

d98 6
a103 2
	 * If no window value set, set a new default window and,
	 * optionally, a new scroll value.
d105 4
a108 35
	if (!F_ISSET(&sp->opts[O_WINDOW], OPT_SET)) {
		O_VAL(sp, O_WINDOW) = val - 1;
		if (!F_ISSET(&sp->opts[O_SCROLL], OPT_SET))
			O_VAL(sp, O_SCROLL) = val / 2;
	}

	F_SET(sp, S_RESIZE);
	return (0);
}

DECL(f_lisp)
{
	msgq(sp, M_ERR, "The lisp option is not implemented");
	return (0);
}

DECL(f_list)
{
	if (turnoff)
		O_CLR(sp, O_LIST);
	else
		O_SET(sp, O_LIST);

	F_SET(sp, S_REFORMAT | S_REDRAW);
	return (0);
}

DECL(f_mesg)
{
	struct stat sb;
	char *tty;

	/* Find the tty. */
	if ((tty = ttyname(STDERR_FILENO)) == NULL) {
		msgq(sp, M_ERR, "ttyname: %s", strerror(errno));
d112 12
a123 6
	/* Save the tty mode for later; only save it once. */
	if (!F_ISSET(sp->gp, G_SETMODE)) {
		F_SET(sp->gp, G_SETMODE);
		if (stat(tty, &sb) < 0) {
			msgq(sp, M_ERR, "%s: %s", tty, strerror(errno));
			return (1);
d125 2
a126 2
		sp->gp->origmode = sb.st_mode;
	}
d128 4
a131 5
	if (turnoff) {
		if (chmod(tty, sp->gp->origmode & ~S_IWGRP) < 0) {
			msgq(sp, M_ERR, "messages not turned off: %s: %s",
			    tty, strerror(errno));
			return (1);
a132 8
		O_CLR(sp, O_MESG);
	} else {
		if (chmod(tty, sp->gp->origmode | S_IWGRP) < 0) {
			msgq(sp, M_ERR, "messages not turned on: %s: %s",
			    tty, strerror(errno));
			return (1);
		}
		O_SET(sp, O_MESG);
d138 1
a138 6
 * f_modeline --
 *	This has been documented in historical systems as both "modeline"
 *	and as "modelines".  Regardless of the name, this option represents
 *	a security problem of mammoth proportions, not to mention a stunning
 *	example of what your intro CS professor referred to as the perils of
 *	mixing code and data.  Don't add it, or I will kill you.
d140 6
a145 1
DECL(f_modeline)
d147 1
a147 2
	if (!turnoff)
		msgq(sp, M_ERR, "The modeline(s) option may never be set");
d151 9
a159 1
DECL(f_number)
d161 1
a161 6
	if (turnoff)
		O_CLR(sp, O_NUMBER);
	else
		O_SET(sp, O_NUMBER);

	F_SET(sp, S_REFORMAT | S_REDRAW);
d165 9
a173 13
DECL(f_octal)
{
	if (turnoff)
		O_CLR(sp, O_OCTAL);
	else
		O_SET(sp, O_OCTAL);

	key_init(sp);
	F_SET(sp, S_REFORMAT | S_REDRAW);
	return (0);
}

DECL(f_paragraph)
d177 1
a177 1
		    "Paragraph options must be in sets of two characters");
d180 1
a180 1
	return (opt_dup(sp, O_PARAGRAPHS, str));
d183 9
a191 1
DECL(f_readonly)
d193 5
a197 9
	if (turnoff) {
		O_CLR(sp, O_READONLY);
		if (sp->frp != NULL)
			F_CLR(sp->frp, FR_RDONLY);
	} else {
		O_SET(sp, O_READONLY);
		if (sp->frp != NULL)
			F_SET(sp->frp, FR_RDONLY);
	}
d201 9
a209 1
DECL(f_section)
d211 9
a219 6
	if (strlen(str) & 1) {
		msgq(sp, M_ERR,
		    "Section options must be in sets of two characters");
		return (1);
	}
	return (opt_dup(sp, O_SECTIONS, str));
d222 9
a230 1
DECL(f_shiftwidth)
d232 7
a238 3
	if (val == 0) {
		msgq(sp, M_ERR, "The shiftwidth can't be set to 0");
		return (1);
a239 1
	O_VAL(sp, O_SHIFTWIDTH) = val;
d244 1
a244 6
 * f_sourceany --
 *	Historic vi, on startup, source'd $HOME/.exrc and ./.exrc, if they
 *	were owned by the user.  The sourceany option was an undocumented
 *	feature of historic vi which permitted the startup source'ing of
 *	.exrc files the user didn't own.  This is an obvious security problem,
 *	and we ignore the option.
d246 6
a251 1
DECL(f_sourceany)
d253 1
a253 2
	if (!turnoff)
		msgq(sp, M_ERR, "The sourceany option may never be set");
d257 9
a265 1
DECL(f_tabstop)
d267 1
a267 6
	if (val == 0) {
		msgq(sp, M_ERR, "Tab stops can't be set to 0");
		return (1);
	}
#define	MAXTABSTOP	20
	if (val > MAXTABSTOP) {
d269 1
a269 1
		    "Tab stops can't be larger than %d", MAXTABSTOP);
a271 3
	O_VAL(sp, O_TABSTOP) = val;

	F_SET(sp, S_REFORMAT | S_REDRAW);
d275 9
a283 1
DECL(f_tags)
d285 2
a286 14
	return (opt_dup(sp, O_TAGS, str));
}

DECL(f_term)
{
	char buf[256];

	if (opt_dup(sp, O_TERM, str))
		return (1);

	/* Set the terminal value in the environment for curses. */
	(void)snprintf(buf, sizeof(buf), "TERM=%s", str);
	if (opt_putenv(buf))
		return (1);
d290 9
a298 1
DECL(f_ttywerase)
d300 1
a300 8
	if (turnoff)
		O_CLR(sp, O_TTYWERASE);
	else {
		O_SET(sp, O_TTYWERASE);
		O_CLR(sp, O_ALTWERASE);
	}
	return (0);
}
a301 2
DECL(f_w300)
{
d303 3
a305 1
	if (baud_from_bval(sp) >= 1200)
d308 1
a308 7
	if (CALL(f_window))
		return (1);

	if (val > O_VAL(sp, O_LINES) - 1)
		val = O_VAL(sp, O_LINES) - 1;
	O_VAL(sp, O_W300) = val;
	return (0);
d311 9
a319 1
DECL(f_w1200)
d324 2
a325 1
	v = baud_from_bval(sp);
d329 1
a329 7
	if (CALL(f_window))
		return (1);

	if (val > O_VAL(sp, O_LINES) - 1)
		val = O_VAL(sp, O_LINES) - 1;
	O_VAL(sp, O_W1200) = val;
	return (0);
d332 9
a340 1
DECL(f_w9600)
d342 1
a342 1
	speed_t v;
d345 2
a346 1
	v = baud_from_bval(sp);
d350 1
a350 22
	if (CALL(f_window))
		return (1);

	if (val > O_VAL(sp, O_LINES) - 1)
		val = O_VAL(sp, O_LINES) - 1;
	O_VAL(sp, O_W9600) = val;
	return (0);
}

DECL(f_window)
{
	if (val < MINIMUM_SCREEN_ROWS) {
		msgq(sp, M_ERR, "Window too small, less than %d",
		    MINIMUM_SCREEN_ROWS);
		return (1);
	}
	if (val > O_VAL(sp, O_LINES) - 1)
		val = O_VAL(sp, O_LINES) - 1;
	O_VAL(sp, O_WINDOW) = val;
	O_VAL(sp, O_SCROLL) = val / 2;

	return (0);
d354 1
a354 2
 * opt_dup --
 *	Copy a string value for user display.
d356 2
a357 2
static int
opt_dup(sp, opt, str)
d359 1
a359 1
	int opt;
d361 1
d363 3
a365 17
	char *p;

	/* Copy for user display. */
	if ((p = strdup(str)) == NULL) {
		msgq(sp, M_SYSERR, NULL);
		return (1);
	}

	/* Free the old contents. */
	if (F_ISSET(&sp->opts[opt], OPT_ALLOCATED))
		free(O_STR(sp, opt));

	/* Note that it's set and allocated. */
	F_SET(&sp->opts[opt], OPT_ALLOCATED | OPT_SET);

	/* Assign new contents. */
	O_STR(sp, opt) = p;
a366 58
}

/*
 * opt_putenv --
 *	Put a value into the environment.  We use putenv(3) because it's
 *	more portable.  The following hack is because some moron decided
 *	to keep a reference to the memory passed to putenv(3), instead of
 *	having it allocate its own.  Someone clearly needs to get promoted
 *	into management.
 */
static int
opt_putenv(s)
	char *s;
{
	char *t;

	/*
	 * XXX
	 * Memory leak.
	 */
	if ((t = strdup(s)) == NULL)
		return (1);
	return (putenv(t));
}

/*
 * baud_from_bval --
 *	Return the baud rate using the standard defines.
 */
u_long
baud_from_bval(sp)
	SCR *sp;
{
	if (!F_ISSET(sp->gp, G_TERMIOS_SET))
		return (9600);

	/*
	 * XXX
	 * There's no portable way to get a "baud rate" -- cfgetospeed(3)
	 * returns the value associated with some #define, which we may
	 * never have heard of, or which may be a purely local speed.  Vi
	 * only cares if it's SLOW (w300), slow (w1200) or fast (w9600).
	 * Try and detect the slow ones, and default to fast.
	 */
	switch (cfgetospeed(&sp->gp->original_termios)) {
	case B50:
	case B75:
	case B110:
	case B134:
	case B150:
	case B200:
	case B300:
	case B600:
		return (600);
	case B1200:
		return (1200);
	}
	return (9600);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
