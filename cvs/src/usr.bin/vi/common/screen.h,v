head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.52
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.50
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.48
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.46
	OPENBSD_5_0:1.5.0.44
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.42
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.40
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.36
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.38
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.34
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.32
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.30
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.28
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.26
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.24
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.22
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.20
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.18
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.16
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.14
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.12
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.10
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.8
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.9;
commitid	01nAnartGL7onLD3;

1.9
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.8;
commitid	ruCZ2IKF0FB0ebCr;

1.8
date	2015.11.19.07.53.31;	author bentley;	state Exp;
branches;
next	1.7;
commitid	aNUlDSFtbBwW1Tdz;

1.7
date	2014.11.20.08.50.53;	author bentley;	state Exp;
branches;
next	1.6;
commitid	DAfFYTGOAzdEQS6z;

1.6
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.31;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.25;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.23;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: screen.h,v 1.8 2015/11/19 07:53:31 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 *
 *	@@(#)screen.h	10.24 (Berkeley) 7/19/96
 */

/*
 * There are minimum values that vi has to have to display a screen.  The row
 * minimum is fixed at 1 (the svi code can share a line between the text line
 * and the colon command/message line).  Column calculation is a lot trickier.
 * For example, you have to have enough columns to display the line number,
 * not to mention guaranteeing that tabstop and shiftwidth values are smaller
 * than the current column value.  It's simpler to have a fixed value and not
 * worry about it.
 *
 * XXX
 * MINIMUM_SCREEN_COLS is almost certainly wrong.
 */
#define	MINIMUM_SCREEN_ROWS	 1
#define	MINIMUM_SCREEN_COLS	20

/*
 * SCR --
 *	The screen structure.  To the extent possible, all screen information
 *	is stored in the various private areas.  The only information here
 *	is used by global routines or is shared by too many screens.
 */
struct _scr {
/* INITIALIZED AT SCREEN CREATE. */
	TAILQ_ENTRY(_scr) q;		/* Screens. */

	int	 id;			/* Screen id #. */
	int	 refcnt;		/* Reference count. */

	GS	*gp;			/* Pointer to global area. */
	SCR	*nextdisp;		/* Next display screen. */
	SCR	*ccl_parent;		/* Colon command-line parent screen. */
	EXF	*ep;			/* Screen's current EXF structure. */

	FREF	*frp;			/* FREF being edited. */
	char	**argv;			/* NULL terminated file name array. */
	char	**cargv;		/* Current file name. */

	u_long	 ccnt;			/* Command count. */
	u_long	 q_ccnt;		/* Quit or ZZ command count. */

					/* Screen's: */
	size_t	 rows;			/* 1-N: number of rows. */
	size_t	 cols;			/* 1-N: number of columns. */
	size_t	 t_rows;		/* 1-N: cur number of text rows. */
	size_t	 t_maxrows;		/* 1-N: max number of text rows. */
	size_t	 t_minrows;		/* 1-N: min number of text rows. */
	size_t	 woff;			/* 0-N: screen offset in frame. */

					/* Cursor's: */
	recno_t	 lno;			/* 1-N: file line. */
	size_t	 cno;			/* 0-N: file character in line. */

	size_t	 rcm;			/* Vi: 0-N: Most attractive column. */

#define	L_ADDED		0		/* Added lines. */
#define	L_CHANGED	1		/* Changed lines. */
#define	L_DELETED	2		/* Deleted lines. */
#define	L_JOINED	3		/* Joined lines. */
#define	L_MOVED		4		/* Moved lines. */
#define	L_SHIFT		5		/* Shift lines. */
#define	L_YANKED	6		/* Yanked lines. */
	recno_t	 rptlchange;		/* Ex/vi: last L_CHANGED lno. */
	recno_t	 rptlines[L_YANKED + 1];/* Ex/vi: lines changed by last op. */

	TEXTH	 tiq;			/* Ex/vi: text input queue. */

	SCRIPT	*script;		/* Vi: script mode information .*/

	recno_t	 defscroll;		/* Vi: ^D, ^U scroll information. */

					/* Display character. */
	CHAR_T	 cname[MAX_CHARACTER_COLUMNS + 1];
	size_t	 clen;			/* Length of display character. */

	enum {				/* Vi editor mode. */
	    SM_APPEND = 0, SM_CHANGE, SM_COMMAND, SM_INSERT,
	    SM_REPLACE } showmode;

	void	*ex_private;		/* Ex private area. */
	void	*vi_private;		/* Vi private area. */

/* PARTIALLY OR COMPLETELY COPIED FROM PREVIOUS SCREEN. */
	char	*alt_name;		/* Ex/vi: alternate file name. */

	CHAR_T	 at_lbuf;		/* Ex/vi: Last executed at buffer. */

					/* Ex/vi: re_compile flags. */
#define	RE_C_SEARCH	0x0002		/* Compile search replacement. */
#define	RE_C_SILENT	0x0004		/* No error messages. */
#define	RE_C_SUBST	0x0008		/* Compile substitute replacement. */
#define	RE_C_TAG	0x0010		/* Compile ctag pattern. */

#define	RE_WSTART	"[[:<:]]"	/* Ex/vi: not-in-word search pattern. */
#define	RE_WSTOP	"[[:>:]]"
					/* Ex/vi: flags to search routines. */
#define	SEARCH_EOL	0x0002		/* Offset past EOL is okay. */
#define	SEARCH_FILE	0x0004		/* Search the entire file. */
#define	SEARCH_INCR	0x0008		/* Search incrementally. */
#define	SEARCH_MSG	0x0010		/* Display search messages. */
#define	SEARCH_PARSE	0x0020		/* Parse the search pattern. */
#define	SEARCH_SET	0x0040		/* Set search direction. */
#define	SEARCH_TAG	0x0080		/* Search for a tag pattern. */
#define	SEARCH_WMSG	0x0100		/* Display search-wrapped messages. */

					/* Ex/vi: RE information. */
	dir_t	 searchdir;		/* Last file search direction. */
	regex_t	 re_c;			/* Search RE: compiled form. */
	char	*re;			/* Search RE: uncompiled form. */
	size_t	 re_len;		/* Search RE: uncompiled length. */
	regex_t	 subre_c;		/* Substitute RE: compiled form. */
	char	*subre;			/* Substitute RE: uncompiled form. */
	size_t	 subre_len;		/* Substitute RE: uncompiled length). */
	char	*repl;			/* Substitute replacement. */
	size_t	 repl_len;		/* Substitute replacement length.*/
	size_t	*newl;			/* Newline offset array. */
	size_t	 newl_len;		/* Newline array size. */
	size_t	 newl_cnt;		/* Newlines in replacement. */
	u_int8_t c_suffix;		/* Edcompatible 'c' suffix value. */
	u_int8_t g_suffix;		/* Edcompatible 'g' suffix value. */

	OPTION	 opts[O_OPTIONCOUNT];	/* Ex/vi: Options. */

/*
 * Screen flags.
 *
 * Editor screens.
 */
#define	SC_EX		0x00000001	/* Ex editor. */
#define	SC_VI		0x00000002	/* Vi editor. */

/*
 * Screen formatting flags, first major, then minor.
 *
 * SC_SCR_EX
 *	Ex screen, i.e. cooked mode.
 * SC_SCR_VI
 *	Vi screen, i.e. raw mode.
 * SC_SCR_EXWROTE
 *	The editor had to write on the screen behind curses' back, and we can't
 *	let curses change anything until the user agrees, e.g. entering the
 *	commands :!utility followed by :set.  We have to switch back into the
 *	vi "editor" to read the user's command input, but we can't touch the
 *	rest of the screen because it's known to be wrong.
 * SC_SCR_REFORMAT
 *	The expected presentation of the lines on the screen have changed,
 *	requiring that the intended screen lines be recalculated.  Implies
 *	SC_SCR_REDRAW.
 * SC_SCR_REDRAW
 *	The screen doesn't correctly represent the file; repaint it.  Note,
 *	setting SC_SCR_REDRAW in the current window causes *all* windows to
 *	be repainted.
 * SC_SCR_CENTER
 *	If the current line isn't already on the screen, center it.
 * SC_SCR_TOP
 *	If the current line isn't already on the screen, put it at the to@@.
 */
#define	SC_SCR_EX	0x00000004	/* Screen is in ex mode. */
#define	SC_SCR_VI	0x00000008	/* Screen is in vi mode. */
#define	SC_SCR_EXWROTE	0x00000010	/* Ex overwrite: see comment above. */
#define	SC_SCR_REFORMAT	0x00000020	/* Reformat (refresh). */
#define	SC_SCR_REDRAW	0x00000040	/* Refresh. */

#define	SC_SCR_CENTER	0x00000080	/* Center the line if not visible. */
#define	SC_SCR_TOP	0x00000100	/* Top the line if not visible. */

/* Screen/file changes. */
#define	SC_EXIT		0x00000200	/* Exiting (not forced). */
#define	SC_EXIT_FORCE	0x00000400	/* Exiting (forced). */
#define	SC_FSWITCH	0x00000800	/* Switch underlying files. */
#define	SC_SSWITCH	0x00001000	/* Switch screens. */

#define	SC_ARGNOFREE	0x00002000	/* Argument list wasn't allocated. */
#define	SC_ARGRECOVER	0x00004000	/* Argument list is recovery files. */
#define	SC_AT_SET	0x00008000	/* Last at buffer set. */
#define	SC_COMEDIT	0x00010000	/* Colon command-line edit window. */
#define	SC_EX_GLOBAL	0x00020000	/* Ex: executing a global command. */
#define	SC_EX_SILENT	0x00040000	/* Ex: batch script. */
#define	SC_EX_WAIT_NO	0x00080000	/* Ex: don't wait for the user. */
#define	SC_EX_WAIT_YES	0x00100000	/* Ex:    do wait for the user. */
#define	SC_READONLY	0x00200000	/* Persistent readonly state. */
#define	SC_RE_SEARCH	0x00400000	/* Search RE has been compiled. */
#define	SC_RE_SUBST	0x00800000	/* Substitute RE has been compiled. */
#define	SC_SCRIPT	0x01000000	/* Shell script window. */
#define	SC_STATUS	0x02000000	/* Welcome message. */
#define	SC_STATUS_CNT	0x04000000	/* Welcome message plus file count. */
#define	SC_TINPUT	0x08000000	/* Doing text input. */
#define	SC_TINPUT_INFO	0x10000000	/* Doing text input on info line. */
	u_int32_t flags;
};
@


1.9
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d85 1
a85 1
	char	 cname[MAX_CHARACTER_COLUMNS + 1];
d98 1
a98 1
	char	 at_lbuf;		/* Ex/vi: Last executed at buffer. */
@


1.8
log
@Remove cscope support in vi.

It makes no sense to keep support for a non-base tool in base, especially
for a feature that few if any people use.
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.h,v 1.7 2014/11/20 08:50:53 bentley Exp $	*/
d85 1
a85 1
	CHAR_T	 cname[MAX_CHARACTER_COLUMNS + 1];
d98 1
a98 1
	CHAR_T	 at_lbuf;		/* Ex/vi: Last executed at buffer. */
@


1.7
log
@Remove the vi perl api.

There have been various build errors for coming on two years now.
It doesn't work and nobody has expressed any interest in saving it.

From natano; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.h,v 1.6 2013/11/28 22:12:40 krw Exp $	*/
a100 1
#define	RE_C_CSCOPE	0x0001		/* Compile cscope pattern. */
a108 1
#define	SEARCH_CSCOPE	0x0001		/* Search for a cscope pattern. */
@


1.6
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.h,v 1.5 2001/01/29 01:58:31 niklas Exp $	*/
a93 1
	void	*perl_private;		/* Perl private area. */
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
	CIRCLEQ_ENTRY(_scr) q;		/* Screens. */
@


1.4
log
@nvi 1.73
@
text
@d1 2
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d9 1
a9 1
 *	@@(#)screen.h	10.22 (Berkeley) 6/30/96
d92 1
d198 4
a201 3
#define	SC_STATUS	0x02000000	/* Schedule welcome message. */
#define	SC_TINPUT	0x04000000	/* Doing text input. */
#define	SC_TINPUT_INFO	0x08000000	/* Doing text input on info line. */
@


1.2
log
@new vi
@
text
@d9 1
a9 1
 *	@@(#)screen.h	10.19 (Berkeley) 5/15/96
a90 1
	void	*sex_private;		/* Ex screen private area. */
d112 1
a112 1
#define	SEARCH_MSG	0x0010		/* Display search warning messages. */
d116 1
d120 6
a125 6
	char	*re;			/* Search RE (uncompiled form). */
	regex_t	 re_c;			/* Search RE (compiled form). */
	size_t	 re_len;		/* Search RE length. */
	char	*subre;			/* Substitute RE (uncompiled form.) */
	regex_t	 subre_c;		/* Substitute RE (compiled form.) */
	size_t	 subre_len;		/* Substitute RE length. */
d189 11
a199 10
#define	SC_EX_DONTWAIT	0x00020000	/* Ex: don't wait for the user. */
#define	SC_EX_GLOBAL	0x00040000	/* Ex: executing a global command. */
#define	SC_EX_SILENT	0x00080000	/* Ex: batch script. */
#define	SC_READONLY	0x00100000	/* Persistent readonly state. */
#define	SC_RE_SEARCH	0x00200000	/* Search RE has been compiled. */
#define	SC_RE_SUBST	0x00400000	/* Substitute RE has been compiled. */
#define	SC_SCRIPT	0x00800000	/* Shell script window. */
#define	SC_STATUS	0x01000000	/* Schedule welcome message. */
#define	SC_TINPUT	0x02000000	/* Doing text input. */
#define	SC_TINPUT_INFO	0x04000000	/* Doing text input on info line. */
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d9 1
a9 13
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)screen.h	8.127 (Berkeley) 8/8/94
d13 6
a18 6
 * There are minimum values that vi has to have to display a screen.  The
 * row minimum is fixed at 1 line for the text, and 1 line for any error
 * messages.  The column calculation is a lot trickier.  For example, you
 * have to have enough columns to display the line number, not to mention
 * guaranteeing that tabstop and shiftwidth values are smaller than the
 * current column value.  It's a lot simpler to have a fixed value and not
d22 1
a22 1
 * MINIMUM_SCREEN_COLS is probably wrong.
d24 1
a24 1
#define	MINIMUM_SCREEN_ROWS	 2
a26 44
enum adjust {				/* Screen adjustment operations. */
	A_DECREASE, A_INCREASE, A_SET };
enum operation {			/* Line operations. */
	LINE_APPEND, LINE_DELETE, LINE_INSERT, LINE_RESET };
enum position {				/* Position operations. */
	P_BOTTOM, P_FILL, P_MIDDLE, P_TOP };
enum sctype {				/* Scroll operations. */
	CNTRL_B, CNTRL_D, CNTRL_E, CNTRL_F, CNTRL_U, CNTRL_Y, Z_CARAT, Z_PLUS };

/*
 * Structure for holding file references.  Each SCR structure contains a
 * linked list of these.  The structure contains the name of the file,
 * along with the information that follows the name.
 *
 * !!!
 * The read-only bit follows the file name, not the file itself.
 *
 * XXX
 * The mtime field should be a struct timespec, but time_t is more portable.
 */
struct _fref {
	CIRCLEQ_ENTRY(_fref) q;		/* Linked list of file references. */
	char	*name;			/* File name. */
	char	*tname;			/* Backing temporary file name. */

	recno_t	 lno;			/* 1-N: file cursor line. */
	size_t	 cno;			/* 0-N: file cursor column. */

#define	FR_CURSORSET	0x001		/* If lno/cno values valid. */
#define	FR_DONTDELETE	0x002		/* Don't delete the temporary file. */
#define	FR_FNONBLANK	0x004		/* Move to the first non-<blank>. */
#define	FR_NAMECHANGE	0x008		/* If the name changed. */
#define	FR_NEWFILE	0x010		/* File doesn't really exist yet. */
#define	FR_RDONLY	0x020		/* File is read-only. */
#define	FR_READNAMED	0x040		/* Read renamed the file. */
#define	FR_RECOVER	0x080		/* File is being recovered. */
#define	FR_TMPEXIT	0x100		/* Modified temporary file, no exit. */
#define	FR_TMPFILE	0x200		/* If file has no name. */
#define	FR_UNLOCKED	0x400		/* File couldn't be locked. */
	u_int16_t flags;
};

#define	TEMPORARY_FILE_STRING	"/tmp"	/* Default temporary file name. */

d37 3
a40 1

d42 1
a42 1

a44 3
	MSGH	 msgq;			/* Message list. */
					/* FREF list. */
	CIRCLEQ_HEAD(_frefh, _fref) frefq;
a45 1

a54 1
	size_t	 woff;			/* 0-N: row offset in screen. */
d58 1
a64 1
	int	 rcm_last;		/* Cursor drawn to the last column. */
d71 2
a72 3
#define	L_LSHIFT	5		/* Left shift lines. */
#define	L_RSHIFT	6		/* Right shift lines. */
#define	L_YANKED	7		/* Yanked lines. */
d76 1
a76 9
	FILE	*stdfp;			/* Ex output file pointer. */

	char	*if_name;		/* Ex input file name, for messages. */
	recno_t	 if_lno;		/* Ex input file line, for messages. */

	fd_set	 rdfd;			/* Ex/vi: read fd select mask. */

	TEXTH	 __tiq;			/* Ex/vi: text input queue. */
	TEXTH	 *tiqp;			/* Ex/vi: text input queue reference. */
a81 3
	struct timeval	 busy_tod;	/* ITIMER_REAL: busy time-of-day. */
	char const	*busy_msg;	/* ITIMER_REAL: busy message. */

d86 3
a88 2
#define	MAX_MODE_NAME	12
	char	*showmode;		/* Mode. */
a92 2
	void	*svi_private;		/* Vi curses screen private area. */
	void	*xaw_private;		/* Vi XAW screen private area. */
d97 29
a125 4
					/* Ex/vi: search/substitute info. */
	regex_t	 sre;			/* Last search RE. */
	regex_t	 subre;			/* Last substitute RE. */
	enum direction	searchdir;	/* File search direction. */
d131 2
a132 2
	u_char	 c_suffix;		/* Edcompatible 'c' suffix value. */
	u_char	 g_suffix;		/* Edcompatible 'g' suffix value. */
d134 1
a134 3
	u_int	 saved_vi_mode;		/* Saved vi display type. */

	OPTION	 opts[O_OPTIONCOUNT];	/* Options. */
d137 1
a137 1
 * SCREEN SUPPORT ROUTINES.
d139 1
a139 1
 * A SCR * MUST be the first argument to these routines.
d141 2
a142 101
					/* Ring the screen bell. */
	void	(*s_bell) __P((SCR *));
					/* Background the screen. */
	int	(*s_bg) __P((SCR *));
					/* Put up a busy message. */
	int	(*s_busy) __P((SCR *, char const *));
					/* Change a screen line. */
	int	(*s_change) __P((SCR *, EXF *, recno_t, enum operation));
					/* Clear the screen. */
	int	(*s_clear) __P((SCR *));
					/* Return column close to specified. */
	size_t	(*s_colpos) __P((SCR *, EXF *, recno_t, size_t));
					/* Return the logical cursor column. */
	int	(*s_column) __P((SCR *, EXF *, size_t *));
	enum confirm			/* Confirm an action with the user. */
		(*s_confirm) __P((SCR *, EXF *, MARK *, MARK *));
					/* Change the relative screen size. */
	int	(*s_crel) __P((SCR *, long));
					/* Edit a file. */
	int	(*s_edit) __P((SCR *, EXF *));
					/* End a screen. */
	int	(*s_end) __P((SCR *));
					/* Run a single ex command. */
	int	(*s_ex_cmd) __P((SCR *, EXF *, EXCMDARG *, MARK *));
					/* Run user's ex commands. */
	int	(*s_ex_run) __P((SCR *, EXF *, MARK *));
					/* Screen's ex write function. */
	int	(*s_ex_write) __P((void *, const char *, int));
					/* Foreground the screen. */
	int	(*s_fg) __P((SCR *, CHAR_T *));
					/* Fill the screen's map. */
	int	(*s_fill) __P((SCR *, EXF *, recno_t, enum position));
	enum input			/* Get a line from the user. */
		(*s_get) __P((SCR *, EXF *, TEXTH *, ARG_CHAR_T, u_int));
	enum input			/* Get a key from the user. */
		(*s_key_read) __P((SCR *, int *, struct timeval *));
					/* Map a function key. */
	int	(*s_fmap) __P((SCR *,
		    enum seqtype, CHAR_T *, size_t, CHAR_T *, size_t));
					/* Tell the screen an option changed. */
	int	(*s_optchange) __P((SCR *, int));
					/* Return column at screen position. */
	int	(*s_position) __P((SCR *, EXF *,
		   MARK *, u_long, enum position));
					/* Change the absolute screen size. */
	int	(*s_rabs) __P((SCR *, long, enum adjust));
					/* Return column close to selection. */
	size_t	(*s_rcm) __P((SCR *, EXF *, recno_t));
					/* Refresh the screen. */
	int	(*s_refresh) __P((SCR *, EXF *));
					/* Move down the screen. */
	int	(*s_scroll) __P((SCR *, EXF *, MARK *, recno_t, enum sctype));
					/* Split the screen. */
	int	(*s_split) __P((SCR *, ARGS *[], int));
					/* Suspend the screen. */
	int	(*s_suspend) __P((SCR *));
					/* Set the window size. */
	int	(*s_window) __P((SCR *, int));

/* Editor screens. */
#define	S_EX		0x0000001	/* Ex screen. */
#define	S_VI_CURSES	0x0000002	/* Vi: curses screen. */
#define	S_VI_XAW	0x0000004	/* Vi: Athena widgets screen. */

#define	IN_EX_MODE(sp)			/* If in ex mode. */		\
	(F_ISSET(sp, S_EX))
#define	IN_VI_MODE(sp)			/* If in vi mode. */		\
	(F_ISSET(sp, S_VI_CURSES | S_VI_XAW))
#define	S_SCREENS			/* Screens. */			\
	(S_EX | S_VI_CURSES | S_VI_XAW)

/* Major screen/file changes. */
#define	S_EXIT		0x0000008	/* Exiting (not forced). */
#define	S_EXIT_FORCE	0x0000010	/* Exiting (forced). */
#define	S_FSWITCH	0x0000020	/* Switch files. */
#define	S_SSWITCH	0x0000040	/* Switch screens. */
#define	S_MAJOR_CHANGE			/* Screen or file changes. */	\
	(S_EXIT | S_EXIT_FORCE | S_FSWITCH | S_SSWITCH)

#define	S_ARGNOFREE	0x0000080	/* Argument list wasn't allocated. */
#define	S_ARGRECOVER	0x0000100	/* Argument list is recovery files. */
#define	S_BELLSCHED	0x0000200	/* Bell scheduled. */
#define	S_CONTINUE	0x0000400	/* Need to ask the user to continue. */
#define	S_EXSILENT	0x0000800	/* Ex batch script. */
#define	S_GLOBAL	0x0001000	/* Doing a global command. */
#define	S_INPUT		0x0002000	/* Doing text input. */
#define	S_INTERRUPTED	0x0004000	/* If have been interrupted. */
#define	S_INTERRUPTIBLE	0x0008000	/* If can be interrupted. */
#define	S_IVIDEO	0x0010000	/* Display in inverse video. */
#define	S_REDRAW	0x0020000	/* Redraw the screen. */
#define	S_REFORMAT	0x0040000	/* Reformat the screen. */
#define	S_REFRESH	0x0080000	/* Refresh the screen. */
#define	S_RENUMBER	0x0100000	/* Renumber the screen. */
#define	S_RESIZE	0x0200000	/* Resize the screen. */
#define	S_SCRIPT	0x0400000	/* Window is a shell script. */
#define	S_SRE_SET	0x0800000	/* The search RE has been set. */
#define	S_SUBRE_SET	0x1000000	/* The substitute RE has been set. */
#define	S_UPDATE_MODE	0x2000000	/* Don't repaint modeline. */
#define	S_VLITONLY	0x4000000	/* ^V literal next only. */
	u_int32_t flags;
};
d145 1
a145 1
 * Signals/timers have no structure, so it's all here.
d147 54
a200 36
 * Block all signals that are being handled.  Used to keep the underlying DB
 * system calls from being interrupted and not restarted, as it could cause
 * consistency problems.  Also used when vi forks child processes, to avoid
 * a signal arriving after the fork and before the exec, causing both parent
 * and child to attempt recovery processing.
 */
#define	SIGBLOCK(gp) \
	(void)sigprocmask(SIG_BLOCK, &(gp)->blockset, NULL);
#define	SIGUNBLOCK(gp) \
	(void)sigprocmask(SIG_UNBLOCK, &(gp)->blockset, NULL);

void	 busy_off __P((SCR *));
int	 busy_on __P((SCR *, char const *));
void	 sig_end __P((void));
int	 sig_init __P((SCR *));

/* Generic routines to start/stop a screen. */
int	 screen_end __P((SCR *));
int	 screen_init __P((SCR *, SCR **, u_int));

/* Public interfaces to the underlying screens. */
int	 ex_screen_copy __P((SCR *, SCR *));
int	 ex_screen_end __P((SCR *));
int	 ex_screen_init __P((SCR *));
int	 sex_screen_copy __P((SCR *, SCR *));
int	 sex_screen_end __P((SCR *));
int	 sex_screen_init __P((SCR *));
int	 svi_screen_copy __P((SCR *, SCR *));
int	 svi_screen_end __P((SCR *));
int	 svi_screen_init __P((SCR *));
int	 v_screen_copy __P((SCR *, SCR *));
int	 v_screen_end __P((SCR *));
int	 v_screen_init __P((SCR *));
int	 xaw_screen_copy __P((SCR *, SCR *));
int	 xaw_screen_end __P((SCR *));
int	 xaw_screen_init __P((SCR *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
