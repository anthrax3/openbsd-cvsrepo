head	1.17;
access;
symbols
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.12
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.16
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.14
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.12
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.17
date	2014.11.20.08.50.53;	author bentley;	state dead;
branches;
next	1.16;
commitid	DAfFYTGOAzdEQS6z;

1.16
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.15;
commitid	06bi6U3x4gFFf2G1;

1.15
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.14.12.32.29;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.15.08.08.02;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.18.20.34.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.29.01.58.28;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	98.06.23.22.40.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.27.22.28.06;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.10.16.01.18.13;	author michaels;	state Exp;
branches;
next	1.5;

1.5
date	96.09.17.17.18.52;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.18;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.16;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.09.59.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.33.53;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove the vi perl api.

There have been various build errors for coming on two years now.
It doesn't work and nobody has expressed any interest in saving it.

From natano; ok millert@@
@
text
@/*	$OpenBSD: api.c,v 1.16 2014/11/12 04:28:41 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 * Copyright (c) 1995
 *	George V. Neville-Neil. All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "../common/common.h"

extern GS *__global_list;			/* XXX */

/*
 * api_fscreen --
 *	Return a pointer to the screen specified by the screen id
 *	or a file name.
 *
 * PUBLIC: SCR *api_fscreen(int, char *);
 */
SCR *
api_fscreen(int id, char *name)
{
	GS *gp;
	SCR *tsp;

	gp = __global_list;

	/* Search the displayed list. */
	TAILQ_FOREACH(tsp, &gp->dq, q)
		if (name == NULL) {
			if (id == tsp->id)
				return (tsp);
		} else if (!strcmp(name, tsp->frp->name))
			return (tsp);

	/* Search the hidden list. */
	TAILQ_FOREACH(tsp, &gp->hq, q)
		if (name == NULL) {
			if (id == tsp->id)
				return (tsp);
		} else if (!strcmp(name, tsp->frp->name))
			return (tsp);
	return (NULL);
}

/*
 * api_aline --
 *	Append a line.
 *
 * PUBLIC: int api_aline(SCR *, recno_t, char *, size_t);
 */
int
api_aline(SCR *sp, recno_t lno, char *line, size_t len)
{
	return (db_append(sp, 1, lno, line, len));
}

/*
 * api_dline --
 *	Delete a line.
 *
 * PUBLIC: int api_dline(SCR *, recno_t);
 */
int
api_dline(SCR *sp, recno_t lno)
{
	return (db_delete(sp, lno));
}

/*
 * api_gline --
 *	Get a line.
 *
 * PUBLIC: int api_gline(SCR *, recno_t, char **, size_t *);
 */
int
api_gline(SCR *sp, recno_t lno, char **linepp, size_t *lenp)
{
	int isempty;

	if (db_eget(sp, lno, linepp, lenp, &isempty)) {
		if (isempty)
			msgq(sp, M_ERR, "209|The file is empty");
		return (1);
	}
	return (0);
}

/*
 * api_iline --
 *	Insert a line.
 *
 * PUBLIC: int api_iline(SCR *, recno_t, char *, size_t);
 */
int
api_iline(SCR *sp, recno_t lno, char *line, size_t len)
{
	return (db_insert(sp, lno, line, len));
}

/*
 * api_lline --
 *	Return the line number of the last line in the file.
 *
 * PUBLIC: int api_lline(SCR *, recno_t *);
 */
int
api_lline(SCR *sp, recno_t *lnop)
{
	return (db_last(sp, lnop));
}

/*
 * api_sline --
 *	Set a line.
 *
 * PUBLIC: int api_sline(SCR *, recno_t, char *, size_t);
 */
int
api_sline(SCR *sp, recno_t lno, char *line, size_t len)
{
	return (db_set(sp, lno, line, len));
}

/*
 * api_getmark --
 *	Get the mark.
 *
 * PUBLIC: int api_getmark(SCR *, int, MARK *);
 */
int
api_getmark(SCR *sp, int markname, MARK *mp)
{
	return (mark_get(sp, (ARG_CHAR_T)markname, mp, M_ERR));
}

/*
 * api_setmark --
 *	Set the mark.
 *
 * PUBLIC: int api_setmark(SCR *, int, MARK *);
 */
int
api_setmark(SCR *sp, int markname, MARK *mp)
{
	return (mark_set(sp, (ARG_CHAR_T)markname, mp, 1));
}

/*
 * api_nextmark --
 *	Return the first mark if next not set, otherwise return the
 *	subsequent mark.
 *
 * PUBLIC: int api_nextmark(SCR *, int, char *);
 */
int
api_nextmark(SCR *sp, int next, char *namep)
{
	LMARK *mp;

	mp = LIST_FIRST(&sp->ep->marks);
	if (next)
		LIST_FOREACH(mp, &sp->ep->marks, q)
			if (mp->name == *namep) {
				mp = LIST_NEXT(mp, q);
				break;
			}
	if (mp == NULL)
		return (1);
	*namep = mp->name;
	return (0);
}

/*
 * api_getcursor --
 *	Get the cursor.
 *
 * PUBLIC: int api_getcursor(SCR *, MARK *);
 */
int
api_getcursor(SCR *sp, MARK *mp)
{
	mp->lno = sp->lno;
	mp->cno = sp->cno;
	return (0);
}

/*
 * api_setcursor --
 *	Set the cursor.
 *
 * PUBLIC: int api_setcursor(SCR *, MARK *);
 */
int
api_setcursor(SCR *sp, MARK *mp)
{
	size_t len;

	if (db_get(sp, mp->lno, DBG_FATAL, NULL, &len))
		return (1);
	if (mp->cno < 0 || mp->cno > len) {
		msgq(sp, M_ERR, "Cursor set to nonexistent column");
		return (1);
	}

	/* Set the cursor. */
	sp->lno = mp->lno;
	sp->cno = mp->cno;
	return (0);
}

/*
 * api_emessage --
 *	Print an error message.
 *
 * PUBLIC: void api_emessage(SCR *, char *);
 */
void
api_emessage(SCR *sp, char *text)
{
	msgq(sp, M_ERR, "%s", text);
}

/*
 * api_imessage --
 *	Print an informational message.
 *
 * PUBLIC: void api_imessage(SCR *, char *);
 */
void
api_imessage(SCR *sp, char *text)
{
	msgq(sp, M_INFO, "%s", text);
}

/*
 * api_edit
 *	Create a new screen and return its id 
 *	or edit a new file in the current screen.
 *
 * PUBLIC: int api_edit(SCR *, char *, SCR **, int);
 */
int
api_edit(SCR *sp, char *file, SCR **spp, int newscreen)
{
	ARGS *ap[2], a;
	EXCMD cmd;

	if (file) {
		ex_cinit(&cmd, C_EDIT, 0, OOBLNO, OOBLNO, 0, ap);
		ex_cadd(&cmd, &a, file, strlen(file));
	} else
		ex_cinit(&cmd, C_EDIT, 0, OOBLNO, OOBLNO, 0, NULL);
	if (newscreen)
		cmd.flags |= E_NEWSCREEN;		/* XXX */
	if (cmd.cmd->fn(sp, &cmd))
		return (1);
	*spp = sp->nextdisp;
	return (0);
}

/*
 * api_escreen
 *	End a screen.
 *
 * PUBLIC: int api_escreen(SCR *);
 */
int
api_escreen(SCR *sp)
{
	EXCMD cmd;

	/*
	 * XXX
	 * If the interpreter exits anything other than the current
	 * screen, vi isn't going to update everything correctly.
	 */
	ex_cinit(&cmd, C_QUIT, 0, OOBLNO, OOBLNO, 0, NULL);
	return (cmd.cmd->fn(sp, &cmd));
}

/*
 * api_swscreen --
 *    Switch to a new screen.
 *
 * PUBLIC: int api_swscreen(SCR *, SCR *);
 */
int
api_swscreen(SCR *sp, SCR *new)
{
	/*
	 * XXX
	 * If the interpreter switches from anything other than the
	 * current screen, vi isn't going to update everything correctly.
	 */
	sp->nextdisp = new;
	F_SET(sp, SC_SSWITCH);

	return (0);
}

/*
 * api_map --
 *	Map a key.
 *
 * PUBLIC: int api_map(SCR *, char *, char *, size_t);
 */
int
api_map(SCR *sp, char *name, char *map, size_t len)
{
	ARGS *ap[3], a, b;
	EXCMD cmd;

	ex_cinit(&cmd, C_MAP, 0, OOBLNO, OOBLNO, 0, ap);
	ex_cadd(&cmd, &a, name, strlen(name));
	ex_cadd(&cmd, &b, map, len);
	return (cmd.cmd->fn(sp, &cmd));
}

/*
 * api_unmap --
 *	Unmap a key.
 *
 * PUBLIC: int api_unmap(SCR *, char *);
 */
int 
api_unmap(SCR *sp, char *name)
{
	ARGS *ap[2], a;
	EXCMD cmd;

	ex_cinit(&cmd, C_UNMAP, 0, OOBLNO, OOBLNO, 0, ap);
	ex_cadd(&cmd, &a, name, strlen(name));
	return (cmd.cmd->fn(sp, &cmd));
}

/*
 * api_opts_get --
 *	Return a option value as a string, in allocated memory.
 *	If the option is of type boolean, boolvalue is (un)set
 *	according to the value; otherwise boolvalue is -1.
 *
 * PUBLIC: int api_opts_get(SCR *, char *, char **, int *);
 */
int
api_opts_get(SCR *sp, char *name, char **value, int *boolvalue)
{
	OPTLIST const *op;
	int offset;
	size_t len;

	if ((op = opts_search(name)) == NULL) {
		opts_nomatch(sp, name);
		return (1);
	}

	offset = op - optlist;
	if (boolvalue != NULL)
		*boolvalue = -1;
	switch (op->type) {
	case OPT_0BOOL:
	case OPT_1BOOL:
		len = strlen(op->name) + 2 + 1;
		MALLOC_RET(sp, *value, char *, len);
		(void)snprintf(*value, len,
		    "%s%s", O_ISSET(sp, offset) ? "" : "no", op->name);
		if (boolvalue != NULL)
			*boolvalue = O_ISSET(sp, offset);
		break;
	case OPT_NUM:
		len = 20;
		MALLOC_RET(sp, *value, char *, len);
		(void)snprintf(*value, len, "%lu", (u_long)O_VAL(sp, offset));
		break;
	case OPT_STR:
		if (O_STR(sp, offset) == NULL) {
			MALLOC_RET(sp, *value, char *, 2);
			value[0] = '\0';
		} else {
			len = strlen(O_STR(sp, offset)) + 1;
			MALLOC_RET(sp,
			    *value, char *, len);
			(void)snprintf(*value, len, "%s", O_STR(sp, offset));
		}
		break;
	}
	return (0);
}

/*
 * api_opts_set --
 *	Set options.
 *
 * PUBLIC: int api_opts_set(SCR *, char *, char *, u_long, int);
 */
int
api_opts_set(SCR *sp, char *name, char *str_value, u_long num_value,
    int bool_value)
{
	ARGS *ap[2], a, b;
	OPTLIST const *op;
	int rval;
	size_t blen;
	char *bp;

	if ((op = opts_search(name)) == NULL) {
		opts_nomatch(sp, name);
		return (1);
	}

	switch (op->type) {
	case OPT_0BOOL:
	case OPT_1BOOL:
		GET_SPACE_RET(sp, bp, blen, 64);
		a.len = snprintf(bp, 64, "%s%s", bool_value ? "" : "no", name);
		if (a.len > 63)
			a.len = 63;
		break;
	case OPT_NUM:
		GET_SPACE_RET(sp, bp, blen, 64);
		a.len = snprintf(bp, 64, "%s=%lu", name, num_value);
		if (a.len > 63)
			a.len = 63;
		break;
	case OPT_STR:
		GET_SPACE_RET(sp, bp, blen, 1024);
		a.len = snprintf(bp, 1024, "%s=%s", name, str_value);
		if (a.len > 1023)
			a.len = 1023;
		break;
	}
	a.bp = bp;
	b.len = 0;
	b.bp = NULL;
	ap[0] = &a;
	ap[1] = &b;
	rval = opts_set(sp, ap, NULL);

	FREE_SPACE(sp, bp, blen);

	return (rval);
}

/*
 * api_run_str --
 *      Execute a string as an ex command.
 *
 * PUBLIC: int api_run_str(SCR *, char *);
 */
int     
api_run_str(SCR *sp, char *cmd)
{
	return (ex_run_str(sp, NULL, cmd, strlen(cmd), 0, 0));
}
@


1.16
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: api.c,v 1.15 2013/11/28 22:12:40 krw Exp $	*/
@


1.15
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: api.c,v 1.14 2009/10/27 23:59:47 deraadt Exp $	*/
d40 1
a40 3
api_fscreen(id, name)
	int id;
	char *name;
d72 1
a72 5
api_aline(sp, lno, line, len)
	SCR *sp;
	recno_t lno;
	char *line;
	size_t len;
d84 1
a84 3
api_dline(sp, lno)
	SCR *sp;
	recno_t lno;
d96 1
a96 5
api_gline(sp, lno, linepp, lenp)
	SCR *sp;
	recno_t lno;
	char **linepp;
	size_t *lenp;
d115 1
a115 5
api_iline(sp, lno, line, len)
	SCR *sp;
	recno_t lno;
	char *line;
	size_t len;
d127 1
a127 3
api_lline(sp, lnop)
	SCR *sp;
	recno_t *lnop;
d139 1
a139 5
api_sline(sp, lno, line, len)
	SCR *sp;
	recno_t lno;
	char *line;
	size_t len;
d151 1
a151 4
api_getmark(sp, markname, mp)
	SCR *sp;
	int markname;
	MARK *mp;
d163 1
a163 4
api_setmark(sp, markname, mp)
	SCR *sp;
	int markname;
	MARK *mp;
d176 1
a176 4
api_nextmark(sp, next, namep)
	SCR *sp;
	int next;
	char *namep;
d200 1
a200 3
api_getcursor(sp, mp)
	SCR *sp;
	MARK *mp;
d214 1
a214 3
api_setcursor(sp, mp)
	SCR *sp;
	MARK *mp;
d238 1
a238 3
api_emessage(sp, text)
	SCR *sp;
	char *text;
d250 1
a250 3
api_imessage(sp, text)
	SCR *sp;
	char *text;
d263 1
a263 5
api_edit(sp, file, spp, newscreen)
	SCR *sp;
	char *file;
	SCR **spp;
	int newscreen;
d288 1
a288 2
api_escreen(sp)
	SCR *sp;
d308 1
a308 2
api_swscreen(sp, new)
      SCR *sp, *new;
d328 1
a328 4
api_map(sp, name, map, len)
	SCR *sp;
	char *name, *map;
	size_t len;
d346 1
a346 3
api_unmap(sp, name)
	SCR *sp;
	char *name;
d365 1
a365 4
api_opts_get(sp, name, value, boolvalue)
	SCR *sp;
	char *name, **value;
	int *boolvalue;
d416 2
a417 5
api_opts_set(sp, name, str_value, num_value, bool_value)
	SCR *sp;
	char *name, *str_value;
	u_long num_value;
	int bool_value;
d470 1
a470 3
api_run_str(sp, cmd)
	SCR *sp;
	char *cmd;
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: api.c,v 1.13 2007/05/14 12:32:29 pyr Exp $	*/
d50 1
a50 1
	CIRCLEQ_FOREACH(tsp, &gp->dq, q)
d58 1
a58 1
	CIRCLEQ_FOREACH(tsp, &gp->hq, q)
@


1.13
log
@use sys/queue macros instead of accessing fields directly.
no binary change.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: api.c,v 1.12 2003/04/15 08:08:02 deraadt Exp $	*/
a14 4

#ifndef lint
static const char sccsid[] = "@@(#)api.c	8.26 (Berkeley) 10/14/96";
#endif /* not lint */
@


1.12
log
@snprintf of course
@
text
@d1 1
a1 1
/*	$OpenBSD: api.c,v 1.11 2002/02/16 21:27:56 millert Exp $	*/
d54 1
a54 2
	for (tsp = gp->dq.cqh_first;
	    tsp != (void *)&gp->dq; tsp = tsp->q.cqe_next)
d62 1
a62 2
	for (tsp = gp->hq.cqh_first;
	    tsp != (void *)&gp->hq; tsp = tsp->q.cqe_next)
d215 1
a215 1
	mp = sp->ep->marks.lh_first;
d217 1
a217 1
		for (; mp != NULL; mp = mp->q.le_next)
d219 1
a219 1
				mp = mp->q.le_next;
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: api.c,v 1.10 2001/08/18 20:34:38 millert Exp $	*/
d428 1
d441 3
a443 2
		MALLOC_RET(sp, *value, char *, strlen(op->name) + 2 + 1);
		(void)sprintf(*value,
d449 3
a451 2
		MALLOC_RET(sp, *value, char *, 20);
		(void)sprintf(*value, "%lu", (u_long)O_VAL(sp, offset));
d458 1
d460 2
a461 2
			    *value, char *, strlen(O_STR(sp, offset)) + 1);
			(void)sprintf(*value, "%s", O_STR(sp, offset));
@


1.10
log
@Fix a pasto I made when adding snprintf() return val checks ages ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: api.c,v 1.9 2001/01/29 01:58:28 niklas Exp $	*/
d41 1
a41 1
 * PUBLIC: SCR *api_fscreen __P((int, char *));
d77 1
a77 1
 * PUBLIC: int api_aline __P((SCR *, recno_t, char *, size_t));
d93 1
a93 1
 * PUBLIC: int api_dline __P((SCR *, recno_t));
d107 1
a107 1
 * PUBLIC: int api_gline __P((SCR *, recno_t, char **, size_t *));
d130 1
a130 1
 * PUBLIC: int api_iline __P((SCR *, recno_t, char *, size_t));
d146 1
a146 1
 * PUBLIC: int api_lline __P((SCR *, recno_t *));
d160 1
a160 1
 * PUBLIC: int api_sline __P((SCR *, recno_t, char *, size_t));
d176 1
a176 1
 * PUBLIC: int api_getmark __P((SCR *, int, MARK *));
d191 1
a191 1
 * PUBLIC: int api_setmark __P((SCR *, int, MARK *));
d207 1
a207 1
 * PUBLIC: int api_nextmark __P((SCR *, int, char *));
d234 1
a234 1
 * PUBLIC: int api_getcursor __P((SCR *, MARK *));
d250 1
a250 1
 * PUBLIC: int api_setcursor __P((SCR *, MARK *));
d276 1
a276 1
 * PUBLIC: void api_emessage __P((SCR *, char *));
d290 1
a290 1
 * PUBLIC: void api_imessage __P((SCR *, char *));
d305 1
a305 1
 * PUBLIC: int api_edit __P((SCR *, char *, SCR **, int));
d334 1
a334 1
 * PUBLIC: int api_escreen __P((SCR *));
d355 1
a355 1
 * PUBLIC: int api_swscreen __P((SCR *, SCR *));
d376 1
a376 1
 * PUBLIC: int api_map __P((SCR *, char *, char *, size_t));
d397 1
a397 1
 * PUBLIC: int api_unmap __P((SCR *, char *));
d418 1
a418 1
 * PUBLIC: int api_opts_get __P((SCR *, char *, char **, int *));
d468 1
a468 1
 * PUBLIC: int api_opts_set __P((SCR *, char *, char *, u_long, int));
d525 1
a525 1
 * PUBLIC: int api_run_str __P((SCR *, char *));
@


1.9
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d505 2
a506 2
		if (a.len > 63)
			a.len = 63;
@


1.8
log
@Fix snprintf return value usage.
@
text
@d1 2
@


1.7
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d491 2
d497 2
d503 2
@


1.6
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d15 1
a15 1
static const char sccsid[] = "@@(#)api.c	8.24 (Berkeley) 9/18/96";
d424 1
a425 1
	OPTLIST const *op;
d427 2
a428 1
	if ((op = opts_search(name)) == NULL)
d430 1
d446 1
a446 1
		(void)sprintf(*value, "%ld", (u_long)O_VAL(sp, offset));
d466 1
a466 1
 * PUBLIC: int api_opts_set __P((SCR *, char *));
d468 2
a469 2
int 
api_opts_set(sp, name)
d471 3
a473 1
	char *name;
d475 34
a508 2
	ARGS *ap[2], a;
	EXCMD cmd;
d510 1
a510 3
	ex_cinit(&cmd, C_SET, 0, OOBLNO, OOBLNO, 0, ap);
	ex_cadd(&cmd, &a, name, strlen(name));
	return (cmd.cmd->fn(sp, &cmd));
@


1.5
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d15 1
a15 1
static const char sccsid[] = "@@(#)api.c	8.23 (Berkeley) 9/15/96";
d413 2
d416 1
a416 1
 * PUBLIC: int api_opts_get __P((SCR *, char *, char **));
d419 1
a419 1
api_opts_get(sp, name, value)
d422 1
d431 2
d439 2
@


1.4
log
@nvi 1.73
@
text
@d15 1
a15 1
static const char sccsid[] = "@@(#)api.c	8.22 (Berkeley) 8/10/96";
a23 1
#include <signal.h>
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d15 1
a15 1
static const char sccsid[] = "@@(#)api.c	8.19 (Berkeley) 6/8/96";
d202 28
d300 3
a302 2
 * api_iscreen
 *	Create a new screen and return its id.
d304 1
a304 1
 * PUBLIC: int api_iscreen __P((SCR *, char *, int *));
d307 1
a307 1
api_iscreen(sp, file, idp)
d310 2
a311 1
	int *idp;
d321 2
a322 1
	cmd.flags |= E_NEWSCREEN;			/* XXX */
d325 1
a325 1
	*idp = sp->nextdisp->id;
@


1.2
log
@vi fixes from bostic
@
text
@d15 1
a15 1
static const char sccsid[] = "@@(#)api.c	8.18 (Berkeley) 4/27/96";
@


1.1
log
@new vi
@
text
@d401 1
a401 1
		MALLOC_RET(sp, *value, char *, strlen(op->name) + 2);
d415 1
a415 1
			    *value, char *, strlen(O_STR(sp, offset)));
@
