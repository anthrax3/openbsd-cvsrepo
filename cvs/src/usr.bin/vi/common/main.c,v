head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.2
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.38.0.6
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2017.07.03.07.01.14;	author bentley;	state Exp;
branches;
next	1.39;
commitid	EvNQUli77WiHPwr6;

1.39
date	2017.04.18.01.45.35;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	Pd2TRHz7UBFr9JGt;

1.38
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.37;
commitid	01nAnartGL7onLD3;

1.37
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.36;
commitid	ruCZ2IKF0FB0ebCr;

1.36
date	2016.02.03.01.47.25;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	VKVsS1OkAAi8PXjr;

1.35
date	2016.01.30.21.23.50;	author martijn;	state Exp;
branches;
next	1.34;
commitid	coLzsk3wkJh1a1Ez;

1.34
date	2016.01.27.22.46.02;	author martijn;	state Exp;
branches;
next	1.33;
commitid	C5sujTKtHSllPijk;

1.33
date	2016.01.09.16.13.26;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Wi01RfUEwZ0KPZ7x;

1.32
date	2016.01.06.22.27.39;	author millert;	state Exp;
branches;
next	1.31;
commitid	WTL2xUDqwK7LLJKC;

1.31
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.30;
commitid	gtDERb7QyXwKGs62;

1.30
date	2015.11.20.04.12.19;	author bentley;	state Exp;
branches;
next	1.29;
commitid	XXmrAnA1nurkbacv;

1.29
date	2015.11.19.19.30.44;	author bentley;	state Exp;
branches;
next	1.28;
commitid	fRy3vQUSh4OE6ZQH;

1.28
date	2015.11.15.01.22.36;	author bentley;	state Exp;
branches;
next	1.27;
commitid	GEAhgEZ3pUmsJB4h;

1.27
date	2015.11.15.00.44.03;	author bentley;	state Exp;
branches;
next	1.26;
commitid	fw0k55T19B62x7Eu;

1.26
date	2014.11.20.08.50.53;	author bentley;	state Exp;
branches;
next	1.25;
commitid	DAfFYTGOAzdEQS6z;

1.25
date	2014.11.19.03.42.40;	author bentley;	state Exp;
branches;
next	1.24;
commitid	d8EyT0pmlGbtwZho;

1.24
date	2014.11.14.20.27.03;	author tedu;	state Exp;
branches;
next	1.23;
commitid	aIZ8ZvbLlUW9obxb;

1.23
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.22;
commitid	06bi6U3x4gFFf2G1;

1.22
date	2013.12.01.20.22.34;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.01.21.57.21;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.28.21.30.43;	author sobrado;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.28.13.02.22;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.12.21.22.48;	author sobrado;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.04.18.55.44;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.14.12.32.29;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.17.02.22.56;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.29.01.58.30;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.07.27.22.28.08;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.43.32;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.01.18.18;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.17.58.21;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Remove settings that were unimplemented for 20 years; update STANDARDS.

ok jmc@@ natano@@
@
text
@/*	$OpenBSD: main.c,v 1.39 2017/04/18 01:45:35 deraadt Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <bitstring.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "../vi/vi.h"

#ifdef DEBUG
static void	 attach(GS *);
#endif
static int	 v_obsolete(char *[]);

/*
 * editor --
 *	Main editor routine.
 *
 * PUBLIC: int editor(GS *, int, char *[]);
 */
int
editor(GS *gp, int argc, char *argv[])
{
	extern int optind;
	extern char *optarg;
	const char *p;
	EVENT ev;
	FREF *frp;
	SCR *sp;
	size_t len;
	u_int flags;
	int ch, flagchk, secure, startup, readonly, rval, silent;
	char *tag_f, *wsizearg, path[256];

	static const char *optstr[3] = {
#ifdef DEBUG
		"c:D:FlRrSsT:t:vw:",
		"c:D:eFlRrST:t:w:",
		"c:D:eFlrST:t:w:"
#else
		"c:FlRrSst:vw:",
		"c:eFlRrSt:w:",
		"c:eFlrSt:w:"
#endif
	};

	if (pledge("stdio rpath wpath cpath fattr flock getpw tty proc exec",
	    NULL) == -1) {
		perror("pledge");
		goto err;
	}

	/* Initialize the busy routine, if not defined by the screen. */
	if (gp->scr_busy == NULL)
		gp->scr_busy = vs_busy;
	/* Initialize the message routine, if not defined by the screen. */
	if (gp->scr_msg == NULL)
		gp->scr_msg = vs_msg;

	/* Common global structure initialization. */
	TAILQ_INIT(&gp->dq);
	TAILQ_INIT(&gp->hq);
	LIST_INIT(&gp->ecq);
	LIST_INSERT_HEAD(&gp->ecq, &gp->excmd, q);
	gp->noprint = DEFAULT_NOPRINT;

	/* Structures shared by screens so stored in the GS structure. */
	TAILQ_INIT(&gp->frefq);
	TAILQ_INIT(&gp->dcb_store.textq);
	LIST_INIT(&gp->cutq);
	LIST_INIT(&gp->seqq);

	/* Set initial screen type and mode based on the program name. */
	readonly = 0;
	if (!strcmp(getprogname(), "ex") || !strcmp(getprogname(), "nex"))
		LF_INIT(SC_EX);
	else {
		/* Nview, view are readonly. */
		if (!strcmp(getprogname(), "nview") ||
		    !strcmp(getprogname(), "view"))
			readonly = 1;
		
		/* Vi is the default. */
		LF_INIT(SC_VI);
	}

	/* Convert old-style arguments into new-style ones. */
	if (v_obsolete(argv))
		return (1);

	/* Parse the arguments. */
	flagchk = '\0';
	tag_f = wsizearg = NULL;
	secure = silent = 0;
	startup = 1;

	/* Set the file snapshot flag. */
	F_SET(gp, G_SNAPSHOT);

	pmode = MODE_EX;
	if (!strcmp(getprogname(), "ex"))
		pmode = MODE_EX;
	else if (!strcmp(getprogname(), "vi"))
		pmode = MODE_VI;
	else if (!strcmp(getprogname(), "view"))
		pmode = MODE_VIEW;

	while ((ch = getopt(argc, argv, optstr[pmode])) != -1)
		switch (ch) {
		case 'c':		/* Run the command. */
			/*
			 * XXX
			 * We should support multiple -c options.
			 */
			if (gp->c_option != NULL) {
				warnx("only one -c command may be specified.");
				return (1);
			}
			gp->c_option = optarg;
			break;
#ifdef DEBUG
		case 'D':
			switch (optarg[0]) {
			case 's':
				startup = 0;
				break;
			case 'w':
				attach(gp);
				break;
			default:
				warnx("-D requires s or w argument.");
				return (1);
			}
			break;
#endif
		case 'e':		/* Ex mode. */
			LF_CLR(SC_VI);
			LF_SET(SC_EX);
			break;
		case 'F':		/* No snapshot. */
			F_CLR(gp, G_SNAPSHOT);
			break;
		case 'R':		/* Readonly. */
			readonly = 1;
			break;
		case 'r':		/* Recover. */
			if (flagchk == 't') {
				warnx(
				    "only one of -r and -t may be specified.");
				return (1);
			}
			flagchk = 'r';
			break;
		case 'S':
			secure = 1;
			break;
		case 's':
			silent = 1;
			break;
#ifdef DEBUG
		case 'T':		/* Trace. */
			if ((gp->tracefp = fopen(optarg, "w")) == NULL) {
				warn("%s", optarg);
				goto err;
			}
			(void)fprintf(gp->tracefp,
			    "\n===\ntrace: open %s\n", optarg);
			break;
#endif
		case 't':		/* Tag. */
			if (flagchk == 'r') {
				warnx(
				    "only one of -r and -t may be specified.");
				return (1);
			}
			if (flagchk == 't') {
				warnx("only one tag file may be specified.");
				return (1);
			}
			flagchk = 't';
			tag_f = optarg;
			break;
		case 'v':		/* Vi mode. */
			LF_CLR(SC_EX);
			LF_SET(SC_VI);
			break;
		case 'w':
			wsizearg = optarg;
			break;
		case '?':
		default:
			(void)gp->scr_usage();
			return (1);
		}
	argc -= optind;
	argv += optind;

	if (secure)
		if (pledge("stdio rpath wpath cpath fattr flock getpw tty", NULL) == -1) {
			perror("pledge");
			goto err;
		}

	/*
	 * -s option is only meaningful to ex.
	 *
	 * If not reading from a terminal, it's like -s was specified.
	 */
	if (silent && !LF_ISSET(SC_EX)) {
		warnx("-s option is only applicable to ex.");
		goto err;
	}
	if (LF_ISSET(SC_EX) && F_ISSET(gp, G_SCRIPTED))
		silent = 1;

	/*
	 * Build and initialize the first/current screen.  This is a bit
	 * tricky.  If an error is returned, we may or may not have a
	 * screen structure.  If we have a screen structure, put it on a
	 * display queue so that the error messages get displayed.
	 *
	 * !!!
	 * Everything we do until we go interactive is done in ex mode.
	 */
	if (screen_init(gp, NULL, &sp)) {
		if (sp != NULL)
			TAILQ_INSERT_HEAD(&gp->dq, sp, q);
		goto err;
	}
	F_SET(sp, SC_EX);
	TAILQ_INSERT_HEAD(&gp->dq, sp, q);

	if (v_key_init(sp))		/* Special key initialization. */
		goto err;

	{ int oargs[5], *oargp = oargs;
	if (readonly)			/* Command-line options. */
		*oargp++ = O_READONLY;
	if (secure)
		*oargp++ = O_SECURE;
	*oargp = -1;			/* Options initialization. */
	if (opts_init(sp, oargs))
		goto err;
	}
	if (wsizearg != NULL) {
		ARGS *av[2], a, b;
		(void)snprintf(path, sizeof(path), "window=%s", wsizearg);
		a.bp = (CHAR_T *)path;
		a.len = strlen(path);
		b.bp = NULL;
		b.len = 0;
		av[0] = &a;
		av[1] = &b;
		(void)opts_set(sp, av, NULL);
	}
	if (silent) {			/* Ex batch mode option values. */
		O_CLR(sp, O_AUTOPRINT);
		O_CLR(sp, O_PROMPT);
		O_CLR(sp, O_VERBOSE);
		O_CLR(sp, O_WARN);
		F_SET(sp, SC_EX_SILENT);
	}

	sp->rows = O_VAL(sp, O_LINES);	/* Make ex formatting work. */
	sp->cols = O_VAL(sp, O_COLUMNS);

	if (!silent && startup) {	/* Read EXINIT, exrc files. */
		if (ex_exrc(sp))
			goto err;
		if (F_ISSET(sp, SC_EXIT | SC_EXIT_FORCE)) {
			if (screen_end(sp))
				goto err;
			goto done;
		}
	}

	/*
	 * List recovery files if -r specified without file arguments.
	 * Note, options must be initialized and startup information
	 * read before doing this.
	 */
	if (flagchk == 'r' && argv[0] == NULL) {
		if (rcv_list(sp))
			goto err;
		if (screen_end(sp))
			goto err;
		goto done;
	}

	/*
	 * !!!
	 * Initialize the default ^D, ^U scrolling value here, after the
	 * user has had every opportunity to set the window option.
	 *
	 * It's historic practice that changing the value of the window
	 * option did not alter the default scrolling value, only giving
	 * a count to ^D/^U did that.
	 */
	sp->defscroll = (O_VAL(sp, O_WINDOW) + 1) / 2;

	/*
	 * If we don't have a command-line option, switch into the right
	 * editor now, so that we position default files correctly, and
	 * so that any tags file file-already-locked messages are in the
	 * vi screen, not the ex screen.
	 *
	 * XXX
	 * If we have a command-line option, the error message can end
	 * up in the wrong place, but I think that the combination is
	 * unlikely.
	 */
	if (gp->c_option == NULL) {
		F_CLR(sp, SC_EX | SC_VI);
		F_SET(sp, LF_ISSET(SC_EX | SC_VI));
	}

	/* Open a tag file if specified. */
	if (tag_f != NULL && ex_tag_first(sp, tag_f))
		goto err;

	/*
	 * Append any remaining arguments as file names.  Files are recovery
	 * files if -r specified.  If the tag option or ex startup commands
	 * loaded a file, then any file arguments are going to come after it.
	 */
	if (*argv != NULL) {
		if (sp->frp != NULL) {
			size_t l;
			/* Cheat -- we know we have an extra argv slot. */
			l = strlen(sp->frp->name) + 1;
			if ((*--argv = malloc(l)) == NULL) {
				warn(NULL);
				goto err;
			}
			(void)strlcpy(*argv, sp->frp->name, l);
		}
		sp->argv = sp->cargv = argv;
		F_SET(sp, SC_ARGNOFREE);
		if (flagchk == 'r')
			F_SET(sp, SC_ARGRECOVER);
	}

	/*
	 * If the ex startup commands and or/the tag option haven't already
	 * created a file, create one.  If no command-line files were given,
	 * use a temporary file.
	 */
	if (sp->frp == NULL) {
		if (sp->argv == NULL) {
			if ((frp = file_add(sp, NULL)) == NULL)
				goto err;
		} else  {
			if ((frp = file_add(sp, (CHAR_T *)sp->argv[0])) == NULL)
				goto err;
			if (F_ISSET(sp, SC_ARGRECOVER))
				F_SET(frp, FR_RECOVER);
		}

		if (file_init(sp, frp, NULL, 0))
			goto err;
		if (EXCMD_RUNNING(gp)) {
			(void)ex_cmd(sp);
			if (F_ISSET(sp, SC_EXIT | SC_EXIT_FORCE)) {
				if (screen_end(sp))
					goto err;
				goto done;
			}
		}
	}

	/*
	 * Check to see if we need to wait for ex.  If SC_SCR_EX is set, ex
	 * was forced to initialize the screen during startup.  We'd like to
	 * wait for a single character from the user, but we can't because
	 * we're not in raw mode.  We can't switch to raw mode because the
	 * vi initialization will switch to xterm's alternate screen, causing
	 * us to lose the messages we're pausing to make sure the user read.
	 * So, wait for a complete line.  
	 */
	if (F_ISSET(sp, SC_SCR_EX)) {
		p = msg_cmsg(sp, CMSG_CONT_R, &len);
		(void)write(STDOUT_FILENO, p, len);
		for (;;) {
			if (v_event_get(sp, &ev, 0, 0))
				goto err;
			if (ev.e_event == E_INTERRUPT ||
			    (ev.e_event == E_CHARACTER &&
			    (ev.e_value == K_CR || ev.e_value == K_NL)))
				break;
			(void)gp->scr_bell(sp);
		}
	}

	/* Switch into the right editor, regardless. */
	F_CLR(sp, SC_EX | SC_VI);
	F_SET(sp, LF_ISSET(SC_EX | SC_VI) | SC_STATUS_CNT);

	/*
	 * Main edit loop.  Vi handles split screens itself, we only return
	 * here when switching editor modes or restarting the screen.
	 */
	while (sp != NULL)
		if (F_ISSET(sp, SC_EX) ? ex(&sp) : vi(&sp))
			goto err;

done:	rval = 0;
	if (0)
err:		rval = 1;

	/* Clean out the global structure. */
	v_end(gp);

	return (rval);
}

/*
 * v_end --
 *	End the program, discarding screens and most of the global area.
 *
 * PUBLIC: void v_end(GS *);
 */
void
v_end(GS *gp)
{
	MSGS *mp;
	SCR *sp;

	/* If there are any remaining screens, kill them off. */
	if (gp->ccl_sp != NULL) {
		(void)file_end(gp->ccl_sp, NULL, 1);
		(void)screen_end(gp->ccl_sp);
	}
	while ((sp = TAILQ_FIRST(&gp->dq)))
		(void)screen_end(sp);	/* Removes sp from the queue. */
	while ((sp = TAILQ_FIRST(&gp->hq)))
		(void)screen_end(sp);	/* Removes sp from the queue. */

#if defined(DEBUG) || defined(PURIFY)
	{ FREF *frp;
		/* Free FREF's. */
		while ((frp = TAILQ_FIRST(&gp->frefq))) {
			TAILQ_REMOVE(&gp->frefq, frp, q);
			free(frp->name);
			free(frp->tname);
			free(frp);
		}
	}

	/* Free key input queue. */
	free(gp->i_event);

	/* Free cut buffers. */
	cut_close(gp);

	/* Free map sequences. */
	seq_close(gp);

	/* Free default buffer storage. */
	(void)text_lfree(&gp->dcb_store.textq);
#endif

	/* Ring the bell if scheduled. */
	if (F_ISSET(gp, G_BELLSCHED))
		(void)fprintf(stderr, "\07");		/* \a */

	/*
	 * Flush any remaining messages.  If a message is here, it's almost
	 * certainly the message about the event that killed us (although
	 * it's possible that the user is sourcing a file that exits from the
	 * editor).
	 */
	while ((mp = LIST_FIRST(&gp->msgq)) != NULL) {
		(void)fprintf(stderr, "%s%.*s",
		    mp->mtype == M_ERR ? "ex/vi: " : "", (int)mp->len, mp->buf);
		LIST_REMOVE(mp, q);
#if defined(DEBUG) || defined(PURIFY)
		free(mp->buf);
		free(mp);
#endif
	}

#if defined(DEBUG) || defined(PURIFY)
	/* Free any temporary space. */
	free(gp->tmp_bp);

#if defined(DEBUG)
	/* Close debugging file descriptor. */
	if (gp->tracefp != NULL)
		(void)fclose(gp->tracefp);
#endif
#endif
}

/*
 * v_obsolete --
 *	Convert historic arguments into something getopt(3) will like.
 */
static int
v_obsolete(char *argv[])
{
	size_t len;
	char *p;

	/*
	 * Translate old style arguments into something getopt will like.
	 * Make sure it's not text space memory, because ex modifies the
	 * strings.
	 *	Change "+" into "-c$".
	 *	Change "+<anything else>" into "-c<anything else>".
	 *	Change "-" into "-s"
	 *	The c, T, t and w options take arguments so they can't be
	 *	    special arguments.
	 *
	 * Stop if we find "--" as an argument, the user may want to edit
	 * a file named "+foo".
	 */
	while (*++argv && strcmp(argv[0], "--"))
		if (argv[0][0] == '+') {
			if (argv[0][1] == '\0') {
				argv[0] = strdup("-c$");
				if (argv[0] == NULL)
					goto nomem;
			} else  {
				p = argv[0];
				len = strlen(argv[0]);
				if ((argv[0] = malloc(len + 2)) == NULL)
					goto nomem;
				argv[0][0] = '-';
				argv[0][1] = 'c';
				(void)strlcpy(argv[0] + 2, p + 1, len);
			}
		} else if (argv[0][0] == '-') {
			if (argv[0][1] == '\0') {
				argv[0] = strdup("-s");
				if (argv[0] == NULL) {
nomem:					warn(NULL);
					return (1);
				}
			} else
				if ((argv[0][1] == 'c' || argv[0][1] == 'T' ||
				    argv[0][1] == 't' || argv[0][1] == 'w') &&
				    argv[0][2] == '\0')
					++argv;
		}
	return (0);
}

#ifdef DEBUG
static void
attach(GS *gp)
{
	int fd;
	char ch;

	if ((fd = open(_PATH_TTY, O_RDONLY, 0)) < 0) {
		warn("%s", _PATH_TTY);
		return;
	}

	(void)printf("process %ld waiting, enter <CR> to continue: ",
	    (long)getpid());
	(void)fflush(stdout);

	do {
		if (read(fd, &ch, 1) != 1) {
			(void)close(fd);
			return;
		}
	} while (ch != '\n' && ch != '\r');
	(void)close(fd);
}
#endif
@


1.39
log
@free(NULL) is ok so use it; from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2016/05/27 09:18:11 martijn Exp $	*/
d55 1
a55 1
	int ch, flagchk, lflag, secure, startup, readonly, rval, silent;
d117 1
a117 1
	lflag = secure = silent = 0;
a165 3
		case 'l':		/* Set lisp, showmatch options. */
			lflag = 1;
			break;
d260 1
a260 5
	if (lflag) {			/* Command-line options. */
		*oargp++ = O_LISP;
		*oargp++ = O_SHOWMATCH;
	}
	if (readonly)
@


1.38
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2016/02/03 01:47:25 mmcc Exp $	*/
d473 2
a474 4
			if (frp->name != NULL)
				free(frp->name);
			if (frp->tname != NULL)
				free(frp->tname);
d480 1
a480 2
	if (gp->i_event != NULL)
		free(gp->i_event);
d514 1
a514 2
	if (gp->tmp_bp != NULL)
		free(gp->tmp_bp);
@


1.37
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d278 1
a278 1
		a.bp = path;
d383 1
a383 1
			if ((frp = file_add(sp, sp->argv[0])) == NULL)
@


1.36
log
@Remove needless alias macros for malloc and calloc. No binary change. I
got this upstreamed a few weeks ago.

ok tb (less a few style tweaks), martijn (who suggested style tweaks)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2016/01/30 21:23:50 martijn Exp $	*/
d278 1
a278 1
		a.bp = (CHAR_T *)path;
d383 1
a383 1
			if ((frp = file_add(sp, (CHAR_T *)sp->argv[0])) == NULL)
@


1.35
log
@replace progname variable in gs structure with getprogname

OK zhuk@@ and tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2016/01/27 22:46:02 martijn Exp $	*/
d361 1
a361 2
			MALLOC_NOMSG(sp, *--argv, l);
			if (*argv == NULL) {
d560 1
a560 2
				MALLOC_NOMSG(NULL, argv[0], len + 2);
				if (argv[0] == NULL)
@


1.34
log
@remove v_estr in favor of warn and warnx

OK schwarze@@, zhuk@@
fine with me tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2016/01/09 16:13:26 deraadt Exp $	*/
d98 1
a98 1
	if (!strcmp(gp->progname, "ex") || !strcmp(gp->progname, "nex"))
d102 2
a103 2
		if (!strcmp(gp->progname, "nview") ||
		    !strcmp(gp->progname, "view"))
d124 1
a124 1
	if (!strcmp(gp->progname, "ex"))
d126 1
a126 1
	else if (!strcmp(gp->progname, "vi"))
d128 1
a128 1
	else if (!strcmp(gp->progname, "view"))
@


1.33
log
@decls before code; from Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2016/01/06 22:27:39 millert Exp $	*/
d20 1
d36 1
a36 2
static void	 v_estr(char *, int, char *);
static int	 v_obsolete(char *, char *[]);
d111 1
a111 1
	if (v_obsolete(gp->progname, argv))
d139 1
a139 2
				v_estr(gp->progname, 0,
				    "only one -c command may be specified.");
d154 1
a154 2
				v_estr(gp->progname, 0,
				    "-D requires s or w argument.");
d174 1
a174 1
				v_estr(gp->progname, 0,
d189 1
a189 1
				v_estr(gp->progname, errno, optarg);
d198 1
a198 1
				v_estr(gp->progname, 0,
d203 1
a203 2
				v_estr(gp->progname, 0,
				    "only one tag file may be specified.");
d236 1
a236 1
		v_estr(gp->progname, 0, "-s option is only applicable to ex.");
d363 1
a363 1
				v_estr(gp->progname, errno, NULL);
d534 1
a534 1
v_obsolete(char *name, char *argv[])
d572 1
a572 1
nomem:					v_estr(name, errno, NULL);
d592 1
a592 1
		v_estr(gp->progname, errno, _PATH_TTY);
a608 11

static void
v_estr(char *name, int eno, char *msg)
{
	(void)fprintf(stderr, "%s", name);
	if (msg != NULL)
		(void)fprintf(stderr, ": %s", msg);
	if (eno)
		(void)fprintf(stderr, ": %s", strerror(errno));
	(void)fprintf(stderr, "\n");
}
@


1.32
log
@Remove the message catalog DB.  This removes the msg_open() and
msg_close() functions along with the msgcat command.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2015/12/07 20:39:19 mmcc Exp $	*/
a57 5
	if (pledge("stdio rpath wpath cpath fattr flock getpw tty proc exec", NULL) == -1) {
		perror("pledge");
		goto err;
	}

d69 6
@


1.31
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2015/11/20 04:12:19 bentley Exp $	*/
a495 3

	/* Close message catalogs. */
	msg_close(gp);
@


1.30
log
@vi -S doesn't need proc or exec.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2015/11/19 19:30:44 bentley Exp $	*/
d363 1
a363 1
			MALLOC_NOMSG(sp, *--argv, char *, l);
d566 1
a566 1
				MALLOC_NOMSG(NULL, argv[0], char *, len + 2);
@


1.29
log
@"tty proc exec", not "proc exec tty"
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2015/11/15 01:22:36 bentley Exp $	*/
d225 6
@


1.28
log
@Vi needs flock, for those who haven't set nolock in .exrc for years...

Pointed out by Theo Buehler.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2015/11/15 00:44:03 bentley Exp $	*/
d58 1
a58 1
	if (pledge("stdio rpath wpath cpath fattr flock getpw proc exec tty", NULL) == -1) {
@


1.27
log
@Basic pledge for vi.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2014/11/20 08:50:53 bentley Exp $	*/
d58 1
a58 1
	if (pledge("stdio rpath wpath cpath fattr getpw proc exec tty", NULL) == -1) {
@


1.26
log
@Remove the vi perl api.

There have been various build errors for coming on two years now.
It doesn't work and nobody has expressed any interest in saving it.

From natano; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2014/11/19 03:42:40 bentley Exp $	*/
d57 5
@


1.25
log
@Remove ifdef checks for LIBRARY.
It is undocumented and triggers the same conditional inclusions as
PURIFY does.

From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2014/11/14 20:27:03 tedu Exp $	*/
a458 4

#ifdef HAVE_PERL_INTERP
	perl_end(gp);
#endif
@


1.24
log
@from natano:
_PATH_BSHELL, _PATH_SENDMAIL, _PATH_TMP and _PATH_TTY are defined in
<paths.h> and _PATH_SYSV_TTY is unused. All of them can be removed from
pathnames.h. The other defines can be made unconditionally.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2014/11/12 04:28:41 bentley Exp $	*/
d464 1
a464 1
#if defined(DEBUG) || defined(PURIFY) || defined(LIBRARY)
d508 1
a508 1
#if defined(DEBUG) || defined(PURIFY) || defined(LIBRARY)
d514 1
a514 1
#if defined(DEBUG) || defined(PURIFY) || defined(LIBRARY)
@


1.23
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2013/12/01 20:22:34 krw Exp $	*/
d23 1
a30 1
#include "pathnames.h"
@


1.22
log
@Change the file reference queue from CIRCLEQ to TAILQ.

vi is now CIRCLEQ free!

ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2013/11/28 22:12:40 krw Exp $	*/
d45 1
a45 4
editor(gp, argc, argv)
	GS *gp;
	int argc;
	char *argv[];
d445 1
a445 2
v_end(gp)
	GS *gp;
d532 1
a532 2
v_obsolete(name, argv)
	char *name, *argv[];
d584 1
a584 2
attach(gp)
	GS *gp;
d609 1
a609 3
v_estr(name, eno, msg)
	char *name, *msg;
	int eno;
@


1.21
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2013/11/25 23:27:11 krw Exp $	*/
d88 1
a88 1
	CIRCLEQ_INIT(&gp->frefq);
d471 2
a472 2
		while ((frp = CIRCLEQ_FIRST(&gp->frefq)) != CIRCLEQ_END(&gp->frefq)) {
			CIRCLEQ_REMOVE(&gp->frefq, frp, q);
@


1.20
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2009/10/27 23:59:47 deraadt Exp $	*/
d81 2
a82 2
	CIRCLEQ_INIT(&gp->dq);
	CIRCLEQ_INIT(&gp->hq);
d247 1
a247 1
			CIRCLEQ_INSERT_HEAD(&gp->dq, sp, q);
d251 1
a251 1
	CIRCLEQ_INSERT_HEAD(&gp->dq, sp, q);
d459 4
a462 4
	while ((sp = CIRCLEQ_FIRST(&gp->dq)) != CIRCLEQ_END(&gp->dq))
		(void)screen_end(sp);
	while ((sp = CIRCLEQ_FIRST(&gp->hq)) != CIRCLEQ_END(&gp->hq))
		(void)screen_end(sp);
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2009/02/01 21:57:21 miod Exp $	*/
d89 1
a89 1
	CIRCLEQ_INIT(&gp->dcb_store.textq);
@


1.18
log
@Move variable declarations around to compile with gcc 2
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2009/01/28 21:30:43 sobrado Exp $	*/
a12 12

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1992, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n\
@@(#) Copyright (c) 1992, 1993, 1994, 1995, 1996\n\
	Keith Bostic.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static const char sccsid[] = "@@(#)main.c	10.48 (Berkeley) 10/11/96";
#endif /* not lint */
@


1.17
log
@remove undocumented support for "-e" in ex(1).

millert@@ says that neither 4.4BSD nor Solaris ex(1) accept this flag,
so it is safe to reject it too.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2009/01/28 13:02:22 sobrado Exp $	*/
d73 12
a138 12

	static const char *optstr[3] = {
#ifdef DEBUG
		"c:D:FlRrSsT:t:vw:",
		"c:D:eFlRrST:t:w:",
		"c:D:eFlrST:t:w:"
#else
		"c:FlRrSst:vw:",
		"c:eFlRrSt:w:",
		"c:eFlrSt:w:"
#endif
	};
@


1.16
log
@ex(1), vi(1), and view(1) have different synopses; each nex/nvi utility
should manage the right set of options and return an appropriate usage
when required.

jsing@@ has suggested preserving "-e" in ex(1) as an undocumented
compatibility flag to avoid breaking silly scripts that may use this
option with the line-oriented editor.

diff sent upstream to nex/nvi maintainers.

ok ("put it in!") jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2008/06/12 21:22:48 sobrado Exp $	*/
d130 1
a130 1
		"c:D:eFlRrSsT:t:vw:",
d134 1
a134 1
		"c:eFlRrSst:vw:",
@


1.15
log
@remove superfluous "usage:" from v_estr().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2008/03/04 18:55:44 otto Exp $	*/
d120 9
d130 3
a132 1
	while ((ch = getopt(argc, argv, "c:D:eFlRrSsT:t:vw:")) != -1)
d134 3
a136 1
	while ((ch = getopt(argc, argv, "c:eFlRrSst:vw:")) != -1)
d138 3
@


1.14
log
@fix ifdef DEBUG code; ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2007/05/14 12:32:29 pyr Exp $	*/
d149 1
a149 1
				    "usage: -D requires s or w argument.");
@


1.13
log
@use sys/queue macros instead of accessing fields directly.
no binary change.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2006/01/08 21:05:39 miod Exp $	*/
d467 1
a467 1
		while ((frp = CIRCLEQ_FIRST(&gp)) != CIRCLEQ_END(&gp->frefq)) {
@


1.12
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2005/10/17 19:12:16 otto Exp $	*/
d467 1
a467 1
		while ((frp = gp->frefq.cqh_first) != (FREF *)&gp->frefq) {
@


1.11
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2003/04/17 02:22:56 itojun Exp $	*/
d44 1
d46 1
d408 2
a409 2
			    ev.e_event == E_CHARACTER &&
			    (ev.e_value == K_CR || ev.e_value == K_NL))
d567 1
a567 1
		} else if (argv[0][0] == '-')
d579 1
@


1.10
log
@eliminate strcpy/sprintf.  reviewed by deraadt and millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2002/06/12 06:07:16 mpech Exp $	*/
d453 1
a453 1
	while ((sp = gp->dq.cqh_first) != (void *)&gp->dq)
d455 1
a455 1
	while ((sp = gp->hq.cqh_first) != (void *)&gp->hq)
d502 1
a502 1
	while ((mp = gp->msgq.lh_first) != NULL) {
@


1.9
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2002/02/16 21:27:57 millert Exp $	*/
d346 1
d348 2
a349 2
			MALLOC_NOMSG(sp,
			    *--argv, char *, strlen(sp->frp->name) + 1);
d354 1
a354 1
			(void)strcpy(*argv, sp->frp->name);
d552 1
a552 1
				MALLOC_NOMSG(NULL, argv[0], char *, 4);
a554 1
				(void)strcpy(argv[0], "-c$");
d563 1
a563 1
				(void)strcpy(argv[0] + 2, p + 1);
d567 1
a567 1
				MALLOC_NOMSG(NULL, argv[0], char *, 3);
a571 1
				(void)strcpy(argv[0], "-s");
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2001/01/29 01:58:30 niklas Exp $	*/
d594 2
a595 2
	(void)printf("process %lu waiting, enter <CR> to continue: ",
	    (u_long)getpid());
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 3
a46 3
static void	 attach __P((GS *));
static void	 v_estr __P((char *, int, char *));
static int	 v_obsolete __P((char *, char *[]));
d52 1
a52 1
 * PUBLIC: int editor __P((GS *, int, char *[]));
d438 1
a438 1
 * PUBLIC: void v_end __P((GS *));
@


1.6
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d21 1
a21 1
static const char sccsid[] = "@@(#)main.c	10.47 (Berkeley) 9/24/96";
d514 1
d518 1
@


1.4
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d117 1
a117 1
	while ((ch = getopt(argc, argv, "c:D:eFlRrSsT:t:vw:")) != EOF)
d119 1
a119 1
	while ((ch = getopt(argc, argv, "c:eFlRrSst:vw:")) != EOF)
@


1.3
log
@nvi 1.73
@
text
@d21 1
a21 1
static const char sccsid[] = "@@(#)main.c	10.44 (Berkeley) 7/13/96";
d42 1
d66 2
a67 3
	int ch, fd, flagchk, lflag, startup, readonly, rval, silent;
	char *tag_f, *wsizearg;
	char path[256];
d110 1
a110 1
	lflag = silent = 0;
d117 1
a117 1
	while ((ch = getopt(argc, argv, "c:D:eFlRrsT:t:vw:")) != EOF)
d119 1
a119 1
	while ((ch = getopt(argc, argv, "c:eFlRrst:vw:")) != EOF)
d141 1
a141 14
				if ((fd = open(_PATH_TTY, O_RDONLY, 0)) < 0) {
					v_estr(gp->progname, errno, _PATH_TTY);
					return (1);
				}
		(void)printf("process %lu waiting, enter <CR> to continue: ",
				    (u_long)getpid());
				(void)fflush(stdout);
				do {
					if (read(fd, &ch, 1) != 1) {
						(void)close(fd);
						return (0);
					}
				} while (ch != '\n' && ch != '\r');
				(void)close(fd);
d171 3
d225 1
a225 1
	if (LF_ISSET(SC_EX) && !F_ISSET(gp, G_STDIN_TTY))
d248 2
a249 4
	{ int oargs[4], *oargp = oargs;
	if (readonly)			/* Command-line options. */
		*oargp++ = O_READONLY;
	if (lflag) {
d253 4
d576 27
@


1.2
log
@new vi
@
text
@d21 1
a21 1
static const char sccsid[] = "@@(#)main.c	10.43 (Berkeley) 5/15/96";
d420 1
a420 1
	F_SET(sp, LF_ISSET(SC_EX | SC_VI));
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char copyright[] =
d15 3
a17 1
	The Regents of the University of California.  All rights reserved.\n";
d21 1
a21 1
static char sccsid[] = "@@(#)main.c	8.106 (Berkeley) 8/17/94";
d24 1
a24 1
#include <sys/param.h>
a29 2
#include <ctype.h>
#include <err.h>
a32 1
#include <signal.h>
a35 1
#include <termios.h>
d38 3
a40 5
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d42 2
a43 18
#include "compat.h"
#include <db.h>
#include <regex.h>
#include <pathnames.h>

#include "vi.h"
#include "excmd.h"
#include "../ex/tag.h"

enum rc { NOEXIST, NOPERM, OK };

static enum rc	 exrc_isok __P((SCR *, struct stat *, char *, int, int));
static void	 gs_end __P((GS *));
static GS	*gs_init __P((void));
static void	 obsolete __P((char *[]));
static void	 usage __P((int));

GS *__global_list;			/* GLOBAL: List of screens. */
d45 6
d52 2
a53 1
main(argc, argv)
d59 2
a60 3
	static int reenter;		/* STATIC: Re-entrancy check. */
	struct stat hsb, lsb;
	GS *gp;
d63 25
a87 13
	u_int flags, saved_vi_mode;
	int ch, eval, flagchk, readonly, silent, snapshot;
	char *excmdarg, *myname, *p, *tag_f, *trace_f, *wsizearg;
	char path[MAXPATHLEN];

	/* Stop if indirecting through a NULL pointer. */
	if (reenter++)
		abort();

#ifdef GDBATTACH
	(void)printf("%u waiting...\n", getpid());
	(void)read(0, &eval, 1);
#endif
d89 1
a89 1
	/* Set screen type and mode based on the program name. */
d91 2
a92 6
	if ((myname = strrchr(*argv, '/')) == NULL)
		myname = *argv;
	else
		++myname;
	if (!strcmp(myname, "ex") || !strcmp(myname, "nex"))
		LF_INIT(S_EX);
d94 3
a96 2
		/* View is readonly. */
		if (!strcmp(myname, "view"))
d98 3
a100 1
		LF_INIT(S_VI_CURSES);
a101 1
	saved_vi_mode = S_VI_CURSES;
d104 2
a105 1
	obsolete(argv);
d109 12
a120 4
	excmdarg = tag_f = trace_f = wsizearg = NULL;
	silent = 0;
	snapshot = 1;
	while ((ch = getopt(argc, argv, "c:eFRrsT:t:vw:X:")) != EOF)
d123 38
a160 1
			excmdarg = optarg;
d162 1
d164 2
a165 2
			LF_CLR(S_SCREENS);
			LF_SET(S_EX);
d168 4
a171 1
			snapshot = 0;
d177 2
a178 2
			if (flagchk == 't')
				errx(1,
d180 2
d187 1
d189 6
a194 1
			trace_f = optarg;
d196 1
d198 2
a199 2
			if (flagchk == 'r')
				errx(1,
d201 4
a204 2
			if (flagchk == 't')
				errx(1,
d206 2
d212 2
a213 2
			LF_CLR(S_SCREENS);
			LF_SET(S_VI_CURSES);
a217 8
		case 'X':
			if (!strcmp(optarg, "aw")) {
				LF_CLR(S_SCREENS);
				LF_SET(S_VI_XAW);
				saved_vi_mode = S_VI_XAW;
				break;
			}
			/* FALLTHROUGH */
d220 2
a221 1
			usage(LF_ISSET(S_EX));
a225 7
	/* Silent is only applicable to ex. */
	if (silent && !LF_ISSET(S_EX))
		errx(1, "-s only applicable to ex.");

	/* Build and initialize the GS structure. */
	__global_list = gp = gs_init();

d227 2
a229 2
	 * Vi always reads from the terminal, so fail if it's not a
	 * terminal.
d231 5
a235 1
	if (!F_ISSET(gp, G_STDIN_TTY)) {
a236 6
		if (!LF_ISSET(S_EX)) {
			msgq(NULL, M_ERR,
			    "Vi's standard input must be a terminal");
			goto err;
		}
	}
d245 1
a245 1
	 * Signals not on, no need to block them for queue manipulation.
d247 1
a247 1
	if (screen_init(NULL, &sp, flags)) {
d249 1
a249 1
			CIRCLEQ_INSERT_HEAD(&__global_list->dq, sp, q);
d252 5
a256 2
	sp->saved_vi_mode = saved_vi_mode;
	CIRCLEQ_INSERT_HEAD(&__global_list->dq, sp, q);
d258 6
a263 8
	if (trace_f != NULL) {
#ifdef DEBUG
		if ((gp->tracefp = fopen(trace_f, "w")) == NULL)
			err(1, "%s", trace_f);
		(void)fprintf(gp->tracefp, "\n===\ntrace: open %s\n", trace_f);
#else
		msgq(sp, M_ERR, "-T support not compiled into this version");
#endif
d265 2
a266 2

	if (opts_init(sp))		/* Options initialization. */
a267 8
	if (readonly)			/* Global read-only bit. */
		O_SET(sp, O_READONLY);
	if (silent) {			/* Ex batch mode. */
		O_CLR(sp, O_AUTOPRINT);
		O_CLR(sp, O_PROMPT);
		O_CLR(sp, O_VERBOSE);
		O_CLR(sp, O_WARN);
		F_SET(sp, S_EXSILENT);
a270 3
		errno = 0;
		if (strtol(wsizearg, &p, 10) < 0 || errno || *p)
			errx(1, "illegal window size -- %s.", wsizearg);
d278 8
a285 3
		if (opts_set(sp, NULL, av))
			 msgq(sp, M_ERR,
			     "Unable to set command line window size option");
d288 12
a299 3
	/* Keymaps, special keys, must follow option initializations. */
	if (term_init(sp))
		goto err;
d301 12
a312 4
#ifdef	DIGRAPHS
	if (digraph_init(sp))		/* Digraph initialization. */
		goto err;
#endif
a314 6
	 * Source the system, environment, $HOME and local .exrc values.
	 * Vi historically didn't check $HOME/.exrc if the environment
	 * variable EXINIT was set.  This is all done before the file is
	 * read in, because things in the .exrc information can set, for
	 * example, the recovery directory.
	 *
d316 2
a317 5
	 * While nvi can handle any of the options settings of historic vi,
	 * the converse is not true.  Since users are going to have to have
	 * files and environmental variables that work with both, we use nvi
	 * versions of both the $HOME and local startup files if they exist,
	 * otherwise the historic ones.
d319 11
a329 3
	 * !!!
	 * For a discussion of permissions and when what .exrc files are
	 * read, see the the comment above the exrc_isok() function below.
d331 8
a338 63
	 * !!!
	 * If the user started the historic of vi in $HOME, vi read the user's
	 * .exrc file twice, as $HOME/.exrc and as ./.exrc.  We avoid this, as
	 * it's going to make some commands behave oddly, and I can't imagine
	 * anyone depending on it.
	 */
	if (!silent) {
		switch (exrc_isok(sp, &hsb, _PATH_SYSEXRC, 1, 0)) {
		case NOEXIST:
		case NOPERM:
			break;
		case OK:
			(void)ex_cfile(sp, NULL, _PATH_SYSEXRC, 0);
			break;
		}

		if ((p = getenv("NEXINIT")) != NULL ||
		    (p = getenv("EXINIT")) != NULL)
			if ((p = strdup(p)) == NULL) {
				msgq(sp, M_SYSERR, NULL);
				goto err;
			} else {
				F_SET(sp, S_VLITONLY);
				(void)ex_icmd(sp, NULL, p, strlen(p), 0);
				F_CLR(sp, S_VLITONLY);
				free(p);
			}
		else if ((p = getenv("HOME")) != NULL && *p) {
			(void)snprintf(path,
			    sizeof(path), "%s/%s", p, _PATH_NEXRC);
			switch (exrc_isok(sp, &hsb, path, 0, 1)) {
			case NOEXIST:
				(void)snprintf(path,
				    sizeof(path), "%s/%s", p, _PATH_EXRC);
				if (exrc_isok(sp, &hsb, path, 0, 1) == OK)
					(void)ex_cfile(sp, NULL, path, 0);
				break;
			case NOPERM:
				break;
			case OK:
				(void)ex_cfile(sp, NULL, path, 0);
				break;
			}
		}

		if (O_ISSET(sp, O_EXRC))
			switch (exrc_isok(sp, &lsb, _PATH_NEXRC, 0, 0)) {
			case NOEXIST:
				if (exrc_isok(sp,
				    &lsb, _PATH_EXRC, 0, 0) == OK &&
				    (lsb.st_dev != hsb.st_dev ||
				    lsb.st_ino != hsb.st_ino))
					(void)ex_cfile(sp, NULL, _PATH_EXRC, 0);
				break;
			case NOPERM:
				break;
			case OK:
				if (lsb.st_dev != hsb.st_dev ||
				    lsb.st_ino != hsb.st_ino)
					(void)ex_cfile(sp,
					    NULL, _PATH_NEXRC, 0);
				break;
			}
d341 2
a342 10
	/* List recovery files if -r specified without file arguments. */
	if (flagchk == 'r' && argv[0] == NULL)
		exit(rcv_list(sp));

	/* Set the file snapshot flag. */
	if (snapshot)
		F_SET(gp, G_SNAPSHOT);

	/* Use a tag file if specified. */
	if (tag_f != NULL && ex_tagfirst(sp, tag_f))
d346 3
a348 2
	 * Append any remaining arguments as file names.  Files are
	 * recovery files if -r specified.
d351 10
d362 1
a362 1
		F_SET(sp, S_ARGNOFREE);
d364 1
a364 1
			F_SET(sp, S_ARGRECOVER);
d368 3
a370 2
	 * If the tag option hasn't already created a file, create one.
	 * If no files as arguments, use a temporary file.
d372 11
a382 6
	if (tag_f == NULL) {
		if ((frp = file_add(sp,
		    sp->argv == NULL ? NULL : (CHAR_T *)(sp->argv[0]))) == NULL)
			goto err;
		if (F_ISSET(sp, S_ARGRECOVER))
			F_SET(frp, FR_RECOVER);
d385 8
d396 13
a408 17
	 * If there's an initial command, push it on the command stack.
	 * Historically, it was always an ex command, not vi in vi mode
	 * or ex in ex mode.  So, make it look like an ex command to vi.
	 *
	 * !!!
	 * Historically, all such commands were executed with the last
	 * line of the file as the current line, and not the first, so
	 * set up vi to be at the end of the file.
	 */
	if (excmdarg != NULL)
		if (IN_EX_MODE(sp)) {
			if (term_push(sp, "\n", 1, 0))
				goto err;
			if (term_push(sp, excmdarg, strlen(excmdarg), 0))
				goto err;
		} else if (IN_VI_MODE(sp)) {
			if (term_push(sp, "\n", 1, 0))
d410 3
a412 30
			if (term_push(sp, excmdarg, strlen(excmdarg), 0))
				goto err;
			if (term_push(sp, ":", 1, 0))
				goto err;
			if (file_lline(sp, sp->ep, &sp->frp->lno))
				goto err;
			F_SET(sp->frp, FR_CURSORSET);
		}

	/* Set up signals. */
	if (sig_init(sp))
		goto err;

	for (;;) {
		/* Ignore errors -- other screens may succeed. */
		(void)sp->s_edit(sp, sp->ep);

		/*
		 * Edit the next screen on the display queue, or, move
		 * a screen from the hidden queue to the display queue.
		 */
		if ((sp = __global_list->dq.cqh_first) ==
		    (void *)&__global_list->dq)
			if ((sp = __global_list->hq.cqh_first) !=
			    (void *)&__global_list->hq) {
				SIGBLOCK(__global_list);
				CIRCLEQ_REMOVE(&sp->gp->hq, sp, q);
				CIRCLEQ_INSERT_TAIL(&sp->gp->dq, sp, q);
				SIGUNBLOCK(__global_list);
			} else
d414 1
a414 20

		/*
		 * The screen type may have changed -- reinitialize the
		 * functions in case it has.
		 */
		switch (F_ISSET(sp, S_SCREENS)) {
		case S_EX:
			if (sex_screen_init(sp))
				goto err;
			break;
		case S_VI_CURSES:
			if (svi_screen_init(sp))
				goto err;
			break;
		case S_VI_XAW:
			if (xaw_screen_init(sp))
				goto err;
			break;
		default:
			abort();
d418 3
a420 3
	eval = 0;
	if (0)
err:		eval = 1;
d423 2
a424 2
	 * NOTE: sp may be GONE when the screen returns, so only
	 * the gp can be trusted.
d426 3
a428 1
	gs_end(gp);
d430 8
a437 1
	exit(eval);
d441 4
a444 2
 * gs_init --
 *	Build and initialize the GS structure.
d446 3
a448 2
static GS *
gs_init()
d450 2
a451 2
	GS *gp;
	int fd;
d453 9
a461 3
	CALLOC_NOMSG(NULL, gp, GS *, 1, sizeof(GS));
	if (gp == NULL)
		err(1, NULL);
d463 3
a465 7
	/*
	 * !!!
	 * Signals not on, no need to block them for queue manipulation.
	 */
	CIRCLEQ_INIT(&gp->dq);
	CIRCLEQ_INIT(&gp->hq);
	LIST_INIT(&gp->msgq);
d467 12
a478 8
	/* Structures shared by screens so stored in the GS structure. */
	CALLOC_NOMSG(NULL, gp->tty, IBUF *, 1, sizeof(IBUF));
	if (gp->tty == NULL)
		err(1, NULL);

	CIRCLEQ_INIT(&gp->dcb_store.textq);
	LIST_INIT(&gp->cutq);
	LIST_INIT(&gp->seqq);
d480 3
a482 3
	/* Set a flag if we're reading from the tty. */
	if (isatty(STDIN_FILENO))
		F_SET(gp, G_STDIN_TTY);
d484 2
a485 21
	/*
	 * Set the G_STDIN_TTY flag.  It's purpose is to avoid setting and
	 * resetting the tty if the input isn't from there.
	 *
	 * Set the G_TERMIOS_SET flag.  It's purpose is to avoid using the
	 * original_termios information (mostly special character values)
	 * if it's not valid.  We expect that if we've lost our controlling
	 * terminal that the open() (but not the tcgetattr()) will fail.
	 */
	if (F_ISSET(gp, G_STDIN_TTY)) {
		if (tcgetattr(STDIN_FILENO, &gp->original_termios) == -1)
			err(1, "tcgetattr");
		F_SET(gp, G_TERMIOS_SET);
	} else if ((fd = open(_PATH_TTY, O_RDONLY, 0)) != -1) {
		if (tcgetattr(fd, &gp->original_termios) == -1)
			err(1, "tcgetattr");
		F_SET(gp, G_TERMIOS_SET);
		(void)close(fd);
	}
	return (gp);
}
d487 2
d490 1
a490 13
/*
 * gs_end --
 *	End the GS structure.
 */
static void
gs_end(gp)
	GS *gp;
{
	MSG *mp;
	SCR *sp;
	char *tty;

	/* Default buffer storage. */
d493 3
a495 6
	/* Reset anything that needs resetting. */
	if (gp->flags & G_SETMODE)			/* O_MESG */
		if ((tty = ttyname(STDERR_FILENO)) == NULL)
			warn("ttyname");
		else if (chmod(tty, gp->origmode) < 0)
			warn("%s", tty);
d501 15
a515 17
	/* If there are any remaining screens, flush their messages. */
	for (sp = __global_list->dq.cqh_first;
	    sp != (void *)&__global_list->dq; sp = sp->q.cqe_next)
		for (mp = sp->msgq.lh_first;
		    mp != NULL && !(F_ISSET(mp, M_EMPTY)); mp = mp->q.le_next)
			(void)fprintf(stderr,
			    "%.*s.\n", (int)mp->len, mp->mbuf);
	for (sp = __global_list->hq.cqh_first;
	    sp != (void *)&__global_list->hq; sp = sp->q.cqe_next)
		for (mp = sp->msgq.lh_first;
		    mp != NULL && !(F_ISSET(mp, M_EMPTY)); mp = mp->q.le_next)
			(void)fprintf(stderr,
			    "%.*s.\n", (int)mp->len, mp->mbuf);
	/* Flush messages on the global queue. */
	for (mp = gp->msgq.lh_first;
	    mp != NULL && !(F_ISSET(mp, M_EMPTY)); mp = mp->q.le_next)
		(void)fprintf(stderr, "%.*s.\n", (int)mp->len, mp->mbuf);
d517 9
a525 4
	/*
	 * DON'T FREE THE GLOBAL STRUCTURE -- WE DIDN'T TURN
	 * OFF SIGNALS/TIMERS, SO IT MAY STILL BE REFERENCED.
	 */
d529 2
a530 34
 * exrc_isok --
 *	Check a .exrc file for source-ability.
 *
 * !!!
 * Historically, vi read the $HOME and local .exrc files if they were owned
 * by the user's real ID, or the "sourceany" option was set, regardless of
 * any other considerations.  We no longer support the sourceany option as
 * it's a security problem of mammoth proportions.  We require the system
 * .exrc file to be owned by root, the $HOME .exrc file to be owned by the
 * user's effective ID (or that the user's effective ID be root) and the
 * local .exrc files to be owned by the user's effective ID.  In all cases,
 * the file cannot be writeable by anyone other than its owner.
 * 
 * In O'Reilly ("Learning the VI Editor", Fifth Ed., May 1992, page 106),
 * it notes that System V release 3.2 and later has an option "[no]exrc".
 * The behavior is that local .exrc files are read only if the exrc option
 * is set.  The default for the exrc option was off, so, by default, local
 * .exrc files were not read.  The problem this was intended to solve was
 * that System V permitted users to give away files, so there's no possible
 * ownership or writeability test to ensure that the file is safe.
 * 
 * POSIX 1003.2-1992 standardized exrc as an option.  It required the exrc
 * option to be off by default, thus local .exrc files are not to be read
 * by default.  The Rationale noted (incorrectly) that this was a change
 * to historic practice, but correctly noted that a default of off improves
 * system security.  POSIX also required that vi check the effective user
 * ID instead of the real user ID, which is why we've switched from historic
 * practice.
 * 
 * We initialize the exrc variable to off.  If it's turned on by the system
 * or $HOME .exrc files, and the local .exrc file passes the ownership and
 * writeability tests, then we read it.  This breaks historic 4BSD practice,
 * but it gives us a measure of security on systems where users can give away
 * files.
d532 3
a534 41
static enum rc
exrc_isok(sp, sbp, path, rootown, rootid)
	SCR *sp;
	struct stat *sbp;
	char *path;
	int rootown, rootid;
{
	uid_t euid;
	char *emsg, buf[MAXPATHLEN];

	/* Check for the file's existence. */
	if (stat(path, sbp))
		return (NOEXIST);

	/* Check ownership permissions. */
	euid = geteuid();
	if (!(rootown && sbp->st_uid == 0) && 
	    !(rootid && euid == 0) && sbp->st_uid != euid) {
		emsg = rootown ?
		    "not owned by you or root" : "not owned by you";
		goto denied;
	}

	/* Check writeability. */
	if (sbp->st_mode & (S_IWGRP | S_IWOTH)) {
		emsg = "writeable by a user other than the owner";
denied:		if (strchr(path, '/') == NULL &&
		    getcwd(buf, sizeof(buf)) != NULL)
			msgq(sp, M_ERR,
			    "%s/%s: not sourced: %s", buf, path, emsg);
		else
			msgq(sp, M_ERR,
			    "%s: not sourced: %s", path, emsg);
		return (NOPERM);
	}
	return (OK);
}

static void
obsolete(argv)
	char *argv[];
d541 1
a541 1
	 * Make sure it's not text space memory, because ex changes the
d546 5
d552 1
a552 1
	while (*++argv)
d557 1
a557 1
					err(1, NULL);
d564 1
a564 1
					err(1, NULL);
d569 14
a582 6
		} else if (argv[0][0] == '-' && argv[0][1] == '\0') {
			MALLOC_NOMSG(NULL, argv[0], char *, 3);
			if (argv[0] == NULL)
				err(1, NULL);
			(void)strcpy(argv[0], "-s");
		}
d586 3
a588 2
usage(is_ex)
	int is_ex;
d590 6
a595 7
#define	EX_USAGE \
    "ex [-eFRrsv] [-c command] [-t tag] [-w size] [files ...]"
#define	VI_USAGE \
    "vi [-eFRrv] [-c command] [-t tag] [-w size] [files ...]"

	(void)fprintf(stderr, "usage: %s\n", is_ex ? EX_USAGE : VI_USAGE);
	exit(1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
