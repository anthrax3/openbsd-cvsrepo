head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.18
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.14
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.12
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.10
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.15;
commitid	01nAnartGL7onLD3;

1.15
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.14;
commitid	ruCZ2IKF0FB0ebCr;

1.14
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	gtDERb7QyXwKGs62;

1.13
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.12;
commitid	06bi6U3x4gFFf2G1;

1.12
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.08.21.09.13;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.31.11.10.39;	author hugh;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.19.02.43.19;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.28;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.17.17.18.52;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.33.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: cut.c,v 1.14 2015/12/07 20:39:19 mmcc Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "common.h"

static void	cb_rotate(SCR *);

/*
 * cut --
 *	Put a range of lines/columns into a TEXT buffer.
 *
 * There are two buffer areas, both found in the global structure.  The first
 * is the linked list of all the buffers the user has named, the second is the
 * unnamed buffer storage.  There is a pointer, too, which is the current
 * default buffer, i.e. it may point to the unnamed buffer or a named buffer
 * depending on into what buffer the last text was cut.  Logically, in both
 * delete and yank operations, if the user names a buffer, the text is cut
 * into it.  If it's a delete of information on more than a single line, the
 * contents of the numbered buffers are rotated up one, the contents of the
 * buffer named '9' are discarded, and the text is cut into the buffer named
 * '1'.  The text is always cut into the unnamed buffer.
 *
 * In all cases, upper-case buffer names are the same as lower-case names,
 * with the exception that they cause the buffer to be appended to instead
 * of replaced.  Note, however, that if text is appended to a buffer, the
 * default buffer only contains the appended text, not the entire contents
 * of the buffer.
 *
 * !!!
 * The contents of the default buffer would disappear after most operations
 * in historic vi.  It's unclear that this is useful, so we don't bother.
 *
 * When users explicitly cut text into the numeric buffers, historic vi became
 * genuinely strange.  I've never been able to figure out what was supposed to
 * happen.  It behaved differently if you deleted text than if you yanked text,
 * and, in the latter case, the text was appended to the buffer instead of
 * replacing the contents.  Hopefully it's not worth getting right, and here
 * we just treat the numeric buffers like any other named buffer.
 *
 * PUBLIC: int cut(SCR *, CHAR_T *, MARK *, MARK *, int);
 */
int
cut(SCR *sp, CHAR_T *namep, MARK *fm, MARK *tm, int flags)
{
	CB *cbp;
	CHAR_T name = '1';	/* default numeric buffer */
	recno_t lno;
	int append, copy_one, copy_def;

	/*
	 * If the user specified a buffer, put it there.  (This may require
	 * a copy into the numeric buffers.  We do the copy so that we don't
	 * have to reference count and so we don't have to deal with things
	 * like appends to buffers that are used multiple times.)
	 *
	 * Otherwise, if it's supposed to be put in a numeric buffer (usually
	 * a delete) put it there.  The rules for putting things in numeric
	 * buffers were historically a little strange.  There were three cases.
	 *
	 *	1: Some motions are always line mode motions, which means
	 *	   that the cut always goes into the numeric buffers.
	 *	2: Some motions aren't line mode motions, e.g. d10w, but
	 *	   can cross line boundaries.  For these commands, if the
	 *	   cut crosses a line boundary, it goes into the numeric
	 *	   buffers.  This includes most of the commands.
	 *	3: Some motions aren't line mode motions, e.g. d`<char>,
	 *	   but always go into the numeric buffers, regardless.  This
	 *	   was the commands: % ` / ? ( ) N n { } -- and nvi adds ^A.
	 *
	 * Otherwise, put it in the unnamed buffer.
	 */
	append = copy_one = copy_def = 0;
	if (namep != NULL) {
		name = *namep;
		if (LF_ISSET(CUT_NUMREQ) || (LF_ISSET(CUT_NUMOPT) &&
		    (LF_ISSET(CUT_LINEMODE) || fm->lno != tm->lno))) {
			copy_one = 1;
			cb_rotate(sp);
		}
		if ((append = isupper(name)) == 1) {
			if (!copy_one)
				copy_def = 1;
			name = tolower(name);
		}
namecb:		CBNAME(sp, cbp, name);
	} else if (LF_ISSET(CUT_NUMREQ) || (LF_ISSET(CUT_NUMOPT) &&
	    (LF_ISSET(CUT_LINEMODE) || fm->lno != tm->lno))) {
		/* Copy into numeric buffer 1. */
		cb_rotate(sp);
		goto namecb;
	} else
		cbp = &sp->gp->dcb_store;

copyloop:
	/*
	 * If this is a new buffer, create it and add it into the list.
	 * Otherwise, if it's not an append, free its current contents.
	 */
	if (cbp == NULL) {
		CALLOC_RET(sp, cbp, 1, sizeof(CB));
		cbp->name = name;
		TAILQ_INIT(&cbp->textq);
		LIST_INSERT_HEAD(&sp->gp->cutq, cbp, q);
	} else if (!append) {
		text_lfree(&cbp->textq);
		cbp->len = 0;
		cbp->flags = 0;
	}


	/* In line mode, it's pretty easy, just cut the lines. */
	if (LF_ISSET(CUT_LINEMODE)) {
		cbp->flags |= CB_LMODE;
		for (lno = fm->lno; lno <= tm->lno; ++lno)
			if (cut_line(sp, lno, 0, CUT_LINE_TO_EOL, cbp))
				goto cut_line_err;
	} else {
		/*
		 * Get the first line.  A length of CUT_LINE_TO_EOL causes
		 * cut_line() to cut from the MARK to the end of the line.
		 */
		if (cut_line(sp, fm->lno, fm->cno, fm->lno != tm->lno ?
		    CUT_LINE_TO_EOL : (tm->cno - fm->cno) + 1, cbp))
			goto cut_line_err;

		/* Get the intermediate lines. */
		for (lno = fm->lno; ++lno < tm->lno;)
			if (cut_line(sp, lno, 0, CUT_LINE_TO_EOL, cbp))
				goto cut_line_err;

		/* Get the last line. */
		if (tm->lno != fm->lno &&
		    cut_line(sp, lno, 0, tm->cno + 1, cbp))
			goto cut_line_err;
	}

	append = 0;		/* Only append to the named buffer. */
	sp->gp->dcbp = cbp;	/* Repoint the default buffer on each pass. */

	if (copy_one) {		/* Copy into numeric buffer 1. */
		CBNAME(sp, cbp, name);
		copy_one = 0;
		goto copyloop;
	}
	if (copy_def) {		/* Copy into the default buffer. */
		cbp = &sp->gp->dcb_store;
		copy_def = 0;
		goto copyloop;
	}
	return (0);

cut_line_err:	
	text_lfree(&cbp->textq);
	cbp->len = 0;
	cbp->flags = 0;
	return (1);
}

/*
 * cb_rotate --
 *	Rotate the numbered buffers up one.
 */
static void
cb_rotate(SCR *sp)
{
	CB *cbp, *del_cbp;

	del_cbp = NULL;
	LIST_FOREACH(cbp, &sp->gp->cutq, q)
		switch(cbp->name) {
		case '1':
			cbp->name = '2';
			break;
		case '2':
			cbp->name = '3';
			break;
		case '3':
			cbp->name = '4';
			break;
		case '4':
			cbp->name = '5';
			break;
		case '5':
			cbp->name = '6';
			break;
		case '6':
			cbp->name = '7';
			break;
		case '7':
			cbp->name = '8';
			break;
		case '8':
			cbp->name = '9';
			break;
		case '9':
			del_cbp = cbp;
			break;
		}
	if (del_cbp != NULL) {
		LIST_REMOVE(del_cbp, q);
		text_lfree(&del_cbp->textq);
		free(del_cbp);
	}
}

/*
 * cut_line --
 *	Cut a portion of a single line.
 *
 * PUBLIC: int cut_line(SCR *, recno_t, size_t, size_t, CB *);
 */
int
cut_line(SCR *sp, recno_t lno, size_t fcno, size_t clen, CB *cbp)
{
	TEXT *tp;
	size_t len;
	char *p;

	/* Get the line. */
	if (db_get(sp, lno, DBG_FATAL, &p, &len))
		return (1);

	/* Create a TEXT structure that can hold the entire line. */
	if ((tp = text_init(sp, NULL, 0, len)) == NULL)
		return (1);

	/*
	 * If the line isn't empty and it's not the entire line,
	 * copy the portion we want, and reset the TEXT length.
	 */
	if (len != 0) {
		if (clen == CUT_LINE_TO_EOL)
			clen = len - fcno;
		memcpy(tp->lb, p + fcno, clen);
		tp->len = clen;
	}

	/* Append to the end of the cut buffer. */
	TAILQ_INSERT_TAIL(&cbp->textq, tp, q);
	cbp->len += tp->len;

	return (0);
}

/*
 * cut_close --
 *	Discard all cut buffers.
 *
 * PUBLIC: void cut_close(GS *);
 */
void
cut_close(GS *gp)
{
	CB *cbp;

	/* Free cut buffer list. */
	while ((cbp = LIST_FIRST(&gp->cutq)) != NULL) {
		if (!TAILQ_EMPTY(&cbp->textq))
			text_lfree(&cbp->textq);
		LIST_REMOVE(cbp, q);
		free(cbp);
	}

	/* Free default cut storage. */
	cbp = &gp->dcb_store;
	if (!TAILQ_EMPTY(&cbp->textq))
		text_lfree(&cbp->textq);
}

/*
 * text_init --
 *	Allocate a new TEXT structure.
 *
 * PUBLIC: TEXT *text_init(SCR *, const char *, size_t, size_t);
 */
TEXT *
text_init(SCR *sp, const char *p, size_t len, size_t total_len)
{
	TEXT *tp;

	CALLOC(sp, tp, 1, sizeof(TEXT));
	if (tp == NULL)
		return (NULL);
	/* ANSI C doesn't define a call to malloc(3) for 0 bytes. */
	if ((tp->lb_len = total_len) != 0) {
		MALLOC(sp, tp->lb, tp->lb_len);
		if (tp->lb == NULL) {
			free(tp);
			return (NULL);
		}
		if (p != NULL && len != 0)
			memcpy(tp->lb, p, len);
	}
	tp->len = len;
	return (tp);
}

/*
 * text_lfree --
 *	Free a chain of text structures.
 *
 * PUBLIC: void text_lfree(TEXTH *);
 */
void
text_lfree(TEXTH *headp)
{
	TEXT *tp;

	while ((tp = TAILQ_FIRST(headp))) {
		TAILQ_REMOVE(headp, tp, q);
		text_free(tp);
	}
}

/*
 * text_free --
 *	Free a text structure.
 *
 * PUBLIC: void text_free(TEXT *);
 */
void
text_free(TEXT *tp)
{
	if (tp->lb != NULL)
		free(tp->lb);
	free(tp);
}
@


1.15
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d62 1
a62 1
 * PUBLIC: int cut(SCR *, char *, MARK *, MARK *, int);
d65 1
a65 1
cut(SCR *sp, char *namep, MARK *fm, MARK *tm, int flags)
d68 1
a68 1
	char name = '1';	/* default numeric buffer */
@


1.14
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.13 2014/11/12 04:28:41 bentley Exp $	*/
d62 1
a62 1
 * PUBLIC: int cut(SCR *, CHAR_T *, MARK *, MARK *, int);
d65 1
a65 1
cut(SCR *sp, CHAR_T *namep, MARK *fm, MARK *tm, int flags)
d68 1
a68 1
	CHAR_T name = '1';	/* default numeric buffer */
@


1.13
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.12 2013/11/25 23:27:11 krw Exp $	*/
d122 1
a122 1
		CALLOC_RET(sp, cbp, CB *, 1, sizeof(CB));
d303 1
a303 1
	CALLOC(sp, tp, TEXT *, 1, sizeof(TEXT));
d308 1
a308 1
		MALLOC(sp, tp->lb, CHAR_T *, tp->lb_len);
@


1.12
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.11 2009/10/27 23:59:47 deraadt Exp $	*/
d65 1
a65 5
cut(sp, namep, fm, tm, flags)
	SCR *sp;
	CHAR_T *namep;
	MARK *fm, *tm;
	int flags;
d186 1
a186 2
cb_rotate(sp)
	SCR *sp;
d235 1
a235 5
cut_line(sp, lno, fcno, clen, cbp)
	SCR *sp;
	recno_t lno;
	size_t fcno, clen;
	CB *cbp;
d274 1
a274 2
cut_close(gp)
	GS *gp;
d299 1
a299 4
text_init(sp, p, len, total_len)
	SCR *sp;
	const char *p;
	size_t len, total_len;
d327 1
a327 2
text_lfree(headp)
	TEXTH *headp;
d344 1
a344 2
text_free(tp)
	TEXT *tp;
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.10 2006/01/08 21:09:13 miod Exp $	*/
d128 1
a128 1
		CIRCLEQ_INIT(&cbp->textq);
d270 1
a270 1
	CIRCLEQ_INSERT_TAIL(&cbp->textq, tp, q);
d290 1
a290 1
		if (CIRCLEQ_FIRST(&cbp->textq) != CIRCLEQ_END(&cbp->textq))
d298 1
a298 1
	if (CIRCLEQ_FIRST(&cbp->textq) != CIRCLEQ_END(&cbp->textq))
d345 2
a346 2
	while ((tp = CIRCLEQ_FIRST(headp)) != CIRCLEQ_END(headp)) {
		CIRCLEQ_REMOVE(headp, tp, q);
@


1.10
log
@Fix one more uninitialized variable scenario; from Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.9 2006/01/08 21:05:39 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)cut.c	10.10 (Berkeley) 9/15/96";
#endif /* not lint */
@


1.9
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.8 2005/10/17 19:12:16 otto Exp $	*/
d76 1
a76 1
	CHAR_T name;
d118 1
a118 1
		name = '1';
a170 1
		name = '1';
@


1.8
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.7 2002/02/16 21:27:56 millert Exp $	*/
d105 2
a106 2
		if (LF_ISSET(CUT_NUMREQ) || LF_ISSET(CUT_NUMOPT) &&
		    (LF_ISSET(CUT_LINEMODE) || fm->lno != tm->lno)) {
d116 2
a117 2
	} else if (LF_ISSET(CUT_NUMREQ) || LF_ISSET(CUT_NUMOPT) &&
	    (LF_ISSET(CUT_LINEMODE) || fm->lno != tm->lno)) {
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.6 2002/01/31 11:10:39 hugh Exp $	*/
d201 1
a201 1
	for (cbp = sp->gp->cutq.lh_first; cbp != NULL; cbp = cbp->q.le_next)
d294 2
a295 2
	while ((cbp = gp->cutq.lh_first) != NULL) {
		if (cbp->textq.cqh_first != (void *)&cbp->textq)
d303 1
a303 1
	if (cbp->textq.cqh_first != (void *)&cbp->textq)
d350 1
a350 1
	while ((tp = headp->cqh_first) != (void *)headp) {
@


1.6
log
@Bugfix picked up from NetBSD, and checked by pval:
: date: 2001/10/20 10:04:50;  author: aymeric
: Fix a cut_line() caller not using the right value for (former) ENTIRE_LINE,
: by defining the (newer) CUT_LINE_TO_EOL define in common/cut.h and using it
: where due.
: Bug reported on current-users by Masanori Kanaoka <kanaoka@@ann.hi-ho.ne.jp>
: diagnosed by Bang Jun-Young <bjy@@mogua.org>,
: quick-fixed by Robert Elz <kre@@munnari.OZ.AU>.
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.5 2001/09/19 02:43:19 pvalchev Exp $	*/
d32 1
a32 1
static void	cb_rotate __P((SCR *));
d66 1
a66 1
 * PUBLIC: int cut __P((SCR *, CHAR_T *, MARK *, MARK *, int));
d242 1
a242 1
 * PUBLIC: int cut_line __P((SCR *, recno_t, size_t, size_t, CB *));
d285 1
a285 1
 * PUBLIC: void cut_close __P((GS *));
d311 1
a311 1
 * PUBLIC: TEXT *text_init __P((SCR *, const char *, size_t, size_t));
d342 1
a342 1
 * PUBLIC: void text_lfree __P((TEXTH *));
d360 1
a360 1
 * PUBLIC: void text_free __P((TEXT *));
@


1.5
log
@Define ENTIRE_LINE to be -1 instead of 0 because we may want to copy 0 characters,
and use ENTIRE_LINE instead of hardcoding 0 in a few places.  Fixes a bug when
dw on an empty line would delete only the empty line, but copy the next line too.

From NetBSD, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.4 2001/01/29 01:58:28 niklas Exp $	*/
a140 1
#define	ENTIRE_LINE	-1
d145 1
a145 1
			if (cut_line(sp, lno, 0, ENTIRE_LINE, cbp))
d149 2
a150 2
		 * Get the first line.  A length of ENTIRE_LINE causes cut_line
		 * to cut from the MARK to the end of the line.
d153 1
a153 1
		    ENTIRE_LINE : (tm->cno - fm->cno) + 1, cbp))
d158 1
a158 1
			if (cut_line(sp, lno, 0, ENTIRE_LINE, cbp))
d268 1
a268 1
		if (clen == ENTIRE_LINE)
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 1
a141 1
#define	ENTIRE_LINE	0
d146 1
a146 1
			if (cut_line(sp, lno, 0, 0, cbp))
d150 1
a150 1
		 * Get the first line.  A length of 0 causes cut_line
d269 1
a269 1
		if (clen == 0)
@


1.3
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d1 2
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cut.c	10.9 (Berkeley) 3/30/96";
d269 1
a269 1
		memmove(tp->lb, p + fcno, clen);
d331 1
a331 1
			memmove(tp->lb, p, len);
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)cut.c	8.34 (Berkeley) 8/17/94";
a17 1
#include <sys/time.h>
a23 1
#include <signal.h>
a26 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d28 1
a28 1
#include "vi.h"
d30 1
a30 1
static int	cb_rotate __P((SCR *));
d63 2
d67 1
a67 1
cut(sp, ep, namep, fm, tm, flags)
a68 1
	EXF *ep;
d70 1
a71 1
	MARK *fm, *tm;
d103 1
a103 1
		if (LF_ISSET(CUT_NUMREQ) || LF_ISSET(CUT_NUMOPT) && 
d144 1
a144 1
			if (cut_line(sp, ep, lno, 0, 0, cbp))
d151 1
a151 1
		if (cut_line(sp, ep, fm->lno, fm->cno, fm->lno != tm->lno ?
d157 1
a157 1
			if (cut_line(sp, ep, lno, 0, ENTIRE_LINE, cbp))
d162 2
a163 6
		    cut_line(sp, ep, lno, 0, tm->cno + 1, cbp)) {
cut_line_err:		text_lfree(&cbp->textq);
			cbp->len = 0;
			cbp->flags = 0;
			return (1);
		}
d181 6
d193 1
a193 1
static int
d233 1
a233 1
		FREE(del_cbp, sizeof(CB));
a234 1
	return (0);
d240 2
d244 1
a244 1
cut_line(sp, ep, lno, fcno, clen, cbp)
a245 1
	EXF *ep;
d255 1
a255 2
	if ((p = file_gline(sp, ep, lno, &len)) == NULL) {
		GETLINE_ERR(sp, lno);
a256 1
	}
d281 26
d309 2
d323 1
a323 1
	/* ANSI C doesn't define a call to malloc(2) for 0 bytes. */
d340 2
d358 2
d366 2
a367 4
		FREE(tp->lb, tp->lb_len);
	if (tp->wd != NULL)
		FREE(tp->wd, tp->wd_len);
	FREE(tp, sizeof(TEXT));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
