head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.8
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.12
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.8
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.6
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.14;
commitid	adBvXLg05bJxz6yx;

1.14
date	2015.03.27.04.11.25;	author brynet;	state Exp;
branches;
next	1.13;
commitid	xTl6pibBNLW0U9wQ;

1.13
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.12;
commitid	06bi6U3x4gFFf2G1;

1.12
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.27.08.52.41;	author zhuk;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.25.23.27.11;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.14.12.32.29;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.17.17.18.53;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@/*	$OpenBSD: line.c,v 1.14 2015/03/27 04:11:25 brynet Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#include "common.h"
#include "../vi/vi.h"

static int scr_update(SCR *, recno_t, lnop_t, int);

/*
 * db_eget --
 *	Front-end to db_get, special case handling for empty files.
 *
 * PUBLIC: int db_eget(SCR *, recno_t, char **, size_t *, int *);
 */
int
db_eget(SCR *sp, recno_t lno, char **pp, size_t *lenp, int *isemptyp)
{
	recno_t l1;

	if (isemptyp != NULL)
		*isemptyp = 0;

	/* If the line exists, simply return it. */
	if (!db_get(sp, lno, 0, pp, lenp))
		return (0);

	/*
	 * If the user asked for line 0 or line 1, i.e. the only possible
	 * line in an empty file, find the last line of the file; db_last
	 * fails loudly.
	 */
	if ((lno == 0 || lno == 1) && db_last(sp, &l1))
		return (1);

	/* If the file isn't empty, fail loudly. */
	if ((lno != 0 && lno != 1) || l1 != 0) {
		db_err(sp, lno);
		return (1);
	}

	if (isemptyp != NULL)
		*isemptyp = 1;

	return (1);
}

/*
 * db_get --
 *	Look in the text buffers for a line, followed by the cache, followed
 *	by the database.
 *
 * PUBLIC: int db_get(SCR *, recno_t, u_int32_t, char **, size_t *);
 */
int
db_get(SCR *sp, recno_t lno, u_int32_t flags, char **pp, size_t *lenp)
{
	DBT data, key;
	EXF *ep;
	TEXT *tp;
	recno_t l1, l2;

	/*
	 * The underlying recno stuff handles zero by returning NULL, but
	 * have to have an OOB condition for the look-aside into the input
	 * buffer anyway.
	 */
	if (lno == 0)
		goto err1;

	/* Check for no underlying file. */
	if ((ep = sp->ep) == NULL) {
		ex_emsg(sp, NULL, EXM_NOFILEYET);
		goto err3;
	}

	if (LF_ISSET(DBG_NOCACHE))
		goto nocache;

	/*
	 * Look-aside into the TEXT buffers and see if the line we want
	 * is there.
	 */
	if (F_ISSET(sp, SC_TINPUT)) {
		l1 = TAILQ_FIRST(&sp->tiq)->lno;
		l2 = TAILQ_LAST(&sp->tiq, _texth)->lno;
		if (l1 <= lno && l2 >= lno) {
#if defined(DEBUG) && 0
	TRACE(sp, "retrieve TEXT buffer line %lu\n", (u_long)lno);
#endif
			TAILQ_FOREACH(tp, &sp->tiq, q) {
				if (tp->lno == lno)
					break;
			}
			if (lenp != NULL)
				*lenp = tp->len;
			if (pp != NULL)
				*pp = tp->lb;
			return (0);
		}
		/*
		 * Adjust the line number for the number of lines used
		 * by the text input buffers.
		 */
		if (lno > l2)
			lno -= l2 - l1;
	}

	/* Look-aside into the cache, and see if the line we want is there. */
	if (lno == ep->c_lno) {
#if defined(DEBUG) && 0
	TRACE(sp, "retrieve cached line %lu\n", (u_long)lno);
#endif
		if (lenp != NULL)
			*lenp = ep->c_len;
		if (pp != NULL)
			*pp = ep->c_lp;
		return (0);
	}
	ep->c_lno = OOBLNO;

nocache:
	/* Get the line from the underlying database. */
	key.data = &lno;
	key.size = sizeof(lno);
	switch (ep->db->get(ep->db, &key, &data, 0)) {
        case -1:
		goto err2;
	case 1:
err1:		if (LF_ISSET(DBG_FATAL))
err2:			db_err(sp, lno);
err3:		if (lenp != NULL)
			*lenp = 0;
		if (pp != NULL)
			*pp = NULL;
		return (1);
	}

	/* Reset the cache. */
	ep->c_lno = lno;
	ep->c_len = data.size;
	ep->c_lp = data.data;

#if defined(DEBUG) && 0
	TRACE(sp, "retrieve DB line %lu\n", (u_long)lno);
#endif
	if (lenp != NULL)
		*lenp = data.size;
	if (pp != NULL)
		*pp = ep->c_lp;
	return (0);
}

/*
 * db_delete --
 *	Delete a line from the file.
 *
 * PUBLIC: int db_delete(SCR *, recno_t);
 */
int
db_delete(SCR *sp, recno_t lno)
{
	DBT key;
	EXF *ep;

#if defined(DEBUG) && 0
	TRACE(sp, "delete line %lu\n", (u_long)lno);
#endif
	/* Check for no underlying file. */
	if ((ep = sp->ep) == NULL) {
		ex_emsg(sp, NULL, EXM_NOFILEYET);
		return (1);
	}
		
	/* Update marks, @@ and global commands. */
	if (mark_insdel(sp, LINE_DELETE, lno))
		return (1);
	if (ex_g_insdel(sp, LINE_DELETE, lno))
		return (1);

	/* Log change. */
	log_line(sp, lno, LOG_LINE_DELETE);

	/* Update file. */
	key.data = &lno;
	key.size = sizeof(lno);
	if (ep->db->del(ep->db, &key, 0) == 1) {
		msgq(sp, M_SYSERR,
		    "unable to delete line %lu", (u_long)lno);
		return (1);
	}

	/* Flush the cache, update line count, before screen update. */
	if (lno <= ep->c_lno)
		ep->c_lno = OOBLNO;
	if (ep->c_nlines != OOBLNO)
		--ep->c_nlines;

	/* File now modified. */
	if (F_ISSET(ep, F_FIRSTMODIFY))
		(void)rcv_init(sp);
	F_SET(ep, F_MODIFIED);

	/* Update screen. */
	return (scr_update(sp, lno, LINE_DELETE, 1));
}

/*
 * db_append --
 *	Append a line into the file.
 *
 * PUBLIC: int db_append(SCR *, int, recno_t, char *, size_t);
 */
int
db_append(SCR *sp, int update, recno_t lno, char *p, size_t len)
{
	DBT data, key;
	EXF *ep;
	int rval;

#if defined(DEBUG) && 0
	TRACE(sp, "append to %lu: len %u {%.*s}\n", lno, len, MIN(len, 20), p);
#endif
	/* Check for no underlying file. */
	if ((ep = sp->ep) == NULL) {
		ex_emsg(sp, NULL, EXM_NOFILEYET);
		return (1);
	}
		
	/* Update file. */
	key.data = &lno;
	key.size = sizeof(lno);
	data.data = p;
	data.size = len;
	if (ep->db->put(ep->db, &key, &data, R_IAFTER) == -1) {
		msgq(sp, M_SYSERR,
		    "unable to append to line %lu", (u_long)lno);
		return (1);
	}

	/* Flush the cache, update line count, before screen update. */
	if (lno < ep->c_lno)
		ep->c_lno = OOBLNO;
	if (ep->c_nlines != OOBLNO)
		++ep->c_nlines;

	/* File now dirty. */
	if (F_ISSET(ep, F_FIRSTMODIFY))
		(void)rcv_init(sp);
	F_SET(ep, F_MODIFIED);

	/* Log change. */
	log_line(sp, lno + 1, LOG_LINE_APPEND);

	/* Update marks, @@ and global commands. */
	rval = 0;
	if (mark_insdel(sp, LINE_INSERT, lno + 1))
		rval = 1;
	if (ex_g_insdel(sp, LINE_INSERT, lno + 1))
		rval = 1;

	/*
	 * Update screen.
	 *
	 * XXX
	 * Nasty hack.  If multiple lines are input by the user, they aren't
	 * committed until an <ESC> is entered.  The problem is the screen was
	 * updated/scrolled as each line was entered.  So, when this routine
	 * is called to copy the new lines from the cut buffer into the file,
	 * it has to know not to update the screen again.
	 */
	return (scr_update(sp, lno, LINE_APPEND, update) || rval);
}

/*
 * db_insert --
 *	Insert a line into the file.
 *
 * PUBLIC: int db_insert(SCR *, recno_t, char *, size_t);
 */
int
db_insert(SCR *sp, recno_t lno, char *p, size_t len)
{
	DBT data, key;
	EXF *ep;
	int rval;

#if defined(DEBUG) && 0
	TRACE(sp, "insert before %lu: len %lu {%.*s}\n",
	    (u_long)lno, (u_long)len, MIN(len, 20), p);
#endif
	/* Check for no underlying file. */
	if ((ep = sp->ep) == NULL) {
		ex_emsg(sp, NULL, EXM_NOFILEYET);
		return (1);
	}
		
	/* Update file. */
	key.data = &lno;
	key.size = sizeof(lno);
	data.data = p;
	data.size = len;
	if (ep->db->put(ep->db, &key, &data, R_IBEFORE) == -1) {
		msgq(sp, M_SYSERR,
		    "unable to insert at line %lu", (u_long)lno);
		return (1);
	}

	/* Flush the cache, update line count, before screen update. */
	if (lno >= ep->c_lno)
		ep->c_lno = OOBLNO;
	if (ep->c_nlines != OOBLNO)
		++ep->c_nlines;

	/* File now dirty. */
	if (F_ISSET(ep, F_FIRSTMODIFY))
		(void)rcv_init(sp);
	F_SET(ep, F_MODIFIED);

	/* Log change. */
	log_line(sp, lno, LOG_LINE_INSERT);

	/* Update marks, @@ and global commands. */
	rval = 0;
	if (mark_insdel(sp, LINE_INSERT, lno))
		rval = 1;
	if (ex_g_insdel(sp, LINE_INSERT, lno))
		rval = 1;

	/* Update screen. */
	return (scr_update(sp, lno, LINE_INSERT, 1) || rval);
}

/*
 * db_set --
 *	Store a line in the file.
 *
 * PUBLIC: int db_set(SCR *, recno_t, char *, size_t);
 */
int
db_set(SCR *sp, recno_t lno, char *p, size_t len)
{
	DBT data, key;
	EXF *ep;

#if defined(DEBUG) && 0
	TRACE(sp, "replace line %lu: len %lu {%.*s}\n",
	    (u_long)lno, (u_long)len, MIN(len, 20), p);
#endif

	/* Check for no underlying file. */
	if ((ep = sp->ep) == NULL) {
		ex_emsg(sp, NULL, EXM_NOFILEYET);
		return (1);
	}
		
	/* Log before change. */
	log_line(sp, lno, LOG_LINE_RESET_B);

	/* Update file. */
	key.data = &lno;
	key.size = sizeof(lno);
	data.data = p;
	data.size = len;
	if (ep->db->put(ep->db, &key, &data, 0) == -1) {
		msgq(sp, M_SYSERR,
		    "unable to store line %lu", (u_long)lno);
		return (1);
	}

	/* Flush the cache, before logging or screen update. */
	if (lno == ep->c_lno)
		ep->c_lno = OOBLNO;

	/* File now dirty. */
	if (F_ISSET(ep, F_FIRSTMODIFY))
		(void)rcv_init(sp);
	F_SET(ep, F_MODIFIED);

	/* Log after change. */
	log_line(sp, lno, LOG_LINE_RESET_F);

	/* Update screen. */
	return (scr_update(sp, lno, LINE_RESET, 1));
}

/*
 * db_exist --
 *	Return if a line exists.
 *
 * PUBLIC: int db_exist(SCR *, recno_t);
 */
int
db_exist(SCR *sp, recno_t lno)
{
	EXF *ep;

	/* Check for no underlying file. */
	if ((ep = sp->ep) == NULL) {
		ex_emsg(sp, NULL, EXM_NOFILEYET);
		return (1);
	}

	if (lno == OOBLNO)
		return (0);
		
	/*
	 * Check the last-line number cache.  Adjust the cached line
	 * number for the lines used by the text input buffers.
	 */
	if (ep->c_nlines != OOBLNO)
		return (lno <= (F_ISSET(sp, SC_TINPUT) ?
		    ep->c_nlines + (TAILQ_LAST(&sp->tiq, _texth)->lno
		    - TAILQ_FIRST(&sp->tiq)->lno) : ep->c_nlines));

	/* Go get the line. */
	return (!db_get(sp, lno, 0, NULL, NULL));
}

/*
 * db_last --
 *	Return the number of lines in the file.
 *
 * PUBLIC: int db_last(SCR *, recno_t *);
 */
int
db_last(SCR *sp, recno_t *lnop)
{
	DBT data, key;
	EXF *ep;
	recno_t lno;

	/* Check for no underlying file. */
	if ((ep = sp->ep) == NULL) {
		ex_emsg(sp, NULL, EXM_NOFILEYET);
		return (1);
	}
		
	/*
	 * Check the last-line number cache.  Adjust the cached line
	 * number for the lines used by the text input buffers.
	 */
	if (ep->c_nlines != OOBLNO) {
		*lnop = ep->c_nlines;
		if (F_ISSET(sp, SC_TINPUT))
			*lnop += TAILQ_LAST(&sp->tiq, _texth)->lno -
			    TAILQ_FIRST(&sp->tiq)->lno;
		return (0);
	}

	key.data = &lno;
	key.size = sizeof(lno);

	switch (ep->db->seq(ep->db, &key, &data, R_LAST)) {
        case -1:
		msgq(sp, M_SYSERR, "unable to get last line");
		*lnop = 0;
		return (1);
        case 1:
		*lnop = 0;
		return (0);
	default:
		break;
	}

	/* Fill the cache. */
	memcpy(&lno, key.data, sizeof(lno));
	ep->c_nlines = ep->c_lno = lno;
	ep->c_len = data.size;
	ep->c_lp = data.data;

	/* Return the value. */
	*lnop = (F_ISSET(sp, SC_TINPUT) &&
	    TAILQ_LAST(&sp->tiq, _texth)->lno > lno ?
	    TAILQ_LAST(&sp->tiq, _texth)->lno : lno);
	return (0);
}

/*
 * db_err --
 *	Report a line error.
 *
 * PUBLIC: void db_err(SCR *, recno_t);
 */
void
db_err(SCR *sp, recno_t lno)
{
	msgq(sp, M_ERR,
	    "Error: unable to retrieve line %lu", (u_long)lno);
}

/*
 * scr_update --
 *	Update all of the screens that are backed by the file that
 *	just changed.
 */
static int
scr_update(SCR *sp, recno_t lno, lnop_t op, int current)
{
	EXF *ep;
	SCR *tsp;

	if (F_ISSET(sp, SC_EX))
		return (0);

	ep = sp->ep;
	if (ep->refcnt != 1)
		TAILQ_FOREACH(tsp, &sp->gp->dq, q)
			if (sp != tsp && tsp->ep == ep)
				if (vs_change(tsp, lno, op))
					return (1);
	return (current ? vs_change(sp, lno, op) : 0);
}
@


1.14
log
@Some vi cleanup, unifdef's some signal blocking code that has never been
enabled in our tree, also removes some stragglers from a global struct
referencing nonexistent Tcl/TK and "IP support". And finally.. deletes
an empty file missed by earlier cleanup by bentley@@.

Inspired by and ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.13 2014/11/12 04:28:41 bentley Exp $	*/
d208 1
a208 1
		    "003|unable to delete line %lu", (u_long)lno);
d256 1
a256 1
		    "004|unable to append to line %lu", (u_long)lno);
d324 1
a324 1
		    "005|unable to insert at line %lu", (u_long)lno);
d386 1
a386 1
		    "006|unable to store line %lu", (u_long)lno);
d475 1
a475 1
		msgq(sp, M_SYSERR, "007|unable to get last line");
d508 1
a508 1
	    "008|Error: unable to retrieve line %lu", (u_long)lno);
@


1.13
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.12 2013/11/28 22:12:40 krw Exp $	*/
a205 1
	SIGBLOCK;
a210 1
	SIGUNBLOCK;
a253 1
	SIGBLOCK;
a258 1
	SIGUNBLOCK;
a321 1
	SIGBLOCK;
a326 1
	SIGUNBLOCK;
a383 1
	SIGBLOCK;
a388 1
	SIGUNBLOCK;
@


1.12
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.11 2013/11/27 08:52:41 zhuk Exp $	*/
d36 1
a36 6
db_eget(sp, lno, pp, lenp, isemptyp)
	SCR *sp;
	recno_t lno;				/* Line number. */
	char **pp;				/* Pointer store. */
	size_t *lenp;				/* Length store. */
	int *isemptyp;
d75 1
a75 6
db_get(sp, lno, flags, pp, lenp)
	SCR *sp;
	recno_t lno;				/* Line number. */
	u_int32_t flags;
	char **pp;				/* Pointer store. */
	size_t *lenp;				/* Length store. */
d180 1
a180 3
db_delete(sp, lno)
	SCR *sp;
	recno_t lno;
d236 1
a236 6
db_append(sp, update, lno, p, len)
	SCR *sp;
	int update;
	recno_t lno;
	char *p;
	size_t len;
d305 1
a305 5
db_insert(sp, lno, p, len)
	SCR *sp;
	recno_t lno;
	char *p;
	size_t len;
d366 1
a366 5
db_set(sp, lno, p, len)
	SCR *sp;
	recno_t lno;
	char *p;
	size_t len;
d421 1
a421 3
db_exist(sp, lno)
	SCR *sp;
	recno_t lno;
d454 1
a454 3
db_last(sp, lnop)
	SCR *sp;
	recno_t *lnop;
d513 1
a513 3
db_err(sp, lno)
	SCR *sp;
	recno_t lno;
d525 1
a525 5
scr_update(sp, lno, op, current)
	SCR *sp;
	recno_t lno;
	lnop_t op;
	int current;
@


1.11
log
@Zap some pointer casts became extra (and thus dangerous) after recent
CIRCLEQ removal.

okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.10 2013/11/25 23:27:11 krw Exp $	*/
d570 1
a570 1
		CIRCLEQ_FOREACH(tsp, &sp->gp->dq, q)
@


1.10
log
@Replace _texth CIRCLEQ with TAILQ. One down, five to go.

Read, tested, fixed and ok'd zhuk@@ pelikan@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.9 2009/10/27 23:59:47 deraadt Exp $	*/
d114 2
a115 2
		l1 = ((TEXT *)TAILQ_FIRST(&sp->tiq))->lno;
		l2 = ((TEXT *)TAILQ_LAST(&sp->tiq, _texth))->lno;
d467 2
a468 2
		    ep->c_nlines + (((TEXT *)TAILQ_LAST(&sp->tiq, _texth))->lno
		    - ((TEXT *)TAILQ_FIRST(&sp->tiq))->lno) : ep->c_nlines));
d502 2
a503 2
			*lnop += ((TEXT *)TAILQ_LAST(&sp->tiq, _texth))->lno -
			    ((TEXT *)TAILQ_FIRST(&sp->tiq))->lno;
d530 2
a531 2
	    ((TEXT *)TAILQ_LAST(&sp->tiq, _texth))->lno > lno ?
	    ((TEXT *)TAILQ_LAST(&sp->tiq, _texth))->lno : lno);
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.8 2007/05/14 12:32:29 pyr Exp $	*/
d114 2
a115 2
		l1 = ((TEXT *)CIRCLEQ_FIRST(&sp->tiq))->lno;
		l2 = ((TEXT *)CIRCLEQ_LAST(&sp->tiq))->lno;
d120 4
a123 2
			for (tp = CIRCLEQ_FIRST(&sp->tiq);
			    tp->lno != lno; tp = CIRCLEQ_NEXT(tp, q));
d467 2
a468 2
		    ep->c_nlines + (((TEXT *)CIRCLEQ_LAST(&sp->tiq))->lno -
		    ((TEXT *)CIRCLEQ_FIRST(&sp->tiq))->lno) : ep->c_nlines));
d502 2
a503 2
			*lnop += ((TEXT *)CIRCLEQ_LAST(&sp->tiq))->lno -
			    ((TEXT *)CIRCLEQ_FIRST(&sp->tiq))->lno;
d530 2
a531 2
	    ((TEXT *)CIRCLEQ_LAST(&sp->tiq))->lno > lno ?
	    ((TEXT *)CIRCLEQ_LAST(&sp->tiq))->lno : lno);
@


1.8
log
@use sys/queue macros instead of accessing fields directly.
no binary change.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.7 2006/01/08 21:05:39 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)line.c	10.21 (Berkeley) 9/15/96";
#endif /* not lint */
@


1.7
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.6 2005/10/17 19:12:16 otto Exp $	*/
d469 1
a469 1
		    ep->c_nlines + (((TEXT *)sp->tiq.cqh_last)->lno -
d504 1
a504 1
			*lnop += ((TEXT *)sp->tiq.cqh_last)->lno -
d532 2
a533 2
	    ((TEXT *)sp->tiq.cqh_last)->lno > lno ?
	    ((TEXT *)sp->tiq.cqh_last)->lno : lno);
@


1.6
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.5 2002/02/16 21:27:57 millert Exp $	*/
d65 1
a65 1
	if (lno != 0 && lno != 1 || l1 != 0) {
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: line.c,v 1.4 2001/01/29 01:58:30 niklas Exp $	*/
d118 2
a119 2
		l1 = ((TEXT *)sp->tiq.cqh_first)->lno;
		l2 = ((TEXT *)sp->tiq.cqh_last)->lno;
d124 2
a125 2
			for (tp = sp->tiq.cqh_first;
			    tp->lno != lno; tp = tp->q.cqe_next);
d470 1
a470 1
		    ((TEXT *)sp->tiq.cqh_first)->lno) : ep->c_nlines));
d505 1
a505 1
			    ((TEXT *)sp->tiq.cqh_first)->lno;
d572 1
a572 2
		for (tsp = sp->gp->dq.cqh_first;
		    tsp != (void *)&sp->gp->dq; tsp = tsp->q.cqe_next)
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
static int scr_update __P((SCR *, recno_t, lnop_t, int));
d37 1
a37 1
 * PUBLIC: int db_eget __P((SCR *, recno_t, char **, size_t *, int *));
d81 1
a81 1
 * PUBLIC: int db_get __P((SCR *, recno_t, u_int32_t, char **, size_t *));
d189 1
a189 1
 * PUBLIC: int db_delete __P((SCR *, recno_t));
d247 1
a247 1
 * PUBLIC: int db_append __P((SCR *, int, recno_t, char *, size_t));
d321 1
a321 1
 * PUBLIC: int db_insert __P((SCR *, recno_t, char *, size_t));
d386 1
a386 1
 * PUBLIC: int db_set __P((SCR *, recno_t, char *, size_t));
d445 1
a445 1
 * PUBLIC: int db_exist __P((SCR *, recno_t));
d480 1
a480 1
 * PUBLIC: int db_last __P((SCR *, recno_t *));
d541 1
a541 1
 * PUBLIC: void db_err __P((SCR *, recno_t));
@


1.3
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d1 2
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)line.c	10.20 (Berkeley) 4/27/96";
a22 1
#include <signal.h>
d523 1
a523 1
	memmove(&lno, key.data, sizeof(lno));
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)line.c	8.32 (Berkeley) 8/17/94";
a25 1
#include <termios.h>
d27 2
a28 3
#include "compat.h"
#include <db.h>
#include <regex.h>
d30 1
a30 2
#include "vi.h"
#include "excmd.h"
d32 42
a73 2
static __inline int scr_update
    __P((SCR *, EXF *, recno_t, enum operation, int));
d76 5
a80 3
 * file_gline --
 *	Look in the text buffers for a line; if it's not there
 *	call file_rline to retrieve it from the database.
d82 2
a83 2
char *
file_gline(sp, ep, lno, lenp)
a84 1
	EXF *ep;
d86 2
d90 2
d97 1
a97 1
	 * have to have an oob condition for the look-aside into the input
d101 10
a110 1
		return (NULL);
d116 3
a118 3
	if (F_ISSET(sp, S_INPUT)) {
		l1 = ((TEXT *)sp->tiqp->cqh_first)->lno;
		l2 = ((TEXT *)sp->tiqp->cqh_last)->lno;
d120 4
a123 1
			for (tp = sp->tiqp->cqh_first;
d125 1
a125 1
			if (lenp)
d127 3
a129 1
			return (tp->lb);
a137 2
	return (file_rline(sp, ep, lno, lenp));
}
d139 1
a139 15
/*
 * file_rline --
 *	Look in the cache for a line; if it's not there retrieve
 *	it from the file.
 */
char *
file_rline(sp, ep, lno, lenp)
	SCR *sp;
	EXF *ep;
	recno_t lno;				/* Line number. */
	size_t *lenp;				/* Length store. */
{
	DBT data, key;

	/* Check the cache. */
d141 4
a144 1
		if (lenp)
d146 3
a148 1
		return (ep->c_lp);
d152 1
d158 9
a166 7
		msgq(sp, M_ERR,
		    "Error: %s/%d: unable to get line %u: %s",
		    tail(__FILE__), __LINE__, lno, strerror(errno));
		/* FALLTHROUGH */
        case 1:
		return (NULL);
		/* NOTREACHED */
a167 2
	if (lenp)
		*lenp = data.size;
d169 1
a169 1
	/* Fill the cache. */
d174 8
a181 1
	return (data.data);
d185 1
a185 1
 * file_dline --
d187 2
d191 1
a191 1
file_dline(sp, ep, lno)
a192 1
	EXF *ep;
d196 1
d199 1
a199 1
	TRACE(sp, "delete line %lu\n", lno);
d201 11
a211 7
	/*
	 * XXX
	 * Marks and global commands have to know when lines are
	 * inserted or deleted.
	 */
	mark_insdel(sp, ep, LINE_DELETE, lno);
	global_insdel(sp, ep, LINE_DELETE, lno);
d214 1
a214 1
	log_line(sp, ep, lno, LOG_LINE_DELETE);
d219 1
a219 1
	SIGBLOCK(sp->gp);
d221 2
a222 3
		msgq(sp, M_ERR,
		    "Error: %s/%d: unable to delete line %u: %s",
		    tail(__FILE__), __LINE__, lno, strerror(errno));
d225 1
a225 1
	SIGUNBLOCK(sp->gp);
d233 1
a233 1
	/* File now dirty. */
d235 1
a235 1
		(void)rcv_init(sp, ep);
d239 1
a239 1
	return (scr_update(sp, ep, lno, LINE_DELETE, 1));
d243 1
a243 1
 * file_aline --
d245 2
d249 1
a249 1
file_aline(sp, ep, update, lno, p, len)
a250 1
	EXF *ep;
d257 2
a258 1
	recno_t lline;
d263 4
a266 18
	/*
	 * XXX
	 * Very nasty special case.  The historic vi code displays a single
	 * space (or a '$' if the list option is set) for the first line in
	 * an "empty" file.  If we "insert" a line, that line gets scrolled
	 * down, not repainted, so it's incorrect when we refresh the the
	 * screen.  This is really hard to find and fix in the vi code -- the
	 * text input functions detect it explicitly and don't insert a new
	 * line.  The hack here is to repaint the screen if we're appending
	 * to an empty file.  The reason that the test is in file_aline, and
	 * not in file_iline or file_sline, is that all of the ex commands
	 * that work in empty files end up here.
	 */
	if (lno == 0) {
		if (file_lline(sp, ep, &lline))
			return (1);
		if (lline == 0)
			F_SET(sp, S_REDRAW);
d268 1
a268 1

d274 1
a274 1
	SIGBLOCK(sp->gp);
d276 2
a277 3
		msgq(sp, M_ERR,
		    "Error: %s/%d: unable to append to line %u: %s",
		    tail(__FILE__), __LINE__, lno, strerror(errno));
d280 1
a280 1
	SIGUNBLOCK(sp->gp);
d290 1
a290 1
		(void)rcv_init(sp, ep);
d294 1
a294 1
	log_line(sp, ep, lno + 1, LOG_LINE_APPEND);
d296 6
a301 14
	/*
	 * XXX
	 * Marks and global commands have to know when lines are
	 * inserted or deleted.
	 *
	 * XXX
	 * See comment above about empty files.  If the file was empty,
	 * then we're adding the first line, which is a replacement, not
	 * an append.  So, we shouldn't whack the marks.
	 */
	if (lno != 0) {
		mark_insdel(sp, ep, LINE_INSERT, lno + 1);
		global_insdel(sp, ep, LINE_INSERT, lno + 1);
	}
d313 1
a313 1
	return (scr_update(sp, ep, lno, LINE_APPEND, update));
d317 1
a317 1
 * file_iline --
d319 2
d323 1
a323 1
file_iline(sp, ep, lno, p, len)
a324 1
	EXF *ep;
d330 2
a331 1
	recno_t lline;
d334 2
a335 2
	TRACE(sp,
	    "insert before %lu: len %u {%.*s}\n", lno, len, MIN(len, 20), p);
d337 4
a340 7

	/* Very nasty special case.  See comment in file_aline(). */
	if (lno == 1) {
		if (file_lline(sp, ep, &lline))
			return (1);
		if (lline == 0)
			F_SET(sp, S_REDRAW);
d342 1
a342 1

d348 1
a348 1
	SIGBLOCK(sp->gp);
d350 2
a351 3
		msgq(sp, M_ERR,
		    "Error: %s/%d: unable to insert at line %u: %s",
		    tail(__FILE__), __LINE__, lno, strerror(errno));
d354 1
a354 1
	SIGUNBLOCK(sp->gp);
d364 1
a364 1
		(void)rcv_init(sp, ep);
d368 1
a368 1
	log_line(sp, ep, lno, LOG_LINE_INSERT);
d370 6
a375 7
	/*
	 * XXX
	 * Marks and global commands have to know when lines are
	 * inserted or deleted.
	 */
	mark_insdel(sp, ep, LINE_INSERT, lno);
	global_insdel(sp, ep, LINE_INSERT, lno);
d378 1
a378 1
	return (scr_update(sp, ep, lno, LINE_INSERT, 1));
d382 1
a382 1
 * file_sline --
d384 2
d388 1
a388 1
file_sline(sp, ep, lno, p, len)
a389 1
	EXF *ep;
d395 1
d398 2
a399 2
	TRACE(sp,
	    "replace line %lu: len %u {%.*s}\n", lno, len, MIN(len, 20), p);
d401 7
d409 1
a409 1
	log_line(sp, ep, lno, LOG_LINE_RESET_B);
d416 1
a416 1
	SIGBLOCK(sp->gp);
d418 2
a419 3
		msgq(sp, M_ERR,
		    "Error: %s/%d: unable to store line %u: %s",
		    tail(__FILE__), __LINE__, lno, strerror(errno));
d422 1
a422 1
	SIGUNBLOCK(sp->gp);
d430 1
a430 1
		(void)rcv_init(sp, ep);
d434 1
a434 1
	log_line(sp, ep, lno, LOG_LINE_RESET_F);
d437 36
a472 1
	return (scr_update(sp, ep, lno, LINE_RESET, 1));
d476 1
a476 1
 * file_lline --
d478 2
d482 1
a482 1
file_lline(sp, ep, lnop)
a483 1
	EXF *ep;
d487 1
d490 10
a499 1
	/* Check the cache. */
d501 4
a504 3
		*lnop = (F_ISSET(sp, S_INPUT) &&
		    ((TEXT *)sp->tiqp->cqh_last)->lno > ep->c_nlines ?
		    ((TEXT *)sp->tiqp->cqh_last)->lno : ep->c_nlines);
d513 1
a513 3
		msgq(sp, M_ERR,
		    "Error: %s/%d: unable to get last line: %s",
		    tail(__FILE__), __LINE__, strerror(errno));
d530 3
a532 3
	*lnop = (F_ISSET(sp, S_INPUT) &&
	    ((TEXT *)sp->tiqp->cqh_last)->lno > lno ?
	    ((TEXT *)sp->tiqp->cqh_last)->lno : lno);
d537 15
d556 2
a557 2
static __inline int
scr_update(sp, ep, lno, op, current)
a558 1
	EXF *ep;
d560 1
a560 1
	enum operation op;
d563 1
d566 4
d574 3
a576 2
				(void)sp->s_change(tsp, ep, lno, op);
	return (current && sp->s_change(sp, ep, lno, op));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
