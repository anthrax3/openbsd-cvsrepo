head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.18
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.14
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.12
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.10
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.6.0.16
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.14
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.12
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.18
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.17;
commitid	01nAnartGL7onLD3;

1.17
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.16;
commitid	ruCZ2IKF0FB0ebCr;

1.16
date	2016.01.20.08.43.27;	author bentley;	state Exp;
branches;
next	1.15;
commitid	etzsUqpfZbRGvPEg;

1.15
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.14;
commitid	adBvXLg05bJxz6yx;

1.14
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	Uu5nFG3wCl0LACBb;

1.13
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.12;
commitid	06bi6U3x4gFFf2G1;

1.12
date	2014.11.10.21.31.42;	author tedu;	state Exp;
branches;
next	1.11;
commitid	69Pn8C3VMgeMEZUy;

1.11
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.08.21.08.27;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.29;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.11.26.22.49.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.16.01.18.16;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.15.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.34.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: key.c,v 1.16 2016/01/20 08:43:27 bentley Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1991, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "../vi/vi.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

static int	v_event_append(SCR *, EVENT *);
static int	v_event_grow(SCR *, int);
static int	v_key_cmp(const void *, const void *);
static void	v_keyval(SCR *, int, scr_keyval_t);
static void	v_sync(SCR *, int);

/*
 * !!!
 * Historic vi always used:
 *
 *	^D: autoindent deletion
 *	^H: last character deletion
 *	^W: last word deletion
 *	^Q: quote the next character (if not used in flow control).
 *	^V: quote the next character
 *
 * regardless of the user's choices for these characters.  The user's erase
 * and kill characters worked in addition to these characters.  Nvi wires
 * down the above characters, but in addition permits the VEOF, VERASE, VKILL
 * and VWERASE characters described by the user's termios structure.
 *
 * Ex was not consistent with this scheme, as it historically ran in tty
 * cooked mode.  This meant that the scroll command and autoindent erase
 * characters were mapped to the user's EOF character, and the character
 * and word deletion characters were the user's tty character and word
 * deletion characters.  This implementation makes it all consistent, as
 * described above for vi.
 *
 * !!!
 * This means that all screens share a special key set.
 */
KEYLIST keylist[] = {
	{K_BACKSLASH,	  '\\'},	/*  \ */
	{K_CARAT,	   '^'},	/*  ^ */
	{K_CNTRLD,	'\004'},	/* ^D */
	{K_CNTRLR,	'\022'},	/* ^R */
	{K_CNTRLT,	'\024'},	/* ^T */
	{K_CNTRLZ,	'\032'},	/* ^Z */
	{K_COLON,	   ':'},	/*  : */
	{K_CR,		  '\r'},	/* \r */
	{K_ESCAPE,	'\033'},	/* ^[ */
	{K_FORMFEED,	  '\f'},	/* \f */
	{K_HEXCHAR,	'\030'},	/* ^X */
	{K_NL,		  '\n'},	/* \n */
	{K_RIGHTBRACE,	   '}'},	/*  } */
	{K_RIGHTPAREN,	   ')'},	/*  ) */
	{K_TAB,		  '\t'},	/* \t */
	{K_VERASE,	  '\b'},	/* \b */
	{K_VKILL,	'\025'},	/* ^U */
	{K_VLNEXT,	'\021'},	/* ^Q */
	{K_VLNEXT,	'\026'},	/* ^V */
	{K_VWERASE,	'\027'},	/* ^W */
	{K_ZERO,	   '0'},	/*  0 */

#define	ADDITIONAL_CHARACTERS	4
	{K_NOTUSED, 0},			/* VEOF, VERASE, VKILL, VWERASE */
	{K_NOTUSED, 0},
	{K_NOTUSED, 0},
	{K_NOTUSED, 0},
};
static int nkeylist =
    (sizeof(keylist) / sizeof(keylist[0])) - ADDITIONAL_CHARACTERS;

/*
 * v_key_init --
 *	Initialize the special key lookup table.
 *
 * PUBLIC: int v_key_init(SCR *);
 */
int
v_key_init(SCR *sp)
{
	u_int ch;
	GS *gp;
	KEYLIST *kp;
	int cnt;

	gp = sp->gp;

	/*
	 * XXX
	 * 8-bit only, for now.  Recompilation should get you any 8-bit
	 * character set, as long as nul isn't a character.
	 */
	(void)setlocale(LC_ALL, "");
	v_key_ilookup(sp);

	v_keyval(sp, K_CNTRLD, KEY_VEOF);
	v_keyval(sp, K_VERASE, KEY_VERASE);
	v_keyval(sp, K_VKILL, KEY_VKILL);
	v_keyval(sp, K_VWERASE, KEY_VWERASE);

	/* Sort the special key list. */
	qsort(keylist, nkeylist, sizeof(keylist[0]), v_key_cmp);

	/* Initialize the fast lookup table. */
	for (gp->max_special = 0, kp = keylist, cnt = nkeylist; cnt--; ++kp) {
		if (gp->max_special < kp->value)
			gp->max_special = kp->value;
		if (kp->ch <= MAX_FAST_KEY)
			gp->special_key[kp->ch] = kp->value;
	}

	/* Find a non-printable character to use as a message separator. */
	for (ch = 1; ch <= MAX_CHAR_T; ++ch)
		if (!isprint(ch)) {
			gp->noprint = ch;
			break;
		}
	if (ch != gp->noprint) {
		msgq(sp, M_ERR, "No non-printable character found");
		return (1);
	}
	return (0);
}

/*
 * v_keyval --
 *	Set key values.
 *
 * We've left some open slots in the keylist table, and if these values exist,
 * we put them into place.  Note, they may reset (or duplicate) values already
 * in the table, so we check for that first.
 */
static void
v_keyval(SCR *sp, int val, scr_keyval_t name)
{
	KEYLIST *kp;
	CHAR_T ch;
	int dne;

	/* Get the key's value from the screen. */
	if (sp->gp->scr_keyval(sp, name, &ch, &dne))
		return;
	if (dne)
		return;

	/* Check for duplication. */
	for (kp = keylist; kp->value != K_NOTUSED; ++kp)
		if (kp->ch == ch) {
			kp->value = val;
			return;
		}

	/* Add a new entry. */
	if (kp->value == K_NOTUSED) {
		keylist[nkeylist].ch = ch;
		keylist[nkeylist].value = val;
		++nkeylist;
	}
}

/*
 * v_key_ilookup --
 *	Build the fast-lookup key display array.
 *
 * PUBLIC: void v_key_ilookup(SCR *);
 */
void
v_key_ilookup(SCR *sp)
{
	CHAR_T ch, *p, *t;
	GS *gp;
	size_t len;

	for (gp = sp->gp, ch = 0; ch <= MAX_FAST_KEY; ++ch)
		for (p = gp->cname[ch].name, t = v_key_name(sp, ch),
		    len = gp->cname[ch].len = sp->clen; len--;)
			*p++ = *t++;
}

/*
 * v_key_len --
 *	Return the length of the string that will display the key.
 *	This routine is the backup for the KEY_LEN() macro.
 *
 * PUBLIC: size_t v_key_len(SCR *, CHAR_T);
 */
size_t
v_key_len(SCR *sp, CHAR_T ch)
{
	(void)v_key_name(sp, ch);
	return (sp->clen);
}

/*
 * v_key_name --
 *	Return the string that will display the key.  This routine
 *	is the backup for the KEY_NAME() macro.
 *
 * PUBLIC: CHAR_T *v_key_name(SCR *, CHAR_T);
 */
CHAR_T *
v_key_name(SCR *sp, CHAR_T ch)
{
	static const CHAR_T hexdigit[] = "0123456789abcdef";
	static const CHAR_T octdigit[] = "01234567";
	CHAR_T *chp, mask;
	size_t len;
	int cnt, shift;

	/* See if the character was explicitly declared printable or not. */
	if ((chp = O_STR(sp, O_PRINT)) != NULL)
		for (; *chp != '\0'; ++chp)
			if (*chp == ch)
				goto pr;
	if ((chp = O_STR(sp, O_NOPRINT)) != NULL)
		for (; *chp != '\0'; ++chp)
			if (*chp == ch)
				goto nopr;

	/*
	 * Historical (ARPA standard) mappings.  Printable characters are left
	 * alone.  Control characters less than 0x20 are represented as '^'
	 * followed by the character offset from the '@@' character in the ASCII
	 * character set.  Del (0x7f) is represented as '^' followed by '?'.
	 *
	 * XXX
	 * The following code depends on the current locale being identical to
	 * the ASCII map from 0x40 to 0x5f (since 0x1f + 0x40 == 0x5f).  I'm
	 * told that this is a reasonable assumption...
	 *
	 * XXX
	 * This code will only work with CHAR_T's that are multiples of 8-bit
	 * bytes.
	 *
	 * XXX
	 * NB: There's an assumption here that all printable characters take
	 * up a single column on the screen.  This is not always correct.
	 */
	if (isprint(ch)) {
pr:		sp->cname[0] = ch;
		len = 1;
		goto done;
	}
nopr:	if (iscntrl(ch) && (ch < 0x20 || ch == 0x7f)) {
		sp->cname[0] = '^';
		sp->cname[1] = ch == 0x7f ? '?' : '@@' + ch;
		len = 2;
	} else if (O_ISSET(sp, O_OCTAL)) {
#define	BITS	(sizeof(CHAR_T) * 8)
#define	SHIFT	(BITS - BITS % 3)
#define	TOPMASK	(BITS % 3 == 2 ? 3 : 1) << (BITS - BITS % 3)
		sp->cname[0] = '\\';
		sp->cname[1] = octdigit[(ch & TOPMASK) >> SHIFT];
		shift = SHIFT - 3;
		for (len = 2, mask = 7 << (SHIFT - 3),
		    cnt = BITS / 3; cnt-- > 0; mask >>= 3, shift -= 3)
			sp->cname[len++] = octdigit[(ch & mask) >> shift];
	} else {
		sp->cname[0] = '\\';
		sp->cname[1] = 'x';
		for (len = 2, chp = (u_int8_t *)&ch,
		    cnt = sizeof(CHAR_T); cnt-- > 0; ++chp) {
			sp->cname[len++] = hexdigit[(*chp & 0xf0) >> 4];
			sp->cname[len++] = hexdigit[*chp & 0x0f];
		}
	}
done:	sp->cname[sp->clen = len] = '\0';
	return (sp->cname);
}

/*
 * v_key_val --
 *	Fill in the value for a key.  This routine is the backup
 *	for the KEY_VAL() macro.
 *
 * PUBLIC: int v_key_val(SCR *, CHAR_T);
 */
int
v_key_val(SCR *sp, CHAR_T ch)
{
	KEYLIST k, *kp;

	k.ch = ch;
	kp = bsearch(&k, keylist, nkeylist, sizeof(keylist[0]), v_key_cmp);
	return (kp == NULL ? K_NOTUSED : kp->value);
}

/*
 * v_event_push --
 *	Push events/keys onto the front of the buffer.
 *
 * There is a single input buffer in ex/vi.  Characters are put onto the
 * end of the buffer by the terminal input routines, and pushed onto the
 * front of the buffer by various other functions in ex/vi.  Each key has
 * an associated flag value, which indicates if it has already been quoted,
 * and if it is the result of a mapping or an abbreviation.
 *
 * PUBLIC: int v_event_push(SCR *, EVENT *, CHAR_T *, size_t, u_int);
 */
int
v_event_push(SCR *sp, EVENT *p_evp, CHAR_T *p_s, size_t nitems, u_int flags)
{
	EVENT *evp;
	GS *gp;
	size_t total;

	/* If we have room, stuff the items into the buffer. */
	gp = sp->gp;
	if (nitems <= gp->i_next ||
	    (gp->i_event != NULL && gp->i_cnt == 0 && nitems <= gp->i_nelem)) {
		if (gp->i_cnt != 0)
			gp->i_next -= nitems;
		goto copy;
	}

	/*
	 * If there are currently items in the queue, shift them up,
	 * leaving some extra room.  Get enough space plus a little
	 * extra.
	 */
#define	TERM_PUSH_SHIFT	30
	total = gp->i_cnt + gp->i_next + nitems + TERM_PUSH_SHIFT;
	if (total >= gp->i_nelem && v_event_grow(sp, MAXIMUM(total, 64)))
		return (1);
	if (gp->i_cnt)
		MEMMOVE(gp->i_event + TERM_PUSH_SHIFT + nitems,
		    gp->i_event + gp->i_next, gp->i_cnt);
	gp->i_next = TERM_PUSH_SHIFT;

	/* Put the new items into the queue. */
copy:	gp->i_cnt += nitems;
	for (evp = gp->i_event + gp->i_next; nitems--; ++evp) {
		if (p_evp != NULL)
			*evp = *p_evp++;
		else {
			evp->e_event = E_CHARACTER;
			evp->e_c = *p_s++;
			evp->e_value = KEY_VAL(sp, evp->e_c);
			F_INIT(&evp->e_ch, flags);
		}
	}
	return (0);
}

/*
 * v_event_append --
 *	Append events onto the tail of the buffer.
 */
static int
v_event_append(SCR *sp, EVENT *argp)
{
	CHAR_T *s;			/* Characters. */
	EVENT *evp;
	GS *gp;
	size_t nevents;			/* Number of events. */

	/* Grow the buffer as necessary. */
	nevents = argp->e_event == E_STRING ? argp->e_len : 1;
	gp = sp->gp;
	if (gp->i_event == NULL ||
	    nevents > gp->i_nelem - (gp->i_next + gp->i_cnt))
		v_event_grow(sp, MAXIMUM(nevents, 64));
	evp = gp->i_event + gp->i_next + gp->i_cnt;
	gp->i_cnt += nevents;

	/* Transform strings of characters into single events. */
	if (argp->e_event == E_STRING)
		for (s = argp->e_csp; nevents--; ++evp) {
			evp->e_event = E_CHARACTER;
			evp->e_c = *s++;
			evp->e_value = KEY_VAL(sp, evp->e_c);
			evp->e_flags = 0;
		}
	else
		*evp = *argp;
	return (0);
}

/* Remove events from the queue. */
#define	QREM(len) {							\
	if ((gp->i_cnt -= (len)) == 0)					\
		gp->i_next = 0;						\
	else								\
		gp->i_next += (len);					\
}

/*
 * v_event_get --
 *	Return the next event.
 *
 * !!!
 * The flag EC_NODIGIT probably needs some explanation.  First, the idea of
 * mapping keys is that one or more keystrokes act like a function key.
 * What's going on is that vi is reading a number, and the character following
 * the number may or may not be mapped (EC_MAPCOMMAND).  For example, if the
 * user is entering the z command, a valid command is "z40+", and we don't want
 * to map the '+', i.e. if '+' is mapped to "xxx", we don't want to change it
 * into "z40xxx".  However, if the user enters "35x", we want to put all of the
 * characters through the mapping code.
 *
 * Historical practice is a bit muddled here.  (Surprise!)  It always permitted
 * mapping digits as long as they weren't the first character of the map, e.g.
 * ":map ^A1 xxx" was okay.  It also permitted the mapping of the digits 1-9
 * (the digit 0 was a special case as it doesn't indicate the start of a count)
 * as the first character of the map, but then ignored those mappings.  While
 * it's probably stupid to map digits, vi isn't your mother.
 *
 * The way this works is that the EC_MAPNODIGIT causes term_key to return the
 * end-of-digit without "looking" at the next character, i.e. leaving it as the
 * user entered it.  Presumably, the next term_key call will tell us how the
 * user wants it handled.
 *
 * There is one more complication.  Users might map keys to digits, and, as
 * it's described above, the commands:
 *
 *	:map g 1G
 *	d2g
 *
 * would return the keys "d2<end-of-digits>1G", when the user probably wanted
 * "d21<end-of-digits>G".  So, if a map starts off with a digit we continue as
 * before, otherwise, we pretend we haven't mapped the character, and return
 * <end-of-digits>.
 *
 * Now that that's out of the way, let's talk about Energizer Bunny macros.
 * It's easy to create macros that expand to a loop, e.g. map x 3x.  It's
 * fairly easy to detect this example, because it's all internal to term_key.
 * If we're expanding a macro and it gets big enough, at some point we can
 * assume it's looping and kill it.  The examples that are tough are the ones
 * where the parser is involved, e.g. map x "ayyx"byy.  We do an expansion
 * on 'x', and get "ayyx"byy.  We then return the first 4 characters, and then
 * find the looping macro again.  There is no way that we can detect this
 * without doing a full parse of the command, because the character that might
 * cause the loop (in this case 'x') may be a literal character, e.g. the map
 * map x "ayy"xyy"byy is perfectly legal and won't cause a loop.
 *
 * Historic vi tried to detect looping macros by disallowing obvious cases in
 * the map command, maps that that ended with the same letter as they started
 * (which wrongly disallowed "map x 'x"), and detecting macros that expanded
 * too many times before keys were returned to the command parser.  It didn't
 * get many (most?) of the tricky cases right, however, and it was certainly
 * possible to create macros that ran forever.  And, even if it did figure out
 * what was going on, the user was usually tossed into ex mode.  Finally, any
 * changes made before vi realized that the macro was recursing were left in
 * place.  We recover gracefully, but the only recourse the user has in an
 * infinite macro loop is to interrupt.
 *
 * !!!
 * It is historic practice that mapping characters to themselves as the first
 * part of the mapped string was legal, and did not cause infinite loops, i.e.
 * ":map! { {^M^T" and ":map n nz." were known to work.  The initial, matching
 * characters were returned instead of being remapped.
 *
 * !!!
 * It is also historic practice that the macro "map ] ]]^" caused a single ]
 * keypress to behave as the command ]] (the ^ got the map past the vi check
 * for "tail recursion").  Conversely, the mapping "map n nn^" went recursive.
 * What happened was that, in the historic vi, maps were expanded as the keys
 * were retrieved, but not all at once and not centrally.  So, the keypress ]
 * pushed ]]^ on the stack, and then the first ] from the stack was passed to
 * the ]] command code.  The ]] command then retrieved a key without entering
 * the mapping code.  This could bite us anytime a user has a map that depends
 * on secondary keys NOT being mapped.  I can't see any possible way to make
 * this work in here without the complete abandonment of Rationality Itself.
 *
 * XXX
 * The final issue is recovery.  It would be possible to undo all of the work
 * that was done by the macro if we entered a record into the log so that we
 * knew when the macro started, and, in fact, this might be worth doing at some
 * point.  Given that this might make the log grow unacceptably (consider that
 * cursor keys are done with maps), for now we leave any changes made in place.
 *
 * PUBLIC: int v_event_get(SCR *, EVENT *, int, u_int32_t);
 */
int
v_event_get(SCR *sp, EVENT *argp, int timeout, u_int32_t flags)
{
	EVENT *evp, ev;
	GS *gp;
	SEQ *qp;
	int init_nomap, ispartial, istimeout, remap_cnt;

	gp = sp->gp;

	/* If simply checking for interrupts, argp may be NULL. */
	if (argp == NULL)
		argp = &ev;

retry:	istimeout = remap_cnt = 0;

	/*
	 * If the queue isn't empty and we're timing out for characters,
	 * return immediately.
	 */
	if (gp->i_cnt != 0 && LF_ISSET(EC_TIMEOUT))
		return (0);

	/*
	 * If the queue is empty, we're checking for interrupts, or we're
	 * timing out for characters, get more events.
	 */
	if (gp->i_cnt == 0 || LF_ISSET(EC_INTERRUPT | EC_TIMEOUT)) {
		/*
		 * If we're reading new characters, check any scripting
		 * windows for input.
		 */
		if (F_ISSET(gp, G_SCRWIN) && sscr_input(sp))
			return (1);
loop:		if (gp->scr_event(sp, argp,
		    LF_ISSET(EC_INTERRUPT | EC_QUOTED | EC_RAW), timeout))
			return (1);
		switch (argp->e_event) {
		case E_ERR:
		case E_SIGHUP:
		case E_SIGTERM:
			/*
			 * Fatal conditions cause the file to be synced to
			 * disk immediately.
			 */
			v_sync(sp, RCV_ENDSESSION | RCV_PRESERVE |
			    (argp->e_event == E_SIGTERM ? 0: RCV_EMAIL));
			return (1);
		case E_TIMEOUT:
			istimeout = 1;
			break;
		case E_INTERRUPT:
			/* Set the global interrupt flag. */
			F_SET(sp->gp, G_INTERRUPTED);

			/*
			 * If the caller was interested in interrupts, return
			 * immediately.
			 */
			if (LF_ISSET(EC_INTERRUPT))
				return (0);
			goto append;
		default:
append:			if (v_event_append(sp, argp))
				return (1);
			break;
		}
	}

	/*
	 * If the caller was only interested in interrupts or timeouts, return
	 * immediately.  (We may have gotten characters, and that's okay, they
	 * were queued up for later use.)
	 */
	if (LF_ISSET(EC_INTERRUPT | EC_TIMEOUT))
		return (0);
	 
newmap:	evp = &gp->i_event[gp->i_next];

	/* 
	 * If the next event in the queue isn't a character event, return
	 * it, we're done.
	 */
	if (evp->e_event != E_CHARACTER) {
		*argp = *evp;
		QREM(1);
		return (0);
	}
	
	/*
	 * If the key isn't mappable because:
	 *
	 *	+ ... the timeout has expired
	 *	+ ... it's not a mappable key
	 *	+ ... neither the command or input map flags are set
	 *	+ ... there are no maps that can apply to it
	 *
	 * return it forthwith.
	 */
	if (istimeout || F_ISSET(&evp->e_ch, CH_NOMAP) ||
	    !LF_ISSET(EC_MAPCOMMAND | EC_MAPINPUT) ||
	    (evp->e_c < MAX_BIT_SEQ && !bit_test(gp->seqb, evp->e_c)))
		goto nomap;

	/* Search the map. */
	qp = seq_find(sp, NULL, evp, NULL, gp->i_cnt,
	    LF_ISSET(EC_MAPCOMMAND) ? SEQ_COMMAND : SEQ_INPUT, &ispartial);

	/*
	 * If get a partial match, get more characters and retry the map.
	 * If time out without further characters, return the characters
	 * unmapped.
	 *
	 * !!!
	 * <escape> characters are a problem.  Cursor keys start with <escape>
	 * characters, so there's almost always a map in place that begins with
	 * an <escape> character.  If we timeout <escape> keys in the same way
	 * that we timeout other keys, the user will get a noticeable pause as
	 * they enter <escape> to terminate input mode.  If key timeout is set
	 * for a slow link, users will get an even longer pause.  Nvi used to
	 * simply timeout <escape> characters at 1/10th of a second, but this
	 * loses over PPP links where the latency is greater than 100Ms.
	 */
	if (ispartial) {
		if (O_ISSET(sp, O_TIMEOUT))
			timeout = (evp->e_value == K_ESCAPE ?
			    O_VAL(sp, O_ESCAPETIME) :
			    O_VAL(sp, O_KEYTIME)) * 100;
		else
			timeout = 0;
		goto loop;
	}

	/* If no map, return the character. */
	if (qp == NULL) {
nomap:		if (!isdigit(evp->e_c) && LF_ISSET(EC_MAPNODIGIT))
			goto not_digit;
		*argp = *evp;
		QREM(1);
		return (0);
	}

	/*
	 * If looking for the end of a digit string, and the first character
	 * of the map is it, pretend we haven't seen the character.
	 */
	if (LF_ISSET(EC_MAPNODIGIT) &&
	    qp->output != NULL && !isdigit(qp->output[0])) {
not_digit:	argp->e_c = CH_NOT_DIGIT;
		argp->e_value = K_NOTUSED;
		argp->e_event = E_CHARACTER;
		F_INIT(&argp->e_ch, 0);
		return (0);
	}

	/* Find out if the initial segments are identical. */
	init_nomap = !e_memcmp(qp->output, &gp->i_event[gp->i_next], qp->ilen);

	/* Delete the mapped characters from the queue. */
	QREM(qp->ilen);

	/* If keys mapped to nothing, go get more. */
	if (qp->output == NULL)
		goto retry;

	/* If remapping characters... */
	if (O_ISSET(sp, O_REMAP)) {
		/*
		 * Periodically check for interrupts.  Always check the first
		 * time through, because it's possible to set up a map that
		 * will return a character every time, but will expand to more,
		 * e.g. "map! a aaaa" will always return a 'a', but we'll never
		 * get anywhere useful.
		 */
		if ((++remap_cnt == 1 || remap_cnt % 10 == 0) &&
		    (gp->scr_event(sp, &ev,
		    EC_INTERRUPT, 0) || ev.e_event == E_INTERRUPT)) {
			F_SET(sp->gp, G_INTERRUPTED);
			argp->e_event = E_INTERRUPT;
			return (0);
		}

		/*
		 * If an initial part of the characters mapped, they are not
		 * further remapped -- return the first one.  Push the rest
		 * of the characters, or all of the characters if no initial
		 * part mapped, back on the queue.
		 */
		if (init_nomap) {
			if (v_event_push(sp, NULL, qp->output + qp->ilen,
			    qp->olen - qp->ilen, CH_MAPPED))
				return (1);
			if (v_event_push(sp, NULL,
			    qp->output, qp->ilen, CH_NOMAP | CH_MAPPED))
				return (1);
			evp = &gp->i_event[gp->i_next];
			goto nomap;
		}
		if (v_event_push(sp, NULL, qp->output, qp->olen, CH_MAPPED))
			return (1);
		goto newmap;
	}

	/* Else, push the characters on the queue and return one. */
	if (v_event_push(sp, NULL, qp->output, qp->olen, CH_MAPPED | CH_NOMAP))
		return (1);

	goto nomap;
}

/*
 * v_sync --
 *	Walk the screen lists, sync'ing files to their backup copies.
 */
static void
v_sync(SCR *sp, int flags)
{
	GS *gp;

	gp = sp->gp;
	TAILQ_FOREACH(sp, &gp->dq, q)
		rcv_sync(sp, flags);
	TAILQ_FOREACH(sp, &gp->hq, q)
		rcv_sync(sp, flags);
}

/*
 * v_event_err --
 *	Unexpected event.
 *
 * PUBLIC: void v_event_err(SCR *, EVENT *);
 */
void
v_event_err(SCR *sp, EVENT *evp)
{
	switch (evp->e_event) {
	case E_CHARACTER:
		msgq(sp, M_ERR, "Unexpected character event");
		break;
	case E_EOF:
		msgq(sp, M_ERR, "Unexpected end-of-file event");
		break;
	case E_INTERRUPT:
		msgq(sp, M_ERR, "Unexpected interrupt event");
		break;
	case E_QUIT:
		msgq(sp, M_ERR, "Unexpected quit event");
		break;
	case E_REPAINT:
		msgq(sp, M_ERR, "Unexpected repaint event");
		break;
	case E_STRING:
		msgq(sp, M_ERR, "Unexpected string event");
		break;
	case E_TIMEOUT:
		msgq(sp, M_ERR, "Unexpected timeout event");
		break;
	case E_WRESIZE:
		msgq(sp, M_ERR, "Unexpected resize event");
		break;
	case E_WRITE:
		msgq(sp, M_ERR, "Unexpected write event");
		break;

	/*
	 * Theoretically, none of these can occur, as they're handled at the
	 * top editor level.
	 */
	case E_ERR:
	case E_SIGHUP:
	case E_SIGTERM:
	default:
		abort();
	}

	/* Free any allocated memory. */
	if (evp->e_asp != NULL)
		free(evp->e_asp);
}

/*
 * v_event_flush --
 *	Flush any flagged keys, returning if any keys were flushed.
 *
 * PUBLIC: int v_event_flush(SCR *, u_int);
 */
int
v_event_flush(SCR *sp, u_int flags)
{
	GS *gp;
	int rval;

	for (rval = 0, gp = sp->gp; gp->i_cnt != 0 &&
	    F_ISSET(&gp->i_event[gp->i_next].e_ch, flags); rval = 1)
		QREM(1);
	return (rval);
}

/*
 * v_event_grow --
 *	Grow the terminal queue.
 */
static int
v_event_grow(SCR *sp, int add)
{
	GS *gp;
	size_t new_nelem, olen;

	gp = sp->gp;
	new_nelem = gp->i_nelem + add;
	olen = gp->i_nelem * sizeof(gp->i_event[0]);
	BINC_RET(sp, gp->i_event, olen, new_nelem * sizeof(gp->i_event[0]));
	gp->i_nelem = olen / sizeof(gp->i_event[0]);
	return (0);
}

/*
 * v_key_cmp --
 *	Compare two keys for sorting.
 */
static int
v_key_cmp(const void *ap, const void *bp)
{
	return (((KEYLIST *)ap)->ch - ((KEYLIST *)bp)->ch);
}
@


1.17
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d131 2
a132 2
		if ((unsigned char) kp->ch <= MAX_FAST_KEY)
			gp->special_key[(unsigned char) kp->ch] = kp->value;
d136 1
a136 1
	for (ch = 1; ch <= MAX_CHAR; ++ch)
d160 1
a160 1
	unsigned char ch;
d193 1
a193 2
	char *p, *t;
	unsigned char ch;
d208 1
a208 1
 * PUBLIC: size_t v_key_len(SCR *, char);
d211 1
a211 1
v_key_len(SCR *sp, char ch)
d222 1
a222 1
 * PUBLIC: char *v_key_name(SCR *, char);
d224 2
a225 2
char *
v_key_name(SCR *sp, char ch)
d227 3
a229 3
	static const char hexdigit[] = "0123456789abcdef";
	static const char octdigit[] = "01234567";
	char *chp, mask;
d255 1
a255 1
	 * This code will only work with chars that are multiples of 8-bit
d272 1
a272 1
#define	BITS	(sizeof(char) * 8)
d284 2
a285 2
		for (len = 2, chp = &ch,
		    cnt = sizeof(char); cnt-- > 0; ++chp) {
d299 1
a299 1
 * PUBLIC: int v_key_val(SCR *, char);
d302 1
a302 1
v_key_val(SCR *sp, char ch)
d321 1
a321 1
 * PUBLIC: int v_event_push(SCR *, EVENT *, char *, size_t, u_int);
d324 1
a324 1
v_event_push(SCR *sp, EVENT *p_evp, char *p_s, size_t nitems, u_int flags)
d375 1
a375 1
	char *s;			/* Characters. */
d598 1
a598 2
	    ((unsigned char) evp->e_c < MAX_BIT_SEQ && !bit_test(gp->seqb,
	    evp->e_c)))
@


1.16
log
@Remove ARG_CHAR_T, a relic from when the code was written K&R style.

ok millert@@ schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.15 2016/01/06 22:28:52 millert Exp $	*/
d131 2
a132 2
		if (kp->ch <= MAX_FAST_KEY)
			gp->special_key[kp->ch] = kp->value;
d136 1
a136 1
	for (ch = 1; ch <= MAX_CHAR_T; ++ch)
d160 1
a160 1
	CHAR_T ch;
d193 2
a194 1
	CHAR_T ch, *p, *t;
d209 1
a209 1
 * PUBLIC: size_t v_key_len(SCR *, CHAR_T);
d212 1
a212 1
v_key_len(SCR *sp, CHAR_T ch)
d223 1
a223 1
 * PUBLIC: CHAR_T *v_key_name(SCR *, CHAR_T);
d225 2
a226 2
CHAR_T *
v_key_name(SCR *sp, CHAR_T ch)
d228 3
a230 3
	static const CHAR_T hexdigit[] = "0123456789abcdef";
	static const CHAR_T octdigit[] = "01234567";
	CHAR_T *chp, mask;
d256 1
a256 1
	 * This code will only work with CHAR_T's that are multiples of 8-bit
d273 1
a273 1
#define	BITS	(sizeof(CHAR_T) * 8)
d285 2
a286 2
		for (len = 2, chp = (u_int8_t *)&ch,
		    cnt = sizeof(CHAR_T); cnt-- > 0; ++chp) {
d300 1
a300 1
 * PUBLIC: int v_key_val(SCR *, CHAR_T);
d303 1
a303 1
v_key_val(SCR *sp, CHAR_T ch)
d322 1
a322 1
 * PUBLIC: int v_event_push(SCR *, EVENT *, CHAR_T *, size_t, u_int);
d325 1
a325 1
v_event_push(SCR *sp, EVENT *p_evp, CHAR_T *p_s, size_t nitems, u_int flags)
d376 1
a376 1
	CHAR_T *s;			/* Characters. */
d599 2
a600 1
	    (evp->e_c < MAX_BIT_SEQ && !bit_test(gp->seqb, evp->e_c)))
@


1.15
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.14 2015/01/16 06:40:14 deraadt Exp $	*/
d208 1
a208 1
 * PUBLIC: size_t v_key_len(SCR *, ARG_CHAR_T);
d211 1
a211 1
v_key_len(SCR *sp, ARG_CHAR_T ch)
d222 1
a222 1
 * PUBLIC: CHAR_T *v_key_name(SCR *, ARG_CHAR_T);
d225 1
a225 1
v_key_name(SCR *sp, ARG_CHAR_T ach)
d229 1
a229 1
	CHAR_T ch, *chp, mask;
a232 2
	ch = ach;

d299 1
a299 1
 * PUBLIC: int v_key_val(SCR *, ARG_CHAR_T);
d302 1
a302 1
v_key_val(SCR *sp, ARG_CHAR_T ch)
@


1.14
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.13 2014/11/12 04:28:41 bentley Exp $	*/
d142 1
a142 1
		msgq(sp, M_ERR, "079|No non-printable character found");
d736 1
a736 1
		msgq(sp, M_ERR, "276|Unexpected character event");
d739 1
a739 1
		msgq(sp, M_ERR, "277|Unexpected end-of-file event");
d742 1
a742 1
		msgq(sp, M_ERR, "279|Unexpected interrupt event");
d745 1
a745 1
		msgq(sp, M_ERR, "280|Unexpected quit event");
d748 1
a748 1
		msgq(sp, M_ERR, "281|Unexpected repaint event");
d751 1
a751 1
		msgq(sp, M_ERR, "285|Unexpected string event");
d754 1
a754 1
		msgq(sp, M_ERR, "286|Unexpected timeout event");
d757 1
a757 1
		msgq(sp, M_ERR, "316|Unexpected resize event");
d760 1
a760 1
		msgq(sp, M_ERR, "287|Unexpected write event");
@


1.13
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.12 2014/11/10 21:31:42 tedu Exp $	*/
a13 1
#include <sys/param.h>
d30 2
d348 1
a348 1
	if (total >= gp->i_nelem && v_event_grow(sp, MAX(total, 64)))
d387 1
a387 1
		v_event_grow(sp, MAX(nevents, 64));
@


1.12
log
@remove old, unnecessary compat code. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.11 2013/11/28 22:12:40 krw Exp $	*/
d101 1
a101 2
v_key_init(sp)
	SCR *sp;
d156 1
a156 4
v_keyval(sp, val, name)
	SCR *sp;
	int val;
	scr_keyval_t name;
d190 1
a190 2
v_key_ilookup(sp)
	SCR *sp;
d210 1
a210 3
v_key_len(sp, ch)
	SCR *sp;
	ARG_CHAR_T ch;
d224 1
a224 3
v_key_name(sp, ach)
	SCR *sp;
	ARG_CHAR_T ach;
d303 1
a303 3
v_key_val(sp, ch)
	SCR *sp;
	ARG_CHAR_T ch;
d325 1
a325 6
v_event_push(sp, p_evp, p_s, nitems, flags)
	SCR *sp;
	EVENT *p_evp;			/* Push event. */
	CHAR_T *p_s;			/* Push characters. */
	size_t nitems;			/* Number of items to push. */
	u_int flags;			/* CH_* flags. */
d374 1
a374 3
v_event_append(sp, argp)
	SCR *sp;
	EVENT *argp;
d499 1
a499 5
v_event_get(sp, argp, timeout, flags)
	SCR *sp;
	EVENT *argp;
	int timeout;
	u_int32_t flags;
d713 1
a713 3
v_sync(sp, flags)
	SCR *sp;
	int flags;
d731 1
a731 3
v_event_err(sp, evp)
	SCR *sp;
	EVENT *evp;
d785 1
a785 3
v_event_flush(sp, flags)
	SCR *sp;
	u_int flags;
d801 1
a801 3
v_event_grow(sp, add)
	SCR *sp;
	int add;
d819 1
a819 2
v_key_cmp(ap, bp)
	const void *ap, *bp;
@


1.11
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.10 2009/10/27 23:59:47 deraadt Exp $	*/
a116 10
#if __linux__
	/*
	 * In libc 4.5.26, setlocale(LC_ALL, ""), doesn't setup the table
	 * for ctype(3c) correctly.  This bug is fixed in libc 4.6.x.
	 *
	 * This code works around this problem for libc 4.5.x users.
	 * Note that this code is harmless if you're using libc 4.6.x.
	 */
	(void)setlocale(LC_CTYPE, "");
#endif
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.9 2006/01/08 21:08:27 miod Exp $	*/
d752 1
a752 1
	CIRCLEQ_FOREACH(sp, &gp->dq, q)
d754 1
a754 1
	CIRCLEQ_FOREACH(sp, &gp->hq, q)
@


1.9
log
@Make sure we can exit from a loop in v_key_init() regardless of the locale
we're in; from Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.8 2006/01/08 21:05:39 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)key.c	10.33 (Berkeley) 9/24/96";
#endif /* not lint */
@


1.8
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.7 2005/10/17 19:12:16 otto Exp $	*/
d108 1
a108 1
	CHAR_T ch;
@


1.7
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.6 2002/02/16 21:27:57 millert Exp $	*/
d437 1
a437 1
	if ((gp->i_cnt -= len) == 0)					\
d440 1
a440 1
		gp->i_next += len;					\
d635 1
a635 1
	    evp->e_c < MAX_BIT_SEQ && !bit_test(gp->seqb, evp->e_c))
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.5 2001/01/29 01:58:29 niklas Exp $	*/
d756 1
a756 1
	for (sp = gp->dq.cqh_first; sp != (void *)&gp->dq; sp = sp->q.cqe_next)
d758 1
a758 1
	for (sp = gp->hq.cqh_first; sp != (void *)&gp->hq; sp = sp->q.cqe_next)
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 5
a39 5
static int	v_event_append __P((SCR *, EVENT *));
static int	v_event_grow __P((SCR *, int));
static int	v_key_cmp __P((const void *, const void *));
static void	v_keyval __P((SCR *, int, scr_keyval_t));
static void	v_sync __P((SCR *, int));
d102 1
a102 1
 * PUBLIC: int v_key_init __P((SCR *));
d205 1
a205 1
 * PUBLIC: void v_key_ilookup __P((SCR *));
d226 1
a226 1
 * PUBLIC: size_t v_key_len __P((SCR *, ARG_CHAR_T));
d242 1
a242 1
 * PUBLIC: CHAR_T *v_key_name __P((SCR *, ARG_CHAR_T));
d323 1
a323 1
 * PUBLIC: int v_key_val __P((SCR *, ARG_CHAR_T));
d347 1
a347 1
 * PUBLIC: int v_event_push __P((SCR *, EVENT *, CHAR_T *, size_t, u_int));
d528 1
a528 1
 * PUBLIC: int v_event_get __P((SCR *, EVENT *, int, u_int32_t));
d766 1
a766 1
 * PUBLIC: void v_event_err __P((SCR *, EVENT *));
d822 1
a822 1
 * PUBLIC: int v_event_flush __P((SCR *, u_int));
@


1.4
log
@o Update README files etc. from nvi-1.79 so they have the correct info
o make port.h empty since we there is nothing we lack
o include <sys/param.h>, not <sys/types.h> in files that use MIN/MAX macros
o add perl api support since we have libperl (off by default)
@
text
@d1 2
@


1.3
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d16 1
a16 1
#include <sys/types.h>
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)key.c	10.32 (Berkeley) 6/30/96";
d564 1
a564 1
		if (F_ISSET(gp, G_SCRIPT) && sscr_input(sp))
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)key.c	10.30 (Berkeley) 4/3/96";
d793 3
a797 3
		break;
	case E_WRITEQUIT:
		msgq(sp, M_ERR, "288|Unexpected write-and-quit event");
@
