head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.22
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.18
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.14
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.12
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.10
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.08.14.21.47.16;	author guenther;	state Exp;
branches;
next	1.13;
commitid	DY1PRC2CZGP0Huc6;

1.13
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.12;
commitid	adBvXLg05bJxz6yx;

1.12
date	2015.11.19.07.53.31;	author bentley;	state Exp;
branches;
next	1.11;
commitid	aNUlDSFtbBwW1Tdz;

1.11
date	2015.03.10.00.10.59;	author bentley;	state Exp;
branches;
next	1.10;
commitid	Rq4QQ2M9qdIOGCjO;

1.10
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.9;
commitid	06bi6U3x4gFFf2G1;

1.9
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.17.19.42.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.32;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.07.24.16.15.24;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.09.59.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Kill '#if defined(DEBUG) && 0' blocks that used %q

ok bentley@@ on principle
@
text
@/*	$OpenBSD: search.c,v 1.13 2016/01/06 22:28:52 millert Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"

typedef enum { S_EMPTY, S_EOF, S_NOPREV, S_NOTFOUND, S_SOF, S_WRAP } smsg_t;

static void	search_msg(SCR *, smsg_t);
static int	search_init(SCR *, dir_t, char *, size_t, char **, u_int);

/*
 * search_init --
 *	Set up a search.
 */
static int
search_init(SCR *sp, dir_t dir, char *ptrn, size_t plen, char **epp,
    u_int flags)
{
	recno_t lno;
	int delim;
	char *p, *t;

	/* If the file is empty, it's a fast search. */
	if (sp->lno <= 1) {
		if (db_last(sp, &lno))
			return (1);
		if (lno == 0) {
			if (LF_ISSET(SEARCH_MSG))
				search_msg(sp, S_EMPTY);
			return (1);
		}
	}

	if (LF_ISSET(SEARCH_PARSE)) {		/* Parse the string. */
		/*
		 * Use the saved pattern if no pattern specified, or if only
		 * one or two delimiter characters specified.
		 *
		 * !!!
		 * Historically, only the pattern itself was saved, vi didn't
		 * preserve addressing or delta information.
		 */
		if (ptrn == NULL)
			goto prev;
		if (plen == 1) {
			if (epp != NULL)
				*epp = ptrn + 1;
			goto prev;
		}
		if (ptrn[0] == ptrn[1]) {
			if (epp != NULL)
				*epp = ptrn + 2;

			/* Complain if we don't have a previous pattern. */
prev:			if (sp->re == NULL) {
				search_msg(sp, S_NOPREV);
				return (1);
			}
			/* Re-compile the search pattern if necessary. */
			if (!F_ISSET(sp, SC_RE_SEARCH) && re_compile(sp,
			    sp->re, sp->re_len, NULL, NULL, &sp->re_c,
			    RE_C_SEARCH |
			    (LF_ISSET(SEARCH_MSG) ? 0 : RE_C_SILENT)))
				return (1);

			/* Set the search direction. */
			if (LF_ISSET(SEARCH_SET))
				sp->searchdir = dir;
			return (0);
		}

		/*
		 * Set the delimiter, and move forward to the terminating
		 * delimiter, handling escaped delimiters.
		 *
		 * QUOTING NOTE:
		 * Only discard an escape character if it escapes a delimiter.
		 */
		for (delim = *ptrn, p = t = ++ptrn;; *t++ = *p++) {
			if (--plen == 0 || p[0] == delim) {
				if (plen != 0)
					++p;
				break;
			}
			if (plen > 1 && p[0] == '\\' && p[1] == delim) {
				++p;
				--plen;
			}
		}
		if (epp != NULL)
			*epp = p;

		plen = t - ptrn;
	}

	/* Compile the RE. */
	if (re_compile(sp, ptrn, plen, &sp->re, &sp->re_len, &sp->re_c,
	    RE_C_SEARCH |
	    (LF_ISSET(SEARCH_MSG) ? 0 : RE_C_SILENT) |
	    (LF_ISSET(SEARCH_TAG) ? RE_C_TAG : 0)))
		return (1);

	/* Set the search direction. */
	if (LF_ISSET(SEARCH_SET))
		sp->searchdir = dir;

	return (0);
}

/*
 * f_search --
 *	Do a forward search.
 *
 * PUBLIC: int f_search(SCR *, MARK *, MARK *, char *, size_t, char **, u_int);
 */
int
f_search(SCR *sp, MARK *fm, MARK *rm, char *ptrn, size_t plen, char **eptrn,
    u_int flags)
{
	busy_t btype;
	recno_t lno;
	regmatch_t match[1];
	size_t coff, len;
	int cnt, eval, rval, wrapped = 0;
	char *l;

	if (search_init(sp, FORWARD, ptrn, plen, eptrn, flags))
		return (1);

	if (LF_ISSET(SEARCH_FILE)) {
		lno = 1;
		coff = 0;
	} else {
		if (db_get(sp, fm->lno, DBG_FATAL, &l, &len))
			return (1);
		lno = fm->lno;

		/*
		 * If doing incremental search, start searching at the previous
		 * column, so that we search a minimal distance and still match
		 * special patterns, e.g., \< for beginning of a word.
		 *
		 * Otherwise, start searching immediately after the cursor.  If
		 * at the end of the line, start searching on the next line.
		 * This is incompatible (read bug fix) with the historic vi --
		 * searches for the '$' pattern never moved forward, and the
		 * "-t foo" didn't work if the 'f' was the first character in
		 * the file.
		 */
		if (LF_ISSET(SEARCH_INCR)) {
			if ((coff = fm->cno) != 0)
				--coff;
		} else if (fm->cno + 1 >= len) {
			coff = 0;
			lno = fm->lno + 1;
			if (db_get(sp, lno, 0, &l, &len)) {
				if (!O_ISSET(sp, O_WRAPSCAN)) {
					if (LF_ISSET(SEARCH_MSG))
						search_msg(sp, S_EOF);
					return (1);
				}
				lno = 1;
				wrapped = 1;
			}
		} else
			coff = fm->cno + 1;
	}

	btype = BUSY_ON;
	for (cnt = INTERRUPT_CHECK, rval = 1;; ++lno, coff = 0) {
		if (cnt-- == 0) {
			if (INTERRUPTED(sp))
				break;
			if (LF_ISSET(SEARCH_MSG)) {
				search_busy(sp, btype);
				btype = BUSY_UPDATE;
			}
			cnt = INTERRUPT_CHECK;
		}
		if ((wrapped && lno > fm->lno) || db_get(sp, lno, 0, &l, &len)) {
			if (wrapped) {
				if (LF_ISSET(SEARCH_MSG))
					search_msg(sp, S_NOTFOUND);
				break;
			}
			if (!O_ISSET(sp, O_WRAPSCAN)) {
				if (LF_ISSET(SEARCH_MSG))
					search_msg(sp, S_EOF);
				break;
			}
			lno = 0;
			wrapped = 1;
			continue;
		}

		/* If already at EOL, just keep going. */
		if (len != 0 && coff == len)
			continue;

		/* Set the termination. */
		match[0].rm_so = coff;
		match[0].rm_eo = len;

		/* Search the line. */
		eval = regexec(&sp->re_c, l, 1, match,
		    (match[0].rm_so == 0 ? 0 : REG_NOTBOL) | REG_STARTEND);
		if (eval == REG_NOMATCH)
			continue;
		if (eval != 0) {
			if (LF_ISSET(SEARCH_MSG))
				re_error(sp, eval, &sp->re_c);
			else
				(void)sp->gp->scr_bell(sp);
			break;
		}

		/* Warn if the search wrapped. */
		if (wrapped && LF_ISSET(SEARCH_WMSG))
			search_msg(sp, S_WRAP);

		rm->lno = lno;
		rm->cno = match[0].rm_so;

		/*
		 * If a change command, it's possible to move beyond the end
		 * of a line.  Historic vi generally got this wrong (e.g. try
		 * "c?$<cr>").  Not all that sure this gets it right, there
		 * are lots of strange cases.
		 */
		if (!LF_ISSET(SEARCH_EOL) && rm->cno >= len)
			rm->cno = len != 0 ? len - 1 : 0;

		rval = 0;
		break;
	}

	if (LF_ISSET(SEARCH_MSG))
		search_busy(sp, BUSY_OFF);
	return (rval);
}

/*
 * b_search --
 *	Do a backward search.
 *
 * PUBLIC: int b_search(SCR *, MARK *, MARK *, char *, size_t, char **, u_int);
 */
int
b_search(SCR *sp, MARK *fm, MARK *rm, char *ptrn, size_t plen, char **eptrn,
    u_int flags)
{
	busy_t btype;
	recno_t lno;
	regmatch_t match[1];
	size_t coff, last, len;
	int cnt, eval, rval, wrapped;
	char *l;

	if (search_init(sp, BACKWARD, ptrn, plen, eptrn, flags))
		return (1);

	/*
	 * If doing incremental search, set the "starting" position past the
	 * current column, so that we search a minimal distance and still
	 * match special patterns, e.g., \> for the end of a word.  This is
	 * safe when the cursor is at the end of a line because we only use
	 * it for comparison with the location of the match.
	 *
	 * Otherwise, start searching immediately before the cursor.  If in
	 * the first column, start search on the previous line.
	 */
	if (LF_ISSET(SEARCH_INCR)) {
		lno = fm->lno;
		coff = fm->cno + 1;
	} else {
		if (fm->cno == 0) {
			if (fm->lno == 1 && !O_ISSET(sp, O_WRAPSCAN)) {
				if (LF_ISSET(SEARCH_MSG))
					search_msg(sp, S_SOF);
				return (1);
			}
			lno = fm->lno - 1;
		} else
			lno = fm->lno;
		coff = fm->cno;
	}

	btype = BUSY_ON;
	for (cnt = INTERRUPT_CHECK, rval = 1, wrapped = 0;; --lno, coff = 0) {
		if (cnt-- == 0) {
			if (INTERRUPTED(sp))
				break;
			if (LF_ISSET(SEARCH_MSG)) {
				search_busy(sp, btype);
				btype = BUSY_UPDATE;
			}
			cnt = INTERRUPT_CHECK;
		}
		if ((wrapped && lno < fm->lno) || lno == 0) {
			if (wrapped) {
				if (LF_ISSET(SEARCH_MSG))
					search_msg(sp, S_NOTFOUND);
				break;
			}
			if (!O_ISSET(sp, O_WRAPSCAN)) {
				if (LF_ISSET(SEARCH_MSG))
					search_msg(sp, S_SOF);
				break;
			}
			if (db_last(sp, &lno))
				break;
			if (lno == 0) {
				if (LF_ISSET(SEARCH_MSG))
					search_msg(sp, S_EMPTY);
				break;
			}
			++lno;
			wrapped = 1;
			continue;
		}

		if (db_get(sp, lno, 0, &l, &len))
			break;

		/* Set the termination. */
		match[0].rm_so = 0;
		match[0].rm_eo = len;

		/* Search the line. */
		eval = regexec(&sp->re_c, l, 1, match,
		    (match[0].rm_eo == len ? 0 : REG_NOTEOL) | REG_STARTEND);
		if (eval == REG_NOMATCH)
			continue;
		if (eval != 0) {
			if (LF_ISSET(SEARCH_MSG))
				re_error(sp, eval, &sp->re_c);
			else
				(void)sp->gp->scr_bell(sp);
			break;
		}

		/* Check for a match starting past the cursor. */
		if (coff != 0 && match[0].rm_so >= coff)
			continue;

		/* Warn if the search wrapped. */
		if (wrapped && LF_ISSET(SEARCH_WMSG))
			search_msg(sp, S_WRAP);

		/*
		 * We now have the first match on the line.  Step through the
		 * line character by character until find the last acceptable
		 * match.  This is painful, we need a better interface to regex
		 * to make this work.
		 */
		for (;;) {
			last = match[0].rm_so++;
			if (match[0].rm_so >= len)
				break;
			match[0].rm_eo = len;
			eval = regexec(&sp->re_c, l, 1, match,
			    (match[0].rm_so == 0 ? 0 : REG_NOTBOL) |
			    REG_STARTEND);
			if (eval == REG_NOMATCH)
				break;
			if (eval != 0) {
				if (LF_ISSET(SEARCH_MSG))
					re_error(sp, eval, &sp->re_c);
				else
					(void)sp->gp->scr_bell(sp);
				goto err;
			}
			if (coff && match[0].rm_so >= coff)
				break;
		}
		rm->lno = lno;

		/* See comment in f_search(). */
		if (!LF_ISSET(SEARCH_EOL) && last >= len)
			rm->cno = len != 0 ? len - 1 : 0;
		else
			rm->cno = last;
		rval = 0;
		break;
	}

err:	if (LF_ISSET(SEARCH_MSG))
		search_busy(sp, BUSY_OFF);
	return (rval);
}

/*
 * search_msg --
 *	Display one of the search messages.
 */
static void
search_msg(SCR *sp, smsg_t msg)
{
	switch (msg) {
	case S_EMPTY:
		msgq(sp, M_ERR, "File empty; nothing to search");
		break;
	case S_EOF:
		msgq(sp, M_ERR,
		    "Reached end-of-file without finding the pattern");
		break;
	case S_NOPREV:
		msgq(sp, M_ERR, "No previous search pattern");
		break;
	case S_NOTFOUND:
		msgq(sp, M_ERR, "Pattern not found");
		break;
	case S_SOF:
		msgq(sp, M_ERR,
		    "Reached top-of-file without finding the pattern");
		break;
	case S_WRAP:
		msgq(sp, M_ERR, "Search wrapped");
		break;
	default:
		abort();
	}
}

/*
 * search_busy --
 *	Put up the busy searching message.
 *
 * PUBLIC: void search_busy(SCR *, busy_t);
 */
void
search_busy(SCR *sp, busy_t btype)
{
	sp->gp->scr_busy(sp, "Searching...", btype);
}
@


1.13
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.12 2015/11/19 07:53:31 bentley Exp $	*/
a225 4
#if defined(DEBUG) && 0
		TRACE(sp, "F search: %lu from %u to %u\n",
		    lno, coff, len != 0 ? len - 1 : len);
#endif
a242 4
#if defined(DEBUG) && 0
		TRACE(sp, "F search: %qu to %qu\n",
		    match[0].rm_so, match[0].rm_eo);
#endif
a350 3
#if defined(DEBUG) && 0
		TRACE(sp, "B search: %lu from 0 to %qu\n", lno, match[0].rm_eo);
#endif
a371 4
#if defined(DEBUG) && 0
		TRACE(sp, "B found: %qu to %qu\n",
		    match[0].rm_so, match[0].rm_eo);
#endif
@


1.12
log
@Remove cscope support in vi.

It makes no sense to keep support for a non-base tool in base, especially
for a feature that few if any people use.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.11 2015/03/10 00:10:59 bentley Exp $	*/
d438 1
a438 1
		msgq(sp, M_ERR, "072|File empty; nothing to search");
d442 1
a442 1
		    "073|Reached end-of-file without finding the pattern");
d445 1
a445 1
		msgq(sp, M_ERR, "074|No previous search pattern");
d448 1
a448 1
		msgq(sp, M_ERR, "075|Pattern not found");
d452 1
a452 1
		    "076|Reached top-of-file without finding the pattern");
d455 1
a455 1
		msgq(sp, M_ERR, "077|Search wrapped");
d471 1
a471 1
	sp->gp->scr_busy(sp, "078|Searching...", btype);
@


1.11
log
@Display "Search wrapped" even when searching from the end of the file.

From Zhihao Yuan.

ok millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.10 2014/11/12 04:28:41 bentley Exp $	*/
d122 1
a122 2
	    (LF_ISSET(SEARCH_TAG) ? RE_C_TAG : 0) |
	    (LF_ISSET(SEARCH_CSCOPE) ? RE_C_CSCOPE : 0)))
@


1.10
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.9 2009/10/27 23:59:47 deraadt Exp $	*/
d147 1
a147 1
	int cnt, eval, rval, wrapped;
d186 1
d193 1
a193 1
	for (cnt = INTERRUPT_CHECK, rval = 1, wrapped = 0;; ++lno, coff = 0) {
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.8 2006/01/08 21:05:39 miod Exp $	*/
d38 2
a39 6
search_init(sp, dir, ptrn, plen, epp, flags)
	SCR *sp;
	dir_t dir;
	char *ptrn, **epp;
	size_t plen;
	u_int flags;
d140 2
a141 6
f_search(sp, fm, rm, ptrn, plen, eptrn, flags)
	SCR *sp;
	MARK *fm, *rm;
	char *ptrn, **eptrn;
	size_t plen;
	u_int flags;
d279 2
a280 6
b_search(sp, fm, rm, ptrn, plen, eptrn, flags)
	SCR *sp;
	MARK *fm, *rm;
	char *ptrn, **eptrn;
	size_t plen;
	u_int flags;
d434 1
a434 3
search_msg(sp, msg)
	SCR *sp;
	smsg_t msg;
d469 1
a469 3
search_busy(sp, btype)
	SCR *sp;
	busy_t btype;
@


1.8
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.7 2002/02/17 19:42:34 millert Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)search.c	10.25 (Berkeley) 6/30/96";
#endif /* not lint */
@


1.7
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.6 2002/02/16 21:27:57 millert Exp $	*/
d214 1
a214 1
		if (wrapped && lno > fm->lno || db_get(sp, lno, 0, &l, &len)) {
d345 1
a345 1
		if (wrapped && lno < fm->lno || lno == 0) {
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: search.c,v 1.5 2001/01/29 01:58:32 niklas Exp $	*/
d145 1
a145 2
 * PUBLIC: int f_search __P((SCR *,
 * PUBLIC:    MARK *, MARK *, char *, size_t, char **, u_int));
d288 1
a288 2
 * PUBLIC: int b_search __P((SCR *,
 * PUBLIC:    MARK *, MARK *, char *, size_t, char **, u_int));
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 2
a35 2
static void	search_msg __P((SCR *, smsg_t));
static int	search_init __P((SCR *, dir_t, char *, size_t, char **, u_int));
d486 1
a486 1
 * PUBLIC: void search_busy __P((SCR *, busy_t));
@


1.4
log
@bring vi/ex up to 1.71
@
text
@d1 2
@


1.3
log
@vi fixes from bostic
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)search.c	10.24 (Berkeley) 5/26/96";
d33 1
a33 1
static int	search_setup __P((SCR *, dir_t, char *, char **, u_int));
d36 1
a36 1
 * search_setup --
d40 1
a40 1
search_setup(sp, dir, ptrn, epp, flags)
d44 1
d64 2
a65 2
		 * Use the saved pattern if no pattern supplied, or if only
		 * the delimiter character supplied.
d68 2
a69 2
		 * Only the pattern itself was saved, historically vi didn't
		 * reuse addressing or delta information.
d73 1
a73 1
		if (ptrn[1] == '\0') {
d87 3
a89 3
			/* Compile the search pattern if necessary. */
			if (!F_ISSET(sp, SC_RE_SEARCH) &&
			    re_compile(sp, sp->re, NULL, NULL, &sp->re_c,
d108 2
a109 2
			if (p[0] == '\0' || p[0] == delim) {
				if (p[0] == delim)
a110 1
				*t = '\0';
d113 1
a113 1
			if (p[1] == delim && p[0] == '\\')
d115 2
d120 2
d125 1
a125 1
	if (re_compile(sp, ptrn, &sp->re, &sp->re_len, &sp->re_c,
d143 2
a144 1
 * PUBLIC: int f_search __P((SCR *, MARK *, MARK *, char *, char **, u_int));
d147 1
a147 1
f_search(sp, fm, rm, ptrn, eptrn, flags)
d151 1
d161 1
a161 1
	if (search_setup(sp, FORWARD, ptrn, eptrn, flags))
d254 2
a255 26
		/*
		 * XXX
		 * Warn if the search wrapped.  This message is only displayed
		 * if we're in interactive mode and there are no keys in the
		 * queue. The problem is that the command is going to succeed,
		 * and the message isn't an error, it's merely informational.
		 * So, if we're reading the .exrc file, displaying it causes
		 * the screen to pause before entering the file, which is bad.
		 * Or, if a macro causes it to be repeatedly displayed, e.g.,
		 * the pattern only occurs once in the file and wrapscan is set,
		 * you lose, particularly if the macro does something like:
		 *	:map K /pattern/^MjK
		 * Each new search will display the message and the /pattern/
		 * will immediately overwrite it, with strange results.  The
		 * System V vi displays the "wrapped" message multiple times,
		 * but it's overwritten each time, so it's not as noticeable.
		 * Since we don't discard messages, it's a real problem.
		 *
		 * XXX
		 * The test for SC_SCR_EX or SC_SCR_VI feels wrong to me.  I
		 * didn't originally intend for that bit to reflect that the
		 * user has "gone interactive", but that's the only solution
		 * I see.
		 */
		if (wrapped && LF_ISSET(SEARCH_MSG) &&
		    F_ISSET(sp, SC_SCR_EX | SC_SCR_VI) && !KEYS_WAITING(sp))
d287 2
a288 1
 * PUBLIC: int b_search __P((SCR *, MARK *, MARK *, char *, char **, u_int));
d291 1
a291 1
b_search(sp, fm, rm, ptrn, eptrn, flags)
d295 1
d305 1
a305 1
	if (search_setup(sp, BACKWARD, ptrn, eptrn, flags))
d395 2
a396 6
		/*
		 * XXX
		 * See the comment in f_search() for more information.
		 */
		if (wrapped && LF_ISSET(SEARCH_MSG) &&
		    F_ISSET(sp, SC_SCR_EX | SC_SCR_VI) && !KEYS_WAITING(sp))
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)search.c	10.23 (Berkeley) 5/15/96";
d251 8
a258 6
		 * if there are no keys in the queue.  The problem is that the
		 * command is going to succeed, and the message isn't an error,
		 * it's informational in nature.  If a macro causes it to be
		 * output repeatedly, e.g., the pattern only occurs once in the
		 * file and wrapscan is set, you can lose, particularly if the
		 * macro does something like:
d265 6
d272 2
a273 1
		if (wrapped && LF_ISSET(SEARCH_MSG) && !KEYS_WAITING(sp))
d415 2
a416 1
		if (wrapped && LF_ISSET(SEARCH_MSG) && !KEYS_WAITING(sp))
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)search.c	8.48 (Berkeley) 8/17/94";
a17 1
#include <sys/time.h>
a22 1
#include <signal.h>
a25 1
#include <termios.h>
d28 6
a33 11
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"

static int	check_delta __P((SCR *, EXF *, long, recno_t));
static int	ctag_conv __P((SCR *, char **, int *));
static int	get_delta __P((SCR *, char **, long *, u_int *));
static int	resetup __P((SCR *, regex_t **, enum direction,
		    char *, char **, long *, u_int *));
d36 2
a37 2
 * resetup --
 *	Set up a search for a regular expression.
d40 1
a40 1
resetup(sp, rep, dir, ptrn, epp, deltap, flagp)
d42 1
a42 2
	regex_t **rep;
	enum direction dir;
d44 1
a44 2
	long *deltap;
	u_int *flagp;
d46 2
a47 2
	u_int flags;
	int delim, eval, re_flags, replaced;
d50 7
a56 21
	/* Set return information the default. */
	*deltap = 0;

	/*
	 * Use saved pattern if no pattern supplied, or if only a delimiter
	 * character is supplied.  Only the pattern was saved, historic vi
	 * did not reuse any delta supplied.
	 */
	flags = *flagp;
	if (ptrn == NULL)
		goto prev;
	if (ptrn[1] == '\0') {
		if (epp != NULL)
			*epp = ptrn + 1;
		goto prev;
	}
	if (ptrn[0] == ptrn[1] && ptrn[2] == '\0') {
		if (epp != NULL)
			*epp = ptrn + 2;
prev:		if (!F_ISSET(sp, S_SRE_SET)) {
			msgq(sp, M_ERR, "No previous search pattern");
d59 1
a59 1
		*rep = &sp->sre;
d61 15
a75 5
		/* Empty patterns set the direction. */
		if (LF_ISSET(SEARCH_SET)) {
			F_SET(sp, S_SRE_SET);
			sp->searchdir = dir;
			sp->sre = **rep;
d77 15
a91 2
		return (0);
	}
d93 5
a97 5
	re_flags = 0;				/* Set RE flags. */
	if (O_ISSET(sp, O_EXTENDED))
		re_flags |= REG_EXTENDED;
	if (O_ISSET(sp, O_IGNORECASE))
		re_flags |= REG_ICASE;
d99 8
a106 7
	replaced = 0;
	if (LF_ISSET(SEARCH_PARSE)) {		/* Parse the string. */
		/* Set delimiter. */
		delim = *ptrn++;

		/* Find terminating delimiter, handling escaped delimiters. */
		for (p = t = ptrn;;) {
a114 16
			*t++ = *p++;
		}

		/*
		 * If characters after the terminating delimiter, it may
		 * be an error, or may be an offset.  In either case, we
		 * return the end of the string, whatever it may be.
		 */
		if (*p) {
			if (get_delta(sp, &p, deltap, flagp))
				return (1);
			if (*p && LF_ISSET(SEARCH_TERM)) {
				msgq(sp, M_ERR,
			"Characters after search string and/or delta");
				return (1);
			}
a117 11

		/* Check for "/   " or other such silliness. */
		if (*ptrn == '\0')
			goto prev;

		if (re_conv(sp, &ptrn, &replaced))
			return (1);
	} else if (LF_ISSET(SEARCH_TAG)) {
		if (ctag_conv(sp, &ptrn, &replaced))
			return (1);
		re_flags &= ~(REG_EXTENDED | REG_ICASE);
d121 9
a129 4
	if (eval = regcomp(*rep, ptrn, re_flags))
		re_error(sp, eval, *rep);
	else if (LF_ISSET(SEARCH_SET)) {
		F_SET(sp, S_SRE_SET);
a130 2
		sp->sre = **rep;
	}
d132 1
a132 4
	/* Free up any extra memory. */
	if (replaced)
		FREE_SPACE(sp, ptrn, 0);
	return (eval);
d136 4
a139 3
 * ctag_conv --
 *	Convert a tags search path into something that the POSIX
 *	1003.2 RE functions can handle.
a140 66
static int
ctag_conv(sp, ptrnp, replacedp)
	SCR *sp;
	char **ptrnp;
	int *replacedp;
{
	size_t blen, len;
	int lastdollar;
	char *bp, *p, *t;

	*replacedp = 0;

	len = strlen(p = *ptrnp);

	/* Max memory usage is 2 times the length of the string. */
	GET_SPACE_RET(sp, bp, blen, len * 2);

	t = bp;

	/* The last character is a '/' or '?', we just strip it. */
	if (p[len - 1] == '/' || p[len - 1] == '?')
		p[len - 1] = '\0';

	/* The next-to-last character is a '$', and it's magic. */
	if (p[len - 2] == '$') {
		lastdollar = 1;
		p[len - 2] = '\0';
	} else
		lastdollar = 0;

	/* The first character is a '/' or '?', we just strip it. */
	if (p[0] == '/' || p[0] == '?')
		++p;

	/* The second character is a '^', and it's magic. */
	if (p[0] == '^')
		*t++ = *p++;

	/*
	 * Escape every other magic character we can find, stripping the
	 * backslashes ctags inserts to escape the search delimiter
	 * characters.
	 */
	while (p[0]) {
		/* Ctags escapes the search delimiter characters. */
		if (p[0] == '\\' && (p[1] == '/' || p[1] == '?'))
			++p;
		else if (strchr("^.[]$*", p[0]))
			*t++ = '\\';
		*t++ = *p++;
	}
	if (lastdollar)
		*t++ = '$';
	*t++ = '\0';

	*ptrnp = bp;
	*replacedp = 1;
	return (0);
}

#define	EMPTYMSG	"File empty; nothing to search"
#define	EOFMSG		"Reached end-of-file without finding the pattern"
#define	NOTFOUND	"Pattern not found"
#define	SOFMSG		"Reached top-of-file without finding the pattern"
#define	WRAPMSG		"Search wrapped"

d142 1
a142 1
f_search(sp, ep, fm, rm, ptrn, eptrn, flagp)
a143 1
	EXF *ep;
d146 1
a146 1
	u_int *flagp;
d148 2
a150 2
	regex_t *re, lre;
	recno_t lno;
d152 1
a152 3
	long delta;
	u_int flags;
	int btear, eval, rval, wrapped;
d155 1
a155 11
	if (file_lline(sp, ep, &lno))
		return (1);
	flags = *flagp;
	if (lno == 0) {
		if (LF_ISSET(SEARCH_MSG))
			msgq(sp, M_INFO, EMPTYMSG);
		return (1);
	}

	re = &lre;
	if (resetup(sp, &re, FORWARD, ptrn, eptrn, &delta, flagp))
a157 7
	/*
	 * Start searching immediately after the cursor.  If at the end of the
	 * line, start searching on the next line.  This is incompatible (read
	 * bug fix) with the historic vi -- searches for the '$' pattern never
	 * moved forward, and "-t foo" didn't work if "foo" was the first thing
	 * in the file.
	 */
d162 1
a162 2
		if ((l = file_gline(sp, ep, fm->lno, &len)) == NULL) {
			GETLINE_ERR(sp, fm->lno);
d164 21
a184 3
		}
		if (fm->cno + 1 >= len) {
			if (fm->lno == lno) {
d187 1
a187 1
						msgq(sp, M_INFO, EOFMSG);
d191 2
a192 5
			} else
				lno = fm->lno + 1;
			coff = 0;
		} else {
			lno = fm->lno;
a193 1
		}
d196 10
a205 7
	/* Turn on busy message. */
	btear = F_ISSET(sp, S_EXSILENT) ? 0 : !busy_on(sp, "Searching...");

	for (rval = 1, wrapped = 0;; ++lno, coff = 0) {
		if (INTERRUPTED(sp)) {
			msgq(sp, M_INFO, "Interrupted.");
			break;
d207 1
a207 2
		if (wrapped && lno > fm->lno ||
		    (l = file_gline(sp, ep, lno, &len)) == NULL) {
d210 1
a210 1
					msgq(sp, M_INFO, NOTFOUND);
d215 1
a215 1
					msgq(sp, M_INFO, EOFMSG);
d224 1
a224 1
		if (len && coff == len)
d233 1
a233 1
		    lno, coff, len ? len - 1 : len);
d236 1
a236 1
		eval = regexec(re, l, 1, match,
d241 4
a244 1
			re_error(sp, eval, re);
a247 4
		/* Warn if wrapped. */
		if (wrapped && O_ISSET(sp, O_WARN) && LF_ISSET(SEARCH_MSG))
			msgq(sp, M_VINFO, WRAPMSG);

d249 14
a262 2
		 * If an offset, see if it's legal.  It's possible to match
		 * past the end of the line with $, so check for that case.
d264 3
a266 6
		if (delta) {
			if (check_delta(sp, ep, delta, lno))
				break;
			rm->lno = delta + lno;
			rm->cno = 0;
		} else {
d268 2
a269 2
			TRACE(sp, "found: %qu to %qu\n",
			    match[0].rm_so, match[0].rm_eo);
d271 11
a281 2
			rm->lno = lno;
			rm->cno = match[0].rm_so;
a282 9
			/*
			 * If a change command, it's possible to move beyond
			 * the end of a line.  Historic vi generally got this
			 * wrong (try "c?$<cr>").  Not all that sure this gets
			 * it right, there are lots of strange cases.
			 */
			if (!LF_ISSET(SEARCH_EOL) && rm->cno >= len)
				rm->cno = len ? len - 1 : 0;
		}
d287 2
a288 3
	/* Turn off busy message, interrupts. */
	if (btear)
		busy_off(sp);
d292 6
d299 1
a299 1
b_search(sp, ep, fm, rm, ptrn, eptrn, flagp)
a300 1
	EXF *ep;
d303 1
a303 1
	u_int *flagp;
d305 2
d308 2
a309 6
	regex_t *re, lre;
	recno_t lno;
	size_t coff, len, last;
	long delta;
	u_int flags;
	int btear, eval, rval, wrapped;
d312 1
a312 1
	if (file_lline(sp, ep, &lno))
a313 6
	flags = *flagp;
	if (lno == 0) {
		if (LF_ISSET(SEARCH_MSG))
			msgq(sp, M_INFO, EMPTYMSG);
		return (1);
	}
d315 16
a330 8
	re = &lre;
	if (resetup(sp, &re, BACKWARD, ptrn, eptrn, &delta, flagp))
		return (1);

	/* If in the first column, start searching on the previous line. */
	if (fm->cno == 0) {
		if (fm->lno == 1) {
			if (!O_ISSET(sp, O_WRAPSCAN)) {
d332 1
a332 1
					msgq(sp, M_INFO, SOFMSG);
d335 1
d337 3
a339 3
			lno = fm->lno - 1;
	} else
		lno = fm->lno;
d341 10
a350 7
	/* Turn on busy message. */
	btear = F_ISSET(sp, S_EXSILENT) ? 0 : !busy_on(sp, "Searching...");

	for (rval = 1, wrapped = 0, coff = fm->cno;; --lno, coff = 0) {
		if (INTERRUPTED(sp)) {
			msgq(sp, M_INFO, "Interrupted.");
			break;
d355 1
a355 1
					msgq(sp, M_INFO, NOTFOUND);
d360 1
a360 1
					msgq(sp, M_INFO, SOFMSG);
d363 2
a364 2
			if (file_lline(sp, ep, &lno))
				goto err;
d367 1
a367 1
					msgq(sp, M_INFO, EMPTYMSG);
d375 2
a376 2
		if ((l = file_gline(sp, ep, lno, &len)) == NULL)
			goto err;
d386 1
a386 1
		eval = regexec(re, l, 1, match,
d391 4
a394 1
			re_error(sp, eval, re);
d402 7
a408 10
		/* Warn if wrapped. */
		if (wrapped && O_ISSET(sp, O_WARN) && LF_ISSET(SEARCH_MSG))
			msgq(sp, M_VINFO, WRAPMSG);

		if (delta) {
			if (check_delta(sp, ep, delta, lno))
				break;
			rm->lno = delta + lno;
			rm->cno = 0;
		} else {
d410 2
a411 2
			TRACE(sp, "found: %qu to %qu\n",
			    match[0].rm_so, match[0].rm_eo);
d413 22
a434 23
			/*
			 * We now have the first match on the line.  Step
			 * through the line character by character until we
			 * find the last acceptable match.  This is painful,
			 * we need a better interface to regex to make this
			 * work.
			 */
			for (;;) {
				last = match[0].rm_so++;
				if (match[0].rm_so >= len)
					break;
				match[0].rm_eo = len;
				eval = regexec(re, l, 1, match,
				    (match[0].rm_so == 0 ? 0 : REG_NOTBOL) |
				    REG_STARTEND);
				if (eval == REG_NOMATCH)
					break;
				if (eval != 0) {
					re_error(sp, eval, re);
					goto err;
				}
				if (coff && match[0].rm_so >= coff)
					break;
d436 4
a439 1
			rm->lno = lno;
d441 5
a445 6
			/* See comment in f_search(). */
			if (!LF_ISSET(SEARCH_EOL) && last >= len)
				rm->cno = len ? len - 1 : 0;
			else
				rm->cno = last;
		}
d450 2
a451 3
	/* Turn off busy message, interrupts. */
err:	if (btear)
		busy_off(sp);
d456 2
a457 14
 * re_conv --
 *	Convert vi's regular expressions into something that the
 *	the POSIX 1003.2 RE functions can handle.
 *
 * There are three conversions we make to make vi's RE's (specifically
 * the global, search, and substitute patterns) work with POSIX RE's.
 *
 * 1: If O_MAGIC is not set, strip backslashes from the magic character
 *    set (.[]*~) that have them, and add them to the ones that don't.
 * 2: If O_MAGIC is not set, the string "\~" is replaced with the text
 *    from the last substitute command's replacement string.  If O_MAGIC
 *    is set, it's the string "~".
 * 3: The pattern \<ptrn\> does "word" searches, convert it to use the
 *    new RE escapes.
d459 2
a460 2
int
re_conv(sp, ptrnp, replacedp)
d462 1
a462 2
	char **ptrnp;
	int *replacedp;
d464 23
a486 64
	size_t blen, needlen;
	int magic;
	char *bp, *p, *t;

	/*
	 * First pass through, we figure out how much space we'll need.
	 * We do it in two passes, on the grounds that most of the time
	 * the user is doing a search and won't have magic characters.
	 * That way we can skip the malloc and memmove's.
	 */
	for (p = *ptrnp, magic = 0, needlen = 0; *p != '\0'; ++p)
		switch (*p) {
		case '\\':
			switch (*++p) {
			case '<':
				magic = 1;
				needlen += sizeof(RE_WSTART);
				break;
			case '>':
				magic = 1;
				needlen += sizeof(RE_WSTOP);
				break;
			case '~':
				if (!O_ISSET(sp, O_MAGIC)) {
					magic = 1;
					needlen += sp->repl_len;
				}
				break;
			case '.':
			case '[':
			case ']':
			case '*':
				if (!O_ISSET(sp, O_MAGIC)) {
					magic = 1;
					needlen += 1;
				}
				break;
			default:
				needlen += 2;
			}
			break;
		case '~':
			if (O_ISSET(sp, O_MAGIC)) {
				magic = 1;
				needlen += sp->repl_len;
			}
			break;
		case '.':
		case '[':
		case ']':
		case '*':
			if (!O_ISSET(sp, O_MAGIC)) {
				magic = 1;
				needlen += 2;
			}
			break;
		default:
			needlen += 1;
			break;
		}

	if (!magic) {
		*replacedp = 0;
		return (0);
a487 66

	/*
	 * Get enough memory to hold the final pattern.
	 *
	 * XXX
	 * It's nul-terminated, for now.
	 */
	GET_SPACE_RET(sp, bp, blen, needlen + 1);

	for (p = *ptrnp, t = bp; *p != '\0'; ++p)
		switch (*p) {
		case '\\':
			switch (*++p) {
			case '<':
				memmove(t, RE_WSTART, sizeof(RE_WSTART) - 1);
				t += sizeof(RE_WSTART) - 1;
				break;
			case '>':
				memmove(t, RE_WSTOP, sizeof(RE_WSTOP) - 1);
				t += sizeof(RE_WSTOP) - 1;
				break;
			case '~':
				if (O_ISSET(sp, O_MAGIC))
					*t++ = '~';
				else {
					memmove(t, sp->repl, sp->repl_len);
					t += sp->repl_len;
				}
				break;
			case '.':
			case '[':
			case ']':
			case '*':
				if (O_ISSET(sp, O_MAGIC))
					*t++ = '\\';
				*t++ = *p;
				break;
			default:
				*t++ = '\\';
				*t++ = *p;
			}
			break;
		case '~':
			if (O_ISSET(sp, O_MAGIC)) {
				memmove(t, sp->repl, sp->repl_len);
				t += sp->repl_len;
			} else
				*t++ = '~';
			break;
		case '.':
		case '[':
		case ']':
		case '*':
			if (!O_ISSET(sp, O_MAGIC))
				*t++ = '\\';
			*t++ = *p;
			break;
		default:
			*t++ = *p;
			break;
		}
	*t = '\0';

	*ptrnp = bp;
	*replacedp = 1;
	return (0);
d491 2
a492 3
 * get_delta --
 *	Get a line delta.  The trickiness is that the delta can be pretty
 *	complicated, i.e. "+3-2+3++- ++" is allowed.
d494 1
a494 97
 * !!!
 * In historic vi, if you had a delta on a search pattern which was used as
 * a motion command, the command became a line mode command regardless of the
 * cursor positions.  A fairly common trick is to use a delta of "+0" to make
 * the command a line mode command.  This is the only place that knows about
 * delta's, so we set the return flag information here.
 */
static int
get_delta(sp, dp, valp, flagp)
	SCR *sp;
	char **dp;
	long *valp;
	u_int *flagp;
{
	char *p;
	long val, tval;

	for (tval = 0, p = *dp; *p != '\0'; *flagp |= SEARCH_DELTA) {
		if (isblank(*p)) {
			++p;
			continue;
		}
		if (*p == '+' || *p == '-') {
			if (!isdigit(*(p + 1))) {
				if (*p == '+') {
					if (tval == LONG_MAX)
						goto overflow;
					++tval;
				} else {
					if (tval == LONG_MIN)
						goto underflow;
					--tval;
				}
				++p;
				continue;
			}
		} else
			if (!isdigit(*p))
				break;

		errno = 0;
		val = strtol(p, &p, 10);
		if (errno == ERANGE) {
			if (val == LONG_MAX)
overflow:			msgq(sp, M_ERR, "Delta value overflow");
			else if (val == LONG_MIN)
underflow:			msgq(sp, M_ERR, "Delta value underflow");
			else
				msgq(sp, M_SYSERR, NULL);
			return (1);
		}
		if (val >= 0) {
			if (LONG_MAX - val < tval)
				goto overflow;
		} else
			if (-(LONG_MIN - tval) > val)
				goto underflow;
		tval += val;
	}
	*dp = p;
	*valp = tval;
	return (0);
}

/*
 * check_delta --
 *	Check a line delta to see if it's legal.
 */
static int
check_delta(sp, ep, delta, lno)
	SCR *sp;
	EXF *ep;
	long delta;
	recno_t lno;
{
	/* A delta can overflow a record number. */
	if (delta < 0) {
		if (lno < LONG_MAX && delta >= (long)lno) {
			msgq(sp, M_ERR, "Search offset before line 1");
			return (1);
		}
	} else {
		if (ULONG_MAX - lno < delta) {
			msgq(sp, M_ERR, "Delta value overflow");
			return (1);
		}
		if (file_gline(sp, ep, lno + delta, NULL) == NULL) {
			msgq(sp, M_ERR, "Search offset past end-of-file");
			return (1);
		}
	}
	return (0);
}

/*
 * re_error --
 *	Report a regular expression error.
d497 1
a497 1
re_error(sp, errcode, preg)
d499 1
a499 2
	int errcode;
	regex_t *preg;
d501 1
a501 11
	size_t s;
	char *oe;

	s = regerror(errcode, preg, "", 0);
	if ((oe = malloc(s)) == NULL)
		msgq(sp, M_SYSERR, NULL);
	else {
		(void)regerror(errcode, preg, oe, s);
		msgq(sp, M_ERR, "RE error: %s", oe);
	}
	free(oe);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
