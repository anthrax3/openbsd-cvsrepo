head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.2
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.22
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.20
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.16
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.34
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.30
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.28
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.26
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.24
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.22
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.20
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.18
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.16
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.14
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2017.04.18.01.45.35;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Pd2TRHz7UBFr9JGt;

1.11
date	2017.01.20.00.55.52;	author krw;	state Exp;
branches;
next	1.10;
commitid	Vqv2b6n3Sh3YStUT;

1.10
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.9;
commitid	01nAnartGL7onLD3;

1.9
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.8;
commitid	ruCZ2IKF0FB0ebCr;

1.8
date	2016.01.30.21.31.08;	author martijn;	state Exp;
branches;
next	1.7;
commitid	zLPqRo5te1vGR4dO;

1.7
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.6;
commitid	adBvXLg05bJxz6yx;

1.6
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.5;
commitid	06bi6U3x4gFFf2G1;

1.5
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.30;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@free(NULL) is ok so use it; from Michael W. Bombardieri
@
text
@/*	$OpenBSD: log.c,v 1.11 2017/01/20 00:55:52 krw Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <bitstring.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "common.h"

/*
 * The log consists of records, each containing a type byte and a variable
 * length byte string, as follows:
 *
 *	LOG_CURSOR_INIT		MARK
 *	LOG_CURSOR_END		MARK
 *	LOG_LINE_APPEND		recno_t		char *
 *	LOG_LINE_DELETE		recno_t		char *
 *	LOG_LINE_INSERT		recno_t		char *
 *	LOG_LINE_RESET_F	recno_t		char *
 *	LOG_LINE_RESET_B	recno_t		char *
 *	LOG_MARK		LMARK
 *
 * We do before image physical logging.  This means that the editor layer
 * MAY NOT modify records in place, even if simply deleting or overwriting
 * characters.  Since the smallest unit of logging is a line, we're using
 * up lots of space.  This may eventually have to be reduced, probably by
 * doing logical logging, which is a much cooler database phrase.
 *
 * The implementation of the historic vi 'u' command, using roll-forward and
 * roll-back, is simple.  Each set of changes has a LOG_CURSOR_INIT record,
 * followed by a number of other records, followed by a LOG_CURSOR_END record.
 * LOG_LINE_RESET records come in pairs.  The first is a LOG_LINE_RESET_B
 * record, and is the line before the change.  The second is LOG_LINE_RESET_F,
 * and is the line after the change.  Roll-back is done by backing up to the
 * first LOG_CURSOR_INIT record before a change.  Roll-forward is done in a
 * similar fashion.
 *
 * The 'U' command is implemented by rolling backward to a LOG_CURSOR_END
 * record for a line different from the current one.  It should be noted that
 * this means that a subsequent 'u' command will make a change based on the
 * new position of the log's cursor.  This is okay, and, in fact, historic vi
 * behaved that way.
 */

static int	log_cursor1(SCR *, int);
static void	log_err(SCR *, char *, int);
#if defined(DEBUG) && 0
static void	log_trace(SCR *, char *, recno_t, u_char *);
#endif

/* Try and restart the log on failure, i.e. if we run out of memory. */
#define	LOG_ERR {							\
	log_err(sp, __FILE__, __LINE__);				\
	return (1);							\
}

/*
 * log_init --
 *	Initialize the logging subsystem.
 *
 * PUBLIC: int log_init(SCR *, EXF *);
 */
int
log_init(SCR *sp, EXF *ep)
{
	/*
	 * !!!
	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER.
	 *
	 * Initialize the buffer.  The logging subsystem has its own
	 * buffers because the global ones are almost by definition
	 * going to be in use when the log runs.
	 */
	ep->l_lp = NULL;
	ep->l_len = 0;
	ep->l_cursor.lno = 1;		/* XXX Any valid recno. */
	ep->l_cursor.cno = 0;
	ep->l_high = ep->l_cur = 1;

	ep->log = dbopen(NULL, O_CREAT | O_NONBLOCK | O_RDWR,
	    S_IRUSR | S_IWUSR, DB_RECNO, NULL);
	if (ep->log == NULL) {
		msgq(sp, M_SYSERR, "Log file");
		F_SET(ep, F_NOLOG);
		return (1);
	}

	return (0);
}

/*
 * log_end --
 *	Close the logging subsystem.
 *
 * PUBLIC: int log_end(SCR *, EXF *);
 */
int
log_end(SCR *sp, EXF *ep)
{
	/*
	 * !!!
	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER.
	 */
	if (ep->log != NULL) {
		(void)(ep->log->close)(ep->log);
		ep->log = NULL;
	}
	free(ep->l_lp);
	ep->l_lp = NULL;
	ep->l_len = 0;
	ep->l_cursor.lno = 1;		/* XXX Any valid recno. */
	ep->l_cursor.cno = 0;
	ep->l_high = ep->l_cur = 1;
	return (0);
}

/*
 * log_cursor --
 *	Log the current cursor position, starting an event.
 *
 * PUBLIC: int log_cursor(SCR *);
 */
int
log_cursor(SCR *sp)
{
	EXF *ep;

	ep = sp->ep;
	if (F_ISSET(ep, F_NOLOG))
		return (0);

	/*
	 * If any changes were made since the last cursor init,
	 * put out the ending cursor record.
	 */
	if (ep->l_cursor.lno == OOBLNO) {
		ep->l_cursor.lno = sp->lno;
		ep->l_cursor.cno = sp->cno;
		return (log_cursor1(sp, LOG_CURSOR_END));
	}
	ep->l_cursor.lno = sp->lno;
	ep->l_cursor.cno = sp->cno;
	return (0);
}

/*
 * log_cursor1 --
 *	Actually push a cursor record out.
 */
static int
log_cursor1(SCR *sp, int type)
{
	DBT data, key;
	EXF *ep;

	ep = sp->ep;
	BINC_RET(sp, ep->l_lp, ep->l_len, sizeof(u_char) + sizeof(MARK));
	ep->l_lp[0] = type;
	memmove(ep->l_lp + sizeof(u_char), &ep->l_cursor, sizeof(MARK));

	key.data = &ep->l_cur;
	key.size = sizeof(recno_t);
	data.data = ep->l_lp;
	data.size = sizeof(u_char) + sizeof(MARK);
	if (ep->log->put(ep->log, &key, &data, 0) == -1)
		LOG_ERR;

#if defined(DEBUG) && 0
	TRACE(sp, "%lu: %s: %u/%u\n", ep->l_cur,
	    type == LOG_CURSOR_INIT ? "log_cursor_init" : "log_cursor_end",
	    sp->lno, sp->cno);
#endif
	/* Reset high water mark. */
	ep->l_high = ++ep->l_cur;

	return (0);
}

/*
 * log_line --
 *	Log a line change.
 *
 * PUBLIC: int log_line(SCR *, recno_t, u_int);
 */
int
log_line(SCR *sp, recno_t lno, u_int action)
{
	DBT data, key;
	EXF *ep;
	size_t len;
	char *lp;

	ep = sp->ep;
	if (F_ISSET(ep, F_NOLOG))
		return (0);

	/*
	 * XXX
	 *
	 * Kluge for vi.  Clear the EXF undo flag so that the
	 * next 'u' command does a roll-back, regardless.
	 */
	F_CLR(ep, F_UNDO);

	/* Put out one initial cursor record per set of changes. */
	if (ep->l_cursor.lno != OOBLNO) {
		if (log_cursor1(sp, LOG_CURSOR_INIT))
			return (1);
		ep->l_cursor.lno = OOBLNO;
	}

	/*
	 * Put out the changes.  If it's a LOG_LINE_RESET_B call, it's a
	 * special case, avoid the caches.  Also, if it fails and it's
	 * line 1, it just means that the user started with an empty file,
	 * so fake an empty length line.
	 */
	if (action == LOG_LINE_RESET_B) {
		if (db_get(sp, lno, DBG_NOCACHE, &lp, &len)) {
			if (lno != 1) {
				db_err(sp, lno);
				return (1);
			}
			len = 0;
			lp = "";
		}
	} else
		if (db_get(sp, lno, DBG_FATAL, &lp, &len))
			return (1);
	BINC_RET(sp,
	    ep->l_lp, ep->l_len, len + sizeof(u_char) + sizeof(recno_t));
	ep->l_lp[0] = action;
	memmove(ep->l_lp + sizeof(u_char), &lno, sizeof(recno_t));
	memmove(ep->l_lp + sizeof(u_char) + sizeof(recno_t), lp, len);

	key.data = &ep->l_cur;
	key.size = sizeof(recno_t);
	data.data = ep->l_lp;
	data.size = len + sizeof(u_char) + sizeof(recno_t);
	if (ep->log->put(ep->log, &key, &data, 0) == -1)
		LOG_ERR;

#if defined(DEBUG) && 0
	switch (action) {
	case LOG_LINE_APPEND:
		TRACE(sp, "%u: log_line: append: %lu {%u}\n",
		    ep->l_cur, lno, len);
		break;
	case LOG_LINE_DELETE:
		TRACE(sp, "%lu: log_line: delete: %lu {%u}\n",
		    ep->l_cur, lno, len);
		break;
	case LOG_LINE_INSERT:
		TRACE(sp, "%lu: log_line: insert: %lu {%u}\n",
		    ep->l_cur, lno, len);
		break;
	case LOG_LINE_RESET_F:
		TRACE(sp, "%lu: log_line: reset_f: %lu {%u}\n",
		    ep->l_cur, lno, len);
		break;
	case LOG_LINE_RESET_B:
		TRACE(sp, "%lu: log_line: reset_b: %lu {%u}\n",
		    ep->l_cur, lno, len);
		break;
	}
#endif
	/* Reset high water mark. */
	ep->l_high = ++ep->l_cur;

	return (0);
}

/*
 * log_mark --
 *	Log a mark position.  For the log to work, we assume that there
 *	aren't any operations that just put out a log record -- this
 *	would mean that undo operations would only reset marks, and not
 *	cause any other change.
 *
 * PUBLIC: int log_mark(SCR *, LMARK *);
 */
int
log_mark(SCR *sp, LMARK *lmp)
{
	DBT data, key;
	EXF *ep;

	ep = sp->ep;
	if (F_ISSET(ep, F_NOLOG))
		return (0);

	/* Put out one initial cursor record per set of changes. */
	if (ep->l_cursor.lno != OOBLNO) {
		if (log_cursor1(sp, LOG_CURSOR_INIT))
			return (1);
		ep->l_cursor.lno = OOBLNO;
	}

	BINC_RET(sp, ep->l_lp,
	    ep->l_len, sizeof(u_char) + sizeof(LMARK));
	ep->l_lp[0] = LOG_MARK;
	memmove(ep->l_lp + sizeof(u_char), lmp, sizeof(LMARK));

	key.data = &ep->l_cur;
	key.size = sizeof(recno_t);
	data.data = ep->l_lp;
	data.size = sizeof(u_char) + sizeof(LMARK);
	if (ep->log->put(ep->log, &key, &data, 0) == -1)
		LOG_ERR;

#if defined(DEBUG) && 0
	TRACE(sp, "%lu: mark %c: %lu/%u\n",
	    ep->l_cur, lmp->name, lmp->lno, lmp->cno);
#endif
	/* Reset high water mark. */
	ep->l_high = ++ep->l_cur;
	return (0);
}

/*
 * Log_backward --
 *	Roll the log backward one operation.
 *
 * PUBLIC: int log_backward(SCR *, MARK *);
 */
int
log_backward(SCR *sp, MARK *rp)
{
	DBT key, data;
	EXF *ep;
	LMARK lm;
	MARK m;
	recno_t lno;
	int didop;
	u_char *p;

	ep = sp->ep;
	if (F_ISSET(ep, F_NOLOG)) {
		msgq(sp, M_ERR,
		    "Logging not being performed, undo not possible");
		return (1);
	}

	if (ep->l_cur == 1) {
		msgq(sp, M_BERR, "No changes to undo");
		return (1);
	}

	F_SET(ep, F_NOLOG);		/* Turn off logging. */

	key.data = &ep->l_cur;		/* Initialize db request. */
	key.size = sizeof(recno_t);
	for (didop = 0;;) {
		--ep->l_cur;
		if (ep->log->get(ep->log, &key, &data, 0))
			LOG_ERR;
#if defined(DEBUG) && 0
		log_trace(sp, "log_backward", ep->l_cur, data.data);
#endif
		switch (*(p = (u_char *)data.data)) {
		case LOG_CURSOR_INIT:
			if (didop) {
				memmove(rp, p + sizeof(u_char), sizeof(MARK));
				F_CLR(ep, F_NOLOG);
				return (0);
			}
			break;
		case LOG_CURSOR_END:
			break;
		case LOG_LINE_APPEND:
		case LOG_LINE_INSERT:
			didop = 1;
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_delete(sp, lno))
				goto err;
			++sp->rptlines[L_DELETED];
			break;
		case LOG_LINE_DELETE:
			didop = 1;
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_insert(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
			    sizeof(recno_t)))
				goto err;
			++sp->rptlines[L_ADDED];
			break;
		case LOG_LINE_RESET_F:
			break;
		case LOG_LINE_RESET_B:
			didop = 1;
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_set(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
			    sizeof(recno_t)))
				goto err;
			if (sp->rptlchange != lno) {
				sp->rptlchange = lno;
				++sp->rptlines[L_CHANGED];
			}
			break;
		case LOG_MARK:
			didop = 1;
			memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
			m.lno = lm.lno;
			m.cno = lm.cno;
			if (mark_set(sp, lm.name, &m, 0))
				goto err;
			break;
		default:
			abort();
		}
	}

err:	F_CLR(ep, F_NOLOG);
	return (1);
}

/*
 * Log_setline --
 *	Reset the line to its original appearance.
 *
 * XXX
 * There's a bug in this code due to our not logging cursor movements
 * unless a change was made.  If you do a change, move off the line,
 * then move back on and do a 'U', the line will be restored to the way
 * it was before the original change.
 *
 * PUBLIC: int log_setline(SCR *);
 */
int
log_setline(SCR *sp)
{
	DBT key, data;
	EXF *ep;
	LMARK lm;
	MARK m;
	recno_t lno;
	u_char *p;

	ep = sp->ep;
	if (F_ISSET(ep, F_NOLOG)) {
		msgq(sp, M_ERR,
		    "Logging not being performed, undo not possible");
		return (1);
	}

	if (ep->l_cur == 1)
		return (1);

	F_SET(ep, F_NOLOG);		/* Turn off logging. */

	key.data = &ep->l_cur;		/* Initialize db request. */
	key.size = sizeof(recno_t);

	for (;;) {
		--ep->l_cur;
		if (ep->log->get(ep->log, &key, &data, 0))
			LOG_ERR;
#if defined(DEBUG) && 0
		log_trace(sp, "log_setline", ep->l_cur, data.data);
#endif
		switch (*(p = (u_char *)data.data)) {
		case LOG_CURSOR_INIT:
			memmove(&m, p + sizeof(u_char), sizeof(MARK));
			if (m.lno != sp->lno || ep->l_cur == 1) {
				F_CLR(ep, F_NOLOG);
				return (0);
			}
			break;
		case LOG_CURSOR_END:
			memmove(&m, p + sizeof(u_char), sizeof(MARK));
			if (m.lno != sp->lno) {
				++ep->l_cur;
				F_CLR(ep, F_NOLOG);
				return (0);
			}
			break;
		case LOG_LINE_APPEND:
		case LOG_LINE_INSERT:
		case LOG_LINE_DELETE:
		case LOG_LINE_RESET_F:
			break;
		case LOG_LINE_RESET_B:
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (lno == sp->lno &&
			    db_set(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
			    sizeof(recno_t)))
				goto err;
			if (sp->rptlchange != lno) {
				sp->rptlchange = lno;
				++sp->rptlines[L_CHANGED];
			}
		case LOG_MARK:
			memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
			m.lno = lm.lno;
			m.cno = lm.cno;
			if (mark_set(sp, lm.name, &m, 0))
				goto err;
			break;
		default:
			abort();
		}
	}

err:	F_CLR(ep, F_NOLOG);
	return (1);
}

/*
 * Log_forward --
 *	Roll the log forward one operation.
 *
 * PUBLIC: int log_forward(SCR *, MARK *);
 */
int
log_forward(SCR *sp, MARK *rp)
{
	DBT key, data;
	EXF *ep;
	LMARK lm;
	MARK m;
	recno_t lno;
	int didop;
	u_char *p;

	ep = sp->ep;
	if (F_ISSET(ep, F_NOLOG)) {
		msgq(sp, M_ERR,
	    "Logging not being performed, roll-forward not possible");
		return (1);
	}

	if (ep->l_cur == ep->l_high) {
		msgq(sp, M_BERR, "No changes to re-do");
		return (1);
	}

	F_SET(ep, F_NOLOG);		/* Turn off logging. */

	key.data = &ep->l_cur;		/* Initialize db request. */
	key.size = sizeof(recno_t);
	for (didop = 0;;) {
		++ep->l_cur;
		if (ep->log->get(ep->log, &key, &data, 0))
			LOG_ERR;
#if defined(DEBUG) && 0
		log_trace(sp, "log_forward", ep->l_cur, data.data);
#endif
		switch (*(p = (u_char *)data.data)) {
		case LOG_CURSOR_END:
			if (didop) {
				++ep->l_cur;
				memmove(rp, p + sizeof(u_char), sizeof(MARK));
				F_CLR(ep, F_NOLOG);
				return (0);
			}
			break;
		case LOG_CURSOR_INIT:
			break;
		case LOG_LINE_APPEND:
		case LOG_LINE_INSERT:
			didop = 1;
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_insert(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
			    sizeof(recno_t)))
				goto err;
			++sp->rptlines[L_ADDED];
			break;
		case LOG_LINE_DELETE:
			didop = 1;
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_delete(sp, lno))
				goto err;
			++sp->rptlines[L_DELETED];
			break;
		case LOG_LINE_RESET_B:
			break;
		case LOG_LINE_RESET_F:
			didop = 1;
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_set(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
			    sizeof(recno_t)))
				goto err;
			if (sp->rptlchange != lno) {
				sp->rptlchange = lno;
				++sp->rptlines[L_CHANGED];
			}
			break;
		case LOG_MARK:
			didop = 1;
			memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
			m.lno = lm.lno;
			m.cno = lm.cno;
			if (mark_set(sp, lm.name, &m, 0))
				goto err;
			break;
		default:
			abort();
		}
	}

err:	F_CLR(ep, F_NOLOG);
	return (1);
}

/*
 * log_err --
 *	Try and restart the log on failure, i.e. if we run out of memory.
 */
static void
log_err(SCR *sp, char *file, int line)
{
	EXF *ep;

	msgq(sp, M_SYSERR, "%s/%d: log put error", basename(file), line);
	ep = sp->ep;
	(void)ep->log->close(ep->log);
	if (!log_init(sp, ep))
		msgq(sp, M_ERR, "Log restarted");
}

#if defined(DEBUG) && 0
static void
log_trace(SCR *sp, char *msg, recno_t rno, u_char *p)
{
	LMARK lm;
	MARK m;
	recno_t lno;

	switch (*p) {
	case LOG_CURSOR_INIT:
		memmove(&m, p + sizeof(u_char), sizeof(MARK));
		TRACE(sp, "%lu: %s:  C_INIT: %u/%u\n", rno, msg, m.lno, m.cno);
		break;
	case LOG_CURSOR_END:
		memmove(&m, p + sizeof(u_char), sizeof(MARK));
		TRACE(sp, "%lu: %s:   C_END: %u/%u\n", rno, msg, m.lno, m.cno);
		break;
	case LOG_LINE_APPEND:
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
		TRACE(sp, "%lu: %s:  APPEND: %lu\n", rno, msg, lno);
		break;
	case LOG_LINE_INSERT:
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
		TRACE(sp, "%lu: %s:  INSERT: %lu\n", rno, msg, lno);
		break;
	case LOG_LINE_DELETE:
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
		TRACE(sp, "%lu: %s:  DELETE: %lu\n", rno, msg, lno);
		break;
	case LOG_LINE_RESET_F:
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
		TRACE(sp, "%lu: %s: RESET_F: %lu\n", rno, msg, lno);
		break;
	case LOG_LINE_RESET_B:
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
		TRACE(sp, "%lu: %s: RESET_B: %lu\n", rno, msg, lno);
		break;
	case LOG_MARK:
		memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
		TRACE(sp,
		    "%lu: %s:    MARK: %u/%u\n", rno, msg, lm.lno, lm.cno);
		break;
	default:
		abort();
	}
}
#endif
@


1.11
log
@Nuke some excess whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.10 2016/05/27 09:18:11 martijn Exp $	*/
d127 2
a128 4
	if (ep->l_lp != NULL) {
		free(ep->l_lp);
		ep->l_lp = NULL;
	}
@


1.10
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.8 2016/01/30 21:31:08 martijn Exp $	*/
d35 1
a35 1
 *	LOG_LINE_APPEND 	recno_t		char *
@


1.9
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d67 1
a67 1
static void	log_trace(SCR *, char *, recno_t, char *);
d178 1
a178 1
	BINC_RET(sp, ep->l_lp, ep->l_len, sizeof(char) + sizeof(MARK));
d180 1
a180 1
	memmove(ep->l_lp + sizeof(char), &ep->l_cursor, sizeof(MARK));
d185 1
a185 1
	data.size = sizeof(char) + sizeof(MARK);
d252 1
a252 1
	    ep->l_lp, ep->l_len, len + sizeof(char) + sizeof(recno_t));
d254 2
a255 2
	memmove(ep->l_lp + sizeof(char), &lno, sizeof(recno_t));
	memmove(ep->l_lp + sizeof(char) + sizeof(recno_t), lp, len);
d260 1
a260 1
	data.size = len + sizeof(char) + sizeof(recno_t);
d321 1
a321 1
	    ep->l_len, sizeof(char) + sizeof(LMARK));
d323 1
a323 1
	memmove(ep->l_lp + sizeof(char), lmp, sizeof(LMARK));
d328 1
a328 1
	data.size = sizeof(char) + sizeof(LMARK);
d356 1
a356 1
	char *p;
d381 1
a381 1
		switch (*(p = data.data)) {
d384 1
a384 1
				memmove(rp, p + sizeof(char), sizeof(MARK));
d394 1
a394 1
			memmove(&lno, p + sizeof(char), sizeof(recno_t));
d401 3
a403 3
			memmove(&lno, p + sizeof(char), sizeof(recno_t));
			if (db_insert(sp, lno, p + sizeof(char) +
			    sizeof(recno_t), data.size - sizeof(char) -
d412 3
a414 3
			memmove(&lno, p + sizeof(char), sizeof(recno_t));
			if (db_set(sp, lno, p + sizeof(char) +
			    sizeof(recno_t), data.size - sizeof(char) -
d424 1
a424 1
			memmove(&lm, p + sizeof(char), sizeof(LMARK));
d459 1
a459 1
	char *p;
d483 1
a483 1
		switch (*(p = data.data)) {
d485 1
a485 1
			memmove(&m, p + sizeof(char), sizeof(MARK));
d492 1
a492 1
			memmove(&m, p + sizeof(char), sizeof(MARK));
d505 1
a505 1
			memmove(&lno, p + sizeof(char), sizeof(recno_t));
d507 2
a508 2
			    db_set(sp, lno, p + sizeof(char) +
			    sizeof(recno_t), data.size - sizeof(char) -
d516 1
a516 1
			memmove(&lm, p + sizeof(char), sizeof(LMARK));
d546 1
a546 1
	char *p;
d571 1
a571 1
		switch (*(p = data.data)) {
d575 1
a575 1
				memmove(rp, p + sizeof(char), sizeof(MARK));
d585 3
a587 3
			memmove(&lno, p + sizeof(char), sizeof(recno_t));
			if (db_insert(sp, lno, p + sizeof(char) +
			    sizeof(recno_t), data.size - sizeof(char) -
d594 1
a594 1
			memmove(&lno, p + sizeof(char), sizeof(recno_t));
d603 3
a605 3
			memmove(&lno, p + sizeof(char), sizeof(recno_t));
			if (db_set(sp, lno, p + sizeof(char) +
			    sizeof(recno_t), data.size - sizeof(char) -
d615 1
a615 1
			memmove(&lm, p + sizeof(char), sizeof(LMARK));
d648 1
a648 1
log_trace(SCR *sp, char *msg, recno_t rno, char *p)
d656 1
a656 1
		memmove(&m, p + sizeof(char), sizeof(MARK));
d660 1
a660 1
		memmove(&m, p + sizeof(char), sizeof(MARK));
d664 1
a664 1
		memmove(&lno, p + sizeof(char), sizeof(recno_t));
d668 1
a668 1
		memmove(&lno, p + sizeof(char), sizeof(recno_t));
d672 1
a672 1
		memmove(&lno, p + sizeof(char), sizeof(recno_t));
d676 1
a676 1
		memmove(&lno, p + sizeof(char), sizeof(recno_t));
d680 1
a680 1
		memmove(&lno, p + sizeof(char), sizeof(recno_t));
d684 1
a684 1
		memmove(&lm, p + sizeof(char), sizeof(LMARK));
@


1.8
log
@replace tail with basename

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.7 2016/01/06 22:28:52 millert Exp $	*/
d67 1
a67 1
static void	log_trace(SCR *, char *, recno_t, u_char *);
d178 1
a178 1
	BINC_RET(sp, ep->l_lp, ep->l_len, sizeof(u_char) + sizeof(MARK));
d180 1
a180 1
	memmove(ep->l_lp + sizeof(u_char), &ep->l_cursor, sizeof(MARK));
d185 1
a185 1
	data.size = sizeof(u_char) + sizeof(MARK);
d252 1
a252 1
	    ep->l_lp, ep->l_len, len + sizeof(u_char) + sizeof(recno_t));
d254 2
a255 2
	memmove(ep->l_lp + sizeof(u_char), &lno, sizeof(recno_t));
	memmove(ep->l_lp + sizeof(u_char) + sizeof(recno_t), lp, len);
d260 1
a260 1
	data.size = len + sizeof(u_char) + sizeof(recno_t);
d321 1
a321 1
	    ep->l_len, sizeof(u_char) + sizeof(LMARK));
d323 1
a323 1
	memmove(ep->l_lp + sizeof(u_char), lmp, sizeof(LMARK));
d328 1
a328 1
	data.size = sizeof(u_char) + sizeof(LMARK);
d356 1
a356 1
	u_char *p;
d381 1
a381 1
		switch (*(p = (u_char *)data.data)) {
d384 1
a384 1
				memmove(rp, p + sizeof(u_char), sizeof(MARK));
d394 1
a394 1
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
d401 3
a403 3
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_insert(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
d412 3
a414 3
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_set(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
d424 1
a424 1
			memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
d459 1
a459 1
	u_char *p;
d483 1
a483 1
		switch (*(p = (u_char *)data.data)) {
d485 1
a485 1
			memmove(&m, p + sizeof(u_char), sizeof(MARK));
d492 1
a492 1
			memmove(&m, p + sizeof(u_char), sizeof(MARK));
d505 1
a505 1
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
d507 2
a508 2
			    db_set(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
d516 1
a516 1
			memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
d546 1
a546 1
	u_char *p;
d571 1
a571 1
		switch (*(p = (u_char *)data.data)) {
d575 1
a575 1
				memmove(rp, p + sizeof(u_char), sizeof(MARK));
d585 3
a587 3
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_insert(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
d594 1
a594 1
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
d603 3
a605 3
			memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
			if (db_set(sp, lno, p + sizeof(u_char) +
			    sizeof(recno_t), data.size - sizeof(u_char) -
d615 1
a615 1
			memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
d648 1
a648 1
log_trace(SCR *sp, char *msg, recno_t rno, u_char *p)
d656 1
a656 1
		memmove(&m, p + sizeof(u_char), sizeof(MARK));
d660 1
a660 1
		memmove(&m, p + sizeof(u_char), sizeof(MARK));
d664 1
a664 1
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
d668 1
a668 1
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
d672 1
a672 1
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
d676 1
a676 1
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
d680 1
a680 1
		memmove(&lno, p + sizeof(u_char), sizeof(recno_t));
d684 1
a684 1
		memmove(&lm, p + sizeof(u_char), sizeof(LMARK));
@


1.7
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2014/11/12 04:28:41 bentley Exp $	*/
d21 1
d639 1
a639 1
	msgq(sp, M_SYSERR, "%s/%d: log put error", tail(file), line);
@


1.6
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2009/10/27 23:59:47 deraadt Exp $	*/
d101 1
a101 1
		msgq(sp, M_SYSERR, "009|Log file");
d360 1
a360 1
		    "010|Logging not being performed, undo not possible");
d365 1
a365 1
		msgq(sp, M_BERR, "011|No changes to undo");
d463 1
a463 1
		    "012|Logging not being performed, undo not possible");
d550 1
a550 1
	    "013|Logging not being performed, roll-forward not possible");
d555 1
a555 1
		msgq(sp, M_BERR, "014|No changes to re-do");
d638 1
a638 1
	msgq(sp, M_SYSERR, "015|%s/%d: log put error", tail(file), line);
d642 1
a642 1
		msgq(sp, M_ERR, "267|Log restarted");
@


1.5
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2002/02/16 21:27:57 millert Exp $	*/
d82 1
a82 3
log_init(sp, ep)
	SCR *sp;
	EXF *ep;
d116 1
a116 3
log_end(sp, ep)
	SCR *sp;
	EXF *ep;
d144 1
a144 2
log_cursor(sp)
	SCR *sp;
d171 1
a171 3
log_cursor1(sp, type)
	SCR *sp;
	int type;
d206 1
a206 4
log_line(sp, lno, action)
	SCR *sp;
	recno_t lno;
	u_int action;
d303 1
a303 3
log_mark(sp, lmp)
	SCR *sp;
	LMARK *lmp;
d347 1
a347 3
log_backward(sp, rp)
	SCR *sp;
	MARK *rp;
d451 1
a451 2
log_setline(sp)
	SCR *sp;
d537 1
a537 3
log_forward(sp, rp)
	SCR *sp;
	MARK *rp;
d634 1
a634 4
log_err(sp, file, line)
	SCR *sp;
	char *file;
	int line;
d647 1
a647 5
log_trace(sp, msg, rno, p)
	SCR *sp;
	char *msg;
	recno_t rno;
	u_char *p;
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2001/01/29 01:58:30 niklas Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)log.c	10.8 (Berkeley) 3/6/96";
#endif /* not lint */
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 2
a68 2
static int	log_cursor1 __P((SCR *, int));
static void	log_err __P((SCR *, char *, int));
d70 1
a70 1
static void	log_trace __P((SCR *, char *, recno_t, u_char *));
d83 1
a83 1
 * PUBLIC: int log_init __P((SCR *, EXF *));
d119 1
a119 1
 * PUBLIC: int log_end __P((SCR *, EXF *));
d149 1
a149 1
 * PUBLIC: int log_cursor __P((SCR *));
d214 1
a214 1
 * PUBLIC: int log_line __P((SCR *, recno_t, u_int));
d314 1
a314 1
 * PUBLIC: int log_mark __P((SCR *, LMARK *));
d360 1
a360 1
 * PUBLIC: int log_backward __P((SCR *, MARK *));
d466 1
a466 1
 * PUBLIC: int log_setline __P((SCR *));
d553 1
a553 1
 * PUBLIC: int log_forward __P((SCR *, MARK *));
@


1.2
log
@new vi
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)log.c	8.18 (Berkeley) 8/17/94";
a18 1
#include <sys/time.h>
a23 1
#include <signal.h>
a26 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d28 1
a28 1
#include "vi.h"
d65 2
a66 1
static int	log_cursor1 __P((SCR *, EXF *, int));
d73 1
a73 5
	msgq(sp, M_ERR, "Error: %s/%d: put log error: %s",		\
	    tail(__FILE__), __LINE__, strerror(errno));			\
	(void)ep->log->close(ep->log);					\
	if (!log_init(sp, ep))						\
		msgq(sp, M_ERR, "Log restarted");			\
d80 2
d89 3
d105 1
a105 1
		msgq(sp, M_ERR, "log db: %s", strerror(errno));
d116 2
d124 4
d146 2
d150 1
a150 1
log_cursor(sp, ep)
d152 1
d154 5
a158 1
{
d166 1
a166 1
		return (log_cursor1(sp, ep, LOG_CURSOR_END));
d178 1
a178 1
log_cursor1(sp, ep, type)
a179 1
	EXF *ep;
d183 1
d185 1
d211 2
d215 1
a215 1
log_line(sp, ep, lno, action)
a216 1
	EXF *ep;
d221 1
d225 1
d239 1
a239 1
		if (log_cursor1(sp, ep, LOG_CURSOR_INIT))
d251 1
a251 1
		if ((lp = file_rline(sp, ep, lno, &len)) == NULL) {
d253 1
a253 1
				GETLINE_ERR(sp, lno);
d260 1
a260 2
		if ((lp = file_gline(sp, ep, lno, &len)) == NULL) {
			GETLINE_ERR(sp, lno);
a261 1
		}
d311 2
d315 1
a315 1
log_mark(sp, ep, lmp)
a316 1
	EXF *ep;
d320 1
d322 1
d328 1
a328 1
		if (log_cursor1(sp, ep, LOG_CURSOR_INIT))
d357 2
d361 1
a361 1
log_backward(sp, ep, rp)
a362 1
	EXF *ep;
d366 1
d373 1
d376 1
a376 1
		    "Logging not being performed, undo not possible");
d381 1
a381 1
		msgq(sp, M_BERR, "No changes to undo");
d410 1
a410 1
			if (file_dline(sp, ep, lno))
d417 1
a417 1
			if (file_iline(sp, ep, lno, p + sizeof(u_char) +
d428 1
a428 1
			if (file_sline(sp, ep, lno, p + sizeof(u_char) +
d442 1
a442 1
			if (mark_set(sp, ep, lm.name, &m, 0))
d463 2
d467 1
a467 1
log_setline(sp, ep)
a468 1
	EXF *ep;
d471 1
d477 1
d480 1
a480 1
		    "Logging not being performed, undo not possible");
d523 1
a523 1
			    file_sline(sp, ep, lno, p + sizeof(u_char) +
d535 1
a535 1
			if (mark_set(sp, ep, lm.name, &m, 0))
d550 2
d554 1
a554 1
log_forward(sp, ep, rp)
a555 1
	EXF *ep;
d559 1
d566 1
d569 1
a569 1
		    "Logging not being performed, roll-forward not possible");
d574 1
a574 1
		msgq(sp, M_BERR, "No changes to re-do");
d604 1
a604 1
			if (file_iline(sp, ep, lno, p + sizeof(u_char) +
d613 1
a613 1
			if (file_dline(sp, ep, lno))
d622 1
a622 1
			if (file_sline(sp, ep, lno, p + sizeof(u_char) +
d636 1
a636 1
			if (mark_set(sp, ep, lm.name, &m, 0))
d646 19
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
