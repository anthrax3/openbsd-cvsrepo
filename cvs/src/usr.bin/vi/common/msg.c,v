head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.12
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.8
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.6
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.18
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.16
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.14
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.12
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.10
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.8
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.6
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.12.18.18.28.39;	author krw;	state Exp;
branches;
next	1.26;
commitid	fSD9BCfnjZyV2uP8;

1.26
date	2016.01.06.22.29.38;	author millert;	state Exp;
branches;
next	1.25;
commitid	RiORzAsItDrPYyBm;

1.25
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.24;
commitid	adBvXLg05bJxz6yx;

1.24
date	2016.01.06.22.27.39;	author millert;	state Exp;
branches;
next	1.23;
commitid	WTL2xUDqwK7LLJKC;

1.23
date	2015.11.19.07.53.31;	author bentley;	state Exp;
branches;
next	1.22;
commitid	aNUlDSFtbBwW1Tdz;

1.22
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.20;
commitid	T0XpHzXjuQBl1V3E;

1.20
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.19;
commitid	06bi6U3x4gFFf2G1;

1.19
date	2013.11.26.17.48.01;	author pelikan;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.20.03.56.13;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.11.06.58.00;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.25.23.44.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.25.23.30.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.17.02.22.56;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.29.01.58.30;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.09.17.17.18.54;	author michaels;	state Exp;
branches;
next	1.6;

1.6
date	96.08.23.13.18.12;	author michaels;	state Exp;
branches;
next	1.5;

1.5
date	96.08.20.22.55.47;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.22;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.20;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Use %zu/%d to print size_t/ssize_t. Cast recno_t (a.k.a. u_int32_t)
to (unsigned long) to match %lu formats. Makes gcc happier and
quieter.

ok deraadt@@
@
text
@/*	$OpenBSD: msg.c,v 1.26 2016/01/06 22:29:38 millert Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1991, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "../vi/vi.h"

/*
 * msgq --
 *	Display a message.
 *
 * PUBLIC: void msgq(SCR *, mtype_t, const char *, ...);
 */
void
msgq(SCR *sp, mtype_t mt, const char *fmt, ...)
{
	static int reenter;		/* STATIC: Re-entrancy check. */
	GS *gp;
	size_t blen, len, mlen, nlen;
	const char *p;
	char *bp, *mp;
        va_list ap;

	/*
	 * !!!
	 * It's possible to enter msg when there's no screen to hold the
	 * message.  If sp is NULL, ignore the special cases and put the
	 * message out to stderr.
	 */
	if (sp == NULL) {
		gp = NULL;
		if (mt == M_BERR)
			mt = M_ERR;
		else if (mt == M_VINFO)
			mt = M_INFO;
	} else {
		gp = sp->gp;
		switch (mt) {
		case M_BERR:
			if (F_ISSET(sp, SC_VI) && !O_ISSET(sp, O_VERBOSE)) {
				F_SET(gp, G_BELLSCHED);
				return;
			}
			mt = M_ERR;
			break;
		case M_VINFO:
			if (!O_ISSET(sp, O_VERBOSE))
				return;
			mt = M_INFO;
			/* FALLTHROUGH */
		case M_INFO:
			if (F_ISSET(sp, SC_EX_SILENT))
				return;
			break;
		case M_ERR:
		case M_SYSERR:
			break;
		default:
			abort();
		}
	}

	/*
	 * It's possible to reenter msg when it allocates space.  We're
	 * probably dead anyway, but there's no reason to drop core.
	 *
	 * XXX
	 * Yes, there's a race, but it should only be two instructions.
	 */
	if (reenter++)
		return;

	/* Get space for the message. */
	nlen = 1024;
	if (0) {
retry:		FREE_SPACE(sp, bp, blen);
		nlen *= 2;
	}
	bp = NULL;
	blen = 0;
	GET_SPACE_GOTO(sp, bp, blen, nlen);

	/*
	 * Error prefix.
	 *
	 * mp:	 pointer to the current next character to be written
	 * mlen: length of the already written characters
	 * blen: total length of the buffer
	 */
#define	REM	(blen - mlen)
	mp = bp;
	mlen = 0;
	if (mt == M_SYSERR) {
		p = "Error: ";
		len = strlen(p);
		if (REM < len)
			goto retry;
		memcpy(mp, p, len);
		mp += len;
		mlen += len;
	}

	/*
	 * If we're running an ex command that the user didn't enter, display
	 * the file name and line number prefix.
	 */
	if ((mt == M_ERR || mt == M_SYSERR) &&
	    sp != NULL && gp != NULL && gp->if_name != NULL) {
		for (p = gp->if_name; *p != '\0'; ++p) {
			len = snprintf(mp, REM, "%s", KEY_NAME(sp, *p));
			mp += len;
			if ((mlen += len) > blen)
				goto retry;
		}
		len = snprintf(mp, REM, ", %d: ", gp->if_lno);
		mp += len;
		if ((mlen += len) > blen)
			goto retry;
	}

	/* If nothing to format, we're done. */
	if (fmt == NULL) {
		len = 0;
		goto nofmt;
	}

	/* Format the arguments into the string. */
        va_start(ap, fmt);
	len = vsnprintf(mp, REM, fmt, ap);
	va_end(ap);
	if (len >= nlen)
		goto retry;

nofmt:	mp += len;
	if ((mlen += len) > blen)
		goto retry;
	if (mt == M_SYSERR) {
		len = snprintf(mp, REM, ": %s", strerror(errno));
		mp += len;
		if ((mlen += len) > blen)
			goto retry;
		mt = M_ERR;
	}

	/* Add trailing newline. */
	if ((mlen += 1) > blen)
		goto retry;
	*mp = '\n';

	if (sp != NULL)
		(void)ex_fflush(sp);
	if (gp != NULL)
		gp->scr_msg(sp, mt, bp, mlen);
	else
		(void)fprintf(stderr, "%.*s", (int)mlen, bp);

	/* Cleanup. */
	FREE_SPACE(sp, bp, blen);
alloc_err:
	reenter = 0;
}

/*
 * msgq_str --
 *	Display a message with an embedded string.
 *
 * PUBLIC: void msgq_str(SCR *, mtype_t, char *, char *);
 */
void
msgq_str(SCR *sp, mtype_t mtype, char *str, char *fmt)
{
	int nf, sv_errno;
	char *p;

	if (str == NULL) {
		msgq(sp, mtype, fmt);
		return;
	}

	sv_errno = errno;
	p = msg_print(sp, str, &nf);
	errno = sv_errno;
	msgq(sp, mtype, fmt, p);
	if (nf)
		FREE_SPACE(sp, p, 0);
}

/*
 * mod_rpt --
 *	Report on the lines that changed.
 *
 * !!!
 * Historic vi documentation (USD:15-8) claimed that "The editor will also
 * always tell you when a change you make affects text which you cannot see."
 * This wasn't true -- edit a large file and do "100d|1".  We don't implement
 * this semantic since it requires tracking each line that changes during a
 * command instead of just keeping count.
 *
 * Line counts weren't right in historic vi, either.  For example, given the
 * file:
 *	abc
 *	def
 * the command 2d}, from the 'b' would report that two lines were deleted,
 * not one.
 *
 * PUBLIC: void mod_rpt(SCR *);
 */
void
mod_rpt(SCR *sp)
{
	static char * const action[] = {
		"added",
		"changed",
		"deleted",
		"joined",
		"moved",
		"shifted",
		"yanked",
	};
	static char * const lines[] = {
		"line",
		"lines",
	};
	recno_t total;
	u_long rptval;
	int first, cnt;
	size_t blen, len, tlen;
	const char *t;
	char * const *ap;
	char *bp, *p;

	/* Change reports are turned off in batch mode. */
	if (F_ISSET(sp, SC_EX_SILENT))
		return;

	/* Reset changing line number. */
	sp->rptlchange = OOBLNO;

	/*
	 * Don't build a message if not enough changed.
	 *
	 * !!!
	 * And now, a vi clone test.  Historically, vi reported if the number
	 * of changed lines was > than the value, not >=, unless it was a yank
	 * command, which used >=.  No lie.  Furthermore, an action was never
	 * reported for a single line action.  This is consistent for actions
	 * other than yank, but yank didn't report single line actions even if
	 * the report edit option was set to 1.  In addition, setting report to
	 * 0 in the 4BSD historic vi was equivalent to setting it to 1, for an
	 * unknown reason (this bug was fixed in System III/V at some point).
	 * I got complaints, so nvi conforms to System III/V historic practice
	 * except that we report a yank of 1 line if report is set to 1.
	 */
#define	ARSIZE(a)	sizeof(a) / sizeof (*a)
#define	MAXNUM		25
	rptval = O_VAL(sp, O_REPORT);
	for (cnt = 0, total = 0; cnt < ARSIZE(action); ++cnt)
		total += sp->rptlines[cnt];
	if (total == 0)
		return;
	if (total <= rptval && sp->rptlines[L_YANKED] < rptval) {
		for (cnt = 0; cnt < ARSIZE(action); ++cnt)
			sp->rptlines[cnt] = 0;
		return;
	}

	/* Build and display the message. */
	GET_SPACE_GOTO(sp, bp, blen, sizeof(action) * MAXNUM + 1);
	for (p = bp, first = 1, tlen = 0,
	    ap = action, cnt = 0; cnt < ARSIZE(action); ++ap, ++cnt)
		if (sp->rptlines[cnt] != 0) {
			if (first)
				first = 0;
			else {
				*p++ = ';';
				*p++ = ' ';
				tlen += 2;
			}
			len = snprintf(p, MAXNUM, "%u ", sp->rptlines[cnt]);
			p += len;
			tlen += len;
			t = lines[sp->rptlines[cnt] == 1 ? 0 : 1];
			len = strlen(t);
			memcpy(p, t, len);
			p += len;
			tlen += len;
			*p++ = ' ';
			++tlen;
			len = strlen(*ap);
			memcpy(p, *ap, len);
			p += len;
			tlen += len;
			sp->rptlines[cnt] = 0;
		}

	/* Add trailing newline. */
	*p = '\n';
	++tlen;

	(void)ex_fflush(sp);
	sp->gp->scr_msg(sp, M_INFO, bp, tlen);

	FREE_SPACE(sp, bp, blen);
alloc_err:
	return;

#undef ARSIZE
#undef MAXNUM
}

/*
 * msgq_status --
 *	Report on the file's status.
 *
 * PUBLIC: void msgq_status(SCR *, recno_t, u_int);
 */
void
msgq_status(SCR *sp, recno_t lno, u_int flags)
{
	recno_t last;
	size_t blen, len;
	int cnt, needsep;
	const char *t;
	char **ap, *bp, *np, *p, *s, *ep;

	/* Get sufficient memory. */
	len = strlen(sp->frp->name);
	GET_SPACE_GOTO(sp, bp, blen, len * MAX_CHARACTER_COLUMNS + 128);
	p = bp;
	ep = bp + blen;

	/* Copy in the filename. */
	for (t = sp->frp->name; *t != '\0'; ++t) {
		len = KEY_LEN(sp, *t);
		memcpy(p, KEY_NAME(sp, *t), len);
		p += len;
	}
	np = p;
	*p++ = ':';
	*p++ = ' ';

	/* Copy in the argument count. */
	if (F_ISSET(sp, SC_STATUS_CNT) && sp->argv != NULL) {
		for (cnt = 0, ap = sp->argv; *ap != NULL; ++ap, ++cnt);
		if (cnt > 1) {
			(void)snprintf(p, ep - p, "%d files to edit", cnt);
			p += strlen(p);
			*p++ = ':';
			*p++ = ' ';
		}
		F_CLR(sp, SC_STATUS_CNT);
	}

	/*
	 * See nvi/exf.c:file_init() for a description of how and when the
	 * read-only bit is set.
	 *
	 * !!!
	 * The historic display for "name changed" was "[Not edited]".
	 */
	needsep = 0;
	if (F_ISSET(sp->frp, FR_NEWFILE)) {
		F_CLR(sp->frp, FR_NEWFILE);
		len = strlen("new file");
		memcpy(p, "new file", len);
		p += len;
		needsep = 1;
	} else {
		if (F_ISSET(sp->frp, FR_NAMECHANGE)) {
			len = strlen("name changed");
			memcpy(p, "name changed", len);
			p += len;
			needsep = 1;
		}
		if (needsep) {
			*p++ = ',';
			*p++ = ' ';
		}
		t = (F_ISSET(sp->ep, F_MODIFIED)) ? "modified" : "unmodified";
		len = strlen(t);
		memcpy(p, t, len);
		p += len;
		needsep = 1;
	}
	if (F_ISSET(sp->frp, FR_UNLOCKED)) {
		if (needsep) {
			*p++ = ',';
			*p++ = ' ';
		}
		len = strlen("UNLOCKED");
		memcpy(p, "UNLOCKED", len);
		p += len;
		needsep = 1;
	}
	if (O_ISSET(sp, O_READONLY)) {
		if (needsep) {
			*p++ = ',';
			*p++ = ' ';
		}
		len = strlen("readonly");
		memcpy(p, "readonly", len);
		p += len;
		needsep = 1;
	}
	if (needsep) {
		*p++ = ':';
		*p++ = ' ';
	}
	if (LF_ISSET(MSTAT_SHOWLAST)) {
		if (db_last(sp, &last))
			return;
		if (last == 0) {
			len = strlen("emptry file");
			memcpy(p, "empty file", len);
			p += len;
		} else {
			(void)snprintf(p, ep - p, "line %lu of %lu [%lu%%]",
			    (unsigned long)lno, (unsigned long)last,
			    (unsigned long)(lno * 100) / last);
			p += strlen(p);
		}
	} else {
		(void)snprintf(p, ep - p, "line %lu", (unsigned long)lno);
		p += strlen(p);
	}
#ifdef DEBUG
	(void)snprintf(p, ep - p, " (pid %ld)", (long)getpid());
	p += strlen(p);
#endif
	*p++ = '\n';
	len = p - bp;

	/*
	 * There's a nasty problem with long path names.  Tags files
	 * can result in long paths and vi will request a continuation key from
	 * the user as soon as it starts the screen.  Unfortunately, the user
	 * has already typed ahead, and chaos results.  If we assume that the
	 * characters in the filenames and informational messages only take a
	 * single screen column each, we can trim the filename.
	 *
	 * XXX
	 * Status lines get put up at fairly awkward times.  For example, when
	 * you do a filter read (e.g., :read ! echo foo) in the top screen of a
	 * split screen, we have to repaint the status lines for all the screens
	 * below the top screen.  We don't want users having to enter continue
	 * characters for those screens.  Make it really hard to screw this up.
	 */
	s = bp;
	if (LF_ISSET(MSTAT_TRUNCATE) && len > sp->cols) {
		for (; s < np && (*s != '/' || (p - s) > sp->cols - 3); ++s);
		if (s == np) {
			s = p - (sp->cols - 5);
			*--s = ' ';
		}
		*--s = '.';
		*--s = '.';
		*--s = '.';
		len = p - s;
	}

	/* Flush any waiting ex messages. */
	(void)ex_fflush(sp);

	sp->gp->scr_msg(sp, M_INFO, s, len);

	FREE_SPACE(sp, bp, blen);
alloc_err:
	return;
}

/*
 * msg_cont --
 *	Return common continuation messages.
 *
 * PUBLIC: const char *msg_cmsg(SCR *, cmsg_t, size_t *);
 */
const char *
msg_cmsg(SCR *sp, cmsg_t which, size_t *lenp)
{
	const char *s;
	switch (which) {
	case CMSG_CONF:
		s = "confirm? [ynq]";
		break;
	case CMSG_CONT:
		s = "Press any key to continue: ";
		break;
	case CMSG_CONT_EX:
		s = "Press any key to continue [: to enter more ex commands]: ";
		break;
	case CMSG_CONT_R:
		s = "Press Enter to continue: ";
		break;
	case CMSG_CONT_S:
		s = " cont?";
		break;
	case CMSG_CONT_Q:
		s = "Press any key to continue [q to quit]: ";
		break;
	default:
		abort();
	}
	*lenp = strlen(s);
	return s;
}

/*
 * msg_print --
 *	Return a printable version of a string, in allocated memory.
 *
 * PUBLIC: char *msg_print(SCR *, const char *, int *);
 */
char *
msg_print(SCR *sp, const char *s, int *needfree)
{
	size_t blen, nlen;
	const char *cp;
	char *bp, *ep, *p, *t;

	*needfree = 0;

	for (cp = s; *cp != '\0'; ++cp)
		if (!isprint(*cp))
			break;
	if (*cp == '\0')
		return ((char *)s);	/* SAFE: needfree set to 0. */

	nlen = 0;
	if (0) {
retry:		if (sp == NULL)
			free(bp);
		else
			FREE_SPACE(sp, bp, blen);
		*needfree = 0;
	}
	nlen += 256;
	if (sp == NULL) {
		if ((bp = malloc(nlen)) == NULL)
			goto alloc_err;
		blen = 0;
	} else
		GET_SPACE_GOTO(sp, bp, blen, nlen);
	if (0) {
alloc_err:	return ("");
	}
	*needfree = 1;

	for (p = bp, ep = (bp + blen) - 1, cp = s; *cp != '\0' && p < ep; ++cp)
		for (t = KEY_NAME(sp, *cp); *t != '\0' && p < ep; *p++ = *t++);
	if (p == ep)
		goto retry;
	*p = '\0';
	return (bp);
}
@


1.26
log
@Remove the msg_cat() function and adjust its former callers.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.25 2016/01/06 22:28:52 millert Exp $	*/
d441 3
a443 2
			(void)snprintf(p, ep - p, "line %lu of %lu [%ld%%]",
			    lno, last, (lno * 100) / last);
d447 1
a447 1
		(void)snprintf(p, ep - p, "line %lu", lno);
@


1.25
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.24 2016/01/06 22:27:39 millert Exp $	*/
d118 2
a119 1
		p = msg_cat(sp, "Error: ", &len);
a149 1
	fmt = msg_cat(sp, fmt, NULL);
d306 2
a307 2
			t = msg_cat(sp,
			    lines[sp->rptlines[cnt] == 1 ? 0 : 1], &len);
d313 2
a314 2
			t = msg_cat(sp, *ap, &len);
			memcpy(p, t, len);
d370 1
a370 2
			(void)snprintf(p, ep - p,
			    msg_cat(sp, "%d files to edit", NULL), cnt);
d388 2
a389 2
		t = msg_cat(sp, "new file", &len);
		memcpy(p, t, len);
d394 2
a395 2
			t = msg_cat(sp, "name changed", &len);
			memcpy(p, t, len);
d403 2
a404 4
		if (F_ISSET(sp->ep, F_MODIFIED))
			t = msg_cat(sp, "modified", &len);
		else
			t = msg_cat(sp, "unmodified", &len);
d414 2
a415 2
		t = msg_cat(sp, "UNLOCKED", &len);
		memcpy(p, t, len);
d424 2
a425 2
		t = msg_cat(sp, "readonly", &len);
		memcpy(p, t, len);
d437 2
a438 2
			t = msg_cat(sp, "empty file", &len);
			memcpy(p, t, len);
d441 2
a442 3
			t = msg_cat(sp, "line %lu of %lu [%ld%%]", &len);
			(void)snprintf(p, ep - p, t, lno, last,
			    (lno * 100) / last);
d446 1
a446 2
		t = msg_cat(sp, "line %lu", &len);
		(void)snprintf(p, ep - p, t, lno);
d503 1
d506 2
a507 1
		return (msg_cat(sp, "confirm? [ynq]", lenp));
d509 2
a510 1
		return (msg_cat(sp, "Press any key to continue: ", lenp));
d512 2
a513 3
		return (msg_cat(sp,
	    "Press any key to continue [: to enter more ex commands]: ",
		    lenp));
d515 2
a516 1
		return (msg_cat(sp, "Press Enter to continue: ", lenp));
d518 2
a519 1
		return (msg_cat(sp, " cont?", lenp));
d521 2
a522 2
		return (msg_cat(sp,
		    "Press any key to continue [q to quit]: ", lenp));
d526 2
a527 26
	/* NOTREACHED */
}

/*
 * msg_cat --
 *	Return a single message from the catalog, plus its length.
 *
 * PUBLIC: const char *msg_cat(SCR *, const char *, size_t *);
 */
const char *
msg_cat(SCR *sp, const char *str, size_t *lenp)
{
	GS *gp;
	DBT data, key;
	recno_t msgno;

	/*
	 * If it's not a catalog message, i.e. has doesn't have a leading
	 * number and '|' symbol, we're done.
	 */
	if (isdigit(str[0]) &&
	    isdigit(str[1]) && isdigit(str[2]) && str[3] == '|')
		str = &str[4];
	if (lenp != NULL)
		*lenp = strlen(str);
	return (str);
@


1.24
log
@Remove the message catalog DB.  This removes the msg_open() and
msg_close() functions along with the msgcat command.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.23 2015/11/19 07:53:31 bentley Exp $	*/
d118 1
a118 1
		p = msg_cat(sp, "020|Error: ", &len);
d236 7
a242 7
		"293|added",
		"294|changed",
		"295|deleted",
		"296|joined",
		"297|moved",
		"298|shifted",
		"299|yanked",
d245 2
a246 2
		"300|line",
		"301|lines",
d371 1
a371 1
			    msg_cat(sp, "317|%d files to edit", NULL), cnt);
d389 1
a389 1
		t = msg_cat(sp, "021|new file", &len);
d395 1
a395 1
			t = msg_cat(sp, "022|name changed", &len);
d405 1
a405 1
			t = msg_cat(sp, "023|modified", &len);
d407 1
a407 1
			t = msg_cat(sp, "024|unmodified", &len);
d417 1
a417 1
		t = msg_cat(sp, "025|UNLOCKED", &len);
d427 1
a427 1
		t = msg_cat(sp, "026|readonly", &len);
d440 1
a440 1
			t = msg_cat(sp, "028|empty file", &len);
d444 1
a444 1
			t = msg_cat(sp, "027|line %lu of %lu [%ld%%]", &len);
d450 1
a450 1
		t = msg_cat(sp, "029|line %lu", &len);
d510 1
a510 1
		return (msg_cat(sp, "268|confirm? [ynq]", lenp));
d512 1
a512 1
		return (msg_cat(sp, "269|Press any key to continue: ", lenp));
d515 1
a515 1
	    "270|Press any key to continue [: to enter more ex commands]: ",
d518 1
a518 1
		return (msg_cat(sp, "161|Press Enter to continue: ", lenp));
d520 1
a520 1
		return (msg_cat(sp, "275| cont?", lenp));
d523 1
a523 1
		    "271|Press any key to continue [q to quit]: ", lenp));
@


1.23
log
@Remove cscope support in vi.

It makes no sense to keep support for a non-base tool in base, especially
for a feature that few if any people use.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.22 2015/01/16 06:40:14 deraadt Exp $	*/
a499 82
 * msg_open --
 *	Open the message catalogs.
 *
 * PUBLIC: int msg_open(SCR *, char *);
 */
int
msg_open(SCR *sp, char *file)
{
	/*
	 * !!!
	 * Assume that the first file opened is the system default, and that
	 * all subsequent ones user defined.  Only display error messages
	 * if we can't open the user defined ones -- it's useful to know if
	 * the system one wasn't there, but if nvi is being shipped with an
	 * installed system, the file will be there, if it's not, then the
	 * message will be repeated every time nvi is started up.
	 */
	static int first = 1;
	DB *db;
	DBT data, key;
	recno_t msgno;
	char *p, *t, buf[PATH_MAX];

	if ((p = strrchr(file, '/')) != NULL && p[1] == '\0' &&
	    (((t = getenv("LC_MESSAGES")) != NULL && t[0] != '\0') ||
	    ((t = getenv("LANG")) != NULL && t[0] != '\0'))) {
		(void)snprintf(buf, sizeof(buf), "%s%s", file, t);
		p = buf;
	} else
		p = file;
	if ((db = dbopen(p,
	    O_NONBLOCK | O_RDONLY, 0, DB_RECNO, NULL)) == NULL) {
		if (first) {
			first = 0;
			return (1);
		}
		msgq_str(sp, M_SYSERR, p, "%s");
		return (1);
	}

	/*
	 * Test record 1 for the magic string.  The msgq call is here so
	 * the message catalog build finds it.
	 */
#define	VMC	"VI_MESSAGE_CATALOG"
	key.data = &msgno;
	key.size = sizeof(recno_t);
	msgno = 1;
	if (db->get(db, &key, &data, 0) != 0 ||
	    data.size != sizeof(VMC) - 1 ||
	    memcmp(data.data, VMC, sizeof(VMC) - 1)) {
		(void)db->close(db);
		if (first) {
			first = 0;
			return (1);
		}
		msgq_str(sp, M_ERR, p,
		    "030|The file %s is not a message catalog");
		return (1);
	}
	first = 0;

	if (sp->gp->msg != NULL)
		(void)sp->gp->msg->close(sp->gp->msg);
	sp->gp->msg = db;
	return (0);
}

/*
 * msg_close --
 *	Close the message catalogs.
 *
 * PUBLIC: void msg_close(GS *);
 */
void
msg_close(GS *gp)
{
	if (gp->msg != NULL)
		(void)gp->msg->close(gp->msg);
}

/*
a533 4
 * !!!
 * Only a single catalog message can be accessed at a time, if multiple
 * ones are needed, they must be copied into local memory.
 *
d548 1
a548 22
	    isdigit(str[1]) && isdigit(str[2]) && str[3] == '|') {
		key.data = &msgno;
		key.size = sizeof(recno_t);
		msgno = atoi(str);

		/*
		 * XXX
		 * Really sleazy hack -- we put an extra character on the
		 * end of the format string, and then we change it to be
		 * the nul termination of the string.  There ought to be
		 * a better way.  Once we can allocate multiple temporary
		 * memory buffers, maybe we can use one of them instead.
		 */
		gp = sp == NULL ? NULL : sp->gp;
		if (gp != NULL && gp->msg != NULL &&
		    gp->msg->get(gp->msg, &key, &data, 0) == 0 &&
		    data.size != 0) {
			if (lenp != NULL)
				*lenp = data.size - 1;
			((char *)data.data)[data.size - 1] = '\0';
			return (data.data);
		}
a549 1
	}
@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.21 2014/11/12 16:29:04 millert Exp $	*/
d462 1
a462 1
	 * There's a nasty problem with long path names.  Cscope and tags files
@


1.21
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.20 2014/11/12 04:28:41 bentley Exp $	*/
a13 1
#include <sys/param.h>
d521 1
a521 1
	char *p, *t, buf[MAXPATHLEN];
@


1.20
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.19 2013/11/26 17:48:01 pelikan Exp $	*/
a14 1
#include <sys/types.h>		/* XXX: param.h may not have included types.h */
a41 10
#ifndef NL_ARGMAX
#define	__NL_ARGMAX	20		/* Set to 9 by System V. */
	struct {
		const char *str;	/* String pointer. */
		size_t	 arg;		/* Argument number. */
		size_t	 prefix;	/* Prefix string length. */
		size_t	 skip;		/* Skipped string length. */
		size_t	 suffix;	/* Suffix string length. */
	} str[__NL_ARGMAX];
#endif
a46 6
#ifndef NL_ARGMAX
	size_t cnt1, cnt2, soff;
	CHAR_T ch;
	const char *t, *u;
	char *rbp, *s_rbp;
#endif
a151 99
#ifndef NL_ARGMAX
	/*
	 * Nvi should run on machines that don't support the numbered argument
	 * specifications (%[digit]*$).  We do this by reformatting the string
	 * so that we can hand it to vsnprintf(3) and it will use the arguments
	 * in the right order.  When vsnprintf returns, we put the string back
	 * into the right order.  It's undefined, according to SVID III, to mix
	 * numbered argument specifications with the standard style arguments,
	 * so this should be safe.
	 *
	 * In addition, we also need a character that is known to not occur in
	 * any vi message, for separating the parts of the string.  As callers
	 * of msgq are responsible for making sure that all the non-printable
	 * characters are formatted for printing before calling msgq, we use a
	 * random non-printable character selected at terminal initialization
	 * time.  This code isn't fast by any means, but as messages should be
	 * relatively short and normally have only a few arguments, it won't be
	 * too bad.  Regardless, nobody has come up with any other solution.
	 *
	 * The result of this loop is an array of pointers into the message
	 * string, with associated lengths and argument numbers.  The array
	 * is in the "correct" order, and the arg field contains the argument
	 * order.
	 */
	for (p = fmt, soff = 0; soff < __NL_ARGMAX;) {
		for (t = p; *p != '\0' && *p != '%'; ++p);
		if (*p == '\0')
			break;
		++p;
		if (!isdigit(*p)) {
			if (*p == '%')
				++p;
			continue;
		}
		for (u = p; isdigit(*++p););
		if (*p != '$')
			continue;

		/* Up to, and including the % character. */
		str[soff].str = t;
		str[soff].prefix = u - t;

		/* Up to, and including the $ character. */
		str[soff].arg = atoi(u);
		str[soff].skip = (p - u) + 1;
		if (str[soff].arg >= __NL_ARGMAX)
			goto ret;

		/* Up to, and including the conversion character. */
		for (u = p; (ch = *++p) != '\0';)
			if (isalpha(ch) &&
			    strchr("diouxXfeEgGcspn", ch) != NULL)
				break;
		str[soff].suffix = p - u;
		if (ch != '\0')
			++p;
		++soff;
	}

	/* If no magic strings, we're done. */
	if (soff == 0)
		goto format;

	 /* Get space for the reordered strings. */
	if ((rbp = malloc(nlen)) == NULL)
		goto ret;
	s_rbp = rbp;

	/*
	 * Reorder the strings into the message string based on argument
	 * order.
	 *
	 * !!!
	 * We ignore arguments that are out of order, i.e. if we don't find
	 * an argument, we continue.  Assume (almost certainly incorrectly)
	 * that whoever created the string knew what they were doing.
	 *
	 * !!!
	 * Brute force "sort", but since we don't expect more than one or two
	 * arguments in a string, the setup cost of a fast sort will be more
	 * expensive than the loop.
	 */
	for (cnt1 = 1; cnt1 <= soff; ++cnt1)
		for (cnt2 = 0; cnt2 < soff; ++cnt2)
			if (cnt1 == str[cnt2].arg) {
				memmove(s_rbp, str[cnt2].str, str[cnt2].prefix);
				memmove(s_rbp + str[cnt2].prefix,
				    str[cnt2].str + str[cnt2].prefix +
				    str[cnt2].skip, str[cnt2].suffix);
				s_rbp += str[cnt2].prefix + str[cnt2].suffix;
				*s_rbp++ =
				    gp == NULL ? DEFAULT_NOPRINT : gp->noprint;
				break;
			}
	*s_rbp = '\0';
	fmt = rbp;

format:
#endif
a157 40

#ifndef NL_ARGMAX
	if (soff == 0)
		goto nofmt;

	/*
	 * Go through the resulting string, and, for each separator character
	 * separated string, enter its new starting position and length in the
	 * array.
	 */
	for (p = t = mp, cnt1 = 1,
	    ch = gp == NULL ? DEFAULT_NOPRINT : gp->noprint; *p != '\0'; ++p)
		if (*p == ch) {
			for (cnt2 = 0; cnt2 < soff; ++cnt2)
				if (str[cnt2].arg == cnt1)
					break;
			str[cnt2].str = t;
			str[cnt2].prefix = p - t;
			t = p + 1;
			++cnt1;
		}

	/*
	 * Reorder the strings once again, putting them back into the
	 * message buffer.
	 *
	 * !!!
	 * Note, the length of the message gets decremented once for
	 * each substring, when we discard the separator character.
	 */
	for (s_rbp = rbp, cnt1 = 0; cnt1 < soff; ++cnt1) {
		memmove(rbp, str[cnt1].str, str[cnt1].prefix);
		rbp += str[cnt1].prefix;
		--len;
	}
	memmove(mp, s_rbp, rbp - s_rbp);

	/* Free the reordered string memory. */
	free(s_rbp);
#endif
@


1.19
log
@fix a possible double-free/NULL deref in msg_print

While there, initialize some variables on unusual paths.
Found by clang static analyzer, ok krw.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.18 2009/10/27 23:59:47 deraadt Exp $	*/
d351 1
a351 4
msgq_str(sp, mtype, str, fmt)
	SCR *sp;
	mtype_t mtype;
	char *str, *fmt;
d390 1
a390 2
mod_rpt(sp)
	SCR *sp;
d499 1
a499 4
msgq_status(sp, lno, flags)
	SCR *sp;
	recno_t lno;
	u_int flags;
d663 1
a663 3
msg_open(sp, file)
	SCR *sp;
	char *file;
d732 1
a732 2
msg_close(gp)
	GS *gp;
d745 1
a745 4
msg_cmsg(sp, which, lenp)
	SCR *sp;
	cmsg_t which;
	size_t *lenp;
d780 1
a780 4
msg_cat(sp, str, lenp)
	SCR *sp;
	const char *str;
	size_t *lenp;
d827 1
a827 4
msg_print(sp, s, needfree)
	SCR *sp;
	const char *s;
	int *needfree;
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.17 2007/03/20 03:56:13 tedu Exp $	*/
d163 2
a164 1
	if (fmt == NULL)
d166 1
d521 1
a521 1
	for (p = bp, t = sp->frp->name; *t != '\0'; ++t) {
d866 1
a866 1
		needfree = 0;
d872 1
@


1.17
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.16 2006/03/11 06:58:00 ray Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)msg.c	10.48 (Berkeley) 9/15/96";
#endif /* not lint */
@


1.16
log
@Silence 39 warnings.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.15 2006/01/08 21:05:39 miod Exp $	*/
d205 1
a205 1
		for (u = p; *++p != '\0' && isdigit(*p););
@


1.15
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.14 2003/04/25 23:44:08 deraadt Exp $	*/
d58 6
d65 3
a67 4
	GS *gp;
	size_t blen, cnt1, cnt2, len, mlen, nlen, soff;
	const char *p, *t, *u;
	char *bp, *mp, *rbp, *s_rbp;
d267 2
d270 1
a270 2

format:	/* Format the arguments into the string. */
d466 1
a466 1
			len = snprintf(p, MAXNUM, "%lu ", sp->rptlines[cnt]);
a509 1
	static int poisoned;
@


1.14
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.13 2003/04/25 23:30:21 deraadt Exp $	*/
d335 1
a335 1
ret:	FREE_SPACE(sp, bp, blen);
d687 2
a688 2
	    ((t = getenv("LC_MESSAGES")) != NULL && t[0] != '\0' ||
	    (t = getenv("LANG")) != NULL && t[0] != '\0')) {
@


1.13
log
@fix comment
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.12 2003/04/17 02:22:56 itojun Exp $	*/
d170 1
a170 1
	 * so that we can hand it to vnsprintf(3) and it will use the arguments
@


1.12
log
@eliminate strcpy/sprintf.  reviewed by deraadt and millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.11 2002/06/12 06:07:16 mpech Exp $	*/
d170 2
a171 2
	 * so that we can hand it to vsprintf(3) and it will use the arguments
	 * in the right order.  When vsprintf returns, we put the string back
@


1.11
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.10 2002/02/19 19:39:39 millert Exp $	*/
d509 1
a509 1
	char **ap, *bp, *np, *p, *s;
d515 1
d531 1
a531 1
			(void)sprintf(p,
d606 2
a607 1
			(void)sprintf(p, t, lno, last, (lno * 100) / last);
d612 1
a612 1
		(void)sprintf(p, t, lno);
d616 1
a616 1
	(void)sprintf(p, " (pid %ld)", (long)getpid());
@


1.10
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.9 2002/02/16 21:27:57 millert Exp $	*/
d614 1
a614 1
	(void)sprintf(p, " (pid %lu)", (u_long)getpid());
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.c,v 1.8 2001/01/29 01:58:30 niklas Exp $	*/
d29 1
a34 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a44 1
#ifdef __STDC__
a45 7
#else
msgq(sp, mt, fmt, va_alist)
	SCR *sp;
	mtype_t mt;
        const char *fmt;
        va_dcl
#endif
a264 1
#ifdef __STDC__
a265 3
#else
        va_start(ap);
#endif
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
 * PUBLIC: void msgq __P((SCR *, mtype_t, const char *, ...));
d361 1
a361 1
 * PUBLIC: void msgq_str __P((SCR *, mtype_t, char *, char *));
d403 1
a403 1
 * PUBLIC: void mod_rpt __P((SCR *));
d513 1
a513 1
 * PUBLIC: void msgq_status __P((SCR *, recno_t, u_int));
d679 1
a679 1
 * PUBLIC: int msg_open __P((SCR *, char *));
d750 1
a750 1
 * PUBLIC: void msg_close __P((GS *));
d764 1
a764 1
 * PUBLIC: const char *msg_cmsg __P((SCR *, cmsg_t, size_t *));
d802 1
a802 1
 * PUBLIC: const char *msg_cat __P((SCR *, const char *, size_t *));
d852 1
a852 1
 * PUBLIC: char *msg_print __P((SCR *, const char *, int *));
@


1.7
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d1 2
@


1.6
log
@nvi 1.75
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)msg.c	10.46 (Berkeley) 8/19/96";
d480 1
a480 1
			memmove(p, t, len);
d486 1
a486 1
			memmove(p, t, len);
d632 1
a633 20

	/*
	 * Poison.
	 *
	 * This message may not be altered in any way, without the written
	 * permission of Keith Bostic.  See the LICENSE file for further
	 * information.
	 */
#define	POISON	"   UNLICENSED"
	if (!poisoned && len < sp->cols - ((sizeof(POISON) - 1) + 1)) {
		memset(p, ' ', sp->cols - len);
		p = (bp + sp->cols) - ((sizeof(POISON) - 1) + 1);
		memcpy(p, POISON, sizeof(POISON) - 1);
		p = (bp + sp->cols) - 1;
		len = p - bp;
		poisoned = 1;
	}

	*p++ = '\n';
	++len;
@


1.5
log
@nvi 1.74
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)msg.c	10.45 (Berkeley) 8/18/96";
d149 1
a149 1
		memmove(mp, p, len);
d528 1
a528 1
	GET_SPACE_GOTO(sp, bp, blen, len + 128);
d532 5
a536 2
	memmove(p, sp->frp->name, len);
	p += len;
d565 1
a565 1
		memmove(p, t, len);
d571 1
a571 1
			memmove(p, t, len);
d583 1
a583 1
		memmove(p, t, len);
d593 1
a593 1
		memmove(p, t, len);
d603 1
a603 1
		memmove(p, t, len);
d616 1
a616 1
			memmove(p, t, len);
d641 4
a644 2
#define	POISON	"   (UNLICENSED)"
	if (!poisoned && len + 1 + (sizeof(POISON) - 1) < sp->cols) {
d646 2
a647 2
		p += sizeof(POISON) - 1;
		len += sizeof(POISON) - 1;
d670 1
a670 1
	if (LF_ISSET(MSTAT_TRUNCATE) && len >= sp->cols) {
@


1.4
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)msg.c	10.42 (Berkeley) 8/11/96";
d519 1
d541 7
a547 6
		(void)sprintf(p,
		    msg_cat(sp, "317|%d files to edit", NULL), cnt);
		p += strlen(p);
		*p++ = ':';
		*p++ = ' ';

d629 17
d647 1
d656 7
d665 11
a675 13
	if (LF_ISSET(MSTAT_TRUNCATE))
		if ((p - s) >= sp->cols) {
			for (; s < np &&
			    (*s != '/' || (p - s) > sp->cols - 3); ++s);
			if (s == np)
				s = bp;
			else {
				*--s = '.';
				*--s = '.';
				*--s = '.';
			}
		}
	len = p - s;
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)msg.c	10.39 (Berkeley) 6/20/96";
d520 2
d523 1
a523 3
	char *bp, *np, *p, *s;
	int needsep;
	size_t blen, len;
d525 1
d530 1
d536 12
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)msg.c	10.36 (Berkeley) 5/15/96";
d384 1
a384 1
 * msgq_rpt --
d401 1
a401 1
 * PUBLIC: void msgq_rpt __P((SCR *));
d404 1
a404 1
msgq_rpt(sp)
d675 3
a677 3
	    ((t = getenv("LANG")) != NULL && t[0] != '\0' ||
	    (t = getenv("LC_MESSAGES")) != NULL && t[0] != '\0')) {
		(void)snprintf(buf, sizeof(buf), "%svi_%s", file, t);
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)msg.c	8.12 (Berkeley) 8/17/94";
d16 2
a17 1
#include <sys/types.h>
d19 1
d23 1
a26 1
#include <signal.h>
a29 1
#include <termios.h>
d38 2
a39 5
#include "compat.h"
#include <db.h>
#include <regex.h>

#include "vi.h"
d44 2
d49 1
a49 1
msgq(SCR *sp, enum msgtype mt, const char *fmt, ...)
d53 2
a54 2
	enum msgtype mt;
        char *fmt;
d58 16
a74 2
	size_t len;
	char msgbuf[1024];
a75 5
#ifdef __STDC__
        va_start(ap, fmt);
#else
        va_start(ap);
#endif
d77 35
a111 13
	 * It's possible to enter msg when there's no screen to hold
	 * the message.  If sp is NULL, ignore the special cases and
	 * just build the message, using __global_list.
	 */
	if (sp == NULL)
		goto nullsp;

	switch (mt) {
	case M_BERR:
		if (!F_ISSET(sp, S_EXSILENT) &&
		    F_ISSET(sp->gp, G_STDIN_TTY) && !O_ISSET(sp, O_VERBOSE)) {
			F_SET(sp, S_BELLSCHED);
			return;
a112 16
		mt = M_ERR;
		break;
	case M_VINFO:
		if (!O_ISSET(sp, O_VERBOSE))
			return;
		mt = M_INFO;
		/* FALLTHROUGH */
	case M_INFO:
		if (F_ISSET(sp, S_EXSILENT))
			return;
		break;
	case M_ERR:
	case M_SYSERR:
		break;
	default:
		abort();
d115 9
a123 1
nullsp:	len = 0;
d125 20
a144 1
#define	EPREFIX	"Error: "
d146 6
a151 2
		memmove(msgbuf, EPREFIX, sizeof(EPREFIX) - 1);
		len += sizeof(EPREFIX) - 1;
d154 16
a169 5
	if (sp != NULL && sp->if_name != NULL) {
		len += snprintf(msgbuf + len, sizeof(msgbuf) - len,
		    "%s, %d: ", sp->if_name, sp->if_lno);
		if (len >= sizeof(msgbuf))
			goto err;
d172 4
a175 12
	if (fmt != NULL) {
		len += vsnprintf(msgbuf + len, sizeof(msgbuf) - len, fmt, ap);
		if (len >= sizeof(msgbuf))
			goto err;
	}

	if (mt == M_SYSERR) {
		len += snprintf(msgbuf + len,
		    sizeof(msgbuf) - len, ": %s", strerror(errno));
		if (len >= sizeof(msgbuf))
			goto err;
	}
d177 1
d179 21
a199 2
	 * If len >= the size, some characters were discarded.
	 * Ignore trailing nul.
d201 23
a223 2
err:	if (len >= sizeof(msgbuf))
		len = sizeof(msgbuf) - 1;
d225 14
a238 6
#ifdef DEBUG
	if (sp != NULL)
		TRACE(sp, "%.*s\n", len, msgbuf);
#endif
	msg_app(__global_list, sp, mt == M_ERR ? 1 : 0, msgbuf, len);
}
d240 4
a243 15
/*
 * msg_app --
 *	Append a message into the queue.  This can fail, but there's
 *	nothing we can do if it does.
 */
void
msg_app(gp, sp, inv_video, p, len)
	GS *gp;
	SCR *sp;
	int inv_video;
	char *p;
	size_t len;
{
	static int reenter;		/* STATIC: Re-entrancy check. */
	MSG *mp, *nmp;
d246 12
a257 2
	 * It's possible to reenter msg when it allocates space.
	 * We're probably dead anyway, but no reason to drop core.
d259 30
a288 3
	if (reenter)
		return;
	reenter = 1;
d291 3
a293 3
	 * We can be entered as the result of a signal arriving, trying
	 * to sync the file and failing.  This shouldn't be a hot spot,
	 * block the signals.
d295 11
a305 1
	SIGBLOCK(gp);
d308 6
a313 2
	 * Find an empty structure, or allocate a new one.  Use the
	 * screen structure if it exists, otherwise the global one.
d315 4
a318 14
	if (sp != NULL) {
		if ((mp = sp->msgq.lh_first) == NULL) {
			CALLOC(sp, mp, MSG *, 1, sizeof(MSG));
			if (mp == NULL)
				goto ret;
			LIST_INSERT_HEAD(&sp->msgq, mp, q);
			goto store;
		}
	} else if ((mp = gp->msgq.lh_first) == NULL) {
		CALLOC(sp, mp, MSG *, 1, sizeof(MSG));
		if (mp == NULL)
			goto ret;
		LIST_INSERT_HEAD(&gp->msgq, mp, q);
		goto store;
d320 15
a334 8
	while (!F_ISSET(mp, M_EMPTY) && mp->q.le_next != NULL)
		mp = mp->q.le_next;
	if (!F_ISSET(mp, M_EMPTY)) {
		CALLOC(sp, nmp, MSG *, 1, sizeof(MSG));
		if (nmp == NULL)
			goto ret;
		LIST_INSERT_AFTER(mp, nmp, q);
		mp = nmp;
d337 32
a368 4
	/* Get enough memory for the message. */
store:	if (len > mp->blen &&
	    (mp->mbuf = binc(sp, mp->mbuf, &mp->blen, len)) == NULL)
		goto ret;
d370 4
a373 4
	/* Store the message. */
	memmove(mp->mbuf, p, len);
	mp->len = len;
	mp->flags = inv_video ? M_INV_VIDEO : 0;
d375 6
a380 2
ret:	reenter = 0;
	SIGUNBLOCK(gp);
d384 1
a384 1
 * msg_rpt --
d390 3
a392 3
 * This isn't true -- edit a large file and do "100d|1".  We don't implement
 * this semantic as it would require that we track each line that changes
 * during a command instead of just keeping count.
d400 2
d403 2
a404 2
int
msg_rpt(sp, is_message)
a405 1
	int is_message;
d408 11
a418 3
		"added", "changed", "deleted", "joined", "moved",
		"left shifted", "right shifted", "yanked",
		NULL,
d423 2
a424 1
	size_t blen, len;
d426 1
a426 1
	char *bp, *p, number[40];
d428 3
a430 2
	if (F_ISSET(sp, S_EXSILENT))
		return (0);
d432 2
a433 2
	if ((rptval = O_VAL(sp, O_REPORT)) == 0)
		goto norpt;
d435 27
a461 2
	GET_SPACE_RET(sp, bp, blen, 512);
	p = bp;
d463 4
a466 2
	total = 0;
	for (ap = action, cnt = 0, first = 1; *ap != NULL; ++ap, ++cnt)
d468 8
a475 5
			total += sp->rptlines[cnt];
			len = snprintf(number, sizeof(number),
			    "%s%lu lines %s",
			    first ? "" : "; ", sp->rptlines[cnt], *ap);
			memmove(p, number, len);
d477 13
a489 1
			first = 0;
d492 6
a497 17
	/*
	 * If nothing to report, return.
	 *
	 * !!!
	 * And now, a special vi clone test.  Historically, vi reported if
	 * the number of changed lines was > than the value, not >=.  Which
	 * means that users can't report on single line changes, btw.)  In
	 * any case, if it was a yank command, it was >=, not >.  No lie.  I
	 * got complaints, so we do it right.
	 */
	if (total > rptval || sp->rptlines[L_YANKED] >= rptval) {
		*p = '\0';
		if (is_message)
			msgq(sp, M_INFO, "%s", bp);
		else
			ex_printf(EXCOOKIE, "%s\n", bp);
	}
d500 2
d503 2
a504 4
	/* Clear after each report. */
norpt:	sp->rptlchange = OOBLNO;
	memset(sp->rptlines, 0, sizeof(sp->rptlines));
	return (0);
d508 1
a508 1
 * msg_status --
d510 2
d513 2
a514 2
int
msg_status(sp, ep, lno, showlast)
a515 1
	EXF *ep;
d517 1
a517 1
	int showlast;
d520 14
a533 3
	char *mo, *nc, *nf, *pid, *ro, *ul;
#ifdef DEBUG
	char pbuf[50];
a534 5
	(void)snprintf(pbuf, sizeof(pbuf), " (pid %u)", getpid());
	pid = pbuf;
#else
	pid = "";
#endif
d536 2
a537 2
	 * See nvi/exf.c:file_init() for a description of how and
	 * when the read-only bit is set.
d542 1
d545 4
a548 2
		nf = "new file";
		mo = nc = "";
a549 1
		nf = "";
d551 48
a598 3
			nc = "name changed";
			mo = F_ISSET(ep, F_MODIFIED) ?
			    ", modified" : ", unmodified";
d600 3
a602 3
			nc = "";
			mo = F_ISSET(ep, F_MODIFIED) ?
			    "modified" : "unmodified";
d604 4
d609 76
a684 4
	ro = F_ISSET(sp->frp, FR_RDONLY) ? ", readonly" : "";
	ul = F_ISSET(sp->frp, FR_UNLOCKED) ? ", UNLOCKED" : "";
	if (showlast) {
		if (file_lline(sp, ep, &last))
d686 30
a715 11
		if (last >= 1)
			msgq(sp, M_INFO,
			    "%s: %s%s%s%s%s: line %lu of %lu [%ld%%]%s",
			    sp->frp->name, nf, nc, mo, ul, ro, lno,
			    last, (lno * 100) / last, pid);
		else
			msgq(sp, M_INFO, "%s: %s%s%s%s%s: empty file%s",
			    sp->frp->name, nf, nc, mo, ul, ro, pid);
	} else
		msgq(sp, M_INFO, "%s: %s%s%s%s%s: line %lu%s",
		    sp->frp->name, nf, nc, mo, ul, ro, lno, pid);
a718 1
#ifdef MSG_CATALOG
d720 56
a775 2
 * get_msg --
 *	Return a format based on a message number.
d777 2
a778 2
char *
get_msg(sp, msgno)
d780 2
a781 1
	char *s_msgno;
d783 1
a784 1
	GS *gp;
a785 1
	char *msg, *p;
d787 26
a812 10
	gp = sp == NULL ? __global_list : sp->gp;
	if (gp->msgdb == NULL) {
		p = sp == NULL ? _PATH_MSGDEF : O_STR(sp, O_CATALOG);
		if ((gp->msgdb = dbopen(p,
		    O_NONBLOCK | O_RDONLY, 444, DB_RECNO, NULL)) == NULL) {
			if ((fmt = malloc(256)) == NULL)
				return ("");
			(void)snprintf(fmt,
			    "unable to open %s: %s", p, strerror(errno));
			return (fmt);
d814 38
d853 17
a869 17
	msgno = atoi(s_msgno);
	key.data = &msgno;
	key.size = sizeof(recno_t);
	switch (gp->msgdb->get(gp->msgdb, &key, &data, 0)) {
	case 0:
		return (data.data);
	case 1:
		p = "no catalog record %ls";
		break;
	case -1:
		p = "catalog record %s: %s";
		break;
	}
	if ((fmt = malloc(256)) == NULL)
		return ("");
	(void)snprintf(fmt, p, msgno, strerror(errno));
	return (fmt);
a870 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
