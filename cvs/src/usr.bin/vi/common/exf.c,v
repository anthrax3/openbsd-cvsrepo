head	1.45;
access;
symbols
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.2
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.10
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.6
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2017.04.18.01.45.35;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	Pd2TRHz7UBFr9JGt;

1.44
date	2016.08.01.18.27.35;	author bentley;	state Exp;
branches;
next	1.43;
commitid	NOKOkHbanuF52TAH;

1.43
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.42;
commitid	01nAnartGL7onLD3;

1.42
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.41;
commitid	ruCZ2IKF0FB0ebCr;

1.41
date	2016.01.06.22.29.38;	author millert;	state Exp;
branches;
next	1.40;
commitid	RiORzAsItDrPYyBm;

1.40
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.39;
commitid	adBvXLg05bJxz6yx;

1.39
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	gtDERb7QyXwKGs62;

1.38
date	2015.11.19.07.53.31;	author bentley;	state Exp;
branches;
next	1.37;
commitid	aNUlDSFtbBwW1Tdz;

1.37
date	2015.07.07.18.34.12;	author millert;	state Exp;
branches;
next	1.36;
commitid	95tO20OwxSfPZzOz;

1.36
date	2015.04.24.21.48.31;	author brynet;	state Exp;
branches;
next	1.35;
commitid	snOxq6D74oYtevTu;

1.35
date	2015.04.19.01.10.59;	author millert;	state Exp;
branches;
next	1.34;
commitid	cI8EB3zDK9os7Glo;

1.34
date	2015.03.27.04.11.25;	author brynet;	state Exp;
branches;
next	1.33;
commitid	xTl6pibBNLW0U9wQ;

1.33
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2014.11.14.20.23.56;	author tedu;	state Exp;
branches;
next	1.31;
commitid	glob3jHxGrGxP1VO;

1.31
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.30;
commitid	T0XpHzXjuQBl1V3E;

1.30
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.29;
commitid	06bi6U3x4gFFf2G1;

1.29
date	2014.11.10.21.31.42;	author tedu;	state Exp;
branches;
next	1.28;
commitid	69Pn8C3VMgeMEZUy;

1.28
date	2013.12.01.20.22.34;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.10.13.20.25;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.24.12.59.28;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.18.20.41.24;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.31.18.18.22;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.01.16.47.25;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.02.00.21.16;	author avsm;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.19.00.06.34;	author ericj;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.18.23.56.10;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.17.04.42.55;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.18.21.39.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.29.01.58.29;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.11.26.22.49.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.05.24.22.43.35;	author d;	state Exp;
branches;
next	1.9;

1.9
date	99.03.06.20.27.45;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.03.06.20.19.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.23.22.40.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.27.22.28.07;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.08.20.22.55.47;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.17.58.19;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.17;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.33.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.45
log
@free(NULL) is ok so use it; from Michael W. Bombardieri
@
text
@/*	$OpenBSD: exf.c,v 1.44 2016/08/01 18:27:35 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>

/*
 * We include <sys/file.h>, because the flock(2) and open(2) #defines
 * were found there on historical systems.  We also include <fcntl.h>
 * because the open(2) #defines are found there on newer systems.
 */
#include <sys/file.h>

#include <bitstring.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "common.h"

static int	file_backup(SCR *, char *, char *);
static void	file_cinit(SCR *);
static void	file_comment(SCR *);
static int	file_spath(SCR *, FREF *, struct stat *, int *);

/*
 * file_add --
 *	Insert a file name into the FREF list, if it doesn't already
 *	appear in it.
 *
 * !!!
 * The "if it doesn't already appear" changes vi's semantics slightly.  If
 * you do a "vi foo bar", and then execute "next bar baz", the edit of bar
 * will reflect the line/column of the previous edit session.  Historic nvi
 * did not do this.  The change is a logical extension of the change where
 * vi now remembers the last location in any file that it has ever edited,
 * not just the previously edited file.
 *
 * PUBLIC: FREF *file_add(SCR *, CHAR_T *);
 */
FREF *
file_add(SCR *sp, CHAR_T *name)
{
	GS *gp;
	FREF *frp, *tfrp;

	/*
	 * Return it if it already exists.  Note that we test against the
	 * user's name, whatever that happens to be, including if it's a
	 * temporary file.
	 *
	 * If the user added a file but was unable to initialize it, there
	 * can be file list entries where the name field is NULL.  Discard
	 * them the next time we see them.
	 */
	gp = sp->gp;
	if (name != NULL)
		TAILQ_FOREACH_SAFE(frp, &gp->frefq, q, tfrp) {
			if (frp->name == NULL) {
				TAILQ_REMOVE(&gp->frefq, frp, q);
				free(frp->name);
				free(frp);
				continue;
			}
			if (!strcmp(frp->name, name))
				return (frp);
		}

	/* Allocate and initialize the FREF structure. */
	CALLOC(sp, frp, 1, sizeof(FREF));
	if (frp == NULL)
		return (NULL);

	/*
	 * If no file name specified, or if the file name is a request
	 * for something temporary, file_init() will allocate the file
	 * name.  Temporary files are always ignored.
	 */
	if (name != NULL && strcmp(name, TEMPORARY_FILE_STRING) &&
	    (frp->name = strdup(name)) == NULL) {
		free(frp);
		msgq(sp, M_SYSERR, NULL);
		return (NULL);
	}

	/* Append into the chain of file names. */
	TAILQ_INSERT_TAIL(&gp->frefq, frp, q);

	return (frp);
}

/*
 * file_init --
 *	Start editing a file, based on the FREF structure.  If successsful,
 *	let go of any previous file.  Don't release the previous file until
 *	absolutely sure we have the new one.
 *
 * PUBLIC: int file_init(SCR *, FREF *, char *, int);
 */
int
file_init(SCR *sp, FREF *frp, char *rcv_name, int flags)
{
	EXF *ep;
	RECNOINFO oinfo;
	struct stat sb;
	size_t psize;
	int fd, exists, open_err, readonly;
	char *oname, tname[] = "/tmp/vi.XXXXXXXXXX";

	open_err = readonly = 0;

	/*
	 * If the file is a recovery file, let the recovery code handle it.
	 * Clear the FR_RECOVER flag first -- the recovery code does set up,
	 * and then calls us!  If the recovery call fails, it's probably
	 * because the named file doesn't exist.  So, move boldly forward,
	 * presuming that there's an error message the user will get to see.
	 */
	if (F_ISSET(frp, FR_RECOVER)) {
		F_CLR(frp, FR_RECOVER);
		if (rcv_read(sp, frp) == 0)
			return (0);		/* successful recovery */
	}

	/*
	 * Required FRP initialization; the only flag we keep is the
	 * cursor information.
	 */
	F_CLR(frp, ~FR_CURSORSET);

	/*
	 * Required EXF initialization:
	 *	Flush the line caches.
	 *	Default recover mail file fd to -1.
	 *	Set initial EXF flag bits.
	 */
	CALLOC_RET(sp, ep, 1, sizeof(EXF));
	ep->c_lno = ep->c_nlines = OOBLNO;
	ep->rcv_fd = ep->fcntl_fd = -1;
	F_SET(ep, F_FIRSTMODIFY);

	/*
	 * Scan the user's path to find the file that we're going to
	 * try and open.
	 */
	if (file_spath(sp, frp, &sb, &exists)) {
		free(ep);
		return (1);
	}

	/*
	 * If no name or backing file, for whatever reason, create a backing
	 * temporary file, saving the temp file name so we can later unlink
	 * it.  If the user never named this file, copy the temporary file name
	 * to the real name (we display that until the user renames it).
	 */
	oname = frp->name;
	if (LF_ISSET(FS_OPENERR) || oname == NULL || !exists) {
		/*
		 * Don't try to create a temporary support file twice.
		 */
		if (frp->tname != NULL)
			goto err;
		fd = mkstemp(tname);
		if (fd == -1 || fstat(fd, &sb) == -1 ||
		    fchmod(fd, S_IRUSR | S_IWUSR) == -1) {
			msgq(sp, M_SYSERR,
			    "Unable to create temporary file");
			if (fd != -1) {
				close(fd);
				(void)unlink(tname);
			}
			goto err;
		}
		(void)close(fd);

		if (frp->name == NULL)
			F_SET(frp, FR_TMPFILE);
		if ((frp->tname = strdup(tname)) == NULL ||
		    (frp->name == NULL && (frp->name = strdup(tname)) == NULL)) {
			free(frp->tname);
			msgq(sp, M_SYSERR, NULL);
			(void)unlink(tname);
			goto err;
		}
		oname = frp->tname;
		psize = 1024;
		if (!LF_ISSET(FS_OPENERR))
			F_SET(frp, FR_NEWFILE);
	} else {
		/*
		 * XXX
		 * A seat of the pants calculation: try to keep the file in
		 * 15 pages or less.  Don't use a page size larger than 10K
		 * (vi should have good locality) or smaller than 1K.
		 */
		psize = ((sb.st_size / 15) + 1023) / 1024;
		if (psize > 10)
			psize = 10;
		if (psize == 0)
			psize = 1;
		psize *= 1024;

		if (!S_ISREG(sb.st_mode))
			msgq_str(sp, M_ERR, oname,
			    "Warning: %s is not a regular file");
	}

	/* Save device, inode and modification time. */
	F_SET(ep, F_DEVSET);
	ep->mdev = sb.st_dev;
	ep->minode = sb.st_ino;

	ep->mtim = sb.st_mtim;

	/* Set up recovery. */
	memset(&oinfo, 0, sizeof(RECNOINFO));
	oinfo.bval = '\n';			/* Always set. */
	oinfo.psize = psize;
	oinfo.flags = F_ISSET(sp->gp, G_SNAPSHOT) ? R_SNAPSHOT : 0;
	if (rcv_name == NULL) {
		if (!rcv_tmp(sp, ep, frp->name))
			oinfo.bfname = ep->rcv_path;
	} else {
		if ((ep->rcv_path = strdup(rcv_name)) == NULL) {
			msgq(sp, M_SYSERR, NULL);
			goto err;
		}
		oinfo.bfname = ep->rcv_path;
		F_SET(ep, F_MODIFIED);
	}

	/* Open a db structure. */
	if ((ep->db = dbopen(rcv_name == NULL ? oname : NULL,
	    O_NONBLOCK | O_RDONLY,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH,
	    DB_RECNO, &oinfo)) == NULL) {
		msgq_str(sp,
		    M_SYSERR, rcv_name == NULL ? oname : rcv_name, "%s");
		/*
		 * !!!
		 * Historically, vi permitted users to edit files that couldn't
		 * be read.  This isn't useful for single files from a command
		 * line, but it's quite useful for "vi *.c", since you can skip
		 * past files that you can't read.
		 */ 
		open_err = 1;
		goto oerr;
	}

	/*
	 * Do the remaining things that can cause failure of the new file,
	 * mark and logging initialization.
	 */
	if (mark_init(sp, ep) || log_init(sp, ep))
		goto err;

	/*
	 * Set the alternate file name to be the file we're discarding.
	 *
	 * !!!
	 * Temporary files can't become alternate files, so there's no file
	 * name.  This matches historical practice, although it could only
	 * happen in historical vi as the result of the initial command, i.e.
	 * if vi was executed without a file name.
	 */
	if (LF_ISSET(FS_SETALT))
		set_alt_name(sp, sp->frp == NULL ||
		    F_ISSET(sp->frp, FR_TMPFILE) ? NULL : sp->frp->name);

	/*
	 * Close the previous file; if that fails, close the new one and run
	 * for the border.
	 *
	 * !!!
	 * There's a nasty special case.  If the user edits a temporary file,
	 * and then does an ":e! %", we need to re-initialize the backing
	 * file, but we can't change the name.  (It's worse -- we're dealing
	 * with *names* here, we can't even detect that it happened.)  Set a
	 * flag so that the file_end routine ignores the backing information
	 * of the old file if it happens to be the same as the new one.
	 *
	 * !!!
	 * Side-effect: after the call to file_end(), sp->frp may be NULL.
	 */
	if (sp->ep != NULL) {
		F_SET(frp, FR_DONTDELETE);
		if (file_end(sp, NULL, LF_ISSET(FS_FORCE))) {
			(void)file_end(sp, ep, 1);
			goto err;
		}
		F_CLR(frp, FR_DONTDELETE);
	}

	/*
	 * Lock the file; if it's a recovery file, it should already be
	 * locked.  Note, we acquire the lock after the previous file
	 * has been ended, so that we don't get an "already locked" error
	 * for ":edit!".
	 *
	 * XXX
	 * While the user can't interrupt us between the open and here,
	 * there's a race between the dbopen() and the lock.  Not much
	 * we can do about it.
	 *
	 * XXX
	 * We don't make a big deal of not being able to lock the file.  As
	 * locking rarely works over NFS, and often fails if the file was
	 * mmap(2)'d, it's far too common to do anything like print an error
	 * message, let alone make the file readonly.  At some future time,
	 * when locking is a little more reliable, this should change to be
	 * an error.
	 */
	if (rcv_name == NULL && !O_ISSET(sp, O_READONLY))
		switch (file_lock(sp, oname,
		    &ep->fcntl_fd, ep->db->fd(ep->db), 0)) {
		case LOCK_FAILED:
			F_SET(frp, FR_UNLOCKED);
			break;
		case LOCK_UNAVAIL:
			readonly = 1;
			msgq_str(sp, M_INFO, oname,
			    "%s already locked, session is read-only");
			break;
		case LOCK_SUCCESS:
			break;
		}

	/*
         * Historically, the readonly edit option was set per edit buffer in
         * vi, unless the -R command-line option was specified or the program
         * was executed as "view".  (Well, to be truthful, if the letter 'w'
         * occurred anywhere in the program name, but let's not get into that.)
	 * So, the persistent readonly state has to be stored in the screen
	 * structure, and the edit option value toggles with the contents of
	 * the edit buffer.  If the persistent readonly flag is set, set the
	 * readonly edit option.
	 *
	 * Otherwise, try and figure out if a file is readonly.  This is a
	 * dangerous thing to do.  The kernel is the only arbiter of whether
	 * or not a file is writeable, and the best that a user program can
	 * do is guess.  Obvious loopholes are files that are on a file system
	 * mounted readonly (access catches this one on a few systems), or
	 * alternate protection mechanisms, ACL's for example, that we can't
	 * portably check.  Lots of fun, and only here because users whined.
	 *
	 * !!!
	 * Historic vi displayed the readonly message if none of the file
	 * write bits were set, or if an an access(2) call on the path
	 * failed.  This seems reasonable.  If the file is mode 444, root
	 * users may want to know that the owner of the file did not expect
	 * it to be written.
	 *
	 * Historic vi set the readonly bit if no write bits were set for
	 * a file, even if the access call would have succeeded.  This makes
	 * the superuser force the write even when vi expects that it will
	 * succeed.  I'm less supportive of this semantic, but it's historic
	 * practice and the conservative approach to vi'ing files as root.
	 *
	 * It would be nice if there was some way to update this when the user
	 * does a "^Z; chmod ...".  The problem is that we'd first have to
	 * distinguish between readonly bits set because of file permissions
	 * and those set for other reasons.  That's not too hard, but deciding
	 * when to reevaluate the permissions is trickier.  An alternative
	 * might be to turn off the readonly bit if the user forces a write
	 * and it succeeds.
	 *
	 * XXX
	 * Access(2) doesn't consider the effective uid/gid values.  This
	 * probably isn't a problem for vi when it's running standalone.
	 */
	if (readonly || F_ISSET(sp, SC_READONLY) ||
	    (!F_ISSET(frp, FR_NEWFILE) &&
	    (!(sb.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) ||
	    access(frp->name, W_OK))))
		O_SET(sp, O_READONLY);
	else
		O_CLR(sp, O_READONLY);

	/* Switch... */
	++ep->refcnt;
	sp->ep = ep;
	sp->frp = frp;

	/* Set the initial cursor position, queue initial command. */
	file_cinit(sp);

	/* Redraw the screen from scratch, schedule a welcome message. */
	F_SET(sp, SC_SCR_REFORMAT | SC_STATUS);

	return (0);

err:
	free(frp->name);
	frp->name = NULL;
	if (frp->tname != NULL) {
		(void)unlink(frp->tname);
		free(frp->tname);
		frp->tname = NULL;
	}

oerr:	if (F_ISSET(ep, F_RCV_ON))
		(void)unlink(ep->rcv_path);
	free(ep->rcv_path);
	ep->rcv_path = NULL;
	if (ep->db != NULL)
		(void)ep->db->close(ep->db);
	free(ep);

	return (open_err ?
	    file_init(sp, frp, rcv_name, flags | FS_OPENERR) : 1);
}

/*
 * file_spath --
 *	Scan the user's path to find the file that we're going to
 *	try and open.
 */
static int
file_spath(SCR *sp, FREF *frp, struct stat *sbp, int *existsp)
{
	CHAR_T savech;
	size_t len;
	int found;
	char *name, *p, *t, path[PATH_MAX];

	/*
	 * If the name is NULL or an explicit reference (i.e., the first
	 * component is . or ..) ignore the O_PATH option.
	 */
	name = frp->name;
	if (name == NULL) {
		*existsp = 0;
		return (0);
	}
	if (name[0] == '/' || (name[0] == '.' &&
	    (name[1] == '/' || (name[1] == '.' && name[2] == '/')))) {
		*existsp = !stat(name, sbp);
		return (0);
	}

	/* Try . */
	if (!stat(name, sbp)) {
		*existsp = 1;
		return (0);
	}

	/* Try the O_PATH option values. */
	for (found = 0, p = t = O_STR(sp, O_PATH);; ++p)
		if (*p == ':' || *p == '\0') {
			if (t < p - 1) {
				savech = *p;
				*p = '\0';
				len = snprintf(path,
				    sizeof(path), "%s/%s", t, name);
				if (len >= sizeof(path))
					len = sizeof(path) - 1;
				*p = savech;
				if (!stat(path, sbp)) {
					found = 1;
					break;
				}
			}
			t = p + 1;
			if (*p == '\0')
				break;
		}

	/* If we found it, build a new pathname and discard the old one. */
	if (found) {
		MALLOC_RET(sp, p, len + 1);
		memcpy(p, path, len + 1);
		free(frp->name);
		frp->name = p;
	}
	*existsp = found;
	return (0);
}

/*
 * file_cinit --
 *	Set up the initial cursor position.
 */
static void
file_cinit(SCR *sp)
{
	GS *gp;
	MARK m;
	size_t len;
	int nb;

	/* Set some basic defaults. */
	sp->lno = 1;
	sp->cno = 0;

	/*
	 * Historically, initial commands (the -c option) weren't executed
	 * until a file was loaded, e.g. "vi +10 nofile", followed by an
	 * :edit or :tag command, would execute the +10 on the file loaded
	 * by the subsequent command, (assuming that it existed).  This
	 * applied as well to files loaded using the tag commands, and we
	 * follow that historic practice.  Also, all initial commands were
	 * ex commands and were always executed on the last line of the file.
	 *
	 * Otherwise, if no initial command for this file:
	 *    If in ex mode, move to the last line, first nonblank character.
	 *    If the file has previously been edited, move to the last known
	 *	  position, and check it for validity.
	 *    Otherwise, move to the first line, first nonblank.
	 *
	 * This gets called by the file init code, because we may be in a
	 * file of ex commands and we want to execute them from the right
	 * location in the file.
	 */
	nb = 0;
	gp = sp->gp;
	if (gp->c_option != NULL && !F_ISSET(sp->frp, FR_NEWFILE)) {
		if (db_last(sp, &sp->lno))
			return;
		if (sp->lno == 0) {
			sp->lno = 1;
			sp->cno = 0;
		}
		if (ex_run_str(sp,
		    "-c option", gp->c_option, strlen(gp->c_option), 1, 1))
			return;
		gp->c_option = NULL;
	} else if (F_ISSET(sp, SC_EX)) {
		if (db_last(sp, &sp->lno))
			return;
		if (sp->lno == 0) {
			sp->lno = 1;
			sp->cno = 0;
			return;
		}
		nb = 1;
	} else {
		if (F_ISSET(sp->frp, FR_CURSORSET)) {
			sp->lno = sp->frp->lno;
			sp->cno = sp->frp->cno;

			/* If returning to a file in vi, center the line. */
			 F_SET(sp, SC_SCR_CENTER);
		} else {
			if (O_ISSET(sp, O_COMMENT))
				file_comment(sp);
			else
				sp->lno = 1;
			nb = 1;
		}
		if (db_get(sp, sp->lno, 0, NULL, &len)) {
			sp->lno = 1;
			sp->cno = 0;
			return;
		}
		if (!nb && sp->cno > len)
			nb = 1;
	}
	if (nb) {
		sp->cno = 0;
		(void)nonblank(sp, sp->lno, &sp->cno);
	}

	/*
	 * !!!
	 * The initial column is also the most attractive column.
	 */
	sp->rcm = sp->cno;

	/*
	 * !!!
	 * Historically, vi initialized the absolute mark, but ex did not.
	 * Which meant, that if the first command in ex mode was "visual",
	 * or if an ex command was executed first (e.g. vi +10 file) vi was
	 * entered without the mark being initialized.  For consistency, if
	 * the file isn't empty, we initialize it for everyone, believing
	 * that it can't hurt, and is generally useful.  Not initializing it
	 * if the file is empty is historic practice, although it has always
	 * been possible to set (and use) marks in empty vi files.
	 */
	m.lno = sp->lno;
	m.cno = sp->cno;
	(void)mark_set(sp, ABSMARK1, &m, 0);
}

/*
 * file_end --
 *	Stop editing a file.
 *
 * PUBLIC: int file_end(SCR *, EXF *, int);
 */
int
file_end(SCR *sp, EXF *ep, int force)
{
	FREF *frp;

	/*
	 * !!!
	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER.
	 * (If argument ep is NULL, use sp->ep.)
	 *
	 * If multiply referenced, just decrement the count and return.
	 */
	if (ep == NULL)
		ep = sp->ep;
	if (--ep->refcnt != 0)
		return (0);

	/*
	 *
	 * Clean up the FREF structure.
	 *
	 * Save the cursor location.
	 *
	 * XXX
	 * It would be cleaner to do this somewhere else, but by the time
	 * ex or vi knows that we're changing files it's already happened.
	 */
	frp = sp->frp;
	frp->lno = sp->lno;
	frp->cno = sp->cno;
	F_SET(frp, FR_CURSORSET);

	/*
	 * We may no longer need the temporary backing file, so clean it
	 * up.  We don't need the FREF structure either, if the file was
	 * never named, so lose it.
	 *
	 * !!!
	 * Re: FR_DONTDELETE, see the comment above in file_init().
	 */
	if (!F_ISSET(frp, FR_DONTDELETE) && frp->tname != NULL) {
		if (unlink(frp->tname))
			msgq_str(sp, M_SYSERR, frp->tname, "%s: remove");
		free(frp->tname);
		frp->tname = NULL;
		if (F_ISSET(frp, FR_TMPFILE)) {
			TAILQ_REMOVE(&sp->gp->frefq, frp, q);
			free(frp->name);
			free(frp);
		}
		sp->frp = NULL;
	}

	/*
	 * Clean up the EXF structure.
	 *
	 * Close the db structure.
	 */
	if (ep->db->close != NULL && ep->db->close(ep->db) && !force) {
		msgq_str(sp, M_SYSERR, frp->name, "%s: close");
		++ep->refcnt;
		return (1);
	}

	/* COMMITTED TO THE CLOSE.  THERE'S NO GOING BACK... */

	/* Stop logging. */
	(void)log_end(sp, ep);

	/* Free up any marks. */
	(void)mark_end(sp, ep);

	/*
	 * Delete recovery files, close the open descriptor, free recovery
	 * memory.  See recover.c for a description of the protocol.
	 *
	 * XXX
	 * Unlink backup file first, we can detect that the recovery file
	 * doesn't reference anything when the user tries to recover it.
	 * There's a race, here, obviously, but it's fairly small.
	 */
	if (!F_ISSET(ep, F_RCV_NORM)) {
		if (ep->rcv_path != NULL && unlink(ep->rcv_path))
			msgq_str(sp, M_SYSERR, ep->rcv_path, "%s: remove");
		if (ep->rcv_mpath != NULL && unlink(ep->rcv_mpath))
			msgq_str(sp, M_SYSERR, ep->rcv_mpath, "%s: remove");
	}
	if (ep->fcntl_fd != -1)
		(void)close(ep->fcntl_fd);
	if (ep->rcv_fd != -1)
		(void)close(ep->rcv_fd);
	free(ep->rcv_path);
	free(ep->rcv_mpath);
	free(ep);
	return (0);
}

/*
 * file_write --
 *	Write the file to disk.  Historic vi had fairly convoluted
 *	semantics for whether or not writes would happen.  That's
 *	why all the flags.
 *
 * PUBLIC: int file_write(SCR *, MARK *, MARK *, char *, int);
 */
int
file_write(SCR *sp, MARK *fm, MARK *tm, char *name, int flags)
{
	enum { NEWFILE, OLDFILE } mtype;
	struct stat sb;
	EXF *ep;
	FILE *fp;
	FREF *frp;
	MARK from, to;
	size_t len;
	u_long nlno, nch;
	int fd, nf, noname, oflags, rval;
	char *p, *s, *t, buf[PATH_MAX + 64];
	const char *msgstr;

	ep = sp->ep;
	frp = sp->frp;

	/*
	 * Writing '%', or naming the current file explicitly, has the
	 * same semantics as writing without a name.
	 */
	if (name == NULL || !strcmp(name, frp->name)) {
		noname = 1;
		name = frp->name;
	} else
		noname = 0;

	/* Can't write files marked read-only, unless forced. */
	if (!LF_ISSET(FS_FORCE) && noname && O_ISSET(sp, O_READONLY)) {
		msgq(sp, M_ERR, LF_ISSET(FS_POSSIBLE) ?
		    "Read-only file, not written; use ! to override" :
		    "Read-only file, not written");
		return (1);
	}

	/* If not forced, not appending, and "writeany" not set ... */
	if (!LF_ISSET(FS_FORCE | FS_APPEND) && !O_ISSET(sp, O_WRITEANY)) {
		/* Don't overwrite anything but the original file. */
		if ((!noname || F_ISSET(frp, FR_NAMECHANGE)) &&
		    !stat(name, &sb)) {
			msgq_str(sp, M_ERR, name,
			    LF_ISSET(FS_POSSIBLE) ?
			    "%s exists, not written; use ! to override" :
			    "%s exists, not written");
			return (1);
		}

		/*
		 * Don't write part of any existing file.  Only test for the
		 * original file, the previous test catches anything else.
		 */
		if (!LF_ISSET(FS_ALL) && noname && !stat(name, &sb)) {
			msgq(sp, M_ERR, LF_ISSET(FS_POSSIBLE) ?
			    "Partial file, not written; use ! to override" :
			    "Partial file, not written");
			return (1);
		}
	}

	/*
	 * Figure out if the file already exists -- if it doesn't, we display
	 * the "new file" message.  The stat might not be necessary, but we
	 * just repeat it because it's easier than hacking the previous tests.
	 * The information is only used for the user message and modification
	 * time test, so we can ignore the obvious race condition.
	 *
	 * One final test.  If we're not forcing or appending the current file,
	 * and we have a saved modification time, object if the file changed
	 * since we last edited or wrote it, and make them force it.
	 */
	if (stat(name, &sb))
		mtype = NEWFILE;
	else {
		if (noname && !LF_ISSET(FS_FORCE | FS_APPEND) &&
		    ((F_ISSET(ep, F_DEVSET) &&
		    (sb.st_dev != ep->mdev || sb.st_ino != ep->minode)) ||
		    timespeccmp(&sb.st_mtim, &ep->mtim, !=))) {
			msgq_str(sp, M_ERR, name, LF_ISSET(FS_POSSIBLE) ?
"%s: file modified more recently than this copy; use ! to override" :
"%s: file modified more recently than this copy");
			return (1);
		}

		mtype = OLDFILE;
	}

	/* Set flags to create, write, and either append or truncate. */
	oflags = O_CREAT | O_WRONLY |
	    (LF_ISSET(FS_APPEND) ? O_APPEND : O_TRUNC);

	/* Backup the file if requested. */
	if (!opts_empty(sp, O_BACKUP, 1) &&
	    file_backup(sp, name, O_STR(sp, O_BACKUP)) && !LF_ISSET(FS_FORCE))
		return (1);

	/* Open the file. */
	if ((fd = open(name, oflags,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) < 0) {
		msgq_str(sp, M_SYSERR, name, "%s");
		return (1);
	}

	/* Try and get a lock. */
	if (!noname && file_lock(sp, NULL, NULL, fd, 0) == LOCK_UNAVAIL)
		msgq_str(sp, M_ERR, name,
		    "%s: write lock was unavailable");

	/*
	 * Use stdio for buffering.
	 *
	 * XXX
	 * SVR4.2 requires the fdopen mode exactly match the original open
	 * mode, i.e. you have to open with "a" if appending.
	 */
	if ((fp = fdopen(fd, LF_ISSET(FS_APPEND) ? "a" : "w")) == NULL) {
		msgq_str(sp, M_SYSERR, name, "%s");
		(void)close(fd);
		return (1);
	}

	/* Build fake addresses, if necessary. */
	if (fm == NULL) {
		from.lno = 1;
		from.cno = 0;
		fm = &from;
		if (db_last(sp, &to.lno))
			return (1);
		to.cno = 0;
		tm = &to;
	}

	rval = ex_writefp(sp, name, fp, fm, tm, &nlno, &nch, 0);

	/*
	 * Save the new last modification time -- even if the write fails
	 * we re-init the time.  That way the user can clean up the disk
	 * and rewrite without having to force it.
	 */
	if (noname) {
		if (stat(name, &sb))
			(void)clock_gettime(CLOCK_REALTIME, &ep->mtim);
		else {
			F_SET(ep, F_DEVSET);
			ep->mdev = sb.st_dev;
			ep->minode = sb.st_ino;

			ep->mtim = sb.st_mtim;
		}
	}

	/*
	 * If the write failed, complain loudly.  ex_writefp() has already
	 * complained about the actual error, reinforce it if data was lost.
	 */
	if (rval) {
		if (!LF_ISSET(FS_APPEND))
			msgq_str(sp, M_ERR, name,
			    "%s: WARNING: FILE TRUNCATED");
		return (1);
	}

	/*
	 * Once we've actually written the file, it doesn't matter that the
	 * file name was changed -- if it was, we've already whacked it.
	 */
	F_CLR(frp, FR_NAMECHANGE);

	/*
	 * If wrote the entire file, and it wasn't by appending it to a file,
	 * clear the modified bit.  If the file was written to the original
	 * file name and the file is a temporary, set the "no exit" bit.  This
	 * permits the user to write the file and use it in the context of the
	 * filesystem, but still keeps them from discarding their changes by
	 * exiting.
	 */
	if (LF_ISSET(FS_ALL) && !LF_ISSET(FS_APPEND)) {
		F_CLR(ep, F_MODIFIED);
		if (F_ISSET(frp, FR_TMPFILE)) {
			if (noname)
				F_SET(frp, FR_TMPEXIT);
			else
				F_CLR(frp, FR_TMPEXIT);
		}
	}

	p = msg_print(sp, name, &nf);
	switch (mtype) {
	case NEWFILE:
		len = snprintf(buf, sizeof(buf),
		    "%s: new file: %lu lines, %lu characters", p, nlno, nch);
		if (len >= sizeof(buf))
			len = sizeof(buf) - 1;
		break;
	case OLDFILE:
		msgstr = LF_ISSET(FS_APPEND) ?
		    "%s: appended: %lu lines, %lu characters" :
		    "%s: %lu lines, %lu characters", NULL;
		len = snprintf(buf, sizeof(buf), msgstr, p, nlno, nch);
		if (len >= sizeof(buf))
			len = sizeof(buf) - 1;
		break;
	default:
		abort();
	}

	/*
	 * There's a nasty problem with long path names.  Tags files
	 * can result in long paths and vi will request a continuation key from
	 * the user.  Unfortunately, the user has typed ahead, and chaos will
	 * result.  If we assume that the characters in the filenames only take
	 * a single screen column each, we can trim the filename.
	 */
	s = buf;
	if (len >= sp->cols) {
		for (s = buf, t = buf + strlen(p); s < t &&
		    (*s != '/' || len >= sp->cols - 3); ++s, --len);
		if (s == t)
			s = buf;
		else {
			*--s = '.';		/* Leading ellipses. */
			*--s = '.';
			*--s = '.';
		}
	}
	msgq(sp, M_INFO, "%s", s);
	if (nf)
		FREE_SPACE(sp, p, 0);
	return (0);
}

/*
 * file_backup --
 *	Backup the about-to-be-written file.
 *
 * XXX
 * We do the backup by copying the entire file.  It would be nice to do
 * a rename instead, but: (1) both files may not fit and we want to fail
 * before doing the rename; (2) the backup file may not be on the same
 * disk partition as the file being written; (3) there may be optional
 * file information (MACs, DACs, whatever) that we won't get right if we
 * recreate the file.  So, let's not risk it.
 */
static int
file_backup(SCR *sp, char *name, char *bname)
{
	struct dirent *dp;
	struct stat sb;
	DIR *dirp;
	EXCMD cmd;
	off_t off;
	size_t blen;
	int flags, maxnum, nr, num, nw, rfd, wfd, version;
	char *bp, *estr, *p, *pct, *slash, *t, *wfname, buf[8192];

	rfd = wfd = -1;
	bp = estr = wfname = NULL;

	/*
	 * Open the current file for reading.  Do this first, so that
	 * we don't exec a shell before the most likely failure point.
	 * If it doesn't exist, it's okay, there's just nothing to back
	 * up.
	 */
	errno = 0;
	if ((rfd = open(name, O_RDONLY, 0)) < 0) {
		if (errno == ENOENT)
			return (0);
		estr = name;
		goto err;
	}

	/*
	 * If the name starts with an 'N' character, add a version number
	 * to the name.  Strip the leading N from the string passed to the
	 * expansion routines, for no particular reason.  It would be nice
	 * to permit users to put the version number anywhere in the backup
	 * name, but there isn't a special character that we can use in the
	 * name, and giving a new character a special meaning leads to ugly
	 * hacks both here and in the supporting ex routines.
	 *
	 * Shell and file name expand the option's value.
	 */
	argv_init(sp, &cmd);
	ex_cinit(&cmd, 0, 0, 0, 0, 0, NULL);
	if (bname[0] == 'N') {
		version = 1;
		++bname;
	} else
		version = 0;
	if (argv_exp2(sp, &cmd, bname, strlen(bname)))
		return (1);

	/*
	 *  0 args: impossible.
	 *  1 args: use it.
	 * >1 args: object, too many args.
	 */
	if (cmd.argc != 1) {
		msgq_str(sp, M_ERR, bname,
		    "%s expanded into too many file names");
		(void)close(rfd);
		return (1);
	}

	/*
	 * If appending a version number, read through the directory, looking
	 * for file names that match the name followed by a number.  Make all
	 * of the other % characters in name literal, so the user doesn't get
	 * surprised and sscanf doesn't drop core indirecting through pointers
	 * that don't exist.  If any such files are found, increment its number
	 * by one.
	 */
	if (version) {
		GET_SPACE_GOTO(sp, bp, blen, cmd.argv[0]->len * 2 + 50);
		for (t = bp, slash = NULL,
		    p = cmd.argv[0]->bp; p[0] != '\0'; *t++ = *p++)
			if (p[0] == '%') {
				if (p[1] != '%')
					*t++ = '%';
			} else if (p[0] == '/')
				slash = t;
		pct = t;
		*t++ = '%';
		*t++ = 'd';
		*t = '\0';

		if (slash == NULL) {
			dirp = opendir(".");
			p = bp;
		} else {
			*slash = '\0';
			dirp = opendir(bp);
			*slash = '/';
			p = slash + 1;
		}
		if (dirp == NULL) {
			estr = cmd.argv[0]->bp;
			goto err;
		}

		for (maxnum = 0; (dp = readdir(dirp)) != NULL;)
			if (sscanf(dp->d_name, p, &num) == 1 && num > maxnum)
				maxnum = num;
		(void)closedir(dirp);

		/* Format the backup file name. */
		(void)snprintf(pct, blen - (pct - bp), "%d", maxnum + 1);
		wfname = bp;
	} else {
		bp = NULL;
		wfname = cmd.argv[0]->bp;
	}
	
	/* Open the backup file, avoiding lurkers. */
	if (stat(wfname, &sb) == 0) {
		if (!S_ISREG(sb.st_mode)) {
			msgq_str(sp, M_ERR, bname,
			    "%s: not a regular file");
			goto err;
		}
		if (sb.st_uid != getuid()) {
			msgq_str(sp, M_ERR, bname, "%s: not owned by you");
			goto err;
		}
		if (sb.st_mode & (S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) {
			msgq_str(sp, M_ERR, bname,
			   "%s: accessible by a user other than the owner");
			goto err;
		}
		flags = O_TRUNC;
	} else
		flags = O_CREAT | O_EXCL;
	if ((wfd = open(wfname, flags | O_WRONLY, S_IRUSR | S_IWUSR)) < 0 ||
	    fchmod(wfd, S_IRUSR | S_IWUSR) < 0) {
		if (wfd != -1) {
			close(wfd);
			(void)unlink(wfname);
		}
		estr = bname;
		goto err;
	}

	/* Copy the file's current contents to its backup value. */
	while ((nr = read(rfd, buf, sizeof(buf))) > 0)
		for (off = 0; nr != 0; nr -= nw, off += nw)
			if ((nw = write(wfd, buf + off, nr)) < 0) {
				estr = wfname;
				goto err;
			}
	if (nr < 0) {
		estr = name;
		goto err;
	}

	if (close(rfd)) {
		estr = name;
		goto err;
	}
	if (close(wfd)) {
		estr = wfname;
		goto err;
	}
	if (bp != NULL)
		FREE_SPACE(sp, bp, blen);
	return (0);

alloc_err:
err:	if (rfd != -1)
		(void)close(rfd);
	if (wfd != -1) {
		(void)unlink(wfname);
		(void)close(wfd);
	}
	if (estr)
		msgq_str(sp, M_SYSERR, estr, "%s");
	if (bp != NULL)
		FREE_SPACE(sp, bp, blen);
	return (1);
}

/*
 * file_comment --
 *	Skip the first comment.
 */
static void
file_comment(SCR *sp)
{
	recno_t lno;
	size_t len;
	char *p;

	for (lno = 1; !db_get(sp, lno, 0, &p, &len) && len == 0; ++lno);
	if (p == NULL)
		return;
	if (p[0] == '#') {
		F_SET(sp, SC_SCR_TOP);
		while (!db_get(sp, ++lno, 0, &p, &len))
			if (len < 1 || p[0] != '#') {
				sp->lno = lno;
				return;
			}
	} else if (len > 1 && p[0] == '/' && p[1] == '*') {
		F_SET(sp, SC_SCR_TOP);
		do {
			for (; len > 1; --len, ++p)
				if (p[0] == '*' && p[1] == '/') {
					sp->lno = lno;
					return;
				}
		} while (!db_get(sp, ++lno, 0, &p, &len));
	} else if (len > 1 && p[0] == '/' && p[1] == '/') {
		F_SET(sp, SC_SCR_TOP);
		p += 2;
		len -= 2;
		do {
			for (; len > 1; --len, ++p)
				if (p[0] == '/' && p[1] == '/') {
					sp->lno = lno;
					return;
				}
		} while (!db_get(sp, ++lno, 0, &p, &len));
	}
}

/*
 * file_m1 --
 * 	First modification check routine.  The :next, :prev, :rewind, :tag,
 *	:tagpush, :tagpop, ^^ modifications check.
 *
 * PUBLIC: int file_m1(SCR *, int, int);
 */
int
file_m1(SCR *sp, int force, int flags)
{
	EXF *ep;

	ep = sp->ep;

	/* If no file loaded, return no modifications. */
	if (ep == NULL)
		return (0);

	/*
	 * If the file has been modified, we'll want to write it back or
	 * fail.  If autowrite is set, we'll write it back automatically,
	 * unless force is also set.  Otherwise, we fail unless forced or
	 * there's another open screen on this file.
	 */
	if (F_ISSET(ep, F_MODIFIED)) {
		if (O_ISSET(sp, O_AUTOWRITE)) {
			if (!force && file_aw(sp, flags))
				return (1);
		} else if (ep->refcnt <= 1 && !force) {
			msgq(sp, M_ERR, LF_ISSET(FS_POSSIBLE) ?
"File modified since last complete write; write or use ! to override" :
"File modified since last complete write; write or use :edit! to override");
			return (1);
		}
	}

	return (file_m3(sp, force));
}

/*
 * file_m2 --
 * 	Second modification check routine.  The :edit, :quit, :recover
 *	modifications check.
 *
 * PUBLIC: int file_m2(SCR *, int);
 */
int
file_m2(SCR *sp, int force)
{
	EXF *ep;

	ep = sp->ep;

	/* If no file loaded, return no modifications. */
	if (ep == NULL)
		return (0);

	/*
	 * If the file has been modified, we'll want to fail, unless forced
	 * or there's another open screen on this file.
	 */
	if (F_ISSET(ep, F_MODIFIED) && ep->refcnt <= 1 && !force) {
		msgq(sp, M_ERR,
"File modified since last complete write; write or use ! to override");
		return (1);
	}

	return (file_m3(sp, force));
}

/*
 * file_m3 --
 * 	Third modification check routine.
 *
 * PUBLIC: int file_m3(SCR *, int);
 */
int
file_m3(SCR *sp, int force)
{
	EXF *ep;

	ep = sp->ep;

	/* If no file loaded, return no modifications. */
	if (ep == NULL)
		return (0);

	/*
	 * Don't exit while in a temporary files if the file was ever modified.
	 * The problem is that if the user does a ":wq", we write and quit,
	 * unlinking the temporary file.  Not what the user had in mind at all.
	 * We permit writing to temporary files, so that user maps using file
	 * system names work with temporary files.
	 */
	if (F_ISSET(sp->frp, FR_TMPEXIT) && ep->refcnt <= 1 && !force) {
		msgq(sp, M_ERR,
		    "File is a temporary; exit will discard modifications");
		return (1);
	}
	return (0);
}

/*
 * file_aw --
 *	Autowrite routine.  If modified, autowrite is set and the readonly bit
 *	is not set, write the file.  A routine so there's a place to put the
 *	comment.
 *
 * PUBLIC: int file_aw(SCR *, int);
 */
int
file_aw(SCR *sp, int flags)
{
	if (!F_ISSET(sp->ep, F_MODIFIED))
		return (0);
	if (!O_ISSET(sp, O_AUTOWRITE))
		return (0);

	/*
	 * !!!
	 * Historic 4BSD vi attempted to write the file if autowrite was set,
	 * regardless of the writeability of the file (as defined by the file
	 * readonly flag).  System V changed this as some point, not attempting
	 * autowrite if the file was readonly.  This feels like a bug fix to
	 * me (e.g. the principle of least surprise is violated if readonly is
	 * set and vi writes the file), so I'm compatible with System V.
	 */
	if (O_ISSET(sp, O_READONLY)) {
		msgq(sp, M_INFO,
		    "File readonly, modifications not auto-written");
		return (1);
	}
	return (file_write(sp, NULL, NULL, NULL, flags));
}

/*
 * set_alt_name --
 *	Set the alternate pathname.
 *
 * Set the alternate pathname.  It's a routine because I wanted some place
 * to hang this comment.  The alternate pathname (normally referenced using
 * the special character '#' during file expansion and in the vi ^^ command)
 * is set by almost all ex commands that take file names as arguments.  The
 * rules go something like this:
 *
 *    1: If any ex command takes a file name as an argument (except for the
 *	 :next command), the alternate pathname is set to that file name.
 *	 This excludes the command ":e" and ":w !command" as no file name
 *       was specified.  Note, historically, the :source command did not set
 *	 the alternate pathname.  It does in nvi, for consistency.
 *
 *    2: However, if any ex command sets the current pathname, e.g. the
 *	 ":e file" or ":rew" commands succeed, then the alternate pathname
 *	 is set to the previous file's current pathname, if it had one.
 *	 This includes the ":file" command and excludes the ":e" command.
 *	 So, by rule #1 and rule #2, if ":edit foo" fails, the alternate
 *	 pathname will be "foo", if it succeeds, the alternate pathname will
 *	 be the previous current pathname.  The ":e" command will not set
 *       the alternate or current pathnames regardless.
 *
 *    3: However, if it's a read or write command with a file argument and
 *	 the current pathname has not yet been set, the file name becomes
 *	 the current pathname, and the alternate pathname is unchanged.
 *
 * If the user edits a temporary file, there may be times when there is no
 * alternative file name.  A name argument of NULL turns it off.
 *
 * PUBLIC: void set_alt_name(SCR *, char *);
 */
void
set_alt_name(SCR *sp, char *name)
{
	free(sp->alt_name);
	if (name == NULL)
		sp->alt_name = NULL;
	else if ((sp->alt_name = strdup(name)) == NULL)
		msgq(sp, M_SYSERR, NULL);
}

/*
 * file_lock --
 *	Get an exclusive lock on a file.
 *
 * PUBLIC: lockr_t file_lock(SCR *, char *, int *, int, int);
 */
lockr_t
file_lock(SCR *sp, char *name, int *fdp, int fd, int iswrite)
{
	if (!O_ISSET(sp, O_LOCKFILES))
		return (LOCK_SUCCESS);
	
	/* Set close-on-exec flag so locks are not inherited by shell cmd. */
	if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
		msgq_str(sp, M_SYSERR, name, "%s");

	/*
	 * !!!
	 * We need to distinguish a lock not being available for the file
	 * from the file system not supporting locking.  Flock is documented
	 * as returning EWOULDBLOCK; add EAGAIN for good measure, and assume
	 * they are the former.  There's no portable way to do this.
	 */
	errno = 0;
	return (flock(fd, LOCK_EX | LOCK_NB) ?
	    errno == EAGAIN || errno == EWOULDBLOCK ? LOCK_UNAVAIL : LOCK_FAILED :
	    LOCK_SUCCESS);
}
@


1.44
log
@Remove vi's "directory" option and TMPDIR support.

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.43 2016/05/27 09:18:11 martijn Exp $	*/
d79 1
a79 2
				if (frp->name != NULL)
					free(frp->name);
d199 1
a199 2
			if (frp->tname != NULL)
				free(frp->tname);
d411 3
a413 4
err:	if (frp->name != NULL) {
		free(frp->name);
		frp->name = NULL;
	}
d422 2
a423 4
	if (ep->rcv_path != NULL) {
		free(ep->rcv_path);
		ep->rcv_path = NULL;
	}
d657 1
a657 2
			if (frp->name != NULL)
				free(frp->name);
d701 2
a702 5
	if (ep->rcv_path != NULL)
		free(ep->rcv_path);
	if (ep->rcv_mpath != NULL)
		free(ep->rcv_mpath);

d1352 1
a1352 2
	if (sp->alt_name != NULL)
		free(sp->alt_name);
@


1.43
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.41 2016/01/06 22:29:38 millert Exp $	*/
d127 1
a127 1
	char *oname, tname[PATH_MAX];
a182 4
		if (opts_empty(sp, O_TMP_DIRECTORY, 0))
			goto err;
		(void)snprintf(tname, sizeof(tname),
		    "%s/vi.XXXXXXXXXX", O_STR(sp, O_TMP_DIRECTORY));
@


1.42
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d57 1
a57 1
 * PUBLIC: FREF *file_add(SCR *, char *);
d60 1
a60 1
file_add(SCR *sp, char *name)
d449 1
a449 1
	char savech;
@


1.41
log
@Remove the msg_cat() function and adjust its former callers.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.40 2016/01/06 22:28:52 millert Exp $	*/
d57 1
a57 1
 * PUBLIC: FREF *file_add(SCR *, CHAR_T *);
d60 1
a60 1
file_add(SCR *sp, CHAR_T *name)
d449 1
a449 1
	CHAR_T savech;
@


1.40
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.39 2015/12/07 20:39:19 mmcc Exp $	*/
d917 2
a918 3
		msgstr = msg_cat(sp,
		    "%s: new file: %lu lines, %lu characters", NULL);
		len = snprintf(buf, sizeof(buf), msgstr, p, nlno, nch);
d923 1
a923 1
		msgstr = msg_cat(sp, LF_ISSET(FS_APPEND) ?
d925 1
a925 1
		    "%s: %lu lines, %lu characters", NULL);
@


1.39
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.38 2015/11/19 07:53:31 bentley Exp $	*/
d191 1
a191 1
			    "237|Unable to create temporary file");
d230 1
a230 1
			    "238|Warning: %s is not a regular file");
d347 1
a347 1
			    "239|%s already locked, session is read-only");
d661 1
a661 1
			msgq_str(sp, M_SYSERR, frp->tname, "240|%s: remove");
d679 1
a679 1
		msgq_str(sp, M_SYSERR, frp->name, "241|%s: close");
d703 1
a703 1
			msgq_str(sp, M_SYSERR, ep->rcv_path, "242|%s: remove");
d705 1
a705 1
			msgq_str(sp, M_SYSERR, ep->rcv_mpath, "243|%s: remove");
d759 2
a760 2
		    "244|Read-only file, not written; use ! to override" :
		    "245|Read-only file, not written");
d771 2
a772 2
			    "246|%s exists, not written; use ! to override" :
			    "247|%s exists, not written");
d782 2
a783 2
			    "248|Partial file, not written; use ! to override" :
			    "249|Partial file, not written");
d807 2
a808 2
"250|%s: file modified more recently than this copy; use ! to override" :
"251|%s: file modified more recently than this copy");
d834 1
a834 1
		    "252|%s: write lock was unavailable");
d886 1
a886 1
			    "254|%s: WARNING: FILE TRUNCATED");
d918 1
a918 1
		    "256|%s: new file: %lu lines, %lu characters", NULL);
d925 2
a926 2
		    "315|%s: appended: %lu lines, %lu characters" :
		    "257|%s: %lu lines, %lu characters", NULL);
d1029 1
a1029 1
		    "258|%s expanded into too many file names");
d1087 1
a1087 1
			    "259|%s: not a regular file");
d1091 1
a1091 1
			msgq_str(sp, M_ERR, bname, "260|%s: not owned by you");
d1096 1
a1096 1
			   "261|%s: accessible by a user other than the owner");
d1224 2
a1225 2
"262|File modified since last complete write; write or use ! to override" :
"263|File modified since last complete write; write or use :edit! to override");
d1257 1
a1257 1
"264|File modified since last complete write; write or use ! to override");
d1290 1
a1290 1
		    "265|File is a temporary; exit will discard modifications");
d1323 1
a1323 1
		    "266|File readonly, modifications not auto-written");
@


1.38
log
@Remove cscope support in vi.

It makes no sense to keep support for a non-base tool in base, especially
for a feature that few if any people use.
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.37 2015/07/07 18:34:12 millert Exp $	*/
d89 1
a89 1
	CALLOC(sp, frp, FREF *, 1, sizeof(FREF));
d156 1
a156 1
	CALLOC_RET(sp, ep, EXF *, 1, sizeof(EXF));
d498 1
a498 1
		MALLOC_RET(sp, p, char *, len + 1);
@


1.37
log
@Fix a regression caused by timespec changes when vi is run without
a file to edit.  Based on a diff from Patrick Keshishian.
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.36 2015/04/24 21:48:31 brynet Exp $	*/
d936 1
a936 1
	 * There's a nasty problem with long path names.  Cscope and tags files
@


1.36
log
@struct timespec/clock_gettime(3) conversion for vi(1).

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.35 2015/04/19 01:10:59 millert Exp $	*/
d188 2
a189 1
		if (fd == -1 || fchmod(fd, S_IRUSR | S_IWUSR) == -1) {
a213 2

		(void)clock_gettime(CLOCK_REALTIME, &ep->mtim);
a227 6
		F_SET(ep, F_DEVSET);
		ep->mdev = sb.st_dev;
		ep->minode = sb.st_ino;

		ep->mtim = sb.st_mtim;

d232 7
@


1.35
log
@Don't lock the file for "vi -R" or "view".  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.34 2015/03/27 04:11:25 brynet Exp $	*/
d16 1
d34 1
d214 1
a214 1
		time(&ep->mtime);
d233 1
a233 1
		ep->mtime = sb.st_mtime;
d805 1
a805 1
		    sb.st_mtime != ep->mtime)) {
d869 1
a869 1
			time(&ep->mtime);
d875 1
a875 1
			ep->mtime = sb.st_mtime;
@


1.34
log
@Some vi cleanup, unifdef's some signal blocking code that has never been
enabled in our tree, also removes some stragglers from a global struct
referencing nonexistent Tcl/TK and "IP support". And finally.. deletes
an empty file missed by earlier cleanup by bentley@@.

Inspired by and ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.33 2015/01/16 06:40:14 deraadt Exp $	*/
d336 1
a336 1
	if (rcv_name == NULL)
d344 2
a345 4
			if (!O_ISSET(sp, O_READONLY)) {
				msgq_str(sp, M_INFO, oname,
				    "239|%s already locked, session is read-only");
			}
@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.32 2014/11/14 20:23:56 tedu Exp $	*/
a824 1
	SIGBLOCK;
a827 1
		SIGUNBLOCK;
a829 1
	SIGUNBLOCK;
@


1.32
log
@from natano:
The vi editor contains code for two different file locking methods -
one using flock(), the other using fcntl(). The fcntl method is unused
and has severe limitations (as described in a code comment). Let's
remove it for sake of readibility.
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.31 2014/11/12 16:29:04 millert Exp $	*/
a13 1
#include <sys/param.h>
d125 1
a125 1
	char *oname, tname[MAXPATHLEN];
d452 1
a452 1
	char *name, *p, *t, path[MAXPATHLEN];
d740 1
a740 1
	char *p, *s, *t, buf[MAXPATHLEN + 64];
@


1.31
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.30 2014/11/12 04:28:41 bentley Exp $	*/
a1381 17
 * XXX
 * The default locking is flock(2) style, not fcntl(2).  The latter is
 * known to fail badly on some systems, and its only advantage is that
 * it occasionally works over NFS.
 *
 * Furthermore, the semantics of fcntl(2) are wrong.  The problems are
 * two-fold: you can't close any file descriptor associated with the file
 * without losing all of the locks, and you can't get an exclusive lock
 * unless you have the file open for writing.  Someone ought to be shot,
 * but it's probably too late, they may already have reproduced.  To get
 * around these problems, nvi opens the files for writing when it can and
 * acquires a second file descriptor when it can't.  The recovery files
 * are examples of the former, they're always opened for writing.  The DB
 * files can't be opened for writing because the semantics of DB are that
 * files opened for writing are flushed back to disk when the DB session
 * is ended. So, in that case we have to acquire an extra file descriptor.
 *
a1393 1
#ifdef HAVE_LOCK_FLOCK			/* Hurrah!  We've got flock(2). */
a1404 49
#endif
#ifdef HAVE_LOCK_FCNTL			/* Gag me.  We've got fcntl(2). */
{
	struct flock arg;
	int didopen, sverrno;

	arg.l_type = F_WRLCK;
	arg.l_whence = 0;		/* SEEK_SET */
	arg.l_start = arg.l_len = 0;
	arg.l_pid = 0;

	/*
	 * If the file descriptor isn't opened for writing, it must fail.
	 * If we fail because we can't get a read/write file descriptor,
	 * we return LOCK_SUCCESS, believing that the file is readonly
	 * and that will be sufficient to warn the user.
	 */
	if (!iswrite) {
		if (name == NULL || fdp == NULL)
			return (LOCK_FAILED);
		if ((fd = open(name, O_RDWR, 0)) == -1)
			return (LOCK_SUCCESS);
		*fdp = fd;
		didopen = 1;
	}

	errno = 0;
	if (!fcntl(fd, F_SETLK, &arg))
		return (LOCK_SUCCESS);
	if (didopen) {
		sverrno = errno;
		(void)close(fd);
		errno = sverrno;
	}

	/*
	 * !!!
	 * We need to distinguish a lock not being available for the file
	 * from the file system not supporting locking.  Fcntl is documented
	 * as returning EACCESS and EAGAIN; add EWOULDBLOCK for good measure,
	 * and assume they are the former.  There's no portable way to do this.
	 */
	return (errno == EACCES || errno == EAGAIN || errno == EWOULDBLOCK ?
	    LOCK_UNAVAIL : LOCK_FAILED);
}
#endif
#if !defined(HAVE_LOCK_FLOCK) && !defined(HAVE_LOCK_FCNTL)
	return (LOCK_SUCCESS);
#endif
@


1.30
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.29 2014/11/10 21:31:42 tedu Exp $	*/
a14 1
#include <sys/types.h>		/* XXX: param.h may not have included types.h */
d1420 3
a1422 5
	return (flock(fd, LOCK_EX | LOCK_NB) ? errno == EAGAIN
#ifdef EWOULDBLOCK
	    || errno == EWOULDBLOCK
#endif
	    ? LOCK_UNAVAIL : LOCK_FAILED : LOCK_SUCCESS);
d1465 2
a1466 5
	return (errno == EACCES || errno == EAGAIN
#ifdef EWOULDBLOCK
	|| errno == EWOULDBLOCK
#endif
	?  LOCK_UNAVAIL : LOCK_FAILED);
@


1.29
log
@remove old, unnecessary compat code. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.28 2013/12/01 20:22:34 krw Exp $	*/
d60 1
a60 3
file_add(sp, name)
	SCR *sp;
	CHAR_T *name;
d120 1
a120 5
file_init(sp, frp, rcv_name, flags)
	SCR *sp;
	FREF *frp;
	char *rcv_name;
	int flags;
d449 1
a449 5
file_spath(sp, frp, sbp, existsp)
	SCR *sp;
	FREF *frp;
	struct stat *sbp;
	int *existsp;
d514 1
a514 2
file_cinit(sp)
	SCR *sp;
d622 1
a622 4
file_end(sp, ep, force)
	SCR *sp;
	EXF *ep;
	int force;
d731 1
a731 5
file_write(sp, fm, tm, name, flags)
	SCR *sp;
	MARK *fm, *tm;
	char *name;
	int flags;
d978 1
a978 3
file_backup(sp, name, bname)
	SCR *sp;
	char *name, *bname;
d1160 1
a1160 2
file_comment(sp)
	SCR *sp;
d1207 1
a1207 3
file_m1(sp, force, flags)
	SCR *sp;
	int force, flags;
d1246 1
a1246 3
file_m2(sp, force)
	SCR *sp;
	int force;
d1276 1
a1276 3
file_m3(sp, force)
	SCR *sp;
	int force;
d1310 1
a1310 3
file_aw(sp, flags)
	SCR *sp;
	int flags;
d1369 1
a1369 3
set_alt_name(sp, name)
	SCR *sp;
	char *name;
d1403 1
a1403 4
file_lock(sp, name, fdp, fd, iswrite)
	SCR *sp;
	char *name;
	int *fdp, fd, iswrite;
@


1.28
log
@Change the file reference queue from CIRCLEQ to TAILQ.

vi is now CIRCLEQ free!

ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.27 2013/04/29 00:28:23 okan Exp $	*/
a857 15

#if __linux__
	/*
	 * XXX
	 * In libc 4.5.x, fdopen(fd, "w") clears the O_APPEND flag (if set).
	 * This bug is fixed in libc 4.6.x.
	 *
	 * This code works around this problem for libc 4.5.x users.
	 * Note that this code is harmless if you're using libc 4.6.x.
	 */
	if (LF_ISSET(FS_APPEND) && lseek(fd, (off_t)0, SEEK_END) < 0) {
		msgq(sp, M_SYSERR, "%s", name);
		return (1);
	}
#endif
@


1.27
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.26 2011/07/10 13:20:25 millert Exp $	*/
d78 1
a78 1
		CIRCLEQ_FOREACH(frp, &gp->frefq, q) {
d80 1
a80 2
				tfrp = CIRCLEQ_NEXT(frp, q);
				CIRCLEQ_REMOVE(&gp->frefq, frp, q);
a83 1
				frp = tfrp;
d108 1
a108 1
	CIRCLEQ_INSERT_TAIL(&gp->frefq, frp, q);
d681 1
a681 1
			CIRCLEQ_REMOVE(&sp->gp->frefq, frp, q);
@


1.26
log
@Rename O_DIRECTORY to O_TMP_DIRECTORY to avoid a namespace collision
with sys/fcntl.h.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.25 2009/10/27 23:59:47 deraadt Exp $	*/
d1460 1
a1460 1
	if (fcntl(fd, F_SETFD, 1) == -1)
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.24 2007/11/24 12:59:28 jmc Exp $	*/
d191 1
a191 1
		if (opts_empty(sp, O_DIRECTORY, 0))
d194 1
a194 1
		    "%s/vi.XXXXXXXXXX", O_STR(sp, O_DIRECTORY));
@


1.24
log
@some spelling fixes from Martynas Venckus
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.23 2006/06/18 20:41:24 jasper Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)exf.c	10.49 (Berkeley) 10/10/96";
#endif /* not lint */
@


1.23
log
@Fix memleak; From Coverity Scan, CID 3135.
From simonb NetBSD

ok naddy@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.22 2006/01/08 21:05:39 miod Exp $	*/
d372 1
a372 1
	 * So, the persistant readonly state has to be stored in the screen
d374 1
a374 1
	 * the edit buffer.  If the persistant readonly flag is set, set the
@


1.22
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.21 2005/10/17 19:12:16 otto Exp $	*/
d177 2
a178 1
	if (file_spath(sp, frp, &sb, &exists))
d180 1
@


1.21
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.20 2003/12/31 18:18:22 millert Exp $	*/
d212 1
a212 1
		    frp->name == NULL && (frp->name = strdup(tname)) == NULL) {
d409 1
a409 1
	    !F_ISSET(frp, FR_NEWFILE) &&
d411 1
a411 1
	    access(frp->name, W_OK)))
d479 2
a480 2
	if (name[0] == '/' || name[0] == '.' &&
	    (name[1] == '/' || name[1] == '.' && name[2] == '/')) {
d827 2
a828 2
		    (F_ISSET(ep, F_DEVSET) &&
		    (sb.st_dev != ep->mdev || sb.st_ino != ep->minode) ||
d909 1
a909 1
	if (noname)
d919 1
d948 1
a948 1
		if (F_ISSET(frp, FR_TMPFILE))
d953 1
d1265 1
a1265 1
	if (F_ISSET(ep, F_MODIFIED))
d1275 1
@


1.20
log
@Both POSIX and the man page says that "vi -r foo" is run where foo does not
exist and has no recovery file that vi shall present an error and edit
foo as a new file.  This change makes the behavior match the documentation;
previously it just spat out an error and quit.  Problem found by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.19 2003/08/01 16:47:25 pvalchev Exp $	*/
d82 1
a82 2
		for (frp = gp->frefq.cqh_first;
		    frp != (FREF *)&gp->frefq; frp = frp->q.cqe_next) {
d84 1
a84 1
				tfrp = frp->q.cqe_next;
@


1.19
log
@when the -R option (read-only) is specified, there is no need to print
a warning that the file is read-only, it's obviously what's expected...
ok fgsch henning
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.18 2003/07/02 00:21:16 avsm Exp $	*/
d153 2
a154 1
		return (rcv_read(sp, frp));
@


1.18
log
@bump randomness of mktemp to from 6 to 10 X's, as recommended by mktemp(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.17 2002/02/19 00:06:34 ericj Exp $	*/
d356 4
a359 2
			msgq_str(sp, M_INFO, oname,
			    "239|%s already locked, session is read-only");
@


1.17
log
@
oops, left out ;
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.16 2002/02/18 23:56:10 ericj Exp $	*/
d196 1
a196 1
		    "%s/vi.XXXXXX", O_STR(sp, O_DIRECTORY));
@


1.16
log
@
format string fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.15 2002/02/16 21:27:56 millert Exp $	*/
d992 1
a992 1
	msgq(sp, M_INFO, "%s", s)
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.14 2001/09/17 04:42:55 pvalchev Exp $	*/
d871 1
a871 1
		msgq(sp, M_SYSERR, name);
d992 1
a992 1
	msgq(sp, M_INFO, s);
@


1.14
log
@make vi exit if it can't create a temp file.  From NetBSD, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.13 2001/06/18 21:39:25 millert Exp $	*/
d43 4
a46 4
static int	file_backup __P((SCR *, char *, char *));
static void	file_cinit __P((SCR *));
static void	file_comment __P((SCR *));
static int	file_spath __P((SCR *, FREF *, struct stat *, int *));
d61 1
a61 1
 * PUBLIC: FREF *file_add __P((SCR *, CHAR_T *));
d126 1
a126 1
 * PUBLIC: int file_init __P((SCR *, FREF *, char *, int));
d632 1
a632 1
 * PUBLIC: int file_end __P((SCR *, EXF *, int));
d744 1
a744 1
 * PUBLIC: int file_write __P((SCR *, MARK *, MARK *, char *, int));
d1240 1
a1240 1
 * PUBLIC: int file_m1 __P((SCR *, int, int));
d1280 1
a1280 1
 * PUBLIC: int file_m2 __P((SCR *, int));
d1312 1
a1312 1
 * PUBLIC: int file_m3 __P((SCR *, int));
d1348 1
a1348 1
 * PUBLIC: int file_aw __P((SCR *, int));
d1409 1
a1409 1
 * PUBLIC: void set_alt_name __P((SCR *, char *));
d1445 1
a1445 1
 * PUBLIC: lockr_t file_lock __P((SCR *, char *, int *, int, int));
@


1.13
log
@When creating temp files, use fchmod() to set the perms to be what we
expect since the mode mkstemp() uses can be modified by the umask.
This fixes a problem where vi would spin trying to create temp
files, eating up inodes; reported by xyntrix@@bitz.org

This fix has the side effect of letting you create files with
silly modes (like 0000), but that is probably OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: exf.c,v 1.12 2001/01/29 01:58:29 niklas Exp $	*/
d188 5
@


1.12
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d192 2
a193 1
		if ((fd = mkstemp(tname)) == -1) {
d196 4
d1137 6
a1142 1
	if ((wfd = open(wfname, flags | O_WRONLY, S_IRUSR | S_IWUSR)) < 0) {
@


1.11
log
@o Update README files etc. from nvi-1.79 so they have the correct info
o make port.h empty since we there is nothing we lack
o include <sys/param.h>, not <sys/types.h> in files that use MIN/MAX macros
o add perl api support since we have libperl (off by default)
@
text
@d1 2
@


1.10
log
@set the close-on-exec flag for newly opened files

Reason:
 vi uses flock to help you notice when you are already editing a file.

 But, when using :shell or :! the fdesc for the locked file is inherited by
 the subprocess.

 This means that if you (say) do a :!xterm& and then quit vi, the fdesc is
 kept open by the xterm and the lock is never released. future vi's on
 that file will then complain.

 I sent this off to bostic.com a long time ago but have as yet heard nothing.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)exf.c		10.49 (Berkeley) 10/10/96";
@


1.9
log
@back out changes that should not have escaped my local tree
@
text
@d1439 4
@


1.8
log
@add missing reference to infocmp
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)exf.c	10.49 (Berkeley) 10/10/96";
@


1.7
log
@Fix snprintf return value usage.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)exf.c		10.49 (Berkeley) 10/10/96";
@


1.6
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d485 2
d946 2
d954 2
@


1.5
log
@nvi 1.74
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)exf.c	10.47 (Berkeley) 8/12/96";
d1189 1
a1189 1
	} else if (len >= 1 && p[0] == '/' && p[1] == '*') {
d1194 11
@


1.4
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)exf.c	10.46 (Berkeley) 8/11/96";
d478 1
a478 1
	for (found = 0, p = t = O_STR(sp, O_PATH);; ++p) {
d485 2
a486 1
				if (!stat(path, sbp))
d488 2
a489 1
				*p = savech;
d492 2
a494 3
		if (*p == '\0' || found)
			break;
	}
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)exf.c	10.42 (Berkeley) 6/19/96";
d44 1
d137 1
a137 1
	int fd, open_err, readonly;
d172 7
d185 1
a185 1
	if (LF_ISSET(FS_OPENERR) || oname == NULL || stat(oname, &sb)) {
d211 2
d227 1
d230 1
a409 3
	/* Change the name of the icon/window. */
	(void)sp->gp->scr_rename(sp);

d440 67
d750 3
a756 1
	frp = sp->frp;
d809 5
a813 9
		mtype = OLDFILE;
		if (!LF_ISSET(FS_FORCE | FS_APPEND)) {
			ep = sp->ep;
			if (noname && ep->mtime != 0 &&
			    (sb.st_dev != sp->ep->mdev ||
			    sb.st_ino != ep->minode ||
			    sb.st_mtime != ep->mtime)) {
				msgq_str(sp, M_ERR, name,
				    LF_ISSET(FS_POSSIBLE) ?
d816 1
a816 2
				return (1);
			}
d818 2
d892 1
a892 2
	if (noname) {
		ep = sp->ep;
d894 1
a894 1
			ep->mtime = 0;
d896 1
d899 1
a901 1
	}
d929 1
a929 1
		F_CLR(sp->ep, F_MODIFIED);
d1212 4
d1217 1
a1217 1
	if (sp->ep == NULL)
d1226 1
a1226 1
	if (F_ISSET(sp->ep, F_MODIFIED))
d1230 1
a1230 1
		} else if (sp->ep->refcnt <= 1 && !force) {
d1252 4
d1257 1
a1257 1
	if (sp->ep == NULL)
d1264 1
a1264 1
	if (F_ISSET(sp->ep, F_MODIFIED) && sp->ep->refcnt <= 1 && !force) {
d1284 4
d1289 1
a1289 1
	if (sp->ep == NULL)
d1299 1
a1299 1
	if (F_ISSET(sp->frp, FR_TMPEXIT) && sp->ep->refcnt <= 1 && !force) {
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)exf.c	10.35 (Berkeley) 5/16/96";
d398 3
d668 1
d671 2
a672 1
	char *p;
d846 6
a851 5
	 * If wrote the entire file clear the modified bit.  If the file was
	 * written back to the original file name and the file is a temporary,
	 * set the "no exit" bit.  This permits the user to write the file and
	 * use it in the context of the file system, but still keeps them from
	 * losing their changes by exiting.
d853 1
a853 1
	if (LF_ISSET(FS_ALL)) {
d865 3
a867 2
		msgq(sp, M_INFO, "256|%s: new file: %lu lines, %lu characters",
		    p, nlno, nch);
d870 4
a873 2
		msgq(sp, M_INFO, "257|%s: %s%lu lines, %lu characters",
		    p, LF_ISSET(FS_APPEND) ? "appended: " : "", nlno, nch);
d875 2
d878 21
d1104 1
a1104 1
	if (p == NULL || len <= 1 || p[0] != '/' || p[1] != '*')
d1106 4
a1109 4
	F_SET(sp, SC_SCR_TOP);
	do {
		for (; len; --len, ++p)
			if (p[0] == '*' && len > 1 && p[1] == '/') {
d1113 10
a1122 1
	} while (!db_get(sp, ++lno, 0, &p, &len));
d1390 5
a1394 2
	return (errno == EACCES || errno == EAGAIN || errno == EWOULDBLOCK ?
	    LOCK_UNAVAIL : LOCK_FAILED);
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)exf.c	8.97 (Berkeley) 8/17/94";
d17 1
a19 1
#include <sys/time.h>
d29 1
a36 1
#include <termios.h>
d39 1
a39 4
#include "compat.h"
#include <db.h>
#include <regex.h>
#include <pathnames.h>
d41 3
a43 2
#include "vi.h"
#include "excmd.h"
d57 2
d65 2
a66 1
	FREF *frp;
d72 4
d77 1
d79 11
a89 2
		for (frp = sp->frefq.cqh_first;
		    frp != (FREF *)&sp->frefq; frp = frp->q.cqe_next)
d92 1
d106 1
a106 1
		FREE(frp, sizeof(FREF));
d112 1
a112 1
	CIRCLEQ_INSERT_TAIL(&sp->frefq, frp, q);
d122 2
d126 1
a126 1
file_init(sp, frp, rcv_name, force)
d130 1
a130 1
	int force;
d136 1
a136 1
	int fd;
d139 2
a167 1
	LIST_INIT(&ep->marks);
d171 11
a181 8
	 * If no name or backing file, create a backing temporary file, saving
	 * the temp file name so we can later unlink it.  If the user never
	 * named this file, copy the temporary file name to the real name (we
	 * display that until the user renames it).
	 */
	if ((oname = frp->name) == NULL || stat(oname, &sb)) {
		(void)snprintf(tname,
		    sizeof(tname), "%s/vi.XXXXXX", O_STR(sp, O_DIRECTORY));
d183 2
a184 1
			msgq(sp, M_SYSERR, "Temporary file");
d200 3
a202 2
		psize = 4 * 1024;
		F_SET(frp, FR_NEWFILE);
d205 4
a208 2
		 * Try to keep it at 10 pages or less per file.  This
		 * isn't friendly on a loaded machine, btw.
d210 6
a215 6
		if (sb.st_size < 40 * 1024)
			psize = 4 * 1024;
		else if (sb.st_size < 320 * 1024)
			psize = 32 * 1024;
		else
			psize = 64 * 1024;
d217 2
d222 2
a223 2
			msgq(sp, M_ERR,
			    "Warning: %s is not a regular file", oname);
d245 14
a258 3
	    O_NONBLOCK | O_RDONLY, DEFFILEMODE, DB_RECNO, &oinfo)) == NULL) {
		msgq(sp, M_SYSERR, rcv_name == NULL ? oname : rcv_name);
		goto err;
d269 15
a283 2
	 * Close the previous file; if that fails, close the new one and
	 * run for the border.
d296 7
a302 4
	F_SET(frp, FR_DONTDELETE);
	if (sp->ep != NULL && file_end(sp, sp->ep, force)) {
		(void)file_end(sp, ep, 1);
		goto err;
a303 1
	F_CLR(frp, FR_DONTDELETE);
d325 1
a325 1
		switch (file_lock(oname,
d331 3
a333 3
			msgq(sp, M_INFO,
			    "%s already locked, session is read-only", oname);
			F_SET(frp, FR_RDONLY);
d340 8
a347 4
	 * The -R flag, or doing a "set readonly" during a session causes
	 * all files edited during the session (using an edit command, or
	 * even using tags) to be marked read-only.  Changing the file name
	 * (see ex/ex_file.c), clears this flag.
d382 2
a383 1
	if (O_ISSET(sp, O_READONLY) || !F_ISSET(frp, FR_NEWFILE) &&
d386 3
a388 1
		F_SET(frp, FR_RDONLY);
d390 1
a390 21
	/*
	 * Set the alternate file name to be the file we've just discarded.
	 *
	 * !!!
	 * If the current file was a temporary file, the call to file_end()
	 * unlinked it and free'd the name.  So, there is no previous file,
	 * and there is no alternate file name.  This matches historical
	 * practice, although in historical vi it could only happen as the
	 * result of the initial command, i.e. if vi was executed without a
	 * file name.
	 */
	set_alt_name(sp, sp->frp == NULL ? NULL : sp->frp->name);

	/*
	 * Switch...
	 *
	 * !!!
	 * Note, because the EXF structure is examine at interrupt time,
	 * the underlying DB structures have to be consistent as soon as
	 * it's assigned to an SCR structure.
	 */
d394 7
d412 3
d421 111
a531 2
	FREE(ep, sizeof(EXF));
	return (1);
d537 2
d549 13
d585 1
a585 1
			msgq(sp, M_SYSERR, "%s: remove", frp->tname);
d589 3
a591 2
			CIRCLEQ_REMOVE(&sp->frefq, frp, q);
			free(frp->name);
d600 1
a600 3
	 * sp->ep MAY NOT BE THE SAME AS THE ARGUMENT ep, SO DON'T USE IT!
	 *
	 * If multiply referenced, just decrement the count and return.
a601 4
	if (--ep->refcnt != 0)
		return (0);

	/* Close the db structure. */
d603 1
a603 1
		msgq(sp, M_ERR, "%s: close: %s", frp->name, strerror(errno));
d627 1
a627 2
			msgq(sp, M_ERR,
			    "%s: remove: %s", ep->rcv_path, strerror(errno));
d629 1
a629 2
			msgq(sp, M_ERR,
			    "%s: remove: %s", ep->rcv_mpath, strerror(errno));
d640 1
a640 1
	FREE(ep, sizeof(EXF));
d649 2
d653 1
a653 1
file_write(sp, ep, fm, tm, name, flags)
a654 1
	EXF *ep;
d659 1
d661 1
d666 2
a667 2
	int btear, fd, noname, oflags, rval;
	char *msg;
d669 4
d674 1
a674 1
	if (name == NULL) {
d681 4
a684 6
	if (!LF_ISSET(FS_FORCE) && noname && F_ISSET(frp, FR_RDONLY)) {
		if (LF_ISSET(FS_POSSIBLE))
			msgq(sp, M_ERR,
			    "Read-only file, not written; use ! to override");
		else
			msgq(sp, M_ERR, "Read-only file, not written");
d693 4
a696 5
			if (LF_ISSET(FS_POSSIBLE))
				msgq(sp, M_ERR,
		"%s exists, not written; use ! to override", name);
			else
				msgq(sp, M_ERR, "%s exists, not written", name);
d705 3
a707 5
			if (LF_ISSET(FS_POSSIBLE))
				msgq(sp, M_ERR,
				    "Use ! to write a partial file");
			else
				msgq(sp, M_ERR, "Partial file, not written");
d719 3
a721 9
	 * If the user is overwriting a file other than the original file, and
	 * O_WRITEANY was what got us here (neither force nor append was set),
	 * display the "existing file" messsage.  Since the FR_NAMECHANGE flag
	 * is cleared on a successful write, the message only appears once when
	 * the user changes a file name.  This is historic practice.
	 *
	 * One final test.  If we're not forcing or appending, and we have a
	 * saved modification time, stop the user if it's been written since
	 * we last edited or wrote it, and make them force it.
d724 1
a724 1
		msg = ": new file";
d726 1
a726 1
		msg = "";
d728 9
a736 5
			if (ep->mtime && sb.st_mtime > ep->mtime) {
				msgq(sp, M_ERR,
			"%s: file modified more recently than this copy%s",
				    name, LF_ISSET(FS_POSSIBLE) ?
				    "; use ! to override" : "");
a738 2
			if (!noname || F_ISSET(frp, FR_NAMECHANGE))
				msg = ": existing file";
d742 8
a749 6
	/* Set flags to either append or truncate. */
	oflags = O_CREAT | O_WRONLY;
	if (LF_ISSET(FS_APPEND))
		oflags |= O_APPEND;
	else
		oflags |= O_TRUNC;
d752 24
a775 1
	if ((fd = open(name, oflags, DEFFILEMODE)) < 0) {
d779 1
d781 9
a789 2
	/* Use stdio for buffering. */
	if ((fp = fdopen(fd, "w")) == NULL) {
a790 1
		msgq(sp, M_SYSERR, name);
d799 1
a799 1
		if (file_lline(sp, ep, &to.lno))
d805 1
a805 5
	/* Turn on the busy message. */
	btear = F_ISSET(sp, S_EXSILENT) ? 0 : !busy_on(sp, "Writing...");
	rval = ex_writefp(sp, ep, name, fp, fm, tm, &nlno, &nch);
	if (btear)
		busy_off(sp);
d812 10
a821 1
	ep->mtime = stat(name, &sb) ? 0 : sb.st_mtime;
d823 4
a826 1
	/* If the write failed, complain loudly. */
d829 2
a830 1
			msgq(sp, M_ERR, "%s: WARNING: file truncated!", name);
d848 1
a848 1
		F_CLR(ep, F_MODIFIED);
d856 127
a982 3
	msgq(sp, M_INFO, "%s%s%s: %lu line%s, %lu characters",
	    INTERRUPTED(sp) ? "Interrupted write: " : "",
	    name, msg, nlno, nlno == 1 ? "" : "s", nch);
d984 59
d1044 38
d1088 2
d1092 1
a1092 1
file_m1(sp, ep, force, flags)
a1093 1
	EXF *ep;
d1096 4
d1106 1
a1106 1
	if (F_ISSET(ep, F_MODIFIED))
d1108 1
a1108 2
			if (!force &&
			    file_write(sp, ep, NULL, NULL, NULL, flags))
d1110 4
a1113 4
		} else if (ep->refcnt <= 1 && !force) {
			msgq(sp, M_ERR,
	"File modified since last complete write; write or use %s to override",
			    LF_ISSET(FS_POSSIBLE) ? "!" : ":edit!");
d1117 1
a1117 1
	return (file_m3(sp, ep, force));
d1124 2
d1128 1
a1128 1
file_m2(sp, ep, force)
a1129 1
	EXF *ep;
d1132 4
d1140 1
a1140 1
	if (F_ISSET(ep, F_MODIFIED) && ep->refcnt <= 1 && !force) {
d1142 1
a1142 1
    "File modified since last complete write; write or use ! to override");
d1146 1
a1146 1
	return (file_m3(sp, ep, force));
d1152 2
d1156 1
a1156 1
file_m3(sp, ep, force)
a1157 1
	EXF *ep;
d1160 4
d1171 1
a1171 1
	if (F_ISSET(sp->frp, FR_TMPEXIT) && ep->refcnt <= 1 && !force) {
d1173 1
a1173 1
		    "File is a temporary; exit will discard modifications");
d1180 82
d1264 1
a1264 1
 * 
d1281 2
d1284 3
a1286 2
enum lockt
file_lock(name, fdp, fd, iswrite)
d1288 1
a1288 1
	int fd, *fdp, iswrite;
d1290 4
a1293 2
#if !defined(USE_FCNTL) && defined(LOCK_EX)
					/* Hurrah!  We've got flock(2). */
d1302 8
a1309 5
	return (flock(fd, LOCK_EX | LOCK_NB) ?
	    errno == EAGAIN || errno == EWOULDBLOCK ?
	        LOCK_UNAVAIL : LOCK_FAILED : LOCK_SUCCESS);

#else					/* Gag me.  We've got fcntl(2). */
d1317 7
a1323 2
	
	/* If the file descriptor isn't opened for writing, it must fail. */
d1328 1
a1328 1
			return (LOCK_FAILED);
d1332 1
a1332 1
		
d1351 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
