head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.8
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.18
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.14
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.12
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.10
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.8
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.13;
commitid	01nAnartGL7onLD3;

1.13
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.12;
commitid	ruCZ2IKF0FB0ebCr;

1.12
date	2016.01.20.08.43.27;	author bentley;	state Exp;
branches;
next	1.11;
commitid	etzsUqpfZbRGvPEg;

1.11
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.10;
commitid	adBvXLg05bJxz6yx;

1.10
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	gtDERb7QyXwKGs62;

1.9
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.8;
commitid	06bi6U3x4gFFf2G1;

1.8
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.29.01.58.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.17.58.21;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: mark.c,v 1.12 2016/01/20 08:43:27 bentley Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "common.h"

static LMARK *mark_find(SCR *, CHAR_T);

/*
 * Marks are maintained in a key sorted doubly linked list.  We can't
 * use arrays because we have no idea how big an index key could be.
 * The underlying assumption is that users don't have more than, say,
 * 10 marks at any one time, so this will be is fast enough.
 *
 * Marks are fixed, and modifications to the line don't update the mark's
 * position in the line.  This can be hard.  If you add text to the line,
 * place a mark in that text, undo the addition and use ` to move to the
 * mark, the location will have disappeared.  It's tempting to try to adjust
 * the mark with the changes in the line, but this is hard to do, especially
 * if we've given the line to v_ntext.c:v_ntext() for editing.  Historic vi
 * would move to the first non-blank on the line when the mark location was
 * past the end of the line.  This can be complicated by deleting to a mark
 * that has disappeared using the ` command.  Historic vi treated this as
 * a line-mode motion and deleted the line.  This implementation complains to
 * the user.
 *
 * In historic vi, marks returned if the operation was undone, unless the
 * mark had been subsequently reset.  Tricky.  This is hard to start with,
 * but in the presence of repeated undo it gets nasty.  When a line is
 * deleted, we delete (and log) any marks on that line.  An undo will create
 * the mark.  Any mark creations are noted as to whether the user created
 * it or if it was created by an undo.  The former cannot be reset by another
 * undo, but the latter may.
 *
 * All of these routines translate ABSMARK2 to ABSMARK1.  Setting either of
 * the absolute mark locations sets both, so that "m'" and "m`" work like
 * they, ah, for lack of a better word, "should".
 */

/*
 * mark_init --
 *	Set up the marks.
 *
 * PUBLIC: int mark_init(SCR *, EXF *);
 */
int
mark_init(SCR *sp, EXF *ep)
{
	/*
	 * !!!
	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER.
	 *
	 * Set up the marks.
	 */
	LIST_INIT(&ep->marks);
	return (0);
}

/*
 * mark_end --
 *	Free up the marks.
 *
 * PUBLIC: int mark_end(SCR *, EXF *);
 */
int
mark_end(SCR *sp, EXF *ep)
{
	LMARK *lmp;

	/*
	 * !!!
	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER.
	 */
	while ((lmp = LIST_FIRST(&ep->marks)) != NULL) {
		LIST_REMOVE(lmp, q);
		free(lmp);
	}
	return (0);
}

/*
 * mark_get --
 *	Get the location referenced by a mark.
 *
 * PUBLIC: int mark_get(SCR *, CHAR_T, MARK *, mtype_t);
 */
int
mark_get(SCR *sp, CHAR_T key, MARK *mp, mtype_t mtype)
{
	LMARK *lmp;

	if (key == ABSMARK2)
		key = ABSMARK1;

	lmp = mark_find(sp, key);
	if (lmp == NULL || lmp->name != key) {
		msgq(sp, mtype, "Mark %s: not set", KEY_NAME(sp, key));
                return (1);
	}
	if (F_ISSET(lmp, MARK_DELETED)) {
		msgq(sp, mtype,
		    "Mark %s: the line was deleted", KEY_NAME(sp, key));
                return (1);
	}

	/*
	 * !!!
	 * The absolute mark is initialized to lno 1/cno 0, and historically
	 * you could use it in an empty file.  Make such a mark always work.
	 */
	if ((lmp->lno != 1 || lmp->cno != 0) && !db_exist(sp, lmp->lno)) {
		msgq(sp, mtype,
		    "Mark %s: cursor position no longer exists",
		    KEY_NAME(sp, key));
		return (1);
	}
	mp->lno = lmp->lno;
	mp->cno = lmp->cno;
	return (0);
}

/*
 * mark_set --
 *	Set the location referenced by a mark.
 *
 * PUBLIC: int mark_set(SCR *, CHAR_T, MARK *, int);
 */
int
mark_set(SCR *sp, CHAR_T key, MARK *value, int userset)
{
	LMARK *lmp, *lmt;

	if (key == ABSMARK2)
		key = ABSMARK1;

	/*
	 * The rules are simple.  If the user is setting a mark (if it's a
	 * new mark this is always true), it always happens.  If not, it's
	 * an undo, and we set it if it's not already set or if it was set
	 * by a previous undo.
	 */
	lmp = mark_find(sp, key);
	if (lmp == NULL || lmp->name != key) {
		MALLOC_RET(sp, lmt, sizeof(LMARK));
		if (lmp == NULL) {
			LIST_INSERT_HEAD(&sp->ep->marks, lmt, q);
		} else
			LIST_INSERT_AFTER(lmp, lmt, q);
		lmp = lmt;
	} else if (!userset &&
	    !F_ISSET(lmp, MARK_DELETED) && F_ISSET(lmp, MARK_USERSET))
		return (0);

	lmp->lno = value->lno;
	lmp->cno = value->cno;
	lmp->name = key;
	lmp->flags = userset ? MARK_USERSET : 0;
	return (0);
}

/*
 * mark_find --
 *	Find the requested mark, or, the slot immediately before
 *	where it would go.
 */
static LMARK *
mark_find(SCR *sp, CHAR_T key)
{
	LMARK *lmp, *lastlmp;

	/*
	 * Return the requested mark or the slot immediately before
	 * where it should go.
	 */
	for (lastlmp = NULL, lmp = LIST_FIRST(&sp->ep->marks);
	    lmp != NULL; lastlmp = lmp, lmp = LIST_NEXT(lmp, q))
		if (lmp->name >= key)
			return (lmp->name == key ? lmp : lastlmp);
	return (lastlmp);
}

/*
 * mark_insdel --
 *	Update the marks based on an insertion or deletion.
 *
 * PUBLIC: int mark_insdel(SCR *, lnop_t, recno_t);
 */
int
mark_insdel(SCR *sp, lnop_t op, recno_t lno)
{
	LMARK *lmp;
	recno_t lline;

	switch (op) {
	case LINE_APPEND:
		/* All insert/append operations are done as inserts. */
		abort();
	case LINE_DELETE:
		LIST_FOREACH(lmp, &sp->ep->marks, q)
			if (lmp->lno >= lno) {
				if (lmp->lno == lno) {
					F_SET(lmp, MARK_DELETED);
					(void)log_mark(sp, lmp);
				} else
					--lmp->lno;
			}
		break;
	case LINE_INSERT:
		/*
		 * XXX
		 * Very nasty special case.  If the file was empty, then we're
		 * adding the first line, which is a replacement.  So, we don't
		 * modify the marks.  This is a hack to make:
		 *
		 *	mz:r!echo foo<carriage-return>'z
		 *
		 * work, i.e. historically you could mark the "line" in an empty
		 * file and replace it, and continue to use the mark.  Insane,
		 * well, yes, I know, but someone complained.
		 *
		 * Check for line #2 before going to the end of the file.
		 */
		if (!db_exist(sp, 2)) {
			if (db_last(sp, &lline))
				return (1);
			if (lline == 1)
				return (0);
		}

		LIST_FOREACH(lmp, &sp->ep->marks, q)
			if (lmp->lno >= lno)
				++lmp->lno;
		break;
	case LINE_RESET:
		break;
	}
	return (0);
}
@


1.13
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d26 1
a26 1
static LMARK *mark_find(SCR *, char);
d104 1
a104 1
 * PUBLIC: int mark_get(SCR *, char, MARK *, mtype_t);
d107 1
a107 1
mark_get(SCR *sp, char key, MARK *mp, mtype_t mtype)
d145 1
a145 1
 * PUBLIC: int mark_set(SCR *, char, MARK *, int);
d148 1
a148 1
mark_set(SCR *sp, char key, MARK *value, int userset)
d186 1
a186 1
mark_find(SCR *sp, char key)
@


1.12
log
@Remove ARG_CHAR_T, a relic from when the code was written K&R style.

ok millert@@ schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mark.c,v 1.11 2016/01/06 22:28:52 millert Exp $	*/
d26 1
a26 1
static LMARK *mark_find(SCR *, CHAR_T);
d104 1
a104 1
 * PUBLIC: int mark_get(SCR *, CHAR_T, MARK *, mtype_t);
d107 1
a107 1
mark_get(SCR *sp, CHAR_T key, MARK *mp, mtype_t mtype)
d145 1
a145 1
 * PUBLIC: int mark_set(SCR *, CHAR_T, MARK *, int);
d148 1
a148 1
mark_set(SCR *sp, CHAR_T key, MARK *value, int userset)
d186 1
a186 1
mark_find(SCR *sp, CHAR_T key)
@


1.11
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: mark.c,v 1.10 2015/12/07 20:39:19 mmcc Exp $	*/
d26 1
a26 1
static LMARK *mark_find(SCR *, ARG_CHAR_T);
d104 1
a104 1
 * PUBLIC: int mark_get(SCR *, ARG_CHAR_T, MARK *, mtype_t);
d107 1
a107 1
mark_get(SCR *sp, ARG_CHAR_T key, MARK *mp, mtype_t mtype)
d145 1
a145 1
 * PUBLIC: int mark_set(SCR *, ARG_CHAR_T, MARK *, int);
d148 1
a148 1
mark_set(SCR *sp, ARG_CHAR_T key, MARK *value, int userset)
d186 1
a186 1
mark_find(SCR *sp, ARG_CHAR_T key)
@


1.10
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mark.c,v 1.9 2014/11/12 04:28:41 bentley Exp $	*/
d116 1
a116 1
		msgq(sp, mtype, "017|Mark %s: not set", KEY_NAME(sp, key));
d121 1
a121 1
		    "018|Mark %s: the line was deleted", KEY_NAME(sp, key));
d132 1
a132 1
		    "019|Mark %s: cursor position no longer exists",
@


1.9
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mark.c,v 1.8 2009/10/27 23:59:47 deraadt Exp $	*/
d163 1
a163 1
		MALLOC_RET(sp, lmt, LMARK *, sizeof(LMARK));
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mark.c,v 1.7 2006/01/08 21:05:39 miod Exp $	*/
d66 1
a66 3
mark_init(sp, ep)
	SCR *sp;
	EXF *ep;
d85 1
a85 3
mark_end(sp, ep)
	SCR *sp;
	EXF *ep;
d107 1
a107 5
mark_get(sp, key, mp, mtype)
	SCR *sp;
	ARG_CHAR_T key;
	MARK *mp;
	mtype_t mtype;
d148 1
a148 5
mark_set(sp, key, value, userset)
	SCR *sp;
	ARG_CHAR_T key;
	MARK *value;
	int userset;
d186 1
a186 3
mark_find(sp, key)
	SCR *sp;
	ARG_CHAR_T key;
d208 1
a208 4
mark_insdel(sp, op, lno)
	SCR *sp;
	lnop_t op;
	recno_t lno;
@


1.7
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: mark.c,v 1.6 2005/10/17 19:12:16 otto Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)mark.c	10.13 (Berkeley) 7/19/96";
#endif /* not lint */
@


1.6
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mark.c,v 1.5 2002/02/16 21:27:57 millert Exp $	*/
d240 1
a240 1
			if (lmp->lno >= lno)
d246 1
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mark.c,v 1.4 2001/01/29 01:58:30 niklas Exp $	*/
d101 1
a101 1
	while ((lmp = ep->marks.lh_first) != NULL) {
d212 2
a213 2
	for (lastlmp = NULL, lmp = sp->ep->marks.lh_first;
	    lmp != NULL; lastlmp = lmp, lmp = lmp->q.le_next)
d239 1
a239 2
		for (lmp = sp->ep->marks.lh_first;
		    lmp != NULL; lmp = lmp->q.le_next)
d269 1
a269 2
		for (lmp = sp->ep->marks.lh_first;
		    lmp != NULL; lmp = lmp->q.le_next)
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
a30 1
static LMARK *mark_find __P((SCR *, ARG_CHAR_T));
d67 1
a67 1
 * PUBLIC: int mark_init __P((SCR *, EXF *));
d88 1
a88 1
 * PUBLIC: int mark_end __P((SCR *, EXF *));
d112 1
a112 1
 * PUBLIC: int mark_get __P((SCR *, ARG_CHAR_T, MARK *, mtype_t));
d157 1
a157 1
 * PUBLIC: int mark_set __P((SCR *, ARG_CHAR_T, MARK *, int));
d223 1
a223 1
 * PUBLIC: int mark_insdel __P((SCR *, lnop_t, recno_t));
@


1.3
log
@nvi 1.73
@
text
@d1 2
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)mark.c	10.12 (Berkeley) 3/30/96";
d44 1
a44 1
 * that has disappeared using the ` command.  Historic vi vi treated this as
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)mark.c	8.21 (Berkeley) 8/17/94";
a17 1
#include <sys/time.h>
a21 1
#include <signal.h>
a24 5
#include <termios.h>

#include "compat.h"
#include <db.h>
#include <regex.h>
d26 1
a26 1
#include "vi.h"
d28 1
a28 1
static LMARK *mark_find __P((SCR *, EXF *, ARG_CHAR_T));
d64 2
a71 2
	LMARK *lmp;

d73 4
a76 2
	 * Make sure the marks have been set up.  If they
	 * haven't, do so, and create the absolute mark.
d78 1
a78 6
	MALLOC_RET(sp, lmp, LMARK *, sizeof(LMARK));
	lmp->lno = 1;
	lmp->cno = 0;
	lmp->name = ABSMARK1;
	lmp->flags = 0;
	LIST_INSERT_HEAD(&ep->marks, lmp, q);
d85 2
d95 4
d101 1
a101 1
		FREE(lmp, sizeof(LMARK));
d109 2
d113 1
a113 1
mark_get(sp, ep, key, mp)
a114 1
	EXF *ep;
d117 1
a119 1
	size_t len;
d124 1
a124 1
	lmp = mark_find(sp, ep, key);
d126 1
a126 1
		msgq(sp, M_BERR, "Mark %s: not set", KEY_NAME(sp, key));
d130 2
a131 2
		msgq(sp, M_BERR,
		    "Mark %s: the line was deleted", KEY_NAME(sp, key));
d134 9
a142 3
	if (file_gline(sp, ep, lmp->lno, &len) == NULL ||
	    lmp->cno > len || lmp->cno == len && len != 0) {
		msgq(sp, M_BERR, "Mark %s: cursor position no longer exists",
d154 2
d158 1
a158 1
mark_set(sp, ep, key, value, userset)
a159 1
	EXF *ep;
d175 1
a175 1
	lmp = mark_find(sp, ep, key);
d179 1
a179 1
			LIST_INSERT_HEAD(&ep->marks, lmt, q);
d200 1
a200 1
mark_find(sp, ep, key)
a201 1
	EXF *ep;
d210 1
a210 1
	for (lastlmp = NULL, lmp = ep->marks.lh_first;
d220 2
d223 2
a224 2
void
mark_insdel(sp, ep, op, lno)
d226 1
a226 2
	EXF *ep;
	enum operation op;
d230 1
d234 2
a235 1
		return;
d237 1
a237 1
		for (lmp = ep->marks.lh_first;
d242 1
a242 1
					(void)log_mark(sp, ep, lmp);
d245 1
a245 1
		return;
d247 22
a268 1
		for (lmp = ep->marks.lh_first;
d272 1
a272 1
		return;
d274 1
a274 1
		return;
d276 1
a276 1
	/* NOTREACHED */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
