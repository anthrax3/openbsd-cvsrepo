head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.2
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.25.0.6
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2017.06.12.18.38.57;	author millert;	state Exp;
branches;
next	1.25;
commitid	EVUEEryoKATGrIcZ;

1.25
date	2016.06.29.20.38.39;	author tb;	state Exp;
branches;
next	1.24;
commitid	9W1dSQv4BLnaveAO;

1.24
date	2016.01.30.21.23.50;	author martijn;	state Exp;
branches;
next	1.23;
commitid	coLzsk3wkJh1a1Ez;

1.23
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.22;
commitid	adBvXLg05bJxz6yx;

1.22
date	2015.04.24.21.48.31;	author brynet;	state Exp;
branches;
next	1.21;
commitid	snOxq6D74oYtevTu;

1.21
date	2015.03.27.04.11.25;	author brynet;	state Exp;
branches;
next	1.20;
commitid	xTl6pibBNLW0U9wQ;

1.20
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2014.11.14.20.27.03;	author tedu;	state Exp;
branches;
next	1.18;
commitid	aIZ8ZvbLlUW9obxb;

1.18
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.17;
commitid	T0XpHzXjuQBl1V3E;

1.17
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.16;
commitid	06bi6U3x4gFFf2G1;

1.16
date	2014.11.10.21.31.42;	author tedu;	state Exp;
branches;
next	1.15;
commitid	69Pn8C3VMgeMEZUy;

1.15
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.25.11.37.03;	author sobrado;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.14.14.29.20;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.11.20.50.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.28.19.48.15;	author jaredy;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.02.00.21.16;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.18.21.39.26;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.28.22.41.35;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.01.58.31;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.09.17.17.18.56;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.07.24.16.15.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Use openat() and unlinkat() instead of chdir()ing to the recovery dir.
Since we use flock() and not fcntl() locking we can open the recovery
file read-only.  OK martijn@@
@
text
@/*	$OpenBSD: recover.c,v 1.25 2016/06/29 20:38:39 tb Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>

/*
 * We include <sys/file.h>, because the open #defines were found there
 * on historical systems.  We also include <fcntl.h> because the open(2)
 * #defines are found there on newer systems.
 */
#include <sys/file.h>

#include <bitstring.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "common.h"

/*
 * Recovery code.
 *
 * The basic scheme is as follows.  In the EXF structure, we maintain full
 * paths of a b+tree file and a mail recovery file.  The former is the file
 * used as backing store by the DB package.  The latter is the file that
 * contains an email message to be sent to the user if we crash.  The two
 * simple states of recovery are:
 *
 *	+ first starting the edit session:
 *		the b+tree file exists and is mode 700, the mail recovery
 *		file doesn't exist.
 *	+ after the file has been modified:
 *		the b+tree file exists and is mode 600, the mail recovery
 *		file exists, and is exclusively locked.
 *
 * In the EXF structure we maintain a file descriptor that is the locked
 * file descriptor for the mail recovery file.  NOTE: we sometimes have to
 * do locking with fcntl(2).  This is a problem because if you close(2) any
 * file descriptor associated with the file, ALL of the locks go away.  Be
 * sure to remember that if you have to modify the recovery code.  (It has
 * been rhetorically asked of what the designers could have been thinking
 * when they did that interface.  The answer is simple: they weren't.)
 *
 * To find out if a recovery file/backing file pair are in use, try to get
 * a lock on the recovery file.
 *
 * To find out if a backing file can be deleted at boot time, check for an
 * owner execute bit.  (Yes, I know it's ugly, but it's either that or put
 * special stuff into the backing file itself, or correlate the files at
 * boot time, neither of which looks like fun.)  Note also that there's a
 * window between when the file is created and the X bit is set.  It's small,
 * but it's there.  To fix the window, check for 0 length files as well.
 *
 * To find out if a file can be recovered, check the F_RCV_ON bit.  Note,
 * this DOES NOT mean that any initialization has been done, only that we
 * haven't yet failed at setting up or doing recovery.
 *
 * To preserve a recovery file/backing file pair, set the F_RCV_NORM bit.
 * If that bit is not set when ending a file session:
 *	If the EXF structure paths (rcv_path and rcv_mpath) are not NULL,
 *	they are unlink(2)'d, and free(3)'d.
 *	If the EXF file descriptor (rcv_fd) is not -1, it is closed.
 *
 * The backing b+tree file is set up when a file is first edited, so that
 * the DB package can use it for on-disk caching and/or to snapshot the
 * file.  When the file is first modified, the mail recovery file is created,
 * the backing file permissions are updated, the file is sync(2)'d to disk,
 * and the timer is started.  Then, at RCV_PERIOD second intervals, the
 * b+tree file is synced to disk.  RCV_PERIOD is measured using SIGALRM, which
 * means that the data structures (SCR, EXF, the underlying tree structures)
 * must be consistent when the signal arrives.
 *
 * The recovery mail file contains normal mail headers, with two additions,
 * which occur in THIS order, as the FIRST TWO headers:
 *
 *	X-vi-recover-file: file_name
 *	X-vi-recover-path: recover_path
 *
 * Since newlines delimit the headers, this means that file names cannot have
 * newlines in them, but that's probably okay.  As these files aren't intended
 * to be long-lived, changing their format won't be too painful.
 *
 * Btree files are named "vi.XXXX" and recovery files are named "recover.XXXX".
 */

#define	VI_FHEADER	"X-vi-recover-file: "
#define	VI_PHEADER	"X-vi-recover-path: "

static int	 rcv_copy(SCR *, int, char *);
static void	 rcv_email(SCR *, char *);
static char	*rcv_gets(char *, size_t, int);
static int	 rcv_mailfile(SCR *, int, char *);
static int	 rcv_mktemp(SCR *, char *, char *, int);

/*
 * rcv_tmp --
 *	Build a file name that will be used as the recovery file.
 *
 * PUBLIC: int rcv_tmp(SCR *, EXF *, char *);
 */
int
rcv_tmp(SCR *sp, EXF *ep, char *name)
{
	struct stat sb;
	static int warned = 0;
	int fd;
	char *dp, *p, path[PATH_MAX];

	/*
	 * !!!
	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER.
	 */
	if (opts_empty(sp, O_RECDIR, 0))
		goto err;
	dp = O_STR(sp, O_RECDIR);
	if (stat(dp, &sb)) {
		if (!warned) {
			warned = 1;
			msgq(sp, M_SYSERR, "%s", dp);
			goto err;
		}
		return 1;
	}

	/* Newlines delimit the mail messages. */
	for (p = name; *p; ++p)
		if (*p == '\n') {
			msgq(sp, M_ERR,
		    "Files with newlines in the name are unrecoverable");
			goto err;
		}

	(void)snprintf(path, sizeof(path), "%s/vi.XXXXXXXXXX", dp);
	if ((fd = rcv_mktemp(sp, path, dp, S_IRWXU)) == -1)
		goto err;
	(void)close(fd);

	if ((ep->rcv_path = strdup(path)) == NULL) {
		msgq(sp, M_SYSERR, NULL);
		(void)unlink(path);
err:		msgq(sp, M_ERR,
		    "Modifications not recoverable if the session fails");
		return (1);
	}

	/* We believe the file is recoverable. */
	F_SET(ep, F_RCV_ON);
	return (0);
}

/*
 * rcv_init --
 *	Force the file to be snapshotted for recovery.
 *
 * PUBLIC: int rcv_init(SCR *);
 */
int
rcv_init(SCR *sp)
{
	EXF *ep;
	recno_t lno;

	ep = sp->ep;

	/* Only do this once. */
	F_CLR(ep, F_FIRSTMODIFY);

	/* If we already know the file isn't recoverable, we're done. */
	if (!F_ISSET(ep, F_RCV_ON))
		return (0);

	/* Turn off recoverability until we figure out if this will work. */
	F_CLR(ep, F_RCV_ON);

	/* Test if we're recovering a file, not editing one. */
	if (ep->rcv_mpath == NULL) {
		/* Build a file to mail to the user. */
		if (rcv_mailfile(sp, 0, NULL))
			goto err;

		/* Force a read of the entire file. */
		if (db_last(sp, &lno))
			goto err;

		/* Turn on a busy message, and sync it to backing store. */
		sp->gp->scr_busy(sp,
		    "Copying file for recovery...", BUSY_ON);
		if (ep->db->sync(ep->db, R_RECNOSYNC)) {
			msgq_str(sp, M_SYSERR, ep->rcv_path,
			    "Preservation failed: %s");
			sp->gp->scr_busy(sp, NULL, BUSY_OFF);
			goto err;
		}
		sp->gp->scr_busy(sp, NULL, BUSY_OFF);
	}

	/* Turn off the owner execute bit. */
	(void)chmod(ep->rcv_path, S_IRUSR | S_IWUSR);

	/* We believe the file is recoverable. */
	F_SET(ep, F_RCV_ON);
	return (0);

err:	msgq(sp, M_ERR,
	    "Modifications not recoverable if the session fails");
	return (1);
}

/*
 * rcv_sync --
 *	Sync the file, optionally:
 *		flagging the backup file to be preserved
 *		snapshotting the backup file and send email to the user
 *		sending email to the user if the file was modified
 *		ending the file session
 *
 * PUBLIC: int rcv_sync(SCR *, u_int);
 */
int
rcv_sync(SCR *sp, u_int flags)
{
	EXF *ep;
	int fd, rval;
	char *dp, buf[1024];

	/* Make sure that there's something to recover/sync. */
	ep = sp->ep;
	if (ep == NULL || !F_ISSET(ep, F_RCV_ON))
		return (0);

	/* Sync the file if it's been modified. */
	if (F_ISSET(ep, F_MODIFIED)) {
		if (ep->db->sync(ep->db, R_RECNOSYNC)) {
			F_CLR(ep, F_RCV_ON | F_RCV_NORM);
			msgq_str(sp, M_SYSERR,
			    ep->rcv_path, "File backup failed: %s");
			return (1);
		}

		/* REQUEST: don't remove backing file on exit. */
		if (LF_ISSET(RCV_PRESERVE))
			F_SET(ep, F_RCV_NORM);

		/* REQUEST: send email. */
		if (LF_ISSET(RCV_EMAIL))
			rcv_email(sp, ep->rcv_mpath);
	}

	/*
	 * !!!
	 * Each time the user exec's :preserve, we have to snapshot all of
	 * the recovery information, i.e. it's like the user re-edited the
	 * file.  We copy the DB(3) backing file, and then create a new mail
	 * recovery file, it's simpler than exiting and reopening all of the
	 * underlying files.
	 *
	 * REQUEST: snapshot the file.
	 */
	rval = 0;
	if (LF_ISSET(RCV_SNAPSHOT)) {
		if (opts_empty(sp, O_RECDIR, 0))
			goto err;
		dp = O_STR(sp, O_RECDIR);
		(void)snprintf(buf, sizeof(buf), "%s/vi.XXXXXXXXXX", dp);
		if ((fd = rcv_mktemp(sp, buf, dp, S_IRUSR | S_IWUSR)) == -1)
			goto err;
		sp->gp->scr_busy(sp,
		    "Copying file for recovery...", BUSY_ON);
		if (rcv_copy(sp, fd, ep->rcv_path) ||
		    close(fd) || rcv_mailfile(sp, 1, buf)) {
			(void)unlink(buf);
			(void)close(fd);
			rval = 1;
		}
		sp->gp->scr_busy(sp, NULL, BUSY_OFF);
	}
	if (0) {
err:		rval = 1;
	}

	/* REQUEST: end the file session. */
	if (LF_ISSET(RCV_ENDSESSION) && file_end(sp, NULL, 1))
		rval = 1;

	return (rval);
}

/*
 * rcv_mailfile --
 *	Build the file to mail to the user.
 */
static int
rcv_mailfile(SCR *sp, int issync, char *cp_path)
{
	EXF *ep;
	GS *gp;
	struct passwd *pw;
	size_t len;
	time_t now;
	uid_t uid;
	int fd;
	char *dp, *p, *t, buf[4096], mpath[PATH_MAX];
	char *t1, *t2, *t3;
	char host[HOST_NAME_MAX+1];

	gp = sp->gp;
	if ((pw = getpwuid(uid = getuid())) == NULL) {
		msgq(sp, M_ERR,
		    "Information on user id %u not found", uid);
		return (1);
	}

	if (opts_empty(sp, O_RECDIR, 0))
		return (1);
	dp = O_STR(sp, O_RECDIR);
	(void)snprintf(mpath, sizeof(mpath), "%s/recover.XXXXXXXXXX", dp);
	if ((fd = rcv_mktemp(sp, mpath, dp, S_IRUSR | S_IWUSR)) == -1)
		return (1);

	/*
	 * XXX
	 * We keep an open lock on the file so that the recover option can
	 * distinguish between files that are live and those that need to
	 * be recovered.  There's an obvious window between the mkstemp call
	 * and the lock, but it's pretty small.
	 */
	ep = sp->ep;
	if (file_lock(sp, NULL, NULL, fd, 1) != LOCK_SUCCESS)
		msgq(sp, M_SYSERR, "Unable to lock recovery file");
	if (!issync) {
		/* Save the recover file descriptor, and mail path. */
		ep->rcv_fd = fd;
		if ((ep->rcv_mpath = strdup(mpath)) == NULL) {
			msgq(sp, M_SYSERR, NULL);
			goto err;
		}
		cp_path = ep->rcv_path;
	}

	/*
	 * XXX
	 * We can't use stdio(3) here.  The problem is that we may be using
	 * fcntl(2), so if ANY file descriptor into the file is closed, the
	 * lock is lost.  So, we could never close the FILE *, even if we
	 * dup'd the fd first.
	 */
	t = sp->frp->name;
	if ((p = strrchr(t, '/')) == NULL)
		p = t;
	else
		++p;
	(void)time(&now);
	(void)gethostname(host, sizeof(host));
	len = snprintf(buf, sizeof(buf),
	    "%s%s\n%s%s\n%s\n%s\n%s%s\n%s%s\n%s\n%s\n\n",
	    VI_FHEADER, t,			/* Non-standard. */
	    VI_PHEADER, cp_path,		/* Non-standard. */
	    "Reply-To: root",
	    "From: root (Nvi recovery program)",
	    "To: ", pw->pw_name,
	    "Subject: Nvi saved the file ", p,
	    "Precedence: bulk",			/* For vacation(1). */
	    "Auto-Submitted: auto-generated");
	if (len > sizeof(buf) - 1)
		goto lerr;
	if (write(fd, buf, len) != len)
		goto werr;

	len = snprintf(buf, sizeof(buf),
	    "%s%.24s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n\n",
	    "On ", ctime(&now), ", the user ", pw->pw_name,
	    " was editing a file named ", t, " on the machine ",
	    host, ", when it was saved for recovery. ",
	    "You can recover most, if not all, of the changes ",
	    "to this file using the -r option to ", getprogname(), ":\n\n\t",
	    getprogname(), " -r ", t);
	if (len > sizeof(buf) - 1) {
lerr:		msgq(sp, M_ERR, "Recovery file buffer overrun");
		goto err;
	}

	/*
	 * Format the message.  (Yes, I know it's silly.)
	 * Requires that the message end in a <newline>.
	 */
#define	FMTCOLS	60
	for (t1 = buf; len > 0; len -= t2 - t1, t1 = t2) {
		/* Check for a short length. */
		if (len <= FMTCOLS) {
			t2 = t1 + (len - 1);
			goto wout;
		}

		/* Check for a required <newline>. */
		t2 = strchr(t1, '\n');
		if (t2 - t1 <= FMTCOLS)
			goto wout;

		/* Find the closest space, if any. */
		for (t3 = t2; t2 > t1; --t2)
			if (*t2 == ' ') {
				if (t2 - t1 <= FMTCOLS)
					goto wout;
				t3 = t2;
			}
		t2 = t3;

		/* t2 points to the last character to display. */
wout:		*t2++ = '\n';

		/* t2 points one after the last character to display. */
		if (write(fd, t1, t2 - t1) != t2 - t1)
			goto werr;
	}

	if (issync) {
		rcv_email(sp, mpath);
		if (close(fd)) {
werr:			msgq(sp, M_SYSERR, "Recovery file");
			goto err;
		}
	}
	return (0);

err:	if (!issync)
		ep->rcv_fd = -1;
	if (fd != -1)
		(void)close(fd);
	return (1);
}

/*
 *	people making love
 *	never exactly the same
 *	just like a snowflake
 *
 * rcv_list --
 *	List the files that can be recovered by this user.
 *
 * PUBLIC: int rcv_list(SCR *);
 */
int
rcv_list(SCR *sp)
{
	struct dirent *dp;
	struct stat sb;
	DIR *dirp;
	int fd;
	FILE *fp;
	int found;
	char *p, *t, file[PATH_MAX], path[PATH_MAX];

	/* Open the recovery directory for reading. */
	if (opts_empty(sp, O_RECDIR, 0))
		return (1);
	p = O_STR(sp, O_RECDIR);
	if ((dirp = opendir(p)) == NULL) {
		msgq_str(sp, M_SYSERR, p, "recdir: %s");
		return (1);
	}

	/* Read the directory. */
	for (found = 0; (dp = readdir(dirp)) != NULL;) {
		if (strncmp(dp->d_name, "recover.", 8))
			continue;

		/*
		 * If it's readable, it's recoverable.
		 */
		if ((fd = openat(dirfd(dirp), dp->d_name, O_RDONLY)) == -1)
			continue;

		switch (file_lock(sp, NULL, NULL, fd, 1)) {
		case LOCK_FAILED:
			/*
			 * XXX
			 * Assume that a lock can't be acquired, but that we
			 * should permit recovery anyway.  If this is wrong,
			 * and someone else is using the file, we're going to
			 * die horribly.
			 */
			break;
		case LOCK_SUCCESS:
			break;
		case LOCK_UNAVAIL:
			/* If it's locked, it's live. */
			close(fd);
			continue;
		}

		/* Check the headers. */
		if ((fp = fdopen(fd, "r")) == NULL) {
			close(fd);
			continue;
		}
		if (fgets(file, sizeof(file), fp) == NULL ||
		    strncmp(file, VI_FHEADER, sizeof(VI_FHEADER) - 1) ||
		    (p = strchr(file, '\n')) == NULL ||
		    fgets(path, sizeof(path), fp) == NULL ||
		    strncmp(path, VI_PHEADER, sizeof(VI_PHEADER) - 1) ||
		    (t = strchr(path, '\n')) == NULL) {
			msgq_str(sp, M_ERR, dp->d_name,
			    "%s: malformed recovery file");
			goto next;
		}
		*p = *t = '\0';

		/*
		 * If the file doesn't exist, it's an orphaned recovery file,
		 * toss it.
		 *
		 * XXX
		 * This can occur if the backup file was deleted and we crashed
		 * before deleting the email file.
		 */
		errno = 0;
		if (stat(path + sizeof(VI_PHEADER) - 1, &sb) &&
		    errno == ENOENT) {
			(void)unlinkat(dirfd(dirp), dp->d_name, 0);
			goto next;
		}

		/* Get the last modification time and display. */
		(void)fstat(fd, &sb);
		(void)printf("%.24s: %s\n",
		    ctime(&sb.st_mtime), file + sizeof(VI_FHEADER) - 1);
		found = 1;

		/* Close, discarding lock. */
next:		(void)fclose(fp);
	}
	if (found == 0)
		(void)printf("%s: No files to recover\n", getprogname());
	(void)closedir(dirp);
	return (0);
}

/*
 * rcv_read --
 *	Start a recovered file as the file to edit.
 *
 * PUBLIC: int rcv_read(SCR *, FREF *);
 */
int
rcv_read(SCR *sp, FREF *frp)
{
	struct dirent *dp;
	struct stat sb;
	DIR *dirp;
	EXF *ep;
	struct timespec rec_mtim;
	int fd, found, locked, requested, sv_fd;
	char *name, *p, *t, *rp, *recp, *pathp;
	char file[PATH_MAX], path[PATH_MAX], recpath[PATH_MAX];

	if (opts_empty(sp, O_RECDIR, 0))
		return (1);
	rp = O_STR(sp, O_RECDIR);
	if ((dirp = opendir(rp)) == NULL) {
		msgq_str(sp, M_SYSERR, rp, "%s");
		return (1);
	}

	name = frp->name;
	sv_fd = -1;
	rec_mtim.tv_sec = rec_mtim.tv_nsec = 0;
	recp = pathp = NULL;
	for (found = requested = 0; (dp = readdir(dirp)) != NULL;) {
		if (strncmp(dp->d_name, "recover.", 8))
			continue;
		(void)snprintf(recpath,
		    sizeof(recpath), "%s/%s", rp, dp->d_name);

		/*
		 * If it's readable, it's recoverable.  It would be very
		 * nice to use stdio(3), but, we can't because that would
		 * require closing and then reopening the file so that we
		 * could have a lock and still close the FP.  Another tip
		 * of the hat to fcntl(2).
		 *
		 * XXX
		 * Should be O_RDONLY, we don't want to write it.  However,
		 * if we're using fcntl(2), there's no way to lock a file
		 * descriptor that's not open for writing.
		 */
		if ((fd = open(recpath, O_RDWR, 0)) == -1)
			continue;

		switch (file_lock(sp, NULL, NULL, fd, 1)) {
		case LOCK_FAILED:
			/*
			 * XXX
			 * Assume that a lock can't be acquired, but that we
			 * should permit recovery anyway.  If this is wrong,
			 * and someone else is using the file, we're going to
			 * die horribly.
			 */
			locked = 0;
			break;
		case LOCK_SUCCESS:
			locked = 1;
			break;
		case LOCK_UNAVAIL:
			/* If it's locked, it's live. */
			(void)close(fd);
			continue;
		}

		/* Check the headers. */
		if (rcv_gets(file, sizeof(file), fd) == NULL ||
		    strncmp(file, VI_FHEADER, sizeof(VI_FHEADER) - 1) ||
		    (p = strchr(file, '\n')) == NULL ||
		    rcv_gets(path, sizeof(path), fd) == NULL ||
		    strncmp(path, VI_PHEADER, sizeof(VI_PHEADER) - 1) ||
		    (t = strchr(path, '\n')) == NULL) {
			msgq_str(sp, M_ERR, recpath,
			    "%s: malformed recovery file");
			goto next;
		}
		*p = *t = '\0';
		++found;

		/*
		 * If the file doesn't exist, it's an orphaned recovery file,
		 * toss it.
		 *
		 * XXX
		 * This can occur if the backup file was deleted and we crashed
		 * before deleting the email file.
		 */
		errno = 0;
		if (stat(path + sizeof(VI_PHEADER) - 1, &sb) &&
		    errno == ENOENT) {
			(void)unlink(dp->d_name);
			goto next;
		}

		/* Check the file name. */
		if (strcmp(file + sizeof(VI_FHEADER) - 1, name))
			goto next;

		++requested;

		/*
		 * If we've found more than one, take the most recent.
		 */
		(void)fstat(fd, &sb);
		if (recp == NULL ||
		    timespeccmp(&rec_mtim, &sb.st_mtim, <)) {
			p = recp;
			t = pathp;
			if ((recp = strdup(recpath)) == NULL) {
				msgq(sp, M_SYSERR, NULL);
				recp = p;
				goto next;
			}
			if ((pathp = strdup(path)) == NULL) {
				msgq(sp, M_SYSERR, NULL);
				free(recp);
				recp = p;
				pathp = t;
				goto next;
			}
			if (p != NULL) {
				free(p);
				free(t);
			}
			rec_mtim = sb.st_mtim;
			if (sv_fd != -1)
				(void)close(sv_fd);
			sv_fd = fd;
		} else
next:			(void)close(fd);
	}
	(void)closedir(dirp);

	if (recp == NULL) {
		msgq_str(sp, M_INFO, name,
		    "No files named %s, readable by you, to recover");
		return (1);
	}
	if (found) {
		if (requested > 1)
			msgq(sp, M_INFO,
	    "There are older versions of this file for you to recover");
		if (found > requested)
			msgq(sp, M_INFO,
			    "There are other files for you to recover");
	}

	/*
	 * Create the FREF structure, start the btree file.
	 *
	 * XXX
	 * file_init() is going to set ep->rcv_path.
	 */
	if (file_init(sp, frp, pathp + sizeof(VI_PHEADER) - 1, 0)) {
		free(recp);
		free(pathp);
		(void)close(sv_fd);
		return (1);
	}

	/*
	 * We keep an open lock on the file so that the recover option can
	 * distinguish between files that are live and those that need to
	 * be recovered.  The lock is already acquired, just copy it.
	 */
	ep = sp->ep;
	ep->rcv_mpath = recp;
	ep->rcv_fd = sv_fd;
	if (!locked)
		F_SET(frp, FR_UNLOCKED);

	/* We believe the file is recoverable. */
	F_SET(ep, F_RCV_ON);
	return (0);
}

/*
 * rcv_copy --
 *	Copy a recovery file.
 */
static int
rcv_copy(SCR *sp, int wfd, char *fname)
{
	int nr, nw, off, rfd;
	char buf[8 * 1024];

	if ((rfd = open(fname, O_RDONLY, 0)) == -1)
		goto err;
	while ((nr = read(rfd, buf, sizeof(buf))) > 0)
		for (off = 0; nr; nr -= nw, off += nw)
			if ((nw = write(wfd, buf + off, nr)) < 0)
				goto err;
	if (nr == 0)
		return (0);

err:	msgq_str(sp, M_SYSERR, fname, "%s");
	return (1);
}

/*
 * rcv_gets --
 *	Fgets(3) for a file descriptor.
 */
static char *
rcv_gets(char *buf, size_t len, int fd)
{
	int nr;
	char *p;

	if ((nr = read(fd, buf, len - 1)) == -1)
		return (NULL);
	buf[nr] = '\0';
	if ((p = strchr(buf, '\n')) == NULL)
		return (NULL);
	(void)lseek(fd, (off_t)((p - buf) + 1), SEEK_SET);
	return (buf);
}

/*
 * rcv_mktemp --
 *	Paranoid make temporary file routine.
 */
static int
rcv_mktemp(SCR *sp, char *path, char *dname, int perms)
{
	int fd;

	/*
	 * !!!
	 * We expect mkstemp(3) to set the permissions correctly.  On
	 * historic System V systems, mkstemp didn't.  Do it here, on
	 * GP's.  This also protects us from users with stupid umasks.
	 *
	 * XXX
	 * The variable perms should really be a mode_t.
	 */
	if ((fd = mkstemp(path)) == -1 || fchmod(fd, perms) == -1) {
		msgq_str(sp, M_SYSERR, dname, "%s");
		if (fd != -1) {
			close(fd);
			unlink(path);
			fd = -1;
		}
	}
	return (fd);
}

/*
 * rcv_email --
 *	Send email.
 */
static void
rcv_email(SCR *sp, char *fname)
{
	struct stat sb;
	char buf[PATH_MAX * 2 + 20];

	if (_PATH_SENDMAIL[0] != '/' || stat(_PATH_SENDMAIL, &sb))
		msgq_str(sp, M_SYSERR,
		    _PATH_SENDMAIL, "not sending email: %s");
	else {
		/*
		 * !!!
		 * If you need to port this to a system that doesn't have
		 * sendmail, the -t flag causes sendmail to read the message
		 * for the recipients instead of specifying them some other
		 * way.
		 */
		(void)snprintf(buf, sizeof(buf),
		    "%s -t < %s", _PATH_SENDMAIL, fname);
		(void)system(buf);
	}
}
@


1.25
log
@If /tmp/vi.recover doesn't exist, don't create it. Warn once
that it doesn't exist, afterwards fail silently.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.24 2016/01/30 21:23:50 martijn Exp $	*/
d468 1
d477 1
a477 1
	if (chdir(p) || (dirp = opendir(".")) == NULL) {
a488 5
		 *
		 * XXX
		 * Should be "r", we don't want to write the file.  However,
		 * if we're using fcntl(2), there's no way to lock a file
		 * descriptor that's not open for writing.
d490 1
a490 1
		if ((fp = fopen(dp->d_name, "r+")) == NULL)
d493 1
a493 1
		switch (file_lock(sp, NULL, NULL, fileno(fp), 1)) {
d507 1
a507 1
			(void)fclose(fp);
d512 4
d539 1
a539 1
			(void)unlink(dp->d_name);
d544 1
a544 1
		(void)fstat(fileno(fp), &sb);
@


1.24
log
@replace progname variable in gs structure with getprogname

OK zhuk@@ and tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.23 2016/01/06 22:28:52 millert Exp $	*/
d125 1
a131 7
	 *
	 *
	 * If the recovery directory doesn't exist, try and create it.  As
	 * the recovery files are themselves protected from reading/writing
	 * by other than the owner, the worst that can happen is that a user
	 * would have permission to remove other user's recovery files.  If
	 * the sticky bit has the BSD semantics, that too will be impossible.
d137 2
a138 1
		if (errno != ENOENT || mkdir(dp, 0)) {
d142 1
a142 1
		(void)chmod(dp, S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX);
@


1.23
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.22 2015/04/24 21:48:31 brynet Exp $	*/
d400 2
a401 2
	    "to this file using the -r option to ", gp->progname, ":\n\n\t",
	    gp->progname, " -r ", t);
d558 1
a558 1
		(void)printf("%s: No files to recover\n", sp->gp->progname);
@


1.22
log
@struct timespec/clock_gettime(3) conversion for vi(1).

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.21 2015/03/27 04:11:25 brynet Exp $	*/
d154 1
a154 1
		    "055|Files with newlines in the name are unrecoverable");
d167 1
a167 1
		    "056|Modifications not recoverable if the session fails");
d212 1
a212 1
		    "057|Copying file for recovery...", BUSY_ON);
d215 1
a215 1
			    "058|Preservation failed: %s");
d230 1
a230 1
	    "059|Modifications not recoverable if the session fails");
d261 1
a261 1
			    ep->rcv_path, "060|File backup failed: %s");
d293 1
a293 1
		    "061|Copying file for recovery...", BUSY_ON);
d334 1
a334 1
		    "062|Information on user id %u not found", uid);
d354 1
a354 1
		msgq(sp, M_SYSERR, "063|Unable to lock recovery file");
d403 1
a403 1
lerr:		msgq(sp, M_ERR, "064|Recovery file buffer overrun");
d444 1
a444 1
werr:			msgq(sp, M_SYSERR, "065|Recovery file");
d528 1
a528 1
			    "066|%s: malformed recovery file");
d642 1
a642 1
			    "067|%s: malformed recovery file");
d704 1
a704 1
		    "068|No files named %s, readable by you, to recover");
d710 1
a710 1
	    "069|There are older versions of this file for you to recover");
d713 1
a713 1
			    "070|There are other files for you to recover");
d828 1
a828 1
		    _PATH_SENDMAIL, "071|not sending email: %s");
@


1.21
log
@Some vi cleanup, unifdef's some signal blocking code that has never been
enabled in our tree, also removes some stragglers from a global struct
referencing nonexistent Tcl/TK and "IP support". And finally.. deletes
an empty file missed by earlier cleanup by bentley@@.

Inspired by and ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.20 2015/01/16 06:40:14 deraadt Exp $	*/
d16 1
d576 1
a576 1
	time_t rec_mtime;
d591 1
a591 1
	rec_mtime = 0;
a670 5
		 *
		 * XXX
		 * Since we're using st_mtime, for portability reasons,
		 * we only get a single second granularity, instead of
		 * getting it right.
d673 2
a674 1
		if (recp == NULL || rec_mtime < sb.st_mtime) {
d693 1
a693 1
			rec_mtime = sb.st_mtime;
@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.19 2014/11/14 20:27:03 tedu Exp $	*/
a256 1
		SIGBLOCK;
a260 1
			SIGUNBLOCK;
a262 1
		SIGUNBLOCK;
@


1.19
log
@from natano:
_PATH_BSHELL, _PATH_SENDMAIL, _PATH_TMP and _PATH_TTY are defined in
<paths.h> and _PATH_SYSV_TTY is unused. All of them can be removed from
pathnames.h. The other defines can be made unconditionally.
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.18 2014/11/12 16:29:04 millert Exp $	*/
a13 1
#include <sys/param.h>
d125 1
a125 1
	char *dp, *p, path[MAXPATHLEN];
d329 1
a329 1
	char *dp, *p, *t, buf[4096], mpath[MAXPATHLEN];
d331 1
a331 1
	char host[MAXHOSTNAMELEN];
d477 1
a477 1
	char *p, *t, file[MAXPATHLEN], path[MAXPATHLEN];
d581 1
a581 1
	char file[MAXPATHLEN], path[MAXPATHLEN], recpath[MAXPATHLEN];
d830 1
a830 1
	char buf[MAXPATHLEN * 2 + 20];
@


1.18
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.17 2014/11/12 04:28:41 bentley Exp $	*/
d30 1
a38 1
#include "pathnames.h"
@


1.17
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.16 2014/11/10 21:31:42 tedu Exp $	*/
a14 1
#include <sys/types.h>		/* XXX: param.h may not have included types.h */
@


1.16
log
@remove old, unnecessary compat code. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.15 2009/10/27 23:59:47 deraadt Exp $	*/
d123 1
a123 4
rcv_tmp(sp, ep, name)
	SCR *sp;
	EXF *ep;
	char *name;
d184 1
a184 2
rcv_init(sp)
	SCR *sp;
d246 1
a246 3
rcv_sync(sp, flags)
	SCR *sp;
	u_int flags;
d322 1
a322 4
rcv_mailfile(sp, issync, cp_path)
	SCR *sp;
	int issync;
	char *cp_path;
d472 1
a472 2
rcv_list(sp)
	SCR *sp;
d574 1
a574 3
rcv_read(sp, frp)
	SCR *sp;
	FREF *frp;
d758 1
a758 4
rcv_copy(sp, wfd, fname)
	SCR *sp;
	int wfd;
	char *fname;
d781 1
a781 4
rcv_gets(buf, len, fd)
	char *buf;
	size_t len;
	int fd;
d800 1
a800 4
rcv_mktemp(sp, path, dname, perms)
	SCR *sp;
	char *path, *dname;
	int perms;
d829 1
a829 3
rcv_email(sp, fname)
	SCR *sp;
	char *fname;
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.14 2008/09/25 11:37:03 sobrado Exp $	*/
a341 9

	/*
	 * XXX
	 * MAXHOSTNAMELEN is in various places on various systems, including
	 * <netdb.h> and <sys/socket.h>.  If not found, use a large default.
	 */
#ifndef MAXHOSTNAMELEN
#define	MAXHOSTNAMELEN	1024
#endif
@


1.14
log
@do not hardcode the editor name in the message displayed by "-r"
when there are no files to recover as this flag is used by ex(1)
and view(1) too.

problem found by jsing@@,  Sven Verdoolaege did some suggestions
to improve its portability.

diff committed upstream.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.13 2007/09/14 14:29:20 chl Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)recover.c	10.21 (Berkeley) 9/15/96";
#endif /* not lint */
@


1.13
log
@remove some warnings:
unused variable `variable'
`variable' might be used uninitialized in this function

ok gilles@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.12 2007/09/11 15:47:17 gilles Exp $	*/
d585 1
a585 1
		(void)printf("vi: no files to recover.\n");
@


1.12
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.11 2006/12/11 20:50:55 deraadt Exp $	*/
d820 2
a821 1
	buf[strcspn(buf, "\n")] = '\0';
@


1.11
log
@rfc 3834 support: Auto-Submitted: auto-generated on lots of things; from Tamas TEVESZ; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.10 2006/04/28 19:48:15 jaredy Exp $	*/
d820 1
a820 2
	if ((p = strchr(buf, '\n')) == NULL)
		return (NULL);
@


1.10
log
@ensure NUL termination after read(); ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.9 2003/07/02 00:21:16 avsm Exp $	*/
d406 1
a406 1
	    "%s%s\n%s%s\n%s\n%s\n%s%s\n%s%s\n%s\n\n",
d413 2
a414 1
	    "Precedence: bulk");		/* For vacation(1). */
@


1.9
log
@bump randomness of mktemp to from 6 to 10 X's, as recommended by mktemp(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.8 2002/02/16 21:27:57 millert Exp $	*/
d818 1
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.7 2001/06/18 21:39:26 millert Exp $	*/
d166 1
a166 1
	(void)snprintf(path, sizeof(path), "%s/vi.XXXXXX", dp);
d303 1
a303 1
		(void)snprintf(buf, sizeof(buf), "%s/vi.XXXXXX", dp);
d367 1
a367 1
	(void)snprintf(mpath, sizeof(mpath), "%s/recover.XXXXXX", dp);
@


1.7
log
@When creating temp files, use fchmod() to set the perms to be what we
expect since the mode mkstemp() uses can be modified by the umask.
This fixes a problem where vi would spin trying to create temp
files, eating up inodes; reported by xyntrix@@bitz.org

This fix has the side effect of letting you create files with
silly modes (like 0000), but that is probably OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.6 2001/05/28 22:41:35 pvalchev Exp $	*/
d114 5
a118 5
static int	 rcv_copy __P((SCR *, int, char *));
static void	 rcv_email __P((SCR *, char *));
static char	*rcv_gets __P((char *, size_t, int));
static int	 rcv_mailfile __P((SCR *, int, char *));
static int	 rcv_mktemp __P((SCR *, char *, char *, int));
d124 1
a124 1
 * PUBLIC: int rcv_tmp __P((SCR *, EXF *, char *));
d188 1
a188 1
 * PUBLIC: int rcv_init __P((SCR *));
d251 1
a251 1
 * PUBLIC: int rcv_sync __P((SCR *, u_int));
d490 1
a490 1
 * PUBLIC: int rcv_list __P((SCR *));
d593 1
a593 1
 * PUBLIC: int rcv_read __P((SCR *, FREF *));
@


1.6
log
@Print SYSERR instead of ERR when recdir does not exist.
Makes the message more useful for the user; from NetBSD, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: recover.c,v 1.5 2001/01/29 01:58:31 niklas Exp $	*/
d840 1
a840 1
	 * GP's.
d843 1
a843 2
	 * The variable perms should really be a mode_t, and it would
	 * be nice to use fchmod(2) instead of chmod(2), here.
d845 1
a845 1
	if ((fd = mkstemp(path)) == -1)
d847 6
a852 2
	else
		(void)chmod(path, perms);
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d613 1
a613 1
		msgq_str(sp, M_ERR, rp, "%s");
@


1.4
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d1 2
@


1.3
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)recover.c	10.20 (Berkeley) 6/20/96";
a33 1
#include <signal.h>
@


1.2
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)recover.c	10.18 (Berkeley) 5/15/96";
d38 1
d337 1
d356 1
d409 1
a409 1
	    "From: root (Vi recovery program)",
d411 1
a411 1
	    "Subject: Vi saved the file ", p,
d418 2
a419 1
	len = snprintf(buf, sizeof(buf), "%s%.24s%s%s%s%s%s%s%s%s%s%s%s\n\n",
d424 2
a425 2
	    "to this file using the -r option to ex or vi:\n\n",
	    "\tvi -r ", t);
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
a7 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d10 2
d13 1
a13 1
static char sccsid[] = "@@(#)recover.c	8.74 (Berkeley) 8/17/94";
d17 1
a19 1
#include <sys/time.h>
a27 2
#include <netdb.h>		/* MAXHOSTNAMELEN on some systems. */

a37 1
#include <termios.h>
d40 2
a41 6
#include "compat.h"
#include <db.h>
#include <regex.h>
#include <pathnames.h>

#include "vi.h"
d73 1
a73 1
 * boot time, neither or which looks like fun.)  Note also that there's a
d115 1
a115 1
static int	 rcv_mailfile __P((SCR *, EXF *, int, char *));
d121 2
d135 4
d145 2
d160 1
a160 1
		    "Files with newlines in the name are unrecoverable");
d173 1
a173 1
		    "Modifications not recoverable if the session fails");
d185 2
d189 1
a189 1
rcv_init(sp, ep)
d191 1
a192 1
{
d194 2
a195 1
	int btear;
d210 1
a210 1
		if (rcv_mailfile(sp, ep, 0, NULL))
d214 1
a214 1
		if (file_lline(sp, ep, &lno))
d218 2
a219 2
		btear = F_ISSET(sp, S_EXSILENT) ? 0 :
		    !busy_on(sp, "Copying file for recovery...");
d221 3
a223 4
			msgq(sp, M_ERR, "Preservation failed: %s: %s",
			    ep->rcv_path, strerror(errno));
			if (btear)
				busy_off(sp);
d226 1
a226 9
		if (btear)
			busy_off(sp);
	}

	/* Turn on the recovery timer, if it's not yet running. */
	if (!F_ISSET(sp->gp, G_RECOVER_SET) && rcv_on(sp, ep)) {
err:		msgq(sp, M_ERR,
		    "Modifications not recoverable if the session fails");
		return (1);
d235 4
d248 2
d252 1
a252 1
rcv_sync(sp, ep, flags)
a253 1
	EXF *ep;
d256 2
a257 1
	int btear, fd, rval;
d261 1
d267 1
d270 3
a272 2
			msgq(sp, M_SYSERR,
			    "File backup failed: %s", ep->rcv_path);
d275 1
d298 2
a299 2
		btear = F_ISSET(sp, S_EXSILENT) ? 0 :
		    !busy_on(sp, "Copying file for recovery...");
d303 7
a309 7
			goto e1;
		if (rcv_copy(sp, fd, ep->rcv_path) || close(fd))
			goto e2;
		if (rcv_mailfile(sp, ep, 1, buf)) {
e2:			(void)unlink(buf);
e1:			if (fd != -1)
				(void)close(fd);
d312 4
a315 2
		if (btear)
			busy_off(sp);
d319 1
a319 1
	if (LF_ISSET(RCV_ENDSESSION) && file_end(sp, ep, 1))
d330 1
a330 1
rcv_mailfile(sp, ep, issync, cp_path)
a331 1
	EXF *ep;
d335 1
d341 1
a341 1
	char *dp, *p, *t, buf[4096], host[MAXHOSTNAMELEN], mpath[MAXPATHLEN];
d344 10
d355 2
a356 1
		msgq(sp, M_ERR, "Information on user id %u not found", uid);
d360 2
d374 3
a376 2
	if (file_lock(NULL, NULL, fd, 1) != LOCK_SUCCESS)
		msgq(sp, M_SYSERR, "Unable to lock recovery file");
d423 1
a423 1
lerr:		msgq(sp, M_ERR, "recovery file buffer overrun");
d457 8
a464 2
		if (write(fd, t1, t2 - t1) != t2 - t1) {
werr:			msgq(sp, M_SYSERR, "recovery file");
a467 4

	if (issync)
		rcv_email(sp, mpath);

d484 2
d498 6
a503 7
	/*
	 * XXX
	 * Messages aren't yet set up.
	 */
	if (chdir(O_STR(sp, O_RECDIR)) || (dirp = opendir(".")) == NULL) {
		(void)fprintf(stderr,
		    "vi: %s: %s\n", O_STR(sp, O_RECDIR), strerror(errno));
d507 1
d523 1
a523 1
		switch (file_lock(NULL, NULL, fileno(fp), 1)) {
d548 2
a549 2
			msgq(sp, M_ERR,
			    "%s: malformed recovery file", dp->d_name);
d571 2
a572 2
		(void)printf("%s: %s",
		    file + sizeof(VI_FHEADER) - 1, ctime(&sb.st_mtime));
d587 2
d601 1
a601 1
	char *name, *p, *t, *recp, *pathp;
d604 5
a608 3
	if ((dirp = opendir(O_STR(sp, O_RECDIR))) == NULL) {
		msgq(sp, M_ERR,
		    "%s: %s", O_STR(sp, O_RECDIR), strerror(errno));
d619 2
a620 2
		(void)snprintf(recpath, sizeof(recpath),
		    "%s/%s", O_STR(sp, O_RECDIR), dp->d_name);
d637 1
a637 1
		switch (file_lock(NULL, NULL, fd, 1)) {
d664 2
a665 2
			msgq(sp, M_ERR,
			    "%s: malformed recovery file", recpath);
d705 1
a705 2
				msgq(sp, M_ERR,
				    "vi: Error: %s.\n", strerror(errno));
d710 2
a711 3
				msgq(sp, M_ERR,
				    "vi: Error: %s.\n", strerror(errno));
				FREE(recp, strlen(recp) + 1);
d717 2
a718 2
				FREE(p, strlen(p) + 1);
				FREE(t, strlen(t) + 1);
d730 2
a731 2
		msgq(sp, M_INFO,
		    "No files named %s, readable by you, to recover", name);
d737 1
a737 1
		   "There are older versions of this file for you to recover");
d740 1
a740 1
			    "There are other files for you to recover");
d794 1
a794 1
err:	msgq(sp, M_SYSERR, "%s", fname);
d808 1
a808 1
	ssize_t nr;
d842 1
a842 1
		msgq(sp, M_SYSERR, "%s", dname);
d860 3
a862 2
	if (stat(_PATH_SENDMAIL, &sb))
		msgq(sp, M_SYSERR, "not sending email: %s", _PATH_SENDMAIL);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
