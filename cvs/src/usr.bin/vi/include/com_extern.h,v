head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.2
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.5.0.54
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.52
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.48
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.46
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.44
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.42
	OPENBSD_5_0:1.5.0.40
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.38
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.36
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.32
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.34
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.30
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.28
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.26
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.24
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.22
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.20
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.18
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.16
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.14
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.14
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.12
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.07.03.07.01.14;	author bentley;	state Exp;
branches;
next	1.14;
commitid	EvNQUli77WiHPwr6;

1.14
date	2016.05.27.09.18.12;	author martijn;	state Exp;
branches;
next	1.13;
commitid	01nAnartGL7onLD3;

1.13
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.12;
commitid	ruCZ2IKF0FB0ebCr;

1.12
date	2016.01.30.21.31.08;	author martijn;	state Exp;
branches;
next	1.11;
commitid	zLPqRo5te1vGR4dO;

1.11
date	2016.01.20.08.43.27;	author bentley;	state Exp;
branches;
next	1.10;
commitid	etzsUqpfZbRGvPEg;

1.10
date	2016.01.06.22.35.29;	author millert;	state Exp;
branches;
next	1.9;
commitid	n3rGwyN2fSlabXu9;

1.9
date	2016.01.06.22.29.38;	author millert;	state Exp;
branches;
next	1.8;
commitid	RiORzAsItDrPYyBm;

1.8
date	2016.01.06.22.27.40;	author millert;	state Exp;
branches;
next	1.7;
commitid	WTL2xUDqwK7LLJKC;

1.7
date	2014.11.20.08.50.53;	author bentley;	state Exp;
branches;
next	1.6;
commitid	DAfFYTGOAzdEQS6z;

1.6
date	2014.11.10.21.40.11;	author tedu;	state Exp;
branches;
next	1.5;
commitid	XlFK1Ymau5jKpy9T;

1.5
date	2002.02.17.19.42.34;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.01.58.47;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.07.27.22.28.20;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.10.16.02.26.04;	author michaels;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove settings that were unimplemented for 20 years; update STANDARDS.

ok jmc@@ natano@@
@
text
@/*	$OpenBSD: com_extern.h,v 1.14 2016/05/27 09:18:12 martijn Exp $	*/

int cut(SCR *, CHAR_T *, MARK *, MARK *, int);
int cut_line(SCR *, recno_t, size_t, size_t, CB *);
void cut_close(GS *);
TEXT *text_init(SCR *, const char *, size_t, size_t);
void text_lfree(TEXTH *);
void text_free(TEXT *);
int del(SCR *, MARK *, MARK *, int);
FREF *file_add(SCR *, CHAR_T *);
int file_init(SCR *, FREF *, char *, int);
int file_end(SCR *, EXF *, int);
int file_write(SCR *, MARK *, MARK *, char *, int);
int file_m1(SCR *, int, int);
int file_m2(SCR *, int);
int file_m3(SCR *, int);
int file_aw(SCR *, int);
void set_alt_name(SCR *, char *);
lockr_t file_lock(SCR *, char *, int *, int, int);
int v_key_init(SCR *);
void v_key_ilookup(SCR *);
size_t v_key_len(SCR *, CHAR_T);
CHAR_T *v_key_name(SCR *, CHAR_T);
int v_key_val(SCR *, CHAR_T);
int v_event_push(SCR *, EVENT *, CHAR_T *, size_t, u_int);
int v_event_get(SCR *, EVENT *, int, u_int32_t);
void v_event_err(SCR *, EVENT *);
int v_event_flush(SCR *, u_int);
int db_eget(SCR *, recno_t, char **, size_t *, int *);
int db_get(SCR *, recno_t, u_int32_t, char **, size_t *);
int db_delete(SCR *, recno_t);
int db_append(SCR *, int, recno_t, char *, size_t);
int db_insert(SCR *, recno_t, char *, size_t);
int db_set(SCR *, recno_t, char *, size_t);
int db_exist(SCR *, recno_t);
int db_last(SCR *, recno_t *);
void db_err(SCR *, recno_t);
int log_init(SCR *, EXF *);
int log_end(SCR *, EXF *);
int log_cursor(SCR *);
int log_line(SCR *, recno_t, u_int);
int log_mark(SCR *, LMARK *);
int log_backward(SCR *, MARK *);
int log_setline(SCR *);
int log_forward(SCR *, MARK *);
int editor(GS *, int, char *[]);
void v_end(GS *);
int mark_init(SCR *, EXF *);
int mark_end(SCR *, EXF *);
int mark_get(SCR *, CHAR_T, MARK *, mtype_t);
int mark_set(SCR *, CHAR_T, MARK *, int);
int mark_insdel(SCR *, lnop_t, recno_t);
void msgq(SCR *, mtype_t, const char *, ...);
void msgq_str(SCR *, mtype_t, char *, char *);
void mod_rpt(SCR *);
void msgq_status(SCR *, recno_t, u_int);
const char *msg_cmsg(SCR *, cmsg_t, size_t *);
char *msg_print(SCR *, const char *, int *);
int opts_init(SCR *, int *);
int opts_set(SCR *, ARGS *[], char *);
int o_set(SCR *, int, u_int, char *, u_long);
int opts_empty(SCR *, int, int);
void opts_dump(SCR *, enum optdisp);
int opts_save(SCR *, FILE *);
OPTLIST const *opts_search(char *);
void opts_nomatch(SCR *, char *);
int opts_copy(SCR *, SCR *);
void opts_free(SCR *);
int f_altwerase(SCR *, OPTION *, char *, u_long *);
int f_columns(SCR *, OPTION *, char *, u_long *);
int f_lines(SCR *, OPTION *, char *, u_long *);
int f_paragraph(SCR *, OPTION *, char *, u_long *);
int f_print(SCR *, OPTION *, char *, u_long *);
int f_readonly(SCR *, OPTION *, char *, u_long *);
int f_recompile(SCR *, OPTION *, char *, u_long *);
int f_reformat(SCR *, OPTION *, char *, u_long *);
int f_section(SCR *, OPTION *, char *, u_long *);
int f_ttywerase(SCR *, OPTION *, char *, u_long *);
int f_w300(SCR *, OPTION *, char *, u_long *);
int f_w1200(SCR *, OPTION *, char *, u_long *);
int f_w9600(SCR *, OPTION *, char *, u_long *);
int f_window(SCR *, OPTION *, char *, u_long *);
int put(SCR *, CB *, CHAR_T *, MARK *, MARK *, int);
int rcv_tmp(SCR *, EXF *, char *);
int rcv_init(SCR *);
int rcv_sync(SCR *, u_int);
int rcv_list(SCR *);
int rcv_read(SCR *, FREF *);
int screen_init(GS *, SCR *, SCR **);
int screen_end(SCR *);
SCR *screen_next(SCR *);
int f_search(SCR *, MARK *, MARK *, char *, size_t, char **, u_int);
int b_search(SCR *, MARK *, MARK *, char *, size_t, char **, u_int);
void search_busy(SCR *, busy_t);
int seq_set(SCR *, CHAR_T *,
   size_t, CHAR_T *, size_t, CHAR_T *, size_t, seq_t, int);
int seq_delete(SCR *, CHAR_T *, size_t, seq_t);
int seq_mdel(SEQ *);
SEQ *seq_find
(SCR *, SEQ **, EVENT *, CHAR_T *, size_t, seq_t, int *);
void seq_close(GS *);
int seq_dump(SCR *, seq_t, int);
int seq_save(SCR *, FILE *, char *, seq_t);
int e_memcmp(CHAR_T *, EVENT *, size_t);
void *binc(SCR *, void *, size_t *, size_t);
int nonblank(SCR *, recno_t, size_t *);
CHAR_T *v_strdup(SCR *, const CHAR_T *, size_t);
enum nresult nget_uslong(u_long *, const char *, char **, int);
enum nresult nget_slong(long *, const char *, char **, int);
void TRACE(SCR *, const char *, ...);
@


1.14
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.12 2016/01/30 21:31:08 martijn Exp $	*/
a71 1
int f_lisp(SCR *, OPTION *, char *, u_long *);
@


1.13
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d3 1
a3 1
int cut(SCR *, char *, MARK *, MARK *, int);
d10 1
a10 1
FREF *file_add(SCR *, char *);
d22 4
a25 4
size_t v_key_len(SCR *, char);
char *v_key_name(SCR *, char);
int v_key_val(SCR *, char);
int v_event_push(SCR *, EVENT *, char *, size_t, u_int);
d50 2
a51 2
int mark_get(SCR *, char, MARK *, mtype_t);
int mark_set(SCR *, char, MARK *, int);
d84 1
a84 1
int put(SCR *, CB *, char *, MARK *, MARK *, int);
d96 3
a98 3
int seq_set(SCR *, char *,
   size_t, char *, size_t, char *, size_t, seq_t, int);
int seq_delete(SCR *, char *, size_t, seq_t);
d101 1
a101 1
(SCR *, SEQ **, EVENT *, char *, size_t, seq_t, int *);
d105 1
a105 1
int e_memcmp(char *, EVENT *, size_t);
d108 1
a108 1
char *v_strdup(SCR *, const char *, size_t);
@


1.12
log
@replace tail with basename

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.11 2016/01/20 08:43:27 bentley Exp $	*/
d3 1
a3 1
int cut(SCR *, CHAR_T *, MARK *, MARK *, int);
d10 1
a10 1
FREF *file_add(SCR *, CHAR_T *);
d22 4
a25 4
size_t v_key_len(SCR *, CHAR_T);
CHAR_T *v_key_name(SCR *, CHAR_T);
int v_key_val(SCR *, CHAR_T);
int v_event_push(SCR *, EVENT *, CHAR_T *, size_t, u_int);
d50 2
a51 2
int mark_get(SCR *, CHAR_T, MARK *, mtype_t);
int mark_set(SCR *, CHAR_T, MARK *, int);
d84 1
a84 1
int put(SCR *, CB *, CHAR_T *, MARK *, MARK *, int);
d96 3
a98 3
int seq_set(SCR *, CHAR_T *,
   size_t, CHAR_T *, size_t, CHAR_T *, size_t, seq_t, int);
int seq_delete(SCR *, CHAR_T *, size_t, seq_t);
d101 1
a101 1
(SCR *, SEQ **, EVENT *, CHAR_T *, size_t, seq_t, int *);
d105 1
a105 1
int e_memcmp(CHAR_T *, EVENT *, size_t);
d108 1
a108 1
CHAR_T *v_strdup(SCR *, const CHAR_T *, size_t);
@


1.11
log
@Remove ARG_CHAR_T, a relic from when the code was written K&R style.

ok millert@@ schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.10 2016/01/06 22:35:29 millert Exp $	*/
a107 1
char *tail(char *);
@


1.10
log
@Remove prototype for now-deleted f_msgcat().
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.9 2016/01/06 22:29:38 millert Exp $	*/
d22 3
a24 3
size_t v_key_len(SCR *, ARG_CHAR_T);
CHAR_T *v_key_name(SCR *, ARG_CHAR_T);
int v_key_val(SCR *, ARG_CHAR_T);
d50 2
a51 2
int mark_get(SCR *, ARG_CHAR_T, MARK *, mtype_t);
int mark_set(SCR *, ARG_CHAR_T, MARK *, int);
@


1.9
log
@Remove the msg_cat() function and adjust its former callers.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.8 2016/01/06 22:27:40 millert Exp $	*/
a72 1
int f_msgcat(SCR *, OPTION *, char *, u_long *);
@


1.8
log
@Remove the message catalog DB.  This removes the msg_open() and
msg_close() functions along with the msgcat command.
From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.7 2014/11/20 08:50:53 bentley Exp $	*/
a57 1
const char *msg_cat(SCR *, const char *, size_t *);
@


1.7
log
@Remove the vi perl api.

There have been various build errors for coming on two years now.
It doesn't work and nobody has expressed any interest in saving it.

From natano; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.6 2014/11/10 21:40:11 tedu Exp $	*/
a56 2
int msg_open(SCR *, char *);
void msg_close(GS *);
@


1.6
log
@remove various bits of autoconf cruft. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.5 2002/02/17 19:42:34 millert Exp $	*/
a2 22
SCR *api_fscreen(int, char *);
int api_aline(SCR *, recno_t, char *, size_t);
int api_dline(SCR *, recno_t);
int api_gline(SCR *, recno_t, char **, size_t *);
int api_iline(SCR *, recno_t, char *, size_t);
int api_lline(SCR *, recno_t *);
int api_sline(SCR *, recno_t, char *, size_t);
int api_getmark(SCR *, int, MARK *);
int api_setmark(SCR *, int, MARK *);
int api_nextmark(SCR *, int, char *);
int api_getcursor(SCR *, MARK *);
int api_setcursor(SCR *, MARK *);
void api_emessage(SCR *, char *);
void api_imessage(SCR *, char *);
int api_edit(SCR *, char *, SCR **, int);
int api_escreen(SCR *);
int api_swscreen(SCR *, SCR *);
int api_map(SCR *, char *, char *, size_t);
int api_unmap(SCR *, char *);
int api_opts_get(SCR *, char *, char **, int *);
int api_opts_set(SCR *, char *, char *, u_long, int);
int api_run_str(SCR *, char *);
@


1.5
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.4 2002/02/16 21:27:57 millert Exp $	*/
a2 61
#ifndef HAVE_BSEARCH
void	*bsearch(const void *, const void *, size_t,
   size_t, int (*)(const void *, const void *));
#endif
#ifndef HAVE_SETENV
int setenv(const char *, const char *, int);
#endif
#ifndef HAVE_UNSETENV
void unsetenv(const char *);
#endif
#ifndef HAVE_GETHOSTNAME
int gethostname(char *, int);
#endif
#ifndef HAVE_GETOPT
int getopt(int, char * const *, const char *); 
#endif
#ifndef HAVE_MEMCHR
void *memchr(const void *, int, size_t);
#endif
#ifndef HAVE_MEMCPY
void *memcpy(void *, const void *, size_t);
#endif
#ifndef HAVE_MEMMOVE
void *memmove(void *, const void *, size_t);
#endif
#ifndef HAVE_MEMSET
void *memset(void *, int, size_t);
#endif
#ifndef HAVE_MKSTEMP
int mkstemp(char *);
#endif
#ifndef HAVE_MMAP
char *mmap(char *, size_t, int, int, int, off_t);
#endif
#ifndef HAVE_MMAP
int munmap(char *, size_t);
#endif
#ifndef HAVE_SNPRINTF
int snprintf(char *, size_t, const char *, ...);
#endif
#ifndef HAVE_STRDUP
char *strdup(const char *);
#endif
#ifndef HAVE_STRERROR
char *strerror(int);
#endif
#ifndef HAVE_STRPBRK
char *strpbrk(const char *, const char *);
#endif
#ifndef HAVE_STRSEP
char *strsep(char **, const char *);
#endif
#ifndef HAVE_STRTOL
long strtol(const char *, char **, int);
#endif
#ifndef HAVE_STRTOUL
unsigned long strtoul(const char *, char **, int);
#endif
#ifndef HAVE_VSNPRINTF
int vsnprintf(char *, size_t, const char *, ...);
#endif
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_extern.h,v 1.3 2001/01/29 01:58:47 niklas Exp $	*/
d4 2
a5 2
void	*bsearch __P((const void *, const void *, size_t,
   size_t, int (*)(const void *, const void *)));
d180 2
a181 4
int f_search __P((SCR *,
   MARK *, MARK *, char *, size_t, char **, u_int));
int b_search __P((SCR *,
   MARK *, MARK *, char *, size_t, char **, u_int));
d183 2
a184 2
int seq_set __P((SCR *, CHAR_T *,
   size_t, CHAR_T *, size_t, CHAR_T *, size_t, seq_t, int));
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 1
a8 1
int setenv __P((const char *, const char *, int));
d11 1
a11 1
void unsetenv __P((const char *));
d14 1
a14 1
int gethostname __P((char *, int));
d17 1
a17 1
int getopt __P((int, char * const *, const char *)); 
d20 1
a20 1
void *memchr __P((const void *, int, size_t));
d23 1
a23 1
void *memcpy __P((void *, const void *, size_t));
d26 1
a26 1
void *memmove __P((void *, const void *, size_t));
d29 1
a29 1
void *memset __P((void *, int, size_t));
d32 1
a32 1
int mkstemp __P((char *));
d35 1
a35 1
char *mmap __P((char *, size_t, int, int, int, off_t));
d38 1
a38 1
int munmap __P((char *, size_t));
d41 1
a41 1
int snprintf __P((char *, size_t, const char *, ...));
d44 1
a44 1
char *strdup __P((const char *));
d47 1
a47 1
char *strerror __P((int));
d50 1
a50 1
char *strpbrk __P((const char *, const char *));
d53 1
a53 1
char *strsep __P((char **, const char *));
d56 1
a56 1
long strtol __P((const char *, char **, int));
d59 1
a59 1
unsigned long strtoul __P((const char *, char **, int));
d62 1
a62 1
int vsnprintf __P((char *, size_t, const char *, ...));
d64 116
a179 116
SCR *api_fscreen __P((int, char *));
int api_aline __P((SCR *, recno_t, char *, size_t));
int api_dline __P((SCR *, recno_t));
int api_gline __P((SCR *, recno_t, char **, size_t *));
int api_iline __P((SCR *, recno_t, char *, size_t));
int api_lline __P((SCR *, recno_t *));
int api_sline __P((SCR *, recno_t, char *, size_t));
int api_getmark __P((SCR *, int, MARK *));
int api_setmark __P((SCR *, int, MARK *));
int api_nextmark __P((SCR *, int, char *));
int api_getcursor __P((SCR *, MARK *));
int api_setcursor __P((SCR *, MARK *));
void api_emessage __P((SCR *, char *));
void api_imessage __P((SCR *, char *));
int api_edit __P((SCR *, char *, SCR **, int));
int api_escreen __P((SCR *));
int api_swscreen __P((SCR *, SCR *));
int api_map __P((SCR *, char *, char *, size_t));
int api_unmap __P((SCR *, char *));
int api_opts_get __P((SCR *, char *, char **, int *));
int api_opts_set __P((SCR *, char *, char *, u_long, int));
int api_run_str __P((SCR *, char *));
int cut __P((SCR *, CHAR_T *, MARK *, MARK *, int));
int cut_line __P((SCR *, recno_t, size_t, size_t, CB *));
void cut_close __P((GS *));
TEXT *text_init __P((SCR *, const char *, size_t, size_t));
void text_lfree __P((TEXTH *));
void text_free __P((TEXT *));
int del __P((SCR *, MARK *, MARK *, int));
FREF *file_add __P((SCR *, CHAR_T *));
int file_init __P((SCR *, FREF *, char *, int));
int file_end __P((SCR *, EXF *, int));
int file_write __P((SCR *, MARK *, MARK *, char *, int));
int file_m1 __P((SCR *, int, int));
int file_m2 __P((SCR *, int));
int file_m3 __P((SCR *, int));
int file_aw __P((SCR *, int));
void set_alt_name __P((SCR *, char *));
lockr_t file_lock __P((SCR *, char *, int *, int, int));
int v_key_init __P((SCR *));
void v_key_ilookup __P((SCR *));
size_t v_key_len __P((SCR *, ARG_CHAR_T));
CHAR_T *v_key_name __P((SCR *, ARG_CHAR_T));
int v_key_val __P((SCR *, ARG_CHAR_T));
int v_event_push __P((SCR *, EVENT *, CHAR_T *, size_t, u_int));
int v_event_get __P((SCR *, EVENT *, int, u_int32_t));
void v_event_err __P((SCR *, EVENT *));
int v_event_flush __P((SCR *, u_int));
int db_eget __P((SCR *, recno_t, char **, size_t *, int *));
int db_get __P((SCR *, recno_t, u_int32_t, char **, size_t *));
int db_delete __P((SCR *, recno_t));
int db_append __P((SCR *, int, recno_t, char *, size_t));
int db_insert __P((SCR *, recno_t, char *, size_t));
int db_set __P((SCR *, recno_t, char *, size_t));
int db_exist __P((SCR *, recno_t));
int db_last __P((SCR *, recno_t *));
void db_err __P((SCR *, recno_t));
int log_init __P((SCR *, EXF *));
int log_end __P((SCR *, EXF *));
int log_cursor __P((SCR *));
int log_line __P((SCR *, recno_t, u_int));
int log_mark __P((SCR *, LMARK *));
int log_backward __P((SCR *, MARK *));
int log_setline __P((SCR *));
int log_forward __P((SCR *, MARK *));
int editor __P((GS *, int, char *[]));
void v_end __P((GS *));
int mark_init __P((SCR *, EXF *));
int mark_end __P((SCR *, EXF *));
int mark_get __P((SCR *, ARG_CHAR_T, MARK *, mtype_t));
int mark_set __P((SCR *, ARG_CHAR_T, MARK *, int));
int mark_insdel __P((SCR *, lnop_t, recno_t));
void msgq __P((SCR *, mtype_t, const char *, ...));
void msgq_str __P((SCR *, mtype_t, char *, char *));
void mod_rpt __P((SCR *));
void msgq_status __P((SCR *, recno_t, u_int));
int msg_open __P((SCR *, char *));
void msg_close __P((GS *));
const char *msg_cmsg __P((SCR *, cmsg_t, size_t *));
const char *msg_cat __P((SCR *, const char *, size_t *));
char *msg_print __P((SCR *, const char *, int *));
int opts_init __P((SCR *, int *));
int opts_set __P((SCR *, ARGS *[], char *));
int o_set __P((SCR *, int, u_int, char *, u_long));
int opts_empty __P((SCR *, int, int));
void opts_dump __P((SCR *, enum optdisp));
int opts_save __P((SCR *, FILE *));
OPTLIST const *opts_search __P((char *));
void opts_nomatch __P((SCR *, char *));
int opts_copy __P((SCR *, SCR *));
void opts_free __P((SCR *));
int f_altwerase __P((SCR *, OPTION *, char *, u_long *));
int f_columns __P((SCR *, OPTION *, char *, u_long *));
int f_lines __P((SCR *, OPTION *, char *, u_long *));
int f_lisp __P((SCR *, OPTION *, char *, u_long *));
int f_msgcat __P((SCR *, OPTION *, char *, u_long *));
int f_paragraph __P((SCR *, OPTION *, char *, u_long *));
int f_print __P((SCR *, OPTION *, char *, u_long *));
int f_readonly __P((SCR *, OPTION *, char *, u_long *));
int f_recompile __P((SCR *, OPTION *, char *, u_long *));
int f_reformat __P((SCR *, OPTION *, char *, u_long *));
int f_section __P((SCR *, OPTION *, char *, u_long *));
int f_ttywerase __P((SCR *, OPTION *, char *, u_long *));
int f_w300 __P((SCR *, OPTION *, char *, u_long *));
int f_w1200 __P((SCR *, OPTION *, char *, u_long *));
int f_w9600 __P((SCR *, OPTION *, char *, u_long *));
int f_window __P((SCR *, OPTION *, char *, u_long *));
int put __P((SCR *, CB *, CHAR_T *, MARK *, MARK *, int));
int rcv_tmp __P((SCR *, EXF *, char *));
int rcv_init __P((SCR *));
int rcv_sync __P((SCR *, u_int));
int rcv_list __P((SCR *));
int rcv_read __P((SCR *, FREF *));
int screen_init __P((GS *, SCR *, SCR **));
int screen_end __P((SCR *));
SCR *screen_next __P((SCR *));
d184 1
a184 1
void search_busy __P((SCR *, busy_t));
d187 2
a188 2
int seq_delete __P((SCR *, CHAR_T *, size_t, seq_t));
int seq_mdel __P((SEQ *));
d190 12
a201 12
   __P((SCR *, SEQ **, EVENT *, CHAR_T *, size_t, seq_t, int *));
void seq_close __P((GS *));
int seq_dump __P((SCR *, seq_t, int));
int seq_save __P((SCR *, FILE *, char *, seq_t));
int e_memcmp __P((CHAR_T *, EVENT *, size_t));
void *binc __P((SCR *, void *, size_t *, size_t));
int nonblank __P((SCR *, recno_t, size_t *));
char *tail __P((char *));
CHAR_T *v_strdup __P((SCR *, const CHAR_T *, size_t));
enum nresult nget_uslong __P((u_long *, const char *, char **, int));
enum nresult nget_slong __P((long *, const char *, char **, int));
void TRACE __P((SCR *, const char *, ...));
@


1.2
log
@Update to 1.79 and install as vi/ex/view.
@
text
@d1 2
@


1.1
log
@namechange.
@
text
@d82 1
a82 1
int api_opts_set __P((SCR *, char *));
d90 1
a90 1
int delete __P((SCR *, MARK *, MARK *, int));
d150 1
@
