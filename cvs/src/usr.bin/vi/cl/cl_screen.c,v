head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.16
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.12
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.10
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.27
date	2016.05.28.18.30.35;	author martijn;	state Exp;
branches;
next	1.26;
commitid	ZDkrcGBxutHLScTT;

1.26
date	2016.02.11.16.34.12;	author tim;	state Exp;
branches;
next	1.25;
commitid	UoDisafDvVb2Ubb7;

1.25
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.24;
commitid	adBvXLg05bJxz6yx;

1.24
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.23;
commitid	gtDERb7QyXwKGs62;

1.23
date	2015.04.10.18.05.51;	author brynet;	state Exp;
branches;
next	1.22;
commitid	3KdoKOBEaWokdDOw;

1.22
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.21;
commitid	T0XpHzXjuQBl1V3E;

1.21
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.20;
commitid	06bi6U3x4gFFf2G1;

1.20
date	2013.11.28.22.12.40;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.21.09.00.25;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.18.23.11.43;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.29.01.58.28;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.11.26.22.49.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.03.06.20.27.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.03.06.20.19.24;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.03.03.01.22.33;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	98.07.24.00.07.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.23.07.12.45;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.10.16.01.18.12;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.09.17.17.18.50;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.17.58.17;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.15.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.33.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Test if stdin is a terminal before resetting the tty state.
Diff supplied by Kai Antweiler.

OK semarie@@ and deraadt@@
@
text
@/*	$OpenBSD: cl_screen.c,v 1.26 2016/02/11 16:34:12 tim Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <curses.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>
#include <termios.h>
#include <unistd.h>

#include "../common/common.h"
#include "cl.h"

static int	cl_ex_end(GS *);
static int	cl_ex_init(SCR *);
static void	cl_freecap(CL_PRIVATE *);
static int	cl_vi_end(GS *);
static int	cl_vi_init(SCR *);
static int	cl_putenv(char *, char *, u_long);

/*
 * cl_screen --
 *	Switch screen types.
 *
 * PUBLIC: int cl_screen(SCR *, u_int32_t);
 */
int
cl_screen(SCR *sp, u_int32_t flags)
{
	CL_PRIVATE *clp;
	GS *gp;

	gp = sp->gp;
	clp = CLP(sp);

	/* See if the current information is incorrect. */
	if (F_ISSET(gp, G_SRESTART)) {
		if ((!F_ISSET(sp, SC_SCR_EX | SC_SCR_VI) ||
		    resizeterm(O_VAL(sp, O_LINES), O_VAL(sp, O_COLUMNS))) &&
		    cl_quit(gp))
			return (1);
		F_CLR(gp, G_SRESTART);
	}
	
	/* See if we're already in the right mode. */
	if ((LF_ISSET(SC_EX) && F_ISSET(sp, SC_SCR_EX)) ||
	    (LF_ISSET(SC_VI) && F_ISSET(sp, SC_SCR_VI)))
		return (0);

	/*
	 * Fake leaving ex mode.
	 *
	 * We don't actually exit ex or vi mode unless forced (e.g. by a window
	 * size change).  This is because many curses implementations can't be
	 * called twice in a single program.  Plus, it's faster.  If the editor
	 * "leaves" vi to enter ex, when it exits ex we'll just fall back into
	 * vi.
	 */
	if (F_ISSET(sp, SC_SCR_EX))
		F_CLR(sp, SC_SCR_EX);

	/*
	 * Fake leaving vi mode.
	 *
	 * Clear out the rest of the screen if we're in the middle of a split
	 * screen.  Move to the last line in the current screen -- this makes
	 * terminal scrolling happen naturally.  Note: *don't* move past the
	 * end of the screen, as there are ex commands (e.g., :read ! cat file)
	 * that don't want to.  Don't clear the info line, its contents may be
	 * valid, e.g. :file|append.
	 */
	if (F_ISSET(sp, SC_SCR_VI)) {
		F_CLR(sp, SC_SCR_VI);

		if (TAILQ_NEXT(sp, q)) {
			(void)move(RLNO(sp, sp->rows), 0);
			clrtobot();
		}
		(void)move(RLNO(sp, sp->rows) - 1, 0);
		refresh();
	}

	/* Enter the requested mode. */
	if (LF_ISSET(SC_EX)) {
		if (cl_ex_init(sp))
			return (1);
		F_SET(clp, CL_IN_EX | CL_SCR_EX_INIT);

		/*
		 * If doing an ex screen for ex mode, move to the last line
		 * on the screen.
		 */
		if (F_ISSET(sp, SC_EX) && clp->cup != NULL)
			tputs(tgoto(clp->cup,
			    0, O_VAL(sp, O_LINES) - 1), 1, cl_putchar);
	} else {
		if (cl_vi_init(sp))
			return (1);
		F_CLR(clp, CL_IN_EX);
		F_SET(clp, CL_SCR_VI_INIT);
	}
	return (0);
}

/*
 * cl_quit --
 *	Shutdown the screens.
 *
 * PUBLIC: int cl_quit(GS *);
 */
int
cl_quit(GS *gp)
{
	CL_PRIVATE *clp;
	int rval;

	rval = 0;
	clp = GCLP(gp);

	/*
	 * If we weren't really running, ignore it.  This happens if the
	 * screen changes size before we've called curses.
	 */
	if (!F_ISSET(clp, CL_SCR_EX_INIT | CL_SCR_VI_INIT))
		return (0);

	/* Clean up the terminal mappings. */
	if (cl_term_end(gp))
		rval = 1;

	/* Really leave vi mode. */
	if (F_ISSET(clp, CL_STDIN_TTY) &&
	    F_ISSET(clp, CL_SCR_VI_INIT) && cl_vi_end(gp))
		rval = 1;

	/* Really leave ex mode. */
	if (F_ISSET(clp, CL_STDIN_TTY) &&
	    F_ISSET(clp, CL_SCR_EX_INIT) && cl_ex_end(gp))
		rval = 1;

	/*
	 * If we were running ex when we quit, or we're using an implementation
	 * of curses where endwin() doesn't get this right, restore the original
	 * terminal modes.
	 *
	 * XXX
	 * We always do this because it's too hard to figure out what curses
	 * implementations get it wrong.  It may discard type-ahead characters
	 * from the tty queue.
	 */
	if (F_ISSET(clp, CL_STDIN_TTY))
		(void)tcsetattr(STDIN_FILENO, TCSADRAIN | TCSASOFT, &clp->orig);

	F_CLR(clp, CL_SCR_EX_INIT | CL_SCR_VI_INIT);
	return (rval);
}

/*
 * cl_vi_init --
 *	Initialize the curses vi screen.
 */
static int
cl_vi_init(SCR *sp)
{
	CL_PRIVATE *clp;
	char *o_cols, *o_lines, *o_term, *ttype;

	clp = CLP(sp);

	/* If already initialized, just set the terminal modes. */
	if (F_ISSET(clp, CL_SCR_VI_INIT))
		goto fast;

	/* Curses vi always reads from (and writes to) a terminal. */
	if (!F_ISSET(clp, CL_STDIN_TTY) || !isatty(STDOUT_FILENO)) {
		msgq(sp, M_ERR,
		    "Vi's standard input and output must be a terminal");
		return (1);
	}

	/* We'll need a terminal type. */
	if (opts_empty(sp, O_TERM, 0))
		return (1);
	ttype = O_STR(sp, O_TERM);

	/*
	 * XXX
	 * Changing the row/column and terminal values is done by putting them
	 * into the environment, which is then read by curses.  What this loses
	 * in ugliness, it makes up for in stupidity.  We can't simply put the
	 * values into the environment ourselves, because in the presence of a
	 * kernel mechanism for returning the window size, entering values into
	 * the environment will screw up future screen resizing events, e.g. if
	 * the user enters a :shell command and then resizes their window.  So,
	 * if they weren't already in the environment, we make sure to delete
	 * them immediately after setting them.
	 *
	 * XXX
	 * Putting the TERM variable into the environment is necessary, even
	 * though we're using newterm() here.  We may be using initscr() as
	 * the underlying function.
	 */
	o_term = getenv("TERM");
	cl_putenv("TERM", ttype, 0);
	o_lines = getenv("LINES");
	cl_putenv("LINES", NULL, (u_long)O_VAL(sp, O_LINES));
	o_cols = getenv("COLUMNS");
	cl_putenv("COLUMNS", NULL, (u_long)O_VAL(sp, O_COLUMNS));

	/*
	 * The terminal is aways initialized, either in `main`, or by a
	 * previous call to newterm(3).
	 */
	(void)del_curterm(cur_term);

	/*
	 * We don't care about the SCREEN reference returned by newterm, we
	 * never have more than one SCREEN at a time.
	 */
	errno = 0;
	if (newterm(ttype, stdout, stdin) == NULL) {
		if (errno)
			msgq(sp, M_SYSERR, "%s", ttype);
		else
			msgq(sp, M_ERR, "%s: unknown terminal type", ttype);
		return (1);
	}

	if (o_term == NULL)
		unsetenv("TERM");
	if (o_lines == NULL)
		unsetenv("LINES");
	if (o_cols == NULL)
		unsetenv("COLUMNS");

	/*
	 * XXX
	 * Someone got let out alone without adult supervision -- the SunOS
	 * newterm resets the signal handlers.  There's a race, but it's not
	 * worth closing.
	 */
	(void)sig_init(sp->gp, sp);

	/*
	 * We use raw mode.  What we want is 8-bit clean, however, signals
	 * and flow control should continue to work.  Admittedly, it sounds
	 * like cbreak, but it isn't.  Using cbreak() can get you additional
	 * things like IEXTEN, which turns on flags like DISCARD and LNEXT.
	 *
	 * !!!
	 * If raw isn't turning off echo and newlines, something's wrong.
	 * However, it shouldn't hurt.
	 */
	noecho();			/* No character echo. */
	nonl();				/* No CR/NL translation. */
	raw();				/* 8-bit clean. */
	idlok(stdscr, 1);		/* Use hardware insert/delete line. */

	/* Put the cursor keys into application mode. */
	(void)keypad(stdscr, TRUE);

	/*
	 * XXX
	 * The screen TI sequence just got sent.  See the comment in
	 * cl_funcs.c:cl_attr().
	 */
	clp->ti_te = TI_SENT;

	/*
	 * XXX
	 * Historic implementations of curses handled SIGTSTP signals
	 * in one of three ways.  They either:
	 *
	 *	1: Set their own handler, regardless.
	 *	2: Did not set a handler if a handler was already installed.
	 *	3: Set their own handler, but then called any previously set
	 *	   handler after completing their own cleanup.
	 *
	 * We don't try and figure out which behavior is in place, we force
	 * it to SIG_DFL after initializing the curses interface, which means
	 * that curses isn't going to take the signal.  Since curses isn't
	 * reentrant (i.e., the whole curses SIGTSTP interface is a fantasy),
	 * we're doing The Right Thing.
	 */
	(void)signal(SIGTSTP, SIG_DFL);

	/*
	 * If flow control was on, turn it back on.  Turn signals on.  ISIG
	 * turns on VINTR, VQUIT, VDSUSP and VSUSP.   The main curses code
	 * already installed a handler for VINTR.  We're going to disable the
	 * other three.
	 *
	 * XXX
	 * We want to use ^Y as a vi scrolling command.  If the user has the
	 * DSUSP character set to ^Y (common practice) clean it up.  As it's
	 * equally possible that the user has VDSUSP set to 'a', we disable
	 * it regardless.  It doesn't make much sense to suspend vi at read,
	 * so I don't think anyone will care.  Alternatively, we could look
	 * it up in the table of legal command characters and turn it off if
	 * it matches one.
	 *
	 * XXX
	 * We don't check to see if the user had signals enabled originally.
	 * If they didn't, it's unclear what we're supposed to do here, but
	 * it's also pretty unlikely.
	 */
	if (tcgetattr(STDIN_FILENO, &clp->vi_enter)) {
		msgq(sp, M_SYSERR, "tcgetattr");
		goto err;
	}
	if (clp->orig.c_iflag & IXON)
		clp->vi_enter.c_iflag |= IXON;
	if (clp->orig.c_iflag & IXOFF)
		clp->vi_enter.c_iflag |= IXOFF;

	clp->vi_enter.c_lflag |= ISIG;
	clp->vi_enter.c_cc[VDSUSP] = _POSIX_VDISABLE;
	clp->vi_enter.c_cc[VQUIT] = _POSIX_VDISABLE;
	clp->vi_enter.c_cc[VSUSP] = _POSIX_VDISABLE;

	/*
	 * XXX
	 * OSF/1 doesn't turn off the <discard>, <literal-next> or <status>
	 * characters when curses switches into raw mode.  It should be OK
	 * to do it explicitly for everyone.
	 */
	clp->vi_enter.c_cc[VDISCARD] = _POSIX_VDISABLE;
	clp->vi_enter.c_cc[VLNEXT] = _POSIX_VDISABLE;
	clp->vi_enter.c_cc[VSTATUS] = _POSIX_VDISABLE;

	/* Initialize terminal based information. */
	if (cl_term_init(sp))
		goto err;

fast:	/* Set the terminal modes. */
	if (tcsetattr(STDIN_FILENO, TCSASOFT | TCSADRAIN, &clp->vi_enter)) {
		if (errno == EINTR)
			goto fast;
		msgq(sp, M_SYSERR, "tcsetattr");
err:		(void)cl_vi_end(sp->gp);
		return (1);
	}
	return (0);
}

/*
 * cl_vi_end --
 *	Shutdown the vi screen.
 */
static int
cl_vi_end(GS *gp)
{
	CL_PRIVATE *clp;

	clp = GCLP(gp);

	/* Restore the cursor keys to normal mode. */
	(void)keypad(stdscr, FALSE);

	/*
	 * If we were running vi when we quit, scroll the screen up a single
	 * line so we don't lose any information.
	 *
	 * Move to the bottom of the window (some endwin implementations don't
	 * do this for you).
	 */
	if (!F_ISSET(clp, CL_IN_EX)) {
		(void)move(0, 0);
		(void)deleteln();
		(void)move(LINES - 1, 0);
		(void)refresh();
	}

	cl_freecap(clp);

	/* End curses window. */
	(void)endwin();

	/* Free the SCREEN created by newterm(3). */
	delscreen(set_term(NULL));

	/*
	 * XXX
	 * The screen TE sequence just got sent.  See the comment in
	 * cl_funcs.c:cl_attr().
	 */
	clp->ti_te = TE_SENT;

	return (0);
}

/*
 * cl_ex_init --
 *	Initialize the ex screen.
 */
static int
cl_ex_init(SCR *sp)
{
	CL_PRIVATE *clp;

	clp = CLP(sp);

	/* If already initialized, just set the terminal modes. */
	if (F_ISSET(clp, CL_SCR_EX_INIT))
		goto fast;

	/* If not reading from a file, we're done. */
	if (!F_ISSET(clp, CL_STDIN_TTY))
		return (0);

	/* Get the ex termcap/terminfo strings. */
	(void)cl_getcap(sp, "cup", &clp->cup);
	(void)cl_getcap(sp, "smso", &clp->smso);
	(void)cl_getcap(sp, "rmso", &clp->rmso);
	(void)cl_getcap(sp, "el", &clp->el);
	(void)cl_getcap(sp, "cuu1", &clp->cuu1);

	/* Enter_standout_mode and exit_standout_mode are paired. */
	if (clp->smso == NULL || clp->rmso == NULL) {
		if (clp->smso != NULL) {
			free(clp->smso);
			clp->smso = NULL;
		}
		if (clp->rmso != NULL) {
			free(clp->rmso);
			clp->rmso = NULL;
		}
	}

	/*
	 * Turn on canonical mode, with normal input and output processing.
	 * Start with the original terminal settings as the user probably
	 * had them (including any local extensions) set correctly for the
	 * current terminal.
	 *
	 * !!!
	 * We can't get everything that we need portably; for example, ONLCR,
	 * mapping <newline> to <carriage-return> on output isn't required
	 * by POSIX 1003.1b-1993.  If this turns out to be a problem, then
	 * we'll either have to play some games on the mapping, or we'll have
	 * to make all ex printf's output \r\n instead of \n.
	 */
	clp->ex_enter = clp->orig;
	clp->ex_enter.c_lflag |=
	    ECHO | ECHOCTL | ECHOE | ECHOK | ECHOKE | ICANON | IEXTEN | ISIG;
	clp->ex_enter.c_iflag |= ICRNL;
	clp->ex_enter.c_oflag |= ONLCR | OPOST;

fast:	if (tcsetattr(STDIN_FILENO, TCSADRAIN | TCSASOFT, &clp->ex_enter)) {
		if (errno == EINTR)
			goto fast;
		msgq(sp, M_SYSERR, "tcsetattr");
		return (1);
	}
	return (0);
}

/*
 * cl_ex_end --
 *	Shutdown the ex screen.
 */
static int
cl_ex_end(GS *gp)
{
	CL_PRIVATE *clp;

	clp = GCLP(gp);

	cl_freecap(clp);

	return (0);
}

/*
 * cl_getcap --
 *	Retrieve termcap/terminfo strings.
 *
 * PUBLIC: int cl_getcap(SCR *, char *, char **);
 */
int
cl_getcap(SCR *sp, char *name, char **elementp)
{
	size_t len;
	char *t;

	if ((t = tigetstr(name)) != NULL &&
	    t != (char *)-1 && (len = strlen(t)) != 0) {
		MALLOC_RET(sp, *elementp, len + 1);
		memmove(*elementp, t, len + 1);
	}
	return (0);
}

/*
 * cl_freecap --
 *	Free any allocated termcap/terminfo strings.
 */
static void
cl_freecap(CL_PRIVATE *clp)
{
	if (clp->el != NULL) {
		free(clp->el);
		clp->el = NULL;
	}
	if (clp->cup != NULL) {
		free(clp->cup);
		clp->cup = NULL;
	}
	if (clp->cuu1 != NULL) {
		free(clp->cuu1);
		clp->cuu1 = NULL;
	}
	if (clp->rmso != NULL) {
		free(clp->rmso);
		clp->rmso = NULL;
	}
	if (clp->smso != NULL) {
		free(clp->smso);
		clp->smso = NULL;
	}
}

/*
 * cl_putenv --
 *	Put a value into the environment.
 */
static int
cl_putenv(char *name, char *str, u_long value)
{
	char buf[40];

	if (str == NULL) {
		(void)snprintf(buf, sizeof(buf), "%lu", value);
		return (setenv(name, buf, 1));
	} else
		return (setenv(name, str, 1));
}
@


1.26
log
@Update comment: the #ifdef VDSUSP was removed in r1.22.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.25 2016/01/06 22:28:52 millert Exp $	*/
d168 2
a169 1
	(void)tcsetattr(STDIN_FILENO, TCSADRAIN | TCSASOFT, &clp->orig);
@


1.25
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.24 2015/12/07 20:39:19 mmcc Exp $	*/
d316 1
a316 2
	 * it matches one.  VDSUSP wasn't in POSIX 1003.1-1990, so we test for
	 * it.
@


1.24
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.23 2015/04/10 18:05:51 brynet Exp $	*/
d193 1
a193 1
		    "016|Vi's standard input and output must be a terminal");
@


1.23
log
@This changes vi to use resizeterm(3) instead of reinitializing curses on
window resizes, which was leaking massive amounts of memory.

Try observing vi in top(1) and while resizing the window a few times
before and aftering applying this diff..

Also some more comment cleanup and another memory leak..

From github.com/lichray/nvi2
879d2ad6dd4a4343eb0a588ebfe637e1c9845bc4
a8c38480adb030a05bbb2aafec6067dd65d8c2eb

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.22 2014/11/12 16:29:04 millert Exp $	*/
d505 1
a505 1
		MALLOC_RET(sp, *elementp, char *, len + 1);
@


1.22
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.21 2014/11/12 04:28:41 bentley Exp $	*/
d55 3
a57 1
		if (cl_quit(gp))
d227 6
a234 10
	 *
	 * XXX
	 * The SunOS initscr() can't be called twice.  Don't even think about
	 * using it.  It fails in subtle ways (e.g. select(2) on fileno(stdin)
	 * stops working).  (The SVID notes that applications should only call
	 * initscr() once.)
	 *
	 * XXX
	 * The HP/UX newterm doesn't support the NULL first argument, so we
	 * have to specify the terminal type.
d395 3
@


1.21
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.20 2013/11/28 22:12:40 krw Exp $	*/
a335 1
#ifdef VDSUSP
a336 1
#endif
a345 1
#ifdef VDISCARD
a346 2
#endif
#ifdef VLNEXT
a347 2
#endif
#ifdef VSTATUS
a348 1
#endif
d460 2
a461 7
	clp->ex_enter.c_lflag  |= ECHO | ECHOE | ECHOK | ICANON | IEXTEN | ISIG;
#ifdef ECHOCTL
	clp->ex_enter.c_lflag |= ECHOCTL;
#endif
#ifdef ECHOKE
	clp->ex_enter.c_lflag |= ECHOKE;
#endif
d463 1
a463 4
	clp->ex_enter.c_oflag |= OPOST;
#ifdef ONLCR
	clp->ex_enter.c_oflag |= ONLCR;
#endif
@


1.20
log
@Convert the display screens and hidden screens CIRCLEQ's to TAILQ's.

ok pelikan@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.19 2009/10/27 23:59:47 deraadt Exp $	*/
d45 1
a45 3
cl_screen(sp, flags)
	SCR *sp;
	u_int32_t flags;
d127 1
a127 2
cl_quit(gp)
	GS *gp;
d177 1
a177 2
cl_vi_init(sp)
	SCR *sp;
d378 1
a378 2
cl_vi_end(gp)
	GS *gp;
d421 1
a421 2
cl_ex_init(sp)
	SCR *sp;
d495 1
a495 2
cl_ex_end(gp)
	GS *gp;
d513 1
a513 3
cl_getcap(sp, name, elementp)
	SCR *sp;
	char *name, **elementp;
d531 1
a531 2
cl_freecap(clp)
	CL_PRIVATE *clp;
d560 1
a560 4
cl_putenv(name, str, value)
	char *name, *str;
	u_long value;

@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.18 2006/04/22 03:09:15 ray Exp $	*/
d92 1
a92 1
		if (CIRCLEQ_NEXT(sp, q) != CIRCLEQ_END(&gp->dq)) {
@


1.18
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.17 2006/01/08 21:05:39 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)cl_screen.c	10.49 (Berkeley) 9/24/96";
#endif /* not lint */
@


1.17
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.16 2005/10/17 19:12:16 otto Exp $	*/
a187 1
	GS *gp;
a189 1
	gp = sp->gp;
@


1.16
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.15 2005/04/21 09:00:25 otto Exp $	*/
d67 2
a68 2
	if (LF_ISSET(SC_EX) && F_ISSET(sp, SC_SCR_EX) ||
	    LF_ISSET(SC_VI) && F_ISSET(sp, SC_SCR_VI))
@


1.15
log
@Avoid the "tcsetattr: Interrupted system call" fatal error when
resizing using a window manager that continously sends resize
events.  ok camield@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.14 2003/07/18 23:11:43 david Exp $	*/
d96 1
a96 1
		if (sp->q.cqe_next != (void *)&gp->dq) {
@


1.14
log
@add missing includes
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.13 2002/02/16 21:27:56 millert Exp $	*/
d374 2
d494 2
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_screen.c,v 1.12 2001/01/29 01:58:28 niklas Exp $	*/
d28 1
@


1.12
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 6
a39 6
static int	cl_ex_end __P((GS *));
static int	cl_ex_init __P((SCR *));
static void	cl_freecap __P((CL_PRIVATE *));
static int	cl_vi_end __P((GS *));
static int	cl_vi_init __P((SCR *));
static int	cl_putenv __P((char *, char *, u_long));
d45 1
a45 1
 * PUBLIC: int cl_screen __P((SCR *, u_int32_t));
d129 1
a129 1
 * PUBLIC: int cl_quit __P((GS *));
d518 1
a518 1
 * PUBLIC: int cl_getcap __P((SCR *, char *, char **));
@


1.11
log
@o Update README files etc. from nvi-1.79 so they have the correct info
o make port.h empty since we there is nothing we lack
o include <sys/param.h>, not <sys/types.h> in files that use MIN/MAX macros
o add perl api support since we have libperl (off by default)
@
text
@d1 2
@


1.10
log
@back out changes that should not have escaped my local tree
@
text
@d20 1
a21 1
#include <curses.h>
@


1.9
log
@add missing reference to infocmp
@
text
@d20 1
a21 1
#include <errno.h>
d198 1
a198 2
		    "016|vi's standard input and output must both refer to a
		     terminal");
@


1.8
log
@better grammar for err msg
@
text
@d20 1
a21 1
#include <curses.h>
@


1.7
log
@-D_USE_OLD_CURSE_ for -locurses and no more -ltermlib/termcap
@
text
@d198 2
a199 1
		    "016|Vi's standard input and output must be a terminal");
@


1.6
log
@Make building with ocurses/termcap and curses/termlib conditional on
USE_OCURSES being defined, and define it for now.  This switches nvi back
to use BSD curses.
@
text
@a20 3
#ifdef USE_OCURSES
#include <ocurses.h>
#else
a21 1
#endif
@


1.5
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d20 4
d25 1
a25 1
#include <errno.h>
@


1.4
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_screen.c	10.48 (Berkeley) 9/15/96";
d151 1
a151 1
	if (F_ISSET(gp, G_STDIN_TTY) &&
d156 1
a156 1
	if (F_ISSET(gp, G_STDIN_TTY) &&
d196 1
a196 1
	if (!F_ISSET(gp, G_STDIN_TTY) || !isatty(STDOUT_FILENO)) {
d439 1
a439 1
	if (!F_ISSET(sp->gp, G_STDIN_TTY))
@


1.3
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_screen.c	10.47 (Berkeley) 7/30/96";
d105 1
a105 2
		clp->in_ex = 1;
		F_SET(clp, CL_SCR_EX_INIT);
d117 1
a117 1
		clp->in_ex = 0;
d400 1
a400 1
	if (!clp->in_ex) {
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_screen.c	10.46 (Berkeley) 6/17/96";
d237 4
a240 3
	 * The SunOS initscr() isn't reentrant.  Don't even think about using
	 * it.  It fails in subtle ways (e.g. select(2) on fileno(stdin) stops
	 * working).
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_screen.c	10.44 (Berkeley) 5/16/96";
d287 5
a291 1
	/* The screen TI sequence just got sent. */
a374 10

	/* If not already done, send the terminal initialization sequence. */
	if (clp->ti_te == TE_SENT) {
		clp->ti_te = TI_SENT;
		if (clp->smcup == NULL)
			(void)cl_getcap(sp, "smcup", &clp->smcup);
		if (clp->smcup != NULL)
			(void)tputs(clp->smcup, 1, cl_putchar);
		(void)fflush(stdout);
	}
d412 5
a416 1
	/* The screen TE sequence just got sent. */
a491 10

	/* If not already done, send the terminal end sequence. */
	if (clp->ti_te == TI_SENT) {
		clp->ti_te = TE_SENT;
		if (clp->rmcup == NULL)
			(void)cl_getcap(sp, "rmcup", &clp->rmcup);
		if (clp->rmcup != NULL)
			(void)tputs(clp->rmcup, 1, cl_putchar);
		(void)fflush(stdout);
	}
d566 1
a566 5
 *	Put a value into the environment.  We use putenv(3) because it's
 *	more portable.  The following hack is because some moron decided
 *	to keep a reference to the memory passed to putenv(3), instead of
 *	having it allocate its own.  Someone clearly needs to get promoted
 *	into management.
@
