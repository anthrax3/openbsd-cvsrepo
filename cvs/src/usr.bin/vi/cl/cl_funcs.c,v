head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.4
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.14.0.22
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.20
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.19;
commitid	01nAnartGL7onLD3;

1.19
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.18;
commitid	ruCZ2IKF0FB0ebCr;

1.18
date	2015.03.29.01.04.23;	author bcallah;	state Exp;
branches;
next	1.17;
commitid	KcEgXMM3P7dpQPm7;

1.17
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.16;
commitid	T0XpHzXjuQBl1V3E;

1.16
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.15;
commitid	06bi6U3x4gFFf2G1;

1.15
date	2014.11.06.10.48.52;	author bentley;	state Exp;
branches;
next	1.14;
commitid	ELEZXFZ7jYF35pM3;

1.14
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.28.13.02.22;	author sobrado;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.11.06.58.00;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.18.23.11.43;	author david;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.29.01.58.27;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.02.08.01.26.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.07.24.00.07.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.09.23.07.12.43;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.01.18.08;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.17.58.16;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.15.13;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.33.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: cl_funcs.c,v 1.18 2015/03/29 01:04:23 bcallah Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <ctype.h>
#include <curses.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>
#include <termios.h>
#include <unistd.h>

#include "../common/common.h"
#include "../vi/vi.h"
#include "cl.h"

/*
 * cl_addstr --
 *	Add len bytes from the string at the cursor, advancing the cursor.
 *
 * PUBLIC: int cl_addstr(SCR *, const char *, size_t);
 */
int
cl_addstr(SCR *sp, const char *str, size_t len)
{
	size_t oldy, oldx;
	int iv;

	/*
	 * If ex isn't in control, it's the last line of the screen and
	 * it's a split screen, use inverse video.
	 */
	iv = 0;
	getyx(stdscr, oldy, oldx);
	if (!F_ISSET(sp, SC_SCR_EXWROTE) &&
	    oldy == RLNO(sp, LASTLINE(sp)) && IS_SPLIT(sp)) {
		iv = 1;
		(void)standout();
	}

	if (addnstr(str, len) == ERR)
		return (1);

	if (iv)
		(void)standend();
	return (0);
}

/*
 * cl_attr --
 *	Toggle a screen attribute on/off.
 *
 * PUBLIC: int cl_attr(SCR *, scr_attr_t, int);
 */
int
cl_attr(SCR *sp, scr_attr_t attribute, int on)
{
	CL_PRIVATE *clp;

	clp = CLP(sp);

	switch (attribute) {
	case SA_ALTERNATE:
	/*
	 * !!!
	 * There's a major layering violation here.  The problem is that the
	 * X11 xterm screen has what's known as an "alternate" screen.  Some
	 * xterm termcap/terminfo entries include sequences to switch to/from
	 * that alternate screen as part of the ti/te (smcup/rmcup) strings.
	 * Vi runs in the alternate screen, so that you are returned to the
	 * same screen contents on exit from vi that you had when you entered
	 * vi.  Further, when you run :shell, or :!date or similar ex commands,
	 * you also see the original screen contents.  This wasn't deliberate
	 * on vi's part, it's just that it historically sent terminal init/end
	 * sequences at those times, and the addition of the alternate screen
	 * sequences to the strings changed the behavior of vi.  The problem
	 * caused by this is that we don't want to switch back to the alternate
	 * screen while getting a new command from the user, when the user is
	 * continuing to enter ex commands, e.g.:
	 *
	 *	:!date				<<< switch to original screen
	 *	[Hit return to continue]	<<< prompt user to continue
	 *	:command			<<< get command from user
	 *
	 * Note that the :command input is a true vi input mode, e.g., input
	 * maps and abbreviations are being done.  So, we need to be able to
	 * switch back into the vi screen mode, without flashing the screen. 
	 *
	 * To make matters worse, the curses initscr() and endwin() calls will
	 * do this automatically -- so, this attribute isn't as controlled by
	 * the higher level screen as closely as one might like.
	 */
	if (on) {
		if (clp->ti_te != TI_SENT) {
			clp->ti_te = TI_SENT;
			if (clp->smcup == NULL)
				(void)cl_getcap(sp, "smcup", &clp->smcup);
			if (clp->smcup != NULL)
				(void)tputs(clp->smcup, 1, cl_putchar);
		}
	} else
		if (clp->ti_te != TE_SENT) {
			clp->ti_te = TE_SENT;
			if (clp->rmcup == NULL)
				(void)cl_getcap(sp, "rmcup", &clp->rmcup);
			if (clp->rmcup != NULL)
				(void)tputs(clp->rmcup, 1, cl_putchar);
			(void)fflush(stdout);
		}
		(void)fflush(stdout);
		break;
	case SA_INVERSE:
		if (F_ISSET(sp, SC_EX | SC_SCR_EXWROTE)) {
			if (clp->smso == NULL)
				return (1);
			if (on)
				(void)tputs(clp->smso, 1, cl_putchar);
			else
				(void)tputs(clp->rmso, 1, cl_putchar);
			(void)fflush(stdout);
		} else {
			if (on)
				(void)standout();
			else
				(void)standend();
		}
		break;
	default:
		abort();
	}
	return (0);
}

/*
 * cl_baud --
 *	Return the baud rate.
 *
 * PUBLIC: int cl_baud(SCR *, u_long *);
 */
int
cl_baud(SCR *sp, u_long *ratep)
{
	CL_PRIVATE *clp;

	/*
	 * XXX
	 * There's no portable way to get a "baud rate" -- cfgetospeed(3)
	 * returns the value associated with some #define, which we may
	 * never have heard of, or which may be a purely local speed.  Vi
	 * only cares if it's SLOW (w300), slow (w1200) or fast (w9600).
	 * Try and detect the slow ones, and default to fast.
	 */
	clp = CLP(sp);
	switch (cfgetospeed(&clp->orig)) {
	case B50:
	case B75:
	case B110:
	case B134:
	case B150:
	case B200:
	case B300:
	case B600:
		*ratep = 600;
		break;
	case B1200:
		*ratep = 1200;
		break;
	default:
		*ratep = 9600;
		break;
	}
	return (0);
}

/*
 * cl_bell --
 *	Ring the bell/flash the screen.
 *
 * PUBLIC: int cl_bell(SCR *);
 */
int
cl_bell(SCR *sp)
{
	if (F_ISSET(sp, SC_EX | SC_SCR_EXWROTE))
		(void)write(STDOUT_FILENO, "\07", 1);		/* \a */
	else {
		/*
		 * If the screen has not been setup we cannot call
		 * curses routines yet.
		 */
		if (F_ISSET(sp, SC_SCR_VI)) {
			/*
			 * Vi has an edit option which determines if the
			 * terminal should be beeped or the screen flashed.
			 */
			if (O_ISSET(sp, O_FLASH))
				(void)flash();
			else
				(void)beep();
		} else if (!O_ISSET(sp, O_FLASH))
			(void)write(STDOUT_FILENO, "\07", 1);
	}
	return (0);
}

/*
 * cl_clrtoeol --
 *	Clear from the current cursor to the end of the line.
 *
 * PUBLIC: int cl_clrtoeol(SCR *);
 */
int
cl_clrtoeol(SCR *sp)
{
	return (clrtoeol() == ERR);
}

/*
 * cl_cursor --
 *	Return the current cursor position.
 *
 * PUBLIC: int cl_cursor(SCR *, size_t *, size_t *);
 */
int
cl_cursor(SCR *sp, size_t *yp, size_t *xp)
{
	/*
	 * The curses screen support splits a single underlying curses screen
	 * into multiple screens to support split screen semantics.  For this
	 * reason the returned value must be adjusted to be relative to the
	 * current screen, and not absolute.  Screens that implement the split
	 * using physically distinct screens won't need this hack.
	 */
	getyx(stdscr, *yp, *xp);
	*yp -= sp->woff;
	return (0);
}

/*
 * cl_deleteln --
 *	Delete the current line, scrolling all lines below it.
 *
 * PUBLIC: int cl_deleteln(SCR *);
 */
int
cl_deleteln(SCR *sp)
{
	size_t oldy, oldx;

	/*
	 * This clause is required because the curses screen uses reverse
	 * video to delimit split screens.  If the screen does not do this,
	 * this code won't be necessary.
	 *
	 * If the bottom line was in reverse video, rewrite it in normal
	 * video before it's scrolled.
	 *
	 * Check for the existence of a chgat function; XSI requires it, but
	 * historic implementations of System V curses don't.   If it's not
	 * a #define, we'll fall back to doing it by hand, which is slow but
	 * acceptable.
	 *
	 * By hand means walking through the line, retrieving and rewriting
	 * each character.  Curses has no EOL marker, so track strings of
	 * spaces, and copy the trailing spaces only if there's a non-space
	 * character following.
	 */
	if (!F_ISSET(sp, SC_SCR_EXWROTE) && IS_SPLIT(sp)) {
		getyx(stdscr, oldy, oldx);
		mvchgat(RLNO(sp, LASTLINE(sp)), 0, -1, A_NORMAL, 0, NULL);
		(void)move(oldy, oldx);
	}

	/*
	 * The bottom line is expected to be blank after this operation,
	 * and other screens must support that semantic.
	 */
	return (deleteln() == ERR);
}

/* 
 * cl_ex_adjust --
 *	Adjust the screen for ex.  This routine is purely for standalone
 *	ex programs.  All special purpose, all special case.
 *
 * PUBLIC: int cl_ex_adjust(SCR *, exadj_t);
 */
int
cl_ex_adjust(SCR *sp, exadj_t action)
{
	CL_PRIVATE *clp;
	int cnt;

	clp = CLP(sp);
	switch (action) {
	case EX_TERM_SCROLL:
		/* Move the cursor up one line if that's possible. */
		if (clp->cuu1 != NULL)
			(void)tputs(clp->cuu1, 1, cl_putchar);
		else if (clp->cup != NULL)
			(void)tputs(tgoto(clp->cup,
			    0, LINES - 2), 1, cl_putchar);
		else
			return (0);
		/* FALLTHROUGH */
	case EX_TERM_CE:
		/* Clear the line. */
		if (clp->el != NULL) {
			(void)putchar('\r');
			(void)tputs(clp->el, 1, cl_putchar);
		} else {
			/*
			 * Historically, ex didn't erase the line, so, if the
			 * displayed line was only a single glyph, and <eof>
			 * was more than one glyph, the output would not fully
			 * overwrite the user's input.  To fix this, output
			 * the maxiumum character number of spaces.  Note,
			 * this won't help if the user entered extra prompt
			 * or <blank> characters before the command character.
			 * We'd have to do a lot of work to make that work, and
			 * it's almost certainly not worth the effort.
			 */
			for (cnt = 0; cnt < MAX_CHARACTER_COLUMNS; ++cnt)
				(void)putchar('\b');
			for (cnt = 0; cnt < MAX_CHARACTER_COLUMNS; ++cnt)
				(void)putchar(' ');
			(void)putchar('\r');
			(void)fflush(stdout);
		}
		break;
	default:
		abort();
	}
	return (0);
}

/*
 * cl_insertln --
 *	Push down the current line, discarding the bottom line.
 *
 * PUBLIC: int cl_insertln(SCR *);
 */
int
cl_insertln(SCR *sp)
{
	/*
	 * The current line is expected to be blank after this operation,
	 * and the screen must support that semantic.
	 */
	return (insertln() == ERR);
}

/*
 * cl_keyval --
 *	Return the value for a special key.
 *
 * PUBLIC: int cl_keyval(SCR *, scr_keyval_t, CHAR_T *, int *);
 */
int
cl_keyval(SCR *sp, scr_keyval_t val, CHAR_T *chp, int *dnep)
{
	CL_PRIVATE *clp;

	/*
	 * VEOF, VERASE and VKILL are required by POSIX 1003.1-1990,
	 * VWERASE is a 4BSD extension.
	 */
	clp = CLP(sp);
	switch (val) {
	case KEY_VEOF:
		*dnep = (*chp = clp->orig.c_cc[VEOF]) == _POSIX_VDISABLE;
		break;
	case KEY_VERASE:
		*dnep = (*chp = clp->orig.c_cc[VERASE]) == _POSIX_VDISABLE;
		break;
	case KEY_VKILL:
		*dnep = (*chp = clp->orig.c_cc[VKILL]) == _POSIX_VDISABLE;
		break;
	case KEY_VWERASE:
		*dnep = (*chp = clp->orig.c_cc[VWERASE]) == _POSIX_VDISABLE;
		break;
	default:
		*dnep = 1;
		break;
	}
	return (0);
}

/*
 * cl_move --
 *	Move the cursor.
 *
 * PUBLIC: int cl_move(SCR *, size_t, size_t);
 */
int
cl_move(SCR *sp, size_t lno, size_t cno)
{
	/* See the comment in cl_cursor. */
	if (move(RLNO(sp, lno), cno) == ERR) {
		msgq(sp, M_ERR,
		    "Error: move: l(%u) c(%u) o(%u)", lno, cno, sp->woff);
		return (1);
	}
	return (0);
}

/*
 * cl_refresh --
 *	Refresh the screen.
 *
 * PUBLIC: int cl_refresh(SCR *, int);
 */
int
cl_refresh(SCR *sp, int repaint)
{
	CL_PRIVATE *clp;

	clp = CLP(sp);

	/*
	 * If we received a killer signal, we're done, there's no point
	 * in refreshing the screen.
	 */
	if (clp->killersig)
		return (0);

	/*
	 * If repaint is set, the editor is telling us that we don't know
	 * what's on the screen, so we have to repaint from scratch.
	 *
	 * In the curses library, doing wrefresh(curscr) is okay, but the
	 * screen flashes when we then apply the refresh() to bring it up
	 * to date.  So, use clearok().
	 */
	if (repaint)
		clearok(curscr, 1);
	return (refresh() == ERR);
}

/*
 * cl_rename --
 *	Rename the file.
 *
 * PUBLIC: int cl_rename(SCR *, char *, int);
 */
int
cl_rename(SCR *sp, char *name, int on)
{
	GS *gp;
	CL_PRIVATE *clp;
	char *ttype;

	gp = sp->gp;
	clp = CLP(sp);

	ttype = OG_STR(gp, GO_TERM);

	/*
	 * XXX
	 * We can only rename windows for xterm.
	 */
	if (on) {
		if (F_ISSET(clp, CL_RENAME_OK) &&
		    !strncmp(ttype, "xterm", sizeof("xterm") - 1)) {
			F_SET(clp, CL_RENAME);
			(void)printf(XTERM_RENAME, name);
			(void)fflush(stdout);
		}
	} else
		if (F_ISSET(clp, CL_RENAME)) {
			F_CLR(clp, CL_RENAME);
			(void)printf(XTERM_RENAME, ttype);
			(void)fflush(stdout);
		}
	return (0);
}

/*
 * cl_suspend --
 *	Suspend a screen.
 *
 * PUBLIC: int cl_suspend(SCR *, int *);
 */
int
cl_suspend(SCR *sp, int *allowedp)
{
	struct termios t;
	CL_PRIVATE *clp;
	size_t oldy, oldx;
	int changed;

	clp = CLP(sp);
	*allowedp = 1;

	/*
	 * The ex implementation of this function isn't needed by screens not
	 * supporting ex commands that require full terminal canonical mode
	 * (e.g. :suspend).
	 *
	 * The vi implementation of this function isn't needed by screens not
	 * supporting vi process suspension, i.e. any screen that isn't backed
	 * by a UNIX shell.
	 *
	 * Setting allowedp to 0 will cause the editor to reject the command.
	 */
	if (F_ISSET(sp, SC_EX)) { 
		/* Save the terminal settings, and restore the original ones. */
		if (F_ISSET(clp, CL_STDIN_TTY)) {
			(void)tcgetattr(STDIN_FILENO, &t);
			(void)tcsetattr(STDIN_FILENO,
			    TCSASOFT | TCSADRAIN, &clp->orig);
		}

		/* Stop the process group. */
		(void)kill(0, SIGTSTP);

		/* Time passes ... */

		/* Restore terminal settings. */
		if (F_ISSET(clp, CL_STDIN_TTY))
			(void)tcsetattr(STDIN_FILENO, TCSASOFT | TCSADRAIN, &t);
		return (0);
	}

	/*
	 * Move to the lower left-hand corner of the screen.
	 *
	 * XXX
	 * Not sure this is necessary in System V implementations, but it
	 * shouldn't hurt.
	 */
	getyx(stdscr, oldy, oldx);
	(void)move(LINES - 1, 0);
	(void)refresh();

	/*
	 * Temporarily end the screen.  System V introduced a semantic where
	 * endwin() could be restarted.  We use it because restarting curses
	 * from scratch often fails in System V.
	 */

	/* Restore the cursor keys to normal mode. */
	(void)keypad(stdscr, FALSE);

	/* Restore the window name. */
	(void)cl_rename(sp, NULL, 0);

	(void)endwin();

	/*
	 * XXX
	 * Restore the original terminal settings.  This is bad -- the
	 * reset can cause character loss from the tty queue.  However,
	 * we can't call endwin() in BSD curses implementations, and too
	 * many System V curses implementations don't get it right.
	 */
	(void)tcsetattr(STDIN_FILENO, TCSADRAIN | TCSASOFT, &clp->orig);

	/* Stop the process group. */
	(void)kill(0, SIGTSTP);

	/* Time passes ... */

	/*
	 * If we received a killer signal, we're done.  Leave everything
	 * unchanged.  In addition, the terminal has already been reset
	 * correctly, so leave it alone.
	 */
	if (clp->killersig) {
		F_CLR(clp, CL_SCR_EX_INIT | CL_SCR_VI_INIT);
		return (0);
	}

	/* Set the window name. */
	(void)cl_rename(sp, sp->frp->name, 1);

	/* Put the cursor keys into application mode. */
	(void)keypad(stdscr, TRUE);

	/* Refresh and repaint the screen. */
	(void)move(oldy, oldx);
	(void)cl_refresh(sp, 1);

	/* If the screen changed size, set the SIGWINCH bit. */
	if (cl_ssize(sp, 1, NULL, NULL, &changed))
		return (1);
	if (changed)
		F_SET(CLP(sp), CL_SIGWINCH);

	return (0);
}

/*
 * cl_usage --
 *	Print out the curses usage messages.
 * 
 * PUBLIC: void cl_usage(void);
 */
void
cl_usage()
{
	switch (pmode) {
	case MODE_EX:
		(void)fprintf(stderr, "usage: "
		    "ex [-FRrSsv] [-c cmd] [-t tag] [-w size] [file ...]\n");
		break;
	case MODE_VI:
		(void)fprintf(stderr, "usage: "
		    "vi [-eFRrS] [-c cmd] [-t tag] [-w size] [file ...]\n");
		break;
	case MODE_VIEW:
		(void)fprintf(stderr, "usage: "
		    "view [-eFrS] [-c cmd] [-t tag] [-w size] [file ...]\n");
		break;
	}
}

#ifdef DEBUG
/*
 * gdbrefresh --
 *	Stub routine so can flush out curses screen changes using gdb.
 */
int
gdbrefresh()
{
	refresh();
	return (0);		/* XXX Convince gdb to run it. */
}
#endif
@


1.19
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d373 1
a373 1
 * PUBLIC: int cl_keyval(SCR *, scr_keyval_t, unsigned char *, int *);
d376 1
a376 1
cl_keyval(SCR *sp, scr_keyval_t val, unsigned char *chp, int *dnep)
@


1.18
log
@Remove SA_INTERRUPT, HISTORIC_PRACTICE, and HISTORICAL_PRACTICE using
unifdef. It seems clear that no one was using these (SA_INTERRUPT didn't
even build the other way). Tweak comments as appropriate.

ok brynet@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.17 2014/11/12 16:29:04 millert Exp $	*/
d373 1
a373 1
 * PUBLIC: int cl_keyval(SCR *, scr_keyval_t, CHAR_T *, int *);
d376 1
a376 1
cl_keyval(SCR *sp, scr_keyval_t val, CHAR_T *chp, int *dnep)
@


1.17
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.16 2014/11/12 04:28:41 bentley Exp $	*/
a263 4
#ifndef mvchgat
	CHAR_T ch;
	size_t col, lno, spcnt;
#endif
@


1.16
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.15 2014/11/06 10:48:52 bentley Exp $	*/
a289 1
#ifdef mvchgat
a290 16
#else
		for (lno = RLNO(sp, LASTLINE(sp)), col = spcnt = 0;;) {
			(void)move(lno, col);
			ch = winch(stdscr);
			if (isblank(ch))
				++spcnt;
			else {
				(void)move(lno, col - spcnt);
				for (; spcnt > 0; --spcnt)
					(void)addch(' ');
				(void)addch(ch);
			}
			if (++col >= sp->cols)
				break;
		}
#endif
a398 1
#ifdef VWERASE
a401 1
#endif
@


1.15
log
@Remove old curses support in vi.

ok nicm@@ millert@@ plus a comment tweak from nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.14 2009/10/27 23:59:47 deraadt Exp $	*/
d40 1
a40 4
cl_addstr(sp, str, len)
	SCR *sp;
	const char *str;
	size_t len;
d72 1
a72 4
cl_attr(sp, attribute, on)
	SCR *sp;
	scr_attr_t attribute;
	int on;
d157 1
a157 3
cl_baud(sp, ratep)
	SCR *sp;
	u_long *ratep;
d198 1
a198 2
cl_bell(sp)
	SCR *sp;
d229 1
a229 2
cl_clrtoeol(sp)
	SCR *sp;
d241 1
a241 3
cl_cursor(sp, yp, xp)
	SCR *sp;
	size_t *yp, *xp;
d262 1
a262 2
cl_deleteln(sp)
	SCR *sp;
d326 1
a326 3
cl_ex_adjust(sp, action)
	SCR *sp;
	exadj_t action;
d381 1
a381 2
cl_insertln(sp)
	SCR *sp;
d397 1
a397 5
cl_keyval(sp, val, chp, dnep)
	SCR *sp;
	scr_keyval_t val;
	CHAR_T *chp;
	int *dnep;
d435 1
a435 3
cl_move(sp, lno, cno)
	SCR *sp;
	size_t lno, cno;
d453 1
a453 3
cl_refresh(sp, repaint)
	SCR *sp;
	int repaint;
d486 1
a486 4
cl_rename(sp, name, on)
	SCR *sp;
	char *name;
	int on;
d524 1
a524 3
cl_suspend(sp, allowedp)
	SCR *sp;
	int *allowedp;
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.13 2009/01/28 13:02:22 sobrado Exp $	*/
d607 2
a608 8
	 * from scratch often fails in System V.  4BSD curses didn't support
	 * restarting after endwin(), so we have to do what clean up we can
	 * without calling it.
	 */
#ifdef HAVE_BSD_CURSES
	/* Save the terminal settings. */
	(void)tcgetattr(STDIN_FILENO, &t);
#endif
a615 3
#ifdef HAVE_BSD_CURSES
	(void)cl_attr(sp, SA_ALTERNATE, 0);
#else
d617 1
a617 1
#endif
a640 8

#ifdef HAVE_BSD_CURSES
	/* Restore terminal settings. */
	if (F_ISSET(clp, CL_STDIN_TTY))
		(void)tcsetattr(STDIN_FILENO, TCSASOFT | TCSADRAIN, &t);

	(void)cl_attr(sp, SA_ALTERNATE, 1);
#endif
@


1.13
log
@ex(1), vi(1), and view(1) have different synopses; each nex/nvi utility
should manage the right set of options and return an appropriate usage
when required.

jsing@@ has suggested preserving "-e" in ex(1) as an undocumented
compatibility flag to avoid breaking silly scripts that may use this
option with the line-oriented editor.

diff sent upstream to nex/nvi maintainers.

ok ("put it in!") jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.12 2006/04/22 03:09:15 ray Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)cl_funcs.c	10.50 (Berkeley) 9/24/96";
#endif /* not lint */
@


1.12
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.11 2006/03/11 06:58:00 ray Exp $	*/
d691 14
a704 5
#define	USAGE "\
usage: ex [-eFRrSsv] [-c command] [-t tag] [-w size] [file ...]\n\
usage: vi [-eFlRrSv] [-c command] [-t tag] [-w size] [file ...]\n"
	(void)fprintf(stderr, "%s", USAGE);
#undef	USAGE
@


1.11
log
@Silence 39 warnings.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.10 2003/07/18 23:11:43 david Exp $	*/
a48 1
	CL_PRIVATE *clp;
a51 2
	clp = CLP(sp);

a284 1
	CL_PRIVATE *clp;
a286 2
	clp = CLP(sp);

a560 1
	GS *gp;
a563 1
	gp = sp->gp;
@


1.10
log
@add missing includes
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.9 2002/02/16 21:27:56 millert Exp $	*/
d284 1
d286 2
d289 1
a289 1
	size_t col, lno, spcnt, oldy, oldx;
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_funcs.c,v 1.8 2001/01/29 01:58:27 niklas Exp $	*/
d29 1
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
 * PUBLIC: int cl_addstr __P((SCR *, const char *, size_t));
d78 1
a78 1
 * PUBLIC: int cl_attr __P((SCR *, scr_attr_t, int));
d166 1
a166 1
 * PUBLIC: int cl_baud __P((SCR *, u_long *));
d209 1
a209 1
 * PUBLIC: int cl_bell __P((SCR *));
d241 1
a241 1
 * PUBLIC: int cl_clrtoeol __P((SCR *));
d254 1
a254 1
 * PUBLIC: int cl_cursor __P((SCR *, size_t *, size_t *));
d277 1
a277 1
 * PUBLIC: int cl_deleteln __P((SCR *));
d342 1
a342 1
 * PUBLIC: int cl_ex_adjust __P((SCR *, exadj_t));
d399 1
a399 1
 * PUBLIC: int cl_insertln __P((SCR *));
d416 1
a416 1
 * PUBLIC: int cl_keyval __P((SCR *, scr_keyval_t, CHAR_T *, int *));
d458 1
a458 1
 * PUBLIC: int cl_move __P((SCR *, size_t, size_t));
d478 1
a478 1
 * PUBLIC: int cl_refresh __P((SCR *, int));
d513 1
a513 1
 * PUBLIC: int cl_rename __P((SCR *, char *, int));
d554 1
a554 1
 * PUBLIC: int cl_suspend __P((SCR *, int *));
d690 1
a690 1
 * PUBLIC: void cl_usage __P((void));
@


1.7
log
@Don't call curses routines beep() or flash() if the screen has not been
setup yet (as they will try to us SP which is NULL at this point).
@
text
@d1 2
@


1.6
log
@-D_USE_OLD_CURSE_ for -locurses and no more -ltermlib/termcap
@
text
@d217 2
a218 2
		 * Vi has an edit option which determines if the terminal
		 * should be beeped or the screen flashed.
d220 11
a230 4
		if (O_ISSET(sp, O_FLASH))
			(void)flash();
		else
			(void)beep();
@


1.5
log
@Make building with ocurses/termcap and curses/termlib conditional on
USE_OCURSES being defined, and define it for now.  This switches nvi back
to use BSD curses.
@
text
@a21 3
#ifdef USE_OCURSES
#include <ocurses.h>
#else
a22 1
#endif
@


1.4
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d22 3
d26 1
@


1.3
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_funcs.c	10.48 (Berkeley) 8/11/96";
d575 1
a575 1
		if (F_ISSET(gp, G_STDIN_TTY)) {
d587 1
a587 1
		if (F_ISSET(gp, G_STDIN_TTY))
d652 1
a652 1
	if (F_ISSET(gp, G_STDIN_TTY))
d687 2
a688 2
usage: ex [-eFRrsv] [-c command] [-t tag] [-w size] [file ...]\n\
usage: vi [-eFlRrv] [-c command] [-t tag] [-w size] [file ...]\n"
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_funcs.c	10.45 (Berkeley) 6/26/96";
d476 11
d504 1
a504 1
 * PUBLIC: int cl_rename __P((SCR *));
d507 1
a507 1
cl_rename(sp)
d509 2
d523 1
a523 3
	 * We can only rename windows for xterm.  Since it's destructive (we
	 * can't restore it to its original value on exit) we have to get the
	 * user's permission.
d525 3
a527 2
	if (O_ISSET(sp, O_WINDOWNAME)) {
		if (!strncmp(ttype, "xterm", sizeof("xterm") - 1)) {
d529 1
a529 1
			(void)printf(XTERM_RENAME, sp->frp->name);
d618 3
d640 10
d657 4
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_funcs.c	10.40 (Berkeley) 5/16/96";
d86 2
d89 49
a139 1
			clp = CLP(sp);
d499 28
a526 1
	return (0);			/* Curses doesn't care. */
d607 1
a607 6
	/* Send the terminal end sequence. */
	if (clp->rmcup == NULL)
		(void)cl_getcap(sp, "rmcup", &clp->rmcup);
	if (clp->rmcup != NULL)
		(void)tputs(clp->rmcup, 1, cl_putchar);
	(void)fflush(stdout);
d630 1
a630 6
	/* Send the terminal initialization sequence. */
	if (clp->smcup == NULL)
		(void)cl_getcap(sp, "smcup", &clp->smcup);
	if (clp->smcup != NULL)
		(void)tputs(clp->smcup, 1, cl_putchar);
	(void)fflush(stdout);
@
