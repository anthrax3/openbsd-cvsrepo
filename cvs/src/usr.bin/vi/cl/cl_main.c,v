head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.20.0.22
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.20
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.33
date	2016.05.05.20.36.41;	author martijn;	state Exp;
branches;
next	1.32;
commitid	VfmAQGwuffDtJBXt;

1.32
date	2016.04.20.19.34.32;	author martijn;	state Exp;
branches;
next	1.31;
commitid	6JqwppOyxgwLawKY;

1.31
date	2016.02.03.01.47.25;	author mmcc;	state Exp;
branches;
next	1.30;
commitid	VKVsS1OkAAi8PXjr;

1.30
date	2016.01.30.21.23.50;	author martijn;	state Exp;
branches;
next	1.29;
commitid	coLzsk3wkJh1a1Ez;

1.29
date	2016.01.27.22.38.12;	author martijn;	state Exp;
branches;
next	1.28;
commitid	2EVcqCAtmkfHHe4i;

1.28
date	2015.12.28.19.24.01;	author millert;	state Exp;
branches;
next	1.27;
commitid	Y5iunogl9ZJjj85H;

1.27
date	2015.12.07.20.39.19;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	gtDERb7QyXwKGs62;

1.26
date	2015.03.29.01.04.23;	author bcallah;	state Exp;
branches;
next	1.25;
commitid	KcEgXMM3P7dpQPm7;

1.25
date	2014.11.19.03.42.40;	author bentley;	state Exp;
branches;
next	1.24;
commitid	d8EyT0pmlGbtwZho;

1.24
date	2014.11.14.20.27.03;	author tedu;	state Exp;
branches;
next	1.23;
commitid	aIZ8ZvbLlUW9obxb;

1.23
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.22;
commitid	T0XpHzXjuQBl1V3E;

1.22
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.21;
commitid	06bi6U3x4gFFf2G1;

1.21
date	2014.11.10.21.34.13;	author tedu;	state Exp;
branches;
next	1.20;
commitid	0tOVvbQZwZhXaItv;

1.20
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.28.17.58.20;	author jasper;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.11.06.58.00;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.18.23.11.43;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.17.19.42.33;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.29.01.58.27;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.11.26.22.49.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.03.06.20.27.43;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.03.06.20.19.23;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.24.00.07.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.23.07.12.44;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.07.27.22.28.05;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.01.18.10;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.17.58.16;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.15.14;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.33.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Remove __sigblockset. This is a leftover after the removal of the signal
blocking code in common/gs.h rev 1.14.

Remove a redundant return while here.

OK millert@@
@
text
@/*	$OpenBSD: cl_main.c,v 1.32 2016/04/20 19:34:32 martijn Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <curses.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>
#include <termios.h>
#include <unistd.h>

#include "../common/common.h"
#include "cl.h"

GS *__global_list;				/* GLOBAL: List of screens. */

static void	   cl_func_std(GS *);
static CL_PRIVATE *cl_init(GS *);
static GS	  *gs_init(void);
static int	   setsig(int, struct sigaction *, void (*)(int));
static void	   sig_end(GS *);
static void	   term_init(char *);

/*
 * main --
 *	This is the main loop for the standalone curses editor.
 */
int
main(int argc, char *argv[])
{
	CL_PRIVATE *clp;
	GS *gp;
	size_t rows, cols;
	int rval;
	char *ttype;

	/* Create and initialize the global structure. */
	__global_list = gp = gs_init();

	/* Create and initialize the CL_PRIVATE structure. */
	clp = cl_init(gp);

	/*
	 * Initialize the terminal information.
	 *
	 * We have to know what terminal it is from the start, since we may
	 * have to use termcap/terminfo to find out how big the screen is.
	 */
	if ((ttype = getenv("TERM")) == NULL)
		ttype = "unknown";
	term_init(ttype);

	/* Add the terminal type to the global structure. */
	if ((OG_D_STR(gp, GO_TERM) =
	    OG_STR(gp, GO_TERM) = strdup(ttype)) == NULL)
		err(1, NULL);

	/* Figure out how big the screen is. */
	if (cl_ssize(NULL, 0, &rows, &cols, NULL))
		exit (1);

	/* Add the rows and columns to the global structure. */
	OG_VAL(gp, GO_LINES) = OG_D_VAL(gp, GO_LINES) = rows;
	OG_VAL(gp, GO_COLUMNS) = OG_D_VAL(gp, GO_COLUMNS) = cols;

	/* Ex wants stdout to be buffered. */
	(void)setvbuf(stdout, NULL, _IOFBF, 0);

	/* Start catching signals. */
	if (sig_init(gp, NULL))
		exit (1);

	/* Run ex/vi. */
	rval = editor(gp, argc, argv);

	/* Clean up signals. */
	sig_end(gp);

	/* Clean up the terminal. */
	(void)cl_quit(gp);

	/*
	 * XXX
	 * Reset the O_MESG option.
	 */
	if (clp->tgw != TGW_UNKNOWN)
		(void)cl_omesg(NULL, clp, clp->tgw == TGW_SET);

	/*
	 * XXX
	 * Reset the X11 xterm icon/window name.
	 */
	if (F_ISSET(clp, CL_RENAME)) {
		(void)printf(XTERM_RENAME, ttype);
		(void)fflush(stdout);
	}

	/* If a killer signal arrived, pretend we just got it. */
	if (clp->killersig) {
		(void)signal(clp->killersig, SIG_DFL);
		(void)kill(getpid(), clp->killersig);
		/* NOTREACHED */
	}

	/* Free the global and CL private areas. */
#if defined(DEBUG) || defined(PURIFY)
	free(clp);
	free(gp);
#endif

	exit (rval);
}

/*
 * gs_init --
 *	Create and partially initialize the GS structure.
 */
static GS *
gs_init(void)
{
	GS *gp;

	/* Allocate the global structure. */
	if ((gp = calloc(1, sizeof(GS))) == NULL)
		err(1, NULL);

	return (gp);
}

/*
 * cl_init --
 *	Create and partially initialize the CL structure.
 */
static CL_PRIVATE *
cl_init(GS *gp)
{
	CL_PRIVATE *clp;
	int fd;

	/* Allocate the CL private structure. */
	if ((clp = calloc(1, sizeof(CL_PRIVATE))) == NULL)
		err(1, NULL);
	gp->cl_private = clp;

	/*
	 * Set the CL_STDIN_TTY flag.  It's purpose is to avoid setting
	 * and resetting the tty if the input isn't from there.  We also
	 * use the same test to determine if we're running a script or
	 * not.
	 */
	if (isatty(STDIN_FILENO))
		F_SET(clp, CL_STDIN_TTY);
	else
		F_SET(gp, G_SCRIPTED);

	/*
	 * We expect that if we've lost our controlling terminal that the
	 * open() (but not the tcgetattr()) will fail.
	 */
	if (F_ISSET(clp, CL_STDIN_TTY)) {
		if (tcgetattr(STDIN_FILENO, &clp->orig) == -1)
			goto tcfail;
	} else if ((fd = open(_PATH_TTY, O_RDONLY, 0)) != -1) {
		if (tcgetattr(fd, &clp->orig) == -1)
tcfail:			err(1, "tcgetattr");
		(void)close(fd);
	}

	/* Initialize the list of curses functions. */
	cl_func_std(gp);

	return (clp);
}

/*
 * term_init --
 *	Initialize terminal information.
 */
static void
term_init(char *ttype)
{
	int err;

	/* Set up the terminal database information. */
	setupterm(ttype, STDOUT_FILENO, &err);
	switch (err) {
	case -1:
		errx(1, "No terminal database found");
	case 0:
		errx(1, "%s: unknown terminal type", ttype);
	}
}

#define	GLOBAL_CLP \
	CL_PRIVATE *clp = GCLP(__global_list);
static void
h_hup(int signo)
{
	GLOBAL_CLP;

	F_SET(clp, CL_SIGHUP);
	clp->killersig = SIGHUP;
}

static void
h_int(int signo)
{
	GLOBAL_CLP;

	F_SET(clp, CL_SIGINT);
}

static void
h_term(int signo)
{
	GLOBAL_CLP;

	F_SET(clp, CL_SIGTERM);
	clp->killersig = SIGTERM;
}

static void
h_winch(int signo)
{
	GLOBAL_CLP;

	F_SET(clp, CL_SIGWINCH);
}
#undef	GLOBAL_CLP

/*
 * sig_init --
 *	Initialize signals.
 *
 * PUBLIC: int sig_init(GS *, SCR *);
 */
int
sig_init(GS *gp, SCR *sp)
{
	CL_PRIVATE *clp;

	clp = GCLP(gp);

	if (sp == NULL) {
		if (setsig(SIGHUP, &clp->oact[INDX_HUP], h_hup) ||
		    setsig(SIGINT, &clp->oact[INDX_INT], h_int) ||
		    setsig(SIGTERM, &clp->oact[INDX_TERM], h_term) ||
		    setsig(SIGWINCH, &clp->oact[INDX_WINCH], h_winch)
		    )
			err(1, NULL);
	} else
		if (setsig(SIGHUP, NULL, h_hup) ||
		    setsig(SIGINT, NULL, h_int) ||
		    setsig(SIGTERM, NULL, h_term) ||
		    setsig(SIGWINCH, NULL, h_winch)
		    ) {
			msgq(sp, M_SYSERR, "signal-reset");
		}
	return (0);
}

/*
 * setsig --
 *	Set a signal handler.
 */
static int
setsig(int signo, struct sigaction *oactp, void (*handler)(int))
{
	struct sigaction act;

	/*
	 * Use sigaction(2), not signal(3), since we don't always want to
	 * restart system calls.  The example is when waiting for a command
	 * mode keystroke and SIGWINCH arrives.  Besides, you can't portably
	 * restart system calls (thanks, POSIX!).
	 */
	act.sa_handler = handler;
	sigemptyset(&act.sa_mask);

	act.sa_flags = 0;
	return (sigaction(signo, &act, oactp));
}

/*
 * sig_end --
 *	End signal setup.
 */
static void
sig_end(GS *gp)
{
	CL_PRIVATE *clp;

	clp = GCLP(gp);
	(void)sigaction(SIGHUP, NULL, &clp->oact[INDX_HUP]);
	(void)sigaction(SIGINT, NULL, &clp->oact[INDX_INT]);
	(void)sigaction(SIGTERM, NULL, &clp->oact[INDX_TERM]);
	(void)sigaction(SIGWINCH, NULL, &clp->oact[INDX_WINCH]);
}

/*
 * cl_func_std --
 *	Initialize the standard curses functions.
 */
static void
cl_func_std(GS *gp)
{
	gp->scr_addstr = cl_addstr;
	gp->scr_attr = cl_attr;
	gp->scr_baud = cl_baud;
	gp->scr_bell = cl_bell;
	gp->scr_busy = NULL;
	gp->scr_clrtoeol = cl_clrtoeol;
	gp->scr_cursor = cl_cursor;
	gp->scr_deleteln = cl_deleteln;
	gp->scr_event = cl_event;
	gp->scr_ex_adjust = cl_ex_adjust;
	gp->scr_fmap = cl_fmap;
	gp->scr_insertln = cl_insertln;
	gp->scr_keyval = cl_keyval;
	gp->scr_move = cl_move;
	gp->scr_msg = NULL;
	gp->scr_optchange = cl_optchange;
	gp->scr_refresh = cl_refresh;
	gp->scr_rename = cl_rename;
	gp->scr_screen = cl_screen;
	gp->scr_suspend = cl_suspend;
	gp->scr_usage = cl_usage;
}
@


1.32
log
@Remove pointless reenter variable.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.31 2016/02/03 01:47:25 mmcc Exp $	*/
a34 1
sigset_t __sigblockset;				/* GLOBAL: Blocked signals. */
d264 1
a264 4
		(void)sigemptyset(&__sigblockset);
		if (sigaddset(&__sigblockset, SIGHUP) ||
		    setsig(SIGHUP, &clp->oact[INDX_HUP], h_hup) ||
		    sigaddset(&__sigblockset, SIGINT) ||
a265 1
		    sigaddset(&__sigblockset, SIGTERM) ||
a266 1
		    sigaddset(&__sigblockset, SIGWINCH) ||
d268 1
a268 1
		    ) {
a269 2
			return (1);
		}
@


1.31
log
@Remove needless alias macros for malloc and calloc. No binary change. I
got this upstreamed a few weeks ago.

ok tb (less a few style tweaks), martijn (who suggested style tweaks)
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.30 2016/01/30 21:23:50 martijn Exp $	*/
a50 1
	static int reenter;
a55 4

	/* If loaded at 0 and jumping through a NULL pointer, stop. */
	if (reenter++)
		abort();
@


1.30
log
@replace progname variable in gs structure with getprogname

OK zhuk@@ and tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.29 2016/01/27 22:38:12 martijn Exp $	*/
d149 1
a149 2
	CALLOC_NOMSG(NULL, gp, 1, sizeof(GS));
	if (gp == NULL)
d166 1
a166 2
	CALLOC_NOMSG(NULL, clp, 1, sizeof(CL_PRIVATE));
	if (clp == NULL)
@


1.29
log
@Replace fprintf+exit with errx. No functional change

OK zhuk@@ and schwarze@@
fine with me tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.28 2015/12/28 19:24:01 millert Exp $	*/
d39 1
a39 1
static GS	  *gs_init(char *);
d63 1
a63 1
	__global_list = gp = gs_init(argv[0]);
d144 1
a144 1
gs_init(char *name)
a146 5
	char *p;

	/* Figure out what our name is. */
	if ((p = strrchr(name, '/')) != NULL)
		name = p + 1;
a152 2

	gp->progname = name;
@


1.28
log
@Use err() instead of custom perr() function.  Also applied by nvi2
upstream.  From Martijn van Duren.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.27 2015/12/07 20:39:19 mmcc Exp $	*/
d42 1
a42 1
static void	   term_init(char *, char *);
d76 1
a76 1
	term_init(gp->progname, ttype);
d214 1
a214 1
term_init(char *name, char *ttype)
d222 1
a222 3
		(void)fprintf(stderr,
		    "%s: No terminal database found\n", name);
		exit (1);
d224 1
a224 3
		(void)fprintf(stderr,
		    "%s: %s: unknown terminal type\n", name, ttype);
		exit (1);
@


1.27
log
@Remove needless type casts and corresponding type parameters from
allocation macros. No binary change.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.26 2015/03/29 01:04:23 bcallah Exp $	*/
d19 1
a39 1
static void	   perr(char *, char *);
d81 1
a81 1
		perr(gp->progname, NULL);
d156 1
a156 1
		perr(name, NULL);
d176 1
a176 1
		perr(gp->progname, NULL);
d198 2
a199 4
		if (tcgetattr(fd, &clp->orig) == -1) {
tcfail:			perr(gp->progname, "tcgetattr");
			exit (1);
		}
d293 1
a293 1
			perr(gp->progname, NULL);
a372 14
}

/*
 * perr --
 *	Print system error.
 */
static void
perr(char *name, char *msg)
{
	(void)fprintf(stderr, "%s:", name);
	if (msg != NULL)
		(void)fprintf(stderr, "%s:", msg);
	(void)fprintf(stderr, "%s\n", strerror(errno));
	exit(1);
@


1.26
log
@Remove SA_INTERRUPT, HISTORIC_PRACTICE, and HISTORICAL_PRACTICE using
unifdef. It seems clear that no one was using these (SA_INTERRUPT didn't
even build the other way). Tweak comments as appropriate.

ok brynet@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.25 2014/11/19 03:42:40 bentley Exp $	*/
d154 1
a154 1
	CALLOC_NOMSG(NULL, gp, GS *, 1, sizeof(GS));
d174 1
a174 1
	CALLOC_NOMSG(NULL, clp, CL_PRIVATE *, 1, sizeof(CL_PRIVATE));
@


1.25
log
@Remove ifdef checks for LIBRARY.
It is undocumented and triggers the same conditional inclusions as
PURIFY does.

From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.24 2014/11/14 20:27:03 tedu Exp $	*/
d322 1
a322 6
	 * restart system calls (thanks, POSIX!).  On the other hand, you
	 * can't portably NOT restart system calls (thanks, Sun!).  SunOS
	 * used SA_INTERRUPT as their extension to NOT restart read calls.
	 * We sure hope nobody else used it for anything else.  Mom told me
	 * there'd be days like this.  She just never told me that there'd
	 * be so many.
a326 3
#ifdef SA_INTERRUPT
	act.sa_flags = SA_INTERRUPT;
#else
a327 1
#endif
@


1.24
log
@from natano:
_PATH_BSHELL, _PATH_SENDMAIL, _PATH_TMP and _PATH_TTY are defined in
<paths.h> and _PATH_SYSV_TTY is unused. All of them can be removed from
pathnames.h. The other defines can be made unconditionally.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.23 2014/11/12 16:29:04 millert Exp $	*/
d131 1
a131 1
#if defined(DEBUG) || defined(PURIFY) || defined(LIBRARY)
@


1.23
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.22 2014/11/12 04:28:41 bentley Exp $	*/
d21 1
a31 1
#include "pathnames.h"
@


1.22
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.21 2014/11/10 21:34:13 tedu Exp $	*/
d291 1
a291 3
		    setsig(SIGTERM, &clp->oact[INDX_TERM], h_term)
#ifdef SIGWINCH
		    ||
a293 1
#endif
d301 1
a301 3
		    setsig(SIGTERM, NULL, h_term)
#ifdef SIGWINCH
		    ||
a302 1
#endif
a352 1
#ifdef SIGWINCH
a353 1
#endif
@


1.21
log
@remove ipc leftovers. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.20 2009/10/27 23:59:47 deraadt Exp $	*/
d144 1
a144 2
gs_init(name)
	char *name;
d168 1
a168 2
cl_init(gp)
	GS *gp;
d216 1
a216 2
term_init(name, ttype)
	char *name, *ttype;
d237 1
a237 2
h_hup(signo)
	int signo;
d246 1
a246 2
h_int(signo)
	int signo;
d254 1
a254 2
h_term(signo)
	int signo;
d263 1
a263 2
h_winch(signo)
	int signo;
d278 1
a278 3
sig_init(gp, sp)
	GS *gp;
	SCR *sp;
d320 1
a320 4
setsig(signo, oactp, handler)
	int signo;
	struct sigaction *oactp;
	void (*handler)(int);
d351 1
a351 2
sig_end(gp)
	GS *gp;
d369 1
a369 2
cl_func_std(gp)
	GS *gp;
d399 1
a399 2
perr(name, msg)
	char *name, *msg;
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.19 2008/03/28 17:58:20 jasper Exp $	*/
a29 3
#ifdef RUNNING_IP
#include "../ip/ip.h"
#endif
a56 4
#ifdef RUNNING_IP
	char *ip_arg;
	char **p_av, **t_av;
#endif
a64 41
	/*
	 * Strip out any arguments that vi isn't going to understand.  There's
	 * no way to portably call getopt twice, so arguments parsed here must
	 * be removed from the argument list.
	 */
#ifdef RUNNING_IP
	ip_arg = NULL;
	for (p_av = t_av = argv;;) {
		if (*t_av == NULL) {
			*p_av = NULL;
			break;
		}
		if (!strcmp(*t_av, "--")) {
			while ((*p_av++ = *t_av++) != NULL);
			break;
		}
		if (!memcmp(*t_av, "-I", sizeof("-I") - 1)) {
			if (t_av[0][2] != '\0') {
				ip_arg = t_av[0] + 2;
				++t_av;
				--argc;
				continue;
			}
			if (t_av[1] != NULL) {
				ip_arg = t_av[1];
				t_av += 2;
				argc -= 2;
				continue;
			}
		}
		*p_av++ = *t_av++;
	}

	/*
	 * If we're being called as an editor library, we're done here, we
	 * get loaded with the curses screen, we don't share much code.
	 */
	if (ip_arg != NULL)
		exit (ip_main(argc, argv, gp, ip_arg));
#endif
		
@


1.19
log
@- minor ansification
  from Gleydson Soares

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.18 2007/10/17 20:10:44 chl Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)cl_main.c	10.36 (Berkeley) 10/14/96";
#endif /* not lint */
@


1.18
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.17 2006/04/22 03:09:15 ray Exp $	*/
d56 1
a56 3
main(argc, argv)
	int argc;
	char *argv[];
@


1.17
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.16 2006/03/11 06:58:00 ray Exp $	*/
d65 1
a65 1
	char *ip_arg, *ttype;
d67 1
@


1.16
log
@Silence 39 warnings.

ok miod, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.15 2006/01/08 21:05:39 miod Exp $	*/
a115 2
#else
	ip_arg = argv[0];
@


1.15
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.14 2003/07/18 23:11:43 david Exp $	*/
d65 4
a68 1
	char *ip_arg, **p_av, **t_av, *ttype;
@


1.14
log
@add missing includes
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.13 2002/02/17 19:42:33 millert Exp $	*/
a198 1
	CL_PRIVATE *clp;
@


1.13
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.12 2002/02/16 21:27:56 millert Exp $	*/
d29 1
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_main.c,v 1.11 2001/01/29 01:58:27 niklas Exp $	*/
d46 1
a46 1
static int	   setsig __P((int, struct sigaction *, void (*)(int)));
@


1.11
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 4
a45 4
static void	   cl_func_std __P((GS *));
static CL_PRIVATE *cl_init __P((GS *));
static GS	  *gs_init __P((char *));
static void	   perr __P((char *, char *));
d47 2
a48 2
static void	   sig_end __P((GS *));
static void	   term_init __P((char *, char *));
d334 1
a334 1
 * PUBLIC: int sig_init __P((GS *, SCR *));
d384 1
a384 1
	void (*handler) __P((int));
@


1.10
log
@o Update README files etc. from nvi-1.79 so they have the correct info
o make port.h empty since we there is nothing we lack
o include <sys/param.h>, not <sys/types.h> in files that use MIN/MAX macros
o add perl api support since we have libperl (off by default)
@
text
@d1 2
@


1.9
log
@back out changes that should not have escaped my local tree
@
text
@d20 1
a22 1
#include <curses.h>
@


1.8
log
@add missing reference to infocmp
@
text
@a19 1
#include <curses.h>
d22 1
@


1.7
log
@-D_USE_OLD_CURSE_ for -locurses and no more -ltermlib/termcap
@
text
@d20 1
a22 1
#include <curses.h>
@


1.6
log
@Make building with ocurses/termcap and curses/termlib conditional on
USE_OCURSES being defined, and define it for now.  This switches nvi back
to use BSD curses.
@
text
@a21 3
#ifdef USE_OCURSES
#include <ocurses.h>
#else
a22 1
#endif
@


1.5
log
@Update to 1.79 and install as vi/ex/view.
@
text
@a19 1
#include <curses.h>
d22 5
@


1.4
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_main.c	10.35 (Berkeley) 9/24/96";
d43 1
a43 1
static void	   nomem __P((char *));
d130 1
a130 1
		nomem(gp->progname);
d207 1
a207 1
		nomem(name);
d228 1
a228 1
		nomem(gp->progname);
d251 1
a251 2
tcfail:			(void)fprintf(stderr, "%s: tcgetattr: %s\n",
			    gp->progname, strerror(errno));
d357 1
a357 2
			(void)fprintf(stderr,
			    "%s: %s\n", gp->progname, strerror(errno));
d459 2
a460 2
 * nomem --
 *	No memory error.
d463 2
a464 2
nomem(name)
	char *name;
d466 4
a469 1
	(void)fprintf(stderr, "%s: %s\n", name, strerror(errno));
@


1.3
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_main.c	10.33 (Berkeley) 8/11/96";
d31 1
a31 1
#ifdef notyet
d76 1
a76 1
#ifdef notyet
d232 4
a235 2
	 * Set the G_STDIN_TTY flag.  It's purpose is to avoid setting and
	 * resetting the tty if the input isn't from there.
d238 3
a240 1
		F_SET(gp, G_STDIN_TTY);
d246 1
a246 1
	if (F_ISSET(gp, G_STDIN_TTY)) {
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_main.c	10.32 (Berkeley) 7/1/96";
d40 1
a230 23
	/* Initialize the list of curses functions. */
	gp->scr_addstr = cl_addstr;
	gp->scr_attr = cl_attr;
	gp->scr_baud = cl_baud;
	gp->scr_bell = cl_bell;
	gp->scr_busy = NULL;
	gp->scr_clrtoeol = cl_clrtoeol;
	gp->scr_cursor = cl_cursor;
	gp->scr_deleteln = cl_deleteln;
	gp->scr_event = cl_event;
	gp->scr_ex_adjust = cl_ex_adjust;
	gp->scr_fmap = cl_fmap;
	gp->scr_insertln = cl_insertln;
	gp->scr_keyval = cl_keyval;
	gp->scr_move = cl_move;
	gp->scr_msg = NULL;
	gp->scr_optchange = cl_optchange;
	gp->scr_refresh = cl_refresh;
	gp->scr_rename = cl_rename;
	gp->scr_screen = cl_screen;
	gp->scr_suspend = cl_suspend;
	gp->scr_usage = cl_usage;

d253 4
d423 31
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_main.c	10.27 (Berkeley) 4/28/96";
d31 3
d40 6
a45 5
static GS	*gs_init __P((char *));
static void	 nomem __P((char *));
static int	 setsig __P((int, struct sigaction *, void (*)(int)));
static void	 sig_end __P((GS *));
static void	 term_init __P((char *, char *));
d61 1
a61 1
	char **p_av, **t_av, *ttype;
a68 1
	clp = GCLP(gp);
a69 1
#ifdef NOT_NEEDED_FOR_CURSES
d75 2
d82 18
d102 9
d112 3
d162 9
a196 1
	int fd;
d205 18
d225 3
a227 4
	if (gp != NULL)
		CALLOC_NOMSG(NULL, clp, CL_PRIVATE *, 1, sizeof(CL_PRIVATE));
	if (gp == NULL || clp == NULL)
		nomem(name);
d269 2
a270 2
tcfail:			(void)fprintf(stderr,
			    "%s: tcgetattr: %s\n", name, strerror(errno));
d275 1
a275 3

	gp->progname = name;
	return (gp);
d365 3
a367 1
		    setsig(SIGTERM, &clp->oact[INDX_TERM], h_term) ||
d369 3
a371 1
		    setsig(SIGWINCH, &clp->oact[INDX_WINCH], h_winch)) {
d379 6
a384 2
		    setsig(SIGTERM, NULL, h_term) ||
		    setsig(SIGWINCH, NULL, h_winch)) {
d438 1
d440 1
@
