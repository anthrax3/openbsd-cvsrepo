head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.4
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.16
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.14
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.12
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.10
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.28
date	2017.07.20.08.37.48;	author anton;	state Exp;
branches;
next	1.27;
commitid	vzib2Xf1mAQKGxSl;

1.27
date	2016.12.18.06.11.23;	author krw;	state Exp;
branches;
next	1.26;
commitid	fCnIjtvaaZwmYSr8;

1.26
date	2016.07.07.09.26.26;	author semarie;	state Exp;
branches;
next	1.25;
commitid	DbA6uRBlp6EdWuFA;

1.25
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.24;
commitid	01nAnartGL7onLD3;

1.24
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.23;
commitid	ruCZ2IKF0FB0ebCr;

1.23
date	2016.04.19.17.23.09;	author martijn;	state Exp;
branches;
next	1.22;
commitid	jeA4r3MSck5D123O;

1.22
date	2016.03.17.03.44.05;	author bentley;	state Exp;
branches;
next	1.21;
commitid	nzmbkSXNR2sEoKul;

1.21
date	2016.01.06.22.28.52;	author millert;	state Exp;
branches;
next	1.20;
commitid	adBvXLg05bJxz6yx;

1.20
date	2015.04.10.18.05.51;	author brynet;	state Exp;
branches;
next	1.19;
commitid	3KdoKOBEaWokdDOw;

1.19
date	2014.11.12.16.29.04;	author millert;	state Exp;
branches;
next	1.18;
commitid	T0XpHzXjuQBl1V3E;

1.18
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.17;
commitid	06bi6U3x4gFFf2G1;

1.17
date	2014.11.06.10.48.52;	author bentley;	state Exp;
branches;
next	1.16;
commitid	ELEZXFZ7jYF35pM3;

1.16
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.22.03.09.15;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.08.21.05.39;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.29.01.58.28;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.11.26.22.49.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.03.06.20.27.44;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.03.06.20.19.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.24.00.07.42;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.06.23.22.40.43;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.09.23.07.12.45;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.17.17.18.51;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.17.58.17;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.15.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.33.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Replace usage of strtol() with strtonum().

ok bentley@@ deraadt@@ millert@@ tb@@
@
text
@/*	$OpenBSD: cl_term.c,v 1.27 2016/12/18 06:11:23 krw Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <bitstring.h>
#include <curses.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "../common/common.h"
#include "cl.h"

static int cl_pfmap(SCR *, seq_t, CHAR_T *, size_t, CHAR_T *, size_t);

/*
 * XXX
 * THIS REQUIRES THAT ALL SCREENS SHARE A TERMINAL TYPE.
 */
typedef struct _tklist {
	char	*ts;			/* Key's termcap string. */
	char	*output;		/* Corresponding vi command. */
	char	*name;			/* Name. */
} TKLIST;
static TKLIST const c_tklist[] = {	/* Command mappings. */
	{"kil1",	"O",	"insert line"},
	{"kdch1",	"x",	"delete character"},
	{"kcud1",	"j",	"cursor down"},
	{"kel",		"D",	"delete to eol"},
	{"kind",     "\004",	"scroll down"},			/* ^D */
	{"kll",		"$",	"go to eol"},
	{"khome",	"^",	"go to sol"},
	{"kich1",	"i",	"insert at cursor"},
	{"kdl1",       "dd",	"delete line"},
	{"kcub1",	"h",	"cursor left"},
	{"knp",	     "\006",	"page down"},			/* ^F */
	{"kpp",	     "\002",	"page up"},			/* ^B */
	{"kri",	     "\025",	"scroll up"},			/* ^U */
	{"ked",	       "dG",	"delete to end of screen"},
	{"kcuf1",	"l",	"cursor right"},
	{"kcuu1",	"k",	"cursor up"},
	{NULL, NULL, NULL},
};
static TKLIST const m1_tklist[] = {	/* Input mappings (set or delete). */
	{"kcud1",  "\033ja",	"cursor down"},			/* ^[ja */
	{"kcub1",  "\033ha",	"cursor left"},			/* ^[ha */
	{"kcuu1",  "\033ka",	"cursor up"},			/* ^[ka */
	{"kcuf1",  "\033la",	"cursor right"},		/* ^[la */
	{NULL, NULL, NULL},
};

/*
 * cl_term_init --
 *	Initialize the special keys defined by the termcap/terminfo entry.
 *
 * PUBLIC: int cl_term_init(SCR *);
 */
int
cl_term_init(SCR *sp)
{
	SEQ *qp;
	TKLIST const *tkp;
	char *t;

	/* Command mappings. */
	for (tkp = c_tklist; tkp->name != NULL; ++tkp) {
		if ((t = tigetstr(tkp->ts)) == NULL || t == (char *)-1)
			continue;
		if (seq_set(sp, tkp->name, strlen(tkp->name), t, strlen(t),
		    tkp->output, strlen(tkp->output), SEQ_COMMAND,
		    SEQ_NOOVERWRITE | SEQ_SCREEN))
			return (1);
	}

	/* Input mappings that are already set or are text deletions. */
	for (tkp = m1_tklist; tkp->name != NULL; ++tkp) {
		if ((t = tigetstr(tkp->ts)) == NULL || t == (char *)-1)
			continue;
		/*
		 * !!!
		 * Some terminals' <cursor_left> keys send single <backspace>
		 * characters.  This is okay in command mapping, but not okay
		 * in input mapping.  That combination is the only one we'll
		 * ever see, hopefully, so kluge it here for now.
		 */
		if (!strcmp(t, "\b"))
			continue;
		if (tkp->output == NULL) {
			if (seq_set(sp, tkp->name, strlen(tkp->name),
			    t, strlen(t), NULL, 0,
			    SEQ_INPUT, SEQ_NOOVERWRITE | SEQ_SCREEN))
				return (1);
		} else
			if (seq_set(sp, tkp->name, strlen(tkp->name),
			    t, strlen(t), tkp->output, strlen(tkp->output),
			    SEQ_INPUT, SEQ_NOOVERWRITE | SEQ_SCREEN))
				return (1);
	}

	/*
	 * Rework any function key mappings that were set before the
	 * screen was initialized.
	 */
	LIST_FOREACH(qp, & sp->gp->seqq, q)
		if (F_ISSET(qp, SEQ_FUNCMAP))
			(void)cl_pfmap(sp, qp->stype,
			    qp->input, qp->ilen, qp->output, qp->olen);
	return (0);
}

/*
 * cl_term_end --
 *	End the special keys defined by the termcap/terminfo entry.
 *
 * PUBLIC: int cl_term_end(GS *);
 */
int
cl_term_end(GS *gp)
{
	SEQ *qp, *nqp;

	/* Delete screen specific mappings. */
	for (qp = LIST_FIRST(&gp->seqq); qp != NULL; qp = nqp) {
		nqp = LIST_NEXT(qp, q);
		if (F_ISSET(qp, SEQ_SCREEN))
			(void)seq_mdel(qp);
	}
	return (0);
}

/*
 * cl_fmap --
 *	Map a function key.
 *
 * PUBLIC: int cl_fmap(SCR *, seq_t, CHAR_T *, size_t, CHAR_T *, size_t);
 */
int
cl_fmap(SCR *sp, seq_t stype, CHAR_T *from, size_t flen, CHAR_T *to,
    size_t tlen)
{
	/* Ignore until the screen is running, do the real work then. */
	if (F_ISSET(sp, SC_VI) && !F_ISSET(sp, SC_SCR_VI))
		return (0);
	if (F_ISSET(sp, SC_EX) && !F_ISSET(sp, SC_SCR_EX))
		return (0);

	return (cl_pfmap(sp, stype, from, flen, to, tlen));
}

/*
 * cl_pfmap --
 *	Map a function key (private version).
 */
static int
cl_pfmap(SCR *sp, seq_t stype, CHAR_T *from, size_t flen, CHAR_T *to,
    size_t tlen)
{
	size_t nlen;
	char *p, key_name[64];

	(void)snprintf(key_name, sizeof(key_name), "kf%d", atoi(from + 1));
	if ((p = tigetstr(key_name)) == NULL ||
	    p == (char *)-1 || strlen(p) == 0)
		p = NULL;
	if (p == NULL) {
		msgq_str(sp, M_ERR, from, "This terminal has no %s key");
		return (1);
	}

	nlen = snprintf(key_name,
	    sizeof(key_name), "function key %d", atoi(from + 1));
	if (nlen >= sizeof(key_name))
		nlen = sizeof(key_name) - 1;
	return (seq_set(sp, key_name, nlen,
	    p, strlen(p), to, tlen, stype, SEQ_NOOVERWRITE | SEQ_SCREEN));
}

/*
 * cl_optchange --
 *	Curses screen specific "option changed" routine.
 *
 * PUBLIC: int cl_optchange(SCR *, int, char *, u_long *);
 */
int
cl_optchange(SCR *sp, int opt, char *str, u_long *valp)
{
	CL_PRIVATE *clp;

	clp = CLP(sp);

	switch (opt) {
	case O_TERM:
		F_CLR(sp, SC_SCR_EX | SC_SCR_VI);
		/* FALLTHROUGH */
	case O_COLUMNS:
	case O_LINES:
		/*
		 * Changing the terminal type requires that we reinitialize
		 * curses, while resizing does not.
		 */
		F_SET(sp->gp, G_SRESTART);
		break;
	case O_MESG:
		(void)cl_omesg(sp, clp, !*valp);
		break;
	case O_WINDOWNAME:
		if (*valp) {
			F_CLR(clp, CL_RENAME_OK);

			(void)cl_rename(sp, NULL, 0);
		} else {
			F_SET(clp, CL_RENAME_OK);

			/*
			 * If the screen is live, i.e. we're not reading the
			 * .exrc file, update the window.
			 */
			if (sp->frp != NULL && sp->frp->name != NULL)
				(void)cl_rename(sp, sp->frp->name, 1);
		}
		break;
	}
	return (0);
}

/*
 * cl_omesg --
 *	Turn the tty write permission on or off.
 *
 * PUBLIC: int cl_omesg(SCR *, CL_PRIVATE *, int);
 */
int
cl_omesg(SCR *sp, CL_PRIVATE *clp, int on)
{
	struct stat sb;
	char *tty;

	/* Find the tty, get the current permissions. */
	if ((tty = ttyname(STDERR_FILENO)) == NULL) {
		if (sp != NULL)
			msgq(sp, M_SYSERR, "stderr");
		return (1);
	}
	if (stat(tty, &sb) < 0) {
		if (sp != NULL)
			msgq(sp, M_SYSERR, "%s", tty);
		return (1);
	}
	sb.st_mode &= ACCESSPERMS;

	/* Save the original status if it's unknown. */
	if (clp->tgw == TGW_UNKNOWN)
		clp->tgw = sb.st_mode & S_IWGRP ? TGW_SET : TGW_UNSET;

	/* Toggle the permissions. */
	if (on) {
		if (chmod(tty, sb.st_mode | S_IWGRP) < 0) {
			if (sp != NULL)
				msgq(sp, M_SYSERR,
				    "messages not turned on: %s", tty);
			return (1);
		}
	} else
		if (chmod(tty, sb.st_mode & ~S_IWGRP) < 0) {
			if (sp != NULL)
				msgq(sp, M_SYSERR,
				    "messages not turned off: %s", tty);
			return (1);
		}
	return (0);
}

/*
 * cl_ssize --
 *	Return the terminal size.
 *
 * PUBLIC: int cl_ssize(SCR *, int, size_t *, size_t *, int *);
 */
int
cl_ssize(SCR *sp, int sigwinch, size_t *rowp, size_t *colp, int *changedp)
{
	struct winsize win;
	size_t col, row;
	int rval;
	char *p;

	/* Assume it's changed. */
	if (changedp != NULL)
		*changedp = 1;

	/*
	 * !!!
	 * sp may be NULL.
	 *
	 * Get the screen rows and columns.  If the values are wrong, it's
	 * not a big deal -- as soon as the user sets them explicitly the
	 * environment will be set and the screen package will use the new
	 * values.
	 *
	 * Try TIOCGWINSZ.
	 */
	row = col = 0;
	if (ioctl(STDERR_FILENO, TIOCGWINSZ, &win) != -1) {
		row = win.ws_row;
		col = win.ws_col;
	}
	/* If here because of suspend or a signal, only trust TIOCGWINSZ. */
	if (sigwinch) {
		/*
		 * Somebody didn't get TIOCGWINSZ right, or has suspend
		 * without window resizing support.  The user just lost,
		 * but there's nothing we can do.
		 */
		if (row == 0 || col == 0) {
			if (changedp != NULL)
				*changedp = 0;
			return (0);
		}

		/*
		 * SunOS systems deliver SIGWINCH when windows are uncovered
		 * as well as when they change size.  In addition, we call
		 * here when continuing after being suspended since the window
		 * may have changed size.  Since we don't want to background
		 * all of the screens just because the window was uncovered,
		 * ignore the signal if there's no change.
		 */
		if (sp != NULL &&
		    row == O_VAL(sp, O_LINES) && col == O_VAL(sp, O_COLUMNS)) {
			if (changedp != NULL)
				*changedp = 0;
			return (0);
		}

		if (rowp != NULL)
			*rowp = row;
		if (colp != NULL)
			*colp = col;
		return (0);
	}

	/*
	 * !!!
	 * If TIOCGWINSZ failed, or had entries of 0, try termcap.  This
	 * routine is called before any termcap or terminal information
	 * has been set up.  If there's no TERM environmental variable set,
	 * let it go, at least ex can run.
	 */
	if (row == 0 || col == 0) {
		if ((p = getenv("TERM")) == NULL)
			goto noterm;
		if (row == 0) {
			if ((rval = tigetnum("lines")) < 0)
				msgq(sp, M_SYSERR, "tigetnum: lines");
			else
				row = rval;
		}
		if (col == 0) {
			if ((rval = tigetnum("cols")) < 0)
				msgq(sp, M_SYSERR, "tigetnum: cols");
			else
				col = rval;
		}
	}

	/* If nothing else, well, it's probably a VT100. */
noterm:	if (row == 0)
		row = 24;
	if (col == 0)
		col = 80;

	/*
	 * !!!
	 * POSIX 1003.2 requires the environment to override everything.
	 * Often, people can get nvi to stop messing up their screen by
	 * deleting the LINES and COLUMNS environment variables from their
	 * dot-files.
	 */
	if ((p = getenv("LINES")) != NULL &&
	    (rval = strtonum(p, 1, INT_MAX, NULL)) > 0)
		row = rval;
	if ((p = getenv("COLUMNS")) != NULL &&
	    (rval = strtonum(p, 1, INT_MAX, NULL)) > 0)
		col = rval;

	if (rowp != NULL)
		*rowp = row;
	if (colp != NULL)
		*colp = col;
	return (0);
}

/*
 * cl_putchar --
 *	Function version of putchar, for tputs.
 *
 * PUBLIC: int cl_putchar(int);
 */
int
cl_putchar(int ch)
{
	return (putchar(ch));
}
@


1.27
log
@Nuke more unused variables.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.26 2016/07/07 09:26:26 semarie Exp $	*/
a20 1
#include <errno.h>
d303 1
a303 2
	long lval;
	char *p, *ep;
d397 6
a402 22
	if ((p = getenv("LINES")) != NULL) {
		errno = 0;
		lval = strtol(p, &ep, 10);
		if (p[0] == '\0' || *ep != '\0')
			;
		else if ((errno == ERANGE && (lval == LONG_MAX || lval ==
		    LONG_MIN)) || (lval > INT_MAX || lval < 1))
			;
		else
			row = lval;
	}
	if ((p = getenv("COLUMNS")) != NULL) {
		errno = 0;
		lval = strtol(p, &ep, 10);
		if (p[0] == '\0' || *ep != '\0')
			;
		else if ((errno == ERANGE && (lval == LONG_MAX || lval ==
		    LONG_MIN)) || (lval > INT_MAX || lval < 1))
			;
		else
			col = lval;
	}
@


1.26
log
@biff, mesg, vi: only consider ACCESSPERMS for setting tty mode.

it explicitly removes any S_ISUID|S_ISGID|S_ISTXT bits, instead of letting
pledge(2) silenciously remove them.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.25 2016/05/27 09:18:11 martijn Exp $	*/
a79 1
	KEYLIST *kp;
@


1.25
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.23 2016/04/19 17:23:09 martijn Exp $	*/
d269 1
@


1.24
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d33 1
a33 1
static int cl_pfmap(SCR *, seq_t, char *, size_t, char *, size_t);
d155 1
a155 1
 * PUBLIC: int cl_fmap(SCR *, seq_t, char *, size_t, char *, size_t);
d158 1
a158 1
cl_fmap(SCR *sp, seq_t stype, char *from, size_t flen, char *to,
d175 1
a175 1
cl_pfmap(SCR *sp, seq_t stype, char *from, size_t flen, char *to,
@


1.23
log
@Remove some useless code.

Minor tweak and OK schwarze@@
OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.22 2016/03/17 03:44:05 bentley Exp $	*/
d33 1
a33 1
static int cl_pfmap(SCR *, seq_t, CHAR_T *, size_t, CHAR_T *, size_t);
d155 1
a155 1
 * PUBLIC: int cl_fmap(SCR *, seq_t, CHAR_T *, size_t, CHAR_T *, size_t);
d158 1
a158 1
cl_fmap(SCR *sp, seq_t stype, CHAR_T *from, size_t flen, CHAR_T *to,
d175 1
a175 1
cl_pfmap(SCR *sp, seq_t stype, CHAR_T *from, size_t flen, CHAR_T *to,
@


1.22
log
@Add error checking for COLUMNS/LINES environment variables.

It would be better to replace all the complicated existing code with a
simple idiom, and this is being worked on. But for the moment,
preventing vi from crashing is worthwhile.

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.21 2016/01/06 22:28:52 millert Exp $	*/
a42 1
	u_char	 value;			/* Special value (for lookup). */
d61 1
a61 1
	{NULL},
d63 1
a63 4
static TKLIST const m1_tklist[] = {	/* Input mappings (lookup). */
	{NULL},
};
static TKLIST const m2_tklist[] = {	/* Input mappings (set or delete). */
d68 1
a68 1
	{NULL},
d95 1
a95 1
	/* Input mappings needing to be looked up. */
a96 14
		if ((t = tigetstr(tkp->ts)) == NULL || t == (char *)-1)
			continue;
		for (kp = keylist;; ++kp)
			if (kp->value == tkp->value)
				break;
		if (kp == NULL)
			continue;
		if (seq_set(sp, tkp->name, strlen(tkp->name), t, strlen(t),
		    &kp->ch, 1, SEQ_INPUT, SEQ_NOOVERWRITE | SEQ_SCREEN))
			return (1);
	}

	/* Input mappings that are already set or are text deletions. */
	for (tkp = m2_tklist; tkp->name != NULL; ++tkp) {
@


1.21
log
@Remove the numeric identifiers at the beginning of the messages
which used to be used as the message number to lookup in the
catalog.  From Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.20 2015/04/10 18:05:51 brynet Exp $	*/
d322 2
a323 1
	char *p;
d417 22
a438 4
	if ((p = getenv("LINES")) != NULL)
		row = strtol(p, NULL, 10);
	if ((p = getenv("COLUMNS")) != NULL)
		col = strtol(p, NULL, 10);
@


1.20
log
@This changes vi to use resizeterm(3) instead of reinitializing curses on
window resizes, which was leaking massive amounts of memory.

Try observing vi in top(1) and while resizing the window a few times
before and aftering applying this diff..

Also some more comment cleanup and another memory leak..

From github.com/lichray/nvi2
879d2ad6dd4a4343eb0a588ebfe637e1c9845bc4
a8c38480adb030a05bbb2aafec6067dd65d8c2eb

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.19 2014/11/12 16:29:04 millert Exp $	*/
d204 1
a204 1
		msgq_str(sp, M_ERR, from, "233|This terminal has no %s key");
d297 1
a297 1
				    "046|messages not turned on: %s", tty);
d304 1
a304 1
				    "045|messages not turned off: %s", tty);
@


1.19
log
@Remove more portability bits for older systems; from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.18 2014/11/12 04:28:41 bentley Exp $	*/
d230 3
a234 1
	case O_TERM:
d236 2
a237 2
		 * Changing the columns, lines or terminal require that
		 * we restart the screen.
a239 1
		F_CLR(sp, SC_SCR_EX | SC_SCR_VI);
@


1.18
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.17 2014/11/06 10:48:52 bentley Exp $	*/
a317 1
#ifdef TIOCGWINSZ
a318 1
#endif
a338 1
#ifdef TIOCGWINSZ
a342 1
#endif
@


1.17
log
@Remove old curses support in vi.

ok nicm@@ millert@@ plus a comment tweak from nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.16 2009/10/27 23:59:47 deraadt Exp $	*/
d82 1
a82 2
cl_term_init(sp)
	SCR *sp;
d156 1
a156 2
cl_term_end(gp)
	GS *gp;
d176 2
a177 5
cl_fmap(sp, stype, from, flen, to, tlen)
	SCR *sp;
	seq_t stype;
	CHAR_T *from, *to;
	size_t flen, tlen;
d193 2
a194 5
cl_pfmap(sp, stype, from, flen, to, tlen)
	SCR *sp;
	seq_t stype;
	CHAR_T *from, *to;
	size_t flen, tlen;
d223 1
a223 5
cl_optchange(sp, opt, str, valp)
	SCR *sp;
	int opt;
	char *str;
	u_long *valp;
d270 1
a270 4
cl_omesg(sp, clp, on)
	SCR *sp;
	CL_PRIVATE *clp;
	int on;
d316 1
a316 5
cl_ssize(sp, sigwinch, rowp, colp, changedp)
	SCR *sp;
	int sigwinch;
	size_t *rowp, *colp;
	int *changedp;
d438 1
a438 2
cl_putchar(ch)
	int ch;
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.15 2006/04/22 03:09:15 ray Exp $	*/
a449 14
#ifdef _USE_OLD_CURSES_
/*
 * cl_putchar --
 *	Function version of putchar, for tputs.
 *
 * PUBLIC: int cl_putchar(int);
 */
void
cl_putchar(ch)
	int ch;
{
	(void)putchar(ch);
}
#else
a461 1
#endif
@


1.15
log
@Removes unused variables and rename variables shadowing external
variables.  No binary change.

Found by lint.

OK otto@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.14 2006/01/08 21:05:39 miod Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)cl_term.c	10.22 (Berkeley) 9/15/96";
#endif /* not lint */
@


1.14
log
@Explicit braces around macro fields and logical operations, gets rid of 148
warnings, no functional change.

From Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.13 2005/10/17 19:12:16 otto Exp $	*/
d209 1
a209 1
	char *p, keyname[64];
d211 2
a212 2
	(void)snprintf(keyname, sizeof(keyname), "kf%d", atoi(from + 1));
	if ((p = tigetstr(keyname)) == NULL ||
d220 5
a224 5
	nlen = snprintf(keyname,
	    sizeof(keyname), "function key %d", atoi(from + 1));
	if (nlen >= sizeof(keyname))
		nlen = sizeof(keyname) - 1;
	return (seq_set(sp, keyname, nlen,
@


1.13
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.12 2002/02/16 21:27:56 millert Exp $	*/
d415 1
a415 1
		if (row == 0)
d420 2
a421 1
		if (col == 0)
d426 1
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_term.c,v 1.11 2001/01/29 01:58:28 niklas Exp $	*/
d147 1
a147 1
	for (qp = sp->gp->seqq.lh_first; qp != NULL; qp = qp->q.le_next)
d167 2
a168 2
	for (qp = gp->seqq.lh_first; qp != NULL; qp = nqp) {
		nqp = qp->q.le_next;
@


1.11
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
static int cl_pfmap __P((SCR *, seq_t, CHAR_T *, size_t, CHAR_T *, size_t));
d83 1
a83 1
 * PUBLIC: int cl_term_init __P((SCR *));
d158 1
a158 1
 * PUBLIC: int cl_term_end __P((GS *));
d179 1
a179 1
 * PUBLIC: int cl_fmap __P((SCR *, seq_t, CHAR_T *, size_t, CHAR_T *, size_t));
d232 1
a232 1
 * PUBLIC: int cl_optchange __P((SCR *, int, char *, u_long *));
d283 1
a283 1
 * PUBLIC: int cl_omesg __P((SCR *, CL_PRIVATE *, int));
d332 1
a332 1
 * PUBLIC: int cl_ssize __P((SCR *, int, size_t *, size_t *, int *));
d457 1
a457 1
 * PUBLIC: int cl_putchar __P((int));
d470 1
a470 1
 * PUBLIC: int cl_putchar __P((int));
@


1.10
log
@o Update README files etc. from nvi-1.79 so they have the correct info
o make port.h empty since we there is nothing we lack
o include <sys/param.h>, not <sys/types.h> in files that use MIN/MAX macros
o add perl api support since we have libperl (off by default)
@
text
@d1 2
@


1.9
log
@back out changes that should not have escaped my local tree
@
text
@d22 1
a24 1
#include <curses.h>
@


1.8
log
@add missing reference to infocmp
@
text
@a21 1
#include <curses.h>
d24 1
@


1.7
log
@-D_USE_OLD_CURSE_ for -locurses and no more -ltermlib/termcap
@
text
@d22 1
a24 1
#include <curses.h>
@


1.6
log
@Fix snprintf return value usage.
@
text
@a23 3
#ifdef USE_OCURSES
#include <ocurses.h>
#else
a24 1
#endif
d450 1
a450 1
#ifdef USE_OCURSES
@


1.5
log
@Make building with ocurses/termcap and curses/termlib conditional on
USE_OCURSES being defined, and define it for now.  This switches nvi back
to use BSD curses.
@
text
@d224 2
@


1.4
log
@nvi 1.76:
        + Fix bug where ^V didn't keep input mapping from happening.
        + Fix a core dump bug in the R command.
        + Give up on licensing: no more shareware, adware, whatever.
        + Fix cursor positioning bug for C, S and c$ in an empty file.
@
text
@a21 1
#include <curses.h>
d24 5
d452 14
d478 1
@


1.3
log
@nvi 1.73
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_term.c	10.21 (Berkeley) 7/12/96";
d186 5
a190 2
	EX_INIT_IGNORE(sp);
	VI_INIT_IGNORE(sp);
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_term.c	10.20 (Berkeley) 5/3/96";
d234 4
d250 17
a266 1
		cl_omesg(sp, CLP(sp), !*valp);
@


1.1
log
@new vi
@
text
@d431 1
a431 1
void
d435 1
a435 1
	putchar(ch);
@
