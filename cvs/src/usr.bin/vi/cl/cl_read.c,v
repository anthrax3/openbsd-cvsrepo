head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.4
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.22
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.20
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.6
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.21
date	2016.05.27.09.18.11;	author martijn;	state Exp;
branches;
next	1.20;
commitid	01nAnartGL7onLD3;

1.20
date	2016.05.02.18.24.25;	author martijn;	state Exp;
branches;
next	1.19;
commitid	ruCZ2IKF0FB0ebCr;

1.19
date	2014.11.12.04.28.41;	author bentley;	state Exp;
branches;
next	1.18;
commitid	06bi6U3x4gFFf2G1;

1.18
date	2009.10.27.23.59.47;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.10.14.03.18;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.02.00.21.32;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.02.15.19.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.26.16.11.56;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.17.19.12.16;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.02.22.44.06;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.17.19.42.33;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.29.01.58.28;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.11.26.22.49.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.03.06.20.27.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.03.06.20.19.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.07.24.00.07.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.09.23.07.12.44;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.10.16.01.18.11;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.07.24.16.15.14;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.33.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Revert CHAR_T removal. Some signedness flaws were introduced.
Found the hard way by jca@@
@
text
@/*	$OpenBSD: cl_read.c,v 1.19 2014/11/12 04:28:41 bentley Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>

#include <bitstring.h>
#include <curses.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "../common/common.h"
#include "../ex/script.h"
#include "cl.h"

static input_t	cl_read(SCR *,
		    u_int32_t, CHAR_T *, size_t, int *, struct timeval *);
static int	cl_resize(SCR *, size_t, size_t);

/*
 * cl_event --
 *	Return a single event.
 *
 * PUBLIC: int cl_event(SCR *, EVENT *, u_int32_t, int);
 */
int
cl_event(SCR *sp, EVENT *evp, u_int32_t flags, int ms)
{
	struct timeval t, *tp;
	CL_PRIVATE *clp;
	size_t lines, columns;
	int changed, nr;

	/*
	 * Queue signal based events.  We never clear SIGHUP or SIGTERM events,
	 * so that we just keep returning them until the editor dies.
	 */
	clp = CLP(sp);
retest:	if (LF_ISSET(EC_INTERRUPT) || F_ISSET(clp, CL_SIGINT)) {
		if (F_ISSET(clp, CL_SIGINT)) {
			F_CLR(clp, CL_SIGINT);
			evp->e_event = E_INTERRUPT;
		} else
			evp->e_event = E_TIMEOUT;
		return (0);
	}
	if (F_ISSET(clp, CL_SIGHUP | CL_SIGTERM | CL_SIGWINCH)) {
		if (F_ISSET(clp, CL_SIGHUP)) {
			evp->e_event = E_SIGHUP;
			return (0);
		}
		if (F_ISSET(clp, CL_SIGTERM)) {
			evp->e_event = E_SIGTERM;
			return (0);
		}
		if (F_ISSET(clp, CL_SIGWINCH)) {
			F_CLR(clp, CL_SIGWINCH);
			if (cl_ssize(sp, 1, &lines, &columns, &changed))
				return (1);
			if (changed) {
				(void)cl_resize(sp, lines, columns);
				evp->e_event = E_WRESIZE;
				return (0);
			}
			/* No real change, ignore the signal. */
		}
	}

	/* Set timer. */
	if (ms == 0)
		tp = NULL;
	else {
		t.tv_sec = ms / 1000;
		t.tv_usec = (ms % 1000) * 1000;
		tp = &t;
	}

	/* Read input characters. */
	switch (cl_read(sp, LF_ISSET(EC_QUOTED | EC_RAW),
	    clp->ibuf, sizeof(clp->ibuf), &nr, tp)) {
	case INP_OK:
		evp->e_csp = clp->ibuf;
		evp->e_len = nr;
		evp->e_event = E_STRING;
		break;
	case INP_EOF:
		evp->e_event = E_EOF;
		break;
	case INP_ERR:
		evp->e_event = E_ERR;
		break;
	case INP_INTR:
		goto retest;
	case INP_TIMEOUT:
		evp->e_event = E_TIMEOUT;
		break;
	default:
		abort();
	}
	return (0);
}

/*
 * cl_read --
 *	Read characters from the input.
 */
static input_t
cl_read(SCR *sp, u_int32_t flags, CHAR_T *bp, size_t blen, int *nrp,
    struct timeval *tp)
{
	struct termios term1, term2;
	CL_PRIVATE *clp;
	GS *gp;
	struct pollfd pfd[1];
	input_t rval;
	int nr, term_reset, timeout;

	gp = sp->gp;
	clp = CLP(sp);
	term_reset = 0;

	/*
	 * 1: A read from a file or a pipe.  In this case, the reads
	 *    never timeout regardless.  This means that we can hang
	 *    when trying to complete a map, but we're going to hang
	 *    on the next read anyway.
	 */
	if (!F_ISSET(clp, CL_STDIN_TTY)) {
		switch (nr = read(STDIN_FILENO, bp, blen)) {
		case 0:
			return (INP_EOF);
		case -1:
			goto err;
		default:
			*nrp = nr;
			return (INP_OK);
		}
		/* NOTREACHED */
	}

	/*
	 * 2: A read with an associated timeout, e.g., trying to complete
	 *    a map sequence.  If input exists, we fall into #3.
	 */
tty_retry:
	if (tp != NULL) {
		pfd[0].fd = STDIN_FILENO;
		pfd[0].events = POLLIN;
		timeout = tp ? (tp->tv_sec * 1000) + (tp->tv_usec / 1000) : 0;
		switch (poll(pfd, 1, timeout)) {
		case 0:
			return (INP_TIMEOUT);
		case -1:
			goto err;
		default:
			break;
		}
	}
	
	/*
	 * The user can enter a key in the editor to quote a character.  If we
	 * get here and the next key is supposed to be quoted, do what we can.
	 * Reset the tty so that the user can enter a ^C, ^Q, ^S.  There's an
	 * obvious race here, when the key has already been entered, but there's
	 * nothing that we can do to fix that problem.
	 *
	 * The editor can ask for the next literal character even thought it's
	 * generally running in line-at-a-time mode.  Do what we can.
	 */
	if (LF_ISSET(EC_QUOTED | EC_RAW) && !tcgetattr(STDIN_FILENO, &term1)) {
		term_reset = 1;
		if (LF_ISSET(EC_QUOTED)) {
			term2 = term1;
			term2.c_lflag &= ~ISIG;
			term2.c_iflag &= ~(IXON | IXOFF);
			(void)tcsetattr(STDIN_FILENO,
			    TCSASOFT | TCSADRAIN, &term2);
		} else
			(void)tcsetattr(STDIN_FILENO,
			    TCSASOFT | TCSADRAIN, &clp->vi_enter);
	}

	/*
	 * 3: Wait for input.
	 *
	 * Select on the command input and scripting window file descriptors.
	 * It's ugly that we wait on scripting file descriptors here, but it's
	 * the only way to keep from locking out scripting windows.
	 */
	if (F_ISSET(gp, G_SCRWIN)) {
		if (sscr_check_input(sp))
			goto err;
	}

	/*
	 * 4: Read the input.
	 *
	 * !!!
	 * What's going on here is some scary stuff.  Ex runs the terminal in
	 * canonical mode.  So, the <newline> character terminating a line of
	 * input is returned in the buffer, but a trailing <EOF> character is
	 * not similarly included.  As ex uses 0<EOF> and ^<EOF> as autoindent
	 * commands, it has to see the trailing <EOF> characters to determine
	 * the difference between the user entering "0ab" and "0<EOF>ab".  We
	 * leave an extra slot in the buffer, so that we can add a trailing
	 * <EOF> character if the buffer isn't terminated by a <newline>.  We
	 * lose if the buffer is too small for the line and exactly N characters
	 * are entered followed by an <EOF> character.
	 */
#define	ONE_FOR_EOF	1
	switch (nr = read(STDIN_FILENO, bp, blen - ONE_FOR_EOF)) {
	case  0:				/* EOF. */
		/*
		 * ^D in canonical mode returns a read of 0, i.e. EOF.  EOF is
		 * a valid command, but we don't want to loop forever because
		 * the terminal driver is returning EOF because the user has
		 * disconnected. The editor will almost certainly try to write
		 * something before this fires, which should kill us, but You
		 * Never Know.
		 */
		if (++clp->eof_count < 50) {
			bp[0] = clp->orig.c_cc[VEOF];
			*nrp = 1;
			rval = INP_OK;

		} else
			rval = INP_EOF;
		break;
	case -1:				/* Error or interrupt. */
err:		if (errno == EINTR)
			rval = INP_INTR;
		else if (errno == EAGAIN)
			goto tty_retry;
		else {
			rval = INP_ERR;
			msgq(sp, M_SYSERR, "input");
		}
		break;
	default:				/* Input characters. */
		if (F_ISSET(sp, SC_EX) && bp[nr - 1] != '\n')
			bp[nr++] = clp->orig.c_cc[VEOF];
		*nrp = nr;
		clp->eof_count = 0;
		rval = INP_OK;
		break;
	}

	/* Restore the terminal state if it was modified. */
	if (term_reset)
		(void)tcsetattr(STDIN_FILENO, TCSASOFT | TCSADRAIN, &term1);
	return (rval);
}

/* 
 * cl_resize --
 *	Reset the options for a resize event.
 */
static int
cl_resize(SCR *sp, size_t lines, size_t columns)
{
	ARGS *argv[2], a, b;
	char b1[1024];

	a.bp = b1;
	b.bp = NULL;
	a.len = b.len = 0;
	argv[0] = &a;
	argv[1] = &b;

	(void)snprintf(b1, sizeof(b1), "lines=%lu", (u_long)lines);
	a.len = strlen(b1);
	if (opts_set(sp, argv, NULL))
		return (1);
	(void)snprintf(b1, sizeof(b1), "columns=%lu", (u_long)columns);
	a.len = strlen(b1);
	if (opts_set(sp, argv, NULL))
		return (1);
	return (0);
}
@


1.20
log
@Remove CHAR_T in favor of native types.

schwarze@@ agrees with the direction.
Few tweaks and OK tb@@
@
text
@d35 1
a35 1
		    u_int32_t, char *, size_t, int *, struct timeval *);
d126 1
a126 1
cl_read(SCR *sp, u_int32_t flags, char *bp, size_t blen, int *nrp,
@


1.19
log
@Ansify vi.

ok bcallah@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.18 2009/10/27 23:59:47 deraadt Exp $	*/
d35 1
a35 1
		    u_int32_t, CHAR_T *, size_t, int *, struct timeval *);
d126 1
a126 1
cl_read(SCR *sp, u_int32_t flags, CHAR_T *bp, size_t blen, int *nrp,
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.17 2009/06/10 14:03:18 millert Exp $	*/
d45 1
a45 5
cl_event(sp, evp, flags, ms)
	SCR *sp;
	EVENT *evp;
	u_int32_t flags;
	int ms;
d126 2
a127 7
cl_read(sp, flags, bp, blen, nrp, tp)
	SCR *sp;
	u_int32_t flags;
	CHAR_T *bp;
	size_t blen;
	int *nrp;
	struct timeval *tp;
d277 1
a277 3
cl_resize(sp, lines, columns)
	SCR *sp;
	size_t lines, columns;
@


1.17
log
@Use poll() instead of select().  The sscr_check_input() bit is
adapted from nvi 1.81.  Tested by several people during the hackathon.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.16 2009/06/02 00:21:32 millert Exp $	*/
a12 4

#ifndef lint
static const char sccsid[] = "@@(#)cl_read.c	10.15 (Berkeley) 9/24/96";
#endif /* not lint */
@


1.16
log
@If the read from the tty fails with EAGAIN, pop back up to the select.
Seems to happen occasionally even though select reported the fd is ready.
OK ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.15 2007/09/02 15:19:35 deraadt Exp $	*/
a19 3
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
d26 1
a142 1
	struct timeval poll;
d145 1
a145 2
	SCR *tsp;
	fd_set *rdfd;
d147 1
a147 1
	int maxfd, nr, term_reset;
a152 9
	/* Allocate space for rdfd. */
	maxfd = STDIN_FILENO;
	CIRCLEQ_FOREACH(tsp, &gp->dq, q)
		if (F_ISSET(tsp, SC_SCRIPT) && tsp->script->sh_master > maxfd)
			maxfd = tsp->script->sh_master;
	rdfd = (fd_set *)calloc(howmany(maxfd + 1, NFDBITS), sizeof(fd_mask));
	if (rdfd == NULL)
		goto err;

a161 1
			free(rdfd);
a166 1
			free(rdfd);
d178 4
a181 7
		memset(rdfd, 0, howmany(STDIN_FILENO + 1, NFDBITS)
		    * sizeof(fd_mask));
		poll.tv_sec = 0;
		poll.tv_usec = 0;
		FD_SET(STDIN_FILENO, rdfd);
		switch (select(STDIN_FILENO + 1,
		    rdfd, NULL, NULL, tp == NULL ? &poll : tp)) {
a182 1
			free(rdfd);
d222 1
a222 9
loop:		memset(rdfd, 0, howmany(maxfd + 1, NFDBITS) * sizeof(fd_mask));
		FD_SET(STDIN_FILENO, rdfd);
		CIRCLEQ_FOREACH(tsp, &gp->dq, q)
			if (F_ISSET(tsp, SC_SCRIPT))
				FD_SET(tsp->script->sh_master, rdfd);
		switch (select(maxfd + 1, rdfd, NULL, NULL, NULL)) {
		case 0:
			abort();
		case -1:
a223 10
		default:
			break;
		}
		if (!FD_ISSET(STDIN_FILENO, rdfd)) {
			if (sscr_input(sp)) {
				free(rdfd);
				return (INP_ERR);
			}
			goto loop;
		}
a281 1
	free(rdfd);
@


1.15
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.14 2007/07/26 16:11:56 millert Exp $	*/
d191 1
d300 2
@


1.14
log
@Add the correct file descriptor to rdfd when cycling through
the list of scripting windows.  Appears to be a cut and paste error.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.13 2005/10/17 19:12:16 otto Exp $	*/
d162 1
a162 1
	rdfd = (fd_set *)malloc(howmany(maxfd + 1, NFDBITS) * sizeof(fd_mask));
@


1.13
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.12 2003/09/02 22:44:06 dhartmei Exp $	*/
d160 2
a161 2
		if (F_ISSET(sp, SC_SCRIPT) && sp->script->sh_master > maxfd)
			maxfd = sp->script->sh_master;
d243 2
a244 2
			if (F_ISSET(sp, SC_SCRIPT))
				FD_SET(sp->script->sh_master, rdfd);
@


1.12
log
@switch to dynamic fd_set and poll. patch entirely from millert@@.
ok deraadt@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.11 2002/02/17 19:42:33 millert Exp $	*/
d159 1
a159 2
	for (tsp = gp->dq.cqh_first;
	    tsp != (void *)&gp->dq; tsp = tsp->q.cqe_next)
d242 1
a242 2
		for (tsp = gp->dq.cqh_first;
		    tsp != (void *)&gp->dq; tsp = tsp->q.cqe_next)
@


1.11
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.10 2002/02/16 21:27:56 millert Exp $	*/
d149 1
a149 1
	fd_set rdfd;
d157 10
d176 1
d182 1
a191 3
	FD_ZERO(&rdfd);
	poll.tv_sec = 0;
	poll.tv_usec = 0;
d193 5
a197 1
		FD_SET(STDIN_FILENO, &rdfd);
d199 1
a199 1
		    &rdfd, NULL, NULL, tp == NULL ? &poll : tp)) {
d201 1
d241 2
a242 3
loop:		FD_ZERO(&rdfd);
		FD_SET(STDIN_FILENO, &rdfd);
		maxfd = STDIN_FILENO;
d245 3
a247 6
			if (F_ISSET(sp, SC_SCRIPT)) {
				FD_SET(sp->script->sh_master, &rdfd);
				if (sp->script->sh_master > maxfd)
					maxfd = sp->script->sh_master;
			}
		switch (select(maxfd + 1, &rdfd, NULL, NULL, NULL)) {
d255 3
a257 2
		if (!FD_ISSET(STDIN_FILENO, &rdfd)) {
			if (sscr_input(sp))
d259 1
d318 1
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl_read.c,v 1.9 2001/01/29 01:58:28 niklas Exp $	*/
d40 2
a41 2
static input_t	cl_read __P((SCR *,
    u_int32_t, CHAR_T *, size_t, int *, struct timeval *));
@


1.9
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
static int	cl_resize __P((SCR *, size_t, size_t));
d48 1
a48 1
 * PUBLIC: int cl_event __P((SCR *, EVENT *, u_int32_t, int));
@


1.8
log
@o Update README files etc. from nvi-1.79 so they have the correct info
o make port.h empty since we there is nothing we lack
o include <sys/param.h>, not <sys/types.h> in files that use MIN/MAX macros
o add perl api support since we have libperl (off by default)
@
text
@d1 2
@


1.7
log
@back out changes that should not have escaped my local tree
@
text
@d24 1
a26 1
#include <curses.h>
@


1.6
log
@add missing reference to infocmp
@
text
@a23 1
#include <curses.h>
d26 1
@


1.5
log
@-D_USE_OLD_CURSE_ for -locurses and no more -ltermlib/termcap
@
text
@d24 1
a26 1
#include <curses.h>
@


1.4
log
@Make building with ocurses/termcap and curses/termlib conditional on
USE_OCURSES being defined, and define it for now.  This switches nvi back
to use BSD curses.
@
text
@a25 3
#ifdef USE_OCURSES
#include <ocurses.h>
#else
a26 1
#endif
@


1.3
log
@nvi 1.78:
        + Fix bugs when both the leftright scrolling and number edit options
          were on.
        + Fix bug where splitting in the middle of the screen could repaint
          incorrectly.
        + Fix first-nul in input bug, where random garbage was inserted.
        + Correct search and mark-as-motion-command bug, it's a line mode
          action if the search starts at or before the first non<blank>.
        + Fix bug autoindent bug, where ^D could shift too far in the line.
        + Fix core dump where ! command called from the .exrc file.
        + Add the -S command-line option, which initializes vi to have the
          secure edit option preset.
@
text
@a23 1
#include <curses.h>
d26 5
@


1.2
log
@bring vi/ex up to 1.71
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_read.c	10.14 (Berkeley) 6/30/96";
d151 1
d161 1
a161 2
	gp = sp->gp;
	if (!F_ISSET(gp, G_STDIN_TTY)) {
d224 1
a224 1
	if (F_ISSET(gp, G_SCRIPT)) {
@


1.1
log
@new vi
@
text
@d13 1
a13 1
static const char sccsid[] = "@@(#)cl_read.c	10.13 (Berkeley) 5/3/96";
d88 1
a88 1
				evp->e_event = E_INTERRUPT;
@
