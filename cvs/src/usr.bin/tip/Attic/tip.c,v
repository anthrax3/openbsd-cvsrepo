head	1.57;
access;
symbols
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.54.0.10
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.54.0.8
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.54.0.4
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.2
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.53.0.10
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.8
	OPENBSD_5_0:1.53.0.6
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.53.0.4
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.34.0.8
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.24.0.6
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.4
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2015.04.24.18.05.21;	author nicm;	state dead;
branches;
next	1.56;
commitid	rYO6EyDAuDX1Hb8y;

1.56
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	6b2lLILbgCR1fvia;

1.55
date	2015.02.07.10.07.15;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	PXiaGXVynCsWpGYh;

1.54
date	2012.12.04.19.31.17;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.03.03.33.12;	author nicm;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.02.07.40.03;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.02.07.32.16;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.02.05.52.48;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.01.21.47.09;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.01.21.28.01;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.01.20.24.19;	author chl;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.30.00.09.27;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.29.23.38.05;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.29.23.32.52;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.29.23.10.56;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.29.21.34.50;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.29.17.42.35;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.29.16.41.56;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.29.05.55.37;	author nicm;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.12.18.26.23;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.12.18.14.00;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2009.12.12.13.38.09;	author nicm;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.45;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.01.18.38.29;	author sobrado;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.15.19.42.05;	author moritz;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.27.23.19.41;	author mcbride;	state Exp;
branches;
next	1.31;

1.31
date	2006.09.22.14.44.27;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.18.03.06.18;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.06.23.24.52;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.17.21.43.51;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.17.19.39.46;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.17.14.43.06;	author moritz;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.16.19.32.46;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.07.09.48.08;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.26.18.17.59;	author deraadt;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2003.10.15.22.33.18;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.20.18.15.32;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.02.56.18;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.29.22.58.56;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.07.06.56.50;	author hugh;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.25.16.41.36;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.25.00.20.19;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.24.18.38.58;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.26.06.07.28;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.09.19.30.49;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.12.19.21.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.20.06.19.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.09.05.38.47;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	98.07.12.05.27.04;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	97.09.01.23.24.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.25.16.30.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.22.22.42.07;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.04.20.23.29.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.04.02.01.47.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.40.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.12.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.17;	author deraadt;	state Exp;
branches;
next	;

1.23.2.1
date	2004.11.13.23.56.37;	author brad;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Remove tip(1), superseded by cu(1).

ok deraadt sthen bmercer
@
text
@/*	$OpenBSD: tip.c,v 1.56 2015/04/18 18:28:38 deraadt Exp $	*/
/*	$NetBSD: tip.c,v 1.13 1997/04/20 00:03:05 mellon Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * tip - UNIX link to other systems
 *  tip [-v] [-speed] system-name
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <util.h>

#include "tip.h"

static void	intprompt(int);
static void	tipin(void);
static int	escape(void);

int
main(int argc, char *argv[])
{
	char *sys = NULL;
	const char *errstr;
	int baud;
	int i, pair[2];

	vinit();

	/* XXX preserve previous braindamaged behavior */
	vsetnum(DC, 1);

	if (argc > 4) {
		fprintf(stderr, "usage: tip [-nv] [-speed] [system-name]\n");
		exit(1);
	}
	if (!isatty(0)) {
		fprintf(stderr, "%s: must be interactive\n", __progname);
		exit(1);
	}

	for (; argc > 1; argv++, argc--) {
		if (argv[1][0] != '-')
			sys = argv[1];
		else switch (argv[1][1]) {

		case 'v':
			vflag++;
			break;

		case 'n':
			noesc++;
			break;

		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			baud = strtonum(&argv[1][1], 0, INT_MAX, &errstr);
			if (errstr) {
				fprintf(stderr, "incorrect speed: %s\n", errstr);
				exit(1);
			}
			vsetnum(BAUDRATE, baud);
			break;

		default:
			fprintf(stderr, "%s: %s, unknown option\n", __progname,
			    argv[1]);
			break;
		}
	}

	(void)signal(SIGINT, cleanup);
	(void)signal(SIGQUIT, cleanup);
	(void)signal(SIGHUP, cleanup);
	(void)signal(SIGTERM, cleanup);
	(void)signal(SIGCHLD, SIG_DFL);

	FD = hunt(sys);
	setbuf(stdout, NULL);

	loginit();
	setparity("none");			/* set the parity table */

	if (ttysetup(vgetnum(BAUDRATE))) {
		fprintf(stderr, "%s: bad baud rate %d\n", __progname,
		    vgetnum(BAUDRATE));
		(void)uu_unlock(uucplock);
		exit(3);
	}
	con();

	i = fcntl(FD, F_GETFL);
	if (i == -1) {
		perror("fcntl");
		cleanup(0);
	}
	i = fcntl(FD, F_SETFL, i & ~O_NONBLOCK);
	if (i == -1) {
		perror("fcntl");
		cleanup(0);
	}

	tcgetattr(0, &defterm);
	gotdefterm = 1;
	term = defterm;
	term.c_lflag &= ~(ICANON|IEXTEN|ECHO);
	term.c_iflag &= ~(INPCK|ICRNL);
	term.c_oflag &= ~OPOST;
	term.c_cc[VMIN] = 1;
	term.c_cc[VTIME] = 0;
	defchars = term;
	term.c_cc[VINTR] = term.c_cc[VQUIT] = term.c_cc[VSUSP] =
	    term.c_cc[VDSUSP] = term.c_cc[VDISCARD] =
	    term.c_cc[VLNEXT] = _POSIX_VDISABLE;
	raw();

	(void)signal(SIGALRM, timeout);

	if (vgetnum(LINEDISC) != TTYDISC) {
		int ld = (int)vgetnum(LINEDISC);
		ioctl(FD, TIOCSETD, &ld);
	}

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pair) != 0) {
		(void)uu_unlock(uucplock);
		err(3, "socketpair");
	}

	/*
	 * Everything's set up now:
	 *	connection established (hardwired or dialup)
	 *	line conditioned (baud rate, mode, etc.)
	 *	internal data structures (variables)
	 * so, fork one process for local side and one for remote.
	 */
	printf("\07connected\r\n");
	tipin_pid = getpid();
	switch (tipout_pid = fork()) {
	case -1:
		(void)uu_unlock(uucplock);
		err(3, "fork");
	case 0:
		close(pair[1]);
		tipin_fd = pair[0];
		tipout();
	default:
		close(pair[0]);
		tipout_fd = pair[1];
		tipin();
	}
	/*NOTREACHED*/
	exit(0);
}

void
con(void)
{
	if (vgetstr(CONNECT) != NULL)
		parwrite(FD, vgetstr(CONNECT), size(vgetstr(CONNECT)));
	logent(vgetstr(HOST), vgetstr(DEVICE), "call completed");
}

void
cleanup(int signo)
{
	(void)uu_unlock(uucplock);
	if (odisc)
		ioctl(0, TIOCSETD, &odisc);
	unraw();
	if (signo && tipout_pid) {
		kill(tipout_pid, signo);
		wait(NULL);
	}
	exit(0);
}

/*
 * put the controlling keyboard into raw mode
 */
void
raw(void)
{
	tcsetattr(0, TCSADRAIN, &term);
}


/*
 * return keyboard to normal mode
 */
void
unraw(void)
{
	if (gotdefterm)
		tcsetattr(0, TCSADRAIN, &defterm);
}

static	jmp_buf promptbuf;

/*
 * Print string ``s'', then read a string
 *  in from the terminal.  Handles signals & allows use of
 *  normal erase and kill characters.
 */
int
prompt(char *s, char *p, size_t sz)
{
	int c;
	char *b = p;
	sig_t oint, oquit;

	stoprompt = 0;
	oint = signal(SIGINT, intprompt);
	oquit = signal(SIGQUIT, SIG_IGN);
	unraw();
	printf("%s", s);
	if (setjmp(promptbuf) == 0)
		while ((c = getchar()) != EOF && (*p = c) != '\n' && --sz > 0)
			p++;
	*p = '\0';

	raw();
	(void)signal(SIGINT, oint);
	(void)signal(SIGQUIT, oquit);
	return (stoprompt || p == b);
}

/*
 * Interrupt service routine during prompting
 */
/*ARGSUSED*/
static void
intprompt(int signo)
{
	(void)signal(SIGINT, SIG_IGN);
	stoprompt = 1;
	printf("\r\n");
	longjmp(promptbuf, 1);
}

/*
 * ****TIPIN   TIPIN****
 */
static void
tipin(void)
{
	int bol = 1;
	int gch;
	char ch;

	/*
	 * Kinda klugey here...
	 *   check for scripting being turned on from the .tiprc file,
	 *   but be careful about just using setscript(), as we may
	 *   send a SIGEMT before tipout has a chance to set up catching
	 *   it; so wait a second, then setscript()
	 */
	if (vgetnum(SCRIPT)) {
		sleep(1);
		setscript();
	}

	while (1) {
		gch = getchar();
		if (gch == EOF)
			cleanup(0);
		gch &= STRIP_PAR;
		if (gch == vgetnum(ESCAPE) && bol) {
			if (!noesc) {
				if (!(gch = escape()))
					continue;
			}
		} else if (gch == vgetnum(RAISECHAR)) {
			vsetnum(RAISE, !vgetnum(RAISE));
			continue;
		} else if (gch == '\r') {
			bol = 1;
			ch = gch;
			parwrite(FD, &ch, 1);
			if (vgetnum(HALFDUPLEX))
				printf("\r\n");
			continue;
		} else if (gch == vgetnum(FORCE)) {
			gch = getchar();
			if (gch == EOF)
				cleanup(0);
			gch &= STRIP_PAR;
		}
		bol = any(gch, vgetstr(EOL));
		if (vgetnum(RAISE) && islower(gch))
			gch = toupper(gch);
		ch = gch;
		parwrite(FD, &ch, 1);
		if (vgetnum(HALFDUPLEX))
			printf("%c", ch);
	}
}

extern esctable_t etable[];

/*
 * Escape handler --
 *  called on recognition of ``escapec'' at the beginning of a line
 */
static int
escape(void)
{
	int gch;
	esctable_t *p;
	char c = vgetnum(ESCAPE);

	gch = getchar();
	if (gch == EOF)
		cleanup(0);
	gch &= STRIP_PAR;
	for (p = etable; p->e_char; p++)
		if (p->e_char == gch) {
			printf("%s", ctrl(c));
			(*p->e_func)(gch);
			return (0);
		}
	/* ESCAPE ESCAPE forces ESCAPE */
	if (c != gch)
		parwrite(FD, &c, 1);
	return (gch);
}

int
any(int cc, char *p)
{
	char c = cc;
	while (p && *p)
		if (*p++ == c)
			return (1);
	return (0);
}

size_t
size(char *s)
{
	size_t i = 0;

	while (s && *s++)
		i++;
	return (i);
}

char *
interp(char *s)
{
	static char buf[256];
	char *p = buf, c, *q;

	while ((c = *s++)) {
		for (q = "\nn\rr\tt\ff\033E\bb"; *q; q++)
			if (*q++ == c) {
				*p++ = '\\'; *p++ = *q;
				goto next;
			}
		if (c < 040) {
			*p++ = '^'; *p++ = c + 'A'-1;
		} else if (c == 0177) {
			*p++ = '^'; *p++ = '?';
		} else
			*p++ = c;
	next:
		;
	}
	*p = '\0';
	return (buf);
}

char *
ctrl(char c)
{
	static char s[3];

	if (c < 040 || c == 0177) {
		s[0] = '^';
		s[1] = c == 0177 ? '?' : c+'A'-1;
		s[2] = '\0';
	} else {
		s[0] = c;
		s[1] = '\0';
	}
	return (s);
}

/*
 * Help command
 */
void
help(int c)
{
	esctable_t *p;

	printf("%c\r\n", c);
	for (p = etable; p->e_char; p++) {
		printf("%2s", ctrl(vgetnum(ESCAPE)));
		printf("%-2s     %s\r\n", ctrl(p->e_char), p->e_help);
	}
}

/*
 * Set up the "remote" tty's state
 */
int
ttysetup(int speed)
{
	struct termios	cntrl;

	if (tcgetattr(FD, &cntrl))
		return (-1);
	cfsetspeed(&cntrl, speed);
	cntrl.c_cflag &= ~(CSIZE|PARENB);
	cntrl.c_cflag |= CS8;
	if (vgetnum(DC))
		cntrl.c_cflag |= CLOCAL;
	if (vgetnum(HARDWAREFLOW))
		cntrl.c_cflag |= CRTSCTS;
	cntrl.c_iflag &= ~(ISTRIP|ICRNL);
	cntrl.c_oflag &= ~OPOST;
	cntrl.c_lflag &= ~(ICANON|ISIG|IEXTEN|ECHO);
	cntrl.c_cc[VMIN] = 1;
	cntrl.c_cc[VTIME] = 0;
	if (vgetnum(TAND))
		cntrl.c_iflag |= IXOFF;
	return (tcsetattr(FD, TCSAFLUSH, &cntrl));
}

static char partab[0200];

/*
 * Do a write to the remote machine with the correct parity.
 * We are doing 8 bit wide output, so we just generate a character
 * with the right parity and output it.
 */
void
parwrite(int fd, char *buf, size_t n)
{
	int i;
	char *bp;

	bp = buf;
	if (bits8 == 0)
		for (i = 0; i < n; i++) {
			*bp = partab[(*bp) & 0177];
			bp++;
		}
	if (write(fd, buf, n) < 0) {
		if (errno == EIO)
			tipabort("Lost carrier.");
		/* this is questionable */
		abort();;//
		perror("write");
	}
}

/*
 * Build a parity table with appropriate high-order bit.
 */
void
setparity(char *defparity)
{
	int i, flip, clr, set;
	char *parity;
	extern const unsigned char evenpartab[];

	if (vgetstr(PARITY) == NULL)
		vsetstr(PARITY, defparity);
	parity = vgetstr(PARITY);
	if (strcmp(parity, "none") == 0) {
		bits8 = 1;
		return;
	}
	bits8 = 0;
	flip = 0;
	clr = 0377;
	set = 0;
	if (strcmp(parity, "odd") == 0)
		flip = 0200;			/* reverse bit 7 */
	else if (strcmp(parity, "zero") == 0)
		clr = 0177;			/* turn off bit 7 */
	else if (strcmp(parity, "one") == 0)
		set = 0200;			/* turn on bit 7 */
	else if (strcmp(parity, "even") != 0) {
		(void) fprintf(stderr, "%s: unknown parity value\r\n", parity);
		(void) fflush(stderr);
	}
	for (i = 0; i < 0200; i++)
		partab[i] = ((evenpartab[i] ^ flip) | set) & clr;
}
@


1.56
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.55 2015/02/07 10:07:15 deraadt Exp $	*/
@


1.55
log
@remove unused cu(1) support in tip; it is supplied as a seperate
simpler binary written by nicm since 5.4
ok jsing dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.54 2012/12/04 19:31:17 kettenis Exp $	*/
d53 2
d86 6
a91 1
			vsetnum(BAUDRATE, atoi(&argv[1][1]));
@


1.54
log
@Get rid of two 10-year-old XXX comments and do check for getchar(3) returning
EOF.  Fixes a very annoying bug where cu(1) will start sending the EOF
"character" down the serial line at high speed if it loses its input terminal.

ok deraadt@@, nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.53 2010/07/03 03:33:12 nicm Exp $	*/
a35 2
 * or
 *  cu phone-number [-s speed] [-l line]
a59 6
	if (strcmp(__progname, "cu") == 0) {
		cumode = 1;
		cumain(argc, argv);
		goto cucommon;
	}

a113 6
cucommon:
	/*
	 * From here down the code is shared with
	 * the "cu" version of tip.
	 */

d158 1
a158 1
	printf(cumode ? "Connected\r\n" : "\07connected\r\n");
d294 1
a294 1
		} else if (!cumode && gch == vgetnum(RAISECHAR)) {
d304 1
a304 1
		} else if (!cumode && gch == vgetnum(FORCE)) {
@


1.53
log
@Changed vinit to clear the values but forgot to move it before they are set by
command line parsing.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.52 2010/07/02 07:40:03 nicm Exp $	*/
d299 4
a302 2
		gch = getchar()&STRIP_PAR;
		/* XXX does not check for EOF */
d318 6
a323 2
		} else if (!cumode && gch == vgetnum(FORCE))
			gch = getchar() & STRIP_PAR;
d347 4
a350 2
	gch = (getchar()&STRIP_PAR);
	/* XXX does not check for EOF */
@


1.52
log
@Clear table and set defaults manually, also move table into value.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.51 2010/07/02 07:32:16 nicm Exp $	*/
d57 2
a106 2

	vinit();
@


1.51
log
@Merge almost-empty pathnames.h into tip.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.50 2010/07/02 05:52:48 nicm Exp $	*/
d106 2
d110 1
a111 1
	vinit();				/* init variables */
@


1.50
log
@Rewrite hunt() to put the "rotary action" into it rather than remote.c, and so
it isn't so stupid (returning a char * as a long which goes into an int to use
as a flag, ugh).
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.49 2010/07/01 21:47:09 nicm Exp $	*/
a45 1
#include "pathnames.h"
@


1.49
log
@Nix some warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.48 2010/07/01 21:28:01 nicm Exp $	*/
d107 1
a107 9
	if ((i = hunt(sys)) == 0) {
		printf("all ports busy\n");
		exit(3);
	}
	if (i == -1) {
		printf("link down\n");
		(void)uu_unlock(uucplock);
		exit(3);
	}
@


1.48
log
@Change variable get/set macros to have better names and drop boolean/character
ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.47 2010/07/01 20:24:19 chl Exp $	*/
d43 2
d122 1
a122 1
		fprintf(stderr, "%s: bad baud rate %ld\n", __progname,
@


1.47
log
@remove unused variables
add missing headers needed for uu_unlock()

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.46 2010/06/30 00:09:27 nicm Exp $	*/
d57 1
a57 1
	setboolean(value(DC), 1);
d89 1
a89 1
			setnumber(value(BAUDRATE), atoi(&argv[1][1]));
d119 1
a119 1
	if (ttysetup(number(value(BAUDRATE)))) {
d121 1
a121 1
		    number(value(BAUDRATE)));
d160 2
a161 2
	if (value(LINEDISC) != TTYDISC) {
		int ld = (int)value(LINEDISC);
d163 1
a163 1
	}		
d199 3
a201 3
	if (value(CONNECT) != NULL)
		parwrite(FD, value(CONNECT), size(value(CONNECT)));
	logent(value(HOST), value(DEVICE), "call completed");
d298 1
a298 1
	if (boolean(value(SCRIPT))) {
d306 1
a306 1
		if ((gch == character(value(ESCAPE))) && bol) {
d311 2
a312 2
		} else if (!cumode && gch == character(value(RAISECHAR))) {
			setboolean(value(RAISE), !boolean(value(RAISE)));
d318 1
a318 1
			if (boolean(value(HALFDUPLEX)))
d321 4
a324 4
		} else if (!cumode && gch == character(value(FORCE)))
			gch = getchar()&STRIP_PAR;
		bol = any(gch, value(EOL));
		if (boolean(value(RAISE)) && islower(gch))
d328 1
a328 1
		if (boolean(value(HALFDUPLEX)))
d344 1
a344 1
	char c = character(value(ESCAPE));
d431 1
a431 1
		printf("%2s", ctrl(character(value(ESCAPE))));
d449 1
a449 1
	if (boolean(value(DC)))
d451 1
a451 1
	if (boolean(value(HARDWAREFLOW)))
d458 1
a458 1
	if (boolean(value(TAND)))
d486 1
d501 3
a503 3
	if (value(PARITY) == NULL)
		value(PARITY) = defparity;
	parity = value(PARITY);
@


1.46
log
@Unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.45 2010/06/29 23:38:05 nicm Exp $	*/
d53 1
a53 1
	char *sys = NULL, sbuf[12], *p;
@


1.45
log
@Add new read-only vtable entries for device and connection string and use those
instead of variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.44 2010/06/29 23:32:52 nicm Exp $	*/
a44 3

int	disc = TTYDISC;		/* tip normally runs this way */
char	PNbuf[256];			/* This limits the size of a number */
@


1.44
log
@Since dial-up is no longer supported, no need to store a phone number, or
accept one to cu(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.43 2010/06/29 23:10:56 nicm Exp $	*/
d202 3
a204 3
	if (CM != NULL)
		parwrite(FD, CM, size(CM));
	logent(value(HOST), DV, "call completed");
@


1.43
log
@For every variable which has a value table entry with IREMOTE, remove the
remote variable and always use the value from the vtable. This then allows the
IREMOTE flag to be removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.42 2010/06/29 21:34:50 nicm Exp $	*/
a101 22
	if (sys == NULL)
		goto notnumber;
	if (isalpha(*sys))
		goto notnumber;
	/*
	 * System name is really a phone number...
	 * Copy the number then stomp on the original (in case the number
	 *	is private, we don't want 'ps' or 'w' to find it).
	 */
	if (strlen(sys) > sizeof PNbuf - 1) {
		fprintf(stderr, "%s: phone number too long (max = %d bytes)\n",
			__progname, (int)sizeof(PNbuf) - 1);
		exit(1);
	}
	strlcpy(PNbuf, sys, sizeof PNbuf - 1);
	for (p = sys; *p; p++)
		*p = '\0';
	PN = PNbuf;
	(void)snprintf(sbuf, sizeof(sbuf), "tip%ld", number(value(BAUDRATE)));
	sys = sbuf;

notnumber:
@


1.42
log
@Merge v_type and v_access into one v_flags member in value_t, get rid of TRUE
and FALSE, and rename the other flags to have a V_ prefix.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.41 2010/06/29 17:42:35 nicm Exp $	*/
d92 1
a92 1
			BR = atoi(&argv[1][1]);
d120 1
a120 1
	(void)snprintf(sbuf, sizeof(sbuf), "tip%ld", BR);
@


1.41
log
@Now that there is no dial-up support, all connections are hardwired so drop the
flag and ignore the -t option to cu(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.40 2010/06/29 16:41:56 nicm Exp $	*/
d60 1
a60 1
	setboolean(value(DC), TRUE);
@


1.40
log
@Bye-bye acu which even UUCP-using naddy agrees "was obsolete 20 years ago" :-).
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.39 2010/06/29 05:55:37 nicm Exp $	*/
d144 1
a144 6
	/*
	 * Hardwired connections require the
	 *  line speed set before they make any transmissions
	 *  (this is particularly true of things like a DF03-AC)
	 */
	if (HW && ttysetup(number(value(BAUDRATE)))) {
d151 1
a151 6
	if (!HW && ttysetup(number(value(BAUDRATE)))) {
		fprintf(stderr, "%s: bad baud rate %ld\n", __progname,
		    number(value(BAUDRATE)));
		(void)uu_unlock(uucplock);
		exit(3);
	}
@


1.39
log
@Replace "nice" strcmp() wrapper macro with strcmp.

ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.38 2009/12/12 18:26:23 nicm Exp $	*/
d37 1
a37 1
 *  cu phone-number [-s speed] [-l line] [-a acu]
a140 7

	/*
	 * Kludge, their's no easy way to get the initialization
	 *   in the right order, so force it here
	 */
	if ((PH = getenv("PHONES")) == NULL)
		PH = _PATH_PHONES;
d155 1
a155 5
	if ((p = con())) {
		printf("\07%s\n[EOT]\n", p);
		(void)uu_unlock(uucplock);
		exit(1);
	}
d229 8
@


1.38
log
@Whoops, missed these.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.37 2009/12/12 18:14:00 nicm Exp $	*/
d62 1
a62 1
	if (equal(__progname, "cu")) {
d541 1
a541 1
	if (equal(parity, "none")) {
d549 1
a549 1
	if (equal(parity, "odd"))
d551 1
a551 1
	else if (equal(parity, "zero"))
d553 1
a553 1
	else if (equal(parity, "one"))
d555 1
a555 1
	else if (!equal(parity, "even")) {
@


1.37
log
@tip is not setuid or setgid anymore and there are no PRIV/EXPR commands, so
remove the code.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.36 2009/12/12 13:38:09 nicm Exp $	*/
a211 1
		daemon_uid();
a226 1
		daemon_uid();
@


1.36
log
@Use a socketpair instead of a pair of pipes.

looks ok to millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.35 2009/10/27 23:59:45 deraadt Exp $	*/
a61 4
	gid = getgid();
	egid = getegid();
	uid = getuid();
	euid = geteuid();
a142 9
	 * Now that we have the logfile and the ACU open
	 *  return to the real uid and gid.  These things will
	 *  be closed on exit.  Swap real and effective uid's
	 *  so we can get the original permissions back
	 *  for removing the uucp lock.
	 */
	user_uid();

	/*
a158 1
		daemon_uid();
a163 1
		daemon_uid();
a169 1
		daemon_uid();
a246 1
	daemon_uid();
a258 36
 * Muck with user ID's.  We are setuid to the owner of the lock
 * directory when we start.  user_uid() reverses real and effective
 * ID's after startup, to run with the user's permissions.
 * daemon_uid() switches back to the privileged uid for unlocking.
 * Finally, to avoid running a shell with the wrong real uid,
 * shell_uid() sets real and effective uid's to the user's real ID.
 */
static int uidswapped;

void
user_uid(void)
{
	if (uidswapped == 0) {
		seteuid(uid);
		uidswapped = 1;
	}
}

void
daemon_uid(void)
{

	if (uidswapped) {
		seteuid(euid);
		uidswapped = 0;
	}
}

void
shell_uid(void)
{
	setegid(gid);
	seteuid(uid);
}

/*
a389 2
			if ((p->e_flags&PRIV) && uid)
				continue;
a470 2
		if ((p->e_flags&PRIV) && uid)
			continue;
d472 1
a472 2
		printf("%-2s %c   %s\r\n", ctrl(p->e_char),
			p->e_flags&EXP ? '*': ' ', p->e_help);
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.34 2008/06/01 18:38:29 sobrado Exp $	*/
d39 4
d57 1
a57 1
	int i;
a219 1
	pipe(fildes); pipe(repdes);
d227 6
d242 12
a253 1
	if ((tipout_pid = fork()))
d255 1
a255 2
	else
		tipout();
@


1.34
log
@synchronize synopsis and usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.33 2007/05/15 19:42:05 moritz Exp $	*/
a31 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)tip.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] = "$OpenBSD: tip.c,v 1.33 2007/05/15 19:42:05 moritz Exp $";
#endif /* not lint */
@


1.33
log
@Remove useless NOxxx defines and use NULL instead.
No binary change.

OK ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.32 2006/11/27 23:19:41 mcbride Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.32 2006/11/27 23:19:41 mcbride Exp $";
d82 1
a82 1
		fprintf(stderr, "usage: tip [-v] [-speed] [system-name]\n");
@


1.32
log
@Back out revision 1.31, restoring the ":dc: is always set" behaviour.
Fixes hangs seen with uplcom(4) and serial console.

testing pedro jolan
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.31 2006/09/22 14:44:27 jason Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.31 2006/09/22 14:44:27 jason Exp $";
d65 1
a65 1
	char *sys = NOSTR, sbuf[12], *p;
d115 1
a115 1
	if (sys == NOSTR)
d168 1
a168 1
	if ((PH = getenv("PHONES")) == NOSTR)
d592 1
a592 1
	if (value(PARITY) == NOSTR)
@


1.31
log
@remove the :dc: is always set behavior (use cua devices or /etc/remote
entries to override); ok deraadt awhile ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.30 2006/08/18 03:06:18 jason Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.30 2006/08/18 03:06:18 jason Exp $";
d67 3
@


1.30
log
@tip/cu always set "dc" because the code was reading from the wrong value
in the array.  Point it at the correct chunk of memory.  For now, also
preserve the old ":dc:" is always set behavior.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.29 2006/06/06 23:24:52 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.29 2006/06/06 23:24:52 deraadt Exp $";
a66 3

	/* XXX preserve previous braindamaged behavior */
	setboolean(value(DC), TRUE);
@


1.29
log
@teach tip about line disciplines; tried by mbalmer too
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.28 2006/03/17 21:43:51 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.28 2006/03/17 21:43:51 deraadt Exp $";
d67 3
@


1.28
log
@size_t size()
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.27 2006/03/17 19:39:46 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.27 2006/03/17 19:39:46 deraadt Exp $";
d228 5
@


1.27
log
@more cleanups; ok moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.26 2006/03/17 14:43:06 moritz Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.26 2006/03/17 14:43:06 moritz Exp $";
d451 1
a451 1
int
d454 1
a454 1
	int i = 0;
@


1.26
log
@big prototype cleanup:

o make more functions static
o add all the prototypes to tip.h
o consistently declare functions in the cmd table

testing and ok dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.25 2006/03/16 19:32:46 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.25 2006/03/16 19:32:46 deraadt Exp $";
d65 1
a65 1
	char *system = NOSTR, sbuf[12], *p;
d89 1
a89 1
			system = argv[1];
d112 1
a112 1
	if (system == NOSTR)
d114 1
a114 1
	if (isalpha(*system))
d121 1
a121 1
	if (strlen(system) > sizeof PNbuf - 1) {
d126 2
a127 2
	strncpy( PNbuf, system, sizeof PNbuf - 1 );
	for (p = system; *p; p++)
d131 1
a131 1
	system = sbuf;
d140 1
a140 1
	if ((i = hunt(system)) == 0) {
d252 1
a252 1
		ioctl(0, TIOCSETD, (char *)&odisc);
d350 1
d366 1
a366 1
	char bol = 1;
d555 1
a555 1
parwrite(int fd, char *buf, int n)
@


1.25
log
@first pass of cleanup of this mess; ok dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.24 2004/11/07 09:48:08 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.24 2004/11/07 09:48:08 otto Exp $";
a55 3
void	intprompt();
void	timeout();
void	cleanup(int);
d58 4
a248 1

d350 2
a351 2
void
intprompt(void)
a352 1

d362 1
a362 1
void
d417 1
a417 1
int
d505 1
a505 1
help(char c)
@


1.24
log
@Do not ignore SIGCHLD, repairing hangs after a subshell is executed
via ~! or ~C. While there, fix description of fd's available to the
command executed by ~C in man page and comments. This has been wrong
since at least 4.4BSD... Spotted by Hugo Villeneuve. PR 3971.  ok
and help millert@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.23 2004/05/26 18:17:59 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.23 2004/05/26 18:17:59 deraadt Exp $";
d62 1
a62 3
main(argc, argv)
	int argc;
	char *argv[];
d64 1
a64 1
	char *system = NOSTR;
a65 2
	char *p;
	char sbuf[12];
d181 1
a181 1
	if ((p = connect())) {
d221 2
a222 2
		term.c_cc[VDSUSP] = term.c_cc[VDISCARD] = 
	 	term.c_cc[VLNEXT] = _POSIX_VDISABLE;
d272 1
a272 1
user_uid()
d281 1
a281 1
daemon_uid()
d291 1
a291 1
shell_uid()
d301 1
a301 1
raw()
d311 1
a311 1
unraw()
d325 1
a325 4
prompt(s, p, sz)
	char *s;
	char *p;
	size_t sz;
d351 1
a351 1
intprompt()
d364 1
a364 1
tipin()
d419 1
a419 1
escape()
d442 1
a442 3
any(cc, p)
	int cc;
	char *p;
d452 1
a452 2
size(s)
	char *s;
d462 1
a462 2
interp(s)
	char *s;
d487 1
a487 2
ctrl(c)
	char c;
d506 1
a506 2
help(c)
	char c;
d524 1
a524 2
ttysetup(speed)
	int speed;
d536 1
a536 1
		cntrl.c_cflag |= CRTSCTS;	
d555 1
a555 4
parwrite(fd, buf, n)
	int fd;
	char *buf;
	int n;
d578 1
a578 2
setparity(defparity)
	char *defparity;
@


1.23
log
@if one process is killed, kill the other ourself; various ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.22 2003/10/15 22:33:18 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.22 2003/10/15 22:33:18 deraadt Exp $";
d141 1
a141 1
	(void)signal(SIGCHLD, SIG_IGN);
@


1.23.2.1
log
@MFC:
Fix by otto@@

Do not ignore SIGCHLD, repairing hangs after a subshell is executed
via ~! or ~C. While there, fix description of fd's available to the
command executed by ~C in man page and comments. This has been wrong
since at least 4.4BSD... Spotted by Hugo Villeneuve. PR 3971.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.23 2004/05/26 18:17:59 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.23 2004/05/26 18:17:59 deraadt Exp $";
d141 1
a141 1
	(void)signal(SIGCHLD, SIG_DFL);
@


1.22
log
@on fatal error, repair tty; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.21 2003/09/20 18:15:32 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.21 2003/09/20 18:15:32 millert Exp $";
d58 1
a58 1
void	cleanup();
d141 1
d207 1
a207 1
		cleanup();
d212 1
a212 1
		cleanup();
d240 2
a241 1
	if ((pid = fork()))
d250 1
a250 1
cleanup()
d258 4
@


1.21
log
@Implement hardwareflow varable in tip(1) like Solaris and hf in /etc/remote.
Based on PR 3411 from Matthew Gream
Also document "tandem" variable (XON/XOFF) in tip man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.20 2003/06/03 02:56:18 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.20 2003/06/03 02:56:18 millert Exp $";
d215 1
d255 1
d311 2
a312 1
	tcsetattr(0, TCSADRAIN, &defterm);
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.19 2002/05/29 22:58:56 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.19 2002/05/29 22:58:56 millert Exp $";
d540 2
@


1.19
log
@Don't hard-code a list of allowed baud rates.  Instead, accept
anything but check the return value of tcsetattr() and error out
if it fails.  This way we accept any baud rate the serial driver
will support.  mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.18 2002/05/07 06:56:50 hugh Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.18 2002/05/07 06:56:50 hugh Exp $";
@


1.18
log
@Carefully applied -Wall fixups from <panda@@omatis.com>.
Also a little KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.17 2002/03/25 16:41:36 deraadt Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: tip.c,v 1.17 2002/03/25 16:41:36 deraadt Exp $";
a58 8
/*
 * Baud rate mapping table
 */
int rates[] = {
	0, 50, 75, 110, 134, 150, 200, 300, 600,
	1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, -1
};

a174 7
	if ((i = speed(number(value(BAUDRATE)))) == 0) {
		printf("%s: bad baud rate %ld\n", __progname,
		    number(value(BAUDRATE)));
		daemon_uid();
		(void)uu_unlock(uucplock);
		exit(3);
	}
d181 7
a187 2
	if (HW)
		ttysetup(i);
d194 7
a200 2
	if (!HW)
		ttysetup(i);
a443 12
speed(n)
	int n;
{
	int *p;

	for (p = rates; *p != -1;  p++)
		if (*p == n)
			return n;
	return 0;
}

int
d531 1
a531 1
void
d537 3
a539 3
	tcgetattr(FD, &cntrl);
	cfsetospeed(&cntrl, speed);
	cfsetispeed(&cntrl, speed);
d551 1
a551 1
	tcsetattr(FD, TCSAFLUSH, &cntrl);
@


1.17
log
@bring in prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.16 2002/02/25 00:20:19 deraadt Exp $	*/
d38 1
a38 1
static char copyright[] =
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.16 2002/02/25 00:20:19 deraadt Exp $";
d634 1
a634 1
		partab[i] = (evenpartab[i] ^ flip | set) & clr;
@


1.16
log
@mark getc uses with regard to int and EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.15 2001/10/24 18:38:58 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.15 2001/10/24 18:38:58 millert Exp $";
d375 1
d402 2
a403 1
			parwrite(FD, &gch, 1);
d412 2
a413 1
		parwrite(FD, &gch, 1);
d415 1
a415 1
			printf("%c", gch);
@


1.15
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.14 2001/09/26 06:07:28 pvalchev Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.14 2001/09/26 06:07:28 pvalchev Exp $";
d373 2
a374 1
	char gch, bol = 1;
d390 1
d425 1
a425 1
	char gch;
d430 1
@


1.14
log
@Wall cleanup w/ some fixes; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.13 2001/09/09 19:30:49 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.13 2001/09/09 19:30:49 millert Exp $";
d79 2
a80 2
	register int i;
	register char *p;
d334 2
a335 2
	register int c;
	register char *b = p;
d423 2
a424 2
	register char gch;
	register esctable_t *p;
d446 1
a446 1
	register int *p;
d456 1
a456 1
	register int cc;
d468 1
a468 1
	register char	*s;
d470 1
a470 1
	register int i = 0;
d479 1
a479 1
	register char *s;
d482 1
a482 1
	register char *p = buf, c, *q;
d527 1
a527 1
	register esctable_t *p;
d576 1
a576 1
	register int n;
d578 2
a579 3
	register int i;
	register char *bp;
	extern int errno;
d602 1
a602 1
	register int i, flip, clr, set;
@


1.13
log
@implement some more command line options for cu and use getopt(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.12 2001/04/12 19:21:43 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.12 2001/04/12 19:21:43 millert Exp $";
d138 1
a138 1
			__progname, sizeof(PNbuf) - 1);
@


1.12
log
@Change tip default from even parity to no parity which is more in line
with user expectations.
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.11 2000/04/20 06:19:33 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.11 2000/04/20 06:19:33 deraadt Exp $";
a70 1
char	*sname();
d87 1
a87 1
	if (equal(sname(argv[0]), "cu")) {
d98 1
a98 1
		fprintf(stderr, "tip: must be interactive\n");
d121 2
a122 1
			fprintf(stderr, "tip: %s, unknown option\n", argv[1]);
d137 2
a138 2
		fprintf(stderr, "tip: phone number too long (max = %d bytes)\n",
			sizeof PNbuf - 1);
d184 2
a185 1
		printf("tip: bad baud rate %ld\n", number(value(BAUDRATE)));
a562 16
}

/*
 * Return "simple" name from a file name,
 * strip leading directories.
 */
char *
sname(s)
	register char *s;
{
	register char *p = s;

	while (*s)
		if (*s++ == '/')
			p = s;
	return (p);
@


1.11
log
@avoid naming something pwrite()
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.10 2000/01/09 05:38:47 jason Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.10 2000/01/09 05:38:47 jason Exp $";
d182 1
a182 1
	setparity("even");			/* set the parity table */
@


1.10
log
@remove O_NONBLOCK from tty fd so we don't spin with EAGAIN
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.9 1998/07/12 05:27:04 todd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.9 1998/07/12 05:27:04 todd Exp $";
d398 1
a398 1
			pwrite(FD, &gch, 1);
d407 1
a407 1
		pwrite(FD, &gch, 1);
d437 1
a437 1
		pwrite(FD, &c, 1);
d588 1
a588 1
pwrite(fd, buf, n)
@


1.9
log
@add no escape option (-n)
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.8 1997/09/01 23:24:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.8 1997/09/01 23:24:26 deraadt Exp $";
d210 11
@


1.8
log
@Wall pass, and oflow fix from eivind@@bitbox.follo.net
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.7 1997/08/25 16:30:13 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.7 1997/08/25 16:30:13 deraadt Exp $";
d112 4
d378 4
a381 2
			if (!(gch = escape()))
				continue;
@


1.7
log
@clean gid too
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.6 1997/08/22 22:42:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.6 1997/08/22 22:42:07 millert Exp $";
d74 1
d76 1
d141 1
a141 1
	(void)snprintf(sbuf, sizeof(sbuf), "tip%d", BR);
d180 1
a180 1
		printf("tip: bad baud rate %d\n", number(value(BAUDRATE)));
d193 1
a193 1
	if (p = connect()) {
d231 1
a231 1
	if (pid = fork())
d236 1
d260 1
d269 1
d279 1
d289 1
d299 1
d312 1
d315 1
a315 1
	register char *p;
d354 1
d402 1
d424 1
d436 4
a439 2
any(c, p)
	register char c, *p;
d441 1
d448 1
d466 1
a466 1
	while (c = *s++) {
d505 1
d524 1
d570 1
d597 1
@


1.6
log
@Buf oflow fix from Warner Losh <imp@@rover.village.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.5 1997/04/20 23:29:33 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.5 1997/04/20 23:29:33 millert Exp $";
d276 1
@


1.5
log
@Incorporate some NetBSD changes:
tip.c
    getchar() returns an int [important since EOF == -1] (thorpej)
    Set CLOCAL if dc flag is set (mellon)
tip.h
    Change booleans from char to short so that comparisons against negative
    values work as expected on systems with unsigned chars. (thorpej)
    Add boolean for dc flag (mellon)
hunt.c
    Set O_NONBLOCK if dc flag set. Don't set HUPCL if dc flag is set. (mellon)
remote.c
    Add boolean for dc flag (mellon)
@
text
@d1 1
a1 1
/*	$OpenBSD: tip.c,v 1.4 1997/04/02 01:47:03 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.4 1997/04/02 01:47:03 millert Exp $";
d303 1
a303 1
prompt(s, p)
d306 1
d318 1
a318 1
		while ((c = getchar()) != EOF && (*p = c) != '\n')
@


1.4
log
@Merge in good changes from NetBSD:
    Compile in strcict ansi (some day I'll get around to -Wall)
    use set* functions instead of modifying the lvalue
    Change a few sprintf() to snprintf() where it coudl possibly matter.
    Replace zzhack stuff with something saner to make tip work on alpha
@
text
@d1 2
a2 2
/*	$OpenBSD: tip.c,v 1.3 1996/06/26 05:40:47 deraadt Exp $	*/
/*	$NetBSD: tip.c,v 1.11 1997/02/11 09:24:06 mrg Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.3 1996/06/26 05:40:47 deraadt Exp $";
d307 1
d317 1
a317 1
		while ((*p = getchar()) != EOF && *p != '\n')
d515 2
@


1.3
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: tip.c,v 1.8 1995/10/29 00:49:42 pk Exp $	*/
/*	$NetBSD: tip.c,v 1.8 1995/10/29 00:49:42 pk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tip.c,v 1.8 1995/10/29 00:49:42 pk Exp $";
d139 1
a139 1
	(void)sprintf(sbuf, "tip%d", BR);
d364 1
a364 1
			boolean(value(RAISE)) = !boolean(value(RAISE));
d578 1
a578 1
	extern char evenpartab[];
@


1.2
log
@from netbsd:
Convert to termios (from Scott Reynolds; PR#1621).
8-bit patches (from Matthieu Herrb; PR#1384).
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: tip.c,v 1.8 1995/10/29 00:49:42 pk Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tip.c,v 1.7 1995/08/11 00:10:40 jtc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: tip.c,v 1.7 1995/08/11 00:10:40 jtc Exp $";
d61 1
a61 1
int bauds[] = {
d66 1
a66 1
int	disc = OTTYDISC;		/* tip normally runs this way */
d176 1
a176 1
	if ((i = speed(number(value(BAUDRATE)))) == NULL) {
d204 11
a214 11
	ioctl(0, TIOCGETP, (char *)&defarg);
	ioctl(0, TIOCGETC, (char *)&defchars);
	ioctl(0, TIOCGLTC, (char *)&deflchars);
	ioctl(0, TIOCGETD, (char *)&odisc);
	arg = defarg;
	arg.sg_flags = ANYP | CBREAK;
	tchars = defchars;
	tchars.t_intrc = tchars.t_quitc = -1;
	ltchars = deflchars;
	ltchars.t_suspc = ltchars.t_dsuspc = ltchars.t_flushc
		= ltchars.t_lnextc = -1;
d283 1
a283 5

	ioctl(0, TIOCSETP, &arg);
	ioctl(0, TIOCSETC, &tchars);
	ioctl(0, TIOCSLTC, &ltchars);
	ioctl(0, TIOCSETD, (char *)&disc);
d292 1
a292 5

	ioctl(0, TIOCSETD, (char *)&odisc);
	ioctl(0, TIOCSETP, (char *)&defarg);
	ioctl(0, TIOCSETC, (char *)&defchars);
	ioctl(0, TIOCSLTC, (char *)&deflchars);
d358 1
a358 1
		gch = getchar()&0177;
d372 1
a372 1
			gch = getchar()&0177;
d394 1
a394 1
	gch = (getchar()&0177);
d414 1
a414 1
	for (p = bauds; *p != -1;  p++)
d416 2
a417 2
			return (p - bauds);
	return (NULL);
d506 1
a506 1
	unsigned bits = LDECCTQ;
d508 10
a517 2
	arg.sg_ispeed = arg.sg_ospeed = speed;
	arg.sg_flags = RAW;
d519 2
a520 3
		arg.sg_flags |= TANDEM;
	ioctl(FD, TIOCSETP, (char *)&arg);
	ioctl(FD, TIOCLBIS, (char *)&bits);
a539 1
static int bits8;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
