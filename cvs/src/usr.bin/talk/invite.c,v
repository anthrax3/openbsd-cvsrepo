head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.12
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.4
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.8
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.12
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.14
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.12
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.14
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.12
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.10
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.16;
commitid	JEVxsRygqcjPtWTf;

1.16
date	2016.02.01.07.29.25;	author mestre;	state Exp;
branches;
next	1.15;
commitid	Pn9SmnrokNcgT1A4;

1.15
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.25.21.27.16;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.02.21.04.42;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.26.04.41.48;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.22.20.52;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.21.06.16.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.03.03.20.43.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.08.18.04.02.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.04.28.22.13.27;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	98.04.27.15.45.49;	author pjanzen;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.40.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.29.12.32.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.12;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@/*	$OpenBSD: invite.c,v 1.16 2016/02/01 07:29:25 mestre Exp $	*/
/*	$NetBSD: invite.c,v 1.3 1994/12/09 02:14:18 jtc Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <setjmp.h>
#include <unistd.h>

#include "talk.h"
#include "talk_ctl.h"

#define STRING_LENGTH 158

/*
 * There wasn't an invitation waiting, so send a request containing
 * our sockt address to the remote talk daemon so it can invite
 * him
 */

/*
 * The msg.id's for the invitations
 * on the local and remote machines.
 * These are used to delete the
 * invitations.
 */
int	local_id, remote_id;
jmp_buf invitebuf;

void
invite_remote(void)
{
	int new_sockt;
	struct itimerval itimer;
	CTL_RESPONSE response;
	struct sockaddr rp;
	socklen_t rplen = sizeof(struct sockaddr);
	struct hostent *rphost;
	char rname[STRING_LENGTH];

	itimer.it_value.tv_sec = RING_WAIT;
	itimer.it_value.tv_usec = 0;
	itimer.it_interval = itimer.it_value;
	if (listen(sockt, 5) != 0)
		quit("Error on attempt to listen for caller", 1);
#ifdef MSG_EOR
	/* copy new style sockaddr to old, swap family (short in old) */
	msg.addr = *(struct osockaddr *)&my_addr;  /* XXX new to old  style*/
	msg.addr.sa_family = htons(my_addr.sin_family);
#else
	msg.addr = *(struct sockaddr *)&my_addr;
#endif
	msg.id_num = htonl(-1);		/* an impossible id_num */
	invitation_waiting = 1;
	announce_invite();
	/*
	 * Shut off the automatic messages for a while,
	 * so we can use the interrupt timer to resend the invitation.
	 * We no longer turn automatic messages back on to avoid a bonus
	 * message after we've connected; this is okay even though end_msgs()
	 * gets called again in main().
	 */
	end_msgs();
	setitimer(ITIMER_REAL, &itimer, NULL);
	message("Waiting for your party to respond");
	signal(SIGALRM, re_invite);
	(void) setjmp(invitebuf);
	while ((new_sockt = accept(sockt, &rp, &rplen)) == -1) {
		if (errno == EINTR || errno == EWOULDBLOCK ||
		    errno == ECONNABORTED)
			continue;
		quit("Unable to connect with your party", 1);
	}
	close(sockt);
	sockt = new_sockt;

	/*
	 * Have the daemons delete the invitations now that we
	 * have connected.
	 */
	msg.id_num = htonl(local_id);
	ctl_transact(my_machine_addr, msg, DELETE, &response);
	msg.id_num = htonl(remote_id);
	ctl_transact(his_machine_addr, msg, DELETE, &response);
	invitation_waiting = 0;

	/*
	 * Check to see if the other guy is coming from the machine
	 * we expect.
	 */
	if (his_machine_addr.s_addr !=
	    ((struct sockaddr_in *)&rp)->sin_addr.s_addr) {
		rphost = gethostbyaddr((char *) &((struct sockaddr_in
		    *)&rp)->sin_addr, sizeof(struct in_addr), AF_INET);
		if (rphost)
			snprintf(rname, STRING_LENGTH,
			    "Answering talk request from %s@@%s", msg.r_name,
			    rphost->h_name);
		else
			snprintf(rname, STRING_LENGTH,
			    "Answering talk request from %s@@%s", msg.r_name,
			    inet_ntoa(((struct sockaddr_in *)&rp)->sin_addr));
		message(rname);
	}
}

/*
 * Routine called on interrupt to re-invite the callee
 */
void
re_invite(int dummy)
{
	message("Ringing your party again");
	/* force a re-announce */
	msg.id_num = htonl(remote_id + 1);
	announce_invite();
	longjmp(invitebuf, 1);
}

static	char *answers[] = {
	"answer #0",					/* SUCCESS */
	"Your party is not logged on",			/* NOT_HERE */
	"Target machine is too confused to talk to us",	/* FAILED */
	"Target machine does not recognize us",		/* MACHINE_UNKNOWN */
	"Your party is refusing messages",		/* PERMISSION_REFUSED */
	"Target machine can not handle remote talk",	/* UNKNOWN_REQUEST */
	"Target machine indicates protocol mismatch",	/* BADVERSION */
	"Target machine indicates protocol botch (addr)",/* BADADDR */
	"Target machine indicates protocol botch (ctl_addr)",/* BADCTLADDR */
};
#define NANSWERS (sizeof (answers) / sizeof (answers[0]))

/*
 * Transmit the invitation and process the response
 */
void
announce_invite(void)
{
	CTL_RESPONSE response;

	current_state = "Trying to connect to your party's talk daemon";
	ctl_transact(his_machine_addr, msg, ANNOUNCE, &response);
	remote_id = response.id_num;
	if (response.answer != SUCCESS)
		quit(response.answer < NANSWERS ? answers[response.answer] : NULL, 0);
	/* leave the actual invitation on my talk daemon */
	ctl_transact(my_machine_addr, msg, LEAVE_INVITE, &response);
	local_id = response.id_num;
}

/*
 * Tell the daemon to remove your invitation
 */
void
send_delete(void)
{

	msg.type = DELETE;
	/*
	 * This is just a extra clean up, so just send it
	 * and don't wait for an answer
	 */
	msg.id_num = htonl(remote_id);
	daemon_addr.sin_addr = his_machine_addr;
	if (sendto(ctl_sockt, &msg, sizeof (msg), 0,
	    (struct sockaddr *)&daemon_addr,
	    sizeof (daemon_addr)) != sizeof(msg))
		warn("send_delete (remote)");
	msg.id_num = htonl(local_id);
	daemon_addr.sin_addr = my_machine_addr;
	if (sendto(ctl_sockt, &msg, sizeof (msg), 0,
	    (struct sockaddr *)&daemon_addr,
	    sizeof (daemon_addr)) != sizeof (msg))
		warn("send_delete (local)");
}
@


1.16
log
@Remove unused headers and sort the remaining
Remove lint-style comments
Swap hardcoded string on usage() for __progname

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.15 2013/03/11 17:40:11 deraadt Exp $	*/
d96 1
a96 1
	setitimer(ITIMER_REAL, &itimer, (struct itimerval *)0);
@


1.15
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.14 2009/10/27 23:59:44 deraadt Exp $	*/
d33 1
a33 1
#include "talk.h"
d35 3
a37 1
#include <sys/time.h>
a38 1
#include <errno.h>
d41 2
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.13 2007/05/25 21:27:16 krw Exp $	*/
d98 2
a99 1
		if (errno == EINTR || errno == ECONNABORTED)
@


1.13
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.12 2004/03/02 21:04:42 tedu Exp $	*/
a31 7

#ifndef lint
#if 0
static char sccsid[] = "@@(#)invite.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] = "$OpenBSD: invite.c,v 1.12 2004/03/02 21:04:42 tedu Exp $";
#endif /* not lint */
@


1.12
log
@use socklen_t and better socket() checks.  from Andrey Matveev
-Wall for good measure
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.11 2003/09/26 04:41:48 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: invite.c,v 1.11 2003/09/26 04:41:48 deraadt Exp $";
d143 1
a143 1
 * Routine called on interupt to re-invite the callee
@


1.11
log
@retry for ECONNABORTED too
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.10 2003/06/10 22:20:52 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.10 2003/06/10 22:20:52 deraadt Exp $";
d73 1
a73 1
	int rplen = sizeof(struct sockaddr);
d104 1
a104 1
	while ((new_sockt = accept(sockt, &rp, &rplen)) < 0) {
@


1.10
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.9 2003/06/03 02:56:17 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.9 2003/06/03 02:56:17 millert Exp $";
d105 1
a105 1
		if (errno == EINTR)
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.8 2002/06/21 06:16:44 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.8 2002/06/21 06:16:44 millert Exp $";
d67 1
a67 1
invite_remote()
d146 1
a146 2
re_invite(dummy)
	int dummy;
d172 1
a172 1
announce_invite()
d190 1
a190 1
send_delete()
@


1.8
log
@o Resize nicely when we receive SIGWINCH
o Also change some 0-2 to *_FILENO
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.7 1999/03/03 20:43:30 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.7 1999/03/03 20:43:30 millert Exp $";
@


1.7
log
@Print fatal errors to stderr after curses has finished instead of printing to the curses window which disapears immediately for terminals that can restore the screen.
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.6 1998/08/18 04:02:15 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.6 1998/08/18 04:02:15 millert Exp $";
a46 1
#include <signal.h>
@


1.6
log
@Some changes inspired by FreeBSD...
 o Kill annoying spaces at the end of lines
 o sigaction, not sigvec
 o warn/err where sensible
 o hstrerror() not herror()
 o defaults for erase, kill, and werase if not set
 o kill a needless refresh() after the beeps that was messing up the screen
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.5 1998/04/28 22:13:27 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.5 1998/04/28 22:13:27 pjanzen Exp $";
d86 1
a86 1
		p_error("Error on attempt to listen for caller");
d112 1
a112 1
		p_error("Unable to connect with your party");
d185 2
a186 5
	if (response.answer != SUCCESS) {
		if (response.answer < NANSWERS)
			message(answers[response.answer]);
		quit();
	}
@


1.5
log
@NetBSD-based -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.4 1998/04/27 15:45:49 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.4 1998/04/27 15:45:49 pjanzen Exp $";
d59 1
a59 1
 * him 
d65 1
a65 1
 * These are used to delete the 
d212 1
a212 1
		perror("send_delete (remote)");
d218 1
a218 1
		perror("send_delete (local)");
@


1.4
log
@

Historically, talk pays no attention to hostnames, so if you've typed
'talk aaa@@b' and are waiting for a response, and user aaa@@c tries to talk
to you, you'll be transparently connected.  Now, talk will print the hostname
of the remote party if it's not the same host that you asked for.
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.3 1996/06/26 05:40:23 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.3 1996/06/26 05:40:23 deraadt Exp $";
d44 2
a45 2
#include <sys/types.h>
#include <sys/socket.h>
a47 1
#include <netinet/in.h>
a48 1
#include <protocols/talkd.h>
d51 1
a52 1
#include "talk.h"
a68 1
void	re_invite();
d71 1
d74 1
a74 1
	int nfd, read_mask, template, new_sockt;
d151 2
a152 1
re_invite()
a153 1

d172 1
a172 1
#define	NANSWERS	(sizeof (answers) / sizeof (answers[0]))
d177 1
d198 1
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: invite.c,v 1.3 1994/12/09 02:14:18 jtc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: invite.c,v 1.3 1994/12/09 02:14:18 jtc Exp $";
d49 1
d56 2
d79 4
d101 4
a104 1
	 * so we can use the interupt timer to resend the invitation
d111 1
a111 1
	while ((new_sockt = accept(sockt, 0, 0)) < 0) {
a122 3
	current_state = "Waiting for your party to respond";
	start_msgs();

d128 19
@


1.2
log
@eliminate annoying blank line when Ringing
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: invite.c,v 1.3 1994/12/09 02:14:18 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@a129 1
	current_line++;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
