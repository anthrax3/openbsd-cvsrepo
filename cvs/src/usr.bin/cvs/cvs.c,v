head	1.159;
access;
symbols
	OPENBSD_6_2:1.159.0.4
	OPENBSD_6_2_BASE:1.159
	OPENBSD_6_1:1.158.0.4
	OPENBSD_6_1_BASE:1.158
	OPENBSD_6_0:1.157.0.4
	OPENBSD_6_0_BASE:1.157
	OPENBSD_5_9:1.157.0.2
	OPENBSD_5_9_BASE:1.157
	OPENBSD_5_8:1.155.0.6
	OPENBSD_5_8_BASE:1.155
	OPENBSD_5_7:1.155.0.2
	OPENBSD_5_7_BASE:1.155
	OPENBSD_5_6:1.153.0.6
	OPENBSD_5_6_BASE:1.153
	OPENBSD_5_5:1.153.0.4
	OPENBSD_5_5_BASE:1.153
	OPENBSD_5_4:1.152.0.8
	OPENBSD_5_4_BASE:1.152
	OPENBSD_5_3:1.152.0.6
	OPENBSD_5_3_BASE:1.152
	OPENBSD_5_2:1.152.0.4
	OPENBSD_5_2_BASE:1.152
	OPENBSD_5_1_BASE:1.152
	OPENBSD_5_1:1.152.0.2
	OPENBSD_5_0:1.151.0.6
	OPENBSD_5_0_BASE:1.151
	OPENBSD_4_9:1.151.0.4
	OPENBSD_4_9_BASE:1.151
	OPENBSD_4_8:1.151.0.2
	OPENBSD_4_8_BASE:1.151
	OPENBSD_4_7:1.150.0.6
	OPENBSD_4_7_BASE:1.150
	OPENBSD_4_6:1.150.0.8
	OPENBSD_4_6_BASE:1.150
	OPENBSD_4_5:1.150.0.4
	OPENBSD_4_5_BASE:1.150
	OPENBSD_4_4:1.150.0.2
	OPENBSD_4_4_BASE:1.150
	OPENBSD_4_3:1.143.0.2
	OPENBSD_4_3_BASE:1.143
	OPENBSD_4_2:1.129.0.2
	OPENBSD_4_2_BASE:1.129
	OPENBSD_4_1:1.118.0.2
	OPENBSD_4_1_BASE:1.118
	OPENBSD_4_0:1.107.0.2
	OPENBSD_4_0_BASE:1.107
	OPENBSD_3_9:1.94.0.2
	OPENBSD_3_9_BASE:1.94
	OPENBSD_3_8:1.84.0.2
	OPENBSD_3_8_BASE:1.84
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.159
date	2017.06.01.08.08.24;	author joris;	state Exp;
branches;
next	1.158;
commitid	oZyV6E3g0wglnhaw;

1.158
date	2016.09.04.16.39.50;	author tb;	state Exp;
branches;
next	1.157;
commitid	SNr0wE0zmWIZqDu9;

1.157
date	2015.11.19.17.44.01;	author deraadt;	state Exp;
branches;
next	1.156;
commitid	cQx46R3KQHjTzMUH;

1.156
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.155;
commitid	O6jeJ0TRmiewrqMI;

1.155
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.154;
commitid	Uu5nFG3wCl0LACBb;

1.154
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.153;
commitid	Z3HC5pAWzpo5jsTe;

1.153
date	2014.01.08.13.23.55;	author okan;	state Exp;
branches;
next	1.152;

1.152
date	2011.09.20.12.43.45;	author nicm;	state Exp;
branches;
next	1.151;

1.151
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.150;

1.150
date	2008.06.21.15.39.15;	author joris;	state Exp;
branches;
next	1.149;

1.149
date	2008.06.17.11.05.39;	author joris;	state Exp;
branches;
next	1.148;

1.148
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.147;

1.147
date	2008.06.10.23.42.04;	author joris;	state Exp;
branches;
next	1.146;

1.146
date	2008.05.30.16.11.32;	author tobias;	state Exp;
branches;
next	1.145;

1.145
date	2008.05.28.17.12.00;	author tobias;	state Exp;
branches;
next	1.144;

1.144
date	2008.03.08.20.52.36;	author tobias;	state Exp;
branches;
next	1.143;

1.143
date	2008.02.26.21.23.00;	author joris;	state Exp;
branches;
next	1.142;

1.142
date	2008.02.02.19.32.28;	author joris;	state Exp;
branches;
next	1.141;

1.141
date	2008.01.28.21.32.00;	author tobias;	state Exp;
branches;
next	1.140;

1.140
date	2008.01.10.10.05.40;	author tobias;	state Exp;
branches;
next	1.139;

1.139
date	2007.10.07.18.14.09;	author chl;	state Exp;
branches;
next	1.138;

1.138
date	2007.09.19.13.49.55;	author tobias;	state Exp;
branches;
next	1.137;

1.137
date	2007.09.19.13.36.32;	author tobias;	state Exp;
branches;
next	1.136;

1.136
date	2007.09.19.12.48.41;	author tobias;	state Exp;
branches;
next	1.135;

1.135
date	2007.09.19.12.26.16;	author tobias;	state Exp;
branches;
next	1.134;

1.134
date	2007.09.19.12.14.21;	author tobias;	state Exp;
branches;
next	1.133;

1.133
date	2007.09.19.11.53.27;	author tobias;	state Exp;
branches;
next	1.132;

1.132
date	2007.09.10.10.29.12;	author tobias;	state Exp;
branches;
next	1.131;

1.131
date	2007.09.07.23.30.30;	author tobias;	state Exp;
branches;
next	1.130;

1.130
date	2007.09.02.12.13.00;	author tobias;	state Exp;
branches;
next	1.129;

1.129
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.128;

1.128
date	2007.05.27.21.14.06;	author ray;	state Exp;
branches;
next	1.127;

1.127
date	2007.05.27.04.12.32;	author ray;	state Exp;
branches;
next	1.126;

1.126
date	2007.05.27.03.35.11;	author ray;	state Exp;
branches;
next	1.125;

1.125
date	2007.05.27.00.46.31;	author ray;	state Exp;
branches;
next	1.124;

1.124
date	2007.05.26.20.45.26;	author ray;	state Exp;
branches;
next	1.123;

1.123
date	2007.05.22.16.47.22;	author xsa;	state Exp;
branches;
next	1.122;

1.122
date	2007.05.09.07.04.57;	author xsa;	state Exp;
branches;
next	1.121;

1.121
date	2007.04.30.08.03.51;	author xsa;	state Exp;
branches;
next	1.120;

1.120
date	2007.04.30.07.00.02;	author xsa;	state Exp;
branches;
next	1.119;

1.119
date	2007.04.24.13.36.30;	author sobrado;	state Exp;
branches;
next	1.118;

1.118
date	2007.02.24.20.52.38;	author otto;	state Exp;
branches;
next	1.117;

1.117
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.116;

1.116
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.115;

1.115
date	2007.02.09.03.30.31;	author joris;	state Exp;
branches;
next	1.114;

1.114
date	2007.02.06.15.24.18;	author jmc;	state Exp;
branches;
next	1.113;

1.113
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.112;

1.112
date	2006.12.11.10.53.00;	author xsa;	state Exp;
branches;
next	1.111;

1.111
date	2006.12.11.07.59.18;	author xsa;	state Exp;
branches;
next	1.110;

1.110
date	2006.11.28.13.31.19;	author xsa;	state Exp;
branches;
next	1.109;

1.109
date	2006.11.14.15.39.41;	author xsa;	state Exp;
branches;
next	1.108;

1.108
date	2006.11.14.15.23.50;	author xsa;	state Exp;
branches;
next	1.107;

1.107
date	2006.07.09.01.57.51;	author joris;	state Exp;
branches;
next	1.106;

1.106
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.105;

1.105
date	2006.06.28.20.19.05;	author reyk;	state Exp;
branches;
next	1.104;

1.104
date	2006.06.13.06.53.45;	author joris;	state Exp;
branches;
next	1.103;

1.103
date	2006.06.12.13.56.00;	author xsa;	state Exp;
branches;
next	1.102;

1.102
date	2006.06.02.19.10.23;	author david;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.30.06.36.09;	author joris;	state Exp;
branches;
next	1.100;

1.100
date	2006.05.27.18.18.06;	author joris;	state Exp;
branches;
next	1.99;

1.99
date	2006.05.27.18.04.46;	author joris;	state Exp;
branches;
next	1.98;

1.98
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.97;

1.97
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.95;

1.95
date	2006.03.15.18.24.50;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2006.01.29.11.17.09;	author xsa;	state Exp;
branches;
next	1.93;

1.93
date	2006.01.26.09.05.31;	author xsa;	state Exp;
branches;
next	1.92;

1.92
date	2006.01.23.14.13.24;	author xsa;	state Exp;
branches;
next	1.91;

1.91
date	2006.01.02.17.06.10;	author xsa;	state Exp;
branches;
next	1.90;

1.90
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.89;

1.89
date	2005.12.19.17.43.01;	author xsa;	state Exp;
branches;
next	1.88;

1.88
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2005.12.03.15.07.20;	author joris;	state Exp;
branches;
next	1.86;

1.86
date	2005.11.12.21.34.48;	author niallo;	state Exp;
branches;
next	1.85;

1.85
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.84;

1.84
date	2005.08.10.14.49.20;	author xsa;	state Exp;
branches;
next	1.83;

1.83
date	2005.08.10.08.05.00;	author xsa;	state Exp;
branches;
next	1.82;

1.82
date	2005.08.10.07.39.48;	author xsa;	state Exp;
branches;
next	1.81;

1.81
date	2005.08.09.08.31.49;	author xsa;	state Exp;
branches;
next	1.80;

1.80
date	2005.08.04.13.31.14;	author xsa;	state Exp;
branches;
next	1.79;

1.79
date	2005.08.03.14.43.08;	author xsa;	state Exp;
branches;
next	1.78;

1.78
date	2005.08.01.19.48.18;	author xsa;	state Exp;
branches;
next	1.77;

1.77
date	2005.07.30.00.10.39;	author xsa;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.28.13.41.38;	author xsa;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.74;

1.74
date	2005.07.24.17.48.05;	author xsa;	state Exp;
branches;
next	1.73;

1.73
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2005.06.16.07.46.42;	author xsa;	state Exp;
branches;
next	1.70;

1.70
date	2005.06.10.13.34.23;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2005.06.01.17.44.34;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.23.18.10.34;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2005.05.20.18.26.49;	author xsa;	state Exp;
branches;
next	1.64;

1.64
date	2005.05.19.15.37.50;	author xsa;	state Exp;
branches;
next	1.63;

1.63
date	2005.05.18.11.53.38;	author xsa;	state Exp;
branches;
next	1.62;

1.62
date	2005.05.17.16.45.07;	author xsa;	state Exp;
branches;
next	1.61;

1.61
date	2005.04.25.19.09.15;	author jfb;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.25.17.59.16;	author jfb;	state Exp;
branches;
next	1.59;

1.59
date	2005.04.22.15.06.28;	author xsa;	state Exp;
branches;
next	1.58;

1.58
date	2005.04.22.03.38.56;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2005.04.21.20.56.12;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2005.04.21.04.37.11;	author jfb;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.20.23.11.30;	author jfb;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.16.19.05.02;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.12.19.35.32;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2005.04.12.15.18.13;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.06.16.35.25;	author jfb;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.31.17.18.24;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.24.01.21.49;	author jfb;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.24.01.03.41;	author joris;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.08.16.13.30;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.06.21.09.00;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.25.20.30.36;	author jfb;	state Exp;
branches;
next	1.39;

1.39
date	2005.02.03.23.00.42;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.24.18.48.23;	author jfb;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.24.17.42.26;	author jfb;	state Exp;
branches;
next	1.36;

1.36
date	2005.01.24.16.12.56;	author jfb;	state Exp;
branches;
next	1.35;

1.35
date	2005.01.14.18.02.04;	author jfb;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.13.23.39.42;	author jfb;	state Exp;
branches;
next	1.33;

1.33
date	2005.01.13.18.47.31;	author jfb;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.13.16.32.46;	author jfb;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.06.20.39.27;	author jfb;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.06.19.56.38;	author jfb;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.22.00.38.25;	author david;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.21.20.59.57;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.21.18.47.58;	author jfb;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.21.18.15.55;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.15.16.28.14;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.15.06.11.40;	author jfb;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.14.19.56.35;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.14.19.11.54;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.13.16.10.30;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.13.13.55.10;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.09.20.03.27;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.07.06.33.10;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.06.21.58.31;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.09.23.06.01;	author krapht;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.09.21.01.36;	author krapht;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.12.17.51.05;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.06.14.49.02;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.06.13.01.09;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.30.23.13.24;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.30.18.58.56;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.30.17.44.48;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.30.01.49.22;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.29.17.48.19;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.26.15.56.42;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.14.19.26.07;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.03.33.09;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.159
log
@Stop looking at current_cvsroot->cr_method to figure out if we're remote or not.

Instead use cvsroot_is_local() and cvsroot_is_remote().
@
text
@/*	$OpenBSD: cvs.c,v 1.158 2016/09/04 16:39:50 tb Exp $	*/
/*
 * Copyright (c) 2006, 2007 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <err.h>

#include "cvs.h"
#include "remote.h"
#include "hash.h"

extern char *__progname;

/* verbosity level: 0 = really quiet, 1 = quiet, 2 = verbose */
int verbosity = 2;

/* compression level used with zlib, 0 meaning no compression taking place */
int	cvs_compress = 0;
int	cvs_readrc = 1;		/* read .cvsrc on startup */
int	cvs_trace = 0;
int	cvs_nolog = 0;
int	cvs_readonly = 0;
int	cvs_readonlyfs = 0;
int	cvs_nocase = 0;	/* set to 1 to disable filename case sensitivity */
int	cvs_noexec = 0;	/* set to 1 to disable disk operations (-n option) */
int	cvs_cmdop;
int	cvs_umask = CVS_UMASK_DEFAULT;
int	cvs_server_active = 0;

char	*cvs_tagname = NULL;
char	*cvs_defargs;		/* default global arguments from .cvsrc */
char	*cvs_rootstr;
char	*cvs_rsh = CVS_RSH_DEFAULT;
char	*cvs_editor = CVS_EDITOR_DEFAULT;
char	*cvs_homedir = NULL;
char	*cvs_tmpdir = CVS_TMPDIR_DEFAULT;

struct cvsroot *current_cvsroot = NULL;
struct cvs_cmd *cmdp;			/* struct of command we are running */

int		cvs_getopt(int, char **);
__dead void	usage(void);
static void	cvs_read_rcfile(void);

struct wklhead temp_files;

void sighandler(int);
volatile sig_atomic_t cvs_quit = 0;
volatile sig_atomic_t sig_received = 0;

extern CVSENTRIES *current_list;

struct hash_table created_directories;
struct hash_table created_cvs_directories;

void
sighandler(int sig)
{
	sig_received = sig;

	switch (sig) {
	case SIGINT:
	case SIGTERM:
	case SIGPIPE:
		cvs_quit = 1;
		break;
	default:
		break;
	}
}

void
cvs_cleanup(void)
{
	cvs_log(LP_TRACE, "cvs_cleanup: removing locks");
	worklist_run(&repo_locks, worklist_unlink);

	cvs_log(LP_TRACE, "cvs_cleanup: removing temp files");
	worklist_run(&temp_files, worklist_unlink);

	if (cvs_server_path != NULL) {
		if (cvs_rmdir(cvs_server_path) == -1)
			cvs_log(LP_ERR,
			    "warning: failed to remove server directory: %s",
			    cvs_server_path);
		free(cvs_server_path);
		cvs_server_path = NULL;
	}

	if (current_list != NULL)
		cvs_ent_close(current_list, ENT_SYNC);
}

__dead void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: %s [-flnQqRrtvw] [-d root] [-e editor] [-s var=val]\n"
	    "           [-T tmpdir] [-z level] command ...\n", __progname);
	exit(1);
}

int
cvs_build_cmd(char ***cmd_argv, char **argv, int argc)
{
	int cmd_argc, i, cur;
	char *cp, *linebuf, *lp;

	if (cmdp->cmd_defargs == NULL) {
		*cmd_argv = argv;
		return argc;
	}

	cur = argc + 2;
	cmd_argc = 0;
	*cmd_argv = xcalloc(cur, sizeof(char *));
	(*cmd_argv)[cmd_argc++] = argv[0];

	linebuf = xstrdup(cmdp->cmd_defargs);
	for (lp = linebuf; lp != NULL;) {
		cp = strsep(&lp, " \t\b\f\n\r\t\v");
		if (cp == NULL)
			break;
		if (*cp == '\0')
			continue;

		if (cmd_argc == cur) {
			cur += 8;
			*cmd_argv = xreallocarray(*cmd_argv, cur,
			    sizeof(char *));
		}

		(*cmd_argv)[cmd_argc++] = cp;
	}

	if (cmd_argc + argc > cur) {
		cur = cmd_argc + argc + 1;
		*cmd_argv = xreallocarray(*cmd_argv, cur,
		    sizeof(char *));
        }

	for (i = 1; i < argc; i++)
		(*cmd_argv)[cmd_argc++] = argv[i];

	(*cmd_argv)[cmd_argc] = NULL;

	return cmd_argc;
}

int
main(int argc, char **argv)
{
	char *envstr, **cmd_argv, **targv;
	int i, ret, cmd_argc;
	struct passwd *pw;
	struct stat st;
	char fpath[PATH_MAX];

	if (pledge("stdio rpath wpath cpath fattr getpw proc exec", NULL) == -1)
		err(1, "pledge");

	tzset();

	TAILQ_INIT(&cvs_variables);
	SLIST_INIT(&repo_locks);
	SLIST_INIT(&temp_files);

	hash_table_init(&created_directories, 100);
	hash_table_init(&created_cvs_directories, 100);

	/* check environment so command-line options override it */
	if ((envstr = getenv("CVS_RSH")) != NULL)
		cvs_rsh = envstr;

	if (((envstr = getenv("CVSEDITOR")) != NULL) ||
	    ((envstr = getenv("VISUAL")) != NULL) ||
	    ((envstr = getenv("EDITOR")) != NULL))
		cvs_editor = envstr;

	if ((envstr = getenv("CVSREAD")) != NULL)
		cvs_readonly = 1;

	if ((envstr = getenv("CVSREADONLYFS")) != NULL) {
		cvs_readonlyfs = 1;
		cvs_nolog = 1;
	}

	if ((cvs_homedir = getenv("HOME")) == NULL) {
		if ((pw = getpwuid(getuid())) != NULL)
			cvs_homedir = pw->pw_dir;
	}

	if ((envstr = getenv("TMPDIR")) != NULL)
		cvs_tmpdir = envstr;

	ret = cvs_getopt(argc, argv);

	argc -= ret;
	argv += ret;
	if (argc == 0)
		usage();

	cmdp = cvs_findcmd(argv[0]);
	if (cmdp == NULL) {
		fprintf(stderr, "Unknown command: `%s'\n\n", argv[0]);
		fprintf(stderr, "CVS commands are:\n");
		for (i = 0; cvs_cdt[i] != NULL; i++)
			fprintf(stderr, "\t%-16s%s\n",
			    cvs_cdt[i]->cmd_name, cvs_cdt[i]->cmd_descr);
		exit(1);
	}

	/*
	 * check the tmp dir, either specified through
	 * the environment variable TMPDIR, or via
	 * the global option -T <dir>
	 */
	if (stat(cvs_tmpdir, &st) == -1)
		fatal("stat failed on `%s': %s", cvs_tmpdir, strerror(errno));
	else if (!S_ISDIR(st.st_mode))
		fatal("`%s' is not valid temporary directory", cvs_tmpdir);

	if (cvs_readrc == 1 && cvs_homedir != NULL) {
		cvs_read_rcfile();

		if (cvs_defargs != NULL) {
			if ((targv = cvs_makeargv(cvs_defargs, &i)) == NULL)
				fatal("failed to load default arguments to %s",
				    __progname);

			cvs_getopt(i, targv);
			cvs_freeargv(targv, i);
			free(targv);
		}
	}

	/* setup signal handlers */
	signal(SIGTERM, sighandler);
	signal(SIGINT, sighandler);
	signal(SIGHUP, sighandler);
	signal(SIGABRT, sighandler);
	signal(SIGALRM, sighandler);
	signal(SIGPIPE, sighandler);

	cvs_cmdop = cmdp->cmd_op;

	cmd_argc = cvs_build_cmd(&cmd_argv, argv, argc);

	cvs_file_init();

	if (cvs_cmdop == CVS_OP_SERVER) {
		cmdp->cmd(cmd_argc, cmd_argv);
		cvs_cleanup();
		return (0);
	}

	cvs_umask = umask(0);
	umask(cvs_umask);

	if ((current_cvsroot = cvsroot_get(".")) == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified! Please use the '-d' option");
		fatal("or set the CVSROOT environment variable.");
	}

	if (cvsroot_is_remote()) {
		cmdp->cmd(cmd_argc, cmd_argv);
		cvs_cleanup();
		return (0);
	}

	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s",
	    current_cvsroot->cr_dir, CVS_PATH_ROOT);

	if (stat(fpath, &st) == -1 && cvs_cmdop != CVS_OP_INIT) {
		if (errno == ENOENT)
			fatal("repository '%s' does not exist",
			    current_cvsroot->cr_dir);
		else
			fatal("%s: %s", current_cvsroot->cr_dir,
			    strerror(errno));
	} else {
		if (!S_ISDIR(st.st_mode))
			fatal("'%s' is not a directory",
			    current_cvsroot->cr_dir);
	}

	if (cvs_cmdop != CVS_OP_INIT) {
		cvs_parse_configfile();
		cvs_parse_modules();
	}

	cmdp->cmd(cmd_argc, cmd_argv);
	cvs_cleanup();

	return (0);
}

int
cvs_getopt(int argc, char **argv)
{
	int ret;
	char *ep;
	const char *errstr;

	while ((ret = getopt(argc, argv, "b:d:e:flnQqRrs:T:tvwxz:")) != -1) {
		switch (ret) {
		case 'b':
			/*
			 * We do not care about the bin directory for RCS files
			 * as this program has no dependencies on RCS programs,
			 * so it is only here for backwards compatibility.
			 */
			cvs_log(LP_NOTICE, "the -b argument is obsolete");
			break;
		case 'd':
			cvs_rootstr = optarg;
			break;
		case 'e':
			cvs_editor = optarg;
			break;
		case 'f':
			cvs_readrc = 0;
			break;
		case 'l':
			cvs_nolog = 1;
			break;
		case 'n':
			cvs_noexec = 1;
			cvs_nolog = 1;
			break;
		case 'Q':
			verbosity = 0;
			break;
		case 'q':
			if (verbosity > 1)
				verbosity = 1;
			break;
		case 'R':
			cvs_readonlyfs = 1;
			cvs_nolog = 1;
			break;
		case 'r':
			cvs_readonly = 1;
			break;
		case 's':
			ep = strchr(optarg, '=');
			if (ep == NULL) {
				cvs_log(LP_ERR, "no = in variable assignment");
				exit(1);
			}
			*(ep++) = '\0';
			if (cvs_var_set(optarg, ep) < 0)
				exit(1);
			break;
		case 'T':
			cvs_tmpdir = optarg;
			break;
		case 't':
			cvs_trace = 1;
			break;
		case 'v':
			printf("%s\n", CVS_VERSION);
			exit(0);
			/* NOTREACHED */
		case 'w':
			cvs_readonly = 0;
			break;
		case 'x':
			/*
			 * Kerberos encryption support, kept for compatibility
			 */
			break;
		case 'z':
			cvs_compress = strtonum(optarg, 0, 9, &errstr);
			if (errstr != NULL)
				fatal("cvs_compress: %s", errstr);
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	ret = optind;
	optind = 1;
	optreset = 1;	/* for next call */

	return (ret);
}

/*
 * cvs_read_rcfile()
 *
 * Read the CVS `.cvsrc' file in the user's home directory.  If the file
 * exists, it should contain a list of arguments that should always be given
 * implicitly to the specified commands.
 */
static void
cvs_read_rcfile(void)
{
	char rcpath[PATH_MAX], *buf, *lbuf, *lp, *p;
	int cmd_parsed, cvs_parsed, i, linenum;
	size_t len, pos;
	struct cvs_cmd *tcmdp;
	FILE *fp;

	linenum = 0;

	i = snprintf(rcpath, PATH_MAX, "%s/%s", cvs_homedir, CVS_PATH_RC);
	if (i < 0 || i >= PATH_MAX) {
		cvs_log(LP_ERRNO, "%s", rcpath);
		return;
	}

	fp = fopen(rcpath, "r");
	if (fp == NULL) {
		if (errno != ENOENT)
			cvs_log(LP_NOTICE, "failed to open `%s': %s", rcpath,
			    strerror(errno));
		return;
	}

	cmd_parsed = cvs_parsed = 0;
	lbuf = NULL;
	while ((buf = fgetln(fp, &len)) != NULL) {
		if (buf[len - 1] == '\n') {
			buf[len - 1] = '\0';
		} else {
			lbuf = xmalloc(len + 1);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		linenum++;

		/* skip any whitespaces */
		p = buf;
		while (*p == ' ')
			p++;

		/*
		 * Allow comments.
		 * GNU cvs stops parsing a line if it encounters a \t
		 * in front of a command, stick at this behaviour for
		 * compatibility.
		 */
		if (*p == '#' || *p == '\t')
			continue;

		pos = strcspn(p, " \t");
		if (pos == strlen(p)) {
			lp = NULL;
		} else {
			lp = p + pos;
			*lp = '\0';
		}

		if (strcmp(p, "cvs") == 0 && !cvs_parsed) {
			/*
			 * Global default options.  In the case of cvs only,
			 * we keep the 'cvs' string as first argument because
			 * getopt() does not like starting at index 0 for
			 * argument processing.
			 */
			if (lp != NULL) {
				*lp = ' ';
				cvs_defargs = xstrdup(p);
			}
			cvs_parsed = 1;
		} else {
			tcmdp = cvs_findcmd(p);
			if (tcmdp == NULL && verbosity == 2)
				cvs_log(LP_NOTICE,
				    "unknown command `%s' in `%s:%d'",
				    p, rcpath, linenum);

			if (tcmdp != cmdp || cmd_parsed)
				continue;

			if (lp != NULL) {
				lp++;
				cmdp->cmd_defargs = xstrdup(lp);
			}
			cmd_parsed = 1;
		}
	}
	free(lbuf);

	if (ferror(fp)) {
		cvs_log(LP_NOTICE, "failed to read line from `%s'", rcpath);
	}

	(void)fclose(fp);
}

/*
 * cvs_var_set()
 *
 * Set the value of the variable <var> to <val>.  If there is no such variable,
 * a new entry is created, otherwise the old value is overwritten.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_var_set(const char *var, const char *val)
{
	const char *cp;
	struct cvs_var *vp;

	if (var == NULL || *var == '\0') {
		cvs_log(LP_ERR, "no variable name");
		return (-1);
	}

	/* sanity check on the name */
	for (cp = var; *cp != '\0'; cp++)
		if (!isalnum((unsigned char)*cp) && (*cp != '_')) {
			cvs_log(LP_ERR,
			    "variable name `%s' contains invalid characters",
			    var);
			return (-1);
		}

	TAILQ_FOREACH(vp, &cvs_variables, cv_link)
		if (strcmp(vp->cv_name, var) == 0)
			break;

	if (vp == NULL) {
		vp = xcalloc(1, sizeof(*vp));

		vp->cv_name = xstrdup(var);
		TAILQ_INSERT_TAIL(&cvs_variables, vp, cv_link);

	} else	/* free the previous value */
		free(vp->cv_val);

	vp->cv_val = xstrdup(val);

	return (0);
}

/*
 * cvs_var_unset()
 *
 * Remove any entry for the variable <var>.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_var_unset(const char *var)
{
	struct cvs_var *vp;

	TAILQ_FOREACH(vp, &cvs_variables, cv_link)
		if (strcmp(vp->cv_name, var) == 0) {
			TAILQ_REMOVE(&cvs_variables, vp, cv_link);
			free(vp->cv_name);
			free(vp->cv_val);
			free(vp);
			return (0);
		}

	return (-1);
}

/*
 * cvs_var_get()
 *
 * Get the value associated with the variable <var>.  Returns a pointer to the
 * value string on success, or NULL if the variable does not exist.
 */

const char *
cvs_var_get(const char *var)
{
	struct cvs_var *vp;

	TAILQ_FOREACH(vp, &cvs_variables, cv_link)
		if (strcmp(vp->cv_name, var) == 0)
			return (vp->cv_val);

	return (NULL);
}
@


1.158
log
@Add missing getpw pledge

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.157 2015/11/19 17:44:01 deraadt Exp $	*/
d297 1
a297 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
@


1.157
log
@opencvs can use pledge "stdio rpath wpath cpath fattr proc exec".
I have not looked into adding stricter pledges later in the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.156 2015/11/05 09:48:21 nicm Exp $	*/
d190 1
a190 1
	if (pledge("stdio rpath wpath cpath fattr proc exec", NULL) == -1)
@


1.156
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.155 2015/01/16 06:40:07 deraadt Exp $	*/
d37 1
d189 3
@


1.155
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.154 2014/12/01 21:58:46 deraadt Exp $	*/
d116 1
a116 1
		xfree(cvs_server_path);
d260 1
a260 1
			xfree(targv);
d516 1
a516 2
	if (lbuf != NULL)
		xfree(lbuf);
d563 1
a563 1
		xfree(vp->cv_val);
d584 3
a586 3
			xfree(vp->cv_name);
			xfree(vp->cv_val);
			xfree(vp);
@


1.154
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.153 2014/01/08 13:23:55 okan Exp $	*/
d187 1
a187 1
	char fpath[MAXPATHLEN];
d429 1
a429 1
	char rcpath[MAXPATHLEN], *buf, *lbuf, *lp, *p;
d437 2
a438 2
	i = snprintf(rcpath, MAXPATHLEN, "%s/%s", cvs_homedir, CVS_PATH_RC);
	if (i < 0 || i >= MAXPATHLEN) {
@


1.153
log
@unsigned char for ctype. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.152 2011/09/20 12:43:45 nicm Exp $	*/
d159 1
a159 1
			*cmd_argv = xrealloc(*cmd_argv, cur,
d168 1
a168 1
		*cmd_argv = xrealloc(*cmd_argv, cur,
@


1.152
log
@Lose unused variable cvs_msg, from Michael W Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.151 2010/07/23 08:31:19 ray Exp $	*/
d546 1
a546 1
		if (!isalnum(*cp) && (*cp != '_')) {
@


1.151
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.150 2008/06/21 15:39:15 joris Exp $	*/
a65 1
char	*cvs_msg = NULL;
@


1.150
log
@add a hash table mechanism based upon hcreate(3) but one that allows
us to maintain multiple hash tables concurrently.

immediatly start using it to keep track of what directories
we have already created and what CVS dirs we already created so
we do not recreate them when we do not need to.

we will be switching more internals to use this soon.
rejoice for cheaper lookups.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.149 2008/06/17 11:05:39 joris Exp $	*/
d76 1
a76 1
struct cvs_wklhead temp_files;
d107 1
a107 1
	cvs_worklist_run(&repo_locks, cvs_worklist_unlink);
d110 1
a110 1
	cvs_worklist_run(&temp_files, cvs_worklist_unlink);
@


1.149
log
@unused vars
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.148 2008/06/14 03:19:15 joris Exp $	*/
d40 1
d84 3
d195 3
@


1.148
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.147 2008/06/10 23:42:04 joris Exp $	*/
a54 1
int	cvs_error = -1;	/* set to the correct error code on failure */
@


1.147
log
@make opencvs behave exactly like GNU cvs does when it comes to
verbosity, it's verbose by default and you can shut it up using -Q.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.146 2008/05/30 16:11:32 tobias Exp $	*/
d82 2
d117 3
@


1.146
log
@Set up cmdp before first possible call of fatal to avoid NULL pointer
dereference in logging code.  Spotted by Igor Zinovik.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.145 2008/05/28 17:12:00 tobias Exp $	*/
d44 1
a44 1
int verbosity = 1;
d121 1
a121 1
	    "usage: %s [-flnQqRrtVvw] [-d root] [-e editor] [-s var=val]\n"
d323 1
a323 1
	while ((ret = getopt(argc, argv, "b:d:e:flnQqRrs:T:tVvwxz:")) != -1) {
d353 2
a354 3
			/*
			 * Be quiet. This is the default in OpenCVS.
			 */
a377 5
			break;
		case 'V':
			/* don't override -Q */
			if (verbosity)
				verbosity = 2;
@


1.145
log
@Don't limit ourselfs when it comes to arguments on command line or
arguments sent by client.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.144 2008/03/08 20:52:36 tobias Exp $	*/
d220 10
a238 10

	cmdp = cvs_findcmd(argv[0]);
	if (cmdp == NULL) {
		fprintf(stderr, "Unknown command: `%s'\n\n", argv[0]);
		fprintf(stderr, "CVS commands are:\n");
		for (i = 0; cvs_cdt[i] != NULL; i++)
			fprintf(stderr, "\t%-16s%s\n",
			    cvs_cdt[i]->cmd_name, cvs_cdt[i]->cmd_descr);
		exit(1);
	}
@


1.144
log
@Set umask (and cvs_umask) to system's umask in local and client mode.
Also zap umask(0);umask(mask); calls, we have cvs_umask for this.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.143 2008/02/26 21:23:00 joris Exp $	*/
d127 47
d176 1
a176 1
	char *envstr, *cmd_argv[CVS_CMD_MAXARG], **targv;
d264 1
a264 18
	cmd_argc = 0;
	memset(cmd_argv, 0, sizeof(cmd_argv));

	cmd_argv[cmd_argc++] = argv[0];
	if (cmdp->cmd_defargs != NULL) {
		/* transform into a new argument vector */
		ret = cvs_getargv(cmdp->cmd_defargs, cmd_argv + 1,
		    CVS_CMD_MAXARG - 1);
		if (ret < 0)
			fatal("main: cvs_getargv failed");

		cmd_argc += ret;
	}

	if (argc + cmd_argc >= CVS_CMD_MAXARG)
		fatal("main: too many arguments for `%s'", cmd_argv[0]);
	for (ret = 1; ret < argc; ret++)
		cmd_argv[cmd_argc++] = argv[ret];
@


1.143
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.142 2008/02/02 19:32:28 joris Exp $	*/
d244 3
a278 2

	umask(cvs_umask);
@


1.142
log
@initial CVSROOT/modules support, only does aliases at the moment (-a).
"modules.c, hurray!" xsa@@, ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.141 2008/01/28 21:32:00 tobias Exp $	*/
a160 1

@


1.141
log
@Zapped some variables which made the source harder to read (and to verify).

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.140 2008/01/10 10:05:40 tobias Exp $	*/
d273 1
a273 1
	if (cvs_cmdop != CVS_OP_INIT)
d275 2
@


1.140
log
@Simply the use of cmdp and cvs_command by zapping cvs_command and working
solely with cmdp.  This remedies some reliability issues with invalid
commands supplied and also fixes a GNU cvs style incompatibility with
release command.

> Based on patch from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.139 2007/10/07 18:14:09 chl Exp $	*/
a499 1
	char *valcp;
a520 1
	valcp = xstrdup(val);
d530 1
a530 1
	vp->cv_val = valcp;
@


1.139
log
@break after exit() is useless

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.138 2007/09/19 13:49:55 tobias Exp $	*/
a61 1
char	*cvs_command;		/* name of the command we are running */
d70 1
a130 1
	struct cvs_cmd *cmdp;
a173 2
	cvs_command = argv[0];

d184 1
a184 1
	cmdp = cvs_findcmd(cvs_command);
d186 1
a186 1
		fprintf(stderr, "Unknown command: `%s'\n\n", cvs_command);
d396 1
a396 1
	struct cvs_cmd *cmdp, *tcmdp;
a413 4

	cmdp = cvs_findcmd(cvs_command);
	if (cmdp == NULL)
		fatal("unknown command `%s'", cvs_command);
@


1.138
log
@Allow lines which do not specify any arguments for command (or cvs).
Sticks at GNU cvs behaviour.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.137 2007/09/19 13:36:32 tobias Exp $	*/
a359 1
			break;
@


1.137
log
@parse global arguments (cvs) and command arguments only once, i.e. first
line of occurence. Nice side-effect: only parse arguments for current
command, not for all.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.136 2007/09/19 12:48:41 tobias Exp $	*/
d453 1
a453 2
			/* ignore lines with no arguments */
			continue;
d466 4
a469 2
			*lp = ' ';
			cvs_defargs = xstrdup(p);
a471 1
			lp++;
d481 4
a484 1
			cmdp->cmd_defargs = xstrdup(lp);
@


1.136
log
@Print warning about invalid command in .cvsrc only if -V is in use.
OpenCVS defaults to -q, so man page should say "with -V", not "without -q
or -Q".

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.135 2007/09/19 12:26:16 tobias Exp $	*/
d398 1
a398 1
	int i, linenum;
d400 1
a400 1
	struct cvs_cmd *cmdp;
d419 5
d460 1
a460 1
		if (strcmp(p, "cvs") == 0) {
d469 1
d472 7
a478 6
			cmdp = cvs_findcmd(p);
			if (cmdp == NULL) {
				if (verbosity == 2)
					cvs_log(LP_NOTICE,
					    "unknown command `%s' in `%s:%d'",
					    p, rcpath, linenum);
a479 1
			}
d482 1
@


1.135
log
@Next to ' ', '\t' is valid between command and arguments.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.134 2007/09/19 12:14:21 tobias Exp $	*/
d468 4
a471 3
				cvs_log(LP_NOTICE,
				    "unknown command `%s' in `%s:%d'",
				    p, rcpath, linenum);
@


1.134
log
@Weird, but our goal is compatibility: treat '\t' in front of keyword as '#'.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.133 2007/09/19 11:53:27 tobias Exp $	*/
d399 1
a399 1
	size_t len;
d446 9
a454 4
		lp = strchr(p, ' ');
		if (lp == NULL)
			continue;	/* ignore lines with no arguments */
		*lp = '\0';
@


1.133
log
@Usage of fgetln() instead of fgets() in .cvsrc parsing handles line
numbers better and allows longer command arguments.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.132 2007/09/10 10:29:12 tobias Exp $	*/
d437 7
a443 2
		/* allow comments */
		if (*p == '#')
@


1.132
log
@Fixed segmentation fault that occured during .cvsrc parsing if an invalid
cvs command has been specified.

Spotted by Mathias De Belder <mathias at woei dot be> who also supplied a
patch, although I took his second suggestion.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.131 2007/09/07 23:30:30 tobias Exp $	*/
d397 1
a397 1
	char rcpath[MAXPATHLEN], linebuf[128], *lp, *p;
d419 11
a429 1
	while (fgets(linebuf, (int)sizeof(linebuf), fp) != NULL) {
a430 8
		if ((len = strlen(linebuf)) == 0)
			continue;
		if (linebuf[len - 1] != '\n') {
			cvs_log(LP_ERR, "line too long in `%s:%d'", rcpath,
				linenum);
			break;
		}
		linebuf[--len] = '\0';
d433 1
a433 1
		p = linebuf;
d467 2
@


1.131
log
@Do not fatal if getpwuid() fails, instead ignore user configuration files.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.130 2007/09/02 12:13:00 tobias Exp $	*/
d187 10
a217 10

	cmdp = cvs_findcmd(cvs_command);
	if (cmdp == NULL) {
		fprintf(stderr, "Unknown command: `%s'\n\n", cvs_command);
		fprintf(stderr, "CVS commands are:\n");
		for (i = 0; cvs_cdt[i] != NULL; i++)
			fprintf(stderr, "\t%-16s%s\n",
			    cvs_cdt[i]->cmd_name, cvs_cdt[i]->cmd_descr);
		exit(1);
	}
@


1.130
log
@Stick at GNU cvs behaviour with Root directive handling: it does not need
to be sent first, can occure multiple times (although this is ignored) but
should be supplied before Directory.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.129 2007/08/06 19:16:06 sobrado Exp $	*/
d160 3
a162 3
		if ((pw = getpwuid(getuid())) == NULL)
			fatal("getpwuid failed");
		cvs_homedir = pw->pw_dir;
d187 1
a187 1
	if (cvs_readrc == 1) {
@


1.129
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.128 2007/05/27 21:14:06 ray Exp $	*/
a134 1
	char *root, *rootp;
d243 3
a245 12
		if (cmd_argc > 1)
			fatal("server does not take any extra arguments");

		setvbuf(stdin, NULL, _IOLBF, 0);
		setvbuf(stdout, NULL, _IOLBF, 0);

		cvs_server_active = 1;
		root = cvs_remote_input();
		if ((rootp = strchr(root, ' ')) == NULL)
			fatal("bad Root request");
		cvs_rootstr = xstrdup(rootp + 1);
		xfree(root);
@


1.128
log
@Add bounds check for cvs command arguments.  Initial diff by Tobias
Stoeckmann, rearranged to "if (num_items >= BUFSIZ)" format for
readability.

I would have liked to allow our cvs client to accept as many arguments
as the system would allow, but the argument parsing code is surprising
hairy.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.127 2007/05/27 04:12:32 ray Exp $	*/
d122 1
a122 1
	    "           [-T tmpdir] [-z level] command [...]\n", __progname);
@


1.127
log
@Revert, we dealt with the -x flag in the past.  jmc suddenly
remembered we had created a separate section for compatibility
flags.  Oh well, two free commits.

OK jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.125 2007/05/27 00:46:31 ray Exp $	*/
d236 2
@


1.126
log
@Mention -x flag (for compatibility only).  From Tobias Stoeckmann.

Input and OK jmc@@
@
text
@d121 1
a121 1
	    "usage: %s [-flnQqRrtVvwx] [-d root] [-e editor] [-s var=val]\n"
@


1.125
log
@Call fatal() if extra arguments are given to "opencvs server".  From
Tobias Stoeckmann.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.124 2007/05/26 20:45:26 ray Exp $	*/
d121 1
a121 1
	    "usage: %s [-flnQqRrtVvw] [-d root] [-e editor] [-s var=val]\n"
@


1.124
log
@cvs_server_path is more appropriate to check than cvs_server_active.

From Tobias Stoeckmann.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.123 2007/05/22 16:47:22 xsa Exp $	*/
d242 3
@


1.123
log
@Note that the global -x option is kept for compatibility (for now) and has
no effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.122 2007/05/09 07:04:57 xsa Exp $	*/
d107 1
a107 1
	if (cvs_server_active) {
d113 1
@


1.122
log
@- we do not have -H, zap it.
- add missing `x' flag in getopt() and sort flags.
- sync usage().

Based on initial diff from Tobias Stoeckmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.121 2007/04/30 08:03:51 xsa Exp $	*/
d120 1
a120 1
	    "usage: %s [-flnQqRrtVvwx] [-d root] [-e editor] [-s var=val]\n"
@


1.121
log
@make usage() __dead; from Tobias Stoeckmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.120 2007/04/30 07:00:02 xsa Exp $	*/
d120 1
a120 1
	    "usage: %s [-flnQqRrtVvw] [-d root] [-e editor] [-s var=val]\n"
d298 1
a298 1
	while ((ret = getopt(argc, argv, "b:d:e:fHlnQqRrs:T:tvVwz:")) != -1) {
@


1.120
log
@missing header; from Tobias Stoeckmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.119 2007/04/24 13:36:30 sobrado Exp $	*/
d73 1
a73 1
void		usage(void);
d116 1
a116 1
void
d119 1
a119 1
	fprintf(stderr,
d122 1
d172 1
a172 1
	if (argc == 0) {
a173 2
		exit(1);
	}
d380 1
a380 1
			exit(1);
@


1.119
log
@changes "Usage" to "usage"; sorts options list in cvs history;
the argument to -z is tz, not timezone; argument names to flags
should use lowercase letters; cvs's usage() output should fit
on a 80-column display

ok by jmc@@, niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.118 2007/02/24 20:52:38 otto Exp $	*/
d35 1
@


1.118
log
@fix comment; from jared r r spiegel
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.117 2007/02/22 06:42:09 otto Exp $	*/
d119 2
a120 2
	    "Usage: %s [-flnQqRrtVvw] [-d root] [-e editor] [-s var=val] "
	    "[-T tmpdir] [-z level] command [...]\n", __progname);
@


1.117
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.116 2007/02/17 18:23:43 xsa Exp $	*/
d525 1
a525 1
 * cvs_var_set()
@


1.116
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.115 2007/02/09 03:30:31 joris Exp $	*/
d28 8
a35 1
#include "includes.h"
a37 3
#include "config.h"
#include "log.h"
#include "file.h"
@


1.115
log
@strtol(3) -> strtonum(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.114 2007/02/06 15:24:18 jmc Exp $	*/
d260 2
a261 3
	if (cvs_path_cat(current_cvsroot->cr_dir, CVS_PATH_ROOT,
	    fpath, sizeof(fpath)) >= sizeof(fpath))
		fatal("main: truncation");
d398 1
a398 1
	int linenum = 0;
d403 4
a406 2
	if (cvs_path_cat(cvs_homedir, CVS_PATH_RC, rcpath, sizeof(rcpath))
	    >= sizeof(rcpath)) {
@


1.114
log
@sort options;
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.113 2007/01/11 02:35:55 joris Exp $	*/
d293 1
d371 3
a373 6
			cvs_compress = (int)strtol(optarg, &ep, 10);
			if (*ep != '\0')
				fatal("error parsing compression level");
			if (cvs_compress < 0 || cvs_compress > 9)
				fatal("gzip compression level must be "
				    "between 0 and 9");
@


1.113
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.112 2006/12/11 10:53:00 xsa Exp $	*/
d115 1
a115 1
	    "Usage: %s [-flnQqRrtvVw] [-d root] [-e editor] [-s var=val] "
@


1.112
log
@global option -n implies -l
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.111 2006/12/11 07:59:18 xsa Exp $	*/
d3 1
a3 1
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
a254 4
		if (cvs_server_active == 1)
			fatal("remote Root while already running as server?");

		cvs_client_connect_to_server();
@


1.111
log
@Permit checkout from a read-only repository using the -R global option
or using the CVSREADONLYFS environment variable.
Request/test/ok todd@@. Man page bits courtesy of jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.110 2006/11/28 13:31:19 xsa Exp $	*/
d322 1
@


1.110
log
@snprintf() -> cvs_path_cat()
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.109 2006/11/14 15:39:41 xsa Exp $	*/
d47 1
d115 1
a115 1
	    "Usage: %s [-flnQqrtvVw] [-d root] [-e editor] [-s var=val] "
d148 5
d298 1
a298 1
	while ((ret = getopt(argc, argv, "b:d:e:fHlnQqrs:T:tvVwz:")) != -1) {
d330 4
@


1.109
log
@Add support for the "Set" request.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.108 2006/11/14 15:23:50 xsa Exp $	*/
d258 4
a261 2
	i = snprintf(fpath, sizeof(fpath), "%s/%s", current_cvsroot->cr_dir,
	    CVS_PATH_ROOT);
@


1.108
log
@Simplify in cvs_read_rcfile() by using cvs_path_cat();
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.107 2006/07/09 01:57:51 joris Exp $	*/
a64 2

static TAILQ_HEAD(, cvs_var) cvs_variables;
@


1.107
log
@handle SIGPIPE correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.106 2006/07/07 17:37:17 joris Exp $	*/
d399 3
a401 5
	if (strlcpy(rcpath, cvs_homedir, sizeof(rcpath)) >= sizeof(rcpath) ||
	    strlcat(rcpath, "/", sizeof(rcpath)) >= sizeof(rcpath) ||
	    strlcat(rcpath, CVS_PATH_RC, sizeof(rcpath)) >= sizeof(rcpath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERR, "%s", rcpath);
@


1.106
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.105 2006/06/28 20:19:05 reyk Exp $	*/
d86 1
@


1.105
log
@use quiet mode (-q) by default and add a flag -V for the old "verbose"
mode.  if you really need to know all the details (the old GNU'ish
behaviour), use -V or even -t for tracing.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.104 2006/06/13 06:53:45 joris Exp $	*/
d34 1
d52 1
d101 8
d128 1
d231 12
d249 9
a257 2
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL)
		fatal("remote setups are not supported yet");
@


1.104
log
@be more accurate in describing what happened
when we cannot see the repository the user wants to work with.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.103 2006/06/12 13:56:00 xsa Exp $	*/
d38 1
a38 1
int verbosity = 2;
d105 1
a105 1
	    "Usage: %s [-flnQqrtvw] [-d root] [-e editor] [-s var=val] "
d261 1
a261 1
	while ((ret = getopt(argc, argv, "b:d:e:fHlnQqrs:T:tvwz:")) != -1) {
d290 3
a292 3
			/* don't override -Q */
			if (verbosity > 1)
				verbosity = 1;
d312 5
@


1.103
log
@bring back a working version of the `cvs init' command. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.102 2006/06/02 19:10:23 david Exp $	*/
d233 1
a233 1
			fatal("'%s' does not seem to be a valid repository",
@


1.102
log
@various spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.101 2006/05/30 06:36:09 joris Exp $	*/
d231 1
a231 1
	if (stat(fpath, &st) == -1) {
d244 2
a245 1
	cvs_parse_configfile();
@


1.101
log
@nuke cvs_repo_base variable
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.100 2006/05/27 18:18:06 joris Exp $	*/
d223 1
a223 1
		fatal("or set the CVSROOT enviroment variable.");
@


1.100
log
@lets be nice and abort cvs when we find out there is
no CVSROOT directory where there is suppose to be one.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.99 2006/05/27 18:04:46 joris Exp $	*/
a59 1
char	*cvs_repo_base = NULL;
@


1.99
log
@basic support for CVSROOT/config - only supporting the 'tag' and
'umask' keyword right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.98 2006/05/27 03:30:30 joris Exp $	*/
d118 1
d229 15
@


1.98
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.97 2006/04/14 02:45:35 deraadt Exp $	*/
d31 1
d50 1
d52 1
d228 4
@


1.97
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.96 2006/04/05 01:38:55 ray Exp $	*/
d3 1
a33 1

a35 1

d40 19
a58 18
int   cvs_compress = 0;
int   cvs_readrc = 1;		/* read .cvsrc on startup */
int   cvs_trace = 0;
int   cvs_nolog = 0;
int   cvs_readonly = 0;
int   cvs_nocase = 0;   /* set to 1 to disable filename case sensitivity */
int   cvs_noexec = 0;	/* set to 1 to disable disk operations (-n option) */
int   cvs_error = -1;	/* set to the correct error code on failure */
char *cvs_defargs;		/* default global arguments from .cvsrc */
char *cvs_command;		/* name of the command we are running */
int   cvs_cmdop;
char *cvs_rootstr;
char *cvs_rsh = CVS_RSH_DEFAULT;
char *cvs_editor = CVS_EDITOR_DEFAULT;
char *cvs_homedir = NULL;
char *cvs_msg = NULL;
char *cvs_repo_base = NULL;
char *cvs_tmpdir = CVS_TMPDIR_DEFAULT;
d60 1
a60 2
/* hierarchy of all the files affected by the command */
CVSFILE *cvs_files;
d64 1
a64 1

a66 1
int		cvs_getopt(int, char **);
d68 31
a98 5
/*
 * usage()
 *
 * Display usage information.
 */
a106 1

d119 2
a120 9

	cvs_log_init(LD_STD, 0);

	/* by default, be very verbose */
	(void)cvs_log_filter(LP_FILTER_UNSET, LP_INFO);

#ifdef DEBUG
	(void)cvs_log_filter(LP_FILTER_UNSET, LP_DEBUG);
#endif
d149 1
a149 1
		exit(CVS_EX_USAGE);
d179 6
a184 6
	signal(SIGPIPE, SIG_IGN);

	if (cvs_file_init() < 0)
		fatal("failed to initialize file support");

	ret = -1;
d193 1
a193 1
		exit(CVS_EX_USAGE);
d211 1
d215 3
a217 17
	ret = cvs_startcmd(cmdp, cmd_argc, cmd_argv);
	switch (ret) {
	case CVS_EX_USAGE:
		fprintf(stderr, "Usage: %s %s %s\n", __progname,
		    cmdp->cmd_name, cmdp->cmd_synopsis);
		break;
	case CVS_EX_DATA:
		cvs_log(LP_ABORT, "internal data error");
		break;
	case CVS_EX_PROTO:
		cvs_log(LP_ABORT, "protocol error");
		break;
	case CVS_EX_FILE:
		cvs_log(LP_ABORT, "an operation on a file or directory failed");
		break;
	case CVS_EX_BADROOT:
		/* match GNU CVS output, thus the LP_ERR and LP_ABORT codes. */
d219 2
a220 9
		    "No CVSROOT specified! Please use the `-d' option");
		cvs_log(LP_ABORT,
		    "or set the CVSROOT enviroment variable.");
		break;
	case CVS_EX_ERR:
		cvs_log(LP_ABORT, "yeah, we failed, and we don't know why");
		break;
	default:
		break;
d223 5
a227 4
	if (cvs_files != NULL)
		cvs_file_free(cvs_files);
	if (cvs_msg != NULL)
		xfree(cvs_msg);
d229 1
a229 1
	return (ret);
a231 1

d278 1
a278 1
				exit(CVS_EX_USAGE);
d282 1
a282 1
				exit(CVS_EX_USAGE);
a287 1
			(void)cvs_log_filter(LP_FILTER_UNSET, LP_TRACE);
d313 1
a313 1
			exit(CVS_EX_USAGE);
a323 1

d344 1
a344 1
		cvs_log(LP_ERRNO, "%s", rcpath);
d361 1
a361 1
			cvs_log(LP_WARN, "line too long in `%s:%d'", rcpath,
d402 1
a409 1

a456 1

a477 1

a478 1

@


1.96
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.95 2006/03/15 18:24:50 deraadt Exp $	*/
d430 1
a430 1
	if ((var == NULL) || (*var == '\0')) {
@


1.95
log
@bogus idiom
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.94 2006/01/29 11:17:09 xsa Exp $	*/
d450 1
a450 2
		vp = (struct cvs_var *)xmalloc(sizeof(*vp));
		memset(vp, 0, sizeof(*vp));
@


1.94
log
@spread some fatal() here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.93 2006/01/26 09:05:31 xsa Exp $	*/
d376 1
a376 1
			*p++;
@


1.93
log
@strings cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.92 2006/01/23 14:13:24 xsa Exp $	*/
d143 4
a146 8
	if (stat(cvs_tmpdir, &st) == -1) {
		cvs_log(LP_ERR, "failed to stat `%s'", cvs_tmpdir);
		exit(CVS_EX_FILE);
	} else if (!S_ISDIR(st.st_mode)) {
		cvs_log(LP_ERR, "`%s' is not valid temporary directory",
		    cvs_tmpdir);
		exit(CVS_EX_FILE);
	}
d152 2
a153 4
			targv = cvs_makeargv(cvs_defargs, &i);
			if (targv == NULL) {
				cvs_log(LP_ERR,
				    "failed to load default arguments to %s",
a154 2
				exit(CVS_EX_DATA);
			}
d165 2
a166 4
	if (cvs_file_init() < 0) {
		cvs_log(LP_ERR, "failed to initialize file support");
		exit(CVS_EX_FILE);
	}
d190 3
a192 5
		if (ret < 0) {
			cvs_log(LP_ERRNO, "failed to generate argument vector "
			    "from default arguments");
			exit(CVS_EX_DATA);
		}
@


1.92
log
@print complete command name in usage, not aliases.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.91 2006/01/02 17:06:10 xsa Exp $	*/
d353 1
a353 1
	int l, linenum = 0;
d358 3
a360 2
	l = snprintf(rcpath, sizeof(rcpath), "%s/%s", cvs_homedir, CVS_PATH_RC);
	if (l == -1 || l >= (int)sizeof(rcpath)) {
@


1.91
log
@- nuke remaining err(), errx() and warnx() instances.
- make cvs_log_init() return type void.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.90 2006/01/02 08:11:56 xsa Exp $	*/
d213 2
a214 2
		fprintf(stderr, "Usage: %s %s %s\n", __progname, cvs_command,
		    cmdp->cmd_synopsis);
@


1.90
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.89 2005/12/19 17:43:01 xsa Exp $	*/
d97 1
a97 2
	if (cvs_log_init(LD_STD, 0) < 0)
		err(1, "failed to initialize logging");
d323 1
a323 1
				errx(1, "error parsing compression level");
d325 1
a325 1
				errx(1, "gzip compression level must be "
@


1.89
log
@use fatal() if getpwuid() fails; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.88 2005/12/10 20:27:45 joris Exp $	*/
d27 1
a27 13
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.88
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.87 2005/12/03 15:07:20 joris Exp $	*/
d132 2
a133 6
		pw = getpwuid(getuid());
		if (pw == NULL) {
			cvs_log(LP_NOTICE,
				"failed to get user's password entry");
			exit(CVS_EX_DATA);
		}
@


1.87
log
@fix date handling in opencvs, this was broken since the very start.
now, when you checkout a tree with gnu cvs, opencvs no longer sees all
the files as modified, and visa versa.

this actually makes gnu cvs and opencvs dance together in working copies.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.86 2005/11/12 21:34:48 niallo Exp $	*/
d183 1
a183 1
			free(targv);
d259 1
a259 1
		free(cvs_msg);
d422 1
a422 4
			cvs_defargs = strdup(p);
			if (cvs_defargs == NULL)
				cvs_log(LP_ERRNO,
				    "failed to copy global arguments");
d433 1
a433 5
			cmdp->cmd_defargs = strdup(lp);
			if (cmdp->cmd_defargs == NULL)
				cvs_log(LP_ERRNO,
				    "failed to copy default arguments for %s",
				    cmdp->cmd_name);
d476 1
a476 6
	valcp = strdup(val);
	if (valcp == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate variable");
		return (-1);
	}

d478 1
a478 6
		vp = (struct cvs_var *)malloc(sizeof(*vp));
		if (vp == NULL) {
			cvs_log(LP_ERRNO, "failed to allocate variable");
			free(valcp);
			return (-1);
		}
d481 1
a481 8
		vp->cv_name = strdup(var);
		if (vp->cv_name == NULL) {
			cvs_log(LP_ERRNO, "failed to allocate variable");
			free(valcp);
			free(vp);
			return (-1);
		}

d485 1
a485 1
		free(vp->cv_val);
d507 3
a509 3
			free(vp->cv_name);
			free(vp->cv_val);
			free(vp);
@


1.86
log
@- remove strtab stuff. serves no useful purpose.

diff is from joris@@, committing on his behalf because his net connection
is very dodgy right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.85 2005/10/07 21:47:32 reyk Exp $	*/
d104 2
@


1.85
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.84 2005/08/10 14:49:20 xsa Exp $	*/
a43 1
#include "strtab.h"
a116 2
	cvs_strtab_init();

a257 2

	cvs_strtab_cleanup();
@


1.84
log
@fgets() expects the 2nd arg to be an int. OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.83 2005/08/10 08:05:00 xsa Exp $	*/
d140 1
a140 1
        }
@


1.83
log
@add global -w option and document it; ok jmc joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.82 2005/08/10 07:39:48 xsa Exp $	*/
d393 1
a393 1
	while (fgets(linebuf, sizeof(linebuf), fp) != NULL) {
@


1.82
log
@use correct return codes when we exit(); ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.81 2005/08/09 08:31:49 xsa Exp $	*/
d92 1
a92 1
	    "Usage: %s [-flnQqrtv] [-d root] [-e editor] [-s var=val] "
d274 1
a274 1
	while ((ret = getopt(argc, argv, "b:d:e:fHlnQqrs:T:tvz:")) != -1) {
d331 3
@


1.81
log
@add missing [-T tmpdir] in usage(), spotted by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.80 2005/08/04 13:31:14 xsa Exp $	*/
d137 1
a137 1
			exit(1);
d151 1
a151 1
		exit(1);
d163 1
a163 1
		exit(1);
d167 1
a167 1
		exit(1);
d179 1
a179 1
				exit(1);
d193 1
a193 1
		exit(1);
d221 1
a221 1
			exit(1);
d314 1
a314 1
				exit(1);
d318 1
a318 1
				exit(1);
d347 1
a347 1
			exit(1);
@


1.80
log
@handle TMPDIR environment variable as well as -T <tmpdir> global option;
Ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.79 2005/08/03 14:43:08 xsa Exp $	*/
d92 2
a93 2
	    "Usage: %s [-flnQqrtv] [-d root] [-e editor] "
	    "[-s var=val] [-z level] command [...]\n", __progname);
@


1.79
log
@check only once for the HOME environment variable and reuse
its value (if any) to check for the .cvsrc and .cvsignore files;
ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.78 2005/08/01 19:48:18 xsa Exp $	*/
d27 1
d71 1
d104 1
d142 3
d153 1
d156 14
d274 1
a274 1
	while ((ret = getopt(argc, argv, "b:d:e:fHlnQqrs:tvz:")) != -1) {
d319 3
@


1.78
log
@respect $HOME when checking for .cvsrc; ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.77 2005/07/30 00:10:39 xsa Exp $	*/
d67 2
a69 1
char *cvs_msg = NULL;
d101 1
d129 10
d345 1
a345 1
	char rcpath[MAXPATHLEN], linebuf[128], *envstr, *home, *lp, *p;
a348 1
	struct passwd *pw;
d351 1
a351 12
	pw = getpwuid(getuid());
	if (pw == NULL) {
		cvs_log(LP_NOTICE, "failed to get user's password entry");
		return;
	}

	if ((envstr = getenv("HOME")) != NULL)
		home = envstr;
	else
		home = pw->pw_dir;

	l = snprintf(rcpath, sizeof(rcpath), "%s/%s", home, CVS_PATH_RC);
@


1.77
log
@add missing -r in usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.76 2005/07/28 13:41:38 xsa Exp $	*/
d333 1
a333 1
	char rcpath[MAXPATHLEN], linebuf[128], *lp, *p;
d346 6
a351 1
	l = snprintf(rcpath, sizeof(rcpath), "%s/%s", pw->pw_dir, CVS_PATH_RC);
@


1.76
log
@respect CVSREAD env. variable; ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.75 2005/07/25 12:05:43 xsa Exp $	*/
d89 2
a90 2
	    "Usage: %s [-flnQqtv] [-d root] [-e editor] [-s var=val] [-z level] "
	    "command [...]\n", __progname);
@


1.75
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.74 2005/07/24 17:48:05 xsa Exp $	*/
d123 3
@


1.74
log
@some more `if (!var)' cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.73 2005/07/23 11:19:46 joris Exp $	*/
d76 3
a78 3
void         usage           (void);
static void  cvs_read_rcfile (void);
int          cvs_getopt(int, char **);
d517 1
a517 1
const char*
@


1.73
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.72 2005/07/07 14:27:57 joris Exp $	*/
d134 1
a134 1
	if (cvs_readrc) {
@


1.72
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.71 2005/06/16 07:46:42 xsa Exp $	*/
d60 1
a60 1

a72 1

d213 3
@


1.71
log
@match gnu/usr.bin/cvs error msg output on bad CVSROOT error; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.70 2005/06/10 13:34:23 joris Exp $	*/
d79 1
a79 2
int          cvs_getopt      (int, char **); 

@


1.70
log
@

allow comments in the cvsrc file.
reported by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.69 2005/06/01 17:44:34 joris Exp $	*/
d210 2
a211 1
		cvs_log(LP_ABORT,
@


1.69
log
@

missed these in previous commits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.68 2005/05/31 08:58:47 xsa Exp $	*/
d328 1
a328 1
	char rcpath[MAXPATHLEN], linebuf[128], *lp;
d367 10
a376 1
		lp = strchr(linebuf, ' ');
d380 1
a380 1
		if (strcmp(linebuf, "cvs") == 0) {
d388 1
a388 1
			cvs_defargs = strdup(linebuf);
d394 1
a394 1
			cmdp = cvs_findcmd(linebuf);
d398 1
a398 1
				    linebuf, rcpath, linenum);
@


1.68
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.67 2005/05/24 04:12:25 jfb Exp $	*/
d67 1
a67 1

@


1.67
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.66 2005/05/23 18:10:34 joris Exp $	*/
d30 1
d32 1
d34 1
a34 1
#include <errno.h>
a35 1
#include <ctype.h>
d37 1
a38 2
#include <signal.h>
#include <string.h>
@


1.66
log
@

add -n flag to cvs usage

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.65 2005/05/20 18:26:49 xsa Exp $	*/
a75 225
/*
 * Command dispatch table
 * ----------------------
 *
 * The synopsis field should only contain the list of arguments that the
 * command supports, without the actual command's name.
 *
 * Command handlers are expected to return 0 if no error occurred, or one of
 * the CVS_EX_* error codes in case of an error.  In case the error
 * returned is 1, the command's usage string is printed to standard
 * error before returning.
 */
struct cvs_cmd cvs_cdt[] = {
	{
		CVS_OP_ADD, "add",      { "ad",  "new" }, &cvs_add, 
		"[-k mode] [-m msg] file ...",
		"k:m:",
		"Add a new file/directory to the repository",
		NULL
	},
	{
		CVS_OP_ADMIN, "admin",    { "adm", "rcs" }, &cvs_admin,
		"",
		"a:A:b::c:e::Ik:l::Lm:n:N:o:qs:t:u::U",
		"Administration front end for rcs",
		NULL
	},
	{
		CVS_OP_ANNOTATE, "annotate", { "ann"        }, &cvs_annotate,
		"[-flR] [-D date | -r rev] ...",
		"D:flRr:",
		"Show last revision where each line was modified",
		NULL
	},
	{
		CVS_OP_CHECKOUT, "checkout", { "co",  "get" }, &cvs_checkout,
		"[-AcflNnPpRs] [-D date | -r rev] [-d dir] [-j rev] [-k mode] "
		"[-t id] module ...",
		"AcD:d:fj:k:lNnPpRr:st:",
		"Checkout sources for editing",
		NULL
	},
	{
		CVS_OP_COMMIT, "commit",   { "ci",  "com" }, &cvs_commit,
		"[-flR] [-F logfile | -m msg] [-r rev] ...",
		"F:flm:Rr:",
		"Check files into the repository",
		NULL
	},
	{
		CVS_OP_DIFF, "diff",     { "di",  "dif" }, &cvs_diff,
		"[-cilNnpRu] [-D date] [-r rev] ...",
		"cD:ilNnpRr:u",
		"Show differences between revisions",
		NULL
	},
	{
		CVS_OP_EDIT, "edit",     {              }, NULL,
		"",
		"",
		"Get ready to edit a watched file",
		NULL
	},
	{
		CVS_OP_EDITORS, "editors",  {              }, NULL,
		"",
		"",
		"See who is editing a watched file",
		NULL
	},
	{
		CVS_OP_EXPORT, "export",   { "ex",  "exp" }, NULL,
		"",
		"",
		"Export sources from CVS, similar to checkout",
		NULL
	},
	{
		CVS_OP_HISTORY, "history",  { "hi",  "his" }, &cvs_history,
		"",
		"acelm:oTt:u:wx:z:",
		"Show repository access history",
		NULL
	},
	{
		CVS_OP_IMPORT, "import",   { "im",  "imp" }, &cvs_import,
		"[-d] [-b branch] [-I ign] [-k subst] [-m msg] "
		"repository vendor-tag release-tags ...",
		"b:dI:k:m:",
		"Import sources into CVS, using vendor branches",
		NULL
	},
	{
		CVS_OP_INIT, "init",     {              }, &cvs_init,
		"",
		"",
		"Create a CVS repository if it doesn't exist",
		NULL
	},
#if defined(HAVE_KERBEROS)
	{
		"kserver",  {}, NULL
		"",
		"",
		"Start a Kerberos authentication CVS server",
		NULL
	},
#endif
	{
		CVS_OP_LOG, "log",      { "lo"         }, &cvs_getlog,
		"[-bhlNRt] [-d dates] [-r revisions] [-s states] [-w logins]",
		"bd:hlNRrs:tw",
		"Print out history information for files",
		NULL
	},
	{
		-1, "login",    {}, NULL,
		"",
		"",
		"Prompt for password for authenticating server",
		NULL
	},
	{
		-1, "logout",   {}, NULL,
		"",
		"",
		"Removes entry in .cvspass for remote repository",
		NULL
	},
	{
		CVS_OP_RDIFF, "rdiff",    {}, NULL,
		"",
		"",
		"Create 'patch' format diffs between releases",
		NULL
	},
	{
		CVS_OP_RELEASE, "release",  { "re", "rel" }, &cvs_release,
		"[-d] dir ...",
		"d",
		"Indicate that a Module is no longer in use",
		NULL
	},
	{
		CVS_OP_REMOVE, "remove",   { "rm", "delete" }, &cvs_remove,
		"[-flR] [file ...]",
		"flR",
		"Remove an entry from the repository",
		NULL
	},
	{
		CVS_OP_RLOG, "rlog",     {}, NULL,
		"",
		"",
		"Print out history information for a module",
		NULL
	},
	{
		CVS_OP_RTAG, "rtag",     {}, NULL,
		"",
		"",
		"Add a symbolic tag to a module",
		NULL
	},
	{
		CVS_OP_SERVER, "server",   {}, &cmd_server,
		"",
		"",
		"Server mode",
		NULL
	},
	{
		CVS_OP_STATUS, "status",   { "st", "stat" }, &cvs_status,
		"[-lRv]",
		"lRv",
		"Display status information on checked out files",
		NULL
	},
	{
		CVS_OP_TAG, "tag",      { "ta", "freeze" }, &cvs_tag,
		"[-bcdFflR] [-D date | -r rev] tagname ...",
		"bcD:dFflRr:",
		"Add a symbolic tag to checked out version of files",
		NULL
	},
	{
		CVS_OP_UNEDIT, "unedit",   {}, NULL,
		"",
		"",
		"Undo an edit command",
		NULL
	},
	{
		CVS_OP_UPDATE, "update",   { "up", "upd" }, &cvs_update,
		"[-ACdflPpR] [-D date | -r rev] [-I ign] [-j rev] [-k mode] "
		"[-t id] ...",
		"ACD:dflPpQqRr:",
		"Bring work tree in sync with repository",
		NULL
	},
	{
		CVS_OP_VERSION, "version",  { "ve", "ver" }, &cvs_version, 
		"", "",
		"Show current CVS version(s)",
		NULL
	},
	{
		CVS_OP_WATCH, "watch",    {}, NULL,
		"",
		"",
		"Set watches",
		NULL
	},
	{
		CVS_OP_WATCHERS, "watchers", {}, NULL,
		"",
		"",
		"See who is watching a file",
		NULL
	},
};

#define CVS_NBCMD  (sizeof(cvs_cdt)/sizeof(cvs_cdt[0]))


d168 1
a168 1
		for (i = 0; i < (int)CVS_NBCMD; i++)
d170 2
a171 7
			    cvs_cdt[i].cmd_name, cvs_cdt[i].cmd_descr);
		exit(1);
	}

	if (cmdp->cmd_info == NULL) {
		cvs_log(LP_ERR, "command `%s' not implemented", cvs_command);
		exit(1);
a218 2
	if (cmdp->cmd_info->cmd_cleanup != NULL)
		cmdp->cmd_info->cmd_cleanup();
a314 32
}


/*
 * cvs_findcmd()
 *
 * Find the entry in the command dispatch table whose name or one of its
 * aliases matches <cmd>.
 * Returns a pointer to the command entry on success, NULL on failure.
 */
struct cvs_cmd*
cvs_findcmd(const char *cmd)
{
	u_int i, j;
	struct cvs_cmd *cmdp;

	cmdp = NULL;

	for (i = 0; (i < CVS_NBCMD) && (cmdp == NULL); i++) {
		if (strcmp(cmd, cvs_cdt[i].cmd_name) == 0)
			cmdp = &cvs_cdt[i];
		else {
			for (j = 0; j < CVS_CMD_MAXALIAS; j++) {
				if (strcmp(cmd, cvs_cdt[i].cmd_alias[j]) == 0) {
					cmdp = &cvs_cdt[i];
					break;
				}
			}
		}
	}

	return (cmdp);
@


1.65
log
@first bits of the `cvs -n' option; ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.64 2005/05/19 15:37:50 xsa Exp $	*/
d316 1
a316 1
	    "Usage: %s [-flQqtv] [-d root] [-e editor] [-s var=val] [-z level] "
@


1.64
log
@- add missing flags for the log command
- enable the -h -N -R -t options
ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.63 2005/05/18 11:53:38 xsa Exp $	*/
d59 1
d114 1
a114 1
		"AcD:d:fj:k:lNnPRr:st:",
d491 1
@


1.63
log
@add `dir' arg in release cmd synopsis;
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.62 2005/05/17 16:45:07 xsa Exp $	*/
d186 1
a186 1
		"d:hlRr:",
@


1.62
log
@enable `release' command; tested & ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.61 2005/04/25 19:09:15 jfb Exp $	*/
d213 1
a213 1
		"[-d]",
@


1.61
log
@resurrect missing parts to generate rcsdiff(1)-style diffs with the -n
flag

ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.59 2005/04/22 15:06:28 xsa Exp $	*/
d212 1
a212 1
		CVS_OP_RELEASE, "release",  {}, NULL,
@


1.60
log
@* add missing 'R' flag in diff synopsis
* add the CVS_EX_BADROOT return code to indicate that there was no
  CVSROOT given or it was invalid

ok joris, xsa
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 2
a127 2
		"[-cilNpRu] [-D date] [-r rev] ...",
		"cD:ilNpRr:u",
@


1.59
log
@sync add command usage w/ man page; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.58 2005/04/22 03:38:56 joris Exp $	*/
d126 2
a127 2
		"[-cilNpu] [-D date] [-r rev] ...",
		"cD:ilNpr:Ru",
d437 6
@


1.58
log
@

missing '-R' (force recursion) option for diff.

noticed by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.57 2005/04/21 20:56:12 xsa Exp $	*/
d90 1
a90 1
		"[-k opt] [-m msg] file ...",
@


1.57
log
@let the `cvs remove' command work with no file(s) specified as args;
joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.56 2005/04/21 04:37:11 jfb Exp $	*/
d127 1
a127 1
		"cD:ilNpr:u",
@


1.56
log
@* fix the tag command's synopsis
* prepend __progname and the command string when displaying command
  usage
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.55 2005/04/20 23:11:30 jfb Exp $	*/
d220 1
a220 1
		"[-flR] file ...",
@


1.55
log
@check the validity of tag names passed to the tag command, and print
an abort message if the tag is invalid.  also, match gnu cvs behaviour
with regards to command usage output on usage errors.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.54 2005/04/16 19:05:02 xsa Exp $	*/
d255 1
a255 1
		"[-bcdFflR] [-D date | -r rev] tagname",
d426 2
a427 1
		fprintf(stderr, "Usage: %s\n", cmdp->cmd_synopsis);
@


1.54
log
@snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.53 2005/04/12 19:35:32 joris Exp $	*/
a423 3
	if (ret > 0)
		fprintf(stderr, "%s [%s aborted]: ", __progname, cvs_command);

d426 1
a426 1
		fprintf(stderr, "Usage: %s", cmdp->cmd_synopsis);
d429 1
a429 1
		fprintf(stderr, "internal data error");
d432 1
a432 1
		fprintf(stderr, "protocol error");
d435 1
a435 1
		fprintf(stderr, "an operation on a file or directory failed");
a439 3

	if (ret > 0)
		fprintf(stderr, "\n");
@


1.53
log
@

don't show unneeded error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.52 2005/04/12 15:18:13 xsa Exp $	*/
d590 1
a590 1
	int linenum = 0;
d602 6
a607 1
	snprintf(rcpath, sizeof(rcpath), "%s/%s", pw->pw_dir, CVS_PATH_RC);
@


1.52
log
@tell about the CVS_EX_* error codes, as we do not use sysexits.h anymore;
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.51 2005/04/12 14:58:40 joris Exp $	*/
a440 1
		fprintf(stderr, "unknown error");
@


1.51
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.50 2005/04/11 18:02:58 joris Exp $	*/
d83 1
a83 1
 * the values known in sysexits.h in case of an error.  In case the error
@


1.50
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.49 2005/04/11 17:56:27 joris Exp $	*/
d424 19
a442 3
	if (ret == 1) {
		fprintf(stderr, "Usage: %s %s %s\n", __progname, cvs_command,
		    cmdp->cmd_synopsis);
d444 3
@


1.49
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.48 2005/04/06 16:35:25 jfb Exp $	*/
a38 1
#include <sysexits.h>
@


1.48
log
@make cvs_findcmd() available to the rest of the program

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.47 2005/04/03 17:32:50 xsa Exp $	*/
d85 1
a85 1
 * returned is EX_USAGE, the command's usage string is printed to standard
d357 1
a357 1
		exit(EX_USAGE);
d396 1
a396 1
		exit(EX_USAGE);
d425 1
a425 1
	if (ret == EX_USAGE) {
d488 1
a488 1
				exit(EX_USAGE);
d492 1
a492 1
				exit(EX_USAGE);
d518 1
a518 1
			exit(EX_USAGE);
@


1.47
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.46 2005/03/31 17:18:24 joris Exp $	*/
d302 3
a304 5
void             usage        (void);
void             sigchld_hdlr (int);
static void             cvs_read_rcfile   (void);
static struct cvs_cmd*  cvs_findcmd  (const char *); 
int              cvs_getopt   (int, char **); 
d537 1
a537 1
static struct cvs_cmd*
@


1.46
log
@

make sure the server command can still be reached with the
new framework.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.45 2005/03/30 17:43:04 joris Exp $	*/
d372 1
a372 1
				exit(EX_OSERR);
d419 1
a419 1
			exit(EX_DATAERR);
@


1.45
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.44 2005/03/24 01:21:49 jfb Exp $	*/
d241 1
a241 1
		CVS_OP_SERVER, "server",   {}, NULL,
@


1.44
log
@add the string table code and enable it on startup
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.43 2005/03/24 01:03:41 joris Exp $	*/
d90 1
a90 1
		CVS_OP_ADD, "add",      { "ad",  "new" }, cvs_add,
d94 1
a94 1
		NULL, NULL
d97 1
a97 2
		CVS_OP_ADMIN, "admin",    { "adm", "rcs" }, cvs_admin,
		"",
d99 1
d101 1
a101 1
		NULL, NULL
d104 1
a104 1
		CVS_OP_ANNOTATE, "annotate", { "ann"        }, cvs_annotate,
d108 1
a108 1
		NULL, NULL
d111 1
a111 1
		CVS_OP_CHECKOUT, "checkout", { "co",  "get" }, cvs_checkout,
d116 1
a116 1
		NULL, NULL
d119 1
a119 1
		CVS_OP_COMMIT, "commit",   { "ci",  "com" }, cvs_commit,
d123 1
a123 1
		NULL, NULL
d126 1
a126 1
		CVS_OP_DIFF, "diff",     { "di",  "dif" }, cvs_diff,
d130 1
a130 1
		NULL, NULL
d137 1
a137 1
		NULL, NULL
d144 1
a144 1
		NULL, NULL
d151 1
a151 1
		NULL, NULL
d154 1
a154 2
		CVS_OP_HISTORY, "history",  { "hi",  "his" }, cvs_history,
		"",
d156 1
d158 1
a158 1
		NULL, NULL
d161 1
a161 1
		CVS_OP_IMPORT, "import",   { "im",  "imp" }, cvs_import,
d166 1
a166 1
		NULL, NULL
d169 1
a169 1
		CVS_OP_INIT, "init",     {              }, cvs_init,
d173 1
a173 1
		NULL, NULL
d181 1
a181 1
		NULL, NULL
d185 1
a185 1
		CVS_OP_LOG, "log",      { "lo"         }, cvs_getlog,
d187 1
a187 1
		"",
d189 1
a189 1
		NULL, NULL
d196 1
a196 1
		NULL, NULL
d203 1
a203 1
		NULL, NULL
d210 1
a210 1
		NULL, NULL
d217 1
a217 1
		NULL, NULL
d220 1
a220 1
		CVS_OP_REMOVE, "remove",   { "rm", "delete" }, cvs_remove,
d224 1
a224 1
		NULL, NULL
d231 1
a231 1
		NULL, NULL
d238 1
a238 1
		NULL, NULL
d241 1
a241 1
		CVS_OP_SERVER, "server",   {}, cvs_server,
d245 1
a245 1
		NULL, NULL
d248 1
a248 1
		CVS_OP_STATUS, "status",   { "st", "stat" }, cvs_status,
d252 1
a252 1
		NULL, NULL
d255 1
a255 1
		CVS_OP_TAG, "tag",      { "ta", "freeze" }, cvs_tag,
d259 1
a259 1
		NULL, NULL
d266 1
a266 1
		NULL, NULL
d269 1
a269 1
		CVS_OP_UPDATE, "update",   { "up", "upd" }, cvs_update,
d272 1
a272 1
		"",
d274 1
a274 1
		NULL, NULL
d277 1
a277 1
		CVS_OP_VERSION, "version",  { "ve", "ver" }, cvs_version,
d280 1
a280 1
		NULL, NULL
d287 1
a287 1
		NULL, NULL
d294 1
a294 1
		NULL, NULL
d401 1
a401 1
	if (cmdp->cmd_hdlr == NULL) {
d426 1
a426 1
	ret = (*cmdp->cmd_hdlr)(cmd_argc, cmd_argv);
d432 2
@


1.43
log
@

add the first pieces of our new command framework.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.42 2005/03/08 16:13:30 joris Exp $	*/
d44 1
d342 2
d436 2
@


1.42
log
@

make cvs_findcmd() and cvs_read_rcfile() static.

ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.41 2005/03/06 21:09:00 joris Exp $	*/
d87 1
a87 10
static struct cvs_cmd {
	int     cmd_op;
	char    cmd_name[CVS_CMD_MAXNAMELEN];
	char    cmd_alias[CVS_CMD_MAXALIAS][CVS_CMD_MAXNAMELEN];
	int   (*cmd_hdlr)(int, char **);
	char   *cmd_synopsis;
	char   *cmd_opts;
	char    cmd_descr[CVS_CMD_MAXDESCRLEN];
	char   *cmd_defargs;
} cvs_cdt[] = {
d93 1
a93 1
		NULL,
d100 1
a100 1
		NULL,
d107 1
a107 1
		NULL,
d115 1
a115 1
		NULL,
d122 1
a122 1
		NULL,
d129 1
a129 1
		NULL,
d136 1
a136 1
		NULL,
d143 1
a143 1
		NULL,
d150 1
a150 1
		NULL,
d157 1
a157 1
		NULL,
d165 1
a165 1
		NULL,
d172 1
a172 1
		NULL,
d180 1
a180 1
		NULL,
d188 1
a188 1
		NULL,
d195 1
a195 1
		NULL,
d202 1
a202 1
		NULL,
d209 1
a209 1
		NULL,
d216 1
a216 1
		NULL,
d223 1
a223 1
		NULL,
d230 1
a230 1
		NULL,
d237 1
a237 1
		NULL,
d244 1
a244 1
		NULL,
d251 1
a251 1
		NULL,
d258 1
a258 1
		NULL,
d265 1
a265 1
		NULL,
d273 1
a273 1
		NULL,
d279 1
a279 1
		NULL,
d286 1
a286 1
		NULL,
d293 1
a293 1
		NULL,
@


1.41
log
@

initial support for the admin command. Not all options are working yet.

ok xsa@@ jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.40 2005/02/25 20:30:36 jfb Exp $	*/
d312 2
a313 2
void             cvs_read_rcfile   (void);
struct cvs_cmd*  cvs_findcmd  (const char *); 
d541 1
a541 1
struct cvs_cmd*
d573 1
a573 1
void
@


1.40
log
@exit with an error message if cvs_file_init() fails
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.39 2005/02/03 23:00:42 xsa Exp $	*/
d105 1
a105 1
		CVS_OP_ADMIN, "admin",    { "adm", "rcs" }, NULL,
@


1.39
log
@be more consistent everywhere with `-k mode' option;
ok jfb@@ jmc@@ Joris Vink;
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.38 2005/01/24 18:48:23 jfb Exp $	*/
d390 4
a393 1
	cvs_file_init();
@


1.38
log
@sync usage of some of the commands, and start filling the cmd_opts
field, which will later be used as the argument to getopt() instead
of hardcoding the option strings.  This will allow us to use the
same handler for commands which have a local and remote version
(i.e. rdiff, rlog, rtag)
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.37 2005/01/24 17:42:26 jfb Exp $	*/
d120 1
a120 1
		"[-AcflNnPpRs] [-D date | -r rev] [-d dir] [-j rev] [-k kopt] "
d278 1
a278 1
		"[-ACdflPpR] [-D date | -r rev] [-I ign] [-j rev] [-k kopt] "
@


1.37
log
@* use the global cvs_msg instead of our own
* support the use of RCS keyword expansion flags in client mode
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.36 2005/01/24 16:12:56 jfb Exp $	*/
d113 2
a114 2
		"[-flR] [-D date | -r rev] file ...",
		"",
d120 3
a122 2
		"",
		"",
d194 1
a194 1
		"",
d222 2
a223 2
		"",
		"",
d230 1
a230 1
		"",
d258 1
a258 1
		"",
d264 2
a265 2
		"[-bdl] [-D date | -r rev] tagname",
		"",
d278 2
a279 1
		"",
@


1.36
log
@add missing command IDs

reviewed by xsa@@ and Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.35 2005/01/14 18:02:04 jfb Exp $	*/
d99 2
a100 2
		"[-m msg] file ...",
		"",
@


1.35
log
@support the -D option to the tag command and sync usage for the tag
command

from Joris Vink, with modifications by me
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.34 2005/01/13 23:39:42 jfb Exp $	*/
d105 1
a105 1
		-1, "admin",    { "adm", "rcs" }, NULL,
d140 1
a140 1
		-1, "edit",     {              }, NULL,
d147 1
a147 1
		-1, "editors",  {              }, NULL,
d154 1
a154 1
		-1, "export",   { "ex",  "exp" }, NULL,
d213 1
a213 1
		-1, "rdiff",    {}, NULL,
d220 1
a220 1
		-1, "release",  {}, NULL,
d234 1
a234 1
		-1, "rlog",     {}, NULL,
d241 1
a241 1
		-1, "rtag",     {}, NULL,
d269 1
a269 1
		-1, "unedit",   {}, NULL,
d289 1
a289 1
		-1, "watch",    {}, NULL,
d296 1
a296 1
		-1, "watchers", {}, NULL,
@


1.34
log
@resurrect the -N and -p options to the diff command

requested and tested by brad@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.33 2005/01/13 18:47:31 jfb Exp $	*/
d263 1
a263 1
		"",
@


1.33
log
@more widespread use of cvs_msg, and free it when we are done

diff by Joris Vink and me
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.32 2005/01/13 16:32:46 jfb Exp $	*/
d134 2
a135 2
		"[-cilu] [-D date] [-r rev] ...",
		"cD:ilur:",
@


1.32
log
@fix the annotate usage (there is no -F flag) and add the missing bits
so the -r and -f arguments are supported, and complain if both -D
and -r are given.  GNU CVS silently accepts to have both specified,
but does not produce output as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.31 2005/01/06 20:39:27 jfb Exp $	*/
d435 2
@


1.31
log
@the status command now supports the same arguments as its gnu cvs
counterpart (-lRv)
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.30 2005/01/06 19:56:38 jfb Exp $	*/
d113 1
a113 1
		"[-FflR] [-D date | -r rev] file ...",
@


1.30
log
@Improved and working import code from Joris Vink with modifications
from me (client mode only for the moment)
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.29 2004/12/22 00:38:25 david Exp $	*/
d256 1
a256 1
		"",
@


1.29
log
@spelling corrections; ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.28 2004/12/21 20:59:57 xsa Exp $	*/
d168 1
a168 1
		CVS_OP_IMPORT, "import",   { "im",  "imp" }, NULL,
@


1.28
log
@s/files/file/ in `cvs remove' usage, like in the other commands;
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.27 2004/12/21 18:47:58 jfb Exp $	*/
d82 1
a82 1
 * Command handlers are expected to return 0 if no error occured, or one of
@


1.27
log
@gnu CVS has an undocumented -s command-line option to set a variable,
so let's support it too.  This will also be required to implement the
`Set' request handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.26 2004/12/21 18:15:55 xsa Exp $	*/
d228 1
a228 1
		"[-flR] files ...",
@


1.26
log
@on the way to `cvs remove'; ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.25 2004/12/15 16:28:14 xsa Exp $	*/
d34 1
d73 2
d324 2
a325 1
	    "Usage: %s [-flQqtv] [-d root] [-e editor] [-z level] command [...]\n", __progname);
d336 2
d446 1
a446 1
	while ((ret = getopt(argc, argv, "b:d:e:fHlnQqrtvz:")) != -1) {
d481 10
d641 111
@


1.25
log
@print line number of warnings in .cvsrc; ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.24 2004/12/15 06:11:40 jfb Exp $	*/
d224 2
a225 2
		CVS_OP_REMOVE, "remove",   {}, NULL,
		"",
@


1.24
log
@Permit the client to generate trace output when the -t option is given
by using the LP_TRACE level to cvs_log().  Traces are filtered by
default.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.23 2004/12/14 19:56:35 xsa Exp $	*/
d608 2
a609 2
				    "unknown command `%s' in `%s'",
				    linebuf, rcpath);
@


1.23
log
@be more verbose for .cvsrc errors/warnings; ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.22 2004/12/14 19:11:54 jfb Exp $	*/
d476 1
@


1.22
log
@support the tag command

from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.21 2004/12/13 16:10:30 xsa Exp $	*/
d553 1
d576 1
d580 2
a581 1
			cvs_log(LP_WARN, ".cvsrc line too long");
d620 1
a620 1
		cvs_log(LP_NOTICE, "failed to read line from cvsrc");
@


1.21
log
@print full path of .cvsrc in log messages; jfb@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.20 2004/12/13 13:55:10 jmc Exp $	*/
d259 1
a259 1
		CVS_OP_TAG, "tag",      { "ta", "freeze" }, NULL,
@


1.20
log
@sync SYNOPSIS and usage();
ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.19 2004/12/09 20:03:27 jfb Exp $	*/
d604 2
a605 2
				    "unknown command `%s' in cvsrc",
				    linebuf);
@


1.19
log
@support the 'annotate' command, will need some polishing
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.18 2004/12/07 17:10:56 tedu Exp $	*/
d321 1
a321 3
	    "Usage: %s [-lQqtvx] [-b bindir] [-d root] [-e editor] [-z level] "
	    "command [options] ...\n",
	    __progname);
@


1.18
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.17 2004/12/07 06:33:10 jfb Exp $	*/
d109 2
a110 2
		CVS_OP_ANNOTATE, "annotate", { "ann"        }, NULL,
		"",
@


1.17
log
@add missing parts for support of .cvsrc

tested, tweaked by and ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.16 2004/12/06 21:03:12 deraadt Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a50 2


a67 1

a71 1

a83 1

a316 1

d491 1
a491 1
			cvs_compress = (int)strtol(optarg, &ep, 10); 
a518 1

a550 1

@


1.16
log
@add missing aliases for the status, tag, update and version commands

original patch from Peter Hessler, with additions by me
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.15 2004/12/06 21:03:12 deraadt Exp $	*/
d55 1
d59 1
a59 1
int   cvs_nocase = 0;   /* set to 1 to disable case sensitivity on filenames */
d61 2
a62 2
/* name of the command we are running */
char *cvs_command;
d97 1
d104 1
d111 1
d118 1
d125 1
d132 1
d139 1
d146 1
d153 1
d160 1
d167 1
d175 1
d182 1
d190 1
d198 1
d205 1
d212 1
d219 1
d226 1
d233 1
d240 1
d247 1
d254 1
d261 1
d268 1
d275 1
d282 1
d288 1
d295 1
d302 1
d312 1
a312 1
void             cvs_readrc   (void);
d314 1
d336 2
a337 3
	char *envstr, *ep;
	int ret;
	u_int i, readrc;
a339 2
	readrc = 1;

d359 89
d465 1
a465 1
			readrc = 0;
d510 1
a510 4
	argc -= optind;
	argv += optind;

	/* reset getopt() for use by commands */
d512 1
a512 43
	optreset = 1;

	if (argc == 0) {
		usage();
		exit(EX_USAGE);
	}

	/* setup signal handlers */
	signal(SIGPIPE, SIG_IGN);

	cvs_file_init();

	if (readrc)
		cvs_readrc();

	cvs_command = argv[0];
	ret = -1;

	cmdp = cvs_findcmd(cvs_command);
	if (cmdp == NULL) {
		fprintf(stderr, "Unknown command: `%s'\n\n", cvs_command);
		fprintf(stderr, "CVS commands are:\n");
		for (i = 0; i < CVS_NBCMD; i++)
			fprintf(stderr, "\t%-16s%s\n",
			    cvs_cdt[i].cmd_name, cvs_cdt[i].cmd_descr);
		exit(EX_USAGE);
	}

	if (cmdp->cmd_hdlr == NULL) {
		cvs_log(LP_ERR, "command `%s' not implemented", cvs_command);
		exit(1);
	}

	cvs_cmdop = cmdp->cmd_op;

	ret = (*cmdp->cmd_hdlr)(argc, argv);
	if (ret == EX_USAGE) {
		fprintf(stderr, "Usage: %s %s %s\n", __progname, cvs_command,
		    cmdp->cmd_synopsis);
	}

	if (cvs_files != NULL)
		cvs_file_free(cvs_files);
d552 1
a552 1
 * cvs_readrc()
d560 1
a560 1
cvs_readrc(void)
d563 1
d585 8
a593 2

		/* ignore lines with no arguments */
d595 2
a596 3
			continue;

		*(lp++) = '\0';
d598 11
a608 1
			/* global options */
d610 1
d618 6
@


1.15
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cvs.c,v 1.14 2004/11/09 23:06:01 krapht Exp $	*/
d233 1
a233 1
		CVS_OP_STATUS, "status",   {}, cvs_status,
d239 1
a239 1
		CVS_OP_TAG, "tag",      { "ta", }, NULL,
d251 1
a251 1
		CVS_OP_UPDATE, "update",   {}, cvs_update,
d257 1
a257 1
		CVS_OP_VERSION, "version",  {}, cvs_version,
@


1.14
log
@* don't use the import code just yet, it uses new functions that aren't
  tested enough yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d520 1
a520 2
		}
		else {
@


1.13
log
@* don't setup a signal handler for SIGCHLD yet
* ignore SIGPIPE
* add the getopt() argument format to the command structure
@
text
@d158 1
a158 1
		CVS_OP_IMPORT, "import",   { "im",  "imp" }, cvs_import,
@


1.12
log
@After the command is done executing, if cvs_files isn't NULL, free the
file structure
@
text
@d67 2
d94 1
d100 1
d106 1
d112 1
d118 1
d124 1
d130 1
d136 1
d142 1
d148 1
d154 1
d158 4
a161 2
		CVS_OP_IMPORT, "import",   { "im",  "imp" }, NULL,
		"",
d167 1
d174 1
d181 1
d187 1
d193 1
d199 1
d205 1
d211 1
d217 1
d223 1
d229 1
d235 1
d241 1
d247 1
d253 1
d258 1
a258 1
		"",
d264 1
d270 1
a284 19

/*
 * sigchld_hdlr()
 *
 * Handler for the SIGCHLD signal, which can be received in case we are
 * running a remote server and it dies.
 */

void
sigchld_hdlr(int signo)
{
	int status;
	pid_t pid;

	if ((pid = wait(&status)) == -1) {
	}
}


d405 1
a405 1
	signal(SIGCHLD, sigchld_hdlr);
@


1.11
log
@Handle the '-b' and '-x' global options even if we don't support them,
and add support for case insensitivity
@
text
@d425 3
@


1.10
log
@Have one global hierarchy of files that are being affected.  This will
allow us to build the tree in memory as well as on disk for operations
such as checkout and update.  It will also allow us to write all Entries
in a single disk write and to avoid creating empty directories on updates
when pruning is requested
@
text
@d58 1
d282 1
a282 1
	    "Usage: %s [-lQqtv] [-d root] [-e editor] [-z level] "
d317 1
a317 1
	while ((ret = getopt(argc, argv, "d:e:fHlnQqrtvz:")) != -1) {
d319 8
d359 5
@


1.9
log
@No more global cvs_root
@
text
@d67 5
@


1.8
log
@missing include
@
text
@a65 2
struct cvsroot *cvs_root = NULL;

@


1.7
log
@Plug in the handler for `cvs status'
@
text
@d42 1
@


1.6
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d202 1
a202 1
		CVS_OP_STATUS, "status",   {}, NULL,
@


1.5
log
@undefine DEBUG
@
text
@d60 1
d82 1
d90 1
a90 1
		"add",      { "ad",  "new" }, cvs_add,
d95 1
a95 1
		"admin",    { "adm", "rcs" }, NULL,
d100 1
a100 1
		"annotate", { "ann"        }, NULL,
d105 1
a105 1
		"checkout", { "co",  "get" }, cvs_checkout,
d110 1
a110 1
		"commit",   { "ci",  "com" }, cvs_commit,
d115 1
a115 1
		"diff",     { "di",  "dif" }, cvs_diff,
d120 1
a120 1
		"edit",     {              }, NULL,
d125 1
a125 1
		"editors",  {              }, NULL,
d130 1
a130 1
		"export",   { "ex",  "exp" }, NULL,
d135 1
a135 1
		"history",  { "hi",  "his" }, cvs_history,
d140 1
a140 1
		"import",   { "im",  "imp" }, NULL,
d145 1
a145 1
		"init",     {              }, cvs_init,
d157 1
a157 1
		"log",      { "lo"         }, cvs_getlog,
d162 1
a162 1
		"login",    {}, NULL,
d167 1
a167 1
		"logout",   {}, NULL,
d172 1
a172 1
		"rdiff",    {}, NULL,
d177 1
a177 1
		"release",  {}, NULL,
d182 1
a182 1
		"remove",   {}, NULL,
d187 1
a187 1
		"rlog",     {}, NULL,
d192 1
a192 1
		"rtag",     {}, NULL,
d197 1
a197 1
		"server",   {}, cvs_server,
d202 1
a202 1
		"status",   {}, NULL,
d207 1
a207 1
		"tag",      { "ta", }, NULL,
d212 1
a212 1
		"unedit",   {}, NULL,
d217 1
a217 1
		"update",   {}, cvs_update,
d222 1
a222 1
		"version",  {}, cvs_version,
d227 1
a227 1
		"watch",    {}, NULL,
d232 1
a232 1
		"watchers", {}, NULL,
d398 2
@


1.4
log
@Add the handler for the checkout command
@
text
@a0 1
#define DEBUG
@


1.3
log
@add a usage string for cvs diff options
@
text
@d104 1
a104 1
		"checkout", { "co",  "get" }, NULL,
d110 1
a110 1
		"",
@


1.2
log
@cvsignore support and simpler API for file access
@
text
@d115 1
a115 1
		"",
@


1.1
log
@Initial revision
@
text
@d375 2
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
