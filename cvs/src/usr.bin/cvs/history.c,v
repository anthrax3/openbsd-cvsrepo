head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.2
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.14
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.12
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.10
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.8
	OPENBSD_5_0:1.40.0.6
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.4
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.39.0.6
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.8
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.4
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.2
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.43;
commitid	8Vv7d4HkmCtExfc6;

1.43
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.42;
commitid	O6jeJ0TRmiewrqMI;

1.42
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Uu5nFG3wCl0LACBb;

1.41
date	2013.12.13.15.19.41;	author zhuk;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.19.19.03.25;	author tobias;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.11.00.47.05;	author tobias;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.10.16.32.35;	author tobias;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.10.15.55.54;	author tobias;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.10.10.56.37;	author tobias;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.09.05.56.44;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.03.13.22.43;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.28.04.48.52;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.20.16.25.46;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.18.17.54.13;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.27.03.30.30;	author joris;	state dead;
branches;
next	1.26;

1.26
date	2006.01.23.14.02.42;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.21.11.42.24;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.11.18.13.01;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.30.16.37.29;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.28.14.34.56;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.31.08.26.40;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.29.00.18.01;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.27.20.47.06;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.28.20.45.07;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.31.22.04.58;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.31.21.46.43;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.30.01.49.23;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.29.18.34.23;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.44
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@/*	$OpenBSD: history.c,v 1.43 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2007 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

void	cvs_history_local(struct cvs_file *);

static void	history_compress(char *, const char *);

struct cvs_cmd		cvs_cmd_history = {
	CVS_OP_HISTORY, CVS_USE_WDIR, "history",
	{ "hi", "his" },			/* omghi2you */
	"Display history of actions done in the base repository",
	"[-ac]",
	"ac",
	NULL,
	cvs_history
};

/* keep in sync with the defines for history stuff in cvs.h */
const char historytab[] = {
	'T',
	'O',
	'E',
	'F',
	'W',
	'U',
	'G',
	'C',
	'M',
	'A',
	'R',
	'\0'
};

#define HISTORY_ALL_USERS		0x01
#define HISTORY_DISPLAY_ARCHIVED	0x02

void
cvs_history_add(int type, struct cvs_file *cf, const char *argument)
{
	BUF *buf;
	FILE *fp;
	RCSNUM *hrev;
	size_t len;
	int fd;
	char *cwd, *p, *rev;
	char revbuf[CVS_REV_BUFSZ], repo[PATH_MAX], fpath[PATH_MAX];
	char timebuf[CVS_TIME_BUFSZ];
	struct tm datetm;

	if (cvs_nolog == 1)
		return;

	if (cvs_cmdop == CVS_OP_CHECKOUT || cvs_cmdop == CVS_OP_EXPORT) {
		if (type != CVS_HISTORY_CHECKOUT &&
		    type != CVS_HISTORY_EXPORT)
			return;
	}

	cvs_log(LP_TRACE, "cvs_history_add(`%c', `%s', `%s')",
	    historytab[type], (cf != NULL) ? cf->file_name : "", argument);

	/* construct repository field */
	if (cvs_cmdop != CVS_OP_CHECKOUT && cvs_cmdop != CVS_OP_EXPORT) {
		cvs_get_repository_name((cf != NULL) ? cf->file_wd : ".",
		    repo, sizeof(repo));
	} else {
		cvs_get_repository_name(argument, repo, sizeof(repo));
	}

	if (cvs_server_active == 1) {
		cwd = "<remote>";
	} else {
		if (getcwd(fpath, sizeof(fpath)) == NULL)
			fatal("cvs_history_add: getcwd: %s", strerror(errno));
		p = fpath;
		if (cvs_cmdop == CVS_OP_CHECKOUT ||
		    cvs_cmdop == CVS_OP_EXPORT) {
			if (strlcat(fpath, "/", sizeof(fpath)) >=
			    sizeof(fpath) || strlcat(fpath, argument,
			    sizeof(fpath)) >= sizeof(fpath))
				fatal("cvs_history_add: string truncation");
		}
		if (cvs_homedir != NULL && cvs_homedir[0] != '\0') {
			len = strlen(cvs_homedir);
			if (strncmp(cvs_homedir, fpath, len) == 0 &&
			    fpath[len] == '/') {
				p += len - 1;
				*p = '~';
			}
		}

		history_compress(p, repo);
		cwd = xstrdup(p);
	}

	/* construct revision field */
	revbuf[0] = '\0';
	rev = revbuf;
	switch (type) {
	case CVS_HISTORY_TAG:
		strlcpy(revbuf, argument, sizeof(revbuf));
		break;
	case CVS_HISTORY_CHECKOUT:
	case CVS_HISTORY_EXPORT:
		/*
		 * buf_alloc uses xcalloc(), so we are safe even
		 * if neither cvs_specified_tag nor cvs_specified_date
		 * have been supplied.
		 */
		buf = buf_alloc(128);
		if (cvs_specified_tag != NULL) {
			buf_puts(buf, cvs_specified_tag);
			if (cvs_specified_date != -1)
				buf_putc(buf, ':');
		}
		if (cvs_specified_date != -1) {
			gmtime_r(&cvs_specified_date, &datetm);
			strftime(timebuf, sizeof(timebuf),
			    "%Y.%m.%d.%H.%M.%S", &datetm);
			buf_puts(buf, timebuf);
		}
		rev = buf_release(buf);
		break;
	case CVS_HISTORY_UPDATE_MERGED:
	case CVS_HISTORY_UPDATE_MERGED_ERR:
	case CVS_HISTORY_COMMIT_MODIFIED:
	case CVS_HISTORY_COMMIT_ADDED:
	case CVS_HISTORY_COMMIT_REMOVED:
	case CVS_HISTORY_UPDATE_CO:
		if ((hrev = rcs_head_get(cf->file_rcs)) == NULL)
			fatal("cvs_history_add: rcs_head_get failed");
		rcsnum_tostr(hrev, revbuf, sizeof(revbuf));
		free(hrev);
		break;
	}

	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s",
	    current_cvsroot->cr_dir, CVS_PATH_HISTORY);

	if ((fd = open(fpath, O_WRONLY|O_APPEND)) == -1) {
		if (errno != ENOENT)
			cvs_log(LP_ERR, "failed to open history file");
	} else {
		if ((fp = fdopen(fd, "a")) != NULL) {
			fprintf(fp, "%c%08llx|%s|%s|%s|%s|%s\n",
			    historytab[type], (long long)time(NULL),
			    getlogin(), cwd, repo, rev,
			    (cf != NULL) ? cf->file_name : argument);
			(void)fclose(fp);
		} else {
			cvs_log(LP_ERR, "failed to add entry to history file");
			(void)close(fd);
		}
	}

	if (rev != revbuf)
		free(rev);
	if (cvs_server_active != 1)
		free(cwd);
}

static void
history_compress(char *wdir, const char *repo)
{
	char *p;
	const char *q;
	size_t repo_len, wdir_len;

	repo_len = strlen(repo);
	wdir_len = strlen(wdir);

	p = wdir + wdir_len;
	q = repo + repo_len;

	while (p >= wdir && q >= repo) {
		if (*p != *q)
			break;
		p--;
		q--;
	}
	p++;
	q++;

	/* if it's not worth the effort, skip compression */
	if (repo + repo_len - q < 3)
		return;

	(void)xsnprintf(p, strlen(p) + 1, "*%zx", q - repo);
}

int
cvs_history(int argc, char **argv)
{
	int ch, flags;

	flags = 0;

	while ((ch = getopt(argc, argv, cvs_cmd_history.cmd_opts)) != -1) {
		switch (ch) {
		case 'a':
			flags |= HISTORY_ALL_USERS;
			break;
		case 'c':
			flags |= HISTORY_DISPLAY_ARCHIVED;
			break;
		default:
			fatal("%s", cvs_cmd_history.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	return (0);
}
@


1.43
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.42 2015/01/16 06:40:07 deraadt Exp $	*/
d160 1
a160 1
		rcsnum_free(hrev);
@


1.42
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.41 2013/12/13 15:19:41 zhuk Exp $	*/
d184 1
a184 1
		xfree(rev);
d186 1
a186 1
		xfree(cwd);
@


1.41
log
@Make it compile again. And there is a time_t fix as a bonus!

Input and okay jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.40 2010/07/23 21:46:05 ray Exp $	*/
d73 1
a73 1
	char revbuf[CVS_REV_BUFSZ], repo[MAXPATHLEN], fpath[MAXPATHLEN];
@


1.40
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.39 2008/06/19 19:03:25 tobias Exp $	*/
d172 4
a175 4
			fprintf(fp, "%c%x|%s|%s|%s|%s|%s\n",
			    historytab[type], time(NULL), getlogin(), cwd,
			    repo, rev, (cf != NULL) ? cf->file_name :
			    argument);
@


1.39
log
@Add entries to history file only if it already exists.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.38 2008/06/11 00:47:05 tobias Exp $	*/
d133 1
a133 1
		 * cvs_buf_alloc uses xcalloc(), so we are safe even
d137 1
a137 1
		buf = cvs_buf_alloc(128);
d139 1
a139 1
			cvs_buf_puts(buf, cvs_specified_tag);
d141 1
a141 1
				cvs_buf_putc(buf, ':');
d147 1
a147 1
			cvs_buf_puts(buf, timebuf);
d149 1
a149 1
		rev = cvs_buf_release(buf);
@


1.38
log
@GNU cvs "compresses" CVSROOT/history by shrinking entry for working dir
and repositry by replacing home directory with ~ and adding things like
"*4" at the end of working directory if the last part of a path is the
same for working directory and repository.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.37 2008/06/10 16:32:35 tobias Exp $	*/
d22 1
d71 1
d167 3
a169 6
	if ((fp = fopen(fpath, "a")) != NULL) {
		fprintf(fp, "%c%x|%s|%s|%s|%s|%s\n",
		    historytab[type], time(NULL), getlogin(), cwd, repo,
		    rev, (cf != NULL) ? cf->file_name : argument);

		(void)fclose(fp);
d171 10
a180 1
		cvs_log(LP_ERR, "failed to add entry to history file");
@


1.37
log
@Added support for tag and date in cvs_history_add for checkout/export.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.36 2008/06/10 15:55:54 tobias Exp $	*/
d32 2
d68 3
a70 1
	char *cwd, *rev;
d87 8
d98 1
a98 1
		if ((cwd = getcwd(NULL, MAXPATHLEN)) == NULL)
d100 16
a115 1
	}
d117 2
a118 6
	/* construct repository field */
	if (cvs_cmdop != CVS_OP_CHECKOUT && cvs_cmdop != CVS_OP_EXPORT) {
		cvs_get_repository_name((cf != NULL) ? cf->file_wd : ".",
		    repo, sizeof(repo));
	} else {
		strlcpy(repo, argument, sizeof(repo));
d155 4
a158 2
		rcsnum_tostr(cf->file_rcs->rf_head,
			revbuf, sizeof(revbuf));
d179 29
@


1.36
log
@If cvs_history_add has been called for a specific file, repo must be built
up from working directory of that file instead of top directory.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.35 2008/01/31 10:15:05 tobias Exp $	*/
d64 1
d66 1
a66 1
	char *cwd;
d68 2
d100 23
a122 18
	if (cvs_cmdop != CVS_OP_CHECKOUT && cvs_cmdop != CVS_OP_EXPORT) {
		switch (type) {
		case CVS_HISTORY_TAG:
			strlcpy(revbuf, argument, sizeof(revbuf));
			break;
		case CVS_HISTORY_CHECKOUT:
		case CVS_HISTORY_EXPORT:
			/* copy TAG or DATE to revbuf */
			break;
		case CVS_HISTORY_UPDATE_MERGED:
		case CVS_HISTORY_UPDATE_MERGED_ERR:
		case CVS_HISTORY_COMMIT_MODIFIED:
		case CVS_HISTORY_COMMIT_ADDED:
		case CVS_HISTORY_COMMIT_REMOVED:
		case CVS_HISTORY_UPDATE_CO:
			rcsnum_tostr(cf->file_rcs->rf_head,
			    revbuf, sizeof(revbuf));
			break;
d124 11
d143 1
a143 1
		    revbuf, (cf != NULL) ? cf->file_name : argument);
d150 2
@


1.35
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.34 2007/09/10 10:56:37 tobias Exp $	*/
d89 2
a90 1
		cvs_get_repository_name(".", repo, sizeof(repo));
@


1.34
log
@Properly display list of commands in default 80 column terminal.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.33 2007/08/09 05:56:44 ray Exp $	*/
d33 1
a33 1
	CVS_OP_HISTORY, 0, "history",
@


1.33
log
@Use '\0', not NULL, for NUL characters.

Pointed out by Anonymous Coward on slashdot.

OK niallo.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.32 2007/07/03 13:22:43 joris Exp $	*/
d35 1
a35 1
	"Display the history of actions done in the base repository",
@


1.32
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.31 2007/06/28 21:38:09 xsa Exp $	*/
d55 1
a55 1
	NULL
@


1.31
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.30 2007/06/28 04:48:52 joris Exp $	*/
a89 3

		if (strlen(repo) > strlen(cwd))
			fatal("bad repository `%s'", repo);
@


1.30
log
@when logging to CVSROOT/history as a server fill in the
directory as <remote> instead of /tmp/cvs-serv<pid>
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.29 2007/06/20 16:25:46 xsa Exp $	*/
d66 1
a66 1
	char revbuf[64], repo[MAXPATHLEN], fpath[MAXPATHLEN];
@


1.29
log
@Add missing `his' command alias. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.28 2007/06/18 17:54:13 joris Exp $	*/
d80 6
a85 2
	if ((cwd = getcwd(NULL, MAXPATHLEN)) == NULL)
		fatal("cvs_history_add: getcwd: %s", strerror(errno));
d133 2
a134 1
	xfree(cwd);
@


1.28
log
@first stab at history stuff for opencvs, currently only writes
to CVSROOT/history but cannot parse it yet with the 'history' command.

"Commit it." ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
	{ "hi" },				/* omghi2you */
@


1.27
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.26 2006/01/23 14:02:42 xsa Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d18 8
a25 1
#include "includes.h"
d28 1
a28 2
#include "log.h"
#include "proto.h"
d30 1
a30 1
#define CVS_HISTORY_MAXMOD	16
d32 6
a37 28
/* history flags */
#define CVS_HF_A	0x01
#define CVS_HF_C	0x02
#define CVS_HF_E	0x04
#define CVS_HF_L	0x08
#define CVS_HF_M	0x10
#define CVS_HF_O	0x20
#define CVS_HF_T	0x40
#define CVS_HF_W	0x80

#define CVS_HF_EXCL	(CVS_HF_C|CVS_HF_E|CVS_HF_M|CVS_HF_O|CVS_HF_T|CVS_HF_X)

static int	cvs_history_init(struct cvs_cmd *, int, char **, int *);
#if 0
static void	cvs_history_print(struct cvs_hent *);
#endif
static int	cvs_history_pre_exec(struct cvsroot *);

extern char *__progname;

struct cvs_cmd cvs_cmd_history = {
	CVS_OP_HISTORY, CVS_REQ_HISTORY, "history",
	{ "hi", "his" },
	"Show repository access history",
	"[-aceloTw] [-b str] [-D date] [-f file] [-m module]\n"
	"                   [-n module] [-p path] [-r rev] [-t tag]\n"
	"                   [-u user] [-x ACEFGMORTUW] [-z tz] [file ...]",
	"ab:cD:ef:lm:n:op:r:Tt:u:wx:z:",
d39 17
a55 8
	0,
	cvs_history_init,
	cvs_history_pre_exec,
	NULL,
	NULL,
	NULL,
	NULL,
	CVS_CMD_SENDDIR
d58 2
a59 6
static int flags = 0;
static char *date, *rev, *user, *tag;
static char *zone = "+0000";
static u_int nbmod = 0;
static u_int rep = 0;
static char *modules[CVS_HISTORY_MAXMOD];
d61 2
a62 2
static int
cvs_history_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d64 3
a66 1
	int ch;
d68 2
a69 1
	date = rev = user = tag = NULL;
d71 4
a74 62
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
		switch (ch) {
		case 'a':
			flags |= CVS_HF_A;
			break;
		case 'b':
			break;
		case 'c':
			rep++;
			flags |= CVS_HF_C;
			break;
		case 'D':
			break;
		case 'e':
			rep++;
			flags |= CVS_HF_E;
			break;
		case 'f':
			break;
		case 'l':
			flags |= CVS_HF_L;
			break;
		case 'm':
			rep++;
			flags |= CVS_HF_M;
			if (nbmod == CVS_HISTORY_MAXMOD) {
				cvs_log(LP_ERR, "too many `-m' options");
				return (CVS_EX_USAGE);
			}
			modules[nbmod++] = optarg;
			break;
		case 'n':
			break;
		case 'o':
			rep++;
			flags |= CVS_HF_O;
			break;
		case 'r':
			rev = optarg;
			break;
		case 'T':
			rep++;
			flags |= CVS_HF_T;
			break;
		case 't':
			tag = optarg;
			break;
		case 'u':
			user = optarg;
			break;
		case 'w':
			flags |= CVS_HF_W;
			break;
		case 'x':
			rep++;
			break;
		case 'z':
			zone = optarg;
			break;
		default:
			return (CVS_EX_USAGE);
		}
d77 2
a78 6
	if (rep > 1) {
		cvs_log(LP_ERR,
		    "Only one report type allowed from: \"-Tcomxe\"");
		return (CVS_EX_USAGE);
	} else if (rep == 0)
		flags |= CVS_HF_O;    /* use -o as default */
d80 2
a81 3
	*arg = optind;
	return (0);
}
d83 9
a91 17
static int
cvs_history_pre_exec(struct cvsroot *root)
{
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (flags & CVS_HF_A)
			cvs_sendarg(root, "-a", 0);

		if (flags & CVS_HF_C)
			cvs_sendarg(root, "-c", 0);

		if (flags & CVS_HF_O)
			cvs_sendarg(root, "-o", 0);

		if (date != NULL) {
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, date, 0);
		}
d93 20
a112 14
		if (rev != NULL) {
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, rev, 0);
		}

		if (tag != NULL) {
			cvs_sendarg(root, "-t", 0);
			cvs_sendarg(root, tag, 0);
		}

		/* if no user is specified, get login name of command issuer */
		if (!(flags & CVS_HF_A) && (user == NULL)) {
			if ((user = getlogin()) == NULL)
				fatal("cannot get login name");
d114 1
d116 2
a117 4
		if (!(flags & CVS_HF_A)) {
			cvs_sendarg(root, "-u", 0);
			cvs_sendarg(root, user, 0);
		}
d119 8
a126 2
		cvs_sendarg(root, "-z", 0);
		cvs_sendarg(root, zone, 0);
d129 1
a129 1
	return (0);
d132 4
d137 1
a137 5
#if 0
static void
cvs_history_print(struct cvs_hent *hent)
{
	struct tm etime;
d139 11
a149 3
	if (localtime_r(&(hent->ch_date), &etime) == NULL) {
		cvs_log(LP_ERR, "failed to convert timestamp to structure");
		return;
d152 4
a155 4
	printf("%c %4d-%02d-%02d %02d:%02d +%04d %-16s %-16s\n",
	    hent->ch_event, etime.tm_year + 1900, etime.tm_mon + 1,
	    etime.tm_mday, etime.tm_hour, etime.tm_min,
	    0, hent->ch_user, hent->ch_repo);
a156 1
#endif
@


1.26
log
@wrap usage;
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.25 2006/01/02 08:11:56 xsa Exp $	*/
@


1.25
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.24 2005/12/30 02:03:28 joris Exp $	*/
d59 3
a61 2
	"[-aceloTw] [-b str] [-D date] [-f file] [-m module] [-n module] "
	"[-p path] [-r rev] [-t tag] [-u user] [-x ACEFGMORTUW] [-z tz]",
@


1.24
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.23 2005/07/25 12:05:43 xsa Exp $	*/
d27 1
a27 8
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.23
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.22 2005/07/21 11:42:24 xsa Exp $	*/
d173 2
a174 2
		if ((flags & CVS_HF_A) && (cvs_sendarg(root, "-a", 0) < 0))
			return (CVS_EX_PROTO);
d176 2
a177 2
		if ((flags & CVS_HF_C) && (cvs_sendarg(root, "-c", 0) < 0))
			return (CVS_EX_PROTO);
d179 2
a180 2
		if ((flags & CVS_HF_O) && (cvs_sendarg(root, "-o", 0) < 0))
			return (CVS_EX_PROTO);
d182 14
a195 11
		if ((date != NULL) && ((cvs_sendarg(root, "-D", 0) < 0) ||
		    (cvs_sendarg(root, date, 0) < 0)))
			return (CVS_EX_PROTO);

		if ((rev != NULL) && ((cvs_sendarg(root, "-r", 0) < 0) ||
		    (cvs_sendarg(root, rev, 0) < 0)))
			return (CVS_EX_PROTO);

		if ((tag != NULL) && ((cvs_sendarg(root, "-t", 0) < 0) ||
		    (cvs_sendarg(root, tag, 0) < 0)))
			return (CVS_EX_PROTO);
d199 2
a200 4
			if ((user = getlogin()) == NULL) {
				cvs_log(LP_ERRNO, "cannot get login name");
				return (CVS_EX_DATA);
			}
d204 2
a205 3
			if ((cvs_sendarg(root, "-u", 0) < 0) ||
			    (cvs_sendarg(root, user, 0) < 0))
				return (CVS_EX_PROTO);
d208 2
a209 3
		if ((cvs_sendarg(root, "-z", 0) < 0) ||
		    (cvs_sendarg(root, zone, 0) < 0))
			return (CVS_EX_PROTO);
@


1.22
log
@<sys/param.h> is already included in "cvs.h", no need to duplicate;
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.21 2005/07/11 18:13:01 joris Exp $	*/
d40 1
a40 1
#define CVS_HISTORY_MAXMOD    16
d43 8
a50 8
#define CVS_HF_A     0x01
#define CVS_HF_C     0x02
#define CVS_HF_E     0x04
#define CVS_HF_L     0x08
#define CVS_HF_M     0x10
#define CVS_HF_O     0x20
#define CVS_HF_T     0x40
#define CVS_HF_W     0x80
d52 1
a52 1
#define CVS_HF_EXCL (CVS_HF_C|CVS_HF_E|CVS_HF_M|CVS_HF_O|CVS_HF_T|CVS_HF_X)
d54 1
a54 1
static int  cvs_history_init      (struct cvs_cmd *, int, char **, int *);
d56 1
a56 1
static void cvs_history_print     (struct cvs_hent *);
d58 1
a58 1
static int  cvs_history_pre_exec (struct cvsroot *);
@


1.21
log
@

we aren't using cvs_history_print() right now
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.20 2005/06/30 16:37:29 joris Exp $	*/
a26 1
#include <sys/param.h>
@


1.20
log
@

missing method checks in pre_exec handler.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.19 2005/06/28 14:34:56 xsa Exp $	*/
d56 1
d58 1
d218 1
d234 1
@


1.19
log
@send the date (-D) here too ..
+ some style nitpicks to be consistent w/ the rest of the code;
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.18 2005/05/31 08:58:48 xsa Exp $	*/
d171 3
a173 2
	if ((flags & CVS_HF_A) && (cvs_sendarg(root, "-a", 0) < 0))
		return (CVS_EX_PROTO);
d175 2
a176 2
	if ((flags & CVS_HF_C) && (cvs_sendarg(root, "-c", 0) < 0))
		return (CVS_EX_PROTO);
d178 2
a179 2
	if ((flags & CVS_HF_O) && (cvs_sendarg(root, "-o", 0) < 0))
		return (CVS_EX_PROTO);
d181 3
a183 3
	if ((date != NULL) && ((cvs_sendarg(root, "-D", 0) < 0) ||
	    (cvs_sendarg(root, date, 0) < 0)))
		return (CVS_EX_PROTO);
d185 2
a186 2
	if ((rev != NULL) && ((cvs_sendarg(root, "-r", 0) < 0) ||
	    (cvs_sendarg(root, rev, 0) < 0)))
d189 2
a190 2
	if ((tag != NULL) && ((cvs_sendarg(root, "-t", 0) < 0) ||
	    (cvs_sendarg(root, tag, 0) < 0)))
d193 6
a198 5
	/* if no user is specified, get login name of command issuer */
	if (!(flags & CVS_HF_A) && (user == NULL)) {
		if ((user = getlogin()) == NULL) {
			cvs_log(LP_ERRNO, "cannot get login name");
			return (CVS_EX_DATA);
d200 10
a210 8
	if (!(flags & CVS_HF_A))
		if ((cvs_sendarg(root, "-u", 0) < 0) ||
		    (cvs_sendarg(root, user, 0) < 0))
			return (CVS_EX_PROTO);

	if ((cvs_sendarg(root, "-z", 0) < 0) ||
	    (cvs_sendarg(root, zone, 0) < 0))
		return (CVS_EX_PROTO);
@


1.18
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.17 2005/05/31 08:26:40 xsa Exp $	*/
d80 1
a80 2
static char *rev = NULL;
static char *user = NULL;
a81 1
static char *tag = NULL;
d91 2
d180 6
a185 3
	if (rev != NULL) {
		if ((cvs_sendarg(root, "-r", 0) < 0) ||
		    (cvs_sendarg(root, rev, 0) < 0))
a186 1
	}
d188 2
a189 3
	if (tag != NULL) {
		if ((cvs_sendarg(root, "-t", 0) < 0) ||
		    (cvs_sendarg(root, tag, 0) < 0))
a190 1
	}
@


1.17
log
@remove LP_ERROR log priority level and rather use LP_ERR as they are both
the same...

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.16 2005/05/29 00:18:01 xsa Exp $	*/
d31 1
a32 1
#include <fcntl.h>
d34 1
a35 1
#include <string.h>
a37 1
#include "rcs.h"
@


1.16
log
@handle -r option;
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.15 2005/05/27 20:47:06 xsa Exp $	*/
d219 1
a219 1
		cvs_log(LP_ERROR, "failed to convert timestamp to structure");
@


1.15
log
@- add missing options
- correctly handle -a and -u flags

ok joris jfbeers
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.14 2005/05/24 04:12:25 jfb Exp $	*/
d81 1
d131 3
d180 6
@


1.14
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.13 2005/04/12 14:58:40 joris Exp $	*/
d66 3
a68 2
	"",
	"acelm:oTt:u:wx:z:",
d98 2
d104 2
d110 2
d124 2
d168 2
d183 8
a190 1
	if (user != NULL) {
a193 1
	}
@


1.13
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.12 2005/04/11 18:02:58 joris Exp $	*/
d56 3
a58 3
static void  cvs_history_print  (struct cvs_hent *);
int cvs_history_options(char *, int, char **, int *);
int cvs_history_sendflags(struct cvsroot *);
d62 11
a72 3
struct cvs_cmd_info cvs_history = {
	cvs_history_options,
	cvs_history_sendflags,
a75 2
	0,
	CVS_REQ_HISTORY,
d87 2
a88 2
int
cvs_history_options(char *opt, int argc, char **argv, int *arg)
d92 1
a92 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d156 2
a157 2
int
cvs_history_sendflags(struct cvsroot *root)
@


1.12
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.11 2005/04/11 17:56:27 joris Exp $	*/
d107 1
a107 1
				return (1);
d135 1
a135 1
			return (1);
d142 1
a142 1
		return (1);
d155 1
a155 1
		return (-1);
d158 1
a158 1
		return (-1);
d163 1
a163 1
			return (-1);
d169 1
a169 1
			return (-1);
d174 1
a174 1
		return (-1);
@


1.11
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.10 2005/04/03 17:32:50 xsa Exp $	*/
a35 1
#include <sysexits.h>
@


1.10
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.9 2005/03/30 17:43:04 joris Exp $	*/
d108 1
a108 1
				return (EX_USAGE);
d136 1
a136 1
			return (EX_USAGE);
d143 1
a143 1
		return (EX_USAGE);
@


1.9
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.8 2005/02/28 20:45:07 joris Exp $	*/
d156 1
a156 1
		return (EX_PROTOCOL);
d159 1
a159 1
		return (EX_PROTOCOL);
d164 1
a164 1
			return (EX_PROTOCOL);
d170 1
a170 1
			return (EX_PROTOCOL);
d175 1
a175 1
		return (EX_PROTOCOL);
@


1.8
log
@

do not forget to call cvs_connect() when we are using a remote cvs server.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.7 2005/01/31 22:04:58 jfb Exp $	*/
d58 2
a59 1

d63 18
a81 5
/*
 * cvs_history()
 *
 * Handle the `cvs history' command.
 */
d83 1
a83 1
cvs_history(int argc, char **argv)
d85 1
a85 14
	int ch, flags;
	u_int nbmod, rep;
	char *user, *zone, *tag, *cp;
	char *modules[CVS_HISTORY_MAXMOD], histpath[MAXPATHLEN];
	struct cvsroot *root;
	struct cvs_hent *hent;
	CVSHIST *hp;

	tag = NULL;
	user = NULL;
	zone = "+0000";
	nbmod = 0;
	flags = 0;
	rep = 0;
d87 1
a87 1
	while ((ch = getopt(argc, argv, "acelm:oTt:u:wx:z:")) != -1) {
a130 2
			for (cp = optarg; *cp != '\0'; cp++) {
			}
d147 3
a149 15
	root = cvsroot_get(".");
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
	if (root->cr_method == CVS_METHOD_LOCAL) {
		snprintf(histpath, sizeof(histpath), "%s/%s", root->cr_dir,
		    CVS_PATH_HISTORY);
		hp = cvs_hist_open(histpath);
		if (hp == NULL) {
			return (EX_UNAVAILABLE);
		}
d151 3
a153 10
		while ((hent = cvs_hist_getnext(hp)) != NULL) {
			cvs_history_print(hent);
		}
		cvs_hist_close(hp);
	} else {
		if (cvs_connect(root) < 0)
			return (EX_PROTOCOL);

		if ((flags & CVS_HF_C) && (cvs_sendarg(root, "-c", 0) < 0))
			return (EX_PROTOCOL);
d155 2
a156 2
		if ((flags & CVS_HF_O) && (cvs_sendarg(root, "-o", 0) < 0))
			return (EX_PROTOCOL);
d158 2
a159 10
		if (tag != NULL) {
			if ((cvs_sendarg(root, "-t", 0) < 0) ||
			    (cvs_sendarg(root, tag, 0) < 0))
				return (EX_PROTOCOL);
		}
		if (user != NULL) {
			if ((cvs_sendarg(root, "-u", 0) < 0) ||
			    (cvs_sendarg(root, user, 0) < 0))
				return (EX_PROTOCOL);
		}
d161 3
a163 2
		if ((cvs_sendarg(root, "-z", 0) < 0) ||
		    (cvs_sendarg(root, zone, 0) < 0))
d165 1
d167 3
a169 1
		if (cvs_sendreq(root, CVS_REQ_HISTORY, NULL) < 0)
d172 4
@


1.7
log
@perform error checking on all the protocol calls
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.6 2005/01/31 21:46:43 jfb Exp $	*/
d169 3
@


1.6
log
@don't crash if we have no valid CVSROOT string
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.5 2004/12/07 17:10:56 tedu Exp $	*/
d169 2
a170 2
		if (flags & CVS_HF_C)
			cvs_sendarg(root, "-c", 0);
d172 2
a173 2
		if (flags & CVS_HF_O)
			cvs_sendarg(root, "-o", 0);
d176 3
a178 2
			cvs_sendarg(root, "-t", 0);
			cvs_sendarg(root, tag, 0);
d181 3
a183 2
			cvs_sendarg(root, "-u", 0);
			cvs_sendarg(root, user, 0);
d186 3
a188 2
		cvs_sendarg(root, "-z", 0);
		cvs_sendarg(root, zone, 0);
d190 2
a191 1
		cvs_sendreq(root, CVS_REQ_HISTORY, NULL);
@


1.5
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.4 2004/12/06 21:03:12 deraadt Exp $	*/
d149 7
@


1.4
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.3 2004/07/30 01:49:23 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a67 1

@


1.3
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 2
	}
	else if (rep == 0)
d162 1
a162 2
	}
	else {
@


1.2
log
@No more cvs_root
@
text
@d41 1
d166 1
a166 1
			cvs_client_sendarg("-c", 0);
d169 1
a169 1
			cvs_client_sendarg("-o", 0);
d172 2
a173 2
			cvs_client_sendarg("-t", 0);
			cvs_client_sendarg(tag, 0);
d176 2
a177 2
			cvs_client_sendarg("-u", 0);
			cvs_client_sendarg(user, 0);
d180 2
d183 1
a183 4
		cvs_client_sendarg("-z", 0);
		cvs_client_sendarg(zone, 0);

		cvs_client_sendreq(CVS_REQ_HISTORY, NULL, 1);
@


1.1
log
@Initial revision
@
text
@a60 2
extern struct cvsroot *cvs_root;

a67 1

d75 1
d149 3
a151 2
	if (cvs_root->cr_method == CVS_METHOD_LOCAL) {
		snprintf(histpath, sizeof(histpath), "%s/%s", cvs_root->cr_dir,
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
