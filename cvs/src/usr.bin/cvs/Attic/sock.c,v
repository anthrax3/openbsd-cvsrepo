head	1.16;
access;
symbols
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2005.04.06.22.08.53;	author joris;	state dead;
branches;
next	1.15;

1.15
date	2005.03.10.22.40.04;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.10.22.37.00;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.10.22.15.03;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.22.23.17.42;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.15.20.14.49;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.15.15.17.34;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.27.20.45.18;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.09.20.43.22;	author krapht;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.24.15.51.07;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.24.14.28.07;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.17.34.10;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.17.30.10;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.25.03.31.24;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.16
log
@

remove dead and unused code

ok jfb@@
@
text
@/*	$OpenBSD: sock.c,v 1.15 2005/03/10 22:40:04 deraadt Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <poll.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#include "log.h"
#include "sock.h"
#include "cvsd.h"


char     *cvsd_sock_path;

/* daemon API */
#ifdef CVSD
int cvsd_sock = -1;
static struct sockaddr_un cvsd_sun;
#endif

/* for client API */
#ifdef CVS
static int cvs_sock = -1;
static struct sockaddr_un cvs_sun;
#endif


#ifdef CVSD
/*
 * cvsd_sock_open()
 *
 * Open the daemon's local socket.  If the server socket is already opened,
 * we close it before reopening it.
 * Returns 0 on success, -1 on failure.
 */
int
cvsd_sock_open(void)
{
	mode_t	old_umask;

	if (cvsd_sock >= 0)
		cvsd_sock_close();

	cvsd_sun.sun_family = AF_LOCAL;
	strlcpy(cvsd_sun.sun_path, cvsd_sock_path, sizeof(cvsd_sun.sun_path));

	cvsd_sock = socket(AF_LOCAL, SOCK_STREAM, 0);
	if (cvsd_sock == -1) {
		cvs_log(LP_ERRNO, "failed to open socket");
		return (-1);
	}

	old_umask = umask(S_IRWXO);
	if (bind(cvsd_sock, (struct sockaddr *)&cvsd_sun,
	    SUN_LEN(&cvsd_sun)) == -1) {
		cvs_log(LP_ERRNO, "failed to bind local socket to `%s'",
		    cvsd_sock_path);
		(void)close(cvsd_sock);
		umask(old_umask);
		return (-1);
	}
	umask(old_umask);

	(void)listen(cvsd_sock, 10);

	if (chown(cvsd_sock_path, getuid(), cvsd_gid) == -1) {
		cvs_log(LP_ERRNO, "failed to change owner of `%s'",
		    cvsd_sock_path);
		(void)close(cvsd_sock);
		(void)unlink(cvsd_sock_path);
		return (-1);
	}

	if (chmod(cvsd_sock_path, CVSD_SOCK_PERMS) == -1) {
		cvs_log(LP_ERRNO, "failed to change mode of `%s'",
		    cvsd_sock_path);
		(void)close(cvsd_sock);
		(void)unlink(cvsd_sock_path);
		return (-1);
	}

	/* close on exec so children can't muck around with this */
	(void)fcntl(cvsd_sock, F_SETFD, FD_CLOEXEC);

	cvs_log(LP_DEBUG, "opened local socket `%s'", cvsd_sock_path);

	return (0);
}


/*
 * cvsd_sock_close()
 *
 * Close the local socket.
 */
void
cvsd_sock_close(void)
{
	cvs_log(LP_DEBUG, "closing local socket `%s'", CVSD_SOCK_PATH);
	if (close(cvsd_sock) == -1) {
		cvs_log(LP_ERRNO, "failed to close local socket");
	}
	if (seteuid(0) == -1)
		cvs_log(LP_ERRNO, "failed to regain privileges");
	else if (unlink(cvsd_sock_path) == -1)
		cvs_log(LP_ERRNO, "failed to unlink local socket `%s'",
		    cvsd_sock_path);
}


/*
 * cvsd_sock_accept()
 *
 * Handler for connections made on the server's local domain socket.
 * It accepts connections and looks for a child process that is currently
 * idle to which it can dispatch the connection's descriptor.  If there are
 * no available child processes, a new one will be created unless the number
 * of children has attained the maximum.
 */
int
cvsd_sock_accept(int fd)
{
	int cfd;
	socklen_t slen;
	struct sockaddr_un sun;

	slen = sizeof(sun);
	cfd = accept(fd, (struct sockaddr *)&sun, &slen);
	if (cfd == -1) {
		cvs_log(LP_ERRNO, "failed to accept client connection");
		return (-1);
	}

	return (cfd);
}
#endif

#ifdef CVS
/*
 * cvs_sock_connect()
 *
 * Open a connection to the CVS server's local socket.
 */
int
cvs_sock_connect(const char *path)
{
	cvs_sun.sun_family = AF_LOCAL;
	strlcpy(cvs_sun.sun_path, path, sizeof(cvs_sun.sun_path));

	cvs_log(LP_INFO, "connecting to CVS server socket `%s'",
	    cvs_sun.sun_path);

	cvs_sock = socket(AF_LOCAL, SOCK_STREAM, 0);
	if (cvs_sock == -1) {
		cvs_log(LP_ERRNO, "failed to open local socket");
		return (-1);
	}

	if (connect(cvs_sock, (struct sockaddr *)&cvs_sun,
	    SUN_LEN(&cvs_sun)) == -1) {
		cvs_log(LP_ERRNO, "failed to connect to server socket `%s'",
		    cvs_sun.sun_path);
		(void)close(cvs_sock);
		return (-1);
	}

	return (0);
}


/*
 * cvs_sock_disconnect()
 *
 * Disconnect from the open socket to the CVS server.
 */
void
cvs_sock_disconnect(void)
{
	if (close(cvs_sock) == -1)
		cvs_log(LP_ERRNO, "failed to close local socket");
}
#endif
@


1.15
log
@oops, right mask
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.14 2005/03/10 22:37:00 deraadt Exp $	*/
@


1.14
log
@use right permissions
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.13 2005/03/10 22:15:03 deraadt Exp $	*/
d84 1
a84 1
	old_umask = umask(CVSD_SOCK_PERMS);
@


1.13
log
@wrap AF_UNIX bind() call in umask() handling (as well as post-chmod)
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.12 2005/02/22 23:17:42 jfb Exp $	*/
d84 1
a84 1
	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
@


1.12
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.11 2005/02/15 20:14:49 jfb Exp $	*/
d70 2
d84 1
d90 1
d93 1
@


1.11
log
@set the close-on-exec flag on the parent's local socket descriptor
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.10 2005/02/15 15:17:34 jfb Exp $	*/
a41 3


volatile sig_atomic_t  cvs_sock_doloop;
@


1.10
log
@avoid crashing when setting a variable with cvsd_set() that was not
initialized with a dynamically-allocated string.

spotted by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.9 2005/01/27 20:45:18 jfb Exp $	*/
d32 1
a32 1
#include <stdlib.h>
d34 1
a35 1
#include <errno.h>
d37 1
d110 3
@


1.9
log
@get rid of event.h, it won't be used
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.8 2004/12/07 17:10:56 tedu Exp $	*/
d46 1
a46 1
char     *cvsd_sock_path = CVSD_SOCK_PATH;
@


1.8
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.7 2004/11/09 20:43:22 krapht Exp $	*/
a40 1
#include "event.h"
@


1.7
log
@cvsd_sock_accept() must return the descriptor, not 0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a48 2


a69 1

d81 1
a81 1
		cvs_log(LP_ERRNO, "failed to open socket"); 
a121 1

a145 1

a169 1

a201 1

@


1.6
log
@Before attempting to unlink() the local socket, set the effective
UID to 0 so we have the appropriate permissions to perform the
operation
@
text
@d165 1
a165 1
	return (0);
@


1.5
log
@When creating the local socket, set the group to the server's group ID
@
text
@d133 3
a135 1
	if (unlink(cvsd_sock_path) == -1)
@


1.4
log
@* wrap more code between program-dependent ifdef's and fix a bug while
  we're at it
@
text
@d96 9
a104 1
	listen(cvsd_sock, 10);
@


1.3
log
@* add the appropriate preprocessor wrappers to compile only the code
  required for each program
* make cvs_sock_connect() take a full path to the socket
@
text
@d52 1
d55 1
d58 1
d61 1
d76 1
a76 1
	if (cvs_sock >= 0)
@


1.2
log
@* when calling cvsd_sock_open(), close the socket if it is already
  opened, before reopening it
* remove the cvsd_sock_loop() call, it was a bad idea
@
text
@d60 1
d153 1
d155 1
a155 1

d163 1
a163 1
cvs_sock_connect(const char *cvsroot)
d166 1
a166 2
	snprintf(cvs_sun.sun_path, sizeof(cvs_sun.sun_path), "%s/%s",
	    cvsroot, CVSD_SOCK_PATH);
d201 1
@


1.1
log
@Initial revision
@
text
@d52 1
a52 1
static int cvsd_sock = -1;
d63 3
a65 1
 * Open the daemon's local socket.
d71 3
d122 1
a122 1
		    CVSD_SOCK_PATH);
d127 1
a127 1
 * cvsd_sock_loop()
d129 5
d136 2
a137 2
void
cvsd_sock_loop(void)
d139 1
a139 1
	int nfds, sock;
a141 50
	struct pollfd pfd[1];

	cvs_sock_doloop = 1;

	while (cvs_sock_doloop) {
		pfd[0].fd = cvsd_sock;
		pfd[0].events = POLLIN;

		nfds = poll(pfd, 1, INFTIM);
		if (nfds == -1) {
			if (errno == EINTR)
				continue;
			cvs_log(LP_ERR, "failed to poll local socket");
		}

		if ((nfds == 0) || !(pfd[0].revents & POLLIN))
			continue;

		sock = accept(pfd[0].fd, (struct sockaddr *)&sun, &slen);
		if (sock == -1) {
			cvs_log(LP_ERRNO, "failed to accept connection");
		}
		cvs_log(LP_DEBUG, "accepted connection");

		cvsd_sock_hdl(sock);
	}


}


/*
 * cvsd_sock_hdl()
 *
 * Handle the events for a single connection.
 */

int
cvsd_sock_hdl(int fd)
{
	uid_t uid;
	gid_t gid;
	struct cvs_event ev;

	/* don't trust what the other end put in */
	if (getpeereid(fd, &uid, &gid) == -1) {
		cvs_log(LP_ERR, "failed to get peer credentials");
		(void)close(fd);
		return (-1);
	}
d143 4
a146 2
	if (read(fd, &ev, sizeof(ev)) == -1) {
		cvs_log(LP_ERR, "failed to read cvs event");
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
