head	1.20;
access;
symbols
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2005.04.06.22.08.53;	author joris;	state dead;
branches;
next	1.19;

1.19
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.22.22.33.01;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.15.15.17.34;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.14.19.53.12;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.09.22.07.40;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.28.15.12.17;	author pat;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.25.18.30.12;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.27.13.42.39;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.27.12.39.29;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.27.12.16.05;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.25.12.21.43;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.24.12.19.21;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.06.20.09.22;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.15.59.38;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.25.03.29.35;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.16.01.46.16;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.20
log
@

remove dead and unused code

ok jfb@@
@
text
@/*	$OpenBSD: cvsd.c,v 1.19 2005/04/03 17:32:50 xsa Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/uio.h>

#include <err.h>
#include <pwd.h>
#include <grp.h>
#include <poll.h>
#include <fcntl.h>
#include <dirent.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <sysexits.h>

#include "log.h"
#include "sock.h"
#include "cvs.h"
#include "repo.h"
#include "cvsd.h"


static void  cvsd_parent_loop (void);
static void  cvsd_report      (void);


extern char *__progname;


int    cvsd_fg = 0;
uid_t  cvsd_uid = 0;
gid_t  cvsd_gid = 0;

volatile sig_atomic_t cvsd_running = 1;
volatile sig_atomic_t cvsd_restart = 0;

static char  *cvsd_user = NULL;
static char  *cvsd_group = NULL;
static char  *cvsd_root = NULL;
static char  *cvsd_conffile = CVSD_PATH_CONF;
static char  *cvsd_moddir = NULL;
static int    cvsd_privfd = -1;

static CVSREPO *cvsd_repo;


static TAILQ_HEAD(,cvsd_child) cvsd_children;
static volatile sig_atomic_t   cvsd_chnum = 0;
static volatile sig_atomic_t   cvsd_chmax = CVSD_CHILD_DEFMAX;
static volatile sig_atomic_t   cvsd_sigchld = 0;
static volatile sig_atomic_t   cvsd_siginfo = 0;


void   usage	 (void);
void   cvsd_sighdlr  (int);
int    cvsd_msghdlr  (struct cvsd_child *, int);


/*
 * cvsd_sighdlr()
 *
 * Generic signal handler.
 */
void
cvsd_sighdlr(int signo)
{
	switch (signo) {
	case SIGHUP:
		cvsd_restart = 1;
		break;
	case SIGCHLD:
		cvsd_sigchld = 1;
		break;
	case SIGINT:
	case SIGTERM:
	case SIGQUIT:
		cvsd_running = 0;
		break;
	case SIGINFO:
		cvsd_siginfo = 1;
		break;
	}
}


/*
 * usage()
 *
 * Display program usage.
 */
void
usage(void)
{
	fprintf(stderr,
	    "Usage: %s [-dfhpv] [-c config] [-g group] [-r root] "
	    "[-s path] [-u user]\n"
	    "\t-c config\tUse <config> as the configuration file\n"
	    "\t-d\t\tStart the server in debugging mode (very verbose)\n"
	    "\t-f\t\tStay in foreground instead of becoming a daemon\n"
	    "\t-g group\tUse group <group> for privilege revocation\n"
	    "\t-h\t\tPrint the usage and exit\n"
	    "\t-p\t\tPerform repository sanity check on startup\n"
	    "\t-r root\t\tUse <root> as the root directory of the repository\n"
	    "\t-s path\t\tUse <path> as the path for the CVS server socket\n"
	    "\t-u user\t\tUse user <user> for privilege revocation\n"
	    "\t-v\t\tBe verbose\n",
	    __progname);
}


int
main(int argc, char **argv)
{
	int ret, repo_flags;
	struct passwd *pwd;
	struct group *grp;

	repo_flags = 0;
	cvsd_set(CVSD_SET_SOCK, CVSD_SOCK_PATH);
	cvsd_set(CVSD_SET_USER, CVSD_USER);
	cvsd_set(CVSD_SET_GROUP, CVSD_GROUP);

	if (cvs_log_init(LD_STD|LD_SYSLOG, LF_PID) < 0)
		err(1, "failed to initialize logging mechanism");

	while ((ret = getopt(argc, argv, "c:dfg:hpr:s:u:v")) != -1) {
		switch (ret) {
		case 'c':
			cvsd_conffile = optarg;
			break;
		case 'd':
			cvs_log_filter(LP_FILTER_UNSET, LP_DEBUG);
			cvs_log_filter(LP_FILTER_UNSET, LP_INFO);
			break;
		case 'f':
			cvsd_fg = 1;
			break;
		case 'g':
			cvsd_set(CVSD_SET_GROUP, optarg);
			break;
		case 'h':
			usage();
			exit(0);
			/* NOTREACHED */
			break;
		case 'p':
			repo_flags |= CVS_REPO_CHKPERM;
			break;
		case 'r':
			cvsd_set(CVSD_SET_ROOT, optarg);
			break;
		case 's':
			cvsd_set(CVSD_SET_SOCK, optarg);
			break;
		case 'u':
			cvsd_set(CVSD_SET_USER, optarg);
			break;
		case 'v':
			cvs_log_filter(LP_FILTER_UNSET, LP_INFO);
			break;
		default:
			usage();
			exit(EX_USAGE);
		}
	}

	argc -= optind;
	argv += optind;

	if (cvs_conf_read(cvsd_conffile) < 0)
		errx(1, "error parsing configuration file `%s'", cvsd_conffile);

	if (cvsd_root == NULL)
		errx(1, "no CVS root directory specified");

	if (argc > 0)
		errx(EX_USAGE, "unrecognized trailing arguments");

	TAILQ_INIT(&cvsd_children);

	pwd = getpwnam(cvsd_user);
	if (pwd == NULL)
		err(1, "failed to get user `%s'", cvsd_user);

	grp = getgrnam(cvsd_group);
	if (grp == NULL)
		err(1, "failed to get group `%s'", cvsd_group);

	endpwent();
	endgrent();

	cvsd_uid = pwd->pw_uid;
	cvsd_gid = grp->gr_gid;

	signal(SIGHUP, cvsd_sighdlr);
	signal(SIGINT, cvsd_sighdlr);
	signal(SIGQUIT, cvsd_sighdlr);
	signal(SIGTERM, cvsd_sighdlr);
	signal(SIGCHLD, cvsd_sighdlr);
	signal(SIGPIPE, SIG_IGN);

	if (!cvsd_fg && daemon(0, 0) == -1) {
		cvs_log(LP_ERRNO, "failed to become a daemon");
		exit(1);
	}

	if ((cvsd_repo = cvs_repo_load(cvsd_root, repo_flags)) == NULL) {
		cvs_log(LP_ERR, "failed to load repository");
		exit(1);
	};

	if (cvsd_sock_open() < 0) {
		exit(1);
	}

	if (setegid(cvsd_gid) == -1) {
		cvs_log(LP_ERRNO, "failed to drop group privileges");
		exit(1);
	}
	if (seteuid(cvsd_uid) == -1) {
		cvs_log(LP_ERRNO, "failed to drop user privileges");
		exit(1);
	}

	signal(SIGINFO, cvsd_sighdlr);
	cvsd_parent_loop();

	cvsd_sock_close();

	cvs_repo_free(cvsd_repo);

	cvs_log(LP_NOTICE, "shutting down");
	cvs_log_cleanup();
	return (0);
}


/*
 * cvsd_child_fork()
 *
 * Fork a child process which chroots to the CVS repository's root directory,
 * drops all privileges, and then executes the cvsd-child process, which will
 * handle the incoming CVS requests.
 * On success, returns a pointer to the new child structure,
 * or NULL on failure.
 */
struct cvsd_child*
cvsd_child_fork(int sock)
{
	int argc, svec[2];
	pid_t pid;
	char *argv[16], ubuf[8], gbuf[8];
	struct cvsd_child *chp;

	if (cvsd_chnum == cvsd_chmax) {
		cvs_log(LP_WARN, "child pool reached limit of processes");
		return (NULL);
	}

	if (socketpair(AF_LOCAL, SOCK_STREAM, PF_UNSPEC, svec) == -1) {
		cvs_log(LP_ERRNO, "failed to create socket pair");
		return (NULL);
	}

	/*
	 * We need to temporarily regain original privileges in order for the
	 * child to chroot().
	 */
	if (seteuid(0) == -1) {
		cvs_log(LP_ERRNO, "failed to regain privileges");
		return (NULL);
	}

	pid = fork();
	if (pid == -1) {
		cvs_log(LP_ERRNO, "failed to fork child");
		(void)close(svec[0]);
		(void)close(svec[1]);
		return (NULL);
	}

	if (pid == 0) {
		cvsd_privfd = svec[1];
		(void)close(svec[0]);

		/*
		 * Move the accepted socket to descriptor 3, where the child
		 * expects it to be.  This could become troublesome if the
		 * descriptor is already taken, but then again, the child
		 * shouldn't have access to other descriptors except the
		 * connection and its side of the socket pair it shares with
		 * the parent.
		 */
		if (dup2(sock, CVSD_CHILD_SOCKFD) == -1) {
			cvs_log(LP_ERRNO, "failed to dup child socket");
			exit(1);
		}
		(void)close(sock);

		argc = 0;
		argv[argc++] = CVSD_PATH_CHILD;
		argv[argc++] = "-r";
		argv[argc++] = cvsd_root;
		if (cvsd_uid != 0) {
			snprintf(ubuf, sizeof(ubuf), "%d", cvsd_uid);
			argv[argc++] = "-u";
			argv[argc++] = ubuf;
		}
		if (cvsd_gid != 0) {
			snprintf(gbuf, sizeof(gbuf), "%d", cvsd_gid);
			argv[argc++] = "-g";
			argv[argc++] = gbuf;
		}
		argv[argc] = NULL;

		execv(CVSD_PATH_CHILD, argv);
		err(1, "FUCK");
		exit(1);
	}

	cvs_log(LP_INFO, "spawning child %d", pid);

	(void)close(svec[1]);

	if (seteuid(cvsd_uid) == -1)
		cvs_log(LP_ERRNO, "failed to redrop privs");

	chp = (struct cvsd_child *)malloc(sizeof(*chp));
	if (chp == NULL) {
		/* XXX kill child */
		cvs_log(LP_ERRNO, "failed to allocate child data");
		return (NULL);
	}

	chp->ch_pid = pid;
	chp->ch_sock = svec[0];
	chp->ch_state = CVSD_ST_IDLE;

	TAILQ_INSERT_TAIL(&cvsd_children, chp, ch_list);
	cvsd_chnum++;

	return (chp);
}


/*
 * cvsd_child_reap()
 *
 * Wait for a child's status and perform the proper actions depending on it.
 * If the child has exited or has been terminated by a signal, it will be
 * removed from the list.
 * Returns 0 on success, or -1 on failure.
 */
int
cvsd_child_reap(void)
{
	pid_t pid;
	int status;
	struct cvsd_child *ch;

	pid = wait(&status);
	if (pid == -1) {
		cvs_log(LP_ERRNO, "failed to wait for child");
		return (-1);
	}

	TAILQ_FOREACH(ch, &cvsd_children, ch_list) {
		if (ch->ch_pid == pid) {
			if (WIFEXITED(status)) {
				cvs_log(LP_WARN,
				    "child %d exited with status %d",
				    pid, WEXITSTATUS(status));
			} else if (WIFSIGNALED(status)) {
				cvs_log(LP_WARN,
				    "child %d terminated with signal %d",
				    pid, WTERMSIG(status));
			} else {
				cvs_log(LP_ERR, "HOLY SHIT!");
			}

			signal(SIGCHLD, SIG_IGN);
			TAILQ_REMOVE(&cvsd_children, ch, ch_list);
			cvsd_chnum--;
			signal(SIGCHLD, cvsd_sighdlr);

			break;
		}
	}

	return (0);
}


/*
 * cvsd_parent_loop()
 *
 * Main loop of the parent cvsd process, which listens on its end of the
 * local socket for requests from the cvs(1) program and on any outstanding
 * messages from the children.
 */
static void
cvsd_parent_loop(void)
{
	int cfd, timeout, ret;
	nfds_t nfds, i;
	struct pollfd *pfd;
	struct cvsd_child *chp;

	nfds = 0;
	timeout = INFTIM;
	pfd = NULL;

	for (;;) {
		if (!cvsd_running)
			break;

		if (cvsd_restart) {
			/* restart server */
		}

		if (cvsd_sigchld) {
			cvsd_sigchld = 0;
			cvsd_child_reap();
		}
		if (cvsd_siginfo) {
			cvsd_siginfo = 0;
			cvsd_report();
		}

		nfds = cvsd_chnum + 1;
		pfd = (struct pollfd *)realloc(pfd,
		    nfds * sizeof(struct pollfd));
		if (pfd == NULL) {
			cvs_log(LP_ERRNO, "failed to reallocate polling data");
			return;
		}

		pfd[0].fd = cvsd_sock;
		pfd[0].events = POLLIN;
		pfd[0].revents = 0;
		i = 1;
		TAILQ_FOREACH(chp, &cvsd_children, ch_list) {
			pfd[i].fd = chp->ch_sock;
			pfd[i].events = POLLIN;
			pfd[i].revents = 0;
			i++;

			if (i == nfds)   /* just a precaution */
				break;
		}

		ret = poll(pfd, nfds, timeout);
		if (ret == -1) {
			if (errno == EINTR)
				continue;
			cvs_log(LP_ERRNO, "poll error");
			break;
		}

		if (pfd[0].revents & (POLLERR|POLLNVAL)) {
			cvs_log(LP_ERR, "poll error on request socket");
		} else if (pfd[0].revents & POLLIN) {
			uid_t uid;
			gid_t gid;

			if ((cfd = cvsd_sock_accept(pfd[0].fd)) == -1)
				continue;

			if ((chp = cvsd_child_fork(cfd)) == NULL) {
				cvs_log(LP_ALERT,
				    "request queue not implemented");
				break;
			}

			if (getpeereid(cfd, &uid, &gid) < 0)
				err(1, "failed to get UID");
			if (cvsd_sendmsg(chp->ch_sock, CVSD_MSG_PASSFD,
			    &cfd, sizeof(cfd)) < 0)
				break;

			/* mark the child as busy */
			chp->ch_state = CVSD_ST_BUSY;
		}

		chp = TAILQ_FIRST(&cvsd_children);
		for (i = 1; i < nfds; i++) {
			if (pfd[i].revents & (POLLERR|POLLNVAL)) {
				cvs_log(LP_ERR,
				    "poll error on child socket (PID %d)",
				    chp->ch_pid);
			} else if (pfd[i].revents & POLLIN)
				cvsd_msghdlr(chp, pfd[i].fd);

			chp = TAILQ_NEXT(chp, ch_list);
		}

	}

	/* broadcast a shutdown message to children */
	TAILQ_FOREACH(chp, &cvsd_children, ch_list) {
		(void)cvsd_sendmsg(chp->ch_sock, CVSD_MSG_SHUTDOWN, NULL, 0);
	}
}


/*
 * cvsd_msghdlr()
 *
 * Handler for messages received from child processes.
 * Returns 0 on success, or -1 on failure.
 */
int
cvsd_msghdlr(struct cvsd_child *child, int fd)
{
	uid_t uid;
	ssize_t ret;
	char rbuf[CVSD_MSG_MAXLEN];
	struct group *gr;
	struct passwd *pw;
	struct iovec iov[2];
	struct cvsd_msg msg;

	ret = read(fd, &msg, sizeof(msg));
	if (ret == -1) {
		cvs_log(LP_ERRNO, "failed to read CVS message");
		return (-1);
	} else if (ret == 0) {
		cvs_log(LP_WARN, "child closed socket pair");
		return (0);
	}

	if (msg.cm_len > 0) {
		ret = read(fd, rbuf, msg.cm_len);
		if (ret != (ssize_t)msg.cm_len) {
			cvs_log(LP_ERR, "failed to read entire msg");
			return (-1);
		}
	}

	/* setup the I/O vector for the reply */
	iov[0].iov_base = &msg;
	iov[0].iov_len = sizeof(msg);

	msg.cm_type = CVSD_MSG_ERROR;
	msg.cm_len = 0;

	switch (msg.cm_type) {
	case CVSD_MSG_GETUID:
		rbuf[ret] = '\0';
		cvs_log(LP_INFO, "getting UID for `%s'", rbuf);

		pw = getpwnam(rbuf);
		if (pw != NULL) {
			msg.cm_type = CVSD_MSG_UID;
			msg.cm_len = sizeof(uid_t);
			iov[1].iov_len = msg.cm_len;
			iov[1].iov_base = &(pw->pw_uid);
		}
		break;
	case CVSD_MSG_GETUNAME:
		memcpy(&uid, rbuf, sizeof(uid));
		cvs_log(LP_INFO, "getting username for UID %u", uid);
		pw = getpwuid(uid);
		if (pw != NULL) {
			msg.cm_type = CVSD_MSG_UNAME;
			msg.cm_len = strlen(pw->pw_name);
			iov[1].iov_len = msg.cm_len;
			iov[1].iov_base = pw->pw_name;
		}
		break;
	case CVSD_MSG_GETGID:
		rbuf[ret] = '\0';
		cvs_log(LP_INFO, "getting GID for `%s'", rbuf);

		gr = getgrnam(rbuf);
		if (gr != NULL) {
			msg.cm_type = CVSD_MSG_GID;
			msg.cm_len = sizeof(gid_t);
			iov[1].iov_len = msg.cm_len;
			iov[1].iov_base = &(gr->gr_gid);
		}
		break;
	case CVSD_MSG_SETIDLE:
		child->ch_state = CVSD_ST_IDLE;
		break;
	default:
		cvs_log(LP_ERR, "unknown command type %u", msg.cm_type);
		return (-1);
	}

	ret = writev(fd, iov, 2);

	return (ret);
}


/*
 * cvsd_set()
 *
 * Generic interface to set some of the parameters of the cvs server.
 * When a string is set using cvsd_set(), the original string is copied into
 * a new buffer.
 * Returns 0 on success, or -1 on failure.
 */
int
cvsd_set(int what, ...)
{
	char *str;
	int error = 0;
	va_list vap;

	str = NULL;

	va_start(vap, what);

	if ((what == CVSD_SET_ROOT) || (what == CVSD_SET_SOCK) ||
	    (what == CVSD_SET_USER) || (what == CVSD_SET_GROUP) ||
	    (what == CVSD_SET_MODDIR)) {
		str = strdup(va_arg(vap, char *));
		if (str == NULL) {
			cvs_log(LP_ERRNO, "failed to set string");
			va_end(vap);
			return (-1);
		}
	}

	switch (what) {
	case CVSD_SET_ROOT:
		if (cvsd_root != NULL)
			free(cvsd_root);
		cvsd_root = str;
		break;
	case CVSD_SET_SOCK:
		if (cvsd_sock_path != NULL)
			free(cvsd_sock_path);
		cvsd_sock_path = str;
		break;
	case CVSD_SET_USER:
		if (cvsd_user != NULL)
			free(cvsd_user);
		cvsd_user = str;
		break;
	case CVSD_SET_GROUP:
		if (cvsd_group != NULL)
			free(cvsd_group);
		cvsd_group = str;
		break;
	case CVSD_SET_MODDIR:
		if (cvsd_moddir != NULL)
			free(cvsd_moddir);
		cvsd_moddir = str;
		break;
	case CVSD_SET_CHMAX:
		cvsd_chmax = va_arg(vap, int);
		/* we should decrease the number of children accordingly */
		break;
	case CVSD_SET_ADDR:
		/* this is more like an add than a set */
		break;
	default:
		cvs_log(LP_ERR, "invalid field to set");
		error = -1;
		break;
	}

	va_end(vap);

	return (error);
}


/*
 * cvsd_report()
 *
 * Report about the current state of child processes on the repository.
 */
static void
cvsd_report(void)
{
	u_int nb_idle, nb_busy, nb_unknown;
	struct cvsd_child *ch;

	nb_idle = 0;
	nb_busy = 0;
	nb_unknown = 0;

	signal(SIGCHLD, SIG_IGN);
	TAILQ_FOREACH(ch, &cvsd_children, ch_list) {
		if (ch->ch_state == CVSD_ST_IDLE)
			nb_idle++;
		else if (ch->ch_state == CVSD_ST_BUSY)
			nb_busy++;
		else if (ch->ch_state == CVSD_ST_UNKNOWN)
			nb_unknown++;
	}

	cvs_log(LP_WARN, "%u children, %u idle, %u busy, %u unknown",
	    cvsd_chnum, nb_idle, nb_busy, nb_unknown);

	TAILQ_FOREACH(ch, &cvsd_children, ch_list)
		cvs_log(LP_WARN, "");
	signal(SIGCHLD, cvsd_sighdlr);
}
@


1.19
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.c,v 1.18 2005/02/22 22:33:01 jfb Exp $	*/
@


1.18
log
@Split the cvs daemon into two different processes: cvsd and cvsd-child.
The cvsd process only takes care of managing children and repository
locks, while the child handles all requests made to access or modify
the contents of the repository.
This will allow us to take advantage of randomized library remapping
and new propolice cookies, and minimizes the amount of code that can
run with elevated privileges.  Still work in progress.

suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.c,v 1.17 2005/02/15 15:17:34 jfb Exp $	*/
d213 1
a213 1
		err(EX_NOUSER, "failed to get user `%s'", cvsd_user);
d217 1
a217 1
		err(EX_NOUSER, "failed to get group `%s'", cvsd_group);
d234 1
a234 1
		exit(EX_OSERR);
d239 1
a239 1
		exit(EX_OSERR);
d248 1
a248 1
		exit(EX_OSERR);
d252 1
a252 1
		exit(EX_OSERR);
d326 1
a326 1
			exit(EX_OSERR);
d348 1
a348 1
		exit(EX_OSERR);
@


1.17
log
@avoid crashing when setting a variable with cvsd_set() that was not
initialized with a dynamically-allocated string.

spotted by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.c,v 1.16 2004/12/14 19:53:12 xsa Exp $	*/
d49 1
a53 2
static void  cvsd_child_main  (void);
static int   cvsd_privdrop    (void);
d61 2
a62 2
uid_t  cvsd_uid = -1;
gid_t  cvsd_gid = -1;
d70 1
a70 1
static char  *cvsd_conffile = CVSD_CONF;
d74 2
a78 1
static volatile sig_atomic_t   cvsd_chmin = CVSD_CHILD_DEFMIN;
d84 1
a84 1
void   usage         (void);
d144 1
a144 2
	u_int i;
	int ret, checkrepo;
d148 1
a148 1
	checkrepo = 0;
d156 1
a156 1
	while ((ret = getopt(argc, argv, "a:c:dfhpr:s:v")) != -1) {
d177 1
a177 1
			checkrepo = 1;
d219 3
d237 5
a254 11
	if (checkrepo && cvsd_checkperms("/") != 0) {
		cvs_log(LP_ERR,
		    "exiting due to permission errors on repository");
		exit(1);
	}

	/* spawn the initial pool of children */
	for (i = 0; i < (u_int)cvsd_chmin; i++)
		if (cvsd_child_fork(NULL) < 0)
			exit(EX_OSERR);

a257 3
	cvs_log(LP_NOTICE, "shutting down");
	cvs_log_cleanup();

d260 1
a260 25
	return (0);
}


/*
 * cvsd_privdrop()
 *
 * Drop privileges.
 */
int
cvsd_privdrop(void)
{
	cvs_log(LP_INFO, "dropping privileges to %s[%d]:%s[%d]",
	    cvsd_user, cvsd_uid, cvsd_group, cvsd_gid);
	if (setgid(cvsd_gid) == -1) {
		cvs_log(LP_ERRNO, "failed to drop group privileges to %s",
		    CVSD_GROUP);
		return (-1);
	}

	if (setuid(cvsd_uid) == -1) {
		cvs_log(LP_ERRNO, "failed to drop user privileges to %s",
		    CVSD_USER);
		return (-1);
	}
d262 2
a268 103
 * cvsd_checkperms()
 *
 * Check permissions on the CVS repository and log warnings for any
 * weird of loose permissions.
 * Returns the number of warnings on success, or -1 on failure.
 */
int
cvsd_checkperms(const char *path)
{
	int fd, nbwarn, ret;
	mode_t fmode;
	long base;
	u_char *dp, *endp;
	char buf[1024], spath[MAXPATHLEN];
	struct stat st;
	struct dirent *dep;

	nbwarn = 0;

	cvs_log(LP_DEBUG, "checking permissions on `%s'", path);

	if (stat(path, &st) == -1) {
		cvs_log(LP_ERRNO, "failed to stat `%s'", path);
		return (-1);
	}

	if (S_ISDIR(st.st_mode))
		fmode = CVSD_DPERM;
	else
		fmode = CVSD_FPERM;

	if (st.st_uid != cvsd_uid) {
		cvs_log(LP_WARN, "owner of `%s' is not %s", path, CVSD_USER);
		nbwarn++;
	}

	if (st.st_gid != cvsd_gid) {
		cvs_log(LP_WARN, "group of `%s' is not %s", path, CVSD_GROUP);
		nbwarn++;
	}

	if (st.st_mode & S_IWGRP) {
		cvs_log(LP_WARN, "file `%s' is group-writable", path,
		    fmode);
		nbwarn++;
	}

	if (st.st_mode & S_IWOTH) {
		cvs_log(LP_WARN, "file `%s' is world-writable", path,
		    fmode);
		nbwarn++;
	}

	if (S_ISDIR(st.st_mode)) {
		fd = open(path, O_RDONLY, 0);
		if (fd == -1) {
			cvs_log(LP_ERRNO, "failed to open directory `%s'",
			    path);
			return (nbwarn);
		}
		/* recurse */
		ret = getdirentries(fd, buf, sizeof(buf), &base);
		if (ret == -1) {
			cvs_log(LP_ERRNO,
			    "failed to get directory entries for `%s'", path);
			(void)close(fd);
			return (nbwarn);
		}

		dp = buf;
		endp = buf + ret;

		while (dp < endp) {
			dep = (struct dirent *)dp;
			dp += dep->d_reclen;

			if ((dep->d_namlen == 1) && (dep->d_name[0] == '.'))
				continue;
			if ((dep->d_namlen == 2) && (dep->d_name[0] == '.') &&
			    (dep->d_name[1] == '.'))
				continue;

			/* skip the CVSROOT directory */
			if (strcmp(dep->d_name, CVS_PATH_ROOT) == 0)
				continue;

			snprintf(spath, sizeof(spath), "%s/%s", path,
			    dep->d_name);
			ret = cvsd_checkperms(spath);
			if (ret == -1)
				nbwarn++;
			else
				nbwarn += ret;
		}
		(void)close(fd);
	}


	return (nbwarn);
}


/*
d271 5
a275 5
 * Fork a child process which chroots to the CVS repository's root directory.
 * If the <chpp> argument is not NULL, a reference to the newly created child
 * structure will be returned.
 * On success, returns 0 in the child process context, 1 in the parent's
 * context, or -1 on failure.
d277 2
a278 2
int
cvsd_child_fork(struct cvsd_child **chpp)
d280 1
a280 1
	int svec[2];
d282 1
d287 1
a287 1
		return (-1);
d292 1
a292 1
		return (-1);
d301 1
a301 1
		return (-1);
d309 1
a309 1
		return (-1);
d316 33
a348 2
		cvsd_child_main();
		/* NOTREACHED */
d353 3
a355 1
	if (seteuid(cvsd_uid) == -1) {
a356 2
		return (-1);
	}
d360 1
d362 1
a362 1
		return (-1);
a368 1
	signal(SIGCHLD, SIG_IGN);
a370 1
	signal(SIGCHLD, cvsd_sighdlr);
d372 1
a372 4
	if (chpp != NULL)
		*chpp = chp;
	(void)close(svec[1]);
	return (1);
d381 1
a381 2
 * removed from the list and new children will be created until the pool has
 * at least <cvsd_chmin> children in it.
a419 3
	while (cvsd_chnum < cvsd_chmin)
		cvsd_child_fork(NULL);

a424 27
 * cvsd_child_get()
 *
 * Find a child process in idle state and return a pointer to the child's
 * structure.  If there are no available child processes, a new one will be
 * created unless the number of children has attained the maximum, in which
 * case NULL is returned.
 */
struct cvsd_child*
cvsd_child_get(void)
{
	struct cvsd_child *chp;

	TAILQ_FOREACH(chp, &cvsd_children, ch_list)
		if (chp->ch_state == CVSD_ST_IDLE)
			return (chp);

	/* no available child, attempt to fork a new one */
	chp = NULL;
	if ((cvsd_chnum < cvsd_chmax) && (cvsd_child_fork(&chp) < 0))
		return (NULL);

	return (chp);
}



/*
d496 4
a499 4
			cfd = cvsd_sock_accept(pfd[0].fd);
			if (cfd == -1)
			chp = cvsd_child_get();
			if (chp == NULL) {
a536 72
 * cvsd_child_main()
 *
 */
static void
cvsd_child_main(void)
{
	int ret, timeout;
	u_int mtype;
	size_t mlen;
	char mbuf[CVSD_MSG_MAXLEN];
	struct pollfd pfd[1];
	struct cvsd_sess *sessp;

	cvs_log(LP_INFO, "changing root to %s", cvsd_root);
	if (chroot(cvsd_root) == -1) {
		cvs_log(LP_ERRNO, "failed to chroot to `%s'", cvsd_root);
		exit(EX_OSERR);
	}
	(void)chdir("/");

	if (cvsd_privdrop() < 0)
		exit(EX_OSERR);

	setproctitle("%s [child %d]", __progname, getpid());

	pfd[0].fd = cvsd_privfd;
	pfd[0].events = POLLIN;
	timeout = INFTIM;
	sessp = NULL;

	while (cvsd_running) {
		ret = poll(pfd, 1, timeout);
		if (ret == -1) {
			if (errno == EINTR)
				continue;
			cvs_log(LP_ERRNO, "poll error");
			break;
		} else if (ret == 0)
			continue;

		if (pfd[0].revents & (POLLERR|POLLNVAL)) {
			cvs_log(LP_ERR, "poll error");
			break;
		}

		mlen = sizeof(mbuf);
		ret = cvsd_recvmsg(pfd[0].fd, &mtype, mbuf, &mlen);
		if (ret == -1) {
			continue;
		} else if (ret == 0)
			break;

		switch (mtype) {
		case CVSD_MSG_PASSFD:
			sessp = cvsd_sess_alloc(*(int *)mbuf);
			break;
		case CVSD_MSG_SHUTDOWN:
			cvsd_running = 0;
			break;
		default:
			cvs_log(LP_ERR,
			    "unexpected message type %u from parent", mtype);
			break;
		}

	}

	exit(0);
}


/*
a682 4
	case CVSD_SET_CHMIN:
		cvsd_chmin = va_arg(vap, int);
		/* we should increase the number of children accordingly */
		break;
d704 2
@


1.16
log
@add missing '\t' in usage(); okay jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.c,v 1.15 2004/12/09 22:07:40 xsa Exp $	*/
d150 1
d181 1
a181 1
			cvsd_root = optarg;
d184 1
a184 1
			cvsd_sock_path = optarg;
a873 1
		error = cvsd_sock_open();
@


1.15
log
@fix pointer of type `void *' used in arithmetic warning; ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.c,v 1.14 2004/12/07 17:10:56 tedu Exp $	*/
d135 1
a135 1
	    "\t-u user\tUse user <user> for privilege revocation\n"
@


1.14
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.c,v 1.13 2004/12/06 21:03:12 deraadt Exp $	*/
d309 1
a309 1
	void *dp, *endp;
@


1.13
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.c,v 1.12 2004/11/28 15:12:17 pat Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a60 1

a93 1

a120 1

a274 1

a302 1

a407 1

a487 1

a538 1

a564 1

a673 1

a747 1

d786 1
a786 1
		cvs_log(LP_INFO, "getting UID for `%s'", rbuf); 
d798 1
a798 1
		cvs_log(LP_INFO, "getting username for UID %u", uid); 
d809 1
a809 1
		cvs_log(LP_INFO, "getting GID for `%s'", rbuf); 
a840 1

a915 1

@


1.12
log
@make sure va_end() is always called in all possible paths

ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d514 1
a514 2
			}
			else if (WIFSIGNALED(status)) {
d518 1
a518 2
			}
			else {
d635 1
a635 2
		}
		else if (pfd[0].revents & POLLIN) {
d638 1
d664 1
a664 2
			}
			else if (pfd[i].revents & POLLIN)
d718 1
a718 2
		}
		else if (ret == 0)
d730 1
a730 2
		}
		else if (ret == 0)
d774 1
a774 2
	}
	else if (ret == 0) {
@


1.11
log
@Handle CVSD_SET_MODDIR, add session allocation and some minor cleanup
@
text
@d863 1
d876 1
d891 1
a891 2
		if (cvsd_sock_open() < 0)
			return (-1);
d921 2
a922 1
		return (-1);
d927 1
a927 1
	return (0);
@


1.10
log
@Rename some variables to match the general format, and avoid exporting
variables that aren't needed
@
text
@d53 1
a53 1
static void  cvsd_child_loop  (void);
d62 3
a64 1
int cvsd_fg = 0;
a68 4

uid_t  cvsd_uid = -1;
gid_t  cvsd_gid = -1;

d73 1
a76 1

d230 1
d257 2
a258 4
	for (i = 0; i < (u_int)cvsd_chmin; i++) {
		ret = cvsd_child_fork(NULL);
		if (ret == -1) {
			cvs_log(LP_ERR, "failed to spawn child");
a259 2
		}
	}
d452 2
a453 15
		cvs_log(LP_INFO, "changing root to %s", cvsd_root);
		if (chroot(cvsd_root) == -1) {
			cvs_log(LP_ERRNO, "failed to chroot to `%s'",
			    cvsd_root);
			exit(EX_OSERR);
		}
		(void)chdir("/");

		if (cvsd_privdrop() < 0)
			exit(EX_OSERR);

		setproctitle("%s [child %d]", __progname, getpid());

		cvsd_child_loop();
		exit(0);
d639 2
d650 2
d683 1
a683 1
 * cvsd_child_loop()
d688 1
a688 1
cvsd_child_loop(void)
d695 13
d712 1
d740 1
d747 1
a747 2
			    "unexpected message type %u from parent",
			    mtype);
d870 2
a871 1
	    (what == CVSD_SET_USER) || (what == CVSD_SET_GROUP)) {
d901 5
@


1.9
log
@Add the `user' and `group' keywords in the configuration file format, so
we can specify alternate users under which the children should run
@
text
@d62 1
a62 1
int foreground = 0;
d64 2
a65 2
volatile sig_atomic_t running = 1;
volatile sig_atomic_t restart = 0;
d103 1
a103 1
		restart = 1;
d111 1
a111 1
		running = 0;
d171 1
a171 1
			foreground = 1;
d233 1
a233 1
	if (!foreground && daemon(0, 0) == -1) {
d607 1
a607 1
		if (!running)
d610 1
a610 1
		if (restart) {
d714 1
a714 1
	while (running) {
d742 1
a742 1
			running = 0;
@


1.8
log
@Simplify signal handling by having only one handler that sets the proper
variables, and add support for reporting via SIGINFO.  Also add a way to
change the user and group for privilege separation of the children.
@
text
@d71 2
a72 2
static char  *cvsd_user = CVSD_USER;
static char  *cvsd_group = CVSD_GROUP;
d155 2
d174 1
a174 1
			cvsd_group = optarg;
d191 1
a191 1
			cvsd_user = optarg;
d865 2
d869 2
a870 2
	switch (what) {
	case CVSD_SET_ROOT:
d873 1
a873 1
			cvs_log(LP_ERRNO, "failed to set CVS root");
d876 4
d884 17
a910 12
		break;
	case CVSD_SET_SOCK:
		str = strdup(va_arg(vap, char *));
		if (str == NULL) {
			cvs_log(LP_ERRNO, "failed to set CVS socket path");
			return (-1);
		}
		if (cvsd_sock_path != NULL)
			free(cvsd_sock_path);
		cvsd_sock_path = str;
		if (cvsd_sock_open() < 0)
			return (-1);
@


1.7
log
@Most of the code to handle SIGCHLD and spawn new children whenever
one dies.  Also fix cvsd_set() by making a copy of the string passed
as argument.
@
text
@d55 1
d68 2
a69 3
uid_t cvsd_uid = -1;
gid_t cvsd_gid = -1;

d71 2
d84 1
d87 3
a89 5
void   usage           (void);
void   sighup_handler  (int);
void   sigint_handler  (int);
void   sigchld_handler (int);
int    cvsd_msghdlr    (struct cvsd_child *, int);
d93 1
a93 1
 * sighup_handler()
d95 1
a95 1
 * Handler for the SIGHUP signal.
d99 1
a99 1
sighup_handler(int signo)
d101 16
a116 28
	restart = 1;
}


/*
 * sigint_handler()
 *
 * Handler for the SIGINT signal.
 */

void
sigint_handler(int signo)
{
	running = 0;
}


/*
 * sigchld_handler()
 *
 * Handler for the SIGCHLD signal.
 */

void
sigchld_handler(int signo)
{
	cvsd_sigchld = 1;
	signal(SIGCHLD, sigchld_handler);
d130 2
a131 1
	    "Usage: %s [-dfhpv] [-c config] [-r root] [-s path]\n"
d135 1
d140 1
d171 3
d188 3
d214 1
a214 1
	pwd = getpwnam(CVSD_USER);
d216 1
a216 1
		err(EX_NOUSER, "failed to get user `%s'", CVSD_USER);
d218 1
a218 1
	grp = getgrnam(CVSD_GROUP);
d220 1
a220 1
		err(EX_NOUSER, "failed to get group `%s'", CVSD_GROUP);
d225 5
a229 5
	signal(SIGHUP, sighup_handler);
	signal(SIGINT, sigint_handler);
	signal(SIGQUIT, sigint_handler);
	signal(SIGTERM, sigint_handler);
	signal(SIGCHLD, sigchld_handler);
d264 1
d285 2
a286 2
	cvs_log(LP_INFO, "dropping privileges to %s:%s", CVSD_USER,
	    CVSD_GROUP);
d492 1
a492 1
	signal(SIGCHLD, sigchld_handler);
d543 1
a543 1
			signal(SIGCHLD, sigchld_handler);
d616 4
d737 2
d907 33
@


1.6
log
@Add a `-h' option to print the usage and exit with status 0 and fix
usage() indentation
@
text
@d63 1
a63 1
volatile sig_atomic_t running = 0;
d71 2
a72 4
char *cvsd_root = NULL;
char *cvsd_conffile = CVSD_CONF;


d81 1
d120 1
d126 2
a127 4
	int status;

	wait(&status);

d142 1
d231 1
a411 1
 * We need to temporarily regain privileges in order to chroot.
d470 1
a470 2

		return (0);
d490 1
d492 2
d505 4
d513 1
a513 1
cvsd_child_reap(struct cvsd_child *ch)
d515 3
d519 33
d612 6
d642 2
d683 5
d700 3
d709 1
a709 1
	for (;;) {
d712 3
a714 3
		}
		else if (ret == 0) {
			cvs_log(LP_INFO, "parent process closed descriptor");
d717 2
a718 1
		cvs_log(LP_INFO, "polling");
d724 20
d847 2
d862 7
a868 1
		str = va_arg(vap, char *);
d880 1
a880 1
		/* this is more like and add than a set */
d883 8
a890 1
		cvsd_sock_path = va_arg(vap, char *);
@


1.5
log
@Fix the SIGINT handler
@
text
@d143 1
a143 1
	    "Usage: %s [-dfpv] [-c config] [-r root] [-s path]\n"
d146 4
a149 3
	    "\t-p\t\tPerform permission and ownership check on the repository\n"
	    "\t-r root\tUse <root> as the root directory of the repository\n"
	    "\t-s path\tUse <path> as the path for the CVS server socket\n"
d168 1
a168 1
	while ((ret = getopt(argc, argv, "a:c:dfpr:s:v")) != -1) {
d179 5
@


1.4
log
@Unused variables
@
text
@d114 1
@


1.3
log
@* rework on the child API, still needs more functionality
* move the ACL parsing code into the more general conf.y, which handles
  parsing of the whole configuration file
@
text
@a638 2
	uid_t uid;
	gid_t gid;
@


1.2
log
@Fix cvsd_privdrop() so we don't just drop effective IDs but all of them,
and call it instead of doing it by hand.  Noticed by and original patch
by Daniel Weeks
@
text
@d63 1
d72 1
a72 1
char *cvsd_aclfile = NULL;
d85 7
a113 1
	cvs_sock_doloop = 0;
d142 1
a142 2
	    "Usage: %s [-dfpv] [-a aclfile] [-c config] [-r root] [-s path]\n"
	    "\t-a aclfile\tUse the file <aclfile> for ACL ruleset\n"
a157 1
	uid_t uid;
d166 1
a166 1
	while ((ret = getopt(argc, argv, "a:dfpr:s:v")) != -1) {
d168 2
a169 2
		case 'a':
			cvsd_aclfile = optarg;
d199 2
a200 2
	if ((cvsd_aclfile != NULL) && (cvs_acl_parse(cvsd_aclfile) < 0))
		errx(1, "error while parsing the ACL file `%s'", cvsd_aclfile);
d251 2
a252 2
	for (i = 0; i < cvsd_chmin; i++) {
		ret = cvsd_forkchild();
d259 1
a259 1
	cvsd_sock_loop();
d402 1
a402 1
 * cvsd_forkchild()
d406 4
a409 2
 * On success, returns 0 if this is the child process, 1 if this is the
 * parent, or -1 on failure.
d413 1
a413 1
cvsd_forkchild(void)
d419 5
d483 6
d490 32
d523 10
a532 1
	return (1);
d536 1
d541 2
a542 1
 * socket pair for requests from the chrooted child.
d548 1
a548 2
	uid_t uid;
	int timeout, ret;
d555 1
d558 7
a564 1
		nfds = cvsd_chnum;
d572 4
a575 1
		i = 0;
d582 1
a582 1
			if (i == nfds)
d592 21
d614 1
a614 1
		for (i = 0; i < nfds; i++) {
d620 1
a620 1
			else
d639 2
d657 4
d669 3
d734 15
d757 47
@


1.1
log
@Initial revision
@
text
@d276 1
a276 1
	if (setegid(cvsd_gid) == -1) {
d282 1
a282 1
	if (seteuid(cvsd_uid) == -1) {
d446 1
a446 3
		/* redrop privileges */
		if (setgid(cvsd_gid) == -1) {
			cvs_log(LP_ERRNO, "failed to drop privileges");
a447 5
		}
		if (setuid(cvsd_uid) == -1) {
			cvs_log(LP_ERRNO, "failed to drop privileges");
			exit(EX_OSERR);
		}
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
