head	1.98;
access;
symbols
	OPENBSD_3_9:1.90.0.2
	OPENBSD_3_9_BASE:1.90
	OPENBSD_3_8:1.76.0.2
	OPENBSD_3_8_BASE:1.76
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.98
date	2006.05.27.03.30.31;	author joris;	state dead;
branches;
next	1.97;

1.97
date	2006.04.14.02.49.43;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2006.04.11.07.52.34;	author ray;	state Exp;
branches;
next	1.94;

1.94
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.93;

1.93
date	2006.04.02.02.01.40;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2006.04.01.01.20.21;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2006.03.15.18.24.50;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2006.02.08.19.24.19;	author joris;	state Exp;
branches;
next	1.89;

1.89
date	2006.02.05.18.21.44;	author joris;	state Exp;
branches;
next	1.88;

1.88
date	2006.01.26.09.05.31;	author xsa;	state Exp;
branches;
next	1.87;

1.87
date	2006.01.04.14.58.12;	author xsa;	state Exp;
branches;
next	1.86;

1.86
date	2006.01.02.17.38.17;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.84;

1.84
date	2005.12.30.17.51.01;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2005.12.30.16.47.36;	author joris;	state Exp;
branches;
next	1.82;

1.82
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.81;

1.81
date	2005.12.20.18.17.01;	author xsa;	state Exp;
branches;
next	1.80;

1.80
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.17.16.16.00;	author moritz;	state Exp;
branches;
next	1.78;

1.78
date	2005.10.10.17.51.53;	author xsa;	state Exp;
branches;
next	1.77;

1.77
date	2005.09.05.19.31.21;	author xsa;	state Exp;
branches;
next	1.76;

1.76
date	2005.08.16.06.37.57;	author xsa;	state Exp;
branches;
next	1.75;

1.75
date	2005.08.14.19.49.18;	author xsa;	state Exp;
branches;
next	1.74;

1.74
date	2005.08.10.14.49.20;	author xsa;	state Exp;
branches;
next	1.73;

1.73
date	2005.08.10.08.14.07;	author xsa;	state Exp;
branches;
next	1.72;

1.72
date	2005.07.28.15.52.09;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2005.07.27.14.15.24;	author xsa;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.26.20.58.44;	author moritz;	state Exp;
branches;
next	1.69;

1.69
date	2005.07.25.20.26.57;	author moritz;	state Exp;
branches;
next	1.68;

1.68
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.67;

1.67
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2005.07.24.16.46.40;	author xsa;	state Exp;
branches;
next	1.65;

1.65
date	2005.07.23.11.20.49;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2005.07.23.00.44.13;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.19.15.30.37;	author xsa;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.19.00.51.01;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2005.07.18.06.58.48;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.09.16.27.34;	author niallo;	state Exp;
branches;
next	1.58;

1.58
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2005.06.10.21.32.08;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.26.22.27.11;	author jfb;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.24.06.42.38;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.24.04.01.03;	author jfb;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.23.20.13.39;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2005.05.12.23.01.35;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.05.09.19.24.07;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.22.15.16.15;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.18.23.56.19;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.26.08.09.54;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.13.19.56.14;	author joris;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.13.19.52.26;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.04.18.36.57;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.04.18.16.40;	author jfb;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.14.20.58.43;	author jfb;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.14.20.54.48;	author jfb;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.22.00.38.25;	author david;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.16.17.09.33;	author jfb;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.14.17.52.37;	author jfb;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.08.19.28.10;	author jfb;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.08.16.07.43;	author jfb;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.08.05.36.14;	author jfb;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.02.19.23.44;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.16.21.03.43;	author jfb;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.15.04.16.33;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.23.15.36.32;	author jfb;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.27.12.42.45;	author jfb;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.13.02.57.28;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.12.20.09.40;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.12.18.35.18;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.05.13.24.37;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.04.13.26.02;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.03.04.58.45;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.02.22.45.57;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.02.17.16.08;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.30.23.10.21;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.30.17.37.58;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.30.01.49.24;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.29.19.03.33;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.29.18.49.08;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.29.18.34.55;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.28.01.49.14;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.27.16.16.19;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.27.13.55.00;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.26.17.28.59;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.26.16.00.10;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.25.18.50.30;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.14.05.16.04;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.04.32.42;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.98
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@/*	$OpenBSD: proto.c,v 1.97 2006/04/14 02:49:43 deraadt Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * CVS client/server protocol
 * ==========================
 *
 * The following code implements the CVS client/server protocol, which is
 * documented at the following URL:
 *	http://www.iam.unibe.ch/~til/documentation/cvs/cvsclient_toc.html
 *	http://www.elegosoft.com/cvs/cvsclient_toc.html
 *
 * The protocol is split up into two parts; the first part is the client side
 * of things and is composed of all the response handlers, which are all named
 * with a prefix of "cvs_resp_".  The second part is the set of request
 * handlers used by the server.  These handlers process the request and
 * generate the appropriate response to send back.  The prefix for request
 * handlers is "cvs_req_".
 *
 */

#include "includes.h"

#include "cvs.h"
#include "log.h"
#include "proto.h"


/* request flags */
#define CVS_REQF_RESP	0x01


static void	cvs_initlog(void);

struct cvs_req cvs_requests[] = {
	{ CVS_REQ_DIRECTORY,     "Directory",         0             },
	{ CVS_REQ_MAXDOTDOT,     "Max-dotdot",        0             },
	{ CVS_REQ_STATICDIR,     "Static-directory",  0             },
	{ CVS_REQ_STICKY,        "Sticky",            0             },
	{ CVS_REQ_ENTRY,         "Entry",             0             },
	{ CVS_REQ_ENTRYEXTRA,    "EntryExtra",        0             },
	{ CVS_REQ_CHECKINTIME,   "Checkin-time",      0             },
	{ CVS_REQ_MODIFIED,      "Modified",          0             },
	{ CVS_REQ_ISMODIFIED,    "Is-modified",       0             },
	{ CVS_REQ_UNCHANGED,     "Unchanged",         0             },
	{ CVS_REQ_USEUNCHANGED,  "UseUnchanged",      0             },
	{ CVS_REQ_NOTIFY,        "Notify",            0             },
	{ CVS_REQ_NOTIFYUSER,    "NotifyUser",        0             },
	{ CVS_REQ_QUESTIONABLE,  "Questionable",      0             },
	{ CVS_REQ_CASE,          "Case",              0             },
	{ CVS_REQ_UTF8,          "Utf8",              0             },
	{ CVS_REQ_ARGUMENT,      "Argument",          0             },
	{ CVS_REQ_ARGUMENTX,     "Argumentx",         0             },
	{ CVS_REQ_GLOBALOPT,     "Global_option",     0             },
	{ CVS_REQ_GZIPSTREAM,    "Gzip-stream",       0             },
	{ CVS_REQ_READCVSRC2,    "read-cvsrc2",       0             },
	{ CVS_REQ_READWRAP,      "read-cvswrappers",  0             },
	{ CVS_REQ_READIGNORE,    "read-cvsignore",    0             },
	{ CVS_REQ_ERRIFREADER,   "Error-If-Reader",   0             },
	{ CVS_REQ_VALIDRCSOPT,   "Valid-RcsOptions",  0             },
	{ CVS_REQ_SET,           "Set",               0             },
	{ CVS_REQ_XPANDMOD,      "expand-modules",    CVS_REQF_RESP },
	{ CVS_REQ_LOG,           "log",               CVS_REQF_RESP },
	{ CVS_REQ_CO,            "co",                CVS_REQF_RESP },
	{ CVS_REQ_EXPORT,        "export",            CVS_REQF_RESP },
	{ CVS_REQ_ANNOTATE,      "annotate",          CVS_REQF_RESP },
	{ CVS_REQ_RDIFF,         "rdiff",             CVS_REQF_RESP },
	{ CVS_REQ_RTAG,          "rtag",              CVS_REQF_RESP },
	{ CVS_REQ_INIT,          "init",              CVS_REQF_RESP },
	{ CVS_REQ_STATUS,        "status",            CVS_REQF_RESP },
	{ CVS_REQ_UPDATE,        "update",            CVS_REQF_RESP },
	{ CVS_REQ_HISTORY,       "history",           CVS_REQF_RESP },
	{ CVS_REQ_IMPORT,        "import",            CVS_REQF_RESP },
	{ CVS_REQ_ADD,           "add",               CVS_REQF_RESP },
	{ CVS_REQ_REMOVE,        "remove",            CVS_REQF_RESP },
	{ CVS_REQ_RELEASE,       "release",           CVS_REQF_RESP },
	{ CVS_REQ_ROOT,          "Root",              0             },
	{ CVS_REQ_VALIDRESP,     "Valid-responses",   0             },
	{ CVS_REQ_VALIDREQ,      "valid-requests",    CVS_REQF_RESP },
	{ CVS_REQ_VERSION,       "version",           CVS_REQF_RESP },
	{ CVS_REQ_NOOP,          "noop",              CVS_REQF_RESP },
	{ CVS_REQ_DIFF,          "diff",              CVS_REQF_RESP },
	{ CVS_REQ_CI,            "ci",                CVS_REQF_RESP },
	{ CVS_REQ_TAG,           "tag",               CVS_REQF_RESP },
	{ CVS_REQ_ADMIN,         "admin",             CVS_REQF_RESP },
	{ CVS_REQ_WATCHERS,      "watchers",          CVS_REQF_RESP },
	{ CVS_REQ_WATCH_ON,      "watch-on",          CVS_REQF_RESP },
	{ CVS_REQ_WATCH_OFF,     "watch-off",         CVS_REQF_RESP },
	{ CVS_REQ_WATCH_ADD,     "watch-add",         CVS_REQF_RESP },
	{ CVS_REQ_WATCH_REMOVE,  "watch-remove",      CVS_REQF_RESP },
	{ CVS_REQ_EDITORS,       "editors",           CVS_REQF_RESP },
};

struct cvs_resp cvs_responses[] = {
	{ CVS_RESP_OK,         "ok"                     },
	{ CVS_RESP_ERROR,      "error"                  },
	{ CVS_RESP_VALIDREQ,   "Valid-requests"         },
	{ CVS_RESP_M,          "M"                      },
	{ CVS_RESP_MBINARY,    "Mbinary"                },
	{ CVS_RESP_MT,         "MT"                     },
	{ CVS_RESP_E,          "E"                      },
	{ CVS_RESP_F,          "F"                      },
	{ CVS_RESP_CREATED,    "Created"                },
	{ CVS_RESP_UPDATED,    "Updated"                },
	{ CVS_RESP_UPDEXIST,   "Update-existing"        },
	{ CVS_RESP_MERGED,     "Merged"                 },
	{ CVS_RESP_REMOVED,    "Removed"                },
	{ CVS_RESP_RMENTRY,    "Remove-entry"           },
	{ CVS_RESP_CKSUM,      "Checksum"               },
	{ CVS_RESP_CLRSTATDIR, "Clear-static-directory" },
	{ CVS_RESP_SETSTATDIR, "Set-static-directory"   },
	{ CVS_RESP_NEWENTRY,   "New-entry"              },
	{ CVS_RESP_CHECKEDIN,  "Checked-in"             },
	{ CVS_RESP_MODE,       "Mode"                   },
	{ CVS_RESP_MODTIME,    "Mod-time"               },
	{ CVS_RESP_MODXPAND,   "Module-expansion"       },
	{ CVS_RESP_SETSTICKY,  "Set-sticky"             },
	{ CVS_RESP_CLRSTICKY,  "Clear-sticky"           },
	{ CVS_RESP_RCSDIFF,    "Rcs-diff"               },
	{ CVS_RESP_TEMPLATE,   "Template"               },
	{ CVS_RESP_COPYFILE,   "Copy-file"              },
};

#define CVS_NBREQ	(sizeof(cvs_requests)/sizeof(cvs_requests[0]))
#define CVS_NBRESP	(sizeof(cvs_responses)/sizeof(cvs_responses[0]))

/* hack to receive the remote version without outputting it */
u_int cvs_version_sent = 0;

static char  cvs_proto_buf[4096];

/*
 * Output files for protocol logging when the CVS_CLIENT_LOG environment
 * variable is set.
 */
static int   cvs_server_logon = 0;
static FILE *cvs_server_inlog = NULL;
static FILE *cvs_server_outlog = NULL;

static pid_t cvs_subproc_pid;

/* last directory sent with cvs_senddir() */
static char cvs_lastdir[MAXPATHLEN] = "";


/*
 * cvs_connect()
 *
 * Open a client connection to the cvs server whose address is given in
 * the <root> variable.  The method used to connect depends on the
 * setting of the CVS_RSH variable.
 * Once the connection has been established, we first send the list of
 * responses we support and request the list of supported requests from the
 * server.  Then, a version request is sent and various global flags are sent.
 */
void
cvs_connect(struct cvsroot *root)
{
	size_t len;
	int argc, infd[2], outfd[2], errfd[2];
	char *argv[16], *cvs_server_cmd, tmsg[1024], *vresp;

	if (root->cr_method == CVS_METHOD_PSERVER)
		fatal("no pserver support due to security issues");
	else if (root->cr_method == CVS_METHOD_KSERVER ||
	    root->cr_method == CVS_METHOD_GSERVER ||
	    root->cr_method == CVS_METHOD_EXT ||
	    root->cr_method == CVS_METHOD_FORK)
		fatal("connection method not supported yet");

	if (root->cr_flags & CVS_ROOT_CONNECTED) {
		cvs_log(LP_NOTICE, "already connected to CVSROOT");
		return;
	}

	if (pipe(infd) == -1)
		fatal("failed to create input pipe for client connection");

	if (pipe(outfd) == -1)
		fatal("failed to create output pipe for client connection");

	if (pipe(errfd) == -1)
		fatal("failed to create error pipe for client connection");

	cvs_subproc_pid = fork();
	if (cvs_subproc_pid == -1) {
		fatal("failed to fork for cvs server connection");
	} else if (cvs_subproc_pid == 0) {
		if (dup2(infd[0], STDIN_FILENO) == -1 ||
		    dup2(outfd[1], STDOUT_FILENO) == -1)
			fatal("failed to setup standard streams "
			    "for cvs server");

		(void)close(infd[1]);
		(void)close(outfd[0]);
		(void)close(errfd[0]);

		argc = 0;
		argv[argc++] = cvs_rsh;

		if (root->cr_user != NULL) {
			argv[argc++] = "-l";
			argv[argc++] = root->cr_user;
		}

		cvs_server_cmd = getenv("CVS_SERVER");
		if (cvs_server_cmd == NULL)
			cvs_server_cmd = CVS_SERVER_DEFAULT;

		argv[argc++] = root->cr_host;
		argv[argc++] = cvs_server_cmd;
		argv[argc++] = "server";
		argv[argc] = NULL;

		if (cvs_trace == 1) {
			tmsg[0] = '\0';
			for (argc = 0; argv[argc] != NULL; argc++) {
				len = strlcat(tmsg, argv[argc], sizeof(tmsg));
				if (len >= sizeof(tmsg))
					fatal("truncation in cvs_connect");

				len = strlcat(tmsg, " ", sizeof(tmsg));
				if (len >= sizeof(tmsg))
					fatal("truncation in cvs_connect");
			}
		}

		cvs_log(LP_TRACE, "Starting server: %s", tmsg);

		execvp(argv[0], argv);
		fatal("failed to execute cvs server");
	}

	/* we are the parent */
	(void)close(infd[0]);
	(void)close(outfd[1]);
	(void)close(errfd[1]);

	root->cr_srvin = fdopen(infd[1], "w");
	if (root->cr_srvin == NULL)
		fatal("failed to create pipe stream");

	root->cr_srvout = fdopen(outfd[0], "r");
	if (root->cr_srvout == NULL)
		fatal("failed to create pipe stream");

	/* make the streams line-buffered */
	(void)setvbuf(root->cr_srvin, NULL, _IOLBF, (size_t)0);
	(void)setvbuf(root->cr_srvout, NULL, _IOLBF, (size_t)0);

	cvs_initlog();

	/*
	 * Send the server the list of valid responses, then ask for valid
	 * requests.
	 */

	vresp = cvs_resp_getvalid();
	cvs_sendreq(root, CVS_REQ_VALIDRESP, vresp);
	xfree(vresp);

	cvs_sendreq(root, CVS_REQ_VALIDREQ, NULL);

	/* send the CVSROOT to the server */
	cvs_sendreq(root, CVS_REQ_ROOT, root->cr_dir);

	/* don't fail if this request doesn't work */
	cvs_sendreq(root, CVS_REQ_VERSION, NULL);

	/* now share our global options with the server */
	if (verbosity <= 1)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-q");
	if (verbosity == 0)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-Q");

	if (cvs_noexec == 1)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-n");

	if (cvs_nolog == 1)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-l");

	if (cvs_readonly == 1)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-r");

	if (cvs_trace == 1)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-t");

	/* not sure why, but we have to send this */
	cvs_sendreq(root, CVS_REQ_USEUNCHANGED, NULL);

	cvs_log(LP_DEBUG, "connected to %s", root->cr_host);

	root->cr_flags |= CVS_ROOT_CONNECTED;
}


/*
 * cvs_disconnect()
 *
 * Disconnect from the cvs server.
 */
void
cvs_disconnect(struct cvsroot *root)
{
	if (!(root->cr_flags & CVS_ROOT_CONNECTED))
		return;

	cvs_log(LP_DEBUG, "closing connection to %s", root->cr_host);

	if (root->cr_srvin != NULL) {
		(void)fclose(root->cr_srvin);
		root->cr_srvin = NULL;
	}
	if (root->cr_srvout != NULL) {
		(void)fclose(root->cr_srvout);
		root->cr_srvout = NULL;
	}

	root->cr_flags &= ~CVS_ROOT_CONNECTED;
}


/*
 * cvs_req_getbyid()
 *
 */
struct cvs_req*
cvs_req_getbyid(int reqid)
{
	u_int i;

	for (i = 0; i < CVS_NBREQ; i++)
		if (cvs_requests[i].req_id == reqid)
			return &(cvs_requests[i]);

	return (NULL);
}


/*
 * cvs_req_getbyname()
 */
struct cvs_req*
cvs_req_getbyname(const char *rname)
{
	u_int i;

	for (i = 0; i < CVS_NBREQ; i++)
		if (strcmp(cvs_requests[i].req_str, rname) == 0)
			return &(cvs_requests[i]);

	return (NULL);
}


/*
 * cvs_req_getvalid()
 *
 * Build a space-separated list of all the requests that this protocol
 * implementation supports.
 */
char *
cvs_req_getvalid(void)
{
	u_int i;
	size_t len;
	char *vrstr;
	BUF *buf;

	buf = cvs_buf_alloc((size_t)512, BUF_AUTOEXT);

	cvs_buf_set(buf, cvs_requests[0].req_str,
	    strlen(cvs_requests[0].req_str), (size_t)0);

	for (i = 1; i < CVS_NBREQ; i++) {
		cvs_buf_putc(buf, ' ');
		cvs_buf_append(buf, cvs_requests[i].req_str,
		    strlen(cvs_requests[i].req_str));
	}

	/* NUL-terminate */
	cvs_buf_putc(buf, '\0');

	len = cvs_buf_len(buf);
	vrstr = xmalloc(len);
	cvs_buf_copy(buf, (size_t)0, vrstr, len);
	cvs_buf_free(buf);

	return (vrstr);
}


/*
 * cvs_resp_getbyid()
 *
 */
struct cvs_resp*
cvs_resp_getbyid(int respid)
{
	u_int i;

	for (i = 0; i < CVS_NBRESP; i++)
		if (cvs_responses[i].resp_id == (u_int)respid)
			return &(cvs_responses[i]);

	return (NULL);
}


/*
 * cvs_resp_getbyname()
 */
struct cvs_resp *
cvs_resp_getbyname(const char *rname)
{
	u_int i;

	for (i = 0; i < CVS_NBRESP; i++)
		if (strcmp(cvs_responses[i].resp_str, rname) == 0)
			return &(cvs_responses[i]);

	return (NULL);
}


/*
 * cvs_resp_getvalid()
 *
 * Build a space-separated list of all the responses that this protocol
 * implementation supports.
 */
char *
cvs_resp_getvalid(void)
{
	u_int i;
	size_t len;
	char *vrstr;
	BUF *buf;

	buf = cvs_buf_alloc((size_t)512, BUF_AUTOEXT);

	cvs_buf_set(buf, cvs_responses[0].resp_str,
	    strlen(cvs_responses[0].resp_str), (size_t)0);

	for (i = 1; i < CVS_NBRESP; i++) {
		cvs_buf_putc(buf, ' ');
		cvs_buf_append(buf, cvs_responses[i].resp_str,
		    strlen(cvs_responses[i].resp_str));
	}

	/* NUL-terminate */
	cvs_buf_putc(buf, '\0');

	len = cvs_buf_len(buf);
	vrstr = xmalloc(len);
	cvs_buf_copy(buf, (size_t)0, vrstr, len);
	cvs_buf_free(buf);

	return (vrstr);
}


/*
 * cvs_sendfile()
 *
 * Send the mode and size of a file followed by the file's contents.
 * Returns 0 on success, or -1 on failure.
 */
void
cvs_sendfile(struct cvsroot *root, const char *path)
{
	int fd, l;
	ssize_t ret;
	char buf[4096];
	struct stat st;

	cvs_log(LP_TRACE, "Sending file `%s' to server", basename(path));

	if (stat(path, &st) == -1) {
		fatal("cvs_sendfile(): stat failed on '%s': %s",
		    path, strerror(errno));
	}

	cvs_modetostr(st.st_mode, buf, sizeof(buf));

	fd = open(path, O_RDONLY, 0);
	if (fd == -1) {
		fatal("cvs_sendfile(): failed to open '%s': %s",
		    path, strerror(errno));
	}

	cvs_sendln(root, buf);

	l = snprintf(buf, sizeof(buf), "%lld\n", st.st_size);
	if (l == -1 || l >= (int)sizeof(buf))
		fatal("overflow in cvs_sendfile");

	cvs_sendln(root, buf);

	while ((ret = read(fd, buf, sizeof(buf))) != 0) {
		if (ret == -1)
			fatal("cvs_sendfile: read error on '%s'", path);

		cvs_sendraw(root, buf, (size_t)ret);
	}

	(void)close(fd);
}


/*
 * cvs_recvfile()
 *
 * Receive the mode and size of a file followed the file's contents and
 * create or update the file whose path is <path> with the received
 * information.
 */
BUF*
cvs_recvfile(struct cvsroot *root, mode_t *mode)
{
	size_t len;
	ssize_t ret;
	off_t fsz, cnt;
	char buf[4096], *ep;
	BUF *fbuf;

	fbuf = cvs_buf_alloc(sizeof(buf), BUF_AUTOEXT);

	cvs_getln(root, buf, sizeof(buf));
	cvs_strtomode(buf, mode);

	cvs_getln(root, buf, sizeof(buf));

	fsz = (off_t)strtol(buf, &ep, 10);
	if (*ep != '\0')
		fatal("parse error in file size transmission");

	cnt = 0;
	do {
		len = MIN(sizeof(buf), (size_t)(fsz - cnt));
		if (len == 0)
			break;
		ret = cvs_recvraw(root, buf, len);
		cvs_buf_append(fbuf, buf, (size_t)ret);
		cnt += (off_t)ret;
	} while (cnt < fsz);

	return (fbuf);
}

/*
 * cvs_sendreq()
 *
 * Send a request to the server of type <rid>, with optional arguments
 * contained in <arg>, which should not be terminated by a newline.
 * Returns 0 on success, or -1 on failure.
 */
void
cvs_sendreq(struct cvsroot *root, u_int rid, const char *arg)
{
	int ret;
	struct cvs_req *req;

	if (root->cr_srvin == NULL)
		fatal("cannot send request %u: Not connected", rid);

	req = cvs_req_getbyid(rid);
	if (req == NULL)
		fatal("unsupported request type %u", rid);

	/* is this request supported by the server? */
	if (!CVS_GETVR(root, req->req_id)) {
		if (rid == CVS_REQ_VERSION) {
			cvs_sendreq(root, CVS_REQ_NOOP, arg);
		} else {
			cvs_log(LP_WARN,
			    "remote end does not support request `%s'",
			    req->req_str);
		}

		return;
	}

	if (strlcpy(cvs_proto_buf, req->req_str, sizeof(cvs_proto_buf)) >=
	    sizeof(cvs_proto_buf) ||
	    strlcat(cvs_proto_buf, (arg == NULL) ? "" : " ",
	    sizeof(cvs_proto_buf)) >= sizeof(cvs_proto_buf) ||
	    strlcat(cvs_proto_buf, (arg == NULL) ? "" : arg,
	    sizeof(cvs_proto_buf)) >= sizeof(cvs_proto_buf) ||
	    strlcat(cvs_proto_buf, "\n",
	    sizeof(cvs_proto_buf)) >= sizeof(cvs_proto_buf))
		fatal("cvs_sendreq: overflow when creating proto buffer");

	if (cvs_server_inlog != NULL)
		fputs(cvs_proto_buf, cvs_server_inlog);

	ret = fputs(cvs_proto_buf, root->cr_srvin);
	if (ret == EOF)
		fatal("failed to send request to server");

	if (rid == CVS_REQ_VERSION)
		cvs_version_sent = 1;

	if (req->req_flags & CVS_REQF_RESP)
		cvs_getresp(root);
}


/*
 * cvs_getresp()
 *
 * Get a response from the server.  This call will actually read and handle
 * responses from the server until one of the response handlers returns
 * non-zero (either an error occurred or the end of the response was reached).
 * Returns the number of handled commands on success, or -1 on failure.
 */
void
cvs_getresp(struct cvsroot *root)
{
	int ret;
	size_t len;

	do {
		/* wait for incoming data */
		if (fgets(cvs_proto_buf, (int)sizeof(cvs_proto_buf),
		    root->cr_srvout) == NULL) {
			if (feof(root->cr_srvout))
				return;
			fatal("failed to read response from server");
		}

		if (cvs_server_outlog != NULL)
			fputs(cvs_proto_buf, cvs_server_outlog);

		if ((len = strlen(cvs_proto_buf)) != 0) {
			/* if len - 1 != '\n' the line is truncated */
			if (cvs_proto_buf[len - 1] == '\n')
				cvs_proto_buf[--len] = '\0';
		}

		ret = cvs_resp_handle(root, cvs_proto_buf);
	} while (ret == 0);
}


/*
 * cvs_getln()
 *
 * Get a line from the remote end and store it in <lbuf>.  The terminating
 * newline character is stripped from the result.
 */
void
cvs_getln(struct cvsroot *root, char *lbuf, size_t len)
{
	size_t rlen;
	FILE *in;

	if (cvs_cmdop == CVS_OP_SERVER)
		in = stdin;
	else
		in = root->cr_srvout;

	if (fgets(lbuf, (int)len, in) == NULL) {
		if (ferror(in)) {
			fatal("cvs_getln: error reading server: %s",
			    strerror(errno));
		}

		if (feof(in))
			*lbuf = '\0';
	}

	if (cvs_server_outlog != NULL)
		fputs(lbuf, cvs_server_outlog);

	rlen = strlen(lbuf);
	if (rlen > 0 && lbuf[rlen - 1] == '\n')
		lbuf[--rlen] = '\0';
}


/*
 * cvs_sendresp()
 *
 * Send a response of type <rid> to the client, with optional arguments
 * contained in <arg>, which should not be terminated by a newline.
 */
void
cvs_sendresp(u_int rid, const char *arg)
{
	int ret;
	struct cvs_resp *resp;

	if ((resp = cvs_resp_getbyid(rid)) == NULL)
		fatal("unsupported response type %u", rid);

	ret = fputs(resp->resp_str, stdout);
	if (ret == EOF) {
		cvs_log(LP_ERRNO, "failed to send response to client");
	} else {
		if (arg != NULL) {
			putc(' ', stdout);
			fputs(arg, stdout);
		}
		putc('\n', stdout);
	}
}


/*
 * cvs_sendln()
 *
 * Send a single line <line> string to the remote end.  The line is sent as is,
 * without any modifications.
 */
void
cvs_sendln(struct cvsroot *root, const char *line)
{
	int nl;
	size_t len;
	FILE *out;

	if (cvs_cmdop == CVS_OP_SERVER)
		out = stdout;
	else
		out = root->cr_srvin;

	nl = 0;
	len = strlen(line);

	if (len > 0 && line[len - 1] != '\n')
		nl = 1;

	if (cvs_server_inlog != NULL) {
		fputs(line, cvs_server_inlog);
		if (nl)
			putc('\n', cvs_server_inlog);
	}
	fputs(line, out);
	if (nl)
		putc('\n', out);
}


/*
 * cvs_sendraw()
 *
 * Send the first <len> bytes from the buffer <src> to the server.
 */
void
cvs_sendraw(struct cvsroot *root, const void *src, size_t len)
{
	FILE *out;

	if (cvs_cmdop == CVS_OP_SERVER)
		out = stdout;
	else
		out = root->cr_srvin;

	if (cvs_server_inlog != NULL)
		fwrite(src, sizeof(char), len, cvs_server_inlog);
	if (fwrite(src, sizeof(char), len, out) < len)
		fatal("failed to send data");
}


/*
 * cvs_recvraw()
 *
 * Receive the first <len> bytes from the buffer <src> to the server.
 */
size_t
cvs_recvraw(struct cvsroot *root, void *dst, size_t len)
{
	size_t ret;
	FILE *in;

	if (cvs_cmdop == CVS_OP_SERVER)
		in = stdin;
	else
		in = root->cr_srvout;

	ret = fread(dst, sizeof(char), len, in);
	if (ret == 0) {
		if (ferror(in)) {
			fatal("cvs_recvraw: error reading from server: %s",
			    strerror(errno));
		}
	} else {
		if (cvs_server_outlog != NULL)
			fwrite(dst, sizeof(char), len, cvs_server_outlog);
	}

	return (ret);
}


/*
 * cvs_senddir()
 *
 * Send a `Directory' request along with the 2 paths that follow it.  If
 * the directory info to be sent is the same as the last info sent, the
 * call does nothing and simply returns without an error.
 */
void
cvs_senddir(struct cvsroot *root, CVSFILE *dir)
{
	size_t len;
	char lbuf[MAXPATHLEN], rbuf[MAXPATHLEN];

	if (dir->cf_type != DT_DIR)
		fatal("cvs_senddir(): cf_type != DT_DIR: %d", dir->cf_type);

	cvs_file_getpath(dir, lbuf, sizeof(lbuf));
	if (strcmp(lbuf, cvs_lastdir) == 0 && cvs_cmdop != CVS_OP_CHECKOUT)
		return;

	if (dir->cf_repo == NULL) {
		len = strlcpy(rbuf, root->cr_dir, sizeof(rbuf));
		if (len >= sizeof(rbuf))
			fatal("cvs_senddir: path truncation");
	} else {
		len = cvs_path_cat(root->cr_dir, dir->cf_repo, rbuf,
		    sizeof(rbuf));
		if (len >= sizeof(rbuf))
			fatal("cvs_senddir: path truncation");
	}

	cvs_sendreq(root, CVS_REQ_DIRECTORY, lbuf);
	cvs_sendln(root, rbuf);

	len = strlcpy(cvs_lastdir, lbuf, sizeof(cvs_lastdir));
	if (len >= sizeof(lbuf))
		fatal("path truncation in cvs_senddir");
}


/*
 * cvs_sendarg()
 *
 * Send the argument <arg> to the server.  The argument <append> is used to
 * determine if the argument should be simply appended to the last argument
 * sent or if it should be created as a new argument (0).
 */
void
cvs_sendarg(struct cvsroot *root, const char *arg, int append)
{
	cvs_sendreq(root, append == 0 ? CVS_REQ_ARGUMENT :
	    CVS_REQ_ARGUMENTX, arg);
}


/*
 * cvs_sendentry()
 *
 * Send an `Entry' request to the server along with the mandatory fields from
 * the CVS entry <ent> (which are the name and revision).
 */
void
cvs_sendentry(struct cvsroot *root, const CVSFILE *file)
{
	char ebuf[CVS_ENT_MAXLINELEN], numbuf[64];

	if (file->cf_type != DT_REG)
		fatal("cvs_sendentry: cf_type != DT_REG: %d", file->cf_type);

	/* don't send Entry for unknown files */
	if (file->cf_cvstat == CVS_FST_UNKNOWN)
		return;

	if (strlcpy(ebuf, "/", sizeof(ebuf)) >= sizeof(ebuf) ||
	    strlcat(ebuf, file->cf_name, sizeof(ebuf)) >= sizeof(ebuf) ||
	    strlcat(ebuf, "/", sizeof(ebuf)) >= sizeof(ebuf) ||
	    strlcat(ebuf, (file->cf_cvstat == CVS_FST_REMOVED) ? "-" : "",
	    sizeof(ebuf)) >= sizeof(ebuf) ||
	    strlcat(ebuf, rcsnum_tostr(file->cf_lrev, numbuf, sizeof(numbuf)),
	    sizeof(ebuf)) >= sizeof(ebuf) ||
	    strlcat(ebuf, "///", sizeof(ebuf)) >= sizeof(ebuf))
		fatal("cvs_sendentry: overflow when creating entry buffer");

	cvs_sendreq(root, CVS_REQ_ENTRY, ebuf);
}


/*
 * cvs_initlog()
 *
 * Initialize protocol logging if the CVS_CLIENT_LOG environment variable is
 * set.  In this case, the variable's value is used as a path to which the
 * appropriate suffix is added (".in" for server input and ".out" for server
 * output.
 * Returns 0 on success, or -1 on failure.
 */
static void
cvs_initlog(void)
{
	int l;
	u_int i;
	char *env, *envdup, buf[MAXPATHLEN], fpath[MAXPATHLEN];
	char rpath[MAXPATHLEN], *s;
	struct stat st;
	time_t now;
	struct passwd *pwd;

	/* avoid doing it more than once */
	if (cvs_server_logon)
		return;

	env = getenv("CVS_CLIENT_LOG");
	if (env == NULL)
		return;

	envdup = xstrdup(env);
	if ((s = strchr(envdup, '%')) != NULL)
		*s = '\0';

	if (strlcpy(buf, env, sizeof(buf)) >= sizeof(buf))
		fatal("string truncation in cvs_initlog");

	if (strlcpy(rpath, envdup, sizeof(rpath)) >= sizeof(rpath))
		fatal("string truncation in cvs_initlog");

	xfree(envdup);

	s = buf;
	while ((s = strchr(s, '%')) != NULL) {
		s++;
		switch (*s) {
		case 'c':
			if (strlcpy(fpath, cvs_command, sizeof(fpath)) >=
			    sizeof(fpath))
				fatal("string truncation in cvs_initlog");
			break;
		case 'd':
			time(&now);
			if (strlcpy(fpath, ctime(&now), sizeof(fpath)) >=
			    sizeof(fpath))
				fatal("string truncation in cvs_initlog");
			break;
		case 'p':
			snprintf(fpath, sizeof(fpath), "%d", getpid());
			break;
		case 'u':
			if ((pwd = getpwuid(getuid())) != NULL) {
				if (strlcpy(fpath, pwd->pw_name,
				    sizeof(fpath)) >= sizeof(fpath))
					fatal("truncation in cvs_initlog");
			} else {
				fpath[0] = '\0';
			}
			endpwent();
			break;
		default:
			fpath[0] = '\0';
			break;
		}

		if (fpath[0] != '\0') {
			if (strlcat(rpath, "-", sizeof(rpath)) >= sizeof(rpath))
				fatal("string truncation cvs_initlog");

			if (strlcat(rpath, fpath, sizeof(rpath))
			    >= sizeof(rpath))
				fatal("string truncation in cvs_initlog");
		}
	}

	for (i = 0; i < UINT_MAX; i++) {
		l = snprintf(fpath, sizeof(fpath), "%s-%d.in", rpath, i);
		if (l == -1 || l >= (int)sizeof(fpath))
			fatal("overflow in cvs_initlog()");

		if (stat(fpath, &st) != -1)
			continue;

		if (errno != ENOENT)
			fatal("cvs_initlog() stat failed '%s'",
			    strerror(errno));

		break;
	}

	cvs_server_inlog = fopen(fpath, "w");
	if (cvs_server_inlog == NULL)
		fatal("failed to open server input log `%s'", fpath);

	for (i = 0; i < UINT_MAX; i++) {
		l = snprintf(fpath, sizeof(fpath), "%s-%d.out", rpath, i);
		if (l == -1 || l >= (int)sizeof(fpath))
			fatal("overflow in cvs_initlog()");

		if (stat(fpath, &st) != -1)
			continue;

		if (errno != ENOENT)
			fatal("cvs_initlog() stat failed '%s'",
			    strerror(errno));

		break;
	}

	cvs_server_outlog = fopen(fpath, "w");
	if (cvs_server_outlog == NULL)
		fatal("failed to open server output log `%s'", fpath);

	/* make the streams line-buffered */
	setvbuf(cvs_server_inlog, NULL, _IOLBF, (size_t)0);
	setvbuf(cvs_server_outlog, NULL, _IOLBF, (size_t)0);

	cvs_server_logon = 1;
}
@


1.97
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.96 2006/04/14 02:45:35 deraadt Exp $	*/
@


1.96
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.95 2006/04/11 07:52:34 ray Exp $	*/
d916 1
a916 1
static void 
@


1.95
log
@Don't close() before fatal().

OK joris@@, niallo@@, and xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.94 2006/04/05 01:38:55 ray Exp $	*/
d187 4
a190 4
	else if ((root->cr_method == CVS_METHOD_KSERVER) ||
	    (root->cr_method == CVS_METHOD_GSERVER) ||
	    (root->cr_method == CVS_METHOD_EXT) ||
	    (root->cr_method == CVS_METHOD_FORK))
d211 2
a212 2
		if ((dup2(infd[0], STDIN_FILENO) == -1) ||
		    (dup2(outfd[1], STDOUT_FILENO) == -1))
d699 1
a699 1
	if ((rlen > 0) && (lbuf[rlen - 1] == '\n'))
d753 1
a753 1
	if ((len > 0) && (line[len - 1] != '\n'))
d870 2
a871 2
	cvs_sendreq(root, ((append == 0) ? CVS_REQ_ARGUMENT :
	    CVS_REQ_ARGUMENTX), arg);
@


1.94
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.93 2006/04/02 02:01:40 joris Exp $	*/
d523 1
a523 2
		if (ret == -1) {
			(void)close(fd);
a524 1
		}
@


1.93
log
@be more alert for string truncation in cvs_initlog()
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.92 2006/04/01 01:20:21 joris Exp $	*/
d407 1
a407 1
	vrstr = (char *)xmalloc(len);
d477 1
a477 1
	vrstr = (char *)xmalloc(len);
@


1.92
log
@cvs_initlog() returns a value that is never used, zap it.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.91 2006/03/15 18:24:50 deraadt Exp $	*/
d941 6
a946 2
	strlcpy(buf, env, sizeof(buf));
	strlcpy(rpath, envdup, sizeof(rpath));
d954 3
a956 1
			strlcpy(fpath, cvs_command, sizeof(fpath));
d960 3
a962 1
			strlcpy(fpath, ctime(&now), sizeof(fpath));
d968 5
a972 3
			if ((pwd = getpwuid(getuid())) != NULL)
				strlcpy(fpath, pwd->pw_name, sizeof(fpath));
			else
d974 1
d983 6
a988 2
			strlcat(rpath, "-", sizeof(rpath));
			strlcat(rpath, fpath, sizeof(rpath));
d1001 2
a1002 1
			fatal("cvs_initlog() stat failed '%s'", strerror(errno));
d1020 2
a1021 1
			fatal("cvs_initlog() stat failed '%s'", strerror(errno));
@


1.91
log
@bogus idiom
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.90 2006/02/08 19:24:19 joris Exp $	*/
d55 1
a55 1
static int	cvs_initlog(void);
d918 1
a918 1
static int
d931 1
a931 1
		return (0);
d935 1
a935 1
		return (0);
d979 2
a980 5
		if (l == -1 || l >= (int)sizeof(fpath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", fpath);
			return (-1);
		}
d986 1
a986 1
			return (-1);
d992 2
a993 5
	if (cvs_server_inlog == NULL) {
		cvs_log(LP_ERRNO, "failed to open server input log `%s'",
		    fpath);
		return (-1);
	}
d997 2
a998 5
		if (l == -1 || l >= (int)sizeof(fpath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", fpath);
			return (-1);
		}
d1004 1
a1004 1
			return (-1);
d1010 2
a1011 5
	if (cvs_server_outlog == NULL) {
		cvs_log(LP_ERRNO, "failed to open server output log `%s'",
		    fpath);
		return (-1);
	}
a1017 2

	return (0);
@


1.90
log
@fix more breakage by xsa, although this one is partially my fault as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.89 2006/02/05 18:21:44 joris Exp $	*/
d947 1
a947 1
		*s++;
@


1.89
log
@unbreak remote protocol which got broken in revision 1.88.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.88 2006/01/26 09:05:31 xsa Exp $	*/
d718 1
a718 1
	if ((resp = cvs_resp_getbyid(rid)) == NULL);
@


1.88
log
@strings cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.87 2006/01/04 14:58:12 xsa Exp $	*/
d613 2
@


1.87
log
@make cvs_sendresp() return type void; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.86 2006/01/02 17:38:17 joris Exp $	*/
d585 1
a585 1
	int ret, l;
d608 7
a614 4
	l = snprintf(cvs_proto_buf, sizeof(cvs_proto_buf), "%s%s%s\n",
	    req->req_str, (arg == NULL) ? "" : " ", (arg == NULL) ? "" : arg);
	if (l == -1 || l >= (int)sizeof(cvs_proto_buf))
		fatal("overflow in cvs_sendreq");
a883 1
	int l;
d893 8
a900 4
	l = snprintf(ebuf, sizeof(ebuf), "/%s/%s%s///", file->cf_name,
	    (file->cf_cvstat == CVS_FST_REMOVED) ? "-" : "",
	    rcsnum_tostr(file->cf_lrev, numbuf, sizeof(numbuf)));
	if (l == -1 || l >= (int)sizeof(ebuf))
@


1.86
log
@zap, kill and eliminate unused code;
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.85 2006/01/02 08:11:56 xsa Exp $	*/
a705 1
 * Returns 0 on success, or -1 on failure.
d707 1
a707 1
int
d713 2
a714 5
	resp = cvs_resp_getbyid(rid);
	if (resp == NULL) {
		cvs_log(LP_ERR, "unsupported response type %u", rid);
		return (-1);
	}
a725 1
	return (0);
@


1.85
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.84 2005/12/30 17:51:01 reyk Exp $	*/
a731 37


#ifdef notyet
/*
 * cvs_getreq()
 *
 * Get a request from the client.
 */
int
cvs_getreq(void)
{
	int nbcmd;

	nbcmd = 0;

	do {
		/* wait for incoming data */
		if (fgets(cvs_proto_buf, (int)sizeof(cvs_proto_buf),
		    stdin) == NULL) {
			if (feof(stdin))
				return (0);
			cvs_log(LP_ERRNO,
			    "failed to read request from client");
			return (-1);
		}

		if ((len = strlen(cvs_proto_buf)) != 0) {
			if (cvs_proto_buf[len - 1] != '\n') {
				/* truncated line */
			} else
				cvs_proto_buf[--len] = '\0';
		}

		ret = cvs_resp_handle(cvs_proto_buf);
	} while (ret == 0);
}
#endif
@


1.84
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.83 2005/12/30 16:47:36 joris Exp $	*/
d44 1
a44 11
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.83
log
@more code cleanup, ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.82 2005/12/30 02:03:28 joris Exp $	*/
d223 2
a224 1
			fatal("failed to setup standard streams for cvs server");
d614 1
a614 1
		
@


1.82
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.81 2005/12/20 18:17:01 xsa Exp $	*/
d562 2
a563 5
	if ((cvs_getln(root, buf, sizeof(buf)) < 0) ||
	    (cvs_strtomode(buf, mode) < 0)) {
		cvs_buf_free(fbuf);
		return (NULL);
	}
d565 1
a565 4
	if (cvs_getln(root, buf, sizeof(buf)) < 0) {
		cvs_buf_free(fbuf);
		return (NULL);
	}
d568 2
a569 5
	if (*ep != '\0') {
		cvs_log(LP_ERR, "parse error in file size transmission");
		cvs_buf_free(fbuf);
		return (NULL);
	}
d577 1
a577 12
		if (ret == -1) {
			cvs_buf_free(fbuf);
			return (NULL);
		}

		if (cvs_buf_append(fbuf, buf, (size_t)ret) == -1) {
			cvs_log(LP_ERR,
			    "failed to append received file data");
			cvs_buf_free(fbuf);
			return (NULL);
		}

a678 2
 * Returns the length in bytes of the line (not including the NUL byte), or
 * -1 on failure.
d680 1
a680 1
int
d693 2
a694 2
			cvs_log(LP_ERRNO, "failed to read line");
			return (-1);
a706 2

	return (rlen);
d842 1
a842 1
ssize_t
d854 11
a864 5
	if (ret == 0)
		return (-1);
	if (cvs_server_outlog != NULL)
		fwrite(dst, sizeof(char), len, cvs_server_outlog);
	return (ssize_t)ret;
@


1.81
log
@cvs_buf_putc() and cvs_buf_write_*() functions cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.80 2005/12/10 20:27:45 joris Exp $	*/
a186 1
 * Returns 0 on success, or -1 on failure.
d188 1
a188 1
int
d191 1
d195 3
a197 4
	if (root->cr_method == CVS_METHOD_PSERVER) {
		cvs_log(LP_ERR, "no pserver support due to security issues");
		return (-1);
	} else if ((root->cr_method == CVS_METHOD_KSERVER) ||
d200 2
a201 4
	    (root->cr_method == CVS_METHOD_FORK)) {
		cvs_log(LP_ERR, "connection method not supported yet");
		return (-1);
	}
d205 1
a205 1
		return (0);
d208 2
a209 5
	if (pipe(infd) == -1) {
		cvs_log(LP_ERRNO,
		    "failed to create input pipe for client connection");
		return (-1);
	}
d211 2
a212 7
	if (pipe(outfd) == -1) {
		cvs_log(LP_ERRNO,
		    "failed to create output pipe for client connection");
		(void)close(infd[0]);
		(void)close(infd[1]);
		return (-1);
	}
d214 2
a215 9
	if (pipe(errfd) == -1) {
		cvs_log(LP_ERRNO,
		    "failed to create error pipe for client connection");
		(void)close(infd[0]);
		(void)close(infd[1]);
		(void)close(outfd[0]);
		(void)close(outfd[1]);
		return (-1);
	}
d219 1
a219 2
		cvs_log(LP_ERRNO, "failed to fork for cvs server connection");
		return (-1);
d222 3
a224 5
		    (dup2(outfd[1], STDOUT_FILENO) == -1)) {
			cvs_log(LP_ERRNO,
			    "failed to setup standard streams for cvs server");
			return (-1);
		}
d249 7
a255 2
				strlcat(tmsg, argv[argc], sizeof(tmsg));
				strlcat(tmsg, " ", sizeof(tmsg));
d258 1
d262 1
a262 2
		cvs_log(LP_ERRNO, "failed to exec");
		exit(CVS_EX_PROTO);
d271 2
a272 4
	if (root->cr_srvin == NULL) {
		cvs_log(LP_ERRNO, "failed to create pipe stream");
		return (-1);
	}
d275 2
a276 4
	if (root->cr_srvout == NULL) {
		cvs_log(LP_ERRNO, "failed to create pipe stream");
		return (-1);
	}
d289 2
a290 10
	if ((vresp = cvs_resp_getvalid()) == NULL) {
		cvs_log(LP_ERR, "can't generate list of valid responses");
		return (-1);
	}

	if (cvs_sendreq(root, CVS_REQ_VALIDRESP, vresp) < 0) {
		cvs_log(LP_ERR, "failed to get valid responses");
		xfree(vresp);
		return (-1);
	}
d293 1
a293 4
	if (cvs_sendreq(root, CVS_REQ_VALIDREQ, NULL) < 0) {
		cvs_log(LP_ERR, "failed to get valid requests from server");
		return (-1);
	}
d296 1
a296 2
	if (cvs_sendreq(root, CVS_REQ_ROOT, root->cr_dir) < 0)
		return (-1);
d299 1
a299 2
	if (cvs_sendreq(root, CVS_REQ_VERSION, NULL) < 0)
		cvs_log(LP_WARN, "failed to get remote version");
d302 13
a314 6
	if ((verbosity <= 1) &&
	    (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-q") < 0))
		return (-1);
	if ((verbosity == 0) &&
	    (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-Q") < 0))
		return (-1);
d316 2
a317 12
	if ((cvs_noexec == 1) &&
	    (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-n") < 0))
		return (-1);
	if ((cvs_nolog == 1) &&
	    (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-l") < 0))
		return (-1);
	if ((cvs_readonly == 1) &&
	    (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-r") < 0))
		return (-1);
	if ((cvs_trace == 1) &&
	    (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-t") < 0))
		return (-1);
d320 1
a320 2
	if (cvs_sendreq(root, CVS_REQ_USEUNCHANGED, NULL) < 0)
		return (-1);
a324 2

	return (0);
d340 1
a401 2
	if (buf == NULL)
		return (NULL);
a471 2
	if (buf == NULL)
		return (NULL);
d500 1
a500 1
int
d511 2
a512 2
		cvs_log(LP_ERRNO, "failed to stat `%s'", path);
		return (-1);
d515 1
a515 2
	if (cvs_modetostr(st.st_mode, buf, sizeof(buf)) < 0)
		return (-1);
d519 2
a520 2
		cvs_log(LP_ERRNO, "failed to open `%s'", path);
		return (-1);
d523 2
a524 4
	if (cvs_sendln(root, buf) < 0) {
		(void)close(fd);
		return (-1);
	}
d527 1
a527 1
		return (-1);
d529 1
a529 4
	if (cvs_sendln(root, buf) < 0) {
		(void)close(fd);
		return (-1);
	}
d534 1
a534 2
			cvs_log(LP_ERRNO, "failed to read file `%s'", path);
			return (-1);
d537 1
a537 4
		if (cvs_sendraw(root, buf, (size_t)ret) < 0) {
			(void)close(fd);
			return (-1);
		}
a540 1
	return (0);
a560 2
	if (fbuf == NULL)
		return (NULL);
d611 1
a611 1
int
d617 2
a618 4
	if (root->cr_srvin == NULL) {
		cvs_log(LP_ERR, "cannot send request %u: Not connected", rid);
		return (-1);
	}
d621 2
a622 4
	if (req == NULL) {
		cvs_log(LP_ERR, "unsupported request type %u", rid);
		return (-1);
	}
d627 1
a627 1
			ret = cvs_sendreq(root, CVS_REQ_NOOP, arg);
a631 1
			ret = -1;
d633 2
a634 1
		return (ret);
d640 1
a640 1
		return (-1);
d646 2
a647 4
	if (ret == EOF) {
		cvs_log(LP_ERRNO, "failed to send request to server");
		return (-1);
	}
d653 1
a653 3
		ret = cvs_getresp(root);

	return (ret);
d665 1
a665 1
int
d668 1
a668 1
	int nbcmd, ret;
a670 2
	nbcmd = 0;

d676 2
a677 4
				return (0);
			cvs_log(LP_ERRNO,
			    "failed to read response from server");
			return (-1);
a689 1
		nbcmd++;
a690 4

	if (ret > 0)
		ret = nbcmd;
	return (ret);
a808 1
 * Returns 0 on success, or -1 on failure.
d810 1
a810 1
int
a835 1
	return (0);
d844 1
a844 1
int
d856 2
a857 6
	if (fwrite(src, sizeof(char), len, out) < len) {
		cvs_log(LP_ERR, "failed to send data");
		return (-1);
	}

	return (0);
d893 1
a893 1
int
d900 1
a900 1
		return (-1);
d904 1
a904 1
		return (0);
d906 5
a910 3
	if (dir->cf_repo == NULL)
		strlcpy(rbuf, root->cr_dir, sizeof(rbuf));
	else {
d914 1
a914 1
			return (-1);
d917 2
d920 3
a922 7
	if ((cvs_sendreq(root, CVS_REQ_DIRECTORY, lbuf) < 0) ||
	    (cvs_sendln(root, rbuf) < 0))
		return (-1);

	strlcpy(cvs_lastdir, lbuf, sizeof(cvs_lastdir));

	return (0);
d933 1
a933 1
int
d936 2
a937 2
	return cvs_sendreq(root, ((append == 0) ?
	    CVS_REQ_ARGUMENT : CVS_REQ_ARGUMENTX), arg);
d947 1
a947 1
int
d953 2
a954 4
	if (file->cf_type != DT_REG) {
		cvs_log(LP_ERR, "attempt to send Entry for non-regular file");
		return (-1);
	}
d958 1
a958 1
		return (0);
d963 2
a964 5
	if (l == -1 || l >= (int)sizeof(ebuf)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", ebuf);
		return (-1);
	}
d966 1
a966 1
	return cvs_sendreq(root, CVS_REQ_ENTRY, ebuf);
@


1.80
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.79 2005/10/17 16:16:00 moritz Exp $	*/
d447 3
a449 6
		if ((cvs_buf_putc(buf, ' ') < 0) ||
		    (cvs_buf_append(buf, cvs_requests[i].req_str,
		    strlen(cvs_requests[i].req_str)) < 0)) {
			cvs_buf_free(buf);
			return (NULL);
		}
d453 1
a453 4
	if (cvs_buf_putc(buf, '\0') < 0) {
		cvs_buf_free(buf);
		return (NULL);
	}
d519 3
a521 6
		if ((cvs_buf_putc(buf, ' ') < 0) ||
		    (cvs_buf_append(buf, cvs_responses[i].resp_str,
		    strlen(cvs_responses[i].resp_str)) < 0)) {
			cvs_buf_free(buf);
			return (NULL);
		}
d525 1
a525 4
	if (cvs_buf_putc(buf, '\0') < 0) {
		cvs_buf_free(buf);
		return (NULL);
	}
@


1.79
log
@add client support for the `watch' and `watchers' commands. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.78 2005/10/10 17:51:53 xsa Exp $	*/
d316 1
a316 1
		free(vresp);
d319 1
a319 1
	free(vresp);
d462 1
a462 6
	vrstr = (char *)malloc(len);
	if (vrstr == NULL) {
		cvs_buf_free(buf);
		return (NULL);
	}

d540 1
a540 6
	vrstr = (char *)malloc(len);
	if (vrstr == NULL) {
		cvs_buf_free(buf);
		return (NULL);
	}

d1093 1
a1093 3
	if ((envdup = strdup(env)) == NULL)
		return (-1);

d1099 1
a1099 1
	free(envdup);
@


1.78
log
@- editors remote handler
- minor consistency tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.77 2005/09/05 19:31:21 xsa Exp $	*/
d119 4
@


1.77
log
@use CVS_ENT_MAXLINELEN;
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.76 2005/08/16 06:37:57 xsa Exp $	*/
d119 1
@


1.76
log
@- watchers remote handler
- consistency nitpicks
ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.75 2005/08/14 19:49:18 xsa Exp $	*/
d1046 1
a1046 1
	char ebuf[128], numbuf[64];
@


1.75
log
@missing casts; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.74 2005/08/10 14:49:20 xsa Exp $	*/
d118 1
@


1.74
log
@fgets() expects the 2nd arg to be an int. OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.73 2005/08/10 08:14:07 xsa Exp $	*/
d293 2
a294 2
	(void)setvbuf(root->cr_srvin, NULL, _IOLBF, 0);
	(void)setvbuf(root->cr_srvout, NULL, _IOLBF, 0);
d433 1
a433 1
	buf = cvs_buf_alloc(512, BUF_AUTOEXT);
d438 1
a438 1
	    strlen(cvs_requests[0].req_str), 0);
d462 1
a462 1
	cvs_buf_copy(buf, 0, vrstr, len);
d516 1
a516 1
	buf = cvs_buf_alloc(512, BUF_AUTOEXT);
d521 1
a521 1
	    strlen(cvs_responses[0].resp_str), 0);
d545 1
a545 1
	cvs_buf_copy(buf, 0, vrstr, len);
d1188 2
a1189 2
	setvbuf(cvs_server_inlog, NULL, _IOLBF, 0);
	setvbuf(cvs_server_outlog, NULL, _IOLBF, 0);
@


1.73
log
@use correct return code where we exit();
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.72 2005/07/28 15:52:09 joris Exp $	*/
d754 1
a754 1
		if (fgets(cvs_proto_buf, sizeof(cvs_proto_buf),
d801 1
a801 1
	if (fgets(lbuf, len, in) == NULL) {
d870 1
a870 1
		if (fgets(cvs_proto_buf, sizeof(cvs_proto_buf),
@


1.72
log
@replace a dead documentation link with two alive ones.
dead link spotted by Nuno Morgadinho.

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.71 2005/07/27 14:15:24 xsa Exp $	*/
d272 1
a272 1
		exit(1);
@


1.71
log
@add trace message in cvs_connect(); ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.70 2005/07/26 20:58:44 moritz Exp $	*/
d32 2
a33 1
 *	http://www.loria.fr/~molli/cvs/doc/cvsclient_toc.html
@


1.70
log
@- fix SIZE_LEFT macro for the cb_cur > cb_buf case.
- make cvs_buf_empty() really clean the buffer.
- fix cvs_buf_copy() for the off > 0 case.
- some more minor buf code cleanup.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.69 2005/07/25 20:26:57 moritz Exp $	*/
d186 1
a186 1
	char *argv[16], *cvs_server_cmd, *vresp;
d259 9
@


1.69
log
@fix memleak. ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.68 2005/07/25 12:13:08 xsa Exp $	*/
d445 1
a445 1
	len = cvs_buf_size(buf);
d528 1
a528 1
	len = cvs_buf_size(buf);
@


1.68
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.67 2005/07/25 12:05:43 xsa Exp $	*/
d1095 1
@


1.67
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.66 2005/07/24 16:46:40 xsa Exp $	*/
d61 1
a61 1
#define CVS_REQF_RESP    0x01
d64 1
a64 1
static int  cvs_initlog   (void);
d149 2
a150 2
#define CVS_NBREQ   (sizeof(cvs_requests)/sizeof(cvs_requests[0]))
#define CVS_NBRESP  (sizeof(cvs_responses)/sizeof(cvs_responses[0]))
@


1.66
log
@do not use `if (!var)' unless it's boolean, better use an == check;
ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.65 2005/07/23 11:20:49 joris Exp $	*/
d415 1
a415 1
char*
d479 1
a479 1
struct cvs_resp*
d498 1
a498 1
char*
@


1.65
log
@remove debug messages, i always seem to forget these.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.64 2005/07/23 11:19:46 joris Exp $	*/
d326 2
a327 1
	if (cvs_noexec && (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-n") < 0))
d329 2
a330 1
	if (cvs_nolog && (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-l") < 0))
d332 2
a333 1
	if (cvs_readonly && (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-r") < 0))
d335 2
a336 1
	if (cvs_trace && (cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-t") < 0))
@


1.64
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.63 2005/07/23 00:44:13 joris Exp $	*/
a717 1
	printf("cvs_sendreq returning %d\n", ret);
a758 1
		printf("(%s) (%d)\n", cvs_proto_buf, ret);
@


1.63
log
@add missing "Remove-entry" response in cvs_responses table
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.62 2005/07/19 15:30:37 xsa Exp $	*/
d718 1
d760 1
@


1.62
log
@make the init command work;
tested aanriot@@ joris@@; Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.61 2005/07/19 00:51:01 joris Exp $	*/
d133 1
@


1.61
log
@if the user specifies the -Q flag (really quiet) we also
have to send the -q flag (quiet) to the server.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.60 2005/07/18 06:58:48 xsa Exp $	*/
d309 2
a310 3
	/* send the CVSROOT to the server unless it's an init */
	if ((cvs_cmdop != CVS_OP_INIT) &&
	    (cvs_sendreq(root, CVS_REQ_ROOT, root->cr_dir) < 0))
@


1.60
log
@use cvs_path_cat() where appropriate; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.59 2005/07/09 16:27:34 niallo Exp $	*/
d319 1
a319 1
	if ((verbosity == 1) &&
d322 1
a322 1
	else if ((verbosity == 0) &&
@


1.59
log
@convert snprintf with format string "%s" to an strlcpy.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.58 2005/07/07 14:27:57 joris Exp $	*/
d976 1
a976 1
	int l;
d989 3
a991 5
		l = snprintf(rbuf, sizeof(rbuf), "%s/%s", root->cr_dir,
		    dir->cf_repo);
		if (l == -1 || l >= (int)sizeof(rbuf)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", rbuf);
a992 1
		}
@


1.58
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.57 2005/06/10 21:32:08 joris Exp $	*/
d1104 1
a1104 1
			snprintf(fpath, sizeof(fpath), "%s", ctime(&now));
@


1.57
log
@

if the remote end doesn't support a version request,
send noop instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.56 2005/05/31 08:58:48 xsa Exp $	*/
d1119 1
a1119 1
		}	
@


1.56
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.55 2005/05/26 22:27:11 jfb Exp $	*/
d687 9
a695 3
		cvs_log(LP_WARN, "remote end does not support request `%s'",
		    req->req_str);
		return (-1);
@


1.55
log
@make cvs_getln() return the length of the line that was read, so we
don't have to call strlen() right after
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.54 2005/05/24 06:42:38 joris Exp $	*/
d46 1
d48 2
a50 2
#include <errno.h>
#include <libgen.h>
d52 1
a53 2
#include <string.h>
#include <pwd.h>
a54 1
#include "buf.h"
a56 1
#include "file.h"
@


1.54
log
@

as a client, the the Root response first, before trying to ask the version
from our server. This will prevent our server from screwing up in
cvs_startcmd().

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.53 2005/05/24 04:01:03 jfb Exp $	*/
a662 1

d769 2
d800 1
a800 1
	return (0);
d902 1
a902 1
			fputc('\n', cvs_server_inlog);
d906 1
a906 1
		fputc('\n', out);
@


1.53
log
@send the -n flag to the server as part of connection initialization
if it was given on the command-line
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.52 2005/05/23 20:13:39 joris Exp $	*/
d311 5
a334 5
		return (-1);

	/* now send the CVSROOT to the server unless it's an init */
	if ((cvs_cmdop != CVS_OP_INIT) &&
	    (cvs_sendreq(root, CVS_REQ_ROOT, root->cr_dir) < 0))
@


1.52
log
@

allow the CVS_CLIENT_LOG stuff to take variables which expand
into usefull information to create unique logfile names.

okay jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.51 2005/05/12 23:01:35 xsa Exp $	*/
d323 2
@


1.51
log
@snprintf checks; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.50 2005/05/09 19:24:07 joris Exp $	*/
d53 1
d1063 7
a1069 1
	char *env, fpath[MAXPATHLEN];
d1079 58
a1136 2
	strlcpy(fpath, env, sizeof(fpath));
	strlcat(fpath, ".in", sizeof(fpath));
d1144 17
a1160 2
	strlcpy(fpath, env, sizeof(fpath));
	strlcat(fpath, ".out", sizeof(fpath));
@


1.50
log
@

cvs_getln() can fail and return -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.49 2005/04/22 15:16:15 joris Exp $	*/
d546 1
a546 1
	int fd;
d571 4
a574 1
	snprintf(buf, sizeof(buf), "%lld\n", st.st_size);
d671 1
a671 1
	int ret;
d692 1
a692 1
	snprintf(cvs_proto_buf, sizeof(cvs_proto_buf), "%s%s%s\n",
d694 2
d968 1
d980 2
a981 2
	else
		snprintf(rbuf, sizeof(rbuf), "%s/%s", root->cr_dir,
d983 6
d1025 1
d1037 1
a1037 1
	snprintf(ebuf, sizeof(ebuf), "/%s/%s%s///", file->cf_name,
d1040 5
@


1.49
log
@

finish support for the '-' token in the Entry file, this allows
us to mark files as removed, and lets the remove command work
completely.

tested and ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.48 2005/04/18 23:56:19 joris Exp $	*/
d621 4
a624 1
	cvs_getln(root, buf, sizeof(buf));
@


1.48
log
@

don't send an Entry reply to the server for unknown files,
fixes "foo is not (any longer) pertinent" errors
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.47 2005/04/18 21:02:50 jfb Exp $	*/
d1021 2
a1022 1
	snprintf(ebuf, sizeof(ebuf), "/%s/%s///", file->cf_name,
@


1.47
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.46 2005/04/03 17:32:50 xsa Exp $	*/
d1016 4
@


1.46
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.45 2005/03/30 17:43:04 joris Exp $	*/
d962 3
d969 1
a969 1
	if (dir->cf_ddat->cd_repo == NULL)
d973 1
a973 1
		    dir->cf_ddat->cd_repo);
d1008 1
a1008 1
cvs_sendentry(struct cvsroot *root, const struct cvs_ent *ent)
d1012 7
a1018 2
	snprintf(ebuf, sizeof(ebuf), "/%s/%s///", ent->ce_name,
	    rcsnum_tostr(ent->ce_rev, numbuf, sizeof(numbuf)));
@


1.45
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.44 2005/03/26 08:09:54 tedu Exp $	*/
a52 1
#include <sysexits.h>
d262 1
a262 1
		exit(EX_OSERR);
@


1.44
log
@fix a variety of things i found at coverity.  ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.43 2005/03/13 19:56:14 joris Exp $	*/
d964 1
a964 1
	if (strcmp(lbuf, cvs_lastdir) == 0)
@


1.43
log
@

unbreak, and do this correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.42 2005/03/13 19:52:26 joris Exp $	*/
d464 1
a464 1
	for (i = 0; i < CVS_NBREQ; i++)
d480 1
a480 1
	for (i = 0; i < CVS_NBREQ; i++)
d618 1
d627 1
@


1.42
log
@

simplify if {} else {} case.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.41 2005/03/04 18:36:57 joris Exp $	*/
d739 1
a739 1
			if (cvs_proto_buf[len - 1] == '\n') {
@


1.41
log
@

add missing 'add' request in cvs_request table.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.40 2005/02/04 18:16:40 jfb Exp $	*/
d738 2
a739 3
			if (cvs_proto_buf[len - 1] != '\n') {
				/* truncated line */
			} else
@


1.40
log
@cleanup and additional error checking on connection setup
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.39 2005/01/14 20:58:43 jfb Exp $	*/
d118 1
@


1.39
log
@minor knf and cleanup, and remove unneeded extern declarations, they
are now in cvs.h
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.38 2005/01/14 20:54:48 jfb Exp $	*/
a281 8
#if 0
	root->cr_srverr = fdopen(errfd[0], "r");
	if (root->cr_srverr == NULL) {
		cvs_log(LP_ERR, "failed to create pipe stream");
		return (-1);
	}
#endif

d293 1
a293 2
	vresp = cvs_resp_getvalid();
	if (vresp == NULL) {
d299 3
d310 1
d312 1
a312 1
		cvs_log(LP_ERR, "failed to get remote version");
d315 13
a327 11
	if (verbosity == 1)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-q");
	else if (verbosity == 0)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-Q");

	if (cvs_nolog)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-l");
	if (cvs_readonly)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-r");
	if (cvs_trace)
		cvs_sendreq(root, CVS_REQ_GLOBALOPT, "-t");
a336 4

#ifdef CVS_ZLIB
	/* if compression was requested, initialize it */
#endif
@


1.38
log
@sprinkle more error reporting and add a trace when sending a file
to the server
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.37 2004/12/22 00:38:25 david Exp $	*/
a51 1
#include <signal.h>
a53 3
#ifdef CVS_ZLIB
#include <zlib.h>
#endif
a65 8
extern int   verbosity;
extern int   cvs_compress;
extern char *cvs_rsh;
extern int   cvs_trace;
extern int   cvs_nolog;
extern int   cvs_readonly;
extern int   cvs_cmdop;

a499 1

a594 1

a597 1

@


1.37
log
@spelling corrections; ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.36 2004/12/16 17:09:33 jfb Exp $	*/
d49 1
d571 2
d583 1
d587 4
a590 1
	cvs_sendln(root, buf);
d592 4
a595 1
	cvs_sendln(root, buf);
d604 4
a607 1
		cvs_sendraw(root, buf, (size_t)ret);
d938 1
@


1.36
log
@make cvs_connect() print an error message and return with an error
code if an unsupported connection method is specified in the
root specification, and warn that pserver will never be supported due
to its poor security
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.35 2004/12/14 17:52:37 jfb Exp $	*/
d169 1
a169 1
 * Output files for protocol logging when the CVS_CLIENT_LOG enviroment
d720 1
a720 1
 * non-zero (either an error occured or the end of the response was reached).
@


1.35
log
@missing `tag' request in the request table

from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.34 2004/12/08 19:28:10 jfb Exp $	*/
d199 10
a261 1

d676 1
a676 1
		cvs_log(LP_ERR, "cannot send request: Not connected");
@


1.34
log
@support for the `Copy-file' response
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.33 2004/12/08 16:07:43 jfb Exp $	*/
d128 1
@


1.33
log
@add a small protection to avoid reconnecting to a server to which we
are already connected.  instead, cvs will print a notice.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.32 2004/12/08 05:36:14 jfb Exp $	*/
d156 1
@


1.32
log
@avoid resending a directory if it was the last directory sent to the
server
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.31 2004/12/07 17:10:56 tedu Exp $	*/
d197 6
d347 2
d361 3
d373 2
@


1.31
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.30 2004/12/06 21:03:12 deraadt Exp $	*/
d176 3
d936 3
a938 1
 * Send a `Directory' request along with the 2 paths that follow it.
d945 4
a954 1
	cvs_file_getpath(dir, lbuf, sizeof(lbuf));
d959 2
@


1.30
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.c,v 1.29 2004/12/02 19:23:44 jfb Exp $	*/
a68 2


a76 2


a78 1

a129 1

a163 1

a187 1

a346 1

a365 1

d374 1
a381 1

a400 1

a448 1

d457 1
a464 1

a534 1

a583 1

a641 1

a695 1

a740 1

a779 1

a811 1

a849 1

a884 1

a909 1

a934 1

d936 1
a936 1
cvs_senddir(struct cvsroot *root, CVSFILE *dir) 
a962 1

a976 1

a997 1

@


1.29
log
@This commit is brought to you by the brand new improved and better tasting
OpenCVS commit code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d230 1
a230 2
	}
	else if (cvs_subproc_pid == 0) {
d737 1
a737 2
			}
			else
d813 1
a813 2
	}
	else {
d852 1
a852 2
			}
			else
@


1.28
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@d132 1
@


1.27
log
@more correct error checking, from Joris Vink <amni at pandora dot be>
@
text
@d180 2
a198 1
	pid_t pid;
d225 2
a226 2
	pid = fork();
	if (pid == -1) {
d230 1
a230 1
	if (pid == 0) {
d964 1
a964 1
	char buf[MAXPATHLEN];
d967 1
a967 1
		strlcpy(buf, root->cr_dir, sizeof(buf));
d969 1
a969 1
		snprintf(buf, sizeof(buf), "%s/%s", root->cr_dir,
d972 4
a975 2
	if ((cvs_sendreq(root, CVS_REQ_DIRECTORY, dir->cf_path) < 0) ||
	    (cvs_sendln(root, buf) < 0))
@


1.26
log
@Fix some issues in the protocol dispatch table:
- set the 'log', 'history', 'rdiff' and 'rtag' commands to require
  a response
- replace the entry for 'rannotate' (which doesn't exist) with
  'annotate' and also remove 'rlog' (which doesn't exist either)
@
text
@d443 4
a448 1

d528 4
@


1.25
log
@Lower the level of an error message
@
text
@d112 1
a112 1
	{ CVS_REQ_LOG,           "log",               0             },
d115 2
a116 3
	{ CVS_REQ_RANNOTATE,     "rannotate",         0             },
	{ CVS_REQ_RDIFF,         "rdiff",             0             },
	{ CVS_REQ_RLOG,          "rlog",              0             },
d121 1
a121 1
	{ CVS_REQ_HISTORY,       "history",           0             },
@


1.24
log
@Fix two descriptor leaks
@
text
@d669 1
a669 1
		cvs_log(LP_ERR, "remote end does not support request `%s'",
@


1.23
log
@Leave stderr alone for the moment
@
text
@d554 3
a561 3
	if (cvs_modetostr(st.st_mode, buf, sizeof(buf)) < 0)
		return (-1);

d568 1
@


1.22
log
@Don't attempt to send the `Root' request if the operation is an `init'
@
text
@d232 1
a232 2
		    (dup2(outfd[1], STDOUT_FILENO) == -1) ||
		    (dup2(errfd[1], STDERR_FILENO) == -1)) {
@


1.21
log
@Don't bother about the server's standard error just yet
@
text
@d332 3
a334 2
	/* now send the CVSROOT to the server */
	if (cvs_sendreq(root, CVS_REQ_ROOT, root->cr_dir) < 0)
@


1.20
log
@When spawning the subprocess for the connection, attach a pipe to its
standard error as well
@
text
@d282 1
d288 1
@


1.19
log
@* set the maximum number of arguments to 256 for the moment
* cvs_sendresp() is now required, so uncomment it
@
text
@d197 1
a197 1
	int argc, infd[2], outfd[2];
d215 10
d232 2
a233 1
		    (dup2(outfd[1], STDOUT_FILENO) == -1)) {
d240 1
d253 1
a253 1
			cvs_server_cmd = "cvs";
d268 1
d279 6
@


1.18
log
@Move all of the request- and response-specific handlers into separate
files and have only the generic function of each type available to
the outside
@
text
@d761 1
a761 1
#ifdef notyet
d765 1
a765 1
 * Send a response to the client of type <rid>, with optional arguments
d774 1
a774 2
	size_t len;
	const char *resp;
d782 1
a782 4
	snprintf(cvs_proto_buf, sizeof(cvs_proto_buf), "%s %s\n", resp,
	    (arg == NULL) ? "" : arg);

	ret = fputs(resp, stdout);
d787 4
a790 2
		if (arg != NULL)
			ret = fprintf(stdout, " %s", arg);
d797 1
@


1.17
log
@When we connect to a remote server, always send the Version request and
add a hack so we don't print it (we receive it through a 'M') but store
it in the cvs root structure instead.  This will allow us to make better
decisions in what we use to communicate with the remote server.
@
text
@a64 2
#define CVS_MTSTK_MAXDEPTH   16

d77 1
a80 16
static int  cvs_resp_validreq  (struct cvsroot *, int, char *);
static int  cvs_resp_cksum     (struct cvsroot *, int, char *);
static int  cvs_resp_modtime   (struct cvsroot *, int, char *);
static int  cvs_resp_m         (struct cvsroot *, int, char *);
static int  cvs_resp_ok        (struct cvsroot *, int, char *);
static int  cvs_resp_error     (struct cvsroot *, int, char *);
static int  cvs_resp_statdir   (struct cvsroot *, int, char *);
static int  cvs_resp_sticky    (struct cvsroot *, int, char *);
static int  cvs_resp_newentry  (struct cvsroot *, int, char *);
static int  cvs_resp_updated   (struct cvsroot *, int, char *);
static int  cvs_resp_removed   (struct cvsroot *, int, char *);
static int  cvs_resp_mode      (struct cvsroot *, int, char *);
static int  cvs_resp_modxpand  (struct cvsroot *, int, char *);
static int  cvs_resp_rcsdiff   (struct cvsroot *, int, char *);
static int  cvs_resp_template  (struct cvsroot *, int, char *);

a82 6
static const char *cvs_months[] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};


d84 49
a132 54
struct cvs_req {
	int      req_id;
	char     req_str[32];
	u_int    req_flags;
	int     (*req_hdlr)(int, char *);
} cvs_requests[] = {
	{ CVS_REQ_DIRECTORY,     "Directory",         0,  NULL },
	{ CVS_REQ_MAXDOTDOT,     "Max-dotdot",        0,  NULL },
	{ CVS_REQ_STATICDIR,     "Static-directory",  0,  NULL },
	{ CVS_REQ_STICKY,        "Sticky",            0,  NULL },
	{ CVS_REQ_ENTRY,         "Entry",             0,  NULL },
	{ CVS_REQ_ENTRYEXTRA,    "EntryExtra",        0,  NULL },
	{ CVS_REQ_CHECKINTIME,   "Checkin-time",      0,  NULL },
	{ CVS_REQ_MODIFIED,      "Modified",          0,  NULL },
	{ CVS_REQ_ISMODIFIED,    "Is-modified",       0,  NULL },
	{ CVS_REQ_UNCHANGED,     "Unchanged",         0,  NULL },
	{ CVS_REQ_USEUNCHANGED,  "UseUnchanged",      0,  NULL },
	{ CVS_REQ_NOTIFY,        "Notify",            0,  NULL },
	{ CVS_REQ_NOTIFYUSER,    "NotifyUser",        0,  NULL },
	{ CVS_REQ_QUESTIONABLE,  "Questionable",      0,  NULL },
	{ CVS_REQ_CASE,          "Case",              0,  NULL },
	{ CVS_REQ_UTF8,          "Utf8",              0,  NULL },
	{ CVS_REQ_ARGUMENT,      "Argument",          0,  NULL },
	{ CVS_REQ_ARGUMENTX,     "Argumentx",         0,  NULL },
	{ CVS_REQ_GLOBALOPT,     "Global_option",     0,  NULL },
	{ CVS_REQ_GZIPSTREAM,    "Gzip-stream",       0,  NULL },
	{ CVS_REQ_READCVSRC2,    "read-cvsrc2",       0,  NULL },
	{ CVS_REQ_READWRAP,      "read-cvswrappers",  0,  NULL },
	{ CVS_REQ_READIGNORE,    "read-cvsignore",    0,  NULL },
	{ CVS_REQ_ERRIFREADER,   "Error-If-Reader",   0,  NULL },
	{ CVS_REQ_VALIDRCSOPT,   "Valid-RcsOptions",  0,  NULL },
	{ CVS_REQ_SET,           "Set",               0,  NULL },
	{ CVS_REQ_XPANDMOD,      "expand-modules",    CVS_REQF_RESP,  NULL },
	{ CVS_REQ_LOG,           "log",               0,  NULL },
	{ CVS_REQ_CO,            "co",                CVS_REQF_RESP,  NULL },
	{ CVS_REQ_EXPORT,        "export",            CVS_REQF_RESP,  NULL },
	{ CVS_REQ_RANNOTATE,     "rannotate",         0,  NULL },
	{ CVS_REQ_RDIFF,         "rdiff",             0,  NULL },
	{ CVS_REQ_RLOG,          "rlog",              0,  NULL },
	{ CVS_REQ_RTAG,          "rtag",              CVS_REQF_RESP,  NULL },
	{ CVS_REQ_INIT,          "init",              CVS_REQF_RESP,  NULL },
	{ CVS_REQ_STATUS,        "status",            CVS_REQF_RESP,  NULL },
	{ CVS_REQ_UPDATE,        "update",            CVS_REQF_RESP,  NULL },
	{ CVS_REQ_HISTORY,       "history",           0,  NULL },
	{ CVS_REQ_IMPORT,        "import",            CVS_REQF_RESP,  NULL },
	{ CVS_REQ_ADD,           "add",               CVS_REQF_RESP,  NULL },
	{ CVS_REQ_REMOVE,        "remove",            CVS_REQF_RESP,  NULL },
	{ CVS_REQ_RELEASE,       "release",           CVS_REQF_RESP,  NULL },
	{ CVS_REQ_ROOT,          "Root",              0,  NULL },
	{ CVS_REQ_VALIDRESP,     "Valid-responses",   0,  NULL },
	{ CVS_REQ_VALIDREQ,      "valid-requests",    CVS_REQF_RESP,  NULL },
	{ CVS_REQ_VERSION,       "version",           CVS_REQF_RESP,  NULL },
	{ CVS_REQ_NOOP,          "noop",              CVS_REQF_RESP,  NULL },
	{ CVS_REQ_DIFF,          "diff",              CVS_REQF_RESP,  NULL },
d136 26
a161 30
struct cvs_resp {
	u_int  resp_id;
	char   resp_str[32];
	int  (*resp_hdlr)(struct cvsroot *, int, char *);
} cvs_responses[] = {
	{ CVS_RESP_OK,         "ok",                     cvs_resp_ok       },
	{ CVS_RESP_ERROR,      "error",                  cvs_resp_error    },
	{ CVS_RESP_VALIDREQ,   "Valid-requests",         cvs_resp_validreq },
	{ CVS_RESP_M,          "M",                      cvs_resp_m        },
	{ CVS_RESP_MBINARY,    "Mbinary",                cvs_resp_m        },
	{ CVS_RESP_MT,         "MT",                     cvs_resp_m        },
	{ CVS_RESP_E,          "E",                      cvs_resp_m        },
	{ CVS_RESP_F,          "F",                      cvs_resp_m        },
	{ CVS_RESP_CREATED,    "Created",                cvs_resp_updated  },
	{ CVS_RESP_UPDATED,    "Updated",                cvs_resp_updated  },
	{ CVS_RESP_UPDEXIST,   "Update-existing",        cvs_resp_updated  },
	{ CVS_RESP_MERGED,     "Merged",                 cvs_resp_updated  },
	{ CVS_RESP_REMOVED,    "Removed",                cvs_resp_removed  },
	{ CVS_RESP_CKSUM,      "Checksum",               cvs_resp_cksum    },
	{ CVS_RESP_CLRSTATDIR, "Clear-static-directory", cvs_resp_statdir  },
	{ CVS_RESP_SETSTATDIR, "Set-static-directory",   cvs_resp_statdir  },
	{ CVS_RESP_NEWENTRY,   "New-entry",              cvs_resp_newentry },
	{ CVS_RESP_CHECKEDIN,  "Checked-in",             cvs_resp_newentry },
	{ CVS_RESP_MODE,       "Mode",                   cvs_resp_mode     },
	{ CVS_RESP_MODTIME,    "Mod-time",               cvs_resp_modtime  },
	{ CVS_RESP_MODXPAND,   "Module-expansion",       cvs_resp_modxpand },
	{ CVS_RESP_SETSTICKY,  "Set-sticky",             cvs_resp_sticky   },
	{ CVS_RESP_CLRSTICKY,  "Clear-sticky",           cvs_resp_sticky   },
	{ CVS_RESP_RCSDIFF,    "Rcs-diff",               cvs_resp_rcsdiff  },
	{ CVS_RESP_TEMPLATE,   "Template",               cvs_resp_template },
a166 21

/*
 * The MT command uses scoping to tag the data.  Whenever we encouter a '+',
 * we push the name of the tag on the stack, and we pop it when we encounter
 * a '-' with the same name.
 */

static char *cvs_mt_stack[CVS_MTSTK_MAXDEPTH];
static u_int cvs_mtstk_depth = 0;

static time_t cvs_modtime = 0;


/* mask of requets supported by server */
static u_char  cvs_server_validreq[CVS_REQ_MAX + 1];

/* last checksum received */
char *cvs_fcksum = NULL;

mode_t  cvs_lastmode = 0;

d168 1
a168 1
static u_int cvs_version_sent = 0;
a432 37
 * cvs_req_handle()
 *
 * Generic request handler dispatcher.
 */

int
cvs_req_handle(char *line)
{
	u_int i;
	char *cp, *cmd;

	cmd = line;

	cp = strchr(cmd, ' ');
	if (cp != NULL)
		*(cp++) = '\0';

	for (i = 0; i < CVS_NBREQ; i++) {
		if (strcmp(cvs_requests[i].req_str, cmd) == 0) {
			if (cvs_requests[i].req_hdlr == NULL) {
				cvs_log(LP_ERR,
				    "unimplemented request handler for `%s'",
				    cmd);
				break;
			}
			else
				return (*cvs_requests[i].req_hdlr)
				    (cvs_requests[i].req_id, cp);
		}
	}

	/* unhandled */
	return (-1);
}


/*
a513 598
 * cvs_resp_handle()
 *
 * Generic response handler dispatcher.  The handler expects the first line
 * of the command as single argument.
 * Returns the return value of the command on success, or -1 on failure.
 */

int
cvs_resp_handle(struct cvsroot *root, char *line)
{
	u_int i;
	char *cp, *cmd;

	cmd = line;

	cp = strchr(cmd, ' ');
	if (cp != NULL)
		*(cp++) = '\0';

	for (i = 0; i < CVS_NBRESP; i++) {
		if (strcmp(cvs_responses[i].resp_str, cmd) == 0) {
			if (cvs_responses[i].resp_hdlr == NULL) {
				cvs_log(LP_ERRNO,
				    "unimplemented response handler for `%s'",
				    cmd);
				return (-1);
			}
			else
				return (*cvs_responses[i].resp_hdlr)
				    (root, cvs_responses[i].resp_id, cp);
		}
	}

	/* unhandled */
	return (-1);
}


/*
 * cvs_resp_validreq()
 *
 * Handler for the `Valid-requests' response.  The list of valid requests is
 * split on spaces and each request's entry in the valid request array is set
 * to 1 to indicate the validity.
 * Returns 0 on success, or -1 on failure.
 */

static int
cvs_resp_validreq(struct cvsroot *root, int type, char *line)
{
	char *sp, *ep;
	struct cvs_req *req;

	/* parse the requests */
	sp = line;
	do {
		ep = strchr(sp, ' ');
		if (ep != NULL)
			*ep = '\0';

		req = cvs_req_getbyname(sp);
		if (req != NULL)
			cvs_server_validreq[req->req_id] = 1;

		if (ep != NULL)
			sp = ep + 1;
	} while (ep != NULL);

	return (0);
}


/*
 * cvs_resp_m()
 *
 * Handler for the `M', 'MT', `F' and `E' responses.
 */

static int
cvs_resp_m(struct cvsroot *root, int type, char *line)
{
	char *cp;
	FILE *stream;

	stream = NULL;

	switch (type) {
	case CVS_RESP_F:
		fflush(stderr);
		return (0);
	case CVS_RESP_M:
		if (cvs_version_sent) {
			/*
			 * Instead of outputting the line, we save it as the
			 * remote server's version string.
			 */
			cvs_version_sent = 0;
			root->cr_version = strdup(line);
			return (0);
		}
		stream = stdout;
		break;
	case CVS_RESP_E:
		stream = stderr;
		break;
	case CVS_RESP_MT:
		if (*line == '+') {
			if (cvs_mtstk_depth == CVS_MTSTK_MAXDEPTH) {
				cvs_log(LP_ERR,
				    "MT scope stack has reached max depth");
				return (-1);
			}
			cvs_mt_stack[cvs_mtstk_depth] = strdup(line + 1);
			if (cvs_mt_stack[cvs_mtstk_depth] == NULL)
				return (-1);
			cvs_mtstk_depth++;
		}
		else if (*line == '-') {
			if (cvs_mtstk_depth == 0) {
				cvs_log(LP_ERR, "MT scope stack underflow");
				return (-1);
			}
			else if (strcmp(line + 1,
			    cvs_mt_stack[cvs_mtstk_depth - 1]) != 0) {
				cvs_log(LP_ERR, "mismatch in MT scope stack");
				return (-1);
			}
			free(cvs_mt_stack[cvs_mtstk_depth--]);
		}
		else {
			if (strcmp(line, "newline") == 0)
				putc('\n', stdout);
			else if (strncmp(line, "fname ", 6) == 0)
				printf("%s", line + 6);
			else {
				/* assume text */
				cp = strchr(line, ' ');
				if (cp != NULL)
					printf("%s", cp + 1);
			}
		}

		return (0);
	case CVS_RESP_MBINARY:
		cvs_log(LP_WARN, "Mbinary not supported in client yet");
		break;
	}

	fputs(line, stream);
	fputc('\n', stream);

	return (0);
}


/*
 * cvs_resp_ok()
 *
 * Handler for the `ok' response.  This handler's job is to 
 */

static int
cvs_resp_ok(struct cvsroot *root, int type, char *line)
{
	return (1);
}


/*
 * cvs_resp_error()
 *
 * Handler for the `error' response.  This handler's job is to 
 */

static int
cvs_resp_error(struct cvsroot *root, int type, char *line)
{
	return (1);
}


/*
 * cvs_resp_statdir()
 *
 * Handler for the `Clear-static-directory' and `Set-static-directory'
 * responses.
 */

static int
cvs_resp_statdir(struct cvsroot *root, int type, char *line)
{
	int fd;
	char rpath[MAXPATHLEN], statpath[MAXPATHLEN];

	cvs_getln(root, rpath, sizeof(rpath));

	snprintf(statpath, sizeof(statpath), "%s/%s", line,
	    CVS_PATH_STATICENTRIES);

	if ((type == CVS_RESP_CLRSTATDIR) &&
	    (unlink(statpath) == -1) && (errno != ENOENT)) {
		cvs_log(LP_ERRNO, "failed to unlink %s file",
		    CVS_PATH_STATICENTRIES);
		return (-1);
	}
	else if (type == CVS_RESP_SETSTATDIR) {
		fd = open(statpath, O_CREAT|O_TRUNC|O_WRONLY, 0400);
		if (fd == -1) {
			cvs_log(LP_ERRNO, "failed to create %s file",
			    CVS_PATH_STATICENTRIES);
			return (-1);
		}
		(void)close(fd);

	}

	return (0);
}

/*
 * cvs_resp_sticky()
 *
 * Handler for the `Clear-sticky' and `Set-sticky' responses.
 */

static int
cvs_resp_sticky(struct cvsroot *root, int type, char *line)
{
	size_t len;
	char rpath[MAXPATHLEN];
	struct stat st;
	CVSFILE *cf;

	/* remove trailing slash */
	len = strlen(line);
	if ((len > 0) && (line[len - 1] == '/'))
		line[--len] = '\0';

	/* get the remote path */
	cvs_getln(root, rpath, sizeof(rpath));

	/* if the directory doesn't exist, create it */
	if (stat(line, &st) == -1) {
		/* attempt to create it */
		if (errno != ENOENT) {
			cvs_log(LP_ERRNO, "failed to stat %s", line);
		}
		else {
			cf = cvs_file_create(line, DT_DIR, 0755);
			if (cf == NULL)
				return (-1);
			cf->cf_ddat->cd_repo = strdup(line);
			cf->cf_ddat->cd_root = root;
			root->cr_ref++;
			cvs_mkadmin(cf, 0755);

			cvs_file_free(cf);
		}
	}

	if (type == CVS_RESP_CLRSTICKY) {
	}
	else if (type == CVS_RESP_SETSTICKY) {
	}

	return (0);
}


/*
 * cvs_resp_newentry()
 *
 * Handler for the `New-entry' response and `Checked-in' responses.
 */

static int
cvs_resp_newentry(struct cvsroot *root, int type, char *line)
{
	char entbuf[128];
	CVSENTRIES *entfile;

	/* get the remote path */
	cvs_getln(root, entbuf, sizeof(entbuf));

	/* get the new Entries line */
	if (cvs_getln(root, entbuf, sizeof(entbuf)) < 0)
		return (-1);

	entfile = cvs_ent_open(line, O_WRONLY);
	if (entfile == NULL)
		return (-1);
	cvs_ent_addln(entfile, entbuf);
	cvs_ent_close(entfile);

	return (0);
}


/*
 * cvs_resp_cksum()
 *
 * Handler for the `Checksum' response.  We store the checksum received for
 * the next file in a dynamically-allocated buffer pointed to by <cvs_fcksum>.
 * Upon next file reception, the handler checks to see if there is a stored
 * checksum.
 * The file handler must make sure that the checksums match and free the
 * checksum buffer once it's done to indicate there is no further checksum.
 */

static int
cvs_resp_cksum(struct cvsroot *root, int type, char *line)
{
	if (cvs_fcksum != NULL) {
		cvs_log(LP_WARN, "unused checksum");
		free(cvs_fcksum);
	}

	cvs_fcksum = strdup(line);
	if (cvs_fcksum == NULL) {
		cvs_log(LP_ERRNO, "failed to copy checksum string");
		return (-1);
	}

	return (0);
}


/*
 * cvs_resp_modtime()
 *
 * Handler for the `Mod-time' file update modifying response.  The timestamp
 * given is used to set the last modification time on the next file that
 * will be received.
 */

static int
cvs_resp_modtime(struct cvsroot *root, int type, char *line)
{
	int i;
	long off;
	char sign, mon[8], gmt[8], hr[4], min[4], *ep;
	struct tm cvs_tm;

	memset(&cvs_tm, 0, sizeof(cvs_tm));
	sscanf(line, "%d %3s %d %2d:%2d:%2d %5s", &cvs_tm.tm_mday, mon,
	    &cvs_tm.tm_year, &cvs_tm.tm_hour, &cvs_tm.tm_min,
	    &cvs_tm.tm_sec, gmt);
	cvs_tm.tm_year -= 1900;
	cvs_tm.tm_isdst = -1;

	if (*gmt == '-') {
		sscanf(gmt, "%c%2s%2s", &sign, hr, min);
		cvs_tm.tm_gmtoff = strtol(hr, &ep, 10);
		if ((cvs_tm.tm_gmtoff == LONG_MIN) ||
		    (cvs_tm.tm_gmtoff == LONG_MAX) ||
		    (*ep != '\0')) {
			cvs_log(LP_ERR,
			    "parse error in GMT hours specification `%s'", hr);
			cvs_tm.tm_gmtoff = 0;
		}
		else {
			/* get seconds */
			cvs_tm.tm_gmtoff *= 3600;

			/* add the minutes */
			off = strtol(min, &ep, 10);
			if ((cvs_tm.tm_gmtoff == LONG_MIN) ||
			    (cvs_tm.tm_gmtoff == LONG_MAX) ||
			    (*ep != '\0')) {
				cvs_log(LP_ERR,
				    "parse error in GMT minutes "
				    "specification `%s'", min);
			}
			else
				cvs_tm.tm_gmtoff += off * 60;
		}
	}
	if (sign == '-')
		cvs_tm.tm_gmtoff = -cvs_tm.tm_gmtoff;

	for (i = 0; i < (int)(sizeof(cvs_months)/sizeof(cvs_months[0])); i++) {
		if (strcmp(cvs_months[i], mon) == 0) {
			cvs_tm.tm_mon = i;
			break;
		}
	}

	cvs_modtime = mktime(&cvs_tm);
	return (0);
}


/*
 * cvs_resp_updated()
 *
 * Handler for the `Updated' and `Created' responses.
 */

static int
cvs_resp_updated(struct cvsroot *root, int type, char *line)
{
	size_t len;
	mode_t fmode;
	char tbuf[32], path[MAXPATHLEN], cksum_buf[CVS_CKSUM_LEN];
	BUF *fbuf;
	CVSENTRIES *ef;
	struct cvs_ent *ep;

	ep = NULL;

	len = strlen(tbuf);
	if ((len > 0) && (tbuf[len - 1] == '\n'))
		tbuf[--len] = '\0';

	/* read the remote path of the file */
	cvs_getln(root, path, sizeof(path));

	/* read the new entry */
	cvs_getln(root, path, sizeof(path));
	ep = cvs_ent_parse(path);
	if (ep == NULL)
		return (-1);
	snprintf(path, sizeof(path), "%s/%s", line, ep->ce_name);


	if (type == CVS_RESP_CREATED) {
		/* set the timestamp as the last one received from Mod-time */
		ep->ce_timestamp = ctime_r(&cvs_modtime, tbuf);

		ef = cvs_ent_open(line, O_WRONLY);
		if (ef == NULL)
			return (-1);

		cvs_ent_add(ef, ep);
		cvs_ent_close(ef);
	}
	else if (type == CVS_RESP_UPDEXIST) {
	}
	else if (type == CVS_RESP_UPDATED) {
	}

	fbuf = cvs_recvfile(root, &fmode);
	if (fbuf == NULL)
		return (-1);

	cvs_buf_write(fbuf, path, fmode);

	/* now see if there is a checksum */
	if (cvs_fcksum != NULL) {
		if (cvs_cksum(path, cksum_buf, sizeof(cksum_buf)) < 0) {
		}

		if (strcmp(cksum_buf, cvs_fcksum) != 0) {
			cvs_log(LP_ERR, "checksum error on received file");
			(void)unlink(line);
		}

		free(cvs_fcksum);
		cvs_fcksum = NULL;
	}

	return (0);
}


/*
 * cvs_resp_removed()
 *
 * Handler for the `Updated' response.
 */

static int
cvs_resp_removed(struct cvsroot *root, int type, char *line)
{
	return (0);
}


/*
 * cvs_resp_mode()
 *
 * Handler for the `Mode' response.
 */

static int
cvs_resp_mode(struct cvsroot *root, int type, char *line)
{
	if (cvs_strtomode(line, &cvs_lastmode) < 0) {
		return (-1);
	}
	return (0);
}


/*
 * cvs_resp_modxpand()
 *
 * Handler for the `Module-expansion' response.
 */

static int
cvs_resp_modxpand(struct cvsroot *root, int type, char *line)
{
	return (0);
}

/*
 * cvs_resp_rcsdiff()
 *
 * Handler for the `Rcs-diff' response.
 */

static int
cvs_resp_rcsdiff(struct cvsroot *root, int type, char *line)
{
	char file[MAXPATHLEN], buf[MAXPATHLEN], cksum_buf[CVS_CKSUM_LEN];
	char *fname, *orig, *patch;
	mode_t fmode;
	BUF *res, *fcont, *patchbuf;
	CVSENTRIES *entf;
	struct cvs_ent *ent;

	/* get remote path and build local path of file to be patched */
	cvs_getln(root, buf, sizeof(buf));
	fname = strrchr(buf, '/');
	if (fname == NULL)
		fname = buf;
	snprintf(file, sizeof(file), "%s%s", line, fname);

	/* get updated entry fields */
	cvs_getln(root, buf, sizeof(buf));
	ent = cvs_ent_parse(buf);
	if (ent == NULL) {
		return (-1);
	}

	patchbuf = cvs_recvfile(root, &fmode);
	fcont = cvs_buf_load(file, BUF_AUTOEXT);
	if (fcont == NULL)
		return (-1);

	cvs_buf_putc(patchbuf, '\0');
	cvs_buf_putc(fcont, '\0');
	orig = cvs_buf_release(fcont);
	patch = cvs_buf_release(patchbuf);

	res = rcs_patch(orig, patch);
	if (res == NULL)
		return (-1);

	cvs_buf_write(res, file, fmode);

	/* now see if there is a checksum */
	if (cvs_fcksum != NULL) {
		if (cvs_cksum(file, cksum_buf, sizeof(cksum_buf)) < 0) {
		}

		if (strcmp(cksum_buf, cvs_fcksum) != 0) {
			cvs_log(LP_ERR, "checksum error on received file");
			(void)unlink(file);
		}

		free(cvs_fcksum);
		cvs_fcksum = NULL;
	}

	/* update revision in entries */
	entf = cvs_ent_open(line, O_WRONLY);
	if (entf == NULL)
		return (-1);

	cvs_ent_close(entf);

	return (0);
}


/*
 * cvs_resp_template()
 *
 * Handler for the `Template' response.
 */

static int
cvs_resp_template(struct cvsroot *root, int type, char *line)
{
	mode_t mode;
	BUF *tmpl;

	tmpl = cvs_recvfile(root, &mode);
	if (tmpl == NULL)
		return (-1);

	return (0);
}


/*
d645 7
d726 1
a726 1
 * Get a line from the server's output and store it in <lbuf>.  The terminating
d734 1
d736 8
a743 3
	if (fgets(lbuf, len, root->cr_srvout) == NULL) {
		if (ferror(root->cr_srvout)) {
			cvs_log(LP_ERRNO, "failed to read line from server");
d747 1
a747 1
		if (feof(root->cr_srvout))
d840 1
a840 1
 * Send a single line <line> string to the server.  The line is sent as is,
d850 6
d868 1
a868 1
	fputs(line, root->cr_srvin);
d870 1
a870 2
		fputc('\n', root->cr_srvin);

d884 7
d893 1
a893 1
	if (fwrite(src, sizeof(char), len, root->cr_srvin) < len) {
d911 6
d918 1
a918 1
	ret = fread(dst, sizeof(char), len, root->cr_srvout);
@


1.16
log
@* copy most of the code from cvs_resp_handle() into cvs_req_handle()
  and add some protection for unimplemented handlers
* add a bogus handler for the `Template' response, which we'll handle
  soon
@
text
@d196 9
a211 3
#define CVS_NBREQ   (sizeof(cvs_requests)/sizeof(cvs_requests[0]))
#define CVS_NBRESP  (sizeof(cvs_responses)/sizeof(cvs_responses[0]))

d215 1
d220 4
d241 3
d348 3
d695 9
d1344 3
@


1.15
log
@Minor bug fixes
@
text
@d96 1
d193 1
d477 25
a501 1
	return (0);
d607 11
a617 3
		if (strcmp(cvs_responses[i].resp_str, cmd) == 0)
			return (*cvs_responses[i].resp_hdlr)
			    (root, cvs_responses[i].resp_id, cp);
d1150 20
@


1.14
log
@Handle the `Rcs-diff' response so we can patch on updates
@
text
@d179 1
a180 1
	{ CVS_RESP_MERGED,     "Merged",                 NULL              },
d822 1
a822 1
	char entbuf[128], path[MAXPATHLEN];
a824 2
	snprintf(path, sizeof(path), "%s/" CVS_PATH_ENTRIES, line);

d832 1
a832 1
	entfile = cvs_ent_open(path, O_WRONLY);
d954 13
a966 3
	if (type == CVS_RESP_CREATED) {
		/* read the remote path of the file */
		cvs_getln(root, path, sizeof(path));
a967 7
		/* read the new entry */
		cvs_getln(root, path, sizeof(path));
		ep = cvs_ent_parse(path);
		if (ep == NULL)
			return (-1);

		snprintf(path, sizeof(path), "%s%s", line, ep->ce_name);
d969 1
a971 3
		len = strlen(tbuf);
		if ((len > 0) && (tbuf[len - 1] == '\n'))
			tbuf[--len] = '\0';
a1071 1
	printf("FILE TO PATCH: %s\n", file);
@


1.13
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d61 1
d95 1
d191 1
a206 6
/*
 * Local and remote directory used by the `Directory' request.
 */
char  cvs_ldir[MAXPATHLEN];
char  cvs_rdir[MAXPATHLEN];

d796 2
a797 1
			cf->cf_ddat->cd_root = cvs_root;
a799 1
			cf->cf_ddat->cd_root = NULL;
d948 1
d950 1
d966 2
d986 2
a987 2
	snprintf(path, sizeof(path), "%s%s", line, ep->ce_name);
	if (cvs_recvfile(root, path) < 0) {
d989 2
a990 1
	}
d994 1
a994 1
		if (cvs_cksum(line, cksum_buf, sizeof(cksum_buf)) < 0) {
d1051 71
d1179 2
a1180 2
int
cvs_recvfile(struct cvsroot *root, const char *path)
a1181 2
	int fd;
	mode_t mode;
d1186 5
d1193 2
a1194 2
	    (cvs_strtomode(buf, &mode) < 0)) {
		return (-1);
d1202 1
a1202 7
		return (-1);
	}

	fd = open(path, O_WRONLY|O_CREAT, mode);
	if (fd == -1) {
		cvs_log(LP_ERRNO, "failed to open `%s'", path);
		return (-1);
d1212 2
a1213 3
			(void)close(fd);
			(void)unlink(path);
			return (-1);
d1216 5
a1220 6
		if (write(fd, buf, (size_t)ret) == -1) {
			cvs_log(LP_ERRNO,
			    "failed to write contents to file `%s'", path);
			(void)close(fd);
			(void)unlink(path);
			return (-1);
d1226 1
a1226 3
	(void)close(fd);

	return (0);
@


1.12
log
@New protocol API commented out, not ready yet
@
text
@d61 1
d81 13
a93 13
static int  cvs_resp_validreq  (int, char *);
static int  cvs_resp_cksum     (int, char *);
static int  cvs_resp_modtime   (int, char *);
static int  cvs_resp_m         (int, char *);
static int  cvs_resp_ok        (int, char *);
static int  cvs_resp_error     (int, char *);
static int  cvs_resp_statdir   (int, char *);
static int  cvs_resp_sticky    (int, char *);
static int  cvs_resp_newentry  (int, char *);
static int  cvs_resp_updated   (int, char *);
static int  cvs_resp_removed   (int, char *);
static int  cvs_resp_mode      (int, char *);
static int  cvs_resp_modxpand  (int, char *);
d95 1
d108 1
a108 1
	int    (*req_hdlr)(int, char *);
d153 1
a153 1
	{ CVS_REQ_VALIDRESP,     "Valid-responses",   CVS_REQF_RESP,  NULL },
d164 1
a164 1
	int  (*resp_hdlr)(int, char *);
d214 172
d392 1
a392 1
const char*
d399 1
a399 1
			return (cvs_requests[i].req_str);
d408 1
a408 1
int
d415 1
a415 1
			return (cvs_requests[i].req_id);
d417 1
a417 1
	return (-1);
d487 1
a487 1
const char*
d493 2
a494 2
		if (cvs_responses[i].resp_id == respid)
			return (cvs_responses[i].resp_str);
d503 1
a503 1
int
d510 1
a510 1
			return (cvs_responses[i].resp_id);
d512 1
a512 1
	return (-1);
d572 1
a572 1
cvs_resp_handle(char *line)
a574 1
	size_t len;
d586 1
a586 1
			    (cvs_responses[i].resp_id, cp);
d604 1
a604 1
cvs_resp_validreq(int type, char *line)
a605 1
	int i;
d607 1
d616 3
a618 3
		i = cvs_req_getbyname(sp);
		if (i != -1)
			cvs_server_validreq[i] = 1;
d635 1
a635 1
cvs_resp_m(int type, char *line)
d709 1
a709 1
cvs_resp_ok(int type, char *line)
d722 1
a722 1
cvs_resp_error(int type, char *line)
d736 1
a736 1
cvs_resp_statdir(int type, char *line)
d741 1
a741 1
	cvs_client_getln(rpath, sizeof(rpath));
d773 1
a773 1
cvs_resp_sticky(int type, char *line)
d786 1
a786 1
	cvs_client_getln(rpath, sizeof(rpath));
d823 1
a823 1
cvs_resp_newentry(int type, char *line)
d831 1
a831 1
	cvs_client_getln(entbuf, sizeof(entbuf));
d834 1
a834 1
	if (cvs_client_getln(entbuf, sizeof(entbuf)) < 0)
d859 1
a859 1
cvs_resp_cksum(int type, char *line)
d885 1
a885 1
cvs_resp_modtime(int type, char *line)
d948 1
a948 1
cvs_resp_updated(int type, char *line)
d955 2
d959 1
a959 1
		cvs_client_getln(path, sizeof(path));
d962 1
a962 1
		cvs_client_getln(path, sizeof(path));
d986 1
a986 1
	if (cvs_recvfile(path) < 0) {
d1015 1
a1015 1
cvs_resp_removed(int type, char *line)
d1028 1
a1028 1
cvs_resp_mode(int type, char *line)
d1044 1
a1044 1
cvs_resp_modxpand(int type, char *line)
d1058 1
a1058 1
cvs_sendfile(const char *path)
d1078 1
a1078 1
	cvs_client_sendln(buf);
d1080 1
a1080 1
	cvs_client_sendln(buf);
d1088 1
a1088 1
		cvs_client_sendraw(buf, (size_t)ret);
d1107 1
a1107 1
cvs_recvfile(const char *path)
d1116 1
a1116 1
	if ((cvs_client_getln(buf, sizeof(buf)) < 0) ||
d1121 1
a1121 1
	cvs_client_getln(buf, sizeof(buf));
d1140 1
a1140 1
		ret = cvs_client_recvraw(buf, len);
a1163 1
#ifdef notyet
d1173 1
a1173 1
cvs_sendreq(struct cvs_root *root, u_int rid, const char *arg)
d1176 1
a1176 2
	size_t len;
	struct cvs_req *reqp;
d1183 2
a1184 2
	reqp = cvs_req_getbyid(rid);
	if (reqp == NULL) {
d1189 2
a1190 2
	snprintf(cvs_client_buf, sizeof(cvs_client_buf), "%s %s\n",
	    reqp->req_str, (arg == NULL) ? "" : " ", (arg == NULL) ? "" : arg);
d1193 1
a1193 1
		fputs(cvs_client_buf, cvs_server_inlog);
d1195 1
a1195 1
	ret = fputs(cvs_client_buf, root->cr_srvin);
d1201 1
a1201 1
	if (reqp->req_flags & CVS_REQF_RESP)
d1204 1
a1204 1
	return (0);
d1218 1
a1218 1
cvs_getresp(struct cvs_root *root)
d1220 2
a1221 1
	int nbcmd;
d1227 1
a1227 1
		if (fgets(cvs_client_buf, sizeof(cvs_client_buf),
d1237 1
a1237 1
			fputs(cvs_client_buf, cvs_server_outlog);
d1239 2
a1240 2
		if ((len = strlen(cvs_client_buf)) != 0) {
			if (cvs_client_buf[len - 1] != '\n') {
d1244 1
a1244 1
				cvs_client_buf[--len] = '\0';
d1247 1
a1247 1
		ret = cvs_resp_handle(cvs_client_buf);
d1258 33
d1306 1
a1306 1
	if (reqp == NULL) {
d1311 1
a1311 1
	snprintf(cvs_client_buf, sizeof(cvs_client_buf), "%s %s\n", resp,
d1342 1
a1342 1
		if (fgets(cvs_client_buf, sizeof(cvs_client_buf),
d1351 2
a1352 2
		if ((len = strlen(cvs_client_buf)) != 0) {
			if (cvs_client_buf[len - 1] != '\n') {
d1356 1
a1356 1
				cvs_client_buf[--len] = '\0';
d1359 1
a1359 1
		ret = cvs_resp_handle(cvs_client_buf);
a1361 104


/*
 * cvs_connect()
 *
 * Open a client connection to the cvs server whose address is given in
 * the <root> variable.  The method used to connect depends on the
 * setting of the CVS_RSH variable.
 * Returns 0 on success, or -1 on failure.
 */

int
cvs_connect(struct cvsroot *root)
{
	int i, argc, infd[2], outfd[2];
	pid_t pid;
	char *argv[16], *cvs_server_cmd;

	if (pipe(infd) == -1) {
		cvs_log(LP_ERRNO,
		    "failed to create input pipe for client connection");
		return (-1);
	}

	if (pipe(outfd) == -1) {
		cvs_log(LP_ERRNO,
		    "failed to create output pipe for client connection");
		(void)close(infd[0]);
		(void)close(infd[1]);
		return (-1);
	}

	pid = fork();
	if (pid == -1) {
		cvs_log(LP_ERRNO, "failed to fork for cvs server connection");
		return (-1);
	}
	if (pid == 0) {
		if ((dup2(infd[0], STDIN_FILENO) == -1) ||
		    (dup2(outfd[1], STDOUT_FILENO) == -1)) {
			cvs_log(LP_ERRNO,
			    "failed to setup standard streams for cvs server");
			return (-1);
		}
		(void)close(infd[1]);
		(void)close(outfd[0]);

		argc = 0;
		argv[argc++] = cvs_rsh;

		if (root->cr_user != NULL) {
			argv[argc++] = "-l";
			argv[argc++] = root->cr_user;
		}


		cvs_server_cmd = getenv("CVS_SERVER");
		if (cvs_server_cmd == NULL)
			cvs_server_cmd = "cvs";

		argv[argc++] = root->cr_host;
		argv[argc++] = cvs_server_cmd;
		argv[argc++] = "server";
		argv[argc] = NULL;

		for (i = 0; i < argc; i++)
			printf("argv[%d] = `%s'\n", i, argv[i]);

		execvp(argv[0], argv);
		cvs_log(LP_ERRNO, "failed to exec");
		exit(EX_OSERR);
	}

	/* we are the parent */
	cvs_server_infd = infd[1];
	cvs_server_outfd = outfd[0];

	cvs_server_in = fdopen(cvs_server_infd, "w");
	if (cvs_server_in == NULL) {
		cvs_log(LP_ERRNO, "failed to create pipe stream");
		return (-1);
	}

	cvs_server_out = fdopen(cvs_server_outfd, "r");
	if (cvs_server_out == NULL) {
		cvs_log(LP_ERRNO, "failed to create pipe stream");
		return (-1);
	}
	root->cr_srvin = cvs_server_in;
	root->cr_srvout = cvs_server_out;

	/* make the streams line-buffered */
	setvbuf(cvs_server_in, NULL, _IOLBF, 0);
	setvbuf(cvs_server_out, NULL, _IOLBF, 0);

	(void)close(infd[0]);
	(void)close(outfd[1]);

	cvs_client_initlog();

	cvs_client_sendinfo();

#ifdef CVS_ZLIB
	/* if compression was requested, initialize it */
a1363 29
	return (0);
}


/*
 * cvs_disconnect()
 *
 * Disconnect from the cvs server.
 */

void
cvs_disconnect(struct cvsroot *root)
{
	cvs_log(LP_DEBUG, "closing client connection");
	if (root->cr_srvin != NULL) {
		(void)fclose(root->cr_srvin);
		root->cr_srvin = NULL;
	}
	if (root->cr_srvout != NULL) {
		(void)fclose(root->cr_srvout);
		root->cr_srvout = NULL;
	}

	if (cvs_server_inlog != NULL)
		fclose(cvs_server_inlog);
	if (cvs_server_outlog != NULL)
		fclose(cvs_server_outlog);
}

d1399 1
a1399 1
 * cvs_client_sendraw()
d1405 1
a1405 1
cvs_client_sendraw(const void *src, size_t len)
d1409 1
a1409 1
	if (fwrite(src, sizeof(char), len, cvs_server_in) < len) {
d1418 1
a1418 1
 * cvs_client_recvraw()
d1424 1
a1424 1
cvs_client_recvraw(void *dst, size_t len)
d1428 1
a1428 1
	ret = fread(dst, sizeof(char), len, cvs_server_out);
d1438 1
a1438 92
 * cvs_client_getln()
 *
 * Get a line from the server's output and store it in <lbuf>.  The terminating
 * newline character is stripped from the result.
 */

int
cvs_client_getln(char *lbuf, size_t len)
{
	size_t rlen;

	if (fgets(lbuf, len, cvs_server_out) == NULL) {
		if (ferror(cvs_server_out)) {
			cvs_log(LP_ERRNO, "failed to read line from server");
			return (-1);
		}

		if (feof(cvs_server_out))
			*lbuf = '\0';
	}

	if (cvs_server_outlog != NULL)
		fputs(lbuf, cvs_server_outlog);

	rlen = strlen(lbuf);
	if ((rlen > 0) && (lbuf[rlen - 1] == '\n'))
		lbuf[--rlen] = '\0';

	return (0);
}


/*
 * cvs_client_sendinfo()
 *
 * Initialize the connection status by first requesting the list of
 * supported requests from the server.  Then, we send the CVSROOT variable
 * with the `Root' request.
 * Returns 0 on success, or -1 on failure.
 */

static int
cvs_client_sendinfo(void)
{
	char *vresp;
	/*
	 * First, send the server the list of valid responses, then ask
	 * for valid requests
	 */

	vresp = cvs_resp_getvalid();
	if (vresp == NULL) {
		cvs_log(LP_ERR, "can't generate list of valid responses");
		return (-1);
	}

	if (cvs_client_sendreq(CVS_REQ_VALIDRESP, vresp, 0) < 0) {
	}
	free(vresp);

	if (cvs_client_sendreq(CVS_REQ_VALIDREQ, NULL, 1) < 0) {
		cvs_log(LP_ERR, "failed to get valid requests from server");
		return (-1);
	}

	/* now share our global options with the server */
	if (verbosity == 1)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-q", 0);
	else if (verbosity == 0)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-Q", 0);

	if (cvs_nolog)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-l", 0);
	if (cvs_readonly)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-r", 0);
	if (cvs_trace)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-t", 0);

	/* now send the CVSROOT to the server */
	if (cvs_client_sendreq(CVS_REQ_ROOT, cvs_root->cr_dir, 0) < 0)
		return (-1);

	/* not sure why, but we have to send this */
	if (cvs_client_sendreq(CVS_REQ_USEUNCHANGED, NULL, 0) < 0)
		return (-1);

	return (0);
}


/*
 * cvs_client_senddir()
d1444 1
a1444 1
cvs_client_senddir(const char *dir)
d1446 1
a1446 1
	char repo[MAXPATHLEN], buf[MAXPATHLEN];
d1448 5
a1452 7
	if (cvs_readrepo(dir, repo, sizeof(repo)) < 0) {
		repo[0] = '\0';
		strlcpy(buf, cvs_root->cr_dir, sizeof(buf));
	}
	else {
		snprintf(buf, sizeof(buf), "%s/%s", cvs_root->cr_dir, repo);
	}
d1454 2
a1455 2
	if ((cvs_client_sendreq(CVS_REQ_DIRECTORY, dir, 0) < 0) ||
	    (cvs_client_sendln(buf) < 0))
d1463 1
a1463 1
 * cvs_client_sendarg()
d1471 1
a1471 1
cvs_client_sendarg(const char *arg, int append)
d1473 2
a1474 2
	return cvs_client_sendreq(((append == 0) ?
	    CVS_REQ_ARGUMENT : CVS_REQ_ARGUMENTX), arg, 0);
d1479 1
a1479 1
 * cvs_client_sendentry()
d1486 1
a1486 1
cvs_client_sendentry(const struct cvs_ent *ent)
d1493 1
a1493 1
	return cvs_client_sendreq(CVS_REQ_ENTRY, ebuf, 0);
d1498 1
a1498 1
 * cvs_client_initlog()
d1508 1
a1508 1
cvs_client_initlog(void)
d1512 4
d1542 1
a1542 45
	return (0);
}


/*
 * cvs_client_sendfile()
 *
 */

int
cvs_client_sendfile(const char *path)
{
	int fd;
	ssize_t ret;
	char buf[4096];
	struct stat st;

	if (stat(path, &st) == -1) {
		cvs_log(LP_ERRNO, "failed to stat `%s'", path);
		return (-1);
	}

	fd = open(path, O_RDONLY, 0);
	if (fd == -1) {
		return (-1);
	}

	if (cvs_modetostr(st.st_mode, buf, sizeof(buf)) < 0)
		return (-1);

	cvs_client_sendln(buf);
	snprintf(buf, sizeof(buf), "%lld\n", st.st_size);
	cvs_client_sendln(buf);

	while ((ret = read(fd, buf, sizeof(buf))) != 0) {
		if (ret == -1) {
			cvs_log(LP_ERRNO, "failed to read file `%s'", path);
			return (-1);
		}

		cvs_client_sendraw(buf, (size_t)ret);

	}

	(void)close(fd);
a1545 1
#endif
@


1.11
log
@Define a flag to tell if a request expects a response.  This will later
allow us to do implicit response handling and remove the third argument
to cvs_client_sendreq()
@
text
@d987 619
@


1.10
log
@No more cvs_root
@
text
@d65 4
d134 1
a134 1
	{ CVS_REQ_XPANDMOD,      "expand-modules",    0,  NULL },
d136 2
a137 2
	{ CVS_REQ_CO,            "co",                0,  NULL },
	{ CVS_REQ_EXPORT,        "export",            0,  NULL },
d141 4
a144 3
	{ CVS_REQ_RTAG,          "rtag",              0,  NULL },
	{ CVS_REQ_INIT,          "init",              0,  NULL },
	{ CVS_REQ_UPDATE,        "update",            0,  NULL },
d146 4
a149 4
	{ CVS_REQ_IMPORT,        "import",            0,  NULL },
	{ CVS_REQ_ADD,           "add",               0,  NULL },
	{ CVS_REQ_REMOVE,        "remove",            0,  NULL },
	{ CVS_REQ_RELEASE,       "release",           0,  NULL },
d151 5
a155 5
	{ CVS_REQ_VALIDRESP,     "Valid-responses",   0,  NULL },
	{ CVS_REQ_VALIDREQ,      "valid-requests",    0,  NULL },
	{ CVS_REQ_VERSION,       "version",           0,  NULL },
	{ CVS_REQ_NOOP,          "noop",              0,  NULL },
	{ CVS_REQ_DIFF,          "diff",              0,  NULL },
a417 43
}


/*
 * cvs_client_sendinfo()
 *
 * Initialize the connection status by first requesting the list of
 * supported requests from the server.  Then, we send the CVSROOT variable
 * with the `Root' request.
 * Returns 0 on success, or -1 on failure.
 */

static int
cvs_client_sendinfo(void)
{
	/* first things first, get list of valid requests from server */
	if (cvs_client_sendreq(CVS_REQ_VALIDREQ, NULL, 1) < 0) {
		cvs_log(LP_ERR, "failed to get valid requests from server");
		return (-1);
	}

	/* now share our global options with the server */
	if (verbosity == 1)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-q", 0);
	else if (verbosity == 0)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-Q", 0);

	if (cvs_nolog)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-l", 0);
	if (cvs_readonly)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-r", 0);
	if (cvs_trace)
		cvs_client_sendreq(CVS_REQ_GLOBALOPT, "-t", 0);

	/* now send the CVSROOT to the server */
	if (cvs_client_sendreq(CVS_REQ_ROOT, cvs_root->cr_dir, 0) < 0)
		return (-1);

	/* not sure why, but we have to send this */
	if (cvs_client_sendreq(CVS_REQ_USEUNCHANGED, NULL, 0) < 0)
		return (-1);

	return (0);
@


1.9
log
@Fix the timestamp parsing for Mod-time.  Months are now being detected
correctly and there is no assumption about Daylight Savings Time
@
text
@a73 2
extern struct cvsroot *cvs_root;

@


1.8
log
@* use a mix of mktime() and ctime_r() instead of asctime_r() to calculate
  the Mod-time timestamp.  This way, mktime() fills in information about
  the week day and day of year which was not calculated with the previous
  method
* calculate the GMT offset

This fixes a bug where each CVS entry in the Entries files would have
`Sun' (for Sunday) as the day of the week.
@
text
@d94 2
a95 12
	"Jan",
	"Feb",
	"Mar",
	"Apr",
	"May",
	"June",
	"July",
	"Aug",
	"Sep",
	"Oct",
	"Nov",
	"Dec"
a99 2


d642 1
d647 5
d760 1
a760 1
	sscanf(line, "%d %8s %d %2d:%2d:%2d %5s", &cvs_tm.tm_mday, mon,
d764 1
d767 1
a767 1
		sscanf("%c%2s%2s", &sign, hr, min);
@


1.7
log
@* parse the timestamp given to Mod-time correctly and store it so the
  next operation on a file can use it (actually, we need to fix the
  problem with weekdays)
* when getting a sticky command and the directory doesn't exist, create
  it and populate it with CVS admin files
@
text
@d202 1
a202 1
static struct tm cvs_modtime;
d760 24
a783 2
	u_int i;
	char mon[8];
d785 15
a799 2
	cvs_modtime.tm_yday = 0;
	cvs_modtime.tm_wday = 0;
d801 5
a805 8
	sscanf(line, "%d %8s %d %2d:%2d:%2d", &cvs_modtime.tm_mday, mon,
	    &cvs_modtime.tm_year, &cvs_modtime.tm_hour, &cvs_modtime.tm_min,
	    &cvs_modtime.tm_sec);
	cvs_modtime.tm_year -= 1900;

	for (i = 0; i < sizeof(cvs_months)/sizeof(cvs_months[0]); i++) {
		if (strcmp(cvs_months[i], mon) == 0)
			cvs_modtime.tm_mon = (int)i;
d808 1
d838 1
a838 1
		ep->ce_timestamp = asctime_r(&cvs_modtime, tbuf);
@


1.6
log
@* fix two offset bugs in MT stack handling
* create the directory if it does not exist when getting a `Clear-sticky'
  or `Set-sticky'
* fix the cvs_client_getln() that was missing in cvs_resp_statdir()
* when receiving a `Created', read the proper lines, then generate
  a valid pathname to pass to cvs_recvfile()
* don't try to compare checksums if the checksum pointer is NULL
* in cvs_recvfile(), open the file with the proper flags
@
text
@d93 17
d202 2
d656 1
d663 1
d667 10
a676 3
		else if (mkdir(line, 0755) == -1) {
			cvs_log(LP_ERRNO, "failed to create %s", line);
			return (-1);
d760 16
d789 3
a791 1
	char path[MAXPATHLEN], cksum_buf[CVS_CKSUM_LEN];
d803 13
@


1.5
log
@* start working on the MT support
* add dummy handlers for `Set-sticky', `Clear-sticky' and
  `Module-expansion'
@
text
@d519 2
a520 3
			cvs_mt_stack[cvs_mtstk_depth++] = strdup(line + 1);
			if (cvs_mt_stack[cvs_mtstk_depth] == NULL) {
				cvs_mtstk_depth--;
d522 1
a522 1
			}
d529 2
a530 2
			else if (strcmp(line,
			    cvs_mt_stack[cvs_mtstk_depth]) != 0) {
d549 1
a549 1
		break;
d599 3
a601 1
	char statpath[MAXPATHLEN];
d635 17
d739 1
a739 1
 * Handler for the `Updated' response.
d745 2
a746 1
	char cksum_buf[CVS_CKSUM_LEN];
d749 8
d763 2
a764 1
	if (cvs_recvfile(line) < 0) {
d769 8
a776 2
	if (cvs_cksum(line, cksum_buf, sizeof(cksum_buf)) < 0) {
	}
d778 2
a779 3
	if (strcmp(cksum_buf, cvs_fcksum) != 0) {
		cvs_log(LP_ERR, "checksum error on received file");
		(void)unlink(line);
a781 3
	free(cvs_fcksum);
	cvs_fcksum = NULL;

d907 1
a907 1
	fd = open(path, O_RDONLY, mode);
d916 2
@


1.4
log
@* add an entry for the `Mod-time' response
@
text
@d63 3
a77 13
/*
 * Local and remote directory used by the `Directory' request.
 */
char  cvs_ldir[MAXPATHLEN];
char  cvs_rdir[MAXPATHLEN];



char *cvs_fcksum = NULL;

mode_t  cvs_lastmode = 0;


d85 1
d90 1
d176 3
d182 4
d192 10
d497 1
d513 37
d552 1
a552 1
		cvs_log(LP_WARN, "MT and Mbinary not supported in client yet");
d606 1
a606 1
	    (unlink(statpath) == -1)) {
d612 1
a612 1
		fd = open(statpath, O_CREAT|O_TRUNC|O_WRONLY, 0400); 
d619 18
d781 13
@


1.3
log
@make adding entries to the Entries file work
@
text
@d90 1
d183 1
d482 1
a482 1
 * Handler for the `M', `F' and `E' responses.
d503 1
d634 15
@


1.2
log
@prepare the entries interface so we can add entries
@
text
@a584 1
	struct cvs_ent *entp;
a595 4
	entp = cvs_ent_parse(entbuf);
	if (entp == NULL)
		return (-1);

d599 1
a599 3

	cvs_ent_add(entfile, entp);

@


1.1
log
@Initial revision
@
text
@d588 1
a588 4
	if (cvs_splitpath(line, entbuf, sizeof(entbuf), NULL, 0) < 0)
		return (-1);

	snprintf(path, sizeof(path), "%s/" CVS_PATH_ENTRIES, entbuf);
d601 1
a601 1
	entfile = cvs_ent_open(path);
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
