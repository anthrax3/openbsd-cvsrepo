head	1.74;
access;
symbols
	OPENBSD_3_9:1.71.0.2
	OPENBSD_3_9_BASE:1.71
	OPENBSD_3_8:1.57.0.2
	OPENBSD_3_8_BASE:1.57
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21;
locks; strict;
comment	@ * @;


1.74
date	2006.05.27.03.30.31;	author joris;	state dead;
branches;
next	1.73;

1.73
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.16.08.43.43;	author xsa;	state Exp;
branches;
next	1.71;

1.71
date	2006.01.27.12.56.28;	author xsa;	state Exp;
branches;
next	1.70;

1.70
date	2006.01.26.09.05.31;	author xsa;	state Exp;
branches;
next	1.69;

1.69
date	2006.01.25.08.15.05;	author xsa;	state Exp;
branches;
next	1.68;

1.68
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.67;

1.67
date	2005.12.30.16.47.36;	author joris;	state Exp;
branches;
next	1.66;

1.66
date	2005.12.29.21.28.26;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2005.12.20.18.17.01;	author xsa;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.03.01.02.09;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2005.11.28.08.49.25;	author xsa;	state Exp;
branches;
next	1.61;

1.61
date	2005.10.22.17.32.57;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2005.09.15.22.12.23;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2005.09.15.17.01.10;	author xsa;	state Exp;
branches;
next	1.57;

1.57
date	2005.08.19.08.28.54;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2005.08.17.16.43.39;	author xsa;	state Exp;
branches;
next	1.55;

1.55
date	2005.08.16.16.34.19;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.14.23.24.55;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.02.12.08.13;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2005.08.02.12.06.38;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2005.07.26.14.58.58;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.24.17.20.14;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.24.16.46.40;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.22.16.27.29;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.14.07.38.35;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.10.00.12.52;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.05.12.00.45;	author joris;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.10.21.13.40;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.24.22.00.25;	author joris;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.24.19.13.52;	author joris;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.24.07.33.36;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.24.03.06.16;	author jfb;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.20.19.58.03;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.19.04.17.24;	author jfb;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.12.17.32.16;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.11.00.07.57;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.03.08.55.16;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.20.15.50.54;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.19.16.57.07;	author joris;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.15.13.14.00;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.15.07.41.20;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.14.03.02.35;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.13.15.08.36;	author jfb;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.29.17.37.37;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.27.18.34.26;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.13.05.39.07;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.06.18.40.33;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.13.22.53.48;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.13.17.09.01;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.10.18.47.38;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.08.20.00.23;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.08.19.28.10;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.07.16.48.55;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.06.04.10.06;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.03.21.08.40;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.23.15.35.10;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.13.13.27.52;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.13.13.24.13;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.13.12.46.26;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.06.20.16.52;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.03.05.08.45;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.03.04.58.45;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.74
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@/*	$OpenBSD: resp.c,v 1.73 2006/04/14 02:45:35 deraadt Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "includes.h"

#include "buf.h"
#include "cvs.h"
#include "log.h"
#include "proto.h"


#define CVS_MTSTK_MAXDEPTH	16


static int  cvs_resp_validreq  (struct cvsroot *, int, char *);
static int  cvs_resp_cksum     (struct cvsroot *, int, char *);
static int  cvs_resp_modtime   (struct cvsroot *, int, char *);
static int  cvs_resp_m         (struct cvsroot *, int, char *);
static int  cvs_resp_ok        (struct cvsroot *, int, char *);
static int  cvs_resp_error     (struct cvsroot *, int, char *);
static int  cvs_resp_statdir   (struct cvsroot *, int, char *);
static int  cvs_resp_sticky    (struct cvsroot *, int, char *);
static int  cvs_resp_newentry  (struct cvsroot *, int, char *);
static int  cvs_resp_updated   (struct cvsroot *, int, char *);
static int  cvs_resp_removed   (struct cvsroot *, int, char *);
static int  cvs_resp_mode      (struct cvsroot *, int, char *);
static int  cvs_resp_modxpand  (struct cvsroot *, int, char *);
static int  cvs_resp_rcsdiff   (struct cvsroot *, int, char *);
static int  cvs_resp_template  (struct cvsroot *, int, char *);
static int  cvs_resp_copyfile  (struct cvsroot *, int, char *);
static int  cvs_resp_createdir (char *);

struct cvs_resphdlr {
	int	(*hdlr)(struct cvsroot *, int, char *);
} cvs_resp_swtab[CVS_RESP_MAX + 1] = {
	{ NULL              },
	{ cvs_resp_ok       },
	{ cvs_resp_error    },
	{ cvs_resp_validreq },
	{ cvs_resp_newentry },
	{ cvs_resp_newentry },
	{ cvs_resp_cksum    },
	{ cvs_resp_copyfile },
	{ cvs_resp_updated  },
	{ cvs_resp_updated  },
	{ cvs_resp_updated  },	/* 10 */
	{ cvs_resp_updated  },
	{ cvs_resp_updated  },
	{ cvs_resp_rcsdiff  },
	{ cvs_resp_mode     },
	{ cvs_resp_modtime  },
	{ cvs_resp_removed  },
	{ cvs_resp_removed  },
	{ cvs_resp_statdir  },
	{ cvs_resp_statdir  },
	{ cvs_resp_sticky   },	/* 20 */
	{ cvs_resp_sticky   },
	{ cvs_resp_template },
	{ NULL              },
	{ NULL              },
	{ NULL              },
	{ cvs_resp_modxpand },
	{ NULL              },
	{ cvs_resp_m        },
	{ cvs_resp_m        },
	{ cvs_resp_m        },	/* 30 */
	{ cvs_resp_m        },
	{ cvs_resp_m        },
};

/*
 * Instead of opening and closing the Entry file all the time,
 * which caused a huge CPU load and slowed down everything,
 * we keep the Entry file for the directory we are working in
 * open until we encounter a new directory.
 */
static char cvs_resp_lastdir[MAXPATHLEN] = "";
static CVSENTRIES *cvs_resp_lastent = NULL;
static int resp_check_dir(struct cvsroot *, const char *);

/*
 * The MT command uses scoping to tag the data.  Whenever we encouter a '+',
 * we push the name of the tag on the stack, and we pop it when we encounter
 * a '-' with the same name.
 */

static char *cvs_mt_stack[CVS_MTSTK_MAXDEPTH];
static u_int cvs_mtstk_depth = 0;

static time_t cvs_modtime = CVS_DATE_DMSEC;


/* last checksum received */
char *cvs_fcksum = NULL;

mode_t  cvs_lastmode = 0;

/* hack to receive the remote version without outputting it */
extern u_int cvs_version_sent;


/*
 * cvs_resp_handle()
 *
 * Generic response handler dispatcher.  The handler expects the first line
 * of the command as single argument.
 * Returns the return value of the command on success, or -1 on failure.
 */
int
cvs_resp_handle(struct cvsroot *root, char *line)
{
	int ret;
	char *cp, *cmd;
	struct cvs_resp *resp;

	cmd = line;

	cp = strchr(cmd, ' ');
	if (cp != NULL)
		*(cp++) = '\0';

	resp = cvs_resp_getbyname(cmd);
	if (resp == NULL) {
		return (-1);
	} else if (cvs_resp_swtab[resp->resp_id].hdlr == NULL) {
		cvs_log(LP_ERR, "handler for `%s' not implemented", cmd);
		return (-1);
	}

	ret = (*cvs_resp_swtab[resp->resp_id].hdlr)(root, resp->resp_id, cp);

	if (ret == -1)
		cvs_log(LP_ERR, "error in handling of `%s' response", cmd);

	return (ret);
}


/*
 * cvs_resp_validreq()
 *
 * Handler for the `Valid-requests' response.  The list of valid requests is
 * split on spaces and each request's entry in the valid request array is set
 * to 1 to indicate the validity.
 * Returns 0 on success, or -1 on failure.
 */
static int
cvs_resp_validreq(struct cvsroot *root, int type, char *line)
{
	char *sp, *ep;
	struct cvs_req *req;

	/* parse the requests */
	sp = line;
	do {
		ep = strchr(sp, ' ');
		if (ep != NULL)
			*ep = '\0';

		req = cvs_req_getbyname(sp);
		if (req != NULL)
			CVS_SETVR(root, req->req_id);

		if (ep != NULL)
			sp = ep + 1;
	} while (ep != NULL);

	return (0);
}


/*
 * cvs_resp_m()
 *
 * Handler for the `M', 'MT', `F' and `E' responses.
 */
static int
cvs_resp_m(struct cvsroot *root, int type, char *line)
{
	char *cp;
	FILE *stream;

	stream = NULL;

	switch (type) {
	case CVS_RESP_F:
		fflush(stderr);
		return (0);
	case CVS_RESP_M:
		if (cvs_version_sent) {
			/*
			 * Instead of outputting the line, we save it as the
			 * remote server's version string.
			 */
			cvs_version_sent = 0;
			root->cr_version = xstrdup(line);
			return (0);
		}
		stream = stdout;
		break;
	case CVS_RESP_E:
		stream = stderr;
		break;
	case CVS_RESP_MT:
		if (*line == '+') {
			if (cvs_mtstk_depth == CVS_MTSTK_MAXDEPTH) {
				cvs_log(LP_ERR,
				    "MT scope stack has reached max depth");
				return (-1);
			}
			cvs_mt_stack[cvs_mtstk_depth] = xstrdup(line + 1);
			cvs_mtstk_depth++;
		} else if (*line == '-') {
			if (cvs_mtstk_depth == 0) {
				cvs_log(LP_ERR, "MT scope stack underflow");
				return (-1);
			} else if (strcmp(line + 1,
			    cvs_mt_stack[cvs_mtstk_depth - 1]) != 0) {
				cvs_log(LP_ERR, "mismatch in MT scope stack");
				return (-1);
			}
			xfree(cvs_mt_stack[--cvs_mtstk_depth]);
		} else {
			if (strcmp(line, "newline") == 0)
				putc('\n', stdout);
			else if (strncmp(line, "fname ", (size_t)6) == 0)
				printf("%s", line + 6);
			else {
				/* assume text */
				cp = strchr(line, ' ');
				if (cp != NULL)
					printf("%s", cp + 1);
			}
		}

		return (0);
	case CVS_RESP_MBINARY:
		cvs_log(LP_WARN, "Mbinary not supported in client yet");
		break;
	}

	fputs(line, stream);
	fputc('\n', stream);

	return (0);
}


/*
 * cvs_resp_ok()
 *
 * Handler for the `ok' response.  This handler's job is to
 */
static int
cvs_resp_ok(struct cvsroot *root, int type, char *line)
{
	/*
	 * If we still have an Entry file open, close it now.
	 */
	if (cvs_resp_lastent != NULL)
		cvs_ent_close(cvs_resp_lastent);

	return (1);
}


/*
 * cvs_resp_error()
 *
 * Handler for the `error' response.  This handler's job is to
 * show the error message given by the server.
 */
static int
cvs_resp_error(struct cvsroot *root, int type, char *line)
{
	if (line == NULL)
		return (1);

	/* XXX - GNU cvs sends an empty error message
	 * at the end of the diff command, even for successfull
	 * diff.
	 */
	if (strlen(line) == 1 && *line == ' ')
		return (1);

	fprintf(stderr, "%s\n", line);
	return (1);
}


/*
 * cvs_resp_statdir()
 *
 * Handler for the `Clear-static-directory' and `Set-static-directory'
 * responses.
 */
static int
cvs_resp_statdir(struct cvsroot *root, int type, char *line)
{
	int fd;
	char rpath[MAXPATHLEN], statpath[MAXPATHLEN];

	/* remote directory line */
	cvs_getln(root, rpath, sizeof(rpath));

	STRIP_SLASH(line);

	/*
	 * Create the directory if it does not exist.
	 */
	if (cvs_resp_createdir(line) < 0)
		return (-1);
	if (strlcpy(statpath, line, sizeof(statpath)) >= sizeof(statpath) ||
	    strlcat(statpath, "/", sizeof(statpath)) >= sizeof(statpath) ||
	    strlcat(statpath, CVS_PATH_STATICENTRIES,
	    sizeof(statpath)) >= sizeof(statpath)) {
		cvs_log(LP_ERR, "Entries.static path truncation");
		return (-1);
	}

	if (cvs_noexec == 0) {
		if (type == CVS_RESP_CLRSTATDIR &&
		    cvs_unlink(statpath) == -1) {
			return (-1);
		} else if (type == CVS_RESP_SETSTATDIR) {
			fd = open(statpath, O_CREAT|O_TRUNC|O_WRONLY, 0644);
			if (fd == -1) {
				cvs_log(LP_ERRNO,
				    "failed to set static directory on %s",
				    line);
				return (-1);
			}
			(void)close(fd);

		}
	}

	return (0);
}

/*
 * cvs_resp_sticky()
 *
 * Handler for the `Clear-sticky' and `Set-sticky' responses.  If the
 * specified directory doesn't exist, we create it.
 */
static int
cvs_resp_sticky(struct cvsroot *root, int type, char *line)
{
	char buf[MAXPATHLEN];

	/* get the remote path */
	cvs_getln(root, buf, sizeof(buf));

	STRIP_SLASH(line);

	if (cvs_resp_createdir(line) < 0)
		return (-1);

	return (0);
}

/*
 * Shared code for cvs_resp[static, sticky]
 *
 * Looks if the directory requested exists, if it doesn't it will
 * create it plus all administrative files as well.
 */
static int
cvs_resp_createdir(char *line)
{
	CVSFILE *base, *cf;
	CVSENTRIES *entf;
	struct stat st;
	struct cvs_ent *ent;
	char *file, subdir[MAXPATHLEN], buf[CVS_ENT_MAXLINELEN];

	entf = NULL;
	cf = NULL;

	/*
	 * we do not want to handle the '.' case,
	 * so return early.
	 */
	if (!strcmp(line, "."))
		return (0);

	cvs_splitpath(line, subdir, sizeof(subdir), &file);
	base = cvs_file_loadinfo(subdir, CF_NOFILES, NULL, NULL, 1);
	if (base == NULL)
		return (-1);

	/*
	 * If <line> doesn't exist, we create it.
	 */
	if (stat(line, &st) == -1) {
		if (errno != ENOENT) {
			cvs_log(LP_ERRNO, "failed to stat `%s'", line);
			return (-1);
		}

		cf = cvs_file_create(base, line, DT_DIR, 0755);
	} else {
		cf = cvs_file_loadinfo(line, CF_NOFILES, NULL, NULL, 1);
	}

	if (cf == NULL) {
		cvs_file_free(base);
		return (-1);
	}

	/*
	 * If the Entries file for the parent is already
	 * open, operate on that, instead of reopening it
	 * and invalidating the opened list.
	 */
	if (!strcmp(subdir, cvs_resp_lastdir))
		entf = cvs_resp_lastent;
	else
		entf = cvs_ent_open(subdir, O_WRONLY);

	/*
	 * see if the entry is still present. If not, we add it again.
	 */
	if (entf != NULL) {
		if ((ent = cvs_ent_get(entf, cf->cf_name)) == NULL) {
			if (strlcpy(buf, "D/", sizeof(buf)) >= sizeof(buf) ||
			    strlcat(buf, cf->cf_name, sizeof(buf)) >=
			    sizeof(buf) ||
			    strlcat(buf, "////", sizeof(buf)) >= sizeof(buf)) {
				cvs_file_free(cf);
				cvs_file_free(base);
				return (-1);
			}

			ent = cvs_ent_parse(buf);
			if (ent == NULL)
				cvs_log(LP_ERR,
				    "failed to create directory entry");
			else
				cvs_ent_add(entf, ent);
		}

		if (strcmp(subdir, cvs_resp_lastdir))
			cvs_ent_close(entf);
	}

	cvs_file_free(cf);
	cvs_file_free(base);
	return (0);
}


/*
 * cvs_resp_newentry()
 *
 * Handler for the `New-entry' response and `Checked-in' responses.
 * In the case of `New-entry', we expect the entry line
 */
static int
cvs_resp_newentry(struct cvsroot *root, int type, char *line)
{
	char entbuf[CVS_ENT_MAXLINELEN];
	struct cvs_ent *ent;

	/* get the remote path */
	cvs_getln(root, entbuf, sizeof(entbuf));

	/* get the new Entries line */
	cvs_getln(root, entbuf, sizeof(entbuf));

	if (resp_check_dir(root, line) < 0)
		return (-1);

	if (type == CVS_RESP_NEWENTRY) {
		cvs_ent_addln(cvs_resp_lastent, entbuf);
	} else if (type == CVS_RESP_CHECKEDIN) {
		ent = cvs_ent_parse(entbuf);
		if (ent == NULL) {
			cvs_log(LP_ERR, "failed to parse entry");
			return (-1);
		}

		/* timestamp it to now */
		ent->ce_mtime = time(&(ent->ce_mtime));

		/* replace the current entry with the one we just received */
		(void)cvs_ent_remove(cvs_resp_lastent, ent->ce_name, 0);

		cvs_ent_add(cvs_resp_lastent, ent);
	}

	return (0);
}


/*
 * cvs_resp_cksum()
 *
 * Handler for the `Checksum' response.  We store the checksum received for
 * the next file in a dynamically-allocated buffer pointed to by <cvs_fcksum>.
 * Upon next file reception, the handler checks to see if there is a stored
 * checksum.
 * The file handler must make sure that the checksums match and free the
 * checksum buffer once it's done to indicate there is no further checksum.
 */
static int
cvs_resp_cksum(struct cvsroot *root, int type, char *line)
{
	if (cvs_fcksum != NULL) {
		cvs_log(LP_WARN, "unused checksum");
		xfree(cvs_fcksum);
	}

	cvs_fcksum = xstrdup(line);

	return (0);
}


/*
 * cvs_resp_copyfile()
 *
 * Handler for the `Copy-file' response, which is used to copy the contents
 * of a file to another file for which the name is provided.  The CVS protocol
 * documentation states that this response is only used prior to a `Merged'
 * response to create a backup of the file.
 */
static int
cvs_resp_copyfile(struct cvsroot *root, int type, char *line)
{
	char path[MAXPATHLEN], newpath[MAXPATHLEN];
	char newname[MAXNAMLEN], *file;

	/* read the remote path of the file to copy and its new name */
	cvs_getln(root, path, sizeof(path));
	cvs_getln(root, newname, sizeof(newname));

	if ((file = basename(path)) == NULL)
		fatal("no base file name in Copy-file path");

	if (strlcpy(path, line, sizeof(path)) >= sizeof(path) ||
	    strlcat(path, file, sizeof(path)) >= sizeof(path))
		fatal("source path overflow in Copy-file response");

	if (strlcpy(newpath, line, sizeof(newpath)) >= sizeof(newpath) ||
	    strlcat(newpath, newname, sizeof(newpath)) >= sizeof(newpath))
		fatal("destination path overflow in Copy-file response");

	if (rename(path, newpath) == -1) {
		fatal("cvs_resp_copyfile: rename: `%s'->`%s': %s",
		    path, newpath, strerror(errno));
	}

	return (0);
}


/*
 * cvs_resp_modtime()
 *
 * Handler for the `Mod-time' file update modifying response.  The timestamp
 * given is used to set the last modification time on the next file that
 * will be received.
 */
static int
cvs_resp_modtime(struct cvsroot *root, int type, char *line)
{
	cvs_modtime = cvs_date_parse(line);
	return (0);
}


/*
 * cvs_resp_updated()
 *
 * Handler for the `Updated', `Update-existing', `Created', `Merged' and
 * `Patched' responses, which all have a very similar format.
 */
static int
cvs_resp_updated(struct cvsroot *root, int type, char *line)
{
	int ret;
	mode_t fmode;
	char path[MAXPATHLEN], cksum_buf[CVS_CKSUM_LEN];
	BUF *fbuf;
	struct cvs_ent *ent;
	struct timeval tv[2];

	ret = 0;

	STRIP_SLASH(line);

	/* read the remote path of the file */
	cvs_getln(root, path, sizeof(path));

	/* read the new entry */
	cvs_getln(root, path, sizeof(path));

	if ((ent = cvs_ent_parse(path)) == NULL)
		return (-1);

	if (strlcpy(path, line, sizeof(path)) >= sizeof(path) ||
	    strlcat(path, "/", sizeof(path)) >= sizeof(path) ||
	    strlcat(path, ent->ce_name, sizeof(path)) >= sizeof(path))
		fatal("Entries path overflow in response");

	/*
	 * Please be sure the directory does exist.
	 */
	if (cvs_resp_createdir(line) < 0)
		return (-1);

	if (resp_check_dir(root, line) < 0)
		return (-1);

	if (cvs_modtime != CVS_DATE_DMSEC) {
		ent->ce_mtime = cvs_modtime;
	} else
		ent->ce_mtime = time(&(ent->ce_mtime));

	if (type == CVS_RESP_UPDEXIST || type == CVS_RESP_UPDATED ||
	    type == CVS_RESP_MERGED || type == CVS_RESP_CREATED) {
		if (cvs_ent_remove(cvs_resp_lastent, ent->ce_name, 0) < 0 &&
		    type != CVS_RESP_CREATED) {
			cvs_log(LP_WARN, "failed to remove entry for '%s`",
			    ent->ce_name);
		}
	}

	cvs_ent_add(cvs_resp_lastent, ent);

	fbuf = cvs_recvfile(root, &fmode);
	cvs_buf_write(fbuf, path, fmode);
	cvs_buf_free(fbuf);

	if (cvs_modtime != CVS_DATE_DMSEC) {
		tv[0].tv_sec = (long)cvs_modtime;
		tv[0].tv_usec = 0;
		tv[1].tv_sec = (long)cvs_modtime;
		tv[1].tv_usec = 0;
		if (utimes(path, tv) == -1)
			cvs_log(LP_ERRNO, "failed to set file timestamps");
	}

	/* invalidate last received timestamp */
	cvs_modtime = CVS_DATE_DMSEC;

	/* now see if there is a checksum */
	if (cvs_fcksum != NULL) {
		if (cvs_cksum(path, cksum_buf, sizeof(cksum_buf)) < 0)
			ret = -1;
		else if (strcmp(cksum_buf, cvs_fcksum) != 0) {
			cvs_log(LP_ERR, "checksum error on received file");
			(void)unlink(line);
			ret = -1;
		}

		xfree(cvs_fcksum);
		cvs_fcksum = NULL;
	}

	return (ret);
}


/*
 * cvs_resp_removed()
 *
 * Handler for the `Removed' and `Remove-entry' responses.  The `Removed'
 * response is received when both a file and its entry need to be removed from
 * the local copy.  The `Remove-entry' is received in cases where the file is
 * already gone but there is still an entry to remove in the Entries file.
 */
static int
cvs_resp_removed(struct cvsroot *root, int type, char *line)
{
	char buf[MAXPATHLEN], base[MAXPATHLEN];
	char fpath[MAXPATHLEN], *file;

	cvs_getln(root, buf, sizeof(buf));

	cvs_splitpath(buf, base, sizeof(base), &file);

	if (strlcpy(fpath, line, sizeof(fpath)) >= sizeof(fpath) ||
	    strlcat(fpath, "/", sizeof(fpath)) >= sizeof(fpath) ||
	    strlcat(fpath, file, sizeof(fpath)) >= sizeof(fpath))
		fatal("cvs_resp_removed: overflow in path");

	if (resp_check_dir(root, line) < 0)
		return (-1);

	(void)cvs_ent_remove(cvs_resp_lastent, file, 0);
	if (type == CVS_RESP_REMOVED &&
	    (unlink(fpath) == -1 && errno != ENOENT)) {
		cvs_log(LP_ERRNO, "failed to unlink `%s'", file);
		return (-1);
	}

	return (0);
}


/*
 * cvs_resp_mode()
 *
 * Handler for the `Mode' response.
 */
static int
cvs_resp_mode(struct cvsroot *root, int type, char *line)
{
	cvs_strtomode(line, &cvs_lastmode);
	return (0);
}


/*
 * cvs_resp_modxpand()
 *
 * Handler for the `Module-expansion' response.
 */
static int
cvs_resp_modxpand(struct cvsroot *root, int type, char *line)
{
	return (0);
}

/*
 * cvs_resp_rcsdiff()
 *
 * Handler for the `Rcs-diff' response.
 */
static int
cvs_resp_rcsdiff(struct cvsroot *root, int type, char *line)
{
	char file[MAXPATHLEN];
	char buf[CVS_ENT_MAXLINELEN], cksum_buf[CVS_CKSUM_LEN];
	char *fname, *orig, *patch;
	mode_t fmode;
	BUF *res, *fcont, *patchbuf;
	CVSENTRIES *entf;
	struct cvs_ent *ent;

	/* get remote path and build local path of file to be patched */
	cvs_getln(root, buf, sizeof(buf));

	fname = strrchr(buf, '/');
	if (fname == NULL)
		fname = buf;

	if (strlcpy(file, line, sizeof(file)) >= sizeof(file) ||
	    strlcat(file, fname, sizeof(file)) >= sizeof(file))
		fatal("cvs_resp_rcsdiff: path truncation");

	/* get updated entry fields */
	cvs_getln(root, buf, sizeof(buf));

	ent = cvs_ent_parse(buf);
	if (ent == NULL)
		return (-1);

	patchbuf = cvs_recvfile(root, &fmode);
	fcont = cvs_buf_load(file, BUF_AUTOEXT);
	if (fcont == NULL)
		return (-1);

	cvs_buf_putc(patchbuf, '\0');
	cvs_buf_putc(fcont, '\0');
	orig = cvs_buf_release(fcont);
	patch = cvs_buf_release(patchbuf);

	res = cvs_patchfile(orig, patch, rcs_patch_lines);
	if (res == NULL)
		return (-1);

	cvs_buf_write(res, file, fmode);

	/* now see if there is a checksum */
	if (cvs_fcksum != NULL) {
		if (cvs_cksum(file, cksum_buf, sizeof(cksum_buf)) < 0) {
		}

		if (strcmp(cksum_buf, cvs_fcksum) != 0) {
			cvs_log(LP_ERR, "checksum error on received file");
			(void)unlink(file);
		}

		xfree(cvs_fcksum);
		cvs_fcksum = NULL;
	}

	/* update revision in entries */
	entf = cvs_ent_open(line, O_WRONLY);
	if (entf == NULL)
		return (-1);

	cvs_ent_close(entf);

	return (0);
}


/*
 * cvs_resp_template()
 *
 * Handler for the `Template' response.
 */
static int
cvs_resp_template(struct cvsroot *root, int type, char *line)
{
	mode_t mode;
	BUF *tmpl;

	tmpl = cvs_recvfile(root, &mode);
	cvs_buf_free(tmpl);

	return (0);
}

/*
 * Check if <dir> is the same as the last
 * received directory, if it's not, switch Entry files.
 */
static int
resp_check_dir(struct cvsroot *root, const char *dir)
{
	char cvspath[MAXPATHLEN], repo[MAXPATHLEN];
	struct stat st;

	/*
	 * Make sure the CVS directory exists.
	 */
	if (strlcpy(cvspath, dir, sizeof(cvspath)) >= sizeof(cvspath) ||
	    strlcat(cvspath, "/", sizeof(cvspath)) >= sizeof(cvspath) ||
	    strlcat(cvspath, CVS_PATH_CVSDIR,
	    sizeof(cvspath)) >= sizeof(cvspath))
		fatal("resp_check_dir: path overflow");

	if (stat(cvspath, &st) == -1) {
		if (errno != ENOENT)
			return (-1);
		if  (cvs_repo_base != NULL) {
			if (strlcpy(repo, cvs_repo_base,
			    sizeof(repo)) >= sizeof(repo) ||
			    strlcat(repo, "/", sizeof(repo)) >= sizeof(repo) ||
			    strlcat(repo, dir, sizeof(repo)) >= sizeof(repo))
				fatal("resp_check_dir: path overflow");
		} else {
			if (strlcpy(repo, dir, sizeof(repo)) >= sizeof(repo))
				fatal("resp_check_dir: path truncation");
		}

		cvs_mkadmin(dir, root->cr_str, repo, NULL, NULL, 0);
	}

	if (strcmp(dir, cvs_resp_lastdir)) {
		if (cvs_resp_lastent != NULL)
			cvs_ent_close(cvs_resp_lastent);
		cvs_resp_lastent = cvs_ent_open(dir, O_WRONLY);
		if (cvs_resp_lastent == NULL)
			return (-1);

		if (strlcpy(cvs_resp_lastdir, dir,
		    sizeof(cvs_resp_lastdir)) >= sizeof(cvs_resp_lastdir))
			fatal("resp_check_dir: path truncation");
	} else {
		/* make sure the old one is still open */
		if (cvs_resp_lastent == NULL) {
			cvs_resp_lastent = cvs_ent_open(cvs_resp_lastdir,
			    O_WRONLY);
			if (cvs_resp_lastent == NULL)
				return (-1);
		}
	}

	return (0);
}
@


1.73
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.72 2006/03/16 08:43:43 xsa Exp $	*/
@


1.72
log
@add missing {} so everything gets reached.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.71 2006/01/27 12:56:28 xsa Exp $	*/
d306 1
a306 1
	if ((strlen(line) == 1) && (*line == ' '))
d345 2
a346 2
		if ((type == CVS_RESP_CLRSTATDIR) &&
		    (cvs_unlink(statpath) == -1)) {
d645 4
a648 4
	if ((type == CVS_RESP_UPDEXIST) || (type == CVS_RESP_UPDATED) ||
	    (type == CVS_RESP_MERGED) || (type == CVS_RESP_CREATED)) {
		if ((cvs_ent_remove(cvs_resp_lastent, ent->ce_name, 0) < 0) &&
		    (type != CVS_RESP_CREATED)) {
d717 2
a718 2
	if ((type == CVS_RESP_REMOVED) && ((unlink(fpath) == -1) &&
	    errno != ENOENT)) {
@


1.71
log
@cvs_mkadmin() cannot return < 0 anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.70 2006/01/26 09:05:31 xsa Exp $	*/
d339 1
a339 1
	    sizeof(statpath)) >= sizeof(statpath))
d342 1
@


1.70
log
@strings cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.69 2006/01/25 08:15:05 xsa Exp $	*/
d875 1
a875 2
		if (cvs_mkadmin(dir, root->cr_str, repo, NULL, NULL, 0) < 0)
			return (-1);
@


1.69
log
@snprintf() cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.68 2006/01/02 08:11:56 xsa Exp $	*/
a393 1
	int l;
d449 4
a452 2
			l = snprintf(buf, sizeof(buf), "D/%s////", cf->cf_name);
			if (l == -1 || l >= (int)sizeof(buf)) {
@


1.68
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.67 2005/12/30 16:47:36 joris Exp $	*/
d323 1
a323 1
	int fd, len;
d336 5
a340 6

	len = snprintf(statpath, sizeof(statpath), "%s/%s", line,
	    CVS_PATH_STATICENTRIES);
	if (len == -1 || len >= (int)sizeof(statpath)) {
		cvs_log(LP_ERR,
		    "path overflow for Entries.static specification");
a341 1
	}
a552 1
	int len;
d563 2
a564 2
	len = snprintf(path, sizeof(path), "%s%s", line, file);
	if (len == -1 || len >= (int)sizeof(path))
d567 2
a568 2
	len = snprintf(newpath, sizeof(newpath), "%s%s", line, newname);
	if (len == -1 || len >= (int)sizeof(path))
d572 1
a572 1
		fatal("failed to rename %s to %s: %s",
d611 2
d624 3
a626 2
	ret = snprintf(path, sizeof(path), "%s/%s", line, ent->ce_name);
	if (ret == -1 || ret >= (int)sizeof(path))
a628 2
	ret = 0;

a698 1
	int l;
d705 4
a708 2
	l = snprintf(fpath, sizeof(fpath), "%s/%s", line, file);
	if (l == -1 || l >= (int)sizeof(fpath))
a756 1
	int len;
d771 4
a774 3
	len = snprintf(file, sizeof(file), "%s%s", line, fname);
	if (len == -1 || len >= (int)sizeof(file))
		fatal("path overflow in Rcs-diff response");
a847 2
	int l;
	size_t len;
d854 4
a857 2
	l = snprintf(cvspath, sizeof(cvspath), "%s/%s", dir, CVS_PATH_CVSDIR);
	if (l == -1 || l >= (int)sizeof(cvspath))
d864 4
a867 3
			l = snprintf(repo, sizeof(repo), "%s/%s", cvs_repo_base,
			    dir);
			if (l == -1 || l >= (int)sizeof(repo))
d870 1
a870 2
			len = strlcpy(repo, dir, sizeof(repo));
			if (len >= sizeof(repo))
d885 2
a886 2
		len = strlcpy(cvs_resp_lastdir, dir, sizeof(cvs_resp_lastdir));
		if (len >= sizeof(cvs_resp_lastdir))
@


1.67
log
@more code cleanup, ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.66 2005/12/29 21:28:26 joris Exp $	*/
d27 1
a27 13

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.66
log
@we were wrongly decrementing cvs_mtskt_depth when handling
a '-' MT response.

this caused checkout and update to fail remotely.
caught by xfree().
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.65 2005/12/20 18:17:01 xsa Exp $	*/
d339 1
a339 2
	if (cvs_getln(root, rpath, sizeof(rpath)) < 0)
		return (-1);
d389 1
a389 2
	if (cvs_getln(root, buf, sizeof(buf)) < 0)
		return (-1);
d502 1
a502 2
	if (cvs_getln(root, entbuf, sizeof(entbuf)) < 0)
		return (-1);
d505 1
a505 2
	if (cvs_getln(root, entbuf, sizeof(entbuf)) < 0)
		return (-1);
d568 2
a569 1
	char path[MAXPATHLEN], newpath[MAXPATHLEN], newname[MAXNAMLEN], *file;
d572 2
a573 3
	if ((cvs_getln(root, path, sizeof(path)) < 0) ||
	    (cvs_getln(root, newname, sizeof(newname)) < 0))
		return (-1);
d575 2
a576 4
	if ((file = basename(path)) == NULL) {
		cvs_log(LP_ERR, "no base file name in Copy-file path");
		return (-1);
	}
d579 3
a581 4
	if (len == -1 || len >= (int)sizeof(path)) {
		cvs_log(LP_ERR, "source path overflow in Copy-file response");
		return (-1);
	}
d583 2
a584 5
	if (len == -1 || len >= (int)sizeof(path)) {
		cvs_log(LP_ERR,
		    "destination path overflow in Copy-file response");
		return (-1);
	}
d587 2
a588 2
		cvs_log(LP_ERRNO, "failed to rename %s to %s", path, newpath);
		return (-1);
d629 1
a629 2
	if (cvs_getln(root, path, sizeof(path)) < 0)
		return (-1);
d632 1
a632 2
	if (cvs_getln(root, path, sizeof(path)) < 0)
		return (-1);
d636 1
d638 3
a640 4
	if (ret == -1 || ret >= (int)sizeof(path)) {
		cvs_log(LP_ERR, "Entries path overflow in response");
		return (-1);
	}
d666 1
a666 4
	if (cvs_ent_add(cvs_resp_lastent, ent) < 0) {
		cvs_ent_free(ent);
		return (-1);
	}
d668 1
a668 2
	if ((fbuf = cvs_recvfile(root, &fmode)) == NULL)
		return (-1);
d714 2
a715 1
	char buf[MAXPATHLEN], base[MAXPATHLEN], fpath[MAXPATHLEN], *file;
d717 1
a717 2
	if (cvs_getln(root, buf, sizeof(buf)) < 0)
		return (-1);
d721 2
a722 5
	if (l == -1 || l >= (int)sizeof(fpath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", fpath);
		return (-1);
	}
d746 1
a746 4
	if (cvs_strtomode(line, &cvs_lastmode) < 0) {
		cvs_log(LP_ERR, "error handling Mode response");
		return (-1);
	}
d780 1
a780 2
	if (cvs_getln(root, buf, sizeof(buf)) < 0)
		return (-1);
d786 2
a787 4
	if (len == -1 || len >= (int)sizeof(file)) {
		cvs_log(LP_ERR, "path overflow in Rcs-diff response");
		return (-1);
	}
d790 1
a790 2
	if (cvs_getln(root, buf, sizeof(buf)) < 0)
		return (-1);
d849 1
a849 2
	if (tmpl == NULL)
		return (-1);
d871 1
a871 1
		return (-1);
d880 1
a880 1
				return (-1);
d882 3
a884 1
			strlcpy(repo, dir, sizeof(repo));
d899 2
a900 5
		if (len >= sizeof(cvs_resp_lastdir)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", cvs_resp_lastdir);
			return (-1);
		}
@


1.65
log
@cvs_buf_putc() and cvs_buf_write_*() functions cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.64 2005/12/10 20:27:45 joris Exp $	*/
d257 1
a257 1
			xfree(cvs_mt_stack[cvs_mtstk_depth--]);
@


1.64
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.63 2005/12/03 01:02:09 joris Exp $	*/
d685 1
a685 4
	if (cvs_buf_write(fbuf, path, fmode) < 0) {
		cvs_buf_free(fbuf);
		return (-1);
	}
@


1.63
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.62 2005/11/28 08:49:25 xsa Exp $	*/
d231 1
a231 1
			root->cr_version = strdup(line);
d246 1
a246 3
			cvs_mt_stack[cvs_mtstk_depth] = strdup(line + 1);
			if (cvs_mt_stack[cvs_mtstk_depth] == NULL)
				return (-1);
d257 1
a257 1
			free(cvs_mt_stack[cvs_mtstk_depth--]);
d551 1
a551 1
		free(cvs_fcksum);
d554 1
a554 5
	cvs_fcksum = strdup(line);
	if (cvs_fcksum == NULL) {
		cvs_log(LP_ERRNO, "failed to copy checksum string");
		return (-1);
	}
d713 1
a713 1
		free(cvs_fcksum);
d851 1
a851 1
		free(cvs_fcksum);
@


1.62
log
@consistency in error messages;
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.61 2005/10/22 17:32:57 joris Exp $	*/
d529 1
a529 1
		(void)cvs_ent_remove(cvs_resp_lastent, ent->ce_name);
d677 1
a677 1
		if ((cvs_ent_remove(cvs_resp_lastent, ent->ce_name) < 0) &&
d755 1
a755 1
	(void)cvs_ent_remove(cvs_resp_lastent, file);
@


1.61
log
@diff3 support, needed for merging files together;

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.60 2005/10/07 21:47:32 reyk Exp $	*/
d439 1
a439 1
			cvs_log(LP_ERRNO, "failed to stat '%s'", line);
@


1.60
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.59 2005/09/15 22:12:23 joris Exp $	*/
d841 1
a841 1
	res = rcs_patch(orig, patch);
@


1.59
log
@strip trailing slashes from any arguments passed to opencvs.
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.58 2005/09/15 17:01:10 xsa Exp $	*/
d69 1
a69 1
	int (*hdlr)(struct cvsroot *, int, char *);
@


1.58
log
@check in cvs_mkadmin() wether we need to create or not the
CVS/Tag file. Sync the rest of the code accordingly; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.57 2005/08/19 08:28:54 xsa Exp $	*/
a47 9


#define STRIP_SLASH(p)						\
	do {							\
		size_t _slen;					\
		_slen = strlen(p);				\
		while ((_slen > 0) && (p[_slen - 1] == '/'))	\
			p[--_slen] = '\0';			\
	} while (0)
@


1.57
log
@missing cast;
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.56 2005/08/17 16:43:39 xsa Exp $	*/
d930 1
a930 1
		if (cvs_mkadmin(dir, root->cr_str, repo) < 0)
@


1.56
log
@more use of CVS_ENT_MAXLINELEN;
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.55 2005/08/16 16:34:19 xsa Exp $	*/
d272 1
a272 1
			else if (strncmp(line, "fname ", 6) == 0)
@


1.55
log
@#define CVS_ENT_MAXLINELEN	1024
.. as the maximum length of a line in an Entries file, and use it.
problem spotted a while ago by mpech@@.

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.54 2005/08/14 23:24:55 joris Exp $	*/
d426 1
a426 1
	char *file, subdir[MAXPATHLEN], buf[MAXPATHLEN];
d811 2
a812 1
	char file[MAXPATHLEN], buf[MAXPATHLEN], cksum_buf[CVS_CKSUM_LEN];
@


1.54
log
@we do not want '.' to show up in the entries file, because it
causes opencvs to crash.

reported by Mike Pechkin
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.53 2005/08/02 12:08:13 joris Exp $	*/
d511 1
a511 1
	char entbuf[128];
@


1.53
log
@oops, missing variable;
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.52 2005/08/02 12:06:38 joris Exp $	*/
d430 8
@


1.52
log
@fix a few bugs which happened when there is no CVS/ directory or when
entire directories were removed from the repository

found by mpech@@
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.51 2005/07/26 14:58:58 xsa Exp $	*/
d421 1
@


1.51
log
@remove the (errno != ENOENT) check now that it is included in cvs_unlink();
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.50 2005/07/25 12:05:43 xsa Exp $	*/
d123 1
a123 1
static int resp_check_dir(const char *);
d427 2
d444 18
a461 4
		if (cf == NULL) {
			cvs_file_free(base);
			return (-1);
		}
d463 10
a472 21
		/*
		 * If the Entries file for the parent is already
		 * open, operate on that, instead of reopening it
		 * and invalidating the opened list.
		 */
		if (!strcmp(subdir, cvs_resp_lastdir))
			entf = cvs_resp_lastent;
		else
			entf = cvs_ent_open(subdir, O_WRONLY);

		/* add a directory entry to the parent */
		if (entf != NULL) {
			if ((ent = cvs_ent_get(entf, cf->cf_name)) == NULL) {
				snprintf(buf, sizeof(buf), "D/%s////",
				    cf->cf_name);
				ent = cvs_ent_parse(buf);
				if (ent == NULL)
					cvs_log(LP_ERR,
					    "failed to create directory entry");
				else
					cvs_ent_add(entf, ent);
d475 6
a480 2
			if (strcmp(subdir, cvs_resp_lastdir))
				cvs_ent_close(entf);
d483 2
a484 1
		cvs_file_free(cf);
d487 1
d513 1
a513 1
	if (resp_check_dir(line) < 0)
d661 7
a667 1
	if (resp_check_dir(line) < 0)
d752 1
a752 1
	if (resp_check_dir(line) < 0)
d894 1
a894 1
resp_check_dir(const char *dir)
d896 1
d898 25
@


1.50
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.49 2005/07/24 17:20:14 xsa Exp $	*/
d371 1
a371 1
		    (cvs_unlink(statpath) == -1) && (errno != ENOENT)) {
@


1.49
log
@use cvs_unlink();
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.48 2005/07/24 16:46:40 xsa Exp $	*/
d47 1
a47 1
#define CVS_MTSTK_MAXDEPTH   16
@


1.48
log
@do not use `if (!var)' unless it's boolean, better use an == check;
ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.47 2005/07/23 11:19:46 joris Exp $	*/
d371 1
a371 3
		    (unlink(statpath) == -1) && (errno != ENOENT)) {
			cvs_log(LP_ERRNO, "failed to unlink %s file",
			    CVS_PATH_STATICENTRIES);
@


1.47
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.46 2005/07/22 16:27:29 joris Exp $	*/
d369 1
a369 1
	if (!cvs_noexec) {
@


1.46
log
@use the cf_name field of the CVSFILE struct instead of using the old
CVS_FILE_NAME macro. This macro used to be nifty because of all
the referencing for the names, but since we don't do that anymore and
use cf_name directly... byebye CVS_FILE_NAME()

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.45 2005/07/14 07:38:35 xsa Exp $	*/
d75 1
a75 1

a347 1
	struct stat dst;
d355 5
a359 7
	/* if the directory doesn't exist, first create it */
	if ((stat(line, &dst) == -1) && (errno == ENOENT)) {
		if ((mkdir(line, 0755) == -1) && (errno != ENOENT)) {
			cvs_log(LP_ERRNO, "failed to create %s", line);
			return (-1);
		}
	}
d395 1
a395 2
 * specified directory doesn't exist, we create it and attach it to the
 * global file structure.
d400 1
a400 4
	char buf[MAXPATHLEN], subdir[MAXPATHLEN], *file;
	struct cvs_ent *ent;
	CVSFILE *cf, *sdir;
	CVSENTRIES *entf;
d408 21
d430 2
a431 3
	sdir = cvs_file_find(cvs_files, subdir);
	if (sdir == NULL) {
		cvs_log(LP_ERR, "failed to find %s", subdir);
a432 1
	}
d434 6
a439 11
	cf = cvs_file_find(sdir, file);
	if (cf == NULL) {
		/* attempt to create it */
		cf = cvs_file_create(sdir, line, DT_DIR, 0755);
		if (cf == NULL) {
			return (-1);
		}
		cf->cf_repo = strdup(line);
		if (cf->cf_repo == NULL) {
			cvs_log(LP_ERRNO, "failed to duplicate `%s'", line);
			cvs_file_free(cf);
a441 2
		cf->cf_root = root;
		root->cr_ref++;
d443 3
a445 2
		if (cvs_file_attach(sdir, cf) < 0) {
			cvs_file_free(cf);
d475 2
d479 1
a479 5
	if (type == CVS_RESP_CLRSTICKY)
		cf->cf_flags &= ~CVS_DIRF_STICKY;
	else if (type == CVS_RESP_SETSTICKY)
		cf->cf_flags |= CVS_DIRF_STICKY;

@


1.45
log
@be consistent when declaring cvs_ent structs; ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.44 2005/07/10 00:12:52 joris Exp $	*/
d455 1
a455 2
			if ((ent = cvs_ent_get(entf,
			    CVS_FILE_NAME(cf))) == NULL) {
d457 1
a457 1
				    CVS_FILE_NAME(cf));
@


1.44
log
@if the Entries file for the parent directory is already open
when receiving a Clear-sticky / Set-sticky response from
the server, don't re-open it again and invalidate the open list,
but instead use the already opened Entries file.

solves our missing directory problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.43 2005/07/05 12:00:45 joris Exp $	*/
d627 1
a627 1
	struct cvs_ent *ep;
d640 1
a640 1
	if ((ep = cvs_ent_parse(path)) == NULL)
d642 1
a642 1
	ret = snprintf(path, sizeof(path), "%s/%s", line, ep->ce_name);
d653 1
a653 1
		ep->ce_mtime = cvs_modtime;
d655 1
a655 1
		ep->ce_mtime = time(&(ep->ce_mtime));
d659 1
a659 1
		if ((cvs_ent_remove(cvs_resp_lastent, ep->ce_name) < 0) &&
d662 1
a662 1
			    ep->ce_name);
d666 2
a667 2
	if (cvs_ent_add(cvs_resp_lastent, ep) < 0) {
		cvs_ent_free(ep);
@


1.43
log
@

protect against cvs_getln() failure.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.42 2005/06/10 21:13:40 joris Exp $	*/
d443 10
d454 3
a456 2
		if ((entf = cvs_ent_open(subdir, O_WRONLY)) != NULL) {
			if ((ent = cvs_ent_get(entf, CVS_FILE_NAME(cf))) == NULL) {
d466 3
a468 1
			cvs_ent_close(entf);
@


1.42
log
@

instead of opening and closing the entry file all the
time, keep the entry file for the last received directory
open until we switch directories. cuts CPU time in half
and increases overall performance a bit.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.41 2005/05/31 08:58:48 xsa Exp $	*/
d481 2
a482 1
	cvs_getln(root, entbuf, sizeof(entbuf));
d779 3
a781 1
	cvs_getln(root, buf, sizeof(buf));
d792 3
a794 1
	cvs_getln(root, buf, sizeof(buf));
@


1.41
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.40 2005/05/24 22:00:25 joris Exp $	*/
d115 9
a123 1

d303 5
a478 1
	CVSENTRIES *entfile;
d487 1
a487 2
	entfile = cvs_ent_open(line, O_WRONLY);
	if (entfile == NULL)
d489 1
d491 1
a491 1
		cvs_ent_addln(entfile, entbuf);
a495 1
			cvs_ent_close(entfile);
d503 1
a503 1
		(void)cvs_ent_remove(entfile, ent->ce_name);
d505 1
a505 1
		cvs_ent_add(entfile, ent);
a506 1
	cvs_ent_close(entfile);
a612 1
	CVSENTRIES *entfile;
d635 1
a635 3
	entfile = cvs_ent_open(line, O_WRONLY);
	if (entfile == NULL) {
		cvs_ent_free(ep);
a636 1
	}
d645 1
a645 1
		if ((cvs_ent_remove(entfile, ep->ce_name) < 0) &&
d652 1
a652 1
	if (cvs_ent_add(entfile, ep) < 0) {
a653 1
		cvs_ent_close(entfile);
a656 2
	cvs_ent_close(entfile);

a707 1
	CVSENTRIES *ef;
d720 2
a721 9
	ef = cvs_ent_open(line, O_RDWR);
	if (ef == NULL) {
		cvs_log(LP_ERR, "error handling `Removed' response");
		if (type == CVS_RESP_RMENTRY)
			return (-1);
	} else {
		(void)cvs_ent_remove(ef, file);
		cvs_ent_close(ef);
	}
d723 1
d849 35
@


1.40
log
@

- create the Entries.Static file with 0644 permissions instead of 0400.
- only add the directory entry to the Entry file when it's not already there.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.39 2005/05/24 19:13:52 joris Exp $	*/
d32 2
d35 1
a36 2
#include <errno.h>
#include <dirent.h>
d38 1
a39 2
#include <string.h>
#include <libgen.h>
a43 1
#include "file.h"
@


1.39
log
@

remove debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.38 2005/05/24 07:33:36 joris Exp $	*/
d367 1
a367 1
			fd = open(statpath, O_CREAT|O_TRUNC|O_WRONLY, 0400);
d433 10
a442 8
			snprintf(buf, sizeof(buf), "D/%s////",
			    CVS_FILE_NAME(cf));
			ent = cvs_ent_parse(buf);
			if (ent == NULL)
				cvs_log(LP_ERR,
				    "failed to create directory entry");
			else
				cvs_ent_add(entf, ent);
@


1.38
log
@

don't try to create directories with mkdir(2) in cvs_resp_sticky().
it will already be created with cvs_file_create().

fixes the Clear-sticky and Set-sticky responses.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.37 2005/05/24 04:12:25 jfb Exp $	*/
a414 1
			printf("yeah its this man\n");
@


1.37
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.36 2005/05/24 03:06:16 jfb Exp $	*/
d346 1
a346 1
		if (mkdir(line, 0755) == -1) {
a393 1
	struct stat dst;
a402 8
	/* if the directory doesn't exist, first create it */
	if ((stat(line, &dst) == -1) && (errno == ENOENT)) {
		if (mkdir(line, 0755) == -1) {
			cvs_log(LP_ERRNO, "failed to create %s", line);
			return (-1);
		}
	}

d414 2
a415 1
		if (cf == NULL)
d417 1
@


1.36
log
@create the target directory when we receive either of the
{Clear,Set}-{static-directory,sticky} responses

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.35 2005/05/20 19:58:03 xsa Exp $	*/
d53 4
a56 4
		size_t len;					\
		len = strlen(p);				\
		while ((len > 0) && (p[len - 1] == '/'))	\
			p[--len] = '\0';			\
@


1.35
log
@cvs_noexec checks; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.34 2005/05/19 04:17:24 jfb Exp $	*/
d336 1
d342 10
d394 1
d403 8
@


1.34
log
@use the date parsing code from date.y and fix timestamps on newly
created files so they match the values found in the corresponding
entries, otherwise all files appear as modified

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.33 2005/05/12 17:32:16 joris Exp $	*/
d349 5
a353 10
	if ((type == CVS_RESP_CLRSTATDIR) &&
	    (unlink(statpath) == -1) && (errno != ENOENT)) {
		cvs_log(LP_ERRNO, "failed to unlink %s file",
		    CVS_PATH_STATICENTRIES);
		return (-1);
	} else if (type == CVS_RESP_SETSTATDIR) {
		fd = open(statpath, O_CREAT|O_TRUNC|O_WRONLY, 0400);
		if (fd == -1) {
			cvs_log(LP_ERRNO,
			    "failed to set static directory on %s", line);
d355 10
a365 2
		(void)close(fd);

@


1.33
log
@

fix segfault in cvs_resp_error()
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.32 2005/05/11 00:07:57 joris Exp $	*/
d569 1
a569 1
	cvs_modtime = cvs_datesec(line, CVS_DATE_RFC822, 1);
a617 1
		cvs_modtime = CVS_DATE_DMSEC;	/* invalidate */
d654 3
@


1.32
log
@

in cvs_resp_removed(), don't abort the operation if we are trying
to unlink(2) a file that has already been removed.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.31 2005/05/03 08:55:16 joris Exp $	*/
d310 2
@


1.31
log
@

catch stupid gnu cvs behaviour, it sends an empty error message
at the end of a diff command (even successfull ones) so
we have to make sure not to show the empty line on screen.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.30 2005/04/20 15:50:54 joris Exp $	*/
d708 2
a709 1
	if ((type == CVS_RESP_REMOVED) && (unlink(fpath) == -1)) {
@


1.30
log
@

shut up a useless warning for newly created files

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.29 2005/04/19 16:57:07 joris Exp $	*/
d305 1
d310 7
@


1.29
log
@

correctly handle the "Removed" response, so that the correct
file and entry are removed.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.28 2005/04/18 21:02:50 jfb Exp $	*/
d614 3
a616 2
		if (cvs_ent_remove(entfile, ep->ce_name) < 0)
			cvs_log(LP_WARN, "failed to remove entry for `%s'",
d618 1
@


1.28
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.27 2005/04/15 13:14:00 xsa Exp $	*/
d673 2
a674 1
	char base[MAXPATHLEN], *file;
d677 12
a688 2
	cvs_splitpath(line, base, sizeof(base), &file);
	ef = cvs_ent_open(base, O_RDWR);
d698 2
a699 2
	if ((type == CVS_RESP_REMOVED) && (unlink(line) == -1)) {
		cvs_log(LP_ERRNO, "failed to unlink `%s'", line);
@


1.27
log
@braino; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.26 2005/04/15 07:41:20 xsa Exp $	*/
d392 2
a393 2
		cf->cf_ddat->cd_repo = strdup(line);
		if (cf->cf_ddat->cd_repo == NULL) {
d398 1
a398 1
		cf->cf_ddat->cd_root = root;
d421 1
a421 1
		cf->cf_ddat->cd_flags &= ~CVS_DIRF_STICKY;
d423 1
a423 1
		cf->cf_ddat->cd_flags |= CVS_DIRF_STICKY;
@


1.26
log
@shudup useless warning; ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.25 2005/04/14 03:02:35 joris Exp $	*/
d541 1
a541 1
		cvs_log(LP_ERRNO, "failed to rename %s to %s", line, newname);
@


1.25
log
@

set ret to 0 after using it to check snprintf() so that
cvs_resp_handle() doesn't freak out and causes everything
to go crazy and fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.24 2005/04/13 15:08:36 jfb Exp $	*/
d466 1
a466 3
		if (cvs_ent_remove(entfile, ent->ce_name) < 0)
			cvs_log(LP_WARN, "failed to remove `%s' entry",
			    ent->ce_name);
@


1.24
log
@check return values of snprintf() for potential overflows or errors

ok xsa@@, joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.23 2005/04/11 18:02:58 joris Exp $	*/
d600 1
@


1.23
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.22 2005/03/29 17:37:37 joris Exp $	*/
d324 1
a324 1
	int fd;
d331 1
a331 1
	snprintf(statpath, sizeof(statpath), "%s/%s", line,
d333 5
d517 1
d530 11
a540 2
	snprintf(path, sizeof(path), "%s%s", line, file);
	snprintf(newpath, sizeof(newpath), "%s%s", line, newname);
a582 1
	ret = 0;
d595 5
a599 1
	snprintf(path, sizeof(path), "%s/%s", line, ep->ce_name);
d732 1
d745 5
a749 1
	snprintf(file, sizeof(file), "%s%s", line, fname);
@


1.22
log
@

cvs_file_attach() can fail, make sure we can handle it
when it does.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.21 2005/01/27 18:34:26 jfb Exp $	*/
a39 1
#include <sysexits.h>
@


1.21
log
@since we close the handles to Entries files, we must reopen them to add
the directories when receiving a Clear-sticky or Set-sticky response.

spotted by Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.20 2005/01/13 05:39:07 jfb Exp $	*/
d397 4
a400 1
		cvs_file_attach(sdir, cf);
@


1.20
log
@when warning about unimplemented handlers, do not attempt to print
the errno message string
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.19 2005/01/06 18:40:33 jfb Exp $	*/
d367 1
d400 1
a400 1
		if (CVS_DIR_ENTRIES(sdir) != NULL) {
d408 2
a409 1
				cvs_ent_add(CVS_DIR_ENTRIES(sdir), ent);
@


1.19
log
@check the return value of a strdup() call and return an error on
failure

from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.18 2004/12/13 22:53:48 jfb Exp $	*/
d164 1
a164 1
		cvs_log(LP_ERRNO, "handler for `%s' not implemented", cmd);
@


1.18
log
@yet another mistake in the protocol docs...even if we send the
appropriate Entry for a file which was lost locally, the server
responds with a Created, so we must remove the previous entry
before replacing it with the one we receive.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.17 2004/12/13 17:09:01 jfb Exp $	*/
d388 5
@


1.17
log
@free the buffer used to receive a file in the Updated response handler
and saner handling of checksums

spotted by and discussed with Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.16 2004/12/10 18:47:38 jfb Exp $	*/
d587 1
a587 1
	    (type == CVS_RESP_MERGED)) {
@


1.16
log
@fix the Copy-file response handler, it seems the CVS protocol
documentation is not exactly up to date for that handler as well
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.15 2004/12/08 20:00:23 jfb Exp $	*/
d551 1
d559 1
d601 4
a604 2
	fbuf = cvs_recvfile(root, &fmode);
	if (fbuf == NULL)
d606 2
a607 2

	cvs_buf_write(fbuf, path, fmode);
d620 3
a622 4
		if (cvs_cksum(path, cksum_buf, sizeof(cksum_buf)) < 0) {
		}

		if (strcmp(cksum_buf, cvs_fcksum) != 0) {
d625 1
d632 1
a632 1
	return (0);
@


1.15
log
@simplify the handler for Created, Updated, Update-existing and Merged
and close the Entries file handle when we are done modifying it.
this fixes a leak and syncs the contents on disk so the revisions
and dates get updated properly
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.13 2004/12/07 17:10:56 tedu Exp $	*/
d39 1
d503 1
a503 1
	char newname[MAXNAMLEN];
d505 3
a507 2
	/* read the new file name given by the server */
	if (cvs_getln(root, newname, sizeof(newname)) < 0)
d510 9
a518 1
	if (rename(line, newname) == -1) {
@


1.14
log
@support for the `Copy-file' response
@
text
@d149 1
d167 6
a172 1
	return (*cvs_resp_swtab[resp->resp_id].hdlr)(root, resp->resp_id, cp);
a543 1
	CVSFILE *cf;
a549 7
	/* find parent directory of file */
	cf = cvs_file_find(cvs_files, line);
	if (cf == NULL) {
		cvs_log(LP_ERR, "failed to find directory %s", line);
		return (-1);
	}

d568 1
a568 2
	if (type == CVS_RESP_CREATED) {
		/* set the timestamp as the last one received from Mod-time */
d570 6
a575 2
		cvs_ent_add(entfile, ep);
	} else if ((type == CVS_RESP_UPDEXIST) || (type == CVS_RESP_UPDATED)) {
d579 1
d581 4
a584 2
		cvs_ent_add(entfile, ep);
	} else if (type == CVS_RESP_MERGED) {
d586 2
@


1.13
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.12 2004/12/07 16:48:55 jfb Exp $	*/
d75 1
d88 1
a88 1
	{ NULL              },
d478 26
@


1.12
log
@avoid a crash when receiving either a Created, Updated, Update-existing
or Merged response by reopening the Entries file correctly before
making modifications to it

Fixes a SIGSEGV reported by Joris Vink and djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.11 2004/12/06 21:03:12 deraadt Exp $	*/
a59 1

a144 1

a176 1

a206 1

d284 1
a284 1
 * Handler for the `ok' response.  This handler's job is to 
a285 1

d289 1
d297 1
a297 1
 * Handler for the `error' response.  This handler's job is to 
a298 1

d302 1
a313 1

a352 1

a412 1

a465 1

a490 1

a504 1

a596 1

a627 1

a643 1

a654 1

d675 1
a675 1
	if (ent == NULL) {
a676 1
	}
a723 1

@


1.11
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.10 2004/12/06 04:10:06 jfb Exp $	*/
d127 1
a127 1
static time_t cvs_modtime = 0;
d522 1
d547 6
d556 8
a563 3
		cvs_ent_add(cf->cf_ddat->cd_ent, ep);
	} else if (type == CVS_RESP_UPDEXIST) {
	} else if (type == CVS_RESP_UPDATED) {
d572 8
a579 6
	tv[0].tv_sec = (long)cvs_modtime;
	tv[0].tv_usec = 0;
	tv[1].tv_sec = (long)cvs_modtime;
	tv[1].tv_usec = 0;
	if (utimes(path, tv) == -1)
		cvs_log(LP_ERRNO, "failed to set file timestamps");
d644 1
@


1.10
log
@implement a saner handler for the Removed and Remove-entry responses.
in the case of Removed, the file will actually be unlinked now.
@
text
@d1 1
a1 1
/*	$OpenBSD: resp.c,v 1.9 2004/12/03 21:08:40 jfb Exp $	*/
d162 1
a162 2
	}
	else if (cvs_resp_swtab[resp->resp_id].hdlr == NULL) {
d249 1
a249 2
		}
		else if (*line == '-') {
d253 1
a253 2
			}
			else if (strcmp(line + 1,
d259 1
a259 2
		}
		else {
d337 1
a337 2
	}
	else if (type == CVS_RESP_SETSTATDIR) {
d439 1
a439 2
	}
	else if (type == CVS_RESP_CHECKEDIN) {
d550 2
a551 4
	}
	else if (type == CVS_RESP_UPDEXIST) {
	}
	else if (type == CVS_RESP_UPDATED) {
@


1.9
log
@When receiving a `Checked-in' response, update the Entries information
correctly.  This fixes the problem caused by a commit not updating
the information properly and subsequent commands generating a message
similar to:

Merging differences between 1.X and 1.Y into file
file already contains the differences between 1.X and 1.Y
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d596 4
a599 1
 * Handler for the `Removed' and `Remove-entry' responses.
d610 11
a620 1
	if (ef == NULL)
d622 1
a622 4

	printf("Received a `Remove' on %s\n", line);
	cvs_ent_remove(ef, file);
	cvs_ent_close(ef);
@


1.8
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@d422 1
d429 1
d442 21
a462 1
	cvs_ent_addln(entfile, entbuf);
@


1.7
log
@print error messages when we receive the `error' response
@
text
@d387 1
a387 1
		cf = cvs_file_create(line, DT_DIR, 0755);
d398 2
a399 1
			snprintf(buf, sizeof(buf), "D/%s////", cf->cf_name);
@


1.6
log
@Remove unused variables
@
text
@d311 1
@


1.5
log
@* add an entry for directories when we create them
* when writing a directory entry, skip the revision and timestamp
@
text
@a499 1
	size_t len;
a504 1
	struct tm tm;
@


1.4
log
@Assume the parent's Entries file is always opened when receiving a new
entry to add, and move to using the `ce_mtime' field of the entry so
we don't end up adding data from a local variable that was discarded
@
text
@d366 2
a367 1
	char rpath[MAXPATHLEN], subdir[MAXPATHLEN], *file;
d371 1
a371 1
	if (cvs_getln(root, rpath, sizeof(rpath)) < 0)
d394 11
@


1.3
log
@Cleanup and fix a call to cvs_splitpath()
@
text
@d51 10
a76 6
static const char *cvs_months[] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};


d358 3
a360 1
 * Handler for the `Clear-sticky' and `Set-sticky' responses.
d366 6
a371 4
	size_t len;
	char rpath[MAXPATHLEN];
	struct stat st;
	CVSFILE *cf;
d373 1
a373 4
	/* remove trailing slash */
	len = strlen(line);
	if ((len > 0) && (line[len - 1] == '/'))
		line[--len] = '\0';
d375 6
a380 2
	/* get the remote path */
	cvs_getln(root, rpath, sizeof(rpath));
d382 2
a383 2
	/* if the directory doesn't exist, create it */
	if (stat(line, &st) == -1) {
d385 6
a390 11
		if (errno != ENOENT) {
			cvs_log(LP_ERRNO, "failed to stat %s", line);
		}
		else {
			cf = cvs_file_create(line, DT_DIR, 0755);
			if (cf == NULL)
				return (-1);
			cf->cf_ddat->cd_repo = strdup(line);
			cf->cf_ddat->cd_root = root;
			root->cr_ref++;
			cvs_mkadmin(cf, 0755);
d392 1
a392 2
			cvs_file_free(cf);
		}
d395 4
a398 4
	if (type == CVS_RESP_CLRSTICKY) {
	}
	else if (type == CVS_RESP_SETSTICKY) {
	}
d473 1
a473 50
	int i;
	long off;
	char sign, mon[8], gmt[8], hr[4], min[4], *ep;
	struct tm cvs_tm;

	memset(&cvs_tm, 0, sizeof(cvs_tm));
	sscanf(line, "%d %3s %d %2d:%2d:%2d %5s", &cvs_tm.tm_mday, mon,
	    &cvs_tm.tm_year, &cvs_tm.tm_hour, &cvs_tm.tm_min,
	    &cvs_tm.tm_sec, gmt);
	cvs_tm.tm_year -= 1900;
	cvs_tm.tm_isdst = -1;

	if (*gmt == '-') {
		sscanf(gmt, "%c%2s%2s", &sign, hr, min);
		cvs_tm.tm_gmtoff = strtol(hr, &ep, 10);
		if ((cvs_tm.tm_gmtoff == LONG_MIN) ||
		    (cvs_tm.tm_gmtoff == LONG_MAX) ||
		    (*ep != '\0')) {
			cvs_log(LP_ERR,
			    "parse error in GMT hours specification `%s'", hr);
			cvs_tm.tm_gmtoff = 0;
		}
		else {
			/* get seconds */
			cvs_tm.tm_gmtoff *= 3600;

			/* add the minutes */
			off = strtol(min, &ep, 10);
			if ((cvs_tm.tm_gmtoff == LONG_MIN) ||
			    (cvs_tm.tm_gmtoff == LONG_MAX) ||
			    (*ep != '\0')) {
				cvs_log(LP_ERR,
				    "parse error in GMT minutes "
				    "specification `%s'", min);
			}
			else
				cvs_tm.tm_gmtoff += off * 60;
		}
	}
	if (sign == '-')
		cvs_tm.tm_gmtoff = -cvs_tm.tm_gmtoff;

	for (i = 0; i < (int)(sizeof(cvs_months)/sizeof(cvs_months[0])); i++) {
		if (strcmp(cvs_months[i], mon) == 0) {
			cvs_tm.tm_mon = i;
			break;
		}
	}

	cvs_modtime = mktime(&cvs_tm);
d481 2
a482 1
 * Handler for the `Updated' and `Created' responses.
d490 1
a490 1
	char tbuf[32], path[MAXPATHLEN], cksum_buf[CVS_CKSUM_LEN];
d492 1
a492 1
	CVSENTRIES *ef;
d494 1
d497 8
a504 1
	ep = NULL;
d507 2
a508 1
	cvs_getln(root, path, sizeof(path));
d511 1
a511 3
	cvs_getln(root, path, sizeof(path));
	ep = cvs_ent_parse(path);
	if (ep == NULL)
d513 4
a516 1
	snprintf(path, sizeof(path), "%s%s", line, ep->ce_name);
d520 2
a521 11
		ep->ce_timestamp = ctime_r(&cvs_modtime, tbuf);
		len = strlen(tbuf);
		if ((len > 0) && (tbuf[len - 1] == '\n'))
			tbuf[--len] = '\0';

		ef = cvs_ent_open(line, O_WRONLY);
		if (ef == NULL)
			return (-1);

		cvs_ent_add(ef, ep);
		cvs_ent_close(ef);
@


1.2
log
@When creating a file, set its last access and modification times to the
last timestamp received by the `Mod-time' command
@
text
@d324 3
a326 1
	cvs_getln(root, rpath, sizeof(rpath));
d340 2
a341 2
			cvs_log(LP_ERRNO, "failed to create %s file",
			    CVS_PATH_STATICENTRIES);
d612 1
a612 1
	char base[MAXPATHLEN], file[MAXNAMLEN];
d615 1
a615 2
	cvs_splitpath(line, base, sizeof(base), file, sizeof(file));

@


1.1
log
@Move all of the request- and response-specific handlers into separate
files and have only the generic function of each type available to
the outside
@
text
@d30 1
d537 1
a548 1
	printf("adding entry `%s'\n", path); 
d575 7
@

