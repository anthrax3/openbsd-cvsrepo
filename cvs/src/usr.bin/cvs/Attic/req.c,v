head	1.45;
access;
symbols
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12;
locks; strict;
comment	@ * @;


1.45
date	2006.05.27.03.30.31;	author joris;	state dead;
branches;
next	1.44;

1.44
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.28.07.17.17;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.27.12.56.28;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.04.14.58.12;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.30.16.47.36;	author joris;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.24.19.07.52;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.22.14.31.44;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.21.20.04.36;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.20.17.33.40;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.03.20.27.35;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.15.17.01.10;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.29.10.38.55;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.23.10.59.47;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.22.17.55.35;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.21.12.32.38;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.19.15.30.37;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.18.08.13.03;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.10.13.59.52;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.17.15.09.55;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.10.21.14.47;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.31.08.26.40;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.30.08.13.15;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.27.22.33.56;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.25.03.58.12;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.18.20.24.19;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.18.21.33.34;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.22.16.33.44;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.13.06.09.14;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.13.05.39.07;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.28.20.46.13;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.19.17.32.55;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.06.14.49.03;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.04.13.55.24;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.04.13.03.52;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.04.12.41.58;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.03.04.58.45;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.45
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@/*	$OpenBSD: req.c,v 1.44 2006/04/14 02:45:35 deraadt Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "includes.h"

#include "buf.h"
#include "cvs.h"
#include "log.h"
#include "proto.h"


extern char *cvs_rootstr;
extern int   cvs_compress;
extern char *cvs_rsh;
extern int   cvs_trace;
extern int   cvs_nolog;
extern int   cvs_readonly;


static int	cvs_req_set(int, char *);
static int	cvs_req_noop(int, char *);
static int	cvs_req_root(int, char *);
static int	cvs_req_validreq(int, char *);
static int	cvs_req_validresp(int, char *);
static int	cvs_req_expandmod(int, char *);
static int	cvs_req_directory(int, char *);
static int	cvs_req_useunchanged(int, char *);
static int	cvs_req_case(int, char *);
static int	cvs_req_argument(int, char *);
static int	cvs_req_globalopt(int, char *);
static int	cvs_req_gzipstream(int, char *);
static int	cvs_req_entry(int, char *);
static int	cvs_req_filestate(int, char *);

static int	cvs_req_command(int, char *);


struct cvs_reqhdlr {
	int	(*hdlr)(int, char *);
} cvs_req_swtab[CVS_REQ_MAX + 1] = {
	{ NULL                  },
	{ cvs_req_root          },
	{ cvs_req_validreq      },
	{ cvs_req_validresp     },
	{ cvs_req_directory     },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ cvs_req_entry         },
	{ NULL                  },
	{ NULL                  },	/* 10 */
	{ cvs_req_filestate     },
	{ cvs_req_filestate     },
	{ cvs_req_filestate     },
	{ cvs_req_useunchanged  },
	{ NULL                  },
	{ NULL                  },
	{ cvs_req_filestate     },
	{ cvs_req_case          },
	{ NULL                  },
	{ cvs_req_argument      },	/* 20 */
	{ cvs_req_argument      },
	{ cvs_req_globalopt     },
	{ cvs_req_gzipstream    },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },	/* 30 */
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ cvs_req_set           },
	{ cvs_req_expandmod     },
	{ cvs_req_command       },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },	/* 40 */
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ NULL                  },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },	/* 50 */
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },	/* 60 */
	{ NULL                  },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_noop          },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
	{ cvs_req_command       },
};



/*
 * Argument array built by `Argument' and `Argumentx' requests.
 */
static char *cvs_req_args[CVS_PROTO_MAXARG];

/* start at 1, because 0 will be the command name */
static int  cvs_req_nargs = 1;

static char *cvs_req_modulename;
static char *cvs_req_rootpath;
static char *cvs_req_currentdir;
extern char cvs_server_tmpdir[MAXPATHLEN];
static CVSENTRIES *cvs_req_entf;

/*
 * cvs_req_handle()
 *
 * Generic request handler dispatcher.  The handler expects the first line
 * of the command as single argument.
 * Returns the return value of the command on success, or -1 on failure.
 */
int
cvs_req_handle(char *line)
{
	char *cp, *cmd;
	struct cvs_req *req;

	cmd = line;

	cp = strchr(cmd, ' ');
	if (cp != NULL)
		*(cp++) = '\0';

	if ((req = cvs_req_getbyname(cmd)) == NULL)
		fatal("cvs_req_handle: cvs_req_getbyname failed");
	else if (cvs_req_swtab[req->req_id].hdlr == NULL)
		fatal("handler for `%s' not implemented", cmd);

	return (*cvs_req_swtab[req->req_id].hdlr)(req->req_id, cp);
}

/*
 * cvs_req_noop()
 */
static int
cvs_req_noop(int reqid, char *line)
{
	cvs_sendresp(CVS_RESP_OK, NULL);
	return (0);
}


static int
cvs_req_root(int reqid, char *line)
{
	if (cvs_req_rootpath != NULL) {
		cvs_log(LP_ERR, "duplicate Root request received");
		cvs_printf("Protocol error: Duplicate Root request");
		return (-1);
	}

	cvs_req_rootpath = xstrdup(line);
	cvs_rootstr = cvs_req_rootpath;

	return (0);
}


static int
cvs_req_validreq(int reqid, char *line)
{
	char *vreq;

	vreq = cvs_req_getvalid();
	if (vreq == NULL)
		return (-1);

	cvs_sendresp(CVS_RESP_VALIDREQ, vreq);
	cvs_sendresp(CVS_RESP_OK, NULL);

	return (0);
}

static int
cvs_req_validresp(int reqid, char *line)
{
	char *sp, *ep;
	struct cvs_resp *resp;

	sp = line;
	do {
		ep = strchr(sp, ' ');
		if (ep != NULL)
			*(ep++) = '\0';

		resp = cvs_resp_getbyname(sp);
		if (resp != NULL)
			;

		if (ep != NULL)
			sp = ep + 1;
	} while (ep != NULL);

	return (0);
}

static int
cvs_req_directory(int reqid, char *line)
{
	int pwd;
	size_t dirlen;
	char rdir[MAXPATHLEN];
	char *repo, *s, *p;

	pwd = (!strcmp(line, "."));

	cvs_getln(NULL, rdir, sizeof(rdir));

	STRIP_SLASH(rdir);

	if (cvs_req_currentdir != NULL)
		xfree(cvs_req_currentdir);

	cvs_req_currentdir = xstrdup(rdir);

	dirlen = strlen(cvs_req_currentdir);

	/*
	 * Lets make sure we always start at the correct
	 * directory.
	 */
	cvs_chdir(cvs_server_tmpdir, 1);

	/*
	 * Set repository path.
	 */
	if (strlen(cvs_req_rootpath) < dirlen) {
		s = cvs_req_currentdir + strlen(cvs_req_rootpath) + 1;
		if (s >= (cvs_req_currentdir + dirlen))
			fatal("you're bad, go away");
	} else
		s = cvs_req_currentdir;

	repo = xstrdup(s);

	/*
	 * Skip back "foo/bar" part, so we can feed the repo
	 * as a startpoint for cvs_create_dir().
	 */
	if (!pwd) {
		s = repo + strlen(repo) - strlen(line) - 1;
		if (*s != '/')
			fatal("cvs_req_directory: malformed directory");

		*s = '\0';
	}

	/*
	 * Obtain the modulename, we only need to do this at
	 * the very first time we get a Directory request.
	 */
	if (cvs_req_modulename == NULL) {
		if ((p = strchr(repo, '/')) != NULL)
			*p = '\0';

		cvs_req_modulename = xstrdup(repo);

		if (p != NULL)
			*p = '/';

		/*
		 * Now, create the admin files in the top-level
		 * directory for the temp repo.
		 */
		cvs_mkadmin(cvs_server_tmpdir, cvs_rootstr, repo, NULL,
		    NULL, 0);
	}

	/*
	 * create the directory plus the administrative files.
	 */
	if (cvs_create_dir(line, 1, cvs_rootstr, repo) < 0) {
		xfree(repo);
		return (-1);
	}

	/*
	 * cvs_create_dir() has already put us in the correct directory
	 * so now open it's Entry file for incoming files.
	 */
	if (cvs_req_entf != NULL)
		cvs_ent_close(cvs_req_entf);
	cvs_req_entf = cvs_ent_open(".", O_RDWR);
	if (cvs_req_entf == NULL)
		fatal("failed to open Entry file for %s", line);

	xfree(repo);
	return (0);
}

static int
cvs_req_entry(int reqid, char *line)
{
	struct cvs_ent *ent;

	/* parse received entry */
	if ((ent = cvs_ent_parse(line)) == NULL)
		return (-1);

	/* add it to the entry file and done */
	if (cvs_ent_add(cvs_req_entf, ent) < 0)
		fatal("cvs_req_entry: cvs_ent_add: `%s'", ent->ce_name);

	/* XXX */
	cvs_ent_write(cvs_req_entf);

	return (0);
}

/*
 * cvs_req_filestate()
 *
 * Handler for the `Modified', `Is-Modified', `Unchanged' and `Questionable'
 * requests, which are all used to report the assumed state of a file from the
 * client.
 */
static int
cvs_req_filestate(int reqid, char *line)
{
	int ret;
	mode_t fmode;
	BUF *fdata;
	struct cvs_ent *ent;

	ret = 0;
	switch (reqid) {
	case CVS_REQ_MODIFIED:
		fdata = cvs_recvfile(NULL, &fmode);
		if (fdata == NULL)
			return (-1);

		/* write the file */
		cvs_buf_write(fdata, line, fmode);
		cvs_buf_free(fdata);
		break;
	case CVS_REQ_ISMODIFIED:
		break;
	case CVS_REQ_UNCHANGED:
		ent = cvs_ent_get(cvs_req_entf, line);
		if (ent == NULL) {
			cvs_log(LP_ERR,
			    "received Unchanged request "
			    "for a non-existing file");
			ret = -1;
		} else {
			ent->ce_status = CVS_ENT_UPTODATE;
		}
		break;
	case CVS_REQ_QUESTIONABLE:
		cvs_printf("? %s\n", line);
		break;
	default:
		cvs_log(LP_ERR, "wrong request id type");
		ret = -1;
		break;
	}

	/* XXX */
	cvs_req_entf->cef_flags &= ~CVS_ENTF_SYNC;
	cvs_ent_write(cvs_req_entf);

	return (ret);
}

/*
 * cvs_req_expandmod()
 *
 */
static int
cvs_req_expandmod(int reqid, char *line)
{
	cvs_sendresp(CVS_RESP_OK, NULL);
	return (0);
}


/*
 * cvs_req_useunchanged()
 *
 * Handler for the `UseUnchanged' requests.  The protocol documentation
 * specifies that this request must be supported by the server and must be
 * sent by the client, though it gives no clue regarding its use.
 */
static int
cvs_req_useunchanged(int reqid, char *line)
{
	return (0);
}


/*
 * cvs_req_case()
 *
 * Handler for the `Case' requests, which toggles case sensitivity ON or OFF
 */
static int
cvs_req_case(int reqid, char *line)
{
	cvs_nocase = 1;
	return (0);
}


static int
cvs_req_set(int reqid, char *line)
{
	char *cp, *lp;

	lp = xstrdup(line);
	if ((cp = strchr(lp, '=')) == NULL)
		fatal("error in Set request (no = in variable assignment)");

	*(cp++) = '\0';

	if (cvs_var_set(lp, cp) < 0) {
		xfree(lp);
		return (-1);
	}

	xfree(lp);

	return (0);
}


static int
cvs_req_argument(int reqid, char *line)
{
	char *nap;

	if (cvs_req_nargs == CVS_PROTO_MAXARG)
		fatal("too many arguments");

	if (reqid == CVS_REQ_ARGUMENT) {
		cvs_req_args[cvs_req_nargs] = xstrdup(line);
		cvs_req_nargs++;
	} else if (reqid == CVS_REQ_ARGUMENTX) {
		if (cvs_req_nargs == 0)
			cvs_log(LP_WARN, "no argument to append to");
		else {
			xasprintf(&nap, "%s%s", cvs_req_args[cvs_req_nargs - 1],
			    line);

			xfree(cvs_req_args[cvs_req_nargs - 1]);
			cvs_req_args[cvs_req_nargs - 1] = nap;
		}
	}

	return (0);
}


static int
cvs_req_globalopt(int reqid, char *line)
{
	if (*line != '-' || *(line + 2) != '\0')
		fatal("invalid `Global_option' request format");

	switch (*(line + 1)) {
	case 'l':
		cvs_nolog = 1;
		break;
	case 'n':
		cvs_noexec = 1;
		break;
	case 'Q':
		verbosity = 0;
		break;
	case 'q':
		if (verbosity > 1)
			verbosity = 1;
		break;
	case 'r':
		cvs_readonly = 1;
		break;
	case 't':
		cvs_trace = 1;
		break;
	default:
		cvs_log(LP_ERR, "unknown global option `%s'", line);
		return (-1);
	}

	return (0);
}


/*
 * cvs_req_gzipstream()
 *
 * Handler for the `Gzip-stream' request, which enables compression at the
 * level given along with the request.  After this request has been processed,
 * all further connection data should be compressed.
 */
static int
cvs_req_gzipstream(int reqid, char *line)
{
	char *ep;
	long val;

	val = strtol(line, &ep, 10);
	if (line[0] == '\0' || *ep != '\0')
		fatal("invalid Gzip-stream level `%s'", line);
	else if (errno == ERANGE && (val < 0 || val > 9))
		fatal("Gzip-stream level %ld out of range", val);

	cvs_compress = (int)val;

	return (0);
}


/*
 * cvs_req_command()
 *
 * Generic request handler for CVS command requests (i.e. diff, update, tag).
 */
static int
cvs_req_command(int reqid, char *line)
{
	struct cvs_cmd *cmdp;

	cmdp = cvs_findcmdbyreq(reqid);
	if (cmdp == NULL) {
		cvs_sendresp(CVS_RESP_ERROR, NULL);
		return (-1);
	}

	/* close the Entry file if it's still open */
	if (cvs_req_entf != NULL)
		cvs_ent_close(cvs_req_entf);

	/* fill in the command name */
	cvs_req_args[0] = cmdp->cmd_name;

	/* switch to the correct directory */
	if (cmdp->cmd_op != CVS_OP_VERSION)
		cvs_chdir(cvs_server_tmpdir, 1);

	if (cvs_startcmd(cmdp, cvs_req_nargs, cvs_req_args) == 0)
		cvs_sendresp(CVS_RESP_OK, NULL);

	return (0);
}
@


1.44
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.43 2006/03/28 07:17:17 ray Exp $	*/
@


1.43
log
@xmalloc(num * size) -> xcalloc(num, size)
asprintf -> xasprintf
Remove asprintf check, which was non-portable anyway.

``okidoki'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.42 2006/01/27 12:56:28 xsa Exp $	*/
d503 1
a503 1
	if ((*line != '-') || (*(line + 2) != '\0'))
d549 1
a549 1
	if ((line[0] == '\0') || (*ep != '\0'))
d551 1
a551 1
	else if ((errno == ERANGE) && ((val < 0) || (val > 9)))
@


1.42
log
@cvs_mkadmin() cannot return < 0 anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.41 2006/01/04 14:58:12 xsa Exp $	*/
d488 1
a488 1
			asprintf(&nap, "%s%s", cvs_req_args[cvs_req_nargs - 1],
a489 2
			if (nap == NULL)
				fatal("cvs_req_argument: asprintf failed");
@


1.41
log
@make cvs_sendresp() return type void; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.40 2006/01/02 08:11:56 xsa Exp $	*/
d312 2
a313 6
		if (cvs_mkadmin(cvs_server_tmpdir, cvs_rootstr, repo,
		    NULL, NULL, 0) < 0) {
			cvs_log(LP_ERR, "failed to create admin files");
			xfree(repo);
			return (-1);
		}
@


1.40
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.39 2005/12/30 16:47:36 joris Exp $	*/
d185 1
a185 5
	int ret;

	ret = cvs_sendresp(CVS_RESP_OK, NULL);
	if (ret < 0)
		return (-1);
d215 2
a216 3
	if ((cvs_sendresp(CVS_RESP_VALIDREQ, vreq) < 0) ||
	    (cvs_sendresp(CVS_RESP_OK, NULL) < 0))
		return (-1);
d423 1
a423 5
	int ret;

	ret = cvs_sendresp(CVS_RESP_OK, NULL);
	if (ret < 0)
		return (-1);
a573 1
	int ret = 0;
d593 2
a594 1
	ret = cvs_startcmd(cmdp, cvs_req_nargs, cvs_req_args);
d596 1
a596 4
	if (ret == 0)
		ret = cvs_sendresp(CVS_RESP_OK, NULL);

	return (ret);
@


1.39
log
@more code cleanup, ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.38 2005/12/24 19:07:52 xsa Exp $	*/
d27 1
a27 11

#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.38
log
@add an argument to cvs_chdir() which enables or not the removal
of the directory we just chdir'd to.
Useful when the function fails especially for the server mode and
its temporary directory. This way it's not left behind on exit.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.37 2005/12/22 14:31:44 xsa Exp $	*/
d269 1
a269 2
	if (cvs_getln(NULL, rdir, sizeof(rdir)) < 0)
		return (-1);
@


1.37
log
@cvs_chdir() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.36 2005/12/21 20:04:36 xsa Exp $	*/
d285 1
a285 1
	cvs_chdir(cvs_server_tmpdir);
d612 1
a612 1
		cvs_chdir(cvs_server_tmpdir);
@


1.36
log
@fatal()ization! OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.35 2005/12/20 17:33:40 xsa Exp $	*/
d285 1
a285 2
	if (cvs_chdir(cvs_server_tmpdir) == -1)
		return (-1);
d611 2
a612 4
	if (cmdp->cmd_op != CVS_OP_VERSION) {
		if (cvs_chdir(cvs_server_tmpdir) == -1)
			return (-1);
	}
@


1.35
log
@cvs_buf_write() cannot fail here;
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.34 2005/12/10 20:27:45 joris Exp $	*/
d181 4
a184 7
	req = cvs_req_getbyname(cmd);
	if (req == NULL)
		return (-1);
	else if (cvs_req_swtab[req->req_id].hdlr == NULL) {
		cvs_log(LP_ERR, "handler for `%s' not implemented", cmd);
		return (-1);
	}
a213 5
	if (cvs_req_rootpath == NULL) {
		cvs_log(LP_ERRNO, "failed to copy Root path");
		return (-1);
	}

a277 4
	if (cvs_req_currentdir == NULL) {
		cvs_log(LP_ERR, "failed to duplicate directory");
		return (-1);
	}
d293 2
a294 4
		if (s >= (cvs_req_currentdir + dirlen)) {
			cvs_log(LP_ERR, "you're bad, go away");
			return (-1);
		}
d298 1
a298 4
	if ((repo = xstrdup(s)) == NULL) {
		cvs_log(LP_ERR, "failed to save repository path");
		return (-1);
	}
d306 2
a307 5
		if (*s != '/') {
			cvs_log(LP_ERR, "malformed directory");
			xfree(repo);
			return (-1);
		}
d320 1
a320 5
		if ((cvs_req_modulename = xstrdup(repo)) == NULL) {
			cvs_log(LP_ERR, "failed to save modulename");
			xfree(repo);
			return (-1);
		}
d352 2
a353 5
	if (cvs_req_entf == NULL) {
		cvs_log(LP_ERR, "failed to open Entry file for %s", line);
		xfree(repo);
		return (-1);
	}
d369 2
a370 5
	if (cvs_ent_add(cvs_req_entf, ent) < 0) {
		cvs_log(LP_ERR, "failed to add '%s' to the Entry file",
		    ent->ce_name);
		return (-1);
	}
d481 3
a483 4
	if ((lp = xstrdup(line)) == NULL) {
		cvs_log(LP_ERRNO, "failed to copy Set argument");
		return (-1);
	}
a484 6
	if ((cp = strchr(lp, '=')) == NULL) {
		cvs_log(LP_ERR, "error in Set request "
		    "(no = in variable assignment)");
		xfree(lp);
		return (-1);
	}
d503 2
a504 4
	if (cvs_req_nargs == CVS_PROTO_MAXARG) {
		cvs_log(LP_ERR, "too many arguments");
		return (-1);
	}
a507 4
		if (cvs_req_args[cvs_req_nargs] == NULL) {
			cvs_log(LP_ERRNO, "failed to copy argument");
			return (-1);
		}
d515 3
a517 5
			if (nap == NULL) {
				cvs_log(LP_ERRNO,
				    "failed to append to argument");
				return (-1);
			}
d530 2
a531 5
	if ((*line != '-') || (*(line + 2) != '\0')) {
		cvs_log(LP_ERR,
		    "invalid `Global_option' request format");
		return (-1);
	}
d576 4
a579 7
	if ((line[0] == '\0') || (*ep != '\0')) {
		cvs_log(LP_ERR, "invalid Gzip-stream level `%s'", line);
		return (-1);
	} else if ((errno == ERANGE) && ((val < 0) || (val > 9))) {
		cvs_log(LP_ERR, "Gzip-stream level %ld out of range", val);
		return (-1);
	}
@


1.34
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.33 2005/12/03 20:27:35 joris Exp $	*/
d431 1
a431 6
		if (cvs_buf_write(fdata, line, fmode) < 0) {
			cvs_log(LP_ERR, "failed to create file %s", line);
			cvs_buf_free(fdata);
			return (-1);
		}

@


1.33
log
@strip any trailing slashes in the received Directory
request, to make sure we are compatible with gnu;
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.32 2005/10/07 21:47:32 reyk Exp $	*/
d216 1
a216 1
	cvs_req_rootpath = strdup(line);
d283 1
a283 1
		free(cvs_req_currentdir);
d285 1
a285 1
	cvs_req_currentdir = strdup(rdir);
d312 1
a312 1
	if ((repo = strdup(s)) == NULL) {
d325 1
a325 1
			free(repo);
d340 1
a340 1
		if ((cvs_req_modulename = strdup(repo)) == NULL) {
d342 1
a342 1
			free(repo);
d356 1
a356 1
			free(repo);
d365 1
a365 1
		free(repo);
d378 1
a378 1
		free(repo);
d382 1
a382 1
	free(repo);
d516 1
a516 1
	if ((lp = strdup(line)) == NULL) {
d524 1
a524 1
		free(lp);
d530 1
a530 1
		free(lp);
d534 1
a534 1
	free(lp);
d551 1
a551 1
		cvs_req_args[cvs_req_nargs] = strdup(line);
d568 1
a568 1
			free(cvs_req_args[cvs_req_nargs - 1]);
@


1.32
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.31 2005/09/15 17:01:10 xsa Exp $	*/
d279 2
@


1.31
log
@check in cvs_mkadmin() wether we need to create or not the
CVS/Tag file. Sync the rest of the code accordingly; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.30 2005/07/29 10:38:55 joris Exp $	*/
d72 1
a72 1
	int (*hdlr)(int, char *);
d443 2
a444 1
			    "received Unchanged request for a non-existing file");
@


1.30
log
@don't try to skip over the rootpath in the received directory if the
rootpath is larger.

tested by xsa@@ a long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.29 2005/07/25 12:13:08 xsa Exp $	*/
d351 2
a352 1
		if (cvs_mkadmin(cvs_server_tmpdir, cvs_rootstr, repo) < 0) {
@


1.29
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.28 2005/07/23 10:59:47 xsa Exp $	*/
d301 8
a308 5
	s = cvs_req_currentdir + strlen(cvs_req_rootpath) + 1;
	if (s >= (cvs_req_currentdir + dirlen)) {
		cvs_log(LP_ERR, "you're bad, go away");
		return (-1);
	}
@


1.28
log
@use cvs_chdir();
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.27 2005/07/22 17:55:35 xsa Exp $	*/
d53 14
a66 14
static int  cvs_req_set          (int, char *);
static int  cvs_req_noop         (int, char *);
static int  cvs_req_root         (int, char *);
static int  cvs_req_validreq     (int, char *);
static int  cvs_req_validresp    (int, char *);
static int  cvs_req_expandmod    (int, char *);
static int  cvs_req_directory    (int, char *);
static int  cvs_req_useunchanged (int, char *);
static int  cvs_req_case         (int, char *);
static int  cvs_req_argument     (int, char *);
static int  cvs_req_globalopt    (int, char *);
static int  cvs_req_gzipstream   (int, char *);
static int  cvs_req_entry        (int, char *);
static int  cvs_req_filestate    (int, char *);
d68 1
a68 1
static int  cvs_req_command      (int, char *);
@


1.27
log
@be sure we accept request for _all_ of our commands on the server side;
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.26 2005/07/21 12:32:38 joris Exp $	*/
d295 1
a295 2
	if (chdir(cvs_server_tmpdir) == -1) {
		cvs_log(LP_ERRNO, "failed to change to top directory");
a296 1
	}
d662 1
a662 2
		if (chdir(cvs_server_tmpdir) == -1) {
			cvs_log(LP_ERRNO, "failed to change dir");
a663 1
		}
@


1.26
log
@show questionable files as '? foo' on the server side.

ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.25 2005/07/19 15:30:37 xsa Exp $	*/
d124 6
a129 4
	{ NULL                  },	/* 50 */
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
a132 2
	{ NULL                  },
	{ NULL                  },
d139 4
a142 4
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
@


1.25
log
@make the init command work;
tested aanriot@@ joris@@; Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.24 2005/07/18 08:13:03 xsa Exp $	*/
d448 1
@


1.24
log
@add cvs_noexec in cvs_req_globalopt() swtich case 'n';
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.23 2005/07/10 13:59:52 xsa Exp $	*/
d133 1
a133 1
	{ NULL                  },
@


1.23
log
@nuke verbosity declaration here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.22 2005/06/17 15:09:55 joris Exp $	*/
d585 1
@


1.22
log
@

correctly build a temporary copy of the client its repository
localy, so the server can execute the local commands on it
and pipe the output to the client.

with this diff in, our server is now working, please note
that we currently don't have support for all commands yet,
but you can expect this soon.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.21 2005/06/10 21:14:47 joris Exp $	*/
a45 1
extern int   verbosity;
@


1.21
log
@

unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.20 2005/05/31 08:58:48 xsa Exp $	*/
d33 1
d45 1
d124 1
a124 1
	{ NULL                  },
d152 4
d157 1
a159 3
static char *cvs_req_repopath;
static char cvs_req_tmppath[MAXPATHLEN];

d161 1
a161 3
static char *cvs_req_args[CVS_PROTO_MAXARG];
static int   cvs_req_nargs = 0;

d223 2
d271 2
a272 1
	int l;
d274 3
d290 1
a290 2
	/* now obtain the path relative to the Root directory */
	cvs_req_repopath = cvs_req_currentdir + strlen(cvs_req_rootpath) + 1;
d292 6
a297 6
	/* create tmp path */
	l = snprintf(cvs_req_tmppath, sizeof(cvs_req_tmppath), "%s/%s",
	    cvs_server_tmpdir, cvs_req_repopath);
	if (l == -1 || l >= (int)sizeof(cvs_req_tmppath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", cvs_req_tmppath);
d301 6
a306 3
	if ((mkdir(cvs_req_tmppath, 0755) == -1) && (errno != EEXIST)) {
		cvs_log(LP_ERRNO, "failed to create temporary directory '%s'",
		    cvs_req_tmppath);
d310 55
a364 2
	/* create the CVS/ administrative files */
	/* XXX - TODO */
d366 14
a386 1
	CVSFILE *cf;
d388 1
d392 9
a400 1
	cf = cvs_file_create(NULL, ent->ce_name, DT_REG, 0644);
d415 1
a415 1
	int l;
d418 1
a418 1
	char fpath[MAXPATHLEN];
d420 3
a422 1
	if (reqid == CVS_REQ_MODIFIED) {
a426 10
		/* create full temporary path */
		l = snprintf(fpath, sizeof(fpath), "%s/%s", cvs_req_tmppath,
		    line);
		if (l == -1 || l >= (int)sizeof(fpath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", fpath);
			cvs_buf_free(fdata);
			return (-1);
		}

d428 2
a429 2
		if (cvs_buf_write(fdata, fpath, fmode) < 0) {
			cvs_log(LP_ERR, "failed to create file %s", fpath);
d435 19
d456 5
a460 1
	return (0);
d654 15
d670 1
@


1.20
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.19 2005/05/31 08:26:40 xsa Exp $	*/
a158 2

static CVSFILE *cvs_lastdir = NULL;
@


1.19
log
@remove LP_ERROR log priority level and rather use LP_ERR as they are both
the same...

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.18 2005/05/30 08:13:15 joris Exp $	*/
d31 1
a33 1
#include <errno.h>
d35 1
a36 1
#include <string.h>
a40 1
#include "file.h"
@


1.18
log
@

zap an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.17 2005/05/27 22:33:56 joris Exp $	*/
d281 1
a281 1
		cvs_log(LP_ERROR, "failed to duplicate directory");
d355 1
a355 1
			cvs_log(LP_ERROR, "failed to create file %s", fpath);
@


1.17
log
@

missing handler for the diff command

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.16 2005/05/25 03:58:12 jfb Exp $	*/
a271 1
	CVSFILE *dirp;
@


1.16
log
@check the return value of cvs_startcmd() in cvs_req_command() so we
send the OK response if it went through, instead of grabbing a random
value from the stack
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.15 2005/05/24 04:12:25 jfb Exp $	*/
d119 1
a119 1
	{ NULL                  },
@


1.15
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.14 2005/05/18 20:24:19 joris Exp $	*/
d549 1
a549 1
	int ret;
d558 1
a558 2
	cvs_startcmd(cmdp, cvs_req_nargs, cvs_req_args);

@


1.14
log
@

build a local copy of the client's source tree when acting as a server.
more server stuff coming soon!

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.13 2005/04/18 21:33:34 jfb Exp $	*/
d161 2
d272 1
d314 1
d319 2
d550 1
d552 2
a553 15
	switch (reqid) {
	case CVS_REQ_VERSION:
		ret = cvs_sendresp(CVS_RESP_M, CVS_VERSION);
		break;
	case CVS_REQ_ADD:
	case CVS_REQ_ANNOTATE:
	case CVS_REQ_CO:
	case CVS_REQ_CI:
	case CVS_REQ_DIFF:
	case CVS_REQ_LOG:
	case CVS_REQ_REMOVE:
	case CVS_REQ_STATUS:
	case CVS_REQ_TAG:
	default:
		cvs_sendresp(CVS_RESP_E, "command not yet implemented");
d555 1
a555 1
		return (0);
d557 2
@


1.13
log
@dummy handlers for the Entry, Modified, Is-Modified, Updated and
Questionable requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.12 2005/02/22 16:33:44 jfb Exp $	*/
d153 3
d157 1
d268 1
d274 30
d328 1
d331 1
d337 19
@


1.12
log
@give the `noop' request its own handler, it definitely does not need
to be in the generic command handler, and add a dummy handler for the
`expand-modules' request
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.11 2005/01/13 06:09:14 jfb Exp $	*/
d65 2
d82 1
a82 1
	{ NULL                  },
d85 3
a87 3
	{ NULL                  },
	{ NULL                  },
	{ NULL                  },
d91 1
a91 1
	{ NULL                  },
d208 1
d272 32
@


1.11
log
@* get rid of useless headers
* fix the handlers for Root, valid-requests, Directory and Set
* add a generic request handler for most of the requests expecting
  a response
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.8 2004/12/19 17:32:55 jfb Exp $	*/
d54 1
d58 1
d107 1
a107 1
	{ NULL                  },
d136 1
a136 1
	{ cvs_req_command       },
d186 14
a203 1

d269 17
a454 2
	case CVS_REQ_NOOP:	/* do nothing */
		break;
d460 1
@


1.10
log
@when warning about unimplemented handlers, do not attempt to print
the errno message string
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.9 2004/12/28 20:46:13 jfb Exp $	*/
a35 1
#include <signal.h>
a36 4
#include <sysexits.h>
#ifdef CVS_ZLIB
#include <zlib.h>
#endif
d53 12
a64 10
static int  cvs_req_set        (int, char *);
static int  cvs_req_root       (int, char *);
static int  cvs_req_validreq   (int, char *);
static int  cvs_req_validresp  (int, char *);
static int  cvs_req_directory  (int, char *);
static int  cvs_req_case       (int, char *);
static int  cvs_req_argument   (int, char *);
static int  cvs_req_globalopt  (int, char *);
static int  cvs_req_gzipstream (int, char *);
static int  cvs_req_version    (int, char *);
d70 70
a139 70
	{ NULL               },
	{ cvs_req_root       },
	{ cvs_req_validreq   },
	{ cvs_req_validresp  },
	{ cvs_req_directory  },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },	/* 10 */
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ cvs_req_case       },
	{ NULL               },
	{ cvs_req_argument   },	/* 20 */
	{ cvs_req_argument   },
	{ cvs_req_globalopt  },
	{ cvs_req_gzipstream },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },	/* 30 */
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ cvs_req_set        },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },	/* 40 */
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },	/* 50 */
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },	/* 60 */
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ NULL               },
	{ cvs_req_version    },
d148 2
d189 4
a192 2
	return (0);
}
d194 3
a196 10

static int
cvs_req_set(int reqid, char *line)
{
	char *cp;

	cp = strchr(line, '=');
	if (cp == NULL) {
		cvs_log(LP_ERR, "error in Set request "
		    "(no = in variable assignment)");
a199 2
	if (cvs_var_set(line, cp) < 0)
		return (-1);
d213 3
a215 1
	cvs_sendresp(CVS_RESP_VALIDREQ, vreq);
d246 1
d248 16
d267 1
d282 29
a390 1

d412 5
d418 1
a418 1
cvs_req_version(int reqid, char *line)
d420 26
a445 2
	cvs_printf("%s\n", CVS_VERSION);
	return (0);
@


1.9
log
@handler for the Set request
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.8 2004/12/19 17:32:55 jfb Exp $	*/
d178 1
a178 1
		cvs_log(LP_ERRNO, "handler for `%s' not implemented", cmd);
@


1.8
log
@add a handler for the Gzip-stream request.  The handler parses the
requested compression level but does not enable compression yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.7 2004/12/07 17:10:56 tedu Exp $	*/
d58 1
d107 1
a107 1
	{ NULL               },
d190 18
@


1.7
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.6 2004/12/06 21:03:12 deraadt Exp $	*/
d65 1
d95 1
a95 1
	{ NULL               },
d319 29
@


1.6
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: req.c,v 1.5 2004/08/06 14:49:03 jfb Exp $	*/
a152 3



a159 1

a183 1

a232 2


a240 1

@


1.5
log
@Handle the '-b' and '-x' global options even if we don't support them,
and add support for case insensitivity
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d274 1
a274 2
	}
	else if (reqid == CVS_REQ_ARGUMENTX) {
@


1.4
log
@Handlers for the `valid-requests' and `Valid-responses' requests
@
text
@d62 1
d89 1
a89 1
	{ NULL               },
d240 13
@


1.3
log
@Handler for the `Global_opt' request
@
text
@d59 2
d72 2
a73 2
	{ NULL               },
	{ NULL               },
d192 23
d216 13
@


1.2
log
@Handler for the `Argument' and `Argumentx' requests
@
text
@d61 1
d90 1
a90 1
	{ NULL               },
d237 37
@


1.1
log
@Move all of the request- and response-specific handlers into separate
files and have only the generic function of each type available to
the outside
@
text
@d60 1
d87 2
a88 2
	{ NULL               },	/* 20 */
	{ NULL               },
d142 11
d199 38
@

