head	1.9;
access;
symbols
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.04.06.22.08.53;	author joris;	state dead;
branches;
next	1.8;

1.8
date	2005.02.22.22.33.01;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.09.20.51.33;	author krapht;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.27.13.42.39;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.25.12.21.43;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.24.14.28.07;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.25.03.29.35;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.9
log
@

remove dead and unused code

ok jfb@@
@
text
@/*	$OpenBSD: cvsd.h,v 1.8 2005/02/22 22:33:01 jfb Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef CVSD_H
#define CVSD_H

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <pwd.h>
#include <grp.h>
#include <signal.h>

#include "cvs.h"

#define CVSD_USER   "_cvsd"
#define CVSD_GROUP  "_cvsd"

#define CVSD_PATH_CONF    "/etc/cvsd.conf"
#define CVSD_PATH_CHILD   "/usr/sbin/cvsd-child"

#define CVSD_CHILD_DEFMAX    5
#define CVSD_CHILD_SOCKFD    3


#define CVSD_FPERM  (S_IRUSR | S_IWUSR)
#define CVSD_DPERM  (S_IRWXU)


/* requests */
#define CVSD_MSG_GETUID    1
#define CVSD_MSG_GETUNAME  2
#define CVSD_MSG_GETGID    3
#define CVSD_MSG_GETGNAME  4
#define CVSD_MSG_PASSFD    5   /* server passes client file descriptor */
#define CVSD_MSG_SETIDLE   6   /* client has no further processing to do */

/* replies */
#define CVSD_MSG_UID       128
#define CVSD_MSG_UNAME     129
#define CVSD_MSG_GID       130
#define CVSD_MSG_GNAME     131

#define CVSD_MSG_SHUTDOWN  253
#define CVSD_MSG_OK        254
#define CVSD_MSG_ERROR     255

#define CVSD_MSG_MAXLEN    256


#define CVSD_SET_ROOT     1
#define CVSD_SET_CHMIN    2
#define CVSD_SET_CHMAX    3
#define CVSD_SET_ADDR     4
#define CVSD_SET_SOCK     5
#define CVSD_SET_USER     6
#define CVSD_SET_GROUP    7
#define CVSD_SET_MODDIR   8


#define CVSD_ST_UNKNOWN      0
#define CVSD_ST_IDLE         1
#define CVSD_ST_BUSY         2
#define CVSD_ST_DEAD         3
#define CVSD_ST_STOPPED      4


/* message structure to pass data between the parent and the chrooted child */
struct cvsd_msg {
	u_int8_t  cm_type;
	u_int8_t  cm_len;    /* length of message data in bytes */
};


struct cvsd_addr {
	sa_family_t ca_fam;
	union {
		struct sockaddr_in  sin;
		struct sockaddr_in6 sin6;
	} ca_addr;
};


struct cvsd_child {
	pid_t  ch_pid;
	int    ch_sock;
	u_int  ch_state;

	TAILQ_ENTRY(cvsd_child) ch_list;
};


/*
 * The following structures are used to vehicle information to and from the
 * cvsd-child process handling the cvs session.
 */

struct cvsd_req {
	int  cr_op;		/* operation (see CVS_OP_* in cvs.h) */
	int  cr_nfiles;
};

struct cvsd_resp {
	int cr_code;
};


/* cvsd-child response codes */
#define CVSD_RESP_OK      0
#define CVSD_RESP_INVREQ  1	/* invalid request */
#define CVSD_RESP_DENIED  2	/* access denied */
#define CVSD_RESP_SYSERR  3	/* system error */
#define CVSD_RESP_RDONLY  4	/* repository is read-only */
#define CVSD_RESP_INVFILE 5	/* one or more files are unknown */
#define CVSD_RESP_INVMOD  6


extern uid_t    cvsd_uid;
extern gid_t    cvsd_gid;


int                 cvsd_set        (int, ...);
struct cvsd_child*  cvsd_child_fork (int);
int                 cvsd_child_reap (void);


/* from conf.y */
int    cvs_conf_read (const char *);
u_int  cvs_acl_eval  (struct cvs_op *);

/* from msg.c */
int    cvsd_sendmsg (int, u_int, const void *, size_t);
int    cvsd_recvmsg (int, u_int *, void *, size_t *);
int    cvsd_sendfd  (int, int);
int    cvsd_recvfd  (int);


struct cvsd_sess*  cvsd_sess_alloc  (int);
void               cvsd_sess_free   (struct cvsd_sess *);


#endif /* CVSD_H */
@


1.8
log
@Split the cvs daemon into two different processes: cvsd and cvsd-child.
The cvsd process only takes care of managing children and repository
locks, while the child handles all requests made to access or modify
the contents of the repository.
This will allow us to take advantage of randomized library remapping
and new propolice cookies, and minimizes the amount of code that can
run with elevated privileges.  Still work in progress.

suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.h,v 1.7 2004/12/07 17:10:56 tedu Exp $	*/
@


1.7
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: cvsd.h,v 1.6 2004/11/09 20:51:33 krapht Exp $	*/
a44 1
#define CVSD_CONF   "/etc/cvsd.conf"
d46 3
a48 1
#define CVSD_CHILD_DEFMIN    3
d50 1
a109 10
#define CVSD_SESS_LOCAL   0
#define CVSD_SESS_REMOTE  1

struct cvsd_sess {
	int              cs_fd;
	int              cs_type;
	uid_t            cs_uid;     /* user ID of the session */
	struct cvsd_addr cs_raddr;   /* remote address */
};

d116 2
a117 1
	struct cvsd_sess *ch_sess;
d119 13
a131 1
	TAILQ_ENTRY(cvsd_child) ch_list;
d135 10
d149 3
a151 5
int                cvsd_set        (int, ...);
int                cvsd_checkperms (const char *);
int                cvsd_child_fork (struct cvsd_child **);
struct cvsd_child* cvsd_child_get  (void);
int                cvsd_child_reap (void);
@


1.6
log
@session prototypes and some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a50 1

a92 1

a129 1

a131 1

@


1.5
log
@Rename some variables to match the general format, and avoid exporting
variables that aren't needed
@
text
@d77 8
a84 7
#define CVSD_SET_ROOT        1
#define CVSD_SET_CHMIN       2
#define CVSD_SET_CHMAX       3
#define CVSD_SET_ADDR        4
#define CVSD_SET_SOCK        5
#define CVSD_SET_USER        6
#define CVSD_SET_GROUP       7
d102 19
d126 2
a131 9
struct cvsd_addr {
	sa_family_t ca_fam;
	union {
		struct sockaddr_in *sin;
		struct sockaddr_in6 *sin6;
	} ca_addr;
};


a143 4
/* from fdpass.c */
int   cvsd_sendfd  (int, int);
int   cvsd_recvfd  (int);

d152 7
@


1.4
log
@Most of the code to handle SIGCHLD and spawn new children whenever
one dies.  Also fix cvsd_set() by making a copy of the string passed
as argument.
@
text
@d82 2
a118 3

extern volatile sig_atomic_t running;
extern volatile sig_atomic_t restart;
@


1.3
log
@When creating the local socket, set the group to the server's group ID
@
text
@d87 2
d130 1
a130 1
int                cvsd_child_reap (struct cvsd_child *);
@


1.2
log
@* rework on the child API, still needs more functionality
* move the ACL parsing code into the more general conf.y, which handles
  parsing of the whole configuration file
@
text
@d38 1
d119 2
@


1.1
log
@Initial revision
@
text
@d33 3
d44 1
d58 4
a61 2
#define CVSD_MSG_PASSFD    3   /* server passes client file descriptor */
#define CVSD_MSG_SETIDLE   4   /* client has no further processing to do */
d66 2
d76 13
d99 1
d105 8
a113 1
extern int foreground;
d121 9
d132 3
a134 7
int  cvsd_checkperms (const char *);
int  cvsd_forkchild  (void);


/* from aclparse.y */
int    cvs_acl_parse  (const char *);
u_int  cvs_acl_eval   (struct cvs_op *);
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
