head	1.83;
access;
symbols
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.83.0.4
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.82.0.6
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.81.0.14
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.81.0.12
	OPENBSD_5_5_BASE:1.81
	OPENBSD_5_4:1.81.0.8
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.81.0.6
	OPENBSD_5_3_BASE:1.81
	OPENBSD_5_2:1.81.0.4
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.2
	OPENBSD_5_0:1.80.0.12
	OPENBSD_5_0_BASE:1.80
	OPENBSD_4_9:1.80.0.10
	OPENBSD_4_9_BASE:1.80
	OPENBSD_4_8:1.80.0.8
	OPENBSD_4_8_BASE:1.80
	OPENBSD_4_7:1.80.0.4
	OPENBSD_4_7_BASE:1.80
	OPENBSD_4_6:1.80.0.6
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.80.0.2
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.79.0.2
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.72.0.2
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.65.0.2
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.64.0.2
	OPENBSD_4_1_BASE:1.64
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.83
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.82;
commitid	O6jeJ0TRmiewrqMI;

1.82
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	Uu5nFG3wCl0LACBb;

1.81
date	2011.12.27.13.59.01;	author nicm;	state Exp;
branches;
next	1.80;

1.80
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.23.20.51.08;	author ragge;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.14.02.43.47;	author tobias;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.08.18.08.59;	author joris;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.08.18.08.34;	author joris;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.08.02.54.08;	author tobias;	state Exp;
branches;
next	1.73;

1.73
date	2008.03.08.20.26.34;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.09.20.04.00;	author xsa;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.06.12.42.46;	author tobias;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.04.15.07.33;	author tobias;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.10.10.08.22;	author tobias;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.64;

1.64
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.63;

1.63
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2007.01.31.21.07.36;	author xsa;	state Exp;
branches;
next	1.61;

1.61
date	2007.01.27.20.23.26;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2007.01.03.22.56.54;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2007.01.03.22.28.30;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.14.09.31.17;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.06.11.12.56;	author xsa;	state Exp;
branches;
next	1.55;

1.55
date	2006.10.31.15.23.40;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.31.07.12.32;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.30.22.05.53;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.30.21.32.52;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.30.21.00.42;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.29.08.19.09;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.29.05.52.42;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.29.05.34.31;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.27.03.30.31;	author joris;	state dead;
branches;
next	1.44;

1.44
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.16.09.06.19;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.27.12.45.21;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.25.08.15.05;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.03.01.02.09;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.06.17.08.05;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.22.11.17.26;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.12.06.36.14;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.10.15.34.46;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.29.23.56.56;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.29.22.59.10;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.27.17.14.08;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.27.16.42.19;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.26.14.58.58;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.25.20.15.35;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.24.17.48.05;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.24.17.20.14;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.24.16.46.40;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.23.22.43.39;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.21.16.59.24;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.20.06.59.27;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.11.07.51.01;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.08.16.03.38;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.20.19.58.03;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.12.14.04.13;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.21.20.56.12;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.21.19.06.06;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.21.18.54.50;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.19.15.36.39;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.09.15.24.36;	author xsa;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.31.16.49.28;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.21.18.15.55;	author xsa;	state Exp;
branches;
next	;


desc
@@


1.83
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@/*	$OpenBSD: remove.c,v 1.82 2015/01/16 06:40:07 deraadt Exp $	*/
/*
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

extern char *__progname;

void		cvs_remove_force(struct cvs_file *);

static int	removed = 0;
static int	existing = 0;

struct cvs_cmd cvs_cmd_remove = {
	CVS_OP_REMOVE, CVS_USE_WDIR, "remove",
	{ "rm", "delete" },
	"Remove an entry from the repository",
	"[-flR] [file ...]",
	"flR",
	NULL,
	cvs_remove
};

int
cvs_remove(int argc, char **argv)
{
	int ch;
	int flags;
	char *arg = ".";
	struct cvs_recursion cr;
	int force_remove = 0;

	flags = CR_RECURSE_DIRS;
	while ((ch = getopt(argc, argv, cvs_cmd_remove.cmd_opts)) != -1) {
		switch (ch) {
		case 'f':
			force_remove = 1;
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		default:
			fatal("%s", cvs_cmd_remove.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	cr.enterdir = NULL;
	cr.leavedir = NULL;
	cr.flags = flags;

	if (force_remove == 1 && cvs_noexec == 0) {
		cr.fileproc = cvs_remove_force;
		if (argc > 0)
			cvs_file_run(argc, argv, &cr);
		else
			cvs_file_run(1, &arg, &cr);
	}

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");
	} else {
		cr.fileproc = cvs_remove_local;
	}

	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("remove");
		cvs_client_get_responses();
	} else {
		if (existing != 0) {
			cvs_log(LP_ERR, (existing == 1) ?
			    "%d file exists; remove it first" :
			    "%d files exist; remove them first", existing);
		}

		if (removed != 0) {
			if (verbosity > 0) {
				cvs_log(LP_NOTICE,
				    "use '%s commit' to remove %s "
				    "permanently", __progname, (removed > 1) ?
				    "these files" : "this file");
			}
		}
	}

	return (0);
}

void
cvs_remove_force(struct cvs_file *cf)
{
	if (cf->file_type != CVS_DIR) {
		if (cf->file_flags & FILE_ON_DISK) {
			if (unlink(cf->file_path) == -1)
				fatal("cvs_remove_force: %s", strerror(errno));
			(void)close(cf->fd);
			cf->fd = -1;
		}
	}
}

void
cvs_remove_local(struct cvs_file *cf)
{
	CVSENTRIES *entlist;
	char *entry, buf[PATH_MAX], tbuf[CVS_TIME_BUFSZ], rbuf[CVS_REV_BUFSZ];
	char sticky[CVS_ENT_MAXLINELEN];

	cvs_log(LP_TRACE, "cvs_remove_local(%s)", cf->file_path);

	if (cf->file_type == CVS_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Removing %s", cf->file_path);
		return;
	}

	if (cvs_cmdop != CVS_OP_CHECKOUT && cvs_cmdop != CVS_OP_UPDATE)
		cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_status == FILE_UNKNOWN) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "nothing known about '%s'",
			    cf->file_path);
		return;
	}

	if (cf->file_flags & FILE_ON_DISK) {
		if (verbosity > 1)
			cvs_log(LP_ERR, "file `%s' still in working directory",
			    cf->file_name);
		existing++;
	} else {
		switch (cf->file_status) {
		case FILE_REMOVE_ENTRY:
			entlist = cvs_ent_open(cf->file_wd);
			cvs_ent_remove(entlist, cf->file_name);

			(void)xsnprintf(buf, sizeof(buf), "%s/%s/%s%s",
			    cf->file_wd, CVS_PATH_CVSDIR, cf->file_name,
			    CVS_DESCR_FILE_EXT);

			(void)unlink(buf);

			if (verbosity > 1) {
				cvs_log(LP_NOTICE, "removed `%s'",
				    cf->file_name);
			}
			return;
		case FILE_REMOVED:
			if (verbosity > 0) {
				cvs_log(LP_ERR,
				    "file `%s' already scheduled for removal",
				    cf->file_name);
			}
			return;
		case FILE_LOST:
			rcsnum_tostr(cf->file_ent->ce_rev, rbuf, sizeof(rbuf));

			ctime_r(&cf->file_ent->ce_mtime, tbuf);
			tbuf[strcspn(tbuf, "\n")] = '\0';

			sticky[0] = '\0';
			if (cf->file_ent->ce_tag != NULL)
				(void)xsnprintf(sticky, sizeof(sticky), "T%s",
				    cf->file_ent->ce_tag);

			entry = xmalloc(CVS_ENT_MAXLINELEN);
			cvs_ent_line_str(cf->file_name, rbuf, tbuf,
			    cf->file_ent->ce_opts ? 
			    cf->file_ent->ce_opts : "", sticky, 0, 1,
			    entry, CVS_ENT_MAXLINELEN);

			if (cvs_server_active == 1) {
				cvs_server_update_entry("Checked-in", cf);
				cvs_remote_output(entry);
			} else {
				entlist = cvs_ent_open(cf->file_wd);
				cvs_ent_add(entlist, entry);
			}

			free(entry);

			if (verbosity > 0) {
				cvs_log(LP_NOTICE,
				    "scheduling file `%s' for removal",
				    cf->file_name);
			}

			cf->file_status = FILE_REMOVED;
			removed++;
			break;
		}
	}
}
@


1.82
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.81 2011/12/27 13:59:01 nicm Exp $	*/
d19 1
d216 1
a216 1
			xfree(entry);
@


1.81
log
@Move some global variables/statics to locals, from Michael W
Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.80 2009/02/21 14:50:53 joris Exp $	*/
d140 1
a140 1
	char *entry, buf[MAXPATHLEN], tbuf[CVS_TIME_BUFSZ], rbuf[CVS_REV_BUFSZ];
@


1.80
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.79 2008/06/23 20:51:08 ragge Exp $	*/
a28 1
static int	force_remove = 0;
d49 1
@


1.79
log
@Some conformance fixes:
- Empty brackets forbidden in C99.
- ? : and skipping middle argument is both disallowed and considered bad
  programming habit.
OK ray@@, xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.78 2008/06/14 03:19:15 joris Exp $	*/
d127 1
a127 1
		if (cf->fd != -1) {
d161 1
a161 1
	if (cf->fd != -1) {
@


1.78
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.77 2008/06/14 02:43:47 tobias Exp $	*/
d203 2
a204 1
			    cf->file_ent->ce_opts ? : "", sticky, 0, 1,
@


1.77
log
@Run cvs_remove_force only if -f has been specified.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.76 2008/06/08 18:08:59 joris Exp $	*/
a170 1
			cvs_ent_close(entlist, ENT_SYNC);
a211 1
				cvs_ent_close(entlist, ENT_SYNC);
@


1.76
log
@kill debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.75 2008/06/08 18:08:34 joris Exp $	*/
d75 7
a81 5
	cr.fileproc = cvs_remove_force;
	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);
d127 1
a127 1
		if (cf->fd != -1 && force_remove == 1 && cvs_noexec == 0) {
@


1.75
log
@properly handle FILE_UPTODATE and FILE_LOST
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.74 2008/06/08 02:54:08 tobias Exp $	*/
a189 1
			printf("%d\n", cf->file_status);
@


1.74
log
@Properly build up path to description files (descr entry in RCS files if
you add a file with -m message).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.73 2008/03/08 20:26:34 joris Exp $	*/
d189 2
a190 1
		default:
@


1.73
log
@add checkout/update -j support.
still has some rough edges.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.72 2008/02/09 20:04:00 xsa Exp $	*/
d172 1
a172 1
			    cf->file_path, CVS_PATH_CVSDIR, cf->file_name,
@


1.72
log
@Introduce cvs_ent_line_str() - formats CVS/Entries lines.
OK tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.71 2008/02/06 12:42:46 tobias Exp $	*/
a26 1
void		cvs_remove_local(struct cvs_file *);
d149 2
a150 1
	cvs_file_classify(cf, cvs_directory_tag);
@


1.71
log
@Sticky tags must have a 'T' in front of them in CVS/Entries.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.70 2008/02/04 15:07:33 tobias Exp $	*/
d201 3
a203 3
			(void)xsnprintf(entry, CVS_ENT_MAXLINELEN,
			    "/%s/-%s/%s/%s/%s", cf->file_name, rbuf, tbuf,
			    cf->file_ent->ce_opts ? : "", sticky);
@


1.70
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.69 2008/01/31 10:15:05 tobias Exp $	*/
d140 1
d195 5
d203 1
a203 2
			    cf->file_ent->ce_opts ? : "",
			    cf->file_ent->ce_tag ? : "");
@


1.69
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.68 2008/01/28 20:31:07 tobias Exp $	*/
d189 1
a189 2
			rcsnum_tostr(cf->file_ent->ce_rev, rbuf,
			     sizeof(rbuf));
d196 3
a198 1
			     "/%s/-%s/%s//", cf->file_name, rbuf, tbuf);
@


1.68
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.67 2008/01/10 10:08:22 tobias Exp $	*/
d35 1
a35 1
	CVS_OP_REMOVE, 0, "remove",
@


1.67
log
@another strcspn() round
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.66 2007/09/22 16:01:22 joris Exp $	*/
d62 1
@


1.66
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.65 2007/06/28 21:38:09 xsa Exp $	*/
d192 1
a192 2
			if (tbuf[strlen(tbuf) - 1] == '\n')
				tbuf[strlen(tbuf) - 1] = '\0';
@


1.65
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.64 2007/02/22 06:42:09 otto Exp $	*/
d148 1
a148 1
	cvs_file_classify(cf, NULL);
@


1.64
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.63 2007/02/09 03:49:15 joris Exp $	*/
d138 1
a138 1
	char *entry, buf[MAXPATHLEN], tbuf[32], rbuf[16];
@


1.63
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.62 2007/01/31 21:07:36 xsa Exp $	*/
d18 3
a20 1
#include "includes.h"
a22 1
#include "log.h"
@


1.62
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.61 2007/01/27 20:23:26 joris Exp $	*/
d147 1
a147 1
	cvs_file_classify(cf, NULL, 0);
@


1.61
log
@when we specify the 'f' flag do not bother removing files that
dont exist on disk anyway, and when removing a file that has been
added but not commited the correct file_status is FILE_REMOVE_ENTRY
and not FILE_ADDED.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.60 2007/01/11 02:35:55 joris Exp $	*/
a135 1
	int l;
d168 1
a168 1
			l = snprintf(buf, sizeof(buf), "%s/%s/%s%s",
a170 2
			if (l == -1 || l >= (int)sizeof(buf))
				fatal("cvs_remove_local: overflow");
d195 1
a195 1
			l = snprintf(entry, CVS_ENT_MAXLINELEN,
a196 2
			if (l == -1 || l >= CVS_ENT_MAXLINELEN)
				fatal("cvs_remove_local: overflow");
@


1.60
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.59 2007/01/03 22:56:54 joris Exp $	*/
d124 1
a124 1
		if (force_remove == 1 && cvs_noexec == 0) {
d164 1
a164 1
		case FILE_ADDED:
@


1.59
log
@make sure remove -f also works in remote setup
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.58 2007/01/03 22:28:30 joris Exp $	*/
d81 1
@


1.58
log
@add support for 'remove' in a remote setup.
testing appriciated, as always.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.57 2006/12/14 09:31:17 xsa Exp $	*/
d27 1
d72 7
a88 2
	cr.flags = flags;

d120 13
a153 7
	}

	if (force_remove == 1 && cvs_noexec == 0) {
		if (unlink(cf->file_path) == -1)
			fatal("cvs_remove_local: %s", strerror(errno));
		(void)close(cf->fd);
		cf->fd = -1;
@


1.57
log
@no need to send -f to the server; this flag has effect
on the client-side only.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.56 2006/11/06 11:12:56 xsa Exp $	*/
d101 1
a101 1
			if (verbosity > 1) {
d150 1
a150 1
		switch(cf->file_status) {
d170 1
a170 1
			if (verbosity > 1 ) {
d190 8
a197 3
			entlist = cvs_ent_open(cf->file_wd);
			cvs_ent_add(entlist, entry);
			cvs_ent_close(entlist, ENT_SYNC);
d201 1
a201 1
			if (verbosity > 1) {
@


1.56
log
@- handle global -n flag in conjunction with remove -f.
- better error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.55 2006/10/31 15:23:40 xsa Exp $	*/
a73 3

		if (force_remove == 1)
			cvs_client_send_request("Argument -f");
@


1.55
log
@a step ahead in opencvs add|remove remote support.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.54 2006/06/19 05:05:17 joris Exp $	*/
d98 3
a100 2
			cvs_log(LP_ERR, "%d file(s) exist, remove them first",
			    existing);
d140 1
a140 1
	if (force_remove == 1) {
@


1.54
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.53 2006/06/16 14:07:42 joris Exp $	*/
d22 1
a25 1
int		cvs_remove(int, char **);
d71 13
a83 1
	cr.fileproc = cvs_remove_local;
d91 10
a100 4
	if (existing != 0) {
		cvs_log(LP_ERR, "%d file(s) exist, remove them first",
		    existing);
	}
d102 8
a109 5
	if (removed != 0) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "use '%s commit' to remove %s "
			    "permanently", __progname, (removed > 1) ?
			    "these files" : "this file");
@


1.53
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.52 2006/05/31 07:12:32 joris Exp $	*/
d71 1
a71 2
	cr.local = cvs_remove_local;
	cr.remote = NULL;
@


1.52
log
@dont check for FILE_UNKNOWN twice,
noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.51 2006/05/30 22:05:53 joris Exp $	*/
a21 1
#include "proto.h"
d33 1
a33 1
	CVS_OP_REMOVE, CVS_REQ_REMOVE, "remove",
@


1.51
log
@correctly handle unknown file in remove
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.50 2006/05/30 21:32:52 joris Exp $	*/
a133 6
		case FILE_UNKNOWN:
			if (verbosity > 1) {
				cvs_log(LP_ERR, "nothing known about `%s'",
				    cf->file_name);
			}
			return;
@


1.50
log
@fill in the correct revision number we will want in file_rcsrev
for each cvs_file struct, this will help us with sticky tags,
commiting to branches and importing into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.49 2006/05/30 21:00:42 joris Exp $	*/
d112 7
@


1.49
log
@prettier output when removing files;
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.48 2006/05/29 08:19:09 xsa Exp $	*/
d111 1
a111 1
	cvs_file_classify(cf, 0);
@


1.48
log
@fix pasto
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.47 2006/05/29 05:52:42 joris Exp $	*/
d81 12
a186 13
		}
	}

	if (cf->file_status == FILE_REMOVED) {
		if (verbosity > 0)
			cvs_log(LP_NOTICE, "use '%s commit' to remove %s "
			    "permanently", __progname,
			    (removed == 1) ? "this file" : "these files");
	} else {
		if (cf->fd != -1) {
			cvs_log(LP_ERR, existing == 1 ?
			    "%d file exists; remove it first" :
			    "%d files exist; remove them first", existing);
@


1.47
log
@remove likes some CR_RECURSE_DIRS luvin' too.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.46 2006/05/29 05:34:31 joris Exp $	*/
d52 1
a52 1
	while ((ch = getopt(argc, argv, cvs_cmd_commit.cmd_opts)) != -1) {
d63 1
a63 1
			fatal("%s", cvs_cmd_commit.cmd_synopsis);
@


1.46
log
@add remove support, hacked by xsa@@ but lots of modifications
from me to actually make it work properly.

commiting since xsa@@ is not around and i want to move forward.
ray@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
d51 1
d58 1
d74 1
@


1.45
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.44 2006/04/14 02:45:35 deraadt Exp $	*/
d3 1
a3 3
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * Copyright (c) 2004, 2005 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a23 1

d26 2
d29 3
a31 7
static int	cvs_remove_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_remove_remote(CVSFILE *, void *);
static int	cvs_remove_local(CVSFILE *, void *);
static int	cvs_remove_file(const char *);

static int	force_remove = 0;	/* -f option */
static int	nuked = 0;
d40 1
a40 8
	CF_IGNORE | CF_RECURSE,
	cvs_remove_init,
	NULL,
	cvs_remove_remote,
	cvs_remove_local,
	NULL,
	NULL,
	CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2 | CVS_CMD_ALLOWSPEC
d43 2
a44 2
static int
cvs_remove_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d47 2
d50 1
a50 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a55 1
			cmd->file_flags &= ~CF_RECURSE;
a57 1
			cmd->file_flags |= CF_RECURSE;
d60 1
a60 1
			return (CVS_EX_USAGE);
d67 9
a75 35
	*arg = optind;
	return (0);
}


static int
cvs_remove_remote(CVSFILE *cf, void *arg)
{
	char fpath[MAXPATHLEN];
	struct cvsroot *root;

	root = CVS_DIR_ROOT(cf);

	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		else
			cvs_senddir(root, cf);
		return (0);
	}

	cvs_file_getpath(cf, fpath, sizeof(fpath));

	if (cvs_remove_file(fpath) < 0)
		fatal("cvs_remove_remote: cvs_remove_file `%s' failed", fpath);

	cvs_sendentry(root, cf);

	if (cf->cf_cvstat != CVS_FST_LOST && force_remove != 1) {
		if (cf->cf_cvstat != CVS_FST_ADDED)
			cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name);

		if (cf->cf_flags & CVS_FILE_ONDISK)
			cvs_sendfile(root, fpath);
	}
d80 2
a81 2
static int
cvs_remove_local(CVSFILE *cf, void *arg)
d83 3
a85 4
	int existing, removed;
	char buf[MAXPATHLEN], fpath[MAXPATHLEN];
	CVSENTRIES *entf;
	struct cvs_ent *ent;
d87 1
a87 2
	existing = removed = 0;
	entf = (CVSENTRIES *)cf->cf_entry;
d89 1
a89 1
	if (cf->cf_type == DT_DIR) {
d91 2
a92 2
			cvs_log(LP_NOTICE, "Removing %s", cf->cf_name);
		return (0);
d95 1
a95 2
	if (cvs_cmdop != CVS_OP_SERVER) {
		cvs_file_getpath(cf, fpath, sizeof(fpath));
d97 5
a101 3
		if (cvs_remove_file(fpath) < 0)
			fatal("cvs_remove_local: cvs_remove_file `%s' failed",
			     fpath);
d104 4
a107 1
	if (nuked == 0) {
a108 31
		if (verbosity > 1)
			cvs_log(LP_WARN, "file `%s' still in working directory",
			    cf->cf_name);
	} else if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		if (verbosity > 1)
			cvs_log(LP_WARN, "nothing known about `%s'",
			    cf->cf_name);
		return (0);
	} else if (cf->cf_cvstat == CVS_FST_ADDED) {
		if (cvs_ent_remove(entf, cf->cf_name, 0) == -1)
			fatal("cvs_remove_local: cvs_ent_remove failed");

		if (strlcpy(buf, CVS_PATH_CVSDIR, sizeof(buf)) >= sizeof(buf) ||
		    strlcat(buf, "/", sizeof(buf)) >= sizeof(buf) ||
		    strlcat(buf, cf->cf_name, sizeof(buf)) >= sizeof(buf) ||
		    strlcat(buf, CVS_DESCR_FILE_EXT,
		    sizeof(buf)) >= sizeof(buf))
			fatal("cvs_remove_local: path truncation");

		if (cvs_unlink(buf) == -1)
			fatal("cvs_remove_local: cvs_unlink `%s' failed", buf);

		if (verbosity > 1)
			cvs_log(LP_NOTICE, "removed `%s'", cf->cf_name);
		return (0);
	} else if (cf->cf_cvstat == CVS_FST_REMOVED) {
		if (verbosity > 1 )
			cvs_log(LP_WARN,
			    "file `%s' already scheduled for removal",
			    cf->cf_name);
		return (0);
d110 35
a144 2
		if ((ent = cvs_ent_get(entf, cf->cf_name)) == NULL)
			fatal("cvs_remove_local: cvs_ent_get failed");
d146 21
a166 3
		/* Prefix revision with `-' */
		ent->ce_status = CVS_ENT_REMOVED;
		entf->cef_flags &= ~CVS_ENTF_SYNC;
d168 4
a171 4
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "scheduling file `%s' for removal",
			    cf->cf_name);
		removed++;
d174 1
a174 1
	if (removed != 0) {
a178 30
		return (0);
	}

	if (existing != 0) {
		cvs_log(LP_WARN, existing == 1 ?
		    "%d file exists; remove it first" :
		    "%d files exist; remove them first", existing);
		return (0);
	}

	return (0);
}

/*
 * cvs_remove_file()
 *
 * Physically remove the file.
 * Used by both remote and local handlers.
 * Returns 0 on success, -1 on failure.
 */
static int
cvs_remove_file(const char *fpath)
{
	struct stat st;

	/* if -f option is used, physically remove the file */
	if (force_remove == 1) {
		if (cvs_unlink(fpath) == -1)
			return (-1);
		nuked++;
d180 5
a184 2
		if (stat(fpath, &st) == -1 && errno == ENOENT)
			nuked++;
a185 2

	return (0);
@


1.44
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.43 2006/03/16 09:06:19 xsa Exp $	*/
@


1.43
log
@zap more unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.42 2006/01/27 12:45:21 xsa Exp $	*/
d207 1
a207 1
		cvs_log(LP_WARN, ((existing == 1) ?
d209 1
a209 1
		    "%d files exist; remove them first"), existing);
d234 1
a234 1
		if ((stat(fpath, &st) == -1) && (errno == ENOENT))
@


1.42
log
@errors handling cleaning here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.41 2006/01/25 08:15:05 xsa Exp $	*/
a94 1
	int ret;
a97 1
	ret = 0;
@


1.41
log
@snprintf() cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.40 2006/01/02 08:11:56 xsa Exp $	*/
d113 1
a113 1
		return (CVS_EX_FILE);
d149 2
a150 1
			return (CVS_EX_FILE);
d165 1
a165 1
			return (CVS_EX_FILE);
d175 1
a175 1
			return (CVS_EX_FILE);
d188 1
a188 1
			return (CVS_EX_DATA);
@


1.40
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.39 2005/12/30 02:03:28 joris Exp $	*/
d131 1
a131 1
	int existing, l, removed;
d166 6
a171 7
		l = snprintf(buf, sizeof(buf), "%s/%s%s",
		    CVS_PATH_CVSDIR, cf->cf_name, CVS_DESCR_FILE_EXT);
		if (l == -1 || l >= (int)sizeof(buf)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", buf);
			return (CVS_EX_DATA);
		}
@


1.39
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.38 2005/12/03 01:02:09 joris Exp $	*/
d28 1
a28 9
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.38
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.37 2005/10/07 21:47:32 reyk Exp $	*/
d112 1
a112 2
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    cf->cf_name);
d114 2
a115 5
			ret = cvs_senddir(root, cf);

		if (ret == -1)
			ret = CVS_EX_PROTO;
		return (ret);
d123 1
a123 2
	if (cvs_sendentry(root, cf) < 0)
		return (CVS_EX_PROTO);
d126 2
a127 6
		if (cf->cf_cvstat != CVS_FST_ADDED) {
			if (cvs_sendreq(root, CVS_REQ_MODIFIED,
			    cf->cf_name) < 0) {
				return (CVS_EX_PROTO);
			}
		}
d129 2
a130 4
		if (cf->cf_flags & CVS_FILE_ONDISK) {
			if (cvs_sendfile(root, fpath) < 0)
				return (CVS_EX_PROTO);
		}
@


1.37
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.36 2005/09/06 17:08:05 xsa Exp $	*/
d182 1
a182 1
		if (cvs_ent_remove(entf, cf->cf_name) == -1)
@


1.36
log
@more bits for the local remove command support; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.35 2005/08/22 11:17:26 xsa Exp $	*/
d251 1
a251 1
		if(cvs_unlink(fpath) == -1)
@


1.35
log
@- handle removal of a freshly added file
- fix crash if we specify -f and the file is not on disk anymore
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.34 2005/08/12 06:36:14 xsa Exp $	*/
d153 1
d206 2
d209 3
a211 1
		/* XXX prefix file version with the `-' char in CVS/Entries */
@


1.34
log
@a few things left to do here.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.33 2005/08/10 15:34:46 xsa Exp $	*/
d29 1
d152 1
d155 1
d181 2
a182 2

		/* XXX scratch it from CVS/Entries */
d191 1
d242 2
d249 3
@


1.33
log
@style..
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.32 2005/07/29 23:56:56 joris Exp $	*/
d178 3
d201 3
@


1.32
log
@do not send a MODIFIED request to the server for a newly added file we
already removed again.

spotted by & ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.31 2005/07/29 22:59:10 joris Exp $	*/
d229 2
a230 2
static
int cvs_remove_file(const char *fpath)
@


1.31
log
@make sure we do not try to send the file to the server if it is no
longer on disk.

problem reported by Nuno Morgadinho.
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.30 2005/07/27 17:14:08 xsa Exp $	*/
d130 5
a134 2
		if (cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name) < 0) {
			return (CVS_EX_PROTO);
@


1.30
log
@more use of LP_NOTICE instead of LP_INFO;
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.29 2005/07/27 16:42:19 xsa Exp $	*/
d134 4
a137 2
		if (cvs_sendfile(root, fpath) < 0)
			return (CVS_EX_PROTO);
@


1.29
log
@use LP_NOTICE instead of LP_INFO where appropriate;
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.28 2005/07/26 14:58:58 xsa Exp $	*/
d184 1
a184 1
			cvs_log(LP_INFO, "removed `%s'", cf->cf_name);
d194 1
a194 1
			cvs_log(LP_INFO, "scheduling file `%s' for removal",
d201 1
a201 1
			cvs_log(LP_INFO, "use '%s commit' to remove %s "
@


1.28
log
@remove the (errno != ENOENT) check now that it is included in cvs_unlink();
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.27 2005/07/25 20:15:35 xsa Exp $	*/
d151 1
a151 1
			cvs_log(LP_INFO, "Removing %s", cf->cf_name);
@


1.27
log
@"file file" -> "this file" in an info msg;
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.26 2005/07/25 12:13:08 xsa Exp $	*/
d180 1
a180 1
		if ((cvs_unlink(buf) == -1) && (errno != ENOENT))
d229 1
a229 1
		if((cvs_unlink(fpath) == -1) && (errno != ENOENT))
@


1.26
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.25 2005/07/24 17:48:05 xsa Exp $	*/
d203 1
a203 1
			    (removed == 1) ? "file file" : "these files");
@


1.25
log
@some more `if (!var)' cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.24 2005/07/24 17:20:14 xsa Exp $	*/
d45 4
a48 4
static int cvs_remove_init   (struct cvs_cmd *, int, char **, int *);
static int cvs_remove_remote (CVSFILE *, void *);
static int cvs_remove_local  (CVSFILE *, void *);
static int cvs_remove_file   (const char *);
@


1.24
log
@use cvs_unlink();
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.23 2005/07/24 16:46:40 xsa Exp $	*/
d162 1
a162 1
	if (!nuked) {
d199 1
a199 1
	if (removed) {
d207 1
a207 1
	if (existing) {
@


1.23
log
@do not use `if (!var)' unless it's boolean, better use an == check;
ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.22 2005/07/23 22:43:39 joris Exp $	*/
d180 1
a180 3
		if ((cvs_noexec == 0) &&
		    (unlink(buf) == -1) && (errno != ENOENT)) {
			cvs_log(LP_ERRNO, "cannot remove %s", buf);
d182 1
a182 1
		}
d228 2
a229 3
	if ((force_remove == 1) && (cvs_noexec == 0)) {
		if((unlink(fpath) == -1) && (errno != ENOENT)) {
			cvs_log(LP_ERRNO, "unable to remove %s", fpath);
a230 1
		}
@


1.22
log
@fix remote remove command, gcc didn't even catch this misplaced bracket.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.21 2005/07/21 16:59:24 xsa Exp $	*/
d180 2
a181 1
		if (!cvs_noexec && (unlink(buf) == -1) && (errno != ENOENT)) {
d230 1
a230 1
	if ((force_remove == 1) && !cvs_noexec) {
@


1.21
log
@if the remove command is issued on a file that has been added but not
committed yet, remove CVS/<file>,t (in local mode);
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.20 2005/07/20 06:59:27 xsa Exp $	*/
d130 1
a130 1
		if (cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name < 0)) {
@


1.20
log
@fix local mode; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.19 2005/07/11 07:51:01 xsa Exp $	*/
d144 2
a145 2
	int existing, removed;
	char fpath[MAXPATHLEN];
d173 11
a183 1
		/* XXX remove ,t file */
@


1.19
log
@print info message;
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.18 2005/07/08 16:03:38 joris Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004 Xavier Santolaria <xsa@@openbsd.org>
d45 1
a45 1
static int cvs_remove_init (struct cvs_cmd *, int, char **, int *);
d47 2
a48 1
static int cvs_remove_local (CVSFILE *, void *);
d51 1
d112 1
a112 1
			    CVS_FILE_NAME(cf));
d123 2
a124 8
	/* if -f option is used, physically remove the file */
	if ((force_remove == 1) && !cvs_noexec) {
		if((unlink(fpath) == -1) && (errno != ENOENT)) {
			cvs_log(LP_ERRNO,
			    "failed to unlink `%s'", fpath);
			return (CVS_EX_FILE);
		}
	}
d130 1
a130 2
		if (cvs_sendreq(root, CVS_REQ_MODIFIED,
		    CVS_FILE_NAME(cf)) < 0) {
d144 5
d155 71
a225 3
	cvs_log(LP_INFO, "scheduling file `%s' for removal", cf->cf_name);
	cvs_log(LP_INFO, "use `%s commit' to remove this file permanently",
	    __progname);
@


1.18
log
@split local and remote function handlers from each other.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.17 2005/07/07 14:27:57 joris Exp $	*/
d149 6
@


1.17
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.16 2005/05/24 04:12:25 jfb Exp $	*/
d46 2
a47 1
static int cvs_remove_file (CVSFILE *, void *);
d61 2
a62 2
	cvs_remove_file,
	cvs_remove_file,
d98 1
a98 1
cvs_remove_file(CVSFILE *cf, void *arg)
d108 5
a112 10
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cf->cf_cvstat == CVS_FST_UNKNOWN)
				ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
				    CVS_FILE_NAME(cf));
			else
				ret = cvs_senddir(root, cf);

			if (ret == -1)
				ret = CVS_EX_PROTO;
		}
d114 2
d121 6
a126 8
	if (root->cr_method != CVS_METHOD_LOCAL) {
		/* if -f option is used, physically remove the file */
		if ((force_remove == 1) && !cvs_noexec) {
			if((unlink(fpath) == -1) && (errno != ENOENT)) {
				cvs_log(LP_ERRNO,
				    "failed to unlink `%s'", fpath);
				return (CVS_EX_FILE);
			}
d128 4
d133 3
a135 1
		if (cvs_sendentry(root, cf) < 0)
d137 1
d139 3
a141 5
		if (cf->cf_cvstat != CVS_FST_LOST && force_remove != 1) {
			if (cvs_sendreq(root, CVS_REQ_MODIFIED,
			    CVS_FILE_NAME(cf)) < 0) {
				return (CVS_EX_PROTO);
			}
d143 9
a151 10
			if (cvs_sendfile(root, fpath) < 0)
				return (CVS_EX_PROTO);
		}
	} else {
		cvs_log(LP_INFO, "scheduling file `%s' for removal",
		    CVS_FILE_NAME(cf));
		cvs_log(LP_INFO,
		    "use `%s commit' to remove this file permanently",
		    __progname);
	}
d153 1
a153 1
	return (ret);
@


1.16
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.15 2005/05/20 20:00:53 joris Exp $	*/
d135 1
a135 1
		
@


1.15
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.14 2005/05/20 19:58:03 xsa Exp $	*/
d45 2
a46 2
static int cvs_remove_file(CVSFILE *, void *);
static int cvs_remove_options(char *, int, char **, int *);
d50 6
a55 2
struct cvs_cmd_info cvs_remove = {
	cvs_remove_options,
d57 4
d62 2
a63 3
	NULL, NULL,
	CF_IGNORE | CF_RECURSE,
	CVS_REQ_REMOVE,
d68 1
a68 1
cvs_remove_options(char *opt, int argc, char **argv, int *arg)
d72 1
a72 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d78 1
a78 1
			cvs_remove.file_flags &= ~CF_RECURSE;
d81 1
a81 1
			cvs_remove.file_flags |= CF_RECURSE;
@


1.14
log
@cvs_noexec checks; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.13 2005/05/12 14:04:13 xsa Exp $	*/
d106 3
@


1.13
log
@make functions static; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.12 2005/04/21 20:56:12 xsa Exp $	*/
d115 1
a115 1
		if (force_remove == 1) {
@


1.12
log
@let the `cvs remove' command work with no file(s) specified as args;
joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.11 2005/04/21 19:06:06 xsa Exp $	*/
d45 2
a46 2
int cvs_remove_file(CVSFILE *, void *);
int cvs_remove_options(char *, int, char **, int *);
d60 1
a60 1
int
d89 1
a89 1
int
@


1.11
log
@better include the cvs_sendfile() req in the conditional statement so
it behaves like expected.. pointed out by joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.10 2005/04/21 18:54:50 xsa Exp $	*/
a82 3

	if (argc == 0)
		return (CVS_EX_USAGE);
@


1.10
log
@add checks for files still physically present that should be removed;
input/ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.9 2005/04/19 15:36:39 xsa Exp $	*/
d134 3
a137 3

		if (cvs_sendfile(root, fpath) < 0)
			return (CVS_EX_PROTO);
@


1.9
log
@- remove unused header
- add -l and -R flags
- add check on cvs_sendentry() return value
joris@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.8 2005/04/18 21:02:50 jfb Exp $	*/
d55 1
a55 1
	0,
a116 5
		if (cvs_sendentry(root, cf) < 0) {
			return (CVS_EX_PROTO);
		}

	} else {
d120 2
a121 2
				cvs_log(LP_ERRNO, "failed to unlink `%s'",
				    fpath);
d126 13
@


1.8
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.7 2005/04/12 14:58:40 joris Exp $	*/
a34 1
#include <libgen.h>
d71 1
d74 1
d117 4
a120 1
		ret = cvs_sendentry(root, cf);
@


1.7
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.6 2005/04/11 18:02:58 joris Exp $	*/
a96 2
	CVSENTRIES *entfile;
	struct cvs_ent *ent;
a98 1
	ent = NULL;
a114 8
	entfile = cvs_ent_open(dirname(fpath), O_RDWR);
	if (entfile == NULL) {
		cvs_log(LP_ERR, "failed to remove `%s'", fpath);
		return (CVS_EX_FILE);
	}

	ent = cvs_ent_get(entfile, CVS_FILE_NAME(cf));

d116 1
a116 2
		if (ent != NULL)
			ret = cvs_sendentry(root, ent);
a132 2

	cvs_ent_close(entfile);
@


1.6
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.5 2005/04/11 17:56:27 joris Exp $	*/
d76 1
a76 1
			return (1);
d84 1
a84 1
		return (1);
d121 1
a121 1
		return (-1);
d135 1
a135 1
				return (-1);
@


1.5
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.4 2005/03/30 17:43:04 joris Exp $	*/
a35 1
#include <sysexits.h>
@


1.4
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.3 2005/03/09 15:24:36 xsa Exp $	*/
d77 1
a77 1
			return (EX_USAGE);
d85 1
a85 1
		return (EX_USAGE);
@


1.3
log
@enable -f option of `remove' command; ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.2 2005/01/31 16:49:28 jfb Exp $	*/
d47 2
a48 1
int  cvs_remove_file (CVSFILE *, void *);
d50 11
a60 1
int	force_remove = 0;	/* -f option */
a61 6
/*
 * cvs_remove()
 *
 * Handler for the `cvs remove' command.
 * Returns 0 on success, or one of the known system exit codes on failure.
 */
d63 1
a63 1
cvs_remove(int argc, char **argv)
d65 1
a65 2
	int i, ch;
	struct cvsroot *root;
d67 1
a67 1
	while ((ch = getopt(argc, argv, "flR")) != -1) {
d87 1
a87 30
	cvs_files = cvs_file_getspec(argv, argc, 0);
	if (cvs_files == NULL)
		return (EX_DATAERR);

	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}

	if ((root->cr_method != CVS_METHOD_LOCAL) && (cvs_connect(root) < 0))
		return (EX_PROTOCOL);

	cvs_file_examine(cvs_files, cvs_remove_file, NULL);

	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0)
			return (EX_PROTOCOL);

		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				return (EX_PROTOCOL);

		if (cvs_sendreq(root, CVS_REQ_REMOVE, NULL) < 0)
			return (EX_PROTOCOL);
	}

@


1.2
log
@when reporting a file to remove, we must use the Entry request along
with the file's information, and not the remove request, which is only
sent at the end of the command.  partially unbreaks remove until we
support the '-' symbol in Entries file
@
text
@d1 1
a1 1
/*	$OpenBSD: remove.c,v 1.1 2004/12/21 18:15:55 xsa Exp $	*/
d49 1
d66 1
d156 9
@


1.1
log
@on the way to `cvs remove'; ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
d35 1
d119 1
d121 2
d125 1
d140 10
d151 2
a152 1
		ret = cvs_sendreq(root, CVS_REQ_REMOVE, CVS_FILE_NAME(cf));
d156 2
a157 1
		cvs_log(LP_INFO, "use `%s commit' to remove this file permanently",
d160 2
@

