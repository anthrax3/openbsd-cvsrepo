head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.2
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.34.0.16
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.14
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.10
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.8
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.6
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.39
date	2016.10.15.22.20.17;	author millert;	state Exp;
branches;
next	1.38;
commitid	bZGHsljlW6kmRYub;

1.38
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.37;
commitid	O6jeJ0TRmiewrqMI;

1.37
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.36;
commitid	DTQbfd4poqBW8iSJ;

1.36
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	Uu5nFG3wCl0LACBb;

1.35
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Z3HC5pAWzpo5jsTe;

1.34
date	2011.04.01.17.25.26;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.28.21.19.30;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.16.17.53.20;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.15.18.23.50;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.15.11.10.23;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.07.08.39.13;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.06.14.17.27;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2009.04.28.09.05.40;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.11.03.38.28;	author tobias;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.11.02.19.13;	author tobias;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.10.05.01.36;	author tobias;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.30.11.06.17;	author tobias;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.24.19.13.56;	author tobias;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.08.11.53.36;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.03.18.59.44;	author tobias;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.03.18.18.44;	author tobias;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.31.20.11.28;	author tobias;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.22.15.38.30;	author joris;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.29.05.04.40;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.30.03.30.21;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.30.03.24.54;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.30.02.21.20;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.29.08.02.59;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.28.23.02.40;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.28.22.12.44;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.28.22.07.40;	author ray;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.27.07.21.21;	author xsa;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.31.22.24.12;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Quiet compiler warnings.  OK tomc@@ tb@@
@
text
@/*	$OpenBSD: diff_internals.c,v 1.38 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (C) Caldera International Inc.  2001-2002.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code and documentation must retain the above
 *    copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * 4. Neither the name of Caldera International, Inc. nor the names of other
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
 * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 2004 Jean-Francois Brousseau.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)diffreg.c   8.1 (Berkeley) 6/6/93
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <regex.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "cvs.h"
#include "diff.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

/*
 * diff - compare two files.
 */

/*
 *	Uses an algorithm due to Harold Stone, which finds
 *	a pair of longest identical subsequences in the two
 *	files.
 *
 *	The major goal is to generate the match vector J.
 *	J[i] is the index of the line in file1 corresponding
 *	to line i file0. J[i] = 0 if there is no
 *	such line in file1.
 *
 *	Lines are hashed so as to work in core. All potential
 *	matches are located by sorting the lines of each file
 *	on the hash (called ``value''). In particular, this
 *	collects the equivalence classes in file1 together.
 *	Subroutine equiv replaces the value of each line in
 *	file0 by the index of the first element of its
 *	matching equivalence in (the reordered) file1.
 *	To save space equiv squeezes file1 into a single
 *	array member in which the equivalence classes
 *	are simply concatenated, except that their first
 *	members are flagged by changing sign.
 *
 *	Next the indices that point into member are unsorted into
 *	array class according to the original order of file0.
 *
 *	The cleverness lies in routine stone. This marches
 *	through the lines of file0, developing a vector klist
 *	of "k-candidates". At step i a k-candidate is a matched
 *	pair of lines x,y (x in file0 y in file1) such that
 *	there is a common subsequence of length k
 *	between the first i lines of file0 and the first y
 *	lines of file1, but there is no such subsequence for
 *	any smaller y. x is the earliest possible mate to y
 *	that occurs in such a subsequence.
 *
 *	Whenever any of the members of the equivalence class of
 *	lines in file1 matable to a line in file0 has serial number
 *	less than the y of some k-candidate, that k-candidate
 *	with the smallest such y is replaced. The new
 *	k-candidate is chained (via pred) to the current
 *	k-1 candidate so that the actual subsequence can
 *	be recovered. When a member has serial number greater
 *	that the y of all k-candidates, the klist is extended.
 *	At the end, the longest subsequence is pulled out
 *	and placed in the array J by unravel
 *
 *	With J in hand, the matches there recorded are
 *	check'ed against reality to assure that no spurious
 *	matches have crept in due to hashing. If they have,
 *	they are broken, and "jackpot" is recorded--a harmless
 *	matter except that a true match for a spuriously
 *	mated line may now be unnecessarily reported as a change.
 *
 *	Much of the complexity of the program comes simply
 *	from trying to minimize core utilization and
 *	maximize the range of doable problems by dynamically
 *	allocating what is needed and reusing what is not.
 *	The core requirements for problems larger than somewhat
 *	are (in words) 2*length(file0) + length(file1) +
 *	3*(number of k-candidates installed),  typically about
 *	6n words for files of length n.
 */

struct cand {
	int	x;
	int	y;
	int	pred;
};

struct line {
	int	serial;
	int	value;
} *file[2];

/*
 * The following struct is used to record change information when
 * doing a "context" or "unified" diff.  (see routine "change" to
 * understand the highly mnemonic field names)
 */
struct context_vec {
	int	a;		/* start line in old file */
	int	b;		/* end line in old file */
	int	c;		/* start line in new file */
	int	d;		/* end line in new file */
};

static void	 output(FILE *, FILE *, int);
static void	 check(FILE *, FILE *, int);
static void	 range(int, int, char *);
static void	 uni_range(int, int);
static void	 dump_context_vec(FILE *, FILE *, int);
static void	 dump_unified_vec(FILE *, FILE *, int);
static void	 prepare(int, FILE *, off_t, int);
static void	 prune(void);
static void	 equiv(struct line *, int, struct line *, int, int *);
static void	 unravel(int);
static void	 unsort(struct line *, int, int *);
static void	 diff_head(void);
static void	 rdiff_head(void);
static void	 change(FILE *, FILE *, int, int, int, int, int);
static void	 sort(struct line *, int);
static int	 ignoreline(char *);
static int	 asciifile(FILE *);
static void	 fetch(long *, int, int, FILE *, int, int, int);
static int	 newcand(int, int, int);
static int	 search(int *, int, int);
static int	 skipline(FILE *);
static int	 isqrt(int);
static int	 stone(int *, int, int *, int *, int);
static int	 readhash(FILE *, int);
static int	 files_differ(FILE *, FILE *);
static char	*match_function(const long *, int, FILE *);
static char	*preadline(int, size_t, off_t);

static int Tflag;
int diff_context = 3;
int diff_format = D_NORMAL;
const char *diff_file1 = NULL;
const char *diff_file2 = NULL;
RCSNUM *diff_rev1 = NULL;
RCSNUM *diff_rev2 = NULL;
char diffargs[512];
static struct stat stb1, stb2;
static char *ifdefname, *ignore_pats;
regex_t ignore_re;

static int  *J;			/* will be overlaid on class */
static int  *class;		/* will be overlaid on file[0] */
static int  *klist;		/* will be overlaid on file[0] after class */
static int  *member;		/* will be overlaid on file[1] */
static int   clen;
static int   inifdef;		/* whether or not we are in a #ifdef block */
static int   len[2];
static int   pref, suff;	/* length of prefix and suffix */
static int   slen[2];
static int   anychange;
static long *ixnew;		/* will be overlaid on file[1] */
static long *ixold;		/* will be overlaid on klist */
static struct cand *clist;	/* merely a free storage pot for candidates */
static int   clistlen;		/* the length of clist */
static struct line *sfile[2];	/* shortened by pruning common prefix/suffix */
static u_char *chrtran;		/* translation table for case-folding */
static struct context_vec *context_vec_start;
static struct context_vec *context_vec_end;
static struct context_vec *context_vec_ptr;

#define FUNCTION_CONTEXT_SIZE	55
static char lastbuf[FUNCTION_CONTEXT_SIZE];
static int lastline;
static int lastmatchline;
BUF  *diffbuf = NULL;


/*
 * chrtran points to one of 2 translation tables: cup2low if folding upper to
 * lower case clow2low if not folding case
 */
u_char clow2low[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
	0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
	0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c,
	0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
	0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
	0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
	0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
	0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
	0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
	0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
	0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
	0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
	0xfd, 0xfe, 0xff
};

u_char cup2low[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
	0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x60, 0x61,
	0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
	0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
	0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
	0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
	0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
	0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
	0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
	0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
	0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
	0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
	0xfd, 0xfe, 0xff
};

int
diffreg(const char *file1, const char *file2, int _fd1, int _fd2,
    BUF *out, int flags)
{
	FILE *f1, *f2;
	int i, rval, fd1, fd2;

	diff_file1 = file1;
	diff_file2 = file2;
	f1 = f2 = NULL;
	rval = D_SAME;
	anychange = 0;
	lastline = 0;
	lastmatchline = 0;
	context_vec_ptr = context_vec_start - 1;
	if (flags & D_IGNORECASE)
		chrtran = cup2low;
	else
		chrtran = clow2low;
	if (out != NULL)
		diffbuf = out;

	fd1 = dup(_fd1);
	if (fd1 == -1)
		fatal("diffreg: dup: %s", strerror(errno));

	fd2 = dup(_fd2);
	if (fd2 == -1)
		fatal("diffreg: dup: %s", strerror(errno));

	if (lseek(fd1, 0, SEEK_SET) < 0)
		fatal("diffreg: lseek: %s", strerror(errno));

	f1 = fdopen(fd1, "r");
	if (f1 == NULL) {
		cvs_log(LP_ERR, "%s", file1);
		goto closem;
	}

	if (lseek(fd2, 0, SEEK_SET) < 0)
		fatal("diffreg: lseek: %s", strerror(errno));

	f2 = fdopen(fd2, "r");
	if (f2 == NULL) {
		cvs_log(LP_ERR, "%s", file2);
		goto closem;
	}

	if (fstat(fd1, &stb1) < 0) {
		cvs_log(LP_ERR, "%s", file1);
		goto closem;
	}

	if (fstat(fd2, &stb2) < 0) {
		cvs_log(LP_ERR, "%s", file2);
		goto closem;
	}

	switch (files_differ(f1, f2)) {
	case 0:
		goto closem;
	case 1:
		break;
	default:
		/* error */
		goto closem;
	}

	if ((flags & D_FORCEASCII) == 0 &&
	    (!asciifile(f1) || !asciifile(f2))) {
		rval = D_BINARY;
		goto closem;
	}

	prepare(0, f1, stb1.st_size, flags);
	prepare(1, f2, stb2.st_size, flags);

	prune();
	sort(sfile[0], slen[0]);
	sort(sfile[1], slen[1]);

	member = (int *)file[1];
	equiv(sfile[0], slen[0], sfile[1], slen[1], member);
	member = xreallocarray(member, slen[1] + 2, sizeof(*member));

	class = (int *)file[0];
	unsort(sfile[0], slen[0], class);
	class = xreallocarray(class, slen[0] + 2, sizeof(*class));

	klist = xcalloc(slen[0] + 2, sizeof(*klist));
	clen = 0;
	clistlen = 100;
	clist = xcalloc(clistlen, sizeof(*clist));
	i = stone(class, slen[0], member, klist, flags);
	free(member);
	free(class);

	J = xreallocarray(J, len[0] + 2, sizeof(*J));
	unravel(klist[i]);
	free(clist);
	free(klist);

	ixold = xreallocarray(ixold, len[0] + 2, sizeof(*ixold));
	ixnew = xreallocarray(ixnew, len[1] + 2, sizeof(*ixnew));
	check(f1, f2, flags);
	output(f1, f2, flags);

closem:
	if (anychange) {
		if (rval == D_SAME)
			rval = D_DIFFER;
	}
	if (f1 != NULL)
		fclose(f1);
	if (f2 != NULL)
		fclose(f2);

	return (rval);
}

/*
 * Check to see if the given files differ.
 * Returns 0 if they are the same, 1 if different, and -1 on error.
 * XXX - could use code from cmp(1) [faster]
 */
static int
files_differ(FILE *f1, FILE *f2)
{
	char buf1[BUFSIZ], buf2[BUFSIZ];
	size_t i, j;

	if (stb1.st_size != stb2.st_size)
		return (1);
	for (;;) {
		i = fread(buf1, 1, sizeof(buf1), f1);
		j = fread(buf2, 1, sizeof(buf2), f2);
		if ((!i && ferror(f1)) || (!j && ferror(f2)))
			return (-1);
		if (i != j)
			return (1);
		if (i == 0)
			return (0);
		if (memcmp(buf1, buf2, i) != 0)
			return (1);
	}
}

static void
prepare(int i, FILE *fd, off_t filesize, int flags)
{
	struct line *p;
	int j, h;
	size_t sz;

	rewind(fd);

	sz = ((uintmax_t)filesize <= SIZE_MAX ? (size_t)filesize : SIZE_MAX) / 25;
	if (sz < 100)
		sz = 100;

	p = xcalloc(sz + 3, sizeof(*p));
	for (j = 0; (h = readhash(fd, flags));) {
		if ((size_t)j == sz) {
			sz = sz * 3 / 2;
			p = xreallocarray(p, sz + 3, sizeof(*p));
		}
		p[++j].value = h;
	}
	len[i] = j;
	file[i] = p;
}

static void
prune(void)
{
	int i, j;

	for (pref = 0; pref < len[0] && pref < len[1] &&
	    file[0][pref + 1].value == file[1][pref + 1].value;
	    pref++)
		;
	for (suff = 0; suff < len[0] - pref && suff < len[1] - pref &&
	    file[0][len[0] - suff].value == file[1][len[1] - suff].value;
	    suff++)
		;
	for (j = 0; j < 2; j++) {
		sfile[j] = file[j] + pref;
		slen[j] = len[j] - pref - suff;
		for (i = 0; i <= slen[j]; i++)
			sfile[j][i].serial = i;
	}
}

static void
equiv(struct line *a, int n, struct line *b, int m, int *c)
{
	int i, j;

	i = j = 1;
	while (i <= n && j <= m) {
		if (a[i].value < b[j].value)
			a[i++].value = 0;
		else if (a[i].value == b[j].value)
			a[i++].value = j;
		else
			j++;
	}
	while (i <= n)
		a[i++].value = 0;
	b[m + 1].value = 0;
	j = 0;
	while (++j <= m) {
		c[j] = -b[j].serial;
		while (b[j + 1].value == b[j].value) {
			j++;
			c[j] = b[j].serial;
		}
	}
	c[j] = -1;
}

/* Code taken from ping.c */
static int
isqrt(int n)
{
	int y, x = 1;

	if (n == 0)
		return (0);

	do { /* newton was a stinker */
		y = x;
		x = n / x;
		x += y;
		x /= 2;
	} while ((x - y) > 1 || (x - y) < -1);

	return (x);
}

static int
stone(int *a, int n, int *b, int *c, int flags)
{
	int i, k, y, j, l;
	int oldc, tc, oldl, sq;
	u_int numtries, bound;

	if (flags & D_MINIMAL)
		bound = UINT_MAX;
	else {
		sq = isqrt(n);
		bound = MAXIMUM(256, sq);
	}

	k = 0;
	c[0] = newcand(0, 0, 0);
	for (i = 1; i <= n; i++) {
		j = a[i];
		if (j == 0)
			continue;
		y = -b[j];
		oldl = 0;
		oldc = c[0];
		numtries = 0;
		do {
			if (y <= clist[oldc].y)
				continue;
			l = search(c, k, y);
			if (l != oldl + 1)
				oldc = c[l - 1];
			if (l <= k) {
				if (clist[c[l]].y <= y)
					continue;
				tc = c[l];
				c[l] = newcand(i, y, oldc);
				oldc = tc;
				oldl = l;
				numtries++;
			} else {
				c[l] = newcand(i, y, oldc);
				k++;
				break;
			}
		} while ((y = b[++j]) > 0 && numtries < bound);
	}
	return (k);
}

static int
newcand(int x, int y, int pred)
{
	struct cand *q;

	if (clen == clistlen) {
		clistlen = clistlen * 11 / 10;
		clist = xreallocarray(clist, clistlen, sizeof(*clist));
	}
	q = clist + clen;
	q->x = x;
	q->y = y;
	q->pred = pred;
	return (clen++);
}

static int
search(int *c, int k, int y)
{
	int i, j, l, t;

	if (clist[c[k]].y < y)	/* quick look for typical case */
		return (k + 1);
	i = 0;
	j = k + 1;
	for (;;) {
		l = (i + j) / 2;
		if (l <= i)
			break;
		t = clist[c[l]].y;
		if (t > y)
			j = l;
		else if (t < y)
			i = l;
		else
			return (l);
	}
	return (l + 1);
}

static void
unravel(int p)
{
	struct cand *q;
	int i;

	for (i = 0; i <= len[0]; i++)
		J[i] = i <= pref ? i :
		    i > len[0] - suff ? i + len[1] - len[0] : 0;
	for (q = clist + p; q->y != 0; q = clist + q->pred)
		J[q->x + pref] = q->y + pref;
}

/*
 * Check does double duty:
 *  1.	ferret out any fortuitous correspondences due
 *	to confounding by hashing (which result in "jackpot")
 *  2.  collect random access indexes to the two files
 */
static void
check(FILE *f1, FILE *f2, int flags)
{
	int i, j, jackpot, c, d;
	long ctold, ctnew;

	rewind(f1);
	rewind(f2);
	j = 1;
	ixold[0] = ixnew[0] = 0;
	jackpot = 0;
	ctold = ctnew = 0;
	for (i = 1; i <= len[0]; i++) {
		if (J[i] == 0) {
			ixold[i] = ctold += skipline(f1);
			continue;
		}
		while (j < J[i]) {
			ixnew[j] = ctnew += skipline(f2);
			j++;
		}
		if (flags & (D_FOLDBLANKS|D_IGNOREBLANKS|D_IGNORECASE)) {
			for (;;) {
				c = getc(f1);
				d = getc(f2);
				/*
				 * GNU diff ignores a missing newline
				 * in one file for -b or -w.
				 */
				if ((flags & (D_FOLDBLANKS|D_IGNOREBLANKS)) &&
				    ((c == EOF && d == '\n') ||
				    (c == '\n' && d == EOF))) {
					break;
				}
				ctold++;
				ctnew++;
				if ((flags & D_FOLDBLANKS) && isspace(c) &&
				    isspace(d)) {
					do {
						if (c == '\n')
							break;
						ctold++;
					} while (isspace(c = getc(f1)));
					do {
						if (d == '\n')
							break;
						ctnew++;
					} while (isspace(d = getc(f2)));
				} else if ((flags & D_IGNOREBLANKS)) {
					while (isspace(c) && c != '\n') {
						c = getc(f1);
						ctold++;
					}
					while (isspace(d) && d != '\n') {
						d = getc(f2);
						ctnew++;
					}
				}
				if (chrtran[c] != chrtran[d]) {
					jackpot++;
					J[i] = 0;
					if (c != '\n' && c != EOF)
						ctold += skipline(f1);
					if (d != '\n' && c != EOF)
						ctnew += skipline(f2);
					break;
				}
				if (c == '\n' || c == EOF)
					break;
			}
		} else {
			for (;;) {
				ctold++;
				ctnew++;
				if ((c = getc(f1)) != (d = getc(f2))) {
					/* jackpot++; */
					J[i] = 0;
					if (c != '\n' && c != EOF)
						ctold += skipline(f1);
					if (d != '\n' && c != EOF)
						ctnew += skipline(f2);
					break;
				}
				if (c == '\n' || c == EOF)
					break;
			}
		}
		ixold[i] = ctold;
		ixnew[j] = ctnew;
		j++;
	}
	for (; j <= len[1]; j++)
		ixnew[j] = ctnew += skipline(f2);
	/*
	 * if (jackpot)
	 *	fprintf(stderr, "jackpot\n");
	 */
}

/* shellsort CACM #201 */
static void
sort(struct line *a, int n)
{
	struct line *ai, *aim, w;
	int j, m = 0, k;

	if (n == 0)
		return;
	for (j = 1; j <= n; j *= 2)
		m = 2 * j - 1;
	for (m /= 2; m != 0; m /= 2) {
		k = n - m;
		for (j = 1; j <= k; j++) {
			for (ai = &a[j]; ai > a; ai -= m) {
				aim = &ai[m];
				if (aim < ai)
					break;	/* wraparound */
				if (aim->value > ai[0].value ||
				    (aim->value == ai[0].value &&
					aim->serial > ai[0].serial))
					break;
				w.value = ai[0].value;
				ai[0].value = aim->value;
				aim->value = w.value;
				w.serial = ai[0].serial;
				ai[0].serial = aim->serial;
				aim->serial = w.serial;
			}
		}
	}
}

static void
unsort(struct line *f, int l, int *b)
{
	int *a, i;

	a = xcalloc(l + 1, sizeof(*a));
	for (i = 1; i <= l; i++)
		a[f[i].serial] = f[i].value;
	for (i = 1; i <= l; i++)
		b[i] = a[i];
	free(a);
}

static int
skipline(FILE *f)
{
	int i, c;

	for (i = 1; (c = getc(f)) != '\n' && c != EOF; i++)
		continue;
	return (i);
}

static void
output(FILE *f1, FILE *f2, int flags)
{
	int m, i0, i1, j0, j1;

	rewind(f1);
	rewind(f2);
	m = len[0];
	J[0] = 0;
	J[m + 1] = len[1] + 1;
	for (i0 = 1; i0 <= m; i0 = i1 + 1) {
		while (i0 <= m && J[i0] == J[i0 - 1] + 1)
			i0++;
		j0 = J[i0 - 1] + 1;
		i1 = i0 - 1;
		while (i1 < m && J[i1 + 1] == 0)
			i1++;
		j1 = J[i1 + 1] - 1;
		J[i1] = j1;
		change(f1, f2, i0, i1, j0, j1, flags);
	}
	if (m == 0)
		change(f1, f2, 1, 0, 1, len[1], flags);
	if (diff_format == D_IFDEF) {
		for (;;) {
#define	c i0
			if ((c = getc(f1)) == EOF)
				return;
			diff_output("%c", c);
		}
#undef c
	}
	if (anychange != 0) {
		if (diff_format == D_CONTEXT)
			dump_context_vec(f1, f2, flags);
		else if (diff_format == D_UNIFIED)
			dump_unified_vec(f1, f2, flags);
	}
}

static void
range(int a, int b, char *separator)
{
	diff_output("%d", a > b ? b : a);
	if (a < b)
		diff_output("%s%d", separator, b);
}

static void
uni_range(int a, int b)
{
	if (a < b)
		diff_output("%d,%d", a, b - a + 1);
	else if (a == b)
		diff_output("%d", b);
	else
		diff_output("%d,0", b);
}

static char *
preadline(int fd, size_t rlen, off_t off)
{
	char *line;
	ssize_t nr;

	line = xmalloc(rlen + 1);
	if ((nr = pread(fd, line, rlen, off)) < 0)
		fatal("preadline: %s", strerror(errno));
	line[nr] = '\0';
	return (line);
}

static int
ignoreline(char *line)
{
	int ret;

	ret = regexec(&ignore_re, line, 0, NULL, 0);
	free(line);
	return (ret == 0);	/* if it matched, it should be ignored. */
}

static void
diff_head(void)
{
	char buf[64];
	struct tm t;
	time_t curr_time;

	if (diff_rev1 != NULL) {
		gmtime_r(&stb1.st_mtime, &t);
	} else {
		time(&curr_time);
		localtime_r(&curr_time, &t);
	}

	(void)strftime(buf, sizeof(buf), "%b %G %H:%M:%S -0000", &t);
	diff_output("%s %s	%d %s", diff_format == D_CONTEXT ?
	    "***" : "---", diff_file1, t.tm_mday, buf);

	if (diff_rev1 != NULL) {
		rcsnum_tostr(diff_rev1, buf, sizeof(buf));
		diff_output("\t%s", buf);
	}

	diff_output("\n");

	gmtime_r(&stb2.st_mtime, &t);

	(void)strftime(buf, sizeof(buf), "%b %G %H:%M:%S -0000", &t);
	diff_output("%s %s	%d %s", diff_format == D_CONTEXT ?
	    "---" : "+++", diff_file2, t.tm_mday, buf);

	if (diff_rev2 != NULL) {
		rcsnum_tostr(diff_rev2, buf, sizeof(buf));
		diff_output("\t%s", buf);
	}

	diff_output("\n");
}

static void
rdiff_head(void)
{
	char buf[64];
	struct tm t;
	time_t curr_time;

	diff_output("%s ", diff_format == D_CONTEXT ? "***" : "---");

	if (diff_rev1 == NULL) {
		diff_output("%s", CVS_PATH_DEVNULL);
		gmtime_r(&stb1.st_atime, &t);
	} else {
		rcsnum_tostr(diff_rev1, buf, sizeof(buf));
		diff_output("%s:%s", diff_file1, buf);
		localtime_r(&stb1.st_mtime, &t);
	}

	(void)strftime(buf, sizeof(buf), "%a %b %e %H:%M:%S %G", &t);
	diff_output("\t%s\n", buf);

	if (diff_rev2 != NULL) {
		localtime_r(&stb2.st_mtime, &t);
	} else {
		time(&curr_time);
		localtime_r(&curr_time, &t);
	}

	(void)strftime(buf, sizeof(buf), "%a %b %e %H:%M:%S %G", &t);

	diff_output("%s %s	%s\n", diff_format == D_CONTEXT ? "---" : "+++",
	    diff_file2, buf);
}

/*
 * Indicate that there is a difference between lines a and b of the from file
 * to get to lines c to d of the to file.  If a is greater then b then there
 * are no lines in the from file involved and this means that there were
 * lines appended (beginning at b).  If c is greater than d then there are
 * lines missing from the to file.
 */
static void
change(FILE *f1, FILE *f2, int a, int b, int c, int d, int flags)
{
	static size_t max_context = 64;
	int i;

	if (diff_format != D_IFDEF && a > b && c > d)
		return;
	if (ignore_pats != NULL) {
		char *line;
		/*
		 * All lines in the change, insert, or delete must
		 * match an ignore pattern for the change to be
		 * ignored.
		 */
		if (a <= b) {		/* Changes and deletes. */
			for (i = a; i <= b; i++) {
				line = preadline(fileno(f1),
				    ixold[i] - ixold[i - 1], ixold[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		if (a > b || c <= d) {	/* Changes and inserts. */
			for (i = c; i <= d; i++) {
				line = preadline(fileno(f2),
				    ixnew[i] - ixnew[i - 1], ixnew[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		return;
	}
proceed:
	if (diff_format == D_CONTEXT || diff_format == D_UNIFIED) {
		/*
		 * Allocate change records as needed.
		 */
		if (context_vec_ptr == context_vec_end - 1) {
			ptrdiff_t offset = context_vec_ptr - context_vec_start;
			max_context <<= 1;
			context_vec_start = xreallocarray(context_vec_start,
			    max_context, sizeof(*context_vec_start));
			context_vec_end = context_vec_start + max_context;
			context_vec_ptr = context_vec_start + offset;
		}
		if (anychange == 0) {
			/*
			 * Print the context/unidiff header first time through.
			 */
			if (cvs_cmdop == CVS_OP_RDIFF)
				rdiff_head();
			else
				diff_head();

			anychange = 1;
		} else if (a > context_vec_ptr->b + (2 * diff_context) + 1 &&
		    c > context_vec_ptr->d + (2 * diff_context) + 1) {
			/*
			 * If this change is more than 'context' lines from the
			 * previous change, dump the record and reset it.
			 */
			if (diff_format == D_CONTEXT)
				dump_context_vec(f1, f2, flags);
			else
				dump_unified_vec(f1, f2, flags);
		}
		context_vec_ptr++;
		context_vec_ptr->a = a;
		context_vec_ptr->b = b;
		context_vec_ptr->c = c;
		context_vec_ptr->d = d;
		return;
	}
	if (anychange == 0)
		anychange = 1;
	switch (diff_format) {
	case D_BRIEF:
		return;
	case D_NORMAL:
		range(a, b, ",");
		diff_output("%c", a > b ? 'a' : c > d ? 'd' : 'c');
		if (diff_format == D_NORMAL)
			range(c, d, ",");
		diff_output("\n");
		break;
	case D_RCSDIFF:
		if (a > b)
			diff_output("a%d %d\n", b, d - c + 1);
		else {
			diff_output("d%d %d\n", a, b - a + 1);

			if (!(c > d))	/* add changed lines */
				diff_output("a%d %d\n", b, d - c + 1);
		}
		break;
	}
	if (diff_format == D_NORMAL || diff_format == D_IFDEF) {
		fetch(ixold, a, b, f1, '<', 1, flags);
		if (a <= b && c <= d && diff_format == D_NORMAL)
			diff_output("---\n");
	}
	fetch(ixnew, c, d, f2, diff_format == D_NORMAL ? '>' : '\0', 0, flags);
	if (inifdef) {
		diff_output("#endif /* %s */\n", ifdefname);
		inifdef = 0;
	}
}

static void
fetch(long *f, int a, int b, FILE *lb, int ch, int oldfile, int flags)
{
	long j, nc;
	int i, c, col;

	/*
	 * When doing #ifdef's, copy down to current line
	 * if this is the first file, so that stuff makes it to output.
	 */
	if (diff_format == D_IFDEF && oldfile) {
		long curpos = ftell(lb);
		/* print through if append (a>b), else to (nb: 0 vs 1 orig) */
		nc = f[a > b ? b : a - 1] - curpos;
		for (i = 0; i < nc; i++)
			diff_output("%c", getc(lb));
	}
	if (a > b)
		return;
	if (diff_format == D_IFDEF) {
		if (inifdef) {
			diff_output("#else /* %s%s */\n",
			    oldfile == 1 ? "!" : "", ifdefname);
		} else {
			if (oldfile)
				diff_output("#ifndef %s\n", ifdefname);
			else
				diff_output("#ifdef %s\n", ifdefname);
		}
		inifdef = 1 + oldfile;
	}
	for (i = a; i <= b; i++) {
		fseek(lb, f[i - 1], SEEK_SET);
		nc = f[i] - f[i - 1];
		if (diff_format != D_IFDEF && ch != '\0') {
			diff_output("%c", ch);
			if (Tflag == 1 && (diff_format == D_NORMAL ||
			    diff_format == D_CONTEXT ||
			    diff_format == D_UNIFIED))
				diff_output("\t");
			else if (diff_format != D_UNIFIED)
				diff_output(" ");
		}
		col = 0;
		for (j = 0; j < nc; j++) {
			if ((c = getc(lb)) == EOF) {
				if (diff_format == D_RCSDIFF)
					cvs_log(LP_ERR,
					    "No newline at end of file");
				else
					diff_output("\n\\ No newline at end of "
					    "file\n");
				return;
			}
			if (c == '\t' && (flags & D_EXPANDTABS)) {
				do {
					diff_output(" ");
				} while (++col & 7);
			} else {
				diff_output("%c", c);
				col++;
			}
		}
	}
}

/*
 * Hash function taken from Robert Sedgewick, Algorithms in C, 3d ed., p 578.
 */
static int
readhash(FILE *f, int flags)
{
	int i, t, space;
	int sum;

	sum = 1;
	space = 0;
	if ((flags & (D_FOLDBLANKS|D_IGNOREBLANKS)) == 0) {
		if (flags & D_IGNORECASE)
			for (i = 0; (t = getc(f)) != '\n'; i++) {
				if (t == EOF) {
					if (i == 0)
						return (0);
					break;
				}
				sum = sum * 127 + chrtran[t];
			}
		else
			for (i = 0; (t = getc(f)) != '\n'; i++) {
				if (t == EOF) {
					if (i == 0)
						return (0);
					break;
				}
				sum = sum * 127 + t;
			}
	} else {
		for (i = 0;;) {
			switch (t = getc(f)) {
			case '\t':
			case '\r':
			case '\v':
			case '\f':
			case ' ':
				space++;
				continue;
			default:
				if (space && (flags & D_IGNOREBLANKS) == 0) {
					i++;
					space = 0;
				}
				sum = sum * 127 + chrtran[t];
				i++;
				continue;
			case EOF:
				if (i == 0)
					return (0);
				/* FALLTHROUGH */
			case '\n':
				break;
			}
			break;
		}
	}
	/*
	 * There is a remote possibility that we end up with a zero sum.
	 * Zero is used as an EOF marker, so return 1 instead.
	 */
	return (sum == 0 ? 1 : sum);
}

static int
asciifile(FILE *f)
{
	unsigned char buf[BUFSIZ];
	size_t i, cnt;

	if (f == NULL)
		return (1);

	rewind(f);
	cnt = fread(buf, 1, sizeof(buf), f);
	for (i = 0; i < cnt; i++)
		if (!isprint(buf[i]) && !isspace(buf[i]))
			return (0);
	return (1);
}

#define begins_with(s, pre) (strncmp(s, pre, sizeof(pre)-1) == 0)

static char *
match_function(const long *f, int pos, FILE *fp)
{
	unsigned char buf[FUNCTION_CONTEXT_SIZE];
	size_t nc;
	int last = lastline;
	char *state = NULL;

	lastline = pos;
	while (pos > last) {
		fseek(fp, f[pos - 1], SEEK_SET);
		nc = f[pos] - f[pos - 1];
		if (nc >= sizeof(buf))
			nc = sizeof(buf) - 1;
		nc = fread(buf, 1, nc, fp);
		if (nc > 0) {
			buf[nc] = '\0';
			buf[strcspn(buf, "\n")] = '\0';
			if (isalpha(buf[0]) || buf[0] == '_' || buf[0] == '$') {
				if (begins_with(buf, "private:")) {
					if (!state)
						state = " (private)";
				} else if (begins_with(buf, "protected:")) {
					if (!state)
						state = " (protected)";
				} else if (begins_with(buf, "public:")) {
					if (!state)
						state = " (public)";
				} else {
					strlcpy(lastbuf, buf, sizeof lastbuf);
					if (state)
						strlcat(lastbuf, state,
						    sizeof lastbuf);
					lastmatchline = pos;
					return lastbuf;
				}
			}
		}
		pos--;
	}
	return lastmatchline > 0 ? lastbuf : NULL;
}

/* dump accumulated "context" diff changes */
static void
dump_context_vec(FILE *f1, FILE *f2, int flags)
{
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd, do_output;
	int a, b, c, d;
	char ch, *f;

	if (context_vec_start > context_vec_ptr)
		return;

	b = d = 0;		/* gcc */
	lowa = MAXIMUM(1, cvp->a - diff_context);
	upb = MINIMUM(len[0], context_vec_ptr->b + diff_context);
	lowc = MAXIMUM(1, cvp->c - diff_context);
	upd = MINIMUM(len[1], context_vec_ptr->d + diff_context);

	diff_output("***************");
	if ((flags & D_PROTOTYPE)) {
		f = match_function(ixold, lowa-1, f1);
		if (f != NULL)
			diff_output(" %s", f);
	}
	diff_output("\n*** ");
	range(lowa, upb, ",");
	diff_output(" ****\n");

	/*
	 * Output changes to the "old" file.  The first loop suppresses
	 * output if there were no changes to the "old" file (we'll see
	 * the "old" lines as context in the "new" list).
	 */
	do_output = 0;
	for (; cvp <= context_vec_ptr; cvp++)
		if (cvp->a <= cvp->b) {
			cvp = context_vec_start;
			do_output++;
			break;
		}
	if (do_output) {
		while (cvp <= context_vec_ptr) {
			a = cvp->a;
			b = cvp->b;
			c = cvp->c;
			d = cvp->d;

			if (a <= b && c <= d)
				ch = 'c';
			else
				ch = (a <= b) ? 'd' : 'a';

			if (ch == 'a')
				fetch(ixold, lowa, b, f1, ' ', 0, flags);
			else {
				fetch(ixold, lowa, a - 1, f1, ' ', 0, flags);
				fetch(ixold, a, b, f1,
				    ch == 'c' ? '!' : '-', 0, flags);
			}
			lowa = b + 1;
			cvp++;
		}
		fetch(ixold, b + 1, upb, f1, ' ', 0, flags);
	}
	/* output changes to the "new" file */
	diff_output("--- ");
	range(lowc, upd, ",");
	diff_output(" ----\n");

	do_output = 0;
	for (cvp = context_vec_start; cvp <= context_vec_ptr; cvp++)
		if (cvp->c <= cvp->d) {
			cvp = context_vec_start;
			do_output++;
			break;
		}
	if (do_output) {
		while (cvp <= context_vec_ptr) {
			a = cvp->a;
			b = cvp->b;
			c = cvp->c;
			d = cvp->d;

			if (a <= b && c <= d)
				ch = 'c';
			else
				ch = (a <= b) ? 'd' : 'a';

			if (ch == 'd')
				fetch(ixnew, lowc, d, f2, ' ', 0, flags);
			else {
				fetch(ixnew, lowc, c - 1, f2, ' ', 0, flags);
				fetch(ixnew, c, d, f2,
				    ch == 'c' ? '!' : '+', 0, flags);
			}
			lowc = d + 1;
			cvp++;
		}
		fetch(ixnew, d + 1, upd, f2, ' ', 0, flags);
	}
	context_vec_ptr = context_vec_start - 1;
}

/* dump accumulated "unified" diff changes */
static void
dump_unified_vec(FILE *f1, FILE *f2, int flags)
{
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd;
	int a, b, c, d;
	char ch, *f;

	if (context_vec_start > context_vec_ptr)
		return;

	b = d = 0;		/* gcc */
	lowa = MAXIMUM(1, cvp->a - diff_context);
	upb = MINIMUM(len[0], context_vec_ptr->b + diff_context);
	lowc = MAXIMUM(1, cvp->c - diff_context);
	upd = MINIMUM(len[1], context_vec_ptr->d + diff_context);

	diff_output("@@@@ -");
	uni_range(lowa, upb);
	diff_output(" +");
	uni_range(lowc, upd);
	diff_output(" @@@@");
	if ((flags & D_PROTOTYPE)) {
		f = match_function(ixold, lowa-1, f1);
		if (f != NULL)
			diff_output(" %s", f);
	}
	diff_output("\n");

	/*
	 * Output changes in "unified" diff format--the old and new lines
	 * are printed together.
	 */
	for (; cvp <= context_vec_ptr; cvp++) {
		a = cvp->a;
		b = cvp->b;
		c = cvp->c;
		d = cvp->d;

		/*
		 * c: both new and old changes
		 * d: only changes in the old file
		 * a: only changes in the new file
		 */
		if (a <= b && c <= d)
			ch = 'c';
		else
			ch = (a <= b) ? 'd' : 'a';

		switch (ch) {
		case 'c':
			fetch(ixold, lowa, a - 1, f1, ' ', 0, flags);
			fetch(ixold, a, b, f1, '-', 0, flags);
			fetch(ixnew, c, d, f2, '+', 0, flags);
			break;
		case 'd':
			fetch(ixold, lowa, a - 1, f1, ' ', 0, flags);
			fetch(ixold, a, b, f1, '-', 0, flags);
			break;
		case 'a':
			fetch(ixnew, lowc, c - 1, f2, ' ', 0, flags);
			fetch(ixnew, c, d, f2, '+', 0, flags);
			break;
		}
		lowa = b + 1;
		lowc = d + 1;
	}
	fetch(ixnew, d + 1, upd, f2, ' ', 0, flags);

	context_vec_ptr = context_vec_start - 1;
}

void
diff_output(const char *fmt, ...)
{
	va_list vap;
	int i;
	char *str;

	va_start(vap, fmt);
	i = vasprintf(&str, fmt, vap);
	va_end(vap);
	if (i == -1)
		fatal("diff_output: could not allocate memory");
	if (diffbuf != NULL)
		buf_puts(diffbuf, str);
	else
		cvs_printf("%s", str);
	free(str);
}
@


1.38
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.37 2015/02/05 12:59:57 millert Exp $	*/
d458 1
a458 1
	sz = (filesize <= SIZE_MAX ? filesize : SIZE_MAX) / 25;
d464 1
a464 1
		if (j == sz) {
@


1.37
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.36 2015/01/16 06:40:07 deraadt Exp $	*/
d76 1
d396 2
a397 2
	xfree(member);
	xfree(class);
d401 2
a402 2
	xfree(clist);
	xfree(klist);
d791 1
a791 1
	xfree(a);
d882 1
a882 1
	xfree(line);
d1460 1
a1460 1
	xfree(str);
@


1.36
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.35 2014/12/01 21:58:46 deraadt Exp $	*/
d74 1
@


1.35
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.34 2011/04/01 17:25:26 nicm Exp $	*/
d67 1
a67 1
#include <sys/param.h>
d82 3
d551 1
a551 1
		bound = MAX(256, sq);
d1279 4
a1282 4
	lowa = MAX(1, cvp->a - diff_context);
	upb = MIN(len[0], context_vec_ptr->b + diff_context);
	lowc = MAX(1, cvp->c - diff_context);
	upd = MIN(len[1], context_vec_ptr->d + diff_context);
d1382 4
a1385 4
	lowa = MAX(1, cvp->a - diff_context);
	upb = MIN(len[0], context_vec_ptr->b + diff_context);
	lowc = MAX(1, cvp->c - diff_context);
	upd = MIN(len[1], context_vec_ptr->d + diff_context);
@


1.34
log
@Move an isqrt() call outside a macro, from Michael W Bombardieri.

ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.33 2010/07/28 21:19:30 nicm Exp $	*/
d380 1
a380 1
	member = xrealloc(member, slen[1] + 2, sizeof(*member));
d384 1
a384 1
	class = xrealloc(class, slen[0] + 2, sizeof(*class));
d394 1
a394 1
	J = xrealloc(J, len[0] + 2, sizeof(*J));
d399 2
a400 2
	ixold = xrealloc(ixold, len[0] + 2, sizeof(*ixold));
	ixnew = xrealloc(ixnew, len[1] + 2, sizeof(*ixnew));
d461 1
a461 1
			p = xrealloc(p, sz + 3, sizeof(*p));
d592 1
a592 1
		clist = xrealloc(clist, clistlen, sizeof(*clist));
d1002 1
a1002 1
			context_vec_start = xrealloc(context_vec_start,
@


1.33
log
@Support -U and -C to specify the context length for "cvs diff".

This doesn't alter cvs rdiff, where -U and -C are not support by GNU
cvs.

ok sthen zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.32 2010/07/23 21:46:05 ray Exp $	*/
d541 2
a542 2
	int oldc, tc, oldl;
	u_int numtries;
d544 6
a549 3
	/* XXX move the isqrt() out of the macro to avoid multiple calls */
	const u_int bound = (flags & D_MINIMAL) ? UINT_MAX :
	    MAX(256, isqrt(n));
@


1.32
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.31 2010/07/16 17:53:20 ray Exp $	*/
d201 1
a201 1
static int context = 3;
d1014 2
a1015 2
		} else if (a > context_vec_ptr->b + (2 * context) + 1 &&
		    c > context_vec_ptr->d + (2 * context) + 1) {
d1273 4
a1276 4
	lowa = MAX(1, cvp->a - context);
	upb = MIN(len[0], context_vec_ptr->b + context);
	lowc = MAX(1, cvp->c - context);
	upd = MIN(len[1], context_vec_ptr->d + context);
d1376 4
a1379 4
	lowa = MAX(1, cvp->a - context);
	upb = MIN(len[0], context_vec_ptr->b + context);
	lowc = MAX(1, cvp->c - context);
	upd = MIN(len[1], context_vec_ptr->d + context);
@


1.31
log
@Combine two diff_output lines into one, from diff.

OK stsp xsa nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.30 2010/07/15 18:23:50 ray Exp $	*/
d207 1
a207 1
char diffargs[128];
d1449 1
a1449 1
		cvs_buf_puts(diffbuf, str);
@


1.30
log
@Die immediately if pread fails. It's a fatal error so treat it as
such. Besides, we weren't handling the NULL being returned.

From diff. Minor nit by nicm.

OK xsa stsp nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.29 2010/07/15 11:10:23 ray Exp $	*/
d1281 2
a1282 4
		if (f != NULL) {
			diff_output(" ");
			diff_output("%s", f);
		}
d1388 2
a1389 4
		if (f != NULL) {
			diff_output(" ");
			diff_output("%s", f);
		}
@


1.29
log
@Sync with diff/diffreg.c r1.75:
Return -1 on error as advertised.
Handle case when only one stream failed.

OK xsa, stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.28 2009/06/07 08:39:13 ray Exp $	*/
d862 2
a863 5
	if ((nr = pread(fd, line, rlen, off)) < 0) {
		cvs_log(LP_ERR, "preadline failed");
		xfree(line);
		return (NULL);
	}
@


1.28
log
@More cvs/diff/rcs convergence:
1. Mostly variable/function renaming, SIZE_T_MAX->SIZE_MAX, and
spacing.
2. One strchr -> strncspn.
3. diff had a weird thing where it set file[12] = ofile[12] but
never updated file or ofile, then if file and ofile were different
it freed it. I removed it.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.27 2009/06/06 14:17:27 ray Exp $	*/
d433 2
d437 1
a437 3
		if (i == 0 && j == 0) {
			if (ferror(f1) || ferror(f2))
				return (1);
a438 1
		}
@


1.27
log
@Sync some rcsdiff changes to cvsdiff.  As a side effect,
cvs diff -t now works.  There should be no functional change
otherwise.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.26 2009/04/28 09:05:40 sthen Exp $	*/
d298 1
a298 1
cvs_diffreg(const char *file1, const char *file2, int _fd1, int _fd2,
d321 1
a321 1
		fatal("cvs_diffreg: dup: %s", strerror(errno));
d325 1
a325 1
		fatal("cvs_diffreg: dup: %s", strerror(errno));
d328 1
a328 1
		fatal("cvs_diffreg: lseek: %s", strerror(errno));
d337 1
a337 1
		fatal("cvs_diffreg: lseek: %s", strerror(errno));
d547 1
a547 1
	    MAX(256, (u_int)isqrt(n));
a1226 1
	char *p;
d1238 1
a1238 3
			p = strchr((const char *)buf, '\n');
			if (p != NULL)
				*p = '\0';
d1250 1
a1250 2
					strlcpy(lastbuf, buf,
					    sizeof lastbuf);
@


1.26
log
@support some additional diff options: -a, -b, -d, -w
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.25 2008/06/11 03:38:28 tobias Exp $	*/
d172 2
a173 2
static void	 output(FILE *, FILE *);
static void	 check(FILE *, FILE *);
d176 3
a178 3
static void	 dump_context_vec(FILE *, FILE *);
static void	 dump_unified_vec(FILE *, FILE *);
static void	 prepare(int, FILE *, off_t);
d185 1
a185 1
static void	 change(FILE *, FILE *, int, int, int, int);
d189 1
a189 1
static void	 fetch(long *, int, int, FILE *, int, int);
d194 2
a195 2
static int	 stone(int *, int, int *, int *);
static int	 readhash(FILE *);
d200 1
a200 1
static int tflag, Tflag;
a202 6
int diff_aflag = 0;
int diff_bflag = 0;
int diff_dflag = 0;
int diff_iflag = 0;
int diff_pflag = 0;
int diff_wflag = 0;
d298 2
a299 1
cvs_diffreg(const char *file1, const char *file2, int _fd1, int _fd2, BUF *out)
d312 4
a315 1
	chrtran = (diff_iflag ? cup2low : clow2low);
d365 2
a366 1
	if (!asciifile(f1) || !asciifile(f2)) {
d371 2
a372 2
	prepare(0, f1, stb1.st_size);
	prepare(1, f2, stb2.st_size);
d390 1
a390 1
	i = stone(class, slen[0], member, klist);
d401 2
a402 2
	check(f1, f2);
	output(f1, f2);
a410 1

d446 1
a446 1
prepare(int i, FILE *fd, off_t filesize)
d459 1
a459 1
	for (j = 0; (h = readhash(fd));) {
d539 1
a539 1
stone(int *a, int n, int *b, int *c)
d546 2
a547 1
	const u_int bound = diff_dflag ? UINT_MAX : MAX(256, (u_int)isqrt(n));
d643 1
a643 1
check(FILE *f1, FILE *f2)
d663 1
a663 1
		if (diff_bflag == 1 || diff_wflag == 1 || diff_iflag == 1) {
d671 1
a671 1
				if ((diff_bflag == 1 || diff_wflag == 1) &&
d678 2
a679 1
				if (diff_bflag == 1 && isspace(c) && isspace(d)) {
d690 1
a690 1
				} else if (diff_wflag == 1) {
d798 1
a798 1
output(FILE *f1, FILE *f2)
d816 1
a816 1
		change(f1, f2, i0, i1, j0, j1);
d819 1
a819 1
		change(f1, f2, 1, 0, 1, len[1]);
d831 1
a831 1
			dump_context_vec(f1, f2);
d833 1
a833 1
			dump_unified_vec(f1, f2);
d963 1
a963 1
change(FILE *f1, FILE *f2, int a, int b, int c, int d)
d1025 1
a1025 1
				dump_context_vec(f1, f2);
d1027 1
a1027 1
				dump_unified_vec(f1, f2);
d1060 1
a1060 1
		fetch(ixold, a, b, f1, '<', 1);
d1064 1
a1064 1
	fetch(ixnew, c, d, f2, diff_format == D_NORMAL ? '>' : '\0', 0);
d1072 1
a1072 1
fetch(long *f, int a, int b, FILE *lb, int ch, int oldfile)
d1125 1
a1125 1
			if (c == '\t' && tflag == 1) {
d1141 1
a1141 1
readhash(FILE *f)
d1148 2
a1149 2
	if (diff_bflag != 1 && diff_wflag != 1) {
		if (diff_iflag == 1)
d1178 1
a1178 1
				if (space != 0 && diff_wflag != 1) {
d1208 1
a1208 1
	if (diff_aflag == 1 || f == NULL)
d1270 1
a1270 1
dump_context_vec(FILE *f1, FILE *f2)
d1287 1
a1287 1
	if (diff_pflag == 1) {
d1323 1
a1323 1
				fetch(ixold, lowa, b, f1, ' ', 0);
d1325 1
a1325 1
				fetch(ixold, lowa, a - 1, f1, ' ', 0);
d1327 1
a1327 1
				    ch == 'c' ? '!' : '-', 0);
d1332 1
a1332 1
		fetch(ixold, b + 1, upb, f1, ' ', 0);
d1359 1
a1359 1
				fetch(ixnew, lowc, d, f2, ' ', 0);
d1361 1
a1361 1
				fetch(ixnew, lowc, c - 1, f2, ' ', 0);
d1363 1
a1363 1
				    ch == 'c' ? '!' : '+', 0);
d1368 1
a1368 1
		fetch(ixnew, d + 1, upd, f2, ' ', 0);
d1375 1
a1375 1
dump_unified_vec(FILE *f1, FILE *f2)
d1396 1
a1396 1
	if (diff_pflag == 1) {
d1427 3
a1429 3
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
			fetch(ixnew, c, d, f2, '+', 0);
d1432 2
a1433 2
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
d1436 2
a1437 2
			fetch(ixnew, lowc, c - 1, f2, ' ', 0);
			fetch(ixnew, c, d, f2, '+', 0);
d1443 1
a1443 1
	fetch(ixnew, d + 1, upd, f2, ' ', 0);
@


1.25
log
@Removed bogus var definition.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.24 2008/06/11 02:19:13 tobias Exp $	*/
d200 1
a200 1
static int aflag, bflag, dflag, tflag, Tflag, wflag;
d203 3
d208 1
d548 1
a548 1
	const u_int bound = dflag ? UINT_MAX : MAX(256, (u_int)isqrt(n));
d664 1
a664 1
		if (bflag == 1 || wflag == 1 || diff_iflag == 1) {
d672 1
a672 1
				if ((bflag == 1 || wflag == 1) &&
d679 1
a679 1
				if (bflag == 1 && isspace(c) && isspace(d)) {
d690 1
a690 1
				} else if (wflag == 1) {
d1148 1
a1148 1
	if (bflag != 1 && wflag != 1) {
d1178 1
a1178 1
				if (space != 0 && wflag != 1) {
d1208 1
a1208 1
	if (aflag == 1 || f == NULL)
@


1.24
log
@Avoid possible NULL pointer dereferences by using reentrant versions
of time functions.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.23 2008/06/10 05:01:36 tobias Exp $	*/
a923 7
	if (diff_rev1 != NULL) {
		localtime_r(&stb1.st_mtime, &t);
	} else {
		time(&curr_time);
		localtime_r(&curr_time, &t);
	}

d932 1
@


1.23
log
@We have a cvs_buf_puts implementation now, also use cvs_buf_putc instead
of cvs_buf_append where appropiate.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.22 2008/05/30 11:06:17 tobias Exp $	*/
d76 1
d882 1
a882 1
	struct tm *t;
d886 1
a886 1
		t = gmtime(&stb1.st_mtime);
d889 1
a889 1
		t = localtime(&curr_time);
d892 1
a892 1
	(void)strftime(buf, sizeof(buf), "%b %G %H:%M:%S -0000", t);
d894 1
a894 1
	    "***" : "---", diff_file1, t->tm_mday, buf);
d903 1
a903 1
	t = gmtime(&stb2.st_mtime);
d905 1
a905 1
	(void)strftime(buf, sizeof(buf), "%b %G %H:%M:%S -0000", t);
d907 1
a907 1
	    "---" : "+++", diff_file2, t->tm_mday, buf);
d921 1
a921 1
	struct tm *t;
d925 1
a925 1
		t = localtime(&stb1.st_mtime);
d928 1
a928 1
		t = localtime(&curr_time);
d935 1
a935 1
		t = gmtime(&stb1.st_atime);
d941 1
a941 1
	(void)strftime(buf, sizeof(buf), "%a %b %e %H:%M:%S %G", t);
d945 1
a945 1
		t = localtime(&stb2.st_mtime);
d948 1
a948 1
		t = localtime(&curr_time);
d951 1
a951 1
	(void)strftime(buf, sizeof(buf), "%a %b %e %H:%M:%S %G", t);
@


1.22
log
@diff -D support, also a change in diff_internals to properly print
file name or /dev/null, if file has been removed or added.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.21 2008/04/24 19:13:56 tobias Exp $	*/
d1462 1
a1462 1
		cvs_buf_append(diffbuf, str, strlen(str));
@


1.21
log
@Use a fixed string in case of vasprintf() error instead of relying on
strerror().  Although our vasprintf() sets errno, we cannot rely on it on
other systems.

ok ray (who spotted this issue), xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.20 2008/03/08 11:53:36 joris Exp $	*/
d204 2
a205 1
char *diff_file = NULL;
d304 2
d893 1
a893 1
	    "***" : "---", diff_file, t->tm_mday, buf);
d906 1
a906 1
	    "---" : "+++", diff_file, t->tm_mday, buf);
d937 1
a937 1
		diff_output("%s:%s", diff_file, buf);
d953 1
a953 1
	    diff_file, buf);
@


1.20
log
@correct usage of lseek(2);
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.19 2008/02/27 22:34:04 joris Exp $	*/
d1457 1
a1457 1
		fatal("diff_output: %s", strerror(errno));
@


1.19
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.18 2008/02/03 18:59:44 tobias Exp $	*/
d321 1
a321 1
	if (lseek(fd1, SEEK_SET, 0) < 0)
d330 1
a330 1
	if (lseek(fd2, SEEK_SET, 0) < 0)
@


1.18
log
@Diff header complies to GNU cvs now.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.17 2008/02/03 18:18:44 tobias Exp $	*/
d298 1
a298 1
cvs_diffreg(const char *file1, const char *file2, BUF *out)
d301 1
a301 1
	int i, rval;
d313 12
a324 1
	f1 = fopen(file1, "r");
d330 4
a333 1
	f2 = fopen(file2, "r");
d339 1
a339 1
	if (fstat(fileno(f1), &stb1) < 0) {
d343 2
a344 1
	if (fstat(fileno(f2), &stb2) < 0) {
d404 1
@


1.17
log
@Added rdiff support.  In order to do this, some output and option fixes
had to be done for diff, too.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.16 2008/01/31 20:11:28 tobias Exp $	*/
d872 3
a874 3
	(void)strftime(buf, sizeof(buf), "%d %b %G %H:%M:%S -0000", t);
	diff_output("%s %s	%s", diff_format == D_CONTEXT ? "***" : "---",
	    diff_file, buf);
d883 1
a883 6
	if (diff_rev2 != NULL)
		t = gmtime(&stb2.st_mtime);
	else {
		time(&curr_time);
		t = localtime(&curr_time);
	}
d885 3
a887 3
	(void)strftime(buf, sizeof(buf), "%d %b %G %H:%M:%S -0000", t);
	diff_output("%s %s	%s", diff_format == D_CONTEXT ? "---" : "+++",
	    diff_file, buf);
@


1.16
log
@vasprintf requires stdio.h
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.15 2007/09/22 15:38:30 joris Exp $	*/
d182 2
d199 1
a199 1
static int aflag, bflag, dflag, iflag, tflag, Tflag, wflag;
d202 1
d309 1
a309 1
	chrtran = (iflag ? cup2low : clow2low);
d640 1
a640 1
		if (bflag == 1 || wflag == 1 || iflag == 1) {
d858 84
a952 2
	char buf[64];
	struct tm *t;
d999 4
a1002 27
			t = localtime(&stb1.st_mtime);
			(void)strftime(buf, sizeof(buf),
			    "%d %b %G %H:%M:%S", t);

			diff_output("%s %s	%s",
			    diff_format == D_CONTEXT ? "***" : "---", diff_file,
			    buf);

			if (diff_rev1 != NULL) {
				rcsnum_tostr(diff_rev1, buf, sizeof(buf));
				diff_output("\t%s", buf);
			}

			diff_output("\n");

			t = localtime(&stb2.st_mtime);
			(void)strftime(buf, sizeof(buf),
			    "%d %b %G %H:%M:%S", t);

			diff_output("%s %s	%s",
			    diff_format == D_CONTEXT ? "---" : "+++", diff_file,
			    buf);

			if (diff_rev2 != NULL) {
				rcsnum_tostr(diff_rev2, buf, sizeof(buf));
				diff_output("\t%s", buf);
			}
a1003 1
			diff_output("\n");
d1136 1
a1136 1
		if (iflag == 1)
@


1.15
log
@fix error message output, it caused diffs to be formed incorrectly
when no newline was present.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.14 2007/06/29 05:04:40 ray Exp $	*/
d74 1
@


1.14
log
@Sync cvs/rcs diff code.

OK joris and xsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.13 2007/05/30 03:30:21 ray Exp $	*/
d1047 1
a1047 1
					    "file");
@


1.13
log
@Remove cand structure (but not its definition).
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.12 2007/05/30 03:24:54 ray Exp $	*/
d66 18
a146 13
#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <regex.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "diff.h"

d176 1
a176 1
static int	 prepare(int, FILE *, off_t);
d214 1
a214 1
static int   diff_len[2];
d234 1
d329 1
d344 4
a347 4
	if (prepare(0, f1, stb1.st_size) < 0 ||
	    prepare(1, f2, stb2.st_size) < 0) {
		goto closem;
	}
d364 1
a364 4

	if ((i = stone(class, slen[0], member, klist)) < 0)
		goto closem;

d368 1
a368 1
	J = xrealloc(J, diff_len[0] + 2, sizeof(*J));
d373 2
a374 3
	ixold = xrealloc(ixold, diff_len[0] + 2, sizeof(*ixold));

	ixnew = xrealloc(ixnew, diff_len[1] + 2, sizeof(*ixnew));
d379 1
a379 1
	if (anychange == 1) {
d419 1
a419 1
static int
d434 1
a434 1
		if (j == (int)sz) {
d440 1
a440 1
	diff_len[i] = j;
a441 2

	return (0);
d449 1
a449 1
	for (pref = 0; pref < diff_len[0] && pref < diff_len[1] &&
d453 2
a454 4
	for (suff = 0;
	    (suff < diff_len[0] - pref) && (suff < diff_len[1] - pref) &&
	    (file[0][diff_len[0] - suff].value ==
	    file[1][diff_len[1] - suff].value);
d459 1
a459 1
		slen[j] = diff_len[j] - pref - suff;
d507 1
a507 1
	} while (x - y > 1 || x - y < -1);
a514 1
	int ret;
d523 1
a523 3
	if ((ret = newcand(0, 0, 0)) < 0)
		return (-1);
	c[0] = ret;
d542 1
a542 3
				if ((ret = newcand(i, y, oldc)) < 0)
					return (-1);
				c[l] = ret;
d547 1
a547 3
				if ((ret = newcand(i, y, oldc)) < 0)
					return (-1);
				c[l] = ret;
d602 1
a602 1
	for (i = 0; i <= diff_len[0]; i++)
d604 1
a604 1
		    i > diff_len[0] - suff ? i + diff_len[1] - diff_len[0] : 0;
d627 1
a627 1
	for (i = 1; i <= diff_len[0]; i++) {
d642 1
a642 1
				 * in one file if bflag || wflag.
d705 1
a705 1
	for (; j <= diff_len[1]; j++)
d708 2
a709 2
	 * if (jackpot != 0)
	 *	cvs_printf("jackpot\n");
d776 1
a776 1
	m = diff_len[0];
d778 1
a778 1
	J[m + 1] = diff_len[1] + 1;
d791 1
a791 1
		change(f1, f2, 1, 0, 1, diff_len[1]);
a863 1
	int i;
d867 1
d1096 3
d1130 1
a1130 1
	char buf[BUFSIZ];
d1146 1
a1146 1
static char*
d1178 1
a1178 1
					strlcpy(lastbuf, (const char *)buf,
d1190 1
a1190 1
	return (lastmatchline > 0) ? lastbuf : NULL;
a1192 1

d1207 1
a1207 1
	upb = MIN(diff_len[0], context_vec_ptr->b + context);
d1209 1
a1209 1
	upd = MIN(diff_len[1], context_vec_ptr->d + context);
d1213 1
a1213 1
		f = match_function(ixold, lowa - 1, f1);
d1235 1
a1235 1
	if (do_output != 0) {
d1271 1
a1271 1
	if (do_output != 0) {
d1312 1
a1312 1
	upb = MIN(diff_len[0], context_vec_ptr->b + context);
d1314 1
a1314 1
	upd = MIN(diff_len[1], context_vec_ptr->d + context);
d1322 1
a1322 1
		f = match_function(ixold, lowa - 1, f1);
@


1.12
log
@Remove unused struct diff_arg.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.11 2007/05/30 02:21:20 ray Exp $	*/
d146 1
a146 1
} cand;
@


1.11
log
@Sync rcsdiff -> cvs diff

Surprisingly, rcsdiff has nicer code than cvs diff.  Changes:
1. Include sys/param.h because we are using MIN/MAX... not sure why
   it hasn't complained in the past.
2. Use fstat instead of stat.
3. Remove useless casts and __inline.
4. Plug a memory leak.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.10 2007/05/29 08:02:59 ray Exp $	*/
a162 7
};

struct diff_arg {
	char	*rev1;
	char	*rev2;
	char	*date1;
	char	*date2;
@


1.10
log
@Get rid of another useless variable, another difference between our
diff code and diff(1).

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.9 2007/05/29 00:19:10 ray Exp $	*/
d129 1
d322 1
a322 1
	if (stat(file1, &stb1) < 0) {
d326 1
a326 1
	if (stat(file2, &stb2) < 0) {
d409 2
a410 2
		i = fread(buf1, (size_t)1, sizeof(buf1), f1);
		j = fread(buf2, (size_t)1, sizeof(buf2), f2);
d432 1
a432 1
	sz = ((size_t)filesize <= SIZE_MAX ? (size_t)filesize : SIZE_MAX) / 25;
d824 1
a824 1
static __inline void
d832 1
a832 1
static __inline void
d852 1
d864 1
a864 1
	ret = regexec(&ignore_re, line, (size_t)0, NULL, 0);
d928 1
a928 1
			t = localtime(&stb1.st_mtime); 
d1149 1
a1149 1
	cnt = fread(buf, (size_t)1, sizeof(buf), f);
d1173 1
a1173 1
		nc = fread(buf, (size_t)1, nc, fp);
@


1.9
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.8 2007/05/28 23:02:40 ray Exp $	*/
a573 1
	int newclistlen;
d576 2
a577 3
		newclistlen = clistlen * 11 / 10;
		clist = xrealloc(clist, newclistlen, sizeof(*clist));
		clistlen = newclistlen;
@


1.8
log
@Some spacing syncs with diff(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.7 2007/05/28 22:12:44 ray Exp $	*/
a297 1
	void *tmp;
d353 1
a353 2
	tmp = xrealloc(member, slen[1] + 2, sizeof(*member));
	member = tmp;
d357 1
a357 2
	tmp = xrealloc(class, slen[0] + 2, sizeof(*class));
	class = tmp;
d370 1
a370 2
	tmp = xrealloc(J, diff_len[0] + 2, sizeof(*J));
	J = tmp;
d375 1
a375 2
	tmp = xrealloc(ixold, diff_len[0] + 2, sizeof(*ixold));
	ixold = tmp;
d377 1
a377 2
	tmp = xrealloc(ixnew, diff_len[1] + 2, sizeof(*ixnew));
	ixnew = tmp;
a424 1
	void *tmp;
d439 1
a439 2
			tmp = xrealloc(p, sz + 3, sizeof(*p));
			p = tmp;
d573 1
a573 1
	struct cand *q, *tmp;
d578 1
a578 2
		tmp = xrealloc(clist, newclistlen, sizeof(*clist));
		clist = tmp;
a916 1
			struct context_vec *tmp;
d919 2
a920 3
			tmp = xrealloc(context_vec_start, max_context,
			    sizeof(*context_vec_start));
			context_vec_start = tmp;
@


1.7
log
@"in formation" -> "information"

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.6 2007/05/28 22:07:40 ray Exp $	*/
d231 2
a232 2
static int  lastline;
static int  lastmatchline;
@


1.6
log
@Line up comments with the rest of the file, like in diff(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.5 2007/03/27 07:21:21 xsa Exp $	*/
d153 1
a153 1
 * The following struct is used to record change in formation when
@


1.5
log
@sync with espie@@'s latest change to diff(1).

from src/usr.bin/diff/diffreg.c rev 1.67:

improve -p for C++ code: classes definition often have
public:/protected:/private: at the start of line.
This lets the -p scanner just take note of the section and keep
looking for the actual class definition.

Also increase function name bufsize so it shows most of these pesky C++
decls...

OK niallo@@ espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.4 2007/02/22 06:42:09 otto Exp $	*/
d158 4
a161 4
	int	a;	/* start line in old file */
	int	b;	/* end line in old file */
	int	c;	/* start line in new file */
	int	d;	/* end line in new file */
@


1.4
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.3 2006/07/07 17:37:17 joris Exp $	*/
d229 1
a229 1
#define FUNCTION_CONTEXT_SIZE	41
d1167 2
d1176 1
d1191 18
a1208 4
				strlcpy(lastbuf, (const char *)buf,
				    sizeof lastbuf);
				lastmatchline = pos;
				return lastbuf;
@


1.3
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.2 2006/05/31 22:24:12 joris Exp $	*/
d129 8
a136 1
#include "includes.h"
a137 1
#include "buf.h"
a139 3
#include "log.h"

#include "xmalloc.h"
@


1.2
log
@support -p flag for diff, makes dlg@@ feel all warm
and fuzzie inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff_internals.c,v 1.1 2006/05/27 03:30:30 joris Exp $	*/
d949 1
a949 1
			printf("\n");
d964 1
a964 1
			printf("\n");
@


1.1
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.90 2006/04/14 23:29:01 joris Exp $	*/
d194 1
a194 1
static int aflag, bflag, dflag, iflag, pflag, tflag, Tflag, wflag;
d197 1
d1216 1
a1216 1
	if (pflag == 1) {
d1325 1
a1325 1
	if (pflag == 1) {
@

