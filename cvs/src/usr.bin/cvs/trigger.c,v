head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14;
locks; strict;
comment	@ * @;


1.23
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.22;
commitid	O6jeJ0TRmiewrqMI;

1.22
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2014.01.08.13.23.55;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.20.19.22.47;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.29.17.49.37;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.19.09.55.19;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.29.09.51.21;	author tobias;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.29.09.46.10;	author tobias;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.17.17.15.56;	author tobias;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.17.17.09.21;	author tobias;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.11.02.02.08;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.10.14.40.54;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.10.05.01.36;	author tobias;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.10.04.38.46;	author tobias;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.10.04.01.41;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.10.03.55.50;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.10.03.33.21;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.10.03.18.59;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.10.02.36.31;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.10.02.08.49;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.10.02.07.58;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.10.01.00.35;	author joris;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@/*	$OpenBSD: trigger.c,v 1.22 2015/01/16 06:40:07 deraadt Exp $	*/
/*
 * Copyright (c) 2008 Tobias Stoeckmann <tobias@@openbsd.org>
 * Copyright (c) 2008 Jonathan Armani <dbd@@asystant.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/types.h>

#include <ctype.h>
#include <errno.h>
#include <libgen.h>
#include <pwd.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "config.h"
#include "cvs.h"

static int	 expand_args(BUF *, struct file_info_list *, const char *,
    const char *, char *);
static int	 expand_var(BUF *, const char *);
static char	*parse_cmd(int, char *, const char *, struct file_info_list *);

static int
expand_args(BUF *buf, struct file_info_list *file_info, const char *repo,
    const char *allowed_args, char *format)
{
	int oldstyle, quote;
	struct file_info *fi = NULL;
	char *p, valbuf[2] = { '\0', '\0' };
	const char *val;

	if (file_info != NULL && !TAILQ_EMPTY(file_info))
		fi = TAILQ_FIRST(file_info);

	quote = oldstyle = 0;

	/* Why does GNU cvs print something if it encounters %{}? */
	if (*format == '\0')
		oldstyle = 1;

	for (p = format; *p != '\0'; p++) {
		if (*p != '%' && strchr(allowed_args, *p) == NULL)
			return 1;

		switch (*p) {
		case 's':
		case 'V':
		case 'v':
			quote = 1;
			oldstyle = 1;
			break;
		default:
			break;
		}
	}
	if (quote)
		buf_putc(buf, '"');
	if (oldstyle) {
		buf_puts(buf, repo);
		buf_putc(buf, ' ');
	}

	if (*format == '\0')
		return 0;

	/*
	 * check like this, add only uses loginfo for directories anyway
	 */
	if (cvs_cmdop == CVS_OP_ADD) {
		buf_puts(buf, "- New directory");
		if (quote)
			buf_putc(buf, '"');
		return (0);
	}

	if (cvs_cmdop == CVS_OP_IMPORT) {
		buf_puts(buf, "- Imported sources");
		if (quote)
			buf_putc(buf, '"');
		return (0);
	}

	for (;;) {
		for (p = format; *p != '\0';) {
			val = NULL;

			switch (*p) {
			case '%':
				val = "%";
				break;
			case 'b':
				if (fi != NULL) {
					valbuf[0] = fi->tag_type;
					val = valbuf;
				}
				break;
			case 'o':
				if (fi != NULL)
					val = fi->tag_op;
				break;
			case 'p':
				val = current_cvsroot->cr_dir;
				break;
			case 'r':
				val = repo;
				break;
			case 'l':
			case 'S':
			case 's':
				if (fi != NULL)
					val = fi->file_path;
				break;
			case 't':
				if (fi != NULL)
					val = fi->tag_new;
				break;
			case 'V':
				if (fi != NULL) {
					if (fi->crevstr != NULL &&
					    !strcmp(fi->crevstr,
					    "Non-existent"))
						val = "NONE";
					else
						val = fi->crevstr;
				}
				break;
			case 'v':
				if (fi != NULL) {
					if (fi->nrevstr != NULL &&
					    !strcmp(fi->nrevstr, "Removed"))
						val = "NONE";
					else
						val = fi->nrevstr;
				}
				break;
			default:
				return 1;
			}

			if (val != NULL)
				buf_puts(buf, val);

			if (*(++p) != '\0')
				buf_putc(buf, ',');
		}

		if (fi != NULL)
			fi = TAILQ_NEXT(fi, flist);
		if (fi == NULL)
			break;

		if (strlen(format) == 1 && (*format == '%' || *format == 'o' ||
		    *format == 'p' || *format == 'r' || *format == 't'))
			break;

		buf_putc(buf, ' ');
	}

	if (quote)
		buf_putc(buf, '"');

	return 0;
}

static int
expand_var(BUF *buf, const char *var)
{
	struct passwd *pw;
	const char *val;

	if (*var == '=') {
		if ((val = cvs_var_get(++var)) == NULL) {
			cvs_log(LP_ERR, "no such user variable ${=%s}", var);
			return (1);
		}
		buf_puts(buf, val);
	} else {
		if (strcmp(var, "CVSEDITOR") == 0 ||
		    strcmp(var, "EDITOR") == 0 ||
		    strcmp(var, "VISUAL") == 0)
			buf_puts(buf, cvs_editor);
		else if (strcmp(var, "CVSROOT") == 0)
			buf_puts(buf, current_cvsroot->cr_dir);
		else if (strcmp(var, "USER") == 0) {
			pw = getpwuid(geteuid());
			if (pw == NULL) {
				cvs_log(LP_ERR, "unable to retrieve "
				    "caller ID");
				return (1);
			}
			buf_puts(buf, pw->pw_name);
		} else if (strcmp(var, "RCSBIN") == 0) {
			cvs_log(LP_ERR, "RCSBIN internal variable is no "
			    "longer supported");
			return (1);
		} else {
			cvs_log(LP_ERR, "no such internal variable $%s", var);
			return (1);
		}
	}

	return (0);
}

static char *
parse_cmd(int type, char *cmd, const char *repo,
    struct file_info_list *file_info)
{
	int expanded = 0;
	char argbuf[2] = { '\0', '\0' };
	char *allowed_args, *default_args, *args, *file, *p, *q = NULL;
	size_t pos;
	BUF *buf;

	switch (type) {
	case CVS_TRIGGER_COMMITINFO:
		allowed_args = "prsS{}";
		default_args = " %p/%r %S";
		file = CVS_PATH_COMMITINFO;
		break;
	case CVS_TRIGGER_LOGINFO:
		allowed_args = "prsSvVt{}";
		default_args = NULL;
		file = CVS_PATH_LOGINFO;
		break;
	case CVS_TRIGGER_VERIFYMSG:
		allowed_args = "l";
		default_args = " %l";
		file = CVS_PATH_VERIFYMSG;
		break;
	case CVS_TRIGGER_TAGINFO:
		allowed_args = "btoprsSvV{}";
		default_args = " %t %o %p/%r %{sv}";
		file = CVS_PATH_TAGINFO;
		break;
	default:
		return (NULL);
	}

	/* before doing any stuff, check if the command starts with % */
	for (p = cmd;
	     *p != '%' && !isspace((unsigned char)*p) && *p != '\0'; p++)
		;
	if (*p == '%')
		return (NULL);

	buf = buf_alloc(1024);

	p = cmd;
again:
	for (; *p != '\0'; p++) {
		if ((pos = strcspn(p, "$%")) != 0) {
			buf_append(buf, p, pos);
			p += pos;
		}

		q = NULL;
		if (*p == '\0')
			break;
		if (*p++ == '$') {
			if (*p == '{') {
				pos = strcspn(++p, "}");
				if (p[pos] == '\0')
					goto bad;
			} else {
				for (pos = 0; isalpha(p[pos]); pos++)
					;
				if (pos == 0) {
					cvs_log(LP_ERR,
					    "unrecognized variable syntax");
					goto bad;
				}
			}
			q = xmalloc(pos + 1);
			memcpy(q, p, pos);
			q[pos] = '\0';
			if (expand_var(buf, q))
				goto bad;
			p += pos - (*(p - 1) == '{' ? 0 : 1);
		} else {
			switch (*p) {
			case '\0':
				goto bad;
			case '{':
				if (strchr(allowed_args, '{') == NULL)
					goto bad;
				pos = strcspn(++p, "}");
				if (p[pos] == '\0')
					goto bad;
				q = xmalloc(pos + 1);
				memcpy(q, p, pos);
				q[pos] = '\0';
				args = q;
				p += pos;
				break;
			default:
				argbuf[0] = *p;
				args = argbuf;
				break;
			}
	
			if (expand_args(buf, file_info, repo, allowed_args,
			    args))
				goto bad;
			expanded = 1;
		}

		free(q);
	}

	if (!expanded && default_args != NULL) {
		p = default_args;
		expanded = 1;
		goto again;
	}

	buf_putc(buf, '\0');
	return (buf_release(buf));

bad:
	free(q);
	cvs_log(LP_NOTICE, "%s contains malformed command '%s'", file, cmd);
	buf_free(buf);
	return (NULL);
}

int
cvs_trigger_handle(int type, char *repo, char *in, struct trigger_list *list,
    struct file_info_list *files)
{
	int r;
	char *cmd;
	struct trigger_line *line;

	TAILQ_FOREACH(line, list, flist) {
		if ((cmd = parse_cmd(type, line->line, repo, files)) == NULL)
			return (1);
		switch(type) {
		case CVS_TRIGGER_COMMITINFO:
		case CVS_TRIGGER_TAGINFO:
		case CVS_TRIGGER_VERIFYMSG:
			if ((r = cvs_exec(cmd, NULL, 1)) != 0) {
				free(cmd);
				return (r);
			}
			break;
		default:
			(void)cvs_exec(cmd, in, 1);
			break;
		}
		free(cmd);
	}

	return (0);
}

struct trigger_list *
cvs_trigger_getlines(char * file, char * repo)
{
	FILE *fp;
	int allow_all, lineno, match = 0;
	size_t len;
	regex_t preg;
	struct trigger_list *list;
	struct trigger_line *tline;
	char fpath[PATH_MAX];
	char *currentline, *defaultline = NULL, *nline, *p, *q, *regex;

	if (strcmp(file, CVS_PATH_EDITINFO) == 0 ||
	    strcmp(file, CVS_PATH_VERIFYMSG) == 0)
		allow_all = 0;
	else
		allow_all = 1;

	(void)xsnprintf(fpath, PATH_MAX, "%s/%s", current_cvsroot->cr_dir,
	    file);

	if ((fp = fopen(fpath, "r")) == NULL) {
		if (errno != ENOENT)
			cvs_log(LP_ERRNO, "cvs_trigger_getlines: %s", file);
		return (NULL);
	}

	list = xmalloc(sizeof(*list));
	TAILQ_INIT(list);
	
	lineno = 0;
	nline = NULL;
	while ((currentline = fgetln(fp, &len)) != NULL) {
		if (currentline[len - 1] == '\n') {
			currentline[len - 1] = '\0';
		} else {
			nline = xmalloc(len + 1);
			memcpy(nline, currentline, len);
			nline[len] = '\0';
			currentline = nline;
		}

		lineno++;

		for (p = currentline; isspace((unsigned char)*p); p++)
			;

		if (*p == '\0' || *p == '#')
			continue;

		for (q = p; !isspace((unsigned char)*q) && *q != '\0'; q++)
			;

		if (*q == '\0')
			goto bad;

		*q++ = '\0';
		regex = p;

		for (; isspace((unsigned char)*q); q++)
			;

		if (*q == '\0')
			goto bad;

		if (strcmp(regex, "ALL") == 0 && allow_all) {
			tline = xmalloc(sizeof(*tline));
			tline->line = xstrdup(q);
			TAILQ_INSERT_TAIL(list, tline, flist);
		} else if (defaultline == NULL && !match &&
		    strcmp(regex, "DEFAULT") == 0) {
			defaultline = xstrdup(q);
		} else if (!match) {
			if (regcomp(&preg, regex, REG_NOSUB|REG_EXTENDED))
				goto bad;

			if (regexec(&preg, repo, 0, NULL, 0) != REG_NOMATCH) {
				match = 1;

				tline = xmalloc(sizeof(*tline));
				tline->line = xstrdup(q);
				TAILQ_INSERT_HEAD(list, tline, flist);
			}
			regfree(&preg);
		}
	}

	free(nline);

	if (defaultline != NULL) {
		if (!match) {
			tline = xmalloc(sizeof(*tline));
			tline->line = defaultline;
			TAILQ_INSERT_HEAD(list, tline, flist);
		} else
			free(defaultline);
	}

	(void)fclose(fp);
	
	if (TAILQ_EMPTY(list)) {
		free(list);
		list = NULL;
	}

	return (list);

bad:
	cvs_log(LP_NOTICE, "%s: malformed line %d", file, lineno);
	free(defaultline);
	cvs_trigger_freelist(list);

	(void)fclose(fp);
	
	return (NULL);
}

void
cvs_trigger_freelist(struct trigger_list * list)
{
	struct trigger_line *line;

	while ((line = TAILQ_FIRST(list)) != NULL) {
		TAILQ_REMOVE(list, line, flist);
		free(line->line);
		free(line);
	}

	free(list);
}

void
cvs_trigger_freeinfo(struct file_info_list * list)
{
	struct file_info * fi;

	while ((fi = TAILQ_FIRST(list)) != NULL) {
		TAILQ_REMOVE(list, fi, flist);

		free(fi->file_path);
		free(fi->file_wd);
		free(fi->crevstr);
		free(fi->nrevstr);
		free(fi->tag_new);
		free(fi->tag_old);
		free(fi);
	}
}

void
cvs_trigger_loginfo_header(BUF *buf, char *repo)
{
	char *dir, pwd[PATH_MAX];
	char hostname[HOST_NAME_MAX+1];

	if (gethostname(hostname, sizeof(hostname)) == -1) {
		fatal("cvs_trigger_loginfo_header: gethostname failed %s",
		    strerror(errno));
	}

	if (getcwd(pwd, sizeof(pwd)) == NULL)
		fatal("cvs_trigger_loginfo_header: Cannot get working "
		    "directory");

	if ((dir = dirname(pwd)) == NULL) {
		fatal("cvs_trigger_loginfo_header: dirname failed %s",
		    strerror(errno));
	}

	buf_puts(buf, "Update of ");
	buf_puts(buf, current_cvsroot->cr_dir);
	buf_putc(buf, '/');
	buf_puts(buf, repo);
	buf_putc(buf, '\n');

	buf_puts(buf, "In directory ");
	buf_puts(buf, hostname);
	buf_puts(buf, ":");
	buf_puts(buf, dir);
	buf_putc(buf, '/');
	buf_puts(buf, repo);
	buf_putc(buf, '\n');
	buf_putc(buf, '\n');
}

@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.21 2014/01/08 13:23:55 okan Exp $	*/
d325 1
a325 2
		if (q != NULL)
			xfree(q);
d338 1
a338 2
	if (q != NULL)
		xfree(q);
d360 1
a360 1
				xfree(cmd);
d368 1
a368 1
		xfree(cmd);
d461 1
a461 2
	if (nline != NULL)
		xfree(nline);
d469 1
a469 1
			xfree(defaultline);
d475 1
a475 1
		xfree(list);
d483 1
a483 3

	if (defaultline != NULL)
		xfree(defaultline);
d498 2
a499 2
		xfree(line->line);
		xfree(line);
d502 1
a502 1
	xfree(list);
d513 7
a519 14
		if (fi->file_path != NULL)
			xfree(fi->file_path);
		if (fi->file_wd != NULL)
			xfree(fi->file_wd);
		if (fi->crevstr != NULL)
			xfree(fi->crevstr);
		if (fi->nrevstr != NULL)
			xfree(fi->nrevstr);
		if (fi->tag_new != NULL)
			xfree(fi->tag_new);
		if (fi->tag_old != NULL)
			xfree(fi->tag_old);

		xfree(fi);
@


1.21
log
@unsigned char for ctype. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.20 2011/05/20 19:22:47 nicm Exp $	*/
d385 1
a385 1
	char fpath[MAXPATHLEN];
d394 1
a394 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", current_cvsroot->cr_dir,
d538 2
a539 2
	char *dir, pwd[MAXPATHLEN];
	char hostname[MAXHOSTNAMELEN];
@


1.20
log
@Remove a silly XXX for a bit of code that is only used once - no value
in making it a function. From Michael W Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.19 2010/10/29 17:49:37 nicm Exp $	*/
d258 2
a259 1
	for (p = cmd; *p != '%' && !isspace(*p) && *p != '\0'; p++)
d420 1
a420 1
		for (p = currentline; isspace(*p); p++)
d426 1
a426 1
		for (q = p; !isspace(*q) && *q != '\0'; q++)
d435 1
a435 1
		for (; isspace(*q); q++)
@


1.19
log
@Nuke some unused variables and remove an unnecessary call to dirname().

From Michael W Bombardieri via ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.18 2010/07/23 21:46:05 ray Exp $	*/
a256 1
	/* XXX move this out of this function */
@


1.18
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.17 2009/03/19 09:55:19 joris Exp $	*/
d564 1
a564 1
	buf_puts(buf, dirname(pwd));
@


1.17
log
@only pass the real $var to expand_vars() instead of the entire
line, this way commitinfo and stuff works again.

found by myself the hard way, fix by tobias@@
who's not around to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.16 2008/08/29 09:51:21 tobias Exp $	*/
d74 1
a74 1
		cvs_buf_putc(buf, '"');
d76 2
a77 2
		cvs_buf_puts(buf, repo);
		cvs_buf_putc(buf, ' ');
d87 1
a87 1
		cvs_buf_puts(buf, "- New directory");
d89 1
a89 1
			cvs_buf_putc(buf, '"');
d94 1
a94 1
		cvs_buf_puts(buf, "- Imported sources");
d96 1
a96 1
			cvs_buf_putc(buf, '"');
d158 1
a158 1
				cvs_buf_puts(buf, val);
d161 1
a161 1
				cvs_buf_putc(buf, ',');
d173 1
a173 1
		cvs_buf_putc(buf, ' ');
d177 1
a177 1
		cvs_buf_putc(buf, '"');
d193 1
a193 1
		cvs_buf_puts(buf, val);
d198 1
a198 1
			cvs_buf_puts(buf, cvs_editor);
d200 1
a200 1
			cvs_buf_puts(buf, current_cvsroot->cr_dir);
d208 1
a208 1
			cvs_buf_puts(buf, pw->pw_name);
d264 1
a264 1
	buf = cvs_buf_alloc(1024);
d270 1
a270 1
			cvs_buf_append(buf, p, pos);
d335 2
a336 2
	cvs_buf_putc(buf, '\0');
	return (cvs_buf_release(buf));
d342 1
a342 1
	cvs_buf_free(buf);
d555 14
a568 14
	cvs_buf_puts(buf, "Update of ");
	cvs_buf_puts(buf, current_cvsroot->cr_dir);
	cvs_buf_putc(buf, '/');
	cvs_buf_puts(buf, repo);
	cvs_buf_putc(buf, '\n');

	cvs_buf_puts(buf, "In directory ");
	cvs_buf_puts(buf, hostname);
	cvs_buf_puts(buf, ":");
	cvs_buf_puts(buf, dirname(pwd));
	cvs_buf_putc(buf, '/');
	cvs_buf_puts(buf, repo);
	cvs_buf_putc(buf, '\n');
	cvs_buf_putc(buf, '\n');
@


1.16
log
@Support for variable expansion in trigger files added.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.15 2008/08/29 09:46:10 tobias Exp $	*/
d283 3
a285 1
				if (!isalpha(*p)) {
a289 1
				pos = strcspn(p, " \t");
d296 1
a296 1
			p += pos;
@


1.15
log
@If parsing of a command in one of the trigger files fails, treat this as an
error instead of ignoring it.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.14 2008/06/17 17:15:56 tobias Exp $	*/
d25 1
d37 1
d182 40
d269 1
a269 1
		if ((pos = strcspn(p, "%")) != 0) {
d274 2
a275 1
		if (*p++ == '\0')
d277 13
a289 11

		q = NULL;
		switch (*p) {
		case '\0':
			goto bad;
		case '{':
			if (strchr(allowed_args, '{') == NULL)
				goto bad;
			pos = strcspn(++p, "}");
			if (p[pos] == '\0')
				goto bad;
d293 2
a294 1
			args = q;
d296 26
a321 5
			break;
		default:
			argbuf[0] = *p;
			args = argbuf;
			break;
a322 4

		if (expand_args(buf, file_info, repo, allowed_args, args))
			goto bad;
		expanded = 1;
@


1.14
log
@Plug memory and file descriptor leaks, diff by Jonathan Armani.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.13 2008/06/17 17:09:21 tobias Exp $	*/
d291 9
a299 14
		cmd = parse_cmd(type, line->line, repo, files);
		if (cmd != NULL) {
			switch(type) {
			case CVS_TRIGGER_COMMITINFO:
			case CVS_TRIGGER_TAGINFO:
			case CVS_TRIGGER_VERIFYMSG:
				if ((r = cvs_exec(cmd, NULL, 1)) != 0) {
					xfree(cmd);
					return r;
				}
				break;
			default:
				(void)cvs_exec(cmd, in, 1);
				break;
d301 4
a304 1
			xfree(cmd);
d306 1
d309 1
a309 1
	return 0;
@


1.13
log
@Regular expressions to match repository are allowed to have % in front.
Diff by Jonathan Armani.
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.12 2008/06/11 02:02:08 joris Exp $	*/
a324 3
	list = xmalloc(sizeof(*list));
	TAILQ_INIT(list);

d340 3
d412 2
d428 2
@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.11 2008/06/10 14:40:54 joris Exp $	*/
a366 4
			goto bad;

		/* XXX why do you check *p (regex)? */
		if (*p == '%')
@


1.11
log
@files that have been removed should be passing "NONE" to scripts
as their new revision, so they can be picked up as being removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.10 2008/06/10 05:01:36 tobias Exp $	*/
d117 1
a117 1
		    		val = current_cvsroot->cr_dir;
@


1.10
log
@We have a cvs_buf_puts implementation now, also use cvs_buf_putc instead
of cvs_buf_append where appropiate.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.9 2008/06/10 04:38:46 tobias Exp $	*/
d125 2
a126 7
				if (fi != NULL) {
					val = basename(fi->file_path);
					if (val == NULL) {
						fatal("basename: %s",
						    strerror(errno));
					}
				}
d143 7
a149 2
				if (fi != NULL)
					val = fi->nrevstr;
@


1.9
log
@If we encounter an error during expanding line of a trigger file, print an
actually useful error message.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.8 2008/06/10 04:01:41 joris Exp $	*/
d74 1
a74 1
		cvs_buf_append(buf, repo, strlen(repo));
d85 1
a85 2
		cvs_buf_append(buf, "- New directory",
		    strlen("- New directory"));
d92 1
a92 2
		cvs_buf_append(buf, "- Imported sources",
		    strlen("- Imported sources"));
d156 1
a156 1
				cvs_buf_append(buf, val, strlen(val));
@


1.8
log
@append "- Imported sources" for imports.
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.7 2008/06/10 03:55:50 joris Exp $	*/
d188 1
a188 1
	char *allowed_args, *default_args, *args, *p, *q = NULL;
d196 1
d201 1
d206 1
d211 1
a241 1
			/* XXX do we realy have to check for { in there? */
d279 1
a279 1
	cvs_log(LP_NOTICE, "CVSROOT: malformed line %s", cmd);
@


1.7
log
@newly added directories need "- New directory" to be passed to the
loginfo script.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.6 2008/06/10 03:33:21 joris Exp $	*/
d87 8
@


1.6
log
@pass the basename(3) for file_path to the script, so we do not get
weird double modules names in the logs;
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.5 2008/06/10 03:18:59 joris Exp $	*/
d81 11
d133 2
a134 1
					if (!strcmp(fi->crevstr,
@


1.5
log
@newly added files should pass "NONE" for their initial revision, unbreaks
more scripts that depend on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.4 2008/06/10 02:36:31 joris Exp $	*/
d108 7
a114 2
				if (fi != NULL)
					val = fi->file_path;
@


1.4
log
@loginfo allows 't' as well - unbreaks certain loginfo scripts.
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.3 2008/06/10 02:08:49 joris Exp $	*/
d116 7
a122 2
				if (fi != NULL)
					val = fi->crevstr;
@


1.3
log
@missing header
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.2 2008/06/10 02:07:58 joris Exp $	*/
d168 1
a168 1
		allowed_args = "prsSvV{}";
@


1.2
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: trigger.c,v 1.1 2008/06/10 01:00:35 joris Exp $	*/
d24 1
@


1.1
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d313 1
a313 2
	while ((currentline = fgetln(fp, &len)) != NULL)
	{
d371 1
@

