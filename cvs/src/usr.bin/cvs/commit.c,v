head	1.158;
access;
symbols
	OPENBSD_6_1:1.155.0.4
	OPENBSD_6_1_BASE:1.155
	OPENBSD_6_0:1.154.0.4
	OPENBSD_6_0_BASE:1.154
	OPENBSD_5_9:1.154.0.2
	OPENBSD_5_9_BASE:1.154
	OPENBSD_5_8:1.153.0.6
	OPENBSD_5_8_BASE:1.153
	OPENBSD_5_7:1.153.0.2
	OPENBSD_5_7_BASE:1.153
	OPENBSD_5_6:1.152.0.14
	OPENBSD_5_6_BASE:1.152
	OPENBSD_5_5:1.152.0.12
	OPENBSD_5_5_BASE:1.152
	OPENBSD_5_4:1.152.0.8
	OPENBSD_5_4_BASE:1.152
	OPENBSD_5_3:1.152.0.6
	OPENBSD_5_3_BASE:1.152
	OPENBSD_5_2:1.152.0.4
	OPENBSD_5_2_BASE:1.152
	OPENBSD_5_1_BASE:1.152
	OPENBSD_5_1:1.152.0.2
	OPENBSD_5_0:1.151.0.2
	OPENBSD_5_0_BASE:1.151
	OPENBSD_4_9:1.150.0.4
	OPENBSD_4_9_BASE:1.150
	OPENBSD_4_8:1.150.0.2
	OPENBSD_4_8_BASE:1.150
	OPENBSD_4_7:1.149.0.2
	OPENBSD_4_7_BASE:1.149
	OPENBSD_4_6:1.149.0.4
	OPENBSD_4_6_BASE:1.149
	OPENBSD_4_5:1.145.0.2
	OPENBSD_4_5_BASE:1.145
	OPENBSD_4_4:1.144.0.2
	OPENBSD_4_4_BASE:1.144
	OPENBSD_4_3:1.131.0.2
	OPENBSD_4_3_BASE:1.131
	OPENBSD_4_2:1.108.0.2
	OPENBSD_4_2_BASE:1.108
	OPENBSD_4_1:1.105.0.2
	OPENBSD_4_1_BASE:1.105
	OPENBSD_4_0:1.81.0.2
	OPENBSD_4_0_BASE:1.81
	OPENBSD_3_9:1.51.0.2
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.0.1;
locks; strict;
comment	@ * @;


1.158
date	2017.06.01.08.08.24;	author joris;	state Exp;
branches;
next	1.157;
commitid	oZyV6E3g0wglnhaw;

1.157
date	2017.05.31.16.48.16;	author joris;	state Exp;
branches;
next	1.156;
commitid	pVPQZ9XIzwXbnOW0;

1.156
date	2017.05.28.17.01.10;	author joris;	state Exp;
branches;
next	1.155;
commitid	BXD7mqz9v7B5WbdB;

1.155
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.154;
commitid	8Vv7d4HkmCtExfc6;

1.154
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.153;
commitid	O6jeJ0TRmiewrqMI;

1.153
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.152;
commitid	Uu5nFG3wCl0LACBb;

1.152
date	2011.12.27.13.59.01;	author nicm;	state Exp;
branches;
next	1.151;

1.151
date	2011.04.20.18.41.40;	author nicm;	state Exp;
branches;
next	1.150;

1.150
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.149;

1.149
date	2009.06.07.08.39.13;	author ray;	state Exp;
branches;
next	1.148;

1.148
date	2009.06.06.14.17.27;	author ray;	state Exp;
branches;
next	1.147;

1.147
date	2009.03.26.22.54.37;	author joris;	state Exp;
branches;
next	1.146;

1.146
date	2009.03.25.21.50.33;	author joris;	state Exp;
branches;
next	1.145;

1.145
date	2008.08.29.09.54.22;	author tobias;	state Exp;
branches;
next	1.144;

1.144
date	2008.07.08.12.54.13;	author joris;	state Exp;
branches;
next	1.143;

1.143
date	2008.06.15.04.38.52;	author tobias;	state Exp;
branches;
next	1.142;

1.142
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.141;

1.141
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.140;

1.140
date	2008.06.10.19.00.17;	author joris;	state Exp;
branches;
next	1.139;

1.139
date	2008.06.10.14.49.50;	author joris;	state Exp;
branches;
next	1.138;

1.138
date	2008.06.10.02.07.57;	author joris;	state Exp;
branches;
next	1.137;

1.137
date	2008.06.10.01.00.34;	author joris;	state Exp;
branches;
next	1.136;

1.136
date	2008.06.09.22.31.24;	author tobias;	state Exp;
branches;
next	1.135;

1.135
date	2008.06.08.20.08.43;	author tobias;	state Exp;
branches;
next	1.134;

1.134
date	2008.06.08.02.54.08;	author tobias;	state Exp;
branches;
next	1.133;

1.133
date	2008.05.17.21.06.44;	author tobias;	state Exp;
branches;
next	1.132;

1.132
date	2008.03.09.03.14.52;	author joris;	state Exp;
branches;
next	1.131;

1.131
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.130;

1.130
date	2008.02.20.17.29.28;	author tobias;	state Exp;
branches;
next	1.129;

1.129
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.128;

1.128
date	2008.02.10.13.07.58;	author joris;	state Exp;
branches;
next	1.127;

1.127
date	2008.02.04.22.36.40;	author joris;	state Exp;
branches;
next	1.126;

1.126
date	2008.02.04.15.07.33;	author tobias;	state Exp;
branches;
next	1.125;

1.125
date	2008.01.31.22.11.38;	author joris;	state Exp;
branches;
next	1.124;

1.124
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.123;

1.123
date	2008.01.29.11.58.59;	author tobias;	state Exp;
branches;
next	1.122;

1.122
date	2008.01.28.21.32.00;	author tobias;	state Exp;
branches;
next	1.121;

1.121
date	2008.01.28.21.26.51;	author tobias;	state Exp;
branches;
next	1.120;

1.120
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.119;

1.119
date	2008.01.13.11.15.19;	author tobias;	state Exp;
branches;
next	1.118;

1.118
date	2008.01.13.11.11.08;	author tobias;	state Exp;
branches;
next	1.117;

1.117
date	2008.01.10.09.54.04;	author tobias;	state Exp;
branches;
next	1.116;

1.116
date	2008.01.10.09.37.26;	author tobias;	state Exp;
branches;
next	1.115;

1.115
date	2007.10.08.14.13.13;	author joris;	state Exp;
branches;
next	1.114;

1.114
date	2007.10.03.13.12.06;	author joris;	state Exp;
branches;
next	1.113;

1.113
date	2007.09.24.13.56.09;	author joris;	state Exp;
branches;
next	1.112;

1.112
date	2007.09.24.13.44.20;	author joris;	state Exp;
branches;
next	1.111;

1.111
date	2007.09.23.11.19.24;	author joris;	state Exp;
branches;
next	1.110;

1.110
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.109;

1.109
date	2007.08.30.11.07.18;	author joris;	state Exp;
branches;
next	1.108;

1.108
date	2007.06.28.17.45.49;	author joris;	state Exp;
branches;
next	1.107;

1.107
date	2007.06.18.17.54.13;	author joris;	state Exp;
branches;
next	1.106;

1.106
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.103;

1.103
date	2007.02.01.20.33.03;	author otto;	state Exp;
branches;
next	1.102;

1.102
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.101;

1.101
date	2007.01.26.21.48.17;	author xsa;	state Exp;
branches;
next	1.100;

1.100
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.99;

1.99
date	2007.01.18.15.26.52;	author xsa;	state Exp;
branches;
next	1.98;

1.98
date	2007.01.14.23.10.56;	author joris;	state Exp;
branches;
next	1.97;

1.97
date	2007.01.13.18.28.27;	author joris;	state Exp;
branches;
next	1.96;

1.96
date	2007.01.13.15.56.15;	author joris;	state Exp;
branches;
next	1.95;

1.95
date	2007.01.13.15.45.59;	author joris;	state Exp;
branches;
next	1.94;

1.94
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.93;

1.93
date	2007.01.12.19.28.12;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2007.01.12.18.27.18;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2007.01.12.17.25.33;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2007.01.11.18.06.49;	author jasper;	state Exp;
branches;
next	1.89;

1.89
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.88;

1.88
date	2007.01.07.03.08.15;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2007.01.07.02.44.13;	author joris;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.07.02.39.24;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2007.01.03.22.28.30;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2007.01.03.20.48.26;	author joris;	state Exp;
branches;
next	1.83;

1.83
date	2007.01.02.23.55.15;	author joris;	state Exp;
branches;
next	1.82;

1.82
date	2006.12.31.15.11.23;	author xsa;	state Exp;
branches;
next	1.81;

1.81
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.80;

1.80
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.79;

1.79
date	2006.07.02.21.01.48;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2006.06.29.00.41.52;	author joris;	state Exp;
branches;
next	1.77;

1.77
date	2006.06.28.18.52.05;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2006.06.28.17.59.06;	author joris;	state Exp;
branches;
next	1.75;

1.75
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.74;

1.74
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.73;

1.73
date	2006.06.14.14.10.50;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2006.06.13.06.51.32;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2006.06.07.07.01.12;	author xsa;	state Exp;
branches;
next	1.70;

1.70
date	2006.06.06.05.18.23;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2006.06.04.09.52.56;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2006.06.01.20.00.52;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.31.23.27.38;	author joris;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.31.01.26.21;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.30.21.32.52;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.30.04.20.27;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.28.10.15.35;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.28.07.56.44;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.28.04.32.54;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.28.01.24.28;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.27.15.17.42;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.27.15.14.27;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.27.14.05.53;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.27.06.16.14;	author joris;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.54;

1.54
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.01.20.11.25;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.16.09.06.19;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.22.14.59.54;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.21.20.06.25;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.27.16.42.19;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.23.00.03.00;	author joris;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.22.16.27.29;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.19.00.32.26;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.14.06.50.50;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.12.07.12.13;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.30.09.52.55;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.30.07.37.01;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.20.05.13.44;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.24.02.06.27;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.24.01.56.36;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.19.02.04.56;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.19.00.35.02;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.19.00.34.39;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.18.21.02.49;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.16.18.01.26;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.15.14.34.15;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.31.15.10.51;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.29.15.06.01;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.02.03.05.02;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.22.23.34.28;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.13.18.47.31;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.21.18.32.10;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.14.22.30.48;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.13.23.08.45;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.08.17.22.48;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.02.19.23.44;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.09.22.22.47;	author krapht;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.09.21.11.37;	author krapht;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.09.20.59.31;	author krapht;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.30.01.49.22;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.158
log
@Stop looking at current_cvsroot->cr_method to figure out if we're remote or not.

Instead use cvsroot_is_local() and cvsroot_is_remote().
@
text
@/*	$OpenBSD: commit.c,v 1.157 2017/05/31 16:48:16 joris Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2006 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "diff.h"
#include "remote.h"

void			 cvs_commit_local(struct cvs_file *);
void			 cvs_commit_check_files(struct cvs_file *);
void			 cvs_commit_loginfo(char *);
void			 cvs_commit_lock_dirs(struct cvs_file *);

static BUF *commit_diff(struct cvs_file *, RCSNUM *, int);
static void commit_desc_set(struct cvs_file *);

struct	file_info_list	 files_info;
struct	trigger_list	*line_list;

struct cvs_flisthead	files_affected;
struct cvs_flisthead	files_added;
struct cvs_flisthead	files_removed;
struct cvs_flisthead	files_modified;

char	*logmsg = NULL;
char	*loginfo = NULL;

static int	conflicts_found;

struct cvs_cmd cvs_cmd_commit = {
	CVS_OP_COMMIT, CVS_USE_WDIR, "commit",
	{ "ci", "com" },
	"Check files into the repository",
	"[-flR] [-F logfile | -m msg] [-r rev] ...",
	"F:flm:Rr:",
	NULL,
	cvs_commit
};

int
cvs_commit(int argc, char **argv)
{
	int flags;
	int ch, Fflag, mflag;
	struct module_checkout *mc;
	struct cvs_recursion cr;
	struct cvs_filelist *l;
	struct file_info *fi;
	char *arg = ".", repo[PATH_MAX];

	flags = CR_RECURSE_DIRS;
	Fflag = mflag = 0;

	while ((ch = getopt(argc, argv, cvs_cmd_commit.cmd_opts)) != -1) {
		switch (ch) {
		case 'F':
			/* free previously assigned value */
			free(logmsg);
			logmsg = cvs_logmsg_read(optarg);
			Fflag = 1;
			break;
		case 'f':
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'm':
			/* free previously assigned value */
			free(logmsg);
			logmsg = xstrdup(optarg);
			mflag = 1;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		case 'r':
			break;
		default:
			fatal("%s", cvs_cmd_commit.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	/* -F and -m are mutually exclusive */
	if (Fflag && mflag)
		fatal("cannot specify both a log file and a message");

	RB_INIT(&files_affected);
	RB_INIT(&files_added);
	RB_INIT(&files_removed);
	RB_INIT(&files_modified);

	TAILQ_INIT(&files_info);
	conflicts_found = 0;

	cr.enterdir = NULL;
	cr.leavedir = NULL;
	cr.fileproc = cvs_commit_check_files;
	cr.flags = flags;

	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);

	if (conflicts_found != 0)
		fatal("%d conflicts found, please correct these first",
		    conflicts_found);

	if (RB_EMPTY(&files_affected))
		return (0);

	if (cvsroot_is_remote()) {
		if (logmsg == NULL) {
			logmsg = cvs_logmsg_create(NULL, &files_added,
			    &files_removed, &files_modified);
			if (logmsg == NULL)
				fatal("This shouldnt happen, honestly!");
		}
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (argc > 0)
			cvs_file_run(argc, argv, &cr);
		else
			cvs_file_run(1, &arg, &cr);

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");

		cvs_client_send_logmsg(logmsg);
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("ci");
		cvs_client_get_responses();
	} else {
		cvs_get_repository_name(".", repo, PATH_MAX);

		line_list = cvs_trigger_getlines(CVS_PATH_COMMITINFO, repo);
		if (line_list != NULL) {
			RB_FOREACH(l, cvs_flisthead, &files_affected) {
				fi = xcalloc(1, sizeof(*fi));
				fi->file_path = xstrdup(l->file_path);
				TAILQ_INSERT_TAIL(&files_info, fi,
				    flist);
			}

			if (cvs_trigger_handle(CVS_TRIGGER_COMMITINFO,
			    repo, NULL, line_list, &files_info)) {
				cvs_log(LP_ERR,
				    "Pre-commit check failed");
				cvs_trigger_freelist(line_list);
				goto end;
			}

			cvs_trigger_freelist(line_list);
			cvs_trigger_freeinfo(&files_info);
		}

		if (cvs_server_active) {
			if (logmsg == NULL)
				fatal("no log message specified");
		} else if (logmsg == NULL) {
			logmsg = cvs_logmsg_create(NULL, &files_added,
			    &files_removed, &files_modified);
			if (logmsg == NULL)
				fatal("This shouldnt happen, honestly!");
		}

		if (cvs_logmsg_verify(logmsg))
			goto end;

		cr.fileproc = cvs_commit_lock_dirs;
		cvs_file_walklist(&files_affected, &cr);

		line_list = cvs_trigger_getlines(CVS_PATH_LOGINFO, repo);

		cr.fileproc = cvs_commit_local;
		cvs_file_walklist(&files_affected, &cr);

		if (line_list != NULL) {
			cvs_commit_loginfo(repo);

			cvs_trigger_handle(CVS_TRIGGER_LOGINFO, repo,
			    loginfo, line_list, &files_info);

			free(loginfo);
			cvs_trigger_freelist(line_list);
			cvs_trigger_freeinfo(&files_info);
		}

		mc = cvs_module_lookup(repo);
		if (mc->mc_prog != NULL &&
		    (mc->mc_flags & MODULE_RUN_ON_COMMIT))
			cvs_exec(mc->mc_prog, NULL, 0);
	}

end:
	cvs_trigger_freeinfo(&files_info);
	free(logmsg);
	return (0);
}

void
cvs_commit_loginfo(char *repo)
{
	BUF *buf;
	char pwd[PATH_MAX];
	struct cvs_filelist *cf;

	if (getcwd(pwd, sizeof(pwd)) == NULL)
		fatal("Can't get working directory");

	buf = buf_alloc(1024);

	cvs_trigger_loginfo_header(buf, repo);

	if (!RB_EMPTY(&files_added)) {
		buf_puts(buf, "Added Files:");

		RB_FOREACH(cf, cvs_flisthead, &files_added) {
			buf_putc(buf, '\n');
			buf_putc(buf, '\t');
			buf_puts(buf, cf->file_path);
		}

		buf_putc(buf, '\n');
	}

	if (!RB_EMPTY(&files_modified)) {
		buf_puts(buf, "Modified Files:");

		RB_FOREACH(cf, cvs_flisthead, &files_modified) {
			buf_putc(buf, '\n');
			buf_putc(buf, '\t');
			buf_puts(buf, cf->file_path);
		}

		buf_putc(buf, '\n');
	}

	if (!RB_EMPTY(&files_removed)) {
		buf_puts(buf, "Removed Files:");

		RB_FOREACH(cf, cvs_flisthead, &files_removed) {
			buf_putc(buf, '\n');
			buf_putc(buf, '\t');
			buf_puts(buf, cf->file_path);
		}

		buf_putc(buf, '\n');
	}

	buf_puts(buf, "Log Message:\n");

	buf_puts(buf, logmsg);

	buf_putc(buf, '\n');
	buf_putc(buf, '\0');

	loginfo = buf_release(buf);
}

void
cvs_commit_lock_dirs(struct cvs_file *cf)
{
	char repo[PATH_MAX];

	cvs_get_repository_path(cf->file_wd, repo, sizeof(repo));
	cvs_log(LP_TRACE, "cvs_commit_lock_dirs: %s", repo);

	/* locks stay in place until we are fully done and exit */
	cvs_repository_lock(repo, 1);
}

void
cvs_commit_check_files(struct cvs_file *cf)
{
	char *tag;
	RCSNUM *branch, *brev;

	branch = brev = NULL;

	cvs_log(LP_TRACE, "cvs_commit_check_files(%s)", cf->file_path);

	if (cvsroot_is_remote())
		cvs_remote_classify_file(cf);
	else
		cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_type == CVS_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Examining %s", cf->file_path);
		return;
	}

	if (cf->file_status == FILE_UPTODATE)
		return;

	if (cf->file_status == FILE_MERGE ||
	    cf->file_status == FILE_PATCH ||
	    cf->file_status == FILE_CHECKOUT ||
	    cf->file_status == FILE_LOST ||
	    cf->file_status == FILE_UNLINK) {
		cvs_log(LP_ERR, "conflict: %s is not up-to-date",
		    cf->file_path);
		conflicts_found++;
		return;
	}

	if (cf->file_status == FILE_CONFLICT &&
	   cf->file_ent->ce_conflict != NULL) {
		cvs_log(LP_ERR, "conflict: unresolved conflicts in %s from "
		    "merging, please fix these first", cf->file_path);
		conflicts_found++;
		return;
	}

	if (cf->file_status == FILE_MODIFIED &&
	    cf->file_ent->ce_conflict != NULL &&
	    update_has_conflict_markers(cf)) {
		cvs_log(LP_ERR, "warning: file %s seems to still contain "
		    "conflict indicators", cf->file_path);
	}

	if (cf->file_ent != NULL && cf->file_ent->ce_date != -1) {
		cvs_log(LP_ERR, "conflict: cannot commit to sticky date for %s",
		    cf->file_path);
		conflicts_found++;
		return;
	}

	if (cvsroot_is_local()) {
		tag = cvs_directory_tag;
		if (cf->file_ent != NULL)
			tag = cf->file_ent->ce_tag;

		if (tag != NULL && cf->file_rcs != NULL) {
			brev = rcs_sym_getrev(cf->file_rcs, tag);
			if (brev != NULL) {
				if (!RCSNUM_ISBRANCH(brev)) {
					cvs_log(LP_ERR, "sticky tag %s is not "
					    "a branch for file %s", tag,
					    cf->file_path);
					conflicts_found++;
				}
			}
		}
	}

	free(branch);
	free(brev);

	if (cf->file_status != FILE_ADDED &&
	    cf->file_status != FILE_REMOVED &&
	    cf->file_status != FILE_MODIFIED)
		return;

	cvs_file_get(cf->file_path, 0, &files_affected, CVS_FILE);

	switch (cf->file_status) {
	case FILE_ADDED:
		cvs_file_get(cf->file_path, 0, &files_added, CVS_FILE);
		break;
	case FILE_REMOVED:
		cvs_file_get(cf->file_path, 0, &files_removed, CVS_FILE);
		break;
	case FILE_MODIFIED:
		cvs_file_get(cf->file_path, 0, &files_modified, CVS_FILE);
		break;
	}
}

void
cvs_commit_local(struct cvs_file *cf)
{
	char *tag;
	BUF *b, *d;
	int onbranch, isnew, histtype, branchadded;
	RCSNUM *nrev, *crev, *rrev, *brev;
	int openflags, rcsflags;
	char rbuf[CVS_REV_BUFSZ], nbuf[CVS_REV_BUFSZ];
	CVSENTRIES *entlist;
	char attic[PATH_MAX], repo[PATH_MAX], rcsfile[PATH_MAX];
	struct file_info *fi;

	cvs_log(LP_TRACE, "cvs_commit_local(%s)", cf->file_path);
	cvs_file_classify(cf, cvs_directory_tag);

	if (cvs_noexec == 1)
		return;

	if (cf->file_type != CVS_FILE)
		fatal("cvs_commit_local: '%s' is not a file", cf->file_path);

	tag = cvs_directory_tag;
	if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL)
		tag = cf->file_ent->ce_tag;

	branchadded = 0;
	switch (cf->file_status) {
	case FILE_ADDED:
		if (cf->file_rcs == NULL && tag != NULL) {
			branchadded = 1;
			cvs_add_tobranch(cf, tag);
		}
		break;
	case FILE_MODIFIED:
	case FILE_REMOVED:
		if (cf->file_rcs == NULL) {
			cvs_log(LP_ERR, "RCS file for %s got lost",
			    cf->file_path);
			return;
		}
		break;
	default:
		cvs_log(LP_ERR, "skipping bogus file `%s'", cf->file_path);
		return;
	}

	onbranch = 0;
	nrev = RCS_HEAD_REV;
	crev = NULL;
	rrev = NULL;
	d = NULL;

	if (cf->file_rcs != NULL && cf->file_rcs->rf_branch != NULL) {
		free(cf->file_rcs->rf_branch);
		cf->file_rcs->rf_branch = NULL;
	}

	if (cf->file_rcs != NULL) {
		rrev = rcs_head_get(cf->file_rcs);
		crev = rcs_head_get(cf->file_rcs);
		if (crev == NULL || rrev == NULL)
			fatal("no head revision in RCS file for %s",
			    cf->file_path);

		if (tag != NULL) {
			free(crev);
			free(rrev);
			brev = rcs_sym_getrev(cf->file_rcs, tag);
			crev = rcs_translate_tag(tag, cf->file_rcs);
			if (brev == NULL || crev == NULL) {
				fatal("failed to resolve existing tag: %s",
				    tag);
			}

			rrev = rcsnum_alloc();
			rcsnum_cpy(brev, rrev, brev->rn_len - 1);

			if (RCSNUM_ISBRANCHREV(crev) &&
			    rcsnum_cmp(crev, rrev, 0)) {
				nrev = rcsnum_alloc();
				rcsnum_cpy(crev, nrev, 0);
				rcsnum_inc(nrev);
			} else if (!RCSNUM_ISBRANCH(crev)) {
				nrev = rcsnum_brtorev(brev);
				if (nrev == NULL)
					fatal("failed to create branch rev");
			} else {
				fatal("this isnt suppose to happen, honestly");
			}

			free(brev);
			free(rrev);
			rrev = rcsnum_branch_root(nrev);

			/* branch stuff was checked in cvs_commit_check_files */
			onbranch = 1;
		}

		rcsnum_tostr(crev, rbuf, sizeof(rbuf));
	} else {
		strlcpy(rbuf, "Non-existent", sizeof(rbuf));
	}

	free(rrev);
	isnew = 0;
	if (cf->file_status == FILE_ADDED) {
		isnew = 1;
		rcsflags = RCS_CREATE;
		openflags = O_CREAT | O_RDONLY;
		if (cf->file_rcs != NULL) {
			if (!onbranch) {
				if (cf->in_attic == 0)
					cvs_log(LP_ERR, "warning: expected %s "
					    "to be in the Attic",
					    cf->file_path);

				if (cf->file_rcs->rf_dead == 0)
					cvs_log(LP_ERR, "warning: expected %s "
					    "to be dead", cf->file_path);

				cvs_get_repository_path(cf->file_wd, repo,
				    PATH_MAX);
				(void)xsnprintf(rcsfile, PATH_MAX, "%s/%s%s",
				    repo, cf->file_name, RCS_FILE_EXT);

				if (rename(cf->file_rpath, rcsfile) == -1)
					fatal("cvs_commit_local: failed to "
					    "move %s outside the Attic: %s",
					    cf->file_path, strerror(errno));

				free(cf->file_rpath);
				cf->file_rpath = xstrdup(rcsfile);
				isnew = 0;
			}

			rcsflags = RCS_READ | RCS_PARSE_FULLY;
			openflags = O_RDONLY;
			rcs_close(cf->file_rcs);
		}

		cf->repo_fd = open(cf->file_rpath, openflags);
		if (cf->repo_fd < 0)
			fatal("cvs_commit_local: %s", strerror(errno));

		cf->file_rcs = rcs_open(cf->file_rpath, cf->repo_fd,
		    rcsflags, 0444);
		if (cf->file_rcs == NULL)
			fatal("cvs_commit_local: failed to create RCS file "
			    "for %s", cf->file_path);

		commit_desc_set(cf);

		if (branchadded)
			strlcpy(rbuf, "Non-existent", sizeof(rbuf));
	}

	if (verbosity > 1) {
		cvs_printf("Checking in %s:\n", cf->file_path);
		cvs_printf("%s <- %s\n", cf->file_rpath, cf->file_path);
		cvs_printf("old revision: %s; ", rbuf);
	}

	if (isnew == 0 && cf->file_rcs->rf_head == NULL)
		fatal("no head revision in RCS file for %s", cf->file_path);

	if (isnew == 0 && onbranch == 0)
		d = commit_diff(cf, cf->file_rcs->rf_head, 0);

	if (cf->file_status == FILE_REMOVED) {
		b = rcs_rev_getbuf(cf->file_rcs, crev, 0);
	} else if (onbranch == 1) {
		b = commit_diff(cf, crev, 1);
	} else {
		b = buf_load_fd(cf->fd);
	}

	if (isnew == 0 && onbranch == 0) {
		if (rcs_deltatext_set(cf->file_rcs, crev, d) == -1)
			fatal("cvs_commit_local: failed to set delta");
	}

	if (rcs_rev_add(cf->file_rcs, nrev, logmsg, -1, NULL) == -1)
		fatal("cvs_commit_local: failed to add new revision");

	if (nrev == RCS_HEAD_REV)
		nrev = cf->file_rcs->rf_head;

	if (rcs_deltatext_set(cf->file_rcs, nrev, b) == -1)
		fatal("cvs_commit_local: failed to set new HEAD delta");

	if (cf->file_status == FILE_REMOVED) {
		if (rcs_state_set(cf->file_rcs, nrev, RCS_STATE_DEAD) == -1)
			fatal("cvs_commit_local: failed to set state");
	}

	if (cf->file_status == FILE_ADDED && cf->file_ent->ce_opts != NULL) {
		int cf_kflag;

		cf_kflag = rcs_kflag_get(cf->file_ent->ce_opts + 2);
		rcs_kwexp_set(cf->file_rcs, cf_kflag);
	}

	rcs_write(cf->file_rcs);

	if (cf->file_status == FILE_REMOVED) {
		strlcpy(nbuf, "Removed", sizeof(nbuf));
	} else if (cf->file_status == FILE_ADDED) {
		if (cf->file_rcs->rf_dead == 1)
			strlcpy(nbuf, "Initial Revision", sizeof(nbuf));
		else
			rcsnum_tostr(nrev, nbuf, sizeof(nbuf));
	} else if (cf->file_status == FILE_MODIFIED) {
		rcsnum_tostr(nrev, nbuf, sizeof(nbuf));
	}

	if (verbosity > 1)
		cvs_printf("new revision: %s\n", nbuf);

	(void)unlink(cf->file_path);
	(void)close(cf->fd);
	cf->fd = -1;

	if (cf->file_status != FILE_REMOVED) {
		cvs_checkout_file(cf, nrev, NULL, CO_COMMIT);
	} else {
		entlist = cvs_ent_open(cf->file_wd);
		cvs_ent_remove(entlist, cf->file_name);

		cvs_get_repository_path(cf->file_wd, repo, PATH_MAX);

		(void)xsnprintf(attic, PATH_MAX, "%s/%s",
		    repo, CVS_PATH_ATTIC);

		if (mkdir(attic, 0755) == -1 && errno != EEXIST)
			fatal("cvs_commit_local: failed to create Attic");

		(void)xsnprintf(attic, PATH_MAX, "%s/%s/%s%s", repo,
		    CVS_PATH_ATTIC, cf->file_name, RCS_FILE_EXT);

		if (rename(cf->file_rpath, attic) == -1)
			fatal("cvs_commit_local: failed to move %s to Attic",
			    cf->file_path);

		if (cvs_server_active == 1)
			cvs_server_update_entry("Remove-entry", cf);
	}

	if (verbosity > 1)
		cvs_printf("done\n");
	else {
		cvs_log(LP_NOTICE, "checking in '%s'; revision %s -> %s",
		    cf->file_path, rbuf, nbuf);
	}

	if (line_list != NULL) {
		fi = xcalloc(1, sizeof(*fi));
		fi->file_path = xstrdup(cf->file_path);
		fi->crevstr = xstrdup(rbuf);
		fi->nrevstr = xstrdup(nbuf);
		if (tag != NULL)
			fi->tag_new = xstrdup(tag);
		TAILQ_INSERT_TAIL(&files_info, fi, flist);
	}

	switch (cf->file_status) {
	case FILE_MODIFIED:
		histtype = CVS_HISTORY_COMMIT_MODIFIED;
		break;
	case FILE_ADDED:
		histtype = CVS_HISTORY_COMMIT_ADDED;
		break;
	case FILE_REMOVED:
		histtype = CVS_HISTORY_COMMIT_REMOVED;
		break;
	default:
		histtype = -1;
		break;
	}

	free(crev);

	if (histtype != -1)
		cvs_history_add(histtype, cf, NULL);
	else
		cvs_log(LP_NOTICE, "histtype was -1 for %s", cf->file_path);
}

static BUF *
commit_diff(struct cvs_file *cf, RCSNUM *rev, int reverse)
{
	int fd1, fd2, d;
	char *p1, *p2;
	BUF *b;

	(void)xasprintf(&p1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);

	if (cf->file_status == FILE_MODIFIED ||
	    cf->file_status == FILE_ADDED) {
		b = buf_load_fd(cf->fd);
		fd1 = buf_write_stmp(b, p1, NULL);
		buf_free(b);
	} else {
		fd1 = rcs_rev_write_stmp(cf->file_rcs, rev, p1, 0);
	}

	(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
	fd2 = rcs_rev_write_stmp(cf->file_rcs, rev, p2, RCS_KWEXP_NONE);

	b = buf_alloc(128);

	diff_format = D_RCSDIFF;

	if (reverse == 1)
		d = diffreg(p2, p1, fd2, fd1, b, D_FORCEASCII);
	else
		d = diffreg(p1, p2, fd1, fd2, b, D_FORCEASCII);
	if (d == D_ERROR)
		fatal("commit_diff: failed to get RCS patch");

	close(fd1);
	close(fd2);

	free(p1);
	free(p2);

	return (b);
}

static void
commit_desc_set(struct cvs_file *cf)
{
	BUF *bp;
	int fd;
	char desc_path[PATH_MAX], *desc;

	(void)xsnprintf(desc_path, PATH_MAX, "%s/%s/%s%s",
	    cf->file_wd, CVS_PATH_CVSDIR, cf->file_name, CVS_DESCR_FILE_EXT);

	if ((fd = open(desc_path, O_RDONLY)) == -1)
		return;

	bp = buf_load_fd(fd);
	buf_putc(bp, '\0');
	desc = buf_release(bp);

	rcs_desc_set(cf->file_rcs, desc);

	(void)close(fd);
	(void)cvs_unlink(desc_path);

	free(desc);
}
@


1.157
log
@Do not use CVS_LOCK_REPO for committing.

This flag tells our file recursion code that for each directory entered
we should lock it. Commit however locks all relevant directories on its
own when it is about to make changes and should not depend on the file
recursion code to do so.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.156 2017/05/28 17:01:10 joris Exp $	*/
d138 1
a138 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
d311 1
a311 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL)
d358 1
a358 1
	if (current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
@


1.156
log
@Don't allow opencvs to commit towards tags that are not branches.

Gets rid of the old logic that wasn't working and replaced it with
a simplified version.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.155 2016/10/13 20:51:25 fcambus Exp $	*/
d54 1
a54 1
	CVS_OP_COMMIT, CVS_USE_WDIR | CVS_LOCK_REPO, "commit",
@


1.155
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.154 2015/11/05 09:48:21 nicm Exp $	*/
d366 6
a371 41
				if (RCSNUM_ISBRANCH(brev))
					goto next;
				free(brev);
			}

			brev = rcs_translate_tag(tag, cf->file_rcs);

			if (brev == NULL) {
				if (cf->file_status == FILE_ADDED)
					goto next;
				fatal("failed to resolve tag: %s",
				    cf->file_ent->ce_tag);
			}

			if ((branch = rcsnum_revtobr(brev)) == NULL) {
				cvs_log(LP_ERR, "sticky tag %s is not "
				    "a branch for file %s", tag,
				    cf->file_path);
				conflicts_found++;
				free(brev);
				return;
			}

			if (!RCSNUM_ISBRANCHREV(brev)) {
				cvs_log(LP_ERR, "sticky tag %s is not "
				    "a branch for file %s", tag,
				    cf->file_path);
				conflicts_found++;
				free(branch);
				free(brev);
				return;
			}

			if (!RCSNUM_ISBRANCH(branch)) {
				cvs_log(LP_ERR, "sticky tag %s is not "
				    "a branch for file %s", tag,
				    cf->file_path);
				conflicts_found++;
				free(branch);
				free(brev);
				return;
a375 1
next:
@


1.154
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.153 2015/01/16 06:40:07 deraadt Exp $	*/
d368 1
a368 1
				rcsnum_free(brev);
d385 1
a385 1
				rcsnum_free(brev);
d394 2
a395 2
				rcsnum_free(branch);
				rcsnum_free(brev);
d404 2
a405 2
				rcsnum_free(branch);
				rcsnum_free(brev);
d412 2
a413 4
	if (branch != NULL)
		rcsnum_free(branch);
	if (brev != NULL)
		rcsnum_free(brev);
d489 1
a489 1
		rcsnum_free(cf->file_rcs->rf_branch);
d501 2
a502 2
			rcsnum_free(crev);
			rcsnum_free(rrev);
d526 2
a527 2
			rcsnum_free(brev);
			rcsnum_free(rrev);
d539 1
a539 2
	if (rrev != NULL)
		rcsnum_free(rrev);
d715 1
a715 2
	if (crev != NULL)
		rcsnum_free(crev);
@


1.153
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.152 2011/12/27 13:59:01 nicm Exp $	*/
d24 1
d81 1
a81 2
			if (logmsg != NULL)
				xfree(logmsg);
d92 1
a92 2
			if (logmsg != NULL)
				xfree(logmsg);
d212 1
a212 1
			xfree(loginfo);
d225 1
a225 2
	if (logmsg != NULL)
		xfree(logmsg);
d569 1
a569 1
				xfree(cf->file_rpath);
d762 2
a763 2
	xfree(p1);
	xfree(p2);
d790 1
a790 1
	xfree(desc);
@


1.152
log
@Move some global variables/statics to locals, from Michael W
Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.151 2011/04/20 18:41:40 nicm Exp $	*/
d71 1
a71 1
	char *arg = ".", repo[MAXPATHLEN];
d163 1
a163 1
		cvs_get_repository_name(".", repo, MAXPATHLEN);
d235 1
a235 1
	char pwd[MAXPATHLEN];
d294 1
a294 1
	char repo[MAXPATHLEN];
d449 1
a449 1
	char attic[MAXPATHLEN], repo[MAXPATHLEN], rcsfile[MAXPATHLEN];
d562 2
a563 2
				    MAXPATHLEN);
				(void)xsnprintf(rcsfile, MAXPATHLEN, "%s/%s%s",
d669 1
a669 1
		cvs_get_repository_path(cf->file_wd, repo, MAXPATHLEN);
d671 1
a671 1
		(void)xsnprintf(attic, MAXPATHLEN, "%s/%s",
d677 1
a677 1
		(void)xsnprintf(attic, MAXPATHLEN, "%s/%s/%s%s", repo,
d775 1
a775 1
	char desc_path[MAXPATHLEN], *desc;
d777 1
a777 1
	(void)xsnprintf(desc_path, MAXPATHLEN, "%s/%s/%s%s",
@


1.151
log
@Trivial code simplifying, from Michael W Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.150 2010/07/23 21:46:05 ray Exp $	*/
a46 1
int	conflicts_found;
d49 2
@


1.150
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.149 2009/06/07 08:39:13 ray Exp $	*/
d190 1
a190 1
			    &files_removed, &files_modified);	
d731 2
a732 2
	int fd1, fd2, f;
	char *p1, *p2, *p;
d753 5
a757 11
	if (reverse == 1) {
		p = p1;
		p1 = p2;
		p2 = p;

		f = fd1;
		fd1 = fd2;
		fd2 = f;
	}

	if (diffreg(p1, p2, fd1, fd2, b, D_FORCEASCII) == D_ERROR)
@


1.149
log
@More cvs/diff/rcs convergence:
1. Mostly variable/function renaming, SIZE_T_MAX->SIZE_MAX, and
spacing.
2. One strchr -> strncspn.
3. diff had a weird thing where it set file[12] = ofile[12] but
never updated file or ofile, then if file and ofile were different
it freed it. I removed it.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.148 2009/06/06 14:17:27 ray Exp $	*/
d240 1
a240 1
	buf = cvs_buf_alloc(1024);
d245 1
a245 1
		cvs_buf_puts(buf, "Added Files:");
d248 3
a250 3
			cvs_buf_putc(buf, '\n');
			cvs_buf_putc(buf, '\t');
			cvs_buf_puts(buf, cf->file_path);
d253 1
a253 1
		cvs_buf_putc(buf, '\n');
d257 1
a257 1
		cvs_buf_puts(buf, "Modified Files:");
d260 3
a262 3
			cvs_buf_putc(buf, '\n');
			cvs_buf_putc(buf, '\t');
			cvs_buf_puts(buf, cf->file_path);
d265 1
a265 1
		cvs_buf_putc(buf, '\n');
d269 1
a269 1
		cvs_buf_puts(buf, "Removed Files:");
d272 3
a274 3
			cvs_buf_putc(buf, '\n');
			cvs_buf_putc(buf, '\t');
			cvs_buf_puts(buf, cf->file_path);
d277 1
a277 1
		cvs_buf_putc(buf, '\n');
d280 1
a280 1
	cvs_buf_puts(buf, "Log Message:\n");
d282 1
a282 1
	cvs_buf_puts(buf, logmsg);
d284 2
a285 2
	cvs_buf_putc(buf, '\n');
	cvs_buf_putc(buf, '\0');
d287 1
a287 1
	loginfo = cvs_buf_release(buf);
d613 1
a613 1
		b = cvs_buf_load_fd(cf->fd);
d739 3
a741 3
		b = cvs_buf_load_fd(cf->fd);
		fd1 = cvs_buf_write_stmp(b, p1, NULL);
		cvs_buf_free(b);
d749 1
a749 1
	b = cvs_buf_alloc(128);
d788 3
a790 3
	bp = cvs_buf_load_fd(fd);
	cvs_buf_putc(bp, '\0');
	desc = cvs_buf_release(bp);
@


1.148
log
@Sync some rcsdiff changes to cvsdiff.  As a side effect,
cvs diff -t now works.  There should be no functional change
otherwise.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.147 2009/03/26 22:54:37 joris Exp $	*/
d763 1
a763 1
	if (cvs_diffreg(p1, p2, fd1, fd2, b, D_FORCEASCII) == D_ERROR)
@


1.147
log
@fix the way Attic is handled in our recursion code, so we
do not skip files or run over them twice.

also fixes -l and -r for checkout/update when a file in
Attic exists with that tag that in HEAD is a directory
in the normal repository like gnu/usr.bin/gcc/INSTALL.

as a bonus, we do not run fstat() twice per file or dir
anymore...

spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.146 2009/03/25 21:50:33 joris Exp $	*/
d763 1
a763 1
	if (cvs_diffreg(p1, p2, fd1, fd2, b) == D_ERROR)
@


1.146
log
@switch our file and directory lists to RB trees (see tree(3)),
so we can benefit from faster lookup times while recursing.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.145 2008/08/29 09:54:22 tobias Exp $	*/
d423 1
a423 1
	cvs_file_get(cf->file_path, 0, &files_affected);
d427 1
a427 1
		cvs_file_get(cf->file_path, 0, &files_added);
d430 1
a430 1
		cvs_file_get(cf->file_path, 0, &files_removed);
d433 1
a433 1
		cvs_file_get(cf->file_path, 0, &files_modified);
@


1.145
log
@Pre-commit checks (CVSROOT/commitinfo) are run before log message is
requested. Do this for GNU cvs compatibility, too.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.144 2008/07/08 12:54:13 joris Exp $	*/
d113 4
a116 4
	TAILQ_INIT(&files_affected);
	TAILQ_INIT(&files_added);
	TAILQ_INIT(&files_removed);
	TAILQ_INIT(&files_modified);
d135 1
a135 1
	if (TAILQ_EMPTY(&files_affected))
d166 1
a166 1
			TAILQ_FOREACH(l, &files_affected, flist) {
d244 1
a244 1
	if (!TAILQ_EMPTY(&files_added)) {
d247 1
a247 1
		TAILQ_FOREACH(cf, &files_added, flist) {
d256 1
a256 1
	if (!TAILQ_EMPTY(&files_modified)) {
d259 1
a259 1
		TAILQ_FOREACH(cf, &files_modified, flist) {
d268 1
a268 1
	if (!TAILQ_EMPTY(&files_removed)) {
d271 1
a271 1
		TAILQ_FOREACH(cf, &files_removed, flist) {
@


1.144
log
@make these compile cleanly
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.143 2008/06/15 04:38:52 tobias Exp $	*/
a137 8
	if (logmsg == NULL && cvs_server_active == 0) {
		logmsg = cvs_logmsg_create(NULL, &files_added, &files_removed,
		    &files_modified);

		if (logmsg == NULL)
			fatal("This shouldnt happen, honestly!");
	}

d139 6
a161 3
		if (cvs_server_active && logmsg == NULL)
			fatal("no log message specified");

d185 10
d225 2
a226 1
	xfree(logmsg);
@


1.143
log
@Support the addition of new files in branches.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.142 2008/06/14 04:34:08 tobias Exp $	*/
d483 1
d708 3
d716 4
a719 1
	cvs_history_add(histtype, cf, NULL);
@


1.142
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.141 2008/06/14 03:19:15 joris Exp $	*/
d369 2
d437 1
a437 1
	int onbranch, isnew, histtype;
d454 21
a474 3
	if (cf->file_status != FILE_MODIFIED &&
	    cf->file_status != FILE_ADDED &&
	    cf->file_status != FILE_REMOVED) {
d489 1
a489 3
	if (cf->file_status == FILE_MODIFIED ||
	    cf->file_status == FILE_REMOVED || (cf->file_status == FILE_ADDED
	    && cf->file_rcs != NULL && cf->file_rcs->rf_dead == 1)) {
a495 4
		tag = cvs_directory_tag;
		if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL)
			tag = cf->file_ent->ce_tag;

d541 1
a541 1
		openflags = O_CREAT | O_TRUNC | O_WRONLY;
d543 24
a566 19
			if (cf->in_attic == 0)
				cvs_log(LP_ERR, "warning: expected %s "
				    "to be in the Attic", cf->file_path);

			if (cf->file_rcs->rf_dead == 0)
				cvs_log(LP_ERR, "warning: expected %s "
				    "to be dead", cf->file_path);

			cvs_get_repository_path(cf->file_wd, repo, MAXPATHLEN);
			(void)xsnprintf(rcsfile, MAXPATHLEN, "%s/%s%s",
			    repo, cf->file_name, RCS_FILE_EXT);

			if (rename(cf->file_rpath, rcsfile) == -1)
				fatal("cvs_commit_local: failed to move %s "
				    "outside the Attic: %s", cf->file_path,
				    strerror(errno));

			xfree(cf->file_rpath);
			cf->file_rpath = xstrdup(rcsfile);
a570 1
			isnew = 0;
d584 3
@


1.141
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.140 2008/06/10 19:00:17 joris Exp $	*/
d475 2
a476 2
			fatal("RCS head empty or missing in %s\n",
			    cf->file_rcs->rf_path);
d573 3
@


1.140
log
@set tag_new if its available so it can get passed to loginfo
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.139 2008/06/10 14:49:50 joris Exp $	*/
a635 1
		cvs_ent_close(entlist, ENT_SYNC);
@


1.139
log
@switch back to a single log message in local mode so we are compliant
with a remote setup.

fixes a very annoying bug with loginfo as well.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.138 2008/06/10 02:07:57 joris Exp $	*/
d669 2
@


1.138
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.137 2008/06/10 01:00:34 joris Exp $	*/
a30 11
struct	cvs_dirlist {
	char	*file_path;
	struct	cvs_flisthead files_affected;
	struct	cvs_flisthead files_added;
	struct	cvs_flisthead files_removed;
	struct	cvs_flisthead files_modified;
	TAILQ_ENTRY(cvs_dirlist) dlist;
};

TAILQ_HEAD(cvs_dlisthead, cvs_dirlist);

d33 1
a33 1
void			 cvs_commit_loginfo(char *, struct cvs_dirlist *);
a34 2
struct cvs_dirlist	*cvs_commit_getdir(char *dir);
void			 cvs_commit_freedirlist(void);
a38 1
struct	cvs_dlisthead	 directory_list;
d42 5
a67 1
	struct cvs_dirlist *d;
d113 5
a117 1
	TAILQ_INIT(&directory_list);
d135 1
a135 1
	if (TAILQ_EMPTY(&directory_list))
d138 3
a140 7
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		d = TAILQ_FIRST(&directory_list);

		if (logmsg == NULL) {
			logmsg = cvs_logmsg_create(NULL, &d->files_added,
			    &d->files_removed, &d->files_modified);
		}
d144 1
d146 1
d167 9
a175 10
		TAILQ_FOREACH(d, &directory_list, dlist) {
			cvs_get_repository_name(d->file_path, repo,
			    MAXPATHLEN);

			if (!Fflag && !mflag) {
				if (logmsg != NULL)
					xfree(logmsg);
				logmsg = cvs_logmsg_create(d->file_path,
				    &d->files_added, &d->files_removed,
				    &d->files_modified);
d178 4
a181 16
			line_list = cvs_trigger_getlines(CVS_PATH_COMMITINFO,
			    repo);
			if (line_list != NULL) {
				TAILQ_FOREACH(l, &d->files_affected, flist) {
					fi = xcalloc(1, sizeof(*fi));
					fi->file_path = xstrdup(l->file_path);
					TAILQ_INSERT_TAIL(&files_info, fi,
					    flist);
				}
				if (cvs_trigger_handle(CVS_TRIGGER_COMMITINFO,
				    repo, NULL, line_list, &files_info)) {
					cvs_log(LP_ERR,
					    "Pre-commit check failed");
					cvs_trigger_freelist(line_list);
					goto end;
				}
d183 1
a183 9
				cvs_trigger_freeinfo(&files_info);
			}
	
			if (logmsg == NULL) {
				if (cvs_server_active)
					fatal("no log message specified");
				logmsg = cvs_logmsg_create(d->file_path,
				    &d->files_added, &d->files_removed,
				    &d->files_modified);
d186 3
a188 2
			if (cvs_logmsg_verify(logmsg))
				goto end;
d190 2
a191 2
			cr.fileproc = cvs_commit_lock_dirs;
			cvs_file_walklist(&d->files_affected, &cr);
d193 2
a194 2
			line_list = cvs_trigger_getlines(CVS_PATH_LOGINFO,
			    repo);
d196 1
a196 2
			cr.fileproc = cvs_commit_local;
			cvs_file_walklist(&d->files_affected, &cr);
d198 2
a199 2
			if (line_list != NULL) {
				cvs_commit_loginfo(repo, d);
d201 2
a202 2
				cvs_trigger_handle(CVS_TRIGGER_LOGINFO, repo,
				    loginfo, line_list, &files_info);
d204 2
a205 4
				xfree(loginfo);
				cvs_trigger_freelist(line_list);
				cvs_trigger_freeinfo(&files_info);
			}
d207 3
a209 4
			mc = cvs_module_lookup(repo);
			if (mc->mc_prog != NULL &&
			    (mc->mc_flags & MODULE_RUN_ON_COMMIT))
				cvs_exec(mc->mc_prog, NULL, 0);
d211 5
a218 1
	cvs_commit_freedirlist();
d225 1
a225 38
cvs_commit_freedirlist(void)
{
	struct cvs_dirlist *d;

	while ((d = TAILQ_FIRST(&directory_list)) != NULL) {
		TAILQ_REMOVE(&directory_list, d, dlist);
		xfree(d->file_path);
		cvs_file_freelist(&d->files_affected);
		cvs_file_freelist(&d->files_added);
		cvs_file_freelist(&d->files_modified);
		cvs_file_freelist(&d->files_removed);
		xfree(d);
	}
}

struct cvs_dirlist *
cvs_commit_getdir(char *dir)
{
	struct cvs_dirlist *dp;

	TAILQ_FOREACH(dp, &directory_list, dlist) {
		if (strcmp(dp->file_path, dir) == 0)
			return dp;
	}

	dp = xmalloc(sizeof(*dp));
	dp->file_path = xstrdup(dir);
	TAILQ_INIT(&dp->files_affected);
	TAILQ_INIT(&dp->files_added);
	TAILQ_INIT(&dp->files_modified);
	TAILQ_INIT(&dp->files_removed);

	TAILQ_INSERT_TAIL(&directory_list, dp, dlist);
	return dp;
}

void
cvs_commit_loginfo(char *repo, struct cvs_dirlist *d)
d228 1
a228 1
	char pwd[MAXPATHLEN], *p;
d238 1
a238 1
	if (!TAILQ_EMPTY(&d->files_added)) {
d241 1
a241 4
		TAILQ_FOREACH(cf, &d->files_added, flist) {
			if ((p = basename(cf->file_path)) == NULL)
				p = cf->file_path;

d244 1
a244 1
			cvs_buf_puts(buf, p);
d250 1
a250 1
	if (!TAILQ_EMPTY(&d->files_modified)) {
d253 1
a253 4
		TAILQ_FOREACH(cf, &d->files_modified, flist) {
			if ((p = basename(cf->file_path)) == NULL)
				p = cf->file_path;

d256 1
a256 1
			cvs_buf_puts(buf, p);
d262 1
a262 1
	if (!TAILQ_EMPTY(&d->files_removed)) {
d265 1
a265 4
		TAILQ_FOREACH(cf, &d->files_removed, flist) {
			if ((p = basename(cf->file_path)) == NULL)
				p = cf->file_path;

d268 1
a268 1
			cvs_buf_puts(buf, p);
a300 1
	struct cvs_dirlist *d;
d415 1
a415 7
	if (current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
		d = cvs_commit_getdir(cf->file_wd);
	} else {
		d = cvs_commit_getdir("remote");
	}

	cvs_file_get(cf->file_path, 0, &d->files_affected);
d419 1
a419 1
		cvs_file_get(cf->file_path, 0, &d->files_added);
d422 1
a422 1
		cvs_file_get(cf->file_path, 0, &d->files_removed);
d425 1
a425 1
		cvs_file_get(cf->file_path, 0, &d->files_modified);
@


1.137
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.136 2008/06/09 22:31:24 tobias Exp $	*/
d214 1
a214 1
	
d229 1
a229 1
	
d232 1
a232 1
	
@


1.136
log
@Properly handle merged files and conflicts which may arrise while merge.
Instead of ignoring all files which contain possible conflict markers,
only watch out for files which have actually been merged.

With input by and ok joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.135 2008/06/08 20:08:43 tobias Exp $	*/
d23 1
d44 1
d52 3
a54 1
struct	cvs_dlisthead directory_list;
d58 1
d78 2
d124 1
d172 3
d176 3
d187 31
d221 3
d227 11
a237 1
			cvs_get_repository_name(".", repo, MAXPATHLEN);
d241 1
a241 1
				cvs_exec(mc->mc_prog);
d245 1
d247 1
a247 1

d260 4
a263 4
		cvs_file_freelist(&(d->files_affected));
		cvs_file_freelist(&(d->files_added));
		cvs_file_freelist(&(d->files_modified));
		cvs_file_freelist(&(d->files_removed));
d280 4
a283 4
	TAILQ_INIT(&(dp->files_affected));
	TAILQ_INIT(&(dp->files_added));
	TAILQ_INIT(&(dp->files_modified));
	TAILQ_INIT(&(dp->files_removed));
d290 69
d522 1
d743 8
@


1.135
log
@Handle commits on a per-directory basis instead handling all of them at
once in local setup.  Also added '!' to reuse typed log message for all
following directories.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.134 2008/06/08 02:54:08 tobias Exp $	*/
a246 1
	char rev[CVS_REV_BUFSZ];
d264 7
a270 1
	if (cf->file_status == FILE_CONFLICT ||
d272 2
d278 2
a279 2
	if (cf->file_status != FILE_REMOVED &&
	    update_has_conflict_markers(cf)) {
d286 5
a290 8
	if (cf->file_status == FILE_MERGE ||
	    cf->file_status == FILE_PATCH ||
	    cf->file_status == FILE_CHECKOUT ||
	    cf->file_status == FILE_LOST) {
		cvs_log(LP_ERR, "conflict: %s is not up-to-date",
		    cf->file_path);
		conflicts_found++;
		return;
a319 1
			rcsnum_tostr(brev, rev, sizeof(rev));
d321 3
a323 2
				cvs_log(LP_ERR, "%s is not a branch revision",
				    rev);
d330 3
a332 2
				cvs_log(LP_ERR, "%s is not a branch revision",
				    rev);
a338 1
			rcsnum_tostr(branch, rev, sizeof(rev));
d340 3
a342 2
				cvs_log(LP_ERR, "%s (%s) is not a branch",
				    cf->file_ent->ce_tag, rev);
@


1.134
log
@Properly build up path to description files (descr entry in RCS files if
you add a file with -m message).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.133 2008/05/17 21:06:44 tobias Exp $	*/
d30 8
a37 3
void	cvs_commit_local(struct cvs_file *);
void	cvs_commit_check_files(struct cvs_file *);
void	cvs_commit_lock_dirs(struct cvs_file *);
d39 8
d50 1
a50 4
struct	cvs_flisthead files_affected;
struct	cvs_flisthead files_added;
struct	cvs_flisthead files_removed;
struct	cvs_flisthead files_modified;
d72 1
d116 1
a116 4
	TAILQ_INIT(&files_affected);
	TAILQ_INIT(&files_added);
	TAILQ_INIT(&files_removed);
	TAILQ_INIT(&files_modified);
d133 1
a133 1
	if (TAILQ_EMPTY(&files_affected))
d136 2
a137 4
	if (logmsg == NULL && cvs_server_active == 0) {
		logmsg = cvs_logmsg_create(&files_added, &files_removed,
		    &files_modified);
	}
d139 4
a142 2
	if (logmsg == NULL)
		fatal("This shouldnt happen, honestly!");
d144 2
a145 3
	cvs_file_freelist(&files_modified);
	cvs_file_freelist(&files_removed);
	cvs_file_freelist(&files_added);
a146 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
d164 8
a171 2
		cr.fileproc = cvs_commit_lock_dirs;
		cvs_file_walklist(&files_affected, &cr);
d173 2
a174 3
		cr.fileproc = cvs_commit_local;
		cvs_file_walklist(&files_affected, &cr);
		cvs_file_freelist(&files_affected);
d176 9
a184 5
		cvs_get_repository_name(".", repo, MAXPATHLEN);
		mc = cvs_module_lookup(repo);
		if (mc->mc_prog != NULL &&
		    (mc->mc_flags & MODULE_RUN_ON_COMMIT))
			cvs_exec(mc->mc_prog);
d187 2
d194 37
d248 1
d352 4
a355 4
	if (cf->file_status == FILE_ADDED ||
	    cf->file_status == FILE_REMOVED ||
	    cf->file_status == FILE_MODIFIED)
		cvs_file_get(cf->file_path, 0, &files_affected);
d357 8
d367 1
a367 1
		cvs_file_get(cf->file_path, 0, &files_added);
d370 1
a370 1
		cvs_file_get(cf->file_path, 0, &files_removed);
d373 1
a373 1
		cvs_file_get(cf->file_path, 0, &files_modified);
@


1.133
log
@Full support of branches added.  We lacked proper support of multiple
branch entry points in one revision as well as branches which started from
other branches.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.132 2008/03/09 03:14:52 joris Exp $	*/
d620 2
a621 2
	(void)xsnprintf(desc_path, MAXPATHLEN, "%s/%s%s",
	    CVS_PATH_CVSDIR, cf->file_name, CVS_DESCR_FILE_EXT);
@


1.132
log
@proper repository locking:
- all read operations now look for a lock, and wait if present but never
  try to lock the tree themselfs anymore.
- all write operations lock the tree where needed.
- commit locks all relevant directories before even attempting to start.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.131 2008/02/27 22:34:04 joris Exp $	*/
d368 2
d371 1
a371 1
			if (crev == NULL) {
d376 5
a380 1
			if (RCSNUM_ISBRANCHREV(crev)) {
a384 3
				brev = rcs_sym_getrev(cf->file_rcs, tag);
				if (brev == NULL)
					fatal("no more tag?");
a387 1
				rcsnum_free(brev);
d392 1
@


1.131
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.130 2008/02/20 17:29:28 tobias Exp $	*/
d32 1
d46 1
a46 1
	CVS_OP_COMMIT, CVS_USE_WDIR, "commit",
d158 3
d174 12
@


1.130
log
@With latest buf cleanup, rcs_rev_getbuf won't return NULL anymore.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.129 2008/02/11 20:33:11 tobias Exp $	*/
d550 1
d559 1
a559 1
		cvs_buf_write_stmp(b, p1, NULL);
d562 1
a562 1
		rcs_rev_write_stmp(cf->file_rcs, rev, p1, 0);
d566 1
a566 1
	rcs_rev_write_stmp(cf->file_rcs, rev, p2, RCS_KWEXP_NONE);
d576 4
d582 1
a582 1
	if (cvs_diffreg(p1, p2, b) == D_ERROR)
d584 3
@


1.129
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.128 2008/02/10 13:07:58 joris Exp $	*/
a443 2
		if (b == NULL)
			fatal("cvs_commit_local: failed to get crev");
@


1.128
log
@do not allow commits to files that have a sticky date set
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.127 2008/02/04 22:36:40 joris Exp $	*/
d449 1
a449 2
		if ((b = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
			fatal("cvs_commit_local: failed to load file");
d559 1
a559 3
		if ((b = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
			fatal("commit_diff: failed to load '%s'",
			    cf->file_path);
d569 1
a569 2
	if ((b = cvs_buf_alloc(128, BUF_AUTOEXT)) == NULL)
		fatal("commit_diff: failed to create diff buf");
d601 1
a601 1
	bp = cvs_buf_load_fd(fd, BUF_AUTOEXT);
@


1.127
log
@CVSROOT/modules:

correct -i and -o usage

-i runs the program specified on commit
-o runs the program specified on checkout
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.126 2008/02/04 15:07:33 tobias Exp $	*/
d213 7
@


1.126
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.125 2008/01/31 22:11:38 joris Exp $	*/
d57 1
d59 1
a59 2
	char *arg = ".";
	int flags;
d61 1
d160 6
@


1.125
log
@free RCSNUM's when we are done with them;

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.124 2008/01/31 10:15:05 tobias Exp $	*/
d459 1
a459 1
		int kflag;
d461 2
a462 2
		kflag = rcs_kflag_get(cf->file_ent->ce_opts + 2);
		rcs_kwexp_set(cf->file_rcs, kflag);
@


1.124
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.123 2008/01/29 11:58:59 tobias Exp $	*/
d221 1
d529 3
@


1.123
log
@Properly free dynamically allocated memory.  Also skip needless checks.

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.122 2008/01/28 21:32:00 tobias Exp $	*/
d45 1
a45 1
	CVS_OP_COMMIT, 0, "commit",
@


1.122
log
@Zapped some variables which made the source harder to read (and to verify).

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.121 2008/01/28 21:26:51 tobias Exp $	*/
d150 1
a150 3
		if (logmsg != NULL)
			cvs_client_send_logmsg(logmsg);

d161 1
d172 2
d235 1
d243 2
d253 2
d261 5
d354 1
d371 2
@


1.121
log
@checkout's options -m and -F are mutually exclusive.  Also watch out to
properly free arguments if options are supplied multiple times.

OK ray@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.120 2008/01/28 20:31:07 tobias Exp $	*/
d522 1
a522 1
	BUF *b1, *b2;
d528 1
a528 1
		if ((b1 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
d531 2
a532 2
		cvs_buf_write_stmp(b1, p1, NULL);
		cvs_buf_free(b1);
d540 1
a540 1
	if ((b2 = cvs_buf_alloc(128, BUF_AUTOEXT)) == NULL)
d551 1
a551 1
	if (cvs_diffreg(p1, p2, b2) == D_ERROR)
d557 1
a557 1
	return (b2);
@


1.120
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.119 2008/01/13 11:15:19 tobias Exp $	*/
d57 1
a57 1
	int ch;
d63 1
d68 3
d72 1
d80 3
d84 1
d98 4
@


1.119
log
@Revision buffers are supposed to be of size CVS_REV_BUFSZ (32) instead
of 24.

OK xsa@@

> Diff from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.118 2008/01/13 11:11:08 tobias Exp $	*/
d78 1
@


1.118
log
@Typos fixed.

OK xsa@@

> Diff from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.117 2008/01/10 09:54:04 tobias Exp $	*/
d267 1
a267 1
	char rbuf[24], nbuf[24];
@


1.117
log
@Our keyword expansion had a big flaw, due to this construction:
if (!(mode & RCS_KWEXP_NONE))

RCS_KWEXP_NONE is defined to 0, so expansion happened always.

Left shifted all RCS_KWEXP defines and looked carefully at hard-coded values
throughout the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.116 2008/01/10 09:37:26 tobias Exp $	*/
d515 1
a515 1
			fatal("commit_diff_file: failed to load '%s'",
@


1.116
log
@RCS files without head keyword mustn't segfault our implementation.  Only
command that supports such files is "cvs status", therefore properly handle
them in all other commands, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.115 2007/10/08 14:13:13 joris Exp $	*/
d524 1
a524 1
	rcs_rev_write_stmp(cf->file_rcs, rev, p2, 0);
@


1.115
log
@do not try to reset the default branch if the RCS file
does not exist, fixes a segfault when commiting a new file.

found by tobias@@ who is going to make a nice little regression test for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.114 2007/10/03 13:12:06 joris Exp $	*/
d302 3
@


1.114
log
@reset the default branch early on so rcs_head_get() does not screw us up
and returns a possibly wrong revision as 'current revision'.

noticed by tobias@@ his regress testing
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.113 2007/09/24 13:56:09 joris Exp $	*/
d292 1
a292 1
	if (cf->file_rcs->rf_branch != NULL) {
@


1.113
log
@unused vars
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.112 2007/09/24 13:44:20 joris Exp $	*/
d292 5
a423 5
	}

	if (cf->file_rcs->rf_branch != NULL) {
		rcsnum_free(cf->file_rcs->rf_branch);
		cf->file_rcs->rf_branch = NULL;
@


1.112
log
@add support to commit modified files to branches.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.111 2007/09/23 11:19:24 joris Exp $	*/
d267 1
a267 1
	char foo[24], rbuf[24], nbuf[24];
@


1.111
log
@make sure when running update -r on existing files to overwrite
the sticky directory tag with it. since -r gets priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.110 2007/09/22 16:01:22 joris Exp $	*/
d33 1
a33 1
static BUF *commit_diff_file(struct cvs_file *);
d155 4
d196 45
d262 1
d264 2
a265 2
	int isnew, histtype;
	RCSNUM *head;
d267 1
a267 1
	char rbuf[24], nbuf[24];
d287 5
d295 38
a332 3
		head = rcs_head_get(cf->file_rcs);
		rcsnum_tostr(head, rbuf, sizeof(rbuf));
		rcsnum_free(head);
d388 2
a389 2
	if (isnew == 0)
		d = commit_diff_file(cf);
d392 1
a392 1
		b = rcs_rev_getbuf(cf->file_rcs, cf->file_rcs->rf_head, 0);
d394 3
a396 1
			fatal("cvs_commit_local: failed to get HEAD");
d402 2
a403 3
	if (isnew == 0) {
		if (rcs_deltatext_set(cf->file_rcs,
		    cf->file_rcs->rf_head, d) == -1)
d407 1
a407 1
	if (rcs_rev_add(cf->file_rcs, RCS_HEAD_REV, logmsg, -1, NULL) == -1)
d410 4
a413 1
	if (rcs_deltatext_set(cf->file_rcs, cf->file_rcs->rf_head, b) == -1)
d417 1
a417 2
		if (rcs_state_set(cf->file_rcs,
		    cf->file_rcs->rf_head, RCS_STATE_DEAD) == -1)
d441 1
a441 2
			rcsnum_tostr(cf->file_rcs->rf_head,
			    nbuf, sizeof(nbuf));
d443 1
a443 1
		rcsnum_tostr(cf->file_rcs->rf_head, nbuf, sizeof(nbuf));
d454 1
a454 1
		cvs_checkout_file(cf, cf->file_rcs->rf_head, NULL, CO_COMMIT);
d502 1
a502 1
commit_diff_file(struct cvs_file *cf)
d504 1
a504 1
	char *p1, *p2;
d517 1
a517 1
		rcs_rev_write_stmp(cf->file_rcs, cf->file_rcs->rf_head, p1, 0);
d521 1
a521 1
	rcs_rev_write_stmp(cf->file_rcs, cf->file_rcs->rf_head, p2, 0);
d524 1
a524 1
		fatal("commit_diff_file: failed to create diff buf");
d527 7
d535 1
a535 1
		fatal("commit_diff_file: failed to get RCS patch");
@


1.110
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.109 2007/08/30 11:07:18 joris Exp $	*/
d362 1
a362 1
		cvs_checkout_file(cf, cf->file_rcs->rf_head, CO_COMMIT);
@


1.109
log
@properly send our log message to the server using Argumentx, so we
no longer break when the log message has multiple lines.

from Tobias Stoeckmann, thanks for doing my work!
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.108 2007/06/28 17:45:49 joris Exp $	*/
d160 1
a160 1
		cvs_file_classify(cf, NULL);
d195 1
a195 1
		cvs_file_get(cf->file_path, &files_affected);
d199 1
a199 1
		cvs_file_get(cf->file_path, &files_added);
d202 1
a202 1
		cvs_file_get(cf->file_path, &files_removed);
d205 1
a205 1
		cvs_file_get(cf->file_path, &files_modified);
d222 1
a222 1
	cvs_file_classify(cf, NULL);
@


1.108
log
@When commiting to a server in a remote setup classify
the files based upon their entry in CVS/Entries instead of
using the local classifying code and trying to locate the RCSfile
on our local disks, which ofc does not work correctly.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.107 2007/06/18 17:54:13 joris Exp $	*/
d136 2
a137 1
		cvs_client_send_request("Argument -m%s", logmsg);
@


1.107
log
@first stab at history stuff for opencvs, currently only writes
to CVSROOT/history but cannot parse it yet with the 'history' command.

"Commit it." ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.106 2007/06/01 17:47:47 niallo Exp $	*/
d156 4
a159 1
	cvs_file_classify(cf, NULL);
@


1.106
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.105 2007/02/22 06:42:09 otto Exp $	*/
d210 1
a210 1
	int isnew;
d226 7
d389 14
@


1.105
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.104 2007/02/09 03:49:15 joris Exp $	*/
d242 1
a242 1
			if (cf->file_rcs->rf_inattic == 0)
@


1.104
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.103 2007/02/01 20:33:03 otto Exp $	*/
d19 6
a24 1
#include "includes.h"
a27 1
#include "log.h"
@


1.103
log
@change mode of a newly created rcs file in the repository to 0444
ok jorix@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.102 2007/01/31 21:07:35 xsa Exp $	*/
d152 1
a152 5
	/*
	 * cvs_file_classify makes the noise for us
	 * XXX - we want that?
	 */
	cvs_file_classify(cf, NULL, 1);
d214 1
a214 1
	cvs_file_classify(cf, NULL, 0);
@


1.102
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.101 2007/01/26 21:48:17 xsa Exp $	*/
d273 1
a273 1
		    rcsflags, 0600);
@


1.101
log
@- support [-k mode] for the add command
- do not let the file keyword expension options (-k) disappear
from the Entries file when doing a commit/update/checkout
- be sure the expension mode gets written to the RCS file when a file
is added/committed in the first place
problems raised by otto@@; tests/ok otto@@ and joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.100 2007/01/25 18:56:33 otto Exp $	*/
d212 1
a212 1
	int l, openflags, rcsflags;
d251 1
a251 1
			l = snprintf(rcsfile, MAXPATHLEN, "%s/%s%s",
a252 2
			if (l == -1 || l >= MAXPATHLEN)
				fatal("cvs_commit_local: overflow");
d359 2
a360 3
		l = snprintf(attic, MAXPATHLEN, "%s/%s", repo, CVS_PATH_ATTIC);
		if (l == -1 || l >= MAXPATHLEN)
			fatal("cvs_commit_local: overflow");
d365 1
a365 1
		l = snprintf(attic, MAXPATHLEN, "%s/%s/%s%s", repo,
a366 2
		if (l == -1 || l >= MAXPATHLEN)
			fatal("cvs_commit_local: overflow");
d423 1
a423 1
	int l, fd;
d426 1
a426 1
	l = snprintf(desc_path, MAXPATHLEN, "%s/%s%s",
a427 2
	if (l == -1 || l >= MAXPATHLEN)
		fatal("commit_desc_set: overflow");
@


1.100
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.99 2007/01/18 15:26:52 xsa Exp $	*/
d322 7
@


1.99
log
@send -l Argument to server when appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.98 2007/01/14 23:10:56 joris Exp $	*/
d215 1
a215 1
	char *attic, *repo, *rcsfile;
a249 2
			rcsfile = xmalloc(MAXPATHLEN);
			repo = xmalloc(MAXPATHLEN);
a262 2
			xfree(rcsfile);
			xfree(repo);
a351 2
		repo = xmalloc(MAXPATHLEN);
		attic = xmalloc(MAXPATHLEN);
a369 3
		xfree(repo);
		xfree(attic);

d422 1
a422 1
	char *desc_path, *desc;
a423 1
	desc_path = xmalloc(MAXPATHLEN);
d429 1
a429 2
	if ((fd = open(desc_path, O_RDONLY)) == -1) {
		xfree(desc_path);
a430 1
	}
a441 1
	xfree(desc_path);
@


1.98
log
@move things around in rcs_rev_getbuf() and rcs_rev_write_fd()
so that we do keyword expansion on-the-fly if required instead
of obtaining the revision in memory first, running over the revision
lines while expanding keywords and only then writing them to the fd
or memory buffer.

this drasticly decreases cpu usage by opencvs on very large trees (like src).

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.97 2007/01/13 18:28:27 joris Exp $	*/
d128 3
@


1.97
log
@switch commit code to the new RCS api.
kay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.96 2007/01/13 15:56:15 joris Exp $	*/
d294 1
a294 1
		b = rcs_rev_getbuf(cf->file_rcs, cf->file_rcs->rf_head);
@


1.96
log
@plug 3 memleaks
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.95 2007/01/13 15:45:59 joris Exp $	*/
d392 3
a394 1
	BUF *b1, *b2, *b3;
d401 2
d404 1
a404 4
		b1 = rcs_rev_getbuf(cf->file_rcs, cf->file_rcs->rf_head);
		if (b1 == NULL)
			fatal("commit_diff_file: failed to load HEAD");
		b1 = rcs_kwexp_buf(b1, cf->file_rcs, cf->file_rcs->rf_head);
d407 2
a408 3
	if ((b2 = rcs_rev_getbuf(cf->file_rcs, cf->file_rcs->rf_head)) == NULL)
		fatal("commit_diff_file: failed to load HEAD for '%s'",
		    cf->file_path);
d410 1
a410 1
	if ((b3 = cvs_buf_alloc(128, BUF_AUTOEXT)) == NULL)
a412 8
	(void)xasprintf(&p1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
	cvs_buf_write_stmp(b1, p1, NULL);
	cvs_buf_free(b1);

	(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
	cvs_buf_write_stmp(b2, p2, NULL);
	cvs_buf_free(b2);

d414 1
a414 1
	if (cvs_diffreg(p1, p2, b3) == D_ERROR)
d420 1
a420 1
	return (b3);
@


1.95
log
@remove BUF * argument from cvs_checkout_file() it will
no longer be used, ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.94 2007/01/12 23:32:01 niallo Exp $	*/
d424 3
@


1.94
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.93 2007/01/12 19:28:12 joris Exp $	*/
d347 1
a347 5
		b = rcs_getrev(cf->file_rcs, cf->file_rcs->rf_head);
		if (b == NULL)
			fatal("cvs_commit_local: failed to get HEAD");

		cvs_checkout_file(cf, cf->file_rcs->rf_head, b, CO_COMMIT);
@


1.93
log
@do not leak memory from rcs_head_get()

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.92 2007/01/12 18:27:18 joris Exp $	*/
d294 1
a294 1
		b = rcs_getrev(cf->file_rcs, cf->file_rcs->rf_head);
d404 1
a404 1
		b1 = rcs_getrev(cf->file_rcs, cf->file_rcs->rf_head);
d410 1
a410 1
	if ((b2 = rcs_getrev(cf->file_rcs, cf->file_rcs->rf_head)) == NULL)
@


1.92
log
@if we have no files to be commited, stop commiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.91 2007/01/12 17:25:33 joris Exp $	*/
d208 1
d225 5
a229 3
	    && cf->file_rcs != NULL && cf->file_rcs->rf_dead == 1))
		rcsnum_tostr(rcs_head_get(cf->file_rcs), rbuf, sizeof(rbuf));
	else
d231 1
@


1.91
log
@complete binary support for opencvs,
adding/importing binary files now works too

partially taken from openrcs
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.90 2007/01/11 18:06:49 jasper Exp $	*/
d104 3
@


1.90
log
@silence some warnings.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.89 2007/01/11 02:35:55 joris Exp $	*/
d29 1
a29 1
static char *commit_diff_file(struct cvs_file *);
d203 1
a203 1
	BUF *b;
d206 1
a206 2
	char *f, rbuf[24], nbuf[24];
	char *d = NULL;
a294 3
	cvs_buf_putc(b, '\0');
	f = cvs_buf_release(b);

d304 1
a304 1
	if (rcs_deltatext_set(cf->file_rcs, cf->file_rcs->rf_head, f) == -1)
a306 5
	xfree(f);

	if (isnew == 0)
		xfree(d);

d385 1
a385 1
static char *
d388 1
a388 1
	char*delta,  *p1, *p2;
d422 1
a422 3
	cvs_buf_putc(b3, '\0');
	delta = cvs_buf_release(b3);
	return (delta);
@


1.89
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.88 2007/01/07 03:08:15 joris Exp $	*/
a53 1
	BUF *bp;
d206 2
a207 1
	char *d, *f, rbuf[24], nbuf[24];
d209 1
a209 1
	char *attic, *repo, *rcsfile, *p;
@


1.88
log
@use cvs_logmsg_read() for -F for simplicity.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.87 2007/01/07 02:44:13 joris Exp $	*/
d119 1
@


1.87
log
@free the filelists we pass to cvs_logmsg_create()
after we obtain our logmessage.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.86 2007/01/07 02:39:24 joris Exp $	*/
d64 1
a64 5
			bp = cvs_buf_load(optarg, BUF_AUTOEXT);
			if (bp == NULL)
				fatal("failed to load commit message %s", optarg);
			cvs_buf_putc(bp, '\0');
			logmsg = cvs_buf_release(bp);
@


1.86
log
@rewrite of the logmessage code, which allows you to
enter a logmessage into your favorite editor when commiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.85 2007/01/03 22:28:30 joris Exp $	*/
d117 4
@


1.85
log
@add support for 'remove' in a remote setup.
testing appriciated, as always.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.84 2007/01/03 20:48:26 joris Exp $	*/
d27 1
a27 1
void	cvs_commit_check_conflicts(struct cvs_file *);
d33 4
d38 1
a38 1
char	*logmsg;
d90 25
a114 1
	/* XXX */
d116 1
a116 1
		fatal("please use -m or -F to specify a log message for now");
a118 2
		cr.enterdir = NULL;
		cr.leavedir = NULL;
a119 1
		cr.flags = flags;
d132 4
a135 1
		return (0);
a137 21
	TAILQ_INIT(&files_affected);
	conflicts_found = 0;

	cr.enterdir = NULL;
	cr.leavedir = NULL;
	cr.fileproc = cvs_commit_check_conflicts;
	cr.flags = flags;

	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);

	if (conflicts_found != 0)
		fatal("%d conflicts found, please correct these first",
		    conflicts_found);

	cr.fileproc = cvs_commit_local;
	cvs_file_walklist(&files_affected, &cr);
	cvs_file_freelist(&files_affected);

d142 1
a142 1
cvs_commit_check_conflicts(struct cvs_file *cf)
d144 1
a144 1
	cvs_log(LP_TRACE, "cvs_commit_check_conflicts(%s)", cf->file_path);
d186 12
@


1.84
log
@if we are commiting a file, do not let the server resend it
with an 'Updated' response, seeing as the client will already have the
latest version. Instead, send the correct 'Checked-in' response.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.83 2007/01/02 23:55:15 joris Exp $	*/
d361 3
a370 14
	}

	if (cvs_server_active == 1) {
		if ((p = strrchr(cf->file_rpath, ',')) != NULL)
			*p = '\0';

		if (cf->file_status == FILE_REMOVED) {
			cvs_server_send_response("Remove-entry %s/",
			    cf->file_wd);
			cvs_remote_output(cf->file_rpath);
		}

		if (p != NULL)
			*p = ',';
@


1.83
log
@- fix cvs_client_remove_entry to correctly handle the passed data
- when commiting in a remote setup, allow the opencvs server to send
  the correct response to the client when a file has been removed
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.82 2006/12/31 15:11:23 xsa Exp $	*/
d333 1
a333 1
		cvs_checkout_file(cf, cf->file_rcs->rf_head, b, 0);
@


1.82
log
@minor nits;
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.81 2006/07/08 09:25:44 ray Exp $	*/
d189 1
a189 1
	char *attic, *repo, *rcsfile;
d368 14
@


1.81
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.80 2006/07/07 17:37:17 joris Exp $	*/
a58 2
		case 'f':
			break;
d62 1
a62 2
				fatal("failed to load commit message %s",
				    optarg);
d66 2
d74 2
a77 2
		case 'R':
			break;
d86 1
@


1.80
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.79 2006/07/02 21:01:48 joris Exp $	*/
d397 1
a397 1
	cvs_buf_write_stmp(b1, p1, 0600, NULL);
d401 1
a401 1
	cvs_buf_write_stmp(b2, p2, 0600, NULL);
@


1.79
log
@- abort the commit when files are not correctly up to date.
- do not try to attempt to check for conflict markers when the file is not on disk.

found by and okay reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.78 2006/06/29 00:41:52 joris Exp $	*/
d24 1
a25 1
int	cvs_commit(int, char **);
d89 20
@


1.78
log
@it is a really good idea to store the result cvs_buf_load_fd returns
in bp, considering we depend on that.

found by reyk who is now my favorite german person, 10x.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.77 2006/06/28 18:52:05 reyk Exp $	*/
d132 1
a132 2
	    cf->file_status == FILE_LOST ||
	    cf->file_status == FILE_UNLINK)
d134 2
d142 1
d147 2
a148 1
	    cf->file_status == FILE_CHECKOUT) {
d152 1
@


1.77
log
@print less verbose messages for cvs commit and add if the -q/-Q flag
has been specified.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.76 2006/06/28 17:59:06 joris Exp $	*/
d407 1
a407 1
	cvs_buf_load_fd(fd, BUF_AUTOEXT);
@


1.76
log
@do not fail when we are trying to commit a newly added file when the CVS/*,t
file is not present for the file.

spotted and tested by reyk@@
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.75 2006/06/19 05:05:17 joris Exp $	*/
d163 1
a163 1
	char *d, *f, rbuf[24];
d234 5
a238 3
	cvs_printf("Checking in %s:\n", cf->file_path);
	cvs_printf("%s <- %s\n", cf->file_rpath, cf->file_path);
	cvs_printf("old revision: %s; ", rbuf);
d286 1
a286 1
		strlcpy(rbuf, "Removed", sizeof(rbuf));
d289 1
a289 1
			strlcpy(rbuf, "Initial Revision", sizeof(rbuf));
d292 1
a292 1
			    rbuf, sizeof(rbuf));
d294 1
a294 1
		rcsnum_tostr(cf->file_rcs->rf_head, rbuf, sizeof(rbuf));
d297 2
a298 1
	cvs_printf("new revision: %s\n", rbuf);
d339 6
a344 2
	cvs_printf("done\n");

@


1.75
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.74 2006/06/16 14:07:42 joris Exp $	*/
d386 1
a386 1
	int l;
d395 1
a395 1
	if ((bp = cvs_buf_load(desc_path, BUF_AUTOEXT)) == NULL) {
d400 1
d406 1
@


1.74
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.73 2006/06/14 14:10:50 joris Exp $	*/
d95 1
a95 2
	cr.local = cvs_commit_check_conflicts;
	cr.remote = NULL;
d107 1
a107 1
	cr.local = cvs_commit_local;
@


1.73
log
@add cvs_buf_load_fd() which does the same as cvs_buf_load()
except it takes a decriptor as argument instead of a path.

modified cvs_buf_load() to open the descriptor then pass
it to cvs_buf_load_fd().

change all the calls to cvs_buf_load() that have a descriptor
open for the path to cvs_buf_load_fd() to prevent races.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.72 2006/06/13 06:51:32 joris Exp $	*/
a23 1
#include "proto.h"
d37 1
a37 1
	CVS_OP_COMMIT, CVS_REQ_CI, "commit",
@


1.72
log
@files that are not checked out are not up-to-date, consider
this a conflict and block the commit when we encounter any of these.

and make an error message a bit more fluffy and accurate.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.71 2006/06/07 07:01:12 xsa Exp $	*/
d248 1
a248 1
		if ((b = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
d350 1
a350 1
		if ((b1 = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
@


1.71
log
@add support for <name>,t file:
- add: creates <name>,t file with initial description if -m option was used.
- commit: uses <name>,t content (if it exists) to set the file description
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.70 2006/06/06 05:18:23 joris Exp $	*/
d89 1
a89 1
		fatal("please use -m to specify a log message for now");
d146 2
a147 1
	    cf->file_status == FILE_PATCH) {
@


1.70
log
@hello commit -F support
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.69 2006/06/04 09:52:56 joris Exp $	*/
d4 1
d31 1
d231 2
d381 29
@


1.69
log
@sprinkle -n voodoo over the add, commit and import commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.68 2006/06/01 20:00:52 joris Exp $	*/
d49 1
d61 6
@


1.68
log
@major rewrite of some rcs parsing stuff:

- rework rcs_getrev() to correctly support branches
- rework rcs_translate_tag() to correctly translate given symbols or
  branches into their matching revisions
- rework rcs_rev_add() to correctly update its 'next' pointers
  and insert the new revision in the correct place on the list.
- rework rcs_head_get() to return the latest revision on the default
  branch if it has been set or the normal HEAD revision otherwise.
- no longer access the rf_head member of the RCSFILE struct manually,
  use the rcs_head_get() function which correctly returns the HEAD
  revision, there might be a default branch that has to be used.
- for now, when commiting a new revision reset the default branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.67 2006/05/31 23:27:38 joris Exp $	*/
d161 3
@


1.67
log
@when adding a new file that already exists set the previous
deltatext (the dead revision) to the correct rcs diff if the file
was modified in any way.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.66 2006/05/31 01:26:21 joris Exp $	*/
d168 1
a168 1
		rcsnum_tostr(cf->file_rcs->rf_head, rbuf, sizeof(rbuf));
d261 5
@


1.66
log
@allow commit to ressurect added files that exist in Attic/
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.65 2006/05/30 21:32:52 joris Exp $	*/
d153 1
d172 1
d174 1
d207 1
d225 1
a225 1
	if (cf->file_status != FILE_ADDED)
d240 1
a240 1
	if (cf->file_status != FILE_ADDED) {
d254 1
a254 1
	if (cf->file_status != FILE_ADDED)
@


1.65
log
@fill in the correct revision number we will want in file_rcsrev
for each cvs_file struct, this will help us with sticky tags,
commiting to branches and importing into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.64 2006/05/30 04:20:27 joris Exp $	*/
d153 1
a153 1
	int l, isadded;
d156 1
a156 1
	char *attic, *repo;
d165 2
a166 1
	    cf->file_status == FILE_REMOVED)
d171 36
a206 3
	isadded = (cf->file_status == FILE_ADDED && cf->file_rcs == NULL);
	if (isadded) {
		cf->repo_fd = open(cf->file_rpath, O_CREAT|O_TRUNC|O_WRONLY);
d211 1
a211 1
		    RCS_CREATE, 0600);
d221 1
a221 1
	if (isadded == 0)
d236 1
a236 1
	if (isadded == 0) {
d250 1
a250 1
	if (isadded == 0)
d264 1
a264 1
		if (cf->file_rcs->rf_dead == 0)
@


1.64
log
@the moment we are done commiting a removed file, move the RCS file
into the Attic and out of our way.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.63 2006/05/28 10:15:35 joris Exp $	*/
d116 1
a116 1
	cvs_file_classify(cf, 1);
d159 1
a159 1
	cvs_file_classify(cf, 0);
@


1.63
log
@enable basic add command, only works on files right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.62 2006/05/28 07:56:44 joris Exp $	*/
d153 1
a153 1
	int isadded;
d156 1
d161 3
d255 23
@


1.62
log
@allow commands to shut up the output from cvs_file_classify
if the commands want to output certain stuff themselfs
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.61 2006/05/28 04:32:54 joris Exp $	*/
d129 2
a130 1
	if (update_has_conflict_markers(cf)) {
d153 1
d166 2
a167 1
	if (cf->file_status == FILE_ADDED) {
d183 1
a183 1
	if (cf->file_status != FILE_ADDED)
d198 1
a198 1
	if (cf->file_status != FILE_ADDED) {
d212 1
a212 1
	if (cf->file_status != FILE_ADDED)
d226 5
a230 1
		strlcpy(rbuf, "Initial Revision", sizeof(rbuf));
d263 2
a264 1
	if (cf->file_status == FILE_MODIFIED) {
d268 1
a268 1
	} else if (cf->file_status == FILE_REMOVED) {
@


1.61
log
@teach opencvs ci how to commit files that have been added,
opencvs can now commit modified files, removed files and added files.

hip hip hurray!
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.60 2006/05/28 01:24:28 joris Exp $	*/
d116 1
a116 1
	cvs_file_classify(cf);
d156 1
a156 1
	cvs_file_classify(cf);
@


1.60
log
@enable merging on update. if your file in your working copy
has been modified by yourself and there is a newer revision
we try and merge them together.

if the merge fails and has conflicts it will mark them inside
the file, you will need to resolve these by hand first before
you will be able to commit your modified file.

works transparent with gnu cvs, as it is suppose to.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.59 2006/05/27 15:17:42 joris Exp $	*/
d152 1
a152 1
	char *d, *f, rbuf[16];
d161 14
d180 2
a181 1
	d = commit_diff_file(cf);
d187 1
a187 1
	} else if (cf->file_status == FILE_MODIFIED) {
d195 5
a199 2
	if (rcs_deltatext_set(cf->file_rcs, cf->file_rcs->rf_head, d) == -1)
		fatal("cvs_commit_local: failed to set delta");
d208 3
a210 1
	xfree(d);
d222 2
@


1.59
log
@show which directory we are examining in our pre-commit checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.58 2006/05/27 15:14:27 joris Exp $	*/
d129 6
d213 5
a217 1
		cvs_checkout_file(cf, cf->file_rcs->rf_head, 0);
@


1.58
log
@allow commands to respect the -l flag, if the -l flag is
specified certain commands will not recurse into directories.

at the same time introduce a method of specifying wether or not
a command should look in the repository for files.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.57 2006/05/27 14:05:53 joris Exp $	*/
d117 6
@


1.57
log
@dont allow commit to continue if the file that is being
commited needs to be updated or merged first.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.56 2006/05/27 06:16:14 joris Exp $	*/
d50 1
d53 2
d62 1
d89 1
@


1.56
log
@commiting removed files now works
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.55 2006/05/27 03:30:30 joris Exp $	*/
d117 7
@


1.55
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d129 1
d134 3
a136 1
	rcsnum_tostr(cf->file_rcs->rf_head, rbuf, sizeof(rbuf));
d144 8
a151 2
	if ((b = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
		fatal("cvs_commit_local: failed to load file");
d168 6
d176 6
a181 1
	rcsnum_tostr(cf->file_rcs->rf_head, rbuf, sizeof(rbuf));
d187 8
a194 1
	cvs_checkout_file(cf, cf->file_rcs->rf_head, 0);
d206 10
a215 2
	if ((b1 = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
		fatal("commit_diff_file: failed to load '%s'", cf->file_path);
@


1.54
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.53 2006/04/01 20:11:25 joris Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a19 1
#include "buf.h"
d21 1
d25 9
a33 6

static int	cvs_commit_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_commit_prepare(CVSFILE *, void *);
static int	cvs_commit_remote(CVSFILE *, void *);
static int	cvs_commit_local(CVSFILE *, void *);
static int	cvs_commit_pre_exec(struct cvsroot *);
d37 1
a37 1
	{ "ci",  "com" },
d42 1
a42 8
	CF_RECURSE | CF_IGNORE | CF_SORT,
	cvs_commit_init,
	cvs_commit_pre_exec,
	cvs_commit_remote,
	cvs_commit_local,
	NULL,
	NULL,
	CVS_CMD_SENDDIR | CVS_CMD_ALLOWSPEC | CVS_CMD_SENDARGS2
d45 2
a46 8
static char *mfile = NULL;
static char *rev = NULL;
static char **commit_files = NULL;
static int commit_fcount = 0;
static int wantedstatus = 0;

static int
cvs_commit_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d49 2
d52 1
a52 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
d54 2
a56 5
			mfile = optarg;
			break;
		case 'f':
			/* XXX half-implemented */
			cmd->file_flags &= ~CF_RECURSE;
a58 1
			cmd->file_flags &= ~CF_RECURSE;
d61 3
a63 1
			cvs_msg = xstrdup(optarg);
a65 4
			cmd->file_flags |= CF_RECURSE;
			break;
		case 'r':
			rev = optarg;
d68 1
a68 1
			return (CVS_EX_USAGE);
d72 2
a73 4
	if (cvs_msg != NULL && mfile != NULL) {
		cvs_log(LP_ERR, "the -F and -m flags are mutually exclusive");
		return (CVS_EX_USAGE);
	}
d75 2
a76 2
	if (mfile != NULL)
		cvs_msg = cvs_logmsg_open(mfile);
d78 2
a79 1
	*arg = optind;
d81 17
a97 2
	commit_files = (argv + optind);
	commit_fcount = (argc - optind);
d102 2
a103 2
int
cvs_commit_pre_exec(struct cvsroot *root)
d105 1
a105 16
	CVSFILE *cfp;
	CVSFILE *tmp;
	int ret, i, flags = CF_RECURSE | CF_IGNORE | CF_SORT;
	struct cvs_flist added, modified, removed, *cl[3];
	int stattype[] = { CVS_FST_ADDED, CVS_FST_MODIFIED, CVS_FST_REMOVED };

	SIMPLEQ_INIT(&added);
	SIMPLEQ_INIT(&modified);
	SIMPLEQ_INIT(&removed);

	cl[0] = &added;
	cl[1] = &modified;
	cl[2] = &removed;

	if ((tmp = cvs_file_loadinfo(".", CF_NOFILES, NULL, NULL, 1)) == NULL)
		return (CVS_EX_DATA);
d108 2
a109 1
	 * Obtain the file lists for the logmessage.
d111 1
a111 9
	for (i = 0; i < 3; i++) {
		wantedstatus = stattype[i];
		if (commit_fcount != 0) {
			ret = cvs_file_getspec(commit_files, commit_fcount,
			    flags, cvs_commit_prepare, cl[i], NULL);
		} else {
			ret = cvs_file_get(".", flags, cvs_commit_prepare,
			    cl[i], NULL);
		}
d113 10
a122 5
		if (ret != CVS_EX_OK) {
			cvs_file_free(tmp);
			return (CVS_EX_DATA);
		}
	}
d124 5
a128 26
	/*
	 * If we didn't catch any file, don't call the editor.
	 */
	if (SIMPLEQ_EMPTY(&added) && SIMPLEQ_EMPTY(&modified) &&
	    SIMPLEQ_EMPTY(&removed)) {
		cvs_file_free(tmp);
		return (0);
	}

	/*
	 * Fetch the log message for real, with all the files.
	 */
	if (cvs_msg == NULL)
		cvs_msg = cvs_logmsg_get(tmp->cf_name, &added, &modified,
		    &removed);

	cvs_file_free(tmp);

	/* free the file lists */
	for (i = 0; i < 3; i++) {
		while (!SIMPLEQ_EMPTY(cl[i])) {
			cfp = SIMPLEQ_FIRST(cl[i]);
			SIMPLEQ_REMOVE_HEAD(cl[i], cf_list);
			cvs_file_free(cfp);
		}
	}
d130 2
a131 2
	if (cvs_msg == NULL)
		return (CVS_EX_DATA);
d133 1
a133 2
	if (root->cr_method != CVS_METHOD_LOCAL) {
		cvs_logmsg_send(root, cvs_msg);
d135 3
a137 5
		if (rev != NULL) {
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, rev, 0);
		}
	}
d139 1
a139 2
	return (0);
}
d141 2
a142 11
/*
 * cvs_commit_prepare()
 *
 * Examine the file <cf> to see if it will be part of the commit, in which
 * case it gets added to the list passed as second argument.
 */
int
cvs_commit_prepare(CVSFILE *cf, void *arg)
{
	CVSFILE *copy;
	struct cvs_flist *clp = (struct cvs_flist *)arg;
d144 2
a145 4
	if (cf->cf_type == DT_REG && cf->cf_cvstat == wantedstatus) {
		copy = cvs_file_copy(cf);
		if (copy == NULL)
			return (CVS_EX_DATA);
d147 2
a148 2
		SIMPLEQ_INSERT_TAIL(clp, copy, cf_list);
	}
d150 2
a151 2
	return (0);
}
d153 2
d156 2
a157 10
/*
 * cvs_commit_remote()
 *
 * Commit a single file.
 */
int
cvs_commit_remote(CVSFILE *cf, void *arg)
{
	char fpath[MAXPATHLEN];
	struct cvsroot *root;
d159 1
a159 1
	root = CVS_DIR_ROOT(cf);
d161 2
a162 5
	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat != CVS_FST_UNKNOWN)
			cvs_senddir(root, cf);
		return (0);
	}
d164 4
a167 1
	cvs_file_getpath(cf, fpath, sizeof(fpath));
d169 1
a169 11
	if (cf->cf_cvstat == CVS_FST_ADDED ||
	    cf->cf_cvstat == CVS_FST_MODIFIED ||
	    cf->cf_cvstat == CVS_FST_REMOVED) {
		cvs_sendentry(root, cf);

		/* if it's removed, don't bother sending a
		 * Modified request together with the file its
		 * contents.
		 */
		if (cf->cf_cvstat == CVS_FST_REMOVED)
			return (0);
a170 5
		cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name);
		cvs_sendfile(root, fpath);
	}

	return (0);
d173 2
a174 2
static int
cvs_commit_local(CVSFILE *cf, void *arg)
d176 2
a177 1
	char fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
d179 2
a180 8
	if (cf->cf_type == DT_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Examining %s", cf->cf_name);
		return (0);
	}

	cvs_file_getpath(cf, fpath, sizeof(fpath));
	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));
d182 22
a203 1
	return (0);
@


1.53
log
@fix some bugs that lint discovered for us.
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.52 2006/03/16 09:06:19 xsa Exp $	*/
d95 1
a95 1
	if ((cvs_msg != NULL) && (mfile != NULL)) {
d204 1
a204 1
	if ((cf->cf_type == DT_REG) && (cf->cf_cvstat == wantedstatus)) {
d237 3
a239 3
	if ((cf->cf_cvstat == CVS_FST_ADDED) ||
	    (cf->cf_cvstat == CVS_FST_MODIFIED) ||
	    (cf->cf_cvstat == CVS_FST_REMOVED)) {
@


1.52
log
@zap more unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.51 2006/01/02 08:11:56 xsa Exp $	*/
d224 1
a224 1
	char *repo, fpath[MAXPATHLEN];
a226 1
	repo = NULL;
a235 3

	if (cf->cf_parent != NULL)
		repo = cf->cf_parent->cf_repo;
@


1.51
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.50 2005/12/30 02:03:28 joris Exp $	*/
a223 1
	int ret;
a224 1
	RCSFILE *rf;
a226 2
	ret = 0;
	rf = NULL;
@


1.50
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.49 2005/12/22 14:59:54 xsa Exp $	*/
d27 1
a27 10
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.49
log
@cvs_rcs_getpath() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.48 2005/12/21 20:06:25 xsa Exp $	*/
d190 1
a190 2
		if (cvs_logmsg_send(root, cvs_msg) < 0)
			return (CVS_EX_PROTO);
d193 2
a194 3
			if ((cvs_sendarg(root, "-r", 0) < 0) ||
			    (cvs_sendarg(root, rev, 0) < 0))
				return (CVS_EX_PROTO);
d244 2
a245 4
		if (cf->cf_cvstat != CVS_FST_UNKNOWN) {
			if (cvs_senddir(root, cf) < 0)
				return (CVS_EX_PROTO);
		}
d257 1
a257 3
		if (cvs_sendentry(root, cf) < 0) {
			return (CVS_EX_PROTO);
		}
d266 2
a267 6
		if (cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name) < 0)
			return (CVS_EX_PROTO);

		if (cvs_sendfile(root, fpath) < 0) {
			return (CVS_EX_PROTO);
		}
@


1.48
log
@cvs_logmsg_open() and cvs_logmsg_get() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.47 2005/12/10 20:27:45 joris Exp $	*/
d295 1
a295 3

	if (cvs_rcs_getpath(cf, rcspath, sizeof(rcspath)) == NULL)
		return (CVS_EX_DATA);
@


1.47
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.46 2005/07/27 16:42:19 xsa Exp $	*/
d109 2
a110 2
	if ((mfile != NULL) && (cvs_msg = cvs_logmsg_open(mfile)) == NULL)
		return (CVS_EX_DATA);
@


1.46
log
@use LP_NOTICE instead of LP_INFO where appropriate;
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.45 2005/07/25 12:05:43 xsa Exp $	*/
d91 1
a91 5
			cvs_msg = strdup(optarg);
			if (cvs_msg == NULL) {
				cvs_log(LP_ERRNO, "failed to copy message");
				return (CVS_EX_USAGE);
			}
@


1.45
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.44 2005/07/23 11:19:46 joris Exp $	*/
d294 1
a294 1
			cvs_log(LP_INFO, "Examining %s", cf->cf_name);
@


1.44
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.43 2005/07/23 00:03:00 joris Exp $	*/
d44 5
a48 5
static int cvs_commit_init    (struct cvs_cmd *, int, char **, int *);
static int cvs_commit_prepare (CVSFILE *, void *);
static int cvs_commit_remote  (CVSFILE *, void *);
static int cvs_commit_local   (CVSFILE *, void *);
static int cvs_commit_pre_exec(struct cvsroot *);
@


1.43
log
@correctly seperate added, modified and removed files for use in the
construction of the log message in the editor.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.42 2005/07/22 16:27:29 joris Exp $	*/
d129 1
a129 1
	int i, flags = CF_RECURSE | CF_IGNORE | CF_SORT;
d141 3
a146 1
	tmp = NULL;
a147 3
		if (tmp != NULL)
			cvs_file_free(tmp);

a148 1

d150 2
a151 2
			tmp = cvs_file_getspec(commit_files, commit_fcount,
			    flags, cvs_commit_prepare, cl[i]);
d153 2
a154 2
			tmp = cvs_file_get(".", flags, cvs_commit_prepare,
			    cl[i]);
d157 2
a158 1
		if (tmp == NULL)
d160 1
@


1.42
log
@use the cf_name field of the CVSFILE struct instead of using the old
CVS_FILE_NAME macro. This macro used to be nifty because of all
the referencing for the names, but since we don't do that anymore and
use cf_name directly... byebye CVS_FILE_NAME()

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.41 2005/07/19 00:32:26 joris Exp $	*/
d71 1
a126 1
	struct cvs_flist cl;
d129 29
a157 3
	int flags = CF_RECURSE | CF_IGNORE | CF_SORT;

	SIMPLEQ_INIT(&cl);
d159 2
a160 5
	if (commit_fcount != 0) {
		tmp = cvs_file_getspec(commit_files, commit_fcount,
		    flags, cvs_commit_prepare, &cl);
	} else {
		tmp = cvs_file_get(".", flags, cvs_commit_prepare, &cl);
d163 5
a167 4
	if (tmp == NULL)
		return (CVS_EX_DATA);

	if (SIMPLEQ_EMPTY(&cl)) {
d172 3
d176 2
a177 2
		cvs_msg = cvs_logmsg_get(tmp->cf_name,
		    NULL, &cl, NULL);
d181 7
a187 4
	while (!SIMPLEQ_EMPTY(&cl)) {
		cfp = SIMPLEQ_FIRST(&cl);
		SIMPLEQ_REMOVE_HEAD(&cl, cf_list);
		cvs_file_free(cfp);
d219 1
a219 3
	if ((cf->cf_type == DT_REG) && ((cf->cf_cvstat == CVS_FST_MODIFIED) ||
	    (cf->cf_cvstat == CVS_FST_ADDED) ||
	    (cf->cf_cvstat == CVS_FST_REMOVED))) {
@


1.41
log
@unbreak the commit command.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.40 2005/07/14 06:50:50 xsa Exp $	*/
d149 1
a149 1
		cvs_msg = cvs_logmsg_get(CVS_FILE_NAME(tmp),
d248 1
a248 2
		if (cvs_sendreq(root, CVS_REQ_MODIFIED,
		    CVS_FILE_NAME(cf)) < 0) {
a249 1
		}
@


1.40
log
@use cvs_rcs_getpath();
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.39 2005/07/12 07:12:13 xsa Exp $	*/
d64 1
a64 1
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDARGS2
@


1.39
log
@split this into cvs_commit_{remote,local}() functions;
ok jfb@@ (Yes, Yes he IS back!!)
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.38 2005/07/07 14:27:57 joris Exp $	*/
a263 1
	int len;
a264 2
	char *repo;
	struct cvsroot *root;
a271 3
	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);

d274 1
a274 5
	len = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, fpath, RCS_FILE_EXT);
	if (len == -1 || len >= (int)sizeof(rcspath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rcspath);
a275 1
	}
@


1.38
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.37 2005/05/31 08:58:47 xsa Exp $	*/
d46 2
a47 1
static int cvs_commit_file    (CVSFILE *, void *);
d60 2
a61 2
	cvs_commit_file,
	NULL,
d204 1
a204 1
 * cvs_commit_file()
d209 1
a209 1
cvs_commit_file(CVSFILE *cf, void *arg)
d211 2
a212 2
	int ret, l;
	char *repo, rcspath[MAXPATHLEN], fpath[MAXPATHLEN];
d222 3
a224 5
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cf->cf_cvstat != CVS_FST_UNKNOWN) {
				if (cvs_senddir(root, cf) < 0)
					return (CVS_EX_PROTO);
			}
a225 1

d237 3
a239 4
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cvs_sendentry(root, cf) < 0) {
				return (CVS_EX_PROTO);
			}
d241 6
a246 6
			/* if it's removed, don't bother sending a
			 * Modified request together with the file its
			 * contents.
			 */
			if (cf->cf_cvstat == CVS_FST_REMOVED)
				return (0);
d248 4
a251 4
			if (cvs_sendreq(root, CVS_REQ_MODIFIED,
			    CVS_FILE_NAME(cf)) < 0) {
				return (CVS_EX_PROTO);
			}
d253 2
a254 3
			if (cvs_sendfile(root, fpath) < 0) {
				return (CVS_EX_PROTO);
			}
d258 23
a280 1
	l = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
d282 1
a282 1
	if (l == -1 || l >= (int)sizeof(rcspath)) {
@


1.37
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.36 2005/05/30 09:52:55 joris Exp $	*/
d129 1
a129 1
 
@


1.36
log
@

don't forget to send the log message, this fixes the commit command.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.35 2005/05/30 07:37:01 xsa Exp $	*/
d32 1
a33 1
#include <fcntl.h>
d35 1
a36 1
#include <string.h>
d38 1
a40 1
#include "buf.h"
@


1.35
log
@handle -r option; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.34 2005/05/24 04:12:25 jfb Exp $	*/
d163 3
@


1.34
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.33 2005/05/20 20:00:53 joris Exp $	*/
d67 1
d98 3
d161 8
@


1.33
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.32 2005/05/20 05:13:44 joris Exp $	*/
d44 11
a54 7
int cvs_commit_prepare(CVSFILE *, void *);
int cvs_commit_file(CVSFILE *, void *);
int cvs_commit_options(char *, int, char **, int *);
int cvs_commit_helper(void);

struct cvs_cmd_info cvs_commit = {
	cvs_commit_options,
d56 3
d61 3
a63 4
	cvs_commit_helper,
	CF_RECURSE | CF_IGNORE | CF_SORT,
	CVS_REQ_CI,
	CVS_CMD_ALLOWSPEC | CVS_CMD_NEEDLOG | CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2
d70 2
a71 2
int
cvs_commit_options(char *opt, int argc, char **argv, int *arg)
d75 1
a75 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d82 1
a82 1
			cvs_commit.file_flags &= ~CF_RECURSE;
d85 1
a85 1
			cvs_commit.file_flags &= ~CF_RECURSE;
d95 1
a95 1
			cvs_commit.file_flags |= CF_RECURSE;
d119 1
a119 1
cvs_commit_helper(void)
@


1.32
log
@

execute the command callback at the same time we are building
the in-memory filelist. cuts down on execution time for larger trees.

"put it in!" jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.31 2005/04/24 02:06:27 joris Exp $	*/
d201 4
a204 2
			if (cf->cf_cvstat != CVS_FST_UNKNOWN)
				ret = cvs_senddir(root, cf);
d207 1
a207 1
		return (ret);
d246 1
a246 1
		return (-1);
@


1.31
log
@

don't send a Modified request and the file its contents when
it has been removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.30 2005/04/24 01:56:36 joris Exp $	*/
d61 2
d105 4
d117 11
d129 5
a133 3
	SIMPLEQ_INIT(&cl);
	cvs_file_examine(cvs_files, cvs_commit_prepare, &cl);
	if (SIMPLEQ_EMPTY(&cl))
d135 1
d138 1
a138 1
		cvs_msg = cvs_logmsg_get(CVS_FILE_NAME(cvs_files),
d140 2
@


1.30
log
@

add missing CVS_CMD_ALLOWSPEC flag
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.29 2005/04/19 02:04:56 jfb Exp $	*/
d198 7
@


1.29
log
@handle removed files as well when checking files to commit

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.28 2005/04/19 00:35:02 joris Exp $	*/
d57 1
a57 1
	CVS_CMD_NEEDLOG | CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2
@


1.28
log
@

remove debug code
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.27 2005/04/19 00:34:39 joris Exp $	*/
d146 2
a147 1
	    (cf->cf_cvstat == CVS_FST_ADDED))) {
d192 2
a193 1
	    (cf->cf_cvstat == CVS_FST_MODIFIED)) {
@


1.27
log
@

make sure we pick up newly added files.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.26 2005/04/18 21:02:49 jfb Exp $	*/
a146 1
		printf("copying %s\n", CVS_FILE_NAME(cf));
@


1.26
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.25 2005/04/16 18:01:26 xsa Exp $	*/
d145 3
a147 1
	if ((cf->cf_type == DT_REG) && (cf->cf_cvstat == CVS_FST_MODIFIED)) {
@


1.25
log
@missing cvs_ent_free(); joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.24 2005/04/15 14:34:15 xsa Exp $	*/
d112 1
a112 1
	TAILQ_INIT(&cl);
d114 1
a114 1
	if (TAILQ_EMPTY(&cl))
d121 3
a123 3
	while (!TAILQ_EMPTY(&cl)) {
		cfp = TAILQ_FIRST(&cl);
		TAILQ_REMOVE(&cl, cfp, cf_list);
d150 1
a150 1
		TAILQ_INSERT_TAIL(clp, copy, cf_list);
a168 1
	struct cvs_ent *entp;
d187 1
a187 5
		repo = cf->cf_parent->cf_ddat->cd_repo;

	entp = cvs_ent_getent(fpath);
	if (entp == NULL)
		return (CVS_EX_DATA);
d192 1
a192 2
			if (cvs_sendentry(root, entp) < 0) {
				cvs_ent_free(entp);
a197 1
				cvs_ent_free(entp);
a201 1
				cvs_ent_free(entp);
a211 2

		cvs_ent_free(entp);
a213 2

	cvs_ent_free(entp);
@


1.24
log
@snprintf() return values checks; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.23 2005/04/12 14:58:40 joris Exp $	*/
d220 2
@


1.23
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.22 2005/04/11 18:02:58 joris Exp $	*/
d165 1
a165 1
	int ret;
d215 1
a215 1
	snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
d217 5
@


1.22
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.21 2005/04/11 17:56:27 joris Exp $	*/
d83 1
a83 1
				return (-1);
d90 1
a90 1
			return (1);
d96 1
a96 1
		return (1);
d100 1
a100 1
		return (-1);
d128 1
a128 1
		return (-1);
d148 1
a148 1
			return (-1);
d192 1
a192 1
		return (-1);
d199 1
a199 1
				return (-1);
d205 1
a205 1
				return (-1);
d210 1
a210 1
				return (-1);
@


1.21
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.20 2005/04/03 17:32:50 xsa Exp $	*/
a36 1
#include <sysexits.h>
@


1.20
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.19 2005/03/31 15:10:51 joris Exp $	*/
d91 1
a91 1
			return (EX_USAGE);
d97 1
a97 1
		return (EX_USAGE);
@


1.19
log
@

fix prototype for cvs_commit_prepare()
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.18 2005/03/30 17:43:04 joris Exp $	*/
d84 1
a84 1
				return (EX_DATAERR);
d101 1
a101 1
		return (EX_DATAERR);
d129 1
a129 1
		return (1);
@


1.18
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.17 2005/03/29 15:06:01 joris Exp $	*/
d45 1
a45 1
static int cvs_commit_prepare(CVSFILE *, void *);
@


1.17
log
@

fix memleak

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.16 2005/03/02 03:05:02 joris Exp $	*/
d45 15
d61 1
a62 9
int    cvs_commit_prepare  (CVSFILE *, void *);
int    cvs_commit_file     (CVSFILE *, void *);


/*
 * cvs_commit()
 *
 * Handler for the `cvs commit' command.
 */
d64 1
a64 1
cvs_commit(int argc, char **argv)
d66 1
a66 9
	int i, ch, flags;
	char *mfile;
	struct cvs_flist cl;
	CVSFILE *cfp;
	struct cvsroot *root;

	flags = CF_RECURSE|CF_IGNORE|CF_SORT;
	mfile = NULL;
	TAILQ_INIT(&cl);
d68 1
a68 1
	while ((ch = getopt(argc, argv, "F:flm:Rr:")) != -1) {
d75 1
a75 1
			flags &= ~CF_RECURSE;
d78 1
a78 1
			flags &= ~CF_RECURSE;
d88 1
a88 1
			flags |= CF_RECURSE;
d103 3
a105 2
	argc -= optind;
	argv += optind;
d107 5
a111 7
	if (argc == 0) {
		cvs_files = cvs_file_get(".", flags);
	} else {
		cvs_files = cvs_file_getspec(argv, argc, flags);
	}
	if (cvs_files == NULL)
		return (EX_DATAERR);
d113 1
a130 24
	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
	if ((root->cr_method != CVS_METHOD_LOCAL) &&
	    ((cvs_connect(root) < 0) || (cvs_logmsg_send(root, cvs_msg) < 0)))
		return (EX_PROTOCOL);

	cvs_file_examine(cvs_files, cvs_commit_file, &cl);

	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0)
			return (EX_PROTOCOL);
		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				return (EX_PROTOCOL);
		if (cvs_sendreq(root, CVS_REQ_CI, NULL) < 0)
			return (EX_PROTOCOL);
	}

a132 1

@


1.16
log
@

- make sure we are using a remote method before calling
  cvs_sendreq() and cvs_sendfile().
- don't leak entp on errors.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.15 2005/02/22 23:34:28 jfb Exp $	*/
d62 1
d119 1
a119 1
	if (cvs_msg == NULL) {
d122 5
a126 2
		if (cvs_msg == NULL)
			return (1);
d128 3
@


1.15
log
@more error checking on protocol calls when running in client mode
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.14 2005/01/13 18:47:31 jfb Exp $	*/
d216 16
a231 4
		if ((root->cr_method != CVS_METHOD_LOCAL) &&
		    (cvs_sendentry(root, entp) < 0)) {
			cvs_ent_free(entp);
			return (-1);
a232 5

		if ((cvs_sendreq(root, CVS_REQ_MODIFIED,
		    CVS_FILE_NAME(cf)) < 0) ||
		    (cvs_sendfile(root, fpath) < 0))
			return (-1);
@


1.14
log
@more widespread use of cvs_msg, and free it when we are done

diff by Joris Vink and me
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.13 2004/12/21 18:32:10 jfb Exp $	*/
d222 4
a225 2
		cvs_sendreq(root, CVS_REQ_MODIFIED, CVS_FILE_NAME(cf));
		cvs_sendfile(root, fpath);
@


1.13
log
@modify the directory handling portion to behave like the one in add.c,
which does not attempt to send data when running on a local
repository.  This will be needed to support local repository access
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.12 2004/12/14 22:30:48 jfb Exp $	*/
d60 1
a60 1
	char *msg, *mfile;
a65 1
	msg = NULL;
d81 5
a85 1
			msg = optarg;
d95 1
a95 1
	if ((msg != NULL) && (mfile != NULL)) {
d100 1
a100 1
	if ((mfile != NULL) && (msg = cvs_logmsg_open(mfile)) == NULL)
d118 4
a121 3
	if (msg == NULL) {
		msg = cvs_logmsg_get(CVS_FILE_NAME(cvs_files), NULL, &cl, NULL);
		if (msg == NULL)
d134 1
a134 1
	    ((cvs_connect(root) < 0) || (cvs_logmsg_send(root, msg) < 0)))
@


1.12
log
@First attempt at syncing the command code and doing a lot more error
checking on all the protocol calls
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.11 2004/12/13 23:08:45 jfb Exp $	*/
d181 1
d187 1
d193 3
a195 7
		if (cf->cf_cvstat != CVS_FST_UNKNOWN) {
			if ((cf->cf_parent != NULL) &&
			    (root != cf->cf_parent->cf_ddat->cd_root)) {
				cvs_connect(root);
			}

			cvs_senddir(root, cf);
d198 1
a198 1
		return (0);
@


1.11
log
@return early if no files are ready to be commited
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.10 2004/12/08 17:22:48 jfb Exp $	*/
d122 10
a131 2
	cvs_connect(root);
	cvs_logmsg_send(root, msg);
d136 7
a142 6
		cvs_senddir(root, cvs_files);
		if (argc > 0) {
			for (i = 0; i < argc; i++)
				cvs_sendarg(root, argv[i], 0);
		}
		cvs_sendreq(root, CVS_REQ_CI, NULL);
d188 1
a191 1
			root = CVS_DIR_ROOT(cf);
a202 2

	root = CVS_DIR_ROOT(cf);
@


1.10
log
@embrace and extend (!) cvs_logmsg_get() so we can now display
information based on its availability and have separate sections for
the Added, Modified and Removed file lists.  this will allow us to
use the same call for add, commit, import and possibly others

Original patch by Joris Vink, some rework from me for the other
sections
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.9 2004/12/07 17:10:56 tedu Exp $	*/
d112 2
@


1.9
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.8 2004/12/06 21:03:12 deraadt Exp $	*/
d59 1
a59 1
	int i, ch, recurse, flags;
a64 1
	recurse = 1;
d69 1
a69 1
	while ((ch = getopt(argc, argv, "F:flm:R")) != -1) {
d75 2
a76 1
			recurse = 0;
d79 1
a79 1
			recurse = 0;
d85 1
a85 1
			recurse = 1;
d114 1
a114 1
		msg = cvs_logmsg_get(CVS_FILE_NAME(cvs_files), &cl);
@


1.8
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: commit.c,v 1.7 2004/12/02 19:23:44 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a55 1

a143 1

a166 1

@


1.7
log
@This commit is brought to you by the brand new improved and better tasting
OpenCVS commit code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 1
a106 2
	}
	else {
@


1.6
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@a44 8
LIST_HEAD(ci_list, ci_file);

struct ci_file {
	char   *ci_path;
	RCSNUM *ci_rev;
	LIST_ENTRY(ci_file) ci_link;
};

d47 1
d60 1
a60 1
	int ch, recurse, flags;
d62 2
a63 1
	struct ci_list cl;
d65 1
a65 1
	flags = 0;
d69 1
a69 1
	LIST_INIT(&cl);
d104 1
a104 1
	if (argc == 0)
d106 1
d113 12
d127 33
a159 2
	cvs_senddir(cvs_files->cf_ddat->cd_root, cvs_files);
	cvs_sendreq(cvs_files->cf_ddat->cd_root, CVS_REQ_CI, NULL);
a177 1
	struct ci_list *cl;
d179 2
a180 1
	cl = (struct ci_list *)arg;
d184 2
a185 2
			root = cf->cf_ddat->cd_root;
			if ((cf->cf_parent == NULL) ||
a194 2
	else
		root = cf->cf_parent->cf_ddat->cd_root;
d196 5
a200 2
	rf = NULL;
	if (cf->cf_parent != NULL) {
a201 4
	}
	else {
		repo = NULL;
	}
@


1.5
log
@Better handling of log message input and removal of crufty code
@
text
@d28 1
d45 1
a45 5
#define CVS_COMMIT_BIGMSG     32000
#define CVS_COMMIT_FTMPL      "/tmp/cvsXXXXXXXXXX"
#define CVS_COMMIT_LOGPREFIX  "CVS:"
#define CVS_COMMIT_LOGLINE \
"----------------------------------------------------------------------"
d47 5
d54 2
a55 2
static char*  cvs_commit_openmsg   (const char *);
static char*  cvs_commit_getmsg   (const char *);
d67 1
a67 1
	int ch, recurse;
d69 1
d71 1
d75 1
a75 2

	cvs_commit_getmsg(".");
d104 1
a104 1
	if ((mfile != NULL) && (msg = cvs_commit_openmsg(mfile)) == NULL)
d110 4
a113 26
	return (0);
}


/*
 * cvs_commit_openmsg()
 *
 * Open the file specified by <path> and allocate a buffer large enough to
 * hold all of the file's contents.  The returned value must later be freed
 * using the free() function.
 * Returns a pointer to the allocated buffer on success, or NULL on failure.
 */

static char*
cvs_commit_openmsg(const char *path)
{
	int ch;
	size_t len;
	char lbuf[256], *msg;
	struct stat st;
	FILE *fp;
	BUF *bp;

	if (stat(path, &st) == -1) {
		cvs_log(LP_ERRNO, "failed to stat `%s'", path);
		return (NULL);
d115 2
d118 1
a118 4
	if (!S_ISREG(st.st_mode)) {
		cvs_log(LP_ERR, "message file must be a regular file");
		return (NULL);
	}
d120 2
a121 10
	if (st.st_size > CVS_COMMIT_BIGMSG) {
		do {
			fprintf(stderr,
			    "The specified message file seems big.  "
			    "Proceed anyways? (y/n) ");
			if (fgets(lbuf, sizeof(lbuf), stdin) == NULL) {
				cvs_log(LP_ERRNO,
				    "failed to read from standard input");
				return (NULL);
			}
d123 1
a123 43
			len = strlen(lbuf);
			if ((len == 0) || (len > 2) ||
			    ((lbuf[0] != 'y') && (lbuf[0] != 'n'))) {
				fprintf(stderr, "invalid input\n");
				continue;
			}
			else if (lbuf[0] == 'y') 
				break;
			else if (lbuf[0] == 'n') {
				cvs_log(LP_ERR, "aborted by user");
				return (NULL);
			}

		} while (1);
	}

	if ((fp = fopen(path, "r")) == NULL) {
		cvs_log(LP_ERRNO, "failed to open message file `%s'", path);
		return (NULL);
	}

	bp = cvs_buf_alloc(128, BUF_AUTOEXT);
	if (bp == NULL) {
		return (NULL);
	}

	while (fgets(lbuf, sizeof(lbuf), fp) != NULL) {
		len = strlen(lbuf);
		if (len == 0)
			continue;

		/* skip lines starting with the prefix */
		if (strncmp(lbuf, CVS_COMMIT_LOGPREFIX,
		    strlen(CVS_COMMIT_LOGPREFIX)) == 0)
			continue;

		cvs_buf_append(bp, lbuf, strlen(lbuf));
	}
	cvs_buf_putc(bp, '\0');

	msg = (char *)cvs_buf_release(bp);

	return (msg);
d128 1
a128 1
 * cvs_commit_getmsg()
d130 1
a130 3
 * Get a commit log message by forking the user's editor.
 * Returns the message in a dynamically allocated string on success, NULL on
 * failure.
d133 2
a134 2
static char*
cvs_commit_getmsg(const char *dir)
d136 18
a153 5
	int ret, fd, argc, fds[3];
	size_t len;
	char *argv[4], buf[16], path[MAXPATHLEN], *msg;
	FILE *fp;
	struct stat st1, st2;
d155 1
a155 13
	msg = NULL;
	fds[0] = -1;
	fds[1] = -1;
	fds[2] = -1;
	strlcpy(path, CVS_COMMIT_FTMPL, sizeof(path));
	argc = 0;
	argv[argc++] = cvs_editor;
	argv[argc++] = path;
	argv[argc] = NULL;

	if ((fd = mkstemp(path)) == -1) {
		cvs_log(LP_ERRNO, "failed to create temporary file");
		return (NULL);
d157 2
d160 3
a162 17
	fp = fdopen(fd, "w");
	if (fp == NULL) {
		cvs_log(LP_ERRNO, "failed to fdopen");
	} else {
		fprintf(fp,
		    "\n%s %s\n%s Enter Log.  Lines beginning with `%s' are "
		    "removed automatically\n%s\n%s Commiting in %s\n"
		    "%s\n%s Modified Files:\n",
		    CVS_COMMIT_LOGPREFIX, CVS_COMMIT_LOGLINE,
		    CVS_COMMIT_LOGPREFIX, CVS_COMMIT_LOGPREFIX,
		    CVS_COMMIT_LOGPREFIX, CVS_COMMIT_LOGPREFIX,
		    dir, CVS_COMMIT_LOGPREFIX, CVS_COMMIT_LOGPREFIX);

		/* XXX list files here */

		fprintf(fp, "%s %s\n", CVS_COMMIT_LOGPREFIX,
		    CVS_COMMIT_LOGLINE);
d164 2
a165 9
	(void)fflush(fp);

	if (fstat(fd, &st1) == -1) {
		cvs_log(LP_ERRNO, "failed to stat log message file");

		(void)fclose(fp);
		if (unlink(path) == -1)
			cvs_log(LP_ERRNO, "failed to unlink log file %s", path);
		return (NULL);
d168 3
a170 17
	for (;;) {
		ret = cvs_exec(argc, argv, fds);
		if (ret == -1)
			break;
		if (fstat(fd, &st2) == -1) {
			cvs_log(LP_ERRNO, "failed to stat log message file");
			break;
		}

		if (st2.st_mtime != st1.st_mtime)
			break;

		/* nothing was entered */
		fprintf(stderr,
		    "Log message unchanged or not specified\na)bort, "
		    "c)ontinue, e)dit, !)reuse this message unchanged "
		    "for remaining dirs\nAction: (continue) ");
d172 6
a177 3
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			cvs_log(LP_ERRNO, "failed to read from standard input");
			break;
d180 2
a181 17
		len = strlen(buf);
		if ((len == 0) || (len > 2)) {
			fprintf(stderr, "invalid input\n");
			continue;
		}
		else if (buf[0] == 'a') { 
			cvs_log(LP_ERR, "aborted by user");
			break;
		} else if ((buf[0] == '\n') || (buf[0] == 'c')) {
			/* empty message */
			msg = strdup("");
			break;
		} else if (ret == 'e')
			continue;
		else if (ret == '!') {
			/* XXX do something */
		}
d184 2
a185 2
	(void)fclose(fp);
	(void)close(fd);
d187 1
a187 2
	if (unlink(path) == -1)
		cvs_log(LP_ERRNO, "failed to unlink log file %s", path);
d189 1
a189 1
	return (msg);
@


1.4
log
@at least compile
@
text
@d40 1
d44 1
a44 1
#define CVS_COMMIT_BIGMSG     8000
a71 1
#if 0
a72 1
#endif
d123 3
a125 3
	int fd, ch;
	size_t sz;
	char buf[32], *msg;
d127 2
d145 1
a145 1
			if (fgets(buf, sizeof(buf), stdin) == NULL) {
d151 3
a153 3
			sz = strlen(buf);
			if ((sz == 0) || (sz > 2) ||
			    ((buf[sz] != 'y') && (buf[sz] != 'n'))) {
d157 1
a157 1
			else if (buf[sz] == 'y') 
d159 1
a159 1
			else if (buf[sz] == 'n') {
d167 2
a168 5
	sz = st.st_size + 1;

	msg = (char *)malloc(sz);
	if (msg == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate message buffer");
d172 2
a173 3
	fd = open(path, O_RDONLY, 0);
	if (fd == -1) {
		cvs_log(LP_ERRNO, "failed to open message file `%s'", path);
d177 11
a187 3
	if (read(fd, msg, sz - 1) == -1) {
		cvs_log(LP_ERRNO, "failed to read CVS commit message");
		return (NULL);
d189 3
a191 1
	msg[sz - 1] = '\0';
d209 2
a210 1
	char *argv[4], path[MAXPATHLEN], *msg;
d212 1
d214 1
a231 1
		exit(1);
a247 1
	(void)fclose(fp);
d249 10
a258 1
	do {
d260 6
a265 5
		if (ret == -1) {
			fprintf(stderr,
			    "Log message unchanged or not specified\n"
			    "a)bort, c)ontinue, e)dit, !)reuse this message "
			    "unchanged for remaining dirs\nAction: () ");
d267 2
a268 11
			ret = getchar();
			if (ret == 'a') {
				cvs_log(LP_ERR, "aborted by user");
				break;
			} else if (ret == 'c') {
			} else if (ret == 'e') {
			} else if (ret == '!') {
			}
				
		}
	} while (0);
d270 5
a274 1
	(void)close(fd);
d276 4
a279 2
	return (msg);
}
d281 18
d300 2
a301 6
/*
 * cvs_commit_gettmpl()
 *
 * Get the template to display when invoking the editor to get a commit
 * message.
 */
d303 2
a304 2
cvs_commit_gettmpl(void)
{
d306 1
@


1.3
log
@Editor invocation code, still needs some work
@
text
@d151 3
a153 1
			if ((sz == 0) || (sz > 2)) {
d156 3
a158 1

a162 1
			fprintf(stderr, "Invalid character\n");
@


1.2
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d43 6
d52 1
a52 2


d71 4
d124 1
a124 1
	int fd;
d126 1
a126 1
	char *msg;
d134 29
d184 90
@


1.1
log
@Initial revision
@
text
@d40 1
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
