head	1.162;
access;
symbols
	OPENBSD_6_0:1.161.0.4
	OPENBSD_6_0_BASE:1.161
	OPENBSD_5_9:1.161.0.2
	OPENBSD_5_9_BASE:1.161
	OPENBSD_5_8:1.160.0.20
	OPENBSD_5_8_BASE:1.160
	OPENBSD_5_7:1.160.0.12
	OPENBSD_5_7_BASE:1.160
	OPENBSD_5_6:1.160.0.16
	OPENBSD_5_6_BASE:1.160
	OPENBSD_5_5:1.160.0.14
	OPENBSD_5_5_BASE:1.160
	OPENBSD_5_4:1.160.0.10
	OPENBSD_5_4_BASE:1.160
	OPENBSD_5_3:1.160.0.8
	OPENBSD_5_3_BASE:1.160
	OPENBSD_5_2:1.160.0.6
	OPENBSD_5_2_BASE:1.160
	OPENBSD_5_1_BASE:1.160
	OPENBSD_5_1:1.160.0.4
	OPENBSD_5_0:1.160.0.2
	OPENBSD_5_0_BASE:1.160
	OPENBSD_4_9:1.159.0.4
	OPENBSD_4_9_BASE:1.159
	OPENBSD_4_8:1.159.0.2
	OPENBSD_4_8_BASE:1.159
	OPENBSD_4_7:1.155.0.2
	OPENBSD_4_7_BASE:1.155
	OPENBSD_4_6:1.155.0.4
	OPENBSD_4_6_BASE:1.155
	OPENBSD_4_5:1.145.0.2
	OPENBSD_4_5_BASE:1.145
	OPENBSD_4_4:1.144.0.2
	OPENBSD_4_4_BASE:1.144
	OPENBSD_4_3:1.133.0.2
	OPENBSD_4_3_BASE:1.133
	OPENBSD_4_2:1.120.0.2
	OPENBSD_4_2_BASE:1.120
	OPENBSD_4_1:1.118.0.2
	OPENBSD_4_1_BASE:1.118
	OPENBSD_4_0:1.109.0.2
	OPENBSD_4_0_BASE:1.109
	OPENBSD_3_9:1.80.0.2
	OPENBSD_3_9_BASE:1.80
	OPENBSD_3_8:1.55.0.2
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.0.1;
locks; strict;
comment	@ * @;


1.162
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.161;
commitid	8Vv7d4HkmCtExfc6;

1.161
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.160;
commitid	O6jeJ0TRmiewrqMI;

1.160
date	2011.04.20.18.33.13;	author nicm;	state Exp;
branches;
next	1.159;

1.159
date	2010.07.30.21.47.18;	author ray;	state Exp;
branches;
next	1.158;

1.158
date	2010.07.28.21.19.30;	author nicm;	state Exp;
branches;
next	1.157;

1.157
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.156;

1.156
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.155;

1.155
date	2009.06.07.08.39.13;	author ray;	state Exp;
branches;
next	1.154;

1.154
date	2009.06.06.14.17.27;	author ray;	state Exp;
branches;
next	1.153;

1.153
date	2009.04.29.12.56.15;	author joris;	state Exp;
branches;
next	1.152;

1.152
date	2009.04.28.09.05.40;	author sthen;	state Exp;
branches;
next	1.151;

1.151
date	2009.04.03.19.46.56;	author joris;	state Exp;
branches;
next	1.150;

1.150
date	2009.04.03.08.18.44;	author joris;	state Exp;
branches;
next	1.149;

1.149
date	2009.04.02.21.13.50;	author joris;	state Exp;
branches;
next	1.148;

1.148
date	2009.04.02.09.09.40;	author joris;	state Exp;
branches;
next	1.147;

1.147
date	2009.03.23.07.28.05;	author joris;	state Exp;
branches;
next	1.146;

1.146
date	2009.03.19.10.09.16;	author joris;	state Exp;
branches;
next	1.145;

1.145
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.144;

1.144
date	2008.06.20.14.04.29;	author tobias;	state Exp;
branches;
next	1.143;

1.143
date	2008.06.20.13.59.14;	author tobias;	state Exp;
branches;
next	1.142;

1.142
date	2008.06.17.06.38.21;	author joris;	state Exp;
branches;
next	1.141;

1.141
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.140;

1.140
date	2008.06.11.20.55.34;	author joris;	state Exp;
branches;
next	1.139;

1.139
date	2008.06.11.02.19.13;	author tobias;	state Exp;
branches;
next	1.138;

1.138
date	2008.06.10.17.34.36;	author tobias;	state Exp;
branches;
next	1.137;

1.137
date	2008.05.30.11.06.17;	author tobias;	state Exp;
branches;
next	1.136;

1.136
date	2008.05.30.10.12.12;	author tobias;	state Exp;
branches;
next	1.135;

1.135
date	2008.05.22.15.45.01;	author tobias;	state Exp;
branches;
next	1.134;

1.134
date	2008.03.13.19.54.34;	author sthen;	state Exp;
branches;
next	1.133;

1.133
date	2008.03.02.19.05.34;	author tobias;	state Exp;
branches;
next	1.132;

1.132
date	2008.03.01.21.29.36;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.130;

1.130
date	2008.02.27.20.04.59;	author tobias;	state Exp;
branches;
next	1.129;

1.129
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.128;

1.128
date	2008.02.09.12.27.31;	author tobias;	state Exp;
branches;
next	1.127;

1.127
date	2008.02.04.21.25.32;	author tobias;	state Exp;
branches;
next	1.126;

1.126
date	2008.02.04.15.07.33;	author tobias;	state Exp;
branches;
next	1.125;

1.125
date	2008.02.03.18.18.44;	author tobias;	state Exp;
branches;
next	1.124;

1.124
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.123;

1.123
date	2008.01.29.12.00.34;	author tobias;	state Exp;
branches;
next	1.122;

1.122
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.121;

1.121
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.120;

1.120
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.119;

1.119
date	2007.06.27.04.23.54;	author joris;	state Exp;
branches;
next	1.118;

1.118
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.117;

1.117
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.116;

1.116
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.115;

1.115
date	2007.01.20.01.07.51;	author niallo;	state Exp;
branches;
next	1.114;

1.114
date	2007.01.15.04.21.38;	author joris;	state Exp;
branches;
next	1.113;

1.113
date	2007.01.14.23.10.56;	author joris;	state Exp;
branches;
next	1.112;

1.112
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.111;

1.111
date	2007.01.11.10.37.18;	author xsa;	state Exp;
branches;
next	1.110;

1.110
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.109;

1.109
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.108;

1.108
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.107;

1.107
date	2006.07.01.01.07.50;	author ray;	state Exp;
branches;
next	1.106;

1.106
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.105;

1.105
date	2006.06.16.20.01.10;	author joris;	state Exp;
branches;
next	1.104;

1.104
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.103;

1.103
date	2006.06.14.20.28.53;	author joris;	state Exp;
branches;
next	1.102;

1.102
date	2006.06.01.20.01.47;	author joris;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.31.22.24.12;	author joris;	state Exp;
branches;
next	1.100;

1.100
date	2006.05.31.07.21.25;	author joris;	state Exp;
branches;
next	1.99;

1.99
date	2006.05.30.22.25.24;	author joris;	state Exp;
branches;
next	1.98;

1.98
date	2006.05.30.21.32.52;	author joris;	state Exp;
branches;
next	1.97;

1.97
date	2006.05.29.07.17.30;	author joris;	state Exp;
branches;
next	1.96;

1.96
date	2006.05.28.07.56.44;	author joris;	state Exp;
branches;
next	1.95;

1.95
date	2006.05.27.21.11.11;	author joris;	state Exp;
branches;
next	1.94;

1.94
date	2006.05.27.20.57.42;	author joris;	state Exp;
branches;
next	1.93;

1.93
date	2006.05.27.17.52.27;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2006.05.27.15.14.27;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2006.04.14.23.29.01;	author joris;	state Exp;
branches;
next	1.89;

1.89
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2006.04.13.16.55.09;	author ray;	state Exp;
branches;
next	1.87;

1.87
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.86;

1.86
date	2006.04.01.20.11.25;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2006.03.28.07.17.16;	author ray;	state Exp;
branches;
next	1.84;

1.84
date	2006.03.28.02.13.44;	author ray;	state Exp;
branches;
next	1.83;

1.83
date	2006.03.25.21.29.59;	author ray;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.24.13.34.27;	author ray;	state Exp;
branches;
next	1.81;

1.81
date	2006.03.23.13.09.09;	author xsa;	state Exp;
branches;
next	1.80;

1.80
date	2006.02.26.18.35.08;	author niallo;	state Exp;
branches;
next	1.79;

1.79
date	2006.01.30.17.58.47;	author xsa;	state Exp;
branches;
next	1.78;

1.78
date	2006.01.27.15.26.38;	author xsa;	state Exp;
branches;
next	1.77;

1.77
date	2006.01.25.11.13.18;	author xsa;	state Exp;
branches;
next	1.76;

1.76
date	2006.01.02.17.06.10;	author xsa;	state Exp;
branches;
next	1.75;

1.75
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.74;

1.74
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.73;

1.73
date	2005.12.21.09.09.02;	author xsa;	state Exp;
branches;
next	1.72;

1.72
date	2005.12.20.18.17.00;	author xsa;	state Exp;
branches;
next	1.71;

1.71
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.70;

1.70
date	2005.12.05.19.53.00;	author niallo;	state Exp;
branches;
next	1.69;

1.69
date	2005.12.01.23.02.27;	author niallo;	state Exp;
branches;
next	1.68;

1.68
date	2005.12.01.20.36.30;	author niallo;	state Exp;
branches;
next	1.67;

1.67
date	2005.11.24.11.23.13;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.21.15.01.10;	author xsa;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.18.10.30.34;	author xsa;	state Exp;
branches;
next	1.64;

1.64
date	2005.11.14.12.53.43;	author xsa;	state Exp;
branches;
next	1.63;

1.63
date	2005.10.22.17.32.57;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2005.10.11.18.01.57;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2005.10.11.14.27.27;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.08.20.39.49;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.08.00.49.18;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.07.23.59.56;	author niallo;	state Exp;
branches;
next	1.57;

1.57
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2005.10.05.23.11.06;	author niallo;	state Exp;
branches;
next	1.55;

1.55
date	2005.08.14.19.49.18;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2005.07.27.16.42.19;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.22.16.27.29;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2005.07.21.11.42.24;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.07.11.01.32.17;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.11.01.26.47;	author niallo;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.10.21.50.25;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.10.13.58.19;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.10.13.53.51;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.09.18.56.16;	author niallo;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.09.16.28.30;	author niallo;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.28.08.44.44;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.05.20.47.44;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.31.08.26.40;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.31.01.59.59;	author joris;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.30.07.28.49;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.27.22.41.00;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.22.17.48.54;	author jfb;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.25.19.09.15;	author jfb;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.22.03.38.56;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.18.21.02.49;	author jfb;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.16.19.05.02;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.14.16.49.09;	author joris;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.31.14.57.32;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.27.00.22.08;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.25.20.32.48;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.01.18.03.32;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.29.15.47.51;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.14.00.35.15;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.13.23.39.42;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.28.22.07.31;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.28.20.39.15;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.28.19.51.07;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.14.21.40.39;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.08.21.11.07;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.06.02.46.47;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.12.18.37.27;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.06.13.08.39;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.30.20.55.35;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.30.01.49.23;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.14.04.32.42;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.03.59.36;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.162
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@/*	$OpenBSD: diff.c,v 1.161 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2008 Tobias Stoeckmann <tobias@@openbsd.org>
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>
#include <sys/time.h>

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "cvs.h"
#include "diff.h"
#include "remote.h"

void	cvs_diff_local(struct cvs_file *);

static int	 dflags = 0;
static int	 Nflag = 0;
static int	 force_head = 0;
static char	*koptstr;
static char	*rev1 = NULL;
static char	*rev2 = NULL;
static time_t	 date1 = -1;
static time_t	 date2 = -1;
static char	*dateflag1 = NULL;
static char	*dateflag2 = NULL;

struct cvs_cmd cvs_cmd_diff = {
	CVS_OP_DIFF, CVS_USE_WDIR, "diff",
	{ "di", "dif" },
	"Show differences between revisions",
	"[-abcdilNnpRuw] [[-D date] [-r rev] [-D date2 | -r rev2]] "
	"[-k mode] [file ...]",
	"abcfC:dD:ik:lNnpr:RuU:w",
	NULL,
	cvs_diff
};

struct cvs_cmd cvs_cmd_rdiff = {
	CVS_OP_RDIFF, 0, "rdiff",
	{ "patch", "pa" },
	"Show differences between revisions",
	"[-flR] [-c | -u] [-s | -t] [-V ver] -D date | -r rev\n"
	"[-D date2 | -r rev2] [-k mode] module ...",
	"cfD:k:lr:RuV:",
	NULL,
	cvs_diff
};

int
cvs_diff(int argc, char **argv)
{
	int ch, flags;
	char *arg = ".";
	const char *errstr;
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;
	strlcpy(diffargs, cvs_cmdop == CVS_OP_DIFF ? "diff" : "rdiff",
	    sizeof(diffargs));

	while ((ch = getopt(argc, argv, cvs_cmdop == CVS_OP_DIFF ?
	    cvs_cmd_diff.cmd_opts : cvs_cmd_rdiff.cmd_opts)) != -1) {
		switch (ch) {
		case 'a':
			strlcat(diffargs, " -a", sizeof(diffargs));
			dflags |= D_FORCEASCII;
			break;
		case 'b':
			strlcat(diffargs, " -b", sizeof(diffargs));
			dflags |= D_FOLDBLANKS;
			break;
		case 'c':
			strlcat(diffargs, " -c", sizeof(diffargs));
			diff_format = D_CONTEXT;
			break;
		case 'C':
			diff_context = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL)
				fatal("context lines %s: %s", errstr, optarg);
			strlcat(diffargs, " -C ", sizeof(diffargs));
			strlcat(diffargs, optarg, sizeof(diffargs));
			diff_format = D_CONTEXT;
			break;
		case 'd':
			strlcat(diffargs, " -d", sizeof(diffargs));
			dflags |= D_MINIMAL;
			break;
		case 'D':
			if (date1 == -1 && rev1 == NULL) {
				if ((date1 = date_parse(optarg)) == -1)
					fatal("invalid date: %s", optarg);
				dateflag1 = optarg;
			} else if (date2 == -1 && rev2 == NULL) {
				if ((date2 = date_parse(optarg)) == -1)
					fatal("invalid date: %s", optarg);
				dateflag2 = optarg;
			} else {
				fatal("no more than 2 revisions/dates can"
				    " be specified");
			}
			break;
		case 'f':
			force_head = 1;
			break;
		case 'i':
			strlcat(diffargs, " -i", sizeof(diffargs));
			dflags |= D_IGNORECASE;
			break;
		case 'k':
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				fatal("%s", cvs_cmdop == CVS_OP_DIFF ?
				    cvs_cmd_diff.cmd_synopsis :
				    cvs_cmd_rdiff.cmd_synopsis);
			}
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'n':
			strlcat(diffargs, " -n", sizeof(diffargs));
			diff_format = D_RCSDIFF;
			break;
		case 'N':
			strlcat(diffargs, " -N", sizeof(diffargs));
			Nflag = 1;
			break;
		case 'p':
			strlcat(diffargs, " -p", sizeof(diffargs));
			dflags |= D_PROTOTYPE;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		case 'r':
			if (date1 == -1 && rev1 == NULL) {
				rev1 = optarg;
			} else if (date2 == -1 && rev2 == NULL) {
				rev2 = optarg;
			} else {
				fatal("no more than 2 revisions/dates can"
				    " be specified");
			}
			break;
		case 't':
			strlcat(diffargs, " -t", sizeof(diffargs));
			dflags |= D_EXPANDTABS;
			break;
		case 'u':
			strlcat(diffargs, " -u", sizeof(diffargs));
			diff_format = D_UNIFIED;
			break;
		case 'U':
			diff_context = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL)
				fatal("context lines %s: %s", errstr, optarg);
			strlcat(diffargs, " -U ", sizeof(diffargs));
			strlcat(diffargs, optarg, sizeof(diffargs));
			diff_format = D_UNIFIED;
			break;
		case 'V':
			fatal("the -V option is obsolete "
			    "and should not be used");
		case 'w':
			strlcat(diffargs, " -w", sizeof(diffargs));
			dflags |= D_IGNOREBLANKS;
			break;
		default:
			fatal("%s", cvs_cmdop == CVS_OP_DIFF ?
			    cvs_cmd_diff.cmd_synopsis :
			    cvs_cmd_rdiff.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (cvs_cmdop == CVS_OP_RDIFF) {
		if (rev1 == NULL && rev2 == NULL && dateflag1 == NULL &&
		    dateflag2 == NULL)
			fatal("must specify at least one revision/date!");

		if (!argc)
			fatal("%s", cvs_cmd_rdiff.cmd_synopsis);

		if (!diff_format) {
			strlcat(diffargs, " -c", sizeof(diffargs));
			diff_format = D_CONTEXT;
		}

		flags |= CR_REPO;
	}

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");

		if (kflag)
			cvs_client_send_request("Argument -k%s", koptstr);

		switch (diff_format) {
		case D_CONTEXT:
			if (cvs_cmdop == CVS_OP_RDIFF)
				cvs_client_send_request("Argument -c");
			else {
				cvs_client_send_request("Argument -C %d",
				    diff_context);
			}
			break;
		case D_RCSDIFF:
			cvs_client_send_request("Argument -n");
			break;
		case D_UNIFIED:
			if (cvs_cmdop == CVS_OP_RDIFF || diff_context == 3)
				cvs_client_send_request("Argument -u");
			else {
				cvs_client_send_request("Argument -U %d",
				    diff_context);
			}
			break;
		default:
			break;
		}

		if (Nflag == 1)
			cvs_client_send_request("Argument -N");

		if (dflags & D_PROTOTYPE)
			cvs_client_send_request("Argument -p");

		if (rev1 != NULL)
			cvs_client_send_request("Argument -r%s", rev1);
		if (rev2 != NULL)
			cvs_client_send_request("Argument -r%s", rev2);

		if (dateflag1 != NULL)
			cvs_client_send_request("Argument -D%s", dateflag1);
		if (dateflag2 != NULL)
			cvs_client_send_request("Argument -D%s", dateflag2);
	} else {
		if (cvs_cmdop == CVS_OP_RDIFF &&
		    chdir(current_cvsroot->cr_dir) == -1)
			fatal("cvs_diff: %s", strerror(errno));

		cr.fileproc = cvs_diff_local;
	}

	cr.flags = flags;

	diff_rev1 = diff_rev2 = NULL;

	if (cvs_cmdop == CVS_OP_DIFF ||
	    current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
		if (argc > 0)
			cvs_file_run(argc, argv, &cr);
		else
			cvs_file_run(1, &arg, &cr);
	}

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");

		cvs_client_send_request((cvs_cmdop == CVS_OP_RDIFF) ?
		    "rdiff" : "diff");

		cvs_client_get_responses();
	}

	return (0);
}

void
cvs_diff_local(struct cvs_file *cf)
{
	BUF *b1;
	int fd1, fd2;
	struct stat st;
	struct timeval tv[2], tv2[2];
	struct tm datetm;
	char rbuf[CVS_REV_BUFSZ], tbuf[CVS_TIME_BUFSZ], *p1, *p2;

	b1 = NULL;
	fd1 = fd2 = -1;
	p1 = p2 = NULL;

	cvs_log(LP_TRACE, "cvs_diff_local(%s)", cf->file_path);

	if (cf->file_type == CVS_DIR) {
		if (verbosity > 1)
			cvs_log(LP_ERR, "Diffing inside %s", cf->file_path);
		return;
	}

	cvs_file_classify(cf, cvs_directory_tag);

	if (cvs_cmdop == CVS_OP_DIFF) {
		if (cf->file_ent == NULL) {
			cvs_log(LP_ERR, "I know nothing about %s",
			    cf->file_path);
			return;
		}

		switch (cf->file_ent->ce_status) {
		case CVS_ENT_ADDED:
			if (Nflag == 0) {
				cvs_log(LP_ERR, "%s is a new entry, no "
				    "comparison available", cf->file_path);
				return;
			}
			if (!(cf->file_flags & FILE_ON_DISK)) {
				cvs_log(LP_ERR, "cannot find %s",
				    cf->file_path);
				return;
			}
			break;
		case CVS_ENT_REMOVED:
			if (Nflag == 0) {
				cvs_log(LP_ERR, "%s was removed, no "
				    "comparison available", cf->file_path);
				return;
			}
			if (cf->file_rcs == NULL) {
				cvs_log(LP_ERR, "cannot find RCS file for %s",
				    cf->file_path);
				return;
			}
			break;
		default:
			if (!(cf->file_flags & FILE_ON_DISK)) {
				cvs_printf("? %s\n", cf->file_path);
				return;
			}

			if (cf->file_rcs == NULL) {
				cvs_log(LP_ERR, "cannot find RCS file for %s",
				    cf->file_path);
				return;
			}
			break;
		}
	}

	if (cf->file_status == FILE_UPTODATE && rev1 == NULL && rev2 == NULL &&
	    date1 == -1 && date2 == -1)
		return;

	if (cf->file_rcs != NULL && cf->file_rcs->rf_head == NULL) {
		cvs_log(LP_ERR, "no head revision in RCS file for %s\n",
		    cf->file_path);
		return;
	}

	if (kflag && cf->file_rcs != NULL)
		rcs_kwexp_set(cf->file_rcs, kflag);

	if (cf->file_rcs == NULL)
		diff_rev1 = NULL;
	else if (rev1 != NULL || date1 != -1) {
		cvs_specified_date = date1;
		diff_rev1 = rcs_translate_tag(rev1, cf->file_rcs);
		if (diff_rev1 == NULL && cvs_cmdop == CVS_OP_DIFF) {
			if (rev1 != NULL) {
				cvs_log(LP_ERR, "tag %s not in file %s", rev1,
				    cf->file_path);
				goto cleanup;
			} else if (Nflag) {
				diff_rev1 = NULL;
			} else {
				gmtime_r(&cvs_specified_date, &datetm);
				strftime(tbuf, sizeof(tbuf),
				    "%Y.%m.%d.%H.%M.%S", &datetm);
				cvs_log(LP_ERR, "no revision for date %s in "
				    "file %s", tbuf, cf->file_path);
				goto cleanup;
			}
		} else if (diff_rev1 == NULL && cvs_cmdop == CVS_OP_RDIFF &&
		    force_head) {
			/* -f is not allowed for unknown symbols */
			if ((diff_rev1 = rcsnum_parse(rev1)) == NULL)
				fatal("no such tag %s", rev1);
			free(diff_rev1);

			diff_rev1 = cf->file_rcs->rf_head;
		}
		cvs_specified_date = -1;
	} else if (cvs_cmdop == CVS_OP_DIFF) {
		if (cf->file_ent->ce_status == CVS_ENT_ADDED)
			diff_rev1 = NULL;
		else
			diff_rev1 = cf->file_ent->ce_rev;
	}

	if (cf->file_rcs == NULL)
		diff_rev2 = NULL;
	else if (rev2 != NULL || date2 != -1) {
		cvs_specified_date = date2;
		diff_rev2 = rcs_translate_tag(rev2, cf->file_rcs);
		if (diff_rev2 == NULL && cvs_cmdop == CVS_OP_DIFF) {
			if (rev2 != NULL) {
				cvs_log(LP_ERR, "tag %s not in file %s", rev2,
				    cf->file_path);
				goto cleanup;
			} else if (Nflag) {
				diff_rev2 = NULL;
			} else {
				gmtime_r(&cvs_specified_date, &datetm);
				strftime(tbuf, sizeof(tbuf),
				    "%Y.%m.%d.%H.%M.%S", &datetm);
				cvs_log(LP_ERR, "no revision for date %s in "
				    "file %s", tbuf, cf->file_path);
				goto cleanup;
			}
		} else if (diff_rev2 == NULL && cvs_cmdop == CVS_OP_RDIFF &&
		    force_head) {
			/* -f is not allowed for unknown symbols */
			if ((diff_rev2 = rcsnum_parse(rev2)) == NULL)
				fatal("no such tag %s", rev2);
			free(diff_rev2);

			diff_rev2 = cf->file_rcs->rf_head;
		}
		cvs_specified_date = -1;
	} else if (cvs_cmdop == CVS_OP_RDIFF)
		diff_rev2 = cf->file_rcs->rf_head;
	else if (cf->file_ent->ce_status == CVS_ENT_REMOVED)
		diff_rev2 = NULL;

	if (diff_rev1 != NULL && diff_rev2 != NULL &&
	    rcsnum_cmp(diff_rev1, diff_rev2, 0) == 0)
		goto cleanup;

	switch (cvs_cmdop) {
	case CVS_OP_DIFF:
		if (cf->file_status == FILE_UPTODATE) {
			if (diff_rev2 == NULL &&
			    !rcsnum_cmp(diff_rev1, cf->file_rcsrev, 0))
				goto cleanup;
		}
		break;
	case CVS_OP_RDIFF:
		if (diff_rev1 == NULL && diff_rev2 == NULL)
			goto cleanup;
		break;
	}

	cvs_printf("Index: %s\n", cf->file_path);
	if (cvs_cmdop == CVS_OP_DIFF)
		cvs_printf("%s\nRCS file: %s\n", RCS_DIFF_DIV,
		    cf->file_rcs != NULL ? cf->file_rpath : cf->file_path);

	if (diff_rev1 != NULL) {
		if (cvs_cmdop == CVS_OP_DIFF && diff_rev1 != NULL) {
			(void)rcsnum_tostr(diff_rev1, rbuf, sizeof(rbuf));
			cvs_printf("retrieving revision %s\n", rbuf);
		}

		tv[0].tv_sec = rcs_rev_getdate(cf->file_rcs, diff_rev1);
		tv[0].tv_usec = 0;
		tv[1] = tv[0];

		(void)xasprintf(&p1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
		fd1 = rcs_rev_write_stmp(cf->file_rcs, diff_rev1, p1, 0);
		if (futimes(fd1, tv) == -1)
			fatal("cvs_diff_local: utimes failed");
	}

	if (diff_rev2 != NULL) {
		if (cvs_cmdop == CVS_OP_DIFF && rev2 != NULL) {
			(void)rcsnum_tostr(diff_rev2, rbuf, sizeof(rbuf));
			cvs_printf("retrieving revision %s\n", rbuf);
		}

		tv2[0].tv_sec = rcs_rev_getdate(cf->file_rcs, diff_rev2);
		tv2[0].tv_usec = 0;
		tv2[1] = tv2[0];

		(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
		fd2 = rcs_rev_write_stmp(cf->file_rcs, diff_rev2, p2, 0);
		if (futimes(fd2, tv2) == -1)
			fatal("cvs_diff_local: utimes failed");
	} else if (cvs_cmdop == CVS_OP_DIFF &&
	    (cf->file_flags & FILE_ON_DISK) &&
	    cf->file_ent->ce_status != CVS_ENT_REMOVED) {
		(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
		if (cvs_server_active == 1 && cf->fd == -1) {
			tv2[0].tv_sec = rcs_rev_getdate(cf->file_rcs,
			    cf->file_ent->ce_rev);
			tv2[0].tv_usec = 0;
			tv2[1] = tv2[0];

			fd2 = rcs_rev_write_stmp(cf->file_rcs,
			    cf->file_ent->ce_rev, p2, 0);
			if (futimes(fd2, tv2) == -1)
				fatal("cvs_diff_local: futimes failed");
		} else {
			if (fstat(cf->fd, &st) == -1)
				fatal("fstat failed %s", strerror(errno));
			b1 = buf_load_fd(cf->fd);

			tv2[0].tv_sec = st.st_mtime;
			tv2[0].tv_usec = 0;
			tv2[1] = tv2[0];

			fd2 = buf_write_stmp(b1, p2, tv2);
			buf_free(b1);
		}
	}

	switch (cvs_cmdop) {
	case CVS_OP_DIFF:
		cvs_printf("%s", diffargs);

		if (rev1 != NULL && diff_rev1 != NULL) {
			(void)rcsnum_tostr(diff_rev1, rbuf, sizeof(rbuf));
			cvs_printf(" -r%s", rbuf);

			if (rev2 != NULL && diff_rev2 != NULL) {
				(void)rcsnum_tostr(diff_rev2, rbuf,
				    sizeof(rbuf));
				cvs_printf(" -r%s", rbuf);
			}
		}

		if (diff_rev2 == NULL)
			cvs_printf(" %s", cf->file_path);
		cvs_printf("\n");
		break;
	case CVS_OP_RDIFF:
		cvs_printf("diff ");
		switch (diff_format) {
		case D_CONTEXT:
			cvs_printf("-c ");
			break;
		case D_RCSDIFF:
			cvs_printf("-n ");
			break;
		case D_UNIFIED:
			cvs_printf("-u ");
			break;
		default:
			break;
		}
		if (diff_rev1 == NULL) {
			cvs_printf("%s ", CVS_PATH_DEVNULL);
		} else {
			(void)rcsnum_tostr(diff_rev1, rbuf, sizeof(rbuf));
			cvs_printf("%s:%s ", cf->file_path, rbuf);
		}

		if (diff_rev2 == NULL) {
			cvs_printf("%s:removed\n", cf->file_path);
		} else {
			(void)rcsnum_tostr(diff_rev2 != NULL ? diff_rev2 :
			    cf->file_rcs->rf_head, rbuf, sizeof(rbuf));
			cvs_printf("%s:%s\n", cf->file_path, rbuf);
		}
		break;
	}

	if (fd1 == -1) {
		if ((fd1 = open(CVS_PATH_DEVNULL, O_RDONLY, 0)) == -1)
			fatal("cannot open %s", CVS_PATH_DEVNULL);
	}
	if (fd2 == -1) {
		if ((fd2 = open(CVS_PATH_DEVNULL, O_RDONLY, 0)) == -1)
			fatal("cannot open %s", CVS_PATH_DEVNULL);
	}

	if (diffreg(p1 != NULL ? cf->file_path : CVS_PATH_DEVNULL,
	    p2 != NULL ? cf->file_path : CVS_PATH_DEVNULL, fd1, fd2, NULL,
	    dflags) == D_ERROR)
		fatal("cvs_diff_local: failed to get RCS patch");

	close(fd1);
	close(fd2);

	worklist_run(&temp_files, worklist_unlink);

	free(p1);
	free(p2);

cleanup:
	if (diff_rev1 != NULL &&
	    (cf->file_rcs == NULL || diff_rev1 != cf->file_rcs->rf_head) &&
	    (cf->file_ent == NULL || diff_rev1 != cf->file_ent->ce_rev))
		free(diff_rev1);
	diff_rev1 = NULL;

	if (diff_rev2 != NULL &&
	    (cf->file_rcs == NULL || diff_rev2 != cf->file_rcs->rf_head))
		free(diff_rev2);
	diff_rev2 = NULL;
}
@


1.161
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.160 2011/04/20 18:33:13 nicm Exp $	*/
d410 1
a410 1
			rcsnum_free(diff_rev1);
d447 1
a447 1
			rcsnum_free(diff_rev2);
@


1.160
log
@Use -u when diff context is 3, from Michael W Bombardieri, tweaked by
millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.159 2010/07/30 21:47:18 ray Exp $	*/
d608 2
a609 4
	if (p1 != NULL)
		xfree(p1);
	if (p2 != NULL)
		xfree(p2);
d615 1
a615 1
		xfree(diff_rev1);
d620 1
a620 1
		xfree(diff_rev2);
@


1.159
log
@Check date_parse return values.

OK xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.158 2010/07/28 21:19:30 nicm Exp $	*/
d242 1
a242 1
			if (cvs_cmdop == CVS_OP_RDIFF)
@


1.158
log
@Support -U and -C to specify the context length for "cvs diff".

This doesn't alter cvs rdiff, where -U and -C are not support by GNU
cvs.

ok sthen zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.157 2010/07/23 21:46:05 ray Exp $	*/
d109 2
a110 1
				date1 = date_parse(optarg);
d113 2
a114 1
				date2 = date_parse(optarg);
@


1.157
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.156 2010/07/23 08:31:19 ray Exp $	*/
d52 1
a52 1
	"abcfdD:ik:lNnpr:Ruw",
d73 1
d95 8
d173 8
d229 6
a234 1
			cvs_client_send_request("Argument -c");
d240 6
a245 1
			cvs_client_send_request("Argument -u");
@


1.156
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.155 2009/06/07 08:39:13 ray Exp $	*/
d100 1
a100 1
				date1 = cvs_date_parse(optarg);
d103 1
a103 1
				date2 = cvs_date_parse(optarg);
d498 1
a498 1
			b1 = cvs_buf_load_fd(cf->fd);
d504 2
a505 2
			fd2 = cvs_buf_write_stmp(b1, p2, tv2);
			cvs_buf_free(b1);
@


1.155
log
@More cvs/diff/rcs convergence:
1. Mostly variable/function renaming, SIZE_T_MAX->SIZE_MAX, and
spacing.
2. One strchr -> strncspn.
3. diff had a weird thing where it set file[12] = ofile[12] but
never updated file or ofile, then if file and ofile were different
it freed it. I removed it.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.154 2009/06/06 14:17:27 ray Exp $	*/
d577 1
a577 1
	cvs_worklist_run(&temp_files, cvs_worklist_unlink);
@


1.154
log
@Sync some rcsdiff changes to cvsdiff.  As a side effect,
cvs diff -t now works.  There should be no functional change
otherwise.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.153 2009/04/29 12:56:15 joris Exp $	*/
d569 1
a569 1
	if (cvs_diffreg(p1 != NULL ? cf->file_path : CVS_PATH_DEVNULL,
@


1.153
log
@add options 'a' and 'd' to the getopt string so
we can actually use them.

bad sthen@@ and bad me for missing this :)
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.152 2009/04/28 09:05:40 sthen Exp $	*/
d35 1
d84 1
a84 1
			diff_aflag = 1;
d88 1
a88 1
			diff_bflag = 1;
d96 1
a96 1
			diff_dflag = 1;
d115 1
a115 1
			diff_iflag = 1;
d141 1
a141 1
			diff_pflag = 1;
d156 4
d169 1
a169 1
			diff_wflag = 1;
d227 1
a227 1
		if (diff_pflag == 1)
d570 2
a571 2
	    p2 != NULL ? cf->file_path : CVS_PATH_DEVNULL, fd1, fd2, NULL)
	    == D_ERROR)
@


1.152
log
@support some additional diff options: -a, -b, -d, -w
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.151 2009/04/03 19:46:56 joris Exp $	*/
d51 1
a51 1
	"bcfD:ik:lNnpr:Ruw",
@


1.151
log
@i fucked up last night, bad so partially revert a piece of
code that wasnt suppose to dissapear:

for uptodate files, we want to compare rev1 against
file_rcsrev to see if we wish to diff or not. saves a bit off logic.

commited with opencvs,
permission by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.150 2009/04/03 08:18:44 joris Exp $	*/
d49 1
a49 1
	"[-cilNnpRu] [[-D date] [-r rev] [-D date2 | -r rev2]] "
d51 1
a51 1
	"cfD:ik:lNnpr:Ru",
d81 8
d93 4
d162 4
@


1.150
log
@my last commit to diff.c broke diffing in some cases,
noticed the hard way here at work.

commiting with opencvs,
permission by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.149 2009/04/02 21:13:50 joris Exp $	*/
d413 5
@


1.149
log
@properly deal with uptodate files server-side, as they do not
have a file on disk we'll need to load the revision into
a temporary file to do our comparison.

do not even bother trying diffing 2 off the same revisions
either. causes less noise... way less.

you guessed it, commited using opencvs entirely.
with permission from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.148 2009/04/02 09:09:40 joris Exp $	*/
a412 3
		if (diff_rev1 != NULL && diff_rev2 == NULL &&
		    rcsnum_cmp(diff_rev1, cf->file_ent->ce_rev, 0) == 0)
			goto cleanup;
@


1.148
log
@make sure diffing -rTAG -rTAG works even if files are uptodate

commited with opencvs,
with permission by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.147 2009/03/23 07:28:05 joris Exp $	*/
a325 3
	if (cf->file_status == FILE_PATCH)
		return;

d413 2
a414 3
		if (cf->file_status == FILE_UPTODATE && diff_rev1 != NULL &&
		    diff_rev2 == NULL &&
		    rcsnum_cmp(diff_rev1, cf->file_rcsrev, 0) == 0)
d461 6
a466 3
		if (fstat(cf->fd, &st) == -1)
			fatal("fstat failed %s", strerror(errno));
		b1 = cvs_buf_load_fd(cf->fd);
d468 8
a475 3
		tv2[0].tv_sec = st.st_mtime;
		tv2[0].tv_usec = 0;
		tv2[1] = tv2[0];
d477 7
a483 3
		(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
		fd2 = cvs_buf_write_stmp(b1, p2, tv2);
		cvs_buf_free(b1);
@


1.147
log
@any directory messages are, believe it or not, suppose to go to LP_ERR
instead of LP_NOTICE, while here modify output for non-existing
files to match "? foobar" instead of "cannot find foobar".

makes our output a little less alien and a little bit more gnuish.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.146 2009/03/19 10:09:16 joris Exp $	*/
d417 1
@


1.146
log
@do not diff files server-side that are uptodate but require a patch,
as the client does not provide these files at all because they are
not modified in anyway. otherwise this results in bad mojo.

found by myself and sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.145 2009/02/21 14:50:53 joris Exp $	*/
d269 1
a269 1
			cvs_log(LP_NOTICE, "Diffing inside %s", cf->file_path);
d309 1
a309 2
				cvs_log(LP_ERR, "cannot find %s",
					    cf->file_path);
@


1.145
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.144 2008/06/20 14:04:29 tobias Exp $	*/
d325 3
@


1.144
log
@Properly send -D arguments to server when run as a client.  Issue spotted
by sthen.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.143 2008/06/20 13:59:14 tobias Exp $	*/
d289 3
a291 4
			if (cf->fd == -1) {
				if (!cvs_server_active)
					cvs_log(LP_ERR, "cannot find %s",
					    cf->file_path);
d308 1
a308 1
			if (cvs_server_active != 1 && cf->fd == -1) {
d459 2
a460 1
	} else if (cvs_cmdop == CVS_OP_DIFF && cf->fd != -1 &&
@


1.143
log
@If -N has been specified along -D for diff, treat invalid dates as non-existent file.  Spotted by sthen.  ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.142 2008/06/17 06:38:21 joris Exp $	*/
d42 2
d88 1
d91 1
d164 2
a165 1
		if (rev1 == NULL)
d213 5
@


1.142
log
@unbreak diff for newly added files, tsk.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.141 2008/06/14 04:34:08 tobias Exp $	*/
d333 1
a333 1
			if (rev1 != NULL)
d336 4
a339 1
			else {
d345 1
a346 1
			goto cleanup;
d373 3
d382 1
a383 1
			goto cleanup;
d405 1
a405 1
		if (cf->file_status == FILE_UPTODATE &&
@


1.141
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.140 2008/06/11 20:55:34 joris Exp $	*/
d318 1
a318 1
	if (cf->file_rcs->rf_head == NULL) {
@


1.140
log
@do not count on files that are uptodate to be on disk in a remote setup.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.139 2008/06/11 02:19:13 tobias Exp $	*/
d317 6
@


1.139
log
@Avoid possible NULL pointer dereferences by using reentrant versions
of time functions.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.138 2008/06/10 17:34:36 tobias Exp $	*/
d299 2
a300 3
			if (cf->fd == -1) {
				if (!cvs_server_active)
					cvs_log(LP_ERR, "cannot find %s",
d304 1
@


1.138
log
@Omit "cannot find file" on server-side if client runs "diff" on an up-to-date
file, because it won't be sent to server then.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.137 2008/05/30 11:06:17 tobias Exp $	*/
d26 1
d248 1
a248 1
	struct tm *datetm;
d331 1
a331 1
				datetm = gmtime(&cvs_specified_date);
d333 1
a333 1
				    "%Y.%m.%d.%H.%M.%S", datetm);
d365 1
a365 1
				datetm = gmtime(&cvs_specified_date);
d367 1
a367 1
				    "%Y.%m.%d.%H.%M.%S", datetm);
@


1.137
log
@diff -D support, also a change in diff_internals to properly print
file name or /dev/null, if file has been removed or added.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.136 2008/05/30 10:12:12 tobias Exp $	*/
d279 3
a281 2
				cvs_log(LP_ERR, "cannot find %s",
				    cf->file_path);
d299 3
a301 2
				cvs_log(LP_ERR, "cannot find %s",
				    cf->file_path);
@


1.136
log
@Major rework of our cvs diff implementation fixes tons of GNU cvs
compatibility glitches and bugs which have been spotted by ray@@ and
Igor Zinovik.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.135 2008/05/22 15:45:01 tobias Exp $	*/
d39 2
d82 10
d129 1
a129 1
			if (rev1 == NULL) {
d131 1
a131 1
			} else if (rev2 == NULL) {
d247 2
a248 1
	char rbuf[CVS_REV_BUFSZ], *p1, *p2;
a301 1
			break;
d311 2
a312 1
	if (cf->file_status == FILE_UPTODATE && rev1 == NULL && rev2 == NULL)
d320 2
a321 1
	else if (rev1 != NULL) {
d324 10
a333 2
			cvs_log(LP_ERR, "tag %s not in file %s", rev1,
			    cf->file_path);
d344 1
d354 2
a355 1
	else if (rev2 != NULL) {
d358 10
a367 2
			cvs_log(LP_ERR, "tag %s not in file %s", rev2,
			    cf->file_path);
d378 1
@


1.135
log
@expension -> expansion

ok joris, xsa (quite some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.134 2008/03/13 19:54:34 sthen Exp $	*/
d3 1
d106 1
d150 3
a230 1
	RCSNUM *r1;
a236 1
	r1 = NULL;
d238 2
d251 6
a256 18
	if (cf->file_status == FILE_LOST) {
		cvs_log(LP_ERR, "cannot find file %s", cf->file_path);
		return;
	} else if (cf->file_status == FILE_UNKNOWN) {
		cvs_log(LP_ERR, "I know nothing about %s", cf->file_path);
		return;
	} else if (cf->file_status == FILE_ADDED && Nflag == 0) {
		cvs_log(LP_ERR, "%s is a new entry, no comparison available",
		    cf->file_path);
		return;
	} else if (cf->file_status == FILE_REMOVED && Nflag == 0) {
		cvs_log(LP_ERR, "%s was removed, no comparison available",
		    cf->file_path);
		return;
	} else if (cf->file_status == FILE_UPTODATE && rev1 == NULL &&
	     rev2 == NULL) {
		return;
	}
d258 5
a262 9
	if (kflag)
		rcs_kwexp_set(cf->file_rcs, kflag);

	if (rev1 != NULL)
		if ((diff_rev1 = rcs_translate_tag(rev1, cf->file_rcs)) ==
		    NULL) {
			if (cvs_cmdop == CVS_OP_DIFF) {
				cvs_log(LP_ERR, "tag %s is not in file %s",
				    rev1, cf->file_path);
d265 4
a268 9
			if (force_head) {
				/* -f is not allowed for unknown symbols */
				diff_rev1 = rcsnum_parse(rev1);
				if (diff_rev1 == NULL)
					fatal("no such tag %s", rev1);
				rcsnum_free(diff_rev1);

				diff_rev1 = rcsnum_alloc();
				rcsnum_cpy(cf->file_rcs->rf_head, diff_rev1, 0);
d270 5
a274 9
		}

	if (rev2 != NULL)
		if ((diff_rev2 = rcs_translate_tag(rev2, cf->file_rcs)) ==
		    NULL) {
			if (cvs_cmdop == CVS_OP_DIFF) {
				rcsnum_free(diff_rev1);
				cvs_log(LP_ERR, "tag %s is not in file %s",
				    rev2, cf->file_path);
d277 4
a280 9
			if (force_head) {
				/* -f is not allowed for unknown symbols */
				diff_rev2 = rcsnum_parse(rev2);
				if (diff_rev2 == NULL)
					fatal("no such tag %s", rev2);
				rcsnum_free(diff_rev2);

				diff_rev2 = rcsnum_alloc();
				rcsnum_cpy(cf->file_rcs->rf_head, diff_rev2, 0);
d282 14
d297 1
d299 1
a299 1
	if (cvs_cmdop == CVS_OP_RDIFF && diff_rev1 == NULL && diff_rev2 == NULL)
d302 2
a303 1
	diff_file = cf->file_path;
d305 14
a318 3
	cvs_printf("Index: %s\n", cf->file_path);
	if (cvs_cmdop == CVS_OP_DIFF)
		cvs_printf("%s\nRCS file: %s\n", RCS_DIFF_DIV, cf->file_rpath);
d320 5
a324 8
	(void)xasprintf(&p1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
	(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);

	if (cf->file_status != FILE_ADDED) {
		if (diff_rev1 != NULL)
			r1 = diff_rev1;
		else if (cf->file_ent != NULL)
			r1 = cf->file_ent->ce_rev;
d326 2
a327 1
			r1 = NULL;
d329 14
a342 1
		diff_rev1 = r1;
d344 6
a349 2
		if (diff_rev1 != NULL) {
			(void)rcsnum_tostr(r1, rbuf, sizeof(rbuf));
d351 3
a353 3
			tv[0].tv_sec = rcs_rev_getdate(cf->file_rcs, r1);
			tv[0].tv_usec = 0;
			tv[1] = tv[0];
d355 21
a375 5
			if (cvs_cmdop == CVS_OP_DIFF)
				cvs_printf("retrieving revision %s\n", rbuf);
			fd1 = rcs_rev_write_stmp(cf->file_rcs, r1, p1, 0);
			if (futimes(fd1, tv) == -1)
				fatal("cvs_diff_local: utimes failed");
d377 9
d388 5
a392 3
	if (diff_rev2 != NULL && cf->file_status != FILE_ADDED &&
	    cf->file_status != FILE_REMOVED) {
		(void)rcsnum_tostr(diff_rev2, rbuf, sizeof(rbuf));
d398 1
a398 2
		if (cvs_cmdop == CVS_OP_DIFF)
			cvs_printf("retrieving revision %s\n", rbuf);
d402 5
a406 8
	} else if (cf->file_status != FILE_REMOVED) {
		if (cvs_cmdop == CVS_OP_RDIFF || (cvs_server_active == 1 &&
		    cf->file_status != FILE_MODIFIED)) {
			if (diff_rev2 != NULL) {
				tv2[0].tv_sec = rcs_rev_getdate(cf->file_rcs,
				    cf->file_rcsrev);
				tv2[0].tv_usec = 0;
				tv2[1] = tv2[0];
d408 3
a410 9
				fd2 = rcs_rev_write_stmp(cf->file_rcs,
				    cf->file_rcsrev, p2, 0);
				if (futimes(fd2, tv2) == -1)
					fatal("cvs_diff_local: utimes failed");
			}
		} else {
			if (fstat(cf->fd, &st) == -1)
				fatal("fstat failed %s", strerror(errno));
			b1 = cvs_buf_load_fd(cf->fd);
d412 3
a414 7
			tv2[0].tv_sec = st.st_mtime;
			tv2[0].tv_usec = 0;
			tv2[1] = tv2[0];

			fd2 = cvs_buf_write_stmp(b1, p2, tv2);
			cvs_buf_free(b1);
		}
d417 2
a418 1
	if (cvs_cmdop == CVS_OP_DIFF) {
d421 2
a422 2
		if (cf->file_status != FILE_ADDED) {
			(void)rcsnum_tostr(r1, rbuf, sizeof(rbuf));
d425 1
a425 1
			if (diff_rev2 != NULL) {
d433 1
a433 1
			cvs_printf(" %s", cf->file_name);
d435 2
a436 1
	} else {
d465 1
d468 3
a470 16
	if (cf->file_status == FILE_ADDED ||
	    (cvs_cmdop == CVS_OP_RDIFF && diff_rev1 == NULL)) {
		xfree(p1);
		close(fd1);
		(void)xasprintf(&p1, "%s", CVS_PATH_DEVNULL);
		if ((fd1 = open(p1, O_RDONLY)) == -1)
			fatal("cvs_diff_local: cannot open %s",
			    CVS_PATH_DEVNULL);
	} else if (cf->file_status == FILE_REMOVED ||
	    (cvs_cmdop == CVS_OP_RDIFF && diff_rev2 == NULL)) {
		xfree(p2);
		close(fd2);
		(void)xasprintf(&p2, "%s", CVS_PATH_DEVNULL);
		if ((fd2 = open(p2, O_RDONLY)) == -1)
			fatal("cvs_diff_local: cannot open %s",
			    CVS_PATH_DEVNULL);
d472 4
d477 3
a479 1
	if (cvs_diffreg(p1, p2, fd1, fd2, NULL) == D_ERROR)
d492 6
a497 5
	if (diff_rev1 != NULL && diff_rev1 != cf->file_rcs->rf_head &&
	    (cf->file_ent != NULL && diff_rev1 != cf->file_ent->ce_rev))
		rcsnum_free(diff_rev1);
	if (diff_rev2 != NULL)
		rcsnum_free(diff_rev2);
d499 4
a502 1
	diff_rev1 = diff_rev2 = NULL;
@


1.134
log
@when a file was locally removed and a diff was done against
an opencvs server (with either gnu or opencvs as the client),
no actual diff output was produced. traced to the typo fixed
in this diff.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.133 2008/03/02 19:05:34 tobias Exp $	*/
d91 1
a91 1
				    "invalid RCS keyword expension mode");
@


1.133
log
@Print the right synopsis for commands on error (especially if commands
share the same function: (r)tag, etc.).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.132 2008/03/01 21:29:36 deraadt Exp $	*/
d448 1
a448 1
		if ((fd1 = open(p2, O_RDONLY)) == -1)
@


1.132
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.131 2008/02/27 22:34:04 joris Exp $	*/
d92 3
a94 1
				fatal("%s", cvs_cmd_add.cmd_synopsis);
d132 3
a134 1
			fatal("%s", cvs_cmd_diff.cmd_synopsis);
@


1.131
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.130 2008/02/27 20:04:59 tobias Exp $	*/
d89 1
a89 1
			if (RCS_KWEXP_INVAL(kflag)) {   
d272 1
a272 1
 			if (force_head) {
d293 1
a293 1
 			if (force_head) {
@


1.130
log
@Always end line that states diff options with a newline.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.129 2008/02/11 20:33:11 tobias Exp $	*/
d22 1
d224 1
d336 2
a337 2
			rcs_rev_write_stmp(cf->file_rcs, r1, p1, 0);
			if (utimes(p1, tv) == -1)
d352 2
a353 2
		rcs_rev_write_stmp(cf->file_rcs, diff_rev2, p2, 0);
		if (utimes(p2, tv2) == -1)
d364 1
a364 1
				rcs_rev_write_stmp(cf->file_rcs,
d366 1
a366 1
				if (utimes(p2, tv2) == -1)
d378 1
a378 1
			cvs_buf_write_stmp(b1, p2, tv2);
d434 1
d436 3
d442 1
d444 3
d449 1
a449 1
	if (cvs_diffreg(p1, p2, NULL) == D_ERROR)
d451 3
@


1.129
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.128 2008/02/09 12:27:31 tobias Exp $	*/
d396 2
a397 1
			cvs_printf(" %s\n", cf->file_name);
@


1.128
log
@If run as server, (r)diff should properly write (r)diff into header
instead of "server".

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.127 2008/02/04 21:25:32 tobias Exp $	*/
d370 1
a370 2
			if ((b1 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
				fatal("failed to load %s", cf->file_path);
@


1.127
log
@r* commands have their own usage; don't check usage of their working dir
equivalents.

OK joris@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.126 2008/02/04 15:07:33 tobias Exp $	*/
d68 2
a69 1
	strlcpy(diffargs, argv[0], sizeof(diffargs));
@


1.126
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.125 2008/02/03 18:18:44 tobias Exp $	*/
d63 1
a63 1
	int ch;
a64 1
	int flags;
d70 2
a71 1
	while ((ch = getopt(argc, argv, cvs_cmd_diff.cmd_opts)) != -1) {
@


1.125
log
@Added rdiff support.  In order to do this, some output and option fixes
had to be done for diff, too.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.124 2008/01/31 10:15:05 tobias Exp $	*/
d32 5
a36 4
static int Nflag = 0;
static int force_head = 0;
static char *rev1 = NULL;
static char *rev2 = NULL;
d44 1
a44 1
	"cfD:iklNnpr:Ru",
d55 1
a55 1
	"cfD:klr:Ru",
d84 9
d124 3
d157 3
d257 3
@


1.124
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.123 2008/01/29 12:00:34 tobias Exp $	*/
d19 1
d22 1
d33 1
d43 12
a54 1
	"cD:iklNnpr:Ru",
d76 7
a90 1
			strlcat(diffargs, " -N", sizeof(diffargs));
d125 12
d169 4
d180 7
a186 4
	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);
d191 4
a194 1
		cvs_client_send_request("diff");
d243 18
a260 2
		if ((diff_rev1 = rcs_translate_tag(rev1, cf->file_rcs)) == NULL)
			return;
d265 16
a280 2
			rcsnum_free(diff_rev1);
			return;
d283 3
d287 4
a290 2
	cvs_printf("Index: %s\n%s\nRCS file: %s\n", cf->file_path,
	    RCS_DIFF_DIV, cf->file_rpath);
d298 2
d301 1
a301 1
			r1 = cf->file_ent->ce_rev;
a303 1
		rcsnum_tostr(r1, rbuf , sizeof(rbuf));
d305 2
a306 3
		tv[0].tv_sec = rcs_rev_getdate(cf->file_rcs, r1);
		tv[0].tv_usec = 0;
		tv[1] = tv[0];
d308 10
a317 2
		cvs_printf("Retrieving revision %s\n", rbuf);
		rcs_rev_write_stmp(cf->file_rcs, r1, p1, 0);
d322 1
a322 1
		rcsnum_tostr(diff_rev2, rbuf, sizeof(rbuf));
d328 2
a329 1
		cvs_printf("Retrieving revision %s\n", rbuf);
d331 2
d334 13
a346 4
		if (cvs_server_active == 1 &&
		    cf->file_status != FILE_MODIFIED) {
			rcs_rev_write_stmp(cf->file_rcs,
			    cf->file_rcsrev, p2, 0);
d362 13
a374 1
	cvs_printf("%s", diffargs);
d376 23
a398 3
	if (cf->file_status != FILE_ADDED) {
		rcsnum_tostr(r1, rbuf, sizeof(rbuf));
		cvs_printf(" -r%s", rbuf);
d400 6
a405 3
		if (diff_rev2 != NULL) {
			rcsnum_tostr(diff_rev2, rbuf, sizeof(rbuf));
			cvs_printf(" -r%s", rbuf);
d409 2
a410 3
	cvs_printf(" %s\n", cf->file_path);

	if (cf->file_status == FILE_ADDED) {
d413 2
a414 1
	} else if (cf->file_status == FILE_REMOVED) {
d429 2
a430 1
	if (diff_rev1 != NULL && diff_rev1 != cf->file_ent->ce_rev)
d432 1
a432 1
	if (diff_rev2 != NULL && diff_rev2 != cf->file_rcsrev)
@


1.123
log
@Properly free dynamically allocated memory on error path.

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.122 2008/01/28 20:31:07 tobias Exp $	*/
d35 1
a35 1
	CVS_OP_DIFF, 0, "diff",
@


1.122
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.121 2007/09/22 16:01:22 joris Exp $	*/
d205 3
a207 1
		if ((diff_rev2 = rcs_translate_tag(rev2, cf->file_rcs)) == NULL)
d209 1
@


1.121
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.120 2007/06/28 21:38:09 xsa Exp $	*/
d38 1
a38 1
	"[-cilNnpu] [[-D date] [-r rev] [-D date2 | -r rev2]] "
d76 3
@


1.120
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.119 2007/06/27 04:23:54 joris Exp $	*/
d176 1
a176 1
	cvs_file_classify(cf, NULL);
d199 2
a200 1
			fatal("cvs_diff_local: could not translate tag `%s'", rev1);
d203 1
a203 1
			fatal("cvs_diff_local: could not translate tag `%s'", rev2);
d240 13
a252 4
		if (fstat(cf->fd, &st) == -1)
			fatal("fstat failed %s", strerror(errno));
		if ((b1 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
			fatal("failed to load %s", cf->file_path);
d254 3
a256 6
		tv2[0].tv_sec = st.st_mtime;
		tv2[0].tv_usec = 0;
		tv2[1] = tv2[0];

		cvs_buf_write_stmp(b1, p2, tv2);
		cvs_buf_free(b1);
@


1.119
log
@fix diff output in a remote setup so our client does not freak out.

noticed and "yes, that's much shinier" by ckuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.118 2007/02/22 06:42:09 otto Exp $	*/
d163 1
a163 1
	char rbuf[16], *p1, *p2;
@


1.118
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.117 2007/02/09 03:49:15 joris Exp $	*/
d224 1
a224 1
		printf("Retrieving revision %s\n", rbuf);
d236 1
a236 1
		printf("Retrieving revision %s\n", rbuf);
@


1.117
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.116 2007/01/26 11:19:44 joris Exp $	*/
d18 5
a22 1
#include "includes.h"
a25 1
#include "log.h"
@


1.116
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.115 2007/01/20 01:07:51 niallo Exp $	*/
d173 1
a173 1
	cvs_file_classify(cf, NULL, 0);
@


1.115
log
@sweep opencvs for missing rcs_translate_tag() return checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.114 2007/01/15 04:21:38 joris Exp $	*/
a240 1
		st.st_mtime = cvs_hack_time(st.st_mtime, 1);
@


1.114
log
@replace old diffing mechanisms with the new fluffy RCS stuff,
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.113 2007/01/14 23:10:56 joris Exp $	*/
d195 2
a196 1
		diff_rev1 = rcs_translate_tag(rev1, cf->file_rcs);
d198 2
a199 1
		diff_rev2 = rcs_translate_tag(rev2, cf->file_rcs);
@


1.113
log
@move things around in rcs_rev_getbuf() and rcs_rev_write_fd()
so that we do keyword expansion on-the-fly if required instead
of obtaining the revision in memory first, running over the revision
lines while expanding keywords and only then writing them to the fd
or memory buffer.

this drasticly decreases cpu usage by opencvs on very large trees (like src).

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.112 2007/01/12 23:32:01 niallo Exp $	*/
d157 1
a157 1
	BUF *b1, *b2;
d163 1
a163 1
	b1 = b2 = NULL;
d203 3
a213 3
		cvs_printf("retrieving revision %s\n", rbuf);
		if ((b1 = rcs_rev_getbuf(cf->file_rcs, r1, 0)) == NULL)
			fatal("failed to retrieve revision %s", rbuf);
d218 3
a225 3
		cvs_printf("retrieving revision %s\n", rbuf);
		if ((b2 = rcs_rev_getbuf(cf->file_rcs, diff_rev2, 0)) == NULL)
			fatal("failed to retrieve revision %s", rbuf);
d230 3
d236 1
a236 1
		if ((b2 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
d243 3
d262 2
a263 5
	if (cf->file_status != FILE_ADDED) {
		(void)xasprintf(&p1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
		cvs_buf_write_stmp(b1, p1, tv);
		cvs_buf_free(b1);
	} else
d265 2
a266 6

	if (cf->file_status != FILE_REMOVED) {
		(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
		cvs_buf_write_stmp(b2, p2, tv2);
		cvs_buf_free(b2);
	} else
d268 1
@


1.112
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.111 2007/01/11 10:37:18 xsa Exp $	*/
d212 1
a212 1
		if ((b1 = rcs_rev_getbuf(cf->file_rcs, r1)) == NULL)
a214 2
		b1 = rcs_kwexp_buf(b1, cf->file_rcs, r1);

d224 1
a224 1
		if ((b2 = rcs_rev_getbuf(cf->file_rcs, diff_rev2)) == NULL)
a225 2

		b2 = rcs_kwexp_buf(b2, cf->file_rcs, diff_rev2);
@


1.111
log
@strl* overload, use xasprintf().
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.110 2007/01/11 02:35:55 joris Exp $	*/
d212 1
a212 1
		if ((b1 = rcs_getrev(cf->file_rcs, r1)) == NULL)
d226 1
a226 1
		if ((b2 = rcs_getrev(cf->file_rcs, diff_rev2)) == NULL)
@


1.110
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.109 2006/07/08 09:25:44 ray Exp $	*/
a155 1
	size_t len;
d160 4
a163 1
	char rbuf[16], p1[MAXPATHLEN], p2[MAXPATHLEN];
d261 1
a261 8
		len = strlcpy(p1, cvs_tmpdir, sizeof(p1));
		if (len >= sizeof(p1))
			fatal("cvs_diff_local: truncation");

		len = strlcat(p1, "/diff1.XXXXXXXXXX", sizeof(p1));
		if (len >= sizeof(p1))
			fatal("cvs_diff_local: truncation");

d264 2
a265 5
	} else {
		len = strlcpy(p1, CVS_PATH_DEVNULL, sizeof(p1));
		if (len >= sizeof(p1))
			fatal("cvs_diff_local: truncation");
	}
d268 1
a268 8
		len = strlcpy(p2, cvs_tmpdir, sizeof(p2));
		if (len >= sizeof(p2))
			fatal("cvs_diff_local: truncation");

		len = strlcat(p2, "/diff2.XXXXXXXXXX", sizeof(p2));
		if (len >= sizeof(p2))
			fatal("cvs_diff_local: truncation");

d271 5
a275 5
	} else {
		len = strlcpy(p2, CVS_PATH_DEVNULL, sizeof(p2));
		if (len >= sizeof(p2))
			fatal("cvs_diff_local: truncation");
	}
a276 1
	cvs_diffreg(p1, p2, NULL);
d278 5
@


1.109
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.108 2006/07/07 17:37:17 joris Exp $	*/
d100 1
@


1.108
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.107 2006/07/01 01:07:50 ray Exp $	*/
d266 1
a266 1
		cvs_buf_write_stmp(b1, p1, 0600, tv);
d283 1
a283 1
		cvs_buf_write_stmp(b2, p2, 0600, tv2);
@


1.107
log
@Indentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.106 2006/06/19 05:05:17 joris Exp $	*/
d23 1
a24 1
int	cvs_diff(int, char **);
d98 35
a132 1
	cr.fileproc = cvs_diff_local;
d141 7
@


1.106
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.105 2006/06/16 20:01:10 joris Exp $	*/
d219 1
a219 1
		fatal("cvs_diff_local: truncation");
@


1.105
log
@change a cvs_buf_load() to cvs_buf_load_fd()
spotted by xsa@@ a few days ago
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.104 2006/06/16 14:07:42 joris Exp $	*/
d98 1
a98 2
	cr.local = cvs_diff_local;
	cr.remote = NULL;
@


1.104
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.103 2006/06/14 20:28:53 joris Exp $	*/
d194 1
a194 1
		if ((b2 = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
@


1.103
log
@simplify cvs_hack_time() and the way it is called;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.102 2006/06/01 20:01:47 joris Exp $	*/
a22 1
#include "proto.h"
d32 1
a32 1
	CVS_OP_DIFF, CVS_REQ_DIFF, "diff",
@


1.102
log
@fix output
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.101 2006/05/31 22:24:12 joris Exp $	*/
a198 3
		if (st.st_mtime == 0)
			fatal("cvs_diff_local: to gmt failed");

@


1.101
log
@support -p flag for diff, makes dlg@@ feel all warm
and fuzzie inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.100 2006/05/31 07:21:25 joris Exp $	*/
a204 2

		diff_rev2 = cf->file_rcsrev;
@


1.100
log
@set diff_rev2 to file_rcsrev when we are using
the file we have on disk as the second thing to diff to.

fixes some output issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.99 2006/05/30 22:25:24 joris Exp $	*/
d71 4
d259 5
@


1.99
log
@fix diff -rrevision usage
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.98 2006/05/30 21:32:52 joris Exp $	*/
d201 2
@


1.98
log
@fill in the correct revision number we will want in file_rcsrev
for each cvs_file struct, this will help us with sticky tags,
commiting to branches and importing into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.97 2006/05/29 07:17:30 joris Exp $	*/
d143 2
a144 1
	} else if (cf->file_status == FILE_UPTODATE && rev2 == NULL) {
@


1.97
log
@make diff accept symbols for -r too now that we have
a translation function.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.96 2006/05/28 07:56:44 joris Exp $	*/
d127 1
a127 1
	cvs_file_classify(cf, 0);
@


1.96
log
@allow commands to shut up the output from cvs_file_classify
if the commands want to output certain stuff themselfs
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.95 2006/05/27 21:11:11 joris Exp $	*/
d28 3
a30 1
int Nflag = 0;
d72 4
a75 8
			if (diff_rev1 == NULL) {
				diff_rev1 = rcsnum_parse(optarg);
				if (diff_rev1 == NULL)
					fatal("rcsnum_parse failed");
			} else if (diff_rev2 == NULL) {
				diff_rev2 = rcsnum_parse(optarg);
				if (diff_rev2 == NULL)
					fatal("rcsnum_parse failed");
d99 2
d143 1
a143 1
	} else if (cf->file_status == FILE_UPTODATE && diff_rev2 == NULL) {
d146 5
@


1.95
log
@and now you can use -N to diff removed files too
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.94 2006/05/27 20:57:42 joris Exp $	*/
d127 1
a127 1
	cvs_file_classify(cf);
@


1.94
log
@allow diff to pick up newly added files with the -N flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.93 2006/05/27 17:52:27 joris Exp $	*/
d28 1
a28 1
int include_added_files = 0;
d67 1
a67 1
			include_added_files = 1;
d135 1
a135 1
	} else if (cf->file_status == FILE_ADDED && include_added_files == 0) {
d139 4
d170 2
a171 1
	if (diff_rev2 != NULL && cf->file_status != FILE_ADDED) {
d182 1
a182 1
	} else {
d228 4
a231 3
	len = strlcpy(p2, cvs_tmpdir, sizeof(p2));
	if (len >= sizeof(p2))
		fatal("cvs_diff_local: truncation");
d233 3
a235 3
	len = strlcat(p2, "/diff2.XXXXXXXXXX", sizeof(p2));
	if (len >= sizeof(p2))
		fatal("cvs_diff_local: truncation");
d237 7
a243 2
	cvs_buf_write_stmp(b2, p2, 0600, tv2);
	cvs_buf_free(b2);
@


1.93
log
@dont forget to expand any keywords before diffing stuff,
otherwise we might end up with chunks that are totally wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.92 2006/05/27 15:14:27 joris Exp $	*/
d28 2
d65 4
d135 3
a137 1
	} else if (cf->file_status == FILE_UPTODATE && diff_rev2 == NULL)
d139 3
d147 5
a151 4
	if (diff_rev1 != NULL)
		r1 = diff_rev1;
	else
		r1 = cf->file_ent->ce_rev;
d153 5
a157 5
	diff_rev1 = r1;
	rcsnum_tostr(r1, rbuf , sizeof(rbuf));
	cvs_printf("retrieving revision %s\n", rbuf);
	if ((b1 = rcs_getrev(cf->file_rcs, r1)) == NULL)
		fatal("failed to retrieve revision %s", rbuf);
d159 1
a159 1
	b1 = rcs_kwexp_buf(b1, cf->file_rcs, r1);
d161 4
a164 3
	tv[0].tv_sec = rcs_rev_getdate(cf->file_rcs, r1);
	tv[0].tv_usec = 0;
	tv[1] = tv[0];
d166 1
a166 1
	if (diff_rev2 != NULL) {
d194 3
a196 2
	rcsnum_tostr(r1, rbuf, sizeof(rbuf));
	cvs_printf(" -r%s", rbuf);
d198 4
a201 3
	if (diff_rev2 != NULL) {
		rcsnum_tostr(diff_rev2, rbuf, sizeof(rbuf));
		cvs_printf(" -r%s", rbuf);
d206 3
a208 2
	len = strlcpy(p1, cvs_tmpdir, sizeof(p1));
	if (len >= sizeof(p1))
d211 3
a213 3
	len = strlcat(p1, "/diff1.XXXXXXXXXX", sizeof(p1));
	if (len >= sizeof(p1))
		fatal("cvs_diff_local: truncation");
d215 7
a221 2
	cvs_buf_write_stmp(b1, p1, 0600, tv);
	cvs_buf_free(b1);
d236 2
@


1.92
log
@allow commands to respect the -l flag, if the -l flag is
specified certain commands will not recurse into directories.

at the same time introduce a method of specifying wether or not
a command should look in the repository for files.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.91 2006/05/27 03:30:30 joris Exp $	*/
d147 2
d158 2
@


1.91
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
d47 1
d56 3
d93 1
@


1.90
log
@- don't append the extension if it's already there (PR 5076).
- show magic branches in rlog (thanks for that nicer hack niall).
- correct output in rcsdiff, so we perfectly match gnu's

all these bugs were found by sturm@@ while he was using cvsweb
(which uses the RCS tools).

"it is in my view that you should put it in" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.89 2006/04/14 02:45:35 deraadt Exp $	*/
d3 1
a3 2
 * Copyright (C) Caldera International Inc.  2001-2002.
 * All rights reserved.
d5 11
a15 121
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code and documentation must retain the above
 *    copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * 4. Neither the name of Caldera International, Inc. nor the names of other
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
 * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 2004 Jean-Francois Brousseau.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)diffreg.c   8.1 (Berkeley) 6/6/93
 */
/*
 *	Uses an algorithm due to Harold Stone, which finds
 *	a pair of longest identical subsequences in the two
 *	files.
 *
 *	The major goal is to generate the match vector J.
 *	J[i] is the index of the line in file1 corresponding
 *	to line i file0. J[i] = 0 if there is no
 *	such line in file1.
 *
 *	Lines are hashed so as to work in core. All potential
 *	matches are located by sorting the lines of each file
 *	on the hash (called ``value''). In particular, this
 *	collects the equivalence classes in file1 together.
 *	Subroutine equiv replaces the value of each line in
 *	file0 by the index of the first element of its
 *	matching equivalence in (the reordered) file1.
 *	To save space equiv squeezes file1 into a single
 *	array member in which the equivalence classes
 *	are simply concatenated, except that their first
 *	members are flagged by changing sign.
 *
 *	Next the indices that point into member are unsorted into
 *	array class according to the original order of file0.
 *
 *	The cleverness lies in routine stone. This marches
 *	through the lines of file0, developing a vector klist
 *	of "k-candidates". At step i a k-candidate is a matched
 *	pair of lines x,y (x in file0 y in file1) such that
 *	there is a common subsequence of length k
 *	between the first i lines of file0 and the first y
 *	lines of file1, but there is no such subsequence for
 *	any smaller y. x is the earliest possible mate to y
 *	that occurs in such a subsequence.
 *
 *	Whenever any of the members of the equivalence class of
 *	lines in file1 matable to a line in file0 has serial number
 *	less than the y of some k-candidate, that k-candidate
 *	with the smallest such y is replaced. The new
 *	k-candidate is chained (via pred) to the current
 *	k-1 candidate so that the actual subsequence can
 *	be recovered. When a member has serial number greater
 *	that the y of all k-candidates, the klist is extended.
 *	At the end, the longest subsequence is pulled out
 *	and placed in the array J by unravel
 *
 *	With J in hand, the matches there recorded are
 *	check'ed against reality to assure that no spurious
 *	matches have crept in due to hashing. If they have,
 *	they are broken, and "jackpot" is recorded--a harmless
 *	matter except that a true match for a spuriously
 *	mated line may now be unnecessarily reported as a change.
 *
 *	Much of the complexity of the program comes simply
 *	from trying to minimize core utilization and
 *	maximize the range of doable problems by dynamically
 *	allocating what is needed and reusing what is not.
 *	The core requirements for problems larger than somewhat
 *	are (in words) 2*length(file0) + length(file1) +
 *	3*(number of k-candidates installed),  typically about
 *	6n words for files of length n.
a19 1
#include "buf.h"
d25 2
a26 31
#include "xmalloc.h"

struct cand {
	int	x;
	int	y;
	int	pred;
} cand;

struct line {
	int	serial;
	int	value;
} *file[2];

/*
 * The following struct is used to record change in formation when
 * doing a "context" or "unified" diff.  (see routine "change" to
 * understand the highly mnemonic field names)
 */
struct context_vec {
	int	a;	/* start line in old file */
	int	b;	/* end line in old file */
	int	c;	/* start line in new file */
	int	d;	/* end line in new file */
};

struct diff_arg {
	char	*rev1;
	char	*rev2;
	char	*date1;
	char	*date2;
};
a27 134
#if !defined(RCSPROG)
static int	cvs_diff_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_diff_remote(CVSFILE *, void *);
static int	cvs_diff_local(CVSFILE *, void *);
static int	cvs_diff_pre_exec(struct cvsroot *);
static int	cvs_diff_cleanup(void);
#endif

static void	 output(FILE *, FILE *);
static void	 check(FILE *, FILE *);
static void	 range(int, int, char *);
static void	 uni_range(int, int);
static void	 dump_context_vec(FILE *, FILE *);
static void	 dump_unified_vec(FILE *, FILE *);
static int	 prepare(int, FILE *, off_t);
static void	 prune(void);
static void	 equiv(struct line *, int, struct line *, int, int *);
static void	 unravel(int);
static void	 unsort(struct line *, int, int *);
static void	 change(FILE *, FILE *, int, int, int, int);
static void	 sort(struct line *, int);
static int	 ignoreline(char *);
static int	 asciifile(FILE *);
static void	 fetch(long *, int, int, FILE *, int, int);
static int	 newcand(int, int, int);
static int	 search(int *, int, int);
static int	 skipline(FILE *);
static int	 isqrt(int);
static int	 stone(int *, int, int *, int *);
static int	 readhash(FILE *);
static int	 files_differ(FILE *, FILE *);
static char	*match_function(const long *, int, FILE *);
static char	*preadline(int, size_t, off_t);


#if !defined(RCSPROG)
static int Nflag;
#endif
static int aflag, bflag, dflag, iflag, pflag, tflag, Tflag, wflag;
static int context = 3;
int diff_format = D_NORMAL;
char *diff_file = NULL;
RCSNUM *diff_rev1 = NULL;
RCSNUM *diff_rev2 = NULL;
char diffargs[128];
static struct stat stb1, stb2;
static char *ifdefname, *ignore_pats;
regex_t ignore_re;

static int  *J;			/* will be overlaid on class */
static int  *class;		/* will be overlaid on file[0] */
static int  *klist;		/* will be overlaid on file[0] after class */
static int  *member;		/* will be overlaid on file[1] */
static int   clen;
static int   inifdef;		/* whether or not we are in a #ifdef block */
static int   diff_len[2];
static int   pref, suff;	/* length of prefix and suffix */
static int   slen[2];
static int   anychange;
static long *ixnew;		/* will be overlaid on file[1] */
static long *ixold;		/* will be overlaid on klist */
static struct cand *clist;	/* merely a free storage pot for candidates */
static int   clistlen;		/* the length of clist */
static struct line *sfile[2];	/* shortened by pruning common prefix/suffix */
static u_char *chrtran;		/* translation table for case-folding */
static struct context_vec *context_vec_start;
static struct context_vec *context_vec_end;
static struct context_vec *context_vec_ptr;

#define FUNCTION_CONTEXT_SIZE	41
static char lastbuf[FUNCTION_CONTEXT_SIZE];
static int  lastline;
static int  lastmatchline;
BUF  *diffbuf = NULL;

/*
 * chrtran points to one of 2 translation tables: cup2low if folding upper to
 * lower case clow2low if not folding case
 */
u_char clow2low[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
	0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
	0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c,
	0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
	0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
	0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
	0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
	0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
	0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
	0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
	0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
	0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
	0xfd, 0xfe, 0xff
};

u_char cup2low[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
	0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x60, 0x61,
	0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
	0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
	0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
	0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
	0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
	0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
	0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
	0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
	0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
	0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
	0xfd, 0xfe, 0xff
};

#if !defined(RCSPROG)
d36 1
a36 8
	CF_RECURSE | CF_IGNORE | CF_SORT | CF_KNOWN,
	cvs_diff_init,
	cvs_diff_pre_exec,
	cvs_diff_remote,
	cvs_diff_local,
	NULL,
	cvs_diff_cleanup,
	CVS_CMD_SENDARGS2 | CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR
d39 2
a40 25

struct cvs_cmd cvs_cmd_rdiff = {
	CVS_OP_RDIFF, CVS_REQ_DIFF, "rdiff",
	{ "pa", "patch" },
	"Create 'patch' format diffs between releases",
	"[-flR] [-c | -u] [-s | -t] [-V ver] -D date | -r rev "
	"[-D date2 | -rev2] module ...",
	"cD:flRr:stuV:",
	NULL,
	CF_RECURSE | CF_IGNORE | CF_SORT | CF_KNOWN,
	cvs_diff_init,
	cvs_diff_pre_exec,
	cvs_diff_remote,
	cvs_diff_local,
	NULL,
	cvs_diff_cleanup,
	CVS_CMD_SENDARGS2 | CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR
};
#endif

#if !defined(RCSPROG)
static struct diff_arg *dap = NULL;

static int
cvs_diff_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d43 2
a45 2
	dap = xmalloc(sizeof(*dap));
	dap->date1 = dap->date2 = dap->rev1 = dap->rev2 = NULL;
d48 1
a48 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a53 23
		case 'D':
			if (dap->date1 == NULL && dap->rev1 == NULL) {
				dap->date1 = optarg;
			} else if (dap->date2 == NULL && dap->rev2 == NULL) {
				dap->date2 = optarg;
			} else {
				cvs_log(LP_ERR,
				    "no more than two revisions/dates can "
				    "be specified");
			}
			break;
		case 'l':
			strlcat(diffargs, " -l", sizeof(diffargs));
			cvs_cmd_diff.file_flags &= ~CF_RECURSE;
			break;
		case 'i':
			strlcat(diffargs, " -i", sizeof(diffargs));
			iflag = 1;
			break;
		case 'N':
			strlcat(diffargs, " -N", sizeof(diffargs));
			Nflag = 1;
			break;
a57 4
		case 'p':
			strlcat(diffargs, " -p", sizeof(diffargs));
			pflag = 1;
			break;
d59 8
a66 5
			if (dap->rev1 == NULL && dap->date1 == NULL) {
				dap->rev1 = optarg;
			} else if (dap->rev2 == NULL &&
			    dap->date2 == NULL) {
				dap->rev2 = optarg;
d68 2
a69 4
				cvs_log(LP_ERR,
				    "no more than two revisions/dates can "
				    "be specified");
				return (CVS_EX_USAGE);
a71 3
		case 'R':
			cvs_cmd_diff.file_flags |= CF_RECURSE;
			break;
d77 1
a77 43
			return (CVS_EX_USAGE);
		}
	}

	*arg = optind;
	return (0);
}

int
cvs_diff_cleanup(void)
{
	if (dap != NULL) {
		xfree(dap);
		dap = NULL;
	}
	return (0);
}

/*
 * cvs_diff_pre_exec()
 *
 */
int
cvs_diff_pre_exec(struct cvsroot *root)
{
	if (root->cr_method != CVS_METHOD_LOCAL) {
		/* send the flags */
		if (Nflag == 1)
			cvs_sendarg(root, "-N", 0);
		if (pflag == 1)
			cvs_sendarg(root, "-p", 0);

		if (diff_format == D_CONTEXT)
			cvs_sendarg(root, "-c", 0);
		else if (diff_format == D_UNIFIED)
			cvs_sendarg(root, "-u", 0);

		if (dap->rev1 != NULL) {
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, dap->rev1, 0);
		} else if (dap->date1 != NULL) {
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, dap->date1, 0);
a78 42
		if (dap->rev2 != NULL) {
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, dap->rev2, 0);
		} else if (dap->date2 != NULL) {
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, dap->date2, 0);
		}
	}

	return (0);
}


/*
 * cvs_diff_file()
 *
 * Diff a single file.
 */
static int
cvs_diff_remote(struct cvs_file *cfp, void *arg)
{
	char fpath[MAXPATHLEN];
	struct cvsroot *root;

	if (cfp->cf_type == DT_DIR) {
		if (cfp->cf_cvstat == CVS_FST_UNKNOWN) {
			root = cfp->cf_parent->cf_root;
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
		} else {
			root = cfp->cf_root;
#if 0
			if (cfp->cf_parent == NULL ||
			    (root != cfp->cf_parent->cf_root)) {
				cvs_connect(root);
				cvs_diff_pre_exec(root);
			}
#endif

			cvs_senddir(root, cfp);
		}

		return (0);
d81 2
a82 4
	if (cfp->cf_cvstat == CVS_FST_LOST) {
		cvs_log(LP_WARN, "cannot find file %s", cfp->cf_name);
		return (0);
	}
d84 4
a87 1
	diff_file = cvs_file_getpath(cfp, fpath, sizeof(fpath));
d89 2
a90 2
	if (cfp->cf_parent != NULL)
		root = cfp->cf_parent->cf_root;
d92 1
a92 17
		root = NULL;

	if (cfp->cf_cvstat == CVS_FST_UNKNOWN) {
		cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
		return (0);
	}

	cvs_sendentry(root, cfp);

	if (cfp->cf_cvstat == CVS_FST_UPTODATE) {
		cvs_sendreq(root, CVS_REQ_UNCHANGED, cfp->cf_name);
		return (0);
	}

	/* at this point, the file is modified */
	cvs_sendreq(root, CVS_REQ_MODIFIED, cfp->cf_name);
	cvs_sendfile(root, diff_file);
d97 2
a98 2
static int
cvs_diff_local(CVSFILE *cf, void *arg)
d100 2
a101 3
	char buf[64];
	char fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	char path_tmp1[MAXPATHLEN], path_tmp2[MAXPATHLEN];
d103 1
a103 2
	RCSNUM *r1, *r2;
	RCSFILE *rf;
d105 1
d107 1
a107 5
	memset(&tv, 0, sizeof(tv));
	memset(&tv2, 0, sizeof(tv2));

	rf = NULL;
	diff_file = cvs_file_getpath(cf, fpath, sizeof(fpath));
d109 1
a109 1
	if (cf->cf_type == DT_DIR) {
d111 1
a111 563
			cvs_log(LP_NOTICE, "Diffing %s", fpath);
		return (0);
	}

	if (cf->cf_cvstat == CVS_FST_LOST) {
		cvs_log(LP_WARN, "cannot find file %s", cf->cf_name);
		return (0);
	}

	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		cvs_log(LP_WARN, "I know nothing about %s", diff_file);
		return (0);
	} else if (cf->cf_cvstat == CVS_FST_UPTODATE)
		return (0);

	/* at this point, the file is modified */
	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));

	if ((rf = rcs_open(rcspath, RCS_READ)) == NULL)
		fatal("cvs_diff_local: rcs_open `%s': %s", rcspath,
		    rcs_errstr(rcs_errno));

	cvs_printf("Index: %s\n%s\nRCS file: %s\n", diff_file,
	    RCS_DIFF_DIV, rcspath);

	if (dap->rev1 == NULL)
		r1 = cf->cf_lrev;
	else {
		if ((r1 = rcsnum_parse(dap->rev1)) == NULL)
			fatal("cvs_diff_local: rcsnum_parse failed");
	}

	cvs_printf("retrieving revision %s\n",
	    rcsnum_tostr(r1, buf, sizeof(buf)));
	b1 = rcs_getrev(rf, r1);

	if (b1 == NULL) {
		cvs_log(LP_ERR, "failed to retrieve revision %s",
		    rcsnum_tostr(r1, buf, sizeof(buf)));
		if (r1 != cf->cf_lrev)
			rcsnum_free(r1);
		rcs_close(rf);
		return (CVS_EX_DATA);
	}
	tv[0].tv_sec = (long)rcs_rev_getdate(rf, r1);
	tv[1].tv_sec = tv[0].tv_sec;

	if (r1 != cf->cf_lrev)
		rcsnum_free(r1);

	if (dap->rev2 != NULL) {
		cvs_printf("retrieving revision %s\n", dap->rev2);
		if ((r2 = rcsnum_parse(dap->rev2)) == NULL) {
			rcs_close(rf);
			return (CVS_EX_DATA);
		}
		b2 = rcs_getrev(rf, r2);
		tv2[0].tv_sec = (long)rcs_rev_getdate(rf, r2);
		tv2[1].tv_sec = tv2[0].tv_sec;
		rcsnum_free(r2);
	} else {
		struct stat st;
		if (stat(diff_file, &st) < 0) {
			cvs_log(LP_ERR, "failed to retrieve revision %s",
			    dap->rev2);
			cvs_buf_free(b1);
			return (CVS_EX_DATA);
		}
		b2 = cvs_buf_load(diff_file, BUF_AUTOEXT);
		tv2[0].tv_sec = st.st_mtime;
		tv2[1].tv_sec = st.st_mtime;
	}

	rcs_close(rf);

	if (b2 == NULL) {
		cvs_log(LP_ERR, "failed to retrieve revision %s",
		    dap->rev2);
		cvs_buf_free(b1);
		return (CVS_EX_DATA);
	}

	cvs_printf("%s", diffargs);
	cvs_printf(" -r%s", buf);
	if (dap->rev2 != NULL)
		cvs_printf(" -r%s", dap->rev2);
	cvs_printf(" %s\n", diff_file);
	strlcpy(path_tmp1, cvs_tmpdir, sizeof(path_tmp1));
	strlcat(path_tmp1, "/diff1.XXXXXXXXXX", sizeof(path_tmp1));
	cvs_buf_write_stmp(b1, path_tmp1, 0600);
	cvs_buf_free(b1);
	if (utimes(path_tmp1, (const struct timeval *)&tv) < 0)
		cvs_log(LP_ERRNO, "error setting utimes");

	strlcpy(path_tmp2, cvs_tmpdir, sizeof(path_tmp2));
	strlcat(path_tmp2, "/diff2.XXXXXXXXXX", sizeof(path_tmp2));
	cvs_buf_write_stmp(b2, path_tmp2, 0600);
	cvs_buf_free(b2);
	if (utimes(path_tmp2, (const struct timeval *)&tv2) < 0)
		cvs_log(LP_ERRNO, "error setting utimes");

	cvs_diffreg(path_tmp1, path_tmp2, NULL);
	(void)unlink(path_tmp1);
	(void)unlink(path_tmp2);

	return (0);
}
#endif


int
cvs_diffreg(const char *file1, const char *file2, BUF *out)
{
	FILE *f1, *f2;
	int i, rval;
	void *tmp;

	f1 = f2 = NULL;
	rval = D_SAME;
	anychange = 0;
	lastline = 0;
	lastmatchline = 0;
	context_vec_ptr = context_vec_start - 1;
	chrtran = (iflag ? cup2low : clow2low);
	if (out != NULL)
		diffbuf = out;

	f1 = fopen(file1, "r");
	if (f1 == NULL) {
		cvs_log(LP_ERRNO, "%s", file1);
		goto closem;
	}

	f2 = fopen(file2, "r");
	if (f2 == NULL) {
		cvs_log(LP_ERRNO, "%s", file2);
		goto closem;
	}

	if (stat(file1, &stb1) < 0) {
		cvs_log(LP_ERRNO, "%s", file1);
		goto closem;
	}
	if (stat(file2, &stb2) < 0) {
		cvs_log(LP_ERRNO, "%s", file2);
		goto closem;
	}
	switch (files_differ(f1, f2)) {
	case 0:
		goto closem;
	case 1:
		break;
	default:
		/* error */
		goto closem;
	}

	if (!asciifile(f1) || !asciifile(f2)) {
		rval = D_BINARY;
		goto closem;
	}
	if (prepare(0, f1, stb1.st_size) < 0 ||
	    prepare(1, f2, stb2.st_size) < 0) {
		goto closem;
	}
	prune();
	sort(sfile[0], slen[0]);
	sort(sfile[1], slen[1]);

	member = (int *)file[1];
	equiv(sfile[0], slen[0], sfile[1], slen[1], member);
	tmp = xrealloc(member, slen[1] + 2, sizeof(*member));
	member = tmp;

	class = (int *)file[0];
	unsort(sfile[0], slen[0], class);
	tmp = xrealloc(class, slen[0] + 2, sizeof(*class));
	class = tmp;

	klist = xcalloc(slen[0] + 2, sizeof(*klist));
	clen = 0;
	clistlen = 100;
	clist = xcalloc(clistlen, sizeof(*clist));

	if ((i = stone(class, slen[0], member, klist)) < 0)
		goto closem;

	xfree(member);
	xfree(class);

	tmp = xrealloc(J, diff_len[0] + 2, sizeof(*J));
	J = tmp;
	unravel(klist[i]);
	xfree(clist);
	xfree(klist);

	tmp = xrealloc(ixold, diff_len[0] + 2, sizeof(*ixold));
	ixold = tmp;

	tmp = xrealloc(ixnew, diff_len[1] + 2, sizeof(*ixnew));
	ixnew = tmp;
	check(f1, f2);
	output(f1, f2);

closem:
	if (anychange == 1) {
		if (rval == D_SAME)
			rval = D_DIFFER;
	}
	if (f1 != NULL)
		fclose(f1);
	if (f2 != NULL)
		fclose(f2);

	return (rval);
}

/*
 * Check to see if the given files differ.
 * Returns 0 if they are the same, 1 if different, and -1 on error.
 * XXX - could use code from cmp(1) [faster]
 */
static int
files_differ(FILE *f1, FILE *f2)
{
	char buf1[BUFSIZ], buf2[BUFSIZ];
	size_t i, j;

	if (stb1.st_size != stb2.st_size)
		return (1);
	for (;;) {
		i = fread(buf1, (size_t)1, sizeof(buf1), f1);
		j = fread(buf2, (size_t)1, sizeof(buf2), f2);
		if (i != j)
			return (1);
		if (i == 0 && j == 0) {
			if (ferror(f1) || ferror(f2))
				return (1);
			return (0);
		}
		if (memcmp(buf1, buf2, i) != 0)
			return (1);
	}
}

static int
prepare(int i, FILE *fd, off_t filesize)
{
	void *tmp;
	struct line *p;
	int j, h;
	size_t sz;

	rewind(fd);

	sz = ((size_t)filesize <= SIZE_MAX ? (size_t)filesize : SIZE_MAX) / 25;
	if (sz < 100)
		sz = 100;

	p = xcalloc(sz + 3, sizeof(*p));
	for (j = 0; (h = readhash(fd));) {
		if (j == (int)sz) {
			sz = sz * 3 / 2;
			tmp = xrealloc(p, sz + 3, sizeof(*p));
			p = tmp;
		}
		p[++j].value = h;
	}
	diff_len[i] = j;
	file[i] = p;

	return (0);
}

static void
prune(void)
{
	int i, j;

	for (pref = 0; pref < diff_len[0] && pref < diff_len[1] &&
	    file[0][pref + 1].value == file[1][pref + 1].value;
	    pref++)
		;
	for (suff = 0;
	    (suff < diff_len[0] - pref) && (suff < diff_len[1] - pref) &&
	    (file[0][diff_len[0] - suff].value ==
	    file[1][diff_len[1] - suff].value);
	    suff++)
		;
	for (j = 0; j < 2; j++) {
		sfile[j] = file[j] + pref;
		slen[j] = diff_len[j] - pref - suff;
		for (i = 0; i <= slen[j]; i++)
			sfile[j][i].serial = i;
	}
}

static void
equiv(struct line *a, int n, struct line *b, int m, int *c)
{
	int i, j;

	i = j = 1;
	while (i <= n && j <= m) {
		if (a[i].value < b[j].value)
			a[i++].value = 0;
		else if (a[i].value == b[j].value)
			a[i++].value = j;
		else
			j++;
	}
	while (i <= n)
		a[i++].value = 0;
	b[m + 1].value = 0;
	j = 0;
	while (++j <= m) {
		c[j] = -b[j].serial;
		while (b[j + 1].value == b[j].value) {
			j++;
			c[j] = b[j].serial;
		}
	}
	c[j] = -1;
}

/* Code taken from ping.c */
static int
isqrt(int n)
{
	int y, x = 1;

	if (n == 0)
		return (0);

	do { /* newton was a stinker */
		y = x;
		x = n / x;
		x += y;
		x /= 2;
	} while (x - y > 1 || x - y < -1);

	return (x);
}

static int
stone(int *a, int n, int *b, int *c)
{
	int ret;
	int i, k, y, j, l;
	int oldc, tc, oldl;
	u_int numtries;

	/* XXX move the isqrt() out of the macro to avoid multiple calls */
	const u_int bound = dflag ? UINT_MAX : MAX(256, (u_int)isqrt(n));

	k = 0;
	if ((ret = newcand(0, 0, 0)) < 0)
		return (-1);
	c[0] = ret;
	for (i = 1; i <= n; i++) {
		j = a[i];
		if (j == 0)
			continue;
		y = -b[j];
		oldl = 0;
		oldc = c[0];
		numtries = 0;
		do {
			if (y <= clist[oldc].y)
				continue;
			l = search(c, k, y);
			if (l != oldl + 1)
				oldc = c[l - 1];
			if (l <= k) {
				if (clist[c[l]].y <= y)
					continue;
				tc = c[l];
				if ((ret = newcand(i, y, oldc)) < 0)
					return (-1);
				c[l] = ret;
				oldc = tc;
				oldl = l;
				numtries++;
			} else {
				if ((ret = newcand(i, y, oldc)) < 0)
					return (-1);
				c[l] = ret;
				k++;
				break;
			}
		} while ((y = b[++j]) > 0 && numtries < bound);
	}
	return (k);
}

static int
newcand(int x, int y, int pred)
{
	struct cand *q, *tmp;
	int newclistlen;

	if (clen == clistlen) {
		newclistlen = clistlen * 11 / 10;
		tmp = xrealloc(clist, newclistlen, sizeof(*clist));
		clist = tmp;
		clistlen = newclistlen;
	}
	q = clist + clen;
	q->x = x;
	q->y = y;
	q->pred = pred;
	return (clen++);
}

static int
search(int *c, int k, int y)
{
	int i, j, l, t;

	if (clist[c[k]].y < y)	/* quick look for typical case */
		return (k + 1);
	i = 0;
	j = k + 1;
	for (;;) {
		l = (i + j) / 2;
		if (l <= i)
			break;
		t = clist[c[l]].y;
		if (t > y)
			j = l;
		else if (t < y)
			i = l;
		else
			return (l);
	}
	return (l + 1);
}

static void
unravel(int p)
{
	struct cand *q;
	int i;

	for (i = 0; i <= diff_len[0]; i++)
		J[i] = i <= pref ? i :
		    i > diff_len[0] - suff ? i + diff_len[1] - diff_len[0] : 0;
	for (q = clist + p; q->y != 0; q = clist + q->pred)
		J[q->x + pref] = q->y + pref;
}

/*
 * Check does double duty:
 *  1.	ferret out any fortuitous correspondences due
 *	to confounding by hashing (which result in "jackpot")
 *  2.  collect random access indexes to the two files
 */
static void
check(FILE *f1, FILE *f2)
{
	int i, j, jackpot, c, d;
	long ctold, ctnew;

	rewind(f1);
	rewind(f2);
	j = 1;
	ixold[0] = ixnew[0] = 0;
	jackpot = 0;
	ctold = ctnew = 0;
	for (i = 1; i <= diff_len[0]; i++) {
		if (J[i] == 0) {
			ixold[i] = ctold += skipline(f1);
			continue;
		}
		while (j < J[i]) {
			ixnew[j] = ctnew += skipline(f2);
			j++;
		}
		if (bflag == 1 || wflag == 1 || iflag == 1) {
			for (;;) {
				c = getc(f1);
				d = getc(f2);
				/*
				 * GNU diff ignores a missing newline
				 * in one file if bflag || wflag.
				 */
				if ((bflag == 1 || wflag == 1) &&
				    ((c == EOF && d == '\n') ||
				    (c == '\n' && d == EOF))) {
					break;
				}
				ctold++;
				ctnew++;
				if (bflag == 1 && isspace(c) && isspace(d)) {
					do {
						if (c == '\n')
							break;
						ctold++;
					} while (isspace(c = getc(f1)));
					do {
						if (d == '\n')
							break;
						ctnew++;
					} while (isspace(d = getc(f2)));
				} else if (wflag == 1) {
					while (isspace(c) && c != '\n') {
						c = getc(f1);
						ctold++;
					}
					while (isspace(d) && d != '\n') {
						d = getc(f2);
						ctnew++;
					}
				}
				if (chrtran[c] != chrtran[d]) {
					jackpot++;
					J[i] = 0;
					if (c != '\n' && c != EOF)
						ctold += skipline(f1);
					if (d != '\n' && c != EOF)
						ctnew += skipline(f2);
					break;
				}
				if (c == '\n' || c == EOF)
					break;
			}
		} else {
			for (;;) {
				ctold++;
				ctnew++;
				if ((c = getc(f1)) != (d = getc(f2))) {
					/* jackpot++; */
					J[i] = 0;
					if (c != '\n' && c != EOF)
						ctold += skipline(f1);
					if (d != '\n' && c != EOF)
						ctnew += skipline(f2);
					break;
				}
				if (c == '\n' || c == EOF)
					break;
			}
		}
		ixold[i] = ctold;
		ixnew[j] = ctnew;
		j++;
	}
	for (; j <= diff_len[1]; j++)
		ixnew[j] = ctnew += skipline(f2);
	/*
	 * if (jackpot != 0)
	 *	cvs_printf("jackpot\n");
	 */
}

/* shellsort CACM #201 */
static void
sort(struct line *a, int n)
{
	struct line *ai, *aim, w;
	int j, m = 0, k;

	if (n == 0)
a112 21
	for (j = 1; j <= n; j *= 2)
		m = 2 * j - 1;
	for (m /= 2; m != 0; m /= 2) {
		k = n - m;
		for (j = 1; j <= k; j++) {
			for (ai = &a[j]; ai > a; ai -= m) {
				aim = &ai[m];
				if (aim < ai)
					break;	/* wraparound */
				if (aim->value > ai[0].value ||
				    (aim->value == ai[0].value &&
					aim->serial > ai[0].serial))
					break;
				w.value = ai[0].value;
				ai[0].value = aim->value;
				aim->value = w.value;
				w.serial = ai[0].serial;
				ai[0].serial = aim->serial;
				aim->serial = w.serial;
			}
		}
a113 1
}
d115 1
a115 4
static void
unsort(struct line *f, int l, int *b)
{
	int *a, i;
d117 2
a118 118
	a = xcalloc(l + 1, sizeof(*a));
	for (i = 1; i <= l; i++)
		a[f[i].serial] = f[i].value;
	for (i = 1; i <= l; i++)
		b[i] = a[i];
	xfree(a);
}

static int
skipline(FILE *f)
{
	int i, c;

	for (i = 1; (c = getc(f)) != '\n' && c != EOF; i++)
		continue;
	return (i);
}

static void
output(FILE *f1, FILE *f2)
{
	int m, i0, i1, j0, j1;

	rewind(f1);
	rewind(f2);
	m = diff_len[0];
	J[0] = 0;
	J[m + 1] = diff_len[1] + 1;
	for (i0 = 1; i0 <= m; i0 = i1 + 1) {
		while (i0 <= m && J[i0] == J[i0 - 1] + 1)
			i0++;
		j0 = J[i0 - 1] + 1;
		i1 = i0 - 1;
		while (i1 < m && J[i1 + 1] == 0)
			i1++;
		j1 = J[i1 + 1] - 1;
		J[i1] = j1;
		change(f1, f2, i0, i1, j0, j1);
	}
	if (m == 0)
		change(f1, f2, 1, 0, 1, diff_len[1]);
	if (diff_format == D_IFDEF) {
		for (;;) {
#define	c i0
			if ((c = getc(f1)) == EOF)
				return;
			diff_output("%c", c);
		}
#undef c
	}
	if (anychange != 0) {
		if (diff_format == D_CONTEXT)
			dump_context_vec(f1, f2);
		else if (diff_format == D_UNIFIED)
			dump_unified_vec(f1, f2);
	}
}

static __inline void
range(int a, int b, char *separator)
{
	diff_output("%d", a > b ? b : a);
	if (a < b)
		diff_output("%s%d", separator, b);
}

static __inline void
uni_range(int a, int b)
{
	if (a < b)
		diff_output("%d,%d", a, b - a + 1);
	else if (a == b)
		diff_output("%d", b);
	else
		diff_output("%d,0", b);
}

static char *
preadline(int fd, size_t rlen, off_t off)
{
	char *line;
	ssize_t nr;

	line = xmalloc(rlen + 1);
	if ((nr = pread(fd, line, rlen, off)) < 0) {
		cvs_log(LP_ERRNO, "preadline failed");
		return (NULL);
	}
	line[nr] = '\0';
	return (line);
}

static int
ignoreline(char *line)
{
	int ret;

	ret = regexec(&ignore_re, line, (size_t)0, NULL, 0);
	xfree(line);
	return (ret == 0);	/* if it matched, it should be ignored. */
}

/*
 * Indicate that there is a difference between lines a and b of the from file
 * to get to lines c to d of the to file.  If a is greater then b then there
 * are no lines in the from file involved and this means that there were
 * lines appended (beginning at b).  If c is greater than d then there are
 * lines missing from the to file.
 */
static void
change(FILE *f1, FILE *f2, int a, int b, int c, int d)
{
	int i;
	static size_t max_context = 64;
	char buf[64];
	struct tm *t;

	if (diff_format != D_IFDEF && a > b && c > d)
d120 2
a121 23
	if (ignore_pats != NULL) {
		char *line;
		/*
		 * All lines in the change, insert, or delete must
		 * match an ignore pattern for the change to be
		 * ignored.
		 */
		if (a <= b) {		/* Changes and deletes. */
			for (i = a; i <= b; i++) {
				line = preadline(fileno(f1),
				    ixold[i] - ixold[i - 1], ixold[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		if (a > b || c <= d) {	/* Changes and inserts. */
			for (i = c; i <= d; i++) {
				line = preadline(fileno(f2),
				    ixnew[i] - ixnew[i - 1], ixnew[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
d123 1
a123 66
	}
proceed:
	if (diff_format == D_CONTEXT || diff_format == D_UNIFIED) {
		/*
		 * Allocate change records as needed.
		 */
		if (context_vec_ptr == context_vec_end - 1) {
			struct context_vec *tmp;
			ptrdiff_t offset = context_vec_ptr - context_vec_start;
			max_context <<= 1;
			tmp = xrealloc(context_vec_start, max_context,
			    sizeof(*context_vec_start));
			context_vec_start = tmp;
			context_vec_end = context_vec_start + max_context;
			context_vec_ptr = context_vec_start + offset;
		}
		if (anychange == 0) {
			/*
			 * Print the context/unidiff header first time through.
			 */
			t = localtime(&stb1.st_mtime); 
			(void)strftime(buf, sizeof(buf),
			    "%Y/%m/%d %H:%M:%S", t);

			diff_output("%s %s	%s",
			    diff_format == D_CONTEXT ? "***" : "---", diff_file,
			    buf);

			if (diff_rev1 != NULL) {
				rcsnum_tostr(diff_rev1, buf, sizeof(buf));
				diff_output("\t%s", buf);
			}

			printf("\n");

			t = localtime(&stb2.st_mtime);
			(void)strftime(buf, sizeof(buf),
			    "%Y/%m/%d %H:%M:%S", t);

			diff_output("%s %s	%s",
			    diff_format == D_CONTEXT ? "---" : "+++", diff_file,
			    buf);

			if (diff_rev2 != NULL) {
				rcsnum_tostr(diff_rev2, buf, sizeof(buf));
				diff_output("\t%s", buf);
			}

			printf("\n");
			anychange = 1;
		} else if (a > context_vec_ptr->b + (2 * context) + 1 &&
		    c > context_vec_ptr->d + (2 * context) + 1) {
			/*
			 * If this change is more than 'context' lines from the
			 * previous change, dump the record and reset it.
			 */
			if (diff_format == D_CONTEXT)
				dump_context_vec(f1, f2);
			else
				dump_unified_vec(f1, f2);
		}
		context_vec_ptr++;
		context_vec_ptr->a = a;
		context_vec_ptr->b = b;
		context_vec_ptr->c = c;
		context_vec_ptr->d = d;
a124 35
	}
	if (anychange == 0)
		anychange = 1;
	switch (diff_format) {
	case D_BRIEF:
		return;
	case D_NORMAL:
		range(a, b, ",");
		diff_output("%c", a > b ? 'a' : c > d ? 'd' : 'c');
		if (diff_format == D_NORMAL)
			range(c, d, ",");
		diff_output("\n");
		break;
	case D_RCSDIFF:
		if (a > b)
			diff_output("a%d %d\n", b, d - c + 1);
		else {
			diff_output("d%d %d\n", a, b - a + 1);

			if (!(c > d))	/* add changed lines */
				diff_output("a%d %d\n", b, d - c + 1);
		}
		break;
	}
	if (diff_format == D_NORMAL || diff_format == D_IFDEF) {
		fetch(ixold, a, b, f1, '<', 1);
		if (a <= b && c <= d && diff_format == D_NORMAL)
			diff_output("---\n");
	}
	fetch(ixnew, c, d, f2, diff_format == D_NORMAL ? '>' : '\0', 0);
	if (inifdef) {
		diff_output("#endif /* %s */\n", ifdefname);
		inifdef = 0;
	}
}
d126 3
a128 5
static void
fetch(long *f, int a, int b, FILE *lb, int ch, int oldfile)
{
	long j, nc;
	int i, c, col;
d130 4
a133 68
	/*
	 * When doing #ifdef's, copy down to current line
	 * if this is the first file, so that stuff makes it to output.
	 */
	if (diff_format == D_IFDEF && oldfile) {
		long curpos = ftell(lb);
		/* print through if append (a>b), else to (nb: 0 vs 1 orig) */
		nc = f[a > b ? b : a - 1] - curpos;
		for (i = 0; i < nc; i++)
			diff_output("%c", getc(lb));
	}
	if (a > b)
		return;
	if (diff_format == D_IFDEF) {
		if (inifdef) {
			diff_output("#else /* %s%s */\n",
			    oldfile == 1 ? "!" : "", ifdefname);
		} else {
			if (oldfile)
				diff_output("#ifndef %s\n", ifdefname);
			else
				diff_output("#ifdef %s\n", ifdefname);
		}
		inifdef = 1 + oldfile;
	}
	for (i = a; i <= b; i++) {
		fseek(lb, f[i - 1], SEEK_SET);
		nc = f[i] - f[i - 1];
		if (diff_format != D_IFDEF && ch != '\0') {
			diff_output("%c", ch);
			if (Tflag == 1 && (diff_format == D_NORMAL ||
			    diff_format == D_CONTEXT ||
			    diff_format == D_UNIFIED))
				diff_output("\t");
			else if (diff_format != D_UNIFIED)
				diff_output(" ");
		}
		col = 0;
		for (j = 0; j < nc; j++) {
			if ((c = getc(lb)) == EOF) {
				if (diff_format == D_RCSDIFF)
					cvs_log(LP_WARN,
					    "No newline at end of file");
				else
					diff_output("\n\\ No newline at end of "
					    "file");
				return;
			}
			if (c == '\t' && tflag == 1) {
				do {
					diff_output(" ");
				} while (++col & 7);
			} else {
				diff_output("%c", c);
				col++;
			}
		}
	}
}

/*
 * Hash function taken from Robert Sedgewick, Algorithms in C, 3d ed., p 578.
 */
static int
readhash(FILE *f)
{
	int i, t, space;
	int sum;
d135 19
a153 21
	sum = 1;
	space = 0;
	if (bflag != 1 && wflag != 1) {
		if (iflag == 1)
			for (i = 0; (t = getc(f)) != '\n'; i++) {
				if (t == EOF) {
					if (i == 0)
						return (0);
					break;
				}
				sum = sum * 127 + chrtran[t];
			}
		else
			for (i = 0; (t = getc(f)) != '\n'; i++) {
				if (t == EOF) {
					if (i == 0)
						return (0);
					break;
				}
				sum = sum * 127 + t;
			}
d155 8
a162 30
		for (i = 0;;) {
			switch (t = getc(f)) {
			case '\t':
			case ' ':
				space++;
				continue;
			default:
				if (space != 0 && wflag != 1) {
					i++;
					space = 0;
				}
				sum = sum * 127 + chrtran[t];
				i++;
				continue;
			case EOF:
				if (i == 0)
					return (0);
				/* FALLTHROUGH */
			case '\n':
				break;
			}
			break;
		}
	}
	/*
	 * There is a remote possibility that we end up with a zero sum.
	 * Zero is used as an EOF marker, so return 1 instead.
	 */
	return (sum == 0 ? 1 : sum);
}
d164 3
a166 45
static int
asciifile(FILE *f)
{
	char buf[BUFSIZ];
	size_t i, cnt;

	if (aflag == 1 || f == NULL)
		return (1);

	rewind(f);
	cnt = fread(buf, (size_t)1, sizeof(buf), f);
	for (i = 0; i < cnt; i++)
		if (!isprint(buf[i]) && !isspace(buf[i]))
			return (0);
	return (1);
}

static char*
match_function(const long *f, int pos, FILE *fp)
{
	unsigned char buf[FUNCTION_CONTEXT_SIZE];
	size_t nc;
	int last = lastline;
	char *p;

	lastline = pos;
	while (pos > last) {
		fseek(fp, f[pos - 1], SEEK_SET);
		nc = f[pos] - f[pos - 1];
		if (nc >= sizeof(buf))
			nc = sizeof(buf) - 1;
		nc = fread(buf, (size_t)1, nc, fp);
		if (nc > 0) {
			buf[nc] = '\0';
			p = strchr((const char *)buf, '\n');
			if (p != NULL)
				*p = '\0';
			if (isalpha(buf[0]) || buf[0] == '_' || buf[0] == '$') {
				strlcpy(lastbuf, (const char *)buf,
				    sizeof lastbuf);
				lastmatchline = pos;
				return lastbuf;
			}
		}
		pos--;
a167 2
	return (lastmatchline > 0) ? lastbuf : NULL;
}
d169 1
d171 2
a172 11
/* dump accumulated "context" diff changes */
static void
dump_context_vec(FILE *f1, FILE *f2)
{
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd, do_output;
	int a, b, c, d;
	char ch, *f;

	if (context_vec_start > context_vec_ptr)
		return;
d174 3
a176 89
	b = d = 0;		/* gcc */
	lowa = MAX(1, cvp->a - context);
	upb = MIN(diff_len[0], context_vec_ptr->b + context);
	lowc = MAX(1, cvp->c - context);
	upd = MIN(diff_len[1], context_vec_ptr->d + context);

	diff_output("***************");
	if (pflag == 1) {
		f = match_function(ixold, lowa - 1, f1);
		if (f != NULL) {
			diff_output(" ");
			diff_output("%s", f);
		}
	}
	diff_output("\n*** ");
	range(lowa, upb, ",");
	diff_output(" ****\n");

	/*
	 * Output changes to the "old" file.  The first loop suppresses
	 * output if there were no changes to the "old" file (we'll see
	 * the "old" lines as context in the "new" list).
	 */
	do_output = 0;
	for (; cvp <= context_vec_ptr; cvp++)
		if (cvp->a <= cvp->b) {
			cvp = context_vec_start;
			do_output++;
			break;
		}
	if (do_output != 0) {
		while (cvp <= context_vec_ptr) {
			a = cvp->a;
			b = cvp->b;
			c = cvp->c;
			d = cvp->d;

			if (a <= b && c <= d)
				ch = 'c';
			else
				ch = (a <= b) ? 'd' : 'a';

			if (ch == 'a')
				fetch(ixold, lowa, b, f1, ' ', 0);
			else {
				fetch(ixold, lowa, a - 1, f1, ' ', 0);
				fetch(ixold, a, b, f1,
				    ch == 'c' ? '!' : '-', 0);
			}
			lowa = b + 1;
			cvp++;
		}
		fetch(ixold, b + 1, upb, f1, ' ', 0);
	}
	/* output changes to the "new" file */
	diff_output("--- ");
	range(lowc, upd, ",");
	diff_output(" ----\n");

	do_output = 0;
	for (cvp = context_vec_start; cvp <= context_vec_ptr; cvp++)
		if (cvp->c <= cvp->d) {
			cvp = context_vec_start;
			do_output++;
			break;
		}
	if (do_output != 0) {
		while (cvp <= context_vec_ptr) {
			a = cvp->a;
			b = cvp->b;
			c = cvp->c;
			d = cvp->d;

			if (a <= b && c <= d)
				ch = 'c';
			else
				ch = (a <= b) ? 'd' : 'a';

			if (ch == 'd')
				fetch(ixnew, lowc, d, f2, ' ', 0);
			else {
				fetch(ixnew, lowc, c - 1, f2, ' ', 0);
				fetch(ixnew, c, d, f2,
				    ch == 'c' ? '!' : '+', 0);
			}
			lowc = d + 1;
			cvp++;
		}
		fetch(ixnew, d + 1, upd, f2, ' ', 0);
a177 2
	context_vec_ptr = context_vec_start - 1;
}
d179 1
a179 8
/* dump accumulated "unified" diff changes */
static void
dump_unified_vec(FILE *f1, FILE *f2)
{
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd;
	int a, b, c, d;
	char ch, *f;
d181 3
a183 2
	if (context_vec_start > context_vec_ptr)
		return;
d185 3
a187 19
	b = d = 0;		/* gcc */
	lowa = MAX(1, cvp->a - context);
	upb = MIN(diff_len[0], context_vec_ptr->b + context);
	lowc = MAX(1, cvp->c - context);
	upd = MIN(diff_len[1], context_vec_ptr->d + context);

	diff_output("@@@@ -");
	uni_range(lowa, upb);
	diff_output(" +");
	uni_range(lowc, upd);
	diff_output(" @@@@");
	if (pflag == 1) {
		f = match_function(ixold, lowa - 1, f1);
		if (f != NULL) {
			diff_output(" ");
			diff_output("%s", f);
		}
	}
	diff_output("\n");
d189 2
a190 19
	/*
	 * Output changes in "unified" diff format--the old and new lines
	 * are printed together.
	 */
	for (; cvp <= context_vec_ptr; cvp++) {
		a = cvp->a;
		b = cvp->b;
		c = cvp->c;
		d = cvp->d;

		/*
		 * c: both new and old changes
		 * d: only changes in the old file
		 * a: only changes in the new file
		 */
		if (a <= b && c <= d)
			ch = 'c';
		else
			ch = (a <= b) ? 'd' : 'a';
d192 7
a198 19
		switch (ch) {
		case 'c':
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
			fetch(ixnew, c, d, f2, '+', 0);
			break;
		case 'd':
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
			break;
		case 'a':
			fetch(ixnew, lowc, c - 1, f2, ' ', 0);
			fetch(ixnew, c, d, f2, '+', 0);
			break;
		}
		lowa = b + 1;
		lowc = d + 1;
	}
	fetch(ixnew, d + 1, upd, f2, ' ', 0);
d200 2
a201 2
	context_vec_ptr = context_vec_start - 1;
}
d203 2
a204 17
void
diff_output(const char *fmt, ...)
{
	va_list vap;
	int i;
	char *str;

	va_start(vap, fmt);
	i = vasprintf(&str, fmt, vap);
	va_end(vap);
	if (i == -1)
		fatal("diff_output: %s", strerror(errno));
	if (diffbuf != NULL)
		cvs_buf_append(diffbuf, str, strlen(str));
	else
		cvs_printf("%s", str);
	xfree(str);
@


1.89
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.88 2006/04/13 16:55:09 ray Exp $	*/
d211 2
d1254 1
d1256 2
a1257 1
	int i;
d1305 4
d1311 13
a1323 1
			    ctime(&stb1.st_mtime));
d1326 8
a1333 1
			    ctime(&stb2.st_mtime));
@


1.88
log
@Add error checking for vasprintf.  Stylistic suggestions from xsa@@.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.87 2006/04/05 01:38:55 ray Exp $	*/
d389 1
a389 1
			if ((dap->rev1 == NULL) && (dap->date1 == NULL)) {
d391 2
a392 2
			} else if ((dap->rev2 == NULL) &&
			    (dap->date2 == NULL)) {
d484 1
a484 1
			if ((cfp->cf_parent == NULL) ||
d708 2
a709 2
	if ((prepare(0, f1, stb1.st_size) < 0) ||
	    (prepare(1, f2, stb2.st_size) < 0)) {
d782 1
a782 1
		if ((i == 0) && (j == 0)) {
d886 1
a886 1
	} while ((x - y) > 1 || (x - y) < -1);
d1025 1
a1025 1
		if ((bflag == 1)|| (wflag == 1) || (iflag == 1)) {
d1033 1
a1033 1
				if (((bflag == 1) || (wflag == 1)) &&
d1040 1
a1040 1
				if ((bflag == 1) && isspace(c) && isspace(d)) {
d1064 1
a1064 1
					if ((c != '\n') && (c != EOF))
d1066 1
a1066 1
					if ((d != '\n') && (c != EOF))
d1070 1
a1070 1
				if ((c == '\n') || (c == EOF))
d1080 1
a1080 1
					if ((c != '\n') && (c != EOF))
d1082 1
a1082 1
					if ((d != '\n') && (c != EOF))
d1086 1
a1086 1
				if ((c == '\n') || (c == EOF))
d1272 1
a1272 1
		if ((a > b) || (c <= d)) {	/* Changes and inserts. */
d1397 1
a1397 1
			if ((Tflag == 1 ) && (diff_format == D_NORMAL ||
d1415 1
a1415 1
			if ((c == '\t') && (tflag == 1)) {
d1438 1
a1438 1
	if ((bflag != 1) && (wflag != 1)) {
d1465 1
a1465 1
				if ((space != 0) && (wflag != 1)) {
d1495 1
a1495 1
	if ((aflag == 1) || (f == NULL))
@


1.87
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.86 2006/04/01 20:11:25 joris Exp $	*/
d1723 1
d1727 4
a1730 1
	vasprintf(&str, fmt, vap);
a1735 1
	va_end(vap);
@


1.86
log
@fix some bugs that lint discovered for us.
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.85 2006/03/28 07:17:16 ray Exp $	*/
d347 1
a347 1
	dap = (struct diff_arg *)xmalloc(sizeof(*dap));
d718 2
a719 2
	tmp = xrealloc(member, slen[1] + 2, sizeof(int));
	member = (int *)tmp;
d723 2
a724 2
	tmp = xrealloc(class, slen[0] + 2, sizeof(int));
	class = (int *)tmp;
d726 1
a726 1
	klist = xcalloc(slen[0] + 2, sizeof(int));
d729 1
a729 1
	clist = xcalloc(clistlen, sizeof(cand));
d737 2
a738 2
	tmp = xrealloc(J, diff_len[0] + 2, sizeof(int));
	J = (int *)tmp;
d743 2
a744 2
	tmp = xrealloc(ixold, diff_len[0] + 2, sizeof(long));
	ixold = (long *)tmp;
d746 2
a747 2
	tmp = xrealloc(ixnew, diff_len[1] + 2, sizeof(long));
	ixnew = (long *)tmp;
d806 1
a806 1
	p = (struct line *)xcalloc(sz + 3, sizeof(struct line));
d810 2
a811 2
			tmp = xrealloc(p, sz + 3, sizeof(struct line));
			p = (struct line *)tmp;
d950 1
a950 1
		tmp = xrealloc(clist, newclistlen, sizeof(cand));
d1140 1
a1140 1
	a = (int *)xcalloc(l + 1, sizeof(int));
d1292 1
a1292 1
			    sizeof(struct context_vec));
@


1.85
log
@xmalloc(num * size) -> xcalloc(num, size)
asprintf -> xasprintf
Remove asprintf check, which was non-portable anyway.

``okidoki'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.83 2006/03/25 21:29:59 ray Exp $	*/
d136 2
@


1.84
log
@Today is Integer Overflow Prevention Day:
 - Sync xmalloc.? with ssh versions.
 - Change all xrealloc() calls to new API.

``I really like this.'' niallo@@
@
text
@d724 1
a724 1
	klist = xmalloc((slen[0] + 2) * sizeof(int));
d727 1
a727 1
	clist = xmalloc(clistlen * sizeof(cand));
d804 1
a804 1
	p = (struct line *)xmalloc((sz + 3) * sizeof(struct line));
d1138 1
a1138 1
	a = (int *)xmalloc((l + 1) * sizeof(int));
@


1.83
log
@Correct integer types, remove unused arguments, non-portable bitshifts
changed to division, KNF, replace unreachable code with goto fail,
et cetera.  Found by lint.

The free() -> xfree() as well.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.82 2006/03/24 13:34:27 ray Exp $	*/
d716 1
a716 1
	tmp = xrealloc(member, (slen[1] + 2) * sizeof(int));
d721 1
a721 1
	tmp = xrealloc(class, (slen[0] + 2) * sizeof(int));
d735 1
a735 1
	tmp = xrealloc(J, (diff_len[0] + 2) * sizeof(int));
d741 1
a741 1
	tmp = xrealloc(ixold, (diff_len[0] + 2) * sizeof(long));
d744 1
a744 1
	tmp = xrealloc(ixnew, (diff_len[1] + 2) * sizeof(long));
d808 1
a808 1
			tmp = xrealloc(p, (sz + 3) * sizeof(struct line));
d948 1
a948 1
		tmp = xrealloc(clist, newclistlen * sizeof(cand));
d1289 1
a1289 1
			tmp = xrealloc(context_vec_start, max_context *
@


1.82
log
@Remove unused variables, better integer types, prevent fallthroughs.
Found by lint.

Compare char * variables against NULL for consistency and add
parentheses around complicated comparisons, suggested by xsa@@.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.81 2006/03/23 13:09:09 xsa Exp $	*/
d175 1
a175 1
static void	 output(const char *, FILE *, const char *, FILE *);
d186 1
a186 2
static void	 change(const char *, FILE *, const char *, FILE *, int,
		    int, int, int);
d747 1
a747 1
	output(file1, f1, file2, f2);
d968 3
a970 3
	while (1) {
		l = i + j;
		if ((l >>= 1) <= i)
d1157 1
a1157 1
output(const char *file1, FILE *f1, const char *file2, FILE *f2)
d1175 1
a1175 1
		change(file1, f1, file2, f2, i0, i1, j0, j1);
d1178 1
a1178 1
		change(file1, f1, file2, f2, 1, 0, 1, diff_len[1]);
d1248 1
a1248 2
change(const char *file1, FILE *f1, const char *file2, FILE *f2,
	int a, int b, int c, int d)
@


1.81
log
@fetch() will never return non-zero; change its return type to void.
OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.80 2006/02/26 18:35:08 niallo Exp $	*/
a339 1
static int recurse;
a368 1
			recurse = 0;
d473 1
a473 2
	char *dir, *repo;
	char fpath[MAXPATHLEN], dfpath[MAXPATHLEN];
d503 1
a503 2
	if (cfp->cf_parent != NULL) {
		dir = cvs_file_getpath(cfp->cf_parent, dfpath, sizeof(dfpath));
d505 1
a505 3
		repo = cfp->cf_parent->cf_repo;
	} else {
		dir = ".";
a506 2
		repo = NULL;
	}
d530 1
a530 1
	char *repo, buf[64];
a535 1
	struct cvsroot *root;
a541 2
	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);
d1364 2
a1365 1
	int i, j, c, lastc, col, nc;
d1405 1
a1405 1
		for (j = 0, lastc = '\0'; j < nc; j++, lastc = c) {
d1493 1
a1493 1
	int i, cnt;
@


1.80
log
@remove unnecessary newline characters in cvs_log() calls.

From: Ray Lai <ray@@cyth.net> in PR#5038
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.79 2006/01/30 17:58:47 xsa Exp $	*/
d191 1
a191 1
static int	 fetch(long *, int, int, FILE *, int, int);
d1365 1
a1365 1
	i = fetch(ixnew, c, d, f2, diff_format == D_NORMAL ? '>' : '\0', 0);
d1372 1
a1372 1
static int
d1389 1
a1389 1
		return (0);
d1423 1
a1423 1
				return (0);
a1434 1
	return (0);
@


1.79
log
@strerror() -> rcs_errstr() when passing rcs_errno as argument;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.78 2006/01/27 15:26:38 xsa Exp $	*/
d594 1
a594 1
		cvs_log(LP_ERR, "failed to retrieve revision %s\n",
d620 1
a620 1
			cvs_log(LP_ERR, "failed to retrieve revision %s\n",
d633 1
a633 1
		cvs_log(LP_ERR, "failed to retrieve revision %s\n",
@


1.78
log
@more errors handling cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.77 2006/01/25 11:13:18 xsa Exp $	*/
d577 1
a577 1
		    strerror(rcs_errno));
@


1.77
log
@use cvs_rcs_getpath() instead of duplicating code.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.76 2006/01/02 17:06:10 xsa Exp $	*/
d575 3
a577 4
	rf = rcs_open(rcspath, RCS_READ);
	if (rf == NULL) {
		return (CVS_EX_DATA);
	}
d585 2
a586 4
		if ((r1 = rcsnum_parse(dap->rev1)) == NULL) {
			rcs_close(rf);
			return (CVS_EX_DATA);
		}
@


1.76
log
@- nuke remaining err(), errx() and warnx() instances.
- make cvs_log_init() return type void.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.75 2006/01/02 08:11:56 xsa Exp $	*/
a537 1
	int len;
d573 1
a573 7
	len = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, diff_file, RCS_FILE_EXT);
	if (len == -1 || len >= (int)sizeof(rcspath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rcspath);
		return (CVS_EX_DATA);
	}
@


1.75
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.74 2005/12/30 02:03:28 joris Exp $	*/
d1428 2
a1429 1
					warnx("No newline at end of file");
@


1.74
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.73 2005/12/21 09:09:02 xsa Exp $	*/
d129 1
a129 14
#include <sys/stat.h>

#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <regex.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.73
log
@cvs_buf_write_stmp() cannot fail anymore, missed it in previous commit;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.72 2005/12/20 18:17:00 xsa Exp $	*/
d450 9
a458 12
		if ((Nflag == 1) && (cvs_sendarg(root, "-N", 0) < 0))
			return (CVS_EX_PROTO);
		if ((pflag ==1) && (cvs_sendarg(root, "-p", 0) < 0))
			return (CVS_EX_PROTO);

		if (diff_format == D_CONTEXT) {
			if (cvs_sendarg(root, "-c", 0) < 0)
				return (CVS_EX_PROTO);
		} else if (diff_format == D_UNIFIED) {
			if (cvs_sendarg(root, "-u", 0) < 0)
				return (CVS_EX_PROTO);
		}
d461 2
a462 3
			if ((cvs_sendarg(root, "-r", 0) < 0) ||
			    (cvs_sendarg(root, dap->rev1, 0) < 0))
				return (CVS_EX_PROTO);
d464 2
a465 3
			if ((cvs_sendarg(root, "-D", 0) < 0) ||
			    (cvs_sendarg(root, dap->date1, 0) < 0))
				return (CVS_EX_PROTO);
d468 2
a469 3
			if ((cvs_sendarg(root, "-r", 0) < 0) ||
			    (cvs_sendarg(root, dap->rev2, 0) < 0))
				return (CVS_EX_PROTO);
d471 2
a472 3
			if ((cvs_sendarg(root, "-D", 0) < 0) ||
			    (cvs_sendarg(root, dap->date2, 0) < 0))
				return  (CVS_EX_PROTO);
d534 1
a534 2
	if (cvs_sendentry(root, cfp) < 0)
		return (CVS_EX_PROTO);
d542 2
a543 3
	if ((cvs_sendreq(root, CVS_REQ_MODIFIED, cfp->cf_name) < 0) ||
	    (cvs_sendfile(root, diff_file) < 0))
		return (CVS_EX_PROTO);
@


1.72
log
@cvs_buf_putc() and cvs_buf_write_*() functions cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.71 2005/12/10 20:27:45 joris Exp $	*/
d685 1
a685 5
	if (cvs_buf_write_stmp(b2, path_tmp2, 0600) == -1) {
		cvs_buf_free(b2);
		(void)unlink(path_tmp1);
		return (CVS_EX_DATA);
	}
@


1.71
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.70 2005/12/05 19:53:00 niallo Exp $	*/
d678 1
a678 5
	if (cvs_buf_write_stmp(b1, path_tmp1, 0600) == -1) {
		cvs_buf_free(b1);
		cvs_buf_free(b2);
		return (CVS_EX_DATA);
	}
@


1.70
log
@- repair cvs diff. my date fix was too naive.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.69 2005/12/01 23:02:27 niallo Exp $	*/
d360 1
a360 3
	dap = (struct diff_arg *)malloc(sizeof(*dap));
	if (dap == NULL)
		return (CVS_EX_DATA);
d435 1
a435 1
		free(dap);
d768 1
a768 6
	if ((tmp = realloc(member, (slen[1] + 2) * sizeof(int))) == NULL) {
		free(member);
		member = NULL;
		cvs_log(LP_ERRNO, "failed to resize member");
		goto closem;
	}
d773 1
a773 6
	if ((tmp = realloc(class, (slen[0] + 2) * sizeof(int))) == NULL) {
		free(class);
		class = NULL;
		cvs_log(LP_ERRNO, "failed to resize class");
		goto closem;
	}
d776 1
a776 4
	if ((klist = malloc((slen[0] + 2) * sizeof(int))) == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate klist");
		goto closem;
	}
d779 1
a779 4
	if ((clist = malloc(clistlen * sizeof(cand))) == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate clist");
		goto closem;
	}
d784 2
a785 2
	free(member);
	free(class);
d787 1
a787 6
	if ((tmp = realloc(J, (diff_len[0] + 2) * sizeof(int))) == NULL) {
		free(J);
		J = NULL;
		cvs_log(LP_ERRNO, "failed to resize J");
		goto closem;
	}
d790 2
a791 2
	free(clist);
	free(klist);
d793 1
a793 6
	if ((tmp = realloc(ixold, (diff_len[0] + 2) * sizeof(long))) == NULL) {
		free(ixold);
		ixold = NULL;
		cvs_log(LP_ERRNO, "failed to resize ixold");
		goto closem;
	}
d795 2
a796 6
	if ((tmp = realloc(ixnew, (diff_len[1] + 2) * sizeof(long))) == NULL) {
		free(ixnew);
		ixnew = NULL;
		cvs_log(LP_ERRNO, "failed to resize ixnew");
		goto closem;
	}
d856 1
a856 5
	p = (struct line *)malloc((sz + 3) * sizeof(struct line));
	if (p == NULL) {
		cvs_log(LP_ERRNO, "failed to prepare line array");
		return (-1);
	}
d860 1
a860 6
			tmp = realloc(p, (sz + 3) * sizeof(struct line));
			if (tmp == NULL) {
				cvs_log(LP_ERRNO, "failed to grow line array");
				free(p);
				return (-1);
			}
d1000 1
a1000 5
		tmp = realloc(clist, newclistlen * sizeof(cand));
		if (tmp == NULL) {
			cvs_log(LP_ERRNO, "failed to resize clist");
			return (-1);
		}
d1190 1
a1190 4
	if ((a = (int *)malloc((l + 1) * sizeof(int))) == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate sort array");
		return;
	}
d1195 1
a1195 1
	free(a);
d1273 1
a1273 5
	line = malloc(rlen + 1);
	if (line == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate line");
		return (NULL);
	}
d1288 1
a1288 1
	free(line);
d1342 2
a1343 8
			if ((tmp = realloc(context_vec_start, max_context *
			    sizeof(struct context_vec))) == NULL) {
				free(context_vec_start);
				context_vec_start = NULL;
				cvs_log(LP_ERRNO,
				    "failed to resize context_vec_start");
				return;
			}
d1781 1
a1781 1
	free(str);
@


1.69
log
@- fix up context and unified diff output in both open rcs and open cvs so
that the date is set correctly.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.68 2005/12/01 20:36:30 niallo Exp $	*/
d648 2
d652 7
d660 2
a671 2
	tv2[0].tv_sec = (long)rcs_rev_getdate(rf, r2);
	tv2[1].tv_sec = tv2[0].tv_sec;
@


1.68
log
@- fix unified and context diff output, finally!

this was a long standing bug, and the fix is hilarious.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.67 2005/11/24 11:23:13 xsa Exp $	*/
d570 4
d635 2
d661 2
d677 2
d688 2
d729 8
@


1.67
log
@respect TMPDIR;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.66 2005/11/21 15:01:10 xsa Exp $	*/
d220 1
a220 1
static int context;
@


1.66
log
@- print some more informative messages
- minor knf
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.65 2005/11/18 10:30:34 xsa Exp $	*/
d661 2
a662 1
	strlcpy(path_tmp1, "/tmp/diff1.XXXXXXXXXX", sizeof(path_tmp1));
d670 2
a671 1
	strlcpy(path_tmp2, "/tmp/diff2.XXXXXXXXXX", sizeof(path_tmp2));
@


1.65
log
@minor knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.64 2005/11/14 12:53:43 xsa Exp $	*/
a217 1
static char diffargs[128];
d223 1
@


1.64
log
@minor knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.63 2005/10/22 17:32:57 joris Exp $	*/
d803 1
a803 1
	if (anychange) {
d833 1
a833 1
		if (i == 0 && j == 0) {
d1128 1
a1128 1
					if (c != '\n' && c != EOF)
d1130 1
a1130 1
					if (d != '\n' && c != EOF)
d1134 1
a1134 1
				if (c == '\n' || c == EOF)
d1144 1
a1144 1
					if (c != '\n' && c != EOF)
d1146 1
a1146 1
					if (d != '\n' && c != EOF)
d1150 1
a1150 1
				if (c == '\n' || c == EOF)
d1161 1
a1161 1
	 * if (jackpot)
d1344 1
a1344 1
		if (a > b || c <= d) {	/* Changes and inserts. */
d1658 1
a1658 1
	if (do_output) {
d1694 1
a1694 1
	if (do_output) {
@


1.63
log
@diff3 support, needed for merging files together;

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.62 2005/10/11 18:01:57 joris Exp $	*/
d181 1
a181 1
static int     cvs_diff_init(struct cvs_cmd *, int, char **, int *);
d452 1
a452 1
		if (Nflag && (cvs_sendarg(root, "-N", 0) < 0))
d454 1
a454 1
		if (pflag && (cvs_sendarg(root, "-p", 0) < 0))
d1089 1
a1089 1
		if (bflag || wflag || iflag) {
d1097 1
a1097 1
				if ((bflag || wflag) &&
d1104 1
a1104 1
				if (bflag && isspace(c) && isspace(d)) {
d1115 1
a1115 1
				} else if (wflag) {
d1474 1
a1474 1
			if (Tflag && (diff_format == D_NORMAL ||
d1491 1
a1491 1
			if (c == '\t' && tflag) {
d1515 2
a1516 2
	if (!bflag && !wflag) {
		if (iflag)
d1542 1
a1542 1
				if (space && !wflag) {
d1572 1
a1572 1
	if (aflag || f == NULL)
d1635 1
a1635 1
	if (pflag) {
d1744 1
a1744 1
	if (pflag) {
@


1.62
log
@close the RCSFILE on error, so we don't leak memory;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.61 2005/10/11 14:27:27 joris Exp $	*/
a187 1
static void	 diff_output(const char *, ...);
d252 1
a252 1
static BUF  *diffbuf = NULL;
d1796 1
a1796 1
static void
@


1.61
log
@export diff_file variable so it can be set from without diff functions;
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.60 2005/10/08 20:39:49 joris Exp $	*/
d615 1
d629 1
d639 1
@


1.60
log
@add missing newline, fixes D_NORMAL diff output;
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.59 2005/10/08 00:49:18 joris Exp $	*/
d224 1
a226 1
static const char *diff_file;
@


1.59
log
@KNF;

from sir reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.58 2005/10/07 23:59:56 niallo Exp $	*/
d1428 1
a1428 1
			diff_output("---");
@


1.58
log
@basic `ci' support is here! more coming soon.

combined effort with joris.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.57 2005/10/07 21:47:32 reyk Exp $	*/
d1472 3
a1474 2
			if (Tflag && (diff_format == D_NORMAL || diff_format == D_CONTEXT
			    || diff_format == D_UNIFIED))
d1485 2
a1486 1
					diff_output("\n\\ No newline at end of file");
@


1.57
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.56 2005/10/05 23:11:06 niallo Exp $	*/
d162 1
a162 1
 * The following struct is used to record change information when
d188 1
d223 1
a223 1
static int format = D_NORMAL;
d253 2
d371 1
a371 1
			format = D_CONTEXT;
d399 1
a399 1
			format = D_RCSDIFF;
d423 1
a423 1
			format = D_UNIFIED;
d458 1
a458 1
		if (format == D_CONTEXT) {
d461 1
a461 1
		} else if (format == D_UNIFIED) {
d675 1
a675 1
	cvs_diffreg(path_tmp1, path_tmp2);
d685 1
a685 1
cvs_diffreg(const char *file1, const char *file2)
d698 2
d1246 1
a1246 1
	if (format == D_IFDEF) {
d1251 1
a1251 1
			cvs_putchar(c);
d1256 1
a1256 1
		if (format == D_CONTEXT)
d1258 1
a1258 1
		else if (format == D_UNIFIED)
d1266 1
a1266 1
	cvs_printf("%d", a > b ? b : a);
d1268 1
a1268 1
		cvs_printf("%s%d", separator, b);
d1275 1
a1275 1
		cvs_printf("%d,%d", a, b - a + 1);
d1277 1
a1277 1
		cvs_printf("%d", b);
d1279 1
a1279 1
		cvs_printf("%d,0", b);
d1325 1
a1325 1
	if (format != D_IFDEF && a > b && c > d)
d1353 1
a1353 1
	if (format == D_CONTEXT || format == D_UNIFIED) {
d1377 2
a1378 2
			cvs_printf("%s %s	%s",
			    format == D_CONTEXT ? "***" : "---", diff_file,
d1380 2
a1381 2
			cvs_printf("%s %s	%s",
			    format == D_CONTEXT ? "---" : "+++", diff_file,
d1390 1
a1390 1
			if (format == D_CONTEXT)
d1404 1
a1404 1
	switch (format) {
d1409 2
a1410 2
		cvs_putchar(a > b ? 'a' : c > d ? 'd' : 'c');
		if (format == D_NORMAL)
d1412 1
a1412 1
		cvs_putchar('\n');
d1416 1
a1416 1
			cvs_printf("a%d %d\n", b, d - c + 1);
d1418 1
a1418 1
			cvs_printf("d%d %d\n", a, b - a + 1);
d1421 1
a1421 1
				cvs_printf("a%d %d\n", b, d - c + 1);
d1425 1
a1425 1
	if (format == D_NORMAL || format == D_IFDEF) {
d1427 2
a1428 2
		if (a <= b && c <= d && format == D_NORMAL)
			puts("---");
d1430 1
a1430 1
	i = fetch(ixnew, c, d, f2, format == D_NORMAL ? '>' : '\0', 0);
d1432 1
a1432 1
		cvs_printf("#endif /* %s */\n", ifdefname);
d1446 1
a1446 1
	if (format == D_IFDEF && oldfile) {
d1451 1
a1451 1
			cvs_putchar(getc(lb));
d1455 1
a1455 1
	if (format == D_IFDEF) {
d1457 1
a1457 1
			cvs_printf("#else /* %s%s */\n",
d1461 1
a1461 1
				cvs_printf("#ifndef %s\n", ifdefname);
d1463 1
a1463 1
				cvs_printf("#ifdef %s\n", ifdefname);
d1470 7
a1476 7
		if (format != D_IFDEF && ch != '\0') {
			cvs_putchar(ch);
			if (Tflag && (format == D_NORMAL || format == D_CONTEXT
			    || format == D_UNIFIED))
				cvs_putchar('\t');
			else if (format != D_UNIFIED)
				cvs_putchar(' ');
d1481 1
a1481 1
				if (format == D_RCSDIFF)
d1484 1
a1484 1
					puts("\n\\ No newline at end of file");
d1489 1
a1489 1
					cvs_putchar(' ');
d1492 1
a1492 1
				cvs_putchar(c);
d1630 1
a1630 1
	cvs_printf("***************");
d1634 2
a1635 2
			cvs_putchar(' ');
			cvs_printf("%s", f);
d1638 1
a1638 1
	cvs_printf("\n*** ");
d1640 1
a1640 1
	cvs_printf(" ****\n");
d1679 1
a1679 1
	cvs_printf("--- ");
d1681 1
a1681 1
	cvs_printf(" ----\n");
d1735 1
a1735 1
	cvs_printf("@@@@ -");
d1737 1
a1737 1
	cvs_printf(" +");
d1739 1
a1739 1
	cvs_printf(" @@@@");
d1743 2
a1744 2
			cvs_putchar(' ');
			cvs_printf("%s", f);
d1747 1
a1747 1
	cvs_putchar('\n');
d1790 16
@


1.56
log
@- add a diff.h header file, corresponding to public functions in diff.c
  and some #defines
- include this header in rcs.c
- link rcs against diff.c

this allows us to use the existing diff work from opencvs within functions
in the rcs.c API and thus in rcs programs. paves the way for diff support
in usr.bin/rcs programs.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.55 2005/08/14 19:49:18 xsa Exp $	*/
d1356 2
a1357 2
			if ((tmp = realloc(context_vec_start,
			    max_context * sizeof(struct context_vec))) == NULL) {
d1595 2
a1596 1
				strlcpy(lastbuf, (const char *)buf, sizeof lastbuf);
@


1.55
log
@missing casts; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.54 2005/07/27 16:42:19 xsa Exp $	*/
d146 1
a149 28

#define CVS_DIFF_DEFCTX	3	/* default context length */


/*
 * Output format options
 */
#define	D_NORMAL	0	/* Normal output */
#define	D_CONTEXT	1	/* Diff with context */
#define	D_UNIFIED	2	/* Unified context diff */
#define	D_IFDEF		3	/* Diff with merged #ifdef's */
#define	D_BRIEF		4	/* Say if the files differ */
#define	D_RCSDIFF	5       /* Reverse editor output: RCS format */

/*
 * Status values for print_status() and diffreg() return values
 */
#define	D_SAME		0	/* Files are the same */
#define	D_DIFFER	1	/* Files are different */
#define	D_BINARY	2	/* Binary files are different */
#define	D_COMMON	3	/* Subdirectory common to both dirs */
#define	D_ONLY		4	/* Only exists in one directory */
#define	D_MISMATCH1	5	/* path1 was a dir, path2 a file */
#define	D_MISMATCH2	6	/* path1 was a file, path2 a dir */
#define	D_ERROR		7	/* An error occurred */
#define	D_SKIPPED1	8	/* path1 was a special file */
#define	D_SKIPPED2	9	/* path2 was a special file */

d180 2
a181 2

static int	cvs_diff_init(struct cvs_cmd *, int, char **, int *);
d186 1
a186 1
int		cvs_diffreg(const char *, const char *);
d216 5
a220 1
static int aflag, bflag, dflag, iflag, Nflag, pflag, tflag, Tflag, wflag;
d224 1
a224 1
static char *ifdefname, *ignore_pats, diffargs[128];
a251 2


d310 1
a310 1

d347 1
d349 1
d678 1
@


1.54
log
@use LP_NOTICE instead of LP_INFO where appropriate;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.53 2005/07/25 12:05:43 xsa Exp $	*/
d844 2
a845 2
		i = fread(buf1, 1, sizeof(buf1), f1);
		j = fread(buf2, 1, sizeof(buf2), f2);
d1323 1
a1323 1
	ret = regexec(&ignore_re, line, 0, NULL, 0);
d1589 1
a1589 1
	cnt = fread(buf, 1, sizeof(buf), f);
d1610 1
a1610 1
		nc = fread(buf, 1, nc, fp);
@


1.53
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.52 2005/07/22 16:27:29 joris Exp $	*/
d599 1
a599 1
			cvs_log(LP_INFO, "Diffing %s", fpath);
@


1.52
log
@use the cf_name field of the CVSFILE struct instead of using the old
CVS_FILE_NAME macro. This macro used to be nifty because of all
the referencing for the names, but since we don't do that anymore and
use cf_name directly... byebye CVS_FILE_NAME()

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.51 2005/07/21 11:42:24 xsa Exp $	*/
d150 1
a150 1
#define CVS_DIFF_DEFCTX    3   /* default context length */
d178 3
a180 3
	int x;
	int y;
	int pred;
d184 2
a185 2
	int serial;
	int value;
d194 4
a197 4
	int a;			/* start line in old file */
	int b;			/* end line in old file */
	int c;			/* start line in new file */
	int d;			/* end line in new file */
d201 4
a204 4
	char  *rev1;
	char  *rev2;
	char  *date1;
	char  *date2;
d208 33
a240 32
static int  cvs_diff_init      (struct cvs_cmd *, int, char **, int *);
static int  cvs_diff_remote    (CVSFILE *, void *);
static int  cvs_diff_local     (CVSFILE *, void *);
static int  cvs_diff_pre_exec (struct cvsroot *);
static int  cvs_diff_cleanup   (void);
int  cvs_diffreg        (const char *, const char *);

static void output(const char *, FILE *, const char *, FILE *);
static void check(FILE *, FILE *);
static void range(int, int, char *);
static void uni_range(int, int);
static void dump_context_vec(FILE *, FILE *);
static void dump_unified_vec(FILE *, FILE *);
static int  prepare(int, FILE *, off_t);
static void prune(void);
static void equiv(struct line *, int, struct line *, int, int *);
static void unravel(int);
static void unsort(struct line *, int, int *);
static void change(const char *, FILE *, const char *, FILE *, int, int, int, int);
static void sort(struct line *, int);
static int  ignoreline(char *);
static int  asciifile(FILE *);
static int  fetch(long *, int, int, FILE *, int, int);
static int  newcand(int, int, int);
static int  search(int *, int, int);
static int  skipline(FILE *);
static int  isqrt(int);
static int  stone(int *, int, int *, int *);
static int  readhash(FILE *);
static int  files_differ(FILE *, FILE *);
static char *match_function(const long *, int, FILE *);
static char *preadline(int, size_t, off_t);
@


1.51
log
@<sys/param.h> is already included in "cvs.h", no need to duplicate;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.50 2005/07/11 01:32:17 joris Exp $	*/
d524 1
a524 2
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cfp));
d542 1
a542 1
		cvs_log(LP_WARN, "cannot find file %s", CVS_FILE_NAME(cfp));
@


1.50
log
@

the status variable is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.49 2005/07/11 01:26:47 niallo Exp $	*/
a128 1
#include <sys/param.h>
@


1.49
log
@add proper handling for realloc() failure cases, avoiding bad idiom and
plugging a few potential memory leaks.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.48 2005/07/10 21:50:25 joris Exp $	*/
a793 1
		status |= 2;
a804 1
		status |= 2;
a811 1
		status |= 2;
@


1.48
log
@

- get rid of an unused variable.
- stone() and newcand() could fail, handle it.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.47 2005/07/10 13:58:19 xsa Exp $	*/
d755 4
a758 1
	if ((tmp = realloc(member, (slen[1] + 2) * sizeof(int))) == NULL)
d760 1
d765 4
a768 1
	if ((tmp = realloc(class, (slen[0] + 2) * sizeof(int))) == NULL)
d770 1
d790 8
a797 1
	J = realloc(J, (diff_len[0] + 2) * sizeof(int));
d802 16
a817 2
	ixold = realloc(ixold, (diff_len[0] + 2) * sizeof(long));
	ixnew = realloc(ixnew, (diff_len[1] + 2) * sizeof(long));
d1024 2
a1025 1
	struct cand *q;
d1028 3
a1030 3
		clistlen = clistlen * 11 / 10;
		clist = realloc(clist, clistlen * sizeof(cand));
		if (clist == NULL) {
d1034 2
d1379 1
d1382 9
a1390 2
			context_vec_start = realloc(context_vec_start,
			    max_context * sizeof(struct context_vec));
@


1.47
log
@no need to declare the verbosity var here as it is already done in cvs.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.46 2005/07/10 13:53:51 xsa Exp $	*/
d244 1
a244 1
static int context, status;
a721 1
		status |= 2;
a727 1
		status |= 2;
a737 1
		status |= 2;
a742 1
		status |= 1;
a746 1
		status |= 2;
d755 1
a755 2
	if ((tmp = realloc(member, (slen[1] + 2) * sizeof(int))) == NULL) {
		status |= 2;
a756 1
	}
d761 1
a761 2
	if ((tmp = realloc(class, (slen[0] + 2) * sizeof(int))) == NULL) {
		status |= 2;
a762 1
	}
a766 1
		status |= 2;
a772 1
		status |= 2;
d775 4
a778 1
	i = stone(class, slen[0], member, klist);
a793 1
		status |= 1;
d944 1
d953 3
a955 1
	c[0] = newcand(0, 0, 0);
d974 3
a976 1
				c[l] = newcand(i, y, oldc);
d981 3
a983 1
				c[l] = newcand(i, y, oldc);
@


1.46
log
@only display info msg if -q is not specified;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.45 2005/07/09 18:56:16 niallo Exp $	*/
a206 2

extern int verbosity;
@


1.45
log
@kill useless "&& r1 == NULL" expression.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.44 2005/07/09 16:28:30 niallo Exp $	*/
d208 2
d601 2
a602 1
		cvs_log(LP_INFO, "Diffing %s", fpath);
@


1.44
log
@explicit casts to const char *

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.43 2005/06/28 08:44:44 xsa Exp $	*/
d611 1
a611 1
	} else if (cf->cf_cvstat == CVS_FST_UPTODATE && r1 == NULL)
@


1.43
log
@- fix commands usage
- fix rdiff aliases

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.42 2005/06/05 20:47:44 joris Exp $	*/
d1578 1
a1578 1
			p = strchr(buf, '\n');
d1582 1
a1582 1
				strlcpy(lastbuf, buf, sizeof lastbuf);
@


1.42
log
@

* introduce cvs_putchar(), to output a single character to stdout.
  if we are in server mode send 'M' when needed.

* switch diff command to cvs_printf() and cvs_putchar() so it will
  output correctly in local and server mode.

ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.41 2005/05/31 08:58:47 xsa Exp $	*/
d340 3
a342 2
	"[-cilNnpu] [-D date] [-r rev] ...",
	"cD:ilNnpr:Ru",
d357 1
a357 1
	{ "di", "dif" },
d359 3
a361 2
	"",
	"",
@


1.41
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.40 2005/05/31 08:26:40 xsa Exp $	*/
d672 2
a673 2
	printf("%s", diffargs);
	printf(" -r%s", buf);
d675 2
a676 2
		printf(" -r%s", dap->rev2);
	printf(" %s\n", diff_file);
d1148 1
a1148 1
	 *	fprintf(stderr, "jackpot\n");
d1239 1
a1239 1
			putchar(c);
d1254 1
a1254 1
	printf("%d", a > b ? b : a);
d1256 1
a1256 1
		printf("%s%d", separator, b);
d1263 1
a1263 1
		printf("%d,%d", a, b - a + 1);
d1265 1
a1265 1
		printf("%d", b);
d1267 1
a1267 1
		printf("%d,0", b);
d1357 1
a1357 1
			printf("%s %s	%s",
d1360 1
a1360 1
			printf("%s %s	%s",
d1389 1
a1389 1
		putchar(a > b ? 'a' : c > d ? 'd' : 'c');
d1392 1
a1392 1
		putchar('\n');
d1396 1
a1396 1
			printf("a%d %d\n", b, d - c + 1);
d1398 1
a1398 1
			printf("d%d %d\n", a, b - a + 1);
d1401 1
a1401 1
				printf("a%d %d\n", b, d - c + 1);
d1412 1
a1412 1
		printf("#endif /* %s */\n", ifdefname);
d1431 1
a1431 1
			putchar(getc(lb));
d1437 1
a1437 1
			printf("#else /* %s%s */\n",
d1441 1
a1441 1
				printf("#ifndef %s\n", ifdefname);
d1443 1
a1443 1
				printf("#ifdef %s\n", ifdefname);
d1451 1
a1451 1
			putchar(ch);
d1454 1
a1454 1
				putchar('\t');
d1456 1
a1456 1
				putchar(' ');
d1469 1
a1469 1
					putchar(' ');
d1472 1
a1472 1
				putchar(c);
d1609 1
a1609 1
	printf("***************");
d1613 2
a1614 2
			putchar(' ');
			fputs(f, stdout);
d1617 1
a1617 1
	printf("\n*** ");
d1619 1
a1619 1
	printf(" ****\n");
d1658 1
a1658 1
	printf("--- ");
d1660 1
a1660 1
	printf(" ----\n");
d1714 1
a1714 1
	fputs("@@@@ -", stdout);
d1716 1
a1716 1
	fputs(" +", stdout);
d1718 1
a1718 1
	fputs(" @@@@", stdout);
d1722 2
a1723 2
			putchar(' ');
			fputs(f, stdout);
d1726 1
a1726 1
	putchar('\n');
@


1.40
log
@remove LP_ERROR log priority level and rather use LP_ERR as they are both
the same...

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.39 2005/05/31 01:59:59 joris Exp $	*/
d132 2
a135 2
#include <ctype.h>
#include <stdio.h>
d139 2
a140 1
#include <dirent.h>
d142 1
a142 1
#include <stddef.h>
a143 1
#include <string.h>
d145 1
a147 1
#include "buf.h"
@


1.39
log
@

b1 and b2 can be NULL if an invalid revision is given.
if one of them is NULL, bail out.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.38 2005/05/30 07:28:49 xsa Exp $	*/
d642 1
a642 1
		cvs_log(LP_ERROR, "failed to retrieve revision %s\n",
d666 1
a666 1
		cvs_log(LP_ERROR, "failed to retrieve revision %s\n",
@


1.38
log
@check cvs_sendarg() return value; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.37 2005/05/27 22:41:00 joris Exp $	*/
d641 8
d664 7
@


1.37
log
@

if the user specified a revision to diff, stop caring if the file is
up to date.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.36 2005/05/24 04:12:25 jfb Exp $	*/
d476 7
a482 4
		if (format == D_CONTEXT)
			cvs_sendarg(root, "-c", 0);
		else if (format == D_UNIFIED)
			cvs_sendarg(root, "-u", 0);
d485 3
a487 2
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, dap->rev1, 0);
d489 3
a491 2
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, dap->date1, 0);
d494 3
a496 2
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, dap->rev2, 0);
d498 3
a500 2
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, dap->date2, 0);
@


1.36
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.35 2005/05/22 17:48:54 jfb Exp $	*/
d602 1
a602 1
	} else if (cf->cf_cvstat == CVS_FST_UPTODATE)
@


1.35
log
@remove ununsed code
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.34 2005/05/20 20:00:53 joris Exp $	*/
d209 5
a213 1
int  cvs_diff_options   (char *, int, char **, int *);
a214 3
int  cvs_diff_file      (CVSFILE *, void *);
int  cvs_diff_sendflags (struct cvsroot *);
int  cvs_diff_cleanup   (void);
d257 1
a257 1
static int   len[2];
d335 25
a359 5
struct cvs_cmd_info cvs_diff = {
	cvs_diff_options,
	cvs_diff_sendflags,
	cvs_diff_file,
	cvs_diff_cleanup,	
d362 6
a367 1
	CVS_REQ_DIFF,
d374 2
a375 2
int
cvs_diff_options(char *opt, int argc, char **argv, int *arg)
d385 1
a385 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d405 1
a405 1
			cvs_diff.file_flags &= ~CF_RECURSE;
d437 1
a437 1
			cvs_diff.file_flags |= CF_RECURSE;
d455 1
a455 1
	if (dap != NULL)
d457 2
d463 1
a463 1
 * cvs_diff_sendflags()
d467 1
a467 1
cvs_diff_sendflags(struct cvsroot *root)
d469 11
a479 5
	/* send the flags */
	if (Nflag && (cvs_sendarg(root, "-N", 0) < 0))
		return (CVS_EX_PROTO);
	if (pflag && (cvs_sendarg(root, "-p", 0) < 0))
		return (CVS_EX_PROTO);
d481 14
a494 18
	if (format == D_CONTEXT)
		cvs_sendarg(root, "-c", 0);
	else if (format == D_UNIFIED)
		cvs_sendarg(root, "-u", 0);

	if (dap->rev1 != NULL) {
		cvs_sendarg(root, "-r", 0);
		cvs_sendarg(root, dap->rev1, 0);
	} else if (dap->date1 != NULL) {
		cvs_sendarg(root, "-D", 0);
		cvs_sendarg(root, dap->date1, 0);
	}
	if (dap->rev2 != NULL) {
		cvs_sendarg(root, "-r", 0);
		cvs_sendarg(root, dap->rev2, 0);
	} else if (dap->date2 != NULL) {
		cvs_sendarg(root, "-D", 0);
		cvs_sendarg(root, dap->date2, 0);
d506 2
a507 2
int
cvs_diff_file(struct cvs_file *cfp, void *arg)
d509 2
a510 7
	int l;
	char *dir, *repo, buf[64];
	char fpath[MAXPATHLEN], dfpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	char path_tmp1[MAXPATHLEN], path_tmp2[MAXPATHLEN];
	BUF *b1, *b2;
	RCSNUM *r1, *r2;
	RCSFILE *rf;
d524 1
a524 1
				cvs_diff_sendflags(root);
a538 1
	rf = NULL;
d552 1
a552 5
		if (root->cr_method == CVS_METHOD_LOCAL)
			cvs_log(LP_WARN, "I know nothing about %s", diff_file);
		else
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cfp));
d556 2
a557 5
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_sendentry(root, cfp) < 0) {
			return (CVS_EX_PROTO);
		}
	}
d560 1
a560 3
		if (root->cr_method != CVS_METHOD_LOCAL)
			cvs_sendreq(root, CVS_REQ_UNCHANGED,
			    CVS_FILE_NAME(cfp));
d565 18
a582 11
	if (root->cr_method != CVS_METHOD_LOCAL) {
		cvs_sendreq(root, CVS_REQ_MODIFIED, CVS_FILE_NAME(cfp));
		cvs_sendfile(root, diff_file);
	} else {
		l = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
		    root->cr_dir, repo, diff_file, RCS_FILE_EXT);
		if (l == -1 || l >= (int)sizeof(rcspath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", rcspath);
			return (CVS_EX_DATA);
		}
d584 4
a587 4
		rf = rcs_open(rcspath, RCS_READ);
		if (rf == NULL) {
			return (CVS_EX_DATA);
		}
d589 4
a592 2
		cvs_printf("Index: %s\n%s\nRCS file: %s\n", diff_file,
		    RCS_DIFF_DIV, rcspath);
d594 4
a597 7
		if (dap->rev1 == NULL)
			r1 = cfp->cf_lrev;
		else {
			if ((r1 = rcsnum_parse(dap->rev1)) == NULL) {
				return (CVS_EX_DATA);
			}
		}
d599 5
a603 3
		cvs_printf("retrieving revision %s\n",
		    rcsnum_tostr(r1, buf, sizeof(buf)));
		b1 = rcs_getrev(rf, r1);
d605 8
a612 2
		if (r1 != cfp->cf_lrev)
			rcsnum_free(r1);
d614 4
a617 10
		if (dap->rev2 != NULL) {
			cvs_printf("retrieving revision %s\n", dap->rev2);
			if ((r2 = rcsnum_parse(dap->rev2)) == NULL) {
				return (CVS_EX_DATA);
			}
			b2 = rcs_getrev(rf, r2);
			rcsnum_free(r2);
		} else {
			b2 = cvs_buf_load(diff_file, BUF_AUTOEXT);
		}
d619 2
a620 1
		rcs_close(rf);
d622 4
a625 9
		printf("%s", diffargs);
		printf(" -r%s", buf);
		if (dap->rev2 != NULL)
			printf(" -r%s", dap->rev2);
		printf(" %s\n", diff_file);
		strlcpy(path_tmp1, "/tmp/diff1.XXXXXXXXXX", sizeof(path_tmp1));
		if (cvs_buf_write_stmp(b1, path_tmp1, 0600) == -1) {
			cvs_buf_free(b1);
			cvs_buf_free(b2);
d628 8
a635 1
		cvs_buf_free(b1);
d637 3
a639 4
		strlcpy(path_tmp2, "/tmp/diff2.XXXXXXXXXX", sizeof(path_tmp2));
		if (cvs_buf_write_stmp(b2, path_tmp2, 0600) == -1) {
			cvs_buf_free(b2);
			(void)unlink(path_tmp1);
d642 16
d659 3
d663 3
a665 1
		cvs_diffreg(path_tmp1, path_tmp2);
d667 1
a667 1
		(void)unlink(path_tmp2);
d669 5
d765 1
a765 1
	J = realloc(J, (len[0] + 2) * sizeof(int));
d770 2
a771 2
	ixold = realloc(ixold, (len[0] + 2) * sizeof(long));
	ixnew = realloc(ixnew, (len[1] + 2) * sizeof(long));
d849 1
a849 1
	len[i] = j;
d860 1
a860 1
	for (pref = 0; pref < len[0] && pref < len[1] &&
d864 4
a867 2
	for (suff = 0; suff < len[0] - pref && suff < len[1] - pref &&
	    file[0][len[0] - suff].value == file[1][len[1] - suff].value;
d872 1
a872 1
		slen[j] = len[j] - pref - suff;
d1019 1
a1019 1
	for (i = 0; i <= len[0]; i++)
d1021 1
a1021 1
		    i > len[0] - suff ? i + len[1] - len[0] : 0;
d1044 1
a1044 1
	for (i = 1; i <= len[0]; i++) {
d1122 1
a1122 1
	for (; j <= len[1]; j++)
d1196 1
a1196 1
	m = len[0];
d1198 1
a1198 1
	J[m + 1] = len[1] + 1;
d1211 1
a1211 1
		change(file1, f1, file2, f2, 1, 0, 1, len[1]);
d1583 1
a1583 1
	upb = MIN(len[0], context_vec_ptr->b + context);
d1585 1
a1585 1
	upd = MIN(len[1], context_vec_ptr->d + context);
d1688 1
a1688 1
	upb = MIN(len[0], context_vec_ptr->b + context);
d1690 1
a1690 1
	upd = MIN(len[1], context_vec_ptr->d + context);
@


1.34
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.33 2005/04/25 19:09:15 jfb Exp $	*/
a130 1
#include <sys/wait.h>
d209 5
a213 12
struct excludes {
	char *pattern;
	struct excludes *next;
};


char	*splice(char *, char *);
int  cvs_diff_options(char *, int, char **, int *);
int  cvs_diffreg(const char *, const char *);
int  cvs_diff_file(struct cvs_file *, void *);
int  cvs_diff_sendflags(struct cvsroot *);
int  cvs_diff_cleanup(void);
a763 14
}


char *
splice(char *dir, char *filename)
{
	char *tail, *buf;

	if ((tail = strrchr(filename, '/')) == NULL)
		tail = filename;
	else
		tail++;
	asprintf(&buf, "%s/%s", dir, tail);
	return (buf);
@


1.33
log
@resurrect missing parts to generate rcsdiff(1)-style diffs with the -n
flag

ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.32 2005/04/22 03:38:56 joris Exp $	*/
d567 1
a567 1
			return (-1);
@


1.32
log
@

missing '-R' (force recursion) option for diff.

noticed by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.31 2005/04/18 21:02:49 jfb Exp $	*/
d133 1
d163 1
d397 4
d1341 10
d1408 4
a1411 1
				puts("\n\\ No newline at end of file");
@


1.31
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.30 2005/04/16 19:05:02 xsa Exp $	*/
d411 3
@


1.30
log
@snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.29 2005/04/14 16:49:09 joris Exp $	*/
a484 1
	struct cvs_ent *entp;
d489 1
a489 1
			root = cfp->cf_parent->cf_ddat->cd_root;
d493 1
a493 1
			root = cfp->cf_ddat->cd_root;
d496 1
a496 1
			    (root != cfp->cf_parent->cf_ddat->cd_root)) {
d518 2
a519 2
		root = cfp->cf_parent->cf_ddat->cd_root;
		repo = cfp->cf_parent->cf_ddat->cd_repo;
a534 4
	entp = cvs_ent_getent(diff_file);
	if (entp == NULL)
		return (CVS_EX_DATA);

d536 1
a536 2
		if (cvs_sendentry(root, entp) < 0) {
			cvs_ent_free(entp);
a544 1
		cvs_ent_free(entp);
a557 2

			cvs_ent_free(entp);
a562 1
			cvs_ent_free(entp);
d570 1
a570 1
			r1 = entp->ce_rev;
a572 1
				cvs_ent_free(entp);
d581 1
a581 1
		if (r1 != entp->ce_rev)
a586 1
				cvs_ent_free(entp);
a622 1
	cvs_ent_free(entp);
@


1.29
log
@

completely fix the diff command
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.28 2005/04/12 14:58:40 joris Exp $	*/
d478 1
d560 1
a560 1
		snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
d562 7
@


1.28
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.27 2005/04/11 18:02:58 joris Exp $	*/
d348 1
a348 1
	CVS_CMD_SENDDIR
@


1.27
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.26 2005/04/11 17:56:27 joris Exp $	*/
d361 1
a361 1
		return (-1);
d409 1
a409 1
				return (1);
d417 1
a417 1
			return (1);
d442 1
a442 1
		return (-1);
d444 1
a444 1
		return (-1);
d537 1
a537 1
		return (-1);
d542 1
a542 1
			return (-1);
d565 1
a565 1
			return (-1);
d576 1
a576 1
				return (-1);
d591 1
a591 1
				return (-1);
d610 1
a610 1
			return (-1);
d618 1
a618 1
			return (-1);
@


1.26
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.25 2005/04/03 17:32:50 xsa Exp $	*/
a143 1
#include <sysexits.h>
@


1.25
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.24 2005/03/31 14:57:32 joris Exp $	*/
d410 1
a410 1
				return (EX_USAGE);
d418 1
a418 1
			return (EX_USAGE);
@


1.24
log
@

remove unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.23 2005/03/30 17:43:04 joris Exp $	*/
d362 1
a362 1
		return (EX_DATAERR);
@


1.23
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.22 2005/02/27 00:22:08 jfb Exp $	*/
a247 2

extern int cvs_client;
@


1.22
log
@Many improvements to the RCS support:

- make it possible to specify creation and the file mode
  in rcs_open()
- implicitly write the contents to disk on rcs_close() if the
  RCS handle has been changed
- fix a bug in the output of the `expand' keyword
- add functions to retrieve and modify the expansion mode
- rcs_parse() shouldn't be available to the outside
- empty string instead of `(null)' if there is no description

ok Joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.21 2005/02/25 20:32:48 jfb Exp $	*/
d216 1
d219 3
a221 1
int  cvs_diff_sendflags(struct cvsroot *, struct diff_arg *);
d343 13
a356 7
/*
 * cvs_diff()
 *
 * Handler for the `cvs diff' command.
 *
 * SYNOPSIS: cvs [args] diff [-clipu] [-D date] [-r rev]
 */
d358 1
a358 1
cvs_diff(int argc, char **argv)
d360 1
a360 3
	int ch, recurse, flags;
	struct diff_arg darg;
	struct cvsroot *root;
d362 4
a365 5
	context = CVS_DIFF_DEFCTX;
	flags = CF_RECURSE|CF_IGNORE|CF_SORT|CF_KNOWN;
	recurse = 1;

	memset(&darg, 0, sizeof(darg));
d368 1
a368 1
	while ((ch = getopt(argc, argv, "cD:liNpr:u")) != -1) {
d375 5
a379 5
			if (darg.date1 == NULL && darg.rev1 == NULL)
				darg.date1 = optarg;
			else if (darg.date2 == NULL && darg.rev2 == NULL)
				darg.date2 = optarg;
			else {
d388 1
a388 1
			flags &= ~CF_RECURSE;
d403 6
a408 5
			if ((darg.rev1 == NULL) && (darg.date1 == NULL))
				darg.rev1 = optarg;
			else if ((darg.rev2 == NULL) && (darg.date2 == NULL))
				darg.rev2 = optarg;
			else {
d424 3
a426 17
	argc -= optind;
	argv += optind;

	if (argc == 0) {
		cvs_files = cvs_file_get(".", flags);
	} else
		cvs_files = cvs_file_getspec(argv, argc, 0);
	if (cvs_files == NULL)
		return (EX_DATAERR);

	cvs_file_examine(cvs_files, cvs_diff_file, &darg);

	root = cvs_files->cf_ddat->cd_root;
	if (root->cr_method != CVS_METHOD_LOCAL) {
		cvs_senddir(root, cvs_files);
		cvs_sendreq(root, CVS_REQ_DIFF, NULL);
	}
d428 5
a435 1

d441 1
a441 1
cvs_diff_sendflags(struct cvsroot *root, struct diff_arg *dap)
a486 1
	struct diff_arg *dap;
a489 2
	dap = (struct diff_arg *)arg;

d497 1
d501 1
a501 1
				cvs_diff_sendflags(root, dap);
d503 1
@


1.21
log
@- switch to rcsnum_parse() where appropriate
- make rcsnum_parse() fail if it encounters an invalid character
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.20 2005/02/01 18:03:32 jfb Exp $	*/
d569 1
a569 1
		rf = rcs_open(rcspath, RCS_MODE_READ);
@


1.20
log
@first round of malloc()/realloc() fixes:
- avoid using the original pointer to store the return
  value of realloc(), so we can free it in case of failure
- check return values for allocation failures and return errors in
  the appropriate cases
- free the diff buffers once the diff has been generated

feedback and testing by Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.19 2005/01/29 15:47:51 jfb Exp $	*/
d581 1
a581 1
			if ((r1 = rcsnum_alloc()) == NULL) {
a584 1
			rcsnum_aton(dap->rev1, NULL, r1);
d596 1
a596 1
			if ((r2 = rcsnum_alloc()) == NULL) {
a599 1
			rcsnum_aton(dap->rev2, NULL, r2);
@


1.19
log
@apply sizeof() to the appropriate buffer in a strlcpy() call

spotted by Andrey Matveev (andrushock at korovino dot net)
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.18 2005/01/14 00:35:15 jfb Exp $	*/
d225 1
a225 1
static void prepare(int, FILE *, off_t);
d581 4
a584 1
			r1 = rcsnum_alloc();
d592 3
d597 4
a600 1
			r2 = rcsnum_alloc();
d603 1
d616 3
a618 1
		if (cvs_buf_write_stmp(b1, path_tmp1, 0600) == -1)
d620 3
d625 1
d629 2
d646 1
d686 5
a690 2
	prepare(0, f1, stb1.st_size);
	prepare(1, f2, stb2.st_size);
d697 5
a701 1
	member = realloc(member, (slen[1] + 2) * sizeof(int));
d705 5
a709 1
	class = realloc(class, (slen[0] + 2) * sizeof(int));
d711 5
a715 1
	klist = malloc((slen[0] + 2) * sizeof(int));
d718 5
a722 1
	clist = malloc(clistlen * sizeof(cand));
d747 1
d793 1
a793 1
static void
d796 1
d807 5
a811 1
	p = malloc((sz + 3) * sizeof(struct line));
d815 7
a821 1
			p = realloc(p, (sz + 3) * sizeof(struct line));
d827 2
d951 4
d1142 4
a1145 1
	a = malloc((l + 1) * sizeof(int));
@


1.18
log
@missing space and kill a gcc warning
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.17 2005/01/13 23:39:42 jfb Exp $	*/
d608 1
a608 1
		strlcpy(path_tmp2, "/tmp/diff2.XXXXXXXXXX", sizeof(path_tmp1));
@


1.17
log
@resurrect the -N and -p options to the diff command

requested and tested by brad@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.16 2004/12/28 22:07:31 xsa Exp $	*/
d835 1
a835 1
		return(0);
d854 2
a855 1
	const u_int bound = dflag ? UINT_MAX : MAX(256, isqrt(n));
@


1.16
log
@remove signedness warnings; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.15 2004/12/28 20:39:15 jfb Exp $	*/
d242 1
d248 1
a248 1
static int aflag, bflag, dflag, iflag, Nflag, tflag, Tflag, wflag;
d277 3
a279 2
static int lastline;
static int lastmatchline;
d362 1
a362 1
	while ((ch = getopt(argc, argv, "cD:liN:r:u")) != -1) {
d392 4
d447 5
d1438 31
d1477 1
a1477 1
	char ch;
d1489 7
d1582 1
a1582 1
	char ch;
d1598 7
@


1.15
log
@rename parameters to avoid shadowing global declarations
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.14 2004/12/28 19:51:07 jfb Exp $	*/
d752 1
a752 1
	sz = (filesize <= SIZE_MAX ? filesize : SIZE_MAX) / 25;
@


1.14
log
@use Argument instead of Argumentx when sending a revision or date
this makes the -r and -D options work with diff
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.13 2004/12/14 21:40:39 jfb Exp $	*/
d731 1
a731 1
splice(char *dir, char *file)
d735 2
a736 2
	if ((tail = strrchr(file, '/')) == NULL)
		tail = file;
d1152 1
a1152 1
preadline(int fd, size_t len, off_t off)
d1157 1
a1157 1
	line = malloc(len + 1);
d1162 1
a1162 1
	if ((nr = pread(fd, line, len, off)) < 0) {
@


1.13
log
@complain about lost files
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.12 2004/12/08 21:11:07 djm Exp $	*/
d448 1
a448 1
		cvs_sendarg(root, dap->rev1, 1);
d451 1
a451 1
		cvs_sendarg(root, dap->date1, 1);
d455 1
a455 1
		cvs_sendarg(root, dap->rev2, 1);
d458 1
a458 1
		cvs_sendarg(root, dap->date2, 1);
@


1.12
log
@use mkstemp for local diff -r r1 -r r2; ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.11 2004/12/07 17:10:56 tedu Exp $	*/
d501 5
@


1.11
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.10 2004/12/06 21:03:12 deraadt Exp $	*/
d475 1
d589 11
a599 3
		cvs_buf_write(b1, "/tmp/diff1", 0600);
		cvs_buf_write(b2, "/tmp/diff2", 0600);
		cvs_diffreg("/tmp/diff1", "/tmp/diff2");
@


1.10
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.9 2004/12/06 02:46:47 jfb Exp $	*/
a244 1

a279 2


a338 1

a345 1

a436 1

a469 1

@


1.9
log
@Missing prototype for cvs_diff_sendflags(), removes a gcc warning
@
text
@d1 1
a1 1
/*	$OpenBSD: diff.c,v 1.8 2004/11/26 16:23:50 jfb Exp $	*/
d421 1
a421 2
	}
	else
d455 1
a455 2
	}
	else if (dap->date1 != NULL) {
d462 1
a462 2
	}
	else if (dap->date2 != NULL) {
d496 1
a496 2
		}
		else {
d517 1
a517 2
	}
	else {
d555 1
a555 2
	}
	else {
d584 1
a584 2
		}
		else {
@


1.8
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d217 2
a218 1
int  cvs_diff_file  (struct cvs_file *, void *);
@


1.7
log
@Fix handling of unknown directories
@
text
@d247 1
a247 1
static int aflag, bflag, dflag, iflag, tflag, Tflag, wflag;
d364 1
a364 1
	while ((ch = getopt(argc, argv, "cD:lir:u")) != -1) {
d390 4
d482 2
a483 1
	char *dir, *repo, rcspath[MAXPATHLEN], buf[64];
d496 2
a497 1
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
d514 1
a514 1
	diff_file = cfp->cf_path;
d517 1
a517 1
		dir = cfp->cf_parent->cf_path;
d531 2
a532 1
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
d549 2
a550 1
			cvs_sendreq(root, CVS_REQ_UNCHANGED, cfp->cf_name);
d557 1
a557 1
		cvs_sendreq(root, CVS_REQ_MODIFIED, cfp->cf_name);
@


1.6
log
@Start using the global files list
@
text
@d419 2
d489 13
a501 5
		root = cfp->cf_ddat->cd_root;
		if ((cfp->cf_parent == NULL) ||
		    (root != cfp->cf_parent->cf_ddat->cd_root)) {
			cvs_connect(root);
			cvs_diff_sendflags(root, dap);
a503 1
		cvs_senddir(root, cfp);
a505 2
	else	/* take the root of parent directory */
		root = cfp->cf_parent->cf_ddat->cd_root;
d509 1
d512 1
d517 1
@


1.5
log
@fix diffing by sending the base directory just before sending the 'diff'
command, and remove some debugging messages
@
text
@a353 1
	struct cvs_file *files;
d415 1
a415 1
		files = cvs_file_get(".", flags);
d418 1
a418 1
		files = cvs_file_getspec(argv, argc, 0);
d420 1
a420 1
	cvs_file_examine(files, cvs_diff_file, &darg);
d422 1
a422 1
	root = files->cf_ddat->cd_root;
d424 1
a424 1
		cvs_senddir(root, files);
@


1.4
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d424 2
a425 1
	if (root->cr_method != CVS_METHOD_LOCAL)
d427 1
a485 2

	cvs_log(LP_DEBUG, "%s: diffing %s", __func__, cfp->cf_path);
@


1.3
log
@prepare the entries interface so we can add entries
@
text
@d149 1
d201 7
d217 1
a217 2
int  cvs_diff_file  (const char *, const char *, const char *);
int  cvs_diff_dir   (const char *, int);
a240 3
static __inline int min(int, int);
static __inline int max(int, int);
static char *match_function(const long *, int, FILE *);
a245 3
extern struct cvsroot *cvs_root;


a275 1
static char lastbuf[FUNCTION_CONTEXT_SIZE];
d353 4
a356 3
	int i, ch, recurse;
	size_t dalen;
	char dir[MAXPATHLEN], file[MAXPATHLEN], *d1, *d2, *r1, *r2;
d359 4
a364 4
	d1 = d2 = NULL;
	r1 = r2 = NULL;
	recurse = 1;

d372 4
a375 4
			if (d1 == NULL && r1 == NULL)
				d1 = optarg;
			else if (d2 == NULL && r2 == NULL)
				d2 = optarg;
d385 1
d392 4
a395 4
			if ((r1 == NULL) && (d1 == NULL))
				r1 = optarg;
			else if ((r2 == NULL) && (d2 == NULL))
				r2 = optarg;
d416 4
a419 2
		/* get the CVSROOT from current dir */
		strlcpy(dir, ".", sizeof(dir));
d421 1
a421 3
		cvs_root = cvsroot_get(dir);
		if (cvs_root == NULL)
			return (EX_USAGE);
d423 3
a425 2
		if (cvs_root->cr_method != CVS_METHOD_LOCAL) {
			cvs_client_connect();
d427 2
a428 23
			/* send the flags */
			if (format == D_CONTEXT)
				cvs_client_sendarg("-c", 0);
			else if (format == D_UNIFIED)
				cvs_client_sendarg("-u", 0);

			if (r1 != NULL) {
				cvs_client_sendarg("-r", 0);
				cvs_client_sendarg(r1, 1);
			}
			else if (d1 != NULL) {
				cvs_client_sendarg("-D", 0);
				cvs_client_sendarg(d1, 1);
			}
			if (r2 != NULL) {
				cvs_client_sendarg("-r", 0);
				cvs_client_sendarg(r2, 1);
			}
			else if (d2 != NULL) {
				cvs_client_sendarg("-D", 0);
				cvs_client_sendarg(d2, 1);
			}
		}
a429 9
		cvs_diff_dir(dir, recurse);
	}
	else {
		for (i = 0; i < argc; i++) {
			cvs_splitpath(argv[i], dir, sizeof(dir),
			    file, sizeof(file));
			cvs_root = cvsroot_get(dir);
			if (cvs_root == NULL)
				return (EX_USAGE);
d431 4
a434 2
			if (cvs_root->cr_method != CVS_METHOD_LOCAL) {
				cvs_client_connect();
d436 24
a459 11
				if (i == 0) {
					/* send the flags */
					if (format == D_CONTEXT)
						cvs_client_sendarg("-c", 0);
					else if (format == D_UNIFIED)
						cvs_client_sendarg("-u", 0);
				}
			}

			cvs_diff_file(argv[i], r1, r2);
		}
a461 3
	if (cvs_root->cr_method != CVS_METHOD_LOCAL)
		cvs_client_sendreq(CVS_REQ_DIFF, NULL, 1);

d473 1
a473 1
cvs_diff_file(const char *path, const char *rev1, const char *rev2)
d475 1
a475 4
	int modif;
	char dir[MAXPATHLEN], file[MAXPATHLEN], rcspath[MAXPATHLEN];
	char repo[MAXPATHLEN], buf[64];
	time_t tsec;
d479 1
a479 3
	CVSENTRIES *entf;
	struct tm tmstamp;
	struct stat fst;
d481 1
d483 1
a483 2
	rf = NULL;
	diff_file = path;
d485 1
a485 4
	if (stat(path, &fst) == -1) {
		cvs_log(LP_ERRNO, "cannot find %s", path);
		return (-1);
	}
d487 7
a493 2
	cvs_splitpath(path, dir, sizeof(dir), file, sizeof(file));
	cvs_readrepo(dir, repo, sizeof(repo));
d495 2
a496 4
	entf = cvs_ent_open(dir, O_RDONLY);
	if (entf == NULL) {
		cvs_log(LP_ERR, "no CVS/Entries file in `%s'", dir);
		return (-1);
d498 2
d501 9
a509 4
	entp = cvs_ent_get(entf, file);
	if ((entp == NULL) && (cvs_root->cr_method == CVS_METHOD_LOCAL)) {
		cvs_log(LP_WARN, "I know nothing about %s", path);
		return (-1);
d512 6
a517 3
	if (cvs_root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_client_senddir(dir) < 0)
			return (-1);
d520 3
a522 1
	tsec = (time_t)fst.st_mtimespec.tv_sec;
d524 5
a528 4
	if ((gmtime_r(&tsec, &tmstamp) == NULL) ||
	    (asctime_r(&tmstamp, buf) == NULL)) {
		cvs_log(LP_ERR, "failed to generate file timestamp");
		return (-1);
a529 4
	modif = (strcmp(buf, entp->ce_timestamp) == 0) ? 0 : 1;

	if (cvs_root->cr_method != CVS_METHOD_LOCAL)
		cvs_client_sendentry(entp);
d531 4
a534 4
	if (!modif) {
		if (cvs_root->cr_method != CVS_METHOD_LOCAL)
			cvs_client_sendreq(CVS_REQ_UNCHANGED, file, 0);
		cvs_ent_close(entf);
d539 3
a541 3
	if (cvs_root->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_sendreq(CVS_REQ_MODIFIED, file, 0);
		cvs_sendfile(path);
d545 1
a545 1
		    cvs_root->cr_dir, repo, path, RCS_FILE_EXT);
d548 2
a549 1
		if (rf == NULL)
d551 1
d553 1
a553 1
		printf("Index: %s\n%s\nRCS file: %s\n", path,
d556 1
a556 1
		if (rev1 == NULL)
d560 1
a560 1
			rcsnum_aton(rev1, NULL, r1);
d563 1
a563 1
		printf("retrieving revision %s\n",
d567 2
a568 2
		if (rev2 != NULL) {
			printf("retrieving revision %s\n", rev2);
d570 1
a570 1
			rcsnum_aton(rev2, NULL, r2);
d574 1
a574 1
			b2 = cvs_buf_load(path, BUF_AUTOEXT);
d577 2
d581 3
a583 3
		if (rev2 != NULL)
			printf(" -r%s", rev2);
		printf(" %s\n", path);
d589 1
a589 2
	cvs_ent_close(entf);

a593 66
/*
 * cvs_diff_dir()
 *
 */

int
cvs_diff_dir(const char *dir, int recurse)
{
	char path[MAXPATHLEN];
	DIR *dirp;
	CVSENTRIES *entf;
	struct dirent *dentp;
	struct cvs_ent *entp;

	printf("cvs_diff_dir(%s)\n", dir);

	dirp = opendir(dir);
	if (dirp == NULL) {
		cvs_log(LP_ERRNO, "failed to open directory `%s'", dir);
		return (-1);
	}

	entf = cvs_ent_open(dir, O_RDONLY);
	if (entf == NULL) {
		cvs_log(LP_ERR, "no CVS/Entries file in `%s'", dir);
		(void)closedir(dirp);
		return (-1);
	}

	while ((dentp = readdir(dirp)) != NULL) {
		if ((strcmp(dentp->d_name, "CVS") == 0) ||
		    (dentp->d_name[0] == '.'))
			continue;

		if (strcmp(dir, ".") != 0) {
			strlcpy(path, dir, sizeof(path));
			strlcat(path, "/", sizeof(path));
		}
		else
			path[0] = '\0';
		strlcat(path, dentp->d_name, sizeof(path));
		if (dentp->d_type == DT_DIR) {
			if (!recurse)
				continue;
			cvs_diff_dir(path, recurse);
		}
		else {
			entp = cvs_ent_get(entf, dentp->d_name);
			if (entp == NULL) {
				cvs_client_sendreq(CVS_REQ_QUESTIONABLE, path,
				    0);
			}
			else {
#if 0
				cvs_diff_file(path);
#endif
			}
		}
	}

	return (0);
}




d825 1
a825 1
	const u_int bound = dflag ? UINT_MAX : max(256, isqrt(n));
a1408 40
static __inline int min(int a, int b)
{
	return (a < b ? a : b);
}

static __inline int max(int a, int b)
{
	return (a > b ? a : b);
}

static char *
match_function(const long *f, int pos, FILE *file)
{
	char buf[FUNCTION_CONTEXT_SIZE];
	size_t nc;
	int last = lastline;
	char *p;

	lastline = pos;
	while (pos > last) {
		fseek(file, f[pos - 1], SEEK_SET);
		nc = f[pos] - f[pos - 1];
		if (nc >= sizeof(buf))
			nc = sizeof(buf) - 1;
		nc = fread(buf, 1, nc, file);
		if (nc > 0) {
			buf[nc] = '\0';
			p = strchr(buf, '\n');
			if (p != NULL)
				*p = '\0';
			if (isalpha(buf[0]) || buf[0] == '_' || buf[0] == '$') {
				strlcpy(lastbuf, buf, sizeof lastbuf);
				lastmatchline = pos;
				return lastbuf;
			}
		}
		pos--;
	}
	return lastmatchline > 0 ? lastbuf : NULL;
}
d1417 1
a1417 1
	char ch, *f;
d1423 4
a1426 4
	lowa = max(1, cvp->a - context);
	upb = min(len[0], context_vec_ptr->b + context);
	lowc = max(1, cvp->c - context);
	upd = min(len[1], context_vec_ptr->d + context);
d1515 1
a1515 1
	char ch, *f;
d1521 4
a1524 4
	lowa = max(1, cvp->a - context);
	upb = min(len[0], context_vec_ptr->b + context);
	lowc = max(1, cvp->c - context);
	upd = min(len[1], context_vec_ptr->d + context);
@


1.2
log
@print diffargs correctly instead of a (null).  This should make the diff
output exactly the same as the one from GNU CVS
@
text
@d513 1
a513 1
	entf = cvs_ent_open(dir);
d624 1
a624 1
	entf = cvs_ent_open(dir);
@


1.1
log
@Initial revision
@
text
@d250 2
a251 1
static char *ifdefname, *diffargs, *ignore_pats, *diff_file;
d358 1
d367 1
d382 1
d386 1
d402 1
d586 5
a590 1
		printf("%s\n", diffargs);
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
