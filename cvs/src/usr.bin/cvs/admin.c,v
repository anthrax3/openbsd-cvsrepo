head	1.67;
access;
symbols
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.66.0.4
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.65.0.6
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.64.0.26
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.64.0.24
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.64.0.20
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.64.0.18
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.64.0.16
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.14
	OPENBSD_5_0:1.64.0.12
	OPENBSD_5_0_BASE:1.64
	OPENBSD_4_9:1.64.0.10
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.64.0.8
	OPENBSD_4_8_BASE:1.64
	OPENBSD_4_7:1.64.0.4
	OPENBSD_4_7_BASE:1.64
	OPENBSD_4_6:1.64.0.6
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.51.0.2
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.67
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.66;
commitid	8Vv7d4HkmCtExfc6;

1.66
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.65;
commitid	O6jeJ0TRmiewrqMI;

1.65
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	Uu5nFG3wCl0LACBb;

1.64
date	2008.09.12.13.20.36;	author tobias;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.20.16.32.06;	author tobias;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.13.17.15.13;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.11.01.43.35;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.22.15.45.01;	author tobias;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.11.12.16.00;	author tobias;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.09.03.14.52;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.09.01.54.03;	author joris;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.04.15.07.32;	author tobias;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.31.21.52.48;	author tobias;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.01.09.45.43;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.21.11.20.10;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2007.01.02.00.02.17;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.01.23.49.06;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2006.12.31.15.38.11;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2006.12.31.15.33.23;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.13.12.51.58;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.13.11.50.11;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.13.11.04.19;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.13.10.42.28;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.13.10.24.30;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.27.03.30.30;	author joris;	state dead;
branches;
next	1.33;

1.33
date	2006.04.10.08.08.00;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.01.20.11.25;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.24.13.34.27;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.16.09.06.19;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.01.08.33.18;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.30.17.58.47;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.27.15.26.38;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.22.14.59.54;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.27.16.42.19;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.18.07.22.23;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.14.06.50.50;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.11.08.32.36;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.25.10.23.57;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.18.21.02.49;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.16.19.05.02;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.26.08.09.54;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.11.16.23.34;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.08.00.20.39;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.07.19.41.07;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.07.16.25.48;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.21.09.00;	author joris;	state Exp;
branches;
next	;


desc
@@


1.67
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@/*	$OpenBSD: admin.c,v 1.66 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * Copyright (c) 2005 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2006, 2007 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/dirent.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

#define ADM_EFLAG	0x01

void	cvs_admin_local(struct cvs_file *);

struct cvs_cmd cvs_cmd_admin = {
	CVS_OP_ADMIN, CVS_USE_WDIR | CVS_LOCK_REPO, "admin",
	{ "adm", "rcs" },
	"Administrative front-end for RCS",
	"[-ILqU] [-A oldfile] [-a users] [-b branch]\n"
	"[-c string] [-e [users]] [-k mode] [-l [rev]] [-m rev:msg]\n"
	"[-N tag[:rev]] [-n tag[:rev]] [-o rev] [-s state[:rev]]"
	"[-t file | str]\n"
	"[-u [rev]] file ...",
	"A:a:b::c:e::Ik:l::Lm:N:n:o:qs:t:Uu::",
	NULL,
	cvs_admin
};

static int	 runflags = 0;
static int	 lkmode = RCS_LOCK_INVAL;
static char	*alist, *comment, *elist, *logmsg, *logstr, *koptstr;
static char	*oldfilename, *orange, *state, *staterevstr;

int
cvs_admin(int argc, char **argv)
{
	int ch;
	int flags;
	char *statestr;
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;

	alist = comment = elist = logmsg = logstr = NULL;
	oldfilename = orange = state = statestr = NULL;

	while ((ch = getopt(argc, argv, cvs_cmd_admin.cmd_opts)) != -1) {
		switch (ch) {
		case 'A':
			oldfilename = optarg;
			break;
		case 'a':
			alist = optarg;
			break;
		case 'b':
			break;
		case 'c':
			comment = optarg;
			break;
		case 'e':
			elist = optarg;
			runflags |= ADM_EFLAG;
			break;
		case 'I':
			break;
		case 'k':
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				fatal("%s", cvs_cmd_admin.cmd_synopsis);
			}
			break;
		case 'L':
			if (lkmode == RCS_LOCK_LOOSE) {
				cvs_log(LP_ERR, "-L and -U are incompatible");
				fatal("%s", cvs_cmd_admin.cmd_synopsis);
			}
			lkmode = RCS_LOCK_STRICT;
			break;
		case 'l':
			break;
		case 'm':
			logstr = optarg;
			break;
		case 'N':
			break;
		case 'n':
			break;
		case 'o':
			orange = optarg;
			break;
		case 'q':
			verbosity = 0;
			break;
		case 's':
			statestr = optarg;
			break;
		case 't':
			break;
		case 'U':
			if (lkmode == RCS_LOCK_STRICT) {
				cvs_log(LP_ERR, "-U and -L are incompatible");
				fatal("%s", cvs_cmd_admin.cmd_synopsis);
			}
			lkmode = RCS_LOCK_LOOSE;
			break;
		case 'u':
			break;
		default:
			fatal("%s", cvs_cmd_admin.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		fatal("%s", cvs_cmd_admin.cmd_synopsis);

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (oldfilename != NULL)
			cvs_client_send_request("Argument -A%s", oldfilename);

		if (alist != NULL)
			cvs_client_send_request("Argument -a%s", alist);

		if (comment != NULL)
			cvs_client_send_request("Argument -c%s", comment);

		if (runflags & ADM_EFLAG)
			cvs_client_send_request("Argument -e%s",
			    (elist != NULL) ? elist : "");

		if (koptstr != NULL)
			cvs_client_send_request("Argument -k%s", koptstr);

		if (lkmode == RCS_LOCK_STRICT)
			cvs_client_send_request("Argument -L");
		else if (lkmode == RCS_LOCK_LOOSE)
			cvs_client_send_request("Argument -U");

		if (logstr != NULL)
			cvs_client_send_logmsg(logstr);

		if (orange != NULL)
			cvs_client_send_request("Argument -o%s", orange);

		if (statestr != NULL)
			cvs_client_send_request("Argument -s%s", statestr);

		if (verbosity == 0)
			cvs_client_send_request("Argument -q");

	} else {
		if (statestr != NULL) {
			if ((staterevstr = strchr(statestr, ':')) != NULL)
				*staterevstr++ = '\0';
			state = statestr;
			if (rcs_state_check(state) < 0) {
				cvs_log(LP_ERR, "invalid state `%s'", state);
				state = NULL;
			}
		}

		flags |= CR_REPO;
		cr.fileproc = cvs_admin_local;
	}

	cr.flags = flags;

	cvs_file_run(argc, argv, &cr);

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("admin");
		cvs_client_get_responses();
	}

	return (0);
}

void
cvs_admin_local(struct cvs_file *cf)
{
	int i;
	RCSNUM *rev;

	cvs_log(LP_TRACE, "cvs_admin_local(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_type == CVS_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Administrating %s", cf->file_name);
		return;
	}

	if (cf->file_ent == NULL)
		return;
	else if (cf->file_status == FILE_ADDED) {
		cvs_log(LP_ERR, "cannot admin newly added file `%s'",
		    cf->file_name);
		return;
	}

	if (cf->file_rcs == NULL) {
		cvs_log(LP_ERR, "lost RCS file for `%s'", cf->file_path);
		return;
	}

	if (verbosity > 0)
		cvs_printf("RCS file: %s\n", cf->file_rcs->rf_path);

	if (oldfilename != NULL) {
		struct cvs_file *ocf;
		struct rcs_access *acp;
		int ofd;
		char *d, *f, fpath[PATH_MAX], repo[PATH_MAX];


		if ((f = basename(oldfilename)) == NULL)
			fatal("cvs_admin_local: basename failed");
		if ((d = dirname(oldfilename)) == NULL)
			fatal("cvs_admin_local: dirname failed");

		cvs_get_repository_path(d, repo, PATH_MAX);

		(void)xsnprintf(fpath, PATH_MAX, "%s/%s", repo, f);

		if (strlcat(fpath, RCS_FILE_EXT, PATH_MAX) >= PATH_MAX)
			fatal("cvs_admin_local: truncation");

		if ((ofd = open(fpath, O_RDONLY)) == -1)
			fatal("cvs_admin_local: open: `%s': %s", fpath,
			    strerror(errno));

		/* XXX: S_ISREG() check instead of blindly using CVS_FILE? */
		ocf = cvs_file_get_cf(d, f, oldfilename, ofd, CVS_FILE, 0);

		ocf->file_rcs = rcs_open(fpath, ofd, RCS_READ, 0444);
		if (ocf->file_rcs == NULL)
			fatal("cvs_admin_local: rcs_open failed");

		TAILQ_FOREACH(acp, &(ocf->file_rcs->rf_access), ra_list)
			rcs_access_add(cf->file_rcs, acp->ra_name);

		cvs_file_free(ocf);
	}

	if (alist != NULL) {
		struct cvs_argvector *aargv;

		aargv = cvs_strsplit(alist, ",");
		for (i = 0; aargv->argv[i] != NULL; i++)
			rcs_access_add(cf->file_rcs, aargv->argv[i]);

		cvs_argv_destroy(aargv);
	}

	if (comment != NULL)
		rcs_comment_set(cf->file_rcs, comment);

	if (elist != NULL) {
		struct cvs_argvector *eargv;

		eargv = cvs_strsplit(elist, ",");
		for (i = 0; eargv->argv[i] != NULL; i++)
			rcs_access_remove(cf->file_rcs, eargv->argv[i]);

		cvs_argv_destroy(eargv);
	} else if (runflags & ADM_EFLAG) {
		struct rcs_access *rap;

		while (!TAILQ_EMPTY(&(cf->file_rcs->rf_access))) {
			rap = TAILQ_FIRST(&(cf->file_rcs->rf_access));
			TAILQ_REMOVE(&(cf->file_rcs->rf_access), rap, ra_list);
			free(rap->ra_name);
			free(rap);
		}
		/* no synced anymore */
		cf->file_rcs->rf_flags &= ~RCS_SYNCED;
	}

	/* Default `-kv' is accepted here. */
	if (kflag) {
		if (cf->file_rcs->rf_expand == NULL ||
		    strcmp(cf->file_rcs->rf_expand, koptstr) != 0)
			rcs_kwexp_set(cf->file_rcs, kflag);
	}

	if (logstr != NULL) {
		if ((logmsg = strchr(logstr, ':')) == NULL) {
			cvs_log(LP_ERR, "missing log message");
			return;
		}

		*logmsg++ = '\0';
		if ((rev = rcsnum_parse(logstr)) == NULL) {
			cvs_log(LP_ERR, "`%s' bad revision number", logstr);
			return;
		}

		if (rcs_rev_setlog(cf->file_rcs, rev, logmsg) < 0) {
			cvs_log(LP_ERR, "failed to set logmsg for `%s' to `%s'",
			    logstr, logmsg);
			free(rev);
			return;
		}

		free(rev);
	}

	if (orange != NULL) {
		struct rcs_delta *rdp, *nrdp;
		char b[CVS_REV_BUFSZ];

		cvs_revision_select(cf->file_rcs, orange);
		for (rdp = TAILQ_FIRST(&(cf->file_rcs->rf_delta));
		    rdp != NULL; rdp = nrdp) {
			nrdp = TAILQ_NEXT(rdp, rd_list);

			/*
			 * Delete selected revisions.
			 */
			if (rdp->rd_flags & RCS_RD_SELECT) {
				rcsnum_tostr(rdp->rd_num, b, sizeof(b));
				if (verbosity > 0)
					cvs_printf("deleting revision %s\n", b);

				(void)rcs_rev_remove(cf->file_rcs, rdp->rd_num);
			}
		}
	}

	if (state != NULL) {
		if (staterevstr != NULL) {
			if ((rev = rcsnum_parse(staterevstr)) == NULL) {
				cvs_log(LP_ERR, "`%s' bad revision number",
				    staterevstr);
				return;
			}
		} else if (cf->file_rcs->rf_head != NULL) {
			rev = rcsnum_alloc();
			rcsnum_cpy(cf->file_rcs->rf_head, rev, 0);
		} else {
			cvs_log(LP_ERR, "head revision missing");
			return;
		}

		(void)rcs_state_set(cf->file_rcs, rev, state);

		free(rev);
	}

	if (lkmode != RCS_LOCK_INVAL)
		(void)rcs_lock_setmode(cf->file_rcs, lkmode);

	rcs_write(cf->file_rcs);

	if (verbosity > 0)
		cvs_printf("done\n");
}
@


1.66
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.65 2015/01/16 06:40:06 deraadt Exp $	*/
d337 1
a337 1
			rcsnum_free(rev);
d341 1
a341 1
		rcsnum_free(rev);
d383 1
a383 1
		rcsnum_free(rev);
@


1.65
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.64 2008/09/12 13:20:36 tobias Exp $	*/
d26 1
d308 2
a309 2
			xfree(rap->ra_name);
			xfree(rap);
@


1.64
log
@Be also very conservative about the supplied revision for state changes,
i.e. don't successfully parse "admin -s dead:1.1:1.1".

Changed global var logrev into function-specific all-purpose rev, too.

No objections xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.63 2008/06/20 16:32:06 tobias Exp $	*/
d20 1
a20 1
#include <sys/param.h>
d248 1
a248 1
		char *d, *f, fpath[MAXPATHLEN], repo[MAXPATHLEN];
d256 1
a256 1
		cvs_get_repository_path(d, repo, MAXPATHLEN);
d258 1
a258 1
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", repo, f);
d260 1
a260 1
		if (strlcat(fpath, RCS_FILE_EXT, MAXPATHLEN) >= MAXPATHLEN)
@


1.63
log
@admin is only allowed on files which have an entry in CVS/Entries.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.62 2008/06/14 04:34:08 tobias Exp $	*/
d53 1
a53 2
static char	*oldfilename, *orange, *state, *statestr;
static RCSNUM	*logrev;
d60 1
d184 10
d216 1
d328 1
a328 1
		if ((logrev = rcsnum_parse(logstr)) == NULL) {
d333 1
a333 1
		if (rcs_rev_setlog(cf->file_rcs, logrev, logmsg) < 0) {
d336 1
a336 1
			rcsnum_free(logrev);
d340 1
a340 1
		rcsnum_free(logrev);
d365 5
a369 11
	if (statestr != NULL) {
		struct cvs_argvector *sargv;

		sargv = cvs_strsplit(statestr, ":");
		if (sargv->argv[1] != NULL) {
			state = xstrdup(sargv->argv[0]);

			if ((logrev = rcsnum_parse(sargv->argv[1])) == NULL) {
				cvs_log(LP_ERR, "`%s' bad revision number", statestr);
				cvs_argv_destroy(sargv);
				xfree(state);
d373 2
a374 3
			state = xstrdup(statestr);
			logrev = rcsnum_alloc();
			rcsnum_cpy(cf->file_rcs->rf_head, logrev, 0);
a376 9
			cvs_argv_destroy(sargv);
			return;
		}

		if (rcs_state_check(state) < 0) {
			cvs_log(LP_ERR, "invalid state `%s'", state);
			cvs_argv_destroy(sargv);
			rcsnum_free(logrev);
			xfree(state);
d380 1
a380 1
		(void)rcs_state_set(cf->file_rcs, logrev, state);
d382 1
a382 3
		cvs_argv_destroy(sargv);
		rcsnum_free(logrev);
		xfree(state);
@


1.62
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.61 2008/06/13 17:15:13 joris Exp $	*/
d217 1
a217 1
	if (cf->file_status == FILE_UNKNOWN)
@


1.61
log
@pass the complete path to cvs_file_get_cf() instead of reconstructing
it again in that function.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.60 2008/06/11 01:43:35 joris Exp $	*/
d367 1
a367 1
		} else {
d371 4
@


1.60
log
@ofd is being closed in cvs_file_free(), no need to close it ourselfs
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.59 2008/05/22 15:45:01 tobias Exp $	*/
d257 1
a257 1
		ocf = cvs_file_get_cf(d, f, ofd, CVS_FILE, 0);
@


1.59
log
@expension -> expansion

ok joris, xsa (quite some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.58 2008/05/11 12:16:00 tobias Exp $	*/
a264 2

		(void)close(ofd);
@


1.58
log
@If "cvs admin" encountered an entry in CVS/Entries for a file which has no
(longer an) RCS file in CVSROOT, both -- GNU cvs and OpenCVS -- segfaulted.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.57 2008/03/09 03:14:52 joris Exp $	*/
d92 1
a92 1
				    "invalid RCS keyword expension mode");
@


1.57
log
@proper repository locking:
- all read operations now look for a lock, and wait if present but never
  try to lock the tree themselfs anymore.
- all write operations lock the tree where needed.
- commit locks all relevant directories before even attempting to start.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.56 2008/03/09 01:54:03 joris Exp $	*/
d222 5
@


1.56
log
@pass user_supplied to struct cvs_file so it can be used
in the callbacks to verify if this file was specified on the command line.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.55 2008/02/04 15:07:32 tobias Exp $	*/
d37 1
a37 1
	CVS_OP_ADMIN, CVS_USE_WDIR, "admin",
@


1.55
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.54 2008/01/31 21:52:48 tobias Exp $	*/
d252 1
a252 1
		ocf = cvs_file_get_cf(d, f, ofd, CVS_FILE);
@


1.54
log
@We have cvs_client_send_logmsg for transmission of log messages.

OK joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.53 2008/01/31 10:15:05 tobias Exp $	*/
a51 1
static int	 kflag = RCS_KWEXP_DEFAULT;
d301 1
a301 1
	if (koptstr != NULL) {
@


1.53
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.52 2007/09/22 16:01:22 joris Exp $	*/
d173 1
a173 1
			cvs_client_send_request("Argument -m%s", logstr);
@


1.52
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.51 2007/06/28 21:38:09 xsa Exp $	*/
d37 1
a37 1
	CVS_OP_ADMIN, 0, "admin",
@


1.51
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.50 2007/02/22 06:42:09 otto Exp $	*/
d210 1
a210 1
	cvs_file_classify(cf, NULL);
@


1.50
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.49 2007/02/17 18:23:43 xsa Exp $	*/
d332 1
a332 1
		char b[16];
@


1.49
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.48 2007/02/09 03:49:15 joris Exp $	*/
d20 8
a27 1
#include "includes.h"
a29 1
#include "log.h"
@


1.48
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.47 2007/02/01 09:45:43 xsa Exp $	*/
d237 1
a237 2
		if (cvs_path_cat(repo, f, fpath, MAXPATHLEN) >= MAXPATHLEN)
			fatal("cvs_admin_local: truncation");
@


1.47
log
@add support for [-k mode]; tests/input/ok otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.46 2007/01/25 18:56:33 otto Exp $	*/
d204 1
a204 1
	cvs_file_classify(cf, NULL, 0);
@


1.46
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.45 2007/01/21 11:20:10 xsa Exp $	*/
d5 1
a5 1
 * Copyright (c) 2006 Xavier Santolaria <xsa@@openbsd.org>
d46 2
a47 1
static char	*alist, *comment, *elist, *logmsg, *logstr;
d83 7
d158 3
d294 7
@


1.45
log
@add support for the -A flag;
wrap some lines while there.
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.44 2007/01/11 02:35:55 joris Exp $	*/
d216 1
a216 1
		char *d, *f, *fpath, *repo;
a217 2
		fpath = xmalloc(MAXPATHLEN);
		repo = xmalloc(MAXPATHLEN);
a248 3

		xfree(fpath);
		xfree(repo);
@


1.44
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.43 2007/01/02 00:02:17 xsa Exp $	*/
d34 1
a34 1
	"[-ILqU] [A oldfile] [-a users] [-b branch]\n"
d46 2
a47 1
static char	*alist, *comment, *elist, *logmsg, *logstr, *orange, *state, *statestr;
d59 2
a60 1
	alist = comment = elist = logmsg = logstr = orange = state = statestr = NULL;
d65 1
d137 3
d211 44
@


1.43
log
@missing xfree()'s; spotted by joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.42 2007/01/01 23:49:06 xsa Exp $	*/
d131 1
@


1.42
log
@add support for [-s state[:rev]]
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.41 2006/12/31 15:38:11 xsa Exp $	*/
d292 2
@


1.41
log
@client-side bits might be useful too for -m...
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.40 2006/12/31 15:33:23 xsa Exp $	*/
d46 1
a46 1
static char	*alist, *comment, *elist, *logmsg, *logstr, *orange;
d58 1
a58 1
	alist = comment = elist = logmsg = logstr = orange = NULL;
d103 1
d154 3
d281 32
@


1.40
log
@add support for -m option.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.39 2006/11/13 12:51:58 xsa Exp $	*/
d146 3
@


1.39
log
@Run cvs_file_classify() so local mode works...
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.38 2006/11/13 11:50:11 xsa Exp $	*/
d46 2
a47 4
static char	*alist = NULL;
static char	*comment = NULL;
static char	*elist = NULL;
static char	*orange = NULL;
d58 2
d90 1
d230 22
@


1.38
log
@fix check on required arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.37 2006/11/13 11:04:19 xsa Exp $	*/
d153 1
d178 2
d195 1
a195 1
		cvs_printf("RCS file: %s\n", cf->file_path);
@


1.37
log
@Write rcs file when finished.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.36 2006/11/13 10:42:28 xsa Exp $	*/
d122 1
a122 1
	if (argc <= 1)
@


1.36
log
@Add support for [-a users] and [-o rev].
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.35 2006/11/13 10:24:30 xsa Exp $	*/
d252 2
@


1.35
log
@bring back basic admin command, mostly based on OpenRCS rcs(1).
not linked to build yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
d49 1
d65 1
d96 1
d131 3
d137 4
d146 3
d194 10
d226 22
@


1.34
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.33 2006/04/10 08:08:00 xsa Exp $	*/
d5 1
a5 1
 * All rights reserved.
d7 3
a9 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d11 7
a17 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d24 1
a24 5
#include "proto.h"


#define LOCK_SET	0x01
#define LOCK_REMOVE	0x02
d26 1
a26 4
#define FLAG_BRANCH		0x01
#define FLAG_DELUSER		0x02
#define FLAG_INTERACTIVE	0x04
#define FLAG_QUIET		0x08
d28 1
a28 4
static int	cvs_admin_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_admin_pre_exec(struct cvsroot *);
static int	cvs_admin_remote(CVSFILE *, void *);
static int	cvs_admin_local(CVSFILE *, void *);
d31 1
a31 1
	CVS_OP_ADMIN, CVS_REQ_ADMIN, "admin",
d34 6
a39 9
	"",
	"a:A:b::c:e::Ik:l::Lm:n:N:o:qs:t:u::U",
	NULL,
	CF_SORT | CF_IGNORE | CF_RECURSE,
	cvs_admin_init,
	cvs_admin_pre_exec,
	cvs_admin_remote,
	cvs_admin_local,
	NULL,
d41 1
a41 1
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2
d44 4
a47 8
static char *q, *Ntag, *ntag, *comment, *replace_msg;
static char *alist, *subst, *lockrev_arg, *unlockrev_arg;
static char *state, *userfile, *branch_arg, *elist, *range;
static int runflags, kflag, lockrev, lkmode;

/* flag as invalid */
static int kflag = RCS_KWEXP_ERR;
static int lkmode = RCS_LOCK_INVAL;
d49 2
a50 2
static int
cvs_admin_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d53 2
a54 1
	RCSNUM *rcs;
d56 1
a56 4
	runflags = lockrev = 0;
	Ntag = ntag = comment = replace_msg = NULL;
	state = alist = subst = elist = lockrev_arg = NULL;
	range = userfile = branch_arg = unlockrev_arg = NULL;
d58 1
a58 2
	/* option-o-rama ! */
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
d60 2
a62 4
			alist = optarg;
			break;
		case 'A':
			userfile = optarg;
a64 3
			runflags |= FLAG_BRANCH;
			if (optarg)
				branch_arg = optarg;
d70 2
a71 3
			runflags |= FLAG_DELUSER;
			if (optarg)
				elist = optarg;
a73 1
			runflags |= FLAG_INTERACTIVE;
d76 5
a80 7
			subst = optarg;
			kflag = rcs_kflag_get(subst);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				rcs_kflag_usage();
				return (CVS_EX_USAGE);
d82 1
a84 3
			lockrev |= LOCK_SET;
			if (optarg)
				lockrev_arg = optarg;
d86 1
a86 2
		case 'L':
			lkmode = RCS_LOCK_STRICT;
d88 1
a88 2
		case 'm':
			replace_msg = optarg;
a90 4
			ntag = optarg;
			break;
		case 'N':
			Ntag = optarg;
a92 1
			range = optarg;
d95 1
a95 1
			runflags |= FLAG_QUIET;
a97 1
			state = optarg;
a100 5
		case 'u':
			lockrev |= LOCK_REMOVE;
			if (optarg)
				unlockrev_arg = optarg;
			break;
d102 3
a104 3
			if (lkmode != RCS_LOCK_INVAL) {
				cvs_log(LP_ERR, "-L and -U are incompatible");
				return (CVS_EX_USAGE);
d108 2
d111 1
a111 1
			return (CVS_EX_USAGE);
d118 2
a119 42
	if (lockrev_arg != NULL) {
		if ((rcs = rcsnum_parse(lockrev_arg)) == NULL) {
			cvs_log(LP_ERR, "%s is not a numeric branch",
			    lockrev_arg);
			return (CVS_EX_USAGE);
		}
		rcsnum_free(rcs);
	}

	if (unlockrev_arg != NULL) {
		if ((rcs = rcsnum_parse(unlockrev_arg)) == NULL) {
			cvs_log(LP_ERR, "%s is not a numeric branch",
			    unlockrev_arg);
			return (CVS_EX_USAGE);
		}
		rcsnum_free(rcs);
	}

	if (replace_msg != NULL) {
		if ((q = strchr(replace_msg, ':')) == NULL) {
			cvs_log(LP_ERR, "invalid option for -m");
			return (CVS_EX_USAGE);
		}
		*q = '\0';
		if ((rcs = rcsnum_parse(replace_msg)) == NULL) {
			cvs_log(LP_ERR, "%s is not a numeric revision",
			    replace_msg);
			return (CVS_EX_USAGE);
		}
		rcsnum_free(rcs);
		*q = ':';
	}

	*arg = optind;
	return (0);
}

static int
cvs_admin_pre_exec(struct cvsroot *root)
{
	if (root->cr_method == CVS_METHOD_LOCAL)
		return (0);
d121 2
a122 4
	if (alist != NULL) {
		cvs_sendarg(root, "-a", 0);
		cvs_sendarg(root, alist, 0);
	}
d124 2
a125 10
	if (userfile != NULL) {
		cvs_sendarg(root, "-A", 0);
		cvs_sendarg(root, userfile, 0);
	}

	if (runflags & FLAG_BRANCH) {
		cvs_sendarg(root, "-b", 0);
		if (branch_arg != NULL)
			cvs_sendarg(root, branch_arg, 0);
	}
d127 2
a128 4
	if (comment != NULL) {
		cvs_sendarg(root, "-c", 0);
		cvs_sendarg(root, comment, 0);
	}
d130 4
a133 5
	if (runflags & FLAG_DELUSER)  {
		cvs_sendarg(root, "-e", 0);
		if (elist != NULL)
			cvs_sendarg(root, elist, 0);
	}
d135 2
a136 2
	if (runflags & FLAG_INTERACTIVE)
		cvs_sendarg(root, "-I", 0);
d138 2
a139 3
	if (subst != NULL) {
		cvs_sendarg(root, "-k", 0);
		cvs_sendarg(root, subst, 0);
d142 1
a142 5
	if (lockrev & LOCK_SET) {
		cvs_sendarg(root, "-l", 0);
		if (lockrev_arg != NULL)
			cvs_sendarg(root, lockrev_arg, 0);
	}
d144 1
a144 9
	if (lkmode == RCS_LOCK_STRICT)
		cvs_sendarg(root, "-L", 0);
	else if (lkmode == RCS_LOCK_LOOSE)
		cvs_sendarg(root, "-U", 0);

	if (replace_msg != NULL) {
		cvs_sendarg(root, "-m", 0);
		cvs_sendarg(root, replace_msg, 0);
	}
d146 5
a150 24
	if (ntag != NULL) {
		cvs_sendarg(root, "-n", 0);
		cvs_sendarg(root, ntag, 0);
	}

	if (Ntag != NULL) {
		cvs_sendarg(root, "-N", 0);
		cvs_sendarg(root, Ntag, 0);
	}

	if (range != NULL) {
		cvs_sendarg(root, "-o", 0);
		cvs_sendarg(root, range, 0);
	}

	if (state != NULL) {
		cvs_sendarg(root, "-s", 0);
		cvs_sendarg(root, state, 0);
	}

	if (lockrev & LOCK_REMOVE) {
		cvs_sendarg(root, "-u", 0);
		if (unlockrev_arg != NULL)
			cvs_sendarg(root, unlockrev_arg, 0);
d156 2
a157 7
/*
 * cvs_admin_remote()
 *
 * Perform admin commands on each file.
 */
static int
cvs_admin_remote(CVSFILE *cf, void *arg)
d159 1
a159 2
	char fpath[MAXPATHLEN];
	struct cvsroot *root;
d161 1
a161 1
	root = CVS_DIR_ROOT(cf);
d163 4
a166 6
	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		else
			cvs_senddir(root, cf);
		return (0);
d169 6
a174 16
	cvs_file_getpath(cf, fpath, sizeof(fpath));
	cvs_sendentry(root, cf);

	switch (cf->cf_cvstat) {
	case CVS_FST_UNKNOWN:
		cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		break;
	case CVS_FST_UPTODATE:
		cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
		break;
	case CVS_FST_MODIFIED:
		cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name);
		cvs_sendfile(root, fpath);
		break;
	default:
		break;
d177 2
a178 2
	return (0);
}
d180 2
a181 10
/*
 * cvs_admin_local()
 *
 * Perform administrative operations on a local RCS file.
 */
static int
cvs_admin_local(CVSFILE *cf, void *arg)
{
	char fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	RCSFILE *rf;
d183 2
a184 5
	if (cf->cf_type == DT_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Administrating %s", cf->cf_name);
		return (0);
	}
d186 3
a188 7
	if (cf->cf_cvstat == CVS_FST_UNKNOWN)
		return (0);
	else if (cf->cf_cvstat == CVS_FST_ADDED) {
		cvs_log(LP_WARN, "cannot admin newly added file `%s'",
		    cf->cf_name);
		return (0);
	}
d190 3
a192 2
	cvs_file_getpath(cf, fpath, sizeof(fpath));
	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));
d194 9
a202 8
	if ((rf = rcs_open(rcspath, RCS_RDWR)) == NULL)
		fatal("cvs_admin_local: rcs_open `%s': %s", rcspath,
		    rcs_errstr(rcs_errno));

	if (!(runflags & FLAG_QUIET))
		cvs_printf("RCS file: %s\n", rcspath);

	rcs_kwexp_set(rf, kflag);
d205 1
a205 3
		rcs_lock_setmode(rf, lkmode);

	rcs_close(rf);
d207 1
a207 1
	if (!(runflags & FLAG_QUIET))
a208 2

	return (0);
@


1.33
log
@change rcs_kwexp_set() return type to void and simplify its use. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.32 2006/04/01 20:11:25 joris Exp $	*/
@


1.32
log
@fix some bugs that lint discovered for us.
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.31 2006/03/24 13:34:27 ray Exp $	*/
d368 2
a369 2
	if (!RCS_KWEXP_INVAL(kflag))
		rcs_kwexp_set(rf, kflag);
@


1.31
log
@Remove unused variables, better integer types, prevent fallthroughs.
Found by lint.

Compare char * variables against NULL for consistency and add
parentheses around complicated comparisons, suggested by xsa@@.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.30 2006/03/16 09:06:19 xsa Exp $	*/
a340 1
	int ret;
d369 1
a369 1
		ret = rcs_kwexp_set(rf, kflag);
d371 1
a371 1
		ret = rcs_lock_setmode(rf, lkmode);
@


1.30
log
@zap more unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.29 2006/02/01 08:33:18 xsa Exp $	*/
d325 1
@


1.29
log
@cannot admin newly added file.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.28 2006/01/30 17:58:47 xsa Exp $	*/
d299 1
a299 1
	char *repo, fpath[MAXPATHLEN];
a302 1
	repo = CVS_DIR_REPO(cf);
@


1.28
log
@strerror() -> rcs_errstr() when passing rcs_errno as argument;
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.27 2006/01/27 15:26:38 xsa Exp $	*/
d351 5
a355 3
	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		if (verbosity > 1)
			cvs_log(LP_WARN, "nothing known about %s", cf->cf_name);
a359 1

d366 3
d375 3
@


1.27
log
@more errors handling cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.26 2006/01/02 08:11:56 xsa Exp $	*/
d363 1
a363 1
		    strerror(rcs_errno));
@


1.26
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.25 2005/12/30 02:03:28 joris Exp $	*/
d361 3
a363 3
	rf = rcs_open(rcspath, RCS_RDWR);
	if (rf == NULL)
		return (CVS_EX_DATA);
@


1.25
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.24 2005/12/22 14:59:54 xsa Exp $	*/
d28 1
a28 9
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.24
log
@cvs_rcs_getpath() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.23 2005/07/27 16:42:19 xsa Exp $	*/
d219 9
a227 7
	if ((alist != NULL) && ((cvs_sendarg(root, "-a", 0) < 0) ||
	    (cvs_sendarg(root, alist, 0) < 0)))
		return (CVS_EX_PROTO);

	if ((userfile != NULL) && ((cvs_sendarg(root, "-A", 0) < 0) ||
	    (cvs_sendarg(root, userfile, 0) < 0)))
		return (CVS_EX_PROTO);
d230 3
a232 5
		if (cvs_sendarg(root, "-b", 0) < 0)
			return (CVS_EX_PROTO);
		if ((branch_arg != NULL) &&
		    (cvs_sendarg(root, branch_arg, 0) < 0))
			return (CVS_EX_PROTO);
d235 4
a238 3
	if ((comment != NULL) && ((cvs_sendarg(root, "-c", 0) < 0) ||
	    (cvs_sendarg(root, comment, 0) < 0)))
		return (CVS_EX_PROTO);
d241 11
a251 5
		if (cvs_sendarg(root, "-e", 0) < 0)
			return (CVS_EX_PROTO);
		if ((elist != NULL) &&
		    (cvs_sendarg(root, elist, 0) < 0))
			return (CVS_EX_PROTO);
d254 4
a257 3
	if (runflags & FLAG_INTERACTIVE) {
		if (cvs_sendarg(root, "-I", 0) < 0)
			return (CVS_EX_PROTO);
d260 9
a268 3
	if ((subst != NULL) && ((cvs_sendarg(root, "-k", 0) < 0) ||
	    (cvs_sendarg(root, subst, 0) < 0)))
		return (CVS_EX_PROTO);
d270 19
a288 32
	if (lockrev & LOCK_SET) {
		if (cvs_sendarg(root, "-l", 0) < 0)
			return (CVS_EX_PROTO);
		if ((lockrev_arg != NULL) &&
		    (cvs_sendarg(root, lockrev_arg, 0) < 0))
			return (CVS_EX_PROTO);
	}

	if ((lkmode == RCS_LOCK_STRICT) && (cvs_sendarg(root, "-L", 0) < 0))
		return (CVS_EX_PROTO);
	else if ((lkmode == RCS_LOCK_LOOSE) && (cvs_sendarg(root, "-U", 0) < 0))
		return (CVS_EX_PROTO);

	if ((replace_msg != NULL) && ((cvs_sendarg(root, "-m", 0) < 0)
	    || (cvs_sendarg(root, replace_msg, 0) < 0)))
		return (CVS_EX_PROTO);

	if ((ntag != NULL) && ((cvs_sendarg(root, "-n", 0) < 0) ||
	    (cvs_sendarg(root, ntag, 0) < 0)))
		return (CVS_EX_PROTO);

	if ((Ntag != NULL) && ((cvs_sendarg(root, "-N", 0) < 0) ||
	    (cvs_sendarg(root, Ntag, 0) < 0)))
		return (CVS_EX_PROTO);

	if ((range != NULL) && ((cvs_sendarg(root, "-o", 0) < 0) ||
	    (cvs_sendarg(root, range, 0) < 0)))
		return (CVS_EX_PROTO);

	if ((state != NULL) && ((cvs_sendarg(root, "-s", 0) < 0) ||
	    (cvs_sendarg(root, state, 0) < 0)))
		return (CVS_EX_PROTO);
d291 3
a293 5
		if (cvs_sendarg(root, "-u", 0) < 0)
			return (CVS_EX_PROTO);
		if ((unlockrev_arg != NULL) &&
		    (cvs_sendarg(root, unlockrev_arg, 0) < 0))
			return (CVS_EX_PROTO);
a306 1
	int ret;
a309 1
	ret = 0;
d315 1
a315 2
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    cf->cf_name);
d317 2
a318 5
			ret = cvs_senddir(root, cf);
		if (ret == -1)
			ret = CVS_EX_PROTO;

		return (ret);
d322 1
a322 3

	if (cvs_sendentry(root, cf) < 0)
		return (CVS_EX_PROTO);
d326 1
a326 1
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
d329 1
a329 1
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
d332 2
a333 3
		ret = cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name);
		if (ret == 0)
			ret = cvs_sendfile(root, fpath);
d338 1
a338 1
	return (ret);
@


1.23
log
@use LP_NOTICE instead of LP_INFO where appropriate;
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.22 2005/07/25 12:05:43 xsa Exp $	*/
d377 1
a377 2
	if (cvs_rcs_getpath(cf, rcspath, sizeof(rcspath)) == NULL)
		return (CVS_EX_DATA);
@


1.22
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.21 2005/07/18 07:22:23 xsa Exp $	*/
d365 1
a365 1
			cvs_log(LP_INFO, "Administrating %s", cf->cf_name);
@


1.21
log
@be consistent w/ warning messages (and handle -Q);
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.20 2005/07/14 06:50:50 xsa Exp $	*/
d51 4
a54 4
static int cvs_admin_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_admin_pre_exec (struct cvsroot *);
static int cvs_admin_remote   (CVSFILE *, void *);
static int cvs_admin_local    (CVSFILE *, void *);
@


1.20
log
@use cvs_rcs_getpath();
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.19 2005/07/11 08:32:36 xsa Exp $	*/
d370 2
a371 1
		cvs_log(LP_WARN, "I know nothing about %s", fpath);
@


1.19
log
@add info message;
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.18 2005/07/07 14:27:57 joris Exp $	*/
d359 2
a360 2
	int ret, len;
	char *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
a361 1
	struct cvsroot *root;
d376 2
a377 7
	len = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, cf->cf_name, RCS_FILE_EXT);
	if (len == -1 || len >= (int)sizeof(rcspath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rcspath);
		return (-1);
	}
@


1.18
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.17 2005/05/31 08:58:47 xsa Exp $	*/
d363 6
@


1.17
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.16 2005/05/25 10:23:57 jfb Exp $	*/
d219 1
a219 1
	if ((alist != NULL) && ((cvs_sendarg(root, "-a", 0) < 0) || 
@


1.16
log
@split cvs_admin_file() into the local and remote versions and do
some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.15 2005/05/24 04:12:25 jfb Exp $	*/
d32 1
a33 1
#include <fcntl.h>
d35 1
a36 1
#include <string.h>
a37 1
#include "rcs.h"
@


1.15
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.14 2005/05/20 20:00:53 joris Exp $	*/
d38 1
d54 2
a55 1
static int cvs_admin_file     (CVSFILE *, void *);
d67 2
a68 2
	cvs_admin_file,
	cvs_admin_file,
d77 5
a81 1
static int runflags, kflag, lockrev, strictlock;
d89 1
a89 1
	runflags = strictlock = lockrev = 0;
d135 1
a135 1
			strictlock |= LOCK_SET;
d163 5
a167 1
			strictlock |= LOCK_REMOVE;
a176 6
	/* do some sanity checking on the arguments */
	if ((strictlock & LOCK_SET) && (strictlock & LOCK_REMOVE)) {
		cvs_log(LP_ERR, "-L and -U are incompatible");
		return (CVS_EX_USAGE);
	}

d217 3
d265 3
a267 2
	if ((strictlock & LOCK_SET) &&
	    (cvs_sendarg(root, "-L", 0) < 0))
a297 4
	if ((strictlock & LOCK_REMOVE) &&
	    (cvs_sendarg(root, "-U", 0) < 0))
		return (CVS_EX_PROTO);

d302 1
a302 1
 * cvs_admin_file()
d307 1
a307 1
cvs_admin_file(CVSFILE *cfp, void *arg)
d309 2
a310 3
	int ret, l;
	char *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	RCSFILE *rf;
d314 2
a315 11
	rf = NULL;
	root = CVS_DIR_ROOT(cfp);
	repo = CVS_DIR_REPO(cfp);

	if (cfp->cf_type == DT_DIR) {
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cfp->cf_cvstat == CVS_FST_UNKNOWN)
				ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
				    CVS_FILE_NAME(cfp));
			else
				ret = cvs_senddir(root, cfp);
d317 8
a324 3
			if (ret == -1)
				ret = CVS_EX_PROTO;
		}
d329 1
a329 1
	cvs_file_getpath(cfp, fpath, sizeof(fpath));
d331 17
a347 4
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_sendentry(root, cfp) < 0) {
			return (CVS_EX_PROTO);
		}
d349 2
a350 17
		switch (cfp->cf_cvstat) {
		case CVS_FST_UNKNOWN:
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cfp));
			break;
		case CVS_FST_UPTODATE:
			ret = cvs_sendreq(root, CVS_REQ_UNCHANGED,
			    CVS_FILE_NAME(cfp));
			break;
		case CVS_FST_MODIFIED:
			ret = cvs_sendreq(root, CVS_REQ_MODIFIED,
			    CVS_FILE_NAME(cfp));
			if (ret == 0)
				ret = cvs_sendfile(root, fpath);
		default:
			break;
		}
d352 12
a363 7
		if (ret == -1)
			ret = CVS_EX_PROTO;
	} else {
		if (cfp->cf_cvstat == CVS_FST_UNKNOWN) {
			cvs_log(LP_WARN, "I know nothing about %s", fpath);
			return (0);
		}
d365 4
a368 7
		l = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
		    root->cr_dir, repo, CVS_FILE_NAME(cfp), RCS_FILE_EXT);
		if (l == -1 || l >= (int)sizeof(rcspath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", rcspath);
			return (CVS_EX_DATA);
		}
d370 1
a370 4
		rf = rcs_open(rcspath, RCS_READ);
		if (rf == NULL) {
			return (CVS_EX_DATA);
		}
d372 6
a377 1
		rcs_close(rf);
d380 12
a391 1
	return (ret);
@


1.14
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.13 2005/04/18 21:02:49 jfb Exp $	*/
d51 15
a65 7
int cvs_admin_options(char *, int, char **, int *);
int cvs_admin_sendflags(struct cvsroot *);
int cvs_admin_file(CVSFILE *, void *);

struct cvs_cmd_info cvs_admin = {
	cvs_admin_options,
	cvs_admin_sendflags,
d67 2
a68 3
	NULL, NULL,
	CF_SORT | CF_IGNORE | CF_RECURSE,
	CVS_REQ_ADMIN,
d77 2
a78 2
int
cvs_admin_options(char *opt, int argc, char **argv, int *arg)
d89 1
a89 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d210 2
a211 2
int
cvs_admin_sendflags(struct cvsroot *root)
d302 1
a302 1
int
@


1.13
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.12 2005/04/16 19:05:02 xsa Exp $	*/
d315 3
d347 3
d361 1
a361 1
			return (-1);
@


1.12
log
@snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.11 2005/04/12 14:58:40 joris Exp $	*/
a300 1
	struct cvs_ent *entp;
a320 1
	entp = cvs_ent_getent(fpath);
d323 1
a323 2
		if ((entp != NULL) && (cvs_sendentry(root, entp) < 0)) {
			cvs_ent_free(entp);
a354 2

			cvs_ent_free(entp);
a359 2
			if (entp != NULL)
				cvs_ent_free(entp);
a365 2
	if (entp != NULL)
		cvs_ent_free(entp);
@


1.11
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.10 2005/04/11 18:02:58 joris Exp $	*/
d298 1
a298 1
	int ret;
d353 1
a353 1
		snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
d355 7
@


1.10
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.9 2005/04/11 17:56:27 joris Exp $	*/
d113 1
a113 1
				return (1);
d153 1
a153 1
			return (1);
d163 1
a163 1
		return (-1);
d170 1
a170 1
			return (1);
d179 1
a179 1
			return (-1);
d187 1
a187 1
			return (1);
d193 1
a193 1
			return (-1);
d208 1
a208 1
		return (-1);
d212 1
a212 1
		return (-1);
d216 1
a216 1
			return (-1);
d219 1
a219 1
			return (-1);
d224 1
a224 1
		return (-1);
d228 1
a228 1
			return (-1);
d231 1
a231 1
			return (-1);
d236 1
a236 1
			return (-1);
d241 1
a241 1
		return (-1);
d245 1
a245 1
			return (-1);
d248 1
a248 1
			return (-1);
d253 1
a253 1
		return (-1);
d257 1
a257 1
		return (-1);
d261 1
a261 1
		return (-1);
d265 1
a265 1
		return (-1);
d269 1
a269 1
		return (-1);
d273 1
a273 1
		return (-1);
d277 1
a277 1
			return (-1);
d280 1
a280 1
			return (-1);
d285 1
a285 1
		return (-1);
d327 1
a327 1
			return (-1);
d360 1
a360 1
			return (-1);
@


1.9
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.8 2005/04/03 17:32:50 xsa Exp $	*/
a36 1
#include <sysexits.h>
@


1.8
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.7 2005/03/30 17:43:04 joris Exp $	*/
d114 1
a114 1
				return (EX_USAGE);
d154 1
a154 1
			return (EX_USAGE);
d171 1
a171 1
			return (EX_USAGE);
d188 1
a188 1
			return (EX_USAGE);
@


1.7
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.6 2005/03/26 08:09:54 tedu Exp $	*/
d164 1
a164 1
		return (EX_PROTOCOL);
d180 1
a180 1
			return (EX_PROTOCOL);
d194 1
a194 1
			return (EX_PROTOCOL);
d209 1
a209 1
		return (EX_PROTOCOL);
d213 1
a213 1
		return (EX_PROTOCOL);
d217 1
a217 1
			return (EX_PROTOCOL);
d220 1
a220 1
			return (EX_PROTOCOL);
d225 1
a225 1
		return (EX_PROTOCOL);
d229 1
a229 1
			return (EX_PROTOCOL);
d232 1
a232 1
			return (EX_PROTOCOL);
d237 1
a237 1
			return (EX_PROTOCOL);
d242 1
a242 1
		return (EX_PROTOCOL);
d246 1
a246 1
			return (EX_PROTOCOL);
d249 1
a249 1
			return (0);
d254 1
a254 1
		return (EX_PROTOCOL);
d258 1
a258 1
		return (EX_PROTOCOL);
d262 1
a262 1
		return (EX_PROTOCOL);
d266 1
a266 1
		return (EX_PROTOCOL);
d270 1
a270 1
		return (EX_PROTOCOL);
d274 1
a274 1
		return (EX_PROTOCOL);
d278 1
a278 1
			return (EX_PROTOCOL);
d281 1
a281 1
			return (EX_PROTOCOL);
d286 1
a286 1
		return (EX_PROTOCOL);
@


1.6
log
@fix a variety of things i found at coverity.  ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.5 2005/03/11 16:23:34 joris Exp $	*/
a43 2
int cvs_admin_file (CVSFILE *, void *);

d52 19
a70 6
/*
 * cvs_admin()
 *
 * Handler for the `cvs admin' command.
 * Returns 0 on success, or one of the known exit codes on error.
 */
d72 1
a72 1
cvs_admin(int argc, char **argv)
d74 1
a74 6
	int i, ch, flags;
	int runflags, kflag, lockrev, strictlock;
	char *q, *Ntag, *ntag, *comment, *replace_msg;
	char *alist, *subst, *lockrev_arg, *unlockrev_arg;
	char *state, *userfile, *branch_arg, *elist, *range;
	struct cvsroot *root;
a80 1
	flags = CF_SORT|CF_IGNORE|CF_RECURSE;
d83 1
a83 2
	while ((ch = getopt(argc, argv, "a:A:b::c:e::Ik:l::Lm:n:N:o:qs:t:u::U"))
	    != -1) {
d200 3
a202 7
	if (argc == 0) {
		cvs_files = cvs_file_get(".", flags);
	} else {
		cvs_files = cvs_file_getspec(argv, argc, 0);
	}
	if (cvs_files == NULL)
		return (EX_DATAERR);
d204 6
a209 8
	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
d211 3
a213 3
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_connect(root) < 0)
			return (EX_PROTOCOL);
d215 2
a216 2
		if ((alist != NULL) && ((cvs_sendarg(root, "-a", 0) < 0) || 
		    (cvs_sendarg(root, alist, 0) < 0)))
d218 2
a219 3

		if ((userfile != NULL) && ((cvs_sendarg(root, "-A", 0) < 0) ||
		    (cvs_sendarg(root, userfile, 0) < 0)))
d221 1
d223 3
a225 7
		if (runflags & FLAG_BRANCH) {
			if (cvs_sendarg(root, "-b", 0) < 0)
				return (EX_PROTOCOL);
			if ((branch_arg != NULL) &&
			    (cvs_sendarg(root, branch_arg, 0) < 0))
				return (EX_PROTOCOL);
		}
d227 2
a228 2
		if ((comment != NULL) && ((cvs_sendarg(root, "-c", 0) < 0) ||
		    (cvs_sendarg(root, comment, 0) < 0)))
d230 2
a231 16

		if (runflags & FLAG_DELUSER)  {
			if (cvs_sendarg(root, "-e", 0) < 0)
				return (EX_PROTOCOL);
			if ((elist != NULL) &&
			    (cvs_sendarg(root, elist, 0) < 0))
				return (EX_PROTOCOL);
		}

		if (runflags & FLAG_INTERACTIVE) {
			if (cvs_sendarg(root, "-I", 0) < 0)
				return (EX_PROTOCOL);
		}

		if ((subst != NULL) && ((cvs_sendarg(root, "-k", 0) < 0) ||
		    (cvs_sendarg(root, subst, 0) < 0)))
d233 1
d235 2
a236 10
		if (lockrev & LOCK_SET) {
			if (cvs_sendarg(root, "-l", 0) < 0)
				return (EX_PROTOCOL);
			if ((lockrev_arg != NULL) &&
			    (cvs_sendarg(root, lockrev_arg, 0) < 0))
				return (0);
		}

		if ((strictlock & LOCK_SET) &&
		    (cvs_sendarg(root, "-L", 0) < 0))
d238 1
d240 3
a242 3
		if ((replace_msg != NULL) && ((cvs_sendarg(root, "-m", 0) < 0)
		    || (cvs_sendarg(root, replace_msg, 0) < 0)))
			return (EX_PROTOCOL);
d244 2
a245 2
		if ((ntag != NULL) && ((cvs_sendarg(root, "-n", 0) < 0) ||
		    (cvs_sendarg(root, ntag, 0) < 0)))
d247 4
d252 3
a254 3
		if ((Ntag != NULL) && ((cvs_sendarg(root, "-N", 0) < 0) ||
		    (cvs_sendarg(root, Ntag, 0) < 0)))
			return (EX_PROTOCOL);
d256 3
a258 3
		if ((range != NULL) && ((cvs_sendarg(root, "-o", 0) < 0) ||
		    (cvs_sendarg(root, range, 0) < 0)))
			return (EX_PROTOCOL);
d260 3
a262 3
		if ((state != NULL) && ((cvs_sendarg(root, "-s", 0) < 0) ||
		    (cvs_sendarg(root, state, 0) < 0)))
			return (EX_PROTOCOL);
d264 3
a266 7
		if (lockrev & LOCK_REMOVE) {
			if (cvs_sendarg(root, "-u", 0) < 0)
				return (EX_PROTOCOL);
			if ((unlockrev_arg != NULL) &&
			    (cvs_sendarg(root, unlockrev_arg, 0) < 0))
				return (EX_PROTOCOL);
		}
d268 3
a270 4
		if ((strictlock & LOCK_REMOVE) &&
		    (cvs_sendarg(root, "-U", 0) < 0))
			return (EX_PROTOCOL);
	}
d272 3
a274 1
	cvs_file_examine(cvs_files, cvs_admin_file, NULL);
d276 2
a277 2
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0)
d279 2
a280 4
		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				return (EX_PROTOCOL);
		if (cvs_sendreq(root, CVS_REQ_ADMIN, NULL) < 0)
d284 4
a289 1

@


1.5
log
@

support the remaining options as well.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.4 2005/03/08 00:20:39 joris Exp $	*/
d383 2
a384 1
			cvs_ent_free(entp);
@


1.4
log
@

don't forget to send options to the server when they are specified.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.3 2005/03/07 19:41:07 joris Exp $	*/
d65 1
a65 2
	char *q;
	char *comment, *replace_msg;
d67 1
a67 1
	char *userfile, *branch_arg, *elist;
d72 3
a74 3
	comment = replace_msg = NULL;
	alist = subst = elist = lockrev_arg = NULL;
	userfile = branch_arg = unlockrev_arg = NULL;
d125 1
d128 1
d131 1
d137 1
d268 16
@


1.3
log
@

use rcs_kflag_get() and RCS_KWEXP_INVAL() to check for valid
RCS keyword expansion modes, also call rcs_kflag_usage()
when an invalid mode is specified.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.2 2005/03/07 16:25:48 joris Exp $	*/
d230 2
a231 1
		if ((comment != NULL) && (cvs_sendarg(root, comment, 0) < 0))
@


1.2
log
@

free rcs when we are done using it.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: admin.c,v 1.1 2005/03/06 21:09:00 joris Exp $	*/
d64 1
a64 2
	int runflags;
	int lockrev, strictlock;
d106 7
a175 8
	}

	if (subst != NULL) {
		if (strcmp(subst, "kv") && strcmp(subst, "kvl") && 
		    *subst != 'o' && *subst != 'b' && *subst != 'v') {
			cvs_log(LP_ERR, "invalid RCS keyword expansion mode");
			return (EX_USAGE);
		}
@


1.1
log
@

initial support for the admin command. Not all options are working yet.

ok xsa@@ jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.8 2005/02/27 00:22:08 jfb Exp $	*/
d191 1
@

