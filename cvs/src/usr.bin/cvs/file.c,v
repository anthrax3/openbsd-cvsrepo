head	1.273;
access;
symbols
	OPENBSD_6_2_BASE:1.273
	OPENBSD_6_1:1.269.0.4
	OPENBSD_6_1_BASE:1.269
	OPENBSD_6_0:1.267.0.4
	OPENBSD_6_0_BASE:1.267
	OPENBSD_5_9:1.267.0.2
	OPENBSD_5_9_BASE:1.267
	OPENBSD_5_8:1.265.0.6
	OPENBSD_5_8_BASE:1.265
	OPENBSD_5_7:1.265.0.2
	OPENBSD_5_7_BASE:1.265
	OPENBSD_5_6:1.263.0.6
	OPENBSD_5_6_BASE:1.263
	OPENBSD_5_5:1.263.0.4
	OPENBSD_5_5_BASE:1.263
	OPENBSD_5_4:1.262.0.12
	OPENBSD_5_4_BASE:1.262
	OPENBSD_5_3:1.262.0.10
	OPENBSD_5_3_BASE:1.262
	OPENBSD_5_2:1.262.0.8
	OPENBSD_5_2_BASE:1.262
	OPENBSD_5_1_BASE:1.262
	OPENBSD_5_1:1.262.0.6
	OPENBSD_5_0:1.262.0.4
	OPENBSD_5_0_BASE:1.262
	OPENBSD_4_9:1.262.0.2
	OPENBSD_4_9_BASE:1.262
	OPENBSD_4_8:1.260.0.2
	OPENBSD_4_8_BASE:1.260
	OPENBSD_4_7:1.258.0.2
	OPENBSD_4_7_BASE:1.258
	OPENBSD_4_6:1.258.0.4
	OPENBSD_4_6_BASE:1.258
	OPENBSD_4_5:1.253.0.2
	OPENBSD_4_5_BASE:1.253
	OPENBSD_4_4:1.249.0.2
	OPENBSD_4_4_BASE:1.249
	OPENBSD_4_3:1.226.0.2
	OPENBSD_4_3_BASE:1.226
	OPENBSD_4_2:1.194.0.2
	OPENBSD_4_2_BASE:1.194
	OPENBSD_4_1:1.189.0.2
	OPENBSD_4_1_BASE:1.189
	OPENBSD_4_0:1.162.0.2
	OPENBSD_4_0_BASE:1.162
	OPENBSD_3_9:1.134.0.2
	OPENBSD_3_9_BASE:1.134
	OPENBSD_3_8:1.116.0.2
	OPENBSD_3_8_BASE:1.116
	OPENBSD_3_7:1.56.0.2
	OPENBSD_3_7_BASE:1.56;
locks; strict;
comment	@ * @;


1.273
date	2017.06.01.08.38.56;	author joris;	state Exp;
branches;
next	1.272;
commitid	pNbeclyygFavCEuw;

1.272
date	2017.06.01.08.08.24;	author joris;	state Exp;
branches;
next	1.271;
commitid	oZyV6E3g0wglnhaw;

1.271
date	2017.05.29.17.18.56;	author joris;	state Exp;
branches;
next	1.270;
commitid	Vylfj0jmxC3phlRF;

1.270
date	2017.05.28.17.11.34;	author joris;	state Exp;
branches;
next	1.269;
commitid	Ik035Hw8ao9wPVwv;

1.269
date	2016.10.15.22.20.17;	author millert;	state Exp;
branches;
next	1.268;
commitid	bZGHsljlW6kmRYub;

1.268
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.267;
commitid	8Vv7d4HkmCtExfc6;

1.267
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.266;
commitid	O6jeJ0TRmiewrqMI;

1.266
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.265;
commitid	0Dp7Dy9FuNZesYo2;

1.265
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.264;
commitid	DTQbfd4poqBW8iSJ;

1.264
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.263;
commitid	Uu5nFG3wCl0LACBb;

1.263
date	2013.12.13.15.19.41;	author zhuk;	state Exp;
branches;
next	1.262;

1.262
date	2010.10.28.15.02.41;	author millert;	state Exp;
branches;
next	1.261;

1.261
date	2010.09.27.14.08.41;	author joshe;	state Exp;
branches;
next	1.260;

1.260
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.259;

1.259
date	2010.07.13.20.47.19;	author nicm;	state Exp;
branches;
next	1.258;

1.258
date	2009.03.28.16.47.33;	author joris;	state Exp;
branches;
next	1.257;

1.257
date	2009.03.26.22.54.37;	author joris;	state Exp;
branches;
next	1.256;

1.256
date	2009.03.25.21.50.33;	author joris;	state Exp;
branches;
next	1.255;

1.255
date	2009.03.24.18.33.25;	author joris;	state Exp;
branches;
next	1.254;

1.254
date	2009.03.19.09.53.16;	author joris;	state Exp;
branches;
next	1.253;

1.253
date	2009.02.21.18.26.47;	author joris;	state Exp;
branches;
next	1.252;

1.252
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.251;

1.251
date	2009.02.21.13.44.18;	author joris;	state Exp;
branches;
next	1.250;

1.250
date	2009.02.21.12.47.19;	author joris;	state Exp;
branches;
next	1.249;

1.249
date	2008.06.15.04.38.52;	author tobias;	state Exp;
branches;
next	1.248;

1.248
date	2008.06.14.03.58.29;	author tobias;	state Exp;
branches;
next	1.247;

1.247
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.246;

1.246
date	2008.06.13.17.15.13;	author joris;	state Exp;
branches;
next	1.245;

1.245
date	2008.06.12.16.54.46;	author joris;	state Exp;
branches;
next	1.244;

1.244
date	2008.06.12.07.29.54;	author joris;	state Exp;
branches;
next	1.243;

1.243
date	2008.06.12.07.16.14;	author joris;	state Exp;
branches;
next	1.242;

1.242
date	2008.06.09.22.31.24;	author tobias;	state Exp;
branches;
next	1.241;

1.241
date	2008.06.09.17.05.49;	author tobias;	state Exp;
branches;
next	1.240;

1.240
date	2008.06.08.13.34.22;	author tobias;	state Exp;
branches;
next	1.239;

1.239
date	2008.06.08.03.03.08;	author tobias;	state Exp;
branches;
next	1.238;

1.238
date	2008.06.08.02.52.24;	author tobias;	state Exp;
branches;
next	1.237;

1.237
date	2008.05.22.06.50.18;	author xsa;	state Exp;
branches;
next	1.236;

1.236
date	2008.03.13.17.06.09;	author joris;	state Exp;
branches;
next	1.235;

1.235
date	2008.03.09.18.02.17;	author joris;	state Exp;
branches;
next	1.234;

1.234
date	2008.03.09.03.14.52;	author joris;	state Exp;
branches;
next	1.233;

1.233
date	2008.03.09.03.06.56;	author joris;	state Exp;
branches;
next	1.232;

1.232
date	2008.03.09.02.30.42;	author tobias;	state Exp;
branches;
next	1.231;

1.231
date	2008.03.09.02.06.32;	author tobias;	state Exp;
branches;
next	1.230;

1.230
date	2008.03.09.01.54.03;	author joris;	state Exp;
branches;
next	1.229;

1.229
date	2008.03.09.01.25.31;	author joris;	state Exp;
branches;
next	1.228;

1.228
date	2008.03.09.01.02.38;	author tobias;	state Exp;
branches;
next	1.227;

1.227
date	2008.03.08.20.26.34;	author joris;	state Exp;
branches;
next	1.226;

1.226
date	2008.03.01.21.29.37;	author deraadt;	state Exp;
branches;
next	1.225;

1.225
date	2008.03.01.14.55.03;	author joris;	state Exp;
branches;
next	1.224;

1.224
date	2008.02.20.17.29.28;	author tobias;	state Exp;
branches;
next	1.223;

1.223
date	2008.02.20.09.16.32;	author joris;	state Exp;
branches;
next	1.222;

1.222
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.221;

1.221
date	2008.02.10.14.00.41;	author joris;	state Exp;
branches;
next	1.220;

1.220
date	2008.02.10.10.21.42;	author joris;	state Exp;
branches;
next	1.219;

1.219
date	2008.02.09.12.20.33;	author tobias;	state Exp;
branches;
next	1.218;

1.218
date	2008.02.09.11.17.02;	author tobias;	state Exp;
branches;
next	1.217;

1.217
date	2008.02.08.22.07.50;	author joris;	state Exp;
branches;
next	1.216;

1.216
date	2008.02.08.21.32.07;	author joris;	state Exp;
branches;
next	1.215;

1.215
date	2008.02.04.18.23.58;	author tobias;	state Exp;
branches;
next	1.214;

1.214
date	2008.02.03.22.50.28;	author joris;	state Exp;
branches;
next	1.213;

1.213
date	2008.02.03.15.08.04;	author tobias;	state Exp;
branches;
next	1.212;

1.212
date	2008.01.31.21.56.34;	author tobias;	state Exp;
branches;
next	1.211;

1.211
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.210;

1.210
date	2008.01.21.16.36.46;	author tobias;	state Exp;
branches;
next	1.209;

1.209
date	2008.01.10.11.21.34;	author tobias;	state Exp;
branches;
next	1.208;

1.208
date	2008.01.10.10.12.09;	author tobias;	state Exp;
branches;
next	1.207;

1.207
date	2008.01.10.10.09.27;	author tobias;	state Exp;
branches;
next	1.206;

1.206
date	2008.01.10.09.37.26;	author tobias;	state Exp;
branches;
next	1.205;

1.205
date	2007.11.09.16.21.24;	author tobias;	state Exp;
branches;
next	1.204;

1.204
date	2007.10.09.12.20.24;	author tobias;	state Exp;
branches;
next	1.203;

1.203
date	2007.10.05.19.28.23;	author gilles;	state Exp;
branches;
next	1.202;

1.202
date	2007.09.24.13.44.20;	author joris;	state Exp;
branches;
next	1.201;

1.201
date	2007.09.23.11.19.24;	author joris;	state Exp;
branches;
next	1.200;

1.200
date	2007.09.23.10.49.49;	author joris;	state Exp;
branches;
next	1.199;

1.199
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.198;

1.198
date	2007.09.22.15.57.24;	author joris;	state Exp;
branches;
next	1.197;

1.197
date	2007.09.17.10.07.21;	author tobias;	state Exp;
branches;
next	1.196;

1.196
date	2007.09.09.20.24.06;	author tobias;	state Exp;
branches;
next	1.195;

1.195
date	2007.09.07.23.30.30;	author tobias;	state Exp;
branches;
next	1.194;

1.194
date	2007.07.03.13.22.42;	author joris;	state Exp;
branches;
next	1.193;

1.193
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.192;

1.192
date	2007.06.26.02.24.10;	author niallo;	state Exp;
branches;
next	1.191;

1.191
date	2007.06.04.21.54.26;	author niallo;	state Exp;
branches;
next	1.190;

1.190
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.189;

1.189
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.188;

1.188
date	2007.02.21.04.18.45;	author ray;	state Exp;
branches;
next	1.187;

1.187
date	2007.02.19.11.40.00;	author otto;	state Exp;
branches;
next	1.186;

1.186
date	2007.02.09.16.46.26;	author joris;	state Exp;
branches;
next	1.185;

1.185
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.184;

1.184
date	2007.02.07.23.47.56;	author todd;	state Exp;
branches;
next	1.183;

1.183
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.182;

1.182
date	2007.01.29.15.47.39;	author joris;	state Exp;
branches;
next	1.181;

1.181
date	2007.01.28.03.03.35;	author joris;	state Exp;
branches;
next	1.180;

1.180
date	2007.01.28.02.04.45;	author joris;	state Exp;
branches;
next	1.179;

1.179
date	2007.01.27.20.21.25;	author joris;	state Exp;
branches;
next	1.178;

1.178
date	2007.01.27.20.02.33;	author joris;	state Exp;
branches;
next	1.177;

1.177
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.176;

1.176
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.175;

1.175
date	2007.01.23.01.53.38;	author ray;	state Exp;
branches;
next	1.174;

1.174
date	2007.01.20.17.02.36;	author joris;	state Exp;
branches;
next	1.173;

1.173
date	2007.01.20.01.31.03;	author joris;	state Exp;
branches;
next	1.172;

1.172
date	2007.01.20.00.58.19;	author niallo;	state Exp;
branches;
next	1.171;

1.171
date	2007.01.19.23.23.21;	author joris;	state Exp;
branches;
next	1.170;

1.170
date	2007.01.14.23.10.56;	author joris;	state Exp;
branches;
next	1.169;

1.169
date	2007.01.13.16.03.53;	author joris;	state Exp;
branches;
next	1.168;

1.168
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.167;

1.167
date	2007.01.12.19.28.12;	author joris;	state Exp;
branches;
next	1.166;

1.166
date	2007.01.10.21.32.19;	author xsa;	state Exp;
branches;
next	1.165;

1.165
date	2007.01.06.17.09.08;	author xsa;	state Exp;
branches;
next	1.164;

1.164
date	2007.01.05.07.13.49;	author xsa;	state Exp;
branches;
next	1.163;

1.163
date	2006.10.25.20.52.34;	author moritz;	state Exp;
branches;
next	1.162;

1.162
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.161;

1.161
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.160;

1.160
date	2006.06.14.20.28.53;	author joris;	state Exp;
branches;
next	1.159;

1.159
date	2006.06.14.14.10.50;	author joris;	state Exp;
branches;
next	1.158;

1.158
date	2006.06.03.19.07.13;	author joris;	state Exp;
branches;
next	1.157;

1.157
date	2006.06.02.19.10.23;	author david;	state Exp;
branches;
next	1.156;

1.156
date	2006.06.01.20.00.52;	author joris;	state Exp;
branches;
next	1.155;

1.155
date	2006.05.31.01.26.22;	author joris;	state Exp;
branches;
next	1.154;

1.154
date	2006.05.30.22.06.13;	author joris;	state Exp;
branches;
next	1.153;

1.153
date	2006.05.30.21.32.52;	author joris;	state Exp;
branches;
next	1.152;

1.152
date	2006.05.30.19.16.51;	author joris;	state Exp;
branches;
next	1.151;

1.151
date	2006.05.30.07.00.30;	author joris;	state Exp;
branches;
next	1.150;

1.150
date	2006.05.29.06.05.56;	author joris;	state Exp;
branches;
next	1.149;

1.149
date	2006.05.29.05.06.03;	author joris;	state Exp;
branches;
next	1.148;

1.148
date	2006.05.28.23.38.42;	author pedro;	state Exp;
branches;
next	1.147;

1.147
date	2006.05.28.21.11.12;	author joris;	state Exp;
branches;
next	1.146;

1.146
date	2006.05.28.17.25.18;	author joris;	state Exp;
branches;
next	1.145;

1.145
date	2006.05.28.10.14.59;	author joris;	state Exp;
branches;
next	1.144;

1.144
date	2006.05.28.08.49.01;	author joris;	state Exp;
branches;
next	1.143;

1.143
date	2006.05.28.07.56.44;	author joris;	state Exp;
branches;
next	1.142;

1.142
date	2006.05.27.20.56.39;	author joris;	state Exp;
branches;
next	1.141;

1.141
date	2006.05.27.15.15.43;	author joris;	state Exp;
branches;
next	1.140;

1.140
date	2006.05.27.15.14.27;	author joris;	state Exp;
branches;
next	1.139;

1.139
date	2006.05.27.06.15.50;	author joris;	state Exp;
branches;
next	1.138;

1.138
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.137;

1.137
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.135;

1.135
date	2006.04.02.02.02.27;	author joris;	state Exp;
branches;
next	1.134;

1.134
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.133;

1.133
date	2005.12.12.21.30.33;	author joris;	state Exp;
branches;
next	1.132;

1.132
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.131;

1.131
date	2005.12.04.17.39.02;	author joris;	state Exp;
branches;
next	1.130;

1.130
date	2005.12.03.15.07.21;	author joris;	state Exp;
branches;
next	1.129;

1.129
date	2005.12.03.02.19.17;	author joris;	state Exp;
branches;
next	1.128;

1.128
date	2005.12.03.01.02.08;	author joris;	state Exp;
branches;
next	1.127;

1.127
date	2005.11.12.21.34.48;	author niallo;	state Exp;
branches;
next	1.126;

1.126
date	2005.10.27.00.24.24;	author joris;	state Exp;
branches;
next	1.125;

1.125
date	2005.10.16.00.29.17;	author joris;	state Exp;
branches;
next	1.124;

1.124
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.123;

1.123
date	2005.09.15.22.12.23;	author joris;	state Exp;
branches;
next	1.122;

1.122
date	2005.09.15.17.01.10;	author xsa;	state Exp;
branches;
next	1.121;

1.121
date	2005.09.14.16.32.08;	author joris;	state Exp;
branches;
next	1.120;

1.120
date	2005.09.13.17.38.35;	author joris;	state Exp;
branches;
next	1.119;

1.119
date	2005.09.11.14.16.48;	author joris;	state Exp;
branches;
next	1.118;

1.118
date	2005.09.06.17.08.05;	author xsa;	state Exp;
branches;
next	1.117;

1.117
date	2005.09.06.15.29.33;	author joris;	state Exp;
branches;
next	1.116;

1.116
date	2005.08.19.13.36.50;	author joris;	state Exp;
branches;
next	1.115;

1.115
date	2005.08.17.16.23.19;	author joris;	state Exp;
branches;
next	1.114;

1.114
date	2005.08.17.08.35.53;	author xsa;	state Exp;
branches;
next	1.113;

1.113
date	2005.08.14.19.49.18;	author xsa;	state Exp;
branches;
next	1.112;

1.112
date	2005.08.11.11.54.42;	author xsa;	state Exp;
branches;
next	1.111;

1.111
date	2005.08.03.14.43.08;	author xsa;	state Exp;
branches;
next	1.110;

1.110
date	2005.07.30.21.16.17;	author moritz;	state Exp;
branches;
next	1.109;

1.109
date	2005.07.29.17.04.42;	author xsa;	state Exp;
branches;
next	1.108;

1.108
date	2005.07.29.13.56.00;	author joris;	state Exp;
branches;
next	1.107;

1.107
date	2005.07.29.00.33.55;	author joris;	state Exp;
branches;
next	1.106;

1.106
date	2005.07.27.10.36.14;	author xsa;	state Exp;
branches;
next	1.105;

1.105
date	2005.07.25.12.58.22;	author joris;	state Exp;
branches;
next	1.104;

1.104
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.103;

1.103
date	2005.07.24.19.04.55;	author joris;	state Exp;
branches;
next	1.102;

1.102
date	2005.07.24.18.54.47;	author joris;	state Exp;
branches;
next	1.101;

1.101
date	2005.07.24.18.34.13;	author joris;	state Exp;
branches;
next	1.100;

1.100
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.99;

1.99
date	2005.07.22.16.27.29;	author joris;	state Exp;
branches;
next	1.98;

1.98
date	2005.07.18.01.02.20;	author joris;	state Exp;
branches;
next	1.97;

1.97
date	2005.07.18.00.55.11;	author joris;	state Exp;
branches;
next	1.96;

1.96
date	2005.07.15.13.10.56;	author joris;	state Exp;
branches;
next	1.95;

1.95
date	2005.07.07.20.24.35;	author joris;	state Exp;
branches;
next	1.94;

1.94
date	2005.07.07.19.06.12;	author joris;	state Exp;
branches;
next	1.93;

1.93
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2005.07.05.16.55.30;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2005.07.01.08.59.09;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2005.06.17.15.09.55;	author joris;	state Exp;
branches;
next	1.89;

1.89
date	2005.06.17.14.58.23;	author joris;	state Exp;
branches;
next	1.88;

1.88
date	2005.06.14.15.27.31;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2005.06.09.01.45.45;	author joris;	state Exp;
branches;
next	1.86;

1.86
date	2005.06.01.16.49.20;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2005.06.01.15.46.32;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2005.06.01.14.03.14;	author joris;	state Exp;
branches;
next	1.83;

1.83
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.82;

1.82
date	2005.05.31.08.26.40;	author xsa;	state Exp;
branches;
next	1.81;

1.81
date	2005.05.28.01.34.28;	author joris;	state Exp;
branches;
next	1.80;

1.80
date	2005.05.25.09.42.12;	author jfb;	state Exp;
branches;
next	1.79;

1.79
date	2005.05.24.21.57.33;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2005.05.24.20.04.43;	author joris;	state Exp;
branches;
next	1.77;

1.77
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.76;

1.76
date	2005.05.22.17.47.53;	author joris;	state Exp;
branches;
next	1.75;

1.75
date	2005.05.20.17.23.18;	author joris;	state Exp;
branches;
next	1.74;

1.74
date	2005.05.20.05.25.44;	author joris;	state Exp;
branches;
next	1.73;

1.73
date	2005.05.20.05.13.44;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2005.05.20.05.01.34;	author jfb;	state Exp;
branches;
next	1.71;

1.71
date	2005.05.12.23.43.49;	author joris;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.12.23.35.42;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.01.23.21.39;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2005.04.25.21.58.32;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2005.04.22.15.16.15;	author joris;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.19.00.32.55;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.18.22.28.41;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.18.21.24.57;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2005.04.18.21.10.39;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.61;

1.61
date	2005.04.16.20.05.05;	author xsa;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.13.20.11.21;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.29.17.37.37;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.26.08.09.54;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.24.14.35.18;	author jfb;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.05.17.19.50;	author jfb;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.05.03.00.27;	author jfb;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.02.16.56.58;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.25.20.32.48;	author jfb;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.24.16.41.28;	author jfb;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.12.20.10.09;	author jfb;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.11.00.01.14;	author jfb;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.06.20.17.25;	author jfb;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.06.20.15.16;	author jfb;	state Exp;
branches;
next	1.47;

1.47
date	2005.01.03.22.53.06;	author jfb;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.28.20.00.14;	author jfb;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.28.19.44.17;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.14.21.23.44;	author jfb;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.13.19.38.22;	author jfb;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.08.19.54.11;	author jfb;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.08.19.44.28;	author jfb;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.07.18.14.04;	author jfb;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.06.07.28.15;	author jfb;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.03.20.19.54;	author jfb;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.02.06.54.15;	author jfb;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.31.11.17.02;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.27.15.43.15;	author jfb;	state Exp;
branches;
next	1.31;

1.31
date	2004.08.27.14.00.29;	author jfb;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.27.13.05.55;	author jfb;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.13.13.28.53;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.13.12.44.25;	author jfb;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.12.21.05.32;	author jfb;	state Exp;
branches;
next	1.26;

1.26
date	2004.08.12.18.36.39;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.10.14.23.57;	author jfb;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.06.20.12.15;	author jfb;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.06.14.55.56;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.06.14.12.56;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.06.12.09.25;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.03.04.41.19;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.03.04.28.15;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.03.04.27.30;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.02.22.49.49;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.02.13.54.01;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.31.01.13.41;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.30.17.39.27;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.30.11.50.33;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.29.17.51.06;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.29.17.31.23;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.29.16.59.39;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.29.15.41.57;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.27.17.15.00;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.27.16.56.10;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.27.12.01.58;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.26.15.58.01;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.25.03.18.52;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.23.05.40.32;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.16.03.08.26;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.14.03.33.09;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.273
log
@If CVS_LOCK_REPO is set only attempt to unlock the repo if we're local.

Otherwise we end up calling cvs_repository_unlock() with garbage from the
stack if we're dealing with a remote cvsroot.
@
text
@/*	$OpenBSD: file.c,v 1.272 2017/06/01 08:08:24 joris Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <fnmatch.h>
#include <libgen.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"
#include "cvs.h"
#include "remote.h"

#define CVS_IGN_STATIC	0x01	/* pattern is static, no need to glob */

#define CVS_CHAR_ISMETA(c)	((c == '*') || (c == '?') || (c == '['))

extern int print_stdout;
extern int build_dirs;

/*
 * Standard patterns to ignore.
 */
static const char *cvs_ign_std[] = {
	".",
	"..",
	"*.o",
	"*.a",
	"*.bak",
	"*.orig",
	"*.rej",
	"*.old",
	"*.exe",
	"*.depend",
	"*.obj",
	"*.elc",
	"*.ln",
	"*.olb",
	"CVS",
	"core",
	"cvslog*",
	"*.core",
	".#*",
	"*~",
	"_$*",
	"*$",
};

char *cvs_directory_tag = NULL;
struct ignore_head cvs_ign_pats;
struct ignore_head dir_ign_pats;
struct ignore_head checkout_ign_pats;

RB_GENERATE(cvs_flisthead, cvs_filelist, flist, cvs_filelist_cmp);

void
cvs_file_init(void)
{
	int i;
	FILE *ifp;
	char path[PATH_MAX], buf[MAXNAMLEN];

	TAILQ_INIT(&cvs_ign_pats);
	TAILQ_INIT(&dir_ign_pats);
	TAILQ_INIT(&checkout_ign_pats);

	/* standard patterns to ignore */
	for (i = 0; i < (int)(sizeof(cvs_ign_std)/sizeof(char *)); i++)
		cvs_file_ignore(cvs_ign_std[i], &cvs_ign_pats);

	if (cvs_homedir == NULL)
		return;

	/* read the cvsignore file in the user's home directory, if any */
	(void)xsnprintf(path, PATH_MAX, "%s/.cvsignore", cvs_homedir);

	ifp = fopen(path, "r");
	if (ifp == NULL) {
		if (errno != ENOENT)
			cvs_log(LP_ERRNO,
			    "failed to open user's cvsignore file `%s'", path);
	} else {
		while (fgets(buf, MAXNAMLEN, ifp) != NULL) {
			buf[strcspn(buf, "\n")] = '\0';
			if (buf[0] == '\0')
				continue;

			cvs_file_ignore(buf, &cvs_ign_pats);
		}

		(void)fclose(ifp);
	}
}

void
cvs_file_ignore(const char *pat, struct ignore_head *list)
{
	char *cp;
	size_t len;
	struct cvs_ignpat *ip;

	ip = xmalloc(sizeof(*ip));
	len = strlcpy(ip->ip_pat, pat, sizeof(ip->ip_pat));
	if (len >= sizeof(ip->ip_pat))
		fatal("cvs_file_ignore: truncation of pattern '%s'", pat);

	/* check if we will need globbing for that pattern */
	ip->ip_flags = CVS_IGN_STATIC;
	for (cp = ip->ip_pat; *cp != '\0'; cp++) {
		if (CVS_CHAR_ISMETA(*cp)) {
			ip->ip_flags &= ~CVS_IGN_STATIC;
			break;
		}
	}

	TAILQ_INSERT_TAIL(list, ip, ip_list);
}

int
cvs_file_chkign(const char *file)
{
	int flags;
	struct cvs_ignpat *ip;

	flags = FNM_PERIOD;
	if (cvs_nocase)
		flags |= FNM_CASEFOLD;

	TAILQ_FOREACH(ip, &cvs_ign_pats, ip_list) {
		if (ip->ip_flags & CVS_IGN_STATIC) {
			if (cvs_file_cmpname(file, ip->ip_pat) == 0)
				return (1);
		} else if (fnmatch(ip->ip_pat, file, flags) == 0)
			return (1);
	}

	TAILQ_FOREACH(ip, &dir_ign_pats, ip_list) {
		if (ip->ip_flags & CVS_IGN_STATIC) {
			if (cvs_file_cmpname(file, ip->ip_pat) == 0)
				return (1);
		} else if (fnmatch(ip->ip_pat, file, flags) == 0)
			return (1);
	}

	TAILQ_FOREACH(ip, &checkout_ign_pats, ip_list) {
		if (ip->ip_flags & CVS_IGN_STATIC) {
			if (cvs_file_cmpname(file, ip->ip_pat) == 0)
				return (1);
		} else if (fnmatch(ip->ip_pat, file, flags) == 0)
			return (1);
	}

	return (0);
}

void
cvs_file_run(int argc, char **argv, struct cvs_recursion *cr)
{
	int i;
	struct cvs_flisthead fl;

	RB_INIT(&fl);

	for (i = 0; i < argc; i++) {
		STRIP_SLASH(argv[i]);
		cvs_file_get(argv[i], FILE_USER_SUPPLIED, &fl, 0);
	}

	cvs_file_walklist(&fl, cr);
	cvs_file_freelist(&fl);
}

struct cvs_filelist *
cvs_file_get(char *name, int flags, struct cvs_flisthead *fl, int type)
{
	char *p;
	struct cvs_filelist *l, find;

	for (p = name; p[0] == '.' && p[1] == '/';)
		p += 2;

	find.file_path = p;
	l = RB_FIND(cvs_flisthead, fl, &find);
	if (l != NULL)
		return (l);

	l = xmalloc(sizeof(*l));
	l->file_path = xstrdup(p);
	l->flags = flags;
	l->type = type;

	RB_INSERT(cvs_flisthead, fl, l);
	return (l);
}

struct cvs_file *
cvs_file_get_cf(const char *d, const char *f, const char *fpath, int fd,
	int type, int flags)
{
	const char *p;
	struct cvs_file *cf;

	for (p = fpath; p[0] == '.' && p[1] == '/';)
		p += 2;

	cf = xcalloc(1, sizeof(*cf));

	cf->file_name = xstrdup(f);
	cf->file_wd = xstrdup(d);
	cf->file_path = xstrdup(p);
	cf->fd = fd;
	cf->repo_fd = -1;
	cf->file_type = type;
	cf->file_status = 0;
	cf->file_flags = flags;
	cf->in_attic = 0;
	cf->file_ent = NULL;

	if (cf->fd != -1)
		cf->file_flags |= FILE_ON_DISK;

	if (cvsroot_is_remote() || cvs_server_active == 1)
		cvs_validate_directory(cf->file_path);

	return (cf);
}

void
cvs_file_walklist(struct cvs_flisthead *fl, struct cvs_recursion *cr)
{
	int fd, type;
	struct stat st;
	struct cvs_file *cf;
	struct cvs_filelist *l, *nxt;
	char *d, *f, repo[PATH_MAX], fpath[PATH_MAX];

	for (l = RB_MIN(cvs_flisthead, fl); l != NULL; l = nxt) {
		if (cvs_quit)
			fatal("received signal %d", sig_received);

		cvs_log(LP_TRACE, "cvs_file_walklist: element '%s'",
		    l->file_path);

		if ((f = basename(l->file_path)) == NULL)
			fatal("cvs_file_walklist: basename failed");
		if ((d = dirname(l->file_path)) == NULL)
			fatal("cvs_file_walklist: dirname failed");

		type = l->type;
		if ((fd = open(l->file_path, O_RDONLY)) != -1) {
			if (type == 0) {
				if (fstat(fd, &st) == -1) {
					cvs_log(LP_ERRNO, "%s", l->file_path);
					(void)close(fd);
					goto next;
				}

				if (S_ISDIR(st.st_mode))
					type = CVS_DIR;
				else if (S_ISREG(st.st_mode))
					type = CVS_FILE;
				else {
					cvs_log(LP_ERR,
					    "ignoring bad file type for %s",
					    l->file_path);
					(void)close(fd);
					goto next;
				}
			}
		} else if (cvsroot_is_local()) {
			/*
			 * During checkout -p, do not use any locally
			 * available directories.
			 */
			if ((cmdp->cmd_flags & CVS_USE_WDIR) &&
			    (cvs_cmdop != CVS_OP_CHECKOUT || !print_stdout))
				if (stat(d, &st) == -1) {
					cvs_log(LP_ERRNO, "%s", d);
					goto next;
				}

			cvs_get_repository_path(d, repo, PATH_MAX);
			(void)xsnprintf(fpath, PATH_MAX, "%s/%s",
			    repo, f);

			if ((fd = open(fpath, O_RDONLY)) == -1) {
				strlcat(fpath, RCS_FILE_EXT, PATH_MAX);
				fd = open(fpath, O_RDONLY);
			}

			if (fd != -1 && type == 0) {
				if (fstat(fd, &st) == -1)
					fatal("cvs_file_walklist: %s: %s",
					     fpath, strerror(errno));

				if (S_ISDIR(st.st_mode))
					type = CVS_DIR;
				else if (S_ISREG(st.st_mode))
					type = CVS_FILE;
				else {
					cvs_log(LP_ERR,
					    "ignoring bad file type for %s",
					    l->file_path);
					(void)close(fd);
					goto next;
				}

				/* this file is not in our working copy yet */
				(void)close(fd);
				fd = -1;
			} else if (fd != -1) {
				close(fd);
				fd = -1;
			}
		}

		cf = cvs_file_get_cf(d, f, l->file_path, fd, type, l->flags);
		if (cf->file_type == CVS_DIR) {
			cvs_file_walkdir(cf, cr);
		} else {
			if (l->flags & FILE_USER_SUPPLIED) {
				cvs_parse_tagfile(cf->file_wd,
				    &cvs_directory_tag, NULL, NULL);

				if (cvs_directory_tag == NULL &&
				    cvs_specified_tag != NULL)
					cvs_directory_tag =
					    xstrdup(cvs_specified_tag);

				if (cvsroot_is_local()) {
					cvs_get_repository_path(cf->file_wd,
					    repo, PATH_MAX);
					cvs_repository_lock(repo,
					    (cmdp->cmd_flags & CVS_LOCK_REPO));
				}
			}

			if (cr->fileproc != NULL)
				cr->fileproc(cf);

			if (l->flags & FILE_USER_SUPPLIED) {
				if (cvsroot_is_local() &&
				    (cmdp->cmd_flags & CVS_LOCK_REPO)) {
					cvs_repository_unlock(repo);
				}
				free(cvs_directory_tag);
				cvs_directory_tag = NULL;
			}
		}

		cvs_file_free(cf);

next:
		nxt = RB_NEXT(cvs_flisthead, fl, l);
	}
}

void
cvs_file_walkdir(struct cvs_file *cf, struct cvs_recursion *cr)
{
	int l, type;
	FILE *fp;
	int nbytes;
	size_t bufsize;
	struct stat st;
	struct dirent *dp;
	struct cvs_ent *ent;
	struct cvs_ignpat *ip;
	struct cvs_ent_line *line;
	struct cvs_flisthead fl, dl;
	CVSENTRIES *entlist;
	char *buf, *ebuf, *cp, repo[PATH_MAX], fpath[PATH_MAX];

	cvs_log(LP_TRACE, "cvs_file_walkdir(%s)", cf->file_path);

	if (cr->enterdir != NULL)
		cr->enterdir(cf);

	if (cr->fileproc != NULL)
		cr->fileproc(cf);

	if (cf->file_status == FILE_SKIP)
		return;

	/*
	 * If this is a repository-only command, do not touch any
	 * locally available directories or try to create them.
	 */
	if (!(cmdp->cmd_flags & CVS_USE_WDIR)) {
		RB_INIT(&fl);
		RB_INIT(&dl);
		goto walkrepo;
	}

	/*
	 * If we do not have an admin directory inside here, dont bother,
	 * unless we are running export or import.
	 */
	(void)xsnprintf(fpath, PATH_MAX, "%s/%s", cf->file_path,
	    CVS_PATH_CVSDIR);

	l = stat(fpath, &st);
	if (cvs_cmdop != CVS_OP_EXPORT && cvs_cmdop != CVS_OP_IMPORT &&
	    (l == -1 || (l == 0 && !S_ISDIR(st.st_mode)))) {
		return;
	}

	cvs_parse_tagfile(cf->file_path, &cvs_directory_tag, NULL, NULL);

	/*
	 * check for a local .cvsignore file
	 */
	(void)xsnprintf(fpath, PATH_MAX, "%s/.cvsignore", cf->file_path);

	if ((fp = fopen(fpath, "r")) != NULL) {
		while (fgets(fpath, PATH_MAX, fp) != NULL) {
			fpath[strcspn(fpath, "\n")] = '\0';
			if (fpath[0] == '\0')
				continue;

			cvs_file_ignore(fpath, &dir_ign_pats);
		}

		(void)fclose(fp);
	}

	if (fstat(cf->fd, &st) == -1)
		fatal("cvs_file_walkdir: %s %s", cf->file_path,
		    strerror(errno));

	if ((uintmax_t)st.st_size > SIZE_MAX)
		fatal("cvs_file_walkdir: %s: file size too big", cf->file_name);

	bufsize = (st.st_size > st.st_blksize) ? st.st_size : st.st_blksize;

	buf = xmalloc(bufsize);
	RB_INIT(&fl);
	RB_INIT(&dl);

	while ((nbytes = getdents(cf->fd, buf, bufsize)) > 0) {
		ebuf = buf + nbytes;
		cp = buf;

		while (cp < ebuf) {
			dp = (struct dirent *)cp;
			if (!strcmp(dp->d_name, ".") ||
			    !strcmp(dp->d_name, "..") ||
			    !strcmp(dp->d_name, CVS_PATH_CVSDIR) ||
			    dp->d_fileno == 0) {
				cp += dp->d_reclen;
				continue;
			}

			(void)xsnprintf(fpath, PATH_MAX, "%s/%s",
			    cf->file_path, dp->d_name);

			if (cvs_file_chkign(dp->d_name) &&
			    cvs_cmdop != CVS_OP_RLOG &&
			    cvs_cmdop != CVS_OP_RTAG) {
				if (cvs_cmdop == CVS_OP_IMPORT)
					cvs_import_ignored(fpath);
				cp += dp->d_reclen;
				continue;
			}

			/*
			 * nfs and afs will show d_type as DT_UNKNOWN
			 * for files and/or directories so when we encounter
			 * this we call lstat() on the path to be sure.
			 */
			if (dp->d_type == DT_UNKNOWN) {
				if (lstat(fpath, &st) == -1)
					fatal("'%s': %s", fpath,
					    strerror(errno));

				switch (st.st_mode & S_IFMT) {
				case S_IFDIR:
					type = CVS_DIR;
					break;
				case S_IFREG:
					type = CVS_FILE;
					break;
				default:
					type = FILE_SKIP;
					break;
				}
			} else {
				switch (dp->d_type) {
				case DT_DIR:
					type = CVS_DIR;
					break;
				case DT_REG:
					type = CVS_FILE;
					break;
				default:
					type = FILE_SKIP;
					break;
				}
			}

			if (type == FILE_SKIP) {
				if (verbosity > 1) {
					cvs_log(LP_NOTICE, "ignoring `%s'",
					    dp->d_name);
				}
				cp += dp->d_reclen;
				continue;
			}

			switch (type) {
			case CVS_DIR:
				if (cr->flags & CR_RECURSE_DIRS)
					cvs_file_get(fpath, 0, &dl, CVS_DIR);
				break;
			case CVS_FILE:
				cvs_file_get(fpath, 0, &fl, CVS_FILE);
				break;
			default:
				fatal("type %d unknown, shouldn't happen",
				    type);
			}

			cp += dp->d_reclen;
		}
	}

	if (nbytes == -1)
		fatal("cvs_file_walkdir: %s %s", cf->file_path,
		    strerror(errno));

	free(buf);

	while ((ip = TAILQ_FIRST(&dir_ign_pats)) != NULL) {
		TAILQ_REMOVE(&dir_ign_pats, ip, ip_list);
		free(ip);
	}

	entlist = cvs_ent_open(cf->file_path);
	TAILQ_FOREACH(line, &(entlist->cef_ent), entries_list) {
		ent = cvs_ent_parse(line->buf);

		(void)xsnprintf(fpath, PATH_MAX, "%s/%s", cf->file_path,
		    ent->ce_name);

		if (!(cr->flags & CR_RECURSE_DIRS) &&
		    ent->ce_type == CVS_ENT_DIR)
			continue;
		if (ent->ce_type == CVS_ENT_DIR)
			cvs_file_get(fpath, 0, &dl, CVS_DIR);
		else if (ent->ce_type == CVS_ENT_FILE)
			cvs_file_get(fpath, 0, &fl, CVS_FILE);

		cvs_ent_free(ent);
	}

walkrepo:
	if (cvsroot_is_local()) {
		cvs_get_repository_path(cf->file_path, repo, PATH_MAX);
		cvs_repository_lock(repo, (cmdp->cmd_flags & CVS_LOCK_REPO));
	}

	if (cr->flags & CR_REPO) {
		xsnprintf(fpath, sizeof(fpath), "%s/%s", cf->file_path,
		    CVS_PATH_STATICENTRIES);

		if (!(cmdp->cmd_flags & CVS_USE_WDIR) ||
		    stat(fpath, &st) == -1 || build_dirs == 1)
			cvs_repository_getdir(repo, cf->file_path, &fl, &dl,
			    (cr->flags & CR_RECURSE_DIRS) ?
			    REPOSITORY_DODIRS : 0);
	}

	cvs_file_walklist(&fl, cr);
	cvs_file_freelist(&fl);

	if (cvsroot_is_local() && (cmdp->cmd_flags & CVS_LOCK_REPO))
		cvs_repository_unlock(repo);

	if (cvs_directory_tag != NULL && cmdp->cmd_flags & CVS_USE_WDIR) {
		cvs_write_tagfile(cf->file_path, cvs_directory_tag, NULL);
		free(cvs_directory_tag);
		cvs_directory_tag = NULL;
	}

	cvs_file_walklist(&dl, cr);
	cvs_file_freelist(&dl);

	if (cr->leavedir != NULL)
		cr->leavedir(cf);
}

void
cvs_file_freelist(struct cvs_flisthead *fl)
{
	struct cvs_filelist *f, *nxt;

	for (f = RB_MIN(cvs_flisthead, fl); f != NULL; f = nxt) {
		nxt = RB_NEXT(cvs_flisthead, fl, f);
		RB_REMOVE(cvs_flisthead, fl, f);
		free(f->file_path);
		free(f);
	}
}

void
cvs_file_classify(struct cvs_file *cf, const char *tag)
{
	size_t len;
	struct stat st;
	BUF *b1, *b2;
	int server_has_file, notag;
	int rflags, ismodified, rcsdead;
	CVSENTRIES *entlist = NULL;
	const char *state;
	char repo[PATH_MAX], rcsfile[PATH_MAX];

	cvs_log(LP_TRACE, "cvs_file_classify(%s, %s)", cf->file_path,
	    (tag != NULL) ? tag : "none");

	if (!strcmp(cf->file_path, ".")) {
		cf->file_status = FILE_UPTODATE;
		return;
	}

	cvs_get_repository_path(cf->file_wd, repo, PATH_MAX);
	(void)xsnprintf(rcsfile, PATH_MAX, "%s/%s",
	    repo, cf->file_name);

	if (cf->file_type == CVS_FILE) {
		len = strlcat(rcsfile, RCS_FILE_EXT, PATH_MAX);
		if (len >= PATH_MAX)
			fatal("cvs_file_classify: truncation");
	}

	cf->file_rpath = xstrdup(rcsfile);

	if (cmdp->cmd_flags & CVS_USE_WDIR) {
		entlist = cvs_ent_open(cf->file_wd);
		cf->file_ent = cvs_ent_get(entlist, cf->file_name);
	} else
		cf->file_ent = NULL;

	if (cf->file_ent != NULL) {
		if (cvs_specified_tag == NULL)
			tag = cf->file_ent->ce_tag;

		if (cf->file_flags & FILE_ON_DISK &&
		    cf->file_ent->ce_type == CVS_ENT_FILE &&
		    cf->file_type == CVS_DIR && tag != NULL) {
			cf->file_status = FILE_SKIP;
			return;
		}

		if (cf->file_flags & FILE_ON_DISK &&
		    cf->file_ent->ce_type == CVS_ENT_DIR &&
		    cf->file_type == CVS_FILE && tag != NULL) {
			cf->file_status = FILE_SKIP;
			return;
		}

		if (cf->file_flags & FILE_INSIDE_ATTIC &&
		    cf->file_ent->ce_type == CVS_ENT_DIR &&
		    cf->file_type != CVS_DIR) {
			cf->file_status = FILE_SKIP;
			return;
		}

		if (cf->file_flags & FILE_ON_DISK &&
		    cf->file_ent->ce_type == CVS_ENT_DIR &&
		    cf->file_type != CVS_DIR)
			fatal("%s is supposed to be a directory, but it is not",
			    cf->file_path);
		if (cf->file_flags & FILE_ON_DISK &&
		    cf->file_ent->ce_type == CVS_ENT_FILE &&
		    cf->file_type != CVS_FILE)
			fatal("%s is supposed to be a file, but it is not",
			    cf->file_path);
	}

	if (cf->file_type == CVS_DIR) {
		if (!(cmdp->cmd_flags & CVS_USE_WDIR))
			cf->file_status = FILE_UPTODATE;
		else if (cf->fd == -1 && stat(rcsfile, &st) != -1)
			cf->file_status = DIR_CREATE;
		else if (cf->file_ent != NULL || cvs_cmdop == CVS_OP_RLOG ||
		    cvs_cmdop == CVS_OP_RTAG)
			cf->file_status = FILE_UPTODATE;
		else
			cf->file_status = FILE_UNKNOWN;

		return;
	}

	rflags = RCS_READ;
	switch (cvs_cmdop) {
	case CVS_OP_COMMIT:
	case CVS_OP_TAG:
	case CVS_OP_RTAG:
		rflags = RCS_WRITE;
		break;
	case CVS_OP_ADMIN:
	case CVS_OP_IMPORT:
	case CVS_OP_LOG:
	case CVS_OP_RLOG:
		rflags |= RCS_PARSE_FULLY;
		break;
	default:
		break;
	}

	cf->repo_fd = open(cf->file_rpath, O_RDONLY);
	if (cf->repo_fd != -1) {
		cf->file_rcs = rcs_open(cf->file_rpath, cf->repo_fd, rflags);
		if (cf->file_rcs == NULL)
			fatal("cvs_file_classify: failed to parse RCS");
	} else {
		(void)xsnprintf(rcsfile, PATH_MAX, "%s/%s/%s%s",
		     repo, CVS_PATH_ATTIC, cf->file_name, RCS_FILE_EXT);

		cf->repo_fd = open(rcsfile, O_RDONLY);
		if (cf->repo_fd != -1) {
			free(cf->file_rpath);
			cf->file_rpath = xstrdup(rcsfile);
			cf->file_rcs = rcs_open(cf->file_rpath,
			    cf->repo_fd, rflags);
			if (cf->file_rcs == NULL)
				fatal("cvs_file_classify: failed to parse RCS");
			cf->in_attic = 1;
		} else {
			cf->file_rcs = NULL;
		}
	}

	notag = 0;
	cf->file_flags |= FILE_HAS_TAG;
	if (tag != NULL && cf->file_rcs != NULL) {
		if ((cf->file_rcsrev = rcs_translate_tag(tag, cf->file_rcs))
		    == NULL) {
			cf->file_rcsrev = rcs_translate_tag(NULL, cf->file_rcs);
			if (cf->file_rcsrev != NULL) {
				notag = 1;
				cf->file_flags &= ~FILE_HAS_TAG;
			}
		}
	} else if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL) {
		cf->file_rcsrev = rcsnum_alloc();
		rcsnum_cpy(cf->file_ent->ce_rev, cf->file_rcsrev, 0);
	} else if (cf->file_rcs != NULL) {
		cf->file_rcsrev = rcs_translate_tag(NULL, cf->file_rcs);
	} else {
		cf->file_rcsrev = NULL;
	}

	ismodified = rcsdead = 0;
	if ((cf->file_flags & FILE_ON_DISK) && cf->file_ent != NULL) {
		if (fstat(cf->fd, &st) == -1)
			fatal("cvs_file_classify: %s", strerror(errno));

		if (st.st_mtime != cf->file_ent->ce_mtime)
			ismodified = 1;
	}

	server_has_file = 0;
	if (cvs_server_active == 1 && cf->file_ent != NULL &&
	    cf->file_ent->ce_mtime == CVS_SERVER_UPTODATE) {
		server_has_file = 1;
		ismodified = 0;
	}

	if ((server_has_file == 1) || (cf->fd != -1))
		cf->file_flags |= FILE_ON_DISK;

	if (ismodified == 1 &&
	    (cf->file_flags & FILE_ON_DISK) && cf->file_rcs != NULL &&
	    cf->file_ent != NULL && !RCSNUM_ISBRANCH(cf->file_ent->ce_rev) &&
	    cf->file_ent->ce_status != CVS_ENT_ADDED) {
		b1 = rcs_rev_getbuf(cf->file_rcs, cf->file_ent->ce_rev, 0);
		b2 = buf_load_fd(cf->fd);

		if (buf_differ(b1, b2))
			ismodified = 1;
		else
			ismodified = 0;
		buf_free(b1);
		buf_free(b2);
	}

	if (cf->file_rcs != NULL && cf->file_rcsrev != NULL &&
	    !RCSNUM_ISBRANCH(cf->file_rcsrev)) {
		state = rcs_state_get(cf->file_rcs, cf->file_rcsrev);
		if (state == NULL)
			fatal("failed to get state for HEAD for %s",
			    cf->file_path);
		if (!strcmp(state, RCS_STATE_DEAD))
			rcsdead = 1;

		if (cvs_specified_date == -1 && cvs_directory_date == -1 &&
		    tag == NULL && cf->in_attic &&
		    !RCSNUM_ISBRANCHREV(cf->file_rcsrev))
			rcsdead = 1;

		cf->file_rcs->rf_dead = rcsdead;
	}

	/*
	 * 10 Sin
	 * 20 Goto hell
	 * (I welcome you if-else hell)
	 */
	if (cf->file_ent == NULL) {
		if (cf->file_rcs == NULL) {
			if (!(cf->file_flags & FILE_ON_DISK)) {
				cvs_log(LP_NOTICE,
				    "nothing known about '%s'",
				    cf->file_path);
			}

			cf->file_status = FILE_UNKNOWN;
		} else if (rcsdead == 1 || !(cf->file_flags & FILE_HAS_TAG)) {
			if (!(cf->file_flags & FILE_ON_DISK)) {
				cf->file_status = FILE_UPTODATE;
			} else if (cvs_cmdop != CVS_OP_ADD) {
				cf->file_status = FILE_UNKNOWN;
			}
		} else if (notag == 0 && cf->file_rcsrev != NULL) {
			cf->file_status = FILE_CHECKOUT;
		} else {
			cf->file_status = FILE_UPTODATE;
		}

		return;
	}

	switch (cf->file_ent->ce_status) {
	case CVS_ENT_ADDED:
		if (!(cf->file_flags & FILE_ON_DISK)) {
			if (cvs_cmdop != CVS_OP_REMOVE) {
				cvs_log(LP_NOTICE,
				    "warning: new-born %s has disappeared",
				    cf->file_path);
			}
			cf->file_status = FILE_REMOVE_ENTRY;
		} else if (cf->file_rcs == NULL || rcsdead == 1 ||
		    !(cf->file_flags & FILE_HAS_TAG)) {
			cf->file_status = FILE_ADDED;
		} else {
			cvs_log(LP_NOTICE,
			    "conflict: %s already created by others",
			    cf->file_path);
			cf->file_status = FILE_CONFLICT;
		}
		break;
	case CVS_ENT_REMOVED:
		if (cf->file_flags & FILE_ON_DISK) {
			cvs_log(LP_NOTICE,
			    "%s should be removed but is still there",
			    cf->file_path);
			cf->file_status = FILE_REMOVED;
		} else if (cf->file_rcs == NULL || rcsdead == 1) {
			cf->file_status = FILE_REMOVE_ENTRY;
		} else {
			if (rcsnum_differ(cf->file_ent->ce_rev,
			    cf->file_rcsrev) && cvs_cmdop != CVS_OP_ADD) {
				cvs_log(LP_NOTICE,
				    "conflict: removed %s was modified"
				    " by a second party",
				    cf->file_path);
				cf->file_status = FILE_CONFLICT;
			} else {
				cf->file_status = FILE_REMOVED;
			}
		}
		break;
	case CVS_ENT_REG:
		if (cf->file_rcs == NULL || cf->file_rcsrev == NULL ||
		    rcsdead == 1 || (reset_tag == 1 && cf->in_attic == 1) ||
		    (notag == 1 && tag != NULL)) {
			if (!(cf->file_flags & FILE_ON_DISK)) {
				cvs_log(LP_NOTICE,
				    "warning: %s's entry exists but"
				    " is no longer in the repository,"
				    " removing entry",
				     cf->file_path);
				cf->file_status = FILE_REMOVE_ENTRY;
			} else {
				if (ismodified) {
					cvs_log(LP_NOTICE,
					    "conflict: %s is no longer "
					    "in the repository but is "
					    "locally modified",
					    cf->file_path);
					if (cvs_cmdop == CVS_OP_COMMIT)
						cf->file_status = FILE_UNLINK;
					else
						cf->file_status = FILE_CONFLICT;
				} else if (cvs_cmdop != CVS_OP_IMPORT) {
					cvs_log(LP_NOTICE,
					    "%s is no longer in the "
					    "repository",
					    cf->file_path);

					cf->file_status = FILE_UNLINK;
				}
			}
		} else if (cf->file_rcsrev == NULL) {
			cf->file_status = FILE_UNLINK;
		} else {
			if (!(cf->file_flags & FILE_ON_DISK)) {
				if (cvs_cmdop != CVS_OP_REMOVE) {
					cvs_log(LP_NOTICE,
					    "warning: %s was lost",
					    cf->file_path);
				}
				cf->file_status = FILE_LOST;
			} else {
				if (ismodified == 1)
					cf->file_status = FILE_MODIFIED;
				else
					cf->file_status = FILE_UPTODATE;
				if (rcsnum_differ(cf->file_ent->ce_rev,
				    cf->file_rcsrev)) {
					if (cf->file_status == FILE_MODIFIED)
						cf->file_status = FILE_MERGE;
					else
						cf->file_status = FILE_PATCH;
				}
			}
		}
		break;
	case CVS_ENT_UNKNOWN:
		if (cvs_server_active != 1)
			fatal("server-side questionable in local mode?");
		cf->file_status = FILE_UNKNOWN;
		break;
	default:
		break;
	}
}

void
cvs_file_free(struct cvs_file *cf)
{
	free(cf->file_name);
	free(cf->file_wd);
	free(cf->file_path);
	free(cf->file_rcsrev);
	free(cf->file_rpath);
	if (cf->file_ent != NULL)
		cvs_ent_free(cf->file_ent);
	if (cf->file_rcs != NULL)
		rcs_close(cf->file_rcs);
	if (cf->fd != -1)
		(void)close(cf->fd);
	if (cf->repo_fd != -1)
		(void)close(cf->repo_fd);
	free(cf);
}

int
cvs_file_cmpname(const char *name1, const char *name2)
{
	return (cvs_nocase == 0) ? (strcmp(name1, name2)) :
	    (strcasecmp(name1, name2));
}

int
cvs_file_cmp(const char *file1, const char *file2)
{
	struct stat stb1, stb2;
	int fd1, fd2, ret;

	ret = 0;

	if ((fd1 = open(file1, O_RDONLY|O_NOFOLLOW, 0)) == -1)
		fatal("cvs_file_cmp: open: `%s': %s", file1, strerror(errno));
	if ((fd2 = open(file2, O_RDONLY|O_NOFOLLOW, 0)) == -1)
		fatal("cvs_file_cmp: open: `%s': %s", file2, strerror(errno));

	if (fstat(fd1, &stb1) == -1)
		fatal("cvs_file_cmp: `%s': %s", file1, strerror(errno));
	if (fstat(fd2, &stb2) == -1)
		fatal("cvs_file_cmp: `%s': %s", file2, strerror(errno));

	if (stb1.st_size != stb2.st_size ||
	    (stb1.st_mode & S_IFMT) != (stb2.st_mode & S_IFMT)) {
		ret = 1;
		goto out;
	}

	if (S_ISBLK(stb1.st_mode) || S_ISCHR(stb1.st_mode)) {
		if (stb1.st_rdev != stb2.st_rdev)
			ret = 1;
		goto out;
	}

	if (S_ISREG(stb1.st_mode)) {
		void *p1, *p2;

		if ((uintmax_t)stb1.st_size > SIZE_MAX) {
			ret = 1;
			goto out;
		}

		if ((p1 = mmap(NULL, stb1.st_size, PROT_READ,
		    MAP_FILE, fd1, (off_t)0)) == MAP_FAILED)
			fatal("cvs_file_cmp: mmap failed");

		if ((p2 = mmap(NULL, stb1.st_size, PROT_READ,
		    MAP_FILE, fd2, (off_t)0)) == MAP_FAILED)
			fatal("cvs_file_cmp: mmap failed");

		madvise(p1, stb1.st_size, MADV_SEQUENTIAL);
		madvise(p2, stb1.st_size, MADV_SEQUENTIAL);

		ret = memcmp(p1, p2, stb1.st_size);

		(void)munmap(p1, stb1.st_size);
		(void)munmap(p2, stb1.st_size);
	}

out:
	(void)close(fd1);
	(void)close(fd2);

	return (ret);
}

int
cvs_file_copy(const char *from, const char *to)
{
	struct stat st;
	struct timeval tv[2];
	time_t atime, mtime;
	int src, dst, ret;

	ret = 0;

	cvs_log(LP_TRACE, "cvs_file_copy(%s,%s)", from, to);

	if (cvs_noexec == 1)
		return (0);

	if ((src = open(from, O_RDONLY, 0)) == -1)
		fatal("cvs_file_copy: open: `%s': %s", from, strerror(errno));

	if (fstat(src, &st) == -1)
		fatal("cvs_file_copy: `%s': %s", from, strerror(errno));

	atime = st.st_atimespec.tv_sec;
	mtime = st.st_mtimespec.tv_sec;

	if (S_ISREG(st.st_mode)) {
		char *p;
		int saved_errno;

		if ((uintmax_t)st.st_size > SIZE_MAX) {
			ret = -1;
			goto out;
		}

		if ((dst = open(to, O_CREAT|O_TRUNC|O_WRONLY,
		    st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO))) == -1)
			fatal("cvs_file_copy: open `%s': %s",
			    to, strerror(errno));

		if ((p = mmap(NULL, st.st_size, PROT_READ,
		    MAP_FILE, src, (off_t)0)) == MAP_FAILED) {
			saved_errno = errno;
			(void)unlink(to);
			fatal("cvs_file_copy: mmap: %s", strerror(saved_errno));
		}

		madvise(p, st.st_size, MADV_SEQUENTIAL);

		if (atomicio(vwrite, dst, p, st.st_size) != (size_t)st.st_size) {
			saved_errno = errno;
			(void)unlink(to);
			fatal("cvs_file_copy: `%s': %s", from,
			    strerror(saved_errno));
		}

		(void)munmap(p, st.st_size);

		tv[0].tv_sec = atime;
		tv[1].tv_sec = mtime;

		if (futimes(dst, tv) == -1) {
			saved_errno = errno;
			(void)unlink(to);
			fatal("cvs_file_copy: futimes: %s",
			    strerror(saved_errno));
		}
		(void)close(dst);
	}
out:
	(void)close(src);

	return (ret);
}

int
cvs_filelist_cmp(struct cvs_filelist *f1, struct cvs_filelist *f2)
{
	return (strcmp(f1->file_path, f2->file_path));
}
@


1.272
log
@Stop looking at current_cvsroot->cr_method to figure out if we're remote or not.

Instead use cvsroot_is_local() and cvsroot_is_remote().
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.271 2017/05/29 17:18:56 joris Exp $	*/
d375 2
a376 1
				if (cmdp->cmd_flags & CVS_LOCK_REPO)
d378 1
@


1.271
log
@cvs_file_classify() was making the mistake of only taking over a sticky
tag from Entries for a given file if the sticky tag is present.

while changing this we can simplify some logic in update.c on how it
decides what tag to use for file classification.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.270 2017/05/28 17:11:34 joris Exp $	*/
d255 1
a255 2
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL ||
	    cvs_server_active == 1)
d303 1
a303 1
		} else if (current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
d363 1
a363 2
				if (current_cvsroot->cr_method ==
				    CVS_METHOD_LOCAL) {
d588 1
a588 1
	if (current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
d607 1
a607 2
	if (current_cvsroot->cr_method == CVS_METHOD_LOCAL &&
	    (cmdp->cmd_flags & CVS_LOCK_REPO))
@


1.270
log
@Let opencvs show ignored files on import, not showing them is just confusing.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.269 2016/10/15 22:20:17 millert Exp $	*/
d678 1
a678 1
		if (cf->file_ent->ce_tag != NULL && cvs_specified_tag == NULL)
@


1.269
log
@Quiet compiler warnings.  OK tomc@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.268 2016/10/13 20:51:25 fcambus Exp $	*/
d487 3
d493 2
a497 3

			(void)xsnprintf(fpath, PATH_MAX, "%s/%s",
			    cf->file_path, dp->d_name);
@


1.268
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.267 2015/11/05 09:48:21 nicm Exp $	*/
d464 1
a464 1
	if (st.st_size > SIZE_MAX)
d467 1
a467 3
	bufsize = st.st_size;
	if (bufsize < st.st_blksize)
		bufsize = st.st_blksize;
d1031 1
a1031 1
		if (stb1.st_size > SIZE_MAX) {
d1088 1
a1088 1
		if (st.st_size > SIZE_MAX) {
d1107 1
a1107 1
		if (atomicio(vwrite, dst, p, st.st_size) != st.st_size) {
@


1.267
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.266 2015/08/20 22:32:41 deraadt Exp $	*/
d980 1
a980 3

	if (cf->file_rcsrev != NULL)
		rcsnum_free(cf->file_rcsrev);
@


1.266
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.265 2015/02/05 12:59:57 millert Exp $	*/
d39 1
d379 2
a380 4
				if (cvs_directory_tag != NULL) {
					xfree(cvs_directory_tag);
					cvs_directory_tag = NULL;
				}
d564 1
a564 1
	xfree(buf);
d568 1
a568 1
		xfree(ip);
d615 1
a615 1
		xfree(cvs_directory_tag);
d634 2
a635 2
		xfree(f->file_path);
		xfree(f);
d756 1
a756 1
			xfree(cf->file_rpath);
d977 3
a979 3
	xfree(cf->file_name);
	xfree(cf->file_wd);
	xfree(cf->file_path);
d983 1
a983 2
	if (cf->file_rpath != NULL)
		xfree(cf->file_rpath);
d992 1
a992 1
	xfree(cf);
@


1.265
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.264 2015/01/16 06:40:07 deraadt Exp $	*/
d219 1
a219 1
	l = (struct cvs_filelist *)xmalloc(sizeof(*l));
d238 1
a238 1
	cf = (struct cvs_file *)xcalloc(1, sizeof(*cf));
@


1.264
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.263 2013/12/13 15:19:41 zhuk Exp $	*/
d38 1
@


1.263
log
@Make it compile again. And there is a time_t fix as a bonus!

Input and okay jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.262 2010/10/28 15:02:41 millert Exp $	*/
d92 1
a92 1
	char path[MAXPATHLEN], buf[MAXNAMLEN];
d106 1
a106 1
	(void)xsnprintf(path, MAXPATHLEN, "%s/.cvsignore", cvs_homedir);
d267 1
a267 1
	char *d, *f, repo[MAXPATHLEN], fpath[MAXPATHLEN];
d314 2
a315 2
			cvs_get_repository_path(d, repo, MAXPATHLEN);
			(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
d319 1
a319 1
				strlcat(fpath, RCS_FILE_EXT, MAXPATHLEN);
d365 1
a365 1
					    repo, MAXPATHLEN);
d405 1
a405 1
	char *buf, *ebuf, *cp, repo[MAXPATHLEN], fpath[MAXPATHLEN];
d432 1
a432 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", cf->file_path,
d446 1
a446 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/.cvsignore", cf->file_path);
d449 1
a449 1
		while (fgets(fpath, MAXPATHLEN, fp) != NULL) {
d496 1
a496 1
			(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
d575 1
a575 1
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", cf->file_path,
d591 1
a591 1
		cvs_get_repository_path(cf->file_path, repo, MAXPATHLEN);
d649 1
a649 1
	char repo[MAXPATHLEN], rcsfile[MAXPATHLEN];
d659 2
a660 2
	cvs_get_repository_path(cf->file_wd, repo, MAXPATHLEN);
	(void)xsnprintf(rcsfile, MAXPATHLEN, "%s/%s",
d664 2
a665 2
		len = strlcat(rcsfile, RCS_FILE_EXT, MAXPATHLEN);
		if (len >= MAXPATHLEN)
d751 1
a751 1
		(void)xsnprintf(rcsfile, MAXPATHLEN, "%s/%s/%s%s",
@


1.262
log
@Change basep parameter of getdirentries() to be off_t *, not long *
so it works correctly with large offsets (and matches other systems).
This requires adding a new getdirentries syscall, with the old one
renamed to ogetdirentries.  All in-tree consumers of getdirentries()
have been updated.  Bump libc and libpthread major numbers.
OK and with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.261 2010/09/27 14:08:41 joshe Exp $	*/
d33 1
a396 1
	off_t base;
d475 1
a475 1
	while ((nbytes = getdirentries(cf->fd, buf, bufsize, &base)) > 0) {
@


1.261
log
@Have cvs_file_walkdir() ignore CVS/ directories when walking a repository tree.

This fixes r* commands such as rlog against a repository which has
somehow ended up containing CVS/Entries.Static files.

ok nicm@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.260 2010/07/23 21:46:05 ray Exp $	*/
d396 1
a396 1
	long base;
@


1.260
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.259 2010/07/13 20:47:19 nicm Exp $	*/
d599 2
a600 1
		if (stat(fpath, &st) == -1 || build_dirs == 1)
@


1.259
log
@Do not put the file into conflict if it is no longer modified (user has
edited it back to repository state).

ok zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.258 2009/03/28 16:47:33 joris Exp $	*/
d811 1
a811 1
		b2 = cvs_buf_load_fd(cf->fd);
d813 1
a813 1
		if (cvs_buf_differ(b1, b2))
d817 2
a818 2
		cvs_buf_free(b1);
		cvs_buf_free(b2);
@


1.258
log
@when i fixed to attic handling i forgot one special case
that we'd hit in normal checkouts/updates for duplicate file
and dirs.

found and diff tested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.257 2009/03/26 22:54:37 joris Exp $	*/
a958 3
				} else if (cf->file_ent->ce_conflict != NULL &&
				    cf->file_status != FILE_MODIFIED) {
					cf->file_status = FILE_CONFLICT;
@


1.257
log
@fix the way Attic is handled in our recursion code, so we
do not skip files or run over them twice.

also fixes -l and -r for checkout/update when a file in
Attic exists with that tag that in HEAD is a directory
in the normal repository like gnu/usr.bin/gcc/INSTALL.

as a bonus, we do not run fstat() twice per file or dir
anymore...

spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.256 2009/03/25 21:50:33 joris Exp $	*/
d690 7
@


1.256
log
@switch our file and directory lists to RB trees (see tree(3)),
so we can benefit from faster lookup times while recursing.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.255 2009/03/24 18:33:25 joris Exp $	*/
d194 4
a197 2
	for (i = 0; i < argc; i++)
		cvs_file_get(argv[i], FILE_USER_SUPPLIED, &fl);
d204 1
a204 1
cvs_file_get(char *name, int flags, struct cvs_flisthead *fl)
d220 1
d280 1
a280 1
		type = CVS_FILE;
d282 6
a287 5
			if (fstat(fd, &st) == -1) {
				cvs_log(LP_ERRNO, "%s", l->file_path);
				(void)close(fd);
				goto next;
			}
d289 11
a299 10
			if (S_ISDIR(st.st_mode))
				type = CVS_DIR;
			else if (S_ISREG(st.st_mode))
				type = CVS_FILE;
			else {
				cvs_log(LP_ERR,
				    "ignoring bad file type for %s",
				    l->file_path);
				(void)close(fd);
				goto next;
d322 1
a322 1
			if (fd != -1) {
d342 3
d348 1
a348 2
		cf = cvs_file_get_cf(d, f, l->file_path,
		    fd, type, l->flags);
d546 1
a546 1
					cvs_file_get(fpath, 0, &dl);
d549 1
a549 1
				cvs_file_get(fpath, 0, &fl);
d582 1
a582 1
			cvs_file_get(fpath, 0, &dl);
d584 1
a584 1
			cvs_file_get(fpath, 0, &fl);
d677 17
a703 3

		if (cf->file_ent->ce_tag != NULL && cvs_specified_tag == NULL)
			tag = cf->file_ent->ce_tag;
@


1.255
log
@have CVS_OP_TAG and CVS_OP_RTAG use RCS_WRITE flag
when calling rcs_open(), so it gets automaticly synced
at the end of operations for that file instead of explicitly
calling rcs_write() when you're in RCS_READ mode only.

while here, make sure we do not try to free an uninitialized list.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.254 2009/03/19 09:53:16 joris Exp $	*/
d84 2
d192 1
a192 1
	TAILQ_INIT(&fl);
d202 1
a202 1
cvs_file_get(const char *name, int flags, struct cvs_flisthead *fl)
d204 2
a205 2
	const char *p;
	struct cvs_filelist *l;
d210 4
a213 3
	TAILQ_FOREACH(l, fl, flist)
		if (!strcmp(l->file_path, p))
			return (l);
d219 1
a219 1
	TAILQ_INSERT_TAIL(fl, l, flist);
d265 1
a265 1
	for (l = TAILQ_FIRST(fl); l != NULL; l = nxt) {
d379 1
a379 1
		nxt = TAILQ_NEXT(l, flist);
d416 2
a417 2
		TAILQ_INIT(&fl);
		TAILQ_INIT(&dl);
d465 2
a466 2
	TAILQ_INIT(&fl);
	TAILQ_INIT(&dl);
d621 1
a621 1
	struct cvs_filelist *f;
d623 3
a625 2
	while ((f = TAILQ_FIRST(fl)) != NULL) {
		TAILQ_REMOVE(fl, f, flist);
d1110 6
@


1.254
log
@properly register Questionable files using CVS/Entries server-side
in order for them to show up as "? foobar" when opencvs is in server mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.253 2009/02/21 18:26:47 joris Exp $	*/
d698 2
a705 1
	case CVS_OP_RTAG:
@


1.253
log
@fix grammar
from <dawedawe@@gmx.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.252 2009/02/21 14:50:53 joris Exp $	*/
d932 5
@


1.252
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.251 2009/02/21 13:44:18 joris Exp $	*/
d419 1
a419 1
	 * If we do not have a admin directory inside here, dont bother,
@


1.251
log
@use file_flags for 2 more reasons:
- mark a file as being inside the Attic/
- mark a file as existing in the working copy
  (both in local and remote mode)

this way we no longer will need to check if cf->fd == -1 and
think about wether or not we are in local or remote mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.250 2009/02/21 12:47:19 joris Exp $	*/
d243 3
d666 2
a667 1
		if (cf->fd != -1 && cf->file_ent->ce_type == CVS_ENT_DIR &&
d671 2
a672 1
		if (cf->fd != -1 && cf->file_ent->ce_type == CVS_ENT_FILE &&
d755 1
a755 1
	if (cf->fd != -1 && cf->file_ent != NULL) {
d773 2
a774 1
	if (ismodified == 1 && cf->fd != -1 && cf->file_rcs != NULL &&
d812 1
a812 1
			if (cf->fd == -1) {
d820 1
a820 1
			if (cf->fd == -1) {
d836 1
a836 1
		if (cf->fd == -1) {
d854 1
a854 1
		if (cf->fd != -1) {
d878 1
a878 1
			if (cf->fd == -1 && server_has_file == 0) {
d908 1
a908 1
			if (cf->fd == -1 && server_has_file == 0) {
@


1.250
log
@alter cvs_file_get() so it takes flags instead of one set
value for user_supplied. allow us to carry any important file flags
over to cvs_file's later on.

makes it easier for what i have coming.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.249 2008/06/15 04:38:52 tobias Exp $	*/
d588 2
a589 1
			    (cr->flags & CR_RECURSE_DIRS));
d764 3
@


1.249
log
@Support the addition of new files in branches.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.248 2008/06/14 03:58:29 tobias Exp $	*/
d193 1
a193 1
		cvs_file_get(argv[i], 1, &fl);
d200 1
a200 1
cvs_file_get(const char *name, int user_supplied, struct cvs_flisthead *fl)
d214 1
a214 1
	l->user_supplied = user_supplied;
d222 1
a222 1
	int type, int user_supplied)
d238 2
a239 2
	cf->file_status = cf->file_flags = 0;
	cf->user_supplied = user_supplied;
d335 1
a335 1
		    fd, type, l->user_supplied);
d339 1
a339 1
			if (l->user_supplied) {
d360 1
a360 1
			if (l->user_supplied) {
@


1.248
log
@Added support for sticky date set in CVS/Tag and CVS/Entries per directory.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.247 2008/06/14 03:19:15 joris Exp $	*/
d809 1
a809 1
		} else if (rcsdead == 1) {
d833 2
a834 1
		} else if (cf->file_rcs == NULL || rcsdead == 1) {
@


1.247
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.246 2008/06/13 17:15:13 joris Exp $	*/
d787 2
a788 1
		if (cvs_specified_date == -1 && tag == NULL && cf->in_attic &&
@


1.246
log
@pass the complete path to cvs_file_get_cf() instead of reconstructing
it again in that function.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.245 2008/06/12 16:54:46 joris Exp $	*/
a575 2
	cvs_ent_close(entlist, ENT_NOSYNC);

a657 1
		cvs_ent_close(entlist, ENT_NOSYNC);
@


1.245
log
@properly deal with CVS_USE_WDIR.
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.244 2008/06/12 07:29:54 joris Exp $	*/
d221 1
a221 1
cvs_file_get_cf(const char *d, const char *f, int fd,
d224 1
a225 3
	char *p, rpath[MAXPATHLEN];

	(void)xsnprintf(rpath, MAXPATHLEN, "%s/%s", d, f);
d227 1
a227 1
	for (p = rpath; p[0] == '.' && p[1] == '/';)
d334 2
a335 1
		cf = cvs_file_get_cf(d, f, fd, type, l->user_supplied);
@


1.244
log
@fix logic
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.243 2008/06/12 07:16:14 joris Exp $	*/
d297 2
a298 1
			if (cvs_cmdop != CVS_OP_CHECKOUT && !print_stdout)
@


1.243
log
@completely kill the need for TMP_DIR when running checkout,
which gives us better performance among other things.

this is however disabled in a few cases:
1) whenever you run checkout over an existing tree (which acts as update)
2) whenever you specify -d or a module alias

we're planning on enabling this behaviour for case 2 in the future.

anoncvs sysadmins now love us even more.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.242 2008/06/09 22:31:24 tobias Exp $	*/
d297 1
a297 1
			if (cvs_cmdop != CVS_OP_CHECKOUT || !print_stdout)
@


1.242
log
@Properly handle merged files and conflicts which may arrise while merge.
Instead of ignoring all files which contain possible conflict markers,
only watch out for files which have actually been merged.

With input by and ok joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.241 2008/06/09 17:05:49 tobias Exp $	*/
d49 1
d588 1
a588 1
		if (stat(fpath, &st) == -1)
@


1.241
log
@Stop fooling ourselfs by freeing cvs_directory_tag at the wrong position:
cvs_directory_tag is reinitalized every time we enter a new directory, so
make it clear by freeing before going into a new directory.

discussed with and ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.240 2008/06/08 13:34:22 tobias Exp $	*/
d882 4
a885 1
					cf->file_status = FILE_CONFLICT;
a909 1

d916 3
@


1.240
log
@Removed unreachable code.
Spotted by Igor Zinovik.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.239 2008/06/08 03:03:08 tobias Exp $	*/
d599 6
a609 6

	if (cvs_directory_tag != NULL && cmdp->cmd_flags & CVS_USE_WDIR) {
		cvs_write_tagfile(cf->file_path, cvs_directory_tag, NULL);
		xfree(cvs_directory_tag);
		cvs_directory_tag = NULL;
	}
@


1.239
log
@Avoid memory leaks in directory tag handling by always allocating and
always freeing dirtag.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.238 2008/06/08 02:52:24 tobias Exp $	*/
a901 2
			} else if (cf->file_rcsrev == NULL) {
				cf->file_status = FILE_UNLINK;
@


1.238
log
@There is no need to convert RCSNUMs to char just to see if they differ.
We have rcsnum_differ for that.  Also remove an unused var assignment if
no CVS/Entries entry exists.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.237 2008/05/22 06:50:18 xsa Exp $	*/
d344 2
a345 1
					cvs_directory_tag = cvs_specified_tag;
d359 8
a366 2
			if (l->user_supplied && cmdp->cmd_flags & CVS_LOCK_REPO)
				cvs_repository_unlock(repo);
@


1.237
log
@Spacing; Stefan Sperling.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.235 2008/03/09 18:02:17 joris Exp $	*/
a627 1
	char r1[CVS_REV_BUFSZ], r2[CVS_REV_BUFSZ];
d727 1
a727 3
		    != NULL) {
			rcsnum_tostr(cf->file_rcsrev, r1, sizeof(r1));
		} else {
a742 5
	if (cf->file_ent != NULL)
		rcsnum_tostr(cf->file_ent->ce_rev, r1, sizeof(r1));
	if (cf->file_rcsrev != NULL)
		rcsnum_tostr(cf->file_rcsrev, r2, sizeof(r2));

d845 2
a846 1
			if (strcmp(r1, r2)) {
d903 2
a904 1
				if (strcmp(r1, r2)) {
@


1.236
log
@use RCS_PARSE_FULLY for CVS_OP_ADMIN as well.
@
text
@d894 1
a894 1
		} else{
@


1.235
log
@only compare file types if the file/directory exists both on disk
and in the CVS/Entries file, otherwise ignore it so we correctly
remove it from CVS/Entries.

spotted by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.234 2008/03/09 03:14:52 joris Exp $	*/
d690 1
@


1.234
log
@proper repository locking:
- all read operations now look for a lock, and wait if present but never
  try to lock the tree themselfs anymore.
- all write operations lock the tree where needed.
- commit locks all relevant directories before even attempting to start.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.233 2008/03/09 03:06:56 joris Exp $	*/
d658 1
a658 1
		if (cf->file_ent->ce_type == CVS_ENT_DIR &&
d662 1
a662 1
		if (cf->file_ent->ce_type == CVS_ENT_FILE &&
d870 1
a870 2
				    " there is no longer a file"
				    " in the repository,"
@


1.233
log
@do not empty the list in cvs_file_walklist() this is the caller
his responsibility, allows us to reuse the same file list
for multiple callbacks.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.232 2008/03/09 02:30:42 tobias Exp $	*/
d241 1
d345 8
d357 3
d571 1
a571 1
	if (cr->flags & CR_REPO) {
d573 2
a574 1
		cvs_repository_lock(repo);
d576 1
d588 2
a589 1
	if (cr->flags & CR_REPO)
@


1.232
log
@cf->user_supplied cannot be used in cvs_file_classify for all commands
(like import, add, commit), so revert this change until a universal
solution is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.231 2008/03/09 02:06:32 tobias Exp $	*/
a353 4
		TAILQ_REMOVE(fl, l, flist);

		xfree(l->file_path);
		xfree(l);
@


1.231
log
@Don't force ourself to support CVS_USE_WDIR commands (release, update, ...)
only if we are in top directory of a repository.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.230 2008/03/09 01:54:03 joris Exp $	*/
d622 1
a622 1
	if (cf->file_type == CVS_DIR && cf->user_supplied) {
@


1.230
log
@pass user_supplied to struct cvs_file so it can be used
in the callbacks to verify if this file was specified on the command line.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.229 2008/03/09 01:25:31 joris Exp $	*/
d622 1
a622 1
	if (!strcmp(cf->file_path, ".")) {
@


1.229
log
@rename check_dir_tag to user_supplied to reflect what the flag
actually means and is used for.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.228 2008/03/09 01:02:38 tobias Exp $	*/
d220 2
a221 1
cvs_file_get_cf(const char *d, const char *f, int fd, int type)
d240 1
d333 1
a333 1
		cf = cvs_file_get_cf(d, f, fd, type);
@


1.228
log
@While allocation memory, make sure that file sizes are smaller than SIZE_MAX.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.227 2008/03/08 20:26:34 joris Exp $	*/
d199 1
a199 1
cvs_file_get(const char *name, int check_dir_tag, struct cvs_flisthead *fl)
d213 1
a213 1
	l->check_dir_tag = check_dir_tag;
d335 1
a335 1
			if (l->check_dir_tag) {
@


1.227
log
@add checkout/update -j support.
still has some rough edges.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.226 2008/03/01 21:29:37 deraadt Exp $	*/
d433 3
d973 1
a973 1
		if (stb1.st_size > (off_t)SIZE_MAX) {
d1030 1
a1030 1
		if (st.st_size > (off_t)SIZE_MAX) {
@


1.226
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.225 2008/03/01 14:55:03 joris Exp $	*/
d751 2
a752 1
	    cf->file_ent != NULL && !RCSNUM_ISBRANCH(cf->file_ent->ce_rev)) {
@


1.225
log
@make sure we compare our current file contents against the correct
revision specified in CVS/Entries if the timestamps mismatch, so
that we do not end up merging a file that was not even modified whenever
it needs a normal patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.224 2008/02/20 17:29:28 tobias Exp $	*/
d324 1
a324 1
			
d972 1
a972 1
		}	
d1029 1
a1029 1
		}	
@


1.224
log
@With latest buf cleanup, rcs_rev_getbuf won't return NULL anymore.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.223 2008/02/20 09:16:32 joris Exp $	*/
d751 2
a752 2
	    cf->file_rcsrev != NULL && !RCSNUM_ISBRANCH(cf->file_rcsrev)) {
		b1 = rcs_rev_getbuf(cf->file_rcs, cf->file_rcsrev, 0);
@


1.223
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.222 2008/02/11 20:33:11 tobias Exp $	*/
a752 3
		if (b1 == NULL)
			fatal("failed to get HEAD revision for comparison");

@


1.222
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.221 2008/02/10 14:00:41 joris Exp $	*/
d731 1
a731 1
	if (cf->file_rcsrev != NULL) {
a732 1
	}
@


1.221
log
@introduce cvs_validate_directory(), which is used to check
directory path to make sure they do not fall outside the CVSROOT
or the working copy directory in a remote setup
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.220 2008/02/10 10:21:42 joris Exp $	*/
d757 1
a757 3
		b2 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT);
		if (b2 == NULL)
			fatal("failed to get file content for comparison");
@


1.220
log
@properly initialize cvs_specified_date so we dont end up with
random stuff going on
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.219 2008/02/09 12:20:33 tobias Exp $	*/
d240 4
@


1.219
log
@Get in proper support for checkout/update -A when it comes to keyword
expansion options.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.218 2008/02/09 11:17:02 tobias Exp $	*/
d774 1
a774 1
		if (cvs_specified_date == 0 && tag == NULL && cf->in_attic &&
@


1.218
log
@Get in initial support for checkout -D.  Works fine with -r support right
now.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.217 2008/02/08 22:07:50 joris Exp $	*/
d850 2
a851 2
		    rcsdead == 1 || (reset_stickies == 1 &&
		    cf->in_attic == 1)|| (notag == 1 && tag != NULL)) {
@


1.217
log
@when checking if a file is really dead do not use cvs_specified_tag only,
instead use the local variable 'tag' which is filled in by our code
to match the correct tag (specified on the command line, or in Entries);

this way, files do not dissapear when they're suppose to be there
if you are using -rSOMETHING
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.216 2008/02/08 21:32:07 joris Exp $	*/
d706 2
a707 2
		if ((cf->file_rcsrev = rcs_translate_tag(tag,
		    cf->file_rcs)) != NULL) {
d710 1
a710 1
			cf->file_rcsrev = rcs_head_get(cf->file_rcs);
d720 1
a720 1
		cf->file_rcsrev = rcs_head_get(cf->file_rcs);
d748 1
a748 1
	    !RCSNUM_ISBRANCH(cf->file_rcsrev)) {
d774 1
a774 1
		if (tag == NULL &&cf->in_attic &&
d801 1
a801 1
		} else if (notag == 0) {
d849 3
a851 3
		if (cf->file_rcs == NULL || rcsdead == 1 ||
		    (reset_stickies == 1 && cf->in_attic == 1) ||
		    (notag == 1 && tag != NULL)) {
d877 3
a879 1
		} else {
d887 2
@


1.216
log
@do not override the specified tag (-r on the command line) with a directory
tag (if present) since this breaks certain things;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.215 2008/02/04 18:23:58 tobias Exp $	*/
d774 1
a774 1
		if (cvs_specified_tag == NULL && cf->in_attic &&
@


1.215
log
@Stripped off 'nb', which was (or was supposed to be) used to distinguish
between a named branch and a revision number supplied by -r.  This can
be done easier in cvs_write_tagfile directly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.214 2008/02/03 22:50:28 joris Exp $	*/
d647 1
a647 1
		if (cf->file_ent->ce_tag != NULL)
@


1.214
log
@more CVSROOT/module stuff:

- allow more then 1 module to be specified per definition
- respect the "!" sign which means: "hey ignore this dir when checking out"
- non alias definitions can now contain files

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.213 2008/02/03 15:08:04 tobias Exp $	*/
d579 1
a579 1
		cvs_write_tagfile(cf->file_path, cvs_directory_tag, NULL, 0);
@


1.213
log
@(f)utimes takes sys/time.h
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.212 2008/01/31 21:56:34 tobias Exp $	*/
d81 1
d92 1
d165 8
@


1.212
log
@If CVS/Entries.Static exists, don't look for more files in repository.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.211 2008/01/31 10:15:05 tobias Exp $	*/
d31 1
@


1.211
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.210 2008/01/21 16:36:46 tobias Exp $	*/
d547 6
a552 2
		cvs_repository_getdir(repo, cf->file_path, &fl, &dl,
		    (cr->flags & CR_RECURSE_DIRS));
@


1.210
log
@Fixed export to be fully functional and compliant to GNU cvs in local and
remote setups.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.209 2008/01/10 11:21:34 tobias Exp $	*/
d373 10
d384 1
a384 1
	 * unless we are running export, import, rlog or rtag.
a390 1
	    cvs_cmdop != CVS_OP_RLOG && cvs_cmdop != CVS_OP_RTAG &&
d542 1
d563 1
a563 1
	if (cvs_directory_tag != NULL) {
d607 1
a607 2
	if (cvs_cmdop != CVS_OP_RLOG && cvs_cmdop != CVS_OP_RTAG &&
	    cf->file_type == CVS_FILE) {
d614 7
a620 3
	entlist = cvs_ent_open(cf->file_wd);
	cf->file_ent = cvs_ent_get(entlist, cf->file_name);
	cvs_ent_close(entlist, ENT_NOSYNC);
d637 3
a639 1
		if (cf->fd == -1 && stat(rcsfile, &st) != -1)
@


1.209
log
@various fixes for remote commands (right now we support rlog and rtag)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.208 2008/01/10 10:12:09 tobias Exp $	*/
d374 1
a374 1
	 * unless we are running import.
d380 2
a381 2
	if (cvs_cmdop != CVS_OP_IMPORT && cvs_cmdop != CVS_OP_RLOG &&
	    cvs_cmdop != CVS_OP_RTAG &&
@


1.208
log
@Make cvs_file_classify more readable.

"Be especially careful with this one" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.207 2008/01/10 10:09:27 tobias Exp $	*/
d381 1
d431 3
a433 1
			if (cvs_file_chkign(dp->d_name)) {
d597 2
a598 1
	if (cf->file_type == CVS_FILE) {
d626 2
a627 1
		else if (cf->file_ent != NULL || cvs_cmdop == CVS_OP_RLOG)
d643 1
@


1.207
log
@xmalloc + memset -> xcalloc
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.206 2008/01/10 09:37:26 tobias Exp $	*/
d603 1
a626 1
		cvs_ent_close(entlist, ENT_NOSYNC);
d640 2
d770 6
a775 1
	} else if (cf->file_ent->ce_status == CVS_ENT_ADDED) {
d791 2
a792 1
	} else if (cf->file_ent->ce_status == CVS_ENT_REMOVED) {
d811 2
a812 1
	} else if (cf->file_ent->ce_status == CVS_ENT_REG) {
d863 3
a866 2

	cvs_ent_close(entlist, ENT_NOSYNC);
@


1.206
log
@RCS files without head keyword mustn't segfault our implementation.  Only
command that supports such files is "cvs status", therefore properly handle
them in all other commands, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.205 2007/11/09 16:21:24 tobias Exp $	*/
d219 1
a219 2
	cf = (struct cvs_file *)xmalloc(sizeof(*cf));
	memset(cf, 0, sizeof(*cf));
@


1.205
log
@Fix for a rather unintuitive behaviour, this way it can be reproduced:

cvs checkout src/sbin/swapon
cvs checkout -rHEAD src/sbin/swapon

If no date or revision has been supplied, swapon.8 won't be checked out,
but if a revision (even if it is HEAD) or a date (-D) has been supplied,
swapon.8 will be checked out due to modifications in Attic/ after it has
been removed from tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.204 2007/10/09 12:20:24 tobias Exp $	*/
a672 1
			notag = 1;
d674 4
a677 1
			cf->file_flags &= ~FILE_HAS_TAG;
@


1.204
log
@Do not warn user about files that are "no longer in the repository"
during cvs import.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.203 2007/10/05 19:28:23 gilles Exp $	*/
d733 4
@


1.203
log
@strcspn() change

was okay'd by pyr@@ and ok by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.202 2007/09/24 13:44:20 joris Exp $	*/
d818 1
a818 1
				} else {
@


1.202
log
@add support to commit modified files to branches.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.201 2007/09/23 11:19:24 joris Exp $	*/
a85 1
	size_t len;
d108 2
a109 2
			len = strlen(buf);
			if (len == 0)
a110 2
			if (buf[len - 1] == '\n')
				buf[len - 1] = '\0';
a350 1
	size_t len;
d395 2
a396 2
			len = strlen(fpath);
			if (len == 0)
a397 2
			if (fpath[len - 1] == '\n')
				fpath[len - 1] = '\0';
d436 1
a436 1
			len = xsnprintf(fpath, MAXPATHLEN, "%s/%s",
@


1.201
log
@make sure when running update -r on existing files to overwrite
the sticky directory tag with it. since -r gets priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.200 2007/09/23 10:49:49 joris Exp $	*/
d714 2
a715 1
	if (ismodified == 1 && cf->fd != -1 && cf->file_rcs != NULL) {
d732 2
a733 1
	if (cf->file_rcs != NULL && cf->file_rcsrev != NULL) {
@


1.200
log
@pass FILE_HAS_FLAG towards the update code so it can identify
if a given tag is present in the RCSfile or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.199 2007/09/22 16:01:22 joris Exp $	*/
d620 3
@


1.199
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.198 2007/09/22 15:57:24 joris Exp $	*/
d670 1
d678 1
@


1.198
log
@we no longer create a 0 sized file in our /tmp/cvs-serv<pid> server
directory when a client sends us info about a file that is up to date.

instead, remember the file is up to date in our CVS/Entries. Saves us a lot
of headaches on very big trees like src/
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.197 2007/09/17 10:07:21 tobias Exp $	*/
d77 1
d184 1
a184 1
		cvs_file_get(argv[i], &fl);
d191 1
a191 1
cvs_file_get(const char *name, struct cvs_flisthead *fl)
d205 1
d324 9
d390 2
d492 1
a492 1
					cvs_file_get(fpath, &dl);
d495 1
a495 1
				cvs_file_get(fpath, &fl);
d528 1
a528 1
			cvs_file_get(fpath, &dl);
d530 1
a530 1
			cvs_file_get(fpath, &fl);
d556 6
d582 1
a582 1
	int server_has_file;
d669 1
d671 6
a676 6
		/* if we could not translate tag, means that we should
		 * skip this file. */
		if ((cf->file_rcsrev = rcs_translate_tag(tag, cf->file_rcs)) == NULL) {
			cf->file_status = FILE_SKIP;
			cvs_ent_close(entlist, ENT_NOSYNC);
			return;
a677 3

		rcsnum_tostr(cf->file_rcsrev, r1, sizeof(r1));

d757 2
d760 1
a760 1
			cf->file_status = FILE_CHECKOUT;
d799 2
a800 1
		    (reset_stickies == 1 && cf->in_attic == 1)) {
@


1.197
log
@Imported atomicio interface.

Requested by ray@@, OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.196 2007/09/09 20:24:06 tobias Exp $	*/
d41 1
d563 1
d570 2
a571 1
	cvs_log(LP_TRACE, "cvs_file_classify(%s)", cf->file_path);
d685 7
d781 1
a781 1
			if (cf->fd == -1) {
d807 1
a807 1
			if (cf->fd == -1) {
@


1.196
log
@Added support for checkout -p with local repository.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.195 2007/09/07 23:30:30 tobias Exp $	*/
d39 1
d939 1
a939 3
		size_t sz;
		ssize_t nw;
		char *p, *buf;
d961 5
a965 12
		sz = st.st_size;
		buf = p;

		while (sz > 0) {
			if ((nw = write(dst, p, sz)) == -1) {
				saved_errno = errno;
				(void)unlink(to);
				fatal("cvs_file_copy: `%s': %s",
				    from, strerror(saved_errno));
			}
			buf += nw;
			sz -= nw;
@


1.195
log
@Do not fatal if getpwuid() fails, instead ignore user configuration files.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.194 2007/07/03 13:22:42 joris Exp $	*/
d45 2
d274 9
a282 4
			if (stat(d, &st) == -1) {
				cvs_log(LP_ERRNO, "%s", d);
				goto next;
			}
@


1.194
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.193 2007/06/28 21:38:09 xsa Exp $	*/
d90 3
@


1.193
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.192 2007/06/26 02:24:10 niallo Exp $	*/
d341 1
a341 1
	char *p, *buf, *ebuf, *cp, repo[MAXPATHLEN], fpath[MAXPATHLEN];
a469 11
				if ((p = strrchr(cf->file_path, '/')) &&
				    !strcmp(p + 1, CVS_PATH_ATTIC)) {

					*p = '\0';
					len = xsnprintf(fpath, MAXPATHLEN,
					    "%s/%s", cf->file_path, dp->d_name);
					*p = '/';
				}
				if (fpath[len - 2] == ',' &&
				    fpath[len - 1] == 'v')
					fpath[len - 2] = '\0';
d555 1
a555 1
	char r1[CVS_REV_BUFSZ], r2[CVS_REV_BUFSZ], *tfname, *tpath, *p;
a563 1

a574 16
	/* XXX: likely wrong place for this shit */
	/* is this file in the Attic? */
	if (cf->file_type == CVS_FILE
	    && strstr(cf->file_rpath, CVS_PATH_ATTIC) != NULL) {
		cf->in_attic = 1;
		/* chop the 'Attic' out of cf->file_path */
		if ((tfname = basename(cf->file_path)) == NULL)
			fatal("cvs_file_classify: basename failure");
		if ((tpath = dirname(cf->file_path)) == NULL)
			fatal("cvs_file_classify: dirname failure");
		if ((p = strstr(tpath, CVS_PATH_ATTIC)) == NULL)
			fatal("cvs_file_classify: strstr failure");
		strlcpy(cf->file_path, tpath, p - tpath + 1);
		strlcat(cf->file_path, tfname, MAXPATHLEN);
	}

a612 4
	if (strncmp(cf->file_path, CVS_JUNK, strlen(CVS_JUNK)) == 0) {
		cf->file_status = FILE_UNKNOWN;
		return;
	}
d618 16
d758 2
a759 1
		if (cf->file_rcs == NULL || rcsdead == 1) {
@


1.192
log
@add support for cvs rlog.
from Mickey.

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.191 2007/06/04 21:54:26 niallo Exp $	*/
d565 2
a566 2
	char repo[MAXPATHLEN], rcsfile[MAXPATHLEN], r1[16], r2[16];
	char *tfname, *tpath, *p;
@


1.191
log
@remove a fatal i committed by accident.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.190 2007/06/01 17:47:47 niallo Exp $	*/
d341 1
a341 1
	char *buf, *ebuf, *cp, repo[MAXPATHLEN], fpath[MAXPATHLEN];
d362 1
a362 1
	if (cvs_cmdop != CVS_OP_IMPORT &&
d417 1
a417 1
			(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
a463 6
			if (!(cr->flags & CR_RECURSE_DIRS) &&
			    type == CVS_DIR) {
				cp += dp->d_reclen;
				continue;
			}

d466 2
a467 1
				cvs_file_get(fpath, &dl);
d470 11
d620 1
a620 1
		else if (cf->file_ent != NULL)
d636 1
@


1.190
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.189 2007/02/22 06:42:09 otto Exp $	*/
a642 4
	} else {
		
		fatal("cvs_file_classify: failed to open file `%s' of type %d",
		    cf->file_rpath, cf->file_type);
@


1.189
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.188 2007/02/21 04:18:45 ray Exp $	*/
a506 1

d560 1
d569 1
d581 15
d634 4
d643 13
a655 16
		cf->file_rcs->rf_inattic = 0;
	} else if (cvs_cmdop != CVS_OP_CHECKOUT) {
		(void)xsnprintf(rcsfile, MAXPATHLEN, "%s/%s/%s%s",
		    repo, CVS_PATH_ATTIC, cf->file_name, RCS_FILE_EXT);

		cf->repo_fd = open(rcsfile, O_RDONLY);
		if (cf->repo_fd != -1) {
			xfree(cf->file_rpath);
			cf->file_rpath = xstrdup(rcsfile);
			cf->file_rcs = rcs_open(cf->file_rpath,
			     cf->repo_fd, rflags);
			if (cf->file_rcs == NULL)
				fatal("cvs_file_classify: failed to parse RCS");
			cf->file_rcs->rf_inattic = 1;
		} else {
			cf->file_rcs = NULL;
a656 2
	} else
		cf->file_rcs = NULL;
d658 2
a659 3
	if (tag != NULL && cf->file_rcs != NULL) {
		if ((cf->file_rcsrev = rcs_translate_tag(tag, cf->file_rcs)) == NULL)
			fatal("cvs_file_classify: could not translate tag `%s'", tag);
d663 1
a663 1
	} else if (cf->file_rcs != NULL)
d665 1
a665 1
	else
d667 1
d671 1
a671 1
	if (cf->file_rcsrev != NULL)
d673 1
@


1.188
log
@Simplify cvs_buf_differ().  Also cvs_buf_differ(), a comparison
function, should not do any resource freeing.

OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.187 2007/02/19 11:40:00 otto Exp $	*/
d28 3
a30 1
#include "includes.h"
d32 6
a37 1
#include <sys/mman.h>
a39 2
#include "file.h"
#include "log.h"
@


1.187
log
@Fix const inconsistencies, void pointer artithmetic and a few other
things. now gcc -Wall and lint are more happy. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.186 2007/02/09 16:46:26 joris Exp $	*/
a671 1
		/* b1 and b2 get released in cvs_buf_differ */
d676 2
@


1.186
log
@correctly skip invalid entries when using
getdirentries(2).

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.185 2007/02/09 03:49:15 joris Exp $	*/
d864 1
a864 1
		if (stb1.st_size > SIZE_MAX) {
d923 1
a923 1
		if (st.st_size > SIZE_MAX) {
@


1.185
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.184 2007/02/07 23:47:56 todd Exp $	*/
d402 1
a402 1
			    dp->d_reclen == 0) {
@


1.184
log
@fstat() -> lstat() in a few select cases,
this fixes a bug where opencvs update would abort if a link existed that
pointed to a non-existent file/dir
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.183 2007/01/31 21:07:35 xsa Exp $	*/
d547 1
a547 1
cvs_file_classify(struct cvs_file *cf, const char *tag, int loud)
@


1.183
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.182 2007/01/29 15:47:39 joris Exp $	*/
d418 1
a418 1
			 * this we call stat() on the path to be sure.
d421 1
a421 1
				if (stat(fpath, &st) == -1)
@


1.182
log
@no longer spit out that you can add new files using 'cvs add',
it is pretty obvious on itself.

ok niallo@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.181 2007/01/28 03:03:35 joris Exp $	*/
d74 1
a74 1
	int i, l;
d87 1
a87 3
	l = snprintf(path, MAXPATHLEN, "%s/.cvsignore", cvs_homedir);
	if (l == -1 || l >= MAXPATHLEN)
		fatal("overflow in cvs_file_init");
a199 1
	int l;
d203 1
a203 3
	l = snprintf(rpath, MAXPATHLEN, "%s/%s", d, f);
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_file_get_cf: overflow");
d226 1
a226 1
	int len, fd, type;
d270 1
a270 1
			len = snprintf(fpath, MAXPATHLEN, "%s/%s",
a271 2
			if (len == -1 || len >= MAXPATHLEN)
				fatal("cvs_file_walklist: overflow");
d353 1
a353 1
	l = snprintf(fpath, MAXPATHLEN, "%s/%s", cf->file_path,
a354 2
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_file_walkdir: overflow");
d365 1
a365 3
	l = snprintf(fpath, MAXPATHLEN, "%s/.cvsignore", cf->file_path);
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_file_walkdir: overflow");
d412 1
a412 1
			l = snprintf(fpath, MAXPATHLEN, "%s/%s",
a413 2
			if (l == -1 || l >= MAXPATHLEN)
				fatal("cvs_file_walkdir: overflow");
d496 1
a496 1
		l = snprintf(fpath, MAXPATHLEN, "%s/%s", cf->file_path,
a497 2
		if (l == -1 || l >= MAXPATHLEN)
			fatal("cvs_file_walkdir: overflow");
d552 1
a552 1
	int rflags, l, ismodified, rcsdead;
d565 1
a565 1
	l = snprintf(rcsfile, MAXPATHLEN, "%s/%s",
a566 2
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_file_classify: overflow");
d620 1
a620 1
		l = snprintf(rcsfile, MAXPATHLEN, "%s/%s/%s%s",
a621 2
		if (l == -1 || l >= MAXPATHLEN)
			fatal("cvs_file_classify: overflow");
@


1.181
log
@remove debug printfs that sneaked in.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.180 2007/01/28 02:04:45 joris Exp $	*/
a719 4
			} else if (cvs_cmdop != CVS_OP_ADD) {
				cvs_log(LP_NOTICE,
				    "use add to create an entry for %s",
				    cf->file_path);
a726 3
				cvs_log(LP_NOTICE,
				    "use add to create an entry for %s",
				    cf->file_path);
@


1.180
log
@add merging support in both local and remote sides.
tested by many, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.179 2007/01/27 20:21:25 joris Exp $	*/
a682 1
		printf("oh what on `%s'\n", cf->file_path);
@


1.179
log
@missed a case for CVS_CMD_ADD from last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.178 2007/01/27 20:02:33 joris Exp $	*/
d683 1
@


1.178
log
@by default let cvs_file_classify complain about certain cases
and fix some warnings that should not come up for certain commands.

ok niallo@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.177 2007/01/26 11:19:44 joris Exp $	*/
d730 1
a730 1
			} else {
@


1.177
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.176 2007/01/25 18:56:33 otto Exp $	*/
d567 1
a567 1
	int rflags, l, ismodified, rcsdead, verbose;
a578 2
	verbose = (verbosity > 1 && loud == 1);

d717 7
a723 9
				if (verbose)
					cvs_log(LP_NOTICE,
					    "nothing known about '%s'",
					    cf->file_path);
			} else {
				if (verbose)
					cvs_log(LP_NOTICE,
					    "use add to create an entry for %s",
					    cf->file_path);
d731 3
a733 4
				if (verbose)
					cvs_log(LP_NOTICE,
					    "use add to create an entry for %s",
					    cf->file_path);
d741 1
a741 1
			if (verbose)
d745 1
d750 3
a752 4
			if (verbose)
				cvs_log(LP_NOTICE,
				    "conflict: %s already created by others",
				    cf->file_path);
d757 3
a759 4
			if (verbose)
				cvs_log(LP_NOTICE,
				    "%s should be removed but is still there",
				    cf->file_path);
d765 4
a768 5
				if (verbose)
					cvs_log(LP_NOTICE,
					    "conflict: removed %s was modified"
					    " by a second party",
					    cf->file_path);
d777 6
a782 7
				if (verbose)
					cvs_log(LP_NOTICE,
					    "warning: %s's entry exists but"
					    " there is no longer a file"
					    " in the repository,"
					    " removing entry",
					     cf->file_path);
d786 5
a790 6
					if (verbose)
						cvs_log(LP_NOTICE,
						    "conflict: %s is no longer "
						    "in the repository but is "
						    "locally modified",
						    cf->file_path);
d793 4
a796 5
					if (verbose)
						cvs_log(LP_NOTICE,
						    "%s is no longer in the "
						    "repository",
						    cf->file_path);
d803 1
a803 1
				if (verbose)
d807 1
@


1.176
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.175 2007/01/23 01:53:38 ray Exp $	*/
a564 1
	time_t mtime;
d680 1
a680 2
		mtime = cvs_hack_time(st.st_mtime, 1);
		if (mtime != cf->file_ent->ce_mtime)
@


1.175
log
@Don't fatal() when unexpected files are encountered in the working
copy.  Allows obj/ directories to exist (which are typically
symlinks.)

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.174 2007/01/20 17:02:36 joris Exp $	*/
d77 1
a77 4
	char *path, *buf;

	path = xmalloc(MAXPATHLEN);
	buf = xmalloc(MAXNAMLEN);
a108 3

	xfree(path);
	xfree(buf);
d204 1
a204 3
	char *p, *rpath;

	rpath = xmalloc(MAXPATHLEN);
a224 1
	xfree(rpath);
d235 1
a235 4
	char *d, *f, *repo, *fpath;

	fpath = xmalloc(MAXPATHLEN);
	repo = xmalloc(MAXPATHLEN);
a324 3

	xfree(fpath);
	xfree(repo);
d343 1
a343 1
	char *buf, *ebuf, *cp, *repo, *fpath;
a355 2
	fpath = xmalloc(MAXPATHLEN);

a367 1
		xfree(fpath);
a528 1
		repo = xmalloc(MAXPATHLEN);
d539 1
a539 1
	if (cr->flags & CR_REPO) {
a540 2
		xfree(repo);
	}
a544 2
	xfree(fpath);

d571 1
a571 1
	char *repo, *rcsfile, r1[16], r2[16];
a581 3
	repo = xmalloc(MAXPATHLEN);
	rcsfile = xmalloc(MAXPATHLEN);

a617 2
		xfree(repo);
		xfree(rcsfile);
a835 2
	xfree(repo);
	xfree(rcsfile);
@


1.174
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.173 2007/01/20 01:31:03 joris Exp $	*/
d464 2
a465 1
					fatal("Unknown file type in copy");
d476 2
a477 1
					fatal("Unknown file type in copy");
d479 9
@


1.173
log
@more safety checks for file->file_rcsrev;
'cool' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.172 2007/01/20 00:58:19 niallo Exp $	*/
d679 1
a679 1
			fatal("cvs_file_classify:  could not translate tag `%s'", tag);
@


1.172
log
@check return value of rcs_translate_tag().  prevents a segfault found by todd@@.  still need to fix tag translation though.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.171 2007/01/19 23:23:21 joris Exp $	*/
d719 1
a719 1
	if (cf->file_rcs != NULL) {
@


1.171
log
@When we hit a DT_UNKNOWN for dirent->d_type in our filelist functions,
stat() the filepath to get the correct type, and therefor
add it to the appropriate list.

This fixes opencvs with CVSROOTs on NFS and AFS, because they
both return D_UNKNOWN for directories (afs even for files too)
in dirent->d_type.

problem found by thib@@ and todd@@
tested by thib@@, todd@@,
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.170 2007/01/14 23:10:56 joris Exp $	*/
d677 4
a680 3
	if (tag != NULL && cf->file_rcs != NULL)
		cf->file_rcsrev = rcs_translate_tag(tag, cf->file_rcs);
	else if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL) {
@


1.170
log
@move things around in rcs_rev_getbuf() and rcs_rev_write_fd()
so that we do keyword expansion on-the-fly if required instead
of obtaining the revision in memory first, running over the revision
lines while expanding keywords and only then writing them to the fd
or memory buffer.

this drasticly decreases cpu usage by opencvs on very large trees (like src).

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.169 2007/01/13 16:03:53 joris Exp $	*/
d345 1
a345 1
	int l;
a440 6
			if (!(cr->flags & CR_RECURSE_DIRS) &&
			    dp->d_type == DT_DIR) {
				cp += dp->d_reclen;
				continue;
			}

d447 3
a449 4
			 * Anticipate the file type to sort them,
			 * note that we do not determine the final
			 * type until we actually have the fd floating
			 * around.
d451 36
a486 1
			if (dp->d_type == DT_DIR)
d488 2
a489 1
			else if (dp->d_type == DT_REG)
d491 5
@


1.169
log
@make a copy of cf->file_ent->ce_rev in cf->file_rcsrev when needed
otherwise we might get a NULL dereference when free'ing the
cf struct with cvs_file_free()
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.168 2007/01/12 23:32:01 niallo Exp $	*/
d669 1
a669 1
		b1 = rcs_rev_getbuf(cf->file_rcs, cf->file_rcsrev);
a671 2

		b1 = rcs_kwexp_buf(b1, cf->file_rcs, cf->file_rcsrev);
@


1.168
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.167 2007/01/12 19:28:12 joris Exp $	*/
d645 4
a648 3
	else if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL)
		cf->file_rcsrev = cf->file_ent->ce_rev;
	else if (cf->file_rcs != NULL)
@


1.167
log
@do not leak memory from rcs_head_get()

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.166 2007/01/10 21:32:19 xsa Exp $	*/
d668 1
a668 1
		b1 = rcs_getrev(cf->file_rcs, cf->file_rcsrev);
@


1.166
log
@add a cvs_file_copy routine and use it for the edit command to
copy the file in the current working directory to CVS/Base/
ok ray@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.165 2007/01/06 17:09:08 xsa Exp $	*/
d831 2
@


1.165
log
@add cvs_base_handle() routine to handle the CVS/Baserev* files.
first bits for the edit command for now.
definitly still more work to do for optimization...
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.164 2007/01/05 07:13:49 xsa Exp $	*/
d909 82
@


1.164
log
@- introduce file comparison routine, cvs_file_cmp().
- compare the <file> in working dir and the one in CVS/Base/<file>
  for the unedit command.
hints otto@@, input and ok ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.163 2006/10/25 20:52:34 moritz Exp $	*/
a70 2
static int	cvs_file_cmpname(const char *, const char *);

d844 1
a844 1
static int
@


1.163
log
@Check len to be > 0 before accessing buf[len-1] and check if the
last character in the string returned by fgets(3) is '\n' before
blindly overwriting it.

OK and input from xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.162 2006/07/07 17:37:17 joris Exp $	*/
d30 2
d851 62
@


1.162
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.161 2006/06/19 05:05:17 joris Exp $	*/
d104 2
a106 4
			if (buf[len - 1] != '\n')
				cvs_log(LP_ERR, "line too long in `%s'", path);

			buf[--len] = '\0';
d397 1
a397 1
		while (fgets(fpath, MAXPATHLEN, fp)) {
d399 2
@


1.161
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.160 2006/06/14 20:28:53 joris Exp $	*/
d282 1
a282 1
		} else {
@


1.160
log
@simplify cvs_hack_time() and the way it is called;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.159 2006/06/14 14:10:50 joris Exp $	*/
d326 2
a327 2
			if (cr->local != NULL)
				cr->local(cf);
d367 2
a368 2
	if (cr->local != NULL)
		cr->local(cf);
@


1.159
log
@add cvs_buf_load_fd() which does the same as cvs_buf_load()
except it takes a decriptor as argument instead of a path.

modified cvs_buf_load() to open the descriptor then pass
it to cvs_buf_load_fd().

change all the calls to cvs_buf_load() that have a descriptor
open for the path to cvs_buf_load_fd() to prevent races.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.158 2006/06/03 19:07:13 joris Exp $	*/
a662 3
		if (mtime == 0)
			fatal("to gmt failed");

@


1.158
log
@add support for update -A and update -r<rev>.
hacking on the plane from toronto to barbados.

i will probably hack some more since im stuck in barbados
for 12 lovely hours over night cause the carribean airlines dont understand
the meaning over 'more than one flight a day'.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.157 2006/06/02 19:10:23 david Exp $	*/
d677 1
a677 2
		/* XXX */
		b2 = cvs_buf_load(cf->file_path, BUF_AUTOEXT);
@


1.157
log
@various spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.156 2006/06/01 20:00:52 joris Exp $	*/
d645 2
@


1.156
log
@major rewrite of some rcs parsing stuff:

- rework rcs_getrev() to correctly support branches
- rework rcs_translate_tag() to correctly translate given symbols or
  branches into their matching revisions
- rework rcs_rev_add() to correctly update its 'next' pointers
  and insert the new revision in the correct place on the list.
- rework rcs_head_get() to return the latest revision on the default
  branch if it has been set or the normal HEAD revision otherwise.
- no longer access the rf_head member of the RCSFILE struct manually,
  use the rcs_head_get() function which correctly returns the HEAD
  revision, there might be a default branch that has to be used.
- for now, when commiting a new revision reset the default branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.155 2006/05/31 01:26:22 joris Exp $	*/
d735 1
a735 1
				    "warning: new-born %s has dissapeared",
@


1.155
log
@allow commit to ressurect added files that exist in Attic/
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.154 2006/05/30 22:06:13 joris Exp $	*/
d610 1
d646 1
a646 1
		cf->file_rcsrev = cf->file_rcs->rf_head;
@


1.154
log
@only look into the Attic for certain commands
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.153 2006/05/30 21:32:52 joris Exp $	*/
d621 1
a621 3
	} else if (cvs_cmdop != CVS_OP_UPDATE && cvs_cmdop != CVS_OP_CHECKOUT
	    && cvs_cmdop != CVS_OP_COMMIT) {
		xfree(cf->file_rpath);
d627 1
a627 3
		cf->file_rpath = xstrdup(rcsfile);

		cf->repo_fd = open(cf->file_rpath, O_RDONLY);
d629 2
@


1.153
log
@fill in the correct revision number we will want in file_rcsrev
for each cvs_file struct, this will help us with sticky tags,
commiting to branches and importing into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.152 2006/05/30 19:16:51 joris Exp $	*/
d621 2
a622 1
	} else {
d641 2
a642 1
	}
@


1.152
log
@look inside the Attic if a specified RCS file cannot be found
in the normal repository, and a way to identify an RCS file in
the Attic in the RCSFILE struct.
will come in handy later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.151 2006/05/30 07:00:30 joris Exp $	*/
d540 1
a540 1
cvs_file_classify(struct cvs_file *cf, int loud)
d642 7
d651 2
a652 2
	if (cf->file_rcs != NULL)
		rcsnum_tostr(cf->file_rcs->rf_head, r2, sizeof(r2));
d668 1
a668 1
		b1 = rcs_getrev(cf->file_rcs, cf->file_rcs->rf_head);
d672 1
a672 1
		b1 = rcs_kwexp_buf(b1, cf->file_rcs, cf->file_rcs->rf_head);
d687 1
a687 1
		state = rcs_state_get(cf->file_rcs, cf->file_rcs->rf_head);
@


1.151
log
@hello import, only works for non-existing repositories right now,
but work is in progress for importing stuff into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.150 2006/05/29 06:05:56 joris Exp $	*/
d619 2
a620 2
			fatal("cvs_file_classify: rcs_open failed while it "
			    "shouldn't");
d622 18
a639 1
		cf->file_rcs = NULL;
@


1.150
log
@i was wrong adding ".*" to the default ignore patterns,
so remove it from there again.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.149 2006/05/29 05:06:03 joris Exp $	*/
d376 2
a377 1
	 * If we do not have a admin directory inside here, dont bother.
d385 2
a386 1
	if (l == -1 || (l == 0 && !S_ISDIR(st.st_mode))) {
a558 1
	entlist = cvs_ent_open(cf->file_wd);
d576 2
@


1.149
log
@if the timestamp of the file has changed and
no longer matches the timestamp in the CVS/Entries file, be
sure to compare the file contents to the revision contents to
be positive the file actually changed.

otherwise we would see a file as modified if somebody
would for example open it in vi and simply :wq it.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.148 2006/05/28 23:38:42 pedro Exp $	*/
a43 1
	".*",
@


1.148
log
@Fix engrish, okay joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.147 2006/05/28 21:11:12 joris Exp $	*/
d544 1
d639 19
@


1.147
log
@add basic 'cvs log' support.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.146 2006/05/28 17:25:18 joris Exp $	*/
d580 1
a580 1
			fatal("%s is suppose to be a directory, but it is not",
d584 1
a584 1
			fatal("%s is suppose to be a file, but it is not",
@


1.146
log
@several fixes to the file api:
- default to CVS_FILE when something is totally unknown
- cvs_get_repository_path() now returns the full repository path for
  the given argument.
- cvs_get_repository_name() returns the contents of CVS/Repository
  to the caller.
- allow command callbacks to specify if our recursion code needs
  to skip the directory or not.
- when checking for a admin directory, make sure it is in fact
  a directory. if it is not we dont want to recurse inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.145 2006/05/28 10:14:59 joris Exp $	*/
d602 10
a611 1
	rflags = 0;
@


1.145
log
@add rf_dead field to RCSFILE which can tell us
if an RCSFILE is dead, will come in usefull later in commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.144 2006/05/28 08:49:01 joris Exp $	*/
d264 1
d289 1
a289 1
			cvs_get_repo(d, repo, MAXPATHLEN);
d371 3
d384 2
a385 1
	if (stat(fpath, &st) == -1) {
d502 1
a502 1
		cvs_get_repo(cf->file_path, repo, MAXPATHLEN);
d562 1
a562 1
	cvs_get_repo(cf->file_wd, repo, MAXPATHLEN);
@


1.144
log
@if we run into a file that was suppose to be a directory
or a directory that is suppose to be a file, abort right away
because something bad probably happened.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.143 2006/05/28 07:56:44 joris Exp $	*/
d633 2
@


1.143
log
@allow commands to shut up the output from cvs_file_classify
if the commands want to output certain stuff themselfs
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.142 2006/05/27 20:56:39 joris Exp $	*/
d572 11
d588 3
@


1.142
log
@more standard ignore pattern
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.141 2006/05/27 15:15:43 joris Exp $	*/
d534 1
a534 1
cvs_file_classify(struct cvs_file *cf)
d539 1
a539 1
	int rflags, l, ismodified, rcsdead;
d551 1
d629 1
a629 1
				if (verbosity > 1)
d634 1
a634 1
				if (verbosity > 1)
d645 4
a648 3
				cvs_log(LP_NOTICE,
				    "use add to create an entry for %s",
				    cf->file_path);
d656 1
a656 1
			if (verbosity > 1)
d664 1
a664 1
			if (verbosity > 1)
d672 1
a672 1
			if (verbosity > 1)
d681 1
a681 1
				if (verbosity > 1)
d694 1
a694 1
				if (verbosity > 1)
d704 1
a704 1
					if (verbosity > 1)
d712 1
a712 1
					if (verbosity > 1)
d723 1
a723 1
				if (verbosity > 1)
@


1.141
log
@remove debug output
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.140 2006/05/27 15:14:27 joris Exp $	*/
d44 1
@


1.140
log
@allow commands to respect the -l flag, if the -l flag is
specified certain commands will not recurse into directories.

at the same time introduce a method of specifying wether or not
a command should look in the repository for files.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.139 2006/05/27 06:15:50 joris Exp $	*/
a435 1
				printf("Skipping %s\n", dp->d_name);
@


1.139
log
@use RCS_STATE_DEAD instead of plain old 'dead' when checking
the RCS file its state.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.138 2006/05/27 03:30:30 joris Exp $	*/
a368 1
	repo = xmalloc(MAXPATHLEN);
a379 1
		xfree(repo);
d434 7
d481 4
d495 4
a498 2
	cvs_get_repo(cf->file_path, repo, MAXPATHLEN);
	cvs_repository_lock(repo);
d500 3
a502 1
	cvs_repository_getdir(repo, cf->file_path, &fl, &dl);
d507 4
a510 1
	cvs_repository_unlock(repo);
a514 1
	xfree(repo);
@


1.138
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.137 2006/04/14 02:45:35 deraadt Exp $	*/
d601 1
a601 1
		if (!strcmp(state, "dead"))
@


1.137
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.136 2006/04/05 01:38:55 ray Exp $	*/
d3 1
a37 7
/* ignore pattern */
struct cvs_ignpat {
	char				ip_pat[MAXNAMLEN];
	int				ip_flags;
	TAILQ_ENTRY(cvs_ignpat)		ip_list;
};

a44 1
	"*.so",
a63 10
#ifdef OLD_SMELLY_CRUFT
	"RCSLOG",
	"tags",
	"TAGS",
	"RCS",
	"SCCS",
	"cvslog.*",	/* to ignore CVS_CLIENT_LOG output */
	"#*",
	",*",
#endif
d66 2
a67 7
/*
 * Entries in the CVS/Entries file with a revision of '0' have only been
 * added.  Compare against this revision to see if this is the case
 */
static RCSNUM *cvs_addedrev;

TAILQ_HEAD(, cvs_ignpat)	cvs_ign_pats;
d69 1
a69 2
static int cvs_file_getdir(CVSFILE *, int, int (*)(CVSFILE *, void *),
    void *, int);
d71 1
a71 13
static int	 cvs_load_dirinfo(CVSFILE *, int);
static int	 cvs_file_sort(struct cvs_flist *, u_int);
static int	 cvs_file_cmp(const void *, const void *);
static int	 cvs_file_cmpname(const char *, const char *);
static CVSFILE	*cvs_file_alloc(const char *, u_int);
static CVSFILE	*cvs_file_lget(const char *, int, CVSFILE *, CVSENTRIES *,
		    struct cvs_ent *);

/*
 * cvs_file_init()
 *
 */
int
d75 1
d77 4
a80 2
	char path[MAXPATHLEN], buf[MAXNAMLEN];
	FILE *ifp;
d83 1
a83 3

	if ((cvs_addedrev = rcsnum_parse("0")) == NULL)
		return (-1);
d87 1
a87 1
		cvs_file_ignore(cvs_ign_std[i]);
d90 3
a92 6
	l = snprintf(path, sizeof(path), "%s/.cvsignore", cvs_homedir);
	if (l == -1 || l >= (int)sizeof(path)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", path);
		return (-1);
	}
d100 1
a100 1
		while (fgets(buf, (int)sizeof(buf), ifp) != NULL) {
d104 2
a105 1
			if (buf[len - 1] != '\n') {
d107 1
a107 1
			}
d109 1
a109 1
			cvs_file_ignore(buf);
d111 1
d115 2
a116 1
	return (0);
d119 2
a120 8
/*
 * cvs_file_ignore()
 *
 * Add the pattern <pat> to the list of patterns for files to ignore.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_file_ignore(const char *pat)
d123 1
d127 3
a129 1
	strlcpy(ip->ip_pat, pat, sizeof(ip->ip_pat));
d140 1
a140 3
	TAILQ_INSERT_TAIL(&cvs_ign_pats, ip, ip_list);

	return (0);
a142 6
/*
 * cvs_file_chkign()
 *
 * Returns 1 if the filename <file> is matched by one of the ignore
 * patterns, or 0 otherwise.
 */
d161 8
d172 2
a173 10
/*
 * cvs_file_create()
 *
 * Create a new file whose path is specified in <path> and of type <type>.
 * If the type is DT_DIR, the CVS administrative repository and files will be
 * created.
 * Returns the created file on success, or NULL on failure.
 */
CVSFILE *
cvs_file_create(CVSFILE *parent, const char *path, u_int type, mode_t mode)
d175 2
a176 18
	int fd, l;
	char fp[MAXPATHLEN], repo[MAXPATHLEN];
	CVSFILE *cfp;

	cfp = cvs_file_alloc(path, type);
	if (cfp == NULL)
		return (NULL);

	l = 0;
	cfp->cf_mode = mode;
	cfp->cf_parent = parent;

	if (type == DT_DIR) {
		cfp->cf_root = cvsroot_get(path);
		if (cfp->cf_root == NULL) {
			cvs_file_free(cfp);
			return (NULL);
		}
d178 1
a178 15
		if (cvs_repo_base != NULL) {
			cvs_file_getpath(cfp, fp, sizeof(fp));
			l = snprintf(repo, sizeof(repo), "%s/%s", cvs_repo_base,
			    fp);
		} else {
			cvs_file_getpath(cfp, repo, sizeof(repo));
			l = 0;
		}

		if (l == -1 || l >= (int)sizeof(repo)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", repo);
			cvs_file_free(cfp);
			return (NULL);
		}
d180 2
a181 15
		cfp->cf_repo = xstrdup(repo);
		if ((mkdir(path, mode) == -1 && errno != EEXIST) ||
		    cvs_mkadmin(path, cfp->cf_root->cr_str, cfp->cf_repo,
		    NULL, NULL, 0) < 0) {
			cvs_file_free(cfp);
			return (NULL);
		}
	} else {
		fd = open(path, O_WRONLY|O_CREAT|O_EXCL, mode);
		if (fd == -1) {
			cvs_file_free(cfp);
			return (NULL);
		}
		(void)close(fd);
	}
d183 2
a184 1
	return (cfp);
d187 5
d193 2
a194 16
/*
 * cvs_file_copy()
 *
 * Allocate space to create a copy of the file <orig>.  The copy inherits all
 * of the original's attributes, but does not inherit its children if the
 * original file is a directory.  Note that files copied using this mechanism
 * are linked to their parent, but the parent has no link to the file.  This
 * is so cvs_file_getpath() works.
 * Returns the copied file on success, or NULL on failure.  The returned
 * structure should be freed using cvs_file_free().
 */
CVSFILE *
cvs_file_copy(CVSFILE *orig)
{
	char path[MAXPATHLEN];
	CVSFILE *cfp;
d196 3
a198 1
	cvs_file_getpath(orig, path, sizeof(path));
d200 2
a201 14
	cfp = cvs_file_alloc(path, orig->cf_type);
	if (cfp == NULL)
		return (NULL);

	cfp->cf_parent = orig->cf_parent;
	cfp->cf_mode = orig->cf_mode;
	cfp->cf_cvstat = orig->cf_cvstat;

	if (orig->cf_type == DT_REG) {
		cfp->cf_etime = orig->cf_etime;
		cfp->cf_mtime = orig->cf_mtime;
	} else if (orig->cf_type == DT_DIR) {
		/* XXX copy CVS directory attributes */
	}
d203 2
a204 1
	return (cfp);
d207 6
d214 1
a214 15
/*
 * cvs_file_get()
 *
 * Load a cvs_file structure with all the information pertaining to the file
 * <path>.
 * The <flags> parameter specifies various flags that alter the behaviour of
 * the function.  The CF_RECURSE flag causes the function to recursively load
 * subdirectories when <path> is a directory.
 * The CF_SORT flag causes the files to be sorted in alphabetical order upon
 * loading.  The special case of "." as a path specification generates
 * recursion for a single level and is equivalent to calling cvs_file_get() on
 * all files of that directory.
 * Returns a pointer to the cvs file structure, which must later be freed
 * with cvs_file_free().
 */
d216 18
a233 5
int
cvs_file_get(const char *path, int flags, int (*cb)(CVSFILE *, void *),
    void *arg, struct cvs_flist *list)
{
	char *files[1];
d235 2
a236 2
	*(const char **)files = path;
	return cvs_file_getspec(files, 1, flags, cb, arg, list);
d239 2
a240 9

/*
 * cvs_file_getspec()
 *
 * Obtain the info about the supplied files or directories.
 */
int
cvs_file_getspec(char **fspec, int fsn, int flags, int (*cb)(CVSFILE *, void *),
    void *arg, struct cvs_flist *list)
d242 27
a268 11
	int i, freecf;
	char pcopy[MAXPATHLEN];
	CVSFILE *cf;
	extern char *cvs_rootstr;

	freecf = (list == NULL);
	cvs_error = CVS_EX_DATA;

	/* init the list */
	if (list != NULL)
		SIMPLEQ_INIT(list);
d270 16
a285 9
	/*
	 * Fetch the needed information about ".", so we can setup a few
	 * things to get ourselfs going.
	 */
	cf = cvs_file_lget(".", 0, NULL, NULL, NULL);
	if (cf == NULL) {
		cvs_log(LP_ERR, "failed to obtain '.' information");
		return (-1);
	}
d287 10
a296 9
	/*
	 * save the base repository path so we can use it to create
	 * the correct full repopath later on.
	 */
	if (cf->cf_repo != NULL) {
		if (cvs_repo_base != NULL)
			xfree(cvs_repo_base);
		cvs_repo_base = xstrdup(cf->cf_repo);
	}
d298 22
a319 6
	/*
	 * This will go away when we have support for multiple Roots.
	 */
	if (cvs_rootstr == NULL && cf->cf_root != NULL) {
		cvs_rootstr = xstrdup(cf->cf_root->cr_str);
	}
d321 6
a326 11
	cvs_error = CVS_EX_OK;

	/*
	 * Since some commands don't require any files to operate
	 * we can stop right here for those.
	 */
	if (cf->cf_root != NULL) {
		if (cf->cf_root->cr_method != CVS_METHOD_LOCAL &&
		    cvs_cmdop == CVS_OP_CHECKOUT) {
			cvs_file_free(cf);
			return (0);
a327 6
	}

	cvs_file_free(cf);

	if (cvs_cmdop == CVS_OP_VERSION)
		return (0);
d329 1
a329 2
	for (i = 0; i < fsn; i++) {
		strlcpy(pcopy, fspec[i], sizeof(pcopy));
d331 3
a333 14
		/*
		 * get rid of any trailing slashes.
		 */
		STRIP_SLASH(pcopy);

		/*
		 * Load the information.
		 */
		cf = cvs_file_loadinfo(pcopy, flags, cb, arg, freecf);
		if (cf == NULL) {
			if (cvs_error != CVS_EX_OK)
				return (-1);
			continue;
		}
d335 2
a336 17
		/*
		 * If extra actions are needed, do them now.
		 */
		if (cf->cf_type == DT_DIR) {
			/* do possible extra actions .. */
		} else {
			/* do possible extra actions .. */
		}

		/*
		 * Attach it to a list if requested, otherwise
		 * just free it again.
		 */
		if (list != NULL)
			SIMPLEQ_INSERT_TAIL(list, cf, cf_list);
		else
			cvs_file_free(cf);
d339 2
a340 1
	return (0);
d343 2
a344 14
/*
 * Load the neccesary information about file or directory <path>.
 * Returns a pointer to the loaded information on success, or NULL
 * on failure.
 *
 * If cb is not NULL, the requested path will be passed to that callback
 * with <arg> as an argument.
 *
 * the <freecf> argument is passed to cvs_file_getdir, if this is 1
 * CVSFILE * structs will be free'd once we are done with them.
 */
CVSFILE *
cvs_file_loadinfo(char *path, int flags, int (*cb)(CVSFILE *, void *),
    void *arg, int freecf)
d346 8
a353 2
	CVSFILE *cf, *base;
	CVSENTRIES *entf;
d355 5
a359 5
	char *p;
	char parent[MAXPATHLEN], item[MAXPATHLEN];
	int type, callit;
	struct stat st;
	struct cvsroot *root;
d361 1
a361 4
	type = 0;
	base = cf = NULL;
	entf = NULL;
	ent = NULL;
d363 2
a364 8
	/*
	 * We first have to find out what type of item we are
	 * dealing with. A file or a directory.
	 *
	 * We can do this by stat(2)'ing the item, but since it
	 * might be gone we also check the Entries file in the
	 * parent directory.
	 */
d366 2
a367 10
	/* get parent directory */
	if ((p = strrchr(path, '/')) != NULL) {
		*p++ = '\0';
		strlcpy(parent, path, sizeof(parent));
		strlcpy(item, p, sizeof(item));
		*--p = '/';
	} else {
		strlcpy(parent, ".", sizeof(parent));
		strlcpy(item, path, sizeof(item));
	}
d369 2
a370 11
	/*
	 * There might not be an Entries file, so do not fail if there
	 * is none available to get the info from.
	 */
	entf = cvs_ent_open(parent, O_RDWR);

	/*
	 * Load the Entry if we successfully opened the Entries file.
	 */
	if (entf != NULL)
		ent = cvs_ent_get(entf, item);
d373 1
a373 2
	 * No Entry available? fall back to stat(2)'ing the item, if
	 * that fails, assume a normal file.
d375 4
a378 11
	if (ent == NULL) {
		if (stat(path, &st) == -1)
			type = DT_REG;
		else
			type = IFTODT(st.st_mode);
	} else {
		if (ent->ce_type == CVS_ENT_DIR)
			type = DT_DIR;
		else
			type = DT_REG;
	}
d380 4
a383 14
	/*
	 * Get the base, which is <parent> for a normal file or
	 * <path> for a directory.
	 */
	if (type == DT_DIR)
		base = cvs_file_lget(path, flags, NULL, entf, ent);
	else
		base = cvs_file_lget(parent, flags, NULL, entf, NULL);

	if (base == NULL) {
		cvs_log(LP_ERR, "failed to obtain directory info for '%s'",
		    parent);
		cvs_error = CVS_EX_FILE;
		goto fail;
d387 1
a387 1
	 * Sanity.
d389 3
a391 4
	if (base->cf_type != DT_DIR) {
		cvs_log(LP_ERR, "base directory isn't a directory at all");
		goto fail;
	}
d393 5
a397 5
	root = CVS_DIR_ROOT(base);
	if (root == NULL) {
		cvs_error = CVS_EX_BADROOT;
		goto fail;
	}
d399 1
a399 9
	/*
	 * If we have a normal file, get the info and link it
	 * to the base.
	 */
	if (type != DT_DIR) {
		cf = cvs_file_lget(path, flags, base, entf, ent);
		if (cf == NULL) {
			cvs_error = CVS_EX_DATA;
			goto fail;
d402 1
a402 1
		cvs_file_attach(base, cf);
d405 3
a407 23
	/*
	 * Always pass the base directory, unless:
	 * - we are running in server or local mode and the path is not "."
	 * - the directory does not exist on disk.
	 * - the callback is NULL.
	*/
	callit = 1;
	if (cb == NULL)
		callit = 0;

	if (cvs_cmdop == CVS_OP_SERVER && type != DT_DIR)
		callit = 0;

	if (root->cr_method == CVS_METHOD_LOCAL && type != DT_DIR)
		callit = 0;

	if (!(base->cf_flags & CVS_FILE_ONDISK))
		callit = 0;

	if (callit != 0) {
		if ((cvs_error = cb(base,arg)) != CVS_EX_OK)
			goto fail;
	}
d409 3
a411 16
	/*
	 * If we have a normal file, pass it as well.
	 */
	if (type != DT_DIR) {
		if (cb != NULL && (cvs_error = cb(cf, arg)) != CVS_EX_OK)
			goto fail;
	} else {
		/*
		 * If the directory exists, recurse through it.
		 */
		if ((base->cf_flags & CVS_FILE_ONDISK) &&
		    cvs_file_getdir(base, flags, cb, arg, freecf) < 0) {
			cvs_error = CVS_EX_FILE;
			goto fail;
		}
	}
d413 3
a415 4
	if (entf != NULL) {
		cvs_ent_close(entf);
		entf = NULL;
	}
d417 3
a419 1
	return (base);
d421 9
a429 20
fail:
	if (entf != NULL)
		cvs_ent_close(entf);
	if (base != NULL)
		cvs_file_free(base);
	return (NULL);
}

/*
 * cvs_file_find()
 *
 * Find the pointer to a CVS file entry within the file hierarchy <hier>.
 * The file's pathname <path> must be relative to the base of <hier>.
 * Returns the entry on success, or NULL on failure.
 */
CVSFILE *
cvs_file_find(CVSFILE *hier, const char *path)
{
	char *pp, *sp, pbuf[MAXPATHLEN];
	CVSFILE *sf, *cf;
d431 2
a432 19
	strlcpy(pbuf, path, sizeof(pbuf));

	cf = hier;
	pp = pbuf;
	do {
		sp = strchr(pp, '/');
		if (sp != NULL)
			*(sp++) = '\0';

		/* special case */
		if (*pp == '.') {
			if (*(pp + 1) == '.' && *(pp + 2) == '\0') {
				/* request to go back to parent */
				if (cf->cf_parent == NULL) {
					cvs_log(LP_NOTICE,
					    "path %s goes back too far", path);
					return (NULL);
				}
				cf = cf->cf_parent;
d434 1
a434 3
			} else if (*(pp + 1) == '\0')
				continue;
		}
d436 4
a439 12
		SIMPLEQ_FOREACH(sf, &(cf->cf_files), cf_list)
			if (cvs_file_cmpname(pp, sf->cf_name) == 0)
				break;
		if (sf == NULL)
			return (NULL);

		cf = sf;
		pp = sp;
	} while (sp != NULL);

	return (cf);
}
d441 10
d452 2
a453 15
/*
 * cvs_file_getpath()
 *
 * Get the full path of the file <file> and store it in <buf>, which is of
 * size <len>.  For portability, it is recommended that <buf> always be
 * at least MAXPATHLEN bytes long.
 * Returns a pointer to the start of the path.
 */
char *
cvs_file_getpath(CVSFILE *file, char *buf, size_t len)
{
	memset(buf, '\0', len);
	if (file->cf_dir != NULL) {
		strlcat(buf, file->cf_dir, len);
		strlcat(buf, "/", len);
d456 3
a458 22
	strlcat(buf, file->cf_name, len);
	return (buf);
}

/*
 * cvs_file_attach()
 *
 * Attach the file <file> as one of the children of parent <parent>, which
 * has to be a file of type DT_DIR.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_file_attach(CVSFILE *parent, CVSFILE *file)
{
	if (parent->cf_type != DT_DIR)
		return (-1);

	SIMPLEQ_INSERT_TAIL(&(parent->cf_files), file, cf_list);
	file->cf_parent = parent;

	return (0);
}
d460 1
d462 3
a464 24
/*
 * Load directory information
 */
static int
cvs_load_dirinfo(CVSFILE *cf, int flags)
{
	char fpath[MAXPATHLEN];
	char pbuf[MAXPATHLEN];
	struct stat st;
	int l;

	cvs_file_getpath(cf, fpath, sizeof(fpath));

	/*
	 * Try to obtain the Root for this given directory, if we cannot
	 * get it, fail, unless we are dealing with a directory that is
	 * unknown or not on disk.
	 */
	cf->cf_root = cvsroot_get(fpath);
	if (cf->cf_root == NULL) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN ||
		    !(cf->cf_flags & CVS_FILE_ONDISK))
			return (0);
		return (-1);
d467 3
a469 7
	/* if the CVS administrative directory exists, load the info */
	l = snprintf(pbuf, sizeof(pbuf), "%s/" CVS_PATH_CVSDIR, fpath);
	if (l == -1 || l >= (int)sizeof(pbuf)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", pbuf);
		return (-1);
	}
d471 4
a474 17
	if (stat(pbuf, &st) == 0 && S_ISDIR(st.st_mode)) {
		if (cvs_readrepo(fpath, pbuf, sizeof(pbuf)) == 0)
			cf->cf_repo = xstrdup(pbuf);
	} else {
		/*
		 * Fill in the repo path ourselfs.
		 */
		if (cvs_repo_base != NULL) {
			l = snprintf(pbuf, sizeof(pbuf), "%s/%s",
			    cvs_repo_base, fpath);
			if (l == -1 || l >= (int)sizeof(pbuf))
				return (-1);

			cf->cf_repo = xstrdup(pbuf);
		} else
			cf->cf_repo = NULL;
	}
d476 4
a479 2
	return (0);
}
d481 1
a481 40
/*
 * cvs_file_getdir()
 *
 * Get a cvs directory structure for the directory whose path is <dir>.
 * This function should not free the directory information on error, as this
 * is performed by cvs_file_free().
 */
static int
cvs_file_getdir(CVSFILE *cf, int flags, int (*cb)(CVSFILE *, void *),
    void *arg, int freecf)
{
	int ret;
	size_t len;
	DIR *dp;
	struct dirent *de;
	char fpath[MAXPATHLEN], pbuf[MAXPATHLEN];
	CVSENTRIES *entf;
	CVSFILE *cfp;
	struct cvs_ent *ent;
	struct cvs_flist dirs;
	int nfiles, ndirs;

	if ((flags & CF_KNOWN) && cf->cf_cvstat == CVS_FST_UNKNOWN)
		return (0);

	/*
	 * if we are working with a repository, fiddle with
	 * the pathname again.
	 */
	if (flags & CF_REPO) {
		ret = snprintf(fpath, sizeof(fpath), "%s%s%s",
		    cf->cf_root->cr_dir,
		    (cf->cf_dir != NULL) ? "/" : "",
		    (cf->cf_dir != NULL) ? cf->cf_dir : "");
		if (ret == -1 || ret >= (int)sizeof(fpath))
			return (-1);

		if (cf->cf_dir != NULL)
			xfree(cf->cf_dir);
		cf->cf_dir = xstrdup(fpath);
d484 1
a484 8
	nfiles = ndirs = 0;
	SIMPLEQ_INIT(&dirs);
	cvs_file_getpath(cf, fpath, sizeof(fpath));

	if ((dp = opendir(fpath)) == NULL) {
		cvs_log(LP_ERRNO, "failed to open directory '%s'", fpath);
		return (-1);
	}
d486 2
a487 73
	ret = -1;
	entf = cvs_ent_open(fpath, O_RDWR);
	while ((de = readdir(dp)) != NULL) {
		if (!strcmp(de->d_name, ".") ||
		    !strcmp(de->d_name, ".."))
			continue;

		len = cvs_path_cat(fpath, de->d_name, pbuf, sizeof(pbuf));
		if (len >= sizeof(pbuf))
			goto done;

		if (entf != NULL)
			ent = cvs_ent_get(entf, de->d_name);
		else
			ent = NULL;

		/*
		 * Do some filtering on the current directory item.
		 */
		if ((flags & CF_IGNORE) && cvs_file_chkign(de->d_name))
			continue;

		if (!(flags & CF_RECURSE) && (de->d_type == DT_DIR)) {
			if (ent != NULL)
				ent->processed = 1;
			continue;
		}

		if (de->d_type != DT_DIR && (flags & CF_NOFILES))
			continue;

		cfp = cvs_file_lget(pbuf, flags, cf, entf, ent);
		if (cfp == NULL) {
			cvs_log(LP_ERR, "failed to get '%s'", pbuf);
			goto done;
		}

		/*
		 * A file is linked to the parent <cf>, a directory
		 * is added to the dirs SIMPLEQ list for later use.
		 */
		if (cfp->cf_type != DT_DIR && !freecf) {
			SIMPLEQ_INSERT_TAIL(&(cf->cf_files), cfp, cf_list);
			nfiles++;
		} else if (cfp->cf_type == DT_DIR) {
			SIMPLEQ_INSERT_TAIL(&dirs, cfp, cf_list);
			ndirs++;
		}

		/*
		 * Now, for a file, pass it to the callback if it was
		 * supplied to us.
		 */
		if (cfp->cf_type != DT_DIR && cb != NULL) {
			if ((cvs_error = cb(cfp, arg)) != CVS_EX_OK)
				goto done;
		}

		/*
		 * Mark the entry as processed.
		 */
		if (ent != NULL)
			ent->processed = 1;

		/*
		 * If we don't want to keep it, free it
		 */
		if (cfp->cf_type != DT_DIR && freecf)
			cvs_file_free(cfp);
	}

	closedir(dp);
	dp = NULL;
d489 1
a489 23
	/*
	 * Pass over all of the entries now, so we pickup any files
	 * that might have been lost, or are for some reason not on disk.
	 *
	 * (Follows the same procedure as above ... can we merge them?)
	 */
	while (entf != NULL && (ent = cvs_ent_next(entf)) != NULL) {
		if (ent->processed == 1)
			continue;
		if (!(flags & CF_RECURSE) && ent->ce_type == CVS_ENT_DIR)
			continue;
		if ((flags & CF_NOFILES) && ent->ce_type != CVS_ENT_DIR)
			continue;

		len = cvs_path_cat(fpath, ent->ce_name, pbuf, sizeof(pbuf));
		if (len >= sizeof(pbuf))
			goto done;

		cfp = cvs_file_lget(pbuf, flags, cf, entf, ent);
		if (cfp == NULL) {
			cvs_log(LP_ERR, "failed to fetch '%s'", pbuf);
			goto done;
		}
d491 2
a492 7
		if (cfp->cf_type != DT_DIR && !freecf) {
			SIMPLEQ_INSERT_TAIL(&(cf->cf_files), cfp, cf_list);
			nfiles++;
		} else if (cfp->cf_type == DT_DIR) {
			SIMPLEQ_INSERT_TAIL(&dirs, cfp, cf_list);
			ndirs++;
		}
d494 1
a494 4
		if (cfp->cf_type != DT_DIR && cb != NULL) {
			if ((cvs_error = cb(cfp, arg)) != CVS_EX_OK)
				goto done;
		}
d496 2
a497 3
		if (cfp->cf_type != DT_DIR && freecf)
			cvs_file_free(cfp);
	}
d499 2
a500 9
	/*
	 * Sort files and dirs if requested.
	 */
	if (flags & CF_SORT) {
		if (nfiles > 0)
			cvs_file_sort(&(cf->cf_files), nfiles);
		if (ndirs > 0)
			cvs_file_sort(&dirs, ndirs);
	}
d502 2
a503 44
	/*
	 * Finally, run over the directories we have encountered.
	 * Before calling cvs_file_getdir() on them, we pass them
	 * to the callback first.
	 */
	while (!SIMPLEQ_EMPTY(&dirs)) {
		cfp = SIMPLEQ_FIRST(&dirs);
		SIMPLEQ_REMOVE_HEAD(&dirs, cf_list);

		if (!freecf)
			SIMPLEQ_INSERT_TAIL(&(cf->cf_files), cfp, cf_list);

		if (cb != NULL) {
			if ((cvs_error = cb(cfp, arg)) != CVS_EX_OK)
				goto done;
		}

		if ((cfp->cf_flags & CVS_FILE_ONDISK) &&
		    cvs_file_getdir(cfp, flags, cb, arg, freecf) < 0)
			goto done;

		if (freecf)
			cvs_file_free(cfp);
	}

	ret = 0;
	cfp = NULL;
done:
	if (cfp != NULL && freecf)
		cvs_file_free(cfp);

	while (!SIMPLEQ_EMPTY(&dirs)) {
		cfp = SIMPLEQ_FIRST(&dirs);
		SIMPLEQ_REMOVE_HEAD(&dirs, cf_list);

		cvs_file_free(cfp);
	}

	if (entf != NULL)
		cvs_ent_close(entf);
	if (dp != NULL)
		closedir(dp);

	return (ret);
a505 6

/*
 * cvs_file_free()
 *
 * Free a cvs_file structure and its contents.
 */
d507 1
a507 1
cvs_file_free(CVSFILE *cf)
d509 1
a509 4
	CVSFILE *child;

	if (cf->cf_name != NULL)
		xfree(cf->cf_name);
d511 4
a514 18
	if (cf->cf_dir != NULL)
		xfree(cf->cf_dir);

	if (cf->cf_type == DT_DIR) {
		if (cf->cf_root != NULL)
			cvsroot_remove(cf->cf_root);
		if (cf->cf_repo != NULL)
			xfree(cf->cf_repo);
		while (!SIMPLEQ_EMPTY(&(cf->cf_files))) {
			child = SIMPLEQ_FIRST(&(cf->cf_files));
			SIMPLEQ_REMOVE_HEAD(&(cf->cf_files), cf_list);
			cvs_file_free(child);
		}
	} else {
		if (cf->cf_tag != NULL)
			xfree(cf->cf_tag);
		if (cf->cf_opts != NULL)
			xfree(cf->cf_opts);
a515 2

	xfree(cf);
d518 2
a519 11

/*
 * cvs_file_sort()
 *
 * Sort a list of cvs file structures according to their filename.  The list
 * <flp> is modified according to the sorting algorithm.  The number of files
 * in the list must be given by <nfiles>.
 * Returns 0 on success, or -1 on failure.
 */
static int
cvs_file_sort(struct cvs_flist *flp, u_int nfiles)
d521 55
a575 22
	int i;
	size_t nb;
	CVSFILE *cf, **cfvec;

	cfvec = xcalloc((size_t)nfiles, sizeof(*cfvec));

	i = 0;
	SIMPLEQ_FOREACH(cf, flp, cf_list) {
		if (i == (int)nfiles) {
			cvs_log(LP_WARN, "too many files to sort");
			/* rebuild the list and abort sorting */
			while (--i >= 0)
				SIMPLEQ_INSERT_HEAD(flp, cfvec[i], cf_list);
			xfree(cfvec);
			return (-1);
		}
		cfvec[i++] = cf;

		/* now unlink it from the list,
		 * we'll put it back in order later
		 */
		SIMPLEQ_REMOVE_HEAD(flp, cf_list);
d578 4
a581 24
	/* clear the list just in case */
	SIMPLEQ_INIT(flp);
	nb = (size_t)i;

	heapsort(cfvec, nb, sizeof(cf), cvs_file_cmp);

	/* rebuild the list from the bottom up */
	for (i = (int)nb - 1; i >= 0; i--)
		SIMPLEQ_INSERT_HEAD(flp, cfvec[i], cf_list);

	xfree(cfvec);
	return (0);
}


static int
cvs_file_cmp(const void *f1, const void *f2)
{
	const CVSFILE *cf1, *cf2;
	cf1 = *(CVSFILE * const *)f1;
	cf2 = *(CVSFILE * const *)f2;
	return cvs_file_cmpname(cf1->cf_name, cf2->cf_name);
}

d583 4
a586 12
/*
 * cvs_file_alloc()
 *
 * Allocate a CVSFILE structure and initialize its internals.
 */
CVSFILE *
cvs_file_alloc(const char *path, u_int type)
{
	CVSFILE *cfp;
	char *p;

	cfp = xcalloc(1, sizeof(*cfp));
d588 3
a590 2
	cfp->cf_type = type;
	cfp->cf_cvstat = CVS_FST_UNKNOWN;
d592 2
a593 2
	if (type == DT_DIR) {
		SIMPLEQ_INIT(&(cfp->cf_files));
d596 7
a602 42
	cfp->cf_name = xstrdup(basename(path));
	if ((p = strrchr(path, '/')) != NULL) {
		*p = '\0';
		if (strcmp(path, "."))
			cfp->cf_dir = xstrdup(path);
		else
			cfp->cf_dir = NULL;
		*p = '/';
	} else
		cfp->cf_dir = NULL;

	return (cfp);
}


/*
 * cvs_file_lget()
 *
 * Get the file and link it with the parent right away.
 * Returns a pointer to the created file structure on success, or NULL on
 * failure.
 */
static CVSFILE *
cvs_file_lget(const char *path, int flags, CVSFILE *parent, CVSENTRIES *pent,
    struct cvs_ent *ent)
{
	char *c;
	int ret;
	u_int type;
	struct stat st;
	CVSFILE *cfp;
	struct cvsroot *root;

	type = DT_UNKNOWN;
	ret = stat(path, &st);
	if (ret == 0)
		type = IFTODT(st.st_mode);

	if ((flags & CF_REPO) && type != DT_DIR) {
		if ((c = strrchr(path, ',')) == NULL)
			return (NULL);
		*c = '\0';
d605 18
a622 34
	if ((cfp = cvs_file_alloc(path, type)) == NULL)
		return (NULL);
	cfp->cf_parent = parent;
	cfp->cf_entry = pent;

	if (cfp->cf_type == DT_DIR && cfp->cf_parent == NULL)
		cfp->cf_flags |= CVS_DIRF_BASE;

	if (ret == 0) {
		cfp->cf_mode = st.st_mode & ACCESSPERMS;
		if (cfp->cf_type == DT_REG)
			cfp->cf_mtime = st.st_mtime;
		cfp->cf_flags |= CVS_FILE_ONDISK;

		if (ent == NULL)
			if (cfp->cf_flags & CVS_DIRF_BASE)
				cfp->cf_cvstat = CVS_FST_UPTODATE;
			else
				cfp->cf_cvstat = CVS_FST_UNKNOWN;
		else {
			/* always show directories as up-to-date */
			if (ent->ce_type == CVS_ENT_DIR)
				cfp->cf_cvstat = CVS_FST_UPTODATE;
			else if (rcsnum_cmp(ent->ce_rev, cvs_addedrev, 2) == 0)
				cfp->cf_cvstat = CVS_FST_ADDED;
			else {
				/*
				 * correct st.st_mtime first
				 */
				if ((st.st_mtime =
				    cvs_hack_time(st.st_mtime, 1)) == 0) {
					cvs_file_free(cfp);
					return (NULL);
				}
d624 9
a632 6
				/* check last modified time */
				if (ent->ce_mtime == (time_t)st.st_mtime) {
					cfp->cf_cvstat = CVS_FST_UPTODATE;
				} else {
					cfp->cf_cvstat = CVS_FST_MODIFIED;
				}
d634 2
a635 2

			cfp->cf_etime = ent->ce_mtime;
d637 25
a661 5
	} else {
		if (ent == NULL) {
			/* assume it is a file and unknown */
			cfp->cf_cvstat = CVS_FST_UNKNOWN;
			cfp->cf_type = DT_REG;
d663 10
a672 16
			if (ent->ce_type == CVS_ENT_FILE)
				cfp->cf_type = DT_REG;
			else if (ent->ce_type == CVS_ENT_DIR)
				cfp->cf_type = DT_DIR;
			else
				cvs_log(LP_WARN, "unknown ce_type %d",
				    ent->ce_type);

			if (ent->ce_status == CVS_ENT_REMOVED)
				cfp->cf_cvstat = CVS_FST_REMOVED;
			else if (ent->ce_status == CVS_ENT_UPTODATE)
				cfp->cf_cvstat = CVS_FST_UPTODATE;
			else if (ent->ce_status == CVS_ENT_ADDED)
				cfp->cf_cvstat = CVS_FST_ADDED;
			else
				cfp->cf_cvstat = CVS_FST_LOST;
d674 26
d701 3
a703 37
		/* XXX assume 0644 ? */
		cfp->cf_mode = 0644;
	}

	if (ent != NULL) {
		/* steal the RCSNUM */
		cfp->cf_lrev = ent->ce_rev;

		if (ent->ce_type == CVS_ENT_FILE) {
			if (ent->ce_tag[0] != '\0')
				cfp->cf_tag = xstrdup(ent->ce_tag);

			if (ent->ce_opts[0] != '\0')
				cfp->cf_opts = xstrdup(ent->ce_opts);
		}
	}

	if (cfp->cf_type == DT_DIR) {
		if (cvs_load_dirinfo(cfp, flags) < 0) {
			cvs_file_free(cfp);
			return (NULL);
		}
	}

	if (flags & CF_REPO) {
		root = CVS_DIR_ROOT(cfp);

		cfp->cf_mode = 0644;
		cfp->cf_cvstat = CVS_FST_LOST;

		c = xstrdup(cfp->cf_dir);
		xfree(cfp->cf_dir);

		if (strcmp(c, root->cr_dir)) {
			c += strlen(root->cr_dir) + 1;
			cfp->cf_dir = xstrdup(c);
			c -= strlen(root->cr_dir) + 1;
d705 19
a723 1
			cfp->cf_dir = NULL;
a724 2

		xfree(c);
d727 4
a730 3
	if (cfp->cf_repo != NULL && cfp->cf_type == DT_DIR &&
	    !strcmp(cfp->cf_repo, path))
		cfp->cf_cvstat = CVS_FST_UPTODATE;
d732 18
a749 19
	/*
	 * In server mode, we do a few extra checks.
	 */
	if (cvs_cmdop == CVS_OP_SERVER) {
		/*
		 * If for some reason a file was added,
		 * but does not exist anymore, start complaining.
		 */
		if (!(cfp->cf_flags & CVS_FILE_ONDISK) &&
		    (cfp->cf_cvstat == CVS_FST_ADDED) &&
		    (cfp->cf_type != DT_DIR))
			cvs_log(LP_WARN, "new-born %s has disappeared", path);

		/*
		 * Any other needed checks?
		 */
	}

	return (cfp);
a751 1

a756 72
}

/*
 * remove any empty directories.
 */
int
cvs_file_prune(char *path)
{
	DIR *dirp;
	int l, pwd, empty;
	struct dirent *dp;
	char fpath[MAXPATHLEN];
	CVSENTRIES *entf;
	CVSFILE *cfp;

	pwd = (!strcmp(path, "."));

	if ((dirp = opendir(path)) == NULL) {
		cvs_log(LP_ERRNO, "failed to open `%s'", fpath);
		return (-1);
	}

	empty = 0;
	entf = cvs_ent_open(path, O_RDWR);

	while ((dp = readdir(dirp)) != NULL) {
		if (!strcmp(dp->d_name, ".") ||
		    !strcmp(dp->d_name, "..") ||
		    !strcmp(dp->d_name, CVS_PATH_CVSDIR))
			continue;

		empty++;
		if (dp->d_type == DT_DIR) {
			l = snprintf(fpath, sizeof(fpath), "%s%s%s",
			    (pwd) ? "" : path, (pwd) ? "" : "/", dp->d_name);
			if (l == -1 || l >= (int)sizeof(fpath)) {
				errno = ENAMETOOLONG;
				cvs_log(LP_ERRNO, "%s", fpath);
				continue;
			}

			cfp = cvs_file_find(cvs_files, fpath);
			if (cfp == NULL)
				continue;

			/* ignore unknown directories */
			if (cfp->cf_cvstat == CVS_FST_UNKNOWN)
				continue;

			if (cvs_file_prune(fpath)) {
				empty--;
				if (entf)
					cvs_ent_remove(entf, fpath, 0);
			} else {
				empty++;
			}
		}
	}

	closedir(dirp);
	if (entf)
		cvs_ent_close(entf);

	empty = (empty == 0);
	if (empty) {
		if (cvs_rmdir(path) < 0) {
			cvs_log(LP_ERR, "failed to prune `%s'", path);
			empty = 0;
		}
	}

	return (empty);
@


1.136
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.135 2006/04/02 02:02:27 joris Exp $	*/
d256 3
a258 3
		if (((mkdir(path, mode) == -1) && (errno != EEXIST)) ||
		    (cvs_mkadmin(path, cfp->cf_root->cr_str, cfp->cf_repo,
		    NULL, NULL, 0) < 0)) {
d578 1
a578 1
	if ((cvs_cmdop == CVS_OP_SERVER) && (type != DT_DIR))
d581 1
a581 1
	if ((root->cr_method == CVS_METHOD_LOCAL) && (type != DT_DIR))
d596 1
a596 1
		if ((cb != NULL) && ((cvs_error = cb(cf, arg)) != CVS_EX_OK))
d648 1
a648 1
			if ((*(pp + 1) == '.') && (*(pp + 2) == '\0')) {
d750 1
a750 1
	if ((stat(pbuf, &st) == 0) && S_ISDIR(st.st_mode)) {
d793 1
a793 1
	if ((flags & CF_KNOWN) && (cf->cf_cvstat == CVS_FST_UNKNOWN))
d850 1
a850 1
		if ((de->d_type != DT_DIR) && (flags & CF_NOFILES))
d863 1
a863 1
		if ((cfp->cf_type != DT_DIR) && !freecf) {
d889 1
a889 1
		if ((cfp->cf_type != DT_DIR) && freecf)
d902 1
a902 1
	while ((entf != NULL) && ((ent = cvs_ent_next(entf)) != NULL)) {
d905 1
a905 1
		if (!(flags & CF_RECURSE) && (ent->ce_type == CVS_ENT_DIR))
d907 1
a907 1
		if ((flags & CF_NOFILES) && (ent->ce_type != CVS_ENT_DIR))
d920 1
a920 1
		if ((cfp->cf_type != DT_DIR) && !freecf) {
d933 1
a933 1
		if ((cfp->cf_type != DT_DIR) && freecf)
d965 1
a965 1
		    (cvs_file_getdir(cfp, flags, cb, arg, freecf) < 0))
d975 1
a975 1
	if ((cfp != NULL) && freecf)
d1149 1
a1149 1
	if ((flags & CF_REPO) && (type != DT_DIR)) {
d1160 1
a1160 1
	if ((cfp->cf_type == DT_DIR) && (cfp->cf_parent == NULL))
d1268 1
a1268 1
	if ((cfp->cf_repo != NULL) && (cfp->cf_type == DT_DIR) &&
@


1.135
log
@spacing;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.134 2006/01/02 08:11:56 xsa Exp $	*/
d165 1
a165 1
	ip = (struct cvs_ignpat *)xmalloc(sizeof(*ip));
d1046 1
a1046 5
	cfvec = (CVSFILE **)calloc((size_t)nfiles, sizeof(CVSFILE *));
	if (cfvec == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate sorting vector");
		return (-1);
	}
d1102 1
a1102 2
	cfp = (CVSFILE *)xmalloc(sizeof(*cfp));
	memset(cfp, 0, sizeof(*cfp));
@


1.134
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.133 2005/12/12 21:30:33 joris Exp $	*/
a36 1

a43 1

a82 1

a88 1

a101 1

a152 1

a181 1

a207 1

@


1.133
log
@only xfree() cf->cf_dir when it's not NULL;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.132 2005/12/10 20:27:45 joris Exp $	*/
d27 1
a27 14
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <fnmatch.h>
#include <libgen.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.132
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.131 2005/12/04 17:39:02 joris Exp $	*/
d828 3
a830 1
		xfree(cf->cf_dir);
@


1.131
log
@more code cleanup, remove useless flags and parts of code
that never got used in the first place;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.130 2005/12/03 15:07:21 joris Exp $	*/
d184 1
a184 6
	ip = (struct cvs_ignpat *)malloc(sizeof(*ip));
	if (ip == NULL) {
		cvs_log(LP_ERR, "failed to allocate space for ignore pattern");
		return (-1);
	}

d276 1
a276 6
		cfp->cf_repo = strdup(repo);
		if (cfp->cf_repo == NULL) {
			cvs_file_free(cfp);
			return (NULL);
		}

d398 2
a399 7
			free(cvs_repo_base);
		cvs_repo_base = strdup(cf->cf_repo);
		if (cvs_repo_base == NULL) {
			cvs_log(LP_ERRNO, "strdup failed");
			cvs_file_free(cf);
			return (-1);
		}
d406 1
a406 6
		cvs_rootstr = strdup(cf->cf_root->cr_str);
		if (cvs_rootstr == NULL) {
			cvs_log(LP_ERRNO, "strdup failed");
			cvs_file_free(cf);
			return (-1);
		}
d772 2
a773 8
		if (cvs_readrepo(fpath, pbuf, sizeof(pbuf)) == 0) {
			cf->cf_repo = strdup(pbuf);
			if (cf->cf_repo == NULL) {
				cvs_log(LP_ERRNO,
				    "failed to dup repository string");
				return (-1);
			}
		}
d784 1
a784 5
			cf->cf_repo = strdup(pbuf);
			if (cf->cf_repo == NULL) {
				cvs_log(LP_ERRNO, "failed to dup repo string");
				return (-1);
			}
d828 2
a829 3
		free(cf->cf_dir);
		if ((cf->cf_dir = strdup(fpath)) == NULL)
			return (-1);
d1024 1
a1024 1
		free(cf->cf_name);
d1027 1
a1027 1
		free(cf->cf_dir);
d1033 1
a1033 1
			free(cf->cf_repo);
d1041 1
a1041 1
			free(cf->cf_tag);
d1043 1
a1043 1
			free(cf->cf_opts);
d1046 1
a1046 1
	free(cf);
d1078 1
a1078 1
			free(cfvec);
d1099 1
a1099 1
	free(cfvec);
d1125 1
a1125 5
	cfp = (CVSFILE *)malloc(sizeof(*cfp));
	if (cfp == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate CVS file data");
		return (NULL);
	}
d1135 1
a1135 7
	cfp->cf_name = strdup(basename(path));
	if (cfp->cf_name == NULL) {
		cvs_log(LP_ERR, "failed to copy file name");
		cvs_file_free(cfp);
		return (NULL);
	}

d1138 3
a1140 9
		if (strcmp(path, ".")) {
			cfp->cf_dir = strdup(path);
			if (cfp->cf_dir == NULL) {
				cvs_log(LP_ERR,
				    "failed to copy directory");
				cvs_file_free(cfp);
				return (NULL);
			}
		} else
d1257 2
a1258 7
			if (ent->ce_tag[0] != '\0') {
				cfp->cf_tag = strdup(ent->ce_tag);
				if (cfp->cf_tag == NULL) {
					cvs_file_free(cfp);
					return (NULL);
				}
			}
d1260 2
a1261 7
			if (ent->ce_opts[0] != '\0') {
				cfp->cf_opts = strdup(ent->ce_opts);
				if (cfp->cf_opts == NULL) {
					cvs_file_free(cfp);
					return (NULL);
				}
			}
d1278 2
a1279 6
		if ((c = strdup(cfp->cf_dir)) == NULL) {
			cvs_file_free(cfp);
			return (NULL);
		}

		free(cfp->cf_dir);
d1283 1
a1283 5
			if ((cfp->cf_dir = strdup(c)) == NULL) {
				cvs_file_free(cfp);
				return (NULL);
			}

d1289 1
a1289 1
		free(c);
@


1.130
log
@fix date handling in opencvs, this was broken since the very start.
now, when you checkout a tree with gnu cvs, opencvs no longer sees all
the files as modified, and visa versa.

this actually makes gnu cvs and opencvs dance together in working copies.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.129 2005/12/03 02:19:17 joris Exp $	*/
a817 3

	if (flags & CF_MKADMIN)
		cvs_mkadmin(fpath, cf->cf_root->cr_str, NULL, NULL, NULL, 0);
@


1.129
log
@remove unused and useless functions, they just get in the way;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.128 2005/12/03 01:02:08 joris Exp $	*/
d1255 9
@


1.128
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.127 2005/11/12 21:34:48 niallo Exp $	*/
a1082 16

/*
 * cvs_file_examine()
 *
 * Walk through the files, calling the callback as we go.
 */
int
cvs_file_examine(CVSFILE *cf, int (*exam)(CVSFILE *, void *), void *arg)
{
	int ret;
	CVSFILE *fp;

	fp = NULL;
	ret = 0;
	return (ret);
}
@


1.127
log
@- remove strtab stuff. serves no useful purpose.

diff is from joris@@, committing on his behalf because his net connection
is very dodgy right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.126 2005/10/27 00:24:24 joris Exp $	*/
a429 1
	cvs_file_free(cf);
d435 11
a445 1
	if (cvs_cmdop == CVS_OP_CHECKOUT || cvs_cmdop == CVS_OP_VERSION)
d850 16
d1227 1
d1232 1
d1239 6
d1304 3
d1339 28
d1450 1
a1450 1
					cvs_ent_remove(entf, fpath);
@


1.126
log
@if cvs_file_loadinfo fails, return failure to the caller instead
of acting like everything went fine.

this fixes eternal loops in the client which waits for data
from the server while the server waits for data from the client.

problem found and fixed by Nuno Morgadinho, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.125 2005/10/16 00:29:17 joris Exp $	*/
a44 1
#include "strtab.h"
d1033 1
a1033 1
		cvs_strfree(cf->cf_name);
d1036 1
a1036 1
		cvs_strfree(cf->cf_dir);
d1050 1
a1050 1
			cvs_strfree(cf->cf_tag);
d1052 1
a1052 1
			cvs_strfree(cf->cf_opts);
d1164 1
a1164 1
	cfp->cf_name = cvs_strdup(basename(path));
d1174 1
a1174 1
			cfp->cf_dir = cvs_strdup(path);
d1279 1
a1279 1
				cfp->cf_tag = cvs_strdup(ent->ce_tag);
d1287 1
a1287 1
				cfp->cf_opts = cvs_strdup(ent->ce_opts);
@


1.125
log
@less 'pirates of the carribean' like error message;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.124 2005/10/07 21:47:32 reyk Exp $	*/
d454 1
a454 1
				break;
@


1.124
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.123 2005/09/15 22:12:23 joris Exp $	*/
d399 1
a399 1
		cvs_log(LP_ERR, "arrrr i failed captain!");
@


1.123
log
@strip trailing slashes from any arguments passed to opencvs.
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.122 2005/09/15 17:01:10 xsa Exp $	*/
d56 1
a56 1
	TAILQ_ENTRY (cvs_ignpat)	ip_list;
d290 1
a290 1
		        NULL, NULL, 0) < 0)) {
d1317 1
a1317 1
	    	    (cfp->cf_cvstat == CVS_FST_ADDED) &&
@


1.122
log
@check in cvs_mkadmin() wether we need to create or not the
CVS/Tag file. Sync the rest of the code accordingly; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.121 2005/09/14 16:32:08 joris Exp $	*/
d442 5
@


1.121
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.120 2005/09/13 17:38:35 joris Exp $	*/
d289 2
a290 1
		    (cvs_mkadmin(path, cfp->cf_root->cr_str, cfp->cf_repo) < 0)) {
d601 1
a601 1
	 */
d807 1
a807 1
		cvs_mkadmin(fpath, cf->cf_root->cr_str, NULL);
@


1.120
log
@fix conditions when the base directory should be passed to the command
callback.

fixes local commands with directories as arguments (like 'add').
problem found and OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.119 2005/09/11 14:16:48 joris Exp $	*/
d605 1
a605 1
	if (cvs_cmdop == CVS_OP_SERVER && type != DT_DIR)
d608 1
a608 1
	if (root->cr_method == CVS_METHOD_LOCAL && type != DT_DIR)
@


1.119
log
@only remove and free a cvsroot struct if it has been added in
cvsroot_parse().

fixes segfaults opencvs has been receiving when cvsroot_parse() fails.
"go ahead" xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.118 2005/09/06 17:08:05 xsa Exp $	*/
d494 1
a494 1
	int type;
d601 17
a617 5
	if (!(((cvs_cmdop == CVS_OP_SERVER) ||
	    (root->cr_method == CVS_METHOD_LOCAL)) && (strcmp(path, "."))) &&
	    (base->cf_flags & CVS_FILE_ONDISK) && (cb != NULL) &&
	    ((cvs_error = cb(base, arg)) != CVS_EX_OK))
		goto fail;
@


1.118
log
@more bits for the local remove command support; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.117 2005/09/06 15:29:33 joris Exp $	*/
d1023 1
a1023 1
			cvsroot_free(cf->cf_root);
@


1.117
log
@Make sure entries do not go away when we run through them in the file code.
Fixes corrupt Entry files.

Problem found by Mike Pechkin, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.116 2005/08/19 13:36:50 joris Exp $	*/
a1258 1
		ent->ce_rev = NULL;
@


1.116
log
@do not close the entries file until all files depending on it have
been passed to the callback.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.115 2005/08/17 16:23:19 joris Exp $	*/
d840 9
d856 2
a857 2
			if (entf != NULL)
				(void)cvs_ent_remove(entf, de->d_name);
a863 12
		/*
		 * Obtain info about the item.
		 */
		len = cvs_path_cat(fpath, de->d_name, pbuf, sizeof(pbuf));
		if (len >= sizeof(pbuf))
			goto done;

		if (entf != NULL)
			ent = cvs_ent_get(entf, de->d_name);
		else
			ent = NULL;

d892 1
a892 2
		 * Remove it from the Entries list to make sure it won't
		 * be picked up again when we look at the Entries.
d894 2
a895 2
		if (entf != NULL)
			(void)cvs_ent_remove(entf, de->d_name);
d914 2
@


1.115
log
@keep a pointer to the CVSENTRIES in the CVSFILE structure.
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.114 2005/08/17 08:35:53 xsa Exp $	*/
a606 5
	if (entf != NULL) {
		cvs_ent_close(entf);
		entf = NULL;
	}

d622 5
@


1.114
log
@trailing whitespaces ...
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.113 2005/08/14 19:49:18 xsa Exp $	*/
d117 2
a118 1
static CVSFILE	*cvs_file_lget(const char *, int, CVSFILE *, struct cvs_ent *);
d396 1
a396 1
	cf = cvs_file_lget(".", 0, NULL, NULL);
d527 1
a527 1
	entf = cvs_ent_open(parent, O_RDONLY);
d556 1
a556 1
		base = cvs_file_lget(path, flags, NULL, ent);
d558 1
a558 1
		base = cvs_file_lget(parent, flags, NULL, NULL);
d586 1
a586 1
		cf = cvs_file_lget(path, flags, base, ent);
a594 5
	if (entf != NULL) {
		cvs_ent_close(entf);
		entf = NULL;
	}

d607 5
d834 1
a834 1
	entf = cvs_ent_open(fpath, O_RDONLY);
d867 1
a867 1
		cfp = cvs_file_lget(pbuf, flags, cf, ent);
d927 1
a927 1
		cfp = cvs_file_lget(pbuf, flags, cf, ent);
d1184 2
a1185 1
cvs_file_lget(const char *path, int flags, CVSFILE *parent, struct cvs_ent *ent)
d1200 1
d1282 5
a1286 3
	if ((cfp->cf_type == DT_DIR) && (cvs_load_dirinfo(cfp, flags) < 0)) {
		cvs_file_free(cfp);
		return (NULL);
@


1.113
log
@missing casts; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.112 2005/08/11 11:54:42 xsa Exp $	*/
d484 1
a484 1
CVSFILE * 
d536 1
a536 1
	 * that fails, assume a normal file. 
d755 1
a755 1
 
@


1.112
log
@fgets() expects the 2nd arg to be an int.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.111 2005/08/03 14:43:08 xsa Exp $	*/
d1074 1
a1074 1
	cfvec = (CVSFILE **)calloc(nfiles, sizeof(CVSFILE *));
@


1.111
log
@check only once for the HOME environment variable and reuse
its value (if any) to check for the .cvsrc and .cvsignore files;
ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.110 2005/07/30 21:16:17 moritz Exp $	*/
d155 1
a155 1
		while (fgets(buf, sizeof(buf), ifp) != NULL) {
@


1.110
log
@o remove a call to cvs_ent_open() from cvs_file_create(),
  since cvs_mkadmin() already does this for us.
o don't deref NULL ptr when cvs_ent_open() fails.
o fix format string in cvs_log().

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.109 2005/07/29 17:04:42 xsa Exp $	*/
a130 1
	struct passwd *pwd;
d142 6
a147 8
	pwd = getpwuid(getuid());
	if (pwd != NULL) {
		l = snprintf(path, sizeof(path), "%s/.cvsignore", pwd->pw_dir);
		if (l == -1 || l >= (int)sizeof(path)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", path);
			return (-1);
		}
d149 12
a160 17
		ifp = fopen(path, "r");
		if (ifp == NULL) {
			if (errno != ENOENT)
				cvs_log(LP_ERRNO,
				    "failed to open user's cvsignore file "
				    "`%s'", path);
		} else {
			while (fgets(buf, sizeof(buf), ifp) != NULL) {
				len = strlen(buf);
				if (len == 0)
					continue;
				if (buf[len - 1] != '\n') {
					cvs_log(LP_ERR, "line too long in `%s'",
					    path);
				}
				buf[--len] = '\0';
				cvs_file_ignore(buf);
d162 2
a163 1
			(void)fclose(ifp);
d165 1
@


1.109
log
@minor KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.108 2005/07/29 13:56:00 joris Exp $	*/
d156 2
a157 1
				    "failed to open user's cvsignore", path);
a254 1
	CVSENTRIES *ent;
a296 5
		}

		ent = cvs_ent_open(path, O_RDWR);
		if (ent != NULL) {
			cvs_ent_close(ent);
@


1.108
log
@make more use of error codes in the file code.
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.107 2005/07/29 00:33:55 joris Exp $	*/
d248 1
a248 1
CVSFILE*
d327 1
a327 1
CVSFILE*
d656 1
a656 1
CVSFILE*
d1139 1
a1139 1
CVSFILE*
d1193 1
a1193 1
static CVSFILE*
@


1.107
log
@correctly build the repository path in cvs_load_dirinfo() so we do not
end up with a totally messed up repopath when there are no admin files present.

problems reported by mpech@@ and Nuno Margadinho.
tested by Nuno Margadinho, thanks a lot!
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.106 2005/07/27 10:36:14 xsa Exp $	*/
d456 3
a458 1
		if (cf == NULL)
d460 1
d573 1
d587 1
a587 1
		cvs_log(LP_ERR, "no Root in base directory found");
d598 1
a598 1
			cvs_log(LP_ERR, "failed to fetch '%s'", path);
d634 1
a634 1
			cvs_log(LP_ERR, "cvs_file_getdir failed");
@


1.106
log
@rename cvs_remove_dir() to cvs_rmdir() because it might be confusing
with the `remove' command local functions. ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.105 2005/07/25 12:58:22 joris Exp $	*/
d784 5
a788 4
		l = snprintf(pbuf, sizeof(pbuf), "%s/%s",
		    cvs_repo_base, fpath);
		if (l == -1 || l >= (int)sizeof(pbuf))
			return (-1);
d790 7
a796 5
		cf->cf_repo = strdup(pbuf);
		if (cf->cf_repo == NULL) {
			cvs_log(LP_ERRNO, "failed to dup repo string");
			return (-1);
		}
@


1.105
log
@make it compile without warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.104 2005/07/25 12:05:43 xsa Exp $	*/
d1384 1
a1384 1
		if (cvs_remove_dir(path) < 0) {
@


1.104
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.103 2005/07/24 19:04:55 joris Exp $	*/
d376 1
a376 1
	files[0] = path;
@


1.103
log
@do not bail out in client mode if the file is not on disk at all.
noticed and ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.102 2005/07/24 18:54:47 joris Exp $	*/
d47 1
a47 1
#define CVS_IGN_STATIC    0x01     /* pattern is static, no need to glob */
d49 1
a49 1
#define CVS_CHAR_ISMETA(c)  ((c == '*') || (c == '?') || (c == '['))
d54 3
a56 3
	char  ip_pat[MAXNAMLEN];
	int   ip_flags;
	TAILQ_ENTRY (cvs_ignpat) ip_list;
d107 1
a107 1
TAILQ_HEAD(, cvs_ignpat)  cvs_ign_pats;
d112 6
a117 6
static int	cvs_load_dirinfo  (CVSFILE *, int);
static int      cvs_file_sort    (struct cvs_flist *, u_int);
static int      cvs_file_cmp     (const void *, const void *);
static int      cvs_file_cmpname (const char *, const char *);
static CVSFILE* cvs_file_alloc   (const char *, u_int);
static CVSFILE* cvs_file_lget  (const char *, int, CVSFILE *, struct cvs_ent *);
d704 1
a704 1
char*
@


1.102
log
@"cvslog.*" should really be "cvslog*"
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.101 2005/07/24 18:34:13 joris Exp $	*/
d544 1
a544 2
	 * that fails, bail out in client mode, or assume a file in
	 * server mode (it will show up as CVS_FST_UNKNOWN).
d547 1
a547 3
		if (stat(path, &st) == -1) {
			if (cvs_cmdop != CVS_OP_SERVER)
				goto fail;
d549 1
a549 1
		} else
@


1.101
log
@add "cvslog.*" to the ignore list
noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.100 2005/07/23 11:19:46 joris Exp $	*/
d81 1
a81 1
	"cvslog.*",
@


1.100
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.99 2005/07/22 16:27:29 joris Exp $	*/
d81 1
@


1.99
log
@use the cf_name field of the CVSFILE struct instead of using the old
CVS_FILE_NAME macro. This macro used to be nifty because of all
the referencing for the names, but since we don't do that anymore and
use cf_name directly... byebye CVS_FILE_NAME()

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.98 2005/07/18 01:02:20 joris Exp $	*/
a46 1

d108 2
a110 1
static int cvs_file_getdir(CVSFILE *, int, char *, int (*)(CVSFILE *, void *), void *);
a250 1
	int bail;
d259 1
a259 1
	bail = l = 0;
a264 5

		/*
		 * If we do not have a valid root for this, try looking at
		 * the parent its root.
		 */
d266 1
a266 14
			if (parent != NULL && parent->cf_root != NULL) {
				cfp->cf_root =
				    cvsroot_parse(parent->cf_root->cr_str);
				if (cfp->cf_root == NULL)
					bail = 1;
			} else {
				bail = 1;
			}
		}

		/* we tried, too bad */
		if (bail) {
			cvs_log(LP_ERR, "failed to obtain root info for `%s'",
			    path);
d369 1
a369 1
CVSFILE*
d371 1
a371 1
    void *arg)
d376 1
a376 1
	return cvs_file_getspec(files, 1, flags, cb, arg);
d383 1
a383 4
 * Load a specific set of files whose paths are given in the vector <fspec>,
 * whose size is given in <fsn>.
 * Returns a pointer to the lowest common subdirectory to all specified
 * files.
d385 1
a385 1
CVSFILE*
d387 1
a387 1
    void *arg)
d389 11
a399 6
	int i;
	int pwd;
	char *sp, *np, pcopy[MAXPATHLEN];
	CVSFILE *base, *nf;
	CVSENTRIES *entfile;
	struct cvs_ent *ent;
d401 9
a409 5
	base = cvs_file_lget(".", 0, NULL, NULL);
	if (base == NULL)
		return (NULL);

	entfile = cvs_ent_open(".", O_RDONLY);
d412 2
a413 2
	 * fill in the repository base (needed to construct repo's in
	 * cvs_file_create).
d415 4
a418 2
	if (base->cf_repo != NULL) {
		cvs_repo_base = strdup(base->cf_repo);
d420 3
a422 5
			cvs_log(LP_ERR, "failed to duplicate repository base");
			cvs_file_free(base);
			if (entfile)
				cvs_ent_close(entfile);
			return (NULL);
d427 1
a427 1
	 * XXX - needed for some commands
d429 6
a434 6
	if (cb != NULL) {
		if (cb(base, arg) != CVS_EX_OK) {
			cvs_file_free(base);
			if (entfile)
				cvs_ent_close(entfile);
			return (NULL);
d438 10
a449 2
		sp = pcopy;
		pwd = (!strcmp(pcopy, "."));
d451 6
a456 3
		np = strchr(sp, '/');
		if (np != NULL)
			*np = '\0';
d458 5
a462 2
		if (pwd) {
			nf = base;
d464 124
a587 13
			nf = cvs_file_find(base, pcopy);
			if (nf == NULL) {
				if (entfile != NULL)
					ent = cvs_ent_get(entfile, pcopy);
				else
					ent = NULL;
				nf = cvs_file_lget(pcopy, 0, base, ent);
				if (nf == NULL) {
					cvs_file_free(base);
					if (entfile)
						cvs_ent_close(entfile);
					return (NULL);
				}
d589 9
a597 7
				if (cvs_file_attach(base, nf) < 0) {
					cvs_file_free(base);
					if (entfile)
						cvs_ent_close(entfile);
					return (NULL);
				}
			}
d600 34
a633 19
		if (nf->cf_type == DT_DIR) {
			if (np != NULL)
				*np++;

			if (cvs_file_getdir(nf, flags, np, cb, arg) < 0) {
				cvs_file_free(base);
				if (entfile)
					cvs_ent_close(entfile);
				return (NULL);
			}
		} else {
			if (cb != NULL) {
				if (cb(nf, arg) != CVS_EX_OK) {
					cvs_file_free(base);
					if (entfile)
						cvs_ent_close(entfile);
					return (NULL);
				}
			}
d637 1
a637 2
	if (entfile)
		cvs_ent_close(entfile);
d639 6
a644 1
	return (base);
a646 1

d704 1
a704 1
 * Returns a pointer to the start of the path on success, or NULL on failure.
d709 3
a711 27
	u_int i;
	const char *fp, *namevec[CVS_FILE_MAXDEPTH];
	CVSFILE *top;

	buf[0] = '\0';
	i = CVS_FILE_MAXDEPTH;
	memset(namevec, 0, sizeof(namevec));

	/* find the top node */
	for (top = file; (top != NULL) && (i > 0); top = top->cf_parent) {
		fp = top->cf_name;

		/* skip self-references */
		if ((fp[0] == '.') && (fp[1] == '\0'))
			continue;
		namevec[--i] = fp;
	}

	if (i == 0)
		return (NULL);
	else if (i == CVS_FILE_MAXDEPTH) {
		strlcpy(buf, ".", len);
		return (buf);
	}

	while (i < CVS_FILE_MAXDEPTH - 1) {
		strlcat(buf, namevec[i++], len);
a713 1
	strlcat(buf, namevec[i], len);
d715 1
a718 1

d751 6
d759 2
a760 4
		/*
		 * Do not fail here for an unknown directory.
		 */
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
d764 1
a764 4

	if (flags & CF_MKADMIN)
		cvs_mkadmin(fpath, cf->cf_root->cr_str, NULL);

d782 14
d798 3
d812 2
a813 1
cvs_file_getdir(CVSFILE *cf, int flags, char *path, int (*cb)(CVSFILE *, void *), void *arg)
d815 6
a820 6
	int l, ret;
	int check_entry;
	u_int ndirs, nfiles;
	char *cur, *np;
	char pbuf[MAXPATHLEN], fpath[MAXPATHLEN];
	struct dirent *ent;
d822 1
a822 1
	struct cvs_ent *cvsent;
d824 1
a824 20
	DIR *dirp;
	CVSENTRIES *entfile;

	ret = -1;
	check_entry = 1;
	ndirs = nfiles = 0;
	SIMPLEQ_INIT(&dirs);

	cvs_file_getpath(cf, fpath, sizeof(fpath));

	cur = np = NULL;
	if (path != NULL) {
		cur = strchr(path, '/');
		if (cur != NULL) {
			*cur = '\0';
			np = cur + 1;
			if (np != NULL && *np == '\0')
				np = NULL;
		}
	}
d829 3
a831 8
	/*
	 * XXX - Do not call the callback for ".", this has
	 * already been done in cvs_file_getspec().
	 */
	if (cb != NULL && strcmp(cf->cf_name, ".")) {
		if (cb(cf, arg) != CVS_EX_OK)
			return (-1);
	}
d833 2
a834 7
	cf->cf_root = cvsroot_get(fpath);
	if (cf->cf_root == NULL) {
		/*
		 * Do not fail here for an unknown directory.
		 */
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			return (0);
d838 5
a842 9
	dirp = opendir(fpath);
	if (dirp == NULL) {
		cvs_log(LP_ERRNO, "failed to open directory %s", fpath);
		return (-1);
	}

	entfile = cvs_ent_open(fpath, O_RDONLY);
	while ((ent = readdir(dirp)) != NULL) {
		if ((flags & CF_IGNORE) && cvs_file_chkign(ent->d_name))
d845 4
a848 1
		if ((flags & CF_NOSYMS) && (ent->d_type == DT_LNK))
d851 3
a853 4
		if (!(flags & CF_RECURSE) && (ent->d_type == DT_DIR)) {
			if (entfile != NULL)
				(void)cvs_ent_remove(entfile,
				    ent->d_name);
d857 1
a857 1
		if ((ent->d_type != DT_DIR) && (flags & CF_NOFILES))
d860 11
a870 4
		if (path != NULL) {
			if (strcmp(path, ent->d_name))
				continue;
		}
d872 3
a874 6
		l = snprintf(pbuf, sizeof(pbuf), "%s/%s", fpath,
		    ent->d_name);
		if (l == -1 || l >= (int)sizeof(pbuf)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", pbuf);
			closedir(dirp);
d878 11
a888 6
		cfp = cvs_file_find(cf, ent->d_name);
		if (cfp == NULL) {
			if (entfile != NULL)
				cvsent = cvs_ent_get(entfile, ent->d_name);
			else
				cvsent = NULL;
d890 6
a895 4
			cfp = cvs_file_lget(pbuf, flags, cf, cvsent);

			if (cfp == NULL) {
				closedir(dirp);
a896 11
			}
			if (entfile != NULL)
				cvs_ent_remove(entfile, cfp->cf_name);

			if (cfp->cf_type != DT_DIR) {
				SIMPLEQ_INSERT_TAIL(&(cf->cf_files), cfp,
				    cf_list);
				nfiles++;
			}
		} else {
			cfp->cf_flags |= CVS_GDIR_IGNORE;
d899 6
a904 12
		if (cfp->cf_type == DT_DIR) {
			ndirs++;
			SIMPLEQ_INSERT_TAIL(&dirs, cfp, cf_list);
		} else {
			/* callback for the file */
			if (cb != NULL) {
				if (cb(cfp, arg) != CVS_EX_OK) {
					closedir(dirp);
					goto done;
				}
			}
		}
d906 5
a910 4
		if (path != NULL) {
			check_entry = 0;
			break;
		}
d913 2
a914 1
	closedir(dirp);
d916 11
a926 6
	if (entfile != NULL && check_entry) {
		while ((cvsent = cvs_ent_next(entfile)) != NULL) {
			if (path != NULL) {
				if (strcmp(cvsent->ce_name, path))
					continue;
			}
d928 3
a930 7
			l = snprintf(pbuf, sizeof(pbuf), "%s/%s", fpath,
			    cvsent->ce_name);
			if (l == -1 || l >= (int)sizeof(pbuf)) {
				errno = ENAMETOOLONG;
				cvs_log(LP_ERRNO, "%s", pbuf);
				goto done;
			}
d932 5
a936 5
			cfp = cvs_file_find(cf, cvsent->ce_name);
			if (cfp == NULL) {
				cfp = cvs_file_lget(pbuf, flags, cf, cvsent);
				if (cfp == NULL)
					continue;
d938 7
a944 8
				if (cfp->cf_type != DT_DIR) {
					SIMPLEQ_INSERT_TAIL(&(cf->cf_files),
					    cfp, cf_list);
					nfiles++;
				}
			} else {
				cfp->cf_flags |= CVS_GDIR_IGNORE;
			}
d946 4
a949 11
			if (cfp->cf_type == DT_DIR) {
				ndirs++;
				SIMPLEQ_INSERT_TAIL(&dirs, cfp,
				    cf_list);
			} else {
				/* callback for the file */
				if (cb != NULL) {
					if (cb(cfp, arg) != CVS_EX_OK)
						goto done;
				}
			}
d951 2
a952 3
			if (path != NULL)
				break;
		}
d955 3
d965 5
d974 1
a974 1
		if (!(cfp->cf_flags & CVS_GDIR_IGNORE))
a975 2
		else
			cfp->cf_flags &= ~CVS_GDIR_IGNORE;
d977 3
a979 3
		if (cvs_file_getdir(cfp, flags, np, cb, arg) < 0) {
			cvs_log(LP_ERR, "failed to get %s", cfp->cf_name);
			continue;
d981 7
d991 1
d993 14
a1006 2
	if (entfile != NULL)
		cvs_ent_close(entfile);
d1025 3
d1052 1
a1052 3
 * Examine the contents of the CVS file structure <cf> with the function
 * <exam>.  The function is called for all subdirectories and files of the
 * root file.
d1060 2
a1061 10
	if (cf->cf_type == DT_DIR) {
		ret = (*exam)(cf, arg);
		SIMPLEQ_FOREACH(fp, &(cf->cf_files), cf_list) {
			ret = cvs_file_examine(fp, exam, arg);
			if (ret != 0)
				break;
		}
	} else
		ret = (*exam)(cf, arg);

d1138 1
d1161 16
d1191 1
a1191 1
	int ret, cwd;
a1196 2
	cwd = (strcmp(path, ".") == 0) ? 1 : 0;

d1212 1
d1215 4
a1218 2
			cfp->cf_cvstat = (cwd == 1) ?
			    CVS_FST_UPTODATE : CVS_FST_UNKNOWN;
d1294 18
d1324 1
a1324 2
 * remove a directory if it does not contain
 * any files other than the CVS/ administrative files.
@


1.98
log
@oops, last commit broke a few things
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.97 2005/07/18 00:55:11 joris Exp $	*/
d553 1
a553 1
			if (cvs_file_cmpname(pp, CVS_FILE_NAME(sf)) == 0)
d587 1
a587 1
		fp = CVS_FILE_NAME(top);
d889 1
a889 1
			cvs_log(LP_ERR, "failed to get %s", CVS_FILE_NAME(cfp));
d1023 1
a1023 1
	return cvs_file_cmpname(CVS_FILE_NAME(cf1), CVS_FILE_NAME(cf2));
@


1.97
log
@let it compile without any warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.96 2005/07/15 13:10:56 joris Exp $	*/
d394 1
a394 1
	files[0] = *(char * const *)path;
@


1.96
log
@if the file has been added but is not on disk make sure we can pick it up
as being "added".

fixes the log command on our server-side for added files.

tested & ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.95 2005/07/07 20:24:35 joris Exp $	*/
d394 1
a394 1
	files[0] = path;
@


1.95
log
@

do not run the callback for "." twice.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.94 2005/07/07 19:06:12 joris Exp $	*/
d1134 2
@


1.94
log
@

add a field to CVSFILE which holds the timestamp from the Entries file.
usefull for some commands.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.93 2005/07/07 14:27:57 joris Exp $	*/
d439 3
a441 1
	/* XXX - needed for some commands */
d722 5
a726 2
	/* callback for the directory entry */
	if (cb != NULL) {
@


1.93
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.92 2005/07/05 16:55:30 joris Exp $	*/
d361 2
a362 1
	if (orig->cf_type == DT_REG)
d364 1
a364 1
	else if (orig->cf_type == DT_DIR) {
d1108 2
@


1.92
log
@

if we can't stat the file and there is no entry for it, don't fail
but assume it is a regular file and it is in unknown state.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.91 2005/07/01 08:59:09 joris Exp $	*/
d791 1
a791 1
			    	    cf_list);
d851 1
a851 1
				SIMPLEQ_INSERT_TAIL(&dirs, cfp, 
d1119 1
a1119 1
				cvs_log(LP_WARN, "unknown ce_type %d", 
d1243 1
a1243 1
	} 
@


1.91
log
@

- plug memleak in cvs_file_getdir().
- fix behaviour regarding unknown directories.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.90 2005/06/17 15:09:55 joris Exp $	*/
d1110 3
a1112 4
			cvs_log(LP_ERR, "no Entry and no file for `%s'",
			    CVS_FILE_NAME(cfp));
			cvs_file_free(cfp);
			return (NULL);
@


1.90
log
@

correctly build a temporary copy of the client its repository
localy, so the server can execute the local commands on it
and pipe the output to the client.

with this diff in, our server is now working, please note
that we currently don't have support for all commands yet,
but you can expect this soon.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.89 2005/06/17 14:58:23 joris Exp $	*/
d642 6
a647 1
	if (cf->cf_root == NULL)
d649 1
d686 1
a686 1
	int l;
d698 1
a703 5
	entfile = cvs_ent_open(fpath, O_RDONLY);

	cf->cf_root = cvsroot_get(fpath);
	if (cf->cf_root == NULL)
		return (-1);
d725 10
d741 1
d770 1
a770 1
			return (-1);
d784 1
a784 1
				return (-1);
d806 1
a806 1
					return (-1);
d831 1
a831 1
				return (-1);
d857 1
a857 1
						return (-1);
a863 1
		cvs_ent_close(entfile);
d888 6
a893 1
	return (0);
d1218 4
@


1.89
log
@

when pruning don't try to remove any directories outside
the actual repository.

reported by david@@, ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.88 2005/06/14 15:27:31 joris Exp $	*/
d1084 1
a1084 1
				if (ent->ce_mtime == (time_t)st.st_mtime)
d1086 1
a1086 1
				else
d1088 1
d1108 2
@


1.88
log
@

finish pruning support, this has been sitting
in my tree since c2k5

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.87 2005/06/09 01:45:45 joris Exp $	*/
d1168 1
d1195 4
@


1.87
log
@

don't forget to close entfile in cvs_file_getspec().
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.86 2005/06/01 16:49:20 joris Exp $	*/
a118 1

d1154 64
@


1.86
log
@

remove debug code
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.85 2005/06/01 15:46:32 joris Exp $	*/
a417 1
	entfile = cvs_ent_open(".", O_RDONLY);
d422 2
d443 2
d470 2
d477 2
d490 2
d498 2
d505 3
@


1.85
log
@

don't trust cvs_file_getpath() to get the correct path when creating
the Repository file for subdirs, if we are not in the root directory of
the repository.

instead, save the parent's Repository path and reuse it when needed,
this way CVS/Repository files aren't messed up with completely wrong
pathnames when running "cvs update -d" in src/sys/ for example.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.84 2005/06/01 14:03:14 joris Exp $	*/
a435 2

		printf("cvs_repo_base is %s\n", cvs_repo_base);
@


1.84
log
@

when creating a new directory, steal the parent its cvsroot structure if
we cannot find one with cvsroot_get().

fixes several segfaults.

tested & ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.83 2005/05/31 08:58:48 xsa Exp $	*/
d251 1
a251 1
	int fd;
d253 1
a253 1
	char fp[MAXPATHLEN];
d261 1
a261 1
	bail = 0;
d290 17
a306 1
		cfp->cf_repo = strdup(cvs_file_getpath(cfp, fp, sizeof(fp)));
d422 17
@


1.83
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.82 2005/05/31 08:26:40 xsa Exp $	*/
d252 1
d261 1
d267 24
a290 2
		cfp->cf_repo = strdup(cvs_file_getpath(cfp,
		    fp, sizeof(fp)));
@


1.82
log
@remove LP_ERROR log priority level and rather use LP_ERR as they are both
the same...

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.81 2005/05/28 01:34:28 joris Exp $	*/
d31 1
a31 1
#include <pwd.h>
a32 1
#include <stdio.h>
d34 1
d36 2
a37 1
#include <dirent.h>
d39 1
a40 2
#include <string.h>
#include <fnmatch.h>
d43 1
a44 1
#include "file.h"
@


1.81
log
@

make sure we check the Entry file when we need to.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.80 2005/05/25 09:42:12 jfb Exp $	*/
d803 1
a803 2
			cvs_log(LP_ERROR, "failed to get %s",
			    CVS_FILE_NAME(cfp));
@


1.80
log
@assume that a file is modified if its timestamp is lower
than the value found in Entries.  This can't really hurt, as
the server will simply ignore it if it's not really modified
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.79 2005/05/24 21:57:33 joris Exp $	*/
d624 2
a625 1
	check_entry = ndirs = nfiles = 0;
@


1.79
log
@

don't fail on mkdir(2) when errno is EEXIST in cvs_file_create().
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.78 2005/05/24 20:04:43 joris Exp $	*/
d1016 1
a1016 1
				if (ent->ce_mtime >= (time_t)st.st_mtime)
@


1.78
log
@

- simplify cvs_mkadmin().
- create the correct base paths in checkout.
- remove the CVS_CMD_SENDARGS2 flag for checkout, it doesn't need it.

okay jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.77 2005/05/24 04:12:25 jfb Exp $	*/
d272 1
a272 1
		if ((mkdir(path, mode) == -1) ||
@


1.77
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.76 2005/05/22 17:47:53 joris Exp $	*/
d272 2
a273 1
		if ((mkdir(path, mode) == -1) || (cvs_mkadmin(cfp, mode) < 0)) {
d578 1
a578 1
		cvs_mkadmin(cf, 0755);
@


1.76
log
@

unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.75 2005/05/20 17:23:18 joris Exp $	*/
d506 1
a506 1
	char *fp, *namevec[CVS_FILE_MAXDEPTH];
a659 4
		if (!strcmp(ent->d_name, ".") ||
		    !strcmp(ent->d_name, ".."))
			continue;

d837 2
d1048 15
a1062 5
		if ((ent->ce_type == CVS_ENT_REG) &&
		    (ent->ce_tag != NULL)) {
			if ((cfp->cf_tag = cvs_strdup(ent->ce_tag)) == NULL) {
				cvs_file_free(cfp);
				return (NULL);
@


1.75
log
@

plug a memleak
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.74 2005/05/20 05:25:44 joris Exp $	*/
d617 1
a617 1
	CVSFILE *cfp, *moo;
a622 1
	moo = NULL;
@


1.74
log
@

allow a cvs command to be executed from outside a repository,
ie: "cvs -d /cvs update src".

problem spotted & ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.73 2005/05/20 05:13:44 joris Exp $	*/
d431 2
a432 1
				if (cb(nf, arg) != CVS_EX_OK)
d434 1
@


1.73
log
@

execute the command callback at the same time we are building
the in-memory filelist. cuts down on execution time for larger trees.

"put it in!" jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.72 2005/05/20 05:01:34 jfb Exp $	*/
d574 2
a575 3
	if (cf->cf_cvstat != CVS_FST_UNKNOWN) {
		if (flags & CF_MKADMIN)
			cvs_mkadmin(cf, 0755);
d577 7
a583 7
		/* if the CVS administrative directory exists, load the info */
		l = snprintf(pbuf, sizeof(pbuf), "%s/" CVS_PATH_CVSDIR, fpath);
		if (l == -1 || l >= (int)sizeof(pbuf)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", pbuf);
			return (-1);
		}
d585 7
a591 8
		if ((stat(pbuf, &st) == 0) && S_ISDIR(st.st_mode)) {
			if (cvs_readrepo(fpath, pbuf, sizeof(pbuf)) == 0) {
				cf->cf_repo = strdup(pbuf);
				if (cf->cf_repo == NULL) {
					cvs_log(LP_ERRNO,
					    "failed to dup repository string");
					return (-1);
				}
d1062 4
@


1.72
log
@don't attempt to copy the file's tag from the entry if we're dealing
with a directory, otherwise we're squashing the file list as part of
the union

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.71 2005/05/12 23:43:49 joris Exp $	*/
d110 1
a111 1
static int      cvs_file_getdir   (CVSFILE *, int, char *);
d348 2
a349 1
cvs_file_get(const char *path, int flags)
d354 1
a354 1
	return cvs_file_getspec(files, 1, flags);
d367 2
a368 1
cvs_file_getspec(char **fspec, int fsn, int flags)
d382 8
d425 1
a425 1
			if (cvs_file_getdir(nf, flags, np) < 0) {
d429 5
d609 1
a609 1
cvs_file_getdir(CVSFILE *cf, int flags, char *path)
d648 6
d723 8
d775 6
d805 1
a805 1
		if (cvs_file_getdir(cfp, flags, np) < 0) {
@


1.71
log
@

set cvsent to NULL if entfile is NULL, fixes a crash
in cvs_file_lget().
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.70 2005/05/12 23:35:42 joris Exp $	*/
d1014 4
a1017 1
		if (ent->ce_tag != NULL) {
a1022 1
		ent->ce_rev = NULL;
@


1.70
log
@

introduce a new flag to the file api: CF_NOFILES, which allows us
to only load directories and skip regular files.

tested and ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.69 2005/05/01 23:21:39 joris Exp $	*/
d678 3
@


1.69
log
@

if CF_MKADMIN flag is specified the administrative files will
be created (if missing) in cvs_load_dirinfo().
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.68 2005/04/25 21:58:32 joris Exp $	*/
d656 3
@


1.68
log
@

first part of file API changes:

- fix our behaviour regarding directories or files in a different
  directory than we currently are as arguments to commands, this
  allows stuff like "cvs status sys/arch/i386/Makefile" to work.

- when parsing a pathname only load the needed nodes of the path
  instead of loading *everything* in memory.

the next step in this is to merge the collection and callback
execution together.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.67 2005/04/22 15:16:15 joris Exp $	*/
d110 1
a110 1
static int	cvs_load_dirinfo  (CVSFILE *);
d547 1
a547 1
cvs_load_dirinfo(CVSFILE *cf)
d560 3
d1017 1
a1017 1
	if ((cfp->cf_type == DT_DIR) && (cvs_load_dirinfo(cfp) < 0)) {
@


1.67
log
@

finish support for the '-' token in the Entry file, this allows
us to mark files as removed, and lets the remove command work
completely.

tested and ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.66 2005/04/19 00:32:55 joris Exp $	*/
d110 2
a111 1
static int      cvs_file_getdir  (CVSFILE *, int);
d350 4
a353 1
	return cvs_file_lget(path, flags, NULL, NULL);
d369 1
d371 3
a373 1
	CVSFILE *base, *cf, *nf;
d375 2
a376 1
	base = cvs_file_get(".", 0);
a381 1
		cf = base;
d383 1
d385 8
a392 5
		do {
			np = strchr(sp, '/');
			if (np != NULL)
				*np = '\0';
			nf = cvs_file_find(cf, sp);
d394 5
a398 1
				nf = cvs_file_lget(pcopy, 0, cf, NULL);
d404 1
a404 1
				if (cvs_file_attach(cf, nf) < 0) {
d409 1
d411 7
a417 3
			if (np != NULL) {
				*np = '/';
				sp = np + 1;
d419 1
a419 3

			cf = nf;
		} while (np != NULL);
d544 1
a544 5
 * cvs_file_getdir()
 *
 * Get a cvs directory structure for the directory whose path is <dir>.
 * This function should not free the directory information on error, as this
 * is performed by cvs_file_free().
d547 1
a547 1
cvs_file_getdir(CVSFILE *cf, int flags)
d549 2
a550 8
	int ret, fd, l;
	u_int ndirs, nfiles;
	long base;
	u_char *dp, *ep;
	char fbuf[2048], pbuf[MAXPATHLEN], fpath[MAXPATHLEN];
	struct dirent *ent;
	CVSFILE *cfp;
	CVSENTRIES *entfile;
d552 1
a552 6
	struct cvs_ent *cvsent;
	struct cvs_flist dirs;

	ndirs = 0;
	nfiles = 0;
	SIMPLEQ_INIT(&dirs);
a554 1

a559 3
		if (flags & CF_MKADMIN)
			cvs_mkadmin(cf, 0755);

d577 2
d580 44
a623 1
			entfile = cvs_ent_open(fpath, O_RDONLY);
d630 3
a632 3
	fd = open(fpath, O_RDONLY);
	if (fd == -1) {
		cvs_log(LP_ERRNO, "failed to open `%s'", fpath);
d636 4
a639 17
	/* To load all files, we first get the entries for the directory and
	 * load the information for each of those entries.  The handle to
	 * the Entries file kept in the directory data is only temporary and
	 * the files should remove their entry when they use it.  After all
	 * files in the directory have been processed, the Entries handle
	 * should only be left with those entries for which no real file
	 * exists.  We then build file structures for those files too, as
	 * we will likely receive fresh copies from the server as part of the
	 * response.
	 */
	do {
		ret = getdirentries(fd, fbuf, sizeof(fbuf), &base);
		if (ret == -1) {
			cvs_log(LP_ERRNO, "failed to get directory entries");
			(void)close(fd);
			return (-1);
		}
d641 2
a642 7
		dp = fbuf;
		ep = fbuf + (size_t)ret;
		while (dp < ep) {
			ent = (struct dirent *)dp;
			dp += ent->d_reclen;
			if (ent->d_fileno == 0)
				continue;
d644 2
a645 2
			if ((flags & CF_IGNORE) && cvs_file_chkign(ent->d_name))
				continue;
d647 6
a652 2
			if ((flags & CF_NOSYMS) && (ent->d_type == DT_LNK))
				continue;
d654 2
a655 4
			if (!(flags & CF_RECURSE) && (ent->d_type == DT_DIR)) {
				if (entfile != NULL)
					(void)cvs_ent_remove(entfile,
					    ent->d_name);
d657 1
a657 1
			}
d659 8
a666 9
			l = snprintf(pbuf, sizeof(pbuf), "%s/%s", fpath,
			    ent->d_name);
			if (l == -1 || l >= (int)sizeof(pbuf)) {
				errno = ENAMETOOLONG;
				cvs_log(LP_ERRNO, "%s", pbuf);
				
				(void)close(fd);
				return (-1);
			}
d668 2
d673 1
d675 1
a675 1
				(void)close(fd);
d681 1
a681 4
			if (cfp->cf_type == DT_DIR) {
				SIMPLEQ_INSERT_TAIL(&dirs, cfp, cf_list);
				ndirs++;
			} else {
d683 1
a683 1
				    cf_list);
d686 2
a688 1
	} while (ret > 0);
d690 14
a703 4
	if (entfile != NULL) {
		/* now create file structure for files which have an
		 * entry in the Entries file but no file on disk
		 */
d705 5
a714 2

				(void)close(fd);
d718 9
a726 8
			cfp = cvs_file_lget(pbuf, flags, cf, cvsent);
			if (cfp != NULL) {
				if (cfp->cf_type == DT_DIR) {
					SIMPLEQ_INSERT_TAIL(&dirs, cfp, cf_list);
					ndirs++;
				} else {
					SIMPLEQ_INSERT_TAIL(&(cf->cf_files), cfp,
					    cf_list);
d729 8
d738 3
d746 4
a749 2
		cvs_file_sort(&(cf->cf_files), nfiles);
		cvs_file_sort(&dirs, ndirs);
d755 11
a765 1
		SIMPLEQ_INSERT_TAIL(&(cf->cf_files), cfp, cf_list);
a767 1
	(void)close(fd);
d1014 1
a1014 1
	if ((cfp->cf_type == DT_DIR) && (cvs_file_getdir(cfp, flags) < 0)) {
@


1.66
log
@

update cf_type to the correct type if we cannot stat(2) the
requested file or directory in cvs_file_lget().

should fix those "attempt to send Entry for non-regular file" errors.

reported by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.65 2005/04/18 22:28:41 joris Exp $	*/
d930 5
a934 1
			cfp->cf_cvstat = CVS_FST_LOST;
@


1.65
log
@

only copy ce_tag is it is not NULL, fixes a segfault on
startup for the update command.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.64 2005/04/18 21:24:57 joris Exp $	*/
d922 8
a929 1
		} else
d931 1
@


1.64
log
@

free cf_tag for regular files in cvs_file_free();

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.63 2005/04/18 21:10:39 joris Exp $	*/
d929 5
a933 3
		if ((cfp->cf_tag = cvs_strdup(ent->ce_tag)) == NULL) {
			cvs_file_free(cfp);
			return (NULL);
@


1.63
log
@

more debugging leftovers
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.62 2005/04/18 21:02:50 jfb Exp $	*/
d731 3
d735 1
@


1.62
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.61 2005/04/16 20:05:05 xsa Exp $	*/
a877 2

	printf("lget(%s)\n", path);
@


1.61
log
@more snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.60 2005/04/13 20:11:21 joris Exp $	*/
d110 6
a115 7
static int       cvs_file_getdir   (CVSFILE *, int);
static void      cvs_file_freedir  (struct cvs_dir *);
static int       cvs_file_sort     (struct cvs_flist *, u_int);
static int       cvs_file_cmp      (const void *, const void *);
static int       cvs_file_cmpname  (const char *, const char *);
static CVSFILE*  cvs_file_alloc    (const char *, u_int);
static CVSFILE*  cvs_file_lget     (const char *, int, CVSFILE *);
d253 1
d263 2
a264 2
		cfp->cf_ddat->cd_root = cvsroot_get(path);
		cfp->cf_ddat->cd_repo = strdup(cvs_file_getpath(cfp,
d266 1
a266 1
		if (cfp->cf_ddat->cd_repo == NULL) {
d276 3
a278 4
		cfp->cf_ddat->cd_ent = cvs_ent_open(path, O_RDWR);
		if (cfp->cf_ddat->cd_ent != NULL) {
			cvs_ent_close(cfp->cf_ddat->cd_ent);
			cfp->cf_ddat->cd_ent = NULL;
a317 1
	cfp->cf_mtime = orig->cf_mtime;
d320 3
a322 1
	if (orig->cf_type == DT_DIR) {
d349 1
a349 1
	return cvs_file_lget(path, flags, NULL);
d383 1
a383 1
				nf = cvs_file_lget(pcopy, 0, cf);
d445 1
a445 1
		TAILQ_FOREACH(sf, &(cf->cf_ddat->cd_files), cf_list)
a514 2
	struct cvs_dir *dp;

d518 1
a518 4
	dp = parent->cf_ddat;

	TAILQ_INSERT_TAIL(&(dp->cd_files), file, cf_list);
	dp->cd_nfiles++;
d536 1
a536 1
	u_int ndirs;
d542 1
a543 1
	struct cvs_dir *cdp;
d548 2
a549 2
	TAILQ_INIT(&dirs);
	cdp = cf->cf_ddat;
d553 2
a554 2
	cdp->cd_root = cvsroot_get(fpath);
	if (cdp->cd_root == NULL)
d571 2
a572 2
				cdp->cd_repo = strdup(pbuf);
				if (cdp->cd_repo == NULL) {
d579 1
a579 1
			cdp->cd_ent = cvs_ent_open(fpath, O_RDONLY);
d625 2
a626 2
				if (cdp->cd_ent != NULL)
					(void)cvs_ent_remove(cdp->cd_ent,
d641 3
a643 1
			cfp = cvs_file_lget(pbuf, flags, cf);
d648 2
d652 1
a652 1
				TAILQ_INSERT_TAIL(&dirs, cfp, cf_list);
d655 1
a655 1
				TAILQ_INSERT_TAIL(&(cdp->cd_files), cfp,
d657 1
a657 1
				cdp->cd_nfiles++;
d662 1
a662 1
	if (cdp->cd_ent != NULL) {
d666 1
a666 1
		while ((cvsent = cvs_ent_next(cdp->cd_ent)) != NULL) {
d677 1
a677 1
			cfp = cvs_file_lget(pbuf, flags, cf);
d680 1
a680 1
					TAILQ_INSERT_TAIL(&dirs, cfp, cf_list);
d683 1
a683 1
					TAILQ_INSERT_TAIL(&(cdp->cd_files), cfp,
d685 1
a685 1
					cdp->cd_nfiles++;
d689 1
a689 2
		cvs_ent_close(cdp->cd_ent);
		cdp->cd_ent = NULL;
d693 1
a693 1
		cvs_file_sort(&(cdp->cd_files), cdp->cd_nfiles);
d697 4
a700 4
	while (!TAILQ_EMPTY(&dirs)) {
		cfp = TAILQ_FIRST(&dirs);
		TAILQ_REMOVE(&dirs, cfp, cf_list);
		TAILQ_INSERT_TAIL(&(cdp->cd_files), cfp, cf_list);
a701 1
	cdp->cd_nfiles += ndirs;
a703 1

d716 2
a717 2
	if (cf->cf_ddat != NULL)
		cvs_file_freedir(cf->cf_ddat);
d720 12
d751 1
a751 1
		TAILQ_FOREACH(fp, &(cf->cf_ddat->cd_files), cf_list) {
a761 27

/*
 * cvs_file_freedir()
 *
 * Free a cvs_dir structure and its contents.
 */
static void
cvs_file_freedir(struct cvs_dir *cd)
{
	CVSFILE *cfp;

	if (cd->cd_root != NULL)
		cvsroot_free(cd->cd_root);
	if (cd->cd_repo != NULL)
		free(cd->cd_repo);

	if (cd->cd_ent != NULL)
		cvs_ent_close(cd->cd_ent);

	while (!TAILQ_EMPTY(&(cd->cd_files))) {
		cfp = TAILQ_FIRST(&(cd->cd_files));
		TAILQ_REMOVE(&(cd->cd_files), cfp, cf_list);
		cvs_file_free(cfp);
	}
}


d784 1
a784 1
	TAILQ_FOREACH(cf, flp, cf_list) {
d789 1
a789 1
				TAILQ_INSERT_HEAD(flp, cfvec[i], cf_list);
d798 1
a798 1
		TAILQ_REMOVE(flp, cf, cf_list);
d802 1
a802 1
	TAILQ_INIT(flp);
d809 1
a809 1
		TAILQ_INSERT_HEAD(flp, cfvec[i], cf_list);
d820 2
a821 2
	cf1 = *(const CVSFILE **)f1;
	cf2 = *(const CVSFILE **)f2;
a834 1
	struct cvs_dir *ddat;
d843 7
a855 2
	cfp->cf_type = type;
	cfp->cf_cvstat = CVS_FST_UNKNOWN;
a856 11
	if (type == DT_DIR) {
		ddat = (struct cvs_dir *)malloc(sizeof(*ddat));
		if (ddat == NULL) {
			cvs_log(LP_ERRNO, "failed to allocate directory data");
			cvs_file_free(cfp);
			return (NULL);
		}
		memset(ddat, 0, sizeof(*ddat));
		TAILQ_INIT(&(ddat->cd_files));
		cfp->cf_ddat = ddat;
	}
d869 1
a869 1
cvs_file_lget(const char *path, int flags, CVSFILE *parent)
a874 1
	struct cvs_ent *ent = NULL;
d879 2
d890 1
a890 4
		cfp->cf_ddat->cd_flags |= CVS_DIRF_BASE;

	if ((parent != NULL) && (CVS_DIR_ENTRIES(parent) != NULL))
		ent = cvs_ent_get(CVS_DIR_ENTRIES(parent), CVS_FILE_NAME(cfp));
d894 2
a895 1
		cfp->cf_mtime = st.st_mtime;
d924 9
a932 2
	if (ent != NULL)
		cvs_ent_remove(CVS_DIR_ENTRIES(parent), CVS_FILE_NAME(cfp));
@


1.60
log
@

file callbacks won't return -1 anymore, but a CVS_EX_* error

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.59 2005/03/29 17:37:37 joris Exp $	*/
d127 1
a127 1
	int i;
d145 7
a151 1
		snprintf(path, sizeof(path), "%s/.cvsignore", pwd->pw_dir);
d540 1
a540 1
	int ret, fd;
d567 7
a573 1
		snprintf(pbuf, sizeof(pbuf), "%s/" CVS_PATH_CVSDIR, fpath);
d636 1
a636 1
			snprintf(pbuf, sizeof(pbuf), "%s/%s", fpath,
d638 8
d668 1
a668 1
			snprintf(pbuf, sizeof(pbuf), "%s/%s", fpath,
d670 8
@


1.59
log
@

cvs_file_attach() can fail, make sure we can handle it
when it does.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.58 2005/03/26 08:09:54 tedu Exp $	*/
d717 1
a717 1
			if (ret == -1)
@


1.58
log
@fix a variety of things i found at coverity.  ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.57 2005/03/24 14:35:18 jfb Exp $	*/
d383 4
a386 1
				cvs_file_attach(cf, nf);
@


1.57
log
@ditch the filename hash table and use the new strtab code instead

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.56 2005/03/05 17:19:50 jfb Exp $	*/
d835 1
@


1.56
log
@fix file loading when recursion is disabled.  this should fix the
weird behaviour encountered when using the -l option to most
commands

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.55 2005/03/05 03:00:27 jfb Exp $	*/
d45 1
a100 10
 * Filename hash table used to avoid duplication of name strings when working
 * on large source trees with common parts.
 */
SLIST_HEAD(cvs_fhb, cvs_fname);

static struct cvs_fhb cvs_fnht[CVS_FILE_NBUCKETS];



/*
d110 7
a116 10
static int               cvs_file_getdir   (CVSFILE *, int);
static void              cvs_file_freedir  (struct cvs_dir *);
static int               cvs_file_sort     (struct cvs_flist *, u_int);
static int               cvs_file_cmp      (const void *, const void *);
static int               cvs_file_cmpname  (const char *, const char *);
static u_int8_t          cvs_file_hashname (const char *);
static struct cvs_fname* cvs_file_getname  (const char *);
static void              cvs_file_freename (struct cvs_fname *);
static CVSFILE*          cvs_file_alloc    (const char *, u_int);
static CVSFILE*          cvs_file_lget     (const char *, int, CVSFILE *);
a132 4
	/* initialize the filename hash table */
	for (i = 0; i < CVS_FILE_NBUCKETS; i++)
		SLIST_INIT(&(cvs_fnht[i]));

d692 1
a692 1
		cvs_file_freename(cf->cf_name);
d832 1
a832 1
	cfp->cf_name = cvs_file_getname(basename(path));
d834 1
a834 1
		cvs_log(LP_ERR, "failed to get file name from table");
a935 92
}


/*
 * cvs_file_hashname()
 *
 * Generate an 8 bit hash value from the name of a file.
 * XXX Improve my distribution!
 */
static u_int8_t
cvs_file_hashname(const char *name)
{
	const char *np;
	u_int8_t h;

	h = 0xb5;
	for (np = name; *np != '\0'; np++)
		h ^= (*np << 3 ^ *np >> 1);

	return (h);
}


/*
 * cvs_file_getname()
 *
 * Look for the file name <name> in the filename hash table.
 * If no entry is found for that name, a new one is created and inserted into
 * the table.  The name's reference count is increased.
 */
static struct cvs_fname*
cvs_file_getname(const char *name)
{
	u_int8_t h;
	struct cvs_fname *fnp;

	h = cvs_file_hashname(name);

	SLIST_FOREACH(fnp, &(cvs_fnht[h]), cf_list)
		if (strcmp(name, fnp->cf_name) == 0) {
			fnp->cf_ref++;
			break;
		}

	if (fnp == NULL) {
		fnp = (struct cvs_fname *)malloc(sizeof(*fnp));
		if (fnp == NULL) {
			cvs_log(LP_ERRNO,
			    "failed to allocate new file name entry");
			return (NULL);
		}

		fnp->cf_name = strdup(name);
		if (fnp->cf_name == NULL) {
			cvs_log(LP_ERRNO, "failed to duplicate name");
			free(fnp);
			return (NULL);
		}

		fnp->cf_ref = 1;
		SLIST_INSERT_HEAD(&(cvs_fnht[h]), fnp, cf_list);
	}

	return (fnp);
}


/*
 * cvs_file_freename()
 *
 * Free the reference to a file name previously obtained with
 * cvs_file_getname().
 */
static void
cvs_file_freename(struct cvs_fname *fn)
{
	u_int8_t h;

	if (fn->cf_ref == 0) {
		cvs_log(LP_WARN, "refcount for `%s' is already 0", fn->cf_name);
		return;
	}

	fn->cf_ref--;
	if (fn->cf_ref == 0) {
		/* no more references, free the file */
		h = cvs_file_hashname(fn->cf_name);

		SLIST_REMOVE(&(cvs_fnht[h]), fn, cvs_fname, cf_list);
		free(fn->cf_name);
		free(fn);
	}
@


1.55
log
@make sure that errors from cvs_file_lget() cascade down instead of
ignoring them

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.54 2005/03/02 16:56:58 joris Exp $	*/
d589 1
a589 2
	if (!(flags & CF_RECURSE) ||
	    ((flags & CF_KNOWN) && (cf->cf_cvstat == CVS_FST_UNKNOWN)))
d629 7
@


1.54
log
@

add a flag to identify the base directory in file hierarchies.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.53 2005/02/25 20:32:48 jfb Exp $	*/
d634 12
a645 9
			if (cfp != NULL) {
				if (cfp->cf_type == DT_DIR) {
					TAILQ_INSERT_TAIL(&dirs, cfp, cf_list);
					ndirs++;
				} else {
					TAILQ_INSERT_TAIL(&(cdp->cd_files), cfp,
					    cf_list);
					cdp->cd_nfiles++;
				}
@


1.53
log
@- switch to rcsnum_parse() where appropriate
- make rcsnum_parse() fail if it encounters an invalid character
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.52 2005/01/24 16:41:28 jfb Exp $	*/
d888 3
@


1.52
log
@when loading a file's information, remove its entry from the parent
directory's entries handle even if the file doesn't exist on disk
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.51 2005/01/12 20:10:09 jfb Exp $	*/
d151 1
a151 2
	if (((cvs_addedrev = rcsnum_alloc()) == NULL) ||
	    (rcsnum_aton("0", NULL, cvs_addedrev) < 0))
@


1.51
log
@use basename(3) instead of mangling the path to figure out the
filename ourselves.  Removes a bunch of now useless code.

spotted by Joris Vink, diff by me
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.50 2005/01/11 00:01:14 jfb Exp $	*/
a912 3

			cvs_ent_remove(CVS_DIR_ENTRIES(parent),
			    CVS_FILE_NAME(cfp));
d923 3
@


1.50
log
@Close the Entries file we just created upon directory creation.  This
fixes the problem where a checkout would only add entries for
directories.

from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.49 2005/01/06 20:17:25 jfb Exp $	*/
d35 1
a829 3
	size_t len;
	char pbuf[MAXPATHLEN];
	const char *fnp;
d840 1
a840 13
	/* ditch trailing slashes */
	strlcpy(pbuf, path, sizeof(pbuf));
	len = strlen(pbuf);
	while (pbuf[len - 1] == '/')
		pbuf[--len] = '\0';

	fnp = strrchr(path, '/');
	if (fnp == NULL)
		fnp = path;
	else
		fnp++;

	cfp->cf_name = cvs_file_getname(fnp);
@


1.49
log
@add *.core as part of the standard ignore patterns
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.48 2005/01/06 20:15:16 jfb Exp $	*/
d287 4
@


1.48
log
@* always assign a cvsroot to directories, even if they are unknown
  to cvs
* only avoid recursion on unknown directories if the CF_KNOWN flag
  was specified
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.47 2005/01/03 22:53:06 jfb Exp $	*/
d80 1
@


1.47
log
@when releasing a file structure, free the reference to its name so
we don't leak memory

spotted by Joris Vink, more complete diff from me
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.46 2004/12/28 20:00:14 jfb Exp $	*/
d560 4
a564 4
		cdp->cd_root = cvsroot_get(fpath);
		if (cdp->cd_root == NULL)
			return (-1);

d584 2
a585 1
	if (!(flags & CF_RECURSE) || (cf->cf_cvstat == CVS_FST_UNKNOWN))
@


1.46
log
@check the return values of rcsnum_alloc() and rcsnum_aton() on
startup

diff from Joris Vink, with minor changes
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.45 2004/12/28 19:44:17 xsa Exp $	*/
d124 1
d692 2
d1013 28
@


1.45
log
@add more standard patterns to ignore; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.44 2004/12/14 21:23:44 jfb Exp $	*/
d148 3
a150 2
	cvs_addedrev = rcsnum_alloc();
	rcsnum_aton("0", NULL, cvs_addedrev);
@


1.44
log
@When loading directory entries, create file structures for files which
have been lost but have a valid entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.43 2004/12/13 19:38:22 jfb Exp $	*/
d67 1
d71 1
d74 4
d81 3
d90 1
@


1.43
log
@get rid of void* arithmetic to nuke another gcc warning
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.42 2004/12/08 19:54:11 jfb Exp $	*/
d539 1
d581 10
d630 18
d867 2
a868 1
	int cwd;
d873 2
a874 4
	if (strcmp(path, ".") == 0)
		cwd = 1;
	else
		cwd = 0;
d876 3
a878 4
	if (stat(path, &st) == -1) {
		cvs_log(LP_ERRNO, "failed to stat %s", path);
		return (NULL);
	}
d880 1
a880 2
	cfp = cvs_file_alloc(path, IFTODT(st.st_mode));
	if (cfp == NULL)
a882 2
	cfp->cf_mode = st.st_mode & ACCESSPERMS;
	cfp->cf_mtime = st.st_mtime;
d884 1
a884 1
	if ((parent != NULL) && (CVS_DIR_ENTRIES(parent) != NULL)) {
a885 1
	}
d887 7
a893 9
	if (ent == NULL) {
		cfp->cf_cvstat = (cwd == 1) ?
		    CVS_FST_UPTODATE : CVS_FST_UNKNOWN;
	} else {
		/* always show directories as up-to-date */
		if (ent->ce_type == CVS_ENT_DIR)
			cfp->cf_cvstat = CVS_FST_UPTODATE;
		else if (rcsnum_cmp(ent->ce_rev, cvs_addedrev, 2) == 0)
			cfp->cf_cvstat = CVS_FST_ADDED;
d895 2
a896 2
			/* check last modified time */
			if (ent->ce_mtime >= (time_t)st.st_mtime)
d898 12
a909 2
			else
				cfp->cf_cvstat = CVS_FST_MODIFIED;
d911 8
@


1.42
log
@check the return value of a strdup() call and return an error on
failure

from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.41 2004/12/08 19:44:28 jfb Exp $	*/
d533 1
a533 1
	void *dp, *ep;
@


1.41
log
@avoid complaining twice when we fail to load a file, and fix a gcc
warning
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.40 2004/12/07 18:14:04 jfb Exp $	*/
d949 6
@


1.40
log
@when loading directory info, only close the handle to the Entries file
if it is not NULL.  fixes a crash when running commands that have no
administrative files to open yet (i.e. import)

noticed by and discussed with Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.39 2004/12/07 17:10:56 tedu Exp $	*/
d765 3
a767 3
	CVSFILE *cf1, *cf2;
	cf1 = *(CVSFILE **)f1;
	cf2 = *(CVSFILE **)f2;
d816 1
d854 1
a854 2
	if (cfp == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate CVS file data");
a855 1
	}
@


1.39
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.38 2004/12/06 21:03:12 deraadt Exp $	*/
d618 4
a621 4
#if 1
	cvs_ent_close(cdp->cd_ent);
	cdp->cd_ent = NULL;
#endif
@


1.38
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.37 2004/12/06 07:28:15 jfb Exp $	*/
a61 1

a90 1

a122 1

a179 1

a214 1

a244 1

a297 1

a353 1

a404 1

a456 1

a501 1

a526 1

a645 1

a661 1

a686 1

a715 1

a776 1

a833 1

a905 1

a926 1

@


1.37
log
@when loading the file information from the Entries file, open it in
read-only mode.  fixes a problem with running non-modifying commands
in directories with restrictive permissions.

Reported and patch tested by Peter Hessler
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.36 2004/12/03 20:19:54 jfb Exp $	*/
d157 1
a157 2
		}
		else {
d234 1
a234 2
		}
		else if (fnmatch(ip->ip_pat, file, flags) == 0)
d280 1
a280 2
	}
	else {
d440 1
a440 2
			}
			else if (*(pp + 1) == '\0')
d621 1
a621 2
				}
				else {
d689 1
a689 2
	}
	else
d886 1
a886 2
	}
	else {
@


1.36
log
@If the timestamp in the Entries file is larger than the file's
timestamp, consider the file to be up to date.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d583 1
a583 1
			cdp->cd_ent = cvs_ent_open(fpath, O_RDWR);
@


1.35
log
@Add cvs_file_copy() to create a copy of a file structure.
This will be used in the commit code.
@
text
@d901 1
a901 1
			if (ent->ce_mtime == (time_t)st.st_mtime)
@


1.34
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@a259 1
	printf("cvs_file_create(%s)\n", path);
a263 1
	cfp->cf_type = type;
d297 37
d830 1
a830 1
		cvs_log(LP_ERR, "WTF!?");
d901 1
a901 1
			if (ent->ce_mtime == st.st_mtime)
@


1.33
log
@

check return value of strdup(3);
ok jfb
@
text
@d89 11
d109 9
a117 7
static int        cvs_file_getdir  (CVSFILE *, int);
static void       cvs_file_freedir (struct cvs_dir *);
static int        cvs_file_sort    (struct cvs_flist *, u_int);
static int        cvs_file_cmp     (const void *, const void *);
static int        cvs_file_cmpname (const char *, const char *);
static CVSFILE*   cvs_file_alloc   (const char *, u_int);
static CVSFILE*   cvs_file_lget    (const char *, int, CVSFILE *);
d135 4
d155 2
a156 1
				cvs_log(LP_ERRNO, "failed to open `%s'", path);
d254 1
a254 1
cvs_file_create(const char *path, u_int type, mode_t mode)
d257 1
d260 1
d267 1
a267 2
	cfp->cf_ddat->cd_root = cvsroot_get(path);
	cfp->cf_ddat->cd_repo = strdup(cfp->cf_path);
d269 8
a276 4
	if (cfp->cf_ddat->cd_repo == NULL) {
		cvs_file_free(cfp);
		return (NULL);
	}
a277 1
	if (type == DT_DIR) {
d414 1
a414 1
			if (cvs_file_cmpname(pp, sf->cf_name) == 0)
d428 47
d515 1
a515 1
	char fbuf[2048], pbuf[MAXPATHLEN];
d526 2
d529 1
a529 1
		cdp->cd_root = cvsroot_get(cf->cf_path);
d537 1
a537 2
		snprintf(pbuf, sizeof(pbuf), "%s/" CVS_PATH_CVSDIR,
		    cf->cf_path);
d539 1
a539 2
			if (cvs_readrepo(cf->cf_path, pbuf,
			    sizeof(pbuf)) == 0) {
d548 1
a548 1
			cdp->cd_ent = cvs_ent_open(cf->cf_path, O_RDWR);
d555 1
a555 1
	fd = open(cf->cf_path, O_RDONLY);
d557 1
a557 1
		cvs_log(LP_ERRNO, "failed to open `%s'", cf->cf_path);
d583 2
a584 2
			snprintf(pbuf, sizeof(pbuf), "%s/%s",
			    cf->cf_path, ent->d_name);
d600 5
a631 2
	if (cf->cf_path != NULL)
		free(cf->cf_path);
d755 1
a755 1
	return cvs_file_cmpname(cf1->cf_name, cf2->cf_name);
d759 6
d770 1
d787 9
a795 3
	cfp->cf_path = strdup(pbuf);
	if (cfp->cf_path == NULL) {
		free(cfp);
a797 7

	cfp->cf_name = strrchr(cfp->cf_path, '/');
	if (cfp->cf_name == NULL)
		cfp->cf_name = cfp->cf_path;
	else
		cfp->cf_name++;

d829 1
a829 3
	struct cvs_ent *ent;

	ent = NULL;
d851 1
a851 1
		ent = cvs_ent_get(CVS_DIR_ENTRIES(parent), cfp->cf_name);
d887 60
@


1.32
log
@Unbreak when running into files with an inode of 0
@
text
@d250 5
@


1.31
log
@Skip directory entries which have a file number of 0
@
text
@d499 1
a501 1
			dp += ent->d_reclen;
@


1.30
log
@Do not attempt to free directory information on error cases in
cvs_file_getdir().  That information will get freed anyways by
cvs_file_free().  Fixes a double free found by Todd Fries.
@
text
@d499 2
@


1.29
log
@More unused variables
@
text
@a256 1

d430 2
d454 1
a454 2
		if (cdp->cd_root == NULL) {
			cvs_file_freedir(cdp);
a455 1
		}
a469 1
					free(cdp);
a483 1
		cvs_file_freedir(cdp);
a491 1
			cvs_file_freedir(cdp);
@


1.28
log
@When comparing a file's timestamp against the one found in the Entries
file, do a straight compare between the time_t's instead of generating
asctime()-style strings and doing strcmp(), and make sure that we have
a repository string if we create the directory, so the file gets
created when calling cvs_mkadmin()
@
text
@a412 1
	struct cvs_ent *ent;
a745 2
	size_t len;
	char buf[32];
a746 1
	struct tm lmtm;
@


1.27
log
@If we create a directory with cvs_file_create(), keep a pointer to the
newly created Entries file in the directory data
@
text
@d248 1
d470 2
a478 1

d791 1
a791 13
			if ((gmtime_r((time_t *)&(st.st_mtime),
			    &lmtm) == NULL) ||
			    (asctime_r(&lmtm, buf) == NULL)) {
				cvs_log(LP_ERR,
				    "failed to generate file timestamp");
				/* fake an up to date file */
				strlcpy(buf, ent->ce_timestamp, sizeof(buf));
			}
			len = strlen(buf);
			if ((len > 0) && (buf[len - 1] == '\n'))
				buf[--len] = '\0';

			if (strcmp(buf, ent->ce_timestamp) == 0)
@


1.26
log
@Implement cvs_file_getspec() so we can finally deal with explicit file
arguments on the command-line, and fix a bunch of minor issues
@
text
@d255 2
@


1.25
log
@Cleanup, and don't close the Entries file handle for a directory when we
are done loading its contents.  We will need the file for whatever changes
we bring to it
@
text
@d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
d129 1
a129 1
		cvs_file_ignore(cvs_ign_std[i]); 
d230 2
d244 1
d247 1
d250 1
a250 1
		if (mkdir(path, mode) == -1) {
d254 1
d304 38
a341 2
	/* XXX implement me */
	return (NULL);
d449 6
a454 5
	cdp->cd_root = cvsroot_get(cf->cf_path);
	if (cdp->cd_root == NULL) {
		cvs_file_freedir(cdp);
		return (-1);
	}
d456 2
a457 2
	if (flags & CF_MKADMIN)
		cvs_mkadmin(cf, 0755);
d459 11
a469 8
	/* if the CVS administrative directory exists, load the info */
	snprintf(pbuf, sizeof(pbuf), "%s/" CVS_PATH_CVSDIR, cf->cf_path);
	if ((stat(pbuf, &st) == 0) && S_ISDIR(st.st_mode)) {
		if (cvs_readrepo(cf->cf_path, pbuf, sizeof(pbuf)) == 0) {
			cdp->cd_repo = strdup(pbuf);
			if (cdp->cd_repo == NULL) {
				free(cdp);
				return (-1);
d471 2
a474 1
		cdp->cd_ent = cvs_ent_open(cf->cf_path, O_RDWR);
d477 3
d512 2
a513 2
				if (cfp->cf_type == DT_DIR) { 
					TAILQ_INSERT_HEAD(&dirs, cfp, cf_list);
d517 1
a517 1
					TAILQ_INSERT_HEAD(&(cdp->cd_files), cfp,
d529 4
a532 1
	TAILQ_FOREACH(cfp, &dirs, cf_list)
d534 1
a537 1
	cf->cf_ddat = cdp;
d775 1
a775 1
	if (ent == NULL)
d778 1
d806 3
a808 7
	if ((cfp->cf_type == DT_DIR) && ((flags & CF_RECURSE) || cwd)) {
		if ((flags & CF_KNOWN) && (cfp->cf_cvstat == CVS_FST_UNKNOWN)) {
		}
		else if (cvs_file_getdir(cfp, flags) < 0) {
			cvs_file_free(cfp);
			return (NULL);
		}
@


1.24
log
@* add a flag CF_NOSYMS to avoid loading information about symbolic links
  and fix 2 calls to cvs_splitpath()
* unbreak cvs_file_find()
@
text
@d230 1
a375 5
	/* if the parent doesn't have an entry for that file, create it */
	if ((dp->cd_ent != NULL) &&
	    ((ent = cvs_ent_get(dp->cd_ent, file->cf_name)) == NULL)) {
	}

d428 1
a428 1
		cdp->cd_ent = cvs_ent_open(cf->cf_path, O_RDONLY);
a474 6

	/* we can now close our Entries file */
	if (cdp->cd_ent != NULL) {
		cvs_ent_close(cdp->cd_ent);
		cdp->cd_ent = NULL;
	}
@


1.23
log
@Handle case insensitivity for real
@
text
@d324 1
a324 1
			*sp = '\0';
d352 1
a352 1
	return (NULL);
d458 3
@


1.22
log
@Add fields to keep track of the file's mode and last modification time
@
text
@d102 1
d206 1
d209 4
d215 1
a215 1
			if (strcmp(file, ip->ip_pat) == 0)
d218 1
a218 1
		else if (fnmatch(ip->ip_pat, file, FNM_PERIOD) == 0)
d343 1
a343 1
			if (strcmp(pp, sf->cf_name) == 0)
d367 2
d373 9
a381 2
	TAILQ_INSERT_HEAD(&(parent->cf_ddat->cd_files), file, cf_list);
	parent->cf_ddat->cd_nfiles++;
d632 1
a632 1
	return strcmp(cf1->cf_name, cf2->cf_name);
d770 8
@


1.21
log
@the CF_STAT flag is useless now, all we have to do is extract the required
information and keep it in the file structure
@
text
@d236 1
d351 23
d675 2
d708 2
@


1.20
log
@Fix an annoying error message on checkouts by loading administrative
information from the CVS Entries, Root and Repository files if the
CVS directory exists
@
text
@d262 6
a267 8
 * the function.  The CF_STAT flag is used to keep stat information of the
 * file in the structure after it is used (it is lost otherwise).  The
 * CF_RECURSE flag causes the function to recursively load subdirectories
 * when <path> is a directory.  The CF_SORT flag causes the files to be
 * sorted in alphabetical order upon loading.
 * The special case of "." as a path specification generates recursion for
 * a single level and is equivalent to calling cvs_file_get() on all files
 * of that directory.
a469 2
	if (cf->cf_stat != NULL)
		free(cf->cf_stat);
a718 2
			free(cfp->cf_ddat);
			cfp->cf_ddat = NULL;
a725 11
	if (flags & CF_STAT) {
		cfp->cf_stat = (struct stat *)malloc(sizeof(struct stat));
		if (cfp->cf_stat == NULL) {
			cvs_log(LP_ERRNO, "failed to allocate stat structure");
			cvs_file_free(cfp);
			return (NULL);
		}

		memcpy(cfp->cf_stat, &st, sizeof(struct stat));
	}

a727 2


@


1.19
log
@cleanup
@
text
@d367 1
a374 8
	if (cvs_readrepo(cf->cf_path, pbuf, sizeof(pbuf)) == 0) {
		cdp->cd_repo = strdup(pbuf);
		if (cdp->cd_repo == NULL) {
			free(cdp);
			return (-1);
		}
	}

d384 13
a396 1
	cdp->cd_ent = cvs_ent_open(cf->cf_path, O_RDONLY);
@


1.18
log
@Initialize ndirs
@
text
@d293 2
a294 5
	int i, c;
	char common[MAXPATHLEN], *cp;
	CVSFILE *cfp;

	return (cfp);
@


1.17
log
@Remove cruft and unbreak compilation
@
text
@d373 1
@


1.16
log
@Allocate a dynamic buffer for sorting.  This way, we don't bork anymore
on directories with huge sets of files, and fix a bug while we're at it.
When sorting failed, the files that had been removed from the list didn't
get pushed back in it.
@
text
@a296 5
	/* first load the common subdirectory */
	cfp = cvs_file_get(common, flags);
	for (i = 0; i < fsn; i++) {
	}

@


1.15
log
@Minor fixes and remove debugging messages
@
text
@d100 1
a100 1
static int        cvs_file_sort    (struct cvs_flist *);
d369 1
d429 1
a429 2
				cfp->cf_parent = cf;
				if (cfp->cf_type == DT_DIR) 
d431 3
a433 1
				else
d436 2
d449 2
a450 2
		cvs_file_sort(&(cdp->cd_files));
		cvs_file_sort(&dirs);
d454 1
d541 4
a544 1
 * Sort a list of cvs file structures according to their filename.
d548 1
a548 1
cvs_file_sort(struct cvs_flist *flp)
d552 7
a558 1
	CVSFILE *cf, *cfvec[256];
d562 1
a562 2
		cfvec[i++] = cf;
		if (i == sizeof(cfvec)/sizeof(CVSFILE *)) {
d564 4
d570 1
d588 1
@


1.14
log
@Lots of cleanup, and add an internal version of cvs_file_get() so we can
link parent directories before the file info is being retrieved.  This
allows us to open most of the CVS administrative files only once
@
text
@d294 1
a294 1
	char common[MAXPATHLEN];
a296 15
	/* first find the common subdir */
	strlcpy(common, fspec[0], sizeof(common));
	for (i = 1; i < fsn; i++) {
		for (c = 0; ; c++) {
			if (common[c] != fspec[i][c]) {
				/* go back to last dir */
				while ((c > 0) && (common[--c] != '/'))
					common[c] = '\0';
				break;
			}
		}
	}
	if (*common == '\0')
		strlcpy(common, ".", sizeof(common));

a388 1
	printf("cvsroot = %s\n", cdp->cd_root->cr_str);
d671 1
a671 1
		ent = cvs_ent_get(CVS_DIR_ENTRIES(parent), path);
a701 2

		cvs_ent_free(ent);
@


1.13
log
@Add cvs_file_find() to find a particular file from its path within a
hierarchy
@
text
@d43 1
a47 2


a50 1

d98 1
a98 1
static int        cvs_file_getdir  (struct cvs_file *, int);
d103 1
d274 1
a274 1
struct cvs_file*
d277 1
a277 81
	int cwd;
	size_t len;
	char buf[32];
	struct stat st;
	struct tm lmtm;
	struct cvs_file *cfp;
	struct cvs_ent *ent;

	if (strcmp(path, ".") == 0)
		cwd = 1;
	else
		cwd = 0;

	if (stat(path, &st) == -1) {
		cvs_log(LP_ERRNO, "failed to stat %s", path);
		return (NULL);
	}

	cfp = cvs_file_alloc(path, IFTODT(st.st_mode));
	if (cfp == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate CVS file data");
		return (NULL);
	}

	ent = cvs_ent_getent(path);
	if (ent == NULL)
		cfp->cf_cvstat = (cwd == 1) ?
		    CVS_FST_UPTODATE : CVS_FST_UNKNOWN;
	else {
		/* always show directories as up-to-date */
		if (ent->ce_type == CVS_ENT_DIR)
			cfp->cf_cvstat = CVS_FST_UPTODATE;
		else if (rcsnum_cmp(ent->ce_rev, cvs_addedrev, 2) == 0)
			cfp->cf_cvstat = CVS_FST_ADDED;
		else {
			/* check last modified time */
			if ((gmtime_r((time_t *)&(st.st_mtime), &lmtm) == NULL) ||
			    (asctime_r(&lmtm, buf) == NULL)) {
				cvs_log(LP_ERR,
				    "failed to generate file timestamp");
				/* fake an up to date file */
				strlcpy(buf, ent->ce_timestamp, sizeof(buf));
			}
			len = strlen(buf);
			if ((len > 0) && (buf[len - 1] == '\n'))
				buf[--len] = '\0';

			if (strcmp(buf, ent->ce_timestamp) == 0)
				cfp->cf_cvstat = CVS_FST_UPTODATE;
			else
				cfp->cf_cvstat = CVS_FST_MODIFIED;
		}

		cvs_ent_free(ent);
	}

	/* convert from stat mode to dirent values */
	cfp->cf_type = IFTODT(st.st_mode);
	if ((cfp->cf_type == DT_DIR) && ((flags & CF_RECURSE) || cwd)) {
		if ((flags & CF_KNOWN) && (cfp->cf_cvstat == CVS_FST_UNKNOWN)) {
			free(cfp->cf_ddat);
			cfp->cf_ddat = NULL;
		}
		else if (cvs_file_getdir(cfp, flags) < 0) {
			cvs_file_free(cfp);
			return (NULL);
		}
	}

	if (flags & CF_STAT) {
		cfp->cf_stat = (struct stat *)malloc(sizeof(struct stat));
		if (cfp->cf_stat == NULL) {
			cvs_log(LP_ERRNO, "failed to allocate stat structure");
			cvs_file_free(cfp);
			return (NULL);
		}

		memcpy(cfp->cf_stat, &st, sizeof(struct stat));
	}

	return (cfp);
d295 1
a295 1
	struct cvs_file *cfp;
d381 1
a381 1
cvs_file_getdir(struct cvs_file *cf, int flags)
d388 1
a388 1
	struct cvs_file *cfp;
d404 1
d410 5
d442 1
a442 1
			cfp = cvs_file_get(pbuf, flags);
d454 6
d481 1
a481 1
cvs_file_free(struct cvs_file *cf)
d505 1
a505 1
	struct cvs_file *fp;
d531 1
a531 1
	struct cvs_file *cfp;
d538 3
d560 1
a560 1
	struct cvs_file *cf, *cfvec[256];
d565 1
a565 1
		if (i == sizeof(cfvec)/sizeof(struct cvs_file *)) {
d593 3
a595 3
	struct cvs_file *cf1, *cf2;
	cf1 = *(struct cvs_file **)f1;
	cf2 = *(struct cvs_file **)f2;
d608 1
a608 1
	cfp = (struct cvs_file *)malloc(sizeof(*cfp));
d648 100
@


1.12
log
@Remove debugging statements
@
text
@d403 53
d464 1
a464 1
	int nf, ret, fd;
d466 1
a466 1
	void *dp, *ep, *tmp;
d581 1
a581 1
				return (-1);
d585 3
a587 1
		return (*exam)(cf, arg);
@


1.11
log
@Loop on the call to getdirentries() until there are no more entries.
Before this, only the first entries of the directory that fit in the
buffer were loaded
@
text
@a382 1
				printf("backtracking!\n");
a389 1
	printf("common part = `%s'\n", common);
@


1.10
log
@* move to tail queues for file list management
* when generating the list of files for a directory, put all the
  subdirectories at the end, sorted
@
text
@d90 4
d416 1
a416 1
	char fbuf[1024], pbuf[MAXPATHLEN];
a444 7
	ret = getdirentries(fd, fbuf, sizeof(fbuf), &base);
	if (ret == -1) {
		cvs_log(LP_ERRNO, "failed to get directory entries");
		(void)close(fd);
		cvs_file_freedir(cdp);
		return (-1);
	}
d446 8
a453 13
	dp = fbuf;
	ep = fbuf + (size_t)ret;
	while (dp < ep) {
		ent = (struct dirent *)dp;
		dp += ent->d_reclen;

		if ((flags & CF_IGNORE) && cvs_file_chkign(ent->d_name))
			continue;

		snprintf(pbuf, sizeof(pbuf), "%s/%s", cf->cf_path, ent->d_name);
		cfp = cvs_file_get(pbuf, flags);
		if (cfp != NULL) {
			cfp->cf_parent = cf;
d455 20
a474 5
			if (cfp->cf_type == DT_DIR) 
				TAILQ_INSERT_HEAD(&dirs, cfp, cf_list);
			else
				TAILQ_INSERT_HEAD(&(cdp->cd_files), cfp,
				    cf_list);
d476 1
a476 1
	}
@


1.9
log
@* when comparing timestamps, use the last modification time instead
  of the last access time.  No wonder all the files appeared as
  modified
* always show directories as up to date
* skeleton for cvs_file_getspec()
@
text
@d124 1
a124 1
	for (i = 0; i < sizeof(cvs_ign_std)/sizeof(char *); i++)
d416 1
d418 1
d462 6
a467 1
			LIST_INSERT_HEAD(&(cdp->cd_files), cfp, cf_list);
d471 1
a471 1
	if (flags & CF_SORT)
d473 4
a493 3
	struct cvs_file *cfp;
	struct cvs_dir *cd;

d520 1
a520 1
		LIST_FOREACH(fp, &(cf->cf_ddat->cd_files), cf_list) {
d547 3
a549 3
	while (!LIST_EMPTY(&(cd->cd_files))) {
		cfp = LIST_FIRST(&(cd->cd_files));
		LIST_REMOVE(cfp, cf_list);
d569 1
a569 1
	LIST_FOREACH(cf, flp, cf_list) {
d579 1
a579 1
		LIST_REMOVE(cf, cf_list);
d583 1
a583 1
	LIST_INIT(flp);
d590 1
a590 1
		LIST_INSERT_HEAD(flp, cfvec[i], cf_list);
d649 1
a649 1
		LIST_INIT(&(ddat->cd_files));
@


1.8
log
@the `.#*' pattern actually still matches, include it in standard
ignore patterns
@
text
@d275 1
a275 1
	size_t dlen;
d303 4
a306 1
		if (rcsnum_cmp(ent->ce_rev, cvs_addedrev, 2) == 0)
d310 1
a310 1
			if ((gmtime_r((time_t *)&(st.st_atime), &lmtm) == NULL) ||
d317 4
d352 42
@


1.7
log
@Fix directory loading with the new file structure allocation code
@
text
@d77 1
a84 1
	".#*",
@


1.6
log
@* create cvs_file_alloc() to keep one copy of the file allocation code
  and reuse it
* add cvs_file_create() to explicitly create a file or directory
* add cvs_mkadmin() to fill the administrative files for a CVS directory
@
text
@d368 2
@


1.5
log
@* when loading a file, cvs_file_get() can now tell whether the file
  is up-to-date or modified
* add cvs_file_examine() to run a command on a file and its subfiles
@
text
@d96 5
a100 4
static struct cvs_dir*  cvs_file_getdir  (struct cvs_file *, int);
static void             cvs_file_freedir (struct cvs_dir *);
static int              cvs_file_sort    (struct cvs_flist *);
static int              cvs_file_cmp     (const void *, const void *);
d218 1
a218 1
 * cvs_file_getv()
d220 1
a220 6
 * Get a vector of all the files found in the directory <dir> and not
 * matching any of the ignore patterns.  The number of files found is
 * returned in <nfiles>.
 * Returns a pointer to a dynamically-allocated string vector on success,
 * or NULL on failure.  The returned vector should be freed with
 * cvs_freeargv().
d223 2
a224 2
char**
cvs_file_getv(const char *dir, int *nfiles, int recurse)
d226 2
a227 5
	int nf, ret, fd;
	long base;
	void *dp, *ep, *tmp;
	char fbuf[1024], **fvec;
	struct dirent *ent;
d229 4
a232 2
	*nfiles = 0;
	fvec = NULL;
d234 5
a238 4
	fd = open(dir, O_RDONLY);
	if (fd == -1) {
		cvs_log(LP_ERRNO, "failed to open `%s'", dir);
		return (NULL);
d240 4
a243 21
	ret = getdirentries(fd, fbuf, sizeof(fbuf), &base);
	if (ret == -1) {
		cvs_log(LP_ERRNO, "failed to get directory entries");
		(void)close(fd);
		return (NULL);
	}

	dp = fbuf;
	ep = fbuf + (size_t)ret;
	while (dp < ep) {
		ent = (struct dirent *)dp;
		dp += ent->d_reclen;

		if (cvs_file_chkign(ent->d_name))
			continue;

		tmp = realloc(fvec, (*nfiles + 1) * sizeof(char *));
		if (tmp == NULL) {
			cvs_log(LP_ERRNO, "failed to reallocate file vector");
			(void)close(fd);
			free(fvec);
d246 1
a246 3
		fvec[++(*nfiles)] = strdup(ent->d_name);

		*nfiles++;
d249 1
a249 3
	(void)close(fd);

	return (fvec);
a281 2
	printf("cvs_file_get(%s)\n", path);

d292 1
a292 1
	cfp = (struct cvs_file *)malloc(sizeof(*cfp));
a296 1
	memset(cfp, 0, sizeof(*cfp));
a322 13
	cfp->cf_path = strdup(path);
	if (cfp->cf_path == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate file path");
		free(cfp);
		return (NULL);
	}

	cfp->cf_name = strrchr(cfp->cf_path, '/');
	if (cfp->cf_name == NULL)
		cfp->cf_name = cfp->cf_path;
	else
		cfp->cf_name++;

d326 2
a327 1
		if ((flags & CF_KNOWN) && (cfp->cf_cvstat == CVS_FST_UNKNOWN))
d329 4
a332 6
		else {
			cfp->cf_ddat = cvs_file_getdir(cfp, flags);
			if (cfp->cf_ddat == NULL) {
				cvs_file_free(cfp);
				return (NULL);
			}
d357 1
a357 1
static struct cvs_dir*
a367 8
	cdp = (struct cvs_dir *)malloc(sizeof(*cdp));
	if (cdp == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate dir");
		return (NULL);
	}
	memset(cdp, 0, sizeof(*cdp));
	LIST_INIT(&(cdp->cd_files));

d372 1
a372 1
			return (NULL);
d379 1
a379 1
		return (NULL);
d386 1
a386 1
		return (NULL);
d393 1
a393 1
		return (NULL);
d417 1
d419 1
a419 1
	return (cdp);
d544 50
@


1.4
log
@* cleanup the file API with regards to flag handling and
  general structure
* implement cvs_ent_close() correctly, fix some memory leaks, and add
  cvs_ent_getent() to get a single entry easily
@
text
@d192 1
a192 1
 * cvs_file_isignored()
d199 1
a199 1
cvs_file_isignored(const char *file)
d257 1
a257 1
		if (cvs_file_isignored(ent->d_name))
d301 1
d303 1
d333 14
a346 2
		else
			cfp->cf_cvstat = CVS_FST_UPTODATE;
d452 1
a452 1
		if ((flags & CF_IGNORE) && cvs_file_isignored(ent->d_name))
d491 27
@


1.3
log
@Revamp the file interface to make life easier
@
text
@d90 3
d119 3
d283 9
d299 1
d303 1
d307 5
d313 1
a313 1
		cvs_log(LP_ERRNO, "failed to stat file");
d324 13
d339 1
d352 9
a360 5
	if (cfp->cf_type == DT_DIR) {
		cfp->cf_ddat = cvs_file_getdir(cfp, flags);
		if (cfp->cf_ddat == NULL) {
			cvs_file_free(cfp);
			return (NULL);
d404 6
a409 9
	if (cvs_readrepo(cf->cf_path, pbuf, sizeof(pbuf)) < 0) {
		free(cdp);
		return (NULL);
	}

	cdp->cd_repo = strdup(pbuf);
	if (cdp->cd_repo == NULL) {
		free(cdp);
		return (NULL);
d443 4
a446 2

		LIST_INSERT_HEAD(&(cdp->cd_files), cfp, cf_list);
a518 1
		printf("adding `%s'\n", cf->cf_path);
a534 3
	printf("Before: \n");
	for (i = 0; i < (int)nb; i++)
		printf("[%d] = `%s'\n", i, cfvec[i]->cf_name);
a535 3
	printf("===================================\nAfter: \n");
	for (i = 0; i < (int)nb; i++)
		printf("[%d] = `%s'\n", i, cfvec[i]->cf_name);
@


1.2
log
@* add prototypes for cvs_getargv() and cvs_freeargv()
* remove cvs_file_free(), cvs_freeargv() does exactly the same
@
text
@d93 7
d222 1
a222 1
cvs_file_getv(const char *dir, int *nfiles)
d269 251
@


1.1
log
@cvsignore support and simpler API for file access
@
text
@d210 2
a211 1
 * or NULL on failure.
a261 17
}


/*
 * cvs_file_freev()
 *
 * Free a file vector obtained with cvs_file_getv().
 */

void
cvs_file_freev(char **fvec, int nfiles)
{
	int i;

	for (i = 0; i < nfiles; i++)
		free(fvec[i]);
	free(fvec);
@

