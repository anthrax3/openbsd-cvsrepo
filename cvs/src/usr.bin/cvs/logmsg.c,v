head	1.59;
access;
symbols
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.56.0.6
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.54.0.20
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.54.0.18
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.54.0.14
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.12
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.10
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.8
	OPENBSD_5_0:1.54.0.6
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.54.0.4
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.54.0.2
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.52.0.4
	OPENBSD_4_6_BASE:1.52
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12;
locks; strict;
comment	@ * @;


1.59
date	2016.10.15.22.20.17;	author millert;	state Exp;
branches;
next	1.58;
commitid	bZGHsljlW6kmRYub;

1.58
date	2016.08.16.19.00.59;	author tb;	state Exp;
branches;
next	1.57;
commitid	SaLKmpKJjpUL6VX8;

1.57
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.56;
commitid	O6jeJ0TRmiewrqMI;

1.56
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.55;
commitid	DTQbfd4poqBW8iSJ;

1.55
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	Uu5nFG3wCl0LACBb;

1.54
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.25.21.50.33;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.26.00.09.02;	author ray;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.10.01.00.34;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.08.20.08.43;	author tobias;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.22.15.46.30;	author tobias;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.09.01.02.38;	author tobias;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.25.10.04.47;	author chl;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.04.17.57.41;	author tobias;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.04.11.47.14;	author tobias;	state Exp;
branches;
next	1.42;

1.42
date	2007.08.30.11.07.18;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.11.02.43.24;	author ray;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.11.02.37.31;	author ray;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.20.08.36.00;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2007.01.25.22.49.39;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.25.08.21.08;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.11.08.48.59;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.11.08.33.53;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.07.18.40.55;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.07.13.33.04;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.07.02.47.57;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.07.02.39.24;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.27.03.30.31;	author joris;	state dead;
branches;
next	1.28;

1.28
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.22.13.19.12;	author moritz;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.21.20.04.36;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.20.18.17.01;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.14.19.49.18;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.10.14.49.20;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.08.14.28.59;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.23.00.03.00;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.02.16.05.38;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.26.21.51.33;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.03.21.08.12;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.08.21.49.02;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.08.18.54.23;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.08.17.22.48;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.03.19.01.02;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.02.19.23.44;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.02.17.45.44;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.12.17.49.11;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Quiet compiler warnings.  OK tomc@@ tb@@
@
text
@/*	$OpenBSD: logmsg.c,v 1.58 2016/08/16 19:00:59 tb Exp $	*/
/*
 * Copyright (c) 2007 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <paths.h>
#include <signal.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"

#define CVS_LOGMSG_PREFIX		"CVS:"
#define CVS_LOGMSG_LINE		\
"----------------------------------------------------------------------"

int	cvs_logmsg_edit(const char *);

char *
cvs_logmsg_read(const char *path)
{
	int fd;
	BUF *bp;
	FILE *fp;
	size_t len;
	struct stat st;
	char *buf, *lbuf;

	if ((fd = open(path, O_RDONLY)) == -1)
		fatal("cvs_logmsg_read: open %s", strerror(errno));

	if (fstat(fd, &st) == -1)
		fatal("cvs_logmsg_read: fstat %s", strerror(errno));

	if (!S_ISREG(st.st_mode))
		fatal("cvs_logmsg_read: file is not a regular file");

	if ((fp = fdopen(fd, "r")) == NULL)
		fatal("cvs_logmsg_read: fdopen %s", strerror(errno));

	if ((uintmax_t)st.st_size > SIZE_MAX)
		fatal("cvs_logmsg_read: %s: file size too big", path);

	lbuf = NULL;
	bp = buf_alloc(st.st_size);
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n') {
			buf[len - 1] = '\0';
			--len;
		} else {
			lbuf = xmalloc(len + 1);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		if (!strncmp(buf, CVS_LOGMSG_PREFIX,
		    sizeof(CVS_LOGMSG_PREFIX) - 1))
			continue;

		buf_append(bp, buf, len);
		buf_putc(bp, '\n');
	}

	free(lbuf);

	(void)fclose(fp);

	buf_putc(bp, '\0');
	return (buf_release(bp));
}

char *
cvs_logmsg_create(char *dir, struct cvs_flisthead *added,
    struct cvs_flisthead *removed, struct cvs_flisthead *modified)
{
	FILE *fp, *rp;
	int c, fd, rd, saved_errno;
	struct cvs_filelist *cf;
	struct stat st1, st2;
	char *fpath, *logmsg, repo[PATH_MAX];
	struct stat st;
	struct trigger_list *line_list;
	struct trigger_line *line;
	static int reuse = 0;
	static char *prevmsg = NULL;

	if (reuse)
		return xstrdup(prevmsg);

	(void)xasprintf(&fpath, "%s/cvsXXXXXXXXXX", cvs_tmpdir);

	if ((fd = mkstemp(fpath)) == -1)
		fatal("cvs_logmsg_create: mkstemp %s", strerror(errno));

	worklist_add(fpath, &temp_files);

	if ((fp = fdopen(fd, "w")) == NULL) {
		saved_errno = errno;
		(void)unlink(fpath);
		fatal("cvs_logmsg_create: fdopen %s", strerror(saved_errno));
	}

	if (prevmsg != NULL && prevmsg[0] != '\0')
		fprintf(fp, "%s", prevmsg);
	else
		fputc('\n', fp);

	line_list = cvs_trigger_getlines(CVS_PATH_RCSINFO, repo);
	if (line_list != NULL) {
		TAILQ_FOREACH(line, line_list, flist) {
			if ((rd = open(line->line, O_RDONLY)) == -1)
				fatal("cvs_logmsg_create: open %s",
				    strerror(errno));
			if (fstat(rd, &st) == -1)
				fatal("cvs_logmsg_create: fstat %s",
				    strerror(errno));
			if (!S_ISREG(st.st_mode))
				fatal("cvs_logmsg_create: file is not a "
				    "regular file");
			if ((rp = fdopen(rd, "r")) == NULL)
				fatal("cvs_logmsg_create: fdopen %s",
				    strerror(errno));
			if ((uintmax_t)st.st_size > SIZE_MAX)
				fatal("cvs_logmsg_create: %s: file size "
				    "too big", line->line);
			logmsg = xmalloc(st.st_size);
			fread(logmsg, st.st_size, 1, rp);
			fwrite(logmsg, st.st_size, 1, fp);
			free(logmsg);
			(void)fclose(rp);
		}
		cvs_trigger_freelist(line_list);
	}

	fprintf(fp, "%s %s\n%s Enter Log.  Lines beginning with `%s' are "
	    "removed automatically\n%s\n", CVS_LOGMSG_PREFIX, CVS_LOGMSG_LINE,
	    CVS_LOGMSG_PREFIX, CVS_LOGMSG_PREFIX, CVS_LOGMSG_PREFIX);

	if (cvs_cmdop == CVS_OP_COMMIT) {
		fprintf(fp, "%s Committing in %s\n%s\n", CVS_LOGMSG_PREFIX,
		    dir != NULL ? dir : ".", CVS_LOGMSG_PREFIX);
	}

	if (added != NULL && !RB_EMPTY(added)) {
		fprintf(fp, "%s Added Files:", CVS_LOGMSG_PREFIX);
		RB_FOREACH(cf, cvs_flisthead, added)
			fprintf(fp, "\n%s\t%s", CVS_LOGMSG_PREFIX,
			    dir != NULL ? basename(cf->file_path) :
			    cf->file_path);
		fputs("\n", fp);
	}

	if (removed != NULL && !RB_EMPTY(removed)) {
		fprintf(fp, "%s Removed Files:", CVS_LOGMSG_PREFIX);
		RB_FOREACH(cf, cvs_flisthead, removed)
			fprintf(fp, "\n%s\t%s", CVS_LOGMSG_PREFIX,
			    dir != NULL ? basename(cf->file_path) :
			    cf->file_path);
		fputs("\n", fp);
	}

	if (modified != NULL && !RB_EMPTY(modified)) {
		fprintf(fp, "%s Modified Files:", CVS_LOGMSG_PREFIX);
		RB_FOREACH(cf, cvs_flisthead, modified)
			fprintf(fp, "\n%s\t%s", CVS_LOGMSG_PREFIX,
			    dir != NULL ? basename(cf->file_path) :
			    cf->file_path);
		fputs("\n", fp);
	}

	fprintf(fp, "%s %s\n", CVS_LOGMSG_PREFIX, CVS_LOGMSG_LINE);
	(void)fflush(fp);

	if (fstat(fd, &st1) == -1) {
		saved_errno = errno;
		(void)unlink(fpath);
		fatal("cvs_logmsg_create: fstat %s", strerror(saved_errno));
	}

	logmsg = NULL;

	for (;;) {
		if (cvs_logmsg_edit(fpath) == -1)
			break;

		if (fstat(fd, &st2) == -1) {
			saved_errno = errno;
			(void)unlink(fpath);
			fatal("cvs_logmsg_create: fstat %s",
			    strerror(saved_errno));
		}

		if (st1.st_mtime != st2.st_mtime) {
			logmsg = cvs_logmsg_read(fpath);
			free(prevmsg);
			prevmsg = xstrdup(logmsg);
			break;
		}

		printf("\nLog message unchanged or not specified\n"
		    "a)bort, c)ontinue, e)dit, !)reuse this message "
		    "unchanged for remaining dirs\nAction: (abort) ");
		(void)fflush(stdout);

		c = getc(stdin);
		if (c == EOF || c == '\n' || c == 'a' || c == 'A') {
			fatal("Aborted by user");
		} else if (c == 'c' || c == 'C') {
			if (prevmsg == NULL)
				prevmsg = xstrdup("");
			logmsg = xstrdup(prevmsg);
			break;
		} else if (c == 'e' || c == 'E') {
			continue;
		} else if (c == '!') {
			reuse = 1;
			if (prevmsg == NULL)
				prevmsg = xstrdup("");
			logmsg = xstrdup(prevmsg);
			break;
		} else {
			cvs_log(LP_ERR, "invalid input");
			continue;
		}
	}

	(void)fclose(fp);
	(void)unlink(fpath);
	free(fpath);

	return (logmsg);
}

/*
 * Execute an editor on the specified pathname, which is interpreted
 * from the shell.  This means flags may be included.
 *
 * Returns -1 on error, or the exit value on success.
 */
int
cvs_logmsg_edit(const char *pathname)
{
	char *argp[] = {"sh", "-c", NULL, NULL}, *p;
	sig_t sighup, sigint, sigquit;
	pid_t pid;
	int saved_errno, st;

	(void)xasprintf(&p, "%s %s", cvs_editor, pathname);
	argp[2] = p;

	sighup = signal(SIGHUP, SIG_IGN);
	sigint = signal(SIGINT, SIG_IGN);
	sigquit = signal(SIGQUIT, SIG_IGN);
	if ((pid = fork()) == -1)
		goto fail;
	if (pid == 0) {
		execv(_PATH_BSHELL, argp);
		_exit(127);
	}
	while (waitpid(pid, &st, 0) == -1)
		if (errno != EINTR)
			goto fail;
	free(p);
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	if (!WIFEXITED(st)) {
		errno = EINTR;
		return (-1);
	}
	return (WEXITSTATUS(st));

 fail:
	saved_errno = errno;
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	free(p);
	errno = saved_errno;
	return (-1);
}

int
cvs_logmsg_verify(char *logmsg)
{
	int fd, ret = 0;
	char *fpath;
	struct trigger_list *line_list;
	struct file_info_list files_info;
	struct file_info *fi;

	line_list = cvs_trigger_getlines(CVS_PATH_VERIFYMSG, "DEFAULT");
	if (line_list != NULL) {
		TAILQ_INIT(&files_info);

		(void)xasprintf(&fpath, "%s/cvsXXXXXXXXXX", cvs_tmpdir);
		if ((fd = mkstemp(fpath)) == -1)
			fatal("cvs_logmsg_verify: mkstemp %s", strerror(errno));

		fi = xcalloc(1, sizeof(*fi));
		fi->file_path = xstrdup(fpath);
		TAILQ_INSERT_TAIL(&files_info, fi, flist);

		if (cvs_trigger_handle(CVS_TRIGGER_VERIFYMSG, NULL, NULL,
		    line_list, &files_info)) {
			cvs_log(LP_ERR, "Log message check failed");
			ret = 1;
		}

		cvs_trigger_freeinfo(&files_info);
		(void)close(fd);
		(void)unlink(fpath);
		free(fpath);
		cvs_trigger_freelist(line_list);
	}

	return ret;
}

@


1.58
log
@When the commit message is empty, don't default to c)ontinue
(committing without log message) but a)bort.  Also, accept
the uppercase versions of the choices.

Matches the corresponding change of behavior of GNU cvs.

suggested by & ok jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.57 2015/11/05 09:48:21 nicm Exp $	*/
d62 1
a62 1
	if (st.st_size > SIZE_MAX)
d145 1
a145 1
			if (st.st_size > SIZE_MAX)
@


1.57
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.56 2015/02/05 12:59:57 millert Exp $	*/
d224 1
a224 1
		    "unchanged for remaining dirs\nAction: (continue) ");
d228 1
a228 1
		if (c == EOF || c == 'a') {
d230 1
a230 1
		} else if (c == '\n' || c == 'c') {
d235 1
a235 1
		} else if (c == 'e') {
@


1.56
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.55 2015/01/16 06:40:07 deraadt Exp $	*/
d86 1
a86 2
	if (lbuf != NULL)
		xfree(lbuf);
d151 1
a151 1
			xfree(logmsg);
d217 1
a217 2
			if (prevmsg != NULL)
				xfree(prevmsg);
d251 1
a251 1
	xfree(fpath);
d285 1
a285 1
	xfree(p);
d300 1
a300 1
	xfree(p);
d335 1
a335 1
		xfree(fpath);
@


1.55
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.54 2010/07/23 21:46:05 ray Exp $	*/
d27 1
@


1.54
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.53 2010/07/23 08:31:19 ray Exp $	*/
d102 1
a102 1
	char *fpath, *logmsg, repo[MAXPATHLEN];
@


1.53
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.52 2009/03/25 21:50:33 joris Exp $	*/
d65 1
a65 1
	bp = cvs_buf_alloc(st.st_size);
d81 2
a82 2
		cvs_buf_append(bp, buf, len);
		cvs_buf_putc(bp, '\n');
d90 2
a91 2
	cvs_buf_putc(bp, '\0');
	return (cvs_buf_release(bp));
@


1.52
log
@switch our file and directory lists to RB trees (see tree(3)),
so we can benefit from faster lookup times while recursing.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.51 2008/11/26 00:09:02 ray Exp $	*/
d117 1
a117 1
	cvs_worklist_add(fpath, &temp_files);
@


1.51
log
@Small optimization.

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.50 2008/06/10 01:00:34 joris Exp $	*/
d166 1
a166 1
	if (added != NULL && !TAILQ_EMPTY(added)) {
d168 1
a168 1
		TAILQ_FOREACH(cf, added, flist)
d175 1
a175 1
	if (removed != NULL && !TAILQ_EMPTY(removed)) {
d177 1
a177 1
		TAILQ_FOREACH(cf, removed, flist)
d184 1
a184 1
	if (modified != NULL && !TAILQ_EMPTY(modified)) {
d186 1
a186 1
		TAILQ_FOREACH(cf, modified, flist)
@


1.50
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.49 2008/06/08 20:08:43 tobias Exp $	*/
d69 1
a75 2

		len = strlen(buf);
@


1.49
log
@Handle commits on a per-directory basis instead handling all of them at
once in local setup.  Also added '!' to reuse typed log message for all
following directories.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.48 2008/05/22 15:46:30 tobias Exp $	*/
d99 2
a100 2
	FILE *fp;
	int c, fd, saved_errno;
d103 4
a106 1
	char *fpath, *logmsg;
d131 27
d306 38
@


1.48
log
@Wrong function names in fatal messages fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.47 2008/03/09 01:02:38 tobias Exp $	*/
d24 1
d96 2
a97 2
cvs_logmsg_create(struct cvs_flisthead *added, struct cvs_flisthead *removed,
	struct cvs_flisthead *modified)
d104 2
d107 3
d123 6
a128 1
	fprintf(fp, "\n%s %s\n%s Enter Log.  Lines beginning with `%s' are "
d132 5
d140 3
a142 2
			fprintf(fp, "\n%s\t%s",
			    CVS_LOGMSG_PREFIX, cf->file_path);
d149 3
a151 2
			fprintf(fp, "\n%s\t%s",
			    CVS_LOGMSG_PREFIX, cf->file_path);
d158 3
a160 2
			fprintf(fp, "\n%s\t%s",
			    CVS_LOGMSG_PREFIX, cf->file_path);
d188 3
d195 2
a196 1
		    "a)bort, c)ontinue, e)dit\nAction: (continue) ");
d203 3
a205 1
			logmsg = xstrdup("");
d209 6
@


1.47
log
@While allocation memory, make sure that file sizes are smaller than SIZE_MAX.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.46 2008/02/11 20:33:11 tobias Exp $	*/
d61 1
a61 1
		fatal("cvs_buf_load_fd: %s: file size too big", path);
@


1.46
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.45 2007/09/25 10:04:47 chl Exp $	*/
d59 3
@


1.45
log
@missing header for mkstemp
check mkstemp return value against -1 instead of NULL

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.44 2007/09/04 17:57:41 tobias Exp $	*/
d61 1
a61 1
	bp = cvs_buf_alloc(st.st_size, BUF_AUTOEXT);
@


1.44
log
@Replaced strlen() with sizeof() - 1 when #define'd strings are used.

OK ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.43 2007/09/04 11:47:14 tobias Exp $	*/
d26 1
d103 1
a103 1
	if ((fd = mkstemp(fpath)) == NULL)
@


1.43
log
@Handle ^D as a)bort in log message question.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.42 2007/08/30 11:07:18 joris Exp $	*/
d74 1
a74 1
		    strlen(CVS_LOGMSG_PREFIX)))
@


1.42
log
@properly send our log message to the server using Argumentx, so we
no longer break when the log message has multiple lines.

from Tobias Stoeckmann, thanks for doing my work!
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.41 2007/05/11 02:43:24 ray Exp $	*/
d173 1
a173 1
		if (c == 'a') {
@


1.41
log
@cvs_logmsg_edit no longer fails with ECHILD.
Add comment describing cvs_logmsg_edit usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.40 2007/05/11 02:37:31 ray Exp $	*/
a71 2
		if (len == 0)
			continue;
@


1.40
log
@Sync with editit from sendbug.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.39 2007/04/20 08:36:00 xsa Exp $	*/
d155 1
a155 1
		if (cvs_logmsg_edit(fpath) == -1 && errno != ECHILD)
d195 6
@


1.39
log
@- correct signal handling and process waiting for the EDITOR support code
(From ray's code in sendbug(1))
- nuke cvs_exec() as it is not used anymore

Prompted by deraadt@@ a few weeks ago.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.38 2007/02/22 06:42:09 otto Exp $	*/
d201 1
a201 1
	int st;
a205 1
top:
d209 2
a210 14
	if ((pid = fork()) == -1) {
		int saved_errno = errno;

		(void)signal(SIGHUP, sighup);
		(void)signal(SIGINT, sigint);
		(void)signal(SIGQUIT, sigquit);
		if (saved_errno == EAGAIN) {
			sleep(1);
			goto top;
		}
		xfree(p);
		errno = saved_errno;
		return (-1);
	}
d215 3
a218 9
	for (;;) {
		if (waitpid(pid, &st, WUNTRACED) == -1) {
			if (errno != EINTR)
				return (-1);
		} else if (WIFSTOPPED(st))
			raise(WSTOPSIG(st));
		else
			break;
	}
d222 2
a223 2
	if (!WIFEXITED(st) || WEXITSTATUS(st) != 0) {
		errno = ECHILD;
d226 10
a235 1
	return (0);
@


1.38
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.37 2007/01/25 22:49:39 xsa Exp $	*/
d19 2
d24 2
d35 2
d97 1
a97 1
	int c, fd, argc, saved_errno;
d100 1
a100 1
	char *fpath, *logmsg, *argv[4];
a151 5
	argc = 0;
	argv[argc++] = cvs_editor;
	argv[argc++] = fpath;
	argv[argc] = NULL;

d155 1
a155 1
		if (cvs_exec(argc, argv) < 0)
d193 53
@


1.37
log
@zap uneeded close() calls after fclose(); pointed out by and OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.36 2007/01/25 08:21:08 otto Exp $	*/
d18 6
a23 1
#include "includes.h"
a25 3
#include "file.h"
#include "log.h"
#include "worklist.h"
@


1.36
log
@do not use strlcpuy on a buffer filled by fgetln, since fgetln does
not NUL-terminate. ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.35 2007/01/11 08:48:59 xsa Exp $	*/
a78 1
	(void)close(fd);
a185 1
	(void)close(fd);
@


1.35
log
@strl* overload, use xasprintf().
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.34 2007/01/11 08:33:53 xsa Exp $	*/
d58 2
a59 1
			strlcpy(lbuf, buf, len);
@


1.34
log
@save errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.33 2007/01/07 18:40:55 joris Exp $	*/
a88 1
	size_t len;
d94 1
a94 8
	fpath = xmalloc(MAXPATHLEN);
	len = strlcpy(fpath, cvs_tmpdir, MAXPATHLEN);
	if (len >= MAXPATHLEN)
		fatal("cvs_logmsg_create: truncation");

	len = strlcat(fpath, "/cvsXXXXXXXXXX", MAXPATHLEN);
	if (len >= MAXPATHLEN)
		fatal("cvs_logmsg_create: truncation");
@


1.33
log
@add the temporary file we create to the temp_files worklist
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.32 2007/01/07 13:33:04 jasper Exp $	*/
d90 1
a90 1
	int c, fd, argc;
d110 1
d112 1
a112 1
		fatal("cvs_logmsg_create: fdopen %s", strerror(errno));
d147 1
d149 1
a149 1
		fatal("cvs_logmsg_create: fstat %s", strerror(errno));
d164 1
d166 2
a167 1
			fatal("cvs_logmsg_create: fstat %s", strerror(errno));
@


1.32
log
@make the output when interrupting writing the log message consistent.

ok joris@@

commiting with opencvs now btw :)
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.31 2007/01/07 02:47:57 joris Exp $	*/
d106 2
@


1.31
log
@and lets make import work with the new logmsg code too!
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.30 2007/01/07 02:39:24 joris Exp $	*/
d170 1
a170 1
		    "a)bort, c)ontinue, e(dit)\nAction: (continue) ");
@


1.30
log
@rewrite of the logmessage code, which allows you to
enter a logmessage into your favorite editor when commiting.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d116 1
a116 1
	if (!TAILQ_EMPTY(added)) {
d124 1
a124 1
	if (!TAILQ_EMPTY(removed)) {
d132 1
a132 1
	if (!TAILQ_EMPTY(modified)) {
@


1.29
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.28 2006/04/14 02:45:35 deraadt Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 11
a15 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a19 1
#include "buf.h"
d21 1
d23 1
a23 2
#include "proto.h"

d25 2
a26 3
#define CVS_LOGMSG_BIGMSG	32000
#define CVS_LOGMSG_PREFIX	"CVS:"
#define CVS_LOGMSG_LINE \
a28 15

static const char *cvs_logmsg_ops[3] = {
	"Added", "Modified", "Removed",
};


/*
 * cvs_logmsg_open()
 *
 * Open the file specified by <path> and allocate a buffer large enough to
 * hold all of the file's contents.  Lines starting with the log prefix
 * are not included in the result.
 * The returned value must later be free()d.
 * Returns a pointer to the allocated buffer on success, or NULL on failure.
 */
d30 1
a30 1
cvs_logmsg_open(const char *path)
d32 3
a34 1
	int lcont;
a35 1
	char lbuf[256], *msg;
d37 4
a40 2
	FILE *fp;
	BUF *bp;
d42 2
a43 2
	if (stat(path, &st) == -1)
		fatal("cvs_logmsg_open: stat: `%s': %s", path, strerror(errno));
d46 1
a46 1
		fatal("cvs_logmsg_open: message file must be a regular file");
d48 2
a49 17
	if (st.st_size > CVS_LOGMSG_BIGMSG) {
		do {
			fprintf(stderr,
			    "The specified message file seems big.  "
			    "Proceed anyways? (y/n) ");
			if (fgets(lbuf, (int)sizeof(lbuf), stdin) == NULL)
				fatal("cvs_logmsg_open: fgets failed");

			len = strlen(lbuf);
			if (len == 0 || len > 2 ||
			    (lbuf[0] != 'y' && lbuf[0] != 'n')) {
				fprintf(stderr, "invalid input\n");
				continue;
			} else if (lbuf[0] == 'y')
				break;
			else if (lbuf[0] == 'n')
				fatal("aborted by user");
d51 10
a60 2
		} while (1);
	}
d62 1
a62 14
	if ((fp = fopen(path, "r")) == NULL)
		fatal("cvs_logmsg_open: fopen: `%s': %s",
		    path, strerror(errno));

	bp = cvs_buf_alloc((size_t)128, BUF_AUTOEXT);

	/* lcont is used to tell if a buffer returned by fgets is a start
	 * of line or just line continuation because the buffer isn't
	 * large enough to hold the entire line.
	 */
	lcont = 0;

	while (fgets(lbuf, (int)sizeof(lbuf), fp) != NULL) {
		len = strlen(lbuf);
d65 3
a67 3
		else if (lcont == 0 &&
		    strncmp(lbuf, CVS_LOGMSG_PREFIX, strlen(CVS_LOGMSG_PREFIX)) == 0)
			/* skip lines starting with the prefix */
d70 6
a75 1
		cvs_buf_append(bp, lbuf, strlen(lbuf));
a76 2
		lcont = (lbuf[len - 1] == '\n') ? 0 : 1;
	}
d78 1
d81 1
a81 4

	msg = (char *)cvs_buf_release(bp);

	return (msg);
a83 12

/*
 * cvs_logmsg_get()
 *
 * Get a log message by forking and executing the user's editor.  The <dir>
 * argument is a relative path to the directory for which the log message
 * applies, and the 3 tail queue arguments contains all the files for which the
 * log message will apply.  Any of these arguments can be set to NULL in the
 * case where there is no information to display.
 * Returns the message in a dynamically allocated string on success, NULL on
 * failure.
 */
d85 2
a86 2
cvs_logmsg_get(const char *dir, struct cvs_flist *added,
    struct cvs_flist *modified, struct cvs_flist *removed)
a87 3
	int i, fd, argc, fds[3], nl;
	size_t len, tlen;
	char *argv[4], buf[16], path[MAXPATHLEN], fpath[MAXPATHLEN], *msg;
d89 3
a91 1
	CVSFILE *cvsfp;
d93 1
a93 1
	struct cvs_flist *files[3];
d95 8
a102 15
	files[0] = added;
	files[1] = modified;
	files[2] = removed;

	msg = NULL;
	fds[0] = -1;
	fds[1] = -1;
	fds[2] = -1;
	strlcpy(path, cvs_tmpdir, sizeof(path));
	strlcat(path, "/cvsXXXXXXXXXX", sizeof(path));
	argc = 0;
	argv[argc++] = cvs_editor;
	argv[argc++] = path;
	argv[argc] = NULL;
	tlen = 0;
d104 2
a105 3
	if ((fd = mkstemp(path)) == -1)
		fatal("cvs_logmsg_get: mkstemp: `%s': %s",
		    path, strerror(errno));
d108 2
a109 3
		if (unlink(path) == -1)
			cvs_log(LP_ERRNO, "failed to unlink temporary file");
		fatal("cvs_logmsg_get: fdopen failed");
d116 23
a138 31
	if (dir != NULL)
		fprintf(fp, "%s Commiting in %s\n%s\n", CVS_LOGMSG_PREFIX, dir,
		    CVS_LOGMSG_PREFIX);

	for (i = 0; i < 3; i++) {
		if (files[i] == NULL)
			continue;

		if (SIMPLEQ_EMPTY(files[i]))
			continue;

		fprintf(fp, "%s %s Files:", CVS_LOGMSG_PREFIX,
		    cvs_logmsg_ops[i]);
		nl = 1;
		SIMPLEQ_FOREACH(cvsfp, files[i], cf_list) {
			/* take the space into account */
			cvs_file_getpath(cvsfp, fpath, sizeof(fpath));
			len = strlen(fpath) + 1;
			if (tlen + len >= 72)
				nl = 1;

			if (nl) {
				fprintf(fp, "\n%s\t", CVS_LOGMSG_PREFIX);
				tlen = 8;
				nl = 0;
			}

			fprintf(fp, " %s", fpath);
			tlen += len;
		}
		fputc('\n', fp);
a139 1
	}
d144 2
a145 3
		if (unlink(path) == -1)
			cvs_log(LP_ERRNO, "failed to unlink log file %s", path);
		fatal("cvs_logmsg_get: fstat failed");
d148 7
d156 1
a156 1
		if (cvs_exec(argc, argv, fds) < 0)
d160 2
a161 2
			cvs_log(LP_ERRNO, "failed to stat log message file");
			break;
d164 2
a165 2
		if (st2.st_mtime != st1.st_mtime) {
			msg = cvs_logmsg_open(path);
d169 9
a177 8
		/* nothing was entered */
		fprintf(stderr,
		    "\nLog message unchanged or not specified\na)bort, "
		    "c)ontinue, e)dit, !)reuse this message unchanged "
		    "for remaining dirs\nAction: (continue) ");

		if (fgets(buf, (int)sizeof(buf), stdin) == NULL) {
			cvs_log(LP_ERRNO, "failed to read from standard input");
d179 1
a179 5
		}

		len = strlen(buf);
		if (len == 0 || len > 2) {
			fprintf(stderr, "invalid input\n");
d181 2
a182 8
		} else if (buf[0] == 'a') {
			cvs_log(LP_ABORT, "aborted by user");
			break;
		} else if (buf[0] == '\n' || buf[0] == 'c') {
			/* empty message */
			msg = xstrdup("");
			break;
		} else if (buf[0] == 'e')
a183 2
		else if (buf[0] == '!') {
			/* XXX do something */
d189 2
d192 1
a192 30
	if (unlink(path) == -1)
		cvs_log(LP_ERRNO, "failed to unlink log file %s", path);

	return (msg);
}


/*
 * cvs_logmsg_send()
 *
 */
void
cvs_logmsg_send(struct cvsroot *root, const char *msg)
{
	const char *mp;
	char *np, buf[256];

	cvs_sendarg(root, "-m", 0);

	for (mp = msg; mp != NULL; mp = strchr(mp, '\n')) {
		if (*mp == '\n')
			mp++;

		/* XXX ghetto */
		strlcpy(buf, mp, sizeof(buf));
		np = strchr(buf, '\n');
		if (np != NULL)
			*np = '\0';
		cvs_sendarg(root, buf, (mp == msg) ? 0 : 1);
	}
@


1.28
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.27 2006/01/02 08:11:56 xsa Exp $	*/
@


1.27
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.26 2005/12/30 02:03:28 joris Exp $	*/
d80 2
a81 2
			if ((len == 0) || (len > 2) ||
			    ((lbuf[0] != 'y') && (lbuf[0] != 'n'))) {
d108 2
a109 2
		else if ((lcont == 0) && (strncmp(lbuf, CVS_LOGMSG_PREFIX,
		    strlen(CVS_LOGMSG_PREFIX)) == 0))
d248 1
a248 1
		if ((len == 0) || (len > 2)) {
d254 1
a254 1
		} else if ((buf[0] == '\n') || (buf[0] == 'c')) {
@


1.26
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.25 2005/12/22 13:19:12 moritz Exp $	*/
d27 1
a27 8
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.25
log
@unitialized variable. ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.24 2005/12/21 20:04:36 xsa Exp $	*/
d286 1
a286 1
int
d292 1
a292 2
	if (cvs_sendarg(root, "-m", 0) < 0)
		fatal("cvs_logmsg_send: cvs_sendarg failed");
d303 1
a303 2
		if (cvs_sendarg(root, buf, (mp == msg) ? 0 : 1) < 0)
			fatal("cvs_logmsg_send: cvs_sendarg failed");
a304 2

	return (0);
@


1.24
log
@fatal()ization! OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.23 2005/12/20 18:17:01 xsa Exp $	*/
d171 1
@


1.23
log
@cvs_buf_putc() and cvs_buf_write_*() functions cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.22 2005/12/10 20:27:45 joris Exp $	*/
d72 2
a73 4
	if (stat(path, &st) == -1) {
		cvs_log(LP_ERRNO, "failed to stat `%s'", path);
		return (NULL);
	}
d75 2
a76 4
	if (!S_ISREG(st.st_mode)) {
		cvs_log(LP_ERR, "message file must be a regular file");
		return (NULL);
	}
d83 2
a84 5
			if (fgets(lbuf, (int)sizeof(lbuf), stdin) == NULL) {
				cvs_log(LP_ERRNO,
				    "failed to read from standard input");
				return (NULL);
			}
d93 2
a94 4
			else if (lbuf[0] == 'n') {
				cvs_log(LP_ERR, "aborted by user");
				return (NULL);
			}
d99 3
a101 4
	if ((fp = fopen(path, "r")) == NULL) {
		cvs_log(LP_ERRNO, "failed to open message file `%s'", path);
		return (NULL);
	}
a103 4
	if (bp == NULL) {
		(void)fclose(fp);
		return (NULL);
	}
d120 1
a120 5
		if (cvs_buf_append(bp, lbuf, strlen(lbuf)) < 0) {
			cvs_buf_free(bp);
			(void)fclose(fp);
			return (NULL);
		}
d172 3
a174 4
	if ((fd = mkstemp(path)) == -1) {
		cvs_log(LP_ERRNO, "failed to create temporary file");
		return (NULL);
	}
d176 1
a176 4
	fp = fdopen(fd, "w");
	if (fp == NULL) {
		cvs_log(LP_ERRNO, "failed to fdopen");
		(void)close(fd);
d179 1
a179 1
		return (NULL);
a222 3
		cvs_log(LP_ERRNO, "failed to stat log message file");

		(void)fclose(fp);
d225 1
a225 1
		return (NULL);
d291 2
a292 4
	if (cvs_sendarg(root, "-m", 0) < 0) {
		cvs_log(LP_ERR, "failed to send log message");
		return (-1);
	}
d303 2
a304 4
		if (cvs_sendarg(root, buf, (mp == msg) ? 0 : 1) < 0) {
			cvs_log(LP_ERR, "failed to send log message");
			return (-1);
		}
@


1.22
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.21 2005/08/14 19:49:18 xsa Exp $	*/
d144 1
a144 4
	if (cvs_buf_putc(bp, '\0') < 0) {
		cvs_buf_free(bp);
		return (NULL);
	}
@


1.21
log
@missing casts; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.20 2005/08/10 14:49:20 xsa Exp $	*/
d290 1
a290 1
			msg = strdup("");
@


1.20
log
@fgets() expects the 2nd arg to be an int. OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.19 2005/08/08 14:28:59 xsa Exp $	*/
d113 1
a113 1
	bp = cvs_buf_alloc(128, BUF_AUTOEXT);
@


1.19
log
@use cvs_tmpdir; OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.18 2005/07/25 12:13:08 xsa Exp $	*/
d87 1
a87 1
			if (fgets(lbuf, sizeof(lbuf), stdin) == NULL) {
d125 1
a125 1
	while (fgets(lbuf, sizeof(lbuf), fp) != NULL) {
d276 1
a276 1
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
@


1.18
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.17 2005/07/25 12:05:43 xsa Exp $	*/
a42 1
#define CVS_LOGMSG_FTMPL	"/tmp/cvsXXXXXXXXXX"
d186 2
a187 1
	strlcpy(path, CVS_LOGMSG_FTMPL, sizeof(path));
@


1.17
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.16 2005/07/23 00:03:00 joris Exp $	*/
d42 3
a44 3
#define CVS_LOGMSG_BIGMSG     32000
#define CVS_LOGMSG_FTMPL      "/tmp/cvsXXXXXXXXXX"
#define CVS_LOGMSG_PREFIX     "CVS:"
@


1.16
log
@correctly seperate added, modified and removed files for use in the
construction of the log message in the editor.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.15 2005/06/02 16:05:38 xsa Exp $	*/
d63 1
a63 1
char*
d167 1
a167 1
char*
@


1.15
log
@- set LP_ABORT log level when action is abored by user instead of LP_ERR
- missing \n in output of an unchanged log message warning
- always use the command name in error messages instead of aliases

ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.14 2005/05/31 08:58:48 xsa Exp $	*/
d217 3
@


1.14
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.13 2005/04/18 21:02:50 jfb Exp $	*/
d269 1
a269 1
		    "Log message unchanged or not specified\na)bort, "
d283 1
a283 1
			cvs_log(LP_ERR, "aborted by user");
@


1.13
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.12 2005/02/26 21:51:33 david Exp $	*/
d33 1
a34 1
#include <string.h>
d36 1
a38 1
#include "buf.h"
@


1.12
log
@spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.11 2005/01/03 21:08:12 jfb Exp $	*/
d222 1
a222 1
		TAILQ_FOREACH(cvsfp, files[i], cf_list) {
@


1.11
log
@more error checking on buffer operations and plug a descriptor leak

from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.10 2004/12/08 21:49:02 jfb Exp $	*/
d161 1
a161 1
 * applies, and the 3 tail queue arguemnts contains all the files for which the
@


1.10
log
@complain if we fail to send the log message so the caller doesn't
have to
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.9 2004/12/08 18:54:23 jfb Exp $	*/
d115 2
a116 1
	if (bp == NULL)
d118 1
d135 5
a139 1
		cvs_buf_append(bp, lbuf, strlen(lbuf));
d143 6
a148 1
	cvs_buf_putc(bp, '\0');
@


1.9
log
@rearrange the output loop for file lists in the log message so we don't
have blank lines or extra delimiters in some cases

spotted by and discussed with Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.8 2004/12/08 17:22:48 jfb Exp $	*/
d305 2
a306 1
	if (cvs_sendarg(root, "-m", 0) < 0)
d308 1
d319 2
a320 1
		if (cvs_sendarg(root, buf, (mp == msg) ? 0 : 1) < 0)
d322 1
@


1.8
log
@embrace and extend (!) cvs_logmsg_get() so we can now display
information based on its availability and have separate sections for
the Added, Modified and Removed file lists.  this will allow us to
use the same call for add, commit, import and possibly others

Original patch by Joris Vink, some rework from me for the other
sections
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.7 2004/12/07 17:10:56 tedu Exp $	*/
d227 1
a228 1
		fprintf(fp, "\n%s %s\n", CVS_LOGMSG_PREFIX, CVS_LOGMSG_LINE);
d230 1
@


1.7
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.6 2004/12/06 21:03:12 deraadt Exp $	*/
d45 1
a45 1
#define CVS_LOGMSG_LOGLINE \
d49 5
d148 5
a152 1
 * Get a log message by forking and executing the user's editor.
d157 2
a158 1
cvs_logmsg_get(const char *dir, struct cvs_flist *files)
d160 1
a160 1
	int ret, fd, argc, fds[3], nl;
d166 5
d194 1
a194 9
	} else {
		fprintf(fp,
		    "\n%s %s\n%s Enter Log.  Lines beginning with `%s' are "
		    "removed automatically\n%s\n%s Commiting in %s\n"
		    "%s\n",
		    CVS_LOGMSG_PREFIX, CVS_LOGMSG_LOGLINE,
		    CVS_LOGMSG_PREFIX, CVS_LOGMSG_PREFIX,
		    CVS_LOGMSG_PREFIX, CVS_LOGMSG_PREFIX,
		    dir, CVS_LOGMSG_PREFIX);
d196 14
a209 2
		/* XXX list files here */
		fprintf(fp, "%s Modified Files:", CVS_LOGMSG_PREFIX);
d211 1
a211 1
		TAILQ_FOREACH(cvsfp, files, cf_list) {
d228 1
a228 2
		fprintf(fp, "\n%s %s\n", CVS_LOGMSG_PREFIX,
		    CVS_LOGMSG_LOGLINE);
d242 1
a242 2
		ret = cvs_exec(argc, argv, fds);
		if (ret == -1)
d244 1
d277 1
a277 1
		} else if (ret == 'e')
d279 1
a279 1
		else if (ret == '!') {
@


1.6
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: logmsg.c,v 1.5 2004/12/03 19:01:02 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a57 1

d94 1
a94 1
			} else if (lbuf[0] == 'y') 
d110 1
a110 1
	if (bp == NULL) {
a111 1
	}
a146 1

d252 1
a252 1
		} else if (buf[0] == 'a') { 
a279 1

@


1.5
log
@Rename variables to make more sense and fix a warning about assigning
to a read-only location.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 1
a95 2
			}
			else if (lbuf[0] == 'y') 
d255 1
a255 2
		}
		else if (buf[0] == 'a') { 
@


1.4
log
@This commit is brought to you by the brand new improved and better tasting
OpenCVS commit code.
@
text
@d289 2
a290 2
	const char *mp, *np;
	char buf[256];
d295 3
a297 3
	for (np = msg; np != NULL; np = strchr(np, '\n')) {
		if (*np == '\n')
			np++;
d300 5
a304 5
		strlcpy(buf, np, sizeof(buf));
		mp = strchr(buf, '\n');
		if (mp != NULL)
			*mp = '\0';
		if (cvs_sendarg(root, buf, (np == msg) ? 0 : 1) < 0)
@


1.3
log
@cvs_logmsg_get() now accepts a list of files that it is getting the
message for and displays those files in the commented part of the
log message
@
text
@d290 1
d292 2
a293 3
	for (np = msg;; np = strchr(np, '\n')) {
		if (np == NULL)
			break;
d295 10
a304 1
		if (cvs_sendarg(root, np, (np == msg) ? 0 : 1) < 0)
@


1.2
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@a41 1
#define CVS_LOGMSG_TERMWIDTH  80
d44 1
a44 1
#define CVS_LOGMSG_LOGPREFIX  "CVS:"
d126 2
a127 2
		else if ((lcont == 0) && (strncmp(lbuf, CVS_LOGMSG_LOGPREFIX,
		    strlen(CVS_LOGMSG_LOGPREFIX)) == 0))
d152 1
a152 1
cvs_logmsg_get(const char *dir)
d154 3
a156 3
	int ret, fd, argc, fds[3];
	size_t len;
	char *argv[4], buf[16], path[MAXPATHLEN], *msg;
d158 1
d179 4
d187 5
a191 5
		    "%s\n%s Modified Files:\n",
		    CVS_LOGMSG_LOGPREFIX, CVS_LOGMSG_LOGLINE,
		    CVS_LOGMSG_LOGPREFIX, CVS_LOGMSG_LOGPREFIX,
		    CVS_LOGMSG_LOGPREFIX, CVS_LOGMSG_LOGPREFIX,
		    dir, CVS_LOGMSG_LOGPREFIX, CVS_LOGMSG_LOGPREFIX);
d194 18
d213 1
a213 1
		fprintf(fp, "%s %s\n", CVS_LOGMSG_LOGPREFIX,
@


1.1
log
@Functions to extract log messages from files and query users for them
@
text
@d39 1
d42 1
d256 22
@
