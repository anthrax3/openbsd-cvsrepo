head	1.40;
access;
symbols
	OPENBSD_6_1:1.39.0.12
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.8
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.4
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.6
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.38.0.18
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.16
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.12
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.10
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.8
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.6
	OPENBSD_5_0:1.38.0.4
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.35.0.4
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2017.06.01.08.08.24;	author joris;	state Exp;
branches;
next	1.39;
commitid	oZyV6E3g0wglnhaw;

1.39
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	Uu5nFG3wCl0LACBb;

1.38
date	2010.10.31.15.37.34;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.25.21.19.20;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.23.20.51.08;	author ragge;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.10.15.50.31;	author tobias;	state Exp;
branches;
next	1.33;

1.33
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.06.17.34.06;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.13.20.29.46;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.09.14.00.14;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.13.06.52.11;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.12.13.56.00;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.10.10.15.48;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.08.18.02.06;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.19.15.30.37;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.16.20.05.05;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.01.21.14.21;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.27.00.22.08;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.05.18.34.01;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.12.20.09.58;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.06.14.09.24;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.30.23.12.13;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.29.18.23.25;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.00.46.48;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Stop looking at current_cvsroot->cr_method to figure out if we're remote or not.

Instead use cvsroot_is_local() and cvsroot_is_remote().
@
text
@/*	$OpenBSD: init.c,v 1.39 2015/01/16 06:40:07 deraadt Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * Copyright (c) 2006 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"
#include "cvs.h"
#include "init.h"
#include "remote.h"

void	cvs_init_local(void);

static void init_mkdir(const char *, mode_t);
static void init_mkfile(char *, const char **);

struct cvsroot_file {
	char			*cf_path;
	const char		**cf_content;
};

static const struct cvsroot_file cvsroot_files[] = {
	{ CVS_PATH_CHECKOUTLIST,	NULL			},
	{ CVS_PATH_COMMITINFO,		NULL			},
	{ CVS_PATH_CONFIG,		config_contents		},
	{ CVS_PATH_CVSWRAPPERS,		NULL			},
	{ CVS_PATH_EDITINFO,		NULL			},
	{ CVS_PATH_HISTORY,		NULL			},
	{ CVS_PATH_LOGINFO,		NULL			},
	{ CVS_PATH_MODULES,		NULL			},
	{ CVS_PATH_NOTIFY_R,		NULL			},
	{ CVS_PATH_RCSINFO,		NULL			},
	{ CVS_PATH_TAGINFO,		NULL			},
	{ CVS_PATH_VALTAGS,		NULL			},
	{ CVS_PATH_VERIFYMSG,		NULL			}
};

static const char *cvsroot_dirs[2] = {
	CVS_PATH_ROOT, CVS_PATH_EMPTYDIR
};

#define INIT_NFILES	(sizeof(cvsroot_files)/sizeof(cvsroot_files[0]))
#define INIT_NDIRS	(sizeof(cvsroot_dirs)/sizeof(cvsroot_dirs[0]))

struct cvs_cmd cvs_cmd_init = {
	CVS_OP_INIT, 0, "init",
	{ { 0 }, { 0 } },
	"Create a CVS repository if it doesn't exist",
	"",
	"",
	NULL,
	cvs_init
};

int
cvs_init(int argc, char **argv)
{
	if (argc > 1)
		fatal("init does not take any extra arguments");

	if (cvsroot_is_remote()) {
		cvs_client_connect_to_server();
		cvs_client_send_request("init %s", current_cvsroot->cr_dir);
		cvs_client_get_responses();
	} else {
		cvs_init_local();
	}

	return (0);
}

void
cvs_init_local(void)
{
	u_int i;
	char path[PATH_MAX];

	cvs_log(LP_TRACE, "cvs_init_local()");

	/* Create repository root directory if it does not already exist */
	init_mkdir(current_cvsroot->cr_dir, 0777);

	for (i = 0; i < INIT_NDIRS; i++) {
		(void)xsnprintf(path, PATH_MAX, "%s/%s",
		    current_cvsroot->cr_dir, cvsroot_dirs[i]);

		init_mkdir(path, 0777);
	}

	for (i = 0; i < INIT_NFILES; i++) {
		(void)xsnprintf(path, PATH_MAX, "%s/%s",
		    current_cvsroot->cr_dir, cvsroot_files[i].cf_path);

		init_mkfile(path, cvsroot_files[i].cf_content);
	}
}

static void
init_mkdir(const char *path, mode_t mode)
{
	struct stat st;

	if (mkdir(path, mode) == -1) {
		if (!(errno == EEXIST ||
		    (errno == EACCES && (stat(path, &st) == 0) &&
		    S_ISDIR(st.st_mode)))) {
			fatal("init_mkdir: mkdir: `%s': %s",
			    path, strerror(errno));
		}
	}
}

static void
init_mkfile(char *path, const char **content)
{
	BUF *b;
	size_t len;
	int fd, openflags, rcsflags;
	char rpath[PATH_MAX];
	const char **p;
	RCSFILE *file;

	openflags = O_WRONLY | O_CREAT | O_EXCL;
	rcsflags = RCS_WRITE | RCS_CREATE;

	if ((fd = open(path, openflags, 0444)) == -1)
		fatal("init_mkfile: open: `%s': %s", path, strerror(errno));

	if (content != NULL) {
		for (p = content; *p != NULL; ++p) {
			len = strlen(*p);
			if (atomicio(vwrite, fd, *p, len) != len)
				fatal("init_mkfile: atomicio failed");
		}
	}

	/*
	 * Make sure history and val-tags files are world-writable.
	 * Every user should be able to write to them.
	 */
	if (strcmp(strrchr(CVS_PATH_HISTORY, '/'), strrchr(path, '/')) == 0 ||
	    strcmp(strrchr(CVS_PATH_VALTAGS, '/'), strrchr(path, '/')) == 0) {
		(void)fchmod(fd, 0666);
		(void)close(fd);
		return;
	}

	(void)xsnprintf(rpath, PATH_MAX, "%s%s", path, RCS_FILE_EXT);

	if ((file = rcs_open(rpath, -1, rcsflags, 0444)) == NULL)
		fatal("failed to create RCS file for `%s'", path);

	b = buf_load(path);

	if (rcs_rev_add(file, RCS_HEAD_REV, "initial checkin", -1, NULL) == -1)
		fatal("init_mkfile: failed to add new revision");

	/* b buffer is free'd in rcs_deltatext_set */
	if (rcs_deltatext_set(file, file->rf_head, b) == -1)
		fatal("init_mkfile: failed to set delta");

	file->rf_flags &= ~RCS_SYNCED;
	rcs_close(file);
	(void)close(fd);
}
@


1.39
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.38 2010/10/31 15:37:34 nicm Exp $	*/
d89 1
a89 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
d93 1
a93 1
	} else
d95 1
@


1.38
log
@init was passing a writable file descriptor into rcs_open which was then
failing to fdopen() it as readable. It doesn't need to pass in the fd at
all, so just change it to pass -1 which makes cvs init work again.

In fact, the fd should never need to be writable - it is only used for
reading. RCS_WRITE triggers a rewrite on the file on rcs_close() but
this is done by using a temporary and rename(2) (RCS_WRITE is a poor
name for the flag). So while here, add a couple of comments to hopefully
make it a little clearer. There is some confusion about how this is used
in other places but checking those is a separate issue.

with and ok tobias
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.37 2010/07/23 21:46:05 ray Exp $	*/
d103 1
a103 1
	char path[MAXPATHLEN];
d111 1
a111 1
		(void)xsnprintf(path, MAXPATHLEN, "%s/%s",
d118 1
a118 1
		(void)xsnprintf(path, MAXPATHLEN, "%s/%s",
d146 1
a146 1
	char rpath[MAXPATHLEN];
d175 1
a175 1
	(void)xsnprintf(rpath, MAXPATHLEN, "%s%s", path, RCS_FILE_EXT);
@


1.37
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.36 2009/03/25 21:19:20 joris Exp $	*/
d177 1
a177 1
	if ((file = rcs_open(rpath, fd, rcsflags, 0444)) == NULL)
@


1.36
log
@remove unused functions, definitions and outdated comments
from the stone ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.35 2008/06/23 20:51:08 ragge Exp $	*/
d180 1
a180 1
	b = cvs_buf_load(path);
@


1.35
log
@Some conformance fixes:
- Empty brackets forbidden in C99.
- ? : and skipping middle argument is both disallowed and considered bad
  programming habit.
OK ray@@, xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.34 2008/06/10 15:50:31 tobias Exp $	*/
d150 2
a151 2
	openflags = O_WRONLY|O_CREAT|O_EXCL;
	rcsflags = RCS_RDWR|RCS_CREATE;
@


1.34
log
@style, also don't use cvs_buf_* if it is realy not worth the effort.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.33 2008/02/11 20:33:11 tobias Exp $	*/
d75 1
a75 1
	{ },
@


1.33
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.32 2007/02/22 06:42:09 otto Exp $	*/
d35 1
d43 1
a43 1
static void init_mkfile(char *, const char *const *);
d47 1
a47 1
	const char *const	*cf_content;
d141 1
a141 1
init_mkfile(char *path, const char *const *content)
d147 1
a147 1
	const char *const *p;
a149 2
	len = 0;
	fd = -1;
d159 2
a160 8
			b = cvs_buf_alloc(len);

			cvs_buf_append(b, *p, strlen(*p));

			if (cvs_buf_write_fd(b, fd) < 0)
				fatal("init_mkfile: cvs_buf_write_fd");

			cvs_buf_free(b);
d171 2
a172 1
		goto out;
a190 1
out:
@


1.32
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.31 2007/02/17 18:23:43 xsa Exp $	*/
d160 1
a160 1
			b = cvs_buf_alloc(len, BUF_AUTOEXT);
d162 1
a162 2
			if (cvs_buf_append(b, *p, strlen(*p)) < 0)
				fatal("init_mkfile: cvs_buf_append");
d186 1
a186 2
	if ((b = cvs_buf_load(path, BUF_AUTOEXT)) == NULL)
		fatal("init_mkfile: failed to load %s", path);
@


1.31
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.30 2007/02/06 17:34:06 xsa Exp $	*/
d28 6
a33 1
#include "includes.h"
a36 1
#include "log.h"
@


1.30
log
@replace strl* overload and xstrdup() misuse by xsnprintf();
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.29 2007/01/25 18:56:33 otto Exp $	*/
d106 2
a107 3
		if (cvs_path_cat(current_cvsroot->cr_dir,
		    cvsroot_dirs[i], path, MAXPATHLEN) >= MAXPATHLEN)
			fatal("cvs_init_local: truncation");
d113 2
a114 3
		if (cvs_path_cat(current_cvsroot->cr_dir,
		    cvsroot_files[i].cf_path, path, MAXPATHLEN) >= MAXPATHLEN)
			fatal("cvs_init_local: truncation");
@


1.29
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.28 2007/01/13 20:29:46 joris Exp $	*/
d143 1
a143 1
	char *rpath;
d180 1
a180 3
	rpath = xstrdup(path);
	if (strlcat(rpath, RCS_FILE_EXT, MAXPATHLEN) >= MAXPATHLEN)
		fatal("init_mkfile: truncation");
a196 1
	xfree(rpath);
@


1.28
log
@make import and init work again after the small breakage
we had with the rcs changes;
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.27 2007/01/11 02:35:55 joris Exp $	*/
d98 1
a98 1
	char *path;
a104 2
	path = xmalloc(MAXPATHLEN);

a119 2

	xfree(path);
@


1.27
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.26 2006/11/09 14:00:14 xsa Exp $	*/
d147 1
a147 1
	char *d, *rpath;
a152 1
	d = NULL;
a193 3
	cvs_buf_putc(b, '\0');
	d = cvs_buf_release(b);

d197 2
a198 1
	if (rcs_deltatext_set(file, file->rf_head, d) == -1)
a205 3

	if (d != NULL)
		xfree(d);
@


1.26
log
@cvs init remote bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.25 2006/06/16 14:07:42 joris Exp $	*/
d85 1
@


1.25
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.24 2006/06/13 06:52:11 joris Exp $	*/
d33 1
a34 1
int	cvs_init(int, char **);
d84 4
a87 1
	if (current_cvsroot->cr_method == CVS_METHOD_LOCAL)
@


1.24
log
@better usage
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.23 2006/06/12 13:56:00 xsa Exp $	*/
a32 1
#include "proto.h"
d69 1
a69 1
	CVS_OP_INIT, CVS_REQ_INIT, "init",
@


1.23
log
@bring back a working version of the `cvs init' command. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.22 2006/02/10 10:15:48 xsa Exp $	*/
d83 1
a83 1
		fatal("%s", cvs_cmd_init.cmd_synopsis);
@


1.22
log
@fix CVS_PATH_NOTIFY duplicate.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.21 2006/01/08 18:02:06 xsa Exp $	*/
d4 1
d31 1
d35 2
d38 2
a39 2
#define CFT_FILE	1
#define CFT_DIR		2
d41 20
d62 2
a63 19
struct cvsroot_file {
	char	*cf_path;	/* path relative to CVS root directory */
	u_int	 cf_type;
	mode_t	 cf_mode;
} cvsroot_files[] = {
	{ CVS_PATH_ROOT,   CFT_DIR, (S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) },
	{ CVS_PATH_EMPTYDIR, CFT_DIR, (S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) },
	{ CVS_PATH_COMMITINFO,  CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_CONFIG,      CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_CVSIGNORE,   CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_CVSWRAPPERS, CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_EDITINFO,    CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_HISTORY,     CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_LOGINFO,     CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_MODULES,     CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_NOTIFY_R,    CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_RCSINFO,     CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_TAGINFO,     CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
	{ CVS_PATH_VERIFYMSG,   CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
d66 2
a67 2
static int	cvs_init_pre_exec(struct cvsroot *);
static void	cvs_init_create_files(struct cvsroot *);
d76 1
a76 8
	0,
	NULL,
	cvs_init_pre_exec,
	NULL,
	NULL,
	NULL,
	NULL,
	0
d79 2
a80 8
/*
 * cvs_init_pre_exec()
 *
 * Local/remote handler for the "cvs init" command.
 * Returns 0 on success, -1 on failure.
 */
static int
cvs_init_pre_exec(struct cvsroot *root)
d82 5
a86 2
	if (root->cr_method == CVS_METHOD_LOCAL)
		cvs_init_create_files(root);
d91 32
a122 8
/*
 * cvs_init_create_files
 *
 * Create all required files for the "cvs init" command.
 * Used by the local handlers.
 * Returns 0 on success, -1 on failure.
 *
 */
d124 1
a124 1
cvs_init_create_files(struct cvsroot *root)
a125 5
	size_t len;
	int fd;
	u_int i;
	char path[MAXPATHLEN];
	RCSFILE *rfp;
d128 6
a133 6
	/* Create repository root directory if it does not already exist */
	if (mkdir(root->cr_dir, 0777) == -1) {
		if (!(errno == EEXIST || (errno == EACCES &&
		    (stat(root->cr_dir, &st) == 0) && S_ISDIR(st.st_mode)))) {
			fatal("cvs_init_create_files: mkdir: %s: %s",
			    root->cr_dir, strerror(errno));
d136 25
d162 2
a163 29
	/* Create the repository administrative files */
	for (i = 0; i < sizeof(cvsroot_files)/sizeof(cvsroot_files[i]); i++) {
		len = cvs_path_cat(root->cr_dir, cvsroot_files[i].cf_path,
		    path, sizeof(path));
		if (len >= sizeof(path))
			fatal("cvs_init_create_files: path truncation");

		if (cvsroot_files[i].cf_type == CFT_DIR) {
			if (mkdir(path, cvsroot_files[i].cf_mode) == -1) {
				if (!(errno == EEXIST || (errno == EACCES &&
				    (stat(path, &st) == 0) &&
				    S_ISDIR(st.st_mode)))) {
					fatal("cvs_init_create_files: mkdir: "
					    "%s: %s", path, strerror(errno));
				}
			}
		} else if (cvsroot_files[i].cf_type == CFT_FILE) {
			fd = open(path, O_WRONLY|O_CREAT|O_EXCL,
			    cvsroot_files[i].cf_mode);
			if (fd == -1)
				fatal("cvs_init_create_file: open failed: %s",
				    strerror(errno));

			(void)close(fd);

			strlcat(path, RCS_FILE_EXT, sizeof(path));
			rfp = rcs_open(path, RCS_WRITE|RCS_CREATE, 0640);
			if (rfp == NULL)
				return;
d165 4
a168 1
			rcs_close(rfp);
d171 38
@


1.21
log
@make cvs_init_create_files() return type void; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.20 2006/01/02 08:11:56 xsa Exp $	*/
d53 1
a53 1
	{ CVS_PATH_NOTIFY,      CFT_FILE, (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) },
@


1.20
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.19 2005/07/25 12:05:43 xsa Exp $	*/
d60 1
a60 1
static int	cvs_init_create_files(struct cvsroot *);
d88 2
a89 4
	if (root->cr_method == CVS_METHOD_LOCAL) {
		if (cvs_init_create_files(root) < 0)
			return (CVS_EX_FILE);
	}
d102 1
a102 1
static int
d116 2
a117 3
			cvs_log(LP_ERRNO, "cannot make directory %s",
			    root->cr_dir);
			return (CVS_EX_FILE);
d126 1
a126 1
			return (-1);
d133 2
a134 3
					cvs_log(LP_ERRNO,
					    "cannot make directory %s", path);
					return (CVS_EX_FILE);
d140 3
a142 5
			if (fd == -1) {
				cvs_log(LP_ERRNO, "failed to create `%s'",
				    path);
				return (CVS_EX_FILE);
			}
d148 2
a149 3
			if (rfp == NULL) {
				return (CVS_EX_DATA);
			}
a153 2

	return (0);
@


1.19
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.18 2005/07/19 15:30:37 xsa Exp $	*/
d27 1
a27 9
#include <sys/param.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.18
log
@make the init command work;
tested aanriot@@ joris@@; Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.17 2005/05/31 08:58:48 xsa Exp $	*/
d42 2
a43 2
#define CFT_FILE   1
#define CFT_DIR    2
d47 3
a49 3
	char   *cf_path;   /* path relative to CVS root directory */
	u_int   cf_type;
	mode_t  cf_mode;
d67 2
a68 2
static int cvs_init_pre_exec     (struct cvsroot *);
static int cvs_init_create_files (struct cvsroot *);
@


1.17
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.16 2005/05/24 04:12:25 jfb Exp $	*/
d52 1
d67 2
a68 1
int cvs_init_local(struct cvsroot *);
d79 1
a79 1
	NULL,
d88 18
a105 1
 * cvs_init_local()
d107 2
a108 1
 * Local handler for the "cvs init" command.
d110 1
d112 2
a113 2
int
cvs_init_local(struct cvsroot *root)
d115 2
a116 1
	int fd, l;
d120 1
d122 11
d134 3
a136 5
		l = snprintf(path, sizeof(path), "%s/%s", root->cr_dir,
		    cvsroot_files[i].cf_path);
		if (l == -1 || l >= (int)sizeof(path)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", path);
a137 1
		}
d141 7
a147 3
				cvs_log(LP_ERRNO, "failed to create `%s'",
				    path);
				return (CVS_EX_FILE);
@


1.16
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.15 2005/04/16 20:05:05 xsa Exp $	*/
d31 1
a32 1
#include <fcntl.h>
d34 1
a35 1
#include <string.h>
a37 1
#include "rcs.h"
@


1.15
log
@more snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.14 2005/04/12 14:58:40 joris Exp $	*/
a52 1

d69 6
a74 1
struct cvs_cmd_info cvs_init = {
a75 1
	NULL, NULL, NULL, NULL,
d77 6
a82 1
	CVS_REQ_INIT,
@


1.14
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.13 2005/04/03 17:32:50 xsa Exp $	*/
d87 1
a87 1
	int fd;
d93 1
a93 1
		snprintf(path, sizeof(path), "%s/%s", root->cr_dir,
d95 5
@


1.13
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.12 2005/03/30 17:43:04 joris Exp $	*/
d100 1
a100 1
				return (-1);
d108 1
a108 1
				return (-1);
d116 1
a116 1
				return (-1);
@


1.12
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.11 2005/03/01 21:14:21 jfb Exp $	*/
a35 1
#include <sysexits.h>
d82 1
a82 1
 * Returns 0 on success, or the appropriate exit status on failure.
d100 1
a100 1
				return (EX_CANTCREAT);
d108 1
a108 1
				return (EX_CANTCREAT);
d116 1
a116 1
				return (EX_CANTCREAT);
@


1.11
log
@fix call to rcs_open() so the file gets created, and remove the
explicit call to rcs_write(), it is not needed anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.10 2005/02/27 00:22:08 jfb Exp $	*/
d69 9
d80 1
a80 1
 * cvs_init()
d82 1
a82 2
 * Handler for the `cvs init' command which is used to initialize a CVS
 * repository.
d86 1
a86 1
cvs_init(int argc, char **argv)
a91 24
	struct cvsroot *root;

	if (argc != 1)
		return (EX_USAGE);

	root = cvsroot_get(".");
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}

	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_connect(root) < 0)
			return (EX_DATAERR);

		if (cvs_sendreq(root, CVS_REQ_INIT, root->cr_dir) < 0)
			return (EX_DATAERR);

		cvs_disconnect(root);
		return (0);
	}
@


1.10
log
@Many improvements to the RCS support:

- make it possible to specify creation and the file mode
  in rcs_open()
- implicitly write the contents to disk on rcs_close() if the
  RCS handle has been changed
- fix a bug in the output of the `expand' keyword
- add functions to retrieve and modify the expansion mode
- rcs_parse() shouldn't be available to the outside
- empty string instead of `(null)' if there is no description

ok Joris
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.9 2005/01/05 18:34:01 jfb Exp $	*/
d131 1
a131 1
			rfp = rcs_open(path, RCS_WRITE, 0644);
a132 5
				return (EX_CANTCREAT);
			}

			if (rcs_write(rfp) < 0) {
				rcs_close(rfp);
@


1.9
log
@Before attempting to initialize the cvs repository, make sure we have
a valid CVSROOT, and abort with the appropriate error message
otherwise.  Fixes a core dump spotted by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.8 2004/12/07 17:10:56 tedu Exp $	*/
d131 1
a131 1
			rfp = rcs_open(path, RCS_MODE_WRITE);
@


1.8
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.7 2004/12/06 21:03:12 deraadt Exp $	*/
d90 8
@


1.7
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.6 2004/08/12 20:09:58 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a69 1

a76 1

@


1.6
log
@Make `init' work in client mode
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 2
		}
		else if (cvsroot_files[i].cf_type == CFT_FILE) {
@


1.5
log
@Unused variable
@
text
@d41 1
d92 10
@


1.4
log
@Remove remaining references to cvs_root
@
text
@a84 1
	struct stat st;
@


1.3
log
@No need to import the `cvs_root' symbol anymore, it is done in cvs.h
@
text
@d86 1
d91 2
d94 1
a94 1
		snprintf(path, sizeof(path), "%s/%s", cvs_root->cr_dir,
@


1.2
log
@* document cvs_init() a bit
@
text
@a41 5
extern struct cvsroot *cvs_root;


extern char cvs_loginfo_data[];

@


1.1
log
@Initial revision
@
text
@d75 7
a81 1

@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
