head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.10
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.8
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.20
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.18
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.14
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.12
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.24
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.26.22.54.37;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.21.13.44.18;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.09.03.14.52;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.03.23.34.41;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.03.22.50.28;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.31.13.54.12;	author tobias;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.10.09.57.51;	author tobias;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.03.13.22.43;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.07.23.47.56;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.19.23.23.21;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.11.07.59.18;	author xsa;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.28.14.49.58;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.10.14.32.44;	author xsa;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.14.12.35.09;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.02.19.10.24;	author david;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.27.15.14.27;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.27.03.30.31;	author joris;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: repository.c,v 1.23 2010/07/23 08:31:19 ray Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"

struct wklhead repo_locks;

void
cvs_repository_unlock(const char *repo)
{
	char fpath[PATH_MAX];

	cvs_log(LP_TRACE, "cvs_repository_unlock(%s)", repo);

	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s", repo, CVS_LOCK);

	/* XXX - this ok? */
	worklist_run(&repo_locks, worklist_unlink);
}

void
cvs_repository_lock(const char *repo, int wantlock)
{
	int i;
	uid_t myuid;
	struct stat st;
	char fpath[PATH_MAX];
	struct passwd *pw;

	if (cvs_noexec == 1 || cvs_readonlyfs == 1)
		return;

	cvs_log(LP_TRACE, "cvs_repository_lock(%s, %d)", repo, wantlock);

	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s", repo, CVS_LOCK);

	myuid = getuid();

	for (i = 0; i < CVS_LOCK_TRIES; i++) {
		if (cvs_quit)
			fatal("received signal %d", sig_received);

		if (stat(fpath, &st) == -1)
			break;

		if (st.st_uid == myuid)
			return;

		if ((pw = getpwuid(st.st_uid)) == NULL)
			fatal("cvs_repository_lock: %s", strerror(errno));

		cvs_log(LP_NOTICE, "waiting for %s's lock in '%s'",
		    pw->pw_name, repo);
		sleep(CVS_LOCK_SLEEP);
	}

	if (i == CVS_LOCK_TRIES)
		fatal("maximum wait time for lock inside '%s' reached", repo);

	if (wantlock == 0)
		return;

	if ((i = open(fpath, O_WRONLY|O_CREAT|O_TRUNC, 0755)) < 0) {
		if (errno == EEXIST)
			fatal("cvs_repository_lock: somebody beat us");
		else
			fatal("cvs_repository_lock: %s: %s",
			    fpath, strerror(errno));
	}

	(void)close(i);
	worklist_add(fpath, &repo_locks);
}

void
cvs_repository_getdir(const char *dir, const char *wdir,
	struct cvs_flisthead *fl, struct cvs_flisthead *dl, int flags)
{
	int type;
	DIR *dirp;
	struct stat st;
	struct dirent *dp;
	char *s, fpath[PATH_MAX], rpath[PATH_MAX];

	if ((dirp = opendir(dir)) == NULL)
		fatal("cvs_repository_getdir: failed to open '%s'", dir);

	while ((dp = readdir(dirp)) != NULL) {
		if (!strcmp(dp->d_name, ".") ||
		    !strcmp(dp->d_name, "..") ||
		    !strcmp(dp->d_name, CVS_LOCK))
			continue;

		(void)xsnprintf(fpath, PATH_MAX, "%s/%s", wdir, dp->d_name);
		(void)xsnprintf(rpath, PATH_MAX, "%s/%s", dir, dp->d_name);

		if (!TAILQ_EMPTY(&checkout_ign_pats)) {
			if ((s = strrchr(fpath, ',')) != NULL)
				*s = '\0';
			if (cvs_file_chkign(fpath))
				continue;
			if (s != NULL)
				*s = ',';
		}

		/*
		 * nfs and afs will show d_type as DT_UNKNOWN
		 * for files and/or directories so when we encounter
		 * this we call lstat() on the path to be sure.
		 */
		if (dp->d_type == DT_UNKNOWN) {
			if (lstat(rpath, &st) == -1)
				fatal("'%s': %s", rpath, strerror(errno));

			switch (st.st_mode & S_IFMT) {
			case S_IFDIR:
				type = CVS_DIR;
				break;
			case S_IFREG:
				type = CVS_FILE;
				break;
			default:
				fatal("Unknown file type in repository");
			}
		} else {
			switch (dp->d_type) {
			case DT_DIR:
				type = CVS_DIR;
				break;
			case DT_REG:
				type = CVS_FILE;
				break;
			default:
				fatal("Unknown file type in repository");
			}
		}

		if (!(flags & REPOSITORY_DODIRS) && type == CVS_DIR) {
			if (strcmp(dp->d_name, CVS_PATH_ATTIC))
				continue;
		}

		switch (type) {
		case CVS_DIR:
			if (!strcmp(dp->d_name, CVS_PATH_ATTIC)) {
				cvs_repository_getdir(rpath, wdir, fl, dl,
				    REPOSITORY_IS_ATTIC);
			} else {
				cvs_file_get(fpath, 0, dl, CVS_DIR);
			}
			break;
		case CVS_FILE:
			if ((s = strrchr(fpath, ',')) != NULL &&
			    s != fpath && !strcmp(s, RCS_FILE_EXT)) {
				*s = '\0';
				cvs_file_get(fpath, 
				    (flags & REPOSITORY_IS_ATTIC) ?
				    FILE_INSIDE_ATTIC : 0, fl, CVS_FILE);
			}
			break;
		default:
			fatal("type %d unknown, shouldn't happen", type);
		}
	}

	(void)closedir(dirp);
}
@


1.23
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.22 2009/03/26 22:54:37 joris Exp $	*/
d33 1
a33 1
	char fpath[MAXPATHLEN];
d49 1
a49 1
	char fpath[MAXPATHLEN];
d105 1
a105 1
	char *s, fpath[MAXPATHLEN], rpath[MAXPATHLEN];
d116 2
a117 2
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", wdir, dp->d_name);
		(void)xsnprintf(rpath, MAXPATHLEN, "%s/%s", dir, dp->d_name);
@


1.22
log
@fix the way Attic is handled in our recursion code, so we
do not skip files or run over them twice.

also fixes -l and -r for checkout/update when a file in
Attic exists with that tag that in HEAD is a directory
in the normal repository like gnu/usr.bin/gcc/INSTALL.

as a bonus, we do not run fstat() twice per file or dir
anymore...

spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.21 2009/02/21 13:44:18 joris Exp $	*/
d28 1
a28 1
struct cvs_wklhead repo_locks;
d40 1
a40 1
	cvs_worklist_run(&repo_locks, cvs_worklist_unlink);
d94 1
a94 1
	cvs_worklist_add(fpath, &repo_locks);
@


1.21
log
@use file_flags for 2 more reasons:
- mark a file as being inside the Attic/
- mark a file as existing in the working copy
  (both in local and remote mode)

this way we no longer will need to check if cf->fd == -1 and
think about wether or not we are in local or remote mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.20 2008/03/09 03:14:52 joris Exp $	*/
d160 4
a163 2
		if (!(flags & REPOSITORY_DODIRS) && type == CVS_DIR)
			continue;
d171 1
a171 1
				cvs_file_get(fpath, 0, dl);
d180 1
a180 1
				    FILE_INSIDE_ATTIC : 0, fl);
@


1.20
log
@proper repository locking:
- all read operations now look for a lock, and wait if present but never
  try to lock the tree themselfs anymore.
- all write operations lock the tree where needed.
- commit locks all relevant directories before even attempting to start.
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.19 2008/02/03 23:34:41 joris Exp $	*/
d99 1
a99 1
	struct cvs_flisthead *fl, struct cvs_flisthead *dl, int dodirs)
d160 1
a160 1
		if (dodirs == 0 && type == CVS_DIR)
d165 4
a168 3
			if (!strcmp(dp->d_name, CVS_PATH_ATTIC))
				cvs_repository_getdir(rpath, wdir, fl, dl, 0);
			else
d170 1
d176 3
a178 1
				cvs_file_get(fpath, 0, fl);
@


1.19
log
@shuffle some stuff around so we dont end up doing the same things
twice in cvs_module_lookup() and checkout_check_directory();

allow single files to be ignored with ! as well;
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.18 2008/02/03 22:50:28 joris Exp $	*/
d44 1
a44 1
cvs_repository_lock(const char *repo)
d47 1
d55 1
a55 1
	cvs_log(LP_TRACE, "cvs_repository_lock(%s)", repo);
d59 2
d68 3
d81 3
@


1.18
log
@more CVSROOT/module stuff:

- allow more then 1 module to be specified per definition
- respect the "!" sign which means: "hey ignore this dir when checking out"
- non alias definitions can now contain files

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.17 2008/01/31 13:54:12 tobias Exp $	*/
d111 2
d115 2
@


1.17
log
@On repository-side, only parse files which end with ,v (RCS_FILE_EXT).
File name ",v" is ignored, too -- in opposite to weird GNU cvs that tries
to create a file without name.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.16 2008/01/10 09:57:51 tobias Exp $	*/
d109 5
@


1.16
log
@Don't ignore files and directories due to patterns on repository-side,
these patterns should only be applied on working directories.

This finally enables a fully working "cvs checkout src" (but don't expect
all checkout options to work, too).
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.15 2007/09/22 16:01:22 joris Exp $	*/
d153 2
a154 1
			if ((s = strrchr(fpath, ',')) != NULL)
d156 2
a157 1
			cvs_file_get(fpath, 0, fl);
@


1.15
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.14 2007/07/03 13:22:43 joris Exp $	*/
a104 3
			continue;

		if (cvs_file_chkign(dp->d_name))
@


1.14
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.13 2007/06/01 17:47:47 niallo Exp $	*/
d153 1
a153 1
				cvs_file_get(fpath, dl);
d158 1
a158 1
			cvs_file_get(fpath, fl);
@


1.13
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.12 2007/02/22 06:42:09 otto Exp $	*/
d150 4
a153 1
			cvs_file_get(fpath, dl);
@


1.12
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.11 2007/02/17 18:23:43 xsa Exp $	*/
a103 1
		    !strcmp(dp->d_name, CVS_PATH_ATTIC) ||
@


1.11
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.10 2007/02/07 23:47:56 todd Exp $	*/
d18 7
a24 1
#include "includes.h"
a26 4
#include "file.h"
#include "log.h"
#include "repository.h"
#include "worklist.h"
@


1.10
log
@fstat() -> lstat() in a few select cases,
this fixes a bug where opencvs update would abort if a link existed that
pointed to a non-existent file/dir
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.9 2007/01/25 18:56:33 otto Exp $	*/
d35 1
a35 2
	if (cvs_path_cat(repo, CVS_LOCK, fpath, sizeof(fpath)) >= sizeof(fpath))
		fatal("cvs_repository_unlock: truncation");
d54 1
a54 2
	if (cvs_path_cat(repo, CVS_LOCK, fpath, sizeof(fpath)) >= sizeof(fpath))
		fatal("cvs_repository_unlock: truncation");
d109 2
a110 7
		if (cvs_path_cat(wdir, dp->d_name,
		    fpath, MAXPATHLEN) >= MAXPATHLEN)
			fatal("cvs_repository_getdir: truncation");

		if (cvs_path_cat(dir, dp->d_name,
		    rpath, MAXPATHLEN) >= MAXPATHLEN)
			fatal("cvs_repository_getdir: truncation");
@


1.9
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.8 2007/01/19 23:23:21 joris Exp $	*/
d122 1
a122 1
		 * this we call stat() on the path to be sure.
d125 1
a125 1
			if (stat(rpath, &st) == -1)
@


1.8
log
@When we hit a DT_UNKNOWN for dirent->d_type in our filelist functions,
stat() the filepath to get the correct type, and therefor
add it to the appropriate list.

This fixes opencvs with CVSROOTs on NFS and AFS, because they
both return D_UNKNOWN for directories (afs even for files too)
in dirent->d_type.

problem found by thib@@ and todd@@
tested by thib@@, todd@@,
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.7 2006/12/11 07:59:18 xsa Exp $	*/
d96 1
a96 4
	char *s, *fpath, *rpath;

	rpath = xmalloc(MAXPATHLEN);
	fpath = xmalloc(MAXPATHLEN);
a166 3

	xfree(rpath);
	xfree(fpath);
@


1.7
log
@Permit checkout from a read-only repository using the -R global option
or using the CVSREADONLYFS environment variable.
Request/test/ok todd@@. Man page bits courtesy of jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.6 2006/11/28 14:49:58 xsa Exp $	*/
d92 1
d94 1
d96 4
a99 1
	char *s, fpath[MAXPATHLEN];
d114 3
a116 2
		if (dodirs == 0 && dp->d_type == DT_DIR)
			continue;
d118 2
a119 2
		if (cvs_path_cat(wdir, dp->d_name,
		    fpath, sizeof(fpath)) >= sizeof(fpath))
d123 3
a125 2
		 * Anticipate the file type for sorting, we do not determine
		 * the final file type until we have the fd floating around.
d127 32
a158 1
		if (dp->d_type == DT_DIR) {
d160 2
a161 1
		} else if (dp->d_type == DT_REG) {
d165 3
d170 3
@


1.6
log
@snprintf() -> cvs_path_cat()
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.5 2006/11/10 14:32:44 xsa Exp $	*/
d49 3
@


1.5
log
@no magic, "Attic" -> CVS_PATH_ATTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.4 2006/06/14 12:35:09 joris Exp $	*/
a30 1
	int l;
d35 2
a36 3
	l = snprintf(fpath, sizeof(fpath), "%s/%s", repo, CVS_LOCK);
	if (l == -1 || l >= (int)sizeof(fpath))
		fatal("cvs_repository_unlock: overflow");
d45 1
a45 1
	int l, i;
d52 2
a53 3
	l = snprintf(fpath, sizeof(fpath), "%s/%s", repo, CVS_LOCK);
	if (l == -1 || l >= (int)sizeof(fpath))
		fatal("cvs_repository_lock: overflow");
a88 1
	int l;
d109 3
a111 3
		l = snprintf(fpath, sizeof(fpath), "%s/%s", wdir, dp->d_name);
		if (l == -1 || l >= (int)sizeof(fpath))
			fatal("cvs_repository_getdir: overflow");
@


1.4
log
@zap myuid variable, it is not used for anything usefull.
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.3 2006/06/02 19:10:24 david Exp $	*/
d103 1
a103 1
		    !strcmp(dp->d_name, "Attic") ||
@


1.3
log
@various spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.2 2006/05/27 15:14:27 joris Exp $	*/
a47 1
	uid_t myuid;
a57 1
	myuid = getuid();
@


1.2
log
@allow commands to respect the -l flag, if the -l flag is
specified certain commands will not recurse into directories.

at the same time introduce a method of specifying wether or not
a command should look in the repository for files.
@
text
@d1 1
a1 1
/*	$OpenBSD: repository.c,v 1.1 2006/05/27 03:30:31 joris Exp $	*/
d82 1
a82 1
			fatal("cvs_repostitory_lock: %s: %s",
@


1.1
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
a92 1
	struct cvs_flisthead *fl, struct cvs_flisthead *dl)
d110 3
@

