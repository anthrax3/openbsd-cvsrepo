head	1.48;
access;
symbols
	OPENBSD_6_1:1.48.0.10
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.8
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.4
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.18
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.47.0.16
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.47.0.12
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.47.0.10
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.47.0.8
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.6
	OPENBSD_5_0:1.47.0.4
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.46.0.8
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.46.0.4
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.46.0.6
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	Uu5nFG3wCl0LACBb;

1.47
date	2010.10.23.18.36.35;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.21.12.52.47;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.20.23.00.13;	author tobias;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.05.19.28.23;	author gilles;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.10.19.11.08;	author joris;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.10.14.06.14;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.02.12.13.00;	author tobias;	state Exp;
branches;
next	1.40;

1.40
date	2007.08.30.11.19.29;	author joris;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.11.11.29.26;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.11.06.32.02;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.02.15.50.10;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.07.17.54.42;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.18.22.52.23;	author niallo;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.27.03.30.31;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.05.01.38.56;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.25.13.31.45;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.25.08.15.05;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.20.16.55.21;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.11.14.16.48;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.10.16.01.27;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.10.14.49.20;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.09.10.33.46;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.20.19.40.27;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.20.19.37.39;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.16.19.05.02;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.17.16.09.03;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.28.21.58.42;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.06.21.03.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.31.11.54.35;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.27.15.40.44;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.02.22.45.57;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.30.01.49.24;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.28.02.15.10;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.28.01.59.19;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.27.16.35.48;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.27.12.18.02;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.14.04.24.46;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.04.12.43;	author vincent;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: root.c,v 1.47 2010/10/23 18:36:35 nicm Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "cvs.h"

extern char *cvs_rootstr;

/* keep these ordered with the defines */
const char *cvs_methods[] = {
	"",
	"local",
	"ssh",
	"pserver",
	"kserver",
	"gserver",
	"ext",
	"fork",
};

#define CVS_NBMETHODS	(sizeof(cvs_methods)/sizeof(cvs_methods[0]))

/*
 * cvsroot_parse()
 *
 * Parse a CVS root string (as found in CVS/Root files or the CVSROOT
 * environment variable) and store the fields in a dynamically
 * allocated cvs_root structure.  The format of the string is as follows:
 *	[:method:][[user[:pass]@@]host[:port]:]path
 * Returns a pointer to the allocated information on success, or NULL
 * on failure.
 */
static struct cvsroot *
cvsroot_parse(const char *str)
{
	u_int i;
	char *cp, *sp, *pp;
	const char *errstr;
	static struct cvsroot *root = NULL;

	if (root != NULL)
		return (root);

	root = xcalloc(1, sizeof(*root));
	root->cr_method = CVS_METHOD_NONE;
	root->cr_str = xstrdup(str);
	root->cr_buf = xstrdup(str);

	sp = root->cr_buf;
	cp = root->cr_buf;
	if (*sp == ':') {
		sp++;
		if ((cp = strchr(sp, ':')) == NULL)
			fatal("failed to parse CVSROOT: unterminated method");

		*(cp++) = '\0';

		for (i = 0; i < CVS_NBMETHODS; i++) {
			if (strcmp(sp, cvs_methods[i]) == 0) {
				root->cr_method = i;
				break;
			}
		}
		if (i == CVS_NBMETHODS)
			fatal("cvsroot_parse: unknown method `%s'", sp);
	}

	/* find the start of the actual path */
	if ((sp = strchr(cp, '/')) == NULL)
		fatal("no path specification in CVSROOT");

	root->cr_dir = sp;
	STRIP_SLASH(root->cr_dir);
	if (sp == cp) {
		if (root->cr_method == CVS_METHOD_NONE)
			root->cr_method = CVS_METHOD_LOCAL;
		/* stop here, it's just a path */
		return (root);
	}

	if (*(sp - 1) != ':')
		fatal("missing host/path delimiter in CVSROOT");

	*(sp - 1) = '\0';

	/*
	 * looks like we have more than just a directory path, so
	 * attempt to split it into user and host parts
	 */
	sp = strchr(cp, '@@');
	if (sp != NULL) {
		*(sp++) = '\0';

		/* password ? */
		pp = strchr(cp, ':');
		if (pp != NULL) {
			*(pp++) = '\0';
			root->cr_pass = pp;
		}

		root->cr_user = cp;
	} else
		sp = cp;

	pp = strchr(sp, ':');
	if (pp != NULL) {
		*(pp++) = '\0';
		root->cr_port = strtonum(pp, 1, 65535, &errstr);
		if (errstr != NULL)
			fatal("port specification in CVSROOT is %s", errstr);

	}

	root->cr_host = sp;

	if (root->cr_method == CVS_METHOD_NONE) {
		/* no method found from start of CVSROOT, guess */
		if (root->cr_host != NULL)
			root->cr_method = CVS_METHOD_SERVER;
		else
			root->cr_method = CVS_METHOD_LOCAL;
	}

	return (root);
}

/*
 * cvsroot_get()
 *
 * Get the CVSROOT information for a specific directory <dir>.  The
 * value is taken from one of 3 possible sources (in order of precedence):
 *
 * 1) the `-d' command-line option
 * 2) the CVS/Root file found in checked-out trees
 * 3) the CVSROOT environment variable
 */
struct cvsroot *
cvsroot_get(const char *dir)
{
	char rootpath[PATH_MAX], *rootstr, line[128];
	FILE *fp;

	if (cvs_rootstr != NULL)
		return cvsroot_parse(cvs_rootstr);

	if (cvs_server_active == 1)
		return cvsroot_parse(dir);

	if (cvs_cmdop == CVS_OP_IMPORT) {
		if ((rootstr = getenv("CVSROOT")) != NULL)
			return (cvsroot_parse(rootstr));
		return (NULL);
	}

	(void)xsnprintf(rootpath, PATH_MAX, "%s/%s", dir, CVS_PATH_ROOTSPEC);

	if ((fp = fopen(rootpath, "r")) == NULL) {
		if (errno == ENOENT) {
			/* try env as a last resort */
			if ((rootstr = getenv("CVSROOT")) != NULL)
				return cvsroot_parse(rootstr);
			else
				return (NULL);
		} else {
			fatal("cvsroot_get: fopen: `%s': %s",
			    CVS_PATH_ROOTSPEC, strerror(errno));
		}
	}

	if (fgets(line, (int)sizeof(line), fp) == NULL)
		fatal("cvsroot_get: fgets: `%s'", CVS_PATH_ROOTSPEC);

	(void)fclose(fp);

	line[strcspn(line, "\n")] = '\0';
	if (line[0] == '\0')
		cvs_log(LP_ERR, "empty %s file", CVS_PATH_ROOTSPEC);

	return cvsroot_parse(line);
}
@


1.47
log
@Use CVSROOT for "cvs import" - just ignore CVS/Root files. PR 6497 from
Michael W Bombardieri.

ok tobias stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.46 2009/02/21 12:52:47 joris Exp $	*/
d166 1
a166 1
	char rootpath[MAXPATHLEN], *rootstr, line[128];
d181 1
a181 1
	(void)xsnprintf(rootpath, MAXPATHLEN, "%s/%s", dir, CVS_PATH_ROOTSPEC);
@


1.46
log
@cleanup of CVSROOT, we have no need for cr_flags,
cr_version or cr_vrmask[] its all very old stuff.

remove all macros using cr_vrmask as well, no use for them.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.45 2008/06/20 23:00:13 tobias Exp $	*/
d175 5
a179 2
	if (cvs_cmdop == CVS_OP_IMPORT)
		return NULL;
@


1.45
log
@Don't parse CVS/Root during import.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.44 2007/10/05 19:28:23 gilles Exp $	*/
a71 2
	CVS_RSTVR(root);

@


1.44
log
@strcspn() change

was okay'd by pyr@@ and ok by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.43 2007/09/10 19:11:08 joris Exp $	*/
d176 3
@


1.43
log
@remove my addition of portnumber for rsh in CVSROOT.
while it sounds like a "good" idea some people convinced me otherwise.

mostly because this breaks compat with GNU cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.42 2007/09/10 14:06:14 joris Exp $	*/
a167 1
	size_t len;
d197 2
a198 2
	len = strlen(line);
	if (len == 0)
a199 2
	else if (line[len - 1] == '\n')
		line[--len] = '\0';
@


1.42
log
@Allow port specification in our CVSROOT which is used for our
ssh connection to our server.

Example: joris@@somehost.com:2222:/cvs

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.41 2007/09/02 12:13:00 tobias Exp $	*/
d136 1
a136 2

		i = strtonum(pp, 1, 65535, &errstr);
a139 1
		root->cr_port = pp;
@


1.41
log
@Stick at GNU cvs behaviour with Root directive handling: it does not need
to be sent first, can occure multiple times (although this is ignored) but
should be supplied before Directory.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.40 2007/08/30 11:19:29 joris Exp $	*/
d136 2
a137 1
		root->cr_port = strtonum(pp, 1, 65535, &errstr);
d141 1
@


1.40
log
@Remove old CVSROOT caching mechanisms.
from Tobias Stoeckmann
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.39 2007/05/11 11:29:26 xsa Exp $	*/
d174 3
@


1.39
log
@typo in previous commit;
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.38 2007/05/11 06:32:02 xsa Exp $	*/
a49 12
 * CVSROOT cache
 *
 * Whenever cvsroot_parse() gets called for a specific string, it first
 * checks in the cache to see if there is already a parsed version of the
 * same string and returns a pointer to it in case one is found (it also
 * increases the reference count).  Otherwise, it does the parsing and adds
 * the result to the cache for future hits.
 */
static TAILQ_HEAD(, cvsroot) cvs_rcache = TAILQ_HEAD_INITIALIZER(cvs_rcache);
static void cvsroot_free(struct cvsroot *);

/*
d59 1
a59 1
struct cvsroot *
d65 1
a65 1
	struct cvsroot *root;
d67 2
a68 12
	/*
	 * Look if we have it in cache, if we found it add it to the cache
	 * at the first position again.
	 */
	TAILQ_FOREACH(root, &cvs_rcache, root_cache) {
		if (root->cr_str != NULL && strcmp(str, root->cr_str) == 0) {
			TAILQ_REMOVE(&cvs_rcache, root, root_cache);
			TAILQ_INSERT_HEAD(&cvs_rcache, root, root_cache);
			root->cr_ref++;
			return (root);
		}
	}
a70 1
	root->cr_ref = 1;
a105 1
		TAILQ_INSERT_HEAD(&cvs_rcache, root, root_cache);
a151 2
	/* add to the cache */
	TAILQ_INSERT_HEAD(&cvs_rcache, root, root_cache);
a152 33
}

/*
 * cvsroot_remove()
 *
 * Remove a CVSROOT structure from the cache, and free it.
 */
void
cvsroot_remove(struct cvsroot *root)
{
	root->cr_ref--;
	if (root->cr_ref == 0) {
		TAILQ_REMOVE(&cvs_rcache, root, root_cache);
		cvsroot_free(root);
	}
}

/*
 * cvsroot_free()
 *
 * Free a CVSROOT structure previously allocated and returned by
 * cvsroot_parse().
 */
static void
cvsroot_free(struct cvsroot *root)
{
	if (root->cr_str != NULL)
		xfree(root->cr_str);
	if (root->cr_buf != NULL)
		xfree(root->cr_buf);
	if (root->cr_version != NULL)
		xfree(root->cr_version);
	xfree(root);
@


1.38
log
@fix format of the CVSROOT string in comments.
from Tobias Stoeckmann. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.37 2007/05/02 15:50:10 xsa Exp $	*/
d67 1
a67 1
 *	[:method:][[user[:pass]@@]host[:port]]:path
@


1.37
log
@strtol() -> strtonum(); from Tobias Stoeckmann.
OK ray@@ otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.36 2007/02/22 06:42:09 otto Exp $	*/
d67 1
a67 1
 *	:method:[[user[:pass]@@host]:path
@


1.36
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.35 2007/02/07 17:54:42 xsa Exp $	*/
d76 1
d160 3
a162 3
		root->cr_port = (u_int)strtol(pp, &cp, 10);
		if ((*cp != '\0') || (root->cr_port > 65535))
			fatal("invalid port specification in CVSROOT");
@


1.35
log
@strl* overload; use xsnprintf(); OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.34 2007/01/18 22:52:23 niallo Exp $	*/
d27 3
a29 1
#include "includes.h"
a31 1
#include "log.h"
@


1.34
log
@extra safety check for NULL value.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.33 2006/06/16 14:07:42 joris Exp $	*/
d232 1
a232 7
	if (strlcpy(rootpath, dir, sizeof(rootpath)) >= sizeof(rootpath) ||
	    strlcat(rootpath, "/", sizeof(rootpath)) >= sizeof(rootpath) ||
	    strlcat(rootpath, CVS_PATH_ROOTSPEC,
	    sizeof(rootpath)) >= sizeof(rootpath)) {
		errno = ENAMETOOLONG;
		fatal("cvsroot_get: %s: %s", rootpath, strerror(errno));
	}
@


1.33
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.32 2006/05/27 03:30:31 joris Exp $	*/
d82 1
a82 1
		if (strcmp(str, root->cr_str) == 0) {
@


1.32
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.31 2006/04/05 01:38:56 ray Exp $	*/
a30 1
#include "proto.h"
a93 4

	/* enable the most basic commands at least */
	CVS_SETVR(root, CVS_REQ_VALIDREQ);
	CVS_SETVR(root, CVS_REQ_VALIDRESP);
@


1.31
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.30 2006/01/25 13:31:45 xsa Exp $	*/
a32 1

a34 1

d127 1
d251 1
a251 1
				fatal("cvsroot_get: empty CVSROOT variable");
d265 1
a265 1
		cvs_log(LP_WARN, "empty %s file", CVS_PATH_ROOTSPEC);
@


1.30
log
@this snprintf() occurence should have been removed in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.29 2006/01/25 08:15:05 xsa Exp $	*/
d93 1
a93 2
	root = (struct cvsroot *)xmalloc(sizeof(*root));
	memset(root, 0, sizeof(*root));
@


1.29
log
@snprintf() cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.28 2006/01/02 08:11:56 xsa Exp $	*/
a231 1
	int l;
a238 1
	l = snprintf(rootpath, sizeof(rootpath), "%s/" CVS_PATH_ROOTSPEC, dir);
@


1.28
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.27 2005/12/20 16:55:21 xsa Exp $	*/
d241 4
a244 1
	if (l == -1 || l >= (int)sizeof(rootpath)) {
@


1.27
log
@use fatal(); OK joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.26 2005/12/10 20:27:45 joris Exp $	*/
d27 1
a27 9
#include <sys/types.h>

#include <err.h>
#include <errno.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.26
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.25 2005/09/11 14:16:48 joris Exp $	*/
d118 3
a120 7
		cp = strchr(sp, ':');
		if (cp == NULL) {
			cvs_log(LP_ERR, "failed to parse CVSROOT: "
			    "unterminated method");
			cvsroot_free(root);
			return (NULL);
		}
d129 2
a130 5
		if (i == CVS_NBMETHODS) {
			cvs_log(LP_ERR, "unknown method `%s'", sp);
			cvsroot_free(root);
			return (NULL);
		}
d134 2
a135 6
	sp = strchr(cp, '/');
	if (sp == NULL) {
		cvs_log(LP_ERR, "no path specification in CVSROOT");
		cvsroot_free(root);
		return (NULL);
	}
d146 3
a148 5
	if (*(sp - 1) != ':') {
		cvs_log(LP_ERR, "missing host/path delimiter in CVS root");
		cvsroot_free(root);
		return (NULL);
	}
d174 2
a175 6
		if (*cp != '\0' || root->cr_port > 65535) {
			cvs_log(LP_ERR,
			    "invalid port specification in CVSROOT");
			cvsroot_free(root);
			return (NULL);
		}
d251 1
a251 2
		cvs_log(LP_ERRNO, "%s", rootpath);
		return (NULL);
d254 1
a254 2
	fp = fopen(rootpath, "r");
	if (fp == NULL) {
d260 1
a260 1
				return (NULL);
d262 2
a263 3
			cvs_log(LP_ERRNO, "failed to open %s",
			    CVS_PATH_ROOTSPEC);
			return (NULL);
d267 3
a269 6
	if (fgets(line, (int)sizeof(line), fp) == NULL) {
		cvs_log(LP_ERR, "failed to read line from %s",
		    CVS_PATH_ROOTSPEC);
		(void)fclose(fp);
		return (NULL);
	}
@


1.25
log
@only remove and free a cvsroot struct if it has been added in
cvsroot_parse().

fixes segfaults opencvs has been receiving when cvsroot_parse() fails.
"go ahead" xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.24 2005/08/10 16:01:27 joris Exp $	*/
d101 1
a101 5
	root = (struct cvsroot *)malloc(sizeof(*root));
	if (root == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate CVS root data");
		return (NULL);
	}
d111 2
a112 11
	root->cr_str = strdup(str);
	if (root->cr_str == NULL) {
		free(root);
		return (NULL);
	}
	root->cr_buf = strdup(str);
	if (root->cr_buf == NULL) {
		cvs_log(LP_ERRNO, "failed to copy CVS root");
		cvsroot_free(root);
		return (NULL);
	}
d236 1
a236 1
		free(root->cr_str);
d238 1
a238 1
		free(root->cr_buf);
d240 2
a241 2
		free(root->cr_version);
	free(root);
@


1.24
log
@do not forget to also add the local roots to the cache.
fixes a segfault in localmode.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.23 2005/08/10 14:49:20 xsa Exp $	*/
d69 1
a223 1

d225 1
a225 1
 * cvsroot_free()
d227 1
a227 2
 * Free a CVSROOT structure previously allocated and returned by
 * cvsroot_parse().
d230 1
a230 1
cvsroot_free(struct cvsroot *root)
d235 1
a235 7
		if (root->cr_str != NULL)
			free(root->cr_str);
		if (root->cr_buf != NULL)
			free(root->cr_buf);
		if (root->cr_version != NULL)
			free(root->cr_version);
		free(root);
d239 17
@


1.23
log
@fgets() expects the 2nd arg to be an int. OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.22 2005/08/09 10:33:46 joris Exp $	*/
d165 1
@


1.22
log
@fix our root caching method, it was utterly broken and would
cause opencvs to segfault in several cases.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.21 2005/07/25 12:13:08 xsa Exp $	*/
d289 1
a289 1
	if (fgets(line, sizeof(line), fp) == NULL) {
@


1.21
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.20 2005/07/25 12:05:43 xsa Exp $	*/
d68 1
a68 5

static struct cvsroot **cvs_rcache = NULL;
static u_int cvs_rcsz = 0;


a84 1
	void *tmp;
d87 10
a96 4
	for (i = 0; i < cvs_rcsz; i++) {
		if (strcmp(str, cvs_rcache[i]->cr_str) == 0) {
			cvs_rcache[i]->cr_ref++;
			return (cvs_rcache[i]);
d218 1
a218 7
	tmp = realloc(cvs_rcache, (cvs_rcsz + 1) * sizeof(struct cvsroot *));
	if (tmp != NULL) {
		cvs_rcache = (struct cvsroot **)tmp;
		cvs_rcache[cvs_rcsz++] = root;
		root->cr_ref++;
	}

d234 1
@


1.20
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.19 2005/05/31 08:58:48 xsa Exp $	*/
d84 1
a84 1
struct cvsroot*
d260 1
a260 1
struct cvsroot*
@


1.19
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.18 2005/05/20 19:40:27 jfb Exp $	*/
d57 1
a57 1
#define CVS_NBMETHODS  (sizeof(cvs_methods)/sizeof(cvs_methods[0]))
@


1.18
log
@simplify error message
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.17 2005/05/20 19:37:39 xsa Exp $	*/
a28 3
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
d31 3
d35 1
a35 1
#include <paths.h>
@


1.17
log
@do not hardcode 'CVS/Root' but rather use defined CVS_PATH_ROOTSPEC;
ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.16 2005/04/16 19:05:02 xsa Exp $	*/
d294 1
a294 1
		cvs_log(LP_ERR, "failed to read CVSROOT line from %s",
@


1.16
log
@snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.15 2005/02/17 16:09:03 jfb Exp $	*/
d287 2
a288 1
			cvs_log(LP_ERRNO, "failed to open CVS/Root");
d294 2
a295 1
		cvs_log(LP_ERR, "failed to read CVSROOT line from CVS/Root");
d303 1
a303 1
		cvs_log(LP_WARN, "empty CVS/Root file");
@


1.15
log
@only increase the reference count on the cvsroot structure when it
gets inserted into the cache.  This makes cvsroot_free() work
correctly instead of leaking memory in error cases of cvsroot_parse()

spotted by and ok pat@@
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.14 2004/12/28 21:58:42 jfb Exp $	*/
d263 1
d271 7
a277 1
	snprintf(rootpath, sizeof(rootpath), "%s/" CVS_PATH_ROOTSPEC, dir);
@


1.14
log
@abort with an error if we can't figure out what the connection
method is
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.13 2004/12/07 17:10:56 tedu Exp $	*/
d105 1
a105 1
	root->cr_ref = 2;
d218 1
a218 4
	if (tmp == NULL) {
		/* just forget about the cache and return anyways */
		root->cr_ref--;
	} else {
d221 1
@


1.13
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.12 2004/12/06 21:03:13 deraadt Exp $	*/
d143 5
@


1.12
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: root.c,v 1.11 2004/08/31 11:54:35 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a83 1

a230 1

a256 1

d290 1
a290 1
	if (len == 0) {
d292 1
a292 1
	} else if (line[len - 1] == '\n')
@


1.11
log
@Do not crash when there is no user specified in the CVSROOT.  Simplified
version of a diff by Joris Vink.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d186 1
a186 2
	}
	else
d217 1
a217 2
	}
	else {
d279 1
a279 2
		}
		else {
d295 1
a295 2
	}
	else if (line[len - 1] == '\n')
@


1.10
log
@cleanup and reset the valid requests array when allocating a new root
structure.  Also enable the use of at least Valid-responses and
valid-requests
@
text
@d187 2
@


1.9
log
@When we connect to a remote server, always send the Version request and
add a hack so we don't print it (we receive it through a 'M') but store
it in the cvs root structure instead.  This will allow us to make better
decisions in what we use to communicate with the remote server.
@
text
@d39 1
d108 5
@


1.8
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d236 2
@


1.7
log
@Remove a debugging message
@
text
@a257 1
	struct cvsroot *rp;
@


1.6
log
@Add a small cache for parsed CVSROOT strings and return a pointer to a
previously cached entry when we encounter the same string more than once.
@
text
@a93 1
			printf("hitting cache for `%s'\n", str);
@


1.5
log
@Be less retarded when parsing the contents of a CVS/Root file
@
text
@d57 14
a70 1
 
d79 1
a79 1
 *	:method:path
d89 1
d92 8
d106 1
a106 1

d109 5
d117 1
a117 1
		free(root);
a122 1

d129 1
a129 2
			free(root->cr_buf);
			free(root);
d146 1
a146 2
		free(root->cr_buf);
		free(root);
d160 1
a160 1
		free(root);
d190 1
a190 1
			free(root);
d206 11
d231 8
a238 2
	free(root->cr_buf);
	free(root);
@


1.4
log
@Zero out the cvs root structure before assigning the fields, otherwise
we can end up with pretty strange results
@
text
@d216 1
a216 1
	char rootpath[MAXPATHLEN], *rootstr, *line;
d239 1
a239 2
	line = fgetln(fp, &len);
	if (line == NULL) {
d242 1
d244 1
d246 3
a248 9
	/* line is not NUL-terminated, but we don't need to allocate an
	 * extra byte because we don't want the trailing newline.  It will
	 * get replaced by a \0.
	 */
	rootstr = (char *)malloc(len);
	if (rootstr == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate CVSROOT string");
		(void)fclose(fp);
		return (NULL);
d250 2
a251 6
	memcpy(rootstr, line, len - 1);
	rootstr[len - 1] = '\0';
	rp = cvsroot_parse(rootstr);

	(void)fclose(fp);
	free(rootstr);
d253 1
a253 1
	return (rp);
@


1.3
log
@get rid of the newline when copying the root string
@
text
@d83 1
@


1.2
log
@/* line is not NUL-terminated */

so don't strlcpy!
@
text
@d254 2
a255 2
	memcpy(rootstr, line, len);
	rootstr[len] = '\0';
@


1.1
log
@Initial revision
@
text
@d254 2
a255 1
	strlcpy(rootstr, line, len);
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
