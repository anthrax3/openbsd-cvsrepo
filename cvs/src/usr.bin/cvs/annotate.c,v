head	1.69;
access;
symbols
	OPENBSD_6_2_BASE:1.69
	OPENBSD_6_1:1.67.0.4
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.65.0.4
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.64.0.6
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.63.0.14
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.63.0.12
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.63.0.8
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.63.0.6
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.63.0.4
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.2
	OPENBSD_5_0:1.62.0.6
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.62.0.4
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.60.0.6
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.60.0.8
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.60.0.4
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.60.0.2
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.37.0.4
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.69
date	2017.06.01.08.08.24;	author joris;	state Exp;
branches;
next	1.68;
commitid	oZyV6E3g0wglnhaw;

1.68
date	2017.05.31.16.14.37;	author joris;	state Exp;
branches;
next	1.67;
commitid	vk1DLnipFVMYHrRc;

1.67
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.66;
commitid	8Vv7d4HkmCtExfc6;

1.66
date	2016.10.12.11.11.56;	author fcambus;	state Exp;
branches;
next	1.65;
commitid	xjULXnphIXKHGTiG;

1.65
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.64;
commitid	O6jeJ0TRmiewrqMI;

1.64
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	Uu5nFG3wCl0LACBb;

1.63
date	2011.12.27.13.59.01;	author nicm;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.30.21.47.18;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.14.03.58.29;	author tobias;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.09.16.34.22;	author tobias;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.02.19.14.10;	author tobias;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.02.19.05.34;	author tobias;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.10.10.21.42;	author joris;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.09.16.05.08;	author tobias;	state Exp;
branches;
next	1.53;

1.53
date	2008.02.09.14.34.40;	author tobias;	state Exp;
branches;
next	1.52;

1.52
date	2008.02.04.21.25.32;	author tobias;	state Exp;
branches;
next	1.51;

1.51
date	2008.02.04.19.12.31;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2008.02.03.16.59.11;	author tobias;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.02.16.59.48;	author tobias;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.02.16.44.11;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.01.17.18.59;	author tobias;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.01.13.36.43;	author tobias;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.43;

1.43
date	2007.10.09.12.59.53;	author tobias;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.09.12.25.27;	author tobias;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.09.12.24.13;	author tobias;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.09.12.22.27;	author tobias;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.13.13.10.57;	author tobias;	state Exp;
branches;
next	1.37;

1.37
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.13.20.59.49;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.11.17.44.18;	author niallo;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.27.16.02.52;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.15.16.18.38;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.27.03.30.30;	author joris;	state dead;
branches;
next	1.29;

1.29
date	2006.01.30.17.58.47;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.27.15.26.38;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.30.16.42.13;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.22.14.59.54;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.21.11.42.24;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.14.06.54.59;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.11.18.05.09;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.04.10.21.03;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.30.08.27.03;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.29.00.52.08;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.20.18.32.23;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.18.21.02.49;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.13.20.05.37;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.13.16.32.46;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.21.18.32.09;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.14.22.30.47;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.09.20.03.26;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Stop looking at current_cvsroot->cr_method to figure out if we're remote or not.

Instead use cvsroot_is_local() and cvsroot_is_remote().
@
text
@/*	$OpenBSD: annotate.c,v 1.68 2017/05/31 16:14:37 joris Exp $	*/
/*
 * Copyright (c) 2007 Tobias Stoeckmann <tobias@@openbsd.org>
 * Copyright (c) 2006 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/dirent.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

void	cvs_annotate_local(struct cvs_file *);

extern char	*cvs_specified_tag;

static int	 force_head = 0;

struct cvs_cmd cvs_cmd_annotate = {
	CVS_OP_ANNOTATE, CVS_USE_WDIR, "annotate",
	{ "ann", "blame" },
	"Show last revision where each line was modified",
	"[-flR] [-D date | -r rev] [file ...]",
	"D:flRr:",
	NULL,
	cvs_annotate
};

struct cvs_cmd cvs_cmd_rannotate = {
	CVS_OP_RANNOTATE, 0, "rannotate",
	{ "rann", "ra" },
	"Show last revision where each line was modified",
	"[-flR] [-D date | -r rev] module ...",
	"D:flRr:",
	NULL,
	cvs_annotate
};

int
cvs_annotate(int argc, char **argv)
{
	int ch, flags;
	char *arg = ".";
	char *dateflag = NULL;
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;

	while ((ch = getopt(argc, argv, cvs_cmdop == CVS_OP_ANNOTATE ?
	    cvs_cmd_annotate.cmd_opts : cvs_cmd_rannotate.cmd_opts)) != -1) {
		switch (ch) {
		case 'D':
			dateflag = optarg;
			if ((cvs_specified_date = date_parse(dateflag)) == -1)
				fatal("invalid date: %s", dateflag);
			break;
		case 'f':
			force_head = 1;
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		case 'r':
			cvs_specified_tag = optarg;
			break;
		default:
			fatal("%s", cvs_cmdop == CVS_OP_ANNOTATE ?
			    cvs_cmd_annotate.cmd_synopsis :
			    cvs_cmd_rannotate.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (cvs_cmdop == CVS_OP_RANNOTATE) {
		if (argc == 0)
			fatal("%s", cvs_cmd_rannotate.cmd_synopsis);

		flags |= CR_REPO;
	}

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (cvsroot_is_remote()) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (dateflag != NULL)
			cvs_client_send_request("Argument -D%s", dateflag);

		if (force_head == 1)
			cvs_client_send_request("Argument -f");

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");

		if (cvs_specified_tag != NULL)
			cvs_client_send_request("Argument -r%s",
			    cvs_specified_tag);
	} else {
		if (cvs_cmdop == CVS_OP_RANNOTATE &&
		    chdir(current_cvsroot->cr_dir) == -1)
			fatal("cvs_annotate: %s", strerror(errno));

		cr.fileproc = cvs_annotate_local;
	}

	cr.flags = flags;

	if (cvs_cmdop == CVS_OP_ANNOTATE || cvsroot_is_local()) {
		if (argc > 0)
			cvs_file_run(argc, argv, &cr);
		else
			cvs_file_run(1, &arg, &cr);
	}

	if (cvsroot_is_remote()) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");

		cvs_client_send_request((cvs_cmdop == CVS_OP_RANNOTATE) ?
		    "rannotate" : "annotate");

		cvs_client_get_responses();
	}

	return (0);
}

void
cvs_annotate_local(struct cvs_file *cf)
{
	int i;
	u_char *p;
	char date[10], rnum[13];
	RCSNUM *bnum, *rev;
	struct rcs_line *line;
	struct rcs_line **alines;

	cvs_log(LP_TRACE, "cvs_annotate_local(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_rcs == NULL || cf->file_rcs->rf_head == NULL)
		return;

	if (cvs_specified_tag != NULL) {
		if ((rev = rcs_translate_tag(cvs_specified_tag,
		    cf->file_rcs)) == NULL) {
			if (!force_head)
				/* Stick at weird GNU cvs, ignore error. */
				return;

			/* -f is not allowed for unknown symbols */
			rev = rcsnum_parse(cvs_specified_tag);
			if (rev == NULL)
				fatal("no such tag %s", cvs_specified_tag);
			free(rev);
			rev = rcsnum_alloc();
			rcsnum_cpy(cf->file_rcs->rf_head, rev, 0);
		}

		/*
		 * If this is a revision in a branch, we have to go first
		 * from HEAD to branch, then down to 1.1. After that, take
		 * annotated branch and go up to branch revision. This must
		 * be done this way due to different handling of "a" and
		 * "d" in rcs file for annotation.
		 */
		if (!RCSNUM_ISBRANCHREV(rev)) {
			bnum = rev;
		} else {
			bnum = rcsnum_alloc();
			rcsnum_cpy(rev, bnum, 2);
		}

		rcs_rev_getlines(cf->file_rcs, bnum, &alines);

		/*
		 * Go into branch and receive annotations for branch revision,
		 * with inverted "a" and "d" meaning.
		 */
		if (bnum != rev) {
			rcs_annotate_getlines(cf->file_rcs, rev, &alines);
			free(bnum);
		}
		free(rev);
	} else {
		rcs_rev_getlines(cf->file_rcs, (cvs_specified_date != -1 ||
		    cvs_directory_date != -1) ? cf->file_rcsrev :
		    cf->file_rcs->rf_head, &alines);
	}

	/* Stick at weird GNU cvs, ignore error. */
	if (alines == NULL)
		return;

	cvs_log(LP_RCS, "Annotations for %s", cf->file_path);
	cvs_log(LP_RCS, "***************");

	for (i = 0; alines[i] != NULL; i++) {
		line = alines[i];

		rcsnum_tostr(line->l_delta->rd_num, rnum, sizeof(rnum));
		strftime(date, sizeof(date), "%d-%b-%y",
		    &(line->l_delta->rd_date));
		if (line->l_len && line->l_line[line->l_len - 1] == '\n')
			line->l_line[line->l_len - 1] = '\0';
		else {
			p = xmalloc(line->l_len + 1);
			memcpy(p, line->l_line, line->l_len);
			p[line->l_len] = '\0';

			if (line->l_needsfree)
				free(line->l_line);
			line->l_line = p;
			line->l_len++;
			line->l_needsfree = 1;
		}
		cvs_printf("%-12.12s (%-8.8s %s): %s\n", rnum,
		    line->l_delta->rd_author, date, line->l_line);

		if (line->l_needsfree)
			free(line->l_line);
		free(line);
	}

	free(alines);
}
@


1.68
log
@fix indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.67 2016/10/13 20:51:25 fcambus Exp $	*/
d107 1
a107 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
d133 1
a133 2
	if (cvs_cmdop == CVS_OP_ANNOTATE ||
	    current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
d140 1
a140 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
@


1.67
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.66 2016/10/12 11:11:56 fcambus Exp $	*/
d182 1
a182 1
                        free(rev);
@


1.66
log
@Use the correct type for p. From Joris Vink.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.65 2015/11/05 09:48:21 nicm Exp $	*/
d182 1
a182 1
                        rcsnum_free(rev);
d209 1
a209 1
			rcsnum_free(bnum);
d211 1
a211 1
		rcsnum_free(rev);
@


1.65
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.64 2015/01/16 06:40:06 deraadt Exp $	*/
d158 2
a159 1
	char date[10], rnum[13], *p;
@


1.64
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.63 2011/12/27 13:59:01 nicm Exp $	*/
d238 1
a238 1
				xfree(line->l_line);
d247 2
a248 2
			xfree(line->l_line);
		xfree(line);
d251 1
a251 1
	xfree(alines);
@


1.63
log
@Move some global variables/statics to locals, from Michael W
Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.62 2010/07/30 21:47:18 ray Exp $	*/
d19 1
a19 1
#include <sys/param.h>
@


1.62
log
@Check date_parse return values.

OK xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.61 2010/07/23 21:46:05 ray Exp $	*/
a34 1
static char	*dateflag;
d62 1
@


1.61
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.60 2008/06/14 04:34:08 tobias Exp $	*/
d72 2
a73 1
			cvs_specified_date = date_parse(dateflag);
@


1.60
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.59 2008/06/14 03:58:29 tobias Exp $	*/
d72 1
a72 1
			cvs_specified_date = cvs_date_parse(dateflag);
d159 2
a160 2
	struct cvs_line *line;
	struct cvs_line **alines;
@


1.59
log
@Added support for sticky date set in CVS/Tag and CVS/Entries per directory.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.58 2008/06/09 16:34:22 tobias Exp $	*/
d166 1
a166 1
	if (cf->file_rcs == NULL)
@


1.58
log
@Check if RCS file exists before trying to retrieve revisions for annotate,
fixes segmentation fault on added but not yet committed files for example.

Based on diff by Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.57 2008/03/02 19:14:10 tobias Exp $	*/
d211 3
a213 2
		rcs_rev_getlines(cf->file_rcs, (cvs_specified_date != -1) ?
		    cf->file_rcsrev : cf->file_rcs->rf_head, &alines);
@


1.57
log
@rannotate needs at least one module as argument.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.56 2008/03/02 19:05:34 tobias Exp $	*/
d166 1
a166 2
	if (cf->file_status == FILE_UNKNOWN || cf->file_status == FILE_UNLINK ||
	    cf->file_type != CVS_FILE)
@


1.56
log
@Print the right synopsis for commands on error (especially if commands
share the same function: (r)tag, etc.).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.55 2008/02/10 10:21:42 joris Exp $	*/
d96 4
a99 1
	if (cvs_cmdop == CVS_OP_RANNOTATE)
d101 1
@


1.55
log
@properly initialize cvs_specified_date so we dont end up with
random stuff going on
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.54 2008/02/09 16:05:08 tobias Exp $	*/
d87 3
a89 1
			fatal("%s", cvs_cmd_annotate.cmd_synopsis);
@


1.54
log
@If no revision or date has been specified, default to HEAD.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.53 2008/02/09 14:34:40 tobias Exp $	*/
d206 1
a206 1
		rcs_rev_getlines(cf->file_rcs, cvs_specified_date ?
@


1.53
log
@Get date support into annotate, too.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.52 2008/02/04 21:25:32 tobias Exp $	*/
d206 2
a207 1
		rcs_rev_getlines(cf->file_rcs, cf->file_rcsrev, &alines);
@


1.52
log
@r* commands have their own usage; don't check usage of their working dir
equivalents.

OK joris@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.51 2008/02/04 19:12:31 joris Exp $	*/
d35 1
d71 2
d104 3
d206 1
a206 1
		rcs_rev_getlines(cf->file_rcs, cf->file_rcs->rf_head, &alines);
@


1.51
log
@trailing space police;
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.50 2008/02/03 16:59:11 tobias Exp $	*/
d66 2
a67 1
	while ((ch = getopt(argc, argv, cvs_cmd_annotate.cmd_opts)) != -1) {
@


1.50
log
@Do not unify this "-fr UNKNOWN" handling, it breaks commands which have
to work fine and just ignore files which don't have requested symbol.

Spotted by joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.49 2008/02/02 16:59:48 tobias Exp $	*/
d164 4
a167 4
			/* -f is not allowed for unknown symbols */   
			rev = rcsnum_parse(cvs_specified_tag);   
			if (rev == NULL)   
				fatal("no such tag %s", cvs_specified_tag);   
@


1.49
log
@Although this doesn't comply to common sense, it complies to GNU cvs. All
commands which supply -f and -r have this weirdness: an unknown
symbol leads to fatal instead of head revision.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.48 2008/02/02 16:44:11 xsa Exp $	*/
d164 5
@


1.48
log
@Sync `rannotate' synopsis. r* commands work on repository modules.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.47 2008/02/01 17:18:59 tobias Exp $	*/
a163 6
			/* -f is not allowed for unknown symbols */
			rev = rcsnum_parse(cvs_specified_tag);
			if (rev == NULL)
				fatal("no such tag %s", cvs_specified_tag);

			rcsnum_free(rev);
@


1.47
log
@Added rannotate support

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.46 2008/02/01 13:36:43 tobias Exp $	*/
d51 1
a51 1
	"[-flR] [-D date | -r rev] [file ...]",
@


1.46
log
@Another GNU cvs weirdo:  During annotate, invalid revisions are allowed if
-f is supplied (thus switching to HEAD), but unknown symbols end in fatal.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.45 2008/01/31 10:15:05 tobias Exp $	*/
d22 1
d47 10
d90 3
d110 4
d119 7
a125 4
	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);
d130 4
a133 1
		cvs_client_send_request("annotate");
@


1.45
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.44 2008/01/28 20:31:07 tobias Exp $	*/
d140 6
@


1.44
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.43 2007/10/09 12:59:53 tobias Exp $	*/
d37 1
a37 1
	CVS_OP_ANNOTATE, 0, "annotate",
@


1.43
log
@Added proper support for branch revisions in annotate.

OK niallo@@, twice :)
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.42 2007/10/09 12:25:27 tobias Exp $	*/
d66 1
@


1.42
log
@Properly parse supplied symbols with -r argument.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.41 2007/10/09 12:24:13 tobias Exp $	*/
d32 2
d120 1
a120 1
	RCSNUM *rev;
d132 1
a132 3
	if (cvs_specified_tag == NULL)
		rcs_rev_getlines(cf->file_rcs, cf->file_rcs->rf_head, &alines);
	else {
d138 1
d143 23
a165 8
		/* rcs_translate_tag may give back an unavailable revision. */
		if (rcs_findrev(cf->file_rcs, rev) == NULL) {
			if (!force_head) {
				/* Stick at weird GNU cvs, ignore error. */
				rcsnum_free(rev);
				return;
			}
			rcsnum_cpy(cf->file_rcs->rf_head, rev, 0);
a166 1
		rcs_rev_getlines(cf->file_rcs, rev, &alines);
d168 2
@


1.41
log
@Do not use working HEAD (file_rcsrev), instead use file_rcs->rf_head to
print revision info.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.40 2007/10/09 12:22:27 tobias Exp $	*/
d133 8
a140 1
		rev = rcsnum_parse(cvs_specified_tag);
d142 2
a143 1
		if (rcsnum_cmp(rev, cf->file_rcs->rf_head, 0) < 0) {
@


1.40
log
@various style cleanups:

- Copyright order
- rev -> cvs_specified_tag
- crev -> rev
- line instead of alines[i] in for-loop

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.39 2007/09/22 16:01:22 joris Exp $	*/
d131 1
a131 1
		rcs_rev_getlines(cf->file_rcs, cf->file_rcsrev, &alines);
d135 1
a135 1
		if (rcsnum_cmp(rev, cf->file_rcsrev, 0) < 0) {
d141 1
a141 1
			rcsnum_cpy(cf->file_rcsrev, rev, 0);
@


1.39
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.38 2007/09/13 13:10:57 tobias Exp $	*/
d3 1
a4 1
 * Copyright (c) 2007 Tobias Stoeckmann <tobias@@openbsd.org>
a32 1
static char	*rev = NULL;
d66 1
a66 1
			rev = optarg;
d89 3
a91 2
		if (rev != NULL)
			cvs_client_send_request("Argument -r%s", rev);
d118 2
a119 1
	RCSNUM *crev;
d130 1
a130 1
	if (rev == NULL)
d133 1
a133 1
		crev = rcsnum_parse(rev);
d135 1
a135 1
		if (rcsnum_cmp(crev, cf->file_rcsrev, 0) < 0) {
d138 1
a138 1
				rcsnum_free(crev);
d141 1
a141 1
			rcsnum_cpy(cf->file_rcsrev, crev, 0);
d143 2
a144 2
		rcs_rev_getlines(cf->file_rcs, crev, &alines);
		rcsnum_free(crev);
d155 3
a157 1
		rcsnum_tostr(alines[i]->l_delta->rd_num, rnum, sizeof(rnum));
d159 3
a161 4
		    &(alines[i]->l_delta->rd_date));
		if (alines[i]->l_len &&
		    alines[i]->l_line[alines[i]->l_len - 1] == '\n')
			alines[i]->l_line[alines[i]->l_len - 1] = '\0';
d163 9
a171 9
			p = xmalloc(alines[i]->l_len + 1);
			memcpy(p, alines[i]->l_line, alines[i]->l_len);
			p[alines[i]->l_len] = '\0';

			if (alines[i]->l_needsfree)
				xfree(alines[i]->l_line);
			alines[i]->l_line = p;
			alines[i]->l_len++;
			alines[i]->l_needsfree = 1;
d174 1
a174 1
		    alines[i]->l_delta->rd_author, date, alines[i]->l_line);
d176 3
a178 3
		if (alines[i]->l_needsfree)
			xfree(alines[i]->l_line);
		xfree(alines[i]);
@


1.38
log
@Added annotate support for local and remote repositories. Behaves like
GNU cvs but is a little faster.

OK joris@@, ray@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.37 2007/02/22 06:42:09 otto Exp $	*/
d123 1
a123 1
	cvs_file_classify(cf, NULL);
@


1.37
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.36 2007/02/09 03:49:15 joris Exp $	*/
d4 1
d21 4
d116 5
d125 23
a147 2
	if (cf->file_status == FILE_UNKNOWN ||
	    cf->file_status == FILE_UNLINK)
d150 30
a179 3
	cvs_printf("Annotations for %s", cf->file_name);
	cvs_printf("\n***************\n");
	cvs_printf("no code yet\n");
@


1.36
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.35 2007/01/13 20:59:49 joris Exp $	*/
d18 3
a20 1
#include "includes.h"
a22 1
#include "log.h"
@


1.35
log
@nuke the the very evil rcs_getrev() stuff
discussed with niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.34 2007/01/11 17:44:18 niallo Exp $	*/
d112 1
a112 1
	cvs_file_classify(cf, NULL, 0);
@


1.34
log
@rework opencvs so that we can deal with binary files.  previously we assumed all files were ascii,
which broke things in real-world usage.  now a checkout of src should work, albeit using lots of
memory and cpu.  fixing this is the next step.

testing by many.
ok & some input joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.33 2007/01/11 02:35:55 joris Exp $	*/
a109 9
	struct cvs_line *lp;
	struct cvs_lines *lines;
	BUF *b;
	RCSNUM *ann_rev;
	char *content;
	size_t len;

	ann_rev = NULL;

d120 1
a120 29

	if (rev != NULL)
		ann_rev = rcs_translate_tag(rev, cf->file_rcs);
	else {
		ann_rev = rcsnum_alloc();
		rcsnum_cpy(cf->file_rcs->rf_head, ann_rev, 0);
	}

	b = rcs_getrev(cf->file_rcs, ann_rev);
	cvs_buf_putc(b, '\0');

	len = cvs_buf_len(b);
	content = cvs_buf_release(b);
	if ((lines = cvs_splitlines(content, len)) == NULL)
		fatal("cvs_annotate_local: cvs_splitlines failed");

        xfree(content);

	/* XXX */
	TAILQ_FOREACH(lp, &(lines->l_lines), l_list) {
		if (lp->l_line == NULL)
			continue;

		cvs_printf("%s\n", lp->l_line);
	}
        cvs_freelines(lines);

	if (ann_rev != NULL)
		rcsnum_free(ann_rev);
@


1.33
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.32 2006/11/27 16:02:52 xsa Exp $	*/
d115 1
d140 1
d142 1
a142 1
	if ((lines = cvs_splitlines(content)) == NULL)
@


1.32
log
@don't process the file if its status is FILE_UNLINK.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.31 2006/11/15 16:18:38 xsa Exp $	*/
d75 1
@


1.31
log
@Bring back basic annotate command. Needs more work.
Not linked to build yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 2
a122 1
	if (cf->file_status == FILE_UNKNOWN)
d144 1
@


1.30
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.29 2006/01/30 17:58:47 xsa Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d22 3
a24 1
#include "proto.h"
d26 2
a27 4
static int	cvs_annotate_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_annotate_remote(CVSFILE *, void *);
static int	cvs_annotate_local(CVSFILE *, void *);
static int	cvs_annotate_pre_exec(struct cvsroot *);
d30 2
a31 2
	CVS_OP_ANNOTATE, CVS_REQ_ANNOTATE, "annotate",
	{ "ann", "blame"  },
d33 1
a33 1
	"[-flR] [-D date | -r rev] ...",
d36 1
a36 8
	CF_SORT | CF_RECURSE | CF_IGNORE | CF_NOSYMS,
	cvs_annotate_init,
	cvs_annotate_pre_exec,
	cvs_annotate_remote,
	cvs_annotate_local,
	NULL,
	NULL,
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2
d39 2
a40 5
static char *date, *rev;
static int usehead;

static int
cvs_annotate_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d42 3
a44 1
	int ch;
d46 1
a46 3
	usehead = 0;
	date = NULL;
	rev = NULL;
d48 1
a48 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a50 1
			date = optarg;
d53 1
a53 1
			usehead = 1;
d56 1
a56 1
			cmd->file_flags &= ~CF_RECURSE;
a58 1
			cmd->file_flags |= CF_RECURSE;
d64 1
a64 1
			return (CVS_EX_USAGE);
d68 2
a69 15
	*arg = optind;
	return (0);
}

static int
cvs_annotate_pre_exec(struct cvsroot *root)
{
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (usehead == 1)
			cvs_sendarg(root, "-f", 0);

		if (rev != NULL) {
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, rev, 0);
		}
d71 2
a72 5
		if (date != NULL) {
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, date, 0);
		}
	}
d74 2
a75 2
	return (0);
}
d77 2
a78 10
/*
 * cvs_annotate_remote()
 *
 * Annotate a single file.
 */
static int
cvs_annotate_remote(CVSFILE *cf, void *arg)
{
	char fpath[MAXPATHLEN];
	struct cvsroot *root;
d80 2
a81 1
	root = CVS_DIR_ROOT(cf);
d83 4
a86 6
	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		else
			cvs_senddir(root, cf);
		return (0);
d89 1
a89 2
	cvs_file_getpath(cf, fpath, sizeof(fpath));
	cvs_sendentry(root, cf);
d91 10
a100 13
	switch (cf->cf_cvstat) {
	case CVS_FST_UNKNOWN:
		cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		break;
	case CVS_FST_UPTODATE:
		cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
		break;
	case CVS_FST_ADDED:
	case CVS_FST_MODIFIED:
		cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);
		break;
	default:
		break;
d106 12
d119 4
a122 5
static int
cvs_annotate_local(CVSFILE *cf, void *arg)
{
	char fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	RCSFILE *rf;
d124 2
a125 2
	if (cf->cf_type == DT_DIR)
		return (0);
d127 6
a132 1
	cvs_file_getpath(cf, fpath, sizeof(fpath));
d134 2
a135 2
	if (cf->cf_cvstat == CVS_FST_UNKNOWN)
		return (0);
d137 3
a139 1
	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));
d141 1
a141 3
	if ((rf = rcs_open(rcspath, RCS_READ)) == NULL)
		fatal("cvs_annotate_local: rcs_open `%s': %s", rcspath,
		    rcs_errstr(rcs_errno));
d143 3
a145 2
	cvs_printf("Annotations for %s", cf->cf_name);
	cvs_printf("\n***************\n");
d147 3
a149 1
	rcs_close(rf);
d151 2
a152 1
	return (0);
@


1.29
log
@strerror() -> rcs_errstr() when passing rcs_errno as argument;
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.28 2006/01/27 15:26:38 xsa Exp $	*/
@


1.28
log
@more errors handling cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.27 2006/01/02 08:11:56 xsa Exp $	*/
d175 1
a175 1
		    strerror(rcs_errno));
@


1.27
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.26 2005/12/30 16:42:13 xsa Exp $	*/
d173 3
a175 3
	rf = rcs_open(rcspath, RCS_READ);
	if (rf == NULL)
		return (CVS_EX_DATA);
@


1.26
log
@minor style nits;
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.25 2005/12/30 02:03:28 joris Exp $	*/
d27 1
a27 8
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.25
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.24 2005/12/22 14:59:54 xsa Exp $	*/
d104 1
a104 1
		if (usehead)
@


1.24
log
@cvs_rcs_getpath() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.23 2005/07/25 12:05:43 xsa Exp $	*/
a39 1

d104 2
a105 2
		if (usehead && (cvs_sendarg(root, "-f", 0) < 0))
			return (CVS_EX_PROTO);
d108 2
a109 3
			if ((cvs_sendarg(root, "-r", 0) < 0) ||
			    (cvs_sendarg(root, rev, 0) < 0))
				return (CVS_EX_PROTO);
d113 2
a114 3
			if ((cvs_sendarg(root, "-D", 0) < 0) ||
			    (cvs_sendarg(root, date, 0) < 0))
				return (CVS_EX_PROTO);
a128 1
	int ret;
a131 1
	ret = 0;
d136 1
a136 2
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    cf->cf_name);
d138 2
a139 6
			ret = cvs_senddir(root, cf);

		if (ret == -1)
			ret = CVS_EX_PROTO;

		return (ret);
d143 1
a143 4

	if (cvs_sendentry(root, cf) < 0) {
		return (CVS_EX_PROTO);
	}
d147 1
a147 1
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
d150 1
a150 1
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
d154 1
a154 1
		ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);
d160 1
a160 4
	if (ret == -1)
		ret = CVS_EX_PROTO;

	return (ret);
@


1.23
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.22 2005/07/21 11:42:24 xsa Exp $	*/
d194 1
a194 2
	if (cvs_rcs_getpath(cf, rcspath, sizeof(rcspath)) == NULL)
		return (CVS_EX_DATA);
@


1.22
log
@<sys/param.h> is already included in "cvs.h", no need to duplicate;
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.21 2005/07/14 06:54:59 xsa Exp $	*/
d41 4
a44 4
static int cvs_annotate_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_annotate_remote   (CVSFILE *, void *);
static int cvs_annotate_local    (CVSFILE *, void *);
static int cvs_annotate_pre_exec (struct cvsroot *);
@


1.21
log
@more use of cvs_rcs_getpath();
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.20 2005/07/11 18:05:09 joris Exp $	*/
a26 1
#include <sys/param.h>
@


1.20
log
@

zap unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.19 2005/07/07 14:27:57 joris Exp $	*/
d184 1
a184 2
	int len;
	char *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
a185 1
	struct cvsroot *root;
a189 3
	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);

d195 1
a195 5
	len = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, CVS_FILE_NAME(cf), RCS_FILE_EXT);
	if (len == -1 || len >= (int)sizeof(rcspath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rcspath);
a196 1
	}
@


1.19
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.18 2005/07/04 10:21:03 xsa Exp $	*/
a187 1
	struct rcs_delta *rdp;
@


1.18
log
@start server support for annotate command + some cleanup; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.17 2005/05/31 08:58:47 xsa Exp $	*/
d62 1
a62 1
};	
@


1.17
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.16 2005/05/30 08:27:03 xsa Exp $	*/
d42 4
a45 4
static int cvs_annotate_file      (CVSFILE *, void *);
static int cvs_annotate_options   (struct cvs_cmd *, int, char **, int *);
static int cvs_annotate_sendflags (struct cvsroot *);

d55 4
a58 4
	cvs_annotate_options,
	cvs_annotate_sendflags,
	cvs_annotate_file,
	cvs_annotate_file,
d68 1
a68 1
cvs_annotate_options(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d103 1
a103 1
cvs_annotate_sendflags(struct cvsroot *root)
d105 3
a107 2
	if (usehead && (cvs_sendarg(root, "-f", 0) < 0))
		return (CVS_EX_PROTO);
d109 5
a113 5
	if (rev != NULL) {
		if ((cvs_sendarg(root, "-r", 0) < 0) ||
		    (cvs_sendarg(root, rev, 0) < 0))
			return (CVS_EX_PROTO);
	}
d115 5
a119 4
	if (date != NULL) {
		if ((cvs_sendarg(root, "-D", 0) < 0) ||
		    (cvs_sendarg(root, date, 0) < 0))
			return (CVS_EX_PROTO);
d126 1
a126 1
 * cvs_annotate_file()
d131 1
a131 1
cvs_annotate_file(CVSFILE *cf, void *arg)
d178 41
@


1.16
log
@-D and -r can be used simultaneously, pointed out by marc@@ and thus
backout my previous change + spotted another case in the annotate
command...

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.15 2005/05/29 00:52:08 xsa Exp $	*/
d31 1
a32 1
#include <fcntl.h>
d34 1
a35 1
#include <string.h>
a37 1
#include "rcs.h"
@


1.15
log
@correct error message...
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.14 2005/05/24 04:12:25 jfb Exp $	*/
a96 6
	}

	if ((date != NULL) && (rev != NULL)) {
		cvs_log(LP_ERR,
		    "the -D and -r arguments are mutually exclusive");
		return (CVS_EX_USAGE);
@


1.14
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.13 2005/05/20 20:00:53 joris Exp $	*/
d101 1
a101 1
		    "the -D and -d arguments are mutually exclusive");
@


1.13
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.12 2005/05/20 18:32:23 jfb Exp $	*/
d44 1
a44 1
static int cvs_annotate_options   (char *, int, char **, int *);
d47 9
a55 1
struct cvs_cmd_info cvs_annotate = {
d59 3
a61 3
	NULL, NULL,
	CF_SORT | CF_RECURSE | CF_IGNORE | CF_NOSYMS,
	CVS_REQ_ANNOTATE,
d69 1
a69 1
cvs_annotate_options(char *opt, int argc, char **argv, int *arg)
d77 1
a77 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d86 1
a86 1
			cvs_annotate.file_flags &= ~CF_RECURSE;
d89 1
a89 1
			cvs_annotate.file_flags |= CF_RECURSE;
@


1.12
log
@make the handlers static and remove local code that will go in another
function
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.11 2005/04/18 21:02:49 jfb Exp $	*/
d143 4
d170 3
@


1.11
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.10 2005/04/13 20:05:37 jfb Exp $	*/
d43 3
a45 4
int cvs_annotate_file(CVSFILE *, void *);
int cvs_annotate_prune(CVSFILE *, void *);
int cvs_annotate_options(char *, int, char **, int *);
int cvs_annotate_sendflags(struct cvsroot *);
d60 1
a60 1
int
d101 1
a101 1
int
d127 1
a127 1
int
d138 5
a142 8
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cf->cf_cvstat == CVS_FST_UNKNOWN)
				ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
				    CVS_FILE_NAME(cf));
			else
				ret = cvs_senddir(root, cf);
		}

d148 3
a150 4
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_sendentry(root, cf) < 0) {
			return (CVS_EX_PROTO);
		}
d152 13
a164 22
		switch (cf->cf_cvstat) {
		case CVS_FST_UNKNOWN:
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cf));
			break;
		case CVS_FST_UPTODATE:
			ret = cvs_sendreq(root, CVS_REQ_UNCHANGED,
			    CVS_FILE_NAME(cf));
			break;
		case CVS_FST_ADDED:
		case CVS_FST_MODIFIED:
			ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED,
			    CVS_FILE_NAME(cf));
			break;
		default:
			break;
		}
	} else {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
			cvs_printf("? %s\n", fpath);
			return (0);
		}
@


1.10
log
@use the option string from the cvs_cmd entry instead of keeping a
hardcoded copy

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.9 2005/04/12 14:58:40 joris Exp $	*/
a133 1
	struct cvs_ent *entp;
a150 1
	entp = cvs_ent_getent(fpath);
d153 1
a153 2
		if ((entp != NULL) && (cvs_sendentry(root, entp) < 0)) {
			cvs_ent_free(entp);
a180 2
	if (entp != NULL)
		cvs_ent_free(entp);
@


1.9
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.8 2005/04/11 18:02:58 joris Exp $	*/
d70 1
a70 1
	while ((ch = getopt(argc, argv, "D:flRr:")) != -1) {
@


1.8
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.7 2005/04/11 17:56:27 joris Exp $	*/
d88 1
a88 1
			return (1);
d95 1
a95 1
		return (1);
d106 1
a106 1
		return (-1);
d111 1
a111 1
			return (-1);
d117 1
a117 1
			return (-1);
d157 1
a157 1
			return (-1);
@


1.7
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.6 2005/04/03 17:32:50 xsa Exp $	*/
a35 1
#include <sysexits.h>
@


1.6
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.5 2005/03/30 17:43:04 joris Exp $	*/
d89 1
a89 1
			return (EX_USAGE);
d96 1
a96 1
		return (EX_USAGE);
@


1.5
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.4 2005/01/13 16:32:46 jfb Exp $	*/
d107 1
a107 1
		return (EX_PROTOCOL);
d112 1
a112 1
			return (EX_PROTOCOL);
d118 1
a118 1
			return (EX_PROTOCOL);
@


1.4
log
@fix the annotate usage (there is no -F flag) and add the missing bits
so the -r and -f arguments are supported, and complain if both -D
and -r are given.  GNU CVS silently accepts to have both specified,
but does not produce output as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.3 2004/12/21 18:32:09 jfb Exp $	*/
d44 14
a57 2
int  cvs_annotate_file  (CVSFILE *, void *);
int  cvs_annotate_prune (CVSFILE *, void *);
d59 2
a61 6
/*
 * cvs_annotate()
 *
 * Handle the `cvs annotate' command.
 * Returns 0 on success, or the appropriate exit code on error.
 */
d63 1
a63 1
cvs_annotate(int argc, char **argv)
d65 1
a65 3
	int i, ch, flags, usehead;
	char *date, *rev;
	struct cvsroot *root;
a69 1
	flags = CF_SORT|CF_RECURSE|CF_IGNORE|CF_NOSYMS;
d80 1
a80 1
			flags &= ~CF_RECURSE;
d83 1
a83 1
			flags |= CF_RECURSE;
d99 3
a101 2
	argc -= optind;
	argv += optind;
d103 5
a107 18
	if (argc == 0) {
		cvs_files = cvs_file_get(".", flags);
	} else {
		/* don't perform ignore on explicitly listed files */
		flags &= ~(CF_IGNORE | CF_RECURSE | CF_SORT);
		cvs_files = cvs_file_getspec(argv, argc, flags);
	}
	if (cvs_files == NULL)
		return (EX_DATAERR);

	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
d109 3
a111 2
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_connect(root) < 0)
a112 12
		if (usehead && (cvs_sendarg(root, "-f", 0) < 0))
			return (EX_PROTOCOL);
		if (rev != NULL) {
			if ((cvs_sendarg(root, "-r", 0) < 0) ||
			    (cvs_sendarg(root, rev, 0) < 0))
				return (EX_PROTOCOL);
		}
		if (date != NULL) {
			if ((cvs_sendarg(root, "-D", 0) < 0) ||
			    (cvs_sendarg(root, date, 0) < 0))
				return (EX_PROTOCOL);
		}
d115 3
a117 10
	cvs_file_examine(cvs_files, cvs_annotate_file, NULL);


	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0)
			return (EX_PROTOCOL);
		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				return (EX_PROTOCOL);
		if (cvs_sendreq(root, CVS_REQ_ANNOTATE, NULL) < 0)
a122 1

@


1.3
log
@modify the directory handling portion to behave like the one in add.c,
which does not attempt to send data when running on a local
repository.  This will be needed to support local repository access
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.2 2004/12/14 22:30:47 jfb Exp $	*/
d57 1
a57 1
	int i, ch, flags;
d61 1
d66 1
a66 1
	while ((ch = getopt(argc, argv, "D:FflRr:")) != -1) {
d71 3
d81 1
d88 6
d118 2
@


1.2
log
@First attempt at syncing the command code and doing a lot more error
checking on all the protocol calls
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.1 2004/12/09 20:03:26 jfb Exp $	*/
d153 9
a161 6
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cf->cf_type == DT_DIR)) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cf));
		else
			ret = cvs_senddir(root, cf);
@


1.1
log
@support the 'annotate' command, will need some polishing
@
text
@d1 1
a1 1
/*	$OpenBSD: annotate.c,v 1.11 2004/12/07 17:10:56 tedu Exp $	*/
d97 11
a107 2
	if (root->cr_method != NULL) {
		cvs_connect(root);
d109 3
a111 2
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, rev, 0);
d114 3
a116 2
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, date, 0); 
d124 2
a125 1
		cvs_senddir(root, cvs_files);
d127 4
a130 2
			cvs_sendarg(root, argv[i], 0);
		cvs_sendreq(root, CVS_REQ_ANNOTATE, NULL);
d145 1
d150 2
a151 1
	cvs_file_getpath(cf, fpath, sizeof(fpath));
d153 3
a155 4
	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
			root = cf->cf_parent->cf_ddat->cd_root;
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
a156 17
		} else {
			root = cf->cf_ddat->cd_root;
			if ((cf->cf_parent == NULL) ||
			    (root != cf->cf_parent->cf_ddat->cd_root)) {
				cvs_connect(root);
			}

			cvs_senddir(root, cf);
		}

		return (0);
	} else
		root = cf->cf_parent->cf_ddat->cd_root;

	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		if (root->cr_method == CVS_METHOD_LOCAL)
			cvs_printf("? %s\n", fpath);
d158 2
a159 3
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cf));
		return (0);
d162 1
a163 5
	if ((entp != NULL) && (root->cr_method != CVS_METHOD_LOCAL) &&
	    (cvs_sendentry(root, entp) < 0)) {
		cvs_ent_free(entp);
		return (-1);
	}
d166 5
d172 4
d177 2
a178 1
			cvs_sendreq(root, CVS_REQ_UNCHANGED, CVS_FILE_NAME(cf));
d182 1
a182 1
			cvs_sendreq(root, CVS_REQ_ISMODIFIED,
d186 6
a191 1
			return (-1);
a192 1

d197 1
a197 1
	return (0);
@

