head	1.159;
access;
symbols
	OPENBSD_6_1:1.159.0.4
	OPENBSD_6_1_BASE:1.159
	OPENBSD_6_0:1.158.0.4
	OPENBSD_6_0_BASE:1.158
	OPENBSD_5_9:1.158.0.2
	OPENBSD_5_9_BASE:1.158
	OPENBSD_5_8:1.157.0.6
	OPENBSD_5_8_BASE:1.157
	OPENBSD_5_7:1.157.0.2
	OPENBSD_5_7_BASE:1.157
	OPENBSD_5_6:1.155.0.16
	OPENBSD_5_6_BASE:1.155
	OPENBSD_5_5:1.155.0.14
	OPENBSD_5_5_BASE:1.155
	OPENBSD_5_4:1.155.0.10
	OPENBSD_5_4_BASE:1.155
	OPENBSD_5_3:1.155.0.8
	OPENBSD_5_3_BASE:1.155
	OPENBSD_5_2:1.155.0.6
	OPENBSD_5_2_BASE:1.155
	OPENBSD_5_1_BASE:1.155
	OPENBSD_5_1:1.155.0.4
	OPENBSD_5_0:1.155.0.2
	OPENBSD_5_0_BASE:1.155
	OPENBSD_4_9:1.154.0.2
	OPENBSD_4_9_BASE:1.154
	OPENBSD_4_8:1.152.0.2
	OPENBSD_4_8_BASE:1.152
	OPENBSD_4_7:1.151.0.2
	OPENBSD_4_7_BASE:1.151
	OPENBSD_4_6:1.151.0.4
	OPENBSD_4_6_BASE:1.151
	OPENBSD_4_5:1.150.0.2
	OPENBSD_4_5_BASE:1.150
	OPENBSD_4_4:1.147.0.2
	OPENBSD_4_4_BASE:1.147
	OPENBSD_4_3:1.140.0.2
	OPENBSD_4_3_BASE:1.140
	OPENBSD_4_2:1.113.0.2
	OPENBSD_4_2_BASE:1.113
	OPENBSD_4_1:1.107.0.2
	OPENBSD_4_1_BASE:1.107
	OPENBSD_4_0:1.90.0.2
	OPENBSD_4_0_BASE:1.90
	OPENBSD_3_9:1.69.0.2
	OPENBSD_3_9_BASE:1.69
	OPENBSD_3_8:1.50.0.2
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.159
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.158;
commitid	8Vv7d4HkmCtExfc6;

1.158
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.157;
commitid	O6jeJ0TRmiewrqMI;

1.157
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.156;
commitid	Uu5nFG3wCl0LACBb;

1.156
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.155;
commitid	Z3HC5pAWzpo5jsTe;

1.155
date	2011.04.20.18.43.57;	author nicm;	state Exp;
branches;
next	1.154;

1.154
date	2010.11.11.21.00.59;	author nicm;	state Exp;
branches;
next	1.153;

1.153
date	2010.09.23.18.10.16;	author nicm;	state Exp;
branches;
next	1.152;

1.152
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.151;

1.151
date	2009.03.24.06.59.19;	author joris;	state Exp;
branches;
next	1.150;

1.150
date	2009.02.23.21.33.12;	author joris;	state Exp;
branches;
next	1.149;

1.149
date	2009.02.23.21.32.08;	author joris;	state Exp;
branches;
next	1.148;

1.148
date	2009.02.21.13.39.59;	author joris;	state Exp;
branches;
next	1.147;

1.147
date	2008.06.21.15.39.15;	author joris;	state Exp;
branches;
next	1.146;

1.146
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.145;

1.145
date	2008.06.12.07.16.14;	author joris;	state Exp;
branches;
next	1.144;

1.144
date	2008.06.10.01.00.35;	author joris;	state Exp;
branches;
next	1.143;

1.143
date	2008.03.09.12.52.33;	author joris;	state Exp;
branches;
next	1.142;

1.142
date	2008.03.09.01.58.00;	author joris;	state Exp;
branches;
next	1.141;

1.141
date	2008.03.08.22.15.30;	author tobias;	state Exp;
branches;
next	1.140;

1.140
date	2008.03.01.15.10.20;	author joris;	state Exp;
branches;
next	1.139;

1.139
date	2008.02.10.14.04.40;	author joris;	state Exp;
branches;
next	1.138;

1.138
date	2008.02.10.14.00.42;	author joris;	state Exp;
branches;
next	1.137;

1.137
date	2008.02.10.13.01.08;	author tobias;	state Exp;
branches;
next	1.136;

1.136
date	2008.02.10.11.52.35;	author joris;	state Exp;
branches;
next	1.135;

1.135
date	2008.02.09.20.04.00;	author xsa;	state Exp;
branches;
next	1.134;

1.134
date	2008.02.09.16.56.58;	author joris;	state Exp;
branches;
next	1.133;

1.133
date	2008.02.09.16.52.27;	author joris;	state Exp;
branches;
next	1.132;

1.132
date	2008.02.04.19.08.32;	author joris;	state Exp;
branches;
next	1.131;

1.131
date	2008.02.04.18.23.58;	author tobias;	state Exp;
branches;
next	1.130;

1.130
date	2008.02.03.17.20.14;	author joris;	state Exp;
branches;
next	1.129;

1.129
date	2008.01.31.22.11.38;	author joris;	state Exp;
branches;
next	1.128;

1.128
date	2008.01.31.22.09.05;	author xsa;	state Exp;
branches;
next	1.127;

1.127
date	2008.01.31.16.44.46;	author tobias;	state Exp;
branches;
next	1.126;

1.126
date	2008.01.31.10.17.47;	author tobias;	state Exp;
branches;
next	1.125;

1.125
date	2008.01.21.16.36.46;	author tobias;	state Exp;
branches;
next	1.124;

1.124
date	2008.01.10.10.09.27;	author tobias;	state Exp;
branches;
next	1.123;

1.123
date	2008.01.10.10.08.22;	author tobias;	state Exp;
branches;
next	1.122;

1.122
date	2008.01.10.10.00.53;	author tobias;	state Exp;
branches;
next	1.121;

1.121
date	2007.10.09.12.14.09;	author tobias;	state Exp;
branches;
next	1.120;

1.120
date	2007.10.05.19.28.23;	author gilles;	state Exp;
branches;
next	1.119;

1.119
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.118;

1.118
date	2007.09.19.12.04.38;	author tobias;	state Exp;
branches;
next	1.117;

1.117
date	2007.09.19.11.53.27;	author tobias;	state Exp;
branches;
next	1.116;

1.116
date	2007.09.09.20.24.06;	author tobias;	state Exp;
branches;
next	1.115;

1.115
date	2007.09.04.19.07.04;	author tobias;	state Exp;
branches;
next	1.114;

1.114
date	2007.09.02.11.40.03;	author tobias;	state Exp;
branches;
next	1.113;

1.113
date	2007.07.19.06.34.15;	author ray;	state Exp;
branches;
next	1.112;

1.112
date	2007.07.03.13.22.43;	author joris;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.110;

1.110
date	2007.05.27.00.37.46;	author ray;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.09.21.19.28;	author xsa;	state Exp;
branches;
next	1.108;

1.108
date	2007.04.20.08.36.00;	author xsa;	state Exp;
branches;
next	1.107;

1.107
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.106;

1.106
date	2007.02.19.11.40.00;	author otto;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.07.23.47.56;	author todd;	state Exp;
branches;
next	1.103;

1.103
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.102;

1.102
date	2007.01.25.18.35.30;	author niallo;	state Exp;
branches;
next	1.101;

1.101
date	2007.01.20.16.52.39;	author thib;	state Exp;
branches;
next	1.100;

1.100
date	2007.01.20.01.07.51;	author niallo;	state Exp;
branches;
next	1.99;

1.99
date	2007.01.19.23.55.31;	author todd;	state Exp;
branches;
next	1.98;

1.98
date	2007.01.17.17.54.50;	author joris;	state Exp;
branches;
next	1.97;

1.97
date	2007.01.11.17.44.18;	author niallo;	state Exp;
branches;
next	1.96;

1.96
date	2007.01.07.01.53.12;	author joris;	state Exp;
branches;
next	1.95;

1.95
date	2007.01.03.14.08.09;	author xsa;	state Exp;
branches;
next	1.94;

1.94
date	2006.12.05.15.59.48;	author xsa;	state Exp;
branches;
next	1.93;

1.93
date	2006.12.05.11.01.05;	author xsa;	state Exp;
branches;
next	1.92;

1.92
date	2006.11.28.14.49.58;	author xsa;	state Exp;
branches;
next	1.91;

1.91
date	2006.10.11.22.00.22;	author thib;	state Exp;
branches;
next	1.90;

1.90
date	2006.07.09.01.47.20;	author joris;	state Exp;
branches;
next	1.89;

1.89
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.88;

1.88
date	2006.06.14.20.28.53;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2006.06.14.15.14.47;	author xsa;	state Exp;
branches;
next	1.86;

1.86
date	2006.06.07.22.20.59;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2006.05.30.19.30.11;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2006.05.30.07.00.30;	author joris;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.29.07.16.44;	author joris;	state Exp;
branches;
next	1.82;

1.82
date	2006.05.28.21.34.37;	author joris;	state Exp;
branches;
next	1.81;

1.81
date	2006.05.28.17.25.18;	author joris;	state Exp;
branches;
next	1.80;

1.80
date	2006.05.27.16.18.23;	author joris;	state Exp;
branches;
next	1.79;

1.79
date	2006.05.27.03.30.31;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2006.04.05.01.38.56;	author ray;	state Exp;
branches;
next	1.76;

1.76
date	2006.03.29.09.16.53;	author ray;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.28.07.17.17;	author ray;	state Exp;
branches;
next	1.74;

1.74
date	2006.03.28.02.13.44;	author ray;	state Exp;
branches;
next	1.73;

1.73
date	2006.03.27.06.13.51;	author pat;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.17.13.40.41;	author niallo;	state Exp;
branches;
next	1.71;

1.71
date	2006.03.17.08.51.45;	author xsa;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.15.19.59.36;	author niallo;	state Exp;
branches;
next	1.69;

1.69
date	2006.01.27.12.56.28;	author xsa;	state Exp;
branches;
next	1.68;

1.68
date	2006.01.25.11.19.51;	author xsa;	state Exp;
branches;
next	1.67;

1.67
date	2006.01.02.08.23.39;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.65;

1.65
date	2006.01.01.05.05.58;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.30.16.47.36;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.24.19.07.52;	author xsa;	state Exp;
branches;
next	1.62;

1.62
date	2005.12.24.04.10.51;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2005.12.22.14.31.44;	author xsa;	state Exp;
branches;
next	1.60;

1.60
date	2005.12.22.14.16.18;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2005.12.03.15.07.21;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.03.03.59.47;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.03.01.02.09;	author joris;	state Exp;
branches;
next	1.55;

1.55
date	2005.10.30.11.10.12;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2005.10.22.17.32.57;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2005.09.15.17.01.10;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2005.09.05.19.29.42;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.17.08.35.53;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2005.08.12.14.41.54;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.30.21.16.17;	author moritz;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.27.19.24.14;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.27.10.38.01;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.27.10.36.14;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.26.14.46.24;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.25.13.37.53;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.24.17.33.09;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.24.17.12.25;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.23.10.59.47;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.23.10.49.35;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.19.15.36.54;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.19.01.40.29;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.13.16.20.44;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.17.15.09.55;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.14.03.56.14;	author pat;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.02.20.19.30;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.27.17.04.59;	author jfb;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.26.22.25.31;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.24.20.04.43;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.20.10.40.22;	author pat;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.20.00.07.19;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.19.04.17.24;	author jfb;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.18.20.24.19;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.16.20.05.05;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.16.18.07.35;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.22.00.38.26;	author david;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.13.16.59.50;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.07.06.33.11;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.06.21.13.49;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.06.21.03.13;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.03.20.24.37;	author weingart;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.10.22.27.31;	author krapht;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.09.21.08.05;	author krapht;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.13.12.48.51;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.13.02.16.29;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.12.18.34.37;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.06.20.08.49;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.05.13.50.12;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.30.16.52.13;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.30.01.49.24;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.28.01.50.05;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.27.12.01.58;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.159
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@/*	$OpenBSD: util.c,v 1.158 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * Copyright (c) 2005, 2006 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <atomicio.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"
#include "hash.h"

extern int print_stdout;
extern int build_dirs;
extern int disable_fast_checkout;

/* letter -> mode type map */
static const int cvs_modetypes[26] = {
	-1, -1, -1, -1, -1, -1,  1, -1, -1, -1, -1, -1, -1,
	-1,  2, -1, -1, -1, -1, -1,  0, -1, -1, -1, -1, -1,
};

/* letter -> mode map */
static const mode_t cvs_modes[3][26] = {
	{
		0,  0,       0,       0,       0,  0,  0,    /* a - g */
		0,  0,       0,       0,       0,  0,  0,    /* h - m */
		0,  0,       0,       S_IRUSR, 0,  0,  0,    /* n - u */
		0,  S_IWUSR, S_IXUSR, 0,       0             /* v - z */
	},
	{
		0,  0,       0,       0,       0,  0,  0,    /* a - g */
		0,  0,       0,       0,       0,  0,  0,    /* h - m */
		0,  0,       0,       S_IRGRP, 0,  0,  0,    /* n - u */
		0,  S_IWGRP, S_IXGRP, 0,       0             /* v - z */
	},
	{
		0,  0,       0,       0,       0,  0,  0,    /* a - g */
		0,  0,       0,       0,       0,  0,  0,    /* h - m */
		0,  0,       0,       S_IROTH, 0,  0,  0,    /* n - u */
		0,  S_IWOTH, S_IXOTH, 0,       0             /* v - z */
	}
};


/* octal -> string */
static const char *cvs_modestr[8] = {
	"", "x", "w", "wx", "r", "rx", "rw", "rwx"
};

/*
 * cvs_strtomode()
 *
 * Read the contents of the string <str> and generate a permission mode from
 * the contents of <str>, which is assumed to have the mode format of CVS.
 * The CVS protocol specification states that any modes or mode types that are
 * not recognized should be silently ignored.  This function does not return
 * an error in such cases, but will issue warnings.
 */
void
cvs_strtomode(const char *str, mode_t *mode)
{
	char type;
	size_t l;
	mode_t m;
	char buf[32], ms[4], *sp, *ep;

	m = 0;
	l = strlcpy(buf, str, sizeof(buf));
	if (l >= sizeof(buf))
		fatal("cvs_strtomode: string truncation");

	sp = buf;
	ep = sp;

	for (sp = buf; ep != NULL; sp = ep + 1) {
		ep = strchr(sp, ',');
		if (ep != NULL)
			*ep = '\0';

		memset(ms, 0, sizeof ms);
		if (sscanf(sp, "%c=%3s", &type, ms) != 2 &&
			sscanf(sp, "%c=", &type) != 1) {
			fatal("failed to scan mode string `%s'", sp);
		}

		if (type <= 'a' || type >= 'z' ||
		    cvs_modetypes[type - 'a'] == -1) {
			cvs_log(LP_ERR,
			    "invalid mode type `%c'"
			    " (`u', `g' or `o' expected), ignoring", type);
			continue;
		}

		/* make type contain the actual mode index */
		type = cvs_modetypes[type - 'a'];

		for (sp = ms; *sp != '\0'; sp++) {
			if (*sp <= 'a' || *sp >= 'z' ||
			    cvs_modes[(int)type][*sp - 'a'] == 0) {
				fatal("invalid permission bit `%c'", *sp);
			} else
				m |= cvs_modes[(int)type][*sp - 'a'];
		}
	}

	*mode = m;
}

/*
 * cvs_modetostr()
 *
 * Generate a CVS-format string to represent the permissions mask on a file
 * from the mode <mode> and store the result in <buf>, which can accept up to
 * <len> bytes (including the terminating NUL byte).  The result is guaranteed
 * to be NUL-terminated.
 */
void
cvs_modetostr(mode_t mode, char *buf, size_t len)
{
	char tmp[16], *bp;
	mode_t um, gm, om;

	um = (mode & S_IRWXU) >> 6;
	gm = (mode & S_IRWXG) >> 3;
	om = mode & S_IRWXO;

	bp = buf;
	*bp = '\0';

	if (um) {
		if (strlcpy(tmp, "u=", sizeof(tmp)) >= sizeof(tmp) ||
		    strlcat(tmp, cvs_modestr[um], sizeof(tmp)) >= sizeof(tmp))
			fatal("cvs_modetostr: overflow for user mode");

		if (strlcat(buf, tmp, len) >= len)
			fatal("cvs_modetostr: string truncation");
	}

	if (gm) {
		if (um) {
			if (strlcat(buf, ",", len) >= len)
				fatal("cvs_modetostr: string truncation");
		}

		if (strlcpy(tmp, "g=", sizeof(tmp)) >= sizeof(tmp) ||
		    strlcat(tmp, cvs_modestr[gm], sizeof(tmp)) >= sizeof(tmp))
			fatal("cvs_modetostr: overflow for group mode");

		if (strlcat(buf, tmp, len) >= len)
			fatal("cvs_modetostr: string truncation");
	}

	if (om) {
		if (um || gm) {
			if (strlcat(buf, ",", len) >= len)
				fatal("cvs_modetostr: string truncation");
		}

		if (strlcpy(tmp, "o=", sizeof(tmp)) >= sizeof(tmp) ||
		    strlcat(tmp, cvs_modestr[gm], sizeof(tmp)) >= sizeof(tmp))
			fatal("cvs_modetostr: overflow for others mode");

		if (strlcat(buf, tmp, len) >= len)
			fatal("cvs_modetostr: string truncation");
	}
}

/*
 * cvs_getargv()
 *
 * Parse a line contained in <line> and generate an argument vector by
 * splitting the line on spaces and tabs.  The resulting vector is stored in
 * <argv>, which can accept up to <argvlen> entries.
 * Returns the number of arguments in the vector, or -1 if an error occurred.
 */
int
cvs_getargv(const char *line, char **argv, int argvlen)
{
	u_int i;
	int argc, error;
	char *linebuf, *lp, *cp;

	linebuf = xstrdup(line);

	memset(argv, 0, argvlen * sizeof(char *));
	argc = 0;

	/* build the argument vector */
	error = 0;
	for (lp = linebuf; lp != NULL;) {
		cp = strsep(&lp, " \t");
		if (cp == NULL)
			break;
		else if (*cp == '\0')
			continue;

		if (argc == argvlen) {
			error++;
			break;
		}

		argv[argc] = xstrdup(cp);
		argc++;
	}

	if (error != 0) {
		/* ditch the argument vector */
		for (i = 0; i < (u_int)argc; i++)
			free(argv[i]);
		argc = -1;
	}

	free(linebuf);
	return (argc);
}

/*
 * cvs_makeargv()
 *
 * Allocate an argument vector large enough to accommodate for all the
 * arguments found in <line> and return it.
 */
char **
cvs_makeargv(const char *line, int *argc)
{
	int i, ret;
	char *argv[1024], **copy;

	ret = cvs_getargv(line, argv, 1024);
	if (ret == -1)
		return (NULL);

	copy = xcalloc(ret + 1, sizeof(char *));

	for (i = 0; i < ret; i++)
		copy[i] = argv[i];
	copy[ret] = NULL;

	*argc = ret;
	return (copy);
}

/*
 * cvs_freeargv()
 *
 * Free an argument vector previously generated by cvs_getargv().
 */
void
cvs_freeargv(char **argv, int argc)
{
	int i;

	for (i = 0; i < argc; i++)
		free(argv[i]);
}

/*
 * cvs_chdir()
 *
 * Change to directory <path>.
 * If <rm> is equal to `1', <path> is removed if chdir() fails so we
 * do not have temporary directories leftovers.
 * Returns 0 on success.
 */
int
cvs_chdir(const char *path, int rm)
{
	if (chdir(path) == -1) {
		if (rm == 1)
			cvs_unlink(path);
		fatal("cvs_chdir: `%s': %s", path, strerror(errno));
	}

	return (0);
}

/*
 * cvs_rename()
 * Change the name of a file.
 * rename() wrapper with an error message.
 * Returns 0 on success.
 */
int
cvs_rename(const char *from, const char *to)
{
	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_rename(%s,%s)", from, to);

	if (cvs_noexec == 1)
		return (0);

	if (rename(from, to) == -1)
		fatal("cvs_rename: `%s'->`%s': %s", from, to, strerror(errno));

	return (0);
}

/*
 * cvs_unlink()
 *
 * Removes the link named by <path>.
 * unlink() wrapper with an error message.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_unlink(const char *path)
{
	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_unlink(%s)", path);

	if (cvs_noexec == 1 && disable_fast_checkout != 0)
		return (0);

	if (unlink(path) == -1 && errno != ENOENT) {
		cvs_log(LP_ERRNO, "%s", path);
		return (-1);
	}

	return (0);
}

/*
 * cvs_rmdir()
 *
 * Remove a directory tree from disk.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_rmdir(const char *path)
{
	int type, ret = -1;
	DIR *dirp;
	struct dirent *ent;
	struct stat st;
	char fpath[PATH_MAX];

	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_rmdir(%s)", path);

	if (cvs_noexec == 1 && disable_fast_checkout != 0)
		return (0);

	if ((dirp = opendir(path)) == NULL) {
		cvs_log(LP_ERR, "failed to open '%s'", path);
		return (-1);
	}

	while ((ent = readdir(dirp)) != NULL) {
		if (!strcmp(ent->d_name, ".") ||
		    !strcmp(ent->d_name, ".."))
			continue;

		(void)xsnprintf(fpath, sizeof(fpath), "%s/%s",
		    path, ent->d_name);

		if (ent->d_type == DT_UNKNOWN) {
			if (lstat(fpath, &st) == -1)
				fatal("'%s': %s", fpath, strerror(errno));

			switch (st.st_mode & S_IFMT) {
			case S_IFDIR:
				type = CVS_DIR;
				break;
			case S_IFREG:
				type = CVS_FILE;
				break;
			default:
				fatal("'%s': Unknown file type in copy",
				    fpath);
			}
		} else {
			switch (ent->d_type) {
			case DT_DIR:
				type = CVS_DIR;
				break;
			case DT_REG:
				type = CVS_FILE;
				break;
			default:
				fatal("'%s': Unknown file type in copy",
				    fpath);
			}
		}
		switch (type) {
		case CVS_DIR:
			if (cvs_rmdir(fpath) == -1)
				goto done;
			break;
		case CVS_FILE:
			if (cvs_unlink(fpath) == -1 && errno != ENOENT)
				goto done;
			break;
		default:
			fatal("type %d unknown, shouldn't happen", type);
		}
	}


	if (rmdir(path) == -1 && errno != ENOENT) {
		cvs_log(LP_ERRNO, "%s", path);
		goto done;
	}

	ret = 0;
done:
	closedir(dirp);
	return (ret);
}

void
cvs_get_repository_path(const char *dir, char *dst, size_t len)
{
	char buf[PATH_MAX];

	cvs_get_repository_name(dir, buf, sizeof(buf));
	(void)xsnprintf(dst, len, "%s/%s", current_cvsroot->cr_dir, buf);
	cvs_validate_directory(dst);
}

void
cvs_get_repository_name(const char *dir, char *dst, size_t len)
{
	FILE *fp;
	char fpath[PATH_MAX];

	dst[0] = '\0';

	if (!(cmdp->cmd_flags & CVS_USE_WDIR)) {
		if (strlcpy(dst, dir, len) >= len)
			fatal("cvs_get_repository_name: truncation");
		return;
	}

	switch (cvs_cmdop) {
	case CVS_OP_EXPORT:
		if (strcmp(dir, "."))
			if (strlcpy(dst, dir, len) >= len)
				fatal("cvs_get_repository_name: truncation");
		break;
	case CVS_OP_IMPORT:
		if (strlcpy(dst, import_repository, len) >= len)
			fatal("cvs_get_repository_name: truncation");
		if (strlcat(dst, "/", len) >= len)
			fatal("cvs_get_repository_name: truncation");

		if (strcmp(dir, "."))
			if (strlcat(dst, dir, len) >= len)
				fatal("cvs_get_repository_name: truncation");
		break;
	default:
		(void)xsnprintf(fpath, sizeof(fpath), "%s/%s",
		    dir, CVS_PATH_REPOSITORY);
		if ((fp = fopen(fpath, "r")) != NULL) {
			if ((fgets(dst, len, fp)) == NULL)
				fatal("%s: bad repository file", fpath);
			dst[strcspn(dst, "\n")] = '\0';
			(void)fclose(fp);
		} else if (cvs_cmdop != CVS_OP_CHECKOUT)
			fatal("%s is missing", fpath);
		break;
	}
}

void
cvs_mkadmin(const char *path, const char *root, const char *repo,
    char *tag, char *date)
{
	FILE *fp;
	int fd;
	char buf[PATH_MAX];
	struct hash_data *hdata, hd;

	hdata = hash_table_find(&created_cvs_directories, path, strlen(path));
	if (hdata != NULL)
		return;

	hd.h_key = xstrdup(path);
	hd.h_data = NULL;
	hash_table_enter(&created_cvs_directories, &hd);

	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_mkadmin(%s, %s, %s, %s, %s)",
		    path, root, repo, (tag != NULL) ? tag : "",
		    (date != NULL) ? date : "");

	(void)xsnprintf(buf, sizeof(buf), "%s/%s", path, CVS_PATH_CVSDIR);

	if (mkdir(buf, 0755) == -1 && errno != EEXIST)
		fatal("cvs_mkadmin: %s: %s", buf, strerror(errno));

	if (cvs_cmdop == CVS_OP_CHECKOUT || cvs_cmdop == CVS_OP_ADD ||
	    (cvs_cmdop == CVS_OP_UPDATE && build_dirs == 1)) {
		(void)xsnprintf(buf, sizeof(buf), "%s/%s",
		    path, CVS_PATH_ROOTSPEC);

		if ((fp = fopen(buf, "w")) == NULL)
			fatal("cvs_mkadmin: %s: %s", buf, strerror(errno));

		fprintf(fp, "%s\n", root);
		(void)fclose(fp);
	}

	(void)xsnprintf(buf, sizeof(buf), "%s/%s", path, CVS_PATH_REPOSITORY);

	if ((fp = fopen(buf, "w")) == NULL)
		fatal("cvs_mkadmin: %s: %s", buf, strerror(errno));

	fprintf(fp, "%s\n", repo);
	(void)fclose(fp);

	cvs_write_tagfile(path, tag, date);

	(void)xsnprintf(buf, sizeof(buf), "%s/%s", path, CVS_PATH_ENTRIES);

	if ((fd = open(buf, O_WRONLY|O_CREAT|O_EXCL, 0666 & ~cvs_umask))
	    == -1) {
		if (errno == EEXIST)
			return;
		fatal("cvs_mkadmin: %s: %s", buf, strerror(errno));
	}

	if (atomicio(vwrite, fd, "D\n", 2) != 2)
		fatal("cvs_mkadmin: %s", strerror(errno));
	close(fd);
}

void
cvs_mkpath(const char *path, char *tag)
{
	CVSENTRIES *ent;
	FILE *fp;
	size_t len;
	struct hash_data *hdata, hd;
	char *entry, *sp, *dp, *dir, *p, rpath[PATH_MAX], repo[PATH_MAX];

	hdata = hash_table_find(&created_directories, path, strlen(path));
	if (hdata != NULL)
		return;

	hd.h_key = xstrdup(path);
	hd.h_data = NULL;
	hash_table_enter(&created_directories, &hd);

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL ||
	    cvs_server_active == 1)
		cvs_validate_directory(path);

	dir = xstrdup(path);

	STRIP_SLASH(dir);

	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_mkpath(%s)", dir);

	repo[0] = '\0';
	rpath[0] = '\0';

	if ((cvs_cmdop != CVS_OP_CHECKOUT) && (cvs_cmdop != CVS_OP_EXPORT)) {
		if ((fp = fopen(CVS_PATH_REPOSITORY, "r")) != NULL) {
			if ((fgets(repo, sizeof(repo), fp)) == NULL)
				fatal("cvs_mkpath: bad repository file");
			repo[strcspn(repo, "\n")] = '\0';
			(void)fclose(fp);
		}
	}

	for (sp = dir; sp != NULL; sp = dp) {
		dp = strchr(sp, '/');
		if (dp != NULL)
			*(dp++) = '\0';

		if (sp == dir && module_repo_root != NULL) {
			len = strlcpy(repo, module_repo_root, sizeof(repo));
			if (len >= (int)sizeof(repo))
				fatal("cvs_mkpath: overflow");
		} else if (strcmp(sp, ".")) {
			if (repo[0] != '\0') {
				len = strlcat(repo, "/", sizeof(repo));
				if (len >= (int)sizeof(repo))
					fatal("cvs_mkpath: overflow");
			}

			len = strlcat(repo, sp, sizeof(repo));
			if (len >= (int)sizeof(repo))
				fatal("cvs_mkpath: overflow");
		}

		if (rpath[0] != '\0') {
			len = strlcat(rpath, "/", sizeof(rpath));
			if (len >= (int)sizeof(rpath))
				fatal("cvs_mkpath: overflow");
		}

		len = strlcat(rpath, sp, sizeof(rpath));
		if (len >= (int)sizeof(rpath))
			fatal("cvs_mkpath: overflow");

		if (mkdir(rpath, 0755) == -1 && errno != EEXIST)
			fatal("cvs_mkpath: %s: %s", rpath, strerror(errno));

		if (cvs_cmdop == CVS_OP_EXPORT && !cvs_server_active)
			continue;

		cvs_mkadmin(rpath, current_cvsroot->cr_str, repo,
		    tag, NULL);

		if (dp != NULL) {
			if ((p = strchr(dp, '/')) != NULL)
				*p = '\0';

			entry = xmalloc(CVS_ENT_MAXLINELEN);
			cvs_ent_line_str(dp, NULL, NULL, NULL, NULL, 1, 0,
			    entry, CVS_ENT_MAXLINELEN);

			ent = cvs_ent_open(rpath);
			cvs_ent_add(ent, entry);
			free(entry);

			if (p != NULL)
				*p = '/';
		}
	}

	free(dir);
}

void
cvs_mkdir(const char *path, mode_t mode)
{
	size_t len;
	char *sp, *dp, *dir, rpath[PATH_MAX];

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL ||
	    cvs_server_active == 1)
		cvs_validate_directory(path);

	dir = xstrdup(path);

	STRIP_SLASH(dir);

	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_mkdir(%s)", dir);

	rpath[0] = '\0';

	for (sp = dir; sp != NULL; sp = dp) {
		dp = strchr(sp, '/');
		if (dp != NULL)
			*(dp++) = '\0';

		len = strlcat(rpath, "/", sizeof(rpath));
		if (len >= (int)sizeof(rpath))
			fatal("cvs_mkdir: overflow");

		len = strlcat(rpath, sp, sizeof(rpath));
		if (len >= (int)sizeof(rpath))
			fatal("cvs_mkdir: overflow");
		if (1 == len)
			continue;

		if (mkdir(rpath, mode) == -1 && errno != EEXIST)
			fatal("cvs_mkdir: %s: %s", rpath, strerror(errno));
	}

	free(dir);
}

/*
 * Split the contents of a file into a list of lines.
 */
struct rcs_lines *
cvs_splitlines(u_char *data, size_t len)
{
	u_char *p, *c;
	size_t i, tlen;
	struct rcs_lines *lines;
	struct rcs_line *lp;

	lines = xcalloc(1, sizeof(*lines));
	TAILQ_INIT(&(lines->l_lines));

	lp = xcalloc(1, sizeof(*lp));
	TAILQ_INSERT_TAIL(&(lines->l_lines), lp, l_list);

	p = c = data;
	for (i = 0; i < len; i++) {
		if (*p == '\n' || (i == len - 1)) {
			tlen = p - c + 1;
			lp = xcalloc(1, sizeof(*lp));
			lp->l_line = c;
			lp->l_len = tlen;
			lp->l_lineno = ++(lines->l_nblines);
			TAILQ_INSERT_TAIL(&(lines->l_lines), lp, l_list);
			c = p + 1;
		}
		p++;
	}

	return (lines);
}

void
cvs_freelines(struct rcs_lines *lines)
{
	struct rcs_line *lp;

	while ((lp = TAILQ_FIRST(&(lines->l_lines))) != NULL) {
		TAILQ_REMOVE(&(lines->l_lines), lp, l_list);
		if (lp->l_needsfree == 1)
			free(lp->l_line);
		free(lp);
	}

	free(lines);
}

/*
 * cvs_strsplit()
 *
 * Split a string <str> of <sep>-separated values and allocate
 * an argument vector for the values found.
 */
struct cvs_argvector *
cvs_strsplit(char *str, const char *sep)
{
	struct cvs_argvector *av;
	size_t i = 0;
	char *cp, *p;

	cp = xstrdup(str);
	av = xmalloc(sizeof(*av));
	av->str = cp;
	av->argv = xmalloc(sizeof(*(av->argv)));

	while ((p = strsep(&cp, sep)) != NULL) {
		av->argv[i++] = p;
		av->argv = xreallocarray(av->argv,
		    i + 1, sizeof(*(av->argv)));
	}
	av->argv[i] = NULL;

	return (av);
}

/*
 * cvs_argv_destroy()
 *
 * Free an argument vector previously allocated by cvs_strsplit().
 */
void
cvs_argv_destroy(struct cvs_argvector *av)
{
	free(av->str);
	free(av->argv);
	free(av);
}

u_int
cvs_revision_select(RCSFILE *file, char *range)
{
	int i;
	u_int nrev;
	char *lstr, *rstr;
	struct rcs_delta *rdp;
	struct cvs_argvector *revargv, *revrange;
	RCSNUM *lnum, *rnum;

	nrev = 0;
	lnum = rnum = NULL;

	revargv = cvs_strsplit(range, ",");
	for (i = 0; revargv->argv[i] != NULL; i++) {
		revrange = cvs_strsplit(revargv->argv[i], ":");
		if (revrange->argv[0] == NULL)
			fatal("invalid revision range: %s", revargv->argv[i]);
		else if (revrange->argv[1] == NULL)
			lstr = rstr = revrange->argv[0];
		else {
			if (revrange->argv[2] != NULL)
				fatal("invalid revision range: %s",
				    revargv->argv[i]);

			lstr = revrange->argv[0];
			rstr = revrange->argv[1];

			if (strcmp(lstr, "") == 0)
				lstr = NULL;
			if (strcmp(rstr, "") == 0)
				rstr = NULL;
		}

		if (lstr == NULL)
			lstr = RCS_HEAD_INIT;

		if ((lnum = rcs_translate_tag(lstr, file)) == NULL)
			fatal("cvs_revision_select: could not translate tag `%s'", lstr);

		if (rstr != NULL) {
			if ((rnum = rcs_translate_tag(rstr, file)) == NULL)
				fatal("cvs_revision_select: could not translate tag `%s'", rstr);
		} else {
			rnum = rcsnum_alloc();
			rcsnum_cpy(file->rf_head, rnum, 0);
		}

		cvs_argv_destroy(revrange);

		TAILQ_FOREACH(rdp, &(file->rf_delta), rd_list) {
			if (rcsnum_cmp(rdp->rd_num, lnum, 0) <= 0 &&
			    rcsnum_cmp(rdp->rd_num, rnum, 0) >= 0 &&
			    !(rdp->rd_flags & RCS_RD_SELECT)) {
				rdp->rd_flags |= RCS_RD_SELECT;
				nrev++;
			}
		}

		free(lnum);
		free(rnum);
	}

	cvs_argv_destroy(revargv);

	return (nrev);
}

int
cvs_yesno(void)
{
	int c, ret;

	ret = 0;

	fflush(stderr);
	fflush(stdout);

	if ((c = getchar()) != 'y' && c != 'Y')
		ret = -1;
	else
		while (c != EOF && c != '\n')
			c = getchar();

	return (ret);
}

/*
 * cvs_exec()
 *
 * Execute <prog> and send <in> to the STDIN if not NULL.
 * If <needwait> == 1, return the result of <prog>, 
 * else, 0 or -1 if an error occur.
 */
int
cvs_exec(char *prog, const char *in, int needwait)
{
	pid_t pid;
	size_t size;
	int fds[2], st;
	char *argp[4] = { "sh", "-c", prog, NULL };

	if (in != NULL && pipe(fds) < 0) {
		cvs_log(LP_ERR, "cvs_exec: pipe failed");
		return (-1);
	}

	if ((pid = fork()) == -1) {
		cvs_log(LP_ERR, "cvs_exec: fork failed");
		return (-1);
	} else if (pid == 0) {
		if (in != NULL) {
			close(fds[1]);
			dup2(fds[0], STDIN_FILENO);
		}

		setenv("CVSROOT", current_cvsroot->cr_dir, 1);
		execv(_PATH_BSHELL, argp);
		cvs_log(LP_ERR, "cvs_exec: failed to run '%s'", prog);
		_exit(127);
	}

	if (in != NULL) {
		close(fds[0]);
		size = strlen(in);
		if (atomicio(vwrite, fds[1], in, size) != size)
			cvs_log(LP_ERR, "cvs_exec: failed to write on STDIN");
		close(fds[1]);
	}

	if (needwait == 1) {
		while (waitpid(pid, &st, 0) == -1)
			;
		if (!WIFEXITED(st)) {
			errno = EINTR;
			return (-1);
		}
		return (WEXITSTATUS(st));
	}

	return (0);
}
@


1.158
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.157 2015/01/16 06:40:07 deraadt Exp $	*/
d850 2
a851 2
		rcsnum_free(lnum);
		rcsnum_free(rnum);
@


1.157
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.156 2014/12/01 21:58:46 deraadt Exp $	*/
d242 1
a242 1
			xfree(argv[i]);
d246 1
a246 1
	xfree(linebuf);
d287 1
a287 2
		if (argv[i] != NULL)
			xfree(argv[i]);
d650 1
a650 1
			xfree(entry);
d657 1
a657 1
	xfree(dir);
d698 1
a698 1
	xfree(dir);
d743 2
a744 2
			xfree(lp->l_line);
		xfree(lp);
d747 1
a747 1
	xfree(lines);
d786 3
a788 3
	xfree(av->str);
	xfree(av->argv);
	xfree(av);
@


1.156
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.155 2011/04/20 18:43:57 nicm Exp $	*/
d369 1
a369 1
	char fpath[MAXPATHLEN];
d447 1
a447 1
	char buf[MAXPATHLEN];
d458 1
a458 1
	char fpath[MAXPATHLEN];
d504 1
a504 1
	char buf[MAXPATHLEN];
d568 1
a568 1
	char *entry, *sp, *dp, *dir, *p, rpath[MAXPATHLEN], repo[MAXPATHLEN];
d665 1
a665 1
	char *sp, *dp, *dir, rpath[MAXPATHLEN];
@


1.155
log
@Remove some includes and defines that are no longer needed, from Michael
W Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.154 2010/11/11 21:00:59 nicm Exp $	*/
d771 1
a771 1
		av->argv = xrealloc(av->argv,
@


1.154
log
@Nuke dead assignments and a dead function, from Michael W Bombardieri
using lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.153 2010/09/23 18:10:16 nicm Exp $	*/
a35 1
#include <md5.h>
@


1.153
log
@Add cvs_mkdir() for recursive directory creation on import, based on a
diff from Michael W Bombardieri in PR 6398.

tested by & ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.152 2010/07/23 21:46:05 ray Exp $	*/
a199 23
}

/*
 * cvs_cksum()
 *
 * Calculate the MD5 checksum of the file whose path is <file> and generate
 * a CVS-format 32 hex-digit string, which is stored in <dst>, whose size is
 * given in <len> and must be at least 33.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_cksum(const char *file, char *dst, size_t len)
{
	if (len < CVS_CKSUM_LEN) {
		cvs_log(LP_ERR, "buffer too small for checksum");
		return (-1);
	}
	if (MD5File(file, dst) == NULL) {
		cvs_log(LP_ERR, "failed to generate checksum for %s", file);
		return (-1);
	}

	return (0);
@


1.152
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.151 2009/03/24 06:59:19 joris Exp $	*/
d680 41
@


1.151
log
@use size_t for size, since atomicio() both accepts and returns it
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.150 2009/02/23 21:33:12 joris Exp $	*/
d688 1
a688 1
struct cvs_lines *
d693 2
a694 2
	struct cvs_lines *lines;
	struct cvs_line *lp;
d720 1
a720 1
cvs_freelines(struct cvs_lines *lines)
d722 1
a722 1
	struct cvs_line *lp;
@


1.150
log
@unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.149 2009/02/23 21:32:08 joris Exp $	*/
d873 2
a874 1
	int fds[2], size, st;
@


1.149
log
@we no longer push out Set-sticky to the client when writing
our Tag file on the server or in cvs_mkpath(), this caused
problems for the "fast checkout" mechanism when a tag was supplied.

instead, write out any directory sticky tag when we are checking
out a file in that directory, this way we can use our "fast checkout"
mechanism (no /tmp required) even for -r and -d without breaking
working copies because they were missing CVS/Tag files.

"looks good" tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.148 2009/02/21 13:39:59 joris Exp $	*/
d592 1
a592 2
	char *entry, sticky[CVS_REV_BUFSZ];
	char *sp, *dp, *dir, *p, rpath[MAXPATHLEN], repo[MAXPATHLEN];
@


1.148
log
@in cvs_mkpath() always look for an existing CVS/Repository file
unless we're running checkout or export.
otherwise we'll end up accidently overwriting it in certain cases
on the client side of things.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.147 2008/06/21 15:39:15 joris Exp $	*/
a679 8
		}

		if (cvs_server_active == 1 && strcmp(rpath, ".")) {
			if (tag != NULL) {
				(void)xsnprintf(sticky, sizeof(sticky),
				    "T%s", tag);
				cvs_server_set_sticky(rpath, sticky);
			}
@


1.147
log
@add a hash table mechanism based upon hcreate(3) but one that allows
us to maintain multiple hash tables concurrently.

immediatly start using it to keep track of what directories
we have already created and what CVS dirs we already created so
we do not recreate them when we do not need to.

we will be switching more internals to use this soon.
rejoice for cheaper lookups.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.146 2008/06/14 03:19:15 joris Exp $	*/
d617 1
a617 1
	if (cvs_cmdop == CVS_OP_UPDATE || cvs_cmdop == CVS_OP_COMMIT) {
@


1.146
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.145 2008/06/12 07:16:14 joris Exp $	*/
d44 1
d529 9
d591 1
d594 8
@


1.145
log
@completely kill the need for TMP_DIR when running checkout,
which gives us better performance among other things.

this is however disabled in a few cases:
1) whenever you run checkout over an existing tree (which acts as update)
2) whenever you specify -d or a module alias

we're planning on enabling this behaviour for case 2 in the future.

anoncvs sysadmins now love us even more.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.144 2008/06/10 01:00:35 joris Exp $	*/
a656 1
			cvs_ent_close(ent, ENT_SYNC);
@


1.144
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.143 2008/03/09 12:52:33 joris Exp $	*/
d47 1
d368 1
a368 1
	if (cvs_noexec == 1)
d397 1
a397 1
	if (cvs_noexec == 1)
d861 1
a861 1
cvs_exec(const char *prog, const char *in, int needwait)
@


1.143
log
@be sure to build CVS/Root when updating and building directories (-d)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.142 2008/03/09 01:58:00 joris Exp $	*/
d852 9
a860 2
void
cvs_exec(const char *prog)
d863 2
a864 1
	char *argp[] = { "sh", "-c", NULL, NULL };
d866 4
a869 1
	argp[2] = prog;
d873 1
a873 1
		return;
d875 6
d882 1
a882 1
		cvs_log(LP_ERR, "failed to run '%s'", prog);
d885 20
@


1.142
log
@be sure to create CVS/Root if we added a new directory to the repository.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.141 2008/03/08 22:15:30 tobias Exp $	*/
d46 1
d538 2
a539 1
	if (cvs_cmdop == CVS_OP_CHECKOUT || cvs_cmdop == CVS_OP_ADD) {
@


1.141
log
@CVS/Entries file must be created in cvs_mkadmin, because they have to be
available in empty directories too (containing only "D" then).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.140 2008/03/01 15:10:20 joris Exp $	*/
d537 1
a537 1
	if (cvs_cmdop == CVS_OP_CHECKOUT) {
@


1.140
log
@do not overwrite CVS/Root in an existing tree whenever somebody
specified a CVSROOT using alternate ways (-d or CVSROOT environ variable)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.139 2008/02/10 14:04:40 joris Exp $	*/
d30 1
d33 1
d35 1
d524 1
d557 13
@


1.139
log
@use cvs_validate_directory() in cvs_get_repository_path() as well,
since we want to make sure we have valid CVS/Repository content

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.138 2008/02/10 14:00:42 joris Exp $	*/
d533 3
a535 1
	(void)xsnprintf(buf, sizeof(buf), "%s/%s", path, CVS_PATH_ROOTSPEC);
d537 2
a538 2
	if ((fp = fopen(buf, "w")) == NULL)
		fatal("cvs_mkadmin: %s: %s", buf, strerror(errno));
d540 3
a542 2
	fprintf(fp, "%s\n", root);
	(void)fclose(fp);
@


1.138
log
@introduce cvs_validate_directory(), which is used to check
directory path to make sure they do not fall outside the CVSROOT
or the working copy directory in a remote setup
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.137 2008/02/10 13:01:08 tobias Exp $	*/
d469 1
@


1.137
log
@Respond with "Updated" instead of "Checked-in" on server-side if a client
committed files, so keywords are expanded properly.

On client-side, we have to be careful about Directory ./ when it comes
to commits, so add a test for CVS_OP_COMMIT.

OK and help from joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.136 2008/02/10 11:52:35 joris Exp $	*/
d559 4
@


1.136
log
@- cvs_write_tagfile() is not responsible to remove CVS/Tag itself
- construct right CVS/Repository paths in cvs_mkpath()

fixes remote Issues;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.135 2008/02/09 20:04:00 xsa Exp $	*/
d570 1
a570 1
	if (cvs_cmdop == CVS_OP_UPDATE) {
@


1.135
log
@Introduce cvs_ent_line_str() - formats CVS/Entries lines.
OK tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.134 2008/02/09 16:56:58 joris Exp $	*/
d588 1
a588 1
		} else {
@


1.134
log
@unused var police, biatsh!
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.133 2008/02/09 16:52:27 joris Exp $	*/
d557 1
a557 1
	char entry[CVS_ENT_MAXLINELEN], sticky[CVS_REV_BUFSZ];
d622 5
a627 1
			xsnprintf(entry, sizeof(entry), "D/%s////", dp);
d630 2
@


1.133
log
@if the CVS/ directory already exists when we reach cvs_mkadmin()
we will definatly need to recreate it with the correct information.

otherwise sucessive checkouts of the same module with other arguments
(like -rOPENBSD_X_X or -D "3 years ago") will not store the correct
information.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.132 2008/02/04 19:08:32 joris Exp $	*/
a519 1
	struct stat st;
@


1.132
log
@more CVSROOT/modules stuff:

- support for -i flag:
	Run "prog" on "cvs commit" from top-level of module.
- fix some memory leaks in modules.c
- pass the line number from cvs_read_config() towards the callbacks
  so its easier to print out where it's going wrong, if it ever does.

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.131 2008/02/04 18:23:58 tobias Exp $	*/
a529 3
	if (stat(buf, &st) != -1)
		return;

a546 6
	(void)fclose(fp);

	(void)xsnprintf(buf, sizeof(buf), "%s/%s", path, CVS_PATH_ENTRIES);

	if ((fp = fopen(buf, "w")) == NULL)
		fatal("cvs_mkadmin: %s: %s", buf, strerror(errno));
@


1.131
log
@Stripped off 'nb', which was (or was supposed to be) used to distinguish
between a named branch and a revision number supplied by -r.  This can
be done easier in cvs_write_tagfile directly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.130 2008/02/03 17:20:14 joris Exp $	*/
d36 1
d827 18
@


1.130
log
@better CVSROOT/module support, includes remote support and modules
that are not aliases (-a);

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.129 2008/01/31 22:11:38 joris Exp $	*/
d516 1
a516 1
    char *tag, char *date, int nb)
d523 1
a523 1
		cvs_log(LP_TRACE, "cvs_mkadmin(%s, %s, %s, %s, %s, %d)",
d525 1
a525 1
		    (date != NULL) ? date : "", nb);
d557 1
a557 1
	cvs_write_tagfile(path, tag, date, nb);
d626 1
a626 1
		    tag, NULL, 0);
@


1.129
log
@free RCSNUM's when we are done with them;

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.128 2008/01/31 22:09:05 xsa Exp $	*/
d593 12
a604 2
		if (repo[0] != '\0') {
			len = strlcat(repo, "/", sizeof(repo));
a607 4

		len = strlcat(repo, sp, sizeof(repo));
		if (len >= (int)sizeof(repo))
			fatal("cvs_mkpath: overflow");
@


1.128
log
@Zap trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.127 2008/01/31 16:44:46 tobias Exp $	*/
d793 3
a798 5

	if (lnum != NULL)
		rcsnum_free(lnum);
	if (rnum != NULL)
		rcsnum_free(rnum);
@


1.127
log
@Rework of cvs_get_repository_name.

checkout is allowed to continue if CVS/Repository does not exist.
export and import are not supposed to open CVS/Repository.
All other commands -- if CVS_USE_WDIR is set -- must fatal if it does
not exist.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.126 2008/01/31 10:17:47 tobias Exp $	*/
d436 1
a436 1
		case CVS_DIR: 
@


1.126
log
@Our directory entries in CVS/Entries had one slash too much -- zapped.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.125 2008/01/21 16:36:46 tobias Exp $	*/
d476 4
a479 4
	/* During checkout -p, do not use any locally available files. */
	if (cvs_cmdop == CVS_OP_CHECKOUT && print_stdout) {
		dst[0] = '\0';
		if (strlcat(dst, dir, len) >= len)
d484 11
a494 10
	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s",
	    dir, CVS_PATH_REPOSITORY);

	if (cvs_cmdop != CVS_OP_IMPORT && (fp = fopen(fpath, "r")) != NULL) {
		if ((fgets(dst, len, fp)) == NULL)
			fatal("cvs_get_repository_name: bad repository file");
		dst[strcspn(dst, "\n")] = '\0';
		(void)fclose(fp);
	} else {
		dst[0] = '\0';
d496 2
a497 2
		if (cvs_cmdop == CVS_OP_IMPORT) {
			if (strlcpy(dst, import_repository, len) >= len)
d499 12
a510 17
			if (strlcat(dst, "/", len) >= len)
				fatal("cvs_get_repository_name: truncation");

			if (strcmp(dir, ".")) {
				if (strlcat(dst, dir, len) >= len) {
					fatal("cvs_get_repository_name: "
					    "truncation");
				}
			}
		} else {
			if ((cvs_cmdop == CVS_OP_EXPORT && strcmp(dir, ".")) ||
			    cvs_cmdop != CVS_OP_CHECKOUT) {
				if (strlcat(dst, dir, len) >= len)
					fatal("cvs_get_repository_name: "
					    "truncation");
			}
		}
@


1.125
log
@Fixed export to be fully functional and compliant to GNU cvs in local and
remote setups.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.124 2008/01/10 10:09:27 tobias Exp $	*/
d630 1
a630 1
			xsnprintf(entry, sizeof(entry), "D/%s/////", dp);
@


1.124
log
@xmalloc + memset -> xcalloc
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.123 2008/01/10 10:08:22 tobias Exp $	*/
d508 2
a509 1
			if (cvs_cmdop != CVS_OP_CHECKOUT) {
d619 3
@


1.123
log
@another strcspn() round
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.122 2008/01/10 10:00:53 tobias Exp $	*/
d656 1
a656 2
	lines = xmalloc(sizeof(*lines));
	memset(lines, 0, sizeof(*lines));
d659 1
a659 2
	lp = xmalloc(sizeof(*lp));
	memset(lp, 0, sizeof(*lp));
d666 1
a666 2
			lp = xmalloc(sizeof(*lp));
			memset(lp, 0, sizeof(*lp));
@


1.122
log
@cvs_mkpath missed to add all "yet to be added" directories into CVS/Entries,
thus making further access to these subdirectories rather difficult.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.121 2007/10/09 12:14:09 tobias Exp $	*/
d474 1
a474 1
	char *s, fpath[MAXPATHLEN];
d490 1
a490 4

		if ((s = strchr(dst, '\n')) != NULL)
			*s = '\0';

@


1.121
log
@cvs import must not parse files in local CVS directory.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.120 2007/10/05 19:28:23 gilles Exp $	*/
d569 1
d572 2
a573 2
	char sticky[CVS_REV_BUFSZ];
	char *sp, *dp, *dir, rpath[MAXPATHLEN], repo[MAXPATHLEN];
d624 11
@


1.120
log
@strcspn() change

was okay'd by pyr@@ and ok by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.119 2007/09/22 16:01:22 joris Exp $	*/
d487 1
a487 1
	if ((fp = fopen(fpath, "r")) != NULL) {
@


1.119
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.118 2007/09/19 12:04:38 tobias Exp $	*/
d588 1
a588 2
			if ((len = strlen(repo)) && repo[len - 1] == '\n')
				repo[len - 1] = '\0';
@


1.118
log
@Do not parse quoted strings because GNU cvs won't do so.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.117 2007/09/19 11:53:27 tobias Exp $	*/
d571 1
d626 5
a630 2
			if (tag != NULL)
				cvs_server_set_sticky(rpath, tag);
@


1.117
log
@Usage of fgetln() instead of fgets() in .cvsrc parsing handles line
numbers better and allows longer command arguments.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.116 2007/09/09 20:24:06 tobias Exp $	*/
d231 1
a231 1
	char qbuf[128], *linebuf, *lp, *cp, *arg;
d241 5
a245 34
		if (*lp == '"') {
			/* double-quoted string */
			lp++;
			i = 0;
			memset(qbuf, 0, sizeof(qbuf));
			while (*lp != '"') {
				if (*lp == '\\')
					lp++;
				if (*lp == '\0') {
					cvs_log(LP_ERR, "no terminating quote");
					error++;
					break;
				}

				qbuf[i++] = *lp++;
				if (i == sizeof(qbuf) - 1) {
					error++;
					break;
				}
			}
			if (error)
				break;
			lp++;

			arg = qbuf;
		} else {
			cp = strsep(&lp, " \t");
			if (cp == NULL)
				break;
			else if (*cp == '\0')
				continue;

			arg = cp;
		}
d252 1
a252 1
		argv[argc] = xstrdup(arg);
@


1.116
log
@Added support for checkout -p with local repository.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.115 2007/09/04 19:07:04 tobias Exp $	*/
a228 1
	size_t l;
d231 1
a231 1
	char linebuf[256], qbuf[128], *lp, *cp, *arg;
d233 1
a233 3
	l = strlcpy(linebuf, line, sizeof(linebuf));
	if (l >= sizeof(linebuf))
		fatal("cvs_getargv: string truncation");
d292 1
@


1.115
log
@Removed dead code.

OK joris@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.114 2007/09/02 11:40:03 tobias Exp $	*/
d41 2
d506 8
@


1.114
log
@Handle quotation marks in .cvsrc correctly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.113 2007/07/19 06:34:15 ray Exp $	*/
a703 32
}

BUF *
cvs_patchfile(u_char *data, size_t dlen, u_char *patch, size_t plen,
    int (*p)(struct cvs_lines *, struct cvs_lines *))
{
	struct cvs_lines *dlines, *plines;
	struct cvs_line *lp;
	BUF *res;

	if ((dlines = cvs_splitlines(data, dlen)) == NULL)
		return (NULL);

	if ((plines = cvs_splitlines(patch, plen)) == NULL)
		return (NULL);

	if (p(dlines, plines) < 0) {
		cvs_freelines(dlines);
		cvs_freelines(plines);
		return (NULL);
	}

	res = cvs_buf_alloc(1024, BUF_AUTOEXT);
	TAILQ_FOREACH(lp, &dlines->l_lines, l_list) {
		if (lp->l_line == NULL)
			continue;
		cvs_buf_append(res, lp->l_line, lp->l_len);
	}

	cvs_freelines(dlines);
	cvs_freelines(plines);
	return (res);
@


1.113
log
@xcalloc is unneeded here since i is always 0 and we always use the
memory after initializing it.

Initial diff from Igor Zinovik.

OK niallo and xsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.112 2007/07/03 13:22:43 joris Exp $	*/
d262 3
@


1.112
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.111 2007/05/29 00:19:10 ray Exp $	*/
d751 1
a751 1
	av->argv = xcalloc(i + 1, sizeof(*(av->argv)));
@


1.111
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.110 2007/05/27 00:37:46 ray Exp $	*/
d39 1
d585 1
a585 1
cvs_mkpath(const char *path)
d640 6
a645 1
		    NULL, NULL, 0);
@


1.110
log
@Fix off-by-one, from Tobias Stoeckmann.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.109 2007/05/09 21:19:28 xsa Exp $	*/
a739 1
	char **nargv;
d749 1
a749 1
		nargv = xrealloc(av->argv,
a750 1
		av->argv = nargv;
@


1.109
log
@cvs_splitpath() isn't used anymore; from Tobias Stoeckmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.108 2007/04/20 08:36:00 xsa Exp $	*/
d256 1
a256 1
				if (i == sizeof(qbuf)) {
@


1.108
log
@- correct signal handling and process waiting for the EDITOR support code
(From ray's code in sendbug(1))
- nuke cvs_exec() as it is not used anymore

Prompted by deraadt@@ a few weeks ago.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.107 2007/02/22 06:42:09 otto Exp $	*/
a212 39
}

/*
 * cvs_splitpath()
 *
 * Split a path <path> into the base portion and the filename portion.
 * The path is copied in <base> and the last delimiter is replaced by a NUL
 * byte.  The <file> pointer is set to point to the first character after
 * that delimiter.
 * Returns 0 on success, or -1 on failure.
 */
void
cvs_splitpath(const char *path, char *base, size_t blen, char **file)
{
	size_t rlen;
	char *sp;

	if ((rlen = strlcpy(base, path, blen)) >= blen)
		fatal("cvs_splitpath: path truncation");

	while (rlen > 0 && base[rlen - 1] == '/')
		base[--rlen] = '\0';

	sp = strrchr(base, '/');
	if (sp == NULL) {
		rlen = strlcpy(base, "./", blen);
		if (rlen >= blen)
			fatal("cvs_splitpath: path truncation");

		rlen = strlcat(base, path, blen);
		if (rlen >= blen)
			fatal("cvs_splitpath: path truncation");

		sp = base + 1;
	}

	*sp = '\0';
	if (file != NULL)
		*file = sp + 1;
@


1.107
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.106 2007/02/19 11:40:00 otto Exp $	*/
a369 24
}

/*
 * cvs_exec()
 */
int
cvs_exec(int argc, char **argv)
{
	int ret;
	pid_t pid;

	if ((pid = fork()) == -1) {
		cvs_log(LP_ERR, "failed to fork");
		return (-1);
	} else if (pid == 0) {
		execvp(argv[0], argv);
		cvs_log(LP_ERR, "failed to exec %s", argv[0]);
		exit(1);
	}

	if (waitpid(pid, &ret, 0) == -1)
		cvs_log(LP_ERR, "failed to waitpid");

	return (ret);
@


1.106
log
@Fix const inconsistencies, void pointer artithmetic and a few other
things. now gcc -Wall and lint are more happy. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.105 2007/02/17 18:23:43 xsa Exp $	*/
d29 8
a36 1
#include "includes.h"
a38 2
#include "log.h"
#include "util.h"
@


1.105
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.104 2007/02/07 23:47:56 todd Exp $	*/
d707 1
a707 1
cvs_splitlines(const u_char *data, size_t len)
d756 1
a756 1
cvs_patchfile(const u_char *data, size_t dlen, const u_char *patch, size_t plen,
@


1.104
log
@fstat() -> lstat() in a few select cases,
this fixes a bug where opencvs update would abort if a link existed that
pointed to a non-existent file/dir
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.103 2007/01/26 11:19:44 joris Exp $	*/
a465 1
	size_t len;
d487 2
a488 3
		len = cvs_path_cat(path, ent->d_name, fpath, sizeof(fpath));
		if (len >= sizeof(fpath))
			fatal("cvs_rmdir: path truncation");
a543 32
/*
 * cvs_path_cat()
 *
 * Concatenate the two paths <base> and <end> and store the generated path
 * into the buffer <dst>, which can accept up to <dlen> bytes, including the
 * NUL byte.  The result is guaranteed to be NUL-terminated.
 * Returns the number of bytes necessary to store the full resulting path,
 * not including the NUL byte (a value equal to or larger than <dlen>
 * indicates truncation).
 */
size_t
cvs_path_cat(const char *base, const char *end, char *dst, size_t dlen)
{
	size_t len;

	len = strlcpy(dst, base, dlen);
	if (len >= dlen - 1) {
		errno = ENAMETOOLONG;
		fatal("overflow in cvs_path_cat");
	} else {
		dst[len] = '/';
		dst[len + 1] = '\0';
		len = strlcat(dst, end, dlen);
		if (len >= dlen) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERR, "%s", dst);
		}
	}

	return (len);
}

d550 1
a550 2
	if (cvs_path_cat(current_cvsroot->cr_dir, buf, dst, len) >= len)
		fatal("cvs_get_repository_path: truncation");
d559 2
a560 3
	if (cvs_path_cat(dir, CVS_PATH_REPOSITORY,
	    fpath, sizeof(fpath)) >= sizeof(fpath))
		fatal("cvs_get_repository_name: truncation");
a599 1
	size_t len;
d608 1
a608 3
	len = cvs_path_cat(path, CVS_PATH_CVSDIR, buf, sizeof(buf));
	if (len >= sizeof(buf))
		fatal("cvs_mkadmin: truncation");
d616 1
a616 3
	len = cvs_path_cat(path, CVS_PATH_ROOTSPEC, buf, sizeof(buf));
	if (len >= sizeof(buf))
		fatal("cvs_mkadmin: truncation");
d624 1
a624 3
	len = cvs_path_cat(path, CVS_PATH_REPOSITORY, buf, sizeof(buf));
	if (len >= sizeof(buf))
		fatal("cvs_mkadmin: truncation");
d632 1
a632 3
	len = cvs_path_cat(path, CVS_PATH_ENTRIES, buf, sizeof(buf));
	if (len >= sizeof(buf))
		fatal("cvs_mkadmin: truncation");
@


1.103
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.102 2007/01/25 18:35:30 niallo Exp $	*/
d493 1
a493 1
			if (stat(fpath, &st) == -1)
@


1.102
log
@plug a memleak in keyword expansion.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.101 2007/01/20 16:52:39 thib Exp $	*/
a575 29
}

/*
 * a hack to mimic and thus match gnu cvs behaviour.
 */
time_t
cvs_hack_time(time_t oldtime, int togmt)
{
	int l;
	struct tm *t;
	char tbuf[32];

	if (togmt == 1) {
		t = gmtime(&oldtime);
		if (t == NULL)
			fatal("gmtime failed");

		return (mktime(t));
	}

	t = localtime(&oldtime);

	l = snprintf(tbuf, sizeof(tbuf), "%d/%d/%d GMT %d:%d:%d",
	    t->tm_mon + 1, t->tm_mday, t->tm_year + 1900, t->tm_hour,
	    t->tm_min, t->tm_sec);
	if (l == -1 || l >= (int)sizeof(tbuf))
		fatal("cvs_hack_time: overflow");

	return (cvs_date_parse(tbuf));
@


1.101
log
@Add missing check for fgets return value in
cvs_get_repository_name().

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.100 2007/01/20 01:07:51 niallo Exp $	*/
d801 1
d821 2
@


1.100
log
@sweep opencvs for missing rcs_translate_tag() return checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.99 2007/01/19 23:55:31 todd Exp $	*/
d628 2
a629 1
		fgets(dst, len, fp);
@


1.99
log
@another place to check for DT_UNKNOWN for d_type for afs/nfs
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.98 2007/01/17 17:54:50 joris Exp $	*/
d937 2
a938 1
		lnum = rcs_translate_tag(lstr, file);
d941 2
a942 1
			rnum = rcs_translate_tag(rstr, file);
@


1.98
log
@add support for remote checkout in both our client and server,
with this the last real dependency to actually be able to use opencvs
in a remote setup has been added.

based upon an initial diff from xsa@@
'kay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.97 2007/01/11 17:44:18 niallo Exp $	*/
d465 1
a465 1
	int ret = -1;
d469 1
d492 30
a521 1
		if (ent->d_type == DT_DIR) {
d524 8
a531 2
		} else if (cvs_unlink(fpath) == -1 && errno != ENOENT)
			goto done;
@


1.97
log
@rework opencvs so that we can deal with binary files.  previously we assumed all files were ascii,
which broke things in real-world usage.  now a checkout of src should work, albeit using lots of
memory and cpu.  fixing this is the next step.

testing by many.
ok & some input joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.96 2007/01/07 01:53:12 joris Exp $	*/
d614 5
a618 2
			if (strlcat(dst, dir, len) >= len)
				fatal("cvs_get_repository_name: truncation");
d733 1
a733 1
		cvs_mkadmin(rpath, current_cvsroot->cr_dir, repo,
@


1.96
log
@zap-o-matic 2007:
- zap unused argument to cvs_exec()
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.95 2007/01/03 14:08:09 xsa Exp $	*/
d741 1
a741 1
cvs_splitlines(const char *fcont)
d743 2
a744 1
	char *dcp;
d749 1
a750 2
	lines->l_nblines = 0;
	lines->l_data = xstrdup(fcont);
d753 1
a753 2
	lp->l_line = NULL;
	lp->l_lineno = 0;
d756 12
a767 10
	for (dcp = lines->l_data; *dcp != '\0';) {
		lp = xmalloc(sizeof(*lp));
		lp->l_line = dcp;
		lp->l_lineno = ++(lines->l_nblines);
		TAILQ_INSERT_TAIL(&(lines->l_lines), lp, l_list);

		dcp = strchr(dcp, '\n');
		if (dcp == NULL)
			break;
		*(dcp++) = '\0';
a782 1
	xfree(lines->l_data);
d787 1
a787 1
cvs_patchfile(const char *data, const char *patch,
a791 2
	size_t len;
	int lineno;
d794 1
a794 3
	len = strlen(data);

	if ((dlines = cvs_splitlines(data)) == NULL)
d797 1
a797 1
	if ((plines = cvs_splitlines(patch)) == NULL)
d806 1
a806 2
	lineno = 0;
	res = cvs_buf_alloc(len, BUF_AUTOEXT);
d808 3
a810 3
		if (lineno != 0)
			cvs_buf_fappend(res, "%s\n", lp->l_line);
		lineno++;
@


1.95
log
@bring back cvs_yesno() as is it going to be used pretty soon now.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.94 2006/12/05 15:59:48 xsa Exp $	*/
d371 1
a371 1
cvs_exec(int argc, char **argv, int fds[3])
@


1.94
log
@unlink(2) sets errno, use it for error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.93 2006/12/05 11:01:05 xsa Exp $	*/
d932 19
@


1.93
log
@rmdir(2) sets errno, use it for error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.92 2006/11/28 14:49:58 xsa Exp $	*/
d449 1
a449 1
		cvs_log(LP_ERR, "cannot remove `%s'", path);
@


1.92
log
@snprintf() -> cvs_path_cat()
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.91 2006/10/11 22:00:22 thib Exp $	*/
d500 1
a500 1
		cvs_log(LP_ERR, "failed to remove '%s'", path);
@


1.91
log
@check fgets(3) return value and also fix a
buf[strlen(buf) - 1] = something; misuse.

ok niallo@@, cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.90 2006/07/09 01:47:20 joris Exp $	*/
a573 1
	int l;
d577 2
a578 3
	l = snprintf(dst, len, "%s/%s", current_cvsroot->cr_dir, buf);
	if (l == -1 || l >= (int)len)
		fatal("cvs_get_repository_path: overflow");
a583 1
	int l;
d587 3
a589 3
	l = snprintf(fpath, sizeof(fpath), "%s/%s", dir, CVS_PATH_REPOSITORY);
	if (l == -1 || l >= (int)sizeof(fpath))
		fatal("cvs_get_repository_name: overflow");
@


1.90
log
@more straightforward trace (-t) output, too much is just too noisy.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.89 2006/07/07 17:37:17 joris Exp $	*/
d697 4
a700 3
			fgets(repo, sizeof(repo), fp);
			if (repo[strlen(repo) - 1] == '\n')
				repo[strlen(repo) - 1] = '\0';
@


1.89
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.88 2006/06/14 20:28:53 joris Exp $	*/
d420 2
a421 1
	cvs_log(LP_TRACE, "cvs_rename(%s,%s)", from, to);
d442 2
a443 1
	cvs_log(LP_TRACE, "cvs_unlink(%s)", path);
d471 2
a472 1
	cvs_log(LP_TRACE, "cvs_rmdir(%s)", path);
d632 4
a635 3
	cvs_log(LP_TRACE, "cvs_mkadmin(%s, %s, %s, %s, %s, %d)",
	    path, root, repo, (tag != NULL) ? tag : "",
	    (date != NULL) ? date : "", nb);
d688 3
a690 1
	cvs_log(LP_TRACE, "cvs_mkpath(%s)", dir);
@


1.88
log
@simplify cvs_hack_time() and the way it is called;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.87 2006/06/14 15:14:47 xsa Exp $	*/
d102 1
a102 2
			cvs_log(LP_ERR, "failed to scan mode string `%s'", sp);
			continue;
d119 1
a119 2
				cvs_log(LP_ERR,
				    "invalid permission bit `%c'", *sp);
@


1.87
log
@handle existing CVS/Tag file when adding new directories. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.86 2006/06/07 22:20:59 reyk Exp $	*/
d554 1
a554 1
			return (0);
d565 1
a565 1
		return (0);
@


1.86
log
@a bug in cvs_mkpath() prevented to create the CVS admin directory and
files under some special circumstances. remove a bogus stat() check to
fix it.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.85 2006/05/30 19:30:11 joris Exp $	*/
d623 2
a624 1
cvs_mkadmin(const char *path, const char *root, const char *repo)
d631 3
a633 1
	cvs_log(LP_TRACE, "cvs_mkadmin(%s, %s, %s)", path, root, repo);
d672 2
d728 2
a729 1
		cvs_mkadmin(rpath, current_cvsroot->cr_dir, repo);
@


1.85
log
@make sure cvs_get_repository_path returns a valid repo name
for the import command.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.84 2006/05/30 07:00:30 joris Exp $	*/
a675 1
	struct stat st;
a718 3

		if (stat(repo, &st) != -1)
			continue;
@


1.84
log
@hello import, only works for non-existing repositories right now,
but work is in progress for importing stuff into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.83 2006/05/29 07:16:44 joris Exp $	*/
d605 1
a605 1
				fatal("cvs_get_repository_name: overflow");
d607 11
a617 1
				fatal("cvs_get_repository_name: overflow");
a618 3

		if (strlcat(dst, dir, len) >= len)
			fatal("cvs_get_repository_name: overflow");
@


1.83
log
@make the log command use rcs_translate_tag
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.82 2006/05/28 21:34:37 joris Exp $	*/
d601 10
a610 1
		if (strlcpy(dst, dir, len) >= len)
@


1.82
log
@add code which allows us to select revisions based upon
a string given by the user on the command line, much like
rcs_revision_select in OpenRCS.

this will be usefull for some commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.81 2006/05/28 17:25:18 joris Exp $	*/
d883 1
a883 2
		if ((lnum = rcsnum_parse(lstr)) == NULL)
			fatal("invalid revision %s", lstr);
d886 1
a886 2
			if ((rnum = rcsnum_parse(rstr)) == NULL)
				fatal("invalid revision %s", rstr);
@


1.81
log
@several fixes to the file api:
- default to CVS_FILE when something is totally unknown
- cvs_get_repository_path() now returns the full repository path for
  the given argument.
- cvs_get_repository_name() returns the contents of CVS/Repository
  to the caller.
- allow command callbacks to specify if our recursion code needs
  to skip the directory or not.
- when checking for a admin directory, make sure it is in fact
  a directory. if it is not we dont want to recurse inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.80 2006/05/27 16:18:23 joris Exp $	*/
d844 70
@


1.80
log
@boogie cvs_yesno() down the removal hatch, it is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.79 2006/05/27 03:30:31 joris Exp $	*/
d571 13
a583 1
cvs_get_repo(const char *dir, char *dst, size_t len)
d587 1
a587 4
	char *s, buf[MAXPATHLEN], fpath[MAXPATHLEN];

	if (strlcpy(buf, dir, sizeof(buf)) >= sizeof(buf))
		fatal("cvs_get_repo: truncation");
d591 1
a591 1
		fatal("cvs_get_repo: overflow");
d594 1
a594 1
		fgets(buf, sizeof(buf), fp);
d596 1
a596 1
		if ((s = strrchr(buf, '\n')) != NULL)
d600 3
a603 4

	l = snprintf(dst, len, "%s/%s", current_cvsroot->cr_dir, buf);
	if (l == -1 || l >= (int)len)
		fatal("cvs_get_repo: overflow");
@


1.79
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.78 2006/04/14 02:45:35 deraadt Exp $	*/
a792 25
}

/*
 * cvs_yesno()
 *
 * Read from standart input for `y' or `Y' character.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_yesno(void)
{
	int c, ret;

	ret = 0;

	fflush(stderr);
	fflush(stdout);

	if ((c = getchar()) != 'y' && c != 'Y')
		ret = -1;
	else
		while (c != EOF && c != '\n')
			c = getchar();

	return (ret);
@


1.78
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.77 2006/04/05 01:38:56 ray Exp $	*/
a34 1
#if !defined(RCSPROG)
a68 41


/*
 * cvs_readrepo()
 *
 * Read the path stored in the `Repository' CVS file for a given directory
 * <dir>, and store that path into the buffer pointed to by <dst>, whose size
 * is <len>.
 */
int
cvs_readrepo(const char *dir, char *dst, size_t len)
{
	size_t dlen, l;
	FILE *fp;
	char repo_path[MAXPATHLEN];

	l = cvs_path_cat(dir, "CVS/Repository", repo_path, sizeof(repo_path));
	if (l >= sizeof(repo_path))
		return (-1);

	fp = fopen(repo_path, "r");
	if (fp == NULL)
		return (-1);

	if (fgets(dst, (int)len, fp) == NULL) {
		if (ferror(fp)) {
			cvs_log(LP_ERRNO, "failed to read from `%s'",
			    repo_path);
		}
		(void)fclose(fp);
		return (-1);
	}
	dlen = strlen(dst);
	if (dlen > 0 && dst[dlen - 1] == '\n')
		dst[--dlen] = '\0';

	(void)fclose(fp);
	return (0);
}


d102 1
a102 1
			cvs_log(LP_WARN, "failed to scan mode string `%s'", sp);
d108 1
a108 1
			cvs_log(LP_WARN,
d120 1
a120 1
				cvs_log(LP_WARN,
a129 1

d201 1
a201 1
		cvs_log(LP_WARN, "buffer too small for checksum");
d205 1
a205 1
		cvs_log(LP_ERRNO, "failed to generate checksum for %s", file);
a327 1

a353 1

a368 70

/*
 * cvs_mkadmin()
 *
 * Create the CVS administrative files within the directory <cdir>.  If the
 * files already exist, they are kept as is.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_mkadmin(const char *dpath, const char *rootpath, const char *repopath,
    char *tag, char *date, int nb)
{
	size_t l;
	char path[MAXPATHLEN];
	FILE *fp;
	CVSENTRIES *ef;
	struct stat st;

	cvs_log(LP_TRACE, "cvs_mkadmin(%s, %s, %s, %s, %s, %d)",
	    dpath, rootpath, repopath, tag ? tag : "", date ? date : "", nb);

	l = cvs_path_cat(dpath, CVS_PATH_CVSDIR, path, sizeof(path));
	if (l >= sizeof(path))
		fatal("cvs_mkadmin: path truncation");

	if (mkdir(path, 0755) == -1 && errno != EEXIST)
		fatal("cvs_mkadmin: mkdir: `%s': %s", path, strerror(errno));

	/* just create an empty Entries file */
	ef = cvs_ent_open(dpath, O_WRONLY);
	if (ef != NULL)
		cvs_ent_close(ef);

	l = cvs_path_cat(dpath, CVS_PATH_ROOTSPEC, path, sizeof(path));
	if (l >= sizeof(path))
		fatal("cvs_mkadmin: path truncation");

	if (stat(path, &st) == -1 && errno == ENOENT) {
		if ((fp = fopen(path, "w")) == NULL)
			fatal("cvs_mkadmin: fopen: `%s': %s",
			    path, strerror(errno));

		if (rootpath != NULL)
			fprintf(fp, "%s\n", rootpath);
		(void)fclose(fp);
	}

	l = cvs_path_cat(dpath, CVS_PATH_REPOSITORY, path, sizeof(path));
	if (l >= sizeof(path))
		fatal("cvs_mkadmin: path truncation");

	if (stat(path, &st) == -1 && errno == ENOENT) {
		if ((fp = fopen(path, "w")) == NULL)
			fatal("cvs_mkadmin: fopen: `%s': %s",
			    path, strerror(errno));

		if (repopath != NULL)
			fprintf(fp, "%s\n", repopath);
		(void)fclose(fp);
	}

	/* create CVS/Tag file (if needed) */
	/* XXX correct? */
	if (tag != NULL || date != NULL)
		(void)cvs_write_tagfile(tag, date, nb);

	return (0);
}


d379 1
a379 1
		cvs_log(LP_ERRNO, "failed to fork");
d383 1
a383 1
		cvs_log(LP_ERRNO, "failed to exec %s", argv[0]);
d388 1
a388 1
		cvs_log(LP_ERRNO, "failed to waitpid");
d449 1
a449 1
		cvs_log(LP_ERRNO, "cannot remove `%s'", path);
d477 1
a477 1
		cvs_log(LP_ERRNO, "failed to open '%s'", path);
d499 1
a499 1
		cvs_log(LP_ERRNO, "failed to remove '%s'", path);
a509 101
 * Create a directory, and the parent directories if needed.
 * based upon mkpath() from mkdir.c
 */
int
cvs_create_dir(const char *path, int create_adm, char *root, char *repo)
{
	int ret;
	char *d, *s;
	struct stat sb;
	char rpath[MAXPATHLEN], entry[MAXPATHLEN];
	CVSENTRIES *entf;
	struct cvs_ent *ent;

	if (create_adm == 1 && root == NULL)
		fatal("cvs_create_dir failed");

	s = xstrdup(path);
	rpath[0] = '\0';
	if (repo != NULL) {
		if (strlcpy(rpath, repo, sizeof(rpath)) >= sizeof(rpath))
			fatal("cvs_create_dir: path truncation");

		if (strlcat(rpath, "/", sizeof(rpath)) >= sizeof(rpath))
			fatal("cvs_create_dir: path truncation");
	}

	ret = -1;
	entf = NULL;
	d = strtok(s, "/");
	while (d != NULL) {
		if (stat(d, &sb)) {
			/* try to create the directory */
			if (errno != ENOENT ||
			    (mkdir(d, 0755) && errno != EEXIST)) {
				cvs_log(LP_ERRNO, "failed to create `%s'", d);
				goto done;
			}
		} else if (!S_ISDIR(sb.st_mode)) {
			cvs_log(LP_ERR, "`%s' not a directory", d);
			goto done;
		}

		/*
		 * Create administrative files if requested.
		 */
		if (create_adm == 1) {
			if (strlcat(rpath, d, sizeof(rpath)) >= sizeof(rpath))
				fatal("cvs_create_dir: path truncation");

			if (strlcat(rpath, "/", sizeof(rpath)) >= sizeof(rpath))
				fatal("cvs_create_dir: path truncation");

			cvs_mkadmin(d, root, rpath, NULL, NULL, 0);
		}

		/*
		 * Add it to the parent directory entry file.
		 * (if any).
		 */
		entf = cvs_ent_open(".", O_RDWR);
		if (entf != NULL && strcmp(d, ".")) {
			if (strlcpy(entry, "D/", sizeof(entry)) >=
			    sizeof(entry) ||
			    strlcat(entry, d, sizeof(entry)) >= sizeof(entry) ||
			    strlcat(entry, "////", sizeof(entry)) >=
			    sizeof(entry))
				fatal("cvs_create_dir: overflow in entry buf");

			if ((ent = cvs_ent_parse(entry)) == NULL) {
				cvs_log(LP_ERR, "failed to parse entry");
				goto done;
			}

			cvs_ent_remove(entf, d, 0);

			if (cvs_ent_add(entf, ent) < 0) {
				cvs_log(LP_ERR, "failed to add entry");
				goto done;
			}
		}

		if (entf != NULL) {
			cvs_ent_close(entf);
			entf = NULL;
		}

		/* All went ok, switch to the newly created directory. */
		cvs_chdir(d, 0);

		d = strtok(NULL, "/");
	}

	ret = 0;
done:
	if (entf != NULL)
		cvs_ent_close(entf);
	xfree(s);
	return (ret);
}

/*
d527 1
a527 1
		cvs_log(LP_ERRNO, "%s", dst);
d534 1
a534 1
			cvs_log(LP_ERRNO, "%s", dst);
d542 1
a542 6
 * cvs_rcs_getpath()
 *
 * Get the RCS path of the file <file> and store it in <buf>, which is
 * of size <len>. For portability, it is recommended that <buf> always be
 * at least MAXPATHLEN bytes long.
 * Returns a pointer to the start of the path on success, or NULL on failure.
d544 2
a545 2
char *
cvs_rcs_getpath(CVSFILE *file, char *buf, size_t len)
d547 8
a554 2
	char *repo;
	struct cvsroot *root;
d556 2
a557 2
	root = CVS_DIR_ROOT(file);
	repo = CVS_DIR_REPO(file);
d559 1
a559 7
	if (strlcpy(buf, root->cr_dir, len) >= len ||
	    strlcat(buf, "/", len) >= len ||
	    strlcat(buf, repo, len) >= len ||
	    strlcat(buf, "/", len) >= len ||
	    strlcat(buf, file->cf_name, len) >= len ||
	    strlcat(buf, RCS_FILE_EXT, len) >= len)
		fatal("cvs_rcs_getpath: path truncation");
d561 7
a567 1
	return (buf);
a569 5
/*
 * cvs_write_tagfile()
 *
 * Write the CVS/Tag file for current directory.
 */
d571 1
a571 1
cvs_write_tagfile(char *tag, char *date, int nb)
d573 1
d575 1
a575 1
	char tagpath[MAXPATHLEN];
d577 9
a585 2
	if (cvs_noexec == 1)
		return;
d587 2
a588 2
	if (strlcpy(tagpath, CVS_PATH_TAG, sizeof(tagpath)) >= sizeof(tagpath))
		return;
a589 17
	if (tag != NULL || date != NULL) {
		fp = fopen(tagpath, "w+");
		if (fp == NULL) {
			if (errno != ENOENT)
				cvs_log(LP_NOTICE,
				    "failed to open `%s' : %s", tagpath,
				    strerror(errno));
			return;
		}
		if (tag != NULL) {
			if (nb != 0)
				fprintf(fp, "N%s\n", tag);
			else
				fprintf(fp, "T%s\n", tag);
		} else {
			fprintf(fp, "D%s\n", date);
		}
a590 3
	} else {
		cvs_unlink(tagpath);
		return;
d592 4
a597 12
/*
 * cvs_parse_tagfile()
 *
 * Parse the CVS/Tag file for current directory.
 *
 * If it contains a branch tag, sets <tagp>.
 * If it contains a date, sets <datep>.
 * If it contains a non-branch tag, sets <nbp>.
 *
 * Returns nothing but an error message, and sets <tagp>, <datep> to NULL
 * and <nbp> to 0.
 */
d599 1
a599 1
cvs_parse_tagfile(char **tagp, char **datep, int *nbp)
a601 1
	int linenum;
d603 2
a604 1
	char linebuf[128], tagpath[MAXPATHLEN];
d606 1
a606 2
	if (tagp != NULL)
		*tagp = (char *)NULL;
d608 3
a610 2
	if (datep != NULL)
		*datep = (char *)NULL;
d612 2
a613 2
	if (nbp != NULL)
		*nbp = 0;
d615 12
a626 2
	if (strlcpy(tagpath, CVS_PATH_TAG, sizeof(tagpath)) >= sizeof(tagpath))
		return;
d628 3
a630 7
	fp = fopen(tagpath, "r");
	if (fp == NULL) {
		if (errno != ENOENT)
			cvs_log(LP_NOTICE, "failed to open `%s' : %s", tagpath,
			    strerror(errno));
		return;
	}
d632 2
a633 1
	linenum = 0;
d635 2
a636 10
	while (fgets(linebuf, (int)sizeof(linebuf), fp) != NULL) {
		linenum++;
		if ((len = strlen(linebuf)) == 0)
			continue;
		if (linebuf[len -1] != '\n') {
			cvs_log(LP_WARN, "line too long in `%s:%d'", tagpath,
			    linenum);
			break;
		}
		linebuf[--len] = '\0';
d638 3
a640 21
		switch (*linebuf) {
		case 'T':
			if (tagp != NULL)
				*tagp = xstrdup(linebuf);
			break;
		case 'D':
			if (datep != NULL)
				*datep = xstrdup(linebuf);
			break;
		case 'N':
			if (tagp != NULL)
				*tagp = xstrdup(linebuf);
			if (nbp != NULL)
				*nbp = 1;
			break;
		default:
			break;
		}
	}
	if (ferror(fp))
		cvs_log(LP_NOTICE, "failed to read line from `%s'", tagpath);
d642 2
d647 2
a648 5
/*
 * a hack to mimic and thus match gnu cvs behaviour.
 */
time_t
cvs_hack_time(time_t oldtime, int togmt)
d650 9
a658 3
	int l;
	struct tm *t;
	char tbuf[32];
d660 2
a661 4
	if (togmt == 1) {
		t = gmtime(&oldtime);
		if (t == NULL)
			return (0);
d663 7
a669 1
		return (mktime(t));
d672 30
a701 1
	t = localtime(&oldtime);
d703 2
a704 5
	l = snprintf(tbuf, sizeof(tbuf), "%d/%d/%d GMT %d:%d:%d",
	    t->tm_mon + 1, t->tm_mday, t->tm_year + 1900, t->tm_hour,
	    t->tm_min, t->tm_sec);
	if (l == -1 || l >= (int)sizeof(tbuf))
		return (0);
d706 1
a706 1
	return (cvs_date_parse(tbuf));
a707 2

#endif	/* !RCSPROG */
@


1.77
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.76 2006/03/29 09:16:53 ray Exp $	*/
d103 1
a103 1
	if ((dlen > 0) && (dst[dlen - 1] == '\n'))
d148 2
a149 2
		if ((type <= 'a') || (type >= 'z') ||
		    (cvs_modetypes[type - 'a'] == -1)) {
d160 2
a161 2
			if ((*sp <= 'a') || (*sp >= 'z') ||
			    (cvs_modes[(int)type][*sp - 'a'] == 0)) {
d273 1
a273 1
	while ((rlen > 0) && (base[rlen - 1] == '/'))
d439 1
a439 1
	if ((mkdir(path, 0755) == -1) && (errno != EEXIST))
d451 1
a451 1
	if ((stat(path, &st) == -1) && (errno == ENOENT)) {
d465 1
a465 1
	if ((stat(path, &st) == -1) && (errno == ENOENT)) {
d563 1
a563 1
	if ((unlink(path) == -1) && (errno != ENOENT)) {
d608 1
a608 1
		} else if ((cvs_unlink(fpath) == -1) && (errno != ENOENT))
d613 1
a613 1
	if ((rmdir(path) == -1) && (errno != ENOENT)) {
d638 1
a638 1
	if ((create_adm == 1) && (root == NULL))
d657 2
a658 2
			if ((errno != ENOENT) || (mkdir(d, 0755) &&
			    errno != EEXIST)) {
d802 1
a802 1
	if ((tag != NULL) || (date != NULL)) {
@


1.76
log
@Yet more lint:
 - Explicitly test for -1 from read(2) and write(2).
 - Change negative parameters to 0 for rcsnum_cmp().  (I think xsa@@ had
   a patch for this earlier.)
 - Remove unused variables.
 - Changed return types to void if we only return one value.
 - Fix possible one-character truncation in rcs_deltatext_set().
 - Use memcpy() to copy u_char arrays.
 - Use ptrdiff_t to hold pointer differences.
 - int -> size_t for sizeof/strlen

``looks fine'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.75 2006/03/28 07:17:17 ray Exp $	*/
a382 1
	size_t size;
d388 1
a388 3
	size = (ret + 1) * sizeof(char *);
	copy = (char **)xmalloc(size);
	memset(copy, 0, size);
d945 1
a945 1
	lines = (struct cvs_lines *)xmalloc(sizeof(*lines));
d950 1
a950 1
	lp = (struct cvs_line *)xmalloc(sizeof(*lp));
d956 1
a956 1
		lp = (struct cvs_line *)xmalloc(sizeof(*lp));
d1061 1
a1061 1
	av = xmalloc(sizeof(struct cvs_argvector));
d1063 1
a1063 1
	av->argv = (char **)xcalloc(i + 1, sizeof(char *));
d1067 2
a1068 2
		nargv = (char **)xrealloc((void *)av->argv,
		    i + 1, sizeof(char *));
@


1.75
log
@xmalloc(num * size) -> xcalloc(num, size)
asprintf -> xasprintf
Remove asprintf check, which was non-portable anyway.

``okidoki'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.73 2006/03/27 06:13:51 pat Exp $	*/
d1059 1
a1061 1
	int i = 0;
@


1.74
log
@Today is Integer Overflow Prevention Day:
 - Sync xmalloc.? with ssh versions.
 - Change all xrealloc() calls to new API.

``I really like this.'' niallo@@
@
text
@d1066 1
a1066 1
	av->argv = (char **)xmalloc((i+1) * sizeof(char *));
@


1.73
log
@Plug a memory leak for all cvs_strsplit call sites; ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.72 2006/03/17 13:40:41 niallo Exp $	*/
d1071 1
a1071 1
		    (i+1) * sizeof(char *));
@


1.72
log
@- Lint says cvs_hacktime() is not used in rcs, so move it into !RCSPROG.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.71 2006/03/17 08:51:45 xsa Exp $	*/
d1055 1
a1055 1
char **
d1058 2
a1059 1
	char **argv, **nargv;
d1064 3
a1066 1
	argv = (char **)xmalloc((i+1) * sizeof(char *));
d1069 4
a1072 3
		argv[i++] = p;
		nargv = (char **)xrealloc((void *)argv, (i+1) * sizeof(char *));
		argv = nargv;
d1074 4
a1077 1
	argv[i] = NULL;
d1079 11
a1089 1
	return (argv);
@


1.71
log
@rlog_strsplit() -> cvs_strsplit() and move it to util.c so it can be reused
by `cvs log' and some other RCS utilities. "Looks good" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.70 2006/03/15 19:59:36 niallo Exp $	*/
d907 29
a1021 29
}

/*
 * a hack to mimic and thus match gnu cvs behaviour.
 */
time_t
cvs_hack_time(time_t oldtime, int togmt)
{
	int l;
	struct tm *t;
	char tbuf[32];

	if (togmt == 1) {
		t = gmtime(&oldtime);
		if (t == NULL)
			return (0);

		return (mktime(t));
	}

	t = localtime(&oldtime);

	l = snprintf(tbuf, sizeof(tbuf), "%d/%d/%d GMT %d:%d:%d",
	    t->tm_mon + 1, t->tm_mday, t->tm_year + 1900, t->tm_hour,
	    t->tm_min, t->tm_sec);
	if (l == -1 || l >= (int)sizeof(tbuf))
		return (0);

	return (cvs_date_parse(tbuf));
@


1.70
log
@- add util.h, reorganising a bunch of things and exposing cvs_yesno()
function to be used by rcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.69 2006/01/27 12:56:28 xsa Exp $	*/
d4 2
d1049 25
@


1.69
log
@cvs_mkadmin() cannot return < 0 anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.68 2006/01/25 11:19:51 xsa Exp $	*/
d31 1
a33 1

d1021 26
@


1.68
log
@strings cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.67 2006/01/02 08:23:39 xsa Exp $	*/
d678 1
a678 4
			if (cvs_mkadmin(d, root, rpath, NULL, NULL, 0) < 0) {
				cvs_log(LP_ERR, "failed to create adm files");
				goto done;
			}
@


1.67
log
@rename variable to fix shadow warning;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.66 2006/01/02 08:11:56 xsa Exp $	*/
a181 2
	int l;
	size_t l1;
d193 2
a194 2
		l = snprintf(tmp, sizeof(tmp), "u=%s", cvs_modestr[um]);
		if (l == -1 || l >= (int)sizeof(tmp))
d197 1
a197 2
		l1 = strlcat(buf, tmp, len);
		if (l1 >= len)
d203 1
a203 2
			l1 = strlcat(buf, ",", len);
			if (l1 >= len)
d207 2
a208 2
		l = snprintf(tmp, sizeof(tmp), "g=%s", cvs_modestr[gm]);
		if (l == -1 || l >= (int)sizeof(tmp))
d211 1
a211 2
		l1 = strlcat(buf, tmp, len);
		if (l1 >= len)
d217 1
a217 2
			l1 = strlcat(buf, ",", len);
			if (l1 >= len)
d221 2
a222 2
		l = snprintf(tmp, sizeof(tmp), "o=%s", cvs_modestr[gm]);
		if (l == -1 || l >= (int)sizeof(tmp))
d225 1
a225 2
		l1 = strlcat(buf, tmp, len);
		if (l1 >= len)
d632 1
a632 2
	size_t l;
	int len, ret;
d672 1
a672 2
			l = strlcat(rpath, d, sizeof(rpath));
			if (l >= sizeof(rpath))
d675 1
a675 2
			l = strlcat(rpath, "/", sizeof(rpath));
			if (l >= sizeof(rpath))
d690 5
a694 2
			len = snprintf(entry, sizeof(entry), "D/%s////", d);
			if (len == -1 || len >= (int)sizeof(entry))
a771 1
	int l;
d778 6
a783 3
	l = snprintf(buf, len, "%s/%s/%s%s",
	    root->cr_dir, repo, file->cf_name, RCS_FILE_EXT);
	if (l == -1 || l >= (int)len)
@


1.66
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.65 2006/01/01 05:05:58 joris Exp $	*/
d312 1
a312 1
	int argc, err;
d323 1
a323 1
	err = 0;
d335 1
a335 1
					err++;
d341 1
a341 1
					err++;
d358 1
a358 1
			err++;
d366 1
a366 1
	if (err != 0) {
@


1.65
log
@more code cleanup;
ok xsa@@

i'm commiting only hours after newyear,
ah the joys of being a true geek.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.64 2005/12/30 16:47:36 joris Exp $	*/
d27 1
a27 11
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <errno.h>
#include <fcntl.h>
#include <md5.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.64
log
@more code cleanup, ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.63 2005/12/24 19:07:52 xsa Exp $	*/
d96 1
a96 1
		return (NULL);
a187 1
 * Returns 0 on success, or -1 on failure.
d189 1
a189 1
int
d192 2
d205 7
a211 2
		snprintf(tmp, sizeof(tmp), "u=%s", cvs_modestr[um]);
		strlcat(buf, tmp, len);
d213 1
d215 13
a227 4
		if (um)
			strlcat(buf, ",", len);
		snprintf(tmp, sizeof(tmp), "g=%s", cvs_modestr[gm]);
		strlcat(buf, tmp, len);
d229 1
d231 13
a243 4
		if (um || gm)
			strlcat(buf, ",", len);
		snprintf(tmp, sizeof(tmp), "o=%s", cvs_modestr[gm]);
		strlcat(buf, tmp, len);
a244 2

	return (0);
d279 1
a279 1
int
d293 8
a300 2
		strlcpy(base, "./", blen);
		strlcat(base, path, blen);
a306 2

	return (0);
d320 1
d325 4
a328 1
	strlcpy(linebuf, line, sizeof(linebuf));
d621 1
a621 1
			goto done;
d692 1
a692 1
				goto done;
d696 1
a696 1
				goto done;
d711 2
a712 5
			if (len == -1 || len >= (int)sizeof(entry)) {
				errno = ENAMETOOLONG;
				cvs_log(LP_ERRNO, "%s", entry);
				goto done;
			}
@


1.63
log
@add an argument to cvs_chdir() which enables or not the removal
of the directory we just chdir'd to.
Useful when the function fails especially for the server mode and
its temporary directory. This way it's not left behind on exit.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.62 2005/12/24 04:10:51 joris Exp $	*/
a126 1
 * Returns 0 on success, or -1 on failure.
d128 1
a128 1
int
d132 1
d137 4
a140 3
	if (strlcpy(buf, str, sizeof(buf)) >= sizeof(buf)) {
		return (-1);
	}
a177 2

	return (0);
@


1.62
log
@remove useless cvs_buf_alloc() failure checks;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.61 2005/12/22 14:31:44 xsa Exp $	*/
d498 3
a500 2
 * Change to directory.
 * chdir() wrapper with an error message.
d504 1
a504 1
cvs_chdir(const char *path)
d506 3
a508 1
	if (chdir(path) == -1)
d510 1
d705 1
a705 1
		cvs_chdir(d);
@


1.61
log
@cvs_chdir() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.60 2005/12/22 14:16:18 xsa Exp $	*/
a965 6
	if ((res = cvs_buf_alloc(len, BUF_AUTOEXT)) == NULL) {
		cvs_freelines(dlines);
		cvs_freelines(plines);
		return (NULL);
	}

d967 1
@


1.60
log
@another fatal() round;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.59 2005/12/10 20:27:45 joris Exp $	*/
d700 2
a701 5
		/*
		 * All went ok, switch to the newly created directory.
		 */
		if (cvs_chdir(d) == -1)
			goto done;
@


1.59
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.58 2005/12/03 15:07:21 joris Exp $	*/
a193 1
	size_t l;
a202 1
	l = 0;
d206 1
a206 1
		l = strlcat(buf, tmp, len);
d263 1
a263 1
		return (-1);
d424 1
a424 1
		return (-1);
d426 2
a427 4
	if ((mkdir(path, 0755) == -1) && (errno != EEXIST)) {
		cvs_log(LP_ERRNO, "failed to create directory %s", path);
		return (-1);
	}
d436 1
a436 1
		return (-1);
d439 4
a442 5
		fp = fopen(path, "w");
		if (fp == NULL) {
			cvs_log(LP_ERRNO, "failed to open %s", path);
			return (-1);
		}
d450 1
a450 1
		return (-1);
d453 4
a456 5
		fp = fopen(path, "w");
		if (fp == NULL) {
			cvs_log(LP_ERRNO, "failed to open %s", path);
			return (-1);
		}
d500 1
a500 1
 * Returns 0 on success, or -1 on failure.
d505 2
a506 4
	if (chdir(path) == -1) {
		cvs_log(LP_ERRNO, "cannot change to dir `%s'", path);
		return (-1);
	}
d515 1
a515 1
 * Returns 0 on success, or -1 on failure.
d525 2
a526 4
	if (rename(from, to) == -1) {
		cvs_log(LP_ERRNO, "cannot rename file `%s' to `%s'", from, to);
		return (-1);
	}
d622 2
a623 4
	if (create_adm == 1 && (root == NULL)) {
		cvs_log(LP_ERR, "missing stuff in cvs_create_dir");
		return (-1);
	}
d628 2
a629 6
		if (strlcpy(rpath, repo, sizeof(rpath)) >= sizeof(rpath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", rpath);
			xfree(s);
			return (-1);
		}
d631 2
a632 6
		if (strlcat(rpath, "/", sizeof(rpath)) >= sizeof(rpath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", rpath);
			xfree(s);
			return (-1);
		}
d769 2
a770 5
	if (l == -1 || l >= (int)len) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", buf);
		return (NULL);
	}
@


1.58
log
@fix date handling in opencvs, this was broken since the very start.
now, when you checkout a tree with gnu cvs, opencvs no longer sees all
the files as modified, and visa versa.

this actually makes gnu cvs and opencvs dance together in working copies.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.57 2005/12/03 03:59:47 joris Exp $	*/
d343 1
a343 6
		argv[argc] = strdup(arg);
		if (argv[argc] == NULL) {
			cvs_log(LP_ERRNO, "failed to copy argument");
			err++;
			break;
		}
d350 1
a350 1
			free(argv[i]);
d376 1
a376 6
	copy = (char **)malloc(size);
	if (copy == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate argument vector");
		cvs_freeargv(argv, ret);
		return (NULL);
	}
d400 1
a400 1
			free(argv[i]);
d637 1
a637 3
	if ((s = strdup(path)) == NULL)
		return (-1);

d643 1
a643 1
			free(s);
d650 1
a650 1
			free(s);
d733 1
a733 1
	free(s);
d895 1
a895 1
				*tagp = strdup(linebuf);
d899 1
a899 1
				*datep = strdup(linebuf);
d903 1
a903 1
				*tagp = strdup(linebuf);
d929 1
a929 4
	lines = (struct cvs_lines *)malloc(sizeof(*lines));
	if (lines == NULL)
		return (NULL);

d932 1
a932 11
	lines->l_data = strdup(fcont);
	if (lines->l_data == NULL) {
		free(lines);
		return (NULL);
	}

	lp = (struct cvs_line *)malloc(sizeof(*lp));
	if (lp == NULL) {
		cvs_freelines(lines);
		return (NULL);
	}
d934 1
d940 1
a940 6
		lp = (struct cvs_line *)malloc(sizeof(*lp));
		if (lp == NULL) {
			cvs_freelines(lines);
			return (NULL);
		}

d961 1
a961 1
		free(lp);
d964 2
a965 2
	free(lines->l_data);
	free(lines);
@


1.57
log
@nuke unused vars;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.56 2005/12/03 01:02:09 joris Exp $	*/
d1037 29
@


1.56
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.55 2005/10/30 11:10:12 xsa Exp $	*/
a77 2

pid_t cvs_exec_pid;
@


1.55
log
@nuke trailing whitespaces;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.54 2005/10/22 17:32:57 joris Exp $	*/
d481 3
a483 1
	(void)cvs_write_tagfile(tag, date, nb);
d644 1
a644 1
	if (create_adm == 1 && (root == NULL || repo == NULL)) {
d652 15
a666 6
	if (strlcpy(rpath, repo, sizeof(rpath)) >= sizeof(rpath) ||
	    strlcat(rpath, "/", sizeof(rpath)) >= sizeof(rpath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rpath);
		free(s);
		return (-1);
d721 1
a721 1
			cvs_ent_remove(entf, d);
@


1.54
log
@diff3 support, needed for merging files together;

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.53 2005/10/07 21:47:32 reyk Exp $	*/
d805 1
a805 1
 */ 
d850 1
a850 1
 * 
@


1.53
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.52 2005/09/15 17:01:10 xsa Exp $	*/
d42 2
d918 110
@


1.52
log
@check in cvs_mkadmin() wether we need to create or not the
CVS/Tag file. Sync the rest of the code accordingly; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.51 2005/09/05 19:29:42 xsa Exp $	*/
d893 1
a893 1
		switch(*linebuf) {
@


1.51
log
@add new functions: cvs_write_tagfile() and cvs_parse_tagfile(),
write and parse a CVS/Tag file. Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.50 2005/08/17 08:35:53 xsa Exp $	*/
d422 2
a423 1
cvs_mkadmin(const char *dpath, const char *rootpath, const char *repopath)
d431 3
d478 3
d684 1
a684 1
			if (cvs_mkadmin(d, root, rpath) < 0) {
@


1.50
log
@trailing whitespaces ...
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.49 2005/08/12 14:41:54 xsa Exp $	*/
a283 1

d790 119
@


1.49
log
@add cvs_rename() function; ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.48 2005/07/30 21:16:17 moritz Exp $	*/
d509 1
a509 1
 */ 
@


1.48
log
@o remove a call to cvs_ent_open() from cvs_file_create(),
  since cvs_mkadmin() already does this for us.
o don't deref NULL ptr when cvs_ent_open() fails.
o fix format string in cvs_log().

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.47 2005/07/27 19:24:14 xsa Exp $	*/
d515 22
@


1.47
log
@check == -1 not != 0 for stat() return value, for consistency sake!
"OK big time" jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.46 2005/07/27 10:38:01 xsa Exp $	*/
d442 2
a443 1
	(void)cvs_ent_close(ef);
@


1.46
log
@make cvs_rmdir() handle global -n and -t options; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.45 2005/07/27 10:36:14 xsa Exp $	*/
d448 1
a448 1
	if ((stat(path, &st) != 0) && (errno == ENOENT)) {
d463 1
a463 1
	if ((stat(path, &st) != 0) && (errno == ENOENT)) {
@


1.45
log
@rename cvs_remove_dir() to cvs_rmdir() because it might be confusing
with the `remove' command local functions. ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.44 2005/07/26 14:46:24 joris Exp $	*/
d557 5
@


1.44
log
@no need to complain that we cannot remove the file in cvs_unlink()
if it does not exist.

"commit it" xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.43 2005/07/25 13:37:53 xsa Exp $	*/
d544 1
a544 1
 * cvs_remove_dir()
d550 1
a550 1
cvs_remove_dir(const char *path)
d573 1
a573 1
			if (cvs_remove_dir(fpath) == -1)
@


1.43
log
@minor KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.42 2005/07/25 12:05:43 xsa Exp $	*/
d535 1
a535 1
	if (unlink(path) == -1) {
@


1.42
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.41 2005/07/24 17:33:09 xsa Exp $	*/
d353 1
a353 1
	if (err) {
d641 1
a641 1
		if (create_adm) {
@


1.41
log
@use cvs_unlink() here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.40 2005/07/24 17:12:25 xsa Exp $	*/
d370 1
a370 1
char**
d744 1
a744 1
char*
@


1.40
log
@add cvs_unlink(); a wrapper to unlunk() w/ an error msg as it is used in
many places. Also handle -n and -t global options.
ok joris@@ jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.39 2005/07/23 10:59:47 xsa Exp $	*/
d575 1
a575 2
		} else if ((unlink(fpath) == -1) && (errno != ENOENT)) {
			cvs_log(LP_ERRNO, "failed to remove '%s'", fpath);
a576 1
		}
@


1.39
log
@use cvs_chdir();
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.38 2005/07/23 10:49:35 xsa Exp $	*/
d514 23
@


1.38
log
@add cvs_chdir(); a wrapper to chdir() w/ an error msg as it is used in
many places. Let's make our life simpler for once.
ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.37 2005/07/19 15:36:54 xsa Exp $	*/
d669 1
a669 2
		if (chdir(d) == -1) {
			cvs_log(LP_ERRNO, "failed to change dir to `%s'", d);
a670 1
		}
@


1.37
log
@use cvs_path_cat() where appropriate; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2005/07/19 01:40:29 deraadt Exp $	*/
d500 18
@


1.36
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.35 2005/07/13 16:20:44 xsa Exp $	*/
d90 1
a90 2
	int l;
	size_t dlen;
d94 2
a95 4
	l = snprintf(repo_path, sizeof(repo_path), "%s/CVS/Repository", dir);
	if (l == -1 || l >= (int)sizeof(repo_path)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", repo_path);
a96 1
        }
d425 1
a425 1
	int l;
d431 2
a432 4
	l = snprintf(path, sizeof(path), "%s/" CVS_PATH_CVSDIR, dpath);
	if (l == -1 || l >= (int)sizeof(path)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", path);
a433 1
	}
d444 2
a445 4
	l = snprintf(path, sizeof(path), "%s/" CVS_PATH_ROOTSPEC, dpath);
	if (l == -1 || l >= (int)sizeof(path)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", path);
a446 1
	}
d459 2
a460 4
	l = snprintf(path, sizeof(path), "%s/" CVS_PATH_REPOSITORY, dpath);
	if (l == -1 || l >= (int)sizeof(path)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", path);
a461 1
	}
@


1.35
log
@add cvs_rcs_getpath() function. Returns the path of the RCS file if it
does exist. Will save us code duplication.
ok joris@@ jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.34 2005/06/17 15:09:55 joris Exp $	*/
d730 1
a730 1
	l = snprintf(buf, len, "%s/%s/%s%s",  
@


1.34
log
@

correctly build a temporary copy of the client its repository
localy, so the server can execute the local commands on it
and pipe the output to the client.

with this diff in, our server is now working, please note
that we currently don't have support for all commands yet,
but you can expect this soon.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.33 2005/06/14 03:56:14 pat Exp $	*/
d710 29
@


1.33
log
@missing closedir() on error path; ok joris xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2005/06/02 20:19:30 joris Exp $	*/
d562 115
@


1.32
log
@

remove unneeded error reporting when using cvs_path_cat(), the
function does it for us.

OK jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.31 2005/05/31 08:58:48 xsa Exp $	*/
d524 1
d541 2
a542 4
		if (len >= sizeof(fpath)) {
			closedir(dirp);
			return (-1);
		}
d545 2
a546 4
			if (cvs_remove_dir(fpath) == -1) {
				closedir(dirp);
				return (-1);
			}
d549 1
a549 1
			return (-1);
a552 1
	closedir(dirp);
d556 1
a556 1
		return (-1);
d559 4
a562 1
	return (0);
@


1.31
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.30 2005/05/27 17:04:59 jfb Exp $	*/
a540 2
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", fpath);
@


1.30
log
@- check strlcpy() return values for truncation
- in cvs_remove_dir(), return failure if we fail to unlink the
  base directory, and return -1 on error to respect the general
  util convention
- missing function documentation
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2005/05/26 22:25:31 jfb Exp $	*/
a30 1
#include <md5.h>
d33 1
d36 1
a37 1
#include <string.h>
a40 1
#include "file.h"
@


1.29
log
@don't keep a pointer to the file handle in CVSENTRIES, it is only
used in cvs_ent_write(), and simplify path building a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2005/05/24 20:04:43 joris Exp $	*/
d142 3
a144 1
	strlcpy(buf, str, sizeof(buf));
d190 4
a230 1

a253 1

a374 1

d517 4
a520 1
 * remove a directory tree from disk.
d525 1
a525 1
	int l, ret;
d532 1
a532 1
		return (CVS_EX_FILE);
d540 2
a541 2
		l = snprintf(fpath, sizeof(fpath), "%s/%s", path, ent->d_name);
		if (l == -1 || l >= (int)sizeof(fpath)) {
d545 1
a545 1
			return (CVS_EX_FILE);
d549 1
a549 1
			if ((ret = cvs_remove_dir(fpath)) != CVS_EX_OK) {
d551 1
a551 1
				return (ret);
d553 3
a555 4
		} else {
			if ((unlink(fpath) == -1) && (errno != ENOENT))
				cvs_log(LP_ERRNO, "failed to remove '%s'",
				    fpath);
d561 1
a561 1
	if ((rmdir(path) == -1) && (errno != ENOENT))
d563 2
d566 1
a566 1
	return (CVS_EX_OK);
d569 10
@


1.28
log
@

- simplify cvs_mkadmin().
- create the correct base paths in checkout.
- remove the CVS_CMD_SENDARGS2 flag for checkout, it doesn't need it.

okay jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2005/05/20 10:40:22 pat Exp $	*/
d562 21
@


1.27
log
@* proper memset
* plug potential memory leak
ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2005/05/20 00:07:19 joris Exp $	*/
d425 1
a425 1
cvs_mkadmin(CVSFILE *cdir, mode_t mode)
d428 1
a428 1
	char dpath[MAXPATHLEN], path[MAXPATHLEN];
a431 3
	struct cvsroot *root;

	cvs_file_getpath(cdir, dpath, sizeof(dpath));
d440 1
a440 1
	if ((mkdir(path, mode) == -1) && (errno != EEXIST)) {
a448 1
	root = cdir->cf_root;
d456 1
a456 1
	if ((root != NULL) && (stat(path, &st) != 0) && (errno == ENOENT)) {
d462 2
a463 16
		if (root->cr_user != NULL) {
			fprintf(fp, "%s", root->cr_user);
			if (root->cr_pass != NULL)
				fprintf(fp, ":%s", root->cr_pass);
			if (root->cr_host != NULL)
				putc('@@', fp);
		}

		if (root->cr_host != NULL) {
			fprintf(fp, "%s", root->cr_host);
			if (root->cr_dir != NULL)
				putc(':', fp);
		}
		if (root->cr_dir)
			fprintf(fp, "%s", root->cr_dir);
		putc('\n', fp);
d474 1
a474 2
	if ((stat(path, &st) != 0) && (errno == ENOENT) &&
	    (cdir->cf_repo != NULL)) {
d480 2
a481 1
		fprintf(fp, "%s\n", cdir->cf_repo);
@


1.26
log
@

unused var

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2005/05/19 04:17:24 jfb Exp $	*/
d302 1
a302 1
	memset(argv, 0, sizeof(argv));
d377 1
d383 2
a384 1
	copy = (char **)malloc((ret + 1) * sizeof(char *));
d387 1
d390 1
a390 1
	memset(copy, 0, sizeof(copy));
@


1.25
log
@use the date parsing code from date.y and fix timestamps on newly
created files so they match the values found in the corresponding
entries, otherwise all files appear as modified

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2005/05/18 20:24:19 joris Exp $	*/
a41 6

static const char *cvs_months[] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

@


1.24
log
@

build a local copy of the client's source tree when acting as a server.
more server stuff coming soon!

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2005/04/18 21:02:50 jfb Exp $	*/
a126 74
}


/*
 * cvs_datesec()
 *
 * Take a date string and transform it into the number of seconds since the
 * Epoch.  The <type> argument specifies whether the timestamp is in ctime(3)
 * format or RFC 822 format (as CVS uses in its protocol).  If the <adj>
 * parameter is not 0, the returned time will be adjusted according to the
 * machine's local timezone.
 */
time_t
cvs_datesec(const char *date, int type, int adj)
{
	int i;
	long off;
	char sign, mon[8], gmt[8], hr[4], min[4], *ep;
	struct tm cvs_tm;

	memset(&cvs_tm, 0, sizeof(cvs_tm));
	cvs_tm.tm_isdst = -1;

	if (type == CVS_DATE_RFC822) {
		if (sscanf(date, "%d %3s %d %2d:%2d:%2d %5s", &cvs_tm.tm_mday,
		    mon, &cvs_tm.tm_year, &cvs_tm.tm_hour, &cvs_tm.tm_min,
		    &cvs_tm.tm_sec, gmt) < 7)
			return (-1);
		cvs_tm.tm_year -= 1900;

		if (*gmt == '-') {
			sscanf(gmt, "%c%2s%2s", &sign, hr, min);
			cvs_tm.tm_gmtoff = strtol(hr, &ep, 10);
			if ((cvs_tm.tm_gmtoff == LONG_MIN) ||
			    (cvs_tm.tm_gmtoff == LONG_MAX) ||
			    (*ep != '\0')) {
				cvs_log(LP_ERR,
				    "parse error in GMT hours specification `%s'", hr);
				cvs_tm.tm_gmtoff = 0;
			} else {
				/* get seconds */
				cvs_tm.tm_gmtoff *= 3600;

				/* add the minutes */
				off = strtol(min, &ep, 10);
				if ((cvs_tm.tm_gmtoff == LONG_MIN) ||
				    (cvs_tm.tm_gmtoff == LONG_MAX) ||
				    (*ep != '\0')) {
					cvs_log(LP_ERR,
					    "parse error in GMT minutes "
					    "specification `%s'", min);
				} else
					cvs_tm.tm_gmtoff += off * 60;
			}
		}
		if (sign == '-')
			cvs_tm.tm_gmtoff = -cvs_tm.tm_gmtoff;
	} else if (type == CVS_DATE_CTIME) {
		/* gmt is used for the weekday */
		sscanf(date, "%3s %3s %d %2d:%2d:%2d %d", gmt, mon,
		    &cvs_tm.tm_mday, &cvs_tm.tm_hour, &cvs_tm.tm_min,
		    &cvs_tm.tm_sec, &cvs_tm.tm_year);
		cvs_tm.tm_year -= 1900;
		cvs_tm.tm_gmtoff = 0;
	}

	for (i = 0; i < (int)(sizeof(cvs_months)/sizeof(cvs_months[0])); i++) {
		if (strcmp(cvs_months[i], mon) == 0) {
			cvs_tm.tm_mon = i;
			break;
		}
	}

	return mktime(&cvs_tm);
@


1.23
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2005/04/16 20:05:05 xsa Exp $	*/
d607 50
@


1.22
log
@more snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2005/04/16 18:07:35 xsa Exp $	*/
d529 1
a529 1
	root = cdir->cf_ddat->cd_root;
d570 1
a570 1
	    (cdir->cf_ddat->cd_repo != NULL)) {
d576 1
a576 1
		fprintf(fp, "%s\n", cdir->cf_ddat->cd_repo);
@


1.21
log
@snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2004/12/22 00:38:26 david Exp $	*/
d562 1
a562 1
	snprintf(path, sizeof(path), "%s/" CVS_PATH_REPOSITORY, dpath);
@


1.20
log
@spelling corrections; ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2004/12/13 16:59:50 jfb Exp $	*/
d97 1
d102 7
a108 1
	snprintf(repo_path, sizeof(repo_path), "%s/CVS/Repository", dir);
d110 1
a110 1
	if (fp == NULL) {
a111 1
	}
d504 1
d513 7
a519 1
	snprintf(path, sizeof(path), "%s/" CVS_PATH_CVSDIR, dpath);
d530 7
a536 1
	snprintf(path, sizeof(path), "%s/" CVS_PATH_ROOTSPEC, dpath);
d563 6
@


1.19
log
@if we fail to generate a file's checksum, print the path of the file
as part of the error message
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2004/12/07 17:10:56 tedu Exp $	*/
d366 1
a366 1
 * Returns the number of arguments in the vector, or -1 if an error occured.
d442 1
a442 1
 * Allocate an argument vector large enough to accomodate for all the
@


1.18
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2004/12/07 06:33:11 jfb Exp $	*/
d316 1
a316 1
		cvs_log(LP_ERRNO, "failed to generate file checksum");
@


1.17
log
@add missing parts for support of .cvsrc

tested, tweaked by and ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2004/12/03 20:24:37 weingart Exp $	*/
a83 1

a93 1

a132 1

d184 1
a184 1
		cvs_tm.tm_gmtoff = 0; 
a207 1

a263 1

a307 1

a332 1

a367 1

a476 1

a494 1

a561 1

@


1.16
log
@reorder some of the code for argument vector splitting so we don't
overflow the array and we don't produce weird results if the last
character of the line is an escape character (bogus!)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2004/12/06 21:03:13 deraadt Exp $	*/
d444 33
@


1.15
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2004/12/03 20:24:37 weingart Exp $	*/
d396 2
d402 1
a402 2
				} else if (*lp == '\\')
					lp++;
d422 5
d459 2
a460 1
		free(argv[i]);
@


1.14
log
@Handle files mode 750.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d163 1
a163 2
			}
			else {
d175 1
a175 2
				}
				else
d181 1
a181 2
	}
	else if (type == CVS_DATE_CTIME) {
d252 1
a252 2
			}
			else
d400 1
a400 2
				}
				else if (*lp == '\\')
d411 1
a411 2
		}
		else {
@


1.13
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@d232 3
a234 1
		if (sscanf(sp, "%c=%3s", &type, ms) != 2) {
@


1.12
log
@missing headers
@
text
@a31 1
#include <err.h>
d470 1
a470 1
cvs_mkadmin(struct cvs_file *cdir, mode_t mode)
d472 1
a472 1
	char path[MAXPATHLEN];
d478 3
a480 1
	snprintf(path, sizeof(path), "%s/" CVS_PATH_CVSDIR, cdir->cf_path);
d487 1
a487 1
	ef = cvs_ent_open(cdir->cf_path, O_WRONLY);
d491 1
a491 1
	snprintf(path, sizeof(path), "%s/" CVS_PATH_ROOTSPEC, cdir->cf_path);
d517 1
a517 1
	snprintf(path, sizeof(path), "%s/" CVS_PATH_REPOSITORY, cdir->cf_path);
d548 2
a549 1
		err(1, "failed to exec %s", argv[0]);
d553 1
a553 1
		warn("failed to waitpid");
@


1.11
log
@cvs_exec()
@
text
@d29 1
d32 1
@


1.10
log
@Handle RFC822 and ctime(3) style timestamps
@
text
@d84 2
d527 25
@


1.9
log
@Add cvs_datesec() to calculate the time_t value corresponding to a
ctime(3)-style date string
@
text
@d126 5
a130 2
 * Take a ctime(3)-style date string and transform it into the number of
 * seconds since the Epoch.
d134 1
a134 1
cvs_datesec(const char *date)
a141 4
	sscanf(date, "%d %3s %d %2d:%2d:%2d %5s", &cvs_tm.tm_mday, mon,
	    &cvs_tm.tm_year, &cvs_tm.tm_hour, &cvs_tm.tm_min,
	    &cvs_tm.tm_sec, gmt);
	cvs_tm.tm_year -= 1900;
d144 6
a149 13
	if (*gmt == '-') {
		sscanf(gmt, "%c%2s%2s", &sign, hr, min);
		cvs_tm.tm_gmtoff = strtol(hr, &ep, 10);
		if ((cvs_tm.tm_gmtoff == LONG_MIN) ||
		    (cvs_tm.tm_gmtoff == LONG_MAX) ||
		    (*ep != '\0')) {
			cvs_log(LP_ERR,
			    "parse error in GMT hours specification `%s'", hr);
			cvs_tm.tm_gmtoff = 0;
		}
		else {
			/* get seconds */
			cvs_tm.tm_gmtoff *= 3600;
d151 3
a153 2
			/* add the minutes */
			off = strtol(min, &ep, 10);
d158 18
a175 2
				    "parse error in GMT minutes "
				    "specification `%s'", min);
a176 2
			else
				cvs_tm.tm_gmtoff += off * 60;
d178 10
a188 2
	if (sign == '-')
		cvs_tm.tm_gmtoff = -cvs_tm.tm_gmtoff;
@


1.8
log
@Before stating the Root file, make sure we actually have something to
write in it
@
text
@d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
d42 5
d124 63
d270 1
a270 1
		l = strlcat(buf, tmp, len); 
d276 1
a276 1
		strlcat(buf, tmp, len); 
d282 1
a282 1
		strlcat(buf, tmp, len); 
d388 1
a388 1
				qbuf[i++] = *lp++; 
@


1.7
log
@Simplify cvs_splitpath() by requiring only one buffer to copy the result
into
@
text
@d404 1
a404 1
	if ((stat(path, &st) != 0) && (errno == ENOENT) && (root != NULL)) {
@


1.6
log
@When splitting a path, strip the trailing slashes before splitting it,
otherwise a path with a trailing slash would give an empty file name
and the original path as the base part
@
text
@d249 4
a252 3
 * Split a path <path> into the directory portion and the filename portion
 * and copy them in <dir> and <file>, whose lengths are <dlen> and <flen>,
 * unless they are NULL.
d257 1
a257 1
cvs_splitpath(const char *path, char *dir, size_t dlen, char *file, size_t flen)
d260 1
a260 2
	const char *sp;
	struct stat st;
d262 2
a263 3
	rlen = strlen(path);
	while ((rlen > 0) && (path[rlen - 1] == '/'))
		path[--rlen] = '\0';
d265 4
a268 1
	sp = strrchr(path, '/');
d270 3
a272 15
		if (stat(path, &st) == -1)
			return (-1);

		if (S_ISDIR(st.st_mode)) {
			if (dir != NULL)
				strlcpy(dir, path, dlen);
			if (file != NULL)
				file[0] = '\0';
		}
		else {
			if (file != NULL)
				strlcpy(file, path, flen);
			if (dir != NULL)
				strlcpy(dir, ".", dlen);
		}
a273 6
	else {
		rlen = MIN(dlen - 1, (size_t)(sp - path));
		if (dir != NULL) {
			strncpy(dir, path, rlen);
			dir[rlen] = '\0';
		}
d275 3
a277 4
		sp++;
		if (file != NULL)
			strlcpy(file, sp, flen);
	}
@


1.5
log
@When calling cvs_mkadmin(), only create the files if they don't already
exist
@
text
@d262 4
@


1.4
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d40 1
d164 1
a164 1
			    (cvs_modes[type][*sp - 'a'] == 0)) {
d169 1
a169 1
				m |= cvs_modes[type][*sp - 'a'];
d391 2
a392 1
 * Create the CVS administrative files within the directory <cdir>.
d402 1
d406 1
a406 1
	if (mkdir(path, mode) == -1) {
d411 1
d415 1
d417 23
a439 4
	fp = fopen(path, "w");
	if (fp == NULL) {
		cvs_log(LP_ERRNO, "failed to open %s", path);
		return (-1);
a440 18
	root = cdir->cf_ddat->cd_root;
	if (root->cr_user != NULL) {
		fprintf(fp, "%s", root->cr_user);
		if (root->cr_pass != NULL)
			fprintf(fp, ":%s", root->cr_pass);
		if (root->cr_host != NULL)
			putc('@@', fp);
	}

	if (root->cr_host != NULL) {
		fprintf(fp, "%s", root->cr_host);
		if (root->cr_dir != NULL)
			putc(':', fp);
	}
	if (root->cr_dir)
		fprintf(fp, "%s", root->cr_dir);
	putc('\n', fp);
	(void)fclose(fp);
d442 3
a444 3
	if (cdir->cf_ddat->cd_repo != NULL) {
		snprintf(path, sizeof(path), "%s/" CVS_PATH_REPOSITORY,
		    cdir->cf_path);
a452 1

@


1.3
log
@Add a newline at the end of the strings put in CVS/Root and
CVS/Repository, like GNU CVS does
@
text
@d280 1
a280 1
		rlen = MIN(dlen - 1, sp - path);
@


1.2
log
@* create cvs_file_alloc() to keep one copy of the file allocation code
  and reuse it
* add cvs_file_create() to explicitly create a file or directory
* add cvs_mkadmin() to fill the administrative files for a CVS directory
@
text
@a94 1

d433 1
d444 1
a444 1
		fprintf(fp, "%s", cdir->cf_ddat->cd_repo);
@


1.1
log
@Initial revision
@
text
@d32 1
a97 1
		cvs_log(LP_ERRNO, "failed to open `%s'", repo_path);
a113 1

d132 1
a132 1
	int type;
d144 1
a144 1
			*(ep++) = '\0';
d146 1
a146 1
		if (sscanf(sp, "%c=%3s", (char *)&type, ms) != 2) {
d385 65
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
