head	1.87;
access;
symbols
	OPENBSD_6_2:1.87.0.4
	OPENBSD_6_2_BASE:1.87
	OPENBSD_6_1:1.85.0.4
	OPENBSD_6_1_BASE:1.85
	OPENBSD_6_0:1.83.0.4
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.81.0.6
	OPENBSD_5_8_BASE:1.81
	OPENBSD_5_7:1.81.0.2
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.80.0.18
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.80.0.16
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.80.0.12
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.80.0.10
	OPENBSD_5_3_BASE:1.80
	OPENBSD_5_2:1.80.0.8
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.80
	OPENBSD_5_1:1.80.0.6
	OPENBSD_5_0:1.80.0.4
	OPENBSD_5_0_BASE:1.80
	OPENBSD_4_9:1.80.0.2
	OPENBSD_4_9_BASE:1.80
	OPENBSD_4_8:1.79.0.6
	OPENBSD_4_8_BASE:1.79
	OPENBSD_4_7:1.79.0.2
	OPENBSD_4_7_BASE:1.79
	OPENBSD_4_6:1.79.0.4
	OPENBSD_4_6_BASE:1.79
	OPENBSD_4_5:1.76.0.4
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.76.0.2
	OPENBSD_4_4_BASE:1.76
	OPENBSD_4_3:1.70.0.2
	OPENBSD_4_3_BASE:1.70
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.55.0.2
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.87
date	2017.06.01.08.08.24;	author joris;	state Exp;
branches;
next	1.86;
commitid	oZyV6E3g0wglnhaw;

1.86
date	2017.05.31.16.13.25;	author joris;	state Exp;
branches;
next	1.85;
commitid	ZNSE3MpVruVb6i6v;

1.85
date	2016.10.27.07.12.02;	author joris;	state Exp;
branches;
next	1.84;
commitid	C6CcfWA73T1D55pc;

1.84
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.83;
commitid	8Vv7d4HkmCtExfc6;

1.83
date	2015.12.22.21.36.57;	author mmcc;	state Exp;
branches;
next	1.82;
commitid	ea5GZDc4EQ86MZA8;

1.82
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.81;
commitid	O6jeJ0TRmiewrqMI;

1.81
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	Uu5nFG3wCl0LACBb;

1.80
date	2010.10.28.12.30.27;	author tobias;	state Exp;
branches;
next	1.79;

1.79
date	2009.03.24.18.33.25;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2009.03.22.18.41.25;	author tobias;	state Exp;
branches;
next	1.77;

1.77
date	2009.03.22.18.40.55;	author tobias;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.20.14.04.29;	author tobias;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.15.04.38.52;	author tobias;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.10.01.00.34;	author joris;	state Exp;
branches;
next	1.73;

1.73
date	2008.03.18.13.00.12;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2008.03.12.13.54.49;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.09.03.14.52;	author joris;	state Exp;
branches;
next	1.70;

1.70
date	2008.03.02.19.05.34;	author tobias;	state Exp;
branches;
next	1.69;

1.69
date	2008.03.01.21.29.37;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2008.03.01.20.03.56;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.09.13.03.29;	author joris;	state Exp;
branches;
next	1.66;

1.66
date	2008.02.09.11.56.58;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2008.02.04.21.25.32;	author tobias;	state Exp;
branches;
next	1.64;

1.64
date	2008.01.31.22.09.05;	author xsa;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.61;

1.61
date	2008.01.10.11.25.27;	author tobias;	state Exp;
branches;
next	1.60;

1.60
date	2008.01.10.11.20.29;	author tobias;	state Exp;
branches;
next	1.59;

1.59
date	2008.01.10.09.39.32;	author tobias;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.17.12.42.39;	author tobias;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.18.17.54.13;	author joris;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.09.12.51.23;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.09.10.08.33;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2006.11.09.09.24.28;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2006.07.02.21.11.54;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2006.06.09.14.57.13;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.07.18.19.07;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.27.03.30.31;	author joris;	state dead;
branches;
next	1.43;

1.43
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.12.14.09.11;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.08.05.01.50;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.06.08.33.03;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.01.14.30.34;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.27.15.42.35;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.27.08.50.51;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.22.14.59.54;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.27.16.33.35;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.26.18.33.54;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.26.17.43.48;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.08.11.40.07;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.27.16.42.19;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.24.16.46.40;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.18.07.22.23;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.14.06.50.50;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.11.10.33.57;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.11.09.08.47;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.28.13.20.53;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.31.08.26.40;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.29.00.55.10;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.24.07.38.46;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.20.23.11.30;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.19.18.51.30;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.16.20.31.18;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.26.08.09.54;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.28.20.18.02;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.27.00.22.08;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.14.18.02.04;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.14.22.30.48;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.14.19.11.54;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Stop looking at current_cvsroot->cr_method to figure out if we're remote or not.

Instead use cvsroot_is_local() and cvsroot_is_remote().
@
text
@/*	$OpenBSD: tag.c,v 1.86 2017/05/31 16:13:25 joris Exp $	*/
/*
 * Copyright (c) 2006 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

#define T_CHECK_UPTODATE	0x01
#define T_DELETE		0x02
#define T_FORCE_MOVE		0x04
#define T_BRANCH		0x08

void	cvs_tag_check_files(struct cvs_file *);
void	cvs_tag_local(struct cvs_file *);

static int tag_del(struct cvs_file *);
static int tag_add(struct cvs_file *);

struct file_info_list	files_info;

static int	runflags = 0;
static int	tag_errors = 0;
static char	*tag = NULL;
static char	*tag_date = NULL;
static char	*tag_name = NULL;
static char	*tag_oldname = NULL;

struct cvs_cmd cvs_cmd_rtag = {
	CVS_OP_RTAG, CVS_LOCK_REPO, "rtag",
	{ "rt", "rfreeze" },
	"Add a symbolic tag to a module",
	"[-bcdFflR] [-D date | -r rev] symbolic_tag module ...",
	"bcD:dFflRr:",
	NULL,
	cvs_tag
};

struct cvs_cmd cvs_cmd_tag = {
	CVS_OP_TAG, CVS_USE_WDIR | CVS_LOCK_REPO, "tag",
	{ "ta", "freeze" },
	"Add a symbolic tag to checked out version of files",
	"[-bcdFflR] [-D date | -r rev] symbolic_tag [file ...]",
	"bcD:dFflRr:",
	NULL,
	cvs_tag
};

int
cvs_tag(int argc, char **argv)
{
	int ch, flags, i;
	char repo[PATH_MAX];
	char *arg = ".";
	struct cvs_recursion cr;
	struct trigger_list *line_list;

	flags = CR_RECURSE_DIRS;

	while ((ch = getopt(argc, argv, cvs_cmdop == CVS_OP_TAG ?
	    cvs_cmd_tag.cmd_opts : cvs_cmd_rtag.cmd_opts)) != -1) {
		switch (ch) {
		case 'b':
			runflags |= T_BRANCH;
			break;
		case 'c':
			runflags |= T_CHECK_UPTODATE;
			break;
		case 'D':
			tag_date = optarg;
			break;
		case 'd':
			runflags |= T_DELETE;
			break;
		case 'F':
			runflags |= T_FORCE_MOVE;
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		case 'r':
			tag_oldname = optarg;
			break;
		default:
			fatal("%s", cvs_cmdop == CVS_OP_TAG ?
			    cvs_cmd_tag.cmd_synopsis :
			    cvs_cmd_rtag.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (cvs_cmdop == CVS_OP_RTAG) {
		flags |= CR_REPO;

		if (argc < 2)
			fatal("%s", cvs_cmd_rtag.cmd_synopsis);

		for (i = 1; i < argc; i++) {
			if (argv[i][0] == '/') {
				fatal("Absolute path name is invalid: %s",
				    argv[i]);
			}
		}
	} else if (cvs_cmdop == CVS_OP_TAG && argc == 0) {
		fatal("%s", cvs_cmd_tag.cmd_synopsis);
	}

	tag_name = argv[0];
	argc--;
	argv++;

	if (!rcs_sym_check(tag_name)) {
		fatal("tag `%s' must not contain the characters `%s'",
		    tag_name, RCS_SYM_INVALCHAR);
	}

	if (tag_oldname != NULL) {
		if (runflags & T_DELETE)
			tag_oldname = NULL;
		else
			tag = tag_oldname;
	}

	if (tag_date != NULL) {
		if (runflags & T_DELETE)
			tag_date = NULL;
		else
			tag = tag_date;
	}

	if (tag_oldname != NULL && tag_date != NULL)
		fatal("-r and -D options are mutually exclusive");

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (cvsroot_is_remote()) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (argc > 0)
			cvs_file_run(argc, argv, &cr);
		else
			cvs_file_run(1, &arg, &cr);

		if (runflags & T_BRANCH)
			cvs_client_send_request("Argument -b");

		if (runflags & T_CHECK_UPTODATE)
			cvs_client_send_request("Argument -c");

		if (runflags & T_DELETE)
			cvs_client_send_request("Argument -d");

		if (runflags & T_FORCE_MOVE)
			cvs_client_send_request("Argument -F");

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");

		if (tag_date != NULL)
			cvs_client_send_request("Argument -D%s", tag_date);

		if (tag_oldname != NULL)
			cvs_client_send_request("Argument -r%s", tag_oldname);

		cvs_client_send_request("Argument %s", tag_name);
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request((cvs_cmdop == CVS_OP_RTAG) ?
		    "rtag" : "tag");
		cvs_client_get_responses();

		return (0);
	}

	if (cvs_cmdop == CVS_OP_RTAG && chdir(current_cvsroot->cr_dir) == -1)
		fatal("cvs_tag: %s", strerror(errno));

	TAILQ_INIT(&files_info);
	cvs_get_repository_name(".", repo, PATH_MAX);
	line_list = cvs_trigger_getlines(CVS_PATH_TAGINFO, repo);

	cr.flags = flags;
	cr.fileproc = cvs_tag_check_files;

	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);

	if (tag_errors)
		fatal("correct the above errors first!");

	if (line_list != NULL) {
		if (cvs_trigger_handle(CVS_TRIGGER_TAGINFO, repo, NULL,
		    line_list, &files_info))
			fatal("Pre-tag check failed");
		cvs_trigger_freelist(line_list);
	}

	cr.fileproc = cvs_tag_local;

	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);

	if (line_list != NULL)
		cvs_trigger_freeinfo(&files_info);

	return (0);
}

void
cvs_tag_check_files(struct cvs_file *cf)
{
	RCSNUM *srev = NULL, *rev = NULL;
	char rbuf[CVS_REV_BUFSZ];
	struct file_info *fi;

	cvs_log(LP_TRACE, "cvs_tag_check_files(%s)", cf->file_path);

	cvs_file_classify(cf, tag);

	if (cf->file_type == CVS_DIR || cf->file_status == FILE_UNKNOWN)
		return;

	if (runflags & T_CHECK_UPTODATE) {
		if (cf->file_status != FILE_UPTODATE &&
		    cf->file_status != FILE_CHECKOUT &&
		    cf->file_status != FILE_PATCH) {
			tag_errors++;
			cvs_log(LP_NOTICE,
			    "%s is locally modified", cf->file_path);
			return;
		}
	}

	switch (cf->file_status) {
	case FILE_ADDED:
	case FILE_REMOVED:
		return;
	default:
		break;
	}

	if (cvs_cmdop == CVS_OP_TAG) {
		if (cf->file_ent == NULL)
			return;
		srev = cf->file_ent->ce_rev;
	} else
		srev = cf->file_rcsrev;

	rcsnum_tostr(srev, rbuf, sizeof(rbuf));
	fi = xcalloc(1, sizeof(*fi));
	fi->nrevstr = xstrdup(rbuf);
	fi->file_path = xstrdup(cf->file_path);

	if (tag_oldname != NULL)
		fi->tag_old = xstrdup(tag_oldname);
	else if (tag_date != NULL)
		fi->tag_old = xstrdup(tag_date);

	if ((rev = rcs_sym_getrev(cf->file_rcs, tag_name)) != NULL) {
		if (!rcsnum_differ(srev, rev))
			goto bad;
		rcsnum_tostr(rev, rbuf, sizeof(rbuf));
		fi->crevstr = xstrdup(rbuf);
		free(rev);
	} else if (runflags & T_DELETE)
		goto bad;

	fi->tag_new = xstrdup(tag_name);

	if (runflags & T_BRANCH)
		fi->tag_type = 'T';
	else if (runflags & T_DELETE)
		fi->tag_type = '?';
	else
		fi->tag_type = 'N';

	if (runflags & T_FORCE_MOVE)
		fi->tag_op = "mov";
	else if (runflags & T_DELETE)
		fi->tag_op = "del";
	else
		fi->tag_op = "add";

	TAILQ_INSERT_TAIL(&files_info, fi, flist);
	return;

bad:
	free(fi->file_path);
	free(fi->crevstr);
	free(fi->nrevstr);
	free(fi->tag_new);
	free(fi->tag_old);
	free(rev);
	free(fi);
}

void
cvs_tag_local(struct cvs_file *cf)
{
	cvs_log(LP_TRACE, "cvs_tag_local(%s)", cf->file_path);

	cvs_file_classify(cf, tag);

	if (cf->file_type == CVS_DIR) {
		if (verbosity > 1) {
			cvs_log(LP_NOTICE, "%s %s",
			    (runflags & T_DELETE) ? "Untagging" : "Tagging",
			    cf->file_path);
		}
		return;
	}

	if (runflags & T_DELETE) {
		if (tag_del(cf) == 0) {
			if (verbosity > 0)
				cvs_printf("D %s\n", cf->file_path);
		}
		return;
	}

	switch (cf->file_status) {
	case FILE_ADDED:
		if (verbosity > 1) {
			cvs_log(LP_NOTICE,
			    "couldn't tag added but un-committed file `%s'",
			    cf->file_path);
		}
		break;
	case FILE_REMOVED:
		if (verbosity > 1) {
			cvs_log(LP_NOTICE,
			    "skipping removed but un-committed file `%s'",
			    cf->file_path);
		}
		break;
	case FILE_CHECKOUT:
	case FILE_MODIFIED:
	case FILE_PATCH:
	case FILE_UPTODATE:
		if (tag_add(cf) == 0) {
			if (verbosity > 0)
				cvs_printf("T %s\n", cf->file_path);
			cvs_history_add(CVS_HISTORY_TAG, cf, tag_name);
		}
		break;
	default:
		break;
	}
}

static int
tag_del(struct cvs_file *cf)
{
	if (cf->file_rcs == NULL)
		return (-1);

	if (cvs_noexec == 1)
		return (0);

	return (rcs_sym_remove(cf->file_rcs, tag_name));
}

static int
tag_add(struct cvs_file *cf)
{
	int ret;
	char revbuf[CVS_REV_BUFSZ], trevbuf[CVS_REV_BUFSZ];
	RCSNUM *srev, *trev;
	struct rcs_sym *sym;

	if (cf->file_rcs == NULL) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "cannot find revision "
			    "control file for `%s'", cf->file_name);
		return (-1);
	}

	if (cvs_cmdop == CVS_OP_TAG) {
		if (cf->file_ent == NULL)
			return (-1);
		srev = cf->file_ent->ce_rev;
	} else
		srev = cf->file_rcsrev;

	if (cvs_noexec == 1)
		return (0);

	(void)rcsnum_tostr(srev, revbuf, sizeof(revbuf));

	trev = rcs_sym_getrev(cf->file_rcs, tag_name);
	if (trev != NULL) {
		if (rcsnum_cmp(srev, trev, 0) == 0) {
			free(trev);
			return (-1);
		}
		(void)rcsnum_tostr(trev, trevbuf, sizeof(trevbuf));
		free(trev);

		if (!(runflags & T_FORCE_MOVE)) {
			cvs_printf("W %s : %s ", cf->file_path, tag_name);
			cvs_printf("already exists on version %s", trevbuf);
			cvs_printf(" : NOT MOVING tag to version %s\n", revbuf);

			return (-1);
		} else {
			sym = rcs_sym_get(cf->file_rcs, tag_name);
			rcsnum_cpy(srev, sym->rs_num, 0);
			cf->file_rcs->rf_flags &= ~RCS_SYNCED;

			return (0);
		}
	}

	if (runflags & T_BRANCH) {
		if ((trev = rcs_branch_new(cf->file_rcs, srev)) == NULL)
			fatal("Cannot create a new branch");
	} else {
		trev = rcsnum_alloc();
		rcsnum_cpy(srev, trev, 0);
	}

	if ((ret = rcs_sym_add(cf->file_rcs, tag_name, trev)) != 0) {
		if (ret != 1) {
			cvs_log(LP_NOTICE,
			    "failed to set tag %s to revision %s in %s",
			    tag_name, revbuf, cf->file_rcs->rf_path);
		}
		free(trev);
		return (-1);
	}

	free(trev);
	return (0);
}
@


1.86
log
@Fix opencvs tag so it does not attempt to to local operations in a remote setup.

While here make sure the "up-to-date" check (-c) works as one expects.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.85 2016/10/27 07:12:02 joris Exp $	*/
d159 1
a159 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
@


1.85
log
@minor whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.84 2016/10/13 20:51:25 fcambus Exp $	*/
d39 2
a40 1
static int	 runflags = 0;
d121 1
a121 1
			if (argv[i][0] == '/')
d124 1
d126 1
a126 1
	} else if (cvs_cmdop == CVS_OP_TAG && argc == 0)
d128 1
d134 1
a134 1
	if (!rcs_sym_check(tag_name))
d137 1
d163 5
d190 7
a196 4
	} else {
		if (cvs_cmdop == CVS_OP_RTAG &&
		    chdir(current_cvsroot->cr_dir) == -1)
			fatal("cvs_tag: %s", strerror(errno));
d199 2
a200 1
	cr.flags = flags;
d202 1
d205 12
a217 7
		TAILQ_INIT(&files_info);
		cr.fileproc = cvs_tag_check_files;
		if (argc > 0)
			cvs_file_run(argc, argv, &cr);
		else
			cvs_file_run(1, &arg, &cr);

d219 2
a220 5
		    line_list, &files_info)) {
			cvs_log(LP_ERR, "Pre-tag check failed");
			cvs_trigger_freelist(line_list);
			goto bad;
		}
d226 4
a229 17
	if (cvs_cmdop == CVS_OP_TAG ||
	    current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
		if (argc > 0)
			cvs_file_run(argc, argv, &cr);
		else
			cvs_file_run(1, &arg, &cr);
	}

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");

		cvs_client_send_request((cvs_cmdop == CVS_OP_RTAG) ?
		    "rtag" : "tag");

		cvs_client_get_responses();
	}
a230 1
bad:
d248 1
a248 1
	if (cf->file_type == CVS_DIR)
d255 3
a338 10
	}

	if (runflags & T_CHECK_UPTODATE) {
		if (cf->file_status != FILE_UPTODATE &&
		    cf->file_status != FILE_CHECKOUT &&
		    cf->file_status != FILE_PATCH) {
			cvs_log(LP_NOTICE,
			    "%s is locally modified", cf->file_path);
			return;
		}
@


1.84
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.83 2015/12/22 21:36:57 mmcc Exp $	*/
d124 1
a124 1
        } else if (cvs_cmdop == CVS_OP_TAG && argc == 0)
a184 1

@


1.83
log
@commited -> committed
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.82 2015/11/05 09:48:21 nicm Exp $	*/
d288 1
a288 1
		rcsnum_free(rev);
d317 1
a317 2
	if (rev != NULL)
		rcsnum_free(rev);
d427 1
a427 1
			rcsnum_free(trev);
d431 1
a431 1
		rcsnum_free(trev);
d462 1
a462 1
		rcsnum_free(trev);
d466 1
a466 1
	rcsnum_free(trev);
@


1.82
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.81 2015/01/16 06:40:07 deraadt Exp $	*/
d360 1
a360 1
			    "couldn't tag added but un-commited file `%s'",
d367 1
a367 1
			    "skipping removed but un-commited file `%s'",
@


1.81
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.80 2010/10/28 12:30:27 tobias Exp $	*/
d19 1
d312 5
a316 10
	if (fi->file_path != NULL)
		xfree(fi->file_path);
	if (fi->crevstr != NULL)
		xfree(fi->crevstr);
	if (fi->nrevstr != NULL)
		xfree(fi->nrevstr);
	if (fi->tag_new != NULL)
		xfree(fi->tag_new);
	if (fi->tag_old != NULL)
		xfree(fi->tag_old);
d319 1
a319 1
	xfree(fi);
@


1.80
log
@Fix memory leak.

ok stsp, zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.79 2009/03/24 18:33:25 joris Exp $	*/
d68 1
a68 1
	char repo[MAXPATHLEN];
d189 1
a189 1
	cvs_get_repository_name(".", repo, MAXPATHLEN);
@


1.79
log
@have CVS_OP_TAG and CVS_OP_RTAG use RCS_WRITE flag
when calling rcs_open(), so it gets automaticly synced
at the end of operations for that file instead of explicitly
calling rcs_write() when you're in RCS_READ mode only.

while here, make sure we do not try to free an uninitialized list.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.78 2009/03/22 18:41:25 tobias Exp $	*/
d287 1
@


1.78
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.77 2009/03/22 18:40:55 tobias Exp $	*/
d229 3
a231 1
	cvs_trigger_freeinfo(&files_info);
a354 2

			rcs_write(cf->file_rcs);
a380 2

			rcs_write(cf->file_rcs);
@


1.77
log
@Avoid the usage of uninitialized value, which even might result in a memory
leak if a file has no line in CVS/Entries.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.76 2008/06/20 14:04:29 tobias Exp $	*/
d366 1
a366 1
		return;
d373 1
a373 1
		return;
@


1.76
log
@Properly send -D arguments to server when run as a client.  Issue spotted
by sthen.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.75 2008/06/15 04:38:52 tobias Exp $	*/
a262 3
	fi = xcalloc(1, sizeof(*fi));
	fi->nrevstr = xstrdup(rbuf);

d271 2
@


1.75
log
@Support the addition of new files in branches.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.74 2008/06/10 01:00:34 joris Exp $	*/
d172 3
@


1.74
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.73 2008/03/18 13:00:12 reyk Exp $	*/
d453 1
a453 1
		if ((trev = rcsnum_new_branch(srev)) == NULL)
a454 14

		for (;;) {
			TAILQ_FOREACH(sym, &(cf->file_rcs->rf_symbols), rs_list)
				if (!rcsnum_cmp(sym->rs_num, trev, 0))
					break;

			if (sym != NULL) {
				if (rcsnum_inc(trev) == NULL)
					fatal("New revision too high");
				if (rcsnum_inc(trev) == NULL)
					fatal("New revision too high");
			} else
				break;
		}
@


1.73
log
@sync the usage with the manpage, use "symbolic_tag" instead of "tag"
for the argument to distinguish it from the command keyword which is
less confusing.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.72 2008/03/12 13:54:49 joris Exp $	*/
d30 1
d36 2
d68 1
d71 1
a181 1
		cr.fileproc = cvs_tag_local;
d186 21
d225 2
d228 91
@


1.72
log
@missing rcsnum_free();
from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.71 2008/03/09 03:14:52 joris Exp $	*/
d45 1
a45 1
	"[-bcdFflR] [-D date | -r rev] tag modules ...",
d55 1
a55 1
	"[-bcdFflR] [-D date | -r rev] tag [file ...]",
@


1.71
log
@proper repository locking:
- all read operations now look for a lock, and wait if present but never
  try to lock the tree themselfs anymore.
- all write operations lock the tree where needed.
- commit locks all relevant directories before even attempting to start.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.70 2008/03/02 19:05:34 tobias Exp $	*/
d317 1
@


1.70
log
@Print the right synopsis for commands on error (especially if commands
share the same function: (r)tag, etc.).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.69 2008/03/01 21:29:37 deraadt Exp $	*/
d42 1
a42 1
	CVS_OP_RTAG, 0, "rtag",
d52 1
a52 1
	CVS_OP_TAG, CVS_USE_WDIR, "tag",
@


1.69
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.68 2008/03/01 20:03:56 joris Exp $	*/
d98 3
a100 1
			fatal("%s", cvs_cmd_tag.cmd_synopsis);
@


1.68
log
@goodbye rcs_errno - we didnt use you and you wont be missed
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.67 2008/02/09 13:03:29 joris Exp $	*/
d237 1
a237 1
	switch(cf->file_status) {
@


1.67
log
@simplify some stuff;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.66 2008/02/09 11:56:58 joris Exp $	*/
d284 1
d353 2
a354 2
	if (rcs_sym_add(cf->file_rcs, tag_name, trev) == -1) {
		if (rcs_errno != RCS_ERR_DUPENT) {
@


1.66
log
@spacing police
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.65 2008/02/04 21:25:32 tobias Exp $	*/
d321 1
a321 1
		} else if (runflags & T_FORCE_MOVE) {
@


1.65
log
@r* commands have their own usage; don't check usage of their working dir
equivalents.

OK joris@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.64 2008/01/31 22:09:05 xsa Exp $	*/
d111 5
a115 4
                for (i = 1; i < argc; i++)
                        if (argv[i][0] == '/')
                                fatal("Absolute path name is invalid: %s",
                                    argv[i]);
@


1.64
log
@Zap trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.63 2008/01/31 10:15:05 tobias Exp $	*/
d70 2
a71 1
	while ((ch = getopt(argc, argv, cvs_cmd_tag.cmd_opts)) != -1) {
@


1.63
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.62 2008/01/28 20:31:07 tobias Exp $	*/
d109 1
a109 1
        
@


1.62
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.61 2008/01/10 11:25:27 tobias Exp $	*/
d52 1
a52 1
	CVS_OP_TAG, 0, "tag",
d105 2
@


1.61
log
@Synced rlog's usage checks and with rtag. Also unbreaks rtag and rlog with
GNU cvs on server-side.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.60 2008/01/10 11:20:29 tobias Exp $	*/
d91 1
@


1.60
log
@Added support for rtag in local and remote setups (with interoperability
with GNU cvs).  Basically we already had rtag in place as tag is supposed
to work with revisions in working directory, but our implementation was
wrong.  Fixed that on the fly as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.59 2008/01/10 09:39:32 tobias Exp $	*/
d176 1
a176 1
	    current_cvsroot->cr_method == CVS_METHOD_LOCAL)) {
@


1.59
log
@Slap in -b support for tag command.  It was missing for a full regress test
as of now.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.58 2007/11/17 12:42:39 tobias Exp $	*/
d18 2
d41 10
d64 1
a64 1
	int ch, flags;
d103 9
a111 1
	if (argc == 0)
d166 4
d175 7
a181 4
	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);
d186 4
a189 1
		cvs_client_send_request("tag");
d201 2
a211 2
	cvs_file_classify(cf, tag);

d249 1
d280 1
a280 1
	RCSNUM *trev;
d290 7
d300 1
a300 1
	(void)rcsnum_tostr(cf->file_rcsrev, revbuf, sizeof(revbuf));
d304 1
a304 1
		if (rcsnum_cmp(cf->file_rcsrev, trev, 0) == 0) {
d318 1
a318 1
			rcsnum_cpy(cf->file_rcsrev, sym->rs_num, 0);
d326 1
a326 1
		if ((trev = rcsnum_new_branch(cf->file_rcsrev)) == NULL)
d344 1
a344 1
		rcsnum_cpy(cf->file_rcsrev, trev, 0);
@


1.58
log
@Convert file_rcsrev earlier into a string, else revbuf can be printed
without initialisation.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.57 2007/06/28 21:38:09 xsa Exp $	*/
d26 1
d60 3
d126 3
d287 23
a309 1
	if (rcs_sym_add(cf->file_rcs, tag_name, cf->file_rcsrev) == -1) {
d315 1
d319 1
@


1.57
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.56 2007/06/18 17:54:13 joris Exp $	*/
d255 2
a281 2
			(void)rcsnum_tostr(cf->file_rcsrev, revbuf,
			    sizeof(revbuf));
@


1.56
log
@first stab at history stuff for opencvs, currently only writes
to CVSROOT/history but cannot parse it yet with the 'history' command.

"Commit it." ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.55 2007/02/22 06:42:09 otto Exp $	*/
d241 1
a241 1
	char revbuf[16], trevbuf[16];
@


1.55
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.54 2007/02/09 03:49:15 joris Exp $	*/
d218 1
@


1.54
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.53 2007/01/11 02:35:55 joris Exp $	*/
d18 1
a18 1
#include "includes.h"
a20 1
#include "log.h"
@


1.53
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.52 2006/11/09 12:51:23 xsa Exp $	*/
d174 1
a174 1
	cvs_file_classify(cf, tag, 0);
@


1.52
log
@add support for -c (Check that working files are not modified).
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.51 2006/11/09 10:08:33 xsa Exp $	*/
d120 1
@


1.51
log
@fix pasto..
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.50 2006/11/09 09:24:28 xsa Exp $	*/
d24 4
d33 1
a33 2
static int	 tag_delete = 0;
static int	 tag_force_move = 0;
d60 3
d67 1
a67 1
			tag_delete = 1;
d70 1
a70 1
			tag_force_move = 1;
d100 1
a100 1
		if (tag_delete == 1)
d107 1
a107 1
		if (tag_delete == 1)
d122 4
a125 1
		if (tag_delete == 1)
d128 1
a128 1
		if (tag_force_move == 1)
d167 1
a167 1
			    (tag_delete == 1) ? "Untagging" : "Tagging",
d175 11
a185 1
	if (tag_delete == 1) {
d262 1
a262 1
		if (tag_force_move == 0) {
d268 1
a268 1
		} else if (tag_force_move == 1) {
@


1.50
log
@remote tag command support joins the party!
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.49 2006/07/02 21:11:54 reyk Exp $	*/
a23 1
int	cvs_tag(int, char **);
@


1.49
log
@for cvs tag, tag all files in the local directory if no file argument
is given.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.48 2006/06/19 05:05:17 joris Exp $	*/
d22 1
d30 2
a31 2
static int	tag_delete = 0;
static int	tag_force_move = 0;
d113 21
a133 1
	cr.fileproc = cvs_tag_local;
d140 7
@


1.48
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.47 2006/06/16 14:07:42 joris Exp $	*/
d50 1
d115 4
a118 1
	cvs_file_run(argc, argv, &cr);
@


1.47
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.46 2006/06/09 14:57:13 xsa Exp $	*/
d111 1
a111 2
	cr.local = cvs_tag_local;
	cr.remote = NULL;
@


1.46
log
@handle `cvs tag -F'; input && OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.45 2006/06/07 18:19:07 xsa Exp $	*/
a21 1
#include "proto.h"
d37 1
a37 1
	CVS_OP_TAG, CVS_REQ_TAG, "tag",
@


1.45
log
@bring back tag command; basic tag addition/deletion available. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a35 1
static RCSNUM	*tag_rev = NULL;
d63 3
d192 3
a194 1
	char revbuf[16];
d206 23
d231 2
a232 1
			(void)rcsnum_tostr(tag_rev, revbuf, sizeof(revbuf));
@


1.44
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.43 2006/04/14 02:45:35 deraadt Exp $	*/
d3 1
a3 4
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * Copyright (c) 2004 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d24 12
a35 15
#define TAG_BRANCH	(1<<0)
#define TAG_DELETE	(1<<1)
#define TAG_FORCE_HEAD	(1<<2)
#define TAG_FORCE_RM	(1<<3)
#define UPTODATE	(1<<4)

static int	cvs_tag_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_tag_local(CVSFILE *, void *);
static int	cvs_tag_remote(CVSFILE *, void *);
static int	cvs_tag_pre_exec(struct cvsroot *);

static int runflags = 0;
static char *tag_name = NULL;
static char *tag_date = NULL;
static char *tag_oldname = NULL;
d44 1
a44 8
	CF_SORT | CF_IGNORE | CF_RECURSE,
	cvs_tag_init,
	cvs_tag_pre_exec,
	cvs_tag_remote,
	cvs_tag_local,
	NULL,
	NULL,
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR
d47 2
a48 20

struct cvs_cmd cvs_cmd_rtag = {
	CVS_OP_RTAG, CVS_REQ_TAG, "rtag",
	{ "rt", "rfreeze" },
	"Add a symbolic tag to a module",
	"[-abdFflnR] [-D date | -r rev] tag modules ...",
	"abD:fFflnRr:",
	NULL,
	CF_SORT | CF_IGNORE | CF_RECURSE,
	cvs_tag_init,
	cvs_tag_pre_exec,
	cvs_tag_remote,
	cvs_tag_local,
	NULL,
	NULL,
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR
};

static int
cvs_tag_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d50 2
a51 1
	int ch;
d53 1
a53 1
	tag_date = tag_oldname = NULL;
d55 1
a55 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
d57 2
a58 5
		case 'b':
			runflags |= TAG_BRANCH;
			break;
		case 'c':
			runflags |= UPTODATE;
d61 1
a61 10
			runflags |= TAG_DELETE;
			break;
		case 'F':
			runflags |= TAG_FORCE_RM;
			break;
		case 'f':
			runflags |= TAG_FORCE_HEAD;
			break;
		case 'D':
			tag_date = optarg;
d64 1
a64 1
			cmd->file_flags &= ~CF_RECURSE;
a66 1
			cmd->file_flags |= CF_RECURSE;
d72 1
a72 1
			return (CVS_EX_USAGE);
a75 1
	*arg = optind;
d80 5
a84 7
		return (CVS_EX_USAGE);
	else {
		tag_name = argv[0];
		argc--;
		argv++;
		*arg += 1;
	}
d90 22
a111 7
	if ((runflags & TAG_BRANCH) && (runflags & TAG_DELETE)) {
		cvs_log(LP_WARN, "ignoring -b with -d options");
		runflags &= ~TAG_BRANCH;
	}

	if ((runflags & TAG_DELETE) && tag_oldname != NULL)
		tag_oldname = NULL;
d113 1
a113 7
	if ((runflags & TAG_DELETE) && tag_date != NULL)
		tag_date = NULL;

	if ((tag_oldname != NULL) && tag_date != NULL) {
		cvs_log(LP_ERR, "the -D and -r options are mutually exclusive");
		return (CVS_EX_USAGE);
	}
d118 2
a119 2
static int
cvs_tag_pre_exec(struct cvsroot *root)
d121 1
a121 3
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (runflags & TAG_BRANCH)
			cvs_sendarg(root, "-b", 0);
d123 8
a130 2
		if (runflags & UPTODATE)
			cvs_sendarg(root, "-c", 0);
d132 1
a132 2
		if (runflags & TAG_DELETE)
			cvs_sendarg(root, "-d", 0);
d134 4
a137 2
		if (runflags & TAG_FORCE_RM)
			cvs_sendarg(root, "-F", 0);
d139 4
a142 2
		if (runflags & TAG_FORCE_HEAD)
			cvs_sendarg(root, "-f", 0);
d144 6
a149 3
		if (tag_oldname != NULL) {
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, tag_oldname, 0);
d151 14
d166 1
a166 3
		if (tag_date != NULL) {
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, tag_date, 0);
d168 3
a170 2

		cvs_sendarg(root, tag_name, 0);
a171 1
	return (0);
a173 6

/*
 * cvs_tag_remote()
 *
 * Get the status of a single file.
 */
d175 1
a175 1
cvs_tag_remote(CVSFILE *cfp, void *arg)
d177 2
a178 4
	char fpath[MAXPATHLEN];
	struct cvsroot *root;

	root = CVS_DIR_ROOT(cfp);
d180 1
a180 2
	if (cfp->cf_type == DT_DIR) {
		cvs_senddir(root, cfp);
a181 1
	}
d183 1
a183 18
	cvs_sendentry(root, cfp);
	cvs_file_getpath(cfp, fpath, sizeof(fpath));

	switch (cfp->cf_cvstat) {
	case CVS_FST_UNKNOWN:
		cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
		break;
	case CVS_FST_UPTODATE:
		cvs_sendreq(root, CVS_REQ_UNCHANGED, cfp->cf_name);
		break;
	case CVS_FST_MODIFIED:
		cvs_sendreq(root, CVS_REQ_ISMODIFIED, cfp->cf_name);
		break;
	default:
		break;
	}

	return (0);
a185 1

d187 1
a187 1
cvs_tag_local(CVSFILE *cf, void *arg)
d189 1
a189 5
	char fpath[MAXPATHLEN], numbuf[64], rcspath[MAXPATHLEN];
	RCSFILE *rf;
	RCSNUM *tag_rev;

	cvs_file_getpath(cf, fpath, sizeof(fpath));
d191 1
a191 1
	if (cf->cf_type == DT_DIR) {
d193 3
a195 22
			cvs_log(LP_NOTICE, "%s %s",
			    (runflags & TAG_DELETE) ? "Untagging" : "Tagging",
			    fpath);
		return (CVS_EX_OK);
	}

	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		if (verbosity > 1)
			cvs_log(LP_WARN, "nothing known about %s", fpath);
		return (0);
	} else if (cf->cf_cvstat == CVS_FST_ADDED) {
		if (verbosity > 1)
			cvs_log(LP_WARN,
			    "couldn't tag added but un-commited file `%s'",
			    fpath);
		return (0);
	} else if (cf->cf_cvstat == CVS_FST_REMOVED) {
		if (verbosity > 1)
			cvs_log(LP_WARN,
			    "skipping removed but un-commited file `%s'",
			    fpath);
		return (0);
d198 1
a198 19
	tag_rev = cf->cf_lrev;

	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));

	if ((rf = rcs_open(rcspath, RCS_READ|RCS_WRITE)) == NULL)
		fatal("cvs_tag_local: rcs_open: %s: %s", rcspath,
		    rcs_errstr(rcs_errno));

	if (runflags & TAG_DELETE) {
		if (cvs_noexec == 0) {
			if (rcs_sym_remove(rf, tag_name) < 0)
				fatal("failed to remove tag %s from %s",
				    tag_name, rcspath);
		}

		if (verbosity > 0)
			cvs_printf("D %s\n", fpath);

		rcs_close(rf);
a199 1
	}
d201 6
a206 5
	if (cvs_noexec == 0) {
		if (rcs_sym_add(rf, tag_name, tag_rev) < 0) {
			rcsnum_tostr(tag_rev, numbuf, sizeof(numbuf));
			fatal("failed to set tag %s to revision %s in %s",
			    tag_name, numbuf, rcspath);
d208 1
a210 4
	if (verbosity > 0)
		cvs_printf("T %s\n", fpath);

	rcs_close(rf);
@


1.43
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.42 2006/04/12 14:09:11 xsa Exp $	*/
@


1.42
log
@missing break; "Yeah, obvious" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.41 2006/03/08 05:01:50 deraadt Exp $	*/
d149 1
a149 1
	if ((runflags & TAG_DELETE) && (tag_oldname != NULL))
d152 1
a152 1
	if ((runflags & TAG_DELETE) && (tag_date != NULL))
d155 1
a155 1
	if ((tag_oldname != NULL) && (tag_date != NULL)) {
@


1.41
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.40 2006/02/06 08:33:03 xsa Exp $	*/
d228 1
@


1.40
log
@- use biwise flags
- add missing option in remote handler
OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.39 2006/02/01 14:30:34 xsa Exp $	*/
d146 1
a146 1
		runflags &= ~TAG_BRANCH;	
@


1.39
log
@allow tag deletion with -d option; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.38 2006/01/27 15:42:35 xsa Exp $	*/
d5 1
d35 5
d46 1
a49 4
static int tag_branch = 0;
static int tag_delete = 0;
static int tag_forcehead = 0;
static int tag_forcemove = 0;
d55 1
a55 1
	"[-bcdFflR] [-D date | -r rev] tagname ...",
d73 1
a73 1
	"[-abdFflnR] [-D date | -r rev] symbolic_tag modules ...",
d96 4
a99 1
			tag_branch = 1;
d102 1
a102 1
			tag_delete = 1;
d105 1
a105 1
			tag_forcemove = 1;
d108 1
a108 1
			tag_forcehead = 1;
d131 1
a131 1
	if (argc == 0) {
d133 1
a133 1
	} else {
d144 1
a144 1
	if ((tag_branch == 1) && (tag_delete == 1)) {
d146 1
a146 1
		tag_branch = 0;
d149 1
a149 1
	if ((tag_delete == 1) && (tag_oldname != NULL))
d152 1
a152 1
	if ((tag_delete == 1) && (tag_date != NULL))
d167 1
a167 1
		if (tag_branch == 1)
d170 4
a173 1
		if (tag_delete == 1)
d176 1
a176 1
		if (tag_forcemove == 1)
d179 1
a179 1
		if (tag_forcehead == 1)
a193 1

d248 2
a249 1
			    tag_delete ? "Untagging" : "Tagging", fpath);
d279 1
a279 1
	if (tag_delete == 1) {
@


1.38
log
@CVS_EX_BADROOT return code is not worth keeping;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.37 2006/01/27 08:50:51 xsa Exp $	*/
d231 1
a231 1
	char fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
d271 6
a276 1
		/* XXX */
d280 1
d285 5
a289 3
		if (rcs_sym_add(rf, tag_name, tag_rev) < 0)
			fatal("cvs_tag_local: rcs_sym_add: %s: %s", rcspath,
			    rcs_errstr(rcs_errno));
@


1.37
log
@use fatal();
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.36 2006/01/02 08:11:56 xsa Exp $	*/
d134 2
a135 3
	if (!rcs_sym_check(tag_name)) {
		cvs_log(LP_ABORT,
		    "tag `%s' must not contain the characters `%s'",
a136 2
		return (CVS_EX_BADTAG);
	}
@


1.36
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.35 2005/12/30 02:03:28 joris Exp $	*/
d269 2
a270 3
	rf = rcs_open(rcspath, RCS_READ|RCS_WRITE);
	if (rf == NULL) {
		cvs_log(LP_ERR, "failed to open %s: %s", rcspath,
a271 2
		return (CVS_EX_DATA);
	}
d282 2
a283 2
		if (rcs_sym_add(rf, tag_name, tag_rev) < 0) {
			cvs_log(LP_ERR, "failed to tag %s: %s", rcspath,
a284 1
		}
@


1.35
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.34 2005/12/22 14:59:54 xsa Exp $	*/
d28 1
a28 6
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
@


1.34
log
@cvs_rcs_getpath() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.33 2005/09/27 16:33:35 xsa Exp $	*/
d169 2
a170 2
		if ((tag_branch == 1) && (cvs_sendarg(root, "-b", 0) < 0))
			return (CVS_EX_PROTO);
d172 2
a173 2
		if ((tag_delete ==1) && (cvs_sendarg(root, "-d", 0) < 0))
			return (CVS_EX_PROTO);
d175 2
a176 2
		if ((tag_forcemove == 1) && (cvs_sendarg(root, "-F", 0) < 0))
			return (CVS_EX_PROTO);
d178 2
a179 2
		if ((tag_forcehead == 1) && (cvs_sendarg(root, "-f", 0) < 0))
			return (CVS_EX_PROTO);
d181 4
a184 4
		if ((tag_oldname != NULL) &&
		    ((cvs_sendarg(root, "-r", 0) < 0) ||
		    (cvs_sendarg(root, tag_oldname, 0) < 0)))
				return (CVS_EX_PROTO);
d186 4
a189 3
		if ((tag_date != NULL) && ((cvs_sendarg(root, "-D", 0) < 0) ||
		    (cvs_sendarg(root, tag_date, 0) < 0)))
				return (CVS_EX_PROTO);
d191 1
a191 2
		if (cvs_sendarg(root, tag_name, 0) < 0)
			return (CVS_EX_PROTO);
a205 1
	int ret;
a208 1
	ret = 0;
d212 2
a213 7
		if (cvs_senddir(root, cfp) < 0)
			ret = CVS_EX_PROTO;
		return (ret);
	}

	if (cvs_sendentry(root, cfp) < 0) {
		return (CVS_EX_PROTO);
d216 1
d221 1
a221 1
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
d224 1
a224 1
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED, cfp->cf_name);
d227 1
a227 1
		ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED, cfp->cf_name);
d232 1
a232 4
	if (ret == -1)
		ret = CVS_EX_PROTO;

	return (ret);
@


1.33
log
@add some file status checks in local setup;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.32 2005/09/26 18:33:54 xsa Exp $	*/
d281 1
a281 2
	if (cvs_rcs_getpath(cf, rcspath, sizeof(rcspath)) == NULL)
		return (CVS_EX_DATA);
@


1.32
log
@some more style nits and bits;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.31 2005/09/26 17:43:48 xsa Exp $	*/
d264 12
@


1.31
log
@style;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.30 2005/08/08 11:40:07 xsa Exp $	*/
d169 1
a169 1
		if (tag_branch && (cvs_sendarg(root, "-b", 0) < 0))
d172 1
a172 1
		if (tag_delete && (cvs_sendarg(root, "-d", 0) < 0))
d175 1
a175 1
		if (tag_forcemove && (cvs_sendarg(root, "-F", 0) < 0))
d178 1
a178 1
		if (tag_forcehead && (cvs_sendarg(root, "-f", 0) < 0))
d181 2
a182 1
		if ((tag_oldname) && ((cvs_sendarg(root, "-r", 0) < 0) ||
d186 1
a186 1
		if ((tag_date) && ((cvs_sendarg(root, "-D", 0) < 0) ||
d277 8
@


1.30
log
@add rtag command aliases;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.29 2005/07/27 16:42:19 xsa Exp $	*/
d146 1
a146 1
	if (tag_branch && tag_delete) {
d151 1
a151 1
	if (tag_delete && tag_oldname)
d154 1
a154 1
	if (tag_delete && tag_date)
d157 1
a157 1
	if (tag_oldname != NULL && tag_date != NULL) {
@


1.29
log
@use LP_NOTICE instead of LP_INFO where appropriate;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.28 2005/07/25 12:13:08 xsa Exp $	*/
d73 1
a73 1
	{  },
@


1.28
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.27 2005/07/24 16:46:40 xsa Exp $	*/
d255 1
a255 1
			cvs_log(LP_INFO, "%s %s",
@


1.27
log
@do not use `if (!var)' unless it's boolean, better use an == check;
ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.26 2005/07/18 07:22:23 xsa Exp $	*/
d40 4
a43 4
static int cvs_tag_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_tag_local    (CVSFILE *, void *);
static int cvs_tag_remote   (CVSFILE *, void *);
static int cvs_tag_pre_exec (struct cvsroot *);
@


1.26
log
@be consistent w/ warning messages (and handle -Q);
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.25 2005/07/14 06:50:50 xsa Exp $	*/
d278 1
a278 1
	if (!cvs_noexec) {
@


1.25
log
@use cvs_rcs_getpath();
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.24 2005/07/11 10:33:57 xsa Exp $	*/
d261 2
a262 1
		cvs_log(LP_WARN, "I know nothing about %s", fpath);
@


1.24
log
@fix another case where a message shouldnt be printed if -Q is specified;
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.23 2005/07/11 09:08:47 xsa Exp $	*/
d247 1
a247 3
	int len;
	char *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	struct cvsroot *root;
a264 2
	repo = CVS_DIR_REPO(cf);
	root = CVS_DIR_ROOT(cf);
d267 1
a267 5
	len = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, cf->cf_name, RCS_FILE_EXT);
	if (len == -1 || len >= (int)sizeof(rcspath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rcspath);
a268 1
	}
@


1.23
log
@display info message only if -q is not specified.
also display correct message wether -d is specified or not.
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.22 2005/07/07 14:27:57 joris Exp $	*/
d293 2
a294 1
	cvs_printf("T %s\n", fpath);
@


1.22
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.21 2005/06/28 13:20:53 xsa Exp $	*/
d256 3
a258 1
		cvs_log(LP_INFO, "Tagging %s", fpath);
@


1.21
log
@- add `rtag' command usage
- add -F and -f

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.20 2005/05/31 08:26:40 xsa Exp $	*/
d232 1
a232 1
		ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED, cfp->cf_name); 
@


1.20
log
@remove LP_ERROR log priority level and rather use LP_ERR as they are both
the same...

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.19 2005/05/29 00:55:10 xsa Exp $	*/
d51 1
d75 2
a76 2
	"",
	"",
d103 3
d175 8
a182 3
		if (tag_oldname) {
			if ((cvs_sendarg(root, "-r", 0) < 0) ||
			    (cvs_sendarg(root, tag_oldname, 0) < 0))
a183 1
		}
d185 2
a186 3
		if (tag_date) {
			if ((cvs_sendarg(root, "-D", 0) < 0) ||
			    (cvs_sendarg(root, tag_date, 0) < 0))
a187 1
		}
@


1.19
log
@consistency in error messages ...
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.18 2005/05/24 07:38:46 xsa Exp $	*/
d154 1
a154 2
		cvs_log(LP_ERROR,
		    "the -D and -r options are mutually exclusive");
@


1.18
log
@cvs_noexec checks; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.17 2005/05/24 04:12:25 jfb Exp $	*/
d154 2
a155 1
		cvs_log(LP_ERROR, "-r and -D options are mutually exclusive");
@


1.17
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.16 2005/05/20 20:00:53 joris Exp $	*/
d278 5
a282 3
	if (rcs_sym_add(rf, tag_name, tag_rev) < 0) {
		cvs_log(LP_ERR, "failed to tag %s: %s", rcspath,
		    rcs_errstr(rcs_errno));
@


1.16
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.15 2005/04/20 23:11:30 jfb Exp $	*/
d40 4
a43 4
static int cvs_tag_local     (CVSFILE *, void *);
static int cvs_tag_remote    (CVSFILE *, void *);
static int cvs_tag_options   (char *, int, char **, int *);
static int cvs_tag_sendflags (struct cvsroot *);
d52 7
a58 5
struct cvs_cmd_info cvs_tag = {
	cvs_tag_options,
	cvs_tag_sendflags,
	cvs_tag_remote,	
	NULL, NULL,
d60 24
a83 1
	CVS_REQ_TAG,
d88 1
a88 1
cvs_tag_options(char *opt, int argc, char **argv, int *arg)
d94 1
a94 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d109 4
a112 1
			cvs_tag.file_flags &= ~CF_RECURSE;
d162 1
a162 1
cvs_tag_sendflags(struct cvsroot *root)
d164 6
a169 2
	if (tag_branch && (cvs_sendarg(root, "-b", 0) < 0))
		return (CVS_EX_PROTO);
d171 5
a175 2
	if (tag_delete && (cvs_sendarg(root, "-d", 0) < 0))
		return (CVS_EX_PROTO);
d177 5
a181 5
	if (tag_oldname) {
		if ((cvs_sendarg(root, "-r", 0) < 0) ||
		    (cvs_sendarg(root, tag_oldname, 0) < 0))
			return (CVS_EX_PROTO);
	}
d183 1
a183 3
	if (tag_date) {
		if ((cvs_sendarg(root, "-D", 0) < 0) ||
		    (cvs_sendarg(root, tag_date, 0) < 0))
a186 3
	if (cvs_sendarg(root, tag_name, 0) < 0)
		return (CVS_EX_PROTO);

d249 5
d261 1
d282 2
@


1.15
log
@check the validity of tag names passed to the tag command, and print
an abort message if the tag is invalid.  also, match gnu cvs behaviour
with regards to command usage output on usage errors.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.14 2005/04/19 18:51:30 jfb Exp $	*/
d177 2
a178 1
		ret = cvs_senddir(root, cfp);
d201 3
d232 1
a232 1
		return (-1);
d239 1
a239 1
		return (-1);
@


1.14
log
@big spring cleanup and make tag work again when dealing with multiple
directories by specifying CVS_CMD_SENDDIR, and first stab at the
local version, needs tweaking
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.13 2005/04/18 21:02:50 jfb Exp $	*/
d105 7
@


1.13
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.12 2005/04/16 20:31:18 xsa Exp $	*/
a28 1
#include <sys/stat.h>
a31 1
#include <fcntl.h>
a32 1
#include <unistd.h>
d40 11
a50 6
int cvs_tag_file(CVSFILE *, void *);
int cvs_tag_options(char *, int, char **, int *);
int cvs_tag_sendflags(struct cvsroot *);

static char *tag, *old_tag, *date;
static int branch, delete;
d55 1
a55 1
	cvs_tag_file,	
d59 1
a59 1
	CVS_CMD_ALLOWSPEC
d62 1
a62 1
int
d67 1
a67 2
	date = old_tag = NULL;
	branch = delete = 0;
d72 1
a72 1
			branch = 1;
d75 4
a78 1
			delete = 1;
d81 1
a81 1
			date = optarg;
d87 1
a87 1
			old_tag = optarg;
d101 1
a101 1
		tag = argv[0];
d107 1
a107 1
	if (branch && delete) {
d109 1
a109 1
		branch = 0;
d112 2
a113 2
	if (delete && old_tag)
		old_tag = NULL;
d115 2
a116 2
	if (delete && date)
		date = NULL;
d118 1
a118 1
	if (old_tag != NULL && date != NULL) {
d126 1
a126 1
int
d129 1
a129 1
	if (branch && (cvs_sendarg(root, "-b", 0) < 0))
d132 1
a132 1
	if (delete && (cvs_sendarg(root, "-d", 0) < 0))
d135 1
a135 1
	if (old_tag) {
d137 1
a137 1
		    (cvs_sendarg(root, old_tag, 0) < 0))
d141 1
a141 1
	if (date) {
d143 1
a143 1
		    (cvs_sendarg(root, date, 0) < 0))
d147 1
a147 1
	if (cvs_sendarg(root, tag, 0) < 0)
d155 1
a155 1
 * cvs_tag_file()
d159 2
a160 2
int
cvs_tag_file(CVSFILE *cfp, void *arg)
d162 2
a163 3
	int ret, l;
	char *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	RCSFILE *rf;
a166 1
	rf = NULL;
d169 7
a175 4
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cfp->cf_type == DT_DIR)) {
		if (cvs_senddir(root, cfp) < 0)
			return (CVS_EX_PROTO);
		return (0);
d180 32
a211 4
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_sendentry(root, cfp) < 0) {
			return (CVS_EX_PROTO);
		}
d213 2
a214 20
		switch (cfp->cf_cvstat) {
		case CVS_FST_UNKNOWN:
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cfp));
			break;
		case CVS_FST_UPTODATE:
			ret = cvs_sendreq(root, CVS_REQ_UNCHANGED,
			    CVS_FILE_NAME(cfp));
			break;
		case CVS_FST_MODIFIED:
			ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED, 
			    CVS_FILE_NAME(cfp));
		default:
			break;
		}
	} else {
		if (cfp->cf_cvstat == CVS_FST_UNKNOWN) {
			cvs_log(LP_WARN, "I know nothing about %s", fpath);
			return (0);
		}
d216 7
a222 8
		repo = CVS_DIR_REPO(cfp);
		l = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
		    root->cr_dir, repo, CVS_FILE_NAME(cfp), RCS_FILE_EXT);
		if (l == -1 || l >= (int)sizeof(rcspath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", rcspath);
			return (-1);
		}
d224 6
a229 4
		rf = rcs_open(rcspath, RCS_READ);
		if (rf == NULL) {
			return (CVS_EX_DATA);
		}
d231 3
a233 1
		rcs_close(rf);
d236 2
a237 1
	return (ret);
@


1.12
log
@thought i had committed that earlier;snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.11 2005/04/12 14:58:40 joris Exp $	*/
a160 1
	struct cvs_ent *entp;
a173 1
	entp = cvs_ent_getent(fpath);
d176 1
a176 2
		if ((entp != NULL) && (cvs_sendentry(root, entp) < 0)) {
			cvs_ent_free(entp);
d201 1
a201 5
		if (cfp->cf_parent != NULL)
			repo = cfp->cf_parent->cf_ddat->cd_repo;
		else
			repo = NULL;

a206 2

			cvs_ent_free(entp);
a211 2
			if (entp != NULL)
				cvs_ent_free(entp);
a216 3

	if (entp != NULL)
		cvs_ent_free(entp);
@


1.11
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.10 2005/04/11 18:02:58 joris Exp $	*/
d158 1
a158 1
	int ret;
d209 1
a209 1
		snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
d211 7
@


1.10
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.9 2005/04/11 17:56:27 joris Exp $	*/
d86 1
a86 1
			return (1);
d95 1
a95 1
		return (1);
d116 1
a116 1
		return (-1);
d126 1
a126 1
		return (-1);
d129 1
a129 1
		return (-1);
d134 1
a134 1
			return (-1);
d140 1
a140 1
			return (-1);
d144 1
a144 1
		return (-1);
d170 1
a170 1
			return (-1);
d180 1
a180 1
			return (-1);
d216 1
a216 1
			return (-1);
@


1.9
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.8 2005/04/03 17:32:50 xsa Exp $	*/
a36 1
#include <sysexits.h>
@


1.8
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.7 2005/03/30 17:43:04 joris Exp $	*/
d87 1
a87 1
			return (EX_USAGE);
d96 1
a96 1
		return (EX_USAGE);
@


1.7
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.6 2005/03/26 08:09:54 tedu Exp $	*/
d127 1
a127 1
		return (EX_PROTOCOL);
d130 1
a130 1
		return (EX_PROTOCOL);
d135 1
a135 1
			return (EX_PROTOCOL);
d141 1
a141 1
			return (EX_PROTOCOL);
d145 1
a145 1
		return (EX_PROTOCOL);
@


1.6
log
@fix a variety of things i found at coverity.  ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.5 2005/02/28 20:18:02 joris Exp $	*/
d44 16
a59 1
int cvs_tag_file (CVSFILE *, void *);
a60 7

/*
 * cvs_tag()
 *
 * Handler for the `cvs tag' command.
 * Returns 0 on success, or one of the known exit codes on error.
 */
d62 1
a62 1
cvs_tag(int argc, char **argv)
d64 1
a64 4
	int ch, flags;
	struct cvsroot *root;
	char *tag, *old_tag, *date;
	int branch, delete;
a67 1
	flags = CF_SORT|CF_IGNORE|CF_RECURSE;
d69 1
a69 1
	while ((ch = getopt(argc, argv, "bdD:lr:")) != -1) {
d81 1
a81 1
			flags &= ~CF_RECURSE;
d91 1
d101 1
d120 11
a130 15
	if (argc == 0)
		cvs_files = cvs_file_get(".", flags);
	else
		cvs_files = cvs_file_getspec(argv, argc, 0);
	if (cvs_files == NULL)
		return (EX_DATAERR);

	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
d132 3
a134 18
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_connect(root) < 0)
			return (EX_PROTOCOL);
		if (branch && (cvs_sendarg(root, "-b", 0) < 0))
			return (EX_PROTOCOL);
		if (delete && (cvs_sendarg(root, "-d", 0) < 0))
			return (EX_PROTOCOL);
		if (old_tag) {
			if ((cvs_sendarg(root, "-r", 0) < 0) ||
			    (cvs_sendarg(root, old_tag, 0) < 0))
				return (EX_PROTOCOL);
		}
		if (date) {
			if ((cvs_sendarg(root, "-D", 0) < 0) ||
			    (cvs_sendarg(root, date, 0) < 0))
				return (EX_PROTOCOL);
		}
		if (cvs_sendarg(root, tag, 0) < 0)
d138 3
a140 6
	cvs_file_examine(cvs_files, cvs_tag_file, NULL);

	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0)
			return (EX_PROTOCOL);
		if (cvs_sendreq(root, CVS_REQ_TAG, NULL) < 0)
d143 3
@


1.5
log
@

update my email address.
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.4 2005/02/27 00:22:08 jfb Exp $	*/
d228 2
a229 1
			cvs_ent_free(entp);
@


1.4
log
@Many improvements to the RCS support:

- make it possible to specify creation and the file mode
  in rcs_open()
- implicitly write the contents to disk on rcs_close() if the
  RCS handle has been changed
- fix a bug in the output of the `expand' keyword
- add functions to retrieve and modify the expansion mode
- rcs_parse() shouldn't be available to the outside
- empty string instead of `(null)' if there is no description

ok Joris
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.3 2005/01/14 18:02:04 jfb Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004 Joris Vink <amni@@pandora.be>
@


1.3
log
@support the -D option to the tag command and sync usage for the tag
command

from Joris Vink, with modifications by me
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.2 2004/12/14 22:30:48 jfb Exp $	*/
d226 1
a226 1
		rf = rcs_open(rcspath, RCS_MODE_READ);
@


1.2
log
@First attempt at syncing the command code and doing a lot more error
checking on all the protocol calls
@
text
@d1 1
a1 1
/*	$OpenBSD: tag.c,v 1.1 2004/12/14 19:11:54 jfb Exp $	*/
d58 1
a58 1
	char *tag, *old_tag;
d61 1
a61 1
	old_tag = NULL;
d65 1
a65 1
	while ((ch = getopt(argc, argv, "bdlr:")) != -1) {
d73 3
d106 8
d138 8
a145 2
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, old_tag, 0);
@


1.1
log
@support the tag command

from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a118 3
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cvs_connect(root) < 0))
		return (EX_OSERR);

d120 6
a125 4
		if (branch)
			cvs_sendarg(root, "-b", 0);
		if (delete)
			cvs_sendarg(root, "-d", 0);
d130 2
a131 1
		cvs_sendarg(root, tag, 0);
d137 4
a140 2
		cvs_senddir(root, cvs_files);
		cvs_sendreq(root, CVS_REQ_TAG, NULL);
@

