head	1.53;
access;
symbols
	OPENBSD_6_1:1.53.0.32
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.30
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.26
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.53.0.28
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.20
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.53.0.24
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.22
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.18
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.16
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.14
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.12
	OPENBSD_5_0:1.53.0.10
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.53.0.8
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.6
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.44.0.2
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14;
locks; strict;
comment	@ * @;


1.53
date	2009.03.26.22.54.37;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.25.21.50.33;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.21.13.44.18;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2009.02.21.12.47.19;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.13.17.15.13;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2008.03.09.01.54.03;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.09.01.25.31;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.23.10.49.49;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.13.16.47.48;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.10.21.32.19;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.06.17.09.08;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.05.07.13.49;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.30.21.32.52;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.28.17.25.18;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.28.07.56.44;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.02.09.42.20;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.04.17.39.02;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.03.02.19.17;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.03.01.02.09;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.12.21.34.48;	author niallo;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.17.16.23.19;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.31.21.08.17;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.25.11.07.00;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.22.16.27.29;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.07.19.06.12;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.06.10.04.55;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.14.15.27.31;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.20.05.13.44;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.12.23.35.42;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.25.21.58.32;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.24.14.35.18;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.02.16.56.58;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.15.07.03.04;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.14.21.23.44;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.02.06.54.15;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.06.20.12.15;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.06.14.12.56;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.06.12.09.26;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.02.22.49.50;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.13.54.02;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.30.17.39.27;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.30.11.50.33;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.30.01.49.23;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.53
log
@fix the way Attic is handled in our recursion code, so we
do not skip files or run over them twice.

also fixes -l and -r for checkout/update when a file in
Attic exists with that tag that in HEAD is a directory
in the normal repository like gnu/usr.bin/gcc/INSTALL.

as a bonus, we do not run fstat() twice per file or dir
anymore...

spotted by deraadt@@
@
text
@/*	$OpenBSD: file.h,v 1.52 2009/03/25 21:50:33 joris Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FILE_H
#define FILE_H

#include <sys/queue.h>
#include <sys/tree.h>

#include <dirent.h>
#include <stdio.h>

#include "rcs.h"

struct cvs_file {
	char	*file_name;
	char	*file_wd;
	char	*file_path;
	char	*file_rpath;

	int	 fd;
	int	 repo_fd;
	int	 file_type;
	int	 file_status;
	int	 file_flags;
	int	 in_attic;

	RCSNUM		*file_rcsrev;
	RCSFILE		*file_rcs;
	struct cvs_ent	*file_ent;
};

#define FILE_UNKNOWN		0
#define FILE_ADDED		1
#define FILE_REMOVED		2
#define FILE_MODIFIED		3
#define FILE_UPTODATE		4
#define FILE_LOST		5
#define FILE_CHECKOUT		6
#define FILE_MERGE		7
#define FILE_PATCH		8
#define FILE_REMOVE_ENTRY	9
#define FILE_CONFLICT		10
#define FILE_UNLINK		11

#define DIR_CREATE		12

#define FILE_SKIP		100

#define FILE_HAS_TAG		0x01
#define FILE_USER_SUPPLIED	0x02
#define FILE_INSIDE_ATTIC	0x04
#define FILE_ON_DISK		0x08

struct cvs_filelist {
	RB_ENTRY(cvs_filelist) flist;
	char	*file_path;
	int	flags;
	int	type;
};

RB_HEAD(cvs_flisthead, cvs_filelist);
RB_PROTOTYPE(cvs_flisthead, cvs_filelist, flist, cvs_filelist_cmp);

struct cvs_recursion;

#define CVS_DIR		1
#define CVS_FILE	2

TAILQ_HEAD(cvs_flist, cvs_file);

struct cvs_ignpat {
	char				ip_pat[MAXNAMLEN];
	int				ip_flags;
	TAILQ_ENTRY(cvs_ignpat)		ip_list;
};

TAILQ_HEAD(ignore_head, cvs_ignpat);

void	cvs_file_init(void);
void	cvs_file_ignore(const char *, struct ignore_head *);
void	cvs_file_classify(struct cvs_file *, const char *);
void	cvs_file_free(struct cvs_file *);
void	cvs_file_run(int, char **, struct cvs_recursion *);
void	cvs_file_walklist(struct cvs_flisthead *, struct cvs_recursion *);
void	cvs_file_walkdir(struct cvs_file *, struct cvs_recursion *);
void	cvs_file_freelist(struct cvs_flisthead *);
struct cvs_filelist *cvs_file_get(char *, int, struct cvs_flisthead *, int);

int	cvs_filelist_cmp(struct cvs_filelist *, struct cvs_filelist *);
int	cvs_file_chkign(const char *);
int	cvs_file_cmpname(const char *, const char *);
int	cvs_file_cmp(const char *, const char *);
int	cvs_file_copy(const char *, const char *);

struct cvs_file *cvs_file_get_cf(const char *, const char *, const char *,
	int, int, int);

#endif	/* FILE_H */
@


1.52
log
@switch our file and directory lists to RB trees (see tree(3)),
so we can benefit from faster lookup times while recursing.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.51 2009/02/21 13:44:18 joris Exp $	*/
d83 1
d112 1
a112 1
struct cvs_filelist *cvs_file_get(char *, int, struct cvs_flisthead *);
@


1.51
log
@use file_flags for 2 more reasons:
- mark a file as being inside the Attic/
- mark a file as existing in the working copy
  (both in local and remote mode)

this way we no longer will need to check if cf->fd == -1 and
think about wether or not we are in local or remote mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.50 2009/02/21 12:47:19 joris Exp $	*/
d32 1
d80 1
a82 1
	TAILQ_ENTRY(cvs_filelist) flist;
d85 2
a86 1
TAILQ_HEAD(cvs_flisthead, cvs_filelist);
d111 1
a111 1
struct cvs_filelist *cvs_file_get(const char *, int, struct cvs_flisthead *);
d113 1
@


1.50
log
@alter cvs_file_get() so it takes flags instead of one set
value for user_supplied. allow us to carry any important file flags
over to cvs_file's later on.

makes it easier for what i have coming.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.49 2008/06/13 17:15:13 joris Exp $	*/
d76 1
@


1.49
log
@pass the complete path to cvs_file_get_cf() instead of reconstructing
it again in that function.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.48 2008/03/09 01:54:03 joris Exp $	*/
a49 1
	int	 user_supplied;
d74 2
d79 1
a79 1
	int	user_supplied;
@


1.48
log
@pass user_supplied to struct cvs_file so it can be used
in the callbacks to verify if this file was specified on the command line.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.47 2008/03/09 01:25:31 joris Exp $	*/
d114 2
a115 1
struct cvs_file *cvs_file_get_cf(const char *, const char *, int, int, int);
@


1.47
log
@rename check_dir_tag to user_supplied to reflect what the flag
actually means and is used for.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.46 2007/09/23 10:49:49 joris Exp $	*/
d50 1
d114 1
a114 1
struct cvs_file *cvs_file_get_cf(const char *, const char *, int, int);
@


1.46
log
@pass FILE_HAS_FLAG towards the update code so it can identify
if a given tag is present in the RCSfile or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.45 2007/09/22 16:01:22 joris Exp $	*/
d77 1
a77 1
	int	check_dir_tag;
@


1.45
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.44 2007/06/01 17:47:47 niallo Exp $	*/
d72 2
@


1.44
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.43 2007/02/22 06:42:09 otto Exp $	*/
d75 1
d104 1
a104 1
struct cvs_filelist *cvs_file_get(const char *, struct cvs_flisthead *);
@


1.43
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.42 2007/02/13 16:47:48 xsa Exp $	*/
d49 1
@


1.42
log
@zap unused CVS_ISDIR() and CVS_ISFILE() macros. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.41 2007/02/09 03:49:15 joris Exp $	*/
d30 5
@


1.41
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.40 2007/01/10 21:32:19 xsa Exp $	*/
a77 6

#define CVS_ISDIR(cf)	\
	((cf)->file_type == CVS_DIR)

#define CVS_ISFILE(cf)	\
	((cf)->file_type == CVS_FILE)
@


1.40
log
@add a cvs_file_copy routine and use it for the edit command to
copy the file in the current working directory to CVS/Base/
ok ray@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.39 2007/01/06 17:09:08 xsa Exp $	*/
d97 1
a97 1
void	cvs_file_classify(struct cvs_file *, const char *, int);
@


1.39
log
@add cvs_base_handle() routine to handle the CVS/Baserev* files.
first bits for the edit command for now.
definitly still more work to do for optimization...
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.38 2007/01/05 07:13:49 xsa Exp $	*/
d108 1
@


1.38
log
@- introduce file comparison routine, cvs_file_cmp().
- compare the <file> in working dir and the one in CVS/Base/<file>
  for the unedit command.
hints otto@@, input and ok ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.37 2006/05/30 21:32:52 joris Exp $	*/
d106 1
@


1.37
log
@fill in the correct revision number we will want in file_rcsrev
for each cvs_file struct, this will help us with sticky tags,
commiting to branches and importing into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.36 2006/05/28 17:25:18 joris Exp $	*/
d106 1
@


1.36
log
@several fixes to the file api:
- default to CVS_FILE when something is totally unknown
- cvs_get_repository_path() now returns the full repository path for
  the given argument.
- cvs_get_repository_name() returns the contents of CVS/Repository
  to the caller.
- allow command callbacks to specify if our recursion code needs
  to skip the directory or not.
- when checking for a admin directory, make sure it is in fact
  a directory. if it is not we dont want to recurse inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.35 2006/05/28 07:56:44 joris Exp $	*/
d45 1
d97 1
a97 1
void	cvs_file_classify(struct cvs_file *, int);
@


1.35
log
@allow commands to shut up the output from cvs_file_classify
if the commands want to output certain stuff themselfs
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.34 2006/05/27 03:30:30 joris Exp $	*/
d63 2
@


1.34
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.33 2006/01/02 09:42:20 xsa Exp $	*/
d94 1
a94 1
void	cvs_file_classify(struct cvs_file *);
@


1.33
log
@more includes cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.32 2005/12/04 17:39:02 joris Exp $	*/
d3 1
d33 68
a100 2
struct cvs_file;
struct cvs_entries;
d102 1
a102 9
#define CF_STAT		0x01	/* obsolete */
#define CF_IGNORE	0x02	/* apply regular ignore rules */
#define CF_RECURSE	0x04	/* recurse on directory operations */
#define CF_SORT		0x08	/* all files are sorted alphabetically */
#define CF_KNOWN	0x10	/* only recurse in directories known to CVS */
#define CF_CREATE	0x20	/* create if file does not exist */
#define CF_NOSYMS	0x40	/* ignore symbolic links */
#define CF_NOFILES	0x80	/* don't load any files inside a directory */
#define CF_REPO		0x100	/* we are loading a repository with ,v files */
d104 1
a104 105
/*
 * The cvs_file structure is used to represent any file or directory within
 * the CVS tree's hierarchy.  The <cf_path> field is a path relative to the
 * directory in which the cvs command was executed.  The <cf_parent> field
 * points back to the parent node in the directory tree structure (it is
 * NULL if the directory is at the wd of the command).
 *
 * The <cf_cvstat> field gives the file's status with regards to the CVS
 * repository.  The file can be in any one of the CVS_FST_* states.
 */
#define CVS_FST_UNKNOWN		0	/* Unknown */
#define CVS_FST_UPTODATE	1	/* Up-to-date */
#define CVS_FST_MODIFIED	2	/* Locally Modified */
#define CVS_FST_ADDED		3	/* Locally Added */
#define CVS_FST_REMOVED		4	/* Locally Removed */
#define CVS_FST_CONFLICT	5	/* Unresolved Conflict */
#define CVS_FST_PATCHED		6
#define CVS_FST_LOST		7	/* Needs Checkout */

SIMPLEQ_HEAD(cvs_flist, cvs_file);

typedef struct cvs_file {
	struct cvs_file	*cf_parent;	/* parent directory (NULL if none) */

	/*
	 * cf_name contains the basename of the fullpath
	 * cf_dir contains the parent directory the file or dir is in.
	 * if cf_dir is NULL the file is in the parent directory.
	 */
	char		*cf_name;
	char		*cf_dir;

	/* pointer to the parent directory's entry file */
	void		*cf_entry;

	mode_t		 cf_mode;
	u_int8_t	 cf_cvstat;	/* cvs status of the file */
	u_int8_t	 cf_type;	/* uses values from dirent.h */
	u_int16_t	 cf_flags;

	union {
		struct {
			RCSNUM	*cd_lrev;	/* local revision */
			time_t	 cd_etime;	/* time in Entries file */
			time_t	 cd_mtime;
			char	*cd_tag;
			char	*cd_opts;
		} cf_reg;
		struct {
			char			*cd_repo;
			struct cvsroot		*cd_root;
			struct cvs_flist	cd_files;
		} cf_dir;
	} cf_td;

	SIMPLEQ_ENTRY(cvs_file)	cf_list;
} CVSFILE;

/* only valid for regular files */
#define cf_etime	cf_td.cf_reg.cd_etime
#define cf_mtime	cf_td.cf_reg.cd_mtime
#define cf_lrev		cf_td.cf_reg.cd_lrev
#define cf_tag		cf_td.cf_reg.cd_tag
#define cf_opts		cf_td.cf_reg.cd_opts

/* only valid for directories */
#define cf_files	cf_td.cf_dir.cd_files
#define cf_repo		cf_td.cf_dir.cd_repo
#define cf_root		cf_td.cf_dir.cd_root

#define CVS_DIRF_STATIC		0x01
#define CVS_DIRF_STICKY		0x02
#define CVS_DIRF_BASE		0x04
#define CVS_FILE_ONDISK		0x08

#define CVS_DIR_ROOT(f)  ((((f)->cf_type == DT_DIR) && \
	((f)->cf_root != NULL)) ? (f)->cf_root : \
	(((f)->cf_parent == NULL) ? NULL : (f)->cf_parent->cf_root))

#define CVS_DIR_REPO(f)  (((f)->cf_type == DT_DIR) ? \
	(f)->cf_repo : (((f)->cf_parent == NULL) ? \
	NULL : (f)->cf_parent->cf_repo))

int	 cvs_file_init(void);
int	 cvs_file_ignore(const char *);
int	 cvs_file_chkign(const char *);
int	 cvs_file_get(const char *, int, int (*)(CVSFILE *, void *),
	    void *, struct cvs_flist *);
int	 cvs_file_getspec(char **, int, int, int (*)(CVSFILE *, void *),
	    void *, struct cvs_flist *);
CVSFILE	*cvs_file_loadinfo(char *, int, int (*)(CVSFILE *, void *), void *,
	    int);

CVSFILE	*cvs_file_create(CVSFILE *, const char *, u_int, mode_t);
CVSFILE	*cvs_file_copy(CVSFILE *);
int	 cvs_file_attach(CVSFILE *, CVSFILE *);

int	 cvs_file_init(void);
int	 cvs_file_ignore(const char *);
int	 cvs_file_chkign(const char *);
CVSFILE	*cvs_file_load(const char *, int);
CVSFILE	*cvs_file_find(CVSFILE *, const char *);
char	*cvs_file_getpath(CVSFILE *, char *, size_t);
void	 cvs_file_free(CVSFILE *);
int	 cvs_file_prune(char *);
@


1.32
log
@more code cleanup, remove useless flags and parts of code
that never got used in the first place;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.31 2005/12/03 02:19:17 joris Exp $	*/
a28 5

#include <sys/param.h>

#include <dirent.h>
#include <search.h>
@


1.31
log
@remove unused and useless functions, they just get in the way;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.30 2005/12/03 01:02:09 joris Exp $	*/
a39 4

#define CVS_FILE_MAXDEPTH	32


d46 3
a48 4
#define CF_MKADMIN	0x40	/* create admin files if they're missing */
#define CF_NOSYMS	0x80	/* ignore symbolic links */
#define CF_NOFILES	0x100	/* don't load any files inside a directory */
#define CF_REPO		0x200	/* we are loading a repository with ,v files */
a68 1

a118 1

@


1.30
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.29 2005/11/12 21:34:48 niallo Exp $	*/
a152 1
int	 cvs_file_examine(CVSFILE *, int (*)(CVSFILE *, void *), void *);
@


1.29
log
@- remove strtab stuff. serves no useful purpose.

diff is from joris@@, committing on his behalf because his net connection
is very dodgy right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.28 2005/08/17 16:23:19 joris Exp $	*/
d53 1
@


1.28
log
@keep a pointer to the CVSENTRIES in the CVSFILE structure.
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.27 2005/07/31 21:08:17 joris Exp $	*/
d84 2
a85 2
	const char	*cf_name;
	const char	*cf_dir;
@


1.27
log
@nuke a totally unused flag for cf_flags
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.26 2005/07/25 11:07:00 xsa Exp $	*/
d87 3
a123 1

@


1.26
log
@KNF; mostly spaces vs. tabs; ok joris@@ jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.25 2005/07/23 11:19:46 joris Exp $	*/
d127 1
a127 2
#define CVS_GDIR_IGNORE		0x08
#define CVS_FILE_ONDISK		0x10
@


1.25
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.24 2005/07/22 16:27:29 joris Exp $	*/
d41 1
a41 1
#define CVS_FILE_MAXDEPTH     32
d44 9
a52 9
#define CF_STAT     0x01  /* obsolete */
#define CF_IGNORE   0x02  /* apply regular ignore rules */
#define CF_RECURSE  0x04  /* recurse on directory operations */
#define CF_SORT     0x08  /* all files are sorted alphabetically */
#define CF_KNOWN    0x10  /* only recurse in directories known to CVS */
#define CF_CREATE   0x20  /* create if file does not exist */
#define CF_MKADMIN  0x40  /* create administrative files if they're missing */
#define CF_NOSYMS   0x80  /* ignore symbolic links */
#define CF_NOFILES  0x100 /* don't load any files inside a directory */
d64 8
a71 8
#define CVS_FST_UNKNOWN   0	/* Unknown */
#define CVS_FST_UPTODATE  1	/* Up-to-date */
#define CVS_FST_MODIFIED  2	/* Locally Modified */
#define CVS_FST_ADDED     3	/* Locally Added */
#define CVS_FST_REMOVED   4	/* Locally Removed */
#define CVS_FST_CONFLICT  5	/* Unresolved Conflict */
#define CVS_FST_PATCHED   6
#define CVS_FST_LOST      7	/* Needs Checkout */
d77 1
a77 1
	struct cvs_file  *cf_parent;  /* parent directory (NULL if none) */
d84 2
a85 2
	const char	 *cf_name;
	const char       *cf_dir;
d87 4
a90 4
	mode_t            cf_mode;
	u_int8_t          cf_cvstat;  /* cvs status of the file */
	u_int8_t          cf_type;    /* uses values from dirent.h */
	u_int16_t         cf_flags;
d94 5
a98 5
			RCSNUM  *cd_lrev;	/* local revision */
			time_t   cd_etime;	/* time in Entries file */
			time_t   cd_mtime;
			char    *cd_tag;
			char    *cd_opts;
d101 3
a103 3
			char             *cd_repo;
			struct cvsroot   *cd_root;
			struct cvs_flist  cd_files;
d107 1
a107 1
	SIMPLEQ_ENTRY(cvs_file)  cf_list;
d111 5
a115 5
#define cf_etime  cf_td.cf_reg.cd_etime
#define cf_mtime  cf_td.cf_reg.cd_mtime
#define cf_lrev   cf_td.cf_reg.cd_lrev
#define cf_tag    cf_td.cf_reg.cd_tag
#define cf_opts   cf_td.cf_reg.cd_opts
d118 3
a120 3
#define cf_files  cf_td.cf_dir.cd_files
#define cf_repo   cf_td.cf_dir.cd_repo
#define cf_root   cf_td.cf_dir.cd_root
d124 5
a128 5
#define CVS_DIRF_STATIC    0x01
#define CVS_DIRF_STICKY    0x02
#define CVS_DIRF_BASE      0x04
#define CVS_GDIR_IGNORE    0x08
#define CVS_FILE_ONDISK    0x10
d138 23
a160 23
int      cvs_file_init    (void);
int      cvs_file_ignore  (const char *);
int      cvs_file_chkign  (const char *);
int	 cvs_file_get     (const char *, int, int (*)(CVSFILE *, void *),
			   void *, struct cvs_flist *);
int      cvs_file_getspec (char **, int, int, int (*)(CVSFILE *, void *),
			   void *, struct cvs_flist *);
CVSFILE* cvs_file_loadinfo(char *, int, int (*)(CVSFILE *, void *), void *,
int);

CVSFILE* cvs_file_create  (CVSFILE *, const char *, u_int, mode_t);
CVSFILE* cvs_file_copy    (CVSFILE *);
int      cvs_file_attach  (CVSFILE *, CVSFILE *);
int      cvs_file_examine (CVSFILE *, int (*)(CVSFILE *, void *), void *);

int      cvs_file_init    (void);
int      cvs_file_ignore  (const char *);
int      cvs_file_chkign  (const char *);
CVSFILE* cvs_file_load    (const char *, int);
CVSFILE* cvs_file_find    (CVSFILE *, const char *);
char*    cvs_file_getpath (CVSFILE *, char *, size_t);
void     cvs_file_free    (CVSFILE *);
int      cvs_file_prune   (char *);
d162 1
a162 1
#endif /* FILE_H */
@


1.24
log
@use the cf_name field of the CVSFILE struct instead of using the old
CVS_FILE_NAME macro. This macro used to be nifty because of all
the referencing for the names, but since we don't do that anymore and
use cf_name directly... byebye CVS_FILE_NAME()

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.23 2005/07/07 19:06:12 joris Exp $	*/
d78 9
a86 1
	const char       *cf_name;
a126 1

d128 1
d141 7
a147 2
CVSFILE* cvs_file_get     (const char *, int, int (*)(CVSFILE *, void *), void *);
CVSFILE* cvs_file_getspec (char **, int, int, int (*)(CVSFILE *, void *), void *);
@


1.23
log
@

add a field to CVSFILE which holds the timestamp from the Entries file.
usefull for some commands.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.22 2005/07/06 10:04:55 xsa Exp $	*/
a112 2

#define CVS_FILE_NAME(cf)   (cf->cf_name)
@


1.22
log
@add explicit comments for file status;
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.21 2005/06/14 15:27:31 joris Exp $	*/
d87 1
d103 1
@


1.21
log
@

finish pruning support, this has been sitting
in my tree since c2k5

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.20 2005/05/24 04:12:25 jfb Exp $	*/
d64 6
a69 6
#define CVS_FST_UNKNOWN   0
#define CVS_FST_UPTODATE  1
#define CVS_FST_MODIFIED  2
#define CVS_FST_ADDED     3
#define CVS_FST_REMOVED   4
#define CVS_FST_CONFLICT  5
d71 1
a71 1
#define CVS_FST_LOST      7
@


1.20
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.19 2005/05/20 05:13:44 joris Exp $	*/
d147 1
a147 1

@


1.19
log
@

execute the command callback at the same time we are building
the in-memory filelist. cuts down on execution time for larger trees.

"put it in!" jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.18 2005/05/12 23:35:42 joris Exp $	*/
d78 1
a78 1
	char             *cf_name;
d105 1
d137 7
a144 1
int      cvs_file_attach  (CVSFILE *, CVSFILE *);
a145 1
int      cvs_file_examine (CVSFILE *, int (*)(CVSFILE *, void *), void *);
@


1.18
log
@

introduce a new flag to the file api: CF_NOFILES, which allows us
to only load directories and skip regular files.

tested and ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.17 2005/04/25 21:58:32 joris Exp $	*/
d132 2
a133 2
CVSFILE* cvs_file_get     (const char *, int);
CVSFILE* cvs_file_getspec (char **, int, int);
@


1.17
log
@

first part of file API changes:

- fix our behaviour regarding directories or files in a different
  directory than we currently are as arguments to commands, this
  allows stuff like "cvs status sys/arch/i386/Makefile" to work.

- when parsing a pathname only load the needed nodes of the path
  instead of loading *everything* in memory.

the next step in this is to merge the collection and callback
execution together.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.16 2005/04/18 21:02:50 jfb Exp $	*/
d52 1
a52 1

@


1.16
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.15 2005/03/24 14:35:18 jfb Exp $	*/
d118 2
@


1.15
log
@ditch the filename hash table and use the new strtab code instead

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.14 2005/03/02 16:56:58 joris Exp $	*/
d35 2
a37 1
struct cvs_dir;
a41 1
#define CVS_FILE_NBUCKETS     256
a62 3
 * If the file's type is DT_DIR, then the <cf_ddat> pointer will point to
 * a cvs_dir structure containing data specific to the directory (such as
 * the contents of the directory's CVS/Entries, CVS/Root, etc.).
d74 1
a74 2
TAILQ_HEAD(cvs_flist, cvs_file);

d80 17
a96 4
	time_t            cf_mtime;
	u_int16_t         cf_cvstat;  /* cvs status of the file */
	u_int16_t         cf_type;    /* uses values from dirent.h */
	struct cvs_dir   *cf_ddat;    /* only for directories */
d98 1
a98 1
	TAILQ_ENTRY(cvs_file)  cf_list;
d101 10
a118 10
struct cvs_dir {
	struct cvsroot     *cd_root;
	char               *cd_repo;
	struct cvs_entries *cd_ent;
	struct cvs_flist    cd_files;
	u_int16_t           cd_nfiles;
	u_int16_t           cd_flags;
};


d120 2
a121 6
	((f)->cf_ddat->cd_root != NULL)) ? (f)->cf_ddat->cd_root : \
	(((f)->cf_parent == NULL) ? NULL : (f)->cf_parent->cf_ddat->cd_root))

#define CVS_DIR_ENTRIES(f)  (((f)->cf_type == DT_DIR) ? \
	(f)->cf_ddat->cd_ent : (((f)->cf_parent == NULL) ? \
	NULL : (f)->cf_parent->cf_ddat->cd_ent))
d124 2
a125 2
	(f)->cf_ddat->cd_repo : (((f)->cf_parent == NULL) ? \
	NULL : (f)->cf_parent->cf_ddat->cd_repo))
@


1.14
log
@

add a flag to identify the base directory in file hierarchies.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.13 2004/12/15 07:03:04 jfb Exp $	*/
a76 7
struct cvs_fname {
	char  *cf_name;
	u_int  cf_ref;
	SLIST_ENTRY(cvs_fname) cf_list;
};


d82 1
a82 1
	struct cvs_fname *cf_name;
d92 2
a93 1
#define CVS_FILE_NAME(cf)   (cf->cf_name->cf_name)
@


1.13
log
@modify the CVS_DIR_ROOT() macro to grab the parent's root if the file
is a directory and has no root set
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.12 2004/12/14 21:23:44 jfb Exp $	*/
d104 1
a104 1

@


1.12
log
@When loading directory entries, create file structures for files which
have been lost but have a valid entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.11 2004/12/07 17:10:56 tedu Exp $	*/
d116 3
a118 3
#define CVS_DIR_ROOT(f)  (((f)->cf_type == DT_DIR) ? \
	(f)->cf_ddat->cd_root : (((f)->cf_parent == NULL) ? \
	NULL : (f)->cf_parent->cf_ddat->cd_root))
@


1.11
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.10 2004/12/02 06:54:15 jfb Exp $	*/
d74 1
@


1.10
log
@Add cvs_file_copy() to create a copy of a file structure.
This will be used in the commit code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a43 1

a66 1

d75 1
a75 1
 
@


1.9
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@d135 1
@


1.8
log
@* add a flag CF_NOSYMS to avoid loading information about symbolic links
  and fix 2 calls to cvs_splitpath()
* unbreak cvs_file_find()
@
text
@d33 1
d40 5
d77 7
d89 7
a95 8
	char            *cf_path;
	struct cvs_file *cf_parent;  /* parent directory (NULL if none) */
	char            *cf_name;
	mode_t           cf_mode;
	time_t           cf_mtime;
	u_int16_t        cf_cvstat;  /* cvs status of the file */
	u_int16_t        cf_type;    /* uses values from dirent.h */
	struct cvs_dir  *cf_ddat;    /* only for directories */
d100 1
a107 1
	u_int               cd_flags;
d112 2
a113 1
	u_int               cd_nfiles;
a131 1
CVSFILE* cvs_file_create  (const char *, u_int, mode_t);
d134 1
d137 1
d139 1
a139 1
void     cvs_file_free    (struct cvs_file *);
@


1.7
log
@Add fields to keep track of the file's mode and last modification time
@
text
@d46 1
d89 5
d95 1
@


1.6
log
@the CF_STAT flag is useless now, all we have to do is extract the required
information and keep it in the file structure
@
text
@d78 2
d116 1
@


1.5
log
@Remove cruft and unbreak compilation
@
text
@d39 1
a39 1
#define CF_STAT     0x01  /* allocate space for file stats */
a79 1
	struct stat     *cf_stat;    /* only available with CF_STAT flag */
@


1.4
log
@Allocate a dynamic buffer for sorting.  This way, we don't bork anymore
on directories with huge sets of files, and fix a bug while we're at it.
When sorting failed, the files that had been removed from the list didn't
get pushed back in it.
@
text
@d36 1
d88 5
a92 5
	struct cvsroot  *cd_root;
	char            *cd_repo;
	CVSENTRIES      *cd_ent;
	struct cvs_flist cd_files;
	u_int            cd_nfiles;
@


1.3
log
@Lots of cleanup, and add an internal version of cvs_file_get() so we can
link parent directories before the file info is being retrieved.  This
allows us to open most of the CVS administrative files only once
@
text
@d91 1
@


1.2
log
@Add cvs_file_find() to find a particular file from its path within a
hierarchy
@
text
@d31 1
a31 1
#include <stdio.h>
a33 79
#include "rcs.h"

#define CVS_VERSION    "OpenCVS 0.1"


#define FILE_HIST_CACHE     128
#define FILE_HIST_NBFLD     6


#define CVS_CKSUM_LEN      33     /* length of a CVS checksum string */


/* operations */
#define CVS_OP_ANY          0     /* all operations */
#define CVS_OP_ADD          1
#define CVS_OP_ANNOTATE     2
#define CVS_OP_CHECKOUT     3
#define CVS_OP_COMMIT       4
#define CVS_OP_DIFF         5
#define CVS_OP_HISTORY      6
#define CVS_OP_IMPORT       7
#define CVS_OP_INIT         8
#define CVS_OP_LOG          9
#define CVS_OP_REMOVE      10
#define CVS_OP_SERVER      11
#define CVS_OP_STATUS      12
#define CVS_OP_TAG         13
#define CVS_OP_UPDATE      14
#define CVS_OP_VERSION     15




/* methods */
#define CVS_METHOD_NONE       0
#define CVS_METHOD_LOCAL      1    /* local access */
#define CVS_METHOD_SERVER     2    /* tunnel through CVS_RSH */
#define CVS_METHOD_PSERVER    3    /* cvs pserver */
#define CVS_METHOD_KSERVER    4    /* kerberos */
#define CVS_METHOD_GSERVER    5    /* gssapi server */
#define CVS_METHOD_EXT        6
#define CVS_METHOD_FORK       7    /* local but fork */

#define CVS_CMD_MAXNAMELEN   16
#define CVS_CMD_MAXALIAS      2
#define CVS_CMD_MAXDESCRLEN  64


/* defaults */
#define CVS_RSH_DEFAULT     "ssh"
#define CVS_EDITOR_DEFAULT  "vi"


/* server-side paths */
#define CVS_PATH_ROOT         "CVSROOT"
#define CVS_PATH_COMMITINFO   CVS_PATH_ROOT "/commitinfo"
#define CVS_PATH_CONFIG       CVS_PATH_ROOT "/config"
#define CVS_PATH_CVSIGNORE    CVS_PATH_ROOT "/cvsignore"
#define CVS_PATH_CVSWRAPPERS  CVS_PATH_ROOT "/cvswrappers"
#define CVS_PATH_EDITINFO     CVS_PATH_ROOT "/editinfo"
#define CVS_PATH_HISTORY      CVS_PATH_ROOT "/history"
#define CVS_PATH_LOGINFO      CVS_PATH_ROOT "/loginfo"
#define CVS_PATH_MODULES      CVS_PATH_ROOT "/modules"
#define CVS_PATH_NOTIFY       CVS_PATH_ROOT "/notify"
#define CVS_PATH_RCSINFO      CVS_PATH_ROOT "/rcsinfo"
#define CVS_PATH_TAGINFO      CVS_PATH_ROOT "/taginfo"
#define CVS_PATH_VERIFYMSG    CVS_PATH_ROOT "/verifymsg"


/* client-side paths */
#define CVS_PATH_RC             ".cvsrc"
#define CVS_PATH_CVSDIR         "CVS"
#define CVS_PATH_ENTRIES        CVS_PATH_CVSDIR "/Entries"
#define CVS_PATH_STATICENTRIES  CVS_PATH_CVSDIR "/Entries.Static"
#define CVS_PATH_LOGENTRIES     CVS_PATH_CVSDIR "/Entries.Log"
#define CVS_PATH_ROOTSPEC       CVS_PATH_CVSDIR "/Root"
#define CVS_PATH_REPOSITORY     CVS_PATH_CVSDIR "/Repository"


d38 7
a44 32
struct cvs_op {
	u_int  co_op;
	uid_t  co_uid;    /* user performing the operation */
	char  *co_path;   /* target path of the operation */
	char  *co_tag;    /* tag or branch, NULL if HEAD */
};



struct cvsroot {
	char   *cr_str;
	u_int   cr_method;
	char   *cr_buf;
	char   *cr_user;
	char   *cr_pass;
	char   *cr_host;
	char   *cr_dir;
	u_int   cr_port;
	u_int   cr_ref;

	/* connection data */
	FILE   *cr_srvin;
	FILE   *cr_srvout;
};


#define CF_STAT     0x01    /* allocate space for file stats */
#define CF_IGNORE   0x02    /* apply regular ignore rules */
#define CF_RECURSE  0x04    /* recurse on directory operations */
#define CF_SORT     0x08    /* all files are sorted alphabetically */
#define CF_KNOWN    0x10    /* only recurse in directories known to CVS */
#define CF_CREATE   0x20    /* create if file does not exist */
d89 1
d94 1
a94 1
#define CVS_DIR_ROOT(f)  (((f)->cf_type == DTDIR) ? \
d98 7
@


1.1
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d196 6
d208 2
a210 1
int      cvs_file_examine (CVSFILE *, int (*)(CVSFILE *, void *), void *);
@

