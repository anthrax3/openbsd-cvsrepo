head	1.107;
access;
symbols
	OPENBSD_6_1_BASE:1.107
	OPENBSD_6_0:1.106.0.4
	OPENBSD_6_0_BASE:1.106
	OPENBSD_5_9:1.106.0.2
	OPENBSD_5_9_BASE:1.106
	OPENBSD_5_8:1.104.0.4
	OPENBSD_5_8_BASE:1.104
	OPENBSD_5_7:1.103.0.2
	OPENBSD_5_7_BASE:1.103
	OPENBSD_5_6:1.102.0.24
	OPENBSD_5_6_BASE:1.102
	OPENBSD_5_5:1.102.0.22
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.102.0.18
	OPENBSD_5_4_BASE:1.102
	OPENBSD_5_3:1.102.0.16
	OPENBSD_5_3_BASE:1.102
	OPENBSD_5_2:1.102.0.14
	OPENBSD_5_2_BASE:1.102
	OPENBSD_5_1_BASE:1.102
	OPENBSD_5_1:1.102.0.12
	OPENBSD_5_0:1.102.0.10
	OPENBSD_5_0_BASE:1.102
	OPENBSD_4_9:1.102.0.8
	OPENBSD_4_9_BASE:1.102
	OPENBSD_4_8:1.102.0.6
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.102.0.2
	OPENBSD_4_7_BASE:1.102
	OPENBSD_4_6:1.102.0.4
	OPENBSD_4_6_BASE:1.102
	OPENBSD_4_5:1.101.0.2
	OPENBSD_4_5_BASE:1.101
	OPENBSD_4_4:1.100.0.2
	OPENBSD_4_4_BASE:1.100
	OPENBSD_4_3:1.95.0.2
	OPENBSD_4_3_BASE:1.95
	OPENBSD_4_2:1.79.0.2
	OPENBSD_4_2_BASE:1.79
	OPENBSD_4_1:1.75.0.2
	OPENBSD_4_1_BASE:1.75
	OPENBSD_4_0:1.61.0.2
	OPENBSD_4_0_BASE:1.61
	OPENBSD_3_9:1.54.0.2
	OPENBSD_3_9_BASE:1.54
	OPENBSD_3_8:1.47.0.2
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.107
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.106;
commitid	8Vv7d4HkmCtExfc6;

1.106
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.105;
commitid	O6jeJ0TRmiewrqMI;

1.105
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.104;
commitid	0Dp7Dy9FuNZesYo2;

1.104
date	2015.04.04.14.19.10;	author stsp;	state Exp;
branches;
next	1.103;
commitid	ED4wEXoF2lnt3mdI;

1.103
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	Uu5nFG3wCl0LACBb;

1.102
date	2009.03.19.09.53.16;	author joris;	state Exp;
branches;
next	1.101;

1.101
date	2009.02.23.21.32.08;	author joris;	state Exp;
branches;
next	1.100;

1.100
date	2008.06.14.20.04.14;	author joris;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.14.03.58.29;	author tobias;	state Exp;
branches;
next	1.98;

1.98
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.97;

1.97
date	2008.06.11.02.19.13;	author tobias;	state Exp;
branches;
next	1.96;

1.96
date	2008.06.09.22.31.24;	author tobias;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.01.21.29.36;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.10.14.08.52;	author xsa;	state Exp;
branches;
next	1.93;

1.93
date	2008.02.10.11.52.35;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2008.02.10.10.21.42;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2008.02.10.10.10.15;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2008.02.09.20.04.00;	author xsa;	state Exp;
branches;
next	1.89;

1.89
date	2008.02.09.17.01.43;	author tobias;	state Exp;
branches;
next	1.88;

1.88
date	2008.02.04.18.23.58;	author tobias;	state Exp;
branches;
next	1.87;

1.87
date	2008.02.04.15.08.44;	author tobias;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.10.10.09.27;	author tobias;	state Exp;
branches;
next	1.85;

1.85
date	2007.11.11.10.06.52;	author tobias;	state Exp;
branches;
next	1.84;

1.84
date	2007.10.05.19.28.23;	author gilles;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.25.11.10.28;	author chl;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.22.15.57.24;	author joris;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.04.19.07.04;	author tobias;	state Exp;
branches;
next	1.79;

1.79
date	2007.07.03.13.22.42;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.02.09.00.19;	author niallo;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.26.02.30.28;	author ray;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.16.20.51.22;	author xsa;	state Exp;
branches;
next	1.75;

1.75
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.74;

1.74
date	2007.02.19.11.40.00;	author otto;	state Exp;
branches;
next	1.73;

1.73
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.04.06.09.31;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.27.18.53.16;	author otto;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.24.13.55.11;	author pyr;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.24.08.34.12;	author pyr;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.24.08.28.46;	author pyr;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.12.18.24.59;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.07.13.28.21;	author xsa;	state Exp;
branches;
next	1.63;

1.63
date	2006.12.07.10.44.16;	author xsa;	state Exp;
branches;
next	1.62;

1.62
date	2006.10.24.06.25.10;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.09.01.47.20;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.14.15.35.17;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.14.15.14.47;	author xsa;	state Exp;
branches;
next	1.58;

1.58
date	2006.06.06.05.13.39;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.03.15.02.55;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2005.12.03.01.02.08;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2005.10.22.17.23.21;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.06.17.08.05;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2005.09.06.15.29.33;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.22.08.53.12;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.19.08.48.30;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2005.08.16.16.34.19;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2005.08.12.18.46.53;	author xsa;	state Exp;
branches;
next	1.43;

1.43
date	2005.08.10.14.49.20;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.24.16.46.39;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.21.11.42.24;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.14.07.38.35;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.17.15.09.55;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.07.08.19.07;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.07.07.23.41;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.02.20.19.30;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.27.17.39.40;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.26.22.25.31;	author jfb;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.26.21.25.49;	author jfb;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.19.21.45.45;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.19.04.17.24;	author jfb;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.22.15.16.15;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.15.14.34.15;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.22.16.09.28;	author jfb;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.01.18.51.04;	author jfb;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.14.16.57.58;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.14.16.39.21;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.14.21.23.44;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.09.20.49.17;	author krapht;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.31.12.25.51;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.27.15.44.38;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.13.13.24.13;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.13.12.58.44;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.13.12.47.54;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.12.18.33.47;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.06.20.10.02;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.04.15.39.10;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.03.14.48.02;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.30.17.37.13;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.27.13.12.10;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.26.16.53.58;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.25.03.18.53;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.14.19.03.00;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.14.05.16.04;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.04.32.42;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.107
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@/*	$OpenBSD: entries.c,v 1.106 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

#define CVS_ENTRIES_NFIELDS	6
#define CVS_ENTRIES_DELIM	'/'

static struct cvs_ent_line *ent_get_line(CVSENTRIES *, const char *);

CVSENTRIES *current_list = NULL;

CVSENTRIES *
cvs_ent_open(const char *dir)
{
	FILE *fp;
	CVSENTRIES *ep;
	char *p, buf[PATH_MAX];
	struct cvs_ent *ent;
	struct cvs_ent_line *line;

	cvs_log(LP_TRACE, "cvs_ent_open(%s)", dir);

	(void)xsnprintf(buf, sizeof(buf), "%s/%s", dir, CVS_PATH_ENTRIES);

	if (current_list != NULL && !strcmp(current_list->cef_path, buf))
		return (current_list);

	if (current_list != NULL) {
		cvs_ent_close(current_list, ENT_SYNC);
		current_list = NULL;
	}

	ep = xcalloc(1, sizeof(*ep));
	ep->cef_path = xstrdup(buf);

	(void)xsnprintf(buf, sizeof(buf), "%s/%s",
	    dir, CVS_PATH_BACKUPENTRIES);

	ep->cef_bpath = xstrdup(buf);

	(void)xsnprintf(buf, sizeof(buf), "%s/%s", dir, CVS_PATH_LOGENTRIES);

	ep->cef_lpath = xstrdup(buf);

	TAILQ_INIT(&(ep->cef_ent));

	if ((fp = fopen(ep->cef_path, "r")) != NULL) {
		while (fgets(buf, sizeof(buf), fp)) {
			buf[strcspn(buf, "\n")] = '\0';

			if (buf[0] == 'D' && buf[1] == '\0')
				break;

			line = xmalloc(sizeof(*line));
			line->buf = xstrdup(buf);
			TAILQ_INSERT_TAIL(&(ep->cef_ent), line, entries_list);
		}

		(void)fclose(fp);
	}

	if ((fp = fopen(ep->cef_lpath, "r")) != NULL) {
		while (fgets(buf, sizeof(buf), fp)) {
			buf[strcspn(buf, "\n")] = '\0';

			if (strlen(buf) < 2)
				fatal("cvs_ent_open: %s: malformed line %s",
				    ep->cef_lpath, buf);

			p = &buf[2];

			if (buf[0] == 'A') {
				line = xmalloc(sizeof(*line));
				line->buf = xstrdup(p);
				TAILQ_INSERT_TAIL(&(ep->cef_ent), line,
				    entries_list);
			} else if (buf[0] == 'R') {
				ent = cvs_ent_parse(p);
				line = ent_get_line(ep, ent->ce_name);
				if (line != NULL) {
					TAILQ_REMOVE(&(ep->cef_ent), line,
					    entries_list);
					free(line->buf);
					free(line);
				}
				cvs_ent_free(ent);
			}
		}

		(void)fclose(fp);
	}

	current_list = ep;
	return (ep);
}

struct cvs_ent *
cvs_ent_parse(const char *entry)
{
	int i;
	struct tm t, dt;
	struct cvs_ent *ent;
	char *fields[CVS_ENTRIES_NFIELDS], *buf, *sp, *dp, *p;

	buf = sp = xstrdup(entry);
	i = 0;
	do {
		dp = strchr(sp, CVS_ENTRIES_DELIM);
		if (dp != NULL)
			*(dp++) = '\0';
		fields[i++] = sp;
		sp = dp;
	} while (dp != NULL && i < CVS_ENTRIES_NFIELDS);

	if (i < CVS_ENTRIES_NFIELDS)
		fatal("missing fields in entry line '%s'", entry);

	ent = xmalloc(sizeof(*ent));
	ent->ce_buf = buf;

	if (*fields[0] == '\0')
		ent->ce_type = CVS_ENT_FILE;
	else if (*fields[0] == 'D')
		ent->ce_type = CVS_ENT_DIR;
	else
		ent->ce_type = CVS_ENT_NONE;

	ent->ce_status = CVS_ENT_REG;
	ent->ce_name = fields[1];
	ent->ce_rev = NULL;
	ent->ce_date = -1;
	ent->ce_tag = NULL;
	ent->ce_time = NULL;

	if (ent->ce_type == CVS_ENT_FILE) {
		if (*fields[2] == '-') {
			ent->ce_status = CVS_ENT_REMOVED;
			sp = fields[2] + 1;
		} else if (*fields[2] == CVS_SERVER_QUESTIONABLE) {
			sp = NULL;
			ent->ce_status = CVS_ENT_UNKNOWN;
		} else {
			sp = fields[2];
			if (fields[2][0] == '0' && fields[2][1] == '\0')
				ent->ce_status = CVS_ENT_ADDED;
		}

		if (sp != NULL) {
			if ((ent->ce_rev = rcsnum_parse(sp)) == NULL) {
				fatal("failed to parse entry revision '%s'",
				    entry);
			}
		}

		if (fields[3][0] == '\0' ||
		    strncmp(fields[3], CVS_DATE_DUMMY,
		    sizeof(CVS_DATE_DUMMY) - 1) == 0 ||
		    strncmp(fields[3], "Initial ", 8) == 0 ||
		    strcmp(fields[3], "Result of merge") == 0) {
			ent->ce_mtime = CVS_DATE_DMSEC;
		} else if (cvs_server_active == 1 &&
		    strncmp(fields[3], CVS_SERVER_UNCHANGED,
		    strlen(CVS_SERVER_UNCHANGED)) == 0) {
			ent->ce_mtime = CVS_SERVER_UPTODATE;
		} else {
			p = fields[3];
			if (strncmp(fields[3], "Result of merge+", 16) == 0)
				p += 16;

			ent->ce_time = xstrdup(p);

			/* Date field can be a '+=' with remote to indicate
			 * conflict.  In this case do nothing. */
			if (strptime(p, "%a %b %d %T %Y", &t) != NULL) {
				t.tm_isdst = -1;	/* Figure out DST. */
				t.tm_gmtoff = 0;
				ent->ce_mtime = mktime(&t);
				ent->ce_mtime += t.tm_gmtoff;
			}
		}
	}

	ent->ce_conflict = fields[3];
	if ((dp = strchr(ent->ce_conflict, '+')) != NULL)
		*dp = '\0';
	else
		ent->ce_conflict = NULL;

	if (strcmp(fields[4], ""))
		ent->ce_opts = fields[4];
	else
		ent->ce_opts = NULL;

	if (strcmp(fields[5], "")) {
		switch (*fields[5]) {
		case 'D':
			if (sscanf(fields[5] + 1, "%d.%d.%d.%d.%d.%d",
			    &dt.tm_year, &dt.tm_mon, &dt.tm_mday,
			    &dt.tm_hour, &dt.tm_min, &dt.tm_sec) != 6)
				fatal("wrong date specification");
			dt.tm_year -= 1900;
			dt.tm_mon -= 1;
			ent->ce_date = timegm(&dt);
			ent->ce_tag = NULL;
			break;
		case 'T':
			ent->ce_tag = fields[5] + 1;
			break;
		default:
			fatal("invalid sticky entry");
		}
	}

	return (ent);
}

struct cvs_ent *
cvs_ent_get(CVSENTRIES *ep, const char *name)
{
	struct cvs_ent *ent;
	struct cvs_ent_line *l;

	l = ent_get_line(ep, name);
	if (l == NULL)
		return (NULL);

	ent = cvs_ent_parse(l->buf);
	return (ent);
}

void
cvs_ent_close(CVSENTRIES *ep, int writefile)
{
	FILE *fp;
	struct cvs_ent_line *l;
	int dflag;

	dflag = 1;
	cvs_log(LP_TRACE, "cvs_ent_close(%s, %d)", ep->cef_bpath, writefile);

	if (cvs_cmdop == CVS_OP_EXPORT)
		writefile = 0;

	fp = NULL;
	if (writefile)
		fp = fopen(ep->cef_bpath, "w");

	while ((l = TAILQ_FIRST(&(ep->cef_ent))) != NULL) {
		if (fp != NULL) {
			if (l->buf[0] == 'D')
				dflag = 0;

			fputs(l->buf, fp);
			fputc('\n', fp);
		}

		TAILQ_REMOVE(&(ep->cef_ent), l, entries_list);
		free(l->buf);
		free(l);
	}

	if (fp != NULL) {
		if (dflag) {
			fputc('D', fp);
			fputc('\n', fp);
		}
		(void)fclose(fp);

		if (rename(ep->cef_bpath, ep->cef_path) == -1)
			fatal("cvs_ent_close: rename: `%s'->`%s': %s",
			    ep->cef_bpath, ep->cef_path, strerror(errno));

		(void)unlink(ep->cef_lpath);
	}

	free(ep->cef_path);
	free(ep->cef_bpath);
	free(ep->cef_lpath);
	free(ep);
}

void
cvs_ent_add(CVSENTRIES *ep, const char *line)
{
	FILE *fp;
	struct cvs_ent_line *l;
	struct cvs_ent *ent;

	if ((ent = cvs_ent_parse(line)) == NULL)
		fatal("cvs_ent_add: parsing failed '%s'", line);

	l = ent_get_line(ep, ent->ce_name);
	if (l != NULL)
		cvs_ent_remove(ep, ent->ce_name);

	cvs_ent_free(ent);

	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_ent_add(%s, %s)", ep->cef_path, line);

	if ((fp = fopen(ep->cef_lpath, "a")) == NULL)
		fatal("cvs_ent_add: fopen: `%s': %s",
		    ep->cef_lpath, strerror(errno));

	fputs("A ", fp);
	fputs(line, fp);
	fputc('\n', fp);

	(void)fclose(fp);

	l = xmalloc(sizeof(*l));
	l->buf = xstrdup(line);
	TAILQ_INSERT_TAIL(&(ep->cef_ent), l, entries_list);
}

void
cvs_ent_remove(CVSENTRIES *ep, const char *name)
{
	FILE *fp;
	struct cvs_ent_line *l;

	if (cvs_server_active == 0)
		cvs_log(LP_TRACE, "cvs_ent_remove(%s, %s)", ep->cef_path, name);

	l = ent_get_line(ep, name);
	if (l == NULL)
		return;

	if ((fp = fopen(ep->cef_lpath, "a")) == NULL)
		fatal("cvs_ent_remove: fopen: `%s': %s", ep->cef_lpath,
		    strerror(errno));

	fputs("R ", fp);
	fputs(l->buf, fp);
	fputc('\n', fp);

	(void)fclose(fp);

	TAILQ_REMOVE(&(ep->cef_ent), l, entries_list);
	free(l->buf);
	free(l);
}

/*
 * cvs_ent_line_str()
 *
 * Build CVS/Entries line.
 *
 */
void
cvs_ent_line_str(const char *name, char *rev, char *tstamp, char *opts,
    char *sticky, int isdir, int isremoved, char *buf, size_t len)
{
	if (isdir == 1) {
		(void)xsnprintf(buf, len, "D/%s////", name);
		return;
	}

	(void)xsnprintf(buf, len, "/%s/%s%s/%s/%s/%s",
	    name, isremoved == 1 ? "-" : "", rev, tstamp, opts, sticky);
}

void
cvs_ent_free(struct cvs_ent *ent)
{
	free(ent->ce_rev);
	free(ent->ce_time);
	free(ent->ce_buf);
	free(ent);
}

static struct cvs_ent_line *
ent_get_line(CVSENTRIES *ep, const char *name)
{
	char *p, *s;
	struct cvs_ent_line *l;

	TAILQ_FOREACH(l, &(ep->cef_ent), entries_list) {
		if (l->buf[0] == 'D')
			p = &(l->buf[2]);
		else
			p = &(l->buf[1]);

		if ((s = strchr(p, '/')) == NULL)
			fatal("ent_get_line: bad entry line '%s'", l->buf);

		*s = '\0';

		if (!strcmp(p, name)) {
			*s = '/';
			return (l);
		}

		*s = '/';
	}

	return (NULL);
}

void
cvs_parse_tagfile(char *dir, char **tagp, char **datep, int *nbp)
{
	FILE *fp;
	int i, linenum;
	size_t len;
	struct tm datetm;
	char linebuf[128], tagpath[PATH_MAX];

	cvs_directory_date = -1;

	if (tagp != NULL)
		*tagp = NULL;

	if (datep != NULL)
		*datep = NULL;

	if (nbp != NULL)
		*nbp = 0;

	i = snprintf(tagpath, PATH_MAX, "%s/%s", dir, CVS_PATH_TAG);
	if (i < 0 || i >= PATH_MAX)
		return;

	if ((fp = fopen(tagpath, "r")) == NULL) {
		if (errno != ENOENT)
			cvs_log(LP_NOTICE, "failed to open `%s' : %s", tagpath,
			    strerror(errno));
		return;
        }

	linenum = 0;

	while (fgets(linebuf, (int)sizeof(linebuf), fp) != NULL) {
		linenum++;
		if ((len = strlen(linebuf)) == 0)
			continue;
		if (linebuf[len - 1] != '\n') {
			cvs_log(LP_NOTICE, "line too long in `%s:%d'",
			    tagpath, linenum);
			break;
		}
		linebuf[--len] = '\0';

		switch (*linebuf) {
		case 'T':
			if (tagp != NULL)
				*tagp = xstrdup(linebuf + 1);
			break;
		case 'D':
			if (sscanf(linebuf + 1, "%d.%d.%d.%d.%d.%d",
			    &datetm.tm_year, &datetm.tm_mon, &datetm.tm_mday,
			    &datetm.tm_hour, &datetm.tm_min, &datetm.tm_sec) !=
			    6)
				fatal("wrong date specification");
			datetm.tm_year -= 1900;
			datetm.tm_mon -= 1;

			cvs_directory_date = timegm(&datetm);

			if (datep != NULL)
				*datep = xstrdup(linebuf + 1);
			break;
		case 'N':
			if (tagp != NULL)
				*tagp = xstrdup(linebuf + 1);
			if (nbp != NULL)
				*nbp = 1;
			break;
		default:
			break;
		}
	}
	if (ferror(fp))
		cvs_log(LP_NOTICE, "failed to read line from `%s'", tagpath);

	(void)fclose(fp);
}

void
cvs_write_tagfile(const char *dir, char *tag, char *date)
{
	FILE *fp;
	RCSNUM *rev;
	char tagpath[PATH_MAX];
	char sticky[CVS_REV_BUFSZ];
	struct tm datetm;
	int i;

	cvs_log(LP_TRACE, "cvs_write_tagfile(%s, %s, %s)", dir,
	    tag != NULL ? tag : "", date != NULL ? date : "");

	if (cvs_noexec == 1)
		return;

	i = snprintf(tagpath, PATH_MAX, "%s/%s", dir, CVS_PATH_TAG);
	if (i < 0 || i >= PATH_MAX)
		return;

	if (tag != NULL || cvs_specified_date != -1 ||
	    cvs_directory_date != -1) {
		if ((fp = fopen(tagpath, "w+")) == NULL) {
			if (errno != ENOENT) {
				cvs_log(LP_NOTICE, "failed to open `%s' : %s",
				    tagpath, strerror(errno));
			}
			return;
		}

		if (tag != NULL) {
			if ((rev = rcsnum_parse(tag)) != NULL) {
				(void)xsnprintf(sticky, sizeof(sticky),
				    "N%s", tag);
				free(rev);
			} else {
				(void)xsnprintf(sticky, sizeof(sticky),
				    "T%s", tag);
			}
		} else {
			if (cvs_specified_date != -1)
				gmtime_r(&cvs_specified_date, &datetm);
			else
				gmtime_r(&cvs_directory_date, &datetm);
			(void)strftime(sticky, sizeof(sticky),
			    "D"CVS_DATE_FMT, &datetm);
		}

		(void)fprintf(fp, "%s\n", sticky);
		(void)fclose(fp);
	}
}
@


1.106
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.105 2015/08/20 22:32:41 deraadt Exp $	*/
d388 1
a388 2
	if (ent->ce_rev != NULL)
		rcsnum_free(ent->ce_rev);
d535 1
a535 1
				rcsnum_free(rev);
@


1.105
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.104 2015/04/04 14:19:10 stsp Exp $	*/
d19 1
d105 2
a106 2
					xfree(line->buf);
					xfree(line);
d280 2
a281 2
		xfree(l->buf);
		xfree(l);
d298 4
a301 4
	xfree(ep->cef_path);
	xfree(ep->cef_bpath);
	xfree(ep->cef_lpath);
	xfree(ep);
d362 2
a363 2
	xfree(l->buf);
	xfree(l);
d390 3
a392 5
	if (ent->ce_time != NULL)
		xfree(ent->ce_time);

	xfree(ent->ce_buf);
	xfree(ent);
@


1.104
log
@Fix modified timestamp in output of opencvs status.
Patch by joris via tech@@; reminded by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.103 2015/01/16 06:40:07 deraadt Exp $	*/
d54 1
a54 1
	ep = (CVSENTRIES *)xcalloc(1, sizeof(*ep));
d75 1
a75 1
			line = (struct cvs_ent_line *)xmalloc(sizeof(*line));
d332 1
a332 1
	l = (struct cvs_ent_line *)xmalloc(sizeof(*l));
@


1.103
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.102 2009/03/19 09:53:16 joris Exp $	*/
d154 1
d191 2
d389 3
@


1.102
log
@properly register Questionable files using CVS/Entries server-side
in order for them to show up as "? foobar" when opencvs is in server mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.101 2009/02/23 21:32:08 joris Exp $	*/
d38 1
a38 1
	char *p, buf[MAXPATHLEN];
d425 1
a425 1
	char linebuf[128], tagpath[MAXPATHLEN];
d438 2
a439 2
	i = snprintf(tagpath, MAXPATHLEN, "%s/%s", dir, CVS_PATH_TAG);
	if (i < 0 || i >= MAXPATHLEN)
d502 1
a502 1
	char tagpath[MAXPATHLEN];
d513 2
a514 2
	i = snprintf(tagpath, MAXPATHLEN, "%s/%s", dir, CVS_PATH_TAG);
	if (i < 0 || i >= MAXPATHLEN)
@


1.101
log
@we no longer push out Set-sticky to the client when writing
our Tag file on the server or in cvs_mkpath(), this caused
problems for the "fast checkout" mechanism when a tag was supplied.

instead, write out any directory sticky tag when we are checking
out a file in that directory, this way we can use our "fast checkout"
mechanism (no /tmp required) even for -r and -d without breaking
working copies because they were missing CVS/Tag files.

"looks good" tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.100 2008/06/14 20:04:14 joris Exp $	*/
d159 3
d168 6
a173 2
		if ((ent->ce_rev = rcsnum_parse(sp)) == NULL)
			fatal("failed to parse entry revision '%s'", entry);
d176 2
a177 1
		    strncmp(fields[3], CVS_DATE_DUMMY, sizeof(CVS_DATE_DUMMY) - 1) == 0 ||
a192 1

@


1.100
log
@unfuck CVS/Tag creation, karma sucks doesn't it.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.99 2008/06/14 03:58:29 tobias Exp $	*/
a536 3

		if (cvs_server_active == 1)
			cvs_server_set_sticky(dir, sticky);
@


1.99
log
@Added support for sticky date set in CVS/Tag and CVS/Entries per directory.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.98 2008/06/14 03:19:15 joris Exp $	*/
d511 1
a511 1
	    cvs_directory_date == -1) {
@


1.98
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.97 2008/06/11 02:19:13 tobias Exp $	*/
d420 2
d469 1
a469 2
			if (cvs_specified_date == -1)
				cvs_specified_date = timegm(&datetm);
d510 2
a511 1
	if (tag != NULL || cvs_specified_date != -1) {
d530 4
a533 1
			gmtime_r(&cvs_specified_date, &datetm);
@


1.97
log
@Avoid possible NULL pointer dereferences by using reentrant versions
of time functions.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.96 2008/06/09 22:31:24 tobias Exp $	*/
d31 2
d42 1
a42 1
	ep = (CVSENTRIES *)xcalloc(1, sizeof(*ep));
d46 9
d114 1
d250 1
d252 6
a257 5
	if (writefile) {
		if ((fp = fopen(ep->cef_bpath, "w")) == NULL)
			fatal("cvs_ent_close: fopen: `%s': %s",
			    ep->cef_path, strerror(errno));
	}
d260 1
a260 1
		if (writefile) {
d273 1
a273 1
	if (writefile) {
@


1.96
log
@Properly handle merged files and conflicts which may arrise while merge.
Instead of ignoring all files which contain possible conflict markers,
only watch out for files which have actually been merged.

With input by and ok joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.95 2008/03/01 21:29:36 deraadt Exp $	*/
d482 1
a482 1
	struct tm *datetm;
d514 1
a514 1
			datetm = gmtime(&cvs_specified_date);
d516 1
a516 1
			    "D"CVS_DATE_FMT, datetm);
@


1.95
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.94 2008/02/10 14:08:52 xsa Exp $	*/
d112 1
a112 1
	char *fields[CVS_ENTRIES_NFIELDS], *buf, *sp, *dp;
d159 1
a159 1
		    strncmp(fields[3], "Result of merge", 15) == 0) {
d166 4
d172 1
a172 1
			if (strptime(fields[3], "%a %b %d %T %Y", &t) != NULL) {
@


1.94
log
@+ #define CVS_DATE_FMT   "%Y.%m.%d.%H.%M.%S"
...and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.93 2008/02/10 11:52:35 joris Exp $	*/
d190 1
a190 1
		switch(*fields[5]) {
@


1.93
log
@- cvs_write_tagfile() is not responsible to remove CVS/Tag itself
- construct right CVS/Repository paths in cvs_mkpath()

fixes remote Issues;
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.92 2008/02/10 10:21:42 joris Exp $	*/
d511 2
a512 2
			strftime(sticky, sizeof(sticky), "D%Y.%m.%d.%H.%M.%S",
			    datetm);
@


1.92
log
@properly initialize cvs_specified_date so we dont end up with
random stuff going on
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.91 2008/02/10 10:10:15 joris Exp $	*/
a519 2
	} else {
		(void)cvs_unlink(tagpath);
@


1.91
log
@parse any date tags set in CVS/Tag or CVS/Entries properly, and use
them for commands;

with tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.90 2008/02/09 20:04:00 xsa Exp $	*/
d140 2
d207 1
a207 2
	} else
		ent->ce_tag = NULL;
d449 1
a449 1
			if (cvs_specified_date == 0)
d491 1
a491 1
	if (tag != NULL || cvs_specified_date != 0) {
@


1.90
log
@Introduce cvs_ent_line_str() - formats CVS/Entries lines.
OK tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.89 2008/02/09 17:01:43 tobias Exp $	*/
d110 1
a110 1
	struct tm t;
d187 19
a205 3
	if (strcmp(fields[5], ""))
		ent->ce_tag = fields[5] + 1;
	else
d398 1
d440 11
@


1.89
log
@Support for checkout -D extended:
Properly write CVS/Tag and CVS/Entries on various combinations of -r and -D.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.88 2008/02/04 18:23:58 tobias Exp $	*/
d318 19
@


1.88
log
@Stripped off 'nb', which was (or was supposed to be) used to distinguish
between a named branch and a revision number supplied by -r.  This can
be done easier in cvs_write_tagfile directly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.87 2008/02/04 15:08:44 tobias Exp $	*/
d430 1
d443 1
a443 1
	if ((tag != NULL) || (date != NULL)) {
d462 3
a464 1
			(void)xsnprintf(sticky, sizeof(sticky), "D%s", date);
@


1.87
log
@Make CVS/Entries.Log look the same as GNU cvs'.  This way interoperability
is possible.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.86 2008/01/10 10:09:27 tobias Exp $	*/
d424 1
a424 1
cvs_write_tagfile(const char *dir, char *tag, char *date, int nb)
d427 1
d432 3
d452 1
a452 1
			if (nb != 0) {
d455 1
@


1.86
log
@xmalloc + memset -> xcalloc
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.85 2007/11/11 10:06:52 tobias Exp $	*/
d76 5
a80 1
			p = &buf[1];
d281 1
a281 1
	fputc('A', fp);
d309 1
a309 1
	fputc('R', fp);
@


1.85
log
@CVS/Entries needs at least one line specifying a 'D'irectory.  If the
current directory has subdirectories, there is no need to apply another
'D' line.  Sticks at GNU cvs behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.84 2007/10/05 19:28:23 gilles Exp $	*/
d40 1
a40 2
	ep = (CVSENTRIES *)xmalloc(sizeof(*ep));
	memset(ep, 0, sizeof(*ep));
@


1.84
log
@strcspn() change

was okay'd by pyr@@ and ok by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.83 2007/09/25 11:10:28 chl Exp $	*/
d211 3
d223 3
d236 4
a239 2
		fputc('D', fp);
		fputc('\n', fp);
@


1.83
log
@missing header for strptime

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.82 2007/09/22 16:01:22 joris Exp $	*/
a34 1
	size_t len;
d60 1
a60 3
			len = strlen(buf);
			if (len > 0 && buf[len - 1] == '\n')
				buf[len - 1] = '\0';
d75 1
a75 3
			len = strlen(buf);
			if (len > 0 && buf[len - 1] == '\n')
				buf[len - 1] = '\0';
@


1.82
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.81 2007/09/22 15:57:24 joris Exp $	*/
d20 1
@


1.81
log
@we no longer create a 0 sized file in our /tmp/cvs-serv<pid> server
directory when a client sends us info about a file that is up to date.

instead, remember the file is up to date in our CVS/Entries. Saves us a lot
of headaches on very big trees like src/
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.80 2007/09/04 19:07:04 tobias Exp $	*/
d421 1
d441 13
a453 6
			if (nb != 0)
				(void)fprintf(fp, "N%s\n", tag);
			else
				(void)fprintf(fp, "T%s\n", tag);
		} else
			(void)fprintf(fp, "D%s\n", date);
d455 1
@


1.80
log
@Removed dead code.

OK joris@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.79 2007/07/03 13:22:42 joris Exp $	*/
d23 1
d158 1
a158 1
		    strncmp(fields[3], "Result of merge", 15) == 0)
d160 5
a164 1
		else {
@


1.79
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.78 2007/06/02 09:00:19 niallo Exp $	*/
a202 12
}

int
cvs_ent_exists(CVSENTRIES *ep, const char *name)
{
	struct cvs_ent_line *l;

	l = ent_get_line(ep, name);
	if (l == NULL)
		return (0);

	return (1);
@


1.78
log
@don't try to parse a server conflict message as a date.
makes cvs remote merging with conflicts work a bit better.

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.77 2007/05/26 02:30:28 ray Exp $	*/
d445 1
@


1.77
log
@Treat lines that start with "dummy timestamp from new-entry" as a
dummy timestamp, not just lines that match it exactly.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.76 2007/05/16 20:51:22 xsa Exp $	*/
d160 9
a168 7
			if (strptime(fields[3], "%a %b %d %T %Y", &t) == NULL)
				fatal("'%s' is not a valid date", fields[3]);

			t.tm_isdst = -1;	/* Figure out DST. */
			t.tm_gmtoff = 0;
			ent->ce_mtime = mktime(&t);
			ent->ce_mtime += t.tm_gmtoff;
@


1.76
log
@Figure out DST by setting tm_isdst element to -1.
From Tobias Stoeckmann. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.75 2007/02/22 06:42:09 otto Exp $	*/
d155 1
a155 1
		    strcmp(fields[3], CVS_DATE_DUMMY) == 0 ||
@


1.75
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.74 2007/02/19 11:40:00 otto Exp $	*/
d162 2
a163 1
			t.tm_isdst = 0;
@


1.74
log
@Fix const inconsistencies, void pointer artithmetic and a few other
things. now gcc -Wall and lint are more happy. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.73 2007/02/17 18:23:43 xsa Exp $	*/
d18 3
a20 1
#include "includes.h"
a22 1
#include "log.h"
@


1.73
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.72 2007/02/04 06:09:31 joris Exp $	*/
d420 1
a420 1
cvs_write_tagfile(char *dir, char *tag, char *date, int nb)
@


1.72
log
@dont bother trying to parse empty lines as dates.
cuts away some cpu time.

from Tobias Ulmer, thanks a million!
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.71 2007/01/27 18:53:16 otto Exp $	*/
d41 1
a41 3
	if (cvs_path_cat(dir, CVS_PATH_ENTRIES, buf, sizeof(buf)) >=
	    sizeof(buf))
		fatal("cvs_ent_open: truncation");
d45 2
a46 3
	if (cvs_path_cat(dir, CVS_PATH_BACKUPENTRIES, buf, sizeof(buf)) >=
	    sizeof(buf))
		fatal("cvs_ent_open: truncation");
d50 1
a50 3
	if (cvs_path_cat(dir, CVS_PATH_LOGENTRIES, buf, sizeof(buf)) >=
	    sizeof(buf))
		fatal("cvs_ent_open: truncation");
d357 1
a357 1
	int linenum;
d370 2
a371 1
	if (cvs_path_cat(dir, CVS_PATH_TAG, tagpath, MAXPATHLEN) >= MAXPATHLEN)
d424 1
d429 2
a430 1
	if (cvs_path_cat(dir, CVS_PATH_TAG, tagpath, MAXPATHLEN) >= MAXPATHLEN)
@


1.71
log
@mktime() produces local time, so add in tm_gmtoff to get UTC.
ok xsa@@ and joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.70 2007/01/26 11:19:44 joris Exp $	*/
d118 1
a118 2
	buf = xstrdup(entry);
	sp = buf;
d131 1
a131 1
	ent = (struct cvs_ent *)xmalloc(sizeof(*ent));
d158 2
a159 1
		if (strcmp(fields[3], CVS_DATE_DUMMY) == 0 ||
d164 2
a165 1
			strptime(fields[3], "%a %b %d %T %Y", &t);
@


1.70
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.69 2007/01/25 18:56:33 otto Exp $	*/
d168 1
@


1.69
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.68 2007/01/24 13:55:11 pyr Exp $	*/
d114 1
d163 6
a168 2
		else
			ent->ce_mtime = cvs_date_parse(fields[3]);
@


1.68
log
@terminate CVS/Entries with a newline.
ok joris@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.67 2007/01/24 08:34:12 pyr Exp $	*/
d357 1
a357 1
	char linebuf[128], *tagpath;
a367 2
	tagpath = xmalloc(MAXPATHLEN);

d369 1
a369 1
		goto out;
d375 1
a375 1
		goto out;
a413 2
out:
	xfree(tagpath);
d420 1
a420 1
	char *tagpath;
a424 2
	tagpath = xmalloc(MAXPATHLEN);

d426 1
a426 1
		goto out;
d434 1
a434 1
			goto out;
a446 1
		goto out;
a447 2
out:
	xfree(tagpath);
@


1.67
log
@the ok from xsa was for another diff, rollback previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.66 2007/01/24 08:28:46 pyr Exp $	*/
d236 1
@


1.66
log
@put a newline at the end of the Entries file, this syncs with
GNU cvs behavior and is easier on the eyes.
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.65 2007/01/12 18:24:59 joris Exp $	*/
a235 1
		fputc('\n', fp);
@


1.65
log
@and thou shalt not leak memory when removing entries
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.64 2006/12/07 13:28:21 xsa Exp $	*/
d236 1
@


1.64
log
@check for cvs_path_cat() return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.63 2006/12/07 10:44:16 xsa Exp $	*/
d94 1
a94 1
				if (line != NULL)
d97 3
@


1.63
log
@use errno where appropriate in error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.62 2006/10/24 06:25:10 ray Exp $	*/
d41 4
a44 1
	cvs_path_cat(dir, CVS_PATH_ENTRIES, buf, sizeof(buf));
d47 4
a50 1
	cvs_path_cat(dir, CVS_PATH_BACKUPENTRIES, buf, sizeof(buf));
d53 4
a56 1
	cvs_path_cat(dir, CVS_PATH_LOGENTRIES, buf, sizeof(buf));
@


1.62
log
@Reuse len instead of calling strlen again.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.61 2006/07/09 01:47:20 joris Exp $	*/
d207 2
a208 2
			fatal("cvs_ent_close: failed to write %s",
			    ep->cef_path);
d227 2
a228 2
			fatal("cvs_ent_close: %s: %s", ep->cef_path,
			     strerror(errno));
d259 2
a260 1
		fatal("cvs_ent_add: failed to open '%s'", ep->cef_lpath);
d287 2
a288 2
		fatal("cvs_ent_remove: failed to open '%s'",
		    ep->cef_lpath);
@


1.61
log
@more straightforward trace (-t) output, too much is just too noisy.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.60 2006/06/14 15:35:17 joris Exp $	*/
d72 2
a73 2
			if (len > 0 && buf[strlen(buf) - 1] == '\n')
				buf[strlen(buf) - 1] = '\0';
@


1.60
log
@useless casts are so the 80s
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.59 2006/06/14 15:14:47 xsa Exp $	*/
d255 2
a256 1
	cvs_log(LP_TRACE, "cvs_ent_add(%s, %s)", ep->cef_path, line);
d278 2
a279 1
	cvs_log(LP_TRACE, "cvs_ent_remove(%s, %s)", ep->cef_path, name);
@


1.59
log
@handle existing CVS/Tag file when adding new directories. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.58 2006/06/06 05:13:39 joris Exp $	*/
d344 1
a344 1
		*tagp = (char *)NULL;
d347 1
a347 1
		*datep = (char *)NULL;
@


1.58
log
@add support for the -D option of update,
-D allows you to update a file to matching a specified date:

opencvs up -D "1 hour ago" foobar will take the first matching
revision that was commited 1 hour ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.57 2006/05/27 03:30:30 joris Exp $	*/
d333 108
@


1.57
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 1
a166 1
		ent->ce_tag = fields[5];
@


1.56
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.55 2006/04/05 01:38:55 ray Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 11
a15 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a22 1

d26 1
a27 7
/*
 * cvs_ent_open()
 *
 * Open the CVS Entries file for the directory <dir>.
 * Returns a pointer to the CVSENTRIES file structure on success, or NULL
 * on failure.
 */
d29 1
a29 1
cvs_ent_open(const char *dir, int flags)
d31 1
d33 2
a34 6
	int exists, nodir;
	char bpath[MAXPATHLEN], *p;
	char cdpath[MAXPATHLEN], ebuf[CVS_ENT_MAXLINELEN], entpath[MAXPATHLEN];
	char mode[4];
	FILE *fp;
	struct stat st;
d36 1
a36 18
	CVSENTRIES *ep;

	exists = 0;
	nodir = 1;
	memset(mode, 0, sizeof(mode));

	/*
	 * Check if the CVS/ dir does exist. If it does,
	 * maybe the Entries file was deleted by accident,
	 * display error message. Else we might be doing a fresh
	 * update or checkout of a module.
	 */
	len = cvs_path_cat(dir, CVS_PATH_CVSDIR, cdpath, sizeof(cdpath));
	if (len >= sizeof(cdpath))
		return (NULL);

	if (stat(cdpath, &st) == 0 && S_ISDIR(st.st_mode))
		nodir = 0;	/* the CVS/ directory does exist */
d38 2
a39 3
	len = cvs_path_cat(dir, CVS_PATH_BACKUPENTRIES, bpath, sizeof(bpath));
	if (len >= sizeof(entpath))
		return (NULL);
d41 2
a42 3
	len = cvs_path_cat(dir, CVS_PATH_ENTRIES, entpath, sizeof(entpath));
	if (len >= sizeof(entpath))
		return (NULL);
d44 2
a45 11
	switch (flags & O_ACCMODE) {
	case O_WRONLY:
	case O_RDWR:
		/* we have to use append otherwise the file gets truncated */
		mode[0] = 'w';
		mode[1] = '+';
		break;
	case O_RDONLY:
		mode[0] = 'r';
		break;
	}
d47 2
a48 13
	/* we can use 'r' if the file already exists */
	if (stat(entpath, &st) == 0) {
		exists = 1;
		mode[0] = 'r';
	}

	fp = fopen(entpath, mode);
	if (fp == NULL) {
		if (nodir == 0)
			cvs_log(LP_ERRNO, "cannot open %s for %s", entpath,
			    mode[1] == '+' ? "writing" : "reading");
		return (NULL);
	}
a49 5
	ep = xcalloc(1, sizeof(*ep));

	ep->cef_path = xstrdup(entpath);
	ep->cef_bpath = xstrdup(bpath);
	ep->cef_cur = NULL;
d52 13
a64 12
	while (fgets(ebuf, (int)sizeof(ebuf), fp) != NULL) {
		len = strlen(ebuf);
		if (len > 0 && ebuf[len - 1] == '\n')
			ebuf[--len] = '\0';
		if (ebuf[0] == 'D' && ebuf[1] == '\0')
			break;
		ent = cvs_ent_parse(ebuf);
		if (ent == NULL)
			continue;

		TAILQ_INSERT_TAIL(&(ep->cef_ent), ent, ce_list);
	}
a65 2
	if (ferror(fp)) {
		cvs_log(LP_ERRNO, "read error on %s", entpath);
a66 2
		cvs_ent_close(ep);
		return (NULL);
d69 22
a90 5
	/* only keep a pointer to the open file if we're in writing mode */
	if ((flags & O_WRONLY) || (flags & O_RDWR))
		ep->cef_flags |= CVS_ENTF_WR;

	(void)fclose(fp);
a91 27
	/*
	 * look for Entries.Log and add merge it together with our
	 * list of things.
	 */
	len = cvs_path_cat(dir, CVS_PATH_LOGENTRIES, entpath, sizeof(entpath));
	if (len >= sizeof(entpath)) {
		cvs_ent_close(ep);
		return (NULL);
	}

	fp = fopen(entpath, "r");
	if (fp != NULL) {
		while (fgets(ebuf, (int)sizeof(ebuf), fp) != NULL) {
			len = strlen(ebuf);
			if (len > 0 && ebuf[len - 1] == '\n')
				ebuf[--len] = '\0';

			p = &ebuf[2];
			ent = cvs_ent_parse(p);
			if (ent == NULL)
				continue;

			if (ebuf[0] == 'A')
				cvs_ent_add(ep, ent);
			else if (ebuf[0] == 'R')
				cvs_ent_remove(ep, ent->ce_name, 0);
		}
a92 8

		/* always un-synced here, because we
		 * just added or removed entries.
		 */
		ep->cef_flags &= ~CVS_ENTF_SYNC;
	} else {
		if (exists == 1)
			ep->cef_flags |= CVS_ENTF_SYNC;
d98 2
a99 9

/*
 * cvs_ent_close()
 *
 * Close the Entries file <ep> and free all data.  Any reference to entries
 * structure within that file become invalid.
 */
void
cvs_ent_close(CVSENTRIES *ep)
d101 1
d103 1
d105 10
a114 5
	if (cvs_noexec == 0 && (ep->cef_flags & CVS_ENTF_WR) &&
	    !(ep->cef_flags & CVS_ENTF_SYNC)) {
		/* implicit sync with disk */
		(void)cvs_ent_write(ep);
	}
d116 2
a117 2
	if (ep->cef_path != NULL)
		xfree(ep->cef_path);
d119 2
a120 2
	if (ep->cef_bpath != NULL)
		xfree(ep->cef_bpath);
d122 10
a131 5
	while (!TAILQ_EMPTY(&(ep->cef_ent))) {
		ent = TAILQ_FIRST(&(ep->cef_ent));
		TAILQ_REMOVE(&(ep->cef_ent), ent, ce_list);
		cvs_ent_free(ent);
	}
d133 9
a141 2
	xfree(ep);
}
d143 2
d146 6
a151 15
/*
 * cvs_ent_add()
 *
 * Add the entry <ent> to the Entries file <ef>.  The disk contents are not
 * modified until a call to cvs_ent_write() is performed.  This is done
 * implicitly on a call to cvs_ent_close() on an Entries file that has been
 * opened for writing.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_ent_add(CVSENTRIES *ef, struct cvs_ent *ent)
{
	if (!(ef->cef_flags & CVS_ENTF_WR)) {
		cvs_log(LP_ERR, "Entries file is opened in read-only mode");
		return (-1);
d154 5
a158 5
	if (cvs_ent_get(ef, ent->ce_name) != NULL) {
		cvs_log(LP_ERR, "attempt to add duplicate entry for `%s'",
		    ent->ce_name);
		return (-1);
	}
d160 4
a163 1
	TAILQ_INSERT_TAIL(&(ef->cef_ent), ent, ce_list);
d165 4
a168 1
	ef->cef_flags &= ~CVS_ENTF_SYNC;
d170 1
a170 1
	return (0);
d173 2
a174 8

/*
 * cvs_ent_addln()
 *
 * Add a line to the Entries file.
 */
int
cvs_ent_addln(CVSENTRIES *ef, const char *line)
d177 1
d179 3
a181 4
	if (!(ef->cef_flags & CVS_ENTF_WR)) {
		cvs_log(LP_ERR, "Entries file is opened in read-only mode");
		return (-1);
	}
d183 3
a185 3
	ent = cvs_ent_parse(line);
	if (ent == NULL)
		return (-1);
d187 4
a190 2
	if (cvs_ent_get(ef, ent->ce_name) != NULL)
		return (-1);
d192 3
a194 2
	TAILQ_INSERT_TAIL(&(ef->cef_ent), ent, ce_list);
	ef->cef_flags &= ~CVS_ENTF_SYNC;
d196 1
a196 1
	return (0);
d199 2
a200 9

/*
 * cvs_ent_remove()
 *
 * Remove an entry from the Entries file <ef>.  The entry's name is given
 * by <name>.
 */
int
cvs_ent_remove(CVSENTRIES *ef, const char *name, int useprev)
d202 2
a203 1
	struct cvs_ent *ent;
d205 5
a209 1
	cvs_log(LP_TRACE, "cvs_ent_remove(%s)", name);
d211 4
a214 14
	ent = cvs_ent_get(ef, name);
	if (ent == NULL)
		return (-1);

	if (ef->cef_cur == ent) {
		/* if this element was the last one retrieved through a
		 * call to cvs_ent_next(), point to the next element to avoid
		 * keeping an invalid reference.
		 */
		if (useprev) {
			ef->cef_cur = TAILQ_PREV(ef->cef_cur,
			    cvsentrieshead, ce_list);
		} else {
			ef->cef_cur = TAILQ_NEXT(ef->cef_cur, ce_list);
d216 4
a220 2
	TAILQ_REMOVE(&(ef->cef_ent), ent, ce_list);
	cvs_ent_free(ent);
d222 10
a231 1
	ef->cef_flags &= ~CVS_ENTF_SYNC;
d233 4
a236 1
	return (0);
d239 2
a240 10

/*
 * cvs_ent_get()
 *
 * Get the CVS entry from the Entries file <ef> whose 'name' portion matches
 * <file>.
 * Returns a pointer to the cvs entry structure on success, or NULL on failure.
 */
struct cvs_ent *
cvs_ent_get(CVSENTRIES *ef, const char *file)
d242 2
d246 2
a247 3
	TAILQ_FOREACH(ent, &(ef->cef_ent), ce_list)
		if (strcmp(ent->ce_name, file) == 0)
			return (ent);
d249 3
a251 2
	return (NULL);
}
d253 1
d255 1
a255 17
/*
 * cvs_ent_next()
 *
 * This function is used to iterate over the entries in an Entries file.  The
 * first call will return the first entry of the file and each subsequent call
 * will return the entry following the last one returned.
 * Returns a pointer to the cvs entry structure on success, or NULL on failure.
 */
struct cvs_ent *
cvs_ent_next(CVSENTRIES *ef)
{
	if (ef->cef_cur == NULL)
		ef->cef_cur = TAILQ_FIRST(&(ef->cef_ent));
	else
		ef->cef_cur = TAILQ_NEXT(ef->cef_cur, ce_list);
	return (ef->cef_cur);
}
d257 2
d260 3
a262 12
/*
 * cvs_ent_parse()
 *
 * Parse a single line from a CVS/Entries file and return a cvs_ent structure
 * containing all the parsed information.
 */
struct cvs_ent*
cvs_ent_parse(const char *entry)
{
	int i;
	char *fields[CVS_ENTRIES_NFIELDS], *buf, *sp, *dp;
	struct cvs_ent *ent;
d264 1
a264 10
	buf = xstrdup(entry);
	sp = buf;
	i = 0;
	do {
		dp = strchr(sp, CVS_ENTRIES_DELIM);
		if (dp != NULL)
			*(dp++) = '\0';
		fields[i++] = sp;
		sp = dp;
	} while (dp != NULL && i < CVS_ENTRIES_NFIELDS);
d266 4
a269 4
	if (i < CVS_ENTRIES_NFIELDS) {
		cvs_log(LP_ERR, "missing fields in entry line `%s'", entry);
		return (NULL);
	}
d271 5
a275 2
	ent = xcalloc(1, sizeof(*ent));
	ent->ce_buf = buf;
d277 1
a277 6
	if (*fields[0] == '\0')
		ent->ce_type = CVS_ENT_FILE;
	else if (*fields[0] == 'D')
		ent->ce_type = CVS_ENT_DIR;
	else
		ent->ce_type = CVS_ENT_NONE;
d279 3
a281 3
	ent->ce_status = CVS_ENT_REG;
	ent->ce_name = fields[1];
	ent->processed = 0;
d283 3
a285 9
	if (ent->ce_type == CVS_ENT_FILE) {
		if (*fields[2] == '-') {
			ent->ce_status = CVS_ENT_REMOVED;
			sp = fields[2] + 1;
		} else {
			sp = fields[2];
			if (fields[2][0] == '0' && fields[2][1] == '\0')
				ent->ce_status = CVS_ENT_ADDED;
		}
d287 3
a289 4
		if ((ent->ce_rev = rcsnum_parse(sp)) == NULL) {
			cvs_ent_free(ent);
			return (NULL);
		}
d291 1
a291 11
		if (cvs_cmdop == CVS_OP_SERVER) {
			if (!strcmp(fields[3], "up to date"))
				ent->ce_status = CVS_ENT_UPTODATE;
		} else {
			if (strcmp(fields[3], CVS_DATE_DUMMY) == 0 ||
			    strncmp(fields[3], "Initial ", 8) == 0)
				ent->ce_mtime = CVS_DATE_DMSEC;
			else
				ent->ce_mtime = cvs_date_parse(fields[3]);
		}
	}
d293 3
a295 3
	ent->ce_opts = fields[4];
	ent->ce_tag = fields[5];
	return (ent);
a297 5
/*
 * cvs_ent_free()
 *
 * Free a single CVS entries structure.
 */
d303 1
a303 2
	if (ent->ce_buf != NULL)
		xfree(ent->ce_buf);
d307 2
a308 8
/*
 * cvs_ent_write()
 *
 * Explicitly write the contents of the Entries file <ef> to disk.
 * Returns 0 on success, or -1 on failure.
 */
int
cvs_ent_write(CVSENTRIES *ef)
d310 2
a311 4
	size_t len;
	char revbuf[64], timebuf[32];
	struct cvs_ent *ent;
	FILE *fp;
d313 14
a326 35
	if (ef->cef_flags & CVS_ENTF_SYNC)
		return (0);

	if ((fp = fopen(ef->cef_bpath, "w")) == NULL) {
		cvs_log(LP_ERRNO, "failed to open Entries `%s'", ef->cef_bpath);
		return (-1);
	}

	TAILQ_FOREACH(ent, &(ef->cef_ent), ce_list) {
		if (ent->ce_type == CVS_ENT_DIR) {
			putc('D', fp);
			timebuf[0] = '\0';
			revbuf[0] = '\0';
		} else {
			rcsnum_tostr(ent->ce_rev, revbuf, sizeof(revbuf));
			if (ent->ce_mtime == CVS_DATE_DMSEC &&
			    ent->ce_status != CVS_ENT_ADDED)
				strlcpy(timebuf, CVS_DATE_DUMMY,
				    sizeof(timebuf));
			else if (ent->ce_status == CVS_ENT_ADDED) {
				strlcpy(timebuf, "Initial ", sizeof(timebuf));
				strlcat(timebuf, ent->ce_name, sizeof(timebuf));
			} else {
				ctime_r(&(ent->ce_mtime), timebuf);
				len = strlen(timebuf);
				if (len > 0 && timebuf[len - 1] == '\n')
					timebuf[--len] = '\0';
			}
		}

		if (cvs_cmdop == CVS_OP_SERVER) {
			if (ent->ce_status == CVS_ENT_UPTODATE)
				strlcpy(timebuf, "up to date", sizeof(timebuf));
			else
				timebuf[0] = '\0';
d329 1
a329 4
		fprintf(fp, "/%s/%s%s/%s/%s/%s\n", ent->ce_name,
		    (ent->ce_status == CVS_ENT_REMOVED) ? "-" : "", revbuf,
		    timebuf, (ent->ce_opts != NULL) ? ent->ce_opts : "",
		    (ent->ce_tag != NULL) ? ent->ce_tag : "");
d332 1
a332 14
	/* terminating line */
	putc('D', fp);
	putc('\n', fp);

	ef->cef_flags |= CVS_ENTF_SYNC;
	fclose(fp);

	/* rename Entries.Backup to Entries */
	cvs_rename(ef->cef_bpath, ef->cef_path);

	/* remove Entries.Log */
	cvs_unlink(CVS_PATH_LOGENTRIES);

	return (0);
@


1.55
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.54 2006/01/02 08:11:56 xsa Exp $	*/
d71 1
a71 1
	if ((stat(cdpath, &st) == 0) && S_ISDIR(st.st_mode))
d117 1
a117 1
		if ((len > 0) && (ebuf[len - 1] == '\n'))
d119 1
a119 1
		if ((ebuf[0] == 'D') && (ebuf[1] == '\0'))
d155 1
a155 1
			if ((len > 0) && (ebuf[len - 1] == '\n'))
d194 1
a194 1
	if ((cvs_noexec == 0) && (ep->cef_flags & CVS_ENTF_WR) &&
d375 1
a375 1
	} while ((dp != NULL) && (i < CVS_ENTRIES_NFIELDS));
d402 1
a402 1
			if ((fields[2][0] == '0') && (fields[2][1] == '\0'))
d415 2
a416 2
			if ((strcmp(fields[3], CVS_DATE_DUMMY) == 0) ||
			    (strncmp(fields[3], "Initial ", 8) == 0))
d472 2
a473 2
			if ((ent->ce_mtime == CVS_DATE_DMSEC) &&
			    (ent->ce_status != CVS_ENT_ADDED))
d482 1
a482 1
				if ((len > 0) && (timebuf[len - 1] == '\n'))
@


1.54
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.53 2005/12/10 20:27:45 joris Exp $	*/
d108 1
a108 2
	ep = (CVSENTRIES *)xmalloc(sizeof(CVSENTRIES));
	memset(ep, 0, sizeof(*ep));
d382 1
a382 2
	ent = (struct cvs_ent *)xmalloc(sizeof(*ent));
	memset(ent, 0, sizeof(*ent));
@


1.53
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.52 2005/12/03 15:02:55 joris Exp $	*/
d27 1
a27 8
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.52
log
@- teach opencvs about Entries.Log and what to do with it
  it it exists in the CVS admin dir.
- when writing the Entries file write it to Entries.Backup first and
  then rename it to Entries when the writing was successfull.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.51 2005/12/03 01:02:08 joris Exp $	*/
d115 1
a115 6
	ep = (CVSENTRIES *)malloc(sizeof(CVSENTRIES));
	if (ep == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate Entries data");
		(void)fclose(fp);
		return (NULL);
	}
d118 2
a119 15
	ep->cef_path = strdup(entpath);
	if (ep->cef_path == NULL) {
		cvs_log(LP_ERRNO, "failed to copy Entries path");
		free(ep);
		(void)fclose(fp);
		return (NULL);
	}

	ep->cef_bpath = strdup(bpath);
	if (ep->cef_bpath == NULL) {
		cvs_ent_close(ep);
		(void)fclose(fp);
		return (NULL);
	}

d209 1
a209 1
		free(ep->cef_path);
d212 1
a212 1
		free(ep->cef_bpath);
d220 1
a220 1
	free(ep);
d374 1
a374 6
	buf = strdup(entry);
	if (buf == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate entry copy");
		return (NULL);
	}

d390 1
a390 5
	ent = (struct cvs_ent *)malloc(sizeof(*ent));
	if (ent == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate CVS entry");
		return (NULL);
	}
d448 2
a449 2
		free(ent->ce_buf);
	free(ent);
@


1.51
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.50 2005/10/22 17:23:21 joris Exp $	*/
d56 1
d81 4
d131 7
d153 1
d167 37
a203 2
	if (exists == 1)
		ep->cef_flags |= CVS_ENTF_SYNC;
d229 3
d496 2
a497 2
	if ((fp = fopen(ef->cef_path, "w")) == NULL) {
		cvs_log(LP_ERRNO, "failed to open Entries `%s'", ef->cef_path);
d542 7
@


1.50
log
@- don't check for admin files when running init;
- don't pass the Entry for newly added files to cvs_date_parse()
- in rcs_rev_add don't bother looking for the previous rev if we
  are creating the RCS file.

from PR 4575
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.49 2005/09/06 17:08:05 xsa Exp $	*/
d258 1
a258 1
cvs_ent_remove(CVSENTRIES *ef, const char *name)
d273 6
a278 1
		ef->cef_cur = TAILQ_NEXT(ef->cef_cur, ce_list);
@


1.49
log
@more bits for the local remove command support; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.48 2005/09/06 15:29:33 joris Exp $	*/
d395 2
a396 1
			if (strcmp(fields[3], CVS_DATE_DUMMY) == 0)
@


1.48
log
@Make sure entries do not go away when we run through them in the file code.
Fixes corrupt Entry files.

Problem found by Mike Pechkin, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.47 2005/08/22 08:53:12 joris Exp $	*/
d451 2
a452 3
			if ((ent->ce_mtime == CVS_DATE_DMSEC &&
			    (ent->ce_status != CVS_ENT_ADDED)) ||
			    ent->ce_status == CVS_ENT_REMOVED)
d475 2
a476 1
		    timebuf, "", "");
@


1.47
log
@add the correct entry for newly added files.
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.46 2005/08/19 08:48:30 xsa Exp $	*/
d374 1
@


1.46
log
@style;
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.45 2005/08/16 16:34:19 xsa Exp $	*/
d450 2
a451 1
			if (ent->ce_mtime == CVS_DATE_DMSEC ||
d455 4
a458 1
			else {
@


1.45
log
@#define CVS_ENT_MAXLINELEN	1024
.. as the maximum length of a line in an Entries file, and use it.
problem spotted a while ago by mpech@@.

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.44 2005/08/12 18:46:53 xsa Exp $	*/
d154 1
a154 1
	if (exists)
@


1.44
log
@- style fix
- add trace message in cvs_ent_remove()
ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.43 2005/08/10 14:49:20 xsa Exp $	*/
d56 2
a57 1
	char cdpath[MAXPATHLEN], entpath[MAXPATHLEN], ebuf[128], mode[4];
@


1.43
log
@fgets() expects the 2nd arg to be an int. OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.42 2005/07/25 12:05:43 xsa Exp $	*/
d103 1
a103 1
		if (!nodir)
d260 2
@


1.42
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.41 2005/07/24 16:46:39 xsa Exp $	*/
d128 1
a128 1
	while (fgets(ebuf, sizeof(ebuf), fp) != NULL) {
@


1.41
log
@do not use `if (!var)' unless it's boolean, better use an == check;
ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.40 2005/07/21 11:42:24 xsa Exp $	*/
d40 2
a41 2
#define CVS_ENTRIES_NFIELDS  6
#define CVS_ENTRIES_DELIM   '/'
d51 1
a51 1
CVSENTRIES*
d288 1
a288 1
struct cvs_ent*
d309 1
a309 1
struct cvs_ent*
@


1.40
log
@<sys/param.h> is already included in "cvs.h", no need to duplicate;
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.39 2005/07/14 07:38:35 xsa Exp $	*/
d171 1
a171 1
	if (!cvs_noexec && (ep->cef_flags & CVS_ENTF_WR) &&
@


1.39
log
@be consistent when declaring cvs_ent structs; ok jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.38 2005/06/17 15:09:55 joris Exp $	*/
a26 1
#include <sys/param.h>
@


1.38
log
@

correctly build a temporary copy of the client its repository
localy, so the server can execute the local commands on it
and pipe the output to the client.

with this diff in, our server is now working, please note
that we currently don't have support for all commands yet,
but you can expect this soon.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.37 2005/06/07 08:19:07 xsa Exp $	*/
d292 1
a292 1
	struct cvs_ent *ep;
d294 3
a296 3
	TAILQ_FOREACH(ep, &(ef->cef_ent), ce_list)
		if (strcmp(ep->ce_name, file) == 0)
			return (ep);
d332 1
a332 1
	struct cvs_ent *entp;
d355 2
a356 2
	entp = (struct cvs_ent *)malloc(sizeof(*entp));
	if (entp == NULL) {
d360 2
a361 2
	memset(entp, 0, sizeof(*entp));
	entp->ce_buf = buf;
d364 1
a364 1
		entp->ce_type = CVS_ENT_FILE;
d366 1
a366 1
		entp->ce_type = CVS_ENT_DIR;
d368 1
a368 1
		entp->ce_type = CVS_ENT_NONE;
d370 2
a371 2
	entp->ce_status = CVS_ENT_REG;
	entp->ce_name = fields[1];
d373 1
a373 1
	if (entp->ce_type == CVS_ENT_FILE) {
d375 1
a375 1
			entp->ce_status = CVS_ENT_REMOVED;
d380 1
a380 1
				entp->ce_status = CVS_ENT_ADDED;
d383 2
a384 2
		if ((entp->ce_rev = rcsnum_parse(sp)) == NULL) {
			cvs_ent_free(entp);
d390 1
a390 1
				entp->ce_status = CVS_ENT_UPTODATE;
d393 1
a393 1
				entp->ce_mtime = CVS_DATE_DMSEC;
d395 1
a395 1
				entp->ce_mtime = cvs_date_parse(fields[3]);
d399 3
a401 3
	entp->ce_opts = fields[4];
	entp->ce_tag = fields[5];
	return (entp);
@


1.37
log
@cvs_path_cat() already sets errno, no need to duplicate.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.36 2005/06/07 07:23:41 xsa Exp $	*/
d382 1
d388 9
a396 4
		if (strcmp(fields[3], CVS_DATE_DUMMY) == 0)
			entp->ce_mtime = CVS_DATE_DMSEC;
		else
			entp->ce_mtime = cvs_date_parse(fields[3]);
d458 7
@


1.36
log
@only display the ``cannot open ./CVS/Entries'' error message when
appropriate ... ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.35 2005/06/02 20:19:30 joris Exp $	*/
d74 1
a74 3
	if (len >= sizeof(cdpath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", cdpath);
d76 1
a76 1
	}
@


1.35
log
@

remove unneeded error reporting when using cvs_path_cat(), the
function does it for us.

OK jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.34 2005/05/31 08:58:47 xsa Exp $	*/
d56 2
a57 2
	int exists;
	char entpath[MAXPATHLEN], ebuf[128], mode[4];
d64 1
d67 15
d106 3
a108 2
		cvs_log(LP_ERRNO, "cannot open %s for %s", entpath,
		    mode[1] == '+' ? "writing" : "reading");
@


1.34
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.33 2005/05/27 17:39:40 xsa Exp $	*/
d67 1
a67 3
	if (len >= sizeof(entpath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", entpath);
a68 1
	}
@


1.33
log
@cvs_noexec check; ok jfbeers
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.32 2005/05/26 22:25:31 jfb Exp $	*/
d37 1
a38 1
#include "cvs.h"
@


1.32
log
@don't keep a pointer to the file handle in CVSENTRIES, it is only
used in cvs_ent_write(), and simplify path building a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.30 2005/05/24 04:12:25 jfb Exp $	*/
d160 1
a160 1
	if ((ep->cef_flags & CVS_ENTF_WR) &&
@


1.31
log
@- remove cvs_ent_getent(), it's not used anymore
- don't use strcmp() to compare one-character strings
@
text
@d56 1
a56 1
	int exists, l;
d66 2
a67 2
	l = snprintf(entpath, sizeof(entpath), "%s/" CVS_PATH_ENTRIES, dir);
	if (l == -1 || l >= (int)sizeof(entpath)) {
a165 2
	if (ep->cef_file != NULL)
		(void)fclose(ep->cef_file);
d413 1
d418 3
a420 7
	if (ef->cef_file == NULL) {
		ef->cef_file = fopen(ef->cef_path, "w");
		if (ef->cef_file == NULL) {
			cvs_log(LP_ERRNO, "failed to open Entries `%s'",
			    ef->cef_path);
			return (-1);
		}
a422 3

	/* reposition ourself at beginning of file */
	rewind(ef->cef_file);
d425 1
a425 1
			putc('D', ef->cef_file);
d442 1
a442 1
		fprintf(ef->cef_file, "/%s/%s%s/%s/%s/%s\n", ent->ce_name,
d448 2
a449 1
	fprintf(ef->cef_file, "D\n");
d452 1
a452 3
	fclose(ef->cef_file);
	ef->cef_file = NULL;

@


1.30
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.29 2005/05/19 21:45:45 jfb Exp $	*/
d121 1
a121 1
		if (strcmp(ebuf, "D") == 0)
d369 1
a369 1
			if (strcmp(fields[2], "0") == 0)
a387 1

a401 32


/*
 * cvs_ent_getent()
 *
 * Get a single entry from the CVS/Entries file of the basename portion of
 * path <path> and return that entry.  That entry must later be freed using
 * cvs_ent_free().
 */
struct cvs_ent*
cvs_ent_getent(const char *path)
{
	char base[MAXPATHLEN], *file;
	CVSENTRIES *entf;
	struct cvs_ent *ep;

	cvs_splitpath(path, base, sizeof(base), &file);

	entf = cvs_ent_open(base, O_RDONLY);
	if (entf == NULL)
		return (NULL);

	ep = cvs_ent_get(entf, file);
	if (ep != NULL) {
		/* take it out of the queue so it doesn't get freed */
		TAILQ_REMOVE(&(entf->cef_ent), ep, ce_list);
	}

	cvs_ent_close(entf);
	return (ep);
}

@


1.29
log
@only allocate a revision number if the entry is for a regular file,
and make sure the ce_opts and ce_tag fields point to valid strings
even for directories

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.28 2005/05/19 04:17:24 jfb Exp $	*/
a384 1

@


1.28
log
@use the date parsing code from date.y and fix timestamps on newly
created files so they match the values found in the corresponding
entries, otherwise all files appear as modified

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.27 2005/04/22 15:16:15 joris Exp $	*/
a352 6
	entp->ce_rev = rcsnum_alloc();
	if (entp->ce_rev == NULL) {
		cvs_ent_free(entp);
		return (NULL);
	}

d372 4
a375 1
		rcsnum_aton(sp, NULL, entp->ce_rev);
d381 1
d383 2
a384 3
		entp->ce_opts = fields[4];
		entp->ce_tag = fields[5];
	}
@


1.27
log
@

finish support for the '-' token in the Entry file, this allows
us to mark files as removed, and lets the remove command work
completely.

tested and ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.26 2005/04/15 14:34:15 xsa Exp $	*/
d383 1
a383 2
			entp->ce_mtime = cvs_datesec(fields[3],
			    CVS_DATE_CTIME, 0);
@


1.26
log
@snprintf() return values checks; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.25 2005/02/22 16:09:28 jfb Exp $	*/
d476 2
a477 1
			if (ent->ce_mtime == CVS_DATE_DMSEC)
d488 3
a490 2
		fprintf(ef->cef_file, "/%s/%s/%s/%s/%s\n", ent->ce_name,
		    revbuf, timebuf, "", "");
@


1.25
log
@do not leak a file pointer in case of error

from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.24 2005/02/01 18:51:04 jfb Exp $	*/
d30 2
a32 1
#include <fcntl.h>
d34 1
a35 1
#include <string.h>
d56 1
a56 1
	int exists;
d66 6
a71 1
	snprintf(entpath, sizeof(entpath), "%s/" CVS_PATH_ENTRIES, dir);
@


1.24
log
@- accept a minus sign in front of the file's revision number to
  indicate that the file has been removed
- set the timestamp as invalid if we get the "dummy timestamp"
  string in the 4th field
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.23 2005/01/14 16:57:58 jfb Exp $	*/
d125 1
d308 1
a308 1
 * Parse a single line from a CVS/Entries file and return a cvs_entry structure
@


1.23
log
@stupid me, no need to reinit the queue

pointed by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.22 2005/01/14 16:39:21 jfb Exp $	*/
d359 1
d363 16
a378 2
		rcsnum_aton(fields[2], NULL, entp->ce_rev);
		entp->ce_mtime = cvs_datesec(fields[3], CVS_DATE_CTIME, 0);
@


1.22
log
@when removing the last entry from the tail queue, reinitialize the
queue for sanity, and make sure that the current pointer is set to
the next item if it points to the item being removed.

fixes a crash reported by brad@@, tested by joris and brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.21 2004/12/14 21:23:44 jfb Exp $	*/
a257 3

	if (TAILQ_EMPTY(&(ef->cef_ent)))	/* reset */
		TAILQ_INIT(&(ef->cef_ent));
@


1.21
log
@When loading directory entries, create file structures for files which
have been lost but have a valid entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.20 2004/12/07 17:10:56 tedu Exp $	*/
d249 7
d258 3
@


1.20
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.19 2004/12/06 21:03:12 deraadt Exp $	*/
d191 3
a193 1
	if (cvs_ent_get(ef, ent->ce_name) != NULL)
d195 1
a243 5

	if (!(ef->cef_flags & CVS_ENTF_WR)) {
		cvs_log(LP_ERR, "Entries file is opened in read-only mode");
		return (-1);
	}
@


1.19
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: entries.c,v 1.18 2004/11/09 20:49:17 krapht Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a43 1

a50 1

a147 1

a182 1

a206 1

a236 1

a266 1

a287 1

a304 1

a371 1

a389 1

a419 1

@


1.18
log
@We don't need to keep a copy of each Entries line, it isn't used
anywhere and it consumes memory uselessly.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d459 1
a459 2
		}
		else {
@


1.17
log
@

use the correct Entries path to store in cef_path;
ok jfb
@
text
@d126 1
a355 6
	entp->ce_line = strdup(entry);
	if (entp->ce_line == NULL) {
		cvs_ent_free(entp);
		return (NULL);
	}

a386 2
	if (ent->ce_line != NULL)
		free(ent->ce_line);
@


1.16
log
@Instead of keeping an open pointer to the Entries file when opening with
write access, close it and reopen it only on demand, since large trees
can contain enough Entries files to generate a 'Too many open files'.

Problem spotted by Todd Fries.
@
text
@d102 1
a102 1
	ep->cef_path = strdup(dir);
@


1.15
log
@* add an entry for directories when we create them
* when writing a directory entry, skip the revision and timestamp
@
text
@d131 1
a131 1
	if ((flags & O_WRONLY) || (flags & O_RDWR)) {
d133 2
a134 4
		ep->cef_file = fp;
	}
	else
		(void)fclose(fp);
d189 1
a189 1
	if (ef->cef_file == NULL) {
d216 1
a216 1
	if (ef->cef_file == NULL) {
d247 5
a445 3
	if (ef->cef_file == NULL)
		return (-1);

d449 10
d488 2
@


1.14
log
@When the mtime is (time_t)-1, print the dummy timestamp string instead
of a bogus date
@
text
@d452 1
a452 1
		if (ent->ce_type == CVS_ENT_DIR)
d454 15
a469 9
		rcsnum_tostr(ent->ce_rev, revbuf, sizeof(revbuf));

		if (ent->ce_mtime == CVS_DATE_DMSEC)
			strlcpy(timebuf, CVS_DATE_DUMMY, sizeof(timebuf));
		else
			ctime_r(&(ent->ce_mtime), timebuf);
		len = strlen(timebuf);
		if ((len > 0) && (timebuf[len - 1] == '\n'))
			timebuf[--len] = '\0';
@


1.13
log
@Ditch the 'ce_timestamp' field in favor of 'ce_mtime', which keeps
the timestamp in time_t instead of a string
@
text
@d456 5
a460 1
		ctime_r(&(ent->ce_mtime), timebuf);
@


1.12
log
@When creating a new Entries file, make sure we put one 'D' instead of
leaving the file empty
@
text
@d369 1
a369 1
		entp->ce_timestamp = fields[3];
d439 2
a440 1
	char revbuf[64];
d456 4
d461 1
a461 1
		    revbuf, ent->ce_timestamp, "", "");
@


1.11
log
@Fix usage of cvs_splitpath()
@
text
@a44 4
static struct cvs_ent*  cvs_ent_clone (const struct cvs_ent *);



d57 1
d64 1
d82 2
a83 1
	if (stat(entpath, &st) == 0)
d85 1
a85 1

a112 2
	rewind(fp);

d125 4
d138 3
a140 1
	ep->cef_flags |= CVS_ENTF_SYNC;
@


1.10
log
@Simplify entry parsing
@
text
@d405 1
a405 1
	char base[MAXPATHLEN], file[MAXPATHLEN];
d409 1
a409 1
	cvs_splitpath(path, base, sizeof(base), file, sizeof(file));
@


1.9
log
@Implement cvs_ent_remove()
@
text
@d40 1
a40 1
#define CVS_ENTRIES_NFIELDS  5
d311 1
a311 1
	char *fields[CVS_ENTRIES_NFIELDS], *sp, *dp;
d314 21
d341 1
d345 1
a345 1
		free(entp);
d355 1
a355 8
	entp->ce_buf = strdup(entry);
	if (entp->ce_buf == NULL) {
		cvs_ent_free(entp);
		return (NULL);
	}
	sp = entp->ce_buf;

	if (*sp == CVS_ENTRIES_DELIM)
d357 1
a357 1
	else if (*sp == 'D') {
d359 1
a359 4
		sp++;
	}
	else {
		/* unknown entry, ignore for future expansion */
a360 12
		sp++;
	}

	sp++;
	i = 0;
	do {
		dp = strchr(sp, CVS_ENTRIES_DELIM);
		if (dp != NULL)
			*(dp++) = '\0';
		fields[i++] = sp;
		sp = dp;
	} while ((dp != NULL) && (i < CVS_ENTRIES_NFIELDS));
d362 1
a362 1
	entp->ce_name = fields[0];
d365 4
a368 4
		rcsnum_aton(fields[1], NULL, entp->ce_rev);
		entp->ce_timestamp = fields[2];
		entp->ce_opts = fields[3];
		entp->ce_tag = fields[4];
@


1.8
log
@* remove header cruft that belongs in file.h
* be more intelligent with the file open mode.  It seems rewind() doesn't
  work too well with a file opened in append mode
@
text
@d235 25
@


1.7
log
@* when opening an Entries file for writing, open the file in append mode
* when parsing the entries, break if we encounter the last line 'D'
* when adding the line to the file, generate it from the fields instead
  of taking the line
@
text
@d63 1
d68 3
d72 1
d74 2
d77 1
a77 1
		/* fallthrough */
a80 3
	case O_WRONLY:
		mode[0] = 'a';
		break;
d83 5
a87 1
	snprintf(entpath, sizeof(entpath), "%s/" CVS_PATH_ENTRIES, dir);
d90 2
a91 2
		cvs_log(LP_ERRNO, "cannot open CVS/Entries for reading",
		    entpath);
d114 2
d130 2
a131 1
	if ((flags & O_WRONLY) || (flags & O_RDWR))
d133 1
d137 1
d154 6
d178 4
a181 1
 * Add the entry <ent> to the Entries file <ef>.
a187 3
	void *tmp;
	char nbuf[64];

d196 3
a198 7
	if (fseek(ef->cef_file, (long)0, SEEK_END) == -1) {
		cvs_log(LP_ERRNO, "failed to seek to end of CVS/Entries file");
		return (-1);
	}
	rcsnum_tostr(ent->ce_rev, nbuf, sizeof(nbuf));
	fprintf(ef->cef_file, "/%s/%s/%s/%s/\n", ent->ce_name, nbuf,
	    ent->ce_timestamp, ent->ce_opts);
a199 1
	TAILQ_INSERT_TAIL(&(ef->cef_ent), ent, ce_list);
a212 1
	void *tmp;
d228 2
a244 1
	u_int i;
d398 39
@


1.6
log
@Fix pointer passed to fclose() in cvs_ent_close()
@
text
@d75 1
a75 1
		mode[0] = 'w';
d110 2
d160 1
d167 1
d181 3
a183 1
	fprintf(ef->cef_file, "%s\n", ent->ce_line);
@


1.5
log
@* cleanup the file API with regards to flag handling and
  general structure
* implement cvs_ent_close() correctly, fix some memory leaks, and add
  cvs_ent_getent() to get a single entry easily
@
text
@d140 1
a140 1
		(void)fclose(ep);
@


1.4
log
@Unbreak the Entries loading code and move to a tail queue so we can remove
entries as well when it will be needed
@
text
@d93 2
d130 2
a131 1
 * Close the Entries file <ep>.
d137 13
d247 1
a247 1
	if (ef->cef_cur == NULL) {
d249 3
a251 4
		return (ef->cef_cur);
	}

	return TAILQ_NEXT(ef->cef_cur, ce_list);
d274 1
d284 1
a284 1
		free(entp);
d290 1
a290 2
		free(entp->ce_line);
		free(entp);
d327 51
@


1.3
log
@make adding entries to the Entries file work
@
text
@d67 5
a71 1
	if (flags & O_RDONLY)
d73 2
a74 1
	else if (flags & O_WRONLY)
d76 1
a76 3
	else if (flags & O_RDWR) {
		mode[0] = 'r';
		mode[1] = '+';
d101 2
a102 7
	ep->cef_nid = 0;
	ep->cef_entries = NULL;
	ep->cef_nbent = 0;

	/* only keep a pointer to the open file if we're in writing mode */
	if ((flags & O_WRONLY) || (flags & O_RDWR))
		ep->cef_file = fp;
d112 1
a112 5
		if (cvs_ent_add(ep, ent) < 0) {
			cvs_ent_close(ep);
			ep = NULL;
			break;
		}
d115 6
a120 1
	(void)fclose(fp);
d163 1
a163 9
	tmp = realloc(ef->cef_entries, (ef->cef_nbent + 1) * sizeof(ent));
	if (tmp == NULL) {
		cvs_log(LP_ERRNO, "failed to resize entries buffer");
		return (-1);
	}

	ef->cef_entries = (struct cvs_ent **)tmp;
	ef->cef_entries[ef->cef_nbent++] = ent;

d192 1
a192 9
	tmp = realloc(ef->cef_entries, (ef->cef_nbent + 1) * sizeof(ent));
	if (tmp == NULL) {
		cvs_log(LP_ERRNO, "failed to resize entries buffer");
		return (-1);
	}

	ef->cef_entries = (struct cvs_ent **)tmp;
	ef->cef_entries[ef->cef_nbent++] = ent;

d209 1
d211 3
a213 4
	for (i = 0; i < ef->cef_nbent; i++) {
		if (strcmp(ef->cef_entries[i]->ce_name, file) == 0)
			return ef->cef_entries[i]; 
	}
d222 3
d231 4
a234 2
	if (ef->cef_nid >= ef->cef_nbent)
		return (NULL);
d236 1
a236 1
	return (ef->cef_entries[ef->cef_nid++]);
@


1.2
log
@prepare the entries interface so we can add entries
@
text
@d44 5
d61 1
a61 1
	char entpath[MAXPATHLEN], ebuf[128];
d66 10
d77 1
a77 1
	fp = fopen(entpath, "r");
d102 4
d142 1
a142 1
 * Add the entry <ent>
d149 5
a153 1
	struct cvs_ent *entp;
d158 2
a159 2
	entp = cvs_ent_parse(ent->ce_line);
	if (entp == NULL) {
d162 38
d201 1
a201 1
	tmp = realloc(ef->cef_entries, (ef->cef_nbent + 1) * sizeof(entp));
d208 1
a208 1
	ef->cef_entries[ef->cef_nbent++] = entp;
@


1.1
log
@Initial revision
@
text
@d53 1
a53 1
cvs_ent_open(const char *dir)
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
