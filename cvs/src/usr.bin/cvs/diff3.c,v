head	1.62;
access;
symbols
	OPENBSD_6_2_BASE:1.62
	OPENBSD_6_1:1.62.0.4
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.57.0.6
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.55.0.12
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.55.0.10
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.55.0.6
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.4
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.2
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.6
	OPENBSD_5_0:1.54.0.4
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.54.0.2
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.50.0.4
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.48.0.4
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.2
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14;
locks; strict;
comment	@ * @;


1.62
date	2016.10.18.21.06.52;	author millert;	state Exp;
branches;
next	1.61;
commitid	foVrnyJsePU0nPEu;

1.61
date	2016.10.16.13.03.40;	author millert;	state Exp;
branches;
next	1.60;
commitid	Yi19rRHCwGVoImk1;

1.60
date	2016.10.15.22.20.17;	author millert;	state Exp;
branches;
next	1.59;
commitid	bZGHsljlW6kmRYub;

1.59
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.58;
commitid	O6jeJ0TRmiewrqMI;

1.58
date	2015.09.05.09.47.08;	author jsg;	state Exp;
branches;
next	1.57;
commitid	AWjHn4VUyqwdq4dE;

1.57
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	Uu5nFG3wCl0LACBb;

1.56
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	Z3HC5pAWzpo5jsTe;

1.55
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.54;

1.54
date	2010.10.29.17.49.37;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.07.08.39.13;	author ray;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.06.14.17.27;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2008.03.09.01.52.55;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.08.20.26.34;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2008.03.08.11.53.36;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2008.03.01.14.40.23;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2008.02.29.21.43.57;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.28.20.35.27;	author joris;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.23.23.42.23;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.17.10.07.21;	author tobias;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.28.02.04.45;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.12.17.25.33;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.11.17.44.18;	author niallo;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.10.08.32.37;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.09.11.14.56;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.24.06.22.53;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.14.14.10.50;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.14.02.49.41;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.28.02.13.44;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.25.21.29.59;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.16.08.32.34;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.14.15.59.06;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.06.13.22.59;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.06.08.46.55;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.05.16.34.31;	author niallo;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.26.10.07.50;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.23.16.49.48;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.30.17.51.01;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.24.04.10.51;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.20.18.17.01;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.03.01.02.08;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.08.16.06.03;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.26.18.13.58;	author xsa;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.23.04.24.59;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.23.04.03.58;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.23.03.47.12;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.22.17.32.57;	author joris;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Using bitwise OR along with two assignments in the conditional of
a while() loop is a trap for the unwary programmer (albeit a clever
trap).  Break this up into two separate assignments and using boolean
OR for clarity.  OK otto@@
@
text
@/*	$OpenBSD: diff3.c,v 1.61 2016/10/16 13:03:40 millert Exp $	*/

/*
 * Copyright (C) Caldera International Inc.  2001-2002.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code and documentation must retain the above
 *    copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * 4. Neither the name of Caldera International, Inc. nor the names of other
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
 * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)diff3.c	8.1 (Berkeley) 6/6/93
 */

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"
#include "cvs.h"
#include "diff.h"

/* diff3 - 3-way differential file comparison */

/* diff3 [-ex3EX] d13 d23 f1 f2 f3 [m1 m3]
 *
 * d13 = diff report on f1 vs f3
 * d23 = diff report on f2 vs f3
 * f1, f2, f3 the 3 files
 * if changes in f1 overlap with changes in f3, m1 and m3 are used
 * to mark the overlaps; otherwise, the file names f1 and f3 are used
 * (only for options E and X).
 */

/*
 * "from" is first in range of changed lines; "to" is last+1
 * from=to=line after point of insertion for added lines.
 */
struct range {
	int from;
	int to;
};

struct diff {
	struct range old;
	struct range new;
};

static size_t szchanges;

static struct diff *d13;
static struct diff *d23;

/*
 * "de" is used to gather editing scripts.  These are later spewed out in
 * reverse order.  Its first element must be all zero, the "new" component
 * of "de" contains line positions or byte positions depending on when you
 * look (!?).  Array overlap indicates which sections in "de" correspond to
 * lines that are different in all three files.
 */
static struct diff *de;
static char *overlap;
static int overlapcnt = 0;
static FILE *fp[3];
static int cline[3];		/* # of the last-read line in each file (0-2) */

/*
 * the latest known correspondence between line numbers of the 3 files
 * is stored in last[1-3];
 */
static int last[4];
static int eflag;
static int oflag;		/* indicates whether to mark overlaps (-E or -X)*/
static int debug  = 0;
static char f1mark[PATH_MAX], f3mark[PATH_MAX];	/* markers for -E and -X */

static int duplicate(struct range *, struct range *);
static int edit(struct diff *, int, int);
static char *getchange(FILE *);
static char *get_line(FILE *, size_t *);
static int number(char **);
static size_t readin(int, struct diff **);
static int skip(int, int, char *);
static int edscript(int);
static int merge(size_t, size_t);
static void change(int, struct range *, int);
static void keep(int, struct range *);
static void prange(struct range *);
static void repos(int);
static void separate(const char *);
static void increase(void);
static int diff3_internal(int, char **, const char *, const char *);

int diff3_conflicts = 0;
RCSNUM *d3rev1 = NULL;
RCSNUM *d3rev2 = NULL;

static int fds[5];

void
cvs_merge_file(struct cvs_file *cf, int verbose)
{
	int i, argc;
	char *data, *patch;
	char *argv[5], r1[CVS_REV_BUFSZ], r2[CVS_REV_BUFSZ];
	char *dp13, *dp23, *path1, *path2, *path3;
	BUF *b1, *d1, *d2, *diffb;
	size_t dlen, plen;
	struct rcs_line *lp;
	struct rcs_lines *dlines, *plines;

	overlapcnt = 0;
	b1 = d1 = d2 = diffb = NULL;

	rcsnum_tostr(d3rev1, r1, sizeof(r1));
	rcsnum_tostr(d3rev2, r2, sizeof(r2));

	b1 = buf_load_fd(cf->fd);
	d1 = buf_alloc(128);
	d2 = buf_alloc(128);
	diffb = buf_alloc(128);

	(void)xasprintf(&path1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
	(void)xasprintf(&path2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
	(void)xasprintf(&path3, "%s/diff3.XXXXXXXXXX", cvs_tmpdir);

	fds[2] = buf_write_stmp(b1, path1, NULL);
	if (verbose == 1)
		cvs_printf("Retrieving revision %s\n", r1);
	fds[3] = rcs_rev_write_stmp(cf->file_rcs, d3rev1, path2, 0);
	if (verbose == 1)
		cvs_printf("Retrieving revision %s\n", r2);
	fds[4] = rcs_rev_write_stmp(cf->file_rcs, d3rev2, path3, 0);

	diffreg(path1, path3, fds[2], fds[4], d1, D_FORCEASCII);
	diffreg(path2, path3, fds[3], fds[4], d2, D_FORCEASCII);

	(void)xasprintf(&dp13, "%s/d13.XXXXXXXXXX", cvs_tmpdir);
	fds[0] = buf_write_stmp(d1, dp13, NULL);
	buf_free(d1);

	(void)xasprintf(&dp23, "%s/d23.XXXXXXXXXX", cvs_tmpdir);
	fds[1] = buf_write_stmp(d2, dp23, NULL);
	buf_free(d2);

	argc = 0;
	diffbuf = diffb;
	argv[argc++] = dp13;
	argv[argc++] = dp23;
	argv[argc++] = path1;
	argv[argc++] = path2;
	argv[argc++] = path3;

	if (lseek(fds[2], 0, SEEK_SET) < 0)
		fatal("cvs_merge_file: lseek fds[2]: %s", strerror(errno));
	if (lseek(fds[3], 0, SEEK_SET) < 0)
		fatal("cvs_merge_file: lseek fds[3]: %s", strerror(errno));
	if (lseek(fds[4], 0, SEEK_SET) < 0)
		fatal("cvs_merge_file: lseek fds[4]: %s", strerror(errno));

	diff3_conflicts = diff3_internal(argc, argv, cf->file_path, r2);
	if (diff3_conflicts < 0)
		fatal("cvs_merge_file: merging failed for an unknown reason");

	plen = buf_len(diffb);
	patch = buf_release(diffb);
	dlen = buf_len(b1);
	data = buf_release(b1);

	if (verbose == 1)
		cvs_printf("Merging differences between %s and %s into `%s'\n",
		    r1, r2, cf->file_path);

	dlines = cvs_splitlines(data, dlen);
	plines = cvs_splitlines(patch, plen);

	ed_patch_lines(dlines, plines);
	cvs_freelines(plines);

	if (verbose == 1 && diff3_conflicts != 0) {
		cvs_log(LP_ERR, "%d conflict%s found during merge, "
		    "please correct.", diff3_conflicts,
		    (diff3_conflicts > 1) ? "s" : "");
	}

	(void)close(cf->fd);
	cf->fd = open(cf->file_path, O_CREAT | O_RDWR | O_TRUNC, 0644);
	if (cf->fd == -1) {
		fatal("cvs_merge_file: failed to reopen fd for writing: %s",
		    strerror(errno));
	}

	TAILQ_FOREACH(lp, &(dlines->l_lines), l_list) {
		if (lp->l_line == NULL)
			continue;

		if (atomicio(vwrite, cf->fd, lp->l_line, lp->l_len) !=
		    lp->l_len)
			fatal("cvs_merge_file: %s", strerror(errno));
	}

	cvs_freelines(dlines);

	free(data);
	free(patch);

	for (i = 0; i < 3; i++)
		fclose(fp[i]);

	worklist_run(&temp_files, worklist_unlink);

	free(path1);
	free(path2);
	free(path3);
	free(dp13);
	free(dp23);
}

static int
diff3_internal(int argc, char **argv, const char *fmark, const char *rmark)
{
	size_t m, n;
	int i;

	eflag = 3;
	oflag = 1;

	if (argc < 5)
		return (-1);

	(void)xsnprintf(f1mark, sizeof(f1mark), "<<<<<<< %s", fmark);
	(void)xsnprintf(f3mark, sizeof(f3mark), ">>>>>>> %s", rmark);

	szchanges = 0;
	memset(last, 0, sizeof(last));
	memset(cline, 0, sizeof(cline));
	free(d13);
	free(d23);
	free(overlap);
	free(de);

	de = d13 = d23 = NULL;
	overlap = NULL;

	increase();

	/* fds[0] and fds[1] are closed in readin() */
	m = readin(fds[0], &d13);
	n = readin(fds[1], &d23);

	for (i = 0; i <= 2; i++) {
		if ((fp[i] = fdopen(fds[i + 2], "r")) == NULL) {
			cvs_log(LP_ERR, "%s", argv[i + 2]);
			return (-1);
		}
	}

	return (merge(m, n));
}

int
ed_patch_lines(struct rcs_lines *dlines, struct rcs_lines *plines)
{
	char op, *ep;
	struct rcs_line *sort, *lp, *dlp, *ndlp, *insert_after;
	int start, end, i, lineno;
	u_char tmp;

	dlp = TAILQ_FIRST(&(dlines->l_lines));
	lp = TAILQ_FIRST(&(plines->l_lines));

	end = 0;
	for (lp = TAILQ_NEXT(lp, l_list); lp != NULL;
	    lp = TAILQ_NEXT(lp, l_list)) {
		/* Skip blank lines */
		if (lp->l_len < 2)
			continue;

		/* NUL-terminate line buffer for strtol() safety. */
		tmp = lp->l_line[lp->l_len - 1];
		lp->l_line[lp->l_len - 1] = '\0';

		op = lp->l_line[strlen(lp->l_line) - 1];
		start = (int)strtol(lp->l_line, &ep, 10);

		/* Restore the last byte of the buffer */
		lp->l_line[lp->l_len - 1] = tmp;

		if (op == 'a') {
			if (start > dlines->l_nblines ||
			    start < 0 || *ep != 'a')
				fatal("ed_patch_lines %d", start);
		} else if (op == 'c') {
			if (start > dlines->l_nblines ||
			    start < 0 || (*ep != ',' && *ep != 'c'))
				fatal("ed_patch_lines");

			if (*ep == ',') {
				ep++;
				end = (int)strtol(ep, &ep, 10);
				if (end < 0 || *ep != 'c')
					fatal("ed_patch_lines");
			} else {
				end = start;
			}
		} else {
			fatal("invalid op %c found while merging", op);
		}


		for (;;) {
			if (dlp == NULL)
				break;
			if (dlp->l_lineno == start)
				break;
			if (dlp->l_lineno > start) {
				dlp = TAILQ_PREV(dlp, tqh, l_list);
			} else if (dlp->l_lineno < start) {
				ndlp = TAILQ_NEXT(dlp, l_list);
				if (ndlp->l_lineno > start)
					break;
				dlp = ndlp;
			}
		}

		if (dlp == NULL)
			fatal("ed_patch_lines");


		if (op == 'c') {
			insert_after = TAILQ_PREV(dlp, tqh, l_list);
			for (i = 0; i <= (end - start); i++) {
				ndlp = TAILQ_NEXT(dlp, l_list);
				TAILQ_REMOVE(&(dlines->l_lines), dlp, l_list);
				dlp = ndlp;
			}
			dlp = insert_after;
		}

		if (op == 'a' || op == 'c') {
			for (;;) {
				ndlp = lp;
				lp = TAILQ_NEXT(lp, l_list);
				if (lp == NULL)
					fatal("ed_patch_lines");

				if (lp->l_len == 2 &&
				    lp->l_line[0] == '.' &&
				    lp->l_line[1] == '\n')
					break;

				TAILQ_REMOVE(&(plines->l_lines), lp, l_list);
				TAILQ_INSERT_AFTER(&(dlines->l_lines), dlp,
				    lp, l_list);
				dlp = lp;

				lp->l_lineno = start;
				lp = ndlp;
			}
		}

		/*
		 * always resort lines as the markers might be put at the
		 * same line as we first started editing.
		 */
		lineno = 0;
		TAILQ_FOREACH(sort, &(dlines->l_lines), l_list)
			sort->l_lineno = lineno++;
		dlines->l_nblines = lineno - 1;
	}

	return (0);
}

/*
 * Pick up the line numbers of all changes from one change file.
 * (This puts the numbers in a vector, which is not strictly necessary,
 * since the vector is processed in one sequential pass.
 * The vector could be optimized out of existence)
 */
static size_t
readin(int fd, struct diff **dd)
{
	int a, b, c, d;
	char kind, *p;
	size_t i;

	fp[0] = fdopen(fd, "r");
	if (fp[0] == NULL)
		fatal("readin: fdopen: %s", strerror(errno));

	for (i = 0; (p = getchange(fp[0])); i++) {
		if (i >= szchanges - 1)
			increase();
		a = b = number(&p);
		if (*p == ',') {
			p++;
			b = number(&p);
		}
		kind = *p++;
		c = d = number(&p);
		if (*p==',') {
			p++;
			d = number(&p);
		}
		if (kind == 'a')
			a++;
		if (kind == 'd')
			c++;
		b++;
		d++;
		(*dd)[i].old.from = a;
		(*dd)[i].old.to = b;
		(*dd)[i].new.from = c;
		(*dd)[i].new.to = d;
	}

	if (i) {
		(*dd)[i].old.from = (*dd)[i-1].old.to;
		(*dd)[i].new.from = (*dd)[i-1].new.to;
	}

	(void)fclose(fp[0]);

	return (i);
}

static int
number(char **lc)
{
	int nn;

	nn = 0;
	while (isdigit((unsigned char)(**lc)))
		nn = nn*10 + *(*lc)++ - '0';

	return (nn);
}

static char *
getchange(FILE *b)
{
	char *line;

	while ((line = get_line(b, NULL))) {
		if (isdigit((unsigned char)line[0]))
			return (line);
	}

	return (NULL);
}

static char *
get_line(FILE *b, size_t *n)
{
	char *cp;
	size_t len;
	static char *buf;
	static size_t bufsize;

	if ((cp = fgetln(b, &len)) == NULL)
		return (NULL);

	if (cp[len - 1] != '\n')
		len++;
	if (len + 1 > bufsize) {
		do {
			bufsize += 1024;
		} while (len + 1 > bufsize);
		buf = xreallocarray(buf, 1, bufsize);
	}
	memcpy(buf, cp, len - 1);
	buf[len - 1] = '\n';
	buf[len] = '\0';
	if (n != NULL)
		*n = len;

	return (buf);
}

static int
merge(size_t m1, size_t m2)
{
	struct diff *d1, *d2, *d3;
	int dpl, j, t1, t2;

	d1 = d13;
	d2 = d23;
	j = 0;
	for (;;) {
		t1 = (d1 < d13 + m1);
		t2 = (d2 < d23 + m2);
		if (!t1 && !t2)
			break;

		if (debug) {
			printf("%d,%d=%d,%d %d,%d=%d,%d\n",
			d1->old.from, d1->old.to,
			d1->new.from, d1->new.to,
			d2->old.from, d2->old.to,
			d2->new.from, d2->new.to);
		}

		/* first file is different from others */
		if (!t2 || (t1 && d1->new.to < d2->new.from)) {
			/* stuff peculiar to 1st file */
			if (eflag==0) {
				separate("1");
				change(1, &d1->old, 0);
				keep(2, &d1->new);
				change(3, &d1->new, 0);
			}
			d1++;
			continue;
		}

		/* second file is different from others */
		if (!t1 || (t2 && d2->new.to < d1->new.from)) {
			if (eflag==0) {
				separate("2");
				keep(1, &d2->new);
				change(2, &d2->old, 0);
				change(3, &d2->new, 0);
			}
			d2++;
			continue;
		}

		/*
		 * Merge overlapping changes in first file
		 * this happens after extension (see below).
		 */
		if (d1 + 1 < d13 + m1 && d1->new.to >= d1[1].new.from) {
			d1[1].old.from = d1->old.from;
			d1[1].new.from = d1->new.from;
			d1++;
			continue;
		}

		/* merge overlapping changes in second */
		if (d2 + 1 < d23 + m2 && d2->new.to >= d2[1].new.from) {
			d2[1].old.from = d2->old.from;
			d2[1].new.from = d2->new.from;
			d2++;
			continue;
		}
		/* stuff peculiar to third file or different in all */
		if (d1->new.from == d2->new.from && d1->new.to == d2->new.to) {
			dpl = duplicate(&d1->old,&d2->old);
			if (dpl == -1)
				return (-1);

			/*
			 * dpl = 0 means all files differ
			 * dpl = 1 means files 1 and 2 identical
			 */
			if (eflag==0) {
				separate(dpl ? "3" : "");
				change(1, &d1->old, dpl);
				change(2, &d2->old, 0);
				d3 = d1->old.to > d1->old.from ? d1 : d2;
				change(3, &d3->new, 0);
			} else
				j = edit(d1, dpl, j);
			d1++;
			d2++;
			continue;
		}

		/*
		 * Overlapping changes from file 1 and 2; extend changes
		 * appropriately to make them coincide.
		 */
		if (d1->new.from < d2->new.from) {
			d2->old.from -= d2->new.from-d1->new.from;
			d2->new.from = d1->new.from;
		} else if (d2->new.from < d1->new.from) {
			d1->old.from -= d1->new.from-d2->new.from;
			d1->new.from = d2->new.from;
		}
		if (d1->new.to > d2->new.to) {
			d2->old.to += d1->new.to - d2->new.to;
			d2->new.to = d1->new.to;
		} else if (d2->new.to > d1->new.to) {
			d1->old.to += d2->new.to - d1->new.to;
			d1->new.to = d2->new.to;
		}
	}

	return (edscript(j));
}

static void
separate(const char *s)
{
	diff_output("====%s\n", s);
}

/*
 * The range of lines rold.from thru rold.to in file i is to be changed.
 * It is to be printed only if it does not duplicate something to be
 * printed later.
 */
static void
change(int i, struct range *rold, int fdup)
{
	diff_output("%d:", i);
	last[i] = rold->to;
	prange(rold);
	if (fdup || debug)
		return;
	i--;
	(void)skip(i, rold->from, NULL);
	(void)skip(i, rold->to, "  ");
}

/*
 * print the range of line numbers, rold.from thru rold.to, as n1,n2 or n1
 */
static void
prange(struct range *rold)
{
	if (rold->to <= rold->from)
		diff_output("%da\n", rold->from - 1);
	else {
		diff_output("%d", rold->from);
		if (rold->to > rold->from+1)
			diff_output(",%d", rold->to - 1);
		diff_output("c\n");
	}
}

/*
 * No difference was reported by diff between file 1 (or 2) and file 3,
 * and an artificial dummy difference (trange) must be ginned up to
 * correspond to the change reported in the other file.
 */
static void
keep(int i, struct range *rnew)
{
	int delta;
	struct range trange;

	delta = last[3] - last[i];
	trange.from = rnew->from - delta;
	trange.to = rnew->to - delta;
	change(i, &trange, 1);
}

/*
 * skip to just before line number from in file "i".  If "pr" is non-NULL,
 * print all skipped stuff with string pr as a prefix.
 */
static int
skip(int i, int from, char *pr)
{
	size_t j, n;
	char *line;

	for (n = 0; cline[i] < from - 1; n += j) {
		if ((line = get_line(fp[i], &j)) == NULL)
			return (-1);
		if (pr != NULL)
			diff_output("%s%s", pr, line);
		cline[i]++;
	}
	return ((int) n);
}

/*
 * Return 1 or 0 according as the old range (in file 1) contains exactly
 * the same data as the new range (in file 2).
 */
static int
duplicate(struct range *r1, struct range *r2)
{
	int c,d;
	int nchar;
	int nline;

	if (r1->to-r1->from != r2->to-r2->from)
		return (0);
	(void)skip(0, r1->from, NULL);
	(void)skip(1, r2->from, NULL);
	nchar = 0;
	for (nline=0; nline < r1->to - r1->from; nline++) {
		do {
			c = getc(fp[0]);
			d = getc(fp[1]);
			if (c == -1 || d== -1)
				return (-1);
			nchar++;
			if (c != d) {
				repos(nchar);
				return (0);
			}
		} while (c != '\n');
	}
	repos(nchar);
	return (1);
}

static void
repos(int nchar)
{
	int i;

	for (i = 0; i < 2; i++)
		(void)fseek(fp[i], (long)-nchar, SEEK_CUR);
}

/*
 * collect an editing script for later regurgitation
 */
static int
edit(struct diff *diff, int fdup, int j)
{
	if (((fdup + 1) & eflag) == 0)
		return (j);
	j++;
	overlap[j] = !fdup;
	if (!fdup)
		overlapcnt++;
	de[j].old.from = diff->old.from;
	de[j].old.to = diff->old.to;
	de[j].new.from = de[j-1].new.to + skip(2, diff->new.from, NULL);
	de[j].new.to = de[j].new.from + skip(2, diff->new.to, NULL);
	return (j);
}

/* regurgitate */
static int
edscript(int n)
{
	int j, k;
	char block[BUFSIZ+1];

	for (; n > 0; n--) {
		if (!oflag || !overlap[n])
			prange(&de[n].old);
		else
			diff_output("%da\n=======\n", de[n].old.to -1);
		(void)fseek(fp[2], (long)de[n].new.from, SEEK_SET);
		for (k = de[n].new.to-de[n].new.from; k > 0; k-= j) {
			j = k > BUFSIZ ? BUFSIZ : k;
			if (fread(block, 1, j, fp[2]) != (size_t)j)
				return (-1);
			block[j] = '\0';
			diff_output("%s", block);
		}

		if (!oflag || !overlap[n])
			diff_output(".\n");
		else {
			diff_output("%s\n.\n", f3mark);
			diff_output("%da\n%s\n.\n", de[n].old.from - 1, f1mark);
		}
	}

	return (overlapcnt);
}

static void
increase(void)
{
	size_t newsz, incr;

	/* are the memset(3) calls needed? */
	newsz = szchanges == 0 ? 64 : 2 * szchanges;
	incr = newsz - szchanges;

	d13 = xreallocarray(d13, newsz, sizeof(*d13));
	memset(d13 + szchanges, 0, incr * sizeof(*d13));
	d23 = xreallocarray(d23, newsz, sizeof(*d23));
	memset(d23 + szchanges, 0, incr * sizeof(*d23));
	de = xreallocarray(de, newsz, sizeof(*de));
	memset(de + szchanges, 0, incr * sizeof(*de));
	overlap = xreallocarray(overlap, newsz, sizeof(*overlap));
	memset(overlap + szchanges, 0, incr * sizeof(*overlap));
	szchanges = newsz;
}
@


1.61
log
@Remove useless n=n assignment in the first parse of a for().
It was already removed from the rcs version by nicm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.60 2016/10/15 22:20:17 millert Exp $	*/
d546 6
a551 1
	while ((t1 = (d1 < d13 + m1)) | (t2 = (d2 < d23 + m2))) {
@


1.60
log
@Quiet compiler warnings.  OK tomc@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.59 2015/11/05 09:48:21 nicm Exp $	*/
d789 1
a789 1
	for (n = n; n > 0; n--) {
@


1.59
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.58 2015/09/05 09:47:08 jsg Exp $	*/
d298 2
a299 1
	de = d13 = d23 = overlap = NULL;
d797 1
a797 1
			if (fread(block, 1, j, fp[2]) != j)
@


1.58
log
@Add brackets to clarify assignments that are the result of a test operator.

ok deraadt@@ looks correct millert@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.57 2015/01/16 06:40:07 deraadt Exp $	*/
d260 2
a261 3
	if (data != NULL)
		xfree(data);
	xfree(patch);
d268 5
a272 5
	xfree(path1);
	xfree(path2);
	xfree(path3);
	xfree(dp13);
	xfree(dp23);
d293 4
a296 8
	if (d13 != NULL)
		xfree(d13);
	if (d23 != NULL)
		xfree(d23);
	if (overlap != NULL)
		xfree(overlap);
	if (de != NULL)
		xfree(de);
d298 1
a298 2
	overlap = NULL;
	de = d13 = d23 = NULL;
@


1.57
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.56 2014/12/01 21:58:46 deraadt Exp $	*/
d551 1
a551 1
	while ((t1 = d1 < d13 + m1) | (t2 = d2 < d23 + m2)) {
@


1.56
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.55 2012/03/04 04:05:15 fgsch Exp $	*/
d131 1
a131 1
static char f1mark[MAXPATHLEN], f3mark[MAXPATHLEN];	/* markers for -E and -X */
@


1.55
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.54 2010/10/29 17:49:37 nicm Exp $	*/
d531 1
a531 1
		buf = xrealloc(buf, 1, bufsize);
d828 1
a828 1
	d13 = xrealloc(d13, newsz, sizeof(*d13));
d830 1
a830 1
	d23 = xrealloc(d23, newsz, sizeof(*d23));
d832 1
a832 1
	de = xrealloc(de, newsz, sizeof(*de));
d834 1
a834 1
	overlap = xrealloc(overlap, newsz, sizeof(*overlap));
@


1.54
log
@Nuke some unused variables and remove an unnecessary call to dirname().

From Michael W Bombardieri via ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.53 2010/07/23 21:46:05 ray Exp $	*/
d136 1
a136 1
static char *getline(FILE *, size_t *);
d506 1
a506 1
	while ((line = getline(b, NULL))) {
d515 1
a515 1
getline(FILE *b, size_t *n)
d717 1
a717 1
		if ((line = getline(fp[i], &j)) == NULL)
@


1.53
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.52 2010/07/23 08:31:19 ray Exp $	*/
d163 1
a163 1
	BUF *b1, *b2, *b3, *d1, *d2, *diffb;
d169 1
a169 1
	b1 = b2 = b3 = d1 = d2 = diffb = NULL;
@


1.52
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.51 2009/10/27 23:59:37 deraadt Exp $	*/
d107 2
a108 2
static struct diff *d13 = NULL;
static struct diff *d23 = NULL;
d117 2
a118 2
static struct diff *de = NULL;
static char *overlap = NULL;
d165 2
a166 2
	struct cvs_line *lp;
	struct cvs_lines *dlines, *plines;
d174 4
a177 4
	b1 = cvs_buf_load_fd(cf->fd);
	d1 = cvs_buf_alloc(128);
	d2 = cvs_buf_alloc(128);
	diffb = cvs_buf_alloc(128);
d183 1
a183 1
	fds[2] = cvs_buf_write_stmp(b1, path1, NULL);
d195 2
a196 2
	fds[0] = cvs_buf_write_stmp(d1, dp13, NULL);
	cvs_buf_free(d1);
d199 2
a200 2
	fds[1] = cvs_buf_write_stmp(d2, dp23, NULL);
	cvs_buf_free(d2);
d221 4
a224 4
	plen = cvs_buf_len(diffb);
	patch = cvs_buf_release(diffb);
	dlen = cvs_buf_len(b1);
	data = cvs_buf_release(b1);
d323 1
a323 1
ed_patch_lines(struct cvs_lines *dlines, struct cvs_lines *plines)
d326 1
a326 1
	struct cvs_line *sort, *lp, *dlp, *ndlp, *insert_after;
d802 1
a802 2
			if (fread(block, (size_t)1, (size_t)j,
			    fp[2]) != (size_t)j)
@


1.51
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.50 2009/06/07 08:39:13 ray Exp $	*/
d267 1
a267 1
	cvs_worklist_run(&temp_files, cvs_worklist_unlink);
d378 1
a378 1
				dlp = TAILQ_PREV(dlp, cvs_tqh, l_list);
d392 1
a392 1
			insert_after = TAILQ_PREV(dlp, cvs_tqh, l_list);
@


1.50
log
@More cvs/diff/rcs convergence:
1. Mostly variable/function renaming, SIZE_T_MAX->SIZE_MAX, and
spacing.
2. One strchr -> strncspn.
3. diff had a weird thing where it set file[12] = ofile[12] but
never updated file or ofile, then if file and ofile were different
it freed it. I removed it.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.49 2009/06/06 14:17:27 ray Exp $	*/
a65 11

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static const char rcsid[] =
    "$OpenBSD: diff3.c,v 1.49 2009/06/06 14:17:27 ray Exp $";
#endif /* not lint */
@


1.49
log
@Sync some rcsdiff changes to cvsdiff.  As a side effect,
cvs diff -t now works.  There should be no functional change
otherwise.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.48 2008/03/09 01:52:55 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.48 2008/03/09 01:52:55 joris Exp $";
d202 2
a203 2
	cvs_diffreg(path1, path3, fds[2], fds[4], d1, D_FORCEASCII);
	cvs_diffreg(path2, path3, fds[3], fds[4], d2, D_FORCEASCII);
@


1.48
log
@unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.47 2008/03/08 20:26:34 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.47 2008/03/08 20:26:34 joris Exp $";
d202 2
a203 2
	cvs_diffreg(path1, path3, fds[2], fds[4], d1);
	cvs_diffreg(path2, path3, fds[3], fds[4], d2);
@


1.47
log
@add checkout/update -j support.
still has some rough edges.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.46 2008/03/08 11:53:36 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.46 2008/03/08 11:53:36 joris Exp $";
d336 1
a336 1
	char op, *ep, *p;
@


1.46
log
@correct usage of lseek(2);
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.45 2008/03/01 14:40:23 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.45 2008/03/01 14:40:23 joris Exp $";
d118 2
a119 2
static struct diff *d13;
static struct diff *d23;
d128 2
a129 2
static struct diff *de;
static char *overlap;
d162 2
d181 3
a183 2
	rcsnum_tostr(cf->file_ent->ce_rev, r1, sizeof(r1));
	rcsnum_tostr(cf->file_rcsrev, r2, sizeof(r2));
d197 1
a197 2
	fds[3] = rcs_rev_write_stmp(cf->file_rcs, cf->file_ent->ce_rev,
	    path2, 0);
d200 1
a200 1
	fds[4] = rcs_rev_write_stmp(cf->file_rcs, cf->file_rcsrev, path3, 0);
d237 3
a239 2
	cvs_printf("Merging differences between %s and %s into `%s'\n",
	    r1, r2, cf->file_path);
d243 1
d278 1
a278 5
	(void)unlink(path1);
	(void)unlink(path2);
	(void)unlink(path3);
	(void)unlink(dp13);
	(void)unlink(dp23);
a292 1
	/* XXX */
d302 15
d336 1
a336 1
	char op, *ep;
d350 1
d354 1
a354 1
		/* len - 1 is NUL terminator so we use len - 2 for 'op' */
d357 1
d360 1
d364 1
a364 1
				fatal("ed_patch_lines");
d378 2
d419 3
a421 1
				if (!memcmp(lp->l_line, ".", 1))
@


1.45
log
@when reopening the file pass the proper mode and reopen it using
O_RDWR instead of O_WRONLY so that when we are in server mode
we do not screw up in cvs_remote_send_file().
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.44 2008/02/29 21:43:57 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.44 2008/02/29 21:43:57 joris Exp $";
d219 1
a219 1
	if (lseek(fds[2], SEEK_SET, 0) < 0)
d221 1
a221 1
	if (lseek(fds[3], SEEK_SET, 0) < 0)
d223 1
a223 1
	if (lseek(fds[4], SEEK_SET, 0) < 0)
@


1.44
log
@handle file permissions and owners properly.
matches what gnu cvs does.

fixes the fact that we couldnt update group writable files.

problem report & diff testing by David Crawshaw.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.43 2008/02/28 20:35:27 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.43 2008/02/28 20:35:27 joris Exp $";
d250 1
a250 1
	cf->fd = open(cf->file_path, O_CREAT | O_WRONLY | O_TRUNC);
@


1.43
log
@nobody needs weird debug messages
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.42 2008/02/27 22:34:04 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.42 2008/02/27 22:34:04 joris Exp $";
d250 1
a250 1
	cf->fd = open(cf->file_path, O_WRONLY | O_TRUNC);
@


1.42
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.41 2008/02/23 23:42:23 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.41 2008/02/23 23:42:23 joris Exp $";
a305 1
	cvs_printf("calling readin with fds[0] (%s)\n", argv[0]);
a306 1
	cvs_printf("calling readin with fds[1] (%s)\n", argv[1]);
a309 1
		cvs_printf("opening fds[%d] (%s)\n", i + 2, argv[i + 2]);
@


1.41
log
@reset overlapcnt at each cvs_merge_file() call so that files that
are being merged that have no conflicts will not report the previous
conflicts that might have been found.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.40 2008/02/11 20:33:11 tobias Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.40 2008/02/11 20:33:11 tobias Exp $";
d149 1
a149 1
static size_t readin(char *, struct diff **);
d163 2
d168 1
a168 1
	int argc;
a186 7
	(void)close(cf->fd);
	cf->fd = open(cf->file_path, O_WRONLY | O_TRUNC);
	if (cf->fd == -1) {
		fatal("cvs_merge_file: failed to reopen fd for writing: %s",
		    strerror(errno));
	}

d191 1
a191 1
	cvs_buf_write_stmp(b1, path1, NULL);
d194 2
a195 1
	rcs_rev_write_stmp(cf->file_rcs, cf->file_ent->ce_rev, path2, 0);
d198 1
a198 1
	rcs_rev_write_stmp(cf->file_rcs, cf->file_rcsrev, path3, 0);
d200 2
a201 2
	cvs_diffreg(path1, path3, d1);
	cvs_diffreg(path2, path3, d2);
d204 1
a204 1
	cvs_buf_write_stmp(d1, dp13, NULL);
d208 1
a208 1
	cvs_buf_write_stmp(d2, dp23, NULL);
d219 7
d249 7
d271 3
d304 6
a309 2
	m = readin(argv[0], &d13);
	n = readin(argv[1], &d23);
d312 2
a313 1
		if ((fp[i] = fopen(argv[i + 2], "r")) == NULL) {
d436 1
a436 1
readin(char *name, struct diff **dd)
d442 4
a445 1
	fp[0] = fopen(name, "r");
d476 1
@


1.40
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.39 2007/09/17 10:07:21 tobias Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.39 2007/09/17 10:07:21 tobias Exp $";
d175 1
@


1.39
log
@Imported atomicio interface.

Requested by ray@@, OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.38 2007/09/10 14:29:53 tobias Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.38 2007/09/10 14:29:53 tobias Exp $";
d179 4
a182 4
	b1 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT);
	d1 = cvs_buf_alloc((size_t)128, BUF_AUTOEXT);
	d2 = cvs_buf_alloc((size_t)128, BUF_AUTOEXT);
	diffb = cvs_buf_alloc((size_t)128, BUF_AUTOEXT);
@


1.38
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.37 2007/06/28 21:38:09 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.37 2007/06/28 21:38:09 xsa Exp $";
d86 1
d249 2
a250 1
		if (write(cf->fd, lp->l_line, lp->l_len) == -1)
@


1.37
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.36 2007/05/29 00:19:10 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.36 2007/05/29 00:19:10 ray Exp $";
d81 1
d733 1
a733 1
		(void)fseek(fp[i], (long)-nchar, 1);
d767 1
a767 1
		(void)fseek(fp[2], (long)de[n].new.from, 0);
@


1.36
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.35 2007/02/22 06:42:09 otto Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.35 2007/02/22 06:42:09 otto Exp $";
d166 1
a166 1
	char *argv[5], r1[16], r2[16];
@


1.35
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.34 2007/01/31 21:07:35 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.34 2007/01/31 21:07:35 xsa Exp $";
a494 1
		char *newbuf;
d498 1
a498 2
		newbuf = xrealloc(buf, 1, bufsize);
		buf = newbuf;
a789 2
	struct diff *p;
	char *q;
d796 8
a803 12
	p = xrealloc(d13, newsz, sizeof(*d13));
	memset(p + szchanges, 0, incr * sizeof(*d13));
	d13 = p;
	p = xrealloc(d23, newsz, sizeof(*d23));
	memset(p + szchanges, 0, incr * sizeof(*d23));
	d23 = p;
	p = xrealloc(de, newsz, sizeof(*de));
	memset(p + szchanges, 0, incr * sizeof(*de));
	de = p;
	q = xrealloc(overlap, newsz, sizeof(*overlap));
	memset(q + szchanges, 0, incr * sizeof(*overlap));
	overlap = q;
@


1.34
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.33 2007/01/28 02:04:45 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.33 2007/01/28 02:04:45 joris Exp $";
d78 6
a83 1
#include "includes.h"
a85 1
#include "log.h"
@


1.33
log
@add merging support in both local and remote sides.
tested by many, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.32 2007/01/12 23:32:01 niallo Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.32 2007/01/12 23:32:01 niallo Exp $";
d279 2
a280 7
	i = snprintf(f1mark, sizeof(f1mark), "<<<<<<< %s", fmark);
	if (i < 0 ||i >= (int)sizeof(f1mark))
		fatal("diff3_internal: truncation");

	i = snprintf(f3mark, sizeof(f3mark), ">>>>>>> %s", rmark);
	if (i < 0 ||i >= (int)sizeof(f3mark))
		fatal("diff3_internal: truncation");
@


1.32
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.31 2007/01/12 17:25:33 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.31 2007/01/12 17:25:33 joris Exp $";
d136 1
a136 1
static char f1mark[40], f3mark[40];	/* markers for -E and -X */
d157 2
a158 3
BUF *
cvs_diff3(RCSFILE *rf, char *workfile, int workfd, RCSNUM *rev1,
	RCSNUM *rev2, int verbose)
d166 2
d170 2
d173 1
a173 6
	rcsnum_tostr(rev1, r1, sizeof(r1));
	rcsnum_tostr(rev2, r2, sizeof(r2));

	if ((b1 = cvs_buf_load_fd(workfd, BUF_AUTOEXT)) == NULL)
		goto out;

d178 7
d192 1
a192 1
	rcs_rev_write_stmp(rf, rev1, path2, 0);
d195 1
a195 1
	rcs_rev_write_stmp(rf, rev2, path3, 0);
a201 1

a202 1
	d1 = NULL;
a205 1

a206 1
	d2 = NULL;
d216 3
a218 6
	diff3_conflicts = diff3_internal(argc, argv, workfile, r2);
	if (diff3_conflicts < 0) {
		cvs_buf_free(diffb);
		diffb = NULL;
		goto out;
	}
a223 1
	diffb = b1 = NULL;
d225 7
a231 2
	if ((diffb = cvs_patchfile(data, dlen, patch, plen, ed_patch_lines)) == NULL)
		goto out;
d239 12
a250 1
	xfree(data);
a252 8
out:
	if (b1 != NULL)
		cvs_buf_free(b1);
	if (d1 != NULL)
		cvs_buf_free(d1);
	if (d2 != NULL)
		cvs_buf_free(d2);

d259 5
a263 12
	if (path1 != NULL)
		xfree(path1);
	if (path2 != NULL)
		xfree(path2);
	if (path3 != NULL)
		xfree(path3);
	if (dp13 != NULL)
		xfree(dp13);
	if (dp23 != NULL)
		xfree(dp23);

	return (diffb);
@


1.31
log
@complete binary support for opencvs,
adding/importing binary files now works too

partially taken from openrcs
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.30 2007/01/11 17:44:18 niallo Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.30 2007/01/11 17:44:18 niallo Exp $";
a175 10
	if (verbose == 1)
		cvs_printf("Retrieving revision %s\n", r1);
	if ((b2 = rcs_getrev(rf, rev1)) == NULL)
		goto out;

	if (verbose == 1)
		cvs_printf("Retrieving revision %s\n", r2);
	if ((b3 = rcs_getrev(rf, rev2)) == NULL)
		goto out;

d185 6
a190 5
	cvs_buf_write_stmp(b2, path2, NULL);
	cvs_buf_write_stmp(b3, path3, NULL);

	cvs_buf_free(b2);
	b2 = NULL;
a242 4
	if (b2 != NULL)
		cvs_buf_free(b2);
	if (b3 != NULL)
		cvs_buf_free(b3);
@


1.30
log
@rework opencvs so that we can deal with binary files.  previously we assumed all files were ascii,
which broke things in real-world usage.  now a checkout of src should work, albeit using lots of
memory and cpu.  fixing this is the next step.

testing by many.
ok & some input joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.29 2006/11/10 08:32:37 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.29 2006/11/10 08:32:37 xsa Exp $";
a229 3

	cvs_buf_putc(diffb, '\0');
	cvs_buf_putc(b1, '\0');
@


1.29
log
@sync with usr.bin/rcs/diff3.c
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.28 2006/11/09 11:14:56 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.28 2006/11/09 11:14:56 xsa Exp $";
d166 1
d234 1
d236 1
d240 1
a240 1
	if ((diffb = cvs_patchfile(data, patch, ed_patch_lines)) == NULL)
d325 1
d333 7
a339 2
		if (lp->l_line[0] == '\0')
			fatal("ed_patch_lines");
d342 2
d400 1
a400 1
				if (!strcmp(lp->l_line, "."))
@


1.28
log
@respect TMPDIR here too, changes pulled in from usr.bin/rcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.27 2006/10/24 06:22:53 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.27 2006/10/24 06:22:53 ray Exp $";
d294 7
a300 5
	strlcpy(f1mark, "<<<<<<< ", sizeof(f1mark));
	strlcat(f1mark, fmark, sizeof(f1mark));

	strlcpy(f3mark, ">>>>>>> ", sizeof(f3mark));
	strlcat(f3mark, rmark, sizeof(f3mark));
d320 1
a320 1
	struct cvs_line *sort, *lp, *dlp, *ndlp;
d373 1
d379 1
a379 1
			dlp = TAILQ_PREV(dlp, cvs_tqh, l_list);
@


1.27
log
@Check that string length != 0 before setting buf[strlen(buf) - 1].

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.26 2006/07/08 09:25:44 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.26 2006/07/08 09:25:44 ray Exp $";
d164 1
a164 2
	char path1[MAXPATHLEN], path2[MAXPATHLEN], path3[MAXPATHLEN];
	char dp13[MAXPATHLEN], dp23[MAXPATHLEN];
d189 4
a192 1
	strlcpy(path1, "/tmp/diff1.XXXXXXXXXX", sizeof(path1));
a193 2

	strlcpy(path2, "/tmp/diff2.XXXXXXXXXX", sizeof(path2));
a194 2

	strlcpy(path3, "/tmp/diff3.XXXXXXXXXX", sizeof(path3));
d203 1
a203 1
	strlcpy(dp13, "/tmp/d13.XXXXXXXXXX", sizeof(dp13));
d209 1
a209 1
	strlcpy(dp23, "/tmp/d23.XXXXXXXXXX", sizeof(dp23));
d266 11
@


1.26
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.25 2006/06/14 14:10:50 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.25 2006/06/14 14:10:50 joris Exp $";
d318 2
@


1.25
log
@add cvs_buf_load_fd() which does the same as cvs_buf_load()
except it takes a decriptor as argument instead of a path.

modified cvs_buf_load() to open the descriptor then pass
it to cvs_buf_load_fd().

change all the calls to cvs_buf_load() that have a descriptor
open for the path to cvs_buf_load_fd() to prevent races.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.24 2006/05/27 03:30:30 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.24 2006/05/27 03:30:30 joris Exp $";
d191 1
a191 1
	cvs_buf_write_stmp(b1, path1, 0600, NULL);
d194 1
a194 1
	cvs_buf_write_stmp(b2, path2, 0600, NULL);
d197 1
a197 1
	cvs_buf_write_stmp(b3, path3, 0600, NULL);
d206 1
a206 1
	cvs_buf_write_stmp(d1, dp13, 0600, NULL);
d212 1
a212 1
	cvs_buf_write_stmp(d2, dp23, 0600, NULL);
@


1.24
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.23 2006/04/14 02:49:41 deraadt Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.23 2006/04/14 02:49:41 deraadt Exp $";
d158 2
a159 1
cvs_diff3(RCSFILE *rf, char *workfile, RCSNUM *rev1, RCSNUM *rev2, int verbose)
d173 1
a173 1
	if ((b1 = cvs_buf_load(workfile, BUF_AUTOEXT)) == NULL)
@


1.23
log
@more nasty spaces go bye bye
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.22 2006/04/05 01:38:55 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.22 2006/04/05 01:38:55 ray Exp $";
d190 1
a190 1
	cvs_buf_write_stmp(b1, path1, 0600);
d193 1
a193 1
	cvs_buf_write_stmp(b2, path2, 0600);
d196 1
a196 1
	cvs_buf_write_stmp(b3, path3, 0600);
d205 1
a205 1
	cvs_buf_write_stmp(d1, dp13, 0600);
d211 1
a211 1
	cvs_buf_write_stmp(d2, dp23, 0600);
d242 1
a242 1
		cvs_log(LP_WARN, "%d conflict%s found during merge, "
d296 1
a296 1
			cvs_log(LP_ERRNO, "%s", argv[i + 2]);
@


1.22
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.21 2006/03/28 02:13:44 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.21 2006/03/28 02:13:44 ray Exp $";
d241 1
a241 1
	if ((verbose ==1) && (diff3_conflicts != 0)) {
d320 2
a321 2
			if ((start > dlines->l_nblines) ||
			    (start < 0) || (*ep != 'a'))
d324 2
a325 2
			if ((start > dlines->l_nblines) ||
			    (start < 0) || ((*ep != ',') && (*ep != 'c')))
d331 1
a331 1
				if ((end < 0) || (*ep != 'c'))
@


1.21
log
@Today is Integer Overflow Prevention Day:
 - Sync xmalloc.? with ssh versions.
 - Change all xrealloc() calls to new API.

``I really like this.'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.20 2006/03/25 21:29:59 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.20 2006/03/25 21:29:59 ray Exp $";
d488 1
d492 2
a493 1
		buf = xrealloc(buf, 1, bufsize);
d793 2
a794 2
	p = xrealloc(d13, newsz, sizeof(struct diff));
	memset(p + szchanges, 0, incr * sizeof(struct diff));
d796 2
a797 2
	p = xrealloc(d23, newsz, sizeof(struct diff));
	memset(p + szchanges, 0, incr * sizeof(struct diff));
d799 2
a800 2
	p = xrealloc(de, newsz, sizeof(struct diff));
	memset(p + szchanges, 0, incr * sizeof(struct diff));
d802 2
a803 2
	q = xrealloc(overlap, newsz, sizeof(char));
	memset(q + szchanges, 0, incr * sizeof(char));
@


1.20
log
@Correct integer types, remove unused arguments, non-portable bitshifts
changed to division, KNF, replace unreachable code with goto fail,
et cetera.  Found by lint.

The free() -> xfree() as well.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.19 2006/03/16 08:32:34 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.19 2006/03/16 08:32:34 xsa Exp $";
d491 1
a491 1
		buf = xrealloc(buf, bufsize);
d791 1
a791 1
	p = xrealloc(d13, newsz * sizeof(struct diff));
d794 1
a794 1
	p = xrealloc(d23, newsz * sizeof(struct diff));
d797 1
a797 1
	p = xrealloc(de, newsz * sizeof(struct diff));
d800 1
a800 1
	q = xrealloc(overlap, newsz * sizeof(char));
@


1.19
log
@kill two unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.18 2006/03/14 15:59:06 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.18 2006/03/14 15:59:06 xsa Exp $";
d143 1
a143 1
static int readin(char *, struct diff **);
d146 1
a146 1
static int merge(int, int);
d274 2
a275 1
	int i, m, n;
d406 1
a406 1
static int
d503 1
a503 1
merge(int m1, int m2)
d514 4
a517 4
			d1->old.from,d1->old.to,
			d1->new.from,d1->new.to,
			d2->old.from,d2->old.to,
			d2->new.from,d2->new.to);
@


1.18
log
@add an argument to cvs_diff3() to be able to handle verbosity of
commands; fixes rcsmerge -q  behaviour. OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.17 2006/03/06 13:22:59 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.17 2006/03/06 13:22:59 xsa Exp $";
d160 1
a160 1
	int ret, argc;
a166 1
	ret = -1;
d308 1
a308 1
	int start, end, busy, i, lineno;
d313 1
a313 1
	busy = end = 0;
@


1.17
log
@adapt informative message if we are sending output to stdout.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.16 2006/03/06 08:46:55 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.16 2006/03/06 08:46:55 xsa Exp $";
d158 1
a158 1
cvs_diff3(RCSFILE *rf, char *workfile, RCSNUM *rev1, RCSNUM *rev2)
d176 2
a177 1
	cvs_printf("Retrieving revision %s\n", r1);
d181 2
a182 1
	cvs_printf("Retrieving revision %s\n", r2);
d242 1
a242 1
	if (diff3_conflicts != 0) {
@


1.16
log
@if the submitted rev(s) is/are the same as the head rev, skip the process
for the specified file. Fix some error messages while there. OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.15 2006/03/05 16:34:31 niallo Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.15 2006/03/05 16:34:31 niallo Exp $";
a235 3

	cvs_printf("Merging differences between %s and %s into %s\n",
	    r1, r2, workfile);
@


1.15
log
@oops, forgot the diff3.c portion of this diff:

fatal() instead of returning -1 on failure in patch functions
ed_patch_lines() and rcs_patch_lines().  this can avoid segfault in certain
circumstances.

From: Ray Lai <ray@@cyth.net>

discussed with xsa@@ and joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.14 2006/02/26 10:07:50 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.14 2006/02/26 10:07:50 xsa Exp $";
d244 2
a245 2
		cvs_printf("%d conflict%s found during merge, "
		    "please correct.\n", diff3_conflicts,
@


1.14
log
@out-of-bounds access and correct some printf while here;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.13 2006/01/23 16:49:48 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.13 2006/01/23 16:49:48 xsa Exp $";
d323 1
a323 1
				return (-1);
d327 1
a327 1
				return (-1);
d333 1
a333 1
					return (-1);
d356 1
a356 1
			return (-1);
d373 1
a373 1
					return (-1);
@


1.13
log
@snprintf() -> strlcpy()/strlcat(); OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.12 2006/01/02 08:11:56 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.12 2006/01/02 08:11:56 xsa Exp $";
d237 2
a238 2
	cvs_printf("Merging changes between '%s' and '%s' ", r1, r2);
	cvs_printf("into '%s'\n", workfile);
d441 4
a444 2
	(*dd)[i].old.from = (*dd)[i-1].old.to;
	(*dd)[i].new.from = (*dd)[i-1].new.to;
@


1.12
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.11 2005/12/30 17:51:01 reyk Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.11 2005/12/30 17:51:01 reyk Exp $";
d285 5
a289 2
	snprintf(f1mark, sizeof(f1mark), "<<<<<<< %s", fmark);
	snprintf(f3mark, sizeof(f3mark), ">>>>>>> %s", rmark);
@


1.11
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.10 2005/12/24 04:10:51 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.10 2005/12/24 04:10:51 joris Exp $";
d78 1
a78 8
#include <sys/queue.h>

#include <err.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.10
log
@remove useless cvs_buf_alloc() failure checks;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.9 2005/12/20 18:17:01 xsa Exp $	*/
d74 2
a75 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.9 2005/12/20 18:17:01 xsa Exp $";
d251 3
a253 2
		cvs_printf("%d conflict%s found during merge, please correct.\n",
		    diff3_conflicts, (diff3_conflicts > 1) ? "s" : "");
d765 2
a766 1
			if (fread(block, (size_t)1, (size_t)j, fp[2]) != (size_t)j)
@


1.9
log
@cvs_buf_putc() and cvs_buf_write_*() functions cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.8 2005/12/10 20:27:45 joris Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.8 2005/12/10 20:27:45 joris Exp $";
d190 3
a192 8
	if ((d1 = cvs_buf_alloc((size_t)128, BUF_AUTOEXT)) == NULL)
		goto out;

	if ((d2 = cvs_buf_alloc((size_t)128, BUF_AUTOEXT)) == NULL)
		goto out;

	if ((diffb = cvs_buf_alloc((size_t)128, BUF_AUTOEXT)) == NULL)
		goto out;
@


1.8
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.7 2005/12/03 01:02:08 joris Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.7 2005/12/03 01:02:08 joris Exp $";
d200 1
a200 2
	if (cvs_buf_write_stmp(b1, path1, 0600) == -1)
		goto out;
d203 1
a203 2
	if (cvs_buf_write_stmp(b2, path2, 0600) == -1)
		goto out;
d206 1
a206 2
	if (cvs_buf_write_stmp(b3, path3, 0600) == -1)
		goto out;
d215 1
a215 2
	if (cvs_buf_write_stmp(d1, dp13, 0600) < 0)
		goto out;
d221 1
a221 2
	if (cvs_buf_write_stmp(d2, dp23, 0600) < 0)
		goto out;
d241 2
a242 11
	if (cvs_buf_putc(diffb, '\0') < 0) {
		cvs_buf_free(diffb);
		diffb = NULL;
		goto out;
	}

	if (cvs_buf_putc(b1, '\0') < 0) {
		cvs_buf_free(diffb);
		diffb = NULL;
		goto out;
	}
@


1.7
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.6 2005/11/08 16:06:03 xsa Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.6 2005/11/08 16:06:03 xsa Exp $";
d273 2
a274 2
	free(data);
	free(patch);
d511 1
a511 2
		if ((buf = realloc(buf, bufsize)) == NULL)
			err(EXIT_FAILURE, NULL);
d810 1
a810 3
	p = realloc(d13, newsz * sizeof(struct diff));
	if (p == NULL)
		err(1, NULL);
d813 1
a813 3
	p = realloc(d23, newsz * sizeof(struct diff));
	if (p == NULL)
		err(1, NULL);
d816 1
a816 3
	p = realloc(de, newsz * sizeof(struct diff));
	if (p == NULL)
		err(1, NULL);
d819 1
a819 3
	q = realloc(overlap, newsz * sizeof(char));
	if (q == NULL)
		err(1, NULL);
@


1.6
log
@missing casts;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.5 2005/10/26 18:13:58 xsa Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.5 2005/10/26 18:13:58 xsa Exp $";
d238 5
a242 1
	if ((diff3_conflicts = diff3_internal(argc, argv, workfile, r2)) < 0)
d244 1
d248 1
d254 1
d267 5
@


1.5
log
@diff3_conflicts cleanup; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.4 2005/10/23 04:24:59 joris Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.4 2005/10/23 04:24:59 joris Exp $";
d190 1
a190 1
	if ((d1 = cvs_buf_alloc(128, BUF_AUTOEXT)) == NULL)
d193 1
a193 1
	if ((d2 = cvs_buf_alloc(128, BUF_AUTOEXT)) == NULL)
d196 1
a196 1
	if ((diffb = cvs_buf_alloc(128, BUF_AUTOEXT)) == NULL)
d771 1
a771 1
			if (fread(block, 1, j, fp[2]) != (size_t)j)
@


1.4
log
@better output;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.3 2005/10/23 04:03:58 joris Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.3 2005/10/23 04:03:58 joris Exp $";
d161 1
a161 1
int	diff3_conflicts = 0;
@


1.3
log
@shut up gcc;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.2 2005/10/23 03:47:12 joris Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.2 2005/10/23 03:47:12 joris Exp $";
d161 2
a178 3
	cvs_printf("merging changes between '%s' and '%s'", r1, r2);
	cvs_printf(" into '%s'\n", workfile);

d182 1
d186 1
d238 1
a238 1
	if ((ret = diff3_internal(argc, argv, workfile, r2)) < 0)
d254 3
@


1.2
log
@- correctly terminate buffer in edscript(), noted by pedro@@
- fix patching for large files;
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.1 2005/10/22 17:32:57 joris Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3.c,v 1.1 2005/10/22 17:32:57 joris Exp $";
d320 1
a320 1
	busy = 0;
@


1.1
log
@diff3 support, needed for merging files together;

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.7 2005/08/01 08:17:57 otto Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.7 2005/08/01 08:17:57 otto Exp $";
d130 1
a130 1
static int overlapcnt;
d331 1
a331 1
			    (start < 0) || (*ep != ','))
d334 8
a341 4
			ep++;
			end = (int)strtol(ep, &ep, 10);
			if ((end < 0) || (*ep != 'c'))
				return (-1);
d344 1
d363 1
d365 1
a365 1
			for (i = start; i <= end; i++) {
d370 1
d757 1
a757 1
	char block[BUFSIZ];
d772 1
@

