head	1.318;
access;
symbols
	OPENBSD_6_1:1.316.0.4
	OPENBSD_6_1_BASE:1.316
	OPENBSD_6_0:1.313.0.4
	OPENBSD_6_0_BASE:1.313
	OPENBSD_5_9:1.313.0.2
	OPENBSD_5_9_BASE:1.313
	OPENBSD_5_8:1.312.0.6
	OPENBSD_5_8_BASE:1.312
	OPENBSD_5_7:1.312.0.2
	OPENBSD_5_7_BASE:1.312
	OPENBSD_5_6:1.311.0.6
	OPENBSD_5_6_BASE:1.311
	OPENBSD_5_5:1.311.0.4
	OPENBSD_5_5_BASE:1.311
	OPENBSD_5_4:1.310.0.10
	OPENBSD_5_4_BASE:1.310
	OPENBSD_5_3:1.310.0.8
	OPENBSD_5_3_BASE:1.310
	OPENBSD_5_2:1.310.0.6
	OPENBSD_5_2_BASE:1.310
	OPENBSD_5_1_BASE:1.310
	OPENBSD_5_1:1.310.0.4
	OPENBSD_5_0:1.310.0.2
	OPENBSD_5_0_BASE:1.310
	OPENBSD_4_9:1.308.0.2
	OPENBSD_4_9_BASE:1.308
	OPENBSD_4_8:1.298.0.2
	OPENBSD_4_8_BASE:1.298
	OPENBSD_4_7:1.291.0.2
	OPENBSD_4_7_BASE:1.291
	OPENBSD_4_6:1.291.0.4
	OPENBSD_4_6_BASE:1.291
	OPENBSD_4_5:1.286.0.2
	OPENBSD_4_5_BASE:1.286
	OPENBSD_4_4:1.278.0.2
	OPENBSD_4_4_BASE:1.278
	OPENBSD_4_3:1.256.0.2
	OPENBSD_4_3_BASE:1.256
	OPENBSD_4_2:1.215.0.2
	OPENBSD_4_2_BASE:1.215
	OPENBSD_4_1:1.210.0.2
	OPENBSD_4_1_BASE:1.210
	OPENBSD_4_0:1.188.0.2
	OPENBSD_4_0_BASE:1.188
	OPENBSD_3_9:1.130.0.2
	OPENBSD_3_9_BASE:1.130
	OPENBSD_3_8:1.59.0.2
	OPENBSD_3_8_BASE:1.59
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.0.1;
locks; strict;
comment	@ * @;


1.318
date	2017.08.28.18.52.25;	author millert;	state Exp;
branches;
next	1.317;
commitid	h2D0zpdtHhPOaAB4;

1.317
date	2017.05.31.16.31.55;	author joris;	state Exp;
branches;
next	1.316;
commitid	as3es39ZrOaOG2oi;

1.316
date	2016.10.15.22.20.17;	author millert;	state Exp;
branches;
next	1.315;
commitid	bZGHsljlW6kmRYub;

1.315
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.314;
commitid	8Vv7d4HkmCtExfc6;

1.314
date	2016.10.13.20.31.45;	author millert;	state Exp;
branches;
next	1.313;
commitid	FSXDgtg44KCsffGG;

1.313
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.312;
commitid	O6jeJ0TRmiewrqMI;

1.312
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.311;
commitid	Uu5nFG3wCl0LACBb;

1.311
date	2014.01.08.13.23.55;	author okan;	state Exp;
branches;
next	1.310;

1.310
date	2011.05.02.22.22.54;	author chl;	state Exp;
branches;
next	1.309;

1.309
date	2011.03.27.14.15.02;	author nicm;	state Exp;
branches;
next	1.308;

1.308
date	2010.11.11.21.00.59;	author nicm;	state Exp;
branches;
next	1.307;

1.307
date	2010.10.31.15.37.34;	author nicm;	state Exp;
branches;
next	1.306;

1.306
date	2010.10.27.08.35.45;	author tobias;	state Exp;
branches;
next	1.305;

1.305
date	2010.10.20.19.53.53;	author tobias;	state Exp;
branches;
next	1.304;

1.304
date	2010.10.15.08.46.23;	author tobias;	state Exp;
branches;
next	1.303;

1.303
date	2010.10.15.08.44.12;	author tobias;	state Exp;
branches;
next	1.302;

1.302
date	2010.09.29.09.23.54;	author tobias;	state Exp;
branches;
next	1.301;

1.301
date	2010.09.11.07.26.00;	author tobias;	state Exp;
branches;
next	1.300;

1.300
date	2010.09.03.08.37.52;	author tobias;	state Exp;
branches;
next	1.299;

1.299
date	2010.09.02.00.21.41;	author tobias;	state Exp;
branches;
next	1.298;

1.298
date	2010.07.31.11.37.37;	author nicm;	state Exp;
branches;
next	1.297;

1.297
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.296;

1.296
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.295;

1.295
date	2010.07.21.09.22.17;	author ray;	state Exp;
branches;
next	1.294;

1.294
date	2010.07.13.20.41.55;	author nicm;	state Exp;
branches;
next	1.293;

1.293
date	2010.07.09.20.07.05;	author naddy;	state Exp;
branches;
next	1.292;

1.292
date	2010.03.30.16.56.32;	author zinovik;	state Exp;
branches;
next	1.291;

1.291
date	2009.06.07.08.39.13;	author ray;	state Exp;
branches;
next	1.290;

1.290
date	2009.06.06.14.17.27;	author ray;	state Exp;
branches;
next	1.289;

1.289
date	2009.03.30.21.45.33;	author joris;	state Exp;
branches;
next	1.288;

1.288
date	2009.03.25.21.23.17;	author joris;	state Exp;
branches;
next	1.287;

1.287
date	2009.03.22.18.39.10;	author tobias;	state Exp;
branches;
next	1.286;

1.286
date	2009.02.21.19.46.40;	author tobias;	state Exp;
branches;
next	1.285;

1.285
date	2009.02.18.20.08.24;	author joris;	state Exp;
branches;
next	1.284;

1.284
date	2009.02.15.13.40.33;	author joris;	state Exp;
branches;
next	1.283;

1.283
date	2009.01.02.00.11.01;	author canacar;	state Exp;
branches;
next	1.282;

1.282
date	2008.11.09.08.51.43;	author tobias;	state Exp;
branches;
next	1.281;

1.281
date	2008.09.17.06.47.57;	author reyk;	state Exp;
branches;
next	1.280;

1.280
date	2008.09.12.13.24.24;	author tobias;	state Exp;
branches;
next	1.279;

1.279
date	2008.09.12.13.11.15;	author tobias;	state Exp;
branches;
next	1.278;

1.278
date	2008.06.26.21.31.40;	author joris;	state Exp;
branches;
next	1.277;

1.277
date	2008.06.15.04.44.06;	author joris;	state Exp;
branches;
next	1.276;

1.276
date	2008.06.15.04.38.52;	author tobias;	state Exp;
branches;
next	1.275;

1.275
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.274;

1.274
date	2008.06.14.03.58.29;	author tobias;	state Exp;
branches;
next	1.273;

1.273
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.272;

1.272
date	2008.06.14.00.47.49;	author tobias;	state Exp;
branches;
next	1.271;

1.271
date	2008.06.12.17.06.17;	author joris;	state Exp;
branches;
next	1.270;

1.270
date	2008.06.12.07.16.14;	author joris;	state Exp;
branches;
next	1.269;

1.269
date	2008.06.10.20.30.17;	author joris;	state Exp;
branches;
next	1.268;

1.268
date	2008.06.10.16.05.04;	author joris;	state Exp;
branches;
next	1.267;

1.267
date	2008.06.10.05.01.36;	author tobias;	state Exp;
branches;
next	1.266;

1.266
date	2008.06.08.13.36.30;	author tobias;	state Exp;
branches;
next	1.265;

1.265
date	2008.05.22.07.57.58;	author joris;	state Exp;
branches;
next	1.264;

1.264
date	2008.05.17.21.06.44;	author tobias;	state Exp;
branches;
next	1.263;

1.263
date	2008.05.11.12.13.41;	author tobias;	state Exp;
branches;
next	1.262;

1.262
date	2008.03.13.17.01.25;	author joris;	state Exp;
branches;
next	1.261;

1.261
date	2008.03.09.19.41.13;	author tobias;	state Exp;
branches;
next	1.260;

1.260
date	2008.03.08.22.33.03;	author joris;	state Exp;
branches;
next	1.259;

1.259
date	2008.03.08.20.52.36;	author tobias;	state Exp;
branches;
next	1.258;

1.258
date	2008.03.08.20.26.34;	author joris;	state Exp;
branches;
next	1.257;

1.257
date	2008.03.08.11.53.36;	author joris;	state Exp;
branches;
next	1.256;

1.256
date	2008.03.02.19.31.08;	author tobias;	state Exp;
branches;
next	1.255;

1.255
date	2008.03.01.21.29.37;	author deraadt;	state Exp;
branches;
next	1.254;

1.254
date	2008.03.01.20.03.56;	author joris;	state Exp;
branches;
next	1.253;

1.253
date	2008.02.28.21.55.48;	author tobias;	state Exp;
branches;
next	1.252;

1.252
date	2008.02.28.20.24.25;	author joris;	state Exp;
branches;
next	1.251;

1.251
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.250;

1.250
date	2008.02.20.09.19.04;	author joris;	state Exp;
branches;
next	1.249;

1.249
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.248;

1.248
date	2008.02.10.10.21.42;	author joris;	state Exp;
branches;
next	1.247;

1.247
date	2008.02.09.13.41.22;	author joris;	state Exp;
branches;
next	1.246;

1.246
date	2008.02.09.11.17.02;	author tobias;	state Exp;
branches;
next	1.245;

1.245
date	2008.02.03.16.59.11;	author tobias;	state Exp;
branches;
next	1.244;

1.244
date	2008.02.02.16.59.48;	author tobias;	state Exp;
branches;
next	1.243;

1.243
date	2008.01.31.22.19.36;	author tobias;	state Exp;
branches;
next	1.242;

1.242
date	2008.01.31.21.49.17;	author joris;	state Exp;
branches;
next	1.241;

1.241
date	2008.01.31.20.29.16;	author joris;	state Exp;
branches;
next	1.240;

1.240
date	2008.01.28.21.33.20;	author tobias;	state Exp;
branches;
next	1.239;

1.239
date	2008.01.14.17.29.21;	author tobias;	state Exp;
branches;
next	1.238;

1.238
date	2008.01.13.11.11.08;	author tobias;	state Exp;
branches;
next	1.237;

1.237
date	2008.01.10.10.48.50;	author tobias;	state Exp;
branches;
next	1.236;

1.236
date	2008.01.10.10.15.48;	author tobias;	state Exp;
branches;
next	1.235;

1.235
date	2008.01.10.09.55.18;	author tobias;	state Exp;
branches;
next	1.234;

1.234
date	2008.01.10.09.37.26;	author tobias;	state Exp;
branches;
next	1.233;

1.233
date	2008.01.10.09.35.02;	author tobias;	state Exp;
branches;
next	1.232;

1.232
date	2008.01.06.14.45.50;	author tobias;	state Exp;
branches;
next	1.231;

1.231
date	2007.11.11.14.02.35;	author tobias;	state Exp;
branches;
next	1.230;

1.230
date	2007.11.11.10.14.33;	author tobias;	state Exp;
branches;
next	1.229;

1.229
date	2007.11.11.10.01.41;	author tobias;	state Exp;
branches;
next	1.228;

1.228
date	2007.11.11.09.49.47;	author tobias;	state Exp;
branches;
next	1.227;

1.227
date	2007.11.08.20.43.42;	author tobias;	state Exp;
branches;
next	1.226;

1.226
date	2007.11.08.20.37.40;	author tobias;	state Exp;
branches;
next	1.225;

1.225
date	2007.10.09.12.59.53;	author tobias;	state Exp;
branches;
next	1.224;

1.224
date	2007.10.09.12.18.53;	author tobias;	state Exp;
branches;
next	1.223;

1.223
date	2007.10.09.12.16.29;	author tobias;	state Exp;
branches;
next	1.222;

1.222
date	2007.09.24.13.44.20;	author joris;	state Exp;
branches;
next	1.221;

1.221
date	2007.09.24.11.18.43;	author joris;	state Exp;
branches;
next	1.220;

1.220
date	2007.09.22.15.41.46;	author joris;	state Exp;
branches;
next	1.219;

1.219
date	2007.09.17.10.07.21;	author tobias;	state Exp;
branches;
next	1.218;

1.218
date	2007.09.13.13.10.57;	author tobias;	state Exp;
branches;
next	1.217;

1.217
date	2007.09.07.23.05.04;	author joris;	state Exp;
branches;
next	1.216;

1.216
date	2007.08.27.19.18.05;	author xsa;	state Exp;
branches;
next	1.215;

1.215
date	2007.07.03.13.22.43;	author joris;	state Exp;
branches;
next	1.214;

1.214
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.213;

1.213
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.212;

1.212
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.211;

1.211
date	2007.05.26.20.58.36;	author niallo;	state Exp;
branches;
next	1.210;

1.210
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.209;

1.209
date	2007.02.19.11.40.00;	author otto;	state Exp;
branches;
next	1.208;

1.208
date	2007.02.04.15.05.05;	author otto;	state Exp;
branches;
next	1.207;

1.207
date	2007.02.01.20.36.21;	author otto;	state Exp;
branches;
next	1.206;

1.206
date	2007.01.26.21.59.11;	author otto;	state Exp;
branches;
next	1.205;

1.205
date	2007.01.26.21.48.17;	author xsa;	state Exp;
branches;
next	1.204;

1.204
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.203;

1.203
date	2007.01.25.19.32.56;	author otto;	state Exp;
branches;
next	1.202;

1.202
date	2007.01.25.18.35.30;	author niallo;	state Exp;
branches;
next	1.201;

1.201
date	2007.01.16.02.52.56;	author joris;	state Exp;
branches;
next	1.200;

1.200
date	2007.01.14.23.10.56;	author joris;	state Exp;
branches;
next	1.199;

1.199
date	2007.01.13.20.59.49;	author joris;	state Exp;
branches;
next	1.198;

1.198
date	2007.01.13.05.09.17;	author joris;	state Exp;
branches;
next	1.197;

1.197
date	2007.01.13.04.29.37;	author joris;	state Exp;
branches;
next	1.196;

1.196
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.195;

1.195
date	2007.01.12.19.28.12;	author joris;	state Exp;
branches;
next	1.194;

1.194
date	2007.01.12.17.25.33;	author joris;	state Exp;
branches;
next	1.193;

1.193
date	2007.01.11.17.44.18;	author niallo;	state Exp;
branches;
next	1.192;

1.192
date	2006.12.21.15.03.15;	author niallo;	state Exp;
branches;
next	1.191;

1.191
date	2006.12.21.14.59.25;	author niallo;	state Exp;
branches;
next	1.190;

1.190
date	2006.12.21.14.58.14;	author niallo;	state Exp;
branches;
next	1.189;

1.189
date	2006.12.04.03.53.30;	author niallo;	state Exp;
branches;
next	1.188;

1.188
date	2006.08.23.20.28.00;	author joris;	state Exp;
branches;
next	1.187;

1.187
date	2006.08.02.03.23.40;	author ray;	state Exp;
branches;
next	1.186;

1.186
date	2006.07.30.03.47.48;	author ray;	state Exp;
branches;
next	1.185;

1.185
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.184;

1.184
date	2006.06.09.14.57.13;	author xsa;	state Exp;
branches;
next	1.183;

1.183
date	2006.06.06.05.13.39;	author joris;	state Exp;
branches;
next	1.182;

1.182
date	2006.06.04.13.53.27;	author joris;	state Exp;
branches;
next	1.181;

1.181
date	2006.06.04.09.52.56;	author joris;	state Exp;
branches;
next	1.180;

1.180
date	2006.06.01.20.00.52;	author joris;	state Exp;
branches;
next	1.179;

1.179
date	2006.05.31.22.25.59;	author joris;	state Exp;
branches;
next	1.178;

1.178
date	2006.05.31.18.26.14;	author joris;	state Exp;
branches;
next	1.177;

1.177
date	2006.05.30.19.16.51;	author joris;	state Exp;
branches;
next	1.176;

1.176
date	2006.05.29.07.15.52;	author joris;	state Exp;
branches;
next	1.175;

1.175
date	2006.05.28.10.14.59;	author joris;	state Exp;
branches;
next	1.174;

1.174
date	2006.05.27.18.04.46;	author joris;	state Exp;
branches;
next	1.173;

1.173
date	2006.05.27.05.59.32;	author joris;	state Exp;
branches;
next	1.172;

1.172
date	2006.05.27.03.30.31;	author joris;	state Exp;
branches;
next	1.171;

1.171
date	2006.05.01.18.17.39;	author niallo;	state Exp;
branches;
next	1.170;

1.170
date	2006.04.25.10.31.39;	author xsa;	state Exp;
branches;
next	1.169;

1.169
date	2006.04.14.02.49.43;	author deraadt;	state Exp;
branches;
next	1.168;

1.168
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.167;

1.167
date	2006.04.13.23.41.13;	author ray;	state Exp;
branches;
next	1.166;

1.166
date	2006.04.13.19.55.41;	author joris;	state Exp;
branches;
next	1.165;

1.165
date	2006.04.13.19.16.15;	author joris;	state Exp;
branches;
next	1.164;

1.164
date	2006.04.12.22.54.23;	author ray;	state Exp;
branches;
next	1.163;

1.163
date	2006.04.10.12.15.21;	author xsa;	state Exp;
branches;
next	1.162;

1.162
date	2006.04.10.08.08.00;	author xsa;	state Exp;
branches;
next	1.161;

1.161
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.160;

1.160
date	2006.04.02.20.57.53;	author joris;	state Exp;
branches;
next	1.159;

1.159
date	2006.04.01.18.02.55;	author joris;	state Exp;
branches;
next	1.158;

1.158
date	2006.03.30.23.12.52;	author joris;	state Exp;
branches;
next	1.157;

1.157
date	2006.03.30.23.09.01;	author joris;	state Exp;
branches;
next	1.156;

1.156
date	2006.03.30.23.06.25;	author joris;	state Exp;
branches;
next	1.155;

1.155
date	2006.03.29.09.16.53;	author ray;	state Exp;
branches;
next	1.154;

1.154
date	2006.03.28.07.42.56;	author ray;	state Exp;
branches;
next	1.153;

1.153
date	2006.03.28.02.13.44;	author ray;	state Exp;
branches;
next	1.152;

1.152
date	2006.03.27.21.56.32;	author niallo;	state Exp;
branches;
next	1.151;

1.151
date	2006.03.27.16.01.18;	author xsa;	state Exp;
branches;
next	1.150;

1.150
date	2006.03.27.15.26.12;	author xsa;	state Exp;
branches;
next	1.149;

1.149
date	2006.03.27.07.14.13;	author xsa;	state Exp;
branches;
next	1.148;

1.148
date	2006.03.26.20.02.54;	author xsa;	state Exp;
branches;
next	1.147;

1.147
date	2006.03.25.21.29.59;	author ray;	state Exp;
branches;
next	1.146;

1.146
date	2006.03.24.16.18.22;	author xsa;	state Exp;
branches;
next	1.145;

1.145
date	2006.03.23.09.03.28;	author xsa;	state Exp;
branches;
next	1.144;

1.144
date	2006.03.15.05.05.35;	author deraadt;	state Exp;
branches;
next	1.143;

1.143
date	2006.03.11.22.44.11;	author niallo;	state Exp;
branches;
next	1.142;

1.142
date	2006.03.11.18.40.14;	author niallo;	state Exp;
branches;
next	1.141;

1.141
date	2006.03.10.05.57.39;	author ray;	state Exp;
branches;
next	1.140;

1.140
date	2006.03.09.10.56.33;	author xsa;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.08.09.03.59;	author xsa;	state Exp;
branches;
next	1.138;

1.138
date	2006.03.08.05.01.50;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.07.19.17.57;	author joris;	state Exp;
branches;
next	1.136;

1.136
date	2006.03.07.16.48.53;	author joris;	state Exp;
branches;
next	1.135;

1.135
date	2006.03.07.01.43.18;	author joris;	state Exp;
branches;
next	1.134;

1.134
date	2006.03.07.01.40.52;	author joris;	state Exp;
branches;
next	1.133;

1.133
date	2006.03.05.16.22.31;	author niallo;	state Exp;
branches;
next	1.132;

1.132
date	2006.03.05.16.06.59;	author niallo;	state Exp;
branches;
next	1.131;

1.131
date	2006.03.05.14.18.56;	author niallo;	state Exp;
branches;
next	1.130;

1.130
date	2006.02.26.16.06.46;	author niallo;	state Exp;
branches;
next	1.129;

1.129
date	2006.02.13.11.02.58;	author xsa;	state Exp;
branches;
next	1.128;

1.128
date	2006.02.09.08.08.56;	author niallo;	state Exp;
branches;
next	1.127;

1.127
date	2006.02.01.13.52.51;	author xsa;	state Exp;
branches;
next	1.126;

1.126
date	2006.01.26.09.05.31;	author xsa;	state Exp;
branches;
next	1.125;

1.125
date	2006.01.10.15.00.47;	author niallo;	state Exp;
branches;
next	1.124;

1.124
date	2006.01.03.11.06.55;	author xsa;	state Exp;
branches;
next	1.123;

1.123
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.122;

1.122
date	2005.12.30.17.51.01;	author reyk;	state Exp;
branches;
next	1.121;

1.121
date	2005.12.30.16.53.55;	author niallo;	state Exp;
branches;
next	1.120;

1.120
date	2005.12.30.16.48.33;	author niallo;	state Exp;
branches;
next	1.119;

1.119
date	2005.12.30.16.45.35;	author niallo;	state Exp;
branches;
next	1.118;

1.118
date	2005.12.28.18.27.24;	author joris;	state Exp;
branches;
next	1.117;

1.117
date	2005.12.27.16.05.20;	author niallo;	state Exp;
branches;
next	1.116;

1.116
date	2005.12.24.04.10.51;	author joris;	state Exp;
branches;
next	1.115;

1.115
date	2005.12.22.02.26.33;	author niallo;	state Exp;
branches;
next	1.114;

1.114
date	2005.12.20.18.17.01;	author xsa;	state Exp;
branches;
next	1.113;

1.113
date	2005.12.20.16.55.21;	author xsa;	state Exp;
branches;
next	1.112;

1.112
date	2005.12.19.17.43.01;	author xsa;	state Exp;
branches;
next	1.111;

1.111
date	2005.12.12.17.47.03;	author joris;	state Exp;
branches;
next	1.110;

1.110
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.109;

1.109
date	2005.12.08.18.56.10;	author joris;	state Exp;
branches;
next	1.108;

1.108
date	2005.12.03.15.31.53;	author joris;	state Exp;
branches;
next	1.107;

1.107
date	2005.12.03.15.07.21;	author joris;	state Exp;
branches;
next	1.106;

1.106
date	2005.12.03.02.10.58;	author joris;	state Exp;
branches;
next	1.105;

1.105
date	2005.12.03.01.02.09;	author joris;	state Exp;
branches;
next	1.104;

1.104
date	2005.12.02.21.21.47;	author joris;	state Exp;
branches;
next	1.103;

1.103
date	2005.12.02.20.08.41;	author joris;	state Exp;
branches;
next	1.102;

1.102
date	2005.12.01.18.22.09;	author xsa;	state Exp;
branches;
next	1.101;

1.101
date	2005.11.22.11.49.02;	author niallo;	state Exp;
branches;
next	1.100;

1.100
date	2005.11.16.08.15.21;	author xsa;	state Exp;
branches;
next	1.99;

1.99
date	2005.11.12.21.34.48;	author niallo;	state Exp;
branches;
next	1.98;

1.98
date	2005.11.09.15.42.58;	author xsa;	state Exp;
branches;
next	1.97;

1.97
date	2005.11.02.20.32.44;	author niallo;	state Exp;
branches;
next	1.96;

1.96
date	2005.10.30.11.10.12;	author xsa;	state Exp;
branches;
next	1.95;

1.95
date	2005.10.29.19.05.50;	author niallo;	state Exp;
branches;
next	1.94;

1.94
date	2005.10.22.17.32.57;	author joris;	state Exp;
branches;
next	1.93;

1.93
date	2005.10.22.17.23.21;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2005.10.18.01.08.13;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2005.10.16.17.44.15;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2005.10.15.22.56.03;	author niallo;	state Exp;
branches;
next	1.89;

1.89
date	2005.10.11.00.10.16;	author joris;	state Exp;
branches;
next	1.88;

1.88
date	2005.10.11.00.08.34;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2005.10.11.00.07.29;	author joris;	state Exp;
branches;
next	1.86;

1.86
date	2005.10.10.23.37.15;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2005.10.10.14.42.54;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2005.10.10.14.16.03;	author joris;	state Exp;
branches;
next	1.83;

1.83
date	2005.10.10.13.41.25;	author joris;	state Exp;
branches;
next	1.82;

1.82
date	2005.10.09.16.14.23;	author joris;	state Exp;
branches;
next	1.81;

1.81
date	2005.10.07.23.59.56;	author niallo;	state Exp;
branches;
next	1.80;

1.80
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.05.23.11.07;	author niallo;	state Exp;
branches;
next	1.78;

1.78
date	2005.10.05.17.34.59;	author joris;	state Exp;
branches;
next	1.77;

1.77
date	2005.10.05.11.38.02;	author joris;	state Exp;
branches;
next	1.76;

1.76
date	2005.10.04.23.02.56;	author joris;	state Exp;
branches;
next	1.75;

1.75
date	2005.10.04.14.55.36;	author joris;	state Exp;
branches;
next	1.74;

1.74
date	2005.10.02.21.44.18;	author joris;	state Exp;
branches;
next	1.73;

1.73
date	2005.09.30.15.06.46;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2005.09.30.14.50.32;	author niallo;	state Exp;
branches;
next	1.71;

1.71
date	2005.09.29.20.54.29;	author moritz;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.29.20.51.35;	author moritz;	state Exp;
branches;
next	1.69;

1.69
date	2005.09.29.20.47.34;	author moritz;	state Exp;
branches;
next	1.68;

1.68
date	2005.09.29.20.44.58;	author moritz;	state Exp;
branches;
next	1.67;

1.67
date	2005.09.29.15.39.41;	author niallo;	state Exp;
branches;
next	1.66;

1.66
date	2005.09.29.15.29.20;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2005.09.19.15.47.14;	author niallo;	state Exp;
branches;
next	1.64;

1.64
date	2005.09.18.15.27.38;	author niallo;	state Exp;
branches;
next	1.63;

1.63
date	2005.09.18.06.19.10;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2005.09.18.00.33.40;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.17.23.47.17;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2005.09.05.19.25.00;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.14.19.49.18;	author xsa;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.11.14.10.20;	author xsa;	state Exp;
branches;
next	1.57;

1.57
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.25.21.59.16;	author jfb;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.25.21.32.31;	author jfb;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.25.08.00.03;	author jfb;	state Exp;
branches;
next	1.51;

1.51
date	2005.05.25.07.15.16;	author jfb;	state Exp;
branches;
next	1.50;

1.50
date	2005.05.25.06.42.41;	author jfb;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.20.23.11.30;	author jfb;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.19.19.30.18;	author jfb;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.19.19.22.31;	author jfb;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.12.14.40.19;	author jfb;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.11.20.32.56;	author jfb;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.11.19.36.46;	author jfb;	state Exp;
branches;
next	1.43;

1.43
date	2005.04.07.22.08.57;	author jfb;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.07.20.50.22;	author jfb;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.07.16.47.11;	author jfb;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.06.19.12.08;	author jfb;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.06.18.51.29;	author joris;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.06.17.09.05;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.26.08.09.54;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.13.22.50.34;	author jfb;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.13.22.07.49;	author jfb;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.13.21.47.04;	author jfb;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.05.18.25.30;	author jfb;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.05.05.58.39;	author jfb;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.05.05.02.15;	author jfb;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.05.03.30.29;	author jfb;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.04.18.21.00;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.03.21.02.23;	author jfb;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.02.04.19.34;	author jfb;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.27.00.22.08;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.25.20.32.48;	author jfb;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.16.19.45.59;	author jfb;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.24.20.43.12;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.14.00.47.44;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.13.20.50.57;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.12.19.23.27;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.18.17.20.40;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.17.21.13.58;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.16.18.55.52;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.16.17.16.18;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.27.15.33.44;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.27.14.36.15;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.25.11.06.50;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.16.15.02.21;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.12.21.02.20;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.02.22.59.58;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.14.20.07.28;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.14.19.40.10;	author vincent;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.14.19.22.43;	author vincent;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.14.14.09.17;	author vincent;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.14.05.13.06;	author vincent;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.02.33.40;	author vincent;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.318
log
@Use xasprintf() instead of calloc() + strlcpy() + memcpy() to
generate the log line.  Fixes a clang warning about using the wrong
size argument in strlcpy().  The existing code was safe but not
good strlcpy() practice.  OK otto@@
@
text
@/*	$OpenBSD: rcs.c,v 1.317 2017/05/31 16:31:55 joris Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <libgen.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"
#include "cvs.h"
#include "diff.h"
#include "rcs.h"
#include "rcsparse.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#define RCS_KWEXP_SIZE  1024

#define ANNOTATE_NEVER	0
#define ANNOTATE_NOW	1
#define ANNOTATE_LATER	2

/* invalid characters in RCS symbol names */
static const char rcs_sym_invch[] = RCS_SYM_INVALCHAR;

/* comment leaders, depending on the file's suffix */
static const struct rcs_comment {
	const char	*rc_suffix;
	const char	*rc_cstr;
} rcs_comments[] = {
	{ "1",    ".\\\" " },
	{ "2",    ".\\\" " },
	{ "3",    ".\\\" " },
	{ "4",    ".\\\" " },
	{ "5",    ".\\\" " },
	{ "6",    ".\\\" " },
	{ "7",    ".\\\" " },
	{ "8",    ".\\\" " },
	{ "9",    ".\\\" " },
	{ "a",    "-- "    },	/* Ada		 */
	{ "ada",  "-- "    },
	{ "adb",  "-- "    },
	{ "asm",  ";; "    },	/* assembler (MS-DOS) */
	{ "ads",  "-- "    },	/* Ada */
	{ "bat",  ":: "    },	/* batch (MS-DOS) */
	{ "body", "-- "    },	/* Ada */
	{ "c",    " * "    },	/* C */
	{ "c++",  "// "    },	/* C++ */
	{ "cc",   "// "    },
	{ "cpp",  "// "    },
	{ "cxx",  "// "    },
	{ "m",    "// "    },	/* Objective-C */
	{ "cl",   ";;; "   },	/* Common Lisp	 */
	{ "cmd",  ":: "    },	/* command (OS/2) */
	{ "cmf",  "c "     },	/* CM Fortran	 */
	{ "csh",  "# "     },	/* shell	 */
	{ "e",    "# "     },	/* efl		 */
	{ "epsf", "% "     },	/* encapsulated postscript */
	{ "epsi", "% "     },	/* encapsulated postscript */
	{ "el",   "; "     },	/* Emacs Lisp	 */
	{ "f",    "c "     },	/* Fortran	 */
	{ "for",  "c "     },
	{ "h",    " * "    },	/* C-header	 */
	{ "hh",   "// "    },	/* C++ header	 */
	{ "hpp",  "// "    },
	{ "hxx",  "// "    },
	{ "in",   "# "     },	/* for Makefile.in */
	{ "l",    " * "    },	/* lex */
	{ "mac",  ";; "    },	/* macro (DEC-10, MS-DOS, PDP-11, VMS, etc) */
	{ "mak",  "# "     },	/* makefile, e.g. Visual C++ */
	{ "me",   ".\\\" " },	/* me-macros	t/nroff	 */
	{ "ml",   "; "     },	/* mocklisp	 */
	{ "mm",   ".\\\" " },	/* mm-macros	t/nroff	 */
	{ "ms",   ".\\\" " },	/* ms-macros	t/nroff	 */
	{ "man",  ".\\\" " },	/* man-macros	t/nroff	 */
	{ "p",    " * "    },	/* pascal	 */
	{ "pas",  " * "    },
	{ "pl",   "# "     },	/* Perl	(conflict with Prolog) */
	{ "pm",   "# "     },	/* Perl	module */
	{ "ps",   "% "     },	/* postscript */
	{ "psw",  "% "     },	/* postscript wrap */
	{ "pswm", "% "     },	/* postscript wrap */
	{ "r",    "# "     },	/* ratfor	 */
	{ "rc",   " * "    },	/* Microsoft Windows resource file */
	{ "red",  "% "     },	/* psl/rlisp	 */
	{ "sh",   "# "     },	/* shell	 */
	{ "sl",   "% "     },	/* psl		 */
	{ "spec", "-- "    },	/* Ada		 */
	{ "tex",  "% "     },	/* tex		 */
	{ "y",    " * "    },	/* yacc		 */
	{ "ye",   " * "    },	/* yacc-efl	 */
	{ "yr",   " * "    },	/* yacc-ratfor	 */
};

struct rcs_kw rcs_expkw[] =  {
	{ "Author",	RCS_KW_AUTHOR   },
	{ "Date",	RCS_KW_DATE     },
	{ "Header",	RCS_KW_HEADER   },
	{ "Id",		RCS_KW_ID       },
	{ "Locker",	RCS_KW_LOCKER	},
	{ "Log",	RCS_KW_LOG      },
	{ "Name",	RCS_KW_NAME     },
	{ "RCSfile",	RCS_KW_RCSFILE  },
	{ "Revision",	RCS_KW_REVISION },
	{ "Source",	RCS_KW_SOURCE   },
	{ "State",	RCS_KW_STATE    },
	{ "Mdocdate",	RCS_KW_MDOCDATE },
};

#define NB_COMTYPES	(sizeof(rcs_comments)/sizeof(rcs_comments[0]))

static RCSNUM	*rcs_get_revision(const char *, RCSFILE *);
int		rcs_patch_lines(struct rcs_lines *, struct rcs_lines *,
		    struct rcs_line **, struct rcs_delta *);
static void	rcs_freedelta(struct rcs_delta *);
static void	rcs_strprint(const u_char *, size_t, FILE *);

static void	rcs_kwexp_line(char *, struct rcs_delta *, struct rcs_lines *,
		    struct rcs_line *, int mode);

/*
 * Prepare RCSFILE for parsing. The given file descriptor (if any) must be
 * read-only and is closed on rcs_close().
 */
RCSFILE *
rcs_open(const char *path, int fd, int flags, ...)
{
	int mode;
	mode_t fmode;
	RCSFILE *rfp;
	va_list vap;
	struct stat st;
	struct rcs_delta *rdp;
	struct rcs_lock *lkr;

	fmode = S_IRUSR|S_IRGRP|S_IROTH;
	flags &= 0xffff;	/* ditch any internal flags */

	if (flags & RCS_CREATE) {
		va_start(vap, flags);
		mode = va_arg(vap, int);
		va_end(vap);
		fmode = (mode_t)mode;
	} else {
		if (fstat(fd, &st) == -1)
			fatal("rcs_open: %s: fstat: %s", path, strerror(errno));
		fmode = st.st_mode;
	}

	fmode &= ~cvs_umask;

	rfp = xcalloc(1, sizeof(*rfp));

	rfp->rf_path = xstrdup(path);
	rfp->rf_flags = flags | RCS_SLOCK | RCS_SYNCED;
	rfp->rf_mode = fmode;
	if (fd == -1)
		rfp->rf_file = NULL;
	else if ((rfp->rf_file = fdopen(fd, "r")) == NULL)
		fatal("rcs_open: %s: fdopen: %s", path, strerror(errno));
	rfp->rf_dead = 0;

	TAILQ_INIT(&(rfp->rf_delta));
	TAILQ_INIT(&(rfp->rf_access));
	TAILQ_INIT(&(rfp->rf_symbols));
	TAILQ_INIT(&(rfp->rf_locks));

	if (!(rfp->rf_flags & RCS_CREATE)) {
		if (rcsparse_init(rfp))
			fatal("could not parse admin data");
	}

	/* fill in rd_locker */
	TAILQ_FOREACH(lkr, &(rfp->rf_locks), rl_list) {
		if ((rdp = rcs_findrev(rfp, lkr->rl_num)) == NULL) {
			rcs_close(rfp);
			return (NULL);
		}

		rdp->rd_locker = xstrdup(lkr->rl_name);
	}

	return (rfp);
}

/*
 * rcs_close()
 *
 * Close an RCS file handle.
 */
void
rcs_close(RCSFILE *rfp)
{
	struct rcs_delta *rdp;
	struct rcs_access *rap;
	struct rcs_lock *rlp;
	struct rcs_sym *rsp;

	if ((rfp->rf_flags & RCS_WRITE) && !(rfp->rf_flags & RCS_SYNCED))
		rcs_write(rfp);

	while (!TAILQ_EMPTY(&(rfp->rf_delta))) {
		rdp = TAILQ_FIRST(&(rfp->rf_delta));
		TAILQ_REMOVE(&(rfp->rf_delta), rdp, rd_list);
		rcs_freedelta(rdp);
	}

	while (!TAILQ_EMPTY(&(rfp->rf_access))) {
		rap = TAILQ_FIRST(&(rfp->rf_access));
		TAILQ_REMOVE(&(rfp->rf_access), rap, ra_list);
		free(rap->ra_name);
		free(rap);
	}

	while (!TAILQ_EMPTY(&(rfp->rf_symbols))) {
		rsp = TAILQ_FIRST(&(rfp->rf_symbols));
		TAILQ_REMOVE(&(rfp->rf_symbols), rsp, rs_list);
		free(rsp->rs_num);
		free(rsp->rs_name);
		free(rsp);
	}

	while (!TAILQ_EMPTY(&(rfp->rf_locks))) {
		rlp = TAILQ_FIRST(&(rfp->rf_locks));
		TAILQ_REMOVE(&(rfp->rf_locks), rlp, rl_list);
		free(rlp->rl_num);
		free(rlp->rl_name);
		free(rlp);
	}

	free(rfp->rf_head);
	free(rfp->rf_branch);

	if (rfp->rf_file != NULL)
		fclose(rfp->rf_file);
	free(rfp->rf_path);
	free(rfp->rf_comment);
	free(rfp->rf_expand);
	free(rfp->rf_desc);
	if (rfp->rf_pdata != NULL)
		rcsparse_free(rfp);
	free(rfp);
}

/*
 * rcs_write()
 *
 * Write the contents of the RCS file handle <rfp> to disk in the file whose
 * path is in <rf_path>.
 */
void
rcs_write(RCSFILE *rfp)
{
	FILE *fp;
	char   numbuf[CVS_REV_BUFSZ], *fn, tmpdir[PATH_MAX];
	struct rcs_access *ap;
	struct rcs_sym *symp;
	struct rcs_branch *brp;
	struct rcs_delta *rdp;
	struct rcs_lock *lkp;
	size_t len;
	int fd, saved_errno;

	fd = -1;

	if (rfp->rf_flags & RCS_SYNCED)
		return;

	if (cvs_noexec == 1)
		return;

	/* Write operations need the whole file parsed */
	if (rcsparse_deltatexts(rfp, NULL))
		fatal("rcs_write: rcsparse_deltatexts");

	if (strlcpy(tmpdir, rfp->rf_path, sizeof(tmpdir)) >= sizeof(tmpdir))
		fatal("rcs_write: truncation");
	(void)xasprintf(&fn, "%s/rcs.XXXXXXXXXX", dirname(tmpdir));

	if ((fd = mkstemp(fn)) == -1)
		fatal("%s", fn);

	if ((fp = fdopen(fd, "w")) == NULL) {
		saved_errno = errno;
		(void)unlink(fn);
		fatal("fdopen %s: %s", fn, strerror(saved_errno));
	}

	worklist_add(fn, &temp_files);

	if (rfp->rf_head != NULL)
		rcsnum_tostr(rfp->rf_head, numbuf, sizeof(numbuf));
	else
		numbuf[0] = '\0';

	fprintf(fp, "head\t%s;\n", numbuf);

	if (rfp->rf_branch != NULL) {
		rcsnum_tostr(rfp->rf_branch, numbuf, sizeof(numbuf));
		fprintf(fp, "branch\t%s;\n", numbuf);
	}

	fputs("access", fp);
	TAILQ_FOREACH(ap, &(rfp->rf_access), ra_list) {
		fprintf(fp, "\n\t%s", ap->ra_name);
	}
	fputs(";\n", fp);

	fprintf(fp, "symbols");
	TAILQ_FOREACH(symp, &(rfp->rf_symbols), rs_list) {
		if (RCSNUM_ISBRANCH(symp->rs_num))
			rcsnum_addmagic(symp->rs_num);
		rcsnum_tostr(symp->rs_num, numbuf, sizeof(numbuf));
		fprintf(fp, "\n\t%s:%s", symp->rs_name, numbuf);
	}
	fprintf(fp, ";\n");

	fprintf(fp, "locks");
	TAILQ_FOREACH(lkp, &(rfp->rf_locks), rl_list) {
		rcsnum_tostr(lkp->rl_num, numbuf, sizeof(numbuf));
		fprintf(fp, "\n\t%s:%s", lkp->rl_name, numbuf);
	}

	fprintf(fp, ";");

	if (rfp->rf_flags & RCS_SLOCK)
		fprintf(fp, " strict;");
	fputc('\n', fp);

	fputs("comment\t@@", fp);
	if (rfp->rf_comment != NULL) {
		rcs_strprint((const u_char *)rfp->rf_comment,
		    strlen(rfp->rf_comment), fp);
		fputs("@@;\n", fp);
	} else
		fputs("# @@;\n", fp);

	if (rfp->rf_expand != NULL) {
		fputs("expand @@", fp);
		rcs_strprint((const u_char *)rfp->rf_expand,
		    strlen(rfp->rf_expand), fp);
		fputs("@@;\n", fp);
	}

	fputs("\n\n", fp);

	TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
		fprintf(fp, "%s\n", rcsnum_tostr(rdp->rd_num, numbuf,
		    sizeof(numbuf)));
		fprintf(fp, "date\t%d.%02d.%02d.%02d.%02d.%02d;",
		    rdp->rd_date.tm_year + 1900, rdp->rd_date.tm_mon + 1,
		    rdp->rd_date.tm_mday, rdp->rd_date.tm_hour,
		    rdp->rd_date.tm_min, rdp->rd_date.tm_sec);
		fprintf(fp, "\tauthor %s;\tstate %s;\n",
		    rdp->rd_author, rdp->rd_state);
		fputs("branches", fp);
		TAILQ_FOREACH(brp, &(rdp->rd_branches), rb_list) {
			fprintf(fp, "\n\t%s", rcsnum_tostr(brp->rb_num, numbuf,
			    sizeof(numbuf)));
		}
		fputs(";\n", fp);
		fprintf(fp, "next\t%s;\n\n", rcsnum_tostr(rdp->rd_next,
		    numbuf, sizeof(numbuf)));
	}

	fputs("\ndesc\n@@", fp);
	if (rfp->rf_desc != NULL && (len = strlen(rfp->rf_desc)) > 0) {
		rcs_strprint((const u_char *)rfp->rf_desc, len, fp);
		if (rfp->rf_desc[len-1] != '\n')
			fputc('\n', fp);
	}
	fputs("@@\n", fp);

	/* deltatexts */
	TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
		fprintf(fp, "\n\n%s\n", rcsnum_tostr(rdp->rd_num, numbuf,
		    sizeof(numbuf)));
		fputs("log\n@@", fp);
		if (rdp->rd_log != NULL) {
			len = strlen(rdp->rd_log);
			rcs_strprint((const u_char *)rdp->rd_log, len, fp);
			if (len == 0 || rdp->rd_log[len-1] != '\n')
				fputc('\n', fp);
		}
		fputs("@@\ntext\n@@", fp);
		if (rdp->rd_text != NULL)
			rcs_strprint(rdp->rd_text, rdp->rd_tlen, fp);
		fputs("@@\n", fp);
	}

	if (fchmod(fd, rfp->rf_mode) == -1) {
		saved_errno = errno;
		(void)unlink(fn);
		fatal("fchmod %s: %s", fn, strerror(saved_errno));
	}

	(void)fclose(fp);

	if (rename(fn, rfp->rf_path) == -1) {
		saved_errno = errno;
		(void)unlink(fn);
		fatal("rename(%s, %s): %s", fn, rfp->rf_path,
		    strerror(saved_errno));
	}

	rfp->rf_flags |= RCS_SYNCED;
	free(fn);
}

/*
 * rcs_head_get()
 *
 * Retrieve the revision number of the head revision for the RCS file <file>.
 */
RCSNUM *
rcs_head_get(RCSFILE *file)
{
	struct rcs_branch *brp;
	struct rcs_delta *rdp;
	RCSNUM *rev, *rootrev;

	if (file->rf_head == NULL)
		return NULL;

	rev = rcsnum_alloc();
	if (file->rf_branch != NULL) {
		/* we have a default branch, use that to calculate the
		 * real HEAD*/
		rootrev = rcsnum_alloc();
		rcsnum_cpy(file->rf_branch, rootrev,
		    file->rf_branch->rn_len - 1);
		if ((rdp = rcs_findrev(file, rootrev)) == NULL)
			fatal("rcs_head_get: could not find root revision");

		/* HEAD should be the last revision on the default branch */
		TAILQ_FOREACH(brp, &(rdp->rd_branches), rb_list) {
			if (rcsnum_cmp(brp->rb_num, file->rf_branch,
			    file->rf_branch->rn_len) == 0)
				break;
		}
		free(rootrev);

		if (brp == NULL)
			fatal("rcs_head_get: could not find first default "
			    "branch revision");

		if ((rdp = rcs_findrev(file, brp->rb_num)) == NULL)
			fatal("rcs_head_get: could not find branch revision");
		while (rdp->rd_next->rn_len != 0)
			if ((rdp = rcs_findrev(file, rdp->rd_next)) == NULL)
				fatal("rcs_head_get: could not find "
				    "next branch revision");

		rcsnum_cpy(rdp->rd_num, rev, 0);
	} else {
		rcsnum_cpy(file->rf_head, rev, 0);
	}

	return (rev);
}

/*
 * rcs_head_set()
 *
 * Set the revision number of the head revision for the RCS file <file> to
 * <rev>, which must reference a valid revision within the file.
 */
int
rcs_head_set(RCSFILE *file, RCSNUM *rev)
{
	if (rcs_findrev(file, rev) == NULL)
		return (-1);

	if (file->rf_head == NULL)
		file->rf_head = rcsnum_alloc();

	rcsnum_cpy(rev, file->rf_head, 0);
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_branch_new()
 *
 * Create a new branch out of supplied revision for the RCS file <file>.
 */
RCSNUM *
rcs_branch_new(RCSFILE *file, RCSNUM *rev)
{
	RCSNUM *brev;
	struct rcs_sym *sym;

	if ((brev = rcsnum_new_branch(rev)) == NULL)
		return (NULL);

	for (;;) {
		TAILQ_FOREACH(sym, &(file->rf_symbols), rs_list)
			if (!rcsnum_cmp(sym->rs_num, brev, 0))
				break;

		if (sym == NULL)
			break;

		if (rcsnum_inc(brev) == NULL ||
		    rcsnum_inc(brev) == NULL) {
			free(brev);
			return (NULL);
		}
	}

	return (brev);
}

/*
 * rcs_branch_get()
 *
 * Retrieve the default branch number for the RCS file <file>.
 * Returns the number on success.  If NULL is returned, then there is no
 * default branch for this file.
 */
const RCSNUM *
rcs_branch_get(RCSFILE *file)
{
	return (file->rf_branch);
}

/*
 * rcs_branch_set()
 *
 * Set the default branch for the RCS file <file> to <bnum>.
 * Returns 0 on success, -1 on failure.
 */
int
rcs_branch_set(RCSFILE *file, const RCSNUM *bnum)
{
	if (file->rf_branch == NULL)
		file->rf_branch = rcsnum_alloc();

	rcsnum_cpy(bnum, file->rf_branch, 0);
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_access_add()
 *
 * Add the login name <login> to the access list for the RCS file <file>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_access_add(RCSFILE *file, const char *login)
{
	struct rcs_access *ap;

	/* first look for duplication */
	TAILQ_FOREACH(ap, &(file->rf_access), ra_list) {
		if (strcmp(ap->ra_name, login) == 0)
			return (-1);
	}

	ap = xmalloc(sizeof(*ap));
	ap->ra_name = xstrdup(login);
	TAILQ_INSERT_TAIL(&(file->rf_access), ap, ra_list);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_access_remove()
 *
 * Remove an entry with login name <login> from the access list of the RCS
 * file <file>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_access_remove(RCSFILE *file, const char *login)
{
	struct rcs_access *ap;

	TAILQ_FOREACH(ap, &(file->rf_access), ra_list)
		if (strcmp(ap->ra_name, login) == 0)
			break;

	if (ap == NULL)
		return (-1);

	TAILQ_REMOVE(&(file->rf_access), ap, ra_list);
	free(ap->ra_name);
	free(ap);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_sym_add()
 *
 * Add a symbol to the list of symbols for the RCS file <rfp>.  The new symbol
 * is named <sym> and is bound to the RCS revision <snum>.
 */
int
rcs_sym_add(RCSFILE *rfp, const char *sym, RCSNUM *snum)
{
	struct rcs_sym *symp;

	if (!rcs_sym_check(sym))
		return (-1);

	/* first look for duplication */
	TAILQ_FOREACH(symp, &(rfp->rf_symbols), rs_list) {
		if (strcmp(symp->rs_name, sym) == 0)
			return (1);
	}

	symp = xmalloc(sizeof(*symp));
	symp->rs_name = xstrdup(sym);
	symp->rs_num = rcsnum_alloc();
	rcsnum_cpy(snum, symp->rs_num, 0);

	TAILQ_INSERT_HEAD(&(rfp->rf_symbols), symp, rs_list);

	/* not synced anymore */
	rfp->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_sym_remove()
 *
 * Remove the symbol with name <sym> from the symbol list for the RCS file
 * <file>.  If no such symbol is found, the call fails and returns with an
 * error.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_sym_remove(RCSFILE *file, const char *sym)
{
	struct rcs_sym *symp;

	if (!rcs_sym_check(sym))
		return (-1);

	TAILQ_FOREACH(symp, &(file->rf_symbols), rs_list)
		if (strcmp(symp->rs_name, sym) == 0)
			break;

	if (symp == NULL)
		return (-1);

	TAILQ_REMOVE(&(file->rf_symbols), symp, rs_list);
	free(symp->rs_name);
	free(symp->rs_num);
	free(symp);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_sym_get()
 *
 * Find a specific symbol <sym> entry in the tree of the RCS file <file>.
 *
 * Returns a pointer to the symbol on success, or NULL on failure.
 */
struct rcs_sym *
rcs_sym_get(RCSFILE *file, const char *sym)
{
	struct rcs_sym *symp;

	TAILQ_FOREACH(symp, &(file->rf_symbols), rs_list)
		if (strcmp(symp->rs_name, sym) == 0)
			return (symp);

	return (NULL);
}

/*
 * rcs_sym_getrev()
 *
 * Retrieve the RCS revision number associated with the symbol <sym> for the
 * RCS file <file>.  The returned value is a dynamically-allocated copy and
 * should be freed by the caller once they are done with it.
 * Returns the RCSNUM on success, or NULL on failure.
 */
RCSNUM *
rcs_sym_getrev(RCSFILE *file, const char *sym)
{
	RCSNUM *num;
	struct rcs_sym *symp;

	if (!rcs_sym_check(sym) || file->rf_head == NULL)
		return (NULL);

	if (!strcmp(sym, RCS_HEAD_BRANCH)) {
		num = rcsnum_alloc();
		rcsnum_cpy(file->rf_head, num, 0);
		return (num);
	}

	num = NULL;
	TAILQ_FOREACH(symp, &(file->rf_symbols), rs_list)
		if (strcmp(symp->rs_name, sym) == 0)
			break;

	if (symp != NULL) {
		num = rcsnum_alloc();
		rcsnum_cpy(symp->rs_num, num, 0);
	}

	return (num);
}

/*
 * rcs_sym_check()
 *
 * Check the RCS symbol name <sym> for any unsupported characters.
 * Returns 1 if the tag is correct, 0 if it isn't valid.
 */
int
rcs_sym_check(const char *sym)
{
	int ret;
	const unsigned char *cp;

	ret = 1;
	cp = sym;
	if (!isalpha(*cp++))
		return (0);

	for (; *cp != '\0'; cp++)
		if (!isgraph(*cp) || (strchr(rcs_sym_invch, *cp) != NULL)) {
			ret = 0;
			break;
		}

	return (ret);
}

/*
 * rcs_lock_getmode()
 *
 * Retrieve the locking mode of the RCS file <file>.
 */
int
rcs_lock_getmode(RCSFILE *file)
{
	return (file->rf_flags & RCS_SLOCK) ? RCS_LOCK_STRICT : RCS_LOCK_LOOSE;
}

/*
 * rcs_lock_setmode()
 *
 * Set the locking mode of the RCS file <file> to <mode>, which must either
 * be RCS_LOCK_LOOSE or RCS_LOCK_STRICT.
 * Returns the previous mode on success, or -1 on failure.
 */
int
rcs_lock_setmode(RCSFILE *file, int mode)
{
	int pmode;
	pmode = rcs_lock_getmode(file);

	if (mode == RCS_LOCK_STRICT)
		file->rf_flags |= RCS_SLOCK;
	else if (mode == RCS_LOCK_LOOSE)
		file->rf_flags &= ~RCS_SLOCK;
	else
		fatal("rcs_lock_setmode: invalid mode `%d'", mode);

	file->rf_flags &= ~RCS_SYNCED;
	return (pmode);
}

/*
 * rcs_lock_add()
 *
 * Add an RCS lock for the user <user> on revision <rev>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_lock_add(RCSFILE *file, const char *user, RCSNUM *rev)
{
	struct rcs_lock *lkp;

	/* first look for duplication */
	TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list) {
		if (strcmp(lkp->rl_name, user) == 0 &&
		    rcsnum_cmp(rev, lkp->rl_num, 0) == 0)
			return (-1);
	}

	lkp = xmalloc(sizeof(*lkp));
	lkp->rl_name = xstrdup(user);
	lkp->rl_num = rcsnum_alloc();
	rcsnum_cpy(rev, lkp->rl_num, 0);

	TAILQ_INSERT_TAIL(&(file->rf_locks), lkp, rl_list);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}


/*
 * rcs_lock_remove()
 *
 * Remove the RCS lock on revision <rev>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_lock_remove(RCSFILE *file, const char *user, RCSNUM *rev)
{
	struct rcs_lock *lkp;

	TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list) {
		if (strcmp(lkp->rl_name, user) == 0 &&
		    rcsnum_cmp(lkp->rl_num, rev, 0) == 0)
			break;
	}

	if (lkp == NULL)
		return (-1);

	TAILQ_REMOVE(&(file->rf_locks), lkp, rl_list);
	free(lkp->rl_num);
	free(lkp->rl_name);
	free(lkp);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_desc_get()
 *
 * Retrieve the description for the RCS file <file>.
 */
const char *
rcs_desc_get(RCSFILE *file)
{
	return (file->rf_desc);
}

/*
 * rcs_desc_set()
 *
 * Set the description for the RCS file <file>.
 */
void
rcs_desc_set(RCSFILE *file, const char *desc)
{
	char *tmp;

	tmp = xstrdup(desc);
	free(file->rf_desc);
	file->rf_desc = tmp;
	file->rf_flags &= ~RCS_SYNCED;
}

/*
 * rcs_comment_lookup()
 *
 * Lookup the assumed comment leader based on a file's suffix.
 * Returns a pointer to the string on success, or NULL on failure.
 */
const char *
rcs_comment_lookup(const char *filename)
{
	int i;
	const char *sp;

	if ((sp = strrchr(filename, '.')) == NULL)
		return (NULL);
	sp++;

	for (i = 0; i < (int)NB_COMTYPES; i++)
		if (strcmp(rcs_comments[i].rc_suffix, sp) == 0)
			return (rcs_comments[i].rc_cstr);
	return (NULL);
}

/*
 * rcs_comment_get()
 *
 * Retrieve the comment leader for the RCS file <file>.
 */
const char *
rcs_comment_get(RCSFILE *file)
{
	return (file->rf_comment);
}

/*
 * rcs_comment_set()
 *
 * Set the comment leader for the RCS file <file>.
 */
void
rcs_comment_set(RCSFILE *file, const char *comment)
{
	char *tmp;

	tmp = xstrdup(comment);
	free(file->rf_comment);
	file->rf_comment = tmp;
	file->rf_flags &= ~RCS_SYNCED;
}

int
rcs_patch_lines(struct rcs_lines *dlines, struct rcs_lines *plines,
    struct rcs_line **alines, struct rcs_delta *rdp)
{
	u_char op;
	char *ep;
	struct rcs_line *lp, *dlp, *ndlp;
	int i, lineno, nbln;
	u_char tmp;

	dlp = TAILQ_FIRST(&(dlines->l_lines));
	lp = TAILQ_FIRST(&(plines->l_lines));

	/* skip first bogus line */
	for (lp = TAILQ_NEXT(lp, l_list); lp != NULL;
	    lp = TAILQ_NEXT(lp, l_list)) {
		if (lp->l_len < 2)
			fatal("line too short, RCS patch seems broken");
		op = *(lp->l_line);
		/* NUL-terminate line buffer for strtol() safety. */
		tmp = lp->l_line[lp->l_len - 1];
		lp->l_line[lp->l_len - 1] = '\0';
		lineno = (int)strtol((char*)(lp->l_line + 1), &ep, 10);
		if (lineno - 1 > dlines->l_nblines || lineno < 0) {
			fatal("invalid line specification in RCS patch");
		}
		ep++;
		nbln = (int)strtol(ep, &ep, 10);
		/* Restore the last byte of the buffer */
		lp->l_line[lp->l_len - 1] = tmp;
		if (nbln < 0)
			fatal("invalid line number specification in RCS patch");

		/* find the appropriate line */
		for (;;) {
			if (dlp == NULL)
				break;
			if (dlp->l_lineno == lineno)
				break;
			if (dlp->l_lineno > lineno) {
				dlp = TAILQ_PREV(dlp, tqh, l_list);
			} else if (dlp->l_lineno < lineno) {
				if (((ndlp = TAILQ_NEXT(dlp, l_list)) == NULL) ||
				    ndlp->l_lineno > lineno)
					break;
				dlp = ndlp;
			}
		}
		if (dlp == NULL)
			fatal("can't find referenced line in RCS patch");

		if (op == 'd') {
			for (i = 0; (i < nbln) && (dlp != NULL); i++) {
				ndlp = TAILQ_NEXT(dlp, l_list);
				TAILQ_REMOVE(&(dlines->l_lines), dlp, l_list);
				if (alines != NULL && dlp->l_line != NULL) {
					dlp->l_delta = rdp;
					alines[dlp->l_lineno_orig - 1] =
						dlp;
				} else
					free(dlp);
				dlp = ndlp;
				/* last line is gone - reset dlp */
				if (dlp == NULL) {
					ndlp = TAILQ_LAST(&(dlines->l_lines),
					    tqh);
					dlp = ndlp;
				}
			}
		} else if (op == 'a') {
			for (i = 0; i < nbln; i++) {
				ndlp = lp;
				lp = TAILQ_NEXT(lp, l_list);
				if (lp == NULL)
					fatal("truncated RCS patch");
				TAILQ_REMOVE(&(plines->l_lines), lp, l_list);
				if (alines != NULL) {
					if (lp->l_needsfree == 1)
						free(lp->l_line);
					lp->l_line = NULL;
					lp->l_needsfree = 0;
				}
				lp->l_delta = rdp;
				TAILQ_INSERT_AFTER(&(dlines->l_lines), dlp,
				    lp, l_list);
				dlp = lp;

				/* we don't want lookup to block on those */
				lp->l_lineno = lineno;

				lp = ndlp;
			}
		} else
			fatal("unknown RCS patch operation `%c'", op);

		/* last line of the patch, done */
		if (lp->l_lineno == plines->l_nblines)
			break;
	}

	/* once we're done patching, rebuild the line numbers */
	lineno = 0;
	TAILQ_FOREACH(lp, &(dlines->l_lines), l_list)
		lp->l_lineno = lineno++;
	dlines->l_nblines = lineno - 1;

	return (0);
}

void
rcs_delta_stats(struct rcs_delta *rdp, int *ladded, int *lremoved)
{
	struct rcs_lines *plines;
	struct rcs_line *lp;
	int added, i, nbln, removed;
	char op, *ep;
	u_char tmp;

	added = removed = 0;

	plines = cvs_splitlines(rdp->rd_text, rdp->rd_tlen);
	lp = TAILQ_FIRST(&(plines->l_lines));

	/* skip first bogus line */
	for (lp = TAILQ_NEXT(lp, l_list); lp != NULL;
	    lp = TAILQ_NEXT(lp, l_list)) {
		if (lp->l_len < 2)
			fatal("line too short, RCS patch seems broken");
		op = *(lp->l_line);
		/* NUL-terminate line buffer for strtol() safety. */
		tmp = lp->l_line[lp->l_len - 1];
		lp->l_line[lp->l_len - 1] = '\0';
		(void)strtol((lp->l_line + 1), &ep, 10);
		ep++;
		nbln = (int)strtol(ep, &ep, 10);
		/* Restore the last byte of the buffer */
		lp->l_line[lp->l_len - 1] = tmp;
		if (nbln < 0)
			fatal("invalid line number specification in RCS patch");

		if (op == 'a') {
			added += nbln;
			for (i = 0; i < nbln; i++) {
				lp = TAILQ_NEXT(lp, l_list);
				if (lp == NULL)
					fatal("truncated RCS patch");
			}
		}
		else if (op == 'd')
			removed += nbln;
		else
			fatal("unknown RCS patch operation '%c'", op);
	}

	cvs_freelines(plines);

	*ladded = added;
	*lremoved = removed;
}

/*
 * rcs_rev_add()
 *
 * Add a revision to the RCS file <rf>.  The new revision's number can be
 * specified in <rev> (which can also be RCS_HEAD_REV, in which case the
 * new revision will have a number equal to the previous head revision plus
 * one).  The <msg> argument specifies the log message for that revision, and
 * <date> specifies the revision's date (a value of -1 is
 * equivalent to using the current time).
 * If <author> is NULL, set the author for this revision to the current user.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_rev_add(RCSFILE *rf, RCSNUM *rev, const char *msg, time_t date,
    const char *author)
{
	time_t now;
	RCSNUM *root = NULL;
	struct passwd *pw;
	struct rcs_branch *brp, *obrp;
	struct rcs_delta *ordp, *rdp;

	if (rev == RCS_HEAD_REV) {
		if (rf->rf_flags & RCS_CREATE) {
			if ((rev = rcsnum_parse(RCS_HEAD_INIT)) == NULL)
				return (-1);
			free(rf->rf_head);
			rf->rf_head = rev;
		} else if (rf->rf_head == NULL) {
			return (-1);
		} else {
			rev = rcsnum_inc(rf->rf_head);
		}
	} else {
		if ((rdp = rcs_findrev(rf, rev)) != NULL)
			return (-1);
	}

	rdp = xcalloc(1, sizeof(*rdp));

	TAILQ_INIT(&(rdp->rd_branches));

	rdp->rd_num = rcsnum_alloc();
	rcsnum_cpy(rev, rdp->rd_num, 0);

	rdp->rd_next = rcsnum_alloc();

	if (!author && !(author = getlogin())) {
		if (!(pw = getpwuid(getuid())))
			fatal("getpwuid failed");
		author = pw->pw_name;
	}
	rdp->rd_author = xstrdup(author);
	rdp->rd_state = xstrdup(RCS_STATE_EXP);
	rdp->rd_log = xstrdup(msg);

	if (date != (time_t)(-1))
		now = date;
	else
		time(&now);
	gmtime_r(&now, &(rdp->rd_date));

	if (RCSNUM_ISBRANCHREV(rev))
		TAILQ_INSERT_TAIL(&(rf->rf_delta), rdp, rd_list);
	else
		TAILQ_INSERT_HEAD(&(rf->rf_delta), rdp, rd_list);
	rf->rf_ndelta++;

	if (!(rf->rf_flags & RCS_CREATE)) {
		if (RCSNUM_ISBRANCHREV(rev)) {
			if (rev->rn_id[rev->rn_len - 1] == 1) {
				/* a new branch */
				root = rcsnum_branch_root(rev);
				brp = xmalloc(sizeof(*brp));
				brp->rb_num = rcsnum_alloc();
				rcsnum_cpy(rdp->rd_num, brp->rb_num, 0);

				if ((ordp = rcs_findrev(rf, root)) == NULL)
					fatal("root node not found");

				TAILQ_FOREACH(obrp, &(ordp->rd_branches),
				    rb_list) {
					if (!rcsnum_cmp(obrp->rb_num,
					    brp->rb_num,
					    brp->rb_num->rn_len - 1))
						break;
				}

				if (obrp == NULL) {
					TAILQ_INSERT_TAIL(&(ordp->rd_branches),
					    brp, rb_list);
				}
			} else {
				root = rcsnum_alloc();
				rcsnum_cpy(rev, root, 0);
				rcsnum_dec(root);
				if ((ordp = rcs_findrev(rf, root)) == NULL)
					fatal("previous revision not found");
				rcsnum_cpy(rdp->rd_num, ordp->rd_next, 0);
			}
		} else {
			ordp = TAILQ_NEXT(rdp, rd_list);
			rcsnum_cpy(ordp->rd_num, rdp->rd_next, 0);
		}
	}

	free(root);

	/* not synced anymore */
	rf->rf_flags &= ~RCS_SYNCED;

	return (0);
}

/*
 * rcs_rev_remove()
 *
 * Remove the revision whose number is <rev> from the RCS file <rf>.
 */
int
rcs_rev_remove(RCSFILE *rf, RCSNUM *rev)
{
	int fd1, fd2;
	char *path_tmp1, *path_tmp2;
	struct rcs_delta *rdp, *prevrdp, *nextrdp;
	BUF *prevbuf, *newdiff, *newdeltatext;

	if (rev == RCS_HEAD_REV)
		rev = rf->rf_head;

	if (rev == NULL)
		return (-1);

	/* do we actually have that revision? */
	if ((rdp = rcs_findrev(rf, rev)) == NULL)
		return (-1);

	/*
	 * This is confusing, the previous delta is next in the TAILQ list.
	 * the next delta is the previous one in the TAILQ list.
	 *
	 * When the HEAD revision got specified, nextrdp will be NULL.
	 * When the first revision got specified, prevrdp will be NULL.
	 */
	prevrdp = (struct rcs_delta *)TAILQ_NEXT(rdp, rd_list);
	nextrdp = (struct rcs_delta *)TAILQ_PREV(rdp, tqh, rd_list);

	newdeltatext = NULL;
	prevbuf = NULL;
	path_tmp1 = path_tmp2 = NULL;

	if (prevrdp != NULL && nextrdp != NULL) {
		newdiff = buf_alloc(64);

		/* calculate new diff */
		(void)xasprintf(&path_tmp1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
		fd1 = rcs_rev_write_stmp(rf, nextrdp->rd_num, path_tmp1, 0);

		(void)xasprintf(&path_tmp2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
		fd2 = rcs_rev_write_stmp(rf, prevrdp->rd_num, path_tmp2, 0);

		diff_format = D_RCSDIFF;
		if (diffreg(path_tmp1, path_tmp2,
		    fd1, fd2, newdiff, D_FORCEASCII) == D_ERROR)
			fatal("rcs_diffreg failed");

		close(fd1);
		close(fd2);

		newdeltatext = newdiff;
	} else if (nextrdp == NULL && prevrdp != NULL) {
		newdeltatext = prevbuf;
	}

	if (newdeltatext != NULL) {
		if (rcs_deltatext_set(rf, prevrdp->rd_num, newdeltatext) < 0)
			fatal("error setting new deltatext");
	}

	TAILQ_REMOVE(&(rf->rf_delta), rdp, rd_list);

	/* update pointers */
	if (prevrdp != NULL && nextrdp != NULL) {
		rcsnum_cpy(prevrdp->rd_num, nextrdp->rd_next, 0);
	} else if (prevrdp != NULL) {
		if (rcs_head_set(rf, prevrdp->rd_num) < 0)
			fatal("rcs_head_set failed");
	} else if (nextrdp != NULL) {
		free(nextrdp->rd_next);
		nextrdp->rd_next = rcsnum_alloc();
	} else {
		free(rf->rf_head);
		rf->rf_head = NULL;
	}

	rf->rf_ndelta--;
	rf->rf_flags &= ~RCS_SYNCED;

	rcs_freedelta(rdp);
	free(newdeltatext);
	free(path_tmp1);
	free(path_tmp2);

	return (0);
}

/*
 * rcs_findrev()
 *
 * Find a specific revision's delta entry in the tree of the RCS file <rfp>.
 * The revision number is given in <rev>.
 *
 * Returns a pointer to the delta on success, or NULL on failure.
 */
struct rcs_delta *
rcs_findrev(RCSFILE *rfp, RCSNUM *rev)
{
	int isbrev;
	struct rcs_delta *rdp;

	if (rev == NULL)
		return NULL;

	isbrev = RCSNUM_ISBRANCHREV(rev);

	/*
	 * We need to do more parsing if the last revision in the linked list
	 * is greater than the requested revision.
	 */
	rdp = TAILQ_LAST(&(rfp->rf_delta), rcs_dlist);
	if (rdp == NULL ||
	    (!isbrev && rcsnum_cmp(rdp->rd_num, rev, 0) == -1) ||
	    ((isbrev && rdp->rd_num->rn_len < 4) ||
	    (isbrev && rcsnum_differ(rev, rdp->rd_num)))) {
		if (rcsparse_deltas(rfp, rev))
			fatal("error parsing deltas");
	}

	TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
		if (rcsnum_differ(rdp->rd_num, rev))
			continue;
		else
			return (rdp);
	}

	return (NULL);
}

/*
 * rcs_kwexp_set()
 *
 * Set the keyword expansion mode to use on the RCS file <file> to <mode>.
 */
void
rcs_kwexp_set(RCSFILE *file, int mode)
{
	int i;
	char *tmp, buf[8] = "";

	if (RCS_KWEXP_INVAL(mode))
		return;

	i = 0;
	if (mode == RCS_KWEXP_NONE)
		buf[0] = 'b';
	else if (mode == RCS_KWEXP_OLD)
		buf[0] = 'o';
	else {
		if (mode & RCS_KWEXP_NAME)
			buf[i++] = 'k';
		if (mode & RCS_KWEXP_VAL)
			buf[i++] = 'v';
		if (mode & RCS_KWEXP_LKR)
			buf[i++] = 'l';
	}

	tmp = xstrdup(buf);
	free(file->rf_expand);
	file->rf_expand = tmp;
	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
}

/*
 * rcs_kwexp_get()
 *
 * Retrieve the keyword expansion mode to be used for the RCS file <file>.
 */
int
rcs_kwexp_get(RCSFILE *file)
{
	if (file->rf_expand == NULL)
		return (RCS_KWEXP_DEFAULT);

	return (rcs_kflag_get(file->rf_expand));
}

/*
 * rcs_kflag_get()
 *
 * Get the keyword expansion mode from a set of character flags given in
 * <flags> and return the appropriate flag mask.  In case of an error, the
 * returned mask will have the RCS_KWEXP_ERR bit set to 1.
 */
int
rcs_kflag_get(const char *flags)
{
	int fl;
	size_t len;
	const char *fp;

	if (flags == NULL || !(len = strlen(flags)))
		return (RCS_KWEXP_ERR);

	fl = 0;
	for (fp = flags; *fp != '\0'; fp++) {
		if (*fp == 'k')
			fl |= RCS_KWEXP_NAME;
		else if (*fp == 'v')
			fl |= RCS_KWEXP_VAL;
		else if (*fp == 'l')
			fl |= RCS_KWEXP_LKR;
		else if (*fp == 'o') {
			if (len != 1)
				fl |= RCS_KWEXP_ERR;
			fl |= RCS_KWEXP_OLD;
		} else if (*fp == 'b') {
			if (len != 1)
				fl |= RCS_KWEXP_ERR;
			fl |= RCS_KWEXP_NONE;
		} else	/* unknown letter */
			fl |= RCS_KWEXP_ERR;
	}

	return (fl);
}

/*
 * rcs_freedelta()
 *
 * Free the contents of a delta structure.
 */
static void
rcs_freedelta(struct rcs_delta *rdp)
{
	struct rcs_branch *rb;

	free(rdp->rd_num);
	free(rdp->rd_next);
	free(rdp->rd_author);
	free(rdp->rd_locker);
	free(rdp->rd_state);
	free(rdp->rd_log);
	free(rdp->rd_text);

	while ((rb = TAILQ_FIRST(&(rdp->rd_branches))) != NULL) {
		TAILQ_REMOVE(&(rdp->rd_branches), rb, rb_list);
		free(rb->rb_num);
		free(rb);
	}

	free(rdp);
}

/*
 * rcs_strprint()
 *
 * Output an RCS string <str> of size <slen> to the stream <stream>.  Any
 * '@@' characters are escaped.  Otherwise, the string can contain arbitrary
 * binary data.
 */
static void
rcs_strprint(const u_char *str, size_t slen, FILE *stream)
{
	const u_char *ap, *ep, *sp;

	if (slen == 0)
		return;

	ep = str + slen - 1;

	for (sp = str; sp <= ep;)  {
		ap = memchr(sp, '@@', ep - sp);
		if (ap == NULL)
			ap = ep;
		(void)fwrite(sp, sizeof(u_char), ap - sp + 1, stream);

		if (*ap == '@@')
			putc('@@', stream);
		sp = ap + 1;
	}
}

/*
 * rcs_deltatext_set()
 *
 * Set deltatext for <rev> in RCS file <rfp> to <dtext>
 * Returns -1 on error, 0 on success.
 */
int
rcs_deltatext_set(RCSFILE *rfp, RCSNUM *rev, BUF *bp)
{
	size_t len;
	u_char *dtext;
	struct rcs_delta *rdp;

	/* Write operations require full parsing */
	if (rcsparse_deltatexts(rfp, NULL))
		return (-1);

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (-1);

	free(rdp->rd_text);

	len = buf_len(bp);
	dtext = buf_release(bp);
	bp = NULL;

	if (len != 0) {
		rdp->rd_text = xmalloc(len);
		rdp->rd_tlen = len;
		(void)memcpy(rdp->rd_text, dtext, len);
	} else {
		rdp->rd_text = NULL;
		rdp->rd_tlen = 0;
	}

	free(dtext);
	return (0);
}

/*
 * rcs_rev_setlog()
 *
 * Sets the log message of revision <rev> to <logtext>.
 */
int
rcs_rev_setlog(RCSFILE *rfp, RCSNUM *rev, const char *logtext)
{
	struct rcs_delta *rdp;

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (-1);

	free(rdp->rd_log);

	rdp->rd_log = xstrdup(logtext);
	rfp->rf_flags &= ~RCS_SYNCED;
	return (0);
}
/*
 * rcs_rev_getdate()
 *
 * Get the date corresponding to a given revision.
 * Returns the date on success, -1 on failure.
 */
time_t
rcs_rev_getdate(RCSFILE *rfp, RCSNUM *rev)
{
	struct rcs_delta *rdp;

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (-1);

	return (timegm(&rdp->rd_date));
}

/*
 * rcs_state_set()
 *
 * Sets the state of revision <rev> to <state>
 * NOTE: default state is 'Exp'. States may not contain spaces.
 *
 * Returns -1 on failure, 0 on success.
 */
int
rcs_state_set(RCSFILE *rfp, RCSNUM *rev, const char *state)
{
	struct rcs_delta *rdp;

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (-1);

	free(rdp->rd_state);

	rdp->rd_state = xstrdup(state);

	rfp->rf_flags &= ~RCS_SYNCED;

	return (0);
}

/*
 * rcs_state_check()
 *
 * Check if string <state> is valid.
 *
 * Returns 0 if the string is valid, -1 otherwise.
 */
int
rcs_state_check(const char *state)
{
	if (strcmp(state, RCS_STATE_DEAD) && strcmp(state, RCS_STATE_EXP))
		return (-1);

	return (0);
}

/*
 * rcs_state_get()
 *
 * Get the state for a given revision of a specified RCSFILE.
 *
 * Returns NULL on failure.
 */
const char *
rcs_state_get(RCSFILE *rfp, RCSNUM *rev)
{
	struct rcs_delta *rdp;

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (NULL);

	return (rdp->rd_state);
}

/* rcs_get_revision() */
static RCSNUM *
rcs_get_revision(const char *revstr, RCSFILE *rfp)
{
	RCSNUM *rev, *brev, *frev;
	struct rcs_branch *brp;
	struct rcs_delta *rdp;
	size_t i;

	rdp = NULL;

	if (!strcmp(revstr, RCS_HEAD_BRANCH)) {
		if (rfp->rf_head == NULL)
			return (NULL);

		frev = rcsnum_alloc();
		rcsnum_cpy(rfp->rf_head, frev, 0);
		return (frev);
	}

	/* Possibly we could be passed a version number */
	if ((rev = rcsnum_parse(revstr)) != NULL) {
		/* Do not return if it is not in RCS file */
		if ((rdp = rcs_findrev(rfp, rev)) != NULL)
			return (rev);
	} else {
		/* More likely we will be passed a symbol */
		rev = rcs_sym_getrev(rfp, revstr);
	}

	if (rev == NULL)
		return (NULL);

	/*
	 * If it was not a branch, thats ok the symbolic
	 * name refered to a revision, so return the resolved
	 * revision for the given name. */
	if (!RCSNUM_ISBRANCH(rev)) {
		/* Sanity check: The first two elements of any
		 * revision (be it on a branch or on trunk) cannot
		 * be greater than HEAD.
		 *
		 * XXX: To avoid comparing to uninitialized memory,
		 * the minimum of both revision lengths is taken
		 * instead of just 2.
		 */
		if (rfp->rf_head == NULL || rcsnum_cmp(rev, rfp->rf_head,
		    MINIMUM(rfp->rf_head->rn_len, rev->rn_len)) < 0) {
			free(rev);
			return (NULL);
		}
		return (rev);
	}

	brev = rcsnum_alloc();
	rcsnum_cpy(rev, brev, rev->rn_len - 1);

	if ((rdp = rcs_findrev(rfp, brev)) == NULL)
		fatal("rcs_get_revision: tag `%s' does not exist", revstr);
	free(brev);

	TAILQ_FOREACH(brp, &(rdp->rd_branches), rb_list) {
		for (i = 0; i < rev->rn_len; i++)
			if (brp->rb_num->rn_id[i] != rev->rn_id[i])
				break;
		if (i != rev->rn_len)
			continue;
		break;
	}

	free(rev);
	frev = rcsnum_alloc();
	if (brp == NULL) {
		rcsnum_cpy(rdp->rd_num, frev, 0);
		return (frev);
	} else {
		/* Fetch the delta with the correct branch num */
		if ((rdp = rcs_findrev(rfp, brp->rb_num)) == NULL)
			fatal("rcs_get_revision: could not fetch branch "
			    "delta");
		rcsnum_cpy(rdp->rd_num, frev, 0);
		return (frev);
	}
}

/*
 * rcs_rev_getlines()
 *
 * Get the entire contents of revision <frev> from the RCSFILE <rfp> and
 * return it as a pointer to a struct rcs_lines.
 */
struct rcs_lines *
rcs_rev_getlines(RCSFILE *rfp, RCSNUM *frev, struct rcs_line ***alines)
{
	size_t plen;
	int annotate, done, i, nextroot;
	RCSNUM *tnum, *bnum;
	struct rcs_branch *brp;
	struct rcs_delta *hrdp, *prdp, *rdp, *trdp;
	u_char *patch;
	struct rcs_line *line, *nline;
	struct rcs_lines *dlines, *plines;

	hrdp = prdp = rdp = trdp = NULL;

	if (rfp->rf_head == NULL ||
	    (hrdp = rcs_findrev(rfp, rfp->rf_head)) == NULL)
		fatal("rcs_rev_getlines: no HEAD revision");

	tnum = frev;
	if (rcsparse_deltatexts(rfp, hrdp->rd_num))
		fatal("rcs_rev_getlines: rcsparse_deltatexts");

	/* revision on branch, get the branch root */
	nextroot = 2;
	bnum = rcsnum_alloc();
	if (RCSNUM_ISBRANCHREV(tnum))
		rcsnum_cpy(tnum, bnum, nextroot);
	else
		rcsnum_cpy(tnum, bnum, tnum->rn_len);

	if (alines != NULL) {
		/* start with annotate first at requested revision */
		annotate = ANNOTATE_LATER;
		*alines = NULL;
	} else
		annotate = ANNOTATE_NEVER;

	dlines = cvs_splitlines(hrdp->rd_text, hrdp->rd_tlen);

	done = 0;

	rdp = hrdp;
	if (!rcsnum_differ(rdp->rd_num, bnum)) {
		if (annotate == ANNOTATE_LATER) {
			/* found requested revision for annotate */
			i = 0;
			TAILQ_FOREACH(line, &(dlines->l_lines), l_list) {
				line->l_lineno_orig = line->l_lineno;
				i++;
			}

			*alines = xcalloc(i + 1, sizeof(struct rcs_line *));
			(*alines)[i] = NULL;
			annotate = ANNOTATE_NOW;

			/* annotate down to 1.1 from where we are */
			free(bnum);
			bnum = rcsnum_parse("1.1");
			if (!rcsnum_differ(rdp->rd_num, bnum)) {
				goto next;
			}
		} else
			goto next;
	}

	prdp = hrdp;
	if ((rdp = rcs_findrev(rfp, hrdp->rd_next)) == NULL)
		goto done;

again:
	while (rdp != NULL) {
		if (rdp->rd_next->rn_len != 0) {
			trdp = rcs_findrev(rfp, rdp->rd_next);
			if (trdp == NULL)
				fatal("failed to grab next revision");
		}

		if (rdp->rd_tlen == 0) {
			if (rcsparse_deltatexts(rfp, rdp->rd_num))
				fatal("rcs_rev_getlines: rcsparse_deltatexts");
			if (rdp->rd_tlen == 0) {
				if (!rcsnum_differ(rdp->rd_num, bnum))
					break;
				rdp = trdp;
				continue;
			}
		}

		plen = rdp->rd_tlen;
		patch = rdp->rd_text;
		plines = cvs_splitlines(patch, plen);
		if (annotate == ANNOTATE_NOW)
			rcs_patch_lines(dlines, plines, *alines, prdp);
		else
			rcs_patch_lines(dlines, plines, NULL, NULL);
		cvs_freelines(plines);

		if (!rcsnum_differ(rdp->rd_num, bnum)) {
			if (annotate != ANNOTATE_LATER)
				break;

			/* found requested revision for annotate */
			i = 0;
			TAILQ_FOREACH(line, &(dlines->l_lines), l_list) {
				line->l_lineno_orig = line->l_lineno;
				i++;
			}

			*alines = xcalloc(i + 1, sizeof(struct rcs_line *));
			(*alines)[i] = NULL;
			annotate = ANNOTATE_NOW;

			/* annotate down to 1.1 from where we are */
			free(bnum);
			bnum = rcsnum_parse("1.1");

			if (!rcsnum_differ(rdp->rd_num, bnum))
				break;
		}

		prdp = rdp;
		rdp = trdp;
	}

next:
	if (rdp == NULL || !rcsnum_differ(rdp->rd_num, frev))
		done = 1;

	if (RCSNUM_ISBRANCHREV(frev) && done != 1) {
		nextroot += 2;
		rcsnum_cpy(frev, bnum, nextroot);

		TAILQ_FOREACH(brp, &(rdp->rd_branches), rb_list) {
			for (i = 0; i < nextroot - 1; i++)
				if (brp->rb_num->rn_id[i] != bnum->rn_id[i])
					break;
			if (i == nextroot - 1)
				break;
		}

		if (brp == NULL) {
			if (annotate != ANNOTATE_NEVER) {
				free(*alines);
				*alines = NULL;
				cvs_freelines(dlines);
				free(bnum);
				return (NULL);
			}
			fatal("expected branch not found on branch list");
		}

		if ((rdp = rcs_findrev(rfp, brp->rb_num)) == NULL)
			fatal("rcs_rev_getlines: failed to get delta for target rev");

		goto again;
	}
done:
	/* put remaining lines into annotate buffer */
	if (annotate == ANNOTATE_NOW) {
		for (line = TAILQ_FIRST(&(dlines->l_lines));
		    line != NULL; line = nline) {
			nline = TAILQ_NEXT(line, l_list);
			TAILQ_REMOVE(&(dlines->l_lines), line, l_list);
			if (line->l_line == NULL) {
				free(line);
				continue;
			}

			line->l_delta = rdp;
			(*alines)[line->l_lineno_orig - 1] = line;
		}

		cvs_freelines(dlines);
		dlines = NULL;
	}

	if (bnum != tnum)
		free(bnum);

	return (dlines);
}

void
rcs_annotate_getlines(RCSFILE *rfp, RCSNUM *frev, struct rcs_line ***alines)
{
	size_t plen;
	int i, nextroot;
	RCSNUM *bnum;
	struct rcs_branch *brp;
	struct rcs_delta *rdp, *trdp;
	u_char *patch;
	struct rcs_line *line;
	struct rcs_lines *dlines, *plines;

	rdp = trdp = NULL;

	if (!RCSNUM_ISBRANCHREV(frev))
		fatal("rcs_annotate_getlines: branch revision expected");

	/* revision on branch, get the branch root */
	nextroot = 2;
	bnum = rcsnum_alloc();
	rcsnum_cpy(frev, bnum, nextroot);

	/*
	 * Going from HEAD to 1.1 enables the use of an array, which is
	 * much faster. Unfortunately this is not possible with branch
	 * revisions, so copy over our alines (array) into dlines (tailq).
	 */
	dlines = xcalloc(1, sizeof(*dlines));
	TAILQ_INIT(&(dlines->l_lines));
	line = xcalloc(1, sizeof(*line));
	TAILQ_INSERT_TAIL(&(dlines->l_lines), line, l_list);

	for (i = 0; (*alines)[i] != NULL; i++) {
		line = (*alines)[i];
		line->l_lineno = i + 1;
		TAILQ_INSERT_TAIL(&(dlines->l_lines), line, l_list);
	}

	rdp = rcs_findrev(rfp, bnum);
	if (rdp == NULL)
		fatal("failed to grab branch root revision");

	do {
		nextroot += 2;
		rcsnum_cpy(frev, bnum, nextroot);

		TAILQ_FOREACH(brp, &(rdp->rd_branches), rb_list) {
			for (i = 0; i < nextroot - 1; i++)
				if (brp->rb_num->rn_id[i] != bnum->rn_id[i])
					break;
			if (i == nextroot - 1)
				break;
		}

		if (brp == NULL)
			fatal("expected branch not found on branch list");

		if ((rdp = rcs_findrev(rfp, brp->rb_num)) == NULL)
			fatal("failed to get delta for target rev");

		for (;;) {
			if (rdp->rd_next->rn_len != 0) {
				trdp = rcs_findrev(rfp, rdp->rd_next);
				if (trdp == NULL)
					fatal("failed to grab next revision");
			}

			if (rdp->rd_tlen == 0) {
				if (rcsparse_deltatexts(rfp, rdp->rd_num))
					fatal("rcs_annotate_getlines: "
					    "rcsparse_deltatexts");
				if (rdp->rd_tlen == 0) {
					if (!rcsnum_differ(rdp->rd_num, bnum))
						break;
					rdp = trdp;
					continue;
				}
			}

			plen = rdp->rd_tlen;
			patch = rdp->rd_text;
			plines = cvs_splitlines(patch, plen);
			rcs_patch_lines(dlines, plines, NULL, rdp);
			cvs_freelines(plines);

			if (!rcsnum_differ(rdp->rd_num, bnum))
				break;

			rdp = trdp;
		}
	} while (rcsnum_differ(rdp->rd_num, frev));

	if (bnum != frev)
		free(bnum);

	/*
	 * All lines have been parsed, now they must be copied over
	 * into alines (array) again.
	 */
	free(*alines);

	i = 0;
	TAILQ_FOREACH(line, &(dlines->l_lines), l_list) {
		if (line->l_line != NULL)
			i++;
	}
	*alines = xcalloc(i + 1, sizeof(struct rcs_line *));
	(*alines)[i] = NULL;

	i = 0;
	TAILQ_FOREACH(line, &(dlines->l_lines), l_list) {
		if (line->l_line != NULL)
			(*alines)[i++] = line;
	}
}

/*
 * rcs_rev_getbuf()
 *
 * XXX: This is really really slow and should be avoided if at all possible!
 *
 * Get the entire contents of revision <rev> from the RCSFILE <rfp> and
 * return it as a BUF pointer.
 */
BUF *
rcs_rev_getbuf(RCSFILE *rfp, RCSNUM *rev, int mode)
{
	int expmode, expand;
	struct rcs_delta *rdp;
	struct rcs_lines *lines;
	struct rcs_line *lp, *nlp;
	BUF *bp;

	rdp = NULL;
	expmode = RCS_KWEXP_NONE;
	expand = 0;
	lines = rcs_rev_getlines(rfp, rev, NULL);
	bp = buf_alloc(1024 * 16);

	if (!(mode & RCS_KWEXP_NONE)) {
		expmode = rcs_kwexp_get(rfp);

		if (!(expmode & RCS_KWEXP_NONE)) {
			if ((rdp = rcs_findrev(rfp, rev)) == NULL) {
				char version[RCSNUM_MAXSTR];

				rcsnum_tostr(rev, version, sizeof(version));
				fatal("could not find desired version %s in %s",
				    version, rfp->rf_path);
			}

			expand = 1;
		}
	}

	for (lp = TAILQ_FIRST(&lines->l_lines); lp != NULL;) {
		nlp = TAILQ_NEXT(lp, l_list);

		if (lp->l_line == NULL) {
			lp = nlp;
			continue;
		}

		if (expand)
			rcs_kwexp_line(rfp->rf_path, rdp, lines, lp, expmode);

		do {
			buf_append(bp, lp->l_line, lp->l_len);
		} while ((lp = TAILQ_NEXT(lp, l_list)) != nlp);
	}

	cvs_freelines(lines);

	return (bp);
}

/*
 * rcs_rev_write_fd()
 *
 * Write the entire contents of revision <frev> from the rcsfile <rfp> to
 * file descriptor <fd>.
 */
void
rcs_rev_write_fd(RCSFILE *rfp, RCSNUM *rev, int _fd, int mode)
{
	int fd;
	FILE *fp;
	size_t ret;
	int expmode, expand;
	struct rcs_delta *rdp;
	struct rcs_lines *lines;
	struct rcs_line *lp, *nlp;
	extern int print_stdout;

	rdp = NULL;
	expmode = RCS_KWEXP_NONE;
	expand = 0;
	lines = rcs_rev_getlines(rfp, rev, NULL);

	if (!(mode & RCS_KWEXP_NONE)) {
		expmode = rcs_kwexp_get(rfp);

		if (!(expmode & RCS_KWEXP_NONE)) {
			if ((rdp = rcs_findrev(rfp, rev)) == NULL)
				fatal("could not fetch revision");
			expand = 1;
		}
	}

	fd = dup(_fd);
	if (fd == -1)
		fatal("rcs_rev_write_fd: dup: %s", strerror(errno));

	if ((fp = fdopen(fd, "w")) == NULL)
		fatal("rcs_rev_write_fd: fdopen: %s", strerror(errno));

	for (lp = TAILQ_FIRST(&lines->l_lines); lp != NULL;) {
		nlp = TAILQ_NEXT(lp, l_list);

		if (lp->l_line == NULL) {
			lp = nlp;
			continue;
		}

		if (expand)
			rcs_kwexp_line(rfp->rf_path, rdp, lines, lp, expmode);

		do {
			/*
			 * Solely for the checkout and update -p options.
			 */
			if (cvs_server_active == 1 &&
			    (cvs_cmdop == CVS_OP_CHECKOUT ||
			    cvs_cmdop == CVS_OP_UPDATE) && print_stdout == 1) {
				ret = fwrite("M ", 1, 2, fp);
				if (ret != 2)
					fatal("rcs_rev_write_fd: %s",
					    strerror(errno));
			}

			ret = fwrite(lp->l_line, 1, lp->l_len, fp);
			if (ret != lp->l_len)
				fatal("rcs_rev_write_fd: %s", strerror(errno));
		} while ((lp = TAILQ_NEXT(lp, l_list)) != nlp);
	}

	cvs_freelines(lines);
	(void)fclose(fp);
}

/*
 * rcs_rev_write_stmp()
 *
 * Write the contents of the rev <rev> to a temporary file whose path is
 * specified using <template> (see mkstemp(3)). NB. This function will modify
 * <template>, as per mkstemp.
 */
int
rcs_rev_write_stmp(RCSFILE *rfp,  RCSNUM *rev, char *template, int mode)
{
	int fd;

	if ((fd = mkstemp(template)) == -1)
		fatal("mkstemp: `%s': %s", template, strerror(errno));

	worklist_add(template, &temp_files);
	rcs_rev_write_fd(rfp, rev, fd, mode);

	if (lseek(fd, 0, SEEK_SET) < 0)
		fatal("rcs_rev_write_stmp: lseek: %s", strerror(errno));

	return (fd);
}

static void
rcs_kwexp_line(char *rcsfile, struct rcs_delta *rdp, struct rcs_lines *lines,
    struct rcs_line *line, int mode)
{
	BUF *tmpbuf;
	int kwtype;
	u_int j, found;
	const u_char *c, *start, *fin, *end;
	char *kwstr;
	char expbuf[256], buf[256];
	size_t clen, kwlen, len, tlen;

	kwtype = 0;
	kwstr = NULL;

	if (mode & RCS_KWEXP_OLD)
		return;

	len = line->l_len;
	if (len == 0)
		return;

	c = line->l_line;
	found = 0;
	/* Final character in buffer. */
	fin = c + len - 1;

	/*
	 * Keyword formats:
	 * $Keyword$
	 * $Keyword: value$
	 */
	for (; c < fin; c++) {
		if (*c != '$')
			continue;

		/* remember start of this possible keyword */
		start = c;

		/* first following character has to be alphanumeric */
		c++;
		if (!isalpha(*c)) {
			c = start;
			continue;
		}

		/* Number of characters between c and fin, inclusive. */
		clen = fin - c + 1;

		/* look for any matching keywords */
		found = 0;
		for (j = 0; j < RCS_NKWORDS; j++) {
			kwlen = strlen(rcs_expkw[j].kw_str);
			/*
			 * kwlen must be less than clen since clen
			 * includes either a terminating `$' or a `:'.
			 */
			if (kwlen < clen &&
			    memcmp(c, rcs_expkw[j].kw_str, kwlen) == 0 &&
			    (c[kwlen] == '$' || c[kwlen] == ':')) {
				found = 1;
				kwstr = rcs_expkw[j].kw_str;
				kwtype = rcs_expkw[j].kw_type;
				c += kwlen;
				break;
			}
		}

		if (found == 0 && cvs_tagname != NULL) {
			kwlen = strlen(cvs_tagname);
			if (kwlen < clen &&
			    memcmp(c, cvs_tagname, kwlen) == 0 &&
			    (c[kwlen] == '$' || c[kwlen] == ':')) {
				found = 1;
				kwstr = cvs_tagname;
				kwtype = RCS_KW_ID;
				c += kwlen;
			}
		}

		/* unknown keyword, continue looking */
		if (found == 0) {
			c = start;
			continue;
		}

		/*
		 * if the next character was ':' we need to look for
		 * an '$' before the end of the line to be sure it is
		 * in fact a keyword.
		 */
		if (*c == ':') {
			for (; c <= fin; ++c) {
				if (*c == '$' || *c == '\n')
					break;
			}

			if (*c != '$') {
				c = start;
				continue;
			}
		}
		end = c + 1;

		/* start constructing the expansion */
		expbuf[0] = '\0';

		if (mode & RCS_KWEXP_NAME) {
			if (strlcat(expbuf, "$", sizeof(expbuf)) >=
			    sizeof(expbuf) || strlcat(expbuf, kwstr,
			    sizeof(expbuf)) >= sizeof(expbuf))
				fatal("rcs_kwexp_line: truncated");
			if ((mode & RCS_KWEXP_VAL) &&
			    strlcat(expbuf, ": ", sizeof(expbuf)) >=
			    sizeof(expbuf))
				fatal("rcs_kwexp_line: truncated");
		}

		/*
		 * order matters because of RCS_KW_ID and
		 * RCS_KW_HEADER here
		 */
		if (mode & RCS_KWEXP_VAL) {
			if (kwtype & RCS_KW_RCSFILE) {
				if (!(kwtype & RCS_KW_FULLPATH))
					(void)strlcat(expbuf, basename(rcsfile),
					    sizeof(expbuf));
				else
					(void)strlcat(expbuf, rcsfile,
					    sizeof(expbuf));
				if (strlcat(expbuf, " ", sizeof(expbuf)) >=
				    sizeof(expbuf))
					fatal("rcs_kwexp_line: truncated");
			}

			if (kwtype & RCS_KW_REVISION) {
				rcsnum_tostr(rdp->rd_num, buf, sizeof(buf));
				if (strlcat(buf, " ", sizeof(buf)) >=
				    sizeof(buf) || strlcat(expbuf, buf,
				    sizeof(expbuf)) >= sizeof(buf))
					fatal("rcs_kwexp_line: truncated");
			}

			if (kwtype & RCS_KW_DATE) {
				if (strftime(buf, sizeof(buf),
				    "%Y/%m/%d %H:%M:%S ",
				    &rdp->rd_date) == 0)
					fatal("rcs_kwexp_line: strftime "
					    "failure");
				if (strlcat(expbuf, buf, sizeof(expbuf)) >=
				    sizeof(expbuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");
			}

			if (kwtype & RCS_KW_MDOCDATE) {
				/*
				 * Do not prepend ' ' for a single
				 * digit, %e would do so and there is
				 * no better format for strftime().
				 */
				if (strftime(buf, sizeof(buf),
				    (rdp->rd_date.tm_mday < 10) ?
				        "%B%e %Y " : "%B %e %Y ",
				    &rdp->rd_date) == 0)
					fatal("rcs_kwexp_line: strftime "
					    "failure");
				if (strlcat(expbuf, buf, sizeof(expbuf)) >=
				    sizeof(expbuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");
			}

			if (kwtype & RCS_KW_AUTHOR) {
				if (strlcat(expbuf, rdp->rd_author,
				    sizeof(expbuf)) >= sizeof(expbuf) ||
				    strlcat(expbuf, " ", sizeof(expbuf)) >=
				    sizeof(expbuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");
			}

			if (kwtype & RCS_KW_STATE) {
				if (strlcat(expbuf, rdp->rd_state,
				    sizeof(expbuf)) >= sizeof(expbuf) ||
				    strlcat(expbuf, " ", sizeof(expbuf)) >=
				    sizeof(expbuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");
			}

			/* order does not matter anymore below */
			if (kwtype & RCS_KW_LOG) {
				char linebuf[256];
				struct rcs_line *cur, *lp;
				char *logp, *l_line, *prefix, *q, *sprefix;
				size_t i;

				/* Log line */
				if (!(kwtype & RCS_KW_FULLPATH))
					(void)strlcat(expbuf,
					    basename(rcsfile), sizeof(expbuf));
				else
					(void)strlcat(expbuf, rcsfile,
					    sizeof(expbuf));

				if (strlcat(expbuf, " ", sizeof(expbuf)) >=
				    sizeof(expbuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");

				cur = line;

				/* copy rdp->rd_log for strsep */
				logp = xstrdup(rdp->rd_log);

				/* copy our prefix for later processing */
				prefix = xmalloc(start - line->l_line + 1);
				memcpy(prefix, line->l_line,
				    start - line->l_line);
				prefix[start - line->l_line] = '\0';

				/* copy also prefix without trailing blanks. */
				sprefix = xstrdup(prefix);
				for (i = strlen(sprefix); i > 0 &&
				    sprefix[i - 1] == ' '; i--)
					sprefix[i - 1] = '\0';

				/* new line: revision + date + author */
				linebuf[0] = '\0';
				if (strlcat(linebuf, "Revision ",
				    sizeof(linebuf)) >= sizeof(linebuf))
					fatal("rcs_kwexp_line: truncated");
				rcsnum_tostr(rdp->rd_num, buf, sizeof(buf));
				if (strlcat(linebuf, buf, sizeof(linebuf))
				    >= sizeof(buf))
					fatal("rcs_kwexp_line: truncated");
				if (strftime(buf, sizeof(buf),
				    "  %Y/%m/%d %H:%M:%S  ",
				    &rdp->rd_date) == 0)
					fatal("rcs_kwexp_line: strftime "
					    "failure");
				if (strlcat(linebuf, buf, sizeof(linebuf))
				    >= sizeof(linebuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");
				if (strlcat(linebuf, rdp->rd_author,
				    sizeof(linebuf)) >= sizeof(linebuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");

				lp = xcalloc(1, sizeof(*lp));
				xasprintf((char **)&(lp->l_line), "%s%s\n",
				    prefix, linebuf);
				lp->l_len = strlen(lp->l_line);
				TAILQ_INSERT_AFTER(&(lines->l_lines), cur, lp,
				    l_list);
				cur = lp;

				/* Log message */
				q = logp;
				while ((l_line = strsep(&q, "\n")) != NULL &&
				    q != NULL) {
					lp = xcalloc(1, sizeof(*lp));

					if (l_line[0] == '\0') {
						xasprintf((char **)&(lp->l_line),
						    "%s\n", sprefix);
					} else {
						xasprintf((char **)&(lp->l_line),
						    "%s%s\n", prefix, l_line);
					}

					lp->l_len = strlen(lp->l_line);
					TAILQ_INSERT_AFTER(&(lines->l_lines),
					    cur, lp, l_list);
					cur = lp;
				}
				free(logp);

				/*
				 * This is just another hairy mess, but it must
				 * be done: All characters behind Log will be
				 * written in a new line next to log messages.
				 * But that's not enough, we have to strip all
				 * trailing whitespaces of our prefix.
				 */
				lp = xcalloc(1, sizeof(*lp));
				xasprintf((char **)&lp->l_line, "%s%s",
				    sprefix, end);
				lp->l_len = strlen(lp->l_line);
				TAILQ_INSERT_AFTER(&(lines->l_lines), cur, lp,
				    l_list);
				cur = lp;

				end = line->l_line + line->l_len - 1;

				free(prefix);
				free(sprefix);

			}

			if (kwtype & RCS_KW_SOURCE) {
				if (strlcat(expbuf, rcsfile, sizeof(expbuf)) >=
				    sizeof(expbuf) || strlcat(expbuf, " ",
				    sizeof(expbuf)) >= sizeof(expbuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");
			}

			if (kwtype & RCS_KW_NAME)
				if (strlcat(expbuf, " ", sizeof(expbuf)) >=
				    sizeof(expbuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");

			if (kwtype & RCS_KW_LOCKER)
				if (strlcat(expbuf, " ", sizeof(expbuf)) >=
				    sizeof(expbuf))
					fatal("rcs_kwexp_line: string "
					    "truncated");
		}

		/* end the expansion */
		if (mode & RCS_KWEXP_NAME)
			if (strlcat(expbuf, "$",
			    sizeof(expbuf)) >= sizeof(expbuf))
				fatal("rcs_kwexp_line: truncated");

		/* Concatenate everything together. */
		tmpbuf = buf_alloc(len + strlen(expbuf));
		/* Append everything before keyword. */
		buf_append(tmpbuf, line->l_line,
		    start - line->l_line);
		/* Append keyword. */
		buf_puts(tmpbuf, expbuf);
		/* Point c to end of keyword. */
		tlen = buf_len(tmpbuf) - 1;
		/* Append everything after keyword. */
		buf_append(tmpbuf, end,
		    line->l_line + line->l_len - end);
		c = buf_get(tmpbuf) + tlen;
		/* Point fin to end of data. */
		fin = buf_get(tmpbuf) + buf_len(tmpbuf) - 1;
		/* Recalculate new length. */
		len = buf_len(tmpbuf);

		/* tmpbuf is now ready, convert to string */
		if (line->l_needsfree)
			free(line->l_line);
		line->l_len = len;
		line->l_line = buf_release(tmpbuf);
		line->l_needsfree = 1;
	}
}

/* rcs_translate_tag() */
RCSNUM *
rcs_translate_tag(const char *revstr, RCSFILE *rfp)
{
	int follow;
	time_t deltatime;
	char branch[CVS_REV_BUFSZ];
	RCSNUM *brev, *frev, *rev;
	struct rcs_delta *rdp, *trdp;
	time_t cdate;

	brev = frev = NULL;

	if (revstr == NULL) {
		if (rfp->rf_branch != NULL) {
			rcsnum_tostr(rfp->rf_branch, branch, sizeof(branch));
			revstr = branch;
		} else {
			revstr = RCS_HEAD_BRANCH;
		}
	}

	if ((rev = rcs_get_revision(revstr, rfp)) == NULL)
		return (NULL);

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (NULL);

	/* let's see if we must follow a branch */
	if (!strcmp(revstr, RCS_HEAD_BRANCH))
		follow = 1;
	else {
		frev = rcs_sym_getrev(rfp, revstr);
		if (frev == NULL)
			frev = rcsnum_parse(revstr);

		brev = rcsnum_alloc();
		rcsnum_cpy(rev, brev, rev->rn_len - 1);

		if (frev != NULL && RCSNUM_ISBRANCH(frev) &&
		    !rcsnum_cmp(frev, brev, 0)) {
			follow = 1;
		} else
			follow = 0;

		free(brev);
	}

	if (cvs_specified_date != -1)
		cdate = cvs_specified_date;
	else
		cdate = cvs_directory_date;

	if (cdate == -1) {
		free(frev);

		/* XXX */
		if (rev->rn_len < 4 || !follow) {
			return (rev);
		}

		/* Find the latest delta on that branch */
		free(rev);
		for (;;) {
			if (rdp->rd_next->rn_len == 0)
				break;
			if ((rdp = rcs_findrev(rfp, rdp->rd_next)) == NULL)
				fatal("rcs_translate_tag: could not fetch "
				    "branch delta");
		}

		rev = rcsnum_alloc();
		rcsnum_cpy(rdp->rd_num, rev, 0);
		return (rev);
	}

	if (frev != NULL) {
		brev = rcsnum_revtobr(frev);
		brev->rn_len = rev->rn_len - 1;
		free(frev);
	}

	free(rev);

	do {
		deltatime = timegm(&(rdp->rd_date));

		if (RCSNUM_ISBRANCHREV(rdp->rd_num)) {
			if (deltatime > cdate) {
				trdp = TAILQ_PREV(rdp, rcs_dlist, rd_list);
				if (trdp == NULL)
					trdp = rdp;

				if (trdp->rd_num->rn_len != rdp->rd_num->rn_len)
					return (NULL);

				rev = rcsnum_alloc();
				rcsnum_cpy(trdp->rd_num, rev, 0);
				return (rev);
			}

			if (rdp->rd_next->rn_len == 0) {
				rev = rcsnum_alloc();
				rcsnum_cpy(rdp->rd_num, rev, 0);
				return (rev);
			}
		} else {
			if (deltatime < cdate) {
				rev = rcsnum_alloc();
				rcsnum_cpy(rdp->rd_num, rev, 0);
				return (rev);
			}
		}

		if (follow && rdp->rd_next->rn_len != 0) {
			if (brev != NULL && !rcsnum_cmp(brev, rdp->rd_num, 0))
				break;

			trdp = rcs_findrev(rfp, rdp->rd_next);
			if (trdp == NULL)
				fatal("failed to grab next revision");
			rdp = trdp;
		} else
			follow = 0;
	} while (follow);

	return (NULL);
}
@


1.317
log
@Plug memleak in rcs_translate_tag() that was causing havoc on large repos.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.316 2016/10/15 22:20:17 millert Exp $	*/
d2466 2
a2467 6
				lp->l_line = xcalloc(strlen(sprefix) +
				    line->l_line + line->l_len - end + 1, 1);
				strlcpy(lp->l_line, sprefix,
				    strlen(sprefix) + 1);
				memcpy(lp->l_line + strlen(sprefix),
				    end, line->l_line + line->l_len - end);
@


1.316
log
@Quiet compiler warnings.  OK tomc@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.315 2016/10/13 20:51:25 fcambus Exp $	*/
d2592 2
@


1.315
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.314 2016/10/13 20:31:45 millert Exp $	*/
d2430 1
a2430 1
				xasprintf(&(lp->l_line), "%s%s\n",
d2444 2
a2445 2
						xasprintf(&(lp->l_line), "%s\n",
						    sprefix);
d2447 1
a2447 1
						xasprintf(&(lp->l_line),
@


1.314
log
@Fix revision lookups for branches.  Properly perform a revision
lookup so update -r actually works again, as a bonus throw a more
correct error when the revision could not be found.  From Joris Vink.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.313 2015/11/05 09:48:21 nicm Exp $	*/
d246 1
a246 1
		rcsnum_free(rsp->rs_num);
d254 1
a254 1
		rcsnum_free(rlp->rl_num);
d259 2
a260 4
	if (rfp->rf_head != NULL)
		rcsnum_free(rfp->rf_head);
	if (rfp->rf_branch != NULL)
		rcsnum_free(rfp->rf_branch);
d469 1
a469 1
		rcsnum_free(rootrev);
d534 1
a534 1
			rcsnum_free(brev);
d683 1
a683 1
	rcsnum_free(symp->rs_num);
d859 1
a859 1
	rcsnum_free(lkp->rl_num);
d1210 1
a1210 2
	if (root != NULL)
		rcsnum_free(root);
d1292 1
a1292 1
		rcsnum_free(nextrdp->rd_next);
d1295 1
a1295 1
		rcsnum_free(rf->rf_head);
d1451 2
a1452 5
	if (rdp->rd_num != NULL)
		rcsnum_free(rdp->rd_num);
	if (rdp->rd_next != NULL)
		rcsnum_free(rdp->rd_next);

d1461 1
a1461 1
		rcsnum_free(rb->rb_num);
d1679 1
a1679 1
			rcsnum_free(rev);
d1690 1
a1690 1
	rcsnum_free(brev);
d1701 1
a1701 1
	rcsnum_free(rev);
d1778 1
a1778 1
			rcsnum_free(bnum);
d1835 1
a1835 1
			rcsnum_free(bnum);
d1867 1
a1867 1
				rcsnum_free(bnum);
d1899 1
a1899 1
		rcsnum_free(bnum);
d1997 1
a1997 1
		rcsnum_free(bnum);
d2583 1
a2583 1
		rcsnum_free(brev);
d2598 1
a2598 1
		rcsnum_free(rev);
d2615 1
a2615 1
		rcsnum_free(frev);
d2618 1
a2618 1
	rcsnum_free(rev);
@


1.313
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.312 2015/01/16 06:40:07 deraadt Exp $	*/
d1798 1
a1798 1
	for (;;) {
a1802 7
		} else {
			/*
			 * XXX Fail, although the caller does not always do the
			 * right thing (eg cvs diff when the tree is ahead of
			 * the repository).
			 */
			break;
d1853 1
a1853 1
	if (!rcsnum_differ(rdp->rd_num, frev))
d2053 8
a2060 2
			if ((rdp = rcs_findrev(rfp, rev)) == NULL)
				fatal("could not fetch revision");
@


1.312
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.311 2014/01/08 13:23:55 okan Exp $	*/
d239 2
a240 2
		xfree(rap->ra_name);
		xfree(rap);
d247 2
a248 2
		xfree(rsp->rs_name);
		xfree(rsp);
d255 2
a256 2
		xfree(rlp->rl_name);
		xfree(rlp);
d266 4
a269 8
	if (rfp->rf_path != NULL)
		xfree(rfp->rf_path);
	if (rfp->rf_comment != NULL)
		xfree(rfp->rf_comment);
	if (rfp->rf_expand != NULL)
		xfree(rfp->rf_expand);
	if (rfp->rf_desc != NULL)
		xfree(rfp->rf_desc);
d272 1
a272 1
	xfree(rfp);
d437 1
a437 3

	if (fn != NULL)
		xfree(fn);
d620 2
a621 2
	xfree(ap->ra_name);
	xfree(ap);
d684 1
a684 1
	xfree(symp->rs_name);
d686 1
a686 1
	xfree(symp);
d862 2
a863 2
	xfree(lkp->rl_name);
	xfree(lkp);
d892 1
a892 2
	if (file->rf_desc != NULL)
		xfree(file->rf_desc);
d941 1
a941 2
	if (file->rf_comment != NULL)
		xfree(file->rf_comment);
d1006 1
a1006 1
					xfree(dlp);
d1024 1
a1024 1
						xfree(lp->l_line);
d1132 1
a1132 2
			if (rf->rf_head != NULL)
				xfree(rf->rf_head);
d1306 3
a1308 8

	if (newdeltatext != NULL)
		xfree(newdeltatext);

	if (path_tmp1 != NULL)
		xfree(path_tmp1);
	if (path_tmp2 != NULL)
		xfree(path_tmp2);
d1384 1
a1384 2
	if (file->rf_expand != NULL)
		xfree(file->rf_expand);
d1459 5
a1463 10
	if (rdp->rd_author != NULL)
		xfree(rdp->rd_author);
	if (rdp->rd_locker != NULL)
		xfree(rdp->rd_locker);
	if (rdp->rd_state != NULL)
		xfree(rdp->rd_state);
	if (rdp->rd_log != NULL)
		xfree(rdp->rd_log);
	if (rdp->rd_text != NULL)
		xfree(rdp->rd_text);
d1468 1
a1468 1
		xfree(rb);
d1471 1
a1471 1
	xfree(rdp);
d1523 1
a1523 2
	if (rdp->rd_text != NULL)
		xfree(rdp->rd_text);
d1538 1
a1538 3
	if (dtext != NULL)
		xfree(dtext);

d1555 1
a1555 2
	if (rdp->rd_log != NULL)
		xfree(rdp->rd_log);
d1594 1
a1594 2
	if (rdp->rd_state != NULL)
		xfree(rdp->rd_state);
d1877 1
a1877 2
				if (*alines != NULL)
					xfree(*alines);
d1899 1
a1899 1
				xfree(line);
d2016 1
a2016 1
	xfree(*alines);
d2463 1
a2463 1
				xfree(logp);
d2486 2
a2487 2
				xfree(prefix);
				xfree(sprefix);
d2538 1
a2538 1
			xfree(line->l_line);
@


1.311
log
@unsigned char for ctype. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.310 2011/05/02 22:22:54 chl Exp $	*/
d43 2
d289 1
a289 1
	char   numbuf[CVS_REV_BUFSZ], *fn, tmpdir[MAXPATHLEN];
d1709 1
a1709 1
		    MIN(rfp->rf_head->rn_len, rev->rn_len)) < 0) {
@


1.310
log
@Fix bad return value check for rcsnum_cmp()

ok nickm@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.309 2011/03/27 14:15:02 nicm Exp $	*/
d762 1
a762 1
	const char *cp;
@


1.309
log
@Get rid of some warnings, from Michael W Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.308 2010/11/11 21:00:59 nicm Exp $	*/
d472 1
a472 1
			    file->rf_branch->rn_len) == NULL)
@


1.308
log
@Nuke dead assignments and a dead function, from Michael W Bombardieri
using lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.307 2010/10/31 15:37:34 nicm Exp $	*/
d1763 2
d1953 2
d2074 2
d2129 2
@


1.307
log
@init was passing a writable file descriptor into rcs_open which was then
failing to fdopen() it as readable. It doesn't need to pass in the fd at
all, so just change it to pass -1 which makes cvs init work again.

In fact, the fd should never need to be writable - it is only used for
reading. RCS_WRITE triggers a rewrite on the file on rcs_close() but
this is done by using a temporary and rename(2) (RCS_WRITE is a poor
name for the flag). So while here, add a couple of comments to hopefully
make it a little clearer. There is some confusion about how this is used
in other places but checking those is a separate issue.

with and ok tobias
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.306 2010/10/27 08:35:45 tobias Exp $	*/
d1066 1
a1066 1
	int added, i, lineno, nbln, removed;
d1084 1
a1084 1
		lineno = (int)strtol((lp->l_line + 1), &ep, 10);
@


1.306
log
@Merge -k and expand @@@@ parsing code between OpenCVS and OpenRCS, resulting
in a performance gain in OpenCVS in some "cvs update" scenarios.

ok zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.305 2010/10/20 19:53:53 tobias Exp $	*/
d147 4
@


1.305
log
@Remove the need for rp_file in parser structure, instead keep only one
FILE pointer in RCSFILE.  This fixes some ugliness in closing an
fdopen()ed FILE and its underlying file descriptor.

Notified by Joerg Sonnenberger <joerg at britannica dot bec to de>

discussed with and ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.304 2010/10/15 08:46:23 tobias Exp $	*/
d1407 4
a1410 1
	return rcs_kflag_get(file->rf_expand);
d1427 2
a1428 2
	if (flags == NULL)
		return 0;
a1430 3
	if (!(len = strlen(flags)))
		return RCS_KWEXP_ERR;

d2071 1
a2071 4
		if (rfp->rf_expand != NULL)
			expmode = rcs_kwexp_get(rfp);
		else
			expmode = RCS_KWEXP_DEFAULT;
d2123 1
a2123 4
		if (rfp->rf_expand != NULL)
			expmode = rcs_kwexp_get(rfp);
		else
			expmode = RCS_KWEXP_DEFAULT;
@


1.304
log
@Fixed default branch handling and added support for branches in branches.

ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.303 2010/10/15 08:44:12 tobias Exp $	*/
d179 4
a182 1
	rfp->rf_fd = fd;
d258 2
@


1.303
log
@Replaced RCS parser code with new rcsparse.{c,h}:
- be very strict about things we parse
- print more information about errors if they occur
- do not fatal() directly in parser, give caller a chance to react
- fix an rcs design issue when it comes to login names

tested by many on tech@@

ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.302 2010/09/29 09:23:54 tobias Exp $	*/
d455 2
a456 1
		rcsnum_cpy(file->rf_branch, rootrev, 2);
d462 2
a463 1
			if (TAILQ_NEXT(brp, rb_list) == NULL)
d467 4
@


1.302
log
@Ensure that we always parse all deltas before expecting "desc" keyword.

ok nicm, zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.301 2010/09/11 07:26:00 tobias Exp $	*/
d41 1
a42 2
#define RCS_BUFSIZE	16384
#define RCS_BUFEXTSIZE	8192
a44 31
/* RCS token types */
#define RCS_TOK_ERR	-1
#define RCS_TOK_EOF	0
#define RCS_TOK_NUM	1
#define RCS_TOK_ID	2
#define RCS_TOK_STRING	3
#define RCS_TOK_SCOLON	4
#define RCS_TOK_COLON	5

#define RCS_TOK_HEAD		8
#define RCS_TOK_BRANCH		9
#define RCS_TOK_ACCESS		10
#define RCS_TOK_SYMBOLS		11
#define RCS_TOK_LOCKS		12
#define RCS_TOK_COMMENT		13
#define RCS_TOK_EXPAND		14
#define RCS_TOK_DATE		15
#define RCS_TOK_AUTHOR		16
#define RCS_TOK_STATE		17
#define RCS_TOK_NEXT		18
#define RCS_TOK_BRANCHES	19
#define RCS_TOK_DESC		20
#define RCS_TOK_LOG		21
#define RCS_TOK_TEXT		22
#define RCS_TOK_STRICT		23

#define RCS_ISKEY(t)	(((t) >= RCS_TOK_HEAD) && ((t) <= RCS_TOK_BRANCHES))

#define RCS_NOSCOL	0x01	/* no terminating semi-colon */
#define RCS_VOPT	0x02	/* value is optional */

a48 17
/* opaque parse data */
struct rcs_pdata {
	char	*rp_buf;
	size_t	 rp_blen;
	char	*rp_bufend;
	size_t	 rp_tlen;

	/* pushback token buffer */
	char	rp_ptok[128];
	int	rp_pttype;	/* token type, RCS_TOK_ERR if no token */

	FILE	*rp_file;
};

#define RCS_TOKSTR(rfp)	((struct rcs_pdata *)rfp->rf_pdata)->rp_buf
#define RCS_TOKLEN(rfp)	((struct rcs_pdata *)rfp->rf_pdata)->rp_tlen

a137 26
static struct rcs_key {
	char	rk_str[16];
	int	rk_id;
	int	rk_val;
	int	rk_flags;
} rcs_keys[] = {
	{ "access",   RCS_TOK_ACCESS,   RCS_TOK_ID,     RCS_VOPT     },
	{ "author",   RCS_TOK_AUTHOR,   RCS_TOK_ID,     0            },
	{ "branch",   RCS_TOK_BRANCH,   RCS_TOK_NUM,    RCS_VOPT     },
	{ "branches", RCS_TOK_BRANCHES, RCS_TOK_NUM,    RCS_VOPT     },
	{ "comment",  RCS_TOK_COMMENT,  RCS_TOK_STRING, RCS_VOPT     },
	{ "date",     RCS_TOK_DATE,     RCS_TOK_NUM,    0            },
	{ "desc",     RCS_TOK_DESC,     RCS_TOK_STRING, RCS_NOSCOL   },
	{ "expand",   RCS_TOK_EXPAND,   RCS_TOK_STRING, RCS_VOPT     },
	{ "head",     RCS_TOK_HEAD,     RCS_TOK_NUM,    RCS_VOPT     },
	{ "locks",    RCS_TOK_LOCKS,    RCS_TOK_ID,     0            },
	{ "log",      RCS_TOK_LOG,      RCS_TOK_STRING, RCS_NOSCOL   },
	{ "next",     RCS_TOK_NEXT,     RCS_TOK_NUM,    RCS_VOPT     },
	{ "state",    RCS_TOK_STATE,    RCS_TOK_ID,     RCS_VOPT     },
	{ "strict",   RCS_TOK_STRICT,   0,              0,           },
	{ "symbols",  RCS_TOK_SYMBOLS,  0,              0            },
	{ "text",     RCS_TOK_TEXT,     RCS_TOK_STRING, RCS_NOSCOL   },
};

#define RCS_NKEYS	(sizeof(rcs_keys)/sizeof(rcs_keys[0]))

a140 12
static void	rcs_parse_init(RCSFILE *);
static int	rcs_parse_admin(RCSFILE *);
static int	rcs_parse_delta(RCSFILE *);
static void	rcs_parse_deltas(RCSFILE *, RCSNUM *);
static int	rcs_parse_deltatext(RCSFILE *);
static void	rcs_parse_deltatexts(RCSFILE *, RCSNUM *);
static void	rcs_parse_desc(RCSFILE *);

static int	rcs_parse_access(RCSFILE *);
static int	rcs_parse_symbols(RCSFILE *);
static int	rcs_parse_locks(RCSFILE *);
static int	rcs_parse_branches(RCSFILE *, struct rcs_delta *);
a141 4
static void	rcs_freepdata(struct rcs_pdata *);
static int	rcs_gettok(RCSFILE *);
static int	rcs_pushtok(RCSFILE *, const char *, int);
static void	rcs_growbuf(RCSFILE *);
a146 2
static int rcs_ignore_keys = 0;

d187 4
a190 2
	if (!(rfp->rf_flags & RCS_CREATE))
		rcs_parse_init(rfp);
d264 1
a264 1
		rcs_freepdata(rfp->rf_pdata);
d296 2
a297 1
	rcs_parse_deltatexts(rfp, NULL);
d1338 2
a1339 1
		rcs_parse_deltas(rfp, rev);
a1441 705
/* rcs_parse_deltas()
 *
 * Parse deltas. If <rev> is not NULL, parse only as far as that
 * revision. If <rev> is NULL, parse all deltas.
 */
static void
rcs_parse_deltas(RCSFILE *rfp, RCSNUM *rev)
{
	int ret;
	struct rcs_delta *enddelta;

	if ((rfp->rf_flags & PARSED_DELTAS) || (rfp->rf_flags & RCS_CREATE))
		return;

	for (;;) {
		ret = rcs_parse_delta(rfp);
		if (rev != NULL) {
			enddelta = TAILQ_LAST(&(rfp->rf_delta), rcs_dlist);
			if (rcsnum_cmp(enddelta->rd_num, rev, 0) == 0)
				break;
		}

		if (ret == 0) {
			rfp->rf_flags |= PARSED_DELTAS;
			break;
		}
		else if (ret == -1)
			fatal("error parsing deltas");
	}
}

/* rcs_parse_deltatexts()
 *
 * Parse deltatexts. If <rev> is not NULL, parse only as far as that
 * revision. If <rev> is NULL, parse everything.
 */
static void
rcs_parse_deltatexts(RCSFILE *rfp, RCSNUM *rev)
{
	int ret;
	struct rcs_delta *rdp;

	if ((rfp->rf_flags & PARSED_DELTATEXTS) ||
	    (rfp->rf_flags & RCS_CREATE))
		return;

	if (!(rfp->rf_flags & PARSED_DESC))
		rcs_parse_desc(rfp);
	for (;;) {
		if (rev != NULL) {
			rdp = rcs_findrev(rfp, rev);
			if (rdp->rd_text != NULL)
				break;
			else
				ret = rcs_parse_deltatext(rfp);
		} else
			ret = rcs_parse_deltatext(rfp);
		if (ret == 0) {
			rfp->rf_flags |= PARSED_DELTATEXTS;
			break;
		}
		else if (ret == -1)
			fatal("problem parsing deltatexts");
	}
}

/* rcs_parse_desc()
 *
 * Parse RCS description.
 */
static void
rcs_parse_desc(RCSFILE *rfp)
{
	int ret = 0;

	if ((rfp->rf_flags & PARSED_DESC) || (rfp->rf_flags & RCS_CREATE))
		return;
	if (!(rfp->rf_flags & PARSED_DELTAS))
		rcs_parse_deltas(rfp, NULL);
	/* do parsing */
	ret = rcs_gettok(rfp);
	if (ret != RCS_TOK_DESC)
		fatal("token `%s' found where RCS desc expected",
		    RCS_TOKSTR(rfp));

	ret = rcs_gettok(rfp);
	if (ret != RCS_TOK_STRING)
		fatal("token `%s' found where RCS desc expected",
		    RCS_TOKSTR(rfp));

	rfp->rf_desc = xstrdup(RCS_TOKSTR(rfp));
	rfp->rf_flags |= PARSED_DESC;
}

/*
 * rcs_parse_init()
 *
 * Initial parsing of file <path>, which is in the RCS format.
 * Just does admin section.
 */
static void
rcs_parse_init(RCSFILE *rfp)
{
	struct rcs_pdata *pdp;

	if (rfp->rf_flags & RCS_PARSED)
		return;

	pdp = xcalloc(1, sizeof(*pdp));

	pdp->rp_pttype = RCS_TOK_ERR;

	if ((pdp->rp_file = fdopen(rfp->rf_fd, "r")) == NULL)
		fatal("fdopen: `%s'", rfp->rf_path);

	pdp->rp_buf = xmalloc((size_t)RCS_BUFSIZE);
	pdp->rp_blen = RCS_BUFSIZE;
	pdp->rp_bufend = pdp->rp_buf + pdp->rp_blen - 1;

	/* ditch the strict lock */
	rfp->rf_flags &= ~RCS_SLOCK;
	rfp->rf_pdata = pdp;

	if (rcs_parse_admin(rfp) < 0) {
		rcs_freepdata(pdp);
		fatal("could not parse admin data");
	}

	if (rfp->rf_flags & RCS_PARSE_FULLY) {
		rcs_parse_deltatexts(rfp, NULL);
		(void)close(rfp->rf_fd);
		rfp->rf_fd = -1;
	}

	rfp->rf_flags |= RCS_SYNCED;
}

/*
 * rcs_parse_admin()
 *
 * Parse the administrative portion of an RCS file.
 * Returns the type of the first token found after the admin section on
 * success, or -1 on failure.
 */
static int
rcs_parse_admin(RCSFILE *rfp)
{
	u_int i;
	int tok, ntok, hmask;
	struct rcs_key *rk;

	rfp->rf_head = NULL;
	rfp->rf_branch = NULL;

	/* hmask is a mask of the headers already encountered */
	hmask = 0;
	for (;;) {
		tok = rcs_gettok(rfp);
		if (tok == RCS_TOK_ERR) {
			cvs_log(LP_ERR, "parse error in RCS admin section");
			goto fail;
		} else if (tok == RCS_TOK_NUM || tok == RCS_TOK_DESC) {
			/*
			 * Assume this is the start of the first delta or
			 * that we are dealing with an empty RCS file and
			 * we just found the description.
			 */
			if (!(hmask & (1 << RCS_TOK_HEAD))) {
				cvs_log(LP_ERR, "head missing");
				goto fail;
			}
			rcs_pushtok(rfp, RCS_TOKSTR(rfp), tok);
			return (tok);
		}

		rk = NULL;
		for (i = 0; i < RCS_NKEYS; i++)
			if (rcs_keys[i].rk_id == tok)
				rk = &(rcs_keys[i]);

		if (hmask & (1 << tok)) {
			cvs_log(LP_ERR, "duplicate RCS key");
			goto fail;
		}
		hmask |= (1 << tok);

		switch (tok) {
		case RCS_TOK_HEAD:
		case RCS_TOK_BRANCH:
		case RCS_TOK_COMMENT:
		case RCS_TOK_EXPAND:
			ntok = rcs_gettok(rfp);
			if (ntok == RCS_TOK_SCOLON)
				break;
			if (ntok != rk->rk_val) {
				cvs_log(LP_ERR,
				    "invalid value type for RCS key `%s'",
				    rk->rk_str);
			}

			if (tok == RCS_TOK_HEAD) {
				if (rfp->rf_head == NULL)
					rfp->rf_head = rcsnum_alloc();
				if (RCS_TOKSTR(rfp)[0] == '\0' ||
				    rcsnum_aton(RCS_TOKSTR(rfp), NULL,
				    rfp->rf_head) < 0) {
					rcsnum_free(rfp->rf_head);
					rfp->rf_head = NULL;
				}
			} else if (tok == RCS_TOK_BRANCH) {
				if (rfp->rf_branch == NULL)
					rfp->rf_branch = rcsnum_alloc();
				if (rcsnum_aton(RCS_TOKSTR(rfp), NULL,
				    rfp->rf_branch) < 0)
					goto fail;
			} else if (tok == RCS_TOK_COMMENT) {
				rfp->rf_comment = xstrdup(RCS_TOKSTR(rfp));
			} else if (tok == RCS_TOK_EXPAND) {
				rfp->rf_expand = xstrdup(RCS_TOKSTR(rfp));
			}

			/* now get the expected semi-colon */
			ntok = rcs_gettok(rfp);
			if (ntok != RCS_TOK_SCOLON) {
				cvs_log(LP_ERR,
				    "missing semi-colon after RCS `%s' key",
				    rk->rk_str);
				goto fail;
			}
			break;
		case RCS_TOK_ACCESS:
			if (rcs_parse_access(rfp) < 0)
				goto fail;
			break;
		case RCS_TOK_SYMBOLS:
			rcs_ignore_keys = 1;
			if (rcs_parse_symbols(rfp) < 0)
				goto fail;
			break;
		case RCS_TOK_LOCKS:
			if (rcs_parse_locks(rfp) < 0)
				goto fail;
			break;
		default:
			cvs_log(LP_ERR,
			    "unexpected token `%s' in RCS admin section",
			    RCS_TOKSTR(rfp));
			goto fail;
		}

		rcs_ignore_keys = 0;

	}

fail:
	return (-1);
}

/*
 * rcs_parse_delta()
 *
 * Parse an RCS delta section and allocate the structure to store that delta's
 * information in the <rfp> delta list.
 * Returns 1 if the section was parsed OK, 0 if it is the last delta, and
 * -1 on error.
 */
static int
rcs_parse_delta(RCSFILE *rfp)
{
	int ret, tok, ntok, hmask;
	u_int i;
	char *tokstr;
	RCSNUM *datenum;
	struct rcs_delta *rdp;
	struct rcs_key *rk;

	tok = rcs_gettok(rfp);
	if (tok == RCS_TOK_DESC) {
		rcs_pushtok(rfp, RCS_TOKSTR(rfp), tok);
		return (0);
	} else if (tok != RCS_TOK_NUM) {
		cvs_log(LP_ERR, "unexpected token `%s' at start of delta",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	rdp = xcalloc(1, sizeof(*rdp));

	rdp->rd_num = rcsnum_alloc();
	rdp->rd_next = rcsnum_alloc();

	TAILQ_INIT(&(rdp->rd_branches));

	rcsnum_aton(RCS_TOKSTR(rfp), NULL, rdp->rd_num);

	hmask = 0;
	ret = 0;
	tokstr = NULL;

	for (;;) {
		tok = rcs_gettok(rfp);
		if (tok == RCS_TOK_ERR) {
			cvs_log(LP_ERR, "parse error in RCS delta section");
			rcs_freedelta(rdp);
			return (-1);
		} else if (tok == RCS_TOK_NUM || tok == RCS_TOK_DESC) {
			rcs_pushtok(rfp, RCS_TOKSTR(rfp), tok);
			ret = (tok == RCS_TOK_NUM ? 1 : 0);
			break;
		}

		rk = NULL;
		for (i = 0; i < RCS_NKEYS; i++)
			if (rcs_keys[i].rk_id == tok)
				rk = &(rcs_keys[i]);

		if (hmask & (1 << tok)) {
			cvs_log(LP_ERR, "duplicate RCS key");
			rcs_freedelta(rdp);
			return (-1);
		}
		hmask |= (1 << tok);

		switch (tok) {
		case RCS_TOK_DATE:
		case RCS_TOK_AUTHOR:
		case RCS_TOK_STATE:
		case RCS_TOK_NEXT:
			ntok = rcs_gettok(rfp);
			if (ntok == RCS_TOK_SCOLON) {
				if (rk->rk_flags & RCS_VOPT)
					break;
				else {
					cvs_log(LP_ERR, "missing mandatory "
					    "value to RCS key `%s'",
					    rk->rk_str);
					rcs_freedelta(rdp);
					return (-1);
				}
			}

			if (ntok != rk->rk_val) {
				cvs_log(LP_ERR,
				    "invalid value type for RCS key `%s'",
				    rk->rk_str);
				rcs_freedelta(rdp);
				return (-1);
			}

			if (tokstr != NULL)
				xfree(tokstr);
			tokstr = xstrdup(RCS_TOKSTR(rfp));
			/* now get the expected semi-colon */
			ntok = rcs_gettok(rfp);
			if (ntok != RCS_TOK_SCOLON) {
				cvs_log(LP_ERR,
				    "missing semi-colon after RCS `%s' key",
				    rk->rk_str);
				xfree(tokstr);
				rcs_freedelta(rdp);
				return (-1);
			}

			if (tok == RCS_TOK_DATE) {
				if ((datenum = rcsnum_parse(tokstr)) == NULL) {
					xfree(tokstr);
					rcs_freedelta(rdp);
					return (-1);
				}
				if (datenum->rn_len != 6) {
					cvs_log(LP_ERR,
					    "RCS date specification has %s "
					    "fields",
					    (datenum->rn_len > 6) ? "too many" :
					    "missing");
					xfree(tokstr);
					rcs_freedelta(rdp);
					rcsnum_free(datenum);
					return (-1);
				}
				rdp->rd_date.tm_year = datenum->rn_id[0];
				if (rdp->rd_date.tm_year >= 1900)
					rdp->rd_date.tm_year -= 1900;
				rdp->rd_date.tm_mon = datenum->rn_id[1] - 1;
				rdp->rd_date.tm_mday = datenum->rn_id[2];
				rdp->rd_date.tm_hour = datenum->rn_id[3];
				rdp->rd_date.tm_min = datenum->rn_id[4];
				rdp->rd_date.tm_sec = datenum->rn_id[5];
				rcsnum_free(datenum);
			} else if (tok == RCS_TOK_AUTHOR) {
				rdp->rd_author = tokstr;
				tokstr = NULL;
			} else if (tok == RCS_TOK_STATE) {
				rdp->rd_state = tokstr;
				tokstr = NULL;
			} else if (tok == RCS_TOK_NEXT) {
				rcsnum_aton(tokstr, NULL, rdp->rd_next);
			}
			break;
		case RCS_TOK_BRANCHES:
			if (rcs_parse_branches(rfp, rdp) < 0) {
				rcs_freedelta(rdp);
				return (-1);
			}
			break;
		default:
			cvs_log(LP_ERR, "unexpected token `%s' in RCS delta",
			    RCS_TOKSTR(rfp));
			rcs_freedelta(rdp);
			return (-1);
		}
	}

	if (tokstr != NULL)
		xfree(tokstr);

	TAILQ_INSERT_TAIL(&(rfp->rf_delta), rdp, rd_list);
	rfp->rf_ndelta++;

	return (ret);
}

/*
 * rcs_parse_deltatext()
 *
 * Parse an RCS delta text section and fill in the log and text field of the
 * appropriate delta section.
 * Returns 1 if the section was parsed OK, 0 if it is the last delta, and
 * -1 on error.
 */
static int
rcs_parse_deltatext(RCSFILE *rfp)
{
	int tok;
	RCSNUM *tnum;
	struct rcs_delta *rdp;

	tok = rcs_gettok(rfp);
	if (tok == RCS_TOK_EOF)
		return (0);

	if (tok != RCS_TOK_NUM) {
		cvs_log(LP_ERR,
		    "unexpected token `%s' at start of RCS delta text",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	tnum = rcsnum_alloc();
	rcsnum_aton(RCS_TOKSTR(rfp), NULL, tnum);

	TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
		if (rcsnum_cmp(tnum, rdp->rd_num, 0) == 0)
			break;
	}
	rcsnum_free(tnum);

	if (rdp == NULL) {
		cvs_log(LP_ERR, "RCS delta text `%s' has no matching delta",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	tok = rcs_gettok(rfp);
	if (tok != RCS_TOK_LOG) {
		cvs_log(LP_ERR, "unexpected token `%s' where RCS log expected",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	tok = rcs_gettok(rfp);
	if (tok != RCS_TOK_STRING) {
		cvs_log(LP_ERR, "unexpected token `%s' where RCS log expected",
		    RCS_TOKSTR(rfp));
		return (-1);
	}
	rdp->rd_log = xstrdup(RCS_TOKSTR(rfp));
	tok = rcs_gettok(rfp);
	if (tok != RCS_TOK_TEXT) {
		cvs_log(LP_ERR, "unexpected token `%s' where RCS text expected",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	tok = rcs_gettok(rfp);
	if (tok != RCS_TOK_STRING) {
		cvs_log(LP_ERR, "unexpected token `%s' where RCS text expected",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	if (RCS_TOKLEN(rfp) == 0) {
		rdp->rd_text = xmalloc(1);
		rdp->rd_text[0] = '\0';
		rdp->rd_tlen = 0;
	} else {
		rdp->rd_text = xmalloc(RCS_TOKLEN(rfp));
		memcpy(rdp->rd_text, RCS_TOKSTR(rfp), RCS_TOKLEN(rfp));
		rdp->rd_tlen = RCS_TOKLEN(rfp);
	}

	return (1);
}

/*
 * rcs_parse_access()
 *
 * Parse the access list given as value to the `access' keyword.
 * Returns 0 on success, or -1 on failure.
 */
static int
rcs_parse_access(RCSFILE *rfp)
{
	int type;

	while ((type = rcs_gettok(rfp)) != RCS_TOK_SCOLON) {
		if (type != RCS_TOK_ID) {
			cvs_log(LP_ERR, "unexpected token `%s' in access list",
			    RCS_TOKSTR(rfp));
			return (-1);
		}

		if (rcs_access_add(rfp, RCS_TOKSTR(rfp)) < 0)
			return (-1);
	}

	return (0);
}

/*
 * rcs_parse_symbols()
 *
 * Parse the symbol list given as value to the `symbols' keyword.
 * Returns 0 on success, or -1 on failure.
 */
static int
rcs_parse_symbols(RCSFILE *rfp)
{
	int type;
	struct rcs_sym *symp;

	for (;;) {
		type = rcs_gettok(rfp);
		if (type == RCS_TOK_SCOLON)
			break;

		if (type != RCS_TOK_ID) {
			cvs_log(LP_ERR, "unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			return (-1);
		}

		symp = xmalloc(sizeof(*symp));
		symp->rs_name = xstrdup(RCS_TOKSTR(rfp));
		symp->rs_num = rcsnum_alloc();

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_COLON) {
			cvs_log(LP_ERR, "unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			rcsnum_free(symp->rs_num);
			xfree(symp->rs_name);
			xfree(symp);
			return (-1);
		}

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_NUM) {
			cvs_log(LP_ERR, "unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			rcsnum_free(symp->rs_num);
			xfree(symp->rs_name);
			xfree(symp);
			return (-1);
		}

		if (rcsnum_aton(RCS_TOKSTR(rfp), NULL, symp->rs_num) < 0) {
			cvs_log(LP_ERR, "failed to parse RCS NUM `%s'",
			    RCS_TOKSTR(rfp));
			rcsnum_free(symp->rs_num);
			xfree(symp->rs_name);
			xfree(symp);
			return (-1);
		}

		TAILQ_INSERT_TAIL(&(rfp->rf_symbols), symp, rs_list);
	}

	return (0);
}

/*
 * rcs_parse_locks()
 *
 * Parse the lock list given as value to the `locks' keyword.
 * Returns 0 on success, or -1 on failure.
 */
static int
rcs_parse_locks(RCSFILE *rfp)
{
	int type;
	struct rcs_lock *lkp;

	for (;;) {
		type = rcs_gettok(rfp);
		if (type == RCS_TOK_SCOLON)
			break;

		if (type != RCS_TOK_ID) {
			cvs_log(LP_ERR, "unexpected token `%s' in lock list",
			    RCS_TOKSTR(rfp));
			return (-1);
		}

		lkp = xmalloc(sizeof(*lkp));
		lkp->rl_name = xstrdup(RCS_TOKSTR(rfp));
		lkp->rl_num = rcsnum_alloc();

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_COLON) {
			cvs_log(LP_ERR, "unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			rcsnum_free(lkp->rl_num);
			xfree(lkp->rl_name);
			xfree(lkp);
			return (-1);
		}

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_NUM) {
			cvs_log(LP_ERR, "unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			rcsnum_free(lkp->rl_num);
			xfree(lkp->rl_name);
			xfree(lkp);
			return (-1);
		}

		if (rcsnum_aton(RCS_TOKSTR(rfp), NULL, lkp->rl_num) < 0) {
			cvs_log(LP_ERR, "failed to parse RCS NUM `%s'",
			    RCS_TOKSTR(rfp));
			rcsnum_free(lkp->rl_num);
			xfree(lkp->rl_name);
			xfree(lkp);
			return (-1);
		}

		TAILQ_INSERT_HEAD(&(rfp->rf_locks), lkp, rl_list);
	}

	/* check if we have a `strict' */
	type = rcs_gettok(rfp);
	if (type != RCS_TOK_STRICT) {
		rcs_pushtok(rfp, RCS_TOKSTR(rfp), type);
	} else {
		rfp->rf_flags |= RCS_SLOCK;

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_SCOLON) {
			cvs_log(LP_ERR,
			    "missing semi-colon after `strict' keyword");
			return (-1);
		}
	}

	return (0);
}

/*
 * rcs_parse_branches()
 *
 * Parse the list of branches following a `branches' keyword in a delta.
 * Returns 0 on success, or -1 on failure.
 */
static int
rcs_parse_branches(RCSFILE *rfp, struct rcs_delta *rdp)
{
	int type;
	struct rcs_branch *brp;

	for (;;) {
		type = rcs_gettok(rfp);
		if (type == RCS_TOK_SCOLON)
			break;

		if (type != RCS_TOK_NUM) {
			cvs_log(LP_ERR,
			    "unexpected token `%s' in list of branches",
			    RCS_TOKSTR(rfp));
			return (-1);
		}

		brp = xmalloc(sizeof(*brp));
		brp->rb_num = rcsnum_parse(RCS_TOKSTR(rfp));
		if (brp->rb_num == NULL) {
			xfree(brp);
			return (-1);
		}

		TAILQ_INSERT_TAIL(&(rdp->rd_branches), brp, rb_list);
	}

	return (0);
}

a1477 184
 * rcs_freepdata()
 *
 * Free the contents of the parser data structure.
 */
static void
rcs_freepdata(struct rcs_pdata *pd)
{
	if (pd->rp_file != NULL)
		(void)fclose(pd->rp_file);
	if (pd->rp_buf != NULL)
		xfree(pd->rp_buf);
	xfree(pd);
}

/*
 * rcs_gettok()
 *
 * Get the next RCS token from the string <str>.
 */
static int
rcs_gettok(RCSFILE *rfp)
{
	u_int i;
	int ch, last, type;
	size_t len;
	char *bp;
	struct rcs_pdata *pdp = (struct rcs_pdata *)rfp->rf_pdata;

	type = RCS_TOK_ERR;
	bp = pdp->rp_buf;
	pdp->rp_tlen = 0;
	*bp = '\0';

	if (pdp->rp_pttype != RCS_TOK_ERR) {
		type = pdp->rp_pttype;
		if (strlcpy(pdp->rp_buf, pdp->rp_ptok, pdp->rp_blen) >=
		    pdp->rp_blen)
			fatal("rcs_gettok: strlcpy");
		pdp->rp_pttype = RCS_TOK_ERR;
		return (type);
	}

	/* skip leading whitespace */
	/* XXX we must skip backspace too for compatibility, should we? */
	do {
		ch = getc(pdp->rp_file);
	} while (isspace(ch));

	if (ch == EOF) {
		type = RCS_TOK_EOF;
	} else if (ch == ';') {
		type = RCS_TOK_SCOLON;
	} else if (ch == ':') {
		type = RCS_TOK_COLON;
	} else if (isalpha(ch)) {
		type = RCS_TOK_ID;
		*(bp++) = ch;
		for (;;) {
			ch = getc(pdp->rp_file);
			if (ch == EOF) {
				type = RCS_TOK_EOF;
				break;
			} else if (!isgraph(ch) ||
			    strchr(rcs_sym_invch, ch) != NULL) {
				ungetc(ch, pdp->rp_file);
				break;
			}
			*(bp++) = ch;
			pdp->rp_tlen++;
			if (bp == pdp->rp_bufend - 1) {
				len = bp - pdp->rp_buf;
				rcs_growbuf(rfp);
				bp = pdp->rp_buf + len;
			}
		}
		*bp = '\0';

		if (type != RCS_TOK_ERR && rcs_ignore_keys != 1) {
			for (i = 0; i < RCS_NKEYS; i++) {
				if (strcmp(rcs_keys[i].rk_str,
				    pdp->rp_buf) == 0) {
					type = rcs_keys[i].rk_id;
					break;
				}
			}
		}
	} else if (ch == '@@') {
		/* we have a string */
		type = RCS_TOK_STRING;
		for (;;) {
			ch = getc(pdp->rp_file);
			if (ch == EOF) {
				type = RCS_TOK_EOF;
				break;
			} else if (ch == '@@') {
				ch = getc(pdp->rp_file);
				if (ch != '@@') {
					ungetc(ch, pdp->rp_file);
					break;
				}
			}

			*(bp++) = ch;
			pdp->rp_tlen++;
			if (bp == pdp->rp_bufend - 1) {
				len = bp - pdp->rp_buf;
				rcs_growbuf(rfp);
				bp = pdp->rp_buf + len;
			}
		}

		*bp = '\0';
	} else if (isdigit(ch)) {
		*(bp++) = ch;
		last = ch;
		type = RCS_TOK_NUM;

		for (;;) {
			ch = getc(pdp->rp_file);
			if (ch == EOF) {
				type = RCS_TOK_EOF;
				break;
			}
			if (bp == pdp->rp_bufend)
				break;
			if (!isdigit(ch) && ch != '.') {
				ungetc(ch, pdp->rp_file);
				break;
			}

			if (last == '.' && ch == '.') {
				type = RCS_TOK_ERR;
				break;
			}
			last = ch;
			*(bp++) = ch;
			pdp->rp_tlen++;
		}
		*bp = '\0';
	}

	return (type);
}

/*
 * rcs_pushtok()
 *
 * Push a token back in the parser's token buffer.
 */
static int
rcs_pushtok(RCSFILE *rfp, const char *tok, int type)
{
	struct rcs_pdata *pdp = (struct rcs_pdata *)rfp->rf_pdata;

	if (pdp->rp_pttype != RCS_TOK_ERR)
		return (-1);

	pdp->rp_pttype = type;
	if (strlcpy(pdp->rp_ptok, tok, sizeof(pdp->rp_ptok)) >=
	    sizeof(pdp->rp_ptok))
		fatal("rcs_pushtok: strlcpy");
	return (0);
}


/*
 * rcs_growbuf()
 *
 * Attempt to grow the internal parse buffer for the RCS file <rf> by
 * RCS_BUFEXTSIZE.
 * In case of failure, the original buffer is left unmodified.
 */
static void
rcs_growbuf(RCSFILE *rf)
{
	struct rcs_pdata *pdp = (struct rcs_pdata *)rf->rf_pdata;

	pdp->rp_buf = xrealloc(pdp->rp_buf, 1,
	    pdp->rp_blen + RCS_BUFEXTSIZE);
	pdp->rp_blen += RCS_BUFEXTSIZE;
	pdp->rp_bufend = pdp->rp_buf + pdp->rp_blen - 1;
}

/*
d1520 2
a1521 1
	rcs_parse_deltatexts(rfp, NULL);
d1753 2
a1754 1
	rcs_parse_deltatexts(rfp, hrdp->rd_num);
d1819 2
a1820 1
			rcs_parse_deltatexts(rfp, rdp->rd_num);
d1990 3
a1992 1
				rcs_parse_deltatexts(rfp, rdp->rd_num);
@


1.301
log
@Fixed typo.

ok ray, zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.300 2010/09/03 08:37:52 tobias Exp $	*/
d222 1
a222 1
static void	rcs_parse_desc(RCSFILE *, RCSNUM *);
d1578 1
a1578 1
		rcs_parse_desc(rfp, rev);
d1602 1
a1602 1
rcs_parse_desc(RCSFILE *rfp, RCSNUM *rev)
d1609 1
a1609 1
		rcs_parse_deltas(rfp, rev);
@


1.300
log
@Rename RCSNUM's fd to rf_fd, complies to other variable names and
OpenRCS.

ok xsa, zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.299 2010/09/02 00:21:41 tobias Exp $	*/
d1628 1
a1628 1
 * Initial parsing of file <path>, which are in the RCS format.
@


1.299
log
@rcsnum_parse() allocates already an RCSNUM struct, so it's not needed to
copy it into a newly allocated one (which is even a memory leak).

ok zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.298 2010/07/31 11:37:37 nicm Exp $	*/
d272 1
a272 1
	rfp->fd = fd;
d1643 1
a1643 1
	if ((pdp->rp_file = fdopen(rfp->fd, "r")) == NULL)
d1661 2
a1662 2
		(void)close(rfp->fd);
		rfp->fd = -1;
@


1.298
log
@When looking for revision, break out of the loop at the end rather than
looping forever.

This prevents the server going into an infinite loop when the repository
is behind the checkout, but the behaviour is not correct (it is an error
rather than ignoring the file), so mark with an XXX for now. Some
underlying OpenCVS functions are too fatal()-happy and will probably
need to be changed in order to fix this properly.

Problem reported by sthen.

ok xsa ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.297 2010/07/23 21:46:05 ray Exp $	*/
d1215 1
a1215 2
			rf->rf_head = rcsnum_alloc();
			rcsnum_cpy(rev, rf->rf_head, 0);
@


1.297
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.296 2010/07/23 08:31:19 ray Exp $	*/
d2786 7
@


1.296
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.295 2010/07/21 09:22:17 ray Exp $	*/
d214 2
a215 2
int		rcs_patch_lines(struct cvs_lines *, struct cvs_lines *,
		    struct cvs_line **, struct rcs_delta *);
d235 2
a236 2
static void	rcs_kwexp_line(char *, struct rcs_delta *, struct cvs_lines *,
		    struct cvs_line *, int mode);
d1028 2
a1029 2
rcs_patch_lines(struct cvs_lines *dlines, struct cvs_lines *plines,
    struct cvs_line **alines, struct rcs_delta *rdp)
d1033 1
a1033 1
	struct cvs_line *lp, *dlp, *ndlp;
d1139 2
a1140 2
	struct cvs_lines *plines;
	struct cvs_line *lp;
d1342 1
a1342 1
		newdiff = cvs_buf_alloc(64);
d2507 2
a2508 2
	len = cvs_buf_len(bp);
	dtext = cvs_buf_release(bp);
d2712 1
a2712 1
 * return it as a pointer to a struct cvs_lines.
d2714 2
a2715 2
struct cvs_lines *
rcs_rev_getlines(RCSFILE *rfp, RCSNUM *frev, struct cvs_line ***alines)
d2723 2
a2724 2
	struct cvs_line *line, *nline;
	struct cvs_lines *dlines, *plines;
d2762 1
a2762 1
			*alines = xcalloc(i + 1, sizeof(struct cvs_line *));
d2818 1
a2818 1
			*alines = xcalloc(i + 1, sizeof(struct cvs_line *));
d2894 1
a2894 1
rcs_annotate_getlines(RCSFILE *rfp, RCSNUM *frev, struct cvs_line ***alines)
d2902 2
a2903 2
	struct cvs_line *line;
	struct cvs_lines *dlines, *plines;
d2995 1
a2995 1
	*alines = xcalloc(i + 1, sizeof(struct cvs_line *));
d3018 2
a3019 2
	struct cvs_lines *lines;
	struct cvs_line *lp, *nlp;
d3024 1
a3024 1
	bp = cvs_buf_alloc(1024 * 16);
d3051 1
a3051 1
			cvs_buf_append(bp, lp->l_line, lp->l_len);
d3074 2
a3075 2
	struct cvs_lines *lines;
	struct cvs_line *lp, *nlp;
d3160 2
a3161 2
rcs_kwexp_line(char *rcsfile, struct rcs_delta *rdp, struct cvs_lines *lines,
    struct cvs_line *line, int mode)
d3353 1
a3353 1
				struct cvs_line *cur, *lp;
d3493 1
a3493 1
		tmpbuf = cvs_buf_alloc(len + strlen(expbuf));
d3495 1
a3495 1
		cvs_buf_append(tmpbuf, line->l_line,
d3498 1
a3498 1
		cvs_buf_puts(tmpbuf, expbuf);
d3500 1
a3500 1
		tlen = cvs_buf_len(tmpbuf) - 1;
d3502 1
a3502 1
		cvs_buf_append(tmpbuf, end,
d3504 1
a3504 1
		c = cvs_buf_get(tmpbuf) + tlen;
d3506 1
a3506 1
		fin = cvs_buf_get(tmpbuf) + cvs_buf_len(tmpbuf) - 1;
d3508 1
a3508 1
		len = cvs_buf_len(tmpbuf);
d3514 1
a3514 1
		line->l_line = cvs_buf_release(tmpbuf);
@


1.295
log
@Only use username if author is NULL. Fixes "ci -wusername" when run
as root.

OK nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.294 2010/07/13 20:41:55 nicm Exp $	*/
d402 1
a402 1
	cvs_worklist_add(fn, &temp_files);
d499 1
a499 1
		if (rdp->rd_text != NULL) {
a500 1
		}
d1067 1
a1067 1
				dlp = TAILQ_PREV(dlp, cvs_tqh, l_list);
d1092 1
a1092 1
					    cvs_tqh);
d1335 1
a1335 1
	nextrdp = (struct rcs_delta *)TAILQ_PREV(rdp, cvs_tqh, rd_list);
d3150 1
a3150 1
	cvs_worklist_add(template, &temp_files);
@


1.294
log
@PR 6423 fix for cvs too, requested by xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.293 2010/07/09 20:07:05 naddy Exp $	*/
d1197 1
a1197 2
 * If <username> is NULL, set the author for this revision to the current user.
 * Otherwise, set it to <username>.
d1202 1
a1202 1
    const char *username)
a1208 1
	uid_t uid;
a1227 4
	uid = getuid();
	if ((pw = getpwuid(uid)) == NULL)
		fatal("getpwuid failed");

d1237 6
a1242 6
	if (uid == 0)
		username = getlogin();
	if (username == NULL || *username == '\0')
		username = pw->pw_name;

	rdp->rd_author = xstrdup(username);
@


1.293
log
@Make cvs and rcs consistent in what characters they'll accept in
symbol/tag names: require the first character to be a letter and
allow any printable character (except the RCS specials $,.:;@@)
afterwards.  This matches GNU cvs.

ok xsa@@ zinovik@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.292 2010/03/30 16:56:32 zinovik Exp $	*/
d495 1
a495 1
			if (rdp->rd_log[len-1] != '\n')
@


1.292
log
@This diff synchronizes rcs parser code with OpenRCS.  It shrinks code by 3
lines, but does exactly the same thing.  It also removes unneeded variable
`buf'

ok deraadt@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.291 2009/06/07 08:39:13 ray Exp $	*/
d2342 2
a2343 2
			} else if (!isalnum(ch) && ch != '_' && ch != '-' &&
			    ch != '/' && ch != '+' && ch != '|') {
@


1.291
log
@More cvs/diff/rcs convergence:
1. Mostly variable/function renaming, SIZE_T_MAX->SIZE_MAX, and
spacing.
2. One strchr -> strncspn.
3. diff had a weird thing where it set file[12] = ofile[12] but
never updated file or ofile, then if file and ofile were different
it freed it. I removed it.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.290 2009/06/06 14:17:27 ray Exp $	*/
d369 1
a369 1
	char buf[1024], numbuf[CVS_REV_BUFSZ], *fn, tmpdir[MAXPATHLEN];
d427 1
a427 5
		if (strlcpy(buf, symp->rs_name, sizeof(buf)) >= sizeof(buf) ||
		    strlcat(buf, ":", sizeof(buf)) >= sizeof(buf) ||
		    strlcat(buf, numbuf, sizeof(buf)) >= sizeof(buf))
			fatal("rcs_write: string overflow");
		fprintf(fp, "\n\t%s", buf);
@


1.290
log
@Sync some rcsdiff changes to cvsdiff.  As a side effect,
cvs diff -t now works.  There should be no functional change
otherwise.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.289 2009/03/30 21:45:33 joris Exp $	*/
d1363 1
a1363 1
		if (cvs_diffreg(path_tmp1, path_tmp2,
@


1.289
log
@kill rp_lines, we do not need it when parsing an RCS file.

incendently, commit made using opencvs entirely.
with permission from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.288 2009/03/25 21:23:17 joris Exp $	*/
d1364 1
a1364 1
		    fd1, fd2, newdiff) == D_ERROR)
@


1.288
log
@prevent a very difficult to reach, but possible use after free.
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.287 2009/03/22 18:39:10 tobias Exp $	*/
a82 2
	u_int	rp_lines;

a1652 1
	pdp->rp_lines = 0;
a2329 2
		if (ch == '\n')
			pdp->rp_lines++;
d2384 1
a2384 2
			} else if (ch == '\n')
				pdp->rp_lines++;
@


1.287
log
@Properly free allocated memory in error case.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.286 2009/02/21 19:46:40 tobias Exp $	*/
d3543 1
a3543 1
	RCSNUM *brev, *frev, *rev, *rrev;
d3547 1
a3547 1
	brev = frev = rrev = NULL;
d3570 1
a3570 1
			frev = rrev = rcsnum_parse(revstr);
a3581 2
		if (rrev != NULL)
			rcsnum_free(rrev);
a3609 3
	if (frev != NULL)
		rcsnum_tostr(frev, branch, sizeof(branch));

d3613 1
@


1.286
log
@Properly convert dates between timezones before comparison.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.285 2009/02/18 20:08:24 joris Exp $	*/
d617 1
a617 5
		if (sym != NULL) {
			if (rcsnum_inc(brev) == NULL ||
			    rcsnum_inc(brev) == NULL)
				return (NULL);
		} else
d619 6
@


1.285
log
@fix off by one character when constructing $Mdocdate$.
problem found by todd@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.284 2009/02/15 13:40:33 joris Exp $	*/
d3621 1
a3621 1
		deltatime = timelocal(&(rdp->rd_date));
@


1.284
log
@add our temporary RCS file to our temp_files worklist in case
for some reason we get interrupted before calling rename().

we hate leaving behind temporary files.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.283 2009/01/02 00:11:01 canacar Exp $	*/
d3337 1
a3337 1
				        "%B%e %Y " : "%B %e %Y",
@


1.283
log
@Add format attributes to functions that use variable arguments and
make the code -Wformat=2 clean. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.282 2008/11/09 08:51:43 tobias Exp $	*/
d403 2
@


1.282
log
@Removed unneeded conversion from RCSNUM to string in rcs_rev_setlog.

oki joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.281 2008/09/17 06:47:57 reyk Exp $	*/
a3181 1
	char *fmt;
d3316 2
a3317 3
				fmt = "%Y/%m/%d %H:%M:%S ";

				if (strftime(buf, sizeof(buf), fmt,
d3333 3
a3335 6
				if (rdp->rd_date.tm_mday < 10)
					fmt = "%B%e %Y ";
				else
					fmt = "%B %e %Y ";

				if (strftime(buf, sizeof(buf), fmt,
d3409 2
a3410 2
				fmt = "  %Y/%m/%d %H:%M:%S  ";
				if (strftime(buf, sizeof(buf), fmt,
@


1.281
log
@try getlogin() to get the real username when comitting files as root.
this gives better information in log messages when the user logged in
with a different uid and used sudo or su to become root. matches the
behaviour of gcvs except that we don't fallback to LOGNAME or USER
since getlogin() should not lie.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.280 2008/09/12 13:24:24 tobias Exp $	*/
d2542 1
a2542 1
 * Sets the log message of revision <rev> to <logtext>
a2547 3
	char buf[CVS_REV_BUFSZ];

	rcsnum_tostr(rev, buf, sizeof(buf));
@


1.280
log
@Plugged two memory leaks which could be encountered while using -r argument
with various CVS commands.

"seems to make sense" xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.279 2008/09/12 13:11:15 tobias Exp $	*/
d1212 1
d1232 2
a1233 1
	if ((pw = getpwuid(getuid())) == NULL)
d1245 3
a1247 1
	if (username == NULL)
@


1.279
log
@Be very conservative about state changes with "admin -s".  With GNU CVS
and current OpenCVS code it's possible to change a state in a way that
cannot be fixed with another admin call.

No objections xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.278 2008/06/26 21:31:40 joris Exp $	*/
d2648 1
a2648 1
			return NULL;
d2658 2
a2659 5
		if ((rdp = rcs_findrev(rfp, rev)) != NULL) {
			frev = rcsnum_alloc();
			rcsnum_cpy(rev, frev, 0);
			return (frev);
		}
d2681 1
a2681 4
		if (rfp->rf_head == NULL)
			return NULL;

		if (rcsnum_cmp(rev, rfp->rf_head,
d2684 1
a2684 1
			return NULL;
@


1.278
log
@plug a memleak in rcs_rev_getlines() - initially noticed & diff by
Igor Zinovik - but fixed in a better way by myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.277 2008/06/15 04:44:06 joris Exp $	*/
d2611 1
a2611 1
	if (strchr(state, ' ') != NULL)
@


1.277
log
@if we are using RCS_PARSE_FULLY we can close the RCS file descriptor
as soon as we are done parsing, since we no longer need it for anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.275 2008/06/14 04:34:08 tobias Exp $	*/
d2753 2
a2754 2
	if (RCSNUM_ISBRANCHREV(tnum)) {
		bnum = rcsnum_alloc();
d2756 2
a2757 3
	} else {
		bnum = tnum;
	}
d2785 1
a2785 2
			if (bnum == tnum)
				bnum = rcsnum_alloc();
d2841 1
a2841 2
			if (bnum == tnum)
				bnum = rcsnum_alloc();
d2874 1
a2874 2
				if (bnum != tnum)
					rcsnum_free(bnum);
@


1.276
log
@Support the addition of new files in branches.

ok joris
@
text
@d1666 1
a1666 1
	if (rfp->rf_flags & RCS_PARSE_FULLY)
d1668 3
@


1.275
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.274 2008/06/14 03:58:29 tobias Exp $	*/
d596 29
@


1.274
log
@Added support for sticky date set in CVS/Tag and CVS/Entries per directory.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.273 2008/06/14 03:19:15 joris Exp $	*/
d779 1
a779 1
	if (!rcs_sym_check(sym))
d1188 2
d1192 2
d1296 3
d1673 4
d1709 6
a1714 2
				rcsnum_aton(RCS_TOKSTR(rfp), NULL,
				    rfp->rf_head);
d2652 3
d2712 2
a2713 1
	if ((hrdp = rcs_findrev(rfp, rfp->rf_head)) == NULL)
@


1.273
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.272 2008/06/14 00:47:49 tobias Exp $	*/
d3504 1
d3545 6
a3550 1
	if (cvs_specified_date == -1) {
d3585 1
a3585 1
			if (deltatime > cvs_specified_date) {
d3604 1
a3604 1
			if (deltatime < cvs_specified_date) {
@


1.272
log
@Fixed wrong function name in fatal call.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.271 2008/06/12 17:06:17 joris Exp $	*/
d2995 1
a2995 1
	bp = cvs_buf_alloc(1024 * 1024);
d3038 1
a3038 1
rcs_rev_write_fd(RCSFILE *rfp, RCSNUM *rev, int fd, int mode)
d3040 3
d3065 7
d3090 2
a3091 1
				if (atomicio(vwrite, fd, "M ", 2) != 2)
d3096 2
a3097 2
			if (atomicio(vwrite, fd, lp->l_line, lp->l_len) !=
			    lp->l_len)
d3103 1
a3103 1

a3618 1

@


1.271
log
@we should be able to handle symbol names that are also RCS tokens,
gnu cvs supports this and we should too really.

allows opencvs to properly checkout netbsd trees.

spotted & tested by rivo nurges
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.270 2008/06/12 07:16:14 joris Exp $	*/
d3545 1
a3545 1
				fatal("rcs_get_revision: could not fetch "
@


1.270
log
@completely kill the need for TMP_DIR when running checkout,
which gives us better performance among other things.

this is however disabled in a few cases:
1) whenever you run checkout over an existing tree (which acts as update)
2) whenever you specify -d or a module alias

we're planning on enabling this behaviour for case 2 in the future.

anoncvs sysadmins now love us even more.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.269 2008/06/10 20:30:17 joris Exp $	*/
d240 2
d1726 1
d1740 3
d2311 1
a2311 1
		if (type != RCS_TOK_ERR) {
@


1.269
log
@properly inherit file permissions.

reported & tested by phessler@@
input otto@@ deraadt@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.268 2008/06/10 16:05:04 joris Exp $	*/
d2989 1
a2989 1
	bp = cvs_buf_alloc(1024);
@


1.268
log
@more characters are allowed in the symbol lists, found by tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.267 2008/06/10 05:01:36 tobias Exp $	*/
d247 1
d259 4
d506 1
@


1.267
log
@We have a cvs_buf_puts implementation now, also use cvs_buf_putc instead
of cvs_buf_append where appropiate.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.266 2008/06/08 13:36:30 tobias Exp $	*/
d2285 1
a2285 1
			    ch != '/' && ch != '+') {
@


1.266
log
@rcs_translate_tag mustn't fatal() if it cannot resolve a tag.  Breaks '-f'
in (r)annotate and (r)diff.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.265 2008/05/22 07:57:58 joris Exp $	*/
d3451 1
a3451 1
		cvs_buf_append(tmpbuf, expbuf, strlen(expbuf));
@


1.265
log
@fix updating to tags pointing at branch revisions;
from Neels Janosch Hofmeyr and Stefan Sperling
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.264 2008/05/17 21:06:44 tobias Exp $	*/
d3497 1
a3497 1
		fatal("rcs_translate_tag: cannot find revision");
@


1.264
log
@Full support of branches added.  We lacked proper support of multiple
branch entry points in one revision as well as branches which started from
other branches.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.263 2008/05/11 12:13:41 tobias Exp $	*/
d2615 1
a2615 2
	 * revision for the given name if it is not newer than HEAD.
	 */
d2617 10
a2626 1
		if (rcsnum_cmp(rev, rfp->rf_head, 0) < 0) {
@


1.263
log
@Memory leak in rcs_delta_stats plugged.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.262 2008/03/13 17:01:25 joris Exp $	*/
d1171 1
a1171 1
	RCSNUM *root;
d1173 1
a1173 1
	struct rcs_branch *brp;
d1223 17
a1239 10
			root = rcsnum_branch_root(rev);
			brp = xmalloc(sizeof(*brp));
			brp->rb_num = rcsnum_alloc();
			rcsnum_cpy(rdp->rd_num, brp->rb_num, 0);
			if ((ordp = rcs_findrev(rf, root)) == NULL)
				fatal("root node not found");
			if (TAILQ_EMPTY(&(ordp->rd_branches))) {
				TAILQ_INSERT_TAIL(&(ordp->rd_branches),
			    brp, rb_list);
			}
d1241 10
a1250 2
			ordp = TAILQ_PREV(rdp, rcs_dlist, rd_list);
			if (RCSNUM_ISBRANCHREV(ordp->rd_num))
d1252 1
d1259 3
d3471 1
a3471 1
	RCSNUM *brev, *frev, *rev;
d3474 1
a3474 1
	brev = frev = NULL;
d3491 22
d3515 1
a3515 1
		if (rev->rn_len < 4) {
a3531 12
	}

	/* let's see if we must follow a branch */
	if (!strcmp(revstr, RCS_HEAD_BRANCH))
		follow = 1;
	else {
		frev = rcs_sym_getrev(rfp, revstr);

		if (frev != NULL && RCSNUM_ISBRANCH(frev))
			follow = 1;
		else
			follow = 0;
@


1.262
log
@properly initialize variables
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.261 2008/03/09 19:41:13 tobias Exp $	*/
d1146 2
@


1.261
log
@Fix segmentation fault when running checkout -p on a file without
specified head revision.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.260 2008/03/08 22:33:03 joris Exp $	*/
d1279 1
@


1.260
log
@better -j support
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.259 2008/03/08 20:52:36 tobias Exp $	*/
d1354 3
d2566 3
@


1.259
log
@Set umask (and cvs_umask) to system's umask in local and client mode.
Also zap umask(0);umask(mask); calls, we have cvs_umask for this.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.258 2008/03/08 20:26:34 joris Exp $	*/
a3463 1

d3501 1
a3501 1
		brev->rn_len = rev->rn_len;
d3514 4
d3520 6
@


1.258
log
@add checkout/update -j support.
still has some rough edges.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.257 2008/03/08 11:53:36 joris Exp $	*/
d244 1
a244 1
	mode_t fmode, mask;
d260 1
a260 3
	mask = umask(0);
	umask(mask);
	fmode &= ~mask;
@


1.257
log
@correct usage of lseek(2);
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.256 2008/03/02 19:31:08 tobias Exp $	*/
a2624 8
		/* Find the latest delta on that branch */
		for (;;) {
			if (rdp->rd_next->rn_len == 0)
				break;
			if ((rdp = rcs_findrev(rfp, rdp->rd_next)) == NULL)
				fatal("rcs_get_revision: could not fetch "
				    "branch delta");
		}
d3443 1
d3460 26
a3485 1
		return NULL;
d3499 2
a3500 5
	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		fatal("rcs_translate_tag: cannot find revision");

	if (cvs_specified_date == -1)
		return rev;
d3510 17
a3526 4
		if (timelocal(&(rdp->rd_date)) < cvs_specified_date) {
			rev = rcsnum_alloc();
			rcsnum_cpy(rdp->rd_num, rev, 0);
			return rev;
d3541 1
a3541 1
	return NULL;
@


1.256
log
@rcs_errno is gone: zap rcs_errstr() and rcs_errstrs[] as well.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.255 2008/03/01 21:29:37 deraadt Exp $	*/
d3075 1
a3075 1
	if (lseek(fd, SEEK_SET, 0) < 0)
@


1.255
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.254 2008/03/01 20:03:56 joris Exp $	*/
a214 11
static const char *rcs_errstrs[] = {
	"No error",
	"No such entry",
	"Duplicate entry found",
	"Bad RCS number",
	"Invalid RCS symbol",
	"Parse error",
};

#define RCS_NERR   (sizeof(rcs_errstrs)/sizeof(rcs_errstrs[0]))

a1467 19
}

/*
 * rcs_errstr()
 *
 * Get the error string matching the RCS error code <code>.
 */
const char *
rcs_errstr(int code)
{
	const char *esp;

	if (code < 0 || (code >= (int)RCS_NERR && code != RCS_ERR_ERRNO))
		esp = NULL;
	else if (code == RCS_ERR_ERRNO)
		esp = strerror(errno);
	else
		esp = rcs_errstrs[code];
	return (esp);
@


1.254
log
@goodbye rcs_errno - we didnt use you and you wont be missed
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.253 2008/02/28 21:55:48 tobias Exp $	*/
d3002 1
a3002 1
	for(lp = TAILQ_FIRST(&lines->l_lines); lp != NULL;) {
d3054 1
a3054 1
	for(lp = TAILQ_FIRST(&lines->l_lines); lp != NULL;) {
@


1.253
log
@RCS files can have a default expansion mode, keep this in mind for
update -A and -k.

spotted by and ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.252 2008/02/28 20:24:25 joris Exp $	*/
a225 2
int rcs_errno = RCS_ERR_NOERR;

d645 1
a645 2
		if (strcmp(ap->ra_name, login) == 0) {
			rcs_errno = RCS_ERR_DUPENT;
a646 1
		}
d674 1
a674 2
	if (ap == NULL) {
		rcs_errno = RCS_ERR_NOENT;
a675 1
	}
a690 1
 * Returns 0 on success, or -1 on failure.
d697 1
a697 2
	if (!rcs_sym_check(sym)) {
		rcs_errno = RCS_ERR_BADSYM;
a698 1
	}
d702 2
a703 4
		if (strcmp(symp->rs_name, sym) == 0) {
			rcs_errno = RCS_ERR_DUPENT;
			return (-1);
		}
d731 1
a731 2
	if (!rcs_sym_check(sym)) {
		rcs_errno = RCS_ERR_BADSYM;
a732 1
	}
d738 1
a738 2
	if (symp == NULL) {
		rcs_errno = RCS_ERR_NOENT;
a739 1
	}
d784 1
a784 2
	if (!rcs_sym_check(sym)) {
		rcs_errno = RCS_ERR_BADSYM;
a785 1
	}
d798 1
a798 3
	if (symp == NULL) {
		rcs_errno = RCS_ERR_NOENT;
	} else {
d881 1
a881 2
		    rcsnum_cmp(rev, lkp->rl_num, 0) == 0) {
			rcs_errno = RCS_ERR_DUPENT;
a882 1
		}
d915 1
a915 2
	if (lkp == NULL) {
		rcs_errno = RCS_ERR_NOENT;
a916 1
	}
d968 1
a968 2
	if ((sp = strrchr(filename, '.')) == NULL) {
		rcs_errno = RCS_ERR_NOENT;
a969 1
	}
d1197 1
a1197 2
		if ((rdp = rcs_findrev(rf, rev)) != NULL) {
			rcs_errno = RCS_ERR_DUPENT;
a1198 1
		}
d1277 1
a1277 2
	if ((rdp = rcs_findrev(rf, rev)) == NULL) {
		rcs_errno = RCS_ERR_NOENT;
a1278 1
	}
a1656 1
			rcs_errno = RCS_ERR_PARSE;
a1674 1
			rcs_errno = RCS_ERR_PARSE;
a1688 1
				rcs_errno = RCS_ERR_PARSE;
a1713 1
				rcs_errno = RCS_ERR_PARSE;
a1732 1
			rcs_errno = RCS_ERR_PARSE;
a1766 1
		rcs_errno = RCS_ERR_PARSE;
a1787 1
			rcs_errno = RCS_ERR_PARSE;
a1802 1
			rcs_errno = RCS_ERR_PARSE;
a1818 1
					rcs_errno = RCS_ERR_PARSE;
a1827 1
				rcs_errno = RCS_ERR_PARSE;
a1840 1
				rcs_errno = RCS_ERR_PARSE;
a1855 1
					rcs_errno = RCS_ERR_PARSE;
a1891 1
			rcs_errno = RCS_ERR_PARSE;
a1927 1
		rcs_errno = RCS_ERR_PARSE;
a1950 1
		rcs_errno = RCS_ERR_PARSE;
a1957 1
		rcs_errno = RCS_ERR_PARSE;
a1964 1
		rcs_errno = RCS_ERR_PARSE;
a1971 1
		rcs_errno = RCS_ERR_PARSE;
a2002 1
			rcs_errno = RCS_ERR_PARSE;
a2032 1
			rcs_errno = RCS_ERR_PARSE;
a2043 1
			rcs_errno = RCS_ERR_PARSE;
a2053 1
			rcs_errno = RCS_ERR_PARSE;
a2094 1
			rcs_errno = RCS_ERR_PARSE;
a2105 1
			rcs_errno = RCS_ERR_PARSE;
a2115 1
			rcs_errno = RCS_ERR_PARSE;
a2144 1
			rcs_errno = RCS_ERR_PARSE;
a2171 1
			rcs_errno = RCS_ERR_PARSE;
@


1.252
log
@kill way out of date stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.251 2008/02/27 22:34:04 joris Exp $	*/
d1480 3
@


1.251
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.250 2008/02/20 09:19:04 joris Exp $	*/
a3134 2

	/* XXX: do we need to call futimes(2) on the output fd? */
@


1.250
log
@make sure we use the default branch (if available)
in rcs_translate_tag() if we are looking for a revision on the trunk.

fixes inconsistancy with gnu cvs.

problem noticed by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.249 2008/02/11 20:33:11 tobias Exp $	*/
d1295 1
d1327 1
a1327 1
		rcs_rev_write_stmp(rf, nextrdp->rd_num, path_tmp1, 0);
d1330 1
a1330 1
		rcs_rev_write_stmp(rf, prevrdp->rd_num, path_tmp2, 0);
d1333 2
a1334 1
		if (cvs_diffreg(path_tmp1, path_tmp2, newdiff) == D_ERROR)
d1337 3
d3149 1
a3149 1
void
d3160 4
a3163 1
	(void)close(fd);
@


1.249
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.248 2008/02/10 10:21:42 joris Exp $	*/
d3528 1
d3534 8
a3541 2
	if (revstr == NULL)
		revstr = RCS_HEAD_BRANCH;
@


1.248
log
@properly initialize cvs_specified_date so we dont end up with
random stuff going on
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.247 2008/02/09 13:41:22 joris Exp $	*/
d1322 1
a1322 1
		newdiff = cvs_buf_alloc(64, BUF_AUTOEXT);
d3035 1
a3035 1
	bp = cvs_buf_alloc(1024, BUF_AUTOEXT);
d3497 1
a3497 1
		tmpbuf = cvs_buf_alloc(len + strlen(expbuf), BUF_AUTOEXT);
@


1.247
log
@fix error msg;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.246 2008/02/09 11:17:02 tobias Exp $	*/
d3554 1
a3554 1
	if (cvs_specified_date == 0)
@


1.246
log
@Get in initial support for checkout -D.  Works fine with -r support right
now.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.245 2008/02/03 16:59:11 tobias Exp $	*/
d3552 1
a3552 1
		fatal("rcs_datetorev: cannot find revision");
@


1.245
log
@Do not unify this "-fr UNKNOWN" handling, it breaks commands which have
to work fine and just ignore files which don't have requested symbol.

Spotted by joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.244 2008/02/02 16:59:48 tobias Exp $	*/
d228 1
d2631 3
a2633 3
/* rcs_translate_tag() */
RCSNUM *
rcs_translate_tag(const char *revstr, RCSFILE *rfp)
d2681 1
a2681 1
		fatal("rcs_translate_tag: tag `%s' does not exist", revstr);
d2701 2
a2702 1
			fatal("rcs_translate_tag: could not fetch branch delta");
d2708 2
a2709 1
				fatal("rcs_translate_tag: could not fetch branch delta");
d3522 64
@


1.244
log
@Although this doesn't comply to common sense, it complies to GNU cvs. All
commands which supply -f and -r have this weirdness: an unknown
symbol leads to fatal instead of head revision.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.243 2008/01/31 22:19:36 tobias Exp $	*/
a2659 6
	/*
	 * Although many cvs commands do have option -f to force head
	 * if a revision is not found, GNU cvs simply fatals with
	 * unknown symbols.  If we reach this point rev is still NULL,
	 * do the same...
	 */
d2661 1
a2661 1
		fatal("no such tag %s", revstr);
@


1.243
log
@Handle magic branch numbers in OpenCVS as well.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.242 2008/01/31 21:49:17 joris Exp $	*/
d2660 6
d2667 1
a2667 1
		return (NULL);
@


1.242
log
@in some cases we did not return a copy of the resulting RCSNUM
towards the caller, which expects a copy (and frees it when done).

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.241 2008/01/31 20:29:16 joris Exp $	*/
d431 2
@


1.241
log
@add changed lines support to log and rlog (the + and - stuff)
from Pierre Riteau;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.240 2008/01/28 21:33:20 tobias Exp $	*/
d2648 5
a2652 2
		if ((rdp = rcs_findrev(rfp, rev)) != NULL)
			return (rev);
@


1.240
log
@Properly free "rev".

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.239 2008/01/14 17:29:21 tobias Exp $	*/
d1135 49
@


1.239
log
@Changed xmalloc(n * m) pattern into xcalloc(n, m).

OK ray@@, xsa@@

> Diff from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.238 2008/01/13 11:11:08 tobias Exp $	*/
d2638 1
@


1.238
log
@Typos fixed.

OK xsa@@

> Diff from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.237 2008/01/10 10:48:50 tobias Exp $	*/
d2948 1
a2948 1
	*alines = xmalloc((i + 1) * sizeof(struct cvs_line *));
@


1.237
log
@just for the record: I HATE Log
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.236 2008/01/10 10:15:48 tobias Exp $	*/
d2661 1
a2661 1
 * Get the entire contents of revision <rev> from the RCSFILE <rfp> and
@


1.236
log
@Damnit, I should avoid this nasty Log word in a comment ...
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.235 2008/01/10 09:55:18 tobias Exp $	*/
d3387 1
a3387 53
				 * be done: All characters behind $Log: rcs.c,v $
				 * be done: All characters behind Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind An empty -k option is invalid
				 * be done: All characters behind
				 * be done: All characters behind Revision 1.234  2008/01/10 09:37:26  tobias
				 * be done: All characters behind RCS files without head keyword mustn't segfault our implementation.  Only
				 * be done: All characters behind command that supports such files is "cvs status", therefore properly handle
				 * be done: All characters behind them in all other commands, too.
				 * be done: All characters behind
				 * be done: All characters behind Revision 1.233  2008/01/10 09:35:02  tobias
				 * be done: All characters behind Added support for keyword $Log: rcs.c,v $
				 * be done: All characters behind Added support for keyword Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind Added support for keyword An empty -k option is invalid
				 * be done: All characters behind Added support for keyword
				 * be done: All characters behind Added support for keyword Revision 1.234  2008/01/10 09:37:26  tobias
				 * be done: All characters behind Added support for keyword RCS files without head keyword mustn't segfault our implementation.  Only
				 * be done: All characters behind Added support for keyword command that supports such files is "cvs status", therefore properly handle
				 * be done: All characters behind Added support for keyword them in all other commands, too.
				 * be done: All characters behind Added support for keyword.  In order to support $Log: rcs.c,v $
				 * be done: All characters behind Added support for keyword.  In order to support Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind Added support for keyword.  In order to support An empty -k option is invalid
				 * be done: All characters behind Added support for keyword.  In order to support
				 * be done: All characters behind Added support for keyword $Log: rcs.c,v $
				 * be done: All characters behind Added support for keyword Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind Added support for keyword An empty -k option is invalid
				 * be done: All characters behind Added support for keyword.  In order to support Revision 1.234  2008/01/10 09:37:26  tobias
				 * be done: All characters behind Added support for keyword $Log: rcs.c,v $
				 * be done: All characters behind Added support for keyword Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind Added support for keyword An empty -k option is invalid
				 * be done: All characters behind Added support for keyword.  In order to support RCS files without head keyword mustn't segfault our implementation.  Only
				 * be done: All characters behind Added support for keyword $Log: rcs.c,v $
				 * be done: All characters behind Added support for keyword Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind Added support for keyword An empty -k option is invalid
				 * be done: All characters behind Added support for keyword.  In order to support command that supports such files is "cvs status", therefore properly handle
				 * be done: All characters behind Added support for keyword $Log: rcs.c,v $
				 * be done: All characters behind Added support for keyword Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind Added support for keyword An empty -k option is invalid
				 * be done: All characters behind Added support for keyword.  In order to support them in all other commands, too.
				 * be done: All characters behind Added support for keyword $Log: rcs.c,v $
				 * be done: All characters behind Added support for keyword Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind Added support for keyword An empty -k option is invalid
				 * be done: All characters behind Added support for keyword.  In order to support, new lines have
				 * be done: All characters behind to be added which mustn't be expanded again (this log message for example
				 * be done: All characters behind would loop forever due to $Log: rcs.c,v $
				 * be done: All characters behind would loop forever due to Revision 1.235  2008/01/10 09:55:18  tobias
				 * be done: All characters behind would loop forever due to An empty -k option is invalid
				 * be done: All characters behind would loop forever due to
				 * be done: All characters behind would loop forever due to Revision 1.234  2008/01/10 09:37:26  tobias
				 * be done: All characters behind would loop forever due to RCS files without head keyword mustn't segfault our implementation.  Only
				 * be done: All characters behind would loop forever due to command that supports such files is "cvs status", therefore properly handle
				 * be done: All characters behind would loop forever due to them in all other commands, too.
				 * be done: All characters behind would loop forever due to keywords in it).
				 * be done: All characters behind will be
@


1.235
log
@An empty -k option is invalid
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.234 2008/01/10 09:37:26 tobias Exp $	*/
d3303 1
a3303 26
				/* $Log: rcs.c,v $
				/* Revision 1.234  2008/01/10 09:37:26  tobias
				/* RCS files without head keyword mustn't segfault our implementation.  Only
				/* command that supports such files is "cvs status", therefore properly handle
				/* them in all other commands, too.
				/*
				/* Revision 1.233  2008/01/10 09:35:02  tobias
				/* Added support for keyword $Log: rcs.c,v $
				/* Added support for keyword Revision 1.234  2008/01/10 09:37:26  tobias
				/* Added support for keyword RCS files without head keyword mustn't segfault our implementation.  Only
				/* Added support for keyword command that supports such files is "cvs status", therefore properly handle
				/* Added support for keyword them in all other commands, too.
				/* Added support for keyword.  In order to support $Log: rcs.c,v $
				/* Added support for keyword $Log$.  In order to support Revision 1.234  2008/01/10 09:37:26  tobias
				/* Added support for keyword $Log$.  In order to support RCS files without head keyword mustn't segfault our implementation.  Only
				/* Added support for keyword $Log$.  In order to support command that supports such files is "cvs status", therefore properly handle
				/* Added support for keyword $Log$.  In order to support them in all other commands, too.
				/* Added support for keyword $Log$.  In order to support, new lines have
				/* to be added which mustn't be expanded again (this log message for example
				/* would loop forever due to $Log: rcs.c,v $
				/* would loop forever due to Revision 1.234  2008/01/10 09:37:26  tobias
				/* would loop forever due to RCS files without head keyword mustn't segfault our implementation.  Only
				/* would loop forever due to command that supports such files is "cvs status", therefore properly handle
				/* would loop forever due to them in all other commands, too.
				/* would loop forever due to keywords in it).
				/* line */
d3388 3
d3398 3
d3406 23
a3428 5
				 * be done: All characters behind Added support for keyword $Log$.  In order to support Revision 1.234  2008/01/10 09:37:26  tobias
				 * be done: All characters behind Added support for keyword $Log$.  In order to support RCS files without head keyword mustn't segfault our implementation.  Only
				 * be done: All characters behind Added support for keyword $Log$.  In order to support command that supports such files is "cvs status", therefore properly handle
				 * be done: All characters behind Added support for keyword $Log$.  In order to support them in all other commands, too.
				 * be done: All characters behind Added support for keyword $Log$.  In order to support, new lines have
d3431 3
@


1.234
log
@RCS files without head keyword mustn't segfault our implementation.  Only
command that supports such files is "cvs status", therefore properly handle
them in all other commands, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.233 2008/01/10 09:35:02 tobias Exp $	*/
d1425 2
a1426 1
	len = strlen(flags);
d3304 5
d3310 11
a3320 1
				/* Added support for keyword $Log$.  In order to support $Log$, new lines have
d3322 6
a3327 1
				/* would loop forever due to $Log$ keywords in it).
d3413 5
d3419 11
a3429 1
				 * be done: All characters behind Added support for keyword $Log$.  In order to support $Log$, new lines have
d3431 6
a3436 1
				 * be done: All characters behind would loop forever due to $Log$ keywords in it).
@


1.233
log
@Added support for keyword $Log$.  In order to support $Log$, new lines have
to be added which mustn't be expanded again (this log message for example
would loop forever due to $Log$ keywords in it).
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.232 2008/01/06 14:45:50 tobias Exp $	*/
d546 3
d3302 6
a3307 1
				/* $Log: $ line */
d3391 6
a3396 1
				 * be done: All characters behind $Log$ will be
@


1.232
log
@Branches are separated with \n\t in GNU rcs/cvs.
This makes regress tests easier to check with OpenCVS and GNU cvs.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.231 2007/11/11 14:02:35 tobias Exp $	*/
d249 2
a250 2
static void	rcs_kwexp_line(char *, struct rcs_delta *, struct cvs_line *,
		    int mode);
d2968 1
a2968 1
	struct cvs_line *lp;
d2988 5
a2992 2
	TAILQ_FOREACH(lp, &lines->l_lines, l_list) {
		if (lp->l_line == NULL)
d2994 1
d2997 1
a2997 1
			rcs_kwexp_line(rfp->rf_path, rdp, lp, expmode);
d2999 3
a3001 1
		cvs_buf_append(bp, lp->l_line, lp->l_len);
d3021 1
a3021 1
	struct cvs_line *lp;
d3040 5
a3044 2
	TAILQ_FOREACH(lp, &lines->l_lines, l_list) {
		if (lp->l_line == NULL)
d3046 1
d3049 1
a3049 1
			rcs_kwexp_line(rfp->rf_path, rdp, lp, expmode);
d3051 14
a3064 7
		/*
		 * Solely for the checkout and update -p options.
		 */
		if (cvs_server_active == 1 &&
		    (cvs_cmdop == CVS_OP_CHECKOUT ||
		    cvs_cmdop == CVS_OP_UPDATE) && print_stdout == 1) {
			if (atomicio(vwrite, fd, "M ", 2) != 2)
d3066 1
a3066 4
		}

		if (atomicio(vwrite, fd, lp->l_line, lp->l_len) != lp->l_len)
			fatal("rcs_rev_write_fd: %s", strerror(errno));
d3097 2
a3098 2
rcs_kwexp_line(char *rcsfile, struct rcs_delta *rdp, struct cvs_line *line,
    int mode)
d3293 14
a3306 1
			if (kwtype & RCS_KW_LOG)
d3311 95
@


1.231
log
@Max. 80 chars per line in rcs_kwexp_line. Saved a tab by redoing

for (...) {
	if (something) {
		...
	}
}

into

for (...) {
	if (!something)
		continue;
	...
}

All other lines which were still too long have been splitted up.
No functional change (beside of if-statement).
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.230 2007/11/11 10:14:33 tobias Exp $	*/
d480 1
a480 1
			fprintf(fp, " %s", rcsnum_tostr(brp->rb_num, numbuf,
@


1.230
log
@Do not (re)expand CVS keywords if it is requested to keep old keywords.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.229 2007/11/11 10:01:41 tobias Exp $	*/
d3086 1
d3093 1
a3093 1
	size_t len, kwlen;
d3116 2
a3117 13
		if (*c == '$') {
			BUF *tmpbuf;
			size_t clen, tlen;

			/* remember start of this possible keyword */
			start = c;

			/* first following character has to be alphanumeric */
			c++;
			if (!isalpha(*c)) {
				c = start;
				continue;
			}
d3119 2
a3120 2
			/* Number of characters between c and fin, inclusive. */
			clen = fin - c + 1;
d3122 6
a3127 18
			/* look for any matching keywords */
			found = 0;
			for (j = 0; j < RCS_NKWORDS; j++) {
				kwlen = strlen(rcs_expkw[j].kw_str);
				/*
				 * kwlen must be less than clen since clen
				 * includes either a terminating `$' or a `:'.
				 */
				if (kwlen < clen &&
				    memcmp(c, rcs_expkw[j].kw_str, kwlen) == 0 &&
				    (c[kwlen] == '$' || c[kwlen] == ':')) {
					found = 1;
					kwstr = rcs_expkw[j].kw_str;
					kwtype = rcs_expkw[j].kw_type;
					c += kwlen;
					break;
				}
			}
d3129 2
a3130 17
			if (found == 0 && cvs_tagname != NULL) {
				kwlen = strlen(cvs_tagname);
				if (kwlen < clen &&
				    memcmp(c, cvs_tagname, kwlen) == 0 &&
				    (c[kwlen] == '$' || c[kwlen] == ':')) {
					found = 1;
					kwstr = cvs_tagname;
					kwtype = RCS_KW_ID;
					c += kwlen;
				}
			}

			/* unknown keyword, continue looking */
			if (found == 0) {
				c = start;
				continue;
			}
d3132 4
d3137 2
a3138 3
			 * if the next character was ':' we need to look for
			 * an '$' before the end of the line to be sure it is
			 * in fact a keyword.
d3140 10
a3149 5
			if (*c == ':') {
				for (; c <= fin; ++c) {
					if (*c == '$' || *c == '\n')
						break;
				}
d3151 9
a3159 4
				if (*c != '$') {
					c = start;
					continue;
				}
d3161 1
a3161 1
			end = c + 1;
d3163 5
a3167 2
			/* start constructing the expansion */
			expbuf[0] = '\0';
d3169 9
a3177 7
			if (mode & RCS_KWEXP_NAME) {
				if (strlcat(expbuf, "$", sizeof(expbuf)) >= sizeof(expbuf) ||
				    strlcat(expbuf, kwstr, sizeof(expbuf)) >= sizeof(expbuf))
					fatal("rcs_kwexp_line: truncated");
				if ((mode & RCS_KWEXP_VAL) &&
				    strlcat(expbuf, ": ", sizeof(expbuf)) >= sizeof(expbuf))
					fatal("rcs_kwexp_line: truncated");
d3180 6
a3185 13
			/*
			 * order matters because of RCS_KW_ID and
			 * RCS_KW_HEADER here
			 */
			if (mode & RCS_KWEXP_VAL) {
				if (kwtype & RCS_KW_RCSFILE) {
					if (!(kwtype & RCS_KW_FULLPATH))
						(void)strlcat(expbuf, basename(rcsfile), sizeof(expbuf));
					else
						(void)strlcat(expbuf, rcsfile, sizeof(expbuf));
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: truncated");
				}
d3187 2
a3188 6
				if (kwtype & RCS_KW_REVISION) {
					rcsnum_tostr(rdp->rd_num, buf, sizeof(buf));
					if (strlcat(buf, " ", sizeof(buf)) >= sizeof(buf) ||
					    strlcat(expbuf, buf, sizeof(expbuf)) >= sizeof(buf))
						fatal("rcs_kwexp_line: truncated");
				}
d3190 10
a3199 2
				if (kwtype & RCS_KW_DATE) {
					fmt = "%Y/%m/%d %H:%M:%S ";
d3201 16
a3216 5
					if (strftime(buf, sizeof(buf), fmt, &rdp->rd_date) == 0)
						fatal("rcs_kwexp_line: strftime failure");
					if (strlcat(expbuf, buf, sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: string truncated");
				}
d3218 7
a3224 16
				if (kwtype & RCS_KW_MDOCDATE) {
					/*
					 * Do not prepend ' ' for a single
					 * digit, %e would do so and there is
					 * no better format for strftime().
					 */
					if (rdp->rd_date.tm_mday < 10)
						fmt = "%B%e %Y ";
					else
						fmt = "%B %e %Y ";

					if (strftime(buf, sizeof(buf), fmt, &rdp->rd_date) == 0)
						fatal("rcs_kwexp_line: strftime failure");
					if (strlcat(expbuf, buf, sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: string truncated");
				}
d3226 2
a3227 5
				if (kwtype & RCS_KW_AUTHOR) {
					if (strlcat(expbuf, rdp->rd_author, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: string truncated");
				}
d3229 9
a3237 5
				if (kwtype & RCS_KW_STATE) {
					if (strlcat(expbuf, rdp->rd_state, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: string truncated");
				}
d3239 52
a3290 18
				/* order does not matter anymore below */
				if (kwtype & RCS_KW_LOG)
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: string truncated");

				if (kwtype & RCS_KW_SOURCE) {
					if (strlcat(expbuf, rcsfile, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: string truncated");
				}

				if (kwtype & RCS_KW_NAME)
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: string truncated");

				if (kwtype & RCS_KW_LOCKER)
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_kwexp_line: string truncated");
d3293 5
a3297 5
			/* end the expansion */
			if (mode & RCS_KWEXP_NAME)
				if (strlcat(expbuf, "$",
				    sizeof(expbuf)) >= sizeof(expbuf))
					fatal("rcs_kwexp_line: truncated");
d3299 5
a3303 24
			/* Concatenate everything together. */
			tmpbuf = cvs_buf_alloc(len + strlen(expbuf), BUF_AUTOEXT);
			/* Append everything before keyword. */
			cvs_buf_append(tmpbuf, line->l_line,
			    start - line->l_line);
			/* Append keyword. */
			cvs_buf_append(tmpbuf, expbuf, strlen(expbuf));
			/* Point c to end of keyword. */
			tlen = cvs_buf_len(tmpbuf) - 1;
			/* Append everything after keyword. */
			cvs_buf_append(tmpbuf, end,
			    line->l_line + line->l_len - end);
			c = cvs_buf_get(tmpbuf) + tlen;
			/* Point fin to end of data. */
			fin = cvs_buf_get(tmpbuf) + cvs_buf_len(tmpbuf) - 1;
			/* Recalculate new length. */
			len = cvs_buf_len(tmpbuf);

			/* tmpbuf is now ready, convert to string */
			if (line->l_needsfree)
				xfree(line->l_line);
			line->l_len = len;
			line->l_line = cvs_buf_release(tmpbuf);
			line->l_needsfree = 1;
d3305 31
@


1.229
log
@Added CVS keyword "Locker". Although it is a dummy function, it's already
enough for OpenBSD's src/.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.228 2007/11/11 09:49:47 tobias Exp $	*/
d3096 3
@


1.228
log
@Apply umask on RCS file modes.  The umask can be changed in CVSROOT/config
and should therefore be handled.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.227 2007/11/08 20:43:42 tobias Exp $	*/
d177 1
d3267 4
@


1.227
log
@Stick at GNU cvs output format of docdate.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.226 2007/11/08 20:37:40 tobias Exp $	*/
d255 1
a255 1
	mode_t fmode;
d270 4
@


1.226
log
@Return latest revision of default branch when HEAD is requested and no
newer revisions are available (for example multiple imports).

Reported by ckuethe@@, OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.225 2007/10/09 12:59:53 tobias Exp $	*/
d3222 9
a3230 1
					fmt = "%B %e %Y ";
@


1.225
log
@Added proper support for branch revisions in annotate.

OK niallo@@, twice :)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.224 2007/10/09 12:18:53 tobias Exp $	*/
d556 9
a564 1
		rcsnum_cpy(brp->rb_num, rev, 0);
@


1.224
log
@Return NULL if a revision has been supplied that is higher than HEAD.

This one and previous OK niallo@@, "makes sense to me" xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.223 2007/10/09 12:16:29 tobias Exp $	*/
d1094 1
d2804 1
a2804 1
	/* put remaining lines of 1.1 into annotate buffer */
d2827 112
@


1.223
log
@Properly resolve branches, i.e. supplying branch base revision (e.g. 1.1.1)
should resolve to latest branch revision (e.g. 1.1.1.1).
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.222 2007/09/24 13:44:20 joris Exp $	*/
d2594 1
a2594 1
	 * revision for the given name.
d2596 5
a2600 1
	if (!RCSNUM_ISBRANCH(rev))
d2602 1
@


1.222
log
@add support to commit modified files to branches.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.221 2007/09/24 11:18:43 joris Exp $	*/
d2579 8
a2586 5
	if ((frev = rcsnum_parse(revstr)) != NULL)
		return (frev);

	/* More likely we will be passed a symbol */
	rev = rcs_sym_getrev(rfp, revstr);
@


1.221
log
@zap unused stuff, cleans it up a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.220 2007/09/22 15:41:46 joris Exp $	*/
d1138 1
d1192 1
d1196 7
a1202 1
			TAILQ_INSERT_TAIL(&(rdp->rd_branches), brp, rb_list);
d1204 2
a1205 1
			rcsnum_cpy(rdp->rd_num, ordp->rd_next, 0);
d2584 1
a2584 1
	
@


1.220
log
@in rcs_translate_tag() do not fail when a tag resolved
to a normal revision instead of a branch, its perfectly valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.219 2007/09/17 10:07:21 tobias Exp $	*/
a1009 18
}

/*
 * rcs_tag_resolve()
 *
 * Retrieve the revision number corresponding to the tag <tag> for the RCS
 * file <file>.
 */
RCSNUM *
rcs_tag_resolve(RCSFILE *file, const char *tag)
{
	RCSNUM *num;

	if ((num = rcsnum_parse(tag)) == NULL) {
		num = rcs_sym_getrev(file, tag);
	}

	return (num);
@


1.219
log
@Imported atomicio interface.

Requested by ray@@, OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.218 2007/09/13 13:10:57 tobias Exp $	*/
d2597 5
a2601 1
	/* If this isn't a branch revision, we have a problem */
d2603 1
a2603 1
		fatal("rcs_translate_tag: tag `%s' is not a branch", revstr);
@


1.218
log
@Added annotate support for local and remote repositories. Behaves like
GNU cvs but is a little faster.

OK joris@@, ray@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.217 2007/09/07 23:05:04 joris Exp $	*/
d37 1
d2918 1
a2918 1
			if (write(fd, "M ", 2) == -1)
d2922 1
a2922 1
		if (write(fd, lp->l_line, lp->l_len) == -1)
@


1.217
log
@Sprinkle some magic so checkout/update -p works
in both local and server mode.

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.216 2007/08/27 19:18:05 xsa Exp $	*/
d76 4
d226 2
a227 1
int		rcs_patch_lines(struct cvs_lines *, struct cvs_lines *);
d1030 2
a1031 1
rcs_patch_lines(struct cvs_lines *dlines, struct cvs_lines *plines)
d1084 6
a1089 1
				xfree(dlp);
d1105 6
d2643 1
a2643 1
rcs_rev_getlines(RCSFILE *rfp, RCSNUM *frev)
d2646 1
a2646 1
	int i, done, nextroot;
d2649 1
a2649 1
	struct rcs_delta *hrdp, *trdp, *rdp;
d2651 1
d2669 7
d2681 23
a2703 2
	if (!rcsnum_differ(rdp->rd_num, bnum))
		goto next;
d2705 1
d2730 4
a2733 1
		rcs_patch_lines(dlines, plines);
d2736 23
a2758 2
		if (!rcsnum_differ(rdp->rd_num, bnum))
			break;
d2760 1
d2780 10
a2789 1
		if (brp == NULL)
d2791 1
d2799 19
d2842 1
a2842 1
	lines = rcs_rev_getlines(rfp, rev);
d2889 1
a2889 1
	lines = rcs_rev_getlines(rfp, rev);
@


1.216
log
@typo in error msg; from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.215 2007/07/03 13:22:43 joris Exp $	*/
d2785 1
d2809 10
@


1.215
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.214 2007/06/28 21:38:09 xsa Exp $	*/
d1556 1
a1556 1
		fatal("fopen: `%s'", rfp->rf_path);
@


1.214
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.213 2007/06/01 17:47:47 niallo Exp $	*/
d2562 6
@


1.213
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.210 2007/02/22 06:42:09 otto Exp $	*/
d367 1
a367 1
	char buf[1024], numbuf[64], *fn, tmpdir[MAXPATHLEN];
d2461 1
a2461 1
	char buf[16];
@


1.212
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.211 2007/05/26 20:58:36 niallo Exp $	*/
a271 1
	rfp->rf_inattic = 0;
d531 3
a533 2
	char br[16];
	RCSNUM *rev;
d535 1
d537 14
a550 2
		rcsnum_tostr(file->rf_branch, br, sizeof(br));
		rev = rcs_translate_tag(br, file);
a551 1
		rev = rcsnum_alloc();
d2552 1
d2556 1
a2556 3
	size_t i;
	char *sdate;
	RCSNUM *rev, *brev;
d2559 1
a2559 1
	time_t givendate, rcsdate;
d2563 5
d2569 3
a2571 18
	if (rev == NULL) {
		if ((rev = rcsnum_parse(revstr)) == NULL) {
			if ((givendate = cvs_date_parse(revstr)) == -1)
				fatal("tag %s does not exist (0)", revstr);

			rcs_parse_deltas(rfp, NULL);

			TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
				sdate = asctime(&rdp->rd_date);
				if (sdate == NULL)
					fatal("failed to parse rcs date");
				rcsdate = cvs_date_parse(sdate);
				if (rcsdate == -1)
					fatal("failed to parse %s", sdate);
				if (givendate <= rcsdate)
					continue;
				break;
			}
d2573 3
a2575 3
			if (rdp == NULL)
				fatal("no revision that matches date %s",
				    revstr);
d2577 2
a2578 10
			rev = rdp->rd_num;
		}
	}

	if (RCSNUM_ISBRANCH(rev)) {
		brev = rcsnum_alloc();
		rcsnum_cpy(rev, brev, rev->rn_len - 1);
	} else {
		brev = rev;
	}
d2581 2
a2582 1
		fatal("tag %s does not exist (1)", revstr);
d2584 8
a2591 16
	if (RCSNUM_ISBRANCH(rev)) {
		rcsnum_free(brev);
		TAILQ_FOREACH(brp, &(rdp->rd_branches), rb_list) {
			for (i = 0; i < rev->rn_len; i++) {
				if (brp->rb_num->rn_id[i] != rev->rn_id[i])
					break;
			}

			if (i != rev->rn_len)
				continue;

			break;
		}

		if (brp == NULL)
			return (NULL);
d2593 6
d2600 5
a2604 3
			fatal("tag %s does not exist (3)", revstr);

		while (rdp->rd_next->rn_len != 0) {
d2606 1
a2606 1
				fatal("tag %s does not exist (4)", revstr);
d2608 2
a2609 2

		rcsnum_cpy(rdp->rd_num, rev, 0);
a2610 2

	return (rev);
d2623 1
a2623 1
	int i, done, nextroot, found;
a2693 1
		/* XXX strange loop and "found" set but not used */
d2695 2
a2696 4
			found = 1;
			for (i = 0; i < nextroot - 1; i++) {
				if (brp->rb_num->rn_id[i] != bnum->rn_id[i]) {
					found = 0;
d2698 2
a2699 4
				}
			}

			break;
@


1.211
log
@add support for Mdocdate rcs keyword in opencvs too.
also add check for strftime return in date keyword parsing while here.
requested by jmc@@, ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.210 2007/02/22 06:42:09 otto Exp $	*/
a2361 1
	void *tmp;
d2364 2
a2365 2
	tmp = xrealloc(pdp->rp_buf, 1, pdp->rp_blen + RCS_BUFEXTSIZE);
	pdp->rp_buf = tmp;
@


1.210
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.209 2007/02/19 11:40:00 otto Exp $	*/
d178 1
d2986 11
a2996 1
					strftime(buf, sizeof(buf), fmt, &rdp->rd_date);
@


1.209
log
@Fix const inconsistencies, void pointer artithmetic and a few other
things. now gcc -Wall and lint are more happy. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.208 2007/02/04 15:05:05 otto Exp $	*/
d27 9
a35 1
#include "includes.h"
a36 1
#include "buf.h"
a38 1
#include "log.h"
a39 2
#include "util.h"
#include "xmalloc.h"
@


1.208
log
@Use the right HEADNAME. Sometimes compiler warnings should not be
ignored. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.207 2007/02/01 20:36:21 otto Exp $	*/
d1010 2
a1011 1
	char op, *ep;
d1028 1
a1028 1
		lineno = (int)strtol((lp->l_line + 1), &ep, 10);
a1177 1

d1202 1
a1202 1
	BUF *nextbuf, *prevbuf, *newdiff, *newdeltatext;
d1224 1
a1224 1
	prevbuf = nextbuf = NULL;
a1293 1
	u_int cmplen;
a1309 2
	cmplen = rev->rn_len;

d2626 2
a2627 2
	size_t i, plen;
	int done, nextroot, found;
d2698 1
d2849 2
a2850 1
	u_char *c, *kwstr, *start, *end, *fin;
d3024 1
a3024 1
			    start - (unsigned char *)line->l_line);
d3031 1
a3031 1
			    ((unsigned char *)line->l_line + line->l_len) - end);
@


1.207
log
@When writing an rcs file, create the temp file next to the target
file and then rename. Avoids inter-filesystem copy and fixes a
potential rcs file truncation when the target fileystem becomes full.
While there, use fchmod instead of chmod.  ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.206 2007/01/26 21:59:11 otto Exp $	*/
d1178 1
a1178 1
			ordp = TAILQ_PREV(rdp, cvs_tqh, rd_list);
@


1.206
log
@more fixe size buffers on the stack. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.205 2007/01/26 21:48:17 xsa Exp $	*/
a217 1
static int	rcs_movefile(char *, char *, mode_t, u_int);
d363 1
a363 1
	char buf[1024], numbuf[64], *fn;
d370 1
a370 1
	int fd, from_fd, to_fd;
d372 1
a372 1
	from_fd = to_fd = fd = -1;
d383 3
a385 1
	(void)xasprintf(&fn, "%s/rcs.XXXXXXXXXX", cvs_tmpdir);
d390 1
a390 3
	if ((fp = fdopen(fd, "w+")) == NULL) {
		int saved_errno;

d393 1
a393 2
		errno = saved_errno;
		fatal("%s", fn);
d498 6
d506 2
a507 1
	if (rcs_movefile(fn, rfp->rf_path, rfp->rf_mode, rfp->rf_flags) == -1) {
d509 2
a510 1
		fatal("rcs_movefile failed");
a516 71
}

/*
 * rcs_movefile()
 *
 * Move a file using rename(2) if possible and copying if not.
 * Returns 0 on success, -1 on failure.
 */
static int
rcs_movefile(char *from, char *to, mode_t perm, u_int to_flags)
{
	FILE *src, *dst;
	size_t nread, nwritten;
	char buf[MAXBSIZE];
	int ret;

	ret = -1;

	if (rename(from, to) == 0) {
		if (chmod(to, perm) == -1) {
			cvs_log(LP_ERRNO, "%s", to);
			return (-1);
		}
		return (0);
	} else if (errno != EXDEV) {
		cvs_log(LP_NOTICE, "failed to access temp RCS output file");
		return (-1);
	}

	if ((chmod(to, S_IWUSR) == -1) && !(to_flags & RCS_CREATE)) {
		cvs_log(LP_ERR, "chmod(%s, 0%o) failed", to, S_IWUSR);
		return (-1);
	}

	/* different filesystem, have to copy the file */
	if ((src = fopen(from, "r")) == NULL) {
		cvs_log(LP_ERRNO, "%s", from);
		return (-1);
	}
	if ((dst = fopen(to, "w")) == NULL) {
		cvs_log(LP_ERRNO, "%s", to);
		return (-1);
	}
	if (fchmod(fileno(dst), perm)) {
		cvs_log(LP_ERR, "%s", to);
		(void)unlink(to);
		return (-1);
	}

	while ((nread = fread(buf, sizeof(char), MAXBSIZE, src)) != 0) {
		if (ferror(src)) {
			cvs_log(LP_ERRNO, "failed to read `%s'", from);
			(void)unlink(to);
			goto out;
		}
		nwritten = fwrite(buf, sizeof(char), nread, dst);
		if (nwritten != nread) {
			cvs_log(LP_ERRNO, "failed to write `%s'", to);
			(void)unlink(to);
			goto out;
		}
	}

	(void)unlink(from);
	ret = 0;

out:
	(void)fclose(src);
	(void)fclose(dst);

	return (ret);
@


1.205
log
@- support [-k mode] for the add command
- do not let the file keyword expension options (-k) disappear
from the Entries file when doing a commit/update/checkout
- be sure the expension mode gets written to the RCS file when a file
is added/committed in the first place
problems raised by otto@@; tests/ok otto@@ and joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.204 2007/01/26 11:19:44 joris Exp $	*/
d524 1
a524 1
	char *buf;
a559 1
	buf = xmalloc(MAXBSIZE);
d574 1
d577 1
a579 4
	(void)unlink(from);

out:
	xfree(buf);
@


1.204
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.203 2007/01/25 19:32:56 otto Exp $	*/
d1469 1
@


1.203
log
@plug a leak if multiple expansions are done on a single line. ok
niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.202 2007/01/25 18:35:30 niallo Exp $	*/
d2543 1
a2543 1
	return (mktime(&rdp->rd_date));
@


1.202
log
@plug a memleak in keyword expansion.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.201 2007/01/16 02:52:56 joris Exp $	*/
d3107 2
@


1.201
log
@sanitize what kind of symbols we can have in symbol names,
tested & found brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.200 2007/01/14 23:10:56 joris Exp $	*/
d3109 1
@


1.200
log
@move things around in rcs_rev_getbuf() and rcs_rev_write_fd()
so that we do keyword expansion on-the-fly if required instead
of obtaining the revision in memory first, running over the revision
lines while expanding keywords and only then writing them to the fd
or memory buffer.

this drasticly decreases cpu usage by opencvs on very large trees (like src).

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.199 2007/01/13 20:59:49 joris Exp $	*/
d2314 1
a2314 1
			    ch != '/') {
@


1.199
log
@nuke the the very evil rcs_getrev() stuff
discussed with niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.198 2007/01/13 05:09:17 joris Exp $	*/
a237 1
static BUF	*rcs_expand_keywords(char *, struct rcs_delta *, BUF *, int);
a2465 201
 * rcs_expand_keywords()
 *
 * Return expansion any RCS keywords in <data>
 *
 * On error, return NULL.
 */
static BUF *
rcs_expand_keywords(char *rcsfile, struct rcs_delta *rdp, BUF *bp, int mode)
{
	BUF *newbuf;
	int kwtype;
	u_int j, found;
	u_char *c, *kwstr, *start, *end, *fin;
	char expbuf[256], buf[256];
	char *fmt;
	size_t len, kwlen;

	kwtype = 0;
	kwstr = NULL;

	len = cvs_buf_len(bp);
	if (len == 0)
		return (bp);

	c = cvs_buf_get(bp);
	found = 0;
	/* Final character in buffer. */
	fin = c + len - 1;

	/* If no keywords are found, return original buffer. */
	newbuf = bp;

	/*
	 * Keyword formats:
	 * $Keyword$
	 * $Keyword: value$
	 */
	for (; c < fin; c++) {
		if (*c == '$') {
			BUF *tmpbuf;
			size_t clen;

			/* remember start of this possible keyword */
			start = c;

			/* first following character has to be alphanumeric */
			c++;
			if (!isalpha(*c)) {
				c = start;
				continue;
			}

			/* Number of characters between c and fin, inclusive. */
			clen = fin - c + 1;

			/* look for any matching keywords */
			found = 0;
			for (j = 0; j < RCS_NKWORDS; j++) {
				kwlen = strlen(rcs_expkw[j].kw_str);
				/*
				 * kwlen must be less than clen since clen
				 * includes either a terminating `$' or a `:'.
				 */
				if (kwlen < clen &&
				    memcmp(c, rcs_expkw[j].kw_str, kwlen) == 0 &&
				    (c[kwlen] == '$' || c[kwlen] == ':')) {
					found = 1;
					kwstr = rcs_expkw[j].kw_str;
					kwtype = rcs_expkw[j].kw_type;
					c += kwlen;
					break;
				}
			}

			/* unknown keyword, continue looking */
			if (found == 0) {
				c = start;
				continue;
			}

			/*
			 * if the next character was ':' we need to look for
			 * an '$' before the end of the line to be sure it is
			 * in fact a keyword.
			 */
			if (*c == ':') {
				for (; c <= fin; ++c) {
					if (*c == '$' || *c == '\n')
						break;
				}

				if (*c != '$') {
					c = start;
					continue;
				}
			}
			end = c + 1;

			/* start constructing the expansion */
			expbuf[0] = '\0';

			if (mode & RCS_KWEXP_NAME) {
				if (strlcat(expbuf, "$", sizeof(expbuf)) >= sizeof(expbuf) ||
				    strlcat(expbuf, kwstr, sizeof(expbuf)) >= sizeof(expbuf))
					fatal("rcs_expand_keywords: truncated");
				if ((mode & RCS_KWEXP_VAL) &&
				    strlcat(expbuf, ": ", sizeof(expbuf)) >= sizeof(expbuf))
					fatal("rcs_expand_keywords: truncated");
			}

			/*
			 * order matters because of RCS_KW_ID and
			 * RCS_KW_HEADER here
			 */
			if (mode & RCS_KWEXP_VAL) {
				if (kwtype & RCS_KW_RCSFILE) {
					if (!(kwtype & RCS_KW_FULLPATH))
						(void)strlcat(expbuf, basename(rcsfile), sizeof(expbuf));
					else
						(void)strlcat(expbuf, rcsfile, sizeof(expbuf));
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: truncated");
				}

				if (kwtype & RCS_KW_REVISION) {
					rcsnum_tostr(rdp->rd_num, buf, sizeof(buf));
					if (strlcat(buf, " ", sizeof(buf)) >= sizeof(buf) ||
					    strlcat(expbuf, buf, sizeof(expbuf)) >= sizeof(buf))
						fatal("rcs_expand_keywords: truncated");
				}

				if (kwtype & RCS_KW_DATE) {
					fmt = "%Y/%m/%d %H:%M:%S ";

					strftime(buf, sizeof(buf), fmt, &rdp->rd_date);
					if (strlcat(expbuf, buf, sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: string truncated");
				}

				if (kwtype & RCS_KW_AUTHOR) {
					if (strlcat(expbuf, rdp->rd_author, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: string truncated");
				}

				if (kwtype & RCS_KW_STATE) {
					if (strlcat(expbuf, rdp->rd_state, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: string truncated");
				}

				/* order does not matter anymore below */
				if (kwtype & RCS_KW_LOG)
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: string truncated");

				if (kwtype & RCS_KW_SOURCE) {
					if (strlcat(expbuf, rcsfile, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: string truncated");
				}

				if (kwtype & RCS_KW_NAME)
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: string truncated");
			}

			/* end the expansion */
			if (mode & RCS_KWEXP_NAME)
				if (strlcat(expbuf, "$",
				    sizeof(expbuf)) >= sizeof(expbuf))
					fatal("rcs_expand_keywords: truncated");

			/* Concatenate everything together. */
			tmpbuf = cvs_buf_alloc(len + strlen(expbuf), BUF_AUTOEXT);
			/* Append everything before keyword. */
			cvs_buf_append(tmpbuf, cvs_buf_get(newbuf),
			    start - (unsigned char *)cvs_buf_get(newbuf));
			/* Append keyword. */
			cvs_buf_append(tmpbuf, expbuf, strlen(expbuf));
			/* Point c to end of keyword. */
			c = cvs_buf_get(tmpbuf) + cvs_buf_len(tmpbuf) - 1;
			/* Append everything after keyword. */
			cvs_buf_append(tmpbuf, end,
			    ((unsigned char *)cvs_buf_get(newbuf) + cvs_buf_len(newbuf)) - end);
			/* Point fin to end of data. */
			fin = cvs_buf_get(tmpbuf) + cvs_buf_len(tmpbuf) - 1;
			/* Recalculate new length. */
			len = cvs_buf_len(tmpbuf);

			/* tmpbuf is now ready, free old newbuf if allocated here. */
			if (newbuf != bp)
				cvs_buf_free(newbuf);
			newbuf = tmpbuf;
		}
	}

	return (newbuf);
}

/*
a2605 28
/*
 * rcs_kwexp_buf()
 *
 * Do keyword expansion on a buffer if necessary
 *
 */
BUF *
rcs_kwexp_buf(BUF *bp, RCSFILE *rf, RCSNUM *rev)
{
	struct rcs_delta *rdp;
	int expmode;

	/*
	 * Do keyword expansion if required.
	 */
	if (rf->rf_expand != NULL)
		expmode = rcs_kwexp_get(rf);
	else
		expmode = RCS_KWEXP_DEFAULT;

	if (!(expmode & RCS_KWEXP_NONE)) {
		if ((rdp = rcs_findrev(rf, rev)) == NULL)
			fatal("could not fetch revision");
		return (rcs_expand_keywords(rf->rf_path, rdp, bp, expmode));
	}
	return (bp);
}

d2804 1
a2804 1
rcs_rev_getbuf(RCSFILE *rfp, RCSNUM *rev)
d2806 2
d2812 1
d2815 14
d2832 4
d2853 1
a2853 1
	int expmode;
d2858 1
d2860 1
a2860 1
	/* keyword expansion if necessary */
d2870 1
a2870 1
			rcs_kwexp_lines(rfp->rf_path, rdp, lines, expmode);
d2873 1
d2877 4
d3019 1
a3019 1
					fatal("rcs_expand_keywords: truncated");
d3022 1
a3022 1
					fatal("rcs_expand_keywords: truncated");
d3036 1
a3036 1
						fatal("rcs_expand_keywords: truncated");
d3043 1
a3043 1
						fatal("rcs_expand_keywords: truncated");
d3051 1
a3051 1
						fatal("rcs_expand_keywords: string truncated");
d3057 1
a3057 1
						fatal("rcs_expand_keywords: string truncated");
d3063 1
a3063 1
						fatal("rcs_expand_keywords: string truncated");
d3069 1
a3069 1
						fatal("rcs_expand_keywords: string truncated");
d3074 1
a3074 1
						fatal("rcs_expand_keywords: string truncated");
d3079 1
a3079 1
						fatal("rcs_expand_keywords: string truncated");
d3086 1
a3086 1
					fatal("rcs_expand_keywords: truncated");
a3110 20
}

/*
 * rcs_kwexp_lines()
 *
 * Do keyword expansion of cvs_lines struct, if necessary.
 * Any lines which need expansion are allocated memory in a separate malloc()
 * from the original, and l_needsfree is set to 1.  cvs_freelines() will check
 * for this and free if necessary.  This basically gives us 'copy-on-write'
 * semantics for expansion of keywords, so we do the minimum work required.
 *
 * On error, return NULL.
 */
void
rcs_kwexp_lines(char *rcsfile, struct rcs_delta *rdp, struct cvs_lines *lines,
    int mode)
{
	struct cvs_line *lp;
	TAILQ_FOREACH(lp, &lines->l_lines, l_list)
		rcs_kwexp_line(rcsfile, rdp, lp, mode);
@


1.198
log
@the memleak i thought i had fixed was in fact NOT a leak at all
and caused opencvs to crash so revert, oops?
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.197 2007/01/13 04:29:37 joris Exp $	*/
a1168 114
}

/*
 * rcs_getrev()
 *
 * Get the whole contents of revision <rev> from the RCSFILE <rfp>.  The
 * returned buffer is dynamically allocated and should be released using
 * cvs_buf_free() once the caller is done using it.
 */
BUF*
rcs_getrev(RCSFILE *rfp, RCSNUM *frev)
{
	size_t i, dlen, plen;
	int done, nextroot, found;
	BUF *rcsbuf;
	RCSNUM *tnum, *bnum;
	struct rcs_branch *brp;
	struct rcs_delta *hrdp, *trdp, *rdp;
	u_char *data, *patch;

	if ((hrdp = rcs_findrev(rfp, rfp->rf_head)) == NULL)
		fatal("rcs_getrev: no HEAD revision");

	tnum = frev;
	rcs_parse_deltatexts(rfp, hrdp->rd_num);

	/* revision on branch, get the branch root */
	nextroot = 2;
	if (RCSNUM_ISBRANCHREV(tnum)) {
		bnum = rcsnum_alloc();
		rcsnum_cpy(tnum, bnum, nextroot);
	} else {
		bnum = tnum;
	}

	rcsbuf = cvs_buf_alloc(hrdp->rd_tlen, BUF_AUTOEXT);
	cvs_buf_append(rcsbuf, hrdp->rd_text, hrdp->rd_tlen);

	done = 0;

	rdp = hrdp;
	if (!rcsnum_differ(rdp->rd_num, bnum))
		goto next;

	if ((rdp = rcs_findrev(rfp, hrdp->rd_next)) == NULL)
		return (rcsbuf);

again:
	for (;;) {
		if (rdp->rd_next->rn_len != 0) {
			trdp = rcs_findrev(rfp, rdp->rd_next);
			if (trdp == NULL)
				fatal("failed to grab next revision");
		}

		if (rdp->rd_tlen == 0) {
			rcs_parse_deltatexts(rfp, rdp->rd_num);
			if (rdp->rd_tlen == 0) {
				if (!rcsnum_differ(rdp->rd_num, bnum))
					break;
				rdp = trdp;
				continue;
			}
		}

		plen = rdp->rd_tlen;
		dlen = cvs_buf_len(rcsbuf);
		patch = rdp->rd_text;
		data = cvs_buf_release(rcsbuf);
		rcsbuf = cvs_patchfile(data, dlen, patch, plen,
		    rcs_patch_lines);
		xfree(data);
		if (rcsbuf == NULL)
			fatal("rcs_getrev: failed to apply rcsdiff");

		if (!rcsnum_differ(rdp->rd_num, bnum))
			break;

		rdp = trdp;
	}

next:
	if (!rcsnum_differ(rdp->rd_num, frev))
		done = 1;

	if (RCSNUM_ISBRANCHREV(frev) && done != 1) {
		nextroot += 2;
		rcsnum_cpy(frev, bnum, nextroot);

		TAILQ_FOREACH(brp, &(rdp->rd_branches), rb_list) {
			found = 1;
			for (i = 0; i < nextroot - 1; i++) {
				if (brp->rb_num->rn_id[i] != bnum->rn_id[i]) {
					found = 0;
					break;
				}
			}

			break;
		}

		if (brp == NULL)
			fatal("expected branch not found on branch list");

		if ((rdp = rcs_findrev(rfp, brp->rb_num)) == NULL)
			fatal("rcs_getrev: failed to get delta for target rev");

		goto again;
	}

	if (bnum != tnum)
		rcsnum_free(bnum);

	return (rcsbuf);
@


1.197
log
@- better error messages
- correclty use cvs_tagname, so that the tag from $CVSROOT/config
  will actually be expanded as a keyword.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.196 2007/01/12 23:32:01 niallo Exp $	*/
a3423 1
			xfree(line->l_line);
@


1.196
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.195 2007/01/12 19:28:12 joris Exp $	*/
d2596 1
a2596 1
	size_t len;
a2638 2
				size_t kwlen;

d3049 1
a3049 1
		fatal("rcs_rev_write_fd: no HEAD revision");
d3128 1
a3128 1
			fatal("rcs_rev_write_fd: failed to get delta for target rev");
d3238 1
a3238 1
	size_t len;
a3277 2
				size_t kwlen;

d3294 12
d3424 1
@


1.195
log
@do not leak memory from rcs_head_get()

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.194 2007/01/12 17:25:33 joris Exp $	*/
d239 2
a1408 5
	if (prevrdp != NULL) {
		if ((prevbuf = rcs_getrev(rf, prevrdp->rd_num)) == NULL)
			fatal("error getting revision");
	}

a1409 3
		if ((nextbuf = rcs_getrev(rf, nextrdp->rd_num)) == NULL)
			fatal("error getting revision");

d1414 1
a1414 2
		cvs_buf_write_stmp(nextbuf, path_tmp1, NULL);
		cvs_buf_free(nextbuf);
d1417 1
a1417 2
		cvs_buf_write_stmp(prevbuf, path_tmp2, NULL);
		cvs_buf_free(prevbuf);
a2594 1
	struct tm tb;
d3031 409
@


1.194
log
@complete binary support for opencvs,
adding/importing binary files now works too

partially taken from openrcs
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.193 2007/01/11 17:44:18 niallo Exp $	*/
d595 1
d599 4
a602 1
		return (rcs_translate_tag(br, file));
d605 1
a605 1
	return (file->rf_head);
@


1.193
log
@rework opencvs so that we can deal with binary files.  previously we assumed all files were ascii,
which broke things in real-world usage.  now a checkout of src should work, albeit using lots of
memory and cpu.  fixing this is the next step.

testing by many.
ok & some input joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.192 2006/12/21 15:03:15 niallo Exp $	*/
d1377 1
a1377 1
	char *newdeltatext, *path_tmp1, *path_tmp2;
d1379 1
a1379 1
	BUF *nextbuf, *prevbuf, *newdiff;
d1427 1
a1427 1
		newdeltatext = cvs_buf_release(newdiff);
d1429 1
a1429 1
		newdeltatext = cvs_buf_release(prevbuf);
d2795 1
a2795 1
rcs_deltatext_set(RCSFILE *rfp, RCSNUM *rev, const char *dtext)
d2798 1
d2810 4
a2813 1
	len = strlen(dtext);
d2815 1
a2815 2
		/* XXX - use xstrdup() if rd_text changes to char *. */
		rdp->rd_text = xmalloc(len + 1);
d2817 1
a2817 1
		(void)memcpy(rdp->rd_text, dtext, len + 1);
d2822 3
@


1.192
log
@- plug memory leak in rcs_parse_delta()

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.191 2006/12/21 14:59:25 niallo Exp $	*/
a495 5

			if (rdp->rd_tlen != 0) {
				if (rdp->rd_text[rdp->rd_tlen-1] != '\n')
					fputc('\n', fp);
			}
d1076 1
d1084 2
d1087 3
d1091 3
a1093 4
		if (lineno > dlines->l_nblines || lineno < 0 ||
		    *ep != ' ')
			fatal("invalid line specification in RCS patch: %s",
			    ep);
d1096 3
a1098 1
		if (nbln < 0 || *ep != '\0')
d1175 1
a1175 1
	size_t i;
d1181 1
a1181 1
	char *data;
d1228 3
a1230 1
		cvs_buf_putc(rcsbuf, '\0');
d1232 3
a1234 2

		rcsbuf = cvs_patchfile(data, rdp->rd_text, rcs_patch_lines);
a1236 1
		xfree(data);
d2109 9
a2117 5
	rdp->rd_text = xmalloc(RCS_TOKLEN(rfp) + 1);
	if (strlcpy(rdp->rd_text, RCS_TOKSTR(rfp), (RCS_TOKLEN(rfp) + 1)) >=
	    RCS_TOKLEN(rfp) + 1)
		fatal("rcs_parse_deltatext: strlcpy");
	rdp->rd_tlen = RCS_TOKLEN(rfp);
@


1.191
log
@- plug memory leak in rcs_translate_tag()

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.190 2006/12/21 14:58:14 niallo Exp $	*/
a1876 7
	rdp = xcalloc(1, sizeof(*rdp));

	rdp->rd_num = rcsnum_alloc();
	rdp->rd_next = rcsnum_alloc();

	TAILQ_INIT(&(rdp->rd_branches));

a1884 1
		rcs_freedelta(rdp);
d1887 8
@


1.190
log
@- plug memory leak in rcs_patch_lines()

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.189 2006/12/04 03:53:30 niallo Exp $	*/
d2994 1
@


1.189
log
@- fix crash when doing keyword expansion of zero-length buffers.

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.188 2006/08/23 20:28:00 joris Exp $	*/
d1121 1
@


1.188
log
@pull in latest change from openrcs:
Add missing checks for EOF when parsing rcs file sections.
by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.32 2006/08/23 11:49:49 millert Exp $	*/
d2598 2
@


1.187
log
@Sync CVS's rcs_expand_keywords() and rcs_kwexp_buf() with RCS.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.186 2006/07/30 03:47:48 ray Exp $	*/
d2420 4
a2423 1
			if (!isalnum(ch) && ch != '_' && ch != '-' &&
d2452 4
a2455 1
			if (ch == '@@') {
d2481 4
@


1.186
log
@Sync some whitespace changes from rcs.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.185 2006/07/08 09:25:44 ray Exp $	*/
d238 1
a238 2
static char*   rcs_expand_keywords(char *, struct rcs_delta *, char *,
                    size_t, int);
d2572 2
a2573 3
static char *
rcs_expand_keywords(char *rcsfile, struct rcs_delta *rdp, char *data,
    size_t len, int mode)
d2575 1
a2575 2
	ptrdiff_t c_offset, sizdiff, start_offset;
	size_t i;
d2578 1
a2578 1
	char *c, *kwstr, *start, *end, *tbuf;
d2580 1
d2582 1
d2586 10
a2595 1
	i = 0;
d2602 1
a2602 1
	for (c = data; *c != '\0' && i < len; c++) {
d2604 3
a2608 1
			start_offset = start - data;
d2617 3
d2623 10
a2632 2
				if (!strncmp(c, rcs_expkw[j].kw_str,
				    strlen(rcs_expkw[j].kw_str))) {
d2636 1
a2640 8
			if (cvs_tagname != NULL &&
			    !strncmp(c, cvs_tagname, strlen(cvs_tagname)) &&
			    found != 1) {
				found = 1;
				kwstr = cvs_tagname;
				kwtype = RCS_KW_ID;
			}

a2646 7
			/* next character has to be ':' or '$' */
			c += strlen(kwstr);
			if (*c != ':' && *c != '$') {
				c = start;
				continue;
			}

d2653 1
a2653 1
				while (*c++) {
a2662 1
			c_offset = c - data;
d2740 21
a2760 23
			sizdiff = strlen(expbuf) - (end - start);
			tbuf = xstrdup(end);

			/* only realloc if we have to */
			if (sizdiff > 0) {
				char *newdata;

				len += sizdiff;
				newdata = xrealloc(data, 1, len);
				data = newdata;

				/*
				 * ensure string pointers are not invalidated
				 * after realloc()
				 */
				start = data + start_offset;
				c = data + c_offset;
			}
			if (strlcpy(start, expbuf, len) >= len ||
			    strlcat(data, tbuf, len) >= len)
				fatal("rcs_expand_keywords: string truncated");
			xfree(tbuf);
			i += strlen(expbuf);
d2764 1
a2764 1
	return (data);
a2911 1
	char *expanded, *tbuf;
a2912 1
	size_t len;
d2925 1
a2925 8
		cvs_buf_putc(bp, '\0');
		len = cvs_buf_len(bp);
		tbuf = cvs_buf_release(bp);
		expanded = rcs_expand_keywords(rf->rf_path, rdp,
		    tbuf, len, expmode);
		bp = cvs_buf_alloc(len, BUF_AUTOEXT);
		cvs_buf_set(bp, expanded, strlen(expanded), 0);
		xfree(expanded);
@


1.185
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.184 2006/06/09 14:57:13 xsa Exp $	*/
d2663 2
a2664 4
				if (strlcat(expbuf, "$", sizeof(expbuf))
				    >= sizeof(expbuf) ||
				    strlcat(expbuf, kwstr, sizeof(expbuf))
				    >= sizeof(expbuf))
d2667 1
a2667 2
				    strlcat(expbuf, ": ", sizeof(expbuf))
				    >= sizeof(expbuf))
d2678 1
a2678 3
						(void)strlcat(expbuf,
						    basename(rcsfile),
						    sizeof(expbuf));
d2680 3
a2682 6
						(void)strlcat(expbuf,
						    rcsfile, sizeof(expbuf));
					if (strlcat(expbuf, " ",
					    sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: "
						    "truncated");
d2686 4
a2689 8
					rcsnum_tostr(rdp->rd_num, buf,
					    sizeof(buf));
					if (strlcat(buf, " ", sizeof(buf))
					    >= sizeof(buf) ||
					    strlcat(expbuf, buf,
					    sizeof(expbuf)) >= sizeof(buf))
						fatal("rcs_expand_keywords: "
						    "truncated");
d2695 3
a2697 6
					strftime(buf, sizeof(buf), fmt,
					    &rdp->rd_date);
					if (strlcat(expbuf, buf,
					    sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: "
						    "string truncated");
d2701 3
a2703 6
					if (strlcat(expbuf, rdp->rd_author,
					    sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ",
					    sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: "
						    "string truncated");
d2707 3
a2709 6
					if (strlcat(expbuf, rdp->rd_state,
					    sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ",
					    sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: "
						    "string truncated");
d2714 2
a2715 4
					if (strlcat(expbuf, " ",
					    sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: "
						    "string truncated");
d2718 3
a2720 6
					if (strlcat(expbuf, rcsfile,
					    sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ",
					    sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: "
						    "string truncated");
d2724 2
a2725 4
					if (strlcat(expbuf, " ",
					    sizeof(expbuf)) >= sizeof(expbuf))
						fatal("rcs_expand_keywords: "
						    "string truncated");
@


1.184
log
@handle `cvs tag -F'; input && OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.183 2006/06/06 05:13:39 joris Exp $	*/
d1412 1
a1412 1
		cvs_buf_write_stmp(nextbuf, path_tmp1, 0600, NULL);
d1416 1
a1416 1
		cvs_buf_write_stmp(prevbuf, path_tmp2, 0600, NULL);
@


1.183
log
@add support for the -D option of update,
-D allows you to update a file to matching a specified date:

opencvs up -D "1 hour ago" foobar will take the first matching
revision that was commited 1 hour ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.182 2006/06/04 13:53:27 joris Exp $	*/
d791 19
@


1.182
log
@lets not stop looking for a branch if the first one
on the branches list does not match the one we are
looking for, it might be further down.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.181 2006/06/04 09:52:56 joris Exp $	*/
d2948 1
a2948 1
	int nextroot;
d2951 4
a2954 2
	struct rcs_delta *rdp, *brdp;
	char revision[16];
d2958 24
a2981 2
		if ((rev = rcsnum_parse(revstr)) == NULL)
			fatal("tag %s does not exist (0)", revstr);
@


1.181
log
@sprinkle -n voodoo over the add, commit and import commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.180 2006/06/01 20:00:52 joris Exp $	*/
a1237 3
			/* XXX */
			if (found == 0)
				fatal("no matching branch on list");
@


1.180
log
@major rewrite of some rcs parsing stuff:

- rework rcs_getrev() to correctly support branches
- rework rcs_translate_tag() to correctly translate given symbols or
  branches into their matching revisions
- rework rcs_rev_add() to correctly update its 'next' pointers
  and insert the new revision in the correct place on the list.
- rework rcs_head_get() to return the latest revision on the default
  branch if it has been set or the normal HEAD revision otherwise.
- no longer access the rf_head member of the RCSFILE struct manually,
  use the rcs_head_get() function which correctly returns the HEAD
  revision, there might be a default branch that has to be used.
- for now, when commiting a new revision reset the default branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.179 2006/05/31 22:25:59 joris Exp $	*/
d376 3
@


1.179
log
@add support for the export command.

export does exactly the same as checkout except it does
not create any administrative (CVS/) directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.178 2006/05/31 18:26:14 joris Exp $	*/
d594 1
a594 1
const RCSNUM *
d597 7
d1071 2
a1072 1
			fatal("invalid line specification in RCS patch");
d1151 7
a1157 8
	u_int i, numlen;
	int isbranch, lookonbranch, found;
	size_t len;
	void *bp;
	RCSNUM *crev, *rev, *brev;
	BUF *rbuf;
	struct rcs_delta *rdp = NULL;
	struct rcs_branch *rb;
d1159 2
a1160 2
	if (rfp->rf_head == NULL)
		return (NULL);
d1162 2
a1163 4
	if (frev == RCS_HEAD_REV)
		rev = rfp->rf_head;
	else
		rev = frev;
d1165 7
a1171 6
	/* XXX rcsnum_cmp() */
	for (i = 0; i < rfp->rf_head->rn_len; i++) {
		if (rfp->rf_head->rn_id[i] < rev->rn_id[i]) {
			rcs_errno = RCS_ERR_NOENT;
			return (NULL);
		}
d1174 8
a1181 2
	/* No matter what, we're going to need up the the description parsed */
	rcs_parse_desc(rfp, NULL);
d1183 2
a1184 5
	rdp = rcs_findrev(rfp, rfp->rf_head);
	if (rdp == NULL) {
		cvs_log(LP_ERR, "failed to get RCS HEAD revision");
		return (NULL);
	}
d1186 7
a1192 2
	if (rdp->rd_tlen == 0)
		rcs_parse_deltatexts(rfp, rfp->rf_head);
d1194 9
a1202 6
	len = rdp->rd_tlen;
	if (len == 0) {
		rbuf = cvs_buf_alloc(1, 0);
		cvs_buf_empty(rbuf);
		return (rbuf);
	}
d1204 2
a1205 2
	rbuf = cvs_buf_alloc(len, BUF_AUTOEXT);
	cvs_buf_append(rbuf, rdp->rd_text, len);
d1207 4
a1210 2
	isbranch = 0;
	brev = NULL;
d1212 2
a1213 8
	/*
	 * If a branch was passed, get the latest revision on it.
	 */
	if (RCSNUM_ISBRANCH(rev)) {
		brev = rev;
		rdp = rcs_findrev(rfp, rev);
		if (rdp == NULL)
			return (NULL);
d1215 1
a1215 6
		rev = rdp->rd_num;
	} else {
		if (RCSNUM_ISBRANCHREV(rev)) {
			brev = rcsnum_revtobr(rev);
			isbranch = 1;
		}
d1218 3
a1220 2
	lookonbranch = 0;
	crev = NULL;
d1222 3
a1224 7
	/* Apply patches backwards to get the right version.
	 */
	do {
		found = 0;
		
		if (rcsnum_cmp(rfp->rf_head, rev, 0) == 0)
			break;
d1226 5
a1230 20
		if (isbranch == 1 && rdp->rd_num->rn_len < rev->rn_len &&
		    !TAILQ_EMPTY(&(rdp->rd_branches)))
			lookonbranch = 1;

		if (isbranch && lookonbranch == 1) {
			lookonbranch = 0;
			TAILQ_FOREACH(rb, &(rdp->rd_branches), rb_list) {
				/* XXX rcsnum_cmp() is totally broken for
				 * this purpose.
				 */
				numlen = MIN(brev->rn_len, rb->rb_num->rn_len);
				for (i = 0; i < numlen; i++) {
					if (rb->rb_num->rn_id[i] !=
					    brev->rn_id[i])
						break;
				}

				if (i == numlen) {
					crev = rb->rb_num;
					found = 1;
d1234 2
d1237 2
a1238 3
				crev = rdp->rd_next;
		} else {
			crev = rdp->rd_next;
d1241 2
a1242 5
		rdp = rcs_findrev(rfp, crev);
		if (rdp == NULL) {
			cvs_buf_free(rbuf);
			return (NULL);
		}
d1244 2
a1245 1
		cvs_buf_putc(rbuf, '\0');
d1247 2
a1248 3
		/* check if we have parsed this rev's deltatext */
		if (rdp->rd_tlen == 0)
			rcs_parse_deltatexts(rfp, rdp->rd_num);
d1250 2
a1251 4
		bp = cvs_buf_release(rbuf);
		rbuf = cvs_patchfile((char *)bp, (char *)rdp->rd_text,
		    rcs_patch_lines);
		xfree(bp);
d1253 1
a1253 9
		if (rbuf == NULL)
			break;
	} while (rcsnum_cmp(crev, rev, 0) != 0);

	if (cvs_buf_getc(rbuf, cvs_buf_len(rbuf)-1) != '\n' &&
	    rbuf != NULL)
		cvs_buf_putc(rbuf, '\n');

	return (rbuf);
d1275 1
a1305 7
	if (!(rf->rf_flags & RCS_CREATE)) {
		/* next should point to the previous HEAD */
		ordp = TAILQ_FIRST(&(rf->rf_delta));
		rcsnum_cpy(ordp->rd_num, rdp->rd_next, 0);
	}


d1319 4
a1322 1
	TAILQ_INSERT_HEAD(&(rf->rf_delta), rdp, rd_list);
d1325 15
d1612 1
d1740 3
d2948 1
d2952 1
a2952 1
	char foo[16];
d2957 1
a2957 1
			fatal("%s is an invalid revision/symbol", revstr);
d2962 4
a2965 1
		rcsnum_cpy(rev, brev, 2);
d2967 2
a2968 3
		if ((rdp = rcs_findrev(rfp, brev)) == NULL)
			fatal("rcs_translate_tag: cannot find branch root "
			    "for '%s'", revstr);
d2970 1
a2971 4
			if (brp->rb_num->rn_len < 4)
				fatal("rcs_translate_tag: bad branch "
				    "revision on list");

d2973 2
a2974 2
				if (rev->rn_id[i] != brp->rb_num->rn_id[i])
					continue;
d2977 3
a2979 1
			rcsnum_tostr(brp->rb_num, foo, sizeof(foo));
d2983 2
a2984 6
		if (brp == NULL) {
			if (cvs_cmdop == CVS_OP_IMPORT)
				return (NULL);
			rcsnum_cpy(rdp->rd_num, rev, 0);
			return (rev);
		}
d2986 2
a2987 5
		if ((rdp = rcs_findrev(rfp, brp->rb_num)) == NULL) {
			rcsnum_tostr(brp->rb_num, foo, sizeof(foo));
			fatal("rcs_translate_tag: cannot find branch rev %s",
			    foo);
		}
d2989 3
a2991 5
		brdp = rdp;
		while (brdp->rd_next->rn_len != 0) {
			brdp = rcs_findrev(rfp, brdp->rd_next);
			if (brdp == NULL)
				fatal("rcs_translate_tag: next is NULL");
d2994 1
a2994 1
		rcsnum_cpy(brdp->rd_num, rev, 0);
@


1.178
log
@have rcs_translate_tag translate branches too, which
allows us to completely use branches for diffing, logging,
updating, etc..

more branches support coming up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.177 2006/05/30 19:16:51 joris Exp $	*/
d2988 2
@


1.177
log
@look inside the Attic if a specified RCS file cannot be found
in the normal repository, and a way to identify an RCS file in
the Attic in the RCSFILE struct.
will come in handy later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.176 2006/05/29 07:15:52 joris Exp $	*/
a1461 3
 * If the given revision is a branch number, we translate it into the latest
 * revision on the branch.
 *
d1467 1
d1470 2
a1471 1
	RCSNUM *brev, *frev;
d1479 3
a1481 1
	    rcsnum_cmp(rdp->rd_num, rev, 0) == -1) {
a1484 21
	/*
	 * Translate a branch into the latest revision on the branch itself.
	 */
	if (RCSNUM_ISBRANCH(rev)) {
		brev = rcsnum_brtorev(rev);
		frev = brev;
		for (;;) {
			rdp = rcs_findrev(rfp, frev);
			if (rdp == NULL)
				return (NULL);

			if (rdp->rd_next->rn_len == 0)
				break;

			frev = rdp->rd_next;
		}

		rcsnum_free(brev);
		return (rdp);
	}

d1488 3
a1490 1
		if (rcsnum_cmp(rdp->rd_num, rev, cmplen) == 0)
d2953 5
a2957 1
	RCSNUM *rev;
d2963 43
@


1.176
log
@add rcs_translate_tag which will translate a specified
revision or symbol given to us on the command line into
the matching revision in the RCS file (if any);
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.175 2006/05/28 10:14:59 joris Exp $	*/
d268 1
@


1.175
log
@add rf_dead field to RCSFILE which can tell us
if an RCSFILE is dead, will come in usefull later in commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.174 2006/05/27 18:04:46 joris Exp $	*/
d801 6
d2965 14
@


1.174
log
@basic support for CVSROOT/config - only supporting the 'tag' and
'umask' keyword right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.173 2006/05/27 05:59:32 joris Exp $	*/
d267 1
@


1.173
log
@correctly expand keywords when checking out files
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.172 2006/05/27 03:30:31 joris Exp $	*/
d2614 8
@


1.172
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.9 2006/05/11 07:34:26 xsa Exp $	*/
a2579 1
	struct tm tb;
d2696 2
a2697 1
					strftime(buf, sizeof(buf), fmt, &tb);
@


1.171
log
@- fix a case in rcs_getrev() handling of branches where variant was not being
  increased and thus no progress could be made in the loop.

bug noticed in rcsdiff(1) by sturm@@

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.170 2006/04/25 10:31:39 xsa Exp $	*/
d29 1
d31 1
d34 2
a35 1
#include "diff.h"
a40 1

a49 1

a68 1

a71 1

a87 1

a90 1

a93 1

a177 13
#ifdef notyet
static struct rcs_kfl {
	char	rk_char;
	int	rk_val;
} rcs_kflags[] = {
	{ 'k',   RCS_KWEXP_NAME },
	{ 'v',   RCS_KWEXP_VAL  },
	{ 'l',   RCS_KWEXP_LKR  },
	{ 'o',   RCS_KWEXP_OLD  },
	{ 'b',   RCS_KWEXP_NONE },
};
#endif

a203 1

a214 1

a215 1
char *timezone_flag = NULL;
d217 2
a240 12
/*
 * rcs_open()
 *
 * Open a file containing RCS-formatted information.  The file's path is
 * given in <path>, and the opening flags are given in <flags>, which is either
 * RCS_READ, RCS_WRITE, or RCS_RDWR.  If the open requests write access and
 * the file does not exist, the RCS_CREATE flag must also be given, in which
 * case it will be created with the mode specified in a third argument of
 * type mode_t.  If the file exists and RCS_CREATE is passed, the open will
 * fail.
 * Returns a handle to the opened file on success, or NULL on failure.
 */
d242 1
a242 1
rcs_open(const char *path, int flags, ...)
d244 1
a244 1
	int ret, mode;
a246 1
	struct stat st;
d254 5
a258 17
	if (((ret = stat(path, &st)) == -1) && errno == ENOENT) {
		if (flags & RCS_CREATE) {
			va_start(vap, flags);
			mode = va_arg(vap, int);
			va_end(vap);
			fmode = (mode_t)mode;
		} else {
			/* XXX, make this command dependant? */
#if 0
			cvs_log(LP_ERR, "RCS file `%s' does not exist", path);
#endif
			rcs_errno = RCS_ERR_NOENT;
			return (NULL);
		}
	} else if (ret == 0 && (flags & RCS_CREATE)) {
		cvs_log(LP_ERR, "RCS file `%s' exists", path);
		return (NULL);
d266 1
a356 1
 * Returns 0 on success, or -1 on failure.
d358 1
a358 1
int
d362 1
a362 2
	char buf[1024], numbuf[64], fn[19] = "";
	void *bp;
a367 1
	ssize_t nread, nwritten;
d374 1
a374 1
		return (0);
d379 2
a380 1
	strlcpy(fn, "/tmp/rcs.XXXXXXXXXX", sizeof(fn));
d382 1
a382 1
		fatal("mkstemp: `%s': %s", fn, strerror(errno));
d385 6
a390 3
		fd = errno;
		unlink(fn);
		fatal("fdopen: %s", strerror(fd));
d414 4
a417 3
		strlcpy(buf, symp->rs_name, sizeof(buf));
		strlcat(buf, ":", sizeof(buf));
		strlcat(buf, numbuf, sizeof(buf));
d500 1
a500 1
	fclose(fp);
d502 4
a505 12
	/*
	 * We try to use rename() to atomically put the new file in place.
	 * If that fails, we try a copy.
	 */
	if (rename(fn, rfp->rf_path) == -1) {
		if (errno == EXDEV) {
			/* rename() not supported so we have to copy. */
			if (chmod(rfp->rf_path, S_IWUSR) == -1 &&
			    !(rfp->rf_flags & RCS_CREATE)) {
				fatal("chmod(%s, 0%o) failed",
				    rfp->rf_path, S_IWUSR);
			}
d507 1
a507 5
			if ((from_fd = open(fn, O_RDONLY)) == -1) {
				cvs_log(LP_ERRNO, "failed to open `%s'",
				    rfp->rf_path);
				return (-1);
			}
d509 3
a511 6
			if ((to_fd = open(rfp->rf_path,
			    O_WRONLY|O_TRUNC|O_CREAT)) == -1) {
				cvs_log(LP_ERRNO, "failed to open `%s'", fn);
				close(from_fd);
				return (-1);
			}
d513 13
a525 10
			bp = xmalloc(MAXBSIZE);
			for (;;) {
				if ((nread = read(from_fd, bp, MAXBSIZE)) == 0)
					break;
				if (nread == -1)
					goto err;
				nwritten = write(to_fd, bp, (size_t)nread);
				if (nwritten == -1 || nwritten != nread)
					goto err;
			}
d527 1
a527 10
			if (nread < 0) {
err:				if (unlink(rfp->rf_path) == -1)
					cvs_log(LP_ERRNO,
					    "failed to unlink `%s'",
					    rfp->rf_path);
				close(from_fd);
				close(to_fd);
				xfree(bp);
				return (-1);
			}
d529 3
a531 12
			close(from_fd);
			close(to_fd);
			xfree(bp);

			if (unlink(fn) == -1) {
				cvs_log(LP_ERRNO,
				    "failed to unlink `%s'", fn);
				return (-1);
			}
		} else {
			cvs_log(LP_ERRNO,
			    "failed to access temp RCS output file");
d534 9
d545 12
a556 3
	if (chmod(rfp->rf_path, rfp->rf_mode) == -1) {
		cvs_log(LP_ERRNO, "failed to chmod `%s'",
		    rfp->rf_path);
d560 23
a582 1
	rfp->rf_flags |= RCS_SYNCED;
d584 1
a584 1
	return (0);
d1356 1
a1356 3
	size_t len;
	char *tmpdir;
	char *newdeltatext, path_tmp1[MAXPATHLEN], path_tmp2[MAXPATHLEN];
a1359 6
#if defined(RCSPROG)
	tmpdir = rcs_tmpdir;
#else
	tmpdir = cvs_tmpdir;
#endif

d1394 2
a1395 10
		len = strlcpy(path_tmp1, tmpdir, sizeof(path_tmp1));
		if (len >= sizeof(path_tmp1))
			fatal("path truncation in rcs_rev_remove");

		len = strlcat(path_tmp1, "/diff1.XXXXXXXXXX",
		    sizeof(path_tmp1));
		if (len >= sizeof(path_tmp1))
			fatal("path truncation in rcs_rev_remove");

		cvs_buf_write_stmp(nextbuf, path_tmp1, 0600);
d1398 2
a1399 10
		len = strlcpy(path_tmp2, tmpdir, sizeof(path_tmp2));
		if (len >= sizeof(path_tmp2))
			fatal("path truncation in rcs_rev_remove");

		len = strlcat(path_tmp2, "/diff2.XXXXXXXXXX",
		    sizeof(path_tmp2));
		if (len >= sizeof(path_tmp2))
			fatal("path truncation in rcs_rev_remove");

		cvs_buf_write_stmp(prevbuf, path_tmp2, 0600);
d1403 2
a1404 1
		cvs_diffreg(path_tmp1, path_tmp2, newdiff);
d1440 5
d1723 2
a1724 2
	if ((pdp->rp_file = fopen(rfp->rf_path, "r")) == NULL)
		fatal("fopen: `%s': %s", rfp->rf_path, strerror(errno));
d2012 1
a2012 2
			cvs_log(LP_ERR,
			    "unexpected token `%s' in RCS delta",
d2103 3
a2105 1
	strlcpy(rdp->rd_text, RCS_TOKSTR(rfp), (RCS_TOKLEN(rfp) + 1));
d2392 3
a2394 1
		strlcpy(pdp->rp_buf, pdp->rp_ptok, pdp->rp_blen);
d2508 3
a2510 1
	strlcpy(pdp->rp_ptok, tok, sizeof(pdp->rp_ptok));
a2587 7
	 * -z support for RCS
	 */
	tb = rdp->rd_date;
	if (timezone_flag != NULL)
		rcs_set_tz(timezone_flag, rdp, &tb);

	/*
d2653 9
a2661 4
				strlcat(expbuf, "$", sizeof(expbuf));
				strlcat(expbuf, kwstr, sizeof(expbuf));
				if (mode & RCS_KWEXP_VAL)
					strlcat(expbuf, ": ", sizeof(expbuf));
d2671 1
a2671 1
						strlcat(expbuf,
d2675 6
a2680 3
						strlcat(expbuf, rcsfile,
						    sizeof(expbuf));
					strlcat(expbuf, " ", sizeof(expbuf));
d2686 6
a2691 2
					strlcat(buf, " ", sizeof(buf));
					strlcat(expbuf, buf, sizeof(expbuf));
d2695 1
a2695 4
					if (timezone_flag != NULL)
						fmt = "%Y/%m/%d %H:%M:%S%z ";
					else
						fmt = "%Y/%m/%d %H:%M:%S ";
d2698 4
a2701 1
					strlcat(expbuf, buf, sizeof(expbuf));
d2705 6
a2710 3
					strlcat(expbuf, rdp->rd_author,
					    sizeof(expbuf));
					strlcat(expbuf, " ", sizeof(expbuf));
d2714 6
a2719 3
					strlcat(expbuf, rdp->rd_state,
					    sizeof(expbuf));
					strlcat(expbuf, " ", sizeof(expbuf));
d2724 4
a2727 1
					strlcat(expbuf, " ", sizeof(expbuf));
d2730 6
a2735 3
					strlcat(expbuf, rcsfile,
					    sizeof(expbuf));
					strlcat(expbuf, " ", sizeof(expbuf));
d2739 4
a2742 1
					strlcat(expbuf, " ", sizeof(expbuf));
d2747 3
a2749 1
				strlcat(expbuf, "$", sizeof(expbuf));
d2753 1
d2761 1
d2769 3
a2771 2
			strlcpy(start, expbuf, len);
			strlcat(data, tbuf, len);
d2939 1
a2939 1
		    fatal("could not fetch revision");
a2950 245

#if !defined(RCSPROG)

static char *month_tab[] = {
	"Jan",
	"Feb",
	"Mar",
	"Apr",
	"May",
	"Jun",
	"Jul",
	"Aug",
	"Sep",
	"Oct",
	"Nov",
	"Dec"
};

void
rcs_kflag_usage(void)
{
	(void)fprintf(stderr, "Valid expansion modes include:\n"
	    "\t-kkv\tGenerate keywords using the default form.\n"
	    "\t-kkvl\tLike -kkv, except locker's name inserted.\n"
	    "\t-kk\tGenerate only keyword names in keyword strings.\n"
	    "\t-kv\tGenerate only keyword values in keyword strings.\n"
	    "\t-ko\tGenerate old keyword string "
	    "(no changes from checked in file).\n"
	    "\t-kb\tGenerate binary file unmodified (merges not allowed).\n");
}

/*
 * Checkout a certain revision <rev> of RCS file <rf> to either standard
 * output when running in server mode, or to <fpath> when running in local mode.
 *
 * If type is CHECKOUT_REV_MERGED we have an extra argument, which
 * is the buffer containing the merged file.
 *
 * If type is CHECKOUT_REV_REMOVED, the file has been removed and we
 * need to do the same thing.
 */
int
cvs_checkout_rev(RCSFILE *rf, RCSNUM *rev, CVSFILE *cf, char *fpath,
    int local, int type, ...)
{
	BUF *bp;
	int l, ret, fsize;
	char timebuf[32], entry[MAXPATHLEN], copyfile[MAXPATHLEN];
	char *content, *repo, buf[MAXPATHLEN], modestr[16];
	struct cvsroot *root;
	struct cvs_ent *ent;
	va_list ap;
	time_t rcstime;
	struct timeval tv[2];
	struct tm *tp;
	RCSNUM *oldrev;

	bp = NULL;
	ret = -1;
	content = NULL;
	oldrev = NULL;

	if (type != CHECKOUT_REV_MERGED && type != CHECKOUT_REV_REMOVED) {
		/* fetch the contents of the revision */
		if ((bp = rcs_getrev(rf, rev)) == NULL) {
			cvs_log(LP_ERR, "revision '%s' not found in file '%s'",
			    rcsnum_tostr(rev, buf, sizeof(buf)), fpath);
			goto out;
		}
		bp = rcs_kwexp_buf(bp, rf, rev);
	} else if (type != CHECKOUT_REV_REMOVED) {
		va_start(ap, type);
		bp = va_arg(ap, BUF *);
		va_end(ap);
	}

	if (type == CHECKOUT_REV_CREATED)
		rcstime = rcs_rev_getdate(rf, rev);
	else if (type == CHECKOUT_REV_MERGED ||
	    type == CHECKOUT_REV_UPDATED) {
		time(&rcstime);
		if ((rcstime = cvs_hack_time(rcstime, 1)) < 0)
			goto out;
	}

	if (type == CHECKOUT_REV_CREATED ||
	    type == CHECKOUT_REV_MERGED ||
	    type == CHECKOUT_REV_UPDATED) {
		ctime_r(&rcstime, timebuf);
		l = strlen(timebuf);
		if (l > 0 && timebuf[l - 1] == '\n')
			timebuf[--l] = '\0';

		l = snprintf(entry, sizeof(entry), "/%s/%s/%s/%s/", cf->cf_name,
		    rcsnum_tostr(rev, buf, sizeof(buf)),
		    (local == 1) ? timebuf : "",
		    (type == CHECKOUT_REV_MERGED) ? "+=" : "");
		if (l == -1 || l >= (int)sizeof(buf))
			goto out;
	}

	if (type == CHECKOUT_REV_MERGED) {
		oldrev = rcsnum_alloc();
		rcsnum_cpy(rev, oldrev, 0);

		if (oldrev->rn_id[oldrev->rn_len - 1] <= 0)
			goto out;
		oldrev = rcsnum_dec(oldrev);

		l = snprintf(copyfile, sizeof(copyfile), ".#%s.%s",
		    cf->cf_name, rcsnum_tostr(oldrev, buf, sizeof(buf)));
		if (l == -1 || l >= (int)sizeof(copyfile))
			goto out;
	}

	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);

	/*
	 * In local mode, just copy the entire contents to fpath.
	 * In server mode, we need to send it to the client together with
	 * some responses.
	 */
	if (local) {
		l = 0;
		if (cf->cf_entry == NULL) {
			l = 1;
			cf->cf_entry = cvs_ent_open(cf->cf_dir, O_RDWR);
			if (cf->cf_entry == NULL) {
				cvs_log(LP_ERR, "failed to open Entry "
				    "file '%s'", cf->cf_dir);
				goto out;
			}
		}

		cvs_ent_remove(cf->cf_entry, cf->cf_name, 1);
		if (type != CHECKOUT_REV_REMOVED) {
			cvs_ent_addln(cf->cf_entry, entry);
			ent = cvs_ent_get(cf->cf_entry, cf->cf_name);
			ent->processed = 1;
		}

		if (l == 1)
			cvs_ent_close(cf->cf_entry);

		switch (type) {
		case CHECKOUT_REV_REMOVED:
			if (cvs_unlink(fpath) < 0)
				goto out;
			break;
		case CHECKOUT_REV_MERGED:
			/* XXX move the old file when merging */
		case CHECKOUT_REV_UPDATED:
		case CHECKOUT_REV_CREATED:
			cvs_buf_write(bp, fpath, cf->cf_mode);
			/*
			 * correct the time first
			 */
			if ((rcstime = cvs_hack_time(rcstime, 0)) == 0)
				goto out;

			tv[0].tv_sec = rcstime;
			tv[0].tv_usec = 0;
			tv[1] = tv[0];
			if (utimes(fpath, tv) == -1)
				cvs_log(LP_ERRNO, "failed to set timestamps");
			break;
		}
	} else {
		/* sanity */
		if (cf->cf_type != DT_REG) {
			cvs_log(LP_ERR, "cvs_checkout_rev: none DT_REG file");
			goto out;
		}

		/*
		 * if we are removing a file, we don't need this stuff.
		 */
		if (type != CHECKOUT_REV_REMOVED) {
			if ((rcstime = cvs_hack_time(rcstime, 0)) == 0)
				goto out;

			tp = gmtime(&rcstime);
			l = snprintf(timebuf, sizeof(timebuf),
			    "%02d %s %d %02d:%02d:%02d -0000",
			    tp->tm_mday, month_tab[tp->tm_mon],
			    tp->tm_year + 1900, tp->tm_hour,
			    tp->tm_min, tp->tm_sec);
			if (l == -1 || l >= (int)sizeof(timebuf))
				goto out;

			fsize = cvs_buf_len(bp);
			cvs_modetostr(cf->cf_mode, modestr, sizeof(modestr));
			cvs_buf_putc(bp, '\0');
			content = cvs_buf_release(bp);
			bp = NULL;
		}

		if (type == CHECKOUT_REV_MERGED) {
			printf("Copy-file %s/\n", (cf->cf_dir != NULL) ?
			    cf->cf_dir : ".");
			printf("%s/%s/%s\n", root->cr_dir, repo, cf->cf_name);
			printf("%s\n", copyfile);
		}

		switch (type) {
		case CHECKOUT_REV_MERGED:
			printf("Merged");
			break;
		case CHECKOUT_REV_REMOVED:
			printf("Removed");
			break;
		case CHECKOUT_REV_CREATED:
			printf("Mod-time %s\n", timebuf);
			printf("Created");
			break;
		default:
			cvs_log(LP_ERR, "cvs_checkout_rev: bad type %d",
			    type);
			goto out;
		}

		printf(" %s/\n", (cf->cf_dir != NULL) ? cf->cf_dir : ".");
		printf("%s/%s\n", repo, cf->cf_name);

		if (type != CHECKOUT_REV_REMOVED) {
			printf("%s\n", entry);
			printf("%s\n%d\n%s", modestr, fsize, content);
		}
	}

	ret = 0;

out:
	if (oldrev != NULL)
		rcsnum_free(oldrev);
	if (bp != NULL)
		cvs_buf_free(bp);
	if (content != NULL)
		xfree(content);

	return (ret);
}

#endif	/* !RCSPROG */
@


1.170
log
@check rcs_head_set() return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.169 2006/04/14 02:49:43 deraadt Exp $	*/
d1166 1
a1166 1
	int isbranch, lookonbranch;
d1238 2
d1262 1
d1266 2
@


1.169
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.168 2006/04/14 02:45:35 deraadt Exp $	*/
d1470 2
a1471 1
		rcs_head_set(rf, prevrdp->rd_num);
@


1.168
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.167 2006/04/13 23:41:13 ray Exp $	*/
d1217 1
a1217 1
	 */ 
@


1.167
log
@Change rcs_parse_init() to return void, since it always returned 0.
Remove unused variables found by lint.

Some parts OK xsa@@, ``throw it in :)'' joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.166 2006/04/13 19:55:41 joris Exp $	*/
d285 1
a285 1
	if (((ret = stat(path, &st)) == -1) && (errno == ENOENT)) {
d299 1
a299 1
	} else if ((ret == 0) && (flags & RCS_CREATE)) {
d549 2
a550 2
			if ((chmod(rfp->rf_path, S_IWUSR) == -1)
			    && !(rfp->rf_flags & RCS_CREATE)) {
d606 1
a606 1
	if ((chmod(rfp->rf_path, rfp->rf_mode) == -1)) {
d919 2
a920 2
		if ((strcmp(lkp->rl_name, user) == 0) &&
		    (rcsnum_cmp(rev, lkp->rl_num, 0) == 0)) {
d951 2
a952 2
		if ((strcmp(lkp->rl_name, user) == 0) &&
		    (rcsnum_cmp(lkp->rl_num, rev, 0) == 0))
d1084 2
a1085 2
		if ((lineno > dlines->l_nblines) || (lineno < 0) ||
		    (*ep != ' '))
d1089 1
a1089 1
		if ((nbln < 0) || (*ep != '\0'))
d1102 1
a1102 1
				    (ndlp->l_lineno > lineno))
d1241 2
a1242 2
		if ((isbranch == 1) && (rdp->rd_num->rn_len < rev->rn_len) &&
		    (!TAILQ_EMPTY(&(rdp->rd_branches))))
d1288 2
a1289 2
	if (cvs_buf_getc(rbuf, cvs_buf_len(rbuf)-1) != '\n'
	    && rbuf != NULL)
d1420 1
a1420 1
	if ((prevrdp != NULL) && (nextrdp != NULL)) {
d1455 1
a1455 1
	} else if ((nextrdp == NULL) && (prevrdp != NULL)) {
d1467 1
a1467 1
	if ((prevrdp != NULL) && (nextrdp != NULL)) {
d1513 2
a1514 2
	if ((rdp == NULL)
	    || (rcsnum_cmp(rdp->rd_num, rev, 0) == -1)) {
d1644 1
a1644 1
	if ((code < 0) || ((code >= (int)RCS_NERR) && (code != RCS_ERR_ERRNO)))
d1694 2
a1695 2
	if ((rfp->rf_flags & PARSED_DELTATEXTS)
	    || (rfp->rf_flags & RCS_CREATE))
d1809 1
a1809 1
		} else if ((tok == RCS_TOK_NUM) || (tok == RCS_TOK_DESC)) {
d3025 1
a3025 1
	if ((type != CHECKOUT_REV_MERGED) && (type != CHECKOUT_REV_REMOVED)) {
d3053 1
a3053 1
		if ((l > 0) && (timebuf[l - 1] == '\n'))
@


1.166
log
@add support for the openrcs -o'range' option.
-o allows users to delete revisions in the specified RCS files.

example:
	rcs -o1.4:1.6 foo deletes revisions 1.4 - 1.6
	rcs -o1.3 foo deletes revision 1.3

joint work with niallo@@
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.165 2006/04/13 19:16:15 joris Exp $	*/
d237 1
a237 1
static int	rcs_parse_init(RCSFILE *);
d315 2
a316 5
	if (!(rfp->rf_flags & RCS_CREATE)
	    && (rcs_parse_init(rfp) < 0)) {
		rcs_close(rfp);
		return (NULL);
	}
d637 1
a637 3
	struct rcs_delta *rd;

	if ((rd = rcs_findrev(file, rev)) == NULL)
d1750 1
a1750 2
 * Just does admin section
 * Returns 0 on success, or -1 on failure.
d1752 1
a1752 1
static int
a1754 1
	int ret, count;
a1756 1
	count = 0;
d1758 1
a1758 1
		return (0);
d1776 1
a1776 1
	if ((ret = rcs_parse_admin(rfp)) < 0) {
a1784 1
	return (0);
@


1.165
log
@fix -z option for openrcs, this was broken by xsa
when he yanked the code out of rcs.c and placed it in rcstime.c.

	struct tm ltb, *tb;
	tb = &ltb;
	return (tb);

isn't really the most perfect idiom to return a value to the caller, now is it?

as a bonus -z for rlog now works too.
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.164 2006/04/12 22:54:23 ray Exp $	*/
d1386 11
a1396 2
	int ret;
	struct rcs_delta *rdp;
a1397 1
	ret = 0;
d1404 75
a1478 1
		ret = -1;
d1480 2
a1481 4
		/* XXX assumes it's not a sub node */
		TAILQ_REMOVE(&(rf->rf_delta), rdp, rd_list);
		rf->rf_ndelta--;
		rf->rf_flags &= ~RCS_SYNCED;
d1484 7
a1490 1
	return (ret);
d1492 1
@


1.164
log
@Better match GNU behavior for rcs -l and rcs -u.
Save 2 bytes of newlines.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.163 2006/04/10 12:15:21 xsa Exp $	*/
d2539 1
a2539 1
	struct tm *tb;
d2549 1
a2549 1
	tb = &rdp->rd_date;
d2551 1
a2551 1
		tb = rcs_set_tz(timezone_flag, rdp);
d2654 1
a2654 1
					strftime(buf, sizeof(buf), fmt, tb);
@


1.163
log
@rcs_kflag_usage() is not used by usr.bin/rcs; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.162 2006/04/10 08:08:00 xsa Exp $	*/
a940 2


@


1.162
log
@change rcs_kwexp_set() return type to void and simplify its use. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.161 2006/04/05 01:38:55 ray Exp $	*/
a1572 13
void
rcs_kflag_usage(void)
{
	fprintf(stderr, "Valid expansion modes include:\n"
	    "\t-kkv\tGenerate keywords using the default form.\n"
	    "\t-kkvl\tLike -kkv, except locker's name inserted.\n"
	    "\t-kk\tGenerate only keyword names in keyword strings.\n"
	    "\t-kv\tGenerate only keyword values in keyword strings.\n"
	    "\t-ko\tGenerate old keyword string "
	    "(no changes from checked in file).\n"
	    "\t-kb\tGenerate binary file unmodified (merges not allowed).\n");
}

d2905 13
d3131 1
a3131 1
#endif
@


1.161
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.160 2006/04/02 20:57:53 joris Exp $	*/
a1472 1
 * Returns 0 on success, or -1 on failure.
d1474 1
a1474 1
int
d1481 1
a1481 1
		return (-1);
a1502 2

	return (0);
@


1.160
log
@some characters are in fact allowed in symbol names, don't freak
out when we encounter them, but handle them correctly.

fixes an issue i ran into when running opencvs update on my local tree;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.159 2006/04/01 18:02:55 joris Exp $	*/
d304 1
a304 2
	rfp = (RCSFILE *)xmalloc(sizeof(*rfp));
	memset(rfp, 0, sizeof(*rfp));
d703 1
a703 1
	ap = (struct rcs_access *)xmalloc(sizeof(*ap));
d767 1
a767 1
	symp = (struct rcs_sym *)xmalloc(sizeof(*symp));
d931 1
a931 1
	lkp = (struct rcs_lock *)xmalloc(sizeof(*lkp));
d1342 1
a1342 2
	rdp = (struct rcs_delta *)xmalloc(sizeof(*rdp));
	memset(rdp, 0, sizeof(*rdp));
d1699 1
a1699 2
	pdp = (struct rcs_pdata *)xmalloc(sizeof(*pdp));
	memset(pdp, 0, sizeof(*pdp));
d1707 1
a1707 1
	pdp->rp_buf = (char *)xmalloc((size_t)RCS_BUFSIZE);
d1856 1
a1856 2
	rdp = (struct rcs_delta *)xmalloc(sizeof(*rdp));
	memset(rdp, 0, sizeof(*rdp));
d2085 1
a2085 1
	rdp->rd_text = (u_char *)xmalloc(RCS_TOKLEN(rfp) + 1);
d2142 1
a2142 1
		symp = (struct rcs_sym *)xmalloc(sizeof(*symp));
d2207 1
a2207 1
		lkp = (struct rcs_lock *)xmalloc(sizeof(*lkp));
d2289 1
a2289 1
		brp = (struct rcs_branch *)xmalloc(sizeof(*brp));
d2506 1
a2506 1
	pdp->rp_buf = (char *)tmp;
d2707 1
a2707 2
			tbuf = xmalloc(strlen(end) + 1);
			strlcpy(tbuf, end, strlen(end) + 1);
d2710 2
d2713 2
a2714 1
				data = xrealloc(data, 1, len);
d2755 2
a2756 1
		rdp->rd_text = (u_char *)xmalloc(len + 1);
@


1.159
log
@don't use mode_t with va_arg(), use int instead and cast it later to
mode_t. doing it the other way around isn't portable as mode_t may
vary from int on some systems to short on others.

noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.158 2006/03/30 23:12:52 joris Exp $	*/
d2401 2
a2402 1
			if (!isalnum(ch) && ch != '_' && ch != '-') {
@


1.158
log
@hmm, let's not use fatal() when we cannot find a branch instead return NULL
so the caller can identify the branch is not there and take correct action.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.157 2006/03/30 23:09:01 joris Exp $	*/
d274 1
a274 1
	int ret;
d288 1
a288 1
			fmode = va_arg(vap, mode_t);
d290 1
@


1.157
log
@zap unused variable, niallo@@ noticed
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.156 2006/03/30 23:06:25 joris Exp $	*/
d1229 1
a1229 1
			fatal("failed to translate branch to latest revision");
d1448 1
a1448 1
				fatal("failed to translate branch to last revision");
@


1.156
log
@first part of supporting branches in openrcs. right now we can only
check them out. commit is not working yet, but will be soon.

tested by myself and ray@@
okay ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.155 2006/03/29 09:16:53 ray Exp $	*/
a2313 1
	struct rcs_delta *crdp;
@


1.155
log
@Yet more lint:
 - Explicitly test for -1 from read(2) and write(2).
 - Change negative parameters to 0 for rcsnum_cmp().  (I think xsa@@ had
   a patch for this earlier.)
 - Remove unused variables.
 - Changed return types to void if we only return one value.
 - Fix possible one-character truncation in rcs_deltatext_set().
 - Use memcpy() to copy u_char arrays.
 - Use ptrdiff_t to hold pointer differences.
 - int -> size_t for sizeof/strlen

``looks fine'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.154 2006/03/28 07:42:56 ray Exp $	*/
d1172 2
a1173 1
	int res;
d1176 1
a1176 1
	RCSNUM *crev, *rev;
d1179 1
d1189 6
a1194 4
	res = rcsnum_cmp(rfp->rf_head, rev, 0);
	if (res == 1) {
		rcs_errno = RCS_ERR_NOENT;
		return (NULL);
d1205 1
d1208 1
d1219 52
a1270 5
	if (res != 0) {
		/* Apply patches backwards to get the right version.
		 * This will need some rework to support sub branches.
		 */
		do {
d1272 23
a1294 18
			rdp = rcs_findrev(rfp, crev);
			if (rdp == NULL) {
				cvs_buf_free(rbuf);
				return (NULL);
			}
			cvs_buf_putc(rbuf, '\0');
			/* check if we have parsed this rev's deltatext */
			if (rdp->rd_tlen == 0)
				rcs_parse_deltatexts(rfp, rdp->rd_num);

			bp = cvs_buf_release(rbuf);
			rbuf = cvs_patchfile((char *)bp, (char *)rdp->rd_text,
			    rcs_patch_lines);
			xfree(bp);
			if (rbuf == NULL)
				break;
		} while (rcsnum_cmp(crev, rev, 0) != 0);
	}
d1298 1
a1345 1
	TAILQ_INIT(&(rdp->rd_snodes));
d1416 4
d1426 2
a1427 3
	struct rcs_delta *rdp, *enddelta;
	struct rcs_dlist *hp;
	int found;
d1433 3
a1435 3
	enddelta = TAILQ_LAST(&(rfp->rf_delta), rcs_dlist);
	if ((enddelta == NULL)
	    || (rcsnum_cmp(enddelta->rd_num, rev, 0) == -1)) {
d1439 10
a1448 2
	cmplen = 2;
	hp = &(rfp->rf_delta);
d1450 1
a1450 10
	do {
		found = 0;
		TAILQ_FOREACH(rdp, hp, rd_list) {
			if (rcsnum_cmp(rdp->rd_num, rev, cmplen) == 0) {
				if (cmplen == rev->rn_len)
					return (rdp);

				hp = &(rdp->rd_snodes);
				cmplen += 2;
				found = 1;
d1452 2
a1453 1
			}
d1455 11
a1465 1
	} while (found && cmplen < rev->rn_len);
a1864 1
	TAILQ_INIT(&(rdp->rd_snodes));
a2335 5
	}

	while ((crdp = TAILQ_FIRST(&(rdp->rd_snodes))) != NULL) {
		TAILQ_REMOVE(&(rdp->rd_snodes), crdp, rd_list);
		rcs_freedelta(crdp);
@


1.154
log
@Finally.  Basically, rcs_parse_delta() doesn't understand that
sometimes there are no revisions, and that it is not an error.  This
makes it so that if rcs_parse_delta is called and the only thing
that is found is the description, we know that there are no more
revisions.

Fixes ``rcs -i file; rlog file''.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.152 2006/03/27 21:56:32 niallo Exp $	*/
d254 1
a254 1
static int	rcs_strprint(const u_char *, size_t, FILE *);
d415 1
a415 1
	ssize_t nread;
d572 7
a578 2
			while ((nread = read(from_fd, bp, MAXBSIZE)) > 0) {
				if (write(to_fd, bp, nread) != nread)
d1374 1
a1374 1
	    || (rcsnum_cmp(enddelta->rd_num, rev, -1) == -1)) {
d1537 1
a1537 1
			if (rcsnum_cmp(enddelta->rd_num, rev, -1) == 0)
d2456 1
a2456 1
static int
a2459 1
	size_t ret;
d2462 1
a2462 1
		return (0);
d2470 1
a2470 1
		ret = fwrite(sp, sizeof(u_char), ap - sp + 1, stream);
a2475 2

	return (0);
d2489 1
d2491 2
a2492 2
	int kwtype, sizdiff;
	u_int j, found, start_offset, c_offset;
d2691 3
a2693 3
		rdp->rd_text = (u_char *)xmalloc(len);
		rdp->rd_tlen = len - 1;
		strlcpy(rdp->rd_text, dtext, len);
@


1.153
log
@Today is Integer Overflow Prevention Day:
 - Sync xmalloc.? with ssh versions.
 - Change all xrealloc() calls to new API.

``I really like this.'' niallo@@
@
text
@d1792 4
a1795 1
	if (tok != RCS_TOK_NUM) {
@


1.152
log
@- properly implement GNU file modes.  basically, checkout will inherit
permissions from rcs file and initial checkin will inherit permissions from
working file.

problem spotted by uwe@@

ok ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.151 2006/03/27 16:01:18 xsa Exp $	*/
d2435 1
a2435 1
	tmp = xrealloc(pdp->rp_buf, pdp->rp_blen + RCS_BUFEXTSIZE);
d2644 1
a2644 1
				data = xrealloc(data, len);
@


1.151
log
@rcs_growbuf() cleanup; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.150 2006/03/27 15:26:12 xsa Exp $	*/
a236 1
static int	rcs_write(RCSFILE *);
d282 1
a282 1
	fmode = 0;
d404 1
a404 1
static int
d604 1
a604 1
	if ((chmod(rfp->rf_path, S_IRUSR|S_IRGRP|S_IROTH) == -1)) {
a2831 1

@


1.150
log
@rcs_comment_set() will never return non-zero; change its return type to void.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.149 2006/03/27 07:14:13 xsa Exp $	*/
d254 1
a254 1
static int	rcs_growbuf(RCSFILE *);
d2337 1
a2337 4
				if (rcs_growbuf(rfp) < 0) {
					type = RCS_TOK_ERR;
					break;
				}
d2370 1
a2370 4
				if (rcs_growbuf(rfp) < 0) {
					type = RCS_TOK_ERR;
					break;
				}
a2428 1
 * Returns 0 on success, or -1 on failure.
d2430 1
a2430 1
static int
a2436 6
	if (tmp == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to grow RCS parse buffer");
		return (-1);
	}

a2439 2

	return (0);
@


1.149
log
@rcs_desc_set() will never return non-zero; change its return type to void.
OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.148 2006/03/26 20:02:54 xsa Exp $	*/
a1040 1
 * Returns 0 on success, or -1 on failure.
d1042 1
a1042 1
int
a1051 2

	return (0);
@


1.148
log
@rcs_parse_desc() cleanup; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.147 2006/03/25 21:29:59 ray Exp $	*/
a988 1
 * Returns 0 on success, or -1 on failure.
d990 1
a990 1
int
a999 2

	return (0);
@


1.147
log
@Correct integer types, remove unused arguments, non-portable bitshifts
changed to division, KNF, replace unreachable code with goto fail,
et cetera.  Found by lint.

The free() -> xfree() as well.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.146 2006/03/24 16:18:22 xsa Exp $	*/
d244 1
a244 1
static int	rcs_parse_desc(RCSFILE *, RCSNUM *);
a1588 2
 *
 * Returns 0 on success, -1 on failure.
d1590 1
a1590 1
static int
d1594 3
a1596 3
	if ((rfp->rf_flags & PARSED_DESC)
	    || (rfp->rf_flags & RCS_CREATE))
		return (0);
d1601 2
a1602 3
	if (ret != RCS_TOK_DESC) {
		rcs_errno = RCS_ERR_PARSE;
		cvs_log(LP_ERR, "token `%s' found where RCS desc expected",
a1603 3
		fatal("problem parsing RCS desc");
		return (-1);
	}
d1606 2
a1607 3
	if (ret != RCS_TOK_STRING) {
		rcs_errno = RCS_ERR_PARSE;
		cvs_log(LP_ERR, "token `%s' found where RCS desc expected",
a1608 2
		fatal("problem parsing RCS desc");
	}
a1611 1
	return (0);
@


1.146
log
@change rcs_parse_deltas() and rcs_parse_deltatexts() return value
to void as they never return non-zero. OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.145 2006/03/23 09:03:28 xsa Exp $	*/
d1432 1
a1432 1
		free(file->rf_expand);
d1691 1
a1691 1
			return (-1);
d1710 1
a1710 1
			return (-1);
d1739 1
a1739 1
					return (-1);
d1753 1
a1753 1
				return (-1);
d1758 1
a1758 1
				return (-1);
d1762 1
a1762 1
				return (-1);
d1766 1
a1766 1
				return (-1);
d1773 1
a1773 1
			return (-1);
d1777 2
a1778 1
	return (0);
d2516 1
d2518 1
a2518 1
	u_int i, j, found, start_offset, c_offset;
@


1.145
log
@use fatal() in rcs_lock_setmode(); OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.144 2006/03/15 05:05:35 deraadt Exp $	*/
d241 1
a241 1
static int	rcs_parse_deltas(RCSFILE *, RCSNUM *);
d243 1
a243 1
static int	rcs_parse_deltatexts(RCSFILE *, RCSNUM *);
a1524 2
 *
 * Returns 0 on success, -1 on failure.
d1526 1
a1526 1
static int
d1531 4
a1534 3
	if ((rfp->rf_flags & PARSED_DELTAS)
	    || (rfp->rf_flags & RCS_CREATE))
		return (0);
a1548 1
	return (0);
a1554 2
 *
 * Returns 0 on success, -1 on failure.
d1556 1
a1556 1
static int
d1561 1
d1564 2
a1565 1
		return (0);
d1581 1
a1581 1
		else if (ret == -1) {
a1582 1
		}
a1583 2

	return (0);
@


1.144
log
@remove some bizzare idioms; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.143 2006/03/11 22:44:11 niallo Exp $	*/
d900 2
a901 4
	else {
		cvs_log(LP_ERRNO, "invalid lock mode %d", mode);
		return (-1);
	}
@


1.143
log
@- implement GNU-compatible handling of revisions specified as single
digits.  e.g. ci -l4 or ci -u5 will work like GNU now.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.142 2006/03/11 18:40:14 niallo Exp $	*/
d2545 1
a2545 1
	for (c = data; *c != '\0' && i < len; *c++) {
d2552 1
a2552 1
			*c++;
@


1.142
log
@- set RCS_SYNCED on rcs_open() so that if you call rcs_close() immediately
it will not write out a blank RCS file if there is no data in the backing
structure.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.141 2006/03/10 05:57:39 ray Exp $	*/
a1266 1
	RCSNUM *old;
a1267 1
	old = rcsnum_alloc();
a1274 1
			rcsnum_cpy(rf->rf_head, old, 0);
a1279 1
			rcsnum_free(old);
a1281 9

		if (!(rf->rf_flags & RCS_CREATE)) {
			ordp = NULL;
			rcsnum_cpy(rev, old, 0);
			while (ordp == NULL) {
				old = rcsnum_dec(old);
				ordp = rcs_findrev(rf, old);
			}
		}
d1298 5
a1302 2
	if (!(rf->rf_flags & RCS_CREATE))
		rcsnum_cpy(old, rdp->rd_next, 0);
a1303 1
	rcsnum_free(old);
d2962 1
a2962 1
		if (rcsnum_dec(oldrev) == NULL)
d2964 1
@


1.141
log
@Only write a log message if the log message is not empty.
Also prevents rfp->rf_desc[-1] from happening.

ok joris, niallo, otto, and xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.140 2006/03/09 10:56:33 xsa Exp $	*/
d308 1
a308 1
	rfp->rf_flags = flags | RCS_SLOCK;
@


1.140
log
@move joris' timezone support into rcstime.c; more work to be done there.
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.139 2006/03/08 09:03:59 xsa Exp $	*/
d515 1
a515 2
	if (rfp->rf_desc != NULL) {
		len = strlen(rfp->rf_desc);
@


1.139
log
@really match gnu on error;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.138 2006/03/08 05:01:50 deraadt Exp $	*/
a2533 1
	int tzone;
d2536 1
a2536 1
	char *c, *kwstr, *start, *end, *tbuf, *m, *h;
d2538 1
a2538 2
	struct tm *tb, ltb;
	time_t now;
d2549 2
a2550 51
	if (timezone_flag != NULL) {
		if (!strcmp(timezone_flag, "LT")) {
			now = mktime(&rdp->rd_date);
			tb = localtime(&now);
			tb->tm_hour += ((int)tb->tm_gmtoff / 3600);
		} else {
			switch (*timezone_flag) {
			case '-':
			case '+':
				break;
			default:
				fatal("%s: not a known time zone",
				    timezone_flag);
			}

			h = timezone_flag;
			if ((m = strrchr(timezone_flag, ':')) != NULL)
				*(m++) = '\0';

			ltb = rdp->rd_date;
			tb = &ltb;

			tzone = atoi(h);

			if (tzone >= 24 && tzone <= -24)
				fatal("%s: not a known time zone",
				    timezone_flag);

			tb->tm_hour += tzone;
			if (tb->tm_hour >= 24 && tb->tm_hour <= -24)
				tb->tm_hour = 0;

			tb->tm_gmtoff += (tzone * 3600);

			if (m != NULL) {
				tzone = atoi(m);
				if (tzone >= 60)
					fatal("%s: not a known time zone",
					    timezone_flag);

				if ((tb->tm_min + tzone) >= 60) {
					tb->tm_hour++;
					tb->tm_min -= tzone;
				} else {
					tb->tm_min += tzone;
				}

				tb->tm_gmtoff += (tzone * 60);
			}
		}
	}
@


1.138
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.137 2006/03/07 19:17:57 joris Exp $	*/
d2562 2
a2563 1
				fatal("not a known time zone");
d2576 2
a2577 1
				fatal("not a known time zone");
d2588 2
a2589 1
					fatal("not a known time zone");
@


1.137
log
@in rcs_write() only do stuff when the RCS file ondisk isn't synced;
niallo agrees;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.136 2006/03/07 16:48:53 joris Exp $	*/
d1114 1
a1114 1
				    (ndlp->l_lineno > lineno)) 
d2734 1
a2734 1
			
d2924 1
a2924 1
		cvs_buf_set(bp, expanded, strlen(expanded), 0); 
@


1.136
log
@make sure the timezone is valid;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.135 2006/03/07 01:43:18 joris Exp $	*/
d422 3
a426 3

	if (rfp->rf_flags & RCS_SYNCED)
		return (0);
@


1.135
log
@match gnu on error;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.134 2006/03/07 01:40:52 joris Exp $	*/
d2557 8
@


1.134
log
@-z support for RCS;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.133 2006/03/05 16:22:31 niallo Exp $	*/
d2567 1
a2567 1
				fatal("not a known time zone: %d", tzone);
d2578 1
a2578 1
					fatal("not a known time zone: %d", tzone);
@


1.133
log
@in rcs_patch_lines(), ensure that rcs patch delete operations don't
leave the dlp pointing at a non-existant line, but instead point it to
the last one in our TAILQ.

this fixes an annoying bug in rcs_patch_lines() where dlp would be
sometimes set to NULL when really it shouldn't be, resulting in an
"invalid line specification in RCS patch" error.

ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.132 2006/03/05 16:06:59 niallo Exp $	*/
d235 1
a235 1

d2534 1
d2537 1
a2537 1
	char *c, *kwstr, *start, *end, *tbuf;
d2539 3
d2548 45
d2688 6
a2693 3
					strftime(buf, sizeof(buf),
					    "%Y/%m/%d %H:%M:%S ",
					    &rdp->rd_date);
@


1.132
log
@fatal() instead of returning -1 on failure in patch functions
ed_patch_lines() and rcs_patch_lines().  this can avoid segfault in certain
circumstances.

From: Ray Lai <ray@@cyth.net>

discussed with xsa@@ and joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.131 2006/03/05 14:18:56 niallo Exp $	*/
d1113 2
a1114 2
				ndlp = TAILQ_NEXT(dlp, l_list);
				if (ndlp->l_lineno > lineno)
d1127 6
@


1.131
log
@our deltatexts were sometimes different from gnu.  rcs_getrev() was
unconditionally doing keyword expansion, even when this wasn't what we
wanted e.g. in checkout_rev() and cvs_checkout_rev(). so:

- change semantics of rcs_getrev() to not do keyword expansion
- add an rcs.c api function rcs_kwexp_buf() which does this
- change both checkout_rev() and cvs_checkout_rev() to use this function.

eyeballed by xsa, joris and Ray Lai
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.130 2006/02/26 16:06:46 niallo Exp $	*/
d1097 2
a1098 5
		    (*ep != ' ')) {
			cvs_log(LP_ERR,
			    "invalid line specification in RCS patch");
			return (-1);
		}
d1101 2
a1102 5
		if ((nbln < 0) || (*ep != '\0')) {
			cvs_log(LP_ERR,
			    "invalid line number specification in RCS patch");
			return (-1);
		}
d1119 2
a1120 5
		if (dlp == NULL) {
			cvs_log(LP_ERR,
			    "can't find referenced line in RCS patch");
			return (-1);
		}
d1132 2
a1133 4
				if (lp == NULL) {
					cvs_log(LP_ERR, "truncated RCS patch");
					return (-1);
				}
d1144 2
a1145 4
		} else {
			cvs_log(LP_ERR, "unknown RCS patch operation `%c'", op);
			return (-1);
		}
@


1.130
log
@also set 'entry' variable in merged case.

fixes PR#5037

From Ray Lai <ray at cyth.net>

"somebody please commit" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.129 2006/02/13 11:02:58 xsa Exp $	*/
d257 1
a257 1
static char*	rcs_expand_keywords(char *, struct rcs_delta *, char *,
d1184 1
a1184 1
	int expmode, res;
a1189 1
	char *expanded;				/* XXX */
a1251 21
	/*
	 * Do keyword expansion if required.
	 */
	if (rfp->rf_expand != NULL)
		expmode = rcs_kwexp_get(rfp);
	else
		expmode = RCS_KWEXP_DEFAULT;

	if ((rbuf != NULL) && !(expmode & RCS_KWEXP_NONE)) {
		if ((rdp = rcs_findrev(rfp, rev)) == NULL)
			return (rbuf);
		cvs_buf_putc(rbuf, '\0');
		len = cvs_buf_len(rbuf);
		bp = cvs_buf_release(rbuf);
		expanded = rcs_expand_keywords(rfp->rf_path, rdp,
		    bp, len, expmode);
		rbuf = cvs_buf_alloc(len, BUF_AUTOEXT);
		cvs_buf_set(rbuf, expanded, strlen(expanded), 0); 
		xfree(expanded);
	}

d2840 37
d2933 1
@


1.129
log
@write out an empty comment in RCS files even if there isn't one as
gnu/usr.bin/cvs does. Found by niallo@@'s automatic tool.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.128 2006/02/09 08:08:56 niallo Exp $	*/
d2934 1
@


1.128
log
@- move rcs_kw-related data into rcs.h and de-static the keyword array. this
  allows access from outside rcs.c and will be needed for upcoming features
  in ci(1).

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.127 2006/02/01 13:52:51 xsa Exp $	*/
d478 1
a479 1
		fputs("comment\t@@", fp);
d483 2
a484 1
	}
@


1.127
log
@set rcs_errno accordingly in rcs_open() if the file is not found.
OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.126 2006/01/26 09:05:31 xsa Exp $	*/
d167 13
a220 36
/*
 * Keyword expansion table
 */
#define RCS_KW_AUTHOR		0x1000
#define RCS_KW_DATE		0x2000
#define RCS_KW_LOG		0x4000
#define RCS_KW_NAME		0x8000
#define RCS_KW_RCSFILE		0x0100
#define RCS_KW_REVISION		0x0200
#define RCS_KW_SOURCE		0x0400
#define RCS_KW_STATE		0x0800
#define RCS_KW_FULLPATH		0x0010

#define RCS_KW_ID \
	(RCS_KW_RCSFILE | RCS_KW_REVISION | RCS_KW_DATE \
	| RCS_KW_AUTHOR | RCS_KW_STATE)

#define RCS_KW_HEADER	(RCS_KW_ID | RCS_KW_FULLPATH)

static struct rcs_kw {
	char	kw_str[16];
	int	kw_type;
} rcs_expkw[] = {
	{ "Author",	RCS_KW_AUTHOR   },
	{ "Date",	RCS_KW_DATE     },
	{ "Header",	RCS_KW_HEADER   },
	{ "Id",		RCS_KW_ID       },
	{ "Log",	RCS_KW_LOG      },
	{ "Name",	RCS_KW_NAME     },
	{ "RCSfile",	RCS_KW_RCSFILE  },
	{ "Revision",	RCS_KW_REVISION },
	{ "Source",	RCS_KW_SOURCE   },
	{ "State",	RCS_KW_STATE    },
};

#define RCS_NKWORDS	(sizeof(rcs_expkw)/sizeof(rcs_expkw[0]))
@


1.126
log
@strings cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.125 2006/01/10 15:00:47 niallo Exp $	*/
d319 1
@


1.125
log
@- rewrite RCS keyword expansion. the old way of doing it was very slow,
this method avoids lots of expensive buffer operations, and gives OpenCVS a
considerable speed boost.

ok xsa@@ "put it in" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.124 2006/01/03 11:06:55 xsa Exp $	*/
d481 3
a483 1
		snprintf(buf, sizeof(buf), "%s:%s", symp->rs_name, numbuf);
@


1.124
log
@knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.123 2006/01/02 08:11:56 xsa Exp $	*/
d280 2
a281 2
static int	rcs_expand_keywords(char *, struct rcs_delta *, char *, char *,
		    size_t, int);
d1207 1
a1207 1
	BUF *rbuf, *dbuf = NULL;
d1209 1
a1209 3
	struct cvs_lines *lines;
	struct cvs_line *lp;
	char out[1024];				/* XXX */
d1269 3
a1271 1

a1280 1
		dbuf = cvs_buf_alloc(len, BUF_AUTOEXT);
a1282 1

d1284 1
a1284 1

d1286 5
a1290 12
		if ((lines = cvs_splitlines((char *)bp)) != NULL) {
			res = 0;
			TAILQ_FOREACH(lp, &lines->l_lines, l_list) {
				if (res++ == 0)
					continue;
				rcs_expand_keywords(rfp->rf_path, rdp,
				    lp->l_line, out, sizeof(out), expmode);
				cvs_buf_fappend(dbuf, "%s\n", out);
			}
			cvs_freelines(lines);
		}
		xfree(bp);
d1293 1
a1293 1
	return (dbuf);
d2574 3
a2576 1
 * Expand any RCS keywords in <line> into <out>
d2578 2
a2579 2
static int
rcs_expand_keywords(char *rcsfile, struct rcs_delta *rdp, char *line, char *out,
d2582 4
a2585 4
	int kwtype;
	u_int i, j, found;
	char *c, *kwstr, *start;
	char expbuf[128], buf[128];
d2596 1
a2596 3
	memset(out, '\0', len);
	for (c = line; *c != '\0' && i < len; *c++) {
		out[i++] = *c;
d2600 1
d2650 2
d2722 18
a2739 3

			out[--i] = '\0';
			strlcat(out, expbuf, len);
d2744 1
a2744 1
	return (0);
@


1.123
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.122 2005/12/30 17:51:01 reyk Exp $	*/
d264 1
a264 1
static int      rcs_parse_deltas(RCSFILE *, RCSNUM *);
d266 2
a267 2
static int      rcs_parse_deltatexts(RCSFILE *, RCSNUM *);
static int      rcs_parse_desc(RCSFILE *, RCSNUM *);
@


1.122
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.121 2005/12/30 16:53:55 niallo Exp $	*/
d27 1
a27 13
#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.121
log
@- zap unused 'rf_ref' member of RCSFILE structure.

spotted by joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.120 2005/12/30 16:48:33 niallo Exp $	*/
d350 1
a350 1
	if (!(rfp->rf_flags & RCS_CREATE) 
d1687 1
a1687 1
        if (!(rfp->rf_flags & PARSED_DELTAS))
d2997 2
a2998 2
				cvs_log(LP_ERR,
				    "failed to open Entry file '%s'", cf->cf_dir);
@


1.120
log
@- simplify an unecessary if/else construct in rcs_open()

spotted by joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.119 2005/12/30 16:45:35 niallo Exp $	*/
a341 1
	rfp->rf_ref = 1;
a380 5

	if (rfp->rf_ref > 1) {
		rfp->rf_ref--;
		return;
	}
@


1.119
log
@- realloc() -> xrealloc(), was missed in the original sweep.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.118 2005/12/28 18:27:24 joris Exp $	*/
d351 2
a352 2
	if (rfp->rf_flags & RCS_CREATE) {
	} else if (rcs_parse_init(rfp) < 0) {
@


1.118
log
@don't use rf_pdata when it's not allocated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.117 2005/12/27 16:05:20 niallo Exp $	*/
d2552 1
a2552 1
	tmp = realloc(pdp->rp_buf, pdp->rp_blen + RCS_BUFEXTSIZE);
@


1.117
log
@- implement lazy-parsing of rcs files, that is only parse as much as we
  need. this can save us much work, particularly with very large rcs files.

first of a few important performance improvements.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.116 2005/12/24 04:10:51 joris Exp $	*/
d433 2
a434 1
	rcs_freepdata(rfp->rf_pdata);
@


1.116
log
@remove useless cvs_buf_alloc() failure checks;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.115 2005/12/22 02:26:33 niallo Exp $	*/
d48 1
d273 1
a273 1
static int	rcs_parse(RCSFILE *);
d276 1
d278 2
d352 1
a352 1
	} else if (rcs_parse(rfp) < 0) {
d433 1
d461 3
d671 1
a671 1
rcs_head_set(RCSFILE *file, const RCSNUM *rev)
d1244 3
d1252 2
a1253 1

a1274 1

d1276 3
d1451 1
a1451 1
rcs_findrev(RCSFILE *rfp, const RCSNUM *rev)
d1454 1
a1454 1
	struct rcs_delta *rdp;
d1458 10
d1609 108
d1718 1
a1718 1
 * rcs_parse()
d1720 2
a1721 1
 * Parse the contents of file <path>, which are in the RCS format.
d1725 1
a1725 1
rcs_parse(RCSFILE *rfp)
d1727 1
a1727 1
	int ret;
d1730 1
d1753 1
a1753 20
		return (-1);
	} else if (ret == RCS_TOK_NUM) {
		for (;;) {
			ret = rcs_parse_delta(rfp);
			if (ret == 0)
				break;
			else if (ret == -1) {
				rcs_freepdata(pdp);
				return (-1);
			}
		}
	}

	ret = rcs_gettok(rfp);
	if (ret != RCS_TOK_DESC) {
		rcs_errno = RCS_ERR_PARSE;
		cvs_log(LP_ERR, "token `%s' found where RCS desc expected",
		    RCS_TOKSTR(rfp));
		rcs_freepdata(pdp);
		return (-1);
d1756 2
a1757 24
	ret = rcs_gettok(rfp);
	if (ret != RCS_TOK_STRING) {
		rcs_errno = RCS_ERR_PARSE;
		cvs_log(LP_ERR, "token `%s' found where RCS desc expected",
		    RCS_TOKSTR(rfp));
		rcs_freepdata(pdp);
		return (-1);
	}

	rfp->rf_desc = xstrdup(RCS_TOKSTR(rfp));
	for (;;) {
		ret = rcs_parse_deltatext(rfp);
		if (ret == 0)
			break;
		else if (ret == -1) {
			rcs_freepdata(pdp);
			return (-1);
		}
	}

	rcs_freepdata(pdp);

	rfp->rf_pdata = NULL;
	rfp->rf_flags |= RCS_PARSED | RCS_SYNCED;
d1759 1
d2766 3
@


1.115
log
@- fix handling of zero byte files.

with this diff, open cvs can do a full local checkout of the XF4 tree on
64-bit architectures, which gnu cvs cannot due to some bug.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.114 2005/12/20 18:17:01 xsa Exp $	*/
a1247 2
	if ((rbuf = cvs_buf_alloc(len, BUF_AUTOEXT)) == NULL)
		return (NULL);
d1249 1
d1284 1
a1284 2
		if ((dbuf = cvs_buf_alloc(len, BUF_AUTOEXT)) == NULL)
			return (rbuf);
@


1.114
log
@cvs_buf_putc() and cvs_buf_write_*() functions cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.113 2005/12/20 16:55:21 xsa Exp $	*/
d1243 5
@


1.113
log
@use fatal(); OK joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.112 2005/12/19 17:43:01 xsa Exp $	*/
d1260 2
a1261 4
			if (cvs_buf_putc(rbuf, '\0') < 0) {
				cvs_buf_free(rbuf);
				return (NULL);
			}
d1285 1
a1285 4
		if (cvs_buf_putc(rbuf, '\0') < 0) {
			cvs_buf_free(dbuf);
			return (rbuf);
		}
d2927 1
a2927 6
			if (cvs_buf_write(bp, fpath, cf->cf_mode) < 0) {
				cvs_log(LP_ERR, "failed to update file '%s'",
				    fpath);
				goto out;
			}

d2966 1
a2966 2
			if (cvs_buf_putc(bp, '\0') < 0)
				goto out;
@


1.112
log
@use fatal() if getpwuid() fails; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.111 2005/12/12 17:47:03 joris Exp $	*/
d460 7
a466 10
	if ((fd = mkstemp(fn)) == -1 ||
	    (fp = fdopen(fd, "w+")) == NULL) {
		if (fd != -1) {
			unlink(fn);
			close(fd);
		}
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to open temp RCS output file `%s'",
		    fn);
		return (-1);
d584 2
a585 3
				cvs_log(LP_ERRNO, "failed to chmod `%s'",
				    rfp->rf_path);
				return (-1);
d1608 2
a1609 7
	pdp->rp_file = fopen(rfp->rf_path, "r");
	if (pdp->rp_file == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to open RCS file `%s'", rfp->rf_path);
		rcs_freepdata(pdp);
		return (-1);
	}
@


1.111
log
@rcsnum_alloc() and rcsnum_cpy() no longer can fail, so don't
bother checking return values for failure.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.110 2005/12/10 20:27:45 joris Exp $	*/
d1364 2
a1365 5
	if ((pw = getpwuid(getuid())) == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		rcsnum_free(old);
		return (-1);
	}
@


1.110
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.109 2005/12/08 18:56:10 joris Exp $	*/
d674 2
a675 6
	if ((file->rf_head == NULL) &&
	    ((file->rf_head = rcsnum_alloc()) == NULL))
		return (-1);

	if (rcsnum_cpy(rev, file->rf_head, 0) < 0)
		return (-1);
d677 1
d705 2
a706 9
	if ((file->rf_branch == NULL) &&
	    ((file->rf_branch = rcsnum_alloc()) == NULL))
		return (-1);

	if (rcsnum_cpy(bnum, file->rf_branch, 0) < 0) {
		rcsnum_free(file->rf_branch);
		file->rf_branch = NULL;
		return (-1);
	}
d708 1
d798 1
a798 5
	if ((symp->rs_num = rcsnum_alloc()) == NULL) {
		xfree(symp->rs_name);
		xfree(symp);
		return (-1);
	}
d869 1
a869 1
	if (symp == NULL)
d871 3
a873 4
	else if (((num = rcsnum_alloc()) != NULL) &&
	    (rcsnum_cpy(symp->rs_num, num, 0) < 0)) {
		rcsnum_free(num);
		num = NULL;
d964 1
a964 5
	if ((lkp->rl_num = rcsnum_alloc()) == NULL) {
		xfree(lkp->rl_name);
		xfree(lkp);
		return (-1);
	}
d1336 1
a1336 3
	if ((old = rcsnum_alloc()) == NULL)
		return (-1);

d1341 1
a1341 4
			if ((rf->rf_head = rcsnum_alloc()) == NULL) {
				rcsnum_free(rev);
				return (-1);
			}
d1376 1
a1376 5
	if ((rdp->rd_num = rcsnum_alloc()) == NULL) {
		rcs_freedelta(rdp);
		rcsnum_free(old);
		return (-1);
	}
d1379 1
a1379 5
	if ((rdp->rd_next = rcsnum_alloc()) == NULL) {
		rcs_freedelta(rdp);
		rcsnum_free(old);
		return (-1);
	}
d1743 1
a1743 1
				if (rfp->rf_head == NULL) {
a1744 3
					if (rfp->rf_head == NULL)
						return (-1);
				}
d1748 1
a1748 1
				if (rfp->rf_branch == NULL) {
a1749 3
					if (rfp->rf_branch == NULL)
						return (-1);
				}
a1814 4
	if (rdp->rd_num == NULL) {
		rcs_freedelta(rdp);
		return (-1);
	}
a1815 4
	if (rdp->rd_next == NULL) {
		rcs_freedelta(rdp);
		return (-1);
	}
a1992 2
	if (tnum == NULL)
		return (-1);
a2098 6
		if (symp->rs_num == NULL) {
			cvs_log(LP_ERRNO, "failed to allocate rcsnum info");
			xfree(symp->rs_name);
			xfree(symp);
			return (-1);
		}
a2163 5
		if (lkp->rl_num == NULL) {
			xfree(lkp->rl_name);
			xfree(lkp);
			return (-1);
		}
d2893 2
a2894 5
		if ((oldrev = rcsnum_alloc()) == NULL)
			goto out;

		if (rcsnum_cpy(rev, oldrev, 0) < 0)
			goto out;
@


1.109
log
@complete and correct rcs locking functionality,
it was only done partially and as a bonus, completely wrong.

seriously guys what was up with that?
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.108 2005/12/03 15:31:53 joris Exp $	*/
d334 1
a334 5
	if ((rfp = (RCSFILE *)malloc(sizeof(*rfp))) == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate RCS file structure");
		rcs_errno = RCS_ERR_ERRNO;
		return (NULL);
	}
d337 1
a337 7
	if ((rfp->rf_path = strdup(path)) == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to duplicate RCS file path");
		free(rfp);
		return (NULL);
	}

d360 1
a360 5
		rdp->rd_locker = strdup(lkr->rl_name);
		if (rdp->rd_locker == NULL) {
			rcs_close(rfp);
			return (NULL);
		}
d396 2
a397 2
		free(rap->ra_name);
		free(rap);
d404 2
a405 2
		free(rsp->rs_name);
		free(rsp);
d412 2
a413 2
		free(rlp->rl_name);
		free(rlp);
d422 1
a422 1
		free(rfp->rf_path);
d424 1
a424 1
		free(rfp->rf_comment);
d426 1
a426 1
		free(rfp->rf_expand);
d428 2
a429 2
		free(rfp->rf_desc);
	free(rfp);
d605 1
a605 7
			if ((bp = malloc(MAXBSIZE)) == NULL) {
				cvs_log(LP_ERRNO, "failed to allocate memory");
				close(from_fd);
				close(to_fd);
				return (-1);
			}

d618 1
a618 1
				free(bp);
d624 1
a624 1
			free(bp);
d741 2
a742 14
	ap = (struct rcs_access *)malloc(sizeof(*ap));
	if (ap == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to allocate RCS access entry");
		return (-1);
	}

	ap->ra_name = strdup(login);
	if (ap->ra_name == NULL) {
		cvs_log(LP_ERRNO, "failed to duplicate user name");
		free(ap);
		return (-1);
	}

d772 2
a773 2
	free(ap->ra_name);
	free(ap);
d805 2
a806 13
	if ((symp = (struct rcs_sym *)malloc(sizeof(*symp))) == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to allocate RCS symbol");
		return (-1);
	}

	if ((symp->rs_name = strdup(sym)) == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to duplicate symbol");
		free(symp);
		return (-1);
	}

d808 2
a809 2
		free(symp->rs_name);
		free(symp);
d849 1
a849 1
	free(symp->rs_name);
d851 1
a851 1
	free(symp);
d976 2
a977 13
	if ((lkp = (struct rcs_lock *)malloc(sizeof(*lkp))) == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to allocate RCS lock");
		return (-1);
	}

	lkp->rl_name = strdup(user);
	if (lkp->rl_name == NULL) {
		cvs_log(LP_ERRNO, "failed to duplicate user name");
		free(lkp);
		return (-1);
	}

d979 2
a980 2
		free(lkp->rl_name);
		free(lkp);
d1019 2
a1020 2
	free(lkp->rl_name);
	free(lkp);
d1049 1
a1049 3
	if ((tmp = strdup(desc)) == NULL)
		return (-1);

d1051 1
a1051 1
		free(file->rf_desc);
d1104 1
a1104 3
	if ((tmp = strdup(comment)) == NULL)
		return (-1);

d1106 1
a1106 1
		free(file->rf_comment);
d1289 1
a1289 1
			free(bp);
d1326 1
a1326 1
		free(bp);
d1393 1
a1393 5
	if ((rdp = (struct rcs_delta *)malloc(sizeof(*rdp))) == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		rcsnum_free(old);
		return (-1);
	}
d1420 3
a1422 18
	if ((rdp->rd_author = strdup(username)) == NULL) {
		rcs_freedelta(rdp);
		rcsnum_free(old);
		return (-1);
	}

	if ((rdp->rd_state = strdup(RCS_STATE_EXP)) == NULL) {
		rcs_freedelta(rdp);
		rcsnum_free(old);
		return (-1);
	}

	if ((rdp->rd_log = strdup(msg)) == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		rcs_freedelta(rdp);
		rcsnum_free(old);
		return (-1);
	}
d1534 1
a1534 6
	if ((tmp = strdup(buf)) == NULL) {
		cvs_log(LP_ERRNO, "%s: failed to copy expansion mode",
		    file->rf_path);
		return (-1);
	}

d1640 1
a1640 5
	if ((pdp = (struct rcs_pdata *)malloc(sizeof(*pdp))) == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to allocate RCS parser data");
		return (-1);
	}
d1654 1
a1654 7
	pdp->rp_buf = (char *)malloc((size_t)RCS_BUFSIZE);
	if (pdp->rp_buf == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to allocate RCS parser buffer");
		rcs_freepdata(pdp);
		return (-1);
	}
d1695 1
a1695 7
	rfp->rf_desc = strdup(RCS_TOKSTR(rfp));
	if (rfp->rf_desc == NULL) {
		cvs_log(LP_ERRNO, "failed to duplicate rcs token");
		rcs_freepdata(pdp);
		return (-1);
	}

d1791 1
a1791 6
				rfp->rf_comment = strdup(RCS_TOKSTR(rfp));
				if (rfp->rf_comment == NULL) {
					cvs_log(LP_ERRNO,
					    "failed to duplicate rcs token");
					return (-1);
				}
d1793 1
a1793 6
				rfp->rf_expand = strdup(RCS_TOKSTR(rfp));
				if (rfp->rf_expand == NULL) {
					cvs_log(LP_ERRNO,
					    "failed to duplicate rcs token");
					return (-1);
				}
d1848 1
a1848 6
	rdp = (struct rcs_delta *)malloc(sizeof(*rdp));
	if (rdp == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		cvs_log(LP_ERRNO, "failed to allocate RCS delta structure");
		return (-1);
	}
d1934 2
a1935 9
				free(tokstr);
			tokstr = strdup(RCS_TOKSTR(rfp));
			if (tokstr == NULL) {
				cvs_log(LP_ERRNO,
				    "failed to duplicate rcs token");
				rcs_freedelta(rdp);
				return (-1);
			}

d1943 1
a1943 1
				free(tokstr);
d1950 1
a1950 1
					free(tokstr);
d1961 1
a1961 1
					free(tokstr);
d2002 1
a2002 1
		free(tokstr);
d2069 1
a2069 6
	rdp->rd_log = strdup(RCS_TOKSTR(rfp));
	if (rdp->rd_log == NULL) {
		cvs_log(LP_ERRNO, "failed to copy RCS deltatext log");
		return (-1);
	}

d2086 1
a2086 5
	rdp->rd_text = (u_char *)malloc(RCS_TOKLEN(rfp) + 1);
	if (rdp->rd_text == NULL) {
		cvs_log(LP_ERRNO, "failed to copy RCS delta text");
		return (-1);
	}
d2143 2
a2144 13
		symp = (struct rcs_sym *)malloc(sizeof(*symp));
		if (symp == NULL) {
			rcs_errno = RCS_ERR_ERRNO;
			cvs_log(LP_ERRNO, "failed to allocate RCS symbol");
			return (-1);
		}
		symp->rs_name = strdup(RCS_TOKSTR(rfp));
		if (symp->rs_name == NULL) {
			cvs_log(LP_ERRNO, "failed to duplicate rcs token");
			free(symp);
			return (-1);
		}

d2148 2
a2149 2
			free(symp->rs_name);
			free(symp);
d2159 2
a2160 2
			free(symp->rs_name);
			free(symp);
d2170 2
a2171 2
			free(symp->rs_name);
			free(symp);
d2179 2
a2180 2
			free(symp->rs_name);
			free(symp);
d2214 2
a2215 12
		lkp = (struct rcs_lock *)malloc(sizeof(*lkp));
		if (lkp == NULL) {
			cvs_log(LP_ERRNO, "failed to allocate RCS lock");
			return (-1);
		}

		if ((lkp->rl_name = strdup(RCS_TOKSTR(rfp))) == NULL) {
			cvs_log(LP_ERR, "failed to save locking user");
			free(lkp);
			return (-1);
		}

d2218 2
a2219 2
			free(lkp->rl_name);
			free(lkp);
d2229 2
a2230 2
			free(lkp->rl_name);
			free(lkp);
d2240 2
a2241 2
			free(lkp->rl_name);
			free(lkp);
d2249 2
a2250 2
			free(lkp->rl_name);
			free(lkp);
d2301 1
a2301 6
		brp = (struct rcs_branch *)malloc(sizeof(*brp));
		if (brp == NULL) {
			rcs_errno = RCS_ERR_ERRNO;
			cvs_log(LP_ERRNO, "failed to allocate RCS branch");
			return (-1);
		}
d2304 1
a2304 1
			free(brp);
d2331 1
a2331 1
		free(rdp->rd_author);
d2333 1
a2333 1
		free(rdp->rd_locker);
d2335 1
a2335 1
		free(rdp->rd_state);
d2337 1
a2337 1
		free(rdp->rd_log);
d2339 1
a2339 1
		free(rdp->rd_text);
d2344 1
a2344 1
		free(rb);
d2352 1
a2352 1
	free(rdp);
d2366 2
a2367 2
		free(pd->rp_buf);
	free(pd);
d2749 1
a2749 1
		free(rdp->rd_text);
d2753 1
a2753 3
		if ((rdp->rd_text = (u_char *)malloc(len)) == NULL)
			return (-1);

d2781 1
a2781 4
		free(rdp->rd_log);

	if ((rdp->rd_log = strdup(logtext)) == NULL)
		return (-1);
d2783 1
d2821 1
a2821 1
		free(rdp->rd_state);
d2823 1
a2823 2
	if ((rdp->rd_state = strdup(state)) == NULL)
		return (-1);
d3096 1
a3096 1
		free(content);
@


1.108
log
@todd@@ reminds me:

If you 'vi file.c' and change stuff, then 'make depend && make' you'll
have a file.o file most definately more recent than the latest committed
version of file.c.

Then, if you rm file.c, and cvs update file.c, if 'file.c' is set to the
timestamp of the last committed version, a subsequent 'make' will not
rebuild the .o file.

to fix this we simply use the current timestamp when updating files.
thanks todd@@!
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.107 2005/12/03 15:07:21 joris Exp $	*/
d311 2
d363 14
d1012 2
a1013 1
		if (strcmp(lkp->rl_name, user) == 0) {
d1056 1
a1056 1
rcs_lock_remove(RCSFILE *file, const RCSNUM *rev)
d1060 3
a1062 2
	TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list)
		if (rcsnum_cmp(lkp->rl_num, rev, 0) == 0)
d1064 1
d2487 2
@


1.107
log
@fix date handling in opencvs, this was broken since the very start.
now, when you checkout a tree with gnu cvs, opencvs no longer sees all
the files as modified, and visa versa.

this actually makes gnu cvs and opencvs dance together in working copies.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.106 2005/12/03 02:10:58 joris Exp $	*/
d3067 2
a3068 1
	else if (type == CHECKOUT_REV_MERGED)
d3070 3
d3074 2
a3075 1
	if (type == CHECKOUT_REV_CREATED) {
d3142 1
@


1.106
log
@usr.bin/rcs stuff doesn't care about cvs_checkout_rev();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.105 2005/12/03 01:02:09 joris Exp $	*/
d3144 6
d3168 3
@


1.105
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.104 2005/12/02 21:21:47 joris Exp $	*/
d3004 2
d3224 2
@


1.104
log
@remove debug message;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.103 2005/12/02 20:08:41 joris Exp $	*/
d321 2
a322 1
			rcs_errno = RCS_ERR_ERRNO;
d324 1
d3003 219
@


1.103
log
@fix commiting/importing of 0 sized files.
found and tested by pedro@@ and niallo@@

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.102 2005/12/01 18:22:09 xsa Exp $	*/
a2909 1
	printf("setting log for %s to '%s'\n", buf, logtext);
@


1.102
log
@rcs_findrev() is not static anymore; align protos while here;
OK joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.101 2005/11/22 11:49:02 niallo Exp $	*/
d564 5
a568 2
			if (rdp->rd_text[rdp->rd_tlen-1] != '\n')
				fputc('\n', fp);
d2884 3
a2886 2
	if ((rdp->rd_text = (u_char *)malloc(len)) == NULL)
		return (-1);
d2888 6
a2893 2
	rdp->rd_tlen = len - 1;
	strlcpy(rdp->rd_text, dtext, len);
@


1.101
log
@- ci(1) can intialise RCS files now!
- support for -j added
- support for -i added

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.100 2005/11/16 08:15:21 xsa Exp $	*/
a289 1
static struct rcs_delta	*rcs_findrev(RCSFILE *, const RCSNUM *);
d1529 1
a1529 1
static struct rcs_delta*
@


1.100
log
@fix writing of RCS files; it has been bugging us for a while now...
now, former RCS suite can make a use of our newly written RCS files;
ok joris niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.99 2005/11/12 21:34:48 niallo Exp $	*/
d1393 12
a1404 2
		rcsnum_cpy(rf->rf_head, old, 0);
		rev = rcsnum_inc(rf->rf_head);
d1451 3
a1453 1
	rcsnum_cpy(old, rdp->rd_next, 0);
@


1.99
log
@- remove strtab stuff. serves no useful purpose.

diff is from joris@@, committing on his behalf because his net connection
is very dodgy right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.98 2005/11/09 15:42:58 xsa Exp $	*/
d448 1
d543 7
a549 4
	if (rfp->rf_desc != NULL)
		rcs_strprint((const u_char *)rfp->rf_desc,
		    strlen(rfp->rf_desc), fp);
	fputs("@@\n\n", fp);
d553 1
a553 1
		fprintf(fp, "\n%s\n", rcsnum_tostr(rdp->rd_num, numbuf,
d556 6
a561 2
		rcs_strprint((const u_char *)rdp->rd_log,
		    strlen(rdp->rd_log), fp);
d563 6
a568 2
		rcs_strprint(rdp->rd_text, rdp->rd_tlen, fp);
		fputs("\n@@\n\n", fp);
@


1.98
log
@add missing '\n' when writing deltatexts in an RCS file;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.97 2005/11/02 20:32:44 niallo Exp $	*/
a44 1
#include "strtab.h"
d393 1
a393 1
		cvs_strfree(rap->ra_name);
d401 1
a401 1
		cvs_strfree(rsp->rs_name);
d409 1
a409 1
		cvs_strfree(rlp->rl_name);
d421 1
a421 1
		cvs_strfree(rfp->rf_comment);
d423 1
a423 1
		cvs_strfree(rfp->rf_expand);
d425 1
a425 1
		cvs_strfree(rfp->rf_desc);
d736 1
a736 1
	ap->ra_name = cvs_strdup(login);
d772 1
a772 1
	cvs_strfree(ap->ra_name);
d811 1
a811 1
	if ((symp->rs_name = cvs_strdup(sym)) == NULL) {
d819 1
a819 1
		cvs_strfree(symp->rs_name);
d860 1
a860 1
	cvs_strfree(symp->rs_name);
d992 1
a992 1
	lkp->rl_name = cvs_strdup(user);
d1000 1
a1000 1
		cvs_strfree(lkp->rl_name);
d1038 1
a1038 1
	cvs_strfree(lkp->rl_name);
d1068 1
a1068 1
	if ((tmp = cvs_strdup(desc)) == NULL)
d1072 1
a1072 1
		cvs_strfree(file->rf_desc);
d1125 1
a1125 1
	if ((tmp = cvs_strdup(comment)) == NULL)
d1129 1
a1129 1
		cvs_strfree(file->rf_comment);
d1435 1
a1435 1
	if ((rdp->rd_author = cvs_strdup(username)) == NULL) {
d1441 1
a1441 1
	if ((rdp->rd_state = cvs_strdup(RCS_STATE_EXP)) == NULL) {
d1447 1
a1447 1
	if ((rdp->rd_log = cvs_strdup(msg)) == NULL) {
d1564 1
a1564 1
	if ((tmp = cvs_strdup(buf)) == NULL) {
d1571 1
a1571 1
		cvs_strfree(file->rf_expand);
d1740 1
a1740 1
	rfp->rf_desc = cvs_strdup(RCS_TOKSTR(rfp));
d1842 1
a1842 1
				rfp->rf_comment = cvs_strdup(RCS_TOKSTR(rfp));
d1849 1
a1849 1
				rfp->rf_expand = cvs_strdup(RCS_TOKSTR(rfp));
d2000 2
a2001 2
				cvs_strfree(tokstr);
			tokstr = cvs_strdup(RCS_TOKSTR(rfp));
d2016 1
a2016 1
				cvs_strfree(tokstr);
d2023 1
a2023 1
					cvs_strfree(tokstr);
d2034 1
a2034 1
					cvs_strfree(tokstr);
d2075 1
a2075 1
		cvs_strfree(tokstr);
d2142 1
a2142 1
	rdp->rd_log = cvs_strdup(RCS_TOKSTR(rfp));
d2231 1
a2231 1
		symp->rs_name = cvs_strdup(RCS_TOKSTR(rfp));
d2241 1
a2241 1
			cvs_strfree(symp->rs_name);
d2252 1
a2252 1
			cvs_strfree(symp->rs_name);
d2263 1
a2263 1
			cvs_strfree(symp->rs_name);
d2272 1
a2272 1
			cvs_strfree(symp->rs_name);
d2313 1
a2313 1
		if ((lkp->rl_name = cvs_strdup(RCS_TOKSTR(rfp))) == NULL) {
d2321 1
a2321 1
			cvs_strfree(lkp->rl_name);
d2332 1
a2332 1
			cvs_strfree(lkp->rl_name);
d2343 1
a2343 1
			cvs_strfree(lkp->rl_name);
d2352 1
a2352 1
			cvs_strfree(lkp->rl_name);
d2439 1
a2439 1
		cvs_strfree(rdp->rd_author);
d2441 1
a2441 1
		cvs_strfree(rdp->rd_state);
d2443 1
a2443 1
		cvs_strfree(rdp->rd_log);
d2885 1
a2885 1
		cvs_strfree(rdp->rd_log);
d2887 1
a2887 1
	if ((rdp->rd_log = cvs_strdup(logtext)) == NULL)
d2927 1
a2927 1
		cvs_strfree(rdp->rd_state);
d2929 1
a2929 1
	if ((rdp->rd_state = cvs_strdup(state)) == NULL)
@


1.97
log
@changes from Venice:

- instead of using lots of individual flag variables, use a single int and
  bitwise operations on it. while this saves memory, really it saves code
  space and reduces complexity. checkout_rev() and checkout_state() in
  particular benefit from these changes since their parameters where growing
  really long.

- implement `-s' option in co

- implement `-M' option in ci

"I like this, go for it" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.96 2005/10/30 11:10:12 xsa Exp $	*/
d557 1
a557 1
		fputs("@@\n\n", fp);
@


1.96
log
@nuke trailing whitespaces;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.95 2005/10/29 19:05:50 niallo Exp $	*/
d2894 16
d2953 19
@


1.95
log
@- add two new functions to RCS api: rcs_state_set() and rcs_state_check()
- use these two new functions to implement -s<state> option in ci

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.94 2005/10/22 17:32:57 joris Exp $	*/
d1365 1
a1365 1
 * If <username> is NULL, set the author for this revision to the current user. 
d2844 1
a2844 1
 * Returns -1 on error, 0 on success. 
d2927 1
a2927 1
 * Returns 0 if the string is valid, -1 otherwise. 
@


1.94
log
@diff3 support, needed for merging files together;

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.93 2005/10/22 17:23:21 joris Exp $	*/
d2892 43
@


1.93
log
@- don't check for admin files when running init;
- don't pass the Entry for newly added files to cvs_date_parse()
- in rcs_rev_add don't bother looking for the previous rev if we
  are creating the RCS file.

from PR 4575
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.92 2005/10/18 01:08:13 joris Exp $	*/
d41 1
a101 13
struct rcs_line {
	char			*rl_line;
	int			 rl_lineno;
	TAILQ_ENTRY(rcs_line)	 rl_list;
};
TAILQ_HEAD(rcs_tqh, rcs_line);

struct rcs_foo {
	int		 rl_nblines;
	char		*rl_data;
	struct rcs_tqh	 rl_lines;
};

a105 1

a286 1
static int	rcs_patch_lines(struct rcs_foo *, struct rcs_foo *);
a291 2
static struct rcs_foo	*rcs_splitlines(const char *);
static void		 rcs_freefoo(struct rcs_foo *);
d1155 2
a1156 56

/*
 * rcs_patch()
 *
 * Apply an RCS-format patch pointed to by <patch> to the file contents
 * found in <data>.
 * Returns 0 on success, or -1 on failure.
 */
BUF*
rcs_patch(const char *data, const char *patch)
{
	struct rcs_foo *dlines, *plines;
	struct rcs_line *lp;
	size_t len;
	int lineno;
	BUF *res;

	len = strlen(data);
	res = cvs_buf_alloc(len, BUF_AUTOEXT);
	if (res == NULL)
		return (NULL);

	dlines = rcs_splitlines(data);
	if (dlines == NULL) {
		cvs_buf_free(res);
		return (NULL);
	}

	plines = rcs_splitlines(patch);
	if (plines == NULL) {
		cvs_buf_free(res);
		rcs_freefoo(dlines);
		return (NULL);
	}

	if (rcs_patch_lines(dlines, plines) < 0) {
		cvs_buf_free(res);
		rcs_freefoo(plines);
		rcs_freefoo(dlines);
		return (NULL);
	}

	lineno = 0;
	TAILQ_FOREACH(lp, &dlines->rl_lines, rl_list) {
		if (lineno != 0)
			cvs_buf_fappend(res, "%s\n", lp->rl_line);
		lineno++;
	}

	rcs_freefoo(dlines);
	rcs_freefoo(plines);
	return (res);
}

static int
rcs_patch_lines(struct rcs_foo *dlines, struct rcs_foo *plines)
d1159 1
a1159 1
	struct rcs_line *lp, *dlp, *ndlp;
d1162 2
a1163 2
	dlp = TAILQ_FIRST(&(dlines->rl_lines));
	lp = TAILQ_FIRST(&(plines->rl_lines));
d1166 5
a1170 5
	for (lp = TAILQ_NEXT(lp, rl_list); lp != NULL;
	    lp = TAILQ_NEXT(lp, rl_list)) {
		op = *(lp->rl_line);
		lineno = (int)strtol((lp->rl_line + 1), &ep, 10);
		if ((lineno > dlines->rl_nblines) || (lineno < 0) ||
d1188 1
a1188 1
			if (dlp->rl_lineno == lineno)
d1190 5
a1194 5
			if (dlp->rl_lineno > lineno) {
				dlp = TAILQ_PREV(dlp, rcs_tqh, rl_list);
			} else if (dlp->rl_lineno < lineno) {
				ndlp = TAILQ_NEXT(dlp, rl_list);
				if (ndlp->rl_lineno > lineno)
d1207 2
a1208 2
				ndlp = TAILQ_NEXT(dlp, rl_list);
				TAILQ_REMOVE(&(dlines->rl_lines), dlp, rl_list);
d1214 1
a1214 1
				lp = TAILQ_NEXT(lp, rl_list);
d1219 3
a1221 3
				TAILQ_REMOVE(&(plines->rl_lines), lp, rl_list);
				TAILQ_INSERT_AFTER(&(dlines->rl_lines), dlp,
				    lp, rl_list);
d1225 1
a1225 1
				lp->rl_lineno = lineno;
d1235 1
a1235 1
		if (lp->rl_lineno == plines->rl_nblines)
d1241 3
a1243 3
	TAILQ_FOREACH(lp, &(dlines->rl_lines), rl_list)
		lp->rl_lineno = lineno++;
	dlines->rl_nblines = lineno - 1;
d1264 2
a1265 2
	struct rcs_foo *lines;
	struct rcs_line *lp;
d1311 2
a1312 1
			rbuf = rcs_patch((char *)bp, (char *)rdp->rd_text);
d1339 1
a1339 1
		if ((lines = rcs_splitlines((char *)bp)) != NULL) {
d1341 1
a1341 1
			TAILQ_FOREACH(lp, &lines->rl_lines, rl_list) {
d1345 1
a1345 1
				    lp->rl_line, out, sizeof(out), expmode);
d1348 1
a1348 1
			rcs_freefoo(lines);
a2620 77

/*
 * rcs_splitlines()
 *
 * Split the contents of a file into a list of lines.
 */
static struct rcs_foo*
rcs_splitlines(const char *fcont)
{
	char *dcp;
	struct rcs_foo *foo;
	struct rcs_line *lp;

	foo = (struct rcs_foo *)malloc(sizeof(*foo));
	if (foo == NULL) {
		cvs_log(LP_ERR, "failed to allocate line structure");
		return (NULL);
	}
	TAILQ_INIT(&(foo->rl_lines));
	foo->rl_nblines = 0;
	foo->rl_data = strdup(fcont);
	if (foo->rl_data == NULL) {
		cvs_log(LP_ERRNO, "failed to copy file contents");
		free(foo);
		return (NULL);
	}

	/*
	 * Add a first bogus line with line number 0.  This is used so we
	 * can position the line pointer before 1 when changing the first line
	 * in rcs_patch().
	 */
	lp = (struct rcs_line *)malloc(sizeof(*lp));
	if (lp == NULL) {
		rcs_freefoo(foo);
		return (NULL);
	}

	lp->rl_line = NULL;
	lp->rl_lineno = 0;
	TAILQ_INSERT_TAIL(&(foo->rl_lines), lp, rl_list);


	for (dcp = foo->rl_data; *dcp != '\0';) {
		lp = (struct rcs_line *)malloc(sizeof(*lp));
		if (lp == NULL) {
			rcs_freefoo(foo);
			cvs_log(LP_ERR, "failed to allocate line entry");
			return (NULL);
		}

		lp->rl_line = dcp;
		lp->rl_lineno = ++(foo->rl_nblines);
		TAILQ_INSERT_TAIL(&(foo->rl_lines), lp, rl_list);

		dcp = strchr(dcp, '\n');
		if (dcp == NULL) {
			break;
		}
		*(dcp++) = '\0';
	}

	return (foo);
}

static void
rcs_freefoo(struct rcs_foo *fp)
{
	struct rcs_line *lp;

	while ((lp = TAILQ_FIRST(&fp->rl_lines)) != NULL) {
		TAILQ_REMOVE(&fp->rl_lines, lp, rl_list);
		free(lp);
	}
	free(fp->rl_data);
	free(fp);
}
@


1.92
log
@plug memleaks in rcs_rev_add() when an error occurs;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.91 2005/10/16 17:44:15 joris Exp $	*/
d1460 7
a1466 5
		ordp = NULL;
		rcsnum_cpy(rev, old, 0);
		while (ordp == NULL) {
			old = rcsnum_dec(old);
			ordp = rcs_findrev(rf, old);
@


1.91
log
@fix the locks section in RCS files;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.90 2005/10/15 22:56:03 niallo Exp $	*/
d1456 1
d1470 1
d1476 1
d1486 1
d1493 1
d1496 1
d1505 1
d1511 1
d1518 1
@


1.90
log
@- add username parameter to rcs_rev_add(), needed to implement at least
  `ci -wusername'.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.89 2005/10/11 00:10:16 joris Exp $	*/
a514 2
		if (lkp != TAILQ_LAST(&(rfp->rf_locks), rcs_llist))
			fprintf(fp, ";");
@


1.89
log
@more debug stuff i forgot to take out, i blame the dominican sun!
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.88 2005/10/11 00:08:34 joris Exp $	*/
d1436 2
d1441 2
a1442 1
rcs_rev_add(RCSFILE *rf, RCSNUM *rev, const char *msg, time_t date)
d1496 4
a1499 1
	if ((rdp->rd_author = cvs_strdup(pw->pw_name)) == NULL) {
@


1.88
log
@remove debug cruft;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.87 2005/10/11 00:07:29 joris Exp $	*/
a1371 1
			printf("loop\n");
@


1.87
log
@fix patching in rcs_getrev();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.86 2005/10/10 23:37:15 joris Exp $	*/
a1568 4
	char buf[16];

	rcsnum_tostr(rev, buf, sizeof(buf));
	printf("rcs_findrev(%s)\n", buf);
@


1.86
log
@add rcs_rev_setlog() in the RCS api; used for setting log messages
of a revision to a specific value;

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.85 2005/10/10 14:42:54 joris Exp $	*/
a1369 1
		crev = rdp->rd_next;
d1371 2
a1387 1
			crev = rdp->rd_next;
d1569 4
@


1.85
log
@better symbol listing in RCS files;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.84 2005/10/10 14:16:03 joris Exp $	*/
d2997 27
@


1.84
log
@use rd_next in rcs_getrev() when patching to get to a revision
instead of just decrementing the revision number, as the previous revision
doesn't always follow the current revision - 1 rule.

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.83 2005/10/10 13:41:25 joris Exp $	*/
d503 1
a503 1
	fprintf(fp, "symbols\n");
d507 1
a507 3
		fprintf(fp, "\t%s", buf);
		if (symp != TAILQ_LAST(&(rfp->rf_symbols), rcs_slist))
			fputc('\n', fp);
@


1.83
log
@correctly fill in the rd_next field in rcs_rev_add();
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.82 2005/10/09 16:14:23 joris Exp $	*/
d1372 1
a1372 5
		if ((crev = rcsnum_alloc()) == NULL) {
			cvs_buf_free(rbuf);
			return (NULL);
		}
		rcsnum_cpy(rfp->rf_head, crev, 0);
a1373 1
			crev->rn_id[crev->rn_len - 1]--;
a1375 1
				rcsnum_free(crev);
a1380 1
				rcsnum_free(crev);
d1389 1
a1390 2

		rcsnum_free(crev);
@


1.82
log
@fix 2 off-by-one's which was causing us a whole load of crap;
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.81 2005/10/07 23:59:56 niallo Exp $	*/
d1454 5
a1458 1
	struct rcs_delta *rdp;
d1461 1
d1463 12
a1474 3
	} else if ((rdp = rcs_findrev(rf, rev)) != NULL) {
		rcs_errno = RCS_ERR_DUPENT;
		return (-1);
d1496 7
@


1.81
log
@basic `ci' support is here! more coming soon.

combined effort with joris.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.80 2005/10/07 21:47:32 reyk Exp $	*/
d1244 1
a1244 1
		if ((lineno > dlines->rl_nblines) || (lineno <= 0) ||
d1252 1
a1252 1
		if ((nbln <= 0) || (*ep != '\0')) {
@


1.80
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.79 2005/10/05 23:11:07 niallo Exp $	*/
a40 1
#include "diff.h"
d43 1
a1454 1
	RCSNUM *tmprev = NULL;
d1457 1
a1457 14
		const RCSNUM *head_rev;
		char version_str[10];

		head_rev = rcs_head_get(rf);
		if ((tmprev = rcsnum_alloc()) == NULL) {
			cvs_log(LP_ERR, "could not allocate rcsnum");
			return (-1);
		}
		if (rcsnum_cpy(head_rev, tmprev, sizeof(version_str)) != 0) {
			cvs_log(LP_ERR, "could not perform rcsnum_cpy");
			rcsnum_free(tmprev);
			return (-1);
		}
		rev = rcsnum_inc(tmprev);
a1481 2
	if (tmprev != NULL)
		rcsnum_free(tmprev);
d1507 1
d2957 28
@


1.79
log
@- add a diff.h header file, corresponding to public functions in diff.c
  and some #defines
- include this header in rcs.c
- link rcs against diff.c

this allows us to use the existing diff work from opencvs within functions
in the rcs.c API and thus in rcs programs. paves the way for diff support
in usr.bin/rcs programs.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.78 2005/10/05 17:34:59 joris Exp $	*/
d601 2
a602 2
			if ((to_fd = open(rfp->rf_path, O_WRONLY|O_TRUNC|O_CREAT))
			    == -1) {
d2908 2
a2909 1
			 * order matters because of RCS_KW_ID and RCS_KW_HEADER here
d2914 2
a2915 1
						strlcat(expbuf, basename(rcsfile),
d2924 2
a2925 1
					rcsnum_tostr(rdp->rd_num, buf, sizeof(buf));
d2932 2
a2933 1
					    "%Y/%m/%d %H:%M:%S ", &rdp->rd_date);
d2954 2
a2955 1
					strlcat(expbuf, rcsfile, sizeof(expbuf));
@


1.78
log
@open the RCS file with O_TRUNC as well when
writing new contents to it;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.77 2005/10/05 11:38:02 joris Exp $	*/
d41 1
@


1.77
log
@free rl_name as well when freeing the lock list;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.76 2005/10/04 23:02:56 joris Exp $	*/
d600 1
a600 1
			if ((to_fd = open(rfp->rf_path, O_WRONLY|O_CREAT))
@


1.76
log
@correctly parse the lock section in an RCS file;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.75 2005/10/04 14:55:36 joris Exp $	*/
d425 1
@


1.75
log
@write locks to the RCS file;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.74 2005/10/02 21:44:18 joris Exp $	*/
d2370 7
d2379 1
d2390 1
d2401 1
d2410 1
@


1.74
log
@correctly copy and NUL-terminate deltatext strings so we don't end up
using garbage in rcs_patch_lines().
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.73 2005/09/30 15:06:46 joris Exp $	*/
d461 1
d464 1
d511 9
a519 1
	fprintf(fp, "locks;");
@


1.73
log
@spacing & KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.72 2005/09/30 14:50:32 niallo Exp $	*/
d2212 1
a2212 1
	rdp->rd_text = (u_char *)malloc(RCS_TOKLEN(rfp));
d2217 1
a2217 1
	memcpy(rdp->rd_text, RCS_TOKSTR(rfp), RCS_TOKLEN(rfp));
@


1.72
log
@rework the rcs_write() function.

now it writes to a temporary file, then rename()s this into place or copies it
if rename() is not possible.

allows us to work with read-only ,v files.

"put your diff in" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.71 2005/09/29 20:54:29 moritz Exp $	*/
d568 1
d582 1
d588 1
d591 1
a591 2
				cvs_log(LP_ERRNO, "failed to open `%s'",
				    fn);
d595 1
d597 1
a597 2
				cvs_log(LP_ERRNO,
				    "failed to allocate memory");
d602 1
d607 1
d618 1
d622 1
d625 1
a625 2
				    "failed to unlink `%s'",
				    fn);
d634 1
d640 1
@


1.71
log
@free the access list when rcs file is closed. ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.70 2005/09/29 20:51:35 moritz Exp $	*/
d32 1
d455 2
a456 1
	char buf[1024], numbuf[64];
d461 3
d468 7
a474 1
	if ((fp = fopen(rfp->rf_path, "w")) == NULL) {
d476 2
a477 2
		cvs_log(LP_ERRNO, "failed to open RCS output file `%s'",
		    rfp->rf_path);
d568 66
a633 1

@


1.70
log
@set RCS_SYNCED to off in some more functions which
change rcs file content. ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.69 2005/09/29 20:47:34 moritz Exp $	*/
d387 1
d403 7
@


1.69
log
@return -1 instead of NULL in rcs_sym_{add,remove}. ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.68 2005/09/29 20:44:58 moritz Exp $	*/
d587 1
d624 1
d881 1
@


1.68
log
@don't forget to put the revision into the rcs_lock
struct in rcs_lock_add(). ok niallo@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.67 2005/09/29 15:39:41 niallo Exp $	*/
d710 1
a710 1
		return (NULL);
d763 1
a763 1
		return (NULL);
@


1.67
log
@implement RCS_HEAD_REV in rcs_rev_add()

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.66 2005/09/29 15:29:20 joris Exp $	*/
d913 7
@


1.66
log
@allow RCS_HEAD_REV to be passed to rcs_getrev() to obtain the head revision;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.65 2005/09/19 15:47:14 niallo Exp $	*/
d1342 1
d1345 14
d1383 2
@


1.65
log
@Zap some compiler warnings about uninitialized variables.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.64 2005/09/18 15:27:38 niallo Exp $	*/
d1217 1
a1217 1
rcs_getrev(RCSFILE *rfp, RCSNUM *rev)
d1222 1
a1222 1
	RCSNUM *crev;
d1231 5
@


1.64
log
@- ensure rcs_rev_add() and rcs_kwexp_set() set the RCS_SYNCED flag to off
  properly.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.63 2005/09/18 06:19:10 joris Exp $	*/
d1223 1
a1223 1
	BUF *rbuf, *dbuf;
d2686 2
@


1.63
log
@RCS keyword expansion support, only $Log$ is not supported right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.62 2005/09/18 00:33:40 joris Exp $	*/
d1388 2
d1498 2
@


1.62
log
@fix memleak
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.61 2005/09/17 23:47:17 joris Exp $	*/
d32 1
a230 1
#ifdef notyet
d234 16
d252 1
d254 10
a263 10
	{ "Author"    },
	{ "Date"      },
	{ "Header"    },
	{ "Id"        },
	{ "Log"       },
	{ "Name"      },
	{ "RCSfile"   },
	{ "Revision"  },
	{ "Source"    },
	{ "State"     }
d265 2
a266 1
#endif
d301 2
a306 1

d1219 1
a1219 1
	int res;
d1223 1
a1223 1
	BUF *rbuf;
d1225 3
d1283 35
a1317 1
	return (rbuf);
d2663 151
@


1.61
log
@fix stupidity in rcs_patch_lines() and return -1 on error so we actually
catch the error instead of completely crashing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.60 2005/09/05 19:25:00 xsa Exp $	*/
d1253 1
@


1.60
log
@style;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.59 2005/08/14 19:49:18 xsa Exp $	*/
d1116 1
a1116 1
			return (NULL);
d1123 1
a1123 1
			return (NULL);
d1144 1
a1144 1
			return (NULL);
@


1.59
log
@missing casts; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.58 2005/08/11 14:10:20 xsa Exp $	*/
d300 1
a300 1
RCSFILE*
d541 1
a541 1
const RCSNUM*
d579 1
a579 1
const RCSNUM*
d774 1
a774 1
RCSNUM*
d1031 1
a1031 1
RCSNUM*
@


1.58
log
@a few casts; ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.57 2005/07/25 12:05:43 xsa Exp $	*/
d1557 1
a1557 1
	pdp->rp_buf = (char *)malloc(RCS_BUFSIZE);
@


1.57
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.56 2005/07/07 14:27:57 joris Exp $	*/
d479 2
a480 1
		rcs_strprint(rfp->rf_comment, strlen(rfp->rf_comment), fp);
d486 2
a487 1
		rcs_strprint(rfp->rf_expand, strlen(rfp->rf_expand), fp);
d514 2
a515 1
		rcs_strprint(rfp->rf_desc, strlen(rfp->rf_desc), fp);
d523 2
a524 1
		rcs_strprint(rdp->rd_log, strlen(rdp->rd_log), fp);
@


1.56
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.55 2005/05/31 08:58:48 xsa Exp $	*/
d43 2
a44 2
#define RCS_BUFSIZE     16384
#define RCS_BUFEXTSIZE   8192
d48 25
a72 25
#define RCS_TOK_ERR     -1
#define RCS_TOK_EOF      0
#define RCS_TOK_NUM      1
#define RCS_TOK_ID       2
#define RCS_TOK_STRING   3
#define RCS_TOK_SCOLON   4
#define RCS_TOK_COLON    5


#define RCS_TOK_HEAD     8
#define RCS_TOK_BRANCH   9
#define RCS_TOK_ACCESS   10
#define RCS_TOK_SYMBOLS  11
#define RCS_TOK_LOCKS    12
#define RCS_TOK_COMMENT  13
#define RCS_TOK_EXPAND   14
#define RCS_TOK_DATE     15
#define RCS_TOK_AUTHOR   16
#define RCS_TOK_STATE    17
#define RCS_TOK_NEXT     18
#define RCS_TOK_BRANCHES 19
#define RCS_TOK_DESC     20
#define RCS_TOK_LOG      21
#define RCS_TOK_TEXT     22
#define RCS_TOK_STRICT   23
d74 1
a74 1
#define RCS_ISKEY(t)    (((t) >= RCS_TOK_HEAD) && ((t) <= RCS_TOK_BRANCHES))
d77 2
a78 2
#define RCS_NOSCOL   0x01   /* no terminating semi-colon */
#define RCS_VOPT     0x02   /* value is optional */
d83 1
a83 1
	u_int  rp_lines;
d85 4
a88 4
	char  *rp_buf;
	size_t rp_blen;
	char  *rp_bufend;
	size_t rp_tlen;
d91 2
a92 2
	char   rp_ptok[128];
	int    rp_pttype;       /* token type, RCS_TOK_ERR if no token */
d94 1
a94 1
	FILE  *rp_file;
d99 3
a101 3
	char *rl_line;
	int   rl_lineno;
	TAILQ_ENTRY(rcs_line) rl_list;
d106 3
a108 3
	int       rl_nblines;
	char     *rl_data;
	struct rcs_tqh rl_lines;
d111 2
a112 2
#define RCS_TOKSTR(rfp)   ((struct rcs_pdata *)rfp->rf_pdata)->rp_buf
#define RCS_TOKLEN(rfp)   ((struct rcs_pdata *)rfp->rf_pdata)->rp_tlen
d122 2
a123 2
	const char  *rc_suffix;
	const char  *rc_cstr;
d189 1
a189 1
#define NB_COMTYPES  (sizeof(rcs_comments)/sizeof(rcs_comments[0]))
d193 2
a194 2
	char  rk_char;
	int   rk_val;
d205 4
a208 4
	char  rk_str[16];
	int   rk_id;
	int   rk_val;
	int   rk_flags;
d228 1
a228 1
#define RCS_NKEYS   (sizeof(rcs_keys)/sizeof(rcs_keys[0]))
d235 1
a235 1
	char  kw_str[16];
d265 21
a285 21
static int   rcs_write           (RCSFILE *);
static int   rcs_parse           (RCSFILE *);
static int   rcs_parse_admin     (RCSFILE *);
static int   rcs_parse_delta     (RCSFILE *);
static int   rcs_parse_deltatext (RCSFILE *);

static int   rcs_parse_access    (RCSFILE *);
static int   rcs_parse_symbols   (RCSFILE *);
static int   rcs_parse_locks     (RCSFILE *);
static int   rcs_parse_branches  (RCSFILE *, struct rcs_delta *);
static void  rcs_freedelta       (struct rcs_delta *);
static void  rcs_freepdata       (struct rcs_pdata *);
static int   rcs_gettok          (RCSFILE *);
static int   rcs_pushtok         (RCSFILE *, const char *, int);
static int   rcs_growbuf         (RCSFILE *);
static int   rcs_patch_lines     (struct rcs_foo *, struct rcs_foo *);
static int   rcs_strprint        (const u_char *, size_t, FILE *);

static struct rcs_delta*  rcs_findrev    (RCSFILE *, const RCSNUM *);
static struct rcs_foo*    rcs_splitlines (const char *);
static void               rcs_freefoo    (struct rcs_foo *);
d936 1
a936 1
const char*
d970 1
a970 1
const char*
d993 1
a993 1
const char*
d1493 1
a1493 1
const char*
@


1.55
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.54 2005/05/25 21:59:16 jfb Exp $	*/
d908 1
a908 1
rcs_lock_remove(RCSFILE *file, const RCSNUM *rev) 
@


1.54
log
@unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.53 2005/05/25 21:32:31 jfb Exp $	*/
a27 1
#include <sys/queue.h>
d30 2
d33 1
a33 1
#include <errno.h>
a34 2
#include <ctype.h>
#include <unistd.h>
a35 1
#include <stdarg.h>
d37 1
d39 1
a40 1
#include "log.h"
@


1.53
log
@modify rcs_rev_add() to accept a time_t argument to explicitly set
the revision's timestamp (-1 is equivalent to using the current time)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.52 2005/05/25 08:00:03 jfb Exp $	*/
a1257 22
}

/*
 * rcs_gethead()
 *
 * Get the head revision for the RCS file <rf>.
 */
BUF*
rcs_gethead(RCSFILE *rf)
{
	return rcs_getrev(rf, rf->rf_head);
}

/*
 * rcs_getrevbydate()
 *
 * Get an RCS revision by a specific date.
 */
RCSNUM*
rcs_getrevbydate(RCSFILE *rfp, struct tm *date)
{
	return (NULL);
@


1.52
log
@- basic code for rcs_rev_add() and rcs_rev_remove(), does not
  handle deltatexts yet
- fix rcs_head_set() by allocating the head pointer if there was no
  previous head revision
- initialize subnodes list correctly for RCS deltas
- fix a crash in rcs_strprint() on NULL strings
-
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.49 2005/04/20 23:11:30 jfb Exp $	*/
d1285 6
a1290 1
 * Add a revision to the RCS file <rf>.
d1294 1
a1294 1
rcs_rev_add(RCSFILE *rf, RCSNUM *rev, const char *msg)
d1342 4
a1345 1
	time(&now);
@


1.51
log
@add cvs_comment_lookup() and a suffix -> comment leader lookup table
to determine the appropriate comment leader for a file
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.50 2005/05/25 06:42:41 jfb Exp $	*/
d31 1
d35 1
d173 2
a174 2
	{ "pl",   "# "     },	/* perl	(conflict with Prolog) */
	{ "pm",   "# "     },	/* perl	module */
d558 4
d1283 94
a1631 3
	cvs_log(LP_DEBUG, "RCS file `%s' parsed OK (%u lines)", rfp->rf_path,
	    pdp->rp_lines);

d1804 1
d1808 1
d2602 3
@


1.50
log
@add the RCS_ERR_ERRNO code to indicate that the actual error code is
in errno, fix cvs_errstr() to return the appropriate string, and
sprinkle some error setting where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.49 2005/04/20 23:11:30 jfb Exp $	*/
d118 72
d957 24
@


1.49
log
@check the validity of tag names passed to the tag command, and print
an abort message if the tag is invalid.  also, match gnu cvs behaviour
with regards to command usage output on usage errors.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.48 2005/04/19 19:30:18 jfb Exp $	*/
d245 1
d256 1
d262 1
d364 1
d547 1
d621 2
a622 2
	symp = (struct rcs_sym *)malloc(sizeof(*symp));
	if (symp == NULL) {
d627 2
a628 2
	symp->rs_name = cvs_strdup(sym);
	if (symp->rs_name == NULL) {
d634 1
a634 2
	symp->rs_num = rcsnum_alloc();
	if (symp->rs_num == NULL) {
d801 2
a802 2
	lkp = (struct rcs_lock *)malloc(sizeof(*lkp));
	if (lkp == NULL) {
d1315 9
a1323 3
	if ((code < 0) || (code >= (int)RCS_NERR))
		return (NULL);
	return (rcs_errstrs[code]);
d1355 1
d1366 1
d1374 1
d1403 1
d1412 1
d1466 1
d1485 1
d1500 1
d1542 1
d1562 1
d1593 1
d1628 1
d1644 1
d1661 1
d1671 1
d1692 1
d1708 1
d1745 1
d1783 1
d1809 1
d1817 1
d1830 1
d1838 1
d1868 1
d1899 1
d1907 1
d1928 1
d1939 1
d1981 1
d2000 1
d2010 1
d2038 1
d2066 1
d2075 1
d2383 1
@


1.48
log
@add error messages for the new RCS error codes
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.47 2005/04/19 19:22:31 jfb Exp $	*/
d116 1
a116 1
static const char rcs_sym_invch[] = "$,.:;@@";
@


1.47
log
@add rcs_sym_check() to check the validity of an RCS symbol and
sprinkle some in the other symbol functions
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.46 2005/04/12 14:40:19 jfb Exp $	*/
d182 2
@


1.46
log
@* handle errors when loading delta branches
* when writing RCS output, generate the proper list of branches for
  deltas
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.45 2005/04/11 20:32:56 jfb Exp $	*/
d114 4
d601 5
d655 5
d693 5
d712 26
@


1.45
log
@modify handling of RCS delta texts so we can handle arbitrary binary
data
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.44 2005/04/11 19:36:46 jfb Exp $	*/
d348 1
d406 1
a406 1
	fprintf(fp, "\n\n");
d417 6
a422 1
		fprintf(fp, "branches;\n");
d1665 4
a1668 1
			rcs_parse_branches(rfp, rdp);
d1988 1
a1988 1
		brp->rb_num = rcsnum_alloc();
a1992 2

		rcsnum_aton(RCS_TOKSTR(rfp), NULL, brp->rb_num);
@


1.44
log
@fix year value in RCS output
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.43 2005/04/07 22:08:57 jfb Exp $	*/
d1060 1
a1060 1
	len = strlen(rdp->rd_text);
d1090 1
a1090 1
			rbuf = rcs_patch((char *)bp, rdp->rd_text);
d1755 1
a1755 1
	rdp->rd_text = cvs_strdup(RCS_TOKSTR(rfp));
d1760 1
d2016 1
a2016 1
		cvs_strfree(rdp->rd_text);
@


1.43
log
@* reverse symbol list order
* allow retrieval and setting of the head revision number
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.42 2005/04/07 20:50:22 jfb Exp $	*/
d411 1
a411 1
		    rdp->rd_date.tm_year, rdp->rd_date.tm_mon + 1,
@


1.42
log
@Perform proper escaping of the @@ character in all RCS strings when
writing the output to the file.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.41 2005/04/07 16:47:11 jfb Exp $	*/
d204 1
a204 1
static struct rcs_delta*  rcs_findrev    (RCSFILE *, RCSNUM *);
d444 32
d1131 1
a1131 1
rcs_findrev(RCSFILE *rfp, RCSNUM *rev)
d1862 1
a1862 1
		TAILQ_INSERT_HEAD(&(rfp->rf_symbols), symp, rs_list);
@


1.41
log
@Fix RCS parsing for keywords that expect and ID and use cvs_strfree()
instead of free() on the duplicated token string to fix a double-free

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.40 2005/04/06 19:12:08 jfb Exp $	*/
d87 1
d111 1
a111 1
#define RCS_TOKLEN(rfp)   ((struct rcs_pdata *)rfp->rf_pdata)->rp_blen
d202 1
d345 1
a345 2
	char buf[1024], numbuf[64], *cp;
	size_t rlen, len;
d393 5
a397 2
	if (rfp->rf_comment != NULL)
		fprintf(fp, "comment\t@@%s@@;\n", rfp->rf_comment);
d399 5
a403 2
	if (rfp->rf_expand != NULL)
		fprintf(fp, "expand @@ %s @@;\n", rfp->rf_expand);
d421 4
a424 2
	fprintf(fp, "\ndesc\n@@%s@@\n\n",
	    (rfp->rf_desc == NULL) ? "" : rfp->rf_desc);
d430 5
a434 10
		fprintf(fp, "log\n@@%s@@\ntext\n@@", rdp->rd_log);

		cp = rdp->rd_text;
		do {
			len = sizeof(buf);
			rlen = rcs_stresc(1, cp, buf, &len);
			fprintf(fp, "%s", buf);
			cp += rlen;
		} while (len != 0);
		fprintf(fp, "@@\n\n");
d1728 1
d2030 1
d2064 1
d2100 1
d2132 1
a2157 47
/*
 * rcs_stresc()
 *
 * Performs either escaping or unescaping of the string stored in <str>.
 * The operation is to escape special RCS characters if the <esc> argument
 * is 1, or unescape otherwise.  The result is stored in the <buf> destination
 * buffer, and <blen> must originally point to the size of <buf>.
 * Returns the number of bytes which have been read from the source <str> and
 * operated on.  The <blen> parameter will contain the number of bytes
 * actually copied in <buf>.
 */
size_t
rcs_stresc(int esc, const char *str, char *buf, size_t *blen)
{
	size_t rlen;
	const char *sp;
	char *bp, *bep;

	rlen = 0;
	bp = buf;
	bep = buf + *blen - 1;

	for (sp = str; (*sp != '\0') && (bp <= (bep - 1)); sp++) {
		if (*sp == '@@') {
			if (esc) {
				if (bp > (bep - 2))
					break;
				*(bp++) = '@@';
			} else {
				sp++;
				if (*sp != '@@') {
					cvs_log(LP_WARN,
					    "unknown escape character `%c' in "
					    "RCS file", *sp);
					if (*sp == '\0')
						break;
				}
			}
		}

		*(bp++) = *sp;
	}

	*bp = '\0';
	*blen = (bp - buf);
	return (sp - str);
}
d2259 29
@


1.40
log
@* allow for creation and removal of RCS locks
* add rcs_tag_resolve() to resolve a branch, tag or revision easily
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.39 2005/04/06 18:51:29 joris Exp $	*/
d133 1
a133 1
	{ "author",   RCS_TOK_AUTHOR,   RCS_TOK_STRING, 0            },
d144 1
a144 1
	{ "state",    RCS_TOK_STATE,    RCS_TOK_STRING, RCS_VOPT     },
d1566 1
a1566 1
				free(tokstr);
d1581 1
a1581 1
				free(tokstr);
d1588 1
a1588 1
					free(tokstr);
d1598 1
a1598 1
					free(tokstr);
d1770 1
a1770 1
		if (type != RCS_TOK_STRING) {
@


1.39
log
@

start using strtab stuff in RCS code.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.38 2005/04/06 17:09:05 joris Exp $	*/
d690 72
d826 19
@


1.38
log
@

plug memleak in rcs_splitlines()

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.37 2005/03/26 08:09:54 tedu Exp $	*/
d40 1
d305 1
a305 1
		free(rsp->rs_name);
d324 1
a324 1
		free(rfp->rf_comment);
d326 1
a326 1
		free(rfp->rf_expand);
d328 1
a328 1
		free(rfp->rf_desc);
d499 1
a499 1
	ap->ra_name = strdup(login);
d535 1
a535 1
	free(ap->ra_name);
d569 1
a569 1
	symp->rs_name = strdup(sym);
d578 1
a578 1
		free(symp->rs_name);
d614 1
a614 1
	free(symp->rs_name);
d711 1
a711 1
	if ((tmp = strdup(desc)) == NULL)
d715 1
a715 1
		free(file->rf_desc);
d744 1
a744 1
	if ((tmp = strdup(comment)) == NULL)
d748 1
a748 1
		free(file->rf_comment);
d1061 1
a1061 1
	if ((tmp = strdup(buf)) == NULL) {
d1068 1
a1068 1
		free(file->rf_expand);
d1224 1
a1224 1
	rfp->rf_desc = strdup(RCS_TOKSTR(rfp));
d1326 1
a1326 1
				rfp->rf_comment = strdup(RCS_TOKSTR(rfp));
d1333 1
a1333 1
				rfp->rf_expand = strdup(RCS_TOKSTR(rfp));
d1476 1
a1476 1
			tokstr = strdup(RCS_TOKSTR(rfp));
d1544 1
a1544 1
		free(tokstr);
d1608 1
a1608 1
	rdp->rd_log = strdup(RCS_TOKSTR(rfp));
d1628 1
a1628 1
	rdp->rd_text = strdup(RCS_TOKSTR(rfp));
d1690 1
a1690 1
		symp->rs_name = strdup(RCS_TOKSTR(rfp));
d1700 1
a1700 1
			free(symp->rs_name);
d1710 1
a1710 1
			free(symp->rs_name);
d1720 1
a1720 1
			free(symp->rs_name);
d1729 1
a1729 1
			free(symp->rs_name);
d1881 1
a1881 1
		free(rdp->rd_author);
d1883 1
a1883 1
		free(rdp->rd_state);
d1885 1
a1885 1
		free(rdp->rd_log);
d1887 1
a1887 1
		free(rdp->rd_text);
@


1.37
log
@fix a variety of things i found at coverity.  ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.36 2005/03/13 22:50:34 jfb Exp $	*/
d2137 2
a2138 1
	if (lp == NULL)
d2140 1
d2150 1
@


1.36
log
@set rcs_errno to RCS_ERR_NOENT if no matching symbol is found in
rcs_sym_getrev()
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.35 2005/03/13 22:07:49 jfb Exp $	*/
d1130 1
a1130 1
	if ((code < 0) || (code > (int)RCS_NERR))
d1489 1
d1496 1
d1506 1
d1508 2
d1699 1
d1777 1
d1786 1
d1794 1
@


1.35
log
@support for the optional `branch' keyword, which is used to set the
default branch for an RCS file
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.34 2005/03/13 21:47:04 jfb Exp $	*/
a636 1

d641 3
a643 3
	if (symp == NULL) {
		/* XXX set error */
	} else if (((num = rcsnum_alloc()) != NULL) &&
@


1.34
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.33 2005/03/05 18:25:30 jfb Exp $	*/
a249 5
	if ((rfp->rf_branch = rcsnum_alloc()) == NULL) {
		free(rfp);
		return (NULL);
	}

a251 1
		rcsnum_free(rfp->rf_branch);
d363 6
d439 35
d1317 8
a1324 2
				rcsnum_aton(RCS_TOKSTR(rfp), NULL,
				    rfp->rf_branch);
@


1.33
log
@add functions to retrieve and set the comment leader for an RCS
file
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.32 2005/03/05 05:58:39 jfb Exp $	*/
a279 1

a336 1

a437 1

a474 2


a476 1

a506 1

a551 1

a554 1

a583 1

a586 1

a617 1

a628 1

a653 1

a664 1

a865 1

a938 1

a949 1

a960 1

a996 1

a1113 1

a1216 1

a1331 1

a1505 1

a1590 1

a1615 1

a1692 1

a1813 1

a1852 1

a1867 1

a1989 1

a2007 1

a2054 1

@


1.32
log
@add RCS error codes and a global variable to hold the last error
and make the code less verbose at the same time
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.30 2005/03/05 03:30:29 jfb Exp $	*/
d112 1
d123 1
d151 20
d702 32
@


1.31
log
@identify ID tokens correctly and fix parsing of RCS files containing
no revisions
@
text
@d149 12
d433 1
a433 2
			cvs_log(LP_ERR, "attempt to add duplicate access `%s'",
			    login);
d478 1
a478 1
		cvs_log(LP_ERR, "%s: no access for `%s'", file->rf_path, login);
d507 1
a507 2
			cvs_log(LP_ERR, "attempt to add duplicate symbol `%s'",
			    sym);
d560 1
a560 1
		cvs_log(LP_ERR, "%s: no such symbol `%s'", file->rf_path, sym);
d850 1
a850 1
		cvs_log(LP_ERR, "sorry, can't travel in the future yet");
d1052 13
@


1.30
log
@functions to manage the locking mode of RCS file
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.29 2005/03/04 18:21:00 jfb Exp $	*/
d1102 1
a1102 1
	if (rcs_parse_admin(rfp) < 0) {
d1105 9
a1113 9
	}

	for (;;) {
		ret = rcs_parse_delta(rfp);
		if (ret == 0)
			break;
		else if (ret == -1) {
			rcs_freepdata(pdp);
			return (-1);
d1166 2
a1167 1
 * Returns 0 on success, or -1 on failure.
d1183 6
a1188 2
		} else if (tok == RCS_TOK_NUM) {
			/* assume this is the start of the first delta */
d1190 1
a1190 1
			return (0);
d1861 1
a1861 1
		type = RCS_TOK_STRING;
@


1.29
log
@add real support for the `access' keyword, both in parsing and
output; rcs_access_add() can be used to add a new login name to
the access list, and rcs_access_remove() to remove an entry
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.28 2005/03/03 21:02:23 jfb Exp $	*/
d595 38
@


1.28
log
@allow for the creation of RCS files that have no revisions,
therefore no specification for the head revision
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.27 2005/03/02 04:19:34 jfb Exp $	*/
d233 1
d318 1
d325 1
a325 2
	fp = fopen(rfp->rf_path, "w");
	if (fp == NULL) {
d337 5
a341 1
	fprintf(fp, "access;\n");
d408 74
d1212 2
a1213 1
			rcs_parse_access(rfp);
d1216 2
a1217 1
			rcs_parse_symbols(rfp);
d1220 2
a1221 1
			rcs_parse_locks(rfp);
d1513 3
@


1.27
log
@- rcs_write() is now static
- when setting a new expansion mode, do not attempt to free the
  previous expansion mode if the pointer is NULL
- add a bunch of new functions:
   * rcs_sym_remove() to remove a symbol
   * rcs_sym_getrev() to retrieve the revision number of a symbol
   * rcs_desc_{s,g}et() to manipulate an RCS file's description
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.26 2005/02/27 00:22:08 jfb Exp $	*/
a215 5
	if ((rfp->rf_head = rcsnum_parse(RCS_HEAD_INIT)) == NULL) {
		free(rfp);
		return (NULL);
	}

a216 1
		rcsnum_free(rfp->rf_head);
a223 1
		rcsnum_free(rfp->rf_head);
d320 1
a320 1
	if ((rfp->rf_flags & RCS_SYNCED) || (rfp->rf_ndelta == 0))
d330 5
a334 1
	rcsnum_tostr(rfp->rf_head, numbuf, sizeof(numbuf));
d718 3
d1097 5
@


1.26
log
@Many improvements to the RCS support:

- make it possible to specify creation and the file mode
  in rcs_open()
- implicitly write the contents to disk on rcs_close() if the
  RCS handle has been changed
- fix a bug in the output of the `expand' keyword
- add functions to retrieve and modify the expansion mode
- rcs_parse() shouldn't be available to the outside
- empty string instead of `(null)' if there is no description

ok Joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.24 2005/02/16 19:45:59 jfb Exp $	*/
d150 1
d318 1
a318 1
int
d457 101
d871 2
a872 1
	free(file->rf_expand);
@


1.25
log
@- switch to rcsnum_parse() where appropriate
- make rcsnum_parse() fail if it encounters an invalid character
@
text
@d35 1
d41 1
a41 1
#define RCS_BUFSIZE     16384 
a107 19
static int  rcs_parse_admin     (RCSFILE *);
static int  rcs_parse_delta     (RCSFILE *);
static int  rcs_parse_deltatext (RCSFILE *);

static int      rcs_parse_access    (RCSFILE *);
static int      rcs_parse_symbols   (RCSFILE *);
static int      rcs_parse_locks     (RCSFILE *);
static int      rcs_parse_branches  (RCSFILE *, struct rcs_delta *);
static void     rcs_freedelta       (struct rcs_delta *);
static void     rcs_freepdata       (struct rcs_pdata *);
static int      rcs_gettok          (RCSFILE *);
static int      rcs_pushtok         (RCSFILE *, const char *, int);
static int      rcs_growbuf         (RCSFILE *);
static int      rcs_patch_lines     (struct rcs_foo *, struct rcs_foo *);

static struct rcs_delta*  rcs_findrev    (RCSFILE *, RCSNUM *);
static struct rcs_foo*    rcs_splitlines (const char *);
static void               rcs_freefoo    (struct rcs_foo *);

d150 21
d175 6
a180 5
 * given in <path>, and the opening mode is given in <mode>, which is either
 * RCS_MODE_READ, RCS_MODE_WRITE, or RCS_MODE_RDWR.  If the mode requests write
 * access and the file does not exist, it will be created.
 * The file isn't actually parsed by rcs_open(); parsing is delayed until the
 * first operation that requires information from the file.
d184 1
a184 1
rcs_open(const char *path, u_int mode)
d186 2
d190 4
d195 11
a205 3
	if ((stat(path, &st) == -1) && (errno == ENOENT) &&
	   !(mode & RCS_MODE_WRITE)) {
		cvs_log(LP_ERRNO, "cannot open RCS file `%s'", path);
d209 1
a209 2
	rfp = (RCSFILE *)malloc(sizeof(*rfp));
	if (rfp == NULL) {
d215 1
a215 2
	rfp->rf_head = rcsnum_alloc();
	if (rfp->rf_head == NULL) {
d220 3
a222 3
	rfp->rf_branch = rcsnum_alloc();
	if (rfp->rf_branch == NULL) {
		rcs_close(rfp);
d226 1
a226 2
	rfp->rf_path = strdup(path);
	if (rfp->rf_path == NULL) {
d228 3
a230 1
		rcs_close(rfp);
a233 2
	rcsnum_aton(RCS_HEAD_INIT, NULL, rfp->rf_head);

d235 2
a236 2
	rfp->rf_flags |= RCS_RF_SLOCK;
	rfp->rf_mode = mode;
d242 2
a243 1
	if (rcs_parse(rfp) < 0) {
d269 3
d326 1
a326 1
	if (rfp->rf_flags & RCS_RF_SYNCED)
d352 1
a352 1
	if (rfp->rf_flags & RCS_RF_SLOCK)
d378 2
a379 1
	fprintf(fp, "\ndesc\n@@%s@@\n\n", rfp->rf_desc);
d398 1
a398 1
	rfp->rf_flags |= RCS_RF_SYNCED;
d405 1
a405 1
 * rcs_addsym()
d412 1
a412 1
rcs_addsym(RCSFILE *rfp, const char *sym, RCSNUM *snum)
d449 1
a449 1
	rfp->rf_flags &= ~RCS_RF_SYNCED;
d623 20
a642 4
	} else {
		rdp = rcs_findrev(rfp, rfp->rf_head);
		if (rdp == NULL) {
			cvs_log(LP_ERR, "failed to get RCS HEAD revision");
d645 9
d655 2
a656 11
		len = strlen(rdp->rd_text);
		rbuf = cvs_buf_alloc(len, BUF_AUTOEXT);
		if (rbuf == NULL)
			return (NULL);
		cvs_buf_append(rbuf, rdp->rd_text, len);

		if (res != 0) {
			/* Apply patches backwards to get the right version.
			 * This will need some rework to support sub branches.
			 */
			if ((crev = rcsnum_alloc()) == NULL) {
d660 5
a664 20
			rcsnum_cpy(rfp->rf_head, crev, 0);
			do {
				crev->rn_id[crev->rn_len - 1]--;
				rdp = rcs_findrev(rfp, crev);
				if (rdp == NULL) {
					rcsnum_free(crev);
					cvs_buf_free(rbuf);
					return (NULL);
				}

				if (cvs_buf_putc(rbuf, '\0') < 0) {
					rcsnum_free(crev);
					cvs_buf_free(rbuf);
					return (NULL);
				}
				bp = cvs_buf_release(rbuf);
				rbuf = rcs_patch((char *)bp, rdp->rd_text);
				if (rbuf == NULL)
					break;
			} while (rcsnum_cmp(crev, rev, 0) != 0);
d666 1
a666 2
			rcsnum_free(crev);
		}
d711 1
a711 1
	
d735 52
d837 1
d844 1
a844 1
int
d850 1
a850 1
	if (rfp->rf_flags & RCS_RF_PARSED)
d853 1
a853 2
	pdp = (struct rcs_pdata *)malloc(sizeof(*pdp));
	if (pdp == NULL) {
d879 1
a879 1
	rfp->rf_flags &= ~RCS_RF_SLOCK;
d936 1
a936 1
	rfp->rf_flags |= RCS_RF_PARSED|RCS_RF_SYNCED;
d1020 1
a1020 1
				    rk->rk_str);	
d1161 1
a1161 1
				    rk->rk_str);	
d1214 1
d1472 1
a1472 1
		rfp->rf_flags |= RCS_RF_SLOCK;
@


1.24
log
@get rid of unneeded whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.23 2005/01/24 20:43:12 jfb Exp $	*/
d1095 1
a1095 2
				datenum = rcsnum_alloc();
				if (datenum == NULL) {
a1098 1
				rcsnum_aton(tokstr, NULL, datenum);
@


1.23
log
@more error checking

looks ok from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.22 2005/01/14 00:47:44 jfb Exp $	*/
a441 1

a588 1

a669 1

a683 1

a770 1

a875 1

a980 1

a1156 1

a1240 1

a1263 1

a1341 1

a1419 1

a1462 1

a1502 1

a1518 1

a1641 1

a1666 1

a1709 1

a1786 1

@


1.22
log
@tweak the output of rcs_kflag_usage() to avoid line wrapping
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.21 2005/01/13 20:50:57 jfb Exp $	*/
d622 1
a622 2
			crev = rcsnum_alloc();
			if (crev == NULL) {
d636 5
a640 1
				cvs_buf_putc(rbuf, '\0');
@


1.21
log
@add rcs_kflag_usage() to display the various keyword expansion modes
supported by the -k argument
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.20 2005/01/12 19:23:27 jfb Exp $	*/
d757 5
a761 5
	    "\t-kkv\t\tGenerate keywords using the default form.\n"
	    "\t-kkvl\t\tLike -kkv, except locker's name inserted.\n"
	    "\t-kk\t\tGenerate only keyword names in keyword strings.\n"
	    "\t-kv\t\tGenerate only keyword values in keyword strings.\n"
	    "\t-ko\t\tGenerate the old keyword string "
d763 1
a763 1
	    "\t-kb\t\tGenerate binary file unmodified (merges not allowed).\n");
@


1.20
log
@add rcs_kflag_get() to validate kflags
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.19 2004/12/18 17:20:40 jfb Exp $	*/
d753 12
@


1.19
log
@when parsing an RCS date, adjust the year by 1900 in the tm structure
so we can use this data with asctime(), mktime() and friends

spotted and patch by Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.18 2004/12/17 21:13:58 jfb Exp $	*/
d130 11
d712 39
@


1.18
log
@* increase the initial parse buffer size to 16384 bytes
* grow the parse buffer as required in rcs_gettok()
* fix line counting offset

tested by Joris Vink and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.17 2004/12/16 18:55:52 jfb Exp $	*/
d1052 2
@


1.17
log
@plug some memory leaks on error cases
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.16 2004/12/16 17:16:18 jfb Exp $	*/
d40 2
a41 1
#define RCS_BUFSIZE   8192
d80 1
a80 1
	u_int  rp_line;
d84 1
d119 1
d154 1
d727 1
a727 1
	pdp->rp_line = 1;
d744 1
d799 1
a799 1
	    pdp->rp_line);
d838 1
a838 1
		for (i = 0; i < sizeof(rcs_keys)/sizeof(rcs_keys[0]); i++)
d979 1
a979 1
		for (i = 0; i < sizeof(rcs_keys)/sizeof(rcs_keys[0]); i++)
d1409 1
a1409 1
void
d1472 2
a1473 1
	char *bp, *bep;
a1477 1
	bep = pdp->rp_buf + pdp->rp_blen - 1;
d1492 1
a1492 1
			pdp->rp_line++;
d1502 1
d1504 1
a1504 1
		while (bp <= bep - 1) {
d1511 8
d1522 7
a1528 4
		for (i = 0; i < sizeof(rcs_keys)/sizeof(rcs_keys[0]); i++) {
			if (strcmp(rcs_keys[i].rk_str, pdp->rp_buf) == 0) {
				type = rcs_keys[i].rk_id;
				break;
a1530 5

		/* not a keyword, assume it's just a string */
		if (type == RCS_TOK_ERR)
			type = RCS_TOK_STRING;

d1533 1
d1543 1
a1543 1
				pdp->rp_line++;
d1546 8
a1553 2
			if (bp == bep)
				break;
a1556 1
		type = RCS_TOK_STRING;
d1564 1
a1564 1
			if (bp == bep)
d1578 1
a1578 1
		*(bp) = '\0';
d1728 28
@


1.16
log
@Add rcs_gethead() to easily retrieve the head revision of an RCS
file.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.15 2004/12/07 17:10:56 tedu Exp $	*/
d384 2
d405 1
d443 2
a444 1
	if (dlines == NULL)
d446 1
d450 1
d456 1
d608 2
a609 1
			if (crev == NULL)
d611 1
d616 3
a618 1
				if (rdp == NULL)
d620 1
a631 1

@


1.15
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.14 2004/12/06 21:03:12 deraadt Exp $	*/
d623 12
@


1.14
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.13 2004/09/27 15:33:44 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a76 1

a163 1

a225 1

a282 1

a375 1

d945 1
a945 1
			rcs_pushtok(rfp, RCS_TOKSTR(rfp), tok); 
d992 1
a992 1
				cvs_log(LP_ERRNO, 
d1486 1
a1486 1
			if (strcmp(rcs_keys[i].rk_str, pdp->rp_buf) == 0) { 
@


1.13
log
@Plug all of the remaining memory leaks using my new Plug-O-Matic 2000(C)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d509 1
a509 2
			}
			else if (dlp->rl_lineno < lineno) {
d528 1
a528 2
		}
		else if (op == 'a') {
d546 1
a546 2
		}
		else {
d588 1
a588 2
	}
	else {
d808 1
a808 2
		}
		else if (tok == RCS_TOK_NUM) {
d842 1
a842 2
			}
			else if (tok == RCS_TOK_BRANCH) {
d845 1
a845 2
			}
			else if (tok == RCS_TOK_COMMENT) {
d852 1
a852 2
			}
			else if (tok == RCS_TOK_EXPAND) {
d949 1
a949 2
		}
		else if (tok == RCS_TOK_NUM || tok == RCS_TOK_DESC) {
d1035 1
a1035 2
			}
			else if (tok == RCS_TOK_AUTHOR) {
d1038 1
a1038 2
			}
			else if (tok == RCS_TOK_STATE) {
d1041 1
a1041 2
			}
			else if (tok == RCS_TOK_NEXT) {
d1321 1
a1321 2
	}
	else {
d1474 1
a1474 2
	}
	else if (ch == ';') {
d1476 1
a1476 2
	}
	else if (ch == ':') {
d1478 1
a1478 2
	}
	else if (isalpha(ch)) {
d1501 1
a1501 2
	}
	else if (ch == '@@') {
d1511 1
a1511 2
			}
			else if (ch == '\n')
d1521 1
a1521 2
	}
	else if (isdigit(ch)) {
d1598 1
a1598 2
			}
			else {
@


1.12
log
@Plug two of the huge leaks that Joris Vink has reported.  rcs_freedelta()
didn't free the RCSNUMs associated with the delta version and next one
@
text
@d233 2
d247 15
d1069 3
a1093 4
	tnum = rcsnum_alloc();
	if (tnum == NULL)
		return (-1);

d1104 4
d1114 2
@


1.11
log
@

- check return values for rcsnum_alloc()
- fix crash when parsing an RCS file and the "branch" keyword was found
- allow '-' and '_' characters in rcs_gettok() (used in symbollists for ex.)
@
text
@d1380 1
d1383 5
d1396 6
@


1.10
log
@

check value of strdup(3) calls;
ok jfb
@
text
@d191 6
d247 2
d390 4
d593 2
a594 1

d909 4
d914 4
d1007 4
d1204 5
d1214 1
d1224 1
d1233 1
d1276 4
d1357 5
d1464 1
a1464 1
			if (!isalnum(ch)) {
d1482 1
@


1.9
log
@Unused variable
@
text
@d375 6
d733 5
d824 5
d832 5
d967 6
a972 1

d1172 6
@


1.8
log
@Unused variable
@
text
@a268 1
	struct rcs_lock *lkp;
@


1.7
log
@* when writing to an RCS file, escape the funny characters
* pretty
@
text
@a442 1
	FILE *fp;
@


1.6
log
@fix rcs_findrev()'s searching algorithm
@
text
@d110 13
a122 13
static int      rcs_parse_access      (RCSFILE *);
static int      rcs_parse_symbols     (RCSFILE *);
static int      rcs_parse_locks       (RCSFILE *);
static int      rcs_parse_branches    (RCSFILE *, struct rcs_delta *);
static void     rcs_freedelta         (struct rcs_delta *);
static void     rcs_freepdata         (struct rcs_pdata *);
static int      rcs_gettok            (RCSFILE *);
static int      rcs_pushtok           (RCSFILE *, const char *, int);
int rcs_patch_lines(struct rcs_foo *, struct rcs_foo *);

static struct rcs_delta*  rcs_findrev (RCSFILE *, RCSNUM *);
static struct rcs_foo* rcs_splitlines (const char *);
static void rcs_freefoo(struct rcs_foo *);
d266 2
a267 1
	char buf[128], numbuf[64];
d330 10
a339 2
		fprintf(fp, "log\n@@%s@@\n", rdp->rd_log);
		fprintf(fp, "text\n@@%s@@\n\n", rdp->rd_text);
d438 1
a438 1
int
a1498 3

	if (!esc)
		printf("unescaping `%s'\n", str);
@


1.5
log
@split rcs_patch in rcs_patch/rcs_patchlines
@
text
@d619 2
a620 1

d624 6
a629 4
	TAILQ_FOREACH(rdp, hp, rd_list) {
		if (rcsnum_cmp(rdp->rd_num, rev, cmplen) == 0) {
			if (cmplen == rev->rn_len)
				return (rdp);
d631 5
a635 2
			hp = &(rdp->rd_snodes);
			cmplen += 2;
d637 1
a637 1
	}
@


1.4
log
@buffers should be freed using cvs_buf_free(), not free()
@
text
@d98 1
a98 1

d103 1
a103 1
	TAILQ_HEAD(rcs_tqh, rcs_line) rl_lines;
a105 2


d118 2
d122 1
d390 2
a391 1
	char op, *ep;
d393 1
a393 3
	int i, lineno, nbln;
	struct rcs_foo *dlines, *plines;
	struct rcs_line *lp, *dlp, *ndlp;
a394 1
	FILE *fp;
d404 1
d406 2
a407 1
	if (plines == NULL)
d409 27
d494 1
a494 1
					return (NULL);
d509 1
a509 1
			return (NULL);
d519 1
a519 3
	TAILQ_FOREACH(lp, &(dlines->rl_lines), rl_list) {
		if (lineno != 0)
			cvs_buf_fappend(res, "%s\n", lp->rl_line);
a520 1
	}
d523 1
a523 1
	return (res);
d1553 1
a1553 1
	if (lp == NULL) {
d1555 1
a1555 1
	}
d1580 13
@


1.3
log
@allocate datenum dynamically (XXX - dont do it for each date)
@
text
@d506 2
a507 2
 * returned buffer is dynamically allocated and should be released using free()
 * once the caller is done using it.
@


1.2
log
@microoptimization!
@
text
@d825 1
a825 1
	RCSNUM datenum;
d921 3
a923 2
				rcsnum_aton(tokstr, NULL, &datenum);
				if (datenum.rn_len != 6) {
d927 1
a927 1
					    (datenum.rn_len > 6) ? "too many" :
d931 7
a937 6
				rdp->rd_date.tm_year = datenum.rn_id[0];
				rdp->rd_date.tm_mon = datenum.rn_id[1] - 1;
				rdp->rd_date.tm_mday = datenum.rn_id[2];
				rdp->rd_date.tm_hour = datenum.rn_id[3];
				rdp->rd_date.tm_min = datenum.rn_id[4];
				rdp->rd_date.tm_sec = datenum.rn_id[5];
@


1.1
log
@Initial revision
@
text
@d490 1
a490 1
	lineno = 1;
d492 2
a493 5
		if (lineno == 1) {
			lineno++;
			continue;
		}
		cvs_buf_fappend(res, "%s\n", lp->rl_line);
a495 1

@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
