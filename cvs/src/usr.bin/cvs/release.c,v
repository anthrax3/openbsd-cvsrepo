head	1.42;
access;
symbols
	OPENBSD_6_1:1.42.0.10
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.8
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.4
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.24
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.22
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.18
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.16
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.14
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.12
	OPENBSD_5_0:1.41.0.10
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.8
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.6
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.4
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.40.0.6
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21;
locks; strict;
comment	@ * @;


1.42
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Uu5nFG3wCl0LACBb;

1.41
date	2009.03.21.11.18.45;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.24.11.06.13;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2008.02.23.13.07.43;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.37;

1.37
date	2008.01.10.10.05.40;	author tobias;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.25.10.56.04;	author chl;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.26.18.02.43;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.27.03.30.31;	author joris;	state dead;
branches;
next	1.32;

1.32
date	2006.03.15.19.59.36;	author niallo;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.27.15.26.38;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.27.12.45.21;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.03.12.47.14;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.30.16.42.13;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.24.19.07.52;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.22.14.31.44;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.21.16.55.28;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.10.14.49.20;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.01.11.18.10;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.27.10.36.14;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.23.10.59.47;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.22.16.27.29;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.22.15.34.05;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.14.15.17.42;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.13.14.35.17;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.30.16.37.29;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.31.14.02.15;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.31.08.26.40;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.27.17.04.59;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.19.22.07.33;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.19.15.31.35;	author xsa;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.17.08.16.03;	author xsa;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.12.23.41.14;	author xsa;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.11.15.31.54;	author xsa;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: release.c,v 1.41 2009/03/21 11:18:45 joris Exp $	*/
/*-
 * Copyright (c) 2005-2007 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

void	cvs_release_local(struct cvs_file *);

static void	release_check_files(struct cvs_file *);

static int	dflag = 0;
static int	files_altered = 0;

struct cvs_cmd cvs_cmd_release = {
	CVS_OP_RELEASE, CVS_USE_WDIR, "release",
	{ "re", "rel" },
	"Indicate that a Module is no longer in use",
	"[-d] dir...",
	"d",
	NULL,
	cvs_release
};

int
cvs_release(int argc, char **argv)
{
	int ch;
	int flags;
	struct cvs_recursion cr;

	flags = CR_REPO;

	while ((ch = getopt(argc, argv, cvs_cmd_release.cmd_opts)) != -1) {
		switch (ch) {
		case 'd':
			dflag = 1;
			break;
		default:
			fatal("%s", cvs_cmd_release.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		fatal("%s", cvs_cmd_release.cmd_synopsis);

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (dflag == 1)
			cvs_client_send_request("Argument -d");
	} else
		cr.fileproc = cvs_release_local;

	cr.flags = flags;

	cvs_file_run(argc, argv, &cr);

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("release");
		cvs_client_get_responses();
	}

	return (0);
}

void
cvs_release_local(struct cvs_file *cf)
{
	struct stat st;
	struct cvs_recursion cr;
	char *wdir, cwd[PATH_MAX];
	char *arg = ".";
	int saved_noexec;

	if (cf->file_type == CVS_FILE)
		return;

	cvs_log(LP_TRACE, "cvs_release_local(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if (cvs_server_active == 1) {
		cvs_history_add(CVS_HISTORY_RELEASE, cf, NULL);
		return;
	}

	if ((wdir = getcwd(cwd, sizeof(cwd))) == NULL)
		fatal("getcwd failed");

	if (cf->file_type == CVS_DIR) {
		if (!strcmp(cf->file_name, "."))
			return;

		/* chdir before updating the directory. */
		cvs_chdir(cf->file_path, 0);

		if (stat(CVS_PATH_CVSDIR, &st) == -1 || !S_ISDIR(st.st_mode)) {
			if (verbosity > 0)
				cvs_log(LP_ERR, "no repository directory: %s",
				    cf->file_path);
			return;
		}
	}

	/* Skip the interactive part if -Q is specified. */
	if (verbosity == 0)
		goto delete;

	saved_noexec = cvs_noexec;
	cvs_noexec = 1;

	cr.enterdir = NULL;
	cr.leavedir = NULL;
	cr.fileproc = cvs_update_local;
	cr.flags = CR_REPO | CR_RECURSE_DIRS;

	cvs_file_run(1, &arg, &cr);

	cvs_noexec = saved_noexec;

	cr.enterdir = NULL;
	cr.leavedir = NULL;
	cr.fileproc = release_check_files;
	cr.flags = CR_RECURSE_DIRS;

	cvs_file_run(1, &arg, &cr);

	(void)printf("You have [%d] altered files in this repository.\n",
	    files_altered);
	(void)printf("Are you sure you want to release %sdirectory `%s': ",
		(dflag == 1) ? "(and delete) " : "", cf->file_path);

	if (cvs_yesno() == -1) {
		(void)fprintf(stderr,
		    "** `%s' aborted by user choice.\n", cmdp->cmd_name);

		/* change back to original working dir */
		cvs_chdir(wdir, 0);

		return;
	}

	/* change back to original working dir */
	cvs_chdir(wdir, 0);

delete:
	if (dflag == 1) {
		if (cvs_rmdir(cf->file_path) != 0)
			fatal("cvs_release_local: cvs_rmdir failed");
	}
}

static void
release_check_files(struct cvs_file *cf)
{
	cvs_log(LP_TRACE, "release_check_files(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_status == FILE_MERGE ||
	    cf->file_status == FILE_ADDED ||
	    cf->file_status == FILE_PATCH ||
	    cf->file_status == FILE_CONFLICT)
		files_altered++;
}
@


1.41
log
@kill useless return;
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.40 2008/02/24 11:06:13 xsa Exp $	*/
d99 1
a99 1
	char *wdir, cwd[MAXPATHLEN];
@


1.40
log
@More -Q support.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.39 2008/02/23 13:07:43 xsa Exp $	*/
a192 1
	return;
@


1.39
log
@Handle global -Q; Avoid interactive stuff when specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.37 2008/01/10 10:05:40 tobias Exp $	*/
d126 3
a128 2
			cvs_log(LP_ERR, "no repository directory: %s",
			    cf->file_path);
@


1.38
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d132 4
d173 1
@


1.37
log
@Simply the use of cmdp and cvs_command by zapping cvs_command and working
solely with cmdp.  This remedies some reliability issues with invalid
commands supplied and also fixes a GNU cvs style incompatibility with
release command.

> Based on patch from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.36 2007/09/25 10:56:04 chl Exp $	*/
d34 1
a34 1
	CVS_OP_RELEASE, 0, "release",
@


1.36
log
@remove unused extern variable

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.35 2007/09/22 16:01:22 joris Exp $	*/
d158 1
a158 1
		    "** `%s' aborted by user choice.\n", cvs_command);
@


1.35
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.34 2007/06/26 18:02:43 xsa Exp $	*/
a24 2

extern char *__progname;
@


1.34
log
@Bring back the release command. More work to be done though.
OK joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d110 1
a110 1
	cvs_file_classify(cf, NULL);
d182 1
a182 1
	cvs_file_classify(cf, NULL);
@


1.33
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 3
a3 4
/*	$OpenBSD: release.c,v 1.32 2006/03/15 19:59:36 niallo Exp $	*/
/*
 * Copyright (c) 2005 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d18 4
a21 1
#include "includes.h"
d24 1
a24 2
#include "log.h"
#include "proto.h"
d26 1
a26 1
#define UPDCMD_FLAGS	"-n -q -d"
d28 3
a30 1
extern char *__progname;
d32 2
a33 3
static int	cvs_release_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_release_pre_exec(struct cvsroot *);
static int	cvs_release_dir(CVSFILE *, void *);
d36 1
a36 1
	CVS_OP_RELEASE, CVS_REQ_RELEASE, "release",
d38 2
a39 2
	"Release",
	"[-d]",
d42 1
a42 8
	CF_NOFILES,
	cvs_release_init,
	cvs_release_pre_exec,
	cvs_release_dir,
	cvs_release_dir,
	NULL,
	NULL,
	CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2 | CVS_CMD_ALLOWSPEC
d45 2
a46 4
static int	dflag;	/* -d option */

static int
cvs_release_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d49 4
d54 1
a54 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
d60 1
a60 1
			return (CVS_EX_USAGE);
a65 1
	*arg = optind;
d68 1
a68 1
		return (CVS_EX_USAGE);
d70 6
a75 2
	return (0);
}
a76 4
static int
cvs_release_pre_exec(struct cvsroot *root)
{
	if (root->cr_method != CVS_METHOD_LOCAL) {
d78 13
a90 1
			cvs_sendarg(root, "-d", 0);
d92 1
d96 2
a97 8
/*
 * cvs_release_dir()
 *
 * Release specified directorie(s).
 * Returns 0 on success, or -1 on failure.
 */
static int
cvs_release_dir(CVSFILE *cf, void *arg)
d99 2
a100 2
	FILE *fp;
	int j, l;
d102 5
a106 3
	char buf[256], dpath[MAXPATHLEN], updcmd[1024];
	struct stat st;
	struct cvsroot *root;
d108 1
a108 1
	j = 0;
d110 6
a115 1
	root = CVS_DIR_ROOT(cf);
a116 2
	/* XXX kept for compat reason of `cvs update' output */
	/* save current working directory for further use */
d120 11
a130 15
	cvs_file_getpath(cf, dpath, sizeof(dpath));

	if (cf->cf_type == DT_DIR) {
		if (!strcmp(cf->cf_name, "."))
			return (0);

		/* chdir before running the `cvs update' command */
		cvs_chdir(dpath, 0);

		/* test if dir has CVS/ directory */
		if (stat(CVS_PATH_CVSDIR, &st) == -1) {
			if (verbosity > 0)
				cvs_log(LP_ERR,
				    "no repository directory: %s", dpath);
			return (0);
a131 21
	} else {
		if (verbosity > 0)
			cvs_log(LP_ERR, "no such directory: %s", dpath);
		return (0);
	}

	/* construct `cvs update' command */
	l = snprintf(updcmd, sizeof(updcmd), "%s %s %s update",
	    __progname, UPDCMD_FLAGS, root->cr_str);
	if (l == -1 || l >= (int)sizeof(updcmd))
		fatal("cvs_release_dir: `cvs update' command string overflow");

	/* XXX we should try to avoid a new connection ... */
	cvs_log(LP_TRACE, "cvs_release_dir() popen(%s,r)", updcmd);
	if ((fp = popen(updcmd, "r")) == NULL)
		fatal("cannot run command `%s'", updcmd);

	while (fgets(buf, (int)sizeof(buf), fp) != NULL) {
		if (strchr("ACMPRU", buf[0]))
			j++;
		(void)fputs(buf, stdout);
d134 2
a135 2
	if (pclose(fp) != 0) {
		cvs_log(LP_ERR, "unable to release `%s'", dpath);
d137 13
a149 3
		/* change back to original working dir */
		cvs_chdir(wdir, 0);
	}
d151 1
a151 7
	printf("You have [%d] altered file%s in this repository.\n",
	    j, j > 1 ? "s" : "");
	while (fgets(buf, (int)sizeof(buf), fp) != NULL) {
		if (strchr("ACMPRU", buf[0]))
			j++;
		(void)fputs(buf, stdout);
	}
d153 4
a156 2
	printf("Are you sure you want to release %sdirectory `%s': ",
	    dflag ? "(and delete) " : "", dpath);
d158 2
a159 2
	if (cvs_yesno() == -1) {	/* No */
		fprintf(stderr,
d165 1
a165 1
		return (-1);
d172 2
a173 2
		if (cvs_rmdir(dpath) != 0)
			fatal("cvs_release_dir: cvs_rmdir failed");
d175 1
d177 13
a189 1
	return (0);
@


1.32
log
@- add util.h, reorganising a bunch of things and exposing cvs_yesno()
function to be used by rcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.31 2006/01/27 15:26:38 xsa Exp $	*/
@


1.31
log
@more errors handling cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.30 2006/01/27 12:45:21 xsa Exp $	*/
a38 1
static int	cvs_release_yesno(void);
a95 25
 * cvs_release_yesno()
 *
 * Read from standart input for `y' or `Y' character.
 * Returns 0 on success, or -1 on failure.
 */
static int
cvs_release_yesno(void)
{
	int c, ret;

	ret = 0;

	fflush(stderr);
	fflush(stdout);

	if ((c = getchar()) != 'y' && c != 'Y')
		ret = -1;
	else
		while (c != EOF && c != '\n')
			c = getchar();

	return (ret);
}

/*
d177 1
a177 1
	if (cvs_release_yesno() == -1) {	/* No */
@


1.30
log
@errors handling cleaning here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.29 2006/01/03 12:47:14 xsa Exp $	*/
d172 1
a172 1
		return (CVS_EX_DATA);
@


1.29
log
@use fatal();
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.28 2006/01/02 08:11:56 xsa Exp $	*/
d218 1
a218 1
			return (CVS_EX_FILE);
@


1.28
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.27 2005/12/30 16:42:13 xsa Exp $	*/
d143 2
a144 4
	if ((wdir = getcwd(cwd, sizeof(cwd))) == NULL) {
		cvs_log(LP_ERRNO, "cannot get current dir");
		return (CVS_EX_FILE);
	}
d176 2
a177 4
	if ((fp = popen(updcmd, "r")) == NULL) {
		cvs_log(LP_ERR, "cannot run command `%s'", updcmd);
		return (CVS_EX_DATA);
	}
@


1.27
log
@minor style nits;
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.26 2005/12/30 02:03:28 joris Exp $	*/
d27 1
a27 9
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.26
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.25 2005/12/24 19:07:52 xsa Exp $	*/
d98 1
a98 1
		if (dflag)
a100 1

@


1.25
log
@add an argument to cvs_chdir() which enables or not the removal
of the directory we just chdir'd to.
Useful when the function fails especially for the server mode and
its temporary directory. This way it's not left behind on exit.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.24 2005/12/22 14:31:44 xsa Exp $	*/
d98 2
a99 2
		if (dflag && cvs_sendarg(root, "-d", 0) < 0)
			return (CVS_EX_PROTO);
@


1.24
log
@cvs_chdir() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.23 2005/10/07 21:47:32 reyk Exp $	*/
d164 1
a164 1
		cvs_chdir(dpath);
d202 1
a202 1
		cvs_chdir(wdir);
d221 1
a221 1
		cvs_chdir(wdir);
d227 1
a227 1
	cvs_chdir(wdir);
@


1.23
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.22 2005/09/21 16:55:28 xsa Exp $	*/
d164 1
a164 2
		if (cvs_chdir(dpath) == -1)
			return (CVS_EX_FILE);
d202 1
a202 2
		if (cvs_chdir(wdir) == -1)
			return (CVS_EX_FILE);
d221 1
a221 2
		if (cvs_chdir(wdir) == -1)
			return (CVS_EX_FILE);
d227 1
a227 2
	if (cvs_chdir(wdir) == -1)
		return (CVS_EX_FILE);
@


1.22
log
@clean this mess up; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.21 2005/08/10 14:49:20 xsa Exp $	*/
d118 2
a119 2
	fflush (stderr);
	fflush (stdout);
@


1.21
log
@fgets() expects the 2nd arg to be an int. OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.20 2005/08/01 11:18:10 xsa Exp $	*/
d57 1
a57 1
	0,
a140 1
	size_t len;
d142 1
a142 2
	char cdpath[MAXPATHLEN], dpath[MAXPATHLEN];
	char buf[256], updcmd[1024];
d146 1
a146 1
	j = 0;		/* number of altered files in the working copy */
d150 7
a158 4
	len = cvs_path_cat(dpath, CVS_PATH_CVSDIR, cdpath, sizeof(cdpath));
	if (len >= sizeof(cdpath))
		return (CVS_EX_DATA);

a161 10
		else {
			/* test if dir has CVS/ directory */
			if (stat(cdpath, &st) == -1) {
				if (verbosity > 0)
					cvs_log(LP_ERR,
					    "no repository directory: %s",
					    dpath);
				return (0);
			}
		}
d163 10
a172 57
		if (root->cr_method != CVS_METHOD_LOCAL) {
			/* XXX kept for compat reason of `cvs update' output */
			/* save current working directory for further use */
			if ((wdir = getcwd(cwd, sizeof(cwd))) == NULL)
				cvs_log(LP_ERRNO, "cannot get current dir");

			/* change dir before running the `cvs update' command */
			if (cvs_chdir(dpath) == -1)
				return (CVS_EX_FILE);

			/* construct `cvs update' command */
			l = snprintf(updcmd, sizeof(updcmd), "%s %s %s update",
			    __progname, UPDCMD_FLAGS, root->cr_str);
			if (l == -1 || l >= (int)sizeof(updcmd))
				return (CVS_EX_DATA);

			/* XXX we should try to avoid a new connection ... */
			if ((fp = popen(updcmd, "r")) == NULL) {
				cvs_log(LP_ERR, "cannot run command `%s'",
				    updcmd);
				return (CVS_EX_DATA);
			}

			while (fgets(buf, (int)sizeof(buf), fp) != NULL) {
				if (strchr("ACMPRU", buf[0]))
					j++;
				(void)fputs(buf, stdout);
			}

			if (pclose(fp) != 0) {
				cvs_log(LP_ERR, "unable to release `%s'",
				    dpath);
				return (CVS_EX_DATA);
			}

			printf("You have [%d] altered file%s in this "
			    "repository.\n", j, j > 1 ? "s" : "");

			printf("Are you sure you want to release "
			    "%sdirectory `%s': ",
			    dflag ? "(and delete) " : "", dpath);

			if (cvs_release_yesno() == -1) {	/* No */
				(void)fprintf(stderr,
				    "** `%s' aborted by user choice.\n",
				    cvs_command);
				return (-1);
			}

			/* change back to original working dir */
			if (cvs_chdir(wdir) == -1)
				return (CVS_EX_FILE);

			if (dflag == 1) {
				if (cvs_rmdir(dpath) != 0)
					return (CVS_EX_FILE);
			}
d177 13
d191 45
@


1.20
log
@add command aliases, `re' and `rel'; from mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.19 2005/07/27 10:36:14 xsa Exp $	*/
d195 1
a195 1
			while (fgets(buf, sizeof(buf), fp) != NULL) {
@


1.19
log
@rename cvs_remove_dir() to cvs_rmdir() because it might be confusing
with the `remove' command local functions. ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.18 2005/07/25 12:13:08 xsa Exp $	*/
d52 1
a52 1
	{ },
@


1.18
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.17 2005/07/23 10:59:47 xsa Exp $	*/
d226 1
a226 4
				if (!cvs_noexec && cvs_remove_dir(dpath) != 0) {
					cvs_log(LP_ERRNO,
					    "deletion of directory `%s' failed",
					    dpath);
a227 1
				}
@


1.17
log
@use cvs_chdir();
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.16 2005/07/22 16:27:29 joris Exp $	*/
d45 4
a48 4
static int cvs_release_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_release_pre_exec (struct cvsroot *);
static int cvs_release_yesno    (void);
static int cvs_release_dir      (CVSFILE *, void *);
@


1.16
log
@use the cf_name field of the CVSFILE struct instead of using the old
CVS_FILE_NAME macro. This macro used to be nifty because of all
the referencing for the names, but since we don't do that anymore and
use cf_name directly... byebye CVS_FILE_NAME()

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.15 2005/07/22 15:34:05 xsa Exp $	*/
d179 1
a179 3
			if (chdir(dpath) == -1) {
				cvs_log(LP_ERRNO, "cannot change to dir `%s'",
				    dpath);
a180 1
			}
d222 1
a222 3
			if (chdir(wdir) == -1) {
				cvs_log(LP_ERRNO, "cannot change to original "
				    "working dir `%s'", wdir);
a223 1
			}
@


1.15
log
@minor tweaks, no functional change;
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.14 2005/07/14 15:17:42 xsa Exp $	*/
d159 1
a159 1
		if (!strcmp(CVS_FILE_NAME(cf), "."))
@


1.14
log
@handle some -Q cases;
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.13 2005/07/13 14:35:17 xsa Exp $	*/
d137 1
a137 1
cvs_release_dir(CVSFILE *cdir, void *arg)
d143 2
a144 2
	char buf[256], cdpath[MAXPATHLEN], dpath[MAXPATHLEN];
	char updcmd[MAXPATHLEN];	/* XXX find a better size; malloc()?? */
d150 1
a150 1
	root = CVS_DIR_ROOT(cdir);
d152 1
a152 1
	cvs_file_getpath(cdir, dpath, sizeof(dpath));
d158 2
a159 2
	if (cdir->cf_type == DT_DIR) {
		if (!strcmp(CVS_FILE_NAME(cdir), "."))
@


1.13
log
@use cvs_path_cat() instead of snprintf();
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.12 2005/07/07 14:27:57 joris Exp $	*/
d164 4
a167 2
				cvs_log(LP_ERR,
				    "no repository directory: %s", dpath);
d241 2
a242 1
		cvs_log(LP_ERR, "no such directory: %s", dpath);
@


1.12
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.11 2005/06/30 16:37:29 joris Exp $	*/
d141 1
d154 2
a155 4
	l = snprintf(cdpath, sizeof(cdpath), "%s/" CVS_PATH_CVSDIR, dpath);
	if (l == -1 || l >= (int)sizeof(cdpath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", cdpath);
a156 1
	}
@


1.11
log
@

missing method checks in pre_exec handler.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.10 2005/05/31 14:02:15 xsa Exp $	*/
d176 1
a176 1
                		cvs_log(LP_ERRNO, "cannot get current dir");
d219 1
a219 1
			    	    "** `%s' aborted by user choice.\n",
d234 1
a234 1
				   	    "deletion of directory `%s' failed",
@


1.10
log
@cvs_noexec check if -d option specified ..
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.9 2005/05/31 08:26:40 xsa Exp $	*/
d97 4
a100 2
	if (dflag && cvs_sendarg(root, "-d", 0) < 0)
		return (CVS_EX_PROTO);
@


1.9
log
@remove LP_ERROR log priority level and rather use LP_ERR as they are both
the same...

ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.8 2005/05/27 17:04:59 jfb Exp $	*/
d230 1
a230 1
				if (cvs_remove_dir(dpath) != 0) {
@


1.8
log
@- check strlcpy() return values for truncation
- in cvs_remove_dir(), return failure if we fail to unlink the
  base directory, and return -1 on error to respect the general
  util convention
- missing function documentation
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.7 2005/05/24 04:12:25 jfb Exp $	*/
d191 1
a191 1
				cvs_log(LP_ERROR, "cannot run command `%s'",
d203 1
a203 1
				cvs_log(LP_ERROR, "unable to release `%s'",
@


1.7
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.6 2005/05/20 20:00:53 joris Exp $	*/
d230 1
a230 1
				if (cvs_remove_dir(dpath) != CVS_EX_OK) {
@


1.6
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.5 2005/05/19 22:07:33 jfb Exp $	*/
d45 15
a59 8
static int cvs_release_options(char *, int, char **, int *);
static int cvs_release_sendflags(struct cvsroot *);
static int cvs_release_yesno(void);
static int cvs_release_dir(CVSFILE *, void *);

struct cvs_cmd_info cvs_release = {
	cvs_release_options,
	cvs_release_sendflags,
d61 3
a63 3
	NULL, NULL,
	CF_IGNORE | CF_KNOWN | CF_NOFILES | CF_RECURSE,
	CVS_REQ_RELEASE,
d70 1
a70 1
cvs_release_options(char *opt, int argc, char **argv, int *arg)
d74 1
a74 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d95 1
a95 1
cvs_release_sendflags(struct cvsroot *root)
@


1.5
log
@kill whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.4 2005/05/19 15:31:35 xsa Exp $	*/
d148 1
a148 1
		return (-1);
d173 1
a173 1
				return (-1);
d180 1
a180 1
				return (-1);
d186 1
a186 1
				return (-1);
d198 1
a198 1
				return (-1);
d219 1
a219 1
				return (-1);
d227 1
a227 1
					return (-1);
d233 1
a233 1
		return (-1);
@


1.4
log
@correct handling of the -d option; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.3 2005/05/17 08:16:03 xsa Exp $	*/
d108 1
a108 1
	
@


1.3
log
@basic update code, needs more work; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.2 2005/05/12 23:41:14 xsa Exp $	*/
d132 1
d164 5
d170 3
a172 1
			if (chdir(dpath) == -1)
d174 1
d203 1
d215 7
d223 1
a223 1
				if (unlink(dpath) == -1) {
d225 1
a225 1
				   	    "deletion of directory %s failed",
@


1.2
log
@add CF_KNOWN and CF_NOFILES flags; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: release.c,v 1.1 2005/05/11 15:31:54 xsa Exp $	*/
d41 3
d55 1
a55 1
	CF_KNOWN | CF_NOFILES,
d130 1
d132 2
a133 1
	char cdpath[MAXPATHLEN], dpath[MAXPATHLEN];
d163 16
d180 11
a190 1
			/* XXX run cvs_update() w/out updating files */
d192 2
a193 2
			printf("You have [%d] altered files in "
			    "this repository.\n", j);
@


1.1
log
@start for the `release' command, need more work; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 2
a52 1
	NULL, NULL, NULL,
@

