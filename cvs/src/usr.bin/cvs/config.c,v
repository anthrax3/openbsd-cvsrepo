head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.30
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.28
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.24
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.22
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.20
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.18
	OPENBSD_5_0:1.15.0.16
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.14
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.12
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.8
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.17
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.16;
commitid	O6jeJ0TRmiewrqMI;

1.16
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2008.03.02.11.58.45;	author joris;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.04.19.08.32;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.01.18.10.26;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.09.16.03.25;	author tobias;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.18.12.13.20;	author tobias;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.12.17.54.58;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.25.08.21.08;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.07.08.43.12;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.04.09.51.21;	author xsa;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.28.15.45.31;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.27.21.10.53;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.27.18.04.46;	author joris;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@/*	$OpenBSD: config.c,v 1.16 2015/01/16 06:40:07 deraadt Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/dirent.h>
#include <sys/resource.h>

#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "cvs.h"
#include "config.h"

void
cvs_parse_configfile(void)
{
	cvs_log(LP_TRACE, "cvs_parse_configfile()");
	cvs_read_config(CVS_PATH_CONFIG, config_parse_line);
}

int
config_parse_line(char *line, int lineno)
{
	struct rlimit rl;
	const char *errstr;
	char *val, *opt, *ep;

	opt = line;
	if ((val = strrchr(opt, '=')) == NULL)
		fatal("cvs_parse_configfile: bad option '%s'", opt);

	*(val++) = '\0';

	if (!strcmp(opt, "tag")) {
		free(cvs_tagname);
		cvs_tagname = xstrdup(val);
	} else if (!strcmp(opt, "umask")) {
		cvs_umask = strtol(val, &ep, 8);

		if (val == ep || *ep != '\0')
			fatal("cvs_parse_configfile: umask %s is "
			    "invalid", val);
		if (cvs_umask < 0 || cvs_umask > 07777)
			fatal("cvs_parse_configfile: umask %s is "
			    "invalid", val);
	} else if (!strcmp(opt, "dlimit")) {
		if (getrlimit(RLIMIT_DATA, &rl) != -1) {
			rl.rlim_cur = (int)strtonum(val, 0, INT_MAX,
			    &errstr);
			if (errstr != NULL)
				fatal("cvs_parse_configfile: %s: %s",
				    val, errstr);
			rl.rlim_cur = rl.rlim_cur * 1024;
			(void)setrlimit(RLIMIT_DATA, &rl);
		}
	} else {
		cvs_log(LP_ERR, "ignoring unknown option '%s'", opt);
	}

	return (0);
}

void
cvs_read_config(char *name, int (*cb)(char *, int))
{
	FILE *fp;
	size_t len;
	int lineno;
	char *p, *buf, *lbuf, fpath[PATH_MAX];

	(void)xsnprintf(fpath, sizeof(fpath), "%s/%s",
	    current_cvsroot->cr_dir, name);

	if ((fp = fopen(fpath, "r")) == NULL)
		return;

	lbuf = NULL;
	lineno = 0;
	while ((buf = fgetln(fp, &len)) != NULL) {
		lineno++;
		if (buf[len - 1] == '\n') {
			buf[len - 1] = '\0';
		} else {
			lbuf = xmalloc(len + 1);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		p = buf;
		while (*p == ' ' || *p == '\t')
			p++;

		if (p[0] == '#' || p[0] == '\0')
			continue;

		if (cb(p, lineno) < 0)
			break;
	}

	free(lbuf);
	(void)fclose(fp);
}
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2008/03/02 11:58:45 joris Exp $	*/
d51 1
a51 2
		if (cvs_tagname != NULL)
			xfree(cvs_tagname);
d117 1
a117 3
	if (lbuf != NULL)
		xfree(lbuf);

@


1.15
log
@allow our parsing functions to stop parsing a config file at
any given time.

will come in handy for CVSROOT/loginfo and CVSROOT/commitinfo
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2008/02/04 19:08:32 joris Exp $	*/
d18 1
a18 1
#include <sys/param.h>
d86 1
a86 1
	char *p, *buf, *lbuf, fpath[MAXPATHLEN];
@


1.14
log
@more CVSROOT/modules stuff:

- support for -i flag:
	Run "prog" on "cvs commit" from top-level of module.
- fix some memory leaks in modules.c
- pass the line number from cvs_read_config() towards the callbacks
  so its easier to print out where it's going wrong, if it ever does.

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2008/02/01 18:10:26 joris Exp $	*/
d37 1
a37 1
void
d76 2
d81 1
a81 1
cvs_read_config(char *name, void (*cb)(char *, int))
d114 2
a115 1
		cb(p, lineno);
@


1.13
log
@introduce cvs_read_config() which will be used as a general
handler to open and read configuration files in CVSROOT/

change cvs_parse_configfile() to use cvs_read_config() instead;

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2007/11/09 16:03:25 tobias Exp $	*/
d38 1
a38 1
config_parse_line(char *line)
d79 1
a79 1
cvs_read_config(char *name, void (*cb)(char *))
d83 1
d93 1
d95 1
d112 1
a112 1
		cb(p);
@


1.12
log
@An umask is octet not decimal. This means we cannot use strtonum() to
parse it due to base 10. Instead strtol() with base 8 must be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2007/10/18 12:13:20 tobias Exp $	*/
d33 48
d83 1
a83 3
	struct rlimit rl;
	const char *errstr;
	char *p, *buf, *ep, *lbuf, *opt, *val, fpath[MAXPATHLEN];
d86 1
a86 1
	    current_cvsroot->cr_dir, CVS_PATH_CONFIG);
d88 1
a88 5
	cvs_log(LP_TRACE, "cvs_parse_configfile(%s)", fpath);

	if ((fp = fopen(fpath, "r")) == NULL) {
		if (errno != ENOENT)
			cvs_log(LP_ERRNO, "%s", CVS_PATH_CONFIG);
a89 1
	}
d92 1
a92 1
	while ((buf = fgetln(fp, &len))) {
d103 1
a103 1
		while (*p == ' ')
d106 1
a106 3
		if (p[0] == '#' || p[0] == '\0') {
			if (lbuf != NULL)
				xfree(lbuf);
a107 1
		}
d109 2
a110 32
		opt = p;
		if ((val = strrchr(opt, '=')) == NULL)
			fatal("cvs_parse_configfile: bad option '%s'", opt);

		*(val++) = '\0';

		if (!strcmp(opt, "tag")) {
			if (cvs_tagname != NULL)
				xfree(cvs_tagname);
			cvs_tagname = xstrdup(val);
		} else if (!strcmp(opt, "umask")) {
			cvs_umask = strtol(val, &ep, 8);

			if (val == ep || *ep != '\0')
				fatal("cvs_parse_configfile: umask %s is "
				    "invalid", val);
			if (cvs_umask < 0 || cvs_umask > 07777)
				fatal("cvs_parse_configfile: umask %s is "
				    "invalid", val);
		} else if (!strcmp(opt, "dlimit")) {
			if (getrlimit(RLIMIT_DATA, &rl) != -1) {
				rl.rlim_cur = (int)strtonum(val, 0, INT_MAX,
				    &errstr);
				if (errstr != NULL)
					fatal("cvs_parse_configfile: %s: %s",
					    val, errstr);
				rl.rlim_cur = rl.rlim_cur * 1024;
				(void)setrlimit(RLIMIT_DATA, &rl);
			}
		} else {
			cvs_log(LP_ERR, "ignoring unknown option '%s'", opt);
		}
d112 2
a113 3
		if (lbuf != NULL)
			xfree(lbuf);
	}
@


1.11
log
@Avoid memory leak if tag is defined multiple times in CVSROOT/config.

OK ray@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2007/07/12 17:54:58 xsa Exp $	*/
d23 1
d37 1
a37 1
	char *p, *buf, *lbuf, *opt, *val, fpath[MAXPATHLEN];
d82 8
a89 4
			cvs_umask = (int)strtonum(val, 0, INT_MAX, &errstr);
			if (errstr != NULL)
				fatal("cvs_parse_configfile: %s: %s", val,
				    errstr);
@


1.10
log
@Do not fatal() if the CVSROOT/config file does not exist.
Matches GNU's behaviour. OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2007/02/22 06:42:09 otto Exp $	*/
d77 2
@


1.9
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2007/02/17 18:23:43 xsa Exp $	*/
d43 5
a47 3
	if ((fp = fopen(fpath, "r")) == NULL)
		fatal("cvs_config_parse: %s: %s",
		    CVS_PATH_CONFIG, strerror(errno));
@


1.8
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2007/01/25 08:21:08 otto Exp $	*/
d18 7
a24 1
#include "includes.h"
a27 2
#include "diff.h"
#include "log.h"
@


1.7
log
@do not use strlcpuy on a buffer filled by fgetln, since fgetln does
not NUL-terminate. ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2006/12/07 08:43:12 xsa Exp $	*/
d34 2
a35 3
	if (cvs_path_cat(current_cvsroot->cr_dir, CVS_PATH_CONFIG,
	    fpath, sizeof(fpath)) >= sizeof(fpath))
		fatal("cvs_parse_configfile: truncation");
@


1.6
log
@add config file path in debug message.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2006/12/04 09:51:21 xsa Exp $	*/
d50 2
a51 1
			strlcpy(lbuf, buf, len);
@


1.5
log
@snprintf() -> cvs_path_cat()
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2006/06/16 14:07:42 joris Exp $	*/
a33 2
	cvs_log(LP_TRACE, "cvs_parse_configfile()");

d37 2
@


1.4
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2006/05/28 15:45:31 joris Exp $	*/
a27 1
	int i;
d36 3
a38 4
	i = snprintf(fpath, sizeof(fpath), "%s/%s", current_cvsroot->cr_dir,
	    CVS_PATH_CONFIG);
	if (i == -1 || i >= (int)sizeof(fpath))
		fatal("cvs_parse_configfile: overflow");
@


1.3
log
@teach opencvs about the dlimit keyword in CVSROOT/config.
put some trace messages in place while im here.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2006/05/27 21:10:53 joris Exp $	*/
a23 1
#include "proto.h"
@


1.2
log
@handle comments and leading spaces correctly
in CVSROOT/config
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.1 2006/05/27 18:04:46 joris Exp $	*/
d32 1
d36 2
d80 10
@


1.1
log
@basic support for CVSROOT/config - only supporting the 'tag' and
'umask' keyword right now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
	char *buf, *lbuf, *opt, *val, fpath[MAXPATHLEN];
d54 11
a64 1
		opt = buf;
@

