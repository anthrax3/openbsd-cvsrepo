head	1.105;
access;
symbols
	OPENBSD_6_1:1.104.0.8
	OPENBSD_6_1_BASE:1.104
	OPENBSD_6_0:1.104.0.4
	OPENBSD_6_0_BASE:1.104
	OPENBSD_5_9:1.104.0.2
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.102.0.6
	OPENBSD_5_8_BASE:1.102
	OPENBSD_5_7:1.102.0.2
	OPENBSD_5_7_BASE:1.102
	OPENBSD_5_6:1.100.0.20
	OPENBSD_5_6_BASE:1.100
	OPENBSD_5_5:1.100.0.18
	OPENBSD_5_5_BASE:1.100
	OPENBSD_5_4:1.100.0.14
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.100.0.12
	OPENBSD_5_3_BASE:1.100
	OPENBSD_5_2:1.100.0.10
	OPENBSD_5_2_BASE:1.100
	OPENBSD_5_1_BASE:1.100
	OPENBSD_5_1:1.100.0.8
	OPENBSD_5_0:1.100.0.6
	OPENBSD_5_0_BASE:1.100
	OPENBSD_4_9:1.100.0.4
	OPENBSD_4_9_BASE:1.100
	OPENBSD_4_8:1.100.0.2
	OPENBSD_4_8_BASE:1.100
	OPENBSD_4_7:1.99.0.2
	OPENBSD_4_7_BASE:1.99
	OPENBSD_4_6:1.99.0.4
	OPENBSD_4_6_BASE:1.99
	OPENBSD_4_5:1.93.0.2
	OPENBSD_4_5_BASE:1.93
	OPENBSD_4_4:1.92.0.2
	OPENBSD_4_4_BASE:1.92
	OPENBSD_4_3:1.84.0.2
	OPENBSD_4_3_BASE:1.84
	OPENBSD_4_2:1.65.0.2
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.55.0.2
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.0.1;
locks; strict;
comment	@ * @;


1.105
date	2017.08.28.19.33.20;	author otto;	state Exp;
branches;
next	1.104;
commitid	pt4iCZKa4LhAa1TL;

1.104
date	2015.12.09.17.55.42;	author mmcc;	state Exp;
branches;
next	1.103;
commitid	nwkkB0Qgo34HsyMP;

1.103
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.102;
commitid	O6jeJ0TRmiewrqMI;

1.102
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.101;
commitid	Uu5nFG3wCl0LACBb;

1.101
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	Z3HC5pAWzpo5jsTe;

1.100
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.99;

1.99
date	2009.04.18.16.26.01;	author joris;	state Exp;
branches;
next	1.98;

1.98
date	2009.04.10.11.26.10;	author joris;	state Exp;
branches;
next	1.97;

1.97
date	2009.04.04.11.32.48;	author joris;	state Exp;
branches;
next	1.96;

1.96
date	2009.04.04.11.29.57;	author joris;	state Exp;
branches;
next	1.95;

1.95
date	2009.03.19.09.56.03;	author joris;	state Exp;
branches;
next	1.94;

1.94
date	2009.03.19.09.53.16;	author joris;	state Exp;
branches;
next	1.93;

1.93
date	2009.02.21.13.39.01;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2008.07.08.12.54.13;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.12.07.16.14;	author joris;	state Exp;
branches;
next	1.89;

1.89
date	2008.06.10.05.01.36;	author tobias;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.28.17.12.00;	author tobias;	state Exp;
branches;
next	1.87;

1.87
date	2008.05.06.10.37.30;	author tobias;	state Exp;
branches;
next	1.86;

1.86
date	2008.04.24.19.13.56;	author tobias;	state Exp;
branches;
next	1.85;

1.85
date	2008.04.18.20.26.07;	author tobias;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.83;

1.83
date	2008.02.09.20.04.00;	author xsa;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.03.18.18.44;	author tobias;	state Exp;
branches;
next	1.81;

1.81
date	2008.02.03.17.20.14;	author joris;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.01.17.18.59;	author tobias;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.31.22.09.05;	author xsa;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.29.12.01.52;	author tobias;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.21.16.36.46;	author tobias;	state Exp;
branches;
next	1.75;

1.75
date	2008.01.10.11.20.29;	author tobias;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.10.09.59.23;	author tobias;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.09.16.27.38;	author tobias;	state Exp;
branches;
next	1.72;

1.72
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.22.15.57.24;	author joris;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.07.19.18.41;	author tobias;	state Exp;
branches;
next	1.69;

1.69
date	2007.09.02.12.16.24;	author tobias;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.02.12.13.00;	author tobias;	state Exp;
branches;
next	1.67;

1.67
date	2007.08.28.19.10.18;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2007.08.23.13.17.53;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2007.07.03.13.22.43;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.29.12.42.05;	author xsa;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.27.20.42.19;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.26.02.24.10;	author niallo;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.06.00.38.37;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.27.00.06.42;	author ray;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.26.23.52.04;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.26.23.19.31;	author ray;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.25.22.27.02;	author ray;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.25.21.58.00;	author ray;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.31.21.07.36;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2007.01.26.11.19.44;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.18.16.45.52;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.17.17.54.50;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2007.01.13.15.29.34;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2007.01.03.22.28.30;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.19.14.11.21;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2006.12.19.11.46.39;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.15.13.12.14;	author xsa;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.15.09.50.37;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2006.12.15.08.02.53;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2006.12.04.09.51.21;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.27.16.04.10;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.14.15.39.42;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.14.14.45.31;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.14.09.59.54;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.14.09.47.52;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.13.12.57.03;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.09.14.00.14;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.09.10.08.33;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.09.09.24.28;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.31.15.23.40;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.09.01.47.20;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.27.03.30.31;	author joris;	state dead;
branches;
next	1.27;

1.27
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.24.19.07.52;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.20.16.55.21;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.14.13.46.36;	author moritz;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.14.19.49.18;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.10.14.49.20;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.08.14.28.59;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.27.10.36.14;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.23.10.59.47;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.18.21.39.25;	author alek;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.18.20.24.19;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.01.09.52.39;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.31.17.18.24;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.28.23.08.24;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.02.17.35.37;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.30.23.12.12;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.29.18.23.25;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.28.02.02.50;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.105
log
@fix const related warnings; ok millert@@
@
text
@/*	$OpenBSD: server.c,v 1.104 2015/12/09 17:55:42 mmcc Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

struct cvs_resp cvs_responses[] = {
	/* this is what our server uses, the client should support it */
	{ "Valid-requests",	1,	cvs_client_validreq, RESP_NEEDED },
	{ "ok",			0,	cvs_client_ok, RESP_NEEDED},
	{ "error",		0,	cvs_client_error, RESP_NEEDED },
	{ "E",			0,	cvs_client_e, RESP_NEEDED },
	{ "M",			0,	cvs_client_m, RESP_NEEDED },
	{ "Checked-in",		0,	cvs_client_checkedin, RESP_NEEDED },
	{ "Updated",		0,	cvs_client_updated, RESP_NEEDED },
	{ "Merged",		0,	cvs_client_merged, RESP_NEEDED },
	{ "Removed",		0,	cvs_client_removed, RESP_NEEDED },
	{ "Remove-entry",	0,	cvs_client_remove_entry, 0 },
	{ "Set-static-directory",	0,
	    cvs_client_set_static_directory, 0 },
	{ "Clear-static-directory",	0,
	    cvs_client_clear_static_directory, 0 },
	{ "Set-sticky",		0,	cvs_client_set_sticky, 0 },
	{ "Clear-sticky",	0,	cvs_client_clear_sticky, 0 },

	/* unsupported responses until told otherwise */
	{ "New-entry",			0,	NULL, 0 },
	{ "Created",			0,	NULL, 0 },
	{ "Update-existing",		0,	NULL, 0 },
	{ "Rcs-diff",			0,	NULL, 0 },
	{ "Patched",			0,	NULL, 0 },
	{ "Mode",			0,	NULL, 0 },
	{ "Mod-time",			0,	NULL, 0 },
	{ "Checksum",			0,	NULL, 0 },
	{ "Copy-file",			0,	NULL, 0 },
	{ "Template",			0,	NULL, 0 },
	{ "Set-checkin-prog",		0,	NULL, 0 },
	{ "Set-update-prog",		0,	NULL, 0 },
	{ "Notified",			0,	NULL, 0 },
	{ "Module-expansion",		0,	NULL, 0 },
	{ "Wrapper-rcsOption",		0,	NULL, 0 },
	{ "Mbinary",			0,	NULL, 0 },
	{ "F",				0,	NULL, 0 },
	{ "MT",				0,	NULL, 0 },
	{ "",				-1,	NULL, 0 }
};

int	cvs_server(int, char **);
char	*cvs_server_path = NULL;

static char *server_currentdir = NULL;
static char **server_argv;
static int server_argc = 1;

extern int disable_fast_checkout;

struct cvs_cmd cvs_cmd_server = {
	CVS_OP_SERVER, CVS_USE_WDIR, "server", { "", "" },
	"server mode",
	NULL,
	NULL,
	NULL,
	cvs_server
};


int
cvs_server(int argc, char **argv)
{
	char *cmd, *data;
	struct cvs_req *req;

	if (argc > 1)
		fatal("server does not take any extra arguments");

	/* Be on server-side very verbose per default. */
	verbosity = 2;

	setvbuf(stdin, NULL, _IOLBF, 0);
	setvbuf(stdout, NULL, _IOLBF, 0);

	cvs_server_active = 1;

	server_argv = xcalloc(server_argc + 1, sizeof(*server_argv));
	server_argv[0] = xstrdup("server");

	(void)xasprintf(&cvs_server_path, "%s/cvs-serv%d", cvs_tmpdir,
	    getpid());

	if (mkdir(cvs_server_path, 0700) == -1)
		fatal("failed to create temporary server directory: %s, %s",
		    cvs_server_path, strerror(errno));

	if (chdir(cvs_server_path) == -1)
		fatal("failed to change directory to '%s'", cvs_server_path);

	for (;;) {
		cmd = cvs_remote_input();

		if ((data = strchr(cmd, ' ')) != NULL)
			(*data++) = '\0';

		req = cvs_remote_get_request_info(cmd);
		if (req == NULL)
			fatal("request '%s' is not supported by our server",
			    cmd);

		if (req->hdlr == NULL)
			fatal("opencvs server does not support '%s'", cmd);

		if ((req->flags & REQ_NEEDDIR) && (server_currentdir == NULL))
			fatal("`%s' needs a directory to be sent with "
			    "the `Directory` request first", cmd);

		(*req->hdlr)(data);
		free(cmd);
	}

	return (0);
}

void
cvs_server_send_response(char *fmt, ...)
{
	int i;
	va_list ap;
	char *data;

	va_start(ap, fmt);
	i = vasprintf(&data, fmt, ap);
	va_end(ap);
	if (i == -1)
		fatal("cvs_server_send_response: could not allocate memory");

	cvs_log(LP_TRACE, "%s", data);
	cvs_remote_output(data);
	free(data);
}

void
cvs_server_root(char *data)
{
	if (data == NULL)
		fatal("Missing argument for Root");

	if (current_cvsroot != NULL)
		return;

	if (data[0] != '/' || (current_cvsroot = cvsroot_get(data)) == NULL)
		fatal("Invalid Root specified!");

	cvs_parse_configfile();
	cvs_parse_modules();
	umask(cvs_umask);
}

void
cvs_server_validresp(char *data)
{
	int i;
	char *sp, *ep;
	struct cvs_resp *resp;

	if ((sp = data) == NULL)
		fatal("Missing argument for Valid-responses");

	do {
		if ((ep = strchr(sp, ' ')) != NULL)
			*ep = '\0';

		resp = cvs_remote_get_response_info(sp);
		if (resp != NULL)
			resp->supported = 1;

		if (ep != NULL)
			sp = ep + 1;
	} while (ep != NULL);

	for (i = 0; cvs_responses[i].supported != -1; i++) {
		resp = &cvs_responses[i];
		if ((resp->flags & RESP_NEEDED) &&
		    resp->supported != 1) {
			fatal("client does not support required '%s'",
			    resp->name);
		}
	}
}

void
cvs_server_validreq(char *data)
{
	BUF *bp;
	char *d;
	int i, first;

	first = 0;
	bp = buf_alloc(512);
	for (i = 0; cvs_requests[i].supported != -1; i++) {
		if (cvs_requests[i].hdlr == NULL)
			continue;

		if (first != 0)
			buf_putc(bp, ' ');
		else
			first++;

		buf_puts(bp, cvs_requests[i].name);
	}

	buf_putc(bp, '\0');
	d = buf_release(bp);

	cvs_server_send_response("Valid-requests %s", d);
	cvs_server_send_response("ok");
	free(d);
}

void
cvs_server_static_directory(char *data)
{
	FILE *fp;
	char fpath[PATH_MAX];

	(void)xsnprintf(fpath, PATH_MAX, "%s/%s",
	    server_currentdir, CVS_PATH_STATICENTRIES);

	if ((fp = fopen(fpath, "w+")) == NULL) {
		cvs_log(LP_ERRNO, "%s", fpath);
		return;
	}
	(void)fclose(fp);
}

void
cvs_server_sticky(char *data)
{
	FILE *fp;
	char tagpath[PATH_MAX];

	if (data == NULL)
		fatal("Missing argument for Sticky");

	(void)xsnprintf(tagpath, PATH_MAX, "%s/%s",
	    server_currentdir, CVS_PATH_TAG);

	if ((fp = fopen(tagpath, "w+")) == NULL) {
		cvs_log(LP_ERRNO, "%s", tagpath);
		return;
	}

	(void)fprintf(fp, "%s\n", data);
	(void)fclose(fp);
}

void
cvs_server_globalopt(char *data)
{
	if (data == NULL)
		fatal("Missing argument for Global_option");

	if (!strcmp(data, "-l"))
		cvs_nolog = 1;

	if (!strcmp(data, "-n"))
		cvs_noexec = 1;

	if (!strcmp(data, "-Q"))
		verbosity = 0;

	if (!strcmp(data, "-q"))
		verbosity = 1;

	if (!strcmp(data, "-r"))
		cvs_readonly = 1;

	if (!strcmp(data, "-t"))
		cvs_trace = 1;
}

void
cvs_server_set(char *data)
{
	char *ep;

	if (data == NULL)
		fatal("Missing argument for Set");

	ep = strchr(data, '=');
	if (ep == NULL)
		fatal("no = in variable assignment");

	*(ep++) = '\0';
	if (cvs_var_set(data, ep) < 0)
		fatal("cvs_server_set: cvs_var_set failed");
}

void
cvs_server_directory(char *data)
{
	CVSENTRIES *entlist;
	char *dir, *repo, *parent, *entry, *dirn, *p;

	if (current_cvsroot == NULL)
		fatal("No Root specified for Directory");

	dir = cvs_remote_input();
	STRIP_SLASH(dir);

	if (strlen(dir) < strlen(current_cvsroot->cr_dir))
		fatal("cvs_server_directory: bad Directory request");

	repo = dir + strlen(current_cvsroot->cr_dir);

	/*
	 * This is somewhat required for checkout, as the
	 * directory request will be:
	 *
	 * Directory .
	 * /path/to/cvs/root
	 */
	if (repo[0] == '\0')
		p = xstrdup(".");
	else
		p = xstrdup(repo + 1);

	cvs_mkpath(p, NULL);

	if ((dirn = basename(p)) == NULL)
		fatal("cvs_server_directory: %s", strerror(errno));

	if ((parent = dirname(p)) == NULL)
		fatal("cvs_server_directory: %s", strerror(errno));

	if (strcmp(parent, ".")) {
		entry = xmalloc(CVS_ENT_MAXLINELEN);
		cvs_ent_line_str(dirn, NULL, NULL, NULL, NULL, 1, 0,
		    entry, CVS_ENT_MAXLINELEN);

		entlist = cvs_ent_open(parent);
		cvs_ent_add(entlist, entry);
		free(entry);
	}

	free(server_currentdir);
	server_currentdir = p;

	free(dir);
}

void
cvs_server_entry(char *data)
{
	CVSENTRIES *entlist;

	if (data == NULL)
		fatal("Missing argument for Entry");

	entlist = cvs_ent_open(server_currentdir);
	cvs_ent_add(entlist, data);
}

void
cvs_server_modified(char *data)
{
	int fd;
	size_t flen;
	mode_t fmode;
	const char *errstr;
	char *mode, *len, fpath[PATH_MAX];

	if (data == NULL)
		fatal("Missing argument for Modified");

	/* sorry, we have to use TMP_DIR */
	disable_fast_checkout = 1;

	mode = cvs_remote_input();
	len = cvs_remote_input();

	cvs_strtomode(mode, &fmode);
	free(mode);

	flen = strtonum(len, 0, INT_MAX, &errstr);
	if (errstr != NULL)
		fatal("cvs_server_modified: %s", errstr);
	free(len);

	(void)xsnprintf(fpath, PATH_MAX, "%s/%s", server_currentdir, data);

	if ((fd = open(fpath, O_WRONLY | O_CREAT | O_TRUNC)) == -1)
		fatal("cvs_server_modified: %s: %s", fpath, strerror(errno));

	cvs_remote_receive_file(fd, flen);

	if (fchmod(fd, 0600) == -1)
		fatal("cvs_server_modified: failed to set file mode");

	(void)close(fd);
}

void
cvs_server_useunchanged(char *data)
{
}

void
cvs_server_unchanged(char *data)
{
	char fpath[PATH_MAX];
	CVSENTRIES *entlist;
	struct cvs_ent *ent;
	char sticky[CVS_ENT_MAXLINELEN];
	char rev[CVS_REV_BUFSZ], entry[CVS_ENT_MAXLINELEN];

	if (data == NULL)
		fatal("Missing argument for Unchanged");

	/* sorry, we have to use TMP_DIR */
	disable_fast_checkout = 1;

	(void)xsnprintf(fpath, PATH_MAX, "%s/%s", server_currentdir, data);

	entlist = cvs_ent_open(server_currentdir);
	ent = cvs_ent_get(entlist, data);
	if (ent == NULL)
		fatal("received Unchanged request for non-existing file");

	sticky[0] = '\0';
	if (ent->ce_tag != NULL)
		(void)xsnprintf(sticky, sizeof(sticky), "T%s", ent->ce_tag);

	rcsnum_tostr(ent->ce_rev, rev, sizeof(rev));
	(void)xsnprintf(entry, sizeof(entry), "/%s/%s/%s/%s/%s",
	    ent->ce_name, rev, CVS_SERVER_UNCHANGED, ent->ce_opts ?
	    ent->ce_opts : "", sticky);

	cvs_ent_free(ent);
	cvs_ent_add(entlist, entry);
}

void
cvs_server_questionable(char *data)
{
	CVSENTRIES *entlist;
	char entry[CVS_ENT_MAXLINELEN];

	if (data == NULL)
		fatal("Questionable request with no data attached");

	(void)xsnprintf(entry, sizeof(entry), "/%s/%c///", data,
	    CVS_SERVER_QUESTIONABLE);

	entlist = cvs_ent_open(server_currentdir);
	cvs_ent_add(entlist, entry);

	/* sorry, we have to use TMP_DIR */
	disable_fast_checkout = 1;
}

void
cvs_server_argument(char *data)
{
	if (data == NULL)
		fatal("Missing argument for Argument");

	server_argv = xreallocarray(server_argv, server_argc + 2,
	    sizeof(*server_argv));
	server_argv[server_argc] = xstrdup(data);
	server_argv[++server_argc] = NULL;
}

void
cvs_server_argumentx(char *data)
{
	int idx;
	size_t len;

	if (server_argc == 1)
		fatal("Protocol Error: ArgumentX without previous argument");

	idx = server_argc - 1;

	len = strlen(server_argv[idx]) + strlen(data) + 2;
	server_argv[idx] = xreallocarray(server_argv[idx], len, sizeof(char));
	strlcat(server_argv[idx], "\n", len);
	strlcat(server_argv[idx], data, len);
}

void
cvs_server_update_patches(char *data)
{
	/*
	 * This does not actually do anything.
	 * It is used to tell that the server is able to
	 * generate patches when given an `update' request.
	 * The client must issue the -u argument to `update'
	 * to receive patches.
	 */
}

void
cvs_server_add(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_add: %s", strerror(errno));

	cvs_cmdop = CVS_OP_ADD;
	cmdp->cmd_flags = cvs_cmd_add.cmd_flags;
	cvs_add(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_import(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_import: %s", strerror(errno));

	cvs_cmdop = CVS_OP_IMPORT;
	cmdp->cmd_flags = cvs_cmd_import.cmd_flags;
	cvs_import(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_admin(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_admin: %s", strerror(errno));

	cvs_cmdop = CVS_OP_ADMIN;
	cmdp->cmd_flags = cvs_cmd_admin.cmd_flags;
	cvs_admin(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_annotate(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_annotate: %s", strerror(errno));

	cvs_cmdop = CVS_OP_ANNOTATE;
	cmdp->cmd_flags = cvs_cmd_annotate.cmd_flags;
	cvs_annotate(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_rannotate(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_rannotate: %s", strerror(errno));

	cvs_cmdop = CVS_OP_RANNOTATE;
	cmdp->cmd_flags = cvs_cmd_rannotate.cmd_flags;
	cvs_annotate(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_commit(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_commit: %s", strerror(errno));

	cvs_cmdop = CVS_OP_COMMIT;
	cmdp->cmd_flags = cvs_cmd_commit.cmd_flags;
	cvs_commit(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_checkout(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_checkout: %s", strerror(errno));

	cvs_cmdop = CVS_OP_CHECKOUT;
	cmdp->cmd_flags = cvs_cmd_checkout.cmd_flags;
	cvs_checkout(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_diff(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_diff: %s", strerror(errno));

	cvs_cmdop = CVS_OP_DIFF;
	cmdp->cmd_flags = cvs_cmd_diff.cmd_flags;
	cvs_diff(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_rdiff(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_rdiff: %s", strerror(errno));

	cvs_cmdop = CVS_OP_RDIFF;
	cmdp->cmd_flags = cvs_cmd_rdiff.cmd_flags;
	cvs_diff(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_export(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_export: %s", strerror(errno));

	cvs_cmdop = CVS_OP_EXPORT;
	cmdp->cmd_flags = cvs_cmd_export.cmd_flags;
	cvs_export(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_init(char *data)
{
	if (data == NULL)
		fatal("Missing argument for init");

	if (current_cvsroot != NULL)
		fatal("Root in combination with init is not supported");

	if ((current_cvsroot = cvsroot_get(data)) == NULL)
		fatal("Invalid argument for init");

	cvs_cmdop = CVS_OP_INIT;
	cmdp->cmd_flags = cvs_cmd_init.cmd_flags;
	cvs_init(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_release(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_release: %s", strerror(errno));

	cvs_cmdop = CVS_OP_RELEASE;
	cmdp->cmd_flags = cvs_cmd_release.cmd_flags;
	cvs_release(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_remove(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_remove: %s", strerror(errno));

	cvs_cmdop = CVS_OP_REMOVE;
	cmdp->cmd_flags = cvs_cmd_remove.cmd_flags;
	cvs_remove(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_status(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_status: %s", strerror(errno));

	cvs_cmdop = CVS_OP_STATUS;
	cmdp->cmd_flags = cvs_cmd_status.cmd_flags;
	cvs_status(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_log(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_log: %s", strerror(errno));

	cvs_cmdop = CVS_OP_LOG;
	cmdp->cmd_flags = cvs_cmd_log.cmd_flags;
	cvs_getlog(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_rlog(char *data)
{
	if (chdir(current_cvsroot->cr_dir) == -1)
		fatal("cvs_server_rlog: %s", strerror(errno));

	cvs_cmdop = CVS_OP_RLOG;
	cmdp->cmd_flags = cvs_cmd_rlog.cmd_flags;
	cvs_getlog(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_tag(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_tag: %s", strerror(errno));

	cvs_cmdop = CVS_OP_TAG;
	cmdp->cmd_flags = cvs_cmd_tag.cmd_flags;
	cvs_tag(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_rtag(char *data)
{
	if (chdir(current_cvsroot->cr_dir) == -1)
		fatal("cvs_server_rtag: %s", strerror(errno));

	cvs_cmdop = CVS_OP_RTAG;
	cmdp->cmd_flags = cvs_cmd_rtag.cmd_flags;
	cvs_tag(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_update(char *data)
{
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_update: %s", strerror(errno));

	cvs_cmdop = CVS_OP_UPDATE;
	cmdp->cmd_flags = cvs_cmd_update.cmd_flags;
	cvs_update(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_version(char *data)
{
	cvs_cmdop = CVS_OP_VERSION;
	cmdp->cmd_flags = cvs_cmd_version.cmd_flags;
	cvs_version(server_argc, server_argv);
	cvs_server_send_response("ok");
}

void
cvs_server_update_entry(const char *resp, struct cvs_file *cf)
{
	char *p;
	char repo[PATH_MAX], fpath[PATH_MAX];

	if ((p = strrchr(cf->file_rpath, ',')) != NULL)
		*p = '\0';

	cvs_get_repository_path(cf->file_wd, repo, PATH_MAX);
	(void)xsnprintf(fpath, PATH_MAX, "%s/%s", repo, cf->file_name);

	cvs_server_send_response("%s %s/", resp, cf->file_wd);
	cvs_remote_output(fpath);

	if (p != NULL)
		*p = ',';
}

void
cvs_server_set_sticky(const char *dir, char *tag)
{
	char fpath[PATH_MAX];
	char repo[PATH_MAX];

	cvs_get_repository_path(dir, repo, PATH_MAX);
	(void)xsnprintf(fpath, PATH_MAX, "%s/", repo);

	cvs_server_send_response("Set-sticky %s/", dir);
	cvs_remote_output(fpath);
	cvs_remote_output(tag);
}

void
cvs_server_clear_sticky(char *dir)
{
	char fpath[PATH_MAX];
	char repo[PATH_MAX];

	cvs_get_repository_path(dir, repo, PATH_MAX);
	(void)xsnprintf(fpath, PATH_MAX, "%s/", repo);

	cvs_server_send_response("Clear-sticky %s//", dir);
	cvs_remote_output(fpath);
}

void
cvs_server_exp_modules(char *module)
{
	struct module_checkout *mo;
	struct cvs_filelist *fl;

	if (server_argc != 2)
		fatal("expand-modules with no arguments");

	mo = cvs_module_lookup(server_argv[1]);

	RB_FOREACH(fl, cvs_flisthead, &(mo->mc_modules))
		cvs_server_send_response("Module-expansion %s", fl->file_path);
	cvs_server_send_response("ok");

	server_argc--;
	free(server_argv[1]);
	server_argv[1] = NULL;
}
@


1.104
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.103 2015/11/05 09:48:21 nicm Exp $	*/
d789 1
a789 1
cvs_server_set_sticky(const char *dir, const char *tag)
@


1.103
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.102 2015/01/16 06:40:07 deraadt Exp $	*/
d369 1
a369 2
	if (server_currentdir != NULL)
		free(server_currentdir);
@


1.102
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.101 2014/12/01 21:58:46 deraadt Exp $	*/
d141 1
a141 1
		xfree(cmd);
d162 1
a162 1
	xfree(data);
d240 1
a240 1
	xfree(d);
d366 1
a366 1
		xfree(entry);
d370 1
a370 1
		xfree(server_currentdir);
d373 1
a373 1
	xfree(dir);
d407 1
a407 1
	xfree(mode);
d412 1
a412 1
	xfree(len);
d832 1
a832 1
	xfree(server_argv[1]);
@


1.101
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.100 2010/07/23 21:46:05 ray Exp $	*/
d247 1
a247 1
	char fpath[MAXPATHLEN];
d249 1
a249 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
d263 1
a263 1
	char tagpath[MAXPATHLEN];
d268 1
a268 1
	(void)xsnprintf(tagpath, MAXPATHLEN, "%s/%s",
d395 1
a395 1
	char *mode, *len, fpath[MAXPATHLEN];
d414 1
a414 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", server_currentdir, data);
d435 1
a435 1
	char fpath[MAXPATHLEN];
d447 1
a447 1
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", server_currentdir, data);
d774 1
a774 1
	char repo[MAXPATHLEN], fpath[MAXPATHLEN];
d779 2
a780 2
	cvs_get_repository_path(cf->file_wd, repo, MAXPATHLEN);
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s", repo, cf->file_name);
d792 2
a793 2
	char fpath[MAXPATHLEN];
	char repo[MAXPATHLEN];
d795 2
a796 2
	cvs_get_repository_path(dir, repo, MAXPATHLEN);
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/", repo);
d806 2
a807 2
	char fpath[MAXPATHLEN];
	char repo[MAXPATHLEN];
d809 2
a810 2
	cvs_get_repository_path(dir, repo, MAXPATHLEN);
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/", repo);
@


1.100
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.99 2009/04/18 16:26:01 joris Exp $	*/
d492 1
a492 1
	server_argv = xrealloc(server_argv, server_argc + 2,
d510 1
a510 1
	server_argv[idx] = xrealloc(server_argv[idx], len, sizeof(char));
@


1.99
log
@bleh, do not force the client to support certain responses.
this fixes annotate on our cvsweb. the cvsweb script does very
funky things in order to get the job done, but hey we should support it.
i'm shocked nobody noticed annotate wasnt working, djees.

found by jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.98 2009/04/10 11:26:10 joris Exp $	*/
d222 1
a222 1
	bp = cvs_buf_alloc(512);
d228 1
a228 1
			cvs_buf_putc(bp, ' ');
d232 1
a232 1
		cvs_buf_puts(bp, cvs_requests[i].name);
d235 2
a236 2
	cvs_buf_putc(bp, '\0');
	d = cvs_buf_release(bp);
@


1.98
log
@with the recent module-expand changes, we need to use
the correct repository path in Set-sticky and Clear-sticky
otherwise we'll end up with stuff like src/bin/ls/src/bin/ls
in CVS/Repository which pretty much breaks.

noticed & ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.97 2009/04/04 11:32:48 joris Exp $	*/
d43 7
a49 5
	{ "Remove-entry",	0,	cvs_client_remove_entry, RESP_NEEDED },
	{ "Set-static-directory",	0,	cvs_client_set_static_directory, RESP_NEEDED },
	{ "Clear-static-directory",	0,	cvs_client_clear_static_directory, RESP_NEEDED },
	{ "Set-sticky",		0,	cvs_client_set_sticky, RESP_NEEDED },
	{ "Clear-sticky",	0,	cvs_client_clear_sticky, RESP_NEEDED },
@


1.97
log
@don't try to free stuff we shouldnt free, really.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.96 2009/04/04 11:29:57 joris Exp $	*/
d794 1
a794 6
	if (module_repo_root != NULL) {
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s/%s",
		    current_cvsroot->cr_dir, module_repo_root, repo);
	} else {
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/", repo);
	}
d808 1
a808 6
	if (module_repo_root != NULL) {
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s/%s",
		    current_cvsroot->cr_dir, module_repo_root, repo);
	} else {
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/", repo);
	}
@


1.96
log
@properly expand modules if requested by the client,
this option is needed so gnu cvs clients can play along
properly when running checkout <module> in a remote setup.

if we do not support this, gnu cvs refuses to send us any
existing files already on disk and opencvs will consider everything
as NEEDS_CHECKOUT, instead of running an update on existing stuff.

problem noticed by fgsch@@
commited with opencvs, but please everybody else
do not use opencvs to commit yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.95 2009/03/19 09:56:03 joris Exp $	*/
a837 5

	if (mo->mc_canfree == 1) {
		xfree(mo->mc_name);
		xfree(mo);
	}
@


1.95
log
@kill unused vars
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.94 2009/03/19 09:53:16 joris Exp $	*/
d822 25
@


1.94
log
@properly register Questionable files using CVS/Entries server-side
in order for them to show up as "? foobar" when opencvs is in server mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.93 2009/02/21 13:39:01 joris Exp $	*/
a467 1
	int fd;
a468 1
	struct cvs_ent *ent;
@


1.93
log
@correct Set-sticky and Clear-sticky responses to
include the right repository path.

we messed up some cvs implementations by
doing this incorrectly.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.92 2008/07/08 12:54:13 joris Exp $	*/
d468 14
@


1.92
log
@make these compile cleanly
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.91 2008/06/14 03:19:15 joris Exp $	*/
d779 1
d781 1
d784 1
a784 1
		    current_cvsroot->cr_dir, module_repo_root, dir);
d786 1
a786 2
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
		    current_cvsroot->cr_dir, dir);
d789 1
a789 1
	cvs_server_send_response("Set-sticky %s", dir);
d798 1
d800 1
d803 1
a803 1
		    current_cvsroot->cr_dir, module_repo_root, dir);
d805 1
a805 2
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
		    current_cvsroot->cr_dir, dir);
d808 1
a808 1
	cvs_server_send_response("Clear-sticky %s", dir);
@


1.91
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.90 2008/06/12 07:16:14 joris Exp $	*/
d776 1
a776 1
cvs_server_set_sticky(char *dir, char *tag)
@


1.90
log
@completely kill the need for TMP_DIR when running checkout,
which gives us better performance among other things.

this is however disabled in a few cases:
1) whenever you run checkout over an existing tree (which acts as update)
2) whenever you specify -d or a module alias

we're planning on enabling this behaviour for case 2 in the future.

anoncvs sysadmins now love us even more.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.89 2008/06/10 05:01:36 tobias Exp $	*/
a363 1
		cvs_ent_close(entlist, ENT_SYNC);
a383 1
	cvs_ent_close(entlist, ENT_SYNC);
a462 1
	cvs_ent_close(entlist, ENT_SYNC);
@


1.89
log
@We have a cvs_buf_puts implementation now, also use cvs_buf_putc instead
of cvs_buf_append where appropiate.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.88 2008/05/28 17:12:00 tobias Exp $	*/
d78 2
d400 3
d444 3
d471 2
d632 1
a632 1
	cvs_checkout(server_argc, server_argv);
@


1.88
log
@Don't limit ourselfs when it comes to arguments on command line or
arguments sent by client.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.87 2008/05/06 10:37:30 tobias Exp $	*/
d224 1
a224 1
			cvs_buf_append(bp, " ", 1);
d228 1
a228 2
		cvs_buf_append(bp, cvs_requests[i].name,
		    strlen(cvs_requests[i].name));
@


1.87
log
@We have to check if server_argc is 1 instead of lesser than 0 to see if
an Argumentx directive has been sent to server without prior Argument.

ok joris, xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.86 2008/04/24 19:13:56 tobias Exp $	*/
d75 1
a75 1
static char *server_argv[CVS_CMD_MAXARG];
d105 1
a468 3
	if (server_argc >= CVS_CMD_MAXARG)
		fatal("cvs_server_argument: too many arguments sent");

d472 4
a475 1
	server_argv[server_argc++] = xstrdup(data);
@


1.86
log
@Use a fixed string in case of vasprintf() error instead of relying on
strerror().  Although our vasprintf() sets errno, we cannot rely on it on
other systems.

ok ray (who spotted this issue), xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.85 2008/04/18 20:26:07 tobias Exp $	*/
d483 1
a483 1
	if (server_argc < 0)
@


1.85
log
@Properly check memory allocation in client code.  While at it, unified
vasprintf() check across OpenCVS code base.

Based on a diff by Jacek Masiulaniec.

ok (and unification requested by) xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.84 2008/02/11 20:33:11 tobias Exp $	*/
d153 1
a153 1
		fatal("cvs_server_send_response: %s", strerror(errno));
@


1.84
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.83 2008/02/09 20:04:00 xsa Exp $	*/
d145 1
d150 1
a150 2
	if (vasprintf(&data, fmt, ap) == -1)
		fatal("vasprintf: %s", strerror(errno));
d152 2
@


1.83
log
@Introduce cvs_ent_line_str() - formats CVS/Entries lines.
OK tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.82 2008/02/03 18:18:44 tobias Exp $	*/
d215 1
a215 1
	bp = cvs_buf_alloc(512, BUF_AUTOEXT);
@


1.82
log
@Added rdiff support.  In order to do this, some output and option fixes
had to be done for diff, too.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.81 2008/02/03 17:20:14 joris Exp $	*/
d320 1
a320 1
	char *dir, *repo, *parent, entry[CVS_ENT_MAXLINELEN], *dirn, *p;
d354 4
a358 2
		(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "D/%s////", dirn);

d361 1
@


1.81
log
@better CVSROOT/module support, includes remote support and modules
that are not aliases (-a);

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.80 2008/02/01 17:18:59 tobias Exp $	*/
d593 12
@


1.80
log
@Added rannotate support

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.79 2008/01/31 22:09:05 xsa Exp $	*/
d171 1
d756 7
a762 2
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
	    current_cvsroot->cr_dir, dir);
d774 7
a780 2
	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
	    current_cvsroot->cr_dir, dir);
@


1.79
log
@Zap trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.78 2008/01/31 10:15:05 tobias Exp $	*/
d544 12
@


1.78
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.77 2008/01/29 12:01:52 tobias Exp $	*/
d661 1
a661 1
 
@


1.77
log
@Fixed function name in fatal calls.  While at it, adjusted style.

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.76 2008/01/21 16:36:46 tobias Exp $	*/
d79 1
a79 1
	CVS_OP_SERVER, 0, "server", { "", "" },
d507 1
d519 1
d531 1
d543 1
d555 1
d567 1
d579 1
d591 1
d609 1
d621 1
d633 1
d645 1
d657 1
d669 1
d681 1
d693 1
d705 1
d714 1
@


1.76
log
@Fixed export to be fully functional and compliant to GNU cvs in local and
remote setups.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.75 2008/01/10 11:20:29 tobias Exp $	*/
d557 2
a558 1
{	if (chdir(server_currentdir) == -1)
d579 3
a581 2
{	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_checkout: %s", strerror(errno));
d675 1
a675 1
		fatal("cvs_server_rlog: %s", strerror(errno));
@


1.75
log
@Added support for rtag in local and remote setups (with interoperability
with GNU cvs).  Basically we already had rtag in place as tag is supposed
to work with revisions in working directory, but our implementation was
wrong.  Fixed that on the fly as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.74 2008/01/10 09:59:23 tobias Exp $	*/
d573 10
@


1.74
log
@Got cvs_server_rlog back into shape.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.73 2007/11/09 16:27:38 tobias Exp $	*/
d655 11
@


1.73
log
@Parse CVSROOT/config and set umask on server-side, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.72 2007/09/22 16:01:22 joris Exp $	*/
d640 1
a640 9
	char fpath[MAXPATHLEN];
	struct cvsroot *cvsroot;

	cvsroot = cvsroot_get(NULL);

	(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
	    cvsroot->cr_dir, server_currentdir);

	if (chdir(fpath) == -1)
@


1.72
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.71 2007/09/22 15:57:24 joris Exp $	*/
d18 1
d169 3
@


1.71
log
@we no longer create a 0 sized file in our /tmp/cvs-serv<pid> server
directory when a client sends us info about a file that is up to date.

instead, remember the file is up to date in our CVS/Entries. Saves us a lot
of headaches on very big trees like src/
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.70 2007/09/07 19:18:41 tobias Exp $	*/
d704 1
a704 1
	char fpath[MAXPATHLEN], tbuf[CVS_ENT_MAXLINELEN];
a708 2
	(void)xsnprintf(tbuf, MAXPATHLEN, "T%s", tag);

d711 1
a711 1
	cvs_remote_output(tbuf);
@


1.70
log
@Do not use global option -V (GNU cvs doesn't understand it), be very
verbose per default on server-side instead.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.69 2007/09/02 12:16:24 tobias Exp $	*/
a419 1
	int fd;
d423 2
a424 1
	struct timeval tv[2];
a430 3
	if ((fd = open(fpath, O_RDWR | O_CREAT | O_TRUNC)) == -1)
		fatal("cvs_server_unchanged: %s: %s", fpath, strerror(errno));

a434 7
	cvs_ent_close(entlist, ENT_NOSYNC);

	tv[0].tv_sec = ent->ce_mtime;
	tv[0].tv_usec = 0;
	tv[1] = tv[0];
	if (futimes(fd, tv) == -1)
		fatal("cvs_server_unchanged: failed to set modified time");
d436 8
a443 2
	if (fchmod(fd, 0600) == -1)
		fatal("cvs_server_unchanged: failed to set mode");
d446 2
a447 1
	(void)close(fd);
@


1.69
log
@OpenCVS server init-support with OpenCVS and GNU cvs clients.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.68 2007/09/02 12:13:00 tobias Exp $	*/
d96 3
d284 3
a291 3

	if (!strcmp(data, "-V"))
		verbosity = 2;
@


1.68
log
@Stick at GNU cvs behaviour with Root directive handling: it does not need
to be sent first, can occure multiple times (although this is ignored) but
should be supplied before Directory.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.67 2007/08/28 19:10:18 xsa Exp $	*/
d575 8
a582 2
	if (chdir(server_currentdir) == -1)
		fatal("cvs_server_init: %s", strerror(errno));
@


1.67
log
@more typos in error messages; from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.66 2007/08/23 13:17:53 joris Exp $	*/
d23 1
d93 8
d157 8
a164 1
	fatal("duplicate Root request from client, violates the protocol");
d313 3
@


1.66
log
@support ArgumentX - unbreaks more gnu cvs client things.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.65 2007/07/03 13:22:43 joris Exp $	*/
d568 1
a568 1
		fatal("cvs_server_init: %s", strerror(errno));
d620 1
a620 1
		fatal("cvs_server_log: %s", strerror(errno));
@


1.65
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.64 2007/06/29 12:42:05 xsa Exp $	*/
d451 12
@


1.64
log
@Server-side bits for release command.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.63 2007/06/27 20:42:19 joris Exp $	*/
d318 1
a318 1
	cvs_mkpath(p);
d649 1
d654 3
d658 1
a658 1
	cvs_remote_output(cf->file_rpath);
d662 27
@


1.63
log
@have the server be more strict about the requests the client
sends that need a 'Directory' request first, so we do not
end up with very weird and possibly insecure behaviour.

more soon!

ok niallo@@ ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.62 2007/06/26 02:24:10 niallo Exp $	*/
d549 11
@


1.62
log
@add support for cvs rlog.
from Mickey.

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.61 2007/06/06 00:38:37 ray Exp $	*/
d117 4
@


1.61
log
@Don't double xstrdup.

From mickey.

``i made a booboo'' joris, OK niallo and xsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.60 2007/05/27 00:06:42 ray Exp $	*/
d577 19
@


1.60
log
@Fix off-by-one, from Tobias Stoeckmann.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.59 2007/05/26 23:52:04 ray Exp $	*/
d332 1
a332 1
	server_currentdir = xstrdup(p);
a333 1
	xfree(p);
@


1.59
log
@It is not the job of cvs_server_send_response() to do error checking.

Also remove unused variable.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.58 2007/05/26 23:19:31 ray Exp $	*/
d436 1
a436 2

	if (server_argc > CVS_CMD_MAXARG)
@


1.58
log
@Remove redundant xsnprintf calls.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.57 2007/05/25 22:27:02 ray Exp $	*/
d129 1
a129 2
	char *data, *s;
	struct cvs_resp *resp;
a134 13

	if ((s = strchr(data, ' ')) != NULL)
		*s = '\0';

	resp = cvs_remote_get_response_info(data);
	if (resp == NULL)
		fatal("'%s' is an unknown response", data);

	if (resp->supported != 1)
		fatal("remote cvs client does not support '%s'", data);

	if (s != NULL)
		*s = ' ';
@


1.57
log
@Call fatal() if we are missing an argument.  From Tobias Stoeckmann.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.56 2007/05/25 21:58:00 ray Exp $	*/
d94 2
a95 3
	cvs_server_path = xmalloc(MAXPATHLEN);
	(void)xsnprintf(cvs_server_path, MAXPATHLEN, "%s/cvs-serv%d",
	    cvs_tmpdir, getpid());
d630 1
a630 1
	char *p, response[MAXPATHLEN];
d635 1
a635 3
	(void)xsnprintf(response, MAXPATHLEN, "%s %s/", resp, cf->file_wd);

	cvs_server_send_response("%s", response);
@


1.56
log
@Check vasprintf for failure.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.55 2007/02/22 06:42:09 otto Exp $	*/
d169 3
a171 1
	sp = data;
d246 3
d264 3
d291 3
d358 3
d375 3
d416 3
d454 3
@


1.55
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.54 2007/02/17 18:23:43 xsa Exp $	*/
d134 2
a135 1
	vasprintf(&data, fmt, ap);
@


1.54
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.53 2007/01/31 21:07:36 xsa Exp $	*/
d18 8
a25 1
#include "includes.h"
a27 2
#include "log.h"
#include "diff.h"
@


1.53
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.52 2007/01/26 11:19:44 joris Exp $	*/
d222 2
a223 3
	if (cvs_path_cat(server_currentdir, CVS_PATH_STATICENTRIES, fpath,
	    MAXPATHLEN) >= MAXPATHLEN)
		fatal("cvs_server_static_directory: truncation");
d238 2
a239 3
	if (cvs_path_cat(server_currentdir, CVS_PATH_TAG, tagpath,
	    MAXPATHLEN) >= MAXPATHLEN)
		fatal("cvs_server_sticky: truncation");
d366 1
a366 3
	if (cvs_path_cat(server_currentdir, data, fpath, MAXPATHLEN) >=
	    MAXPATHLEN)
		fatal("cvs_server_modified: truncation");
d393 1
a393 3
	if (cvs_path_cat(server_currentdir, data, fpath, MAXPATHLEN) >=
	    MAXPATHLEN)
		fatal("cvs_server_unchanged: truncation");
@


1.52
log
@Handle CVS/Entries and file timestamp correctly so we do
not mistakenly see a file as Modified while it is not.

As a result, we can remove the very hackish cvs_hack_time() and
GNU cvs and opencvs should almost get along now.

lotsa help and okay The otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.51 2007/01/25 18:56:33 otto Exp $	*/
a83 1
	int l;
d90 1
a90 1
	l = snprintf(cvs_server_path, MAXPATHLEN, "%s/cvs-serv%d",
a91 2
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_server: overflow in server path");
a290 1
	int l;
d324 1
a324 3
		l = snprintf(entry, CVS_ENT_MAXLINELEN, "D/%s////", dirn);
		if (l == -1 || l >= CVS_ENT_MAXLINELEN)
			fatal("cvs_server_directory: overflow");
a607 1
	int l;
d613 1
a613 3
	l = snprintf(response, MAXPATHLEN, "%s %s/", resp, cf->file_wd);
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_server_update_entry: overflow");
@


1.51
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.50 2007/01/18 16:45:52 joris Exp $	*/
d416 1
a416 1
	tv[0].tv_sec = cvs_hack_time(ent->ce_mtime, 0);
@


1.50
log
@import improvements:
- add support for remote import in opencvs client and server.
- do not free already free'd buffers in import_update()
- do not append a '\0' to the loaded file buffer, this was bad behaviour

makes import work fine both locally and remotely.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.49 2007/01/17 17:54:50 joris Exp $	*/
d223 1
a223 1
	char *fpath;
a224 1
	fpath = xmalloc(MAXPATHLEN);
d231 1
a231 1
		goto out;
a233 2
out:
	xfree(fpath);
d240 1
a240 1
	char *tagpath;
a241 1
	tagpath = xmalloc(MAXPATHLEN);
d248 1
a248 1
		goto out;
a252 2
out:
	xfree(tagpath);
d296 1
a296 1
	char *dir, *repo, *parent, *entry, *dirn, *p;
a327 1
		entry = xmalloc(CVS_ENT_MAXLINELEN);
a333 1
		xfree(entry);
d361 1
a361 1
	char *mode, *len, *fpath;
a373 1
	fpath = xmalloc(MAXPATHLEN);
a385 1
	xfree(fpath);
d398 1
a398 1
	char *fpath;
a402 1
	fpath = xmalloc(MAXPATHLEN);
a425 1
	xfree(fpath);
d615 1
a615 1
	char *p, *response;
a619 1
	response = xmalloc(MAXPATHLEN);
a628 2

	xfree(response);
@


1.49
log
@add support for remote checkout in both our client and server,
with this the last real dependency to actually be able to use opencvs
in a remote setup has been added.

based upon an initial diff from xsa@@
'kay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.48 2007/01/13 15:29:34 joris Exp $	*/
d481 11
@


1.48
log
@- remote update now works again, with new rcs api
- we no longer hold the entire file in memory when sending or receiving it
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.47 2007/01/03 22:28:30 joris Exp $	*/
d302 1
a302 1
	char *dir, *repo, *parent, *entry, *dirn;
d305 3
a307 1
	if (strlen(dir) < strlen(current_cvsroot->cr_dir) + 1)
d310 15
a324 2
	repo = dir + strlen(current_cvsroot->cr_dir) + 1;
	cvs_mkpath(repo);
d326 1
a326 1
	if ((dirn = basename(repo)) == NULL)
d329 1
a329 1
	if ((parent = dirname(repo)) == NULL)
d346 1
a346 1
	server_currentdir = xstrdup(repo);
d348 1
d514 10
@


1.47
log
@add support for 'remove' in a remote setup.
testing appriciated, as always.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.46 2006/12/19 14:11:21 xsa Exp $	*/
a348 1
	BUF *bp;
a365 2
	bp = cvs_remote_receive_file(flen);

d374 1
a374 2
	if (cvs_buf_write_fd(bp, fd) == -1)
		fatal("cvs_server_modified: failed to write file '%s'", fpath);
a380 1
	cvs_buf_free(bp);
@


1.46
log
@add client-side support for Set-static-directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.45 2006/12/19 11:46:39 xsa Exp $	*/
d589 23
@


1.45
log
@add client-side support for Clear-static-directory, Clear-sticky and
Set-sticky requests. Set-sticky needs more work though.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.44 2006/12/15 13:12:14 xsa Exp $	*/
d37 1
a51 1
	{ "Set-static-directory",	0,	NULL, 0 },
@


1.44
log
@dummy support for update-patches request.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.43 2006/12/15 09:50:37 xsa Exp $	*/
d37 3
a51 3
	{ "Clear-static-directory",	0,	NULL, 0 },
	{ "Set-sticky",			0,	NULL, 0 },
	{ "Clear-sticky",		0,	NULL, 0 },
@


1.43
log
@server-side Static-directory bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.42 2006/12/15 08:02:53 xsa Exp $	*/
d448 12
@


1.42
log
@server-side Sticky bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.41 2006/12/04 09:51:21 xsa Exp $	*/
d220 20
d250 1
a250 1
	if ((fp = fopen(tagpath ,"w+")) == NULL) {
@


1.41
log
@snprintf() -> cvs_path_cat()
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.40 2006/11/27 16:04:10 xsa Exp $	*/
d217 22
@


1.40
log
@hook up annotate server bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.39 2006/11/14 15:39:42 xsa Exp $	*/
d308 1
a308 1
	int fd, l;
d328 3
a330 3
	l = snprintf(fpath, MAXPATHLEN, "%s/%s", server_currentdir, data);
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_server_modified: overflow");
d354 1
a354 1
	int l, fd;
d361 3
a363 3
	l = snprintf(fpath, MAXPATHLEN, "%s/%s", server_currentdir, data);
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_server_unchanged: overflow");
@


1.39
log
@Add support for the "Set" request.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.38 2006/11/14 14:45:31 xsa Exp $	*/
d430 10
@


1.38
log
@Handle global -l, -Q, and -r on the server side too.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.37 2006/11/14 09:59:54 xsa Exp $	*/
d239 14
@


1.37
log
@dummy support for Argumentx request.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.36 2006/11/14 09:47:52 xsa Exp $	*/
d222 2
a223 2
	if (!strcmp(data, "-t"))
		cvs_trace = 1;
d227 9
@


1.36
log
@Bring back version command. Still needs tweaks to make the
gnu cvs client<->opencvs server setup work. Rest works fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.35 2006/11/13 12:57:03 xsa Exp $	*/
d378 5
@


1.35
log
@Add server-side bits for admin command.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.34 2006/11/09 14:00:14 xsa Exp $	*/
d488 8
@


1.34
log
@cvs init remote bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.33 2006/11/09 10:08:33 xsa Exp $	*/
d390 12
@


1.33
log
@fix pasto..
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.32 2006/11/09 09:24:28 xsa Exp $	*/
d410 11
@


1.32
log
@remote tag command support joins the party!
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.31 2006/10/31 15:23:40 xsa Exp $	*/
d453 1
a453 1
	cvs_getlog(server_argc, server_argv);
@


1.31
log
@a step ahead in opencvs add|remove remote support.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.30 2006/07/09 01:47:20 joris Exp $	*/
d442 11
@


1.30
log
@more straightforward trace (-t) output, too much is just too noisy.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.29 2006/07/07 17:37:17 joris Exp $	*/
d381 11
d410 11
@


1.29
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d148 1
a229 2

	cvs_log(LP_TRACE, "cvs_server_globalopt(%s)", data);
a238 2
	cvs_log(LP_TRACE, "cvs_server_directory(%s)", data);

a275 2
	cvs_log(LP_TRACE, "cvs_server_entry(%s)", data);

a290 2
	cvs_log(LP_TRACE, "cvs_server_modified(%s)", data);

a325 1
	cvs_log(LP_TRACE, "cvs_server_useunchanged()");
a336 2
	cvs_log(LP_TRACE, "cvs_server_unchanged(%s)", data);

a367 1
	cvs_log(LP_TRACE, "cvs_server_questionable(%s)", data);
a372 1
	cvs_log(LP_TRACE, "cvs_server_argument(%s)", data);
a382 2
	cvs_log(LP_TRACE, "cvs_server_commit()");

a393 2
	cvs_log(LP_TRACE, "cvs_server_diff()");

a404 2
	cvs_log(LP_TRACE, "cvs_server_status()");

a415 2
	cvs_log(LP_TRACE, "cvs_server_log()");

a426 2
	cvs_log(LP_TRACE, "cvs_server_update()");

@


1.28
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.27 2006/01/02 08:11:56 xsa Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d22 41
a62 1
#include "proto.h"
d64 2
d67 3
a69 5
/* argument vector built by the `Argument' and `Argumentx' requests */
char   **cvs_args;
u_int   cvs_nbarg = 0;
u_int   cvs_utf8ok = 0;
u_int   cvs_case = 0;
d72 2
a73 5
	CVS_OP_SERVER, 0, "server",
	{ },
	"Server mode",
	"",
	"",
d75 3
a77 3
	0,
	NULL, NULL, NULL, NULL, NULL, NULL,
	0
a79 1
char cvs_server_tmpdir[MAXPATHLEN];
a80 11
/*
 * cvs_server()
 *
 * Implement the `cvs server' command.  As opposed to the general method of
 * CVS client/server implementation, the cvs program merely acts as a
 * redirector to the cvs daemon for most of the tasks.
 *
 * The `cvs server' command is only used on the server side of a remote
 * cvs command.  With this command, the cvs program starts listening on
 * standard input for CVS protocol requests.
 */
d84 35
a118 18
	int l, ret;
	size_t len;
	char reqbuf[512];

	if (argc != 1)
		return (CVS_EX_USAGE);

	/* make sure standard in and standard out are line-buffered */
	(void)setvbuf(stdin, NULL, _IOLBF, (size_t)0);
	(void)setvbuf(stdout, NULL, _IOLBF, (size_t)0);

	/* create the temporary directory */
	l = snprintf(cvs_server_tmpdir, sizeof(cvs_server_tmpdir),
	    "%s/cvs-serv%d", cvs_tmpdir, getpid());
	if (l == -1 || l >= (int)sizeof(cvs_server_tmpdir)) {
		errno = ENAMETOOLONG;
		fatal("cvs_server: tmpdir path too long: `%s'",
		    cvs_server_tmpdir);
d121 23
a143 3
	if (mkdir(cvs_server_tmpdir, 0700) == -1)
		fatal("cvs_server: mkdir: `%s': %s",
		    cvs_server_tmpdir, strerror(errno));
d145 2
a146 1
	cvs_chdir(cvs_server_tmpdir, 1);
d148 36
a183 8
	for (;;) {
		if (fgets(reqbuf, (int)sizeof(reqbuf), stdin) == NULL) {
			if (feof(stdin))
				break;
			else if (ferror(stdin)) {
				(void)cvs_rmdir(cvs_server_tmpdir);
				fatal("cvs_server: fgets failed");
			}
d185 2
d188 11
a198 2
		len = strlen(reqbuf);
		if (len == 0)
a199 5
		else if (reqbuf[len - 1] != '\n') {
			(void)cvs_rmdir(cvs_server_tmpdir);
			fatal("cvs_server: truncated request");
		}
		reqbuf[--len] = '\0';
d201 28
a228 1
		cvs_req_handle(reqbuf);
d230 2
d233 32
d267 184
a450 2
	/* cleanup the temporary tree */
	ret = cvs_rmdir(cvs_server_tmpdir);
d452 3
a454 1
	return (ret);
@


1.27
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.26 2005/12/24 19:07:52 xsa Exp $	*/
@


1.26
log
@add an argument to cvs_chdir() which enables or not the removal
of the directory we just chdir'd to.
Useful when the function fails especially for the server mode and
its temporary directory. This way it's not left behind on exit.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.25 2005/12/20 16:55:21 xsa Exp $	*/
d27 1
a27 8
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.25
log
@use fatal(); OK joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.24 2005/10/14 13:46:36 moritz Exp $	*/
d99 1
a99 4
	if (cvs_chdir(cvs_server_tmpdir) == -1) {
		(void)cvs_rmdir(cvs_server_tmpdir);
		fatal("cvs_server: cvs_chdir failed");
	}
@


1.24
log
@remove temporary cvs directory in error cases too. ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.23 2005/08/14 19:49:18 xsa Exp $	*/
d79 1
a79 1
	if (argc != 1) {
a80 1
	}
d91 2
a92 2
		cvs_log(LP_ERRNO, "%s", cvs_server_tmpdir);
		return (CVS_EX_DATA);
d95 3
a97 5
	if (mkdir(cvs_server_tmpdir, 0700) == -1) {
		cvs_log(LP_ERRNO, "failed to create temporary directory '%s'",
		    cvs_server_tmpdir);
		return (CVS_EX_FILE);
	}
d100 2
a101 2
		cvs_rmdir(cvs_server_tmpdir);
		return (CVS_EX_FILE);
d109 2
a110 2
				cvs_rmdir(cvs_server_tmpdir);
				return (CVS_EX_DATA);
d118 2
a119 3
			cvs_log(LP_ERR, "truncated request");
			cvs_rmdir(cvs_server_tmpdir);
			return (CVS_EX_PROTO);
@


1.23
log
@missing casts; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.22 2005/08/10 14:49:20 xsa Exp $	*/
d102 2
a103 1
	if (cvs_chdir(cvs_server_tmpdir) == -1)
d105 1
d111 2
a112 1
			else if (ferror(stdin))
d114 1
d122 1
@


1.22
log
@fgets() expects the 2nd arg to be an int. OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.21 2005/08/08 14:28:59 xsa Exp $	*/
d84 2
a85 2
	(void)setvbuf(stdin, NULL, _IOLBF, 0);
	(void)setvbuf(stdout, NULL, _IOLBF, 0);
@


1.21
log
@use cvs_tmpdir; OK jfb@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.20 2005/07/27 10:36:14 xsa Exp $	*/
d106 1
a106 1
		if (fgets(reqbuf, sizeof(reqbuf), stdin) == NULL) {
@


1.20
log
@rename cvs_remove_dir() to cvs_rmdir() because it might be confusing
with the `remove' command local functions. ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.19 2005/07/23 10:59:47 xsa Exp $	*/
a30 1
#include <paths.h>
d89 1
a89 1
	    "%scvs-serv%d", _PATH_TMP, getpid());
@


1.19
log
@use cvs_chdir();
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.18 2005/05/31 08:58:48 xsa Exp $	*/
d129 1
a129 1
	ret = cvs_remove_dir(cvs_server_tmpdir);
@


1.18
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.17 2005/05/24 04:12:25 jfb Exp $	*/
d103 1
a103 3
	if (chdir(cvs_server_tmpdir) == -1) {
		cvs_log(LP_ERRNO, "failed to change to temporary directory '%s'",
		    cvs_server_tmpdir);
a104 1
	}
@


1.17
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.16 2005/05/20 20:00:53 joris Exp $	*/
d30 3
d34 1
a34 1
#include <stdio.h>
a35 3
#include <errno.h>
#include <string.h>
#include <paths.h>
@


1.16
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.15 2005/05/18 21:39:25 alek Exp $	*/
d46 1
a46 1
u_int   cvs_case   = 0;
d48 11
a58 2
struct cvs_cmd_info cmd_server = {
	NULL, NULL, NULL, NULL, NULL, 0, 0, 0 };
@


1.15
log
@Style

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.14 2005/05/18 20:24:19 joris Exp $	*/
d91 1
a91 1
		return (CVS_EX_DATA);
d97 1
a97 1
		return (CVS_EX_DATA);
@


1.14
log
@

build a local copy of the client's source tree when acting as a server.
more server stuff coming soon!

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.13 2005/04/12 14:58:40 joris Exp $	*/
d95 2
a96 2
		cvs_log(LP_ERRNO, "failed to change to temporary directory '%s'"
		    , cvs_server_tmpdir);
@


1.13
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.12 2005/04/11 18:02:58 joris Exp $	*/
d28 1
d51 2
d67 1
d79 21
d122 4
a125 1
	return (0);
@


1.12
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.11 2005/04/11 17:56:27 joris Exp $	*/
d68 1
a68 1
		return (1);
d80 1
a80 1
				return (-1);
d88 1
a88 1
			return (-1);
@


1.11
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.10 2005/04/03 17:32:50 xsa Exp $	*/
a34 1
#include <sysexits.h>
@


1.10
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.9 2005/04/01 09:52:39 joris Exp $	*/
d69 1
a69 1
		return (EX_USAGE);
@


1.9
log
@

crank up buffersize to get rid of truncated requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.8 2005/03/31 17:18:24 joris Exp $	*/
d81 1
a81 1
				return (EX_DATAERR);
d89 1
a89 1
			return (EX_DATAERR);
@


1.8
log
@

make sure the server command can still be reached with the
new framework.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.7 2005/03/28 23:08:24 jfb Exp $	*/
d66 1
a66 1
	char reqbuf[128];
@


1.7
log
@dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.6 2004/12/07 17:10:56 tedu Exp $	*/
d47 3
@


1.6
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.5 2004/08/02 17:35:37 jfb Exp $	*/
a38 1
#include "sock.h"
a72 6
	if (cvs_sock_connect(CVSD_SOCK_PATH) < 0) {
		cvs_log(LP_ERR, "failed to connect to CVS server socket");
		return (-1);
	}


a93 2

	cvs_sock_disconnect();
@


1.5
log
@Get a step closer to reality
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a42 1

d45 1
a45 2
u_int    cvs_nbarg = 0;

a48 2


a59 1

@


1.4
log
@Remove remaining references to cvs_root
@
text
@d40 1
d68 1
a68 1
	ssize_t ret;
a69 1
	struct cvsroot *root;
d75 10
d86 5
a90 3
		ret = read(STDIN_FILENO, reqbuf, sizeof(reqbuf));
		if (ret == 0) {
			break;
d93 8
d102 1
a102 1
	}
a104 3
	if (cvs_sock_connect(root->cr_dir) < 0) {
		cvs_log(LP_ERR, "failed to connect to CVS server socket");
		return (-1);
@


1.3
log
@No need to import the `cvs_root' symbol anymore, it is done in cvs.h
@
text
@d69 1
d85 1
a85 1
	if (cvs_sock_connect(cvs_root->cr_dir) < 0) {
@


1.2
log
@Fix $OpenBSD$ tag
@
text
@a41 3
extern struct cvsroot *cvs_root;


@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: pmdb.c,v 1.19 2003/08/18 17:55:57 jfb Exp $	*/
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
