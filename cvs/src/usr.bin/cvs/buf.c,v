head	1.84;
access;
symbols
	OPENBSD_6_1_BASE:1.84
	OPENBSD_6_0:1.83.0.4
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.82.0.6
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.80.0.18
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.80.0.16
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.80.0.12
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.80.0.10
	OPENBSD_5_3_BASE:1.80
	OPENBSD_5_2:1.80.0.8
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.80
	OPENBSD_5_1:1.80.0.6
	OPENBSD_5_0:1.80.0.4
	OPENBSD_5_0_BASE:1.80
	OPENBSD_4_9:1.80.0.2
	OPENBSD_4_9_BASE:1.80
	OPENBSD_4_8:1.78.0.2
	OPENBSD_4_8_BASE:1.78
	OPENBSD_4_7:1.74.0.2
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.74.0.4
	OPENBSD_4_6_BASE:1.74
	OPENBSD_4_5:1.72.0.4
	OPENBSD_4_5_BASE:1.72
	OPENBSD_4_4:1.72.0.2
	OPENBSD_4_4_BASE:1.72
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.62.0.2
	OPENBSD_4_2_BASE:1.62
	OPENBSD_4_1:1.60.0.2
	OPENBSD_4_1_BASE:1.60
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.84
date	2016.10.15.22.20.17;	author millert;	state Exp;
branches;
next	1.83;
commitid	bZGHsljlW6kmRYub;

1.83
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.82;
commitid	O6jeJ0TRmiewrqMI;

1.82
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.81;
commitid	DTQbfd4poqBW8iSJ;

1.81
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	Z3HC5pAWzpo5jsTe;

1.80
date	2010.09.08.20.49.11;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2010.09.08.15.13.39;	author tobias;	state Exp;
branches;
next	1.78;

1.78
date	2010.08.01.09.19.29;	author zinovik;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.31.16.28.31;	author zinovik;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.74;

1.74
date	2009.03.25.21.19.20;	author joris;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.23.18.21.23;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.10.01.00.34;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.09.01.02.38;	author tobias;	state Exp;
branches;
next	1.70;

1.70
date	2008.03.08.11.53.36;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2008.02.11.20.33.10;	author tobias;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.03.15.08.04;	author tobias;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.25.10.02.50;	author chl;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.17.10.07.21;	author tobias;	state Exp;
branches;
next	1.64;

1.64
date	2007.08.29.21.15.06;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2007.08.29.09.35.42;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2007.08.09.03.08.13;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.21.04.18.45;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.19.11.40.00;	author otto;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.02.04.34.49;	author ray;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.02.04.24.09;	author ray;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.14.14.10.50;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.29.04.47.28;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.28.22.43.54;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.14.02.49.43;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.13.19.11.30;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.12.07.56.58;	author ray;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.11.00.49.49;	author ray;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.10.19.49.44;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.10.19.03.10;	author niallo;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.06.16.48.34;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.28.02.13.44;	author ray;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.25.21.29.58;	author ray;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.23.08.50.41;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.20.16.18.13;	author niallo;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.17.07.37.08;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.15.19.48.12;	author niallo;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.07.17.22.08;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.06.15.04.17;	author niallo;	state Exp;
branches;
next	1.33;

1.33
date	2006.02.26.09.45.02;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.29.17.50.08;	author niallo;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.16.21.02.36;	author niallo;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.15.19.25.32;	author niallo;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.10.14.57.53;	author niallo;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.30.05.28.27;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.30.01.59.00;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.24.04.10.51;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.23.00.27.04;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.21.16.03.56;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.20.17.55.10;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.20.17.11.48;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.20.16.55.21;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.14.19.49.18;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.29.17.04.42;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.26.20.58.44;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.20.16.14.55;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.02.07.16.38;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.26.21.46.36;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.24.07.38.46;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.08.22.22.38;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.08.21.11.07;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.28.15.12.17;	author pat;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.27.13.29.27;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.13.22.21.11;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Quiet compiler warnings.  OK tomc@@ tb@@
@
text
@/*	$OpenBSD: buf.c,v 1.83 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2003 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>

#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"
#include "cvs.h"
#include "buf.h"

#define BUF_INCR	128

struct buf {
	/* buffer handle, buffer size, and data length */
	u_char	*cb_buf;
	size_t	 cb_size;
	size_t	 cb_len;
};

#define SIZE_LEFT(b)	(b->cb_size - b->cb_len)

static void	buf_grow(BUF *, size_t);

/*
 * Create a new buffer structure and return a pointer to it.  This structure
 * uses dynamically-allocated memory and must be freed with buf_free(), once
 * the buffer is no longer needed.
 */
BUF *
buf_alloc(size_t len)
{
	BUF *b;

	b = xmalloc(sizeof(*b));
	/* Postpone creation of zero-sized buffers */
	if (len > 0)
		b->cb_buf = xcalloc(1, len);
	else
		b->cb_buf = NULL;

	b->cb_size = len;
	b->cb_len = 0;

	return (b);
}

/*
 * Open the file specified by <path> and load all of its contents into a
 * buffer.
 * Returns the loaded buffer.
 */
BUF *
buf_load(const char *path)
{
	int fd;
	BUF *bp;

	if ((fd = open(path, O_RDONLY, 0600)) == -1)
		fatal("buf_load: failed to load '%s' : %s", path,
		    strerror(errno));

	bp = buf_load_fd(fd);
	(void)close(fd);
	return (bp);
}

BUF *
buf_load_fd(int fd)
{
	struct stat st;
	BUF *buf;

	if (fstat(fd, &st) == -1)
		fatal("buf_load_fd: fstat: %s", strerror(errno));

	if (lseek(fd, 0, SEEK_SET) == -1)
		fatal("buf_load_fd: lseek: %s", strerror(errno));

	if ((uintmax_t)st.st_size > SIZE_MAX)
		fatal("buf_load_fd: file size too big");
	buf = buf_alloc(st.st_size);
	if (atomicio(read, fd, buf->cb_buf, buf->cb_size) != buf->cb_size)
		fatal("buf_load_fd: read: %s", strerror(errno));
	buf->cb_len = buf->cb_size;

	return (buf);
}

void
buf_free(BUF *b)
{
	if (b == NULL)
		return;
	free(b->cb_buf);
	free(b);
}

/*
 * Free the buffer <b>'s structural information but do not free the contents
 * of the buffer.  Instead, they are returned and should be freed later.
 */
void *
buf_release(BUF *b)
{
	void *tmp;

	tmp = b->cb_buf;
	free(b);
	return (tmp);
}

/*
 * Append a single character <c> to the end of the buffer <b>.
 */
void
buf_putc(BUF *b, int c)
{
	u_char *bp;

	if (SIZE_LEFT(b) == 0)
		buf_grow(b, BUF_INCR);
	bp = b->cb_buf + b->cb_len;
	*bp = (u_char)c;
	b->cb_len++;
}

/*
 * Append a C-string <str> to the end of the buffer <b>.
 */
void
buf_puts(BUF *b, const char *str)
{
	buf_append(b, str, strlen(str));
}

/*
 * Append <len> bytes of data pointed to by <data> to the buffer <b>.  If the
 * buffer is too small to accept all data, it will get resized to an
 * appropriate size to accept all data.
 */
void
buf_append(BUF *b, const void *data, size_t len)
{
	size_t left;
	u_char *bp;

	left = SIZE_LEFT(b);

	if (left < len)
		buf_grow(b, len - left);

	bp = b->cb_buf + b->cb_len;
	memcpy(bp, data, len);
	b->cb_len += len;
}

/*
 * Returns the size of the buffer that is being used.
 */
size_t
buf_len(BUF *b)
{
	return (b->cb_len);
}

/*
 * Write the contents of the buffer <b> to the specified <fd>
 */
int
buf_write_fd(BUF *b, int fd)
{
	if (atomicio(vwrite, fd, b->cb_buf, b->cb_len) != b->cb_len)
		return (-1);
	return (0);
}

/*
 * Write the contents of the buffer <b> to the file whose path is given in
 * <path>.  If the file does not exist, it is created with mode <mode>.
 */
int
buf_write(BUF *b, const char *path, mode_t mode)
{
	int fd;
open:
	if ((fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)) == -1) {
		if (errno == EACCES && unlink(path) != -1)
			goto open;
		else
			fatal("open: `%s': %s", path, strerror(errno));
	}

	if (buf_write_fd(b, fd) == -1) {
		(void)unlink(path);
		fatal("buf_write: buf_write_fd: `%s'", path);
	}

	if (fchmod(fd, mode) < 0)
		cvs_log(LP_ERR, "permissions not set on file %s", path);

	(void)close(fd);

	return (0);
}

/*
 * Write the contents of the buffer <b> to a temporary file whose path is
 * specified using <template> (see mkstemp.3). If <tv> is specified file
 * access and modification time is set to <tv>.
 * NB. This function will modify <template>, as per mkstemp
 */
int
buf_write_stmp(BUF *b, char *template, struct timeval *tv)
{
	int fd;

	if ((fd = mkstemp(template)) == -1)
		fatal("mkstemp: `%s': %s", template, strerror(errno));

	if (buf_write_fd(b, fd) == -1) {
		(void)unlink(template);
		fatal("buf_write_stmp: buf_write_fd: `%s'", template);
	}

	if (tv != NULL) {
		if (futimes(fd, tv) == -1)
			fatal("buf_write_stmp: futimes failed");
	}

	worklist_add(template, &temp_files);

	if (lseek(fd, 0, SEEK_SET) < 0)
		fatal("buf_write_stmp: lseek: %s", strerror(errno));

	return (fd);
}

u_char *
buf_get(BUF *bp)
{
	return (bp->cb_buf);
}

int
buf_differ(const BUF *b1, const BUF *b2)
{
	if (b1->cb_len != b2->cb_len)
		return (1);

	return (memcmp(b1->cb_buf, b2->cb_buf, b1->cb_len));
}

/*
 * Grow the buffer <b> by <len> bytes.  The contents are unchanged by this
 * operation regardless of the result.
 */
static void
buf_grow(BUF *b, size_t len)
{
	b->cb_buf = xreallocarray(b->cb_buf, 1, b->cb_size + len);
	b->cb_size += len;
}
@


1.83
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.82 2015/02/05 12:59:57 millert Exp $	*/
d109 1
a109 1
	if (st.st_size > SIZE_MAX)
@


1.82
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.81 2014/12/01 21:58:46 deraadt Exp $	*/
d122 4
a125 3
	if (b->cb_buf != NULL)
		xfree(b->cb_buf);
	xfree(b);
d130 1
a130 2
 * of the buffer.  Instead, they are returned and should be freed later using
 * xfree().
d138 1
a138 1
	xfree(b);
@


1.81
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.80 2010/09/08 20:49:11 nicm Exp $	*/
d32 1
@


1.80
log
@Improve buf.c comments, from zinovik.

ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.79 2010/09/08 15:13:39 tobias Exp $	*/
d289 1
a289 1
	b->cb_buf = xrealloc(b->cb_buf, 1, b->cb_size + len);
@


1.79
log
@Use SIZE_LEFT macro to determine left size instead of calculating with
pointers.

ok zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.78 2010/08/01 09:19:29 zinovik Exp $	*/
d43 1
d53 5
d76 5
d126 5
d141 3
d156 3
d165 5
d186 3
d195 3
d206 4
d235 6
a282 2
 * buf_grow()
 *
@


1.78
log
@change returning type to void like it is done in OpenRCS:buf_release()

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.77 2010/07/31 16:28:31 zinovik Exp $	*/
d130 2
a132 4
	if (bp == (b->cb_buf + b->cb_size)) {
		buf_grow(b, BUF_INCR);
		bp = b->cb_buf + b->cb_len;
	}
@


1.77
log
@introduce macro SIZE_LEFT and function buf_grow() from OpenRCS

buf_grow() replaces macro BUF_GROW()

ok nicm@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.76 2010/07/23 21:46:05 ray Exp $	*/
d115 1
a115 1
u_char *
d118 1
a118 1
	u_char *tmp;
@


1.76
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.75 2010/07/23 08:31:19 ray Exp $	*/
a40 5
#define BUF_GROW(bp, len)						\
	do {								\
		b->cb_buf = xrealloc(b->cb_buf, 1, b->cb_size + len);	\
		b->cb_size += len;					\
	} while (0);
d48 4
d132 1
a132 1
		BUF_GROW(b, BUF_INCR);
d149 1
a149 1
	u_char *bp, *bep;
d151 1
a151 3
	bp = b->cb_buf + b->cb_len;
	bep = b->cb_buf + b->cb_size;
	left = bep - bp;
d153 2
a154 4
	if (left < len) {
		BUF_GROW(b, len - left);
		bp = b->cb_buf + b->cb_len;
	}
d156 1
d239 13
@


1.75
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.74 2009/03/25 21:19:20 joris Exp $	*/
d47 1
a47 1
struct cvs_buf {
d54 1
a54 1
cvs_buf_alloc(size_t len)
d59 1
d72 1
a72 1
cvs_buf_load(const char *path)
d78 1
a78 1
		fatal("cvs_buf_load: failed to load '%s' : %s", path,
d81 1
a81 1
	bp = cvs_buf_load_fd(fd);
d87 1
a87 1
cvs_buf_load_fd(int fd)
d93 1
a93 1
		fatal("cvs_buf_load_fd: fstat: %s", strerror(errno));
d96 1
a96 1
		fatal("cvs_buf_load_fd: lseek: %s", strerror(errno));
d99 2
a100 2
		fatal("cvs_buf_load_fd: file size too big");
	buf = cvs_buf_alloc(st.st_size);
d102 1
a102 1
		fatal("cvs_buf_load_fd: read: %s", strerror(errno));
d109 1
a109 1
cvs_buf_free(BUF *b)
d117 1
a117 1
cvs_buf_release(BUF *b)
d127 1
a127 1
cvs_buf_putc(BUF *b, int c)
d141 1
a141 1
cvs_buf_puts(BUF *b, const char *str)
d143 1
a143 1
	cvs_buf_append(b, str, strlen(str));
d147 1
a147 1
cvs_buf_append(BUF *b, const void *data, size_t len)
d166 1
a166 1
cvs_buf_len(BUF *b)
d172 1
a172 1
cvs_buf_write_fd(BUF *b, int fd)
d180 1
a180 1
cvs_buf_write(BUF *b, const char *path, mode_t mode)
d191 1
a191 1
	if (cvs_buf_write_fd(b, fd) == -1) {
d193 1
a193 1
		fatal("cvs_buf_write: cvs_buf_write_fd: `%s'", path);
d205 1
a205 1
cvs_buf_write_stmp(BUF *b, char *template, struct timeval *tv)
d212 1
a212 1
	if (cvs_buf_write_fd(b, fd) == -1) {
d214 1
a214 1
		fatal("cvs_buf_write_stmp: cvs_buf_write_fd: `%s'", template);
d219 1
a219 1
			fatal("cvs_buf_write_stmp: futimes failed");
d225 1
a225 1
		fatal("cvs_buf_write_stmp: lseek: %s", strerror(errno));
d231 1
a231 1
cvs_buf_get(BUF *bp)
d237 1
a237 1
cvs_buf_differ(const BUF *b1, const BUF *b2)
@


1.74
log
@remove unused functions, definitions and outdated comments
from the stone ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.73 2009/03/23 18:21:23 joris Exp $	*/
d221 1
a221 1
	cvs_worklist_add(template, &temp_files);
@


1.73
log
@kill SIZE_LEFT() macro, no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.72 2008/06/10 01:00:34 joris Exp $	*/
d41 5
a47 1
	/* buffer handle, buffer size, and data length */
a52 9
static void	cvs_buf_grow(BUF *, size_t);

/*
 * cvs_buf_alloc()
 *
 * Create a new buffer structure and return a pointer to it.  This structure
 * uses dynamically-allocated memory and must be freed with cvs_buf_free(),
 * once the buffer is no longer needed.
 */
a58 1
	/* Postpone creation of zero-sized buffers */
a106 5
/*
 * cvs_buf_free()
 *
 * Free the buffer <b> and all associated data.
 */
a114 7
/*
 * cvs_buf_release()
 *
 * Free the buffer <b>'s structural information but do not free the contents
 * of the buffer.  Instead, they are returned and should be freed later using
 * free().
 */
a124 17
/*
 * cvs_buf_empty()
 *
 * Empty the contents of the buffer <b> and reset pointers.
 */
void
cvs_buf_empty(BUF *b)
{
	memset(b->cb_buf, 0, b->cb_size);
	b->cb_len = 0;
}

/*
 * cvs_buf_putc()
 *
 * Append a single character <c> to the end of the buffer <b>.
 */
d132 1
a132 4
		/* extend */
		cvs_buf_grow(b, (size_t)BUF_INCR);

		/* the buffer might have been moved */
a138 5
/*
 * cvs_buf_puts()
 *
 * Wrapper function for constant strings to cvs_buf_append.
 */
a144 21
/*
 * cvs_buf_getc()
 *
 * Return u_char at buffer position <pos>.
 *
 */
u_char
cvs_buf_getc(BUF *b, size_t pos)
{
	return (b->cb_buf[pos]);
}

/*
 * cvs_buf_append()
 *
 * Append <len> bytes of data pointed to by <data> to the buffer <b>.  If the
 * buffer is too small to accept all data, it will attempt to append as much
 * data as possible, or if the BUF_AUTOEXT flag is set for the buffer, it
 * will get resized to an appropriate size to accept all data.
 * Returns the number of bytes successfully appended to the buffer.
 */
d156 1
a156 1
		cvs_buf_grow(b, len - left);
a163 5
/*
 * cvs_buf_len()
 *
 * Returns the size of the buffer that is being used.
 */
a169 5
/*
 * cvs_buf_write_fd()
 *
 * Write the contents of the buffer <b> to the specified <fd>
 */
a177 6
/*
 * cvs_buf_write()
 *
 * Write the contents of the buffer <b> to the file whose path is given in
 * <path>.  If the file does not exist, it is created with mode <mode>.
 */
d182 1
a182 1
 open:
a202 7
/*
 * cvs_buf_write_stmp()
 *
 * Write the contents of the buffer <b> to a temporary file whose path is
 * specified using <template> (see mkstemp.3). NB. This function will modify
 * <template>, as per mkstemp
 */
d229 2
a230 8
/*
 * cvs_buf_grow()
 *
 * Grow the buffer <b> by <len> bytes.  The contents are unchanged by this
 * operation regardless of the result.
 */
static void
cvs_buf_grow(BUF *b, size_t len)
d232 1
a232 37
	b->cb_buf = xrealloc(b->cb_buf, 1, b->cb_size + len);
	b->cb_size += len;
}

/*
 * cvs_buf_copy()
 *
 * Copy the first <len> bytes of data in the buffer <b> starting at offset
 * <off> in the destination buffer <dst>, which can accept up to <len> bytes.
 * Returns the number of bytes successfully copied, or -1 on failure.
 */
ssize_t
cvs_buf_copy(BUF *b, size_t off, void *dst, size_t len)
{
	size_t rc;

	if (off > b->cb_len)
		fatal("cvs_buf_copy failed");

	rc = MIN(len, (b->cb_len - off));
	memcpy(dst, b->cb_buf + off, rc);

	return (ssize_t)rc;
}

/*
 * cvs_buf_peek()
 *
 * Peek at the contents of the buffer <b> at offset <off>.
 */
const u_char *
cvs_buf_peek(BUF *b, size_t off)
{
	if (off >= b->cb_len)
		return (NULL);

	return (b->cb_buf + off);
@


1.72
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.71 2008/03/09 01:02:38 tobias Exp $	*/
a47 2

#define SIZE_LEFT(b)	(b->cb_size - b->cb_len)
@


1.71
log
@While allocation memory, make sure that file sizes are smaller than SIZE_MAX.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.70 2008/03/08 11:53:36 joris Exp $	*/
d177 11
@


1.70
log
@correct usage of lseek(2);
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.69 2008/02/27 22:34:04 joris Exp $	*/
d105 2
@


1.69
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.68 2008/02/11 20:33:10 tobias Exp $	*/
d299 1
a299 1
	if (lseek(fd, SEEK_SET, 0) < 0)
@


1.68
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.67 2008/02/03 15:08:04 tobias Exp $	*/
d279 1
a279 1
void
d297 4
a300 1
	(void)close(fd);
d302 1
a302 1
	cvs_worklist_add(template, &temp_files);
@


1.67
log
@(f)utimes takes sys/time.h
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.66 2007/09/25 10:02:50 chl Exp $	*/
a42 2
	u_int	cb_flags;

d61 1
a61 1
cvs_buf_alloc(size_t len, u_int flags)
a71 1
	b->cb_flags = flags;
d79 1
a79 1
cvs_buf_load(const char *path, u_int flags)
d88 1
a88 1
	bp = cvs_buf_load_fd(fd, flags);
d94 1
a94 1
cvs_buf_load_fd(int fd, u_int flags)
d105 1
a105 1
	buf = cvs_buf_alloc(st.st_size, flags);
d168 1
a168 4
		if (b->cb_flags & BUF_AUTOEXT)
			cvs_buf_grow(b, (size_t)BUF_INCR);
		else
			fatal("cvs_buf_putc failed");
d198 1
a198 1
ssize_t
d201 1
a201 1
	size_t left, rlen;
a206 1
	rlen = len;
d209 2
a210 5
		if (b->cb_flags & BUF_AUTOEXT) {
			cvs_buf_grow(b, len - left);
			bp = b->cb_buf + b->cb_len;
		} else
			rlen = bep - bp;
d213 2
a214 27
	memcpy(bp, data, rlen);
	b->cb_len += rlen;

	return (rlen);
}

/*
 * cvs_buf_fappend()
 *
 */
ssize_t
cvs_buf_fappend(BUF *b, const char *fmt, ...)
{
	ssize_t ret;
	char *str;
	va_list vap;

	va_start(vap, fmt);
	ret = vasprintf(&str, fmt, vap);
	va_end(vap);

	if (ret == -1)
		fatal("cvs_buf_fappend: failed to format data");

	ret = cvs_buf_append(b, str, (size_t)ret);
	xfree(str);
	return (ret);
@


1.66
log
@missing header for mkstemp

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.65 2007/09/17 10:07:21 tobias Exp $	*/
d28 1
@


1.65
log
@Imported atomicio interface.

Requested by ray@@, OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.64 2007/08/29 21:15:06 joris Exp $	*/
d31 1
@


1.64
log
@correct error string in cvs_buf_load_fd() to match the function.
from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.63 2007/08/29 09:35:42 joris Exp $	*/
d34 1
a96 3
	ssize_t ret;
	size_t len;
	u_char *bp;
d107 3
a109 10
	for (bp = buf->cb_buf; ; bp += (size_t)ret) {
		len = SIZE_LEFT(buf);
		ret = read(fd, bp, len);
		if (ret == -1)
			fatal("cvs_buf_load_fd: read: %s", strerror(errno));
		else if (ret == 0)
			break;

		buf->cb_len += (size_t)ret;
	}
d269 2
a270 19
	u_char *bp;
	size_t len;
	ssize_t ret;

	len = b->cb_len;
	bp = b->cb_buf;

	do {
		ret = write(fd, bp, len);
		if (ret == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return (-1);
		}

		len -= (size_t)ret;
		bp += (size_t)ret;
	} while (len > 0);

@


1.63
log
@more typo shizzle from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.62 2007/08/09 03:08:13 ray Exp $	*/
d113 1
a113 1
			fatal("cvs_buf_load: read: %s", strerror(errno));
@


1.62
log
@Correct function name in fatal().  From Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.61 2007/05/29 00:19:10 ray Exp $	*/
d85 1
a85 1
		fatal("cvs_buf_load_fd: failed to load '%s' : %s", path,
@


1.61
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.60 2007/02/22 06:42:09 otto Exp $	*/
d85 1
a85 1
		fatal("cvs_buf_load: failed to load '%s' : %s", path,
@


1.60
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.59 2007/02/21 04:18:45 ray Exp $	*/
d370 1
a370 4
	void *tmp;

	tmp = xrealloc(b->cb_buf, 1, b->cb_size + len);
	b->cb_buf = tmp;
@


1.59
log
@Simplify cvs_buf_differ().  Also cvs_buf_differ(), a comparison
function, should not do any resource freeing.

OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.58 2007/02/19 11:40:00 otto Exp $	*/
d27 6
a32 1
#include "includes.h"
a35 3
#include "log.h"
#include "xmalloc.h"
#include "worklist.h"
@


1.58
log
@Fix const inconsistencies, void pointer artithmetic and a few other
things. now gcc -Wall and lint are more happy. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.57 2007/02/02 04:34:49 ray Exp $	*/
d411 1
a411 1
cvs_buf_differ(BUF *b1, BUF *b2)
d413 1
a413 8
	char *c1, *c2;
	int l1, l2, len, ret;

	l1 = cvs_buf_len(b1);
	l2 = cvs_buf_len(b2);
	len = MIN(l1, l2);

	if (l1 != l2)
d416 1
a416 11
	c1 = cvs_buf_release(b1);
	c2 = cvs_buf_release(b2);

	ret = memcmp(c1, c2, len);

	if (c1 != NULL)
		xfree(c1);
	if (c2 != NULL)
		xfree(c2);

	return (ret);
@


1.57
log
@Remove cb_cur or replace with cb_buf; cb_cur was the same as cb_buf
most of the time and was never of much use.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.56 2007/02/02 04:24:09 ray Exp $	*/
d141 1
a141 1
void *
d401 1
a401 1
const void *
@


1.56
log
@Remove unused and buggy {cvs,rcs}_buf_set functions.

Bugginess pointed out and fix provided by Pierre Riteau.

OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.55 2006/07/08 09:25:44 ray Exp $	*/
d40 1
a40 1
	/* buffer handle and size */
a42 3

	/* start and length of valid data in buffer */
	u_char	*cb_cur;
d46 1
a46 2
#define SIZE_LEFT(b)	(b->cb_size - (size_t)(b->cb_cur - b->cb_buf) \
			    - b->cb_len)
a70 1
	b->cb_cur = b->cb_buf;
d107 1
a107 1
	for (bp = buf->cb_cur; ; bp += (size_t)ret) {
a159 1
	b->cb_cur = b->cb_buf;
d173 1
a173 1
	bp = b->cb_cur + b->cb_len;
d182 1
a182 1
		bp = b->cb_cur + b->cb_len;
d197 1
a197 1
	return (b->cb_cur[pos]);
d215 1
a215 1
	bp = b->cb_cur + b->cb_len;
d223 1
a223 1
			bp = b->cb_cur + b->cb_len;
d281 1
a281 1
	bp = b->cb_cur;
a368 1
	size_t diff;
a369 1
	diff = b->cb_cur - b->cb_buf;
a372 3

	/* readjust pointers in case the buffer moved in memory */
	b->cb_cur = b->cb_buf + diff;
@


1.55
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.54 2006/06/14 14:10:50 joris Exp $	*/
a166 34
}

/*
 * cvs_buf_set()
 *
 * Set the contents of the buffer <b> at offset <off> to the first <len>
 * bytes of data found at <src>.  If the buffer was not created with
 * BUF_AUTOEXT, as many bytes as possible will be copied in the buffer.
 */
ssize_t
cvs_buf_set(BUF *b, const void *src, size_t len, size_t off)
{
	size_t rlen = 0;

	if (b->cb_size < (len + off)) {
		if ((b->cb_flags & BUF_AUTOEXT)) {
			cvs_buf_grow(b, len + off - b->cb_size);
			rlen = len + off;
		} else {
			rlen = b->cb_size - off;
		}
	} else {
		rlen = len;
	}

	b->cb_len = rlen;
	memcpy((b->cb_buf + off), src, rlen);

	if (b->cb_len == 0) {
		b->cb_cur = b->cb_buf + off;
		b->cb_len = rlen;
	}

	return (rlen);
@


1.54
log
@add cvs_buf_load_fd() which does the same as cvs_buf_load()
except it takes a decriptor as argument instead of a path.

modified cvs_buf_load() to open the descriptor then pass
it to cvs_buf_load_fd().

change all the calls to cvs_buf_load() that have a descriptor
open for the path to cvs_buf_load_fd() to prevent races.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.53 2006/05/29 04:47:28 joris Exp $	*/
d377 1
a377 1
cvs_buf_write_stmp(BUF *b, char *template, mode_t mode, struct timeval *tv)
a387 4

	if (fchmod(fd, mode) < 0)
		cvs_log(LP_ERR, "permissions not set on temporary file %s",
		    template);
@


1.53
log
@unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.52 2006/05/28 22:43:54 joris Exp $	*/
a80 7
/*
 * cvs_buf_load()
 *
 * Open the file specified by <path> and load all of its contents into a
 * buffer.
 * Returns the loaded buffer on success.
 */
d85 14
d105 2
a106 4
	if ((fd = open(path, O_RDONLY, 0600)) == -1) {
		cvs_log(LP_ERR, "%s", path);
		return (NULL);
	}
d108 2
a109 2
	if (fstat(fd, &st) == -1)
		fatal("cvs_buf_load: fstat: %s", strerror(errno));
a121 2

	(void)close(fd);
@


1.52
log
@add a way to look if a buffer differs from another one
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.51 2006/05/27 03:30:30 joris Exp $	*/
d460 1
a460 1
	int i, l1, l2, len, ret;
@


1.51
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.50 2006/04/14 02:49:43 deraadt Exp $	*/
d454 26
@


1.50
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.49 2006/04/14 02:45:35 deraadt Exp $	*/
d29 1
d99 1
a99 1
		cvs_log(LP_ERRNO, "%s", path);
d106 1
a106 1
	buf = cvs_buf_alloc((size_t)st.st_size, flags);
d110 1
a110 2
		if (ret == -1) {
			cvs_buf_free(buf);
d112 1
a112 1
		} else if (ret == 0)
d359 1
a359 1
		cvs_log(LP_ERRNO, "permissions not set on file %s", path);
d374 1
a374 1
cvs_buf_write_stmp(BUF *b, char *template, mode_t mode)
a380 4
#if defined(RCSPROG)
	cvs_worklist_add(template, &rcs_temp_files);
#endif

d387 1
a387 1
		cvs_log(LP_ERRNO, "permissions not set on temporary file %s",
d390 5
d396 2
a420 1
#if !defined(RCSPROG)
a454 1
#endif	/* RCSPROG */
@


1.49
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.48 2006/04/13 19:11:30 joris Exp $	*/
d384 1
a384 1
	
@


1.48
log
@fix the obviously broken cvs_buf_set(), so we don't end up
getting our buffer reset to 0 (empty) all the time.

i noticed this when i was trying to fix -z for keyword expansion. sigh.
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.47 2006/04/12 07:56:58 ray Exp $	*/
d347 1
a347 1
		if ((errno == EACCES) && (unlink(path) != -1))
@


1.47
log
@xmalloc(); memset(); -> xcalloc();

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.46 2006/04/11 00:49:49 ray Exp $	*/
d179 1
a179 1
		if ((b->cb_flags & BUF_AUTOEXT))
d181 2
a182 1
		else
d184 2
a185 1
	} else
d187 1
d189 1
@


1.46
log
@Change cvs_buf_grow() to return void, since it cannot fail, and
just use xrealloc, since it handles the case of an unallocated
buffer anyway.  (b->cb_buf should be NULL if the space is unallocated.)

``Tested & looks OK to'' niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.45 2006/04/10 19:49:44 joris Exp $	*/
d67 3
a69 4
	if (len > 0) {
		b->cb_buf = xmalloc(len);
		memset(b->cb_buf, 0, len);
	} else
@


1.45
log
@make sure we add the correct name mkstemp(3) creates for us
to the worklist of temporary files.

this way we definatly don't leave any files behind in /tmp.

tested & okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.44 2006/04/10 19:03:10 niallo Exp $	*/
d51 1
a51 1
static ssize_t	cvs_buf_grow(BUF *, size_t);
d180 2
a181 3
		if ((b->cb_flags & BUF_AUTOEXT) &&
		    (cvs_buf_grow(b, len + off - b->cb_size) < 0))
			fatal("cvs_buf_set failed");
d210 3
a212 2
		if (!(b->cb_flags & BUF_AUTOEXT) ||
		    (cvs_buf_grow(b, (size_t)BUF_INCR) < 0))
d256 1
a256 2
			if (cvs_buf_grow(b, len - left) < 0)
				fatal("cvs_buf_append failed");
a398 1
 * Returns the new size on success, or -1 on failure.
d400 1
a400 1
static ssize_t
d407 2
a408 6
	/* Buffer not allocated yet */
	if (b->cb_size == 0)
		tmp = xmalloc(len);
	else
		tmp = xrealloc(b->cb_buf, 1, b->cb_size + len);
	b->cb_buf = (u_char *)tmp;
a412 2

	return (ssize_t)b->cb_size;
@


1.44
log
@- use fchmod() instead of chmod() in cvs_buf_write_stmp(), makes
 it like cvs_buf_write()
- print warning on fchmod() failure (suggested by ray)

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.43 2006/04/06 16:48:34 xsa Exp $	*/
d32 1
d379 4
d387 1
@


1.43
log
@cvs_buf_copy() and cvs_buf_peek() are not used by usr.bin/rcs; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.42 2006/04/05 01:38:55 ray Exp $	*/
d354 4
a359 3
	if (chmod(path, mode) < 0)
		fatal("cvs_buf_write: chmod failed: %s", strerror(errno));

d382 4
a385 1
	(void)fchmod(fd, mode);
@


1.42
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.41 2006/03/28 02:13:44 ray Exp $	*/
a166 21
 * cvs_buf_copy()
 *
 * Copy the first <len> bytes of data in the buffer <b> starting at offset
 * <off> in the destination buffer <dst>, which can accept up to <len> bytes.
 * Returns the number of bytes successfully copied, or -1 on failure.
 */
ssize_t
cvs_buf_copy(BUF *b, size_t off, void *dst, size_t len)
{
	size_t rc;

	if (off > b->cb_len)
		fatal("cvs_buf_copy failed");

	rc = MIN(len, (b->cb_len - off));
	memcpy(dst, b->cb_buf + off, rc);

	return (ssize_t)rc;
}

/*
a302 14
 * cvs_buf_peek()
 *
 * Peek at the contents of the buffer <b> at offset <off>.
 */
const void *
cvs_buf_peek(BUF *b, size_t off)
{
	if (off >= b->cb_len)
		return (NULL);

	return (b->cb_buf + off);
}

/*
d412 37
@


1.41
log
@Today is Integer Overflow Prevention Day:
 - Sync xmalloc.? with ssh versions.
 - Change all xrealloc() calls to new API.

``I really like this.'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.40 2006/03/25 21:29:58 ray Exp $	*/
d64 1
a64 1
	b = (BUF *)xmalloc(sizeof(*b));
@


1.40
log
@Correct integer types, remove unused arguments, non-portable bitshifts
changed to division, KNF, replace unreachable code with goto fail,
et cetera.  Found by lint.

The free() -> xfree() as well.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.39 2006/03/23 08:50:41 xsa Exp $	*/
d438 1
a438 1
		tmp = xrealloc(b->cb_buf, b->cb_size + len);
@


1.39
log
@- cvs_buf_putc() will never return non-zero
- change cvs_buf_putc() return type to void
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.38 2006/03/20 16:18:13 niallo Exp $	*/
d249 1
a249 1
cvs_buf_getc(BUF *b, u_int pos)
@


1.38
log
@delint; cvs_buf_write_stmp() will never return non-zero:

- remove superfluous error handling for cvs_buf_write_stmp()
- change cvs_buf_write_stmp() return type to void

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.37 2006/03/17 07:37:08 ray Exp $	*/
a221 1
 * Returns 0 on success.
d223 1
a223 1
int
a239 2

	return (0);
@


1.37
log
@Use ssize_t in appropriate places.
Found by lint.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.36 2006/03/15 19:48:12 niallo Exp $	*/
d407 1
a407 1
int
a420 2

	return (0);
@


1.36
log
@- fchmod file to mode.

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.35 2006/03/07 17:22:08 xsa Exp $	*/
d296 1
a296 1
int
d299 1
a299 1
	int ret;
@


1.35
log
@no need to duplicate error message;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.34 2006/03/06 15:04:17 niallo Exp $	*/
d419 1
@


1.34
log
@like gnu ci(1), continue to process valid files in argv even if some are
invalid.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.33 2006/02/26 09:45:02 xsa Exp $	*/
d98 1
a98 1
		cvs_log(LP_ERRNO, "%s: %s", path, strerror(errno));
@


1.33
log
@better user-friendly error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.32 2006/01/29 17:50:08 niallo Exp $	*/
d97 4
a100 2
	if ((fd = open(path, O_RDONLY, 0600)) == -1)
		fatal("%s: %s", path, strerror(errno));
@


1.32
log
@- fix a bug where co -l would fail with "permission denied" if the working
file was read-only.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.31 2006/01/16 21:02:36 niallo Exp $	*/
d98 1
a98 1
		fatal("cvs_buf_load: open: `%s': %s", path, strerror(errno));
@


1.31
log
@- in cvs_buf_free(), don't try to free() b->cb_buf if it has not been
  allocated. fixes PR4974.


From: <ttakah@@lapis.plala.or.jp>
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.30 2006/01/15 19:25:32 niallo Exp $	*/
d378 7
a384 3

	if ((fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)) == -1)
		fatal("open: `%s': %s", path, strerror(errno));
@


1.30
log
@- don't try to malloc 0 bytes of memory if an empty buffer is requested; delay
  the malloc till cvs_buf_grow(). fixes PR4972.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.29 2006/01/10 14:57:53 niallo Exp $	*/
d69 2
a70 1
	}
d129 2
a130 1
	xfree(b->cb_buf);
@


1.29
log
@- add cvs_buf_getc() function; returns byte at specified buffer position.

needed for the next commit.

ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.28 2006/01/02 08:11:56 xsa Exp $	*/
d65 5
a69 2
	b->cb_buf = xmalloc(len);
	memset(b->cb_buf, 0, len);
d430 5
a434 1
	tmp = xrealloc(b->cb_buf, b->cb_size + len);
@


1.28
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.27 2005/12/30 05:28:27 joris Exp $	*/
d236 12
@


1.27
log
@adjust some thruth in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.26 2005/12/30 01:59:00 joris Exp $	*/
d27 1
a27 11
#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.26
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.25 2005/12/24 04:10:51 joris Exp $	*/
d255 1
a255 2
 * Returns the number of bytes successfully appended to the buffer, or -1
 * on failure.
@


1.25
log
@remove useless cvs_buf_alloc() failure checks;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.24 2005/12/23 00:27:04 joris Exp $	*/
a44 1

a56 1

a59 1

a61 2


a85 1

a126 1

a138 1

a155 1

a168 1

a189 1

a220 1

a247 1

a283 1

a306 1

a317 1

a331 1

a367 1

a394 1

@


1.24
log
@cvs_buf_write() did not properly set new permissions
on already existing files.

niallo agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.23 2005/12/21 16:03:56 xsa Exp $	*/
d115 1
a115 3
	if ((buf = cvs_buf_alloc((size_t)st.st_size, flags)) == NULL)
		fatal("cvs_buf_load: cvs_buf_alloc failed");

@


1.23
log
@initialize `rlen' in cvs_buf_set();
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.22 2005/12/20 17:55:10 xsa Exp $	*/
d401 3
@


1.22
log
@fix use of fatal() from previous commit;
temporary files were left behind if cvs_buf_write_* functions failed;
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.21 2005/12/20 17:11:48 xsa Exp $	*/
d213 1
a213 1
	size_t rlen;
@


1.21
log
@missed that in previous fatal() commit;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.20 2005/12/20 16:55:21 xsa Exp $	*/
d371 1
a371 1
			fatal("cvs_buf_write_fd failed");
d391 1
a391 1
	int ret, fd;
d396 1
a396 3
	ret = cvs_buf_write_fd(b, fd);
	if (ret == -1) {
		cvs_log(LP_ERRNO, "failed to write to file `%s'",  path);
d398 1
d402 1
a402 1
	return (ret);
d416 1
a416 1
	int ret, fd;
d421 1
a421 4
	ret = cvs_buf_write_fd(b, fd);
	if (ret == -1) {
		cvs_log(LP_ERRNO, "failed to write to temp file `%s'",
		    template);
d423 1
d427 1
a427 1
	return (ret);
@


1.20
log
@use fatal(); OK joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.19 2005/12/10 20:27:45 joris Exp $	*/
d194 1
a194 1
		return (-1);
d239 1
a239 1
 * Returns 0 on success, or -1 on failure.
d251 1
a251 1
			return (-1);
@


1.19
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.18 2005/08/14 19:49:18 xsa Exp $	*/
d97 1
a97 1
 * Returns the loaded buffer on success, or NULL on failure.
d109 2
a110 5
	fd = open(path, O_RDONLY, 0600);
	if (fd == -1) {
		cvs_log(LP_ERRNO, "failed to open buffer source");
		return (NULL);
	}
d112 2
a113 5
	if (fstat(fd, &st) == -1) {
		cvs_log(LP_ERRNO, "failed to stat buffer source");
		(void)close(fd);
		return (NULL);
	}
d115 2
a116 5
	buf = cvs_buf_alloc((size_t)st.st_size, flags);
	if (buf == NULL) {
		(void)close(fd);
		return (NULL);
	}
a121 2
			cvs_log(LP_ERRNO, "read failed from buffer source");
			(void)close(fd);
d123 1
a123 1
			return (NULL);
d216 3
a218 3
		if ((b->cb_flags & BUF_AUTOEXT) && (cvs_buf_grow(b,
		    len + off - b->cb_size) < 0))
			return (-1);
d287 1
a287 1
				return (-1);
d315 2
a316 4
	if (ret == -1) {
		cvs_log(LP_ERRNO, "failed to format data");
		return (-1);
	}
d371 1
a371 1
			return (-1);
d393 2
a394 5
	fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);
	if (fd == -1) {
		cvs_log(LP_ERRNO, "failed to open file `%s'", path);
		return (-1);
	}
d419 2
a420 5
	fd = mkstemp(template);
	if (fd == -1) {
		cvs_log(LP_ERRNO, "failed to mkstemp file `%s'", template);
		return (-1);
	}
@


1.18
log
@missing casts; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.17 2005/07/29 17:04:42 xsa Exp $	*/
d41 1
a41 1

d79 2
a80 12
	b = (BUF *)malloc(sizeof(*b));
	if (b == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate buffer");
		return (NULL);
	}

	b->cb_buf = malloc(len);
	if (b->cb_buf == NULL) {
		cvs_log(LP_ERRNO, "failed to allocate buffer");
		free(b);
		return (NULL);
	}
d155 2
a156 2
	free(b->cb_buf);
	free(b);
d173 1
a173 1
	free(b);
d332 1
a332 1
	free(str);
d466 1
a466 5
	tmp = realloc(b->cb_buf, b->cb_size + len);
	if (tmp == NULL) {
		cvs_log(LP_ERRNO, "failed to grow buffer");
		return (-1);
	}
@


1.17
log
@minor KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.16 2005/07/26 20:58:44 moritz Exp $	*/
d271 1
a271 1
		    (cvs_buf_grow(b, BUF_INCR) < 0))
d341 1
a341 1
	ret = cvs_buf_append(b, str, ret);
@


1.16
log
@- fix SIZE_LEFT macro for the cb_cur > cb_buf case.
- make cvs_buf_empty() really clean the buffer.
- fix cvs_buf_copy() for the off > 0 case.
- some more minor buf code cleanup.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.15 2005/07/25 12:05:43 xsa Exp $	*/
d177 1
a177 1
void*
d364 1
a364 1
const void*
@


1.15
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.14 2005/07/20 16:14:55 xsa Exp $	*/
d59 2
a60 2

#define SIZE_LEFT(b)	((size_t)(b->cb_buf - b->cb_cur) + b->cb_size)
d138 1
a138 1
		len = MIN(SIZE_LEFT(buf), 4096);
d196 1
d218 1
a218 1
	memcpy(dst, b->cb_buf, rc);
d227 3
a229 3
 * Set the contents of the buffer <b> to the first <len> bytes of data found
 * at <src>.  If the buffer was not created with BUF_AUTOEXT, as many bytes
 * as possible will be copied in the buffer.
d231 1
a231 1
int
d252 1
a252 1
	return (int)rlen;
d348 1
a348 1
 * cvs_buf_size()
d353 1
a353 1
cvs_buf_size(BUF *b)
d390 1
a390 1
		ret = write(fd, bp, MIN(len, 8192));
@


1.14
log
@no need to append strerror(errno) in error msg if we use LP_ERRNO code;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.13 2005/07/07 14:27:57 joris Exp $	*/
d43 1
a43 1
#define BUF_INCR   128
d47 1
a47 1
	u_int    cb_flags;
d50 2
a51 2
	u_char  *cb_buf;
	size_t   cb_size;
d54 2
a55 2
	u_char  *cb_cur;
	size_t   cb_len;
d60 1
a60 1
#define SIZE_LEFT(b)  ((size_t)(b->cb_buf - b->cb_cur) + b->cb_size)
d63 1
a63 1
static ssize_t   cvs_buf_grow (BUF *, size_t);
d74 1
a74 1
BUF*
d109 1
a109 1
BUF*
@


1.13
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.12 2005/06/02 07:16:38 xsa Exp $	*/
d446 1
a446 2
		cvs_log(LP_ERRNO, "failed to mkstemp file `%s': %s",
		    template, strerror(errno));
d452 2
a453 2
		cvs_log(LP_ERRNO, "failed to write to temp file `%s': %s",
		    template, strerror(errno));
@


1.12
log
@revert cvs_noexec checks commit, requested by jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.11 2005/05/31 08:58:47 xsa Exp $	*/
d417 1
a417 1
		cvs_log(LP_ERRNO, "failed to open file `%s'", path); 
d434 1
a434 1
 * Write the contents of the buffer <b> to a temporary file whose path is 
d446 1
a446 1
		cvs_log(LP_ERRNO, "failed to mkstemp file `%s': %s", 
d453 1
a453 1
		cvs_log(LP_ERRNO, "failed to write to temp file `%s': %s", 
@


1.11
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.10 2005/05/26 21:46:36 jfb Exp $	*/
a39 1
#include "cvs.h"
a414 2
	ret = 0;
	
d421 1
a421 3
	if (!cvs_noexec)
		ret = cvs_buf_write_fd(b, fd);

a443 2
	ret = 0;

d451 1
a451 3
	if (!cvs_noexec)
		ret = cvs_buf_write_fd(b, fd);

@


1.10
log
@don't append strerror(errno) to error messages if we use LP_ERRNO
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.9 2005/05/24 07:38:46 xsa Exp $	*/
a29 1
#include <stdio.h>
d31 1
d34 3
a37 3
#include <string.h>
#include <stdlib.h>
#include <errno.h>
@


1.9
log
@cvs_noexec checks; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.8 2004/12/08 22:22:38 jfb Exp $	*/
d420 1
a420 2
		cvs_log(LP_ERRNO, "failed to open file `%s': %s", 
		    path, strerror(errno));
d428 1
a428 2
		cvs_log(LP_ERRNO, "failed to write to file `%s': %s", 
		    path, strerror(errno));
@


1.8
log
@get rid of void* pointer arithmetic on buffers so gcc stops complaining
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.7 2004/12/08 21:11:07 djm Exp $	*/
d40 1
d416 2
d425 3
a427 1
	ret = cvs_buf_write_fd(b, fd);
d451 2
d460 3
a462 1
	ret = cvs_buf_write_fd(b, fd);
@


1.7
log
@use mkstemp for local diff -r r1 -r r2; ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.6 2004/12/07 17:10:56 tedu Exp $	*/
d50 1
a50 1
	void    *cb_buf;
d60 1
a60 1
#define SIZE_LEFT(b)  ((size_t)((u_char *)b->cb_buf - b->cb_cur) + b->cb_size)
d95 1
a95 1
	b->cb_cur = (u_char *)b->cb_buf;
d115 1
a115 1
	void *bp;
d143 1
a143 1
			cvs_buf_free(bp);
d180 1
a180 1
	void *tmp;
d196 1
a196 1
	b->cb_cur = (u_char *)b->cb_buf;
d297 1
a297 1
	void *bp, *bep;
d477 1
a477 1
	diff = b->cb_cur - (u_char *)b->cb_buf;
@


1.6
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.5 2004/12/06 21:03:12 deraadt Exp $	*/
d37 1
d374 1
a374 1
 * cvs_buf_write()
d376 1
a376 2
 * Write the contents of the buffer <b> to the file whose path is given in
 * <path>.  If the file does not exist, it is created with mode <mode>.
d379 1
a379 1
cvs_buf_write(BUF *b, const char *path, mode_t mode)
a380 1
	int fd;
a384 6
	fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);
	if (fd == -1) {
		cvs_log(LP_ERRNO, "failed to open file `%s'", path);
		return (-1);
	}

d391 2
a392 3
			cvs_log(LP_ERRNO, "failed to write to file `%s'", path);
			(void)close(fd);
			(void)unlink(path);
d400 28
d430 1
a430 1
	return (0);
d433 30
@


1.5
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.4 2004/11/28 15:12:17 pat Exp $	*/
a72 1

a107 1

a160 1

a175 1

d180 1
a191 1

a206 1

a228 1

d235 1
a235 1
		if ((b->cb_flags & BUF_AUTOEXT) && (cvs_buf_grow(b, 
a259 1

a291 1

a322 1

a349 1

a361 1

a377 1

a420 1

@


1.4
log
@make sure va_end() is always called in all possible paths

ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 2
		}
		else if (ret == 0)
d246 1
a246 3

	}
	else
d316 1
a316 2
		}
		else
@


1.3
log
@

use the real lenght to zero out the buffer in
cvs_buf_alloc();

ok jfb@@
@
text
@d344 2
a346 1
	ret = vasprintf(&str, fmt, vap);
a350 1
	va_end(vap);
@


1.2
log
@* make the email address consistent
@
text
@d91 1
a91 1
	memset(b->cb_buf, 0, sizeof(b->cb_buf));
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 2003 Jean-Francois Brousseau <jfb@@fugusec.net>
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
