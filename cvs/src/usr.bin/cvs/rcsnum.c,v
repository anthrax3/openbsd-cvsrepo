head	1.59;
access;
symbols
	OPENBSD_6_2:1.59.0.2
	OPENBSD_6_2_BASE:1.59
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.56.0.6
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.55.0.6
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.54.0.6
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.4
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.2
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.16
	OPENBSD_5_0:1.53.0.14
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.53.0.12
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.10
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.6
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.8
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.4
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.2
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.52.0.2
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2017.08.28.19.33.20;	author otto;	state Exp;
branches;
next	1.58;
commitid	pt4iCZKa4LhAa1TL;

1.58
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.57;
commitid	8Vv7d4HkmCtExfc6;

1.57
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.56;
commitid	O6jeJ0TRmiewrqMI;

1.56
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	Uu5nFG3wCl0LACBb;

1.55
date	2014.01.08.13.23.55;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2012.07.02.21.56.25;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2008.05.22.07.03.02;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2008.03.01.20.03.56;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2008.02.09.14.03.20;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.31.22.19.36;	author tobias;	state Exp;
branches;
next	1.49;

1.49
date	2008.01.10.09.39.32;	author tobias;	state Exp;
branches;
next	1.48;

1.48
date	2007.12.09.14.02.56;	author tobias;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.24.13.44.20;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.04.17.57.41;	author tobias;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.26.00.36.04;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.12.17.33.05;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.21.04.09.54;	author ray;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.13.18.42.40;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.27.03.28.36;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.31.18.24.55;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.27.03.30.31;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.14.22.33.15;	author niallo;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.14.02.49.44;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.06.12.12.07;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.05.01.38.56;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.30.23.06.25;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.30.06.07.35;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.28.02.13.44;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.18.03.33.55;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.15.05.05.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.11.22.44.11;	author niallo;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.11.06.28.49;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.28.14.09.34;	author niallo;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.03.11.06.55;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.30.17.51.01;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.27.16.08.26;	author niallo;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.12.17.47.03;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.10.13.06.24;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.19.15.45.16;	author niallo;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.02.11.48.56;	author joris;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.26.01.45.54;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.13.16.25.02;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.05.05.58.39;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.25.20.32.48;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.25.20.05.42;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.03.22.10.12;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.10.19.19.11;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.29.17.47.50;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.05.08.20;	author vincent;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.59
log
@fix const related warnings; ok millert@@
@
text
@/*	$OpenBSD: rcsnum.c,v 1.58 2016/10/13 20:51:25 fcambus Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "cvs.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

static void	 rcsnum_setsize(RCSNUM *, u_int);
static char	*rcsnum_itoa(u_int16_t, char *, size_t);

/*
 * rcsnum_alloc()
 *
 * Allocate an RCS number structure and return a pointer to it.
 */
RCSNUM *
rcsnum_alloc(void)
{
	RCSNUM *rnp;

	rnp = xcalloc(1, sizeof(*rnp));
	rnp->rn_len = 0;

	return (rnp);
}

/*
 * rcsnum_addmagic()
 *
 * Adds a magic branch number to an RCS number.
 * Returns 0 on success, or -1 on failure.
 */
int
rcsnum_addmagic(RCSNUM *rn)
{
	if (!rn->rn_len || rn->rn_len > RCSNUM_MAXLEN - 1)
		return -1;
	rcsnum_setsize(rn, rn->rn_len + 1);
	rn->rn_id[rn->rn_len - 1] = rn->rn_id[rn->rn_len - 2];
	rn->rn_id[rn->rn_len - 2] = 0;

	return 0;
}

/*
 * rcsnum_parse()
 *
 * Parse a string specifying an RCS number and return the corresponding RCSNUM.
 */
RCSNUM *
rcsnum_parse(const char *str)
{
	const char *ep;
	RCSNUM *num;

	num = rcsnum_alloc();
	if (rcsnum_aton(str, &ep, num) < 0 || *ep != '\0') {
		free(num);
		num = NULL;
	}

	return (num);
}

/*
 * rcsnum_tostr()
 *
 * Format the RCS number <nump> into a human-readable dot-separated
 * representation and store the resulting string in <buf>, which is of size
 * <blen>.
 * Returns a pointer to the start of <buf>.  On failure <buf> is set to
 * an empty string.
 */
char *
rcsnum_tostr(const RCSNUM *nump, char *buf, size_t blen)
{
	u_int i;
	char tmp[8];

	if (nump == NULL || nump->rn_len == 0) {
		buf[0] = '\0';
		return (buf);
	}

	if (strlcpy(buf, rcsnum_itoa(nump->rn_id[0], buf, blen), blen) >= blen)
		fatal("rcsnum_tostr: truncation");
	for (i = 1; i < nump->rn_len; i++) {
		const char *str;

		str = rcsnum_itoa(nump->rn_id[i], tmp, sizeof(tmp));
		if (strlcat(buf, ".", blen) >= blen ||
		    strlcat(buf, str, blen) >= blen)
			fatal("rcsnum_tostr: truncation");
	}
	return (buf);
}

static char *
rcsnum_itoa(u_int16_t num, char *buf, size_t len)
{
	u_int16_t i;
	char *p;

	if (num == 0)
		return "0";

	p = buf + len - 1;
	i = num;
	bzero(buf, len);
	while (i) {
		*--p = '0' + (i % 10);
		i  /= 10;
	}
	return (p);
}

/*
 * rcsnum_cpy()
 *
 * Copy the number stored in <nsrc> in the destination <ndst> up to <depth>
 * numbers deep.  If <depth> is 0, there is no depth limit.
 */
void
rcsnum_cpy(const RCSNUM *nsrc, RCSNUM *ndst, u_int depth)
{
	u_int len;

	len = nsrc->rn_len;
	if (depth != 0 && len > depth)
		len = depth;

	rcsnum_setsize(ndst, len);
	memcpy(ndst->rn_id, nsrc->rn_id, len * sizeof(*(nsrc->rn_id)));
}

/*
 * rcsnum_cmp()
 *
 * Compare the two numbers <n1> and <n2>. Returns -1 if <n1> is larger than
 * <n2>, 0 if they are both the same, and 1 if <n2> is larger than <n1>.
 * The <depth> argument specifies how many numbers deep should be checked for
 * the result.  A value of 0 means that the depth will be the maximum of the
 * two numbers, so that a longer number is considered greater than a shorter
 * number if they are equal up to the minimum length.
 */
int
rcsnum_cmp(RCSNUM *n1, RCSNUM *n2, u_int depth)
{
	int res;
	u_int i;
	size_t slen;

	if (!rcsnum_differ(n1, n2))
		return (0);

	slen = MINIMUM(n1->rn_len, n2->rn_len);
	if (depth != 0 && slen > depth)
		slen = depth;

	for (i = 0; i < slen; i++) {
		res = n1->rn_id[i] - n2->rn_id[i];
		if (res < 0)
			return (1);
		else if (res > 0)
			return (-1);
	}

	/* If an explicit depth was specified, and we've
	 * already checked up to depth, consider the
	 * revision numbers equal. */
	if (depth != 0 && slen == depth)
		return (0);
	else if (n1->rn_len > n2->rn_len)
		return (-1);
	else if (n2->rn_len > n1->rn_len)
		return (1);

	return (0);
}

/*
 * rcsnum_aton()
 *
 * Translate the string <str> containing a sequence of digits and periods into
 * its binary representation, which is stored in <nump>.  The address of the
 * first byte not part of the number is stored in <ep> on return, if it is not
 * NULL.
 * Returns 0 on success, or -1 on failure.
 */
int
rcsnum_aton(const char *str, const char **ep, RCSNUM *nump)
{
	u_int32_t val;
	const char *sp;
	char *s;

	nump->rn_len = 0;
	nump->rn_id[0] = 0;

	for (sp = str;; sp++) {
		if (!isdigit((unsigned char)*sp) && (*sp != '.'))
			break;

		if (*sp == '.') {
			if (nump->rn_len >= RCSNUM_MAXLEN - 1)
				goto rcsnum_aton_failed;

			nump->rn_len++;
			nump->rn_id[nump->rn_len] = 0;
			continue;
		}

		val = (nump->rn_id[nump->rn_len] * 10) + (*sp - '0');
		if (val > RCSNUM_MAXNUM)
			fatal("RCSNUM overflow!");

		nump->rn_id[nump->rn_len] = val;
	}

	if (ep != NULL)
		*ep = sp;

	/*
	 * Handle "magic" RCS branch numbers.
	 *
	 * What are they?
	 *
	 * Magic branch numbers have an extra .0. at the second farmost
	 * rightside of the branch number, so instead of having an odd
	 * number of dot-separated decimals, it will have an even number.
	 *
	 * Now, according to all the documentation I've found on the net
	 * about this, cvs does this for "efficiency reasons", I'd like
	 * to hear one.
	 *
	 * We just make sure we remove the .0. from in the branch number.
	 *
	 * XXX - for compatibility reasons with GNU cvs we _need_
	 * to skip this part for the 'log' command, apparently it does
	 * show the magic branches for an unknown and probably
	 * completely insane and not understandable reason in that output.
	 *
	 */
	if (nump->rn_len > 2 && nump->rn_id[nump->rn_len - 1] == 0) {
		/*
		 * Look for ".0.x" at the end of the branch number.
		 */
		if ((s = strrchr(str, '.')) != NULL) {
			s--;
			while (*s != '.')
				s--;

			/*
			 * If we have a "magic" branch, adjust it
			 * so the .0. is removed.
			 */
			if (!strncmp(s, RCS_MAGIC_BRANCH,
			    sizeof(RCS_MAGIC_BRANCH) - 1)) {
				nump->rn_id[nump->rn_len - 1] =
				    nump->rn_id[nump->rn_len];
				nump->rn_len--;
			}
		}
	}

	/* We can't have a single-digit rcs number. */
	if (nump->rn_len == 0) {
		nump->rn_len++;
		nump->rn_id[nump->rn_len] = 0;
	}

	nump->rn_len++;
	return (nump->rn_len);

rcsnum_aton_failed:
	nump->rn_len = 0;
	return (-1);
}

/*
 * rcsnum_inc()
 *
 * Increment the revision number specified in <num>.
 * Returns a pointer to the <num> on success, or NULL on failure.
 */
RCSNUM *
rcsnum_inc(RCSNUM *num)
{
	if (num->rn_id[num->rn_len - 1] == RCSNUM_MAXNUM)
		return (NULL);
	num->rn_id[num->rn_len - 1]++;
	return (num);
}

/*
 * rcsnum_dec()
 *
 * Decreases the revision number specified in <num>, if doing so will not
 * result in an ending value below 1. E.g. 4.2 will go to 4.1 but 4.1 will
 * be returned as 4.1.
 */
RCSNUM *
rcsnum_dec(RCSNUM *num)
{
	/* XXX - Is it an error for the number to be 0? */
	if (num->rn_id[num->rn_len - 1] <= 1)
		return (num);
	num->rn_id[num->rn_len - 1]--;
	return (num);
}

/*
 * rcsnum_revtobr()
 *
 * Retrieve the branch number associated with the revision number <num>.
 * If <num> is a branch revision, the returned value will be the same
 * number as the argument.
 */
RCSNUM *
rcsnum_revtobr(const RCSNUM *num)
{
	RCSNUM *brnum;

	if (num->rn_len < 2)
		return (NULL);

	brnum = rcsnum_alloc();
	rcsnum_cpy(num, brnum, 0);

	if (!RCSNUM_ISBRANCH(brnum))
		brnum->rn_len--;

	return (brnum);
}

/*
 * rcsnum_brtorev()
 *
 * Retrieve the initial revision number associated with the branch number <num>.
 * If <num> is a revision number, an error will be returned.
 */
RCSNUM *
rcsnum_brtorev(const RCSNUM *brnum)
{
	RCSNUM *num;

	if (!RCSNUM_ISBRANCH(brnum)) {
		return (NULL);
	}

	num = rcsnum_alloc();
	rcsnum_setsize(num, brnum->rn_len + 1);
	rcsnum_cpy(brnum, num, brnum->rn_len);
	num->rn_id[num->rn_len++] = 1;

	return (num);
}

RCSNUM *
rcsnum_new_branch(RCSNUM *rev)
{
	RCSNUM *branch;

	if (rev->rn_len > RCSNUM_MAXLEN - 1)
		return NULL;

	branch = rcsnum_alloc();
	rcsnum_cpy(rev, branch, 0);
	rcsnum_setsize(branch, rev->rn_len + 1);
	branch->rn_id[branch->rn_len - 1] = 2;

	return branch;
}

RCSNUM *
rcsnum_branch_root(RCSNUM *brev)
{
	RCSNUM *root;

	if (!RCSNUM_ISBRANCHREV(brev))
		fatal("rcsnum_branch_root: no revision on branch specified");

	root = rcsnum_alloc();
	rcsnum_cpy(brev, root, 0);
	root->rn_len -= 2;
	return (root);
}

static void
rcsnum_setsize(RCSNUM *num, u_int len)
{
	num->rn_len = len;
}

int
rcsnum_differ(RCSNUM *r1, RCSNUM *r2)
{
	int i, len;

	if (r1->rn_len != r2->rn_len)
		return (1);

	len = MINIMUM(r1->rn_len, r2->rn_len);
	for (i = 0; i < len; i++) {
		if (r1->rn_id[i] != r2->rn_id[i])
			return (1);
	}

	return (0);
}
@


1.58
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.57 2015/11/05 09:48:21 nicm Exp $	*/
d80 1
a80 1
	char *ep;
d218 1
a218 1
rcsnum_aton(const char *str, char **ep, RCSNUM *nump)
d248 1
a248 1
		*(const char **)ep = sp;
@


1.57
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.56 2015/01/16 06:40:07 deraadt Exp $	*/
d85 1
a85 1
		rcsnum_free(num);
a89 11
}

/*
 * rcsnum_free()
 *
 * Free an RCSNUM structure previously allocated with rcsnum_alloc().
 */
void
rcsnum_free(RCSNUM *rn)
{
	free(rn);
@


1.56
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.55 2014/01/08 13:23:55 okan Exp $	*/
d28 1
d100 1
a100 1
	xfree(rn);
@


1.55
log
@unsigned char for ctype. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.54 2012/07/02 21:56:25 tedu Exp $	*/
d32 2
d193 1
a193 1
	slen = MIN(n1->rn_len, n2->rn_len);
d440 1
a440 1
	len = MIN(r1->rn_len, r2->rn_len);
@


1.54
log
@simplify rcsnum parsing by using a fixed array without all the realloc
ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.53 2008/05/22 07:03:02 joris Exp $	*/
d236 1
a236 1
		if (!isdigit(*sp) && (*sp != '.'))
@


1.53
log
@correctly deal with non-zero depths specified in rcsnum_cmp();

from Stefan Sperling
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.52 2008/03/01 20:03:56 joris Exp $	*/
d45 1
a45 1
	rnp = xmalloc(sizeof(*rnp));
a46 1
	rnp->rn_id = NULL;
a96 2
	if (rn->rn_id != NULL)
		xfree(rn->rn_id);
a129 1

d168 1
a168 3
	/* Overflow checked in rcsnum_setsize(). */
	(void)memcpy(ndst->rn_id, nsrc->rn_id,
	    len * sizeof(*(nsrc->rn_id)));
a231 3
	if (nump->rn_id == NULL)
		nump->rn_id = xmalloc(sizeof(*(nump->rn_id)));

a243 2
			nump->rn_id = xrealloc(nump->rn_id,
			    nump->rn_len + 1, sizeof(*(nump->rn_id)));
a303 2
		nump->rn_id = xrealloc(nump->rn_id,
		    nump->rn_len + 1, sizeof(*(nump->rn_id)));
a311 2
	xfree(nump->rn_id);
	nump->rn_id = NULL;
a426 1
	num->rn_id = xrealloc(num->rn_id, len, sizeof(*(num->rn_id)));
@


1.52
log
@goodbye rcs_errno - we didnt use you and you wont be missed
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.51 2008/02/09 14:03:20 joris Exp $	*/
d183 3
a185 2
 * the result.  A value of 0 means that the depth will be the minimum of the
 * two numbers.
d209 6
a214 1
	if (n1->rn_len > n2->rn_len)
@


1.51
log
@- always remove the additional .0 from magic branches, even when
  running the log command.

- change getlog.c so it will add any .0 for magic branches in its output
  if required


less confusing for rcs_translate_tag();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.50 2008/01/31 22:19:36 tobias Exp $	*/
a84 2
		if (*ep != '\0')
			rcs_errno = RCS_ERR_BADNUM;
d243 1
a243 2
			if (nump->rn_len >= RCSNUM_MAXLEN - 1) {
				rcs_errno = RCS_ERR_BADNUM;
a244 1
			}
@


1.50
log
@Handle magic branch numbers in OpenCVS as well.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.49 2008/01/10 09:39:32 tobias Exp $	*/
a34 2
int rcsnum_flags;

d288 1
a288 2
	if (nump->rn_len > 2 && nump->rn_id[nump->rn_len - 1] == 0
	    && !(rcsnum_flags & RCSNUM_NO_MAGIC)) {
@


1.49
log
@Slap in -b support for tag command.  It was missing for a full regress test
as of now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.48 2007/12/09 14:02:56 tobias Exp $	*/
d52 18
@


1.48
log
@Fix for an off-by-one.

OK fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.47 2007/09/24 13:44:20 joris Exp $	*/
d390 16
@


1.47
log
@add support to commit modified files to branches.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.46 2007/09/04 17:57:41 tobias Exp $	*/
d297 1
d300 1
a300 2
		nump->rn_id[nump->rn_len + 1] = 0;
		nump->rn_len++;
@


1.46
log
@Replaced strlen() with sizeof() - 1 when #define'd strings are used.

OK ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.45 2007/05/29 00:19:10 ray Exp $	*/
d390 14
@


1.45
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.44 2007/05/26 00:36:04 krw Exp $	*/
d287 1
a287 1
			    strlen(RCS_MAGIC_BRANCH))) {
@


1.44
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.43 2007/05/12 17:33:05 ray Exp $	*/
a215 1
	void *tmp;
d235 1
a235 1
			tmp = xrealloc(nump->rn_id,
a236 1
			nump->rn_id = tmp;
d297 1
a297 1
		tmp = xrealloc(nump->rn_id,
a298 1
		nump->rn_id = tmp;
d395 1
a395 4
	void *tmp;

	tmp = xrealloc(num->rn_id, len, sizeof(*(num->rn_id)));
	num->rn_id = tmp;
@


1.43
log
@Change 0x30 to more readable '0'.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.42 2007/02/22 06:42:09 otto Exp $	*/
d262 2
a263 2
	 * Now, according to all the documentation i've found on the net
	 * about this, cvs does this for "efficiency reasons", i'd like
@


1.42
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.41 2007/02/21 04:09:54 ray Exp $	*/
d243 1
a243 1
		val = (nump->rn_id[nump->rn_len] * 10) + (*sp - 0x30);
@


1.41
log
@Replace a manual xrealloc with rcsnum_setsize.

From Charles Longeau <chl at tuxfamily dot org>.

OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.40 2006/11/13 18:42:40 xsa Exp $	*/
d27 2
a28 1
#include "includes.h"
a30 2
#include "log.h"
#include "rcs.h"
@


1.40
log
@Check strlcpy/strlcat return values; from usr.bin/rcs/rcsnum.c
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.39 2006/07/27 03:28:36 ray Exp $	*/
a152 1
	void *tmp;
d158 2
a159 4
	tmp = xrealloc(ndst->rn_id, len, sizeof(*(nsrc->rn_id)));
	ndst->rn_id = tmp;
	ndst->rn_len = len;
	/* Overflow checked in xrealloc(). */
@


1.39
log
@Pull in improper memory allocation from RCS:

> Not were we allocating memory for a pointer array, it wasn't even for
> the right variable!  Fixes make regress with MALLOC_OPTIONS=PR.
>
> Found by and fix worked on with Joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.38 2006/05/31 18:24:55 joris Exp $	*/
a103 1
	size_t len;
d110 2
a111 1
	strlcpy(buf, rcsnum_itoa(nump->rn_id[0], buf, blen), blen);
d113 6
a118 8
		len = strlcat(buf, ".", blen);
		if (len >= blen)
			fatal("rcsnum_tostr: overflow 1");

		len = strlcat(buf,
		    rcsnum_itoa(nump->rn_id[i], tmp, sizeof(tmp)), blen);
		if (len >= blen)
			fatal("rcsnum_tostr: overflow 2");
@


1.38
log
@be smarter when comparing 2 revisions to each other.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.37 2006/05/27 03:30:31 joris Exp $	*/
d161 1
a161 1
	tmp = xrealloc(ndst->rn_id, len, sizeof(len));
d165 2
a166 1
	(void)memcpy(ndst->rn_id, nsrc->rn_id, len * sizeof(len));
@


1.37
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.36 2006/04/14 22:33:15 niallo Exp $	*/
d178 1
a178 1
rcsnum_cmp(const RCSNUM *n1, const RCSNUM *n2, u_int depth)
d184 3
d408 17
@


1.36
log
@- swap a hack for a slightly nicer hack using a global variable.  this avoids
adding a really nasty hack to make some upcoming rlog fixes from joris work.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.35 2006/04/14 02:49:44 deraadt Exp $	*/
a32 1

d104 1
d113 8
a120 3
		strlcat(buf, ".", blen);
		strlcat(buf, rcsnum_itoa(nump->rn_id[i], tmp, sizeof(tmp)),
		    blen);
@


1.35
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.34 2006/04/14 02:45:35 deraadt Exp $	*/
d37 1
d271 2
a272 6
#if !defined(RCSPROG)
	if (nump->rn_len > 2 && nump->rn_id[nump->rn_len - 1] == 0 &&
	    cvs_cmdop != CVS_OP_LOG) {
#else
	if (nump->rn_len > 2 && nump->rn_id[nump->rn_len - 1] == 0) {
#endif
@


1.34
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.33 2006/04/06 12:12:07 xsa Exp $	*/
d128 1
a128 1
		
@


1.33
log
@rcsnum_setsize() will never return non-zero; change its return type to void.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.32 2006/04/05 01:38:56 ray Exp $	*/
d67 1
a67 1
	if ((rcsnum_aton(str, &ep, num) < 0) || (*ep != '\0')) {
d105 1
a105 1
	if ((nump == NULL) || (nump->rn_len == 0)) {
d152 1
a152 1
	if ((depth != 0) && (len > depth))
d179 1
a179 1
	if ((depth != 0) && (slen > depth))
d271 2
a272 2
	if ((nump->rn_len > 2) && (nump->rn_id[nump->rn_len - 1] == 0)
	    && (cvs_cmdop != CVS_OP_LOG)) {
d274 1
a274 1
	if ((nump->rn_len > 2) && (nump->rn_id[nump->rn_len - 1] == 0)) {
@


1.32
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.31 2006/03/30 23:06:25 joris Exp $	*/
d34 1
a34 1
static int	 rcsnum_setsize(RCSNUM *, u_int);
d388 1
a388 5
	if (rcsnum_setsize(num, brnum->rn_len + 1) < 0) {
		rcsnum_free(num);
		return (NULL);
	}

d395 1
a395 1
static int
a402 1
	return (0);
@


1.31
log
@first part of supporting branches in openrcs. right now we can only
check them out. commit is not working yet, but will be soon.

tested by myself and ray@@
okay ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.30 2006/03/30 06:07:35 ray Exp $	*/
d48 1
a48 1
	rnp = (RCSNUM *)xmalloc(sizeof(*rnp));
d156 1
a156 1
	ndst->rn_id = (u_int16_t *)tmp;
d159 1
a159 1
	memcpy(ndst->rn_id, nsrc->rn_id, len * sizeof(len));
d216 1
a216 1
		nump->rn_id = (u_int16_t *)xmalloc(sizeof(u_int16_t));
d233 2
a234 2
			    nump->rn_len + 1, sizeof(u_int16_t));
			nump->rn_id = (u_int16_t *)tmp;
d300 2
a301 2
		    nump->rn_len + 1, sizeof(u_int16_t));
		nump->rn_id = (u_int16_t *)tmp;
d404 2
a405 2
	tmp = xrealloc(num->rn_id, len, sizeof(u_int16_t));
	num->rn_id = (u_int16_t *)tmp;
@


1.30
log
@ - Comment fixes.
 - int rcsnum_cpy() -> void rcsnum_cpy().
 - Check for overflow in rcsnum_cpy().

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.29 2006/03/28 02:13:44 ray Exp $	*/
d305 1
@


1.29
log
@Today is Integer Overflow Prevention Day:
 - Sync xmalloc.? with ssh versions.
 - Change all xrealloc() calls to new API.

``I really like this.'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.28 2006/03/18 03:33:55 ray Exp $	*/
d41 1
a41 2
 * Allocate an RCS number structure and return a pointer to it on success,
 * or NULL on failure.
d143 1
a143 2
 * numbers deep.
 * Returns 0 on success, or -1 on failure.
d145 1
a145 1
int
a148 1
	size_t sz;
a153 1
	sz = len * sizeof(u_int16_t);
d155 1
a155 1
	tmp = xrealloc(ndst->rn_id, 1, sz);
d158 2
a159 2
	memcpy(ndst->rn_id, nsrc->rn_id, sz);
	return (0);
@


1.28
log
@Change code to match comments, fixing potential off-by-one error.
According to the comments, the lowest number should be 1.

not okay, then okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.27 2006/03/15 05:05:35 deraadt Exp $	*/
d159 1
a159 1
	tmp = xrealloc(ndst->rn_id, sz);
d237 1
a237 1
			    (nump->rn_len + 1) * sizeof(u_int16_t));
d304 1
a304 1
		    (nump->rn_len + 1) * sizeof(u_int16_t));
d407 1
a407 1
	tmp = xrealloc(num->rn_id, len * sizeof(u_int16_t));
@


1.27
log
@remove some bizzare idioms; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.26 2006/03/11 22:44:11 niallo Exp $	*/
d344 2
a345 1
	if (num->rn_id[num->rn_len - 1] <= 0)
@


1.26
log
@- implement GNU-compatible handling of revisions specified as single
digits.  e.g. ci -l4 or ci -u5 will work like GNU now.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.25 2006/03/11 06:28:49 ray Exp $	*/
d284 1
a284 1
			*s--;
d286 1
a286 1
				*s--;
@


1.25
log
@Fix rcsnum_tostr() description.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.24 2006/01/28 14:09:34 niallo Exp $	*/
d127 3
d301 8
d337 3
a339 2
 * Decreases the revision number specified in <num>
 * Returns pointer to the <num> on success, or NULL on failure.
d345 1
a345 1
		return (NULL);
@


1.24
log
@- don't segfault on rcsnum overflow.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.23 2006/01/03 11:06:55 xsa Exp $	*/
d97 2
a98 1
 * Returns a pointer to the start of <buf> on success, or NULL on failure.
@


1.23
log
@knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.22 2006/01/02 08:11:56 xsa Exp $	*/
d240 2
a241 4
		if (val > RCSNUM_MAXNUM) {
			cvs_log(LP_ERR, "RCSNUM overflow");
			goto rcsnum_aton_failed;
		}
@


1.22
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.21 2005/12/30 17:51:01 reyk Exp $	*/
d34 2
a35 2
static int	rcsnum_setsize(RCSNUM *, u_int);
static char     *rcsnum_itoa(u_int16_t, char *, size_t);
@


1.21
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.20 2005/12/27 16:08:26 niallo Exp $	*/
d27 1
a27 6
#include <sys/param.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
@


1.20
log
@- optimise rcsnum_tostr(). we call this function a LOT and using multiple
  snprintf()s in it is SLOW.

second of a few important performance improvements.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.19 2005/12/12 17:47:03 joris Exp $	*/
d128 2
a129 2
        u_int16_t i;
        char *p;   
d131 2
a132 2
        p = buf + len - 1;
        i = num;
d134 5
a138 5
        while (i) {
                *--p = '0' + (i % 10);
                i  /= 10;
        }
        return (p);    
@


1.19
log
@rcsnum_alloc() and rcsnum_cpy() no longer can fail, so don't
bother checking return values for failure.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.18 2005/12/10 20:27:45 joris Exp $	*/
d40 1
d115 1
a115 1
	snprintf(buf, blen, "%u", nump->rn_id[0]);
d117 3
a119 2
		snprintf(tmp, sizeof(tmp), ".%u", nump->rn_id[i]);
		strlcat(buf, tmp, blen);
d123 16
@


1.18
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.17 2005/10/10 13:06:24 joris Exp $	*/
d71 1
a71 3
	if ((num = rcsnum_alloc()) == NULL)
		return (NULL);

d341 1
a341 3
	if ((brnum = rcsnum_alloc()) == NULL)
		return (NULL);

d365 1
a365 3
	if ((num = rcsnum_alloc()) == NULL)
		return (NULL);

@


1.17
log
@add rcsnum_dec() api call, decreases a revision number by one.
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.16 2005/09/19 15:45:16 niallo Exp $	*/
d53 1
a53 5
	rnp = (RCSNUM *)malloc(sizeof(*rnp));
	if (rnp == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		return (NULL);
	}
d93 2
a94 2
		free(rn->rn_id);
	free(rn);
d144 1
a144 6
	tmp = realloc(ndst->rn_id, sz);
	if (tmp == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		return (-1);
	}

d204 2
a205 7
	if (nump->rn_id == NULL) {
		nump->rn_id = (u_int16_t *)malloc(sizeof(u_int16_t));
		if (nump->rn_id == NULL) {
			rcs_errno = RCS_ERR_ERRNO;
			return (-1);
		}
	}
d221 1
a221 1
			tmp = realloc(nump->rn_id,
a222 2
			if (tmp == NULL)
				goto rcsnum_aton_failed;
d293 1
a293 1
	free(nump->rn_id);
d388 1
a388 6
	tmp = realloc(num->rn_id, len * sizeof(u_int16_t));
	if (tmp == NULL) {
		rcs_errno = RCS_ERR_ERRNO;
		return (-1);
	}

@


1.16
log
@Add preprocessor directives needed for usr.bin/rcs programs to compile.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.15 2005/08/02 11:48:56 joris Exp $	*/
d326 15
@


1.15
log
@handle magic branch numbers.

ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.14 2005/07/25 12:13:08 xsa Exp $	*/
d277 1
d280 3
@


1.14
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.13 2005/07/25 12:05:43 xsa Exp $	*/
d34 1
d211 1
d255 44
@


1.13
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.12 2005/05/31 08:58:48 xsa Exp $	*/
d38 1
a38 1
static int rcsnum_setsize  (RCSNUM *, u_int);
d47 1
a47 1
RCSNUM*
d68 1
a68 1
RCSNUM*
d270 1
a270 1
RCSNUM*
d286 1
a286 1
RCSNUM*
d311 1
a311 1
RCSNUM*
@


1.12
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.11 2005/05/26 01:45:54 jfb Exp $	*/
d108 1
a108 1
char*
@


1.11
log
@add a couple of functions to go from branch numbers to revisions and
vice versa, and fix RCSNUM_ISBRANCH()
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.10 2005/04/13 16:25:02 jfb Exp $	*/
d34 1
a35 1
#include "log.h"
@


1.10
log
@make rcsnum_tostr() return an empty string if the RCSNUM is NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.9 2005/03/05 05:58:39 jfb Exp $	*/
d38 2
d44 2
a45 1
 * Allocate an RCS number structure.
d54 1
a54 1
		cvs_log(LP_ERR, "failed to allocate RCS number");
a62 1

a86 1

a99 1

a127 1

d149 1
a149 1
		cvs_log(LP_ERR, "failed to reallocate RCSNUM");
a158 1

a194 1

d214 1
a214 1
			cvs_log(LP_ERRNO, "failed to allocate RCSNUM");
d228 1
a228 2
				cvs_log(LP_ERR,
				    "RCSNUM exceeds maximum length");
d262 86
@


1.9
log
@add RCS error codes and a global variable to hold the last error
and make the code less verbose at the same time
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.8 2005/02/25 20:32:48 jfb Exp $	*/
d102 4
d114 1
a114 1
	if (nump->rn_len == 0) {
@


1.8
log
@- switch to rcsnum_parse() where appropriate
- make rcsnum_parse() fail if it encounters an invalid character
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.7 2005/02/25 20:05:42 jfb Exp $	*/
d77 3
a79 1
		return (NULL);
d235 1
a235 1
			if (tmp == NULL) {
a236 1
			}
@


1.7
log
@add rcsnum_parse() to simplify the most common case
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.6 2005/01/03 22:10:12 jfb Exp $	*/
d75 1
a75 1
	if (rcsnum_aton(str, &ep, num) < 0) {
@


1.6
log
@limit the maximum length of RCS numbers to 64 nums and avoid
potential integer overflow in case of ridiculously large RCSNUMs
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.5 2004/12/10 19:19:11 jfb Exp $	*/
d62 23
a88 1

@


1.5
log
@proper typecast to get rid of another warning
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.4 2004/12/07 17:10:56 tedu Exp $	*/
d182 1
d188 2
a189 1
		if (nump->rn_id == NULL)
d191 1
d195 1
a195 1
	nump->rn_id[nump->rn_len] = 0;
d202 6
d212 1
a212 4
				free(nump->rn_id);
				nump->rn_len = 0;
				nump->rn_id = NULL;
				return (-1);
d219 7
a225 2
		nump->rn_id[nump->rn_len] *= 10;
		nump->rn_id[nump->rn_len] += *sp - 0x30;
d233 6
@


1.4
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.3 2004/07/29 17:47:50 jfb Exp $	*/
d218 1
a218 1
		*ep = (char *)sp;
@


1.3
log
@Do not error out when calling rcsnum_aton() on the string "0", which is
a valid RCSNUM
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a28 1

a43 1

a79 1

d91 1
a91 1
	snprintf(buf, blen, "%u", nump->rn_id[0]); 
a107 1

a141 1

d152 1
a152 1
		
a178 1

@


1.2
log
@fix memleak on rcsnum reuse
initialize new members to 0
@
text
@a190 3
	if (!isdigit(*str))
		return (-1);

d200 2
a201 5
	for (sp = str; ; sp++) {
		if (!isdigit(*sp) && (*sp != '.')) {
			if (nump->rn_id[nump->rn_len] == 0) {
				return (-1);
			}
a202 1
		}
@


1.1
log
@Initial revision
@
text
@d194 5
a198 3
	nump->rn_id = (u_int16_t *)malloc(sizeof(u_int16_t));
	if (nump->rn_id == NULL)
		return (-1);
d201 1
d222 1
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
