head	1.113;
access;
symbols
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.112.0.4
	OPENBSD_6_0_BASE:1.112
	OPENBSD_5_9:1.112.0.2
	OPENBSD_5_9_BASE:1.112
	OPENBSD_5_8:1.111.0.6
	OPENBSD_5_8_BASE:1.111
	OPENBSD_5_7:1.111.0.2
	OPENBSD_5_7_BASE:1.111
	OPENBSD_5_6:1.110.0.18
	OPENBSD_5_6_BASE:1.110
	OPENBSD_5_5:1.110.0.16
	OPENBSD_5_5_BASE:1.110
	OPENBSD_5_4:1.110.0.12
	OPENBSD_5_4_BASE:1.110
	OPENBSD_5_3:1.110.0.10
	OPENBSD_5_3_BASE:1.110
	OPENBSD_5_2:1.110.0.8
	OPENBSD_5_2_BASE:1.110
	OPENBSD_5_1_BASE:1.110
	OPENBSD_5_1:1.110.0.6
	OPENBSD_5_0:1.110.0.4
	OPENBSD_5_0_BASE:1.110
	OPENBSD_4_9:1.110.0.2
	OPENBSD_4_9_BASE:1.110
	OPENBSD_4_8:1.109.0.2
	OPENBSD_4_8_BASE:1.109
	OPENBSD_4_7:1.107.0.4
	OPENBSD_4_7_BASE:1.107
	OPENBSD_4_6:1.107.0.6
	OPENBSD_4_6_BASE:1.107
	OPENBSD_4_5:1.107.0.2
	OPENBSD_4_5_BASE:1.107
	OPENBSD_4_4:1.105.0.2
	OPENBSD_4_4_BASE:1.105
	OPENBSD_4_3:1.95.0.2
	OPENBSD_4_3_BASE:1.95
	OPENBSD_4_2:1.78.0.2
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.77.0.2
	OPENBSD_4_1_BASE:1.77
	OPENBSD_4_0:1.60.0.2
	OPENBSD_4_0_BASE:1.60
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.113
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.112;
commitid	8Vv7d4HkmCtExfc6;

1.112
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.111;
commitid	O6jeJ0TRmiewrqMI;

1.111
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	Uu5nFG3wCl0LACBb;

1.110
date	2010.11.11.21.00.59;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.23.21.46.04;	author ray;	state Exp;
branches;
next	1.108;

1.108
date	2010.04.04.17.11.11;	author zinovik;	state Exp;
branches;
next	1.107;

1.107
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.106;

1.106
date	2009.01.02.00.11.01;	author canacar;	state Exp;
branches;
next	1.105;

1.105
date	2008.06.15.04.38.52;	author tobias;	state Exp;
branches;
next	1.104;

1.104
date	2008.06.14.04.34.07;	author tobias;	state Exp;
branches;
next	1.103;

1.103
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.102;

1.102
date	2008.06.14.02.34.27;	author tobias;	state Exp;
branches;
next	1.101;

1.101
date	2008.06.14.00.55.31;	author tobias;	state Exp;
branches;
next	1.100;

1.100
date	2008.06.10.01.00.34;	author joris;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.08.02.54.08;	author tobias;	state Exp;
branches;
next	1.98;

1.98
date	2008.05.22.15.45.01;	author tobias;	state Exp;
branches;
next	1.97;

1.97
date	2008.03.09.03.41.55;	author joris;	state Exp;
branches;
next	1.96;

1.96
date	2008.03.08.20.26.34;	author joris;	state Exp;
branches;
next	1.95;

1.95
date	2008.03.01.21.29.36;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.09.20.04.00;	author xsa;	state Exp;
branches;
next	1.93;

1.93
date	2008.02.06.18.12.28;	author tobias;	state Exp;
branches;
next	1.92;

1.92
date	2008.02.04.19.54.21;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2008.02.04.18.23.58;	author tobias;	state Exp;
branches;
next	1.90;

1.90
date	2008.02.04.15.07.32;	author tobias;	state Exp;
branches;
next	1.89;

1.89
date	2008.01.31.10.17.47;	author tobias;	state Exp;
branches;
next	1.88;

1.88
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.87;

1.87
date	2008.01.29.12.22.59;	author tobias;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.10.10.08.22;	author tobias;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.10.09.44.32;	author tobias;	state Exp;
branches;
next	1.84;

1.84
date	2008.01.10.09.41.52;	author tobias;	state Exp;
branches;
next	1.83;

1.83
date	2008.01.10.09.37.26;	author tobias;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.23.11.19.24;	author joris;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.80;

1.80
date	2007.08.30.11.07.18;	author joris;	state Exp;
branches;
next	1.79;

1.79
date	2007.08.29.09.32.13;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.77;

1.77
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.76;

1.76
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.75;

1.75
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.74;

1.74
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.73;

1.73
date	2007.01.27.21.18.17;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2007.01.26.21.48.16;	author xsa;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.26.06.21.51;	author otto;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.13.15.45.59;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.12.19.28.12;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.12.03.34.50;	author joris;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2006.12.20.16.40.27;	author xsa;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.19.15.15.14;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2006.12.19.15.12.59;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2006.12.04.09.51.21;	author xsa;	state Exp;
branches;
next	1.61;

1.61
date	2006.10.31.15.23.40;	author xsa;	state Exp;
branches;
next	1.60;

1.60
date	2006.07.01.12.02.06;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.28.18.52.05;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.06.14.15.14.47;	author xsa;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.07.07.01.12;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.05.02.03.15;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.04.09.52.56;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.01.20.00.52;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.30.21.32.52;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.30.09.11.24;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.30.08.23.31;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.30.07.09.38;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.29.17.55.39;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.29.06.25.06;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.28.17.26.12;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.28.10.15.35;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.28.07.56.44;	author joris;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.27.03.30.30;	author joris;	state dead;
branches;
next	1.41;

1.41
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.27.12.56.28;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.27.12.45.21;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.25.11.19.51;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.30.15.40.22;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.25.17.38.44;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.21.16.30.03;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.15.17.01.10;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.13.17.35.00;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.05.19.49.31;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.30.00.01.50;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.27.17.53.54;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.25.12.42.54;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.10.21.55.30;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.08.16.03.38;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.24.18.30.25;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.24.17.42.26;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.30.20.37.56;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.21.17.50.40;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.21.16.48.39;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.08.20.23.06;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.06.02.19.54;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.09.20.59.07;	author krapht;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.13.13.27.52;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.13.12.59.28;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.30.01.49.21;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.113
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@/*	$OpenBSD: add.c,v 1.112 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

extern char *__progname;

void	cvs_add_loginfo(char *);
void	cvs_add_entry(struct cvs_file *);
void	cvs_add_remote(struct cvs_file *);

static void add_directory(struct cvs_file *);
static void add_file(struct cvs_file *);
static void add_entry(struct cvs_file *);

int		kflag = 0;
static u_int	added_files = 0;
static char	kbuf[8];

extern char	*logmsg;
extern char	*loginfo;

struct cvs_cmd cvs_cmd_add = {
	CVS_OP_ADD, CVS_USE_WDIR, "add",
	{ "ad", "new" },
	"Add a new file or directory to the repository",
	"[-k mode] [-m message] ...",
	"k:m:",
	NULL,
	cvs_add
};

int
cvs_add(int argc, char **argv)
{
	int ch;
	int flags;
	struct cvs_recursion cr;

	flags = CR_REPO;

	while ((ch = getopt(argc, argv, cvs_cmd_add.cmd_opts)) != -1) {
		switch (ch) {
		case 'k':
			kflag = rcs_kflag_get(optarg);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				fatal("%s", cvs_cmd_add.cmd_synopsis);
			}
			(void)xsnprintf(kbuf, sizeof(kbuf), "-k%s", optarg);
			break;
		case 'm':
			logmsg = optarg;
			break;
		default:
			fatal("%s", cvs_cmd_add.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		fatal("%s", cvs_cmd_add.cmd_synopsis);

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_add_remote;
		flags = 0;

		if (kflag)
			cvs_client_send_request("Argument %s", kbuf);

		if (logmsg != NULL)
			cvs_client_send_logmsg(logmsg);
	} else {
		if (logmsg != NULL && cvs_logmsg_verify(logmsg))
			return (0);

		cr.fileproc = cvs_add_local;
	}

	cr.flags = flags;

	cvs_file_run(argc, argv, &cr);

	if (added_files != 0) {
		cvs_log(LP_NOTICE, "use '%s commit' to add %s "
		    "permanently", __progname,
		    (added_files == 1) ? "this file" : "these files");
	}

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_senddir(".");
		cvs_client_send_files(argv, argc);
		cvs_client_send_request("add");
		cvs_client_get_responses();

		if (server_response == SERVER_OK) {
			cr.fileproc = cvs_add_entry;
			cvs_file_run(argc, argv, &cr);
		}
	}

	return (0);
}

void
cvs_add_entry(struct cvs_file *cf)
{
	char *entry;
	CVSENTRIES *entlist;

	if (cf->file_type == CVS_DIR) {
		entry = xmalloc(CVS_ENT_MAXLINELEN);
		cvs_ent_line_str(cf->file_name, NULL, NULL, NULL, NULL, 1, 0,
		    entry, CVS_ENT_MAXLINELEN);

		entlist = cvs_ent_open(cf->file_wd);
		cvs_ent_add(entlist, entry);

		free(entry);
	} else {
		add_entry(cf);
	}
}

void
cvs_add_local(struct cvs_file *cf)
{
	cvs_log(LP_TRACE, "cvs_add_local(%s)", cf->file_path);

	if (cvs_cmdop != CVS_OP_CHECKOUT && cvs_cmdop != CVS_OP_UPDATE)
		cvs_file_classify(cf, cvs_directory_tag);

	/* dont use `cvs add *' */
	if (strcmp(cf->file_name, ".") == 0 ||
	    strcmp(cf->file_name, "..") == 0 ||
	    strcmp(cf->file_name, CVS_PATH_CVSDIR) == 0) {
		if (verbosity > 1)
			cvs_log(LP_ERR,
			    "cannot add special file `%s'; skipping",
			    cf->file_name);
		return;
	}

	if (cf->file_type == CVS_DIR)
		add_directory(cf);
	else
		add_file(cf);
}

void
cvs_add_remote(struct cvs_file *cf)
{
	char path[PATH_MAX];

	cvs_log(LP_TRACE, "cvs_add_remote(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_type == CVS_DIR) {
		cvs_get_repository_path(cf->file_wd, path, PATH_MAX);
		if (strlcat(path, "/", sizeof(path)) >= sizeof(path))
			fatal("cvs_add_remote: truncation");
		if (strlcat(path, cf->file_path, sizeof(path)) >= sizeof(path))
			fatal("cvs_add_remote: truncation");
		cvs_client_send_request("Directory %s\n%s", cf->file_path,
		    path);

		add_directory(cf);
	} else {
		cvs_client_sendfile(cf);
	}
}

void
cvs_add_loginfo(char *repo)
{
	BUF *buf;
	char pwd[PATH_MAX];

	if (getcwd(pwd, sizeof(pwd)) == NULL)
		fatal("Can't get working directory");

	buf = buf_alloc(1024);

	cvs_trigger_loginfo_header(buf, repo);

	buf_puts(buf, "Log Message:\nDirectory ");
	buf_puts(buf, current_cvsroot->cr_dir);
	buf_putc(buf, '/');
	buf_puts(buf, repo);
	buf_puts(buf, " added to the repository\n");

	buf_putc(buf, '\0');

	loginfo = buf_release(buf);
}

void
cvs_add_tobranch(struct cvs_file *cf, char *tag)
{
	BUF *bp;
	char attic[PATH_MAX], repo[PATH_MAX];
	char *msg;
	struct stat st;
	RCSNUM *branch;

	cvs_log(LP_TRACE, "cvs_add_tobranch(%s)", cf->file_name);

	if (cvs_noexec == 1)
		return;

	if (fstat(cf->fd, &st) == -1)
		fatal("cvs_add_tobranch: %s", strerror(errno));

	cvs_get_repository_path(cf->file_wd, repo, PATH_MAX);
	(void)xsnprintf(attic, PATH_MAX, "%s/%s",
	    repo, CVS_PATH_ATTIC);

	if (mkdir(attic, 0755) == -1 && errno != EEXIST)
		fatal("cvs_add_tobranch: failed to create Attic");

	(void)xsnprintf(attic, PATH_MAX, "%s/%s/%s%s", repo,
	    CVS_PATH_ATTIC, cf->file_name, RCS_FILE_EXT);

	free(cf->file_rpath);
	cf->file_rpath = xstrdup(attic);

	cf->repo_fd = open(cf->file_rpath, O_CREAT|O_RDONLY);
	if (cf->repo_fd < 0)
		fatal("cvs_add_tobranch: %s: %s", cf->file_rpath,
		    strerror(errno));

	cf->file_rcs = rcs_open(cf->file_rpath, cf->repo_fd,
	    RCS_CREATE|RCS_WRITE, 0444);
	if (cf->file_rcs == NULL)
		fatal("cvs_add_tobranch: failed to create RCS file for %s",
		    cf->file_path);

	if ((branch = rcsnum_parse("1.1.2")) == NULL)
		fatal("cvs_add_tobranch: failed to parse branch");

	if (rcs_sym_add(cf->file_rcs, tag, branch) == -1)
		fatal("cvs_add_tobranch: failed to add vendor tag");

	(void)xasprintf(&msg, "file %s was initially added on branch %s.",
	    cf->file_name, tag);
	if (rcs_rev_add(cf->file_rcs, RCS_HEAD_REV, msg, -1, NULL) == -1)
		fatal("cvs_add_tobranch: failed to create first branch "
		    "revision");
	free(msg);

	if (rcs_findrev(cf->file_rcs, cf->file_rcs->rf_head) == NULL)
		fatal("cvs_add_tobranch: cannot find newly added revision");

	bp = buf_alloc(1);

	if (rcs_deltatext_set(cf->file_rcs,
	    cf->file_rcs->rf_head, bp) == -1)
		fatal("cvs_add_tobranch: failed to set deltatext");

	rcs_comment_set(cf->file_rcs, " * ");

	if (rcs_state_set(cf->file_rcs, cf->file_rcs->rf_head, RCS_STATE_DEAD)
	    == -1)
		fatal("cvs_add_tobranch: failed to set state");
}

static void
add_directory(struct cvs_file *cf)
{
	int added, nb;
	struct stat st;
	CVSENTRIES *entlist;
	char *date, entry[PATH_MAX], msg[1024], repo[PATH_MAX], *tag, *p;
	struct file_info_list files_info;
	struct file_info *fi;
	struct trigger_list *line_list;

	cvs_log(LP_TRACE, "add_directory(%s)", cf->file_path);

	(void)xsnprintf(entry, PATH_MAX, "%s%s",
	    cf->file_rpath, RCS_FILE_EXT);

	added = 1;
	if (stat(entry, &st) != -1) {
		cvs_log(LP_NOTICE, "cannot add directory %s: "
		    "a file with that name already exists",
		    cf->file_path);
		added = 0;
	} else {
		/* Let's see if we have any per-directory tags first. */
		cvs_parse_tagfile(cf->file_wd, &tag, &date, &nb);

		(void)xsnprintf(entry, PATH_MAX, "%s/%s",
		    cf->file_path, CVS_PATH_CVSDIR);

		if (cvs_server_active) {
			if (mkdir(cf->file_rpath, 0755) == -1 &&
			    errno != EEXIST)
				fatal("add_directory: %s: %s", cf->file_rpath,
				    strerror(errno));
		} else if (stat(entry, &st) != -1) {
			if (!S_ISDIR(st.st_mode)) {
				cvs_log(LP_ERR, "%s exists but is not "
				    "directory", entry);
			} else {
				cvs_log(LP_NOTICE, "%s already exists",
				    entry);
			}
			added = 0;
		} else if (cvs_noexec != 1) {
			if (mkdir(cf->file_rpath, 0755) == -1 &&
			    errno != EEXIST)
				fatal("add_directory: %s: %s", cf->file_rpath,
				    strerror(errno));

			cvs_get_repository_name(cf->file_wd, repo,
			    PATH_MAX);

			(void)xsnprintf(entry, PATH_MAX, "%s/%s",
			    repo, cf->file_name);

			cvs_mkadmin(cf->file_path, current_cvsroot->cr_dir,
			    entry, tag, date);

			p = xmalloc(CVS_ENT_MAXLINELEN);
			cvs_ent_line_str(cf->file_name, NULL, NULL, NULL,
			    NULL, 1, 0, p, CVS_ENT_MAXLINELEN);

			entlist = cvs_ent_open(cf->file_wd);
			cvs_ent_add(entlist, p);
			free(p);
		}
	}

	if (added == 1 && current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
		(void)xsnprintf(msg, sizeof(msg),
		    "Directory %s added to the repository", cf->file_rpath);

		if (tag != NULL) {
			(void)strlcat(msg,
			    "\n--> Using per-directory sticky tag ",
			    sizeof(msg));
			(void)strlcat(msg, tag, sizeof(msg));
		}
		if (date != NULL) {
			(void)strlcat(msg,
			    "\n--> Using per-directory sticky date ",
			    sizeof(msg));
			(void)strlcat(msg, date, sizeof(msg));
		}
		cvs_printf("%s\n", msg);

		free(tag);
		free(date);

		cvs_get_repository_name(cf->file_path, repo, PATH_MAX);
		line_list = cvs_trigger_getlines(CVS_PATH_LOGINFO, repo);
		if (line_list != NULL) {
			TAILQ_INIT(&files_info);
			fi = xcalloc(1, sizeof(*fi));
			fi->file_path = xstrdup(cf->file_path);
			TAILQ_INSERT_TAIL(&files_info, fi, flist);

			cvs_add_loginfo(repo);
			cvs_trigger_handle(CVS_TRIGGER_LOGINFO, repo,
			    loginfo, line_list, &files_info);

			cvs_trigger_freeinfo(&files_info);
			cvs_trigger_freelist(line_list);
			free(loginfo);
		}
	}

	cf->file_status = FILE_SKIP;
}

static void
add_file(struct cvs_file *cf)
{
	int nb, stop;
	char revbuf[CVS_REV_BUFSZ];
	RCSNUM *head = NULL;
	char *tag;

	cvs_parse_tagfile(cf->file_wd, &tag, NULL, &nb);
	if (nb) {
		cvs_log(LP_ERR, "cannot add file on non-branch tag %s", tag);
		return;
	}

	if (cf->file_rcs != NULL) {
		head = rcs_head_get(cf->file_rcs);
		if (head == NULL) {
			cvs_log(LP_NOTICE, "no head revision in RCS file for "
			    "%s", cf->file_path);
		}
		rcsnum_tostr(head, revbuf, sizeof(revbuf));
	}

	stop = 0;
	switch (cf->file_status) {
	case FILE_ADDED:
	case FILE_CHECKOUT:
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "%s has already been entered",
			    cf->file_path);
		stop = 1;
		break;
	case FILE_REMOVED:
		if (cf->file_rcs == NULL) {
			cvs_log(LP_NOTICE, "cannot resurrect %s; "
			    "RCS file removed by second party", cf->file_name);
		} else if (!(cf->file_flags & FILE_ON_DISK)) {
			add_entry(cf);

			/* Restore the file. */
			cvs_checkout_file(cf, head, NULL, 0);

			cvs_printf("U %s\n", cf->file_path);

			cvs_log(LP_NOTICE, "%s, version %s, resurrected",
			    cf->file_name, revbuf);

			cf->file_status = FILE_UPTODATE;
		}
		stop = 1;
		break;
	case FILE_CONFLICT:
	case FILE_LOST:
	case FILE_MODIFIED:
	case FILE_UPTODATE:
		if (cf->file_rcs != NULL && cf->file_rcs->rf_dead == 0) {
			cvs_log(LP_NOTICE, "%s already exists, with version "
			     "number %s", cf->file_path, revbuf);
			stop = 1;
		}
		break;
	case FILE_UNKNOWN:
		if (cf->file_rcs != NULL && cf->file_rcs->rf_dead == 1) {
			cvs_log(LP_NOTICE, "re-adding file %s "
			    "(instead of dead revision %s)",
			    cf->file_path, revbuf);
			added_files++;
		} else if (cf->file_flags & FILE_ON_DISK) {
			cvs_log(LP_NOTICE, "scheduling file '%s' for addition",
			    cf->file_path);
			added_files++;
		} else {
			stop = 1;
		}
		break;
	default:
		break;
	}

	free(head);

	if (stop == 1)
		return;

	add_entry(cf);
}

static void
add_entry(struct cvs_file *cf)
{
	FILE *fp;
	char *entry, path[PATH_MAX];
	char revbuf[CVS_REV_BUFSZ], tbuf[CVS_TIME_BUFSZ];
	char sticky[CVS_ENT_MAXLINELEN];
	CVSENTRIES *entlist;

	if (cvs_noexec == 1)
		return;

	sticky[0] = '\0';
	entry = xmalloc(CVS_ENT_MAXLINELEN);

	if (cf->file_status == FILE_REMOVED) {
		rcsnum_tostr(cf->file_ent->ce_rev, revbuf, sizeof(revbuf));

		ctime_r(&cf->file_ent->ce_mtime, tbuf);
		tbuf[strcspn(tbuf, "\n")] = '\0';

		if (cf->file_ent->ce_tag != NULL)
			(void)xsnprintf(sticky, sizeof(sticky), "T%s",
			    cf->file_ent->ce_tag);

		/* Remove the '-' prefixing the version number. */
		cvs_ent_line_str(cf->file_name, revbuf, tbuf,
		    cf->file_ent->ce_opts ? cf->file_ent->ce_opts : "", sticky,
		    0, 0, entry, CVS_ENT_MAXLINELEN);
	} else {
		if (logmsg != NULL) {
			(void)xsnprintf(path, PATH_MAX, "%s/%s/%s%s",
			    cf->file_wd, CVS_PATH_CVSDIR, cf->file_name,
			    CVS_DESCR_FILE_EXT);

			if ((fp = fopen(path, "w+")) == NULL)
				fatal("add_entry: fopen `%s': %s",
				    path, strerror(errno));

			if (fputs(logmsg, fp) == EOF) {
				(void)unlink(path);
				fatal("add_entry: fputs `%s': %s",
				    path, strerror(errno));
			}
			(void)fclose(fp);
		}

		if (cvs_directory_tag != NULL)
			(void)xsnprintf(sticky, sizeof(sticky), "T%s",
			    cvs_directory_tag);

		tbuf[0] = '\0';
		if (!cvs_server_active)
			(void)xsnprintf(tbuf, sizeof(tbuf), "Initial %s",
			    cf->file_name);

		cvs_ent_line_str(cf->file_name, "0", tbuf, kflag ? kbuf : "",
		    sticky, 0, 0, entry, CVS_ENT_MAXLINELEN);
	}

	if (cvs_server_active) {
		cvs_server_send_response("Checked-in %s/", cf->file_wd);
		cvs_server_send_response("%s", cf->file_path);
		cvs_server_send_response("%s", entry);
	} else {
		entlist = cvs_ent_open(cf->file_wd);
		cvs_ent_add(entlist, entry);
	}
	free(entry);
}
@


1.112
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.111 2015/01/16 06:40:06 deraadt Exp $	*/
d488 1
a488 2
	if (head != NULL)
		rcsnum_free(head);
@


1.111
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.110 2010/11/11 21:00:59 nicm Exp $	*/
d23 1
d150 1
a150 1
		xfree(entry);
d256 1
a256 1
	xfree(cf->file_rpath);
d281 1
a281 1
	xfree(msg);
d363 1
a363 1
			xfree(p);
d385 2
a386 4
		if (tag != NULL)
			xfree(tag);
		if (date != NULL)
			xfree(date);
d402 1
a402 2
			if (loginfo != NULL)
				xfree(loginfo);
d565 1
a565 1
	xfree(entry);
@


1.110
log
@Nuke dead assignments and a dead function, from Michael W Bombardieri
using lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.109 2010/07/23 21:46:04 ray Exp $	*/
d183 1
a183 1
	char path[MAXPATHLEN];
d190 1
a190 1
		cvs_get_repository_path(cf->file_wd, path, MAXPATHLEN);
d208 1
a208 1
	char pwd[MAXPATHLEN];
d232 1
a232 1
	char attic[MAXPATHLEN], repo[MAXPATHLEN];
d245 2
a246 2
	cvs_get_repository_path(cf->file_wd, repo, MAXPATHLEN);
	(void)xsnprintf(attic, MAXPATHLEN, "%s/%s",
d252 1
a252 1
	(void)xsnprintf(attic, MAXPATHLEN, "%s/%s/%s%s", repo,
d304 1
a304 1
	char *date, entry[MAXPATHLEN], msg[1024], repo[MAXPATHLEN], *tag, *p;
d311 1
a311 1
	(void)xsnprintf(entry, MAXPATHLEN, "%s%s",
d324 1
a324 1
		(void)xsnprintf(entry, MAXPATHLEN, "%s/%s",
d348 1
a348 1
			    MAXPATHLEN);
d350 1
a350 1
			(void)xsnprintf(entry, MAXPATHLEN, "%s/%s",
d389 1
a389 1
		cvs_get_repository_name(cf->file_path, repo, MAXPATHLEN);
d503 1
a503 1
	char *entry, path[MAXPATHLEN];
d530 1
a530 1
			(void)xsnprintf(path, MAXPATHLEN, "%s/%s/%s%s",
@


1.109
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.108 2010/04/04 17:11:11 zinovik Exp $	*/
a234 1
	struct rcs_delta *rdp;
d282 1
a282 1
	if ((rdp = rcs_findrev(cf->file_rcs, cf->file_rcs->rf_head)) == NULL)
@


1.108
log
@OpenCVS is very annoying and incorrect when user tries to add several
files at a time.

OpenCVS does the following:
# touch a b c
# opencvs add a b c
opencvs add: scheduling file 'a' for addition
opencvs add: use 'opencvs commit' to add this file permanently
opencvs add: scheduling file 'b' for addition
opencvs add: use 'opencvs commit' to add this file permanently
opencvs add: scheduling file 'c' for addition
opencvs add: use 'opencvs commit' to add this file permanently

This behaviour was added in -r 1.48 of add.c file.

This commit makes OpenCVS behave like GNU cvs:
# touch a b c
# opencvs add a b c
opencvs add: scheduling file 'a' for addition
opencvs add: scheduling file 'b' for addition
opencvs add: scheduling file 'c' for addition
opencvs add: use 'opencvs commit' to add these files permanently

ok deraadt@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.107 2009/02/21 14:50:53 joris Exp $	*/
d213 1
a213 1
	buf = cvs_buf_alloc(1024);
d217 5
a221 5
	cvs_buf_puts(buf, "Log Message:\nDirectory ");
	cvs_buf_puts(buf, current_cvsroot->cr_dir);
	cvs_buf_putc(buf, '/');
	cvs_buf_puts(buf, repo);
	cvs_buf_puts(buf, " added to the repository\n");
d223 1
a223 1
	cvs_buf_putc(buf, '\0');
d225 1
a225 1
	loginfo = cvs_buf_release(buf);
d286 1
a286 1
	bp = cvs_buf_alloc(1);
@


1.107
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.106 2009/01/02 00:11:01 canacar Exp $	*/
d40 1
d114 6
d415 1
a415 1
	int added, nb, stop;
d435 1
a435 1
	added = stop = 0;
d478 1
a478 1
			added++;
d482 1
a482 1
			added++;
a497 6

	if (added != 0) {
		cvs_log(LP_NOTICE, "use '%s commit' to add %s "
		    "permanently", __progname,
		    (added == 1) ? "this file" : "these files");
	}
@


1.106
log
@Add format attributes to functions that use variable arguments and
make the code -Wformat=2 clean. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.105 2008/06/15 04:38:52 tobias Exp $	*/
d441 1
a441 1
		} else if (cf->fd == -1) {
d472 1
a472 1
		} else if (cf->fd != -1) {
@


1.105
log
@Support the addition of new files in branches.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.104 2008/06/14 04:34:07 tobias Exp $	*/
d561 2
a562 2
		cvs_server_send_response(cf->file_path);
		cvs_server_send_response(entry);
@


1.104
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.103 2008/06/14 03:19:15 joris Exp $	*/
d22 1
d219 71
@


1.103
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.102 2008/06/14 02:34:27 tobias Exp $	*/
d338 1
a338 1
	RCSNUM *head;
d349 4
a352 3
		if (head == NULL)
			fatal("RCS head empty or missing in %s",
			    cf->file_rcs->rf_path);
a353 1
		rcsnum_free(head);
a372 4
			head = rcs_head_get(cf->file_rcs);
			if (head == NULL)
				fatal("RCS head empty or missing in %s",
				    cf->file_rcs->rf_path);
a373 1
			rcsnum_free(head);
d411 3
@


1.102
log
@No need to add \n at the end of format string for a fatal call.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.101 2008/06/14 00:55:31 tobias Exp $	*/
a139 1
		cvs_ent_close(entlist, ENT_SYNC);
a283 1
			cvs_ent_close(entlist, ENT_SYNC);
a495 1
		cvs_ent_close(entlist, ENT_SYNC);
@


1.101
log
@Don't trick user into believing that it's actually possible to add a file
to repository which is even ready to be checked out.

"probably right" joris
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.100 2008/06/10 01:00:34 joris Exp $	*/
d352 1
a352 1
			fatal("RCS head empty or missing in %s\n",
d377 1
a377 1
				fatal("RCS head empty or missing in %s\n",
@


1.100
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.99 2008/06/08 02:54:08 tobias Exp $	*/
d361 1
@


1.99
log
@Properly build up path to description files (descr entry in RCS files if
you add a file with -m message).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.98 2008/05/22 15:45:01 tobias Exp $	*/
d30 1
d41 2
a42 1
char	*logmsg;
d102 3
d197 24
d228 3
d312 18
@


1.98
log
@expension -> expansion

ok joris, xsa (quite some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.97 2008/03/09 03:41:55 joris Exp $	*/
d411 3
a413 2
			(void)xsnprintf(path, MAXPATHLEN, "%s/%s%s",
			    CVS_PATH_CVSDIR, cf->file_name, CVS_DESCR_FILE_EXT);
@


1.97
log
@do not use CR_REPO in a remote setup, that will obviously fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.96 2008/03/08 20:26:34 joris Exp $	*/
d67 1
a67 1
				    "invalid RCS keyword expension mode");
@


1.96
log
@add checkout/update -j support.
still has some rough edges.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.95 2008/03/01 21:29:36 deraadt Exp $	*/
d92 1
@


1.95
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.94 2008/02/09 20:04:00 xsa Exp $	*/
a29 1
void	cvs_add_local(struct cvs_file *);
d147 2
a148 1
	cvs_file_classify(cf, cvs_directory_tag);
@


1.94
log
@Introduce cvs_ent_line_str() - formats CVS/Entries lines.
OK tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.93 2008/02/06 18:12:28 tobias Exp $	*/
a433 1
		
@


1.93
log
@Improve add command:

* fix server-side add
* support add in branches
* do not add files in N-tagged directories

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.92 2008/02/04 19:54:21 joris Exp $	*/
d125 1
a125 1
	char entry[CVS_ENT_MAXLINELEN];
d129 3
a131 2
		(void)xsnprintf(entry, CVS_ENT_MAXLINELEN,
		    "D/%s////", cf->file_name);
d136 2
d247 3
a249 2
			(void)xsnprintf(p, CVS_ENT_MAXLINELEN,
			    "D/%s////", cf->file_name);
d383 1
a383 1
	char entry[CVS_ENT_MAXLINELEN], path[MAXPATHLEN];
d392 1
d405 3
a407 3
		(void)xsnprintf(entry, CVS_ENT_MAXLINELEN,
		    "/%s/%s/%s/%s/%s", cf->file_name, revbuf, tbuf,
		    cf->file_ent->ce_opts ? cf->file_ent->ce_opts : "", sticky);
d434 3
a436 3
		(void)xsnprintf(entry, CVS_ENT_MAXLINELEN,
		    "/%s/0/%s/%s/%s", cf->file_name, tbuf, kflag ? kbuf : "",
		    sticky);
d448 1
@


1.92
log
@unbreak add in a remote setup.
bad tobias, no cookie.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.91 2008/02/04 18:23:58 tobias Exp $	*/
d283 1
a283 1
	int added, stop;
d286 7
d381 1
d387 2
d395 4
d401 2
a402 2
		    "/%s/%s/%s/%s/", cf->file_name, revbuf, tbuf,
		    cf->file_ent->ce_opts ? cf->file_ent->ce_opts : "");
d420 9
d430 2
a431 2
		    "/%s/0/Initial %s/%s/", cf->file_name, cf->file_name,
		    kflag ? kbuf : "");
@


1.91
log
@Stripped off 'nb', which was (or was supposed to be) used to distinguish
between a named branch and a revision number supplied by -r.  This can
be done easier in cvs_write_tagfile directly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.90 2008/02/04 15:07:32 tobias Exp $	*/
d94 1
a94 1
		if (kflag);
@


1.90
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.89 2008/01/31 10:17:47 tobias Exp $	*/
d241 1
a241 1
			    entry, tag, date, nb);
@


1.89
log
@Our directory entries in CVS/Entries had one slash too much -- zapped.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.88 2008/01/31 10:15:05 tobias Exp $	*/
d38 2
a39 2
static int	 kflag = RCS_KWEXP_DEFAULT;
static char	 kbuf[8], *koptstr;
d65 1
a65 2
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
d71 1
a71 1
			(void)xsnprintf(kbuf, sizeof(kbuf), "-k%s", koptstr);
d94 1
a94 1
		if (kflag != RCS_KWEXP_DEFAULT)
d408 1
a408 1
		    (kflag != RCS_KWEXP_DEFAULT) ? kbuf : "");
@


1.88
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.87 2008/01/29 12:22:59 tobias Exp $	*/
d131 1
a131 1
		    "D/%s/////", cf->file_name);
d246 1
a246 1
			    "D/%s/////", cf->file_name);
@


1.87
log
@There is no need to xstrdup() optarg.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.86 2008/01/10 10:08:22 tobias Exp $	*/
d44 1
a44 1
	CVS_OP_ADD, 0, "add",
@


1.86
log
@another strcspn() round
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.85 2008/01/10 09:44:32 tobias Exp $	*/
d75 1
a75 1
			logmsg = xstrdup(optarg);
@


1.85
log
@Handle the addition of directories right, especially in remote setups with
GNU cvs as a server.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.84 2008/01/10 09:41:52 tobias Exp $	*/
d384 1
a384 2
		if (tbuf[strlen(tbuf) - 1] == '\n')
			tbuf[strlen(tbuf) - 1] = '\0';
@


1.84
log
@Properly handle "cvs add" on a client/server setup with GNU cvs as a client.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.83 2008/01/10 09:37:26 tobias Exp $	*/
d32 1
d93 1
a93 1
		cr.fileproc = cvs_client_sendfile;
d109 1
a110 1
		cvs_client_senddir(".");
d165 24
d215 6
a220 1
		if (stat(entry, &st) != -1) {
d232 1
a232 1
				fatal("add_directory: %s: %s", cf->file_path,
d254 1
a254 1
	if (added == 1) {
@


1.83
log
@RCS files without head keyword mustn't segfault our implementation.  Only
command that supports such files is "cvs status", therefore properly handle
them in all other commands, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.82 2007/09/23 11:19:24 joris Exp $	*/
d383 9
a391 3
	entlist = cvs_ent_open(cf->file_wd);
	cvs_ent_add(entlist, entry);
	cvs_ent_close(entlist, ENT_SYNC);
@


1.82
log
@make sure when running update -r on existing files to overwrite
the sticky directory tag with it. since -r gets priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.81 2007/09/22 16:01:22 joris Exp $	*/
d260 3
d284 3
@


1.81
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.80 2007/08/30 11:07:18 joris Exp $	*/
d281 1
a281 1
			cvs_checkout_file(cf, head, 0);
@


1.80
log
@properly send our log message to the server using Argumentx, so we
no longer break when the log message has multiple lines.

from Tobias Stoeckmann, thanks for doing my work!
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.79 2007/08/29 09:32:13 joris Exp $	*/
d145 1
a145 1
	cvs_file_classify(cf, NULL);
@


1.79
log
@missing xfree();
from Igor Zinovik, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.78 2007/06/28 21:38:09 xsa Exp $	*/
d98 1
a98 1
			cvs_client_send_request("Argument -m%s", logmsg);
@


1.78
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.77 2007/02/22 06:42:09 otto Exp $	*/
d220 1
@


1.77
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.76 2007/02/17 18:23:43 xsa Exp $	*/
d254 1
a254 1
	char revbuf[16];
d336 2
a337 1
	char entry[CVS_ENT_MAXLINELEN], path[MAXPATHLEN], revbuf[16], tbuf[32];
@


1.76
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.75 2007/02/09 03:49:15 joris Exp $	*/
d19 5
a23 1
#include "includes.h"
a25 2
#include "diff.h"
#include "log.h"
@


1.75
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.74 2007/01/31 21:07:35 xsa Exp $	*/
d185 2
a186 3
		if (cvs_path_cat(cf->file_path, CVS_PATH_CVSDIR,
		    entry, MAXPATHLEN) >= MAXPATHLEN)
			fatal("add_directory: truncation");
d206 2
a207 3
			if (cvs_path_cat(repo, cf->file_name, entry,
			    MAXPATHLEN) >= MAXPATHLEN)
				fatal("add_directory: truncation");
@


1.74
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.73 2007/01/27 21:18:17 joris Exp $	*/
d143 1
a143 1
	cvs_file_classify(cf, NULL, 1);
@


1.73
log
@- do not try to add non-existing files
- do not overwrite the contents of the file when the file was removed
and you try to re-add it.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.72 2007/01/26 21:48:16 xsa Exp $	*/
d69 1
a69 1
			snprintf(kbuf, sizeof(kbuf), "-k%s", koptstr);
a122 1
	int l;
d127 2
a128 4
		l = snprintf(entry, CVS_ENT_MAXLINELEN,
			    "D/%s/////", cf->file_name);
		if (l == -1 || l >= CVS_ENT_MAXLINELEN)
			fatal("cvs_add_entry: overflow");
d165 1
a165 1
	int l, added, nb;
d172 2
a173 3
	l = snprintf(entry, MAXPATHLEN, "%s%s", cf->file_rpath, RCS_FILE_EXT);
	if (l == -1 || l >= MAXPATHLEN)
		fatal("cvs_add_local: overflow");
d215 1
a215 1
			l = snprintf(p, CVS_ENT_MAXLINELEN,
d224 1
a224 1
		snprintf(msg, sizeof(msg),
a335 1
	int l;
d350 1
a350 1
		l = snprintf(entry, CVS_ENT_MAXLINELEN,
a352 2
		if (l == -1 || l >= CVS_ENT_MAXLINELEN)
               		fatal("add_entry: truncation");
d355 1
a355 1
			l = snprintf(path, MAXPATHLEN, "%s/%s%s",
a356 2
			if (l == -1 || l >= MAXPATHLEN)
               			fatal("add_entry: truncation");
d370 1
a370 1
		l = snprintf(entry, CVS_ENT_MAXLINELEN,
a372 2
		if (l == -1 || l >= CVS_ENT_MAXLINELEN)
               		fatal("add_entry: truncation");
@


1.72
log
@- support [-k mode] for the add command
- do not let the file keyword expension options (-k) disappear
from the Entries file when doing a commit/update/checkout
- be sure the expension mode gets written to the RCS file when a file
is added/committed in the first place
problems raised by otto@@; tests/ok otto@@ and joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.71 2007/01/26 06:21:51 otto Exp $	*/
d146 1
a146 1
	cvs_file_classify(cf, NULL, 0);
d279 1
a279 1
		} else {
d311 2
a312 1
		} else {
d315 3
a318 1
		added++;
@


1.71
log
@extra xfree leftover; from tbert.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.70 2007/01/25 18:56:33 otto Exp $	*/
d35 3
d44 2
a45 2
	"[-m message] ...",
	"m:",
d61 10
d92 3
d353 2
a354 1
		    "/%s/%s/%s//", cf->file_name, revbuf, tbuf);
d376 3
a378 2
		l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/0/Initial %s//",
		    cf->file_name, cf->file_name);
@


1.70
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.69 2007/01/13 15:45:59 joris Exp $	*/
a235 1
	xfree(entry);
@


1.69
log
@remove BUF * argument from cvs_checkout_file() it will
no longer be used, ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.68 2007/01/12 19:28:12 joris Exp $	*/
d108 1
a108 1
	char *entry;
a111 1
		entry = xmalloc(CVS_ENT_MAXLINELEN);
a119 1
		xfree(entry);
d155 1
a155 1
	char *date, *entry, msg[1024], *repo, *tag;
a158 1
	entry = xmalloc(MAXPATHLEN);
a191 1
			repo = xmalloc(MAXPATHLEN);
d202 2
a203 5
			xfree(repo);
			xfree(entry);

			entry = xmalloc(CVS_ENT_MAXLINELEN);
			l = snprintf(entry, CVS_ENT_MAXLINELEN,
d206 1
a206 1
			cvs_ent_add(entlist, entry);
d323 1
a323 1
	char *entry, *path, revbuf[16], tbuf[32];
a328 2
	entry = xmalloc(CVS_ENT_MAXLINELEN);

a342 2
			path = xmalloc(MAXPATHLEN);

a357 1
			xfree(path);
a368 2

	xfree(entry);
@


1.68
log
@do not leak memory from rcs_head_get()

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.67 2007/01/12 03:34:50 joris Exp $	*/
a248 1
	BUF *b;
d276 1
a276 1
			b = rcs_getrev(cf->file_rcs, head);
a278 4
			if (b == NULL)
				fatal("cvs_add_local: failed to get HEAD");

			cvs_checkout_file(cf, head, b, 0);
@


1.67
log
@fix incorrect output which was driving me more then crazy
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.66 2007/01/11 02:35:55 joris Exp $	*/
d254 5
a258 3
	if (cf->file_rcs != NULL)
		rcsnum_tostr(rcs_head_get(cf->file_rcs),
		    revbuf, sizeof(revbuf));
d278 2
@


1.66
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.65 2006/12/20 16:40:27 xsa Exp $	*/
d320 3
a322 4
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "use '%s commit' to add %s "
			    "permanently", __progname,
			    (added == 1) ? "this file" : "these files");
@


1.65
log
@missing xfree();
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.64 2006/12/19 15:15:14 joris Exp $	*/
d76 1
@


1.64
log
@correctly check snprintf(), noticed by ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.63 2006/12/19 15:12:59 joris Exp $	*/
d120 1
@


1.63
log
@- Introduce a way for the command code to recognize what the server replied.
- Modify the add command so it uses the above method to correctly enter
  added files in CVS/Entries if in a remote setup.

ok xsa@@

... And no a shark didnt eat me.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.62 2006/12/04 09:51:21 xsa Exp $	*/
d114 3
@


1.62
log
@snprintf() -> cvs_path_cat()
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.61 2006/10/31 15:23:40 xsa Exp $	*/
d29 1
d93 5
d101 19
@


1.61
log
@a step ahead in opencvs add|remove remote support.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.60 2006/07/01 12:02:06 reyk Exp $	*/
d146 3
a148 4
		l = snprintf(entry, MAXPATHLEN, "%s/%s", cf->file_path,
		    CVS_PATH_CVSDIR);
		if (l == -1 || l >= MAXPATHLEN)
			fatal("add_directory: overflow");
d169 3
a171 2
			l = snprintf(entry, MAXPATHLEN, "%s/%s", repo,
			    cf->file_name);
@


1.60
log
@fix a possible bug of pathname concatenation when adding subdirectories.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.59 2006/06/28 18:52:05 reyk Exp $	*/
d24 1
a27 1
int	cvs_add(int, char **);
d73 10
a82 1
	cr.fileproc = cvs_add_local;
d86 8
@


1.59
log
@print less verbose messages for cvs commit and add if the -q/-Q flag
has been specified.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.58 2006/06/19 05:05:17 joris Exp $	*/
d154 1
a154 1
			    cf->file_path);
@


1.58
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.57 2006/06/16 14:07:42 joris Exp $	*/
d273 1
a273 1
		if (verbosity > 0)
@


1.57
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.56 2006/06/14 15:14:47 xsa Exp $	*/
d73 1
a73 2
	cr.local = cvs_add_local;
	cr.remote = NULL;
@


1.56
log
@handle existing CVS/Tag file when adding new directories. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.55 2006/06/07 07:01:12 xsa Exp $	*/
a23 1
#include "proto.h"
d37 1
a37 1
	CVS_OP_ADD, CVS_REQ_ADD, "add",
@


1.55
log
@add support for <name>,t file:
- add: creates <name>,t file with initial description if -m option was used.
- commit: uses <name>,t content (if it exists) to set the file description
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.54 2006/06/05 02:03:15 joris Exp $	*/
d109 1
a109 1
	int l, added;
d112 1
a112 1
	char *entry, *repo;
d128 3
d159 1
a159 1
			    entry);
d174 21
a194 2
		cvs_printf("Directory %s added to the repository\n",
		    cf->file_rpath);
@


1.54
log
@allow the re-adding of files with previous revisions
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.53 2006/06/04 09:52:56 joris Exp $	*/
d4 1
d33 1
d183 2
a184 2
	int added, l, stop;
	char *entry, revbuf[16], tbuf[32];
a185 1
	CVSENTRIES *entlist;
d203 2
a204 23
		} else if (cvs_noexec != 1) {
			/*
			 * Remove the '-' prefixing the version number and
			 * restore the file.
			 */
			rcsnum_tostr(cf->file_ent->ce_rev, revbuf,
			    sizeof(revbuf));

			ctime_r(&cf->file_ent->ce_mtime, tbuf);
			if (tbuf[strlen(tbuf) - 1] == '\n')
				tbuf[strlen(tbuf) - 1] = '\0';

			entry = xmalloc(CVS_ENT_MAXLINELEN);
			l = snprintf(entry, CVS_ENT_MAXLINELEN,
			    "/%s/%s/%s//", cf->file_name, revbuf, tbuf);
			if (l == -1 || l >= CVS_ENT_MAXLINELEN)
				fatal("cvs_add_local: overflow");

			entlist = cvs_ent_open(cf->file_wd);
			cvs_ent_add(entlist, entry);
			cvs_ent_close(entlist, ENT_SYNC);

			xfree(entry);
d206 1
a218 3
		} else {
			cvs_log(LP_NOTICE, "%s, version %s, ressurected",
			    cf->file_name, revbuf);
a219 1

d250 1
a250 11
	if (added != 0 && cvs_noexec != 1) {
		entry = xmalloc(CVS_ENT_MAXLINELEN);
		l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/0/Initial %s//",
		    cf->file_name, cf->file_name);

		entlist = cvs_ent_open(cf->file_wd);
		cvs_ent_add(entlist, entry);
		cvs_ent_close(entlist, ENT_SYNC);

		xfree(entry);
	}
d258 60
@


1.53
log
@sprinkle -n voodoo over the add, commit and import commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.52 2006/06/01 20:00:52 joris Exp $	*/
a260 1
			added++;
d264 1
@


1.52
log
@major rewrite of some rcs parsing stuff:

- rework rcs_getrev() to correctly support branches
- rework rcs_translate_tag() to correctly translate given symbols or
  branches into their matching revisions
- rework rcs_rev_add() to correctly update its 'next' pointers
  and insert the new revision in the correct place on the list.
- rework rcs_head_get() to return the latest revision on the default
  branch if it has been set or the normal HEAD revision otherwise.
- no longer access the rf_head member of the RCSFILE struct manually,
  use the rcs_head_get() function which correctly returns the HEAD
  revision, there might be a default branch that has to be used.
- for now, when commiting a new revision reset the default branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.51 2006/05/30 21:32:52 joris Exp $	*/
d107 1
a107 1
	int l;
d119 1
d124 1
d139 2
a140 1
		} else {
d165 2
d168 3
a170 3
			cvs_printf("Directory %s added to the repository\n",
			    cf->file_rpath);
		}
d202 1
a202 1
		} else {
d231 1
a231 1
			cvs_checkout_file(cf, cf->file_rcs->rf_head, b, 0);
d238 3
d242 1
d273 8
a280 7
	entry = xmalloc(CVS_ENT_MAXLINELEN);
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/0/Initial %s//",
	    cf->file_name, cf->file_name);

	entlist = cvs_ent_open(cf->file_wd);
	cvs_ent_add(entlist, entry);
	cvs_ent_close(entlist, ENT_SYNC);
d282 2
a283 1
	xfree(entry);
@


1.51
log
@fill in the correct revision number we will want in file_rcsrev
for each cvs_file struct, this will help us with sticky tags,
commiting to branches and importing into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.50 2006/05/30 09:11:24 xsa Exp $	*/
d178 1
d182 2
a183 1
		rcsnum_tostr(cf->file_rcs->rf_head, revbuf, sizeof(revbuf));
d221 2
a222 1
			b = rcs_getrev(cf->file_rcs, cf->file_rcs->rf_head);
@


1.50
log
@handle lost files, modified files and files with conflicts; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.49 2006/05/30 08:23:31 xsa Exp $	*/
d85 1
a85 1
	cvs_file_classify(cf, 0);
@


1.49
log
@handle special files when doing `cvs add *'; input+OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.48 2006/05/30 07:09:38 xsa Exp $	*/
d233 3
@


1.48
log
@handle removed files; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.47 2006/05/29 17:55:39 joris Exp $	*/
d86 11
@


1.47
log
@fix option string
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.46 2006/05/29 06:25:06 joris Exp $	*/
d25 2
d164 3
a166 3
	int l;
	int stop;
	char *entry, revbuf[16];
d172 1
a172 1
	stop = 0;
d175 45
a219 2
		cvs_log(LP_NOTICE, "%s has already been entered",
		    cf->file_path);
d235 1
d257 6
a262 1
	cvs_log(LP_NOTICE, "use commit to add this file permanently");
@


1.46
log
@add needs to be passed arguments on the command line, and
isnt supposed to just run over our parent directory if none are
specified.

found by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.45 2006/05/28 17:26:12 joris Exp $	*/
d38 1
a38 1
	"m",
@


1.45
log
@our add command can now add directories to the repository as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.44 2006/05/28 10:15:35 joris Exp $	*/
a47 1
	char *arg = ".";
d65 3
d74 1
a74 5
	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);

@


1.44
log
@enable basic add command, only works on files right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.43 2006/05/28 07:56:44 joris Exp $	*/
d28 3
d51 1
a51 1
	flags = CR_RECURSE_DIRS | CR_REPO;
d83 15
a97 2
	int stop, l;
	char *entry, revbuf[16];
d99 3
d103 57
a159 1
	cvs_log(LP_TRACE, "cvs_add_local(%s)", cf->file_path);
d161 7
a167 1
	cvs_file_classify(cf, 0);
@


1.43
log
@allow commands to shut up the output from cvs_file_classify
if the commands want to output certain stuff themselfs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 4
d88 4
d96 8
d106 8
a113 2
		cvs_log(LP_NOTICE, "%s is unknown to us so far",
		    cf->file_path);
d118 15
@


1.42
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.41 2006/04/14 02:45:35 deraadt Exp $	*/
d3 1
a3 3
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * Copyright (c) 2005 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d21 1
d25 2
d28 1
a28 9
extern char *__progname;


static int	cvs_add_remote(CVSFILE *, void *);
static int	cvs_add_local(CVSFILE *, void *);
static int	cvs_add_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_add_pre_exec(struct cvsroot *);
static int	cvs_add_directory(CVSFILE *);
static int	cvs_add_build_entry(CVSFILE *);
d33 3
a35 9
	"Add a new file/directory to the repository",
	"[-k mode] [-m msg] file ...",
	"k:m:",
	NULL,
	0,
	cvs_add_init,
	cvs_add_pre_exec,
	cvs_add_remote,
	cvs_add_local,
d37 1
a37 2
	NULL,
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2
d40 2
a41 6
static int kflag = RCS_KWEXP_DEFAULT;
static char *koptstr;
static char kbuf[16];

static int
cvs_add_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d44 3
d48 1
a48 1
	cvs_msg = NULL;
d50 1
a50 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a51 10
		case 'k':
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				rcs_kflag_usage();
				return (CVS_EX_USAGE);
			}
			break;
d53 1
a53 1
			cvs_msg = xstrdup(optarg);
d56 1
a56 1
			return (CVS_EX_USAGE);
d60 2
a61 12
	*arg = optind;
	return (0);
}

static int
cvs_add_pre_exec(struct cvsroot *root)
{
	kbuf[0] = '\0';

	if (kflag != RCS_KWEXP_DEFAULT) {
		strlcpy(kbuf, "-k", sizeof(kbuf));
		strlcat(kbuf, koptstr, sizeof(kbuf));
d63 10
a72 3
		if (root->cr_method != CVS_METHOD_LOCAL)
			cvs_sendarg(root, kbuf, 0);
	}
d77 2
a78 2
static int
cvs_add_remote(CVSFILE *cf, void *arg)
d80 1
a80 1
	struct cvsroot *root;
d82 1
a82 1
	root = CVS_DIR_ROOT(cf);
d84 11
a94 3
	if (cf->cf_type == DT_DIR) {
		cvs_senddir(root, cf);
		return (0);
a95 223

	if (cf->cf_cvstat == CVS_FST_UNKNOWN)
		cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);

	return (0);
}

static int
cvs_add_local(CVSFILE *cf, void *arg)
{
	int added, ret;
	char numbuf[64];

	added = 0;

	/* dont use `cvs add *' */
	if (strcmp(cf->cf_name, ".") == 0 ||
	    strcmp(cf->cf_name, "..") == 0 ||
	    strcmp(cf->cf_name, CVS_PATH_CVSDIR) == 0) {
		if (verbosity > 1)
			fatal("cannot add special file `%s'.", cf->cf_name);
	}

	if (cf->cf_type == DT_DIR)
		return cvs_add_directory(cf);

	if ((!(cf->cf_flags & CVS_FILE_ONDISK)) &&
	    cf->cf_cvstat != CVS_FST_LOST &&
	    cf->cf_cvstat != CVS_FST_REMOVED) {
		if (verbosity > 1)
			cvs_log(LP_WARN, "nothing known about `%s'",
			    cf->cf_name);
		return (0);
	} else if (cf->cf_cvstat == CVS_FST_ADDED) {
		if (verbosity > 1)
			cvs_log(LP_WARN, "`%s' has already been entered",
			    cf->cf_name);
		return (0);
	} else if (cf->cf_cvstat == CVS_FST_REMOVED) {

		/* XXX remove '-' from CVS/Entries */

		/* XXX check the file out */

		rcsnum_tostr(cf->cf_lrev, numbuf, sizeof(numbuf));
		cvs_log(LP_WARN, "%s, version %s, resurrected",
		    cf->cf_name, numbuf);

		return (0);
	} else if (cf->cf_cvstat == CVS_FST_CONFLICT ||
	    cf->cf_cvstat == CVS_FST_LOST ||
	    cf->cf_cvstat == CVS_FST_MODIFIED ||
	    cf->cf_cvstat == CVS_FST_UPTODATE) {
		if (verbosity > 1) {
			rcsnum_tostr(cf->cf_lrev, numbuf, sizeof(numbuf));
			cvs_log(LP_WARN,
			    "%s already exists, with version number %s",
			    cf->cf_name, numbuf);
		}
		return (0);
	}

	if ((ret = cvs_add_build_entry(cf)) != 0)
		return (ret);
	else {
		added++;
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "scheduling file `%s' for addition",
			    cf->cf_name);
	}

	if (added != 0) {
		if (verbosity > 0)
			cvs_log(LP_NOTICE, "use '%s commit' to add %s "
			    "permanently", __progname,
			    (added == 1) ? "this file" : "these files");
		return (0);
	}

	return (0);
}

/*
 * cvs_add_directory()
 *
 * Add a directory to the repository.
 *
 * Returns 0 on success, -1 on failure.
 */
static int
cvs_add_directory(CVSFILE *cf)
{
	int nb;
	char *date, *repo, *tag;
	char entry[CVS_ENT_MAXLINELEN], fpath[MAXPATHLEN], rcsdir[MAXPATHLEN];
	char msg[1024];
	CVSENTRIES *entf;
	struct cvsroot *root;
	struct stat st;
	struct cvs_ent *ent;

	entf = (CVSENTRIES *)cf->cf_entry;

	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);

	if (strlcpy(fpath, cf->cf_name, sizeof(fpath)) >= sizeof(fpath))
		fatal("cvs_add_directory: path truncation");

	if (strchr(fpath, '/') != NULL)
		fatal("directory %s not added; must be a direct sub-directory",
		    fpath);

	/* Let's see if we have any per-directory tags first */
	cvs_parse_tagfile(&tag, &date, &nb);

	/* XXX check for <dir>/CVS */

	if (strlcpy(rcsdir, root->cr_dir, sizeof(rcsdir)) >= sizeof(rcsdir) ||
	    strlcat(rcsdir, "/", sizeof(rcsdir)) >= sizeof(rcsdir) ||
	    strlcat(rcsdir, repo, sizeof(rcsdir)) >= sizeof(rcsdir))
		fatal("cvs_add_directory: path truncation");

	if (stat(rcsdir, &st) == 0 && !(S_ISDIR(st.st_mode)))
		fatal("%s is not a directory; %s not added: %s", rcsdir, fpath,
		    strerror(errno));

	snprintf(msg, sizeof(msg),
	    "Directory %s added to the repository", rcsdir);

	if (tag != NULL) {
		strlcat(msg, "\n--> Using per-directory sticky tag ",
		    sizeof(msg));
		strlcat(msg, tag, sizeof(msg));
	}
	if (date != NULL) {
		strlcat(msg, "\n--> Using per-directory sticky date ",
		    sizeof(msg));
		strlcat(msg, date, sizeof(msg));
	}
	strlcat(msg, "\n", sizeof(msg));

	if (cvs_noexec == 0) {
		if (mkdir(rcsdir, 0777) == -1)
			fatal("cvs_add_directory: mkdir `%s': %s",
			    rcsdir, strerror(errno));
	}

	/* create CVS/ admin files */
	if (cvs_noexec == 0)
		cvs_mkadmin(fpath, root->cr_str, repo, tag, date, nb);

	/* XXX Build the Entries line. */
	if (strlcpy(entry, "D/", sizeof(entry)) >= sizeof(entry) ||
	    strlcat(entry, fpath, sizeof(entry)) >= sizeof(entry) ||
	    strlcat(entry, "////", sizeof(entry)) >= sizeof(entry))
		fatal("cvs_add_directory: path truncation");

	if ((ent = cvs_ent_parse(entry)) == NULL)
		fatal("cvs_add_directory: cvs_ent_parse failed");

	if (cvs_ent_add(entf, ent) < 0)
		fatal("cvs_add_directory: cvs_ent_parse failed");

	cvs_printf("%s", msg);

	return (0);
}

static int
cvs_add_build_entry(CVSFILE *cf)
{
	char entry[CVS_ENT_MAXLINELEN], path[MAXPATHLEN];
	FILE *fp;
	CVSENTRIES *entf;
	struct cvs_ent *ent;

	entf = (CVSENTRIES *)cf->cf_entry;

	if (cvs_noexec == 1)
		return (0);

	/* Build the path to the <file>,t file. */
	if (strlcpy(path, CVS_PATH_CVSDIR, sizeof(path)) >= sizeof(path) ||
	    strlcat(path, "/", sizeof(path)) >= sizeof(path) ||
	    strlcat(path, cf->cf_name, sizeof(path)) >= sizeof(path) ||
	    strlcat(path, CVS_DESCR_FILE_EXT, sizeof(path)) >= sizeof(path))
		fatal("cvs_add_build_entry: path truncation");

	if ((fp = fopen(path, "w+")) == NULL)
		fatal("cvs_add_build_entry: fopen `%s': %s", path,
		    strerror(errno));

	if (cvs_msg != NULL) {
		if (fputs(cvs_msg, fp) == EOF)
			fatal("cvs_add_build_entry: fputs `%s': %s", path,
			    strerror(errno));
	}
	(void)fclose(fp);

	/* XXX Build the Entries line. */
	if (strlcpy(entry, "/", sizeof(entry)) >= sizeof(entry) ||
	    strlcat(entry, cf->cf_name, sizeof(entry)) >= sizeof(entry) ||
	    strlcat(entry, "/0/Initial ", sizeof(entry)) >= sizeof(entry) ||
	    strlcat(entry, cf->cf_name, sizeof(entry)) >= sizeof(entry) ||
	    strlcat(entry, "/", sizeof(entry)) >= sizeof(entry) ||
	    strlcat(entry, kbuf, sizeof(entry)) >= sizeof(entry) ||
	    strlcat(entry, "/", sizeof(entry)) >= sizeof(entry)) {
		(void)cvs_unlink(path);
		fatal("cvs_add_build_entry: path truncation");
	}

	if ((ent = cvs_ent_parse(entry)) == NULL) {
		(void)cvs_unlink(path);
		fatal("cvs_add_build_entry: cvs_ent_parse failed");
	}

	if (cvs_ent_add(entf, ent) < 0) {
		(void)cvs_unlink(path);
		fatal("cvs_add_build_entry: cvs_ent_add failed");
	}

	return (0);
@


1.41
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.40 2006/01/27 12:56:28 xsa Exp $	*/
@


1.40
log
@cvs_mkadmin() cannot return < 0 anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.39 2006/01/27 12:45:21 xsa Exp $	*/
d140 3
a142 3
	if ((strcmp(cf->cf_name, ".") == 0) ||
	    (strcmp(cf->cf_name, "..") == 0) ||
	    (strcmp(cf->cf_name, CVS_PATH_CVSDIR) == 0)) {
d151 2
a152 2
	    (cf->cf_cvstat != CVS_FST_LOST) &&
	    (cf->cf_cvstat != CVS_FST_REMOVED)) {
d173 4
a176 4
	} else if ((cf->cf_cvstat == CVS_FST_CONFLICT) ||
	    (cf->cf_cvstat == CVS_FST_LOST) ||
	    (cf->cf_cvstat == CVS_FST_MODIFIED) ||
	    (cf->cf_cvstat == CVS_FST_UPTODATE)) {
d247 1
a247 1
	if ((stat(rcsdir, &st) == 0) && !(S_ISDIR(st.st_mode)))
@


1.39
log
@errors handling cleaning here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.38 2006/01/25 11:19:51 xsa Exp $	*/
d274 1
a274 2
		if (cvs_mkadmin(fpath, root->cr_str, repo, tag, date, nb) == -1)
			return (CVS_EX_FILE);
@


1.38
log
@strings cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.37 2006/01/02 08:11:56 xsa Exp $	*/
d144 1
a144 3
			cvs_log(LP_ERR,
			    "cannot add special file `%s'.", cf->cf_name);
		return (CVS_EX_FILE);
d231 1
a231 1
		return (CVS_EX_DATA);
d233 2
a234 3
	if (strchr(fpath, '/') != NULL) {
		cvs_log(LP_ERR,
		    "directory %s not added; must be a direct sub-directory",
a235 2
		return (CVS_EX_FILE);
	}
d247 3
a249 5
	if ((stat(rcsdir, &st) == 0) && !(S_ISDIR(st.st_mode))) {
		cvs_log(LP_ERRNO,
		    "%s is not a directory; %s not added", rcsdir, fpath);
		return (CVS_EX_FILE);
	}
d267 3
a269 4
		if (mkdir(rcsdir, 0777) == -1) {
			cvs_log(LP_ERRNO, "failed to create %s", rcsdir);
			return (CVS_EX_FILE);
		}
d283 2
a284 4
	if ((ent = cvs_ent_parse(entry)) == NULL) {
		cvs_log(LP_ERR, "failed to parse entry");
		return (CVS_EX_DATA);
	}
d286 2
a287 4
	if (cvs_ent_add(entf, ent) < 0) {
		cvs_log(LP_ERR, "failed to add entry");
		return (CVS_EX_DATA);
	}
d314 3
a316 5
	fp = fopen(path, "w+");
	if (fp == NULL) {
		cvs_log(LP_ERRNO, "failed to open `%s'", path);
		return (CVS_EX_FILE);
	}
d319 3
a321 5
		if (fputs(cvs_msg, fp) == EOF) {
			cvs_log(LP_ERRNO, "cannot write to `%s'", path);
			(void)fclose(fp);
			return (CVS_EX_FILE);
		}
a337 1
		cvs_log(LP_ERR, "failed to parse entry");
d339 1
a339 1
		return (CVS_EX_DATA);
a342 1
		cvs_log(LP_ERR, "failed to add entry");
d344 1
a344 1
		return (CVS_EX_DATA);
@


1.37
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.36 2005/12/30 02:03:28 joris Exp $	*/
d218 1
a218 1
	int l, nb;
d247 4
a250 7
	l = snprintf(rcsdir, sizeof(rcsdir), "%s/%s",
	    root->cr_dir, repo);
	if (l == -1 || l >= (int)sizeof(rcsdir)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rcsdir);
		return (CVS_EX_DATA);
	}
d286 4
a289 6
	l = snprintf(entry, sizeof(entry), "D/%s////", fpath);
	if (l == -1 || l >= (int)sizeof(entry)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", entry);
		return (CVS_EX_DATA);
	}
a308 1
	int l;
d320 5
a324 7
	l = snprintf(path, sizeof(path), "%s/%s%s",
	    CVS_PATH_CVSDIR, cf->cf_name, CVS_DESCR_FILE_EXT);
	if (l == -1 || l >= (int)sizeof(path)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", path);
		return (CVS_EX_DATA);
	}
d342 7
a348 5
	l = snprintf(entry, sizeof(entry), "/%s/0/Initial %s/%s/",
	    cf->cf_name, cf->cf_name, kbuf);
	if (l == -1 || l >= (int)sizeof(entry)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", entry);
d350 1
a350 1
		return (CVS_EX_DATA);
@


1.36
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.35 2005/12/10 20:27:45 joris Exp $	*/
d28 1
a28 8
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.35
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.34 2005/10/07 21:47:32 reyk Exp $	*/
d113 2
a114 4
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cvs_sendarg(root, kbuf, 0) < 0)
				return (CVS_EX_PROTO);
		}
a122 1
	int ret;
a124 1
	ret = 0;
d128 2
a129 4
		ret = cvs_senddir(root, cf);
		if (ret == -1)
			ret = CVS_EX_PROTO;
		return (ret);
d133 1
a133 2
		ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED,
		    cf->cf_name);
d135 1
a135 4
	if (ret == -1)
		ret = CVS_EX_PROTO;

	return (ret);
@


1.34
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.33 2005/09/30 15:40:22 xsa Exp $	*/
d93 1
a93 4
			if ((cvs_msg = strdup(optarg)) == NULL) {
				cvs_log(LP_ERRNO, "failed to copy message");
				return (CVS_EX_DATA);
			}
@


1.33
log
@avoid using `cvs add *' idiom wrt special files; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.32 2005/09/25 17:38:44 xsa Exp $	*/
d196 1
a196 1
	    (cf->cf_cvstat == CVS_FST_LOST) || 
d319 1
a319 1
	}        
d383 1
a383 1
	}	
@


1.32
log
@use cvs_add_build_entry(); joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.31 2005/09/21 16:30:03 xsa Exp $	*/
d159 10
d314 1
a314 1
        }
@


1.31
log
@use correct return codes in cvs_add_directory(); joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.30 2005/09/15 17:01:10 xsa Exp $	*/
a49 1
#if 0
a50 1
#endif
d154 1
a154 1
	int added;
d198 3
a200 3
	if (verbosity > 1) {
		cvs_log(LP_NOTICE, "scheduling file `%s' for addition",
		    cf->cf_name);
d202 3
a320 1
#if 0
a382 1
#endif
@


1.30
log
@check in cvs_mkadmin() wether we need to create or not the
CVS/Tag file. Sync the rest of the code accordingly; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.29 2005/09/13 17:35:00 xsa Exp $	*/
d161 2
a162 5
	if (cf->cf_type == DT_DIR) {
		if (cvs_add_directory(cf) == -1)
			return (CVS_EX_FILE);
		return (0);
	}
d242 1
a242 1
		return (-1);
d248 1
a248 1
		return (-1);
d261 1
a261 1
		return (-1);
d267 1
a267 1
		return (-1);
d288 1
a288 1
			return (-1);
d295 1
a295 1
			return (-1);
d302 1
a302 1
		return (-1);
d307 1
a307 1
		return (-1);
d312 1
a312 1
		return (-1);
@


1.29
log
@let's add directories too; testing+ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.28 2005/09/05 19:49:31 xsa Exp $	*/
d257 2
d297 1
a297 1
		if (cvs_mkadmin(fpath, root->cr_str, repo) == -1)
@


1.28
log
@let's move forward with the local add command;
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.27 2005/07/30 00:01:50 joris Exp $	*/
d29 1
d49 1
d161 6
d216 101
@


1.27
log
@we actually want CVS_FST_UNKNOWN here.

problem reported by Nuno once more.
ok from an enthousiastic xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.26 2005/07/27 17:53:54 xsa Exp $	*/
d4 1
d48 3
d71 1
d110 1
a110 1
	char buf[16];
d112 8
a119 6
	if ((root->cr_method != CVS_METHOD_LOCAL) &&
	    (kflag != RCS_KWEXP_DEFAULT)) {
		strlcpy(buf, "-k", sizeof(buf));
		strlcat(buf, koptstr, sizeof(buf));
		if (cvs_sendarg(root, buf, 0) < 0)
			return (CVS_EX_PROTO);
d151 2
a152 2
static
int cvs_add_local(CVSFILE *cf, void *arg)
d154 118
a271 3
	cvs_log(LP_NOTICE, "scheduling file `%s' for addition", cf->cf_name);
	cvs_log(LP_NOTICE, "use `%s commit' to add this file permanently",
	    __progname);
d275 1
@


1.26
log
@use LP_NOTICE here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.25 2005/07/25 12:42:54 xsa Exp $	*/
d134 1
a134 1
	if (cf->cf_cvstat == CVS_FST_ADDED)
@


1.25
log
@missed that one too...
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.24 2005/07/23 11:19:46 joris Exp $	*/
d147 2
a148 2
	cvs_log(LP_INFO, "scheduling file `%s' for addition", cf->cf_name);
	cvs_log(LP_INFO, "use `%s commit' to add this file permanently",
@


1.24
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.23 2005/07/10 21:55:30 joris Exp $	*/
d43 4
a46 4
static int cvs_add_remote(CVSFILE *, void *);
static int cvs_add_local(CVSFILE *, void *);
static int cvs_add_init(struct cvs_cmd *, int, char **, int *);
static int cvs_add_pre_exec(struct cvsroot *);
@


1.23
log
@

if cvs_sendreq() returns -1 we have to translate it into CVS_EX_PROTO,
so the user will know what is going on.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.22 2005/07/08 16:03:38 joris Exp $	*/
d134 1
a134 1
	if (cf->cf_cvstat == CVS_FST_UNKNOWN)
@


1.22
log
@split local and remote function handlers from each other.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.21 2005/05/24 04:12:25 jfb Exp $	*/
d137 3
@


1.21
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.20 2005/05/20 20:00:53 joris Exp $	*/
d43 2
a44 1
static int cvs_add_file(CVSFILE *, void *);
d58 2
a59 2
	cvs_add_file,
	cvs_add_file,
d119 1
a119 1
cvs_add_file(CVSFILE *cf, void *arg)
d128 1
a128 3
		if (root->cr_method != CVS_METHOD_LOCAL)
			ret = cvs_senddir(root, cf);

a130 1

d134 2
a135 6
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED,
			    cf->cf_name);
	} else {
		cvs_log(LP_INFO, "scheduling file `%s' for addition",
a136 3
		cvs_log(LP_INFO, "use `%s commit' to add this file permanently",
		    __progname);
	}
d139 10
@


1.20
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.19 2005/04/12 14:58:40 joris Exp $	*/
d43 15
a57 7
int cvs_add_file(CVSFILE *, void *);
int cvs_add_options(char *, int, char **, int *);
int cvs_add_sendflags(struct cvsroot *);

struct cvs_cmd_info cvs_add = {
	cvs_add_options,
	cvs_add_sendflags,
d59 2
a60 3
	NULL, NULL,
	0,
	CVS_REQ_ADD,
d67 2
a68 2
int
cvs_add_options(char *opt, int argc, char **argv, int *arg)
d74 1
a74 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d101 2
a102 2
int
cvs_add_sendflags(struct cvsroot *root)
d106 2
a107 1
	if (kflag != RCS_KWEXP_DEFAULT) {
d117 1
a117 1
int
d139 1
a139 1
			    CVS_FILE_NAME(cf));
d142 1
a142 1
		    CVS_FILE_NAME(cf));
@


1.19
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.18 2005/04/11 18:02:58 joris Exp $	*/
d121 3
@


1.18
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.17 2005/04/11 17:56:27 joris Exp $	*/
d76 1
a76 1
				return (1);
d82 1
a82 1
				return (-1);
d86 1
a86 1
			return (1);
d103 1
a103 1
			return (-1);
@


1.17
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.16 2005/04/03 17:32:50 xsa Exp $	*/
a32 1
#include <sysexits.h>
@


1.16
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.15 2005/03/30 17:43:04 joris Exp $	*/
d77 1
a77 1
				return (EX_USAGE);
d87 1
a87 1
			return (EX_USAGE);
@


1.15
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.14 2005/01/24 18:30:25 jfb Exp $	*/
d83 1
a83 1
				return (EX_DATAERR);
d104 1
a104 1
			return (EX_PROTOCOL);
@


1.14
log
@get rid of a debugging printf() that slipped through the cracks
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.13 2005/01/24 17:42:26 jfb Exp $	*/
d44 13
a56 1
int  cvs_add_file (CVSFILE *, void *);
d58 2
a60 6
/*
 * cvs_add()
 *
 * Handler for the `cvs add' command.
 * Returns 0 on success, or one of the known system exit codes on failure.
 */
d62 1
a62 1
cvs_add(int argc, char **argv)
d64 1
a64 3
	int i, ch, kflag;
	char buf[16], *koptstr;
	struct cvsroot *root;
a65 1
	kflag = RCS_KWEXP_DEFAULT;
d68 1
a68 1
	while ((ch = getopt(argc, argv, "k:m:")) != -1) {
d91 3
a93 27
	argc -= optind;
	argv += optind;
	if (argc == 0)
		return (EX_USAGE);

	cvs_files = cvs_file_getspec(argv, argc, 0);
	if (cvs_files == NULL)
		return (EX_DATAERR);

	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_connect(root) < 0)
			return (EX_PROTOCOL);
		if (kflag != RCS_KWEXP_DEFAULT) {
			strlcpy(buf, "-k", sizeof(buf));
			strlcat(buf, koptstr, sizeof(buf));
			if (cvs_sendarg(root, buf, 0) < 0)
				return (EX_PROTOCOL);
		}
	}
d95 4
a98 1
	cvs_file_examine(cvs_files, cvs_add_file, NULL);
d100 4
a103 9
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0)
			return (EX_PROTOCOL);

		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				return (EX_PROTOCOL);

		if (cvs_sendreq(root, CVS_REQ_ADD, NULL) < 0)
a108 1

@


1.13
log
@* use the global cvs_msg instead of our own
* support the use of RCS keyword expansion flags in client mode
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.12 2004/12/30 20:37:56 jfb Exp $	*/
a73 1
			printf("kopt = `%s'\n", koptstr);
@


1.12
log
@Send files to add using `Is-Modified' instead of `add', and send
directories regardless of whether they are known or not, in case
they are part of the files to add.
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.11 2004/12/21 17:50:40 jfb Exp $	*/
d56 2
a57 2
	int i, ch;
	char *kflag, *msg;
d60 2
a61 1
	kflag = msg = NULL;
d66 9
a74 1
			kflag = optarg;
d77 4
a80 1
			msg = optarg;
a88 1

d104 10
a113 2
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cvs_connect(root) < 0))
		return (EX_PROTOCOL);
@


1.11
log
@Check to make sure we have a valid CVSROOT, and check the return value
when sending the add request
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.10 2004/12/21 16:48:39 xsa Exp $	*/
d124 2
a125 7
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cf->cf_cvstat == CVS_FST_UNKNOWN)
				ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
				    CVS_FILE_NAME(cf));
			else
				ret = cvs_senddir(root, cf);
		}
d131 3
a133 1
		ret = cvs_sendreq(root, CVS_REQ_ADD, CVS_FILE_NAME(cf));
@


1.10
log
@on the way to `cvs add'; ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.9 2004/12/08 20:23:06 jfb Exp $	*/
d86 7
a92 1

d136 1
a136 1
		cvs_sendreq(root, CVS_REQ_ADD, CVS_FILE_NAME(cf));
@


1.9
log
@minor simplification in if () statement from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.8 2004/12/07 17:10:56 tedu Exp $	*/
a31 1
#include <unistd.h>
d34 1
a43 1

a46 1

d60 1
a60 1
	kflag = NULL;
d85 5
d92 7
a98 1
	root = CVS_DIR_ROOT(cvs_files);
d100 3
a102 4
	for (i = 0; i < argc; i++)
		cvs_sendarg(root, argv[i], 0);
	if (cvs_sendreq(root, CVS_REQ_ADD, NULL) < 0)
		return (-1);
d111 1
d114 3
d118 6
a123 8
		if (cf->cf_cvstat != CVS_FST_UNKNOWN) {
			root = cf->cf_ddat->cd_root;
			if ((cf->cf_parent == NULL) ||
			    (root != cf->cf_parent->cf_ddat->cd_root)) {
				cvs_connect(root);
			}

			cvs_senddir(root, cf);
d126 1
a126 1
		return (0);
a128 2
	root = CVS_DIR_ROOT(cf);

d130 1
a130 1
		cvs_sendreq(root, CVS_REQ_ISMODIFIED, CVS_FILE_NAME(cf));
d133 1
a133 1
		    cf->cf_name);
d138 1
a138 1
	return (0);
@


1.8
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.7 2004/12/06 21:03:12 deraadt Exp $	*/
d106 1
a106 2
		if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		} else {
@


1.7
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.6 2004/12/06 02:19:54 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a54 1

@


1.6
log
@Pass the proper type for the third argument to cvs_sendreq()
@
text
@d1 1
a1 1
/*	$OpenBSD: add.c,v 1.5 2004/11/09 20:59:07 krapht Exp $	*/
d108 1
a108 2
		}
		else {
d125 1
a125 2
	}
	else {
@


1.5
log
@a bit more sense
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 1
a125 1
		cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);
@


1.4
log
@Remove unused variables
@
text
@d124 4
a127 3
	cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);

	if (cvs_cmdop == CVS_OP_SERVER) {
@


1.3
log
@Make add work in client mode
@
text
@d59 1
a59 1
	int i, ch, ret;
@


1.2
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d41 7
d59 1
a59 1
	int ch, i, ret;
d81 1
a81 1
	if (argc == 0) {
d83 37
d122 1
a122 1
	root = NULL;
d124 1
a124 5
	for (i = 0; i < argc; i++) {
		ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED, argv[i]);
		if (ret < 0)
			return (EX_DATAERR);
	}
d126 5
a130 2
	for (i = 0; i < argc; i++) {
		ret = cvs_sendreq(root, CVS_REQ_ARGUMENT, argv[i]);
a131 2

	ret = cvs_sendreq(root, CVS_REQ_ADD, NULL);
@


1.1
log
@Initial revision
@
text
@d38 1
a38 4



extern struct cvsroot *cvs_root;
d54 1
d78 2
d81 1
a81 6
		/*
		 * XXX figure out if we should send `Modified' or `Is-Modified'
		 * The cvs documentation specifies that Modified should be used
		 * in this case, but GNU CVS sends the latter.
		 */
		ret = cvs_client_sendreq(CVS_REQ_ISMODIFIED, argv[i], 0);
d87 1
a87 1
		ret = cvs_client_sendreq(CVS_REQ_ARGUMENT, argv[i], 0);
d90 1
a90 1
	ret = cvs_client_sendreq(CVS_REQ_ADD, NULL, 0);
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
