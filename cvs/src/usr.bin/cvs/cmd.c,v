head	1.69;
access;
symbols
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.69.0.8
	OPENBSD_6_0_BASE:1.69
	OPENBSD_5_9:1.69.0.4
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.69.0.6
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.30
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.68.0.28
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.68.0.24
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.68.0.22
	OPENBSD_5_3_BASE:1.68
	OPENBSD_5_2:1.68.0.20
	OPENBSD_5_2_BASE:1.68
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.18
	OPENBSD_5_0:1.68.0.16
	OPENBSD_5_0_BASE:1.68
	OPENBSD_4_9:1.68.0.14
	OPENBSD_4_9_BASE:1.68
	OPENBSD_4_8:1.68.0.12
	OPENBSD_4_8_BASE:1.68
	OPENBSD_4_7:1.68.0.8
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.68.0.10
	OPENBSD_4_6_BASE:1.68
	OPENBSD_4_5:1.68.0.6
	OPENBSD_4_5_BASE:1.68
	OPENBSD_4_4:1.68.0.4
	OPENBSD_4_4_BASE:1.68
	OPENBSD_4_3:1.68.0.2
	OPENBSD_4_3_BASE:1.68
	OPENBSD_4_2:1.61.0.2
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.57.0.2
	OPENBSD_4_1_BASE:1.57
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33;
locks; strict;
comment	@ * @;


1.69
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	Uu5nFG3wCl0LACBb;

1.68
date	2008.02.03.18.18.44;	author tobias;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.01.17.18.59;	author tobias;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.21.16.40.04;	author tobias;	state Exp;
branches;
next	1.65;

1.65
date	2008.01.10.11.20.29;	author tobias;	state Exp;
branches;
next	1.64;

1.64
date	2008.01.10.10.05.40;	author tobias;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.25.10.56.04;	author chl;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.04.19.07.03;	author tobias;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.27.20.27.38;	author xsa;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.26.18.02.43;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.26.02.24.10;	author niallo;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.18.17.54.13;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.19.11.40.00;	author otto;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.27.14.19.53;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.14.09.47.52;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.13.12.57.03;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.12.13.56.00;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2006.06.07.18.19.07;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.31.22.25.59;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.30.07.00.30;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.29.05.34.31;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.28.21.11.12;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.28.10.15.35;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.30.17.51.01;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.03.01.02.08;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.22.17.23.21;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.13.17.24.38;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.07.17.43.15;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.26.16.03.20;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.21.11.42.24;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.08.10.30.24;	author joris;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.04.07.11.10;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.14.15.27.31;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.13.13.02.18;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.07.16.22.19;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.02.20.12.06;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.25.04.12.54;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.24.04.21.54;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.23.17.43.54;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.20.05.13.44;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.25.21.58.32;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.25.17.59.16;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.18.21.06.46;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.18.21.02.49;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.13.14.49.05;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.12.17.20.01;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.01.09.44.00;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.31.17.18.24;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.31.15.47.17;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.29.03.10.27;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.28.17.17.38;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.24.01.03.41;	author joris;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: cmd.c,v 1.68 2008/02/03 18:18:44 tobias Exp $	*/
/*
 * Copyright (c) 2005 Joris Vink <joris@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/types.h>
#include <sys/dirent.h>

#include <string.h>

#include "cvs.h"

struct cvs_cmd *cvs_cdt[] = {
	&cvs_cmd_add,
	&cvs_cmd_admin,
	&cvs_cmd_annotate,
	&cvs_cmd_commit,
	&cvs_cmd_checkout,
	&cvs_cmd_diff,
	&cvs_cmd_export,
	&cvs_cmd_history,
	&cvs_cmd_import,
	&cvs_cmd_init,
	&cvs_cmd_log,
	&cvs_cmd_rannotate,
	&cvs_cmd_rdiff,
	&cvs_cmd_release,
	&cvs_cmd_remove,
	&cvs_cmd_rlog,
	&cvs_cmd_rtag,
	&cvs_cmd_server,
	&cvs_cmd_status,
	&cvs_cmd_tag,
	&cvs_cmd_update,
	&cvs_cmd_version,
#if 0
	&cvs_cmd_edit,
	&cvs_cmd_editors,
	&cvs_cmd_unedit,
	&cvs_cmd_watch,
	&cvs_cmd_watchers,
#endif
	NULL
};

struct cvs_cmd *
cvs_findcmd(const char *cmd)
{
	int i, j;
	struct cvs_cmd *p;

	p = NULL;
	for (i = 0; (cvs_cdt[i] != NULL) && (p == NULL); i++) {
		if (strcmp(cmd, cvs_cdt[i]->cmd_name) == 0)
			p = cvs_cdt[i];
		else {
			for (j = 0; j < CVS_CMD_MAXALIAS; j++) {
				if (strcmp(cmd,
				    cvs_cdt[i]->cmd_alias[j]) == 0) {
					p = cvs_cdt[i];
					break;
				}
			}
		}
	}

	return (p);
}
@


1.68
log
@Added rdiff support.  In order to do this, some output and option fixes
had to be done for diff, too.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.67 2008/02/01 17:18:59 tobias Exp $	*/
d26 1
a26 1
#include <sys/param.h>
@


1.67
log
@Added rannotate support

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.66 2008/01/21 16:40:04 tobias Exp $	*/
d46 1
a58 1
	&cvs_cmd_rdiff,
@


1.66
log
@Fixed cvs_findcmd I broke last time: cvs_findcmd is called during .cvsrc
parsing and must have a local cmdp variable.

> Spotted by Pierre Riteau.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.65 2008/01/10 11:20:29 tobias Exp $	*/
d45 1
@


1.65
log
@Added support for rtag in local and remote setups (with interoperability
with GNU cvs).  Basically we already had rtag in place as tag is supposed
to work with revisions in working directory, but our implementation was
wrong.  Fixed that on the fly as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.64 2008/01/10 10:05:40 tobias Exp $	*/
d69 1
d71 2
a72 3
	cmdp = NULL;

	for (i = 0; (cvs_cdt[i] != NULL) && (cmdp == NULL); i++) {
d74 1
a74 1
			cmdp = cvs_cdt[i];
d79 1
a79 1
					cmdp = cvs_cdt[i];
d86 1
a86 1
	return (cmdp);
@


1.64
log
@Simply the use of cmdp and cvs_command by zapping cvs_command and working
solely with cmdp.  This remedies some reliability issues with invalid
commands supplied and also fixes a GNU cvs style incompatibility with
release command.

> Based on patch from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.63 2007/09/25 10:56:04 chl Exp $	*/
d48 1
a57 1
	&cvs_cmd_rtag,
@


1.63
log
@remove unused extern variable

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.62 2007/09/04 19:07:03 tobias Exp $	*/
a68 1
	struct cvs_cmd *cmdp;
@


1.62
log
@Removed dead code.

OK joris@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.61 2007/06/27 20:27:38 xsa Exp $	*/
a31 2

extern char *cvs_rootstr;
@


1.61
log
@Remove last bits about login and logout commands, which will never be
implemented anyway. OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.60 2007/06/26 18:02:43 xsa Exp $	*/
a87 16

	return (cmdp);
}

struct cvs_cmd *
cvs_findcmdbyreq(u_int reqid)
{
	int i;
	struct cvs_cmd *cmdp;

	cmdp = NULL;
	for (i = 0; cvs_cdt[i] != NULL; i++)
		if (cvs_cdt[i]->cmd_req == reqid) {
			cmdp = cvs_cdt[i];
			break;
		}
@


1.60
log
@Bring back the release command. More work to be done though.
OK joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.59 2007/06/26 02:24:10 niallo Exp $	*/
a55 1
	&cvs_cmd_checkout,
a57 4
#if 0
	&cvs_cmd_login,
	&cvs_cmd_logout,
#endif
a60 1
	&cvs_cmd_update,
@


1.59
log
@add support for cvs rlog.
from Mickey.

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.58 2007/06/18 17:54:13 joris Exp $	*/
d47 1
a63 1
	&cvs_cmd_release,
@


1.58
log
@first stab at history stuff for opencvs, currently only writes
to CVSROOT/history but cannot parse it yet with the 'history' command.

"Commit it." ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.57 2007/02/22 06:42:09 otto Exp $	*/
d48 1
a63 1
	&cvs_cmd_rlog,
@


1.57
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.56 2007/02/19 11:40:00 otto Exp $	*/
d43 1
a56 1
	&cvs_cmd_history,
@


1.56
log
@Fix const inconsistencies, void pointer artithmetic and a few other
things. now gcc -Wall and lint are more happy. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.55 2006/11/27 14:19:53 xsa Exp $	*/
d26 2
d29 1
a29 1
#include "includes.h"
a31 1
#include "log.h"
@


1.55
log
@client-side of the annotate command is usable, build it too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.54 2006/11/14 09:47:52 xsa Exp $	*/
d98 1
a98 1
cvs_findcmdbyreq(int reqid)
@


1.54
log
@Bring back version command. Still needs tweaks to make the
gnu cvs client<->opencvs server setup work. Rest works fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.53 2006/11/13 12:57:03 xsa Exp $	*/
d37 1
a51 1
	&cvs_cmd_annotate,
@


1.53
log
@Add server-side bits for admin command.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.52 2006/07/07 17:37:17 joris Exp $	*/
d49 1
a65 1
	&cvs_cmd_version,
@


1.52
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.51 2006/06/12 13:56:00 xsa Exp $	*/
d36 1
d45 1
a48 1
	&cvs_cmd_server,
a49 1
	&cvs_cmd_admin,
@


1.51
log
@bring back a working version of the `cvs init' command. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.50 2006/06/07 18:19:07 xsa Exp $	*/
d47 1
a62 1
	&cvs_cmd_server,
@


1.50
log
@bring back tag command; basic tag addition/deletion available. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.49 2006/05/31 22:25:59 joris Exp $	*/
d41 1
a53 1
	&cvs_cmd_init,
@


1.49
log
@add support for the export command.

export does exactly the same as checkout except it does
not create any administrative (CVS/) directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.48 2006/05/30 07:00:30 joris Exp $	*/
a41 1
	&cvs_cmd_update,
d44 2
a62 1
	&cvs_cmd_tag,
@


1.48
log
@hello import, only works for non-existing repositories right now,
but work is in progress for importing stuff into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.47 2006/05/29 05:34:31 joris Exp $	*/
d39 1
a50 1
	&cvs_cmd_export,
@


1.47
log
@add remove support, hacked by xsa@@ but lots of modifications
from me to actually make it work properly.

commiting since xsa@@ is not around and i want to move forward.
ray@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.46 2006/05/28 21:11:12 joris Exp $	*/
d39 1
a51 1
	&cvs_cmd_import,
@


1.46
log
@add basic 'cvs log' support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.45 2006/05/28 10:15:35 joris Exp $	*/
d41 1
a58 1
	&cvs_cmd_remove,
@


1.45
log
@enable basic add command, only works on files right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.44 2006/05/27 03:30:30 joris Exp $	*/
d39 1
@


1.44
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.43 2006/04/14 02:45:35 deraadt Exp $	*/
d35 1
a41 1
	&cvs_cmd_add,
@


1.43
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.42 2006/01/02 08:11:56 xsa Exp $	*/
a30 1
#include "proto.h"
a33 12
/*
 * Command dispatch table
 * ----------------------
 *
 * The synopsis field should only contain the list of arguments that the
 * command supports, without the actual command's name.
 *
 * Command handlers are expected to return 0 if no error occurred, or one of
 * the CVS_EX_* error codes in case of an error.  In case the error
 * returned is 1, the command's usage string is printed to standard
 * error before returning.
 */
d35 6
a44 2
	&cvs_cmd_commit,
	&cvs_cmd_diff,
a50 4
#if defined(HAVE_KERBEROS)
	&cvs_cmd_kserver,
#endif
	&cvs_cmd_log,
a60 1
	&cvs_cmd_status,
d67 1
a70 11
#define MISSING_CVS_DIR		0x01
#define MISSING_CVS_ENTRIES	0x02
#define MISSING_CVS_REPO	0x04

/*
 * cvs_findcmd()
 *
 * Find the entry in the command dispatch table whose name or one of its
 * aliases matches <cmd>.
 * Returns a pointer to the command entry on success, NULL on failure.
 */
a109 162
}


/*
 * start the execution of a command.
 */
int
cvs_startcmd(struct cvs_cmd *cmd, int argc, char **argv)
{
	int i, ret, error;
	struct cvsroot *root;
	int (*ex_hdlr)(CVSFILE *, void *);
	CVSFILE *cf;
	struct stat st;

	/* if the command requested is the server one, just call the
	 * cvs_server() function to handle it, and return after it.
	 */
	if (cmd->cmd_op == CVS_OP_SERVER)
		return cvs_server(argc, argv);

	if ((root = cvsroot_get(".")) == NULL)
		return (CVS_EX_BADROOT);

	i = 1;
	if (cmd->cmd_init != NULL) {
		if ((ret = (*cmd->cmd_init)(cmd, argc, argv, &i)) != 0)
			return (ret);
	}

	argc -= i;
	argv += i;

	/*
	 * Check if we have the administrative files present, if we are
	 * missing one, we will error out because we cannot continue.
	 *
	 * We are not checking for CVS/Root since we fetched the root
	 * above via cvsroot_get().
	 *
	 * checkout, export, import, init and release do not depend on
	 * these files.
	 */
	error = 0;
	if (cmd->cmd_op != CVS_OP_CHECKOUT &&
	    cmd->cmd_op != CVS_OP_EXPORT &&
	    cmd->cmd_op != CVS_OP_IMPORT &&
	    cmd->cmd_op != CVS_OP_INIT &&
	    cmd->cmd_op != CVS_OP_RELEASE &&
	    cmd->cmd_op != CVS_OP_VERSION) {
		/* check for the CVS directory */
		ret = stat(CVS_PATH_CVSDIR, &st);
		if ((ret == -1 && errno == ENOENT) ||
		    (ret != -1 && !(S_ISDIR(st.st_mode))))
			error |= MISSING_CVS_DIR;

		/* check if the CVS/Entries file exists */
		ret = stat(CVS_PATH_ENTRIES, &st);
		if ((ret == -1 && errno == ENOENT) ||
		    (ret != -1 && !(S_ISREG(st.st_mode))))
			error |= MISSING_CVS_ENTRIES;

		/* check if the CVS/Repository file exists */
		ret = stat(CVS_PATH_REPOSITORY, &st);
		if ((ret == -1 && errno == ENOENT) ||
		    (ret != -1 && !(S_ISREG(st.st_mode))))
			error |= MISSING_CVS_REPO;
	}

	if (error > 0) {
		if (error & MISSING_CVS_DIR) {
			cvs_log(LP_ABORT, "missing '%s' directory",
			    CVS_PATH_CVSDIR);
			return (CVS_EX_FILE);
		}

		if (error & MISSING_CVS_ENTRIES)
			cvs_log(LP_ABORT, "missing '%s' file",
			    CVS_PATH_ENTRIES);
		if (error & MISSING_CVS_REPO)
			cvs_log(LP_ABORT, "missing '%s' file",
			    CVS_PATH_REPOSITORY);
		return (CVS_EX_FILE);
	}

	if (!(cmd->cmd_flags & CVS_CMD_ALLOWSPEC) && (argc > 0))
		return (CVS_EX_USAGE);

	/*
	 * This allows us to correctly fill in the repository
	 * string for CVSFILE's fetched inside the repository itself.
	 */
	if (cvs_cmdop == CVS_OP_SERVER)
		cvs_rootstr = xstrdup(root->cr_str);

	cvs_log(LP_TRACE, "cvs_startcmd() CVSROOT=%s", root->cr_str);

	if (root->cr_method != CVS_METHOD_LOCAL)
		cvs_connect(root);

	if (cmd->cmd_pre_exec != NULL) {
		if ((ret = cmd->cmd_pre_exec(root)) != 0)
			return (ret);
	}

	if (root->cr_method == CVS_METHOD_LOCAL)
		ex_hdlr = cmd->cmd_exec_local;
	else
		ex_hdlr = cmd->cmd_exec_remote;

	if (argc > 0) {
		ret = cvs_file_getspec(argv, argc, cmd->file_flags,
		    ex_hdlr, NULL, NULL);
	} else {
		ret = cvs_file_get(".", cmd->file_flags,
		    ex_hdlr, NULL, NULL);
	}

	if (ret != CVS_EX_OK)
		return (cvs_error);

	if (cmd->cmd_post_exec != NULL) {
		if ((ret = cmd->cmd_post_exec(root)) != 0)
			return (ret);
	}

	if (root->cr_method != CVS_METHOD_LOCAL) {
		/*
		 * If we have to send the directory the command
		 * has been issued in, obtain it.
		 */
		if (cmd->cmd_flags & CVS_CMD_SENDDIR) {
			cf = cvs_file_loadinfo(".", CF_NOFILES, NULL, NULL, 1);
			if (cf == NULL)
				return (CVS_EX_DATA);
			cvs_senddir(root, cf);
			cvs_file_free(cf);
		}

		if (cmd->cmd_flags & CVS_CMD_SENDARGS2) {
			for (i = 0; i < argc; i++)
				cvs_sendarg(root, argv[i], 0);
		}

		if (cmd->cmd_req != CVS_REQ_NONE) {
			cvs_sendreq(root, cmd->cmd_req,
			    (cmd->cmd_op == CVS_OP_INIT) ? root->cr_dir : NULL);
		}
	}

	if (cmd->cmd_cleanup != NULL)
		(*cmd->cmd_cleanup)();

#if 0
	if (cvs_cmdop != CVS_OP_SERVER && cmd->cmd_flags & CVS_CMD_PRUNEDIRS)
		cvs_file_prune(fpath);
#endif

	if (root->cr_method != CVS_METHOD_LOCAL)
		cvs_disconnect(root);

	return (0);
@


1.42
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.41 2005/12/30 17:51:01 reyk Exp $	*/
d178 6
a183 6
	if ((cmd->cmd_op != CVS_OP_CHECKOUT) &&
	    (cmd->cmd_op != CVS_OP_EXPORT) &&
	    (cmd->cmd_op != CVS_OP_IMPORT) &&
	    (cmd->cmd_op != CVS_OP_INIT) &&
	    (cmd->cmd_op != CVS_OP_RELEASE) &&
	    (cmd->cmd_op != CVS_OP_VERSION)) {
d186 2
a187 2
		if (((ret == -1) && (errno == ENOENT)) || ((ret != -1) &&
		    !(S_ISDIR(st.st_mode))))
d192 2
a193 2
		if (((ret == -1) && (errno == ENOENT)) || ((ret != -1) &&
		    !(S_ISREG(st.st_mode))))
d198 2
a199 2
		if (((ret == -1) && (errno == ENOENT)) || ((ret != -1) &&
		    !(S_ISREG(st.st_mode))))
@


1.41
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.40 2005/12/30 02:03:28 joris Exp $	*/
d27 1
a27 9
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.40
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.39 2005/12/10 20:27:45 joris Exp $	*/
d182 2
a183 1
	 * checkout, export, import, init and release do not depend on these files.
@


1.39
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.38 2005/12/03 01:02:08 joris Exp $	*/
d238 2
a239 2
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cvs_connect(root) < 0))
		return (CVS_EX_PROTO);
d276 1
a276 4
			if (cvs_senddir(root, cf) < 0) {
				cvs_file_free(cf);
				return (CVS_EX_PROTO);
			}
d281 2
a282 4
			for (i = 0; i < argc; i++) {
				if (cvs_sendarg(root, argv[i], 0) < 0)
					return (CVS_EX_PROTO);
			}
d285 4
a288 4
		if (cmd->cmd_req != CVS_REQ_NONE &&
		    cvs_sendreq(root, cmd->cmd_req,
		    (cmd->cmd_op == CVS_OP_INIT) ? root->cr_dir : NULL) < 0)
			return (CVS_EX_PROTO);
@


1.38
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.37 2005/10/22 17:23:21 joris Exp $	*/
d233 2
a234 5
	if (cvs_cmdop == CVS_OP_SERVER) {
		cvs_rootstr = strdup(root->cr_str);
		if (cvs_rootstr == NULL)
			return (CVS_EX_DATA);
	}
@


1.37
log
@- don't check for admin files when running init;
- don't pass the Entry for newly added files to cvs_date_parse()
- in rcs_rev_add don't bother looking for the previous rev if we
  are creating the RCS file.

from PR 4575
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.36 2005/10/07 21:47:32 reyk Exp $	*/
d41 1
d228 10
@


1.36
log
@knf and spacing, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.35 2005/09/13 17:24:38 joris Exp $	*/
d181 1
a181 1
	 * checkout, export, import and release do not depend on these files.
d187 1
@


1.35
log
@unbreak opencvs server
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.34 2005/09/07 17:43:15 joris Exp $	*/
d184 4
a187 2
	if ((cmd->cmd_op != CVS_OP_CHECKOUT) && (cmd->cmd_op != CVS_OP_EXPORT) &&
	    (cmd->cmd_op != CVS_OP_IMPORT) && (cmd->cmd_op != CVS_OP_RELEASE) &&
d216 2
a217 1
			cvs_log(LP_ABORT, "missing '%s' file", CVS_PATH_ENTRIES);
d219 2
a220 1
			cvs_log(LP_ABORT, "missing '%s' file", CVS_PATH_REPOSITORY);
@


1.34
log
@make sure the administrative files that the commands depend on are
present before we try to continue.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.33 2005/07/26 16:03:20 xsa Exp $	*/
d185 2
a186 1
	    (cmd->cmd_op != CVS_OP_IMPORT) && (cmd->cmd_op != CVS_OP_RELEASE)) {
@


1.33
log
@move trace message before calling cvs_connect();
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.32 2005/07/25 12:05:43 xsa Exp $	*/
d29 1
d91 3
a93 1

d150 1
a150 2
	int i;
	int ret;
d154 1
d173 45
@


1.32
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.31 2005/07/23 11:19:46 joris Exp $	*/
d174 2
a177 2

	cvs_log(LP_TRACE, "cvs_startcmd() CVSROOT=%s", root->cr_str);
@


1.31
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.30 2005/07/21 11:42:24 xsa Exp $	*/
d99 1
a99 1
struct cvs_cmd*
d124 1
a124 1
struct cvs_cmd*
@


1.30
log
@<sys/param.h> is already included in "cvs.h", no need to duplicate;
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.29 2005/07/08 10:30:24 joris Exp $	*/
d151 1
a151 1
	char fpath[MAXPATHLEN];
d190 2
a191 2
		cvs_files = cvs_file_getspec(argv, argc, cmd->file_flags,
		    ex_hdlr, NULL);
d193 2
a194 2
		cvs_files = cvs_file_get(".", cmd->file_flags,
		    ex_hdlr, NULL);
d197 2
a198 4
	if (cvs_files == NULL)
		return (CVS_EX_DATA);

	cvs_file_getpath(cvs_files, fpath, sizeof(fpath));
d206 4
d211 5
a215 1
			if (cvs_senddir(root, cvs_files) < 0)
d217 2
d228 2
a229 1
		if (cmd->cmd_req != CVS_REQ_NONE && cvs_sendreq(root, cmd->cmd_req,
d237 1
d240 1
@


1.29
log
@

don't try to run the pruning function on server side.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.28 2005/07/07 14:27:57 joris Exp $	*/
a26 1
#include <sys/param.h>
@


1.28
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.27 2005/07/04 07:11:10 xsa Exp $	*/
d229 1
a229 1
	if (cmd->cmd_flags & CVS_CMD_PRUNEDIRS)
@


1.27
log
@enable all commands; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.26 2005/06/14 15:27:31 joris Exp $	*/
d231 1
a231 1
		
@


1.26
log
@

finish pruning support, this has been sitting
in my tree since c2k5

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.25 2005/06/13 13:02:18 xsa Exp $	*/
a60 1
#if 0
a63 1
#endif
a82 1
#if 0
a83 1
#endif
a85 1
#if 0
a87 1
#endif
@


1.25
log
@move the CVSROOT check earlier in the process, this way we get the
CVSROOT checked before the commands are run ... ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.24 2005/06/07 16:22:19 joris Exp $	*/
d158 1
d207 2
d235 3
@


1.24
log
@

don't forget to call cvs_disconnect() at the end
of a remote connection.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.23 2005/06/02 20:12:06 joris Exp $	*/
d165 3
a178 3

	if ((root = cvsroot_get(".")) == NULL)
		return (CVS_EX_BADROOT);
@


1.23
log
@

handle commands which do not have any init callback a bit
better, eliminates the use of dummy functions.

OK jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.22 2005/05/31 08:58:47 xsa Exp $	*/
d231 3
@


1.22
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.21 2005/05/25 04:12:54 jfb Exp $	*/
d165 1
d169 1
d171 2
a172 3
		argc -= i;
		argv += i;
	}
@


1.21
log
@no need to check cvs_trace before outputting a trace, the log code
does it for us
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.20 2005/05/24 04:21:54 jfb Exp $	*/
d31 2
d34 1
a34 1
#include <stdio.h>
a35 2
#include <errno.h>
#include <string.h>
a38 1
#include "rcs.h"
@


1.20
log
@remove debugging messages
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.19 2005/05/24 04:12:25 jfb Exp $	*/
d182 2
a183 2
	if (cvs_trace)
		cvs_log(LP_TRACE, "cvs_startcmd() CVSROOT=%s", root->cr_str);
@


1.19
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.18 2005/05/23 17:43:54 xsa Exp $	*/
a166 1
		printf("[init]\n");
a185 1
		printf("[pre-exec]\n");
a206 1
		printf("[post-exec]\n");
@


1.18
log
@add some logging for `cvs -t' option use; ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.17 2005/05/20 05:13:44 joris Exp $	*/
d42 107
d158 1
a158 1
	struct cvs_cmd_info *c = cmd->cmd_info;
d163 2
a164 4
	if (cmd->cmd_op == CVS_OP_SERVER) {
		ret = cvs_server(argc, argv);
		return (ret);
	}
d166 3
a168 2
	if (c->cmd_options != NULL) {
		if ((ret = c->cmd_options(cmd->cmd_opts, argc, argv, &i)) != 0)
d175 2
a176 2
	if ((c->cmd_helper != NULL) && ((ret = c->cmd_helper()) != 0))
		return (ret);
d181 2
d186 4
a189 20
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_connect(root) < 0)
			return (CVS_EX_PROTO);

		if (c->cmd_flags & CVS_CMD_SENDARGS1) {
			for (i = 0; i < argc; i++) {
				if (cvs_sendarg(root, argv[i], 0) < 0)
					return (CVS_EX_PROTO);
			}
		}

		if (c->cmd_sendflags != NULL) {
			if ((ret = c->cmd_sendflags(root)) != 0)
				return (ret);
		}

		if (c->cmd_flags & CVS_CMD_NEEDLOG) {
			if (cvs_logmsg_send(root, cvs_msg) < 0)
				return (CVS_EX_PROTO);
		}
d192 8
a199 9
	/* if we are the version command, don't bother going
	 * any further now, we did everything we had to.
	 */
	if (cmd->cmd_op == CVS_OP_VERSION)
		return (0);

	if ((c->cmd_flags & CVS_CMD_ALLOWSPEC) && argc != 0) {
		cvs_files = cvs_file_getspec(argv, argc, c->file_flags,
		    c->cmd_examine, NULL);
d201 2
a202 2
		cvs_files = cvs_file_get(".", c->file_flags,
		    c->cmd_examine, NULL);
d208 6
d215 1
a215 1
		if (c->cmd_flags & CVS_CMD_SENDDIR) {
d220 1
a220 1
		if (c->cmd_flags & CVS_CMD_SENDARGS2) {
d227 1
a227 1
		if (cvs_sendreq(root, c->cmd_req,
d231 3
@


1.17
log
@

execute the command callback at the same time we are building
the in-memory filelist. cuts down on execution time for larger trees.

"put it in!" jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.16 2005/04/25 21:58:32 joris Exp $	*/
d74 3
@


1.16
log
@

first part of file API changes:

- fix our behaviour regarding directories or files in a different
  directory than we currently are as arguments to commands, this
  allows stuff like "cvs status sys/arch/i386/Makefile" to work.

- when parsing a pathname only load the needed nodes of the path
  instead of loading *everything* in memory.

the next step in this is to merge the collection and callback
execution together.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.15 2005/04/25 17:59:16 jfb Exp $	*/
a68 8
	if ((c->cmd_flags & CVS_CMD_ALLOWSPEC) && argc != 0)
		cvs_files = cvs_file_getspec(argv, argc, c->file_flags);
	else
		cvs_files = cvs_file_get(".", c->file_flags);

	if (cvs_files == NULL)
		return (CVS_EX_DATA);

d72 1
a72 2
	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL && (root = cvsroot_get(".")) == NULL)
d103 10
a112 2
	if (c->cmd_examine != NULL)
		cvs_file_examine(cvs_files, c->cmd_examine, NULL);
@


1.15
log
@* add missing 'R' flag in diff synopsis
* add the CVS_EX_BADROOT return code to indicate that there was no
  CVSROOT given or it was invalid

ok joris, xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.14 2005/04/18 21:06:46 jfb Exp $	*/
d70 1
a70 1
		cvs_files = cvs_file_getspec(argv, argc, 0);
@


1.14
log
@remove debugging leftovers
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.13 2005/04/18 21:02:49 jfb Exp $	*/
d81 2
a82 7
	if (root == NULL && (root = cvsroot_get(".")) == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified! Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT enviroment variable.");
		return (CVS_EX_USAGE);
	}
@


1.13
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.12 2005/04/13 14:49:05 joris Exp $	*/
a118 4

	printf("YO BITCH, I'M DONE\n");
	getchar();
	exit(0);
@


1.12
log
@

cmd_helper() returns error codes > 0 or 0 on success.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.11 2005/04/12 17:20:01 joris Exp $	*/
d119 4
@


1.11
log
@

use the new CVS_EX_* error codes here as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.10 2005/04/12 14:58:40 joris Exp $	*/
d77 1
a77 1
	if ((c->cmd_helper != NULL) && ((ret = c->cmd_helper()) < 0))
@


1.10
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.9 2005/04/11 18:02:58 joris Exp $	*/
d75 1
a75 1
		return (-1);
d86 1
a86 1
		return (1);
d91 1
a91 1
			return (-1);
d96 1
a96 1
					return (-1);
d107 1
a107 1
				return (-1);
d123 1
a123 1
				return (-1);
d129 1
a129 1
					return (-1);
d135 1
a135 1
			return (-1);
@


1.9
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.8 2005/04/11 17:56:27 joris Exp $	*/
d101 1
a101 1
			if ((ret = c->cmd_sendflags(root)) < 0)
@


1.8
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.7 2005/04/03 17:32:50 xsa Exp $	*/
a35 1
#include <sysexits.h>
@


1.7
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.6 2005/04/01 09:44:00 joris Exp $	*/
d63 1
a63 1
		if ((ret = c->cmd_options(cmd->cmd_opts, argc, argv, &i)) < 0)
d87 1
a87 1
		return (EX_USAGE);
@


1.6
log
@

make sure we don't do unneeded things for the version command.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.5 2005/03/31 17:18:24 joris Exp $	*/
d63 1
a63 1
		if ((ret = c->cmd_options(cmd->cmd_opts, argc, argv, &i)))
d76 1
a76 1
		return (EX_DATAERR);
d78 1
a78 1
	if ((c->cmd_helper != NULL) && ((ret = c->cmd_helper())))
d92 1
a92 1
			return (EX_PROTOCOL);
d97 1
a97 1
					return (EX_PROTOCOL);
d102 1
a102 1
			if ((ret = c->cmd_sendflags(root)))
d108 1
a108 1
				return (EX_PROTOCOL);
d124 1
a124 1
				return (EX_PROTOCOL);
d130 1
a130 1
					return (EX_PROTOCOL);
d136 1
a136 1
			return (EX_PROTOCOL);
@


1.5
log
@

make sure the server command can still be reached with the
new framework.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.4 2005/03/31 15:47:17 joris Exp $	*/
d111 6
@


1.4
log
@

- as long as we are using the sysexits.h error codes make sure
  we handle them.
- handle cmd_sendflags() when it fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.3 2005/03/29 03:10:27 joris Exp $	*/
d53 8
@


1.3
log
@

allow cmd_options to be NULL, so that commands which
have no options will work fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.2 2005/03/28 17:17:38 joris Exp $	*/
d55 1
a55 1
		if ((ret = c->cmd_options(cmd->cmd_opts, argc, argv, &i)) < 0)
d70 1
a70 1
	if ((c->cmd_helper != NULL) && ((ret = c->cmd_helper()) < 0))
d93 4
a96 2
		if (c->cmd_sendflags != NULL)
			c->cmd_sendflags(root);
@


1.2
log
@

fix argument count in cvs_startcmd()

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.1 2005/03/24 01:03:41 joris Exp $	*/
d54 7
a60 5
	if ((ret = c->cmd_options(cmd->cmd_opts, argc, argv, &i)) < 0)
		return (ret);

	argc -= i;
	argv += i;
@


1.1
log
@

add the first pieces of our new command framework.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a57 1
	argc += i;
@

