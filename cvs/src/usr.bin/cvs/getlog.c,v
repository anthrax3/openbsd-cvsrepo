head	1.100;
access;
symbols
	OPENBSD_6_1:1.100.0.2
	OPENBSD_6_1_BASE:1.100
	OPENBSD_6_0:1.98.0.8
	OPENBSD_6_0_BASE:1.98
	OPENBSD_5_9:1.98.0.4
	OPENBSD_5_9_BASE:1.98
	OPENBSD_5_8:1.98.0.6
	OPENBSD_5_8_BASE:1.98
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.97.0.6
	OPENBSD_5_6_BASE:1.97
	OPENBSD_5_5:1.97.0.4
	OPENBSD_5_5_BASE:1.97
	OPENBSD_5_4:1.96.0.2
	OPENBSD_5_4_BASE:1.96
	OPENBSD_5_3:1.95.0.12
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.95.0.10
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.8
	OPENBSD_5_0:1.95.0.6
	OPENBSD_5_0_BASE:1.95
	OPENBSD_4_9:1.95.0.4
	OPENBSD_4_9_BASE:1.95
	OPENBSD_4_8:1.95.0.2
	OPENBSD_4_8_BASE:1.95
	OPENBSD_4_7:1.93.0.2
	OPENBSD_4_7_BASE:1.93
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.90.0.2
	OPENBSD_4_5_BASE:1.90
	OPENBSD_4_4:1.89.0.2
	OPENBSD_4_4_BASE:1.89
	OPENBSD_4_3:1.87.0.2
	OPENBSD_4_3_BASE:1.87
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.71.0.2
	OPENBSD_4_1_BASE:1.71
	OPENBSD_4_0:1.65.0.2
	OPENBSD_4_0_BASE:1.65
	OPENBSD_3_9:1.55.0.2
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.100
date	2016.10.15.22.20.17;	author millert;	state Exp;
branches;
next	1.99;
commitid	bZGHsljlW6kmRYub;

1.99
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.98;
commitid	8Vv7d4HkmCtExfc6;

1.98
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.97;
commitid	Z3HC5pAWzpo5jsTe;

1.97
date	2014.01.08.13.23.55;	author okan;	state Exp;
branches;
next	1.96;

1.96
date	2013.06.03.17.04.35;	author jcs;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.30.21.47.18;	author ray;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.26.17.30.04;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.23.15.13.58;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.23.15.10.09;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2008.09.12.13.38.35;	author tobias;	state Exp;
branches;
next	1.89;

1.89
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.88;

1.88
date	2008.06.09.23.33.15;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.02.19.05.34;	author tobias;	state Exp;
branches;
next	1.86;

1.86
date	2008.02.09.14.25.02;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.09.14.03.20;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.04.21.25.32;	author tobias;	state Exp;
branches;
next	1.83;

1.83
date	2008.01.31.22.09.05;	author xsa;	state Exp;
branches;
next	1.82;

1.82
date	2008.01.31.20.29.16;	author joris;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.12.22.39.32;	author tobias;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.10.11.25.27;	author tobias;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.24.22.06.28;	author joris;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.17.19.59.25;	author xsa;	state Exp;
branches;
next	1.75;

1.75
date	2007.07.17.19.56.08;	author xsa;	state Exp;
branches;
next	1.74;

1.74
date	2007.07.16.12.16.01;	author xsa;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.26.02.24.10;	author niallo;	state Exp;
branches;
next	1.71;

1.71
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.10.15.49.03;	author xsa;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.08.22.05.52;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2006.10.24.13.15.34;	author xsa;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2006.06.02.19.10.24;	author david;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.30.21.34.03;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.29.18.00.02;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.29.06.29.49;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.28.21.35.58;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.28.21.11.12;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.04.14.22.33.15;	author niallo;	state Exp;
branches;
next	1.55;

1.55
date	2006.02.06.16.21.43;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.30.17.58.47;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.29.11.09.45;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.27.15.26.38;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.30.16.42.13;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.22.14.59.54;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.03.15.57.40;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.08.14.48.27;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2005.08.05.10.17.14;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.27.16.42.19;	author xsa;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.22.16.27.29;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.21.11.42.24;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.19.02.18.05;	author joris;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.15.08.39.14;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.14.06.50.50;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.11.08.44.16;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.11.08.36.58;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.01.15.00.22;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.01.14.55.30;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.01.14.29.13;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.29.14.30.38;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.20.16.57.31;	author jfb;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.19.16.11.10;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.19.15.37.50;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.11.22.50.09;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.16.20.05.05;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.13.19.44.42;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.13.16.37.50;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.26.08.09.54;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.27.00.22.08;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.21.18.32.10;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.14.22.30.48;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.14.20.19.37;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.06.03.13.52;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.18.15.54.17;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.13.13.37.49;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.31.01.14.21;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.30.01.49.23;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.29.18.23.26;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.100
log
@Quiet compiler warnings.  OK tomc@@ tb@@
@
text
@/*	$OpenBSD: getlog.c,v 1.99 2016/10/13 20:51:25 fcambus Exp $	*/
/*
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>

#include "cvs.h"
#include "remote.h"

#define L_HEAD		0x01
#define L_HEAD_DESCR	0x02
#define L_NAME		0x04
#define L_NOTAGS	0x08
#define L_LOGINS	0x10
#define L_STATES	0x20

#define LDATE_LATER	0x01
#define LDATE_EARLIER	0x02
#define LDATE_SINGLE	0x04
#define LDATE_RANGE	0x08
#define LDATE_INCLUSIVE	0x10

void		 cvs_log_local(struct cvs_file *);
static void	 log_rev_print(struct rcs_delta *);
static char 	*push_date(char *dest, const char *);
static u_int	 date_select(RCSFILE *, char *);

int	 runflags = 0;
char	*logrev = NULL;
char	*logdate = NULL;
char	*slist = NULL;
char	*wlist = NULL;

struct cvs_cmd cvs_cmd_log = {
	CVS_OP_LOG, CVS_USE_WDIR, "log",
	{ "lo" },
	"Print out history information for files",
	"[-bhlNRt] [-d dates] [-r revisions] [-s states] [-w logins]",
	"bd:hlNRr:s:tw:",
	NULL,
	cvs_getlog
};

struct cvs_cmd cvs_cmd_rlog = {
	CVS_OP_RLOG, 0, "rlog",
	{ "rlo" },
	"Print out history information for files",
	"[-bhlNRt] [-d dates] [-r revisions] [-s states] [-w logins]",
	"bd:hlNRr:s:tw:",
	NULL,
	cvs_getlog
};

int
cvs_getlog(int argc, char **argv)
{
	int ch, flags, i;
	char *arg = ".";
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;

	while ((ch = getopt(argc, argv, cvs_cmdop == CVS_OP_LOG ?
	    cvs_cmd_log.cmd_opts : cvs_cmd_rlog.cmd_opts)) != -1) {
		switch (ch) {
		case 'd':
			logdate = push_date(logdate, optarg);
			break;
		case 'h':
			runflags |= L_HEAD;
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'N':
			runflags |= L_NOTAGS;
			break;
		case 'R':
			runflags |= L_NAME;
			break;
		case 'r':
			logrev = optarg;
			break;
		case 's':
			runflags |= L_STATES;
			slist = optarg;
			break;
		case 't':
			runflags |= L_HEAD_DESCR;
			break;
		case 'w':
			runflags |= L_LOGINS;
			wlist = optarg;
			break;
		default:
			fatal("%s", cvs_cmdop == CVS_OP_LOG ?
			    cvs_cmd_log.cmd_synopsis :
			    cvs_cmd_rlog.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (cvs_cmdop == CVS_OP_RLOG) {
		flags |= CR_REPO;

		if (argc == 0)
			return 0;

		for (i = 0; i < argc; i++)
			if (argv[i][0] == '/')
				fatal("Absolute path name is invalid: %s",
				    argv[i]);
	}

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (logdate != NULL)
			cvs_client_send_request("Argument -d%s", logdate);

		if (runflags & L_HEAD)
			cvs_client_send_request("Argument -h");

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");

		if (runflags & L_NOTAGS)
			cvs_client_send_request("Argument -N");

		if (runflags & L_NAME)
			cvs_client_send_request("Argument -R");

		if (logrev != NULL)
			cvs_client_send_request("Argument -r%s", logrev);

		if (runflags & L_STATES)
			cvs_client_send_request("Argument -s%s", slist);

		if (runflags & L_HEAD_DESCR)
			cvs_client_send_request("Argument -t");

		if (runflags & L_LOGINS)
			cvs_client_send_request("Argument -w%s", wlist);
	} else {
		if (cvs_cmdop == CVS_OP_RLOG &&
		    chdir(current_cvsroot->cr_dir) == -1)
			fatal("cvs_getlog: %s", strerror(errno));

		cr.fileproc = cvs_log_local;
	}

	cr.flags = flags;

	if (cvs_cmdop == CVS_OP_LOG ||
	    current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
		if (argc > 0)
			cvs_file_run(argc, argv, &cr);
		else
			cvs_file_run(1, &arg, &cr);
	}

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");

		cvs_client_send_request((cvs_cmdop == CVS_OP_RLOG) ?
		    "rlog" : "log");

		cvs_client_get_responses();
	}

	return (0);
}

void
cvs_log_local(struct cvs_file *cf)
{
	u_int nrev;
	RCSNUM *rev;
	struct rcs_sym *sym;
	struct rcs_lock *lkp;
	struct rcs_delta *rdp;
	struct rcs_access *acp;
	char numb[CVS_REV_BUFSZ];

	cvs_log(LP_TRACE, "cvs_log_local(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_type == CVS_DIR) {
		if (verbosity > 1)
			cvs_log(LP_ERR, "Logging %s", cf->file_path);
		return;
	}

	if (cf->file_rcs == NULL) {
		return;
	} else if (cf->file_status == FILE_ADDED) {
		if (verbosity > 0)
			cvs_log(LP_ERR, "%s has been added, but not committed",
			    cf->file_path);
		return;
	}

	if (runflags & L_NAME) {
		cvs_printf("%s\n", cf->file_rpath);
		return;
	}

	if (logrev != NULL)
		nrev = cvs_revision_select(cf->file_rcs, logrev);
	else if (logdate != NULL) {
		if ((nrev = date_select(cf->file_rcs, logdate)) == (u_int)-1) {
			cvs_log(LP_ERR, "invalid date: %s", logdate);
			return;
		}
	} else
		nrev = cf->file_rcs->rf_ndelta;

	cvs_printf("\nRCS file: %s", cf->file_rpath);

	if (cvs_cmdop != CVS_OP_RLOG)
		cvs_printf("\nWorking file: %s", cf->file_path);

	cvs_printf("\nhead:");
	if (cf->file_rcs->rf_head != NULL)
		cvs_printf(" %s", rcsnum_tostr(cf->file_rcs->rf_head,
		    numb, sizeof(numb)));

	cvs_printf("\nbranch:");
	if (rcs_branch_get(cf->file_rcs) != NULL) {
		cvs_printf(" %s", rcsnum_tostr(rcs_branch_get(cf->file_rcs),
		    numb, sizeof(numb)));
	}

	cvs_printf("\nlocks: %s", (cf->file_rcs->rf_flags & RCS_SLOCK)
	    ? "strict" : "");
	TAILQ_FOREACH(lkp, &(cf->file_rcs->rf_locks), rl_list)
		cvs_printf("\n\t%s: %s", lkp->rl_name,
		    rcsnum_tostr(lkp->rl_num, numb, sizeof(numb)));

	cvs_printf("\naccess list:\n");
	TAILQ_FOREACH(acp, &(cf->file_rcs->rf_access), ra_list)
		cvs_printf("\t%s\n", acp->ra_name);

	if (!(runflags & L_NOTAGS)) {
		cvs_printf("symbolic names:\n");
		TAILQ_FOREACH(sym, &(cf->file_rcs->rf_symbols), rs_list) {
			rev = rcsnum_alloc();
			rcsnum_cpy(sym->rs_num, rev, 0);
			if (RCSNUM_ISBRANCH(sym->rs_num))
				rcsnum_addmagic(rev);

			cvs_printf("\t%s: %s\n", sym->rs_name,
			    rcsnum_tostr(rev, numb, sizeof(numb)));
			free(rev);
		}
	}

	cvs_printf("keyword substitution: %s\n",
	    cf->file_rcs->rf_expand == NULL ? "kv" : cf->file_rcs->rf_expand);

	cvs_printf("total revisions: %u", cf->file_rcs->rf_ndelta);

	if (cf->file_rcs->rf_head != NULL &&
	    !(runflags & L_HEAD) && !(runflags & L_HEAD_DESCR))
		cvs_printf(";\tselected revisions: %u", nrev);

	cvs_printf("\n");

	if (!(runflags & L_HEAD) || (runflags & L_HEAD_DESCR))
		cvs_printf("description:\n%s", cf->file_rcs->rf_desc);

	if (!(runflags & L_HEAD) && !(runflags & L_HEAD_DESCR)) {
		TAILQ_FOREACH(rdp, &(cf->file_rcs->rf_delta), rd_list) {
			/*
			 * if selections are enabled verify that entry is
			 * selected.
			 */
			if ((logrev == NULL && logdate == NULL) ||
			    (rdp->rd_flags & RCS_RD_SELECT))
				log_rev_print(rdp);
		}
	}

	cvs_printf("%s\n", LOG_REVEND);
}

static void
log_rev_print(struct rcs_delta *rdp)
{
	int i, found;
	char numb[CVS_REV_BUFSZ], timeb[CVS_TIME_BUFSZ];
	struct cvs_argvector *sargv, *wargv;
	struct rcs_branch *rb;
	struct rcs_delta *nrdp;

	i = found = 0;

	/* -s states */
	if (runflags & L_STATES) {
		sargv = cvs_strsplit(slist, ",");
		for (i = 0; sargv->argv[i] != NULL; i++) {
			if (strcmp(rdp->rd_state, sargv->argv[i]) == 0) {
				found++;
				break;
			}
			found = 0;
		}
		cvs_argv_destroy(sargv);
	}

	/* -w[logins] */
	if (runflags & L_LOGINS) {
		wargv = cvs_strsplit(wlist, ",");
		for (i = 0; wargv->argv[i] != NULL; i++) {
			if (strcmp(rdp->rd_author, wargv->argv[i]) == 0) {
				found++;
				break;
			}
			found = 0;
		}
		cvs_argv_destroy(wargv);
	}

	if ((runflags & (L_STATES|L_LOGINS)) && found == 0)
		return;

	cvs_printf("%s\n", LOG_REVSEP);

	rcsnum_tostr(rdp->rd_num, numb, sizeof(numb));
	cvs_printf("revision %s", numb);

	strftime(timeb, sizeof(timeb), "%Y/%m/%d %H:%M:%S", &rdp->rd_date);
	cvs_printf("\ndate: %s;  author: %s;  state: %s;",
	    timeb, rdp->rd_author, rdp->rd_state);

	/*
	 * If we are a branch revision, the diff of this revision is stored
	 * in place.
	 * Otherwise, it is stored in the previous revision as a reversed diff.
	 */
	if (RCSNUM_ISBRANCHREV(rdp->rd_num))
		nrdp = rdp;
	else
		nrdp = TAILQ_NEXT(rdp, rd_list);

	/*
	 * We do not write diff stats for the first revision of the default
	 * branch, since it was not a diff but a full text.
	 */
	if (nrdp != NULL && rdp->rd_num->rn_len == nrdp->rd_num->rn_len) {
		int added, removed;
		rcs_delta_stats(nrdp, &added, &removed);
		if (RCSNUM_ISBRANCHREV(rdp->rd_num))
			cvs_printf("  lines: +%d -%d;", added, removed);
		else
			cvs_printf("  lines: +%d -%d;", removed, added);
	}

	if (rdp->rd_commitid != NULL)
		printf("  commitid: %s;", rdp->rd_commitid);

	cvs_printf("\n");

	if (!TAILQ_EMPTY(&(rdp->rd_branches))) {
		cvs_printf("branches:");
		TAILQ_FOREACH(rb, &(rdp->rd_branches), rb_list) {
			RCSNUM *branch;
			branch = rcsnum_revtobr(rb->rb_num);
			rcsnum_tostr(branch, numb, sizeof(numb));
			cvs_printf("  %s;", numb);
			free(branch);
		}
		cvs_printf("\n");
	}

	cvs_printf("%s", rdp->rd_log);
}

static char *
push_date(char *dest, const char *src)
{
	size_t len;

	if (dest == NULL)
		return (xstrdup(src));

	/* 2 = ; and '\0' */
	len = strlen(dest) + strlen(src) + 2;

	dest[strlen(dest)] = ';';
	dest = xreallocarray(dest, len, 1);
	strlcat(dest, src, len);
	return (dest);
}

static u_int
date_select(RCSFILE *file, char *date)
{
	int i, nrev, flags;
	struct rcs_delta *rdp;
	struct cvs_argvector *args;
	char *first, *last, delim;
	time_t firstdate, lastdate, rcsdate;

	nrev = 0;
	args = cvs_strsplit(date, ";");

	for (i = 0; args->argv[i] != NULL; i++) {
		flags = 0;
		firstdate = lastdate = -1;

		first = args->argv[i];
		last = strchr(args->argv[i], '<');
		if (last != NULL) {
			delim = *last;
			*last++ = '\0';

			if (*last == '=') {
				last++;
				flags |= LDATE_INCLUSIVE;
			}
		} else {
			last = strchr(args->argv[i], '>');
			if (last != NULL) {
				delim = *last;
				*last++ = '\0';

				if (*last == '=') {
					last++;
					flags |= LDATE_INCLUSIVE;
				}
			}
		}

		if (last == NULL) {
			flags |= LDATE_SINGLE;
			if ((firstdate = date_parse(first)) == -1)
				return -1;
			delim = '\0';
			last = "\0";
		} else {
			while (*last && isspace((unsigned char)*last))
				last++;
		}

		if (delim == '>' && *last == '\0') {
			flags |= LDATE_EARLIER;
			if ((firstdate = date_parse(first)) == -1)
				return -1;
		}

		if (delim == '>' && *first == '\0' && *last != '\0') {
			flags |= LDATE_LATER;
			if ((firstdate = date_parse(last)) == -1)
				return -1;
		}

		if (delim == '<' && *last == '\0') {
			flags |= LDATE_LATER;
			if ((firstdate = date_parse(first)) == -1)
				return -1;
		}

		if (delim == '<' && *first == '\0' && *last != '\0') {
			flags |= LDATE_EARLIER;
			if ((firstdate = date_parse(last)) == -1)
				return -1;
		}

		if (*first != '\0' && *last != '\0') {
			flags |= LDATE_RANGE;

			if (delim == '<') {
				firstdate = date_parse(first);
				lastdate = date_parse(last);
			} else {
				firstdate = date_parse(last);
				lastdate = date_parse(first);
			}
			if (firstdate == -1 || lastdate == -1)
				return -1;
		}

		TAILQ_FOREACH(rdp, &(file->rf_delta), rd_list) {
			rcsdate = mktime(&(rdp->rd_date));

			if (flags & LDATE_SINGLE) {
				if (rcsdate <= firstdate) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					break;
				}
			}

			if (flags & LDATE_EARLIER) {
				if (rcsdate < firstdate) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}

				if (flags & LDATE_INCLUSIVE &&
				    (rcsdate <= firstdate)) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}
			}

			if (flags & LDATE_LATER) {
				if (rcsdate > firstdate) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}

				if (flags & LDATE_INCLUSIVE &&
				    (rcsdate >= firstdate)) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}
			}

			if (flags & LDATE_RANGE) {
				if ((rcsdate > firstdate) &&
				    (rcsdate < lastdate)) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}

				if (flags & LDATE_INCLUSIVE &&
				    ((rcsdate >= firstdate) &&
				    (rcsdate <= lastdate))) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}
			}
		}
	}

	cvs_argv_destroy(args);

	return (nrev);
}
@


1.99
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.98 2014/12/01 21:58:46 deraadt Exp $	*/
d237 1
a237 1
		if ((nrev = date_select(cf->file_rcs, logdate)) == -1) {
@


1.98
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.97 2014/01/08 13:23:55 okan Exp $	*/
d20 1
d280 1
a280 1
			rcsnum_free(rev);
d397 1
a397 1
			rcsnum_free(branch);
@


1.97
log
@unsigned char for ctype. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.96 2013/06/03 17:04:35 jcs Exp $	*/
d416 1
a416 1
	dest = xrealloc(dest, len, 1);
@


1.96
log
@properly handle commitid tokens found in rcs files

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.95 2010/07/30 21:47:18 ray Exp $	*/
d467 1
a467 1
			while (*last && isspace(*last))
@


1.95
log
@Check date_parse return values.

OK xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.94 2010/07/23 21:46:05 ray Exp $	*/
d379 1
a379 1
			cvs_printf("  lines: +%d -%d", added, removed);
d381 1
a381 1
			cvs_printf("  lines: +%d -%d", removed, added);
d383 4
@


1.94
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.93 2009/03/26 17:30:04 joris Exp $	*/
d235 6
a240 3
	else if (logdate != NULL)
		nrev = date_select(cf->file_rcs, logdate);
	else
d458 2
a459 1
			firstdate = date_parse(first);
d469 2
a470 1
			firstdate = date_parse(first);
d475 2
a476 1
			firstdate = date_parse(last);
d481 2
a482 1
			firstdate = date_parse(first);
d487 2
a488 1
			firstdate = date_parse(last);
d501 2
@


1.93
log
@"Logging dirname" needs to be properly shown when running log/rlog.
spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.92 2009/03/23 15:13:58 joris Exp $	*/
d455 1
a455 1
			firstdate = cvs_date_parse(first);
d465 1
a465 1
			firstdate = cvs_date_parse(first);
d470 1
a470 1
			firstdate = cvs_date_parse(last);
d475 1
a475 1
			firstdate = cvs_date_parse(first);
d480 1
a480 1
			firstdate = cvs_date_parse(last);
d487 2
a488 2
				firstdate = cvs_date_parse(first);
				lastdate = cvs_date_parse(last);
d490 2
a491 2
				firstdate = cvs_date_parse(last);
				lastdate = cvs_date_parse(first);
@


1.92
log
@remove debug, bleh
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.90 2008/09/12 13:38:35 tobias Exp $	*/
d213 6
a224 6
		return;
	}

	if (cf->file_type == CVS_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Logging %s", cf->file_path);
@


1.91
log
@add rlog -d support, ported from openrcs by
Josh Elsasser <josh@@elsasser.org>
@
text
@a118 2
	cvs_printf("dates: %s\n", logdate);

@


1.90
log
@Move the revision selection in front of output, so errors won't mix up
with output.  Matches GNU cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.89 2008/06/14 04:34:08 tobias Exp $	*/
d22 1
d34 10
a43 3
void	cvs_log_local(struct cvs_file *);

static void	log_rev_print(struct rcs_delta *);
d47 1
d83 3
d119 2
d143 3
d237 2
d302 2
a303 1
			if (logrev == NULL || (rdp->rd_flags & RCS_RD_SELECT))
d397 163
@


1.89
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.88 2008/06/09 23:33:15 joris Exp $	*/
d218 5
a266 5

	if (logrev != NULL)
		nrev = cvs_revision_select(cf->file_rcs, logrev);
	else
		nrev = cf->file_rcs->rf_ndelta;
@


1.88
log
@log already gets it FILE_UNKNOWN warning spewed out from cvs_file_classify,
so do not mention it again in cvs_log_local();
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.87 2008/03/02 19:05:34 tobias Exp $	*/
d198 1
a198 1
	if (cf->file_status == FILE_UNKNOWN) {
@


1.87
log
@Print the right synopsis for commands on error (especially if commands
share the same function: (r)tag, etc.).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.86 2008/02/09 14:25:02 joris Exp $	*/
a198 3
		if (verbosity > 0 && cvs_cmdop != CVS_OP_RLOG)
			cvs_log(LP_ERR, "nothing known about %s",
			    cf->file_path);
@


1.86
log
@make sure we do not call rcsnum_addmagic() directly on
a revision number in our symbol list if we want to correctly
reuse that symbol later on in rcs_translate_tag();
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.85 2008/02/09 14:03:20 joris Exp $	*/
d101 3
a103 1
			fatal("%s", cvs_cmd_log.cmd_synopsis);
@


1.85
log
@- always remove the additional .0 from magic branches, even when
  running the log command.

- change getlog.c so it will add any .0 for magic branches in its output
  if required


less confusing for rcs_translate_tag();
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.84 2008/02/04 21:25:32 tobias Exp $	*/
d185 1
d248 2
d251 1
a251 1
				rcsnum_addmagic(sym->rs_num);
d254 2
a255 1
			    rcsnum_tostr(sym->rs_num, numb, sizeof(numb)));
@


1.84
log
@r* commands have their own usage; don't check usage of their working dir
equivalents.

OK joris@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.83 2008/01/31 22:09:05 xsa Exp $	*/
d38 1
a38 1
char 	*logrev = NULL;
a68 1
	rcsnum_flags |= RCSNUM_NO_MAGIC;
d247 3
@


1.83
log
@Zap trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.82 2008/01/31 20:29:16 joris Exp $	*/
d72 2
a73 1
	while ((ch = getopt(argc, argv, cvs_cmd_log.cmd_opts)) != -1) {
@


1.82
log
@add changed lines support to log and rlog (the + and - stuff)
from Pierre Riteau;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.81 2008/01/31 10:15:05 tobias Exp $	*/
d369 1
a369 1
 
@


1.81
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.80 2008/01/12 22:39:32 tobias Exp $	*/
d291 2
d331 1
a331 1
	cvs_printf("\ndate: %s;  author: %s;  state: %s;\n",
d333 37
@


1.80
log
@Added missing break statements.

OK xsa@@

> Diff from Igor Zinovik <zinovik at cs dot karelia dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.79 2008/01/10 11:25:27 tobias Exp $	*/
d43 1
a43 1
	CVS_OP_LOG, 0, "log",
d109 2
@


1.79
log
@Synced rlog's usage checks and with rtag. Also unbreaks rtag and rlog with
GNU cvs on server-side.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.78 2007/09/24 22:06:28 joris Exp $	*/
d85 1
@


1.78
log
@oops i was suppose to pass cvs_directory_tag to cvs_file_classify().
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.77 2007/09/22 16:01:22 joris Exp $	*/
d65 1
a65 2
	int ch;
	int flags;
d107 10
d157 7
a163 4
	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);
d193 1
a193 1
		if (verbosity > 0)
@


1.77
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.76 2007/07/17 19:59:25 xsa Exp $	*/
d178 1
a178 1
	cvs_file_classify(cf, cvs_file_classify);
@


1.76
log
@Correct function name in error string.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.75 2007/07/17 19:56:08 xsa Exp $	*/
d178 1
a178 1
	cvs_file_classify(cf, NULL);
@


1.75
log
@Simplify the way we check wether the issued command is `log' or `rlog'.
Input and OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.74 2007/07/16 12:16:01 xsa Exp $	*/
d141 1
a141 1
			fatal("cvs_server_log: %s", strerror(errno));
@


1.74
log
@Do not display the `Working file:' line if the issued command is `rlog'.
Matches GNU's behaviour. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.73 2007/06/28 21:38:09 xsa Exp $	*/
d139 1
a139 1
		if (cvs_command[0] == 'r' &&
d156 4
a159 4
		if (cvs_command[0] == 'r')
			cvs_client_send_request("rlog");
		else
			cvs_client_send_request("log");
@


1.73
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.72 2007/06/26 02:24:10 niallo Exp $	*/
d204 4
a207 1
	cvs_printf("\nWorking file: %s", cf->file_path);
@


1.72
log
@add support for cvs rlog.
from Mickey.

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.71 2007/02/22 06:42:09 otto Exp $	*/
d174 1
a174 1
	char numb[32];
d271 1
a271 1
	char numb[32], timeb[32];
@


1.71
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.70 2007/02/09 03:49:15 joris Exp $	*/
d21 1
a25 6
#define LOG_REVSEP \
"----------------------------"

#define LOG_REVEND \
 "============================================================================="

d52 10
d139 4
d156 4
a159 1
		cvs_client_send_request("log");
@


1.70
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.69 2007/01/11 02:35:55 joris Exp $	*/
d19 2
a20 1
#include "includes.h"
a22 2
#include "diff.h"
#include "log.h"
@


1.69
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.68 2006/11/10 15:49:03 xsa Exp $	*/
d167 1
a167 1
	cvs_file_classify(cf, NULL, 0);
@


1.68
log
@fix -w
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.67 2006/11/08 22:05:52 xsa Exp $	*/
d108 1
@


1.67
log
@[-s states] and [-w logins] bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.66 2006/10/24 13:15:34 xsa Exp $	*/
d53 1
a53 1
	"bd:hlNRr:s:tw::",
d290 1
a290 2
	if ((((runflags & L_STATES) && (runflags & L_LOGINS)) ||
	    (runflags & (L_STATES | L_LOGINS))) && found == 0)
@


1.66
log
@bring back support for -h, -N, -R, and -t.
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.65 2006/07/07 17:37:17 joris Exp $	*/
d36 2
d41 2
d45 2
d53 1
a53 1
	"bd:hlNRr:s:tw:",
d85 4
d92 4
d125 3
d130 3
d162 1
a162 1
	char numb[32], timeb[32];
d243 6
a248 14
			if (logrev != NULL &&
			    !(rdp->rd_flags & RCS_RD_SELECT))
				continue;

			cvs_printf("%s\n", LOG_REVSEP);

			rcsnum_tostr(rdp->rd_num, numb, sizeof(numb));
			cvs_printf("revision %s", numb);

			strftime(timeb, sizeof(timeb), "%Y/%m/%d %H:%M:%S",
			    &rdp->rd_date);
			cvs_printf("\ndate: %s;  author: %s;  state: %s;\n",
			    timeb, rdp->rd_author, rdp->rd_state);
			cvs_printf("%s", rdp->rd_log);
d253 50
@


1.65
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.64 2006/06/19 05:05:17 joris Exp $	*/
d3 1
d32 5
d39 1
d65 3
d71 5
d79 3
d96 3
d102 6
d110 3
d166 5
d194 6
a199 4
	cvs_printf("symbolic names:\n");
	TAILQ_FOREACH(sym, &(cf->file_rcs->rf_symbols), rs_list) {
		cvs_printf("\t%s: %s\n", sym->rs_name,
		    rcsnum_tostr(sym->rs_num, numb, sizeof(numb)));
d212 4
a215 1
	cvs_printf(";\tselected revisions: %u", nrev);
a216 1
	cvs_printf("description:\n%s", cf->file_rcs->rf_desc);
d218 20
a237 15
	TAILQ_FOREACH(rdp, &(cf->file_rcs->rf_delta), rd_list) {
		if (logrev != NULL &&
		    !(rdp->rd_flags & RCS_RD_SELECT))
			continue;

		cvs_printf("%s\n", LOG_REVSEP);

		rcsnum_tostr(rdp->rd_num, numb, sizeof(numb));
		cvs_printf("revision %s", numb);

		strftime(timeb, sizeof(timeb), "%Y/%m/%d %H:%M:%S",
		    &rdp->rd_date);
		cvs_printf("\ndate: %s;  author: %s;  state: %s;\n", timeb,
		    rdp->rd_author, rdp->rd_state);
		cvs_printf("%s", rdp->rd_log);
@


1.64
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.63 2006/06/16 14:07:42 joris Exp $	*/
d23 1
a30 1
int	cvs_getlog(int, char **);
d74 13
a86 1
	cr.fileproc = cvs_log_local;
d94 7
d136 3
a138 3
	printf("\nRCS file: %s", cf->file_rpath);
	printf("\nWorking file: %s", cf->file_path);
	printf("\nhead:");
d140 1
a140 1
		printf(" %s", rcsnum_tostr(cf->file_rcs->rf_head,
d143 1
a143 1
	printf("\nbranch:");
d145 1
a145 1
		printf(" %s", rcsnum_tostr(rcs_branch_get(cf->file_rcs),
d149 1
a149 1
	printf("\nlocks: %s", (cf->file_rcs->rf_flags & RCS_SLOCK)
d152 1
a152 1
		printf("\n\t%s: %s", lkp->rl_name,
d155 1
a155 1
	printf("\naccess list:\n");
d157 1
a157 1
		printf("\t%s\n", acp->ra_name);
d159 1
a159 1
	printf("symbolic names:\n");
d161 1
a161 1
		printf("\t%s: %s\n", sym->rs_name,
d165 1
a165 1
	printf("keyword substitution: %s\n",
d168 1
a168 1
	printf("total revisions: %u", cf->file_rcs->rf_ndelta);
d175 3
a177 3
	printf(";\tselected revisions: %u", nrev);
	printf("\n");
	printf("description:\n%s", cf->file_rcs->rf_desc);
d184 1
a184 1
		printf("%s\n", LOG_REVSEP);
d187 1
a187 1
		printf("revision %s", numb);
d191 1
a191 1
		printf("\ndate: %s;  author: %s;  state: %s;\n", timeb,
d193 1
a193 1
		printf("%s", rdp->rd_log);
d196 1
a196 1
	printf("%s\n", LOG_REVEND);
@


1.63
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.62 2006/06/02 19:10:24 david Exp $	*/
d74 1
a74 2
	cr.remote = NULL;
	cr.local = cvs_log_local;
@


1.62
log
@various spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.61 2006/05/30 21:34:03 joris Exp $	*/
a22 1
#include "proto.h"
d36 1
a36 1
	CVS_OP_LOG, CVS_REQ_LOG, "log",
@


1.61
log
@change cvs_file_classify here to, forgot to commit this
when i changed its arguments in the last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.60 2006/05/29 18:00:02 joris Exp $	*/
d108 1
a108 1
			cvs_log(LP_ERR, "%s has been added, but not commited",
@


1.60
log
@add trace messages for debugging purpose
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.59 2006/05/29 06:29:49 joris Exp $	*/
d99 1
a99 1
	cvs_file_classify(cf, 0);
@


1.59
log
@i forgot to handle directories inside the 'log' code,
which resulted in a very painfull segfault later on.

found by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.58 2006/05/28 21:35:58 joris Exp $	*/
d96 2
@


1.58
log
@teach log how to handle the revisions passed on the command line.
the following now works:
'opencvs log -r1.5:1.15 foobar'
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.57 2006/05/28 21:11:12 joris Exp $	*/
d108 6
@


1.57
log
@add basic 'cvs log' support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 1
		nrev = 1;
a154 2
		rcsnum_tostr(rdp->rd_num, numb, sizeof(numb));

d156 1
a156 1
		    strcmp(logrev, numb))
d161 1
@


1.56
log
@- swap a hack for a slightly nicer hack using a global variable.  this avoids
adding a really nasty hack to make some upcoming rlog fixes from joris work.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.55 2006/02/06 16:21:43 xsa Exp $	*/
d3 1
a3 3
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d21 1
d25 2
d28 1
a28 2
#define CVS_GETLOG_REVSEP	"----------------------------"
#define CVS_GETLOG_REVEND \
d31 4
a34 10
#define GLOG_BRANCH		(1<<0)
#define GLOG_HEADER		(1<<1)
#define GLOG_HEADER_DESCR	(1<<2)
#define GLOG_NAME		(1<<3)
#define GLOG_NOTAGS		(1<<4)

static int	cvs_getlog_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_getlog_remote(CVSFILE *, void *);
static int	cvs_getlog_local(CVSFILE *, void *);
static int	cvs_getlog_pre_exec(struct cvsroot *);
d43 1
a43 26
	CF_NOSYMS | CF_IGNORE | CF_SORT | CF_RECURSE,
	cvs_getlog_init,
	cvs_getlog_pre_exec,
	cvs_getlog_remote,
	cvs_getlog_local,
	NULL,
	NULL,
	CVS_CMD_SENDDIR | CVS_CMD_ALLOWSPEC | CVS_CMD_SENDARGS2
};


struct cvs_cmd cvs_cmd_rlog = {
	CVS_OP_LOG, CVS_REQ_LOG, "log",
	{ "lo" },
	"Print out history information for files",
	"[-bhlNRt] [-d dates] [-r revisions] [-s states] [-w logins]",
	"d:hlRr:",
	NULL,
	CF_NOSYMS | CF_IGNORE | CF_SORT | CF_RECURSE,
	cvs_getlog_init,
	cvs_getlog_pre_exec,
	cvs_getlog_remote,
	cvs_getlog_local,
	NULL,
	NULL,
	CVS_CMD_SENDDIR | CVS_CMD_ALLOWSPEC | CVS_CMD_SENDARGS2
d46 2
a47 4
static int runflags = 0;

static int
cvs_getlog_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d50 3
d54 4
a57 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a58 8
		case 'b':
			runflags |= GLOG_BRANCH;
			break;
		case 'd':
			break;
		case 'h':
			runflags |= GLOG_HEADER;
			break;
d60 1
a60 7
			cmd->file_flags &= ~CF_RECURSE;
			break;
		case 'N':
			runflags |= GLOG_NOTAGS;
			break;
		case 'R':
			runflags |= GLOG_NAME;
d63 1
a63 7
			break;
		case 's':
			break;
		case 't':
			runflags |= GLOG_HEADER_DESCR;
			break;
		case 'w':
d66 1
a66 1
			return (CVS_EX_USAGE);
d70 2
a71 48
	*arg = optind;
	rcsnum_flags |= RCSNUM_NO_MAGIC;
	return (0);
}

static int
cvs_getlog_pre_exec(struct cvsroot *root)
{
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (runflags & GLOG_BRANCH)
			cvs_sendarg(root, "-b", 0);

		if (runflags & GLOG_HEADER)
			cvs_sendarg(root, "-h", 0);

		if (runflags & GLOG_NOTAGS)
			cvs_sendarg(root, "-N", 0);

		if (runflags & GLOG_NAME)
			cvs_sendarg(root, "-R", 0);

		if (runflags & GLOG_HEADER_DESCR)
			cvs_sendarg(root, "-t", 0);
	}
	return (0);
}

/*
 * cvs_getlog_remote()
 *
 */
static int
cvs_getlog_remote(CVSFILE *cf, void *arg)
{
	char fpath[MAXPATHLEN];
	struct cvsroot *root;

	root = CVS_DIR_ROOT(cf);

	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		else
			cvs_senddir(root, cf);
		return (0);
	}

	cvs_file_getpath(cf, fpath, sizeof(fpath));
d73 10
a82 16
	cvs_sendentry(root, cf);

	switch (cf->cf_cvstat) {
	case CVS_FST_UNKNOWN:
		cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		break;
	case CVS_FST_UPTODATE:
		cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
		break;
	case CVS_FST_ADDED:
	case CVS_FST_MODIFIED:
		cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);
		break;
	default:
		break;
	}
d87 2
a88 4


static int
cvs_getlog_local(CVSFILE *cf, void *arg)
d90 1
a90 3
	int nrev;
	char rcspath[MAXPATHLEN], numbuf[64];
	RCSFILE *rf;
d92 1
d95 1
d97 1
a97 1
	nrev = 0;
d99 6
a104 1
	if (cf->cf_cvstat == CVS_FST_ADDED) {
d106 3
a108 3
			cvs_log(LP_WARN, "%s has been added, but not committed",
			    cf->cf_name);
		return (0);
d111 11
a121 4
	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		if (verbosity > 0)
			cvs_log(LP_WARN, "nothing known about %s", cf->cf_name);
		return (0);
d124 5
a128 5
	if (cf->cf_type == DT_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Logging %s", cf->cf_name);
		return (0);
	}
d130 3
a132 1
	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));
d134 4
a137 3
	if (runflags & GLOG_NAME) {
		cvs_printf("%s\n", rcspath);
		return (0);
d140 4
a143 17
	if ((rf = rcs_open(rcspath, RCS_READ|RCS_PARSE_FULLY)) == NULL)
		fatal("cvs_getlog_local: rcs_open `%s': %s", rcspath,
		    rcs_errstr(rcs_errno));

	cvs_printf("\nRCS file: %s", rcspath);
	cvs_printf("\nWorking file: %s", cf->cf_name);
	cvs_printf("\nhead:");
	if (rcs_head_get(rf) != NULL) {
		cvs_printf(" %s",
		    rcsnum_tostr(rcs_head_get(rf), numbuf, sizeof(numbuf)));
	}
	cvs_printf("\nbranch:");
	if (rcs_branch_get(rf) != NULL) {
		cvs_printf(" %s",
		    rcsnum_tostr(rcs_branch_get(rf), numbuf, sizeof(numbuf)));
	}
	cvs_printf("\nlocks:%s", (rf->rf_flags & RCS_SLOCK) ? " strict" : "");
d145 4
a148 10
	cvs_printf("\naccess list:\n");
	TAILQ_FOREACH(acp, &(rf->rf_access), ra_list)
		cvs_printf("\t%s\n", acp->ra_name);

	if (!(runflags & GLOG_NOTAGS)) {
		cvs_printf("symbolic names:\n");
		TAILQ_FOREACH(sym, &(rf->rf_symbols), rs_list)
			cvs_printf("\t%s: %s\n", sym->rs_name,
			    rcsnum_tostr(sym->rs_num, numbuf, sizeof(numbuf)));
	}
d150 3
a152 2
	cvs_printf("keyword substitution: %s\n",
	    rf->rf_expand == NULL ? "kv" : rf->rf_expand);
d154 2
a155 1
	cvs_printf("total revisions: %u", rf->rf_ndelta);
d157 3
a159 2
	if (!(runflags & GLOG_HEADER) && !(runflags & GLOG_HEADER_DESCR))
		cvs_printf(";\tselected revisions: %u", nrev);
d161 1
a161 19
	cvs_printf("\n");

	if (!(runflags & GLOG_HEADER) || (runflags & GLOG_HEADER_DESCR))
		cvs_printf("description:\n%s", rf->rf_desc);

	if (!(runflags & GLOG_HEADER) && !(runflags & GLOG_HEADER_DESCR)) {
		TAILQ_FOREACH(rdp, &(rf->rf_delta), rd_list) {
			rcsnum_tostr(rdp->rd_num, numbuf, sizeof(numbuf));
			cvs_printf(CVS_GETLOG_REVSEP "\nrevision %s\n", numbuf);
			cvs_printf("date: %d/%02d/%02d %02d:%02d:%02d;"
			    "  author: %s;  state: %s;\n",
			    rdp->rd_date.tm_year + 1900,
			    rdp->rd_date.tm_mon + 1,
			    rdp->rd_date.tm_mday, rdp->rd_date.tm_hour,
			    rdp->rd_date.tm_min, rdp->rd_date.tm_sec,
			    rdp->rd_author, rdp->rd_state);
			cvs_printf("%s", rdp->rd_log);
		}
	}
d163 1
a163 1
	cvs_printf(CVS_GETLOG_REVEND "\n");
d165 6
a170 1
	rcs_close(rf);
d172 1
a172 1
	return (0);
@


1.55
log
@- use bitwise flags
- add missing option in remote handler
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.54 2006/01/30 17:58:47 xsa Exp $	*/
d126 1
@


1.54
log
@strerror() -> rcs_errstr() when passing rcs_errno as argument;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.53 2006/01/29 11:09:45 xsa Exp $	*/
d4 1
a34 4
#define CVS_GLOG_RFONLY		0x01
#define CVS_GLOG_HDONLY		0x02


d39 6
d85 1
a85 4
static int log_rfonly = 0;
static int log_honly = 0;
static int log_lhonly = 0;
static int log_notags = 0;
d95 1
d100 1
a100 1
			log_honly = 1;
d106 1
a106 1
			log_notags = 1;
d109 1
a109 1
			log_rfonly = 1;
d116 1
a116 1
			log_lhonly = 1;
d133 4
a136 1
		if (log_honly == 1)
d138 2
a139 1
		if (log_notags == 1)
d141 2
a142 1
		if (log_rfonly == 1)
d144 2
a145 1
		if (log_lhonly == 1)
d228 1
a228 1
	if (log_rfonly == 1) {
d255 1
a255 1
	if (log_notags == 0) {
d267 1
a267 1
	if ((log_honly == 0) && (log_lhonly == 0))
d272 1
a272 1
	if ((log_honly == 0) || (log_lhonly == 1))
d275 1
a275 1
	if ((log_honly == 0) && (log_lhonly == 0)) {
@


1.53
log
@RCS_PARSE_FULLY needed here too, as in rlog(1);
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.52 2006/01/27 15:26:38 xsa Exp $	*/
d228 1
a228 1
		    strerror(rcs_errno));
@


1.52
log
@more errors handling cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.51 2006/01/02 08:11:56 xsa Exp $	*/
d226 1
a226 1
	if ((rf = rcs_open(rcspath, RCS_READ)) == NULL)
@


1.51
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.50 2005/12/30 16:42:13 xsa Exp $	*/
d226 3
a228 3
	rf = rcs_open(rcspath, RCS_READ);
	if (rf == NULL)
		return (CVS_EX_DATA);
@


1.50
log
@minor style nits;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.49 2005/12/30 02:03:28 joris Exp $	*/
d27 1
a27 6
#include <errno.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.49
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.48 2005/12/22 14:59:54 xsa Exp $	*/
d137 1
a137 1
		if (log_honly)
d139 1
a139 1
		if (log_notags)
d141 1
a141 1
		if (log_rfonly)
d143 1
a143 1
		if (log_lhonly)
a145 1

d226 1
a226 1
	if (log_rfonly) {
@


1.48
log
@cvs_rcs_getpath() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.47 2005/11/03 15:57:40 xsa Exp $	*/
d137 8
a144 8
		if (log_honly && (cvs_sendarg(root, "-h", 0) < 0))
			return (CVS_EX_PROTO);
		if (log_notags && (cvs_sendarg(root, "-N", 0) < 0))
			return (CVS_EX_PROTO);
		if (log_rfonly && (cvs_sendarg(root, "-R", 0) < 0))
			return (CVS_EX_PROTO);
		if (log_lhonly && (cvs_sendarg(root, "-t", 0) < 0))
			return (CVS_EX_PROTO);
a156 1
	int ret;
a159 1
	ret = 0;
d164 1
a164 2
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    cf->cf_name);
d166 2
a167 2
			ret = cvs_senddir(root, cf);
		return (ret);
d172 1
a172 2
	if (cvs_sendentry(root, cf) < 0)
		return (CVS_EX_PROTO);
d176 1
a176 1
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
d179 1
a179 1
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
d183 1
a183 1
		ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);
d189 1
a189 3
	if (ret == -1)
		ret = CVS_EX_PROTO;
	return (ret);
@


1.47
log
@output tweaks;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.46 2005/08/08 14:48:27 xsa Exp $	*/
d231 1
a231 2
	if (cvs_rcs_getpath(cf, rcspath, sizeof(rcspath)) == NULL)
		return (CVS_EX_DATA);
@


1.46
log
@zap unused var;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.45 2005/08/05 10:17:14 xsa Exp $	*/
d271 1
a271 1
	cvs_printf("total revisions: %u;", rf->rf_ndelta);
d274 1
a274 1
		cvs_printf("\tselected revisions: %u", nrev);
@


1.45
log
@minor KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.44 2005/07/27 16:42:19 xsa Exp $	*/
d158 1
a158 1
	char *repo, fpath[MAXPATHLEN];
a162 1
	repo = CVS_DIR_REPO(cf);
@


1.44
log
@use LP_NOTICE instead of LP_INFO where appropriate;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.43 2005/07/25 12:05:43 xsa Exp $	*/
d262 1
a262 1
	if (!log_notags) {
d274 1
a274 1
	if (!log_honly && !log_lhonly)
d279 1
a279 1
	if (!log_honly || log_lhonly)
d282 1
a282 1
	if (!log_honly && !log_lhonly) {
@


1.43
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.42 2005/07/22 16:27:29 joris Exp $	*/
d228 1
a228 1
			cvs_log(LP_INFO, "Logging %s", cf->cf_name);
@


1.42
log
@use the cf_name field of the CVSFILE struct instead of using the old
CVS_FILE_NAME macro. This macro used to be nifty because of all
the referencing for the names, but since we don't do that anymore and
use cf_name directly... byebye CVS_FILE_NAME()

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.41 2005/07/21 11:42:24 xsa Exp $	*/
d39 2
a40 2
#define CVS_GLOG_RFONLY    0x01
#define CVS_GLOG_HDONLY    0x02
d43 1
a43 1
#define CVS_GETLOG_REVSEP   "----------------------------"
d47 4
a50 4
static int cvs_getlog_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_getlog_remote   (CVSFILE *, void *);
static int cvs_getlog_local    (CVSFILE *, void *);
static int cvs_getlog_pre_exec (struct cvsroot *);
@


1.41
log
@<sys/param.h> is already included in "cvs.h", no need to duplicate;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.40 2005/07/19 02:18:05 joris Exp $	*/
d168 1
a168 1
			    CVS_FILE_NAME(cf));
@


1.40
log
@missing CF_IGNORE, CF_NOSYMS and CF_SORT flags.
gets the local mode of 'log' a bit closer to reality.

problems noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.39 2005/07/15 08:39:14 xsa Exp $	*/
a25 2

#include <sys/param.h>
@


1.39
log
@if a file has been locally added and not committed, handle it with proper
warning message;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.38 2005/07/14 06:50:50 xsa Exp $	*/
d61 1
a61 1
	CF_RECURSE,
d79 1
a79 1
	CF_RECURSE,
@


1.38
log
@use cvs_rcs_getpath();
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.37 2005/07/11 08:44:16 xsa Exp $	*/
d213 9
a232 2

	nrev = 0;
@


1.37
log
@display warning message about an unknown file only if -Q is not specified;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.36 2005/07/11 08:36:58 xsa Exp $	*/
d206 1
a206 1
	int nrev, l;
a207 1
	char *repo;
a211 1
	struct cvsroot *root;
a225 2
	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);
d227 1
a227 5
	l = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, CVS_FILE_NAME(cf), RCS_FILE_EXT);
	if (l == -1 || l >= (int)sizeof(rcspath)) {
		errno = ENAMETOOLONG;
		 cvs_log(LP_ERRNO, "%s", rcspath);
a228 1
	}
@


1.36
log
@display info message only if -q is not specified;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.35 2005/07/07 14:27:57 joris Exp $	*/
d216 2
a217 1
		cvs_log(LP_WARN, "nothing known about %s", cf->cf_name);
@


1.35
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.34 2005/07/01 15:00:22 xsa Exp $	*/
d221 2
a222 1
		cvs_log(LP_INFO, "Logging %s", cf->cf_name);
@


1.34
log
@|| should && instead ...
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.33 2005/07/01 14:55:30 xsa Exp $	*/
d278 1
a278 1
	
d289 1
a289 1
		    	    "  author: %s;  state: %s;\n",
@


1.33
log
@more output tweaks in server mode ..
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.32 2005/07/01 14:29:13 xsa Exp $	*/
d276 1
a276 1
	if (!log_honly || !log_lhonly)
@


1.32
log
@fix output when using in server mode; more to come ... ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.31 2005/05/31 08:58:48 xsa Exp $	*/
d49 4
a52 4
static int  cvs_getlog_remote  (CVSFILE *, void *);
static int  cvs_getlog_local   (CVSFILE *, void *);
static int cvs_getlog_options(struct cvs_cmd *, int, char **, int *);
static int cvs_getlog_sendflags(struct cvsroot *);
d62 2
a63 2
	cvs_getlog_options,
	NULL,
d80 2
a81 2
	cvs_getlog_options,
	cvs_getlog_sendflags,
d95 1
a95 1
cvs_getlog_options(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d136 1
a136 1
cvs_getlog_sendflags(struct cvsroot *root)
d138 10
a147 8
	if (log_honly && (cvs_sendarg(root, "-h", 0) < 0))
		return (CVS_EX_PROTO);
	if (log_notags && (cvs_sendarg(root, "-N", 0) < 0))
		return (CVS_EX_PROTO);
	if (log_rfonly && (cvs_sendarg(root, "-R", 0) < 0))
		return (CVS_EX_PROTO);
	if (log_lhonly && (cvs_sendarg(root, "-t", 0) < 0))
		return (CVS_EX_PROTO);
d274 6
a279 5
	if (log_honly)
		cvs_printf("total revisions: %u;\n", rf->rf_ndelta);
	else {
		cvs_printf("total revisions: %u;\tselected revisions: %u\n",
		    rf->rf_ndelta, nrev);
d281 2
a282 2
		if (!log_lhonly)
			cvs_printf("description:\n%s", rf->rf_desc);
d284 1
@


1.31
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.30 2005/05/29 14:30:38 xsa Exp $	*/
d244 13
a256 6
	cvs_printf("\nRCS file: %s\nWorking file: %s\n", rcspath, cf->cf_name);
	cvs_printf("head: %s\n",
	    rcsnum_tostr(rcs_head_get(rf), numbuf, sizeof(numbuf)));
	cvs_printf("branch: %s\n",
	    rcsnum_tostr(rcs_branch_get(rf), numbuf, sizeof(numbuf)));
	cvs_printf("locks: %s\n", (rf->rf_flags & RCS_SLOCK) ? "strict" : "");
d258 1
a258 1
	cvs_printf("access list:\n");
d269 2
a270 1
	cvs_printf("keyword substitution: %s\n", "");
d278 1
a278 1
		if (log_lhonly)
@


1.30
log
@add missing options in usage..
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.29 2005/05/24 04:12:25 jfb Exp $	*/
d29 3
d33 1
a33 1
#include <stdio.h>
a34 3
#include <errno.h>
#include <string.h>
#include <paths.h>
a37 1
#include "file.h"
@


1.29
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.28 2005/05/20 20:00:53 joris Exp $	*/
d60 1
a60 1
	"d:hlRr:",
@


1.28
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.27 2005/05/20 16:57:31 jfb Exp $	*/
d50 3
a52 3
static int cvs_getlog_remote  (CVSFILE *, void *);
static int cvs_getlog_local   (CVSFILE *, void *);
static int cvs_getlog_options(char *, int, char **, int *);
d55 26
a80 1
struct cvs_cmd_info cvs_getlog = {
d84 3
a86 3
	NULL, NULL,
	CF_IGNORE | CF_RECURSE,
	CVS_REQ_LOG,
d96 1
a96 1
cvs_getlog_options(char *opt, int argc, char **argv, int *arg)
d100 1
a100 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d110 1
a110 1
			cvs_getlog.file_flags &= ~CF_RECURSE;
@


1.27
log
@return CVS_EX_PROTO on protocol errors

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.26 2005/05/19 16:11:10 xsa Exp $	*/
d208 1
a208 1
		return (-1);
d218 1
a218 1
		return (-1);
@


1.26
log
@handle -t option locally too; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.25 2005/05/19 15:37:50 xsa Exp $	*/
d152 2
a153 3
	if (cvs_sendentry(root, cf) < 0) {
		return (-1);
	}
d170 2
@


1.25
log
@- add missing flags for the log command
- enable the -h -N -R -t options
ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.24 2005/05/11 22:50:09 joris Exp $	*/
d244 4
a247 1
		cvs_printf("description:\n%s", rf->rf_desc);
@


1.24
log
@

missing CF_IGNORE flag
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.23 2005/04/18 21:02:50 jfb Exp $	*/
d50 4
a53 4
static int  cvs_getlog_remote  (CVSFILE *, void *);
static int  cvs_getlog_local   (CVSFILE *, void *);

int cvs_getlog_options(char *, int, char **, int *);
d57 1
a57 1
	NULL,
d67 1
d70 1
a70 1
int
d77 2
d95 7
d111 14
@


1.23
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.22 2005/04/16 20:05:05 xsa Exp $	*/
d60 1
a60 1
	CF_RECURSE,
@


1.22
log
@more snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.21 2005/04/13 19:44:42 jfb Exp $	*/
a111 1
	struct cvs_ent *entp;
a126 1
	entp = cvs_ent_getent(fpath);
d128 1
a128 2
	if ((entp != NULL) && (cvs_sendentry(root, entp) < 0)) {
		cvs_ent_free(entp);
a146 2
	if (entp != NULL)
		cvs_ent_free(entp);
@


1.21
log
@* accept the -N option to suppress logging of tags
* print locks, access entries and description in local mode
* cleanup and get rid of unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.20 2005/04/13 16:37:50 jfb Exp $	*/
d160 1
a160 1
	int nrev;
d183 1
a183 1
	snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
d185 5
@


1.20
log
@cleanup and split the log code into two separate functions for local
and remote, and a first stab at the code for local log
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.19 2005/04/12 14:58:40 joris Exp $	*/
d50 1
a50 1
static int  cvs_getlog_file    (CVSFILE *, void *);
d58 1
a58 1
	cvs_getlog_file,
d65 3
a67 2
static int rfonly = 0;
static int honly = 0;
d79 1
a79 1
			honly = 1;
d84 3
d88 1
a88 1
			rfonly = 1;
d103 1
a103 1
 * cvs_getlog_file()
a104 1
 * Diff a single file.
d107 1
a107 1
cvs_getlog_file(CVSFILE *cf, void *arg)
a110 1
	RCSFILE *rf;
a114 1
	rf = NULL;
d137 1
a137 2
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
		    CVS_FILE_NAME(cf));
d140 1
a140 2
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED,
		    CVS_FILE_NAME(cf));
d144 1
a144 2
		ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED,
		    CVS_FILE_NAME(cf));
d161 1
a161 1
	char fpath[MAXPATHLEN], rcspath[MAXPATHLEN], numbuf[64];
d166 1
a168 1
	cvs_file_getpath(cf, fpath, sizeof(fpath));
d170 1
a170 1
		cvs_printf("? %s\n", fpath);
d174 2
a175 1
	if (cf->cf_type == DT_DIR)
d177 1
d186 5
d200 1
a200 1
	cvs_printf("locks:\naccess list:\n");
d202 9
a210 4
	cvs_printf("symbolic names:\n");
	TAILQ_FOREACH(sym, &(rf->rf_symbols), rs_list) {
		cvs_printf("\t%s: %s\n", sym->rs_name,
		    rcsnum_tostr(sym->rs_num, numbuf, sizeof(numbuf)));
d212 1
a213 2
	cvs_printf("total revisions: %u;\tselected revisions: %u\n",
	    rf->rf_ndelta, nrev);
d215 18
a232 12
	cvs_printf("description:\n");

	TAILQ_FOREACH(rdp, &(rf->rf_delta), rd_list) {
		rcsnum_tostr(rdp->rd_num, numbuf, sizeof(numbuf));
		cvs_printf(CVS_GETLOG_REVSEP "\nrevision %s\n", numbuf);
		cvs_printf("date: %d/%02d/%02d %02d:%02d:%02d;  author: %s;"
		    "  state: %s;\n",
		    rdp->rd_date.tm_year + 1900, rdp->rd_date.tm_mon + 1,
		    rdp->rd_date.tm_mday, rdp->rd_date.tm_hour,
		    rdp->rd_date.tm_min, rdp->rd_date.tm_sec,
		    rdp->rd_author, rdp->rd_state);
		cvs_printf("%s", rdp->rd_log);
@


1.19
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.18 2005/04/11 18:02:58 joris Exp $	*/
a49 3
#ifdef notyet
static void cvs_getlog_print   (const char *, RCSFILE *, u_int);
#endif
d51 1
d118 5
a122 8
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cf->cf_cvstat == CVS_FST_UNKNOWN)
				ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
				    CVS_FILE_NAME(cf));
			else
				ret = cvs_senddir(root, cf);
		}

d129 4
a132 31
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if ((entp != NULL) && (cvs_sendentry(root, entp) < 0)) {
			cvs_ent_free(entp);
			return (CVS_EX_PROTO);
		}

		switch (cf->cf_cvstat) {
		case CVS_FST_UNKNOWN:
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cf));
			break;
		case CVS_FST_UPTODATE:
			ret = cvs_sendreq(root, CVS_REQ_UNCHANGED,
			    CVS_FILE_NAME(cf));
			break;
		case CVS_FST_ADDED:
		case CVS_FST_MODIFIED:
			ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED,
			    CVS_FILE_NAME(cf));
			break;
		default:
			break;
		}
	} else {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
			cvs_printf("? %s\n", fpath);
			return (0);
		}

		snprintf(fpath, sizeof(fpath), "%s/%s/%s%s",
		    root->cr_dir, repo, CVS_FILE_NAME(cf), RCS_FILE_EXT);
d134 16
a149 8
		rf = rcs_open(fpath, RCS_READ);
		if (rf == NULL) {
			if (entp != NULL)
				cvs_ent_free(entp);
			return (CVS_EX_DATA);
		}

		rcs_close(rf);
d157 4
a160 3
#ifdef notyet
static void
cvs_getlog_print(const char *file, RCSFILE *rfp, u_int flags)
d162 5
a166 1
	char numbuf[64], datebuf[64], *sp;
d168 7
d176 29
a204 6
	cvs_printf("RCS file: %s\nWorking file: %s\n",
	    rfp->rf_path, file);
	cvs_printf("Working file: %s\n", (char *)NULL);
	cvs_printf("head: %s\nbranch:\nlocks:\naccess list:\n");
	cvs_printf("symbolic names:\nkeyword substitutions:\n");
	cvs_printf("total revisions: %u;\tselected revisions: %u\n", 1, 1);
d208 1
a208 2
	for (;;) {
		cvs_printf(CVS_GETLOG_REVSEP "\n");
d210 4
a213 4
		cvs_printf("revision %s\n", numbuf);
		cvs_printf("date: %d/%02d/%d %02d:%02d:%02d;  author: %s;"
		    "  state: %s;  lines:",
		    rdp->rd_date.tm_year, rdp->rd_date.tm_mon + 1,
d217 1
d221 4
a225 1
#endif
@


1.18
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.17 2005/04/11 17:56:27 joris Exp $	*/
d91 1
a91 1
			return (1);
d137 1
a137 1
			return (-1);
d170 1
a170 1
			return (-1);
@


1.17
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.16 2005/03/30 17:43:04 joris Exp $	*/
a34 1
#include <sysexits.h>
@


1.16
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.15 2005/03/26 08:09:54 tedu Exp $	*/
d92 1
a92 1
			return (EX_USAGE);
@


1.15
log
@fix a variety of things i found at coverity.  ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.14 2005/02/27 00:22:08 jfb Exp $	*/
d56 1
d58 12
a70 5
/*
 * cvs_getlog()
 *
 * Implement the `cvs log' command.
 */
d72 1
a72 1
cvs_getlog(int argc, char **argv)
d74 1
a74 2
	int i, rfonly, honly, flags;
	struct cvsroot *root;
d76 2
a77 6
	flags = CF_RECURSE;
	rfonly = 0;
	honly = 0;

	while ((i = getopt(argc, argv, "d:hlRr:")) != -1) {
		switch (i) {
d84 1
a84 1
			flags &= ~CF_RECURSE;
d96 1
a96 33
	argc -= optind;
	argv += optind;

	if (argc == 0)
		cvs_files = cvs_file_get(".", flags);
	else
		cvs_files = cvs_file_getspec(argv, argc, flags);
	if (cvs_files == NULL)
		return (EX_DATAERR);

	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}

	if ((root->cr_method != CVS_METHOD_LOCAL) && (cvs_connect(root) < 0))
		return (EX_PROTOCOL);

	cvs_file_examine(cvs_files, cvs_getlog_file, NULL);

	if (root->cr_method != CVS_METHOD_LOCAL) {
		cvs_senddir(root, cvs_files);
		if (argc > 0) {
			for (i = 0; i < argc; i++)
				cvs_sendarg(root, argv[i], 0);
		}
		cvs_sendreq(root, CVS_REQ_LOG, NULL);
	}

@


1.14
log
@Many improvements to the RCS support:

- make it possible to specify creation and the file mode
  in rcs_open()
- implicitly write the contents to disk on rcs_close() if the
  RCS handle has been changed
- fix a bug in the output of the `expand' keyword
- add functions to retrieve and modify the expansion mode
- rcs_parse() shouldn't be available to the outside
- empty string instead of `(null)' if there is no description

ok Joris
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.13 2004/12/21 18:32:10 jfb Exp $	*/
d198 2
a199 1
			cvs_ent_free(entp);
@


1.13
log
@modify the directory handling portion to behave like the one in add.c,
which does not attempt to send data when running on a local
repository.  This will be needed to support local repository access
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.12 2004/12/14 22:30:48 jfb Exp $	*/
d196 1
a196 1
		rf = rcs_open(fpath, RCS_MODE_READ);
@


1.12
log
@First attempt at syncing the command code and doing a lot more error
checking on all the protocol calls
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.11 2004/12/14 20:19:37 xsa Exp $	*/
d149 9
a157 6
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cf->cf_type == DT_DIR)) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cf));
		else
			ret = cvs_senddir(root, cf);
@


1.11
log
@fix path to RCS file; jfb@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.10 2004/12/07 17:10:56 tedu Exp $	*/
d96 1
a96 1
	if (argc == 0) {
d98 1
a98 1
	} else {
a99 1
	}
d103 12
a116 1
	root = cvs_files->cf_ddat->cd_root;
d138 1
d144 4
a147 1
	cvs_file_getpath(cf, fpath, sizeof(fpath));
d149 3
a151 4
	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
			root = cf->cf_parent->cf_ddat->cd_root;
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
a152 24
		} else {
			root = cf->cf_ddat->cd_root;
			if ((cf->cf_parent == NULL) ||
			    (root != cf->cf_parent->cf_ddat->cd_root)) {
				cvs_connect(root);
			}

			cvs_senddir(root, cf);
		}

		return (0);
	} else
		root = cf->cf_parent->cf_ddat->cd_root;

	rf = NULL;
	if (cf->cf_parent != NULL) {
		repo = cf->cf_parent->cf_ddat->cd_repo;
	} else {
		repo = NULL;
	}

	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		if (root->cr_method == CVS_METHOD_LOCAL)
			cvs_printf("? %s\n", fpath);
d154 2
a155 3
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cf));
		return (0);
d158 1
a159 2
	if (entp == NULL)
		return (-1);
d161 5
a165 5
	if ((root->cr_method != CVS_METHOD_LOCAL) &&
	    (cvs_sendentry(root, entp) < 0)) {
		cvs_ent_free(entp);
		return (-1);
	}
a166 1
	if (root->cr_method != CVS_METHOD_LOCAL) {
d168 4
d173 2
a174 1
			cvs_sendreq(root, CVS_REQ_UNCHANGED, CVS_FILE_NAME(cf));
d178 1
a178 1
			cvs_sendreq(root, CVS_REQ_ISMODIFIED,
d182 14
d199 1
a199 2
		cvs_ent_free(entp);
		return (0);
d202 1
a202 5
	snprintf(fpath, sizeof(fpath), "%s/%s/%s%s",
	    root->cr_dir, repo, CVS_FILE_NAME(cf), RCS_FILE_EXT);

	rf = rcs_open(fpath, RCS_MODE_READ);
	if (rf == NULL) {
d204 1
a204 6
		return (-1);
	}

	rcs_close(rf);
	cvs_ent_free(entp);
	return (0);
@


1.10
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.9 2004/12/06 21:03:12 deraadt Exp $	*/
d199 1
a199 1
	    root->cr_dir, repo, fpath, RCS_FILE_EXT);
@


1.9
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.8 2004/12/06 03:13:52 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
d51 1
a51 1
#ifdef notyet 
a62 1

a124 1

@


1.8
log
@Get rid of a gcc warning
@
text
@d1 1
a1 1
/*	$OpenBSD: getlog.c,v 1.7 2004/11/26 16:23:50 jfb Exp $	*/
d99 1
a99 2
	}
	else {
d142 1
a142 2
		}
		else {
d153 1
a153 2
	}
	else
d159 1
a159 2
	}
	else {
@


1.7
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
d53 1
@


1.6
log
@Make the 'cvs log' command work in client mode, mostly based on the
code from update
@
text
@d129 1
a129 1
	char *dir, *repo, rcspath[MAXPATHLEN];
d134 2
d139 2
a140 1
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
a158 1
		dir = cf->cf_parent->cf_path;
a161 1
		dir = ".";
d167 1
a167 1
			cvs_printf("? %s\n", cf->cf_path);
d169 2
a170 1
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
d174 1
a174 1
	entp = cvs_ent_getent(cf->cf_path);
d187 1
a187 1
			cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
d191 2
a192 1
			cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);
d202 2
a203 2
	snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, cf->cf_path, RCS_FILE_EXT);
d205 1
a205 1
	rf = rcs_open(rcspath, RCS_MODE_READ);
@


1.5
log
@Cleanup the code, will need rework
@
text
@d39 1
a39 2
#include "rcs.h"
#include "sock.h"
a50 1
#ifdef notyet
d52 1
a52 2
#endif

d66 1
d104 12
d120 78
d199 2
d202 10
d220 1
a220 1
	printf("RCS file: %s\nWorking file: %s\n",
d222 4
a225 4
	printf("Working file: %s\n", (char *)NULL);
	printf("head: %s\nbranch:\nlocks:\naccess list:\n");
	printf("symbolic names:\nkeyword substitutions:\n");
	printf("total revisions: %u;\tselected revisions: %u\n", 1, 1);
d227 1
a227 1
	printf("description:\n");
d230 1
a230 1
		printf(CVS_GETLOG_REVSEP "\n");
d232 2
a233 2
		printf("revision %s\n", numbuf);
		printf("date: %d/%02d/%d %02d:%02d:%02d;  author: %s;"
d241 1
a241 2
	printf(CVS_GETLOG_REVEND "\n");

@


1.4
log
@Remove old code
@
text
@d52 1
d54 1
d68 1
a68 4
	int i, rfonly, honly, recurse;
	u_int flags;
	char rcspath[MAXPATHLEN];
	RCSFILE *rfp;
d70 1
a72 1
	recurse = 1;
d82 1
a82 1
			recurse = 0;
d98 1
d101 1
a101 2
		for (i = 0; i < argc; i++) {
		}
d103 2
d110 4
d122 1
a122 1
	printf("Working file: %s\n", NULL);
d131 1
a131 1
		rcsnum_tostr(&(rdp->rd_num), numbuf, sizeof(numbuf));
d144 1
@


1.3
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@d98 4
a101 10
	for (i = 0; i < argc; i++) {
		rfp = NULL;
#if 0
		if (cvs_root->cr_method == CVS_METHOD_LOCCAL) {
			snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
			    cvs_root->cr_dir, argv[i], RCS_FILE_EXT);

			rfp = rcs_open(rcspath, RCS_MODE_READ);
			if (rfp == NULL)
				continue;
a102 3
#endif

		cvs_getlog_print(argv[i], rfp, 0);
@


1.2
log
@No need to import the `cvs_root' symbol anymore, it is done in cvs.h
@
text
@d41 1
@


1.1
log
@Initial revision
@
text
@a54 2
extern struct cvsroot *cvs_root;

@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
