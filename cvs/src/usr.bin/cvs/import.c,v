head	1.106;
access;
symbols
	OPENBSD_6_1:1.106.0.2
	OPENBSD_6_1_BASE:1.106
	OPENBSD_6_0:1.105.0.4
	OPENBSD_6_0_BASE:1.105
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.104.0.6
	OPENBSD_5_8_BASE:1.104
	OPENBSD_5_7:1.104.0.2
	OPENBSD_5_7_BASE:1.104
	OPENBSD_5_6:1.103.0.18
	OPENBSD_5_6_BASE:1.103
	OPENBSD_5_5:1.103.0.16
	OPENBSD_5_5_BASE:1.103
	OPENBSD_5_4:1.103.0.12
	OPENBSD_5_4_BASE:1.103
	OPENBSD_5_3:1.103.0.10
	OPENBSD_5_3_BASE:1.103
	OPENBSD_5_2:1.103.0.8
	OPENBSD_5_2_BASE:1.103
	OPENBSD_5_1_BASE:1.103
	OPENBSD_5_1:1.103.0.6
	OPENBSD_5_0:1.103.0.4
	OPENBSD_5_0_BASE:1.103
	OPENBSD_4_9:1.103.0.2
	OPENBSD_4_9_BASE:1.103
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.101.0.2
	OPENBSD_4_7_BASE:1.101
	OPENBSD_4_6:1.101.0.4
	OPENBSD_4_6_BASE:1.101
	OPENBSD_4_5:1.98.0.2
	OPENBSD_4_5_BASE:1.98
	OPENBSD_4_4:1.97.0.2
	OPENBSD_4_4_BASE:1.97
	OPENBSD_4_3:1.87.0.2
	OPENBSD_4_3_BASE:1.87
	OPENBSD_4_2:1.74.0.2
	OPENBSD_4_2_BASE:1.74
	OPENBSD_4_1:1.72.0.2
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.106
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.105;
commitid	8Vv7d4HkmCtExfc6;

1.105
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.104;
commitid	O6jeJ0TRmiewrqMI;

1.104
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.103;
commitid	Uu5nFG3wCl0LACBb;

1.103
date	2010.09.23.18.10.16;	author nicm;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.101;

1.101
date	2009.06.27.16.55.31;	author martynas;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.07.08.39.13;	author ray;	state Exp;
branches;
next	1.99;

1.99
date	2009.06.06.14.17.27;	author ray;	state Exp;
branches;
next	1.98;

1.98
date	2009.01.02.00.11.01;	author canacar;	state Exp;
branches;
next	1.97;

1.97
date	2008.06.15.04.21.26;	author joris;	state Exp;
branches;
next	1.96;

1.96
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.95;

1.95
date	2008.06.10.20.30.17;	author joris;	state Exp;
branches;
next	1.94;

1.94
date	2008.06.10.02.11.19;	author tobias;	state Exp;
branches;
next	1.93;

1.93
date	2008.06.10.01.00.34;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2008.06.08.20.08.43;	author tobias;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.08.13.35.47;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.08.13.22.46;	author joris;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.22.15.45.01;	author tobias;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.22.06.48.27;	author xsa;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.01.20.49.44;	author joris;	state Exp;
branches;
next	1.86;

1.86
date	2008.03.01.20.45.41;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.20.17.29.28;	author tobias;	state Exp;
branches;
next	1.83;

1.83
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.04.15.07.33;	author tobias;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.31.21.30.08;	author joris;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.10.09.54.04;	author tobias;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.10.09.37.26;	author tobias;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.02.11.31.35;	author tobias;	state Exp;
branches;
next	1.75;

1.75
date	2007.08.30.11.07.18;	author joris;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.71;

1.71
date	2007.02.21.04.18.45;	author ray;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.69;

1.69
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2007.02.01.11.06.25;	author xsa;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.20.01.07.51;	author niallo;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.19.08.21.45;	author xsa;	state Exp;
branches;
next	1.64;

1.64
date	2007.01.18.16.45.52;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2007.01.14.23.10.56;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2007.01.13.20.29.46;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.60;

1.60
date	2007.01.12.17.25.33;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2007.01.11.15.41.42;	author xsa;	state Exp;
branches;
next	1.58;

1.58
date	2007.01.11.12.37.29;	author xsa;	state Exp;
branches;
next	1.57;

1.57
date	2007.01.07.02.47.57;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.04.09.51.21;	author xsa;	state Exp;
branches;
next	1.55;

1.55
date	2006.12.04.09.46.27;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.16.14.02.37;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2006.06.14.14.10.50;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.11.17.50.11;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2006.06.04.09.52.56;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.01.20.01.31;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.30.21.41.00;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.30.07.00.30;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.27.03.30.30;	author joris;	state dead;
branches;
next	1.43;

1.43
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.05.01.38.55;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.01.00.56.54;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.27.15.26.11;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.08.18.42.41;	author joris;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.30.17.58.47;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.27.10.39.49;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.25.08.15.05;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.21.20.06.25;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.20.18.17.01;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.03.01.02.09;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.28.08.49.25;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.24.11.17.15;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.15.22.56.02;	author niallo;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.04.12.20.42;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.15.12.24.50;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.26.03.14.21;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.26.03.10.01;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.26.02.35.13;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.26.00.51.36;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.25.21.47.19;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.25.09.25.48;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.24.04.21.54;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.25.16.29.41;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.16.20.05.05;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.05.18.43.55;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.28.20.18.02;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.13.18.47.31;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.06.19.56.38;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.09.20.46.02;	author krapht;	state Exp;
branches;
next	;


desc
@@


1.106
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@/*	$OpenBSD: import.c,v 1.105 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "diff.h"
#include "remote.h"

void	cvs_import_local(struct cvs_file *);

static void import_loginfo(char *);
static void import_new(struct cvs_file *);
static void import_printf(const char *, ...)
	__attribute__((format(printf, 1, 2)));
static void import_update(struct cvs_file *);
static void import_tag(struct cvs_file *, RCSNUM *, RCSNUM *);
static BUF *import_get_rcsdiff(struct cvs_file *, RCSNUM *);

#define IMPORT_DEFAULT_BRANCH	"1.1.1"

extern char *loginfo;
extern char *logmsg;

static char *import_branch = IMPORT_DEFAULT_BRANCH;
static char *vendor_tag = NULL;
static char **release_tags;
static char *koptstr;
static int dflag = 0;
static int tagcount = 0;
static BUF *logbuf;

char *import_repository = NULL;
int import_conflicts = 0;

struct cvs_cmd cvs_cmd_import = {
	CVS_OP_IMPORT, CVS_USE_WDIR, "import",
	{ "im", "imp" },
	"Import sources into CVS, using vendor branches",
	"[-b branch] [-d] [-k mode] [-m message] "
	"repository vendor-tag release-tags",
	"b:dk:m:",
	NULL,
	cvs_import
};

int
cvs_import(int argc, char **argv)
{
	int i, ch;
	char repo[PATH_MAX], *arg = ".";
	struct cvs_recursion cr;
	struct trigger_list *line_list;

	while ((ch = getopt(argc, argv, cvs_cmd_import.cmd_opts)) != -1) {
		switch (ch) {
		case 'b':
			import_branch = optarg;
			break;
		case 'd':
			dflag = 1;
			break;
		case 'k':
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				fatal("%s", cvs_cmd_import.cmd_synopsis);
			}
			break;
		case 'm':
			logmsg = optarg;
			break;
		default:
			fatal("%s", cvs_cmd_import.cmd_synopsis);
			break;
		}
	}

	argc -= optind;
	argv += optind;

	if (argc < 3)
		fatal("%s", cvs_cmd_import.cmd_synopsis);

	import_repository = argv[0];
	vendor_tag = argv[1];
	argc -= 2;
	argv += 2;

	release_tags = argv;
	tagcount = argc;

	if (!rcs_sym_check(vendor_tag))
		fatal("invalid symbol: %s", vendor_tag);

	for (i = 0; i < tagcount; i++) {
		if (!rcs_sym_check(release_tags[i]))
			fatal("invalid symbol: %s", release_tags[i]);
	}

	if (logmsg == NULL) {
		if (cvs_server_active)
			fatal("no log message specified");
		else
			logmsg = cvs_logmsg_create(NULL, NULL, NULL, NULL);
	}

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();

		cvs_client_send_request("Argument -b%s", IMPORT_DEFAULT_BRANCH);

		if (kflag)
			cvs_client_send_request("Argument -k%s", koptstr);

		cvs_client_send_logmsg(logmsg);
		cvs_client_send_request("Argument %s", import_repository);
		cvs_client_send_request("Argument %s", vendor_tag);
		for (i = 0; i < tagcount; i++)
			cvs_client_send_request("Argument %s", release_tags[i]);

		cr.enterdir = NULL;
		cr.leavedir = NULL;
		cr.fileproc = cvs_client_sendfile;
		cr.flags = CR_RECURSE_DIRS;

		cvs_file_run(1, &arg, &cr);
		cvs_client_senddir(".");
		cvs_client_send_request("import");

		cvs_client_get_responses();
		return (0);
	}

	if (cvs_logmsg_verify(logmsg))
		return (0);

	(void)xsnprintf(repo, sizeof(repo), "%s/%s",
	    current_cvsroot->cr_dir, import_repository);

	import_loginfo(import_repository);

	if (cvs_noexec != 1)
		cvs_mkdir(repo, 0755);

	cr.enterdir = NULL;
	cr.leavedir = NULL;
	cr.fileproc = cvs_import_local;
	cr.flags = CR_RECURSE_DIRS;
	cvs_file_run(1, &arg, &cr);

	if (import_conflicts != 0) {
		import_printf("\n%d conflicts created by this import.\n\n",
		    import_conflicts);
		import_printf("Use the following command to help the merge:\n");
		import_printf("\topencvs checkout ");
		import_printf("-j%s:yesterday -j%s %s\n\n", vendor_tag,
		    vendor_tag, import_repository);
	} else {
		import_printf("\nNo conflicts created by this import.\n\n");
	}

	loginfo = buf_release(logbuf);
	logbuf = NULL;

	line_list = cvs_trigger_getlines(CVS_PATH_LOGINFO, import_repository);
	if (line_list != NULL) {
		cvs_trigger_handle(CVS_TRIGGER_LOGINFO, import_repository,
		    loginfo, line_list, NULL);
		cvs_trigger_freelist(line_list);
	}

	free(loginfo);
	return (0);
}

static void
import_printf(const char *fmt, ...)
{
	char *str;
	va_list vap;

	va_start(vap, fmt);
	if (vasprintf(&str, fmt, vap) == -1)
		fatal("import_printf: could not allocate memory");
	va_end(vap);

	cvs_printf("%s", str);
	buf_puts(logbuf, str);

	free(str);
}

void
cvs_import_local(struct cvs_file *cf)
{
	int isnew;
	struct stat st;
	char repo[PATH_MAX];

	cvs_log(LP_TRACE, "cvs_import_local(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_type == CVS_DIR) {
		if (!strcmp(cf->file_path, "."))
			return;

		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Importing %s", cf->file_path);

		if (cvs_noexec == 1)
			return;

		if (mkdir(cf->file_rpath, 0755) == -1 && errno != EEXIST)
			fatal("cvs_import_local: %s: %s", cf->file_rpath,
			    strerror(errno));

		return;
	}

	isnew = 1;
	(void)xsnprintf(repo, sizeof(repo), "%s/%s/%s/%s%s",
	    current_cvsroot->cr_dir, cf->file_wd, CVS_PATH_ATTIC,
	    cf->file_name, RCS_FILE_EXT);

	if (cf->file_rcs != NULL || stat(repo, &st) != -1)
		isnew = 0;

	if (isnew == 1)
		import_new(cf);
	else
		import_update(cf);
}

static void
import_loginfo(char *repo)
{
	int i;
	char pwd[PATH_MAX];

	if (getcwd(pwd, sizeof(pwd)) == NULL)
		fatal("Can't get working directory");

	logbuf = buf_alloc(1024);
	cvs_trigger_loginfo_header(logbuf, repo);

	buf_puts(logbuf, "Log Message:\n");
	buf_puts(logbuf, logmsg);
	if (logmsg[0] != '\0' && logmsg[strlen(logmsg) - 1] != '\n')
		buf_putc(logbuf, '\n');
	buf_putc(logbuf, '\n');

	buf_puts(logbuf, "Status:\n\n");

	buf_puts(logbuf, "Vendor Tag:\t");
	buf_puts(logbuf, vendor_tag);
	buf_putc(logbuf, '\n');
	buf_puts(logbuf, "Release Tags:\t");

	for (i = 0; i < tagcount ; i++) {
		buf_puts(logbuf, "\t\t");
		buf_puts(logbuf, release_tags[i]);
		buf_putc(logbuf, '\n');
	}
	buf_putc(logbuf, '\n');
	buf_putc(logbuf, '\n');
}

static void
import_new(struct cvs_file *cf)
{
	int i;
	BUF *bp;
	mode_t mode;
	time_t tstamp;
	struct stat st;
	struct rcs_branch *brp;
	struct rcs_delta *rdp;
	RCSNUM *branch, *brev;

	tstamp = -1;

	cvs_log(LP_TRACE, "import_new(%s)", cf->file_name);

	if (cvs_noexec == 1) {
		import_printf("N %s/%s\n", import_repository, cf->file_path);
		return;
	}

	if (fstat(cf->fd, &st) == -1)
		fatal("import_new: %s", strerror(errno));

	mode = st.st_mode;

	if (dflag == 1)
		tstamp = st.st_mtime;

	if ((branch = rcsnum_parse(import_branch)) == NULL)
		fatal("import_new: failed to parse branch");

	bp = buf_load_fd(cf->fd);

	if ((brev = rcsnum_brtorev(branch)) == NULL)
		fatal("import_new: failed to get first branch revision");

	cf->repo_fd = open(cf->file_rpath, O_CREAT | O_RDONLY);
	if (cf->repo_fd < 0)
		fatal("import_new: %s: %s", cf->file_rpath, strerror(errno));

	cf->file_rcs = rcs_open(cf->file_rpath, cf->repo_fd, RCS_CREATE,
	    (mode & ~(S_IWUSR | S_IWGRP | S_IWOTH)));
	if (cf->file_rcs == NULL)
		fatal("import_new: failed to create RCS file for %s",
		    cf->file_path);

	rcs_branch_set(cf->file_rcs, branch);

	if (rcs_sym_add(cf->file_rcs, vendor_tag, branch) == -1)
		fatal("import_new: failed to add vendor tag");

	for (i = 0; i < tagcount; i++) {
		if (rcs_sym_add(cf->file_rcs, release_tags[i], brev) == -1)
			fatal("import_new: failed to add release tag");
	}

	if (rcs_rev_add(cf->file_rcs, brev, logmsg, tstamp, NULL) == -1)
		fatal("import_new: failed to create first branch revision");

	if (rcs_rev_add(cf->file_rcs, RCS_HEAD_REV, "Initial revision",
	    tstamp, NULL) == -1)
		fatal("import_new: failed to create first revision");

	if ((rdp = rcs_findrev(cf->file_rcs, cf->file_rcs->rf_head)) == NULL)
		fatal("import_new: cannot find newly added revision");

	brp = xmalloc(sizeof(*brp));
	brp->rb_num = rcsnum_alloc();
	rcsnum_cpy(brev, brp->rb_num, 0);
	TAILQ_INSERT_TAIL(&(rdp->rd_branches), brp, rb_list);

	if (rcs_deltatext_set(cf->file_rcs,
	    cf->file_rcs->rf_head, bp) == -1)
		fatal("import_new: failed to set deltatext");

	if (kflag)
		rcs_kwexp_set(cf->file_rcs, kflag);

	rcs_write(cf->file_rcs);
	import_printf("N %s/%s\n", import_repository, cf->file_path);

	free(branch);
	free(brev);
}

static void
import_update(struct cvs_file *cf)
{
	int ret;
	BUF *b1, *b2, *d;
	char branch[CVS_REV_BUFSZ];
	RCSNUM *newrev, *rev, *brev;

	cvs_log(LP_TRACE, "import_update(%s)", cf->file_path);

	if (cf->file_rcs->rf_head == NULL)
		fatal("no head revision in RCS file for `%s'", cf->file_path);

	if ((rev = rcs_translate_tag(import_branch, cf->file_rcs)) == NULL)
		fatal("import_update: could not translate tag `%s'",
		    import_branch);

	if ((brev = rcsnum_parse(import_branch)) == NULL)
		fatal("import_update: rcsnum_parse failed");

	b1 = rcs_rev_getbuf(cf->file_rcs, rev, RCS_KWEXP_NONE);
	b2 = buf_load_fd(cf->fd);

	ret = buf_differ(b1, b2);
	buf_free(b1);
	buf_free(b2);
	if (ret == 0) {
		import_tag(cf, brev, rev);
		free(brev);
		if (cvs_noexec != 1)
			rcs_write(cf->file_rcs);
		import_printf("U %s/%s\n", import_repository, cf->file_path);
		return;
	}

	if (cf->file_rcs->rf_branch != NULL)
		rcsnum_tostr(cf->file_rcs->rf_branch, branch, sizeof(branch));

	if (cf->file_rcs->rf_branch == NULL || cf->in_attic == 1 ||
	    strcmp(branch, import_branch)) {
		import_conflicts++;
		import_printf("C %s/%s\n", import_repository, cf->file_path);
	} else {
		import_printf("U %s/%s\n", import_repository, cf->file_path);
	}

	if (cvs_noexec == 1)
		return;

	d = import_get_rcsdiff(cf, rev);
	newrev = rcsnum_inc(rev);

	if (rcs_rev_add(cf->file_rcs, newrev, logmsg, -1, NULL) == -1)
		fatal("import_update: failed to add new revision");

	if (rcs_deltatext_set(cf->file_rcs, newrev, d) == -1)
		fatal("import_update: failed to set deltatext");

	import_tag(cf, brev, newrev);

	if (kflag)
		rcs_kwexp_set(cf->file_rcs, kflag);

	free(brev);
	rcs_write(cf->file_rcs);
}

static void
import_tag(struct cvs_file *cf, RCSNUM *branch, RCSNUM *newrev)
{
	int i;

	if (cvs_noexec != 1) {
		rcs_sym_add(cf->file_rcs, vendor_tag, branch);

		for (i = 0; i < tagcount; i++)
			rcs_sym_add(cf->file_rcs, release_tags[i], newrev);
	}
}

static BUF *
import_get_rcsdiff(struct cvs_file *cf, RCSNUM *rev)
{
	char *p1, *p2;
	BUF *b1, *b2;
	int fd1, fd2;

	b2 = buf_alloc(128);

	b1 = buf_load_fd(cf->fd);

	(void)xasprintf(&p1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
	fd1 = buf_write_stmp(b1, p1, NULL);
	buf_free(b1);

	(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
	fd2 = rcs_rev_write_stmp(cf->file_rcs, rev, p2, RCS_KWEXP_NONE);

	diff_format = D_RCSDIFF;
	if (diffreg(p2, p1, fd2, fd1, b2, D_FORCEASCII) == D_ERROR)
		fatal("import_get_rcsdiff: failed to get RCS patch");

	close(fd1);
	close(fd2);

	(void)unlink(p1);
	(void)unlink(p2);

	free(p1);
	free(p2);

	return (b2);
}
@


1.105
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.104 2015/01/16 06:40:07 deraadt Exp $	*/
d374 2
a375 2
	rcsnum_free(branch);
	rcsnum_free(brev);
d406 1
a406 1
		rcsnum_free(brev);
d441 1
a441 1
	rcsnum_free(brev);
@


1.104
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.103 2010/09/23 18:10:16 nicm Exp $	*/
d22 1
d195 1
a195 1
	xfree(loginfo);
d213 1
a213 1
	xfree(str);
d486 2
a487 2
	xfree(p1);
	xfree(p2);
@


1.103
log
@Add cvs_mkdir() for recursive directory creation on import, based on a
diff from Michael W Bombardieri in PR 6398.

tested by & ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.102 2010/07/23 21:46:05 ray Exp $	*/
d70 1
a70 1
	char repo[MAXPATHLEN], *arg = ".";
d220 1
a220 1
	char repo[MAXPATHLEN];
d261 1
a261 1
	char pwd[MAXPATHLEN];
@


1.102
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.101 2009/06/27 16:55:31 martynas Exp $	*/
d164 2
a165 4
	if (cvs_noexec != 1) {
		if (mkdir(repo, 0755) == -1 && errno != EEXIST)
			fatal("cvs_import: %s: %s", repo, strerror(errno));
	}
@


1.101
log
@release storage after asprintf.  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.100 2009/06/07 08:39:13 ray Exp $	*/
d186 1
a186 1
	loginfo = cvs_buf_release(logbuf);
d212 1
a212 1
	cvs_buf_puts(logbuf, str);
d268 1
a268 1
	logbuf = cvs_buf_alloc(1024);
d271 2
a272 2
	cvs_buf_puts(logbuf, "Log Message:\n");
	cvs_buf_puts(logbuf, logmsg);
d274 2
a275 2
		cvs_buf_putc(logbuf, '\n');
	cvs_buf_putc(logbuf, '\n');
d277 1
a277 1
	cvs_buf_puts(logbuf, "Status:\n\n");
d279 4
a282 4
	cvs_buf_puts(logbuf, "Vendor Tag:\t");
	cvs_buf_puts(logbuf, vendor_tag);
	cvs_buf_putc(logbuf, '\n');
	cvs_buf_puts(logbuf, "Release Tags:\t");
d285 3
a287 3
		cvs_buf_puts(logbuf, "\t\t");
		cvs_buf_puts(logbuf, release_tags[i]);
		cvs_buf_putc(logbuf, '\n');
d289 2
a290 2
	cvs_buf_putc(logbuf, '\n');
	cvs_buf_putc(logbuf, '\n');
d325 1
a325 1
	bp = cvs_buf_load_fd(cf->fd);
d400 1
a400 1
	b2 = cvs_buf_load_fd(cf->fd);
d402 3
a404 3
	ret = cvs_buf_differ(b1, b2);
	cvs_buf_free(b1);
	cvs_buf_free(b2);
d466 1
a466 1
	b2 = cvs_buf_alloc(128);
d468 1
a468 1
	b1 = cvs_buf_load_fd(cf->fd);
d471 2
a472 2
	fd1 = cvs_buf_write_stmp(b1, p1, NULL);
	cvs_buf_free(b1);
@


1.100
log
@More cvs/diff/rcs convergence:
1. Mostly variable/function renaming, SIZE_T_MAX->SIZE_MAX, and
spacing.
2. One strchr -> strncspn.
3. diff had a weird thing where it set file[12] = ofile[12] but
never updated file or ofile, then if file and ofile were different
it freed it. I removed it.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.99 2009/06/06 14:17:27 ray Exp $	*/
d213 2
@


1.99
log
@Sync some rcsdiff changes to cvsdiff.  As a side effect,
cvs diff -t now works.  There should be no functional change
otherwise.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.98 2009/01/02 00:11:01 canacar Exp $	*/
d476 1
a476 1
	if (cvs_diffreg(p2, p1, fd2, fd1, b2, D_FORCEASCII) == D_ERROR)
@


1.98
log
@Add format attributes to functions that use variable arguments and
make the code -Wformat=2 clean. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.97 2008/06/15 04:21:26 joris Exp $	*/
d476 1
a476 1
	if (cvs_diffreg(p2, p1, fd2, fd1, b2) == D_ERROR)
@


1.97
log
@open the RCS file descriptor with O_RDONLY, like all other code does.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.96 2008/06/14 04:34:08 tobias Exp $	*/
d33 2
a34 1
static void import_printf(const char *, ...);
@


1.96
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.95 2008/06/10 20:30:17 joris Exp $	*/
d327 1
a327 1
	cf->repo_fd = open(cf->file_rpath, O_CREAT|O_TRUNC|O_WRONLY);
@


1.95
log
@properly inherit file permissions.

reported & tested by phessler@@
input otto@@ deraadt@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.94 2008/06/10 02:11:19 tobias Exp $	*/
d385 3
@


1.94
log
@Don't spawn editor for log message on server-side if no log message has
been supplied as argument by client.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.93 2008/06/10 01:00:34 joris Exp $	*/
d295 1
d311 2
a312 3
	if (dflag == 1) {
		if (fstat(cf->fd, &st) == -1)
			fatal("import_new: %s", strerror(errno));
d314 3
a317 1
	}
d331 2
a332 1
	cf->file_rcs = rcs_open(cf->file_rpath, cf->repo_fd, RCS_CREATE, 0444);
@


1.93
log
@New trigger framework that allows us to run the required scripts
defined in CVSROOT/commitinfo and CVSROOT/loginfo and so on.

This enables the use of log_accum2 and all that other nice stuff we like.

This was mostly written by Jonathan Armani with help from tobias@@ and myself.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.92 2008/06/08 20:08:43 tobias Exp $	*/
d121 6
a126 5
	if (logmsg == NULL)
		logmsg = cvs_logmsg_create(NULL, NULL, NULL, NULL);

	if (logmsg == NULL)
		fatal("This shouldnt happen, honestly!");
@


1.92
log
@Handle commits on a per-directory basis instead handling all of them at
once in local setup.  Also added '!' to reuse typed log message for all
following directories.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.91 2008/06/08 13:35:47 joris Exp $	*/
d31 1
d33 1
d40 3
a43 1
static char *logmsg = NULL;
d49 1
d71 1
d154 3
d160 2
d174 1
a174 1
		cvs_printf("\n%d conflicts created by this import.\n\n",
d176 3
a178 3
		cvs_printf("Use the following command to help the merge:\n");
		cvs_printf("\topencvs checkout ");
		cvs_printf("-j%s:yesterday -j%s %s\n\n", vendor_tag,
d181 1
a181 1
		cvs_printf("\nNo conflicts created by this import.\n\n");
d184 11
d198 15
d256 34
d305 1
a305 1
		cvs_printf("N %s/%s\n", import_repository, cf->file_path);
d366 1
a366 1
	cvs_printf("N %s/%s\n", import_repository, cf->file_path);
d400 1
a400 1
		cvs_printf("U %s/%s\n", import_repository, cf->file_path);
d410 1
a410 1
		cvs_printf("C %s/%s\n", import_repository, cf->file_path);
d412 1
a412 1
		cvs_printf("U %s/%s\n", import_repository, cf->file_path);
@


1.91
log
@allow for multiple release tags, noticed by tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.90 2008/06/08 13:22:46 joris Exp $	*/
d116 1
a116 1
		logmsg = cvs_logmsg_create(NULL, NULL, NULL);
@


1.90
log
@properly check the passed tags if they are valid before attempting
the import.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.89 2008/05/22 15:45:01 tobias Exp $	*/
d41 1
a41 1
static char *release_tag = NULL;
d44 1
d63 1
a63 1
	int ch;
d101 5
a105 1
	release_tag = argv[2];
d109 5
a113 2
	if (!rcs_sym_check(release_tag))
		fatal("invalid symbol: %s", release_tag);
d132 2
a133 1
		cvs_client_send_request("Argument %s", release_tag);
d221 1
d267 4
a270 2
	if (rcs_sym_add(cf->file_rcs, release_tag, brev) == -1)
		fatal("import_new: failed to add release tag");
d368 1
a368 1
	char b[CVS_REV_BUFSZ];
a370 1
		rcsnum_tostr(branch, b, sizeof(b));
d373 2
a374 2
		rcsnum_tostr(newrev, b, sizeof(b));
		rcs_sym_add(cf->file_rcs, release_tag, newrev);
@


1.89
log
@expension -> expansion

ok joris, xsa (quite some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.88 2008/05/22 06:48:27 xsa Exp $	*/
d98 9
a111 4

	import_repository = argv[0];
	vendor_tag = argv[1];
	release_tag = argv[2];
@


1.88
log
@Error messages fixes; Stefan Sperling.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.85 2008/02/27 22:34:04 joris Exp $	*/
d79 1
a79 1
				    "invalid RCS keyword expension mode");
@


1.87
log
@import_get_rcsdiff() doesnt need cvs_noexec checks.
it only gets called from import_update() which handles the noexec stuff
@
text
@d250 1
a250 1
		fatal("import_new: failed to add release tag");
d253 1
a253 1
		fatal("import_new: failed to add vendor tag");
@


1.86
log
@allow dry-runs (-n) to work properly;
@
text
@d371 1
a371 2
	if (cvs_noexec != 1) {
		b1 = cvs_buf_load_fd(cf->fd);
d373 3
a375 3
		(void)xasprintf(&p1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
		fd1 = cvs_buf_write_stmp(b1, p1, NULL);
		cvs_buf_free(b1);
d377 2
a378 2
		(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
		fd2 = rcs_rev_write_stmp(cf->file_rcs, rev, p2, RCS_KWEXP_NONE);
d380 3
a382 3
		diff_format = D_RCSDIFF;
		if (cvs_diffreg(p2, p1, fd2, fd1, b2) == D_ERROR)
			fatal("import_get_rcsdiff: failed to get RCS patch");
d384 2
a385 2
		close(fd1);
		close(fd2);
d387 2
a388 2
		(void)unlink(p1);
		(void)unlink(p2);
d390 2
a391 3
		xfree(p1);
		xfree(p2);
	}
@


1.85
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.84 2008/02/20 17:29:28 tobias Exp $	*/
d310 3
a312 1
		rcs_write(cf->file_rcs);
d319 11
a339 8

	if (cf->file_rcs->rf_branch == NULL || cf->in_attic == 1 ||
	    strcmp(branch, import_branch)) {
		import_conflicts++;
		cvs_printf("C %s/%s\n", import_repository, cf->file_path);
	} else {
		cvs_printf("U %s/%s\n", import_repository, cf->file_path);
	}
@


1.84
log
@With latest buf cleanup, rcs_rev_getbuf won't return NULL anymore.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.83 2008/02/11 20:33:11 tobias Exp $	*/
d362 1
d370 1
a370 1
		cvs_buf_write_stmp(b1, p1, NULL);
d374 1
a374 1
		rcs_rev_write_stmp(cf->file_rcs, rev, p2, RCS_KWEXP_NONE);
d377 1
a377 1
		if (cvs_diffreg(p2, p1, b2) == D_ERROR)
d379 3
@


1.83
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.82 2008/02/04 15:07:33 tobias Exp $	*/
d295 2
a296 1
		fatal("import_update: could not translate tag `%s'", import_branch);
d301 1
a301 3
	if ((b1 = rcs_rev_getbuf(cf->file_rcs, rev, RCS_KWEXP_NONE)) == NULL)
		fatal("import_update: failed to grab revision");

@


1.82
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.81 2008/01/31 21:30:08 joris Exp $	*/
d233 1
a233 2
	if ((bp = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
		fatal("import_new: failed to load %s", cf->file_path);
d303 1
a303 2
	if ((b2 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
		fatal("import_update: failed to load %s", cf->file_path);
d364 1
a364 1
	b2 = cvs_buf_alloc(128, BUF_AUTOEXT);
d367 1
a367 3
		if ((b1 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
			fatal("import_get_rcsdiff: failed loading %s",
			    cf->file_path);
@


1.81
log
@remove dead and unreachable code

ok tobias@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.80 2008/01/31 10:15:05 tobias Exp $	*/
a42 1
static int kflag = RCS_KWEXP_DEFAULT;
d113 1
a113 1
		if (kflag != RCS_KWEXP_DEFAULT)
d275 1
a275 1
	if (kflag != RCS_KWEXP_DEFAULT)
d339 1
a339 1
	if (kflag != RCS_KWEXP_DEFAULT)
@


1.80
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.79 2008/01/10 09:54:04 tobias Exp $	*/
d292 1
a292 1
	RCSNUM *newrev, *rev, *brev, *hrev;
d302 14
a315 18
	if (rev != NULL) {
		if ((b1 = rcs_rev_getbuf(cf->file_rcs, rev, RCS_KWEXP_NONE))
		    == NULL)
			fatal("import_update: failed to grab revision");

		if ((b2 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
			fatal("import_update: failed to load %s",
			    cf->file_path);

		ret = cvs_buf_differ(b1, b2);
		cvs_buf_free(b1);
		cvs_buf_free(b2);
		if (ret == 0) {
			import_tag(cf, brev, rev);
			rcsnum_free(brev);
			rcs_write(cf->file_rcs);
			return;
		}
d321 2
a322 12
	if (rev != NULL) {
		d = import_get_rcsdiff(cf, rev);
		newrev = rcsnum_inc(rev);
	} else {
		hrev = rcs_head_get(cf->file_rcs);
		if (hrev == NULL)
			fatal("RCS head empty or missing in %s\n",
			    cf->file_rcs->rf_path);
		d = import_get_rcsdiff(cf, hrev);
		rcsnum_free(hrev);
		newrev = rcsnum_brtorev(brev);
	}
@


1.79
log
@Our keyword expansion had a big flaw, due to this construction:
if (!(mode & RCS_KWEXP_NONE))

RCS_KWEXP_NONE is defined to 0, so expansion happened always.

Left shifted all RCS_KWEXP defines and looked carefully at hard-coded values
throughout the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.78 2008/01/10 09:37:26 tobias Exp $	*/
d50 1
a50 1
	CVS_OP_IMPORT, 0, "import",
@


1.78
log
@RCS files without head keyword mustn't segfault our implementation.  Only
command that supports such files is "cvs status", therefore properly handle
them in all other commands, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.77 2007/09/22 16:01:22 joris Exp $	*/
d303 2
a304 1
		if ((b1 = rcs_rev_getbuf(cf->file_rcs, rev, 0)) == NULL)
d393 1
a393 1
		rcs_rev_write_stmp(cf->file_rcs, rev, p2, 0);
@


1.77
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.76 2007/09/02 11:31:35 tobias Exp $	*/
d329 3
@


1.76
log
@Stick at GNU cvs behaviour by writing "Initial revision" in revision 1.1
instead of custom log message (which gets written into 1.1.1.1).

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.75 2007/08/30 11:07:18 joris Exp $	*/
d172 1
a172 1
	cvs_file_classify(cf, NULL);
@


1.75
log
@properly send our log message to the server using Argumentx, so we
no longer break when the log message has multiple lines.

from Tobias Stoeckmann, thanks for doing my work!
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.74 2007/06/28 21:38:09 xsa Exp $	*/
d260 2
a261 1
	if (rcs_rev_add(cf->file_rcs, RCS_HEAD_REV, logmsg, tstamp, NULL) == -1)
@


1.74
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.73 2007/06/01 17:47:47 niallo Exp $	*/
d117 1
a117 1
		cvs_client_send_request("Argument -m%s", logmsg);
@


1.73
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.72 2007/02/22 06:42:09 otto Exp $	*/
d290 1
a290 1
	char branch[16];
d359 1
a359 1
	char b[16];
@


1.72
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.71 2007/02/21 04:18:45 ray Exp $	*/
d341 1
a341 1
	if (cf->file_rcs->rf_branch == NULL || cf->file_rcs->rf_inattic == 1 ||
@


1.71
log
@Simplify cvs_buf_differ().  Also cvs_buf_differ(), a comparison
function, should not do any resource freeing.

OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.70 2007/02/17 18:23:43 xsa Exp $	*/
d18 6
a23 1
#include "includes.h"
a26 1
#include "log.h"
@


1.70
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.69 2007/02/09 03:49:15 joris Exp $	*/
d306 2
@


1.69
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.68 2007/02/01 11:06:25 xsa Exp $	*/
d131 2
a132 3
	if (cvs_path_cat(current_cvsroot->cr_dir, import_repository,
	    repo, sizeof(repo)) >= sizeof(repo))
		fatal("cvs_import: truncation");
@


1.68
log
@add support for [-k mode]; tests/ok otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.67 2007/01/31 21:07:35 xsa Exp $	*/
d169 1
a169 1
	cvs_file_classify(cf, NULL, 0);
@


1.67
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.66 2007/01/20 01:07:51 niallo Exp $	*/
d38 2
a39 1

d49 3
a51 2
	"[-d] [-b branch] [-m message] repository vendor-tag release-tags",
	"b:dm:",
d71 9
d109 4
d272 3
d343 3
@


1.66
log
@sweep opencvs for missing rcs_translate_tag() return checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.65 2007/01/19 08:21:45 xsa Exp $	*/
a147 1
	int l;
d174 1
a174 1
	l = snprintf(repo, sizeof(repo), "%s/%s/%s/%s%s",
a176 2
	if (l == -1 || l >= (int)sizeof(repo))
		fatal("import_new: overflow");
@


1.65
log
@move cvs_import() proto to the correct place.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.64 2007/01/18 16:45:52 joris Exp $	*/
d277 2
a278 1
	rev = rcs_translate_tag(import_branch, cf->file_rcs);
@


1.64
log
@import improvements:
- add support for remote import in opencvs client and server.
- do not free already free'd buffers in import_update()
- do not append a '\0' to the loaded file buffer, this was bad behaviour

makes import work fine both locally and remotely.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.63 2007/01/14 23:10:56 joris Exp $	*/
a24 1
int	cvs_import(int, char **);
@


1.63
log
@move things around in rcs_rev_getbuf() and rcs_rev_write_fd()
so that we do keyword expansion on-the-fly if required instead
of obtaining the revision in memory first, running over the revision
lines while expanding keywords and only then writing them to the fd
or memory buffer.

this drasticly decreases cpu usage by opencvs on very large trees (like src).

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.62 2007/01/13 20:29:46 joris Exp $	*/
d23 1
d95 22
a222 2
	cvs_buf_putc(bp, '\0');

d271 1
d274 1
a274 1
	RCSNUM *newrev, *rev, *brev;
d291 2
a292 1
		if (cvs_buf_differ(b1, b2) == 0) {
a293 3
			cvs_printf("U %s/%s\n", import_repository,
			    cf->file_path);
			rcsnum_free(rev);
d307 3
a309 1
		d = import_get_rcsdiff(cf, rcs_head_get(cf->file_rcs));
a318 1
	cvs_buf_free(d);
a328 2
	if (rev != NULL)
		rcsnum_free(rev);
a329 1

a352 3
	if ((b1 = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
		fatal("import_get_rcsdiff: failed loading %s", cf->file_path);

d356 4
d374 2
a375 4
		if (p1 != NULL)
			xfree(p1);
		if (p2 != NULL)
			xfree(p2);
a376 3

	if (b1 != NULL)
		cvs_buf_free(b1);
@


1.62
log
@make import and init work again after the small breakage
we had with the rcs changes;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.61 2007/01/12 23:32:01 niallo Exp $	*/
d262 1
a262 1
		if ((b1 = rcs_rev_getbuf(cf->file_rcs, rev)) == NULL)
@


1.61
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.60 2007/01/12 17:25:33 joris Exp $	*/
d30 1
a30 1
static char *import_get_rcsdiff(struct cvs_file *, RCSNUM *);
d250 2
a251 2
	BUF *b1, *b2;
	char *d, branch[16];
d297 1
a297 2
	xfree(d);

d329 1
a329 1
static char *
d332 1
a332 1
	char *delta, *p1, *p2;
a360 3
	cvs_buf_putc(b2, '\0');
	delta = cvs_buf_release(b2);

a362 2
	if (b2 != NULL)
		cvs_buf_free(b2);
d364 1
a364 1
	return (delta);
@


1.60
log
@complete binary support for opencvs,
adding/importing binary files now works too

partially taken from openrcs
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.59 2007/01/11 15:41:42 xsa Exp $	*/
d262 1
a262 1
		if ((b1 = rcs_getrev(cf->file_rcs, rev)) == NULL)
d334 1
a334 1
	BUF *b1, *b2, *b3;
d339 1
a339 4
	if ((b2 = rcs_getrev(cf->file_rcs, rev)) == NULL)
		fatal("import_get_rcsdiff: failed loading revision");

	b3 = cvs_buf_alloc(128, BUF_AUTOEXT);
d347 1
a347 2
		cvs_buf_write_stmp(b2, p2, NULL);
		cvs_buf_free(b2);
d350 1
a350 1
		if (cvs_diffreg(p2, p1, b3) == D_ERROR)
d362 2
a363 2
	cvs_buf_putc(b3, '\0');
	delta = cvs_buf_release(b3);
a368 2
	if (b3 != NULL)
		cvs_buf_free(b3);
@


1.59
log
@revert last commit after discussing w/ joris@@; makes sense to remove
the tmp files once we'r done w/ them, not at the very end only..
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.58 2007/01/11 12:37:29 xsa Exp $	*/
a171 1
	char *content;
a200 1
	content = cvs_buf_release(bp);
d237 1
a237 1
	    cf->file_rcs->rf_head, content) == -1)
a242 1
	xfree(content);
@


1.58
log
@no need to unlink() the tmp files here as they have already been added
to the temp_files walklist anyway..
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.57 2007/01/07 02:47:57 joris Exp $	*/
d359 3
@


1.57
log
@and lets make import work with the new logmsg code too!
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.56 2006/12/04 09:51:21 xsa Exp $	*/
a358 3

		(void)unlink(p1);
		(void)unlink(p2);
@


1.56
log
@snprintf() -> cvs_path_cat()
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.55 2006/12/04 09:46:27 xsa Exp $	*/
d85 4
a88 1
		fatal("please specify a logmessage using -m for now");
@


1.55
log
@- unlink tmp files when finished.
- add missing xfree().
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.54 2006/07/08 09:25:44 ray Exp $	*/
d57 1
a57 1
	int ch, l;
d91 3
a93 4
	l = snprintf(repo, sizeof(repo), "%s/%s", current_cvsroot->cr_dir,
	    import_repository);
	if (l == -1 || l >= (int)sizeof(repo))
		fatal("cvs_import: overflow");
@


1.54
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.53 2006/06/19 05:05:17 joris Exp $	*/
d357 8
d369 8
@


1.53
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.52 2006/06/16 14:07:42 joris Exp $	*/
d347 1
a347 1
		cvs_buf_write_stmp(b1, p1, 0600, NULL);
d351 1
a351 1
		cvs_buf_write_stmp(b2, p2, 0600, NULL);
@


1.52
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.51 2006/06/16 14:02:37 xsa Exp $	*/
d103 1
a103 2
	cr.remote = NULL;
	cr.local = cvs_import_local;
@


1.51
log
@add support for -d; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.50 2006/06/14 14:10:50 joris Exp $	*/
a22 1
#include "proto.h"
d45 1
a45 1
	CVS_OP_IMPORT, CVS_REQ_IMPORT, "import",
@


1.50
log
@add cvs_buf_load_fd() which does the same as cvs_buf_load()
except it takes a decriptor as argument instead of a path.

modified cvs_buf_load() to open the descriptor then pass
it to cvs_buf_load_fd().

change all the calls to cvs_buf_load() that have a descriptor
open for the path to cvs_buf_load_fd() to prevent races.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.49 2006/06/11 17:50:11 joris Exp $	*/
d40 2
d49 2
a50 2
	"[-b vendor branch id] [-m message] repository vendor-tag release-tags",
	"b:m:",
d67 3
d173 2
d179 2
d188 7
d224 1
a224 1
	if (rcs_rev_add(cf->file_rcs, brev, logmsg, -1, NULL) == -1)
d227 1
a227 1
	if (rcs_rev_add(cf->file_rcs, RCS_HEAD_REV, logmsg, -1, NULL) == -1)
@


1.49
log
@remove unused variable
from Jasper Lievisse Adriaanse.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.48 2006/06/04 09:52:56 joris Exp $	*/
d182 1
a182 1
	if ((bp = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
d252 1
a252 2
		/* XXX */
		if ((b2 = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
d323 1
a323 2
	/* XXX */
	if ((b1 = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
@


1.48
log
@sprinkle -n voodoo over the add, commit and import commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.47 2006/06/01 20:01:31 joris Exp $	*/
d238 1
a238 1
	char *d, b[16], branch[16];
@


1.47
log
@import work on existing repos:
- make it work (obviously).
- count conflicts and report them at the end of the import.
- add the release tags to the correct revision.

fixes for importing to new repos:
- add the release tags to the correct branch revision
- plug memleak

general import fixes:
- use the correct path in the status messages, this is just
  fluffy output but it does make things nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.46 2006/05/30 21:41:00 joris Exp $	*/
d92 4
a95 2
	if (mkdir(repo, 0755) == -1 && errno != EEXIST)
		fatal("cvs_import: %s: %s", repo, strerror(errno));
d137 2
d174 5
d284 1
d309 3
a311 2
	rcsnum_tostr(branch, b, sizeof(b));
	rcs_sym_add(cf->file_rcs, vendor_tag, branch);
d313 3
a315 2
	rcsnum_tostr(newrev, b, sizeof(b));
	rcs_sym_add(cf->file_rcs, release_tag, newrev);
d333 13
a345 11
	(void)xasprintf(&p1, "%s/diff1.XXXXXXXXXX", cvs_tmpdir);
	cvs_buf_write_stmp(b1, p1, 0600, NULL);
	cvs_buf_free(b1);

	(void)xasprintf(&p2, "%s/diff2.XXXXXXXXXX", cvs_tmpdir);
	cvs_buf_write_stmp(b2, p2, 0600, NULL);
	cvs_buf_free(b2);

	diff_format = D_RCSDIFF;
	if (cvs_diffreg(p2, p1, b3) == D_ERROR)
		fatal("import_get_rcsdiff: failed to get RCS patch");
@


1.46
log
@ugh forgot to change cvs_file_classify here too.
i dont deserve beers tonight.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.45 2006/05/30 07:00:30 joris Exp $	*/
d30 2
d41 1
d102 11
d196 1
a196 1
	if (rcs_sym_add(cf->file_rcs, release_tag, branch) == -1)
d218 1
a218 1
	cvs_printf("N %s\n", cf->file_path);
d220 1
d228 4
d233 103
@


1.45
log
@hello import, only works for non-existing repositories right now,
but work is in progress for importing stuff into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
a112 1
	cvs_file_classify(cf, 0);
@


1.44
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.43 2006/04/14 02:45:35 deraadt Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Joris Vink <joris@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d21 1
d25 2
d28 2
a29 1
#define CVS_IMPORT_DEFBRANCH	"1.1.1"
d31 1
d33 4
a36 11
static int	cvs_import_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_import_pre_exec(struct cvsroot *);
static int	cvs_import_pre_exec(struct cvsroot *);
static int	cvs_import_post_exec(struct cvsroot *);
static int	cvs_import_remote(CVSFILE *, void *);
static int	cvs_import_local(CVSFILE *, void *);
static int	cvs_import_cleanup(void);

static int dflag = 0;
static int conflicts = 0;
static RCSNUM *imp_brnum;
d38 1
a38 1
static char *module, *vendor, *release;
d44 2
a45 3
	"[-d] [-b branch] [-I ign] [-k mode] [-m msg] [-W spec] module "
	"vendortag releasetag ...",
	"b:dI:k:m:W:",
d47 1
a47 8
	CF_RECURSE | CF_IGNORE | CF_NOSYMS,
	cvs_import_init,
	cvs_import_pre_exec,
	cvs_import_remote,
	cvs_import_local,
	cvs_import_post_exec,
	cvs_import_cleanup,
	CVS_CMD_SENDDIR
d50 2
a51 2
static int
cvs_import_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d53 3
a55 1
	int ch;
d57 1
a57 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
d60 1
a60 17
			if ((imp_brnum = rcsnum_parse(optarg)) == NULL) {
				cvs_log(LP_ERR, "%s is not a numeric branch",
				    optarg);
				return (CVS_EX_USAGE);
			}
			break;
		case 'd':
			dflag = 1;
			break;
		case 'I':
			if (cvs_file_ignore(optarg) < 0) {
				cvs_log(LP_ERR, "failed to add `%s' to list "
				    "of ignore patterns", optarg);
				return (CVS_EX_USAGE);
			}
			break;
		case 'k':
d63 1
a63 1
			cvs_msg = xstrdup(optarg);
d66 2
a67 1
			return (CVS_EX_USAGE);
a72 6
	if (argc != 3)
		return (CVS_EX_USAGE);

	if (imp_brnum == NULL &&
	    (imp_brnum = rcsnum_parse(CVS_IMPORT_DEFBRANCH)) == NULL)
		fatal("cvs_import_init: rcsnum_parse failed");
d74 2
a75 3
	module = argv[0];
	vendor = argv[1];
	release = argv[2];
d77 2
a78 1
	*arg = optind + 3;
d80 18
a97 2
	if (cvs_msg == NULL)
		cvs_msg = cvs_logmsg_get(NULL, NULL, NULL, NULL);
d102 2
a103 2
static int
cvs_import_pre_exec(struct cvsroot *root)
d105 4
a108 1
	char numbuf[64], repodir[MAXPATHLEN];
d110 1
a110 18
	if (root->cr_method == CVS_METHOD_LOCAL) {
		if (cvs_path_cat(root->cr_dir, module, repodir,
		    sizeof(repodir)) >= sizeof(repodir))
			fatal("cvs_import_pre_exec: cvs_path_cat overflow");

		if (mkdir(repodir, 0775) == -1)
			fatal("cvs_import_pre_exec: mkdir `%s': %s",
			    repodir, strerror(errno));
	} else {
		rcsnum_tostr(imp_brnum, numbuf, sizeof(numbuf));

		cvs_sendarg(root, "-b", 0);
		cvs_sendarg(root, numbuf, 0);
		cvs_logmsg_send(root, cvs_msg);
		cvs_sendarg(root, module, 0);
		cvs_sendarg(root, vendor, 0);
		cvs_sendarg(root, release, 0);
	}
d112 1
a112 2
	return (0);
}
d114 3
a116 4
static int
cvs_import_post_exec(struct cvsroot *root)
{
	char buf[8];
d118 2
a119 8
	if (root->cr_method == CVS_METHOD_LOCAL) {
		if (conflicts > 0)
			snprintf(buf, sizeof(buf), "%d", conflicts);

		if (verbosity > 0)
			cvs_printf("\n%s conflicts created by this import\n\n",
			    conflicts == 0 ? "No" : buf);
	}
a120 2
	return (CVS_EX_OK);
}
d122 3
a124 29
/*
 * cvs_import_remote()
 *
 * Perform the import of a single file or directory.
 */
static int
cvs_import_remote(CVSFILE *cf, void *arg)
{
	size_t sz;
	struct cvsroot *root;
	char fpath[MAXPATHLEN], repodir[MAXPATHLEN];
	char repo[MAXPATHLEN], date[32];

	root = CVS_DIR_ROOT(cf);

	if (cvs_path_cat(root->cr_dir, module, repo, sizeof(repo)) >=
	    sizeof(repo))
		fatal("cvs_import_remove: cvs_path_cat overflow");

	cvs_file_getpath(cf, fpath, sizeof(fpath));

	if (cf->cf_type == DT_DIR) {
		if (!strcmp(cf->cf_name, "."))
			strlcpy(repodir, repo, sizeof(repodir));
		else {
			if(cvs_path_cat(repo, fpath, repodir,
			    sizeof(repodir)) >= sizeof(repodir))
				fatal("cvs_import_remove: cvs_path_cat overflow");
		}
d126 1
a126 3
		cvs_sendreq(root, CVS_REQ_DIRECTORY, fpath);
		cvs_sendln(root, repodir);
		return (0);
d129 6
a134 7
	if (dflag == 1) {
		ctime_r(&(cf->cf_mtime), date);
		sz = strlen(date);
		if (sz > 0 && date[sz - 1] == '\n')
			date[--sz] = '\0';
		cvs_sendreq(root, CVS_REQ_CHECKINTIME, date);
	}
d136 2
a137 2
	cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name);
	cvs_sendfile(root, fpath);
d139 4
a142 1
	return (0);
d145 2
a146 2
static int
cvs_import_local(CVSFILE *cf, void *arg)
d148 3
a150 7
	time_t stamp;
	char *fcont;
	char fpath[MAXPATHLEN], rpath[MAXPATHLEN], repo[MAXPATHLEN];
	const char *comment;
	struct stat fst;
	struct timeval ts[2];
	struct cvsroot *root;
d152 12
a163 4
	struct rcs_branch *brp;
	RCSFILE *rf;
	RCSNUM *rev, *brev;
	BUF *bp;
d165 2
a166 1
	root = CVS_DIR_ROOT(cf);
d168 3
a170 20
	if (cvs_path_cat(root->cr_dir, module, repo, sizeof(repo)) >=
	    sizeof(repo))
		fatal("cvs_import_local: cvs_path_cat overflow");

	cvs_file_getpath(cf, fpath, sizeof(fpath));

	if (cf->cf_type == DT_DIR) {
		if (!strcmp(cf->cf_name, "."))
			strlcpy(rpath, repo, sizeof(rpath));
		else {
			if (cvs_path_cat(repo, fpath, rpath,
			    sizeof(rpath)) >= sizeof(rpath))
				fatal("cvs_import_local: cvs_path_cat overflow");

			cvs_printf("Importing %s\n", rpath);
			if (mkdir(rpath, 0755) == -1) {
				cvs_log(LP_ERRNO, "failed to create %s",
				    rpath);
			}
		}
d172 4
a175 2
		return (0);
	}
d177 1
a177 40
	/*
	 * If -d was given, use the file's last modification time as the
	 * timestamps for the initial revisions.
	 */
	if (dflag == 1) {
		if (stat(fpath, &fst) == -1)
			fatal("cvs_import_local: stat failed on `%s': %s",
			    fpath, strerror(errno));

		stamp = (time_t)fst.st_mtime;

		ts[0].tv_sec = stamp;
		ts[0].tv_usec = 0;
		ts[1].tv_sec = stamp;
		ts[1].tv_usec = 0;
	} else
		stamp = -1;

	if (strlcpy(rpath, repo, sizeof(rpath)) >= sizeof(rpath) ||
	    strlcat(rpath, "/", sizeof(rpath)) >= sizeof(rpath) ||
	    strlcat(rpath, fpath, sizeof(rpath)) >= sizeof(rpath) ||
	    strlcat(rpath, RCS_FILE_EXT, sizeof(rpath)) >= sizeof(rpath))
		fatal("cvs_import_local: path truncation");

	cvs_printf("N %s\n", fpath);

	if ((rf = rcs_open(rpath, RCS_RDWR|RCS_CREATE, 0444)) == NULL)
		fatal("cvs_import_local: rcs_open: `%s': %s", rpath,
		    rcs_errstr(rcs_errno));

	comment = rcs_comment_lookup(cf->cf_name);
	if (comment != NULL)
		rcs_comment_set(rf, comment);

	brev = rcsnum_brtorev(imp_brnum);
	if (rcs_rev_add(rf, brev, cvs_msg, stamp, NULL) < 0) {
		(void)unlink(rpath);
		fatal("cvs_import_local: rcs_rev_add failed: %s",
		    rcs_errstr(rcs_errno));
	}
d179 2
a180 5
	if (rcs_sym_add(rf, release, brev) < 0) {
		(void)unlink(rpath);
		fatal("cvs_import_local: rcs_sym_add failed: %s",
		    rcs_errstr(rcs_errno));
	}
d182 2
a183 7
	rev = rcsnum_alloc();
	rcsnum_cpy(imp_brnum, rev, 2);
	if (rcs_rev_add(rf, rev, cvs_msg, stamp, NULL) < 0) {
		(void)unlink(rpath);
		fatal("cvs_import_local: rcs_rev_add failed: %s",
		    rcs_errstr(rcs_errno));
	}
d185 2
a186 5
	if (rcs_head_set(rf, rev) < 0) {
		(void)unlink(rpath);
		fatal("cvs_import_local: rcs_head_set failed: %s",
		    rcs_errstr(rcs_errno));
	}
d188 2
a189 5
	if (rcs_branch_set(rf, imp_brnum) < 0) {
		(void)unlink(rpath);
		fatal("cvs_import_local: rcs_branch_set failed: %s",
		    rcs_errstr(rcs_errno));
	}
d191 2
a192 5
	if (rcs_sym_add(rf, vendor, imp_brnum) < 0) {
		(void)unlink(rpath);
		fatal("cvs_import_local: rcs_sym_add failed: %s",
		    rcs_errstr(rcs_errno));
	}
a193 4
	/*
	 * Put the branch revision on the branches list for the first revision.
	 */
	rdp = rcs_findrev(rf, rev);
d199 3
a201 6
	if ((bp = cvs_buf_load(fpath, BUF_AUTOEXT)) == NULL) {
		(void)unlink(rpath);
		fatal("cvs_import_local: cvs_buf_load failed");
	}

	cvs_buf_putc(bp, '\0');
d203 2
a204 1
	fcont = cvs_buf_release(bp);
d206 2
a207 12
	if (rcs_deltatext_set(rf, rev, fcont) < 0) {
		(void)unlink(rpath);
		fatal("cvs_import_local: rcs_deltatext_set failed");
	}

	/* add the vendor tag and release tag as symbols */
	rcs_close(rf);

	if (dflag ==1 && utimes(rpath, ts) == -1)
		cvs_log(LP_ERRNO, "failed to timestamp RCS file");

	return (0);
d210 2
a211 2
static int
cvs_import_cleanup(void)
d213 1
a213 3
	if (imp_brnum != NULL)
		rcsnum_free(imp_brnum);
	return (0);
@


1.43
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.42 2006/04/05 01:38:55 ray Exp $	*/
@


1.42
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.41 2006/04/01 00:56:54 joris Exp $	*/
d108 2
a109 2
	if ((imp_brnum == NULL) &&
	    ((imp_brnum = rcsnum_parse(CVS_IMPORT_DEFBRANCH)) == NULL))
d206 1
a206 1
		if ((sz > 0) && (date[sz - 1] == '\n'))
d358 1
a358 1
	if ((dflag ==1) && (utimes(rpath, ts) == -1))
@


1.41
log
@improve import a bit:
- create directory and files with the correct permissions
- correctly add the branch revision to the branch list of the head revision
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.40 2006/03/27 15:26:11 xsa Exp $	*/
d336 1
a336 1
	brp = (struct rcs_branch *)xmalloc(sizeof(*brp));
@


1.40
log
@rcs_comment_set() will never return non-zero; change its return type to void.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.39 2006/02/08 18:42:41 joris Exp $	*/
d134 1
a134 1
		if (mkdir(repodir, 0700) == -1)
d227 2
d230 1
a230 1
	RCSNUM *rev;
d250 1
a250 1
			if (mkdir(rpath, 0700) == -1) {
d285 1
a285 1
	if ((rf = rcs_open(rpath, RCS_RDWR|RCS_CREATE)) == NULL)
d293 2
a294 2
	rev = rcsnum_brtorev(imp_brnum);
	if (rcs_rev_add(rf, rev, cvs_msg, stamp, NULL) < 0) {
d300 1
a300 1
	if (rcs_sym_add(rf, release, rev) < 0) {
d306 1
d331 9
@


1.39
log
@once again, we have to unbreak stuff xsa broke on his own.
seriously xavier, I might be in the carribean but you are drinking
all the rum and commiting shit drunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.38 2006/01/30 17:58:47 xsa Exp $	*/
d288 2
a289 5
	if ((comment != NULL) && (rcs_comment_set(rf, comment) < 0)) {
		cvs_log(LP_WARN, "failed to set RCS comment leader: %s",
		    rcs_errstr(rcs_errno));
		/* don't error out, no big deal */
	}
@


1.38
log
@strerror() -> rcs_errstr() when passing rcs_errno as argument;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.37 2006/01/27 10:39:49 xsa Exp $	*/
d283 1
a283 1
	if ((rf = rcs_open(rpath, RCS_RDWR|RCS_CREATE)) == NULL);
@


1.37
log
@errors handling cleaning;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.36 2006/01/25 08:15:05 xsa Exp $	*/
d285 1
a285 1
		    strerror(rcs_errno));
d304 1
a304 1
		    strerror(rcs_errno));
d323 1
a323 1
		    strerror(rcs_errno));
d329 1
a329 1
		    strerror(rcs_errno));
@


1.36
log
@snprintf() cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.35 2006/01/02 08:11:56 xsa Exp $	*/
d109 2
a110 4
	    ((imp_brnum = rcsnum_parse(CVS_IMPORT_DEFBRANCH)) == NULL)) {
		cvs_log(LP_ERR, "failed to parse default import branch");
		return (CVS_EX_DATA);
	}
a126 1
	size_t len;
d130 7
a136 9
		len = cvs_path_cat(root->cr_dir, module, repodir,
		    sizeof(repodir));
		if (len >= sizeof(repodir))
			return (CVS_EX_DATA);

		if (mkdir(repodir, 0700) == -1) {
			cvs_log(LP_ERRNO, "failed to create %s", repodir);
			return (CVS_EX_DATA);
		}
d176 1
a176 1
	size_t len, sz;
d183 3
a185 3
	len = cvs_path_cat(root->cr_dir, module, repo, sizeof(repo));
	if (len >= sizeof(repo))
		return (CVS_EX_DATA);
d193 3
a195 4
			len = cvs_path_cat(repo, fpath, repodir,
			    sizeof(repodir));
			if (len >= sizeof(repodir))
				return (CVS_EX_DATA);
a219 1
	size_t len;
d233 3
a235 3
	len = cvs_path_cat(root->cr_dir, module, repo, sizeof(repo));
	if (len >= sizeof(repo))
		return (CVS_EX_DATA);
d243 3
a245 3
			len = cvs_path_cat(repo, fpath, rpath, sizeof(rpath));
			if (len >= sizeof(rpath))
				return (CVS_EX_DATA);
d262 4
a265 4
		if (stat(fpath, &fst) == -1) {
			cvs_log(LP_ERRNO, "failed to stat `%s'", fpath);
			return (CVS_EX_DATA);
		}
d283 2
a284 3
	rf = rcs_open(rpath, RCS_RDWR|RCS_CREATE);
	if (rf == NULL) {
		cvs_log(LP_ERR, "failed to create RCS file: %s",
a285 2
		return (CVS_EX_DATA);
	}
d296 2
a297 1
		cvs_log(LP_ERR, "failed to add revision: %s",
a298 3
		rcs_close(rf);
		(void)unlink(rpath);
		return (CVS_EX_DATA);
d302 2
a303 1
		cvs_log(LP_ERR, "failed to set RCS symbol: %s",
a304 3
		rcs_close(rf);
		(void)unlink(rpath);
		return (CVS_EX_DATA);
d309 2
a310 1
		cvs_log(LP_ERR, "failed to add revision: %s",
a311 3
		rcs_close(rf);
		(void)unlink(rpath);
		return (CVS_EX_DATA);
d315 2
a316 1
		cvs_log(LP_ERR, "failed to set RCS head: %s",
a317 3
		rcs_close(rf);
		(void)unlink(rpath);
		return (CVS_EX_DATA);
d321 2
a322 1
		cvs_log(LP_ERR, "failed to set RCS default branch: %s",
a323 1
		return (CVS_EX_DATA);
d327 2
a328 1
		cvs_log(LP_ERR, "failed to set RCS symbol: %s",
a329 3
		rcs_close(rf);
		(void)unlink(rpath);
		return (CVS_EX_DATA);
a332 1
		rcs_close(rf);
d334 1
a334 1
		return (CVS_EX_DATA);
a341 1
		rcs_close(rf);
d343 1
a343 1
		return (CVS_EX_DATA);
d352 1
a352 1
	return (CVS_EX_OK);
@


1.35
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.34 2005/12/30 02:03:28 joris Exp $	*/
a226 1
	int l;
d282 5
a286 7
	l = snprintf(rpath, sizeof(rpath), "%s/%s%s",
	    repo, fpath, RCS_FILE_EXT);
	if (l == -1 || l >= (int)sizeof(rpath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rpath);
		return (CVS_EX_DATA);
	}
@


1.34
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.33 2005/12/21 20:06:25 xsa Exp $	*/
d27 1
a27 8
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.33
log
@cvs_logmsg_open() and cvs_logmsg_get() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.32 2005/12/20 18:17:01 xsa Exp $	*/
d152 6
a157 7
		if ((cvs_sendarg(root, "-b", 0) < 0) ||
		    (cvs_sendarg(root, numbuf, 0) < 0) ||
		    (cvs_logmsg_send(root, cvs_msg) < 0) ||
		    (cvs_sendarg(root, module, 0) < 0) ||
		    (cvs_sendarg(root, vendor, 0) < 0) ||
		    (cvs_sendarg(root, release, 0) < 0))
			return (CVS_EX_PROTO);
d211 2
a212 4
		if (cvs_sendreq(root, CVS_REQ_DIRECTORY, fpath) < 0)
			return (CVS_EX_PROTO);
		if (cvs_sendln(root, repodir) < 0)
			return (CVS_EX_PROTO);
d221 1
a221 2
		if (cvs_sendreq(root, CVS_REQ_CHECKINTIME, date) < 0)
			return (CVS_EX_PROTO);
d223 3
a225 4
	if (cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name) < 0)
		return (CVS_EX_PROTO);
	if (cvs_sendfile(root, fpath) < 0)
		return (CVS_EX_PROTO);
@


1.32
log
@cvs_buf_putc() and cvs_buf_write_*() functions cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.31 2005/12/10 20:27:45 joris Exp $	*/
d127 2
a128 3
	if ((cvs_msg == NULL) &&
	    (cvs_msg = cvs_logmsg_get(NULL, NULL, NULL, NULL)) == NULL)
		return (CVS_EX_DATA);
@


1.31
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.30 2005/12/03 01:02:09 joris Exp $	*/
d374 1
a374 5
	if (cvs_buf_putc(bp, '\0') < 0) {
		rcs_close(rf);
		(void)unlink(rpath);
		return (CVS_EX_DATA);
	}
@


1.30
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.29 2005/11/28 08:49:25 xsa Exp $	*/
d103 1
a103 5
			cvs_msg = strdup(optarg);
			if (cvs_msg == NULL) {
				cvs_log(LP_ERRNO, "failed to copy message");
				return (CVS_EX_DATA);
			}
@


1.29
log
@consistency in error messages;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.28 2005/11/24 11:17:15 xsa Exp $	*/
d246 1
d254 1
d367 20
@


1.28
log
@minor knf + snprintf() return check;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.27 2005/10/15 22:56:02 niallo Exp $	*/
d286 1
a286 1
			cvs_log(LP_ERRNO, "failed to stat %s", fpath);
@


1.27
log
@- add username parameter to rcs_rev_add(), needed to implement at least
  `ci -wusername'.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.26 2005/08/04 12:20:42 xsa Exp $	*/
d224 1
a224 1
	if (dflag) {
d244 1
d284 1
a284 1
	if (dflag) {
d298 1
a298 1
	snprintf(rpath, sizeof(rpath), "%s/%s%s",
d300 5
d373 1
a373 1
	if (dflag && (utimes(rpath, ts) == -1))
@


1.26
log
@sync command synopsis w/ man page;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.25 2005/07/25 12:05:43 xsa Exp $	*/
d317 1
a317 1
	if (rcs_rev_add(rf, rev, cvs_msg, stamp) < 0) {
d334 1
a334 1
	if (rcs_rev_add(rf, rev, cvs_msg, stamp) < 0) {
@


1.25
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.24 2005/07/15 12:24:50 xsa Exp $	*/
d62 3
a64 3
	"[-d] [-b branch] [-I ign] [-k subst] [-m msg] repository "
	"vendor-tag release-tags ...",
	"b:dI:k:m:",
@


1.24
log
@- use cvs_path_cat() where appropriate instead of snprintf()
- handle a -Q case
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.23 2005/05/31 08:58:48 xsa Exp $	*/
d41 1
a41 1
#define CVS_IMPORT_DEFBRANCH    "1.1.1"
d44 7
a50 7
static int cvs_import_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_import_pre_exec (struct cvsroot *);
static int cvs_import_pre_exec (struct cvsroot *);
static int cvs_import_post_exec(struct cvsroot *);
static int cvs_import_remote   (CVSFILE *, void *);
static int cvs_import_local    (CVSFILE *, void *);
static int cvs_import_cleanup  (void);
@


1.23
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.22 2005/05/26 03:14:21 jfb Exp $	*/
d141 1
d145 5
a149 2
		snprintf(repodir, sizeof(repodir), "%s/%s", root->cr_dir,
		    module);
d178 3
a180 2
		cvs_printf("\n%s conflicts created by this import\n\n",
		    conflicts == 0 ? "No" : buf);
d194 1
a194 2
	int len;
	size_t sz;
d200 3
a202 4
	len = snprintf(repo, sizeof(repo), "%s/%s", root->cr_dir, module);
	if (len == -1 || len >= (int)sizeof(repo)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", repo);
a203 1
	}
d211 3
a213 5
			len = snprintf(repodir, sizeof(repodir), "%s/%s",
			    repo, fpath);
			if (len == -1 || len >= (int)sizeof(repodir)) {
				errno = ENAMETOOLONG;
				cvs_log(LP_ERRNO, "%s", repodir);
a214 1
			}
d243 1
a243 1
	int len;
d254 3
a256 4
	len = snprintf(repo, sizeof(repo), "%s/%s", root->cr_dir, module);
	if (len == -1 || len >= (int)sizeof(repo)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", repo);
a257 1
	}
d265 2
a266 5
			len = snprintf(rpath, sizeof(rpath), "%s/%s",
			    repo, fpath);
			if (len == -1 || len >= (int)sizeof(rpath)) {
				errno = ENAMETOOLONG;
				cvs_log(LP_ERRNO, "%s", rpath);
a267 1
			}
@


1.22
log
@remove the trailing \n from the ctime() timestamp
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.21 2005/05/26 03:10:01 jfb Exp $	*/
d33 1
a34 1
#include <string.h>
d36 1
a37 2
#include "file.h"
#include "cvs.h"
@


1.21
log
@send the Checkin-time request along with the file's timestamp when
running in client mode with the -d flag.  The timestamp format is
the same as ctime(3), as opposed to GNU CVS, which uses Yet
Another Timestamp Format to make this more complicated...
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.20 2005/05/26 02:35:13 jfb Exp $	*/
d191 1
d228 3
@


1.20
log
@fix remaining issues with regards to branch numbering and add the
vendor tag to the list of symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.19 2005/05/26 00:51:36 jfb Exp $	*/
d193 1
a193 1
	char repo[MAXPATHLEN];
d225 5
@


1.19
log
@support the -b option in local mode as well and rearrange the branch
code a bit to get rid of an annoying global.  Also remove a memory
leak by adding a cleanup handler and print the number of conflicts
created while importing
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.18 2005/05/25 21:47:19 jfb Exp $	*/
d315 1
a315 2
	/* first add the magic 1.1.1.1 revision */
	rev = rcsnum_parse("1.1.1.1");
d332 1
a332 3
	rcsnum_free(rev);

	rev = rcsnum_parse(RCS_HEAD_INIT);
d352 8
@


1.18
log
@support the -d flag in local mode (GNU CVS ignores that flag and even
kills a linux box regardless of the size of the import)
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.17 2005/05/25 09:25:48 jfb Exp $	*/
d44 1
d47 2
d51 1
d54 4
a57 2
static RCSNUM *bnum;
static char *branch, *module, *vendor, *release;
d72 2
a73 2
	NULL,
	NULL,
a81 2
	branch = CVS_IMPORT_DEFBRANCH;

d85 1
a85 2
			branch = optarg;
			if ((bnum = rcsnum_parse(branch)) == NULL) {
d87 1
a87 1
				    branch);
a89 1
			rcsnum_free(bnum);
a116 1

d120 6
d142 1
a142 1
	char repodir[MAXPATHLEN];
d152 2
d155 1
a155 1
		    (cvs_sendarg(root, branch, 0) < 0) ||
d166 16
d352 1
a352 2
#if 0
	if (rcs_branch_set(rf, rev) < 0) {
a356 1
#endif
d365 8
@


1.17
log
@when importing a file in local mode, add the first two revisions
and set the head to revision 1.1
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.16 2005/05/24 04:21:54 jfb Exp $	*/
d49 1
d90 1
d140 4
a143 1
		mkdir(repodir, 0700);
a207 5

/*
 * cvs_import_local()
 *
 */
d212 1
a212 1
	struct cvsroot *root;
d215 3
d253 18
d285 1
a285 1
		cvs_log(LP_ERR, "failed to set RCS comment leader: %s",
d287 1
d292 1
a292 1
	if (rcs_rev_add(rf, rev, cvs_msg) < 0) {
d299 9
d311 1
a311 1
	if (rcs_rev_add(rf, rev, cvs_msg) < 0) {
d327 9
d337 3
@


1.16
log
@remove debugging messages
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.15 2005/05/24 04:12:25 jfb Exp $	*/
a122 2
	cvs_msg = "test\n";
#if 0
a125 1
#endif
d214 1
d216 1
d257 37
@


1.15
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.14 2005/05/20 20:00:53 joris Exp $	*/
a253 1
	printf("importing file in %s\n", rpath);
@


1.14
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.13 2005/04/25 16:29:41 jfb Exp $	*/
d28 1
a28 1
#include <sys/queue.h>
a29 2
#include <err.h>
#include <dirent.h>
d44 4
a47 3
int cvs_import_options(char *, int, char **, int *);
int cvs_import_sendflags(struct cvsroot *);
int cvs_import_file(CVSFILE *, void *);
d52 8
a59 5
struct cvs_cmd_info cvs_import = {
	cvs_import_options,
	cvs_import_sendflags,
	cvs_import_file,
	NULL, NULL,
d61 6
a66 1
	CVS_REQ_IMPORT,
d70 2
a71 2
int
cvs_import_options(char *opt, int argc, char **argv, int *arg)
d77 1
a77 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
a112 1
	*arg = optind;
d114 1
a114 1
	if (argc > 4)
d121 4
d128 1
d133 2
a134 2
int
cvs_import_sendflags(struct cvsroot *root)
d136 15
a150 7
	if ((cvs_sendarg(root, "-b", 0) < 0) ||
	    (cvs_sendarg(root, branch, 0) < 0) ||
	    (cvs_logmsg_send(root, cvs_msg) < 0) ||
	    (cvs_sendarg(root, module, 0) < 0) ||
	    (cvs_sendarg(root, vendor, 0) < 0) ||
	    (cvs_sendarg(root, release, 0) < 0))
		return (CVS_EX_PROTO);
d156 1
a156 1
 * cvs_import_file()
d160 2
a161 2
int
cvs_import_file(CVSFILE *cfp, void *arg)
d163 1
a163 1
	int l;
d168 3
a170 3
	root = CVS_DIR_ROOT(cfp);
	l = snprintf(repo, sizeof(repo), "%s/%s", root->cr_dir, module);
	if (l == -1 || l >= (int)sizeof(repo)) {
d176 1
a176 2
	cvs_file_getpath(cfp, fpath, sizeof(fpath));
	printf("Importing %s\n", fpath);
d178 2
a179 2
	if (cfp->cf_type == DT_DIR) {
		if (!strcmp(CVS_FILE_NAME(cfp), "."))
d182 1
a182 1
			l = snprintf(repodir, sizeof(repodir), "%s/%s",
d184 1
a184 1
			if (l == -1 || l >= (int)sizeof(repodir)) {
d190 56
a245 7
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cvs_sendreq(root, CVS_REQ_DIRECTORY, fpath) < 0)
				return (CVS_EX_PROTO);
			if (cvs_sendln(root, repodir) < 0)
				return (CVS_EX_PROTO);
		} else {
			/* create the directory */
d251 8
a258 7
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_sendreq(root, CVS_REQ_MODIFIED, CVS_FILE_NAME(cfp)) < 0)
			return (CVS_EX_PROTO);
		if (cvs_sendfile(root, fpath) < 0)
			return (CVS_EX_PROTO);
	} else {
		/* local import */
d261 3
a263 1
	return (0);
@


1.13
log
@set the default branch to 1.1.1 upon import, and remove a stray
cvs_connect() call

ok joris, xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.12 2005/04/16 20:05:05 xsa Exp $	*/
d144 1
a144 1
	int ret, l;
d154 1
a154 1
		return (-1);
d169 1
a169 1
				return (-1);
d173 4
a176 3
			ret = cvs_sendreq(root, CVS_REQ_DIRECTORY, fpath);
			if (ret == 0)
				ret = cvs_sendln(root, repodir);
@


1.12
log
@more snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.11 2005/04/12 14:58:40 joris Exp $	*/
d68 2
d125 1
a125 2
	if ((cvs_connect(root) < 0) ||
	    (cvs_sendarg(root, "-b", 0) < 0) ||
@


1.11
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.10 2005/04/11 18:02:58 joris Exp $	*/
d143 1
a143 1
	int ret;
d149 6
a154 1
	snprintf(repo, sizeof(repo), "%s/%s", root->cr_dir, module);
d162 9
a170 2
		else
			snprintf(repodir, sizeof(repodir), "%s/%s", repo, fpath);
@


1.10
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.9 2005/04/11 17:56:27 joris Exp $	*/
d75 1
a75 1
				return (1);
d85 1
a85 1
				return (1);
d94 1
a94 1
				return (-1);
d98 1
a98 1
			return (1);
d107 1
a107 1
		return (1);
d115 1
a115 1
		return (-1);
d130 1
a130 1
		return (-1);
d172 1
a172 1
			return (-1);
d174 1
a174 1
			return (-1);
@


1.9
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.8 2005/04/03 17:32:50 xsa Exp $	*/
a36 1
#include <sysexits.h>
@


1.8
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.7 2005/03/30 17:43:04 joris Exp $	*/
d76 1
a76 1
				return (EX_USAGE);
d86 1
a86 1
				return (EX_USAGE);
d99 1
a99 1
			return (EX_USAGE);
d108 1
a108 1
		return (EX_USAGE);
@


1.7
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.6 2005/03/05 18:43:55 joris Exp $	*/
d95 1
a95 1
				return (EX_DATAERR);
d131 1
a131 1
		return (EX_PROTOCOL);
@


1.6
log
@

free bnum when we are done using it, also use rcsnum_parse() instead
of our own combination of rcsnum_alloc() and rcsnum_aton().

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.5 2005/02/28 20:18:02 joris Exp $	*/
d47 3
d51 2
d54 9
a62 2
int cvs_import_file(CVSFILE *, void *);
char repo[MAXPATHLEN];
a63 5
/*
 * cvs_import()
 *
 * Handler for the `cvs import' command.
 */
d65 1
a65 1
cvs_import(int argc, char **argv)
d67 1
a67 7
	int ch, flags;
	char *branch;
	struct cvsroot *root;
	RCSNUM *bnum;

	branch = CVS_IMPORT_DEFBRANCH;
	flags = CF_RECURSE | CF_IGNORE | CF_NOSYMS;
d69 1
a69 1
	while ((ch = getopt(argc, argv, "b:dI:k:m:")) != -1) {
d105 2
d110 3
a112 12
	cvs_files = cvs_file_get(".", flags);
	if (cvs_files == NULL)
		return (EX_DATAERR);

	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
d118 2
a119 10
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if ((cvs_connect(root) < 0) ||
		    (cvs_sendarg(root, "-b", 0) < 0) ||
		    (cvs_sendarg(root, branch, 0) < 0) ||
		    (cvs_logmsg_send(root, cvs_msg) < 0) ||
		    (cvs_sendarg(root, argv[0], 0) < 0) ||
		    (cvs_sendarg(root, argv[1], 0) < 0) ||
		    (cvs_sendarg(root, argv[2], 0) < 0))
			return (EX_PROTOCOL);
	}
d121 11
a131 8
	snprintf(repo, sizeof(repo), "%s/%s", root->cr_dir, argv[0]);
	cvs_file_examine(cvs_files, cvs_import_file, NULL);

	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0 ||
		    cvs_sendreq(root, CVS_REQ_IMPORT, NULL) < 0)
			return (EX_PROTOCOL);
	}
d147 1
d150 1
@


1.5
log
@

update my email address.
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.4 2005/01/13 18:47:31 jfb Exp $	*/
d61 1
a61 1
	char *branch, *ep;
d72 1
a72 4
			if ((bnum = rcsnum_alloc()) == NULL)
				return (-1);
			if ((rcsnum_aton(branch, &ep, bnum) < 0) ||
			    (*ep != '\0')) {
d77 1
@


1.4
log
@more widespread use of cvs_msg, and free it when we are done

diff by Joris Vink and me
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.3 2005/01/06 19:56:38 jfb Exp $	*/
d3 1
a3 1
 * Copyright (c) 2004 Joris Vink <amni@@pandora.be>
@


1.3
log
@Improved and working import code from Joris Vink with modifications
from me (client mode only for the moment)
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.2 2004/12/07 17:10:56 tedu Exp $	*/
d93 5
a97 1
			cvs_msg = optarg;
@


1.2
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: import.c,v 1.1 2004/11/09 20:46:02 krapht Exp $	*/
a38 1
#include "cvs.h"
d41 1
d44 7
a50 3
static int do_import(struct cvsroot *, char **);
static int cvs_import_dir(struct cvsroot *, char *, char *);
static int cvs_import_file(struct cvsroot *, CVSFILE *);
d61 1
a61 1
	char *repo, *vendor, *release;
d63 1
d65 2
a66 1
	flags = CF_IGNORE|CF_NOSYMS;
d71 10
d110 6
a115 7
	if (root->cr_method != CVS_METHOD_LOCAL) {
		cvs_connect(root);

		/* Do it */
		do_import(root, argv);

		cvs_disconnect(root);
d118 3
a120 2
	return (0);
}
d122 9
a130 12
/*
 * Import a module using a server
 */
static int
do_import(struct cvsroot *root, char **argv)
{
	char repository[MAXPATHLEN];

	/* XXX temporary */
	if (cvs_sendarg(root, "-m testlog", 0) < 0) {
		cvs_log(LP_ERR, "failed to send temporary logmessage");
		return (-1);
d133 2
a134 7
	/* send arguments */
	if (cvs_sendarg(root, argv[0], 0) < 0 ||
	    cvs_sendarg(root, argv[1], 0) < 0 ||
	    cvs_sendarg(root, argv[2], 0) < 0) {
		cvs_log(LP_ERR, "failed to send arguments");
		return (-1);
	}
d136 4
a139 8
	/* create the repository name */
	snprintf(repository, sizeof(repository), "%s/%s",
	    root->cr_dir, argv[0]);

	cvs_files = cvs_file_get(".", 0);
	if (cvs_files == NULL) {
		cvs_log(LP_ERR, "failed to obtain info on root");
		return (-1);
a141 13
	/* walk the root directory */
	cvs_import_dir(root, ".", repository);

	/* send import request */
	if (cvs_senddir(root, cvs_files) < 0 ||
	    cvs_sendraw(root, repository, strlen(repository) < 0 ||
	    cvs_sendraw(root, "\n", 1) < 0 ||
	    cvs_sendreq(root, CVS_REQ_IMPORT, NULL) < 0))
		cvs_log(LP_ERR, "failed to import repository %s",
		    repository);


	/* done */
d145 7
a151 2
static int
cvs_import_dir(struct cvsroot *root, char *dirname, char *repo)
d153 3
a155 15
	char *cwd;
	char *basedir;
	char cvsdir[MAXPATHLEN];
	CVSFILE *parent, *fp;

	if ((basedir = strrchr(dirname, '/')) != NULL)
		basedir++;
	else
		basedir = dirname;

	/* save current directory */
	if ((cwd = getcwd(NULL, MAXPATHLEN)) == NULL) {
		cvs_log(LP_ERR, "couldn't save current directory");
		return (-1);
	}
d157 1
a157 5
	/* Switch to the new directory */
	if (chdir(basedir) < 0) {
		cvs_log(LP_ERR, "failed to switch to directory %s", dirname);
		return (-1);
	}
d159 2
a160 11
	if (!strcmp(dirname, "."))
		strlcpy(cvsdir, repo, sizeof(cvsdir));
	else
		snprintf(cvsdir, sizeof(cvsdir), "%s/%s", repo, dirname);

	/* Obtain information about the directory */
	parent = cvs_file_get(".", CF_SORT|CF_RECURSE|CF_IGNORE);
	if (parent == NULL) {
		cvs_log(LP_ERR, "couldn't obtain info on %s", dirname);
		return (-1);
	}
d162 12
a173 4
	if (cvs_sendreq(root, CVS_REQ_DIRECTORY, dirname) < 0 ||
	    cvs_sendraw(root, cvsdir, strlen(cvsdir)) < 0 ||
	    cvs_sendraw(root, "\n", 1) < 0)
		return (-1);
d175 1
a175 33
	printf("Importing %s\n", dirname);

	/* Walk the directory */
	TAILQ_FOREACH(fp, &(parent->cf_ddat->cd_files), cf_list) {
		/* If we have a sub directory, skip it for now */
		if (fp->cf_type == DT_DIR)
			continue;

		/* Import the file */
		if (cvs_import_file(root, fp) < 0)
#if 0
			cvs_log(LP_ERR, "failed to import %s", fp->cf_path);
#else
			cvs_log(LP_ERR, "failed to import %s", NULL);
#endif
	}

	/* Walk the subdirectories */
	TAILQ_FOREACH(fp, &(parent->cf_ddat->cd_files), cf_list) {
		if (fp->cf_type != DT_DIR)
			continue;
		if (!strcmp(CVS_FILE_NAME(fp), ".") ||
		    !strcmp(CVS_FILE_NAME(fp), ".."))
			continue;

		if (strcmp(dirname, "."))
			snprintf(cvsdir, sizeof(cvsdir), "%s/%s",
			    dirname, CVS_FILE_NAME(fp));
		else
			strlcpy(cvsdir, CVS_FILE_NAME(fp), sizeof(cvsdir));
		if (cvs_import_dir(root, cvsdir, repo) < 0)
			cvs_log(LP_ERR, "failed to import directory %s",
			    CVS_FILE_NAME(fp));
d178 7
a184 6
	cvs_file_free(parent);

	/* restore working directory */
	if (chdir(cwd) < 0) {
		cvs_log(LP_ERR, "failed to restore directory %s", cwd);
		return (-1);
a185 17

	return (0);
}

/*
 * Import a file
 */
static int
cvs_import_file(struct cvsroot *root, CVSFILE *fp)
{
	/* Send a Modified response follwed by the
	 * file's mode, length and contents
	 */
	if (cvs_sendreq(root, CVS_REQ_MODIFIED, CVS_FILE_NAME(fp)) < 0)
		return (-1);
	if (cvs_sendfile(root, CVS_FILE_NAME(fp)) < 0)
		return (-1);
@


1.1
log
@import code from Joris Vink <amni at pandora dot be>
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 1
a125 1
 		return (-1);
@
