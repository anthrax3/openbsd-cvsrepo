head	1.176;
access;
symbols
	OPENBSD_6_2:1.176.0.4
	OPENBSD_6_2_BASE:1.176
	OPENBSD_6_1:1.174.0.4
	OPENBSD_6_1_BASE:1.174
	OPENBSD_6_0:1.171.0.4
	OPENBSD_6_0_BASE:1.171
	OPENBSD_5_9:1.171.0.2
	OPENBSD_5_9_BASE:1.171
	OPENBSD_5_8:1.170.0.6
	OPENBSD_5_8_BASE:1.170
	OPENBSD_5_7:1.170.0.2
	OPENBSD_5_7_BASE:1.170
	OPENBSD_5_6:1.168.0.6
	OPENBSD_5_6_BASE:1.168
	OPENBSD_5_5:1.168.0.4
	OPENBSD_5_5_BASE:1.168
	OPENBSD_5_4:1.167.0.6
	OPENBSD_5_4_BASE:1.167
	OPENBSD_5_3:1.167.0.4
	OPENBSD_5_3_BASE:1.167
	OPENBSD_5_2:1.167.0.2
	OPENBSD_5_2_BASE:1.167
	OPENBSD_5_1_BASE:1.166
	OPENBSD_5_1:1.166.0.6
	OPENBSD_5_0:1.166.0.4
	OPENBSD_5_0_BASE:1.166
	OPENBSD_4_9:1.166.0.2
	OPENBSD_4_9_BASE:1.166
	OPENBSD_4_8:1.163.0.2
	OPENBSD_4_8_BASE:1.163
	OPENBSD_4_7:1.160.0.2
	OPENBSD_4_7_BASE:1.160
	OPENBSD_4_6:1.160.0.4
	OPENBSD_4_6_BASE:1.160
	OPENBSD_4_5:1.157.0.2
	OPENBSD_4_5_BASE:1.157
	OPENBSD_4_4:1.156.0.2
	OPENBSD_4_4_BASE:1.156
	OPENBSD_4_3:1.135.0.2
	OPENBSD_4_3_BASE:1.135
	OPENBSD_4_2:1.105.0.2
	OPENBSD_4_2_BASE:1.105
	OPENBSD_4_1:1.97.0.2
	OPENBSD_4_1_BASE:1.97
	OPENBSD_4_0:1.80.0.2
	OPENBSD_4_0_BASE:1.80
	OPENBSD_3_9:1.54.0.2
	OPENBSD_3_9_BASE:1.54
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.176
date	2017.06.01.08.08.24;	author joris;	state Exp;
branches;
next	1.175;
commitid	oZyV6E3g0wglnhaw;

1.175
date	2017.05.29.17.18.56;	author joris;	state Exp;
branches;
next	1.174;
commitid	Vylfj0jmxC3phlRF;

1.174
date	2016.10.15.22.20.17;	author millert;	state Exp;
branches;
next	1.173;
commitid	bZGHsljlW6kmRYub;

1.173
date	2016.10.14.20.37.07;	author fcambus;	state Exp;
branches;
next	1.172;
commitid	VOBFsMEOyzG9E7Uu;

1.172
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.171;
commitid	8Vv7d4HkmCtExfc6;

1.171
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.170;
commitid	O6jeJ0TRmiewrqMI;

1.170
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.169;
commitid	DTQbfd4poqBW8iSJ;

1.169
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.168;
commitid	Uu5nFG3wCl0LACBb;

1.168
date	2013.12.13.15.19.41;	author zhuk;	state Exp;
branches;
next	1.167;

1.167
date	2012.07.02.21.56.25;	author tedu;	state Exp;
branches;
next	1.166;

1.166
date	2010.10.28.15.02.41;	author millert;	state Exp;
branches;
next	1.165;

1.165
date	2010.10.27.08.35.45;	author tobias;	state Exp;
branches;
next	1.164;

1.164
date	2010.09.29.18.14.52;	author nicm;	state Exp;
branches;
next	1.163;

1.163
date	2010.07.30.21.47.18;	author ray;	state Exp;
branches;
next	1.162;

1.162
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.161;

1.161
date	2010.07.13.21.33.44;	author nicm;	state Exp;
branches;
next	1.160;

1.160
date	2009.03.24.17.03.32;	author joris;	state Exp;
branches;
next	1.159;

1.159
date	2009.03.23.07.40.30;	author joris;	state Exp;
branches;
next	1.158;

1.158
date	2009.03.21.11.16.28;	author joris;	state Exp;
branches;
next	1.157;

1.157
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.156;

1.156
date	2008.06.28.13.10.02;	author joris;	state Exp;
branches;
next	1.155;

1.155
date	2008.06.19.19.04.59;	author tobias;	state Exp;
branches;
next	1.154;

1.154
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.153;

1.153
date	2008.06.14.03.58.29;	author tobias;	state Exp;
branches;
next	1.152;

1.152
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.151;

1.151
date	2008.06.12.07.16.14;	author joris;	state Exp;
branches;
next	1.150;

1.150
date	2008.06.11.19.10.02;	author joris;	state Exp;
branches;
next	1.149;

1.149
date	2008.06.09.23.54.27;	author joris;	state Exp;
branches;
next	1.148;

1.148
date	2008.06.09.22.31.24;	author tobias;	state Exp;
branches;
next	1.147;

1.147
date	2008.06.08.16.32.34;	author tobias;	state Exp;
branches;
next	1.146;

1.146
date	2008.05.30.16.14.34;	author tobias;	state Exp;
branches;
next	1.145;

1.145
date	2008.05.23.09.46.45;	author tobias;	state Exp;
branches;
next	1.144;

1.144
date	2008.05.22.15.46.30;	author tobias;	state Exp;
branches;
next	1.143;

1.143
date	2008.05.22.15.45.01;	author tobias;	state Exp;
branches;
next	1.142;

1.142
date	2008.03.09.15.43.55;	author joris;	state Exp;
branches;
next	1.141;

1.141
date	2008.03.09.14.28.21;	author joris;	state Exp;
branches;
next	1.140;

1.140
date	2008.03.09.13.01.22;	author joris;	state Exp;
branches;
next	1.139;

1.139
date	2008.03.09.01.02.38;	author tobias;	state Exp;
branches;
next	1.138;

1.138
date	2008.03.08.22.54.58;	author joris;	state Exp;
branches;
next	1.137;

1.137
date	2008.03.08.22.33.03;	author joris;	state Exp;
branches;
next	1.136;

1.136
date	2008.03.08.20.26.34;	author joris;	state Exp;
branches;
next	1.135;

1.135
date	2008.03.02.19.05.34;	author tobias;	state Exp;
branches;
next	1.134;

1.134
date	2008.03.01.22.35.44;	author joris;	state Exp;
branches;
next	1.133;

1.133
date	2008.02.28.21.55.48;	author tobias;	state Exp;
branches;
next	1.132;

1.132
date	2008.02.11.20.33.11;	author tobias;	state Exp;
branches;
next	1.131;

1.131
date	2008.02.10.10.21.42;	author joris;	state Exp;
branches;
next	1.130;

1.130
date	2008.02.10.10.10.15;	author joris;	state Exp;
branches;
next	1.129;

1.129
date	2008.02.09.20.04.00;	author xsa;	state Exp;
branches;
next	1.128;

1.128
date	2008.02.09.17.52.32;	author joris;	state Exp;
branches;
next	1.127;

1.127
date	2008.02.09.17.01.43;	author tobias;	state Exp;
branches;
next	1.126;

1.126
date	2008.02.09.13.09.33;	author joris;	state Exp;
branches;
next	1.125;

1.125
date	2008.02.09.12.48.23;	author joris;	state Exp;
branches;
next	1.124;

1.124
date	2008.02.09.12.20.33;	author tobias;	state Exp;
branches;
next	1.123;

1.123
date	2008.02.09.11.40.43;	author joris;	state Exp;
branches;
next	1.122;

1.122
date	2008.02.08.21.44.32;	author joris;	state Exp;
branches;
next	1.121;

1.121
date	2008.02.06.12.42.46;	author tobias;	state Exp;
branches;
next	1.120;

1.120
date	2008.02.04.18.23.58;	author tobias;	state Exp;
branches;
next	1.119;

1.119
date	2008.02.04.15.07.33;	author tobias;	state Exp;
branches;
next	1.118;

1.118
date	2008.02.03.15.20.10;	author tobias;	state Exp;
branches;
next	1.117;

1.117
date	2008.01.31.18.09.40;	author tobias;	state Exp;
branches;
next	1.116;

1.116
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.115;

1.115
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.114;

1.114
date	2008.01.21.16.36.46;	author tobias;	state Exp;
branches;
next	1.113;

1.113
date	2008.01.10.10.08.22;	author tobias;	state Exp;
branches;
next	1.112;

1.112
date	2007.09.23.11.19.24;	author joris;	state Exp;
branches;
next	1.111;

1.111
date	2007.09.23.10.49.49;	author joris;	state Exp;
branches;
next	1.110;

1.110
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.109;

1.109
date	2007.09.07.23.59.01;	author tobias;	state Exp;
branches;
next	1.108;

1.108
date	2007.09.07.23.05.04;	author joris;	state Exp;
branches;
next	1.107;

1.107
date	2007.09.04.17.57.41;	author tobias;	state Exp;
branches;
next	1.106;

1.106
date	2007.08.23.13.11.14;	author joris;	state Exp;
branches;
next	1.105;

1.105
date	2007.07.05.23.03.32;	author joris;	state Exp;
branches;
next	1.104;

1.104
date	2007.07.03.13.22.43;	author joris;	state Exp;
branches;
next	1.103;

1.103
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.102;

1.102
date	2007.06.28.04.54.11;	author joris;	state Exp;
branches;
next	1.101;

1.101
date	2007.06.27.03.58.16;	author joris;	state Exp;
branches;
next	1.100;

1.100
date	2007.06.18.17.54.13;	author joris;	state Exp;
branches;
next	1.99;

1.99
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.98;

1.98
date	2007.05.27.21.02.23;	author ray;	state Exp;
branches;
next	1.97;

1.97
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.96;

1.96
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.95;

1.95
date	2007.02.09.16.46.26;	author joris;	state Exp;
branches;
next	1.94;

1.94
date	2007.02.09.08.00.37;	author xsa;	state Exp;
branches;
next	1.93;

1.93
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2007.01.31.21.07.36;	author xsa;	state Exp;
branches;
next	1.91;

1.91
date	2007.01.28.23.37.29;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2007.01.28.02.04.45;	author joris;	state Exp;
branches;
next	1.89;

1.89
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.88;

1.88
date	2007.01.23.16.42.19;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2007.01.18.09.26.19;	author xsa;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.17.17.54.50;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2007.01.13.15.45.59;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.83;

1.83
date	2007.01.11.17.44.18;	author niallo;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.81;

1.81
date	2006.12.07.09.14.16;	author xsa;	state Exp;
branches;
next	1.80;

1.80
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.79;

1.79
date	2006.07.03.07.09.35;	author xsa;	state Exp;
branches;
next	1.78;

1.78
date	2006.07.02.21.01.48;	author joris;	state Exp;
branches;
next	1.77;

1.77
date	2006.07.01.21.09.36;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2006.07.01.20.30.46;	author reyk;	state Exp;
branches;
next	1.75;

1.75
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.74;

1.74
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.73;

1.73
date	2006.06.14.15.17.54;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2006.06.14.14.10.50;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2006.06.06.05.13.39;	author joris;	state Exp;
branches;
next	1.70;

1.70
date	2006.06.03.19.07.13;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.31.22.25.59;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.30.21.32.52;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.28.17.25.18;	author joris;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.28.07.56.44;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.28.01.24.28;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.27.21.20.52;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.27.16.10.01;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.27.15.53.01;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.27.15.14.27;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.27.05.20.25;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.27.03.30.31;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2006.04.10.08.08.00;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.16.09.06.19;	author xsa;	state Exp;
branches;
next	1.55;

1.55
date	2006.03.14.15.59.06;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.27.15.26.38;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.06.16.41.15;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.06.16.34.47;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.30.16.42.13;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.22.14.59.54;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.03.15.31.53;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.03.13.00.00;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.03.01.02.09;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2005.08.08.11.37.41;	author xsa;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.27.16.42.19;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.23.11.19.46;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.21.11.42.24;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.14.06.50.50;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.30.16.47.19;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.30.16.37.29;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.17.08.40.42;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.30.08.27.03;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.29.16.36.54;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.26.03.07.20;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.24.04.21.54;	author jfb;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.20.18.26.49;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.27.04.42.40;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.19.00.55.07;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.19.00.38.39;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.16.20.31.18;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.27.00.22.08;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.22.23.31.13;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.04.17.50.20;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.13.07.04.16;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.21.18.32.10;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.14.22.30.48;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.06.21.03.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.27.15.55.31;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.12.18.02.18;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.12.17.48.18;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.30.20.55.35;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.30.01.49.24;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.29.18.32.46;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.29.17.39.12;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.176
log
@Stop looking at current_cvsroot->cr_method to figure out if we're remote or not.

Instead use cvsroot_is_local() and cvsroot_is_remote().
@
text
@/*	$OpenBSD: update.c,v 1.175 2017/05/29 17:18:56 joris Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cvs.h"
#include "diff.h"
#include "remote.h"

int	prune_dirs = 0;
int	print_stdout = 0;
int	build_dirs = 0;
int	reset_option = 0;
int	reset_tag = 0;
int 	backup_local_changes = 0;
char *cvs_specified_tag = NULL;
char *cvs_join_rev1 = NULL;
char *cvs_join_rev2 = NULL;

static char *koptstr;
static char *dateflag = NULL;
static int Aflag = 0;

static void update_clear_conflict(struct cvs_file *);
static void update_join_file(struct cvs_file *);

extern CVSENTRIES *current_list;

struct cvs_cmd cvs_cmd_update = {
	CVS_OP_UPDATE, CVS_USE_WDIR, "update",
	{ "up", "upd" },
	"Bring work tree in sync with repository",
	"[-ACdflPpR] [-D date | -r rev] [-I ign] [-j rev] [-k mode] "
	"[-t id] ...",
	"ACD:dfI:j:k:lPpQqRr:t:u",
	NULL,
	cvs_update
};

int
cvs_update(int argc, char **argv)
{
	int ch;
	char *arg = ".";
	int flags;
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;

	while ((ch = getopt(argc, argv, cvs_cmd_update.cmd_opts)) != -1) {
		switch (ch) {
		case 'A':
			Aflag = 1;
			if (koptstr == NULL)
				reset_option = 1;
			if (cvs_specified_tag == NULL)
				reset_tag = 1;
			break;
		case 'C':
			backup_local_changes = 1;
			break;
		case 'D':
			dateflag = optarg;
			if ((cvs_specified_date = date_parse(dateflag)) == -1)
				fatal("invalid date: %s", dateflag);
			reset_tag = 0;
			break;
		case 'd':
			build_dirs = 1;
			break;
		case 'f':
			break;
		case 'I':
			break;
		case 'j':
			if (cvs_join_rev1 == NULL)
				cvs_join_rev1 = optarg;
			else if (cvs_join_rev2 == NULL)
				cvs_join_rev2 = optarg;
			else
				fatal("too many -j options");
			break;
		case 'k':
			reset_option = 0;
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				fatal("%s", cvs_cmd_update.cmd_synopsis);
			}
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'P':
			prune_dirs = 1;
			break;
		case 'p':
			print_stdout = 1;
			cvs_noexec = 1;
			break;
		case 'Q':
		case 'q':
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		case 'r':
			reset_tag = 0;
			cvs_specified_tag = optarg;
			break;
		case 'u':
			break;
		default:
			fatal("%s", cvs_cmd_update.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (cvsroot_is_local()) {
		cr.enterdir = cvs_update_enterdir;
		cr.leavedir = prune_dirs ? cvs_update_leavedir : NULL;
		cr.fileproc = cvs_update_local;
		flags |= CR_REPO;
	} else {
		cvs_client_connect_to_server();
		if (Aflag)
			cvs_client_send_request("Argument -A");
		if (dateflag != NULL)
			cvs_client_send_request("Argument -D%s", dateflag);
		if (build_dirs)
			cvs_client_send_request("Argument -d");
		if (kflag)
			cvs_client_send_request("Argument -k%s", koptstr);
		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");
		if (prune_dirs)
			cvs_client_send_request("Argument -P");
		if (print_stdout)
			cvs_client_send_request("Argument -p");

		if (cvs_specified_tag != NULL)
			cvs_client_send_request("Argument -r%s",
			    cvs_specified_tag);

		cr.enterdir = NULL;
		cr.leavedir = NULL;
		cr.fileproc = cvs_client_sendfile;
	}

	cr.flags = flags;

	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);

	if (cvsroot_is_remote()) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("update");
		cvs_client_get_responses();
	}

	return (0);
}

void
cvs_update_enterdir(struct cvs_file *cf)
{
	CVSENTRIES *entlist;
	char *dirtag, *entry, fpath[PATH_MAX];

	cvs_log(LP_TRACE, "cvs_update_enterdir(%s)", cf->file_path);

	cvs_file_classify(cf, NULL);

	if (cf->file_status == DIR_CREATE && build_dirs == 1) {
		cvs_parse_tagfile(cf->file_wd, &dirtag, NULL, NULL);
		cvs_mkpath(cf->file_path, cvs_specified_tag != NULL ?
		    cvs_specified_tag : dirtag);
		free(dirtag);

		if ((cf->fd = open(cf->file_path, O_RDONLY)) == -1)
			fatal("cvs_update_enterdir: `%s': %s",
			    cf->file_path, strerror(errno));

		if (cvs_server_active == 1 && cvs_cmdop != CVS_OP_CHECKOUT)
			cvs_server_clear_sticky(cf->file_path);

		if (cvs_cmdop != CVS_OP_EXPORT) {
			(void)xasprintf(&entry, "D/%s////", cf->file_name);

			entlist = cvs_ent_open(cf->file_wd);
			cvs_ent_add(entlist, entry);
			free(entry);
		}
	} else if ((cf->file_status == DIR_CREATE && build_dirs == 0) ||
		    cf->file_status == FILE_UNKNOWN) {
		cf->file_status = FILE_SKIP;
	} else if (reset_tag) {
		(void)xsnprintf(fpath, PATH_MAX, "%s/%s",
		    cf->file_path, CVS_PATH_TAG);
		(void)unlink(fpath);
	} else {
		if (cvs_specified_tag != NULL || cvs_specified_date != -1)
			cvs_write_tagfile(cf->file_path,
				    cvs_specified_tag, NULL);
	}
}

void
cvs_update_leavedir(struct cvs_file *cf)
{
	int nbytes;
	int isempty;
	size_t bufsize;
	struct stat st;
	struct dirent *dp;
	char *buf, *ebuf, *cp;
	CVSENTRIES *entlist;

	cvs_log(LP_TRACE, "cvs_update_leavedir(%s)", cf->file_path);

	if (cvs_server_active == 1 && !strcmp(cf->file_name, "."))
		return;

	entlist = cvs_ent_open(cf->file_path);
	if (!TAILQ_EMPTY(&(entlist->cef_ent))) {
		isempty = 0;
		goto prune_it;
	}

	if (fstat(cf->fd, &st) == -1)
		fatal("cvs_update_leavedir: %s", strerror(errno));

	if ((uintmax_t)st.st_size > SIZE_MAX)
		fatal("cvs_update_leavedir: %s: file size too big",
		    cf->file_name);

	bufsize = (st.st_size > st.st_blksize) ? st.st_size : st.st_blksize;

	isempty = 1;
	buf = xmalloc(bufsize);

	if (lseek(cf->fd, 0, SEEK_SET) == -1)
		fatal("cvs_update_leavedir: %s", strerror(errno));

	while ((nbytes = getdents(cf->fd, buf, bufsize)) > 0) {
		ebuf = buf + nbytes;
		cp = buf;

		while (cp < ebuf) {
			dp = (struct dirent *)cp;
			if (!strcmp(dp->d_name, ".") ||
			    !strcmp(dp->d_name, "..") ||
			    dp->d_fileno == 0) {
				cp += dp->d_reclen;
				continue;
			}

			if (strcmp(dp->d_name, CVS_PATH_CVSDIR)) 
				isempty = 0;

			if (isempty == 0)
				break;

			cp += dp->d_reclen;
		}
	}

	if (nbytes == -1)
		fatal("cvs_update_leavedir: %s", strerror(errno));

	free(buf);

prune_it:
	if ((isempty == 1 && prune_dirs == 1) ||
	    (cvs_server_active == 1 && cvs_cmdop == CVS_OP_CHECKOUT)) {
		/* XXX */
		cvs_rmdir(cf->file_path);

		if (cvs_server_active == 0 && cvs_cmdop != CVS_OP_EXPORT) {
			entlist = cvs_ent_open(cf->file_wd);
			cvs_ent_remove(entlist, cf->file_name);
		}
	}
}

void
cvs_update_local(struct cvs_file *cf)
{
	CVSENTRIES *entlist;
	int ent_kflag, rcs_kflag, ret, flags;
	char *tag, rbuf[CVS_REV_BUFSZ];

	cvs_log(LP_TRACE, "cvs_update_local(%s)", cf->file_path);

	if (cf->file_type == CVS_DIR) {
		if (cf->file_status == FILE_SKIP) {
			if (cvs_cmdop == CVS_OP_EXPORT && verbosity > 0)
				cvs_printf("? %s\n", cf->file_path);
			return;
		}

		if (cf->file_status != FILE_UNKNOWN &&
		    verbosity > 1)
			cvs_log(LP_ERR, "Updating %s", cf->file_path);
		return;
	}

	flags = 0;
	if (cvs_specified_tag != NULL)
		tag = cvs_specified_tag;
	else
		tag = cvs_directory_tag;

	cvs_file_classify(cf, tag);

	if (kflag && cf->file_rcs != NULL)
		rcs_kwexp_set(cf->file_rcs, kflag);

	if ((cf->file_status == FILE_UPTODATE ||
	    cf->file_status == FILE_MODIFIED) && cf->file_ent != NULL &&
	    cf->file_ent->ce_tag != NULL && reset_tag) {
		if (cf->file_status == FILE_MODIFIED)
			cf->file_status = FILE_MERGE;
		else
			cf->file_status = FILE_CHECKOUT;

		if ((cf->file_rcsrev = rcs_head_get(cf->file_rcs)) == NULL)
			fatal("no head revision in RCS file for %s",
			    cf->file_path);

		/* might be a bit overkill */
		if (cvs_server_active == 1)
			cvs_server_clear_sticky(cf->file_wd);
	}

	if (print_stdout) {
		if (cf->file_status != FILE_UNKNOWN && cf->file_rcs != NULL &&
		    cf->file_rcsrev != NULL && !cf->file_rcs->rf_dead &&
		    (cf->file_flags & FILE_HAS_TAG)) {
			rcsnum_tostr(cf->file_rcsrev, rbuf, sizeof(rbuf));
			if (verbosity > 1) {
				cvs_log(LP_RCS, RCS_DIFF_DIV);
				cvs_log(LP_RCS, "Checking out %s",
				    cf->file_path);
				cvs_log(LP_RCS, "RCS:  %s", cf->file_rpath);
				cvs_log(LP_RCS, "VERS: %s", rbuf);
				cvs_log(LP_RCS, "***************");
			}
			cvs_checkout_file(cf, cf->file_rcsrev, tag, CO_DUMP);
		}
		return;
	}

	if (cf->file_ent != NULL) {
		if (cf->file_ent->ce_opts == NULL) {
			if (kflag)
				cf->file_status = FILE_CHECKOUT;
		} else if (cf->file_rcs != NULL) {
			if (strlen(cf->file_ent->ce_opts) < 3)
				fatal("malformed option for file %s",
				    cf->file_path);

			ent_kflag = rcs_kflag_get(cf->file_ent->ce_opts + 2);
			rcs_kflag = rcs_kwexp_get(cf->file_rcs);

			if ((kflag && (kflag != ent_kflag)) ||
			    (reset_option && (ent_kflag != rcs_kflag)))
				cf->file_status = FILE_CHECKOUT;
		}
	}

	switch (cf->file_status) {
	case FILE_UNKNOWN:
		cvs_printf("? %s\n", cf->file_path);
		break;
	case FILE_MODIFIED:
		if (backup_local_changes) {
			cvs_backup_file(cf);

			cvs_checkout_file(cf, cf->file_rcsrev, NULL, flags);
			cvs_printf("U %s\n", cf->file_path);
		} else {
			ret = update_has_conflict_markers(cf);
			if (cf->file_ent->ce_conflict != NULL && ret == 1)
				cvs_printf("C %s\n", cf->file_path);
			else {
				if (cf->file_ent->ce_conflict != NULL && ret == 0)
					update_clear_conflict(cf);
				cvs_printf("M %s\n", cf->file_path);
			}
		}
		break;
	case FILE_ADDED:
		cvs_printf("A %s\n", cf->file_path);
		break;
	case FILE_REMOVED:
		cvs_printf("R %s\n", cf->file_path);
		break;
	case FILE_CONFLICT:
		cvs_printf("C %s\n", cf->file_path);
		break;
	case FILE_LOST:
	case FILE_CHECKOUT:
	case FILE_PATCH:
		if (!reset_tag && (tag != NULL || cvs_specified_date != -1 ||
		    cvs_directory_date != -1 || (cf->file_ent != NULL &&
		    cf->file_ent->ce_tag != NULL)))
			flags = CO_SETSTICKY;

		if (cf->file_flags & FILE_ON_DISK && (cf->file_ent == NULL ||
		    cf->file_ent->ce_type == CVS_ENT_NONE)) {
			cvs_log(LP_ERR, "move away %s; it is in the way",
			    cf->file_path);
			cvs_printf("C %s\n", cf->file_path);
		} else {
			cvs_checkout_file(cf, cf->file_rcsrev, tag, flags);
			cvs_printf("U %s\n", cf->file_path);
			cvs_history_add(CVS_HISTORY_UPDATE_CO, cf, NULL);
		}
		break;
	case FILE_MERGE:
		d3rev1 = cf->file_ent->ce_rev;
		d3rev2 = cf->file_rcsrev;
		cvs_checkout_file(cf, cf->file_rcsrev, tag, CO_MERGE);

		if (diff3_conflicts != 0) {
			cvs_printf("C %s\n", cf->file_path);
			cvs_history_add(CVS_HISTORY_UPDATE_MERGED_ERR,
			    cf, NULL);
		} else {
			update_clear_conflict(cf);
			cvs_printf("M %s\n", cf->file_path);
			cvs_history_add(CVS_HISTORY_UPDATE_MERGED, cf, NULL);
		}
		break;
	case FILE_UNLINK:
		(void)unlink(cf->file_path);
	case FILE_REMOVE_ENTRY:
		entlist = cvs_ent_open(cf->file_wd);
		cvs_ent_remove(entlist, cf->file_name);
		cvs_history_add(CVS_HISTORY_UPDATE_REMOVE, cf, NULL);

		if (cvs_server_active == 1)
			cvs_checkout_file(cf, cf->file_rcsrev, tag, CO_REMOVE);
		break;
	case FILE_UPTODATE:
		if (cvs_cmdop != CVS_OP_UPDATE)
			break;

		if (reset_tag != 1 && reset_option != 1 &&
		    cvs_specified_tag == NULL && cvs_specified_date == -1)
			break;

		if (cf->file_rcs->rf_dead != 1 &&
		    (cf->file_flags & FILE_HAS_TAG))
			cvs_checkout_file(cf, cf->file_rcsrev,
			    tag, CO_SETSTICKY);
		break;
	default:
		break;
	}

	if (cvs_join_rev1 != NULL)
		update_join_file(cf);
}

static void
update_clear_conflict(struct cvs_file *cf)
{
	CVSENTRIES *entlist;
	char *entry, revbuf[CVS_REV_BUFSZ];
	char sticky[CVS_ENT_MAXLINELEN], opt[4];

	cvs_log(LP_TRACE, "update_clear_conflict(%s)", cf->file_path);

	rcsnum_tostr(cf->file_rcsrev, revbuf, sizeof(revbuf));

	sticky[0] = '\0';
	if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL)
		(void)xsnprintf(sticky, sizeof(sticky), "T%s",
		    cf->file_ent->ce_tag);

	opt[0] = '\0';
	if (cf->file_ent != NULL && cf->file_ent->ce_opts != NULL)
		strlcpy(opt, cf->file_ent->ce_opts, sizeof(opt));

	entry = xmalloc(CVS_ENT_MAXLINELEN);
	cvs_ent_line_str(cf->file_name, revbuf, "Result of merge",
	    opt[0] != '\0' ? opt : "", sticky, 0, 0,
	    entry, CVS_ENT_MAXLINELEN);

	entlist = cvs_ent_open(cf->file_wd);
	cvs_ent_add(entlist, entry);
	free(entry);
}

/*
 * XXX - this is the way GNU cvs checks for outstanding conflicts
 * in a file after a merge. It is a very very bad approach and
 * should be looked at once opencvs is working decently.
 */
int
update_has_conflict_markers(struct cvs_file *cf)
{
	BUF *bp;
	int conflict;
	char *content;
	struct rcs_line *lp;
	struct rcs_lines *lines;
	size_t len;

	cvs_log(LP_TRACE, "update_has_conflict_markers(%s)", cf->file_path);

	if (!(cf->file_flags & FILE_ON_DISK) || cf->file_ent == NULL)
		return (0);

	bp = buf_load_fd(cf->fd);

	buf_putc(bp, '\0');
	len = buf_len(bp);
	content = buf_release(bp);
	if ((lines = cvs_splitlines(content, len)) == NULL)
		fatal("update_has_conflict_markers: failed to split lines");

	conflict = 0;
	TAILQ_FOREACH(lp, &(lines->l_lines), l_list) {
		if (lp->l_line == NULL)
			continue;

		if (!strncmp(lp->l_line, RCS_CONFLICT_MARKER1,
		    sizeof(RCS_CONFLICT_MARKER1) - 1) ||
		    !strncmp(lp->l_line, RCS_CONFLICT_MARKER2,
		    sizeof(RCS_CONFLICT_MARKER2) - 1) ||
		    !strncmp(lp->l_line, RCS_CONFLICT_MARKER3,
		    sizeof(RCS_CONFLICT_MARKER3) - 1)) {
			conflict = 1;
			break;
		}
	}

	cvs_freelines(lines);
	free(content);
	return (conflict);
}

void
update_join_file(struct cvs_file *cf)
{
	time_t told;
	RCSNUM *rev1, *rev2;
	const char *state1, *state2;
	char rbuf[CVS_REV_BUFSZ], *jrev1, *jrev2, *p;

	rev1 = rev2 = NULL;
	jrev1 = jrev2 = NULL;

	jrev1 = xstrdup(cvs_join_rev1);
	if (cvs_join_rev2 != NULL)
		jrev2 = xstrdup(cvs_join_rev2);

	if (jrev2 == NULL) {
		jrev2 = jrev1;
		jrev1 = NULL;
	}

	told = cvs_specified_date;

	if ((p = strchr(jrev2, ':')) != NULL) {
		(*p++) = '\0';
		if ((cvs_specified_date = date_parse(p)) == -1) {
			cvs_printf("invalid date: %s", p);
			goto out;
		}
	}

	rev2 = rcs_translate_tag(jrev2, cf->file_rcs);
	cvs_specified_date = told;

	if (jrev1 != NULL) {
		if ((p = strchr(jrev1, ':')) != NULL) {
			(*p++) = '\0';
			if ((cvs_specified_date = date_parse(p)) == -1) {
				cvs_printf("invalid date: %s", p);
				goto out;
			}
		}

		rev1 = rcs_translate_tag(jrev1, cf->file_rcs);
		cvs_specified_date = told;
	} else {
		if (rev2 == NULL)
			goto out;

		rev1 = rcsnum_alloc();
		rcsnum_cpy(cf->file_rcsrev, rev1, 0);
	}

	state1 = state2 = RCS_STATE_DEAD;

	if (rev1 != NULL)
		state1 = rcs_state_get(cf->file_rcs, rev1);
	if (rev2 != NULL)
		state2 = rcs_state_get(cf->file_rcs, rev2);

	if (rev2 == NULL || !strcmp(state2, RCS_STATE_DEAD)) {
		if (rev1 == NULL || !strcmp(state1, RCS_STATE_DEAD))
			goto out;

		if (cf->file_status == FILE_REMOVED ||
		    cf->file_rcs->rf_dead == 1)
			goto out;

		if (cf->file_status == FILE_MODIFIED ||
		    cf->file_status == FILE_ADDED)
			goto out;

		(void)unlink(cf->file_path);
		(void)close(cf->fd);
		cf->fd = -1;
		cvs_remove_local(cf);
		goto out;
	}

	if (cf->file_ent != NULL) {
		if (!rcsnum_cmp(cf->file_ent->ce_rev, rev2, 0))
			goto out;
	}

	if (cf->file_rcsrev == NULL) {
		cvs_printf("non-mergable file: %s has no head revision!\n",
		    cf->file_path);
		goto out;
	}

	if (rev1 == NULL || !strcmp(state1, RCS_STATE_DEAD)) {
		if (cf->file_flags & FILE_ON_DISK) {
			cvs_printf("%s exists but has been added in %s\n",
			    cf->file_path, jrev2);
		} else {
			cvs_printf("A %s\n", cf->file_path);
			cvs_checkout_file(cf, cf->file_rcsrev, NULL, 0);
			cvs_add_local(cf);
		}
		goto out;
	}

	if (!rcsnum_cmp(rev1, rev2, 0))
		goto out;

	if (!(cf->file_flags & FILE_ON_DISK)) {
		cvs_printf("%s does not exist but is present in %s\n",
		    cf->file_path, jrev2);
		goto out;
	}

	if (rcs_kwexp_get(cf->file_rcs) & RCS_KWEXP_NONE) {
		cvs_printf("non-mergable file: %s needs merge!\n",
		    cf->file_path);
		goto out;
	}

	cvs_printf("joining ");
	rcsnum_tostr(rev1, rbuf, sizeof(rbuf));
	cvs_printf("%s ", rbuf);

	rcsnum_tostr(rev2, rbuf, sizeof(rbuf));
	cvs_printf("%s ", rbuf);

	rcsnum_tostr(cf->file_rcsrev, rbuf, sizeof(rbuf));
	cvs_printf("into %s (%s)\n", cf->file_path, rbuf);

	d3rev1 = rev1;
	d3rev2 = rev2;
	cvs_checkout_file(cf, cf->file_rcsrev, NULL, CO_MERGE);

	if (diff3_conflicts == 0)
		update_clear_conflict(cf);

out:
	free(rev1);
	free(rev2);
	free(jrev1);
	free(jrev2);
}

void
cvs_backup_file(struct cvs_file *cf)
{
	char	 backup_name[PATH_MAX];
	char	 revstr[RCSNUM_MAXSTR];

	if (cf->file_status == FILE_ADDED)
		(void)xsnprintf(revstr, sizeof(revstr), "0");
	else
		rcsnum_tostr(cf->file_ent->ce_rev, revstr, sizeof(revstr));

	(void)xsnprintf(backup_name, PATH_MAX, "%s/.#%s.%s",
	    cf->file_wd, cf->file_name, revstr);

	cvs_file_copy(cf->file_path, backup_name);

	(void)xsnprintf(backup_name, PATH_MAX, ".#%s.%s",
	    cf->file_name, revstr);
	cvs_printf("(Locally modified %s moved to %s)\n",
		   cf->file_name, backup_name);
}
@


1.175
log
@cvs_file_classify() was making the mistake of only taking over a sticky
tag from Entries for a given file if the sticky tag is present.

while changing this we can simplify some logic in update.c on how it
decides what tag to use for file classification.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.174 2016/10/15 22:20:17 millert Exp $	*/
d145 1
a145 1
	if (current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
d183 1
a183 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
@


1.174
log
@Quiet compiler warnings.  OK tomc@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.173 2016/10/14 20:37:07 fcambus Exp $	*/
a339 2
	else if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL)
		tag = cf->file_ent->ce_tag;
@


1.173
log
@Fix update -r and -A.

In certain cases update -r and update -A would not properly set or reset
the sticky tag for file(s).

From Joris Vink.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.172 2016/10/13 20:51:25 fcambus Exp $	*/
d262 1
a262 5
	bufsize = st.st_size;
	if (bufsize < st.st_blksize)
		bufsize = st.st_blksize;

	if (st.st_size > SIZE_MAX)
d265 2
@


1.172
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.171 2015/11/05 09:48:21 nicm Exp $	*/
d483 2
a484 4
		if (reset_tag != 1 && reset_option != 1)
			break;

		if (cf->file_ent != NULL && cf->file_ent->ce_tag == NULL)
@


1.171
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.170 2015/02/05 12:59:57 millert Exp $	*/
d715 2
a716 5
	if (rev1 != NULL)
		rcsnum_free(rev1);
	if (rev2 != NULL)
		rcsnum_free(rev2);

@


1.170
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.169 2015/01/16 06:40:07 deraadt Exp $	*/
d24 1
d207 1
a207 2
		if (dirtag != NULL)
			xfree(dirtag);
d221 1
a221 1
			xfree(entry);
d302 1
a302 1
	xfree(buf);
d529 1
a529 1
	xfree(entry);
d577 1
a577 1
	xfree(content);
d720 2
a721 4
	if (jrev1 != NULL)
		xfree(jrev1);
	if (jrev2 != NULL)
		xfree(jrev2);
@


1.169
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.168 2013/12/13 15:19:41 zhuk Exp $	*/
d23 1
@


1.168
log
@Make it compile again. And there is a time_t fix as a bonus!

Input and okay jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.167 2012/07/02 21:56:25 tedu Exp $	*/
d195 1
a195 1
	char *dirtag, *entry, fpath[MAXPATHLEN];
d226 1
a226 1
		(void)xsnprintf(fpath, MAXPATHLEN, "%s/%s",
d728 1
a728 1
	char	 backup_name[MAXPATHLEN];
d736 1
a736 1
	(void)xsnprintf(backup_name, MAXPATHLEN, "%s/.#%s.%s",
d741 1
a741 1
	(void)xsnprintf(backup_name, MAXPATHLEN, ".#%s.%s",
@


1.167
log
@simplify rcsnum parsing by using a fixed array without all the realloc
ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.166 2010/10/28 15:02:41 millert Exp $	*/
d20 1
a238 1
	off_t base;
d275 1
a275 1
	while ((nbytes = getdirentries(cf->fd, buf, bufsize, &base)) > 0) {
@


1.166
log
@Change basep parameter of getdirentries() to be off_t *, not long *
so it works correctly with large offsets (and matches other systems).
This requires adding a new getdirentries syscall, with the old one
renamed to ogetdirentries.  All in-tree consumers of getdirentries()
have been updated.  Bump libc and libpthread major numbers.
OK and with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.165 2010/10/27 08:35:45 tobias Exp $	*/
d729 1
a729 1
	char	 revstr[RCSNUM_MAXLEN];
d732 1
a732 1
		(void)xsnprintf(revstr, RCSNUM_MAXLEN, "0");
d734 1
a734 1
		rcsnum_tostr(cf->file_ent->ce_rev, revstr, RCSNUM_MAXLEN);
@


1.165
log
@Merge -k and expand @@@@ parsing code between OpenCVS and OpenRCS, resulting
in a performance gain in OpenCVS in some "cvs update" scenarios.

ok zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.164 2010/09/29 18:14:52 nicm Exp $	*/
d238 1
a238 1
	long base;
@


1.164
log
@Support for update -C, from zinovik.

ok tobias xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.163 2010/07/30 21:47:18 ray Exp $	*/
a582 1
	int flag;
d690 1
a690 2
	flag = rcs_kwexp_get(cf->file_rcs);
	if (flag & RCS_KWEXP_NONE) {
@


1.163
log
@Check date_parse return values.

OK xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.162 2010/07/23 21:46:05 ray Exp $	*/
d34 1
d79 1
d409 5
a413 3
		ret = update_has_conflict_markers(cf);
		if (cf->file_ent->ce_conflict != NULL && ret == 1) {
			cvs_printf("C %s\n", cf->file_path);
d415 8
a422 3
			if (cf->file_ent->ce_conflict != NULL && ret == 0)
				update_clear_conflict(cf);
			cvs_printf("M %s\n", cf->file_path);
d725 22
@


1.162
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.161 2010/07/13 21:33:44 nicm Exp $	*/
d81 2
a82 1
			cvs_specified_date = date_parse(dateflag);
d596 4
a599 1
		cvs_specified_date = date_parse(p);
d608 4
a611 1
			cvs_specified_date = date_parse(p);
@


1.161
log
@Don't silently overwrite untracked local files with newly-added
repository files.

slightly earlier version ok zinovik xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.160 2009/03/24 17:03:32 joris Exp $	*/
d81 1
a81 1
			cvs_specified_date = cvs_date_parse(dateflag);
d532 2
a533 2
	struct cvs_line *lp;
	struct cvs_lines *lines;
d541 1
a541 1
	bp = cvs_buf_load_fd(cf->fd);
d543 3
a545 3
	cvs_buf_putc(bp, '\0');
	len = cvs_buf_len(bp);
	content = cvs_buf_release(bp);
d595 1
a595 1
		cvs_specified_date = cvs_date_parse(p);
d604 1
a604 1
			cvs_specified_date = cvs_date_parse(p);
@


1.160
log
@shuffle code a bit so FILE_REMOVE_ENTRY also calls
cvs_checkout_file() with CO_REMOVE set otherwise our server
would never inform the client the entry should be removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.159 2009/03/23 07:40:30 joris Exp $	*/
d432 10
a441 3
		cvs_checkout_file(cf, cf->file_rcsrev, tag, flags);
		cvs_printf("U %s\n", cf->file_path);
		cvs_history_add(CVS_HISTORY_UPDATE_CO, cf, NULL);
@


1.159
log
@LP_NOTICE should be LP_ERR when showing directory messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.158 2009/03/21 11:16:28 joris Exp $	*/
a452 2
		if (cvs_server_active == 1)
			cvs_checkout_file(cf, cf->file_rcsrev, tag, CO_REMOVE);
d457 3
@


1.158
log
@be smarter when checking if a directory is empty by looking at
CVS/Entries early on in cvs_update_leavedir()
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.157 2009/02/21 14:50:53 joris Exp $	*/
d331 1
a331 1
			cvs_log(LP_NOTICE, "Updating %s", cf->file_path);
@


1.157
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.156 2008/06/28 13:10:02 joris Exp $	*/
d249 6
d285 1
a285 5
			if (!strcmp(dp->d_name, CVS_PATH_CVSDIR)) {
				entlist = cvs_ent_open(cf->file_path);
				if (!TAILQ_EMPTY(&(entlist->cef_ent)))
					isempty = 0;
			} else {
a286 1
			}
d300 1
@


1.156
log
@if the user supplied -A only checkout files again if a sticky tag
was in fact set, instead of ALWAYS checking them out no matter what.

spotted & diff tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.155 2008/06/19 19:04:59 tobias Exp $	*/
d528 1
a528 1
	if (cf->fd == -1 || cf->file_ent == NULL)
d645 1
a645 1
		if (cf->fd != -1) {
d659 1
a659 1
	if (cf->fd == -1) {
@


1.155
log
@If checkout/update -p is requested with a specific tag for a file which
doesn't contain this tag, don't print head.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.154 2008/06/14 04:34:08 tobias Exp $	*/
d462 1
a462 1
		if (cf->file_rcsrev == NULL)
d465 1
a465 3
		if (tag == NULL && cvs_specified_date == -1 &&
		    cvs_directory_date == -1 && !reset_tag &&
		    !reset_option)
@


1.154
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.153 2008/06/14 03:58:29 tobias Exp $	*/
d365 2
a366 1
		    cf->file_rcsrev != NULL && !cf->file_rcs->rf_dead) {
@


1.153
log
@Added support for sticky date set in CVS/Tag and CVS/Entries per directory.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.152 2008/06/14 03:19:15 joris Exp $	*/
d354 3
a356 1
		cf->file_rcsrev = rcs_head_get(cf->file_rcs);
d363 13
a375 9
	if (print_stdout && cf->file_status != FILE_UNKNOWN &&
	    !cf->file_rcs->rf_dead) {
		rcsnum_tostr(cf->file_rcsrev, rbuf, sizeof(rbuf));
		if (verbosity > 1) {
			cvs_log(LP_RCS, RCS_DIFF_DIV);
			cvs_log(LP_RCS, "Checking out %s", cf->file_path);
			cvs_log(LP_RCS, "RCS:  %s", cf->file_rpath);
			cvs_log(LP_RCS, "VERS: %s", rbuf);
			cvs_log(LP_RCS, "***************");
a376 1
		cvs_checkout_file(cf, cf->file_rcsrev, tag, CO_DUMP);
d384 1
a384 1
		} else {
d637 6
@


1.152
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.151 2008/06/12 07:16:14 joris Exp $	*/
d82 1
d419 3
a421 3
		if ((tag != NULL && !reset_tag) || cvs_specified_date != -1 ||
		    (((cf->file_ent != NULL) && cf->file_ent->ce_tag != NULL) &&
		    !reset_tag))
d459 3
a461 1
		if (tag == NULL && cvs_specified_date == -1)
@


1.151
log
@completely kill the need for TMP_DIR when running checkout,
which gives us better performance among other things.

this is however disabled in a few cases:
1) whenever you run checkout over an existing tree (which acts as update)
2) whenever you specify -d or a module alias

we're planning on enabling this behaviour for case 2 in the future.

anoncvs sysadmins now love us even more.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.150 2008/06/11 19:10:02 joris Exp $	*/
d45 2
a214 1
			cvs_ent_close(entlist, ENT_SYNC);
a281 2

				cvs_ent_close(entlist, ENT_NOSYNC);
a305 1
			cvs_ent_close(entlist, ENT_SYNC);
a448 1
		cvs_ent_close(entlist, ENT_SYNC);
a500 1
	cvs_ent_close(entlist, ENT_SYNC);
@


1.150
log
@cleanup our junk when in server mode and running as checkout every
time we descend into another directory, leaves even less crap in /tmp
while running.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.149 2008/06/09 23:54:27 joris Exp $	*/
d255 2
a256 1
		fatal("cvs_update_leavedir: %s: file size too big", cf->file_name);
d299 2
a300 2
	if ((isempty == 1 && prune_dirs == 1) || (cvs_server_active == 1 &&
	    cvs_cmdop == CVS_OP_CHECKOUT)) {
@


1.149
log
@unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.148 2008/06/09 22:31:24 tobias Exp $	*/
d298 2
a299 1
	if (isempty == 1 && prune_dirs == 1) {
@


1.148
log
@Properly handle merged files and conflicts which may arrise while merge.
Instead of ignoring all files which contain possible conflict markers,
only watch out for files which have actually been merged.

With input by and ok joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.147 2008/06/08 16:32:34 tobias Exp $	*/
a477 1
	time_t now;
@


1.147
log
@Don't check a file for conflict markers if it has no CVS/Entries entry.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.146 2008/05/30 16:14:34 tobias Exp $	*/
d480 1
a480 1
	char *entry, revbuf[CVS_REV_BUFSZ], timebuf[CVS_TIME_BUFSZ];
a484 4
	time(&now);
	ctime_r(&now, timebuf);
	timebuf[strcspn(timebuf, "\n")] = '\0';

d497 1
a497 1
	cvs_ent_line_str(cf->file_name, revbuf, timebuf,
@


1.146
log
@Keyword expansion must not be set if no RCS file is available, for example
a newly added but not yet committed file.  Fixes segfault.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.145 2008/05/23 09:46:45 tobias Exp $	*/
d528 1
a528 1
	if (cf->fd == -1)
@


1.145
log
@Properly pass the directory tag of parent directory into new subdirectories.

Spotted by and ok joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.144 2008/05/22 15:46:30 tobias Exp $	*/
d342 1
a342 1
	if (kflag)
@


1.144
log
@Wrong function names in fatal messages fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.143 2008/05/22 15:45:01 tobias Exp $	*/
d188 1
a188 1
	char *entry, fpath[MAXPATHLEN];
d192 1
a192 1
	cvs_file_classify(cf, cvs_directory_tag);
d195 6
a200 1
		cvs_mkpath(cf->file_path, cvs_specified_tag);
@


1.143
log
@expension -> expansion

ok joris, xsa (quite some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.142 2008/03/09 15:43:55 joris Exp $	*/
d250 1
a250 1
		fatal("cvs_buf_load_fd: %s: file size too big", cf->file_name);
@


1.142
log
@locate the first occurance of ':' in the given -j arguments
instead of the last one, otherwise we cannot properly separate
the tag from the given date (if any).
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.141 2008/03/09 14:28:21 joris Exp $	*/
d102 1
a102 1
				    "invalid RCS keyword expension mode");
@


1.141
log
@simplify logic in cvs_update_leavedir()
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.140 2008/03/09 13:01:22 joris Exp $	*/
d578 1
a578 1
	if ((p = strrchr(jrev2, ':')) != NULL) {
d587 1
a587 1
		if ((p = strrchr(jrev1, ':')) != NULL) {
@


1.140
log
@when in server mode, be sure the client picks up any new directories
if they are available if we run with -d, however do not send the
stuff when running a checkout so empty directories do not even appear
in our working copy, saves us the whole pruning trouble at the end with co.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.139 2008/03/09 01:02:38 tobias Exp $	*/
a234 2
	struct cvs_ent *ent;
	struct cvs_ent_line *line;
d273 2
a274 9
				TAILQ_FOREACH(line, &(entlist->cef_ent),
				    entries_list) {
					ent = cvs_ent_parse(line->buf);

					if (ent->ce_status == CVS_ENT_REMOVED) {
						isempty = 0;
						cvs_ent_free(ent);
						break;
					}
a275 2
					cvs_ent_free(ent);
				}
@


1.139
log
@While allocation memory, make sure that file sizes are smaller than SIZE_MAX.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.138 2008/03/08 22:54:58 joris Exp $	*/
d199 3
@


1.138
log
@do not log successfull merges in CVSROOT/history when joining.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.137 2008/03/08 22:33:03 joris Exp $	*/
d247 3
@


1.137
log
@better -j support
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.136 2008/03/08 20:26:34 joris Exp $	*/
d680 1
a680 1
	if (diff3_conflicts == 0) {
a681 2
		cvs_history_add(CVS_HISTORY_UPDATE_MERGED, cf, NULL);
	}
@


1.136
log
@add checkout/update -j support.
still has some rough edges.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.135 2008/03/02 19:05:34 tobias Exp $	*/
d641 1
a641 1
			    cf->file_path, cvs_join_rev2);
d643 1
d650 6
a655 1
	if (cf->fd == -1)
d657 1
@


1.135
log
@Print the right synopsis for commands on error (especially if commands
share the same function: (r)tag, etc.).

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.134 2008/03/01 22:35:44 joris Exp $	*/
d35 2
d43 1
d89 6
d313 1
a313 1
	char *tag;
d315 1
a315 2
	CVSENTRIES *entlist;
	char rbuf[CVS_REV_BUFSZ];
d428 2
d470 3
d481 1
a481 1
	char sticky[CVS_ENT_MAXLINELEN];
d492 1
a492 1
	if (cf->file_ent->ce_tag != NULL)
d496 4
d502 1
a502 1
	    cf->file_ent->ce_opts ? : "", sticky, 0, 0,
d558 130
@


1.134
log
@use file_rcsrev in update_clear_conflict() - this way
we will always pick up the correct revision.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.133 2008/02/28 21:55:48 tobias Exp $	*/
d94 1
a94 1
				fatal("%s", cvs_cmd_add.cmd_synopsis);
@


1.133
log
@RCS files can have a default expansion mode, keep this in mind for
update -A and -k.

spotted by and ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.132 2008/02/11 20:33:11 tobias Exp $	*/
d476 1
a476 1
	rcsnum_tostr(cf->file_ent->ce_rev, revbuf, sizeof(revbuf));
@


1.132
log
@Cleanup buf implementation:

* Don't check for NULL on buffer creation, because it calls fatal() when
  something's wrong.
* All buffers are supposed to expand if there is no space left in them,
  so zap flags as well.
* Remove code that is now dead.

OK joris@@

> Inspired by a diff from Igor Zinovik about unchecked return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.131 2008/02/10 10:21:42 joris Exp $	*/
d305 1
a305 1
	int ret, flags;
d307 1
a307 1
	char kbuf[8], rbuf[CVS_REV_BUFSZ];
d371 9
a379 7
			if (kflag) {
				(void)xsnprintf(kbuf, sizeof(kbuf),
				    "-k%s", cf->file_rcs->rf_expand);

			    	if (strcmp(kbuf, cf->file_ent->ce_opts))
					cf->file_status = FILE_CHECKOUT;
			} else if (reset_option)
@


1.131
log
@properly initialize cvs_specified_date so we dont end up with
random stuff going on
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.130 2008/02/10 10:10:15 joris Exp $	*/
d512 1
a512 3
	if ((bp = cvs_buf_load_fd(cf->fd, BUF_AUTOEXT)) == NULL)
		fatal("update_has_conflict_markers: failed to load %s",
		    cf->file_path);
@


1.130
log
@parse any date tags set in CVS/Tag or CVS/Entries properly, and use
them for commands;

with tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.129 2008/02/09 20:04:00 xsa Exp $	*/
d207 1
a207 1
		if (cvs_specified_tag != NULL || cvs_specified_date != 0)
d408 1
a408 1
		if ((tag != NULL && !reset_tag) || cvs_specified_date != 0 ||
d447 1
a447 1
		if (tag == NULL && cvs_specified_date == 0)
@


1.129
log
@Introduce cvs_ent_line_str() - formats CVS/Entries lines.
OK tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.128 2008/02/09 17:52:32 joris Exp $	*/
d444 8
a451 2
		if ((tag != NULL && cf->file_rcs->rf_dead != 1 &&
		    (cf->file_flags & FILE_HAS_TAG)) || cvs_specified_date != 0)
@


1.128
log
@in cvs_update_enterdir() write the CVS/Tag file if the
cvs_specified_date is != 0 as well;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.127 2008/02/09 17:01:43 tobias Exp $	*/
d476 3
a478 3
	(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s/%s/%s",
	    cf->file_name, revbuf, timebuf, cf->file_ent->ce_opts ? : "",
	    sticky);
@


1.127
log
@Support for checkout -D extended:
Properly write CVS/Tag and CVS/Entries on various combinations of -r and -D.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.126 2008/02/09 13:09:33 joris Exp $	*/
d207 1
a207 1
		if (cvs_specified_tag != NULL)
@


1.126
log
@missing break

spotted by tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.125 2008/02/09 12:48:23 joris Exp $	*/
d408 1
a408 1
		if ((tag != NULL && !reset_tag) ||
d444 2
a445 2
		if (tag != NULL && cf->file_rcs->rf_dead != 1 &&
		    (cf->file_flags & FILE_HAS_TAG))
@


1.125
log
@remote improvements:

- make sure the client creates the correct CVS/Repository when running
  checkout if there was no -d targetdir specified.
- allow -D to work remotely for both checkout and update.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.124 2008/02/09 12:20:33 tobias Exp $	*/
d73 1
@


1.124
log
@Get in proper support for checkout/update -A when it comes to keyword
expansion options.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.123 2008/02/09 11:40:43 joris Exp $	*/
d37 1
d74 2
a75 1
			cvs_specified_date = cvs_date_parse(optarg);
d135 2
@


1.123
log
@lets do -D for update as well
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.122 2008/02/08 21:44:32 joris Exp $	*/
d32 2
a33 1
int	reset_stickies = 0;
d37 1
d65 5
a69 1
			reset_stickies = 1;
d85 1
d111 1
d131 1
a131 1
		if (reset_stickies)
d197 1
a197 1
	} else if (reset_stickies == 1) {
d334 1
a334 1
	    cf->file_ent->ce_tag != NULL && reset_stickies == 1) {
d372 1
a372 1
			} else if (reset_stickies)
d403 1
a403 1
		if ((tag != NULL && reset_stickies != 1) ||
d405 1
a405 1
		    (reset_stickies != 1)))
@


1.122
log
@do not override a specified (-r) tag with the tag in the Entries file
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.121 2008/02/06 12:42:46 tobias Exp $	*/
d67 1
a67 1
			cvs_specified_tag = optarg;
@


1.121
log
@Sticky tags must have a 'T' in front of them in CVS/Entries.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.120 2008/02/04 18:23:58 tobias Exp $	*/
d314 2
a322 3

	if (cf->file_ent != NULL && cf->file_ent->ce_tag != NULL)
		tag = cf->file_ent->ce_tag;
@


1.120
log
@Stripped off 'nb', which was (or was supposed to be) used to distinguish
between a named branch and a revision number supplied by -r.  This can
be done easier in cvs_write_tagfile directly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.119 2008/02/04 15:07:33 tobias Exp $	*/
d448 1
d458 5
d466 1
a466 1
	    cf->file_ent->ce_tag ? : "");
@


1.119
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.118 2008/02/03 15:20:10 tobias Exp $	*/
d196 1
a196 1
				    cvs_specified_tag, NULL, 0);
@


1.118
log
@cvs_update_leavedir is only useful if dirs have to be pruned.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.117 2008/01/31 18:09:40 tobias Exp $	*/
d35 2
d79 7
d127 2
d294 1
a294 1
	char rbuf[CVS_REV_BUFSZ];
d319 3
d354 16
d458 3
a460 2
	(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s//",
	    cf->file_name, revbuf, timebuf);
@


1.117
log
@During checkout -p don't print files which are in Attic if they are not
requested with -r.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.116 2008/01/31 10:15:05 tobias Exp $	*/
d109 1
a109 1
		cr.leavedir = cvs_update_leavedir;
@


1.116
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.115 2008/01/28 20:31:07 tobias Exp $	*/
d326 2
a327 1
	if (print_stdout && cf->file_status != FILE_UNKNOWN) {
@


1.115
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.114 2008/01/21 16:36:46 tobias Exp $	*/
d38 1
a38 1
	CVS_OP_UPDATE, 0, "update",
@


1.114
log
@Fixed export to be fully functional and compliant to GNU cvs in local and
remote setups.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.113 2008/01/10 10:08:22 tobias Exp $	*/
d92 1
@


1.113
log
@another strcspn() round
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.112 2007/09/23 11:19:24 joris Exp $	*/
d166 2
a167 1
		(void)xasprintf(&entry, "D/%s////", cf->file_name);
d169 5
a173 4
		entlist = cvs_ent_open(cf->file_wd);
		cvs_ent_add(entlist, entry);
		cvs_ent_close(entlist, ENT_SYNC);
		xfree(entry);
a200 1
	char export[MAXPATHLEN];
a203 12
	if (cvs_cmdop == CVS_OP_EXPORT) {
		(void)xsnprintf(export, MAXPATHLEN, "%s/%s",
		    cf->file_path, CVS_PATH_CVSDIR);

		/* XXX */
		if (cvs_rmdir(export) == -1)
			fatal("cvs_update_leavedir: %s: %s:", export,
			    strerror(errno));

		return;
	}

d268 1
a268 1
		if (cvs_server_active == 0) {
d287 3
a289 1
		if (cf->file_status == FILE_SKIP)
d291 1
@


1.112
log
@make sure when running update -r on existing files to overwrite
the sticky directory tag with it. since -r gets priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.111 2007/09/23 10:49:49 joris Exp $	*/
d429 1
a429 2
	if (timebuf[strlen(timebuf) - 1] == '\n')
		timebuf[strlen(timebuf) - 1] = '\0';
@


1.111
log
@pass FILE_HAS_FLAG towards the update code so it can identify
if a given tag is present in the RCSfile or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.110 2007/09/22 16:01:22 joris Exp $	*/
d290 1
d308 9
a316 1
	cvs_file_classify(cf, cvs_directory_tag);
d342 1
a342 1
		cvs_checkout_file(cf, cf->file_rcsrev, CO_DUMP);
d372 1
a372 1
		if (cvs_directory_tag != NULL ||
d377 1
a377 1
		cvs_checkout_file(cf, cf->file_rcsrev, flags);
d382 1
a382 1
		cvs_checkout_file(cf, cf->file_rcsrev, CO_MERGE);
d397 1
a397 1
			cvs_checkout_file(cf, cf->file_rcsrev, CO_REMOVE);
d408 1
a408 1
		if (cvs_directory_tag != NULL && cf->file_rcs->rf_dead != 1 &&
d410 2
a411 1
			cvs_checkout_file(cf, cf->file_rcsrev, CO_SETSTICKY);
@


1.110
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.109 2007/09/07 23:59:01 tobias Exp $	*/
d399 2
a400 1
		if (cvs_directory_tag != NULL && cf->file_rcs->rf_dead != 1)
@


1.109
log
@Properly send out rcs info header with "E " in server mode (stderr in
local mode). Format style change also enables opencvs to be used with
cvsweb (+ adjustment).

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.108 2007/09/07 23:05:04 joris Exp $	*/
d124 4
d158 1
a158 1
	cvs_file_classify(cf, NULL);
a182 3

		cvs_parse_tagfile(cf->file_path,
		    &cvs_specified_tag, NULL, NULL);
d307 1
a307 1
	cvs_file_classify(cf, cvs_specified_tag);
d316 1
d363 3
a365 1
		if (cvs_specified_tag != NULL)
d394 7
@


1.108
log
@Sprinkle some magic so checkout/update -p works
in both local and server mode.

OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.107 2007/09/04 17:57:41 tobias Exp $	*/
d324 7
a330 4
		if (verbosity > 1)
			cvs_printf("%s\nChecking out %s\n"
			    "RCS:\t%s\nVERS:\t%s\n***************\n",
			    RCS_DIFF_DIV, cf->file_path, cf->file_rpath, rbuf);
@


1.107
log
@Replaced strlen() with sizeof() - 1 when #define'd strings are used.

OK ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.106 2007/08/23 13:11:14 joris Exp $	*/
d30 1
a30 1
int	print = 0;
d85 1
a85 1
			print = 1;
d121 1
a121 1
		if (print)
d322 1
a322 1
	if (print && cf->file_status != FILE_UNKNOWN) {
@


1.106
log
@missing 'u' option for update caused gnu cvs client to not function
with our server mode. Unfortunatly we dont really support rcs diffs
for update just yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.105 2007/07/05 23:03:32 joris Exp $	*/
d455 1
a455 1
		    strlen(RCS_CONFLICT_MARKER1)) ||
d457 1
a457 1
		    strlen(RCS_CONFLICT_MARKER2)) ||
d459 1
a459 1
		    strlen(RCS_CONFLICT_MARKER3))) {
@


1.105
log
@fix a "Device busy" error in server mode. found by ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.104 2007/07/03 13:22:43 joris Exp $	*/
d43 1
a43 1
	"ACD:dfI:j:k:lPpQqRr:t:",
d95 2
@


1.104
log
@Rework the way opencvs works in relation to files in the Attic/:

Previously, files in the 'Attic/' were linked into our filelist as being
'Attic/filename,v' this caused unneeded stress on certain functions
like cvs_file_classify() who had to do pointer voodoo to split out
the 'Attic/' part and do other very weird stuff to normalize the pathname
of these files.

Instead, we handle these files early in the start when we
build the fileslist in cvs_repository_getdir(). When encountering
the 'Attic/' directory, we recurse in it if required but instead of
using the 'Attic/' directory component as our base directory we stick
with the directory name where 'Attic/' resides in, resulting in the
correct filename while maintaining the correct RCSpath for the file.

This made the following things a lot easier:
(and in most cases actually fixed the below points)

- status with files in Attic/.
- checking out HEAD repositories with files in Attic/.
- checking out repositories with -rTAG.
- updating with -rTAG.

and as an added bonus the following now also works:

- correctly creating CVS/Tag in both local and remote mode thus
  allowing update/status/and more to work correctly with the tagged tree.
  (thanks to the correct handling of -rTAG cases).
- resetting tags with opencvs -A properly works too now.

This is a major step forward into the usability
of OpenCVS when it comes to maintaining multiple tagged trees, the next
logical step would be to fix commiting to branches.

enjoy you -stable cowards.

tested by myself, xsa, niallo and ckuethe
thanks guys!
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.103 2007/06/28 21:38:09 xsa Exp $	*/
d211 3
@


1.103
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.102 2007/06/28 04:54:11 joris Exp $	*/
d33 1
a33 1
char *tag = NULL;
d65 1
a65 1
			tag = optarg;
d94 1
a94 1
			tag = optarg;
a146 1
	char *entry;
d148 1
d155 1
a155 1
		cvs_mkpath(cf->file_path);
d169 11
d301 1
a301 1
	cvs_file_classify(cf, tag);
d311 4
d353 1
a353 1
		if (tag != NULL)
@


1.102
log
@do not call cvs_checkout_file() for file removals in local mode,
only required in server mode due to the fact we need to let the client
now its been removed, found this the hard way.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.101 2007/06/27 03:58:16 joris Exp $	*/
d275 1
a275 1
	char rbuf[16];
d378 1
a378 1
	char *entry, revbuf[16], timebuf[32];
@


1.101
log
@We were missing the needed clue/magic to have our remote setup
handle files that have been removed from the repository
correctly, which resulted in them still being in the working copy
after doing an update.

noticed and diff tested by ckuethe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.100 2007/06/18 17:54:13 joris Exp $	*/
d360 2
a361 1
		cvs_checkout_file(cf, cf->file_rcsrev, CO_REMOVE);
@


1.100
log
@first stab at history stuff for opencvs, currently only writes
to CVSROOT/history but cannot parse it yet with the 'history' command.

"Commit it." ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.99 2007/06/01 17:47:47 niallo Exp $	*/
d360 1
@


1.99
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.98 2007/05/27 21:02:23 ray Exp $	*/
d343 1
d350 2
d355 1
d364 1
@


1.98
log
@Replace xmalloc/xsnprintf combo with xasprintf.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.97 2007/02/22 06:42:09 otto Exp $	*/
d33 1
a33 1
static char *tag = NULL;
@


1.97
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.96 2007/02/17 18:23:43 xsa Exp $	*/
d160 1
a160 3
		entry = xmalloc(CVS_ENT_MAXLINELEN);
		(void)xsnprintf(entry, CVS_ENT_MAXLINELEN, "D/%s////",
		    cf->file_name);
@


1.96
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.95 2007/02/09 16:46:26 joris Exp $	*/
d18 6
a23 1
#include "includes.h"
a25 1
#include "log.h"
@


1.95
log
@correctly skip invalid entries when using
getdirentries(2).

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.94 2007/02/09 08:00:37 xsa Exp $	*/
d188 2
a189 3
		if (cvs_path_cat(cf->file_path, CVS_PATH_CVSDIR, export,
		    MAXPATHLEN) >= MAXPATHLEN)
			fatal("cvs_update_leavedir: truncation");
@


1.94
log
@if a directory exists in the working dir but not in the
repository, mark it as to be skipped so we do not try to
lock it on update and miserably fail... OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.93 2007/02/09 03:49:15 joris Exp $	*/
d221 1
a221 1
			    dp->d_reclen == 0) {
@


1.93
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.92 2007/01/31 21:07:36 xsa Exp $	*/
d164 2
a165 1
	} else if (cf->file_status == DIR_CREATE && build_dirs == 0) {
@


1.92
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.91 2007/01/28 23:37:29 joris Exp $	*/
d148 1
a148 1
	cvs_file_classify(cf, NULL, 0);
d288 1
a288 1
	cvs_file_classify(cf, tag, 1);
@


1.91
log
@do not overwrite a file that is modified but has a sticky tag set
when running update -A, instead merge in the changes.

'kay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.90 2007/01/28 02:04:45 joris Exp $	*/
a142 1
	int l;
d157 1
a157 1
		l = snprintf(entry, CVS_ENT_MAXLINELEN, "D/%s////",
a158 2
		if (l == -1 || l >= CVS_ENT_MAXLINELEN)
			fatal("cvs_update_enterdir: overflow");
a366 1
	int l;
d381 1
a381 1
	l = snprintf(entry, CVS_ENT_MAXLINELEN, "/%s/%s/%s//",
a382 2
	if (l == -1 || l >= CVS_ENT_MAXLINELEN)
		fatal("update_clear_conflict: overflow");
@


1.90
log
@add merging support in both local and remote sides.
tested by many, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.89 2007/01/25 18:56:33 otto Exp $	*/
d293 2
a294 1
	if (cf->file_status == FILE_UPTODATE && cf->file_ent != NULL &&
d296 4
a299 1
		cf->file_status = FILE_CHECKOUT;
@


1.89
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.88 2007/01/23 16:42:19 joris Exp $	*/
a341 4
#if 0
		cvs_diff3(cf->file_rcs, cf->file_path, cf->fd,
		    cf->file_ent->ce_rev, cf->file_rcsrev, 1);

a349 1
#endif
@


1.88
log
@When acting as a server do not blindly remove
directories in cvs_update_leavedir().

fixes the "Device busy" error some people have been seeing.
problem initially reported by Frank Denis.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.87 2007/01/18 09:26:19 xsa Exp $	*/
d185 1
a185 1
	char *export;
a189 1
		export = xmalloc(MAXPATHLEN);
a198 1
		xfree(export);
@


1.87
log
@more informative error msg.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.86 2007/01/17 17:54:50 joris Exp $	*/
a188 5
	if (cvs_server_active == 1) {
		cvs_rmdir(cf->file_path);
		return;
	}

d265 5
a269 3
		entlist = cvs_ent_open(cf->file_wd);
		cvs_ent_remove(entlist, cf->file_name);
		cvs_ent_close(entlist, ENT_SYNC);
@


1.86
log
@add support for remote checkout in both our client and server,
with this the last real dependency to actually be able to use opencvs
in a remote setup has been added.

based upon an initial diff from xsa@@
'kay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.85 2007/01/13 15:45:59 joris Exp $	*/
d154 2
a155 1
			fatal("cvs_update_enterdir: %s", strerror(errno));
@


1.85
log
@remove BUF * argument from cvs_checkout_file() it will
no longer be used, ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.84 2007/01/12 23:32:01 niallo Exp $	*/
d187 5
@


1.84
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.83 2007/01/11 17:44:18 niallo Exp $	*/
a272 1
	BUF *bp;
a288 4
	/*
	 * the bp buffer will be released inside rcs_kwexp_buf,
	 * which is called from cvs_checkout_file().
	 */
a289 1
	bp = NULL;
d304 1
a304 1
		cvs_checkout_file(cf, cf->file_rcsrev, NULL, CO_DUMP);
d337 1
a337 1
		cvs_checkout_file(cf, cf->file_rcsrev, NULL, flags);
d341 1
a343 2
		if (bp == NULL)
			fatal("cvs_update_local: failed to merge");
d345 1
a345 1
		cvs_checkout_file(cf, cf->file_rcsrev, bp, CO_MERGE);
d353 1
@


1.83
log
@rework opencvs so that we can deal with binary files.  previously we assumed all files were ascii,
which broke things in real-world usage.  now a checkout of src should work, albeit using lots of
memory and cpu.  fixing this is the next step.

testing by many.
ok & some input joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.82 2007/01/11 02:35:55 joris Exp $	*/
a304 3
		bp = rcs_getrev(cf->file_rcs, cf->file_rcsrev);
		if (bp == NULL)
			fatal("cvs_update_local: failed to get HEAD");
d310 1
a310 1
		cvs_checkout_file(cf, cf->file_rcsrev, bp, CO_DUMP);
a339 4
		bp = rcs_getrev(cf->file_rcs, cf->file_rcsrev);
		if (bp == NULL)
			fatal("cvs_update_local: failed to get HEAD");

d343 1
a343 1
		cvs_checkout_file(cf, cf->file_rcsrev, bp, flags);
d347 1
a347 1
		bp = cvs_diff3(cf->file_rcs, cf->file_path, cf->fd,
@


1.82
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.81 2006/12/07 09:14:16 xsa Exp $	*/
d422 1
d434 1
d436 1
a436 1
	if ((lines = cvs_splitlines(content)) == NULL)
a438 2
	xfree(content);

d456 1
@


1.81
log
@snprintf() -> cvs_path_cat()
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.80 2006/07/07 17:37:17 joris Exp $	*/
d106 1
@


1.80
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.79 2006/07/03 07:09:35 xsa Exp $	*/
d175 1
a175 1
	int isempty, l;
d189 3
a191 4
		l = snprintf(export, MAXPATHLEN, "%s/%s", cf->file_path,
		    CVS_PATH_CVSDIR);
		if (l == -1 || l >= MAXPATHLEN)
			fatal("cvs_update_leavedir: overflow");
@


1.79
log
@-p implies -n...
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.78 2006/07/02 21:01:48 joris Exp $	*/
d23 1
a24 1
int	cvs_update(int, char **);
d52 1
a52 1
	flags = CR_REPO | CR_RECURSE_DIRS;
d100 22
a121 3
	cr.enterdir = cvs_update_enterdir;
	cr.leavedir = cvs_update_leavedir;
	cr.fileproc = cvs_update_local;
d128 7
@


1.78
log
@- abort the commit when files are not correctly up to date.
- do not try to attempt to check for conflict markers when the file is not on disk.

found by and okay reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.77 2006/07/01 21:09:36 reyk Exp $	*/
d82 1
@


1.77
log
@to be correct, cvs update -p is the "print" and not the "dump" flag.

suggested by deraadt@@, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.76 2006/07/01 20:30:46 reyk Exp $	*/
d397 3
@


1.76
log
@implement the -p (dump) flag for cvs update

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.75 2006/06/19 05:05:17 joris Exp $	*/
d26 1
a26 1
int	dump = 0;
d81 1
a81 1
			dump = 1;
d277 1
a277 1
	if (dump && cf->file_status != FILE_UNKNOWN) {
@


1.75
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.74 2006/06/16 14:07:42 joris Exp $	*/
d26 1
d81 1
d249 1
d275 13
@


1.74
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.73 2006/06/14 15:17:54 joris Exp $	*/
d99 1
a99 2
	cr.local = cvs_update_local;
	cr.remote = NULL;
@


1.73
log
@i mixed up the offset and whence variables for lseek(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.72 2006/06/14 14:10:50 joris Exp $	*/
a22 1
#include "proto.h"
d33 1
a33 1
	CVS_OP_UPDATE, CVS_REQ_UPDATE, "update",
@


1.72
log
@add cvs_buf_load_fd() which does the same as cvs_buf_load()
except it takes a decriptor as argument instead of a path.

modified cvs_buf_load() to open the descriptor then pass
it to cvs_buf_load_fd().

change all the calls to cvs_buf_load() that have a descriptor
open for the path to cvs_buf_load_fd() to prevent races.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.71 2006/06/06 05:13:39 joris Exp $	*/
d186 1
a186 1
	if (lseek(cf->fd, SEEK_SET, 0) == -1)
@


1.71
log
@add support for the -D option of update,
-D allows you to update a file to matching a specified date:

opencvs up -D "1 hour ago" foobar will take the first matching
revision that was commited 1 hour ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.70 2006/06/03 19:07:13 joris Exp $	*/
d313 1
a313 1
		bp = cvs_diff3(cf->file_rcs, cf->file_path,
d384 1
a384 1
	if ((bp = cvs_buf_load(cf->file_path, BUF_AUTOEXT)) == NULL)
@


1.70
log
@add support for update -A and update -r<rev>.
hacking on the plane from toronto to barbados.

i will probably hack some more since im stuck in barbados
for 12 lovely hours over night cause the carribean airlines dont understand
the meaning over 'more than one flight a day'.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.69 2006/05/31 22:25:59 joris Exp $	*/
d61 1
@


1.69
log
@add support for the export command.

export does exactly the same as checkout except it does
not create any administrative (CVS/) directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.68 2006/05/30 21:32:52 joris Exp $	*/
d28 2
d57 1
d87 1
a244 1
	int ret;
d246 1
d265 1
d267 7
a273 1
	cvs_file_classify(cf, NULL, 1);
d305 4
a308 1
		cvs_checkout_file(cf, cf->file_rcsrev, bp, 0);
@


1.68
log
@fill in the correct revision number we will want in file_rcsrev
for each cvs_file struct, this will help us with sticky tags,
commiting to branches and importing into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.67 2006/05/28 17:25:18 joris Exp $	*/
d143 1
a143 1
	int isempty;
d151 1
d155 16
d229 1
@


1.67
log
@several fixes to the file api:
- default to CVS_FILE when something is totally unknown
- cvs_get_repository_path() now returns the full repository path for
  the given argument.
- cvs_get_repository_name() returns the contents of CVS/Repository
  to the caller.
- allow command callbacks to specify if our recursion code needs
  to skip the directory or not.
- when checking for a admin directory, make sure it is in fact
  a directory. if it is not we dont want to recurse inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.66 2006/05/28 07:56:44 joris Exp $	*/
d116 1
a116 1
	cvs_file_classify(cf, 0);
d244 1
a244 1
	cvs_file_classify(cf, 1);
d272 1
a272 1
		bp = rcs_getrev(cf->file_rcs, cf->file_rcs->rf_head);
d276 1
a276 1
		cvs_checkout_file(cf, cf->file_rcs->rf_head, bp, 0);
d281 1
a281 1
		    cf->file_ent->ce_rev, cf->file_rcs->rf_head, 1);
d285 1
a285 1
		cvs_checkout_file(cf, cf->file_rcs->rf_head, bp, CO_MERGE);
@


1.66
log
@allow commands to shut up the output from cvs_file_classify
if the commands want to output certain stuff themselfs
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.65 2006/05/28 01:24:28 joris Exp $	*/
a30 2
#define UPDATE_SKIP	100

d134 1
a134 1
		cf->file_status = UPDATE_SKIP;
d152 2
d230 1
a230 1
		if (cf->file_status == UPDATE_SKIP)
@


1.65
log
@enable merging on update. if your file in your working copy
has been modified by yourself and there is a newer revision
we try and merge them together.

if the merge fails and has conflicts it will mark them inside
the file, you will need to resolve these by hand first before
you will be able to commit your modified file.

works transparent with gnu cvs, as it is suppose to.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.64 2006/05/27 21:20:52 joris Exp $	*/
d118 1
a118 1
	cvs_file_classify(cf);
d244 1
a244 1
	cvs_file_classify(cf);
@


1.64
log
@do not close the same entries list twice, this caused a double free;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.63 2006/05/27 16:10:01 joris Exp $	*/
d29 2
d223 2
d239 5
d251 2
a252 1
		if (cf->file_ent->ce_conflict != NULL)
d254 3
a256 1
		else
d258 1
d272 6
a277 2
		if (cvs_checkout_file(cf, cf->file_rcs->rf_head, 0))
			cvs_printf("U %s\n", cf->file_path);
d280 13
a292 1
		cvs_printf("needs merge: %s\n", cf->file_path);
d304 76
@


1.63
log
@support the -d flag for update.

if you specify -d when running update new directories will be build,
otherwise they will be skipped.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.62 2006/05/27 15:53:01 joris Exp $	*/
a186 2
						cvs_ent_close(entlist,
						    ENT_NOSYNC);
@


1.62
log
@update needs the CR_REPO flag to, otherwise it will forget
about any new files or directories inside the repository
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.61 2006/05/27 15:14:27 joris Exp $	*/
d27 3
d60 1
d118 1
a118 1
	if (cf->file_status == DIR_CREATE) {
d133 2
d228 3
@


1.61
log
@allow commands to respect the -l flag, if the -l flag is
specified certain commands will not recurse into directories.

at the same time introduce a method of specifying wether or not
a command should look in the repository for files.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.60 2006/05/27 05:20:25 joris Exp $	*/
d47 1
a47 1
	flags = CR_RECURSE_DIRS;
@


1.60
log
@pruning (-P) support for both the update and checkout commands;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.59 2006/05/27 03:30:31 joris Exp $	*/
d44 1
d47 2
d67 1
d93 1
@


1.59
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
d66 1
d86 1
a86 1
	cr.leavedir = NULL;
d124 82
@


1.58
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.57 2006/04/10 08:08:00 xsa Exp $	*/
d3 1
a3 2
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d22 1
a23 1
#include "diff.h"
d25 1
a25 4
static int	cvs_update_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_update_pre_exec(struct cvsroot *);
static int	cvs_update_remote(CVSFILE *, void *);
static int	cvs_update_local(CVSFILE *, void *);
d35 1
a35 8
	CF_SORT | CF_RECURSE | CF_IGNORE | CF_NOSYMS,
	cvs_update_init,
	cvs_update_pre_exec,
	cvs_update_remote,
	cvs_update_local,
	NULL,
	NULL,
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDARGS2 | CVS_CMD_SENDDIR
d38 2
a39 6
static char *date, *rev, *koptstr;
static int dflag, Aflag;
static int kflag = RCS_KWEXP_DEFAULT;

static int
cvs_update_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d42 2
d45 1
a45 5
	dflag = Aflag = 0;
	date = NULL;
	rev = NULL;

	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a47 1
			Aflag = 1;
a50 1
			date = optarg;
a52 1
			dflag = 1;
a60 8
			koptstr = optarg;
			kflag = rcs_kflag_get(koptstr);
			if (RCS_KWEXP_INVAL(kflag)) {
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
				rcs_kflag_usage();
				return (CVS_EX_USAGE);
			}
a62 1
			cmd->file_flags &= ~CF_RECURSE;
a64 1
			cmd->cmd_flags |= CVS_CMD_PRUNEDIRS;
a66 1
			cvs_noexec = 1;	/* no locks will be created */
a71 1
			cmd->file_flags |= CF_RECURSE;
a73 1
			rev = optarg;
d76 1
a76 1
			return (CVS_EX_USAGE);
d80 2
a81 3
	*arg = optind;
	return (0);
}
d83 4
a86 17
static int
cvs_update_pre_exec(struct cvsroot *root)
{
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_cmd_update.cmd_flags & CVS_CMD_PRUNEDIRS)
			cvs_sendarg(root, "-P", 0);

		if (Aflag == 1)
			cvs_sendarg(root, "-A", 0);

		if (dflag == 1)
			cvs_sendarg(root, "-d", 0);

		if (rev != NULL) {
			cvs_sendarg(root, "-r", 0);
			cvs_sendarg(root, rev, 0);
		}
d88 4
a91 5
		if (date != NULL) {
			cvs_sendarg(root, "-D", 0);
			cvs_sendarg(root, date, 0);
		}
	}
d96 2
a97 8
/*
 * cvs_update_remote()
 *
 * Update a single file.  In the case where we act as client, send any
 * pertinent information about that file to the server.
 */
static int
cvs_update_remote(CVSFILE *cf, void *arg)
d99 23
a121 34
	char fpath[MAXPATHLEN];
	struct cvsroot *root;

	root = CVS_DIR_ROOT(cf);

	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		else
			cvs_senddir(root, cf);
		return (0);
	}

	cvs_file_getpath(cf, fpath, sizeof(fpath));

	cvs_sendentry(root, cf);

	if (!(cf->cf_flags & CVS_FILE_ONDISK))
		return (0);

	switch (cf->cf_cvstat) {
	case CVS_FST_UNKNOWN:
		cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		break;
	case CVS_FST_UPTODATE:
		cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
		break;
	case CVS_FST_ADDED:
	case CVS_FST_MODIFIED:
		cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name);
		cvs_sendfile(root, fpath);
		break;
	default:
		break;
a122 2

	return (0);
d125 2
a126 5
/*
 * cvs_update_local()
 */
static int
cvs_update_local(CVSFILE *cf, void *arg)
d128 3
a130 18
	int islocal, revdiff;
	char fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	RCSFILE *rf;
	RCSNUM *frev;
	BUF *fbuf;

	revdiff = 0;
	rf = NULL;
	frev = NULL;
	islocal = (cvs_cmdop != CVS_OP_SERVER);

	cvs_file_getpath(cf, fpath, sizeof(fpath));

	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		if (verbosity > 1)
			cvs_printf("? %s\n", fpath);
		return (CVS_EX_OK);
	}
d132 5
a136 4
	if (cf->cf_type == DT_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Updating %s", fpath);
		return (CVS_EX_OK);
d139 1
a139 26
	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));

	/*
	 * Only open the RCS file for files that have not been added.
	 */
	if (cf->cf_cvstat != CVS_FST_ADDED) {
		rf = rcs_open(rcspath, RCS_READ);

		/*
		 * If there is no RCS file available in the repository
		 * directory that matches this file, it's gone.
		 * XXX: so what about the Attic?
		 */
		if (rf == NULL) {
			cvs_log(LP_WARN, "%s is no longer in the repository",
			    fpath);
			if (cvs_checkout_rev(NULL, NULL, cf, fpath,
			    islocal, CHECKOUT_REV_REMOVED) < 0)
				fatal("cvs_update_local: cvs_checkout_rev failed");
			return (CVS_EX_OK);
		}
	} else {
		/* There's no need to update a newly added file */
		cvs_printf("A %s\n", fpath);
		return (CVS_EX_OK);
	}
d141 3
a143 44
	/* set keyword expansion */
	/* XXX look at cf->cf_opts as well for this */
	rcs_kwexp_set(rf, kflag);

	/* fill in the correct revision */
	if (rev != NULL) {
		if ((frev = rcsnum_parse(rev)) == NULL)
			fatal("cvs_update_local: rcsnum_parse failed");
	} else
		frev = rf->rf_head;

	/*
	 * Compare the headrevision with the revision we currently have.
	 */
	if (cf->cf_lrev != NULL)
		revdiff = rcsnum_cmp(cf->cf_lrev, frev, 0);

	switch (cf->cf_cvstat) {
	case CVS_FST_MODIFIED:
		/*
		 * If the file has been modified but there is a newer version
		 * available, we try to merge it into the existing changes.
		 */
		if (revdiff == 1) {
			fbuf = cvs_diff3(rf, fpath, cf->cf_lrev, frev, 0);
			if (fbuf == NULL) {
				cvs_log(LP_ERR, "merge failed");
				break;
			}

			/*
			 * Please note fbuf will be free'd in cvs_checkout_rev
			 */
			if (cvs_checkout_rev(rf, frev, cf, fpath, islocal,
			    CHECKOUT_REV_MERGED, fbuf) != -1) {
				cvs_printf("%c %s\n",
				    (diff3_conflicts > 0) ? 'C' : 'M',
				    fpath);
				if (diff3_conflicts > 0)
					cf->cf_cvstat = CVS_FST_CONFLICT;
			}
		} else {
			cvs_printf("M %s\n", fpath);
		}
d145 5
a149 2
	case CVS_FST_REMOVED:
		cvs_printf("R %s\n", fpath);
d151 2
a152 2
	case CVS_FST_CONFLICT:
		cvs_printf("C %s\n", fpath);
d154 2
a155 6
	case CVS_FST_LOST:
		if (cvs_checkout_rev(rf, frev, cf, fpath, islocal,
		    CHECKOUT_REV_UPDATED) != -1) {
			cf->cf_cvstat = CVS_FST_UPTODATE;
			cvs_printf("U %s\n", fpath);
		}
d157 18
a174 6
	case CVS_FST_UPTODATE:
		if (revdiff == 1) {
			if (cvs_checkout_rev(rf, frev, cf, fpath, islocal,
			    CHECKOUT_REV_UPDATED) != -1)
				cvs_printf("P %s\n", fpath);
		}
a178 6

	if (frev != NULL && frev != rf->rf_head)
		rcsnum_free(frev);
	rcs_close(rf);

	return (CVS_EX_OK);
@


1.57
log
@change rcs_kwexp_set() return type to void and simplify its use. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.56 2006/03/16 09:06:19 xsa Exp $	*/
d327 1
a327 1
	if ((frev != NULL) && (frev != rf->rf_head))
@


1.56
log
@zap more unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.55 2006/03/14 15:59:06 xsa Exp $	*/
d260 1
a260 2
	if (rcs_kwexp_set(rf, kflag) < 0)
		fatal("cvs_update_local: rcs_kwexp_set failed");
@


1.55
log
@add an argument to cvs_diff3() to be able to handle verbosity of
commands; fixes rcsmerge -q  behaviour. OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.54 2006/01/27 15:26:38 xsa Exp $	*/
d206 1
a206 1
	int ret, islocal, revdiff;
a207 1
	char *repo;
a210 1
	struct cvsroot *root;
d212 1
a212 1
	revdiff = ret = 0;
a216 2
	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);
@


1.54
log
@more errors handling cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.53 2006/01/06 16:41:15 reyk Exp $	*/
d287 1
a287 1
			fbuf = cvs_diff3(rf, fpath, cf->cf_lrev, frev);
@


1.53
log
@ingore local update of newly added files. this fixes some possible
NULL pointer conditions and also removes some obsolete extra checks.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.52 2006/01/06 16:34:47 reyk Exp $	*/
d253 1
a253 1
				return (CVS_EX_FILE);
d264 2
a265 4
	if (rcs_kwexp_set(rf, kflag) < 0) {
		rcs_close(rf);
		return (CVS_EX_DATA);
	}
d269 3
a271 5
		if ((frev = rcsnum_parse(rev)) == NULL) {
			rcs_close(rf);
			return (CVS_EX_DATA);
		}
	} else {
a272 1
	}
@


1.52
log
@uninitialized pointer could confuse the cleanup check

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.51 2006/01/02 08:11:56 xsa Exp $	*/
d256 4
d265 1
a265 2
		if (rf != NULL)
			rcs_close(rf);
d272 1
a272 2
			if (rf != NULL)
				rcs_close(rf);
d282 1
a282 1
	if (rf != NULL && cf->cf_lrev != NULL)
a312 3
	case CVS_FST_ADDED:
		cvs_printf("A %s\n", fpath);
		break;
d339 1
a339 2
	if (rf != NULL)
		rcs_close(rf);
@


1.51
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.50 2005/12/30 16:42:13 xsa Exp $	*/
d216 1
@


1.50
log
@minor style nits;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.49 2005/12/30 02:03:28 joris Exp $	*/
d27 1
a27 8
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.49
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.48 2005/12/22 14:59:54 xsa Exp $	*/
d139 1
a139 1
		if (Aflag)
d142 1
a142 1
		if (dflag)
@


1.48
log
@cvs_rcs_getpath() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.47 2005/12/03 15:31:53 joris Exp $	*/
d136 18
a153 15
		if ((cvs_cmd_update.cmd_flags & CVS_CMD_PRUNEDIRS) &&
		    (cvs_sendarg(root, "-P", 0) < 0))
			return (CVS_EX_PROTO);
		if (Aflag && cvs_sendarg(root, "-A", 0) < 0)
			return (CVS_EX_PROTO);
		if (dflag && cvs_sendarg(root, "-d", 0) < 0)
			return (CVS_EX_PROTO);

		if ((rev != NULL) && ((cvs_sendarg(root, "-r", 0) < 0) ||
		    (cvs_sendarg(root, rev, 0) < 0)))
			return (CVS_EX_PROTO);

		if ((date != NULL) && ((cvs_sendarg(root, "-D", 0) < 0) ||
		    (cvs_sendarg(root, date, 0) < 0)))
			return (CVS_EX_PROTO);
a167 1
	int ret;
a170 1
	ret = 0;
d175 1
a175 2
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    cf->cf_name);
d177 2
a178 6
			ret = cvs_senddir(root, cf);

		if (ret == -1)
			ret = CVS_EX_PROTO;

		return (ret);
d183 1
a183 2
	if (cvs_sendentry(root, cf) < 0)
		return (CVS_EX_PROTO);
d190 1
a190 1
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
d193 1
a193 1
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
d197 2
a198 3
		ret = cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name);
		if (ret == 0)
			ret = cvs_sendfile(root, fpath);
d204 1
a204 4
	if (ret == -1)
		ret = CVS_EX_PROTO;

	return (ret);
@


1.47
log
@todd@@ reminds me:

If you 'vi file.c' and change stuff, then 'make depend && make' you'll
have a file.o file most definately more recent than the latest committed
version of file.c.

Then, if you rm file.c, and cvs update file.c, if 'file.c' is set to the
timestamp of the last committed version, a subsequent 'make' will not
rebuild the .o file.

to fix this we simply use the current timestamp when updating files.
thanks todd@@!
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.46 2005/12/03 13:00:00 joris Exp $	*/
a246 1

d250 1
a250 2
	if (cvs_rcs_getpath(cf, rcspath, sizeof(rcspath)) == NULL)
		return (CVS_EX_DATA);
@


1.46
log
@respect Q flag in output;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.45 2005/12/03 01:02:09 joris Exp $	*/
d339 1
a339 1
		    CHECKOUT_REV_CREATED) != -1) {
d347 1
a347 1
			    CHECKOUT_REV_CREATED) != -1)
@


1.45
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.44 2005/08/08 11:37:41 xsa Exp $	*/
d239 2
a240 1
		cvs_printf("? %s\n", fpath);
@


1.44
log
@zap unused vars;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.43 2005/07/27 16:42:19 xsa Exp $	*/
d39 1
a39 1

a45 1

d222 1
a222 1
	int ret;
d224 1
d226 3
d230 1
a230 1
	ret = 0;
d232 1
d234 2
d244 3
a246 1
		cvs_log(LP_NOTICE, "Updating %s", fpath);
d253 26
a278 3
	rf = rcs_open(rcspath, RCS_RDWR);
	if (rf == NULL) {
		printf("failed here?\n");
d282 10
a291 1
	rcs_close(rf);
d293 67
a359 1
	return (ret);
@


1.43
log
@use LP_NOTICE instead of LP_INFO where appropriate;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.42 2005/07/25 12:13:08 xsa Exp $	*/
d167 1
a167 1
	char *repo, fpath[MAXPATHLEN];
a171 1
	repo = CVS_DIR_REPO(cf);
@


1.42
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.41 2005/07/23 11:19:46 joris Exp $	*/
d239 1
a239 1
		cvs_log(LP_INFO, "Updating %s", fpath);
@


1.41
log
@rewrite of the file code. the previous one was just
a mess and not clean.
this code is much cleaner, faster, and uses less memory overall.

tested by xsa@@, brad@@, Michael Knudsen, and myself.
okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.40 2005/07/21 11:42:24 xsa Exp $	*/
d41 4
a44 4
static int cvs_update_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_update_pre_exec (struct cvsroot *);
static int cvs_update_remote    (CVSFILE *, void *);
static int cvs_update_local     (CVSFILE *, void *);
@


1.40
log
@<sys/param.h> is already included in "cvs.h", no need to duplicate;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.39 2005/07/14 06:50:50 xsa Exp $	*/
d191 3
@


1.39
log
@use cvs_rcs_getpath();
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.38 2005/07/07 14:27:57 joris Exp $	*/
a26 1
#include <sys/param.h>
@


1.38
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.37 2005/06/30 16:47:19 joris Exp $	*/
d222 2
a223 2
	int ret, l;
	char *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
a224 1
	struct cvsroot *root;
a227 2
	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);
d241 1
a241 5
	l = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, cf->cf_name, RCS_FILE_EXT);
	if (l == -1 || l >= (int)sizeof(rcspath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rcspath);
a242 1
	}
@


1.37
log
@

remove CF_KNOWN flag and move the CVS_FST_UNKNOWN check above the
one that looks if CVSFILE is a directory, so we get a correct output
of unknown files in server mode.

discussed with and ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.36 2005/06/30 16:37:29 joris Exp $	*/
d138 1
a138 1
		if ((cvs_cmd_update.cmd_flags & CVS_CMD_PRUNEDIRS) && 
@


1.36
log
@

missing method checks in pre_exec handler.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.35 2005/06/17 08:40:42 xsa Exp $	*/
d56 1
a56 1
	CF_SORT | CF_RECURSE | CF_IGNORE | CF_KNOWN | CF_NOSYMS,
d234 5
a241 5
	}

	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		cvs_printf("? %s\n", fpath);
		return (0);
@


1.35
log
@- add missing option in the command usage
- handle -k
- handle -D and send it to server

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.34 2005/05/31 08:58:48 xsa Exp $	*/
d137 8
a144 7
	if ((cvs_cmd_update.cmd_flags & CVS_CMD_PRUNEDIRS) && 
	    (cvs_sendarg(root, "-P", 0) < 0))
		return (CVS_EX_PROTO);
	if (Aflag && cvs_sendarg(root, "-A", 0) < 0)
		return (CVS_EX_PROTO);
	if (dflag && cvs_sendarg(root, "-d", 0) < 0)
		return (CVS_EX_PROTO);
d146 2
a147 2
	if ((rev != NULL) && ((cvs_sendarg(root, "-r", 0) < 0) ||
	    (cvs_sendarg(root, rev, 0) < 0)))
d150 4
a153 3
	if ((date != NULL) && ((cvs_sendarg(root, "-D", 0) < 0) ||
	    (cvs_sendarg(root, date, 0) < 0)))
		return (CVS_EX_PROTO);
@


1.34
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.33 2005/05/30 08:27:03 xsa Exp $	*/
d54 1
a54 1
	"ACD:dflPpQqRr:",
d66 1
a66 1
static char *date, *rev;
d68 1
d93 14
d145 2
a146 3
	if (rev != NULL) {
		if ((cvs_sendarg(root, "-r", 0) < 0) ||
		    (cvs_sendarg(root, rev, 0) < 0))
d148 5
a152 1
	}
@


1.33
log
@-D and -r can be used simultaneously, pointed out by marc@@ and thus
backout my previous change + spotted another case in the annotate
command...

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.32 2005/05/29 16:36:54 xsa Exp $	*/
d31 1
a32 1
#include <fcntl.h>
d34 1
a35 1
#include <string.h>
a37 1
#include "rcs.h"
@


1.32
log
@-D and -r are mutually exclusive ...
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.31 2005/05/26 03:07:20 joris Exp $	*/
a115 6
	if ((date != NULL) && (rev != NULL)) {
		cvs_log(LP_ERR,
		    "the -D and -r arguments are mutually exclusive");
		return (CVS_EX_USAGE);
	}

d130 6
@


1.31
log
@

first part of real pruning support

okay jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.30 2005/05/24 04:21:54 jfb Exp $	*/
d67 1
d76 2
d86 2
d109 1
d114 6
@


1.30
log
@remove debugging messages
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.29 2005/05/24 04:12:25 jfb Exp $	*/
d67 1
a67 1
static int Pflag, dflag, Aflag;
d74 1
a74 1
	Pflag = dflag = Aflag = 0;
d92 1
a92 1
			Pflag = 1;
d117 2
a118 1
	if (Pflag && cvs_sendarg(root, "-P", 0) < 0)
@


1.29
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.28 2005/05/20 20:00:53 joris Exp $	*/
a194 1
	printf("cvs_update_local(%s)\n", cf->cf_name);
a219 1
	printf("opening %s\n", rcspath);
@


1.28
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.27 2005/05/20 18:26:49 xsa Exp $	*/
d43 2
a46 2
static int cvs_update_options   (char *, int, char **, int *);
static int cvs_update_sendflags (struct cvsroot *);
d48 12
a59 3
struct cvs_cmd_info cvs_update = {
	cvs_update_options,
	cvs_update_sendflags,
d61 3
a63 3
	NULL, NULL,
	CF_SORT | CF_RECURSE | CF_IGNORE | CF_KNOWN | CF_NOSYMS,
	CVS_REQ_UPDATE,
d70 1
a70 1
cvs_update_options(char *opt, int argc, char **argv, int *arg)
d76 1
a76 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d89 1
a89 1
			cvs_update.file_flags &= ~CF_RECURSE;
d101 1
a101 1
			cvs_update.file_flags |= CF_RECURSE;
d115 1
a115 1
cvs_update_sendflags(struct cvsroot *root)
d195 1
d201 2
d204 1
a207 2
	cvs_file_getpath(cf, fpath, sizeof(fpath));

d221 1
d224 1
@


1.27
log
@first bits of the `cvs -n' option; ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.26 2005/04/27 04:42:40 jfb Exp $	*/
d141 3
d169 3
d207 1
a207 1
		return (-1);
@


1.26
log
@cleanup and initial split between remote and local update code
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.25 2005/04/19 00:55:07 joris Exp $	*/
d86 2
@


1.25
log
@

send the correct argument, -A not -a
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.24 2005/04/19 00:38:39 joris Exp $	*/
d43 4
a46 4
int cvs_update_file(CVSFILE *, void *);
int cvs_update_prune(CVSFILE *, void *);
int cvs_update_options(char *, int, char **, int *);
int cvs_update_sendflags(struct cvsroot *);
d51 1
a51 1
	cvs_update_file,
d60 1
a60 1
int
d103 1
a103 1
int
d116 1
a116 1
 * cvs_update_file()
d121 2
a122 2
int
cvs_update_file(CVSFILE *cf, void *arg)
d124 2
a125 3
	int ret, l;
	char *fname, *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	RCSFILE *rf;
a128 1
	rf = NULL;
a130 1
	fname = CVS_FILE_NAME(cf);
d133 5
a137 7
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cf->cf_cvstat == CVS_FST_UNKNOWN)
				ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
				    CVS_FILE_NAME(cf));
			else
				ret = cvs_senddir(root, cf);
		}
d144 2
a145 39
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_sendentry(root, cf) < 0) {
			return (CVS_EX_PROTO);
		}

		switch (cf->cf_cvstat) {
		case CVS_FST_UNKNOWN:
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE, fname);
			break;
		case CVS_FST_UPTODATE:
			ret = cvs_sendreq(root, CVS_REQ_UNCHANGED, fname);
			break;
		case CVS_FST_ADDED:
		case CVS_FST_MODIFIED:
			ret = cvs_sendreq(root, CVS_REQ_MODIFIED, fname);
			if (ret == 0)
				ret = cvs_sendfile(root, fpath);
			break;
		default:
			break;
		}
	} else {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
			cvs_printf("? %s\n", fpath);
			return (0);
		}

		l = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
		    root->cr_dir, repo, fname, RCS_FILE_EXT);
		if (l == -1 || l >= (int)sizeof(rcspath)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", rcspath);
			return (-1);
		}

		rf = rcs_open(rcspath, RCS_READ);
		if (rf == NULL) {
			return (CVS_EX_DATA);
		}
d147 15
a161 1
		rcs_close(rf);
a166 1

d168 1
a168 3
 * cvs_update_prune()
 *
 * Prune all directories which contain no more files known to CVS.
d170 2
a171 2
int
cvs_update_prune(CVSFILE *cf, void *arg)
d173 28
d202 8
a209 1
	return (0);
@


1.24
log
@

support -P -A -d flags
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.23 2005/04/18 21:02:50 jfb Exp $	*/
d108 1
a108 1
	if (Aflag && cvs_sendarg(root, "-a", 0) < 0)
@


1.23
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.22 2005/04/16 20:31:18 xsa Exp $	*/
d46 1
d50 1
a50 1
	NULL,
d58 2
d65 2
d70 2
d75 2
d83 2
d103 11
@


1.22
log
@thought i had committed that earlier;snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.21 2005/04/12 14:58:40 joris Exp $	*/
a105 1
	struct cvs_ent *entp;
a125 1
	entp = cvs_ent_getent(fpath);
d128 1
a128 2
		if ((entp != NULL) && (cvs_sendentry(root, entp) < 0)) {
			cvs_ent_free(entp);
a158 2

			cvs_ent_free(entp);
a163 1
			cvs_ent_free(entp);
a169 2
	if (entp != NULL)
		cvs_ent_free(entp);
@


1.21
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.20 2005/04/11 18:02:58 joris Exp $	*/
d102 1
a102 1
	int ret;
d157 1
a157 1
		snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
d159 7
@


1.20
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.19 2005/04/11 17:56:27 joris Exp $	*/
d84 1
a84 1
			return (1);
d132 1
a132 1
			return (-1);
d163 1
a163 1
			return (-1);
@


1.19
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.18 2005/03/30 17:43:04 joris Exp $	*/
a35 1
#include <sysexits.h>
@


1.18
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.17 2005/02/27 00:22:08 jfb Exp $	*/
d85 1
a85 1
			return (EX_USAGE);
@


1.17
log
@Many improvements to the RCS support:

- make it possible to specify creation and the file mode
  in rcs_open()
- implicitly write the contents to disk on rcs_close() if the
  RCS handle has been changed
- fix a bug in the output of the `expand' keyword
- add functions to retrieve and modify the expansion mode
- rcs_parse() shouldn't be available to the outside
- empty string instead of `(null)' if there is no description

ok Joris
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.16 2005/02/22 23:31:13 jfb Exp $	*/
d44 13
a56 2
int  cvs_update_file  (CVSFILE *, void *);
int  cvs_update_prune (CVSFILE *, void *);
a57 7

/*
 * cvs_update()
 *
 * Handle the `cvs update' command.
 * Returns 0 on success, or the appropriate exit code on error.
 */
d59 1
a59 1
cvs_update(int argc, char **argv)
d61 1
a61 2
	int i, ch, flags;
	struct cvsroot *root;
d63 1
a63 3
	flags = CF_SORT|CF_RECURSE|CF_IGNORE|CF_KNOWN|CF_NOSYMS;

	while ((ch = getopt(argc, argv, "ACD:dflPpQqRr:")) != -1) {
d72 1
a72 1
			flags &= ~CF_RECURSE;
d80 1
a80 1
			flags |= CF_RECURSE;
d89 1
a89 37
	argc -= optind;
	argv += optind;

	if (argc == 0)
		cvs_files = cvs_file_get(".", flags);
	else {
		/* don't perform ignore on explicitly listed files */
		flags &= ~(CF_IGNORE | CF_RECURSE | CF_SORT);
		cvs_files = cvs_file_getspec(argv, argc, flags);
	}
	if (cvs_files == NULL)
		return (EX_DATAERR);

	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cvs_connect(root) < 0))
		return (EX_PROTOCOL);

	cvs_file_examine(cvs_files, cvs_update_file, NULL);

	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0)
			return (EX_PROTOCOL);

		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				return (EX_PROTOCOL);
		if (cvs_sendreq(root, CVS_REQ_UPDATE, NULL) < 0)
			return (EX_PROTOCOL);
	}

@


1.16
log
@use the file's name, and not its full path, when building the path to
the RCS file in the repository

spotted by pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.15 2005/02/04 17:50:20 jfb Exp $	*/
d196 1
a196 1
		rf = rcs_open(rcspath, RCS_MODE_READ);
@


1.15
log
@remove duplicate trace message which gets output in cvs_sendfile()
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.14 2005/01/13 07:04:16 jfb Exp $	*/
d194 1
a194 1
		    root->cr_dir, repo, fpath, RCS_FILE_EXT);
@


1.14
log
@prettier
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.13 2004/12/21 18:32:10 jfb Exp $	*/
a179 1
			cvs_log(LP_TRACE, "Sending file `%s' to server", fname);
@


1.13
log
@modify the directory handling portion to behave like the one in add.c,
which does not attempt to send data when running on a local
repository.  This will be needed to support local repository access
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.12 2004/12/14 22:30:48 jfb Exp $	*/
d139 1
a139 1
	char *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
d148 1
d173 1
a173 2
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cf));
d176 1
a176 2
			ret = cvs_sendreq(root, CVS_REQ_UNCHANGED,
			    CVS_FILE_NAME(cf));
d180 2
a181 2
			ret = cvs_sendreq(root, CVS_REQ_MODIFIED,
			    CVS_FILE_NAME(cf));
@


1.12
log
@First attempt at syncing the command code and doing a lot more error
checking on all the protocol calls
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.11 2004/12/07 17:10:56 tedu Exp $	*/
d149 9
a157 6
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cf->cf_type == DT_DIR)) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cf));
		else
			ret = cvs_senddir(root, cf);
@


1.11
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.10 2004/12/06 21:03:13 deraadt Exp $	*/
d57 2
a58 1
	int ch, flags;
d91 1
a91 1
	if (argc == 0) {
d93 1
a93 1
	} else {
d101 11
d114 10
a123 2
	cvs_senddir(cvs_files->cf_ddat->cd_root, cvs_files);
	cvs_sendreq(cvs_files->cf_ddat->cd_root, CVS_REQ_UPDATE, NULL);
d132 2
a133 1
 * Diff a single file.
d138 1
d144 4
a147 1
	cvs_file_getpath(cf, fpath, sizeof(fpath));
d149 3
a151 4
	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
			root = cf->cf_parent->cf_ddat->cd_root;
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
a152 24
		} else {
			root = cf->cf_ddat->cd_root;
			if ((cf->cf_parent == NULL) ||
			    (root != cf->cf_parent->cf_ddat->cd_root)) {
				cvs_connect(root);
			}

			cvs_senddir(root, cf);
		}

		return (0);
	} else
		root = cf->cf_parent->cf_ddat->cd_root;

	rf = NULL;
	if (cf->cf_parent != NULL) {
		repo = cf->cf_parent->cf_ddat->cd_repo;
	} else {
		repo = NULL;
	}

	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		if (root->cr_method == CVS_METHOD_LOCAL)
			cvs_printf("? %s\n", fpath);
d154 2
a155 2
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, CVS_FILE_NAME(cf));
		return (0);
d158 1
a159 2
	if (entp == NULL)
		return (-1);
d161 5
a165 5
	if ((root->cr_method != CVS_METHOD_LOCAL) &&
	    (cvs_sendentry(root, entp) < 0)) {
		cvs_ent_free(entp);
		return (-1);
	}
a166 1
	if (root->cr_method != CVS_METHOD_LOCAL) {
d168 4
d173 2
a174 1
			cvs_sendreq(root, CVS_REQ_UNCHANGED, CVS_FILE_NAME(cf));
d178 4
a181 2
			cvs_sendreq(root, CVS_REQ_MODIFIED, CVS_FILE_NAME(cf));
			cvs_sendfile(root, fpath);
d184 14
d201 1
a201 2
		cvs_ent_free(entp);
		return (0);
d204 1
a204 5
	snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, fpath, RCS_FILE_EXT);

	rf = rcs_open(rcspath, RCS_MODE_READ);
	if (rf == NULL) {
d206 1
a206 6
		return (-1);
	}

	rcs_close(rf);
	cvs_ent_free(entp);
	return (0);
@


1.10
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.9 2004/11/26 16:23:50 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a47 2


a53 1

a113 1

a205 1

@


1.9
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 1
a95 2
	}
	else {
d133 1
a133 2
		}
		else {
d144 1
a144 2
	}
	else
d150 1
a150 2
	}
	else {
@


1.8
log
@Add CF_NOSYMS to the flags so we skip symbolic links
@
text
@d122 1
a122 1
	char *dir, *repo, rcspath[MAXPATHLEN];
d127 2
d132 2
a133 1
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
a151 1
		dir = cf->cf_parent->cf_path;
a154 1
		dir = ".";
d160 1
a160 1
			cvs_printf("? %s\n", cf->cf_path);
d162 1
a162 1
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
d166 1
a166 1
	entp = cvs_ent_getent(cf->cf_path);
d179 1
a179 1
			cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
d183 2
a184 2
			cvs_sendreq(root, CVS_REQ_MODIFIED, cf->cf_name);
			cvs_sendfile(root, cf->cf_path);
d195 1
a195 1
	    root->cr_dir, repo, cf->cf_path, RCS_FILE_EXT);
@


1.7
log
@Use cvs_files to build the file hierarchy and handle explicit arguments
correctly
@
text
@d62 1
a62 1
	flags = CF_SORT|CF_RECURSE|CF_IGNORE|CF_KNOWN;
@


1.6
log
@If the directory we are updating is unknown, send a Questionable request
instead of attempting to connect to an invalid root specification
@
text
@d60 1
a60 2
	int ch, i, flags;
	struct cvs_file *cf;
a61 1
	cf = NULL;
d94 1
a94 1
		cf = cvs_file_get(".", flags);
d98 2
a99 5
		flags &= ~CF_IGNORE;

		for (i = 0; i < argc; i++) {
			cf = cvs_file_get(argv[i], flags);
		}
d101 2
d104 1
a104 1
	cvs_file_examine(cf, cvs_update_file, NULL);
d106 2
a107 2
	cvs_senddir(cf->cf_ddat->cd_root, cf);
	cvs_sendreq(cf->cf_ddat->cd_root, CVS_REQ_UPDATE, NULL);
@


1.5
log
@fix diffing by sending the base directory just before sending the 'diff'
command, and remove some debugging messages
@
text
@d64 1
a64 1
	flags = CF_SORT|CF_RECURSE|CF_IGNORE;
d131 12
a142 4
		root = cf->cf_ddat->cd_root;
		if ((cf->cf_parent == NULL) ||
		    (root != cf->cf_parent->cf_ddat->cd_root)) {
			cvs_connect(root);
a144 1
		cvs_senddir(root, cf);
@


1.4
log
@Move to the new API for the client-server protocol.  All functions now
take a cvs root structure as parameter.  This will allow for much easier
management of CVS trees that make use of multiple roots.
@
text
@a129 2
	cvs_log(LP_DEBUG, "%s: updating %s", __func__, cf->cf_path);

@


1.3
log
@Don't export `cvs_root'
@
text
@d41 1
d109 2
a110 2
	cvs_client_senddir(cf->cf_path);
	cvs_client_sendreq(CVS_REQ_UPDATE, NULL, 1);
d136 1
a136 3
			cvs_client_connect(root);
			/* XXX temporary hack */
			cvs_root = root;
d139 1
a139 1
		cvs_client_senddir(cf->cf_path);
d159 1
a159 2
			cvs_client_sendreq(CVS_REQ_QUESTIONABLE,
			    cf->cf_name, 0);
d168 1
a168 1
	    (cvs_client_sendentry(entp) < 0)) {
d176 1
a176 1
			cvs_client_sendreq(CVS_REQ_UNCHANGED, cf->cf_name, 0);
d180 2
a181 2
			cvs_client_sendreq(CVS_REQ_MODIFIED, cf->cf_name, 0);
			cvs_sendfile(cf->cf_path);
@


1.2
log
@update meat
@
text
@a41 4
extern char *__progname;

extern struct cvsroot *cvs_root;

@


1.1
log
@Initial revision
@
text
@d47 6
d57 1
a59 1

d63 5
a67 1
	int ch;
d76 1
d78 2
d84 1
d86 2
a90 2
			fprintf(stderr, "Usage: %s [args] update [args] ...\n",
			    __progname);
d97 124
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
