head	1.100;
access;
symbols
	OPENBSD_6_2:1.100.0.4
	OPENBSD_6_2_BASE:1.100
	OPENBSD_6_1:1.98.0.4
	OPENBSD_6_1_BASE:1.98
	OPENBSD_6_0:1.96.0.6
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.96.0.2
	OPENBSD_5_9_BASE:1.96
	OPENBSD_5_8:1.96.0.4
	OPENBSD_5_8_BASE:1.96
	OPENBSD_5_7:1.94.0.2
	OPENBSD_5_7_BASE:1.94
	OPENBSD_5_6:1.93.0.20
	OPENBSD_5_6_BASE:1.93
	OPENBSD_5_5:1.93.0.18
	OPENBSD_5_5_BASE:1.93
	OPENBSD_5_4:1.93.0.14
	OPENBSD_5_4_BASE:1.93
	OPENBSD_5_3:1.93.0.12
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.93.0.10
	OPENBSD_5_2_BASE:1.93
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.8
	OPENBSD_5_0:1.93.0.6
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.93.0.4
	OPENBSD_4_9_BASE:1.93
	OPENBSD_4_8:1.93.0.2
	OPENBSD_4_8_BASE:1.93
	OPENBSD_4_7:1.92.0.2
	OPENBSD_4_7_BASE:1.92
	OPENBSD_4_6:1.92.0.4
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.91.0.2
	OPENBSD_4_5_BASE:1.91
	OPENBSD_4_4:1.88.0.2
	OPENBSD_4_4_BASE:1.88
	OPENBSD_4_3:1.83.0.2
	OPENBSD_4_3_BASE:1.83
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.73.0.2
	OPENBSD_4_1_BASE:1.73
	OPENBSD_4_0:1.68.0.2
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.54.0.2
	OPENBSD_3_9_BASE:1.54
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.100
date	2017.06.01.08.08.24;	author joris;	state Exp;
branches;
next	1.99;
commitid	oZyV6E3g0wglnhaw;

1.99
date	2017.05.28.16.58.54;	author joris;	state Exp;
branches;
next	1.98;
commitid	Kq7eLtSB5NbbQZL8;

1.98
date	2016.11.03.20.13.41;	author joris;	state Exp;
branches;
next	1.97;
commitid	xtITnmg5IoPbIrer;

1.97
date	2016.10.18.17.11.43;	author joris;	state Exp;
branches;
next	1.96;
commitid	zoGeysaZGOXNuEBX;

1.96
date	2015.04.04.14.20.11;	author stsp;	state Exp;
branches;
next	1.95;
commitid	X3nuJaQSYqTq7RBm;

1.95
date	2015.04.04.14.19.10;	author stsp;	state Exp;
branches;
next	1.94;
commitid	ED4wEXoF2lnt3mdI;

1.94
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	Uu5nFG3wCl0LACBb;

1.93
date	2010.04.19.13.03.10;	author millert;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.21.15.33.22;	author joris;	state Exp;
branches;
next	1.91;

1.91
date	2009.02.21.14.50.53;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2009.02.21.12.47.19;	author joris;	state Exp;
branches;
next	1.89;

1.89
date	2009.01.14.00.23.30;	author joris;	state Exp;
branches;
next	1.88;

1.88
date	2008.06.14.04.34.08;	author tobias;	state Exp;
branches;
next	1.87;

1.87
date	2008.06.11.02.19.13;	author tobias;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.08.18.07.44;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2008.06.08.16.20.49;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.08.16.17.04;	author joris;	state Exp;
branches;
next	1.83;

1.83
date	2008.02.13.17.05.13;	author joris;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.10.14.08.52;	author xsa;	state Exp;
branches;
next	1.81;

1.81
date	2008.02.10.13.16.35;	author xsa;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.10.09.37.26;	author tobias;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.03.12.29.52;	author xsa;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.73;

1.73
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.31.21.07.36;	author xsa;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.12.19.28.12;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.07.13.01.40;	author joris;	state Exp;
branches;
next	1.66;

1.66
date	2006.06.19.05.05.17;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2006.06.16.14.07.42;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2006.06.07.15.21.47;	author xsa;	state Exp;
branches;
next	1.63;

1.63
date	2006.06.04.14.56.09;	author xsa;	state Exp;
branches;
next	1.62;

1.62
date	2006.06.01.20.00.52;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.30.21.32.52;	author joris;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.30.07.24.08;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.28.07.56.44;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.27.15.14.27;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.27.03.30.31;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2006.04.12.14.31.05;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.30.17.58.47;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.27.15.26.38;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.25.08.15.05;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.22.14.59.54;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2005.09.22.16.13.44;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2005.09.05.20.03.22;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.17.18.33.55;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2005.08.17.08.35.53;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2005.08.08.11.37.41;	author xsa;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.27.16.42.19;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.22.16.27.29;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.19.15.48.52;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.14.06.54.59;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.10.13.58.19;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.08.12.45.10;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.08.11.46.23;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.08.10.10.48;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.08.07.22.58;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.07.15.52.26;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.07.15.10.17;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.07.14.08.41;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.07.07.37.43;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.07.06.52.14;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.06.09.52.16;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.05.16.14.47;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.05.16.06.52;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.30.15.24.53;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.30.09.42.14;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.25.13.53.37;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.24.04.12.25;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.20.20.00.53;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.27.04.54.46;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.18.21.02.50;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.16.20.31.18;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.16.20.26.05;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.12.16.56.07;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.12.16.13.59;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.12.14.58.40;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.11.18.02.58;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.11.17.56.27;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.03.17.32.50;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.30.17.43.04;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.26.08.09.54;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.27.00.22.08;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.06.20.39.27;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.21.18.32.10;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.14.22.30.48;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.06.21.03.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.26.16.23.50;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.30.17.44.48;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.100
log
@Stop looking at current_cvsroot->cr_method to figure out if we're remote or not.

Instead use cvsroot_is_local() and cvsroot_is_remote().
@
text
@/*	$OpenBSD: status.c,v 1.99 2017/05/28 16:58:54 joris Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2005-2008 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

void	cvs_status_local(struct cvs_file *);

static int show_sym = 0;

struct cvs_cmd cvs_cmd_status = {
	CVS_OP_STATUS, CVS_USE_WDIR, "status",
	{ "st", "stat" },
	"Display status information on checked out files",
	"[-lRv]",
	"lRv",
	NULL,
	cvs_status
};

#define CVS_STATUS_SEP	\
	"==================================================================="

const char *status_tab[] = {
	"Unknown",
	"Locally Added",
	"Locally Removed",
	"Locally Modified",
	"Up-to-date",
	"Needs Checkout",
	"Needs Checkout",
	"Needs Merge",
	"Needs Patch",
	"Entry Invalid",
	"Unresolved Conflict",
	"Classifying error",
};

int
cvs_status(int argc, char **argv)
{
	int ch, flags;
	char *arg = ".";
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;

	while ((ch = getopt(argc, argv, cvs_cmd_status.cmd_opts)) != -1) {
		switch (ch) {
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		case 'v':
			show_sym = 1;
			break;
		default:
			fatal("%s", cvs_cmd_status.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (cvsroot_is_local()) {
		flags |= CR_REPO;
		cr.fileproc = cvs_status_local;
	} else {
		cvs_client_connect_to_server();
		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");
		if (show_sym)
			cvs_client_send_request("Argument -v");
		cr.fileproc = cvs_client_sendfile;
	}

	cr.flags = flags;

	if (argc > 0)
		cvs_file_run(argc, argv, &cr);
	else
		cvs_file_run(1, &arg, &cr);

	if (cvsroot_is_remote()) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("status");
		cvs_client_get_responses();
	}

	return (0);
}

void
cvs_status_local(struct cvs_file *cf)
{
	size_t len;
	RCSNUM *head, *brev;
	const char *status;
	struct rcs_delta *rdp;
	char buf[PATH_MAX + CVS_REV_BUFSZ + 128];
	char timebuf[CVS_TIME_BUFSZ], revbuf[CVS_REV_BUFSZ];
	struct rcs_sym *sym;

	cvs_log(LP_TRACE, "cvs_status_local(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if (cf->file_type == CVS_DIR) {
		if (verbosity > 1)
			cvs_log(LP_NOTICE, "Examining %s", cf->file_path);
		return;
	}

	if (cf->file_status == FILE_UPTODATE &&
	    !(cf->file_flags & FILE_ON_DISK) &&
	    !(cf->file_flags & FILE_USER_SUPPLIED))
		return;

	if (cf->file_rcs != NULL)
		head = cf->file_rcsrev;
	else
		head = NULL;

	cvs_printf("%s\n", CVS_STATUS_SEP);

	if (cf->file_rcs != NULL && head == NULL)
		status = status_tab[FILE_UNKNOWN];
	else
		status = status_tab[cf->file_status];

	if (cf->file_status == FILE_MODIFIED &&
	    cf->file_ent->ce_conflict != NULL)
		status = "File had conflicts on merge";

	if (!(cf->file_flags & FILE_ON_DISK)) {
		(void)xsnprintf(buf, sizeof(buf), "no file %s\t",
		    cf->file_name);
	} else
		if (strlcpy(buf, cf->file_name, sizeof(buf)) >= sizeof(buf))
			fatal("cvs_status_local: overflow");

	cvs_printf("File: %-17s\tStatus: %s\n\n", buf, status);

	if (cf->file_ent == NULL) {
		(void)xsnprintf(buf, sizeof(buf),
		    "No entry for %s", cf->file_name);
	} else if (cf->file_ent->ce_status == CVS_ENT_ADDED) {
		len = strlcpy(buf, "New file!", sizeof(buf));
		if (len >= sizeof(buf))
			fatal("cvs_status_local: truncation");
	} else {
		rcsnum_tostr(cf->file_ent->ce_rev, revbuf, sizeof(revbuf));

		if (cf->file_ent->ce_conflict == NULL) {
			if (cvs_server_active == 0) {
				(void)strlcpy(timebuf, cf->file_ent->ce_time,
				    sizeof(timebuf));
			} else {
				timebuf[0] = '\0';
			}
		} else {
			len = strlcpy(timebuf, cf->file_ent->ce_conflict,
			    sizeof(timebuf));
			if (len >= sizeof(timebuf))
				fatal("cvs_status_local: truncation");
		}

		(void)strlcpy(buf, revbuf, sizeof(buf));
		if (cvs_server_active == 0) {
			(void)strlcat(buf, "\t", sizeof(buf));
			(void)strlcat(buf, timebuf, sizeof(buf));
		}
	}

	cvs_printf("   Working revision:\t%s\n", buf);

	buf[0] = '\0';
	if (cf->file_rcs == NULL) {
		len = strlcat(buf, "No revision control file", sizeof(buf));
		if (len >= sizeof(buf))
			fatal("cvs_status_local: truncation");
	} else if (head == NULL) {
		len = strlcat(buf, "No head revision", sizeof(buf));
		if (len >= sizeof(buf))
			fatal("cvs_status_local: truncation");
	} else {
		rcsnum_tostr(head, revbuf, sizeof(revbuf));
		(void)xsnprintf(buf, sizeof(buf), "%s\t%s", revbuf,
		    cf->file_rpath);
	}

	cvs_printf("   Repository revision:\t%s\n", buf);

	if (cf->file_rcs != NULL && head != NULL) {
		rdp = rcs_findrev(cf->file_rcs, head);
		if (rdp == NULL) {
			fatal("cvs_status_local: No head revision delta");
		}

		cvs_printf("   Commit Identifier:\t%s\n",
		    (rdp->rd_commitid != NULL) ? rdp->rd_commitid : "(none)");
	}

	if (cf->file_ent != NULL) {
		if (cf->file_ent->ce_tag != NULL) {
			if ((brev = rcs_sym_getrev(cf->file_rcs,
			    cf->file_ent->ce_tag)) == NULL) {
				(void)strlcpy(buf, "- MISSING from RCS file!",
				    sizeof(buf));
			} else {
				rcsnum_tostr(brev, revbuf, sizeof(revbuf));
				if (RCSNUM_ISBRANCH(brev)) {
					xsnprintf(buf, sizeof(buf),
					    "(branch: %s)", revbuf);
				} else {
					xsnprintf(buf, sizeof(buf),
					    "(revision: %s)", revbuf);
				}
				free(brev);
			}

			cvs_printf("   Sticky Tag:\t\t%s %s\n",
			    cf->file_ent->ce_tag, buf);
		} else if (verbosity > 0) {
			cvs_printf("   Sticky Tag:\t\t(none)\n");
		}

		if (cf->file_ent->ce_date != -1) {
			struct tm datetm;
			char datetmp[CVS_TIME_BUFSZ];

			gmtime_r(&(cf->file_ent->ce_date), &datetm);
                        (void)strftime(datetmp, sizeof(datetmp),
			    CVS_DATE_FMT, &datetm);

			cvs_printf("   Sticky Date:\t\t%s\n", datetmp);
		} else if (verbosity > 0)
			cvs_printf("   Sticky Date:\t\t(none)\n");

		if (cf->file_ent->ce_opts != NULL)
			cvs_printf("   Sticky Options:\t%s\n",
			    cf->file_ent->ce_opts);
		else if (verbosity > 0)
			cvs_printf("   Sticky Options:\t(none)\n");
	}

	if (cf->file_rcs != NULL && show_sym == 1) {
		cvs_printf("\n");
		cvs_printf("   Existing Tags:\n");

		if (!TAILQ_EMPTY(&(cf->file_rcs->rf_symbols))) {
			TAILQ_FOREACH(sym,
			    &(cf->file_rcs->rf_symbols), rs_list) {
				(void)rcsnum_tostr(sym->rs_num, revbuf,
				    sizeof(revbuf));

				cvs_printf("\t%-25s\t(%s: %s)\n", sym->rs_name,
				    RCSNUM_ISBRANCH(sym->rs_num) ? "branch" :
				    "revision", revbuf);
			 }
		} else
			cvs_printf("\tNo Tags Exist\n");
	}

	cvs_printf("\n");
}
@


1.99
log
@Teach opencvs status to display the sticky tag according to what it really
represents if it is a branch or a revision.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.98 2016/11/03 20:13:41 joris Exp $	*/
d90 1
a90 1
	if (current_cvsroot->cr_method == CVS_METHOD_LOCAL) {
d109 1
a109 1
	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
@


1.98
log
@Don't use ce_time if we are running as a server, it won't be present.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.97 2016/10/18 17:11:43 joris Exp $	*/
d238 7
a244 2
				(void)xsnprintf(buf, sizeof(buf),
				    "(branch: %s)", revbuf);
@


1.97
log
@Add the branch revision to the status output much like GNU cvs does.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.96 2015/04/04 14:20:11 stsp Exp $	*/
d181 6
a186 2
			(void)strlcpy(timebuf, cf->file_ent->ce_time,
			    sizeof(timebuf));
@


1.96
log
@Add support for commit ids to opencvs status.
Patch by joris via tech@@; reminded by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.95 2015/04/04 14:19:10 stsp Exp $	*/
d19 1
d123 1
a123 1
	RCSNUM *head;
d227 15
a241 4
		if (cf->file_ent->ce_tag != NULL)
			cvs_printf("   Sticky Tag:\t\t%s\n",
			    cf->file_ent->ce_tag);
		else if (verbosity > 0)
d243 1
@


1.95
log
@Fix modified timestamp in output of opencvs status.
Patch by joris via tech@@; reminded by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.94 2015/01/16 06:40:07 deraadt Exp $	*/
d124 1
d214 10
@


1.94
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.93 2010/04/19 13:03:10 millert Exp $	*/
d179 2
a180 3
			ctime_r(&(cf->file_ent->ce_mtime), timebuf);
			if (timebuf[strlen(timebuf) - 1] == '\n')
				timebuf[strlen(timebuf) - 1] = '\0';
@


1.93
log
@Increase buffer size to support large pathnames.  Committing on
behalf of stsp@@ who is travelling.  OK miod@@ deraadt@@ xsa@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.92 2009/03/21 15:33:22 joris Exp $	*/
d124 1
a124 1
	char buf[MAXPATHLEN + CVS_REV_BUFSZ + 128];
@


1.92
log
@use file_rcsrev when printing out Repository revision so
we always receive the correct revision number instead of HEAD,
otherwise running status on a file that belongs to a branch results
in showing HEAD revision instead of latest branch revision.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.91 2009/02/21 14:50:53 joris Exp $	*/
d124 2
a125 1
	char buf[128], timebuf[CVS_TIME_BUFSZ], revbuf[CVS_REV_BUFSZ];
@


1.91
log
@use FILE_ON_DISK flags when we need to verify if a file
exists in the working copy or not instead of checking fd being -1
since this can differ in server or local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.90 2009/02/21 12:47:19 joris Exp $	*/
d143 1
a143 1
		head = rcs_head_get(cf->file_rcs);
a207 1
		rcsnum_free(head);
@


1.90
log
@alter cvs_file_get() so it takes flags instead of one set
value for user_supplied. allow us to carry any important file flags
over to cvs_file's later on.

makes it easier for what i have coming.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.89 2009/01/14 00:23:30 joris Exp $	*/
d137 2
a138 1
	if (cf->file_status == FILE_UPTODATE && cf->fd == -1 &&
d158 1
a158 1
	if (cf->fd == -1) {
@


1.89
log
@fix printing status on removed files by default;
slighty different diff applied then what the bug author provided us.

thanks & closes pr 6038
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.88 2008/06/14 04:34:08 tobias Exp $	*/
d138 1
a138 1
	    cf->user_supplied == 0)
@


1.88
log
@Conforming to RCS specification, it is possible but unlikely to encounter
an RCS file which has no head revision set.  Some commands actually can
work with them (log, status) so support these files. Fixes  A LOT of
possible segmentation faults.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.87 2008/06/11 02:19:13 tobias Exp $	*/
d136 4
@


1.87
log
@Avoid possible NULL pointer dereferences by using reentrant versions
of time functions.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.86 2008/06/08 18:07:44 joris Exp $	*/
d137 1
a137 1
	if (cf->file_rcs != NULL) {
d139 1
a139 3
		if (head == NULL && cf->file_status != FILE_REMOVE_ENTRY)
			return;
	} else {
a140 1
	}
d144 5
a148 1
	status = status_tab[cf->file_status];
d153 1
a153 3
	if (cf->file_status == FILE_LOST ||
	    cf->file_status == FILE_REMOVE_ENTRY ||
	    (cf->file_rcs != NULL && cf->in_attic == 1 && cf->fd == -1)) {
d165 1
a165 2
	} else if (cf->file_status == FILE_ADDED ||
		   cf->file_status == FILE_REMOVE_ENTRY) {
d193 1
a193 1
	if (cf->file_rcs == NULL || head == NULL) {
d195 4
@


1.86
log
@check for file_rcs being NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.85 2008/06/08 16:20:49 joris Exp $	*/
d20 1
d216 1
a216 1
			struct tm *datetm;
d219 1
a219 1
			datetm = gmtime(&(cf->file_ent->ce_date));
d221 1
a221 1
			    CVS_DATE_FMT, datetm);
@


1.85
log
@there are more cases where we cannot show the tags when -v is specified.
noticed by tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.84 2008/06/08 16:17:04 joris Exp $	*/
d233 1
a233 2
	if (cf->file_status == FILE_UPTODATE &&
	    cf->file_status != FILE_MODIFIED && show_sym == 1) {
@


1.84
log
@do not segfault when running status -v on non existing files.
original patch from Igor Zinovik but fixed in another way.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.83 2008/02/13 17:05:13 joris Exp $	*/
d233 2
a234 1
	if (cf->file_status != FILE_UNKNOWN && show_sym == 1) {
@


1.83
log
@fix a crash that could happen when running status on unknown files.

from Tero Koskinen.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.82 2008/02/10 14:08:52 xsa Exp $	*/
d233 1
a233 1
	if (show_sym == 1) {
@


1.82
log
@+ #define CVS_DATE_FMT   "%Y.%m.%d.%H.%M.%S"
...and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.81 2008/02/10 13:16:35 xsa Exp $	*/
d136 7
a142 3
	head = rcs_head_get(cf->file_rcs);
	if (head == NULL && cf->file_status != FILE_REMOVE_ENTRY)
		return;
a151 1
	    cf->file_status == FILE_UNKNOWN ||
@


1.81
log
@Add support for Sticky Date. OK joris@@ tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.80 2008/01/31 10:15:05 tobias Exp $	*/
d217 1
a217 1
                            "%Y.%m.%d.%H.%M.%S", datetm);
@


1.80
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.79 2008/01/28 20:31:07 tobias Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
d210 12
@


1.79
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.78 2008/01/10 09:37:26 tobias Exp $	*/
d30 1
a30 1
	CVS_OP_STATUS, 0, "status",
@


1.78
log
@RCS files without head keyword mustn't segfault our implementation.  Only
command that supports such files is "cvs status", therefore properly handle
them in all other commands, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.77 2007/09/22 16:01:22 joris Exp $	*/
d72 1
@


1.77
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.76 2007/07/03 12:29:52 xsa Exp $	*/
d135 4
d148 1
d161 2
a162 1
	} else if (cf->file_status == FILE_ADDED) {
d190 1
a190 1
	if (cf->file_rcs == NULL) {
a194 1
		head = rcs_head_get(cf->file_rcs);
@


1.76
log
@On the server side, in a remote setup, do not display timestamp.
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.75 2007/06/28 21:38:09 xsa Exp $	*/
d127 1
a127 1
	cvs_file_classify(cf, NULL);
d144 1
a144 1
	    (cf->file_rcs != NULL && cf->in_attic == 1)) {
@


1.75
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.74 2007/06/01 17:47:47 niallo Exp $	*/
d174 5
a178 1
		(void)xsnprintf(buf, sizeof(buf), "%s\t%s", revbuf, timebuf);
@


1.74
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.73 2007/02/22 06:42:09 otto Exp $	*/
d122 1
a122 1
	char buf[128], timebuf[32], revbuf[32];
@


1.73
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.72 2007/02/09 03:49:15 joris Exp $	*/
d144 1
a144 1
	    (cf->file_rcs != NULL && cf->file_rcs->rf_inattic == 1)) {
@


1.72
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.71 2007/01/31 21:07:36 xsa Exp $	*/
d19 2
a20 1
#include "includes.h"
a22 1
#include "log.h"
@


1.71
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.70 2007/01/12 19:28:12 joris Exp $	*/
d127 1
a127 1
	cvs_file_classify(cf, NULL, 1);
@


1.70
log
@do not leak memory from rcs_head_get()

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.69 2007/01/11 02:35:55 joris Exp $	*/
a118 1
	int l;
d145 2
a146 3
		l = snprintf(buf, sizeof(buf), "no file %s\t", cf->file_name);
		if (l == -1 || l >= (int)sizeof(buf))
			fatal("cvs_status_local: overflow");
d154 1
a154 1
		l = snprintf(buf, sizeof(buf),
a155 2
		if (l == -1 || l >= (int)sizeof(buf))
			fatal("cvs_status_local: overflow");
d174 1
a174 3
		l = snprintf(buf, sizeof(buf), "%s\t%s", revbuf, timebuf);
		if (l == -1 || l >= (int)sizeof(buf))
			fatal("cvs_status_local: overflow");
d188 1
a188 1
		l = snprintf(buf, sizeof(buf), "%s\t%s", revbuf,
a189 2
		if (l == -1 || l >= (int)sizeof(buf))
			fatal("cvs_status_local: overflow");
@


1.69
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.68 2006/07/07 17:37:17 joris Exp $	*/
d121 1
d191 3
a193 2
		rcsnum_tostr(rcs_head_get(cf->file_rcs),
		    revbuf, sizeof(revbuf));
@


1.68
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.67 2006/07/07 13:01:40 joris Exp $	*/
d91 1
@


1.67
log
@fix segfault for newly added files.

found while test driving the new remote code.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.66 2006/06/19 05:05:17 joris Exp $	*/
d23 1
a24 1
int	cvs_status(int, char **);
d64 1
a64 1
	flags = CR_REPO | CR_RECURSE_DIRS;
d86 12
a97 1
	cr.fileproc = cvs_status_local;
d104 7
@


1.66
log
@kill local and remote callback and just have one called fileproc.
we let the commands pass the correct function.

all in preparation for remote.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.65 2006/06/16 14:07:42 joris Exp $	*/
d125 1
a125 1
	    cf->file_rcs->rf_inattic == 1) {
@


1.65
log
@in preparation for the new remote code, proto.h becomes obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.64 2006/06/07 15:21:47 xsa Exp $	*/
d86 1
a86 2
	cr.local = cvs_status_local;
	cr.remote = NULL;
@


1.64
log
@bring back -v support; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.63 2006/06/04 14:56:09 xsa Exp $	*/
a22 1
#include "proto.h"
d30 1
a30 1
	CVS_OP_STATUS, CVS_REQ_STATUS, "status",
@


1.63
log
@fix output if file is lost, unknown, or in the Attic; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.62 2006/06/01 20:00:52 joris Exp $	*/
d4 1
d28 2
d35 1
a35 1
	"lRv:",
d75 1
d106 1
d195 18
@


1.62
log
@major rewrite of some rcs parsing stuff:

- rework rcs_getrev() to correctly support branches
- rework rcs_translate_tag() to correctly translate given symbols or
  branches into their matching revisions
- rework rcs_rev_add() to correctly update its 'next' pointers
  and insert the new revision in the correct place on the list.
- rework rcs_head_get() to return the latest revision on the default
  branch if it has been set or the normal HEAD revision otherwise.
- no longer access the rf_head member of the RCSFILE struct manually,
  use the rcs_head_get() function which correctly returns the HEAD
  revision, there might be a default branch that has to be used.
- for now, when commiting a new revision reset the default branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.61 2006/05/30 21:32:52 joris Exp $	*/
d120 11
a130 1
	cvs_printf("File: %-17s\tStatus: %s\n\n", cf->file_name, status);
@


1.61
log
@fill in the correct revision number we will want in file_rcsrev
for each cvs_file struct, this will help us with sticky tags,
commiting to branches and importing into existing repositories.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.60 2006/05/30 07:24:08 xsa Exp $	*/
d158 2
a159 1
		rcsnum_tostr(cf->file_rcs->rf_head, revbuf, sizeof(revbuf));
@


1.60
log
@handle -q for Sticky Options and Sticky Tags output; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.59 2006/05/28 07:56:44 joris Exp $	*/
d105 1
a105 1
	cvs_file_classify(cf, 1);
@


1.59
log
@allow commands to shut up the output from cvs_file_classify
if the commands want to output certain stuff themselfs
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.58 2006/05/27 15:14:27 joris Exp $	*/
d169 1
a169 1
			cvs_printf("   Sticky Tag:\t%s\n",
d171 3
d177 2
@


1.58
log
@allow commands to respect the -l flag, if the -l flag is
specified certain commands will not recurse into directories.

at the same time introduce a method of specifying wether or not
a command should look in the repository for files.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.57 2006/05/27 03:30:31 joris Exp $	*/
d105 1
a105 1
	cvs_file_classify(cf);
@


1.57
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
	int ch;
d62 2
d67 1
d85 1
@


1.56
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.55 2006/04/12 14:31:05 xsa Exp $	*/
d3 1
a3 3
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * Copyright (c) 2005 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
d5 3
a7 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d9 7
a15 15
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d24 2
a25 21

#define CVS_STATUS_SEP \
 "==================================================================="

/* Keep this sorted as it is now. See file.h for status values. */
const char *cvs_statstr[] = {
	"Unknown",
	"Up-to-date",
	"Locally Modified",
	"Locally Added",
	"Locally Removed",
	"Unresolved Conflict",
	"Patched",
	"Needs Checkout",
};


static int cvs_status_init     (struct cvs_cmd *, int, char **, int *);
static int cvs_status_remote   (CVSFILE *, void *);
static int cvs_status_local    (CVSFILE *, void *);
static int cvs_status_pre_exec (struct cvsroot *);
d32 1
a32 8
	"lRv",
	NULL,
	CF_SORT | CF_IGNORE | CF_RECURSE,
	cvs_status_init,
	cvs_status_pre_exec,
	cvs_status_remote,
	cvs_status_local,
	NULL,
d34 1
a34 1
	CVS_CMD_ALLOWSPEC | CVS_CMD_SENDDIR | CVS_CMD_SENDARGS2
d37 2
a38 1
static int verbose = 0;
d40 17
a56 2
static int
cvs_status_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d59 2
d62 1
a62 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a64 1
			cmd->file_flags &= ~CF_RECURSE;
a66 1
			cmd->file_flags |= CF_RECURSE;
a68 1
			verbose = 1;
d71 1
a71 1
			return (CVS_EX_USAGE);
d75 2
a76 3
	*arg = optind;
	return (0);
}
d78 9
a86 7
static int
cvs_status_pre_exec(struct cvsroot *root)
{
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (verbose == 1)
			cvs_sendarg(root, "-v", 0);
	}
d91 2
a92 7
/*
 * cvs_status_remote()
 *
 * Get the status of a single file.
 */
static int
cvs_status_remote(CVSFILE *cfp, void *arg)
d94 4
a97 4
	char fpath[MAXPATHLEN];
	struct cvsroot *root;

	root = CVS_DIR_ROOT(cfp);
d99 1
a99 9
	if (cfp->cf_type == DT_DIR) {
		if (cfp->cf_cvstat == CVS_FST_UNKNOWN)
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
		else
			cvs_senddir(root, cfp);
		return (0);
	}

	cvs_file_getpath(cfp, fpath, sizeof(fpath));
d101 1
a101 17
	cvs_sendentry(root, cfp);

	switch (cfp->cf_cvstat) {
	case CVS_FST_UNKNOWN:
		cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
		break;
	case CVS_FST_UPTODATE:
		cvs_sendreq(root, CVS_REQ_UNCHANGED, cfp->cf_name);
		break;
	case CVS_FST_ADDED:
	case CVS_FST_MODIFIED:
		cvs_sendreq(root, CVS_REQ_MODIFIED, cfp->cf_name);
		cvs_sendfile(root, fpath);
		break;
	default:
		break;
	}
d103 1
a103 13
	return (0);
}

static int
cvs_status_local(CVSFILE *cf, void *arg)
{
	size_t n;
	char buf[MAXNAMLEN], fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
	char numbuf[64], timebuf[32];
	RCSFILE *rf;
	struct rcs_sym *sym;

	if (cf->cf_type == DT_DIR) {
d105 2
a106 2
			cvs_log(LP_NOTICE, "Examining %s", cf->cf_name);
		return (0);
d109 1
a109 10
	cvs_file_getpath(cf, fpath, sizeof(fpath));
	cvs_rcs_getpath(cf, rcspath, sizeof(rcspath));

	rf = NULL;
	if (cf->cf_cvstat != CVS_FST_UNKNOWN &&
	    cf->cf_cvstat != CVS_FST_ADDED) {
		if ((rf = rcs_open(rcspath, RCS_READ)) == NULL)
			fatal("cvs_status_local: rcs_open `%s': %s", rcspath,
			    rcs_errstr(rcs_errno));
	}
d111 16
a126 17
	buf[0] = '\0';

	if (cf->cf_cvstat == CVS_FST_UNKNOWN)
		cvs_log(LP_WARN, "nothing known about %s", cf->cf_name);

	if (cf->cf_cvstat == CVS_FST_LOST || cf->cf_cvstat == CVS_FST_UNKNOWN)
		strlcpy(buf, "no file ", sizeof(buf));
	strlcat(buf, cf->cf_name, sizeof(buf));

	cvs_printf(CVS_STATUS_SEP "\nFile: %-17s\tStatus: %s\n\n",
	    buf, cvs_statstr[cf->cf_cvstat]);

	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		strlcpy(buf, "No entry for ", sizeof(buf));
		strlcat(buf, cf->cf_name, sizeof(buf));
	} else if (cf->cf_cvstat == CVS_FST_ADDED) {
		strlcpy(buf, "New file!", sizeof(buf));
d128 1
a128 2
		rcsnum_tostr(cf->cf_lrev, numbuf, sizeof(numbuf));
		strlcpy(buf, numbuf, sizeof(buf));
d130 10
a139 8
		/* Display etime in local mode only. */
		if (cvs_cmdop != CVS_OP_SERVER) {
			strlcat(buf, "\t", sizeof(buf));

			ctime_r(&(cf->cf_etime), timebuf);
			n = strlen(timebuf);
			if (n > 0 && timebuf[n - 1] == '\n')
				timebuf[--n] = '\0';
d141 3
a143 2
			strlcat(buf, timebuf, sizeof(buf));
		}
d148 5
a152 3
	if (cf->cf_cvstat == CVS_FST_UNKNOWN ||
	    cf->cf_cvstat == CVS_FST_ADDED) {
		strlcpy(buf, "No revision control file", sizeof(buf));
d154 5
a158 4
		strlcpy(buf, rcsnum_tostr(rf->rf_head, numbuf, sizeof(numbuf)),
		    sizeof(buf));
		strlcat(buf, "\t", sizeof(buf));
		strlcat(buf, rcspath, sizeof(buf));
d163 7
a169 37
	/* If the file is unknown, no other output is needed after this. */
	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		cvs_printf("\n");
		return (0);
	}

	if (cf->cf_tag != NULL)
		cvs_printf("   Sticky Tag:\t\t%s\n", cf->cf_tag);
	else if (verbosity > 0)
		cvs_printf("   Sticky Tag:\t\t(none)\n");

	/* XXX */
	if (verbosity > 0)
		cvs_printf("   Sticky Date:\t\t%s\n", "(none)");

	if (cf->cf_opts != NULL)
		cvs_printf("   Sticky Options:\t%s\n", cf->cf_opts);
	else if (verbosity > 0)
		cvs_printf("   Sticky Options:\t(none)\n");

	if (verbose == 1) {
		cvs_printf("\n");
		cvs_printf("   Existing Tags:\n");

		if (!TAILQ_EMPTY(&(rf->rf_symbols))) {
			TAILQ_FOREACH(sym, &(rf->rf_symbols), rs_list) {
				rcsnum_tostr(sym->rs_num, numbuf,
				    sizeof(numbuf));

				cvs_printf("\t%-25s\t(%s: %s)\n",
				    sym->rs_name,
				    RCSNUM_ISBRANCH(sym->rs_num) ? "branch" :
				    "revision", numbuf);
			}
		} else {
			cvs_printf("\tNo Tags Exist\n");
		}
a172 5

	if (rf != NULL)
		rcs_close(rf);

	return (0);
@


1.55
log
@yet another missing break;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.54 2006/01/30 17:58:47 xsa Exp $	*/
d208 1
a208 1
			if ((n > 0) && (timebuf[n - 1] == '\n'))
@


1.54
log
@strerror() -> rcs_errstr() when passing rcs_errno as argument;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.53 2006/01/27 15:26:38 xsa Exp $	*/
d147 1
@


1.53
log
@more errors handling cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.52 2006/01/25 08:15:05 xsa Exp $	*/
d177 1
a177 1
			    strerror(rcs_errno));
@


1.52
log
@snprintf() cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.51 2006/01/02 08:11:56 xsa Exp $	*/
d175 3
a177 3
		rf = rcs_open(rcspath, RCS_READ);
		if (rf == NULL)
			return (CVS_EX_DATA);
@


1.51
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.50 2005/12/30 02:03:28 joris Exp $	*/
a156 1
	int len;
d193 2
a194 2
		len = snprintf(buf, sizeof(buf), "No entry for %s",
		    cf->cf_name);
d196 1
a196 1
		len = snprintf(buf, sizeof(buf), "New file!");
d199 1
a199 1
		len = snprintf(buf, sizeof(buf), "%s", numbuf);
a213 6
	if (len == -1 || len >= (int)sizeof(buf)) {
		if (rf != NULL)
			rcs_close(rf);
		return (CVS_EX_DATA);
	}

d218 1
a218 1
		len = snprintf(buf, sizeof(buf), "No revision control file");
d220 4
a223 9
		len = snprintf(buf, sizeof(buf), "%s\t%s",
		    rcsnum_tostr(rf->rf_head, numbuf, sizeof(numbuf)),
		    rcspath);
	}

	if (len == -1 || len >= (int)sizeof(buf)) {
		if (rf != NULL)
			rcs_close(rf);
		return (CVS_EX_DATA);
@


1.50
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.49 2005/12/22 14:59:54 xsa Exp $	*/
d28 1
a28 9
#include <sys/types.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.49
log
@cvs_rcs_getpath() cannot fail anymore;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.48 2005/09/22 16:13:44 xsa Exp $	*/
d112 2
a113 2
		if ((verbose == 1) && (cvs_sendarg(root, "-v", 0) < 0))
			return (CVS_EX_PROTO);
a126 1
	int ret;
a129 1
	ret = 0;
d134 1
a134 2
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    cfp->cf_name);
d136 2
a137 6
			ret = cvs_senddir(root, cfp);

		if (ret == -1)
			ret = CVS_EX_PROTO;

		return (ret);
d142 1
a142 2
	if (cvs_sendentry(root, cfp) < 0)
		return (CVS_EX_PROTO);
d146 1
a146 1
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
d149 1
a149 1
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED, cfp->cf_name);
d153 2
a154 3
		ret = cvs_sendreq(root, CVS_REQ_MODIFIED, cfp->cf_name);
		if (ret == 0)
			ret = cvs_sendfile(root, fpath);
d159 1
a159 4
	if (ret == -1)
		ret = CVS_EX_PROTO;

	return (ret);
@


1.48
log
@style;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.47 2005/09/05 20:03:22 xsa Exp $	*/
d191 1
a191 3

	if (cvs_rcs_getpath(cf, rcspath, sizeof(rcspath)) == NULL)
		return (CVS_EX_DATA);
@


1.47
log
@add warning message if file status is unknown;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.46 2005/08/17 18:33:55 joris Exp $	*/
d112 1
a112 1
		if (verbose && (cvs_sendarg(root, "-v", 0) < 0))
d282 1
a282 1
	if (verbose) {
@


1.46
log
@only close the RCS file if we opened it.
fixes a crash with newly added files.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.45 2005/08/17 08:35:53 xsa Exp $	*/
d204 4
@


1.45
log
@trailing whitespaces ...
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.44 2005/08/08 11:37:41 xsa Exp $	*/
d195 1
d298 3
a300 1
	rcs_close(rf);
@


1.44
log
@zap unused vars;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.43 2005/07/27 16:42:19 xsa Exp $	*/
d287 1
a287 1
				    sym->rs_name,  
@


1.43
log
@use LP_NOTICE instead of LP_INFO where appropriate;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.42 2005/07/22 16:27:29 joris Exp $	*/
d128 1
a128 2
	char *repo, fpath[MAXPATHLEN];
	RCSFILE *rf;
a131 1
	rf = NULL;
a132 1
	repo = CVS_DIR_REPO(cfp);
@


1.42
log
@use the cf_name field of the CVSFILE struct instead of using the old
CVS_FILE_NAME macro. This macro used to be nifty because of all
the referencing for the names, but since we don't do that anymore and
use cf_name directly... byebye CVS_FILE_NAME()

okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.41 2005/07/19 15:48:52 xsa Exp $	*/
d189 1
a189 1
			cvs_log(LP_INFO, "Examining %s", cf->cf_name);
@


1.41
log
@print existing tags if any (-v); long time ago Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.40 2005/07/14 06:54:59 xsa Exp $	*/
d140 1
a140 1
			    CVS_FILE_NAME(cfp));
@


1.40
log
@more use of cvs_rcs_getpath();
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.39 2005/07/10 13:58:19 xsa Exp $	*/
d4 1
d59 3
a61 3
static int cvs_status_init      (struct cvs_cmd *, int, char **, int *);
static int cvs_status_remote    (CVSFILE *, void *);
static int cvs_status_local     (CVSFILE *, void *);
d185 1
d279 19
@


1.39
log
@no need to declare the verbosity var here as it is already done in cvs.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.38 2005/07/08 12:45:10 xsa Exp $	*/
a182 1
	char *repo;
a183 1
	struct cvsroot *root;
a190 3
	root = CVS_DIR_ROOT(cf);
	repo = CVS_DIR_REPO(cf);

d193 1
a193 5
	len = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, CVS_FILE_NAME(cf), RCS_FILE_EXT);
	if (len == -1 || len >= (int)sizeof(rcspath)) {
		errno = ENAMETOOLONG;
		cvs_log(LP_ERRNO, "%s", rcspath);
a194 1
	}
@


1.38
log
@handle -Q correctly; Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.37 2005/07/08 11:46:23 xsa Exp $	*/
a55 2

extern int verbosity;
@


1.37
log
@if a file has been locally added, output correct info! Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.36 2005/07/08 10:10:48 xsa Exp $	*/
d276 13
a288 5
	cvs_printf("   Sticky Tag:\t\t%s\n",
	    cf->cf_tag == NULL ? "(none)" : cf->cf_tag);
	cvs_printf("   Sticky Date:\t\t%s\n", "(none)");
	cvs_printf("   Sticky Options:\t%s\n",
	    cf->cf_opts == NULL ? "(none)" : cf->cf_opts);
@


1.36
log
@hrmz spaces...
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.35 2005/07/08 07:22:58 xsa Exp $	*/
d208 2
a209 1
	if (cf->cf_cvstat != CVS_FST_UNKNOWN) {
d226 2
d229 2
a230 2
		len = snprintf(buf, sizeof(buf), "%s",
		    rcsnum_tostr(cf->cf_lrev, buf, sizeof(buf)));
d253 3
a255 2
	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		len = snprintf(buf, sizeof(buf), "No revision control file\n");
d271 2
a272 1
	if (cf->cf_cvstat == CVS_FST_UNKNOWN)
d274 1
@


1.35
log
@display in local mode only the mtime of a file stored in the Entries file;
Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.34 2005/07/07 15:52:26 joris Exp $	*/
d236 1
a236 1
                                        timebuf[--n] = '\0';
@


1.34
log
@

more snprintf(3) checks, check against the correct
size of the buffer, close RCSFILE on error.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.33 2005/07/07 15:10:17 xsa Exp $	*/
d182 3
a184 1
	char buf[MAXNAMLEN], fpath[MAXPATHLEN], numbuf[64], rcspath[MAXPATHLEN];
d228 12
@


1.33
log
@add info message when examining directories; Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.32 2005/07/07 14:08:41 joris Exp $	*/
d228 3
a230 1
	if (len == -1 || len >= (int)sizeof(len))
d232 1
d237 1
a237 1
		snprintf(buf, sizeof(buf), "%s", "No revision control file\n");
d239 1
a239 1
		snprintf(buf, sizeof(buf), "%s\t%s",
d242 6
@


1.32
log
@

snprintf(3) checks.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.31 2005/07/07 07:37:43 xsa Exp $	*/
d57 2
d187 3
a189 1
	if (cf->cf_type == DT_DIR)
d191 1
@


1.31
log
@add comment;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.30 2005/07/07 06:52:14 xsa Exp $	*/
d216 2
a217 1
		snprintf(buf, sizeof(buf), "No entry for %s", cf->cf_name);
d219 1
a219 1
		snprintf(buf, sizeof(buf), "%s",
d222 3
@


1.30
log
@display what we should in case the file is unknown to cvs. Ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.29 2005/07/06 09:52:16 xsa Exp $	*/
d45 1
a45 1

@


1.29
log
@correct file status strings;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.28 2005/07/05 16:14:47 xsa Exp $	*/
d180 1
a180 1
	char buf[MAXNAMLEN], fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
a192 5
	if (cf->cf_cvstat == CVS_FST_UNKNOWN) {
		cvs_log(LP_WARN, "I know nothing about %s", fpath);
		return (0);
	}

d201 5
a205 3
	rf = rcs_open(rcspath, RCS_READ);
	if (rf == NULL)
		return (CVS_EX_DATA);
d208 1
a208 1
	if (cf->cf_cvstat == CVS_FST_LOST)
d223 15
a237 2
	rcsnum_tostr(rf->rf_head, buf, sizeof(buf));
	cvs_printf("   Repository revision:\t%s\t%s\n", buf, rcspath);
@


1.28
log
@correct ouput to match gnu/usr.bin/cvs; more to come.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.27 2005/07/05 16:06:52 xsa Exp $	*/
d50 3
a52 3
	"Added",
	"Removed",
	"Conflict",
@


1.27
log
@`No' -> `no' in output; matches gnu/usr.bin/cvs output;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.26 2005/06/30 15:24:53 xsa Exp $	*/
d180 2
a181 1
	char *repo, buf[MAXNAMLEN], fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
d215 1
a215 1
	cvs_printf(CVS_STATUS_SEP "\nFile: %-18sStatus: %s\n\n",
d225 1
a225 1
	cvs_printf("   Working revision:    %s\n", buf);
d227 2
a228 2
	cvs_printf("   Repository revision: %s %s\n", buf, rcspath);
	cvs_printf("   Sticky Tag:          %s\n",
d230 2
a231 2
	cvs_printf("   Sticky Date:         %s\n", "(none)");
	cvs_printf("   Sticky Options:      %s\n",
@


1.26
log
@add missing method check in pre_exec handler ... spotted by joris@@.
options can be sent to server now without making it go crazy..
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.25 2005/06/30 09:42:14 xsa Exp $	*/
d211 1
a211 1
		strlcpy(buf, "No file ", sizeof(buf));
@


1.25
log
@missing \n in server-side output;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.24 2005/06/25 13:53:37 joris Exp $	*/
d110 5
a114 2
	if (verbose && (cvs_sendarg(root, "-v", 0) < 0))
		return (CVS_EX_PROTO);
@


1.24
log
@

match output with the one from GNU cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.23 2005/05/31 08:58:48 xsa Exp $	*/
d230 1
@


1.23
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.22 2005/05/24 04:12:25 jfb Exp $	*/
a176 1
	size_t sz;
a177 1
	char datebuf[26];
d217 2
a218 6
		ctime_r(&(cf->cf_mtime), datebuf);
		sz = strlen(datebuf);
		if ((sz > 0) && (datebuf[sz - 1] == '\n'))
			datebuf[--sz] = '\0';
		snprintf(buf, sizeof(buf), "%s %s",
		    rcsnum_tostr(cf->cf_lrev, buf, sizeof(buf)), datebuf);
@


1.22
log
@Merge the cvs_cmd and cvs_cmd_info structures and add the necessary
fields to hook local versions of the commands.  This needs to go in
before it gets any bigger

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.21 2005/05/20 20:00:53 joris Exp $	*/
d31 1
a32 1
#include <fcntl.h>
d34 1
a35 1
#include <string.h>
@


1.21
log
@

correct wrong error code usage.

ok jfb@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.20 2005/04/27 04:54:46 jfb Exp $	*/
d58 15
a72 8
int cvs_status_remote    (CVSFILE *, void *);
int cvs_status_local     (CVSFILE *, void *);
int cvs_status_options   (char *, int, char **, int *);
int cvs_status_sendflags (struct cvsroot *);

struct cvs_cmd_info cvs_status = {
	cvs_status_options,
	cvs_status_sendflags,
d74 3
a76 3
	NULL, NULL,
	CF_SORT | CF_IGNORE | CF_RECURSE,
	CVS_REQ_STATUS,
d82 2
a83 2
int
cvs_status_options(char *opt, int argc, char **argv, int *arg)
d87 1
a87 1
	while ((ch = getopt(argc, argv, opt)) != -1) {
d90 1
a90 1
			cvs_status.file_flags &= ~CF_RECURSE;
d93 1
a93 1
			cvs_status.file_flags |= CF_RECURSE;
d107 2
a108 2
int
cvs_status_sendflags(struct cvsroot *root)
d120 1
a120 1
int
d173 2
a174 2
int
cvs_status_local(CVSFILE *cfp, void *arg)
d176 2
a177 1
	int l;
d179 1
d183 1
a183 1
	if (cfp->cf_type == DT_DIR)
d186 2
a187 2
	root = CVS_DIR_ROOT(cfp);
	repo = CVS_DIR_REPO(cfp);
d189 1
a189 1
	cvs_file_getpath(cfp, fpath, sizeof(fpath));
d191 1
a191 1
	if (cfp->cf_cvstat == CVS_FST_UNKNOWN) {
d196 3
a198 3
	l = snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
	    root->cr_dir, repo, CVS_FILE_NAME(cfp), RCS_FILE_EXT);
	if (l == -1 || l >= (int)sizeof(rcspath)) {
d209 1
a209 1
	if (cfp->cf_cvstat == CVS_FST_LOST)
d211 1
a211 1
	strlcat(buf, CVS_FILE_NAME(cfp), sizeof(buf));
d214 1
a214 1
	    buf, cvs_statstr[cfp->cf_cvstat]);
d216 2
a217 3
	if (cfp->cf_cvstat == CVS_FST_UNKNOWN) {
		snprintf(buf, sizeof(buf), "No entry for %s",
		    CVS_FILE_NAME(cfp));
d219 4
d224 1
a224 2
		    rcsnum_tostr(cfp->cf_lrev, buf, sizeof(buf)),
		    "date here");
d230 2
a231 1
	cvs_printf("   Sticky Tag:          %s\n", "(none)");
d233 2
a234 1
	cvs_printf("   Sticky Options:      %s\n", "(none)");
@


1.20
log
@no need to query the Entries line for files anymore and a bit of cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.19 2005/04/18 21:02:50 jfb Exp $	*/
d132 4
d141 2
a142 3
	if (cvs_sendentry(root, cfp) < 0) {
		return (-1);
	}
d160 3
d192 1
a192 1
		return (-1);
d196 2
a197 3
	if (rf == NULL) {
		return (-1);
	}
@


1.19
log
@Modify the CVSFILE structure using a union to keep information about
both files and directories.  We can now keep the revision number for
regular files, and don't need to fetch the appropriate entry in the
command callbacks.  This saves a huge amount of parsing on Entries
files.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.18 2005/04/16 20:31:18 xsa Exp $	*/
d58 1
a58 1
int cvs_status_file      (CVSFILE *, void *);
d66 1
a66 1
	cvs_status_file,
d109 1
a109 1
 * cvs_status_file()
d114 1
a114 1
cvs_status_file(CVSFILE *cfp, void *arg)
d143 1
a143 2
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
		    CVS_FILE_NAME(cfp));
d146 1
a146 2
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED,
		    CVS_FILE_NAME(cfp));
d150 1
a150 2
		ret = cvs_sendreq(root, CVS_REQ_MODIFIED,
		    CVS_FILE_NAME(cfp));
a165 1
	struct cvs_ent *entp;
a174 1
	entp = cvs_ent_getent(fpath);
a185 2

		cvs_ent_free(entp);
a190 2
		if (entp != NULL)
			cvs_ent_free(entp);
d202 1
a202 1
	if (entp == NULL) {
d207 1
a207 1
		    rcsnum_tostr(entp->ce_rev, buf, sizeof(buf)),
a219 2
	if (entp != NULL)
		cvs_ent_free(entp);
@


1.18
log
@thought i had committed that earlier;snprintf return value check; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.17 2005/04/16 20:26:05 joris Exp $	*/
a118 1
	struct cvs_ent *entp;
a135 1
	entp = cvs_ent_getent(fpath);
d137 1
a137 2
	if ((entp != NULL) && (cvs_sendentry(root, entp) < 0)) {
		cvs_ent_free(entp);
a159 2
	if (entp != NULL)
		cvs_ent_free(entp);
@


1.17
log
@

make sure we send the correct stuff for newly added files that
are not commited yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.16 2005/04/12 16:56:07 jfb Exp $	*/
d171 1
d191 1
a191 1
	snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
d193 7
@


1.16
log
@handle files which have been lost or that have no associated entry
correctly when acting in local mode

spotted by joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.15 2005/04/12 16:13:59 jfb Exp $	*/
d153 1
@


1.15
log
@* 'Up to date' --> 'Up-to-date', and add the 'Lost' status string
* first stab at cvs_status_local(), which will run the command in
  local mode or remotely when acting as server (not hooked yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.14 2005/04/12 14:58:40 joris Exp $	*/
d54 1
a54 1
	"Lost",
d170 1
a170 1
	char *repo, numbuf[64], fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
d199 5
d205 10
a214 1
	    CVS_FILE_NAME(cfp), cvs_statstr[cfp->cf_cvstat]);
d216 3
a218 4
	rcsnum_tostr(entp->ce_rev, numbuf, sizeof(numbuf));
	cvs_printf("   Working revision:    %s %s\n", numbuf, "date here");
	rcsnum_tostr(rf->rf_head, numbuf, sizeof(numbuf));
	cvs_printf("   Repository revision: %s %s\n", numbuf, rcspath);
@


1.14
log
@

introduce our own set of error codes used by the commands to report
what exactly went wrong in case of an error.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.13 2005/04/11 18:02:58 joris Exp $	*/
d42 4
d48 1
a48 1
	"Up to date",
d54 1
d58 4
a61 3
int cvs_status_file(CVSFILE *, void *);
int cvs_status_options(char *, int, char **, int *);
int cvs_status_sendflags(struct cvsroot *);
d117 1
a117 1
	char *repo, fpath[MAXPATHLEN], rcspath[MAXPATHLEN];
d128 5
a132 8
		if (root->cr_method != CVS_METHOD_LOCAL) {
			if (cfp->cf_cvstat == CVS_FST_UNKNOWN)
				ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
				    CVS_FILE_NAME(cfp));
			else
				ret = cvs_senddir(root, cfp);
		}

d139 41
a179 5
	if (root->cr_method != CVS_METHOD_LOCAL) {
		if ((entp != NULL) && (cvs_sendentry(root, entp) < 0)) {
			cvs_ent_free(entp);
			return (CVS_EX_PROTO);
		}
d181 2
a182 22
		switch (cfp->cf_cvstat) {
		case CVS_FST_UNKNOWN:
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cfp));
			break;
		case CVS_FST_UPTODATE:
			ret = cvs_sendreq(root, CVS_REQ_UNCHANGED,
			    CVS_FILE_NAME(cfp));
			break;
		case CVS_FST_MODIFIED:
			ret = cvs_sendreq(root, CVS_REQ_MODIFIED,
			    CVS_FILE_NAME(cfp));
			if (ret == 0)
				ret = cvs_sendfile(root, fpath);
		default:
			break;
		}
	} else {
		if (cfp->cf_cvstat == CVS_FST_UNKNOWN) {
			cvs_log(LP_WARN, "I know nothing about %s", fpath);
			return (0);
		}
d184 4
a187 2
		snprintf(rcspath, sizeof(rcspath), "%s/%s/%s%s",
		    root->cr_dir, repo, CVS_FILE_NAME(cfp), RCS_FILE_EXT);
d189 2
a190 6
		rf = rcs_open(rcspath, RCS_READ);
		if (rf == NULL) {
			if (entp != NULL)
				cvs_ent_free(entp);
			return (CVS_EX_DATA);
		}
d192 5
a196 1
		rcs_close(rf);
d199 13
d214 1
a214 1
	return (ret);
@


1.13
log
@

don't include sysexits.h now we don't use those error codes
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.12 2005/04/11 17:56:27 joris Exp $	*/
d86 1
a86 1
			return (1);
d98 1
a98 1
		return (-1);
d139 1
a139 1
			return (-1);
d172 1
a172 1
			return (-1);
@


1.12
log
@

remove EX_USAGE error codes

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.11 2005/04/03 17:32:50 xsa Exp $	*/
a35 1
#include <sysexits.h>
@


1.11
log
@first round of EX_* exit codes removal; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.10 2005/03/30 17:43:04 joris Exp $	*/
d87 1
a87 1
			return (EX_USAGE);
@


1.10
log
@

move all the client commands to the new command framework.
eliminates a lot of duplicate code.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.9 2005/03/26 08:09:54 tedu Exp $	*/
d99 1
a99 1
		return (EX_PROTOCOL);
@


1.9
log
@fix a variety of things i found at coverity.  ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.8 2005/02/27 00:22:08 jfb Exp $	*/
d54 13
a66 1
int cvs_status_file (CVSFILE *, void *);
d68 1
a69 6
/*
 * cvs_status()
 *
 * Handler for the `cvs status' command.
 * Returns 0 on success, or one of the known exit codes on error.
 */
d71 1
a71 1
cvs_status(int argc, char **argv)
d73 1
a73 5
	int i, ch, flags, verbose;
	struct cvsroot *root;

	verbose = 0;
	flags = CF_SORT|CF_IGNORE|CF_RECURSE;
d75 1
a75 1
	while ((ch = getopt(argc, argv, "lRv")) != -1) {
d78 1
a78 1
			flags &= ~CF_RECURSE;
d81 1
a81 1
			flags |= CF_RECURSE;
d91 3
a93 38
	argc -= optind;
	argv += optind;

	if (argc == 0) {
		cvs_files = cvs_file_get(".", flags);
	} else {
		cvs_files = cvs_file_getspec(argv, argc, 0);
	}
	if (cvs_files == NULL)
		return (EX_DATAERR);

	root = CVS_DIR_ROOT(cvs_files);
	if (root == NULL) {
		cvs_log(LP_ERR,
		    "No CVSROOT specified!  Please use the `-d' option");
		cvs_log(LP_ERR,
		    "or set the CVSROOT environment variable.");
		return (EX_USAGE);
	}

	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_connect(root) < 0)
			return (EX_PROTOCOL);
		if (verbose && (cvs_sendarg(root, "-v", 0) < 0))
			return (EX_PROTOCOL);
	}

	cvs_file_examine(cvs_files, cvs_status_file, NULL);

	if (root->cr_method != CVS_METHOD_LOCAL) {
		if (cvs_senddir(root, cvs_files) < 0)
			return (EX_PROTOCOL);
		for (i = 0; i < argc; i++)
			if (cvs_sendarg(root, argv[i], 0) < 0)
				return (EX_PROTOCOL);
		if (cvs_sendreq(root, CVS_REQ_STATUS, NULL) < 0)
			return (EX_PROTOCOL);
	}
d95 5
a101 1

@


1.8
log
@Many improvements to the RCS support:

- make it possible to specify creation and the file mode
  in rcs_open()
- implicitly write the contents to disk on rcs_close() if the
  RCS handle has been changed
- fix a bug in the output of the `expand' keyword
- add functions to retrieve and modify the expansion mode
- rcs_parse() shouldn't be available to the outside
- empty string instead of `(null)' if there is no description

ok Joris
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.7 2005/01/06 20:39:27 jfb Exp $	*/
d199 2
a200 1
			cvs_ent_free(entp);
@


1.7
log
@the status command now supports the same arguments as its gnu cvs
counterpart (-lRv)
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.6 2004/12/21 18:32:10 jfb Exp $	*/
d197 1
a197 1
		rf = rcs_open(rcspath, RCS_MODE_READ);
@


1.6
log
@modify the directory handling portion to behave like the one in add.c,
which does not attempt to send data when running on a local
repository.  This will be needed to support local repository access
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.5 2004/12/14 22:30:48 jfb Exp $	*/
d66 1
a66 1
	int i, ch, flags;
d69 1
d72 1
a72 1
	while ((ch = getopt(argc, argv, "F:flm:Rr:")) != -1) {
d74 9
d108 6
a113 2
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cvs_connect(root) < 0))
		return (EX_PROTOCOL);
@


1.5
log
@First attempt at syncing the command code and doing a lot more error
checking on all the protocol calls
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.4 2004/12/07 17:10:56 tedu Exp $	*/
d136 11
a146 2
	if ((root->cr_method != CVS_METHOD_LOCAL) && (cfp->cf_type == DT_DIR))
		return (cvs_senddir(root, cfp));
@


1.4
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.3 2004/12/06 21:03:13 deraadt Exp $	*/
d67 1
a67 1
	struct cvs_file *cf;
a68 1
	cf = NULL;
d82 20
a101 4
		cf = cvs_file_get(".", flags);
		if (cf == NULL) {
			return (EX_DATAERR);
		}
d103 8
a110 5
		cvs_file_examine(cf, cvs_status_file, NULL);
	} else {
		for (i = 0; i < argc; i++) {
			cf = cvs_file_get(argv[i], flags);
		}
d125 1
d131 1
a131 15
	cvs_file_getpath(cfp, fpath, sizeof(fpath));
	cvs_log(LP_DEBUG, "%s: getting status for %s", __func__, fpath);

	if (cfp->cf_type == DT_DIR) {
		root = cfp->cf_ddat->cd_root;
		if ((cfp->cf_parent == NULL) ||
		    (root != cfp->cf_parent->cf_ddat->cd_root)) {
			cvs_connect(root);
		}

		cvs_senddir(root, cfp);
		return (0);
	} else
		root = cfp->cf_parent->cf_ddat->cd_root;

d133 2
a134 4
	if (cfp->cf_parent != NULL)
		repo = cfp->cf_parent->cf_ddat->cd_repo;
	else
		repo = NULL;
d136 2
a137 8
	if (cfp->cf_cvstat == CVS_FST_UNKNOWN) {
		if (root->cr_method == CVS_METHOD_LOCAL)
			cvs_log(LP_WARN, "I know nothing about %s", fpath);
		else
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    CVS_FILE_NAME(cfp));
		return (0);
	}
d139 1
a140 2
	if (entp == NULL)
		return (-1);
d143 1
a143 1
		if (cvs_sendentry(root, entp) < 0) {
a146 1
	}
d148 11
a158 3
	if (cfp->cf_cvstat == CVS_FST_UPTODATE) {
		if (root->cr_method != CVS_METHOD_LOCAL)
			cvs_sendreq(root, CVS_REQ_UNCHANGED,
d160 10
a169 3
		cvs_ent_free(entp);
		return (0);
	}
a170 5
	/* at this point, the file is modified */
	if (root->cr_method != CVS_METHOD_LOCAL) {
		cvs_sendreq(root, CVS_REQ_MODIFIED, CVS_FILE_NAME(cfp));
		cvs_sendfile(root, fpath);
	} else {
d182 4
a185 2
	cvs_ent_free(entp);
	return (0);
@


1.3
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: status.c,v 1.2 2004/11/26 16:23:50 jfb Exp $	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a56 2


a62 1

a103 1

d128 1
a128 1
	if (cfp->cf_parent != NULL) {
d130 1
a130 1
	} else {
a131 1
	}
@


1.2
log
@Rewrite the internals of the file management code so that we do not keep
a full path to each file we load, and cache file names so we can have
multiple references to a single name.  This saves a lot of memory on large
trees such as /usr/src, especially on 'Makefile', 'README' and such.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
a92 2
	}
	else {
d128 1
a128 2
	}
	else
d134 1
a134 2
	}
	else {
d170 1
a170 2
	}
	else {
@


1.1
log
@Plug in the handler for `cvs status'
@
text
@a87 1
			printf("FUCK!\n");
d110 1
a110 1
cvs_status_file(struct cvs_file *cfp, void *arg)
d112 1
a112 1
	char *dir, *repo, rcspath[MAXPATHLEN];
d117 2
a118 1
	cvs_log(LP_DEBUG, "%s: getting status for %s", __func__, cfp->cf_path);
a134 1
		dir = cfp->cf_parent->cf_path;
a137 1
		dir = ".";
d143 1
a143 2
			cvs_log(LP_WARN, "I know nothing about %s",
			    cfp->cf_path);
d145 2
a146 1
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cfp->cf_name);
d150 1
a150 1
	entp = cvs_ent_getent(cfp->cf_path);
d163 2
a164 1
			cvs_sendreq(root, CVS_REQ_UNCHANGED, cfp->cf_name);
d171 2
a172 2
		cvs_sendreq(root, CVS_REQ_MODIFIED, cfp->cf_name);
		cvs_sendfile(root, cfp->cf_path);
d176 1
a176 1
		    root->cr_dir, repo, cfp->cf_name, RCS_FILE_EXT);
@

