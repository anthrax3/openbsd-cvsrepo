head	1.103;
access;
symbols
	OPENBSD_6_1:1.102.0.4
	OPENBSD_6_1_BASE:1.102
	OPENBSD_6_0:1.101.0.14
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.101.0.10
	OPENBSD_5_9_BASE:1.101
	OPENBSD_5_8:1.101.0.12
	OPENBSD_5_8_BASE:1.101
	OPENBSD_5_7:1.101.0.4
	OPENBSD_5_7_BASE:1.101
	OPENBSD_5_6:1.101.0.8
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.101.0.6
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.101.0.2
	OPENBSD_5_4_BASE:1.101
	OPENBSD_5_3:1.100.0.4
	OPENBSD_5_3_BASE:1.100
	OPENBSD_5_2:1.100.0.2
	OPENBSD_5_2_BASE:1.100
	OPENBSD_5_1_BASE:1.99
	OPENBSD_5_1:1.99.0.4
	OPENBSD_5_0:1.99.0.2
	OPENBSD_5_0_BASE:1.99
	OPENBSD_4_9:1.98.0.2
	OPENBSD_4_9_BASE:1.98
	OPENBSD_4_8:1.94.0.2
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.93.0.2
	OPENBSD_4_7_BASE:1.93
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.92.0.4
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.92.0.2
	OPENBSD_4_4_BASE:1.92
	OPENBSD_4_3:1.90.0.2
	OPENBSD_4_3_BASE:1.90
	OPENBSD_4_2:1.77.0.2
	OPENBSD_4_2_BASE:1.77
	OPENBSD_4_1:1.75.0.2
	OPENBSD_4_1_BASE:1.75
	OPENBSD_4_0:1.69.0.2
	OPENBSD_4_0_BASE:1.69
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.103
date	2017.08.28.19.33.20;	author otto;	state Exp;
branches;
next	1.102;
commitid	pt4iCZKa4LhAa1TL;

1.102
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.101;
commitid	8Vv7d4HkmCtExfc6;

1.101
date	2013.06.03.17.04.35;	author jcs;	state Exp;
branches;
next	1.100;

1.100
date	2012.07.02.21.56.25;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2011.06.03.10.02.25;	author chl;	state Exp;
branches;
next	1.98;

1.98
date	2010.10.31.15.37.34;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2010.10.20.19.53.53;	author tobias;	state Exp;
branches;
next	1.96;

1.96
date	2010.09.03.08.37.52;	author tobias;	state Exp;
branches;
next	1.95;

1.95
date	2010.08.31.20.42.45;	author tobias;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.25.21.19.20;	author joris;	state Exp;
branches;
next	1.92;

1.92
date	2008.06.15.04.38.52;	author tobias;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.12.16.17.55;	author joris;	state Exp;
branches;
next	1.90;

1.90
date	2008.03.02.19.31.08;	author tobias;	state Exp;
branches;
next	1.89;

1.89
date	2008.03.01.20.03.56;	author joris;	state Exp;
branches;
next	1.88;

1.88
date	2008.02.27.22.34.04;	author joris;	state Exp;
branches;
next	1.87;

1.87
date	2008.02.09.14.03.20;	author joris;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.31.22.19.36;	author tobias;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.31.20.29.16;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2008.01.10.10.06.59;	author tobias;	state Exp;
branches;
next	1.83;

1.83
date	2008.01.10.09.54.04;	author tobias;	state Exp;
branches;
next	1.82;

1.82
date	2008.01.10.09.39.32;	author tobias;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.11.10.01.41;	author tobias;	state Exp;
branches;
next	1.80;

1.80
date	2007.10.09.12.59.53;	author tobias;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.24.13.44.20;	author joris;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.13.13.10.57;	author tobias;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.01.17.47.47;	author niallo;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.26.20.58.36;	author niallo;	state Exp;
branches;
next	1.75;

1.75
date	2007.02.19.11.40.00;	author otto;	state Exp;
branches;
next	1.74;

1.74
date	2007.02.12.14.35.28;	author xsa;	state Exp;
branches;
next	1.73;

1.73
date	2007.01.14.23.10.56;	author joris;	state Exp;
branches;
next	1.72;

1.72
date	2007.01.13.04.18.50;	author joris;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.12.23.32.01;	author niallo;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.12.17.25.33;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2006.06.09.14.57.13;	author xsa;	state Exp;
branches;
next	1.68;

1.68
date	2006.06.01.20.00.52;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.31.18.26.14;	author joris;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.30.19.16.51;	author joris;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.29.07.15.52;	author joris;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.28.10.14.59;	author joris;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.28.01.24.28;	author joris;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.27.03.30.31;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2006.04.14.22.33.15;	author niallo;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.13.19.55.41;	author joris;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.13.19.16.15;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.10.08.08.00;	author xsa;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.30.23.06.25;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.30.06.11.03;	author ray;	state Exp;
branches;
next	1.55;

1.55
date	2006.03.30.06.07.35;	author ray;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.27.21.56.32;	author niallo;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.27.15.26.12;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.27.07.14.13;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.24.03.22.03;	author ray;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.23.02.21.33;	author ray;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.09.10.56.33;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.07.01.40.52;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.05.14.18.56;	author niallo;	state Exp;
branches;
next	1.46;

1.46
date	2006.02.09.08.08.56;	author niallo;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.02.09.42.20;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.30.16.53.55;	author niallo;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.27.16.05.21;	author niallo;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.08.18.56.10;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.03.15.31.53;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.03.01.02.09;	author joris;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.01.18.22.09;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.02.20.32.44;	author niallo;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.29.19.05.50;	author niallo;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.22.17.32.57;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2005.10.15.22.56.03;	author niallo;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.10.23.37.15;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.10.13.06.24;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.07.23.59.56;	author niallo;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.02.11.48.56;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.25.11.28.59;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.26.01.45.54;	author jfb;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.25.21.59.16;	author jfb;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.25.21.32.31;	author jfb;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.25.10.23.57;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.25.07.15.16;	author jfb;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.25.06.42.41;	author jfb;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.20.23.11.30;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.19.19.22.31;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.13.15.50.49;	author jfb;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.11.20.32.56;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.07.22.08.57;	author jfb;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.07.20.50.22;	author jfb;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.06.19.12.08;	author jfb;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.13.22.07.49;	author jfb;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.05.18.25.30;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.05.05.58.39;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.05.05.00.56;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.05.03.30.29;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.04.18.21.00;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.02.04.19.34;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.27.00.22.08;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.25.20.05.41;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.13.20.50.57;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.12.19.23.27;	author jfb;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.03.22.10.12;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.16.17.16.18;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.15.05.09.06;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.103
log
@fix const related warnings; ok millert@@
@
text
@/*	$OpenBSD: rcs.h,v 1.102 2016/10/13 20:51:25 fcambus Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef RCS_H
#define RCS_H

#include <stdio.h>
#include <time.h>

#include "buf.h"

#define RCS_DIFF_DIV \
	"==================================================================="

#define RCS_FILE_EXT		",v"

#define RCS_HEAD_BRANCH		"HEAD"
#define RCS_HEAD_INIT		"1.1"
#define RCS_HEAD_REV		((RCSNUM *)(-1))

#define RCS_CONFLICT_MARKER1	"<<<<<<< "
#define RCS_CONFLICT_MARKER2	">>>>>>> "
#define RCS_CONFLICT_MARKER3	"=======\n"

#define RCS_SYM_INVALCHAR	"$,.:;@@"

#define RCS_MAGIC_BRANCH	".0."
#define RCS_STATE_EXP		"Exp"
#define RCS_STATE_DEAD		"dead"

/* lock types */
#define RCS_LOCK_INVAL		(-1)
#define RCS_LOCK_LOOSE		0
#define RCS_LOCK_STRICT		1

/*
 * Keyword expansion table
 */
#define RCS_KW_AUTHOR		0x1000
#define RCS_KW_DATE		0x2000
#define RCS_KW_LOG		0x4000
#define RCS_KW_NAME		0x8000
#define RCS_KW_RCSFILE		0x0100
#define RCS_KW_REVISION		0x0200
#define RCS_KW_SOURCE		0x0400
#define RCS_KW_STATE		0x0800
#define RCS_KW_FULLPATH		0x0010
#define RCS_KW_MDOCDATE		0x0020
#define RCS_KW_LOCKER		0x0040

#define RCS_KW_ID \
	(RCS_KW_RCSFILE | RCS_KW_REVISION | RCS_KW_DATE \
	| RCS_KW_AUTHOR | RCS_KW_STATE)

#define RCS_KW_HEADER	(RCS_KW_ID | RCS_KW_FULLPATH)

/* RCS keyword expansion modes (kflags) */
#define RCS_KWEXP_NONE	0x01	/* do not expand keywords */
#define RCS_KWEXP_NAME	0x02	/* include keyword name */
#define RCS_KWEXP_VAL	0x04	/* include keyword value */
#define RCS_KWEXP_LKR	0x08	/* include name of locker */
#define RCS_KWEXP_OLD	0x10	/* generate old keyword string */
#define RCS_KWEXP_ERR	0x20	/* mode has an error */

#define RCS_KWEXP_DEFAULT	(RCS_KWEXP_NAME | RCS_KWEXP_VAL)
#define RCS_KWEXP_KVL		(RCS_KWEXP_NAME | RCS_KWEXP_VAL | RCS_KWEXP_LKR)

#define RCS_KWEXP_INVAL(k) \
	((k & RCS_KWEXP_ERR) || \
	((k & RCS_KWEXP_OLD) && (k & ~RCS_KWEXP_OLD)))

struct rcs_kw {
	char	kw_str[16];
	int	kw_type;
};

#define RCS_NKWORDS	(sizeof(rcs_expkw)/sizeof(rcs_expkw[0]))

#define RCSNUM_MAXNUM	USHRT_MAX
#define RCSNUM_MAXLEN	16
#define RCSNUM_MAXSTR	64

#define RCSNUM_ISBRANCH(n)	((n)->rn_len % 2)
#define RCSNUM_ISBRANCHREV(n)	(!((n)->rn_len % 2) && ((n)->rn_len >= 4))

/* file flags */
#define RCS_READ	  (1<<0)
#define RCS_WRITE	  (1<<1)  /* flush changes on rcs_close() */
#define RCS_CREATE	  (1<<2)  /* create the file */
#define RCS_PARSE_FULLY   (1<<3)  /* fully parse it on open */

/* internal flags */
#define RCS_PARSED	  (1<<4)  /* file has been parsed */
#define RCS_SYNCED	  (1<<5)  /* in-mem copy is sync with disk copy */
#define RCS_SLOCK	  (1<<6)  /* strict lock */

/* parser flags */
#define PARSED_DELTAS     (1<<7)  /* all deltas are parsed */
#define PARSED_DESC       (1<<8)  /* the description is parsed */
#define PARSED_DELTATEXTS (1<<9)  /* all delta texts are parsed */

/* delta flags */
#define RCS_RD_DEAD	0x01	/* dead */
#define RCS_RD_SELECT	0x02	/* select for operation */

/* commitids in cvs/cvsnt can be up to 64 bytes */
#define RCS_COMMITID_MAXLEN 64

typedef struct rcs_num {
	u_int		 rn_len;
	u_int16_t	 rn_id[RCSNUM_MAXLEN];
} RCSNUM;

struct rcs_access {
	char			*ra_name;
	TAILQ_ENTRY(rcs_access)	 ra_list;
};

struct rcs_sym {
	char			*rs_name;
	RCSNUM			*rs_num;
	TAILQ_ENTRY(rcs_sym)	 rs_list;
};

struct rcs_lock {
	char	*rl_name;
	RCSNUM	*rl_num;

	TAILQ_ENTRY(rcs_lock)	 rl_list;
};

struct rcs_branch {
	RCSNUM			*rb_num;
	TAILQ_ENTRY(rcs_branch)	 rb_list;
};

TAILQ_HEAD(rcs_dlist, rcs_delta);

struct rcs_delta {
	RCSNUM		*rd_num;
	RCSNUM		*rd_next;
	int		 rd_flags;
	struct tm	 rd_date;
	char		*rd_author;
	char		*rd_state;
	char		*rd_commitid;
	char		*rd_log;
	char		*rd_locker;
	u_char		*rd_text;
	size_t		 rd_tlen;

	TAILQ_HEAD(, rcs_branch)	rd_branches;
	TAILQ_ENTRY(rcs_delta)		rd_list;
};


typedef struct rcs_file {
	FILE	*rf_file;
	int	 rf_dead;
	char	*rf_path;
	mode_t	 rf_mode;
	int	 rf_flags;

	RCSNUM	*rf_head;
	RCSNUM	*rf_branch;
	char	*rf_comment;
	char	*rf_expand;
	char	*rf_desc;

	u_int					rf_ndelta;
	struct rcs_dlist			rf_delta;
	TAILQ_HEAD(rcs_alist, rcs_access)	rf_access;
	TAILQ_HEAD(rcs_slist, rcs_sym)		rf_symbols;
	TAILQ_HEAD(rcs_llist, rcs_lock)		rf_locks;

	void	*rf_pdata;
} RCSFILE;

struct rcs_line;
struct rcs_lines;

RCSFILE			*rcs_open(const char *, int, int, ...);
void			 rcs_close(RCSFILE *);
RCSNUM			*rcs_head_get(RCSFILE *);
int			 rcs_head_set(RCSFILE *, RCSNUM *);
RCSNUM			*rcs_branch_new(RCSFILE *, RCSNUM *);
const RCSNUM		*rcs_branch_get(RCSFILE *);
int			 rcs_branch_set(RCSFILE *, const RCSNUM *);
int			 rcs_access_add(RCSFILE *, const char *);
int			 rcs_access_remove(RCSFILE *, const char *);
int			 rcs_access_check(RCSFILE *, const char *);
struct rcs_delta	*rcs_findrev(RCSFILE *, RCSNUM *);
int			 rcs_sym_add(RCSFILE *, const char *, RCSNUM *);
int			 rcs_sym_check(const char *);
struct rcs_sym		*rcs_sym_get(RCSFILE *, const char *);
int			 rcs_sym_remove(RCSFILE *, const char *);
RCSNUM			*rcs_sym_getrev(RCSFILE *, const char *);
RCSNUM			*rcs_translate_tag(const char *, RCSFILE *);
int			 rcs_lock_getmode(RCSFILE *);
int			 rcs_lock_setmode(RCSFILE *, int);
int			 rcs_lock_add(RCSFILE *, const char *, RCSNUM *);
int			 rcs_lock_remove(RCSFILE *, const char *, RCSNUM *);
int			 rcs_deltatext_set(RCSFILE *, RCSNUM *, BUF *);
const char		*rcs_desc_get(RCSFILE *);
void			 rcs_desc_set(RCSFILE *, const char *);
const char		*rcs_comment_lookup(const char *);
const char		*rcs_comment_get(RCSFILE *);
void			 rcs_comment_set(RCSFILE *, const char *);
BUF			*rcs_kwexp_buf(BUF *, RCSFILE *, RCSNUM *);
void			 rcs_kwexp_set(RCSFILE *, int);
int			 rcs_kwexp_get(RCSFILE *);
int			 rcs_rev_add(RCSFILE *, RCSNUM *, const char *, time_t,
			     const char *);
time_t			 rcs_rev_getdate(RCSFILE *, RCSNUM *);
int			 rcs_rev_setlog(RCSFILE *, RCSNUM *, const char *);
int			 rcs_rev_remove(RCSFILE *, RCSNUM *);
int			 rcs_state_set(RCSFILE *, RCSNUM *, const char *);
const char		*rcs_state_get(RCSFILE *, RCSNUM *);
int			 rcs_state_check(const char *);
RCSNUM			*rcs_tag_resolve(RCSFILE *, const char *);
void			 rcs_write(RCSFILE *);
int			 rcs_rev_write_stmp(RCSFILE *,  RCSNUM *, char *, int);
void			 rcs_rev_write_fd(RCSFILE *, RCSNUM *, int, int);
struct rcs_lines	*rcs_rev_getlines(RCSFILE *, RCSNUM *,
			     struct rcs_line ***);
void			 rcs_annotate_getlines(RCSFILE *, RCSNUM *,
			     struct rcs_line ***);
BUF			*rcs_rev_getbuf(RCSFILE *, RCSNUM *, int);
void			 rcs_delta_stats(struct rcs_delta *, int *, int *);

int	rcs_kflag_get(const char *);
void	rcs_kflag_usage(void);
int	rcs_kw_expand(RCSFILE *, u_char *, size_t, size_t *);

RCSNUM	*rcsnum_alloc(void);
RCSNUM	*rcsnum_parse(const char *);
RCSNUM	*rcsnum_brtorev(const RCSNUM *);
RCSNUM	*rcsnum_revtobr(const RCSNUM *);
RCSNUM	*rcsnum_inc(RCSNUM *);
RCSNUM	*rcsnum_dec(RCSNUM *);
RCSNUM	*rcsnum_branch_root(RCSNUM *);
RCSNUM	*rcsnum_new_branch(RCSNUM *);
int	 rcsnum_addmagic(RCSNUM *);
int	 rcsnum_aton(const char *, const char **, RCSNUM *);
char	*rcsnum_tostr(const RCSNUM *, char *, size_t);
void	 rcsnum_cpy(const RCSNUM *, RCSNUM *, u_int);
int	 rcsnum_cmp(RCSNUM *, RCSNUM *, u_int);
int	 rcsnum_differ(RCSNUM *, RCSNUM *);

#endif	/* RCS_H */
@


1.102
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.101 2013/06/03 17:04:35 jcs Exp $	*/
d267 1
a267 1
int	 rcsnum_aton(const char *, char **, RCSNUM *);
@


1.101
log
@properly handle commitid tokens found in rcs files

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.100 2012/07/02 21:56:25 tedu Exp $	*/
a265 1
void	 rcsnum_free(RCSNUM *);
@


1.100
log
@simplify rcsnum parsing by using a fixed array without all the realloc
ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.99 2011/06/03 10:02:25 chl Exp $	*/
d129 3
d169 1
@


1.99
log
@add missing header, needed by the use of struct tm

ok nicm@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.98 2010/10/31 15:37:34 nicm Exp $	*/
d103 2
a104 1
#define RCSNUM_MAXLEN	64
d131 1
a131 1
	u_int16_t	*rn_id;
@


1.98
log
@init was passing a writable file descriptor into rcs_open which was then
failing to fdopen() it as readable. It doesn't need to pass in the fd at
all, so just change it to pass -1 which makes cvs init work again.

In fact, the fd should never need to be writable - it is only used for
reading. RCS_WRITE triggers a rewrite on the file on rcs_close() but
this is done by using a temporary and rename(2) (RCS_WRITE is a poor
name for the flag). So while here, add a couple of comments to hopefully
make it a little clearer. There is some confusion about how this is used
in other places but checking those is a separate issue.

with and ok tobias
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.97 2010/10/20 19:53:53 tobias Exp $	*/
d31 1
@


1.97
log
@Remove the need for rp_file in parser structure, instead keep only one
FILE pointer in RCSFILE.  This fixes some ugliness in closing an
fdopen()ed FILE and its underlying file descriptor.

Notified by Joerg Sonnenberger <joerg at britannica dot bec to de>

discussed with and ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.96 2010/09/03 08:37:52 tobias Exp $	*/
d109 1
a109 1
#define RCS_WRITE	  (1<<1)
@


1.96
log
@Rename RCSNUM's fd to rf_fd, complies to other variable names and
OpenRCS.

ok xsa, zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.95 2010/08/31 20:42:45 tobias Exp $	*/
d29 3
d175 1
a175 1
	int	 rf_fd;
@


1.95
log
@Removed ra_uid, which was supposed to save the uid of a delta's author.
Is not used and not useful.

ok xsa, zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.94 2010/07/23 21:46:05 ray Exp $	*/
d172 1
a172 1
	int	fd;
@


1.94
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.93 2009/03/25 21:19:20 joris Exp $	*/
a130 1
	uid_t			 ra_uid;
@


1.93
log
@remove unused functions, definitions and outdated comments
from the stone ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.92 2008/06/15 04:38:52 tobias Exp $	*/
d145 1
a145 1
	TAILQ_ENTRY(rcs_lock)	rl_list;
d150 1
a150 1
	TAILQ_ENTRY(rcs_branch)	rb_list;
d194 2
a195 2
struct cvs_line;
struct cvs_lines;
d239 2
a240 2
struct cvs_lines	*rcs_rev_getlines(RCSFILE *, RCSNUM *,
			     struct cvs_line ***);
d242 1
a242 1
			     struct cvs_line ***);
@


1.92
log
@Support the addition of new files in branches.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.91 2008/06/12 16:17:55 joris Exp $	*/
a30 1
#define RCS_DIFF_MAXARG		32
a33 1
#define RCSDIR			"RCS"
a45 1

a54 1

a90 1

a106 1
#define RCS_RDWR	  (RCS_READ|RCS_WRITE)
a123 6
/* used for rcs_checkout_rev */
#define CHECKOUT_REV_CREATED	1
#define CHECKOUT_REV_MERGED	2
#define CHECKOUT_REV_REMOVED	3
#define CHECKOUT_REV_UPDATED	4

a128 1

a146 1

@


1.91
log
@You successfully cast 'remove dead cruft'
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.90 2008/03/02 19:31:08 tobias Exp $	*/
d215 1
@


1.90
log
@rcs_errno is gone: zap rcs_errstr() and rcs_errstrs[] as well.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.89 2008/03/01 20:03:56 joris Exp $	*/
a128 9

/* RCS error codes */
#define RCS_ERR_NOERR	0
#define RCS_ERR_NOENT	1
#define RCS_ERR_DUPENT	2
#define RCS_ERR_BADNUM	3
#define RCS_ERR_BADSYM	4
#define RCS_ERR_PARSE	5
#define RCS_ERR_ERRNO	255
@


1.89
log
@goodbye rcs_errno - we didnt use you and you wont be missed
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.88 2008/02/27 22:34:04 joris Exp $	*/
a257 1
const char		*rcs_errstr(int);
@


1.88
log
@prevent file races

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.87 2008/02/09 14:03:20 joris Exp $	*/
a216 1
extern int rcs_errno;
@


1.87
log
@- always remove the additional .0 from magic branches, even when
  running the log command.

- change getlog.c so it will add any .0 for magic branches in its output
  if required


less confusing for rcs_translate_tag();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.86 2008/01/31 22:19:36 tobias Exp $	*/
d261 1
a261 1
void			 rcs_rev_write_stmp(RCSFILE *,  RCSNUM *, char *, int);
@


1.86
log
@Handle magic branch numbers in OpenCVS as well.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.85 2008/01/31 20:29:16 joris Exp $	*/
a107 1
#define RCSNUM_NO_MAGIC		(1<<0)
a288 2

extern int rcsnum_flags;
@


1.85
log
@add changed lines support to log and rlog (the + and - stuff)
from Pierre Riteau;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.84 2008/01/10 10:06:59 tobias Exp $	*/
d284 1
@


1.84
log
@rcs_getrev is gone: zap prototype, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.83 2008/01/10 09:54:04 tobias Exp $	*/
d269 1
@


1.83
log
@Our keyword expansion had a big flaw, due to this construction:
if (!(mode & RCS_KWEXP_NONE))

RCS_KWEXP_NONE is defined to 0, so expansion happened always.

Left shifted all RCS_KWEXP defines and looked carefully at hard-coded values
throughout the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.82 2008/01/10 09:39:32 tobias Exp $	*/
a241 1
BUF			*rcs_getrev(RCSFILE *, RCSNUM *);
@


1.82
log
@Slap in -b support for tag command.  It was missing for a full regress test
as of now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.81 2007/11/11 10:01:41 tobias Exp $	*/
d81 6
a86 6
#define RCS_KWEXP_NONE	0x00
#define RCS_KWEXP_NAME	0x01	/* include keyword name */
#define RCS_KWEXP_VAL	0x02	/* include keyword value */
#define RCS_KWEXP_LKR	0x04	/* include name of locker */
#define RCS_KWEXP_OLD	0x08	/* generate old keyword string */
#define RCS_KWEXP_ERR	0x10	/* mode has an error */
@


1.81
log
@Added CVS keyword "Locker". Although it is a dummy function, it's already
enough for OpenBSD's src/.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.80 2007/10/09 12:59:53 tobias Exp $	*/
d282 1
@


1.80
log
@Added proper support for branch revisions in annotate.

OK niallo@@, twice :)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.79 2007/09/24 13:44:20 joris Exp $	*/
d72 1
@


1.79
log
@add support to commit modified files to branches.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.78 2007/09/13 13:10:57 tobias Exp $	*/
d265 2
@


1.78
log
@Added annotate support for local and remote repositories. Behaves like
GNU cvs but is a little faster.

OK joris@@, ray@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.77 2007/06/01 17:47:47 niallo Exp $	*/
d278 1
@


1.77
log
@add support for local and remote branch checkout.  for example,
cvs co -rOPENBSD_3_0 works now.
along the way, simplify and rationalise code and fix a few nits.

ok joris@@ xsa@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.76 2007/05/26 20:58:36 niallo Exp $	*/
d218 1
d264 2
a265 1
struct cvs_lines	*rcs_rev_getlines(RCSFILE *, RCSNUM *);
@


1.76
log
@add support for Mdocdate rcs keyword in opencvs too.
also add check for strftime return in date keyword parsing while here.
requested by jmc@@, ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.75 2007/02/19 11:40:00 otto Exp $	*/
a197 1
	int	 rf_inattic;
@


1.75
log
@Fix const inconsistencies, void pointer artithmetic and a few other
things. now gcc -Wall and lint are more happy. ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.74 2007/02/12 14:35:28 xsa Exp $	*/
d71 1
@


1.74
log
@remove unused leftovers from openrcs; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.73 2007/01/14 23:10:56 joris Exp $	*/
d180 1
a180 1
	u_int		 rd_flags;
d200 1
a200 1
	u_int	 rf_flags;
@


1.73
log
@move things around in rcs_rev_getbuf() and rcs_rev_write_fd()
so that we do keyword expansion on-the-fly if required instead
of obtaining the revision in memory first, running over the revision
lines while expanding keywords and only then writing them to the fd
or memory buffer.

this drasticly decreases cpu usage by opencvs on very large trees (like src).

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.72 2007/01/13 04:18:50 joris Exp $	*/
a282 3
/* rcstime.c */
void	 rcs_set_tz(char *, struct rcs_delta *, struct tm *);
extern char *timezone_flag;
@


1.72
log
@add missing prototypes for some new rcs api functions;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.71 2007/01/12 23:32:01 niallo Exp $	*/
a247 2
void			 rcs_kwexp_lines(char *, struct rcs_delta *,
			     struct cvs_lines *, int);
d264 1
a264 1
BUF			*rcs_rev_getbuf(RCSFILE *, RCSNUM *);
@


1.71
log
@major re-work of the RCS api.  this results in 100x performance improvements in some places and much
reduced memory usage.  note that only checkout has been fully converted to use the new high-performance
functions.  other codepaths (e.g. update) still use the old method which is provided for backwards
compatibility.  we can convert the remaining slow bits over to the new api piece-by-piece.

"commit this, now" joris@@
brad@@ tested, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.70 2007/01/12 17:25:33 joris Exp $	*/
d263 4
@


1.70
log
@complete binary support for opencvs,
adding/importing binary files now works too

partially taken from openrcs
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.69 2006/06/09 14:57:13 xsa Exp $	*/
a28 1

d218 1
d248 2
@


1.69
log
@handle `cvs tag -F'; input && OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.68 2006/06/01 20:00:52 joris Exp $	*/
d241 1
a241 1
int			 rcs_deltatext_set(RCSFILE *, RCSNUM *, const char *);
@


1.68
log
@major rewrite of some rcs parsing stuff:

- rework rcs_getrev() to correctly support branches
- rework rcs_translate_tag() to correctly translate given symbols or
  branches into their matching revisions
- rework rcs_rev_add() to correctly update its 'next' pointers
  and insert the new revision in the correct place on the list.
- rework rcs_head_get() to return the latest revision on the default
  branch if it has been set or the normal HEAD revision otherwise.
- no longer access the rf_head member of the RCSFILE struct manually,
  use the rcs_head_get() function which correctly returns the HEAD
  revision, there might be a default branch that has to be used.
- for now, when commiting a new revision reset the default branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.67 2006/05/31 18:26:14 joris Exp $	*/
d231 2
a235 1
int			 rcs_sym_check(const char *);
@


1.67
log
@have rcs_translate_tag translate branches too, which
allows us to completely use branches for diffing, logging,
updating, etc..

more branches support coming up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.66 2006/05/30 19:16:51 joris Exp $	*/
d222 1
a222 1
const RCSNUM		*rcs_head_get(RCSFILE *);
@


1.66
log
@look inside the Attic if a specified RCS file cannot be found
in the normal repository, and a way to identify an RCS file in
the Attic in the RCSFILE struct.
will come in handy later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.65 2006/05/29 07:15:52 joris Exp $	*/
d275 2
a276 1
int	 rcsnum_cmp(const RCSNUM *, const RCSNUM *, u_int);
@


1.65
log
@add rcs_translate_tag which will translate a specified
revision or symbol given to us on the command line into
the matching revision in the RCS file (if any);
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.64 2006/05/28 10:14:59 joris Exp $	*/
d198 1
@


1.64
log
@add rf_dead field to RCSFILE which can tell us
if an RCSFILE is dead, will come in usefull later in commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.63 2006/05/28 01:24:28 joris Exp $	*/
d232 1
@


1.63
log
@enable merging on update. if your file in your working copy
has been modified by yourself and there is a newer revision
we try and merge them together.

if the merge fails and has conflicts it will mark them inside
the file, you will need to resolve these by hand first before
you will be able to commit your modified file.

works transparent with gnu cvs, as it is suppose to.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.62 2006/05/27 03:30:31 joris Exp $	*/
d197 1
@


1.62
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.3 2006/05/11 07:34:26 xsa Exp $	*/
d43 3
@


1.61
log
@- swap a hack for a slightly nicer hack using a global variable.  this avoids
adding a really nasty hack to make some upcoming rlog fixes from joris work.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.60 2006/04/13 19:55:41 joris Exp $	*/
d136 1
a136 1
/* used for cvs_checkout_rev */
d193 1
a212 1

d215 1
a215 2

RCSFILE			*rcs_open(const char *, int, ...);
d253 1
a253 2
int			 rcs_write(RCSFILE *);

a272 1

a273 4

#if defined(RCSPROG)
extern char *rcs_tmpdir;
#endif
@


1.60
log
@add support for the openrcs -o'range' option.
-o allows users to delete revisions in the specified RCS files.

example:
	rcs -o1.4:1.6 foo deletes revisions 1.4 - 1.6
	rcs -o1.3 foo deletes revision 1.3

joint work with niallo@@
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.59 2006/04/13 19:16:15 joris Exp $	*/
d104 1
d281 1
@


1.59
log
@fix -z option for openrcs, this was broken by xsa
when he yanked the code out of rcs.c and placed it in rcstime.c.

	struct tm ltb, *tb;
	tb = &ltb;
	return (tb);

isn't really the most perfect idiom to return a value to the caller, now is it?

as a bonus -z for rlog now works too.
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.58 2006/04/10 08:08:00 xsa Exp $	*/
d276 4
@


1.58
log
@change rcs_kwexp_set() return type to void and simplify its use. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.57 2006/03/30 23:06:25 joris Exp $	*/
d273 1
a273 1
struct tm	*rcs_set_tz(char *, struct rcs_delta *);
@


1.57
log
@first part of supporting branches in openrcs. right now we can only
check them out. commit is not working yet, but will be soon.

tested by myself and ray@@
okay ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.56 2006/03/30 06:11:03 ray Exp $	*/
d241 1
a241 1
int			 rcs_kwexp_set(RCSFILE *, int);
@


1.56
log
@Add rlog -r[REV1][:][REV2] support

From Pierre-Yves Ritschard.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.55 2006/03/30 06:07:35 ray Exp $	*/
d103 1
a103 1

a185 1
	struct rcs_dlist		rd_snodes;
@


1.55
log
@ - Comment fixes.
 - int rcsnum_cpy() -> void rcsnum_cpy().
 - Check for overflow in rcsnum_cpy().

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.54 2006/03/27 21:56:32 niallo Exp $	*/
d124 1
@


1.54
log
@- properly implement GNU file modes.  basically, checkout will inherit
permissions from rcs file and initial checkin will inherit permissions from
working file.

problem spotted by uwe@@

ok ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.53 2006/03/27 15:26:12 xsa Exp $	*/
d269 1
a269 1
int	 rcsnum_cpy(const RCSNUM *, RCSNUM *, u_int);
@


1.53
log
@rcs_comment_set() will never return non-zero; change its return type to void.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.52 2006/03/27 07:14:13 xsa Exp $	*/
d253 1
@


1.52
log
@rcs_desc_set() will never return non-zero; change its return type to void.
OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.51 2006/03/24 03:22:03 ray Exp $	*/
d239 1
a239 1
int			 rcs_comment_set(RCSFILE *, const char *);
@


1.51
log
@Fix RCS_KWEXP_INVAL() macro.

Pointed out by Theo.

Okay xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.50 2006/03/23 02:21:33 ray Exp $	*/
d236 1
a236 1
int			 rcs_desc_set(RCSFILE *, const char *);
@


1.50
log
@Use TAILQ_HEAD() macro instead of custom struct definition.

From Pierre-Yves Ritschard.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.49 2006/03/09 10:56:33 xsa Exp $	*/
d89 1
a89 1
	((k & RCS_KWEXP_OLD) && (RCS_KWEXP_OLD & ~RCS_KWEXP_OLD)))
@


1.49
log
@move joris' timezone support into rcstime.c; more work to be done there.
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.48 2006/03/07 01:40:52 joris Exp $	*/
d171 1
a171 4
struct rcs_dlist {
	struct rcs_delta	*tqh_first;
	struct rcs_delta	**tqh_last;
};
@


1.48
log
@-z support for RCS;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.47 2006/03/05 14:18:56 niallo Exp $	*/
d273 3
@


1.47
log
@our deltatexts were sometimes different from gnu.  rcs_getrev() was
unconditionally doing keyword expansion, even when this wasn't what we
wanted e.g. in checkout_rev() and cvs_checkout_rev(). so:

- change semantics of rcs_getrev() to not do keyword expansion
- add an rcs.c api function rcs_kwexp_buf() which does this
- change both checkout_rev() and cvs_checkout_rev() to use this function.

eyeballed by xsa, joris and Ray Lai
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.46 2006/02/09 08:08:56 niallo Exp $	*/
d273 2
@


1.46
log
@- move rcs_kw-related data into rcs.h and de-static the keyword array. this
  allows access from outside rcs.c and will be needed for upcoming features
  in ci(1).

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.45 2006/01/02 09:42:20 xsa Exp $	*/
d243 1
@


1.45
log
@more includes cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.44 2005/12/30 16:53:55 niallo Exp $	*/
d57 19
d92 6
@


1.44
log
@- zap unused 'rf_ref' member of RCSFILE structure.

spotted by joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.43 2005/12/27 16:05:21 niallo Exp $	*/
a28 5

#include <sys/types.h>
#include <sys/queue.h>

#include <time.h>
@


1.43
log
@- implement lazy-parsing of rcs files, that is only parse as much as we
  need. this can save us much work, particularly with very large rcs files.

first of a few important performance improvements.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.42 2005/12/08 18:56:10 joris Exp $	*/
a175 1
	u_int	 rf_ref;
@


1.42
log
@complete and correct rcs locking functionality,
it was only done partially and as a bonus, completely wrong.

seriously guys what was up with that?
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.41 2005/12/03 15:31:53 joris Exp $	*/
d86 5
a90 4
#define RCS_READ	0x01
#define RCS_WRITE	0x02
#define RCS_RDWR	(RCS_READ|RCS_WRITE)
#define RCS_CREATE	0x04		/* create the file */
d93 8
a100 3
#define RCS_PARSED	0x010000	/* file has been parsed */
#define RCS_SYNCED	0x020000	/* in-mem copy is sync with disk copy */
#define RCS_SLOCK	0x040000	/* strict lock */
d202 1
a202 1
int			 rcs_head_set(RCSFILE *, const RCSNUM *);
d208 1
a208 1
struct rcs_delta	*rcs_findrev(RCSFILE *, const RCSNUM *);
@


1.41
log
@todd@@ reminds me:

If you 'vi file.c' and change stuff, then 'make depend && make' you'll
have a file.o file most definately more recent than the latest committed
version of file.c.

Then, if you rm file.c, and cvs update file.c, if 'file.c' is set to the
timestamp of the last committed version, a subsequent 'make' will not
rebuild the .o file.

to fix this we simply use the current timestamp when updating files.
thanks todd@@!
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.40 2005/12/03 01:02:09 joris Exp $	*/
d158 1
d210 1
a210 1
int			 rcs_lock_remove(RCSFILE *, const RCSNUM *);
@


1.40
log
@add very basic support for the following stuff:

- checkout in local mode (example: /cvs)
- update in local and server mode (example: /cvs and user@@host:/cvs)
- import in local and server mode (example: /cvs and user@@host:/cvs)

what remains to be done:

- not all options are supported yet, and update cannot pick up newly
  added files yet. these things are pending and will be commited
  real soon.

- checkout only works locally right now.

- fix rcs parsing code so that we don't fucking hog 100% cpu
  on really BIG BIG BIG ass trees.

mainly tested by pedro@@ and myself, thanks a lot pedro!

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.39 2005/12/01 18:22:09 xsa Exp $	*/
d112 1
@


1.39
log
@rcs_findrev() is not static anymore; align protos while here;
OK joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.38 2005/11/02 20:32:44 niallo Exp $	*/
d107 5
@


1.38
log
@changes from Venice:

- instead of using lots of individual flag variables, use a single int and
  bitwise operations on it. while this saves memory, really it saves code
  space and reduces complexity. checkout_rev() and checkout_state() in
  particular benefit from these changes since their parameters where growing
  really long.

- implement `-s' option in co

- implement `-M' option in ci

"I like this, go for it" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.37 2005/10/29 19:05:50 niallo Exp $	*/
d186 37
a222 36
RCSFILE		*rcs_open(const char *, int, ...);
void		 rcs_close(RCSFILE *);
const RCSNUM	*rcs_head_get(RCSFILE *);
int		 rcs_head_set(RCSFILE *, const RCSNUM *);
const RCSNUM	*rcs_branch_get(RCSFILE *);
int		 rcs_branch_set(RCSFILE *, const RCSNUM *);
int		 rcs_access_add(RCSFILE *, const char *);
int		 rcs_access_remove(RCSFILE *, const char *);
int		 rcs_access_check(RCSFILE *, const char *);
int		 rcs_sym_add(RCSFILE *, const char *, RCSNUM *);
int		 rcs_sym_remove(RCSFILE *, const char *);
RCSNUM		*rcs_sym_getrev(RCSFILE *, const char *);
int		 rcs_sym_check(const char *);
int		 rcs_lock_getmode(RCSFILE *);
int		 rcs_lock_setmode(RCSFILE *, int);
int		 rcs_lock_add(RCSFILE *, const char *, RCSNUM *);
int		 rcs_lock_remove(RCSFILE *, const RCSNUM *);
BUF		*rcs_getrev(RCSFILE *, RCSNUM *);
int		 rcs_deltatext_set(RCSFILE *, RCSNUM *, const char *);
const char	*rcs_desc_get(RCSFILE *);
int		 rcs_desc_set(RCSFILE *, const char *);
const char	*rcs_comment_lookup(const char *);
const char	*rcs_comment_get(RCSFILE *);
int		 rcs_comment_set(RCSFILE *, const char *);
int		 rcs_kwexp_set(RCSFILE *, int);
int		 rcs_kwexp_get(RCSFILE *);
int		 rcs_rev_add(RCSFILE *, RCSNUM *, const char *, time_t,
                     const char *);
time_t           rcs_rev_getdate(RCSFILE *, RCSNUM *);
int		 rcs_rev_setlog(RCSFILE *, RCSNUM *, const char *);
int		rcs_rev_remove(RCSFILE *, RCSNUM *);
int              rcs_state_set(RCSFILE *, RCSNUM *, const char *);
const char      *rcs_state_get(RCSFILE *, RCSNUM *);
int              rcs_state_check(const char *);
RCSNUM		*rcs_tag_resolve(RCSFILE *, const char *);
const char	*rcs_errstr(int);
@


1.37
log
@- add two new functions to RCS api: rcs_state_set() and rcs_state_check()
- use these two new functions to implement -s<state> option in ci

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.36 2005/10/22 17:32:57 joris Exp $	*/
d214 1
d218 1
@


1.36
log
@diff3 support, needed for merging files together;

"go for it" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.35 2005/10/15 22:56:03 niallo Exp $	*/
d216 2
@


1.35
log
@- add username parameter to rcs_rev_add(), needed to implement at least
  `ci -wusername'.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.34 2005/10/10 23:37:15 joris Exp $	*/
a222 2

BUF	*rcs_patch(const char *, const char *);
@


1.34
log
@add rcs_rev_setlog() in the RCS api; used for setting log messages
of a revision to a specific value;

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.33 2005/10/10 13:06:24 joris Exp $	*/
d212 2
a213 1
int		 rcs_rev_add(RCSFILE *, RCSNUM *, const char *, time_t);
@


1.33
log
@add rcsnum_dec() api call, decreases a revision number by one.
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.32 2005/10/07 23:59:56 niallo Exp $	*/
d213 1
@


1.32
log
@basic `ci' support is here! more coming soon.

combined effort with joris.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.31 2005/08/02 11:48:56 joris Exp $	*/
d229 1
@


1.31
log
@handle magic branch numbers.

ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.30 2005/07/25 11:28:59 xsa Exp $	*/
d204 1
@


1.30
log
@KNF; mostly spaces vs. tabs; ok joris@@ jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.29 2005/05/26 01:45:54 jfb Exp $	*/
d52 1
@


1.29
log
@add a couple of functions to go from branch numbers to revisions and
vice versa, and fix RCSNUM_ISBRANCH()
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.28 2005/05/25 21:59:16 jfb Exp $	*/
d37 1
a37 1
#define RCS_DIFF_MAXARG   32
d41 2
a42 2
#define RCSDIR         "RCS"
#define RCS_FILE_EXT   ",v"
d44 3
a46 3
#define RCS_HEAD_BRANCH  "HEAD"
#define RCS_HEAD_INIT    "1.1"
#define RCS_HEAD_REV     ((RCSNUM *)(-1))
d49 1
a49 1
#define RCS_SYM_INVALCHAR  "$,.:;@@"
d52 2
a53 2
#define RCS_STATE_EXP    "Exp"
#define RCS_STATE_DEAD   "dead"
d56 3
a58 3
#define RCS_LOCK_INVAL  (-1)
#define RCS_LOCK_LOOSE    0
#define RCS_LOCK_STRICT   1
d62 6
a67 6
#define RCS_KWEXP_NONE     0x00
#define RCS_KWEXP_NAME     0x01		/* include keyword name */
#define RCS_KWEXP_VAL      0x02		/* include keyword value */
#define RCS_KWEXP_LKR      0x04		/* include name of locker */
#define RCS_KWEXP_OLD      0x08		/* generate old keyword string */
#define RCS_KWEXP_ERR      0x10		/* mode has an error */
d69 2
a70 2
#define RCS_KWEXP_DEFAULT  (RCS_KWEXP_NAME | RCS_KWEXP_VAL)
#define RCS_KWEXP_KVL      (RCS_KWEXP_NAME | RCS_KWEXP_VAL | RCS_KWEXP_LKR)
d78 2
a79 2
#define RCSNUM_MAXNUM  USHRT_MAX
#define RCSNUM_MAXLEN  64
d81 1
a81 1
#define RCSNUM_ISBRANCH(n)    ((n)->rn_len % 2)
d85 4
a88 4
#define RCS_READ    0x01
#define RCS_WRITE   0x02
#define RCS_RDWR    (RCS_READ|RCS_WRITE)
#define RCS_CREATE  0x04			/* create the file */
d91 3
a93 3
#define RCS_PARSED  0x010000   /* file has been parsed */
#define RCS_SYNCED  0x020000   /* in-memory copy is in sync with disk copy */
#define RCS_SLOCK   0x040000   /* strict lock */
d96 1
a96 1
#define RCS_RD_DEAD   0x01     /* dead */
d99 7
a105 7
#define RCS_ERR_NOERR    0
#define RCS_ERR_NOENT    1
#define RCS_ERR_DUPENT   2
#define RCS_ERR_BADNUM   3
#define RCS_ERR_BADSYM   4
#define RCS_ERR_PARSE    5
#define RCS_ERR_ERRNO  255
d108 2
a109 2
	u_int      rn_len;
	u_int16_t *rn_id;
d114 3
a116 3
	char    *ra_name;
	uid_t    ra_uid;
	TAILQ_ENTRY(rcs_access) ra_list;
d120 3
a122 3
	char    *rs_name;
	RCSNUM  *rs_num;
	TAILQ_ENTRY(rcs_sym) rs_list;
d126 2
a127 2
	char     *rl_name;
	RCSNUM   *rl_num;
d129 1
a129 1
	TAILQ_ENTRY(rcs_lock) rl_list;
d134 2
a135 2
	RCSNUM  *rb_num;
	TAILQ_ENTRY(rcs_branch) rb_list;
d139 2
a140 2
	struct rcs_delta *tqh_first;
	struct rcs_delta **tqh_last;
d144 13
a156 13
	RCSNUM    *rd_num;
	RCSNUM    *rd_next;
	u_int      rd_flags;
	struct tm  rd_date;
	char      *rd_author;
	char      *rd_state;
	char      *rd_log;
	u_char    *rd_text;
	size_t     rd_tlen;

	struct rcs_dlist         rd_snodes;
	TAILQ_HEAD(, rcs_branch) rd_branches;
	TAILQ_ENTRY(rcs_delta)   rd_list;
d161 16
a176 16
	char   *rf_path;
	u_int   rf_ref;
	mode_t  rf_mode;
	u_int   rf_flags;

	RCSNUM *rf_head;
	RCSNUM *rf_branch;
	char   *rf_comment;
	char   *rf_expand;
	char   *rf_desc;

	u_int   rf_ndelta;
	struct rcs_dlist                  rf_delta;
	TAILQ_HEAD(rcs_alist, rcs_access) rf_access;
	TAILQ_HEAD(rcs_slist, rcs_sym)    rf_symbols;
	TAILQ_HEAD(rcs_llist, rcs_lock)   rf_locks;
d178 1
a178 1
	void   *rf_pdata;
d185 47
a231 47
RCSFILE*      rcs_open          (const char *, int, ...);
void          rcs_close         (RCSFILE *);
const RCSNUM* rcs_head_get      (RCSFILE *);
int           rcs_head_set      (RCSFILE *, const RCSNUM *);
const RCSNUM* rcs_branch_get    (RCSFILE *);
int           rcs_branch_set    (RCSFILE *, const RCSNUM *);
int           rcs_access_add    (RCSFILE *, const char *);
int           rcs_access_remove (RCSFILE *, const char *);
int           rcs_access_check  (RCSFILE *, const char *);
int           rcs_sym_add       (RCSFILE *, const char *, RCSNUM *);
int           rcs_sym_remove    (RCSFILE *, const char *);
RCSNUM*       rcs_sym_getrev    (RCSFILE *, const char *);
int           rcs_sym_check     (const char *);
int           rcs_lock_getmode  (RCSFILE *);
int           rcs_lock_setmode  (RCSFILE *, int);
int           rcs_lock_add      (RCSFILE *, const char *, RCSNUM *);
int           rcs_lock_remove   (RCSFILE *, const RCSNUM *);
BUF*          rcs_getrev        (RCSFILE *, RCSNUM *);
const char*   rcs_desc_get      (RCSFILE *);
int           rcs_desc_set      (RCSFILE *, const char *);
const char*   rcs_comment_lookup(const char *);
const char*   rcs_comment_get   (RCSFILE *);
int           rcs_comment_set   (RCSFILE *, const char *);
int           rcs_kwexp_set     (RCSFILE *, int);
int           rcs_kwexp_get     (RCSFILE *);
int           rcs_rev_add       (RCSFILE *, RCSNUM *, const char *, time_t);
int           rcs_rev_remove    (RCSFILE *, RCSNUM *);
RCSNUM*       rcs_tag_resolve   (RCSFILE *, const char *);
const char*   rcs_errstr        (int);


int       rcs_kflag_get    (const char *);
void      rcs_kflag_usage  (void);
int       rcs_kw_expand    (RCSFILE *, u_char *, size_t, size_t *);

BUF*      rcs_patch     (const char *, const char *);

RCSNUM*   rcsnum_alloc  (void);
RCSNUM*   rcsnum_parse  (const char *);
RCSNUM*   rcsnum_brtorev(const RCSNUM *);
RCSNUM*   rcsnum_revtobr(const RCSNUM *);
RCSNUM*   rcsnum_inc    (RCSNUM *);
void      rcsnum_free   (RCSNUM *);
int       rcsnum_aton   (const char *, char **, RCSNUM *);
char*     rcsnum_tostr  (const RCSNUM *, char *, size_t);
int       rcsnum_cpy    (const RCSNUM *, RCSNUM *, u_int);
int       rcsnum_cmp    (const RCSNUM *, const RCSNUM *, u_int);
d233 1
a233 1
#endif /* RCS_H */
@


1.28
log
@unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.27 2005/05/25 21:32:31 jfb Exp $	*/
d81 1
a81 1
#define RCSNUM_ISBRANCH(n)    (((n)->rn_len % 2) == 0)
d224 3
@


1.27
log
@modify rcs_rev_add() to accept a time_t argument to explicitly set
the revision's timestamp (-1 is equivalent to using the current time)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.26 2005/05/25 10:23:57 jfb Exp $	*/
a202 2
BUF*          rcs_gethead       (RCSFILE *);
RCSNUM*       rcs_getrevbydate  (RCSFILE *, struct tm *);
a213 2


@


1.26
log
@split cvs_admin_file() into the local and remote versions and do
some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.25 2005/05/25 07:15:16 jfb Exp $	*/
d212 1
a212 1
int           rcs_rev_add       (RCSFILE *, RCSNUM *, const char *);
@


1.25
log
@add cvs_comment_lookup() and a suffix -> comment leader lookup table
to determine the appropriate comment leader for a file
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.24 2005/05/25 06:42:41 jfb Exp $	*/
d56 1
@


1.24
log
@add the RCS_ERR_ERRNO code to indicate that the actual error code is
in errno, fix cvs_errstr() to return the appropriate string, and
sprinkle some error setting where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.23 2005/04/20 23:11:30 jfb Exp $	*/
d206 1
@


1.23
log
@check the validity of tag names passed to the tag command, and print
an abort message if the tag is invalid.  also, match gnu cvs behaviour
with regards to command usage output on usage errors.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.22 2005/04/19 19:22:31 jfb Exp $	*/
d104 1
a104 1

d210 2
d214 3
@


1.22
log
@add rcs_sym_check() to check the validity of an RCS symbol and
sprinkle some in the other symbol functions
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.21 2005/04/13 15:50:49 jfb Exp $	*/
d47 3
@


1.21
log
@cache leftovers
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.20 2005/04/11 20:32:56 jfb Exp $	*/
d99 2
d193 1
@


1.20
log
@modify handling of RCS delta texts so we can handle arbitrary binary
data
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.19 2005/04/07 22:08:57 jfb Exp $	*/
a219 6

/* from cache.c */
int       rcs_cache_init    (u_int);
RCSFILE  *rcs_cache_fetch   (const char *path);
int       rcs_cache_store   (RCSFILE *);
void      rcs_cache_destroy (void);
@


1.19
log
@* reverse symbol list order
* allow retrieval and setting of the head revision number
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.18 2005/04/07 20:50:22 jfb Exp $	*/
d145 1
a145 1
	char      *rd_text;
@


1.18
log
@Perform proper escaping of the @@ character in all RCS strings when
writing the output to the file.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.17 2005/04/06 19:12:08 jfb Exp $	*/
d181 2
@


1.17
log
@* allow for creation and removal of RCS locks
* add rcs_tag_resolve() to resolve a branch, tag or revision easily
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.15 2005/03/05 18:25:30 jfb Exp $	*/
d138 9
a146 10
	RCSNUM      *rd_num;
	RCSNUM      *rd_next;
	u_int        rd_flags;
	struct tm    rd_date;
	char        *rd_author;
	char        *rd_state;
	char        *rd_log;
	char        *rd_text;

	struct rcs_dlist rd_snodes;
d148 1
d150 1
a150 1
	TAILQ_ENTRY(rcs_delta)  rd_list;
a209 1
size_t    rcs_stresc    (int, const char *, char *, size_t *);
@


1.16
log
@support for the optional `branch' keyword, which is used to set the
default branch for an RCS file
@
text
@d44 3
a46 1
#define RCS_HEAD_INIT  "1.1"
d49 3
d77 2
d120 1
a171 1

d191 2
d202 1
@


1.15
log
@add functions to retrieve and set the comment leader for an RCS
file
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.14 2005/03/05 05:58:39 jfb Exp $	*/
d172 22
a193 20
RCSFILE*    rcs_open          (const char *, int, ...);
void        rcs_close         (RCSFILE *);
int         rcs_access_add    (RCSFILE *, const char *);
int         rcs_access_remove (RCSFILE *, const char *);
int         rcs_access_check  (RCSFILE *, const char *);
int         rcs_sym_add       (RCSFILE *, const char *, RCSNUM *);
int         rcs_sym_remove    (RCSFILE *, const char *);
RCSNUM*     rcs_sym_getrev    (RCSFILE *, const char *);
int         rcs_lock_getmode  (RCSFILE *);
int         rcs_lock_setmode  (RCSFILE *, int);
BUF*        rcs_getrev        (RCSFILE *, RCSNUM *);
BUF*        rcs_gethead       (RCSFILE *);
RCSNUM*     rcs_getrevbydate  (RCSFILE *, struct tm *);
const char* rcs_desc_get      (RCSFILE *);
int         rcs_desc_set      (RCSFILE *, const char *);
const char* rcs_comment_get   (RCSFILE *);
int         rcs_comment_set   (RCSFILE *, const char *);
int         rcs_kwexp_set     (RCSFILE *, int);
int         rcs_kwexp_get     (RCSFILE *);
const char* rcs_errstr        (int);
@


1.14
log
@add RCS error codes and a global variable to hold the last error
and make the code less verbose at the same time
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.12 2005/03/05 03:30:29 jfb Exp $	*/
d187 2
@


1.13
log
@unbreak the RCS_KWEXP_INVAL() macro
@
text
@d41 1
d87 6
d169 3
d189 1
@


1.12
log
@functions to manage the locking mode of RCS file
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.11 2005/03/04 18:21:00 jfb Exp $	*/
d63 2
a64 1
	((k & RCS_KWEXP_ERR) || ((k & RCS_KWEXP_OLD) != RCS_KWEXP_OLD))
@


1.11
log
@add real support for the `access' keyword, both in parsing and
output; rcs_access_add() can be used to add a new login name to
the access list, and rcs_access_remove() to remove an entry
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.10 2005/03/02 04:19:34 jfb Exp $	*/
d45 6
d169 2
@


1.10
log
@- rcs_write() is now static
- when setting a new expansion mode, do not attempt to free the
  previous expansion mode if the pointer is NULL
- add a bunch of new functions:
   * rcs_sym_remove() to remove a symbol
   * rcs_sym_getrev() to retrieve the revision number of a symbol
   * rcs_desc_{s,g}et() to manipulate an RCS file's description
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.9 2005/02/27 00:22:08 jfb Exp $	*/
d86 6
d145 4
a148 3
	struct rcs_dlist                rf_delta;
	TAILQ_HEAD(rcs_slist, rcs_sym)  rf_symbols;
	TAILQ_HEAD(rcs_llist, rcs_lock) rf_locks;
d155 15
a169 12
RCSFILE*    rcs_open         (const char *, int, ...);
void        rcs_close        (RCSFILE *);
int         rcs_sym_add      (RCSFILE *, const char *, RCSNUM *);
int         rcs_sym_remove   (RCSFILE *, const char *);
RCSNUM*     rcs_sym_getrev   (RCSFILE *, const char *);
BUF*        rcs_getrev       (RCSFILE *, RCSNUM *);
BUF*        rcs_gethead      (RCSFILE *);
RCSNUM*     rcs_getrevbydate (RCSFILE *, struct tm *);
const char* rcs_desc_get     (RCSFILE *);
int         rcs_desc_set     (RCSFILE *, const char *);
int         rcs_kwexp_set    (RCSFILE *, int);
int         rcs_kwexp_get    (RCSFILE *);
@


1.9
log
@Many improvements to the RCS support:

- make it possible to specify creation and the file mode
  in rcs_open()
- implicitly write the contents to disk on rcs_close() if the
  RCS handle has been changed
- fix a bug in the output of the `expand' keyword
- add functions to retrieve and modify the expansion mode
- rcs_parse() shouldn't be available to the outside
- empty string instead of `(null)' if there is no description

ok Joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.8 2005/02/25 20:05:41 jfb Exp $	*/
d148 12
a159 10
RCSFILE*  rcs_open         (const char *, int, ...);
void      rcs_close        (RCSFILE *);
int       rcs_write        (RCSFILE *);
int       rcs_sym_add      (RCSFILE *, const char *, RCSNUM *);
int       rcs_sym_remove   (RCSFILE *, const char *);
BUF*      rcs_getrev       (RCSFILE *, RCSNUM *);
BUF*      rcs_gethead      (RCSFILE *);
RCSNUM*   rcs_getrevbydate (RCSFILE *, struct tm *);
int       rcs_kwexp_set    (RCSFILE *, int);
int       rcs_kwexp_get    (RCSFILE *);
@


1.8
log
@add rcsnum_parse() to simplify the most common case
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.7 2005/01/13 20:50:57 jfb Exp $	*/
d56 3
a58 1
#define RCS_KWEXP_INVAL(k) (k & RCS_KWEXP_ERR)
a64 6
/* open modes */
#define RCS_MODE_READ   0x01
#define RCS_MODE_WRITE  0x02
#define RCS_MODE_RDWR   (RCS_MODE_READ|RCS_MODE_WRITE)


d66 9
a74 3
#define RCS_RF_PARSED  0x01   /* file has been parsed */
#define RCS_RF_SYNCED  0x02   /* in-memory copy is in sync with disk copy */
#define RCS_RF_SLOCK   0x04   /* strict lock */
d129 1
a129 1
	u_int   rf_mode;
d138 5
a142 3
	struct rcs_dlist rf_delta;
	TAILQ_HEAD(rcs_slist, rcs_sym)   rf_symbols;
	TAILQ_HEAD(rcs_llist, rcs_lock)  rf_locks;
d148 1
a148 1
RCSFILE*  rcs_open         (const char *, u_int);
a149 1
int       rcs_parse        (RCSFILE *);
d151 2
a152 2
int       rcs_addsym       (RCSFILE *, const char *, RCSNUM *);
int       rcs_rmsym        (RCSFILE *, const char *);
d156 2
d161 1
@


1.7
log
@add rcs_kflag_usage() to display the various keyword expansion modes
supported by the -k argument
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.6 2005/01/12 19:23:27 jfb Exp $	*/
d161 1
@


1.6
log
@add rcs_kflag_get() to validate kflags
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.5 2005/01/03 22:10:12 jfb Exp $	*/
d155 1
@


1.5
log
@limit the maximum length of RCS numbers to 64 nums and avoid
potential integer overflow in case of ridiculously large RCSNUMs
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.4 2004/12/16 17:16:18 jfb Exp $	*/
d45 17
a77 5

#define RCSNUM_MAXNUM  USHRT_MAX
#define RCSNUM_MAXLEN  64


d153 2
@


1.4
log
@Add rcs_gethead() to easily retrieve the head revision of an RCS
file.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.3 2004/12/15 05:09:06 jfb Exp $	*/
d59 5
@


1.3
log
@we don't need a separate header for 4 function prototypes, move
them in rcs.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.2 2004/12/07 17:10:56 tedu Exp $	*/
d134 1
@


1.2
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.h,v 1.1.1.1 2004/07/13 22:02:40 jfb Exp $	*/
d146 5
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 1
a13 1
 *    derived from this software without specific prior written permission. 
d24 1
a24 1
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
a66 1

a106 1

a124 2


@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
