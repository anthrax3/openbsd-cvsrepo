head	1.52;
access;
symbols
	OPENBSD_6_1:1.52.0.4
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.50.0.6
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.49.0.20
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.18
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.14
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.49.0.12
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.10
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.8
	OPENBSD_5_0:1.49.0.6
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.4
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.48.0.6
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.48.0.8
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.4
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.2
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8;
locks; strict;
comment	@ * @;


1.52
date	2016.10.13.20.51.25;	author fcambus;	state Exp;
branches;
next	1.51;
commitid	8Vv7d4HkmCtExfc6;

1.51
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.50;
commitid	O6jeJ0TRmiewrqMI;

1.50
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	Uu5nFG3wCl0LACBb;

1.49
date	2010.07.09.18.42.14;	author zinovik;	state Exp;
branches;
next	1.48;

1.48
date	2008.06.23.20.51.08;	author ragge;	state Exp;
branches;
next	1.47;

1.47
date	2008.06.14.03.19.15;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.11.02.19.13;	author tobias;	state Exp;
branches;
next	1.45;

1.45
date	2008.03.01.21.29.36;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2008.02.06.12.42.46;	author tobias;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.04.15.07.33;	author tobias;	state Exp;
branches;
next	1.42;

1.42
date	2008.01.31.10.15.05;	author tobias;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.28.20.31.07;	author tobias;	state Exp;
branches;
next	1.40;

1.40
date	2008.01.10.10.08.22;	author tobias;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.05.19.28.23;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.24.22.06.28;	author joris;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.22.16.01.22;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.01.10.43.13;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.28.21.38.09;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.17.18.23.43;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.09.03.49.15;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.25.18.56.33;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.25.11.09.21;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.11.15.45.02;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.11.08.09.55;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.11.02.35.55;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.10.21.32.19;	author xsa;	state Exp;
branches;
next	1.25;

1.25
date	2007.01.09.10.01.43;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.08.13.21.21;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.06.17.09.08;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2007.01.05.09.41.30;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.05.09.32.49;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.05.09.15.00;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.05.08.52.37;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.05.08.37.55;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.05.07.13.49;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.03.09.49.37;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.02.14.51.18;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.02.13.51.13;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.27.03.30.30;	author joris;	state dead;
branches;
next	1.12;

1.12
date	2006.03.16.09.06.19;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.30.02.03.28;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.10.17.51.53;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.25.12.05.43;	author xsa;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.10.21.51.23;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.31.10.54.05;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.31.08.58.47;	author xsa;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.28.20.39.08;	author xsa;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.26.14.46.22;	author xsa;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.26.07.27.01;	author xsa;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.25.22.07.54;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.52
log
@rcsnum_free() -> free() cleanups. From Michael W. Bombardieri.

OK millert@@
@
text
@/*	$OpenBSD: edit.c,v 1.51 2015/11/05 09:48:21 nicm Exp $	*/
/*
 * Copyright (c) 2006, 2007 Xavier Santolaria <xsa@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "cvs.h"
#include "remote.h"

#define E_COMMIT	0x01
#define E_EDIT		0x02
#define E_UNEDIT	0x04
#define E_ALL		(E_EDIT|E_COMMIT|E_UNEDIT)

#define BASE_ADD	0x01
#define BASE_GET	0x02
#define BASE_REMOVE	0x04

static void	cvs_edit_local(struct cvs_file *);
static void	cvs_editors_local(struct cvs_file *);
static void	cvs_unedit_local(struct cvs_file *);

static RCSNUM	*cvs_base_handle(struct cvs_file *, int);

static int	edit_aflags = 0;

struct cvs_cmd cvs_cmd_edit = {
	CVS_OP_EDIT, CVS_USE_WDIR, "edit",
	{ { 0 }, { 0 } },
	"Get ready to edit a watched file",
	"[-lR] [-a action] [file ...]",
	"a:lR",
	NULL,
	cvs_edit
};

struct cvs_cmd cvs_cmd_editors = {
	CVS_OP_EDITORS, CVS_USE_WDIR, "editors",
	{ { 0 }, { 0 } },
	"See who is editing a watched file",
	"[-lR] [file ...]",
	"lR",
	NULL,
	cvs_editors
};

struct cvs_cmd cvs_cmd_unedit = {
	CVS_OP_UNEDIT, CVS_USE_WDIR, "unedit",
	{ { 0 }, { 0 } },
	"Undo an edit command",
	"[-lR] [file ...]",
	"lR",
	NULL,
	cvs_unedit
};

int
cvs_edit(int argc, char **argv)
{
	int ch;
	int flags;
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;

	while ((ch = getopt(argc, argv, cvs_cmd_edit.cmd_opts)) != -1) {
		switch (ch) {
		case 'a':
			if (strcmp(optarg, "edit") == 0)
				edit_aflags |= E_EDIT;
			else if (strcmp(optarg, "unedit") == 0)
				edit_aflags |= E_UNEDIT;
			else if (strcmp(optarg, "commit") == 0)
				edit_aflags |= E_COMMIT;
			else if (strcmp(optarg, "all") == 0)
				edit_aflags |= E_ALL;
			else if (strcmp(optarg, "none") == 0)
				edit_aflags &= ~E_ALL;
			else
				fatal("%s", cvs_cmd_edit.cmd_synopsis);
			break;
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		default:
			fatal("%s", cvs_cmd_edit.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		fatal("%s", cvs_cmd_edit.cmd_synopsis);

	if (edit_aflags == 0)
		edit_aflags |= E_ALL;

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");
	} else {
		cr.fileproc = cvs_edit_local;
	}

	cr.flags = flags;

	cvs_file_run(argc, argv, &cr);

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("edit");
		cvs_client_get_responses();
	}

	return (0);
}

int
cvs_editors(int argc, char **argv)
{
	int ch;
	int flags;
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;

	while ((ch = getopt(argc, argv, cvs_cmd_editors.cmd_opts)) != -1) {
		switch (ch) {
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		default:
			fatal("%s", cvs_cmd_editors.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		fatal("%s", cvs_cmd_editors.cmd_synopsis);

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");
	} else {
		cr.fileproc = cvs_editors_local;
	}

	cr.flags = flags;

	cvs_file_run(argc, argv, &cr);

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("editors");
		cvs_client_get_responses();
	}

	return (0);
}

int
cvs_unedit(int argc, char **argv)
{
	int ch;
	int flags;
	struct cvs_recursion cr;

	flags = CR_RECURSE_DIRS;

	while ((ch = getopt(argc, argv, cvs_cmd_unedit.cmd_opts)) != -1) {
		switch (ch) {
		case 'l':
			flags &= ~CR_RECURSE_DIRS;
			break;
		case 'R':
			flags |= CR_RECURSE_DIRS;
			break;
		default:
			fatal("%s", cvs_cmd_unedit.cmd_synopsis);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		fatal("%s", cvs_cmd_unedit.cmd_synopsis);

	cr.enterdir = NULL;
	cr.leavedir = NULL;

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_connect_to_server();
		cr.fileproc = cvs_client_sendfile;

		if (!(flags & CR_RECURSE_DIRS))
			cvs_client_send_request("Argument -l");
	} else {
		cr.fileproc = cvs_unedit_local;
	}

	cr.flags = flags;

	cvs_file_run(argc, argv, &cr);

	if (current_cvsroot->cr_method != CVS_METHOD_LOCAL) {
		cvs_client_send_files(argv, argc);
		cvs_client_senddir(".");
		cvs_client_send_request("unedit");
		cvs_client_get_responses();
	}

	return (0);
}

static void
cvs_edit_local(struct cvs_file *cf)
{
	FILE *fp;
	struct tm t;
	time_t now;
	char timebuf[CVS_TIME_BUFSZ], thishost[HOST_NAME_MAX+1];
	char bfpath[PATH_MAX], wdir[PATH_MAX];

	if (cvs_noexec == 1)
		return;

	cvs_log(LP_TRACE, "cvs_edit_local(%s)", cf->file_path);

	cvs_file_classify(cf, cvs_directory_tag);

	if ((fp = fopen(CVS_PATH_NOTIFY, "a")) == NULL)
		fatal("cvs_edit_local: fopen: `%s': %s",
		    CVS_PATH_NOTIFY, strerror(errno));

	(void)time(&now);
	gmtime_r(&now, &t);
	asctime_r(&t, timebuf);
	timebuf[strcspn(timebuf, "\n")] = '\0';

	if (gethostname(thishost, sizeof(thishost)) == -1)
		fatal("gethostname failed");

	if (getcwd(wdir, sizeof(wdir)) == NULL)
		fatal("getcwd failed");

	(void)fprintf(fp, "E%s\t%s GMT\t%s\t%s\t",
	    cf->file_name, timebuf, thishost, wdir);

	if (edit_aflags & E_EDIT)
		(void)fprintf(fp, "E");
	if (edit_aflags & E_UNEDIT)
		(void)fprintf(fp, "U");
	if (edit_aflags & E_COMMIT)
		(void)fprintf(fp, "C");

	(void)fprintf(fp, "\n");

	(void)fclose(fp);

	if (fchmod(cf->fd, 0644) == -1)
		fatal("cvs_edit_local: fchmod %s", strerror(errno));

	(void)xsnprintf(bfpath, PATH_MAX, "%s/%s",
	    CVS_PATH_BASEDIR, cf->file_name);

	if (mkdir(CVS_PATH_BASEDIR, 0755) == -1 && errno != EEXIST)
		fatal("cvs_edit_local: `%s': %s", CVS_PATH_BASEDIR,
		    strerror(errno));

	if (cvs_file_copy(cf->file_path, bfpath) == -1)
		fatal("cvs_edit_local: cvs_file_copy failed");

	(void)cvs_base_handle(cf, BASE_ADD);
}

static void
cvs_editors_local(struct cvs_file *cf)
{
}

static void
cvs_unedit_local(struct cvs_file *cf)
{
	FILE *fp;
	struct stat st;
	struct tm t;
	time_t now;
	char bfpath[PATH_MAX], timebuf[64], thishost[HOST_NAME_MAX+1];
	char wdir[PATH_MAX], sticky[CVS_ENT_MAXLINELEN];
	RCSNUM *ba_rev;

	cvs_log(LP_TRACE, "cvs_unedit_local(%s)", cf->file_path);

	if (cvs_noexec == 1)
		return;

	cvs_file_classify(cf, cvs_directory_tag);

	(void)xsnprintf(bfpath, PATH_MAX, "%s/%s",
	    CVS_PATH_BASEDIR, cf->file_name);

	if (stat(bfpath, &st) == -1)
		return;

	if (cvs_file_cmp(cf->file_path, bfpath) != 0) {
		cvs_printf("%s has been modified; revert changes? ",
		    cf->file_name);

		if (cvs_yesno() == -1)
			return;
	}

	cvs_rename(bfpath, cf->file_path);

	if ((fp = fopen(CVS_PATH_NOTIFY, "a")) == NULL)
		fatal("cvs_unedit_local: fopen: `%s': %s",
		    CVS_PATH_NOTIFY, strerror(errno));

	(void)time(&now);
	gmtime_r(&now, &t);
	asctime_r(&t, timebuf);
	timebuf[strcspn(timebuf, "\n")] = '\0';

	if (gethostname(thishost, sizeof(thishost)) == -1)
		fatal("gethostname failed");

	if (getcwd(wdir, sizeof(wdir)) == NULL)
		fatal("getcwd failed");

	(void)fprintf(fp, "U%s\t%s GMT\t%s\t%s\t\n",
	    cf->file_name, timebuf, thishost, wdir);

	(void)fclose(fp);

	if ((ba_rev = cvs_base_handle(cf, BASE_GET)) == NULL) {
		cvs_log(LP_ERR, "%s not mentioned in %s",
		    cf->file_name, CVS_PATH_BASEREV);
		return;
	}

	if (cf->file_ent != NULL) {
		CVSENTRIES *entlist;
		struct cvs_ent *ent;
		char *entry, rbuf[CVS_REV_BUFSZ];

		entlist = cvs_ent_open(cf->file_wd);

		if ((ent = cvs_ent_get(entlist, cf->file_name)) == NULL)
			fatal("cvs_unedit_local: cvs_ent_get failed");

		(void)rcsnum_tostr(ba_rev, rbuf, sizeof(rbuf));

		memset(timebuf, 0, sizeof(timebuf));
		ctime_r(&cf->file_ent->ce_mtime, timebuf);
		timebuf[strcspn(timebuf, "\n")] = '\0';

		sticky[0] = '\0';
		if (cf->file_ent->ce_tag != NULL)
			(void)xsnprintf(sticky, sizeof(sticky), "T%s",
			    cf->file_ent->ce_tag);

		(void)xasprintf(&entry, "/%s/%s/%s/%s/%s",
		    cf->file_name, rbuf, timebuf, cf->file_ent->ce_opts ? 
		    cf->file_ent->ce_opts : "", sticky);

		cvs_ent_add(entlist, entry);

		cvs_ent_free(ent);

		free(entry);
	}

	free(ba_rev);

	(void)cvs_base_handle(cf, BASE_REMOVE);

	if (fchmod(cf->fd, 0644) == -1)
		fatal("cvs_unedit_local: fchmod %s", strerror(errno));
}

static RCSNUM *
cvs_base_handle(struct cvs_file *cf, int flags)
{
	FILE *fp, *tfp;
	RCSNUM *ba_rev;
	int i;
	char *dp, *sp;
	char buf[PATH_MAX], *fields[2], rbuf[CVS_REV_BUFSZ];

	cvs_log(LP_TRACE, "cvs_base_handle(%s)", cf->file_path);

	tfp = NULL;
	ba_rev = NULL;

	if (((fp = fopen(CVS_PATH_BASEREV, "r")) == NULL) && errno != ENOENT) {
		cvs_log(LP_ERRNO, "%s", CVS_PATH_BASEREV);
		goto out;
	}

	if (flags & (BASE_ADD|BASE_REMOVE)) {
		if ((tfp = fopen(CVS_PATH_BASEREVTMP, "w")) == NULL) {
			cvs_log(LP_ERRNO, "%s", CVS_PATH_BASEREVTMP);
			goto out;
		}
	}

	if (fp != NULL) {
		while (fgets(buf, sizeof(buf), fp)) {
			buf[strcspn(buf, "\n")] = '\0';

			if (buf[0] != 'B')
				continue;

			sp = buf + 1;
			i = 0;
			do {
				if ((dp = strchr(sp, '/')) != NULL)
					*(dp++) = '\0';
				fields[i++] = sp;
				sp = dp;
			} while (dp != NULL && i < 2);

			if (cvs_file_cmpname(fields[0], cf->file_path) == 0) {
				if (flags & BASE_GET) {
					ba_rev = rcsnum_parse(fields[1]);
					if (ba_rev == NULL)
						fatal("cvs_base_handle: "
						    "rcsnum_parse");
					goto got_rev;
				}
			} else {
				if (flags & (BASE_ADD|BASE_REMOVE))
					(void)fprintf(tfp, "%s\n", buf);
			}
		}
	}

got_rev:
	if (flags & (BASE_ADD)) {
		(void)rcsnum_tostr(cf->file_ent->ce_rev, rbuf, sizeof(rbuf));
		(void)fprintf(tfp, "B%s/%s/\n", cf->file_path, rbuf);
	}

out:
	if (fp != NULL)
		(void)fclose(fp);

	if (tfp != NULL) {
		(void)fclose(tfp);
		(void)cvs_rename(CVS_PATH_BASEREVTMP, CVS_PATH_BASEREV);
	}

	return (ba_rev);
}
@


1.51
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.50 2015/01/16 06:40:07 deraadt Exp $	*/
d416 1
a416 1
	rcsnum_free(ba_rev);
@


1.50
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.49 2010/07/09 18:42:14 zinovik Exp $	*/
d21 1
d413 1
a413 1
		xfree(entry);
@


1.49
log
@when opencvs is started with trace option `-t' it must print function it
enters, even if it was executed simultaneously with `-n' (no exec option).
cvs_unedit_local() does not conform that behaviour, so lets make it behave
like all other functions.

ok xsa@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.48 2008/06/23 20:51:08 ragge Exp $	*/
d263 2
a264 2
	char timebuf[CVS_TIME_BUFSZ], thishost[MAXHOSTNAMELEN];
	char bfpath[MAXPATHLEN], wdir[MAXPATHLEN];
d305 1
a305 1
	(void)xsnprintf(bfpath, MAXPATHLEN, "%s/%s",
d330 2
a331 2
	char bfpath[MAXPATHLEN], timebuf[64], thishost[MAXHOSTNAMELEN];
	char wdir[MAXPATHLEN], sticky[CVS_ENT_MAXLINELEN];
d341 1
a341 1
	(void)xsnprintf(bfpath, MAXPATHLEN, "%s/%s",
d430 1
a430 1
	char buf[MAXPATHLEN], *fields[2], rbuf[CVS_REV_BUFSZ];
@


1.48
log
@Some conformance fixes:
- Empty brackets forbidden in C99.
- ? : and skipping middle argument is both disallowed and considered bad
  programming habit.
OK ray@@, xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.47 2008/06/14 03:19:15 joris Exp $	*/
d334 2
a337 2

	cvs_log(LP_TRACE, "cvs_unedit_local(%s)", cf->file_path);
@


1.47
log
@don't always re-open the same CVS/Entries file, instead keep the
last opened CVS/Entries around to operate on and close it whenever
we switch directory. gives us a small performance boost, obviously.

while doing this, switch the way we write revisions to disk by
using fwrite(3) so stuff can get written to disk in chunks
instead of writing everything line by line, another win.

with help from otto@@
ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.46 2008/06/11 02:19:13 tobias Exp $	*/
d47 1
a47 1
	{ },
d57 1
a57 1
	{ },
d67 1
a67 1
	{ },
d405 2
a406 2
		    cf->file_name, rbuf, timebuf, cf->file_ent->ce_opts ? : "",
		    sticky);
@


1.46
log
@Avoid possible NULL pointer dereferences by using reentrant versions
of time functions.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.45 2008/03/01 21:29:36 deraadt Exp $	*/
a410 1
		cvs_ent_close(entlist, ENT_SYNC);
@


1.45
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.44 2008/02/06 12:42:46 tobias Exp $	*/
d22 1
d261 1
a261 1
	struct tm *t;
d278 2
a279 4
	if ((t = gmtime(&now)) == NULL)
		fatal("gmtime failed");

	asctime_r(t, timebuf);
d328 1
a328 1
	struct tm *t;
d362 2
a363 4
	if ((t = gmtime(&now)) == NULL)
		fatal("gmtime failed");

	asctime_r(t, timebuf);
@


1.44
log
@Sticky tags must have a 'T' in front of them in CVS/Entries.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.43 2008/02/04 15:07:33 tobias Exp $	*/
d454 1
a454 1
		while(fgets(buf, sizeof(buf), fp)) {
@


1.43
log
@Added -k flag support for all commands which support it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.42 2008/01/31 10:15:05 tobias Exp $	*/
d332 1
a332 1
	char wdir[MAXPATHLEN];
d402 5
d409 1
a409 1
		    cf->file_ent->ce_tag ? : "");
@


1.42
log
@Replaced the unused cvs_command variable cmd_req with cmd_flags, which states
if the current command is supposed to use a working directory or if it is a
repository-only command (as of now checkout -p, rtag, rlog).

Makes the code simpler, easier to read and automagically fixes some issues
we encountered with these commands (for example if a working directory
exists, or "." operations are performed).

OK joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.41 2008/01/28 20:31:07 tobias Exp $	*/
d403 2
a404 3
		    cf->file_name, rbuf, timebuf,
		    (cf->file_ent->ce_tag) ? cf->file_ent->ce_tag : "",
		    (cf->file_ent->ce_opts) ? cf->file_ent->ce_opts : "");
@


1.41
log
@Properly handle -R -- although it is default, it may be overwritten mit -l
in front of it.

OK joris@@, xsa@@

> Diff from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.40 2008/01/10 10:08:22 tobias Exp $	*/
d45 1
a45 1
	CVS_OP_EDIT, 0, "edit",
d55 1
a55 1
	CVS_OP_EDITORS, 0, "editors",
d65 1
a65 1
	CVS_OP_UNEDIT, 0, "unedit",
@


1.40
log
@another strcspn() round
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.39 2007/10/05 19:28:23 gilles Exp $	*/
d103 1
d161 1
d216 1
@


1.39
log
@strcspn() change

was okay'd by pyr@@ and ok by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.38 2007/09/24 22:06:28 joris Exp $	*/
d278 1
a278 2
	if (timebuf[strlen(timebuf) - 1] == '\n')
                timebuf[strlen(timebuf) - 1] = '\0';
d364 1
a364 2
	if (timebuf[strlen(timebuf) - 1] == '\n')
                timebuf[strlen(timebuf) - 1] = '\0';
d397 1
a397 2
		if (timebuf[strlen(timebuf) - 1] == '\n')
			timebuf[strlen(timebuf) - 1] = '\0';
@


1.38
log
@oops i was suppose to pass cvs_directory_tag to cvs_file_classify().
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.37 2007/09/22 16:01:22 joris Exp $	*/
a427 1
	size_t len;
d451 1
a451 3
			len = strlen(buf);
			if (len > 0 && buf[len - 1] == '\n')
				buf[len - 1] = '\0';
@


1.37
log
@better branching/sticky tag support, no branch commits yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.36 2007/07/01 10:43:13 xsa Exp $	*/
d338 1
a338 1
	cvs_file_classify(cf, cvs_file_classify);
@


1.36
log
@Sync time buffer size; missed in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.35 2007/06/28 21:38:09 xsa Exp $	*/
d267 1
a267 1
	cvs_file_classify(cf, NULL);
d338 1
a338 1
	cvs_file_classify(cf, NULL);
@


1.35
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.34 2007/02/22 06:42:09 otto Exp $	*/
d259 2
a260 2
	char bfpath[MAXPATHLEN], timebuf[64], thishost[MAXHOSTNAMELEN];
	char wdir[MAXPATHLEN];
@


1.34
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.33 2007/02/17 18:23:43 xsa Exp $	*/
d388 1
a388 1
		char *entry, rbuf[16];
d431 1
a431 1
	char buf[MAXPATHLEN], *fields[2], rbuf[16];
@


1.33
log
@cvs_path_cat() removal since we can now easily handle that
functionality w/ xsnprintf(); Initial diff started by thib@@.
OK thib@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.32 2007/02/09 03:49:15 joris Exp $	*/
d18 5
a22 1
#include "includes.h"
a24 1
#include "log.h"
@


1.32
log
@remove the cvs_file_classify() `loud' argument, it was used
in the old school days and serves no purpose what so ever now.

otto@@ mentioned this to me a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.31 2007/01/25 18:56:33 otto Exp $	*/
d301 2
a302 3
	if (cvs_path_cat(CVS_PATH_BASEDIR, cf->file_name, bfpath,
	    MAXPATHLEN) >= MAXPATHLEN)
		fatal("cvs_edit_local: truncation");
d337 2
a338 3
	if (cvs_path_cat(CVS_PATH_BASEDIR, cf->file_name, bfpath,
	    MAXPATHLEN) >= MAXPATHLEN)
		fatal("cvs_unedit_local: truncation");
@


1.31
log
@use more stack allocations for fixed size buffers. ok xsa@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.30 2007/01/25 11:09:21 xsa Exp $	*/
d264 1
a264 1
	cvs_file_classify(cf, NULL, 0);
d336 1
a336 1
	cvs_file_classify(cf, NULL, 0);
@


1.30
log
@typo in error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.29 2007/01/11 15:45:02 xsa Exp $	*/
d256 2
a257 1
	char *bfpath, timebuf[64], thishost[MAXHOSTNAMELEN], wdir[MAXPATHLEN];
a300 1
	bfpath = xmalloc(MAXPATHLEN);
a311 2
	xfree(bfpath);

d327 2
a328 1
	char *bfpath, timebuf[64], thishost[MAXHOSTNAMELEN], wdir[MAXPATHLEN];
a337 1
	bfpath = xmalloc(MAXPATHLEN);
d342 1
a342 2
	if (stat(bfpath, &st) == -1) {
		xfree(bfpath);
a343 1
	}
d349 1
a349 2
		if (cvs_yesno() == -1) {
			xfree(bfpath);
a350 1
		}
a353 1
	xfree(bfpath);
@


1.29
log
@update the revision number in CVS/Entries from CVS/Baserev if we
are reverting to the revision that the user edited in the first place.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.28 2007/01/11 08:09:55 xsa Exp $	*/
d399 1
a399 1
			fatal("cvs_unedit_local: cvs_ent_parse failed");
@


1.28
log
@sync joris' last change (connection to remote server when all options are
valid) for the unedit command too.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.27 2007/01/11 02:35:55 joris Exp $	*/
d385 6
a390 1
	/* XXX: Update the revision number in CVS/Entries from CVS/Baserev */
d392 27
a418 6
		if ((ba_rev = cvs_base_handle(cf, BASE_GET)) == NULL) {
			cvs_log(LP_ERR, "%s not mentioned in %s",
			    cf->file_name, CVS_PATH_BASEREV);
			return;
		}
		rcsnum_free(ba_rev);
d420 2
@


1.27
log
@in a remote setup:
do not connect to the remote server until we are sure all the options
passed to the commands are valid.

noticed by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.26 2007/01/10 21:32:19 xsa Exp $	*/
d227 1
@


1.26
log
@add a cvs_file_copy routine and use it for the edit command to
copy the file in the current working directory to CVS/Base/
ok ray@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.25 2007/01/09 10:01:43 xsa Exp $	*/
d119 1
d173 1
@


1.25
log
@remove uneeded linebreak when creating the CVS/Notify
file with the edit command.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.24 2007/01/08 13:21:21 xsa Exp $	*/
d306 2
a307 1
	/* XXX: copy cf->file_path to bfpath */
@


1.24
log
@- simplify CVS/Baserev file parsing; makes unedit work better.
- add tracing messages in edit, unedit functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.23 2007/01/06 17:09:08 xsa Exp $	*/
d280 1
a280 1
	(void)fprintf(fp, "E%s\t%s GMT\t%s\t%s\t\n",
@


1.23
log
@add cvs_base_handle() routine to handle the CVS/Baserev* files.
first bits for the edit command for now.
definitly still more work to do for optimization...
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.22 2007/01/05 09:41:30 xsa Exp $	*/
d258 2
d326 1
d331 2
d382 10
d403 3
a405 2
	char *filename, *filerev, *p;
	char buf[MAXPATHLEN], rbuf[16];
d412 1
a412 1
	if ((fp = fopen(CVS_PATH_BASEREV, "r")) == NULL) {
d424 29
a452 23
	while(fgets(buf, sizeof(buf), fp)) {
		len = strlen(buf);
		if (len > 0 && buf[len - 1] == '\n')
			buf[len - 1] = '\0';

		if (buf[0] != 'B')
			continue;

		filename = buf;
		if((p = strchr(filename, '/')) == NULL)
			continue;

		filerev = p;
		if ((p = strchr(filerev, '/')) == NULL)
			continue;

		if (cvs_file_cmpname(filename, cf->file_path) == 0) {
			if (flags & BASE_GET) {
				*p = '\0';
				if ((ba_rev = rcsnum_parse(filerev)) == NULL)
					fatal("cvs_base_handle: rcsnum_parse");
				*p = '/';
				goto got_rev;
a453 3
		} else {
			if (flags & (BASE_ADD|BASE_REMOVE))
				(void)fprintf(tfp, "%s\n", buf);
@


1.22
log
@for edit: create the CVS/Base directory if it does not already exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.21 2007/01/05 09:32:49 xsa Exp $	*/
d29 4
d37 2
d258 2
d308 1
a308 1
	/* XXX: Update revision number in CVS/Baserev from CVS/Entries */
d328 2
d369 1
a370 1
		fatal("getcwd failed");
d376 1
a376 1
	/* XXX: Update revision number in CVS/Entries from CVS/Baserev */
d380 74
@


1.21
log
@use current working directory fullpath for notifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.20 2007/01/05 09:15:00 xsa Exp $	*/
d291 4
@


1.20
log
@correctly handle time in notifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.19 2007/01/05 08:52:37 xsa Exp $	*/
d247 1
a247 1
	char *bfpath, timebuf[64], thishost[MAXHOSTNAMELEN];
d267 3
d271 1
a271 1
	    cf->file_name, timebuf, thishost, cf->file_wd);
d311 1
a311 1
	char *bfpath, timebuf[64], thishost[MAXHOSTNAMELEN];
d354 3
d358 1
a358 1
	    cf->file_name, timebuf, thishost, cf->file_wd);
@


1.19
log
@use correct hostname for notifications.

also, in a near future, might be worth thinking about sharing
some code between the edit and unedit commands, would shrink
the mess a little bit...
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.18 2007/01/05 08:37:55 xsa Exp $	*/
d247 1
a247 1
	char *bfpath, *fdate, thishost[MAXHOSTNAMELEN];
d260 3
a262 1
	fdate = asctime(t);
d268 1
a268 1
	    cf->file_name, fdate, thishost, cf->file_wd);
d308 1
a308 1
	char *bfpath, *fdate, thishost[MAXHOSTNAMELEN];
d344 3
a346 1
	fdate = asctime(t);
d352 1
a352 1
	    cf->file_name, fdate, thishost, cf->file_wd);
@


1.18
log
@starting bits for the edit command. more to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.17 2007/01/05 07:13:49 xsa Exp $	*/
d247 1
a247 1
	char *bfpath, *fdate;
d262 3
d266 1
a266 1
	    cf->file_name, fdate, current_cvsroot->cr_host, cf->file_wd);
d306 1
a306 1
	char *bfpath, *fdate;
d344 3
d348 1
a348 1
	    cf->file_name, fdate, current_cvsroot->cr_host, cf->file_wd);
@


1.17
log
@- introduce file comparison routine, cvs_file_cmp().
- compare the <file> in working dir and the one in CVS/Base/<file>
  for the unedit command.
hints otto@@, input and ok ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.16 2007/01/03 09:49:37 xsa Exp $	*/
d24 6
d33 12
d66 70
d239 50
@


1.16
log
@set permissions back on the file after it got copied from the
CVS/Base/ directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.15 2007/01/02 14:51:18 xsa Exp $	*/
d180 9
a188 1
	/* XXX: compare cf->file_path and bfpath */
@


1.15
log
@some unedit command bits; still work in progress for local mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.14 2007/01/02 13:51:13 xsa Exp $	*/
d201 3
@


1.14
log
@skeletons for the client-side part of the editors and watchers commands.
not linked to build.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 1
 * Copyright (c) 2006 Xavier Santolaria <xsa@@openbsd.org>
d25 1
d37 10
d100 53
d156 45
@


1.13
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.12 2006/03/16 09:06:19 xsa Exp $	*/
d3 1
a3 2
 * Copyright (c) 2005 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
d5 11
a15 19
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d22 1
a22 10
#include "proto.h"



static int	cvs_edit_init(struct cvs_cmd *, int, char **, int *);
static int	cvs_edit_remote(CVSFILE *, void *);
static int	cvs_edit_local(CVSFILE *, void *);

static int	cvs_editors_remote(CVSFILE *, void *);

d24 1
a24 16
struct cvs_cmd cvs_cmd_edit = {
	CVS_OP_EDIT, CVS_REQ_NOOP, "edit",
	{ },
	"Mark a file as being edited",
	"[-lR] [-a action] [file ...]",
	"a:lR",
	NULL,
	CF_SORT | CF_RECURSE,
	cvs_edit_init,
	NULL,
	cvs_edit_remote,
	cvs_edit_local,
	NULL,
	NULL,
	0
};
d27 1
a27 19
	CVS_OP_EDITORS, CVS_REQ_EDITORS, "editors",
	{ },
	"List editors on a file",
	"[-lR] [file ...]",
	"lR",
	NULL,
	CF_SORT | CF_RECURSE,
	cvs_edit_init,
	NULL,
	cvs_editors_remote,
	NULL,
	NULL,
	NULL,
	CVS_CMD_SENDDIR | CVS_CMD_ALLOWSPEC | CVS_CMD_SENDARGS2
};


struct cvs_cmd cvs_cmd_unedit = {
	CVS_OP_UNEDIT, CVS_REQ_NOOP, "unedit",
d29 1
a29 1
	"Undo an edit command",
d33 1
a33 8
	CF_SORT | CF_RECURSE,
	cvs_edit_init,
	NULL,
	cvs_edit_remote,
	cvs_edit_local,
	NULL,
	NULL,
	0
d36 2
a37 4


static int
cvs_edit_init(struct cvs_cmd *cmd, int argc, char **argv, int *arg)
d40 4
d45 1
a45 1
	while ((ch = getopt(argc, argv, cmd->cmd_opts)) != -1) {
a46 8
		case 'a':
			/*
			 * The `editors' and `unedit' commands do not have
			 * the -a option. Check which command has been issued.
			 */
			if (cvs_cmdop != CVS_OP_EDIT)
				return (CVS_EX_USAGE);
			break;
d48 1
a48 1
			cmd->file_flags &= ~CF_RECURSE;
a50 1
			cmd->file_flags |= CF_RECURSE;
d53 1
a53 1
			return (CVS_EX_USAGE);
d57 2
a58 3
	*arg = optind;
	return (CVS_EX_OK);
}
d60 2
d63 2
a64 9
/*
 * cvs_edit_remote()
 *
 */
static int
cvs_edit_remote(CVSFILE *cf, void *arg)
{
	return (CVS_EX_OK);
}
d66 8
d75 1
a75 19
/*
 * cvs_edit_local()
 *
 */
static int
cvs_edit_local(CVSFILE *cf, void *arg)
{
	return (CVS_EX_OK);
}


/*
 * cvs_editors_remote()
 *
 */
static int
cvs_editors_remote(CVSFILE *cf, void *arg)
{
	struct cvsroot *root;
d77 1
a77 1
	root = CVS_DIR_ROOT(cf);
d79 5
a83 6
	if (cf->cf_type == DT_DIR) {
		if (cf->cf_cvstat == CVS_FST_UNKNOWN)
			cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		else
			cvs_senddir(root, cf);
		return (0);
d86 2
a87 1
	cvs_sendentry(root, cf);
d89 3
a91 16
	switch (cf->cf_cvstat) {
	case CVS_FST_UNKNOWN:
		cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
		break;
	case CVS_FST_UPTODATE:
		cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
		break;
	case CVS_FST_ADDED:
	case CVS_FST_MODIFIED:
		cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);
		break;
	default:
		break;
	}

	return (0);
@


1.12
log
@zap more unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.11 2006/01/02 08:11:56 xsa Exp $	*/
@


1.11
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.10 2005/12/30 02:03:28 joris Exp $	*/
d99 1
a99 4
	int ch, dflag, mod_count;

	dflag = 0;
	mod_count = 0;
a133 4
	int *mod_count;

	mod_count = (int *)arg;

a144 4
	int *mod_count;

	mod_count = (int *)arg;

@


1.10
log
@major cleanup of the functions handling the remote cvs protocol.
makes the code a lot more readable and understandable.

ok xsa@@ and niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.9 2005/10/10 17:51:53 xsa Exp $	*/
d27 1
a27 9
#include <sys/types.h>

#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.9
log
@- editors remote handler
- minor consistency tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.8 2005/07/25 12:05:43 xsa Exp $	*/
a174 1
	int ret;
a176 1
	ret = 0;
d181 1
a181 2
			ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE,
			    cf->cf_name);
d183 2
a184 6
			ret = cvs_senddir(root, cf);

		if (ret == -1)
			ret = CVS_EX_PROTO;

		return (ret);
d187 1
a187 2
	if (cvs_sendentry(root, cf) < 0)
		return (CVS_EX_PROTO);
d191 1
a191 1
		ret = cvs_sendreq(root, CVS_REQ_QUESTIONABLE, cf->cf_name);
d194 1
a194 1
		ret = cvs_sendreq(root, CVS_REQ_UNCHANGED, cf->cf_name);
d198 1
a198 1
		ret = cvs_sendreq(root, CVS_REQ_ISMODIFIED, cf->cf_name);
d204 1
a204 5

	if (ret == -1)
		ret = CVS_EX_PROTO;

	return (ret);
@


1.8
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.7 2005/07/10 21:51:23 joris Exp $	*/
d47 2
d74 1
a74 1
	0,
d77 2
a78 2
	cvs_edit_remote,
	cvs_edit_local,
d81 1
a81 1
	0
d143 1
a143 1
cvs_edit_remote(CVSFILE *file, void *arg)
d158 1
a158 1
cvs_edit_local(CVSFILE *file, void *arg)
d165 52
@


1.7
log
@

zap unused variables;
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.6 2005/05/31 10:54:05 xsa Exp $	*/
d43 3
a45 3
static int cvs_edit_init   (struct cvs_cmd *, int, char **, int *);
static int cvs_edit_remote (CVSFILE *, void *);
static int cvs_edit_local  (CVSFILE *, void *);
@


1.6
log
@add some comments ..
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.5 2005/05/31 08:58:47 xsa Exp $	*/
d105 1
a105 2
	int i, ch, dflag, mod_count;
	struct cvsroot *root;
@


1.5
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.4 2005/05/28 20:39:08 xsa Exp $	*/
d114 4
@


1.4
log
@we do not use sysexits.h anymore, nuke it!
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.3 2005/05/26 14:46:22 xsa Exp $	*/
d31 1
a34 1
#include <libgen.h>
@


1.3
log
@fix `editors' and `unedit' commands usage..
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.2 2005/05/26 07:27:01 xsa Exp $	*/
a34 1
#include <sysexits.h>
@


1.2
log
@fix usage..
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.1 2005/05/25 22:07:54 jfb Exp $	*/
d70 2
a71 2
	"",
	"",
d88 1
a88 1
	"[-lR] ...",
@


1.1
log
@skeleton for the edit-related functions, not linked in yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a53 1
	"[-lR] [-a action ...",
@

