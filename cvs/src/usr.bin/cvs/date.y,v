head	1.26;
access;
symbols
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.10
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.12
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.18.0.8
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8;
locks; strict;
comment	@ * @;


1.26
date	2017.07.20.13.39.11;	author okan;	state Exp;
branches;
next	1.25;
commitid	T32m2rxSLuieGVdj;

1.25
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.24;
commitid	O6jeJ0TRmiewrqMI;

1.24
date	2013.12.03.00.23.45;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.04.19.17.28.06;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.31.08.54.42;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.29.18.52.45;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.23.09.11.10;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.16.01.00.00;	author cnst;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.06.12.55.48;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.20.06.57.54;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.09.15.55.55;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.03.14.26.13;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.29.04.42.46;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.07.21.47.32;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.25.19.11.34;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.20.17.15.49;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.19.04.17.24;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.18.21.55.13;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.30.16.41.07;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.28.22.40.58;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.24.15.40.43;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.24.03.07.04;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.23.20.00.18;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Add missing <time.h> header.

ok joris@@
@
text
@%{
/*	$OpenBSD: date.y,v 1.25 2015/11/05 09:48:21 nicm Exp $	*/

/*
**  Originally written by Steven M. Bellovin <smb@@research.att.com> while
**  at the University of North Carolina at Chapel Hill.  Later tweaked by
**  a couple of people on Usenet.  Completely overhauled by Rich $alz
**  <rsalz@@bbn.com> and Jim Berets <jberets@@bbn.com> in August, 1990;
**
**  This grammar has 10 shift/reduce conflicts.
**
**  This code is in the public domain and has no copyright.
*/
/* SUPPRESS 287 on yaccpar_sccsid *//* Unused static variable */
/* SUPPRESS 288 on yyerrlab *//* Label unused */

#include <ctype.h>
#include <string.h>
#include <time.h>

#include "cvs.h"

#define YEAR_EPOCH	1970
#define YEAR_TMORIGIN	1900
#define HOUR(x)		((time_t)(x) * 60)
#define SECSPERDAY	(24L * 60L * 60L)


/* An entry in the lexical lookup table */
typedef struct _TABLE {
	char	*name;
	int	type;
	time_t	value;
} TABLE;


/*  Daylight-savings mode:  on, off, or not yet known. */
typedef enum _DSTMODE {
	DSTon, DSToff, DSTmaybe
} DSTMODE;

/*  Meridian:  am, pm, or 24-hour style. */
typedef enum _MERIDIAN {
	MERam, MERpm, MER24
} MERIDIAN;


/*
 *  Global variables.  We could get rid of most of these by using a good
 *  union as the yacc stack.  (This routine was originally written before
 *  yacc had the %union construct.)  Maybe someday; right now we only use
 *  the %union very rarely.
 */
static const char	*yyInput;
static DSTMODE	yyDSTmode;
static time_t	yyDayOrdinal;
static time_t	yyDayNumber;
static int	yyHaveDate;
static int	yyHaveDay;
static int	yyHaveRel;
static int	yyHaveTime;
static int	yyHaveZone;
static time_t	yyTimezone;
static time_t	yyDay;
static time_t	yyHour;
static time_t	yyMinutes;
static time_t	yyMonth;
static time_t	yySeconds;
static time_t	yyYear;
static MERIDIAN	yyMeridian;
static time_t	yyRelMonth;
static time_t	yyRelSeconds;


static int	yyerror(const char *);
static int	yylex(void);
static int	yyparse(void);
static int	lookup(char *);

%}

%union {
	time_t		Number;
	enum _MERIDIAN	Meridian;
}

%token	tAGO tDAY tDAYZONE tID tMERIDIAN tMINUTE_UNIT tMONTH tMONTH_UNIT
%token	tSEC_UNIT tSNUMBER tUNUMBER tZONE tDST

%type	<Number>	tDAY tDAYZONE tMINUTE_UNIT tMONTH tMONTH_UNIT
%type	<Number>	tSEC_UNIT tSNUMBER tUNUMBER tZONE
%type	<Meridian>	tMERIDIAN o_merid

%%

spec	: /* NULL */
	| spec item
	;

item	: time {
		yyHaveTime++;
	}
	| zone {
		yyHaveZone++;
	}
	| date {
		yyHaveDate++;
	}
	| day {
		yyHaveDay++;
	}
	| rel {
		yyHaveRel++;
	}
	| number
	;

time	: tUNUMBER tMERIDIAN {
		yyHour = $1;
		yyMinutes = 0;
		yySeconds = 0;
		yyMeridian = $2;
	}
	| tUNUMBER ':' tUNUMBER o_merid {
		yyHour = $1;
		yyMinutes = $3;
		yySeconds = 0;
		yyMeridian = $4;
	}
	| tUNUMBER ':' tUNUMBER tSNUMBER {
		yyHour = $1;
		yyMinutes = $3;
		yyMeridian = MER24;
		yyDSTmode = DSToff;
		yyTimezone = - ($4 % 100 + ($4 / 100) * 60);
	}
	| tUNUMBER ':' tUNUMBER ':' tUNUMBER o_merid {
		yyHour = $1;
		yyMinutes = $3;
		yySeconds = $5;
		yyMeridian = $6;
	}
	| tUNUMBER ':' tUNUMBER ':' tUNUMBER tSNUMBER {
		yyHour = $1;
		yyMinutes = $3;
		yySeconds = $5;
		yyMeridian = MER24;
		yyDSTmode = DSToff;
		yyTimezone = - ($6 % 100 + ($6 / 100) * 60);
	}
	;

zone	: tZONE {
		yyTimezone = $1;
		yyDSTmode = DSToff;
	}
	| tDAYZONE {
		yyTimezone = $1;
		yyDSTmode = DSTon;
	}
	| tZONE tDST {
		yyTimezone = $1;
		yyDSTmode = DSTon;
	}
	;

day	: tDAY {
		yyDayOrdinal = 1;
		yyDayNumber = $1;
	}
	| tDAY ',' {
		yyDayOrdinal = 1;
		yyDayNumber = $1;
	}
	| tUNUMBER tDAY {
		yyDayOrdinal = $1;
		yyDayNumber = $2;
	}
	;

date	: tUNUMBER '/' tUNUMBER {
		yyMonth = $1;
		yyDay = $3;
	}
	| tUNUMBER '/' tUNUMBER '/' tUNUMBER {
		if ($1 >= 100) {
			yyYear = $1;
			yyMonth = $3;
			yyDay = $5;
		} else {
			yyMonth = $1;
			yyDay = $3;
			yyYear = $5;
		}
	}
	| tUNUMBER tSNUMBER tSNUMBER {
		/* ISO 8601 format.  yyyy-mm-dd.  */
		yyYear = $1;
		yyMonth = -$2;
		yyDay = -$3;
	}
	| tUNUMBER tMONTH tSNUMBER {
		/* e.g. 17-JUN-1992.  */
		yyDay = $1;
		yyMonth = $2;
		yyYear = -$3;
	}
	| tMONTH tUNUMBER {
		yyMonth = $1;
		yyDay = $2;
	}
	| tMONTH tUNUMBER ',' tUNUMBER {
		yyMonth = $1;
		yyDay = $2;
		yyYear = $4;
	}
	| tUNUMBER tMONTH {
		yyMonth = $2;
		yyDay = $1;
	}
	| tUNUMBER tMONTH tUNUMBER {
		yyMonth = $2;
		yyDay = $1;
		yyYear = $3;
	}
	;

rel	: relunit tAGO {
		yyRelSeconds = -yyRelSeconds;
		yyRelMonth = -yyRelMonth;
	}
	| relunit
	;

relunit	: tUNUMBER tMINUTE_UNIT {
		yyRelSeconds += $1 * $2 * 60L;
	}
	| tSNUMBER tMINUTE_UNIT {
		yyRelSeconds += $1 * $2 * 60L;
	}
	| tMINUTE_UNIT {
		yyRelSeconds += $1 * 60L;
	}
	| tSNUMBER tSEC_UNIT {
		yyRelSeconds += $1;
	}
	| tUNUMBER tSEC_UNIT {
		yyRelSeconds += $1;
	}
	| tSEC_UNIT {
		yyRelSeconds++;
	}
	| tSNUMBER tMONTH_UNIT {
		yyRelMonth += $1 * $2;
	}
	| tUNUMBER tMONTH_UNIT {
		yyRelMonth += $1 * $2;
	}
	| tMONTH_UNIT {
		yyRelMonth += $1;
	}
	;

number	: tUNUMBER {
		if (yyHaveTime && yyHaveDate && !yyHaveRel)
			yyYear = $1;
		else {
			if ($1 > 10000) {
				yyHaveDate++;
				yyDay= ($1)%100;
				yyMonth= ($1/100)%100;
				yyYear = $1/10000;
			} else {
				yyHaveTime++;
				if ($1 < 100) {
					yyHour = $1;
					yyMinutes = 0;
				} else {
					yyHour = $1 / 100;
					yyMinutes = $1 % 100;
				}
				yySeconds = 0;
				yyMeridian = MER24;
			}
		}
	}
	;

o_merid	: /* NULL */ {
		$$ = MER24;
	}
	| tMERIDIAN {
		$$ = $1;
	}
	;

%%

/* Month and day table. */
static TABLE const MonthDayTable[] = {
	{ "january",	tMONTH,	1 },
	{ "february",	tMONTH,	2 },
	{ "march",	tMONTH,	3 },
	{ "april",	tMONTH,	4 },
	{ "may",	tMONTH,	5 },
	{ "june",	tMONTH,	6 },
	{ "july",	tMONTH,	7 },
	{ "august",	tMONTH,	8 },
	{ "september",	tMONTH,	9 },
	{ "sept",	tMONTH,	9 },
	{ "october",	tMONTH,	10 },
	{ "november",	tMONTH,	11 },
	{ "december",	tMONTH,	12 },
	{ "sunday",	tDAY,	0 },
	{ "monday",	tDAY,	1 },
	{ "tuesday",	tDAY,	2 },
	{ "tues",	tDAY,	2 },
	{ "wednesday",	tDAY,	3 },
	{ "wednes",	tDAY,	3 },
	{ "thursday",	tDAY,	4 },
	{ "thur",	tDAY,	4 },
	{ "thurs",	tDAY,	4 },
	{ "friday",	tDAY,	5 },
	{ "saturday",	tDAY,	6 },
	{ NULL }
};

/* Time units table. */
static TABLE const UnitsTable[] = {
	{ "year",	tMONTH_UNIT,	12 },
	{ "month",	tMONTH_UNIT,	1 },
	{ "fortnight",	tMINUTE_UNIT,	14 * 24 * 60 },
	{ "week",	tMINUTE_UNIT,	7 * 24 * 60 },
	{ "day",	tMINUTE_UNIT,	1 * 24 * 60 },
	{ "hour",	tMINUTE_UNIT,	60 },
	{ "minute",	tMINUTE_UNIT,	1 },
	{ "min",	tMINUTE_UNIT,	1 },
	{ "second",	tSEC_UNIT,	1 },
	{ "sec",	tSEC_UNIT,	1 },
	{ NULL }
};

/* Assorted relative-time words. */
static TABLE const OtherTable[] = {
	{ "tomorrow",	tMINUTE_UNIT,	1 * 24 * 60 },
	{ "yesterday",	tMINUTE_UNIT,	-1 * 24 * 60 },
	{ "today",	tMINUTE_UNIT,	0 },
	{ "now",	tMINUTE_UNIT,	0 },
	{ "last",	tUNUMBER,	-1 },
	{ "this",	tMINUTE_UNIT,	0 },
	{ "next",	tUNUMBER,	2 },
	{ "first",	tUNUMBER,	1 },
/*  { "second",		tUNUMBER,	2 }, */
	{ "third",	tUNUMBER,	3 },
	{ "fourth",	tUNUMBER,	4 },
	{ "fifth",	tUNUMBER,	5 },
	{ "sixth",	tUNUMBER,	6 },
	{ "seventh",	tUNUMBER,	7 },
	{ "eighth",	tUNUMBER,	8 },
	{ "ninth",	tUNUMBER,	9 },
	{ "tenth",	tUNUMBER,	10 },
	{ "eleventh",	tUNUMBER,	11 },
	{ "twelfth",	tUNUMBER,	12 },
	{ "ago",	tAGO,	1 },
	{ NULL }
};

/* The timezone table. */
/* Some of these are commented out because a time_t can't store a float. */
static TABLE const TimezoneTable[] = {
	{ "gmt",	tZONE,     HOUR( 0) },	/* Greenwich Mean */
	{ "ut",		tZONE,     HOUR( 0) },	/* Universal (Coordinated) */
	{ "utc",	tZONE,     HOUR( 0) },
	{ "wet",	tZONE,     HOUR( 0) },	/* Western European */
	{ "bst",	tDAYZONE,  HOUR( 0) },	/* British Summer */
	{ "wat",	tZONE,     HOUR( 1) },	/* West Africa */
	{ "at",		tZONE,     HOUR( 2) },	/* Azores */
#if	0
	/* For completeness.  BST is also British Summer, and GST is
	 * also Guam Standard. */
	{ "bst",	tZONE,     HOUR( 3) },	/* Brazil Standard */
	{ "gst",	tZONE,     HOUR( 3) },	/* Greenland Standard */
#endif
#if 0
	{ "nft",	tZONE,     HOUR(3.5) },	/* Newfoundland */
	{ "nst",	tZONE,     HOUR(3.5) },	/* Newfoundland Standard */
	{ "ndt",	tDAYZONE,  HOUR(3.5) },	/* Newfoundland Daylight */
#endif
	{ "ast",	tZONE,     HOUR( 4) },	/* Atlantic Standard */
	{ "adt",	tDAYZONE,  HOUR( 4) },	/* Atlantic Daylight */
	{ "est",	tZONE,     HOUR( 5) },	/* Eastern Standard */
	{ "edt",	tDAYZONE,  HOUR( 5) },	/* Eastern Daylight */
	{ "cst",	tZONE,     HOUR( 6) },	/* Central Standard */
	{ "cdt",	tDAYZONE,  HOUR( 6) },	/* Central Daylight */
	{ "mst",	tZONE,     HOUR( 7) },	/* Mountain Standard */
	{ "mdt",	tDAYZONE,  HOUR( 7) },	/* Mountain Daylight */
	{ "pst",	tZONE,     HOUR( 8) },	/* Pacific Standard */
	{ "pdt",	tDAYZONE,  HOUR( 8) },	/* Pacific Daylight */
	{ "yst",	tZONE,     HOUR( 9) },	/* Yukon Standard */
	{ "ydt",	tDAYZONE,  HOUR( 9) },	/* Yukon Daylight */
	{ "hst",	tZONE,     HOUR(10) },	/* Hawaii Standard */
	{ "hdt",	tDAYZONE,  HOUR(10) },	/* Hawaii Daylight */
	{ "cat",	tZONE,     HOUR(10) },	/* Central Alaska */
	{ "ahst",	tZONE,     HOUR(10) },	/* Alaska-Hawaii Standard */
	{ "nt",		tZONE,     HOUR(11) },	/* Nome */
	{ "idlw",	tZONE,     HOUR(12) },	/* International Date Line West */
	{ "cet",	tZONE,     -HOUR(1) },	/* Central European */
	{ "met",	tZONE,     -HOUR(1) },	/* Middle European */
	{ "mewt",	tZONE,     -HOUR(1) },	/* Middle European Winter */
	{ "mest",	tDAYZONE,  -HOUR(1) },	/* Middle European Summer */
	{ "swt",	tZONE,     -HOUR(1) },	/* Swedish Winter */
	{ "sst",	tDAYZONE,  -HOUR(1) },	/* Swedish Summer */
	{ "fwt",	tZONE,     -HOUR(1) },	/* French Winter */
	{ "fst",	tDAYZONE,  -HOUR(1) },	/* French Summer */
	{ "eet",	tZONE,     -HOUR(2) },	/* Eastern Europe, USSR Zone 1 */
	{ "bt",		tZONE,     -HOUR(3) },	/* Baghdad, USSR Zone 2 */
#if 0
	{ "it",		tZONE,     -HOUR(3.5) },/* Iran */
#endif
	{ "zp4",	tZONE,     -HOUR(4) },	/* USSR Zone 3 */
	{ "zp5",	tZONE,     -HOUR(5) },	/* USSR Zone 4 */
#if 0
	{ "ist",	tZONE,     -HOUR(5.5) },/* Indian Standard */
#endif
	{ "zp6",	tZONE,     -HOUR(6) },	/* USSR Zone 5 */
#if	0
	/* For completeness.  NST is also Newfoundland Stanard, and SST is
	 * also Swedish Summer. */
	{ "nst",	tZONE,     -HOUR(6.5) },/* North Sumatra */
	{ "sst",	tZONE,     -HOUR(7) },	/* South Sumatra, USSR Zone 6 */
#endif	/* 0 */
	{ "wast",	tZONE,     -HOUR(7) },	/* West Australian Standard */
	{ "wadt",	tDAYZONE,  -HOUR(7) },	/* West Australian Daylight */
#if 0
	{ "jt",		tZONE,     -HOUR(7.5) },/* Java (3pm in Cronusland!) */
#endif
	{ "cct",	tZONE,     -HOUR(8) },	/* China Coast, USSR Zone 7 */
	{ "jst",	tZONE,     -HOUR(9) },	/* Japan Standard, USSR Zone 8 */
#if 0
	{ "cast",	tZONE,     -HOUR(9.5) },/* Central Australian Standard */
	{ "cadt",	tDAYZONE,  -HOUR(9.5) },/* Central Australian Daylight */
#endif
	{ "east",	tZONE,     -HOUR(10) },	/* Eastern Australian Standard */
	{ "eadt",	tDAYZONE,  -HOUR(10) },	/* Eastern Australian Daylight */
	{ "gst",	tZONE,     -HOUR(10) },	/* Guam Standard, USSR Zone 9 */
	{ "nzt",	tZONE,     -HOUR(12) },	/* New Zealand */
	{ "nzst",	tZONE,     -HOUR(12) },	/* New Zealand Standard */
	{ "nzdt",	tDAYZONE,  -HOUR(12) },	/* New Zealand Daylight */
	{ "idle",	tZONE,     -HOUR(12) },	/* International Date Line East */
	{  NULL  }
};

/* Military timezone table. */
static TABLE const MilitaryTable[] = {
	{ "a",	tZONE,	HOUR(  1) },
	{ "b",	tZONE,	HOUR(  2) },
	{ "c",	tZONE,	HOUR(  3) },
	{ "d",	tZONE,	HOUR(  4) },
	{ "e",	tZONE,	HOUR(  5) },
	{ "f",	tZONE,	HOUR(  6) },
	{ "g",	tZONE,	HOUR(  7) },
	{ "h",	tZONE,	HOUR(  8) },
	{ "i",	tZONE,	HOUR(  9) },
	{ "k",	tZONE,	HOUR( 10) },
	{ "l",	tZONE,	HOUR( 11) },
	{ "m",	tZONE,	HOUR( 12) },
	{ "n",	tZONE,	HOUR(- 1) },
	{ "o",	tZONE,	HOUR(- 2) },
	{ "p",	tZONE,	HOUR(- 3) },
	{ "q",	tZONE,	HOUR(- 4) },
	{ "r",	tZONE,	HOUR(- 5) },
	{ "s",	tZONE,	HOUR(- 6) },
	{ "t",	tZONE,	HOUR(- 7) },
	{ "u",	tZONE,	HOUR(- 8) },
	{ "v",	tZONE,	HOUR(- 9) },
	{ "w",	tZONE,	HOUR(-10) },
	{ "x",	tZONE,	HOUR(-11) },
	{ "y",	tZONE,	HOUR(-12) },
	{ "z",	tZONE,	HOUR(  0) },
	{ NULL }
};


static int
yyerror(const char *s)
{
#if !defined(TEST)
	char *str;

	(void)xasprintf(&str, "parsing date string: %s", s);
	cvs_log(LP_ERR, "%s", str);
	free(str);
#endif
	return (0);
}


static time_t
ToSeconds(time_t Hours, time_t Minutes, time_t	Seconds, MERIDIAN Meridian)
{
	if (Minutes < 0 || Minutes > 59 || Seconds < 0 || Seconds > 59)
		return (-1);

	switch (Meridian) {
	case MER24:
		if (Hours < 0 || Hours > 23)
			return (-1);
		return (Hours * 60L + Minutes) * 60L + Seconds;
	case MERam:
		if (Hours < 1 || Hours > 12)
			return (-1);
		if (Hours == 12)
			Hours = 0;
		return (Hours * 60L + Minutes) * 60L + Seconds;
	case MERpm:
		if (Hours < 1 || Hours > 12)
			return (-1);
		if (Hours == 12)
			Hours = 0;
		return ((Hours + 12) * 60L + Minutes) * 60L + Seconds;
	default:
		return (-1);
	}
	/* NOTREACHED */
}


/* Year is either
 * A negative number, which means to use its absolute value (why?)
 * A number from 0 to 99, which means a year from 1900 to 1999, or
 * The actual year (>=100).
 */
static time_t
Convert(time_t Month, time_t Day, time_t Year, time_t Hours, time_t Minutes,
    time_t Seconds, MERIDIAN Meridian, DSTMODE DSTmode)
{
	static int DaysInMonth[12] = {
		31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
	};
	time_t	tod;
	time_t	julian;
	int	i;

	if (Year < 0)
		Year = -Year;
	if (Year < 69)
		Year += 2000;
	else if (Year < 100) {
		Year += 1900;
		if (Year < YEAR_EPOCH)
			Year += 100;
	}
	DaysInMonth[1] = Year % 4 == 0 && (Year % 100 != 0 || Year % 400 == 0)
	    ? 29 : 28;
	/* XXX Sloppily check for 2038 if time_t is 32 bits */
	if (Year < YEAR_EPOCH ||
	    (sizeof(time_t) == sizeof(int) && Year > 2038) ||
	    Month < 1 || Month > 12 ||
	    /* Lint fluff:  "conversion from long may lose accuracy" */
	     Day < 1 || Day > DaysInMonth[(int)--Month])
		return (-1);

	for (julian = Day - 1, i = 0; i < Month; i++)
		julian += DaysInMonth[i];

	for (i = YEAR_EPOCH; i < Year; i++)
		julian += 365 + (i % 4 == 0);
	julian *= SECSPERDAY;
	julian += yyTimezone * 60L;

	if ((tod = ToSeconds(Hours, Minutes, Seconds, Meridian)) < 0)
		return (-1);
	julian += tod;
	if ((DSTmode == DSTon) ||
	    (DSTmode == DSTmaybe && localtime(&julian)->tm_isdst))
	julian -= 60 * 60;
	return (julian);
}


static time_t
DSTcorrect(time_t Start, time_t Future)
{
	time_t	StartDay;
	time_t	FutureDay;

	StartDay = (localtime(&Start)->tm_hour + 1) % 24;
	FutureDay = (localtime(&Future)->tm_hour + 1) % 24;
	return (Future - Start) + (StartDay - FutureDay) * 60L * 60L;
}


static time_t
RelativeDate(time_t Start, time_t DayOrdinal, time_t DayNumber)
{
	struct tm	*tm;
	time_t	now;

	now = Start;
	tm = localtime(&now);
	now += SECSPERDAY * ((DayNumber - tm->tm_wday + 7) % 7);
	now += 7 * SECSPERDAY * (DayOrdinal <= 0 ? DayOrdinal : DayOrdinal - 1);
	return DSTcorrect(Start, now);
}


static time_t
RelativeMonth(time_t Start, time_t RelMonth)
{
	struct tm	*tm;
	time_t	Month;
	time_t	Year;

	if (RelMonth == 0)
		return (0);
	tm = localtime(&Start);
	Month = 12 * (tm->tm_year + 1900) + tm->tm_mon + RelMonth;
	Year = Month / 12;
	Month = Month % 12 + 1;
	return DSTcorrect(Start,
	    Convert(Month, (time_t)tm->tm_mday, Year,
	    (time_t)tm->tm_hour, (time_t)tm->tm_min, (time_t)tm->tm_sec,
	    MER24, DSTmaybe));
}


static int
lookup(char *buff)
{
	size_t		len;
	char		*p, *q;
	int		i, abbrev;
	const TABLE	*tp;

	/* Make it lowercase. */
	for (p = buff; *p; p++)
		if (isupper(*p))
			*p = tolower(*p);

	if (strcmp(buff, "am") == 0 || strcmp(buff, "a.m.") == 0) {
		yylval.Meridian = MERam;
		return (tMERIDIAN);
	}
	if (strcmp(buff, "pm") == 0 || strcmp(buff, "p.m.") == 0) {
		yylval.Meridian = MERpm;
		return (tMERIDIAN);
	}

	len = strlen(buff);
	/* See if we have an abbreviation for a month. */
	if (len == 3)
		abbrev = 1;
	else if (len == 4 && buff[3] == '.') {
		abbrev = 1;
		buff[3] = '\0';
		--len;
	} else
		abbrev = 0;

	for (tp = MonthDayTable; tp->name; tp++) {
		if (abbrev) {
			if (strncmp(buff, tp->name, 3) == 0) {
				yylval.Number = tp->value;
				return (tp->type);
			}
		} else if (strcmp(buff, tp->name) == 0) {
			yylval.Number = tp->value;
			return (tp->type);
		}
	}

	for (tp = TimezoneTable; tp->name; tp++)
		if (strcmp(buff, tp->name) == 0) {
			yylval.Number = tp->value;
			return (tp->type);
		}

	if (strcmp(buff, "dst") == 0)
		return (tDST);

	for (tp = UnitsTable; tp->name; tp++)
		if (strcmp(buff, tp->name) == 0) {
			yylval.Number = tp->value;
			return (tp->type);
		}

	/* Strip off any plural and try the units table again. */
	if (len != 0 && buff[len - 1] == 's') {
		buff[len - 1] = '\0';
		for (tp = UnitsTable; tp->name; tp++)
			if (strcmp(buff, tp->name) == 0) {
				yylval.Number = tp->value;
				return (tp->type);
			}
		buff[len - 1] = 's';	/* Put back for "this" in OtherTable. */
	}

	for (tp = OtherTable; tp->name; tp++)
		if (strcmp(buff, tp->name) == 0) {
			yylval.Number = tp->value;
			return (tp->type);
		}

	/* Military timezones. */
	if (len == 1 && isalpha(*buff)) {
		for (tp = MilitaryTable; tp->name; tp++)
			if (strcmp(buff, tp->name) == 0) {
				yylval.Number = tp->value;
				return (tp->type);
			}
	}

	/* Drop out any periods and try the timezone table again. */
	for (i = 0, p = q = buff; *q; q++)
		if (*q != '.')
			*p++ = *q;
		else
			i++;
	*p = '\0';
	if (i)
		for (tp = TimezoneTable; tp->name; tp++)
			if (strcmp(buff, tp->name) == 0) {
				yylval.Number = tp->value;
				return (tp->type);
			}

	return (tID);
}


static int
yylex(void)
{
	char	c, *p, buff[20];
	int	count, sign;

	for (;;) {
		while (isspace(*yyInput))
			yyInput++;

		if (isdigit(c = *yyInput) || c == '-' || c == '+') {
			if (c == '-' || c == '+') {
				sign = c == '-' ? -1 : 1;
				if (!isdigit(*++yyInput))
					/* skip the '-' sign */
					continue;
			}
			else
				sign = 0;

			for (yylval.Number = 0; isdigit(c = *yyInput++); )
				yylval.Number = 10 * yylval.Number + c - '0';
			yyInput--;
			if (sign < 0)
				yylval.Number = -yylval.Number;
			return sign ? tSNUMBER : tUNUMBER;
		}

		if (isalpha(c)) {
			for (p = buff; isalpha(c = *yyInput++) || c == '.'; )
				if (p < &buff[sizeof buff - 1])
					*p++ = c;
			*p = '\0';
			yyInput--;
			return lookup(buff);
		}
		if (c != '(')
			return *yyInput++;

		count = 0;
		do {
			c = *yyInput++;
			if (c == '\0')
				return (c);
			if (c == '(')
				count++;
			else if (c == ')')
				count--;
		} while (count > 0);
	}
}

/* Yield A - B, measured in seconds.  */
static long
difftm(struct tm *a, struct tm *b)
{
	int ay = a->tm_year + (YEAR_TMORIGIN - 1);
	int by = b->tm_year + (YEAR_TMORIGIN - 1);
	int days = (
	    /* difference in day of year */
	    a->tm_yday - b->tm_yday
	    /* + intervening leap days */
	    +  ((ay >> 2) - (by >> 2))
	    -  (ay/100 - by/100)
	    +  ((ay/100 >> 2) - (by/100 >> 2))
	    /* + difference in years * 365 */
	    +  (long)(ay-by) * 365);
	return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))
	    + (a->tm_min - b->tm_min)) + (a->tm_sec - b->tm_sec));
}

/*
 * date_parse()
 *
 * Returns the number of seconds since the Epoch corresponding to the date.
 */
time_t
date_parse(const char *p)
{
	struct tm	gmt, tm;
	time_t		Start, tod, nowtime, tz;

	yyInput = p;

	if (time(&nowtime) == -1 || !gmtime_r(&nowtime, &gmt) ||
	    !localtime_r(&nowtime, &tm))
		return -1;

	tz = difftm(&gmt, &tm) / 60;

	if (tm.tm_isdst)
		tz += 60;

	yyYear = tm.tm_year + 1900;
	yyMonth = tm.tm_mon + 1;
	yyDay = tm.tm_mday;
	yyTimezone = tz;
	yyDSTmode = DSTmaybe;
	yyHour = 0;
	yyMinutes = 0;
	yySeconds = 0;
	yyMeridian = MER24;
	yyRelSeconds = 0;
	yyRelMonth = 0;
	yyHaveDate = 0;
	yyHaveDay = 0;
	yyHaveRel = 0;
	yyHaveTime = 0;
	yyHaveZone = 0;

	if (yyparse() || yyHaveTime > 1 || yyHaveZone > 1 ||
	    yyHaveDate > 1 || yyHaveDay > 1)
		return (-1);

	if (yyHaveDate || yyHaveTime || yyHaveDay) {
		Start = Convert(yyMonth, yyDay, yyYear, yyHour, yyMinutes,
		    yySeconds, yyMeridian, yyDSTmode);
		if (Start < 0)
			return (-1);
	} else {
		Start = nowtime;
		if (!yyHaveRel)
			Start -= ((tm.tm_hour * 60L + tm.tm_min) * 60L) +
			    tm.tm_sec;
	}

	Start += yyRelSeconds;
	Start += RelativeMonth(Start, yyRelMonth);

	if (yyHaveDay && !yyHaveDate) {
		tod = RelativeDate(Start, yyDayOrdinal, yyDayNumber);
		Start += tod;
	}

	return Start;
}

#if defined(TEST)
/* ARGSUSED */
int
main(int argc, char **argv)
{
	char	buff[128];
	time_t	d;

	(void)printf("Enter date, or blank line to exit.\n\t> ");
	(void)fflush(stdout);
	while (fgets(buff, sizeof(buff), stdin) && buff[0]) {
		d = date_parse(buff);
		if (d == -1)
			(void)printf("Bad format - couldn't convert.\n");
		else
			(void)printf("%s", ctime(&d));
		(void)printf("\t> ");
		(void)fflush(stdout);
	}

	return (0);
}
#endif	/* defined(TEST) */
@


1.25
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.24 2013/12/03 00:23:45 deraadt Exp $	*/
d19 1
@


1.24
log
@do not need timeb.h
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.23 2013/04/19 17:28:06 deraadt Exp $	*/
d491 1
a491 1
	xfree(str);
@


1.23
log
@Constrain the 2038 check to only when sizeof(time_t) == sizeof(int).
Adding more powerful checking is too difficult.  We'll fix this problem
by moving to 64-bit time_t.. and once we do, we don't want this code to
falsely trigger.
ok millert
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.22 2010/07/31 08:54:42 ray Exp $	*/
a15 2

#include <sys/timeb.h>
@


1.22
log
@Checking for -1 as an overflow value is pretty absurd. Returning
the unix epoch is equally absurd. Just return Start for now. We may
add overflow checks in the future.

OK xsa nicm
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.21 2010/07/29 18:52:45 ray Exp $	*/
d556 4
a559 3
	/* Checking for 2038 bogusly assumes that time_t is 32 bits.  But
	   I'm too lazy to try to check for time_t overflow in another way.  */
	if (Year < YEAR_EPOCH || Year > 2038 || Month < 1 || Month > 12 ||
@


1.21
log
@Replace abort(), fatal(), and errx() with return -1, since date_parse
returns -1 on error.

OK nicm
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.20 2010/07/23 21:46:05 ray Exp $	*/
d865 1
a865 4
	/* Have to do *something* with a legitimate -1 so it's distinguishable
	 * from the error return value.  (Alternately could set errno on error.)
	 */
	return (Start == -1) ? (0) : (Start);
@


1.20
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.19 2010/07/23 09:11:10 ray Exp $	*/
d817 1
a817 1
		fatal("date_parse failed");
@


1.19
log
@Clean up struct tm handling. Instead of calling gmtime/localtime
and making copies (among other weird dances), use reentrant versions.

Not being able to tell the time is a fatal error, so die if that
happens.

Diff originally from nicm.

OK nicm xsa
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.18 2008/02/16 01:00:00 cnst Exp $	*/
d803 1
a803 1
 * cvs_date_parse()
d808 1
a808 1
cvs_date_parse(const char *p)
d817 1
a817 1
		fatal("cvs_date_parse failed");
d882 1
a882 1
		d = cvs_date_parse(buff);
@


1.18
log
@* yyInput doesn't seem to contain anything meaningful at the time when
  yyerror() is called, so there's no point in printing it
* unbreak `env CFLAGS='-DTEST' make date`

ok joris@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.17 2007/10/06 12:55:48 chl Exp $	*/
d810 2
a811 3
	struct tm	gmt, *gmt_ptr, *tm;
	struct timeb	ftz, *now;
	time_t		Start, tod, nowtime;
d815 13
a827 27
	now = &ftz;
	(void)time(&nowtime);

	gmt_ptr = gmtime(&nowtime);
	if (gmt_ptr != NULL) {
		/* Make a copy, in case localtime modifies *tm (I think
		 * that comment now applies to *gmt_ptr, but I am too
		 * lazy to dig into how gmtime and locatime allocate the
		 * structures they return pointers to).
		 */
		gmt = *gmt_ptr;
	}

	if (!(tm = localtime(&nowtime)))
		return (-1);

	if (gmt_ptr != NULL)
		ftz.timezone = difftm(&gmt, tm) / 60;

	if (tm->tm_isdst)
		ftz.timezone += 60;

	tm = localtime(&nowtime);
	yyYear = tm->tm_year + 1900;
	yyMonth = tm->tm_mon + 1;
	yyDay = tm->tm_mday;
	yyTimezone = now->timezone;
d853 2
a854 2
			Start -= ((tm->tm_hour * 60L + tm->tm_min) * 60L) +
			    tm->tm_sec;
@


1.17
log
@replace abort() by return (-1)

from ray@@ suggestion
"looks good" ray@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.16 2007/02/22 06:42:09 otto Exp $	*/
d488 1
d491 1
a491 7
	if (isspace(yyInput[0]) || !isprint(yyInput[0]))
		(void)xasprintf(&str,
		    "%s: unexpected char 0x%02x in date string", s, yyInput[0]);
	else
		(void)xasprintf(&str, "%s: unexpected %s in date string",
		    s, yyInput);

d494 1
@


1.16
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.15 2007/01/20 06:57:54 ray Exp $	*/
d527 1
a527 1
		abort();
@


1.15
log
@Prevent negative array index accesses when strlen(buff) == 0.

OK joris@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.14 2006/11/09 15:55:55 xsa Exp $	*/
d17 4
a20 1
#include "includes.h"
a21 1
#include "log.h"
@


1.14
log
@sync with usr.bin/rcs version.
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.13 2006/05/03 14:26:13 ray Exp $	*/
d632 1
d651 1
d653 1
a653 1
	if (strlen(buff) == 3)
d655 1
a655 1
	else if (strlen(buff) == 4 && buff[3] == '.') {
d658 1
d690 2
a691 3
	i = strlen(buff) - 1;
	if (buff[i] == 's') {
		buff[i] = '\0';
d697 1
a697 1
		buff[i] = 's';	/* Put back for "this" in OtherTable. */
d707 1
a707 1
	if (buff[1] == '\0' && isalpha(*buff)) {
@


1.13
log
@Use xasprintf and xfree.

``But i thought it already went in...'' xsa@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.12 2006/04/29 04:42:46 ray Exp $	*/
d74 4
a77 4
static int   yyerror   (const char *);
static int   yylex     (void);
static int   yyparse   (void);
static int   lookup    (char *);
d489 2
a490 2
		(void)xasprintf(&str, "%s: unexpected char 0x%02x in date string",
		    s, yyInput[0]);
a494 3
#if defined(TEST)
	printf("%s", str);
#else
a495 1
#endif
@


1.12
log
@Remove dead code.

OK niallo@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.11 2006/01/02 08:11:56 xsa Exp $	*/
a486 1
	int n;
d489 1
a489 1
		n = asprintf(&str, "%s: unexpected char 0x%02x in date string",
d492 1
a492 1
		n = asprintf(&str, "%s: unexpected %s in date string",
a493 2
	if (n == -1)
		return (0);
d500 1
a500 1
	free(str);
@


1.11
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.10 2005/10/07 21:47:32 reyk Exp $	*/
d817 1
a817 1
	struct tm	*tm, gmt;
a820 2
	now = NULL;

a821 2
	if (now == NULL) {
		struct tm *gmt_ptr;
d823 2
a824 2
		now = &ftz;
		(void)time(&nowtime);
d826 9
a834 9
		gmt_ptr = gmtime(&nowtime);
		if (gmt_ptr != NULL) {
			/* Make a copy, in case localtime modifies *tm (I think
			 * that comment now applies to *gmt_ptr, but I am too
			 * lazy to dig into how gmtime and locatime allocate the
			 * structures they return pointers to).
			 */
			gmt = *gmt_ptr;
		}
d836 2
a837 2
		if (!(tm = localtime(&nowtime)))
			return (-1);
d839 2
a840 2
		if (gmt_ptr != NULL)
			ftz.timezone = difftm(&gmt, tm) / 60;
d842 2
a843 6
		if (tm->tm_isdst)
			ftz.timezone += 60;
	}
	else {
		nowtime = now->time;
	}
@


1.10
log
@knf and spacing, ok joris@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.9 2005/09/25 19:11:34 otto Exp $	*/
d17 1
a17 9
#include <sys/types.h>
#include <sys/timeb.h>

#include <ctype.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
@


1.9
log
@Produce more clear error message parsing date strings. ok joris@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.8 2005/05/20 17:15:49 jfb Exp $	*/
d540 1
a540 1
		abort ();
d805 8
a812 9
			  /* difference in day of year */
			  a->tm_yday - b->tm_yday
			  /* + intervening leap days */
			  +  ((ay >> 2) - (by >> 2))
			  -  (ay/100 - by/100)
			  +  ((ay/100 >> 2) - (by/100 >> 2))
			  /* + difference in years * 365 */
			  +  (long)(ay-by) * 365
			  );
d854 1
a854 1
		if(tm->tm_isdst)
d891 2
a892 1
			Start -= ((tm->tm_hour * 60L + tm->tm_min) * 60L) + tm->tm_sec;
@


1.8
log
@* missing prototype for lookup()
* remove crufty VMS-specific code
* sprinkle some magic knf dust
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.7 2005/05/19 04:17:24 jfb Exp $	*/
d82 1
a82 1
static int   yyerror   (const char *, ...);
a490 1
/* ARGSUSED */
d492 1
a492 1
yyerror(const char *fmt, ...)
d494 11
a504 1
	va_list vap;
a505 1
	va_start(vap, fmt);
d507 1
a507 1
	vprintf(fmt, vap);
d509 1
a509 1
	cvs_vlog(LP_ERR, fmt, vap);
d511 1
a511 2
	va_end(vap);

@


1.7
log
@use the date parsing code from date.y and fix timestamps on newly
created files so they match the values found in the corresponding
entries, otherwise all files appear as modified

ok joris
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.6 2005/04/18 21:55:13 joris Exp $	*/
d85 1
d638 1
a638 1
LookupWord(char *buff)
d773 1
a773 1
			return LookupWord(buff);
d811 5
d830 1
a830 1
		(void)time (&nowtime);
d832 1
a832 1
		gmt_ptr = gmtime (&nowtime);
d842 1
a842 1
		if (!(tm = localtime (&nowtime)))
d846 1
a846 8
			ftz.timezone = difftm (&gmt, tm) / 60;
		else
			/* We are on a system like VMS, where the system clock is
			   in local time and the system has no concept of timezones.
			   Hopefully we can fake this out (for the case in which the
			   user specifies no timezone) by just saying the timezone
			   is zero.  */
			ftz.timezone = 0;
d913 1
a913 1
		d = get_date(buff, (struct timeb *)NULL);
@


1.6
log
@

missing prototype for get_date();

from deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.5 2005/03/30 16:41:07 joris Exp $	*/
d28 1
d61 1
a61 1
static char	*yyInput;
a85 2
time_t		get_date(char *, struct timeb *);

d811 1
a811 1
get_date(char *p, struct timeb *now)
d814 1
a814 1
	struct timeb	ftz;
d816 2
@


1.5
log
@

allow this to be compiled on its own for testing.

ok jfb@@
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.4 2005/03/28 22:40:58 jfb Exp $	*/
d85 1
@


1.4
log
@alignment
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.3 2005/03/24 15:40:43 jfb Exp $	*/
d497 3
d501 1
@


1.3
log
@more cleanup and knf
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.2 2005/03/24 03:07:04 jfb Exp $	*/
d43 1
a43 3
/*
**  Daylight-savings mode:  on, off, or not yet known.
*/
d48 1
a48 3
/*
**  Meridian:  am, pm, or 24-hour style.
*/
d55 5
a59 5
**  Global variables.  We could get rid of most of these by using a good
**  union as the yacc stack.  (This routine was originally written before
**  yacc had the %union construct.)  Maybe someday; right now we only use
**  the %union very rarely.
*/
d378 1
a378 1
	{ "ut",	tZONE,     HOUR( 0) },	/* Universal (Coordinated) */
d383 1
a383 1
	{ "at",	tZONE,     HOUR( 2) },	/* Azores */
d411 1
a411 1
	{ "nt",	tZONE,     HOUR(11) },	/* Nome */
d422 1
a422 1
	{ "bt",	tZONE,     -HOUR(3) },	/* Baghdad, USSR Zone 2 */
d424 1
a424 1
	{ "it",	tZONE,     -HOUR(3.5) },/* Iran */
d441 1
a441 1
	{ "jt",	tZONE,     -HOUR(7.5) },/* Java (3pm in Cronusland!) */
@


1.2
log
@add missing prototypes for standard yacc functions and make yyerror()
accept a format with variable arguments
@
text
@d2 1
a2 1
/*	$OpenBSD: date.y,v 1.1 2005/03/23 20:00:18 jfb Exp $	*/
d29 2
a30 1
#define EPOCH		1970
d111 1
a111 1
			yyHaveTime++;
d114 1
a114 1
			yyHaveZone++;
d117 1
a117 1
			yyHaveDate++;
d120 1
a120 1
			yyHaveDay++;
d123 1
a123 1
			yyHaveRel++;
d129 4
a132 4
			yyHour = $1;
			yyMinutes = 0;
			yySeconds = 0;
			yyMeridian = $2;
d135 4
a138 4
			yyHour = $1;
			yyMinutes = $3;
			yySeconds = 0;
			yyMeridian = $4;
d141 5
a145 5
			yyHour = $1;
			yyMinutes = $3;
			yyMeridian = MER24;
			yyDSTmode = DSToff;
			yyTimezone = - ($4 % 100 + ($4 / 100) * 60);
d148 4
a151 4
			yyHour = $1;
			yyMinutes = $3;
			yySeconds = $5;
			yyMeridian = $6;
d154 6
a159 6
			yyHour = $1;
			yyMinutes = $3;
			yySeconds = $5;
			yyMeridian = MER24;
			yyDSTmode = DSToff;
			yyTimezone = - ($6 % 100 + ($6 / 100) * 60);
d164 2
a165 2
			yyTimezone = $1;
			yyDSTmode = DSToff;
d168 2
a169 2
			yyTimezone = $1;
			yyDSTmode = DSTon;
d171 3
a173 4
	|
	  tZONE tDST {
			yyTimezone = $1;
			yyDSTmode = DSTon;
d178 2
a179 2
			yyDayOrdinal = 1;
			yyDayNumber = $1;
d182 2
a183 2
			yyDayOrdinal = 1;
			yyDayNumber = $1;
d186 2
a187 2
			yyDayOrdinal = $1;
			yyDayNumber = $2;
d192 9
d203 2
d206 2
a207 2
	| tUNUMBER '/' tUNUMBER '/' tUNUMBER {
			if ($1 >= 100) {
d209 2
a210 13
		yyMonth = $3;
		yyDay = $5;
			} else {
		yyMonth = $1;
		yyDay = $3;
		yyYear = $5;
			}
	}
	| tUNUMBER tSNUMBER tSNUMBER {
			/* ISO 8601 format.  yyyy-mm-dd.  */
			yyYear = $1;
			yyMonth = -$2;
			yyDay = -$3;
d213 4
a216 4
			/* e.g. 17-JUN-1992.  */
			yyDay = $1;
			yyMonth = $2;
			yyYear = -$3;
d219 2
a220 2
			yyMonth = $1;
			yyDay = $2;
d223 3
a225 3
			yyMonth = $1;
			yyDay = $2;
			yyYear = $4;
d228 2
a229 2
			yyMonth = $2;
			yyDay = $1;
d232 3
a234 3
			yyMonth = $2;
			yyDay = $1;
			yyYear = $3;
d239 2
a240 2
			yyRelSeconds = -yyRelSeconds;
			yyRelMonth = -yyRelMonth;
d246 1
a246 1
			yyRelSeconds += $1 * $2 * 60L;
d249 1
a249 1
			yyRelSeconds += $1 * $2 * 60L;
d252 1
a252 1
			yyRelSeconds += $1 * 60L;
d255 1
a255 1
			yyRelSeconds += $1;
d258 1
a258 1
			yyRelSeconds += $1;
d261 1
a261 1
			yyRelSeconds++;
d264 1
a264 1
			yyRelMonth += $1 * $2;
d267 1
a267 1
			yyRelMonth += $1 * $2;
d270 1
a270 1
			yyRelMonth += $1;
d275 4
a278 4
			if (yyHaveTime && yyHaveDate && !yyHaveRel)
		yyYear = $1;
			else {
		if($1>10000) {
d283 1
a283 2
		}
		else {
d286 3
a288 4
			yyHour = $1;
			yyMinutes = 0;
				}
				else {
a293 1
			    }
d295 1
d560 1
a560 1
		if (Year < EPOCH)
d567 1
a567 1
	if (Year < EPOCH || Year > 2038 || Month < 1 || Month > 12 ||
d575 1
a575 1
	for (i = EPOCH; i < Year; i++)
a789 2
#define TM_YEAR_ORIGIN 1900

d792 1
a792 1
difftm (struct tm *a, struct tm *b)
d794 2
a795 2
	int ay = a->tm_year + (TM_YEAR_ORIGIN - 1);
	int by = b->tm_year + (TM_YEAR_ORIGIN - 1);
@


1.1
log
@public domain yacc date parser with a first round of knf
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d22 1
d83 6
d498 1
a498 1
yyerror(char *s)
d500 6
a505 1
	cvs_log(LP_ERR, "%s", s);
d819 1
a819 3
	time_t		Start;
	time_t		tod;
	time_t nowtime;
@

