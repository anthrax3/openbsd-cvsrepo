head	1.47;
access;
symbols
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.47.0.8
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.46.0.18
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.10
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.14
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.12
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.8
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.6
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.4
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.2
	OPENBSD_5_0:1.45.0.14
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.12
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.10
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.6
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.8
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.4
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OpenCVS_0_1:1.1.1.1
	OpenCVS:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2015.11.05.09.48.21;	author nicm;	state Exp;
branches;
next	1.46;
commitid	O6jeJ0TRmiewrqMI;

1.46
date	2011.12.27.13.59.01;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.12.16.53.12;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.11.01.55.05;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2008.04.24.19.13.56;	author tobias;	state Exp;
branches;
next	1.42;

1.42
date	2008.01.10.10.05.40;	author tobias;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.07.23.59.01;	author tobias;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.26.02.24.10;	author niallo;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.10.20.58.02;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.22.06.42.09;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2007.01.31.21.07.35;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.07.17.37.17;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.27.03.30.30;	author joris;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.20.12.13.19;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.14.02.45.35;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.13.16.55.09;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.15.21.34.59;	author niallo;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.02.17.06.10;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.02.08.11.56;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.10.20.27.45;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.09.23.59.17;	author joris;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.19.15.45.16;	author niallo;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.05.16.21.41;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.27.15.45.44;	author xsa;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.27.13.06.04;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.25.12.13.08;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.07.14.27.57;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.07.09.06.15;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.05.20.47.44;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.02.20.16.48;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.02.16.05.38;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.31.08.58.48;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.06.21.42.32;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.06.18.39.35;	author jfb;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.28.22.46.09;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.26.08.09.54;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.22.16.22.10;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.16.15.33.37;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.15.15.29.35;	author jfb;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.15.06.11.40;	author jfb;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.07.17.10.56;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.06.21.03.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.28.15.12.17;	author pat;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.05.13.39.01;	author jfb;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.05.13.32.08;	author jfb;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.27.16.19.41;	author jfb;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.07.13.22.02.40;	author jfb;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Remove xfree(), like already done for RCS. From Michael W Bombardieri,
ok mmcc
@
text
@/*	$OpenBSD: log.c,v 1.46 2011/12/27 13:59:01 nicm Exp $	*/
/*
 * Copyright (c) 2006 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "cvs.h"

extern char *__progname;

/*
 * cvs_log()
 *
 * Log the format-string message
 * The <fmt> argument should not have a terminating newline, as this is taken
 * care of by the logging facility.
 */
void
cvs_log(u_int level, const char *fmt, ...)
{
	va_list vap;

	va_start(vap, fmt);
	cvs_vlog(level, fmt, vap);
	va_end(vap);
}

/*
 * cvs_vlog()
 *
 * The <fmt> argument should not have a terminating newline, as this is taken
 * care of by the logging facility.
 */
void
cvs_vlog(u_int level, const char *fmt, va_list vap)
{
	int ecp;
	FILE *out;
	char *cmdname;

	if (cvs_trace != 1 && level == LP_TRACE)
		return;

	if (level == LP_ERRNO)
		ecp = errno;
	else
		ecp = 0;

	if (level == LP_NOTICE)
		out = stdout;
	else
		out = stderr;

	if (cvs_server_active) {
		if (out == stdout)
			putc('M', out);
		else {
			out = stdout;
			putc('E', out);
		}

		putc(' ', out);
	}

	cmdname = (cmdp != NULL) ? cmdp->cmd_name : __progname;

	/* The cvs program appends the command name to the program name */
	if (level == LP_TRACE) {
		if (cvs_server_active)
			putc('S', out);
		else
			putc('C', out);
		(void)fputs("-> ", out);
	} else if (level != LP_RCS) {
		(void)fputs(__progname, out);
		putc(' ', out);
		if (level == LP_ABORT)
			(void)fprintf(out,
			    "[%s aborted]", cmdname);
		else
			(void)fputs(cmdname, out);
		(void)fputs(": ", out);
	}

	(void)vfprintf(out, fmt, vap);
	if (level == LP_ERRNO) {
		(void)fprintf(out, ": %s\n", strerror(ecp));

		/* preserve it just in case we changed it? */
		errno = ecp;
	} else
		fputc('\n', out);
}

/*
 * cvs_printf()
 *
 * Wrapper function around printf() that prepends a 'M' command when
 * the program is acting as server.
 */
int
cvs_printf(const char *fmt, ...)
{
	static int send_m = 1;
	int ret;
	char *nstr, *dp, *sp;
	va_list vap;

	va_start(vap, fmt);

	ret = vasprintf(&nstr, fmt, vap);
	if (ret == -1)
		fatal("cvs_printf: could not allocate memory");

	for (dp = nstr; *dp != '\0';) {
		sp = strchr(dp, '\n');
		if (sp == NULL)
			for (sp = dp; *sp != '\0'; sp++)
				;

		if (cvs_server_active && send_m) {
			send_m = 0;
			putc('M', stdout);
			putc(' ', stdout);
		}

		if (dp != nstr && dp != sp &&
		    !strncmp(dp, LOG_REVSEP, sp - dp))
			putc('>', stdout);

		fwrite(dp, sizeof(char), (size_t)(sp - dp), stdout);

		if (*sp != '\n')
			break;

		putc('\n', stdout);
		send_m = 1;
		dp = sp + 1;
	}

	free(nstr);
	va_end(vap);

	return (ret);
}
@


1.46
log
@Move some global variables/statics to locals, from Michael W
Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.45 2008/06/12 16:53:12 joris Exp $	*/
d29 1
d166 1
a166 1
	xfree(nstr);
@


1.45
log
@cmdp can be NULL while still in cvs_getopt(), so deal with this
inside of cvs_vlog() since cvs_getopt() might be calling it.

spotted by Jonathan Armani
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.44 2008/06/11 01:55:05 joris Exp $	*/
a33 1
static int send_m = 1;
d128 1
@


1.44
log
@style ferry comes around
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.43 2008/04/24 19:13:56 tobias Exp $	*/
d64 1
d90 2
d104 1
a104 1
			    "[%s aborted]", cmdp->cmd_name);
d106 1
a106 1
			(void)fputs(cmdp->cmd_name, out);
@


1.43
log
@Use a fixed string in case of vasprintf() error instead of relying on
strerror().  Although our vasprintf() sets errno, we cannot rely on it on
other systems.

ok ray (who spotted this issue), xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.42 2008/01/10 10:05:40 tobias Exp $	*/
d132 14
a145 27
		ret = vasprintf(&nstr, fmt, vap);
		if (ret == -1)
			fatal("cvs_printf: could not allocate memory");
		for (dp = nstr; *dp != '\0';) {
			sp = strchr(dp, '\n');
			if (sp == NULL)
				for (sp = dp; *sp != '\0'; sp++)
					;

			if (cvs_server_active && send_m) {
				send_m = 0;
				putc('M', stdout);
				putc(' ', stdout);
			}

			if (dp != nstr && dp != sp &&
			    !strncmp(dp, LOG_REVSEP, sp - dp))
				putc('>', stdout);

			fwrite(dp, sizeof(char), (size_t)(sp - dp), stdout);

			if (*sp != '\n')
				break;

			putc('\n', stdout);
			send_m = 1;
			dp = sp + 1;
a146 1
		xfree(nstr);
d148 15
d164 1
@


1.42
log
@Simply the use of cmdp and cvs_command by zapping cvs_command and working
solely with cmdp.  This remedies some reliability issues with invalid
commands supplied and also fixes a GNU cvs style incompatibility with
release command.

> Based on patch from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.41 2007/09/07 23:59:01 tobias Exp $	*/
d134 1
a134 1
			fatal("cvs_printf: %s", strerror(errno));
@


1.41
log
@Properly send out rcs info header with "E " in server mode (stderr in
local mode). Format style change also enables opencvs to be used with
cvsweb (+ adjustment).

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.40 2007/06/26 02:24:10 niallo Exp $	*/
a63 1
	struct cvs_cmd *cmdp;
d98 6
a103 13
		if (cvs_command != NULL) {
			/*
			 * always use the command name in error messages,
			 * not aliases
			 */
			cmdp = cvs_findcmd(cvs_command);
			putc(' ', out);
			if (level == LP_ABORT)
				(void)fprintf(out,
				    "[%s aborted]", cmdp->cmd_name);
			else
				(void)fputs(cmdp->cmd_name, out);
		}
@


1.40
log
@add support for cvs rlog.
from Mickey.

ok joris@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.39 2007/05/10 20:58:02 xsa Exp $	*/
d97 1
a97 1
	} else {
@


1.39
log
@Simplify cvs_vlog() to avoid endless fatal() loop on some error case.
Problem spotted and fix submitted by Tobias Stoeckmann.
OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.38 2007/02/22 06:42:09 otto Exp $	*/
a139 1
	if (cvs_server_active) {
d149 1
a149 1
			if (send_m) {
d155 4
a168 2
	} else
		ret = vprintf(fmt, vap);
@


1.38
log
@general includes cleanup sweep. ok joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.37 2007/01/31 21:07:35 xsa Exp $	*/
a62 1
	char prefix[64], buf[1024], ebuf[255];
a63 1
	char *cmdname;
a73 31
	/* always use the command name in error messages, not aliases */
	if (cvs_command == NULL)
		cmdname = " ";
	else {
		cmdp = cvs_findcmd(cvs_command);
		cmdname = cmdp->cmd_name;
	}

	/* The cvs program appends the command name to the program name */
	if (level == LP_TRACE) {
		strlcpy(prefix, " -> ", sizeof(prefix));
		if (cvs_server_active)
			prefix[0] = 'S';
		else
			prefix[0] = 'C';
	} else if (cvs_command != NULL) {
		if (level == LP_ABORT)
			(void)xsnprintf(prefix, sizeof(prefix),
			    "%s [%s aborted]", __progname, cmdname);
		else
			(void)xsnprintf(prefix, sizeof(prefix), "%s %s",
			    __progname, cmdname);
	} else /* just use the standard strlcpy */
		strlcpy(prefix, __progname, sizeof(prefix));

	vsnprintf(buf, sizeof(buf), fmt, vap);
	if (level == LP_ERRNO) {
		(void)xsnprintf(ebuf, sizeof(ebuf), ": %s", strerror(errno));
		strlcat(buf, ebuf, sizeof(buf));
	}

d90 28
a117 5
	fputs(prefix, out);
	if (level != LP_TRACE)
		fputs(": ", out);
	fputs(buf, out);
	fputc('\n', out);
d119 1
a119 2
	/* preserve it just in case we changed it? */
	if (level == LP_ERRNO)
d121 2
@


1.37
log
@snprintf() -> xsnprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.36 2006/07/07 17:37:17 joris Exp $	*/
d28 2
a29 1
#include "includes.h"
a31 1
#include "log.h"
@


1.36
log
@first part of opencvs remote, fairly useable on existing trees
although i advise against using it on real development trees for now.

only a few commands work right so far:
- commit
- diff
- status
- log
- update (partially working)

if you feel like testing remote and run into bugs feel free to
contact me, and please include a full trace (-t).
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.35 2006/05/27 03:30:30 joris Exp $	*/
d93 4
a96 1
			snprintf(prefix, sizeof(prefix), "%s [%s aborted]",
a97 3
		else
			snprintf(prefix, sizeof(prefix), "%s %s", __progname,
			    cmdname);
d103 1
a103 1
		snprintf(ebuf, sizeof(ebuf), ": %s", strerror(errno));
@


1.35
log
@commit the new opencvs code, i have been hacking on
this for the past 2 weeks now and it should go in at
the start of the hackathon so others can help out.

this code is a lot safer, smarter, faster and best of
all it is actually doing what it is suppose to do!

basic checkout, update, status, diff and commit are
working in local mode only.
there is no support for any remote setups now.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.33 2006/04/14 02:45:35 deraadt Exp $	*/
a33 1

d87 1
a87 1
		if (cvs_cmdop == CVS_OP_SERVER)
d89 2
d112 1
a112 1
	if (cvs_cmdop == CVS_OP_SERVER) {
d149 1
a149 1
	if (cvs_cmdop == CVS_OP_SERVER) {
@


1.34
log
@change cvs_log() and cvs_vlog() return type to void; OK niallo@@.
@
text
@d3 1
a34 28

#ifdef unused
static char *cvs_log_levels[LP_MAX + 1] = {
	"debug",
	"info",
	"notice",
	"warning",
	"error",
	"alert",
	"error",
	"abort",
	"trace",
};
#endif

static int cvs_slpriomap[LP_MAX + 1] = {
	LOG_DEBUG,
	LOG_INFO,
	LOG_NOTICE,
	LOG_WARNING,
	LOG_ERR,
	LOG_ALERT,
	LOG_ERR,
	LOG_ERR,
	LOG_DEBUG,
};

#if !defined(RCSPROG)
a35 103
#endif
static u_int cvs_log_dest = LD_STD;
static u_int cvs_log_flags = 0;

static struct syslog_data cvs_sl = SYSLOG_DATA_INIT;

/* filter manipulation macros */
#define CVS_LOG_FLTRRST()	(cvs_log_filters = 0)
#define CVS_LOG_FLTRSET(l)	(cvs_log_filters |= (1 << l))
#define CVS_LOG_FLTRGET(l)	(cvs_log_filters & (1 << l))
#define CVS_LOG_FLTRCLR(l)	(cvs_log_filters &= ~(1 << l))

static u_int cvs_log_filters;


/*
 * cvs_log_init()
 *
 * Initialize the logging facility of the server.
 */
void
cvs_log_init(u_int dest, u_int flags)
{
	int slopt;

	cvs_log_dest = dest;
	cvs_log_flags = flags;

	/* by default, filter only LP_DEBUG and LP_INFO levels */
	CVS_LOG_FLTRRST();
	CVS_LOG_FLTRSET(LP_DEBUG);
	CVS_LOG_FLTRSET(LP_INFO);

	/* traces are enabled with the -t command-line option */
	CVS_LOG_FLTRSET(LP_TRACE);

	if (dest & LD_SYSLOG) {
		slopt = 0;

		if (dest & LD_CONS)
			slopt |= LOG_CONS;
		if (flags & LF_PID)
			slopt |= LOG_PID;

		openlog_r(__progname, slopt, LOG_DAEMON, &cvs_sl);
	}
}


/*
 * cvs_log_cleanup()
 *
 * Cleanup the logging facility.
 */
void
cvs_log_cleanup(void)
{

	closelog_r(&cvs_sl);
}


/*
 * cvs_log_filter()
 *
 * Apply or remove filters on the logging facility.  The exact operation is
 * specified by the <how> and <level> arguments.  The <how> arguments tells
 * how the filters will be affected, and <level> gives the log levels that
 * will be affected by the change.
 * Returns 0 on success, or -1 on failure.
 */

int
cvs_log_filter(u_int how, u_int level)
{
	u_int i;

	if (level > LP_MAX && level != LP_ALL) {
		cvs_log(LP_ERR, "invalid log level for filter");
		return (-1);
	}

	switch (how) {
	case LP_FILTER_SET:
		if (level == LP_ALL)
			for (i = 0; i <= LP_MAX; i++)
				CVS_LOG_FLTRSET(i);
		else
			CVS_LOG_FLTRSET(level);
		break;
	case LP_FILTER_UNSET:
		if (level == LP_ALL)
			CVS_LOG_FLTRRST();
		else
			CVS_LOG_FLTRCLR(level);
		break;
	default:
		return (-1);
	}

	return (0);
}

a53 1

a65 1
#if !defined(RCSPROG)
a67 4
#endif

	if (level > LP_MAX)
		fatal("cvs_vlog failed");
d69 1
a69 2
	/* apply any filters */
	if (CVS_LOG_FLTRGET(level))
a77 1
#if !defined(RCSPROG)
a97 1
#endif
a99 5
	if ((cvs_log_flags & LF_PID) && level != LP_TRACE) {
		snprintf(buf, sizeof(buf), "[%d]", (int)getpid());
		strlcat(prefix, buf, sizeof(prefix));
	}

d106 9
a114 2
	if (cvs_log_dest & LD_STD) {
		if (level < LP_NOTICE)
d116 1
a116 12
		else
			out = stderr;

#if !defined(RCSPROG)
		if (cvs_cmdop == CVS_OP_SERVER) {
			if (out == stdout)
				putc('M', out);
			else {
				out = stdout;
				putc('E', out);
			}
			putc(' ', out);
a117 1
#endif
d119 1
a119 5
		fputs(prefix, out);
		if (level != LP_TRACE)
			fputs(": ", out);
		fputs(buf, out);
		fputc('\n', out);
d122 5
a126 2
	if (cvs_log_dest & LD_SYSLOG)
		syslog_r(cvs_slpriomap[level], &cvs_sl, "%s", buf);
a132 1

a142 1
#if !defined(RCSPROG)
a143 1
#endif
a147 1
#if !defined(RCSPROG)
a174 1
#endif
@


1.33
log
@remove a metric buttload of excessive ()
no binary change; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.32 2006/04/13 16:55:09 ray Exp $	*/
d174 1
a174 1
int
a176 1
	int ret;
d180 1
a180 1
	ret = cvs_vlog(level, fmt, vap);
a181 2

	return (ret);
d191 1
a191 1
int
d203 1
a203 1
		return (-1);
d207 1
a207 1
		return (0);
a280 2

	return (0);
@


1.32
log
@Add error checking for vasprintf.  Stylistic suggestions from xsa@@.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.31 2006/03/15 21:34:59 niallo Exp $	*/
d140 1
a140 1
	if ((level > LP_MAX) && (level != LP_ALL)) {
d242 1
a242 1
	if ((cvs_log_flags & LF_PID) && (level != LP_TRACE)) {
@


1.31
log
@- remove unused function cvs_putchar()

"well then zap it" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.30 2006/01/02 17:06:10 xsa Exp $	*/
d309 12
a320 22
		if (ret != -1) {
			for (dp = nstr; *dp != '\0';) {
				sp = strchr(dp, '\n');
				if (sp == NULL)
					for (sp = dp; *sp != '\0'; sp++)
						;

				if (send_m) {
					send_m = 0;
					putc('M', stdout);
					putc(' ', stdout);
				}

				fwrite(dp, sizeof(char), (size_t)(sp - dp),
				    stdout);

				if (*sp != '\n')
					break;

				putc('\n', stdout);
				send_m = 1;
				dp = sp + 1;
d322 9
a330 1
			xfree(nstr);
d332 1
@


1.30
log
@- nuke remaining err(), errx() and warnx() instances.
- make cvs_log_init() return type void.
ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.29 2006/01/02 08:11:56 xsa Exp $	*/
a339 18
}
void
cvs_putchar(int c)
{
#if !defined(RCSPROG)
	if (cvs_cmdop == CVS_OP_SERVER && send_m) {
		send_m = 0;
		putc('M', stdout);
		putc(' ', stdout);
	}
#endif

	putc(c, stdout);

#if !defined(RCSPROG)
	if (cvs_cmdop == CVS_OP_SERVER && c == '\n')
		send_m = 1;
#endif
@


1.29
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.28 2005/12/10 20:27:45 joris Exp $	*/
a81 1
 * Returns 0 on success, or -1 on failure.
d83 1
a83 1
int
a108 2

	return (0);
@


1.28
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.27 2005/10/09 23:59:17 joris Exp $	*/
d27 1
a27 8
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
@


1.27
log
@fix cvs_log() so it doesn't segfault when called before
cvs_command is set.

problem found by & discussed with Nuno Morgadinho thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.26 2005/09/19 15:45:16 niallo Exp $	*/
d342 1
a342 1
			free(nstr);
@


1.26
log
@Add preprocessor directives needed for usr.bin/rcs programs to compile.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.25 2005/08/05 16:21:41 xsa Exp $	*/
d211 1
d229 6
a234 1
	cmdp = cvs_findcmd(cvs_command);
d244 1
a244 1
			    __progname, cmdp->cmd_name);
d247 1
a247 1
			    cmdp->cmd_name);
@


1.25
log
@increase ebuf[] size in cvs_vlog() wrt strerror(3) return value;
ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.24 2005/07/27 15:45:44 xsa Exp $	*/
d68 1
d70 1
d210 1
d212 1
d227 1
d243 1
d263 1
d273 1
d303 1
d305 1
d310 1
d339 1
d348 1
d354 1
d358 1
d361 1
@


1.24
log
@rather make LP_NOTICE send to stderr not LP_INFO, pointed out by jfb@@.
ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.23 2005/07/27 13:06:04 xsa Exp $	*/
d206 1
a206 1
	char prefix[64], buf[1024], ebuf[32];
@


1.23
log
@make LP_INFO send to stderr; ok joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.22 2005/07/25 12:13:08 xsa Exp $	*/
d58 1
a59 1
	LOG_INFO,
d252 1
a252 1
		if (level <= LP_NOTICE)
@


1.22
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.21 2005/07/07 14:27:57 joris Exp $	*/
d58 1
a59 1
	LOG_NOTICE,
@


1.21
log
@

remove trailing whitespaces

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.20 2005/06/07 09:06:15 joris Exp $	*/
d75 4
a78 4
#define CVS_LOG_FLTRRST()    (cvs_log_filters = 0)
#define CVS_LOG_FLTRSET(l)   (cvs_log_filters |= (1 << l))
#define CVS_LOG_FLTRGET(l)   (cvs_log_filters & (1 << l))
#define CVS_LOG_FLTRCLR(l)   (cvs_log_filters &= ~(1 << l))
@


1.20
log
@

remove ancient and unused CVS define. it was a leftover from
the daemon.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.19 2005/06/05 20:47:44 joris Exp $	*/
d309 1
a309 1
				if (send_m) { 
@


1.19
log
@

* introduce cvs_putchar(), to output a single character to stdout.
  if we are in server mode send 'M' when needed.

* switch diff command to cvs_printf() and cvs_putchar() so it will
  output correctly in local and server mode.

ok xsa@@, jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.18 2005/06/02 20:16:48 joris Exp $	*/
d208 1
a221 3
#ifdef CVS
	struct cvs_cmd *cmdp;

a237 1
#endif
a256 1
#ifdef CVS
a265 1
#endif
a284 1
#ifdef CVS
a332 1

a346 2

#endif
@


1.18
log
@

make cvs_printf() a bit smarter, so it can be called without having
to worry about the 'M' in server mode.

OK jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.17 2005/06/02 16:05:38 xsa Exp $	*/
d68 1
a302 1
	static int send_m = 1;
d339 16
@


1.17
log
@- set LP_ABORT log level when action is abored by user instead of LP_ERR
- missing \n in output of an unchanged log message warning
- always use the command name in error messages instead of aliases

ok jfb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.16 2005/05/31 08:58:48 xsa Exp $	*/
d302 1
d315 6
a320 2
				putc('M', stdout);
				putc(' ', stdout);
d328 1
@


1.16
log
@headers ordering (alphabetically) and cleanup, from mbalmer@@ and myself;
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.15 2005/04/06 21:42:32 jfb Exp $	*/
d221 5
d234 1
a234 1
			    __progname, cvs_command);
d237 1
a237 1
			    cvs_command);
@


1.15
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.14 2005/04/06 18:39:35 jfb Exp $	*/
d31 1
d33 1
a33 1
#include <stdlib.h>
a34 2
#include <stdarg.h>
#include <syslog.h>
d36 1
a37 1
#include "cvs.h"
@


1.14
log
@make cvs_printf() work as advertised when running as server
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.13 2005/03/28 22:46:09 jfb Exp $	*/
d285 1
d329 1
@


1.13
log
@make LP_TRACE messages go through again, and assign them a level of
LOG_DEBUG for the syslog facility

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.12 2005/03/26 08:09:54 tedu Exp $	*/
d288 1
a288 1
 * Wrapper function around printf() that prepends a 'M' or 'E' command when
d295 1
d299 26
a324 1
	ret = vprintf(fmt, vap);
a325 1

@


1.12
log
@fix a variety of things i found at coverity.  ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.11 2005/02/22 16:22:10 jfb Exp $	*/
d44 1
a44 1
static char *cvs_log_levels[] = {
d53 1
d57 1
a57 1
static int cvs_slpriomap[] = {
d66 1
d209 1
a209 1
	if (level >= LP_MAX)
@


1.11
log
@when a log message is generated by the server and is sent to
standard error, instead redirect it to standard out with the
appropriate `E' prefix to indicate an error response message
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.10 2005/02/16 15:33:37 jfb Exp $	*/
d207 1
a207 1
	if (level > LP_MAX)
@


1.10
log
@properly initialize the syslog_data structure
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2005/02/15 15:29:35 jfb Exp $	*/
d257 2
a258 1
			else
d260 1
@


1.9
log
@remove the LP_FILTER_TOGGLE operation, which is really pointless, and
use a bitmask to keep track of the log filters
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.8 2004/12/15 06:11:40 jfb Exp $	*/
d70 1
a70 1
static struct syslog_data cvs_sl;
@


1.8
log
@Permit the client to generate trace output when the -t option is given
by using the LP_TRACE level to cvs_log().  Traces are filtered by
default.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.7 2004/12/07 17:10:56 tedu Exp $	*/
a66 2


d70 1
a70 2
static u_int cvs_log_filters[LP_MAX + 1];
#define NB_FILTERS  sizeof(cvs_log_filters)/sizeof(cvs_log_filters[0])
d72 5
d78 1
a78 1
static struct syslog_data cvs_sl;
d96 3
a98 3
	memset(cvs_log_filters, 0, sizeof(cvs_log_filters));
	cvs_log_filters[LP_DEBUG] = 1;
	cvs_log_filters[LP_INFO] = 1;
d101 1
a101 1
	cvs_log_filters[LP_TRACE] = 1;
d154 2
a155 2
			for (i = 0; i < NB_FILTERS; i++)
				cvs_log_filters[i] = 1;
d157 1
a157 1
			cvs_log_filters[level] = 1;
d161 1
a161 10
			for (i = 0; i < NB_FILTERS; i++)
				cvs_log_filters[i] = 0;
		else
			cvs_log_filters[level] = 0;
		break;
	case LP_FILTER_TOGGLE:
		if (level == LP_ALL)
			for (i = 0; i < NB_FILTERS; i++)
				cvs_log_filters[i] =
				    (cvs_log_filters[i] == 0) ? 1 : 0;
d163 1
a163 2
			cvs_log_filters[level] =
			    (cvs_log_filters[level] == 0) ? 1 : 0;
d211 1
a211 1
	if (cvs_log_filters[level] != 0)
@


1.7
log
@less whitespace, more pretty.  ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2004/12/06 21:03:12 deraadt Exp $	*/
d98 3
a217 1

d229 5
a233 1
	if (cvs_command != NULL) {
d244 1
a244 1
	if (cvs_log_flags & LF_PID) {
d271 5
a275 1
		fprintf(out, "%s: %s\n", prefix, buf);
@


1.6
log
@tighten vertical spacing for else; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2004/11/28 15:12:17 pat Exp $	*/
a84 1

a117 1

d121 1
a122 1

a184 1

a204 1

a284 1

@


1.5
log
@make sure va_end() is always called in all possible paths

ok jfb
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d238 1
a238 2
	}
	else /* just use the standard strlcpy */
@


1.4
log
@Add a new log level LP_ABORT, which modifies the behaviour of prefix
generation by outputting something similar to GNU CVS:

cvs [<command> aborted]: message
@
text
@a297 1

a298 1

@


1.3
log
@Adapt the logging so any messages generated by the server will be
prepended with a 'M' or 'E' command, depending on the log level, and
follow the GNU behaviour of printing the command name after the program
name in messages
@
text
@d51 2
a52 1
	"error"
d64 1
d216 2
a217 1
	ecp = 0;
a218 3
	if (level > LP_MAX) {
		return (-1);
	}
d221 1
a221 1
	if (cvs_log_filters[level] == 1)
d226 2
d232 6
a237 2
		snprintf(prefix, sizeof(prefix), "%s %s", __progname,
		    cvs_command);
@


1.2
log
@Comment out unused code and some minor cleanup.  Add the prototype and
skeleton for cvs_printf(), which will be used to output strings that do
not need all of the handling that cvs_log() performs.  This will be used
among other things to prepend the `M' and `E' family of responses to
output made by the `server' command.
@
text
@d38 1
d42 1
d227 10
a236 1
	strlcpy(prefix, __progname, sizeof(prefix));
d253 10
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@fugusec.net>
d41 1
d51 1
a51 1

a208 1
	pid_t pid;
d254 23
@


1.1.1.1
log
@* initial import from the cvs-tools module
@
text
@@
