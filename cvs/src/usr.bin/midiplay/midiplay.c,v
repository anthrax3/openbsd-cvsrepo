head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.1.0.12
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.10
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.05.05.09.18.12;	author ratchov;	state Exp;
branches;
next	1.17;
commitid	llzIbo7EMJ0pQOSj;

1.17
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	yGZX28AeTChVE8eY;

1.16
date	2013.11.12.13.54.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.26.04.17.04;	author lum;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.20.18.35.24;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.28.07.23.46;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.13.13.45.29;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.14.18.22.49;	author sobrado;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.02.15.19.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.06.00.56.51;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.28.10.59.11;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.11.22.54.06;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.14.04.27.26;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.10.22.20.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.01.23.58.22;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Fix one of the reads past the end of the buffer. Found
by Geoff Hill, fix proposed by jsg@@ and zhuk@@.
@
text
@/*	$OpenBSD: midiplay.c,v 1.17 2015/02/08 23:40:34 deraadt Exp $	*/
/*	$NetBSD: midiplay.c,v 1.8 1998/11/25 22:17:07 augustss Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (augustss@@netbsd.org).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <err.h>
#include <unistd.h>
#include <string.h>
#include <sndio.h>

struct track {
	u_char *start, *end;
	u_long curtime;
	u_char status;
};

#define MIDI_META 0xff

#define META_SEQNO	0x00
#define META_TEXT	0x01
#define META_COPYRIGHT	0x02
#define META_TRACK	0x03
#define META_INSTRUMENT	0x04
#define META_LYRIC	0x05
#define META_MARKER	0x06
#define META_CUE	0x07
#define META_CHPREFIX	0x20
#define META_EOT	0x2f
#define META_SET_TEMPO	0x51
#define META_KEY	0x59
#define META_SMPTE	0x54
#define META_TIMESIGN	0x58

char *metanames[] = { 
	"", "Text", "Copyright", "Track", "Instrument", 
	"Lyric", "Marker", "Cue",
};

static int midi_lengths[] = { 2,2,2,2,1,1,2,0 };
/* Number of bytes in a MIDI command */
#define MIDI_LENGTH(d) (midi_lengths[((d) >> 4) & 7])

#define MIDI_IS_STATUS(d)	((d) & 0x80)
#define MIDI_IS_COMMON(d)	((d) < 0xf0)
#define MIDI_SYSEX_START	0xf0
#define MIDI_SYSEX_STOP		0xf7

void usage(void);
void send_event(u_char, u_char *, u_int);
void dometa(u_int, u_char *, u_int);
void midireset(void);
u_long getvar(struct track *);
void playfile(FILE *, char *);
void playdata(u_char *, u_int, char *);
void sigalrm(int);
int main(int argc, char **argv);

extern char *__progname;

#define P(c) 1,0x90,c,0x7f,4,0x80,c,0
#define PL(c) 1,0x90,c,0x7f,8,0x80,c,0
#define C 0x3c
#define D 0x3e
#define E 0x40
#define F 0x41

u_char sample[] = { 
	'M','T','h','d',  0,0,0,6,  0,1,  0,1,  0,8,
	'M','T','r','k',  0,0,0,4+13*8,
	P(C), P(C), P(C), P(E), P(D), P(D), P(D), 
	P(F), P(E), P(E), P(D), P(D), PL(C),
	0, 0xff, 0x2f, 0
};
#undef P
#undef PL
#undef C
#undef D
#undef E
#undef F

#define MARK_HEADER "MThd"
#define MARK_TRACK "MTrk"
#define MARK_LEN 4

#define SIZE_LEN 4
#define HEADER_LEN 6

#define GET8(p) ((p)[0])
#define GET16(p) (((p)[0] << 8) | (p)[1])
#define GET24(p) (((p)[0] << 16) | ((p)[1] << 8) | (p)[2])
#define GET32(p) (((p)[0] << 24) | ((p)[1] << 16) | ((p)[2] << 8) | (p)[3])

void
usage(void)
{
	printf("usage: "
	       "%s [-gmqvx] [-f device] [-t tempo] [file ...]\n",
	       __progname);
	exit(1);
}

int showmeta = 0;
int verbose = 0;
u_int tempo = 60 * 1000000 / 100;	/* default tempo is 100bpm */
int play = 1;
struct mio_hdl *hdl;
struct timespec ts, ts_last;

void
send_event(u_char status, u_char *data, u_int len)
{
	u_int i;

	if (verbose > 1) {
		printf("MIDI %02x", status);
		for (i = 0; i < len; i++)
			printf(" %02x", data[i]);
		printf("\n");
	}
	if (play) {
		mio_write(hdl, &status, 1);
		mio_write(hdl, data, len);
	}
}

u_long
getvar(struct track *tp)
{
	u_long r, c;

	r = 0;
	do {
		c = *tp->start++;
		r = (r << 7) | (c & 0x7f);
	} while ((c & 0x80) && tp->start < tp->end);
	return (r);
}

void
dometa(u_int meta, u_char *p, u_int len)
{
	switch (meta) {
	case META_TEXT:
	case META_COPYRIGHT:
	case META_TRACK:
	case META_INSTRUMENT:
	case META_LYRIC:
	case META_MARKER:
	case META_CUE:
		if (showmeta) {
			printf("%s: ", metanames[meta]);
			fwrite(p, len, 1, stdout);
			printf("\n");
		}
		break;
	case META_SET_TEMPO:
		tempo = GET24(p);
		if (showmeta)
			printf("Tempo: %d us / quarter note\n", tempo);
		break;
	case META_TIMESIGN:
		if (showmeta) {
			int n = p[1];
			int d = 1;
			while (n-- > 0)
				d *= 2;
			printf("Time signature: %d/%d %d,%d\n",
			       p[0], d, p[2], p[3]);
		}
		break;
	case META_KEY:
		if (showmeta)
			printf("Key: %d %s\n", (char)p[0],
			       p[1] ? "minor" : "major");
		break;
	default:
		break;
	}
}

void
midireset(void)
{
	/* General MIDI reset sequence */
	static u_char gm_reset[] = { 0x7e, 0x7f, 0x09, 0x01, 0xf7 };

	send_event(MIDI_SYSEX_START, gm_reset, sizeof gm_reset);
}

void
playfile(FILE *f, char *name)
{
	u_char *buf, *newbuf;
	u_int tot, n, size, newsize, nread;

	/* 
	 * We need to read the whole file into memory for easy processing.
	 * Using mmap() would be nice, but some file systems do not support
	 * it, nor does reading from e.g. a pipe.  The latter also precludes
	 * finding out the file size without reading it.
	 */
	size = 1000;
	buf = malloc(size);
	if (buf == NULL)
		err(1, "malloc() failed");
	nread = size;
	tot = 0;
	for (;;) {
		n = fread(buf + tot, 1, nread, f);
		tot += n;
		if (n < nread)
			break;
		/* There must be more to read. */
		nread = size;
		newsize = size * 2;
		newbuf = realloc(buf, newsize);
		if (newbuf == NULL)
			err(1, "realloc() failed");
		buf = newbuf;
		size = newsize;
	}
	playdata(buf, tot, name);
	free(buf);
}

void
sigalrm(int i)
{
}

void
playdata(u_char *buf, u_int tot, char *name)
{
	long long delta_nsec = 0;
	u_int delta_ticks;
	int format, ntrks, divfmt, ticks, t, besttrk = 0;
	u_int len, mlen;
	u_char *p, *end, byte, meta;
	struct track *tracks;
	u_long bestcur, now;
	struct track *tp;

	end = buf + tot;
	if (verbose)
		printf("Playing %s (%d bytes) ... \n", name, tot);

	if (memcmp(buf, MARK_HEADER, MARK_LEN) != 0) {
		warnx("Not a MIDI file, missing header");
		return;
	}
	if (GET32(buf + MARK_LEN) != HEADER_LEN) {
		warnx("Not a MIDI file, bad header");
		return;
	}
	format = GET16(buf + MARK_LEN + SIZE_LEN);
	ntrks = GET16(buf + MARK_LEN + SIZE_LEN + 2);
	divfmt = GET8(buf + MARK_LEN + SIZE_LEN + 4);
	ticks = GET8(buf + MARK_LEN + SIZE_LEN + 5);
	p = buf + MARK_LEN + SIZE_LEN + HEADER_LEN;
	if ((divfmt & 0x80) == 0)
		ticks |= divfmt << 8;
	else
		errx(1, "Absolute time codes not implemented yet");
	if (verbose > 1)
		printf("format=%d ntrks=%d divfmt=%x ticks=%d\n",
		       format, ntrks, divfmt, ticks);
	if (format != 0 && format != 1) {
		warnx("Cannnot play MIDI file of type %d", format);
		return;
	}
	if (ntrks == 0)
		return;
	tracks = calloc(ntrks, sizeof(struct track));
	if (tracks == NULL)
		err(1, "malloc() tracks failed");
	for (t = 0; t < ntrks; ) {
		if (p >= end - MARK_LEN - SIZE_LEN) {
			warnx("Cannot find track %d", t);
			goto ret;
		}
		len = GET32(p + MARK_LEN);
		if (len > end - (p + MARK_LEN + SIZE_LEN)) {
			warnx("Crazy track length");
			goto ret;
		}
		if (memcmp(p, MARK_TRACK, MARK_LEN) == 0) {
			tracks[t].start = p + MARK_LEN + SIZE_LEN;
			tracks[t].end = tracks[t].start + len;
			tracks[t].curtime = getvar(&tracks[t]);
			t++;
		}
		p += MARK_LEN + SIZE_LEN + len;
	}

	/* 
	 * Play MIDI events by selecting the track with the lowest
	 * curtime.  Execute the event, update the curtime and repeat.
	 */

	now = 0;
	delta_nsec = 0;
	if (clock_gettime(CLOCK_MONOTONIC, &ts_last) < 0)
		err(1, "clock_gettime");
	for (;;) {
		/* Locate lowest curtime */
		bestcur = ULONG_MAX;
		for (t = 0; t < ntrks; t++) {
			if (tracks[t].curtime < bestcur) {
				bestcur = tracks[t].curtime;
				besttrk = t;
			}
		}
		if (bestcur == ULONG_MAX)
			break;
		if (verbose > 1) {
			printf("DELAY %4ld TRACK %2d ", bestcur-now, besttrk);
			fflush(stdout);
		}
		while (now < bestcur) {
			pause();
			if (clock_gettime(CLOCK_MONOTONIC, &ts) < 0)
				err(1, "clock_gettime");
			delta_nsec += 1000000000L * (ts.tv_sec - ts_last.tv_sec);
			delta_nsec += ts.tv_nsec - ts_last.tv_nsec;
			ts_last = ts;
			if (delta_nsec <= 0)
				continue;
			delta_ticks = delta_nsec * ticks / (1000LL * tempo);
			delta_nsec -= 1000LL * delta_ticks * tempo / ticks;
			now += delta_ticks;
		}
		tp = &tracks[besttrk];
		byte = *tp->start++;
		if (byte == MIDI_META) {
			meta = *tp->start++;
			mlen = getvar(tp);
			if (verbose > 1)
				printf("META %02x (%d)\n", meta, mlen);
			dometa(meta, tp->start, mlen);
			tp->start += mlen;
		} else {
			if (MIDI_IS_STATUS(byte))
				tp->status = byte;
			else
				tp->start--;
			if (MIDI_IS_COMMON(tp->status)) {
				mlen = MIDI_LENGTH(tp->status);
				send_event(tp->status, tp->start, mlen);
			} else if (tp->status == MIDI_SYSEX_START) {
				mlen = getvar(tp);
				send_event(MIDI_SYSEX_START, tp->start, mlen);
			} else if (tp->status == MIDI_SYSEX_STOP) {
				mlen = getvar(tp);
				/* Sorry, can't do this yet */;
			} else {
				if (verbose)
					printf("MIDI event 0x%02x ignored\n",
					       tp->status);
			}
			tp->start += mlen;
		}
		if (tp->start >= tp->end)
			tp->curtime = ULONG_MAX;
		else
			tp->curtime += getvar(tp);
	}
 ret:
	free(tracks);
}

int
main(int argc, char **argv)
{
	int ch;
	int example = 0;
	int gmreset = 0;
	char *file = NULL;
	FILE *f;
	const char *errstr;
	struct sigaction sa;
	struct itimerval it;

	while ((ch = getopt(argc, argv, "?d:f:glmqt:vx")) != -1) {
		switch (ch) {
		case 'f':
			file = optarg;
			break;
		case 'g':
			gmreset = 1;
			break;
		case 'm':
			showmeta = 1;
			break;
		case 'q':
			play = 0;
			break;
		case 't':
			tempo = 60 * 1000000 / 
			    strtonum(optarg, 40, 240, &errstr);
			if (errstr)
				errx(1, "tempo is %s: %s", errstr, optarg);
			break;
		case 'v':
			verbose++;
			break;
		case 'x':
			example = 1;
			break;
		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
    
	hdl = mio_open(file, MIO_OUT, 0);
	if (hdl == NULL)
		errx(1, "failed to open MIDI output");
	if (gmreset)
		midireset();

	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sigalrm;
	sigfillset(&sa.sa_mask);
	if (sigaction(SIGALRM, &sa, NULL) < 0)
		err(1, "sigaction");
	it.it_interval.tv_sec = it.it_value.tv_sec = 0;
	it.it_interval.tv_usec = it.it_value.tv_usec = 1000;
	if (setitimer(ITIMER_REAL, &it, NULL) < 0)
		err(1, "setitimer");

	if (example)
		playdata(sample, sizeof sample, "<Gubben Noa>");
	else if (argc == 0)
		playfile(stdin, "<stdin>");
	else
		while (argc--) {
			f = fopen(*argv, "r");
			if (f == NULL)
				err(1, "%s", *argv);
			else {
				playfile(f, *argv);
				fclose(f);
			}
			argv++;
		}

	exit(0);
}
@


1.17
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.16 2013/11/12 13:54:51 deraadt Exp $	*/
d315 1
a315 1
		if (len > 1000000) { /* a safe guard */
@


1.16
log
@simpler prototype repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.15 2012/01/26 04:17:04 lum Exp $	*/
d422 1
a422 1
			gmreset++;
d425 1
a425 1
			showmeta++;
d440 1
a440 1
			example++;
@


1.15
log
@Typo in comment. ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.14 2011/09/20 18:35:24 ratchov Exp $	*/
d88 1
@


1.14
log
@Don't include fcntl.h (not needed anymore) and use errx(3) instead of
fprintf(3) and exit(3).

from Michael W. Bombardieri <mwb at bom.nom.co>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.13 2011/04/28 07:23:46 ratchov Exp $	*/
d328 1
a328 1
	 * Play MIDI events by selecting the track track with the lowest
@


1.13
log
@use ULONG_MAX instead of ~0
from Michael W. Bombardieri <mb at ii.net>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.12 2010/02/13 13:45:29 ratchov Exp $	*/
a38 1
#include <fcntl.h>
d450 2
a451 4
	if (hdl == NULL) {
		fprintf(stderr, "failed to open MIDI output\n");
		exit(1);
	}
@


1.12
log
@convert midiplay to sndio(7) so it can be used with soft synths, for
instance. Now, the -f option sets the MIDI device (instead of the
sequencer(4) device). The -d and -l options were removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.11 2009/10/14 18:22:49 sobrado Exp $	*/
d339 1
a339 1
		bestcur = ~0;
d346 1
a346 1
		if (bestcur == ~0)
d396 1
a396 1
			tp->curtime = ~0;
@


1.11
log
@add a missing flag to usage; while here, slightly improve spacing
in source code (being consistent with the style used in the rest
of this file) and write "usage:" using lower case letters only, as
usual in the BSD operating systems.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.10 2008/06/26 05:42:21 ray Exp $	*/
d35 1
a35 3
#include <sys/ioctl.h>
#include <sys/midiio.h>

d43 1
a43 2

#define DEVMUSIC "/dev/music"
d77 5
d83 1
a83 1
void send_event(seq_event_rec *);
a85 1
void send_sysex(u_char *, u_int);
d130 1
a130 1
	       "%s [-glmqvx] [-d devno] [-f file] [-t tempo] [file ...]\n",
d137 1
a137 4
#define BASETEMPO 400000
u_int tempo = BASETEMPO;		/* microsec / quarter note */
u_int ttempo = 100;
int unit = 0;
d139 2
a140 1
int fd;
d143 1
a143 1
send_event(seq_event_rec *ev)
d145 12
a156 7
	/*
	printf("%02x %02x %02x %02x %02x %02x %02x %02x\n",
	       ev->arr[0], ev->arr[1], ev->arr[2], ev->arr[3], 
	       ev->arr[4], ev->arr[5], ev->arr[6], ev->arr[7]);
	*/
	if (play)
		write(fd, ev, sizeof *ev);
d220 1
a220 23
	send_sysex(gm_reset, sizeof gm_reset);
}

#define SYSEX_CHUNK 6
void
send_sysex(u_char *p, u_int l)
{
	seq_event_rec event;
	u_int n;

	event.arr[0] = SEQ_SYSEX;
	event.arr[1] = unit;
	do {
		n = SYSEX_CHUNK;
		if (l < n) {
			memset(&event.arr[2], 0xff, SYSEX_CHUNK);
			n = l;
		}
		memcpy(&event.arr[2], p, n);
		send_event(&event);
		l -= n;
		p += n;
	} while (l > 0);
d260 5
d267 2
d270 2
a271 2
	u_int len, mlen, status, chan;
	u_char *p, *end, byte, meta, *msg;
a274 1
	seq_event_rec event;
a332 18
	/*
	 * The ticks variable is the number of ticks that make up a quarter
	 * note and is used as a reference value for the delays between
	 * the MIDI events.
	 * The sequencer has two "knobs": the TIMEBASE and the TEMPO.
	 * The delay specified in TMR_WAIT_REL is specified in
	 * sequencer time units.  The length of a unit is
	 * 60*1000000 / (TIMEBASE * TEMPO).
	 * Set it to 1ms/unit (adjusted by user tempo changes).
	 */
	t = 500 * ttempo / 100;
	if (ioctl(fd, SEQUENCER_TMR_TIMEBASE, &t) < 0)
		err(1, "SEQUENCER_TMR_TIMEBASE");
	t = 120;
	if (ioctl(fd, SEQUENCER_TMR_TEMPO, &t) < 0)
		err(1, "SEQUENCER_TMR_TEMPO");
	if (ioctl(fd, SEQUENCER_TMR_START, 0) < 0)
		err(1, "SEQUENCER_TMR_START");
d334 3
d352 12
a363 17
		if (now < bestcur) {
			union {
				u_int32_t i;
				u_int8_t b[4];
			} u;
			u_int32_t delta = bestcur - now;
			delta = (int)((double)delta * tempo / (1000.0*ticks));
			u.i = delta;
			if (delta != 0) {
				event.arr[0] = SEQ_TIMING;
				event.arr[1] = TMR_WAIT_REL;
				event.arr[4] = u.b[0];
				event.arr[5] = u.b[1];
				event.arr[6] = u.b[2];
				event.arr[7] = u.b[3];
				send_event(&event);
			}
a364 1
		now = bestcur;
d379 7
a385 39
			mlen = MIDI_LENGTH(tp->status);
			msg = tp->start;
			if (verbose > 1) {
			    if (mlen == 1)
				printf("MIDI %02x (%d) %02x\n",
				       tp->status, mlen, msg[0]);
			    else   
				printf("MIDI %02x (%d) %02x %02x\n",
				       tp->status, mlen, msg[0], msg[1]);
			}
			status = MIDI_GET_STATUS(tp->status);
			chan = MIDI_GET_CHAN(tp->status);
			switch (status) {
			case MIDI_NOTEOFF:
			case MIDI_NOTEON:
			case MIDI_KEY_PRESSURE:
				SEQ_MK_CHN_VOICE(&event, unit, status, chan,
						 msg[0], msg[1]);
				send_event(&event);
				break;
			case MIDI_CTL_CHANGE:
				SEQ_MK_CHN_COMMON(&event, unit, status, chan, 
						  msg[0], 0, msg[1]);
				send_event(&event);
				break;
			case MIDI_PGM_CHANGE:
			case MIDI_CHN_PRESSURE:
				SEQ_MK_CHN_COMMON(&event, unit, status, chan, 
						  msg[0], 0, 0);
				send_event(&event);
				break;
			case MIDI_PITCH_BEND:
				SEQ_MK_CHN_COMMON(&event, unit, status, chan, 
						  0, 0, 
						  (msg[0] & 0x7f) | 
						  ((msg[1] & 0x7f) << 7));
				send_event(&event);
				break;
			case MIDI_SYSTEM_PREFIX:
d387 2
a388 6
				if (tp->status == MIDI_SYSEX_START)
					send_sysex(tp->start, mlen);
				else
					/* Sorry, can't do this yet */;
				break;
			default:
a399 3
	if (ioctl(fd, SEQUENCER_SYNC, 0) < 0)
		err(1, "SEQUENCER_SYNC");

a407 1
	int listdevs = 0;
d410 1
a410 3
	int nmidi;
	char *file = DEVMUSIC;
	struct synth_info info;
d413 2
a417 5
		case 'd':
			unit = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "unit is %s: %s", errstr, optarg);
			break;
a423 3
		case 'l':
			listdevs++;
			break;
d431 2
a432 1
			ttempo = strtonum(optarg, 0, INT_MAX, &errstr);
d450 4
a453 14
	fd = open(file, O_WRONLY);
	if (fd < 0)
		err(1, "%s", file);
	if (ioctl(fd, SEQUENCER_NRMIDIS, &nmidi) < 0)
		err(1, "ioctl(SEQUENCER_NRMIDIS) failed, ");
	if (nmidi == 0)
		errx(1, "Sorry, no MIDI devices available");
	if (listdevs) {
		for (info.device = 0; info.device < nmidi; info.device++) {
			if (ioctl(fd, SEQUENCER_INFO, &info) < 0)
				err(1, "ioctl(SEQUENCER_INFO) failed, ");
			printf("%d: %s\n", info.device, info.name);
		}
		exit(0);
d457 11
@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.9 2007/09/02 15:19:33 deraadt Exp $	*/
d128 3
a130 2
	printf("Usage: %s [-lmqvx] [-d devno] [-f file] [-t tempo] "
	    "[file ...]\n", __progname);
@


1.9
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.8 2005/11/06 00:56:51 jsg Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@Instead of always forcing General MIDI 1 mode make it an option
so other modes can be used.
From Alexandre Ratchov, alex-contact at caoua.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.7 2005/07/28 10:59:11 jsg Exp $	*/
d324 1
a324 1
	tracks = malloc(ntrks * sizeof(struct track));
@


1.7
log
@Fix bug that prevented system exclusive messages longer than 6 bytes
from working properly.
From Alexandre Ratchov alex-contact at caoua.org
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.6 2005/03/11 22:54:06 jmc Exp $	*/
d488 1
d495 1
a495 1
	while ((ch = getopt(argc, argv, "?d:f:lmqt:vx")) != -1) {
d505 3
d551 2
a552 1
	midireset();
@


1.6
log
@- synopsis according to style(9)
- add missing -q option
- sync usage()
- minor tweaks while here
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.5 2004/05/14 04:27:26 tedu Exp $	*/
d243 1
@


1.5
log
@little cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.4 2003/06/10 22:20:48 deraadt Exp $	*/
d135 2
a136 2
	printf("Usage: %s [-d unit] [-f file] [-l] [-m] [-q] [-t tempo]"
	    "[-v] [-x] [file ...]\n", __progname);
@


1.4
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.3 2002/03/14 06:51:42 mpech Exp $	*/
d40 5
d47 1
a51 4
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/midiio.h>
d135 2
a136 2
	printf("Usage: %s [-d unit] [-f file] [-l] [-m] [-q] [-t tempo] [-v] [-x] [file ...]\n",
		__progname);
d249 2
a250 2
	u_char *buf;
	u_int tot, n, size, nread;
d260 2
a261 2
	if (buf == 0)
		errx(1, "malloc() failed");
d271 6
a276 4
		size *= 2;
		buf = realloc(buf, size);
		if (buf == NULL)
			errx(1, "realloc() failed");
d325 1
a325 1
		errx(1, "malloc() tracks failed");
d491 1
d494 1
a494 1
		switch(ch) {
d496 3
a498 1
			unit = atoi(optarg);
d513 3
a515 1
			ttempo = atoi(optarg);
@


1.3
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.2 2002/02/16 21:27:49 millert Exp $	*/
d131 1
a131 1
usage()
d148 1
a148 2
send_event(ev)
	seq_event_rec *ev;
d160 1
a160 2
getvar(tp)
	struct track *tp;
d173 1
a173 4
dometa(meta, p, len)
	u_int meta;
	u_char *p;
	u_int len;
d215 1
a215 1
midireset()
d225 1
a225 3
send_sysex(p, l)
	u_char *p;
	u_int l;
d245 1
a245 3
playfile(f, name)
	FILE *f;
	char *name;
d279 1
a279 4
playdata(buf, tot, name)
	u_char *buf;
	u_int tot;
	char *name;
d478 1
a478 3
main(argc, argv)
	int argc;
	char **argv;
@


1.2
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.1 1999/01/01 23:58:22 niklas Exp $	*/
d268 1
a268 1
		errx(1, "malloc() failed\n");
d281 1
a281 1
			errx(1, "realloc() failed\n");
d306 1
a306 1
		warnx("Not a MIDI file, missing header\n");
d310 1
a310 1
		warnx("Not a MIDI file, bad header\n");
d321 1
a321 1
		errx(1, "Absolute time codes not implemented yet\n");
d326 1
a326 1
		warnx("Cannnot play MIDI file of type %d\n", format);
d333 1
a333 1
		errx(1, "malloc() tracks failed\n");
d336 1
a336 1
			warnx("Cannot find track %d\n", t);
d341 1
a341 1
			warnx("Crazy track length\n");
d542 1
a542 1
		errx(1, "Sorry, no MIDI devices available\n");
@


1.1
log
@MIDI file player
@
text
@d1 1
a1 1
/*	$OpenBSD: midiplay.c,v 1.8 1998/11/25 22:17:07 augustss Exp $	*/
d85 9
a93 9
void usage __P((void));
void send_event __P((seq_event_rec *));
void dometa __P((u_int, u_char *, u_int));
void midireset __P((void));
void send_sysex __P((u_char *, u_int));
u_long getvar __P((struct track *));
void playfile __P((FILE *, char *));
void playdata __P((u_char *, u_int, char *));
int main __P((int argc, char **argv));
@

