head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.26
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.24
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.20
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.22
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.14
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.18
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.16
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.12
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.12
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.26.14.20.03;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.20.00.01.20;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.22.20.52.55;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.10.22.20.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.02.24.00;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.07.00.31.55;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.31.16.55.37;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.43.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.29.01.07.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@/*	$OpenBSD: rpcinfo.c,v 1.13 2009/10/27 23:59:42 deraadt Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpcinfo: ping a particular rpc program
 *     or dump the portmapper
 */

#include <rpc/rpc.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netdb.h>
#include <rpc/pmap_prot.h>
#include <rpc/pmap_clnt.h>
#include <signal.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <arpa/inet.h>

#define MAXHOSTLEN 256

#define	MIN_VERS	((u_long) 0)
#define	MAX_VERS	((u_long) 4294967295UL)

void	udpping(u_short portflag, int argc, char **argv);
void	tcpping(u_short portflag, int argc, char **argv);
int	pstatus(CLIENT *client, u_long prognum, u_long vers);
void	pmapdump(int argc, char **argv);
bool_t	reply_proc(caddr_t res, struct sockaddr_in *who);
void	brdcst(int argc, char **argv);
void	deletereg(int argc, char **argv);
void	setreg(int argc, char **argv);
void	usage(char *);
int	getprognum(char *arg, u_long *ulp);
int	getul(char *arg, u_long *ulp);
void	get_inet_address(struct sockaddr_in *addr, char *host);

/*
 * Functions to be performed.
 */
#define	NONE		0	/* no function */
#define	PMAPDUMP	1	/* dump portmapper registrations */
#define	TCPPING		2	/* ping TCP service */
#define	UDPPING		3	/* ping UDP service */
#define	BRDCST		4	/* ping broadcast UDP service */
#define DELETES		5	/* delete registration for the service */
#define SETS		6	/* set registration for the service */

int
main(int argc, char *argv[])
{
	int c;
	extern char *optarg;
	extern int optind;
	int errflg;
	int function;
	u_short portnum;
	u_long tmp;

	function = NONE;
	portnum = 0;
	errflg = 0;
	while ((c = getopt(argc, argv, "ptubdsn:")) != -1) {
		switch (c) {

		case 'p':
			if (function != NONE)
				errflg = 1;
			else
				function = PMAPDUMP;
			break;

		case 't':
			if (function != NONE)
				errflg = 1;
			else
				function = TCPPING;
			break;

		case 'u':
			if (function != NONE)
				errflg = 1;
			else
				function = UDPPING;
			break;

		case 'b':
			if (function != NONE)
				errflg = 1;
			else
				function = BRDCST;
			break;

		case 'n':
			if (getul(optarg, &tmp))
				usage("invalid port number");
			if (tmp >= 65536)
				usage("port number out of range");
			portnum = (u_short)tmp;
			break;

		case 'd':
			if (function != NONE)
				errflg = 1;
			else
				function = DELETES;
			break;

		case 's':
			if (function != NONE)
				errflg = 1;
			else
				function = SETS;
			break;


		case '?':
			errflg = 1;
		}
	}

	if (errflg || function == NONE)
		usage(NULL);

	switch (function) {

	case PMAPDUMP:
		if (portnum != 0)
			usage(NULL);
		pmapdump(argc - optind, argv + optind);
		break;

	case UDPPING:
		udpping(portnum, argc - optind, argv + optind);
		break;

	case TCPPING:
		tcpping(portnum, argc - optind, argv + optind);
		break;

	case BRDCST:
		if (portnum != 0)
			usage(NULL);

		brdcst(argc - optind, argv + optind);
		break;

	case DELETES:
		deletereg(argc - optind, argv + optind);
		break;

	case SETS:
		setreg(argc - optind, argv + optind);
		break;
	}

	return (0);
}
		
void
udpping(u_short portnum, int argc, char **argv)
{
	struct timeval to;
	struct sockaddr_in addr;
	enum clnt_stat rpc_stat;
	CLIENT *client;
	u_long prognum, vers, minvers, maxvers;
	int sock = RPC_ANYSOCK;
	struct rpc_err rpcerr;
	int failure;
    
	if (argc < 2)
		usage("too few arguments");
	if (argc > 3)
		usage("too many arguments");
	if (getprognum(argv[1], &prognum))
		usage("program number out of range");

	get_inet_address(&addr, argv[0]);
	/* Open the socket here so it will survive calls to clnt_destroy */
	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sock < 0) {
		perror("rpcinfo: socket");
		exit(1);
	}
	if (getuid() == 0)
		bindresvport(sock, NULL);
	failure = 0;
	if (argc == 2) {
		/*
		 * A call to version 0 should fail with a program/version
		 * mismatch, and give us the range of versions supported.
		 */
		addr.sin_port = htons(portnum);
		to.tv_sec = 5;
		to.tv_usec = 0;
		if ((client = clntudp_create(&addr, prognum, (u_long)0,
		    to, &sock)) == NULL) {
			clnt_pcreateerror("rpcinfo");
			printf("program %lu is not available\n",
			    prognum);
			exit(1);
		}
		to.tv_sec = 10;
		to.tv_usec = 0;
		rpc_stat = clnt_call(client, NULLPROC, xdr_void, (char *)NULL,
		    xdr_void, (char *)NULL, to);
		if (rpc_stat == RPC_PROGVERSMISMATCH) {
			clnt_geterr(client, &rpcerr);
			minvers = rpcerr.re_vers.low;
			maxvers = rpcerr.re_vers.high;
		} else if (rpc_stat == RPC_SUCCESS) {
			/*
			 * Oh dear, it DOES support version 0.
			 * Let's try version MAX_VERS.
			 */
			addr.sin_port = htons(portnum);
			to.tv_sec = 5;
			to.tv_usec = 0;
			if ((client = clntudp_create(&addr, prognum, MAX_VERS,
			    to, &sock)) == NULL) {
				clnt_pcreateerror("rpcinfo");
				printf("program %lu version %lu is not available\n",
				    prognum, MAX_VERS);
				exit(1);
			}
			to.tv_sec = 10;
			to.tv_usec = 0;
			rpc_stat = clnt_call(client, NULLPROC, xdr_void,
			    (char *)NULL, xdr_void, (char *)NULL, to);
			if (rpc_stat == RPC_PROGVERSMISMATCH) {
				clnt_geterr(client, &rpcerr);
				minvers = rpcerr.re_vers.low;
				maxvers = rpcerr.re_vers.high;
			} else if (rpc_stat == RPC_SUCCESS) {
				/*
				 * It also supports version MAX_VERS.
				 * Looks like we have a wise guy.
				 * OK, we give them information on all
				 * 4 billion versions they support...
				 */
				minvers = 0;
				maxvers = MAX_VERS;
			} else {
				(void) pstatus(client, prognum, MAX_VERS);
				exit(1);
			}
		} else {
			(void) pstatus(client, prognum, (u_long)0);
			exit(1);
		}
		clnt_destroy(client);
		for (vers = minvers; vers <= maxvers; vers++) {
			addr.sin_port = htons(portnum);
			to.tv_sec = 5;
			to.tv_usec = 0;
			if ((client = clntudp_create(&addr, prognum, vers,
			    to, &sock)) == NULL) {
				clnt_pcreateerror("rpcinfo");
				printf("program %lu version %lu is not available\n",
				    prognum, vers);
				exit(1);
			}
			to.tv_sec = 10;
			to.tv_usec = 0;
			rpc_stat = clnt_call(client, NULLPROC, xdr_void,
			    (char *)NULL, xdr_void, (char *)NULL, to);
			if (pstatus(client, prognum, vers) < 0)
				failure = 1;
			clnt_destroy(client);
		}
	} else {
		getul(argv[2], &vers);		/* XXX */
		addr.sin_port = htons(portnum);
		to.tv_sec = 5;
		to.tv_usec = 0;
		if ((client = clntudp_create(&addr, prognum, vers,
		    to, &sock)) == NULL) {
			clnt_pcreateerror("rpcinfo");
			printf("program %lu version %lu is not available\n",
			    prognum, vers);
			exit(1);
		}
		to.tv_sec = 10;
		to.tv_usec = 0;
		rpc_stat = clnt_call(client, 0, xdr_void, (char *)NULL,
		    xdr_void, (char *)NULL, to);
		if (pstatus(client, prognum, vers) < 0)
			failure = 1;
	}
	(void) close(sock); /* Close it up again */
	if (failure)
		exit(1);
}

void
tcpping(u_short portnum, int argc, char **argv)
{
	struct timeval to;
	struct sockaddr_in addr;
	enum clnt_stat rpc_stat;
	CLIENT *client;
	u_long prognum, vers, minvers, maxvers;
	int sock = RPC_ANYSOCK;
	struct rpc_err rpcerr;
	int failure;

	if (argc < 2)
		usage("too few arguments");
	if (argc > 3)
		usage("too many arguments");
	if (getprognum(argv[1], &prognum))
		usage("program number out of range");

	get_inet_address(&addr, argv[0]);
	failure = 0;
	if (argc == 2) {
		/*
		 * A call to version 0 should fail with a program/version
		 * mismatch, and give us the range of versions supported.
		 */
		addr.sin_port = htons(portnum);
		if ((client = clnttcp_create(&addr, prognum, MIN_VERS,
		    &sock, 0, 0)) == NULL) {
			clnt_pcreateerror("rpcinfo");
			printf("program %lu is not available\n",
			    prognum);
			exit(1);
		}
		to.tv_sec = 10;
		to.tv_usec = 0;
		rpc_stat = clnt_call(client, NULLPROC, xdr_void, (char *)NULL,
		    xdr_void, (char *)NULL, to);
		if (rpc_stat == RPC_PROGVERSMISMATCH) {
			clnt_geterr(client, &rpcerr);
			minvers = rpcerr.re_vers.low;
			maxvers = rpcerr.re_vers.high;
		} else if (rpc_stat == RPC_SUCCESS) {
			/*
			 * Oh dear, it DOES support version 0.
			 * Let's try version MAX_VERS.
			 */
			addr.sin_port = htons(portnum);
			if ((client = clnttcp_create(&addr, prognum, MAX_VERS,
			    &sock, 0, 0)) == NULL) {
				clnt_pcreateerror("rpcinfo");
				printf("program %lu version %lu is not available\n",
				    prognum, MAX_VERS);
				exit(1);
			}
			to.tv_sec = 10;
			to.tv_usec = 0;
			rpc_stat = clnt_call(client, NULLPROC, xdr_void,
			    (char *)NULL, xdr_void, (char *)NULL, to);
			if (rpc_stat == RPC_PROGVERSMISMATCH) {
				clnt_geterr(client, &rpcerr);
				minvers = rpcerr.re_vers.low;
				maxvers = rpcerr.re_vers.high;
			} else if (rpc_stat == RPC_SUCCESS) {
				/*
				 * It also supports version MAX_VERS.
				 * Looks like we have a wise guy.
				 * OK, we give them information on all
				 * 4 billion versions they support...
				 */
				minvers = 0;
				maxvers = MAX_VERS;
			} else {
				(void) pstatus(client, prognum, MAX_VERS);
				exit(1);
			}
		} else {
			(void) pstatus(client, prognum, MIN_VERS);
			exit(1);
		}
		clnt_destroy(client);
		(void) close(sock);
		sock = RPC_ANYSOCK; /* Re-initialize it for later */
		for (vers = minvers; vers <= maxvers; vers++) {
			addr.sin_port = htons(portnum);
			if ((client = clnttcp_create(&addr, prognum, vers,
			    &sock, 0, 0)) == NULL) {
				clnt_pcreateerror("rpcinfo");
				printf("program %lu version %lu is not available\n",
				    prognum, vers);
				exit(1);
			}
			to.tv_usec = 0;
			to.tv_sec = 10;
			rpc_stat = clnt_call(client, 0, xdr_void, (char *)NULL,
			    xdr_void, (char *)NULL, to);
			if (pstatus(client, prognum, vers) < 0)
				failure = 1;
			clnt_destroy(client);
			(void) close(sock);
			sock = RPC_ANYSOCK;
		}
	} else {
		getul(argv[2], &vers);		/* XXX */
		addr.sin_port = htons(portnum);
		if ((client = clnttcp_create(&addr, prognum, vers, &sock,
		    0, 0)) == NULL) {
			clnt_pcreateerror("rpcinfo");
			printf("program %lu version %lu is not available\n",
			    prognum, vers);
			exit(1);
		}
		to.tv_usec = 0;
		to.tv_sec = 10;
		rpc_stat = clnt_call(client, 0, xdr_void, (char *)NULL,
		    xdr_void, (char *)NULL, to);
		if (pstatus(client, prognum, vers) < 0)
			failure = 1;
	}
	if (failure)
		exit(1);
}

/*
 * This routine should take a pointer to an "rpc_err" structure, rather than
 * a pointer to a CLIENT structure, but "clnt_perror" takes a pointer to
 * a CLIENT structure rather than a pointer to an "rpc_err" structure.
 * As such, we have to keep the CLIENT structure around in order to print
 * a good error message.
 */
int
pstatus(CLIENT *client, u_long prognum, u_long vers)
{
	struct rpc_err rpcerr;

	clnt_geterr(client, &rpcerr);
	if (rpcerr.re_status != RPC_SUCCESS) {
		clnt_perror(client, "rpcinfo");
		printf("program %lu version %lu is not available\n",
		    prognum, vers);
		return (-1);
	} else {
		printf("program %lu version %lu ready and waiting\n",
		    prognum, vers);
		return (0);
	}
}

void
pmapdump(int argc, char **argv)
{
	struct sockaddr_in server_addr;
	struct hostent *hp;
	struct pmaplist *head = NULL;
	int socket = RPC_ANYSOCK;
	struct timeval minutetimeout;
	CLIENT *client;
	struct rpcent *rpc;
	
	if (argc > 1)
		usage("too many arguments");

	if (argc == 1)
		get_inet_address(&server_addr, argv[0]);
	else {
		bzero((char *)&server_addr, sizeof server_addr);
		server_addr.sin_family = AF_INET;
		if ((hp = gethostbyname("localhost")) != NULL)
			bcopy(hp->h_addr, (caddr_t)&server_addr.sin_addr,
			    hp->h_length);
		else
			(void) inet_aton("0.0.0.0", &server_addr.sin_addr);
	}
	minutetimeout.tv_sec = 60;
	minutetimeout.tv_usec = 0;
	server_addr.sin_port = htons(PMAPPORT);
	if ((client = clnttcp_create(&server_addr, PMAPPROG,
	    PMAPVERS, &socket, 50, 500)) == NULL) {
		clnt_pcreateerror("rpcinfo: can't contact portmapper");
		exit(1);
	}
	if (clnt_call(client, PMAPPROC_DUMP, xdr_void, NULL,
	    xdr_pmaplist, &head, minutetimeout) != RPC_SUCCESS) {
		fprintf(stderr, "rpcinfo: can't contact portmapper: ");
		clnt_perror(client, "rpcinfo");
		exit(1);
	}
	if (head == NULL) {
		printf("No remote programs registered.\n");
	} else {
		printf("   program vers proto   port\n");
		for (; head != NULL; head = head->pml_next) {
			printf("%10ld%5ld",
			    head->pml_map.pm_prog,
			    head->pml_map.pm_vers);
			if (head->pml_map.pm_prot == IPPROTO_UDP)
				printf("%6s",  "udp");
			else if (head->pml_map.pm_prot == IPPROTO_TCP)
				printf("%6s", "tcp");
			else
				printf("%6ld",  head->pml_map.pm_prot);
			printf("%7ld",  head->pml_map.pm_port);
			rpc = getrpcbynumber(head->pml_map.pm_prog);
			if (rpc)
				printf("  %s\n", rpc->r_name);
			else
				printf("\n");
		}
	}
}

/* 
 * reply_proc collects replies from the broadcast. 
 * to get a unique list of responses the output of rpcinfo should
 * be piped through sort(1) and then uniq(1).
 */
/*ARGSUSED*/
bool_t
reply_proc(caddr_t res, struct sockaddr_in *who)
{
	struct hostent *hp;

	hp = gethostbyaddr((char *) &who->sin_addr, sizeof who->sin_addr,
	    AF_INET);
	printf("%s %s\n", inet_ntoa(who->sin_addr),
	    (hp == NULL) ? "(unknown)" : hp->h_name);
	return(FALSE);
}

void
brdcst(int argc, char **argv)
{
	enum clnt_stat rpc_stat;
	u_long prognum, vers_num;

	if (argc != 2)
		usage("incorrect number of arguments");
	if (getprognum(argv[1], &prognum))
		usage("program number out of range");
	if (getul(argv[1], &vers_num))
		usage("version number out of range");
		
	rpc_stat = clnt_broadcast(prognum, vers_num, NULLPROC, xdr_void,
	    (char *)NULL, xdr_void, (char *)NULL, reply_proc);
	if ((rpc_stat != RPC_SUCCESS) && (rpc_stat != RPC_TIMEDOUT)) {
		fprintf(stderr, "rpcinfo: broadcast failed: %s\n",
		    clnt_sperrno(rpc_stat));
		exit(1);
	}
	exit(0);
}

void
deletereg(int argc, char **argv)
{
	u_long prog_num, version_num;

	if (argc != 2)
		usage("incorrect number of arguments");
	if (getprognum(argv[0], &prog_num))
		usage("program number out of range");
	if (getul(argv[1], &version_num))
		usage("version number out of range");

	if ((pmap_unset(prog_num, version_num)) == 0) {
		fprintf(stderr, "rpcinfo: Could not delete "
		    "registration for prog %s version %s\n",
		    argv[0], argv[1]);
		exit(1);
	}
}

void
setreg(int argc, char **argv)
{
	u_long prog_num, version_num, port_num;

	if (argc != 3)
		usage("incorrect number of arguments");
	if (getprognum(argv[0], &prog_num))
		usage("cannot parse program number");
	if (getul(argv[1], &version_num))
		usage("cannot parse version number");
	if (getul(argv[2], &port_num))
		usage("cannot parse port number");
	if (port_num >= 65536)
		usage("port number out of range");
		
	if ((pmap_set(prog_num, version_num, IPPROTO_TCP,
	    (u_short)port_num)) == 0) {
		fprintf(stderr, "rpcinfo: Could not set registration "
		    "for prog %s version %s port %s protocol IPPROTO_TCP\n",
		    argv[0], argv[1], argv[2]);
		exit(1);
	}
	if ((pmap_set(prog_num, version_num, IPPROTO_UDP,
	    (u_short)port_num)) == 0) {
		fprintf(stderr, "rpcinfo: Could not set registration "
		    "for prog %s version %s port %s protocol IPPROTO_UDP\n",
		    argv[0], argv[1], argv[2]);
		exit(1);
	}
}

void
usage(char *msg)
{
	if (msg)
		fprintf(stderr,
		    "rpcinfo: %s\n", msg);
	fprintf(stderr, "usage: rpcinfo -b program version\n");
	fprintf(stderr, "       rpcinfo -d program version\n");
	fprintf(stderr, "       rpcinfo -p [host]\n");
	fprintf(stderr, "       rpcinfo -s program version port\n");
	fprintf(stderr,
	    "       rpcinfo [-n portnum] -t host program [version]\n");
	fprintf(stderr,
	    "       rpcinfo [-n portnum] -u host program [version]\n");
	exit(1);
}

int
getprognum(char *arg, u_long *ulp)
{
	struct rpcent *rpc;

	if (isalpha(*arg)) {
		rpc = getrpcbyname(arg);
		if (rpc == NULL) {
			fprintf(stderr, "rpcinfo: %s is unknown service\n",
			    arg);
			exit(1);
		}
		*ulp = rpc->r_number;
		return 0;
	}
	return getul(arg, ulp);
}

int
getul(char *arg, u_long *ulp)
{
	u_long ul;
	int save_errno = errno;
	char *ep;
	int ret = 1;

	errno = 0;
	ul = strtoul(arg, &ep, 10);
	if (arg[0] == '\0' || *ep != '\0')
		goto fail;
	if (errno == ERANGE && ul == ULONG_MAX)
		goto fail;
	*ulp = ul;
	ret = 0;
fail:
	errno = save_errno;
	return (ret);
}

void
get_inet_address(struct sockaddr_in *addr, char *host)
{
	struct hostent *hp;

	bzero((char *)addr, sizeof *addr);
	if (inet_aton(host, &addr->sin_addr) == 0) {
		if ((hp = gethostbyname(host)) == NULL) {
			fprintf(stderr, "rpcinfo: %s is unknown host\n",
			    host);
			exit(1);
		}
		bcopy(hp->h_addr, (char *)&addr->sin_addr, hp->h_length);
	}
	addr->sin_family = AF_INET;
}
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.12 2007/03/26 14:20:03 jmc Exp $	*/
d4 28
a31 1
 * Copyright (C) 1986, Sun Microsystems, Inc.
a36 29
 */

/*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
@


1.12
log
@sort options, synopsis, and usage(); from Igor Sobrado
@
text
@d1 1
a1 7
/*	$OpenBSD: rpcinfo.c,v 1.11 2006/01/20 00:01:20 millert Exp $	*/

#ifndef lint
/*static char sccsid[] = "from: @@(#)rpcinfo.c 1.22 87/08/12 SMI";*/
/*static char sccsid[] = "from: @@(#)rpcinfo.c	2.2 88/08/11 4.0 RPCSRC";*/
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.11 2006/01/20 00:01:20 millert Exp $";
#endif
@


1.11
log
@Explicitly include limits.h if we are going to use its contents.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.10 2005/09/22 20:52:55 deraadt Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.10 2005/09/22 20:52:55 deraadt Exp $";
d648 4
d653 1
a653 1
	    "Usage: rpcinfo [ -n portnum ] -u host prognum [ versnum ]\n");
d655 1
a655 5
	    "       rpcinfo [ -n portnum ] -t host prognum [ versnum ]\n");
	fprintf(stderr, "       rpcinfo -p [ host ]\n");
	fprintf(stderr, "       rpcinfo -b prognum versnum\n");
	fprintf(stderr, "       rpcinfo -d prognum versnum\n");
	fprintf(stderr, "       rpcinfo -s prognum versnum portnum\n");
@


1.10
log
@-s was using the wrong arg (PF_INET) for protocol instead of IPPROTO_TCP & IPPROTO_UDP for pmap_set()
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.9 2003/06/10 22:20:50 deraadt Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.9 2003/06/10 22:20:50 deraadt Exp $";
d59 1
@


1.9
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.8 2001/11/19 19:02:16 mpech Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.8 2001/11/19 19:02:16 mpech Exp $";
d625 1
a625 1
	if ((pmap_set(prog_num, version_num, PF_INET,
d628 8
a635 1
		    "for prog %s version %s port %s\n",
@


1.8
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.7 2001/07/17 02:24:00 pvalchev Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.7 2001/07/17 02:24:00 pvalchev Exp $";
d91 1
a91 3
main(argc, argv)
	int argc;
	char **argv;
d202 1
a202 4
udpping(portnum, argc, argv)
	u_short portnum;
	int argc;
	char **argv;
d338 1
a338 4
tcpping(portnum, argc, argv)
	u_short portnum;
	int argc;
	char **argv;
d468 1
a468 4
pstatus(client, prognum, vers)
	CLIENT *client;
	u_long prognum;
	u_long vers;
d486 1
a486 3
pmapdump(argc, argv)
	int argc;
	char **argv;
d555 1
a555 3
reply_proc(res, who)
	caddr_t res;			/* Nothing comes back */
	struct sockaddr_in *who;	/* Who sent us the reply */
d567 1
a567 3
brdcst(argc, argv)
	int argc;
	char **argv;
d590 1
a590 3
deletereg(argc, argv)
	int argc;
	char **argv;
d610 1
a610 3
setreg(argc, argv)
	int argc;
	char **argv;
d652 1
a652 3
getprognum(arg, ulp)
	char *arg;
	u_long *ulp;
d670 1
a670 3
getul(arg, ulp)
	char *arg;
	u_long *ulp;
d691 1
a691 3
get_inet_address(addr, host)
	struct sockaddr_in *addr;
	char *host;
@


1.7
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.6 2001/07/07 00:31:55 millert Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.6 2001/07/07 00:31:55 millert Exp $";
d95 1
a95 1
	register int c;
d477 1
a477 1
	register CLIENT *client;
d502 1
a502 1
	register struct hostent *hp;
d506 1
a506 1
	register CLIENT *client;
d572 1
a572 1
	register struct hostent *hp;
d677 1
a677 1
	register struct rpcent *rpc;
d720 1
a720 1
	register struct hostent *hp;
@


1.6
log
@silence a warning
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.5 2000/07/31 16:55:37 deraadt Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.5 2000/07/31 16:55:37 deraadt Exp $";
d54 3
a677 1
	register u_long prognum;
@


1.5
log
@modernize this source code including: avoiding atoi(), range checking,
KNF.  while at it, add a rpcinfo -s command for setting ports from userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.4 1997/01/15 23:43:08 millert Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.4 1997/01/15 23:43:08 millert Exp $";
d67 1
a67 1
bool_t	reply_proc(void *res, struct sockaddr_in *who);
d566 1
a566 1
	void *res;			/* Nothing comes back */
d594 1
a594 2
	    (char *)NULL, xdr_void, (char *)NULL,
	    reply_proc);
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.3 1996/06/29 01:07:33 deraadt Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.3 1996/06/29 01:07:33 deraadt Exp $";
d55 1
d63 12
a74 11
static void	udpping(/*u_short portflag, int argc, char **argv*/);
static void	tcpping(/*u_short portflag, int argc, char **argv*/);
static int	pstatus(/*CLIENT *client, u_long prognum, u_long vers*/);
static void	pmapdump(/*int argc, char **argv*/);
static bool_t	reply_proc(/*void *res, struct sockaddr_in *who*/);
static void	brdcst(/*int argc, char **argv*/);
static void	deletereg(/* int argc, char **argv */) ;
static void	usage(/*void*/);
static u_long	getprognum(/*char *arg*/);
static u_long	getvers(/*char *arg*/);
static void	get_inet_address(/*struct sockaddr_in *addr, char *host*/);
d85 1
d98 1
d103 1
a103 1
	while ((c = getopt(argc, argv, "ptubdn:")) != -1) {
d135 5
a139 1
			portnum = (u_short) atoi(optarg);   /* hope we don't get bogus # */
d149 8
d162 2
a163 4
	if (errflg || function == NONE) {
		usage();
		return (1);
	}
d168 2
a169 4
		if (portnum != 0) {
			usage();
			return (1);
		}
d182 3
a184 4
		if (portnum != 0) {
			usage();
			return (1);
		}
d191 4
d200 1
a200 1
static void
d215 7
a221 5
	if (argc < 2 || argc > 3) {
		usage();
		exit(1);
	}
	prognum = getprognum(argv[1]);
d315 2
a316 3
	}
	else {
		vers = getvers(argv[2]);
d339 1
a339 1
static void
d354 7
a360 5
	if (argc < 2 || argc > 3) {
		usage();
		exit(1);
	}
	prognum = getprognum(argv[1]);
d444 2
a445 3
	}
	else {
		vers = getvers(argv[2]);
d472 1
a472 1
static int
d493 1
a493 1
static void
d506 3
a508 4
	if (argc > 1) {
		usage();
		exit(1);
	}
a562 1

d564 1
a564 1
static bool_t
d566 2
a567 2
	void *res;		/* Nothing comes back */
	struct sockaddr_in *who; /* Who sent us the reply */
d578 1
a578 1
static void
d584 1
a584 1
	u_long prognum, vers;
d586 10
a595 8
	if (argc != 2) {
		usage();
		exit(1);
	}
	prognum = getprognum(argv[0]);
	vers = getvers(argv[1]);
	rpc_stat = clnt_broadcast(prognum, vers, NULLPROC, xdr_void,
	    (char *)NULL, xdr_void, (char *)NULL, reply_proc);
d604 1
a604 1
static void
d608 9
a616 1
{	u_long prog_num, version_num ;
d618 5
a622 3
	if (argc != 2) {
		usage() ;
		exit(1) ;
d624 26
a649 6
	prog_num = getprognum(argv[0]);
	version_num = getvers(argv[1]);
	if ((pmap_unset(prog_num, version_num)) == 0) {
		fprintf(stderr, "rpcinfo: Could not delete registration for prog %s version %s\n",
			argv[0], argv[1]) ;
		exit(1) ;
d653 2
a654 2
static void
usage()
d656 7
a662 2
	fprintf(stderr, "Usage: rpcinfo [ -n portnum ] -u host prognum [ versnum ]\n");
	fprintf(stderr, "       rpcinfo [ -n portnum ] -t host prognum [ versnum ]\n");
d665 3
a667 1
	fprintf(stderr, "       rpcinfo -d prognum versnum\n") ;
d670 2
a671 2
static u_long
getprognum(arg)
d673 1
d685 2
a686 3
		prognum = rpc->r_number;
	} else {
		prognum = (u_long) atoi(arg);
d688 1
a688 2

	return (prognum);
d691 2
a692 2
static u_long
getvers(arg)
d694 1
d696 16
a711 4
	register u_long vers;

	vers = (int) atoi(arg);
	return (vers);
d714 1
a714 1
static void
d724 2
a725 1
			fprintf(stderr, "rpcinfo: %s is unknown host\n", host);
@


1.3
log
@bindresvport if possible; uid 0 check is ridiculous crap
@
text
@d1 1
a1 1
/*	$OpenBSD: rpcinfo.c,v 1.2 1996/06/26 05:38:45 deraadt Exp $	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.2 1996/06/26 05:38:45 deraadt Exp $";
d99 1
a99 1
	while ((c = getopt(argc, argv, "ptubdn:")) != EOF) {
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
a6 1
static char rcsid[] = "$OpenBSD: rpcinfo.c,v 1.1.1.1 1995/10/18 08:46:02 deraadt Exp $";
d207 1
a207 1
	sock = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP);
d212 2
a594 4
		exit(1) ;
	}
	if (getuid()) { /* This command allowed only to root */
		fprintf(stderr, "Sorry. You are not root\n") ;
@


1.1
log
@Initial revision
@
text
@d1 2
d6 1
a6 1
static char rcsid[] = "$Id: rpcinfo.c,v 1.4 1995/05/21 14:46:39 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
