head	1.8;
access;
symbols
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.14
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.12
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.8
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.10
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	PMDB:1.1.1.1
	PMBD_4_1:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.08.30.15.53.47;	author kettenis;	state dead;
branches;
next	1.7;

1.7
date	2011.07.08.23.42.27;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.02.15.19.33;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.31.08.47.31;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.09.02.23.48;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.12.00.24.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.15.16.41.06;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.15.16.30.32;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.03.15.16.30.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Move pmdb to the attic.

It's unfinished.  It will never be finished.
It's unfinishable.  deraadt@@
@
text
@/*	$OpenBSD: clit.c,v 1.7 2011/07/08 23:42:27 nicm Exp $	*/
/*
 * Copyright (c) 2002 Artur Grabowski <art@@openbsd.org>
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

#include <stdlib.h>
#include <stdio.h>
#include <histedit.h>
#include <err.h>
#include <string.h>

#include "clit.h"

extern char *__progname;

char *prompt_add;

static char *
prompt(EditLine *el)
{
	static char p[64];

	snprintf(p, sizeof(p), "%s%s> ", __progname,
	    prompt_add ? prompt_add : "");

	return p;
}

/*
 * Returns number of commands that (at least partially) match "name".
 */
static int
name_to_cmd(const char *name, struct clit *cmds, int ncmds, struct clit **res)
{
	int i, len, ret;

	len = strlen(name);
	ret = 0;

	for (i = 0; i < ncmds; i++) {
		if (strncmp(cmds[i].cmd, name, len) == 0) {
			*res = &cmds[i];
			ret++;
		}
	}

	return ret;	
}

struct clitenv {
	struct clit *cmds;
	int ncmds;
	EditLine *el;
	History *hist;
};

int
cmd_help(int argc, char **argv, void *arg)
{
	struct clitenv *env = arg;
	struct clit *cmds = env->cmds, *cmdp;
	int ncmds = env->ncmds;
	int i, res;

	if (argc > 1) {
		res = name_to_cmd(argv[1], cmds, ncmds, &cmdp);
		if (res == 1) {
			printf("%s\t%s\n", cmdp->cmd, cmdp->help);
		} else {
			fprintf(stderr, "%s command: %s\n",
			    res == 0 ? "unknown" : "ambiguous", argv[1]);
		}

		return 0;
	}
	for (i = 0; i < ncmds; i++) {
		cmdp = &cmds[i];

		printf("%s\t%s\n", cmdp->cmd, cmdp->help);
	}

	return 0;
}

/*
 * XXX - there is no way to push external args into this function.
 */
unsigned char
complt(EditLine *el, int ch)
{
	const LineInfo *line;
	char str[1024];
	int len, ret;

	line = el_line(el);
	if (line->cursor != line->lastchar)
		return CC_ERROR;

	len = line->lastchar - line->buffer;

	if (len >= 1023)
		return CC_ERROR;

	memcpy(str, line->buffer, len);
	str[len] = '\0';

	ret = cmd_complt(str, sizeof(str));

	el_push(el, &str[len]);

	return ret ? CC_ERROR : CC_REDISPLAY;
}

void *
cmdinit(struct clit *cmds, int ncmds)
{
	struct clitenv *env;
	HistEvent ev;

	if ((env = malloc(sizeof(*env))) == NULL)
		err(1, "Can't init cmd interpreter.");

	env->cmds = cmds;
	env->ncmds = ncmds;

	env->hist = history_init();
	history(env->hist, &ev, H_SETSIZE, 100);

	env->el = el_init(__progname, stdin, stdout, stderr);

	el_set(env->el, EL_EDITOR, "emacs");
	el_set(env->el, EL_PROMPT, prompt);
	el_set(env->el, EL_HIST, history, env->hist);
	el_set(env->el, EL_ADDFN, "complt", "complete", complt);
	el_set(env->el, EL_BIND, "\t", "complt", NULL);
	el_source(env->el, NULL);

	/* XXX - EL_SIGNAL ? */

	return env;
}

void
cmdend(void *arg)
{
	struct clitenv *env = arg;

	el_end(env->el);
	history_end(env->hist);

	free(env);
}

int
cmdloop(void *arg)
{
	struct clitenv *env = arg;
	EditLine *el = env->el;
	History *hist = env->hist;
	const char *elline;
	int cnt;
	char **argv;
	int maxargs = 16;	/* XXX */
	int stop;

	stop = 0;

	if ((argv = calloc(sizeof(char *), maxargs)) == NULL)
		err(1, "malloc");

	while (!stop && (elline = el_gets(el, &cnt)) != NULL) {
		char *line, *orgline;
		struct clit *cmdp;
		char **ap;
		int argc, res;
		HistEvent ev;

		memset(argv, 0, sizeof(char *) * maxargs);

		history(hist, &ev, H_ENTER, elline);

		orgline = line = strdup(elline);
		if (line == NULL)
			err(1, "strdup");

		argc = 0;
		for (ap = argv; (*ap = strsep(&line, " \t\n")) != NULL;) {
			if (**ap != '\0') {
				++ap;
				if (++argc == maxargs)
					break;
			}
		}
		if (argc == maxargs) {
			fprintf(stderr, "Too many arguments\n");
			goto cmdout;
		}
		if (!argc)
			goto cmdout;

		/*
		 * Editline commands.
		 */
		if (el_parse(el, argc, (const char **)argv) != -1)
			goto cmdout;

		if ((res = name_to_cmd(argv[0], env->cmds, env->ncmds,
		    &cmdp)) == 1) {
			if (argc - 1 > cmdp->maxargc)
				fprintf(stderr, "Too many arguments\n");
			else if (argc - 1 < cmdp->minargc)
				fprintf(stderr, "Too few arguments\n");
			else
				stop = (*cmdp->handler)(argc, argv,
				    cmdp->arg ? cmdp->arg : env);
		} else {
			fprintf(stderr, "%s command: %s\n",
			    res == 0 ? "unknown" : "ambiguous", argv[0]);
		}
cmdout:
		free(orgline);
	}
	free(argv);

	return stop;
}

@


1.7
log
@el_set(EL_BIND) requires a NULL marker as the last argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: clit.c,v 1.6 2007/09/02 15:19:33 deraadt Exp $	*/
@


1.6
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: clit.c,v 1.5 2003/10/31 08:47:31 otto Exp $	*/
d156 1
a156 1
	el_set(env->el, EL_BIND, "\t", "complt");
@


1.5
log
@New libedit api changes.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clit.c,v 1.4 2002/08/09 02:23:48 aaron Exp $	*/
d189 1
a189 1
	if ((argv = malloc(sizeof(char *) * maxargs)) == NULL)
@


1.4
log
@Correct the size arg to memset() so argv will be cleared correctly; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: clit.c,v 1.3 2002/07/12 00:24:53 deraadt Exp $	*/
a138 1
#ifdef __NetBSD__
a139 1
#endif
a147 1
#ifdef __NetBSD__
a148 3
#else
	history(env->hist, H_EVENT, 100);
#endif
a149 1
#ifdef __NetBSD__
d151 1
a151 3
#else
	env->el = el_init(__progname, stdin, stdout);
#endif
a196 1
#ifdef __NetBSD__
a197 1
#endif
a200 1
#ifdef __NetBSD__
a201 3
#else
		history(hist, H_ENTER, elline);
#endif
d225 1
a225 1
		if (el_parse(el, argc, argv) != -1)
@


1.3
log
@malloc/strdup failure not handled; cloder@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: clit.c,v 1.2 2002/03/15 16:41:06 jason Exp $	*/
d210 1
a210 1
		memset(argv, 0, sizeof(argv));
@


1.2
log
@s/$PMDB$/$OpenBSD$/
@
text
@d1 1
a1 1
/*	$OpenBSD: clit.c,v 1.11 2002/03/07 13:57:28 art Exp $	*/
d219 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$PMDB: clit.c,v 1.11 2002/03/07 13:57:28 art Exp $	*/
@


1.1.1.1
log
@Import pmdb 4.1.

(see http://www.blahonga.org/~art/openbsd/pmdb.html for more info).

The development repository now moves here out from my local repository.
@
text
@@
