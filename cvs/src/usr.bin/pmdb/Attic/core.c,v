head	1.9;
access;
symbols
	OPENBSD_5_2:1.8.0.22
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.20
	OPENBSD_5_0:1.8.0.18
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.16
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.14
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.10
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.12
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.8
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.6
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2012.08.30.15.53.47;	author kettenis;	state dead;
branches;
next	1.8;

1.8
date	2007.08.01.15.44.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.01.15.43.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.17.23.43.45;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.29.00.01.46;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.28.23.33.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.22.02.55.54;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.22.01.20.50;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.05.18.02.27;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Move pmdb to the attic.

It's unfinished.  It will never be finished.
It's unfinishable.  deraadt@@
@
text
@/*	$OpenBSD: core.c,v 1.8 2007/08/01 15:44:37 deraadt Exp $	*/
/*
 * Copyright (c) 2002 Jean-Francois Brousseau <krapht@@secureops.com>
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/mman.h>

#include <err.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

#include "core.h"
#include "pmdb.h"
#include "symbol.h"

int
read_core(const char *path, struct pstate *ps)
{
	struct corefile *cf;
	void *core_map;
	off_t c_off;
	int i, cfd;

	cf = (struct corefile *)malloc(sizeof(*cf));
	if (cf == NULL)
		err(1, "malloc");

	cfd = open(path, O_RDONLY, 0600);
	if (cfd < 0)
		err(1, "open() failed on core file");

	if (fstat(cfd, &(cf->cfstat)) < 0)
		err(1, "fstat() failed on core");

	if (cf->cfstat.st_mtimespec.tv_sec < ps->exec_stat.st_mtimespec.tv_sec)
		warnx("executable is more recent than core file!");

	core_map = mmap(NULL, cf->cfstat.st_size, PROT_READ, MAP_PRIVATE,
	    cfd, 0);
	if (core_map == MAP_FAILED)
		err(1, "mmap() failed on core");
	close(cfd);

	cf->chdr = (struct core *)core_map;
	c_off = cf->chdr->c_hdrsize;
	if (CORE_GETMAGIC(*(cf->chdr)) != COREMAGIC)
		errx(1, "hey, that's not a core file");

	printf("Core file generated from '%s' by signal %d (SIG%s)\n",
	    cf->chdr->c_name, cf->chdr->c_signo,
	    sys_signame[cf->chdr->c_signo]);

#ifdef DEBUG
	printf("Core: text=0x%lx, data=0x%lx, stack=0x%lx\n",
	    cf->chdr->c_tsize, cf->chdr->c_dsize, cf->chdr->c_ssize);
#endif

	cf->segs = (struct coreseg **)calloc(cf->chdr->c_nseg,
	    sizeof(cf->segs));
	if (cf->segs == NULL)
		err(1, "calloc");

	for (i = 0; i < cf->chdr->c_nseg; i++) {
		cf->segs[i] = (struct coreseg *)(core_map + c_off);
		if (CORE_GETMAGIC(*(cf->segs[i])) != CORESEGMAGIC)
			errx(1, "invalid segment hdr for segment %d", i);

		if (CORE_GETFLAG(*(cf->segs[i])) & CORE_CPU) {
			cf->regs = (struct reg *)
			    ((long) cf->segs[i] + cf->chdr->c_seghdrsize);
		}

		if (CORE_GETFLAG(*(cf->segs[i])) & CORE_STACK)
			cf->c_stack = cf->segs[i] + cf->chdr->c_seghdrsize;

		c_off += cf->chdr->c_seghdrsize + cf->segs[i]->c_size;

#ifdef DEBUG
		(void)printf("seg[%d]: midmag=0x%lx  addr=0x%lx  size=0x%lx\n",
		    i, cf->segs[i]->c_midmag, cf->segs[i]->c_addr,
		    cf->segs[i]->c_size);
#endif
	}

	cf->path = (char *)path;
	ps->ps_flags |= PSF_CORE;
	ps->ps_core = cf;

	return (0);
}

void
free_core(struct pstate *ps)
{
	struct corefile *cf = ps->ps_core;

	if (cf == NULL)
		return;

	if (cf->segs != NULL) {
		free(cf->segs);
		cf->segs = NULL;
	}

	if (cf->chdr != NULL) {
		munmap(cf->chdr, cf->cfstat.st_size);
		cf->chdr = NULL;
	}

}

void
core_printregs(struct pstate *ps)
{
	struct corefile *cf = ps->ps_core;
	reg *rg;
	char buf[256];
	int i;

	rg = (reg *)cf->regs;
	for (i = 0; i < md_def.nregs; i++)
		printf("%s:\t0x%.*lx\t%s\n", md_def.md_reg_names[i],
		    (int)(sizeof(reg) * 2), (long) rg[i],
		    sym_print(ps, rg[i], buf, sizeof(buf)));
}


ssize_t
core_read(struct pstate *ps, off_t from, void *to, size_t size)
{
	struct coreseg *cs;
	size_t read;
	void *fp;
	int i;

	for (i = 0; i < ps->ps_core->chdr->c_nseg; i++) {
		cs = ps->ps_core->segs[i];
		if ((from >= cs->c_addr) &&
		    (from < (cs->c_addr + cs->c_size))) {
			read = size;
			if ((from + size) > (cs->c_addr + cs->c_size))
				read = (cs->c_addr + cs->c_size) - from;
			fp = (void *)cs + sizeof(*cs) +
			    ((u_long)from - cs->c_addr);
			memcpy(to, fp, read);
			return (read);
		}
	}

	return (-1);
}


ssize_t
core_write(struct pstate *ps, off_t to, void *from, size_t size)
{
	struct coreseg *cs;
	size_t written;
	void *fp;
	int i;

	for (i = 0; i < ps->ps_core->chdr->c_nseg; i++) {
		cs = ps->ps_core->segs[i];
		if ((to > cs->c_addr) && (to < (cs->c_addr + cs->c_size))) {
			written = size;
			fp = (void *)cs + sizeof(*cs) + (to - cs->c_addr);
			memcpy(fp, from, written);
			return (written);
		}
	}

	return (-1);
}
@


1.8
log
@in (unused function) free_core(), unmap the core; from veins@@evilkittens.org
@
text
@d1 1
a1 1
/*	$OpenBSD: core.c,v 1.7 2007/08/01 15:43:56 deraadt Exp $	*/
@


1.7
log
@close core file fd after mmap; veins@@evilkittens.org
@
text
@d1 1
a1 1
/*	$OpenBSD: core.c,v 1.6 2003/08/17 23:43:45 mickey Exp $	*/
d131 6
@


1.6
log
@fix ptr arythmetics in core_write(); from aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: core.c,v 1.5 2003/03/29 00:01:46 mickey Exp $	*/
d69 1
@


1.5
log
@implement short reads at the end of the core segement
@
text
@d1 1
a1 1
/*	$OpenBSD: core.c,v 1.4 2003/03/28 23:33:27 mickey Exp $	*/
d186 1
a186 1
			fp = cs + sizeof(*cs) + (to - cs->c_addr);
@


1.4
log
@do not core dump on stripped executables. revmap the registers printed to the symbols even for cores (already happens for live executables); art@@ said it should wait until after the release and so it is already after the release now
@
text
@d1 1
a1 1
/*	$OpenBSD: core.c,v 1.3 2002/07/22 02:55:54 art Exp $	*/
d158 2
a159 1
		if ((from >= cs->c_addr) && (from < (cs->c_addr + cs->c_size))) {
d161 4
a164 1
			fp = cs + sizeof(*cs) + ((u_long)from - cs->c_addr);
@


1.3
log
@Map the core file with MAP_PRIVATE.
Some other random cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: core.c,v 1.2 2002/07/22 01:20:50 art Exp $	*/
d41 1
d133 1
a133 1
core_printregs(struct corefile *cf)
d135 1
d137 1
d142 3
a144 2
		printf("%s:\t0x%.*lx\n", md_def.md_reg_names[i],
		    (int)(sizeof(reg) * 2), (long) rg[i]);
@


1.2
log
@Support for reading from core files.
From Jean-Francois Brousseau <krapht@@secureops.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: core.c,v 1.1 2002/06/05 18:02:27 fgsch Exp $	*/
d64 1
a64 1
	core_map = mmap(NULL, cf->cfstat.st_size, PROT_READ, MAP_SHARED,
d147 1
a147 1
	int i;
d150 1
a150 1
	struct coreseg *cs;
d156 1
a156 1
			fp = cs + sizeof(*cs) + (from - cs->c_addr);
d158 1
a158 1
			return read;
d169 1
a169 1
	int i;
d172 1
a172 1
	struct coreseg *cs;
d180 1
a180 1
			return written;
@


1.1
log
@core support from Jean-Francois Brousseau <krapht@@secureops.com> with
a few tweaks of mine. tested on sparc64 and i386.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 44
@

