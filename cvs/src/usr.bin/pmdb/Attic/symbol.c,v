head	1.8;
access;
symbols
	OPENBSD_5_2:1.7.0.38
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.36
	OPENBSD_5_0:1.7.0.34
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.32
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.30
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.26
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	PMDB:1.1.1.1
	PMBD_4_1:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.08.30.15.53.47;	author kettenis;	state dead;
branches;
next	1.7;

1.7
date	2003.03.28.23.33.27;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.24.14.06.27;	author vincent;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.16.01.12.47;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.15.18.04.41;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.15.17.49.51;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.15.16.41.06;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.15.16.30.32;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.03.15.16.30.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Move pmdb to the attic.

It's unfinished.  It will never be finished.
It's unfinishable.  deraadt@@
@
text
@/*	$OpenBSD: symbol.c,v 1.7 2003/03/28 23:33:27 mickey Exp $	*/
/*
 * Copyright (c) 2002 Artur Grabowski <art@@openbsd.org>
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <err.h>
#include <errno.h>

#include "pmdb.h"
#include "symbol.h"

/*
 * Initialize the executable and the symbol table.
 */
void
sym_init_exec(struct pstate *ps, const char *name)
{
	ps->ps_sops = NULL;
	ps->ps_sym_exe = NULL;
	TAILQ_INIT(&ps->ps_syms);

#ifdef PMDB_ELF
	if (sym_check_elf(name, ps))
#endif
#ifdef PMDB_AOUT
	if (sym_check_aout(name, ps))
#endif
		warnx("sym_init_exec: %s is not a supported file format", name);

	if (ps->ps_sops) {
		/* XXX - this 0 doesn't have to be correct.. */
		ps->ps_sym_exe = st_open(ps, name, 0);
		if (ps->ps_sym_exe)
			ps->ps_sym_exe->st_flags |= ST_EXEC;
	}
}

/*
 * Destroy all symbol tables.
 */
void
sym_destroy(struct pstate *ps)
{
	struct sym_table *st;

	if (!(ps->ps_flags & PSF_SYMBOLS))
		return;
	while ((st = TAILQ_FIRST(&ps->ps_syms)) != NULL) {
		TAILQ_REMOVE(&ps->ps_syms, st, st_list);
		(*ps->ps_sops->sop_close)(st);
	}
	ps->ps_sym_exe = NULL;
}

/*
 * We have reasons to believe that the symbol tables we have are not consistent
 * with the running binary. Update.
 */
void
sym_update(struct pstate *ps)
{
	(*ps->ps_sops->sop_update)(ps);
}

char *
sym_name_and_offset(struct pstate *ps, reg pc, char *nam, size_t len, reg *off)
{
	struct sym_table *st;
	int bestoffisset = 0;
	reg bestoff, noff;
	char *res;

	TAILQ_FOREACH(st, &ps->ps_syms, st_list) {
		res = (*ps->ps_sops->sop_name_and_off)(st, pc, &noff);
		if (res == NULL)
			continue;
		if (noff < bestoff || !bestoffisset) {
			bestoffisset = 1;
			bestoff = noff;
			strlcpy(nam, res, len);
		}
	}

	if (!bestoffisset || !strcmp(nam, "_end"))
		return (NULL);

	*off = bestoff;
	return (nam);
}

int
sym_lookup(struct pstate *ps, const char *name, reg *res)
{
	/*
	 * We let the sop do the table walking itself since it might have
	 * preferences about what symbols to pick (weak and stuff).
	 */
	return ((*ps->ps_sops->sop_lookup)(ps, name, res));
}

char *
sym_print(struct pstate *ps, reg pc, char *buf, size_t buflen)
{
	char namebuf[1024], *name;
	reg offs;

	name = sym_name_and_offset(ps, pc, namebuf, sizeof(namebuf), &offs);
	if (name == NULL) {
		snprintf(buf, buflen, "0x%lx", pc);
	} else {
		if (offs)
			snprintf(buf, buflen, "%s+0x%lx(0x%lx)",
			    name, offs, pc);
		else
			snprintf(buf, buflen, "%s(0x%lx)", name, pc);
	}

	return (buf);
}

/*
 * Open a symbol table and install it in the list. Don't do anything if
 * it's already there.
 */
struct sym_table *
st_open(struct pstate *ps, const char *name, reg offs)
{
	struct sym_table *st;

	TAILQ_FOREACH(st, &ps->ps_syms, st_list) {
		if (!strcmp(name, st->st_fname) && (st->st_offs == offs))
			return (st);
	}

	warnx("Loading symbols from %s at 0x%lx", name, offs);

	if ((st = (*ps->ps_sops->sop_open)(name)) != NULL) {
		TAILQ_INSERT_TAIL(&ps->ps_syms, st, st_list);
		strlcpy(st->st_fname, name, sizeof(st->st_fname));
		st->st_offs = offs;
	}

	return (st);
}

/*
 * Load a symbol table from file argv[1] at offset argv[2].
 */
int
cmd_sym_load(int argc, char **argv, void *arg)
{
	struct pstate *ps = arg;
	char *fname, *ep;
	reg offs;

	fname = argv[1];
	errno = 0;
	offs = strtol(argv[2], &ep, 0);
	if (argv[2][0] == '\0' || *ep != '\0' || errno == ERANGE) {
		fprintf(stderr, "%s is not a valid offset\n", argv[2]);
		return (0);
	}

	if (st_open(ps, fname, offs) == NULL) {
		warnx("symbol loading failed");
	}

	return (0);
}
@


1.7
log
@do not core dump on stripped executables. revmap the registers printed to the symbols even for cores (already happens for live executables); art@@ said it should wait until after the release and so it is already after the release now
@
text
@d1 1
a1 1
/*	$OpenBSD: symbol.c,v 1.6 2002/07/24 14:06:27 vincent Exp $	*/
@


1.6
log
@don't use the TAILQ before it is initialised.  makes pmdb not crash on
exit if called with an non{existent,executable} file.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: symbol.c,v 1.5 2002/03/16 01:12:47 art Exp $	*/
d135 5
a139 1
		snprintf(buf, buflen, "%s+0x%lx(0x%lx)", name, offs, pc);
@


1.5
log
@Don't set st->st_offs when st is NULL.
Noted by Gregory Steuck <greg@@nest.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: symbol.c,v 1.4 2002/03/15 18:04:41 art Exp $	*/
d70 2
@


1.4
log
@Add a command 'sym_load' to load a symbol table at some offset.
We are in a desperate need of a better command line interface, the top level
is starting to get crowded.
@
text
@d1 1
a1 1
/*	$OpenBSD: symbol.c,v 1.3 2002/03/15 17:49:51 art Exp $	*/
d158 1
a159 2

	st->st_offs = offs;
@


1.3
log
@Move the linking offset from the symbol format dependent structs
to struct sym_table.
Allow callers to specify linking offset to st_open.
@
text
@d1 1
a1 1
/*	$OpenBSD: symbol.c,v 1.2 2002/03/15 16:41:06 jason Exp $	*/
d31 1
d153 1
a153 1
	warnx("Loading symbols from %s", name);
d165 24
@


1.2
log
@s/$PMDB$/$OpenBSD$/
@
text
@d1 1
a1 1
/*	$OpenBSD: symbol.c,v 1.5 2002/03/07 14:27:08 art Exp $	*/
d54 2
a55 1
		ps->ps_sym_exe = st_open(ps, name);
d143 1
a143 1
st_open(struct pstate *ps, const char *name)
d148 1
a148 1
		if (!strcmp(name, st->st_fname))
d158 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$PMDB: symbol.c,v 1.5 2002/03/07 14:27:08 art Exp $	*/
@


1.1.1.1
log
@Import pmdb 4.1.

(see http://www.blahonga.org/~art/openbsd/pmdb.html for more info).

The development repository now moves here out from my local repository.
@
text
@@
