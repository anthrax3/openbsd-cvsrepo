head	1.31;
access;
symbols
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.14
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.12
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.10
	OPENBSD_5_0:1.24.0.8
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.10
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.8
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.6
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.8
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2017.03.20.16.10.10;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	JQgzLeiSGen74JMS;

1.30
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	0Dp7Dy9FuNZesYo2;

1.29
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.27;
commitid	9QOFSShUOtA0kQLF;

1.27
date	2014.10.08.04.08.13;	author doug;	state Exp;
branches;
next	1.26;
commitid	lx7QcAL9U0sqOhIo;

1.26
date	2013.11.17.20.19.36;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.03.04.12.23;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.09.19.41.56;	author sobrado;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.17.19.55.05;	author moritz;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.17.19.31.54;	author moritz;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.12.05.25.06;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.07.17.18.44;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.04.17.06.45;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.10.22.20.50;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.27.03.14.07;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.02.18.06.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.18.22.19.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.18.22.18.02;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.08.16.23.48.57;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	99.02.09.13.32.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.08.08.20.25.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.09.04.05.07;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.20.10.05.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.01.07.18.28;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.12.10.19.00.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.04.23.43.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.16.09.10.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@recallocarray array that has remote data
@
text
@/*	$OpenBSD: rup.c,v 1.30 2015/08/20 22:32:41 deraadt Exp $	*/

/*-
 * Copyright (c) 1993, John Brezak
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <netdb.h>
#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#include <arpa/inet.h>
#include <err.h>
#include <unistd.h>

#undef FSHIFT			/* Use protocol's shift and scale values */
#undef FSCALE
#include <rpcsvc/rstat.h>

#define HOST_WIDTH 27

int printtime;			/* print the remote host(s)'s time */

struct host_list {
	struct host_list *next;
	struct in_addr addr;
} *hosts;

void usage(void);
int print_rup_data(char *, statstime *host_stat);

static int
search_host(struct in_addr addr)
{
	struct host_list *hp;

	if (!hosts)
		return(0);

	for (hp = hosts; hp != NULL; hp = hp->next) {
		if (hp->addr.s_addr == addr.s_addr)
			return(1);
	}
	return(0);
}

static void
remember_host(struct in_addr addr)
{
	struct host_list *hp;

	if (!(hp = malloc(sizeof(struct host_list)))) {
		err(1, NULL);
		/* NOTREACHED */
	}
	hp->addr.s_addr = addr.s_addr;
	hp->next = hosts;
	hosts = hp;
}


struct rup_data {
	char *host;
	struct statstime statstime;
};
struct rup_data *rup_data;
int rup_data_idx = 0;
int rup_data_max = 0;

enum sort_type {
	SORT_NONE,
	SORT_HOST,
	SORT_LDAV,
	SORT_UPTIME
};
enum sort_type sort_type;

static int
compare(const void *v1, const void *v2)
{
	const struct rup_data *d1 = v1;
	const struct rup_data *d2 = v2;

	switch(sort_type) {
	case SORT_HOST:
		return strcmp(d1->host, d2->host);
	case SORT_LDAV:
		return d1->statstime.avenrun[0]
			- d2->statstime.avenrun[0];
	case SORT_UPTIME:
		return d1->statstime.boottime.tv_sec
			- d2->statstime.boottime.tv_sec;
	default:
		/* something's really wrong here */
		abort();
	}
}

static void
remember_rup_data(char *host, struct statstime *st)
{
	if (rup_data_idx >= rup_data_max) {
		int newsize;
		struct rup_data *newrup;

		newsize = rup_data_max + 16;
		newrup = recallocarray(rup_data, rup_data_max, newsize,
		    sizeof(struct rup_data));
		if (newrup == NULL) {
			err(1, NULL);
			/* NOTREACHED */
		}
		rup_data = newrup;
		rup_data_max = newsize;
	}

	if ((rup_data[rup_data_idx].host = strdup(host)) == NULL)
		err(1, NULL);
	rup_data[rup_data_idx].statstime = *st;
	rup_data_idx++;
}


static int
rstat_reply(char *replyp, struct sockaddr_in *raddrp)
{
	struct hostent *hp;
	char *host;
	statstime *host_stat = (statstime *)replyp;

	if (!search_host(raddrp->sin_addr)) {
		hp = gethostbyaddr((char *)&raddrp->sin_addr.s_addr,
		    sizeof(struct in_addr), AF_INET);
		if (hp)
			host = hp->h_name;
		else
			host = inet_ntoa(raddrp->sin_addr);

		remember_host(raddrp->sin_addr);

		if (sort_type != SORT_NONE)
			remember_rup_data(host, host_stat);
		else
			print_rup_data(host, host_stat);
	}

	return (0);
}


int
print_rup_data(char *host, statstime *host_stat)
{
	unsigned int ups = 0, upm = 0, uph = 0, upd = 0;
	struct tm *tmp_time, host_time;
	char days_buf[16], hours_buf[16];
	time_t tim;

	if (printtime)
		printf("%-*.*s", HOST_WIDTH-8, HOST_WIDTH-8, host);
	else
		printf("%-*.*s", HOST_WIDTH, HOST_WIDTH, host);

	tim = host_stat->curtime.tv_sec;
	tmp_time = localtime(&tim);
	host_time = *tmp_time;

	host_stat->curtime.tv_sec -= host_stat->boottime.tv_sec;

	if (host_stat->curtime.tv_sec > 0)
		ups = host_stat->curtime.tv_sec;
	upd = ups / (3600 * 24);
	ups -= upd * 3600 * 24;
	uph = ups / 3600;
	ups -= uph * 3600;
	upm = ups / 60;

	if (upd != 0)
		snprintf(days_buf, sizeof days_buf, "%3u day%s, ", upd,
		    (upd > 1) ? "s" : "");
	else
		days_buf[0] = '\0';

	if (uph != 0)
		snprintf(hours_buf, sizeof hours_buf, "%2u:%02u, ",
		    uph, upm);
	else
		if (upm != 0)
			snprintf(hours_buf, sizeof hours_buf, "%2u min%s ",
			    upm, (upm == 1) ? ", " : "s,");
		else
			hours_buf[0] = '\0';

	if (printtime)
		printf(" %2d:%02d%cm",
		    (host_time.tm_hour % 12) ? (host_time.tm_hour % 12) : 12,
		    host_time.tm_min,
		    (host_time.tm_hour >= 12) ? 'p' : 'a');

	printf(" up %9.9s%9.9s load average: %.2f %.2f %.2f\n",
	    days_buf, hours_buf,
	    (double)host_stat->avenrun[0] / FSCALE,
	    (double)host_stat->avenrun[1] / FSCALE,
	    (double)host_stat->avenrun[2] / FSCALE);

	return(0);
}


static void
onehost(char *host)
{
	CLIENT *rstat_clnt;
	statstime host_stat;
	static struct timeval timeout = {25, 0};
	extern char *__progname;

	rstat_clnt = clnt_create(host, RSTATPROG, RSTATVERS_TIME, "udp");
	if (rstat_clnt == NULL) {
		fprintf(stderr, "%s: %s", __progname,
		    clnt_spcreateerror(host));
		return;
	}

	bzero((char *)&host_stat, sizeof(host_stat));
	if (clnt_call(rstat_clnt, RSTATPROC_STATS, xdr_void, NULL,
	    xdr_statstime, &host_stat, timeout) != RPC_SUCCESS) {
		fprintf(stderr, "%s: %s", __progname,
		    clnt_sperror(rstat_clnt, host));
		clnt_destroy(rstat_clnt);
		return;
	}

	if (sort_type != SORT_NONE)
		remember_rup_data(host, &host_stat);
	else
		print_rup_data(host, &host_stat);

	clnt_destroy(rstat_clnt);
}

static void
allhosts(void)
{
	statstime host_stat;
	enum clnt_stat clnt_stat;
	extern char *__progname;

	if (sort_type != SORT_NONE) {
		printf("collecting responses...\n");
		fflush(stdout);
	}

	clnt_stat = clnt_broadcast(RSTATPROG, RSTATVERS_TIME, RSTATPROC_STATS,
	    xdr_void, NULL, xdr_statstime, (char *)&host_stat, rstat_reply);
	if (clnt_stat != RPC_SUCCESS && clnt_stat != RPC_TIMEDOUT) {
		fprintf(stderr, "%s: %s\n", __progname, clnt_sperrno(clnt_stat));
		exit(1);
	}
}

int
main(int argc, char *argv[])
{
	int ch;
	size_t i;
	extern int optind;

	sort_type = SORT_NONE;
	while ((ch = getopt(argc, argv, "dhlt")) != -1)
		switch (ch) {
		case 'd':
			printtime = 1;
			break;
		case 'h':
			sort_type = SORT_HOST;
			break;
		case 'l':
			sort_type = SORT_LDAV;
			break;
		case 't':
			sort_type = SORT_UPTIME;
			break;
		default:
			usage();
			/*NOTREACHED*/
		}

	setvbuf(stdout, NULL, _IOLBF, 0);

	if (argc == optind)
		allhosts();
	else {
		for (; optind < argc; optind++)
			onehost(argv[optind]);
	}

	if (sort_type != SORT_NONE) {
		qsort(rup_data, rup_data_idx, sizeof(struct rup_data),
		    compare);

		for (i = 0; i < rup_data_idx; i++) {
			print_rup_data(rup_data[i].host,
			    &rup_data[i].statstime);
		}
	}

	exit(0);
}


void
usage(void)
{
	fprintf(stderr, "usage: rup [-dhlt] [host ...]\n");
	exit(1);
}
@


1.30
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.29 2015/01/16 06:40:11 deraadt Exp $	*/
d134 1
a134 1
		newrup = reallocarray(rup_data, newsize,
@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.28 2014/11/26 18:34:51 millert Exp $	*/
d79 1
a79 1
	if (!(hp = (struct host_list *)malloc(sizeof(struct host_list)))) {
@


1.28
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.27 2014/10/08 04:08:13 doug Exp $	*/
a34 1
#include <sys/param.h>
@


1.27
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.26 2013/11/17 20:19:36 okan Exp $	*/
d317 1
a317 1
	setlinebuf(stdout);
@


1.26
log
@Include unistd.h as it is the standard location for getopt().

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.25 2013/04/03 04:12:23 deraadt Exp $	*/
d135 2
a136 1
		newrup = realloc(rup_data, newsize * sizeof(struct rup_data));
@


1.25
log
@do not assume time_t and timeval.tv_sec are the same type
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.24 2009/10/27 23:59:43 deraadt Exp $	*/
d42 1
@


1.24
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.23 2008/07/09 19:41:56 sobrado Exp $	*/
d183 1
d190 2
a191 1
	tmp_time = localtime((time_t *)&host_stat->curtime.tv_sec);
@


1.23
log
@documentation tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.22 2005/11/17 19:55:05 moritz Exp $	*/
a29 4

#ifndef lint
static char rcsid[] = "$OpenBSD: rup.c,v 1.22 2005/11/17 19:55:05 moritz Exp $";
#endif /* not lint */
@


1.22
log
@some knf and whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.21 2005/11/17 19:31:54 moritz Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.21 2005/11/17 19:31:54 moritz Exp $";
d343 1
a343 1
	fprintf(stderr, "Usage: rup [-dhlt] [hosts ...]\n");
@


1.21
log
@sort hosts, even when specified on the command line.
fixes pr 4614. from alexander.farber at gmail.com.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.20 2003/12/12 05:25:06 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.20 2003/12/12 05:25:06 deraadt Exp $";
d67 1
a67 1
	
d146 1
a146 1
	
d199 6
a204 6
		ups=host_stat->curtime.tv_sec;
	upd=ups/(3600*24);
	ups-=upd*3600*24;
	uph=ups/3600;
	ups-=uph*3600;
	upm=ups/60;
d230 3
a232 3
	    (double)host_stat->avenrun[0]/FSCALE,
	    (double)host_stat->avenrun[1]/FSCALE,
	    (double)host_stat->avenrun[2]/FSCALE);
d245 1
a245 1
	
d316 1
a316 1
	
@


1.20
log
@term 3 cleanup, ok from brezak
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.19 2003/10/07 17:18:44 tedu Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.19 2003/10/07 17:18:44 tedu Exp $";
d262 5
a266 1
	print_rup_data(host, &host_stat);
a275 1
	size_t i;
d278 1
a278 1
		printf("collecting responses...");
a287 11

	if (sort_type != SORT_NONE) {
		putchar('\n');
		qsort(rup_data, rup_data_idx, sizeof(struct rup_data),
		    compare);

		for (i = 0; i < rup_data_idx; i++) {
			print_rup_data(rup_data[i].host,
			    &rup_data[i].statstime);
		}
	}
d294 1
d324 10
@


1.19
log
@check strdup, from jared yanovich.  fix realloc while i'm here.
ok deraadt@@ henning@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.18 2003/08/04 17:06:45 deraadt Exp $	*/
d15 2
a16 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.18 2003/08/04 17:06:45 deraadt Exp $";
@


1.18
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.17 2003/06/10 22:20:50 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.17 2003/06/10 22:20:50 deraadt Exp $";
d139 6
a144 4
		rup_data_max += 16;
		rup_data = realloc(rup_data,
		    rup_data_max * sizeof(struct rup_data));
		if (rup_data == NULL) {
d148 2
d152 2
a153 1
	rup_data[rup_data_idx].host = strdup(host);
@


1.17
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.16 2002/05/27 03:14:07 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.16 2002/05/27 03:14:07 deraadt Exp $";
d68 1
a68 1
int
d83 1
a83 1
void
d114 1
a114 1
int
d135 1
a135 1
void
d154 1
a154 1
int
d238 1
a238 1
void
d266 1
a266 1
void
@


1.16
log
@snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.15 2002/02/16 21:27:52 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.15 2002/02/16 21:27:52 millert Exp $";
d69 1
a69 2
search_host(addr)
	struct in_addr addr;
d84 1
a84 2
remember_host(addr)
	struct in_addr addr;
a97 1

d106 1
a106 1
enum sort_type { 
d115 1
a115 3
compare(d1, d2)
	struct rup_data *d1;
	struct rup_data *d2;
d117 3
d127 1
a127 1
		return d1->statstime.boottime.tv_sec 
d136 1
a136 3
remember_rup_data(host, st)
	char *host;
	struct statstime *st;
d140 1
a140 1
		rup_data = realloc(rup_data, 
d155 1
a155 3
rstat_reply(replyp, raddrp)
	char *replyp;
	struct sockaddr_in *raddrp;
d182 1
a182 3
print_rup_data(host, host_stat)
	char *host;
	statstime *host_stat;
d239 1
a239 2
onehost(host)
	char *host;
d267 1
a267 1
allhosts()
d299 1
a299 3
main(argc, argv)
	int argc;
	char *argv[];
d338 1
a338 1
usage()
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.14 2001/10/02 18:06:47 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.14 2001/10/02 18:06:47 deraadt Exp $";
d192 3
a194 6
	struct tm *tmp_time;
	struct tm host_time;
	unsigned ups=0,upm=0,uph=0,upd=0;

	char days_buf[16];
	char hours_buf[16];
d215 2
a216 2
		sprintf(days_buf, "%3u day%s, ", upd,
			(upd > 1) ? "s" : "");
d221 2
a222 2
		sprintf(hours_buf, "%2u:%02u, ",
			uph, upm);
d225 2
a226 2
			sprintf(hours_buf, "%2u min%s ", upm,
			    (upm == 1) ? ", " : "s,");
@


1.14
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.13 2001/06/18 22:19:04 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.13 2001/06/18 22:19:04 deraadt Exp $";
d65 2
a66 2
void usage __P((void));
int print_rup_data __P((char *, statstime *host_stat));
@


1.13
log
@clnt leaks; tommy@@ti.com
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.12 2001/06/18 22:18:02 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.12 2001/06/18 22:18:02 millert Exp $";
d142 3
a144 3
        if (rup_data_idx >= rup_data_max) {
                rup_data_max += 16;
                rup_data = realloc (rup_data, 
d146 2
a147 2
                if (rup_data == NULL) {
                        err (1, NULL);
d149 2
a150 2
                }
        }
@


1.12
log
@Add sanity check for remote host boot time > current time for when
clocks go screwey.  Similar to patch from kstailey@@disclosure.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.11 1999/08/16 23:48:57 aaron Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.11 1999/08/16 23:48:57 aaron Exp $";
d270 1
@


1.11
log
@Consistify so "rup host" and "rup -d host" produce similarly formatted output.
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.10 1999/02/09 13:32:03 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.10 1999/02/09 13:32:03 deraadt Exp $";
d209 2
a210 1
	ups=host_stat->curtime.tv_sec;
@


1.10
log
@for 1 min up, report min instead of mins; abs@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.9 1998/08/08 20:25:14 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.9 1998/08/08 20:25:14 millert Exp $";
d56 1
a56 1
#define HOST_WIDTH 24
d200 1
a200 1
		printf("%-*.*s", HOST_WIDTH-3, HOST_WIDTH-3, host);
@


1.9
log
@Don't wrap on an 80 char wide screen in -d mode; Tim Rightnour <root@@polaris.garbled.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.8 1997/07/09 04:05:07 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.8 1997/07/09 04:05:07 deraadt Exp $";
d227 2
a228 1
			sprintf(hours_buf, "%2u mins, ", upm);
@


1.8
log
@\n after clnt_sperrno()
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.7 1997/06/20 10:05:56 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.7 1997/06/20 10:05:56 deraadt Exp $";
d199 4
a202 1
	printf("%-*.*s", HOST_WIDTH, HOST_WIDTH, host);
@


1.7
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.6 1997/02/01 07:18:28 tholo Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.6 1997/02/01 07:18:28 tholo Exp $";
d288 1
a288 1
		fprintf(stderr, "%s: %s", __progname, clnt_sperrno(clnt_stat));
@


1.6
log
@Better handling of long uptimes; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.5 1996/12/10 19:00:03 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.5 1996/12/10 19:00:03 deraadt Exp $";
d48 1
d65 3
d117 1
d286 1
a286 1
	    xdr_void, NULL, xdr_statstime, &host_stat, rstat_reply);
d304 1
a304 1

d345 1
@


1.5
log
@do not use warnx, blank lines suck
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.4 1996/09/04 23:43:57 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.4 1996/09/04 23:43:57 deraadt Exp $";
d189 2
a190 1
	struct tm host_uptime;
d201 10
a210 6
	tmp_time = gmtime((time_t *)&host_stat->curtime.tv_sec);
	host_uptime = *tmp_time;

	if (host_uptime.tm_yday != 0)
		sprintf(days_buf, "%3d day%s, ", host_uptime.tm_yday,
		    (host_uptime.tm_yday > 1) ? "s" : "");
d214 3
a216 3
	if (host_uptime.tm_hour != 0)
		sprintf(hours_buf, "%2d:%02d, ",
		    host_uptime.tm_hour, host_uptime.tm_min);
d218 2
a219 2
		if (host_uptime.tm_min != 0)
			sprintf(hours_buf, "%2d mins, ", host_uptime.tm_min);
@


1.4
log
@get 12am & 12pm correct; netbsd pr#2734, khym@@bga.com [this was hell to test]
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.3 1996/08/16 09:10:29 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.3 1996/08/16 09:10:29 deraadt Exp $";
d241 1
d245 2
a246 1
		warnx("%s", clnt_spcreateerror(host));
d253 2
a254 1
		warnx("%s",  clnt_sperror(rstat_clnt, host));
d267 1
d278 1
a278 1
		warnx("%s", clnt_sperrno(clnt_stat));
@


1.3
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: rup.c,v 1.2 1996/06/26 05:38:52 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.2 1996/06/26 05:38:52 deraadt Exp $";
d219 2
a220 1
		printf(" %2d:%02d%cm", host_time.tm_hour % 12,
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: rup.c,v 1.1.1.1 1995/10/18 08:46:03 deraadt Exp $";
d121 1
a121 1
		return d1->statstime.avenrun[0] 
d140 1
a140 1
				rup_data_max * sizeof(struct rup_data));
d164 1
a164 2
			sizeof(struct in_addr), AF_INET);

d172 1
a172 1
		if (sort_type != SORT_NONE) {
d174 1
a174 1
		} else {
a175 1
		}
d205 1
a205 1
			(host_uptime.tm_yday > 1) ? "s" : "");
d211 1
a211 1
			host_uptime.tm_hour, host_uptime.tm_min);
d220 2
a221 2
			host_time.tm_min,
			(host_time.tm_hour >= 12) ? 'p' : 'a');
d224 4
a227 4
		days_buf, hours_buf,
		(double)host_stat->avenrun[0]/FSCALE,
		(double)host_stat->avenrun[1]/FSCALE,
		(double)host_stat->avenrun[2]/FSCALE);
d248 2
a249 1
	if (clnt_call(rstat_clnt, RSTATPROC_STATS, xdr_void, NULL, xdr_statstime, &host_stat, timeout) != RPC_SUCCESS) {
d271 1
a271 2
				   xdr_void, NULL,
				   xdr_statstime, &host_stat, rstat_reply);
d279 2
a280 1
		qsort(rup_data, rup_data_idx, sizeof(struct rup_data), compare);
d283 2
a284 1
			print_rup_data(rup_data[i].host, &rup_data[i].statstime);
@


1.1
log
@Initial revision
@
text
@d1 2
d37 1
a37 1
static char rcsid[] = "$Id: rup.c,v 1.10 1994/02/05 14:58:14 pk Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
