head	1.41;
access;
symbols
	OPENBSD_6_2:1.41.0.4
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.14
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.12
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.10
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.23.0.16
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.12
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.10
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.8
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.10
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2017.09.06.21.02.31;	author tb;	state Exp;
branches;
next	1.40;
commitid	9tmc4oeEOiMaCfbu;

1.40
date	2017.07.08.22.27.17;	author tedu;	state Exp;
branches;
next	1.39;
commitid	7gDzuGUsDJ5mvK0a;

1.39
date	2017.07.08.22.22.04;	author tedu;	state Exp;
branches;
next	1.38;
commitid	J3bSShjEUV4bqKB7;

1.38
date	2017.07.08.22.19.23;	author tedu;	state Exp;
branches;
next	1.37;
commitid	TKGE2s85w4H83LjY;

1.37
date	2017.07.08.22.14.48;	author tedu;	state Exp;
branches;
next	1.36;
commitid	V5GOGemEcgzCqNHf;

1.36
date	2017.07.08.22.07.39;	author tedu;	state Exp;
branches;
next	1.35;
commitid	0gFXFZvPWLYGRNM0;

1.35
date	2017.07.08.22.01.09;	author tedu;	state Exp;
branches;
next	1.34;
commitid	xd509alv7M9cFxly;

1.34
date	2017.05.03.09.51.39;	author mestre;	state Exp;
branches;
next	1.33;
commitid	CaQOrlCeSyj26bDl;

1.33
date	2016.05.28.16.11.10;	author tedu;	state Exp;
branches;
next	1.32;
commitid	rubLxCW4M2r2uiQ6;

1.32
date	2015.10.15.02.35.04;	author tedu;	state Exp;
branches;
next	1.31;
commitid	NZ6t7eLVt5E0ynQv;

1.31
date	2015.10.10.20.35.01;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	m38BXhkh3XknrpM6;

1.30
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	sbrB3Q5CNxcwZpfU;

1.29
date	2015.10.07.04.05.24;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	k8hbUd5I90c8CHNu;

1.28
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2013.08.22.04.43.40;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.13.15.26.06;	author tobias;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.18.20.58.35;	author martynas;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.26.02.35.08;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.26.02.32.41;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.14.14.42.28;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.15.21.49.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.04.01.08.54;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.23.03.07.21;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.08.18.04.43;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.02.16.25.11;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.29.21.38.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.03.06.20.27.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.03.06.20.19.19;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.27.21.47.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.27.21.29.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.01.15.23.42.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.10.16.00.09.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.06.01.57.15;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.08.06.18.10.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.25.01.54.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.35.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.24.09.19.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.41
log
@After recent changes, we need to clear hash, not s1.

From Scott Cheloha
ok deraadt
@
text
@/*	$OpenBSD: lock.c,v 1.40 2017/07/08 22:27:17 tedu Exp $	*/
/*	$NetBSD: lock.c,v 1.8 1996/05/07 18:32:31 jtc Exp $	*/

/*
 * Copyright (c) 1980, 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Bob Toxen.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Lock a terminal up until the given key is entered, until the root
 * password is entered, or the given interval times out.
 *
 * Timeout interval is by default TIMEOUT, it can be changed with
 * an argument of the form -time where time is in minutes
 */

#include <sys/stat.h>
#include <sys/time.h>
#include <signal.h>

#include <ctype.h>
#include <err.h>
#include <pwd.h>
#include <readpassphrase.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <limits.h>

#include <login_cap.h>
#include <bsd_auth.h>

#define	TIMEOUT	15

void bye(int);
void hi(int);

int	no_timeout;			/* lock terminal forever */

int
main(int argc, char *argv[])
{
	char hostname[HOST_NAME_MAX+1], s[BUFSIZ], s1[BUFSIZ], date[256];
	char hash[_PASSWORD_LEN];
	char *p, *style, *nstyle, *ttynam;
	struct itimerval ntimer, otimer;
	struct timeval timeout;
	int ch, sectimeout, usemine, cnt, tries = 10, backoff = 3;
	const char *errstr;
	struct passwd *pw;
	struct tm *timp;
	time_t curtime;
	login_cap_t *lc;

	sectimeout = TIMEOUT;
	style = NULL;
	usemine = 0;
	no_timeout = 0;
	memset(&timeout, 0, sizeof(timeout));

	if (pledge("stdio rpath wpath getpw tty proc exec", NULL) == -1)
		err(1, "pledge");

	if (!(pw = getpwuid(getuid())))
		errx(1, "unknown uid %u.", getuid());

	lc = login_getclass(pw->pw_class);
	if (lc != NULL) {
		/*
		 * We allow "login-tries" attempts to login but start
		 * slowing down after "login-backoff" attempts.
		 */
		tries = login_getcapnum(lc, "login-tries", 10, 10);
		backoff = login_getcapnum(lc, "login-backoff", 3, 3);
	}

	while ((ch = getopt(argc, argv, "a:npt:")) != -1) {
		switch (ch) {
		case 'a':
			if (lc) {
				style = login_getstyle(lc, optarg, "auth-lock");
				if (style == NULL)
					errx(1,
					    "invalid authentication style: %s",
					    optarg);
			}
			usemine = 1;
			break;
		case 't':
			sectimeout = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "timeout %s: %s", errstr, optarg);
			break;
		case 'p':
			usemine = 1;
			break;
		case 'n':
			no_timeout = 1;
			break;
		default:
			fprintf(stderr,
			    "usage: %s [-np] [-a style] [-t timeout]\n",
			    getprogname());
			exit(1);
		}
	}
	timeout.tv_sec = sectimeout * 60;

	gethostname(hostname, sizeof(hostname));
	if (usemine && lc == NULL)
		errx(1, "login class not found");
	if (!(ttynam = ttyname(STDIN_FILENO)))
		errx(1, "not a terminal?");
	curtime = time(NULL);
	timp = localtime(&curtime);
	strftime(date, sizeof(date), "%c", timp);

	if (!usemine) {
		/* get key and check again */
		if (!readpassphrase("Key: ", s, sizeof(s), RPP_ECHO_OFF) ||
		    *s == '\0')
			exit(0);
		/*
		 * Don't need EOF test here, if we get EOF, then s1 != s
		 * and the right things will happen.
		 */
		readpassphrase("Again: ", s1, sizeof(s1), RPP_ECHO_OFF);
		if (strcmp(s1, s)) {
			warnx("\apasswords didn't match.");
			exit(1);
		}
		crypt_newhash(s, "bcrypt", hash, sizeof(hash));
		explicit_bzero(s, sizeof(s));
		explicit_bzero(s1, sizeof(s1));
	}

	/* set signal handlers */
	signal(SIGINT, hi);
	signal(SIGQUIT, hi);
	signal(SIGTSTP, hi);
	signal(SIGALRM, bye);

	memset(&ntimer, 0, sizeof(ntimer));
	ntimer.it_value = timeout;
	if (!no_timeout)
		setitimer(ITIMER_REAL, &ntimer, &otimer);

	/* header info */
	if (no_timeout) {
		fprintf(stderr,
		    "%s: %s on %s. no timeout\ntime now is %s\n",
		    getprogname(), ttynam, hostname, date);
	} else {
		fprintf(stderr,
		    "%s: %s on %s. timeout in %d minutes\ntime now is %s\n",
		    getprogname(), ttynam, hostname, sectimeout, date);
	}

	for (cnt = 0;;) {
		if (!readpassphrase("Key: ", s, sizeof(s), RPP_ECHO_OFF))
			continue;
		if (strlen(s) == 0) {
			hi(0);
			continue;
		}
		if (usemine) {
			/*
			 * If user entered 's/key' or the style specified via
			 * the '-a' argument, auth_userokay() will prompt
			 * for a new password.  Otherwise, use what we have.
			 */
			if ((strcmp(s, "s/key") == 0 &&
			    (nstyle = login_getstyle(lc, "skey", "auth-lock")))
			    || ((nstyle = style) && strcmp(s, nstyle) == 0))
				p = NULL;
			else
				p = s;
			if (auth_userokay(pw->pw_name, nstyle, "auth-lock",
			    p)) {
				explicit_bzero(s, sizeof(s));
				break;
			}
		} else if (crypt_checkpass(s, hash) == 0) {
			explicit_bzero(s, sizeof(s));
			explicit_bzero(hash, sizeof(hash));
			break;
		}
		putc('\a', stderr);
		cnt %= tries;
		if (++cnt > backoff) {
			sigset_t set, oset;
			sigfillset(&set);
			sigprocmask(SIG_BLOCK, &set, &oset);
			sleep((u_int)((cnt - backoff) * tries / 2));
			sigprocmask(SIG_SETMASK, &oset, NULL);
		}
	}

	exit(0);
}

void
hi(int signo)
{
	struct itimerval left;

	dprintf(STDERR_FILENO, "%s: type in the unlock key.",
	    getprogname());
	if (!no_timeout) {
		getitimer(ITIMER_REAL, &left);
		dprintf(STDERR_FILENO, " timeout in %lld:%02d minutes",
		    (long long)(left.it_value.tv_sec / 60),
		    (int)(left.it_value.tv_sec % 60));
	}
	dprintf(STDERR_FILENO, "\n");
}

void
bye(int signo)
{

	if (!no_timeout)
		warnx("timeout");
	_exit(1);
}
@


1.40
log
@this program was infected with lint era casts. i think we're past that now.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.39 2017/07/08 22:22:04 tedu Exp $	*/
d214 1
a214 1
			explicit_bzero(s1, sizeof(s1));
@


1.39
log
@remove ARGSUSED, from Scott Cheloha.
and while we're cleaning, switch __progname to getprogname.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.38 2017/07/08 22:19:23 tedu Exp $	*/
d102 2
a103 2
		tries = (int)login_getcapnum(lc, "login-tries", 10, 10);
		backoff = (int)login_getcapnum(lc, "login-backoff", 3, 3);
d119 1
a119 1
			sectimeout = (int)strtonum(optarg, 1, INT_MAX, &errstr);
d130 1
a130 1
			(void)fprintf(stderr,
d156 1
a156 1
		(void)readpassphrase("Again: ", s1, sizeof(s1), RPP_ECHO_OFF);
d167 4
a170 4
	(void)signal(SIGINT, hi);
	(void)signal(SIGQUIT, hi);
	(void)signal(SIGTSTP, hi);
	(void)signal(SIGALRM, bye);
d179 1
a179 1
		(void)fprintf(stderr,
d183 1
a183 1
		(void)fprintf(stderr,
d217 1
a217 1
		(void)putc('\a', stderr);
d236 1
a236 1
	(void)dprintf(STDERR_FILENO, "%s: type in the unlock key.",
d239 2
a240 2
		(void)getitimer(ITIMER_REAL, &left);
		(void)dprintf(STDERR_FILENO, " timeout in %lld:%02d minutes",
d244 1
a244 1
	(void)dprintf(STDERR_FILENO, "\n");
@


1.38
log
@use crypt_newhash to protect the password. from Scott Cheloha
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.37 2017/07/08 22:14:48 tedu Exp $	*/
a68 3
extern	char *__progname;

/*ARGSUSED*/
d132 1
a132 1
			    __progname);
d181 1
a181 1
		    __progname, ttynam, hostname, date);
d185 1
a185 1
		    __progname, ttynam, hostname, sectimeout, date);
a230 1
/*ARGSUSED*/
d236 2
a237 1
	(void)dprintf(STDERR_FILENO, "%s: type in the unlock key.", __progname);
a246 1
/*ARGSUSED*/
@


1.37
log
@clean up some unused variables. also, making a variable global isn't the
best way to zero initialize it if that's all you need.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.36 2017/07/08 22:07:39 tedu Exp $	*/
d76 1
d164 1
d166 1
d215 1
a215 1
		} else if (strcmp(s, s1) == 0) {
@


1.36
log
@instead of using time(), refer to getitimer to find out how long the
timeout is.
from Scott Cheloha
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.35 2017/07/08 22:01:09 tedu Exp $	*/
a66 3
struct timeval	timeout;
struct timeval	zerotime;
time_t	nexttime;			/* keep the timeout time */
d78 1
d90 1
a145 1
	nexttime = curtime + (sectimeout * 60);
d172 1
a172 1
	ntimer.it_interval = zerotime;
@


1.35
log
@can just continue after readpassphrase returns null, the sighandler will
have already printed a message.
from Scott Cheloha
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.34 2017/05/03 09:51:39 mestre Exp $	*/
d237 1
a237 2
	char buf[1024], buf2[1024];
	time_t left;
d239 8
a246 10
	if (no_timeout)
		buf2[0] = '\0';
	else {
		left = nexttime - time(NULL);
		(void)snprintf(buf2, sizeof buf2, " timeout in %lld:%d minutes",
		    (long long)(left / 60), (int)(left % 60));
	}
	(void)snprintf(buf, sizeof buf, "%s: type in the unlock key.%s\n",
	    __progname, buf2);
	(void) write(STDERR_FILENO, buf, strlen(buf));
@


1.34
log
@Use the safe idiom of cleaning sensitive data from memory with explicit_bzero,
instead of relying on other methods, after readpassphrase. Some programs on
this diff won't benefit that much since it happens near the terminal path, but
someone might copy the unsafe idiom to another program and place it where it
may leak sensitive data.

Discussed aeons ago with tb@@, OK deraadt@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.33 2016/05/28 16:11:10 tedu Exp $	*/
d191 3
a193 2
		if (!readpassphrase("Key: ", s, sizeof(s), RPP_ECHO_OFF) ||
		    *s == '\0') {
@


1.33
log
@repair braces. from ilya.kaliman/gsoares/natano
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.32 2015/10/15 02:35:04 tedu Exp $	*/
d165 1
a165 1
		s[0] = '\0';
d208 3
a210 1
			if (auth_userokay(pw->pw_name, nstyle, "auth-lock", p))
d212 4
a215 1
		} else if (strcmp(s, s1) == 0)
d217 1
@


1.32
log
@lock needs pledge(proc exec) to use bsd auth system. from trondd
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.31 2015/10/10 20:35:01 deraadt Exp $	*/
d109 1
a109 1
	while ((ch = getopt(argc, argv, "a:npt:")) != -1)
d137 1
@


1.31
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.30 2015/10/09 01:37:08 deraadt Exp $	*/
d93 1
a93 1
	if (pledge("stdio rpath wpath getpw tty", NULL) == -1)
@


1.30
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.29 2015/10/07 04:05:24 deraadt Exp $	*/
d93 1
a93 1
	if (pledge("stdio getpw rpath wpath tty", NULL) == -1)
@


1.29
log
@tame "stdio getpw rpath wpath tty".  "tty" allows this to use
readpassphrase().
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.28 2015/01/16 06:40:09 deraadt Exp $	*/
d93 2
a94 2
	if (tame("stdio getpw rpath wpath tty", NULL) == -1)
		err(1, "tame");
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.27 2013/08/22 04:43:40 guenther Exp $	*/
d92 3
@


1.27
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.26 2010/06/13 15:26:06 tobias Exp $	*/
a43 1
#include <sys/param.h>
d57 1
d78 1
a78 1
	char hostname[MAXHOSTNAMELEN], s[BUFSIZ], s1[BUFSIZ], date[256];
@


1.26
log
@Prevent a segmentation fault.  It could occur when login_getclass fails and
the key "s/key" is entered with supplied -a or -p option.

ok millert (with better error message)
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.25 2009/10/27 23:59:39 deraadt Exp $	*/
d227 1
a227 1
	time_t now;
d232 3
a234 3
		now = time(NULL);
		(void)snprintf(buf2, sizeof buf2, " timeout in %d:%d minutes",
		    (nexttime - now) / 60, (nexttime - now) % 60);
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.24 2009/09/18 20:58:35 martynas Exp $	*/
d138 2
@


1.24
log
@like login(1), back off password guesses after login-backoff;  and
reset cnt after login-tries.  tweak & ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.23 2006/04/26 02:35:08 deraadt Exp $	*/
a34 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)lock.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: lock.c,v 1.23 2006/04/26 02:35:08 deraadt Exp $";
#endif /* not lint */
@


1.23
log
@pleasing lint, without displeasing future developers
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.22 2006/04/26 02:32:41 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.22 2006/04/26 02:32:41 deraadt Exp $";
d94 1
a94 1
	int ch, sectimeout, usemine;
d110 9
a118 1
	
d197 1
a197 1
	for (;;) {
d220 8
@


1.22
log
@merge parts of strtonum() cleanup from tan.dang@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.21 2005/07/14 14:42:28 jmc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.21 2005/07/14 14:42:28 jmc Exp $";
d124 1
a124 1
			sectimeout = strtonum(optarg, 1, INT_MAX, &errstr);
d217 1
d219 1
a219 1
hi(int dummy)
d231 1
a231 1
	snprintf(buf, sizeof buf, "%s: type in the unlock key.%s\n",
d236 1
d238 1
a238 1
bye(int dummy)
@


1.21
log
@- better synopsis
- sort options
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.20 2003/06/03 02:56:10 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.20 2003/06/03 02:56:10 millert Exp $";
d95 1
d124 3
a126 2
			if ((sectimeout = atoi(optarg)) <= 0)
				errx(1, "illegal timeout value: %s", optarg);
a133 1
		case '?':
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.19 2002/08/15 21:49:40 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.19 2002/08/15 21:49:40 deraadt Exp $";
d135 1
a135 1
			    "usage: %s [-n] [-p] [-a style] [-t timeout]\n",
@


1.19
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.18 2002/08/04 01:08:54 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.18 2002/08/04 01:08:54 deraadt Exp $";
@


1.18
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.17 2002/06/23 03:07:21 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.17 2002/06/23 03:07:21 deraadt Exp $";
d115 1
a115 1
		switch(ch) {
@


1.17
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.16 2002/05/08 18:04:43 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.16 2002/05/08 18:04:43 millert Exp $";
d93 1
a93 3
main(argc, argv)
	int argc;
	char **argv;
d95 4
a99 1
	struct itimerval ntimer, otimer;
a101 3
	int ch, sectimeout, usemine;
	char *p, *style, *nstyle, *ttynam;
	char hostname[MAXHOSTNAMELEN], s[BUFSIZ], s1[BUFSIZ], date[256];
d221 1
a221 2
hi(dummy)
	int dummy;
d239 1
a239 2
bye(dummy)
	int dummy;
@


1.16
log
@_exit() not exit() in signal handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.15 2002/02/16 21:27:48 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.15 2002/02/16 21:27:48 millert Exp $";
d112 1
a112 1
		errx(1, "unknown uid %d.", getuid());
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.14 2001/11/02 16:25:11 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.14 2001/11/02 16:25:11 deraadt Exp $";
d247 2
a248 1
		errx(1, "timeout");
@


1.14
log
@avoid stdio in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.13 2001/05/29 21:38:15 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.13 2001/05/29 21:38:15 millert Exp $";
d81 2
a82 2
void bye	__P((int));
void hi		__P((int));
@


1.13
log
@adapt to BSD authentication and clean things up a bit while I am at it
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.12 1999/03/06 20:27:40 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.12 1999/03/06 20:27:40 millert Exp $";
d226 1
d229 3
a231 2
	(void)fprintf(stderr, "%s: type in the unlock key.", __progname);
	if (!no_timeout) {
d233 2
a234 3
		(void)fprintf(stderr, " timeout in %d:%d minutes",
		    (nexttime - now) / 60,
		    (nexttime - now) % 60);
d236 3
a238 1
	putc('\n', stderr);
@


1.12
log
@back out changes that should not have escaped my local tree
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.10 1997/07/27 21:47:07 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.10 1997/07/27 21:47:07 millert Exp $";
d69 1
d76 2
a77 3
#ifdef SKEY
#include <skey.h>
#endif
a82 2
void quit	__P((int));
int skey_auth	__P((char *));
d86 1
a86 2
struct termios	tty, ntty;
long	nexttime;			/* keep the timeout time */
d89 2
a97 1
	struct timeval timval;
d102 3
a104 2
	char *ap, *mypw, *ttynam, *tzn;
	char hostname[MAXHOSTNAMELEN], s[BUFSIZ], s1[BUFSIZ];
d107 1
a107 1
	mypw = NULL;
d113 2
d116 12
a127 2
	while ((ch = getopt(argc, argv, "npt:")) != -1)
		switch((char)ch) {
a133 1
			mypw = strdup(pw->pw_passwd);
d141 2
a142 1
			    "usage: lock [-n] [-p] [-t timeout]\n");
a146 4
	seteuid(getuid());		/* discard what privs we can */

	if (tcgetattr(0, &tty) < 0)	/* get information for header */
		exit(1);
d148 1
a148 1
	if (!(ttynam = ttyname(0)))
d150 2
a151 4
	if (gettimeofday(&timval, (struct timezone *)NULL))
		err(1, "gettimeofday");
	curtime = timval.tv_sec;
	nexttime = timval.tv_sec + (sectimeout * 60);
d153 1
a153 2
	ap = asctime(timp);
	tzn = timp->tm_zone;
d155 1
a155 6
	(void)signal(SIGINT, quit);
	(void)signal(SIGQUIT, quit);
	ntty = tty; ntty.c_lflag &= ~ECHO;
	(void)tcsetattr(0, TCSADRAIN, &ntty);

	if (!mypw) {
d157 3
a159 4
		(void)fputs("Key: ", stdout);
		if (!fgets(s, sizeof(s), stdin) || *s == '\n')
			quit(0);
		(void)fputs("\nAgain: ", stdout);
d164 1
a164 2
		(void)fgets(s1, sizeof(s1), stdin);
		(void)putchar('\n');
d166 1
a166 2
			(void)puts("\alock: passwords didn't match.");
			(void)tcsetattr(0, TCSADRAIN, &tty);
a169 1
		mypw = s1;
d185 3
a187 2
		(void)printf("lock: %s on %s. no timeout\ntime now is %.20s%s%s",
		    ttynam, hostname, ap, tzn, ap + 19);
d189 3
a191 2
		(void)printf("lock: %s on %s. timeout in %d minutes\ntime now is %.20s%s%s",
		    ttynam, hostname, sectimeout, ap, tzn, ap + 19);
d195 2
a196 3
		(void)fputs("Key: ", stdout);
		if (!fgets(s, sizeof(s), stdin)) {
			clearerr(stdin);
d201 12
a212 12
			s[strlen(s) - 1] = '\0';
#ifdef SKEY
			if (strcasecmp(s, "s/key") == 0) {
				/* S/Key lookup needs to be done as root */
				seteuid(0);
				ch = skey_auth(pw->pw_name);
				seteuid(getuid());
				if (ch)
					break;
			}
#endif
			if (!strcmp(mypw, crypt(s, mypw)))
d214 1
a214 2
		}
		else if (!strcmp(s, s1))
d216 1
a216 3
		(void)puts("\a");
		if (tcsetattr(0, TCSADRAIN, &ntty) < 0)
			exit(1);
d219 1
a219 29
	quit(0);
	exit(0);			/*NOTREACHED*/
}

#ifdef SKEY
/*
 * We can't use libskey's skey_authenticate() since it
 * handles signals in a way that's inappropriate
 * for our needs. Instead we roll our own.
 */
int
skey_auth(user)
	char *user;
{
	char s[256], *ask;
	int ret = 0;

	if (!skey_haskey(user) && (ask = skey_keyinfo(user))) {
		(void)printf("\n%s\nResponse: ", ask);		
		if (!fgets(s, sizeof(s), stdin) || *s == '\n')
			clearerr(stdin);
		else {
			rip(s);
			if (skey_passcheck(user, s) != -1)
				ret = 1;
		}
	} else
		(void)printf("Sorry, you have no s/key.\n");
	return(ret);
a220 1
#endif
d226 1
a226 1
	struct timeval timval;
d228 6
a233 9
	if (!gettimeofday(&timval, (struct timezone *)NULL)) {
		(void)printf("lock: type in the unlock key. ");
		if (no_timeout) {
			putchar('\n');
		} else {
			(void)printf("timeout in %ld:%ld minutes\n",
			    (nexttime - timval.tv_sec) / 60,
			    (nexttime - timval.tv_sec) % 60);
		}
d235 1
d239 1
a239 1
quit(dummy)
a241 4
	putchar('\n');
	(void)tcsetattr(0, TCSADRAIN, &tty);
	exit(0);
}
d243 2
a244 9
void
bye(dummy)
	int dummy;
{
	if (!no_timeout) {
		(void)tcsetattr(0, TCSADRAIN, &tty);
		(void)puts("lock: timeout");
		exit(1);
	}
@


1.11
log
@add missing reference to infocmp
@
text
@a73 1
#include <login_cap.h>
a105 1
	login_cap_t *lc = NULL;
a215 1
#if 0
a217 9
#else
			lc = login_getpwclass(pw);
			if (lc->lc_style == NULL)
				lc->lc_style = login_getstyle(lc, NULL, "login");
			if ((ch = auth_response(pw->pw_name, lc->lc_class,
			    lc->lc_style, "response", NULL, "", s)) > 0)
				break;
			warnx("auth_response returned %d", ch);
#endif
@


1.10
log
@A bit of KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.9 1997/07/27 21:29:59 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.9 1997/07/27 21:29:59 millert Exp $";
d74 1
d107 1
d218 1
d221 9
@


1.9
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.8 1997/01/15 23:42:45 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.8 1997/01/15 23:42:45 millert Exp $";
d81 4
a84 4
int skey_auth __P((char *));
void quit __P((int));
void bye __P((int));
void hi __P((int));
d130 2
a131 1
			fprintf(stderr, "usage: lock [-n] [-p] [-t timeout]\n");
d158 1
a158 1
		printf("Key: ");
d161 1
a161 1
		printf("\nAgain: ");
d190 1
a190 1
		printf("lock: %s on %s. no timeout\ntime now is %.20s%s%s",
d193 1
a193 1
		printf("lock: %s on %s. timeout in %d minutes\ntime now is %.20s%s%s",
d198 1
a198 1
		printf("Key: ");
d221 1
a221 1
		printf("\a\n");
d244 1
a244 1
		printf("\n%s\nResponse: ", ask);		
d248 1
a248 1
			s[strlen(s) - 1] = '\0';
d253 2
a254 2
		printf("Sorry, you have no s/key.\n");
	return ret;
d269 1
a269 1
			printf("timeout in %ld:%ld minutes\n",
d291 1
a291 1
		printf("lock: timeout\n");
@


1.8
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.7 1996/10/16 00:09:20 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.7 1996/10/16 00:09:20 millert Exp $";
d81 4
a84 1
void quit(), bye(), hi();
d90 1
a90 1
int		no_timeout;			/* lock terminal forever */
d93 1
d159 1
a159 1
			quit();
d200 1
a200 1
			hi();
d224 3
a226 1
	quit();
d258 2
a259 1
hi()
d276 2
a277 1
quit()
d285 2
a286 1
bye()
@


1.7
log
@s/key support now works (s/key lookup must be done with euid == 0)
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.6 1996/09/06 01:57:15 downsj Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.6 1996/09/06 01:57:15 downsj Exp $";
d111 1
a111 1
	while ((ch = getopt(argc, argv, "npt:")) != EOF)
@


1.6
log
@Add -n/no timeout option.  FreeBSD PR bin/1567, obrien@@Nuxi.cs.ucdavis.edu.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.5 1996/08/06 18:10:23 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.5 1996/08/06 18:10:23 deraadt Exp $";
d75 4
a93 1
	extern char *optarg;
a101 1
	char *crypt();
d131 1
a131 1
	setuid(getuid());		/* discard privs */
d164 1
a164 1
			(void)printf("\alock: passwords didn't match.\n");
d203 5
a207 1
				if (skey_auth(pw->pw_name))
d233 1
a233 1
	char s[128], *ask, *skey_keyinfo __P((char *name));
d237 1
a237 1
		printf("\n[%s]\nResponse: ", ask);		
@


1.5
log
@type cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.4 1996/07/25 01:54:39 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.4 1996/07/25 01:54:39 deraadt Exp $";
d83 1
d104 1
d109 1
a109 1
	while ((ch = getopt(argc, argv, "pt:")) != EOF)
d119 3
d124 1
a124 1
			fprintf(stderr, "usage: lock [-p] [-t timeout]\n");
d178 2
a179 1
	setitimer(ITIMER_REAL, &ntimer, &otimer);
d182 7
a188 2
	printf("lock: %s on %s. timeout in %d minutes\ntime now is %.20s%s%s",
	    ttynam, hostname, sectimeout, ap, tzn, ap + 19);
d250 10
a259 3
	if (!gettimeofday(&timval, (struct timezone *)NULL))
	printf("lock: type in the unlock key. timeout in %ld:%ld minutes\n",
	    (nexttime - timval.tv_sec) / 60, (nexttime - timval.tv_sec) % 60);
d273 5
a277 3
	(void)tcsetattr(0, TCSADRAIN, &tty);
	printf("lock: timeout\n");
	exit(1);
@


1.4
log
@readable
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.3 1996/06/26 05:35:56 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.3 1996/06/26 05:35:56 deraadt Exp $";
d161 1
a161 1
		s[0] = NULL;
d213 2
a214 1
skey_auth(char *user)
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.c,v 1.8 1996/05/07 18:32:31 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: lock.c,v 1.8 1996/05/07 18:32:31 jtc Exp $";
d119 1
a119 2
			(void)fprintf(stderr,
			    "usage: lock [-p] [-t timeout]\n");
d146 1
a146 1
		(void)printf("Key: ");
d149 1
a149 1
		(void)printf("\nAgain: ");
d176 1
a176 1
(void)printf("lock: %s on %s. timeout in %d minutes\ntime now is %.20s%s%s",
d180 1
a180 1
		(void)printf("Key: ");
d199 1
a199 1
		(void)printf("\a\n");
d239 1
a239 1
(void)printf("lock: type in the unlock key. timeout in %ld:%ld minutes\n",
d246 1
a246 1
	(void)putchar('\n');
d255 1
a255 1
	(void)printf("lock: timeout\n");
@


1.2
log
@use protos
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: lock.c,v 1.8 1996/05/07 18:32:31 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: lock.c,v 1.7 1995/06/27 00:16:17 jtc Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: lock.c,v 1.7 1995/06/27 00:16:17 jtc Exp $";
d69 1
d72 1
a88 1
	extern int errno, optind;
d97 1
a97 1
	char *crypt(), *ttyname();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
