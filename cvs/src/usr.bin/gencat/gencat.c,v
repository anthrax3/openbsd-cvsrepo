head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.10
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.10
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.10.10.21.29.59;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	oN4SOBEml37hWgGy;

1.17
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.16;
commitid	yCis8OrOsfixbKpI;

1.16
date	2012.12.05.23.20.25;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.01.11.25.54;	author lum;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.04.18.42.32;	author sobrado;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.17.19.04.20;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.01.19.23.34;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.10.22.20.46;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.27.23.53.29;	author danh;	state Exp;
branches;
next	1.5;

1.5
date	97.09.21.10.34.00;	author jdm;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.33.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.38.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.43.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.19;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@pledge "stdio rpath wpath cpath"
ok doug
@
text
@/*	$OpenBSD: gencat.c,v 1.17 2014/11/18 20:54:28 krw Exp $	*/
/*	$NetBSD: gencat.c,v 1.9 1998/10/09 17:00:56 itohy Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by J.T. Conklin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/***********************************************************
Copyright 1990, by Alfalfa Software Incorporated, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that Alfalfa's name not be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission.

ALPHALPHA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
ALPHALPHA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

If you make any modifications, bugfixes or other changes to this software
we'd appreciate it if you could send a copy to us so we can keep things
up-to-date.  Many thanks.
				Kee Hinckley
				Alfalfa Software, Inc.
				267 Allston St., #3
				Cambridge, MA 02139  USA
				nazgul@@alfalfa.com

******************************************************************/

#define _NLS_PRIVATE

/* ensure 8-bit cleanliness */
#define ISSPACE(c) \
    (isascii((unsigned char)c) && isspace((unsigned char)c))

#include <sys/queue.h>
#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <nl_types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

struct _msgT {
	long    msgId;
	char   *str;
        LIST_ENTRY(_msgT) entries;
};

struct _setT {
	long    setId;
        LIST_HEAD(msghead, _msgT) msghead;
        LIST_ENTRY(_setT) entries;
};

LIST_HEAD(sethead, _setT) sethead;
static struct _setT *curSet;

static char *curline = NULL;
static long lineno = 0;

extern	char	*__progname;		/* from crt0.o */

static	char   *cskip(char *);
static	void	error(char *, char *);
static	void	nomem(void);
static	char   *get_line(int);
static	char   *getmsg(int, char *, char);
static	void	warning(char *, char *);
static	char   *wskip(char *);
static	char   *xstrdup(const char *);
static	void   *xmalloc(size_t);
static	void   *xrealloc(void *, size_t);

void	MCParse(int fd);
void	MCWriteCat(int fd);
void	MCDelMsg(int msgId);
void	MCAddMsg(int msgId, const char *msg);
void	MCAddSet(int setId);
void	MCDelSet(int setId);
int	main(int, char **);
void	usage(void);


void
usage(void)
{
	fprintf(stderr, "usage: %s catfile msgfile ...\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int     ofd, ifd;
	char   *catfile = NULL;
	int     c;

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");

	while ((c = getopt(argc, argv, "")) != -1) {
		switch (c) {
		case '?':
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if (argc < 2) {
		usage();
		/* NOTREACHED */
	}
	catfile = *argv++;

	for (; *argv; argv++) {
		if ((ifd = open(*argv, O_RDONLY)) < 0)
			err(1, "Unable to read %s", *argv);
		MCParse(ifd);
		close(ifd);
	}

	if ((ofd = open(catfile, O_WRONLY | O_TRUNC | O_CREAT, 0666)) < 0)
		err(1, "Unable to create a new %s", catfile);
	MCWriteCat(ofd);
	exit(0);
}

static void
warning(char *cptr, char *msg)
{
	warnx("%s on line %ld\n%s", msg, lineno, curline);
	if (cptr) {
		char   *tptr;
		for (tptr = curline; tptr < cptr; ++tptr)
			putc(' ', stderr);
		fprintf(stderr, "^\n");
	}
}

static void
error(char *cptr, char *msg)
{
	warning(cptr, msg);
	exit(1);
}

static void
nomem(void)
{
	error(NULL, "out of memory");
}

static void *
xmalloc(size_t len)
{
	void   *p;

	if ((p = malloc(len)) == NULL)
		nomem();
	return (p);
}

static void *
xrealloc(void *ptr, size_t size)
{
	if ((ptr = realloc(ptr, size)) == NULL)
		nomem();
	return (ptr);
}

static char *
xstrdup(const char *str)
{
	char *nstr;

	if ((nstr = strdup(str)) == NULL)
		nomem();
	return (nstr);
}

static char *
get_line(int fd)
{
	static long curlen = BUFSIZ;
	static char buf[BUFSIZ], *bptr = buf, *bend = buf;
	char   *cptr, *cend;
	long    buflen;

	if (!curline) {
		curline = xmalloc(curlen);
	}
	++lineno;

	cptr = curline;
	cend = curline + curlen;
	for (;;) {
		for (; bptr < bend && cptr < cend; ++cptr, ++bptr) {
			if (*bptr == '\n') {
				*cptr = '\0';
				++bptr;
				return (curline);
			} else
				*cptr = *bptr;
		}
		if (bptr == bend) {
			buflen = read(fd, buf, BUFSIZ);
			if (buflen <= 0) {
				if (cptr > curline) {
					*cptr = '\0';
					return (curline);
				}
				return (NULL);
			}
			bend = buf + buflen;
			bptr = buf;
		}
		if (cptr == cend) {
			cptr = curline = xrealloc(curline, curlen *= 2);
			cend = curline + curlen;
		}
	}
}

static char *
wskip(char *cptr)
{
	if (!*cptr || !ISSPACE(*cptr)) {
		warning(cptr, "expected a space");
		return (cptr);
	}
	while (*cptr && ISSPACE(*cptr))
		++cptr;
	return (cptr);
}

static char *
cskip(char *cptr)
{
	if (!*cptr || ISSPACE(*cptr)) {
		warning(cptr, "wasn't expecting a space");
		return (cptr);
	}
	while (*cptr && !ISSPACE(*cptr))
		++cptr;
	return (cptr);
}

static char *
getmsg(int fd, char *cptr, char quote)
{
	static char *msg = NULL;
	static long msglen = 0;
	long    clen, i;
	char   *tptr;

	if (quote && *cptr == quote) {
		++cptr;
	} 

	clen = strlen(cptr) + 1;
	if (clen > msglen) {
		if (msglen)
			msg = xrealloc(msg, clen);
		else
			msg = xmalloc(clen);
		msglen = clen;
	}
	tptr = msg;

	while (*cptr) {
		if (quote && *cptr == quote) {
			char   *tmp;
			tmp = cptr + 1;

			if (*tmp && (!ISSPACE(*tmp) || *wskip(tmp))) {
				warning(cptr, "unexpected quote character, ignoring");
				*tptr++ = *cptr++;
			} else {
				*cptr = '\0';
			}
		} else if (*cptr == '\\') {
			++cptr;
			switch (*cptr) {
			case '\0':
				cptr = get_line(fd);
				if (!cptr)
					error(NULL, "premature end of file");
				msglen += strlen(cptr);
				i = tptr - msg;
				msg = xrealloc(msg, msglen);
				tptr = msg + i;
				break;
			case 'n':
				*tptr++ = '\n';
				++cptr;
				break;
			case 't':
				*tptr++ = '\t';
				++cptr;
				break;
			case 'v':
				*tptr++ = '\v';
				++cptr;
				break;
			case 'b':
				*tptr++ = '\b';
				++cptr;
				break;
			case 'r':
				*tptr++ = '\r';
				++cptr;
				break;
			case 'f':
				*tptr++ = '\f';
				++cptr;
				break;
			case '\\':
				*tptr++ = '\\';
				++cptr;
				break;
			case '"':
				/* FALLTHROUGH */
			case '\'':
				/*
				 * While it isn't necessary to
				 * escape ' and ", let's accept
				 * them escaped and not complain.
				 * (XPG4 states that '\' should be
				 * ignored when not used in a 
				 * valid escape sequence)
				 */
				*tptr++ = '"';
				++cptr;
				break;
			default:
				if (quote && *cptr == quote) {
					*tptr++ = *cptr++;
				} else if (isdigit((unsigned char) *cptr)) {
					*tptr = 0;
					for (i = 0; i < 3; ++i) {
						if (!isdigit((unsigned char) *cptr))
							break;
						if (*cptr > '7')
							warning(cptr, "octal number greater than 7?!");
						*tptr *= 8;
						*tptr += (*cptr - '0');
						++cptr;
					}
				} else {
					warning(cptr, "unrecognized escape sequence; ignoring esacpe character");
				}
				break;
			}
		} else {
			*tptr++ = *cptr++;
		}
	}
	*tptr = '\0';
	return (msg);
}

void
MCParse(int fd)
{
	char   *cptr, *str;
	int     setid, msgid = 0;
	char    quote = 0;

	/* XXX: init sethead? */

	while ((cptr = get_line(fd))) {
		if (*cptr == '$') {
			++cptr;
			if (strncmp(cptr, "set", 3) == 0) {
				cptr += 3;
				cptr = wskip(cptr);
				setid = atoi(cptr);
				MCAddSet(setid);
				msgid = 0;
			} else if (strncmp(cptr, "delset", 6) == 0) {
				cptr += 6;
				cptr = wskip(cptr);
				setid = atoi(cptr);
				MCDelSet(setid);
			} else if (strncmp(cptr, "quote", 5) == 0) {
				cptr += 5;
				if (!*cptr)
					quote = 0;
				else {
					cptr = wskip(cptr);
					if (!*cptr)
						quote = 0;
					else
						quote = *cptr;
				}
			} else if (ISSPACE(*cptr)) {
				;
			} else {
				if (*cptr) {
					cptr = wskip(cptr);
					if (*cptr)
						warning(cptr, "unrecognized line");
				}
			}
		} else {
			/*
			 * First check for (and eat) empty lines....
			 */
			if (!*cptr)
				continue;
			/*
			 * We have a digit? Start of a message. Else,
			 * syntax error.
			 */
			if (isdigit((unsigned char) *cptr)) {
				msgid = atoi(cptr);
				cptr = cskip(cptr);
				cptr = wskip(cptr);
				/* if (*cptr) ++cptr; */
			} else {
				warning(cptr, "neither blank line nor start of a message id");
				continue;
			}
			/*
			 * If we have a message ID, but no message,
			 * then this means "delete this message id
			 * from the catalog".
			 */
			if (!*cptr) {
				MCDelMsg(msgid);
			} else {
				str = getmsg(fd, cptr, quote);
				MCAddMsg(msgid, str);
			}
		}
	}
}

/*
 * Write message catalog.
 *
 * The message catalog is first converted from its internal to its
 * external representation in a chunk of memory allocated for this
 * purpose.  Then the completed catalog is written.  This approach
 * avoids additional housekeeping variables and/or a lot of seeks
 * that would otherwise be required.
 */
void
MCWriteCat(int fd)
{
	int     nsets;		/* number of sets */
	int     nmsgs;		/* number of msgs */
	int     string_size;	/* total size of string pool */
	int     msgcat_size;	/* total size of message catalog */
	void   *msgcat;		/* message catalog data */
	struct _nls_cat_hdr *cat_hdr;
	struct _nls_set_hdr *set_hdr;
	struct _nls_msg_hdr *msg_hdr;
	char   *strings;
	struct _setT *set;
	struct _msgT *msg;
	int     msg_index;
	int     msg_offset;

	/* determine number of sets, number of messages, and size of the
	 * string pool */
	nsets = 0;
	nmsgs = 0;
	string_size = 0;

	LIST_FOREACH(set, &sethead, entries) {
		nsets++;

		LIST_FOREACH(msg, &set->msghead, entries) {
			nmsgs++;
			string_size += strlen(msg->str) + 1;
		}
	}

#ifdef DEBUG
	printf("number of sets: %d\n", nsets);
	printf("number of msgs: %d\n", nmsgs);
	printf("string pool size: %d\n", string_size);
#endif

	/* determine size and then allocate buffer for constructing external
	 * message catalog representation */
	msgcat_size = sizeof(struct _nls_cat_hdr)
	    + (nsets * sizeof(struct _nls_set_hdr))
	    + (nmsgs * sizeof(struct _nls_msg_hdr))
	    + string_size;

	msgcat = xmalloc(msgcat_size);
	memset(msgcat, '\0', msgcat_size);

	/* fill in msg catalog header */
	cat_hdr = (struct _nls_cat_hdr *) msgcat;
	cat_hdr->__magic = htonl(_NLS_MAGIC);
	cat_hdr->__nsets = htonl(nsets);
	cat_hdr->__mem = htonl(msgcat_size - sizeof(struct _nls_cat_hdr));
	cat_hdr->__msg_hdr_offset =
	    htonl(nsets * sizeof(struct _nls_set_hdr));
	cat_hdr->__msg_txt_offset =
	    htonl(nsets * sizeof(struct _nls_set_hdr) +
	    nmsgs * sizeof(struct _nls_msg_hdr));

	/* compute offsets for set & msg header tables and string pool */
	set_hdr = (struct _nls_set_hdr *) ((char *) msgcat +
	    sizeof(struct _nls_cat_hdr));
	msg_hdr = (struct _nls_msg_hdr *) ((char *) msgcat +
	    sizeof(struct _nls_cat_hdr) +
	    nsets * sizeof(struct _nls_set_hdr));
	strings = (char *) msgcat +
	    sizeof(struct _nls_cat_hdr) +
	    nsets * sizeof(struct _nls_set_hdr) +
	    nmsgs * sizeof(struct _nls_msg_hdr);

	msg_index = 0;
	msg_offset = 0;
	LIST_FOREACH(set, &sethead, entries) {

		nmsgs = 0;
		LIST_FOREACH(msg, &set->msghead, entries) {
			int     msg_len = strlen(msg->str) + 1;

			msg_hdr->__msgno = htonl(msg->msgId);
			msg_hdr->__msglen = htonl(msg_len);
			msg_hdr->__offset = htonl(msg_offset);

			memcpy(strings, msg->str, msg_len);
			strings += msg_len;
			msg_offset += msg_len;

			nmsgs++;
			msg_hdr++;
		}

		set_hdr->__setno = htonl(set->setId);
		set_hdr->__nmsgs = htonl(nmsgs);
		set_hdr->__index = htonl(msg_index);
		msg_index += nmsgs;
		set_hdr++;
	}

	/* write out catalog.  XXX: should this be done in small chunks? */
	write(fd, msgcat, msgcat_size);
}

void
MCAddSet(int setId)
{
	struct _setT *p, *q;

	if (setId <= 0) {
		error(NULL, "setId's must be greater than zero");
		/* NOTREACHED */
	}
#if 0
	/* XXX */
	if (setId > NL_SETMAX) {
		error(NULL, "setId %d exceeds limit (%d)");
		/* NOTREACHED */
	}
#endif

	p = LIST_FIRST(&sethead);
	q = NULL;
	for (; p != NULL && p->setId < setId; q = p, p = LIST_NEXT(p, entries));

	if (p && p->setId == setId) {
		;
	} else {
		p = xmalloc(sizeof(struct _setT));
		memset(p, '\0', sizeof(struct _setT));
		LIST_INIT(&p->msghead);

		p->setId = setId;

		if (q == NULL) {
			LIST_INSERT_HEAD(&sethead, p, entries);
		} else {
			LIST_INSERT_AFTER(q, p, entries);
		}
	}

	curSet = p;
}

void
MCAddMsg(int msgId, const char *str)
{
	struct _msgT *p, *q;

	if (!curSet)
		error(NULL, "can't specify a message when no set exists");

	if (msgId <= 0) {
		error(NULL, "msgId's must be greater than zero");
		/* NOTREACHED */
	}
#if 0
	/* XXX */
	if (msgId > NL_SETMAX) {
		error(NULL, "msgId %d exceeds limit (%d)");
		/* NOTREACHED */
	}
#endif

	p = LIST_FIRST(&curSet->msghead);
	q = NULL;
	for (; p != NULL && p->msgId < msgId; q = p, p = LIST_NEXT(p, entries));

	if (p && p->msgId == msgId) {
		free(p->str);
	} else {
		p = xmalloc(sizeof(struct _msgT));
		memset(p, '\0', sizeof(struct _msgT));

		if (q == NULL) {
			LIST_INSERT_HEAD(&curSet->msghead, p, entries);
		} else {
			LIST_INSERT_AFTER(q, p, entries);
		}
	}

	p->msgId = msgId;
	p->str = xstrdup(str);
}

void
MCDelSet(int setId)
{
	struct _setT *set;
	struct _msgT *msg;

	set = LIST_FIRST(&sethead);
	for (; set != NULL && set->setId < setId;
	    set = LIST_NEXT(set, entries));

	if (set && set->setId == setId) {

		msg = LIST_FIRST(&set->msghead);
		while (msg) {
			free(msg->str);
			LIST_REMOVE(msg, entries);
		}

		LIST_REMOVE(set, entries);
		return;
	}
	warning(NULL, "specified set doesn't exist");
}

void
MCDelMsg(int msgId)
{
	struct _msgT *msg;

	if (!curSet)
		error(NULL, "you can't delete a message before defining the set");

	msg = LIST_FIRST(&curSet->msghead);
	for (; msg != NULL && msg->msgId < msgId;
	    msg = LIST_NEXT(msg, entries));

	if (msg && msg->msgId == msgId) {
		free(msg->str);
		LIST_REMOVE(msg, entries);
		return;
	}
	warning(NULL, "specified msg doesn't exist");
}
@


1.17
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.16 2012/12/05 23:20:25 deraadt Exp $	*/
d136 3
@


1.16
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.15 2012/03/04 04:05:15 fgsch Exp $	*/
a80 3
#include <fcntl.h>
#include <nl_types.h>
#include <err.h>
@


1.15
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.14 2011/01/01 11:25:54 lum Exp $	*/
a32 1
#include <sys/cdefs.h>
@


1.14
log
@Put "else if" split between two lines together, then move whitespace.
ok deraadt (ok'd sep2009)
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.13 2009/10/27 23:59:38 deraadt Exp $	*/
d109 1
a109 1
static	char   *getline(int);
d225 1
a225 1
getline(int fd)
d328 1
a328 1
				cptr = getline(fd);
d414 1
a414 1
	while ((cptr = getline(fd))) {
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.12 2009/01/04 18:42:32 sobrado Exp $	*/
d317 1
d324 34
a357 2
		} else
			if (*cptr == '\\') {
d359 32
a390 68
				switch (*cptr) {
				case '\0':
					cptr = getline(fd);
					if (!cptr)
						error(NULL, "premature end of file");
					msglen += strlen(cptr);
					i = tptr - msg;
					msg = xrealloc(msg, msglen);
					tptr = msg + i;
					break;
				case 'n':
					*tptr++ = '\n';
					++cptr;
					break;
				case 't':
					*tptr++ = '\t';
					++cptr;
					break;
				case 'v':
					*tptr++ = '\v';
					++cptr;
					break;
				case 'b':
					*tptr++ = '\b';
					++cptr;
					break;
				case 'r':
					*tptr++ = '\r';
					++cptr;
					break;
				case 'f':
					*tptr++ = '\f';
					++cptr;
					break;
				case '\\':
					*tptr++ = '\\';
					++cptr;
					break;
				case '"':
					/* FALLTHROUGH */
				case '\'':
					/*
					 * While it isn't necessary to
					 * escape ' and ", let's accept
					 * them escaped and not complain.
					 * (XPG4 states that '\' should be
					 * ignored when not used in a 
					 * valid escape sequence)
					 */
					*tptr++ = '"';
					++cptr;
					break;
				default:
					if (quote && *cptr == quote) {
						*tptr++ = *cptr++;
					} else if (isdigit((unsigned char) *cptr)) {
						*tptr = 0;
						for (i = 0; i < 3; ++i) {
							if (!isdigit((unsigned char) *cptr))
								break;
							if (*cptr > '7')
								warning(cptr, "octal number greater than 7?!");
							*tptr *= 8;
							*tptr += (*cptr - '0');
							++cptr;
						}
					} else {
						warning(cptr, "unrecognized escape sequence; ignoring esacpe character");
d392 2
a393 1
					break;
d395 1
a395 2
			} else {
				*tptr++ = *cptr++;
d397 3
@


1.12
log
@sync the synopsis and usage of the command; "usage:" is lowercase.

tweaked and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.11 2008/06/26 05:42:21 ray Exp $	*/
a33 4
#ifndef lint
static const char rcsid[] =
    "$OpenBSD: gencat.c,v 1.11 2008/06/26 05:42:21 ray Exp $";
#endif /* not lint */
@


1.11
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.10 2005/10/17 19:04:20 otto Exp $	*/
d36 1
a36 1
    "$OpenBSD: gencat.c,v 1.10 2005/10/17 19:04:20 otto Exp $";
d134 1
a134 1
	fprintf(stderr, "Usage: %s catfile msgfile ...\n", __progname);
@


1.10
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.9 2004/07/01 19:23:34 mickey Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *        This product includes software developed by the NetBSD 
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its 
 *    contributors may be used to endorse or promote products derived 
 *    from this software without specific prior written permission.
d36 1
a36 1
    "$OpenBSD: gencat.c,v 1.9 2004/07/01 19:23:34 mickey Exp $";
@


1.9
log
@simpilfy warning() and wall
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.8 2003/06/10 22:20:46 deraadt Exp $	*/
d43 1
a43 1
    "$OpenBSD: gencat.c,v 1.8 2003/06/10 22:20:46 deraadt Exp $";
d525 1
a525 2
	for (set = sethead.lh_first; set != NULL;
	    set = set->entries.le_next) {
d528 1
a528 2
		for (msg = set->msghead.lh_first; msg != NULL;
		    msg = msg->entries.le_next) {
d574 1
a574 2
	for (set = sethead.lh_first; set != NULL;
	    set = set->entries.le_next) {
d577 1
a577 2
		for (msg = set->msghead.lh_first; msg != NULL;
		    msg = msg->entries.le_next) {
d620 1
a620 1
	p = sethead.lh_first;
d622 1
a622 1
	for (; p != NULL && p->setId < setId; q = p, p = p->entries.le_next);
d663 1
a663 1
	p = curSet->msghead.lh_first;
d665 1
a665 1
	for (; p != NULL && p->msgId < msgId; q = p, p = p->entries.le_next);
d690 3
a692 2
	set = sethead.lh_first;
	for (; set != NULL && set->setId < setId; set = set->entries.le_next);
d696 1
a696 1
		msg = set->msghead.lh_first;
d716 3
a718 2
	msg = curSet->msghead.lh_first;
	for (; msg != NULL && msg->msgId < msgId; msg = msg->entries.le_next);
@


1.8
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.7 2002/02/16 21:27:46 millert Exp $	*/
d42 2
a43 2
static char rcsid[] =
    "$OpenBSD: gencat.c,v 1.7 2002/02/16 21:27:46 millert Exp $";
d93 3
d185 1
a185 2
	fprintf(stderr, "%s: %s on line %ld\n", __progname, msg, lineno);
	fprintf(stderr, "%s\n", curline);
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.6 2000/09/27 23:53:29 danh Exp $	*/
d43 1
a43 1
    "$OpenBSD: gencat.c,v 1.6 2000/09/27 23:53:29 danh Exp $";
d136 1
a136 1
usage()
d143 1
a143 3
main(argc, argv)
	int     argc;
	char   *argv[];
d180 1
a180 3
warning(cptr, msg)
	char   *cptr;
	char   *msg;
d193 1
a193 3
error(cptr, msg)
	char   *cptr;
	char   *msg;
d200 1
a200 1
nomem()
d206 1
a206 2
xmalloc(len)
	size_t  len;
d216 1
a216 3
xrealloc(ptr, size)
	void   *ptr;
	size_t  size;
d224 1
a224 2
xstrdup(str)
	const char   *str;
d234 1
a234 2
getline(fd)
	int     fd;
d277 1
a277 2
wskip(cptr)
	char   *cptr;
d289 1
a289 2
cskip(cptr)
	char   *cptr;
d301 1
a301 4
getmsg(fd, cptr, quote)
	int     fd;
	char   *cptr;
	char    quote;
d415 1
a415 2
MCParse(fd)
	int     fd;
d501 1
a501 2
MCWriteCat(fd)
	int     fd;
d606 1
a606 2
MCAddSet(setId)
	int     setId;
d646 1
a646 3
MCAddMsg(msgId, str)
	int     msgId;
	const char *str;
d687 1
a687 2
MCDelSet(setId)
	int     setId;
d710 1
a710 2
MCDelMsg(msgId)
	int     msgId;
@


1.6
log
@merged with NetBSD, 20000927 and fixes PR 1421; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencat.c,v 1.5 1997/09/21 10:34:00 jdm Exp $	*/
d43 1
a43 1
    "$OpenBSD$";
d114 19
a132 19
static	char   *cskip __P((char *));
static	void	error __P((char *, char *));
static	void	nomem __P((void));
static	char   *getline __P((int));
static	char   *getmsg __P((int, char *, char));
static	void	warning __P((char *, char *));
static	char   *wskip __P((char *));
static	char   *xstrdup __P((const char *));
static	void   *xmalloc __P((size_t));
static	void   *xrealloc __P((void *, size_t));

void	MCParse __P((int fd));
void	MCWriteCat __P((int fd));
void	MCDelMsg __P((int msgId));
void	MCAddMsg __P((int msgId, const char *msg));
void	MCAddSet __P((int setId));
void	MCDelSet __P((int setId));
int	main __P((int, char **));
void	usage __P((void));
@


1.5
log
@Don't complain loudly about escaped single and double quotes found in
the message text source file (as in the greek .m file in the tcsh port).
It is XPG4 valid to quietly ignore those backslashes.
Also: 8-bit clean, -Wall (removed unused MCReadCat() & corrupt()), and
spelling fixes.
@
text
@d1 2
a2 1
/*	$OpenBSD: gencat.c,v 1.4 1996/06/26 05:33:40 deraadt Exp $	*/
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d40 6
d81 2
a82 1
#define ISSPACE(c) (isascii(c) && isspace(c))
d86 3
a92 9
#include <fcntl.h>
#include <nl_types.h>

extern void MCAddSet __P((int setId));
extern void MCDelSet __P((int setId));
extern void MCAddMsg __P((int msgId, const char *msg));
extern void MCDelMsg __P((int msgId));
extern void MCParse __P((int fd));
extern void MCWriteCat __P((int fd));
d112 23
d138 1
a138 1
	fprintf(stderr, "Use: gencat catfile msgfile ...\n");
d169 2
a170 4
		if ((ifd = open(*argv, O_RDONLY)) < 0) {
			fprintf(stderr, "gencat: Unable to read %s\n", *argv);
			exit(1);
		}
d175 2
a176 5
	if ((ofd = open(catfile, O_WRONLY | O_TRUNC | O_CREAT, 0666)) < 0) {
		fprintf(stderr, "gencat: Unable to create a new %s.\n",
		    catfile);
		exit(1);
	}
d186 1
a186 1
	fprintf(stderr, "gencat: %s on line %ld\n", msg, lineno);
d234 1
a234 1
	char   *str;
d236 3
a238 1
	if ((str = strdup(str)) == NULL)
d240 1
a240 1
	return (str);
d326 1
a326 1
	};
d389 2
a390 1
				case '"': 
d392 1
a392 1
					/* 
d397 1
a397 1
					 * ignored when not used in a
d404 3
a406 1
					if (isdigit(*cptr)) {
d409 1
a409 1
							if (!isdigit(*cptr))
d418 1
a418 1
						warning(cptr, "unrecognized escape sequence; ignoring escape character");
d420 1
d475 10
a484 1
			if (isdigit(*cptr)) {
d489 3
d493 6
a498 1
			if (!*cptr)
d500 1
a500 1
			else {
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 1
a19 1
 *    must display the following acknowledgement:
d73 3
a89 1
extern void MCReadCat __P((int fd));
a185 6
corrupt()
{
	error(NULL, "corrupt message catalog");
}

static void
d269 1
a269 1
	if (!*cptr || !isspace(*cptr)) {
d273 1
a273 1
	while (*cptr && isspace(*cptr))
d282 1
a282 1
	if (!*cptr || isspace(*cptr)) {
d286 1
a286 1
	while (*cptr && !isspace(*cptr))
d304 1
a304 1
	} 
d320 2
a321 2
			if (*tmp && (!isspace(*tmp) || *wskip(tmp))) {
				warning(cptr, "unexpected quote character, ignoreing");
d367 13
d393 1
a393 1
						warning(cptr, "unrecognized escape sequence");
d439 1
a439 1
			} else if (isspace(*cptr)) {
a464 83
void
MCReadCat(fd)
	int     fd;
{
#if 0
	MCHeaderT mcHead;
	MCMsgT  mcMsg;
	MCSetT  mcSet;
	msgT   *msg;
	setT   *set;
	int     i;
	char   *data;

	/* XXX init sethead? */

	if (read(fd, &mcHead, sizeof(mcHead)) != sizeof(mcHead))
		corrupt();
	if (strncmp(mcHead.magic, MCMagic, MCMagicLen) != 0)
		corrupt();
	if (mcHead.majorVer != MCMajorVer)
		error(NULL, "unrecognized catalog version");
	if ((mcHead.flags & MCGetByteOrder()) == 0)
		error(NULL, "wrong byte order");

	if (lseek(fd, mcHead.firstSet, SEEK_SET) == -1)
		corrupt();

	for (;;) {
		if (read(fd, &mcSet, sizeof(mcSet)) != sizeof(mcSet))
			corrupt();
		if (mcSet.invalid)
			continue;

		set = xmalloc(sizeof(setT));
		memset(set, '\0', sizeof(*set));
		if (cat->first) {
			cat->last->next = set;
			set->prev = cat->last;
			cat->last = set;
		} else
			cat->first = cat->last = set;

		set->setId = mcSet.setId;

		/* Get the data */
		if (mcSet.dataLen) {
			data = xmalloc(mcSet.dataLen);
			if (lseek(fd, mcSet.data.off, SEEK_SET) == -1)
				corrupt();
			if (read(fd, data, mcSet.dataLen) != mcSet.dataLen)
				corrupt();
			if (lseek(fd, mcSet.u.firstMsg, SEEK_SET) == -1)
				corrupt();

			for (i = 0; i < mcSet.numMsgs; ++i) {
				if (read(fd, &mcMsg, sizeof(mcMsg)) != sizeof(mcMsg))
					corrupt();
				if (mcMsg.invalid) {
					--i;
					continue;
				}
				msg = xmalloc(sizeof(msgT));
				memset(msg, '\0', sizeof(*msg));
				if (set->first) {
					set->last->next = msg;
					msg->prev = set->last;
					set->last = msg;
				} else
					set->first = set->last = msg;

				msg->msgId = mcMsg.msgId;
				msg->str = xstrdup((char *) (data + mcMsg.msg.off));
			}
			free(data);
		}
		if (!mcSet.nextSet)
			break;
		if (lseek(fd, mcSet.nextSet, SEEK_SET) == -1)
			corrupt();
	}
#endif
}

d638 1
a638 1
		error(NULL, "msgID %d exceeds limit (%d)");
d679 1
a679 1
			LIST_REMOVE(msg, entries)
@


1.3
log
@svr4-style gencat
@
text
@d1 2
@


1.2
log
@sync to netbsd 960418
@
text
@d1 35
d66 1
a66 1
    
d69 1
a69 8
/* Edit History

01/18/91   3 hamilton	#if not reparsed
01/12/91   2 schulert	conditionally use prototypes
12/23/90   2 hamilton	Fix fd == NULL to fd < 0
11/03/90   1 hamilton	Alphalpha->Alfalfa & OmegaMail->Poste
08/13/90   1 schulert	move from ua to omu
*/
d71 2
d74 25
a98 9
#include <sys/types.h>
#ifdef SYSV
#include <sys/fcntl.h>
#define L_SET SEEK_SET
#define L_INCR SEEK_CUR
#endif
#include <sys/file.h>
#include <sys/stat.h>
#include "gencat.h"
d100 2
a101 13
/*
 * The spec says the syntax is "gencat catfile msgfile...".
 * We extend it to:
 * 	gencat [-lang C|C++|ANSIC] catfile msgfile [-h <header-file>]...
 * Flags are order dependant, we'll take whatever lang was most recently chosen
 * and use it to generate the next header file.  The header files are generated
 * at the point in the command line they are listed.  Thus the sequence:
 *	gencat -lang C foo.cat foo.mcs -h foo.h -lang C++ bar.mcs -h bar.H
 * will put constants from foo.mcs into foo.h and constants from bar.mcs into
 * bar.h.  Constants are not saved in the catalog file, so nothing will come
 * from that, even if things have been defined before.  The constants in foo.h
 * will be in C syntax, in bar.H in C++ syntax.
 */
d103 2
a104 5
#if ANSI_C || defined(__cplusplus)
# define P_(x) x
#else
# define P_(x) /**/
#endif
d106 6
a111 1
static void writeIfChanged P_((char *fname, int lang, int orConsts));
d113 19
a131 1
#undef P_
d133 1
a133 49
void usage() {
    fprintf(stderr, "Use: gencat [-new] [-or] [-lang C|C++|ANSIC]\n");
    fprintf(stderr, "            catfile msgfile [-h <header-file>]...\n");
}

int main(
#if ANSI_C || defined(__cplusplus)
		int argc, char *argv[])
#else
		argc, argv)
int argc;
char *argv[];
#endif
{
    int		ofd, ifd, i;
    FILE	*fptr;
    char	*catfile = NULL;
    char	*input = NULL;
    int		lang = MCLangC;
    int		new = False;
    int		orConsts = False;
    
    for (i = 1; i < argc; ++i) {
	if (argv[i][0] == '-') {
	    if (strcmp(argv[i], "-lang") == 0) {
		++i;
		if (strcmp(argv[i], "C") == 0) lang = MCLangC;
		else if (strcmp(argv[i], "C++") == 0) lang = MCLangCPlusPlus;
		else if (strcmp(argv[i], "ANSIC") == 0) lang = MCLangANSIC;
		else {
		    fprintf(stderr, "gencat: Unrecognized language: %s\n", argv[i]);
		    exit(1);
		} 
	    } else if (strcmp(argv[i], "-h") == 0) {
		if (!input) {
		    fprintf(stderr, "gencat: Can't write to a header before reading something.\n");
		    exit(1);
		}
		++i;
		writeIfChanged(argv[i], lang, orConsts);
	    } else if (strcmp(argv[i], "-new") == 0) {
		if (catfile) {
		    fprintf(stderr, "gencat: You must specify -new before the catalog file name\n");
		    exit(1);
		}
		new = True;
	    } else if (strcmp(argv[i], "-or") == 0) {
		orConsts = ~orConsts;
	    } else {
d135 7
a141 8
		exit(1);
	    }
        } else {
	    if (!catfile) {
		catfile = argv[i];
		if (new) {
		    if ((ofd = open(catfile, O_WRONLY|O_TRUNC|O_CREAT, 0666)) < 0) {
			fprintf(stderr, "gencat: Unable to create a new %s.\n", catfile);
a142 19
		    }
		} else if ((ofd = open(catfile, O_RDONLY)) < 0) {
		    if ((ofd = open(catfile, O_WRONLY|O_CREAT, 0666)) < 0) {
			fprintf(stderr, "gencat: Unable to create %s.\n", catfile);
			exit(1);
		    }
		} else {
		    MCReadCat(ofd);
		    close(ofd);
		    if ((ofd = open(catfile, O_WRONLY|O_TRUNC)) < 0) {
			fprintf(stderr, "gencat: Unable to truncate %s.\n", catfile);
			exit(1);
		    }
		}
	    } else {
		input = argv[i];
		if ((ifd = open(input, O_RDONLY)) < 0) {
		    fprintf(stderr, "gencat: Unable to read %s\n", input);
		    exit(1);
a145 1
	    }
d147 6
a152 2
    }
    if (catfile) {
d155 23
a177 2
    } else {
	usage();
a178 1
    }
d181 353
a533 8
static void writeIfChanged(
#if ANSI_C || defined(__cplusplus)
		char *fname, int lang, int orConsts)
#else
		fname, lang, orConsts)
char *fname;
int lang;
int orConsts;
d535 14
d550 209
a758 25
    char	tmpname[32];
    char	buf[BUFSIZ], tbuf[BUFSIZ], *cptr, *tptr;
    int		fd, tfd;
    int		diff = False;
    int		c, len, tlen;
    struct stat	sbuf;

    /* If it doesn't exist, just create it */
    if (stat(fname, &sbuf)) {
	if ((fd = open(fname, O_WRONLY|O_CREAT, 0666)) < 0) {
	    fprintf(stderr, "gencat: Unable to create header file %s.\n", fname);
	    exit(1);
	}
	MCWriteConst(fd, lang, orConsts);
	close(fd);
	return;
    }

    /* If it does exist, create a temp file for now */
    sprintf(tmpname, "/tmp/gencat.%d", (int) getpid());
    if ((tfd = open(tmpname, O_RDWR|O_CREAT, 0666)) < 0) {
	fprintf(stderr, "gencat: Unable to open temporary file: %s\n", tmpname);
	exit(1);
    }
    unlink(tmpname);
d760 5
a764 2
    /* Write to the temp file and rewind */
    MCWriteConst(tfd, lang, orConsts);
d766 2
a767 5
    /* Open the real header file */
    if ((fd = open(fname, O_RDONLY)) < 0) {
	fprintf(stderr, "gencat: Unable to read header file: %s\n", fname);
	exit(1);
    }
d769 2
a770 5
    /* Backup to the start of the temp file */
    if (lseek(tfd, 0L, L_SET) < 0) {
	fprintf(stderr, "gencat: Unable to seek in tempfile: %s\n", tmpname);
	exit(1);
    }
d772 6
a777 32
    /* Now compare them */
    while ((tlen = read(tfd, tbuf, BUFSIZ)) > 0) {
	if ((len = read(fd, buf, BUFSIZ)) != tlen) {
	    diff = True;
	    goto done;
	}
	for (cptr = buf, tptr = tbuf; cptr < buf+len; ++cptr, ++tptr) {
	    if (*tptr != *cptr) {
		diff = True;
		goto done;
	    }
	}
    }
done:    
    if (diff) {
	if (lseek(tfd, 0L, L_SET) < 0) {
	    fprintf(stderr, "gencat: Unable to seek in tempfile: %s\n", tmpname);
	    exit(1);
	}
	close(fd);
	if ((fd = open(fname, O_WRONLY|O_TRUNC)) < 0) {
	    fprintf(stderr, "gencat: Unable to truncate header file: %s\n", fname);
	    exit(1);
	}
	while ((len = read(tfd, buf, BUFSIZ)) > 0) {
	    if (write(fd, buf, len) != len) {
		fprintf(stderr, "gencat: Error writing to header file: %s\n", fname);
	    }
	}
    }
    close(fd);
    close(tfd);
@


1.1
log
@Initial revision
@
text
@d83 1
a83 1
void main(
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
