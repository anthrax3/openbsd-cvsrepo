head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.2
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.31.0.2
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.39
date	2016.10.10.02.22.59;	author gsoares;	state Exp;
branches;
next	1.38;
commitid	cu0lOXNoIrJcLSaR;

1.38
date	2015.10.11.03.08.20;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	L1UJSN4apljqt7fa;

1.37
date	2015.10.10.14.25.42;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	IqU9NfRSva4E05Wq;

1.36
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	Uu5nFG3wCl0LACBb;

1.35
date	2014.05.07.01.27.42;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.12.13.54.51;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.09.22.17.28.34;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2013.06.03.04.17.37;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2012.12.12.22.25.21;	author halex;	state Exp;
branches;
next	1.30;

1.30
date	2012.08.21.10.32.38;	author ajacoutot;	state Exp;
branches;
next	1.29;

1.29
date	2012.08.21.06.28.36;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.10.12.48.08;	author halex;	state Exp;
branches;
next	1.27;

1.27
date	2012.04.21.03.14.50;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2012.04.12.14.59.19;	author pirofti;	state Exp;
branches;
next	1.25;

1.25
date	2012.03.13.09.44.49;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2012.03.01.13.04.29;	author lum;	state Exp;
branches;
next	1.23;

1.23
date	2012.02.16.21.25.35;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2012.02.15.08.19.30;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2012.02.09.20.04.35;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.17.04.27.20;	author lum;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.07.15.38.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.19.05.52.23;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.16.11.48.46;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.20.07.26.49;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.11.20.25.23;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.27.20.56.47;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.27.14.50.09;	author robert;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.02.21.45.53;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.11.17.17.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.29.19.40.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.17.15.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.13.55.10;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.24.18.04.45;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.12.00.19.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.07.02.17.31;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.06.20.07.49;	author millert;	state Exp;
branches;
next	;


desc
@@


1.39
log
@- mark delim variable as const. it is a literal string;
- no need to declare main() prototype;
- mark all functions as static;
- add __dead marker to usage(), since it doesn't return;
- zap extern *optarg/optind in main(), It is already done in unistd.h;
- return from main instead of exit(3) that enables stack protector;
- fix err() eval in pledge()s error path.

OK millert@@
@
text
@/*	$OpenBSD: pkill.c,v 1.38 2015/10/11 03:08:20 deraadt Exp $	*/
/*	$NetBSD: pkill.c,v 1.5 2002/10/27 11:49:34 kleink Exp $	*/

/*-
 * Copyright (c) 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Doran.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/types.h>
#include <sys/sysctl.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <regex.h>
#include <ctype.h>
#include <kvm.h>
#include <err.h>
#include <pwd.h>
#include <grp.h>
#include <errno.h>

#define	STATUS_MATCH	0
#define	STATUS_NOMATCH	1
#define	STATUS_BADUSAGE	2
#define	STATUS_ERROR	3

enum listtype {
	LT_GENERIC,
	LT_USER,
	LT_GROUP,
	LT_TTY,
	LT_PGRP,
	LT_SID,
	LT_RTABLE
};

struct list {
	SLIST_ENTRY(list) li_chain;
	long	li_number;
};

SLIST_HEAD(listhead, list);

struct kinfo_proc	*plist;
char	*selected;
const char	*delim = "\n";
int	nproc;
int	pgrep;
int	signum = SIGTERM;
int	newest;
int	oldest;
int 	quiet;
int	inverse;
int	longfmt;
int	matchargs;
int	fullmatch;
int	confirmkill;
kvm_t	*kd;
pid_t	mypid;

struct listhead euidlist = SLIST_HEAD_INITIALIZER(list);
struct listhead ruidlist = SLIST_HEAD_INITIALIZER(list);
struct listhead rgidlist = SLIST_HEAD_INITIALIZER(list);
struct listhead pgrplist = SLIST_HEAD_INITIALIZER(list);
struct listhead ppidlist = SLIST_HEAD_INITIALIZER(list);
struct listhead tdevlist = SLIST_HEAD_INITIALIZER(list);
struct listhead sidlist = SLIST_HEAD_INITIALIZER(list);
struct listhead rtablist = SLIST_HEAD_INITIALIZER(list);

static void __dead	usage(void);
static int	killact(struct kinfo_proc *, int);
static int	grepact(struct kinfo_proc *, int);
static void	makelist(struct listhead *, enum listtype, char *);
static char	*getargv(struct kinfo_proc *);
static int	askyn(struct kinfo_proc *);

extern char *__progname;

static char *
getargv(struct kinfo_proc *kp)
{
	static char buf[_POSIX2_LINE_MAX];
	char **pargv;
	size_t j;

	if ((pargv = kvm_getargv(kd, kp, 0)) == NULL) {
		strlcpy(buf, kp->p_comm, sizeof(buf));
		return buf;
	}

	j = 0;
	while (j < sizeof(buf) && *pargv != NULL) {
		int ret;

		ret = snprintf(buf + j, sizeof(buf) - j,
		    pargv[1] != NULL ? "%s " : "%s", pargv[0]);
		if (ret >= sizeof(buf) - j)
			j += sizeof(buf) - j - 1;
		else if (ret > 0)
			j += ret;
		pargv++;
	}
	return buf;
}

int
main(int argc, char **argv)
{
	char buf[_POSIX2_LINE_MAX], *mstr, *p, *q;
	int i, j, ch, bestidx, rv, criteria;
	int (*action)(struct kinfo_proc *, int);
	struct kinfo_proc *kp;
	struct list *li;
	u_int32_t bestsec, bestusec;
	regex_t reg;
	regmatch_t regmatch;

	if (strcmp(__progname, "pgrep") == 0) {
		action = grepact;
		pgrep = 1;
	} else {
		action = killact;
		p = argv[1];

		if (argc > 1 && p[0] == '-') {
			p++;
			i = (int)strtol(p, &q, 10);
			if (*q == '\0') {
				signum = i;
				argv++;
				argc--;
			} else {
				if (strncasecmp(p, "sig", 3) == 0)
					p += 3;
				for (i = 1; i < NSIG; i++)
					if (strcasecmp(sys_signame[i], p) == 0)
						break;
				if (i != NSIG) {
					signum = i;
					argv++;
					argc--;
				}
			}
		}
	}

	criteria = 0;

	while ((ch = getopt(argc, argv, "G:P:T:U:d:fg:Ilnoqs:t:u:vx")) != -1)
		switch (ch) {
		case 'G':
			makelist(&rgidlist, LT_GROUP, optarg);
			criteria = 1;
			break;
		case 'P':
			makelist(&ppidlist, LT_GENERIC, optarg);
			criteria = 1;
			break;
		case 'T':
			makelist(&rtablist, LT_RTABLE, optarg);
			criteria = 1;
			break;
		case 'U':
			makelist(&ruidlist, LT_USER, optarg);
			criteria = 1;
			break;
		case 'd':
			if (!pgrep)
				usage();
			delim = optarg;
			break;
		case 'f':
			matchargs = 1;
			break;
		case 'g':
			makelist(&pgrplist, LT_PGRP, optarg);
			criteria = 1;
			break;
		case 'I':
			confirmkill = 1;
			break;
		case 'l':
			longfmt = 1;
			break;
		case 'n':
			newest = 1;
			criteria = 1;
			break;
		case 'o':
			oldest = 1;
			criteria = 1;
			break;
		case 'q':
			quiet = 1;
			break;
		case 's':
			makelist(&sidlist, LT_SID, optarg);
			criteria = 1;
			break;
		case 't':
			makelist(&tdevlist, LT_TTY, optarg);
			criteria = 1;
			break;
		case 'u':
			makelist(&euidlist, LT_USER, optarg);
			criteria = 1;
			break;
		case 'v':
			inverse = 1;
			break;
		case 'x':
			fullmatch = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}

	argc -= optind;
	argv += optind;
	if (argc != 0)
		criteria = 1;
	if (!criteria || (newest && oldest))
		usage();

	mypid = getpid();

	/*
	 * Retrieve the list of running processes from the kernel.
	 */
	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, buf);
	if (kd == NULL)
		errx(STATUS_ERROR, "kvm_openfiles(): %s", buf);

	plist = kvm_getprocs(kd, KERN_PROC_ALL, 0, sizeof(*plist), &nproc);
	if (plist == NULL)
		errx(STATUS_ERROR, "kvm_getprocs() failed");

	if (matchargs == 0 && confirmkill == 0) {
		if (action == killact) {
			if (pledge("stdio proc", NULL) == -1)
				err(STATUS_ERROR, "pledge");
		} else if (action == grepact) {
			if (pledge("stdio", NULL) == -1)
				err(STATUS_ERROR, "pledge");
		}
	}

	/*
	 * Allocate memory which will be used to keep track of the
	 * selection.
	 */
	if ((selected = calloc(nproc, 1)) == NULL)
		errx(STATUS_ERROR, "memory allocation failure");

	/*
	 * Refine the selection.
	 */
	for (; *argv != NULL; argv++) {
		if ((rv = regcomp(&reg, *argv, REG_EXTENDED)) != 0) {
			regerror(rv, &reg, buf, sizeof(buf));
			errx(STATUS_BADUSAGE, "bad expression: %s", buf);
		}

		for (i = 0, kp = plist; i < nproc; i++, kp++) {
			if ((kp->p_flag & (P_SYSTEM | P_THREAD)) != 0 ||
			     kp->p_pid == mypid)
				continue;

			if (matchargs)
				mstr = getargv(kp);
			else
				mstr = kp->p_comm;

			rv = regexec(&reg, mstr, 1, &regmatch, 0);
			if (rv == 0) {
				if (fullmatch) {
					if (regmatch.rm_so == 0 &&
					    regmatch.rm_eo == strlen(mstr))
						selected[i] = 1;
				} else
					selected[i] = 1;
			} else if (rv != REG_NOMATCH) {
				regerror(rv, &reg, buf, sizeof(buf));
				errx(STATUS_ERROR, "regexec(): %s", buf);
			}
		}

		regfree(&reg);
	}

	for (i = 0, kp = plist; i < nproc; i++, kp++) {
		if ((kp->p_flag & (P_SYSTEM | P_THREAD)) != 0 ||
		     kp->p_pid == mypid)
			continue;

		SLIST_FOREACH(li, &ruidlist, li_chain)
			if (kp->p_ruid == (uid_t)li->li_number)
				break;
		if (SLIST_FIRST(&ruidlist) != NULL && li == NULL) {
			selected[i] = 0;
			continue;
		}

		SLIST_FOREACH(li, &rgidlist, li_chain)
			if (kp->p_rgid == (gid_t)li->li_number)
				break;
		if (SLIST_FIRST(&rgidlist) != NULL && li == NULL) {
			selected[i] = 0;
			continue;
		}

		SLIST_FOREACH(li, &euidlist, li_chain)
			if (kp->p_uid == (uid_t)li->li_number)
				break;
		if (SLIST_FIRST(&euidlist) != NULL && li == NULL) {
			selected[i] = 0;
			continue;
		}

		SLIST_FOREACH(li, &ppidlist, li_chain)
			if (kp->p_ppid == (uid_t)li->li_number)
				break;
		if (SLIST_FIRST(&ppidlist) != NULL && li == NULL) {
			selected[i] = 0;
			continue;
		}

		SLIST_FOREACH(li, &pgrplist, li_chain)
			if (kp->p__pgid == (uid_t)li->li_number)
				break;
		if (SLIST_FIRST(&pgrplist) != NULL && li == NULL) {
			selected[i] = 0;
			continue;
		}

		SLIST_FOREACH(li, &tdevlist, li_chain) {
			if (li->li_number == -1 &&
			    (kp->p_psflags & PS_CONTROLT) == 0)
				break;
			if (kp->p_tdev == (uid_t)li->li_number)
				break;
		}
		if (SLIST_FIRST(&tdevlist) != NULL && li == NULL) {
			selected[i] = 0;
			continue;
		}

		SLIST_FOREACH(li, &sidlist, li_chain)
			if (kp->p_sid == (uid_t)li->li_number)
				break;
		if (SLIST_FIRST(&sidlist) != NULL && li == NULL) {
			selected[i] = 0;
			continue;
		}

		SLIST_FOREACH(li, &rtablist, li_chain)
			if (kp->p_rtableid == (u_int32_t)li->li_number)
				break;
		if (SLIST_FIRST(&rtablist) != NULL && li == NULL) {
			selected[i] = 0;
			continue;
		}

		if (argc == 0)
			selected[i] = 1;
	}

	if (newest || oldest) {
		bestidx = -1;

		if (newest)
			bestsec = bestusec = 0;
		else
			bestsec = bestusec = UINT32_MAX;

		for (i = 0, kp = plist; i < nproc; i++, kp++) {
			if (!selected[i])
				continue;

			if ((newest && (kp->p_ustart_sec > bestsec ||
			    (kp->p_ustart_sec == bestsec
			    && kp->p_ustart_usec > bestusec)))
			|| (oldest && (kp->p_ustart_sec < bestsec ||
                            (kp->p_ustart_sec == bestsec
                            && kp->p_ustart_usec < bestusec)))) {

				bestsec = kp->p_ustart_sec;
				bestusec = kp->p_ustart_usec;
				bestidx = i;
			}
		}

		memset(selected, 0, nproc);
		if (bestidx != -1)
			selected[bestidx] = 1;
	}

	/*
	 * Take the appropriate action for each matched process, if any.
	 */
	rv = STATUS_NOMATCH;
	for (i = 0, j = 0, kp = plist; i < nproc; i++, kp++) {
		if ((kp->p_flag & (P_SYSTEM | P_THREAD)) != 0 ||
		     kp->p_pid == mypid)
			continue;
		if (selected[i] == inverse)
			continue;

		switch ((*action)(kp, j++)) {
		case STATUS_MATCH:
			if (rv != STATUS_ERROR)
				rv = STATUS_MATCH;
			break;
		case STATUS_NOMATCH:
			j--;
			break;
		case STATUS_ERROR:
			rv = STATUS_ERROR;
			break;
		}
	}
	if (pgrep && j && !quiet)
		putchar('\n');

	return(rv);
}

static void __dead
usage(void)
{
	const char *ustr;

	if (pgrep)
		ustr = "[-flnoqvx] [-d delim]";
	else
		ustr = "[-signal] [-fIlnoqvx]";

	fprintf(stderr, "usage: %s %s [-G gid] [-g pgrp] [-P ppid] [-s sid]"
	    "\n\t[-T rtable] [-t tty] [-U uid] [-u euid] [pattern ...]\n",
	    __progname, ustr);

	exit(STATUS_BADUSAGE);
}

static int
askyn(struct kinfo_proc *kp)
{
	int first, ch;

	printf("kill %d %.60s? ", (int)kp->p_pid, getargv(kp));
	fflush(stdout);

	first = ch = getchar();
	while (ch != '\n' && ch != EOF)
		ch = getchar();
	return (first == 'y' || first == 'Y');
}

static int
killact(struct kinfo_proc *kp, int dummy)
{
	int doit;

	if (confirmkill) {
		doit = askyn(kp);
	} else {
		if (longfmt && !quiet)
			printf("%d %s\n", (int)kp->p_pid, kp->p_comm);
		doit = 1;
	}

	if (doit && kill(kp->p_pid, signum) == -1) {
		if (errno == ESRCH)
			return (STATUS_NOMATCH);
		warn("signalling pid %d", (int)kp->p_pid);
		return (STATUS_ERROR);
	}
	return (STATUS_MATCH);
}

static int
grepact(struct kinfo_proc *kp, int printdelim)
{
	char **argv;

	if (quiet)
		return (STATUS_MATCH);
	if (longfmt && matchargs)
		if ((argv = kvm_getargv(kd, kp, 0)) == NULL)
			return (errno == ESRCH ? STATUS_NOMATCH : STATUS_ERROR);
	if (printdelim)
		fputs(delim, stdout);
	if (longfmt && matchargs) {
		printf("%d ", (int)kp->p_pid);
		for (; *argv != NULL; argv++) {
			printf("%s", *argv);
			if (argv[1] != NULL)
				putchar(' ');
		}
	} else if (longfmt)
		printf("%d %s", (int)kp->p_pid, kp->p_comm);
	else
		printf("%d", (int)kp->p_pid);

	return (STATUS_MATCH);
}

static void
makelist(struct listhead *head, enum listtype type, char *src)
{
	struct list *li;
	struct passwd *pw;
	struct group *gr;
	struct stat st;
	char *sp, *p, buf[PATH_MAX];
	int empty;

	empty = 1;

	while ((sp = strsep(&src, ",")) != NULL) {
		if (*sp == '\0')
			usage();

		if ((li = malloc(sizeof(*li))) == NULL)
			errx(STATUS_ERROR, "memory allocation failure");
		SLIST_INSERT_HEAD(head, li, li_chain);
		empty = 0;

		li->li_number = strtol(sp, &p, 0);
		if (*p == '\0') {
			switch (type) {
			case LT_PGRP:
				if (li->li_number == 0)
					li->li_number = getpgrp();
				break;
			case LT_SID:
				if (li->li_number == 0)
					li->li_number = getsid(mypid);
				break;
			case LT_RTABLE:
				if (li->li_number < 0 ||
				    li->li_number > RT_TABLEID_MAX)
					errx(STATUS_BADUSAGE,
					    "rtable out of range");
				break;
			case LT_TTY:
				usage();
			default:
				break;
			}
			continue;
		}

		switch (type) {
		case LT_USER:
			if ((pw = getpwnam(sp)) == NULL)
				errx(STATUS_BADUSAGE, "unknown user `%s'", sp);
			li->li_number = pw->pw_uid;
			break;
		case LT_GROUP:
			if ((gr = getgrnam(sp)) == NULL)
				errx(STATUS_BADUSAGE, "unknown group `%s'", sp);
			li->li_number = gr->gr_gid;
			break;
		case LT_TTY:
			if (strcmp(sp, "-") == 0) {
				li->li_number = -1;
				break;
			} else if (strcmp(sp, "co") == 0)
				p = "console";
			else if (strncmp(sp, "tty", 3) == 0)
				p = sp;
			else
				p = NULL;

			if (p == NULL)
				snprintf(buf, sizeof(buf), "/dev/tty%s", sp);
			else
				snprintf(buf, sizeof(buf), "/dev/%s", p);

			if (stat(buf, &st) < 0) {
				if (errno == ENOENT)
					errx(STATUS_BADUSAGE,
					    "no such tty: `%s'", sp);
				err(STATUS_ERROR, "stat(%s)", sp);
			}

			if (!S_ISCHR(st.st_mode))
				errx(STATUS_BADUSAGE, "not a tty: `%s'", sp);

			li->li_number = st.st_rdev;
			break;
		default:
			usage();
		}
	}

	if (empty)
		usage();
}
@


1.38
log
@fix a regression spotted by chris@@.  the -f and -I arguments fetch process
arguments using kvm_getargs, after the pledge() has been made.  someone
brave should refactor this, hoisting the argument fetching to between
kvm_getprocs() and pledge() - storing the argument data as neccessary.
the current situation is also a race -- it fetches the data twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.37 2015/10/10 14:25:42 deraadt Exp $	*/
d80 1
a80 1
char	*delim = "\n";
d104 6
a109 7
int	main(int, char **);
void	usage(void);
int	killact(struct kinfo_proc *, int);
int	grepact(struct kinfo_proc *, int);
void	makelist(struct listhead *, enum listtype, char *);
char	*getargv(struct kinfo_proc *);
int	askyn(struct kinfo_proc *);
d113 1
a113 1
char *
a142 2
	extern char *optarg;
	extern int optind;
d276 1
a276 1
				err(1, "pledge");
d279 1
a279 1
				err(1, "pledge");
d460 1
a460 1
	exit(rv);
d463 1
a463 1
void
d480 1
a480 1
int
d494 1
a494 1
int
d516 1
a516 1
int
d543 1
a543 1
void
@


1.37
log
@pkill has to get all the getopt, getpwuid, libkvm stuff out of the way
first.  it can pledge to "stdio" (pgrep case) or "stdio proc" (pkill case)
before parsing and matching the expression.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.36 2015/01/16 06:40:10 deraadt Exp $	*/
a85 1
char	*pledge_choice = "stdio proc";
a156 1
		pledge_choice = "stdio";
d276 9
a284 2
	if (pledge(pledge_choice, NULL) == -1)
		err(1, "pledge");
@


1.36
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.35 2014/05/07 01:27:42 tedu Exp $	*/
d86 1
d158 1
d277 3
@


1.35
log
@calloc, from peter malone
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.34 2013/11/12 13:54:51 deraadt Exp $	*/
d33 1
a34 1
#include <sys/param.h>
d543 1
a543 1
	char *sp, *p, buf[MAXPATHLEN];
@


1.34
log
@simpler prototype repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.33 2013/09/22 17:28:34 guenther Exp $	*/
d280 1
a280 1
	if ((selected = malloc(nproc)) == NULL)
a281 1
	memset(selected, 0, nproc);
@


1.33
log
@Stop merging the per-thread and per-process flags when reporting
them via sysctl(KERN_PROC).  In struct kinfo_proc the per-process
flags move to p_psflags, leaving the per-thread flags in p_flags.
Flag descriptions in ps(1) updated to be less obtuse.

discussed with matthew@@ some time ago; ok jca@@, manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.32 2013/06/03 04:17:37 tedu Exp $	*/
d109 2
@


1.32
log
@-I to confirm pkills. ok many
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.31 2012/12/12 22:25:21 halex Exp $	*/
d365 1
a365 1
			    (kp->p_flag & P_CONTROLT) == 0)
@


1.31
log
@properly handle the case where a process has disappeared in between grep'ing
and printing it

discussed with and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.30 2012/08/21 10:32:38 ajacoutot Exp $	*/
d91 1
d112 27
d144 1
a144 1
	char buf[_POSIX2_LINE_MAX], *mstr, **pargv, *p, *q;
d184 1
a184 1
	while ((ch = getopt(argc, argv, "G:P:T:U:d:fg:lnoqs:t:u:vx")) != -1)
d214 3
d296 3
a298 20
			if (matchargs) {
				if ((pargv = kvm_getargv(kd, kp, 0)) == NULL)
					continue;

				j = 0;
				while (j < sizeof(buf) && *pargv != NULL) {
					int ret;

					ret = snprintf(buf + j, sizeof(buf) - j,
					    pargv[1] != NULL ? "%s " : "%s",
					    pargv[0]);
					if (ret >= sizeof(buf) - j)
						j += sizeof(buf) - j - 1;
					else if (ret > 0)
						j += ret;
					pargv++;
				}

				mstr = buf;
			} else
d463 1
a463 1
		ustr = "[-signal] [-flnoqvx]";
d473 14
d489 9
a497 2
	if (longfmt && !quiet)
		printf("%d %s\n", (int)kp->p_pid, kp->p_comm);
d499 1
a499 1
	if (kill(kp->p_pid, signum) == -1) {
@


1.30
log
@Missing "-q" in usage().

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.29 2012/08/21 06:28:36 espie Exp $	*/
d422 9
a430 1
		if ((*action)(kp, j++) == -1)
d432 2
a433 2
		else if (rv != STATUS_ERROR)
			rv = STATUS_MATCH;
d464 3
a466 1
	if (kill(kp->p_pid, signum) == -1 && errno != ESRCH) {
d468 1
a468 1
		return (-1);
d470 1
a470 1
	return (0);
d479 4
a482 1
		return (0);
a485 3
		if ((argv = kvm_getargv(kd, kp, 0)) == NULL)
			return (-1);

d497 1
a497 1
	return (0);
@


1.29
log
@add -q "silent" option similar to grep
okay ajacoutot@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.28 2012/07/10 12:48:08 halex Exp $	*/
d439 1
a439 1
		ustr = "[-flnovx] [-d delim]";
d441 1
a441 1
		ustr = "[-signal] [-flnovx]";
@


1.28
log
@make pkill -l print the proper processes also when the invert (-v)
flag is passed

ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.27 2012/04/21 03:14:50 guenther Exp $	*/
d86 1
d156 1
a156 1
	while ((ch = getopt(argc, argv, "G:P:T:U:d:fg:lnos:t:u:vx")) != -1)
d197 3
d427 1
a427 1
	if (pgrep && j)
d453 1
a453 1
	if (longfmt)
d468 2
@


1.27
log
@Remove a check made superfluous by the KERN_PROC_SHOW_THREADS flag.
This lets new binaries work (at least w/o the -H option) with old kernels.

ok pirofti@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.26 2012/04/12 14:59:19 pirofti Exp $	*/
d415 1
a415 6
		if (selected[i]) {
			if (longfmt && !pgrep)
				printf("%d %s\n", (int)kp->p_pid, kp->p_comm);
			if (inverse)
				continue;
		} else if (!inverse)
d449 2
@


1.26
log
@Add per thread accounting, mainly for usage & friends.

This expands the already bloated FILL_KPROC macro to take an extra
parameter that indicates if the callee is a thread or a process.

The userland bits are adjusted accordingly and ps(1) and top(1) now
display per thread usage times when -H is used.

Also pkill(1) had to be adjusted so that duplicates don't pop up.

libkvm does basically the same thing as the kernel bits.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.25 2012/03/13 09:44:49 sthen Exp $	*/
a258 2
				continue;
			if (kp->p_tid != -1)
@


1.25
log
@Teach pgrep/pkill to only match processes, not threads. ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.24 2012/03/01 13:04:29 lum Exp $	*/
d259 2
@


1.24
log
@Remove unused variable. Added in 1.20 by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.23 2012/02/16 21:25:35 jmc Exp $	*/
d257 2
a258 1
			if ((kp->p_flag & P_SYSTEM) != 0 || kp->p_pid == mypid)
d301 2
a302 1
		if ((kp->p_flag & P_SYSTEM) != 0 || kp->p_pid == mypid)
d412 2
a413 1
		if ((kp->p_flag & P_SYSTEM) != 0 || kp->p_pid == mypid)
@


1.23
log
@exit usage() with STATUS_BADUSAGE rather than STATUS_ERROR, per the man page;

fix proposed by lum actually happened in netbsd -r1.16, some 6 years ago;
ok lum
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.22 2012/02/15 08:19:30 jmc Exp $	*/
a117 1
	int did_action;
a407 1
	did_action = 0;
d413 1
a413 2
			if (longfmt && !pgrep) {
				did_action = 1;
a414 1
			}
@


1.22
log
@avoid usage() warping onto the next line;
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.21 2012/02/09 20:04:35 markus Exp $	*/
d449 1
a449 1
	exit(STATUS_ERROR);
@


1.21
log
@restrict pkill/pgrep to the routing domain specified by -T; ok henning@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.20 2012/01/17 04:27:20 lum Exp $	*/
d445 2
a446 2
	fprintf(stderr, "usage: %s %s [-G gid] [-g pgrp] [-P ppid] [-s sid] "
	    "[-T rtable]\n\t[-t tty] [-U uid] [-u euid] [pattern ...]\n",
@


1.20
log
@Allow pkill to use the -l option. This displays which processes have been
signalled using the "Long" format, like pgrep.

Original diff from FreeBSD, modified somewhat on tech@@, with feedback from nicm@@

Man page input from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.19 2011/04/10 03:20:59 guenther Exp $	*/
d39 1
d67 2
a68 1
	LT_SID
d100 1
d156 1
a156 1
	while ((ch = getopt(argc, argv, "G:P:U:d:fg:lnos:t:u:vx")) != -1)
d166 4
d364 8
d446 2
a447 1
	    "[-t tty]\n\t[-U uid] [-u euid] [pattern ...]\n", __progname, ustr);
d509 1
a509 1
		li->li_number = (uid_t)strtol(sp, &p, 0);
d519 6
@


1.19
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.18 2009/10/27 23:59:41 deraadt Exp $	*/
d115 1
a179 2
			if (!pgrep)
				usage();
d394 1
d400 4
d428 1
a428 1
		ustr = "[-signal] [-fnovx]";
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.17 2008/06/26 05:42:21 ray Exp $	*/
d76 1
a76 1
struct kinfo_proc2	*plist;
d101 2
a102 2
int	killact(struct kinfo_proc2 *, int);
int	grepact(struct kinfo_proc2 *, int);
d114 2
a115 2
	int (*action)(struct kinfo_proc2 *, int);
	struct kinfo_proc2 *kp;
d230 1
a230 1
	plist = kvm_getproc2(kd, KERN_PROC_ALL, 0, sizeof(*plist), &nproc);
d232 1
a232 1
		errx(STATUS_ERROR, "kvm_getproc2() failed");
d256 1
a256 1
				if ((pargv = kvm_getargv2(kd, kp, 0)) == NULL)
d433 1
a433 1
killact(struct kinfo_proc2 *kp, int dummy)
d444 1
a444 1
grepact(struct kinfo_proc2 *kp, int printdelim)
d451 1
a451 1
		if ((argv = kvm_getargv2(kd, kp, 0)) == NULL)
@


1.17
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.16 2008/02/07 15:38:07 millert Exp $	*/
a31 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.16 2008/02/07 15:38:07 millert Exp $";
#endif /* !lint */
@


1.16
log
@Add add -o flag to pkill/pgrep like on Solaris and Linux.
OK jmc@@ henning@@ oga@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.15 2006/09/19 05:52:23 otto Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.15 2006/09/19 05:52:23 otto Exp $";
@


1.15
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
Paul Stoeber, more to come. ok millert@@ pedro@@ jaredy@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.14 2005/07/16 11:48:46 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.14 2005/07/16 11:48:46 jmc Exp $";
d53 1
d94 1
d163 1
a163 1
	while ((ch = getopt(argc, argv, "G:P:U:d:fg:lns:t:u:vx")) != -1)
d198 4
d229 1
a229 1
	if (!criteria)
d373 1
a373 3
	if (newest) {
		bestsec = 0;
		bestusec = 0;
d376 5
d385 1
a385 1
			if (kp->p_ustart_sec > bestsec ||
d387 5
a391 1
			    && kp->p_ustart_usec > bestusec)) {
d433 1
a433 1
		ustr = "[-flnvx] [-d delim]";
d435 1
a435 1
		ustr = "[-signal] [-fnvx]";
@


1.14
log
@sort options and sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.13 2005/05/20 07:26:49 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.13 2005/05/20 07:26:49 otto Exp $";
d540 1
a540 1
			if ((st.st_mode & S_IFCHR) == 0)
@


1.13
log
@Don't print an empty line when no match is found in pgrep mode.
ok millert@@ robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.12 2005/04/11 20:25:23 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.12 2005/04/11 20:25:23 deraadt Exp $";
d424 2
a425 2
	fprintf(stderr, "usage: %s %s [-G gid] [-P ppid] [-U uid] [-g pgrp] "
	    "[-s sid] [-t tty] [-u euid] pattern ...\n", __progname, ustr);
@


1.12
log
@handle snprintf return value overflow case; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.11 2005/03/27 20:56:47 robert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.11 2005/03/27 20:56:47 robert Exp $";
d408 1
a408 1
	if (pgrep)
@


1.11
log
@revert r1.9; this one needs more discussion
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.10 2005/03/27 14:50:09 robert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.10 2005/03/27 14:50:09 robert Exp $";
d271 3
a273 1
					if (ret > 0)
@


1.10
log
@add a -i option to ignore case distinctions in the process match;
From: NetBSD; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.9 2005/03/02 21:45:53 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.9 2005/03/02 21:45:53 otto Exp $";
a96 1
int	cflags = REG_EXTENDED;
d161 1
a161 1
	while ((ch = getopt(argc, argv, "G:P:U:d:fg:ilns:t:u:vx")) != -1)
a186 3
		case 'i':
			cflags |= REG_ICASE;
			break;
d251 1
a251 1
		if ((rv = regcomp(&reg, *argv, cflags)) != 0) {
d418 1
a418 1
		ustr = "[-filnvx] [-d delim]";
d420 1
a420 1
		ustr = "[-signal] [-finvx]";
@


1.9
log
@Report non-existing user or groupname correctly. From David Brownlee
<abs@@netbsd>. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.8 2005/02/11 17:17:45 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.8 2005/02/11 17:17:45 millert Exp $";
d97 1
d162 1
a162 1
	while ((ch = getopt(argc, argv, "G:P:U:d:fg:lns:t:u:vx")) != -1)
d188 3
d255 1
a255 1
		if ((rv = regcomp(&reg, *argv, REG_EXTENDED)) != 0) {
d422 1
a422 1
		ustr = "[-flnvx] [-d delim]";
d424 1
a424 1
		ustr = "[-signal] [-fnvx]";
@


1.8
log
@Fix -d option; it should print a newline at EOL, not the specified delimeter.
Problem found and OK by robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.7 2004/12/29 19:40:36 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.7 2004/12/29 19:40:36 deraadt Exp $";
d507 1
a507 2
				errx(STATUS_BADUSAGE, "unknown user `%s'",
				    optarg);
d512 1
a512 2
				errx(STATUS_BADUSAGE, "unknown group `%s'",
				    optarg);
@


1.7
log
@handle snprintf -1; otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.6 2004/07/15 17:15:33 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.6 2004/07/15 17:15:33 millert Exp $";
d110 2
a111 2
int	killact(struct kinfo_proc2 *);
int	grepact(struct kinfo_proc2 *);
d123 1
a123 1
	int (*action)(struct kinfo_proc2 *);
d391 2
a392 1
	for (i = 0, rv = STATUS_NOMATCH, kp = plist; i < nproc; i++, kp++) {
d401 1
a401 1
		if ((*action)(kp) == -1)
d406 2
d429 1
a429 1
killact(struct kinfo_proc2 *kp)
d440 1
a440 1
grepact(struct kinfo_proc2 *kp)
d444 2
a460 1
	printf("%s", delim);
@


1.6
log
@Don't print a warning if kill(2) returns ESRCH since the process may have
died on its own in the time between when the process list was consulted
and when we do the actual kill.  This fixes an annoyance for privsep
processes (and others) where when you kill one the others die by themselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.5 2004/07/15 13:55:10 mpech Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.5 2004/07/15 13:55:10 mpech Exp $";
d266 3
a268 1
					j += snprintf(buf + j, sizeof(buf) - j,
d271 2
@


1.5
log
@Skip SYSTEM and ourown proccess on every loop.

millert@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.4 2004/06/24 18:04:45 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.4 2004/06/24 18:04:45 millert Exp $";
d425 1
a425 1
	if (kill(kp->p_pid, signum) == -1) {
@


1.4
log
@When given multiple processes to kill, keep going if we are unable to kill
one (previously it would error out and not kill the remaining ones).
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.3 2004/03/12 00:19:48 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.3 2004/03/12 00:19:48 deraadt Exp $";
d294 1
a294 1
		if ((kp->p_flag & P_SYSTEM) != 0)
d388 1
a388 1
		if (kp->p_pid == mypid)
a393 3
			continue;

		if ((kp->p_flag & P_SYSTEM) != 0)
@


1.3
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.2 2004/01/07 02:17:31 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.2 2004/01/07 02:17:31 millert Exp $";
d110 2
a111 2
void	killact(struct kinfo_proc2 *);
void	grepact(struct kinfo_proc2 *);
d123 1
a123 1
	void (*action)(struct kinfo_proc2 *);
d387 1
a387 1
	for (i = 0, rv = 0, kp = plist; i < nproc; i++, kp++) {
d399 4
a402 2
		rv = 1;
		(*action)(kp);
d405 1
a405 1
	exit(rv ? STATUS_MATCH : STATUS_NOMATCH);
d424 1
a424 1
void
d428 5
a432 2
	if (kill(kp->p_pid, signum) == -1)
		err(STATUS_ERROR, "signalling pid %d", (int)kp->p_pid);
d435 1
a435 1
void
d442 1
a442 1
			return;
d456 1
@


1.2
log
@Convert back to using kvm_getproc2() and friends now that libkvm
supports it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pkill.c,v 1.1 2004/01/06 20:07:49 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pkill.c,v 1.1 2004/01/06 20:07:49 millert Exp $";
d304 1
a304 1
	
d373 2
a374 2
			    	bestsec = kp->p_ustart_sec;
			    	bestusec = kp->p_ustart_usec;
d536 1
a536 1
		};
@


1.1
log
@pkill/pgrep from NetBSD with changes to use kvm_getprocs().  Selecting
on session ID does not current work but that will change once the
kernel supports the KERN_PROC2 sysctl and pkill/pgrep is modified
to use kvm_getproc2().  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD$";
d86 1
a86 1
struct kinfo_proc	*plist;
d110 2
a111 2
void	killact(struct kinfo_proc *);
void	grepact(struct kinfo_proc *);
d121 1
a121 1
	char buf[_POSIX2_LINE_MAX], *mstr, **pargv, *cp, *q;
d123 2
a124 2
	void (*action)(struct kinfo_proc *);
	struct kinfo_proc *kp;
d126 1
a126 1
	struct timeval besttime;
d135 1
a135 1
		cp = argv[1];
d137 3
a139 3
		if (argc > 1 && *cp == '-') {
			cp++;
			i = (int)strtol(cp, &q, 10);
d145 2
a146 2
				if (strncasecmp(cp, "sig", 3) == 0)
					cp += 3;
d148 1
a148 1
					if (strcasecmp(sys_signame[i], cp) == 0)
d235 1
a235 1
	plist = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc);
d237 1
a237 1
		errx(STATUS_ERROR, "kvm_getprocs() failed");
d257 1
a257 3
			struct proc *p = &kp->kp_proc;

			if ((p->p_flag & P_SYSTEM) != 0 || p->p_pid == mypid)
d261 1
a261 1
				if ((pargv = kvm_getargv(kd, kp, 0)) == NULL)
d274 1
a274 1
				mstr = p->p_comm;
d294 1
a294 4
		struct eproc *ep = &kp->kp_eproc;
		struct proc *p = &kp->kp_proc;

		if ((p->p_flag & P_SYSTEM) != 0)
d298 1
a298 1
			if (ep->e_pcred.p_ruid == (uid_t)li->li_number)
d306 1
a306 1
			if (ep->e_pcred.p_rgid == (gid_t)li->li_number)
d314 1
a314 1
			if (ep->e_ucred.cr_uid == (uid_t)li->li_number)
d322 1
a322 1
			if (ep->e_ppid == (uid_t)li->li_number)
d330 1
a330 1
			if (ep->e_pgid == (uid_t)li->li_number)
d339 1
a339 1
			    (p->p_flag & P_CONTROLT) == 0)
d341 1
a341 1
			if (ep->e_tdev == (uid_t)li->li_number)
a348 1
#if 0	/* XXX - where is session id in kernel? */
d350 1
a350 1
			if (ep->p_sid == (uid_t)li->li_number)
a355 1
#endif
d362 2
a363 1
		timerclear(&besttime);
a366 2
			struct timeval *tv = &kp->kp_eproc.e_pstats.p_start;

d370 5
a374 2
			if (timercmp(tv, &besttime, >)) {
				besttime = *tv;
d388 1
a388 3
		struct proc *p = &kp->kp_proc;

		if (p->p_pid == mypid)
d396 1
a396 1
		if ((p->p_flag & P_SYSTEM) != 0)
d423 1
a423 1
killact(struct kinfo_proc *kp)
d426 2
a427 2
	if (kill(kp->kp_proc.p_pid, signum) == -1)
		err(STATUS_ERROR, "signalling pid %d", (int)kp->kp_proc.p_pid);
d431 1
a431 1
grepact(struct kinfo_proc *kp)
d436 1
a436 1
		if ((argv = kvm_getargv(kd, kp, 0)) == NULL)
d439 1
a439 1
		printf("%d ", (int)kp->kp_proc.p_pid);
d446 1
a446 1
		printf("%d %s", (int)kp->kp_proc.p_pid, kp->kp_proc.p_comm);
d448 1
a448 1
		printf("%d", (int)kp->kp_proc.p_pid);
@

