head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.23.0.6
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.16
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.12
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.10
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.10
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.03.22.18.24.34;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	526fcdXLFx66Bo7m;

1.32
date	2015.12.11.20.25.47;	author mmcc;	state Exp;
branches;
next	1.31;
commitid	imdifMlAvt2nFvdW;

1.31
date	2014.12.05.04.03.57;	author jsg;	state Exp;
branches;
next	1.30;
commitid	moqVGrAHdAs0abuM;

1.30
date	2014.12.02.15.56.22;	author millert;	state Exp;
branches;
next	1.29;
commitid	fTMubrWaxIK4TBKX;

1.29
date	2014.10.09.03.02.18;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	qlgFRitXWDoTjAoD;

1.28
date	2014.03.13.01.18.22;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.03.13.00.33.55;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.10.23.01.29;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.08.22.55.59;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.08.21.40.25;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.15.12.44.38;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.14.13.13.42;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.21.07.38.16;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.20.04.22.10;	author cloder;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.10.16.40.45;	author pvalchev;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.08.20.13.13;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.06.05.35.26;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.19.16.34.53;	author pvalchev;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.08.00.18.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.13.09.09.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.16.06.29.45;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.12.05.17.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.11.24.01.21.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.23.45.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.31.04.56.01;	author etheisen;	state Exp;
branches;
next	1.3;

1.3
date	96.03.27.19.33.19;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.04.08.37.02;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.06;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@merge three obviously redundant adjacent if statements

from Michael W. Bombardieri
@
text
@/* $OpenBSD: reader.c,v 1.32 2015/12/11 20:25:47 mmcc Exp $	 */
/* $NetBSD: reader.c,v 1.5 1996/03/19 03:21:43 jtc Exp $	 */

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <limits.h>
#include "defs.h"

/* The line size must be a positive integer.  One hundred was chosen	 */
/* because few lines in Yacc input grammars exceed 100 characters.	 */
/* Note that if a line exceeds LINESIZE characters, the line buffer	 */
/* will be expanded to accommodate it.					 */

#define LINESIZE 100

char *cache;
int cinc, cache_size;

int ntags, tagmax;
char **tag_table;

char saw_eof, unionized;
char *cptr, *line;
int linesize;

bucket *goal;
int prec;
int gensym;
char last_was_action;

int maxitems;
bucket **pitem;

int maxrules;
bucket **plhs;

int name_pool_size;
char *name_pool;

void cachec(int);
void get_line(void);
char *dup_line(void);
void skip_comment(void);
int nextc(void);
int keyword(void);
void copy_ident(void);
void copy_text(void);
void copy_union(void);
bucket *get_literal(void);
int is_reserved(char *);
bucket *get_name(void);
int get_number(void);
char *get_tag(void);
void declare_tokens(int);
void declare_types(void);
void declare_start(void);
void handle_expect(void);
void read_declarations(void);
void initialize_grammar(void);
void expand_items(void);
void expand_rules(void);
void advance_to_start(void);
void start_rule(bucket *, int);
void end_rule(void);
void insert_empty_rule(void);
void add_symbol(void);
void copy_action(void);
int mark_symbol(void);
void read_grammar(void);
void free_tags(void);
void pack_names(void);
void check_symbols(void);
void pack_symbols(void);
void pack_grammar(void);
void print_grammar(void);

char line_format[] = "#line %d \"%s\"\n";

void
cachec(int c)
{
	assert(cinc >= 0);
	if (cinc >= cache_size) {
		cache_size += 256;
		cache = realloc(cache, cache_size);
		if (cache == NULL)
			no_space();
	}
	cache[cinc] = c;
	++cinc;
}


void
get_line(void)
{
	FILE *f = input_file;
	int c, i;

	if (saw_eof || (c = getc(f)) == EOF) {
		if (line) {
			free(line);
			line = 0;
		}
		cptr = 0;
		saw_eof = 1;
		return;
	}
	if (line == NULL || linesize != (LINESIZE + 1)) {
		free(line);
		linesize = LINESIZE + 1;
		line = malloc(linesize);
		if (line == NULL)
			no_space();
	}
	i = 0;
	++lineno;
	for (;;) {
		line[i] = c;
		if (c == '\n') {
			cptr = line;
			return;
		}
		if (++i >= linesize) {
			linesize += LINESIZE;
			line = realloc(line, linesize);
			if (line == NULL)
				no_space();
		}
		c = getc(f);
		if (c == EOF) {
			line[i] = '\n';
			saw_eof = 1;
			cptr = line;
			return;
		}
	}
}


char *
dup_line(void)
{
	char *p, *s, *t;

	if (line == NULL)
		return (0);
	s = line;
	while (*s != '\n')
		++s;
	p = malloc(s - line + 1);
	if (p == NULL)
		no_space();

	s = line;
	t = p;
	while ((*t++ = *s++) != '\n')
		continue;
	return (p);
}


void
skip_comment(void)
{
	char *s;
	int st_lineno = lineno;
	char *st_line = dup_line();
	char *st_cptr = st_line + (cptr - line);

	s = cptr + 2;
	for (;;) {
		if (*s == '*' && s[1] == '/') {
			cptr = s + 2;
			free(st_line);
			return;
		}
		if (*s == '\n') {
			get_line();
			if (line == NULL)
				unterminated_comment(st_lineno, st_line, st_cptr);
			s = cptr;
		} else
			++s;
	}
}


int
nextc(void)
{
	char *s;

	if (line == NULL) {
		get_line();
		if (line == NULL)
			return (EOF);
	}
	s = cptr;
	for (;;) {
		switch (*s) {
		case '\n':
			get_line();
			if (line == NULL)
				return (EOF);
			s = cptr;
			break;

		case ' ':
		case '\t':
		case '\f':
		case '\r':
		case '\v':
		case ',':
		case ';':
			++s;
			break;

		case '\\':
			cptr = s;
			return ('%');

		case '/':
			if (s[1] == '*') {
				cptr = s;
				skip_comment();
				s = cptr;
				break;
			} else if (s[1] == '/') {
				get_line();
				if (line == NULL)
					return (EOF);
				s = cptr;
				break;
			}
			/* fall through */

		default:
			cptr = s;
			return ((unsigned char) *s);
		}
	}
}


int
keyword(void)
{
	int c;
	char *t_cptr = cptr;

	c = (unsigned char) *++cptr;
	if (isalpha(c)) {
		cinc = 0;
		for (;;) {
			if (isalpha(c)) {
				if (isupper(c))
					c = tolower(c);
				cachec(c);
			} else if (isdigit(c) || c == '_' || c == '.' || c == '$')
				cachec(c);
			else
				break;
			c = (unsigned char) *++cptr;
		}
		cachec(NUL);

		if (strcmp(cache, "token") == 0 || strcmp(cache, "term") == 0)
			return (TOKEN);
		if (strcmp(cache, "type") == 0)
			return (TYPE);
		if (strcmp(cache, "left") == 0)
			return (LEFT);
		if (strcmp(cache, "right") == 0)
			return (RIGHT);
		if (strcmp(cache, "nonassoc") == 0 || strcmp(cache, "binary") == 0)
			return (NONASSOC);
		if (strcmp(cache, "start") == 0)
			return (START);
		if (strcmp(cache, "union") == 0)
			return (UNION);
		if (strcmp(cache, "ident") == 0)
			return (IDENT);
		if (strcmp(cache, "expect") == 0)
			return (EXPECT);
	} else {
		++cptr;
		if (c == '{')
			return (TEXT);
		if (c == '%' || c == '\\')
			return (MARK);
		if (c == '<')
			return (LEFT);
		if (c == '>')
			return (RIGHT);
		if (c == '0')
			return (TOKEN);
		if (c == '2')
			return (NONASSOC);
	}
	syntax_error(lineno, line, t_cptr);
	/* NOTREACHED */
	return (0);
}


void
copy_ident(void)
{
	int c;
	FILE *f = output_file;

	c = nextc();
	if (c == EOF)
		unexpected_EOF();
	if (c != '"')
		syntax_error(lineno, line, cptr);
	++outline;
	fprintf(f, "#ident \"");
	for (;;) {
		c = (unsigned char) *++cptr;
		if (c == '\n') {
			fprintf(f, "\"\n");
			return;
		}
		putc(c, f);
		if (c == '"') {
			putc('\n', f);
			++cptr;
			return;
		}
	}
}


void
copy_text(void)
{
	int c;
	int quote;
	FILE *f = text_file;
	int need_newline = 0;
	int t_lineno = lineno;
	char *t_line = dup_line();
	char *t_cptr = t_line + (cptr - line - 2);

	if (*cptr == '\n') {
		get_line();
		if (line == NULL)
			unterminated_text(t_lineno, t_line, t_cptr);
	}
	if (!lflag)
		fprintf(f, line_format, lineno, input_file_name);

loop:
	c = (unsigned char) *cptr++;
	switch (c) {
	case '\n':
next_line:
		putc('\n', f);
		need_newline = 0;
		get_line();
		if (line)
			goto loop;
		unterminated_text(t_lineno, t_line, t_cptr);

	case '\'':
	case '"': {
		int s_lineno = lineno;
		char *s_line = dup_line();
		char *s_cptr = s_line + (cptr - line - 1);

		quote = c;
		putc(c, f);
		for (;;) {
			c = (unsigned char) *cptr++;
			putc(c, f);
			if (c == quote) {
				need_newline = 1;
				free(s_line);
				goto loop;
			}
			if (c == '\n')
				unterminated_string(s_lineno, s_line, s_cptr);
			if (c == '\\') {
				c = (unsigned char) *cptr++;
				putc(c, f);
				if (c == '\n') {
					get_line();
					if (line == NULL)
						unterminated_string(s_lineno, s_line, s_cptr);
				}
			}
		}
	}

	case '/':
		putc(c, f);
		need_newline = 1;
		c = (unsigned char) *cptr;
		if (c == '/') {
			putc('*', f);
			while ((c = (unsigned char) *++cptr) != '\n') {
				if (c == '*' && cptr[1] == '/')
					fprintf(f, "* ");
				else
					putc(c, f);
			}
			fprintf(f, "*/");
			goto next_line;
		}
		if (c == '*') {
			int c_lineno = lineno;
			char *c_line = dup_line();
			char *c_cptr = c_line + (cptr - line - 1);

			putc('*', f);
			++cptr;
			for (;;) {
				c = (unsigned char) *cptr++;
				putc(c, f);
				if (c == '*' && *cptr == '/') {
					putc('/', f);
					++cptr;
					free(c_line);
					goto loop;
				}
				if (c == '\n') {
					get_line();
					if (line == NULL)
						unterminated_comment(c_lineno, c_line, c_cptr);
				}
			}
		}
		need_newline = 1;
		goto loop;

	case '%':
	case '\\':
		if (*cptr == '}') {
			if (need_newline)
				putc('\n', f);
			++cptr;
			free(t_line);
			return;
		}
		/* fall through */

	default:
		putc(c, f);
		need_newline = 1;
		goto loop;
	}
}


void
copy_union(void)
{
	int c, quote, depth;
	int u_lineno = lineno;
	char *u_line = dup_line();
	char *u_cptr = u_line + (cptr - line - 6);

	if (unionized)
		over_unionized(cptr - 6);
	unionized = 1;

	if (!lflag)
		fprintf(text_file, line_format, lineno, input_file_name);

	fprintf(text_file, "#ifndef YYSTYPE_DEFINED\n");
	fprintf(text_file, "#define YYSTYPE_DEFINED\n");
	fprintf(text_file, "typedef union");
	if (dflag) {
		fprintf(union_file, "#ifndef YYSTYPE_DEFINED\n");
		fprintf(union_file, "#define YYSTYPE_DEFINED\n");
		fprintf(union_file, "typedef union");
	}

	depth = 0;
loop:
	c = (unsigned char) *cptr++;
	putc(c, text_file);
	if (dflag)
		putc(c, union_file);
	switch (c) {
	case '\n':
next_line:
		get_line();
		if (line == NULL)
			unterminated_union(u_lineno, u_line, u_cptr);
		goto loop;

	case '{':
		++depth;
		goto loop;

	case '}':
		if (--depth == 0) {
			fprintf(text_file, " YYSTYPE;\n");
			fprintf(text_file, "#endif /* YYSTYPE_DEFINED */\n");
			free(u_line);
			return;
		}
		goto loop;

	case '\'':
	case '"': {
		int s_lineno = lineno;
		char *s_line = dup_line();
		char *s_cptr = s_line + (cptr - line - 1);

		quote = c;
		for (;;) {
			c = (unsigned char) *cptr++;
			putc(c, text_file);
			if (dflag)
				putc(c, union_file);
			if (c == quote) {
				free(s_line);
				goto loop;
			}
			if (c == '\n')
				unterminated_string(s_lineno, s_line, s_cptr);
			if (c == '\\') {
				c = (unsigned char) *cptr++;
				putc(c, text_file);
				if (dflag)
					putc(c, union_file);
				if (c == '\n') {
					get_line();
					if (line == NULL)
						unterminated_string(s_lineno,
						    s_line, s_cptr);
				}
			}
		}
	}

	case '/':
		c = (unsigned char) *cptr;
		if (c == '/') {
			putc('*', text_file);
			if (dflag)
				putc('*', union_file);
			while ((c = (unsigned char) *++cptr) != '\n') {
				if (c == '*' && cptr[1] == '/') {
					fprintf(text_file, "* ");
					if (dflag)
						fprintf(union_file, "* ");
				} else {
					putc(c, text_file);
					if (dflag)
						putc(c, union_file);
				}
			}
			fprintf(text_file, "*/\n");
			if (dflag)
				fprintf(union_file, "*/\n");
			goto next_line;
		}
		if (c == '*') {
			int c_lineno = lineno;
			char *c_line = dup_line();
			char *c_cptr = c_line + (cptr - line - 1);

			putc('*', text_file);
			if (dflag)
				putc('*', union_file);
			++cptr;
			for (;;) {
				c = (unsigned char) *cptr++;
				putc(c, text_file);
				if (dflag)
					putc(c, union_file);
				if (c == '*' && *cptr == '/') {
					putc('/', text_file);
					if (dflag)
						putc('/', union_file);
					++cptr;
					free(c_line);
					goto loop;
				}
				if (c == '\n') {
					get_line();
					if (line == NULL)
						unterminated_comment(c_lineno,
						    c_line, c_cptr);
				}
			}
		}
		goto loop;

	default:
		goto loop;
	}
}


bucket *
get_literal(void)
{
	int c, quote, i, n;
	char *s;
	bucket *bp;
	int s_lineno = lineno;
	char *s_line = dup_line();
	char *s_cptr = s_line + (cptr - line);

	quote = (unsigned char) *cptr++;
	cinc = 0;
	for (;;) {
		c = (unsigned char) *cptr++;
		if (c == quote)
			break;
		if (c == '\n')
			unterminated_string(s_lineno, s_line, s_cptr);
		if (c == '\\') {
			char *c_cptr = cptr - 1;
			unsigned long ulval;

			c = (unsigned char) *cptr++;
			switch (c) {
			case '\n':
				get_line();
				if (line == NULL)
					unterminated_string(s_lineno, s_line,
					    s_cptr);
				continue;

			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
				ulval = strtoul(cptr - 1, &s, 8);
				if (s == cptr - 1 || ulval > MAXCHAR)
					illegal_character(c_cptr);
				c = (int) ulval;
				cptr = s;
				break;

			case 'x':
				ulval = strtoul(cptr, &s, 16);
				if (s == cptr || ulval > MAXCHAR)
					illegal_character(c_cptr);
				c = (int) ulval;
				cptr = s;
				break;

			case 'a':
				c = 7;
				break;
			case 'b':
				c = '\b';
				break;
			case 'f':
				c = '\f';
				break;
			case 'n':
				c = '\n';
				break;
			case 'r':
				c = '\r';
				break;
			case 't':
				c = '\t';
				break;
			case 'v':
				c = '\v';
				break;
			}
		}
		cachec(c);
	}
	free(s_line);

	n = cinc;
	s = malloc(n);
	if (s == NULL)
		no_space();

	memcpy(s, cache, n);

	cinc = 0;
	if (n == 1)
		cachec('\'');
	else
		cachec('"');

	for (i = 0; i < n; ++i) {
		c = ((unsigned char *) s)[i];
		if (c == '\\' || c == cache[0]) {
			cachec('\\');
			cachec(c);
		} else if (isprint(c))
			cachec(c);
		else {
			cachec('\\');
			switch (c) {
			case 7:
				cachec('a');
				break;
			case '\b':
				cachec('b');
				break;
			case '\f':
				cachec('f');
				break;
			case '\n':
				cachec('n');
				break;
			case '\r':
				cachec('r');
				break;
			case '\t':
				cachec('t');
				break;
			case '\v':
				cachec('v');
				break;
			default:
				cachec(((c >> 6) & 7) + '0');
				cachec(((c >> 3) & 7) + '0');
				cachec((c & 7) + '0');
				break;
			}
		}
	}

	if (n == 1)
		cachec('\'');
	else
		cachec('"');

	cachec(NUL);
	bp = lookup(cache);
	bp->class = TERM;
	if (n == 1 && bp->value == UNDEFINED)
		bp->value = *(unsigned char *) s;
	free(s);

	return (bp);
}


int
is_reserved(char *name)
{
	char *s;

	if (strcmp(name, ".") == 0 ||
	    strcmp(name, "$accept") == 0 ||
	    strcmp(name, "$end") == 0)
		return (1);

	if (name[0] == '$' && name[1] == '$' && isdigit((unsigned char) name[2])) {
		s = name + 3;
		while (isdigit((unsigned char) *s))
			++s;
		if (*s == NUL)
			return (1);
	}
	return (0);
}


bucket *
get_name(void)
{
	int c;

	cinc = 0;
	for (c = (unsigned char) *cptr; IS_IDENT(c); c = (unsigned char) *++cptr)
		cachec(c);
	cachec(NUL);

	if (is_reserved(cache))
		used_reserved(cache);

	return (lookup(cache));
}


int
get_number(void)
{
	unsigned long ul;
	char *p;

	ul = strtoul(cptr, &p, 10);
	if (ul > INT_MAX)
		syntax_error(lineno, line, cptr);
	cptr = p;
	return (ul);
}


char *
get_tag(void)
{
	int c, i;
	char *s;
	int t_lineno = lineno;
	char *t_line = dup_line();
	char *t_cptr = t_line + (cptr - line);

	++cptr;
	c = nextc();
	if (c == EOF)
		unexpected_EOF();
	if (!isalpha(c) && c != '_' && c != '$')
		illegal_tag(t_lineno, t_line, t_cptr);

	cinc = 0;
	do {
		cachec(c);
		c = (unsigned char) *++cptr;
	} while (IS_IDENT(c));
	cachec(NUL);

	c = nextc();
	if (c == EOF)
		unexpected_EOF();
	if (c != '>')
		illegal_tag(t_lineno, t_line, t_cptr);
	free(t_line);
	++cptr;

	for (i = 0; i < ntags; ++i) {
		if (strcmp(cache, tag_table[i]) == 0)
			return (tag_table[i]);
	}

	if (ntags >= tagmax) {
		tagmax += 16;
		tag_table = reallocarray(tag_table, tagmax, sizeof(char *));
		if (tag_table == NULL)
			no_space();
	}
	s = malloc(cinc);
	if (s == NULL)
		no_space();
	strlcpy(s, cache, cinc);
	tag_table[ntags] = s;
	++ntags;
	return (s);
}


void
declare_tokens(int assoc)
{
	int c;
	bucket *bp;
	int value;
	char *tag = 0;

	if (assoc != TOKEN)
		++prec;

	c = nextc();
	if (c == EOF)
		unexpected_EOF();
	if (c == '<') {
		tag = get_tag();
		c = nextc();
		if (c == EOF)
			unexpected_EOF();
	}
	for (;;) {
		if (isalpha(c) || c == '_' || c == '.' || c == '$')
			bp = get_name();
		else if (c == '\'' || c == '"')
			bp = get_literal();
		else
			return;

		if (bp == goal)
			tokenized_start(bp->name);
		bp->class = TERM;

		if (tag) {
			if (bp->tag && tag != bp->tag)
				retyped_warning(bp->name);
			bp->tag = tag;
		}
		if (assoc != TOKEN) {
			if (bp->prec && prec != bp->prec)
				reprec_warning(bp->name);
			bp->assoc = assoc;
			bp->prec = prec;
		}
		c = nextc();
		if (c == EOF)
			unexpected_EOF();
		if (isdigit(c)) {
			value = get_number();
			if (bp->value != UNDEFINED && value != bp->value)
				revalued_warning(bp->name);
			bp->value = value;
			c = nextc();
			if (c == EOF)
				unexpected_EOF();
		}
	}
}


/*
 * %expect requires special handling as it really isn't part of the yacc
 * grammar only a flag for yacc proper.
 */
void
declare_expect(int assoc)
{
	int c;

	if (assoc != EXPECT)
		++prec;

	/*
         * Stay away from nextc - doesn't detect EOL and will read to EOF.
         */
	c = (unsigned char) *++cptr;
	if (c == EOF)
		unexpected_EOF();

	for (;;) {
		if (isdigit(c)) {
			SRexpect = get_number();
			break;
		}
		/*
	         * Looking for number before EOL.
	         * Spaces, tabs, and numbers are ok.
	         * Words, punc., etc. are syntax errors.
	         */
		else if (c == '\n' || isalpha(c) || !isspace(c)) {
			syntax_error(lineno, line, cptr);
		} else {
			c = (unsigned char) *++cptr;
			if (c == EOF)
				unexpected_EOF();
		}
	}
}


void
declare_types(void)
{
	int c;
	bucket *bp;
	char *tag;

	c = nextc();
	if (c == EOF)
		unexpected_EOF();
	if (c != '<')
		syntax_error(lineno, line, cptr);
	tag = get_tag();

	for (;;) {
		c = nextc();
		if (isalpha(c) || c == '_' || c == '.' || c == '$')
			bp = get_name();
		else if (c == '\'' || c == '"')
			bp = get_literal();
		else
			return;

		if (bp->tag && tag != bp->tag)
			retyped_warning(bp->name);
		bp->tag = tag;
	}
}


void
declare_start(void)
{
	int c;
	bucket *bp;

	c = nextc();
	if (c == EOF)
		unexpected_EOF();
	if (!isalpha(c) && c != '_' && c != '.' && c != '$')
		syntax_error(lineno, line, cptr);
	bp = get_name();
	if (bp->class == TERM)
		terminal_start(bp->name);
	if (goal && goal != bp)
		restarted_warning();
	goal = bp;
}


void
read_declarations(void)
{
	int c, k;

	cache_size = 256;
	cache = malloc(cache_size);
	if (cache == NULL)
		no_space();

	for (;;) {
		c = nextc();
		if (c == EOF)
			unexpected_EOF();
		if (c != '%')
			syntax_error(lineno, line, cptr);
		switch (k = keyword()) {
		case MARK:
			return;

		case IDENT:
			copy_ident();
			break;

		case TEXT:
			copy_text();
			break;

		case UNION:
			copy_union();
			break;

		case TOKEN:
		case LEFT:
		case RIGHT:
		case NONASSOC:
			declare_tokens(k);
			break;

		case EXPECT:
			declare_expect(k);
			break;

		case TYPE:
			declare_types();
			break;

		case START:
			declare_start();
			break;
		}
	}
}


void
initialize_grammar(void)
{
	nitems = 4;
	maxitems = 300;
	pitem = calloc(maxitems, sizeof(bucket *));
	if (pitem == NULL)
		no_space();

	nrules = 3;
	maxrules = 100;
	plhs = reallocarray(NULL, maxrules, sizeof(bucket *));
	if (plhs == NULL)
		no_space();
	plhs[0] = 0;
	plhs[1] = 0;
	plhs[2] = 0;
	rprec = reallocarray(NULL, maxrules, sizeof(short));
	if (rprec == NULL)
		no_space();
	rprec[0] = 0;
	rprec[1] = 0;
	rprec[2] = 0;
	rassoc = reallocarray(NULL, maxrules, sizeof(char));
	if (rassoc == NULL)
		no_space();
	rassoc[0] = TOKEN;
	rassoc[1] = TOKEN;
	rassoc[2] = TOKEN;
}


void
expand_items(void)
{
	int olditems = maxitems;

	maxitems += 300;
	pitem = reallocarray(pitem, maxitems, sizeof(bucket *));
	if (pitem == NULL)
		no_space();
	memset(pitem + olditems, 0, (maxitems - olditems) * sizeof(bucket *));
}


void
expand_rules(void)
{
	maxrules += 100;
	plhs = reallocarray(plhs, maxrules, sizeof(bucket *));
	if (plhs == NULL)
		no_space();
	rprec = reallocarray(rprec, maxrules, sizeof(short));
	if (rprec == NULL)
		no_space();
	rassoc = reallocarray(rassoc, maxrules, sizeof(char));
	if (rassoc == NULL)
		no_space();
}


void
advance_to_start(void)
{
	int c;
	bucket *bp;
	char *s_cptr;
	int s_lineno;

	for (;;) {
		c = nextc();
		if (c != '%')
			break;
		s_cptr = cptr;
		switch (keyword()) {
		case MARK:
			no_grammar();

		case TEXT:
			copy_text();
			break;

		case START:
			declare_start();
			break;

		default:
			syntax_error(lineno, line, s_cptr);
		}
	}

	c = nextc();
	if (!isalpha(c) && c != '_' && c != '.' && c != '_')
		syntax_error(lineno, line, cptr);
	bp = get_name();
	if (goal == NULL) {
		if (bp->class == TERM)
			terminal_start(bp->name);
		goal = bp;
	}
	s_lineno = lineno;
	c = nextc();
	if (c == EOF)
		unexpected_EOF();
	if (c != ':')
		syntax_error(lineno, line, cptr);
	start_rule(bp, s_lineno);
	++cptr;
}


void
start_rule(bucket * bp, int s_lineno)
{
	if (bp->class == TERM)
		terminal_lhs(s_lineno);
	bp->class = NONTERM;
	if (nrules >= maxrules)
		expand_rules();
	plhs[nrules] = bp;
	rprec[nrules] = UNDEFINED;
	rassoc[nrules] = TOKEN;
}


void
end_rule(void)
{
	int i;

	if (!last_was_action && plhs[nrules]->tag) {
		for (i = nitems - 1; pitem[i]; --i)
			continue;
		if (i == maxitems - 1 || pitem[i + 1] == 0 ||
		    pitem[i + 1]->tag != plhs[nrules]->tag)
			default_action_warning();
	}
	last_was_action = 0;
	if (nitems >= maxitems)
		expand_items();
	pitem[nitems] = 0;
	++nitems;
	++nrules;
}


void
insert_empty_rule(void)
{
	bucket *bp, **bpp;

	assert(cache);
	snprintf(cache, cache_size, "$$%d", ++gensym);
	bp = make_bucket(cache);
	last_symbol->next = bp;
	last_symbol = bp;
	bp->tag = plhs[nrules]->tag;
	bp->class = NONTERM;

	if ((nitems += 2) > maxitems)
		expand_items();
	bpp = pitem + nitems - 1;
	*bpp-- = bp;
	while ((bpp[0] = bpp[-1]))
		--bpp;

	if (++nrules >= maxrules)
		expand_rules();
	plhs[nrules] = plhs[nrules - 1];
	plhs[nrules - 1] = bp;
	rprec[nrules] = rprec[nrules - 1];
	rprec[nrules - 1] = 0;
	rassoc[nrules] = rassoc[nrules - 1];
	rassoc[nrules - 1] = TOKEN;
}


void
add_symbol(void)
{
	int c;
	bucket *bp;
	int s_lineno = lineno;

	c = (unsigned char) *cptr;
	if (c == '\'' || c == '"')
		bp = get_literal();
	else
		bp = get_name();

	c = nextc();
	if (c == ':') {
		end_rule();
		start_rule(bp, s_lineno);
		++cptr;
		return;
	}
	if (last_was_action)
		insert_empty_rule();
	last_was_action = 0;

	if (++nitems > maxitems)
		expand_items();
	pitem[nitems - 1] = bp;
}


void
copy_action(void)
{
	int c, i, n, depth, quote;
	char *tag;
	FILE *f = action_file;
	int a_lineno = lineno;
	char *a_line = dup_line();
	char *a_cptr = a_line + (cptr - line);

	if (last_was_action)
		insert_empty_rule();
	last_was_action = 1;

	fprintf(f, "case %d:\n", nrules - 2);
	if (!lflag)
		fprintf(f, line_format, lineno, input_file_name);
	if (*cptr == '=')
		++cptr;

	n = 0;
	for (i = nitems - 1; pitem[i]; --i)
		++n;

	depth = 0;
loop:
	c = (unsigned char) *cptr;
	if (c == '$') {
		if (cptr[1] == '<') {
			int d_lineno = lineno;
			char *d_line = dup_line();
			char *d_cptr = d_line + (cptr - line);

			++cptr;
			tag = get_tag();
			c = (unsigned char) *cptr;
			if (c == '$') {
				fprintf(f, "yyval.%s", tag);
				++cptr;
				free(d_line);
				goto loop;
			} else if (isdigit(c)) {
				i = get_number();
				if (i > n)
					dollar_warning(d_lineno, i);
				fprintf(f, "yyvsp[%d].%s", i - n, tag);
				free(d_line);
				goto loop;
			} else if (c == '-' && isdigit((unsigned char) cptr[1])) {
				++cptr;
				i = -get_number() - n;
				fprintf(f, "yyvsp[%d].%s", i, tag);
				free(d_line);
				goto loop;
			} else
				dollar_error(d_lineno, d_line, d_cptr);
		} else if (cptr[1] == '$') {
			if (ntags) {
				tag = plhs[nrules]->tag;
				if (tag == NULL)
					untyped_lhs();
				fprintf(f, "yyval.%s", tag);
			} else
				fprintf(f, "yyval");
			cptr += 2;
			goto loop;
		} else if (isdigit((unsigned char) cptr[1])) {
			++cptr;
			i = get_number();
			if (ntags) {
				if (i <= 0 || i > n)
					unknown_rhs(i);
				tag = pitem[nitems + i - n - 1]->tag;
				if (tag == NULL)
					untyped_rhs(i, pitem[nitems + i - n - 1]->name);
				fprintf(f, "yyvsp[%d].%s", i - n, tag);
			} else {
				if (i > n)
					dollar_warning(lineno, i);
				fprintf(f, "yyvsp[%d]", i - n);
			}
			goto loop;
		} else if (cptr[1] == '-') {
			cptr += 2;
			i = get_number();
			if (ntags)
				unknown_rhs(-i);
			fprintf(f, "yyvsp[%d]", -i - n);
			goto loop;
		}
	}
	if (isalpha(c) || c == '_' || c == '$') {
		do {
			putc(c, f);
			c = (unsigned char) *++cptr;
		} while (isalnum(c) || c == '_' || c == '$');
		goto loop;
	}
	putc(c, f);
	++cptr;
	switch (c) {
	case '\n':
next_line:
		get_line();
		if (line)
			goto loop;
		unterminated_action(a_lineno, a_line, a_cptr);

	case ';':
		if (depth > 0)
			goto loop;
		fprintf(f, "\nbreak;\n");
		free(a_line);
		return;

	case '{':
		++depth;
		goto loop;

	case '}':
		if (--depth > 0)
			goto loop;
		fprintf(f, "\nbreak;\n");
		free(a_line);
		return;

	case '\'':
	case '"': {
		int s_lineno = lineno;
		char *s_line = dup_line();
		char *s_cptr = s_line + (cptr - line - 1);

		quote = c;
		for (;;) {
			c = (unsigned char) *cptr++;
			putc(c, f);
			if (c == quote) {
				free(s_line);
				goto loop;
			}
			if (c == '\n')
				unterminated_string(s_lineno, s_line, s_cptr);
			if (c == '\\') {
				c = (unsigned char) *cptr++;
				putc(c, f);
				if (c == '\n') {
					get_line();
					if (line == NULL)
						unterminated_string(s_lineno, s_line, s_cptr);
				}
			}
		}
	}

	case '/':
		c = (unsigned char) *cptr;
		if (c == '/') {
			putc('*', f);
			while ((c = (unsigned char) *++cptr) != '\n') {
				if (c == '*' && cptr[1] == '/')
					fprintf(f, "* ");
				else
					putc(c, f);
			}
			fprintf(f, "*/\n");
			goto next_line;
		}
		if (c == '*') {
			int c_lineno = lineno;
			char *c_line = dup_line();
			char *c_cptr = c_line + (cptr - line - 1);

			putc('*', f);
			++cptr;
			for (;;) {
				c = (unsigned char) *cptr++;
				putc(c, f);
				if (c == '*' && *cptr == '/') {
					putc('/', f);
					++cptr;
					free(c_line);
					goto loop;
				}
				if (c == '\n') {
					get_line();
					if (line == NULL)
						unterminated_comment(c_lineno, c_line, c_cptr);
				}
			}
		}
		goto loop;

	default:
		goto loop;
	}
}


int
mark_symbol(void)
{
	int c;
	bucket *bp = NULL;

	c = (unsigned char) cptr[1];
	if (c == '%' || c == '\\') {
		cptr += 2;
		return (1);
	}
	if (c == '=')
		cptr += 2;
	else if ((c == 'p' || c == 'P') &&
	    ((c = cptr[2]) == 'r' || c == 'R') &&
	    ((c = cptr[3]) == 'e' || c == 'E') &&
	    ((c = cptr[4]) == 'c' || c == 'C') &&
	    ((c = (unsigned char) cptr[5], !IS_IDENT(c))))
		cptr += 5;
	else
		syntax_error(lineno, line, cptr);

	c = nextc();
	if (isalpha(c) || c == '_' || c == '.' || c == '$')
		bp = get_name();
	else if (c == '\'' || c == '"')
		bp = get_literal();
	else {
		syntax_error(lineno, line, cptr);
		/* NOTREACHED */
	}

	if (rprec[nrules] != UNDEFINED && bp->prec != rprec[nrules])
		prec_redeclared();

	rprec[nrules] = bp->prec;
	rassoc[nrules] = bp->assoc;
	return (0);
}


void
read_grammar(void)
{
	int c;

	initialize_grammar();
	advance_to_start();

	for (;;) {
		c = nextc();
		if (c == EOF)
			break;
		if (isalpha(c) || c == '_' || c == '.' || c == '$' || c == '\'' ||
		    c == '"')
			add_symbol();
		else if (c == '{' || c == '=')
			copy_action();
		else if (c == '|') {
			end_rule();
			start_rule(plhs[nrules - 1], 0);
			++cptr;
		} else if (c == '%') {
			if (mark_symbol())
				break;
		} else
			syntax_error(lineno, line, cptr);
	}
	end_rule();
}


void
free_tags(void)
{
	int i;

	if (tag_table == NULL)
		return;

	for (i = 0; i < ntags; ++i) {
		assert(tag_table[i]);
		free(tag_table[i]);
	}
	free(tag_table);
}


void
pack_names(void)
{
	bucket *bp;
	char *p, *s, *t;

	name_pool_size = 13;	/* 13 == sizeof("$end") + sizeof("$accept") */
	for (bp = first_symbol; bp; bp = bp->next)
		name_pool_size += strlen(bp->name) + 1;
	name_pool = malloc(name_pool_size);
	if (name_pool == NULL)
		no_space();

	strlcpy(name_pool, "$accept", name_pool_size);
	strlcpy(name_pool + 8, "$end", name_pool_size - 8);
	t = name_pool + 13;
	for (bp = first_symbol; bp; bp = bp->next) {
		p = t;
		s = bp->name;
		while ((*t++ = *s++))
			continue;
		free(bp->name);
		bp->name = p;
	}
}


void
check_symbols(void)
{
	bucket *bp;

	if (goal->class == UNKNOWN)
		undefined_goal(goal->name);

	for (bp = first_symbol; bp; bp = bp->next) {
		if (bp->class == UNKNOWN) {
			undefined_symbol_warning(bp->name);
			bp->class = TERM;
		}
	}
}


void
pack_symbols(void)
{
	bucket *bp;
	bucket **v;
	int i, j, k, n;

	nsyms = 2;
	ntokens = 1;
	for (bp = first_symbol; bp; bp = bp->next) {
		++nsyms;
		if (bp->class == TERM)
			++ntokens;
	}
	start_symbol = ntokens;
	nvars = nsyms - ntokens;

	symbol_name = reallocarray(NULL, nsyms, sizeof(char *));
	if (symbol_name == NULL)
		no_space();
	symbol_value = reallocarray(NULL, nsyms, sizeof(short));
	if (symbol_value == NULL)
		no_space();
	symbol_prec = reallocarray(NULL, nsyms, sizeof(short));
	if (symbol_prec == NULL)
		no_space();
	symbol_assoc = malloc(nsyms);
	if (symbol_assoc == NULL)
		no_space();

	v = reallocarray(NULL, nsyms, sizeof(bucket *));
	if (v == NULL)
		no_space();

	v[0] = 0;
	v[start_symbol] = 0;

	i = 1;
	j = start_symbol + 1;
	for (bp = first_symbol; bp; bp = bp->next) {
		if (bp->class == TERM)
			v[i++] = bp;
		else
			v[j++] = bp;
	}
	assert(i == ntokens && j == nsyms);

	for (i = 1; i < ntokens; ++i)
		v[i]->index = i;

	goal->index = start_symbol + 1;
	k = start_symbol + 2;
	while (++i < nsyms)
		if (v[i] != goal) {
			v[i]->index = k;
			++k;
		}
	goal->value = 0;
	k = 1;
	for (i = start_symbol + 1; i < nsyms; ++i) {
		if (v[i] != goal) {
			v[i]->value = k;
			++k;
		}
	}

	k = 0;
	for (i = 1; i < ntokens; ++i) {
		n = v[i]->value;
		if (n > 256) {
			for (j = k++; j > 0 && symbol_value[j - 1] > n; --j)
				symbol_value[j] = symbol_value[j - 1];
			symbol_value[j] = n;
		}
	}

	if (v[1]->value == UNDEFINED)
		v[1]->value = 256;

	j = 0;
	n = 257;
	for (i = 2; i < ntokens; ++i) {
		if (v[i]->value == UNDEFINED) {
			while (j < k && n == symbol_value[j]) {
				while (++j < k && n == symbol_value[j])
					continue;
				++n;
			}
			v[i]->value = n;
			++n;
		}
	}

	symbol_name[0] = name_pool + 8;
	symbol_value[0] = 0;
	symbol_prec[0] = 0;
	symbol_assoc[0] = TOKEN;
	for (i = 1; i < ntokens; ++i) {
		symbol_name[i] = v[i]->name;
		symbol_value[i] = v[i]->value;
		symbol_prec[i] = v[i]->prec;
		symbol_assoc[i] = v[i]->assoc;
	}
	symbol_name[start_symbol] = name_pool;
	symbol_value[start_symbol] = -1;
	symbol_prec[start_symbol] = 0;
	symbol_assoc[start_symbol] = TOKEN;
	for (++i; i < nsyms; ++i) {
		k = v[i]->index;
		symbol_name[k] = v[i]->name;
		symbol_value[k] = v[i]->value;
		symbol_prec[k] = v[i]->prec;
		symbol_assoc[k] = v[i]->assoc;
	}

	free(v);
}


void
pack_grammar(void)
{
	int i, j;
	int assoc, prec;

	ritem = reallocarray(NULL, nitems, sizeof(short));
	if (ritem == NULL)
		no_space();
	rlhs = reallocarray(NULL, nrules, sizeof(short));
	if (rlhs == NULL)
		no_space();
	rrhs = reallocarray(NULL, nrules + 1, sizeof(short));
	if (rrhs == NULL)
		no_space();
	rprec = reallocarray(rprec, nrules, sizeof(short));
	if (rprec == NULL)
		no_space();
	rassoc = realloc(rassoc, nrules);
	if (rassoc == NULL)
		no_space();

	ritem[0] = -1;
	ritem[1] = goal->index;
	ritem[2] = 0;
	ritem[3] = -2;
	rlhs[0] = 0;
	rlhs[1] = 0;
	rlhs[2] = start_symbol;
	rrhs[0] = 0;
	rrhs[1] = 0;
	rrhs[2] = 1;

	j = 4;
	for (i = 3; i < nrules; ++i) {
		rlhs[i] = plhs[i]->index;
		rrhs[i] = j;
		assoc = TOKEN;
		prec = 0;
		while (pitem[j]) {
			ritem[j] = pitem[j]->index;
			if (pitem[j]->class == TERM) {
				prec = pitem[j]->prec;
				assoc = pitem[j]->assoc;
			}
			++j;
		}
		ritem[j] = -i;
		++j;
		if (rprec[i] == UNDEFINED) {
			rprec[i] = prec;
			rassoc[i] = assoc;
		}
	}
	rrhs[i] = j;

	free(plhs);
	free(pitem);
}


void
print_grammar(void)
{
	int i, j, k;
	int spacing = 0;
	FILE *f = verbose_file;

	if (!vflag)
		return;

	k = 1;
	for (i = 2; i < nrules; ++i) {
		if (rlhs[i] != rlhs[i - 1]) {
			if (i != 2)
				fprintf(f, "\n");
			fprintf(f, "%4d  %s :", i - 2, symbol_name[rlhs[i]]);
			spacing = strlen(symbol_name[rlhs[i]]) + 1;
		} else {
			fprintf(f, "%4d  ", i - 2);
			j = spacing;
			while (--j >= 0)
				putc(' ', f);
			putc('|', f);
		}

		while (ritem[k] >= 0) {
			fprintf(f, " %s", symbol_name[ritem[k]]);
			++k;
		}
		++k;
		putc('\n', f);
	}
}


void
reader(void)
{
	write_section(banner);
	create_symbol_table();
	read_declarations();
	read_grammar();
	free_symbol_table();
	free_tags();
	pack_names();
	check_symbols();
	pack_symbols();
	pack_grammar();
	free_symbols();
	print_grammar();
}
@


1.32
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/* $OpenBSD: reader.c,v 1.31 2014/12/05 04:03:57 jsg Exp $	 */
d505 1
a505 1
	if (dflag)
a506 1
	if (dflag)
a507 1
	if (dflag)
d509 1
@


1.31
log
@Rework the number handling to avoid an integer overflow/crash
found with the afl fuzzer.

This is tedu's simplified version of an earlier patch from me.
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: reader.c,v 1.30 2014/12/02 15:56:22 millert Exp $	 */
d140 1
a140 2
		if (line)
			free(line);
@


1.30
log
@Remove dead stores found by llvm checker and mark functions that
call done() as __dead to avoid false positives.  OK otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: reader.c,v 1.29 2014/10/09 03:02:18 deraadt Exp $	 */
d36 1
d824 2
a825 1
	int c, n;
d827 5
a831 5
	n = 0;
	for (c = (unsigned char) *cptr; isdigit(c); c = (unsigned char) *++cptr)
		n = 10 * n + (c - '0');

	return (n);
@


1.29
log
@use reallocarray().  Leave the malloc/realloc cases in the skeleton
untouched because they have their own mult int overflow checks, and
placing reallocarray there causes some incredible fireworks in other
software.  Discussed with millert.
@
text
@d1 1
a1 1
/* $OpenBSD: reader.c,v 1.28 2014/03/13 01:18:22 tedu Exp $	 */
a930 1
		value = UNDEFINED;
@


1.28
log
@collapse variable declarations
@
text
@d1 1
a1 1
/* $OpenBSD: reader.c,v 1.27 2014/03/13 00:33:55 tedu Exp $	 */
d871 1
a871 3
		tag_table = (tag_table ?
		    realloc(tag_table, tagmax * sizeof(char *)) :
		    malloc(tagmax * sizeof(char *)));
d1101 1
a1101 1
	plhs = malloc(maxrules * sizeof(bucket *));
d1107 1
a1107 1
	rprec = malloc(maxrules * sizeof(short));
d1113 1
a1113 1
	rassoc = malloc(maxrules * sizeof(char));
d1128 1
a1128 1
	pitem = realloc(pitem, maxitems * sizeof(bucket *));
d1139 1
a1139 1
	plhs = realloc(plhs, maxrules * sizeof(bucket *));
d1142 1
a1142 1
	rprec = realloc(rprec, maxrules * sizeof(short));
d1145 1
a1145 1
	rassoc = realloc(rassoc, maxrules * sizeof(char));
d1644 1
a1644 1
	symbol_name = malloc(nsyms * sizeof(char *));
d1647 1
a1647 1
	symbol_value = malloc(nsyms * sizeof(short));
d1650 1
a1650 1
	symbol_prec = malloc(nsyms * sizeof(short));
d1657 1
a1657 1
	v = malloc(nsyms * sizeof(bucket *));
d1752 1
a1752 1
	ritem = malloc(nitems * sizeof(short));
d1755 1
a1755 1
	rlhs = malloc(nrules * sizeof(short));
d1758 1
a1758 1
	rrhs = malloc((nrules + 1) * sizeof(short));
d1761 1
a1761 1
	rprec = realloc(rprec, nrules * sizeof(short));
@


1.27
log
@indent, add a touch of style
@
text
@d1 1
a1 1
/* $OpenBSD: reader.c,v 1.26 2014/01/10 23:01:29 millert Exp $	 */
d127 1
a127 2
	int c;
	int i;
d157 1
a157 1
			if (line == 0)
a196 1

d490 1
a490 3
	int c;
	int quote;
	int depth;
d635 1
a635 3
	int c, quote;
	int i;
	int n;
d823 1
a823 2
	int c;
	int n;
d836 1
a836 2
	int c;
	int i;
d1128 1
d1302 1
a1302 4
	int c;
	int i, n;
	int depth;
	int quote;
@


1.26
log
@Use strtoul() to do octal and hex character conversion instead of
custom code.
@
text
@d1 2
a2 2
/*	$OpenBSD: reader.c,v 1.25 2014/01/08 22:55:59 millert Exp $	*/
/*	$NetBSD: reader.c,v 1.5 1996/03/19 03:21:43 jtc Exp $	*/
d38 4
a41 4
/*  The line size must be a positive integer.  One hundred was chosen	*/
/*  because few lines in Yacc input grammars exceed 100 characters.	*/
/*  Note that if a line exceeds LINESIZE characters, the line buffer	*/
/*  will be expanded to accommodate it.					*/
d71 1
a71 1
char * dup_line(void);
d78 1
a78 1
bucket * get_literal(void);
d80 1
a80 1
bucket * get_name(void);
d82 1
a82 1
char * get_tag(void);
d111 9
a119 9
    assert(cinc >= 0);
    if (cinc >= cache_size)
    {
	cache_size += 256;
	cache = realloc(cache, cache_size);
	if (cache == NULL) no_space();
    }
    cache[cinc] = c;
    ++cinc;
d126 42
a167 39
    FILE *f = input_file;
    int c;
    int i;

    if (saw_eof || (c = getc(f)) == EOF)
    {
	if (line) { free(line); line = 0; }
	cptr = 0;
	saw_eof = 1;
	return;
    }

    if (line == NULL || linesize != (LINESIZE + 1))
    {
	if (line) free(line);
	linesize = LINESIZE + 1;
	line = malloc(linesize);
	if (line == NULL) no_space();
    }

    i = 0;
    ++lineno;
    for (;;)
    {
	line[i]  =  c;
	if (c == '\n') { cptr = line; return; }
	if (++i >= linesize)
	{
	    linesize += LINESIZE;
	    line = realloc(line, linesize);
	    if (line ==  0) no_space();
	}
	c = getc(f);
	if (c ==  EOF)
	{
	    line[i] = '\n';
	    saw_eof = 1;
	    cptr = line;
	    return;
a168 1
    }
d175 1
a175 1
    char *p, *s, *t;
d177 14
a190 10
    if (line == NULL) return (0);
    s = line;
    while (*s != '\n') ++s;
    p = malloc(s - line + 1);
    if (p == NULL) no_space();

    s = line;
    t = p;
    while ((*t++ = *s++) != '\n') continue;
    return (p);
d197 1
a197 1
    char *s;
d199 18
a216 19
    int st_lineno = lineno;
    char *st_line = dup_line();
    char *st_cptr = st_line + (cptr - line);

    s = cptr + 2;
    for (;;)
    {
	if (*s == '*' && s[1] == '/')
	{
	    cptr = s + 2;
	    free(st_line);
	    return;
	}
	if (*s == '\n')
	{
	    get_line();
	    if (line == NULL)
		unterminated_comment(st_lineno, st_line, st_cptr);
	    s = cptr;
a217 3
	else
	    ++s;
    }
d224 1
a224 29
    char *s;

    if (line == NULL)
    {
	get_line();
	if (line == NULL)
	    return (EOF);
    }

    s = cptr;
    for (;;)
    {
	switch (*s)
	{
	case '\n':
	    get_line();
	    if (line == NULL) return (EOF);
	    s = cptr;
	    break;

	case ' ':
	case '\t':
	case '\f':
	case '\r':
	case '\v':
	case ',':
	case ';':
	    ++s;
	    break;
d226 1
a226 14
	case '\\':
	    cptr = s;
	    return ('%');

	case '/':
	    if (s[1] == '*')
	    {
		cptr = s;
		skip_comment();
		s = cptr;
		break;
	    }
	    else if (s[1] == '/')
	    {
d228 46
a273 9
		if (line == NULL) return (EOF);
		s = cptr;
		break;
	    }
	    /* fall through */

	default:
	    cptr = s;
	    return ((unsigned char)*s);
a274 1
    }
d281 2
a282 2
    int c;
    char *t_cptr = cptr;
d284 15
a298 18
    c = (unsigned char)*++cptr;
    if (isalpha(c))
    {
	cinc = 0;
	for (;;)
	{
	    if (isalpha(c))
	    {
		if (isupper(c)) c = tolower(c);
		cachec(c);
	    }
	    else if (isdigit(c) || c == '_' || c == '.' || c == '$')
		cachec(c);
	    else
		break;
	    c = (unsigned char)*++cptr;
	}
	cachec(NUL);
d300 36
a335 38
	if (strcmp(cache, "token") == 0 || strcmp(cache, "term") == 0)
	    return (TOKEN);
	if (strcmp(cache, "type") == 0)
	    return (TYPE);
	if (strcmp(cache, "left") == 0)
	    return (LEFT);
	if (strcmp(cache, "right") == 0)
	    return (RIGHT);
	if (strcmp(cache, "nonassoc") == 0 || strcmp(cache, "binary") == 0)
	    return (NONASSOC);
	if (strcmp(cache, "start") == 0)
	    return (START);
	if (strcmp(cache, "union") == 0)
	    return (UNION);
	if (strcmp(cache, "ident") == 0)
	    return (IDENT);
	if (strcmp(cache, "expect") == 0)
	    return (EXPECT);
    }
    else
    {
	++cptr;
	if (c == '{')
	    return (TEXT);
	if (c == '%' || c == '\\')
	    return (MARK);
	if (c == '<')
	    return (LEFT);
	if (c == '>')
	    return (RIGHT);
	if (c == '0')
	    return (TOKEN);
	if (c == '2')
	    return (NONASSOC);
    }
    syntax_error(lineno, line, t_cptr);
    /*NOTREACHED*/
    return (0);
d342 2
a343 2
    int c;
    FILE *f = output_file;
d345 19
a363 19
    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c != '"') syntax_error(lineno, line, cptr);
    ++outline;
    fprintf(f, "#ident \"");
    for (;;)
    {
	c = (unsigned char)*++cptr;
	if (c == '\n')
	{
	    fprintf(f, "\"\n");
	    return;
	}
	putc(c, f);
	if (c == '"')
	{
	    putc('\n', f);
	    ++cptr;
	    return;
a364 1
    }
d371 15
a385 15
    int c;
    int quote;
    FILE *f = text_file;
    int need_newline = 0;
    int t_lineno = lineno;
    char *t_line = dup_line();
    char *t_cptr = t_line + (cptr - line - 2);

    if (*cptr == '\n')
    {
	get_line();
	if (line == NULL)
	    unterminated_text(t_lineno, t_line, t_cptr);
    }
    if (!lflag) fprintf(f, line_format, lineno, input_file_name);
d388 18
a405 23
    c = (unsigned char)*cptr++;
    switch (c)
    {
    case '\n':
    next_line:
	putc('\n', f);
	need_newline = 0;
	get_line();
	if (line) goto loop;
	unterminated_text(t_lineno, t_line, t_cptr);

    case '\'':
    case '"':
	{
	    int s_lineno = lineno;
	    char *s_line = dup_line();
	    char *s_cptr = s_line + (cptr - line - 1);

	    quote = c;
	    putc(c, f);
	    for (;;)
	    {
		c = (unsigned char)*cptr++;
d407 19
a425 5
		if (c == quote)
		{
		    need_newline = 1;
		    free(s_line);
		    goto loop;
a426 14
		if (c == '\n')
		    unterminated_string(s_lineno, s_line, s_cptr);
		if (c == '\\')
		{
		    c = (unsigned char)*cptr++;
		    putc(c, f);
		    if (c == '\n')
		    {
			get_line();
			if (line == NULL)
			    unterminated_string(s_lineno, s_line, s_cptr);
		    }
		}
	    }
d429 1
a429 28
    case '/':
	putc(c, f);
	need_newline = 1;
	c = (unsigned char)*cptr;
	if (c == '/')
	{
	    putc('*', f);
	    while ((c = (unsigned char)*++cptr) != '\n')
	    {
		if (c == '*' && cptr[1] == '/')
		    fprintf(f, "* ");
		else
		    putc(c, f);
	    }
	    fprintf(f, "*/");
	    goto next_line;
	}
	if (c == '*')
	{
	    int c_lineno = lineno;
	    char *c_line = dup_line();
	    char *c_cptr = c_line + (cptr - line - 1);

	    putc('*', f);
	    ++cptr;
	    for (;;)
	    {
		c = (unsigned char)*cptr++;
d431 12
a442 6
		if (c == '*' && *cptr == '/')
		{
		    putc('/', f);
		    ++cptr;
		    free(c_line);
		    goto loop;
d444 41
a484 19
		if (c == '\n')
		{
		    get_line();
		    if (line == NULL)
			unterminated_comment(c_lineno, c_line, c_cptr);
		}
	    }
	}
	need_newline = 1;
	goto loop;

    case '%':
    case '\\':
	if (*cptr == '}')
	{
	    if (need_newline) putc('\n', f);
	    ++cptr;
	    free(t_line);
	    return;
a485 7
	/* fall through */

    default:
	putc(c, f);
	need_newline = 1;
	goto loop;
    }
d492 23
a514 19
    int c;
    int quote;
    int depth;
    int u_lineno = lineno;
    char *u_line = dup_line();
    char *u_cptr = u_line + (cptr - line - 6);

    if (unionized) over_unionized(cptr - 6);
    unionized = 1;

    if (!lflag)
	fprintf(text_file, line_format, lineno, input_file_name);

    fprintf(text_file, "#ifndef YYSTYPE_DEFINED\n");
    fprintf(text_file, "#define YYSTYPE_DEFINED\n");
    fprintf(text_file, "typedef union");
    if (dflag) fprintf(union_file, "#ifndef YYSTYPE_DEFINED\n");
    if (dflag) fprintf(union_file, "#define YYSTYPE_DEFINED\n");
    if (dflag) fprintf(union_file, "typedef union");
d516 1
a516 1
    depth = 0;
d518 22
a539 42
    c = (unsigned char)*cptr++;
    putc(c, text_file);
    if (dflag) putc(c, union_file);
    switch (c)
    {
    case '\n':
    next_line:
	get_line();
	if (line == NULL) unterminated_union(u_lineno, u_line, u_cptr);
	goto loop;

    case '{':
	++depth;
	goto loop;

    case '}':
	if (--depth == 0)
	{
	    fprintf(text_file, " YYSTYPE;\n");
	    fprintf(text_file, "#endif /* YYSTYPE_DEFINED */\n");
	    free(u_line);
	    return;
	}
	goto loop;

    case '\'':
    case '"':
	{
	    int s_lineno = lineno;
	    char *s_line = dup_line();
	    char *s_cptr = s_line + (cptr - line - 1);

	    quote = c;
	    for (;;)
	    {
		c = (unsigned char)*cptr++;
		putc(c, text_file);
		if (dflag) putc(c, union_file);
		if (c == quote)
		{
		    free(s_line);
		    goto loop;
d541 32
a572 13
		if (c == '\n')
		    unterminated_string(s_lineno, s_line, s_cptr);
		if (c == '\\')
		{
		    c = (unsigned char)*cptr++;
		    putc(c, text_file);
		    if (dflag) putc(c, union_file);
		    if (c == '\n')
		    {
			get_line();
			if (line == NULL)
			    unterminated_string(s_lineno, s_line, s_cptr);
		    }
a573 1
	    }
d576 21
a596 12
    case '/':
	c = (unsigned char)*cptr;
	if (c == '/')
	{
	    putc('*', text_file);
	    if (dflag) putc('*', union_file);
	    while ((c = (unsigned char)*++cptr) != '\n')
	    {
		if (c == '*' && cptr[1] == '/')
		{
		    fprintf(text_file, "* ");
		    if (dflag) fprintf(union_file, "* ");
d598 29
a626 31
		else
		{
		    putc(c, text_file);
		    if (dflag) putc(c, union_file);
		}
	    }
	    fprintf(text_file, "*/\n");
	    if (dflag) fprintf(union_file, "*/\n");
	    goto next_line;
	}
	if (c == '*')
	{
	    int c_lineno = lineno;
	    char *c_line = dup_line();
	    char *c_cptr = c_line + (cptr - line - 1);

	    putc('*', text_file);
	    if (dflag) putc('*', union_file);
	    ++cptr;
	    for (;;)
	    {
		c = (unsigned char)*cptr++;
		putc(c, text_file);
		if (dflag) putc(c, union_file);
		if (c == '*' && *cptr == '/')
		{
		    putc('/', text_file);
		    if (dflag) putc('/', union_file);
		    ++cptr;
		    free(c_line);
		    goto loop;
d628 5
a632 13
		if (c == '\n')
		{
		    get_line();
		    if (line == NULL)
			unterminated_comment(c_lineno, c_line, c_cptr);
		}
	    }
	}
	goto loop;

    default:
	goto loop;
    }
d639 92
a730 28
    int c, quote;
    int i;
    int n;
    char *s;
    bucket *bp;
    int s_lineno = lineno;
    char *s_line = dup_line();
    char *s_cptr = s_line + (cptr - line);

    quote = (unsigned char)*cptr++;
    cinc = 0;
    for (;;)
    {
	c = (unsigned char)*cptr++;
	if (c == quote) break;
	if (c == '\n') unterminated_string(s_lineno, s_line, s_cptr);
	if (c == '\\')
	{
	    char *c_cptr = cptr - 1;
	    unsigned long ulval;

	    c = (unsigned char)*cptr++;
	    switch (c)
	    {
	    case '\n':
		get_line();
		if (line == NULL) unterminated_string(s_lineno, s_line, s_cptr);
		continue;
d732 38
a769 47
	    case '0': case '1': case '2': case '3':
	    case '4': case '5': case '6': case '7':
		ulval = strtoul(cptr - 1, &s, 8);
		if (s == cptr - 1 || ulval > MAXCHAR) illegal_character(c_cptr);
		c = (int)ulval;
		cptr = s;
	    	break;

	    case 'x':
		ulval = strtoul(cptr, &s, 16);
		if (s == cptr || ulval > MAXCHAR) illegal_character(c_cptr);
		c = (int)ulval;
		cptr = s;
	    	break;

	    case 'a': c = 7; break;
	    case 'b': c = '\b'; break;
	    case 'f': c = '\f'; break;
	    case 'n': c = '\n'; break;
	    case 'r': c = '\r'; break;
	    case 't': c = '\t'; break;
	    case 'v': c = '\v'; break;
	    }
	}
	cachec(c);
    }
    free(s_line);

    n = cinc;
    s = malloc(n);
    if (s == NULL) no_space();

    memcpy(s, cache, n);

    cinc = 0;
    if (n == 1)
	cachec('\'');
    else
	cachec('"');

    for (i = 0; i < n; ++i)
    {
	c = ((unsigned char *)s)[i];
	if (c == '\\' || c == cache[0])
	{
	    cachec('\\');
	    cachec(c);
d771 3
a773 2
	else if (isprint(c))
	    cachec(c);
d775 8
a782 31
	{
	    cachec('\\');
	    switch (c)
	    {
	    case 7: cachec('a'); break;
	    case '\b': cachec('b'); break;
	    case '\f': cachec('f'); break;
	    case '\n': cachec('n'); break;
	    case '\r': cachec('r'); break;
	    case '\t': cachec('t'); break;
	    case '\v': cachec('v'); break;
	    default:
		cachec(((c >> 6) & 7) + '0');
		cachec(((c >> 3) & 7) + '0');
		cachec((c & 7) + '0');
		break;
	    }
	}
    }

    if (n == 1)
	cachec('\'');
    else
	cachec('"');

    cachec(NUL);
    bp = lookup(cache);
    bp->class = TERM;
    if (n == 1 && bp->value == UNDEFINED)
	bp->value = *(unsigned char *)s;
    free(s);
d784 1
a784 1
    return (bp);
d791 1
a791 1
    char *s;
d793 1
a793 1
    if (strcmp(name, ".") == 0 ||
d796 1
a796 1
	return (1);
d798 8
a805 8
    if (name[0] == '$' && name[1] == '$' && isdigit((unsigned char)name[2]))
    {
	s = name + 3;
	while (isdigit((unsigned char)*s)) ++s;
	if (*s == NUL) return (1);
    }

    return (0);
d812 1
a812 1
    int c;
d814 4
a817 4
    cinc = 0;
    for (c = (unsigned char)*cptr; IS_IDENT(c); c = (unsigned char)*++cptr)
	cachec(c);
    cachec(NUL);
d819 2
a820 1
    if (is_reserved(cache)) used_reserved(cache);
d822 1
a822 1
    return (lookup(cache));
d829 2
a830 2
    int c;
    int n;
d832 3
a834 3
    n = 0;
    for (c = (unsigned char)*cptr; isdigit(c); c = (unsigned char)*++cptr)
	n = 10*n + (c - '0');
d836 1
a836 1
    return (n);
d843 49
a891 45
    int c;
    int i;
    char *s;
    int t_lineno = lineno;
    char *t_line = dup_line();
    char *t_cptr = t_line + (cptr - line);

    ++cptr;
    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (!isalpha(c) && c != '_' && c != '$')
	illegal_tag(t_lineno, t_line, t_cptr);

    cinc = 0;
    do { cachec(c); c = (unsigned char)*++cptr; } while (IS_IDENT(c));
    cachec(NUL);

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c != '>')
	illegal_tag(t_lineno, t_line, t_cptr);
    free(t_line);
    ++cptr;

    for (i = 0; i < ntags; ++i)
    {
	if (strcmp(cache, tag_table[i]) == 0)
	    return (tag_table[i]);
    }

    if (ntags >= tagmax)
    {
	tagmax += 16;
	tag_table = (char **)
			(tag_table ? realloc(tag_table, tagmax*sizeof(char *))
				   : malloc(tagmax*sizeof(char *)));
	if (tag_table == NULL) no_space();
    }

    s = malloc(cinc);
    if  (s == NULL) no_space();
    strlcpy(s, cache, cinc);
    tag_table[ntags] = s;
    ++ntags;
    return (s);
d898 4
a901 34
    int c;
    bucket *bp;
    int value;
    char *tag = 0;

    if (assoc != TOKEN) ++prec;

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c == '<')
    {
	tag = get_tag();
	c = nextc();
	if (c == EOF) unexpected_EOF();
    }

    for (;;)
    {
	if (isalpha(c) || c == '_' || c == '.' || c == '$')
	    bp = get_name();
	else if (c == '\'' || c == '"')
	    bp = get_literal();
	else
	    return;

	if (bp == goal) tokenized_start(bp->name);
	bp->class = TERM;

	if (tag)
	{
	    if (bp->tag && tag != bp->tag)
		retyped_warning(bp->name);
	    bp->tag = tag;
	}
d904 1
a904 6
	{
	    if (bp->prec && prec != bp->prec)
		reprec_warning(bp->name);
	    bp->assoc = assoc;
	    bp->prec = prec;
	}
d907 44
a950 10
	if (c == EOF) unexpected_EOF();
	value = UNDEFINED;
	if (isdigit(c))
	{
	    value = get_number();
	    if (bp->value != UNDEFINED && value != bp->value)
		revalued_warning(bp->name);
	    bp->value = value;
	    c = nextc();
	    if (c == EOF) unexpected_EOF();
a951 1
    }
d956 1
a956 2
 * %expect requires special handling
 * as it really isn't part of the yacc
d962 1
a962 1
    int c;
d964 2
a965 1
    if (assoc != EXPECT) ++prec;
d967 2
a968 18
    /*
     * Stay away from nextc - doesn't
     * detect EOL and will read to EOF.
     */
    c = (unsigned char)*++cptr;
    if (c == EOF) unexpected_EOF();

    for (;;)
    {
        if (isdigit(c))
        {
	    SRexpect = get_number();
            break;
        }
        /*
         * Looking for number before EOL.
         * Spaces, tabs, and numbers are ok,
         * words, punc., etc. are syntax errors.
d970 22
a991 10
        else if (c == '\n' || isalpha(c) || !isspace(c))
        {
            syntax_error(lineno, line, cptr);
        }
        else
        {
            c = (unsigned char)*++cptr;
            if (c == EOF) unexpected_EOF();
        }
    }
d998 3
a1000 8
    int c;
    bucket *bp;
    char *tag;

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c != '<') syntax_error(lineno, line, cptr);
    tag = get_tag();
a1001 2
    for (;;)
    {
d1003 14
a1016 6
	if (isalpha(c) || c == '_' || c == '.' || c == '$')
	    bp = get_name();
	else if (c == '\'' || c == '"')
	    bp = get_literal();
	else
	    return;
d1018 4
a1021 4
	if (bp->tag && tag != bp->tag)
	    retyped_warning(bp->name);
	bp->tag = tag;
    }
d1028 2
a1029 2
    int c;
    bucket *bp;
d1031 11
a1041 10
    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (!isalpha(c) && c != '_' && c != '.' && c != '$')
	syntax_error(lineno, line, cptr);
    bp = get_name();
    if (bp->class == TERM)
	terminal_start(bp->name);
    if (goal && goal != bp)
	restarted_warning();
    goal = bp;
d1048 1
a1048 1
    int c, k;
d1050 46
a1095 44
    cache_size = 256;
    cache = malloc(cache_size);
    if (cache == NULL) no_space();

    for (;;)
    {
	c = nextc();
	if (c == EOF) unexpected_EOF();
	if (c != '%') syntax_error(lineno, line, cptr);
	switch (k = keyword())
	{
	case MARK:
	    return;

	case IDENT:
	    copy_ident();
	    break;

	case TEXT:
	    copy_text();
	    break;

	case UNION:
	    copy_union();
	    break;

	case TOKEN:
	case LEFT:
	case RIGHT:
	case NONASSOC:
	    declare_tokens(k);
	    break;

	case EXPECT:
	    declare_expect(k);
            break;

	case TYPE:
	    declare_types();
	    break;

	case START:
	    declare_start();
	    break;
a1096 1
    }
d1103 26
a1128 22
    nitems = 4;
    maxitems = 300;
    pitem = (bucket **) calloc(maxitems, sizeof(bucket *));
    if (pitem == NULL) no_space();

    nrules = 3;
    maxrules = 100;
    plhs = (bucket **) malloc(maxrules*sizeof(bucket *));
    if (plhs == NULL) no_space();
    plhs[0] = 0;
    plhs[1] = 0;
    plhs[2] = 0;
    rprec = (short *) malloc(maxrules*sizeof(short));
    if (rprec == NULL) no_space();
    rprec[0] = 0;
    rprec[1] = 0;
    rprec[2] = 0;
    rassoc = (char *) malloc(maxrules*sizeof(char));
    if (rassoc == NULL) no_space();
    rassoc[0] = TOKEN;
    rassoc[1] = TOKEN;
    rassoc[2] = TOKEN;
d1135 6
a1140 5
    int olditems = maxitems;
    maxitems += 300;
    pitem = (bucket **) realloc(pitem, maxitems*sizeof(bucket *));
    if (pitem == NULL) no_space();
    memset(pitem + olditems, 0, (maxitems - olditems)*sizeof(bucket *));
d1147 10
a1156 7
    maxrules += 100;
    plhs = (bucket **) realloc(plhs, maxrules*sizeof(bucket *));
    if (plhs == NULL) no_space();
    rprec = (short *) realloc(rprec, maxrules*sizeof(short));
    if (rprec == NULL) no_space();
    rassoc = (char *) realloc(rassoc, maxrules*sizeof(char));
    if (rassoc == NULL) no_space();
d1163 26
a1188 4
    int c;
    bucket *bp;
    char *s_cptr;
    int s_lineno;
a1189 2
    for (;;)
    {
d1191 7
a1197 17
	if (c != '%') break;
	s_cptr = cptr;
	switch (keyword())
	{
	case MARK:
	    no_grammar();

	case TEXT:
	    copy_text();
	    break;

	case START:
	    declare_start();
	    break;

	default:
	    syntax_error(lineno, line, s_cptr);
d1199 8
a1206 19
    }

    c = nextc();
    if (!isalpha(c) && c != '_' && c != '.' && c != '_')
	syntax_error(lineno, line, cptr);
    bp = get_name();
    if (goal == NULL)
    {
	if (bp->class == TERM)
	    terminal_start(bp->name);
	goal = bp;
    }

    s_lineno = lineno;
    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c != ':') syntax_error(lineno, line, cptr);
    start_rule(bp, s_lineno);
    ++cptr;
d1211 1
a1211 1
start_rule(bucket *bp, int s_lineno)
d1213 8
a1220 8
    if (bp->class == TERM)
	terminal_lhs(s_lineno);
    bp->class = NONTERM;
    if (nrules >= maxrules)
	expand_rules();
    plhs[nrules] = bp;
    rprec[nrules] = UNDEFINED;
    rassoc[nrules] = TOKEN;
d1227 1
a1227 1
    int i;
d1229 13
a1241 13
    if (!last_was_action && plhs[nrules]->tag)
    {
	for (i = nitems - 1; pitem[i]; --i) continue;
	if (i == maxitems - 1 || pitem[i+1] == 0 ||
	    pitem[i+1]->tag != plhs[nrules]->tag)
	    default_action_warning();
    }

    last_was_action = 0;
    if (nitems >= maxitems) expand_items();
    pitem[nitems] = 0;
    ++nitems;
    ++nrules;
d1248 1
a1248 1
    bucket *bp, **bpp;
d1250 23
a1272 22
    assert(cache);
    snprintf(cache, cache_size, "$$%d", ++gensym);
    bp = make_bucket(cache);
    last_symbol->next = bp;
    last_symbol = bp;
    bp->tag = plhs[nrules]->tag;
    bp->class = NONTERM;

    if ((nitems += 2) > maxitems)
	expand_items();
    bpp = pitem + nitems - 1;
    *bpp-- = bp;
    while ((bpp[0] = bpp[-1])) --bpp;

    if (++nrules >= maxrules)
	expand_rules();
    plhs[nrules] = plhs[nrules-1];
    plhs[nrules-1] = bp;
    rprec[nrules] = rprec[nrules-1];
    rprec[nrules-1] = 0;
    rassoc[nrules] = rassoc[nrules-1];
    rassoc[nrules-1] = TOKEN;
d1279 9
a1287 9
    int c;
    bucket *bp;
    int s_lineno = lineno;

    c = (unsigned char)*cptr;
    if (c == '\'' || c == '"')
	bp = get_literal();
    else
	bp = get_name();
d1289 14
a1302 16
    c = nextc();
    if (c == ':')
    {
	end_rule();
	start_rule(bp, s_lineno);
	++cptr;
	return;
    }

    if (last_was_action)
	insert_empty_rule();
    last_was_action = 0;

    if (++nitems > maxitems)
	expand_items();
    pitem[nitems-1] = bp;
d1309 19
a1327 18
    int c;
    int i, n;
    int depth;
    int quote;
    char *tag;
    FILE *f = action_file;
    int a_lineno = lineno;
    char *a_line = dup_line();
    char *a_cptr = a_line + (cptr - line);

    if (last_was_action)
	insert_empty_rule();
    last_was_action = 1;

    fprintf(f, "case %d:\n", nrules - 2);
    if (!lflag)
	fprintf(f, line_format, lineno, input_file_name);
    if (*cptr == '=') ++cptr;
d1329 3
a1331 2
    n = 0;
    for (i = nitems - 1; pitem[i]; --i) ++n;
d1333 1
a1333 1
    depth = 0;
d1335 70
a1404 17
    c = (unsigned char)*cptr;
    if (c == '$')
    {
	if (cptr[1] == '<')
	{
	    int d_lineno = lineno;
	    char *d_line = dup_line();
	    char *d_cptr = d_line + (cptr - line);

	    ++cptr;
	    tag = get_tag();
	    c = (unsigned char)*cptr;
	    if (c == '$')
	    {
		fprintf(f, "yyval.%s", tag);
		++cptr;
		free(d_line);
d1406 20
a1425 7
	    }
	    else if (isdigit(c))
	    {
		i = get_number();
		if (i > n) dollar_warning(d_lineno, i);
		fprintf(f, "yyvsp[%d].%s", i - n, tag);
		free(d_line);
d1427 33
a1459 119
	    }
	    else if (c == '-' && isdigit((unsigned char)cptr[1]))
	    {
		++cptr;
		i = -get_number() - n;
		fprintf(f, "yyvsp[%d].%s", i, tag);
		free(d_line);
		goto loop;
	    }
	    else
		dollar_error(d_lineno, d_line, d_cptr);
	}
	else if (cptr[1] == '$')
	{
	    if (ntags)
	    {
		tag = plhs[nrules]->tag;
		if (tag == NULL) untyped_lhs();
		fprintf(f, "yyval.%s", tag);
	    }
	    else
		fprintf(f, "yyval");
	    cptr += 2;
	    goto loop;
	}
	else if (isdigit((unsigned char)cptr[1]))
	{
	    ++cptr;
	    i = get_number();
	    if (ntags)
	    {
		if (i <= 0 || i > n)
		    unknown_rhs(i);
		tag = pitem[nitems + i - n - 1]->tag;
		if (tag == NULL) untyped_rhs(i, pitem[nitems + i - n - 1]->name);
		fprintf(f, "yyvsp[%d].%s", i - n, tag);
	    }
	    else
	    {
		if (i > n)
		    dollar_warning(lineno, i);
		fprintf(f, "yyvsp[%d]", i - n);
	    }
	    goto loop;
	}
	else if (cptr[1] == '-')
	{
	    cptr += 2;
	    i = get_number();
	    if (ntags)
		unknown_rhs(-i);
	    fprintf(f, "yyvsp[%d]", -i - n);
	    goto loop;
	}
    }
    if (isalpha(c) || c == '_' || c == '$')
    {
	do
	{
	    putc(c, f);
	    c = (unsigned char)*++cptr;
	} while (isalnum(c) || c == '_' || c == '$');
	goto loop;
    }
    putc(c, f);
    ++cptr;
    switch (c)
    {
    case '\n':
    next_line:
	get_line();
	if (line) goto loop;
	unterminated_action(a_lineno, a_line, a_cptr);

    case ';':
	if (depth > 0) goto loop;
	fprintf(f, "\nbreak;\n");
	free(a_line);
	return;

    case '{':
	++depth;
	goto loop;

    case '}':
	if (--depth > 0) goto loop;
	fprintf(f, "\nbreak;\n");
	free(a_line);
	return;

    case '\'':
    case '"':
	{
	    int s_lineno = lineno;
	    char *s_line = dup_line();
	    char *s_cptr = s_line + (cptr - line - 1);

	    quote = c;
	    for (;;)
	    {
		c = (unsigned char)*cptr++;
		putc(c, f);
		if (c == quote)
		{
		    free(s_line);
		    goto loop;
		}
		if (c == '\n')
		    unterminated_string(s_lineno, s_line, s_cptr);
		if (c == '\\')
		{
		    c = (unsigned char)*cptr++;
		    putc(c, f);
		    if (c == '\n')
		    {
			get_line();
			if (line == NULL)
			    unterminated_string(s_lineno, s_line, s_cptr);
		    }
a1460 1
	    }
d1463 35
a1497 33
    case '/':
	c = (unsigned char)*cptr;
	if (c == '/')
	{
	    putc('*', f);
	    while ((c = (unsigned char)*++cptr) != '\n')
	    {
		if (c == '*' && cptr[1] == '/')
		    fprintf(f, "* ");
		else
		    putc(c, f);
	    }
	    fprintf(f, "*/\n");
	    goto next_line;
	}
	if (c == '*')
	{
	    int c_lineno = lineno;
	    char *c_line = dup_line();
	    char *c_cptr = c_line + (cptr - line - 1);

	    putc('*', f);
	    ++cptr;
	    for (;;)
	    {
		c = (unsigned char)*cptr++;
		putc(c, f);
		if (c == '*' && *cptr == '/')
		{
		    putc('/', f);
		    ++cptr;
		    free(c_line);
		    goto loop;
d1499 5
a1503 13
		if (c == '\n')
		{
		    get_line();
		    if (line == NULL)
			unterminated_comment(c_lineno, c_line, c_cptr);
		}
	    }
	}
	goto loop;

    default:
	goto loop;
    }
d1510 2
a1511 2
    int c;
    bucket *bp = NULL;
d1513 15
a1527 17
    c = (unsigned char)cptr[1];
    if (c == '%' || c == '\\')
    {
	cptr += 2;
	return (1);
    }

    if (c == '=')
	cptr += 2;
    else if ((c == 'p' || c == 'P') &&
	     ((c = cptr[2]) == 'r' || c == 'R') &&
	     ((c = cptr[3]) == 'e' || c == 'E') &&
	     ((c = cptr[4]) == 'c' || c == 'C') &&
	     ((c = (unsigned char)cptr[5], !IS_IDENT(c))))
	cptr += 5;
    else
	syntax_error(lineno, line, cptr);
d1529 16
a1544 17
    c = nextc();
    if (isalpha(c) || c == '_' || c == '.' || c == '$')
	bp = get_name();
    else if (c == '\'' || c == '"')
	bp = get_literal();
    else
    {
	syntax_error(lineno, line, cptr);
	/*NOTREACHED*/
    }

    if (rprec[nrules] != UNDEFINED && bp->prec != rprec[nrules])
	prec_redeclared();

    rprec[nrules] = bp->prec;
    rassoc[nrules] = bp->assoc;
    return (0);
d1551 1
a1551 1
    int c;
d1553 2
a1554 2
    initialize_grammar();
    advance_to_start();
d1556 18
a1573 18
    for (;;)
    {
	c = nextc();
	if (c == EOF) break;
	if (isalpha(c) || c == '_' || c == '.' || c == '$' || c == '\'' ||
		c == '"')
	    add_symbol();
	else if (c == '{' || c == '=')
	    copy_action();
	else if (c == '|')
	{
	    end_rule();
	    start_rule(plhs[nrules-1], 0);
	    ++cptr;
	}
	else if (c == '%')
	{
	    if (mark_symbol()) break;
d1575 1
a1575 4
	else
	    syntax_error(lineno, line, cptr);
    }
    end_rule();
d1582 1
a1582 1
    int i;
d1584 2
a1585 1
    if (tag_table == NULL) return;
d1587 5
a1591 6
    for (i = 0; i < ntags; ++i)
    {
	assert(tag_table[i]);
	free(tag_table[i]);
    }
    free(tag_table);
d1598 2
a1599 2
    bucket *bp;
    char *p, *s, *t;
d1601 18
a1618 17
    name_pool_size = 13;  /* 13 == sizeof("$end") + sizeof("$accept") */
    for (bp = first_symbol; bp; bp = bp->next)
	name_pool_size += strlen(bp->name) + 1;
    name_pool = malloc(name_pool_size);
    if (name_pool == NULL) no_space();

    strlcpy(name_pool, "$accept", name_pool_size);
    strlcpy(name_pool+8, "$end", name_pool_size - 8);
    t = name_pool + 13;
    for (bp = first_symbol; bp; bp = bp->next)
    {
	p = t;
	s = bp->name;
	while ((*t++ = *s++)) continue;
	free(bp->name);
	bp->name = p;
    }
d1625 1
a1625 1
    bucket *bp;
d1627 2
a1628 2
    if (goal->class == UNKNOWN)
	undefined_goal(goal->name);
d1630 5
a1634 6
    for (bp = first_symbol; bp; bp = bp->next)
    {
	if (bp->class == UNKNOWN)
	{
	    undefined_symbol_warning(bp->name);
	    bp->class = TERM;
a1635 1
    }
d1642 111
a1752 117
    bucket *bp;
    bucket **v;
    int i, j, k, n;

    nsyms = 2;
    ntokens = 1;
    for (bp = first_symbol; bp; bp = bp->next)
    {
	++nsyms;
	if (bp->class == TERM) ++ntokens;
    }
    start_symbol = ntokens;
    nvars = nsyms - ntokens;

    symbol_name = (char **) malloc(nsyms*sizeof(char *));
    if (symbol_name == NULL) no_space();
    symbol_value = (short *) malloc(nsyms*sizeof(short));
    if (symbol_value == NULL) no_space();
    symbol_prec = (short *) malloc(nsyms*sizeof(short));
    if (symbol_prec == NULL) no_space();
    symbol_assoc = malloc(nsyms);
    if (symbol_assoc == NULL) no_space();

    v = (bucket **) malloc(nsyms*sizeof(bucket *));
    if (v == NULL) no_space();

    v[0] = 0;
    v[start_symbol] = 0;

    i = 1;
    j = start_symbol + 1;
    for (bp = first_symbol; bp; bp = bp->next)
    {
	if (bp->class == TERM)
	    v[i++] = bp;
	else
	    v[j++] = bp;
    }
    assert(i == ntokens && j == nsyms);

    for (i = 1; i < ntokens; ++i)
	v[i]->index = i;

    goal->index = start_symbol + 1;
    k = start_symbol + 2;
    while (++i < nsyms)
	if (v[i] != goal)
	{
	    v[i]->index = k;
	    ++k;
	}

    goal->value = 0;
    k = 1;
    for (i = start_symbol + 1; i < nsyms; ++i)
    {
	if (v[i] != goal)
	{
	    v[i]->value = k;
	    ++k;
	}
    }

    k = 0;
    for (i = 1; i < ntokens; ++i)
    {
	n = v[i]->value;
	if (n > 256)
	{
	    for (j = k++; j > 0 && symbol_value[j-1] > n; --j)
		symbol_value[j] = symbol_value[j-1];
	    symbol_value[j] = n;
	}
    }

    if (v[1]->value == UNDEFINED)
	v[1]->value = 256;

    j = 0;
    n = 257;
    for (i = 2; i < ntokens; ++i)
    {
	if (v[i]->value == UNDEFINED)
	{
	    while (j < k && n == symbol_value[j])
	    {
		while (++j < k && n == symbol_value[j]) continue;
		++n;
	    }
	    v[i]->value = n;
	    ++n;
	}
    }

    symbol_name[0] = name_pool + 8;
    symbol_value[0] = 0;
    symbol_prec[0] = 0;
    symbol_assoc[0] = TOKEN;
    for (i = 1; i < ntokens; ++i)
    {
	symbol_name[i] = v[i]->name;
	symbol_value[i] = v[i]->value;
	symbol_prec[i] = v[i]->prec;
	symbol_assoc[i] = v[i]->assoc;
    }
    symbol_name[start_symbol] = name_pool;
    symbol_value[start_symbol] = -1;
    symbol_prec[start_symbol] = 0;
    symbol_assoc[start_symbol] = TOKEN;
    for (++i; i < nsyms; ++i)
    {
	k = v[i]->index;
	symbol_name[k] = v[i]->name;
	symbol_value[k] = v[i]->value;
	symbol_prec[k] = v[i]->prec;
	symbol_assoc[k] = v[i]->assoc;
    }
d1754 1
a1754 1
    free(v);
d1761 2
a1762 2
    int i, j;
    int assoc, prec;
d1764 48
a1811 26
    ritem = (short *) malloc(nitems*sizeof(short));
    if (ritem == NULL) no_space();
    rlhs = (short *) malloc(nrules*sizeof(short));
    if (rlhs == NULL) no_space();
    rrhs = (short *) malloc((nrules+1)*sizeof(short));
    if (rrhs == NULL) no_space();
    rprec = (short *) realloc(rprec, nrules*sizeof(short));
    if (rprec == NULL) no_space();
    rassoc = realloc(rassoc, nrules);
    if (rassoc == NULL) no_space();

    ritem[0] = -1;
    ritem[1] = goal->index;
    ritem[2] = 0;
    ritem[3] = -2;
    rlhs[0] = 0;
    rlhs[1] = 0;
    rlhs[2] = start_symbol;
    rrhs[0] = 0;
    rrhs[1] = 0;
    rrhs[2] = 1;

    j = 4;
    for (i = 3; i < nrules; ++i)
    {
	rlhs[i] = plhs[i]->index;
a1812 21
	assoc = TOKEN;
	prec = 0;
	while (pitem[j])
	{
	    ritem[j] = pitem[j]->index;
	    if (pitem[j]->class == TERM)
	    {
		prec = pitem[j]->prec;
		assoc = pitem[j]->assoc;
	    }
	    ++j;
	}
	ritem[j] = -i;
	++j;
	if (rprec[i] == UNDEFINED)
	{
	    rprec[i] = prec;
	    rassoc[i] = assoc;
	}
    }
    rrhs[i] = j;
d1814 2
a1815 2
    free(plhs);
    free(pitem);
d1822 28
a1849 14
    int i, j, k;
    int spacing = 0;
    FILE *f = verbose_file;

    if (!vflag) return;

    k = 1;
    for (i = 2; i < nrules; ++i)
    {
	if (rlhs[i] != rlhs[i-1])
	{
	    if (i != 2) fprintf(f, "\n");
	    fprintf(f, "%4d  %s :", i - 2, symbol_name[rlhs[i]]);
	    spacing = strlen(symbol_name[rlhs[i]]) + 1;
a1850 16
	else
	{
	    fprintf(f, "%4d  ", i - 2);
	    j = spacing;
	    while (--j >= 0) putc(' ', f);
	    putc('|', f);
	}

	while (ritem[k] >= 0)
	{
	    fprintf(f, " %s", symbol_name[ritem[k]]);
	    ++k;
	}
	++k;
	putc('\n', f);
    }
d1857 12
a1868 12
    write_section(banner);
    create_symbol_table();
    read_declarations();
    read_grammar();
    free_symbol_table();
    free_tags();
    pack_names();
    check_symbols();
    pack_symbols();
    pack_grammar();
    free_symbols();
    print_grammar();
@


1.25
log
@Add casts to unsigned char for ctype functions and other places
where a char is stored in an int.  Joint work with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.24 2014/01/08 21:40:25 millert Exp $	*/
a77 1
int hexval(int);
a654 13
int
hexval(int c)
{
    if (c >= '0' && c <= '9')
	return (c - '0');
    if (c >= 'A' && c <= 'F')
	return (c - 'A' + 10);
    if (c >= 'a' && c <= 'f')
	return (c - 'a' + 10);
    return (-1);
}


d677 1
d689 4
a692 14
		n = c - '0';
		c = (unsigned char)*cptr;
		if (IS_OCTAL(c))
		{
		    n = (n << 3) + (c - '0');
		    c = (unsigned char)*++cptr;
		    if (IS_OCTAL(c))
		    {
			n = (n << 3) + (c - '0');
			++cptr;
		    }
		}
		if (n > MAXCHAR) illegal_character(c_cptr);
		c = n;
d696 5
a700 15
		c = (unsigned char)*cptr++;
		n = hexval(c);
		if (n < 0 || n >= 16)
		    illegal_character(c_cptr);
		for (;;)
		{
		    c = (unsigned char)*cptr;
		    i = hexval(c);
		    if (i < 0 || i >= 16) break;
		    ++cptr;
		    n = (n << 4) + i;
		    if (n > MAXCHAR) illegal_character(c_cptr);
		}
		c = n;
		break;
@


1.24
log
@Remove CALLOC, MALLOC, FREE and REALLOC macros and just call calloc(),
nalloc(), free() and realloc() directly.  The macros were casting
to the wrong (pre-C89) types and there is no need for them in a C89
world.  OK matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.23 2012/04/15 12:44:38 chl Exp $	*/
d276 1
a276 1
	    return (*s);
d288 1
a288 1
    c = *++cptr;
d303 1
a303 1
	    c = *++cptr;
d361 1
a361 1
	c = *++cptr;
d398 1
a398 1
    c = *cptr++;
d420 1
a420 1
		c = *cptr++;
d432 1
a432 1
		    c = *cptr++;
d447 1
a447 1
	c = *cptr;
d451 1
a451 1
	    while ((c = *++cptr) != '\n')
d471 1
a471 1
		c = *cptr++;
d535 1
a535 1
    c = *cptr++;
d570 1
a570 1
		c = *cptr++;
d582 1
a582 1
		    c = *cptr++;
d596 1
a596 1
	c = *cptr;
d601 1
a601 1
	    while ((c = *++cptr) != '\n')
d629 1
a629 1
		c = *cptr++;
d681 1
a681 1
    quote = *cptr++;
d685 1
a685 1
	c = *cptr++;
d692 1
a692 1
	    c = *cptr++;
d703 1
a703 1
		c = *cptr;
d707 1
a707 1
		    c = *++cptr;
d719 1
a719 1
		c = *cptr++;
d725 1
a725 1
		    c = *cptr;
d817 1
a817 1
    if (name[0] == '$' && name[1] == '$' && isdigit(name[2]))
d820 1
a820 1
	while (isdigit(*s)) ++s;
d834 1
a834 1
    for (c = *cptr; IS_IDENT(c); c = *++cptr)
d851 1
a851 1
    for (c = *cptr; isdigit(c); c = *++cptr)
d875 1
a875 1
    do { cachec(c); c = *++cptr; } while (IS_IDENT(c));
d987 1
a987 1
    c = *++cptr;
d1008 1
a1008 1
            c = *++cptr;
d1292 1
a1292 1
    c = *cptr;
d1344 1
a1344 1
    c = *cptr;
d1355 1
a1355 1
	    c = *cptr;
d1371 1
a1371 1
	    else if (c == '-' && isdigit(cptr[1]))
d1395 1
a1395 1
	else if (isdigit(cptr[1]))
d1430 1
a1430 1
	    c = *++cptr;
d1470 1
a1470 1
		c = *cptr++;
d1481 1
a1481 1
		    c = *cptr++;
d1494 1
a1494 1
	c = *cptr;
d1498 1
a1498 1
	    while ((c = *++cptr) != '\n')
d1518 1
a1518 1
		c = *cptr++;
d1549 1
a1549 1
    c = cptr[1];
d1562 1
a1562 1
	     ((c = cptr[5], !IS_IDENT(c))))
@


1.23
log
@* Use NULL instead of 0 for pointers
* Replace loop with memcpy() in function get_literal()
* Style tweak: "for(" -> "for ("

From Michael W. Bombardieri

ok nicm@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.22 2010/07/14 13:13:42 nicm Exp $	*/
d116 1
a116 1
	cache = REALLOC(cache, cache_size);
d133 1
a133 1
	if (line) { FREE(line); line = 0; }
d141 1
a141 1
	if (line) FREE(line);
d143 1
a143 1
	line = MALLOC(linesize);
d156 1
a156 1
	    line = REALLOC(line, linesize);
d179 1
a179 1
    p = MALLOC(s - line + 1);
d204 1
a204 1
	    FREE(st_line);
d425 1
a425 1
		    FREE(s_line);
d477 1
a477 1
		    FREE(c_line);
d497 1
a497 1
	    FREE(t_line);
d555 1
a555 1
	    FREE(u_line);
d575 1
a575 1
		    FREE(s_line);
d637 1
a637 1
		    FREE(c_line);
d746 1
a746 1
    FREE(s_line);
d749 1
a749 1
    s = MALLOC(n);
d801 1
a801 1
    FREE(s);
d882 1
a882 1
    FREE(t_line);
d895 2
a896 2
			(tag_table ? REALLOC(tag_table, tagmax*sizeof(char *))
				   : MALLOC(tagmax*sizeof(char *)));
d900 1
a900 1
    s = MALLOC(cinc);
d1069 1
a1069 1
    cache = MALLOC(cache_size);
d1122 1
a1122 1
    pitem = (bucket **) CALLOC(maxitems, sizeof(bucket *));
d1127 1
a1127 1
    plhs = (bucket **) MALLOC(maxrules*sizeof(bucket *));
d1132 1
a1132 1
    rprec = (short *) MALLOC(maxrules*sizeof(short));
d1137 1
a1137 1
    rassoc = (char *) MALLOC(maxrules*sizeof(char));
d1150 1
a1150 1
    pitem = (bucket **) REALLOC(pitem, maxitems*sizeof(bucket *));
d1160 1
a1160 1
    plhs = (bucket **) REALLOC(plhs, maxrules*sizeof(bucket *));
d1162 1
a1162 1
    rprec = (short *) REALLOC(rprec, maxrules*sizeof(short));
d1164 1
a1164 1
    rassoc = (char *) REALLOC(rassoc, maxrules*sizeof(char));
d1360 1
a1360 1
		FREE(d_line);
d1368 1
a1368 1
		FREE(d_line);
d1376 1
a1376 1
		FREE(d_line);
d1447 1
a1447 1
	FREE(a_line);
d1457 1
a1457 1
	FREE(a_line);
d1474 1
a1474 1
		    FREE(s_line);
d1524 1
a1524 1
		    FREE(c_line);
d1631 1
a1631 1
	FREE(tag_table[i]);
d1633 1
a1633 1
    FREE(tag_table);
d1646 1
a1646 1
    name_pool = MALLOC(name_pool_size);
d1657 1
a1657 1
	FREE(bp->name);
d1699 1
a1699 1
    symbol_name = (char **) MALLOC(nsyms*sizeof(char *));
d1701 1
a1701 1
    symbol_value = (short *) MALLOC(nsyms*sizeof(short));
d1703 1
a1703 1
    symbol_prec = (short *) MALLOC(nsyms*sizeof(short));
d1705 1
a1705 1
    symbol_assoc = MALLOC(nsyms);
d1708 1
a1708 1
    v = (bucket **) MALLOC(nsyms*sizeof(bucket *));
d1803 1
a1803 1
    FREE(v);
d1813 1
a1813 1
    ritem = (short *) MALLOC(nitems*sizeof(short));
d1815 1
a1815 1
    rlhs = (short *) MALLOC(nrules*sizeof(short));
d1817 1
a1817 1
    rrhs = (short *) MALLOC((nrules+1)*sizeof(short));
d1819 1
a1819 1
    rprec = (short *) REALLOC(rprec, nrules*sizeof(short));
d1821 1
a1821 1
    rassoc = REALLOC(rassoc, nrules);
d1862 2
a1863 2
    FREE(plhs);
    FREE(pitem);
@


1.22
log
@Zero the pitem array so checking items after those used works as
expected, also do not look beyond the size of the array.

ok otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.21 2009/10/27 23:59:50 deraadt Exp $	*/
d117 1
a117 1
	if (cache == 0) no_space();
d139 1
a139 1
    if (line == 0 || linesize != (LINESIZE + 1))
d144 1
a144 1
	if (line == 0) no_space();
d176 1
a176 1
    if (line == 0) return (0);
d180 1
a180 1
    if (p == 0) no_space();
d210 1
a210 1
	    if (line == 0)
d225 1
a225 1
    if (line == 0)
d228 1
a228 1
	if (line == 0)
d239 1
a239 1
	    if (line == 0) return (EOF);
d268 1
a268 1
		if (line == 0) return (EOF);
d392 1
a392 1
	if (line == 0)
d437 1
a437 1
			if (line == 0)
d483 1
a483 1
		    if (line == 0)
d543 1
a543 1
	if (line == 0) unterminated_union(u_lineno, u_line, u_cptr);
d588 1
a588 1
			if (line == 0)
d643 1
a643 1
		    if (line == 0)
d697 1
a697 1
		if (line == 0) unterminated_string(s_lineno, s_line, s_cptr);
d750 1
a750 1
    if (s == 0) no_space();
d752 1
a752 2
    for (i = 0; i < n; ++i)
	s[i] = cache[i];
d897 1
a897 1
	if (tag_table == 0) no_space();
d901 1
a901 1
    if  (s == 0) no_space();
d990 1
a990 1
    for(;;)
d1070 1
a1070 1
    if (cache == 0) no_space();
d1123 1
a1123 1
    if (pitem == 0) no_space();
d1128 1
a1128 1
    if (plhs == 0) no_space();
d1133 1
a1133 1
    if (rprec == 0) no_space();
d1138 1
a1138 1
    if (rassoc == 0) no_space();
d1151 1
a1151 1
    if (pitem == 0) no_space();
d1161 1
a1161 1
    if (plhs == 0) no_space();
d1163 1
a1163 1
    if (rprec == 0) no_space();
d1165 1
a1165 1
    if (rassoc == 0) no_space();
d1204 1
a1204 1
    if (goal == 0)
d1387 1
a1387 1
		if (tag == 0) untyped_lhs();
d1404 1
a1404 1
		if (tag == 0) untyped_rhs(i, pitem[nitems + i - n - 1]->name);
d1486 1
a1486 1
			if (line == 0)
d1530 1
a1530 1
		    if (line == 0)
d1626 1
a1626 1
    if (tag_table == 0) return;
d1647 1
a1647 1
    if (name_pool == 0) no_space();
d1700 1
a1700 1
    if (symbol_name == 0) no_space();
d1702 1
a1702 1
    if (symbol_value == 0) no_space();
d1704 1
a1704 1
    if (symbol_prec == 0) no_space();
d1706 1
a1706 1
    if (symbol_assoc == 0) no_space();
d1709 1
a1709 1
    if (v == 0) no_space();
d1814 1
a1814 1
    if (ritem == 0) no_space();
d1816 1
a1816 1
    if (rlhs == 0) no_space();
d1818 1
a1818 1
    if (rrhs == 0) no_space();
d1820 1
a1820 1
    if (rprec == 0) no_space();
d1822 1
a1822 1
    if (rassoc == 0) no_space();
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.20 2006/04/21 07:38:16 deraadt Exp $	*/
d1123 1
a1123 1
    pitem = (bucket **) MALLOC(maxitems*sizeof(bucket *));
a1124 4
    pitem[0] = 0;
    pitem[1] = 0;
    pitem[2] = 0;
    pitem[3] = 0;
d1149 1
d1153 1
d1243 2
a1244 1
	if (pitem[i+1] == 0 || pitem[i+1]->tag != plhs[nrules]->tag)
@


1.20
log
@back out last (powerpc on bgpd build shows it is wrong)
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.18 2005/06/10 16:40:45 pvalchev Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)reader.c	5.7 (Berkeley) 1/20/91";
#else
static char rcsid[] = "$NetBSD: reader.c,v 1.5 1996/03/19 03:21:43 jtc Exp $";
#endif
#endif /* not lint */
@


1.19
log
@Fix off-by-one read caused by bad grammars. I think this defect was
present in the very first version of byacc from the early 90's and was
only triggered recently when I used malloc.conf -> JG on a bad gramamr.
OK millert@@
@
text
@d1253 1
a1253 1
	if (pitem[i] == 0 || pitem[i]->tag != plhs[nrules]->tag)
@


1.18
log
@-Wall clean; ok otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.17 2004/08/08 20:13:13 deraadt Exp $	*/
d1253 1
a1253 1
	if (pitem[i+1] == 0 || pitem[i+1]->tag != plhs[nrules]->tag)
@


1.17
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.16 2004/01/06 05:35:26 deraadt Exp $	*/
d1557 1
a1557 1
    bucket *bp;
d1881 1
a1881 1
    int spacing;
@


1.16
log
@protect output from %union from being anonymous using cpp guarding, for
the case where the yacc output .c file pulls in the yacc output -h file;
espie ok
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.15 2003/06/19 16:34:53 pvalchev Exp $	*/
d86 1
a86 1
int hexval(int); 
d759 1
a759 1
    
@


1.15
log
@ansify; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.14 2003/06/03 02:56:24 millert Exp $	*/
d534 2
d537 2
d562 1
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 2
/*	$OpenBSD: reader.c,v 1.13 2003/04/08 00:18:13 deraadt Exp $	*/

d118 1
a118 2
cachec(c)
int c;
d133 1
a133 1
get_line()
d180 1
a180 1
dup_line()
d198 1
a198 1
skip_comment()
d229 1
a229 1
nextc()
d291 1
a291 1
keyword()
d357 1
a357 1
copy_ident()
d387 1
a387 1
copy_text()
d519 1
a519 1
copy_union()
d660 1
a660 2
hexval(c)
int c;
d673 1
a673 1
get_literal()
d812 1
a812 2
is_reserved(name)
char *name;
d833 1
a833 1
get_name()
d849 1
a849 1
get_number()
d863 1
a863 1
get_tag()
d914 1
a914 2
declare_tokens(assoc)
int assoc;
d981 1
a981 2
declare_expect(assoc)
int assoc;
d1020 1
a1020 1
declare_types()
d1049 1
a1049 1
declare_start()
d1068 1
a1068 1
read_declarations()
d1122 1
a1122 1
initialize_grammar()
d1154 1
a1154 1
expand_items()
d1163 1
a1163 1
expand_rules()
d1176 1
a1176 1
advance_to_start()
d1227 1
a1227 3
start_rule(bp, s_lineno)
bucket *bp;
int s_lineno;
d1241 1
a1241 1
end_rule()
d1261 1
a1261 1
insert_empty_rule()
d1291 1
a1291 1
add_symbol()
d1323 1
a1323 1
copy_action()
d1549 1
a1549 1
mark_symbol()
d1593 1
a1593 1
read_grammar()
d1627 1
a1627 1
free_tags()
d1643 1
a1643 1
pack_names()
d1669 1
a1669 1
check_symbols()
d1688 1
a1688 1
pack_symbols()
d1813 1
a1813 1
pack_grammar()
d1873 1
a1873 1
print_grammar()
d1910 1
a1910 1
reader()
@


1.13
log
@string cleaning; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.12 2003/03/13 09:09:37 deraadt Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.11 2002/06/14 21:35:00 todd Exp $	*/
d914 1
a914 1
    strcpy(s, cache);
d1666 2
a1667 2
    strcpy(name_pool, "$accept");
    strcpy(name_pool+8, "$end");
@


1.11
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.10 2002/02/16 21:28:00 millert Exp $	*/
d1278 1
a1278 1
    sprintf(cache, "$$%d", ++gensym);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.9 2001/11/19 19:02:18 mpech Exp $	*/
d54 1
a54 1
/*  will be expanded to accomodate it.					*/
@


1.9
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.8 2001/07/16 06:29:45 pvalchev Exp $	*/
d82 37
a118 37
void cachec __P((int));
void get_line __P((void));
char * dup_line __P((void));
void skip_comment __P((void));
int nextc __P((void));
int keyword __P((void));
void copy_ident __P((void));
void copy_text __P((void));
void copy_union __P((void));
int hexval __P((int)); 
bucket * get_literal __P((void));
int is_reserved __P((char *));
bucket * get_name __P((void));
int get_number __P((void));
char * get_tag __P((void));
void declare_tokens __P((int));
void declare_types __P((void));
void declare_start __P((void));
void handle_expect __P((void));
void read_declarations __P((void));
void initialize_grammar __P((void));
void expand_items __P((void));
void expand_rules __P((void));
void advance_to_start __P((void));
void start_rule __P((bucket *, int));
void end_rule __P((void));
void insert_empty_rule __P((void));
void add_symbol __P((void));
void copy_action __P((void));
int mark_symbol __P((void));
void read_grammar __P((void));
void free_tags __P((void));
void pack_names __P((void));
void check_symbols __P((void));
void pack_symbols __P((void));
void pack_grammar __P((void));
void print_grammar __P((void));
@


1.8
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.7 2001/07/12 05:17:33 deraadt Exp $	*/
d141 3
a143 3
    register FILE *f = input_file;
    register int c;
    register int i;
d188 1
a188 1
    register char *p, *s, *t;
d206 1
a206 1
    register char *s;
d237 1
a237 1
    register char *s;
d299 1
a299 1
    register int c;
d365 2
a366 2
    register int c;
    register FILE *f = output_file;
d395 1
a395 1
    register int c;
d397 1
a397 1
    register FILE *f = text_file;
d527 1
a527 1
    register int c;
d682 5
a686 5
    register int c, quote;
    register int i;
    register int n;
    register char *s;
    register bucket *bp;
d843 1
a843 1
    register int c;
d859 2
a860 2
    register int c;
    register int n;
d873 3
a875 3
    register int c;
    register int i;
    register char *s;
d925 2
a926 2
    register int c;
    register bucket *bp;
d993 1
a993 1
    register int c;
d1032 2
a1033 2
    register int c;
    register bucket *bp;
d1061 2
a1062 2
    register int c;
    register bucket *bp;
d1080 1
a1080 1
    register int c, k;
d1188 2
a1189 2
    register int c;
    register bucket *bp;
d1238 1
a1238 1
register bucket *bp;
d1255 1
a1255 1
    register int i;
d1275 1
a1275 1
    register bucket *bp, **bpp;
d1305 2
a1306 2
    register int c;
    register bucket *bp;
d1337 2
a1338 2
    register int c;
    register int i, n;
d1342 1
a1342 1
    register FILE *f = action_file;
d1563 2
a1564 2
    register int c;
    register bucket *bp;
d1607 1
a1607 1
    register int c;
d1641 1
a1641 1
    register int i;
d1657 2
a1658 2
    register bucket *bp;
    register char *p, *s, *t;
d1683 1
a1683 1
    register bucket *bp;
d1702 3
a1704 3
    register bucket *bp;
    register bucket **v;
    register int i, j, k, n;
d1827 1
a1827 1
    register int i, j;
d1887 1
a1887 1
    register int i, j, k;
d1889 1
a1889 1
    register FILE *f = verbose_file;
@


1.7
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.6 1998/11/24 01:21:29 deraadt Exp $	*/
d82 38
a121 1

d358 1
d392 1
d524 1
d921 1
d989 1
d1029 1
d1058 1
d1077 1
d1131 1
d1163 1
d1172 1
d1185 1
d1236 1
d1252 1
d1272 1
d1289 1
a1289 1
    while (bpp[0] = bpp[-1]) --bpp;
d1302 1
d1334 1
d1604 1
d1638 1
d1654 1
d1673 1
a1673 1
	while (*t++ = *s++) continue;
d1680 1
d1699 1
d1824 1
d1884 1
d1921 1
@


1.6
log
@fix memory leaks; itohy@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.5 1996/04/21 23:45:19 deraadt Exp $	*/
d85 1
d101 1
d166 1
d324 1
@


1.5
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD: reader.c,v 1.4 1996/03/31 04:56:01 etheisen Exp $	*/
d850 1
a872 1
    FREE(t_line);
d1406 1
d1416 1
@


1.4
log
@Fix 960317 NetBSD merge error.  Merge caused local OpenBSD mod lossage.

NetBSD's byacc %expect mods are buggy and don't handle syntax or semantic
errors.  Additionally, they do not mimic the BISON behavior they try to
emulate.  Our local OpenBSD %expect mods are much better.
@
text
@d1 39
a39 1
/*	$OpenBSD$	*/
d42 5
a46 1
static char rcsid[] = "$Id$";
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d4 1
a4 1
static char rcsid[] = "$OpenBSD$";
d897 44
a985 17
handle_expect()
{
    register int c;
    register int num;

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (!isdigit(c))
	syntax_error(lineno, line, cptr);
    num = get_number();
    if (num == 1)
    	fprintf (stderr, "%s: Expect 1 shift/reduce conflict.\n", myname);
    else
	fprintf (stderr, "%s: Expect %d shift/reduce conflicts.\n", myname,
	    num);
}

d1024 4
a1033 4
	    break;

	case EXPECT:
	    handle_expect();
@


1.2
log
@Yacc now understands %expect keyword.  This should help prevent yacc from
gagging on GNU bison grammer.
@
text
@d1 2
d4 1
a4 1
static char rcsid[] = "$Id: reader.c,v 1.1.1.1 1995/10/18 08:47:06 deraadt Exp $";
a896 44
/*
 * %expect requires special handling
 * as it really isn't part of the yacc
 * grammar only a flag for yacc proper.
 */
declare_expect(assoc)
int assoc;
{
    register int c;

    if (assoc != EXPECT) ++prec;

    /*
     * Stay away from nextc - doesn't
     * detect EOL and will read to EOF.
     */
    c = *++cptr;
    if (c == EOF) unexpected_EOF();

    for(;;)
    {
        if (isdigit(c))
        {
	    SRexpect = get_number();
            break;
        }
        /*
         * Looking for number before EOL.
         * Spaces, tabs, and numbers are ok,
         * words, punc., etc. are syntax errors.
         */
        else if (c == '\n' || isalpha(c) || !isspace(c))
        {
            syntax_error(lineno, line, cptr);
        }
        else
        {
            c = *++cptr;
            if (c == EOF) unexpected_EOF();
        }
    }
}


d942 17
a996 4
	case EXPECT:
	    declare_expect(k);
            break;

d1003 4
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: reader.c,v 1.3 1993/08/02 17:56:49 mycroft Exp $";
d253 2
d895 44
d1021 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
