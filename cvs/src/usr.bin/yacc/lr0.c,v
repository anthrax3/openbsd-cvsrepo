head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.12
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.10
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.6
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.12.0.6
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.03.13.01.18.22;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.13.00.59.34;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.13.23.14.17;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.08.22.36.37;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.08.22.30.32;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2014.01.08.21.40.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2012.03.03.19.15.00;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.03.20.42.54;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.01.21.21.39;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.19.16.34.53;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.28.00;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.16.06.29.44;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.45.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@collapse variable declarations
@
text
@/* $OpenBSD: lr0.c,v 1.17 2014/03/13 00:59:34 tedu Exp $	 */
/* $NetBSD: lr0.c,v 1.4 1996/03/19 03:21:35 jtc Exp $	 */

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "defs.h"

extern short *itemset;
extern short *itemsetend;
extern unsigned *ruleset;

int nstates;
core *first_state;
shifts *first_shift;
reductions *first_reduction;

short get_state(int);
core *new_state(int);

void allocate_itemsets(void);
void allocate_storage(void);
void append_states(void);
void free_storage(void);
void generate_states(void);
void initialize_states(void);
void new_itemsets(void);
void save_shifts(void);
void save_reductions(void);
void set_derives(void);
void print_derives(void);
void set_nullable(void);

static core **state_set;
static core *this_state;
static core *last_state;
static shifts *last_shift;
static reductions *last_reduction;

static int nshifts;
static short *shift_symbol;

static short *redset;
static short *shiftset;

static short **kernel_base;
static short **kernel_end;
static short *kernel_items;

void
allocate_itemsets(void)
{
	short *itemp, *item_end;
	int i, count, max, symbol;
	short *symbol_count;

	count = 0;
	symbol_count = NEW2(nsyms, short);

	item_end = ritem + nitems;
	for (itemp = ritem; itemp < item_end; itemp++) {
		symbol = *itemp;
		if (symbol >= 0) {
			count++;
			symbol_count[symbol]++;
		}
	}

	kernel_base = NEW2(nsyms, short *);
	kernel_items = NEW2(count, short);

	count = 0;
	max = 0;
	for (i = 0; i < nsyms; i++) {
		kernel_base[i] = kernel_items + count;
		count += symbol_count[i];
		if (max < symbol_count[i])
			max = symbol_count[i];
	}

	shift_symbol = symbol_count;
	kernel_end = NEW2(nsyms, short *);
}

void
allocate_storage(void)
{
	allocate_itemsets();
	shiftset = NEW2(nsyms, short);
	redset = NEW2(nrules + 1, short);
	state_set = NEW2(nitems, core *);
}

void
append_states(void)
{
	int i, j, symbol;

#ifdef	TRACE
	fprintf(stderr, "Entering append_states()\n");
#endif
	for (i = 1; i < nshifts; i++) {
		symbol = shift_symbol[i];
		j = i;
		while (j > 0 && shift_symbol[j - 1] > symbol) {
			shift_symbol[j] = shift_symbol[j - 1];
			j--;
		}
		shift_symbol[j] = symbol;
	}

	for (i = 0; i < nshifts; i++) {
		symbol = shift_symbol[i];
		shiftset[i] = get_state(symbol);
	}
}

void
free_storage(void)
{
	free(shift_symbol);
	free(redset);
	free(shiftset);
	free(kernel_base);
	free(kernel_end);
	free(kernel_items);
	free(state_set);
}


void
generate_states(void)
{
	allocate_storage();
	itemset = NEW2(nitems, short);
	ruleset = NEW2(WORDSIZE(nrules), unsigned);
	set_first_derives();
	initialize_states();

	while (this_state) {
		closure(this_state->items, this_state->nitems);
		save_reductions();
		new_itemsets();
		append_states();

		if (nshifts > 0)
			save_shifts();

		this_state = this_state->next;
	}

	finalize_closure();
	free_storage();
}



short
get_state(int symbol)
{
	int n, found, key;
	short *isp1, *isp2, *iend;
	core *sp;

#ifdef	TRACE
	fprintf(stderr, "Entering get_state(%d)\n", symbol);
#endif

	isp1 = kernel_base[symbol];
	iend = kernel_end[symbol];
	n = iend - isp1;

	key = *isp1;
	assert(0 <= key && key < nitems);
	sp = state_set[key];
	if (sp) {
		found = 0;
		while (!found) {
			if (sp->nitems == n) {
				found = 1;
				isp1 = kernel_base[symbol];
				isp2 = sp->items;

				while (found && isp1 < iend) {
					if (*isp1++ != *isp2++)
						found = 0;
				}
			}
			if (!found) {
				if (sp->link) {
					sp = sp->link;
				} else {
					sp = sp->link = new_state(symbol);
					found = 1;
				}
			}
		}
	} else {
		state_set[key] = sp = new_state(symbol);
	}

	return (sp->number);
}


void
initialize_states(void)
{
	int i;
	short *start_derives;
	core *p;

	start_derives = derives[start_symbol];
	for (i = 0; start_derives[i] >= 0; ++i)
		continue;

	p = malloc(sizeof(core) + i * sizeof(short));
	if (p == NULL)
		no_space();

	p->next = 0;
	p->link = 0;
	p->number = 0;
	p->accessing_symbol = 0;
	p->nitems = i;

	for (i = 0; start_derives[i] >= 0; ++i)
		p->items[i] = rrhs[start_derives[i]];

	first_state = last_state = this_state = p;
	nstates = 1;
}

void
new_itemsets(void)
{
	int i, shiftcount;
	short *isp, *ksp;
	int symbol;

	memset(kernel_end, 0, nsyms * sizeof(short *));

	shiftcount = 0;
	isp = itemset;
	while (isp < itemsetend) {
		i = *isp++;
		symbol = ritem[i];
		if (symbol > 0) {
			ksp = kernel_end[symbol];
			if (!ksp) {
				shift_symbol[shiftcount++] = symbol;
				ksp = kernel_base[symbol];
			}
			*ksp++ = i + 1;
			kernel_end[symbol] = ksp;
		}
	}

	nshifts = shiftcount;
}



core *
new_state(int symbol)
{
	int n;
	core *p;
	short *isp1, *isp2, *iend;

#ifdef	TRACE
	fprintf(stderr, "Entering new_state(%d)\n", symbol);
#endif

	if (nstates >= MAXSHORT)
		fatal("too many states");

	isp1 = kernel_base[symbol];
	iend = kernel_end[symbol];
	n = iend - isp1;

	p = allocate(sizeof(core) + (n - 1) * sizeof(short));
	p->accessing_symbol = symbol;
	p->number = nstates;
	p->nitems = n;

	isp2 = p->items;
	while (isp1 < iend)
		*isp2++ = *isp1++;

	last_state->next = p;
	last_state = p;

	nstates++;

	return (p);
}


void
save_shifts(void)
{
	shifts *p;
	short *sp1, *sp2, *send;

	p = allocate(sizeof(shifts) + (nshifts - 1) * sizeof(short));

	p->number = this_state->number;
	p->nshifts = nshifts;

	sp1 = shiftset;
	sp2 = p->shift;
	send = shiftset + nshifts;

	while (sp1 < send)
		*sp2++ = *sp1++;

	if (last_shift) {
		last_shift->next = p;
		last_shift = p;
	} else {
		first_shift = p;
		last_shift = p;
	}
}


void
save_reductions(void)
{
	short *isp, *rp1, *rp2;
	int item, count;
	reductions *p;
	short *rend;

	count = 0;
	for (isp = itemset; isp < itemsetend; isp++) {
		item = ritem[*isp];
		if (item < 0) {
			redset[count++] = -item;
		}
	}

	if (count) {
		p = allocate(sizeof(reductions) + (count - 1) * sizeof(short));

		p->number = this_state->number;
		p->nreds = count;

		rp1 = redset;
		rp2 = p->rules;
		rend = rp1 + count;

		while (rp1 < rend)
			*rp2++ = *rp1++;

		if (last_reduction) {
			last_reduction->next = p;
			last_reduction = p;
		} else {
			first_reduction = p;
			last_reduction = p;
		}
	}
}

void
set_derives(void)
{
	int i, k, lhs;
	short *rules;

	derives = NEW2(nsyms, short *);
	rules = NEW2(nvars + nrules, short);

	k = 0;
	for (lhs = start_symbol; lhs < nsyms; lhs++) {
		derives[lhs] = rules + k;
		for (i = 0; i < nrules; i++) {
			if (rlhs[i] == lhs) {
				rules[k] = i;
				k++;
			}
		}
		rules[k] = -1;
		k++;
	}

#ifdef	DEBUG
	print_derives();
#endif
}

void
free_derives(void)
{
	free(derives[start_symbol]);
	free(derives);
}

#ifdef	DEBUG
void
print_derives(void)
{
	int i;
	short *sp;

	printf("\nDERIVES\n\n");

	for (i = start_symbol; i < nsyms; i++) {
		printf("%s derives ", symbol_name[i]);
		for (sp = derives[i]; *sp >= 0; sp++) {
			printf("  %d", *sp);
		}
		putchar('\n');
	}

	putchar('\n');
}
#endif

void
set_nullable(void)
{
	int i, j;
	int empty;
	int done;

	nullable = calloc(1, nsyms);
	if (nullable == NULL)
		no_space();

	done = 0;
	while (!done) {
		done = 1;
		for (i = 1; i < nitems; i++) {
			empty = 1;
			while ((j = ritem[i]) >= 0) {
				if (!nullable[j])
					empty = 0;
				++i;
			}
			if (empty) {
				j = rlhs[-j];
				if (!nullable[j]) {
					nullable[j] = 1;
					done = 0;
				}
			}
		}
	}

#ifdef DEBUG
	for (i = 0; i < nsyms; i++) {
		if (nullable[i])
			printf("%s is nullable\n", symbol_name[i]);
		else
			printf("%s is not nullable\n", symbol_name[i]);
	}
#endif
}

void
free_nullable(void)
{
	free(nullable);
}

void
lr0(void)
{
	set_derives();
	set_nullable();
	generate_states();
}
@


1.17
log
@last bits of indentation and style
@
text
@d1 1
a1 1
/* $OpenBSD: lr0.c,v 1.16 2014/01/13 23:14:17 millert Exp $	 */
d82 2
a83 6
	short *itemp;
	short *item_end;
	int symbol;
	int i;
	int count;
	int max;
d126 1
a126 3
	int i;
	int j;
	int symbol;
d190 2
a191 4
	int key;
	short *isp1;
	short *isp2;
	short *iend;
a192 2
	int found;
	int n;
d266 2
a267 4
	int i;
	int shiftcount;
	short *isp;
	short *ksp;
d298 1
a298 3
	short *isp1;
	short *isp2;
	short *iend;
d333 1
a333 3
	short *sp1;
	short *sp2;
	short *send;
d360 2
a361 5
	short *isp;
	short *rp1;
	short *rp2;
	int item;
	int count;
d399 1
a399 2
	int i, k;
	int lhs;
@


1.16
log
@Callers of get_state() and sole_reduction() always store the result
as a short so make the return value match the type of the value we
are returning.  From Michael W. Bombardieri
@
text
@d1 2
a2 2
/*	$OpenBSD: lr0.c,v 1.15 2014/01/08 22:36:37 millert Exp $	*/
/*	$NetBSD: lr0.c,v 1.4 1996/03/19 03:21:35 jtc Exp $	*/
d82 31
a112 34
    short *itemp;
    short *item_end;
    int symbol;
    int i;
    int count;
    int max;
    short *symbol_count;

    count = 0;
    symbol_count = NEW2(nsyms, short);

    item_end = ritem + nitems;
    for (itemp = ritem; itemp < item_end; itemp++)
    {
	symbol = *itemp;
	if (symbol >= 0)
	{
	    count++;
	    symbol_count[symbol]++;
	}
    }

    kernel_base = NEW2(nsyms, short *);
    kernel_items = NEW2(count, short);

    count = 0;
    max = 0;
    for (i = 0; i < nsyms; i++)
    {
	kernel_base[i] = kernel_items + count;
	count += symbol_count[i];
	if (max < symbol_count[i])
	    max = symbol_count[i];
    }
d114 2
a115 2
    shift_symbol = symbol_count;
    kernel_end = NEW2(nsyms, short *);
d121 4
a124 4
    allocate_itemsets();
    shiftset = NEW2(nsyms, short);
    redset = NEW2(nrules + 1, short);
    state_set = NEW2(nitems, core *);
d130 3
a132 3
    int i;
    int j;
    int symbol;
d135 1
a135 1
    fprintf(stderr, "Entering append_states()\n");
d137 14
a150 17
    for (i = 1; i < nshifts; i++)
    {
	symbol = shift_symbol[i];
	j = i;
	while (j > 0 && shift_symbol[j - 1] > symbol)
	{
	    shift_symbol[j] = shift_symbol[j - 1];
	    j--;
	}
	shift_symbol[j] = symbol;
    }

    for (i = 0; i < nshifts; i++)
    {
	symbol = shift_symbol[i];
	shiftset[i] = get_state(symbol);
    }
d156 7
a162 7
    free(shift_symbol);
    free(redset);
    free(shiftset);
    free(kernel_base);
    free(kernel_end);
    free(kernel_items);
    free(state_set);
d169 11
a179 12
    allocate_storage();
    itemset = NEW2(nitems, short);
    ruleset = NEW2(WORDSIZE(nrules), unsigned);
    set_first_derives();
    initialize_states();

    while (this_state)
    {
	closure(this_state->items, this_state->nitems);
	save_reductions();
	new_itemsets();
	append_states();
d181 2
a182 2
	if (nshifts > 0)
	    save_shifts();
d184 2
a185 2
	this_state = this_state->next;
    }
d187 2
a188 2
    finalize_closure();
    free_storage();
d196 7
a202 7
    int key;
    short *isp1;
    short *isp2;
    short *iend;
    core *sp;
    int found;
    int n;
d205 1
a205 1
    fprintf(stderr, "Entering get_state(%d)\n", symbol);
d208 28
a235 30
    isp1 = kernel_base[symbol];
    iend = kernel_end[symbol];
    n = iend - isp1;

    key = *isp1;
    assert(0 <= key && key < nitems);
    sp = state_set[key];
    if (sp)
    {
	found = 0;
	while (!found)
	{
	    if (sp->nitems == n)
	    {
		found = 1;
		isp1 = kernel_base[symbol];
		isp2 = sp->items;

		while (found && isp1 < iend)
		{
		    if (*isp1++ != *isp2++)
			found = 0;
		}
	    }

	    if (!found)
	    {
		if (sp->link)
		{
		    sp = sp->link;
d237 2
a238 6
		else
		{
		    sp = sp->link = new_state(symbol);
		    found = 1;
		}
	    }
a239 5
    }
    else
    {
	state_set[key] = sp = new_state(symbol);
    }
d241 1
a241 1
    return (sp->number);
d248 17
a264 16
    int i;
    short *start_derives;
    core *p;

    start_derives = derives[start_symbol];
    for (i = 0; start_derives[i] >= 0; ++i)
	continue;

    p = (core *) malloc(sizeof(core) + i*sizeof(short));
    if (p == 0) no_space();

    p->next = 0;
    p->link = 0;
    p->number = 0;
    p->accessing_symbol = 0;
    p->nitems = i;
d266 2
a267 2
    for (i = 0;  start_derives[i] >= 0; ++i)
	p->items[i] = rrhs[start_derives[i]];
d269 2
a270 2
    first_state = last_state = this_state = p;
    nstates = 1;
d276 22
a297 25
    int i;
    int shiftcount;
    short *isp;
    short *ksp;
    int symbol;

    memset(kernel_end, 0, nsyms * sizeof(short *));

    shiftcount = 0;
    isp = itemset;
    while (isp < itemsetend)
    {
	i = *isp++;
	symbol = ritem[i];
	if (symbol > 0)
	{
	    ksp = kernel_end[symbol];
	    if (!ksp)
	    {
		shift_symbol[shiftcount++] = symbol;
		ksp = kernel_base[symbol];
	    }

	    *ksp++ = i + 1;
	    kernel_end[symbol] = ksp;
a298 1
    }
d300 1
a300 1
    nshifts = shiftcount;
d308 5
a312 5
    int n;
    core *p;
    short *isp1;
    short *isp2;
    short *iend;
d315 1
a315 1
    fprintf(stderr, "Entering new_state(%d)\n", symbol);
d318 2
a319 2
    if (nstates >= MAXSHORT)
	fatal("too many states");
d321 3
a323 3
    isp1 = kernel_base[symbol];
    iend = kernel_end[symbol];
    n = iend - isp1;
d325 4
a328 4
    p = allocate(sizeof(core) + (n - 1) * sizeof(short));
    p->accessing_symbol = symbol;
    p->number = nstates;
    p->nitems = n;
d330 3
a332 3
    isp2 = p->items;
    while (isp1 < iend)
	*isp2++ = *isp1++;
d334 2
a335 2
    last_state->next = p;
    last_state = p;
d337 1
a337 1
    nstates++;
d339 1
a339 1
    return (p);
d346 24
a369 27
    shifts *p;
    short *sp1;
    short *sp2;
    short *send;

    p = allocate(sizeof(shifts) + (nshifts - 1) * sizeof(short));

    p->number = this_state->number;
    p->nshifts = nshifts;

    sp1 = shiftset;
    sp2 = p->shift;
    send = shiftset + nshifts;

    while (sp1 < send)
	*sp2++ = *sp1++;

    if (last_shift)
    {
	last_shift->next = p;
	last_shift = p;
    }
    else
    {
	first_shift = p;
	last_shift = p;
    }
d376 18
a393 21
    short *isp;
    short *rp1;
    short *rp2;
    int item;
    int count;
    reductions *p;
    short *rend;

    count = 0;
    for (isp = itemset; isp < itemsetend; isp++)
    {
	item = ritem[*isp];
	if (item < 0)
	{
	    redset[count++] = -item;
	}
    }

    if (count)
    {
	p = allocate(sizeof(reductions) + (count - 1) * sizeof(short));
d395 2
a396 2
	p->number = this_state->number;
	p->nreds = count;
d398 14
a411 16
	rp1 = redset;
	rp2 = p->rules;
	rend = rp1 + count;

	while (rp1 < rend)
	    *rp2++ = *rp1++;

	if (last_reduction)
	{
	    last_reduction->next = p;
	    last_reduction = p;
	}
	else
	{
	    first_reduction = p;
	    last_reduction = p;
a412 1
    }
d418 17
a434 16
    int i, k;
    int lhs;
    short *rules;

    derives = NEW2(nsyms, short *);
    rules = NEW2(nvars + nrules, short);

    k = 0;
    for (lhs = start_symbol; lhs < nsyms; lhs++)
    {
	derives[lhs] = rules + k;
	for (i = 0; i < nrules; i++)
	{
	    if (rlhs[i] == lhs)
	    {
		rules[k] = i;
a435 1
	    }
a436 3
	rules[k] = -1;
	k++;
    }
d439 1
a439 1
    print_derives();
d446 2
a447 2
    free(derives[start_symbol]);
    free(derives);
d454 2
a455 2
    int i;
    short *sp;
d457 1
a457 1
    printf("\nDERIVES\n\n");
d459 6
a464 6
    for (i = start_symbol; i < nsyms; i++)
    {
	printf("%s derives ", symbol_name[i]);
	for (sp = derives[i]; *sp >= 0; sp++)
	{
	    printf("  %d", *sp);
d466 1
a467 3
    }

    putchar('\n');
d474 25
a498 27
    int i, j;
    int empty;
    int done;

    nullable = calloc(1, nsyms);
    if (nullable == 0) no_space();

    done = 0;
    while (!done)
    {
	done = 1;
	for (i = 1; i < nitems; i++)
	{
	    empty = 1;
	    while ((j = ritem[i]) >= 0)
	    {
		if (!nullable[j])
		    empty = 0;
		++i;
	    }
	    if (empty)
	    {
		j = rlhs[-j];
		if (!nullable[j])
		{
		    nullable[j] = 1;
		    done = 0;
a499 1
	    }
a500 1
    }
d503 6
a508 7
    for (i = 0; i < nsyms; i++)
    {
	if (nullable[i])
	    printf("%s is nullable\n", symbol_name[i]);
	else
	    printf("%s is not nullable\n", symbol_name[i]);
    }
d515 1
a515 1
    free(nullable);
d521 3
a523 3
    set_derives();
    set_nullable();
    generate_states();
@


1.15
log
@Use calloc() instead of malloc() + memset.  Based on a diff from
Michael W. Bombardieri.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.14 2014/01/08 22:30:32 millert Exp $	*/
d47 1
a47 1
int get_state(int);
d200 1
a200 1
int
@


1.14
log
@Make allocate() take size_t and return void *.  This lets us drop
some more useless casts.  Also add missing arguments to a couple
of prototypes while here.  OK matthew@@ pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.13 2014/01/08 21:40:25 millert Exp $	*/
d513 1
a513 1
    nullable = malloc(nsyms);
a514 2

    memset(nullable, 0, nsyms);
@


1.13
log
@Remove CALLOC, MALLOC, FREE and REALLOC macros and just call calloc(),
nalloc(), free() and realloc() directly.  The macros were casting
to the wrong (pre-C89) types and there is no need for them in a C89
world.  OK matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.12 2012/03/03 19:15:00 nicm Exp $	*/
d346 1
a346 1
    p = (core *) allocate((unsigned) (sizeof(core) + (n - 1) * sizeof(short)));
d372 1
a372 2
    p = (shifts *) allocate((unsigned) (sizeof(shifts) +
			(nshifts - 1) * sizeof(short)));
d420 1
a420 2
	p = (reductions *) allocate((unsigned) (sizeof(reductions) +
					(count - 1) * sizeof(short)));
@


1.12
log
@Replace some loops with calloc/memset. From Michael W Bombardieri.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.11 2011/04/03 20:42:54 nicm Exp $	*/
d162 7
a168 7
    FREE(shift_symbol);
    FREE(redset);
    FREE(shiftset);
    FREE(kernel_base);
    FREE(kernel_end);
    FREE(kernel_items);
    FREE(state_set);
d274 1
a274 1
    p = (core *) MALLOC(sizeof(core) + i*sizeof(short));
d481 2
a482 2
    FREE(derives[start_symbol]);
    FREE(derives);
d515 1
a515 1
    nullable = MALLOC(nsyms);
d559 1
a559 1
    FREE(nullable);
@


1.11
log
@Trim some very long unused debugging functions, from Michael W
Bombardieri.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.10 2011/04/01 21:21:39 nicm Exp $	*/
d299 1
a299 2
    for (i = 0; i < nsyms; i++)
	kernel_end[i] = 0;
@


1.10
log
@Add calls to some existing but previously unused free functions. Also
replace a loop with a memset. From Michael W Bombardieri.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.9 2009/10/27 23:59:50 deraadt Exp $	*/
a56 4
void show_cores(void);
void show_ritems(void);
void show_rrhs(void);
void show_shifts(void);
a363 80

/* show_cores is used for debugging */

void
show_cores(void)
{
    core *p;
    int i, j, k, n;
    int itemno;

    k = 0;
    for (p = first_state; p; ++k, p = p->next)
    {
	if (k) printf("\n");
	printf("state %d, number = %d, accessing symbol = %s\n",
		k, p->number, symbol_name[p->accessing_symbol]);
	n = p->nitems;
	for (i = 0; i < n; ++i)
	{
	    itemno = p->items[i];
	    printf("%4d  ", itemno);
	    j = itemno;
	    while (ritem[j] >= 0) ++j;
	    printf("%s :", symbol_name[rlhs[-ritem[j]]]);
	    j = rrhs[-ritem[j]];
	    while (j < itemno)
		printf(" %s", symbol_name[ritem[j++]]);
	    printf(" .");
	    while (ritem[j] >= 0)
		printf(" %s", symbol_name[ritem[j++]]);
	    printf("\n");
	    fflush(stdout);
	}
    }
}


/* show_ritems is used for debugging */

void
show_ritems(void)
{
    int i;

    for (i = 0; i < nitems; ++i)
	printf("ritem[%d] = %d\n", i, ritem[i]);
}


/* show_rrhs is used for debugging */

void
show_rrhs(void)
{
    int i;

    for (i = 0; i < nrules; ++i)
	printf("rrhs[%d] = %d\n", i, rrhs[i]);
}


/* show_shifts is used for debugging */

void
show_shifts(void)
{
    shifts *p;
    int i, j, k;

    k = 0;
    for (p = first_shift; p; ++k, p = p->next)
    {
	if (k) printf("\n");
	printf("shift %d, number = %d, nshifts = %d\n", k, p->number,
		p->nshifts);
	j = p->nshifts;
	for (i = 0; i < j; ++i)
	    printf("\t%d\n", p->shift[i]);
    }
}
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.8 2003/06/19 16:34:53 pvalchev Exp $	*/
a65 2
void free_derives(void);
void free_nullable(void);
d603 1
a603 2
    for (i = 0; i < nsyms; ++i)
	nullable[i] = 0;
@


1.8
log
@ansify; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.7 2003/06/03 02:56:24 millert Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)lr0.c	5.3 (Berkeley) 1/20/91";
#else
static char rcsid[] = "$OpenBSD: lr0.c,v 1.7 2003/06/03 02:56:24 millert Exp $";
#endif
#endif /* not lint */
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.6 2002/02/16 21:28:00 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: lr0.c,v 1.6 2002/02/16 21:28:00 millert Exp $";
d94 1
a94 1
allocate_itemsets()
d136 1
a136 1
allocate_storage()
d145 1
a145 1
append_states()
d174 1
a174 1
free_storage()
d187 1
a187 1
generate_states()
d215 1
a215 2
get_state(symbol)
int symbol;
d278 1
a278 1
initialize_states()
d305 1
a305 1
new_itemsets()
d342 1
a342 2
new_state(symbol)
int symbol;
d382 1
a382 1
show_cores()
d418 1
a418 1
show_ritems()
d430 1
a430 1
show_rrhs()
d442 1
a442 1
show_shifts()
d460 1
a460 1
save_shifts()
d494 1
a494 1
save_reductions()
d543 1
a543 1
set_derives()
d574 1
a574 1
free_derives()
d582 1
a582 1
print_derives()
d604 1
a604 1
set_nullable()
d653 1
a653 1
free_nullable()
d659 1
a659 1
lr0()
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.5 2001/11/19 19:02:18 mpech Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: lr0.c,v 1.5 2001/11/19 19:02:18 mpech Exp $";
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.4 2001/07/16 06:29:44 pvalchev Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: lr0.c,v 1.4 2001/07/16 06:29:44 pvalchev Exp $";
d59 2
a60 2
int get_state __P((int));
core *new_state __P((int));
d62 18
a79 18
void allocate_itemsets __P((void));
void allocate_storage __P((void));
void append_states __P((void));
void free_storage __P((void));
void generate_states __P((void));
void initialize_states __P((void));
void new_itemsets __P((void));
void show_cores __P((void));
void show_ritems __P((void));
void show_rrhs __P((void));
void show_shifts __P((void));
void save_shifts __P((void));
void save_reductions __P((void));
void set_derives __P((void));
void print_derives __P((void));
void set_nullable __P((void));
void free_derives __P((void));
void free_nullable __P((void));
@


1.4
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.3 1996/06/26 05:44:37 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: lr0.c,v 1.3 1996/06/26 05:44:37 deraadt Exp $";
d100 7
a106 7
    register short *itemp;
    register short *item_end;
    register int symbol;
    register int i;
    register int count;
    register int max;
    register short *symbol_count;
d151 3
a153 3
    register int i;
    register int j;
    register int symbol;
d222 7
a228 7
    register int key;
    register short *isp1;
    register short *isp2;
    register short *iend;
    register core *sp;
    register int found;
    register int n;
d285 3
a287 3
    register int i;
    register short *start_derives;
    register core *p;
d312 5
a316 5
    register int i;
    register int shiftcount;
    register short *isp;
    register short *ksp;
    register int symbol;
d350 5
a354 5
    register int n;
    register core *p;
    register short *isp1;
    register short *isp2;
    register short *iend;
d468 4
a471 4
    register shifts *p;
    register short *sp1;
    register short *sp2;
    register short *send;
d502 7
a508 7
    register short *isp;
    register short *rp1;
    register short *rp2;
    register int item;
    register int count;
    register reductions *p;
    register short *rend;
d551 3
a553 3
    register int i, k;
    register int lhs;
    register short *rules;
d590 2
a591 2
    register int i;
    register short *sp;
d612 2
a613 2
    register int i, j;
    register int empty;
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: lr0.c,v 1.4 1996/03/19 03:21:35 jtc Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: lr0.c,v 1.4 1996/03/19 03:21:35 jtc Exp $";
d59 21
a79 2
int get_state();
core *new_state();
d97 1
a97 1

d139 1
a139 1

d148 1
a148 1

d177 1
a177 1

d190 1
a190 1

d282 1
a282 1

d309 1
a309 1

d387 1
d423 1
d434 2
d447 1
d465 1
a465 1

d499 1
a499 1

d548 1
a548 1

d579 1
d587 1
d609 1
a609 1

d658 1
a658 1

d664 1
a664 1

@


1.2
log
@sync to netbsd 960418
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: lr0.c,v 1.4 1996/03/19 03:21:35 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 38
d40 5
a44 1
static char rcsid[] = "$Id: lr0.c,v 1.3 1993/08/02 17:56:39 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
