head	1.18;
access;
symbols
	OPENBSD_6_0:1.18.0.10
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.6
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.20
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.16
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.14
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.12
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.03.13.00.59.34;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.13.23.14.18;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.08.21.40.25;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2012.03.03.19.15.00;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.10.16.40.45;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.08.20.13.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.19.16.34.53;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.19.03.24.56;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.28.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.16.06.29.44;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	99.08.04.18.31.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.23.45.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.31.04.56.02;	author etheisen;	state Exp;
branches;
next	1.2;

1.2
date	96.02.04.08.37.01;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@last bits of indentation and style
@
text
@/* $OpenBSD: mkpar.c,v 1.17 2014/01/13 23:14:18 millert Exp $	 */
/* $NetBSD: mkpar.c,v 1.4 1996/03/19 03:21:39 jtc Exp $	 */

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "defs.h"

action **parser;
int SRtotal;
int SRexpect = 0;
int RRtotal;
short *SRconflicts;
short *RRconflicts;
short *defred;
short *rules_used;
short nunused;
short final_state;

static int SRcount;
static int RRcount;

extern action *parse_actions();
extern action *get_shifts();
extern action *add_reductions();
extern action *add_reduce();

short sole_reduction(int);
void free_action_row(action *);

void find_final_state(void);
void unused_rules(void);
void remove_conflicts(void);
void total_conflicts(void);
void defreds(void);


void
make_parser(void)
{
	int i;

	parser = NEW2(nstates, action *);
	for (i = 0; i < nstates; i++)
		parser[i] = parse_actions(i);

	find_final_state();
	remove_conflicts();
	unused_rules();
	if (SRtotal + RRtotal > 0)
		total_conflicts();
	defreds();
}


action *
parse_actions(int stateno)
{
	action *actions;

	actions = get_shifts(stateno);
	actions = add_reductions(stateno, actions);
	return (actions);
}


action *
get_shifts(int stateno)
{
	action *actions, *temp;
	shifts *sp;
	short *to_state;
	int i, k;
	int symbol;

	actions = 0;
	sp = shift_table[stateno];
	if (sp) {
		to_state = sp->shift;
		for (i = sp->nshifts - 1; i >= 0; i--) {
			k = to_state[i];
			symbol = accessing_symbol[k];
			if (ISTOKEN(symbol)) {
				temp = NEW(action);
				temp->next = actions;
				temp->symbol = symbol;
				temp->number = k;
				temp->prec = symbol_prec[symbol];
				temp->action_code = SHIFT;
				temp->assoc = symbol_assoc[symbol];
				actions = temp;
			}
		}
	}
	return (actions);
}

action *
add_reductions(int stateno, action * actions)
{
	int i, j, m, n;
	int ruleno, tokensetsize;
	unsigned *rowp;

	tokensetsize = WORDSIZE(ntokens);
	m = lookaheads[stateno];
	n = lookaheads[stateno + 1];
	for (i = m; i < n; i++) {
		ruleno = LAruleno[i];
		rowp = LA + i * tokensetsize;
		for (j = ntokens - 1; j >= 0; j--) {
			if (BIT(rowp, j))
				actions = add_reduce(actions, ruleno, j);
		}
	}
	return (actions);
}


action *
add_reduce(action * actions, int ruleno, int symbol)
{
	action *temp, *prev, *next;

	prev = 0;
	for (next = actions; next && next->symbol < symbol; next = next->next)
		prev = next;

	while (next && next->symbol == symbol && next->action_code == SHIFT) {
		prev = next;
		next = next->next;
	}

	while (next && next->symbol == symbol &&
	    next->action_code == REDUCE && next->number < ruleno) {
		prev = next;
		next = next->next;
	}

	temp = NEW(action);
	temp->next = next;
	temp->symbol = symbol;
	temp->number = ruleno;
	temp->prec = rprec[ruleno];
	temp->action_code = REDUCE;
	temp->assoc = rassoc[ruleno];

	if (prev)
		prev->next = temp;
	else
		actions = temp;

	return (actions);
}


void
find_final_state(void)
{
	int goal, i;
	short *to_state;
	shifts *p;

	p = shift_table[0];
	to_state = p->shift;
	goal = ritem[1];
	for (i = p->nshifts - 1; i >= 0; --i) {
		final_state = to_state[i];
		if (accessing_symbol[final_state] == goal)
			break;
	}
}


void
unused_rules(void)
{
	int i;
	action *p;

	rules_used = calloc(nrules, sizeof(short));
	if (rules_used == NULL)
		no_space();

	for (i = 0; i < nstates; ++i) {
		for (p = parser[i]; p; p = p->next) {
			if (p->action_code == REDUCE && p->suppressed == 0)
				rules_used[p->number] = 1;
		}
	}

	nunused = 0;
	for (i = 3; i < nrules; ++i)
		if (!rules_used[i])
			++nunused;

	if (nunused) {
		if (nunused == 1)
			fprintf(stderr, "%s: 1 rule never reduced\n", __progname);
		else
			fprintf(stderr, "%s: %d rules never reduced\n", __progname,
				nunused);
	}
}


void
remove_conflicts(void)
{
	int i;
	int symbol;
	action *p, *pref = NULL;

	SRtotal = 0;
	RRtotal = 0;
	SRconflicts = NEW2(nstates, short);
	RRconflicts = NEW2(nstates, short);
	for (i = 0; i < nstates; i++) {
		SRcount = 0;
		RRcount = 0;
		symbol = -1;
		for (p = parser[i]; p; p = p->next) {
			if (p->symbol != symbol) {
				pref = p;
				symbol = p->symbol;
			} else if (i == final_state && symbol == 0) {
				SRcount++;
				p->suppressed = 1;
			} else if (pref->action_code == SHIFT) {
				if (pref->prec > 0 && p->prec > 0) {
					if (pref->prec < p->prec) {
						pref->suppressed = 2;
						pref = p;
					} else if (pref->prec > p->prec) {
						p->suppressed = 2;
					} else if (pref->assoc == LEFT) {
						pref->suppressed = 2;
						pref = p;
					} else if (pref->assoc == RIGHT) {
						p->suppressed = 2;
					} else {
						pref->suppressed = 2;
						p->suppressed = 2;
					}
				} else {
					SRcount++;
					p->suppressed = 1;
				}
			} else {
				RRcount++;
				p->suppressed = 1;
			}
		}
		SRtotal += SRcount;
		RRtotal += RRcount;
		SRconflicts[i] = SRcount;
		RRconflicts[i] = RRcount;
	}
}


void
total_conflicts(void)
{
	/* Warn if s/r != expect or if any r/r */
	if ((SRtotal != SRexpect) || RRtotal) {
		if (SRtotal == 1)
			fprintf(stderr, "%s: %s finds 1 shift/reduce conflict\n",
				input_file_name, __progname);
		else if (SRtotal > 1)
			fprintf(stderr, "%s: %s finds %d shift/reduce conflicts\n",
				input_file_name, __progname, SRtotal);
	}
	if (RRtotal == 1)
		fprintf(stderr, "%s: %s finds 1 reduce/reduce conflict\n",
			input_file_name, __progname);
	else if (RRtotal > 1)
		fprintf(stderr, "%s: %s finds %d reduce/reduce conflicts\n",
			input_file_name, __progname, RRtotal);
}


short
sole_reduction(int stateno)
{
	int count;
	short ruleno;
	action *p;

	count = 0;
	ruleno = 0;
	for (p = parser[stateno]; p; p = p->next) {
		if (p->action_code == SHIFT && p->suppressed == 0)
			return (0);
		else if (p->action_code == REDUCE && p->suppressed == 0) {
			if (ruleno > 0 && p->number != ruleno)
				return (0);
			if (p->symbol != 1)
				++count;
			ruleno = p->number;
		}
	}

	if (count == 0)
		return (0);
	return (ruleno);
}


void
defreds(void)
{
	int i;

	defred = NEW2(nstates, short);
	for (i = 0; i < nstates; i++)
		defred[i] = sole_reduction(i);
}

void
free_action_row(action * p)
{
	action *q;

	while (p) {
		q = p->next;
		free(p);
		p = q;
	}
}

void
free_parser(void)
{
	int i;

	for (i = 0; i < nstates; i++)
		free_action_row(parser[i]);

	free(parser);
}
@


1.17
log
@Callers of get_state() and sole_reduction() always store the result
as a short so make the return value match the type of the value we
are returning.  From Michael W. Bombardieri
@
text
@d1 2
a2 2
/*	$OpenBSD: mkpar.c,v 1.16 2014/01/08 21:40:25 millert Exp $	*/
/*	$NetBSD: mkpar.c,v 1.4 1996/03/19 03:21:39 jtc Exp $	*/
d70 1
a70 1
    int i;
d72 10
a81 9
    parser = NEW2(nstates, action *);
    for (i = 0; i < nstates; i++)
	parser[i] = parse_actions(i);

    find_final_state();
    remove_conflicts();
    unused_rules();
    if (SRtotal + RRtotal > 0) total_conflicts();
    defreds();
d88 1
a88 1
    action *actions;
d90 3
a92 3
    actions = get_shifts(stateno);
    actions = add_reductions(stateno, actions);
    return (actions);
d99 24
a122 26
    action *actions, *temp;
    shifts *sp;
    short *to_state;
    int i, k;
    int symbol;

    actions = 0;
    sp = shift_table[stateno];
    if (sp)
    {
	to_state = sp->shift;
	for (i = sp->nshifts - 1; i >= 0; i--)
	{
	    k = to_state[i];
	    symbol = accessing_symbol[k];
	    if (ISTOKEN(symbol))
	    {
		temp = NEW(action);
		temp->next = actions;
		temp->symbol = symbol;
		temp->number = k;
		temp->prec = symbol_prec[symbol];
		temp->action_code = SHIFT;
		temp->assoc = symbol_assoc[symbol];
		actions = temp;
	    }
d124 1
a124 2
    }
    return (actions);
d128 1
a128 1
add_reductions(int stateno, action *actions)
d130 14
a143 15
    int i, j, m, n;
    int ruleno, tokensetsize;
    unsigned *rowp;

    tokensetsize = WORDSIZE(ntokens);
    m = lookaheads[stateno];
    n = lookaheads[stateno + 1];
    for (i = m; i < n; i++)
    {
	ruleno = LAruleno[i];
	rowp = LA + i * tokensetsize;
	for (j = ntokens - 1; j >= 0; j--)
	{
	    if (BIT(rowp, j))
		actions = add_reduce(actions, ruleno, j);
d145 1
a145 2
    }
    return (actions);
d150 1
a150 1
add_reduce(action *actions, int ruleno, int symbol)
d152 5
a156 1
    action *temp, *prev, *next;
d158 10
a167 29
    prev = 0;
    for (next = actions; next && next->symbol < symbol; next = next->next)
	prev = next;

    while (next && next->symbol == symbol && next->action_code == SHIFT)
    {
	prev = next;
	next = next->next;
    }

    while (next && next->symbol == symbol &&
	    next->action_code == REDUCE && next->number < ruleno)
    {
	prev = next;
	next = next->next;
    }

    temp = NEW(action);
    temp->next = next;
    temp->symbol = symbol;
    temp->number = ruleno;
    temp->prec = rprec[ruleno];
    temp->action_code = REDUCE;
    temp->assoc = rassoc[ruleno];

    if (prev)
	prev->next = temp;
    else
	actions = temp;
d169 14
a182 1
    return (actions);
d189 12
a200 12
    int goal, i;
    short *to_state;
    shifts *p;

    p = shift_table[0];
    to_state = p->shift;
    goal = ritem[1];
    for (i = p->nshifts - 1; i >= 0; --i)
    {
	final_state = to_state[i];
	if (accessing_symbol[final_state] == goal) break;
    }
d207 2
a208 2
    int i;
    action *p;
d210 10
a219 2
    rules_used = calloc(nrules, sizeof(short));
    if (rules_used == NULL) no_space();
d221 12
a232 20
    for (i = 0; i < nstates; ++i)
    {
	for (p = parser[i]; p; p = p->next)
	{
	    if (p->action_code == REDUCE && p->suppressed == 0)
		rules_used[p->number] = 1;
	}
    }

    nunused = 0;
    for (i = 3; i < nrules; ++i)
	if (!rules_used[i]) ++nunused;

    if (nunused) {
	if (nunused == 1)
	    fprintf(stderr, "%s: 1 rule never reduced\n", __progname);
	else
	    fprintf(stderr, "%s: %d rules never reduced\n", __progname,
		    nunused);
    }
d239 43
a281 52
    int i;
    int symbol;
    action *p, *pref = NULL;

    SRtotal = 0;
    RRtotal = 0;
    SRconflicts = NEW2(nstates, short);
    RRconflicts = NEW2(nstates, short);
    for (i = 0; i < nstates; i++)
    {
	SRcount = 0;
	RRcount = 0;
	symbol = -1;
	for (p = parser[i]; p; p = p->next)
	{
	    if (p->symbol != symbol)
	    {
		pref = p;
		symbol = p->symbol;
	    }
	    else if (i == final_state && symbol == 0)
	    {
		SRcount++;
		p->suppressed = 1;
	    }
	    else if (pref->action_code == SHIFT)
	    {
		if (pref->prec > 0 && p->prec > 0)
		{
		    if (pref->prec < p->prec)
		    {
			pref->suppressed = 2;
			pref = p;
		    }
		    else if (pref->prec > p->prec)
		    {
			p->suppressed = 2;
		    }
		    else if (pref->assoc == LEFT)
		    {
			pref->suppressed = 2;
			pref = p;
		    }
		    else if (pref->assoc == RIGHT)
		    {
			p->suppressed = 2;
		    }
		    else
		    {
			pref->suppressed = 2;
			p->suppressed = 2;
		    }
d283 5
a287 17
		else
		{
		    SRcount++;
		    p->suppressed = 1;
		}
	    }
	    else
	    {
		RRcount++;
		p->suppressed = 1;
	    }
	}
	SRtotal += SRcount;
	RRtotal += RRcount;
	SRconflicts[i] = SRcount;
	RRconflicts[i] = RRcount;
    }
d294 15
a308 17
    /* Warn if s/r != expect or if any r/r */
    if ((SRtotal != SRexpect) || RRtotal)
    {
        if (SRtotal == 1)
            fprintf(stderr, "%s: %s finds 1 shift/reduce conflict\n",
		    input_file_name, __progname);
        else if (SRtotal > 1)
            fprintf(stderr, "%s: %s finds %d shift/reduce conflicts\n",
		    input_file_name, __progname, SRtotal);
    }

    if (RRtotal == 1)
        fprintf(stderr, "%s: %s finds 1 reduce/reduce conflict\n",
		input_file_name, __progname);
    else if (RRtotal > 1)
	fprintf(stderr, "%s: %s finds %d reduce/reduce conflicts\n",
		input_file_name, __progname, RRtotal);
d315 19
a333 13
    int count;
    short ruleno;
    action *p;

    count = 0;
    ruleno = 0;
    for (p = parser[stateno]; p; p = p->next)
    {
	if (p->action_code == SHIFT && p->suppressed == 0)
	    return (0);
	else if (p->action_code == REDUCE && p->suppressed == 0)
	{
	    if (ruleno > 0 && p->number != ruleno)
d335 1
a335 9
	    if (p->symbol != 1)
		++count;
	    ruleno = p->number;
	}
    }

    if (count == 0)
	return (0);
    return (ruleno);
d342 1
a342 1
    int i;
d344 3
a346 3
    defred = NEW2(nstates, short);
    for (i = 0; i < nstates; i++)
	defred[i] = sole_reduction(i);
d350 1
a350 1
free_action_row(action *p)
d352 1
a352 1
  action *q;
d354 5
a358 6
  while (p)
    {
      q = p->next;
      free(p);
      p = q;
    }
d364 1
a364 1
  int i;
d366 2
a367 2
  for (i = 0; i < nstates; i++)
    free_action_row(parser[i]);
d369 1
a369 1
  free(parser);
@


1.16
log
@Remove CALLOC, MALLOC, FREE and REALLOC macros and just call calloc(),
nalloc(), free() and realloc() directly.  The macros were casting
to the wrong (pre-C89) types and there is no need for them in a C89
world.  OK matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.15 2012/03/03 19:15:00 nicm Exp $	*/
d57 1
a57 1
int sole_reduction(int);
d341 1
a341 1
int
d344 2
a345 1
    int count, ruleno;
@


1.15
log
@Replace some loops with calloc/memset. From Michael W Bombardieri.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.14 2009/10/27 23:59:50 deraadt Exp $	*/
d216 1
a216 1
    rules_used = CALLOC(nrules, sizeof(short));
d387 1
a387 1
      FREE(p);
d400 1
a400 1
  FREE(parser);
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.13 2005/06/10 16:40:45 pvalchev Exp $	*/
d216 2
a217 5
    rules_used = (short *) MALLOC(nrules*sizeof(short));
    if (rules_used == 0) no_space();

    for (i = 0; i < nrules; ++i)
	rules_used[i] = 0;
@


1.13
log
@-Wall clean; ok otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.12 2004/08/08 20:13:13 deraadt Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)mkpar.c	5.3 (Berkeley) 1/20/91";
#else
static char rcsid[] = "$NetBSD: mkpar.c,v 1.4 1996/03/19 03:21:39 jtc Exp $";
#endif
#endif /* not lint */
@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.11 2003/06/19 16:34:53 pvalchev Exp $	*/
d258 1
a258 1
    action *p, *pref;
@


1.11
log
@ansify; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.10 2003/06/03 02:56:24 millert Exp $	*/
d359 1
a359 1
    ruleno = 0; 
d389 1
a389 1
 
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 2
/*	$OpenBSD: mkpar.c,v 1.9 2002/06/19 03:24:56 deraadt Exp $	*/

d76 1
a76 1
make_parser()
d93 1
a93 2
parse_actions(stateno)
int stateno;
d104 1
a104 2
get_shifts(stateno)
int stateno;
d138 1
a138 3
add_reductions(stateno, actions)
int stateno;
action *actions;
d162 1
a162 3
add_reduce(actions, ruleno, symbol)
action *actions;
int ruleno, symbol;
d201 1
a201 1
find_final_state()
d219 1
a219 1
unused_rules()
d254 1
a254 1
remove_conflicts()
d330 1
a330 1
total_conflicts()
d353 1
a353 2
sole_reduction(stateno)
int stateno;
d381 1
a381 1
defreds()
d391 1
a391 2
free_action_row(p)
action *p;
d404 1
a404 1
free_parser()
@


1.9
log
@have yacc spit out c compiler-like error messages, so that utilities which
expect those can cope.  I've wanted this for >12 years.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.8 2002/02/16 21:28:00 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.7 2001/11/19 19:02:18 mpech Exp $	*/
d347 2
a348 1
            fprintf(stderr, "%s: 1 shift/reduce conflict\n", __progname);
d350 2
a351 2
            fprintf(stderr, "%s: %d shift/reduce conflicts\n", __progname,
                    SRtotal);
d355 2
a356 1
        fprintf(stderr, "%s: 1 reduce/reduce conflict\n", __progname);
d358 2
a359 2
	fprintf(stderr, "%s: %d reduce/reduce conflicts\n", __progname,
                RRtotal);
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.6 2001/07/16 06:29:44 pvalchev Exp $	*/
d70 2
a71 2
int sole_reduction __P((int));
void free_action_row __P((action *));
d73 5
a77 5
void find_final_state __P((void));
void unused_rules __P((void));
void remove_conflicts __P((void));
void total_conflicts __P((void));
void defreds __P((void));
@


1.6
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.5 1999/08/04 18:31:26 millert Exp $	*/
d83 1
a83 1
    register int i;
d99 1
a99 1
register int stateno;
d101 1
a101 1
    register action *actions;
d113 5
a117 5
    register action *actions, *temp;
    register shifts *sp;
    register short *to_state;
    register int i, k;
    register int symbol;
d147 1
a147 1
register action *actions;
d149 3
a151 3
    register int i, j, m, n;
    register int ruleno, tokensetsize;
    register unsigned *rowp;
d172 2
a173 2
register action *actions;
register int ruleno, symbol;
d175 1
a175 1
    register action *temp, *prev, *next;
d214 3
a216 3
    register int goal, i;
    register short *to_state;
    register shifts *p;
d232 2
a233 2
    register int i;
    register action *p;
d267 3
a269 3
    register int i;
    register int symbol;
    register action *p, *pref;
d365 2
a366 2
    register int count, ruleno;
    register action *p;
d393 1
a393 1
    register int i;
d402 1
a402 1
register action *p;
d404 1
a404 1
  register action *q;
d417 1
a417 1
  register int i;
@


1.5
log
@o Use __progname
o Use _PATH_TMP
o Use mkstemp() instead of mktemp()
o Really use 10 X's (one is eaten up by a letter)
o Correct manpage wrt temp file name
o Uncomment .Xr yyfix in man page since we ship it now
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.4 1996/04/21 23:45:15 deraadt Exp $	*/
d70 2
d73 8
d211 1
d229 1
d254 1
a254 1
    if (nunused)
d260 1
d264 1
d340 1
d390 1
d400 1
d414 1
@


1.4
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD: mkpar.c,v 1.3 1996/03/31 04:56:02 etheisen Exp $	*/
d244 1
a244 1
	    fprintf(stderr, "%s: 1 rule never reduced\n", myname);
d246 2
a247 1
	    fprintf(stderr, "%s: %d rules never reduced\n", myname, nunused);
d332 1
a332 1
            fprintf(stderr, "%s: 1 shift/reduce conflict\n", myname);
d334 1
a334 1
            fprintf(stderr, "%s: %d shift/reduce conflicts\n", myname,
d339 1
a339 1
        fprintf(stderr, "%s: 1 reduce/reduce conflict\n", myname);
d341 1
a341 1
	fprintf(stderr, "%s: %d reduce/reduce conflicts\n", myname,
@


1.3
log
@Fix 960317 NetBSD merge error.  Merge caused local OpenBSD mod lossage.

NetBSD's byacc %expect mods are buggy and don't handle syntax or semantic
errors.  Additionally, they do not mimic the BISON behavior they try to
emulate.  Our local OpenBSD %expect mods are much better.
@
text
@d1 39
a39 1
/*	$OpenBSD$	*/
d42 5
a46 1
static char rcsid[] = "$Id$";
a404 1

@


1.2
log
@Yacc now understands %expect keyword.  This should help prevent yacc from
gagging on GNU bison grammer.
@
text
@d1 2
d4 1
a4 1
static char rcsid[] = "$Id: mkpar.c,v 1.1.1.1 1995/10/18 08:47:05 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: mkpar.c,v 1.3 1993/08/02 17:56:42 mycroft Exp $";
d9 1
d283 9
a291 8
    fprintf(stderr, "%s: ", myname);
    if (SRtotal == 1)
	fprintf(stderr, "1 shift/reduce conflict");
    else if (SRtotal > 1)
	fprintf(stderr, "%d shift/reduce conflicts", SRtotal);

    if (SRtotal && RRtotal)
	fprintf(stderr, ", ");
d294 1
a294 1
	fprintf(stderr, "1 reduce/reduce conflict");
d296 2
a297 3
	fprintf(stderr, "%d reduce/reduce conflicts", RRtotal);

    fprintf(stderr, ".\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
