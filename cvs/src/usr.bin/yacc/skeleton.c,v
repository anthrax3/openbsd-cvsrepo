head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.6
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.35.0.8
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.16
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.14
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.12
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.10
	OPENBSD_5_0:1.30.0.8
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.8
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.4
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.12.31.23.22.39;	author guenther;	state Exp;
branches;
next	1.38;
commitid	zJCifPWHkbAZO0pN;

1.38
date	2015.12.30.17.16.47;	author mmcc;	state Exp;
branches;
next	1.37;
commitid	mFm17ZLaLJWWABwm;

1.37
date	2015.12.30.14.45.38;	author tedu;	state Exp;
branches;
next	1.36;
commitid	7gc3hkD1BqLG7xXe;

1.36
date	2015.12.28.19.14.04;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	izbA3pS6G2y8tkwH;

1.35
date	2014.03.16.18.38.30;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.07.19.44.07;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.07.19.34.49;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.02.21.02.18.00;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.30.20.33.00;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.08.15.06.50;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.03.21.14.58;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.02.15.19.36;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.20.16.51.32;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.20.03.07.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.10.16.40.45;	author pvalchev;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.12.13.39.50;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.25.20.00.15;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.19.16.34.53;	author pvalchev;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.03.21.34.21;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.16.06.29.45;	author pvalchev;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.26.00.03.33;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.27.21.34.23;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.26.22.37.24;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.11.18.15.45.12;	author dm;	state Exp;
branches;
next	1.12;

1.12
date	98.11.18.03.22.55;	author dm;	state Exp;
branches;
next	1.11;

1.11
date	98.11.17.06.13.43;	author dm;	state Exp;
branches;
next	1.10;

1.10
date	98.09.08.04.21.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.04.25.18.52.18;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.01.03.00.53.25;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.12.27.08.05.18;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.07.28.02.03.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.20.07.31.54;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.23.45.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.27.19.33.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.22.01.41.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.06;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Declare yyparse() so the generated code is safe with
-Werror-implicit-function-declaration

ok millert@@
@
text
@/*	$OpenBSD: skeleton.c,v 1.38 2015/12/30 17:16:47 mmcc Exp $	*/
/*	$NetBSD: skeleton.c,v 1.10 1996/03/25 00:36:18 mrg Exp $	*/

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "defs.h"

/*  The definition of yysccsid in the banner should be replaced with	*/
/*  a #pragma ident directive if the target C compiler supports		*/
/*  #pragma ident directives.						*/
/*									*/
/*  If the skeleton is changed, the banner should be changed so that	*/
/*  the altered version can be easily distinguished from the original.	*/
/*									*/
/*  The #defines included with the banner are there because they are	*/
/*  useful in subsequent code.  The macros #defined in the header or	*/
/*  the body either are not useful outside of semantic actions or	*/
/*  are conditional.							*/

char *banner[] =
{
	"#include <stdlib.h>",
	"#include <string.h>",
	"#define YYBYACC 1",
	"#define YYMAJOR 1",
	"#define YYMINOR 9",
	"#define YYLEX yylex()",
	"#define YYEMPTY -1",
	"#define yyclearin (yychar=(YYEMPTY))",
	"#define yyerrok (yyerrflag=0)",
	"#define YYRECOVERING() (yyerrflag!=0)",
	NULL
};


char *tables[] =
{
	"extern const short yylhs[];",
	"extern const short yylen[];",
	"extern const short yydefred[];",
	"extern const short yydgoto[];",
	"extern const short yysindex[];",
	"extern const short yyrindex[];",
	"extern const short yygindex[];",
	"extern const short yytable[];",
	"extern const short yycheck[];",
	"#if YYDEBUG",
	"extern const char *const yyname[];",
	"extern const char *const yyrule[];",
	"#endif",
	NULL
};


char *header[] =
{
	"#ifdef YYSTACKSIZE",
	"#undef YYMAXDEPTH",
	"#define YYMAXDEPTH YYSTACKSIZE",
	"#else",
	"#ifdef YYMAXDEPTH",
	"#define YYSTACKSIZE YYMAXDEPTH",
	"#else",
	"#define YYSTACKSIZE 10000",
	"#define YYMAXDEPTH 10000",
	"#endif",
	"#endif",
	"#define YYINITSTACKSIZE 200",
	"/* LINTUSED */",
	"int yydebug;",
	"int yynerrs;",
	"int yyerrflag;",
	"int yychar;",
	"short *yyssp;",
	"YYSTYPE *yyvsp;",
	"YYSTYPE yyval;",
	"YYSTYPE yylval;",
	"short *yyss;",
	"short *yysslim;",
	"YYSTYPE *yyvs;",
	"unsigned int yystacksize;",
	"int yyparse(void);",
	NULL
};


char *body[] =
{
	"/* allocate initial stack or double stack size, up to YYMAXDEPTH */",
	"static int yygrowstack(void)",
	"{",
	"    unsigned int newsize;",
	"    long sslen;",
	"    short *newss;",
	"    YYSTYPE *newvs;",
	"",
	"    if ((newsize = yystacksize) == 0)",
	"        newsize = YYINITSTACKSIZE;",
	"    else if (newsize >= YYMAXDEPTH)",
	"        return -1;",
	"    else if ((newsize *= 2) > YYMAXDEPTH)",
	"        newsize = YYMAXDEPTH;",
	"    sslen = yyssp - yyss;",
	"#ifdef SIZE_MAX",
	"#define YY_SIZE_MAX SIZE_MAX",
	"#else",
	"#define YY_SIZE_MAX 0xffffffffU",
	"#endif",
	"    if (newsize && YY_SIZE_MAX / newsize < sizeof *newss)",
	"        goto bail;",
	"    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :",
	"      (short *)malloc(newsize * sizeof *newss); /* overflow check above */",
	"    if (newss == NULL)",
	"        goto bail;",
	"    yyss = newss;",
	"    yyssp = newss + sslen;",
	"    if (newsize && YY_SIZE_MAX / newsize < sizeof *newvs)",
	"        goto bail;",
	"    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :",
	"      (YYSTYPE *)malloc(newsize * sizeof *newvs); /* overflow check above */",
	"    if (newvs == NULL)",
	"        goto bail;",
	"    yyvs = newvs;",
	"    yyvsp = newvs + sslen;",
	"    yystacksize = newsize;",
	"    yysslim = yyss + newsize - 1;",
	"    return 0;",
	"bail:",
	"    if (yyss)",
	"            free(yyss);",
	"    if (yyvs)",
	"            free(yyvs);",
	"    yyss = yyssp = NULL;",
	"    yyvs = yyvsp = NULL;",
	"    yystacksize = 0;",
	"    return -1;",
	"}",
	"",
	"#define YYABORT goto yyabort",
	"#define YYREJECT goto yyabort",
	"#define YYACCEPT goto yyaccept",
	"#define YYERROR goto yyerrlab",
	"int",
	"yyparse(void)",
	"{",
	"    int yym, yyn, yystate;",
	"#if YYDEBUG",
	"    const char *yys;",
	"",
	"    if ((yys = getenv(\"YYDEBUG\")))",
	"    {",
	"        yyn = *yys;",
	"        if (yyn >= '0' && yyn <= '9')",
	"            yydebug = yyn - '0';",
	"    }",
	"#endif /* YYDEBUG */",
	"",
	"    yynerrs = 0;",
	"    yyerrflag = 0;",
	"    yychar = (-1);",
	"",
	"    if (yyss == NULL && yygrowstack()) goto yyoverflow;",
	"    yyssp = yyss;",
	"    yyvsp = yyvs;",
	"    *yyssp = yystate = 0;",
	"",
	"yyloop:",
	"    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;",
	"    if (yychar < 0)",
	"    {",
	"        if ((yychar = yylex()) < 0) yychar = 0;",
	"#if YYDEBUG",
	"        if (yydebug)",
	"        {",
	"            yys = 0;",
	"            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
	"            if (!yys) yys = \"illegal-symbol\";",
	"            printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
	"                    YYPREFIX, yystate, yychar, yys);",
	"        }",
	"#endif",
	"    }",
	"    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",
	"            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
	"    {",
	"#if YYDEBUG",
	"        if (yydebug)",
	"            printf(\"%sdebug: state %d, shifting to state %d\\n\",",
	"                    YYPREFIX, yystate, yytable[yyn]);",
	"#endif",
	"        if (yyssp >= yysslim && yygrowstack())",
	"        {",
	"            goto yyoverflow;",
	"        }",
	"        *++yyssp = yystate = yytable[yyn];",
	"        *++yyvsp = yylval;",
	"        yychar = (-1);",
	"        if (yyerrflag > 0)  --yyerrflag;",
	"        goto yyloop;",
	"    }",
	"    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",
	"            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
	"    {",
	"        yyn = yytable[yyn];",
	"        goto yyreduce;",
	"    }",
	"    if (yyerrflag) goto yyinrecovery;",
	"#if defined(__GNUC__)",
	"    goto yynewerror;",
	"#endif",
	"yynewerror:",
	"    yyerror(\"syntax error\");",
	"#if defined(__GNUC__)",
	"    goto yyerrlab;",
	"#endif",
	"yyerrlab:",
	"    ++yynerrs;",
	"yyinrecovery:",
	"    if (yyerrflag < 3)",
	"    {",
	"        yyerrflag = 3;",
	"        for (;;)",
	"        {",
	"            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
	"                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
	"            {",
	"#if YYDEBUG",
	"                if (yydebug)",
	"                    printf(\"%sdebug: state %d, error recovery shifting\\",
	" to state %d\\n\", YYPREFIX, *yyssp, yytable[yyn]);",
	"#endif",
	"                if (yyssp >= yysslim && yygrowstack())",
	"                {",
	"                    goto yyoverflow;",
	"                }",
	"                *++yyssp = yystate = yytable[yyn];",
	"                *++yyvsp = yylval;",
	"                goto yyloop;",
	"            }",
	"            else",
	"            {",
	"#if YYDEBUG",
	"                if (yydebug)",
	"                    printf(\"%sdebug: error recovery discarding state %d\
\\n\",",
	"                            YYPREFIX, *yyssp);",
	"#endif",
	"                if (yyssp <= yyss) goto yyabort;",
	"                --yyssp;",
	"                --yyvsp;",
	"            }",
	"        }",
	"    }",
	"    else",
	"    {",
	"        if (yychar == 0) goto yyabort;",
	"#if YYDEBUG",
	"        if (yydebug)",
	"        {",
	"            yys = 0;",
	"            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
	"            if (!yys) yys = \"illegal-symbol\";",
	"            printf(\"%sdebug: state %d, error recovery discards token %d\
 (%s)\\n\",",
	"                    YYPREFIX, yystate, yychar, yys);",
	"        }",
	"#endif",
	"        yychar = (-1);",
	"        goto yyloop;",
	"    }",
	"yyreduce:",
	"#if YYDEBUG",
	"    if (yydebug)",
	"        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",",
	"                YYPREFIX, yystate, yyn, yyrule[yyn]);",
	"#endif",
	"    yym = yylen[yyn];",
	"    if (yym)",
	"        yyval = yyvsp[1-yym];",
	"    else",
	"        memset(&yyval, 0, sizeof yyval);",
	"    switch (yyn)",
	"    {",
	NULL
};


char *trailer[] =
{
	"    }",
	"    yyssp -= yym;",
	"    yystate = *yyssp;",
	"    yyvsp -= yym;",
	"    yym = yylhs[yyn];",
	"    if (yystate == 0 && yym == 0)",
	"    {",
	"#if YYDEBUG",
	"        if (yydebug)",
	"            printf(\"%sdebug: after reduction, shifting from state 0 to\\",
	" state %d\\n\", YYPREFIX, YYFINAL);",
	"#endif",
	"        yystate = YYFINAL;",
	"        *++yyssp = YYFINAL;",
	"        *++yyvsp = yyval;",
	"        if (yychar < 0)",
	"        {",
	"            if ((yychar = yylex()) < 0) yychar = 0;",
	"#if YYDEBUG",
	"            if (yydebug)",
	"            {",
	"                yys = 0;",
	"                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
	"                if (!yys) yys = \"illegal-symbol\";",
	"                printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
	"                        YYPREFIX, YYFINAL, yychar, yys);",
	"            }",
	"#endif",
	"        }",
	"        if (yychar == 0) goto yyaccept;",
	"        goto yyloop;",
	"    }",
	"    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
	"            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
	"        yystate = yytable[yyn];",
	"    else",
	"        yystate = yydgoto[yym];",
	"#if YYDEBUG",
	"    if (yydebug)",
	"        printf(\"%sdebug: after reduction, shifting from state %d \\",
	"to state %d\\n\", YYPREFIX, *yyssp, yystate);",
	"#endif",
	"    if (yyssp >= yysslim && yygrowstack())",
	"    {",
	"        goto yyoverflow;",
	"    }",
	"    *++yyssp = yystate;",
	"    *++yyvsp = yyval;",
	"    goto yyloop;",
	"yyoverflow:",
	"    yyerror(\"yacc stack overflow\");",
	"yyabort:",
	"    if (yyss)",
	"            free(yyss);",
	"    if (yyvs)",
	"            free(yyvs);",
	"    yyss = yyssp = NULL;",
	"    yyvs = yyvsp = NULL;",
	"    yystacksize = 0;",
	"    return (1);",
	"yyaccept:",
	"    if (yyss)",
	"            free(yyss);",
	"    if (yyvs)",
	"            free(yyvs);",
	"    yyss = yyssp = NULL;",
	"    yyvs = yyvsp = NULL;",
	"    yystacksize = 0;",
	"    return (0);",
	"}",
	NULL
};


void
write_section(char *section[])
{
	int i;
	char *s;

	for (i = 0; (s = section[i]); ++i) {
		++outline;
		fputs(s, code_file);
		putc('\n', code_file);
	}
}
@


1.38
log
@Back out of 1.36 and 1.37, which made simplifications to allocation
logic based on C89. It broke a few C++ ports. Prompted by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.37 2015/12/30 14:45:38 tedu Exp $	*/
d112 1
@


1.37
log
@put back casts for realloc because c++ needs them. reported by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.36 2015/12/28 19:14:04 mmcc Exp $	*/
d140 2
a141 1
	"    newss = (short *)realloc(yyss, newsize * sizeof(*newss)); /* overflow check above */",
d148 2
a149 1
	"    newvs = (YYSTYPE *)realloc(yyvs, newsize * sizeof(*newvs)); /* overflow check above */",
d158 4
a161 2
	"    free(yyss);",
	"    free(yyvs);",
d371 4
a374 2
	"    free(yyss);",
	"    free(yyvs);",
d380 4
a383 2
	"    free(yyss);",
	"    free(yyvs);",
@


1.36
log
@realloc and free's behavior when passed NULL is defined by C89, so we
can safely assume it.

ok millert@@. Also discussed with deraadt@@, sthen@@, and espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.35 2014/03/16 18:38:30 guenther Exp $	*/
d140 1
a140 1
	"    newss = realloc(yyss, newsize * sizeof(*newss)); /* overflow check above */",
d147 1
a147 1
	"    newvs = realloc(yyvs, newsize * sizeof(*newvs)); /* overflow check above */",
@


1.35
log
@lint is dead (long live the lint!), so stop using it as a cpp conditional
(namespace pollution!) or talking about its opinion on code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.34 2014/03/07 19:44:07 tedu Exp $	*/
d140 1
a140 2
	"    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :",
	"      (short *)malloc(newsize * sizeof *newss); /* overflow check above */",
d147 1
a147 2
	"    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :",
	"      (YYSTYPE *)malloc(newsize * sizeof *newvs); /* overflow check above */",
d156 2
a157 4
	"    if (yyss)",
	"            free(yyss);",
	"    if (yyvs)",
	"            free(yyvs);",
d367 2
a368 4
	"    if (yyss)",
	"            free(yyss);",
	"    if (yyvs)",
	"            free(yyvs);",
d374 2
a375 4
	"    if (yyss)",
	"            free(yyss);",
	"    if (yyvs)",
	"            free(yyvs);",
@


1.34
log
@a few other tweaks it's easier to see in the light of day
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.33 2014/03/07 19:34:49 tedu Exp $	*/
d237 1
a237 1
	"#if defined(lint) || defined(__GNUC__)",
d242 1
a242 1
	"#if defined(lint) || defined(__GNUC__)",
@


1.33
log
@drag this code into modern style. ok zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.32 2014/02/21 02:18:00 tedu Exp $	*/
a395 1
	int c;
a397 1
	FILE *f;
a398 1
	f = code_file;
d401 2
a402 2
		fputs(s, f);
		putc('\n', f);
@


1.32
log
@drop support for pre-standard C, it's time to move on. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.31 2013/10/30 20:33:00 millert Exp $	*/
d52 11
a62 11
    "#include <stdlib.h>",
    "#include <string.h>",
    "#define YYBYACC 1",
    "#define YYMAJOR 1",
    "#define YYMINOR 9",
    "#define YYLEX yylex()",
    "#define YYEMPTY -1",
    "#define yyclearin (yychar=(YYEMPTY))",
    "#define yyerrok (yyerrflag=0)",
    "#define YYRECOVERING() (yyerrflag!=0)",
    NULL
d68 14
a81 14
    "extern const short yylhs[];",
    "extern const short yylen[];",
    "extern const short yydefred[];",
    "extern const short yydgoto[];",
    "extern const short yysindex[];",
    "extern const short yyrindex[];",
    "extern const short yygindex[];",
    "extern const short yytable[];",
    "extern const short yycheck[];",
    "#if YYDEBUG",
    "extern const char *const yyname[];",
    "extern const char *const yyrule[];",
    "#endif",
    NULL
d87 26
a112 26
    "#ifdef YYSTACKSIZE",
    "#undef YYMAXDEPTH",
    "#define YYMAXDEPTH YYSTACKSIZE",
    "#else",
    "#ifdef YYMAXDEPTH",
    "#define YYSTACKSIZE YYMAXDEPTH",
    "#else",
    "#define YYSTACKSIZE 10000",
    "#define YYMAXDEPTH 10000",
    "#endif",
    "#endif",
    "#define YYINITSTACKSIZE 200",
    "/* LINTUSED */",
    "int yydebug;",
    "int yynerrs;",
    "int yyerrflag;",
    "int yychar;",
    "short *yyssp;",
    "YYSTYPE *yyvsp;",
    "YYSTYPE yyval;",
    "YYSTYPE yylval;",
    "short *yyss;",
    "short *yysslim;",
    "YYSTYPE *yyvs;",
    "unsigned int yystacksize;",
    NULL
d118 156
a273 156
    "/* allocate initial stack or double stack size, up to YYMAXDEPTH */",
    "static int yygrowstack(void)",
    "{",
    "    unsigned int newsize;",
    "    long sslen;",
    "    short *newss;",
    "    YYSTYPE *newvs;",
    "",
    "    if ((newsize = yystacksize) == 0)",
    "        newsize = YYINITSTACKSIZE;",
    "    else if (newsize >= YYMAXDEPTH)",
    "        return -1;",
    "    else if ((newsize *= 2) > YYMAXDEPTH)",
    "        newsize = YYMAXDEPTH;",
    "    sslen = yyssp - yyss;",
    "#ifdef SIZE_MAX",
    "#define YY_SIZE_MAX SIZE_MAX",
    "#else",
    "#define YY_SIZE_MAX 0xffffffffU",
    "#endif",
    "    if (newsize && YY_SIZE_MAX / newsize < sizeof *newss)",
    "        goto bail;",
    "    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :",
    "      (short *)malloc(newsize * sizeof *newss); /* overflow check above */",
    "    if (newss == NULL)",
    "        goto bail;",
    "    yyss = newss;",
    "    yyssp = newss + sslen;",
    "    if (newsize && YY_SIZE_MAX / newsize < sizeof *newvs)",
    "        goto bail;",
    "    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :",
    "      (YYSTYPE *)malloc(newsize * sizeof *newvs); /* overflow check above */",
    "    if (newvs == NULL)",
    "        goto bail;",
    "    yyvs = newvs;",
    "    yyvsp = newvs + sslen;",
    "    yystacksize = newsize;",
    "    yysslim = yyss + newsize - 1;",
    "    return 0;",
    "bail:",
    "    if (yyss)",
    "            free(yyss);",
    "    if (yyvs)",
    "            free(yyvs);",
    "    yyss = yyssp = NULL;",
    "    yyvs = yyvsp = NULL;",
    "    yystacksize = 0;",
    "    return -1;",
    "}",
    "",
    "#define YYABORT goto yyabort",
    "#define YYREJECT goto yyabort",
    "#define YYACCEPT goto yyaccept",
    "#define YYERROR goto yyerrlab",
    "int",
    "yyparse(void)",
    "{",
    "    int yym, yyn, yystate;",
    "#if YYDEBUG",
    "    const char *yys;",
    "",
    "    if ((yys = getenv(\"YYDEBUG\")))",
    "    {",
    "        yyn = *yys;",
    "        if (yyn >= '0' && yyn <= '9')",
    "            yydebug = yyn - '0';",
    "    }",
    "#endif /* YYDEBUG */",
    "",
    "    yynerrs = 0;",
    "    yyerrflag = 0;",
    "    yychar = (-1);",
    "",
    "    if (yyss == NULL && yygrowstack()) goto yyoverflow;",
    "    yyssp = yyss;",
    "    yyvsp = yyvs;",
    "    *yyssp = yystate = 0;",
    "",
    "yyloop:",
    "    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;",
    "    if (yychar < 0)",
    "    {",
    "        if ((yychar = yylex()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "    }",
    "    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: state %d, shifting to state %d\\n\",",
    "                    YYPREFIX, yystate, yytable[yyn]);",
    "#endif",
    "        if (yyssp >= yysslim && yygrowstack())",
    "        {",
    "            goto yyoverflow;",
    "        }",
    "        *++yyssp = yystate = yytable[yyn];",
    "        *++yyvsp = yylval;",
    "        yychar = (-1);",
    "        if (yyerrflag > 0)  --yyerrflag;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "        yyn = yytable[yyn];",
    "        goto yyreduce;",
    "    }",
    "    if (yyerrflag) goto yyinrecovery;",
    "#if defined(lint) || defined(__GNUC__)",
    "    goto yynewerror;",
    "#endif",
    "yynewerror:",
    "    yyerror(\"syntax error\");",
    "#if defined(lint) || defined(__GNUC__)",
    "    goto yyerrlab;",
    "#endif",
    "yyerrlab:",
    "    ++yynerrs;",
    "yyinrecovery:",
    "    if (yyerrflag < 3)",
    "    {",
    "        yyerrflag = 3;",
    "        for (;;)",
    "        {",
    "            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
    "                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: state %d, error recovery shifting\\",
    " to state %d\\n\", YYPREFIX, *yyssp, yytable[yyn]);",
    "#endif",
    "                if (yyssp >= yysslim && yygrowstack())",
    "                {",
    "                    goto yyoverflow;",
    "                }",
    "                *++yyssp = yystate = yytable[yyn];",
    "                *++yyvsp = yylval;",
    "                goto yyloop;",
    "            }",
    "            else",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: error recovery discarding state %d\
d275 18
a292 18
    "                            YYPREFIX, *yyssp);",
    "#endif",
    "                if (yyssp <= yyss) goto yyabort;",
    "                --yyssp;",
    "                --yyvsp;",
    "            }",
    "        }",
    "    }",
    "    else",
    "    {",
    "        if (yychar == 0) goto yyabort;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, error recovery discards token %d\
d294 20
a313 20
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "        yychar = (-1);",
    "        goto yyloop;",
    "    }",
    "yyreduce:",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",",
    "                YYPREFIX, yystate, yyn, yyrule[yyn]);",
    "#endif",
    "    yym = yylen[yyn];",
    "    if (yym)",
    "        yyval = yyvsp[1-yym];",
    "    else",
    "        memset(&yyval, 0, sizeof yyval);",
    "    switch (yyn)",
    "    {",
    NULL
d319 71
a389 71
    "    }",
    "    yyssp -= yym;",
    "    yystate = *yyssp;",
    "    yyvsp -= yym;",
    "    yym = yylhs[yyn];",
    "    if (yystate == 0 && yym == 0)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: after reduction, shifting from state 0 to\\",
    " state %d\\n\", YYPREFIX, YYFINAL);",
    "#endif",
    "        yystate = YYFINAL;",
    "        *++yyssp = YYFINAL;",
    "        *++yyvsp = yyval;",
    "        if (yychar < 0)",
    "        {",
    "            if ((yychar = yylex()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "            if (yydebug)",
    "            {",
    "                yys = 0;",
    "                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "                if (!yys) yys = \"illegal-symbol\";",
    "                printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                        YYPREFIX, YYFINAL, yychar, yys);",
    "            }",
    "#endif",
    "        }",
    "        if (yychar == 0) goto yyaccept;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
    "        yystate = yytable[yyn];",
    "    else",
    "        yystate = yydgoto[yym];",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: after reduction, shifting from state %d \\",
    "to state %d\\n\", YYPREFIX, *yyssp, yystate);",
    "#endif",
    "    if (yyssp >= yysslim && yygrowstack())",
    "    {",
    "        goto yyoverflow;",
    "    }",
    "    *++yyssp = yystate;",
    "    *++yyvsp = yyval;",
    "    goto yyloop;",
    "yyoverflow:",
    "    yyerror(\"yacc stack overflow\");",
    "yyabort:",
    "    if (yyss)",
    "            free(yyss);",
    "    if (yyvs)",
    "            free(yyvs);",
    "    yyss = yyssp = NULL;",
    "    yyvs = yyvsp = NULL;",
    "    yystacksize = 0;",
    "    return (1);",
    "yyaccept:",
    "    if (yyss)",
    "            free(yyss);",
    "    if (yyvs)",
    "            free(yyvs);",
    "    yyss = yyssp = NULL;",
    "    yyvs = yyvsp = NULL;",
    "    yystacksize = 0;",
    "    return (0);",
    "}",
    NULL
d396 10
a405 13
    int c;
    int i;
    char *s;
    FILE *f;

    f = code_file;
    for (i = 0; (s = section[i]); ++i)
    {
	++outline;
	while ((c = *s))
	{
	    putc(c, f);
	    ++s;
a406 2
	putc('\n', f);
    }
@


1.31
log
@Make yystacksize unsigned to avoid a warning about sign comparision
mismatches.  Also store the result of "yyssp - yyss" in a long, not
an int.  We could use ptrdiff_t but don't want to rely on that type
being defined for portability on old systems without it.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.30 2009/10/27 23:59:50 deraadt Exp $	*/
d62 1
a62 1
    0
a67 1
    "#if defined(__cplusplus) || defined(__STDC__)",
d81 1
a81 16
    "#else /* !(defined(__cplusplus) || defined(__STDC__)) */",
    "extern short yylhs[];",
    "extern short yylen[];",
    "extern short yydefred[];",
    "extern short yydgoto[];",
    "extern short yysindex[];",
    "extern short yyrindex[];",
    "extern short yygindex[];",
    "extern short yytable[];",
    "extern short yycheck[];",
    "#if YYDEBUG",
    "extern char *yyname[];",
    "extern char *yyrule[];",
    "#endif /* YYDEBUG */",
    "#endif /* !(defined(__cplusplus) || defined(__STDC__)) */",
    0
d112 1
a112 1
    0
a118 1
    "#if defined(__cplusplus) || defined(__STDC__)",
a119 3
    "#else",
    "static int yygrowstack()",
    "#endif",
a172 1
    "#if defined(__cplusplus) || defined(__STDC__)",
a173 3
    "#else",
    "yyparse()",
    "#endif",
a176 1
    "#if defined(__cplusplus) || defined(__STDC__)",
a177 3
    "#else /* !(defined(__cplusplus) || defined(__STDC__)) */",
    "    char *yys;",
    "#endif /* !(defined(__cplusplus) || defined(__STDC__)) */",
d313 1
a313 1
    0
d389 1
a389 1
    0
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.29 2008/07/08 15:06:50 otto Exp $	*/
d127 1
a127 1
    "int yystacksize;",
d141 2
a142 1
    "    int newsize, i;",
d152 1
a152 1
    "    i = yyssp - yyss;",
d165 1
a165 1
    "    yyssp = newss + i;",
d173 1
a173 1
    "    yyvsp = newvs + i;",
@


1.29
log
@Fix an venerable bug: if we're reducing a rule that has an empty
right hand side and the yacc stackpointer is pointing at the very
end of the allocated stack, we end up accessing the stack out of
bounds by the implicit $$ = $1 action.  Detected by my new malloc,
experienced by sturm@@ on sparc64; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.28 2007/09/03 21:14:58 deraadt Exp $	*/
a35 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)skeleton.c	5.8 (Berkeley) 4/29/95";
#else
static char rcsid[] = "$NetBSD: skeleton.c,v 1.10 1996/03/25 00:36:18 mrg Exp $";
#endif
#endif /* not lint */

a51 8
    "#ifndef lint",
    "/*static char yysccsid[] = \"from: @@(#)yaccpar	1.9 (Berkeley) 02/21/93\";*/",
    "static char yyrcsid[]",
    "#if __GNUC__ >= 2",
    "  __attribute__ ((unused))",
    "#endif /* __GNUC__ >= 2 */",
    "  = \"$OpenBSD: skeleton.c,v 1.28 2007/09/03 21:14:58 deraadt Exp $\";",
    "#endif",
@


1.28
log
@move back to using malloc() instead of calloc(), because the yacc
skeleton really should only call malloc/realloc/free, no other external
APIs at all.  theefore, add a pre-check for the overflow case, thus
protecting realloc too; tested mblamer, ok millert, help from kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.27 2007/09/02 15:19:36 deraadt Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.27 2007/09/02 15:19:36 deraadt Exp $\";",
d69 1
d350 4
a353 1
    "    yyval = yyvsp[1-yym];",
@


1.27
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.26 2006/04/20 16:51:32 deraadt Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.26 2006/04/20 16:51:32 deraadt Exp $\";",
d167 7
d175 1
a175 1
    "      (short *)calloc(newsize, sizeof *newss);",
d180 2
d183 1
a183 1
    "      (YYSTYPE *)calloc(newsize, sizeof *newvs);",
@


1.26
log
@use new LINTED keyword for a global which is perhaps not used, but must
be there; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.25 2006/04/20 03:07:36 deraadt Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.25 2006/04/20 03:07:36 deraadt Exp $\";",
d168 1
a168 1
    "      (short *)malloc(newsize * sizeof *newss);",
d174 1
a174 1
    "      (YYSTYPE *)malloc(newsize * sizeof *newvs);",
@


1.25
log
@yydebug has to always be there, even if it is not used.  this pleases
lint on every program that has a .y in it....; ok cloder though he does
not understand yet
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.24 2005/06/10 16:40:45 pvalchev Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.24 2005/06/10 16:40:45 pvalchev Exp $\";",
d130 1
a130 1
    "/* LINTED YYDEBUG */",
@


1.24
log
@-Wall clean; ok otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.23 2004/03/12 13:39:50 henning Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.23 2004/03/12 13:39:50 henning Exp $\";",
d130 1
@


1.23
log
@fix memory leak in the code yacc generates, ok millert deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.22 2003/11/25 20:00:15 espie Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.22 2003/11/25 20:00:15 espie Exp $\";",
d434 1
a434 1
	while (c = *s)
@


1.22
log
@obvious fix for gcc3.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.21 2003/06/19 16:34:53 pvalchev Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.21 2003/06/19 16:34:53 pvalchev Exp $\";",
d400 7
d409 7
@


1.21
log
@ansify; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.20 2003/06/03 02:56:24 millert Exp $	*/
d63 1
a63 1
    "#if __GNUC__ == 2",
d65 2
a66 2
    "#endif /* __GNUC__ == 2 */",
    "  = \"$OpenBSD: skeleton.c,v 1.20 2003/06/03 02:56:24 millert Exp $\";",
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.19 2002/12/03 21:34:21 mickey Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.19 2002/12/03 21:34:21 mickey Exp $\";",
d409 1
a409 2
write_section(section)
char *section[];
@


1.19
log
@constify the not yet constified tables, use defined(__STDC__) instead of ifdef __STC__ where appropriate; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.18 2001/11/19 19:02:18 mpech Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.18 2001/11/19 19:02:18 mpech Exp $\";",
@


1.18
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.17 2001/07/16 06:29:45 pvalchev Exp $	*/
d70 1
a70 1
    "  = \"$OpenBSD: skeleton.c,v 1.17 2001/07/16 06:29:45 pvalchev Exp $\";",
d87 15
a111 4
    "#if defined(__cplusplus) || __STDC__",
    "extern const char * const yyname[];",
    "extern const char * const yyrule[];",
    "#else /* !(defined(__cplusplus) || __STDC__) */",
a113 1
    "#endif /* !(defined(__cplusplus) || __STDC__) */",
d115 1
d153 1
a153 1
    "#if defined(__cplusplus) || __STDC__",
d201 1
a201 1
    "#if defined(__cplusplus) || __STDC__",
d209 1
a209 1
    "#if defined(__cplusplus) || __STDC__",
d211 1
a211 1
    "#else /* !(defined(__cplusplus) || __STDC__) */",
d213 1
a213 1
    "#endif /* !(defined(__cplusplus) || __STDC__) */",
@


1.17
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.16 2001/02/26 00:03:33 tholo Exp $	*/
d70 1
a70 1
    "  = \"$OpenBSD: skeleton.c,v 1.16 2001/02/26 00:03:33 tholo Exp $\";",
d196 1
a196 1
    "    register int yym, yyn, yystate;",
d199 1
a199 1
    "    register const char *yys;",
d201 1
a201 1
    "    register char *yys;",
d405 4
a408 4
    register int c;
    register int i;
    register char *s;
    register FILE *f;
@


1.16
log
@Silence some warnings in generated grammers compiled with YYDEBUG;
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.15 2000/01/27 21:34:23 deraadt Exp $	*/
d70 1
a70 1
    "  = \"$OpenBSD: skeleton.c,v 1.15 2000/01/27 21:34:23 deraadt Exp $\";",
d401 1
d411 1
a411 1
    for (i = 0; s = section[i]; ++i)
@


1.15
log
@er, oops, types must be same for multiple assignment
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.14 2000/01/26 22:37:24 deraadt Exp $	*/
d70 1
a70 1
    "  = \"$OpenBSD: skeleton.c,v 1.14 2000/01/26 22:37:24 deraadt Exp $\";",
d97 4
d103 2
a104 1
    "#endif",
d198 3
d202 1
d210 1
a210 1
    "#endif",
@


1.14
log
@if yygrowstack() fails to allocate memory, free all yacc memory allocations and reset for future yyparse() calls... obscure eh
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.13 1998/11/18 15:45:12 dm Exp $	*/
d70 1
a70 1
    "  = \"$OpenBSD: skeleton.c,v 1.13 1998/11/18 15:45:12 dm Exp $\";",
d174 2
a175 1
    "    yyss = yyssp = yyvs = yyvsp = NULL;",
@


1.13
log
@revert last change for K\&R C compilers without const
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.11 1998/11/17 06:13:43 dm Exp $	*/
d70 1
a70 1
    "  = \"$OpenBSD: skeleton.c,v 1.11 1998/11/17 06:13:43 dm Exp $\";",
d157 1
a157 1
    "        return -1;",
d163 1
a163 1
    "        return -1;",
d169 8
@


1.12
log
@drop the __attribute__ stuf in favor of a simple const
@
text
@d66 5
a70 1
    "static const char yyrcsid[] = \"$OpenBSD: skeleton.c,v 1.11 1998/11/17 06:13:43 dm Exp $\";",
@


1.11
log
@add __attribute__ ((unused)) to the yyrcsid under GCC 2
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.10 1998/09/08 04:21:08 millert Exp $	*/
d66 1
a66 5
    "static char yyrcsid[]",
    "#if __GNUC__ == 2",
    "  __attribute__ ((unused))",
    "#endif /* __GNUC__ == 2 */",
    "  = \"$OpenBSD: skeleton.c,v 1.10 1998/09/08 04:21:08 millert Exp $\";",
@


1.10
log
@Don't assume realloc() can take NULL as first arg.  Yacc needs to generate portable code...
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.9 1998/04/25 18:52:18 mickey Exp $	*/
d66 5
a70 1
    "static char yyrcsid[] = \"$OpenBSD: skeleton.c,v 1.9 1998/04/25 18:52:18 mickey Exp $\";",
@


1.9
log
@remove const, so it works on !ansi compiler
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.8 1997/01/03 00:53:25 tholo Exp $	*/
d66 1
a66 1
    "static char yyrcsid[] = \"$OpenBSD: skeleton.c,v 1.8 1997/01/03 00:53:25 tholo Exp $\";",
d150 3
a152 1
    "    if ((newss = (short *)realloc(yyss, newsize * sizeof *newss)) == NULL)",
d156 3
a158 1
    "    if ((newvs = (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs)) == NULL)",
@


1.8
log
@YYRECOVERING(), not YYRECOVERING.  Approved by Robert Corbett
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.7 1996/12/27 08:05:18 tholo Exp $	*/
d66 1
a66 1
    "static const char yyrcsid[] = \"$OpenBSD: skeleton.c,v 1.7 1996/12/27 08:05:18 tholo Exp $\";",
@


1.7
log
@Remove some GCC warnings in generated output; from Steve Price via FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.6 1996/07/28 02:03:26 deraadt Exp $	*/
d66 1
a66 1
    "static const char yyrcsid[] = \"$OpenBSD: skeleton.c,v 1.6 1996/07/28 02:03:26 deraadt Exp $\";",
d76 1
a76 1
    "#define YYRECOVERING (yyerrflag!=0)",
@


1.6
log
@silence gcc in super-pedantic mode; based on freebsd pr#1427
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.5 1996/05/20 07:31:54 tholo Exp $	*/
d66 1
a66 1
    "static char yyrcsid[] = \"$OpenBSD: skeleton.c,v 1.5 1996/05/20 07:31:54 tholo Exp $\";",
d236 1
a236 1
    "#ifdef lint",
d241 1
a241 1
    "#ifdef lint",
@


1.5
log
@Use prototypes if 'defined(__cplusplus) || __STDC__'
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.3 1996/03/27 19:33:21 niklas Exp $	*/
d66 1
a66 1
    "static char yyrcsid[] = \"$OpenBSD: skeleton.c,v 1.3 1996/03/27 19:33:21 niklas Exp $\";",
d178 1
a178 1
    "    if (yys = getenv(\"YYDEBUG\"))",
@


1.4
log
@sync to netbsd 960418
@
text
@d133 3
d137 1
d168 3
d172 1
@


1.3
log
@From NetBSD: merge of 960317
@
text
@d1 46
a46 1
/*	$OpenBSD$	*/
d66 1
a66 1
    "static char yyrcsid[] = \"$OpenBSD$\";",
d68 1
d109 2
a110 2
    "#define YYSTACKSIZE 500",
    "#define YYMAXDEPTH 500",
d113 1
d122 4
a125 3
    "short yyss[YYSTACKSIZE];",
    "YYSTYPE yyvs[YYSTACKSIZE];",
    "#define yystacksize YYSTACKSIZE",
d132 27
a163 3
    "#if defined(__STDC__)",
    "yyparse(void)",
    "#else",
a164 1
    "#endif",
a168 1
    "    extern char *getenv();",
d182 1
d211 1
a211 1
    "        if (yyssp >= yyss + yystacksize - 1)",
d228 4
d252 1
a252 1
    "                if (yyssp >= yyss + yystacksize - 1)",
d349 1
a349 1
    "    if (yyssp >= yyss + yystacksize - 1)",
@


1.2
log
@Imported from Cygnus byacc: Define YYEMPTY and YYLEX, because GCC uses them.
@
text
@d1 2
d21 1
a21 1
    "static char yyrcsid[] = \"$Id: skeleton.c,v 1.1.1.1 1995/10/18 08:47:06 deraadt Exp $\";",
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
    "static char yyrcsid[] = \"$Id: skeleton.c,v 1.6 1995/09/07 17:34:04 jtc Exp $\";",
d24 3
a26 1
    "#define yyclearin (yychar=(-1))",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
