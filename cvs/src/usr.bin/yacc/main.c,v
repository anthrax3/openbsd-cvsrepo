head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.2
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.12
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.10
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.8
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.18.0.8
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2017.05.25.20.11.03;	author tedu;	state Exp;
branches;
next	1.28;
commitid	z7x0vVP30EN9CXhi;

1.28
date	2016.07.27.20.53.47;	author tedu;	state Exp;
branches;
next	1.27;
commitid	IZ3MnaQwWuyeSgh4;

1.27
date	2015.10.10.14.23.47;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	yjVtbeobniTvUanD;

1.26
date	2014.03.13.00.33.55;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.08.22.30.32;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.08.21.40.25;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.05.01.10.41.05;	author chl;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.08.03.18.59;	author pvalchev;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.04.13.46.06;	author robert;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.19.16.34.53;	author pvalchev;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.16.17.43.37;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.28.00;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.07.11.42.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.16.06.29.44;	author pvalchev;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.19.17.58.22;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.08.04.18.31.26;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.05.28.16.48.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.11.05.09.36.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.04.18.41.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.14.04.47.08;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.06.26.05.44.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.25.01.54.55;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.45.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.22.00.57.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@fix a variety of warnings. from Brian Callahan
@
text
@/* $OpenBSD: main.c,v 1.28 2016/07/27 20:53:47 tedu Exp $	 */
/* $NetBSD: main.c,v 1.5 1996/03/19 03:21:38 jtc Exp $	 */

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include "defs.h"

char dflag;
char lflag;
char rflag;
char tflag;
char vflag;

char *symbol_prefix;
char *file_prefix = "y";

int lineno;
int outline;

int explicit_file_name;

char *action_file_name;
char *code_file_name;
char *defines_file_name;
char *input_file_name = "";
char *output_file_name;
char *text_file_name;
char *union_file_name;
char *verbose_file_name;

FILE *action_file;	/* a temp file, used to save actions associated    */
			/* with rules until the parser is written	   */
FILE *code_file;	/* y.code.c (used when the -r option is specified) */
FILE *defines_file;	/* y.tab.h					   */
FILE *input_file;	/* the input file				   */
FILE *output_file;	/* y.tab.c					   */
FILE *text_file;	/* a temp file, used to save text until all	   */
			/* symbols have been defined			   */
FILE *union_file;	/* a temp file, used to save the union		   */
			/* definition until all symbol have been	   */
			/* defined					   */
FILE *verbose_file;	/* y.output					   */

int nitems;
int nrules;
int nsyms;
int ntokens;
int nvars;

int start_symbol;
char **symbol_name;
short *symbol_value;
short *symbol_prec;
char *symbol_assoc;

short *ritem;
short *rlhs;
short *rrhs;
short *rprec;
char *rassoc;
short **derives;
char *nullable;

void onintr(int);
void set_signals(void);
void usage(void);
void getargs(int, char *[]);
void create_file_names(void);
void open_files(void);

volatile sig_atomic_t sigdie;

void
done(int k)
{
	if (action_file)
		unlink(action_file_name);
	if (text_file)
		unlink(text_file_name);
	if (union_file)
		unlink(union_file_name);
	if (sigdie)
		_exit(k);
	exit(k);
}


void
onintr(__unused int signo)
{
	sigdie = 1;
	done(1);
}


void
set_signals(void)
{
#ifdef SIGINT
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, onintr);
#endif
#ifdef SIGTERM
	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
		signal(SIGTERM, onintr);
#endif
#ifdef SIGHUP
	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
		signal(SIGHUP, onintr);
#endif
}


void
usage(void)
{
	fprintf(stderr, "usage: %s [-dlrtv] [-b file_prefix] [-o output_file] [-p symbol_prefix] file\n", __progname);
	exit(1);
}


void
getargs(int argc, char *argv[])
{
	int ch;

	while ((ch = getopt(argc, argv, "b:dlo:p:rtv")) != -1) {
		switch (ch) {
		case 'b':
			file_prefix = optarg;
			break;

		case 'd':
			dflag = 1;
			break;

		case 'l':
			lflag = 1;
			break;

		case 'o':
			output_file_name = optarg;
			explicit_file_name = 1;
			break;

		case 'p':
			symbol_prefix = optarg;
			break;

		case 'r':
			rflag = 1;
			break;

		case 't':
			tflag = 1;
			break;

		case 'v':
			vflag = 1;
			break;

		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();
	if (strcmp(*argv, "-") == 0)
		input_file = stdin;
	else
		input_file_name = *argv;
}


void *
allocate(size_t n)
{
	void *v;

	v = NULL;
	if (n) {
		v = calloc(1, n);
		if (!v)
			no_space();
	}
	return (v);
}

#define TEMPNAME(s, c, d, l)	\
	(asprintf(&(s), "%.*s/yacc.%xXXXXXXXXXX", (int)(l), (d), (c)))

void
create_file_names(void)
{
	size_t len;
	char *tmpdir;

	tmpdir = _PATH_TMP;

	len = strlen(tmpdir);
	if (tmpdir[len - 1] == '/')
		len--;

	if (TEMPNAME(action_file_name, 'a', tmpdir, len) == -1 ||
	    TEMPNAME(text_file_name, 'r', tmpdir, len) == -1 ||
	    TEMPNAME(union_file_name, 'u', tmpdir, len) == -1)
		no_space();

	if (output_file_name == NULL) {
		if (asprintf(&output_file_name, "%s%s", file_prefix, OUTPUT_SUFFIX)
		    == -1)
			no_space();
	}
	if (rflag) {
		if (asprintf(&code_file_name, "%s%s", file_prefix, CODE_SUFFIX) == -1)
			no_space();
	} else
		code_file_name = output_file_name;

	if (dflag) {
		if (explicit_file_name) {
			char *suffix;

			defines_file_name = strdup(output_file_name);
			if (defines_file_name == 0)
				no_space();

			/* does the output_file_name have a known suffix */
			if ((suffix = strrchr(output_file_name, '.')) != 0 &&
			    (!strcmp(suffix, ".c") ||	/* good, old-fashioned C */
			     !strcmp(suffix, ".C") ||	/* C++, or C on Windows */
			     !strcmp(suffix, ".cc") ||	/* C++ */
			     !strcmp(suffix, ".cxx") ||	/* C++ */
			     !strcmp(suffix, ".cpp"))) {/* C++ (Windows) */
				strncpy(defines_file_name, output_file_name,
					suffix - output_file_name + 1);
				defines_file_name[suffix - output_file_name + 1] = 'h';
				defines_file_name[suffix - output_file_name + 2] = '\0';
			} else {
				fprintf(stderr, "%s: suffix of output file name %s"
				 " not recognized, no -d file generated.\n",
					__progname, output_file_name);
				dflag = 0;
				free(defines_file_name);
				defines_file_name = 0;
			}
		} else {
			if (asprintf(&defines_file_name, "%s%s", file_prefix,
				     DEFINES_SUFFIX) == -1)
				no_space();
		}
	}
	if (vflag) {
		if (asprintf(&verbose_file_name, "%s%s", file_prefix,
			     VERBOSE_SUFFIX) == -1)
			no_space();
	}
}


void
open_files(void)
{
	int fd;

	create_file_names();

	if (input_file == 0) {
		input_file = fopen(input_file_name, "r");
		if (input_file == 0)
			open_error(input_file_name);
	}
	fd = mkstemp(action_file_name);
	if (fd == -1 || (action_file = fdopen(fd, "w")) == NULL)
		open_error(action_file_name);

	fd = mkstemp(text_file_name);
	if (fd == -1 || (text_file = fdopen(fd, "w")) == NULL)
		open_error(text_file_name);

	if (vflag) {
		verbose_file = fopen(verbose_file_name, "w");
		if (verbose_file == 0)
			open_error(verbose_file_name);
	}
	if (dflag) {
		defines_file = fopen(defines_file_name, "w");
		if (defines_file == NULL)
			open_write_error(defines_file_name);
		fd = mkstemp(union_file_name);
		if (fd == -1 || (union_file = fdopen(fd, "w")) == NULL)
			open_error(union_file_name);
	}
	output_file = fopen(output_file_name, "w");
	if (output_file == 0)
		open_error(output_file_name);

	if (rflag) {
		code_file = fopen(code_file_name, "w");
		if (code_file == 0)
			open_error(code_file_name);
	} else
		code_file = output_file;
}


int
main(int argc, char *argv[])
{
	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		fatal("pledge: invalid arguments");

	set_signals();
	getargs(argc, argv);
	open_files();
	reader();
	lr0();
	lalr();
	make_parser();
	verbose();
	output();
	done(0);
	/* NOTREACHED */
	return (0);
}
@


1.28
log
@it should not be necessary for yacc to use TMPDIR, /tmp is good enough.
ok beck deraadt guenther
@
text
@d1 1
a1 1
/* $OpenBSD: main.c,v 1.27 2015/10/10 14:23:47 deraadt Exp $	 */
d125 1
a125 1
onintr(int signo)
@


1.27
log
@fairly obvious pledges.
ok doug
@
text
@d1 1
a1 1
/* $OpenBSD: main.c,v 1.26 2014/03/13 00:33:55 tedu Exp $	 */
d237 1
a237 2
	if ((tmpdir = getenv("TMPDIR")) == NULL || *tmpdir == '\0')
		tmpdir = _PATH_TMP;
@


1.26
log
@indent, add a touch of style
@
text
@d1 1
a1 1
/* $OpenBSD: main.c,v 1.25 2014/01/08 22:30:32 millert Exp $	 */
d350 3
@


1.25
log
@Make allocate() take size_t and return void *.  This lets us drop
some more useless casts.  Also add missing arguments to a couple
of prototypes while here.  OK matthew@@ pelikan@@
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.24 2014/01/08 21:40:25 millert Exp $	*/
/*	$NetBSD: main.c,v 1.5 1996/03/19 03:21:38 jtc Exp $	*/
d67 12
a78 12
FILE *action_file;	/*  a temp file, used to save actions associated    */
			/*  with rules until the parser is written	    */
FILE *code_file;	/*  y.code.c (used when the -r option is specified) */
FILE *defines_file;	/*  y.tab.h					    */
FILE *input_file;	/*  the input file				    */
FILE *output_file;	/*  y.tab.c					    */
FILE *text_file;	/*  a temp file, used to save text until all	    */
			/*  symbols have been defined			    */
FILE *union_file;	/*  a temp file, used to save the union		    */
			/*  definition until all symbol have been	    */
			/*  defined					    */
FILE *verbose_file;	/*  y.output					    */
d86 2
a87 2
int   start_symbol;
char  **symbol_name;
d90 1
a90 1
char  *symbol_assoc;
d96 1
a96 1
char  *rassoc;
d112 9
a120 9
    if (action_file)
	unlink(action_file_name);
    if (text_file)
	unlink(text_file_name);
    if (union_file)
	unlink(union_file_name);
    if (sigdie)
	_exit(k);
    exit(k);
d127 2
a128 2
    sigdie = 1;
    done(1);
d136 2
a137 2
    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
	signal(SIGINT, onintr);
d140 2
a141 2
    if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
	signal(SIGTERM, onintr);
d144 2
a145 2
    if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
	signal(SIGHUP, onintr);
d153 2
a154 2
    fprintf(stderr, "usage: %s [-dlrtv] [-b file_prefix] [-o output_file] [-p symbol_prefix] file\n", __progname);
    exit(1);
d161 1
a161 1
    int ch;
d163 41
a203 36
    while ((ch = getopt(argc, argv, "b:dlo:p:rtv")) != -1)
    {
	switch (ch)
	{
	case 'b':
	    file_prefix = optarg;
	    break;
	    
	case 'd':
	    dflag = 1;
	    break;

	case 'l':
	    lflag = 1;
	    break;

        case 'o':
	    output_file_name = optarg;
	    explicit_file_name = 1;
	    break;
	    
	case 'p':
	    symbol_prefix = optarg;
	    break;
	    
	case 'r':
	    rflag = 1;
	    break;

	case 't':
	    tflag = 1;
	    break;

	case 'v':
	    vflag = 1;
	    break;
d205 6
a210 13
	default:
	    usage();
	}
    }
    argc -= optind;
    argv += optind;

    if (argc != 1)
	usage();
    if (strcmp(*argv, "-") == 0)
	input_file = stdin;
    else
	input_file_name = *argv;
d217 1
a217 1
    void *v;
d219 7
a225 7
    v = NULL;
    if (n)
    {
	v = calloc(1, n);
	if (!v) no_space();
    }
    return (v);
d234 2
a235 2
    size_t len;
    char *tmpdir;
d237 2
a238 2
    if ((tmpdir = getenv("TMPDIR")) == NULL || *tmpdir == '\0')
	tmpdir = _PATH_TMP;
d240 52
a291 52
    len = strlen(tmpdir);
    if (tmpdir[len-1] == '/')
	len--;

    if (TEMPNAME(action_file_name, 'a', tmpdir, len) == -1 ||
	TEMPNAME(text_file_name, 'r', tmpdir, len) == -1 ||
	TEMPNAME(union_file_name, 'u', tmpdir, len) == -1)
	no_space();

    if (output_file_name == NULL)
    {
	if (asprintf(&output_file_name, "%s%s", file_prefix, OUTPUT_SUFFIX)
	    == -1)
	    no_space();
    }

    if (rflag) {
	if (asprintf(&code_file_name, "%s%s", file_prefix, CODE_SUFFIX) == -1)
	    no_space();
    } else
	code_file_name = output_file_name;

    if (dflag)
    {
        if (explicit_file_name)
	{
	    char *suffix;

	    defines_file_name = strdup(output_file_name);
	    if (defines_file_name == 0)
	        no_space();

            /* does the output_file_name have a known suffix */
            if ((suffix = strrchr(output_file_name, '.')) != 0 &&
                (!strcmp(suffix, ".c") ||	/* good, old-fashioned C */
                 !strcmp(suffix, ".C") ||	/* C++, or C on Windows */
                 !strcmp(suffix, ".cc") ||	/* C++ */
                 !strcmp(suffix, ".cxx") ||	/* C++ */
                 !strcmp(suffix, ".cpp")))	/* C++ (Windows) */
            {
                strncpy(defines_file_name, output_file_name,
                    suffix - output_file_name + 1);
                defines_file_name[suffix - output_file_name + 1] = 'h';
                defines_file_name[suffix - output_file_name + 2] = '\0';
            } else {
                fprintf(stderr,"%s: suffix of output file name %s"
                    " not recognized, no -d file generated.\n",
                    __progname, output_file_name);
                dflag = 0;
                free(defines_file_name);
                defines_file_name = 0;
            }
d293 4
a296 5
	else
	{
	    if (asprintf(&defines_file_name, "%s%s", file_prefix,
		DEFINES_SUFFIX) == -1)
	        no_space();
a297 8
    }

    if (vflag)
    {
	if (asprintf(&verbose_file_name, "%s%s", file_prefix,
	    VERBOSE_SUFFIX) == -1)
	    no_space();
    }
d304 1
a304 1
    int fd;
d306 1
a306 1
    create_file_names();
d308 36
a343 44
    if (input_file == 0)
    {
	input_file = fopen(input_file_name, "r");
	if (input_file == 0)
	    open_error(input_file_name);
    }

    fd = mkstemp(action_file_name);
    if (fd == -1 || (action_file = fdopen(fd, "w")) == NULL)
	open_error(action_file_name);

    fd = mkstemp(text_file_name);
    if (fd == -1 || (text_file = fdopen(fd, "w")) == NULL)
	open_error(text_file_name);

    if (vflag)
    {
	verbose_file = fopen(verbose_file_name, "w");
	if (verbose_file == 0)
	    open_error(verbose_file_name);
    }

    if (dflag)
    {
	defines_file = fopen(defines_file_name, "w");
	if (defines_file == NULL)
	    open_write_error(defines_file_name);
	fd = mkstemp(union_file_name);
	if (fd == -1 || (union_file = fdopen(fd, "w")) == NULL)
	    open_error(union_file_name);
    }

    output_file = fopen(output_file_name, "w");
    if (output_file == 0)
	open_error(output_file_name);

    if (rflag)
    {
	code_file = fopen(code_file_name, "w");
	if (code_file == 0)
	    open_error(code_file_name);
    }
    else
	code_file = output_file;
d350 12
a361 12
    set_signals();
    getargs(argc, argv);
    open_files();
    reader();
    lr0();
    lalr();
    make_parser();
    verbose();
    output();
    done(0);
    /*NOTREACHED*/
    return (0);
@


1.24
log
@Remove CALLOC, MALLOC, FREE and REALLOC macros and just call calloc(),
nalloc(), free() and realloc() directly.  The macros were casting
to the wrong (pre-C89) types and there is no need for them in a C89
world.  OK matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2009/10/27 23:59:50 deraadt Exp $	*/
d216 2
a217 2
char *
allocate(unsigned int n)
d219 1
a219 1
    char *p;
d221 1
a221 1
    p = NULL;
d224 2
a225 2
	p = calloc(1, n);
	if (!p) no_space();
d227 1
a227 1
    return (p);
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2009/05/01 10:41:05 chl Exp $	*/
d224 1
a224 1
	p = CALLOC(1, n);
@


1.22
log
@remove unused function

from tobias@@

ok otto@@ millert@@ gilles@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2008/05/17 23:31:52 sobrado Exp $	*/
a34 14

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1989 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	5.5 (Berkeley) 5/24/93";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.21 2008/05/17 23:31:52 sobrado Exp $";
#endif
#endif /* not lint */
@


1.21
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2005/06/08 03:18:59 pvalchev Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.20 2005/06/08 03:18:59 pvalchev Exp $";
a324 16

FILE *
fsopen(char *name, char *mode)
{
    FILE *fp = NULL;
    int fd, mod = O_RDONLY;

    if (strchr(mode, 'w'))
	mod = O_RDWR;
    if ((fd = open(name, mod | O_EXCL|O_CREAT, 0666)) == -1 ||
	(fp = fdopen(fd, mode)) == NULL) {
	if (fd != -1)
	    close(fd);
    }
    return (fp);
}
@


1.20
log
@add open_write_error() to bail on fopen(3) failing to open for write, gains
more descriptive error messages, eg:
"cannot open target file y.tab.h for writing" as opposed to a generic error.
based on Alexander von Gernler <grunk@@pestilenz.org>, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2005/04/04 13:46:06 robert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 2005/04/04 13:46:06 robert Exp $";
d167 1
a167 1
    fprintf(stderr, "usage: %s [-dlrtv] [-b file_prefix] [-o outputfile] [-p symbol_prefix] filename\n", __progname);
@


1.19
log
@convert to getopt(); ok millert@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2003/06/19 16:34:53 pvalchev Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 2003/06/19 16:34:53 pvalchev Exp $";
d374 2
a375 2
	if (defines_file == 0)
	    open_error(defines_file_name);
@


1.18
log
@ansify; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2003/06/03 02:56:24 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 2003/06/03 02:56:24 millert Exp $";
d175 1
a175 2
    int i;
    char *s;
d177 1
a177 1
    for (i = 1; i < argc; ++i)
d179 1
a179 3
	s = argv[i];
	if (*s != '-') break;
	switch (*++s)
a180 9
	case '\0':
	    input_file = stdin;
	    if (i + 1 < argc) usage();
	    return;

	case '-':
	    ++i;
	    goto no_more_options;

d182 3
a184 8
	    if (*++s)
		 file_prefix = s;
	    else if (++i < argc)
		file_prefix = argv[i];
	    else
		usage();
	    continue;

d194 4
a197 9
            if (*++s)
	        output_file_name = s;
            else if (++i < argc)
                output_file_name = argv[i];
            else
                usage();
            explicit_file_name = 1;
            continue;

d199 3
a201 8
	    if (*++s)
		symbol_prefix = s;
	    else if (++i < argc)
		symbol_prefix = argv[i];
	    else
		usage();
	    continue;

a216 33

	for (;;)
	{
	    switch (*++s)
	    {
	    case '\0':
		goto end_of_option;

	    case 'd':
		dflag = 1;
		break;

	    case 'l':
		lflag = 1;
		break;

	    case 'r':
		rflag = 1;
		break;

	    case 't':
		tflag = 1;
		break;

	    case 'v':
		vflag = 1;
		break;

	    default:
		usage();
	    }
	}
end_of_option:;
d218 2
d221 6
a226 3
no_more_options:;
    if (i + 1 != argc) usage();
    input_file_name = argv[i];
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2003/04/16 17:43:37 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 2003/04/16 17:43:37 millert Exp $";
d124 1
a124 2
done(k)
int k;
d139 1
a139 2
onintr(signo)
	int signo;
d147 1
a147 1
set_signals()
d165 1
a165 1
usage()
d173 1
a173 3
getargs(argc, argv)
int argc;
char *argv[];
d286 1
a286 2
allocate(n)
unsigned n;
d303 1
a303 1
create_file_names()
d382 1
a382 3
fsopen(name, mode)
    char *name;
    char *mode;
d398 1
a398 1
open_files()
d452 1
a452 3
main(argc, argv)
int argc;
char *argv[];
@


1.16
log
@strcpy() removal; based on a patch from henning@@ but simplified
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2002/02/16 21:28:00 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 2002/02/16 21:28:00 millert Exp $";
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2001/11/19 19:02:18 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 2001/11/19 19:02:18 mpech Exp $";
a69 1
char *temp_form = "yacc.XXXXXXXXXXX";
d308 3
d314 1
a314 1
    int i, len;
d317 1
a317 1
    if (!(tmpdir = getenv("TMPDIR")))
d321 2
a322 26
    i = len + strlen(temp_form) + 1;
    if (len && tmpdir[len-1] != '/')
	++i;

    action_file_name = MALLOC(i);
    if (action_file_name == 0) no_space();
    text_file_name = MALLOC(i);
    if (text_file_name == 0) no_space();
    union_file_name = MALLOC(i);
    if (union_file_name == 0) no_space();

    strcpy(action_file_name, tmpdir);
    strcpy(text_file_name, tmpdir);
    strcpy(union_file_name, tmpdir);

    if (len && tmpdir[len - 1] != '/')
    {
	action_file_name[len] = '/';
	text_file_name[len] = '/';
	union_file_name[len] = '/';
	++len;
    }

    strcpy(action_file_name + len, temp_form);
    strcpy(text_file_name + len, temp_form);
    strcpy(union_file_name + len, temp_form);
d324 4
a327 3
    action_file_name[len + 5] = 'a';
    text_file_name[len + 5] = 't';
    union_file_name[len + 5] = 'u';
d329 1
a329 3
    len = strlen(file_prefix);

    if (!output_file_name)
d331 2
a332 2
        output_file_name = MALLOC(len + 7);
        if (output_file_name == 0)
a333 2
        strcpy(output_file_name, file_prefix);
        strcpy(output_file_name + len, OUTPUT_SUFFIX);
d336 2
a337 4
    if (rflag)
    {
	code_file_name = MALLOC(len + 8);
	if (code_file_name == 0)
d339 1
a339 4
	strcpy(code_file_name, file_prefix);
	strcpy(code_file_name + len, CODE_SUFFIX);
    }
    else
d348 1
a348 1
	    defines_file_name = MALLOC(strlen(output_file_name)+1);
a350 1
	    strcpy(defines_file_name, output_file_name);
d375 2
a376 2
	    defines_file_name = MALLOC(len + 7);
	    if (defines_file_name == 0)
a377 2
	    strcpy(defines_file_name, file_prefix);
	    strcpy(defines_file_name + len, DEFINES_SUFFIX);
d383 2
a384 2
	verbose_file_name = MALLOC(len + 8);
	if (verbose_file_name == 0)
a385 2
	strcpy(verbose_file_name, file_prefix);
	strcpy(verbose_file_name + len, VERBOSE_SUFFIX);
@


1.14
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2001/11/07 11:42:53 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 2001/11/07 11:42:53 deraadt Exp $";
d119 6
a124 6
void onintr __P((int));
void set_signals __P((void));
void usage __P((void));
void getargs __P((int, char *[]));
void create_file_names __P((void));
void open_files __P((void));
@


1.13
log
@fix signal race
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2001/07/16 06:29:44 pvalchev Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 2001/07/16 06:29:44 pvalchev Exp $";
d122 1
a122 1
void getargs __P((int, register char *[]));
d184 2
a185 2
    register int i;
    register char *s;
d298 1
a298 1
    register char *p;
@


1.12
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2001/01/19 17:58:22 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 2001/01/19 17:58:22 deraadt Exp $";
d126 2
d132 8
a139 3
    if (action_file) { fclose(action_file); unlink(action_file_name); }
    if (text_file) { fclose(text_file); unlink(text_file_name); }
    if (union_file) { fclose(union_file); unlink(union_file_name); }
d148 2
a149 1
    done(1);	/* XXX signal race */
@


1.11
log
@mark remaining signal races which are difficult to fix, and fix a few partially
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1999/08/04 18:31:26 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1999/08/04 18:31:26 millert Exp $";
d57 1
d59 1
a59 1
#include <signal.h>
d119 8
d145 1
d163 1
d171 1
d301 1
a301 1

d435 1
a435 1

d505 1
@


1.10
log
@o Use __progname
o Use _PATH_TMP
o Use mkstemp() instead of mktemp()
o Really use 10 X's (one is eaten up by a letter)
o Correct manpage wrt temp file name
o Uncomment .Xr yyfix in man page since we ship it now
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1998/05/28 16:48:47 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1998/05/28 16:48:47 deraadt Exp $";
d132 1
a132 1
    done(1);
@


1.9
log
@buf problem with TMPDIR; karls@@inet.no
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1997/11/05 09:36:22 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1997/11/05 09:36:22 deraadt Exp $";
d56 1
d69 1
a69 2
char *myname = "yacc";
char *temp_form = "yacc.XXXXXXXXXX";
d155 1
a155 1
    fprintf(stderr, "usage: %s [-dlrtv] [-b file_prefix] [-o outputfile] [-p symbol_prefix] filename\n", myname);
a166 1
    if (argc > 0) myname = argv[0];
d295 2
a296 2
    tmpdir = getenv("TMPDIR");
    if (tmpdir == 0) tmpdir = "/tmp";
a329 4
    mktemp(action_file_name);
    mktemp(text_file_name);
    mktemp(union_file_name);

d378 1
a378 1
                    myname, output_file_name);
d437 2
a438 2
    action_file = fsopen(action_file_name, "w");
    if (action_file == 0)
d441 2
a442 2
    text_file = fsopen(text_file_name, "w");
    if (text_file == 0)
d457 2
a458 2
	union_file = fsopen(union_file_name, "w");
	if (union_file ==  0)
@


1.8
log
@handle c++ and other languages; buffer underrun; netbsd pr#4392;
fixes from jfw@@jfwhome.funhouse.com
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/04/04 18:41:38 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1997/04/04 18:41:38 deraadt Exp $";
d300 1
a300 1
    i = len + 13;
@


1.7
log
@when mktemp() is hard to fix, use 10 X
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1997/01/14 04:47:08 tholo Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1997/01/14 04:47:08 tholo Exp $";
d361 3
a363 1
	    defines_file_name = MALLOC(strlen(output_file_name));
d367 21
a387 2
	    if (!strcmp(output_file_name + (strlen(output_file_name)-2), ".c"))
	        defines_file_name [strlen(output_file_name)-1] = 'h';
@


1.6
log
@Use <fcntl.h>, not <sys/file.h>.  Approved by Bob Corbett.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/06/26 05:44:38 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1996/06/26 05:44:38 deraadt Exp $";
d69 1
a69 1
char *temp_form = "yacc.XXXXXXX";
@


1.5
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/03/19 03:21:38 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1996/03/19 03:21:38 jtc Exp $";
d55 1
a55 1
#include <sys/file.h>
@


1.4
log
@mktemp open+fdopen
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: main.c,v 1.5 1996/03/19 03:21:38 jtc Exp $";
@


1.3
log
@sync to netbsd 960418
@
text
@d53 3
a116 4
extern char *mktemp();
extern char *getenv();


d388 19
d409 2
d420 1
a420 1
    action_file = fopen(action_file_name, "w");
d424 1
a424 1
    text_file = fopen(text_file_name, "w");
d440 1
a440 1
	union_file = fopen(union_file_name, "w");
@


1.2
log
@Imported from Cygnus byacc, David 'Zoo' Zuhn: add support for a -o
flag, to be command line compatible  with bison, for most FSF programs
that use a parser.
@
text
@d1 44
d46 5
a50 1
static char rcsid[] = "$Id: main.c,v 1.1.1.1 1995/10/18 08:47:05 deraadt Exp $";
d129 2
a130 1
onintr()
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: main.c,v 1.4 1993/12/07 17:46:56 mycroft Exp $";
d22 2
d106 1
a106 1
    fprintf(stderr, "usage: %s [-dlrtv] [-b file_prefix] [-p symbol_prefix] filename\n", myname);
d151 10
d288 8
a295 5
    output_file_name = MALLOC(len + 7);
    if (output_file_name == 0)
	no_space();
    strcpy(output_file_name, file_prefix);
    strcpy(output_file_name + len, OUTPUT_SUFFIX);
d310 17
a326 5
	defines_file_name = MALLOC(len + 7);
	if (defines_file_name == 0)
	    no_space();
	strcpy(defines_file_name, file_prefix);
	strcpy(defines_file_name + len, DEFINES_SUFFIX);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
