head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.18.0.8
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.8
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.11.0.6
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2017.05.25.20.11.03;	author tedu;	state Exp;
branches;
next	1.18;
commitid	z7x0vVP30EN9CXhi;

1.18
date	2015.12.11.20.25.47;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	imdifMlAvt2nFvdW;

1.17
date	2014.05.17.15.19.17;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2014.03.13.01.18.22;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2014.03.08.01.05.39;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.10.11.19.31;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2014.01.09.23.07.50;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2014.01.08.21.40.25;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2012.03.03.19.15.00;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.01.21.21.39;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.19.16.34.53;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.28.00;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.16.06.29.44;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.45.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@fix a variety of warnings. from Brian Callahan
@
text
@/*	$OpenBSD: lalr.c,v 1.18 2015/12/11 20:25:47 mmcc Exp $	*/
/*	$NetBSD: lalr.c,v 1.4 1996/03/19 03:21:33 jtc Exp $	*/

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "defs.h"

typedef struct shorts {
	struct shorts *next;
	short value;
} shorts;

int tokensetsize;
short *lookaheads;
short *LAruleno;
unsigned *LA;
short *accessing_symbol;
core **state_table;
shifts **shift_table;
reductions **reduction_table;
short *goto_map;
short *from_state;
short *to_state;

short **transpose(short **, int);
void set_state_table(void);
void set_accessing_symbol(void);
void set_shift_table(void);
void set_reduction_table(void);
void set_maxrhs(void);
void initialize_LA(void);
void set_goto_map(void);
void initialize_F(void);
void build_relations(void);
void compute_FOLLOWS(void);
void compute_lookaheads(void);
int map_goto(int, int);
void digraph(short **);
void add_lookback_edge(int, int, int);
void traverse(int);

static int infinity;
static int maxrhs;
static int ngotos;
static unsigned *F;
static short **includes;
static shorts **lookback;
static short **R;
static short *INDEX;
static short *VERTICES;
static int top;

void
lalr(void)
{
	tokensetsize = WORDSIZE(ntokens);

	set_state_table();
	set_accessing_symbol();
	set_shift_table();
	set_reduction_table();
	set_maxrhs();
	initialize_LA();
	set_goto_map();
	initialize_F();
	build_relations();
	compute_FOLLOWS();
	compute_lookaheads();
	free_derives();
	free_nullable();
}


void
set_state_table(void)
{
	core *sp;

	state_table = NEW2(nstates, core *);
	for (sp = first_state; sp; sp = sp->next)
		state_table[sp->number] = sp;
}


void
set_accessing_symbol(void)
{
	core *sp;

	accessing_symbol = NEW2(nstates, short);
	for (sp = first_state; sp; sp = sp->next)
		accessing_symbol[sp->number] = sp->accessing_symbol;
}


void
set_shift_table(void)
{
	shifts *sp;

	shift_table = NEW2(nstates, shifts *);
	for (sp = first_shift; sp; sp = sp->next)
		shift_table[sp->number] = sp;
}


void
set_reduction_table(void)
{
	reductions *rp;

	reduction_table = NEW2(nstates, reductions *);
	for (rp = first_reduction; rp; rp = rp->next)
		reduction_table[rp->number] = rp;
}


void
set_maxrhs(void)
{
	short *itemp, *item_end;
	int length, max;

	length = 0;
	max = 0;
	item_end = ritem + nitems;
	for (itemp = ritem; itemp < item_end; itemp++) {
		if (*itemp >= 0) {
			length++;
		} else {
			if (length > max) max = length;
			length = 0;
		}
	}

	maxrhs = max;
}


void
initialize_LA(void)
{
	int i, j, k;
	reductions *rp;

	lookaheads = NEW2(nstates + 1, short);

	k = 0;
	for (i = 0; i < nstates; i++) {
		lookaheads[i] = k;
		rp = reduction_table[i];
		if (rp)
			k += rp->nreds;
	}
	lookaheads[nstates] = k;

	LA = NEW2(k * tokensetsize, unsigned);
	LAruleno = NEW2(k, short);
	lookback = NEW2(k, shorts *);

	k = 0;
	for (i = 0; i < nstates; i++) {
		rp = reduction_table[i];
		if (rp) {
			for (j = 0; j < rp->nreds; j++) {
				LAruleno[k] = rp->rules[j];
				k++;
			}
		}
	}
}

void
set_goto_map(void)
{
	shifts *sp;
	int i, k, symbol;
	int state1, state2;
	short *temp_map;

	goto_map = NEW2(nvars + 1, short) - ntokens;
	temp_map = NEW2(nvars + 1, short) - ntokens;

	ngotos = 0;
	for (sp = first_shift; sp; sp = sp->next) {
		for (i = sp->nshifts - 1; i >= 0; i--) {
			symbol = accessing_symbol[sp->shift[i]];

			if (ISTOKEN(symbol)) break;

			if (ngotos == MAXSHORT)
				fatal("too many gotos");

			ngotos++;
			goto_map[symbol]++;
		}
	}

	k = 0;
	for (i = ntokens; i < nsyms; i++) {
		temp_map[i] = k;
		k += goto_map[i];
	}

	for (i = ntokens; i < nsyms; i++)
		goto_map[i] = temp_map[i];

	goto_map[nsyms] = ngotos;
	temp_map[nsyms] = ngotos;

	from_state = NEW2(ngotos, short);
	to_state = NEW2(ngotos, short);

	for (sp = first_shift; sp; sp = sp->next) {
		state1 = sp->number;
		for (i = sp->nshifts - 1; i >= 0; i--) {
			state2 = sp->shift[i];
			symbol = accessing_symbol[state2];

			if (ISTOKEN(symbol)) break;

			k = temp_map[symbol]++;
			from_state[k] = state1;
			to_state[k] = state2;
		}
	}

	free(temp_map + ntokens);
}



/*  Map_goto maps a state/symbol pair into its numeric representation.	*/

int
map_goto(int state, int symbol)
{
	int high, low, middle, s;

	low = goto_map[symbol];
	high = goto_map[symbol + 1];

	for (;;) {
		assert(low <= high);
		middle = (low + high) >> 1;
		s = from_state[middle];
		if (s == state)
			return (middle);
		else if (s < state)
			low = middle + 1;
		else
			high = middle - 1;
	}
}


void
initialize_F(void)
{
	int i, j, k;
	shifts *sp;
	short *edge, *rp, **reads;
	unsigned int *rowp;
	int nedges, stateno, symbol, nwords;

	nwords = ngotos * tokensetsize;
	F = NEW2(nwords, unsigned);

	reads = NEW2(ngotos, short *);
	edge = NEW2(ngotos + 1, short);
	nedges = 0;

	rowp = F;
	for (i = 0; i < ngotos; i++) {
		stateno = to_state[i];
		sp = shift_table[stateno];

		if (sp) {
			k = sp->nshifts;

			for (j = 0; j < k; j++) {
				symbol = accessing_symbol[sp->shift[j]];
				if (ISVAR(symbol))
					break;
				SETBIT(rowp, symbol);
			}

			for (; j < k; j++) {
				symbol = accessing_symbol[sp->shift[j]];
				if (nullable[symbol])
					edge[nedges++] = map_goto(stateno, symbol);
			}
			
			if (nedges) {
				reads[i] = rp = NEW2(nedges + 1, short);

				for (j = 0; j < nedges; j++)
					rp[j] = edge[j];

				rp[nedges] = -1;
				nedges = 0;
			}
		}

		rowp += tokensetsize;
	}

	SETBIT(F, 0);
	digraph(reads);

	for (i = 0; i < ngotos; i++)
		free(reads[i]);

	free(reads);
	free(edge);
}


void
build_relations(void)
{
	int i, j, k;
	short *rulep, *rp;
	shifts *sp;
	int length, nedges, done;
	int state1, stateno, symbol1, symbol2;
	short *shortp, *edge, *states;
	short **new_includes;

	includes = NEW2(ngotos, short *);
	edge = NEW2(ngotos + 1, short);
	states = NEW2(maxrhs + 1, short);

	for (i = 0; i < ngotos; i++) {
		nedges = 0;
		state1 = from_state[i];
		symbol1 = accessing_symbol[to_state[i]];

		for (rulep = derives[symbol1]; *rulep >= 0; rulep++) {
			length = 1;
			states[0] = state1;
			stateno = state1;

			for (rp = ritem + rrhs[*rulep]; *rp >= 0; rp++) {
				symbol2 = *rp;
				sp = shift_table[stateno];
				k = sp->nshifts;

				for (j = 0; j < k; j++) {
					stateno = sp->shift[j];
					if (accessing_symbol[stateno] == symbol2)
						break;
				}

				states[length++] = stateno;
			}

			add_lookback_edge(stateno, *rulep, i);

			length--;
			done = 0;
			while (!done) {
				done = 1;
				rp--;
				if (ISVAR(*rp)) {
					stateno = states[--length];
					edge[nedges++] = map_goto(stateno, *rp);
					if (nullable[*rp] && length > 0)
						done = 0;
				}
			}
		}

		if (nedges) {
			includes[i] = shortp = NEW2(nedges + 1, short);
			for (j = 0; j < nedges; j++)
				shortp[j] = edge[j];
			shortp[nedges] = -1;
		}
	}

	new_includes = transpose(includes, ngotos);

	for (i = 0; i < ngotos; i++)
		free(includes[i]);

	free(includes);

	includes = new_includes;

	free(edge);
	free(states);
}

void
add_lookback_edge(int stateno, int ruleno, int gotono)
{
	int i, k, found;
	shorts *sp;

	i = lookaheads[stateno];
	k = lookaheads[stateno + 1];
	found = 0;
	while (!found && i < k) {
		if (LAruleno[i] == ruleno)
			found = 1;
		else
			++i;
	}
	assert(found);

	sp = NEW(shorts);
	sp->next = lookback[i];
	sp->value = gotono;
	lookback[i] = sp;
}



short **
transpose(short **old_R, int n)
{
	short **new_R, **temp_R, *nedges, *sp;
	int i, k;

	nedges = NEW2(n, short);

	for (i = 0; i < n; i++) {
		sp = old_R[i];
		if (sp) {
			while (*sp >= 0)
				nedges[*sp++]++;
		}
	}

	new_R = NEW2(n, short *);
	temp_R = NEW2(n, short *);

	for (i = 0; i < n; i++) {
		k = nedges[i];
		if (k > 0) {
			sp = NEW2(k + 1, short);
			new_R[i] = sp;
			temp_R[i] = sp;
			sp[k] = -1;
		}
	}

	free(nedges);

	for (i = 0; i < n; i++) {
		sp = old_R[i];
		if (sp) {
			while (*sp >= 0)
				*temp_R[*sp++]++ = i;
		}
	}

	free(temp_R);

	return (new_R);
}


void
compute_FOLLOWS(void)
{
	digraph(includes);
}

void
compute_lookaheads(void)
{
	int i, n;
	unsigned int *fp1, *fp2, *fp3;
	shorts *sp, *next;
	unsigned int *rowp;

	rowp = LA;
	n = lookaheads[nstates];
	for (i = 0; i < n; i++) {
		fp3 = rowp + tokensetsize;
		for (sp = lookback[i]; sp; sp = sp->next) {
			fp1 = rowp;
			fp2 = F + tokensetsize * sp->value;
			while (fp1 < fp3)
				*fp1++ |= *fp2++;
		}
		rowp = fp3;
	}

	for (i = 0; i < n; i++)
		for (sp = lookback[i]; sp; sp = next) {
			next = sp->next;
			free(sp);
		}

	free(lookback);
	free(F);
}

void
digraph(short **relation)
{
	int i;

	infinity = ngotos + 2;
	INDEX = NEW2(ngotos + 1, short);
	VERTICES = NEW2(ngotos + 1, short);
	top = 0;
	R = relation;

	memset(INDEX, 0, ngotos * sizeof(short));
	for (i = 0; i < ngotos; i++)
		if (R[i])
			traverse(i);

	free(INDEX);
	free(VERTICES);
}


void
traverse(int i)
{
	unsigned int *base, *fp1, *fp2, *fp3;
	int j, height;
	short *rp;

	VERTICES[++top] = i;
	INDEX[i] = height = top;

	base = F + i * tokensetsize;
	fp3 = base + tokensetsize;

	rp = R[i];
	if (rp) {
		while ((j = *rp++) >= 0) {
			if (INDEX[j] == 0)
				traverse(j);

			if (INDEX[i] > INDEX[j])
				INDEX[i] = INDEX[j];

			fp1 = base;
			fp2 = F + j * tokensetsize;

			while (fp1 < fp3)
				*fp1++ |= *fp2++;
		}
	}

	if (INDEX[i] == height) {
		for (;;) {
			j = VERTICES[top--];
			INDEX[j] = infinity;

			if (i == j)
				break;

			fp1 = base;
			fp2 = F + j * tokensetsize;

			while (fp1 < fp3)
				*fp2++ = *fp1++;
		}
	}
}
@


1.18
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.17 2014/05/17 15:19:17 chl Exp $	*/
d55 1
a55 1
short **transpose();
d451 1
a451 1
transpose(short **R, int n)
d459 1
a459 1
		sp = R[i];
d482 1
a482 1
		sp = R[i];
@


1.17
log
@remove unused variable

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.16 2014/03/13 01:18:22 tedu Exp $	*/
d341 2
a342 4
	for (i = 0; i < ngotos; i++) {
		if (reads[i])
			free(reads[i]);
	}
d415 1
a415 2
		if (includes[i])
			free(includes[i]);
@


1.16
log
@collapse variable declarations
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.15 2014/03/08 01:05:39 tedu Exp $	*/
d207 1
a207 1
	int i, j, k, symbol;
@


1.15
log
@reindent
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.14 2014/01/10 11:19:31 sthen Exp $	*/
d151 2
a152 4
	short *itemp;
	short *item_end;
	int length;
	int max;
d207 2
a208 3
	int i;
	int symbol;
	int k;
a209 2
	int state2;
	int state1;
d268 1
a268 4
	int high;
	int low;
	int middle;
	int s;
d290 1
a290 3
	int i;
	int j;
	int k;
d292 3
a294 8
	short *edge;
	unsigned *rowp;
	short *rp;
	short **reads;
	int nedges;
	int stateno;
	int symbol;
	int nwords;
d354 2
a355 5
	int i;
	int j;
	int k;
	short *rulep;
	short *rp;
d357 3
a359 10
	int length;
	int nedges;
	int done;
	int state1;
	int stateno;
	int symbol1;
	int symbol2;
	short *shortp;
	short *edge;
	short *states;
d431 1
a431 2
	int i, k;
	int found;
d456 2
a457 6
	short **new_R;
	short **temp_R;
	short *nedges;
	short *sp;
	int i;
	int k;
d508 1
a508 1
	unsigned *fp1, *fp2, *fp3;
d510 1
a510 1
	unsigned *rowp;
d559 2
a560 4
	unsigned *fp1;
	unsigned *fp2;
	unsigned *fp3;
	int j;
a561 3

	int height;
	unsigned *base;
@


1.14
log
@revert previous; height is never changed, but top is changed.
ok espie@@ who saw intermittent sigbus in ports/math/hc with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.12 2014/01/08 21:40:25 millert Exp $	*/
d38 4
a41 7
typedef
  struct shorts
    {
      struct shorts *next;
      short value;
    }
  shorts;
d86 1
a86 1
    tokensetsize = WORDSIZE(ntokens);
d88 13
a100 13
    set_state_table();
    set_accessing_symbol();
    set_shift_table();
    set_reduction_table();
    set_maxrhs();
    initialize_LA();
    set_goto_map();
    initialize_F();
    build_relations();
    compute_FOLLOWS();
    compute_lookaheads();
    free_derives();
    free_nullable();
d107 1
a107 1
    core *sp;
d109 3
a111 3
    state_table = NEW2(nstates, core *);
    for (sp = first_state; sp; sp = sp->next)
	state_table[sp->number] = sp;
d118 1
a118 1
    core *sp;
d120 3
a122 3
    accessing_symbol = NEW2(nstates, short);
    for (sp = first_state; sp; sp = sp->next)
	accessing_symbol[sp->number] = sp->accessing_symbol;
d129 1
a129 1
    shifts *sp;
d131 3
a133 3
    shift_table = NEW2(nstates, shifts *);
    for (sp = first_shift; sp; sp = sp->next)
	shift_table[sp->number] = sp;
d140 1
a140 1
    reductions *rp;
d142 3
a144 3
    reduction_table = NEW2(nstates, reductions *);
    for (rp = first_reduction; rp; rp = rp->next)
	reduction_table[rp->number] = rp;
d151 15
a165 18
  short *itemp;
  short *item_end;
  int length;
  int max;

  length = 0;
  max = 0;
  item_end = ritem + nitems;
  for (itemp = ritem; itemp < item_end; itemp++)
    {
      if (*itemp >= 0)
	{
	  length++;
	}
      else
	{
	  if (length > max) max = length;
	  length = 0;
a166 1
    }
d168 1
a168 1
  maxrhs = max;
d175 2
a176 2
  int i, j, k;
  reductions *rp;
d178 1
a178 1
  lookaheads = NEW2(nstates + 1, short);
d180 22
a201 25
  k = 0;
  for (i = 0; i < nstates; i++)
    {
      lookaheads[i] = k;
      rp = reduction_table[i];
      if (rp)
	k += rp->nreds;
    }
  lookaheads[nstates] = k;

  LA = NEW2(k * tokensetsize, unsigned);
  LAruleno = NEW2(k, short);
  lookback = NEW2(k, shorts *);

  k = 0;
  for (i = 0; i < nstates; i++)
    {
      rp = reduction_table[i];
      if (rp)
	{
	  for (j = 0; j < rp->nreds; j++)
	    {
	      LAruleno[k] = rp->rules[j];
	      k++;
	    }
a202 1
    }
d208 53
a260 57
  shifts *sp;
  int i;
  int symbol;
  int k;
  short *temp_map;
  int state2;
  int state1;

  goto_map = NEW2(nvars + 1, short) - ntokens;
  temp_map = NEW2(nvars + 1, short) - ntokens;

  ngotos = 0;
  for (sp = first_shift; sp; sp = sp->next)
    {
      for (i = sp->nshifts - 1; i >= 0; i--)
	{
	  symbol = accessing_symbol[sp->shift[i]];

	  if (ISTOKEN(symbol)) break;

	  if (ngotos == MAXSHORT)
	    fatal("too many gotos");

	  ngotos++;
	  goto_map[symbol]++;
        }
    }

  k = 0;
  for (i = ntokens; i < nsyms; i++)
    {
      temp_map[i] = k;
      k += goto_map[i];
    }

  for (i = ntokens; i < nsyms; i++)
    goto_map[i] = temp_map[i];

  goto_map[nsyms] = ngotos;
  temp_map[nsyms] = ngotos;

  from_state = NEW2(ngotos, short);
  to_state = NEW2(ngotos, short);

  for (sp = first_shift; sp; sp = sp->next)
    {
      state1 = sp->number;
      for (i = sp->nshifts - 1; i >= 0; i--)
	{
	  state2 = sp->shift[i];
	  symbol = accessing_symbol[state2];

	  if (ISTOKEN(symbol)) break;

	  k = temp_map[symbol]++;
	  from_state[k] = state1;
	  to_state[k] = state2;
a261 1
    }
d263 1
a263 1
  free(temp_map + ntokens);
d273 19
a291 20
    int high;
    int low;
    int middle;
    int s;

    low = goto_map[symbol];
    high = goto_map[symbol + 1];

    for (;;)
    {
	assert(low <= high);
	middle = (low + high) >> 1;
	s = from_state[middle];
	if (s == state)
	    return (middle);
	else if (s < state)
	    low = middle + 1;
	else
	    high = middle - 1;
    }
d298 51
a348 68
  int i;
  int j;
  int k;
  shifts *sp;
  short *edge;
  unsigned *rowp;
  short *rp;
  short **reads;
  int nedges;
  int stateno;
  int symbol;
  int nwords;

  nwords = ngotos * tokensetsize;
  F = NEW2(nwords, unsigned);

  reads = NEW2(ngotos, short *);
  edge = NEW2(ngotos + 1, short);
  nedges = 0;

  rowp = F;
  for (i = 0; i < ngotos; i++)
    {
      stateno = to_state[i];
      sp = shift_table[stateno];

      if (sp)
	{
	  k = sp->nshifts;

	  for (j = 0; j < k; j++)
	    {
	      symbol = accessing_symbol[sp->shift[j]];
	      if (ISVAR(symbol))
		break;
	      SETBIT(rowp, symbol);
	    }

	  for (; j < k; j++)
	    {
	      symbol = accessing_symbol[sp->shift[j]];
	      if (nullable[symbol])
		edge[nedges++] = map_goto(stateno, symbol);
	    }
	
	  if (nedges)
	    {
	      reads[i] = rp = NEW2(nedges + 1, short);

	      for (j = 0; j < nedges; j++)
		rp[j] = edge[j];

	      rp[nedges] = -1;
	      nedges = 0;
	    }
	}

      rowp += tokensetsize;
    }

  SETBIT(F, 0);
  digraph(reads);

  for (i = 0; i < ngotos; i++)
    {
      if (reads[i])
	free(reads[i]);
    }
d350 13
a362 2
  free(reads);
  free(edge);
d369 61
a429 80
  int i;
  int j;
  int k;
  short *rulep;
  short *rp;
  shifts *sp;
  int length;
  int nedges;
  int done;
  int state1;
  int stateno;
  int symbol1;
  int symbol2;
  short *shortp;
  short *edge;
  short *states;
  short **new_includes;

  includes = NEW2(ngotos, short *);
  edge = NEW2(ngotos + 1, short);
  states = NEW2(maxrhs + 1, short);

  for (i = 0; i < ngotos; i++)
    {
      nedges = 0;
      state1 = from_state[i];
      symbol1 = accessing_symbol[to_state[i]];

      for (rulep = derives[symbol1]; *rulep >= 0; rulep++)
	{
	  length = 1;
	  states[0] = state1;
	  stateno = state1;

	  for (rp = ritem + rrhs[*rulep]; *rp >= 0; rp++)
	    {
	      symbol2 = *rp;
	      sp = shift_table[stateno];
	      k = sp->nshifts;

	      for (j = 0; j < k; j++)
		{
		  stateno = sp->shift[j];
		  if (accessing_symbol[stateno] == symbol2) break;
		}

	      states[length++] = stateno;
	    }

	  add_lookback_edge(stateno, *rulep, i);

	  length--;
	  done = 0;
	  while (!done)
	    {
	      done = 1;
	      rp--;
	      if (ISVAR(*rp))
		{
		  stateno = states[--length];
		  edge[nedges++] = map_goto(stateno, *rp);
		  if (nullable[*rp] && length > 0) done = 0;
		}
	    }
	}

      if (nedges)
	{
	  includes[i] = shortp = NEW2(nedges + 1, short);
	  for (j = 0; j < nedges; j++)
	    shortp[j] = edge[j];
	  shortp[nedges] = -1;
	}
    }

  new_includes = transpose(includes, ngotos);

  for (i = 0; i < ngotos; i++)
    if (includes[i])
      free(includes[i]);
d431 9
a439 1
  free(includes);
d441 3
a443 1
  includes = new_includes;
d445 6
a450 2
  free(edge);
  free(states);
d456 19
a474 20
    int i, k;
    int found;
    shorts *sp;

    i = lookaheads[stateno];
    k = lookaheads[stateno + 1];
    found = 0;
    while (!found && i < k)
    {
	if (LAruleno[i] == ruleno)
	    found = 1;
	else
	    ++i;
    }
    assert(found);

    sp = NEW(shorts);
    sp->next = lookback[i];
    sp->value = gotono;
    lookback[i] = sp;
d482 38
a519 43
  short **new_R;
  short **temp_R;
  short *nedges;
  short *sp;
  int i;
  int k;

  nedges = NEW2(n, short);

  for (i = 0; i < n; i++)
    {
      sp = R[i];
      if (sp)
	{
	  while (*sp >= 0)
	    nedges[*sp++]++;
	}
    }

  new_R = NEW2(n, short *);
  temp_R = NEW2(n, short *);

  for (i = 0; i < n; i++)
    {
      k = nedges[i];
      if (k > 0)
	{
	  sp = NEW2(k + 1, short);
	  new_R[i] = sp;
	  temp_R[i] = sp;
	  sp[k] = -1;
	}
    }

  free(nedges);

  for (i = 0; i < n; i++)
    {
      sp = R[i];
      if (sp)
	{
	  while (*sp >= 0)
	    *temp_R[*sp++]++ = i;
a520 1
    }
d522 1
a522 1
  free(temp_R);
d524 1
a524 1
  return (new_R);
d531 1
a531 1
  digraph(includes);
d537 23
a559 26
  int i, n;
  unsigned *fp1, *fp2, *fp3;
  shorts *sp, *next;
  unsigned *rowp;

  rowp = LA;
  n = lookaheads[nstates];
  for (i = 0; i < n; i++)
    {
      fp3 = rowp + tokensetsize;
      for (sp = lookback[i]; sp; sp = sp->next)
	{
	  fp1 = rowp;
	  fp2 = F + tokensetsize * sp->value;
	  while (fp1 < fp3)
	    *fp1++ |= *fp2++;
	}
      rowp = fp3;
    }

  for (i = 0; i < n; i++)
    for (sp = lookback[i]; sp; sp = next)
      {
        next = sp->next;
        free(sp);
      }
d561 2
a562 2
  free(lookback);
  free(F);
d568 1
a568 1
  int i;
d570 10
a579 10
  infinity = ngotos + 2;
  INDEX = NEW2(ngotos + 1, short);
  VERTICES = NEW2(ngotos + 1, short);
  top = 0;
  R = relation;

  memset(INDEX, 0, ngotos * sizeof(short));
  for (i = 0; i < ngotos; i++)
      if (R[i])
          traverse(i);
d581 2
a582 2
  free(INDEX);
  free(VERTICES);
d589 20
a608 5
  unsigned *fp1;
  unsigned *fp2;
  unsigned *fp3;
  int j;
  short *rp;
d610 2
a611 2
  int height;
  unsigned *base;
d613 2
a614 2
  VERTICES[++top] = i;
  INDEX[i] = height = top;
d616 3
a618 19
  base = F + i * tokensetsize;
  fp3 = base + tokensetsize;

  rp = R[i];
  if (rp)
    {
      while ((j = *rp++) >= 0)
	{
	  if (INDEX[j] == 0)
	    traverse(j);

	  if (INDEX[i] > INDEX[j])
	    INDEX[i] = INDEX[j];

	  fp1 = base;
	  fp2 = F + j * tokensetsize;

	  while (fp1 < fp3)
	    *fp1++ |= *fp2++;
a619 1
    }
d621 4
a624 6
  if (INDEX[i] == height)
    {
      for (;;)
	{
	  j = VERTICES[top--];
	  INDEX[j] = infinity;
d626 2
a627 2
	  if (i == j)
	    break;
d629 2
a630 2
	  fp1 = base;
	  fp2 = F + j * tokensetsize;
d632 3
a634 2
	  while (fp1 < fp3)
	    *fp2++ = *fp1++;
a635 1
    }
@


1.13
log
@Remove useless variable "height" in function traverse().  It is
assigned the value of "top" but never changed so just use top instead.
From Michael W. Bombardieri
@
text
@d632 2
d637 1
a637 1
  INDEX[i] = top;
d661 1
a661 1
  if (INDEX[i] == top)
@


1.12
log
@Remove CALLOC, MALLOC, FREE and REALLOC macros and just call calloc(),
nalloc(), free() and realloc() directly.  The macros were casting
to the wrong (pre-C89) types and there is no need for them in a C89
world.  OK matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.11 2012/03/03 19:15:00 nicm Exp $	*/
a631 2

  int height;
d635 1
a635 1
  INDEX[i] = height = top;
d659 1
a659 1
  if (INDEX[i] == height)
@


1.11
log
@Replace some loops with calloc/memset. From Michael W Bombardieri.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.10 2011/04/01 21:21:39 nicm Exp $	*/
d279 1
a279 1
  FREE(temp_map + ntokens);
d381 1
a381 1
	FREE(reads[i]);
d384 2
a385 2
  FREE(reads);
  FREE(edge);
d471 1
a471 1
      FREE(includes[i]);
d473 1
a473 1
  FREE(includes);
d477 2
a478 2
  FREE(edge);
  FREE(states);
d545 1
a545 1
  FREE(nedges);
d557 1
a557 1
  FREE(temp_R);
d596 1
a596 1
        FREE(sp);
d599 2
a600 2
  FREE(lookback);
  FREE(F);
d619 2
a620 2
  FREE(INDEX);
  FREE(VERTICES);
@


1.10
log
@Add calls to some existing but previously unused free functions. Also
replace a loop with a memset. From Michael W Bombardieri.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.9 2009/10/27 23:59:50 deraadt Exp $	*/
a611 1

d614 1
d616 2
a617 7
    INDEX[i] = 0;

  for (i = 0; i < ngotos; i++)
    {
      if (INDEX[i] == 0 && R[i])
	traverse(i);
    }
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.8 2003/06/19 16:34:53 pvalchev Exp $	*/
d102 2
@


1.8
log
@ansify; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.7 2003/06/03 02:56:24 millert Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)lalr.c	5.3 (Berkeley) 6/1/90";
#else
static char rcsid[] = "$OpenBSD: lalr.c,v 1.7 2003/06/03 02:56:24 millert Exp $";
#endif
#endif /* not lint */
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.6 2002/02/16 21:28:00 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: lalr.c,v 1.6 2002/02/16 21:28:00 millert Exp $";
d95 1
a95 1
lalr()
d114 1
a114 1
set_state_table()
d125 1
a125 1
set_accessing_symbol()
d136 1
a136 1
set_shift_table()
d147 1
a147 1
set_reduction_table()
d158 1
a158 1
set_maxrhs()
d186 1
a186 1
initialize_LA()
d223 1
a223 1
set_goto_map()
d293 1
a293 3
map_goto(state, symbol)
int state;
int symbol;
d319 1
a319 1
initialize_F()
d396 1
a396 1
build_relations()
d488 1
a488 2
add_lookback_edge(stateno, ruleno, gotono)
int stateno, ruleno, gotono;
d515 1
a515 3
transpose(R, n)
short **R;
int n;
d570 1
a570 1
compute_FOLLOWS()
d576 1
a576 1
compute_lookaheads()
d610 1
a610 2
digraph(relation)
short **relation;
d636 1
a636 2
traverse(i)
int i;
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.5 2001/11/19 19:02:18 mpech Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: lalr.c,v 1.5 2001/11/19 19:02:18 mpech Exp $";
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.4 2001/07/16 06:29:44 pvalchev Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: lalr.c,v 1.4 2001/07/16 06:29:44 pvalchev Exp $";
d71 15
a85 15
void set_state_table __P((void));
void set_accessing_symbol __P((void));
void set_shift_table __P((void));
void set_reduction_table __P((void));
void set_maxrhs __P((void));
void initialize_LA __P((void));
void set_goto_map __P((void));
void initialize_F __P((void));
void build_relations __P((void));
void compute_FOLLOWS __P((void));
void compute_lookaheads __P((void));
int map_goto __P((int, int));
void digraph __P((short **));
void add_lookback_edge __P((int, int, int));
void traverse __P((int));
@


1.4
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.3 1996/06/26 05:44:37 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: lalr.c,v 1.3 1996/06/26 05:44:37 deraadt Exp $";
d120 1
a120 1
    register core *sp;
d131 1
a131 1
    register core *sp;
d142 1
a142 1
    register shifts *sp;
d153 1
a153 1
    register reductions *rp;
d164 4
a167 4
  register short *itemp;
  register short *item_end;
  register int length;
  register int max;
d192 2
a193 2
  register int i, j, k;
  register reductions *rp;
d229 7
a235 7
  register shifts *sp;
  register int i;
  register int symbol;
  register int k;
  register short *temp_map;
  register int state2;
  register int state1;
d301 4
a304 4
    register int high;
    register int low;
    register int middle;
    register int s;
d327 12
a338 12
  register int i;
  register int j;
  register int k;
  register shifts *sp;
  register short *edge;
  register unsigned *rowp;
  register short *rp;
  register short **reads;
  register int nedges;
  register int stateno;
  register int symbol;
  register int nwords;
d404 17
a420 17
  register int i;
  register int j;
  register int k;
  register short *rulep;
  register short *rp;
  register shifts *sp;
  register int length;
  register int nedges;
  register int done;
  register int state1;
  register int stateno;
  register int symbol1;
  register int symbol2;
  register short *shortp;
  register short *edge;
  register short *states;
  register short **new_includes;
d497 3
a499 3
    register int i, k;
    register int found;
    register shorts *sp;
d526 6
a531 6
  register short **new_R;
  register short **temp_R;
  register short *nedges;
  register short *sp;
  register int i;
  register int k;
d587 4
a590 4
  register int i, n;
  register unsigned *fp1, *fp2, *fp3;
  register shorts *sp, *next;
  register unsigned *rowp;
d622 1
a622 1
  register int i;
d647 1
a647 1
register int i;
d649 5
a653 5
  register unsigned *fp1;
  register unsigned *fp2;
  register unsigned *fp3;
  register int j;
  register short *rp;
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: lalr.c,v 1.4 1996/03/19 03:21:33 jtc Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: lalr.c,v 1.4 1996/03/19 03:21:33 jtc Exp $";
d71 15
d98 1
a98 1

d117 1
a117 1

d128 1
a128 1

d139 1
a139 1

d150 1
a150 1

d161 1
a161 1

d189 1
a189 1

d226 1
a226 1

d324 1
a324 1

d401 1
a401 1

d493 1
a493 1

d578 1
a578 1

d584 1
a584 1

d618 1
a618 1

d645 1
a645 1

@


1.2
log
@sync to netbsd 960418
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: lalr.c,v 1.4 1996/03/19 03:21:33 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 38
d40 5
a44 1
static char rcsid[] = "$Id: lalr.c,v 1.3 1993/08/02 17:56:38 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
