head	1.15;
access;
symbols
	OPENBSD_6_1:1.14.0.12
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.8
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.20
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.16
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.14
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.12
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.10
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.8
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.05.25.20.11.03;	author tedu;	state Exp;
branches;
next	1.14;
commitid	z7x0vVP30EN9CXhi;

1.14
date	2014.12.02.15.56.22;	author millert;	state Exp;
branches;
next	1.13;
commitid	fTMubrWaxIK4TBKX;

1.13
date	2014.03.13.01.18.22;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.03.08.00.44.14;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.08.21.40.25;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2012.05.30.13.12.39;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.06.10.16.40.45;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.19.16.34.53;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.16.06.29.43;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.45.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@fix a variety of warnings. from Brian Callahan
@
text
@/*	$OpenBSD: closure.c,v 1.14 2014/12/02 15:56:22 millert Exp $	*/
/*	$NetBSD: closure.c,v 1.4 1996/03/19 03:21:29 jtc Exp $	*/

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "defs.h"

short *itemset;
short *itemsetend;
unsigned *ruleset;

static unsigned *first_derives;
static unsigned *EFF;


#ifdef	DEBUG

static void
print_closure(int n)
{
	short *isp;

	printf("\n\nn = %d\n\n", n);
	for (isp = itemset; isp < itemsetend; isp++)
		printf("   %d\n", *isp);
}

static void
print_EFF(void)
{
	int i, j;
	unsigned int *rowp;
	unsigned int k, word;

	printf("\n\nEpsilon Free Firsts\n");

	for (i = start_symbol; i < nsyms; i++) {
		printf("\n%s", symbol_name[i]);
		rowp = EFF + ((i - start_symbol) * WORDSIZE(nvars));
		word = *rowp++;

		k = BITS_PER_WORD;
		for (j = 0; j < nvars; k++, j++) {
			if (k >= BITS_PER_WORD) {
				word = *rowp++;
				k = 0;
			}

			if (word & (1 << k))
				printf("  %s", symbol_name[start_symbol + j]);
		}
	}
}

static void
print_first_derives(void)
{
	int i, j;
	unsigned int *rp;
	unsigned int k, cword = 0;

	printf("\n\n\nFirst Derives\n");

	for (i = start_symbol; i < nsyms; i++) {
		printf("\n%s derives\n", symbol_name[i]);
		rp = first_derives + i * WORDSIZE(nrules);
		k = BITS_PER_WORD;
		for (j = 0; j <= nrules; k++, j++) {
			if (k >= BITS_PER_WORD) {
				cword = *rp++;
				k = 0;
			}

			if (cword & (1 << k))
				printf("   %d\n", j);
		}
	}

	fflush(stdout);
}

#endif


static void
set_EFF(void)
{
	unsigned int *row;
	int symbol, rowsize, i, rule;
	short *sp;

	rowsize = WORDSIZE(nvars);
	EFF = NEW2(nvars * rowsize, unsigned);

	row = EFF;
	for (i = start_symbol; i < nsyms; i++) {
		sp = derives[i];
		for (rule = *sp; rule > 0; rule = *++sp) {
			symbol = ritem[rrhs[rule]];
			if (ISVAR(symbol)) {
				symbol -= start_symbol;
				SETBIT(row, symbol);
			}
		}
		row += rowsize;
	}

	reflexive_transitive_closure(EFF, nvars);

#ifdef	DEBUG
	print_EFF();
#endif
}


void
set_first_derives(void)
{
	unsigned int *rrow, *vrow;
	unsigned int k, cword = 0;
	int i, j, rule, rulesetsize, varsetsize;
	short *rp;

	rulesetsize = WORDSIZE(nrules);
	varsetsize = WORDSIZE(nvars);
	first_derives = NEW2(nvars * rulesetsize, unsigned) - ntokens * rulesetsize;

	set_EFF();

	rrow = first_derives + ntokens * rulesetsize;
	for (i = start_symbol; i < nsyms; i++) {
		vrow = EFF + ((i - ntokens) * varsetsize);
		k = BITS_PER_WORD;
		for (j = start_symbol; j < nsyms; k++, j++) {
			if (k >= BITS_PER_WORD) {
				cword = *vrow++;
				k = 0;
			}

			if (cword & (1 << k)) {
				rp = derives[j];
				while ((rule = *rp++) >= 0) {
					SETBIT(rrow, rule);
				}
			}
		}
		rrow += rulesetsize;
	}

#ifdef	DEBUG
	print_first_derives();
#endif

	free(EFF);
}


void
closure(short *nucleus, int n)
{
	unsigned int i, word;
	short *csp, *csend;
	unsigned int *dsp, *rsp, *rsend;
	int rulesetsize;
	int ruleno, symbol, itemno;

	rulesetsize = WORDSIZE(nrules);
	rsend = ruleset + rulesetsize;
	memset(ruleset, 0, rulesetsize * sizeof(*ruleset));

	csend = nucleus + n;
	for (csp = nucleus; csp < csend; ++csp) {
		symbol = ritem[*csp];
		if (ISVAR(symbol)) {
			dsp = first_derives + symbol * rulesetsize;
			rsp = ruleset;
			while (rsp < rsend)
				*rsp++ |= *dsp++;
		}
	}

	ruleno = 0;
	itemsetend = itemset;
	csp = nucleus;
	for (rsp = ruleset; rsp < rsend; ++rsp) {
		word = *rsp;
		if (word) {
			for (i = 0; i < BITS_PER_WORD; ++i) {
				if (word & (1 << i)) {
					itemno = rrhs[ruleno+i];
					while (csp < csend && *csp < itemno)
						*itemsetend++ = *csp++;
					*itemsetend++ = itemno;
					while (csp < csend && *csp == itemno)
						++csp;
				}
			}
		}
		ruleno += BITS_PER_WORD;
	}

	while (csp < csend)
		*itemsetend++ = *csp++;

#ifdef	DEBUG
  print_closure(n);
#endif
}



void
finalize_closure(void)
{
	free(itemset);
	free(ruleset);
	free(first_derives + ntokens * WORDSIZE(nrules));
}
@


1.14
log
@Remove dead stores found by llvm checker and mark functions that
call done() as __dead to avoid false positives.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.13 2014/03/13 01:18:22 tedu Exp $	*/
d46 70
a115 1
void
a248 69


#ifdef	DEBUG

void
print_closure(int n)
{
	short *isp;

	printf("\n\nn = %d\n\n", n);
	for (isp = itemset; isp < itemsetend; isp++)
		printf("   %d\n", *isp);
}

void
print_EFF(void)
{
	int i, j;
	unsigned int *rowp;
	unsigned int k, word;

	printf("\n\nEpsilon Free Firsts\n");

	for (i = start_symbol; i < nsyms; i++) {
		printf("\n%s", symbol_name[i]);
		rowp = EFF + ((i - start_symbol) * WORDSIZE(nvars));
		word = *rowp++;

		k = BITS_PER_WORD;
		for (j = 0; j < nvars; k++, j++) {
			if (k >= BITS_PER_WORD) {
				word = *rowp++;
				k = 0;
			}

			if (word & (1 << k))
				printf("  %s", symbol_name[start_symbol + j]);
		}
	}
}

void
print_first_derives(void)
{
	int i, j;
	unsigned int *rp;
	unsigned int k, cword = 0;

	printf("\n\n\nFirst Derives\n");

	for (i = start_symbol; i < nsyms; i++) {
		printf("\n%s derives\n", symbol_name[i]);
		rp = first_derives + i * WORDSIZE(nrules);
		k = BITS_PER_WORD;
		for (j = 0; j <= nrules; k++, j++) {
			if (k >= BITS_PER_WORD) {
				cword = *rp++;
				k = 0;
			}

			if (cword & (1 << k))
				printf("   %d\n", j);
		}
	}

	fflush(stdout);
}

#endif
@


1.13
log
@collapse variable declarations
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.12 2014/03/08 00:44:14 tedu Exp $	*/
a107 2

		vrow += varsetsize;
@


1.12
log
@reindent
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.11 2014/01/08 21:40:25 millert Exp $	*/
d49 2
a50 2
	unsigned *row;
	int symbol;
a51 3
	int rowsize;
	int i;
	int rule;
d80 3
a82 5
	unsigned *rrow;
	unsigned *vrow;
	int j;
	unsigned k;
	unsigned cword = 0;
a84 5
	int rule;
	int i;
	int rulesetsize;
	int varsetsize;

d124 3
a126 6
	int ruleno;
	unsigned word;
	unsigned i;
	short *csp;
	unsigned *dsp;
	unsigned *rsp;
d128 1
a128 5

	short *csend;
	unsigned *rsend;
	int symbol;
	int itemno;
d200 2
a201 3
	unsigned *rowp;
	unsigned word;
	unsigned k;
d226 3
a228 5
	int i;
	int j;
	unsigned *rp;
	unsigned cword = 0;
	unsigned k;
@


1.11
log
@Remove CALLOC, MALLOC, FREE and REALLOC macros and just call calloc(),
nalloc(), free() and realloc() directly.  The macros were casting
to the wrong (pre-C89) types and there is no need for them in a C89
world.  OK matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.10 2012/05/30 13:12:39 nicm Exp $	*/
d49 21
a69 22
    unsigned *row;
    int symbol;
    short *sp;
    int rowsize;
    int i;
    int rule;

    rowsize = WORDSIZE(nvars);
    EFF = NEW2(nvars * rowsize, unsigned);

    row = EFF;
    for (i = start_symbol; i < nsyms; i++)
    {
	sp = derives[i];
	for (rule = *sp; rule > 0; rule = *++sp)
	{
	    symbol = ritem[rrhs[rule]];
	    if (ISVAR(symbol))
	    {
		symbol -= start_symbol;
		SETBIT(row, symbol);
	    }
a70 2
	row += rowsize;
    }
d72 1
a72 1
    reflexive_transitive_closure(EFF, nvars);
d75 1
a75 1
    print_EFF();
d83 34
a116 37
    unsigned *rrow;
    unsigned *vrow;
    int j;
    unsigned k;
    unsigned cword = 0;
    short *rp;

    int rule;
    int i;
    int rulesetsize;
    int varsetsize;

    rulesetsize = WORDSIZE(nrules);
    varsetsize = WORDSIZE(nvars);
    first_derives = NEW2(nvars * rulesetsize, unsigned) - ntokens * rulesetsize;

    set_EFF();

    rrow = first_derives + ntokens * rulesetsize;
    for (i = start_symbol; i < nsyms; i++)
    {
	vrow = EFF + ((i - ntokens) * varsetsize);
	k = BITS_PER_WORD;
	for (j = start_symbol; j < nsyms; k++, j++)
	{
	    if (k >= BITS_PER_WORD)
	    {
		cword = *vrow++;
		k = 0;
	    }

	    if (cword & (1 << k))
	    {
		rp = derives[j];
		while ((rule = *rp++) >= 0)
		{
		    SETBIT(rrow, rule);
d118 3
a120 1
	    }
a122 4
	vrow += varsetsize;
	rrow += rulesetsize;
    }

d124 1
a124 1
    print_first_derives();
d127 1
a127 1
    free(EFF);
d134 26
a159 27
    int ruleno;
    unsigned word;
    unsigned i;
    short *csp;
    unsigned *dsp;
    unsigned *rsp;
    int rulesetsize;

    short *csend;
    unsigned *rsend;
    int symbol;
    int itemno;

    rulesetsize = WORDSIZE(nrules);
    rsend = ruleset + rulesetsize;
    memset(ruleset, 0, rulesetsize * sizeof(*ruleset));

    csend = nucleus + n;
    for (csp = nucleus; csp < csend; ++csp)
    {
	symbol = ritem[*csp];
	if (ISVAR(symbol))
	{
	    dsp = first_derives + symbol * rulesetsize;
	    rsp = ruleset;
	    while (rsp < rsend)
		*rsp++ |= *dsp++;
a160 1
    }
d162 16
a177 18
    ruleno = 0;
    itemsetend = itemset;
    csp = nucleus;
    for (rsp = ruleset; rsp < rsend; ++rsp)
    {
	word = *rsp;
	if (word)
	{
	    for (i = 0; i < BITS_PER_WORD; ++i)
	    {
		if (word & (1 << i))
		{
		    itemno = rrhs[ruleno+i];
		    while (csp < csend && *csp < itemno)
			*itemsetend++ = *csp++;
		    *itemsetend++ = itemno;
		    while (csp < csend && *csp == itemno)
			++csp;
d179 1
a179 1
	    }
a180 2
	ruleno += BITS_PER_WORD;
    }
d182 2
a183 2
    while (csp < csend)
	*itemsetend++ = *csp++;
d195 3
a197 3
  free(itemset);
  free(ruleset);
  free(first_derives + ntokens * WORDSIZE(nrules));
d206 1
a206 1
  short *isp;
d208 3
a210 3
  printf("\n\nn = %d\n\n", n);
  for (isp = itemset; isp < itemsetend; isp++)
    printf("   %d\n", *isp);
d216 10
a225 18
    int i, j;
    unsigned *rowp;
    unsigned word;
    unsigned k;

    printf("\n\nEpsilon Free Firsts\n");

    for (i = start_symbol; i < nsyms; i++)
    {
	printf("\n%s", symbol_name[i]);
	rowp = EFF + ((i - start_symbol) * WORDSIZE(nvars));
	word = *rowp++;

	k = BITS_PER_WORD;
	for (j = 0; j < nvars; k++, j++)
	{
	    if (k >= BITS_PER_WORD)
	    {
a226 2
		k = 0;
	    }
d228 10
a237 2
	    if (word & (1 << k))
		printf("  %s", symbol_name[start_symbol + j]);
a238 1
    }
d244 17
a260 20
    int i;
    int j;
    unsigned *rp;
    unsigned cword = 0;
    unsigned k;

    printf("\n\n\nFirst Derives\n");

    for (i = start_symbol; i < nsyms; i++)
    {
	printf("\n%s derives\n", symbol_name[i]);
	rp = first_derives + i * WORDSIZE(nrules);
	k = BITS_PER_WORD;
	for (j = 0; j <= nrules; k++, j++)
        {
	  if (k >= BITS_PER_WORD)
	  {
	      cword = *rp++;
	      k = 0;
	  }
d262 3
a264 2
	  if (cword & (1 << k))
	    printf("   %d\n", j);
a265 1
    }
d267 1
a267 1
  fflush(stdout);
@


1.10
log
@Replace a loop with a memset, from Michael W Bombardieri. White here
also remove an unnecessary assignment pointed out by millert@@.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.9 2009/10/27 23:59:50 deraadt Exp $	*/
d135 1
a135 1
    FREE(EFF);
d209 3
a211 3
  FREE(itemset);
  FREE(ruleset);
  FREE(first_derives + ntokens * WORDSIZE(nrules));
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.8 2005/06/10 16:40:45 pvalchev Exp $	*/
a155 1
    rsp = ruleset;
d157 1
a157 2
    for (rsp = ruleset; rsp < rsend; rsp++)
	*rsp = 0;
@


1.8
log
@-Wall clean; ok otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.7 2003/06/19 16:34:53 pvalchev Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)closure.c	5.3 (Berkeley) 5/24/93";
#else
static char rcsid[] = "$OpenBSD: closure.c,v 1.7 2003/06/19 16:34:53 pvalchev Exp $";
#endif
#endif /* not lint */
@


1.7
log
@ansify; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.6 2003/06/03 02:56:24 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: closure.c,v 1.6 2003/06/03 02:56:24 millert Exp $";
d98 1
a98 1
    unsigned cword;
d274 1
a274 1
    unsigned cword;
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.5 2001/11/19 19:02:18 mpech Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: closure.c,v 1.5 2001/11/19 19:02:18 mpech Exp $";
d55 1
a55 1
set_EFF()
d92 1
a92 1
set_first_derives()
d148 1
a148 3
closure(nucleus, n)
short *nucleus;
int n;
d217 1
a217 1
finalize_closure()
d227 2
a228 2
print_closure(n)
int n;
d237 2
a238 2

print_EFF()
d268 2
a269 2

print_first_derives()
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.4 2001/07/16 06:29:43 pvalchev Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: closure.c,v 1.4 2001/07/16 06:29:43 pvalchev Exp $";
@


1.4
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.3 1996/06/26 05:44:35 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: closure.c,v 1.3 1996/06/26 05:44:35 deraadt Exp $";
d61 6
a66 6
    register unsigned *row;
    register int symbol;
    register short *sp;
    register int rowsize;
    register int i;
    register int rule;
d98 6
a103 6
    register unsigned *rrow;
    register unsigned *vrow;
    register int j;
    register unsigned k;
    register unsigned cword;
    register short *rp;
d156 7
a162 7
    register int ruleno;
    register unsigned word;
    register unsigned i;
    register short *csp;
    register unsigned *dsp;
    register unsigned *rsp;
    register int rulesetsize;
d236 1
a236 1
  register short *isp;
d246 4
a249 4
    register int i, j;
    register unsigned *rowp;
    register unsigned word;
    register unsigned k;
d277 5
a281 5
    register int i;
    register int j;
    register unsigned *rp;
    register unsigned cword;
    register unsigned k;
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: closure.c,v 1.4 1996/03/19 03:21:29 jtc Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: closure.c,v 1.4 1996/03/19 03:21:29 jtc Exp $";
d58 1
d95 1
d151 1
d222 1
@


1.2
log
@sync to netbsd 960418
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: closure.c,v 1.4 1996/03/19 03:21:29 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 38
d40 5
a44 1
static char rcsid[] = "$Id: closure.c,v 1.3 1993/08/02 17:56:35 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
