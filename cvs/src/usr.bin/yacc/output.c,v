head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.20
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.16
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.14
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.12
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.09.21.16.26.30;	author otto;	state Exp;
branches;
next	1.25;
commitid	uv2dnHpViGySmx0i;

1.25
date	2015.12.11.20.25.47;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	imdifMlAvt2nFvdW;

1.24
date	2014.12.02.15.40.37;	author otto;	state Exp;
branches;
next	1.23;
commitid	pSCoOvRF24XYOHR2;

1.23
date	2014.03.13.01.18.22;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.03.07.19.44.07;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.03.07.19.34.49;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.02.21.02.18.00;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.08.22.55.59;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.08.22.36.37;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.08.21.40.25;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.03.19.15.00;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.10.16.40.45;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.08.20.13.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.06.05.35.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.19.16.34.53;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.03.21.34.21;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.28.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.16.06.29.45;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.26.00.03.32;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.12.06.12.07.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.45.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.06;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Fix bad indentation. One already existed in 1.20, one introduced in 1.21;
ok tedu@@
@
text
@/*	$OpenBSD: output.c,v 1.25 2015/12/11 20:25:47 mmcc Exp $	*/
/*	$NetBSD: output.c,v 1.4 1996/03/19 03:21:41 jtc Exp $	*/

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "defs.h"

static int nvectors;
static int nentries;
static short **froms;
static short **tos;
static short *tally;
static short *width;
static short *state_count;
static short *order;
static short *base;
static short *pos;
static int maxtable;
static short *table;
static short *check;
static int lowzero;
static int high;

void output_prefix(void);
void output_rule_data(void);
void output_yydefred(void);
void output_actions(void);
void token_actions(void);
void goto_actions(void);
int default_goto(int);
void save_column(int, int);
void sort_actions(void);
void pack_table(void);
int matching_vector(int);
int pack_vector(int);
void output_base(void);
void output_table(void);
void output_check(void);
int is_C_identifier(char *);
void output_defines(void);
void output_stored_text(void);
void output_debug(void);
void output_stype(void);
void output_trailing_text(void);
void output_semantic_actions(void);
void free_itemsets(void);
void free_shifts(void);
void free_reductions(void);

void
output(void)
{
	free_itemsets();
	free_shifts();
	free_reductions();
	output_prefix();
	output_stored_text();
	output_defines();
	output_rule_data();
	output_yydefred();
	output_actions();
	free_parser();
	output_debug();
	output_stype();
	if (rflag)
		write_section(tables);
	write_section(header);
	output_trailing_text();
	write_section(body);
	output_semantic_actions();
	write_section(trailer);
}


void
output_prefix(void)
{
	if (symbol_prefix == NULL)
		symbol_prefix = "yy";
	else {
		++outline;
		fprintf(code_file, "#define yyparse %sparse\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yylex %slex\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyerror %serror\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yychar %schar\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyval %sval\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yylval %slval\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yydebug %sdebug\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yynerrs %snerrs\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyerrflag %serrflag\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyss %sss\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yysslim %ssslim\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyssp %sssp\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyvs %svs\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyvsp %svsp\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yystacksize %sstacksize\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yylhs %slhs\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yylen %slen\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yydefred %sdefred\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yydgoto %sdgoto\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yysindex %ssindex\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyrindex %srindex\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yygindex %sgindex\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yytable %stable\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yycheck %scheck\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyname %sname\n", symbol_prefix);
		++outline;
		fprintf(code_file, "#define yyrule %srule\n", symbol_prefix);
	}
	++outline;
	fprintf(code_file, "#define YYPREFIX \"%s\"\n", symbol_prefix);
}


void
output_rule_data(void)
{
	int i;
	int j;

	fprintf(output_file,
	    "const short %slhs[] =\n"
	    "\t{%42d,", symbol_prefix, symbol_value[start_symbol]);

	j = 10;
	for (i = 3; i < nrules; i++) {
		if (j >= 10) {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		} else
			++j;
		fprintf(output_file, "%5d,", symbol_value[rlhs[i]]);
	}
	if (!rflag)
		outline += 2;
	fprintf(output_file, "\n};\n");

	fprintf(output_file,
	    "const short %slen[] =\n"
	    "\t{%42d,", symbol_prefix, 2);

	j = 10;
	for (i = 3; i < nrules; i++) {
		if (j >= 10) {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		} else
			j++;
		fprintf(output_file, "%5d,", rrhs[i + 1] - rrhs[i] - 1);
	}
	if (!rflag)
		outline += 2;
	fprintf(output_file, "\n};\n");
}


void
output_yydefred(void)
{
	int i, j;

	fprintf(output_file,
	    "const short %sdefred[] =\n"
	    "\t{%39d,",
	    symbol_prefix, (defred[0] ? defred[0] - 2 : 0));

	j = 10;
	for (i = 1; i < nstates; i++) {
		if (j < 10)
			++j;
		else {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		}
		fprintf(output_file, "%5d,", (defred[i] ? defred[i] - 2 : 0));
	}

	if (!rflag)
		outline += 2;
	fprintf(output_file, "\n};\n");
}


void
output_actions(void)
{
	nvectors = 2 * nstates + nvars;

	froms = NEW2(nvectors, short *);
	tos = NEW2(nvectors, short *);
	tally = NEW2(nvectors, short);
	width = NEW2(nvectors, short);

	token_actions();
	free(lookaheads);
	free(LA);
	free(LAruleno);
	free(accessing_symbol);

	goto_actions();
	free(goto_map + ntokens);
	free(from_state);
	free(to_state);

	sort_actions();
	pack_table();
	output_base();
	output_table();
	output_check();
}


void
token_actions(void)
{
	int i, j;
	int shiftcount, reducecount;
	int max, min;
	short *actionrow, *r, *s;
	action *p;

	actionrow = NEW2(2*ntokens, short);
	for (i = 0; i < nstates; ++i) {
		if (parser[i]) {
			for (j = 0; j < 2 * ntokens; ++j)
				actionrow[j] = 0;
			shiftcount = 0;
			reducecount = 0;
			for (p = parser[i]; p; p = p->next) {
				if (p->suppressed == 0) {
					if (p->action_code == SHIFT) {
						++shiftcount;
						actionrow[p->symbol] = p->number;
					} else if (p->action_code == REDUCE &&
					    p->number != defred[i]) {
						++reducecount;
						actionrow[p->symbol + ntokens] = p->number;
					}
				}
			}

			tally[i] = shiftcount;
			tally[nstates+i] = reducecount;
			width[i] = 0;
			width[nstates+i] = 0;
			if (shiftcount > 0) {
				froms[i] = r = NEW2(shiftcount, short);
				tos[i] = s = NEW2(shiftcount, short);
				min = MAXSHORT;
				max = 0;
				for (j = 0; j < ntokens; ++j) {
					if (actionrow[j]) {
						if (min > symbol_value[j])
							min = symbol_value[j];
						if (max < symbol_value[j])
							max = symbol_value[j];
						*r++ = symbol_value[j];
						*s++ = actionrow[j];
					}
				}
				width[i] = max - min + 1;
			}
			if (reducecount > 0) {
				froms[nstates+i] = r = NEW2(reducecount, short);
				tos[nstates+i] = s = NEW2(reducecount, short);
				min = MAXSHORT;
				max = 0;
				for (j = 0; j < ntokens; ++j) {
					if (actionrow[ntokens+j]) {
						if (min > symbol_value[j])
							min = symbol_value[j];
						if (max < symbol_value[j])
							max = symbol_value[j];
						*r++ = symbol_value[j];
						*s++ = actionrow[ntokens+j] - 2;
					}
				}
				width[nstates+i] = max - min + 1;
			}
		}
	}
	free(actionrow);
}

void
goto_actions(void)
{
	int i, j, k;

	state_count = NEW2(nstates, short);

	k = default_goto(start_symbol + 1);
	fprintf(output_file, "const short %sdgoto[] =\n"
	    "\t{%40d,", symbol_prefix, k);
	save_column(start_symbol + 1, k);

	j = 10;
	for (i = start_symbol + 2; i < nsyms; i++) {
		if (j >= 10) {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		} else
			++j;

		k = default_goto(i);
		fprintf(output_file, "%5d,", k);
		save_column(i, k);
	}

	if (!rflag)
		outline += 2;
	fprintf(output_file, "\n};\n");
	free(state_count);
}

int
default_goto(int symbol)
{
	int i;
	int m;
	int n;
	int default_state;
	int max;

	m = goto_map[symbol];
	n = goto_map[symbol + 1];

	if (m == n)
		return (0);

	memset(state_count, 0, nstates * sizeof(short));

	for (i = m; i < n; i++)
		state_count[to_state[i]]++;

	max = 0;
	default_state = 0;
	for (i = 0; i < nstates; i++) {
		if (state_count[i] > max) {
			max = state_count[i];
			default_state = i;
		}
	}

	return (default_state);
}



void
save_column(int symbol, int default_state)
{
	int i;
	int m;
	int n;
	short *sp;
	short *sp1;
	short *sp2;
	int count;
	int symno;

	m = goto_map[symbol];
	n = goto_map[symbol + 1];

	count = 0;
	for (i = m; i < n; i++) {
		if (to_state[i] != default_state)
			++count;
	}
	if (count == 0)
		return;

	symno = symbol_value[symbol] + 2*nstates;

	froms[symno] = sp1 = sp = NEW2(count, short);
	tos[symno] = sp2 = NEW2(count, short);

	for (i = m; i < n; i++) {
		if (to_state[i] != default_state) {
			*sp1++ = from_state[i];
			*sp2++ = to_state[i];
		}
	}

	tally[symno] = count;
	width[symno] = sp1[-1] - sp[0] + 1;
}

void
sort_actions(void)
{
	int i;
	int j;
	int k;
	int t;
	int w;

	order = NEW2(nvectors, short);
	nentries = 0;

	for (i = 0; i < nvectors; i++) {
		if (tally[i] > 0) {
			t = tally[i];
			w = width[i];
			j = nentries - 1;

			while (j >= 0 && (width[order[j]] < w))
				j--;

			while (j >= 0 && (width[order[j]] == w) &&
			    (tally[order[j]] < t))
				j--;

			for (k = nentries - 1; k > j; k--)
				order[k + 1] = order[k];

			order[j + 1] = i;
			nentries++;
		}
	}
}


void
pack_table(void)
{
	int i;
	int place;
	int state;

	base = NEW2(nvectors, short);
	pos = NEW2(nentries, short);

	maxtable = 1000;
	table = NEW2(maxtable, short);
	check = NEW2(maxtable, short);

	lowzero = 0;
	high = 0;

	for (i = 0; i < maxtable; i++)
		check[i] = -1;

	for (i = 0; i < nentries; i++) {
		state = matching_vector(i);

		if (state < 0)
			place = pack_vector(i);
		else
			place = base[state];

		pos[i] = place;
		base[order[i]] = place;
	}

	for (i = 0; i < nvectors; i++) {
		free(froms[i]);
		free(tos[i]);
	}

	free(froms);
	free(tos);
	free(pos);
}


/*  The function matching_vector determines if the vector specified by	*/
/*  the input parameter matches a previously considered	vector.  The	*/
/*  test at the start of the function checks if the vector represents	*/
/*  a row of shifts over terminal symbols or a row of reductions, or a	*/
/*  column of shifts over a nonterminal symbol.  Berkeley Yacc does not	*/
/*  check if a column of shifts over a nonterminal symbols matches a	*/
/*  previously considered vector.  Because of the nature of LR parsing	*/
/*  tables, no two columns can match.  Therefore, the only possible	*/
/*  match would be between a row and a column.  Such matches are	*/
/*  unlikely.  Therefore, to save time, no attempt is made to see if a	*/
/*  column matches a previously considered vector.			*/
/*									*/
/*  Matching_vector is poorly designed.  The test could easily be made	*/
/*  faster.  Also, it depends on the vectors being in a specific	*/
/*  order.								*/

int
matching_vector(int vector)
{
	int i, j, k, t, w, match, prev;

	i = order[vector];
	if (i >= 2*nstates)
		return (-1);

	t = tally[i];
	w = width[i];

	for (prev = vector - 1; prev >= 0; prev--) {
		j = order[prev];
		if (width[j] != w || tally[j] != t)
			return (-1);

		match = 1;
		for (k = 0; match && k < t; k++) {
			if (tos[j][k] != tos[i][k] ||
			    froms[j][k] != froms[i][k])
				match = 0;
		}

		if (match)
			return (j);
	}

	return (-1);
}



int
pack_vector(int vector)
{
	int i, j, k, l;
	int t, loc, ok;
	short *from, *to;
	int newmax;

	i = order[vector];
	t = tally[i];
	assert(t);

	from = froms[i];
	to = tos[i];

	j = lowzero - from[0];
	for (k = 1; k < t; ++k)
		if (lowzero - from[k] > j)
			j = lowzero - from[k];
	for (;; ++j) {
		if (j == 0)
			continue;
		ok = 1;
		for (k = 0; ok && k < t; k++) {
			loc = j + from[k];
			if (loc >= maxtable) {
				if (loc >= MAXTABLE)
					fatal("maximum table size exceeded");

				newmax = maxtable;
				do {
					newmax += 200;
				} while (newmax <= loc);
				table = realloc(table, newmax * sizeof(short));
				if (table == NULL)
					no_space();
				check = realloc(check, newmax * sizeof(short));
				if (check == NULL)
					no_space();
				for (l  = maxtable; l < newmax; ++l) {
					table[l] = 0;
					check[l] = -1;
				}
				maxtable = newmax;
			}

			if (check[loc] != -1)
				ok = 0;
		}
		for (k = 0; ok && k < vector; k++) {
			if (pos[k] == j)
				ok = 0;
		}
		if (ok) {
			for (k = 0; k < t; k++) {
				loc = j + from[k];
				table[loc] = to[k];
				check[loc] = from[k];
				if (loc > high)
					high = loc;
			}

			while (lowzero < maxtable && check[lowzero] != -1)
				++lowzero;

			return (j);
		}
	}
}



void
output_base(void)
{
	int i, j;

	fprintf(output_file, "const short %ssindex[] =\n"
	    "\t{%39d,", symbol_prefix, base[0]);

	j = 10;
	for (i = 1; i < nstates; i++) {
		if (j >= 10) {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		} else
			++j;
		fprintf(output_file, "%5d,", base[i]);
	}

	if (!rflag)
		outline += 2;
	fprintf(output_file, "};\n"
	    "const short %srindex[] =\n"
	    "\t{%39d,", symbol_prefix, base[nstates]);

	j = 10;
	for (i = nstates + 1; i < 2*nstates; i++) {
		if (j >= 10) {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		} else
			++j;
		fprintf(output_file, "%5d,", base[i]);
	}

	if (!rflag)
		outline += 2;
	fprintf(output_file, "};\n"
	    "const short %sgindex[] =\n"
	    "\t{%39d,", symbol_prefix, base[2*nstates]);

	j = 10;
	for (i = 2*nstates + 1; i < nvectors - 1; i++) {
		if (j >= 10) {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		} else
			++j;
		fprintf(output_file, "%5d,", base[i]);
	}

	if (!rflag)
		outline += 2;
	fprintf(output_file, "\n};\n");
	free(base);
}


void
output_table(void)
{
	int i, j;

	++outline;
	fprintf(code_file, "#define YYTABLESIZE %d\n", high);
	fprintf(output_file, "const short %stable[] =\n"
	    "\t{%40d,", symbol_prefix, table[0]);

	j = 10;
	for (i = 1; i <= high; i++) {
		if (j >= 10) {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		} else
			++j;
		fprintf(output_file, "%5d,", table[i]);
	}

	if (!rflag)
		outline += 2;
	fprintf(output_file, "\n};\n");
	free(table);
}


void
output_check(void)
{
	int i, j;

	fprintf(output_file, "const short %scheck[] =\n"
	    "\t{%40d,", symbol_prefix, check[0]);

	j = 10;
	for (i = 1; i <= high; i++) {
		if (j >= 10) {
			if (!rflag)
				++outline;
			putc('\n', output_file);
			j = 1;
		} else
			++j;
		fprintf(output_file, "%5d,", check[i]);
	}

	if (!rflag)
		outline += 2;
	fprintf(output_file, "\n};\n");
	free(check);
}


int
is_C_identifier(char *name)
{
	char *s;
	int c;

	s = name;
	c = (unsigned char)*s;
	if (c == '"') {
		c = (unsigned char)*++s;
		if (!isalpha(c) && c != '_' && c != '$')
			return (0);
		while ((c = (unsigned char)*++s) != '"') {
			if (!isalnum(c) && c != '_' && c != '$')
				return (0);
		}
		return (1);
	}

	if (!isalpha(c) && c != '_' && c != '$')
		return (0);
	while ((c = (unsigned char)*++s)) {
		if (!isalnum(c) && c != '_' && c != '$')
			return (0);
	}
	return (1);
}


void
output_defines(void)
{
	int c, i;
	char *s;

	for (i = 2; i < ntokens; ++i) {
		s = symbol_name[i];
		if (is_C_identifier(s)) {
			fprintf(code_file, "#define ");
			if (dflag)
				fprintf(defines_file, "#define ");
			c = (unsigned char)*s;
			if (c == '"') {
				while ((c = (unsigned char)*++s) != '"') {
					putc(c, code_file);
					if (dflag)
						putc(c, defines_file);
				}
			} else {
				do {
					putc(c, code_file);
					if (dflag)
						putc(c, defines_file);
				} while ((c = (unsigned char)*++s));
			}
			++outline;
			fprintf(code_file, " %d\n", symbol_value[i]);
			if (dflag)
				fprintf(defines_file, " %d\n", symbol_value[i]);
		}
	}

	++outline;
	fprintf(code_file, "#define YYERRCODE %d\n", symbol_value[1]);

	if (dflag && unionized) {
		fclose(union_file);
		union_file = fopen(union_file_name, "r");
		if (union_file == NULL)
			open_error(union_file_name);
		while ((c = getc(union_file)) != EOF)
			putc(c, defines_file);
		fprintf(defines_file, " YYSTYPE;\n");
		fprintf(defines_file, "#endif /* YYSTYPE_DEFINED */\n");
		fprintf(defines_file, "extern YYSTYPE %slval;\n",
		    symbol_prefix);
	}
}


void
output_stored_text(void)
{
	int c;
	FILE *in, *out;

	fclose(text_file);
	text_file = fopen(text_file_name, "r");
	if (text_file == NULL)
		open_error(text_file_name);
	in = text_file;
	if ((c = getc(in)) == EOF)
		return;
	out = code_file;
	if (c ==  '\n')
		++outline;
	putc(c, out);
	while ((c = getc(in)) != EOF) {
		if (c == '\n')
			++outline;
		putc(c, out);
	}
	if (!lflag)
		fprintf(out, line_format, ++outline + 1, code_file_name);
}


void
output_debug(void)
{
	int i, j, k, max;
	char **symnam, *s;

	++outline;
	fprintf(code_file, "#define YYFINAL %d\n", final_state);
	outline += 3;
	fprintf(code_file, "#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n",
		tflag);
	if (rflag)
		fprintf(output_file, "#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n",
		    tflag);

	max = 0;
	for (i = 2; i < ntokens; ++i)
		if (symbol_value[i] > max)
			max = symbol_value[i];
	++outline;
	fprintf(code_file, "#define YYMAXTOKEN %d\n", max);

	symnam = calloc(max+1, sizeof(char *));
	if (symnam == NULL)
		no_space();

	for (i = ntokens - 1; i >= 2; --i)
		symnam[symbol_value[i]] = symbol_name[i];
	symnam[0] = "end-of-file";

	if (!rflag)
		++outline;
	fprintf(output_file,
	    "#if YYDEBUG\n"
	    "const char * const %sname[] =\n"
	    "\t{", symbol_prefix);
	j = 80;
	for (i = 0; i <= max; ++i) {
		if ((s = symnam[i]) != '\0') {
			if (s[0] == '"') {
				k = 7;
				while (*++s != '"') {
					++k;
					if (*s == '\\') {
						k += 2;
						if (*++s == '\\')
							++k;
					}
				}
				j += k;
				if (j > 80) {
					if (!rflag)
						++outline;
					putc('\n', output_file);
					j = k;
				}
				fprintf(output_file, "\"\\\"");
				s = symnam[i];
				while (*++s != '"') {
					if (*s == '\\') {
						fprintf(output_file, "\\\\");
						if (*++s == '\\')
							fprintf(output_file, "\\\\");
						else
							putc(*s, output_file);
					} else
						putc(*s, output_file);
				}
				fprintf(output_file, "\\\"\",");
			} else if (s[0] == '\'') {
				if (s[1] == '"') {
					j += 7;
					if (j > 80) {
						if (!rflag)
							++outline;
						putc('\n', output_file);
						j = 7;
					}
					fprintf(output_file, "\"'\\\"'\",");
				} else {
					k = 5;
					while (*++s != '\'') {
						++k;
						if (*s == '\\') {
							k += 2;
							if (*++s == '\\')
								++k;
						}
					}
					j += k;
					if (j > 80) {
						if (!rflag)
							++outline;
						putc('\n', output_file);
						j = k;
					}
					fprintf(output_file, "\"'");
					s = symnam[i];
					while (*++s != '\'') {
						if (*s == '\\') {
							fprintf(output_file, "\\\\");
							if (*++s == '\\')
								fprintf(output_file, "\\\\");
							else
								putc(*s, output_file);
						} else
							putc(*s, output_file);
					}
					fprintf(output_file, "'\",");
				}
			} else {
				k = strlen(s) + 3;
				j += k;
				if (j > 80) {
					if (!rflag)
						++outline;
					putc('\n', output_file);
					j = k;
				}
				putc('"', output_file);
				do {
					putc(*s, output_file);
				} while (*++s);
				fprintf(output_file, "\",");
			}
		} else {
			j += 2;
			if (j > 80) {
				if (!rflag)
					++outline;
				putc('\n', output_file);
				j = 2;
			}
			fprintf(output_file, "0,");
		}
	}
	if (!rflag)
		outline += 2;
	fprintf(output_file, "\n};\n");
	free(symnam);

	if (!rflag)
		++outline;
	fprintf(output_file,
	    "const char * const %srule[] =\n"
	    "\t{", symbol_prefix);
	for (i = 2; i < nrules; ++i) {
		fprintf(output_file, "\"%s :", symbol_name[rlhs[i]]);
		for (j = rrhs[i]; ritem[j] > 0; ++j) {
			s = symbol_name[ritem[j]];
			if (s[0] == '"') {
				fprintf(output_file, " \\\"");
				while (*++s != '"') {
					if (*s == '\\') {
						if (s[1] == '\\')
							fprintf(output_file, "\\\\\\\\");
						else
							fprintf(output_file, "\\\\%c", s[1]);
						++s;
					} else
						putc(*s, output_file);
				}
				fprintf(output_file, "\\\"");
			} else if (s[0] == '\'') {
				if (s[1] == '"')
					fprintf(output_file, " '\\\"'");
				else if (s[1] == '\\') {
					if (s[2] == '\\')
						fprintf(output_file, " '\\\\\\\\");
					else
						fprintf(output_file, " '\\\\%c", s[2]);
					s += 2;
					while (*++s != '\'')
						putc(*s, output_file);
					putc('\'', output_file);
				} else
					fprintf(output_file, " '%c'", s[1]);
			} else
				fprintf(output_file, " %s", s);
		}
		if (!rflag)
			++outline;
		fprintf(output_file, "\",\n");
	}

	if (!rflag)
		outline += 2;
	fprintf(output_file, "};\n#endif\n");
}


void
output_stype(void)
{
	if (!unionized && ntags == 0) {
		outline += 3;
		fprintf(code_file, "#ifndef YYSTYPE\ntypedef int YYSTYPE;\n#endif\n");
	}
}


void
output_trailing_text(void)
{
	int c, last;
	FILE *in, *out;

	if (line == 0)
		return;

	in = input_file;
	out = code_file;
	c = (unsigned char)*cptr;
	if (c == '\n') {
		++lineno;
		if ((c = getc(in)) == EOF)
			return;
		if (!lflag) {
			++outline;
			fprintf(out, line_format, lineno, input_file_name);
		}
		if (c == '\n')
			++outline;
		putc(c, out);
		last = c;
	} else {
		if (!lflag) {
			++outline;
			fprintf(out, line_format, lineno, input_file_name);
		}
		do {
			putc(c, out);
		} while ((c = (unsigned char)*++cptr) != '\n');
		++outline;
		putc('\n', out);
		last = '\n';
	}

	while ((c = getc(in)) != EOF) {
		if (c == '\n')
			++outline;
		putc(c, out);
		last = c;
	}

	if (last != '\n') {
		++outline;
		putc('\n', out);
	}
	if (!lflag)
		fprintf(out, line_format, ++outline + 1, code_file_name);
}


void
output_semantic_actions(void)
{
	int c, last;
	FILE *out;

	fclose(action_file);
	action_file = fopen(action_file_name, "r");
	if (action_file == NULL)
		open_error(action_file_name);

	if ((c = getc(action_file)) == EOF)
		return;

	out = code_file;
	last = c;
	if (c == '\n')
		++outline;
	putc(c, out);
	while ((c = getc(action_file)) != EOF) {
		if (c == '\n')
			++outline;
		putc(c, out);
		last = c;
	}

	if (last != '\n') {
		++outline;
		putc('\n', out);
	}

	if (!lflag)
		fprintf(out, line_format, ++outline + 1, code_file_name);
}


void
free_itemsets(void)
{
	core *cp, *next;

	free(state_table);
	for (cp = first_state; cp; cp = next) {
		next = cp->next;
		free(cp);
	}
}


void
free_shifts(void)
{
	shifts *sp, *next;

	free(shift_table);
	for (sp = first_shift; sp; sp = next) {
		next = sp->next;
		free(sp);
	}
}



void
free_reductions(void)
{
	reductions *rp, *next;

	free(reduction_table);
	for (rp = first_reduction; rp; rp = next) {
		next = rp->next;
		free(rp);
	}
}
@


1.25
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.24 2014/12/02 15:40:37 otto Exp $	*/
d284 3
a286 3
	if (parser[i]) {
		for (j = 0; j < 2 * ntokens; ++j)
			actionrow[j] = 0;
@


1.24
log
@Fix lowzero running out of bounds in pack_vector(). Problem seen by
Andrey Skvortsov; ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.23 2014/03/13 01:18:22 tedu Exp $	*/
d519 2
a520 4
		if (froms[i])
			free(froms[i]);
		if (tos[i])
			free(tos[i]);
@


1.23
log
@collapse variable declarations
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.22 2014/03/07 19:44:07 tedu Exp $	*/
d642 1
a642 1
			while (check[lowzero] != -1)
@


1.22
log
@a few other tweaks it's easier to see in the light of day
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.21 2014/03/07 19:34:49 tedu Exp $	*/
d550 1
a550 7
	int i;
	int j;
	int k;
	int t;
	int w;
	int match;
	int prev;
d584 2
a585 5
	int t;
	int loc;
	int ok;
	short *from;
	short *to;
d613 2
a614 2
				table = realloc(table, newmax*sizeof(short));
				if (table == 0)
d616 2
a617 2
				check = realloc(check, newmax*sizeof(short));
				if (check == 0)
d718 1
a718 2
	int i;
	int j;
d747 1
a747 2
	int i;
	int j;
d900 3
a902 2
	symnam = (char **) calloc(max+1, sizeof(char *));
	if (symnam == 0) no_space();
@


1.21
log
@drag this code into modern style. ok zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.20 2014/02/21 02:18:00 tedu Exp $	*/
a187 1

a206 1

a234 1

a286 1

d353 2
a354 3
	fprintf(output_file,
	"const short %sdgoto[] =\n"
	"\t{%40d,", symbol_prefix, k);
d390 2
a391 1
	if (m == n) return (0);
d396 1
a396 1
	state_count[to_state[i]]++;
d619 9
a627 5
				do { newmax += 200; } while (newmax <= loc);
				table = (short *) realloc(table, newmax*sizeof(short));
				if (table == 0) no_space();
				check = (short *) realloc(check, newmax*sizeof(short));
				if (check == 0) no_space();
d666 2
a667 3
	fprintf(output_file,
	"const short %ssindex[] =\n"
	"\t{%39d,", symbol_prefix, base[0]);
a677 1

d683 1
a683 2
	fprintf(output_file,
	    "};\n"
a695 1

d701 1
a701 2
	fprintf(output_file,
	    "};\n"
a713 1

d732 2
a733 3
	fprintf(output_file,
	"const short %stable[] =\n"
	"\t{%40d,", symbol_prefix, table[0]);
a743 1

d760 2
a761 3
	fprintf(output_file,
	"const short %scheck[] =\n"
	"\t{%40d,", symbol_prefix, check[0]);
a771 1

d827 2
a828 1
					if (dflag) putc(c, defines_file);
d833 2
a834 1
					if (dflag) putc(c, defines_file);
d939 2
a940 1
					if (!rflag) ++outline;
d960 5
a964 5
					if (j > 80)
					{
					if (!rflag) ++outline;
					putc('\n', output_file);
					j = 7;
d974 1
a974 1
							++k;
d979 2
a980 1
						if (!rflag) ++outline;
d1002 2
a1003 1
					if (!rflag) ++outline;
d1008 3
a1010 1
				do { putc(*s, output_file); } while (*++s);
d1016 2
a1017 1
				if (!rflag) ++outline;
d1042 5
a1046 5
					if (s[1] == '\\')
						fprintf(output_file, "\\\\\\\\");
					else
						fprintf(output_file, "\\\\%c", s[1]);
					++s;
d1048 1
a1048 1
					putc(*s, output_file);
d1184 3
a1186 4
	for (cp = first_state; cp; cp = next)
	{
	next = cp->next;
	free(cp);
@


1.20
log
@drop support for pre-standard C, it's time to move on. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.19 2014/01/08 22:55:59 millert Exp $	*/
d83 19
a101 18
    free_itemsets();
    free_shifts();
    free_reductions();
    output_prefix();
    output_stored_text();
    output_defines();
    output_rule_data();
    output_yydefred();
    output_actions();
    free_parser();
    output_debug();
    output_stype();
    if (rflag) write_section(tables);
    write_section(header);
    output_trailing_text();
    write_section(body);
    output_semantic_actions();
    write_section(trailer);
d108 56
a163 46
    if (symbol_prefix == NULL)
	symbol_prefix = "yy";
    else
    {
	++outline;
	fprintf(code_file, "#define yyparse %sparse\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yylex %slex\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyerror %serror\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yychar %schar\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyval %sval\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yylval %slval\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yydebug %sdebug\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yynerrs %snerrs\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyerrflag %serrflag\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyss %sss\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yysslim %ssslim\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyssp %sssp\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyvs %svs\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyvsp %svsp\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yystacksize %sstacksize\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yylhs %slhs\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yylen %slen\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yydefred %sdefred\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yydgoto %sdgoto\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yysindex %ssindex\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyrindex %srindex\n", symbol_prefix);
d165 1
a165 12
	fprintf(code_file, "#define yygindex %sgindex\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yytable %stable\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yycheck %scheck\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyname %sname\n", symbol_prefix);
	++outline;
	fprintf(code_file, "#define yyrule %srule\n", symbol_prefix);
    }
    ++outline;
    fprintf(code_file, "#define YYPREFIX \"%s\"\n", symbol_prefix);
d172 2
a173 2
    int i;
    int j;
d175 39
a213 41
    fprintf(output_file,
	"const short %slhs[] =\n"
	"\t{%42d,", symbol_prefix, symbol_value[start_symbol]);

    j = 10;
    for (i = 3; i < nrules; i++)
    {
	if (j >= 10)
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
	}
        else
	    ++j;

        fprintf(output_file, "%5d,", symbol_value[rlhs[i]]);
    }
    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");

    fprintf(output_file,
	"const short %slen[] =\n"
	"\t{%42d,", symbol_prefix, 2);

    j = 10;
    for (i = 3; i < nrules; i++)
    {
	if (j >= 10)
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
	}
	else
	  j++;

        fprintf(output_file, "%5d,", rrhs[i + 1] - rrhs[i] - 1);
    }
    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
d220 17
a236 1
    int i, j;
d238 1
a238 15
    fprintf(output_file,
	"const short %sdefred[] =\n"
	"\t{%39d,",
	symbol_prefix, (defred[0] ? defred[0] - 2 : 0));

    j = 10;
    for (i = 1; i < nstates; i++)
    {
	if (j < 10)
	    ++j;
	else
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
d241 3
a243 5
	fprintf(output_file, "%5d,", (defred[i] ? defred[i] - 2 : 0));
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
d250 1
a250 1
    nvectors = 2*nstates + nvars;
d252 21
a272 21
    froms = NEW2(nvectors, short *);
    tos = NEW2(nvectors, short *);
    tally = NEW2(nvectors, short);
    width = NEW2(nvectors, short);

    token_actions();
    free(lookaheads);
    free(LA);
    free(LAruleno);
    free(accessing_symbol);

    goto_actions();
    free(goto_map + ntokens);
    free(from_state);
    free(to_state);

    sort_actions();
    pack_table();
    output_base();
    output_table();
    output_check();
d279 26
a304 13
    int i, j;
    int shiftcount, reducecount;
    int max, min;
    short *actionrow, *r, *s;
    action *p;

    actionrow = NEW2(2*ntokens, short);
    for (i = 0; i < nstates; ++i)
    {
	if (parser[i])
	{
	    for (j = 0; j < 2*ntokens; ++j)
	    actionrow[j] = 0;
d306 38
a343 40
	    shiftcount = 0;
	    reducecount = 0;
	    for (p = parser[i]; p; p = p->next)
	    {
		if (p->suppressed == 0)
		{
		    if (p->action_code == SHIFT)
		    {
			++shiftcount;
			actionrow[p->symbol] = p->number;
		    }
		    else if (p->action_code == REDUCE && p->number != defred[i])
		    {
			++reducecount;
			actionrow[p->symbol + ntokens] = p->number;
		    }
		}
	    }

	    tally[i] = shiftcount;
	    tally[nstates+i] = reducecount;
	    width[i] = 0;
	    width[nstates+i] = 0;
	    if (shiftcount > 0)
	    {
		froms[i] = r = NEW2(shiftcount, short);
		tos[i] = s = NEW2(shiftcount, short);
		min = MAXSHORT;
		max = 0;
		for (j = 0; j < ntokens; ++j)
		{
		    if (actionrow[j])
		    {
			if (min > symbol_value[j])
			    min = symbol_value[j];
			if (max < symbol_value[j])
			    max = symbol_value[j];
			*r++ = symbol_value[j];
			*s++ = actionrow[j];
		    }
a344 22
		width[i] = max - min + 1;
	    }
	    if (reducecount > 0)
	    {
		froms[nstates+i] = r = NEW2(reducecount, short);
		tos[nstates+i] = s = NEW2(reducecount, short);
		min = MAXSHORT;
		max = 0;
		for (j = 0; j < ntokens; ++j)
		{
		    if (actionrow[ntokens+j])
		    {
			if (min > symbol_value[j])
			    min = symbol_value[j];
			if (max < symbol_value[j])
			    max = symbol_value[j];
			*r++ = symbol_value[j];
			*s++ = actionrow[ntokens+j] - 2;
		    }
		}
		width[nstates+i] = max - min + 1;
	    }
d346 1
a346 2
    }
    free(actionrow);
d352 1
a352 1
    int i, j, k;
d354 1
a354 1
    state_count = NEW2(nstates, short);
d356 2
a357 2
    k = default_goto(start_symbol + 1);
    fprintf(output_file,
d360 16
a375 1
    save_column(start_symbol + 1, k);
d377 4
a380 20
    j = 10;
    for (i = start_symbol + 2; i < nsyms; i++)
    {
	if (j >= 10)
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
	}
	else
	    ++j;

	k = default_goto(i);
	fprintf(output_file, "%5d,", k);
	save_column(i, k);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    free(state_count);
d386 5
a390 5
    int i;
    int m;
    int n;
    int default_state;
    int max;
d392 2
a393 2
    m = goto_map[symbol];
    n = goto_map[symbol + 1];
d395 1
a395 1
    if (m == n) return (0);
d397 1
a397 1
    memset(state_count, 0, nstates * sizeof(short));
d399 1
a399 1
    for (i = m; i < n; i++)
d402 7
a408 8
    max = 0;
    default_state = 0;
    for (i = 0; i < nstates; i++)
    {
	if (state_count[i] > max)
	{
	    max = state_count[i];
	    default_state = i;
a409 1
    }
d411 1
a411 1
    return (default_state);
d419 30
a448 31
    int i;
    int m;
    int n;
    short *sp;
    short *sp1;
    short *sp2;
    int count;
    int symno;

    m = goto_map[symbol];
    n = goto_map[symbol + 1];

    count = 0;
    for (i = m; i < n; i++)
    {
	if (to_state[i] != default_state)
	    ++count;
    }
    if (count == 0) return;

    symno = symbol_value[symbol] + 2*nstates;

    froms[symno] = sp1 = sp = NEW2(count, short);
    tos[symno] = sp2 = NEW2(count, short);

    for (i = m; i < n; i++)
    {
	if (to_state[i] != default_state)
	{
	    *sp1++ = from_state[i];
	    *sp2++ = to_state[i];
a449 1
    }
d451 2
a452 2
    tally[symno] = count;
    width[symno] = sp1[-1] - sp[0] + 1;
d458 21
a478 16
  int i;
  int j;
  int k;
  int t;
  int w;

  order = NEW2(nvectors, short);
  nentries = 0;

  for (i = 0; i < nvectors; i++)
    {
      if (tally[i] > 0)
	{
	  t = tally[i];
	  w = width[i];
	  j = nentries - 1;
d480 2
a481 2
	  while (j >= 0 && (width[order[j]] < w))
	    j--;
d483 3
a485 8
	  while (j >= 0 && (width[order[j]] == w) && (tally[order[j]] < t))
	    j--;

	  for (k = nentries - 1; k > j; k--)
	    order[k + 1] = order[k];

	  order[j + 1] = i;
	  nentries++;
a486 1
    }
d493 39
a531 41
    int i;
    int place;
    int state;

    base = NEW2(nvectors, short);
    pos = NEW2(nentries, short);

    maxtable = 1000;
    table = NEW2(maxtable, short);
    check = NEW2(maxtable, short);

    lowzero = 0;
    high = 0;

    for (i = 0; i < maxtable; i++)
	check[i] = -1;

    for (i = 0; i < nentries; i++)
    {
	state = matching_vector(i);

	if (state < 0)
	    place = pack_vector(i);
	else
	    place = base[state];

	pos[i] = place;
	base[order[i]] = place;
    }

    for (i = 0; i < nvectors; i++)
    {
	if (froms[i])
	    free(froms[i]);
	if (tos[i])
	    free(tos[i]);
    }

    free(froms);
    free(tos);
    free(pos);
d554 26
a579 20
    int i;
    int j;
    int k;
    int t;
    int w;
    int match;
    int prev;

    i = order[vector];
    if (i >= 2*nstates)
	return (-1);

    t = tally[i];
    w = width[i];

    for (prev = vector - 1; prev >= 0; prev--)
    {
	j = order[prev];
	if (width[j] != w || tally[j] != t)
	    return (-1);
d581 2
a582 5
	match = 1;
	for (k = 0; match && k < t; k++)
	{
	    if (tos[j][k] != tos[i][k] || froms[j][k] != froms[i][k])
		match = 0;
d585 1
a585 5
	if (match)
	    return (j);
    }

    return (-1);
d593 48
a640 42
    int i, j, k, l;
    int t;
    int loc;
    int ok;
    short *from;
    short *to;
    int newmax;

    i = order[vector];
    t = tally[i];
    assert(t);

    from = froms[i];
    to = tos[i];

    j = lowzero - from[0];
    for (k = 1; k < t; ++k)
	if (lowzero - from[k] > j)
	    j = lowzero - from[k];
    for (;; ++j)
    {
	if (j == 0)
	    continue;
	ok = 1;
	for (k = 0; ok && k < t; k++)
	{
	    loc = j + from[k];
	    if (loc >= maxtable)
	    {
		if (loc >= MAXTABLE)
		    fatal("maximum table size exceeded");

		newmax = maxtable;
		do { newmax += 200; } while (newmax <= loc);
		table = (short *) realloc(table, newmax*sizeof(short));
		if (table == 0) no_space();
		check = (short *) realloc(check, newmax*sizeof(short));
		if (check == 0) no_space();
		for (l  = maxtable; l < newmax; ++l)
		{
		    table[l] = 0;
		    check[l] = -1;
d642 8
a649 20
		maxtable = newmax;
	    }

	    if (check[loc] != -1)
		ok = 0;
	}
	for (k = 0; ok && k < vector; k++)
	{
	    if (pos[k] == j)
		ok = 0;
	}
	if (ok)
	{
	    for (k = 0; k < t; k++)
	    {
		loc = j + from[k];
		table[loc] = to[k];
		check[loc] = from[k];
		if (loc > high) high = loc;
	    }
d651 2
a652 2
	    while (check[lowzero] != -1)
		++lowzero;
d654 2
a655 1
	    return (j);
a656 1
    }
d664 1
a664 1
    int i, j;
d666 1
a666 1
    fprintf(output_file,
d670 57
a726 60
    j = 10;
    for (i = 1; i < nstates; i++)
    {
	if (j >= 10)
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
	}
	else
	    ++j;

	fprintf(output_file, "%5d,", base[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file,
	"};\n"
	"const short %srindex[] =\n"
	"\t{%39d,", symbol_prefix, base[nstates]);

    j = 10;
    for (i = nstates + 1; i < 2*nstates; i++)
    {
	if (j >= 10)
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
	}
	else
	    ++j;

	fprintf(output_file, "%5d,", base[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file,
	"};\n"
	"const short %sgindex[] =\n"
	"\t{%39d,", symbol_prefix, base[2*nstates]);

    j = 10;
    for (i = 2*nstates + 1; i < nvectors - 1; i++)
    {
	if (j >= 10)
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
	}
	else
	    ++j;

	fprintf(output_file, "%5d,", base[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    free(base);
d733 2
a734 2
    int i;
    int j;
d736 3
a738 3
    ++outline;
    fprintf(code_file, "#define YYTABLESIZE %d\n", high);
    fprintf(output_file,
d742 17
a758 18
    j = 10;
    for (i = 1; i <= high; i++)
    {
	if (j >= 10)
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
	}
	else
	    ++j;

	fprintf(output_file, "%5d,", table[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    free(table);
d765 2
a766 2
    int i;
    int j;
d768 1
a768 1
    fprintf(output_file,
d772 17
a788 18
    j = 10;
    for (i = 1; i <= high; i++)
    {
	if (j >= 10)
	{
	    if (!rflag) ++outline;
	    putc('\n', output_file);
	    j = 1;
	}
	else
	    ++j;

	fprintf(output_file, "%5d,", check[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    free(check);
d795 15
a809 2
    char *s;
    int c;
a810 5
    s = name;
    c = (unsigned char)*s;
    if (c == '"')
    {
	c = (unsigned char)*++s;
a811 4
	    return (0);
	while ((c = (unsigned char)*++s) != '"')
	{
	    if (!isalnum(c) && c != '_' && c != '$')
d813 3
a817 10
    }

    if (!isalpha(c) && c != '_' && c != '$')
	return (0);
    while ((c = (unsigned char)*++s))
    {
	if (!isalnum(c) && c != '_' && c != '$')
	    return (0);
    }
    return (1);
d824 2
a825 2
    int c, i;
    char *s;
d827 22
a848 14
    for (i = 2; i < ntokens; ++i)
    {
	s = symbol_name[i];
	if (is_C_identifier(s))
	{
	    fprintf(code_file, "#define ");
	    if (dflag) fprintf(defines_file, "#define ");
	    c = (unsigned char)*s;
	    if (c == '"')
	    {
		while ((c = (unsigned char)*++s) != '"')
		{
		    putc(c, code_file);
		    if (dflag) putc(c, defines_file);
d850 17
a866 31
	    }
	    else
	    {
		do
		{
		    putc(c, code_file);
		    if (dflag) putc(c, defines_file);
		}
		while ((c = (unsigned char)*++s));
	    }
	    ++outline;
	    fprintf(code_file, " %d\n", symbol_value[i]);
	    if (dflag) fprintf(defines_file, " %d\n", symbol_value[i]);
	}
    }

    ++outline;
    fprintf(code_file, "#define YYERRCODE %d\n", symbol_value[1]);

    if (dflag && unionized)
    {
	fclose(union_file);
	union_file = fopen(union_file_name, "r");
	if (union_file == NULL) open_error(union_file_name);
	while ((c = getc(union_file)) != EOF)
	    putc(c, defines_file);
	fprintf(defines_file, " YYSTYPE;\n");
	fprintf(defines_file, "#endif /* YYSTYPE_DEFINED */\n");
	fprintf(defines_file, "extern YYSTYPE %slval;\n",
		symbol_prefix);
    }
d873 2
a874 2
    int c;
    FILE *in, *out;
d876 10
a885 15
    fclose(text_file);
    text_file = fopen(text_file_name, "r");
    if (text_file == NULL)
	open_error(text_file_name);
    in = text_file;
    if ((c = getc(in)) == EOF)
	return;
    out = code_file;
    if (c ==  '\n')
	++outline;
    putc(c, out);
    while ((c = getc(in)) != EOF)
    {
	if (c == '\n')
	    ++outline;
d887 7
a893 3
    }
    if (!lflag)
	fprintf(out, line_format, ++outline + 1, code_file_name);
d900 2
a901 2
    int i, j, k, max;
    char **symnam, *s;
d903 4
a906 7
    ++outline;
    fprintf(code_file, "#define YYFINAL %d\n", final_state);
    outline += 3;
    fprintf(code_file, "#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n",
	    tflag);
    if (rflag)
	fprintf(output_file, "#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n",
d908 107
a1014 86

    max = 0;
    for (i = 2; i < ntokens; ++i)
	if (symbol_value[i] > max)
	    max = symbol_value[i];
    ++outline;
    fprintf(code_file, "#define YYMAXTOKEN %d\n", max);

    symnam = (char **) calloc(max+1, sizeof(char *));
    if (symnam == 0) no_space();

    for (i = ntokens - 1; i >= 2; --i)
	symnam[symbol_value[i]] = symbol_name[i];
    symnam[0] = "end-of-file";

    if (!rflag) ++outline;
    fprintf(output_file,
	"#if YYDEBUG\n"
	"const char * const %sname[] =\n"
	"\t{", symbol_prefix);
    j = 80;
    for (i = 0; i <= max; ++i)
    {
	if ((s = symnam[i]) != '\0')
	{
	    if (s[0] == '"')
	    {
		k = 7;
		while (*++s != '"')
		{
		    ++k;
		    if (*s == '\\')
		    {
			k += 2;
			if (*++s == '\\')
			    ++k;
		    }
		}
		j += k;
		if (j > 80)
		{
		    if (!rflag) ++outline;
		    putc('\n', output_file);
		    j = k;
		}
		fprintf(output_file, "\"\\\"");
		s = symnam[i];
		while (*++s != '"')
		{
		    if (*s == '\\')
		    {
			fprintf(output_file, "\\\\");
			if (*++s == '\\')
			    fprintf(output_file, "\\\\");
			else
			    putc(*s, output_file);
		    }
		    else
			putc(*s, output_file);
		}
		fprintf(output_file, "\\\"\",");
	    }
	    else if (s[0] == '\'')
	    {
		if (s[1] == '"')
		{
		    j += 7;
		    if (j > 80)
		    {
			if (!rflag) ++outline;
			putc('\n', output_file);
			j = 7;
		    }
		    fprintf(output_file, "\"'\\\"'\",");
		}
		else
		{
		    k = 5;
		    while (*++s != '\'')
		    {
			++k;
			if (*s == '\\')
			{
			    k += 2;
			    if (*++s == '\\')
				++k;
d1016 6
a1021 19
		    }
		    j += k;
		    if (j > 80)
		    {
			if (!rflag) ++outline;
			putc('\n', output_file);
			j = k;
		    }
		    fprintf(output_file, "\"'");
		    s = symnam[i];
		    while (*++s != '\'')
		    {
			if (*s == '\\')
			{
			    fprintf(output_file, "\\\\");
			    if (*++s == '\\')
				fprintf(output_file, "\\\\");
			    else
				putc(*s, output_file);
d1023 1
a1023 4
			else
			    putc(*s, output_file);
		    }
		    fprintf(output_file, "'\",");
d1025 44
a1068 10
	    }
	    else
	    {
		k = strlen(s) + 3;
		j += k;
		if (j > 80)
		{
		    if (!rflag) ++outline;
		    putc('\n', output_file);
		    j = k;
d1070 3
a1072 4
		putc('"', output_file);
		do { putc(*s, output_file); } while (*++s);
		fprintf(output_file, "\",");
	    }
a1073 68
	else
	{
	    j += 2;
	    if (j > 80)
	    {
		if (!rflag) ++outline;
		putc('\n', output_file);
		j = 2;
	    }
	    fprintf(output_file, "0,");
	}
    }
    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    free(symnam);

    if (!rflag) ++outline;
    fprintf(output_file,
	"const char * const %srule[] =\n"
	"\t{", symbol_prefix);
    for (i = 2; i < nrules; ++i)
    {
	fprintf(output_file, "\"%s :", symbol_name[rlhs[i]]);
	for (j = rrhs[i]; ritem[j] > 0; ++j)
	{
	    s = symbol_name[ritem[j]];
	    if (s[0] == '"')
	    {
		fprintf(output_file, " \\\"");
		while (*++s != '"')
		{
		    if (*s == '\\')
		    {
			if (s[1] == '\\')
			    fprintf(output_file, "\\\\\\\\");
			else
			    fprintf(output_file, "\\\\%c", s[1]);
			++s;
		    }
		    else
			putc(*s, output_file);
		}
		fprintf(output_file, "\\\"");
	    }
	    else if (s[0] == '\'')
	    {
		if (s[1] == '"')
		    fprintf(output_file, " '\\\"'");
		else if (s[1] == '\\')
		{
		    if (s[2] == '\\')
			fprintf(output_file, " '\\\\\\\\");
		    else
			fprintf(output_file, " '\\\\%c", s[2]);
		    s += 2;
		    while (*++s != '\'')
			putc(*s, output_file);
		    putc('\'', output_file);
		}
		else
		    fprintf(output_file, " '%c'", s[1]);
	    }
	    else
		fprintf(output_file, " %s", s);
	}
	if (!rflag) ++outline;
	fprintf(output_file, "\",\n");
    }
d1075 3
a1077 2
    if (!rflag) outline += 2;
    fprintf(output_file, "};\n#endif\n");
d1084 4
a1087 5
    if (!unionized && ntags == 0)
    {
	outline += 3;
	fprintf(code_file, "#ifndef YYSTYPE\ntypedef int YYSTYPE;\n#endif\n");
    }
d1094 2
a1095 2
    int c, last;
    FILE *in, *out;
d1097 2
a1098 2
    if (line == 0)
	return;
d1100 38
a1137 12
    in = input_file;
    out = code_file;
    c = (unsigned char)*cptr;
    if (c == '\n')
    {
	++lineno;
	if ((c = getc(in)) == EOF)
	    return;
	if (!lflag)
	{
	    ++outline;
	    fprintf(out, line_format, lineno, input_file_name);
a1138 7
	if (c == '\n')
	    ++outline;
	putc(c, out);
	last = c;
    }
    else
    {
d1140 1
a1140 25
	{
	    ++outline;
	    fprintf(out, line_format, lineno, input_file_name);
	}
	do { putc(c, out); } while ((c = (unsigned char)*++cptr) != '\n');
	++outline;
	putc('\n', out);
	last = '\n';
    }

    while ((c = getc(in)) != EOF)
    {
	if (c == '\n')
	    ++outline;
	putc(c, out);
	last = c;
    }

    if (last != '\n')
    {
	++outline;
	putc('\n', out);
    }
    if (!lflag)
	fprintf(out, line_format, ++outline + 1, code_file_name);
d1147 7
a1153 2
    int c, last;
    FILE *out;
d1155 5
a1159 15
    fclose(action_file);
    action_file = fopen(action_file_name, "r");
    if (action_file == NULL)
	open_error(action_file_name);

    if ((c = getc(action_file)) == EOF)
	return;

    out = code_file;
    last = c;
    if (c == '\n')
	++outline;
    putc(c, out);
    while ((c = getc(action_file)) != EOF)
    {
d1161 1
a1161 1
	    ++outline;
d1163 6
a1168 2
	last = c;
    }
d1170 4
a1173 5
    if (last != '\n')
    {
	++outline;
	putc('\n', out);
    }
d1175 2
a1176 2
    if (!lflag)
	fprintf(out, line_format, ++outline + 1, code_file_name);
d1183 1
a1183 1
    core *cp, *next;
d1185 3
a1187 3
    free(state_table);
    for (cp = first_state; cp; cp = next)
    {
d1190 1
a1190 1
    }
d1197 1
a1197 1
    shifts *sp, *next;
d1199 5
a1203 6
    free(shift_table);
    for (sp = first_shift; sp; sp = next)
    {
	next = sp->next;
	free(sp);
    }
d1211 1
a1211 1
    reductions *rp, *next;
d1213 5
a1217 6
    free(reduction_table);
    for (rp = first_reduction; rp; rp = next)
    {
	next = rp->next;
	free(rp);
    }
@


1.19
log
@Add casts to unsigned char for ctype functions and other places
where a char is stored in an int.  Joint work with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.18 2014/01/08 22:36:37 millert Exp $	*/
a175 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d177 1
a177 4
	"#else\n"
	"short %slhs[] =\n"
	"#endif\n"
	"\t{%42d,", symbol_prefix, symbol_prefix, symbol_value[start_symbol]);
a196 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d198 1
a198 4
	"#else\n"
	"short %slen[] =\n"
	"#endif\n"
	"\t{%42d,", symbol_prefix, symbol_prefix, 2);
a224 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
a225 3
	"#else\n"
	"short %sdefred[] =\n"
	"#endif\n"
d227 1
a227 1
	symbol_prefix, symbol_prefix, (defred[0] ? defred[0] - 2 : 0));
a371 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d373 1
a373 4
	"#else\n"
	"short %sdgoto[] =\n"
	"#endif\n"
	"\t{%40d,", symbol_prefix, symbol_prefix, k);
a695 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d697 1
a697 4
	"#else\n"
	"short %ssindex[] =\n"
	"#endif\n"
	"\t{%39d,", symbol_prefix, symbol_prefix, base[0]);
a716 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d718 1
a718 4
	"#else\n"
	"short %srindex[] =\n"
	"#endif\n"
	"\t{%39d,", symbol_prefix, symbol_prefix, base[nstates]);
a737 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d739 1
a739 4
	"#else\n"
	"short %sgindex[] =\n"
	"#endif\n"
	"\t{%39d,", symbol_prefix, symbol_prefix, base[2*nstates]);
a770 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d772 1
a772 4
	"#else\n"
	"short %stable[] =\n"
	"#endif\n"
	"\t{%40d,", symbol_prefix, symbol_prefix, table[0]);
a801 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d803 1
a803 4
	"#else\n"
	"short %scheck[] =\n"
	"#endif\n"
	"\t{%40d,", symbol_prefix, symbol_prefix, check[0]);
a972 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d974 1
a974 4
	"#else\n"
	"char *%sname[] =\n"
	"#endif\n"
	"\t{", symbol_prefix, symbol_prefix);
a1100 1
	"#if defined(__cplusplus) || defined(__STDC__)\n"
d1102 1
a1102 4
	"#else\n"
	"char *%srule[] =\n"
	"#endif\n"
	"\t{", symbol_prefix, symbol_prefix);
@


1.18
log
@Use calloc() instead of malloc() + memset.  Based on a diff from
Michael W. Bombardieri.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.17 2014/01/08 21:40:25 millert Exp $	*/
d869 1
a869 1
    c = *s;
d872 1
a872 1
	c = *++s;
d875 1
a875 1
	while ((c = *++s) != '"')
d885 1
a885 1
    while ((c = *++s))
d907 1
a907 1
	    c = *s;
d910 1
a910 1
		while ((c = *++s) != '"')
d923 1
a923 1
		while ((c = *++s));
d1223 1
a1223 1
    c = *cptr;
d1246 1
a1246 1
	do { putc(c, out); } while ((c = *++cptr) != '\n');
@


1.17
log
@Remove CALLOC, MALLOC, FREE and REALLOC macros and just call calloc(),
nalloc(), free() and realloc() directly.  The macros were casting
to the wrong (pre-C89) types and there is no need for them in a C89
world.  OK matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.16 2012/03/03 19:15:00 nicm Exp $	*/
d999 1
a999 1
    symnam = (char **) malloc((max+1)*sizeof(char *));
a1001 3
    /* Note that it is  not necessary to initialize the element		*/
    /* symnam[max].							*/
    memset(symnam, 0, max * sizeof(char *));
@


1.16
log
@Replace some loops with calloc/memset. From Michael W Bombardieri.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.15 2009/10/27 23:59:50 deraadt Exp $	*/
d272 4
a275 4
    FREE(lookaheads);
    FREE(LA);
    FREE(LAruleno);
    FREE(accessing_symbol);
d278 3
a280 3
    FREE(goto_map + ntokens);
    FREE(from_state);
    FREE(to_state);
d372 1
a372 1
    FREE(actionrow);
d411 1
a411 1
    FREE(state_count);
d562 1
a562 1
	    FREE(froms[i]);
d564 1
a564 1
	    FREE(tos[i]);
d567 3
a569 3
    FREE(froms);
    FREE(tos);
    FREE(pos);
d666 1
a666 1
		table = (short *) REALLOC(table, newmax*sizeof(short));
d668 1
a668 1
		check = (short *) REALLOC(check, newmax*sizeof(short));
d786 1
a786 1
    FREE(base);
d823 1
a823 1
    FREE(table);
d858 1
a858 1
    FREE(check);
d999 1
a999 1
    symnam = (char **) MALLOC((max+1)*sizeof(char *));
d1140 1
a1140 1
    FREE(symnam);
d1316 1
a1316 1
    FREE(state_table);
d1320 1
a1320 1
	FREE(cp);
d1330 1
a1330 1
    FREE(shift_table);
d1334 1
a1334 1
	FREE(sp);
d1345 1
a1345 1
    FREE(reduction_table);
d1349 1
a1349 1
	FREE(rp);
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.14 2005/06/10 16:40:45 pvalchev Exp $	*/
d428 1
a428 2
    for (i = 0; i < nstates; i++)
	state_count[i] = 0;
d1004 1
a1004 2
    for (i = 0; i < max; ++i)
	symnam[i] = 0;
@


1.14
log
@-Wall clean; ok otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.13 2004/08/08 20:13:13 deraadt Exp $	*/
a34 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)output.c	5.7 (Berkeley) 5/24/93";
#else
static char rcsid[] = "$OpenBSD: output.c,v 1.13 2004/08/08 20:13:13 deraadt Exp $";
#endif
#endif /* not lint */
@


1.13
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.12 2004/01/06 05:35:26 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: output.c,v 1.12 2004/01/06 05:35:26 deraadt Exp $";
d894 1
a894 1
    while (c = *++s)
d932 1
a932 1
		while (c = *++s);
@


1.12
log
@protect output from %union from being anonymous using cpp guarding, for
the case where the yacc output .c file pulls in the yacc output -h file;
espie ok
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.11 2003/06/19 16:34:53 pvalchev Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: output.c,v 1.11 2003/06/19 16:34:53 pvalchev Exp $";
a182 1
 
@


1.11
log
@ansify; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.10 2003/06/03 02:56:24 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: output.c,v 1.10 2003/06/03 02:56:24 millert Exp $";
d951 3
a953 1
	fprintf(defines_file, " YYSTYPE;\nextern YYSTYPE %slval;\n",
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.9 2002/12/03 21:34:21 mickey Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: output.c,v 1.9 2002/12/03 21:34:21 mickey Exp $";
d89 1
a89 1
output()
d113 1
a113 1
output_prefix()
d178 1
a178 1
output_rule_data()
d237 1
a237 1
output_yydefred()
d271 1
a271 1
output_actions()
d300 1
a300 1
token_actions()
d385 1
a385 1
goto_actions()
d424 1
a424 2
default_goto(symbol)
int symbol;
d460 1
a460 3
save_column(symbol, default_state)
int symbol;
int default_state;
d501 1
a501 1
sort_actions()
d537 1
a537 1
pack_table()
d600 1
a600 2
matching_vector(vector)
int vector;
d640 1
a640 2
pack_vector(vector)
int vector;
d717 1
a717 1
output_base()
a799 1

d801 1
a801 1
output_table()
a836 1

d838 1
a838 1
output_check()
d873 1
a873 2
is_C_identifier(name)
char *name;
d905 1
a905 1
output_defines()
d958 1
a958 1
output_stored_text()
d986 1
a986 1
output_debug()
d1214 1
a1214 1
output_stype()
d1225 1
a1225 1
output_trailing_text()
d1283 1
a1283 1
output_semantic_actions()
d1321 1
a1321 1
free_itemsets()
d1335 1
a1335 1
free_shifts()
d1350 1
a1350 1
free_reductions()
@


1.9
log
@constify the not yet constified tables, use defined(__STDC__) instead of ifdef __STC__ where appropriate; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.8 2002/02/16 21:28:00 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: output.c,v 1.8 2002/02/16 21:28:00 millert Exp $";
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.7 2001/11/19 19:02:18 mpech Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: output.c,v 1.7 2001/11/19 19:02:18 mpech Exp $";
d187 8
a194 3
  
    fprintf(output_file, "short %slhs[] = {%42d,", symbol_prefix,
	    symbol_value[start_symbol]);
d213 7
a219 1
    fprintf(output_file, "short %slen[] = {%42d,", symbol_prefix, 2);
d245 8
a252 2
    fprintf(output_file, "short %sdefred[] = {%39d,", symbol_prefix,
	    (defred[0] ? defred[0] - 2 : 0));
d396 7
a402 1
    fprintf(output_file, "short %sdgoto[] = {%40d,", symbol_prefix, k);
d730 7
a736 1
    fprintf(output_file, "short %ssindex[] = {%39d,", symbol_prefix, base[0]);
d754 8
a761 2
    fprintf(output_file, "\n};\nshort %srindex[] = {%39d,", symbol_prefix,
	    base[nstates]);
d779 8
a786 2
    fprintf(output_file, "\n};\nshort %sgindex[] = {%39d,", symbol_prefix,
	    base[2*nstates]);
d818 7
a824 2
    fprintf(output_file, "short %stable[] = {%40d,", symbol_prefix,
	    table[0]);
d854 7
a860 2
    fprintf(output_file, "short %scheck[] = {%40d,", symbol_prefix,
	    check[0]);
d1031 8
a1038 1
    fprintf(output_file, "#if YYDEBUG\n#if defined(__cplusplus) || __STDC__\nconst char * const %sname[] =\n#else\nchar *%sname[] =\n#endif\n\t{", symbol_prefix, symbol_prefix);
d1164 7
a1170 1
    fprintf(output_file, "#if defined(__cplusplus) || __STDC__\nconst char * const %srule[] =\n#else\nchar *%srule[] =\n#endif\n\t{", symbol_prefix, symbol_prefix);
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.6 2001/07/16 06:29:45 pvalchev Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: output.c,v 1.6 2001/07/16 06:29:45 pvalchev Exp $";
d66 25
a90 25
void output_prefix __P((void));
void output_rule_data __P((void));
void output_yydefred __P((void));
void output_actions __P((void));
void token_actions __P((void));
void goto_actions __P((void));
int default_goto __P((int));
void save_column __P((int, int));
void sort_actions __P((void));
void pack_table __P((void));
int matching_vector __P((int));
int pack_vector __P((int));
void output_base __P((void));
void output_table __P((void));
void output_check __P((void));
int is_C_identifier __P((char *));
void output_defines __P((void));
void output_stored_text __P((void));
void output_debug __P((void));
void output_stype __P((void));
void output_trailing_text __P((void));
void output_semantic_actions __P((void));
void free_itemsets __P((void));
void free_shifts __P((void));
void free_reductions __P((void));
@


1.6
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.5 2001/02/26 00:03:32 tholo Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: output.c,v 1.5 2001/02/26 00:03:32 tholo Exp $";
d184 2
a185 2
    register int i;
    register int j;
d232 1
a232 1
    register int i, j;
d289 5
a293 5
    register int i, j;
    register int shiftcount, reducecount;
    register int max, min;
    register short *actionrow, *r, *s;
    register action *p;
d374 1
a374 1
    register int i, j, k;
d408 5
a412 5
    register int i;
    register int m;
    register int n;
    register int default_state;
    register int max;
d446 8
a453 8
    register int i;
    register int m;
    register int n;
    register short *sp;
    register short *sp1;
    register short *sp2;
    register int count;
    register int symno;
d487 5
a491 5
  register int i;
  register int j;
  register int k;
  register int t;
  register int w;
d523 3
a525 3
    register int i;
    register int place;
    register int state;
d587 7
a593 7
    register int i;
    register int j;
    register int k;
    register int t;
    register int w;
    register int match;
    register int prev;
d628 6
a633 6
    register int i, j, k, l;
    register int t;
    register int loc;
    register int ok;
    register short *from;
    register short *to;
d705 1
a705 1
    register int i, j;
d772 2
a773 2
    register int i;
    register int j;
d805 2
a806 2
    register int i;
    register int j;
d836 2
a837 2
    register char *s;
    register int c;
d868 2
a869 2
    register int c, i;
    register char *s;
d921 2
a922 2
    register int c;
    register FILE *in, *out;
d949 1
a949 1
    register int i, j, k, max;
d1175 2
a1176 2
    register int c, last;
    register FILE *in, *out;
d1233 2
a1234 2
    register int c, last;
    register FILE *out;
d1271 1
a1271 1
    register core *cp, *next;
d1285 1
a1285 1
    register shifts *sp, *next;
d1300 1
a1300 1
    register reductions *rp, *next;
@


1.5
log
@Silence some warnings in generated grammers compiled with YYDEBUG;
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.4 1996/12/06 12:07:13 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: output.c,v 1.4 1996/12/06 12:07:13 deraadt Exp $";
d66 25
d92 1
d116 1
d181 1
d229 1
d257 1
d286 1
d371 1
d441 1
d484 1
d520 1
d702 1
d769 1
d802 1
d865 1
d918 1
d946 1
d984 1
a984 1
	if (s = symnam[i])
d1161 1
d1172 1
d1230 1
d1268 1
d1282 1
d1297 1
@


1.4
log
@-p did not rename 2 variables; netbsd pr#2997, mike.long@@analog.com
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.3 1996/06/26 05:44:39 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: output.c,v 1.3 1996/06/26 05:44:39 deraadt Exp $";
d939 1
a939 1
    fprintf(output_file, "#if YYDEBUG\nchar *%sname[] = {", symbol_prefix);
d1065 1
a1065 1
    fprintf(output_file, "char *%srule[] = {\n", symbol_prefix);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: output.c,v 1.4 1996/03/19 03:21:41 jtc Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: output.c,v 1.4 1996/03/19 03:21:41 jtc Exp $";
d117 2
d124 2
@


1.2
log
@sync to netbsd 960418
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: output.c,v 1.4 1996/03/19 03:21:41 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 38
d40 5
a44 1
static char rcsid[] = "$Id: output.c,v 1.3 1993/08/02 17:56:43 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
